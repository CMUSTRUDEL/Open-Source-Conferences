Title: Making OpenBSD Useful on the Octeon Network Gear - Paul Irofti
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

My work on the Octeon port made possible for OpenBSD to run on the D-Link DSR line of mid-range routers and also improved all supported models through the drivers I wrote. I’m continuing my work on improving the OpenBSD experience on the Octeon products by enhancing network support (including advanced switch support among other things) and adding disk support via USB and CFI. This presentation summarizes the developments I brought and the obstacles I faced.

Speaker biography:

Paul is an OpenBSD developer since 2008, involved in ACPI, suspend and resume, power management, mips64, porting and currently with a keen interest in the Loongson and Octeon platforms. Currently he’s a freelancer and also studying for his PhD in Parallel Algorithms for Signal Processing. In the past he worked for a telephony company developing VoIP, Voicemail and related software and after that as an antivirus engine developer and reverse engineer. In his spare time he enjoys a good game of Go, running or hiking.
Captions: 
	00:00:05,690 --> 00:00:26,730
oh one time I think I only introduces

00:00:15,660 --> 00:00:29,880
himself as well my name is Paul Yadav

00:00:26,730 --> 00:00:35,880
tea and today I want to talk about the

00:00:29,880 --> 00:00:39,629
work I did on algae on machines I want

00:00:35,880 --> 00:00:42,510
to take you through the drivers and the

00:00:39,629 --> 00:00:47,000
obstacles that I faced during the last

00:00:42,510 --> 00:00:51,930
year or maybe year and a half now and

00:00:47,000 --> 00:00:58,859
I'm gonna wrap it up with what's coming

00:00:51,930 --> 00:01:03,030
to OpenBSD port Who am I I'm a reverse

00:00:58,859 --> 00:01:07,020
engineer I work for six years now in the

00:01:03,030 --> 00:01:11,729
anti virus in industry I designed an

00:01:07,020 --> 00:01:14,280
emulator for anti viruses and I also

00:01:11,729 --> 00:01:15,650
wrote different static and dynamic

00:01:14,280 --> 00:01:19,860
engines

00:01:15,650 --> 00:01:25,619
I'm also an open BSD hacker since 2008 I

00:01:19,860 --> 00:01:29,970
think and I didn't really find a single

00:01:25,619 --> 00:01:32,549
spot on which to focus on open BSD so I

00:01:29,970 --> 00:01:35,460
started with with really easy stuff like

00:01:32,549 --> 00:01:37,140
a CPI and power management coming from

00:01:35,460 --> 00:01:40,140
reverse engineering background

00:01:37,140 --> 00:01:45,540
it looked appealing little did I know

00:01:40,140 --> 00:01:49,590
though and then I moved to London which

00:01:45,540 --> 00:01:52,979
is a 64 machine that the Chinese produce

00:01:49,590 --> 00:01:56,100
and it's supposed to be entirely open

00:01:52,979 --> 00:01:59,100
sourced and as far as Hardware goes but

00:01:56,100 --> 00:02:00,990
of course it's not because there's one

00:01:59,100 --> 00:02:04,200
piece there which is called the embedded

00:02:00,990 --> 00:02:06,149
controller which does just that embeds

00:02:04,200 --> 00:02:07,920
all the control in a single chip of the

00:02:06,149 --> 00:02:11,760
entire machine and it's not documented

00:02:07,920 --> 00:02:13,890
so that was supposed to be fun ended up

00:02:11,760 --> 00:02:15,360
not being so much fun but I

00:02:13,890 --> 00:02:17,010
at the end of the road you say yeah I

00:02:15,360 --> 00:02:19,680
did that it was nice so it was

00:02:17,010 --> 00:02:23,190
fulfilling in the end and because of

00:02:19,680 --> 00:02:27,360
that I got to see how the mips64 machine

00:02:23,190 --> 00:02:30,020
works I moved on to octi on later on but

00:02:27,360 --> 00:02:34,920
in the meantime I also do compact Linux

00:02:30,020 --> 00:02:39,510
support for open BSD because well when I

00:02:34,920 --> 00:02:42,030
first started working at BitDefender I

00:02:39,510 --> 00:02:44,130
want to use open BSD and the ID a which

00:02:42,030 --> 00:02:47,700
is a reverse engineering tool was

00:02:44,130 --> 00:02:49,739
working on open BSD so I used but they

00:02:47,700 --> 00:02:52,800
have it they have a port for Linux so I

00:02:49,739 --> 00:02:55,830
used compat Linux for that and it used

00:02:52,800 --> 00:02:57,269
to work I haven't I haven't used it for

00:02:55,830 --> 00:03:01,050
a few years now I don't know if recent

00:02:57,269 --> 00:03:05,610
versions work but they should and also i

00:03:01,050 --> 00:03:08,340
port miscellaneous applications to open

00:03:05,610 --> 00:03:11,970
BSD which is the most fun thing to do

00:03:08,340 --> 00:03:15,030
because it's a lot easier than the rest

00:03:11,970 --> 00:03:17,730
and you actually get to see things

00:03:15,030 --> 00:03:21,090
working not just panics and blue

00:03:17,730 --> 00:03:21,750
messages popping at you and if that

00:03:21,090 --> 00:03:27,230
wasn't enough

00:03:21,750 --> 00:03:29,820
I'm also following a PhD in a very

00:03:27,230 --> 00:03:32,010
connect very well connected subject of

00:03:29,820 --> 00:03:34,350
parallel computing on the GPUs which has

00:03:32,010 --> 00:03:35,730
nothing to do with anything so far but

00:03:34,350 --> 00:03:38,549
it's very interesting as well I do

00:03:35,730 --> 00:03:42,209
signal processing and I'm about to

00:03:38,549 --> 00:03:44,600
finish my PhD I have some courses on

00:03:42,209 --> 00:03:48,840
parallel programming at the faculty of

00:03:44,600 --> 00:03:51,840
computer science in Bucharest so that's

00:03:48,840 --> 00:03:56,610
about it once a year I go out and have

00:03:51,840 --> 00:04:00,510
fun how did I get in touch with octi on

00:03:56,610 --> 00:04:03,030
it was almost random as I said I played

00:04:00,510 --> 00:04:05,280
where father made 64 ports I tried HDI

00:04:03,030 --> 00:04:08,130
for a bit but I couldn't get it working

00:04:05,280 --> 00:04:09,239
the model I had and me odd finally did

00:04:08,130 --> 00:04:13,410
that for me so it wasn't interesting

00:04:09,239 --> 00:04:15,510
anymore but then I had a first contact

00:04:13,410 --> 00:04:21,120
with octi on during the Toronto

00:04:15,510 --> 00:04:22,979
hackathon which is which was a very good

00:04:21,120 --> 00:04:24,930
hackathon for me but had nothing to do

00:04:22,979 --> 00:04:27,300
with out Kyong besides the fact that I

00:04:24,930 --> 00:04:27,830
sit next to Jasper who was hacking on

00:04:27,300 --> 00:04:33,830
this

00:04:27,830 --> 00:04:34,909
box always mumbling stuff in net Dutch

00:04:33,830 --> 00:04:38,360
yes thank you

00:04:34,909 --> 00:04:41,270
I was Netherland these know Dutch Thanks

00:04:38,360 --> 00:04:44,300
and I like when I see people angry

00:04:41,270 --> 00:04:46,969
because I can I can understand that and

00:04:44,300 --> 00:04:48,259
I can relate to that so I kept asking

00:04:46,969 --> 00:04:49,639
him what's going on and he was working

00:04:48,259 --> 00:04:52,520
on a boot loader for this ah Keung

00:04:49,639 --> 00:04:55,849
machine and it was really interesting I

00:04:52,520 --> 00:04:57,979
I was mostly looking at his console

00:04:55,849 --> 00:05:00,979
output and following my work for a few

00:04:57,979 --> 00:05:03,500
days but that got me interested and I

00:05:00,979 --> 00:05:06,280
brought small phrase in the under Atlee

00:05:03,500 --> 00:05:10,629
report which is the OpenBSD journal

00:05:06,280 --> 00:05:13,940
about this experience and diana which

00:05:10,629 --> 00:05:16,430
was kind enough to write me an e-mail

00:05:13,940 --> 00:05:19,190
right away so do you want one or what

00:05:16,430 --> 00:05:21,860
and I was like oh ok I didn't even think

00:05:19,190 --> 00:05:24,529
about that I was just telling a story

00:05:21,860 --> 00:05:27,219
about the hackathon and soon enough I

00:05:24,529 --> 00:05:33,680
got a DSR 500 machine which is a d-link

00:05:27,219 --> 00:05:37,270
router switch that's based on a key on

00:05:33,680 --> 00:05:40,729
and that's how the nightmare started

00:05:37,270 --> 00:05:46,520
because I was looking forward to this

00:05:40,729 --> 00:05:49,759
and the first thing to do when you get a

00:05:46,520 --> 00:05:51,710
box is open it and then try to boot

00:05:49,759 --> 00:05:53,240
whatever is in there but of course it

00:05:51,710 --> 00:05:54,949
was running you boot which is very

00:05:53,240 --> 00:05:57,500
popular with armed people and you can

00:05:54,949 --> 00:05:59,900
see that because you boot has a thousand

00:05:57,500 --> 00:06:01,729
variations just like arms so there's no

00:05:59,900 --> 00:06:03,500
coherency you can't read a single

00:06:01,729 --> 00:06:05,750
document and see how you're able to

00:06:03,500 --> 00:06:08,810
program that so I was lucky enough to

00:06:05,750 --> 00:06:12,319
learn how to boot a kernel through other

00:06:08,810 --> 00:06:15,620
people's work and hair loss since I have

00:06:12,319 --> 00:06:17,479
enough hair now but me odd was not so

00:06:15,620 --> 00:06:20,150
lucky and he wrote most of the

00:06:17,479 --> 00:06:20,900
instructions that don't really make

00:06:20,150 --> 00:06:25,819
sense

00:06:20,900 --> 00:06:28,129
typing boot octi on Linux - BSD is kind

00:06:25,819 --> 00:06:30,199
of schizophrenic but anyway once I got

00:06:28,129 --> 00:06:32,060
through that I managed to go all the way

00:06:30,199 --> 00:06:34,659
through the copyright and then the

00:06:32,060 --> 00:06:36,740
kernel crashed which was awesome

00:06:34,659 --> 00:06:38,180
actually I'm really excited when I see

00:06:36,740 --> 00:06:41,330
that because I get to fix things and I

00:06:38,180 --> 00:06:43,550
get to I get to

00:06:41,330 --> 00:06:47,870
talk about things and visit nice places

00:06:43,550 --> 00:06:49,640
like Bulgaria and meet you guys so I

00:06:47,870 --> 00:06:57,110
knew this was coming when I saw that

00:06:49,640 --> 00:07:00,640
crash so I looking at getting past the

00:06:57,110 --> 00:07:03,410
copyright which is not so interesting I

00:07:00,640 --> 00:07:08,150
had to look at how Jackie on my memory

00:07:03,410 --> 00:07:09,980
is organized and it's split into chunks

00:07:08,150 --> 00:07:12,830
you don't really expect to have a lot of

00:07:09,980 --> 00:07:19,610
memory anunnaki on machine so you have

00:07:12,830 --> 00:07:24,020
different chunks of buffers that memory

00:07:19,610 --> 00:07:26,690
gets mapped onto so as you can see you

00:07:24,020 --> 00:07:30,500
got the first range which is the first

00:07:26,690 --> 00:07:34,670
20 256 Meg the second range and then

00:07:30,500 --> 00:07:38,540
what whatever else is above 512 gets

00:07:34,670 --> 00:07:42,020
mapped in the last section but my DSR

00:07:38,540 --> 00:07:46,790
500 had 128 Meg and nobody expected that

00:07:42,020 --> 00:07:49,610
because we're in 2010 Plus and it was a

00:07:46,790 --> 00:07:54,560
small system memory and the code the

00:07:49,610 --> 00:07:57,800
kernel assumed that the memory should at

00:07:54,560 --> 00:08:01,700
least have 256 Meg and it was during

00:07:57,800 --> 00:08:04,760
this substitution this abstraction here

00:08:01,700 --> 00:08:08,120
which of course ended up with me having

00:08:04,760 --> 00:08:13,340
terabytes or petabytes of RAM because it

00:08:08,120 --> 00:08:13,790
overflowed so fixing that I got a big

00:08:13,340 --> 00:08:15,350
reward

00:08:13,790 --> 00:08:17,390
but I was a bit scared because I got all

00:08:15,350 --> 00:08:20,990
the way to use al and so there was

00:08:17,390 --> 00:08:22,700
nothing to fix so we're free slides in I

00:08:20,990 --> 00:08:26,870
couldn't present something with only

00:08:22,700 --> 00:08:31,190
free slides so but I was kind of happy

00:08:26,870 --> 00:08:34,700
and I started looking at Adi method for

00:08:31,190 --> 00:08:36,410
more problems and there were plenty even

00:08:34,700 --> 00:08:38,810
though the D message is really short if

00:08:36,410 --> 00:08:42,260
you're used to aim D 6040 messages which

00:08:38,810 --> 00:08:44,950
take like 10 pages this was like a less

00:08:42,260 --> 00:08:47,770
than the screen which is very nice

00:08:44,950 --> 00:08:52,310
because you can see it all at once so

00:08:47,770 --> 00:08:54,110
first of all opt CF is short for octi on

00:08:52,310 --> 00:08:56,600
compact flash

00:08:54,110 --> 00:08:58,040
which is not configured so no internal

00:08:56,600 --> 00:09:01,010
memory awesome

00:08:58,040 --> 00:09:03,829
this memory address conflict coming from

00:09:01,010 --> 00:09:07,700
a the pci address space which i still

00:09:03,829 --> 00:09:09,980
haven't fixed today and then there's the

00:09:07,700 --> 00:09:12,529
fie to which the network was connecting

00:09:09,980 --> 00:09:14,810
to that the network adapter was

00:09:12,529 --> 00:09:17,510
connecting to and that that means

00:09:14,810 --> 00:09:22,850
unknown five so there were some problems

00:09:17,510 --> 00:09:24,560
there so I was kind of starting to get a

00:09:22,850 --> 00:09:26,779
bit excited about the machine again and

00:09:24,560 --> 00:09:28,430
also there was no symbol table what that

00:09:26,779 --> 00:09:31,070
means is that when you get a crash

00:09:28,430 --> 00:09:34,490
you only get hexadecimal output on your

00:09:31,070 --> 00:09:36,500
screen no symbols that means note now no

00:09:34,490 --> 00:09:38,779
trace no parsable

00:09:36,500 --> 00:09:46,610
trace once you start reading in

00:09:38,779 --> 00:09:50,180
hexadecimal Cyrillic seems fun so where

00:09:46,610 --> 00:09:53,000
to from here I I wanted to add more

00:09:50,180 --> 00:09:56,589
drivers which I did and I'm gonna talk

00:09:53,000 --> 00:09:59,750
later on I wanted storage support and

00:09:56,589 --> 00:10:03,649
networking of course these things seem

00:09:59,750 --> 00:10:06,079
important for a port and I specially

00:10:03,649 --> 00:10:08,240
wanted to help Jasper to improve the

00:10:06,079 --> 00:10:10,579
second-stage boot loader in order to get

00:10:08,240 --> 00:10:15,560
the symbols and make my life easier

00:10:10,579 --> 00:10:17,930
which didn't happen until today but I we

00:10:15,560 --> 00:10:20,660
worked on the boot loader this year in

00:10:17,930 --> 00:10:24,649
summer and the hackathon in Ljubljana in

00:10:20,660 --> 00:10:26,540
Slovenia and it's getting there so the

00:10:24,649 --> 00:10:29,300
end goal being we should have a port

00:10:26,540 --> 00:10:32,690
that's able to stand on its own and the

00:10:29,300 --> 00:10:35,029
users which I hope to be amongst should

00:10:32,690 --> 00:10:37,760
be able to just create a cheap router or

00:10:35,029 --> 00:10:42,589
switch out of the Augean and get the

00:10:37,760 --> 00:10:45,560
sweet OpenBSD message from it so then

00:10:42,589 --> 00:10:48,410
when looking at drivers and implementing

00:10:45,560 --> 00:10:50,630
that I might have got my first major

00:10:48,410 --> 00:10:52,970
disappointment which is the SDK license

00:10:50,630 --> 00:10:56,720
that comes from the kayvyun people the

00:10:52,970 --> 00:11:00,230
guys that produce audience and they were

00:10:56,720 --> 00:11:01,880
very nice to open-source all their SDK

00:11:00,230 --> 00:11:04,160
for the drivers so you only need to call

00:11:01,880 --> 00:11:06,770
a few functions and hook them up to your

00:11:04,160 --> 00:11:07,820
kernel but the problem is that they have

00:11:06,770 --> 00:11:10,220
this

00:11:07,820 --> 00:11:15,080
it's almost like a BSD license except

00:11:10,220 --> 00:11:16,490
for the US export clause which we don't

00:11:15,080 --> 00:11:18,680
use in the project I don't want to get

00:11:16,490 --> 00:11:19,520
into politics because I don't understand

00:11:18,680 --> 00:11:23,360
them really

00:11:19,520 --> 00:11:25,220
but since the project decided that and I

00:11:23,360 --> 00:11:27,140
kind of agree with it we need to be

00:11:25,220 --> 00:11:28,790
coherent we have no such license in the

00:11:27,140 --> 00:11:33,460
tree I couldn't use it

00:11:28,790 --> 00:11:41,420
so I mailed the guys I sent an email I

00:11:33,460 --> 00:11:44,440
got a lot of replies towards zero I the

00:11:41,420 --> 00:11:47,390
weird thing is that the SDK covers USB

00:11:44,440 --> 00:11:49,190
random number generator

00:11:47,390 --> 00:11:51,950
I don't know network card everything

00:11:49,190 --> 00:11:53,960
every driver and they also have a crypto

00:11:51,950 --> 00:11:56,720
accelerator which I'm guessing it's why

00:11:53,960 --> 00:11:59,750
that Clause is there and I asked them if

00:11:56,720 --> 00:12:01,610
they can just resume that Clause to the

00:11:59,750 --> 00:12:04,310
crypto accelerator that they have on the

00:12:01,610 --> 00:12:06,290
chip but I got no answer

00:12:04,310 --> 00:12:08,000
because I think that's why that got

00:12:06,290 --> 00:12:12,050
there and then it was just copied over

00:12:08,000 --> 00:12:16,280
and over so I wanted to start with a

00:12:12,050 --> 00:12:21,430
simple driver because I wanted to see

00:12:16,280 --> 00:12:25,850
how the registers look and how Hawaii

00:12:21,430 --> 00:12:27,560
could use yaki on without the SDK so I

00:12:25,850 --> 00:12:30,410
wanted to start with a random number

00:12:27,560 --> 00:12:34,370
generator which should have been pretty

00:12:30,410 --> 00:12:36,740
easy because I just need to start it get

00:12:34,370 --> 00:12:43,430
the output and fit it to our random

00:12:36,740 --> 00:12:46,700
number subsystem so I started looking at

00:12:43,430 --> 00:12:50,270
the magical figures that yes DK is using

00:12:46,700 --> 00:12:55,790
for the control register for the random

00:12:50,270 --> 00:12:59,240
numbers and it's as easy as I expected

00:12:55,790 --> 00:13:01,520
you just read the control register make

00:12:59,240 --> 00:13:03,170
sure you set up the output you set the

00:13:01,520 --> 00:13:05,900
output at the entropy flag and just

00:13:03,170 --> 00:13:07,970
after you write it back you should get

00:13:05,900 --> 00:13:14,450
randomness from there on so if you just

00:13:07,970 --> 00:13:16,520
do this once during boot so the numbers

00:13:14,450 --> 00:13:17,660
are written in the entropy register

00:13:16,520 --> 00:13:21,680
which is different from the control one

00:13:17,660 --> 00:13:24,319
you fit it to our API for randomness

00:13:21,680 --> 00:13:29,059
and then you keep reading every 10

00:13:24,319 --> 00:13:31,269
milliseconds easy the obstacles I faced

00:13:29,059 --> 00:13:35,509
this was actually the driver that took

00:13:31,269 --> 00:13:41,839
most of my time I think was because of

00:13:35,509 --> 00:13:44,660
engine is so the the register addresses

00:13:41,839 --> 00:13:47,720
are written in a different engine in in

00:13:44,660 --> 00:13:50,470
the SDK then in then what you're

00:13:47,720 --> 00:13:54,649
supposed to fit their to fit to the

00:13:50,470 --> 00:13:56,509
control register so if you want to do an

00:13:54,649 --> 00:13:59,259
actual read and access register you're

00:13:56,509 --> 00:14:05,300
supposed to flip all the bits because

00:13:59,259 --> 00:14:08,829
that's why I don't know why so besides

00:14:05,300 --> 00:14:11,509
that there was a read after write

00:14:08,829 --> 00:14:13,579
required whenever you set the control

00:14:11,509 --> 00:14:14,720
register just to make sure it was

00:14:13,579 --> 00:14:16,970
actually written there which is not

00:14:14,720 --> 00:14:19,449
uncommon but still for something as

00:14:16,970 --> 00:14:22,459
simple as that I didn't expect and

00:14:19,449 --> 00:14:25,100
another when I finally got a driver I

00:14:22,459 --> 00:14:27,800
was feeling eight bytes of data but I

00:14:25,100 --> 00:14:29,929
was told that only four are needed to be

00:14:27,800 --> 00:14:31,699
fed to the random subsystem which you

00:14:29,929 --> 00:14:37,939
can ask for white tomorrow during his

00:14:31,699 --> 00:14:41,059
talk moving on I I got a message every

00:14:37,939 --> 00:14:44,540
time I did NFS boot which is really

00:14:41,059 --> 00:14:48,170
annoying because it's in caps and you

00:14:44,540 --> 00:14:50,629
know IRC culture you get bleeding eyes

00:14:48,170 --> 00:14:53,089
when you see caps so I want to get rid

00:14:50,629 --> 00:14:56,389
of that so because we didn't have a

00:14:53,089 --> 00:15:01,819
clock we only use the file system to get

00:14:56,389 --> 00:15:04,189
the time of day clock and the Archaean

00:15:01,819 --> 00:15:05,689
boards have some really good clocks I

00:15:04,189 --> 00:15:08,540
mean the Swiss must be proud of this

00:15:05,689 --> 00:15:11,439
technology of clocks of a one-second

00:15:08,540 --> 00:15:13,730
resolution I mean they're awesome and

00:15:11,439 --> 00:15:15,740
there are the ones that are used to get

00:15:13,730 --> 00:15:21,889
time and set time for the time of day

00:15:15,740 --> 00:15:23,869
clock if that wasn't scary enough in

00:15:21,889 --> 00:15:26,600
order to get the clock you need to use a

00:15:23,869 --> 00:15:31,129
two wires few serial interface which is

00:15:26,600 --> 00:15:35,019
a twisted way of getting across to

00:15:31,129 --> 00:15:39,069
different devices so you get stuff like

00:15:35,019 --> 00:15:43,680
an internal address of that serial

00:15:39,069 --> 00:15:47,319
interface and you get nice things like

00:15:43,680 --> 00:15:50,139
every bit which needs to be checked if

00:15:47,319 --> 00:15:53,110
the serial interface actually read what

00:15:50,139 --> 00:15:55,779
you told it to read and all kinds the

00:15:53,110 --> 00:15:59,529
valid bit it's it's very stable and

00:15:55,779 --> 00:16:03,639
robust and you get like old is pretty

00:15:59,529 --> 00:16:06,610
two-bit metadata just to write 32 bits

00:16:03,639 --> 00:16:13,230
which in the case of the RTC clock is

00:16:06,610 --> 00:16:15,790
even less but sure it's supposed to be

00:16:13,230 --> 00:16:18,720
like this so you set the address field

00:16:15,790 --> 00:16:21,279
for the real-time clock device and

00:16:18,720 --> 00:16:23,559
afterwards you just use internal

00:16:21,279 --> 00:16:27,939
addresses you don't use the entire

00:16:23,559 --> 00:16:30,569
address to access the time clock and you

00:16:27,939 --> 00:16:34,480
set the operation of reading or writing

00:16:30,569 --> 00:16:36,040
in the metadata that I showed and you

00:16:34,480 --> 00:16:37,660
just do reads and writes from the data

00:16:36,040 --> 00:16:39,699
field that should be easy I don't know

00:16:37,660 --> 00:16:41,649
why I'm complaining so much well maybe

00:16:39,699 --> 00:16:44,939
because you do it in two steps the first

00:16:41,649 --> 00:16:48,339
being that you need to set the read bit

00:16:44,939 --> 00:16:51,999
in order to read something from the from

00:16:48,339 --> 00:16:53,499
the RTC clock and then you need to set

00:16:51,999 --> 00:16:59,639
the valid bit this is done in sequence

00:16:53,499 --> 00:17:03,579
of course and you need to write to the

00:16:59,639 --> 00:17:05,199
register which is like controlling the

00:17:03,579 --> 00:17:07,240
entire interface and telling you what

00:17:05,199 --> 00:17:10,089
what to do but the second step you need

00:17:07,240 --> 00:17:12,970
to read back and keep reading back until

00:17:10,089 --> 00:17:15,429
the valid bit is set and if that is

00:17:12,970 --> 00:17:21,429
cleared then the operation was done and

00:17:15,429 --> 00:17:23,289
you can get a byte of data awesome which

00:17:21,429 --> 00:17:27,209
is one second resolution so you have

00:17:23,289 --> 00:17:30,940
enough time enough time to loop so yeah

00:17:27,209 --> 00:17:35,230
and the rights are done in a similar

00:17:30,940 --> 00:17:38,110
fashion in that you set bits in order to

00:17:35,230 --> 00:17:40,960
write and you finally could you finally

00:17:38,110 --> 00:17:44,510
configure that register for right and

00:17:40,960 --> 00:17:47,510
then the second step reads back what

00:17:44,510 --> 00:17:50,270
if the operation was completed and loops

00:17:47,510 --> 00:17:52,520
all over except with the extra bit of

00:17:50,270 --> 00:17:55,880
having to read back even after you got

00:17:52,520 --> 00:18:01,240
the valid the okay I I wrote there you

00:17:55,880 --> 00:18:05,450
still have to do an extra read so

00:18:01,240 --> 00:18:13,299
afterwards you get useful information

00:18:05,450 --> 00:18:19,880
everything is BCD coded which yes it's

00:18:13,299 --> 00:18:24,020
good I guess and you got to feed the set

00:18:19,880 --> 00:18:30,350
time and get time routines the BCD

00:18:24,020 --> 00:18:33,350
formatted data so that got me to a real

00:18:30,350 --> 00:18:35,900
time clock but of course the issues if

00:18:33,350 --> 00:18:36,650
it wasn't obvious so far is that it's

00:18:35,900 --> 00:18:38,990
very fragile

00:18:36,650 --> 00:18:41,600
you need to read they're there a lot if

00:18:38,990 --> 00:18:43,970
you're looking at the code if you have

00:18:41,600 --> 00:18:47,120
nothing better to do there are a lot of

00:18:43,970 --> 00:18:49,309
checks integrity checks there because of

00:18:47,120 --> 00:18:52,790
the loops and it can actually even

00:18:49,309 --> 00:18:56,960
timeout I think it's it's complicated

00:18:52,790 --> 00:19:00,049
and some models don't even have a real

00:18:56,960 --> 00:19:01,970
time clock so when I committed it I

00:19:00,049 --> 00:19:04,340
checked I expected everyone to have a

00:19:01,970 --> 00:19:05,750
real time clock but some just panicked

00:19:04,340 --> 00:19:08,480
because there was nothing there when you

00:19:05,750 --> 00:19:12,350
tried to read or write to that real time

00:19:08,480 --> 00:19:20,080
clock like the ubiquitous edge router so

00:19:12,350 --> 00:19:23,870
by that moving on I was able to NFS boot

00:19:20,080 --> 00:19:26,750
without the caps but you know in order

00:19:23,870 --> 00:19:28,900
to anaphase boot at first I had to TFTP

00:19:26,750 --> 00:19:31,160
boot all of these involve a network

00:19:28,900 --> 00:19:34,790
which was working until I reached

00:19:31,160 --> 00:19:38,210
userland when I couldn't even pink I

00:19:34,790 --> 00:19:42,140
couldn't do anything I can get media and

00:19:38,210 --> 00:19:45,470
the status was no carrier so it was like

00:19:42,140 --> 00:19:49,220
no cable connected but that far it could

00:19:45,470 --> 00:19:52,400
reach the network so I wanted to fix

00:19:49,220 --> 00:19:57,820
that of course looking at the missing

00:19:52,400 --> 00:19:57,820
Phi for the Broadcom device there

00:19:57,970 --> 00:20:04,070
remember the unknown PHY message from

00:20:01,190 --> 00:20:06,350
the D message that I talked in the

00:20:04,070 --> 00:20:08,000
beginning I started looking at other

00:20:06,350 --> 00:20:09,560
people's work with which is what I

00:20:08,000 --> 00:20:11,750
mostly do because I don't really like to

00:20:09,560 --> 00:20:13,400
work I like to get other people's work

00:20:11,750 --> 00:20:19,970
and adapt it and call it mine

00:20:13,400 --> 00:20:20,210
so open wrt had a wonderful driver for

00:20:19,970 --> 00:20:23,530
it

00:20:20,210 --> 00:20:27,860
with which I adapted and trimmed down

00:20:23,530 --> 00:20:30,080
for different reasons I basically just

00:20:27,860 --> 00:20:32,570
got the values that I need to read and

00:20:30,080 --> 00:20:36,530
read from the media the media

00:20:32,570 --> 00:20:38,570
information because the open wrt driver

00:20:36,530 --> 00:20:41,630
was a lot more complex and was doing a

00:20:38,570 --> 00:20:45,380
lot more things like switching which we

00:20:41,630 --> 00:20:49,750
don't have support for in OpenBSD for

00:20:45,380 --> 00:20:49,750
you know doing multiple ports which and

00:20:51,970 --> 00:21:00,740
like the zet router project from freebsd

00:20:55,520 --> 00:21:03,800
and stuff like that so I wrote a minimal

00:21:00,740 --> 00:21:08,210
driver which does download switching so

00:21:03,800 --> 00:21:12,590
whatever you plug in there sense sends

00:21:08,210 --> 00:21:16,820
out so I need to get to to the status of

00:21:12,590 --> 00:21:19,880
the files see if the link state is okay

00:21:16,820 --> 00:21:22,640
if what kind of mode were in and what

00:21:19,880 --> 00:21:25,820
the speed is so this was done through

00:21:22,640 --> 00:21:28,820
registers from the read from the status

00:21:25,820 --> 00:21:31,250
page of the file so in order to get that

00:21:28,820 --> 00:21:34,580
I need to make sure that I'm on the

00:21:31,250 --> 00:21:36,620
right page and of course you need an

00:21:34,580 --> 00:21:38,870
extra read back operation even after you

00:21:36,620 --> 00:21:41,420
after you set the page that you want to

00:21:38,870 --> 00:21:45,860
be in and then once you're in the right

00:21:41,420 --> 00:21:50,120
page you get the data from there in two

00:21:45,860 --> 00:21:53,810
bytes of data that tell you what the CPU

00:21:50,120 --> 00:21:56,030
port is doing so what media it has the

00:21:53,810 --> 00:21:57,920
link state and everything and the next

00:21:56,030 --> 00:22:00,410
for the next ports you get the inflow in

00:21:57,920 --> 00:22:03,470
the second third and fourth data

00:22:00,410 --> 00:22:08,000
registers my ideas are for 500 has four

00:22:03,470 --> 00:22:09,720
ports so that's why so after that I got

00:22:08,000 --> 00:22:15,780
media

00:22:09,720 --> 00:22:18,090
right here and I could ping so network

00:22:15,780 --> 00:22:22,140
was working which is really nice to have

00:22:18,090 --> 00:22:25,530
on a router so for the switch support I

00:22:22,140 --> 00:22:27,660
was planning on integrating one of the

00:22:25,530 --> 00:22:30,540
two frameworks there's that router one

00:22:27,660 --> 00:22:34,290
which I am more familiar with because

00:22:30,540 --> 00:22:37,290
I'm I was in contact a lot of for a lot

00:22:34,290 --> 00:22:40,460
of time with Alexander and there is also

00:22:37,290 --> 00:22:45,060
the IJ solution the IJ people from Japan

00:22:40,460 --> 00:22:47,370
they have a commercial support for the

00:22:45,060 --> 00:22:49,790
oculus on OpenBSD and they open sourced

00:22:47,370 --> 00:22:53,700
the solution for the switch framework

00:22:49,790 --> 00:22:55,440
which I tried to integrate into OpenBSD

00:22:53,700 --> 00:22:57,960
during the Ljubljana hackathon this

00:22:55,440 --> 00:23:01,830
summer but the guy developing that was

00:22:57,960 --> 00:23:07,580
very busy and didn't have we couldn't

00:23:01,830 --> 00:23:07,580
sink in order to discuss integrating it

00:23:08,420 --> 00:23:15,510
moving on the hardest part as the USB

00:23:13,740 --> 00:23:18,090
support because the CompactFlash even if

00:23:15,510 --> 00:23:21,420
you even even if you have a driver for

00:23:18,090 --> 00:23:23,370
it it's like 32 Meg so the zetz router

00:23:21,420 --> 00:23:25,290
people are stripping down freebsd in

00:23:23,370 --> 00:23:27,960
order to fit in that compact flash and

00:23:25,290 --> 00:23:32,940
then they have USB support for the KVM

00:23:27,960 --> 00:23:35,910
sdk so you can add extra storage so

00:23:32,940 --> 00:23:38,370
there's that driver and then there's the

00:23:35,910 --> 00:23:41,340
IJ driver which they also open source

00:23:38,370 --> 00:23:44,010
but they only work for the 3,000 models

00:23:41,340 --> 00:23:46,860
of k vm machines and it's also very

00:23:44,010 --> 00:23:49,070
specific to their to the machine that

00:23:46,860 --> 00:23:52,890
they sell and it's not really working on

00:23:49,070 --> 00:23:55,650
the machines that we support and then

00:23:52,890 --> 00:23:57,630
there's my driver which I finally got to

00:23:55,650 --> 00:23:59,580
a point where it no longer fries tix I

00:23:57,630 --> 00:24:01,860
managed to fry like four or five memory

00:23:59,580 --> 00:24:03,870
sticks with it with a small spark coming

00:24:01,860 --> 00:24:06,080
out of it when I plug them in that was

00:24:03,870 --> 00:24:06,080
lovely

00:24:06,590 --> 00:24:13,410
so I'm going to talk about that

00:24:09,840 --> 00:24:15,870
wonderful implementation I did I started

00:24:13,410 --> 00:24:18,380
by doing the machine specific the host

00:24:15,870 --> 00:24:21,720
controller specific initial

00:24:18,380 --> 00:24:23,520
initialization routines which is a clock

00:24:21,720 --> 00:24:26,210
setup core set up DMA

00:24:23,520 --> 00:24:31,610
and setting up a proper interrupt and

00:24:26,210 --> 00:24:34,980
this was pretty much stealing magical

00:24:31,610 --> 00:24:37,140
values from the SDK or looking at what

00:24:34,980 --> 00:24:39,900
iha people did it's always a mix so I

00:24:37,140 --> 00:24:45,050
always had like four or five virtual

00:24:39,900 --> 00:24:48,780
screens with X terms to their code and

00:24:45,050 --> 00:24:54,450
once I did that I managed to get an

00:24:48,780 --> 00:24:57,300
attachment so the opt octagon host

00:24:54,450 --> 00:25:02,160
controller was attaching to USB 0 which

00:24:57,300 --> 00:25:06,300
I know doesn't sound like much but to me

00:25:02,160 --> 00:25:08,700
it was a glorious day and I even got

00:25:06,300 --> 00:25:12,510
some error messages so more work awesome

00:25:08,700 --> 00:25:13,890
so I wanted to fix those and the first

00:25:12,510 --> 00:25:21,570
thing was to add an interrupt routine

00:25:13,890 --> 00:25:24,660
which is it it's really easy to start

00:25:21,570 --> 00:25:28,440
with you just add bits of pieces there

00:25:24,660 --> 00:25:29,940
and but the memory sticks keep frying

00:25:28,440 --> 00:25:34,070
whenever you think you were making

00:25:29,940 --> 00:25:38,250
progress so the best thing I did was

00:25:34,070 --> 00:25:41,910
look at both implementations and make a

00:25:38,250 --> 00:25:43,890
and I was able to make a coherent inter

00:25:41,910 --> 00:25:46,080
up routine that looks if you open other

00:25:43,890 --> 00:25:47,670
host control drivers in OpenBSD they're

00:25:46,080 --> 00:25:51,120
going to look the same and you're going

00:25:47,670 --> 00:25:52,800
to spot the machine specific bits when

00:25:51,120 --> 00:25:55,500
looking at the two in parallel so I

00:25:52,800 --> 00:25:58,650
think that's nice yeah even if I have an

00:25:55,500 --> 00:26:03,540
accident or whatever MPI can come over

00:25:58,650 --> 00:26:05,640
and finish the driver for me so oh by

00:26:03,540 --> 00:26:10,440
the way I never looked at the USB before

00:26:05,640 --> 00:26:14,280
this so this was also a very nice

00:26:10,440 --> 00:26:19,980
experience to start learning about a

00:26:14,280 --> 00:26:22,050
different layer and MPI which is USB

00:26:19,980 --> 00:26:26,760
master nowadays in open BSD was very

00:26:22,050 --> 00:26:31,410
kind to answer my ridiculous questions

00:26:26,760 --> 00:26:32,970
so after I've finished interrupted

00:26:31,410 --> 00:26:34,260
routine or so I thought I keep adding

00:26:32,970 --> 00:26:36,000
code to it

00:26:34,260 --> 00:26:36,840
I got a property message without those

00:26:36,000 --> 00:26:39,000
errors

00:26:36,840 --> 00:26:42,810
doesn't mean that and it was working

00:26:39,000 --> 00:26:48,540
just the messages went away so I moved

00:26:42,810 --> 00:26:52,500
on to adding route table support which

00:26:48,540 --> 00:26:56,400
is like like the media support for the

00:26:52,500 --> 00:27:01,280
fie you you start notifying people about

00:26:56,400 --> 00:27:04,980
what's happening in your hub which is

00:27:01,280 --> 00:27:10,490
the status you get the scripture of the

00:27:04,980 --> 00:27:13,800
requests that are sent to the hub and

00:27:10,490 --> 00:27:15,150
also fixing the USB to the Scriptures

00:27:13,800 --> 00:27:17,670
because you have to register the host

00:27:15,150 --> 00:27:20,490
controller as a USB to controller fixing

00:27:17,670 --> 00:27:23,790
those and acknowledging the fact that I

00:27:20,490 --> 00:27:27,720
was getting commands from outside helped

00:27:23,790 --> 00:27:32,370
fix the frying problem so I was able to

00:27:27,720 --> 00:27:34,350
plug in things without Sparks and I was

00:27:32,370 --> 00:27:37,890
able to use the devices afterwards so

00:27:34,350 --> 00:27:40,050
this was I'm not sure if it was progress

00:27:37,890 --> 00:27:42,690
though because some people offered money

00:27:40,050 --> 00:27:45,260
for the driver before just to be able to

00:27:42,690 --> 00:27:50,750
make pranks on first of April to people

00:27:45,260 --> 00:27:54,480
and but in my pointer to his progress

00:27:50,750 --> 00:27:57,630
because now the USB port was doing the

00:27:54,480 --> 00:27:59,910
same thing as before nothing you plug in

00:27:57,630 --> 00:28:03,360
a device and you get nothing back you

00:27:59,910 --> 00:28:05,880
pull it out and it still works so back

00:28:03,360 --> 00:28:09,990
to base

00:28:05,880 --> 00:28:11,780
back to the basis and then in order to

00:28:09,990 --> 00:28:15,660
actually get something out of the USB

00:28:11,780 --> 00:28:18,360
host controller I started adding more

00:28:15,660 --> 00:28:20,610
support for news reports and the end

00:28:18,360 --> 00:28:22,290
points of course they call and endpoints

00:28:20,610 --> 00:28:24,180
channels that took me a long time to

00:28:22,290 --> 00:28:26,280
figure out was a channel spots that I

00:28:24,180 --> 00:28:28,320
was asking MPI do you know channel

00:28:26,280 --> 00:28:30,540
definition in a USB specification know

00:28:28,320 --> 00:28:34,650
what's a channel so that was fun

00:28:30,540 --> 00:28:36,600
changing that name thank you so these

00:28:34,650 --> 00:28:38,700
allowed me to keep track of when you

00:28:36,600 --> 00:28:41,280
connect to a port or when you do a port

00:28:38,700 --> 00:28:44,070
reset and I was able to send

00:28:41,280 --> 00:28:46,800
notifications up stream upstream about

00:28:44,070 --> 00:28:49,680
what was going on and this actually

00:28:46,800 --> 00:28:50,750
moved things further as now the nowadays

00:28:49,680 --> 00:28:54,080
I need to

00:28:50,750 --> 00:28:58,100
and device transfer and control methods

00:28:54,080 --> 00:29:00,740
which in terms of the actual devices

00:28:58,100 --> 00:29:03,730
means that I need to start sending data

00:29:00,740 --> 00:29:10,130
through so the control is almost there

00:29:03,730 --> 00:29:11,720
because to give a large picture I the

00:29:10,130 --> 00:29:14,360
green things are things that are done

00:29:11,720 --> 00:29:17,780
and the blue things is what I'm working

00:29:14,360 --> 00:29:19,490
on and the red is what's missing so you

00:29:17,780 --> 00:29:22,370
might think is half and half but you're

00:29:19,490 --> 00:29:24,380
being overly optimistic it's just so

00:29:22,370 --> 00:29:27,860
that I can show that it did something

00:29:24,380 --> 00:29:31,130
it's this will take a lot of time and

00:29:27,860 --> 00:29:33,050
it's very sensible work here but at

00:29:31,130 --> 00:29:36,500
least it's not destroying devices and

00:29:33,050 --> 00:29:40,820
it's you're able to actually see how

00:29:36,500 --> 00:29:43,570
things are moving in a USB stack and not

00:29:40,820 --> 00:29:46,850
getting panics just not moving data or

00:29:43,570 --> 00:29:51,650
not detecting the proper the proper

00:29:46,850 --> 00:29:57,170
events so this is the point where I

00:29:51,650 --> 00:30:00,380
where where I am today as I was saying

00:29:57,170 --> 00:30:05,480
the boss the boss methods are done and

00:30:00,380 --> 00:30:10,240
the hub routines should be okay now

00:30:05,480 --> 00:30:12,500
so I'm moving on to devices so the major

00:30:10,240 --> 00:30:14,660
showstoppers because I'm working on this

00:30:12,500 --> 00:30:16,810
for a while now is there's the K which

00:30:14,660 --> 00:30:18,890
would have there's the K is like two

00:30:16,810 --> 00:30:23,690
function calls and you're done you have

00:30:18,890 --> 00:30:26,150
a host controller nice right and the

00:30:23,690 --> 00:30:28,000
fact that the SDK and the IJ code is

00:30:26,150 --> 00:30:30,620
very different and they they actually

00:30:28,000 --> 00:30:33,230
set registers in a different way and in

00:30:30,620 --> 00:30:35,270
a different order and it's a lot of

00:30:33,230 --> 00:30:40,130
guesswork in poking and going back to

00:30:35,270 --> 00:30:42,140
reverse engineering and USB is really

00:30:40,130 --> 00:30:44,480
hard I mean like this pack is hard

00:30:42,140 --> 00:30:48,700
enough and doing it without the proper

00:30:44,480 --> 00:30:51,290
documentation isn't harder and the time

00:30:48,700 --> 00:30:55,070
requirements are really high and I can't

00:30:51,290 --> 00:30:56,660
I'm one of the people that need to focus

00:30:55,070 --> 00:30:57,980
on a task for at least four hours in

00:30:56,660 --> 00:31:00,170
order to get something done

00:30:57,980 --> 00:31:01,970
I can't just work for an hour in the

00:31:00,170 --> 00:31:04,580
evening after I'm done with regular work

00:31:01,970 --> 00:31:08,990
on the USB because I need to get in

00:31:04,580 --> 00:31:12,019
and remember where I left off and start

00:31:08,990 --> 00:31:17,269
thinking about the magical values in

00:31:12,019 --> 00:31:21,919
this part of the world so progress is

00:31:17,269 --> 00:31:24,769
slow because of that moving on to the

00:31:21,919 --> 00:31:29,919
flash memory I started working on that

00:31:24,769 --> 00:31:34,820
as well as time off from the USB layer

00:31:29,919 --> 00:31:38,570
which is it's supposed to be really easy

00:31:34,820 --> 00:31:41,600
to implement it's a compact flash after

00:31:38,570 --> 00:31:44,200
well after all the freebies FreeBSD has

00:31:41,600 --> 00:31:48,649
a driver foot that's going through CFI

00:31:44,200 --> 00:31:52,309
and I want to get the code from there

00:31:48,649 --> 00:31:55,880
and I probably will end up doing that

00:31:52,309 --> 00:31:57,590
the problem is that they they have a lot

00:31:55,880 --> 00:32:00,740
of layers that they go through and I

00:31:57,590 --> 00:32:03,590
just want to get the core of the driver

00:32:00,740 --> 00:32:05,899
I'll show in a later slide I think the

00:32:03,590 --> 00:32:09,380
layer that it goes through or maybe we

00:32:05,899 --> 00:32:13,460
can see it here yeah the CFI to see if

00:32:09,380 --> 00:32:15,559
ID connected to a CF i0 it's it's they

00:32:13,460 --> 00:32:18,620
support a lot of compact flashes because

00:32:15,559 --> 00:32:21,889
they respect this specification that

00:32:18,620 --> 00:32:24,919
Intel AMD and other people agreed upon

00:32:21,889 --> 00:32:28,130
and it's different because of course

00:32:24,919 --> 00:32:30,860
Intel or AMD decided to violate that and

00:32:28,130 --> 00:32:35,110
do things opposite so a lot of if thefts

00:32:30,860 --> 00:32:38,029
and I haven't I have never done at a

00:32:35,110 --> 00:32:42,080
disk driver so I discussed with dlg

00:32:38,029 --> 00:32:47,779
David about it because his the authority

00:32:42,080 --> 00:32:50,840
in this domain and I the idea is to

00:32:47,779 --> 00:32:53,690
write a small ata driver for it but the

00:32:50,840 --> 00:32:56,360
problem is that this device is so dumb

00:32:53,690 --> 00:32:59,059
that it's not using most of Gita things

00:32:56,360 --> 00:33:02,360
so it's doesn't do concurrent commands

00:32:59,059 --> 00:33:04,370
it's just there are no port multipliers

00:33:02,360 --> 00:33:06,559
it's just so easy that eighty eight

00:33:04,370 --> 00:33:11,269
might be even more complicated than what

00:33:06,559 --> 00:33:14,510
the previous did people are doing so the

00:33:11,269 --> 00:33:17,580
the idea now is to avoid doing something

00:33:14,510 --> 00:33:20,880
like PCI IDE which is

00:33:17,580 --> 00:33:26,610
very does a lot of layer violations and

00:33:20,880 --> 00:33:28,170
to to do standalone driver maybe because

00:33:26,610 --> 00:33:33,720
the reason the rights are done through

00:33:28,170 --> 00:33:36,720
registers you don't do DMA it's so I I'm

00:33:33,720 --> 00:33:38,790
still changing the implementation every

00:33:36,720 --> 00:33:44,970
time I'm going back to it so I'm I

00:33:38,790 --> 00:33:47,220
haven't settled on a direction so this

00:33:44,970 --> 00:33:48,540
is I as I was saying I don't know if I

00:33:47,220 --> 00:33:52,080
should support the entire CFI

00:33:48,540 --> 00:33:54,480
specification this is an extension of it

00:33:52,080 --> 00:33:57,740
I don't know if I should add that maybe

00:33:54,480 --> 00:34:06,650
I should start small I don't know so

00:33:57,740 --> 00:34:12,840
progress on this is really slow as well

00:34:06,650 --> 00:34:16,250
so to conclude is a lot of work was put

00:34:12,840 --> 00:34:18,900
into it even though it's not so obvious

00:34:16,250 --> 00:34:22,890
the lack of documentation as always is

00:34:18,900 --> 00:34:27,240
slowing things and SDK copyright was is

00:34:22,890 --> 00:34:31,200
making things even harder and I would

00:34:27,240 --> 00:34:35,220
enjoy to have to get some help in these

00:34:31,200 --> 00:34:37,260
open problems there and I I will

00:34:35,220 --> 00:34:39,750
continue working on the port and I want

00:34:37,260 --> 00:34:43,740
to complete it this soon as possible to

00:34:39,750 --> 00:34:46,530
make it stand alone the the memory

00:34:43,740 --> 00:34:52,230
storage being the main problem with it

00:34:46,530 --> 00:34:56,480
nowadays so thank you for listening to

00:34:52,230 --> 00:34:56,480
me and questions

00:35:07,220 --> 00:35:12,180
this thing where you had to loop over

00:35:10,260 --> 00:35:14,190
the real-time clock just to be able to

00:35:12,180 --> 00:35:16,349
write one byte and wait for the valid

00:35:14,190 --> 00:35:18,030
bit to change value how many times do

00:35:16,349 --> 00:35:20,220
you have to loop over that before it

00:35:18,030 --> 00:35:21,540
actually accepts what you're trying to

00:35:20,220 --> 00:35:23,880
tell it I happened

00:35:21,540 --> 00:35:26,790
i I measured it a few times and it

00:35:23,880 --> 00:35:30,510
wasn't that bad actually I mean it seems

00:35:26,790 --> 00:35:32,490
that it's rarely occurring the problem

00:35:30,510 --> 00:35:34,349
there you always get it the first time

00:35:32,490 --> 00:35:39,890
most of the times but sometimes you can

00:35:34,349 --> 00:35:42,570
get like three or four iterations before

00:35:39,890 --> 00:35:45,060
there was no that's rare amounts like

00:35:42,570 --> 00:35:55,920
10,000 no no no it's not that bad but

00:35:45,060 --> 00:35:57,839
it's yeah it's tricky yeah so I know

00:35:55,920 --> 00:36:00,119
it's not good but did you try you're

00:35:57,839 --> 00:36:05,220
playing with us DK to see if it would be

00:36:00,119 --> 00:36:08,339
easier actually I tried to play with the

00:36:05,220 --> 00:36:11,880
Asetek meaning to integrate it and see

00:36:08,339 --> 00:36:14,220
how USB works I tried that with FreeBSD

00:36:11,880 --> 00:36:16,320
and it works really good and with the

00:36:14,220 --> 00:36:20,280
jet router but not with the actual

00:36:16,320 --> 00:36:22,290
OpenBSD tree because it it's it's not so

00:36:20,280 --> 00:36:26,490
easy to integrate the SDK I mean it

00:36:22,290 --> 00:36:28,260
needs a bit of work so I prefer to play

00:36:26,490 --> 00:36:34,080
with other projects that already did

00:36:28,260 --> 00:36:36,089
that work and try to yeah I'm yeah why

00:36:34,080 --> 00:36:37,140
it can give you some pointers but you

00:36:36,089 --> 00:36:38,010
don't have to reverse engineer

00:36:37,140 --> 00:36:41,310
everything

00:36:38,010 --> 00:36:44,040
yeah no I'm I'm looking at the SDK and

00:36:41,310 --> 00:36:47,010
I'm I'm helping myself there from there

00:36:44,040 --> 00:36:50,280
with different values and stuff but the

00:36:47,010 --> 00:36:53,880
logic it's really like it's the

00:36:50,280 --> 00:36:56,070
abstraction they use is very deep so you

00:36:53,880 --> 00:36:58,650
have to in order to read the register

00:36:56,070 --> 00:37:01,170
you go through like ten or twelve

00:36:58,650 --> 00:37:02,400
functions until you actually do the read

00:37:01,170 --> 00:37:04,080
operation because they call it from

00:37:02,400 --> 00:37:06,680
different places and different drivers

00:37:04,080 --> 00:37:10,280
and that makes sense for them so

00:37:06,680 --> 00:37:12,480
integrating that into our VSD would be

00:37:10,280 --> 00:37:14,880
would take a bit of time and it's not

00:37:12,480 --> 00:37:18,700
impossible and I know that it won't get

00:37:14,880 --> 00:37:26,410
committed because of that license yeah

00:37:18,700 --> 00:37:28,210
Thanks how finicky is the hardware that

00:37:26,410 --> 00:37:30,880
you are working with debug is they have

00:37:28,210 --> 00:37:34,420
a convenient serial console yes it has a

00:37:30,880 --> 00:37:37,060
serial console which is like serial not

00:37:34,420 --> 00:37:39,970
JTAG or whatever so did you know

00:37:37,060 --> 00:37:41,890
soldering necessary no you just buy it

00:37:39,970 --> 00:37:42,940
and you plug it in and it was the there

00:37:41,890 --> 00:37:43,660
was a d-link that you were working with

00:37:42,940 --> 00:37:45,400
yes

00:37:43,660 --> 00:37:48,220
dealing the isara 500 but I think the

00:37:45,400 --> 00:37:50,560
others are the same I'm I don't remember

00:37:48,220 --> 00:37:51,130
anyone having to solder a serial but I

00:37:50,560 --> 00:37:56,380
might be wrong

00:37:51,130 --> 00:37:58,780
yep and it actually comes up as Phi as

00:37:56,380 --> 00:38:02,170
well the serial because you get to like

00:37:58,780 --> 00:38:05,620
a network cable on one end and on the

00:38:02,170 --> 00:38:09,150
other the actual serial cable it's yeah

00:38:05,620 --> 00:38:09,150
works on the fly

00:38:14,980 --> 00:38:19,430
that might be a very generic question

00:38:17,630 --> 00:38:21,680
but what I mean are those devices

00:38:19,430 --> 00:38:24,950
popular the d-link are there many

00:38:21,680 --> 00:38:26,750
devices using our channel now yes link

00:38:24,950 --> 00:38:30,740
has a lot of models using that they even

00:38:26,750 --> 00:38:32,600
have wireless mine only has wired

00:38:30,740 --> 00:38:35,480
network some have wireless a lot of

00:38:32,600 --> 00:38:37,910
people are using it as because it comes

00:38:35,480 --> 00:38:40,760
with a product I mean the dealing I have

00:38:37,910 --> 00:38:43,190
I could use it right off because it is

00:38:40,760 --> 00:38:44,330
they sell those it's not like I have to

00:38:43,190 --> 00:38:47,420
write an email in they send me

00:38:44,330 --> 00:38:50,330
prototypes yes so yeah a lot of people

00:38:47,420 --> 00:38:52,790
seem to be using that I I'm not sure if

00:38:50,330 --> 00:38:54,830
the DSR 500 so say but there are a lot

00:38:52,790 --> 00:39:01,420
of all key on models produced by the

00:38:54,830 --> 00:39:01,420
d-link and not only them but yeah yep I

00:39:03,460 --> 00:39:12,830
think Claudio so can we use these

00:39:10,490 --> 00:39:16,010
devices for like firewalls and stuff

00:39:12,830 --> 00:39:19,970
already or is it not really good that's

00:39:16,010 --> 00:39:24,380
what I wanted to I have a server that's

00:39:19,970 --> 00:39:26,570
running since 1996 or 1997 and I wanted

00:39:24,380 --> 00:39:34,910
to once I got this I wanted to do the

00:39:26,570 --> 00:39:37,220
roped PF thing on it and I I didn't test

00:39:34,910 --> 00:39:39,200
with OpenBSD but FreeBSD works yeah sure

00:39:37,220 --> 00:39:41,780
but they using the SDK so I don't know

00:39:39,200 --> 00:39:45,560
if the fine needs further work or maybe

00:39:41,780 --> 00:39:47,360
some but yeah looking at the open w RT

00:39:45,560 --> 00:39:52,460
driver we have most of the things there

00:39:47,360 --> 00:39:54,680
so I I haven't tested with open BSD for

00:39:52,460 --> 00:39:56,900
like actual performance but then I only

00:39:54,680 --> 00:39:59,330
run a home server so I don't I'm not the

00:39:56,900 --> 00:40:03,200
speed junkie yep so you don't know how

00:39:59,330 --> 00:40:05,930
fast this no I don't know that but you

00:40:03,200 --> 00:40:07,970
should ask JM f your dlg I know they

00:40:05,930 --> 00:40:10,160
experimented stuff on them and their

00:40:07,970 --> 00:40:13,010
because they they were building the

00:40:10,160 --> 00:40:14,270
infrastructure at the university they

00:40:13,010 --> 00:40:18,760
probably looked at the networking

00:40:14,270 --> 00:40:18,760
figures so yeah

00:40:21,940 --> 00:40:30,680
further questions we still of times

00:40:26,359 --> 00:40:34,160
fractals I can tell so alone again

00:40:30,680 --> 00:40:37,070
that's all we sit we still some of their

00:40:34,160 --> 00:40:39,490
great time earlier so if you know my

00:40:37,070 --> 00:40:39,490
questions

00:40:40,550 --> 00:40:43,859

YouTube URL: https://www.youtube.com/watch?v=Ej4AR5dnfDQ


