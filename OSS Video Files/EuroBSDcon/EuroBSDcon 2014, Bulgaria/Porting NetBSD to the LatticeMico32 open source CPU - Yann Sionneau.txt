Title: Porting NetBSD to the LatticeMico32 open source CPU - Yann Sionneau
Publication date: 2019-10-13
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

I will describe the work I did on the open source LatticeMico32 softcore CPU to add a MMU to its pipeline and then how I added support for this enhanced LM32 CPU in the NetBSD 6 kernel.I will quickly explain what a MMU is and how it works in LM32. I will then show an overview of the steps I followed to add support for this new CPU and this new System-on-Chip to the NetBSD kernel. Afterward I will explain some of the choices made for this port, especially those in relation with the MMU handling : the (machine-dependant) virtual memory system (aka pmap).I will demo the boot of the NetBSD kernel on QEMU emulating LM32 CPU and then on the Milkymist One VJ Station.

Speaker biography:

Yann Sionneau is a 26 year-old French embedded software engineer passionate about learning how embedded systems work in general.Yann is part of the M-Labs (fka Milkymist) community that is working on developing open source digital designs on FPGAs as well as making it more and more easy to do so by providing a simple but yet powerful framework for System-on-Chip design.Yann contributed the original RTEMS Board Support Package of the Milkymist One video synthesizer, a Memory Management Unit (MMU) for the Open Source soft-core CPU LatticeMico32, and ported NetBSD kernel for the LM32 CPU and the Milkymist System-on-Chip. Yann recently became an EdgeBSD developer and his work on LM32 support is currently upstream in an EdgeBSD branch.
Captions: 
	00:00:00,110 --> 00:00:07,259
my buddy I'd like to introduce

00:00:03,200 --> 00:00:09,480
young-soon off to you and he is going to

00:00:07,259 --> 00:00:13,259
explain to us how he ported nappies D to

00:00:09,480 --> 00:00:16,320
the lettuce micro 32 soft CPU and how

00:00:13,259 --> 00:00:22,500
here to modified the CPU before being

00:00:16,320 --> 00:00:24,680
able to run let beastie good morning

00:00:22,500 --> 00:00:32,149
everybody thank you for attending

00:00:24,680 --> 00:00:36,149
so as Martin said going to talk about

00:00:32,149 --> 00:00:40,440
what I did as a hobby project recently

00:00:36,149 --> 00:00:43,730
and it involved poaching net bsd an edge

00:00:40,440 --> 00:00:46,860
bsd which has been presented yesterday

00:00:43,730 --> 00:00:56,070
on an open source CPU called the lattice

00:00:46,860 --> 00:01:00,270
micro sorta - so presented so i'm will

00:00:56,070 --> 00:01:02,550
be joining m labs in a few days which

00:01:00,270 --> 00:01:04,309
was formerly known as milky miss

00:01:02,550 --> 00:01:09,119
community and which has been

00:01:04,309 --> 00:01:12,270
incorporated recently by its founder so

00:01:09,119 --> 00:01:14,970
that's a cool company doing your

00:01:12,270 --> 00:01:16,920
interesting open source hardware and

00:01:14,970 --> 00:01:19,590
software stuff like the making mist

00:01:16,920 --> 00:01:21,570
board if you thought of it or the making

00:01:19,590 --> 00:01:24,900
me system and chip i will talk about it

00:01:21,570 --> 00:01:28,290
a bit later so okay let's talk about

00:01:24,900 --> 00:01:32,369
this port and more specifically ported

00:01:28,290 --> 00:01:33,720
on the milk you missed one board first

00:01:32,369 --> 00:01:37,619
part I will talk a bit about the

00:01:33,720 --> 00:01:41,880
hardware so talk about the MMU and then

00:01:37,619 --> 00:01:45,990
a bit about software but first what's

00:01:41,880 --> 00:01:49,729
the milkiness one it's this it's an

00:01:45,990 --> 00:01:53,939
electronic device aimed at generating

00:01:49,729 --> 00:01:56,640
video effects in which are in real time

00:01:53,939 --> 00:02:00,130
synchronized to a lot of sources like

00:01:56,640 --> 00:02:05,979
for instance audio input or media

00:02:00,130 --> 00:02:11,500
or DMX even's etc so it's a kind of a an

00:02:05,979 --> 00:02:15,010
artistic device that can be used a bit

00:02:11,500 --> 00:02:18,160
like this so you can film someone a

00:02:15,010 --> 00:02:20,880
performer and then you project against

00:02:18,160 --> 00:02:24,580
the wall at a party or at a concert and

00:02:20,880 --> 00:02:26,410
you apply nice real-time video effects

00:02:24,580 --> 00:02:29,640
like rotation zoom in zoom out or

00:02:26,410 --> 00:02:35,140
blurring etc and you can interact with

00:02:29,640 --> 00:02:39,220
all kind of PartyLite devices like MIDI

00:02:35,140 --> 00:02:42,040
keyboard cetera so that's the device and

00:02:39,220 --> 00:02:44,890
it produces nice effects like these ones

00:02:42,040 --> 00:02:47,920
those are screenshots of the device

00:02:44,890 --> 00:02:50,890
outputs and the cool thing about this

00:02:47,920 --> 00:02:54,640
device is not just any closest

00:02:50,890 --> 00:02:58,180
commercial device because its uses an

00:02:54,640 --> 00:03:01,269
FPGA as its main components and most of

00:02:58,180 --> 00:03:03,819
the interesting part of the device

00:03:01,269 --> 00:03:08,230
functions are implemented in size FPGA

00:03:03,819 --> 00:03:13,600
so it's not fixed in time you can play

00:03:08,230 --> 00:03:16,799
with it you can modify you can do your

00:03:13,600 --> 00:03:20,260
hack stuff on it and it's pretty cool so

00:03:16,799 --> 00:03:25,780
what's an FPGA so it's a chip basically

00:03:20,260 --> 00:03:30,489
like any other but you can configure it

00:03:25,780 --> 00:03:34,660
to behave a bit the way you want so it

00:03:30,489 --> 00:03:39,370
you've got logic blocks located as an

00:03:34,660 --> 00:03:41,139
array and i/o block and you can

00:03:39,370 --> 00:03:43,630
configure each logic block to do

00:03:41,139 --> 00:03:45,130
something like drug logic operation like

00:03:43,630 --> 00:03:48,519
a door

00:03:45,130 --> 00:03:51,970
Zoro stuff like that and then you have a

00:03:48,519 --> 00:03:54,670
switching matrix that allow you allows

00:03:51,970 --> 00:03:57,130
you to interconnect those logic block

00:03:54,670 --> 00:04:00,480
and you decide which block you connect

00:03:57,130 --> 00:04:04,959
to which other and then you can create

00:04:00,480 --> 00:04:07,620
basically a logic circuit and you can do

00:04:04,959 --> 00:04:10,479
this a lot of times and you can

00:04:07,620 --> 00:04:12,870
basically implement almost for free and

00:04:10,479 --> 00:04:16,169
ASIC chip but Asics chips

00:04:12,870 --> 00:04:22,590
cost usually thousands of hundreds of

00:04:16,169 --> 00:04:25,020
thousands of dollars so this the PCBs is

00:04:22,590 --> 00:04:27,840
an electronic circuit which is also open

00:04:25,020 --> 00:04:30,150
source so it contains this FPGA and on

00:04:27,840 --> 00:04:33,000
the FPGA it runs the milk image system

00:04:30,150 --> 00:04:37,050
on chip which is also open source so

00:04:33,000 --> 00:04:39,389
it's a whole bunch of function blocks

00:04:37,050 --> 00:04:42,660
which are controlling I don't know for

00:04:39,389 --> 00:04:45,960
instance the USB or the sound or MIDI

00:04:42,660 --> 00:04:49,860
DMX you are except for as a dram out of

00:04:45,960 --> 00:04:52,740
frame buffer so all all those

00:04:49,860 --> 00:04:55,289
controllers are making the device work

00:04:52,740 --> 00:04:58,860
and then on the bottom left you've got

00:04:55,289 --> 00:05:00,660
the mica 32 CPU that's the the main

00:04:58,860 --> 00:05:04,710
component I will be talking about it's

00:05:00,660 --> 00:05:07,470
the the soft core CPU which is running

00:05:04,710 --> 00:05:12,300
on this video and which will be running

00:05:07,470 --> 00:05:15,750
that BSD so okay Mikko 32 so sorry the

00:05:12,300 --> 00:05:19,380
bits have architecture it's risk big

00:05:15,750 --> 00:05:22,289
endian does six stages it is fully

00:05:19,380 --> 00:05:25,200
bypass so it's pretty okay in terms of

00:05:22,289 --> 00:05:28,740
performance and you can put caches or

00:05:25,200 --> 00:05:30,870
not you can disable them and they are up

00:05:28,740 --> 00:05:33,900
to 2-way set associative and it's using

00:05:30,870 --> 00:05:38,820
the wishbone on cheapest which is an

00:05:33,900 --> 00:05:42,990
open-source specification bus which is

00:05:38,820 --> 00:05:46,320
used by all the open course community of

00:05:42,990 --> 00:05:48,660
open source hardware course devices so

00:05:46,320 --> 00:05:52,410
you can easily find a lot of open source

00:05:48,660 --> 00:05:55,710
calls which are talking this protocol

00:05:52,410 --> 00:06:00,030
this on chrimbus protocol got tons of of

00:05:55,710 --> 00:06:02,550
them okay and the CPU actually works on

00:06:00,030 --> 00:06:03,630
pretty much every FPGA because it is

00:06:02,550 --> 00:06:06,720
device agnostic

00:06:03,630 --> 00:06:09,389
it doesn't use specific blocks from one

00:06:06,720 --> 00:06:11,580
specific FPGA bundle for instance so you

00:06:09,389 --> 00:06:15,449
can for instance from the CPU on the d0

00:06:11,580 --> 00:06:20,849
nano which is running natural chip on

00:06:15,449 --> 00:06:23,099
the mill chemist one running featuring

00:06:20,849 --> 00:06:26,719
an exponent six of PJ from Shining's

00:06:23,099 --> 00:06:30,780
popular Pro or the mix Co which is a new

00:06:26,719 --> 00:06:34,860
project from M labs video mixer also

00:06:30,780 --> 00:06:36,630
open source and or even the new king

00:06:34,860 --> 00:06:39,750
takes seven series from the island so

00:06:36,630 --> 00:06:41,280
all of these could run and can run

00:06:39,750 --> 00:06:44,310
actually run as those days

00:06:41,280 --> 00:06:46,860
Mikko attitude so why is it interesting

00:06:44,310 --> 00:06:50,669
it's small it really really doesn't take

00:06:46,860 --> 00:06:51,960
a lot of resources inside the FPGA is as

00:06:50,669 --> 00:06:56,610
I said it's possible and it's pretty

00:06:51,960 --> 00:06:57,780
fast a lot of CPU open source also that

00:06:56,610 --> 00:07:03,120
you can find on the internet usually

00:06:57,780 --> 00:07:05,820
they run at 20 25 megahertz and this one

00:07:03,120 --> 00:07:09,780
can run up to 200 megahertz in recent

00:07:05,820 --> 00:07:11,940
chips actually works a lot of CPUs

00:07:09,780 --> 00:07:14,639
there's a hobby project that you can

00:07:11,940 --> 00:07:16,979
find on the web but most of them a lot

00:07:14,639 --> 00:07:20,070
buggies they actually do work in the end

00:07:16,979 --> 00:07:22,919
so it's one of the few that works and it

00:07:20,070 --> 00:07:26,370
does an okay software support we've got

00:07:22,919 --> 00:07:31,529
the GCC being UT gdb even qmu which is

00:07:26,370 --> 00:07:33,080
really handy and it's open source no to

00:07:31,529 --> 00:07:36,599
the bad points

00:07:33,080 --> 00:07:40,560
it had no memory management unit so I

00:07:36,599 --> 00:07:43,440
couldn't put net DSD but that's one of

00:07:40,560 --> 00:07:47,190
the few the one of the first thing I I

00:07:43,440 --> 00:07:52,139
fixed I worked on this with a Mikkel

00:07:47,190 --> 00:07:54,300
value it's a two-man job and the CPU is

00:07:52,139 --> 00:07:56,430
used in some closest commercial Asics so

00:07:54,300 --> 00:07:59,940
it's pretty solid it's been implemented

00:07:56,430 --> 00:08:03,800
in real world chips and it can achieve a

00:07:59,940 --> 00:08:12,120
pretty decent frequency in quite all

00:08:03,800 --> 00:08:16,889
cell process so to standard risk

00:08:12,120 --> 00:08:18,570
pipeline so just get address

00:08:16,889 --> 00:08:20,370
computations and you've got the

00:08:18,570 --> 00:08:22,740
instruction fetch then decode execute

00:08:20,370 --> 00:08:27,029
loadstone right back so I think all of

00:08:22,740 --> 00:08:28,770
you already understand all of this so

00:08:27,029 --> 00:08:35,640
okay

00:08:28,770 --> 00:08:39,390
this is a simplification drawing of the

00:08:35,640 --> 00:08:41,220
CPU the original CPU or it was working

00:08:39,390 --> 00:08:43,380
so we got the pipeline on the left then

00:08:41,220 --> 00:08:46,080
you've got the two instruction and data

00:08:43,380 --> 00:08:49,020
caches on the right and then main memory

00:08:46,080 --> 00:08:52,710
stirs off chip and originally there was

00:08:49,020 --> 00:08:54,450
no a menu and no notion of virtual

00:08:52,710 --> 00:08:57,540
addressing so physical address was used

00:08:54,450 --> 00:09:01,680
everywhere so but directly talking

00:08:57,540 --> 00:09:04,440
almost to the RAM chip and there were no

00:09:01,680 --> 00:09:06,720
translation so it was okay to run you

00:09:04,440 --> 00:09:11,100
see Linux for instance which does run

00:09:06,720 --> 00:09:15,290
some accents but as I understood it that

00:09:11,100 --> 00:09:19,020
the SD couldn't work on social system so

00:09:15,290 --> 00:09:21,480
we modified it so we added this memory

00:09:19,020 --> 00:09:25,740
management unit so that on the Left

00:09:21,480 --> 00:09:29,220
pipeline only manages virtual addresses

00:09:25,740 --> 00:09:31,680
and then gets translated and goes

00:09:29,220 --> 00:09:35,040
through to main memory as physical

00:09:31,680 --> 00:09:40,140
addresses so the in this way we were

00:09:35,040 --> 00:09:44,610
able to to have a something to to run

00:09:40,140 --> 00:09:47,370
and bsd so okay but a bit about the

00:09:44,610 --> 00:09:48,870
enemy's job so it basically translate a

00:09:47,370 --> 00:09:51,600
virtual address into a physical address

00:09:48,870 --> 00:09:56,220
and it gives you also memory protection

00:09:51,600 --> 00:09:58,530
so for instance it can allow you to say

00:09:56,220 --> 00:10:01,230
okay as a stack is not executable and

00:09:58,530 --> 00:10:02,970
okay this is data so you can write to it

00:10:01,230 --> 00:10:04,590
or maybe this is read-only data so I

00:10:02,970 --> 00:10:10,730
don't want to allow you to write to it

00:10:04,590 --> 00:10:14,760
and it gives you this kind of security

00:10:10,730 --> 00:10:17,940
so we explained how it was implemented

00:10:14,760 --> 00:10:21,540
in this case so

00:10:17,940 --> 00:10:24,950
this is the same diagram but even more

00:10:21,540 --> 00:10:27,030
simplified so if your CPU pipeline

00:10:24,950 --> 00:10:29,240
giving some referrals from memory

00:10:27,030 --> 00:10:32,790
management unit and it gets translated

00:10:29,240 --> 00:10:34,470
but okay how does the MMU knows how to

00:10:32,790 --> 00:10:37,800
translate this virtual address into the

00:10:34,470 --> 00:10:39,540
physical address how does it work it's

00:10:37,800 --> 00:10:42,090
using okay this is reading the page

00:10:39,540 --> 00:10:49,940
table but the page table as you can see

00:10:42,090 --> 00:10:54,480
is located in the DRAM so we we couldn't

00:10:49,940 --> 00:10:56,070
access each time the DRAM to do a

00:10:54,480 --> 00:11:02,820
translation that would be terribly slow

00:10:56,070 --> 00:11:05,700
so what was done no no okay

00:11:02,820 --> 00:11:08,790
first sorry where we could I keep

00:11:05,700 --> 00:11:11,700
talking about page pages and first

00:11:08,790 --> 00:11:16,370
before I was talking about addresses so

00:11:11,700 --> 00:11:19,050
why do I switch word because in reality

00:11:16,370 --> 00:11:20,910
you're not just translating addresses

00:11:19,050 --> 00:11:22,680
because if you were just doing a

00:11:20,910 --> 00:11:25,140
translation from one address to another

00:11:22,680 --> 00:11:27,810
address in like this so for instance the

00:11:25,140 --> 00:11:31,200
address for to the address one and all

00:11:27,810 --> 00:11:33,660
zero five two 101 you would need to

00:11:31,200 --> 00:11:37,440
remember all those translations as you

00:11:33,660 --> 00:11:39,800
would there would be a lot of data to

00:11:37,440 --> 00:11:43,170
remember you would need to remember all

00:11:39,800 --> 00:11:45,840
all those translation line and for to

00:11:43,170 --> 00:11:47,610
transfer gigabytes you would need for

00:11:45,840 --> 00:11:48,090
for billions of lines so it can't work

00:11:47,610 --> 00:11:52,890
like this

00:11:48,090 --> 00:11:55,530
so to be more efficient use pages and

00:11:52,890 --> 00:11:58,620
then you take big chunks of memory and

00:11:55,530 --> 00:12:02,340
you translate those big chunks by what

00:11:58,620 --> 00:12:06,030
we call pages so and in this case where

00:12:02,340 --> 00:12:08,520
it's implemented as four kilobytes so by

00:12:06,030 --> 00:12:10,320
just having one line you can translate

00:12:08,520 --> 00:12:13,050
four kilobytes of RAM and it's more

00:12:10,320 --> 00:12:13,680
efficient like this that's what everyone

00:12:13,050 --> 00:12:18,570
is doing

00:12:13,680 --> 00:12:21,060
basically so okay so we're accessing

00:12:18,570 --> 00:12:23,280
this page table in RAM but we're not

00:12:21,060 --> 00:12:26,790
doing it all the time because it's very

00:12:23,280 --> 00:12:28,440
slow DRAM is really slow so we're going

00:12:26,790 --> 00:12:30,060
through that what's called TLB

00:12:28,440 --> 00:12:31,710
translation lookaside buffer and it's

00:12:30,060 --> 00:12:33,870
just a cache like the

00:12:31,710 --> 00:12:37,200
destruction of data cache but it caches

00:12:33,870 --> 00:12:41,280
a translation of virtual address to

00:12:37,200 --> 00:12:42,900
physical address so this way if TV

00:12:41,280 --> 00:12:46,800
contains information you're looking for

00:12:42,900 --> 00:12:48,930
in just one cycle you get your physical

00:12:46,800 --> 00:12:51,900
address translation and you then you can

00:12:48,930 --> 00:12:54,750
play with it so it's pretty handy and

00:12:51,900 --> 00:13:03,240
this is an on-chip cache so it's really

00:12:54,750 --> 00:13:07,920
fast access okay and then okay and then

00:13:03,240 --> 00:13:10,440
in theory the one when you are accessing

00:13:07,920 --> 00:13:11,730
the TLB and it doesn't contain the

00:13:10,440 --> 00:13:14,640
information you're looking for because

00:13:11,730 --> 00:13:18,120
as a cache is just a subset it's pretty

00:13:14,640 --> 00:13:20,220
small you should have a way to then

00:13:18,120 --> 00:13:23,640
access really the page table in the slow

00:13:20,220 --> 00:13:28,470
D Ram to get the information and refill

00:13:23,640 --> 00:13:31,290
the TLB and usually hardware does this

00:13:28,470 --> 00:13:35,010
so that's here we should directly go to

00:13:31,290 --> 00:13:37,710
main memory and to the Refresh but here

00:13:35,010 --> 00:13:40,620
in the design which are both chosen only

00:13:37,710 --> 00:13:43,770
for to be to be easier to implement and

00:13:40,620 --> 00:13:46,920
for simplicity we're not doing this

00:13:43,770 --> 00:13:49,230
so the TLB won't fetch from page table

00:13:46,920 --> 00:13:51,180
directly there is no hard web page we

00:13:49,230 --> 00:13:57,240
walk so we'll need the help of the

00:13:51,180 --> 00:13:58,980
operating system here so in fact if the

00:13:57,240 --> 00:14:02,880
information is not in the TLB it will

00:13:58,980 --> 00:14:05,040
trigger an exception and will trap into

00:14:02,880 --> 00:14:07,650
the operating system and the operating

00:14:05,040 --> 00:14:11,070
system will have to fix the stuff so to

00:14:07,650 --> 00:14:16,500
go read page table find some way to do

00:14:11,070 --> 00:14:19,800
it in even if the MMU is off etc and

00:14:16,500 --> 00:14:23,040
then when the information is there to

00:14:19,800 --> 00:14:25,850
refill the TLB - so to update to put the

00:14:23,040 --> 00:14:30,720
mapping inside and then to assume what

00:14:25,850 --> 00:14:34,220
what was going on so it's a bit like

00:14:30,720 --> 00:14:38,760
what most mixes are doing or even

00:14:34,220 --> 00:14:40,800
PowerPC bulky and it's not the the the

00:14:38,760 --> 00:14:46,709
most efficient way but it's easier to

00:14:40,800 --> 00:14:53,190
- so the TLB is entirely managed by

00:14:46,709 --> 00:14:57,120
software okay so I said the features of

00:14:53,190 --> 00:14:59,730
this mmm you only use four kilobyte

00:14:57,120 --> 00:15:01,560
pages so it's not configurable you

00:14:59,730 --> 00:15:07,200
cannot say okay I want one megabyte page

00:15:01,560 --> 00:15:10,860
size and some so quick question I've got

00:15:07,200 --> 00:15:13,680
a 32-bit physical address if the page

00:15:10,860 --> 00:15:15,269
size is 4 kilobytes how many bits of the

00:15:13,680 --> 00:15:25,170
address indicates the offset within a

00:15:15,269 --> 00:15:27,649
given page well it depends what you mean

00:15:25,170 --> 00:15:27,649
by this

00:15:30,320 --> 00:15:44,220
yeah if you do a byte access you can too

00:15:41,100 --> 00:15:49,440
to indicate enough set within a page so

00:15:44,220 --> 00:15:53,329
it's the lowest bits there's alignment

00:15:49,440 --> 00:15:53,329
when you access devar

00:16:12,600 --> 00:16:19,560
yeah is there is byte addressing inside

00:16:15,940 --> 00:16:22,899
Mecca 32 and since it's a new it can be

00:16:19,560 --> 00:16:26,519
an a-line just for the by addressing to

00:16:22,899 --> 00:16:31,810
me anyway so here's the the usual case

00:16:26,519 --> 00:16:35,769
there's no trick in the question so so

00:16:31,810 --> 00:16:38,350
yeah it's as usual its it's 12 bits for

00:16:35,769 --> 00:16:40,360
the for the 4k so we've got the page

00:16:38,350 --> 00:16:43,540
number on the left which is 20 bits and

00:16:40,360 --> 00:16:48,069
the offset within the page which is 12

00:16:43,540 --> 00:16:49,660
bits so there are two TLB is two took

00:16:48,069 --> 00:16:51,790
suffered sort of caches for the

00:16:49,660 --> 00:16:56,079
translation one for instruction one for

00:16:51,790 --> 00:16:59,889
data and they are pretty big but it's to

00:16:56,079 --> 00:17:02,290
cope with the slow leanness of having to

00:16:59,889 --> 00:17:05,760
do it in software each time information

00:17:02,290 --> 00:17:08,589
is missing so we want

00:17:05,760 --> 00:17:11,799
let's hear me to be really big

00:17:08,589 --> 00:17:13,510
so that most of the time for lucky

00:17:11,799 --> 00:17:19,569
information is not missing and it's in

00:17:13,510 --> 00:17:22,600
the TLB so there are 1,024 entries so 10

00:17:19,569 --> 00:17:25,539
bits to index those it will be useful

00:17:22,600 --> 00:17:27,490
information for later so as another as I

00:17:25,539 --> 00:17:30,789
said know how to a page tree worker so

00:17:27,490 --> 00:17:34,030
it's told Tobs system so ok well

00:17:30,789 --> 00:17:36,549
something a bit like this so we feed a

00:17:34,030 --> 00:17:39,549
virtual address we feed if it's a load

00:17:36,549 --> 00:17:41,350
or a store in string show data and then

00:17:39,549 --> 00:17:44,620
the MM you will answer ok this is a

00:17:41,350 --> 00:17:47,130
physical address and ok I grant you the

00:17:44,620 --> 00:17:50,200
access for instance or I deny you it and

00:17:47,130 --> 00:17:52,330
but here in this case since he still be

00:17:50,200 --> 00:17:54,940
assisted we need a way to say say I

00:17:52,330 --> 00:17:56,740
don't know because maybe the mm doesn't

00:17:54,940 --> 00:17:58,539
know the answer and then that's where

00:17:56,740 --> 00:18:01,900
the software operating system part kicks

00:17:58,539 --> 00:18:07,840
in so ok now let's have a look inside

00:18:01,900 --> 00:18:11,110
how the TV works a bit so I'll just walk

00:18:07,840 --> 00:18:13,900
you through it by translating a virtual

00:18:11,110 --> 00:18:19,450
address so let's take for instance this

00:18:13,900 --> 00:18:24,080
virtual address a triple 0 1 wo 4 only

00:18:19,450 --> 00:18:31,280
showed the three first line of the TLD

00:18:24,080 --> 00:18:33,169
line index is just handy for for the

00:18:31,280 --> 00:18:35,510
talk but it's not actually information

00:18:33,169 --> 00:18:37,880
inside the TLB it's you only contains a

00:18:35,510 --> 00:18:42,620
tag physical page number a read only bit

00:18:37,880 --> 00:18:45,169
and a valid bit so how does it work so

00:18:42,620 --> 00:18:46,700
first we split a virtual address into

00:18:45,169 --> 00:18:49,340
the page number and I've set in the page

00:18:46,700 --> 00:18:55,340
the offset is not really useful for now

00:18:49,340 --> 00:18:58,510
so we're going to put it apart okay so

00:18:55,340 --> 00:19:00,860
we've got our virtual page number that's

00:18:58,510 --> 00:19:05,200
that's the thing we are going to

00:19:00,860 --> 00:19:09,169
translate so we eat Frances a a 0 0 1

00:19:05,200 --> 00:19:12,679
how do we do it first we write it in

00:19:09,169 --> 00:19:18,830
binary and then before I said the TLB is

00:19:12,679 --> 00:19:21,980
undec by 10 bits so we take those 10

00:19:18,830 --> 00:19:25,010
lower bits of the virtual page number

00:19:21,980 --> 00:19:29,480
and those will index this here B so that

00:19:25,010 --> 00:19:33,860
will so that will choose the line that

00:19:29,480 --> 00:19:37,159
is interesting to us so here it's 1 so

00:19:33,860 --> 00:19:41,120
we will choose the line number 1 so

00:19:37,159 --> 00:19:46,520
that's where maybe the information is so

00:19:41,120 --> 00:19:50,120
then okay the valid bit is 1 so ok it's

00:19:46,520 --> 00:19:51,740
at least a valid information then we've

00:19:50,120 --> 00:19:54,500
got also the information that it's a

00:19:51,740 --> 00:19:56,380
read-only mapping so if the access is

00:19:54,500 --> 00:20:00,370
writing it will be denied for instance

00:19:56,380 --> 00:20:02,870
then we've got the physical page number

00:20:00,370 --> 00:20:04,880
okay that could be our answer and then

00:20:02,870 --> 00:20:09,710
we've got this word information it's a

00:20:04,880 --> 00:20:11,480
tag okay why I'm saying I am I saying

00:20:09,710 --> 00:20:15,559
maybe it's information we're looking for

00:20:11,480 --> 00:20:18,770
because you saw that I only took the ten

00:20:15,559 --> 00:20:22,460
lowest bits part of the virtual page

00:20:18,770 --> 00:20:27,320
number to address this TLB so whatever

00:20:22,460 --> 00:20:29,330
the value of the first bits here I would

00:20:27,320 --> 00:20:31,970
have chosen anyway the same line the

00:20:29,330 --> 00:20:35,149
line number one so we have kind of a

00:20:31,970 --> 00:20:37,220
fight for this line it could be a

00:20:35,149 --> 00:20:39,499
translation for a lot of

00:20:37,220 --> 00:20:41,659
virtual addresses so we need to check

00:20:39,499 --> 00:20:42,379
that that's we'll really the one we're

00:20:41,659 --> 00:20:44,299
looking for

00:20:42,379 --> 00:20:45,499
and to do this we're using the tag

00:20:44,299 --> 00:20:48,429
information here

00:20:45,499 --> 00:20:52,609
Justin bits so we're taking the value

00:20:48,429 --> 00:20:54,590
280 our translated thing it bitten

00:20:52,609 --> 00:20:58,820
binary and when comparing we're doing

00:20:54,590 --> 00:21:02,239
the tag check and okay we see that it's

00:20:58,820 --> 00:21:04,159
the same so that's how we know that it's

00:21:02,239 --> 00:21:07,519
really the formation we were looking for

00:21:04,159 --> 00:21:13,029
and then the physical page number column

00:21:07,519 --> 00:21:15,679
will contain really our results so the

00:21:13,029 --> 00:21:18,289
physical page number is the B triple

00:21:15,679 --> 00:21:23,330
zero one and then to get really the

00:21:18,289 --> 00:21:25,609
entire physical Adric we append the page

00:21:23,330 --> 00:21:27,349
offset so okay we've done the

00:21:25,609 --> 00:21:31,070
translation that's basically how it

00:21:27,349 --> 00:21:35,239
works at the moment in the MCOs 52 c pu

00:21:31,070 --> 00:21:39,369
+ m mu except that now i needed to add

00:21:35,239 --> 00:21:43,039
an address space ID to the chair

00:21:39,369 --> 00:21:45,080
to make it work so but that's basically

00:21:43,039 --> 00:21:51,129
it it's okay

00:21:45,080 --> 00:21:57,200
enough for the other parts no just

00:21:51,129 --> 00:22:01,879
report to you how I managed to progress

00:21:57,200 --> 00:22:04,940
and actually running at BSD kernel

00:22:01,879 --> 00:22:08,119
so first very cool thing that I enjoyed

00:22:04,940 --> 00:22:11,389
is that everything is kind of cross

00:22:08,119 --> 00:22:14,629
compilation so I could work for instance

00:22:11,389 --> 00:22:17,239
on my macbook and Mac OS and there was

00:22:14,629 --> 00:22:20,779
no issue with it so I could just run

00:22:17,239 --> 00:22:22,399
this command and it would just generate

00:22:20,779 --> 00:22:25,549
for me a cross compilation tool chain

00:22:22,399 --> 00:22:27,590
that runs on Mac OS but targets lattice

00:22:25,549 --> 00:22:30,649
miko city to architecture and it was

00:22:27,590 --> 00:22:32,779
really handy build that sh is doing it

00:22:30,649 --> 00:22:36,950
for me and it's pretty awesome - I was

00:22:32,779 --> 00:22:39,830
very surprised so I had to hack some

00:22:36,950 --> 00:22:42,499
make files there and there - to get it

00:22:39,830 --> 00:22:44,779
to to work because the architecture will

00:22:42,499 --> 00:22:48,700
not support it in the tree yet but it

00:22:44,779 --> 00:22:51,759
was really really useful

00:22:48,700 --> 00:22:51,759
[Music]

00:22:52,039 --> 00:23:05,580
okay an issue I I had was that the

00:23:02,309 --> 00:23:07,650
colonel is not linked against Lib GCC so

00:23:05,580 --> 00:23:10,710
I had a lot of missing symbols when I

00:23:07,650 --> 00:23:14,039
was at the end trying to link my colonel

00:23:10,710 --> 00:23:15,480
and I was wondering why and in fact okay

00:23:14,039 --> 00:23:18,270
I understood later it's not linked

00:23:15,480 --> 00:23:20,399
really Lib GCC so every time there was a

00:23:18,270 --> 00:23:23,610
multiplication or division of motherÃ­s

00:23:20,399 --> 00:23:26,130
operation well instead of doing in line

00:23:23,610 --> 00:23:28,529
the code was inserting calls to those

00:23:26,130 --> 00:23:31,710
utility functions and there were not

00:23:28,529 --> 00:23:34,620
linked with it so instead the killer is

00:23:31,710 --> 00:23:37,980
linked with Lipkin and okay I learned

00:23:34,620 --> 00:23:40,049
that I had to go to this Cicely bleep

00:23:37,980 --> 00:23:42,970
con and add the directory from

00:23:40,049 --> 00:23:45,440
architecture and put it put there the

00:23:42,970 --> 00:23:48,000
[Music]

00:23:45,440 --> 00:23:54,299
utility functions to do the mathematical

00:23:48,000 --> 00:23:58,020
operation okay then my first goal was

00:23:54,299 --> 00:24:00,570
trying to at least get a binary image to

00:23:58,020 --> 00:24:03,690
get it to link even if it didn't work

00:24:00,570 --> 00:24:05,730
because first you've got to to get some

00:24:03,690 --> 00:24:10,710
binary to try to run it and then try to

00:24:05,730 --> 00:24:14,240
debug so I just tried to to fill the

00:24:10,710 --> 00:24:18,270
include and configuration and

00:24:14,240 --> 00:24:20,010
directories by copying a bit what's what

00:24:18,270 --> 00:24:21,929
did what exists in the other

00:24:20,010 --> 00:24:24,059
architecture trying to understand how it

00:24:21,929 --> 00:24:28,710
works some time at first I didn't

00:24:24,059 --> 00:24:32,220
understand exactly what I was supposed

00:24:28,710 --> 00:24:34,080
to put so I kind of cop I and and then

00:24:32,220 --> 00:24:36,990
for all the missing symbol I'll just put

00:24:34,080 --> 00:24:40,860
stubs because I really wanted to be able

00:24:36,990 --> 00:24:43,260
to to get this elf image and okay I try

00:24:40,860 --> 00:24:45,289
to run it and then debug one by one or

00:24:43,260 --> 00:24:48,510
the issue and write the missing pieces

00:24:45,289 --> 00:24:52,110
so first tab everything runs this really

00:24:48,510 --> 00:24:55,140
simple command and then in the end when

00:24:52,110 --> 00:24:58,620
I got the elf I could try to really

00:24:55,140 --> 00:25:00,070
implement something first thing I needed

00:24:58,620 --> 00:25:02,379
to debug so

00:25:00,070 --> 00:25:06,039
to print something on the console so I

00:25:02,379 --> 00:25:08,679
did a very basic console driver only for

00:25:06,039 --> 00:25:10,239
early prints and it's really not

00:25:08,679 --> 00:25:12,789
difficult to do you just declare a

00:25:10,239 --> 00:25:15,549
struct where you put your callback

00:25:12,789 --> 00:25:19,229
function for reading a character of

00:25:15,549 --> 00:25:25,479
writing a character to the UART and then

00:25:19,229 --> 00:25:27,850
it will be used later on so I needed to

00:25:25,479 --> 00:25:33,099
implement of course the exception

00:25:27,850 --> 00:25:34,720
handlers but the first function is reset

00:25:33,099 --> 00:25:38,470
handler which is executed in this case

00:25:34,720 --> 00:25:41,940
and then for that's the code executed

00:25:38,470 --> 00:25:48,659
when you've got an irq or TLB maze

00:25:41,940 --> 00:25:51,309
exceptional this kind of stuff and then

00:25:48,659 --> 00:25:55,570
at startup it's called the milky me

00:25:51,309 --> 00:25:58,950
startup C code then it initializes the

00:25:55,570 --> 00:26:01,570
console driver by using the previously

00:25:58,950 --> 00:26:04,899
written structure so if you remember

00:26:01,570 --> 00:26:07,779
this Mickey Mouse come comes I'm it's

00:26:04,899 --> 00:26:10,690
pretty easy is just you assign to C n

00:26:07,779 --> 00:26:12,849
tab a pointer to this structure and then

00:26:10,690 --> 00:26:16,479
the whole system knows that when you do

00:26:12,849 --> 00:26:18,340
prints by the referencing a whole bunch

00:26:16,479 --> 00:26:20,489
of pointers it will end up in you in

00:26:18,340 --> 00:26:23,649
your structure and you will call you

00:26:20,489 --> 00:26:25,419
your print function so by just assigning

00:26:23,649 --> 00:26:29,769
the structure it's okay than you can do

00:26:25,419 --> 00:26:33,009
prints and you can do easy debug so that

00:26:29,769 --> 00:26:34,899
was convenience then pretty early in

00:26:33,009 --> 00:26:36,249
this military startup function you need

00:26:34,899 --> 00:26:39,039
to initialize the virtual memory

00:26:36,249 --> 00:26:41,259
subsystem so you do this by calling the

00:26:39,039 --> 00:26:45,639
machine-dependent pmadd bootstrap

00:26:41,259 --> 00:26:48,879
function that's basically where you

00:26:45,639 --> 00:26:51,220
register the physical run which is

00:26:48,879 --> 00:26:54,639
available in the system you say to UVM

00:26:51,220 --> 00:26:57,609
ok I've got that much pages and starts

00:26:54,639 --> 00:26:59,470
here and it ends there and ok you can

00:26:57,609 --> 00:27:04,869
deal with it and you can do a location

00:26:59,470 --> 00:27:07,450
on this pool and then when basically

00:27:04,869 --> 00:27:09,609
those a very simple initialization is

00:27:07,450 --> 00:27:10,629
done you can call main function which is

00:27:09,609 --> 00:27:12,400
machine-independent

00:27:10,629 --> 00:27:15,880
and it's

00:27:12,400 --> 00:27:19,600
basically a very long list of sub system

00:27:15,880 --> 00:27:27,190
initialization calls so then you're in

00:27:19,600 --> 00:27:29,200
the in the usual net BST column so but

00:27:27,190 --> 00:27:31,900
then you need to implement a few stuff

00:27:29,200 --> 00:27:36,120
like P map the pmab sub system as I said

00:27:31,900 --> 00:27:39,250
is the kind of the virtual memory system

00:27:36,120 --> 00:27:42,100
it's not so straightforward to implement

00:27:39,250 --> 00:27:44,290
but the really good news and the really

00:27:42,100 --> 00:27:47,140
good surprise I had is that I didn't

00:27:44,290 --> 00:27:49,960
have to do it and that's pretty cool

00:27:47,140 --> 00:27:55,210
the less you write code less burg you

00:27:49,960 --> 00:27:57,820
have so since my Cosatu is software

00:27:55,210 --> 00:28:01,630
managed TLB and there is already code

00:27:57,820 --> 00:28:04,630
for that thanks to Maximus I all I only

00:28:01,630 --> 00:28:08,140
had to use the files in CCO VMP map

00:28:04,630 --> 00:28:10,630
which already used in a 4pc buki and ok

00:28:08,140 --> 00:28:13,360
the pin system subsystem was done I only

00:28:10,630 --> 00:28:16,870
had to do the the first function which

00:28:13,360 --> 00:28:20,980
is just P my bootstrap but all the rest

00:28:16,870 --> 00:28:25,660
was working fine so far so that's a good

00:28:20,980 --> 00:28:27,610
surprise then you've got some stuff like

00:28:25,660 --> 00:28:29,679
copying copier which are basically

00:28:27,610 --> 00:28:32,559
taking data from the users first process

00:28:29,679 --> 00:28:35,500
copying it to kernel memory and the

00:28:32,559 --> 00:28:39,549
other way around then you've got to

00:28:35,500 --> 00:28:45,010
implement atomic operations there is no

00:28:39,549 --> 00:28:47,830
atomic instruction in micro 32 so I by

00:28:45,010 --> 00:28:50,980
reading basically the kernel code of net

00:28:47,830 --> 00:28:54,190
Biasi I learned about this technique the

00:28:50,980 --> 00:28:55,720
restartable atomic sequence for

00:28:54,190 --> 00:28:58,870
implementing the basic compare-and-swap

00:28:55,720 --> 00:29:01,059
which is the core of all the

00:28:58,870 --> 00:29:06,130
implementation of a mutex pin locks and

00:29:01,059 --> 00:29:08,590
all the stuff like this and so it works

00:29:06,130 --> 00:29:12,160
a bit like this that's the actual code I

00:29:08,590 --> 00:29:16,290
have implemented for the restore table

00:29:12,160 --> 00:29:16,290
to make sequence so

00:29:16,830 --> 00:29:21,510
the interesting thing is that since

00:29:19,260 --> 00:29:24,680
there is no atomic operation in Mecca

00:29:21,510 --> 00:29:27,570
city - obviously it takes here five

00:29:24,680 --> 00:29:31,890
assembly instructions so it's really not

00:29:27,570 --> 00:29:33,930
atomic at all so how does it work if I'm

00:29:31,890 --> 00:29:37,350
ever interrupted for instance by an

00:29:33,930 --> 00:29:41,130
exception most likely an ir q 4 in the

00:29:37,350 --> 00:29:45,150
middle of this supposedly atomic

00:29:41,130 --> 00:29:49,260
operation then in the return path when I

00:29:45,150 --> 00:29:51,090
will return back to what I was doing so

00:29:49,260 --> 00:29:55,110
in this case this as a mere cooperation

00:29:51,090 --> 00:29:58,590
I check if the PC with the return PC is

00:29:55,110 --> 00:30:01,590
in between the kasra start symbol or the

00:29:58,590 --> 00:30:03,870
class rust or Casarez and symbol and in

00:30:01,590 --> 00:30:07,710
this case instead of just returning to

00:30:03,870 --> 00:30:09,390
the PC to where I was executing so for

00:30:07,710 --> 00:30:11,850
instance maybe returning to the store

00:30:09,390 --> 00:30:15,450
water once plus 0y3

00:30:11,850 --> 00:30:18,570
then I choose to return to the Kasbah

00:30:15,450 --> 00:30:22,200
star so I rewind I go to the start and

00:30:18,570 --> 00:30:24,900
restart again so I found it a pretty

00:30:22,200 --> 00:30:29,130
cool trick and I didn't know about that

00:30:24,900 --> 00:30:31,350
so that's what I use and then you need

00:30:29,130 --> 00:30:34,560
to indeed add support for interrupts to

00:30:31,350 --> 00:30:37,170
handle them but even to let the driver

00:30:34,560 --> 00:30:39,870
register the interrupts call backs so

00:30:37,170 --> 00:30:44,190
you need to be to do a bit of code about

00:30:39,870 --> 00:30:47,730
this and then you need a running system

00:30:44,190 --> 00:30:53,640
clock to let the system be able to

00:30:47,730 --> 00:30:56,250
schedule a WPS read stuff like that so

00:30:53,640 --> 00:30:58,200
so you need basically on the mckimie

00:30:56,250 --> 00:30:59,880
system chip there are two timers so I'm

00:30:58,200 --> 00:31:03,690
using one of the two timers would you

00:30:59,880 --> 00:31:05,100
just if the system ticks and and there

00:31:03,690 --> 00:31:08,490
is a global symbol you need to implement

00:31:05,100 --> 00:31:10,770
it's called CPU in it clocks and its

00:31:08,490 --> 00:31:13,470
main goal is just to set up this so to

00:31:10,770 --> 00:31:16,860
actually to initialize the timer to

00:31:13,470 --> 00:31:19,740
activate it to register the clock arrow

00:31:16,860 --> 00:31:22,770
Q hundred and and do this kind of stuff

00:31:19,740 --> 00:31:25,350
and then another thing is that your

00:31:22,770 --> 00:31:27,660
clock either Q hundred needs to call a

00:31:25,350 --> 00:31:29,610
machine independent

00:31:27,660 --> 00:31:30,680
symbol which is hard clock and that's

00:31:29,610 --> 00:31:33,080
how it plugs

00:31:30,680 --> 00:31:36,140
all together a true to go from the

00:31:33,080 --> 00:31:38,210
machine-dependent code to then the the

00:31:36,140 --> 00:31:40,250
rest of the system to do the time

00:31:38,210 --> 00:31:41,900
accounting and the scheduling stuff so

00:31:40,250 --> 00:31:45,770
you need to plug to the hard clock

00:31:41,900 --> 00:31:47,570
system then there is a whole bunch of

00:31:45,770 --> 00:31:49,340
all the function that you know detail

00:31:47,570 --> 00:31:52,180
because it would be really too long but

00:31:49,340 --> 00:31:56,180
you need to implement CPU switch to

00:31:52,180 --> 00:32:00,170
which is basically the machine dependent

00:31:56,180 --> 00:32:04,520
function to switch from one lwp to

00:32:00,170 --> 00:32:09,910
another so LBP is lightweight process if

00:32:04,520 --> 00:32:13,250
I'm missing and then k copy to copy data

00:32:09,910 --> 00:32:21,110
set fall to safe current context and for

00:32:13,250 --> 00:32:23,750
cooperation to create process and really

00:32:21,110 --> 00:32:26,179
cool stuff I enjoyed about the net bsd

00:32:23,750 --> 00:32:29,000
environment and ecosystem is that the

00:32:26,179 --> 00:32:31,280
small nine in the parenthesis is that

00:32:29,000 --> 00:32:34,280
for kernel code function you've got man

00:32:31,280 --> 00:32:36,559
pages and you don't have this on all

00:32:34,280 --> 00:32:38,690
operating systems so I found it really

00:32:36,559 --> 00:32:40,940
cool I want you to know how to implement

00:32:38,690 --> 00:32:43,700
CPU switch to what it was supposed to do

00:32:40,940 --> 00:32:45,950
I don't have any clue I could okay I

00:32:43,700 --> 00:32:48,980
read the other architecture but I I just

00:32:45,950 --> 00:32:51,620
had to type man and CPU switch to and I

00:32:48,980 --> 00:32:55,280
had my answers and a bit of how it

00:32:51,620 --> 00:33:00,020
should work so that it was pretty cool

00:32:55,280 --> 00:33:03,350
and so then order a functional I had to

00:33:00,020 --> 00:33:06,080
implement so SPE is to block interrupts

00:33:03,350 --> 00:33:07,280
so that in some critical sections you

00:33:06,080 --> 00:33:09,140
don't want to be bothered by any

00:33:07,280 --> 00:33:13,460
interrupted so you can block them and

00:33:09,140 --> 00:33:16,100
then reassembled them afterwards and ok

00:33:13,460 --> 00:33:26,240
CPU start of a basic level of machine

00:33:16,100 --> 00:33:28,970
dependent function ok then I want you to

00:33:26,240 --> 00:33:34,010
try to boot user space when the kernel

00:33:28,970 --> 00:33:35,990
was fully booting so to do it I had to

00:33:34,010 --> 00:33:40,880
create a dummy Ram disk containing only

00:33:35,990 --> 00:33:42,710
one binary which is in it then I built

00:33:40,880 --> 00:33:44,420
the kernel with the NFS option which is

00:33:42,710 --> 00:33:48,140
memory

00:33:44,420 --> 00:33:50,840
five system which allows you to embed

00:33:48,140 --> 00:33:53,030
inside your kernel image around this

00:33:50,840 --> 00:33:56,270
basically so a filesystem which is which

00:33:53,030 --> 00:33:59,090
will be in RAM you inserting the kernel

00:33:56,270 --> 00:34:04,280
layer then you try to put it that's to

00:33:59,090 --> 00:34:06,679
approach I had and that's basically

00:34:04,280 --> 00:34:09,139
where the to press the progress of the

00:34:06,679 --> 00:34:12,139
project is right now it's totally kernel

00:34:09,139 --> 00:34:14,649
boots and it's booting and it's running

00:34:12,139 --> 00:34:18,080
the init which is a really a small

00:34:14,649 --> 00:34:20,419
handcrafted statically linked crappy in

00:34:18,080 --> 00:34:24,560
it just printing hello world but I

00:34:20,419 --> 00:34:27,350
thought it's cool it's at least runs so

00:34:24,560 --> 00:34:35,690
okay time for the demo as I'm saying it

00:34:27,350 --> 00:34:38,780
runs let's try to see if it's true okay

00:34:35,690 --> 00:34:38,780
[Music]

00:34:39,879 --> 00:34:49,179
so let's just compile it for the fun

00:34:44,679 --> 00:34:49,179
just touch one file

00:34:51,389 --> 00:34:57,819
and then so I'm it's pretty easy to come

00:34:55,179 --> 00:35:04,109
by or just use build that Sh

00:34:57,819 --> 00:35:04,109
and should just compile out of the box

00:35:04,230 --> 00:35:18,039
okay so then you've got Kanu here then

00:35:16,089 --> 00:35:27,910
you can use Q mu which is really handy

00:35:18,039 --> 00:35:29,740
to debug to run this kernel so you say

00:35:27,910 --> 00:35:33,700
you want to run the milk Emma

00:35:29,740 --> 00:35:52,319
system-on-chip you select RH

00:35:33,700 --> 00:35:52,319
maybe it's a bit small okay okay so

00:35:54,150 --> 00:36:01,720
second assistantship you say you want to

00:35:57,940 --> 00:36:05,289
use LM thirty-two with full divider and

00:36:01,720 --> 00:36:08,079
multiplier and with M mu you don't need

00:36:05,289 --> 00:36:18,789
graphic and you say like where the

00:36:08,079 --> 00:36:24,009
kernel is so suggest kernel going to

00:36:18,789 --> 00:36:27,130
happen gdb and okay let's run it with

00:36:24,009 --> 00:36:29,470
gdb and that's really handy because

00:36:27,130 --> 00:36:33,940
that's basically how I debug the

00:36:29,470 --> 00:36:36,369
debugging all the problems I had is that

00:36:33,940 --> 00:36:38,680
there is a gdb server inside Q mu you

00:36:36,369 --> 00:36:44,789
can just attach it and look at all

00:36:38,680 --> 00:36:44,789
memory registers etc so let's attach

00:36:45,210 --> 00:36:50,700
okay it's more

00:36:54,290 --> 00:37:08,910
what okay I forgot to do something I

00:37:06,600 --> 00:37:12,420
just build the colonel but I didn't put

00:37:08,910 --> 00:37:15,780
the RAM FS inside so if I just hit

00:37:12,420 --> 00:37:20,570
continue it you just okay so you see at

00:37:15,780 --> 00:37:23,820
least the criminal boots so you've got

00:37:20,570 --> 00:37:26,340
okay I've put a lot of debugging prints

00:37:23,820 --> 00:37:32,130
but basically you had started just the P

00:37:26,340 --> 00:37:35,550
map bootstrap and it registers using u

00:37:32,130 --> 00:37:42,090
vm page phys loaded registers available

00:37:35,550 --> 00:37:46,760
ram ram size you say it registered a

00:37:42,090 --> 00:37:54,030
bunch of pages in the system and then it

00:37:46,760 --> 00:37:56,190
calls okay then it it initializes a

00:37:54,030 --> 00:37:59,160
peanut module etc and then you call main

00:37:56,190 --> 00:38:00,800
I've put a few prints of the main what's

00:37:59,160 --> 00:38:06,900
the main doing so basically it

00:38:00,800 --> 00:38:09,420
initializes all the subsystem and then

00:38:06,900 --> 00:38:11,940
it's trying to initialize all the

00:38:09,420 --> 00:38:15,300
drivers of faunal a very few rival only

00:38:11,940 --> 00:38:18,330
the timer then the UART

00:38:15,300 --> 00:38:21,660
and the clock which is the other timer

00:38:18,330 --> 00:38:25,980
and during the clock ticks then you turn

00:38:21,660 --> 00:38:30,570
on interrupts and then it tries to find

00:38:25,980 --> 00:38:32,310
a root filesystem which is not ah it's

00:38:30,570 --> 00:38:34,980
not managing to find the root filesystem

00:38:32,310 --> 00:38:42,380
so it's in the booty so now let's try to

00:38:34,980 --> 00:38:42,380
put a ram disk so

00:38:46,160 --> 00:39:00,380
so here I'm creating a dummy file

00:38:50,599 --> 00:39:07,519
I'm putting DEFCON saw corrective device

00:39:00,380 --> 00:39:10,759
I'm creating ffs and I'm compiling my in

00:39:07,519 --> 00:39:15,380
it statically linked in it inside the

00:39:10,759 --> 00:39:18,109
RAM FS and then using MD set image I'm

00:39:15,380 --> 00:39:20,029
embedding the Rama face inside the

00:39:18,109 --> 00:39:26,859
kernel so no it should boot a little bit

00:39:20,029 --> 00:39:26,859
further so let's run it again

00:39:31,809 --> 00:39:35,829
first let's see what's inside

00:39:38,920 --> 00:39:47,450
okay so you've got the main out maybe in

00:39:44,900 --> 00:39:50,269
C okay that's basically what's the init

00:39:47,450 --> 00:39:54,259
is doing its really really almost

00:39:50,269 --> 00:39:58,039
nothing in just opening dev console for

00:39:54,259 --> 00:40:00,440
a CDN studio SEO and it's writing hello

00:39:58,039 --> 00:40:03,829
world so phone is really simple in its

00:40:00,440 --> 00:40:07,490
stuff and it statically linked so all

00:40:03,829 --> 00:40:10,960
the write and read and open functions

00:40:07,490 --> 00:40:13,640
are just inline assembly inside the unit

00:40:10,960 --> 00:40:20,720
so that's what we are going to try to

00:40:13,640 --> 00:40:23,210
run it should print hello world so there

00:40:20,720 --> 00:40:24,650
is a bug where after init it crashes so

00:40:23,210 --> 00:40:26,539
to prevent this I'm going to put a

00:40:24,650 --> 00:40:31,849
breakpoint on the last instruction of

00:40:26,539 --> 00:40:37,759
main just for the beauty of not hiding

00:40:31,849 --> 00:40:44,750
the crash pretty so so this is a virtual

00:40:37,759 --> 00:40:49,940
address and now if I show qmu and I do

00:40:44,750 --> 00:40:54,650
continue okay so then you see what's

00:40:49,940 --> 00:40:57,230
more is that it found a root filesystem

00:40:54,650 --> 00:40:58,870
which is of type ffs which was in the

00:40:57,230 --> 00:41:03,670
RAM file systems and

00:40:58,870 --> 00:41:05,800
warning and then it's loading in it and

00:41:03,670 --> 00:41:15,130
it's running it and you've got real

00:41:05,800 --> 00:41:18,010
world and then if you really want to see

00:41:15,130 --> 00:41:19,600
it crash you do consider and now you

00:41:18,010 --> 00:41:38,980
delete the breakpoint and you do

00:41:19,600 --> 00:41:43,870
continue and then you get okay so that's

00:41:38,980 --> 00:41:46,540
just memory layout which is I think it's

00:41:43,870 --> 00:41:48,940
- pretty usual once or three gigabytes

00:41:46,540 --> 00:41:53,560
for user space of virtual memory in one

00:41:48,940 --> 00:41:57,040
cuboid for kernel space so on the milk

00:41:53,560 --> 00:42:01,960
image border is only 128 megabytes of

00:41:57,040 --> 00:42:05,170
RAM and the interesting thing here is

00:42:01,960 --> 00:42:11,530
the RAM window I will explain a bit what

00:42:05,170 --> 00:42:15,400
it is so basically all the physical Ram

00:42:11,530 --> 00:42:20,320
has been mapped in this Ram window which

00:42:15,400 --> 00:42:23,440
is in the kernel address space so okay

00:42:20,320 --> 00:42:28,510
physical RAM status physical address 0 X

00:42:23,440 --> 00:42:32,140
for all 0 and basically all the

00:42:28,510 --> 00:42:34,720
beginning of the kernel virtual memory

00:42:32,140 --> 00:42:38,680
so starting at 0 XE all these beginning

00:42:34,720 --> 00:42:41,530
so from C 0 to C 8 it's in fact a direct

00:42:38,680 --> 00:42:45,040
mapping to the physical RAM so by using

00:42:41,530 --> 00:42:47,860
these virtual addresses you can

00:42:45,040 --> 00:42:51,180
basically access all the physical RAM

00:42:47,860 --> 00:42:55,750
and that's really handy for some stuff

00:42:51,180 --> 00:42:58,210
so for instance here is how I'm managing

00:42:55,750 --> 00:43:02,050
the page table it's too pretty again the

00:42:58,210 --> 00:43:06,400
standard usual way so you've got page

00:43:02,050 --> 00:43:09,370
directory and a page table so if you

00:43:06,400 --> 00:43:11,770
want you to again see where this virtual

00:43:09,370 --> 00:43:14,350
address is you to compose it and

00:43:11,770 --> 00:43:17,050
but you split it into the ten bits ten

00:43:14,350 --> 00:43:20,170
bits on twelve bits you take the top ten

00:43:17,050 --> 00:43:24,820
bits which are three so you index and

00:43:20,170 --> 00:43:27,130
you use the third row in the page

00:43:24,820 --> 00:43:29,170
directory it gives you the address of

00:43:27,130 --> 00:43:32,920
the page table you see see four it's the

00:43:29,170 --> 00:43:36,670
same over there and then you take the

00:43:32,920 --> 00:43:39,040
following ten bits and okay one zero

00:43:36,670 --> 00:43:41,800
it's it's two so you take the second

00:43:39,040 --> 00:43:45,280
line and this will give you will give

00:43:41,800 --> 00:43:48,610
you the the physical address and again

00:43:45,280 --> 00:43:51,400
you happened the offset okay this is a

00:43:48,610 --> 00:43:56,260
this is a data structure in the criminal

00:43:51,400 --> 00:43:57,610
to really manage and remember all the

00:43:56,260 --> 00:44:02,350
mappings all the virtual to physical

00:43:57,610 --> 00:44:06,270
mapping it but the kernel is running

00:44:02,350 --> 00:44:09,070
with members the MMU on so it cannot

00:44:06,270 --> 00:44:15,640
access to which to a physical addresses

00:44:09,070 --> 00:44:17,380
it couldn't work so ok you you think ok

00:44:15,640 --> 00:44:20,320
we'll put only virtual addresses in this

00:44:17,380 --> 00:44:22,600
structure this structure ok if put sea

00:44:20,320 --> 00:44:25,150
floor to point to my page table and it's

00:44:22,600 --> 00:44:27,369
I am ok but I need also to be able to

00:44:25,150 --> 00:44:30,100
access this data structure from the TLB

00:44:27,369 --> 00:44:33,820
miss Andrew and in Makati - it's running

00:44:30,100 --> 00:44:36,820
with Mme off so I cannot dereference

00:44:33,820 --> 00:44:39,460
this kind of pointer and that's where

00:44:36,820 --> 00:44:42,820
the window the run window kicks in

00:44:39,460 --> 00:44:44,890
because since it's a direct mapping it's

00:44:42,820 --> 00:44:46,780
really easy to translate from one to the

00:44:44,890 --> 00:44:53,020
other by just doing subtraction and

00:44:46,780 --> 00:44:55,150
addition so so I choose to put virtual

00:44:53,020 --> 00:44:58,330
addresses inside the page table and

00:44:55,150 --> 00:45:03,010
everything so for the kernel it's okay

00:44:58,330 --> 00:45:07,630
but when in exception handler I just do

00:45:03,010 --> 00:45:09,730
this computation so I can walk this page

00:45:07,630 --> 00:45:12,750
table from the exception along with no

00:45:09,730 --> 00:45:18,110
no issue because I know how to translate

00:45:12,750 --> 00:45:21,650
so that was the interesting properties

00:45:18,110 --> 00:45:23,450
okay it's pretty much done so if you

00:45:21,650 --> 00:45:25,550
want to follow progress about the spot

00:45:23,450 --> 00:45:28,460
it's really just the beginning since

00:45:25,550 --> 00:45:30,910
it's just loading small in it and there

00:45:28,460 --> 00:45:35,030
is no lip support yet and it doesn't run

00:45:30,910 --> 00:45:39,110
bunch of user space stuff so this is a

00:45:35,030 --> 00:45:42,680
static webpage giving the progress but I

00:45:39,110 --> 00:45:46,040
try to update also the wiki page on edge

00:45:42,680 --> 00:45:47,990
bsd website which shows you all what's

00:45:46,040 --> 00:45:51,590
working what's not working and how you

00:45:47,990 --> 00:45:54,800
can bootstrap the stuff so get the the

00:45:51,590 --> 00:45:56,600
correct git repository compiler to which

00:45:54,800 --> 00:45:59,360
the crust will shine compile the gdb

00:45:56,600 --> 00:46:01,850
compile the Q special Q mu Paul etc so

00:45:59,360 --> 00:46:05,300
everything is explained to directly

00:46:01,850 --> 00:46:09,200
start developing on it then I'm using

00:46:05,300 --> 00:46:14,900
I'm using git basically so omeka lism

00:46:09,200 --> 00:46:17,720
github but I imported all the net desi

00:46:14,900 --> 00:46:20,300
sauce wizard history so it's not an

00:46:17,720 --> 00:46:20,990
awesome we're working so a better thing

00:46:20,300 --> 00:46:23,840
is the

00:46:20,990 --> 00:46:28,880
edge BSD git repository which of all the

00:46:23,840 --> 00:46:34,850
history which is based on your mirror

00:46:28,880 --> 00:46:39,800
and that's there is a short URL about

00:46:34,850 --> 00:46:43,040
this so okay thank you for listening and

00:46:39,800 --> 00:46:45,650
also thanks to all those people and more

00:46:43,040 --> 00:46:50,090
that I forgot who really helped me a lot

00:46:45,650 --> 00:47:01,070
in this not so easy task but really cool

00:46:50,090 --> 00:47:03,190
and full of learning stuff thank you any

00:47:01,070 --> 00:47:03,190
questions

00:47:04,270 --> 00:47:17,800
I think your TLB is very large yes

00:47:15,400 --> 00:47:19,840
compared to others is do you notice

00:47:17,800 --> 00:47:21,940
did you experiment with smaller one and

00:47:19,840 --> 00:47:24,970
see how the performance is affected

00:47:21,940 --> 00:47:28,390
no I didn't try actory that's a good

00:47:24,970 --> 00:47:31,360
question yeah it's pretty large but

00:47:28,390 --> 00:47:33,670
what's cool is the FPGA is is that I get

00:47:31,360 --> 00:47:35,650
it mostly for free because when you're

00:47:33,670 --> 00:47:37,900
implementing this kind of caches you're

00:47:35,650 --> 00:47:41,440
implementing basically SRAM inside the

00:47:37,900 --> 00:47:44,080
FPGA and you have special Hardware

00:47:41,440 --> 00:47:47,140
blocks usually to implement those SRAM

00:47:44,080 --> 00:47:50,560
and anyway you're usually not using them

00:47:47,140 --> 00:47:53,530
so when you do logic a usually you do

00:47:50,560 --> 00:47:55,210
logic multiplexers etc and you don't use

00:47:53,530 --> 00:47:57,990
the S frame block so they sit there and

00:47:55,210 --> 00:48:03,550
used so anywhere you can use them and

00:47:57,990 --> 00:48:11,140
you can bigger caches and and yeah it's

00:48:03,550 --> 00:48:15,480
cool other questions to explain the

00:48:11,140 --> 00:48:18,490
process of synthesizing the CPU core and

00:48:15,480 --> 00:48:21,550
world building process from the scratch

00:48:18,490 --> 00:48:23,160
very locked source or VHDL source to to

00:48:21,550 --> 00:48:25,870
building the Cardinal ant

00:48:23,160 --> 00:48:28,930
bitstream is it possible to build a

00:48:25,870 --> 00:48:31,270
world soft CPU with your MMU extensions

00:48:28,930 --> 00:48:33,400
using only free tools for example

00:48:31,270 --> 00:48:36,960
without xylenes is a or other

00:48:33,400 --> 00:48:42,240
proprietary very locked synthesizers

00:48:36,960 --> 00:48:45,010
okay well indeed

00:48:42,240 --> 00:48:49,840
FPGA world is a bit sad because there is

00:48:45,010 --> 00:48:53,380
no full a to dead to chain which are

00:48:49,840 --> 00:48:56,410
open source so if you want you real fpga

00:48:53,380 --> 00:48:59,220
development you are forced to use closes

00:48:56,410 --> 00:49:04,510
vendor dependent a to shine like the

00:48:59,220 --> 00:49:07,450
Cylons ia sea or the ultra one etc so

00:49:04,510 --> 00:49:11,410
now if you cannot synthesize your system

00:49:07,450 --> 00:49:13,840
on chip well you cannot get to the bit

00:49:11,410 --> 00:49:16,600
rate blood to the bit stream file with

00:49:13,840 --> 00:49:17,710
only open source to chain but there is a

00:49:16,600 --> 00:49:20,800
bit of work into

00:49:17,710 --> 00:49:23,890
this direction and actually you can

00:49:20,800 --> 00:49:25,180
synthesize so only the first part of the

00:49:23,890 --> 00:49:28,589
other work because you need to

00:49:25,180 --> 00:49:31,150
synthesize and you need to map to the

00:49:28,589 --> 00:49:33,250
block technology and then you need to do

00:49:31,150 --> 00:49:37,359
the place and route etc so it only the

00:49:33,250 --> 00:49:38,980
first step of the pipeline it can be

00:49:37,359 --> 00:49:41,109
done an open source you can synthesize

00:49:38,980 --> 00:49:43,240
lattice mucosa tissue or even all the

00:49:41,109 --> 00:49:45,930
make a mist system and chip use in your

00:49:43,240 --> 00:49:47,890
uses which is an open source synthesizer

00:49:45,930 --> 00:49:51,369
so yeah thank you

00:49:47,890 --> 00:49:53,890
and another question is it possible to

00:49:51,369 --> 00:49:56,890
run that CPU in simulation in for

00:49:53,890 --> 00:49:59,530
example it's very low yes it does work

00:49:56,890 --> 00:50:02,440
and it helped me a lot to debug the MMU

00:49:59,530 --> 00:50:06,460
and implemented it I used several a

00:50:02,440 --> 00:50:08,770
simulator but I Varela also and okay

00:50:06,460 --> 00:50:11,890
it's simulated also by qmu as you could

00:50:08,770 --> 00:50:14,800
see but it's not at the gate level but

00:50:11,890 --> 00:50:21,160
yeah you can run it with Icarus okay

00:50:14,800 --> 00:50:26,410
thank you so so how much work was it

00:50:21,160 --> 00:50:29,589
doing the MMU implementation well in

00:50:26,410 --> 00:50:32,050
fact you know it's in theory it's pretty

00:50:29,589 --> 00:50:35,380
straightforward to design an MMU since

00:50:32,050 --> 00:50:38,050
it's just well a cache with a bunch of

00:50:35,380 --> 00:50:40,180
logic around but in practice since I was

00:50:38,050 --> 00:50:43,060
really a beginner it's kind of my first

00:50:40,180 --> 00:50:47,440
fpga project so took a year to implement

00:50:43,060 --> 00:50:50,109
and to test and debug etc but in theory

00:50:47,440 --> 00:50:52,570
it's not that complex but I was doing

00:50:50,109 --> 00:50:56,230
this project to learn so I had my own

00:50:52,570 --> 00:51:02,779
learning curve about this other

00:50:56,230 --> 00:51:06,569
questions okay

00:51:02,779 --> 00:51:12,180
and how much time did you to do the Napa

00:51:06,569 --> 00:51:14,309
steeples what well I I said I'm only

00:51:12,180 --> 00:51:15,959
doing this as a hobby project so in my

00:51:14,309 --> 00:51:20,400
spare time and it took really a hell of

00:51:15,959 --> 00:51:28,920
a long time maybe I'm not really good

00:51:20,400 --> 00:51:31,229
but yeah I started beginning of 2013 I

00:51:28,920 --> 00:51:33,569
think so it's one year and a half it's

00:51:31,229 --> 00:51:36,900
yeah it took a long time it's just one

00:51:33,569 --> 00:51:39,749
over there and one over there in the

00:51:36,900 --> 00:51:41,249
night or in the subway and it's really

00:51:39,749 --> 00:51:44,189
long to work like this it's not an

00:51:41,249 --> 00:51:46,079
eight-hour straight hours a day it's

00:51:44,189 --> 00:51:48,599
easier to work to work when you've got

00:51:46,079 --> 00:51:50,699
like it's 2 or 3 hours straight because

00:51:48,599 --> 00:51:53,099
then you got to remember what you did

00:51:50,699 --> 00:52:03,199
before except for a song yeah it took a

00:51:53,099 --> 00:52:03,199

YouTube URL: https://www.youtube.com/watch?v=npmbdZRLHJ8


