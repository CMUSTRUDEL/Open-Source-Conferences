Title: Parallel make: working with legacy code - Marc Espie
Publication date: 2019-10-13
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

OpenBSD uses a completely revamped version of the classical BSD bmake. It is much faster, works better, and is now fully parallel, to the extent we now fix bugs in Makefiles instead of work-arounds in make.Now that the work is mostly finished, we have enough experience to talk about what went right (and what went wrong, mostly extra delays that I would know how to avoid now).I will talk a lot about the modifications that went on over the years, in a very challenging environment: staying compatible with the existing Makefiles, in a tool that was at best poorly documented and is full of surprises.This is a prime example of OpenBSD philosophy â€œevolution, not revolutionâ€: the code in current make is almost entirely new, but it was replaced, one component at a time. Figuring out a battle plan to conquer the old rotting code was a very large part of that fight.

Speaker biography:

Senior developer in the OpenBSD project, teacher of development and security practices at a private graduate school.
Captions: 
	00:00:00,060 --> 00:00:08,400
okay so the next speaker here will be

00:00:02,639 --> 00:00:10,320
Marcus B mark is a long time and he's in

00:00:08,400 --> 00:00:15,360
charge of course of the port system

00:00:10,320 --> 00:00:17,640
which he rewrote and rang brought it to

00:00:15,360 --> 00:00:25,320
the shape that it is today so please

00:00:17,640 --> 00:00:26,910
mark thank you so today I'm going to

00:00:25,320 --> 00:00:28,710
talk about something apparently

00:00:26,910 --> 00:00:31,380
completely different except it's not

00:00:28,710 --> 00:00:35,399
because obviously it's ready to building

00:00:31,380 --> 00:00:36,750
stuff again and and it's quite a feat

00:00:35,399 --> 00:00:38,700
challenge to talk about that because

00:00:36,750 --> 00:00:41,809
it's work but I've been doing for a long

00:00:38,700 --> 00:00:44,309
time something over ten years by now and

00:00:41,809 --> 00:00:47,070
like matter and it's a yesterday there

00:00:44,309 --> 00:01:01,079
are lots of dragons here very much so

00:00:47,070 --> 00:01:09,570
oh yeah whose phone is with no where is

00:01:01,079 --> 00:01:12,960
it oh yeah it goes sorry about that so

00:01:09,570 --> 00:01:17,790
I'm going to is it you're working right

00:01:12,960 --> 00:01:19,650
yeah start with an example to give you

00:01:17,790 --> 00:01:20,369
an idea or how many dragons were in

00:01:19,650 --> 00:01:22,439
there

00:01:20,369 --> 00:01:24,600
I hope that everybody knows at least

00:01:22,439 --> 00:01:26,369
some mech so for instance you've got

00:01:24,600 --> 00:01:28,890
here a fragment of a make file which

00:01:26,369 --> 00:01:30,509
dots with dots to fix this line which is

00:01:28,890 --> 00:01:32,970
supposed to tell you what you're going

00:01:30,509 --> 00:01:36,479
to do when you meet dot C file for

00:01:32,970 --> 00:01:38,520
instance and when you get a rule which

00:01:36,479 --> 00:01:40,880
is actually a suffix fault since you got

00:01:38,520 --> 00:01:43,409
the suffixes already define here and

00:01:40,880 --> 00:01:45,659
when you say that you want to generate

00:01:43,409 --> 00:01:47,220
an object five from a C file and of

00:01:45,659 --> 00:01:50,549
course it works because you have those

00:01:47,220 --> 00:01:54,119
fixes then you decide that you don't

00:01:50,549 --> 00:01:57,479
want any more suffixes so after this

00:01:54,119 --> 00:01:59,729
line precisely the b dot o-- is not

00:01:57,479 --> 00:02:02,729
going to do anything because it does not

00:01:59,729 --> 00:02:05,100
know what dot c to dot or translation

00:02:02,729 --> 00:02:09,470
and then what's really funny about make

00:02:05,100 --> 00:02:13,110
is that if you put for china again

00:02:09,470 --> 00:02:14,069
what's going to happen on the c dot o

00:02:13,110 --> 00:02:16,049
file is it going

00:02:14,069 --> 00:02:19,620
to be generated from the C file or is it

00:02:16,049 --> 00:02:23,879
not trick question

00:02:19,620 --> 00:02:27,750
does anybody know ha it's actually going

00:02:23,879 --> 00:02:29,969
to work surprisingly enough you can

00:02:27,750 --> 00:02:32,459
define some suffixes roll with some

00:02:29,969 --> 00:02:35,250
suffixes existing then you can wipe the

00:02:32,459 --> 00:02:37,650
suffixes but it only says that okay for

00:02:35,250 --> 00:02:40,439
now over suffixes don't work but if

00:02:37,650 --> 00:02:43,439
literally instead Versa fixes when it

00:02:40,439 --> 00:02:45,060
works again and it has to be that way if

00:02:43,439 --> 00:02:45,299
you change that you are going to break

00:02:45,060 --> 00:02:48,090
it

00:02:45,299 --> 00:02:48,989
lots of macphails everything is like

00:02:48,090 --> 00:02:53,849
that basically

00:02:48,989 --> 00:02:55,169
so it's complete minefield I just to say

00:02:53,849 --> 00:02:57,840
that you don't have to work in the

00:02:55,169 --> 00:03:03,000
kernel to break things we can also very

00:02:57,840 --> 00:03:06,389
well break things in userland so like I

00:03:03,000 --> 00:03:07,829
said I began with ten years ago right

00:03:06,389 --> 00:03:10,230
now I should say that some things are

00:03:07,829 --> 00:03:13,650
obvious but may well not so when I

00:03:10,230 --> 00:03:16,290
started so I'm going to start with a

00:03:13,650 --> 00:03:19,590
jumble of pcs or stuff that doesn't make

00:03:16,290 --> 00:03:26,790
any sense and hopefully by the end you

00:03:19,590 --> 00:03:29,549
will be as confused as I am to start

00:03:26,790 --> 00:03:31,919
with while I go tricked by this guy

00:03:29,549 --> 00:03:34,799
named Pew into playing with Mac it's

00:03:31,919 --> 00:03:38,489
obviously not my code it's crappy code

00:03:34,799 --> 00:03:40,229
actually it's not even UNIX code make we

00:03:38,489 --> 00:03:44,190
have in open BSD which is basically

00:03:40,229 --> 00:03:46,260
what's also in a BSD is coming from some

00:03:44,190 --> 00:03:47,790
experimental operating system called

00:03:46,260 --> 00:03:50,280
sprites which was supposed to be

00:03:47,790 --> 00:03:52,319
distributed and you have lots of

00:03:50,280 --> 00:03:55,319
tendrils about that everywhere it's

00:03:52,319 --> 00:03:56,819
mostly a student project Wow very good

00:03:55,319 --> 00:03:59,189
student project but still it's

00:03:56,819 --> 00:04:03,030
definitely not prediction code at the

00:03:59,189 --> 00:04:05,909
start when I started with what you know

00:04:03,030 --> 00:04:08,669
also is that these days if you want to

00:04:05,909 --> 00:04:11,669
build anything on system you have to

00:04:08,669 --> 00:04:14,250
have some kind of make like Beth says

00:04:11,669 --> 00:04:16,049
this morning s conscious crap and most

00:04:14,250 --> 00:04:17,940
everything else is not very good

00:04:16,049 --> 00:04:22,409
compared to make so you have to work

00:04:17,940 --> 00:04:25,190
with it it's supposed to be more less

00:04:22,409 --> 00:04:27,600
turned up but it's not very stern up

00:04:25,190 --> 00:04:29,520
yeah I put this line in yes

00:04:27,600 --> 00:04:31,940
today's mission critical you have to

00:04:29,520 --> 00:04:34,830
ever make that works a bit as well as

00:04:31,940 --> 00:04:38,010
your she'll choose the right one

00:04:34,830 --> 00:04:44,190
please many shall goal was just to make

00:04:38,010 --> 00:04:45,870
things faster if you have to look at the

00:04:44,190 --> 00:04:49,590
specification you're going to go crazy

00:04:45,870 --> 00:04:53,220
it's a little less crazy money to us 10

00:04:49,590 --> 00:04:55,140
years ago but still it's bad and worse

00:04:53,220 --> 00:04:57,210
on things we try a bit more specified

00:04:55,140 --> 00:04:58,110
but more often than not you will see

00:04:57,210 --> 00:05:00,720
that new features

00:04:58,110 --> 00:05:03,630
I just stuff that comes from jimick as

00:05:00,720 --> 00:05:05,760
usual but basically you take anything

00:05:03,630 --> 00:05:08,790
but Sun Linux with this and they have a

00:05:05,760 --> 00:05:10,770
huge influence of a POSIX so you won't

00:05:08,790 --> 00:05:13,470
find in any of our influence and we have

00:05:10,770 --> 00:05:15,450
to find us obviously we have to get

00:05:13,470 --> 00:05:18,270
people on from all the BSD projects

00:05:15,450 --> 00:05:20,400
inside POSIX somehow and say hey we

00:05:18,270 --> 00:05:26,310
exist don't just copy line X that's

00:05:20,400 --> 00:05:27,990
completely stupid and at the time 10

00:05:26,310 --> 00:05:30,420
years ago parallel was something which

00:05:27,990 --> 00:05:31,770
was ok it could be a nice feature but

00:05:30,420 --> 00:05:33,840
it's not supposed to be working

00:05:31,770 --> 00:05:37,380
of course but that time we did not have

00:05:33,840 --> 00:05:42,120
that many simple systems and especially

00:05:37,380 --> 00:05:44,100
not on open BSD I did not have a plan I

00:05:42,120 --> 00:05:45,540
started looking at some changes my

00:05:44,100 --> 00:05:49,530
initial goal was just to make things

00:05:45,540 --> 00:05:51,960
faster to put things into perspective at

00:05:49,530 --> 00:05:54,870
the time I started the Amiga port system

00:05:51,960 --> 00:05:58,200
just took 7 seconds to start doing

00:05:54,870 --> 00:06:02,100
anything you want to any port in vpotus

00:05:58,200 --> 00:06:03,870
tree and you typed make and you waited

00:06:02,100 --> 00:06:08,010
for 7 seconds and then something

00:06:03,870 --> 00:06:17,400
happened it's late question but it went

00:06:08,010 --> 00:06:19,620
on to one second actually actually i'm

00:06:17,400 --> 00:06:21,990
cheeky cheating there because work i

00:06:19,620 --> 00:06:23,820
didn't make is about half way

00:06:21,990 --> 00:06:26,460
responsible for making things for a

00:06:23,820 --> 00:06:30,710
server rest was changing the past week

00:06:26,460 --> 00:06:30,710
so 32 insane Mallis

00:06:32,280 --> 00:06:40,590
so let's look at V until now at first

00:06:38,100 --> 00:06:42,810
sight you will think that make is mostly

00:06:40,590 --> 00:06:43,740
working with character strings but

00:06:42,810 --> 00:06:47,100
actually it's not

00:06:43,740 --> 00:06:49,500
not quite most specifically it's not

00:06:47,100 --> 00:06:51,510
very right data structure because you've

00:06:49,500 --> 00:06:54,510
got lots of concerts in Simek which

00:06:51,510 --> 00:06:56,160
looks like this and you have to pass

00:06:54,510 --> 00:06:59,190
them you have to read them and you have

00:06:56,160 --> 00:07:02,280
to expand checks on them so if you have

00:06:59,190 --> 00:07:04,140
usual C strings you're going to spend

00:07:02,280 --> 00:07:06,600
all your time copying stuff around or

00:07:04,140 --> 00:07:09,480
doing what make was doing which was even

00:07:06,600 --> 00:07:12,000
more stupid which was to say okay here I

00:07:09,480 --> 00:07:14,910
have start of this variable I'm going to

00:07:12,000 --> 00:07:19,200
look until VN I'm going to change this

00:07:14,910 --> 00:07:21,660
guy tell this brace into a zero so that

00:07:19,200 --> 00:07:23,280
this looks like a character string then

00:07:21,660 --> 00:07:25,920
I'm going to do something with this

00:07:23,280 --> 00:07:30,360
variable value then I'm going to put the

00:07:25,920 --> 00:07:32,850
brace back completely crazy especially

00:07:30,360 --> 00:07:34,640
if you want to debug things because you

00:07:32,850 --> 00:07:37,950
can't even make a distinction between

00:07:34,640 --> 00:07:39,600
strings which are read-only and stuff

00:07:37,950 --> 00:07:44,070
that is modified all over the place

00:07:39,600 --> 00:07:46,410
which is completely crazy so the thing

00:07:44,070 --> 00:07:49,680
that started with with was to change

00:07:46,410 --> 00:07:51,720
that to actually handle a string as

00:07:49,680 --> 00:07:54,210
intervals because most of the time

00:07:51,720 --> 00:07:56,370
you're going to have a buffer in make

00:07:54,210 --> 00:07:58,410
and you're going to want to play with

00:07:56,370 --> 00:08:00,900
that buffer between this position and

00:07:58,410 --> 00:08:02,640
that position and this is really the

00:08:00,900 --> 00:08:06,540
natural structure to deal with character

00:08:02,640 --> 00:08:07,860
strings inside make there's also a shin

00:08:06,540 --> 00:08:11,820
table which is something that I

00:08:07,860 --> 00:08:16,280
introduced earlier on and looking at the

00:08:11,820 --> 00:08:16,280
way make did not manage memory actually

00:08:18,590 --> 00:08:24,750
so how that was record for instance one

00:08:22,530 --> 00:08:26,850
of the first programs I try to solve was

00:08:24,750 --> 00:08:29,970
to look at how make was building new

00:08:26,850 --> 00:08:32,580
strings choosing a simple drawable

00:08:29,970 --> 00:08:34,349
buffer where you had Street where you

00:08:32,580 --> 00:08:36,570
add characters and why you finished you

00:08:34,349 --> 00:08:39,330
put a 0 at the end and you do a copy of

00:08:36,570 --> 00:08:40,800
part of the format you want and there

00:08:39,330 --> 00:08:43,830
were actually two zeros at the end of

00:08:40,800 --> 00:08:44,820
the strings so I said ok let's remove

00:08:43,830 --> 00:08:48,180
one

00:08:44,820 --> 00:08:50,190
than Goddard obviously so you look

00:08:48,180 --> 00:08:52,650
through a Kurd you find one bug fix it

00:08:50,190 --> 00:08:55,920
and you reckon Pilon

00:08:52,650 --> 00:08:58,620
call dump again for at least two bags

00:08:55,920 --> 00:09:00,480
and hurt in that and most of the code

00:08:58,620 --> 00:09:02,280
was like that you would look at

00:09:00,480 --> 00:09:05,760
something find something insane inside

00:09:02,280 --> 00:09:08,520
the mix code fix it and we realize that

00:09:05,760 --> 00:09:12,780
something else was relying on that

00:09:08,520 --> 00:09:16,110
specific behavior if you seen deduce

00:09:12,780 --> 00:09:18,390
work on OpenSSL for instance it will

00:09:16,110 --> 00:09:21,210
remind you or something because it's

00:09:18,390 --> 00:09:26,550
exactly the same issue exactly the same

00:09:21,210 --> 00:09:32,120
kind of crappy code to talk about

00:09:26,550 --> 00:09:36,030
something Morphin actually introduced

00:09:32,120 --> 00:09:39,720
some hashing techniques inside of make

00:09:36,030 --> 00:09:42,870
to make it faster right afterwards

00:09:39,720 --> 00:09:44,520
you've got to realize how bad of a

00:09:42,870 --> 00:09:48,960
research project this was at first

00:09:44,520 --> 00:09:51,750
because where was exactly no structure

00:09:48,960 --> 00:09:54,630
to look for viable names or photogate

00:09:51,750 --> 00:09:57,690
names inside mix ten years ago it was

00:09:54,630 --> 00:10:00,150
only a set of lists so you take this

00:09:57,690 --> 00:10:02,430
normal make file like stuff regenerated

00:10:00,150 --> 00:10:06,270
by I make for instance which has about

00:10:02,430 --> 00:10:08,640
500 variables 500 targets and each time

00:10:06,270 --> 00:10:10,890
you want to get any value of any

00:10:08,640 --> 00:10:16,850
variable you have to work from that list

00:10:10,890 --> 00:10:16,850
to find it it's going to be slow right I

00:10:18,170 --> 00:10:25,740
designed punishing to be useful all

00:10:22,170 --> 00:10:28,950
fruit mech and looking at things that

00:10:25,740 --> 00:10:32,010
managed to find seven places inside of

00:10:28,950 --> 00:10:35,420
mech which needed some actual data

00:10:32,010 --> 00:10:37,620
structure to look up names at least I

00:10:35,420 --> 00:10:39,690
even introduced a new one

00:10:37,620 --> 00:10:45,810
number eight maybe we'll talk about that

00:10:39,690 --> 00:10:48,180
if we have a time and it's one to be

00:10:45,810 --> 00:10:51,390
widely successful at least in open BSD

00:10:48,180 --> 00:10:58,230
since it's also using m40 sort man dog

00:10:51,390 --> 00:11:00,330
and signify as you know how does it look

00:10:58,230 --> 00:11:02,040
well it was designed specifically for

00:11:00,330 --> 00:11:06,360
MEC to be fast

00:11:02,040 --> 00:11:08,250
so there's mostly no internal memory

00:11:06,360 --> 00:11:11,790
allocation if you want to allocate stuff

00:11:08,250 --> 00:11:14,250
you have to design it directly into your

00:11:11,790 --> 00:11:15,870
data structure so for instance you're

00:11:14,250 --> 00:11:18,000
not going to say I want a new vegetable

00:11:15,870 --> 00:11:19,670
you say you have your lettuce to train

00:11:18,000 --> 00:11:24,380
memory and you're going to initialize it

00:11:19,670 --> 00:11:26,430
directly you give you an int of how many

00:11:24,380 --> 00:11:30,180
variables you're going to store in it

00:11:26,430 --> 00:11:33,840
like pour off to usually and the fat

00:11:30,180 --> 00:11:35,700
parameter to wash in it is just to tell

00:11:33,840 --> 00:11:38,760
it how to allocate memory when it

00:11:35,700 --> 00:11:40,770
actually needs to and when you do

00:11:38,760 --> 00:11:44,250
everything by hand so for instance for

00:11:40,770 --> 00:11:47,160
hashing data structure you're actually

00:11:44,250 --> 00:11:49,680
going to do version parts yourself so

00:11:47,160 --> 00:11:53,370
you can specialize it plug it with

00:11:49,680 --> 00:11:55,320
something else then you're going to look

00:11:53,370 --> 00:11:58,890
into your data structure to find things

00:11:55,320 --> 00:12:02,250
that slot where whatever you want to do

00:11:58,890 --> 00:12:04,590
is going to end and once you have that

00:12:02,250 --> 00:12:06,360
slot you can say that okay write

00:12:04,590 --> 00:12:09,240
something with a already so I found it

00:12:06,360 --> 00:12:10,530
oh it's not the right one I have to

00:12:09,240 --> 00:12:13,410
replace it with something else

00:12:10,530 --> 00:12:15,300
but if you didn't find something and you

00:12:13,410 --> 00:12:17,070
want to insert a new data structure you

00:12:15,300 --> 00:12:19,740
don't have to look again you already did

00:12:17,070 --> 00:12:23,400
so that games a lot actually that's

00:12:19,740 --> 00:12:25,530
actually a lot faster to specify looking

00:12:23,400 --> 00:12:28,860
up for our given slot and when deciding

00:12:25,530 --> 00:12:30,930
whether you want to insert well you want

00:12:28,860 --> 00:12:36,030
to find your data structure in such a

00:12:30,930 --> 00:12:37,680
new one or remove an on one also this

00:12:36,030 --> 00:12:40,140
this point which is specific to make

00:12:37,680 --> 00:12:43,980
which actually if you look at how make

00:12:40,140 --> 00:12:46,800
files become loaded with actual

00:12:43,980 --> 00:12:50,670
variables you've got was magic variables

00:12:46,800 --> 00:12:54,230
like dirt are gaps for instance or you

00:12:50,670 --> 00:12:59,990
have special rules like funny like

00:12:54,230 --> 00:13:02,850
physics that's a joke actually and

00:12:59,990 --> 00:13:05,460
having fresh value available here means

00:13:02,850 --> 00:13:11,580
that you can actually build it directly

00:13:05,460 --> 00:13:14,790
inside your passer you can take your

00:13:11,580 --> 00:13:17,670
get name a and you put it inside

00:13:14,790 --> 00:13:19,470
the sea switch so that you can figure

00:13:17,670 --> 00:13:21,360
out okay this is already available I

00:13:19,470 --> 00:13:30,390
know I don't need to create a special

00:13:21,360 --> 00:13:34,380
entry for it next point that did work on

00:13:30,390 --> 00:13:37,440
was Memorial location at that point you

00:13:34,380 --> 00:13:40,940
had lists and yeah while it was list

00:13:37,440 --> 00:13:44,490
basically we try and see but still disp

00:13:40,940 --> 00:13:47,040
every every single data structure inside

00:13:44,490 --> 00:13:49,790
of make was allocating at least two

00:13:47,040 --> 00:13:53,399
pieces of memory you have putting things

00:13:49,790 --> 00:13:55,709
for instance versus G node it's actually

00:13:53,399 --> 00:13:59,399
a internal representation of a target

00:13:55,709 --> 00:14:03,089
inside of mech and we were allocating a

00:13:59,399 --> 00:14:05,160
new one each time duplicating the name

00:14:03,089 --> 00:14:09,029
of the target it was installed inside

00:14:05,160 --> 00:14:11,910
the same data structure and every target

00:14:09,029 --> 00:14:14,100
had maybe 10 list and each of those

00:14:11,910 --> 00:14:21,000
lists which just a pointer to an

00:14:14,100 --> 00:14:23,339
external data structure right so I spent

00:14:21,000 --> 00:14:25,200
some time working on this I remembered

00:14:23,339 --> 00:14:29,430
that I also know some of our programming

00:14:25,200 --> 00:14:32,399
languages like C++ well they have this

00:14:29,430 --> 00:14:34,740
nice notion that allocating memory and

00:14:32,399 --> 00:14:36,240
analyzing your data structure are some

00:14:34,740 --> 00:14:37,829
completely different beasts and you

00:14:36,240 --> 00:14:41,910
don't have to do both at the same time

00:14:37,829 --> 00:14:44,700
and by applying this which was really

00:14:41,910 --> 00:14:48,029
boring work but necessary which was

00:14:44,700 --> 00:14:52,529
basically changing all of mix source

00:14:48,029 --> 00:14:56,820
code to just replace construct roads

00:14:52,529 --> 00:14:58,920
with initialization functions I managed

00:14:56,820 --> 00:15:00,600
to change previous code into something

00:14:58,920 --> 00:15:04,770
that looked like this so you have

00:15:00,600 --> 00:15:11,120
exactly 1 allocation 1 memorial occasion

00:15:04,770 --> 00:15:14,490
prayer target instead of 12 also and

00:15:11,120 --> 00:15:16,680
looking at the end result fuji poor for

00:15:14,490 --> 00:15:18,959
instance showed me that I managed to

00:15:16,680 --> 00:15:22,610
divide the number of memory allocation

00:15:18,959 --> 00:15:24,990
by more than 10 which was obviously

00:15:22,610 --> 00:15:34,140
something which made things

00:15:24,990 --> 00:15:35,880
much faster as you can guess so we

00:15:34,140 --> 00:15:40,080
probably something like six or seven

00:15:35,880 --> 00:15:42,510
years ago and while I had just tickled a

00:15:40,080 --> 00:15:46,880
monster and it didn't bite you out so I

00:15:42,510 --> 00:15:50,640
decided to dive in a little further and

00:15:46,880 --> 00:15:52,980
at which point I hadn't actually much of

00:15:50,640 --> 00:15:55,470
make which is more less for reality

00:15:52,980 --> 00:15:57,330
which is that you have lots of small

00:15:55,470 --> 00:16:00,870
modules which are supposed to do one

00:15:57,330 --> 00:16:04,170
thing and do one thing well but some

00:16:00,870 --> 00:16:06,210
people I've looked at those modules and

00:16:04,170 --> 00:16:08,280
decided that we wanted to add some

00:16:06,210 --> 00:16:10,080
features that means that some module is

00:16:08,280 --> 00:16:13,080
talking directly to something else and

00:16:10,080 --> 00:16:15,450
bypassing some mechanism to do something

00:16:13,080 --> 00:16:19,260
tricky which probably made sense at the

00:16:15,450 --> 00:16:23,490
time but in the end everything is

00:16:19,260 --> 00:16:25,710
untangled and nothing works and I don't

00:16:23,490 --> 00:16:28,800
want to frighten you too much but but

00:16:25,710 --> 00:16:30,480
still the case today rust if some areas

00:16:28,800 --> 00:16:36,180
where we haven't fixed everything and

00:16:30,480 --> 00:16:39,270
I'm 100% certain that fee over projects

00:16:36,180 --> 00:16:41,790
so net BSD and FreeBSD visitors are both

00:16:39,270 --> 00:16:48,300
using mimic which is a descendant of the

00:16:41,790 --> 00:16:50,310
same project have some issues so how to

00:16:48,300 --> 00:16:53,640
proceed well you have to affect all that

00:16:50,310 --> 00:16:55,740
as usual going for one module trying to

00:16:53,640 --> 00:16:57,780
understand it trying not to disturb

00:16:55,740 --> 00:17:01,080
whatever's going on in view of our

00:16:57,780 --> 00:17:07,110
models until you can manage to grasp

00:17:01,080 --> 00:17:11,310
intricacies and progress beyond that to

00:17:07,110 --> 00:17:13,770
give you some actual needs is a very

00:17:11,310 --> 00:17:16,440
simplified version of what's in sight

00:17:13,770 --> 00:17:18,630
make you have variables that's probably

00:17:16,440 --> 00:17:21,540
the sanest module it's very complicated

00:17:18,630 --> 00:17:23,520
but it's mostly self content so it means

00:17:21,540 --> 00:17:25,140
that if you are going to touch veamos

00:17:23,520 --> 00:17:29,610
you're not going to break anything else

00:17:25,140 --> 00:17:34,590
hopefully targets so yeah basically

00:17:29,610 --> 00:17:36,660
that's your initial list of targets per

00:17:34,590 --> 00:17:38,430
some issues in verb because it has to

00:17:36,660 --> 00:17:43,350
support some mechanism which

00:17:38,430 --> 00:17:45,450
only used by I make like double double :

00:17:43,350 --> 00:17:47,010
rules which is complete something

00:17:45,450 --> 00:17:52,740
completely insane but that you have to

00:17:47,010 --> 00:17:55,770
support the parser which was bit insane

00:17:52,740 --> 00:17:57,930
because it was calling each module in

00:17:55,770 --> 00:18:00,240
turn to try to decide what to do with

00:17:57,930 --> 00:18:04,590
whatever line and manage more or less to

00:18:00,240 --> 00:18:06,240
tame it and make it a bit faster cond

00:18:04,590 --> 00:18:09,150
which was missed name because it

00:18:06,240 --> 00:18:11,250
actually deals with every dot PSD

00:18:09,150 --> 00:18:14,880
comment so that include conditionals but

00:18:11,250 --> 00:18:17,040
that also include includes and followed

00:18:14,880 --> 00:18:18,780
so I have to break it up and try to make

00:18:17,040 --> 00:18:22,200
it Center it's not quite finished yet

00:18:18,780 --> 00:18:27,270
but not really important things that

00:18:22,200 --> 00:18:32,190
should work do work with this self she

00:18:27,270 --> 00:18:35,640
fixes on link that one is definitely not

00:18:32,190 --> 00:18:37,920
finished yet because there are lots of

00:18:35,640 --> 00:18:40,260
callbacks all over the place from viola

00:18:37,920 --> 00:18:42,410
module like the job engine that tries to

00:18:40,260 --> 00:18:45,270
decide when you try to build something

00:18:42,410 --> 00:18:48,450
whether you can apply some suffix full

00:18:45,270 --> 00:18:49,920
or not and since you are both look in

00:18:48,450 --> 00:18:52,260
several different places of all

00:18:49,920 --> 00:18:54,750
different directories especially on this

00:18:52,260 --> 00:18:57,090
DMX since you have this object do

00:18:54,750 --> 00:18:58,740
constrict but also never makes since you

00:18:57,090 --> 00:19:01,740
have some kind of the path mechanism

00:18:58,740 --> 00:19:04,050
you're never quite sure what's going to

00:19:01,740 --> 00:19:05,850
happen until you actually reach the

00:19:04,050 --> 00:19:07,680
point where you actually want to build

00:19:05,850 --> 00:19:09,150
your target maybe you will discovered

00:19:07,680 --> 00:19:11,270
you have some new dependencies that you

00:19:09,150 --> 00:19:16,370
did not know existed

00:19:11,270 --> 00:19:21,300
can be funny compact v readable all

00:19:16,370 --> 00:19:23,880
second challenging job the new pollen

00:19:21,300 --> 00:19:26,580
engine which wasn't working ten years

00:19:23,880 --> 00:19:29,040
ago and which is still a bit clunky and

00:19:26,580 --> 00:19:32,010
Festivus program that we actually have

00:19:29,040 --> 00:19:34,730
two engines which is not a good idea at

00:19:32,010 --> 00:19:39,000
some point we want to merge those

00:19:34,730 --> 00:19:43,320
directory caching yet another place to

00:19:39,000 --> 00:19:45,440
put opening and trivial stuff like

00:19:43,320 --> 00:19:48,510
string construction in before and

00:19:45,440 --> 00:19:50,520
non-trivial stuff but that's so mostly

00:19:48,510 --> 00:19:51,740
unused but it can break and nobody will

00:19:50,520 --> 00:19:53,590
notice

00:19:51,740 --> 00:19:57,010
the stuff that's supposed to handle

00:19:53,590 --> 00:20:00,260
achieve achieves directly inside making

00:19:57,010 --> 00:20:04,130
more or less works but nobody uses it

00:20:00,260 --> 00:20:11,539
anyway what you have to have it if you

00:20:04,130 --> 00:20:14,840
want to be POSIX so this is what I said

00:20:11,539 --> 00:20:18,220
basically there are some baby dragons in

00:20:14,840 --> 00:20:21,289
very small parts that I started with and

00:20:18,220 --> 00:20:25,279
once we decided you weren't too badly

00:20:21,289 --> 00:20:31,130
you can go into fight bigger dragons and

00:20:25,279 --> 00:20:33,049
get changed obviously let's talk a

00:20:31,130 --> 00:20:36,049
little bit more about variables because

00:20:33,049 --> 00:20:38,510
yeah this is a baby dragon but it's

00:20:36,049 --> 00:20:40,490
already complicated enough because if

00:20:38,510 --> 00:20:43,429
you look at the rule for mech you

00:20:40,490 --> 00:20:46,250
actually have four different kinds of

00:20:43,429 --> 00:20:47,450
variables at least because what you put

00:20:46,250 --> 00:20:50,000
in the makefile

00:20:47,450 --> 00:20:52,970
will be overridden by stuff that you

00:20:50,000 --> 00:20:54,890
pass on will come online but you also

00:20:52,970 --> 00:20:58,070
have a switch in mech which means that

00:20:54,890 --> 00:21:01,399
stuff on VI vironment will override both

00:20:58,070 --> 00:21:03,590
of them and when you have dynamic

00:21:01,399 --> 00:21:05,809
variables stuff that is only defined

00:21:03,590 --> 00:21:08,870
within the context of one rule like

00:21:05,809 --> 00:21:11,120
DeLaughter yet for instance and which

00:21:08,870 --> 00:21:13,490
can be tricky to do because suffixes

00:21:11,120 --> 00:21:16,309
might happen much later and you would

00:21:13,490 --> 00:21:18,620
like and some cases you have to

00:21:16,309 --> 00:21:22,029
reevaluate your lines to be sure you get

00:21:18,620 --> 00:21:22,029
the right values for variables

00:21:24,580 --> 00:21:29,270
obviously this initially meant that

00:21:27,020 --> 00:21:32,360
things were very slow because you had to

00:21:29,270 --> 00:21:34,760
look at variables it at least worse for

00:21:32,360 --> 00:21:38,899
places to be sure you had the right

00:21:34,760 --> 00:21:41,570
value so I managed to make it down to at

00:21:38,899 --> 00:21:44,230
least at most two lookups that's one

00:21:41,570 --> 00:21:46,820
global list and one list per target and

00:21:44,230 --> 00:21:48,470
usually when you find things in the

00:21:46,820 --> 00:21:51,169
global list that should be in Volokh at

00:21:48,470 --> 00:21:53,270
least you're very hip and happy about it

00:21:51,169 --> 00:21:56,049
and that's a bug like for instance if

00:21:53,270 --> 00:21:59,090
you find a definition of your target of

00:21:56,049 --> 00:22:02,440
target variable information it's not a

00:21:59,090 --> 00:22:02,440
good idea should be automatic

00:22:02,840 --> 00:22:11,990
Plus laziness which is again a good and

00:22:09,800 --> 00:22:13,820
a bad idea because you have the laziness

00:22:11,990 --> 00:22:15,860
explained in the POSIX rules and then

00:22:13,820 --> 00:22:18,230
you have a BSD extensions which means

00:22:15,860 --> 00:22:20,930
that some stuff are expended early and

00:22:18,230 --> 00:22:23,960
some stuff is expended light and can be

00:22:20,930 --> 00:22:25,490
completely crazy but it's not very

00:22:23,960 --> 00:22:27,770
program inside make it's more of a

00:22:25,490 --> 00:22:30,950
program when you want to use it if you

00:22:27,770 --> 00:22:33,860
have to maintain any part of BSD make

00:22:30,950 --> 00:22:36,160
file just run away just don't do it it's

00:22:33,860 --> 00:22:36,160
crazy

00:22:39,020 --> 00:22:46,730
like I said viable expansion is

00:22:42,740 --> 00:22:48,470
complicated I found a bug a few months

00:22:46,730 --> 00:22:52,490
ago which is related to dynamic

00:22:48,470 --> 00:22:54,860
variables version features that we

00:22:52,490 --> 00:22:58,520
didn't have that I managed to add thanks

00:22:54,860 --> 00:23:01,130
to may work on variables recursive

00:22:58,520 --> 00:23:03,710
variables which means basically viable

00:23:01,130 --> 00:23:05,660
which contains another variable as part

00:23:03,710 --> 00:23:07,580
of its name so that you can specialize

00:23:05,660 --> 00:23:10,340
stuff for instance for a given

00:23:07,580 --> 00:23:13,030
architecture she flags depending on a

00:23:10,340 --> 00:23:17,360
given file it's very easy to do as well

00:23:13,030 --> 00:23:20,090
thanks to that there's something that we

00:23:17,360 --> 00:23:23,480
had to do to implement fake in

00:23:20,090 --> 00:23:25,820
repository which is basically to bash

00:23:23,480 --> 00:23:29,180
everything that was passed on the

00:23:25,820 --> 00:23:31,160
command line down through sub Max and

00:23:29,180 --> 00:23:34,250
venture Max and answer makes all the way

00:23:31,160 --> 00:23:35,210
down to totals so that for instance this

00:23:34,250 --> 00:23:38,090
deal would work

00:23:35,210 --> 00:23:40,250
I think but finally in an base they

00:23:38,090 --> 00:23:43,850
realized that we had to do this as well

00:23:40,250 --> 00:23:46,370
but it took them a long time and just to

00:23:43,850 --> 00:23:48,800
say something nice about them as well we

00:23:46,370 --> 00:23:51,250
borrowed some features like for extended

00:23:48,800 --> 00:23:54,740
follow ups which is an awesome idea

00:23:51,250 --> 00:23:56,810
because when you can do stuff like that

00:23:54,740 --> 00:23:59,450
say that you have a list which is

00:23:56,810 --> 00:24:01,780
actually composed of a pair of stuff

00:23:59,450 --> 00:24:05,300
like a link and a file and you can

00:24:01,780 --> 00:24:08,410
create a rule that will link every month

00:24:05,300 --> 00:24:12,470
page to its source just in one simple

00:24:08,410 --> 00:24:15,070
what if you used to make one simple line

00:24:12,470 --> 00:24:15,070
of make file

00:24:16,910 --> 00:24:25,559
where am I oh cool so like I said we

00:24:23,669 --> 00:24:30,750
have some physics stuff and when we have

00:24:25,559 --> 00:24:32,669
some not such basic stuff like taking

00:24:30,750 --> 00:24:37,799
value work as part of a viable for

00:24:32,669 --> 00:24:40,940
instance and for loops and conditionals

00:24:37,799 --> 00:24:40,940
and stuff like that

00:24:42,410 --> 00:24:51,570
this is something where we can first

00:24:47,820 --> 00:24:55,200
smallest by this I mean that by the time

00:24:51,570 --> 00:24:57,270
I started working on make we had more or

00:24:55,200 --> 00:24:59,820
less with some modifiers that need me as

00:24:57,270 --> 00:25:05,160
a net bsd FreeBSD didn't have anything

00:24:59,820 --> 00:25:07,790
more or less and we started adding new

00:25:05,160 --> 00:25:10,799
stuff like lower case for instance

00:25:07,790 --> 00:25:12,419
furious biforn and bsd decided to do

00:25:10,799 --> 00:25:14,520
their own stuff and obviously in

00:25:12,419 --> 00:25:15,059
completely incompatible ways to what we

00:25:14,520 --> 00:25:20,190
are doing

00:25:15,059 --> 00:25:22,740
so while them or if you want more

00:25:20,190 --> 00:25:24,929
reasonably you can take our source and

00:25:22,740 --> 00:25:26,730
look at the modifiers code which is very

00:25:24,929 --> 00:25:28,650
clean and if you don't like our

00:25:26,730 --> 00:25:31,440
modifiers and you want to have something

00:25:28,650 --> 00:25:33,840
else it's very easy to do we just don't

00:25:31,440 --> 00:25:36,000
see the need for us but it's very easy

00:25:33,840 --> 00:25:38,970
to pop that to any over obviously if you

00:25:36,000 --> 00:25:42,210
want to have a low or something like

00:25:38,970 --> 00:25:44,250
that set of viable modifiers and we took

00:25:42,210 --> 00:25:48,380
from whatever projects I don't remember

00:25:44,250 --> 00:25:48,380
the name you can do that it's very easy

00:25:50,330 --> 00:25:56,010
the interesting part is that at that

00:25:52,919 --> 00:25:57,809
point polemic wasn't working so by that

00:25:56,010 --> 00:25:59,970
point you're probably thinking why did

00:25:57,809 --> 00:26:01,890
that come to see this guy he said that

00:25:59,970 --> 00:26:05,750
he was going to talk about pile mech and

00:26:01,890 --> 00:26:05,750
yes and said anything about that so far

00:26:06,140 --> 00:26:11,970
there was the science student project

00:26:09,210 --> 00:26:16,160
part which is what guy you what face

00:26:11,970 --> 00:26:19,410
make thought that putting all commands

00:26:16,160 --> 00:26:21,750
under a target into one single shell

00:26:19,410 --> 00:26:23,940
what is a good idea which is obviously

00:26:21,750 --> 00:26:26,760
going to break almost every make fine in

00:26:23,940 --> 00:26:27,870
existence because we expect everything

00:26:26,760 --> 00:26:30,510
online no make file

00:26:27,870 --> 00:26:34,940
we run by a distinct chair won't work

00:26:30,510 --> 00:26:38,190
otherwise there was also the fact that

00:26:34,940 --> 00:26:40,890
this pallid stuff wasn't working so we

00:26:38,190 --> 00:26:43,020
put more debug stuff in it so if you try

00:26:40,890 --> 00:26:45,330
to run a mikvah in parallel at that

00:26:43,020 --> 00:26:49,080
point while it won't work because it

00:26:45,330 --> 00:26:52,350
will display shitload of stuff and since

00:26:49,080 --> 00:26:54,360
some commands expect to have some result

00:26:52,350 --> 00:26:56,070
produced by make and reuse it later

00:26:54,360 --> 00:26:59,940
while that won't work

00:26:56,070 --> 00:27:02,550
and there was a lot of code that wasn't

00:26:59,940 --> 00:27:04,860
used it was on VMs but it was bright and

00:27:02,550 --> 00:27:09,630
there was a lot of code but we're

00:27:04,860 --> 00:27:12,480
supposed to let you run jobs on other

00:27:09,630 --> 00:27:19,530
machines distantly using whatever

00:27:12,480 --> 00:27:22,050
interface what we not have at all so at

00:27:19,530 --> 00:27:25,650
that point I decided I wanted parallel

00:27:22,050 --> 00:27:29,250
make to work so the first thing I did

00:27:25,650 --> 00:27:31,860
was remove extra shell execution every

00:27:29,250 --> 00:27:33,630
command should every line in the target

00:27:31,860 --> 00:27:37,890
should have its own shell it won't work

00:27:33,630 --> 00:27:40,440
otherwise remove extra disappear leave

00:27:37,890 --> 00:27:43,620
it into a debug mode but not keep it for

00:27:40,440 --> 00:27:46,260
anything and get rid of all the noise

00:27:43,620 --> 00:27:49,770
because remote was just noise it was

00:27:46,260 --> 00:27:52,140
just stress that was making the code

00:27:49,770 --> 00:27:58,559
almost impossible to read and definitely

00:27:52,140 --> 00:28:02,840
impossible to change so this gave us

00:27:58,559 --> 00:28:02,840
first version of Parlin make that work

00:28:04,010 --> 00:28:12,660
basically where worst elements of one

00:28:08,880 --> 00:28:16,710
shelf a target part which is that job

00:28:12,660 --> 00:28:19,679
handler was Jam manager which

00:28:16,710 --> 00:28:21,510
would be running each line for supplied

00:28:19,679 --> 00:28:24,929
shell and then running the last line and

00:28:21,510 --> 00:28:31,050
then seing us ok everything went ok you

00:28:24,929 --> 00:28:33,540
have your target it's dumb this had one

00:28:31,050 --> 00:28:35,700
major program which is what we put comes

00:28:33,540 --> 00:28:37,800
out garbled because you are going to run

00:28:35,700 --> 00:28:40,290
several jobs in parallel and you're

00:28:37,800 --> 00:28:40,870
going to see every job manager saying I

00:28:40,290 --> 00:28:43,660
am going to

00:28:40,870 --> 00:28:46,690
executive s at the same time and you get

00:28:43,660 --> 00:28:52,059
fragments of lines or stuff horrible

00:28:46,690 --> 00:28:53,890
stuff all through it so I did something

00:28:52,059 --> 00:28:56,200
I shouldn't have

00:28:53,890 --> 00:28:58,480
I did some extra structure to try to

00:28:56,200 --> 00:29:00,550
gain control over the situation which is

00:28:58,480 --> 00:29:03,370
that basically at that points the men

00:29:00,550 --> 00:29:06,040
make process used to have a pipe to each

00:29:03,370 --> 00:29:09,520
job manager and to select whatever it

00:29:06,040 --> 00:29:12,309
wanted to display at that time so if you

00:29:09,520 --> 00:29:14,559
have some knowledge of concurrent

00:29:12,309 --> 00:29:17,770
programming it's basically a completely

00:29:14,559 --> 00:29:20,050
unfair scheduler because I want once I

00:29:17,770 --> 00:29:22,120
have somewhat put from a given job to

00:29:20,050 --> 00:29:24,780
give it a chance to be put as much as it

00:29:22,120 --> 00:29:27,429
can before I switch to the next job so

00:29:24,780 --> 00:29:31,690
yeah basically you just try to biggest

00:29:27,429 --> 00:29:34,420
key role into works and at this point

00:29:31,690 --> 00:29:37,900
heat worked for the canary we managed to

00:29:34,420 --> 00:29:43,990
build the first canal with make - before

00:29:37,900 --> 00:29:48,340
I think and noise I needed to add lots

00:29:43,990 --> 00:29:50,070
of dependencies and boom it worked from

00:29:48,340 --> 00:29:52,600
the sauce tree as well

00:29:50,070 --> 00:29:55,660
the main issue with a sauce tree was

00:29:52,600 --> 00:29:57,640
that parallel make was completely

00:29:55,660 --> 00:30:00,309
untested of course since he didn't use

00:29:57,640 --> 00:30:02,710
to work so people used to forget

00:30:00,309 --> 00:30:04,150
dependencies all over the place and if

00:30:02,710 --> 00:30:06,460
you try to build things in parallel

00:30:04,150 --> 00:30:08,860
instead of second shot obviously you're

00:30:06,460 --> 00:30:10,900
going to say oh wait I should have built

00:30:08,860 --> 00:30:13,510
this before that so I have to write it

00:30:10,900 --> 00:30:17,320
down so what it was this is as stupid as

00:30:13,510 --> 00:30:19,690
it goes this was busy part because then

00:30:17,320 --> 00:30:21,730
you have to look at the cases where it

00:30:19,690 --> 00:30:25,030
doesn't work and you have to realize

00:30:21,730 --> 00:30:28,890
that you're not even half wave there are

00:30:25,030 --> 00:30:28,890
still lots of issues to fix

00:30:34,060 --> 00:30:42,060
is a list of the three most important

00:30:38,230 --> 00:30:44,710
issues that we have by tweet hat right

00:30:42,060 --> 00:30:47,650
first one is that pipe means that you

00:30:44,710 --> 00:30:50,230
don't have any standard input so that's

00:30:47,650 --> 00:30:52,210
the difference between a complete make

00:30:50,230 --> 00:30:53,920
because in second shall make you can

00:30:52,210 --> 00:30:55,720
have one command which is going to ask

00:30:53,920 --> 00:30:57,880
for user do you want to continue or

00:30:55,720 --> 00:31:00,760
something like that it will block make

00:30:57,880 --> 00:31:03,160
for a while but it will work if you have

00:31:00,760 --> 00:31:07,960
your polygon layer which is actually

00:31:03,160 --> 00:31:10,480
redirecting STD out from each command

00:31:07,960 --> 00:31:13,060
and getting it in to make that means

00:31:10,480 --> 00:31:13,600
that those commands no longer get what

00:31:13,060 --> 00:31:15,850
we need

00:31:13,600 --> 00:31:19,870
in terms of user input so some stuff

00:31:15,850 --> 00:31:25,840
doesn't quite work Macias is that

00:31:19,870 --> 00:31:28,330
naturally inside of normal way to build

00:31:25,840 --> 00:31:30,760
unique stuff you have some rules that

00:31:28,330 --> 00:31:32,500
will create several files the simplest

00:31:30,760 --> 00:31:35,590
example I expect that you're familiar

00:31:32,500 --> 00:31:38,070
with it is using yak since usually you

00:31:35,590 --> 00:31:43,690
will create see source file and header

00:31:38,070 --> 00:31:46,840
each file so at that point we'd get some

00:31:43,690 --> 00:31:49,360
MacGyver and just did with something but

00:31:46,840 --> 00:31:53,500
the GCC guys did which is to put a

00:31:49,360 --> 00:31:55,720
timestamp to say eyes with a build of

00:31:53,500 --> 00:32:00,430
those files and hope but we did not

00:31:55,720 --> 00:32:02,650
forget any and the last program which is

00:32:00,430 --> 00:32:04,270
actually the most is one is that

00:32:02,650 --> 00:32:07,480
actually make doesn't understand the

00:32:04,270 --> 00:32:12,520
file system so if you have two targets

00:32:07,480 --> 00:32:14,860
say dot slash a and a for make ver

00:32:12,520 --> 00:32:18,400
different targets but on your file

00:32:14,860 --> 00:32:20,860
system usually if ever son fight if it

00:32:18,400 --> 00:32:23,910
doesn't scare you it should but we come

00:32:20,860 --> 00:32:23,910
back to that in a few minutes

00:32:26,700 --> 00:32:32,940
at which point I was probably confident

00:32:29,669 --> 00:32:36,090
enough to try to decide but I wanted to

00:32:32,940 --> 00:32:39,120
document things which was also a big

00:32:36,090 --> 00:32:41,400
part of taming the Beast because the

00:32:39,120 --> 00:32:44,450
documentation we had was horrible and

00:32:41,400 --> 00:32:47,309
not matching any standards at all so

00:32:44,450 --> 00:32:49,860
first you document how things work when

00:32:47,309 --> 00:32:52,020
you look at POSIX then you realize you

00:32:49,860 --> 00:32:53,640
don't even use the right vocabulary so

00:32:52,020 --> 00:32:55,740
that people coming from outside won't

00:32:53,640 --> 00:32:57,870
understand what you're talking about so

00:32:55,740 --> 00:33:02,700
you change every term until you more

00:32:57,870 --> 00:33:05,460
less match what POSIX says and there's

00:33:02,700 --> 00:33:07,620
also very big ongoing work which is that

00:33:05,460 --> 00:33:09,179
you have to decide which extensions whom

00:33:07,620 --> 00:33:12,590
you want to keep because we're actually

00:33:09,179 --> 00:33:16,080
useful and maintainable and working and

00:33:12,590 --> 00:33:19,320
not a program to pop to elsewhere and

00:33:16,080 --> 00:33:21,690
which but you want to get rid of because

00:33:19,320 --> 00:33:24,570
it's complete crap and this is actually

00:33:21,690 --> 00:33:26,669
very difficult I think that this is a

00:33:24,570 --> 00:33:28,799
point where MBE is actually losing

00:33:26,669 --> 00:33:31,470
because we are keeping waste too much

00:33:28,799 --> 00:33:40,110
stuff which is unmentionable in the long

00:33:31,470 --> 00:33:46,890
term guilty this is something that we

00:33:40,110 --> 00:33:49,080
don't do yet that we should do and we

00:33:46,890 --> 00:33:51,270
should have a word that enables us to

00:33:49,080 --> 00:33:53,010
say okay this part of make Eastern down

00:33:51,270 --> 00:33:56,640
and walling you are using some stuff

00:33:53,010 --> 00:33:59,340
that won't work elsewhere and this is

00:33:56,640 --> 00:34:02,130
the best story basically because even

00:33:59,340 --> 00:34:04,140
people who are writing bash scripts did

00:34:02,130 --> 00:34:06,720
have the flag to make sure they don't

00:34:04,140 --> 00:34:08,879
use bash extensions then they wouldn't

00:34:06,720 --> 00:34:10,409
be into such a mess where you have to

00:34:08,879 --> 00:34:12,869
have bash on your system because

00:34:10,409 --> 00:34:14,570
suddenly have the shell scripts won't

00:34:12,869 --> 00:34:17,970
work you have the same issues with make

00:34:14,570 --> 00:34:21,240
it's less of an issue some ish because

00:34:17,970 --> 00:34:30,450
it's only used by developers usually but

00:34:21,240 --> 00:34:32,099
it's still a nightmare while you isn't

00:34:30,450 --> 00:34:35,369
where because it's actually easy

00:34:32,099 --> 00:34:37,440
optimisation if you start looking at

00:34:35,369 --> 00:34:39,720
recursive make files you quite well know

00:34:37,440 --> 00:34:41,099
that if you going to use but I will make

00:34:39,720 --> 00:34:44,070
you're going to have some community at

00:34:41,099 --> 00:34:46,440
our expression because at the first

00:34:44,070 --> 00:34:50,070
level you've got four jobs when second

00:34:46,440 --> 00:34:51,990
level is 16 jobs and 64 jobs and you

00:34:50,070 --> 00:34:55,879
don't usually go much much further

00:34:51,990 --> 00:34:55,879
because your machine has exploded over

00:34:56,960 --> 00:35:02,700
systems like new make for instance use a

00:34:59,580 --> 00:35:06,839
kind of token system but it's actually a

00:35:02,700 --> 00:35:08,400
little widow for two reasons one you

00:35:06,839 --> 00:35:10,859
could decide to use a socket or

00:35:08,400 --> 00:35:12,720
something but we are going to put it you

00:35:10,859 --> 00:35:15,420
see you don't know actually when you're

00:35:12,720 --> 00:35:19,080
using neck which file system is writable

00:35:15,420 --> 00:35:20,849
which one is not and so if you have for

00:35:19,080 --> 00:35:22,800
instance some temporary file system or

00:35:20,849 --> 00:35:24,810
some network file system you can

00:35:22,800 --> 00:35:27,630
possibly not put a socket on it and have

00:35:24,810 --> 00:35:29,280
it working so you have to have for some

00:35:27,630 --> 00:35:31,140
very strong constraints if you actually

00:35:29,280 --> 00:35:33,780
want to use a circuit to communicate

00:35:31,140 --> 00:35:36,540
between processes you could decide to

00:35:33,780 --> 00:35:39,720
use file descriptor but that actually

00:35:36,540 --> 00:35:41,849
doesn't work why it works but people

00:35:39,720 --> 00:35:44,099
like market in East Winston said nah

00:35:41,849 --> 00:35:45,230
it's not turned out it shouldn't work it

00:35:44,099 --> 00:35:47,730
won't work

00:35:45,230 --> 00:35:49,470
because you're not passing your file

00:35:47,730 --> 00:35:51,150
descriptor directly from a make process

00:35:49,470 --> 00:35:53,520
to the next mix process but you have a

00:35:51,150 --> 00:35:55,950
shell in between and Vaishali is allowed

00:35:53,520 --> 00:35:58,050
to do whatever it wants with any further

00:35:55,950 --> 00:36:04,080
script or you pass it besides stand on

00:35:58,050 --> 00:36:07,170
input and output and scenario so vo

00:36:04,080 --> 00:36:08,730
stick was very simple it's just that you

00:36:07,170 --> 00:36:11,760
look deeper at whatever you will be

00:36:08,730 --> 00:36:14,609
going to execute and a if you noticed

00:36:11,760 --> 00:36:16,200
that you have something which is also

00:36:14,609 --> 00:36:18,690
invoking make or something that looks

00:36:16,200 --> 00:36:20,550
like make you decide a I'm a recursive

00:36:18,690 --> 00:36:22,859
make file so I'm going to block there

00:36:20,550 --> 00:36:25,740
which means that I'm going to start my

00:36:22,859 --> 00:36:27,480
for jobs as usual but once I'm running

00:36:25,740 --> 00:36:31,080
this one I'm not going to start anything

00:36:27,480 --> 00:36:34,460
else until will see is finished and

00:36:31,080 --> 00:36:37,020
that's good enough actually in practice

00:36:34,460 --> 00:36:38,250
if that sounds familiar to the people

00:36:37,020 --> 00:36:40,410
working in port

00:36:38,250 --> 00:36:42,600
and it's exactly the same optimization

00:36:40,410 --> 00:36:45,360
that you that we put as DP before our

00:36:42,600 --> 00:36:48,420
lab we're going to start stuff which is

00:36:45,360 --> 00:36:50,010
potentially expensive and we are going

00:36:48,420 --> 00:36:58,890
to block and starting anything else

00:36:50,010 --> 00:37:00,540
until we're sure that part is done sorry

00:36:58,890 --> 00:37:05,040
I'm going a bit fast because I want to

00:37:00,540 --> 00:37:06,480
go to the juicy but the pipe issue the

00:37:05,040 --> 00:37:07,170
solution came from something else

00:37:06,480 --> 00:37:09,030
entirely

00:37:07,170 --> 00:37:10,980
basically I just wanted to get better

00:37:09,030 --> 00:37:14,010
error messages with line number and

00:37:10,980 --> 00:37:17,520
stuff like that and if you have just a

00:37:14,010 --> 00:37:19,440
germ manager that runs on every line in

00:37:17,520 --> 00:37:22,800
target building you don't have good

00:37:19,440 --> 00:37:24,750
error messages because the job manager

00:37:22,800 --> 00:37:26,550
is just going to say Oh something

00:37:24,750 --> 00:37:31,080
up and you don't know where it went

00:37:26,550 --> 00:37:34,080
wrong so I replaced with German law with

00:37:31,080 --> 00:37:36,030
a virtual manager with a job automated

00:37:34,080 --> 00:37:37,980
instead of having one manager which is

00:37:36,030 --> 00:37:40,740
responsible for our lots of

00:37:37,980 --> 00:37:44,730
stuff I've make proper which is

00:37:40,740 --> 00:37:46,950
everything by hand and each manager just

00:37:44,730 --> 00:37:52,320
keeps track of where it's at at which

00:37:46,950 --> 00:37:53,820
line it is inside a given job the nice

00:37:52,320 --> 00:37:55,350
thing is that once you do that you

00:37:53,820 --> 00:37:58,200
realize you no longer need to have a

00:37:55,350 --> 00:38:00,780
pipe because you're no longer printing

00:37:58,200 --> 00:38:03,360
stuff from within virtual manager but

00:38:00,780 --> 00:38:05,190
from make itself so you have complete

00:38:03,360 --> 00:38:07,560
lines of course the comments you're

00:38:05,190 --> 00:38:11,070
going to are maybe going to display

00:38:07,560 --> 00:38:12,930
some stuff now it's not that often and

00:38:11,070 --> 00:38:17,450
it doesn't really matter it works just

00:38:12,930 --> 00:38:17,450
fine so no longer any program with pipes

00:38:20,150 --> 00:38:26,070
seen a non link become an issue if you

00:38:24,180 --> 00:38:28,760
don't know about this I'm just going to

00:38:26,070 --> 00:38:32,520
alert you that this stuff does not work

00:38:28,760 --> 00:38:34,820
you can't jobs and use wait and

00:38:32,520 --> 00:38:37,320
expect to get signals at the same time

00:38:34,820 --> 00:38:40,890
because wait won't be interrupted by

00:38:37,320 --> 00:38:42,570
signals so it's as simple as that if you

00:38:40,890 --> 00:38:44,100
have your mic which is building lots of

00:38:42,570 --> 00:38:47,370
stuff and you want to interrupt it and

00:38:44,100 --> 00:38:50,390
you do things that way then you may have

00:38:47,370 --> 00:38:50,390
to wait for a long time

00:38:51,079 --> 00:38:57,559
the idea is that you're going to do

00:38:54,599 --> 00:39:00,029
something funky with signals where

00:38:57,559 --> 00:39:02,400
basically you'll no longer wait for jobs

00:39:00,029 --> 00:39:04,859
but instead you're going to pause until

00:39:02,400 --> 00:39:07,619
you get the signal and in order to get

00:39:04,859 --> 00:39:10,069
jobs you just put empty under for sick

00:39:07,619 --> 00:39:13,170
child so that whenever one of your

00:39:10,069 --> 00:39:14,849
children dies then you get to a signal

00:39:13,170 --> 00:39:22,859
which showing no but at least you get

00:39:14,849 --> 00:39:24,779
that over Molly's sign notes well but

00:39:22,859 --> 00:39:28,609
isn't very so it doesn't really matter

00:39:24,779 --> 00:39:32,339
this one is probably the most important

00:39:28,609 --> 00:39:34,140
people did say that using one single

00:39:32,339 --> 00:39:37,470
shell was good because you were

00:39:34,140 --> 00:39:39,569
less processes instead of that we can do

00:39:37,470 --> 00:39:41,390
an optimization we don't necessarily

00:39:39,569 --> 00:39:43,410
have to run a shell for each comment

00:39:41,390 --> 00:39:46,049
especially if you not have any shell

00:39:43,410 --> 00:39:48,450
what comes in recommend and will ready

00:39:46,049 --> 00:39:51,569
scan vacuum and Fuu we already look to

00:39:48,450 --> 00:39:54,210
see if we see okay well like make so if

00:39:51,569 --> 00:39:57,869
we just have a simple command no shell

00:39:54,210 --> 00:39:59,460
so it's even faster and maybe I will do

00:39:57,869 --> 00:40:01,859
that but it wouldn't make sense to

00:39:59,460 --> 00:40:03,690
optimize with simple constructs which

00:40:01,859 --> 00:40:05,160
collapse all the time where you change

00:40:03,690 --> 00:40:08,579
to a given directory and when some

00:40:05,160 --> 00:40:12,259
comment could just Jackie do CSTR inside

00:40:08,579 --> 00:40:12,259
make and run recommend that would work

00:40:13,069 --> 00:40:19,680
as far as multiple targets I have to

00:40:15,900 --> 00:40:22,349
quit it David Anand I think if I

00:40:19,680 --> 00:40:24,269
remember correctly it told me that when

00:40:22,349 --> 00:40:26,819
you see something like that it used to

00:40:24,269 --> 00:40:28,859
be a shortcut to say that both targets

00:40:26,819 --> 00:40:31,829
have some dependencies and some comments

00:40:28,859 --> 00:40:34,470
but in recent POSIX declaration it

00:40:31,829 --> 00:40:42,239
actually means that you are you might be

00:40:34,470 --> 00:40:44,670
building a and B together in order to be

00:40:42,239 --> 00:40:46,650
sure you have to do some heuristics

00:40:44,670 --> 00:40:48,869
always the same one you are going to

00:40:46,650 --> 00:40:50,999
look if you referencing the target it

00:40:48,869 --> 00:40:52,710
recommends you're executing in which

00:40:50,999 --> 00:40:54,779
case you have some speed comments you

00:40:52,710 --> 00:40:57,059
actually we're using the same rule to

00:40:54,779 --> 00:40:59,880
build a and B separately but if you

00:40:57,059 --> 00:41:01,470
don't refer to the target it's very

00:40:59,880 --> 00:41:03,539
likely that you're building everything

00:41:01,470 --> 00:41:04,510
at the same time and so you just lock

00:41:03,539 --> 00:41:06,310
one target why

00:41:04,510 --> 00:41:09,660
you're building vivillon so that you

00:41:06,310 --> 00:41:09,660
don't try to be both at the same time

00:41:09,870 --> 00:41:13,780
notice that it's just very realistic and

00:41:12,850 --> 00:41:16,060
if you're wrong

00:41:13,780 --> 00:41:17,830
it's not really a problem because if you

00:41:16,060 --> 00:41:20,560
tie some targets which are actually

00:41:17,830 --> 00:41:22,810
generated separately they are not

00:41:20,560 --> 00:41:27,910
parallel and that's it that's the only

00:41:22,810 --> 00:41:30,160
issue you're going to run into okay I

00:41:27,910 --> 00:41:32,530
just have time to talk about that which

00:41:30,160 --> 00:41:38,130
is the only issue that we have left with

00:41:32,530 --> 00:41:40,390
this why is it an issue it's because

00:41:38,130 --> 00:41:42,190
when you're running second shalt make it

00:41:40,390 --> 00:41:46,060
doesn't really matter because you can

00:41:42,190 --> 00:41:49,120
rely on the file system basically you're

00:41:46,060 --> 00:41:51,100
going to take one wall evaluate it build

00:41:49,120 --> 00:41:54,040
the target which is called a for

00:41:51,100 --> 00:41:55,930
instance and then you look again at the

00:41:54,040 --> 00:41:59,350
file system and if you see a rule which

00:41:55,930 --> 00:42:01,060
refers to dot slash a okay you look at

00:41:59,350 --> 00:42:02,740
the file system you have the file and

00:42:01,060 --> 00:42:05,680
you have the right time stamps so you

00:42:02,740 --> 00:42:08,170
don't have to rebuild anything but if

00:42:05,680 --> 00:42:10,930
you're trying to do stuff in parallel we

00:42:08,170 --> 00:42:13,000
don't necessarily know that both targets

00:42:10,930 --> 00:42:15,490
refer to the same file and you might try

00:42:13,000 --> 00:42:19,450
to build them both at the same times and

00:42:15,490 --> 00:42:23,260
going to go completely crazy and even

00:42:19,450 --> 00:42:27,940
worse worse with VF and even worse with

00:42:23,260 --> 00:42:29,800
suffixes the first hint I got that there

00:42:27,940 --> 00:42:31,420
was a big issue with that is when I

00:42:29,800 --> 00:42:34,120
tried to build listen to two cops

00:42:31,420 --> 00:42:36,610
because they rely on vests if you build

00:42:34,120 --> 00:42:40,420
any reason to talk off with separate

00:42:36,610 --> 00:42:42,130
subject directory it will work with AMI

00:42:40,420 --> 00:42:44,740
completely and it's not to make

00:42:42,130 --> 00:42:46,720
fellowship it's bad problem it's

00:42:44,740 --> 00:42:49,480
definitely but it tries to build a file

00:42:46,720 --> 00:42:51,730
in a given directory and refers to it as

00:42:49,480 --> 00:42:53,410
if it were in the novel directory and it

00:42:51,730 --> 00:42:55,600
has to be the same file and it does not

00:42:53,410 --> 00:42:56,590
know anything about it it's very

00:42:55,600 --> 00:43:00,670
complicated

00:42:56,590 --> 00:43:03,010
I had a partial solution which is

00:43:00,670 --> 00:43:05,620
basically to look at the file names and

00:43:03,010 --> 00:43:08,260
once you have the same file names you

00:43:05,620 --> 00:43:10,600
try to decide based on the full path

00:43:08,260 --> 00:43:13,630
whether it's the same file or not and

00:43:10,600 --> 00:43:15,700
this works you can actually figure out

00:43:13,630 --> 00:43:17,390
which files are supposed to be the same

00:43:15,700 --> 00:43:20,210
file

00:43:17,390 --> 00:43:22,460
you can't simply put a rule inside of

00:43:20,210 --> 00:43:23,990
make saying that okay boss target

00:43:22,460 --> 00:43:24,620
service M you are going to type in

00:43:23,990 --> 00:43:26,390
forever

00:43:24,620 --> 00:43:29,110
because when you're going to create

00:43:26,390 --> 00:43:33,680
loops inside your dependency tree

00:43:29,110 --> 00:43:36,020
basically you can build loops inside the

00:43:33,680 --> 00:43:41,270
make file it's perfectly normal as long

00:43:36,020 --> 00:43:43,490
as you only take a tree path and you try

00:43:41,270 --> 00:43:45,380
to build it and if you do those

00:43:43,490 --> 00:43:47,510
equivalence without thinking you're

00:43:45,380 --> 00:43:49,430
definitely going to create groups that

00:43:47,510 --> 00:43:52,730
make is going to notice and it's going

00:43:49,430 --> 00:43:56,510
to be awfully confused about it and this

00:43:52,730 --> 00:44:00,880
doesn't work and nobody in BSD land as a

00:43:56,510 --> 00:44:00,880
solution for race as far as I know yes

00:44:02,740 --> 00:44:11,780
so the next step will be to go into the

00:44:08,660 --> 00:44:15,500
worst part of make which is the parent

00:44:11,780 --> 00:44:17,630
of builder and take it out entirely

00:44:15,500 --> 00:44:20,150
because I think that the second shell

00:44:17,630 --> 00:44:22,190
builder is better the only thing that

00:44:20,150 --> 00:44:24,350
needs to be down list instead of

00:44:22,190 --> 00:44:25,880
building things to put stuff that's

00:44:24,350 --> 00:44:31,130
supposed to be built inside the queue

00:44:25,880 --> 00:44:33,410
and to iterate on that and very often to

00:44:31,130 --> 00:44:35,540
look at verse equivalents targets to

00:44:33,410 --> 00:44:37,460
make sure that what you've built is

00:44:35,540 --> 00:44:41,110
actually what you need and that you have

00:44:37,460 --> 00:44:45,380
everything in sync and they should work

00:44:41,110 --> 00:44:47,510
hopefully so maybe see you in two years

00:44:45,380 --> 00:44:50,960
and tell you whether it worked or not I

00:44:47,510 --> 00:44:55,820
think that's about the state of what we

00:44:50,960 --> 00:44:59,270
are doing right now yeah some publicity

00:44:55,820 --> 00:45:01,010
for some of our projects if you want to

00:44:59,270 --> 00:45:05,450
have a build system that's in

00:45:01,010 --> 00:45:08,810
I should really consider ninja as far as

00:45:05,450 --> 00:45:11,540
I know it's McDon right it's completely

00:45:08,810 --> 00:45:14,360
different person Texas has nothing to do

00:45:11,540 --> 00:45:16,160
with mech but almost every problem that

00:45:14,360 --> 00:45:20,270
you noticed if you played a lot with

00:45:16,160 --> 00:45:22,460
make like rescue save max automatically

00:45:20,270 --> 00:45:25,580
generating dependencies for header files

00:45:22,460 --> 00:45:28,220
it's under correctly by ninja the guy

00:45:25,580 --> 00:45:31,010
you did vessels while twenty years of

00:45:28,220 --> 00:45:32,960
insight if what really odd about

00:45:31,010 --> 00:45:36,890
how makes it work and indeed something

00:45:32,960 --> 00:45:38,869
but does actually work so please look at

00:45:36,890 --> 00:45:42,140
it don't go to s cons don't go to see

00:45:38,869 --> 00:45:44,480
make to give to whatever definitely not

00:45:42,140 --> 00:45:44,780
to do make if you want to do something

00:45:44,480 --> 00:45:47,680
new

00:45:44,780 --> 00:45:47,680
start with ninja ah

00:45:47,930 --> 00:45:55,540
I'm almost done time I think yeah any

00:45:53,090 --> 00:45:55,540
questions

00:46:03,290 --> 00:46:12,360
no I wait for the mic in the example for

00:46:08,700 --> 00:46:14,130
the AP dependency rule change that looks

00:46:12,360 --> 00:46:16,050
a lot like the Yak rule

00:46:14,130 --> 00:46:18,840
yep they're using before so what does

00:46:16,050 --> 00:46:23,490
make do now when it sees their role

00:46:18,840 --> 00:46:26,250
written yak for now you explicitly have

00:46:23,490 --> 00:46:28,740
to put this dependency for things to

00:46:26,250 --> 00:46:31,500
work which means that you can't rely on

00:46:28,740 --> 00:46:37,680
the auto-generated to fix rules for yak

00:46:31,500 --> 00:46:42,990
but if you explicitly writes that Jack

00:46:37,680 --> 00:46:46,610
rule it will work so this is still a bit

00:46:42,990 --> 00:46:50,280
tricky you can't just use whatever is

00:46:46,610 --> 00:46:53,040
designed by POSIX for now because it

00:46:50,280 --> 00:46:54,780
will only say that to transform a

00:46:53,040 --> 00:46:56,220
relaxed file into a C file you have

00:46:54,780 --> 00:46:58,890
vegetable and it doesn't say anything

00:46:56,220 --> 00:47:00,590
about the header file you still have to

00:46:58,890 --> 00:47:03,720
put extra dependency for things to work

00:47:00,590 --> 00:47:07,500
this is what we need and as far as I

00:47:03,720 --> 00:47:10,380
know we haven't had any races inside the

00:47:07,500 --> 00:47:13,910
yak generated stuff for at least one

00:47:10,380 --> 00:47:13,910
year so probably works

00:47:19,570 --> 00:47:27,520
actually took two questions if have you

00:47:24,010 --> 00:47:30,040
tried running make with different J

00:47:27,520 --> 00:47:33,100
values and see how the jobs are

00:47:30,040 --> 00:47:35,650
distributed among the processors yeah is

00:47:33,100 --> 00:47:37,690
are they used in a proper way and make

00:47:35,650 --> 00:47:40,690
help that or is it just a kernel

00:47:37,690 --> 00:47:43,030
schedule that's all the camera do is

00:47:40,690 --> 00:47:45,760
definitely your crappy yes that I know

00:47:43,030 --> 00:47:54,940
that but can make help with that

00:47:45,760 --> 00:47:57,430
handicap yes I was just curious how the

00:47:54,940 --> 00:47:59,200
distribution I look the thing I've

00:47:57,430 --> 00:48:02,200
noticed is that you have a crappy laptop

00:47:59,200 --> 00:48:04,630
like this to cross CPU you usually use

00:48:02,200 --> 00:48:06,790
make - g4 for instance because it's

00:48:04,630 --> 00:48:08,320
better and make manages to vest some

00:48:06,790 --> 00:48:12,160
overhead that I don't understand

00:48:08,320 --> 00:48:13,870
anything about if you really look at how

00:48:12,160 --> 00:48:15,940
much time you spend most of the time

00:48:13,870 --> 00:48:18,340
it's not going to be a program with make

00:48:15,940 --> 00:48:21,820
proper but mostly we've received mic

00:48:18,340 --> 00:48:23,830
files and that requires that you

00:48:21,820 --> 00:48:27,010
redesign things to not be recursive at

00:48:23,830 --> 00:48:29,050
all and you also spend a lot of time in

00:48:27,010 --> 00:48:30,790
configure suite for instance but it's

00:48:29,050 --> 00:48:32,650
one exception in our sauce tree which is

00:48:30,790 --> 00:48:35,440
Bennett Hills which is completely crazy

00:48:32,650 --> 00:48:37,870
but you've got all that stuff running in

00:48:35,440 --> 00:48:40,480
parallel and perfectly using make food

00:48:37,870 --> 00:48:42,520
to build things very fast but if you

00:48:40,480 --> 00:48:46,060
look at the most crappiest example we

00:48:42,520 --> 00:48:48,490
have which is Zeno Kara you will lose

00:48:46,060 --> 00:48:50,590
completely with mcmanus 24 because you

00:48:48,490 --> 00:48:53,080
spend about half the time running

00:48:50,590 --> 00:48:55,060
configures and compressing forms which

00:48:53,080 --> 00:48:56,860
are mostly second shell stuff there's

00:48:55,060 --> 00:49:00,550
only one target running at one given

00:48:56,860 --> 00:49:03,370
time if you look at it more closely it's

00:49:00,550 --> 00:49:07,390
also one reason to have DP be and try to

00:49:03,370 --> 00:49:10,500
use it for possibly source config yet

00:49:07,390 --> 00:49:14,530
there isn't where you want to yell at me

00:49:10,500 --> 00:49:16,630
because make only deals properly with

00:49:14,530 --> 00:49:19,000
something which is fairly local if you

00:49:16,630 --> 00:49:22,330
have one single directory with lots of

00:49:19,000 --> 00:49:24,520
source files sure you can parallelize it

00:49:22,330 --> 00:49:26,950
and it will work but if you are things

00:49:24,520 --> 00:49:29,020
over several directories and people have

00:49:26,950 --> 00:49:31,390
already written make files that are

00:49:29,020 --> 00:49:32,770
separate for each actually it won't be

00:49:31,390 --> 00:49:35,109
so good

00:49:32,770 --> 00:49:37,540
it should also be possible to replace

00:49:35,109 --> 00:49:39,270
what we have in v3 in order to build

00:49:37,540 --> 00:49:42,190
several programs at once

00:49:39,270 --> 00:49:44,410
in some cases like very simple stuff

00:49:42,190 --> 00:49:46,599
like LS or sash mode or stuff like that

00:49:44,410 --> 00:49:48,430
while you have the same options and

00:49:46,599 --> 00:49:50,589
while you have one source file para

00:49:48,430 --> 00:49:52,119
victory you could say okay I want to

00:49:50,589 --> 00:49:56,140
build everything at once in parallel

00:49:52,119 --> 00:49:58,930
mode and should possibly work but where

00:49:56,140 --> 00:50:01,480
are some of our dragons most of all to

00:49:58,930 --> 00:50:03,430
you because if you start looking at the

00:50:01,480 --> 00:50:04,900
doulton que file and try changing them

00:50:03,430 --> 00:50:09,490
usually you're going to break something

00:50:04,900 --> 00:50:12,069
else so it's complicated my second

00:50:09,490 --> 00:50:14,589
question was if you look is it always

00:50:12,069 --> 00:50:19,750
worth it to paralyze make in a project I

00:50:14,589 --> 00:50:22,140
mean at the time it takes to to

00:50:19,750 --> 00:50:25,150
calculate the dependencies and weight on

00:50:22,140 --> 00:50:28,720
on the objects that need to be built

00:50:25,150 --> 00:50:32,200
might take more time than actually doing

00:50:28,720 --> 00:50:35,230
it sequentially no if you have one

00:50:32,200 --> 00:50:38,490
single directory and once again make

00:50:35,230 --> 00:50:40,839
instance it's usually going to do a fit

00:50:38,490 --> 00:50:44,290
it's going to be a program if you have

00:50:40,839 --> 00:50:45,670
several directories obviously or if you

00:50:44,290 --> 00:50:48,579
have the time if you start from scratch

00:50:45,670 --> 00:50:51,069
I'd recommend that you write one single

00:50:48,579 --> 00:50:54,849
make file and that you reach over into

00:50:51,069 --> 00:50:56,500
whatever sauce directory you need and at

00:50:54,849 --> 00:50:59,920
least you get a chance to get all

00:50:56,500 --> 00:51:02,230
dependencies right because having make

00:50:59,920 --> 00:51:05,170
running over evolve directories and

00:51:02,230 --> 00:51:06,790
having several make files it's going to

00:51:05,170 --> 00:51:08,650
be expensive because you are going to

00:51:06,790 --> 00:51:10,930
risk and with five systems of all times

00:51:08,650 --> 00:51:13,180
and also you're going to have some

00:51:10,930 --> 00:51:16,119
sequential bottleneck sort of a loop is

00:51:13,180 --> 00:51:18,760
what's what's actually was this

00:51:16,119 --> 00:51:22,150
anecdotal stuff about ninja which is

00:51:18,760 --> 00:51:25,059
that Simek can be coerced to use ninja

00:51:22,150 --> 00:51:27,250
as back-end and if you start doing that

00:51:25,059 --> 00:51:29,680
you will break things because people

00:51:27,250 --> 00:51:32,799
usually don't supply all inter

00:51:29,680 --> 00:51:35,200
dependencies between victory and ninja

00:51:32,799 --> 00:51:37,990
is so much more efficient than GMAC at

00:51:35,200 --> 00:51:40,750
finding them out but you will find races

00:51:37,990 --> 00:51:43,150
but you weren't even aware existed but

00:51:40,750 --> 00:51:45,319
it's definitely worth it you just have

00:51:43,150 --> 00:51:47,630
to run out to win

00:51:45,319 --> 00:51:50,329
pregnancy's speaker a few of em around

00:51:47,630 --> 00:51:53,150
and twitch usually go much faster

00:51:50,329 --> 00:51:55,549
for instance the biggest probe instance

00:51:53,150 --> 00:51:57,999
we had was chromium because chromium

00:51:55,549 --> 00:52:02,769
used to build using Simek and jimick and

00:51:57,999 --> 00:52:06,469
now it's no sorry not seeming cheap and

00:52:02,769 --> 00:52:09,109
anemic and now it's using ninja as a

00:52:06,469 --> 00:52:13,219
back-end as as a result the build time

00:52:09,109 --> 00:52:16,190
has been more than half yeah it was

00:52:13,219 --> 00:52:19,969
spending half the time just for an uchi

00:52:16,190 --> 00:52:25,269
make fools at at least 50% CPU power

00:52:19,969 --> 00:52:25,269
jimick wonder thank you that's

00:52:40,720 --> 00:52:43,860

YouTube URL: https://www.youtube.com/watch?v=md7qKvv_4YI


