Title: BSD ARM Kernel Internals - Arun Thomas
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

In this talk, I’ll discuss how BSD kernels interface with the ARM processor. I will cover the kernel internals of the FreeBSD and NetBSD ARM ports, focusing primarily on ARMv7.I will discuss how booting, memory management, exceptions, and interrupts work, using plenty of BSD code. This talk is meant to be a quick start guide for BSD hackers who aren’t familiar with the ARM architecture.

Speaker biography:

Arun Thomas is an open-source kernel hacker by trade. He got his first taste of BSD in 2002.
Arun is currently an OS researcher/hacker on the DARPA CRASH/SAFE program. He has contributed to several open-source projects over the years, including the MINIX 3 operating system as a core developer, the Gentoo Linux distribution as a Gentoo/Hardened and Gentoo/ARM developer, and the Linux kernel. He has given talks about open-source operating systems at ARM TechCon, BSDCan, EuroBSDCon, and FOSDEM.
Captions: 
	00:00:01,280 --> 00:00:05,670
welcome everybody to the first talk this

00:00:03,510 --> 00:00:07,589
morning it's a great pleasure to

00:00:05,670 --> 00:00:09,540
introduce Aaron Thomas who is going to

00:00:07,589 --> 00:00:12,620
talk about I'm Colonel internists I

00:00:09,540 --> 00:00:12,620
won't thanks

00:00:14,750 --> 00:00:19,050
okay so I'm Aaron Thomas and I'm gonna

00:00:17,190 --> 00:00:22,470
talk about a BSD arm kernel internals

00:00:19,050 --> 00:00:25,140
this is my second talk at a Europe East

00:00:22,470 --> 00:00:27,480
akan I gave a talk at a your a BST con

00:00:25,140 --> 00:00:29,220
2011 when it was in Holland and it was a

00:00:27,480 --> 00:00:30,630
great time the European account events

00:00:29,220 --> 00:00:31,980
are always a lot of fun a lot of

00:00:30,630 --> 00:00:37,469
interesting talks and I interesting

00:00:31,980 --> 00:00:40,730
people so let's get started so we start

00:00:37,469 --> 00:00:45,960
off with a little bit of a quick demo if

00:00:40,730 --> 00:00:47,579
yep cool so what you're seeing now is a

00:00:45,960 --> 00:00:49,610
freebsd booting on arm

00:00:47,579 --> 00:00:52,680
specifically the the picot blunt black

00:00:49,610 --> 00:00:54,780
so there are a couple versions of the

00:00:52,680 --> 00:00:57,300
boot loader that ran and now the freebsd

00:00:54,780 --> 00:00:59,430
you boot loader is running I have some

00:00:57,300 --> 00:01:01,649
screenshots so a lot of stuff kind of

00:00:59,430 --> 00:01:02,640
flew by will have some screenshots where

00:01:01,649 --> 00:01:05,820
we can actually kind of look at what's

00:01:02,640 --> 00:01:10,580
going on so the you boot loader is gonna

00:01:05,820 --> 00:01:12,990
load the kernel shortly and here we go

00:01:10,580 --> 00:01:14,790
okay so now the kernel is running and

00:01:12,990 --> 00:01:16,979
we're doing a bunch of a device

00:01:14,790 --> 00:01:18,000
initialization and so what I'm gonna do

00:01:16,979 --> 00:01:20,549
throughout the talk is kind of go

00:01:18,000 --> 00:01:22,220
through the the process of how FreeBSD

00:01:20,549 --> 00:01:24,270
boots an arm and we'll focus on the

00:01:22,220 --> 00:01:26,700
machine dependent parts kind of the

00:01:24,270 --> 00:01:28,070
early kernel initialization I won't talk

00:01:26,700 --> 00:01:30,090
it all about the Machine independent

00:01:28,070 --> 00:01:32,189
initialization there are a lot of other

00:01:30,090 --> 00:01:35,040
good resources out there for that ok so

00:01:32,189 --> 00:01:37,430
now we're in user land and then we're

00:01:35,040 --> 00:01:41,549
gonna run a bunch of the NIT scripts and

00:01:37,430 --> 00:01:43,049
eventually get to a prompt so as I said

00:01:41,549 --> 00:01:44,579
this is a BeagleBone black it's a pretty

00:01:43,049 --> 00:01:48,210
convenient platform it's pretty cheap

00:01:44,579 --> 00:01:49,979
it's pretty powerful it's supported by

00:01:48,210 --> 00:01:53,700
all of them all the PS DS except

00:01:49,979 --> 00:01:58,170
dragonfly which doesn't have a an arm

00:01:53,700 --> 00:02:00,110
port yet as far as I know and it's gonna

00:01:58,170 --> 00:02:03,500
keep booting we're almost there

00:02:00,110 --> 00:02:03,500
and it's Barry

00:02:05,770 --> 00:02:10,709
so I haven't cooked up via serial cable

00:02:08,530 --> 00:02:13,959
now so we can see all the stuff okay so

00:02:10,709 --> 00:02:16,540
now I can boot I can log in so logging

00:02:13,959 --> 00:02:22,450
this route no password it's very secure

00:02:16,540 --> 00:02:25,930
so that's the message and then if I run

00:02:22,450 --> 00:02:30,550
you name - M running arm which is what

00:02:25,930 --> 00:02:33,340
you expect ok so let's go back to the

00:02:30,550 --> 00:02:36,370
output so as I said there's a couple

00:02:33,340 --> 00:02:40,060
versions of you boot whoa

00:02:36,370 --> 00:02:40,360
all right cool good that was good all

00:02:40,060 --> 00:02:42,040
right

00:02:40,360 --> 00:02:45,280
so there's a couple versions of you boot

00:02:42,040 --> 00:02:48,790
the run so there's SPL and then there's

00:02:45,280 --> 00:02:50,830
a real you boot that runs then there's

00:02:48,790 --> 00:02:52,810
the you boot loader it'll load the

00:02:50,830 --> 00:02:54,190
kernel and these you it uses something

00:02:52,810 --> 00:02:58,600
called a DT B which we'll talk about

00:02:54,190 --> 00:03:00,400
device tree blob and then you get to the

00:02:58,600 --> 00:03:03,160
the copyright notice so the kernels

00:03:00,400 --> 00:03:04,840
booted before this happens there's a lot

00:03:03,160 --> 00:03:06,730
of machine dependent initialization that

00:03:04,840 --> 00:03:09,700
needs to happen that's arm specific and

00:03:06,730 --> 00:03:12,060
so we'll go through what the the code

00:03:09,700 --> 00:03:14,170
that is used to achieve this looks like

00:03:12,060 --> 00:03:16,180
so if you look at logs a little more

00:03:14,170 --> 00:03:18,340
carefully so it's free beastie 11

00:03:16,180 --> 00:03:21,370
current and it's got a weird revision

00:03:18,340 --> 00:03:22,390
because they use get I use crochet to

00:03:21,370 --> 00:03:24,640
build the image and we'll talk about

00:03:22,390 --> 00:03:27,700
what crochet is I use the standard

00:03:24,640 --> 00:03:30,519
BeagleBone config and it's built an arm

00:03:27,700 --> 00:03:32,440
it's arm so FreeBSD is kind of

00:03:30,519 --> 00:03:36,310
interesting in that it builds the system

00:03:32,440 --> 00:03:38,739
with clang even on arm and so here's the

00:03:36,310 --> 00:03:40,660
CPU that the peekaboo and black has its

00:03:38,739 --> 00:03:44,470
cortex eight and I'll talk about the

00:03:40,660 --> 00:03:46,840
different CPUs that arm has a little

00:03:44,470 --> 00:03:49,000
thing about the CPU features has thumb

00:03:46,840 --> 00:03:51,160
to support and it talks a little bit

00:03:49,000 --> 00:03:53,370
more about the the output has more about

00:03:51,160 --> 00:03:55,510
the cache hierarchy and stuff like that

00:03:53,370 --> 00:03:57,400
down here you see something about the

00:03:55,510 --> 00:04:00,280
Texas Instruments am three three five

00:03:57,400 --> 00:04:01,569
eight and that's the the SFC that is in

00:04:00,280 --> 00:04:04,389
the BeagleBone black and we'll talk

00:04:01,569 --> 00:04:05,980
about ssese system on chips a little bit

00:04:04,389 --> 00:04:09,310
more about device tree we'll talk about

00:04:05,980 --> 00:04:10,930
what that is down here the last line you

00:04:09,310 --> 00:04:12,400
see the mapping for the serial this is

00:04:10,930 --> 00:04:16,239
basically how the serial gets configured

00:04:12,400 --> 00:04:19,280
so it's a sixteen five fifty it's mapped

00:04:16,239 --> 00:04:22,160
at this address for 4009 zero zero zero

00:04:19,280 --> 00:04:23,720
and it's at irq 72 and so we'll talk

00:04:22,160 --> 00:04:29,330
about how this information actually gets

00:04:23,720 --> 00:04:31,220
to the to the kernel okay so my goal

00:04:29,330 --> 00:04:34,940
with this talk is to get you all hacking

00:04:31,220 --> 00:04:37,100
bsd on arm how many of you how many of

00:04:34,940 --> 00:04:39,710
you have done little or no hacking on

00:04:37,100 --> 00:04:41,840
bsd arm anybody excellent

00:04:39,710 --> 00:04:43,880
so this talk is designed for all of you

00:04:41,840 --> 00:04:46,070
so my goal is to get you all hacking or

00:04:43,880 --> 00:04:49,850
at least interested in hacking PSTN arm

00:04:46,070 --> 00:04:51,530
so the talk is three parts so I'll start

00:04:49,850 --> 00:04:53,110
off a little arm 101 so a little bit

00:04:51,530 --> 00:04:55,010
about the instruction set architecture

00:04:53,110 --> 00:04:56,360
some of the hardware that's out there

00:04:55,010 --> 00:04:59,300
some the SDC's there out there and where

00:04:56,360 --> 00:05:02,480
to go to find the kind of useful arm

00:04:59,300 --> 00:05:04,550
documentation then after that we'll look

00:05:02,480 --> 00:05:07,520
at some kernel code from FreeBSD NetBSD

00:05:04,550 --> 00:05:09,380
will focus on the machine dependent kind

00:05:07,520 --> 00:05:12,530
of early kernel initialization code and

00:05:09,380 --> 00:05:15,230
then there's a short section on bsd arm

00:05:12,530 --> 00:05:16,700
tips and resources so kind of how to set

00:05:15,230 --> 00:05:20,120
up your development environment where

00:05:16,700 --> 00:05:22,430
the good debug tools are and other good

00:05:20,120 --> 00:05:25,220
resources so you can continue your arm

00:05:22,430 --> 00:05:28,970
study so I gave a version of this talk

00:05:25,220 --> 00:05:31,640
at a BSD can a few months ago and so I

00:05:28,970 --> 00:05:33,650
can honestly say that a patch someone

00:05:31,640 --> 00:05:35,240
actually submitted a patch because of

00:05:33,650 --> 00:05:37,160
this talk so one of the FreeBSD

00:05:35,240 --> 00:05:39,710
committers noticed a typo in my slides

00:05:37,160 --> 00:05:41,240
and it was actually a typo in one of

00:05:39,710 --> 00:05:43,640
those freebie source files in a hello

00:05:41,240 --> 00:05:45,919
cord of s so they fix the typo and an

00:05:43,640 --> 00:05:47,960
hour after my talk they committed they

00:05:45,919 --> 00:05:49,190
made a commit for that that was actually

00:05:47,960 --> 00:05:52,760
kind of cool so I'm hoping all of you

00:05:49,190 --> 00:05:57,740
will also make some hashes against a BSD

00:05:52,760 --> 00:05:59,570
arm ok so let's get into arm so arm is

00:05:57,740 --> 00:06:02,810
as you know hugely popular in embedded

00:05:59,570 --> 00:06:04,190
systems so your smart phones your smart

00:06:02,810 --> 00:06:05,810
watches now all that stuff you probably

00:06:04,190 --> 00:06:07,850
have several arm devices in your pocket

00:06:05,810 --> 00:06:09,260
right now it's moving into

00:06:07,850 --> 00:06:12,169
general-purpose computing so your

00:06:09,260 --> 00:06:15,140
laptops desktops netbooks so the Samsung

00:06:12,169 --> 00:06:17,240
Chromebooks have ARM chips in them it's

00:06:15,140 --> 00:06:19,100
also moving in a server platform so AMD

00:06:17,240 --> 00:06:21,860
is making arm servers now which is kind

00:06:19,100 --> 00:06:23,479
of cool and kind of crazy it's also

00:06:21,860 --> 00:06:25,850
moving a high-performance computing so

00:06:23,479 --> 00:06:28,430
NVIDIA has some pretty cool gpgpu

00:06:25,850 --> 00:06:30,229
platforms there's this Jetson board and

00:06:28,430 --> 00:06:31,430
I saw some posts on the FreeBSD mailing

00:06:30,229 --> 00:06:33,050
list that people are actually working on

00:06:31,430 --> 00:06:35,629
porting FreeBSD to that so

00:06:33,050 --> 00:06:37,520
it's actually pretty cool arm has an

00:06:35,629 --> 00:06:38,780
interesting business model it doesn't

00:06:37,520 --> 00:06:40,819
manufacture chips

00:06:38,780 --> 00:06:42,849
it basically licenses their architecture

00:06:40,819 --> 00:06:46,220
and their processor designs to other

00:06:42,849 --> 00:06:48,289
vendors like TI and Samsung so it'll

00:06:46,220 --> 00:06:51,080
take the core add some extra logic and

00:06:48,289 --> 00:06:52,400
then they'll fabricate and sell that so

00:06:51,080 --> 00:06:56,389
it's kind of an interesting business

00:06:52,400 --> 00:06:58,580
model okay so let's get into the ARM

00:06:56,389 --> 00:07:01,220
architecture so arm stands for advanced

00:06:58,580 --> 00:07:03,050
RISC machine formerly it was acorn RISC

00:07:01,220 --> 00:07:05,900
machine so RISC machine is a reduced

00:07:03,050 --> 00:07:08,719
instruction set computer so as simple

00:07:05,900 --> 00:07:10,340
instructions simpler dressing modes it's

00:07:08,719 --> 00:07:12,259
a load store architecture so if you want

00:07:10,340 --> 00:07:14,599
to operate on memory you need a load

00:07:12,259 --> 00:07:16,460
memory your memory out the word for

00:07:14,599 --> 00:07:18,979
memory into register operated on there

00:07:16,460 --> 00:07:21,979
and store it back out there's no memory

00:07:18,979 --> 00:07:24,379
memory instructions like in x86 it's

00:07:21,979 --> 00:07:26,300
big-endian or little-endian little

00:07:24,379 --> 00:07:28,699
indians far more common especially in

00:07:26,300 --> 00:07:31,250
bsd there been several versions of the

00:07:28,699 --> 00:07:33,979
ISA over the years so there's been the

00:07:31,250 --> 00:07:37,490
current ones or arm v7 and arm p8 so arm

00:07:33,979 --> 00:07:39,680
v7 is a 32-bit is a and arm p8 64-bit is

00:07:37,490 --> 00:07:41,419
a the arm v8 architecture is actually

00:07:39,680 --> 00:07:44,479
pretty cool arm cleaned up a lot of

00:07:41,419 --> 00:07:46,370
things in the architecture but I want to

00:07:44,479 --> 00:07:49,580
talk about it all here we'll stick to

00:07:46,370 --> 00:07:51,469
arm v7 arm also has several architecture

00:07:49,580 --> 00:07:52,430
profiles is the application profile the

00:07:51,469 --> 00:07:54,469
real time profile and the

00:07:52,430 --> 00:07:55,789
microcontroller profile will when we

00:07:54,469 --> 00:07:57,650
talk about the application profile the

00:07:55,789 --> 00:07:59,810
real time in microcontroller profiles

00:07:57,650 --> 00:08:04,940
are for embedded systems that don't

00:07:59,810 --> 00:08:08,150
support virtual memory so so as I said

00:08:04,940 --> 00:08:10,819
we'll focus on arm v7a so the 32-bit

00:08:08,150 --> 00:08:12,590
architecture so if you're looking at CPU

00:08:10,819 --> 00:08:16,430
models these are the cortex a CPUs

00:08:12,590 --> 00:08:18,770
cortex a5 to a 15 and we'll get into the

00:08:16,430 --> 00:08:21,229
the different CPUs that are out there so

00:08:18,770 --> 00:08:23,270
these are CPUs with full MMU support and

00:08:21,229 --> 00:08:24,979
their design for what arm calls full

00:08:23,270 --> 00:08:28,750
feature operating system so things like

00:08:24,979 --> 00:08:31,520
FreeBSD NetBSD iOS that kind of thing so

00:08:28,750 --> 00:08:33,260
our mall on v7 II actually has two

00:08:31,520 --> 00:08:34,430
instruction sets there's the arm

00:08:33,260 --> 00:08:36,079
instruction set and the thumb

00:08:34,430 --> 00:08:37,779
instruction set so the arm instruction

00:08:36,079 --> 00:08:40,310
set is 32-bit it was the original

00:08:37,779 --> 00:08:42,020
instruction set and then later they

00:08:40,310 --> 00:08:44,000
introduced the arm introduced the thumb

00:08:42,020 --> 00:08:46,250
instruction set which is a mix of 16-bit

00:08:44,000 --> 00:08:47,010
and 32-bit instructions originally was

00:08:46,250 --> 00:08:49,110
16-bit

00:08:47,010 --> 00:08:51,210
with the introduction of thumb too they

00:08:49,110 --> 00:08:52,230
also added 32 instructions and the

00:08:51,210 --> 00:08:54,210
reason why they added the thumb

00:08:52,230 --> 00:08:56,730
instruction set is for a code density so

00:08:54,210 --> 00:08:58,920
they want to code if better code density

00:08:56,730 --> 00:09:00,150
is good for your caches so that's the

00:08:58,920 --> 00:09:03,750
main reason and which is good for

00:09:00,150 --> 00:09:06,050
performance okay this is a term that

00:09:03,750 --> 00:09:08,760
you'll see a lot system-on-chip SOC

00:09:06,050 --> 00:09:11,850
especially in the arm world so what's an

00:09:08,760 --> 00:09:13,230
SOC so essentially it's you know it's

00:09:11,850 --> 00:09:14,850
basically an arm CPU packaged up with a

00:09:13,230 --> 00:09:16,950
bunch of other logic so typically on

00:09:14,850 --> 00:09:21,360
these SOC sees the arm CPU is just a

00:09:16,950 --> 00:09:23,370
small piece of the full system so a lot

00:09:21,360 --> 00:09:25,020
of so here's some examples of things

00:09:23,370 --> 00:09:26,700
that you'll find in your esta si so

00:09:25,020 --> 00:09:29,760
you've got interrupt controllers timers

00:09:26,700 --> 00:09:32,760
you arts SD MMC control or SATA

00:09:29,760 --> 00:09:35,280
controllers USB controllers GPUs all

00:09:32,760 --> 00:09:38,340
kinds of peripherals so like your gps

00:09:35,280 --> 00:09:39,720
controller your all the stuff all that

00:09:38,340 --> 00:09:41,310
functionality it's basically in your

00:09:39,720 --> 00:09:46,020
phone is probably it has some sort of

00:09:41,310 --> 00:09:49,080
corresponding block in the SOC so here's

00:09:46,020 --> 00:09:51,030
an example of an SOC this is the the

00:09:49,080 --> 00:09:53,340
a.m. 3 3 5 X that's in the other people

00:09:51,030 --> 00:09:55,550
go in black over there and as you'll see

00:09:53,340 --> 00:09:58,710
the the core is actually a fairly small

00:09:55,550 --> 00:10:00,410
portion of it so that's the cortex a8

00:09:58,710 --> 00:10:02,400
that's what's in the a BeagleBone black

00:10:00,410 --> 00:10:04,380
so if you look at it there's a lot of

00:10:02,400 --> 00:10:06,180
other logic so you've got a GPU in there

00:10:04,380 --> 00:10:09,330
you've got like a bunch of busses you

00:10:06,180 --> 00:10:11,820
got you are it's got SPI you see timers

00:10:09,330 --> 00:10:16,590
watch our time or real-time clock JTAG

00:10:11,820 --> 00:10:19,080
adc's you got your MMC SD GPIO is USB

00:10:16,590 --> 00:10:20,970
Ethernet MAC memory controllers so

00:10:19,080 --> 00:10:25,710
there's a lot of other stuff that goes

00:10:20,970 --> 00:10:27,900
into an SOC than just the arm core so

00:10:25,710 --> 00:10:30,600
this is the board that I've been using

00:10:27,900 --> 00:10:32,940
for the demo it's a popular hobby sport

00:10:30,600 --> 00:10:35,550
it's called the BeagleBone black it's 55

00:10:32,940 --> 00:10:37,020
us it used to be 45 us when they

00:10:35,550 --> 00:10:38,880
released the Red Sea version which is

00:10:37,020 --> 00:10:40,740
current version they increase the price

00:10:38,880 --> 00:10:43,650
by 10 bucks because they increase the

00:10:40,740 --> 00:10:45,600
onboard flash from I think two kegs to

00:10:43,650 --> 00:10:47,460
four gigs I think in Europe you can get

00:10:45,600 --> 00:10:50,130
it for around like 53 euros from one of

00:10:47,460 --> 00:10:52,080
the European distributors so it's

00:10:50,130 --> 00:10:54,840
supported by FreeBSD NetBSD and OpenBSD

00:10:52,080 --> 00:10:56,820
if dragonfly had an arm port I'm pretty

00:10:54,840 --> 00:10:57,870
sure would sport this board as well it's

00:10:56,820 --> 00:10:59,759
a pretty nice platform it's pretty

00:10:57,870 --> 00:11:01,799
powerful it's pretty compact

00:10:59,759 --> 00:11:03,869
you only want you can get it powered

00:11:01,799 --> 00:11:06,209
from a USB so that's actually kind of

00:11:03,869 --> 00:11:07,649
cool and it was kind of nice because I

00:11:06,209 --> 00:11:09,179
when you're packing for a transatlantic

00:11:07,649 --> 00:11:13,410
trip it doesn't take up a lot of room so

00:11:09,179 --> 00:11:17,009
it's kind of cool okay so here are a

00:11:13,410 --> 00:11:20,249
bunch of the the different bsd support

00:11:17,009 --> 00:11:21,929
arm v7s of season boards so these if you

00:11:20,249 --> 00:11:23,939
grab one of these boards you can run bsd

00:11:21,929 --> 00:11:26,100
on them so I'll start off with the Texas

00:11:23,939 --> 00:11:27,989
Instruments family of SOC s that's

00:11:26,100 --> 00:11:30,359
they're really popular they're in a lot

00:11:27,989 --> 00:11:32,100
of really popular boards so the TI OMAP

00:11:30,359 --> 00:11:34,199
3 and DaVinci are found in the

00:11:32,100 --> 00:11:34,879
BeagleBoard and the BeagleBoard XM the

00:11:34,199 --> 00:11:37,019
satara

00:11:34,879 --> 00:11:39,359
SOC s are found in the BeagleBone white

00:11:37,019 --> 00:11:40,529
and the pico blonde black and the OMAP 4

00:11:39,359 --> 00:11:45,389
is found in the panda board and the

00:11:40,529 --> 00:11:47,220
Panda board es so another popular set of

00:11:45,389 --> 00:11:49,859
esta seasons from all winner on the old

00:11:47,220 --> 00:11:52,230
winter 8:28 10 and a 20 knees are found

00:11:49,859 --> 00:11:55,199
in the QB truck the cubieboard in the QB

00:11:52,230 --> 00:11:56,819
truck respectively the Freescale imx6 is

00:11:55,199 --> 00:11:59,519
found in the juan board it's also found

00:11:56,819 --> 00:12:01,319
in the other novena laptop it's a it's

00:11:59,519 --> 00:12:03,209
an open-source laptop from bunny wagon

00:12:01,319 --> 00:12:04,859
company that's getting released soon it

00:12:03,209 --> 00:12:06,499
was like a Kickstarter campaign so

00:12:04,859 --> 00:12:09,480
that's actually kind of cool

00:12:06,499 --> 00:12:11,609
the Samsung Exynos 5 is really high-end

00:12:09,480 --> 00:12:14,609
SOC you'll find this in the Chromebook

00:12:11,609 --> 00:12:15,419
and the Arndale board the styling sync

00:12:14,609 --> 00:12:19,109
is actually a pretty interesting

00:12:15,419 --> 00:12:21,660
platform so basically it pairs a cortex

00:12:19,109 --> 00:12:23,579
CPU with a bunch of at PGA fabric and

00:12:21,660 --> 00:12:24,989
you can find them is that board in the

00:12:23,579 --> 00:12:26,699
micro said so I get a couple of these ed

00:12:24,989 --> 00:12:27,899
boards and it work and it's a it's a

00:12:26,699 --> 00:12:31,919
pretty cool platform if you're doing any

00:12:27,899 --> 00:12:34,410
hardware's on so here's the list of the

00:12:31,919 --> 00:12:38,160
various cortex CPUs that are out there a

00:12:34,410 --> 00:12:40,259
15 through the a 17 so at the low end

00:12:38,160 --> 00:12:41,730
you've got the cortex a5 you'll find on

00:12:40,259 --> 00:12:45,449
the freescale vybrid this is for your

00:12:41,730 --> 00:12:47,339
really kind of embedded stuff at the

00:12:45,449 --> 00:12:50,069
lower end you've got the cortex a8 so

00:12:47,339 --> 00:12:50,970
the TI OMAP 3-2 vinci satara so those

00:12:50,069 --> 00:12:52,079
are the ones that you find in the

00:12:50,970 --> 00:12:54,989
BeagleBone and the BeagleBoard

00:12:52,079 --> 00:12:58,169
the old winter 10 also has the cortex a8

00:12:54,989 --> 00:13:00,869
that's found in the the cubieboard the

00:12:58,169 --> 00:13:02,669
cortex a9 is the mid-range CPUs so

00:13:00,869 --> 00:13:04,769
that'll be found in Euro map 4 which is

00:13:02,669 --> 00:13:06,269
in the pandaboard the Freescale imx6

00:13:04,769 --> 00:13:09,119
which is the wand board and the sync

00:13:06,269 --> 00:13:10,559
board so the a8 and the a 9 are

00:13:09,119 --> 00:13:12,170
basically what you'll see in a lot of

00:13:10,559 --> 00:13:15,290
these hobbyist boards the mature

00:13:12,170 --> 00:13:18,860
of them the cortex a15 is the kind of

00:13:15,290 --> 00:13:21,560
the high end of the the arm CPU models

00:13:18,860 --> 00:13:22,760
so it's found its this Samsung Exynos 5

00:13:21,560 --> 00:13:24,860
which I find a lot of your high-end

00:13:22,760 --> 00:13:27,950
smartphones as well as the Chromebook

00:13:24,860 --> 00:13:29,779
and the Arndale Borden the cortex a7 is

00:13:27,950 --> 00:13:31,760
is one of the newer CPUs it's a

00:13:29,779 --> 00:13:34,250
replacement for the faster a it's a

00:13:31,760 --> 00:13:35,720
faster a8 so it's going for the the

00:13:34,250 --> 00:13:38,060
lower end and you'll find this in the

00:13:35,720 --> 00:13:39,170
Exynos 5 so the Exynos 5 is kind of

00:13:38,060 --> 00:13:42,290
interesting because it has the cortex

00:13:39,170 --> 00:13:43,850
a15 and a7 and what they call a big

00:13:42,290 --> 00:13:46,490
little configuration so that's kind of

00:13:43,850 --> 00:13:49,060
interesting the a8 is also found in the

00:13:46,490 --> 00:13:52,160
all winter 820 which is in the QB truck

00:13:49,060 --> 00:13:53,720
the a12 in the a 17 are newer processors

00:13:52,160 --> 00:13:55,310
they're supposed to kind of fill in the

00:13:53,720 --> 00:13:58,399
mid-range nish so they're a 9

00:13:55,310 --> 00:13:59,870
replacements I don't know I haven't seen

00:13:58,399 --> 00:14:01,399
any s2 sees that they're in yet but I'm

00:13:59,870 --> 00:14:04,850
pretty sure they'll be in a bunch of

00:14:01,399 --> 00:14:06,199
boards pretty soon ok so we talked about

00:14:04,850 --> 00:14:09,139
a bunch of the hardware that's out there

00:14:06,199 --> 00:14:12,110
let's talk about the soft right now so

00:14:09,139 --> 00:14:13,880
we'll talk about api's so what's an ABI

00:14:12,110 --> 00:14:15,680
an ABI is an application binary

00:14:13,880 --> 00:14:18,170
interface so if you read the arm Docs

00:14:15,680 --> 00:14:20,230
there it says that there are rules that

00:14:18,170 --> 00:14:22,670
an arm executes all must must adhere to

00:14:20,230 --> 00:14:24,649
so these are things like executable

00:14:22,670 --> 00:14:27,339
formats calling conventions alignments

00:14:24,649 --> 00:14:30,740
how do what your system calls look like

00:14:27,339 --> 00:14:32,930
so arm has several a/b eyes there's the

00:14:30,740 --> 00:14:34,130
the arm embedded ABI and the arm

00:14:32,930 --> 00:14:37,279
embedded ABI with hardware

00:14:34,130 --> 00:14:39,190
floating-point army ABI and EAB IHF and

00:14:37,279 --> 00:14:41,300
these are the kind of two current api's

00:14:39,190 --> 00:14:43,399
there's an older version there's an

00:14:41,300 --> 00:14:44,660
older ABI arm o ABI I don't actually

00:14:43,399 --> 00:14:46,760
know what the o stands for it might be

00:14:44,660 --> 00:14:49,850
original or old or obsolete I don't know

00:14:46,760 --> 00:14:52,279
but it's not really used as much now so

00:14:49,850 --> 00:14:56,569
net BSD and FreeBSD both support EA bi

00:14:52,279 --> 00:14:57,920
and EAB IHF and depending on which which

00:14:56,569 --> 00:15:02,300
api you want to use you'll build your

00:14:57,920 --> 00:15:03,829
tool chain for that ABI okay so let's

00:15:02,300 --> 00:15:06,829
look at the of the instruction set a

00:15:03,829 --> 00:15:09,079
little bit more so arm has 16

00:15:06,829 --> 00:15:13,269
general-purpose registers r0 through are

00:15:09,079 --> 00:15:16,160
15 some of them had designated uses so

00:15:13,269 --> 00:15:18,170
r11 is the frame pointer or 13 is the

00:15:16,160 --> 00:15:21,019
stack pointer our 14 is the link

00:15:18,170 --> 00:15:22,790
register so the link register when you

00:15:21,019 --> 00:15:24,290
do a call instruction our arm it'll save

00:15:22,790 --> 00:15:25,610
your current PC so you have something to

00:15:24,290 --> 00:15:25,920
return back to so that's what the link

00:15:25,610 --> 00:15:28,649
reg

00:15:25,920 --> 00:15:32,190
just used for our 15s used as the the

00:15:28,649 --> 00:15:34,380
program counter the PC arm also has some

00:15:32,190 --> 00:15:36,360
program status registers and it also has

00:15:34,380 --> 00:15:38,910
floating-point they're called vfp

00:15:36,360 --> 00:15:43,740
registers and arm and sim d registers

00:15:38,910 --> 00:15:45,510
that are called neon ok so I won't talk

00:15:43,740 --> 00:15:47,370
at all about the vfp and the neons stuff

00:15:45,510 --> 00:15:49,800
because but if you're doing numerical

00:15:47,370 --> 00:15:52,800
code and like vector code you should

00:15:49,800 --> 00:15:54,839
look into that stuff more so there are

00:15:52,800 --> 00:15:56,910
two program status registers the current

00:15:54,839 --> 00:15:58,889
program status register the CPS R and

00:15:56,910 --> 00:16:00,810
the save program status register SBS R

00:15:58,889 --> 00:16:03,360
and the SPS stars used for exceptions

00:16:00,810 --> 00:16:05,130
and so it holds some important bits for

00:16:03,360 --> 00:16:07,740
the system's hacker so it has the

00:16:05,130 --> 00:16:09,839
processor mode for instance SVC mode the

00:16:07,740 --> 00:16:11,310
interrupts mask bits weather like irq

00:16:09,839 --> 00:16:12,720
mode if you want to disable interrupts

00:16:11,310 --> 00:16:14,940
basically you'll set this bit in this

00:16:12,720 --> 00:16:19,019
register so if you'll set I R cubed to

00:16:14,940 --> 00:16:20,790
disable interrupts it also tracks the

00:16:19,019 --> 00:16:23,160
state so whether in arm state or thumb

00:16:20,790 --> 00:16:24,600
state as well as the Antonis as a

00:16:23,160 --> 00:16:26,940
processor operating and big-endian or

00:16:24,600 --> 00:16:28,850
little-endian mode and as well as a

00:16:26,940 --> 00:16:33,990
condition your standard condition flags

00:16:28,850 --> 00:16:35,190
negative zero carry overflow ok since

00:16:33,990 --> 00:16:36,930
we'll be doing some kernel hacking it's

00:16:35,190 --> 00:16:39,600
good to have like an idea of what the

00:16:36,930 --> 00:16:40,800
assembly syntax looks like you'll least

00:16:39,600 --> 00:16:43,050
be reading some assembly when you're

00:16:40,800 --> 00:16:44,899
doing kernel hacking probably if you're

00:16:43,050 --> 00:16:47,820
looking at smog jump and stuff like that

00:16:44,899 --> 00:16:49,110
so here's a fairly simple program it

00:16:47,820 --> 00:16:53,339
just adds the numbers one and two

00:16:49,110 --> 00:16:55,290
together so what this does it'll load

00:16:53,339 --> 00:16:58,290
the immediate value 1 into register r1

00:16:55,290 --> 00:17:00,899
and then the load the immediate value 2

00:16:58,290 --> 00:17:03,660
into register r2 and then I'll add r1

00:17:00,899 --> 00:17:06,350
and r2 and put that into register R 3 so

00:17:03,660 --> 00:17:09,000
the destinations on the left side so

00:17:06,350 --> 00:17:10,410
assuming the the process to implement

00:17:09,000 --> 00:17:14,630
correctly you don't get any weird like

00:17:10,410 --> 00:17:18,059
cosmic bit flips you should have 3 + r3

00:17:14,630 --> 00:17:20,520
as I said we've got a arms load store

00:17:18,059 --> 00:17:23,429
architecture so if you know load you

00:17:20,520 --> 00:17:24,569
have to load and store memory so here

00:17:23,429 --> 00:17:27,689
examples of the load and store

00:17:24,569 --> 00:17:30,000
instructions so LDR so this will load

00:17:27,689 --> 00:17:32,640
the value that r1 points to you into r0

00:17:30,000 --> 00:17:36,240
and then this will store the value there

00:17:32,640 --> 00:17:39,200
are 0 has into the memory pointed to the

00:17:36,240 --> 00:17:40,820
pointer whatever r1 points to

00:17:39,200 --> 00:17:42,769
you can also push and pop things to the

00:17:40,820 --> 00:17:44,629
stack so this is how you push multiple

00:17:42,769 --> 00:17:46,970
values on to the sex so this will push

00:17:44,629 --> 00:17:49,399
r0 through r2 onto the stack I think you

00:17:46,970 --> 00:17:51,860
pop those values into r0 through our CEO

00:17:49,399 --> 00:17:53,809
these are actually aliases forearm has

00:17:51,860 --> 00:17:55,700
these load multiple and store multiple

00:17:53,809 --> 00:17:57,619
instructions so you can load multiple

00:17:55,700 --> 00:18:01,700
words and store multiple words to and

00:17:57,619 --> 00:18:04,399
from memory arm also has control flow

00:18:01,700 --> 00:18:07,639
instructions as you might expect so this

00:18:04,399 --> 00:18:10,159
is how you do a branch so branch if 0bz

00:18:07,639 --> 00:18:12,379
lupa the call instruction uses the

00:18:10,159 --> 00:18:16,220
branch and Link instruction PL so this

00:18:12,379 --> 00:18:18,649
will jump to func and then save the the

00:18:16,220 --> 00:18:19,820
current PC to the link register and if

00:18:18,649 --> 00:18:23,690
you want to return use the branch

00:18:19,820 --> 00:18:25,789
exchange instruction so B XLR so this

00:18:23,690 --> 00:18:28,909
will jump to the to the link register

00:18:25,789 --> 00:18:31,340
your saved PC and in older versions the

00:18:28,909 --> 00:18:32,809
I say you would just do this you just

00:18:31,340 --> 00:18:36,049
directly move the link register and the

00:18:32,809 --> 00:18:39,799
PC that's deprecated that's deprecated

00:18:36,049 --> 00:18:40,879
in arm d7 okay so now we went through

00:18:39,799 --> 00:18:42,470
some of the user level stuff look at

00:18:40,879 --> 00:18:44,090
let's look at the OS relevant stuff

00:18:42,470 --> 00:18:46,879
because that's what we're doing we're

00:18:44,090 --> 00:18:48,710
trying to get an OS running arm so arm

00:18:46,879 --> 00:18:50,749
has several privilege levels we'll only

00:18:48,710 --> 00:18:52,789
talk about two of them in this talk so

00:18:50,749 --> 00:18:55,369
peel 0 is used for unprivileged user

00:18:52,789 --> 00:18:57,679
code peel 1 is used for privileged

00:18:55,369 --> 00:18:58,700
kernel code and almost has several

00:18:57,679 --> 00:19:00,470
operating modes

00:18:58,700 --> 00:19:01,700
this stuff's a little bit complicated

00:19:00,470 --> 00:19:04,429
but it's good to know if you're doing

00:19:01,700 --> 00:19:06,019
exception handling if when you're doing

00:19:04,429 --> 00:19:07,850
exception handling so there's one

00:19:06,019 --> 00:19:10,070
unprivileged mode as I said that runs at

00:19:07,850 --> 00:19:12,230
peel 0 but then there are eight

00:19:10,070 --> 00:19:14,239
privileged modes that run at P l1 and

00:19:12,230 --> 00:19:16,039
above so supervisor and irq are some

00:19:14,239 --> 00:19:18,499
examples of those privileged modes and

00:19:16,039 --> 00:19:20,480
the purpose loads privileged modes used

00:19:18,499 --> 00:19:24,139
primarily for interrupts and exception

00:19:20,480 --> 00:19:26,779
handling so here all the modes that the

00:19:24,139 --> 00:19:29,299
processor can be in so supervisor mode

00:19:26,779 --> 00:19:31,820
is used for system calls so arm has an

00:19:29,299 --> 00:19:34,100
instruction SPC our supervisor call and

00:19:31,820 --> 00:19:36,350
that's how you trap into the kernel in

00:19:34,100 --> 00:19:38,690
earlier versions of the ISA this is

00:19:36,350 --> 00:19:40,210
called SWI or software interrupt this is

00:19:38,690 --> 00:19:42,350
actually what you'll see in the PSD code

00:19:40,210 --> 00:19:45,169
it's also the initial mode the processor

00:19:42,350 --> 00:19:46,659
starts up in there's also an interrupt

00:19:45,169 --> 00:19:48,980
mode which is used for normal interrupts

00:19:46,659 --> 00:19:50,690
fast interrupt mode is used for higher

00:19:48,980 --> 00:19:52,370
priority interrupts also the processing

00:19:50,690 --> 00:19:55,220
of the interrupts is a bit faster

00:19:52,370 --> 00:19:57,080
you might expect from the name abroad

00:19:55,220 --> 00:19:59,600
Mord is abort mode is used for memory

00:19:57,080 --> 00:20:01,370
faults and undefined mode is used for

00:19:59,600 --> 00:20:03,830
illegal instructions or also to emulate

00:20:01,370 --> 00:20:05,390
instructions system mode is used as a

00:20:03,830 --> 00:20:07,100
privileged mode that allows you to

00:20:05,390 --> 00:20:09,950
access user mode registers it's not

00:20:07,100 --> 00:20:12,140
really used much hypervisor mode is used

00:20:09,950 --> 00:20:13,910
for virtual machine monitors support and

00:20:12,140 --> 00:20:16,160
monitor mode is used for our arms trust

00:20:13,910 --> 00:20:17,390
zone stuff the most important modes the

00:20:16,160 --> 00:20:19,160
ones you'll see when we look at the code

00:20:17,390 --> 00:20:21,440
examples are supervisor mode interrupt

00:20:19,160 --> 00:20:23,900
mode abort mode and undefined mode and

00:20:21,440 --> 00:20:27,320
we'll see those when we look at the sum

00:20:23,900 --> 00:20:29,059
of the BSD code so arm has an

00:20:27,320 --> 00:20:30,380
interesting feature that I'm just gonna

00:20:29,059 --> 00:20:32,270
mention I don't really have the time to

00:20:30,380 --> 00:20:34,910
go into it but the feature is called

00:20:32,270 --> 00:20:36,470
banked registers so most registers are

00:20:34,910 --> 00:20:38,360
shared amongst the various modes so

00:20:36,470 --> 00:20:40,730
you've one PC in all of those modes that

00:20:38,360 --> 00:20:42,860
I mentioned earlier but banked registers

00:20:40,730 --> 00:20:44,750
are dedicated registers for each mode so

00:20:42,860 --> 00:20:46,250
they're actually duplicated so arm

00:20:44,750 --> 00:20:48,170
allows you to have separate stacks for

00:20:46,250 --> 00:20:49,309
each mode so you will have tubes too so

00:20:48,170 --> 00:20:51,320
you have separate stack pointer

00:20:49,309 --> 00:20:52,730
registers so there's a stack pointer

00:20:51,320 --> 00:20:54,740
register for user mode and the sack

00:20:52,730 --> 00:20:55,820
pointer register for supervisor mode so

00:20:54,740 --> 00:20:57,620
I don't really talk about this I just

00:20:55,820 --> 00:20:59,600
want you guys to know that it exists and

00:20:57,620 --> 00:21:01,730
it's important for exception handling if

00:20:59,600 --> 00:21:05,120
you want to know more some of the arm

00:21:01,730 --> 00:21:06,710
docks will tell you all the details so

00:21:05,120 --> 00:21:10,640
let's briefly go over arm virtual memory

00:21:06,710 --> 00:21:13,070
so on our mv7 you're looking at a 32-bit

00:21:10,640 --> 00:21:15,380
address if you're not using LPA which is

00:21:13,070 --> 00:21:17,360
large physical address extensions with

00:21:15,380 --> 00:21:19,070
LPA you looking at a 40 bit address but

00:21:17,360 --> 00:21:21,740
we're just gonna focus on kind of stock

00:21:19,070 --> 00:21:23,240
arm v7 virtual memory architecture so

00:21:21,740 --> 00:21:26,240
with a 32-bit address you're looking at

00:21:23,240 --> 00:21:28,490
a 4 gigabyte virtual address space arm

00:21:26,240 --> 00:21:31,070
has paging support there's two levels of

00:21:28,490 --> 00:21:33,350
page tables arm calls them translation

00:21:31,070 --> 00:21:35,960
tables in the documents and there's a

00:21:33,350 --> 00:21:38,270
hardware manage TLB so the MMU who does

00:21:35,960 --> 00:21:40,250
the page table walk and TLB miss the

00:21:38,270 --> 00:21:42,290
commonly used page to the page the

00:21:40,250 --> 00:21:48,070
commonly used page sizes are 4 kilobyte

00:21:42,290 --> 00:21:50,300
small pages and 1 megabyte sections so

00:21:48,070 --> 00:21:52,610
one important part of the architecture

00:21:50,300 --> 00:21:54,530
is a coprocessor 15 which is the system

00:21:52,610 --> 00:21:56,270
control core processor it's heavily used

00:21:54,530 --> 00:21:57,559
for systems programming so if you're

00:21:56,270 --> 00:21:59,480
doing in kernel hacking it's good to

00:21:57,559 --> 00:22:02,929
know that it exists I call it the kernel

00:21:59,480 --> 00:22:04,970
hackers best friend so this is used to

00:22:02,929 --> 00:22:06,270
set up the the processes page table so

00:22:04,970 --> 00:22:09,030
this is the instruction that's used

00:22:06,270 --> 00:22:11,190
so you'll this will write to the ax

00:22:09,030 --> 00:22:14,190
translation tape the translation table

00:22:11,190 --> 00:22:15,270
based register so basically you're

00:22:14,190 --> 00:22:17,460
looking to the docks to figure out how

00:22:15,270 --> 00:22:19,650
to do this but the instruction is MCR

00:22:17,460 --> 00:22:21,750
move to coop rusts from register and

00:22:19,650 --> 00:22:23,640
these numbers basically you'll find in

00:22:21,750 --> 00:22:26,490
the docks basically but this is how you

00:22:23,640 --> 00:22:29,190
install the page table another thing

00:22:26,490 --> 00:22:30,870
that the Cobras 15 holds is the system

00:22:29,190 --> 00:22:33,270
control register and that's pretty

00:22:30,870 --> 00:22:35,250
important because this is how you enable

00:22:33,270 --> 00:22:37,470
the MMU and it's also having that will

00:22:35,250 --> 00:22:39,540
enable branch prediction and caching

00:22:37,470 --> 00:22:41,520
it's also how you tell the processor

00:22:39,540 --> 00:22:44,309
where the exception vector table is is

00:22:41,520 --> 00:22:45,809
going to be and use that with these

00:22:44,309 --> 00:22:47,520
instructions again you'll basically just

00:22:45,809 --> 00:22:50,010
look at the arm docks if you don't read

00:22:47,520 --> 00:22:53,970
from it it's moved to register from

00:22:50,010 --> 00:22:55,950
coprocessor so and then to write its

00:22:53,970 --> 00:22:57,990
move to KO process from register

00:22:55,950 --> 00:22:59,610
basically you look at the docks to

00:22:57,990 --> 00:23:00,929
figure out what numbers but these are

00:22:59,610 --> 00:23:05,580
the numbers that you need for the

00:23:00,929 --> 00:23:08,510
processor for the coprocessor stuff ok

00:23:05,580 --> 00:23:10,710
so I'm just gonna that's kind of like a

00:23:08,510 --> 00:23:12,480
quick introduction to the ARM

00:23:10,710 --> 00:23:14,460
architecture if you want all the details

00:23:12,480 --> 00:23:18,590
these are the guides that you should be

00:23:14,460 --> 00:23:21,840
looking at so this is a quote or a

00:23:18,590 --> 00:23:23,910
snippet from the net bsd source code cpu

00:23:21,840 --> 00:23:26,940
func dot c and I'll read it out it says

00:23:23,910 --> 00:23:28,950
and thus spake the arm arm so what's the

00:23:26,940 --> 00:23:31,410
arm arm the arm arm is the ARM

00:23:28,950 --> 00:23:34,020
architecture reference manual it's

00:23:31,410 --> 00:23:35,130
basically has all the details that you

00:23:34,020 --> 00:23:37,470
could possibly want to know about arm

00:23:35,130 --> 00:23:38,190
it's about 2,000 pages so you're

00:23:37,470 --> 00:23:39,510
probably not gonna read it

00:23:38,190 --> 00:23:42,240
cover-to-cover but it's a great

00:23:39,510 --> 00:23:44,309
reference so for our purposes we'll want

00:23:42,240 --> 00:23:48,240
that v 7a and v7 our version of the

00:23:44,309 --> 00:23:50,580
manual so they constantly updated it

00:23:48,240 --> 00:23:52,250
with CPU errata so there was a 2014

00:23:50,580 --> 00:23:55,290
version so that's one you should grab

00:23:52,250 --> 00:23:57,450
the cortex a series programmers guide is

00:23:55,290 --> 00:24:00,809
also great it's a much lighter quicker'n

00:23:57,450 --> 00:24:02,850
introduction to arm so I would

00:24:00,809 --> 00:24:05,309
definitely grab that if you're a neuter

00:24:02,850 --> 00:24:06,840
arm so arm release this originally in

00:24:05,309 --> 00:24:10,380
2012 and they've been continuously

00:24:06,840 --> 00:24:12,179
updating it so it's now in version 4 so

00:24:10,380 --> 00:24:13,770
that one just came out this year so

00:24:12,179 --> 00:24:17,429
these are both free you can grab the

00:24:13,770 --> 00:24:18,990
PDFs on the website and you have to you

00:24:17,429 --> 00:24:20,100
have to register per website or arm but

00:24:18,990 --> 00:24:21,570
the documents are free

00:24:20,100 --> 00:24:25,200
so you should definitely grab these like

00:24:21,570 --> 00:24:26,310
right after the talk or even now the

00:24:25,200 --> 00:24:28,680
other guide that's good is the arm

00:24:26,310 --> 00:24:30,930
system developers God it's a decade old

00:24:28,680 --> 00:24:33,240
it was published in 2004 so our arms

00:24:30,930 --> 00:24:35,310
moved a lot we've come a long way in the

00:24:33,240 --> 00:24:36,990
last decade so some of the stuff stated

00:24:35,310 --> 00:24:38,370
but in terms of the system level aspects

00:24:36,990 --> 00:24:40,590
especially like exception handling all

00:24:38,370 --> 00:24:45,210
that stuff this is a really great really

00:24:40,590 --> 00:24:46,890
great resource even still okay so in

00:24:45,210 --> 00:24:48,900
addition to those manuals you'll want to

00:24:46,890 --> 00:24:50,700
get some manuals for your specific board

00:24:48,900 --> 00:24:52,650
so in this case for the big one black

00:24:50,700 --> 00:24:54,900
you get a cortex a8 so you want to grab

00:24:52,650 --> 00:24:56,730
the manual for the cortex eight the

00:24:54,900 --> 00:24:58,920
technical reference manual you want to

00:24:56,730 --> 00:25:00,480
grab the am 3 3 5 X technical reference

00:24:58,920 --> 00:25:01,770
manual because that's the SOC that's on

00:25:00,480 --> 00:25:03,300
this board and then you want to grab the

00:25:01,770 --> 00:25:06,960
Beagle bone system reference manual as

00:25:03,300 --> 00:25:10,080
well so the SOC CRM has a lot of useful

00:25:06,960 --> 00:25:13,110
information like the memory map so if

00:25:10,080 --> 00:25:15,450
you want to write to this to the to the

00:25:13,110 --> 00:25:18,300
serial port your zeros map this address

00:25:15,450 --> 00:25:19,890
we saw this earlier for for easy row 9 0

00:25:18,300 --> 00:25:21,450
0 0 so if you just write to this address

00:25:19,890 --> 00:25:23,910
that's where you have transmit register

00:25:21,450 --> 00:25:25,770
is so you can get to output to serial

00:25:23,910 --> 00:25:28,170
that way the interrupt controller is

00:25:25,770 --> 00:25:30,480
mapped this address the DM timer1 which

00:25:28,170 --> 00:25:32,730
uses a clock is this address and the T

00:25:30,480 --> 00:25:33,800
Rams mapped to this address so the T

00:25:32,730 --> 00:25:37,740
around has a lot of useful information

00:25:33,800 --> 00:25:39,030
the SOC trm almost has a lot of useful

00:25:37,740 --> 00:25:41,630
migration guides so if you're coming

00:25:39,030 --> 00:25:44,400
from mips power x86 these are good

00:25:41,630 --> 00:25:46,610
they're kind of a Quick Start Guide CIA

00:25:44,400 --> 00:25:49,860
32 guide has useful information like on

00:25:46,610 --> 00:25:51,480
arm characters are unsigned by default

00:25:49,860 --> 00:25:52,680
and so that can cause problems so you

00:25:51,480 --> 00:25:54,120
should definitely grab these if you're

00:25:52,680 --> 00:25:57,720
coming from one of these other

00:25:54,120 --> 00:26:00,120
architectures ok so now that we kind of

00:25:57,720 --> 00:26:01,740
went into the basics of the ARM

00:26:00,120 --> 00:26:03,270
architecture and I showed you guys where

00:26:01,740 --> 00:26:05,700
to get more documentation we can start

00:26:03,270 --> 00:26:07,320
digging into the code so the vast

00:26:05,700 --> 00:26:08,550
majority of your OS code is going to be

00:26:07,320 --> 00:26:11,280
machine independent so it's gonna be the

00:26:08,550 --> 00:26:13,230
same across all the architectures and

00:26:11,280 --> 00:26:15,870
then a small portion of it is machine

00:26:13,230 --> 00:26:18,630
dependent so that ends that's like arm

00:26:15,870 --> 00:26:20,820
specific code and this is usually a mix

00:26:18,630 --> 00:26:22,650
of C and some assembly and inline

00:26:20,820 --> 00:26:24,690
assembly so we're gonna look at some

00:26:22,650 --> 00:26:25,970
examples from FreeBSD and a PST and kind

00:26:24,690 --> 00:26:30,930
of go through the machine dependent

00:26:25,970 --> 00:26:33,270
initialization of the kernel so FreeBSD

00:26:30,930 --> 00:26:34,050
an epi ste both have arm I've really

00:26:33,270 --> 00:26:36,540
great arm support

00:26:34,050 --> 00:26:38,490
and there's some notable differences so

00:26:36,540 --> 00:26:39,810
neppy sees build-out SH which is what

00:26:38,490 --> 00:26:41,520
you use to build the system allows for

00:26:39,810 --> 00:26:42,900
cross OS building so you can build on

00:26:41,520 --> 00:26:45,630
Linux or Mac or whatever so that's

00:26:42,900 --> 00:26:47,220
actually kind of cool FreeBSD uses clang

00:26:45,630 --> 00:26:49,970
to build the system so that's actually

00:26:47,220 --> 00:26:52,230
kind of interesting even on arm so

00:26:49,970 --> 00:26:54,000
previously uses device tree for hardware

00:26:52,230 --> 00:26:56,760
configuration while net beastie uses the

00:26:54,000 --> 00:26:58,320
auto comp framework FreeBSD has an extra

00:26:56,760 --> 00:26:59,610
booth later bootloader stage called you

00:26:58,320 --> 00:27:03,090
boot loader and we'll look at that

00:26:59,610 --> 00:27:04,770
when we get into booting so here are the

00:27:03,090 --> 00:27:06,210
pads that you want to know when you

00:27:04,770 --> 00:27:09,270
start looking start taking in to the

00:27:06,210 --> 00:27:11,370
code for an FPS T so all the arm

00:27:09,270 --> 00:27:13,020
specific code is under ciserek arm so

00:27:11,370 --> 00:27:16,200
the headers are under include and

00:27:13,020 --> 00:27:18,630
include arm 32 and the dot c files under

00:27:16,200 --> 00:27:21,120
our arm arm 32 and cortex so this is

00:27:18,630 --> 00:27:23,130
these are those pads for the core ARM

00:27:21,120 --> 00:27:25,050
architecture support then if you want to

00:27:23,130 --> 00:27:29,610
look at the SOC and BeagleBone specific

00:27:25,050 --> 00:27:31,980
code you look under OMAP and evv arm so

00:27:29,610 --> 00:27:33,300
evb arm stands for evaluation board arm

00:27:31,980 --> 00:27:35,850
and that's where all the platform

00:27:33,300 --> 00:27:38,370
specific code goes so include has the

00:27:35,850 --> 00:27:41,930
header files and then beagle has your

00:27:38,370 --> 00:27:44,490
beagle bone specific or source files

00:27:41,930 --> 00:27:47,340
then the configuration files if you want

00:27:44,490 --> 00:27:50,790
to figure out which files get built when

00:27:47,340 --> 00:27:53,550
you add for the core arm support you'll

00:27:50,790 --> 00:27:55,920
look in this files arm file and standard

00:27:53,550 --> 00:27:56,730
arm has our STD our arm has the various

00:27:55,920 --> 00:27:58,920
build options

00:27:56,730 --> 00:28:01,470
that's use to build arm you also want to

00:27:58,920 --> 00:28:04,470
look at files that cortex for the

00:28:01,470 --> 00:28:07,080
BeagleBone and s and the a.m. 3 3 5 x

00:28:04,470 --> 00:28:09,290
stuff you'll look at the OMAP to file

00:28:07,080 --> 00:28:11,940
the EBP arm file in the Pico file and

00:28:09,290 --> 00:28:14,270
the this file the Beagle bone this is

00:28:11,940 --> 00:28:18,800
the top-level Pico boned kernel config

00:28:14,270 --> 00:28:20,730
so for FreeBSD here are the key

00:28:18,800 --> 00:28:22,800
directories for the core arm support

00:28:20,730 --> 00:28:24,240
there's fewer directories so all the

00:28:22,800 --> 00:28:27,300
architecture specific code goes under

00:28:24,240 --> 00:28:29,280
sis arm so include has your include

00:28:27,300 --> 00:28:32,400
files as you might expect an arm has

00:28:29,280 --> 00:28:35,310
your all the dot C files and then for

00:28:32,400 --> 00:28:36,480
your SOC and for the Beagle bone you can

00:28:35,310 --> 00:28:39,840
find that stuff under

00:28:36,480 --> 00:28:41,880
Ti so that's the directory that has all

00:28:39,840 --> 00:28:45,060
the shared code for all the T is OCS and

00:28:41,880 --> 00:28:48,560
then the a.m. 3 3 5 X has the code for

00:28:45,060 --> 00:28:48,560
the Beagle bone specific stuff

00:28:48,690 --> 00:28:52,980
then you look at files that arm to

00:28:51,360 --> 00:28:54,630
figure out which files get built

00:28:52,980 --> 00:28:56,550
basically and then there are

00:28:54,630 --> 00:28:57,990
corresponding files for the SSC and for

00:28:56,550 --> 00:29:00,750
the BeagleBone so you look at the ti one

00:28:57,990 --> 00:29:02,880
the a.m. 3 3 5 X Files the people don't

00:29:00,750 --> 00:29:04,290
file and the top-level kernel config can

00:29:02,880 --> 00:29:06,870
be found here so if you want to modify

00:29:04,290 --> 00:29:10,410
the the Karl config you'll copy that and

00:29:06,870 --> 00:29:11,970
then you can tweak it there okay so

00:29:10,410 --> 00:29:14,460
let's talk a little bit about a booting

00:29:11,970 --> 00:29:18,120
on arm so we'll talk a little bit about

00:29:14,460 --> 00:29:20,070
how how the Pico boots so the bootloader

00:29:18,120 --> 00:29:21,870
has a few main responsibilities so it'll

00:29:20,070 --> 00:29:23,940
do kind of your basic hardware

00:29:21,870 --> 00:29:24,780
initialization so it'll initialize DRAM

00:29:23,940 --> 00:29:27,390
and serial

00:29:24,780 --> 00:29:29,250
it'll pass some boot parameters some

00:29:27,390 --> 00:29:30,750
information to the kernel and then we'll

00:29:29,250 --> 00:29:34,140
load the kernel so those are kind of the

00:29:30,750 --> 00:29:35,730
main responsibilities so when you boot

00:29:34,140 --> 00:29:37,170
up there's several boot loaders that run

00:29:35,730 --> 00:29:39,420
the first thing it runs is the reset

00:29:37,170 --> 00:29:41,370
handler and the SOC rom then the

00:29:39,420 --> 00:29:43,560
first-stage bootloader will run so SPL

00:29:41,370 --> 00:29:45,030
or ml ml oh and the BeagleBone black and

00:29:43,560 --> 00:29:47,160
there's a stripped-down version of you

00:29:45,030 --> 00:29:49,140
boot and that's needed since your DRAM

00:29:47,160 --> 00:29:53,460
is not initialized yet and so here's

00:29:49,140 --> 00:29:54,960
some output from SPL then after that

00:29:53,460 --> 00:29:56,400
your second stage bootloader runs you

00:29:54,960 --> 00:29:59,310
can run a full version of you boot and

00:29:56,400 --> 00:30:01,290
this will read the configuration um txt

00:29:59,310 --> 00:30:03,420
so you can see that here and if you want

00:30:01,290 --> 00:30:04,770
to tweak the the booting stuff this is

00:30:03,420 --> 00:30:06,330
the file that you'll modify so if you

00:30:04,770 --> 00:30:10,500
want to set up like net booting you'll

00:30:06,330 --> 00:30:12,930
modify this file then it reads your DTB

00:30:10,500 --> 00:30:15,150
file and I'm going to talk about the

00:30:12,930 --> 00:30:19,800
device tree blob shortly and then it'll

00:30:15,150 --> 00:30:21,780
start the new boot loader so this is an

00:30:19,800 --> 00:30:24,240
extra bootloader stage that only occurs

00:30:21,780 --> 00:30:25,590
on FreeBSD and FEC doesn't have it it's

00:30:24,240 --> 00:30:27,540
an implementation of the standard loader

00:30:25,590 --> 00:30:29,820
that's on the other freebsd platforms

00:30:27,540 --> 00:30:31,710
and you can find those sources here if

00:30:29,820 --> 00:30:34,170
you're interested and here's the output

00:30:31,710 --> 00:30:35,280
from the FreeBSD u bootloader you can

00:30:34,170 --> 00:30:38,160
tell that it's going to boot the kernel

00:30:35,280 --> 00:30:43,200
and then it's going to use the the D to

00:30:38,160 --> 00:30:45,600
be provided so device tree

00:30:43,200 --> 00:30:48,120
what's device tree so device tree is

00:30:45,600 --> 00:30:49,830
used for to capture a hardware

00:30:48,120 --> 00:30:51,750
configuration and it's used by FreeBSD

00:30:49,830 --> 00:30:53,250
on several platforms I think it

00:30:51,750 --> 00:30:58,310
originally comes from PowerPC but it's

00:30:53,250 --> 00:31:01,110
used on MIPS and arm and PowerPC as well

00:30:58,310 --> 00:31:03,150
so you can find the source file

00:31:01,110 --> 00:31:06,600
for the device tree blobs in this

00:31:03,150 --> 00:31:08,280
directory DTS arm and for the people in

00:31:06,600 --> 00:31:11,640
black you'll look at the BeagleBone

00:31:08,280 --> 00:31:15,380
black DTS most of the logics actually in

00:31:11,640 --> 00:31:19,020
this included file the a.m. 3 5 X DTS I

00:31:15,380 --> 00:31:22,230
that's the SS sees DTS file so here's a

00:31:19,020 --> 00:31:25,500
snippet from that file so the SSC is the

00:31:22,230 --> 00:31:27,809
aim 3 3 5 X and so this is u r0 and so

00:31:25,500 --> 00:31:30,150
you tells you what kind of SOC it

00:31:27,809 --> 00:31:33,120
what kind of UART it is it's an NS 16

00:31:30,150 --> 00:31:37,890
550 it tells you the mapping there's

00:31:33,120 --> 00:31:41,370
that for 4009 0 0 0 0 address it's

00:31:37,890 --> 00:31:43,740
mapped 4 0 X 1000 so for K and the

00:31:41,370 --> 00:31:47,070
registers shift is 2 so it's gonna do a

00:31:43,740 --> 00:31:51,270
4 byte accesses and it uses interrupts

00:31:47,070 --> 00:31:52,860
72 so that DTS file gets turned into a

00:31:51,270 --> 00:31:55,799
device tree blob of the device tree

00:31:52,860 --> 00:31:58,440
compiler so this BeagleBone black DTS

00:31:55,799 --> 00:32:00,960
becomes the B bone black DTP that we saw

00:31:58,440 --> 00:32:03,419
getting loaded earlier so the device

00:32:00,960 --> 00:32:05,910
free blob is it's stored in a compressed

00:32:03,419 --> 00:32:07,440
format called a flattened device tree it

00:32:05,910 --> 00:32:09,690
can either be compiled in the kernel or

00:32:07,440 --> 00:32:12,150
loaded separately so in our case it was

00:32:09,690 --> 00:32:14,250
being loaded separately the kernel

00:32:12,150 --> 00:32:16,440
parses the DCP to learn the the board's

00:32:14,250 --> 00:32:17,580
hardware configuration and if you want

00:32:16,440 --> 00:32:19,980
to know the details of how that stuff

00:32:17,580 --> 00:32:22,520
works if you look at Lib FD T it'll it

00:32:19,980 --> 00:32:25,200
has all the FTT parsing code

00:32:22,520 --> 00:32:27,150
ok so net bsd does not use device tree

00:32:25,200 --> 00:32:29,669
uses auto conference dead that's the

00:32:27,150 --> 00:32:31,950
device auto configuration framework so

00:32:29,669 --> 00:32:33,179
the hardware configurated by the kernel

00:32:31,950 --> 00:32:35,610
configuration process so when you run

00:32:33,179 --> 00:32:37,740
config basically so here's a snippet

00:32:35,610 --> 00:32:40,140
from the top-level BeagleBone config

00:32:37,740 --> 00:32:42,240
file and a PSD and you can tell it as

00:32:40,140 --> 00:32:46,110
basically the same information so it has

00:32:42,240 --> 00:32:48,900
the same address for 4900 and it's

00:32:46,110 --> 00:32:52,200
mapped for 4k it's using interrupts 72

00:32:48,900 --> 00:32:57,630
and it's accessing things that uh for at

00:32:52,200 --> 00:32:59,040
4 byte boundaries ok so now that we

00:32:57,630 --> 00:33:00,210
talked a little bit up a little bit

00:32:59,040 --> 00:33:04,860
about booting let's go through the

00:33:00,210 --> 00:33:05,940
kernel initialization process so the

00:33:04,860 --> 00:33:07,919
first thing that happens is sort of

00:33:05,940 --> 00:33:09,510
early kernel initialization so the first

00:33:07,919 --> 00:33:11,460
thing it'll the kernel will deal will

00:33:09,510 --> 00:33:12,990
save off the boot parameters it'll set

00:33:11,460 --> 00:33:13,350
the initial page table and then enable

00:33:12,990 --> 00:33:15,450
the

00:33:13,350 --> 00:33:16,980
you it'll set up the exception vector

00:33:15,450 --> 00:33:19,020
table the exception handlers and the

00:33:16,980 --> 00:33:20,429
exception stacks and then we'll do some

00:33:19,020 --> 00:33:21,660
device initialization so it'll

00:33:20,429 --> 00:33:23,700
initialize a serial the interpret

00:33:21,660 --> 00:33:26,520
controller the timer is for the clock

00:33:23,700 --> 00:33:27,120
tick then we'll get into the machine

00:33:26,520 --> 00:33:29,130
independent

00:33:27,120 --> 00:33:31,110
initialization that's common across all

00:33:29,130 --> 00:33:32,910
the the architectures so this will

00:33:31,110 --> 00:33:35,010
initialize your kernel subsystems it'll

00:33:32,910 --> 00:33:36,690
do some more device initialization it'll

00:33:35,010 --> 00:33:38,100
only then you'll enable interrupts and

00:33:36,690 --> 00:33:40,049
then I'll switch to user mode and run in

00:33:38,100 --> 00:33:41,610
it which is the first user code so I

00:33:40,049 --> 00:33:45,120
don't talk I won't talk about this stuff

00:33:41,610 --> 00:33:47,280
at all there's a good talk at a aja bsd

00:33:45,120 --> 00:33:49,350
con that will go over these details or

00:33:47,280 --> 00:33:51,030
you could also read off the new edition

00:33:49,350 --> 00:33:52,320
of Kurt's book the booting chapter has a

00:33:51,030 --> 00:33:57,780
bunch of useful stuff in there it's been

00:33:52,320 --> 00:34:00,480
updated so we're the first steps for a

00:33:57,780 --> 00:34:04,650
freebsd unarmed so if you look at a ll

00:34:00,480 --> 00:34:05,850
core s the the entry point is start so

00:34:04,650 --> 00:34:09,600
these are the very first instructions

00:34:05,850 --> 00:34:10,200
that execute so previously uses a Linux

00:34:09,600 --> 00:34:13,649
boot ABI

00:34:10,200 --> 00:34:17,639
so since it's using you boot so R 0 will

00:34:13,649 --> 00:34:19,440
have register 0 in it or register 0 will

00:34:17,639 --> 00:34:21,330
have value 0 in it our one will have the

00:34:19,440 --> 00:34:23,490
Machine type and our two in this case

00:34:21,330 --> 00:34:26,669
will have a pointer to the the DTE image

00:34:23,490 --> 00:34:28,950
and if you read this comment so all this

00:34:26,669 --> 00:34:32,300
stuff actually gets passed to init arm

00:34:28,950 --> 00:34:35,580
in the struct arm booth params structure

00:34:32,300 --> 00:34:36,780
so these instructions is down here is

00:34:35,580 --> 00:34:39,270
basically just saving off these

00:34:36,780 --> 00:34:41,070
registers from that you boot gives you

00:34:39,270 --> 00:34:43,409
so information that you boot gives you

00:34:41,070 --> 00:34:44,730
then the next thing the freebies does is

00:34:43,409 --> 00:34:47,250
it tries to make sure that interrupts

00:34:44,730 --> 00:34:49,260
are disabled so you could we'll do this

00:34:47,250 --> 00:34:50,550
for you but kernel programmers are kind

00:34:49,260 --> 00:34:52,590
of paranoid so they want to make sure

00:34:50,550 --> 00:34:54,149
that interrupts are disabled because

00:34:52,590 --> 00:34:55,710
you're not ready to handle interrupts

00:34:54,149 --> 00:34:57,180
yet because you haven't set up any of

00:34:55,710 --> 00:34:59,580
the exception handlers or the interrupt

00:34:57,180 --> 00:35:01,410
handlers so this is the code to do that

00:34:59,580 --> 00:35:02,640
basically all does is earlier I

00:35:01,410 --> 00:35:05,609
mentioned that a current program status

00:35:02,640 --> 00:35:07,350
register has interrupt has an interrupt

00:35:05,609 --> 00:35:09,750
disabled bit so basically is just gonna

00:35:07,350 --> 00:35:12,450
read the current program status register

00:35:09,750 --> 00:35:13,859
and then or in the I bit and the eff bit

00:35:12,450 --> 00:35:15,930
to disable interrupts and fast

00:35:13,859 --> 00:35:18,359
interrupts and then it uses the MS or

00:35:15,930 --> 00:35:24,980
move to status from register to to write

00:35:18,359 --> 00:35:26,630
that value so the freebsd that freebsd

00:35:24,980 --> 00:35:29,660
the start routine is actually common

00:35:26,630 --> 00:35:32,839
across all of the SOC s neppy ste has

00:35:29,660 --> 00:35:35,570
actually different start routines for

00:35:32,839 --> 00:35:37,910
each board so the beagle start s file

00:35:35,570 --> 00:35:40,040
has the the entry point for the Beagle

00:35:37,910 --> 00:35:41,720
board which is a beagle start so it's

00:35:40,040 --> 00:35:44,570
pretty similar what you'll see is that

00:35:41,720 --> 00:35:46,339
it will try to switch to SVC mode and

00:35:44,570 --> 00:35:50,750
disable interrupts and that's what the

00:35:46,339 --> 00:35:52,730
CPS ID instruction does this is a this

00:35:50,750 --> 00:35:55,310
isn't actually necessary but it's good

00:35:52,730 --> 00:35:56,960
to do just in case and then it does the

00:35:55,310 --> 00:35:59,359
same thing basically this freebsd this

00:35:56,960 --> 00:36:01,460
will it basically saves off the the

00:35:59,359 --> 00:36:06,440
arguments that the the bootloader gave

00:36:01,460 --> 00:36:08,150
us into this location you boot args so

00:36:06,440 --> 00:36:12,380
we'll continue on with an epi ste

00:36:08,150 --> 00:36:15,170
initialization so the people start will

00:36:12,380 --> 00:36:18,020
create an initial page table

00:36:15,170 --> 00:36:21,079
it calls armed boot L 1 PT NIT to do the

00:36:18,020 --> 00:36:23,270
work so this page table is an l1 page

00:36:21,079 --> 00:36:25,190
table with one megabyte sections so it

00:36:23,270 --> 00:36:26,780
has mappings for the kernel it's just an

00:36:25,190 --> 00:36:28,339
identity mapping server shil address

00:36:26,780 --> 00:36:30,020
equals physical address and as a mapping

00:36:28,339 --> 00:36:34,880
for serial so we can get debug output

00:36:30,020 --> 00:36:37,400
out to the serial after that legal start

00:36:34,880 --> 00:36:39,950
will run and it'll it needs to enable

00:36:37,400 --> 00:36:41,780
people start will continue to run and it

00:36:39,950 --> 00:36:44,210
needs to enable the MMU and it calls arm

00:36:41,780 --> 00:36:47,180
CP unit to do the work so if you read

00:36:44,210 --> 00:36:50,510
this comment it says turn on the MMU CPU

00:36:47,180 --> 00:36:52,730
cache turn on the MMU and caches so it

00:36:50,510 --> 00:36:54,500
passes in that temporary l1 page table

00:36:52,730 --> 00:36:57,740
that we mentioned earlier to arm CP unit

00:36:54,500 --> 00:36:59,410
so arm CPU NIT it's a little bit

00:36:57,740 --> 00:37:04,310
misleading it's in this function that

00:36:59,410 --> 00:37:07,250
has an a 9 file but it also applies to

00:37:04,310 --> 00:37:09,050
the cortex a8 as well which is the

00:37:07,250 --> 00:37:10,220
processor on the Beagle bone so the

00:37:09,050 --> 00:37:12,319
first thing this does it will invalidate

00:37:10,220 --> 00:37:14,240
your cache is in your teal B's then it

00:37:12,319 --> 00:37:16,099
will enable the caches and I'll set the

00:37:14,240 --> 00:37:17,599
t TBR which is a translation table based

00:37:16,099 --> 00:37:21,530
register that's how you install the page

00:37:17,599 --> 00:37:23,540
table and then you'll enable the MMU so

00:37:21,530 --> 00:37:25,280
the rest of the machine dependent

00:37:23,540 --> 00:37:27,170
initialization is handled by start this

00:37:25,280 --> 00:37:30,740
is a common routine across all the SOC s

00:37:27,170 --> 00:37:32,599
you can find it in ello cord s and this

00:37:30,740 --> 00:37:35,150
is basically the jump to that common

00:37:32,599 --> 00:37:36,109
start routine so start basically what it

00:37:35,150 --> 00:37:37,860
does is it will set up the environment

00:37:36,109 --> 00:37:39,270
for C code so you

00:37:37,860 --> 00:37:41,280
do the rest of the initialization and

00:37:39,270 --> 00:37:43,140
see which is a lot more convenient than

00:37:41,280 --> 00:37:44,850
writing everything in assembly so the

00:37:43,140 --> 00:37:46,320
first C function that'll run is init arm

00:37:44,850 --> 00:37:49,050
which is a helper function init arm

00:37:46,320 --> 00:37:50,370
common and that'll do the rest of the

00:37:49,050 --> 00:37:51,840
the kind of machine dependent

00:37:50,370 --> 00:37:54,030
initialization for you so there's a lot

00:37:51,840 --> 00:37:55,500
of stuff that happens in there after

00:37:54,030 --> 00:37:58,020
that's done then you can call main which

00:37:55,500 --> 00:38:01,890
is the first machine independent code on

00:37:58,020 --> 00:38:04,980
FreeBSD this main is called mi startup

00:38:01,890 --> 00:38:06,000
for a machine independent startup but

00:38:04,980 --> 00:38:10,230
the flow is pretty similar between

00:38:06,000 --> 00:38:12,780
FreeBSD and a BSD so init arm as I

00:38:10,230 --> 00:38:15,240
mentioned in there arm is a SOC specific

00:38:12,780 --> 00:38:17,280
so there's one for the BeagleBone and

00:38:15,240 --> 00:38:18,810
then init arm common is the arm generic

00:38:17,280 --> 00:38:21,380
one that Scott is shared across all the

00:38:18,810 --> 00:38:24,120
SOC s so these two functions perform

00:38:21,380 --> 00:38:27,120
these two functions together do the

00:38:24,120 --> 00:38:28,980
following things so it'll map the

00:38:27,120 --> 00:38:31,080
devices and I'll initialize the console

00:38:28,980 --> 00:38:33,420
it sets up the real page table so we in

00:38:31,080 --> 00:38:35,640
a kind of a dummy page table initially

00:38:33,420 --> 00:38:37,980
this will set up the real page table and

00:38:35,640 --> 00:38:40,410
switch to it it'll set up the exception

00:38:37,980 --> 00:38:43,710
vectors and stacks and all parse the the

00:38:40,410 --> 00:38:48,420
boot arguments afterwards in it arm and

00:38:43,710 --> 00:38:50,130
main can run so we'll talk we'll briefly

00:38:48,420 --> 00:38:50,940
talk about exception handling for the

00:38:50,130 --> 00:38:53,760
the kernel hacker

00:38:50,940 --> 00:38:55,320
so things that you'll have to do you'll

00:38:53,760 --> 00:38:56,700
have to set up the vector table the

00:38:55,320 --> 00:39:00,440
exception stack pointers and you'll have

00:38:56,700 --> 00:39:03,840
to write handlers for each exception so

00:39:00,440 --> 00:39:05,850
the exceptions are briefly reset

00:39:03,840 --> 00:39:07,920
undefined instruction supervisory call

00:39:05,850 --> 00:39:09,420
used for system calls prefetcher board

00:39:07,920 --> 00:39:10,620
and data board these are used for memory

00:39:09,420 --> 00:39:13,140
faults and instruction and data

00:39:10,620 --> 00:39:15,510
respectively interrupts fast interrupts

00:39:13,140 --> 00:39:17,130
and hypervisor calls so the exception

00:39:15,510 --> 00:39:19,680
vector table is a jump table with eight

00:39:17,130 --> 00:39:21,720
entries one for each exception type so

00:39:19,680 --> 00:39:24,090
each entry holds one armed instruction

00:39:21,720 --> 00:39:26,130
so you can either make it a branch to an

00:39:24,090 --> 00:39:27,390
exception handler or a PC load of an

00:39:26,130 --> 00:39:27,600
exception handler that's what this looks

00:39:27,390 --> 00:39:29,790
like

00:39:27,600 --> 00:39:31,470
they're basically equivalent so this is

00:39:29,790 --> 00:39:33,390
what free beasties exception vector

00:39:31,470 --> 00:39:35,580
table looks like you find an exception s

00:39:33,390 --> 00:39:40,050
so here's the entry for the system call

00:39:35,580 --> 00:39:42,060
so you do SWI entry so you also have to

00:39:40,050 --> 00:39:44,880
tell the the process of where the vector

00:39:42,060 --> 00:39:48,150
table is found so there's a few options

00:39:44,880 --> 00:39:51,310
the lo vector location is 0 the hi

00:39:48,150 --> 00:39:53,590
vectors location is here and the

00:39:51,310 --> 00:39:57,070
you'll use the system control registers

00:39:53,590 --> 00:39:58,480
be bit to determine this another option

00:39:57,070 --> 00:39:59,950
is to use the vector-based address

00:39:58,480 --> 00:40:02,920
register that allows you to put the

00:39:59,950 --> 00:40:04,930
vector table at an arbitrary address so

00:40:02,920 --> 00:40:07,390
here is FreeBSD exception setup code

00:40:04,930 --> 00:40:09,880
it's in init arm so it'll allocate

00:40:07,390 --> 00:40:12,550
stacks for each of the the modes that we

00:40:09,880 --> 00:40:14,080
saw earlier so irq abort undefined and

00:40:12,550 --> 00:40:16,870
this is the the kernel stack that's used

00:40:14,080 --> 00:40:18,730
for SDC mode this function will go in

00:40:16,870 --> 00:40:19,600
and modify all this banked registers

00:40:18,730 --> 00:40:22,030
that I talked about for the stack

00:40:19,600 --> 00:40:25,680
pointer and FreeBSD uses the vectors

00:40:22,030 --> 00:40:27,820
high location so the 0xff address

00:40:25,680 --> 00:40:31,870
okay so we'll briefly go over a

00:40:27,820 --> 00:40:33,370
developing PSTN arm so PC has really

00:40:31,870 --> 00:40:35,200
great cross-compilation support you can

00:40:33,370 --> 00:40:37,540
cross build the entire systems so it'll

00:40:35,200 --> 00:40:40,200
build you boot the kernel the tool chain

00:40:37,540 --> 00:40:44,710
libraries usually and all that stuff

00:40:40,200 --> 00:40:46,390
then you can also create a bootable SD

00:40:44,710 --> 00:40:49,030
images really easily just with one

00:40:46,390 --> 00:40:52,710
command so on freebsd will use crochet

00:40:49,030 --> 00:40:56,200
for that on a PC you'll use a build sh

00:40:52,710 --> 00:40:58,270
so this is actually pretty convenient if

00:40:56,200 --> 00:40:59,830
you're doing a lot of development you'll

00:40:58,270 --> 00:41:02,050
probably want to set up net booting so

00:40:59,830 --> 00:41:03,610
you can TFTP boot the kernel and NFS

00:41:02,050 --> 00:41:05,230
mount the root filesystem this will

00:41:03,610 --> 00:41:09,130
really shorten your development cycle

00:41:05,230 --> 00:41:11,380
and if you don't feel like booting

00:41:09,130 --> 00:41:14,830
making your own image you can grab one

00:41:11,380 --> 00:41:16,870
from the net pc and freebsd websites so

00:41:14,830 --> 00:41:18,010
debugging via sino arm VST and arm a lot

00:41:16,870 --> 00:41:21,460
of stuff you'll be doing is printf

00:41:18,010 --> 00:41:22,900
debugging you boot sets up the serial

00:41:21,460 --> 00:41:25,120
for you and if you want early debug

00:41:22,900 --> 00:41:28,300
output you can set verbose init arm on

00:41:25,120 --> 00:41:31,510
neppy SDA or turned debug on in freebsd

00:41:28,300 --> 00:41:33,850
you on Nepean previously respectively

00:41:31,510 --> 00:41:35,860
JTAG debuggers are handy some are

00:41:33,850 --> 00:41:38,680
relatively inexpensive the flyswatter is

00:41:35,860 --> 00:41:40,480
one and it supports spiegel on black if

00:41:38,680 --> 00:41:42,490
you saw her ahead around there kernel

00:41:40,480 --> 00:41:43,990
debugger is are useful q is also really

00:41:42,490 --> 00:41:46,570
useful so you can hack an arm without

00:41:43,990 --> 00:41:50,230
actually having any hardware there's a

00:41:46,570 --> 00:41:52,540
lot of useful talks I won't actually go

00:41:50,230 --> 00:41:54,400
into all of them but in the interest of

00:41:52,540 --> 00:41:55,750
time so the freebsd on people in black

00:41:54,400 --> 00:41:57,940
is a really good talk it was in the

00:41:55,750 --> 00:41:59,560
first edition the freebsd journal you

00:41:57,940 --> 00:42:01,960
should definitely check that out and

00:41:59,560 --> 00:42:03,490
then this talk how freebsd boots the

00:42:01,960 --> 00:42:05,319
self decorum IPPs perspective is really

00:42:03,490 --> 00:42:07,789
good it goes into all of the image

00:42:05,319 --> 00:42:10,359
including machine-dependent stuff this

00:42:07,789 --> 00:42:14,180
new PC talk is good for learning about

00:42:10,359 --> 00:42:16,490
SOC modern ssese and then this stuff's

00:42:14,180 --> 00:42:18,440
good for learning about booting and this

00:42:16,490 --> 00:42:20,900
guy they're reporting an MPC guide us

00:42:18,440 --> 00:42:22,670
guide on the net BST website and that's

00:42:20,900 --> 00:42:23,839
pretty uh it's it's a little dated but

00:42:22,670 --> 00:42:25,760
it's probably the most complete

00:42:23,839 --> 00:42:29,569
information on how to get it as to see

00:42:25,760 --> 00:42:31,970
up okay so in summary we discussed the

00:42:29,569 --> 00:42:33,230
basics of the the ARM architecture what

00:42:31,970 --> 00:42:35,119
the instructions that looks like where

00:42:33,230 --> 00:42:36,470
to go to get more documentation we

00:42:35,119 --> 00:42:40,369
looked at some of the machine dependent

00:42:36,470 --> 00:42:43,819
BSD code looking at FreeBSD and FEC and

00:42:40,369 --> 00:42:46,400
they showed a few tips on how to do some

00:42:43,819 --> 00:42:48,619
debugging on and set up your development

00:42:46,400 --> 00:42:50,450
environment on arm and then all those

00:42:48,619 --> 00:42:51,950
talks are really good also the freebie C

00:42:50,450 --> 00:42:53,599
and F PC developers have a lot of really

00:42:51,950 --> 00:42:56,569
good blogs that are really informative

00:42:53,599 --> 00:42:58,099
so you can type if you type them a term

00:42:56,569 --> 00:42:59,390
into Google probably one of theirs one

00:42:58,099 --> 00:43:01,730
of their guides one of their blog posts

00:42:59,390 --> 00:43:04,520
all pop-up is really useful when I was

00:43:01,730 --> 00:43:06,440
getting up to speed so I'm hoping I've

00:43:04,520 --> 00:43:09,170
kind of so I present a lot of

00:43:06,440 --> 00:43:10,640
information and I gave you a lot of

00:43:09,170 --> 00:43:14,809
resources that you're gonna check out

00:43:10,640 --> 00:43:16,640
but uh so I'm hoping that I've given you

00:43:14,809 --> 00:43:18,920
at least the inclination to maybe grab a

00:43:16,640 --> 00:43:20,779
BSD and start hacking so there's a lot

00:43:18,920 --> 00:43:22,789
of cool hardware out there so grab a BSD

00:43:20,779 --> 00:43:24,020
install it and then start hacking you

00:43:22,789 --> 00:43:25,309
can there's a lot of things you can do

00:43:24,020 --> 00:43:27,020
there's a lot of new hardware coming out

00:43:25,309 --> 00:43:28,849
you can pour to a new board you can add

00:43:27,020 --> 00:43:32,079
drivers you can fix bugs you can

00:43:28,849 --> 00:43:34,339
optimize code so I'm hoping you'll least

00:43:32,079 --> 00:43:35,779
grab one of these boards and do a little

00:43:34,339 --> 00:43:39,230
bit of hacking or at least think about

00:43:35,779 --> 00:43:40,400
it so I'll be around you can definitely

00:43:39,230 --> 00:43:43,279
come up and talk to me if you wanna talk

00:43:40,400 --> 00:43:47,170
about arm and here's my email address

00:43:43,279 --> 00:43:47,170
and I'm happy to take maybe a question

00:43:49,780 --> 00:44:12,760
thanks.thanks our own any questions hi

00:44:09,690 --> 00:44:14,530
you mentioned the device three support

00:44:12,760 --> 00:44:18,370
hmm

00:44:14,530 --> 00:44:22,660
is there any chance to waive the the

00:44:18,370 --> 00:44:25,630
same device three definition used by

00:44:22,660 --> 00:44:27,060
Linux on BSD or so that's kind of a

00:44:25,630 --> 00:44:29,170
complicated question I I'm probably not

00:44:27,060 --> 00:44:31,570
capable to answer that so the problem

00:44:29,170 --> 00:44:34,540
the previous the the device free stuff

00:44:31,570 --> 00:44:36,130
is that it's a be it's GPL die think so

00:44:34,540 --> 00:44:38,250
I talked to grant likely one of the

00:44:36,130 --> 00:44:41,260
Linux kernel developers a while ago a

00:44:38,250 --> 00:44:43,210
long time ago and he seemed interested

00:44:41,260 --> 00:44:45,610
maybe like switching that stuff over to

00:44:43,210 --> 00:44:47,320
BST licensing so maybe it's possible but

00:44:45,610 --> 00:44:50,140
I don't actually know so someone from

00:44:47,320 --> 00:44:51,820
the like someone official from FreeBSD

00:44:50,140 --> 00:44:53,320
would probably have to go talk to the

00:44:51,820 --> 00:44:55,830
Linux guys to see that happen but that

00:44:53,320 --> 00:44:55,830
would be great actually

00:44:59,320 --> 00:45:04,810
problem like naming the didn't the

00:45:02,290 --> 00:45:08,350
naming of the property or something like

00:45:04,810 --> 00:45:10,570
this is it doing in a compatible way or

00:45:08,350 --> 00:45:14,560
yeah I don't actually know yeah so I

00:45:10,570 --> 00:45:16,120
mean I think some people I think I think

00:45:14,560 --> 00:45:18,100
they may be starting to use some of the

00:45:16,120 --> 00:45:20,800
Linux device tree I don't really know

00:45:18,100 --> 00:45:22,720
actually so I think if you asked him

00:45:20,800 --> 00:45:24,220
previously arm they'll probably know ian

00:45:22,720 --> 00:45:25,720
Lepore probably would be the guy to talk

00:45:24,220 --> 00:45:28,300
to you about that stuff there's a lot of

00:45:25,720 --> 00:45:30,100
stuff okay thank you so I don't know

00:45:28,300 --> 00:45:31,090
enough about that unfortunately but it

00:45:30,100 --> 00:45:32,230
would be great if we could use the same

00:45:31,090 --> 00:45:36,840
device to use and it would be great if

00:45:32,230 --> 00:45:36,840
they're BSD licensed thanks

00:45:45,070 --> 00:45:53,510
and just a small comment if you part to

00:45:50,780 --> 00:45:57,080
your own but make sure to set the

00:45:53,510 --> 00:45:59,390
alignment flex very very early otherwise

00:45:57,080 --> 00:46:03,020
you can get some interesting surprises

00:45:59,390 --> 00:46:10,190
from C code that's that's a good comment

00:46:03,020 --> 00:46:12,800
I got the question about what you say

00:46:10,190 --> 00:46:14,450
the the reboot you say you use the

00:46:12,800 --> 00:46:16,790
identity mapping for virtual address

00:46:14,450 --> 00:46:18,740
equal physical address is it only for

00:46:16,790 --> 00:46:20,690
the early stage yeah it's just for the

00:46:18,740 --> 00:46:22,820
early stage okay and then you would you

00:46:20,690 --> 00:46:24,770
do you map the kill you map your data

00:46:22,820 --> 00:46:26,750
and your hi addresses

00:46:24,770 --> 00:46:28,460
okay like one gigabyte per gigabyte

00:46:26,750 --> 00:46:30,380
separation yeah I forget the exact

00:46:28,460 --> 00:46:38,120
details but yeah something I got okay

00:46:30,380 --> 00:46:40,130
thanks other questions cool it's a lot

00:46:38,120 --> 00:46:42,849
preciate enough

00:46:40,130 --> 00:46:42,849

YouTube URL: https://www.youtube.com/watch?v=4gRKA7xoGJ8


