Title: The entropic principle: dev u?random and NetBSD - Taylor R Campbell
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

Programs that talk over the internet today require unpredictable secrets to thwart passive eavesdroppers and active men-in-the-middle.Unix folklore teaches that programs must acquire these secrets from a beast called `entropy’ in the pantheon of information theory, who lives in /dev/random, and that in neighbouring /dev/urandom lives only a false idol. The truth, however, is not so mystical.I will discuss what /dev/random and /dev/urandom actually mean, what applications actually need, and how they should attain it. I will also discuss the implementation of /dev/u?random in NetBSD and the kernel’s cryptographic pseudorandom number generation API.

Speaker biography:

Taylor `Riastradh’ Campbell is not a cryptographer, but has spent enough time scrutinizing crypto in the software he relies on to notice when it’s done wrong. In 2011, Taylor found what may be Colin Percival’s most embarrassing bug when he noticed the two missing characters `++’ to increment the AES-CTR nonce in Tarsnap leading to reused — and thereby decidedly predictable — key streams. Taylor became afflicted with a NetBSD commit bit later in 2011 for unrelated reasons, and has since participated in rototilling the NetBSD kernel entropy subsystem.
Captions: 
	00:00:00,199 --> 00:00:06,150
everybody I'd like to introduce you to

00:00:03,659 --> 00:00:08,670
Taylor Kemper Taylor what one of the few

00:00:06,150 --> 00:00:11,190
people who sent multiple pretty good

00:00:08,670 --> 00:00:13,170
talks address sense to the program

00:00:11,190 --> 00:00:18,420
committee and who you randomly selected

00:00:13,170 --> 00:00:21,689
this one but how did you randomly select

00:00:18,420 --> 00:00:24,210
him there welcome to the entropic

00:00:21,689 --> 00:00:27,240
principle about dev random and dev you

00:00:24,210 --> 00:00:29,099
random I don't actually know of a

00:00:27,240 --> 00:00:30,720
concept called the entropic principle I

00:00:29,099 --> 00:00:37,020
just thought it sounded funny when I was

00:00:30,720 --> 00:00:38,730
thinking of a title so I'd like to start

00:00:37,020 --> 00:00:42,590
by saying if you don't take anything

00:00:38,730 --> 00:00:44,760
else away from this talk just know that

00:00:42,590 --> 00:00:48,210
when you're writing an application and

00:00:44,760 --> 00:00:50,820
you need to make a random choice used a

00:00:48,210 --> 00:00:53,969
few random it's a safe thing to do it'll

00:00:50,820 --> 00:00:56,850
work anywhere and even though you might

00:00:53,969 --> 00:00:59,760
have this notion that it is it is only a

00:00:56,850 --> 00:01:02,190
a false idol of randomness or it's only

00:00:59,760 --> 00:01:05,519
pseudo-random not really random that's

00:01:02,190 --> 00:01:07,460
actually not really right it's it's it

00:01:05,519 --> 00:01:10,890
it'll work

00:01:07,460 --> 00:01:13,920
so dev random and W random our device

00:01:10,890 --> 00:01:16,590
nodes on pretty much any modern UNIX

00:01:13,920 --> 00:01:18,420
system they have the property that when

00:01:16,590 --> 00:01:20,369
you read anything from them when you

00:01:18,420 --> 00:01:22,380
read a byte from them

00:01:20,369 --> 00:01:27,030
nobody can predict other than the kernel

00:01:22,380 --> 00:01:29,880
what that byte you'll read is they also

00:01:27,030 --> 00:01:32,880
have the property that you can influence

00:01:29,880 --> 00:01:34,409
what future reads will yield by writing

00:01:32,880 --> 00:01:37,740
to them but I'll get to that later about

00:01:34,409 --> 00:01:40,229
entropy sources now they're different in

00:01:37,740 --> 00:01:43,020
that when you read from to have a random

00:01:40,229 --> 00:01:47,130
rather than to have you random they've

00:01:43,020 --> 00:01:49,079
renewables sometimes block now the usual

00:01:47,130 --> 00:01:50,460
explanation of what's going on there is

00:01:49,079 --> 00:01:52,140
that there's something about information

00:01:50,460 --> 00:01:56,090
theory and real random in us versus

00:01:52,140 --> 00:01:58,259
pseudo randomness and stuff but really

00:01:56,090 --> 00:02:00,030
the real difference is that dev random

00:01:58,259 --> 00:02:04,320
sometimes blocks and devil you random

00:02:00,030 --> 00:02:06,750
never blocks and there is a no shortage

00:02:04,320 --> 00:02:08,970
of very confused verbiage on the

00:02:06,750 --> 00:02:10,739
internet about what the nature of the

00:02:08,970 --> 00:02:12,300
difference is but that's the the real

00:02:10,739 --> 00:02:13,099
difference is dev random blocks W random

00:02:12,300 --> 00:02:15,959
doesn't

00:02:13,099 --> 00:02:17,579
so why does it matter that it'd be

00:02:15,959 --> 00:02:18,750
unpredictable well there are bad guys on

00:02:17,579 --> 00:02:21,930
the internet when you're writing any

00:02:18,750 --> 00:02:23,549
sort of engineering system that talks to

00:02:21,930 --> 00:02:27,989
the internet it is your responsibility

00:02:23,549 --> 00:02:29,970
to make sure that people don't even your

00:02:27,989 --> 00:02:32,010
conversations and they don't intercept

00:02:29,970 --> 00:02:33,450
your conversations and they will because

00:02:32,010 --> 00:02:34,379
there are there are there people like

00:02:33,450 --> 00:02:36,209
him mmm

00:02:34,379 --> 00:02:39,379
this this character mr. James clapper

00:02:36,209 --> 00:02:41,670
well he doesn't do it personally but

00:02:39,379 --> 00:02:45,060
there's lots of nasty stuff on the

00:02:41,670 --> 00:02:48,450
internet and I we need crypto in order

00:02:45,060 --> 00:02:50,670
to avoid the nasty stuff and in order

00:02:48,450 --> 00:02:52,950
for crypto to work the parties involved

00:02:50,670 --> 00:02:54,900
in communicating over the Internet need

00:02:52,950 --> 00:02:56,790
to have secrets that the bad guys cannot

00:02:54,900 --> 00:03:01,530
predict if the bad guys can can predict

00:02:56,790 --> 00:03:05,250
the secrets the crypto doesn't work here

00:03:01,530 --> 00:03:09,720
are some examples of where people used

00:03:05,250 --> 00:03:13,939
crypto and failed to make sure that the

00:03:09,720 --> 00:03:16,500
secrets were actually unpredictable the

00:03:13,939 --> 00:03:18,720
there's a time when you used national

00:03:16,500 --> 00:03:21,269
identity database and it used a bunch of

00:03:18,720 --> 00:03:22,889
RSA keys that were generated by smart

00:03:21,269 --> 00:03:25,260
cards that were all thoroughly certified

00:03:22,889 --> 00:03:27,299
except that well actually the

00:03:25,260 --> 00:03:28,859
certification process didn't make sure

00:03:27,299 --> 00:03:31,139
that the rent number generator actually

00:03:28,859 --> 00:03:32,010
worked so a lot of the RSA keys had a

00:03:31,139 --> 00:03:38,489
factors in common

00:03:32,010 --> 00:03:41,790
oops Sony used in signature scheme for

00:03:38,489 --> 00:03:43,109
assigning firmware updates only they

00:03:41,790 --> 00:03:45,900
screwed up the use of the signature

00:03:43,109 --> 00:03:48,889
scheme so that they accidentally

00:03:45,900 --> 00:03:52,680
revealed the signing key to the world

00:03:48,889 --> 00:03:55,229
and so anybody could sign PlayStation

00:03:52,680 --> 00:03:58,109
firmware updates similar to the e

00:03:55,229 --> 00:03:59,579
Taiwanese national unity database there

00:03:58,109 --> 00:04:02,250
was a project which you may have heard

00:03:59,579 --> 00:04:05,280
about factor botnet um just surveying

00:04:02,250 --> 00:04:07,680
machines on the internet with TLS as a

00:04:05,280 --> 00:04:10,650
cell servers and found that a lot of

00:04:07,680 --> 00:04:14,459
them had secrets that were entirely

00:04:10,650 --> 00:04:18,570
predictable and when the NSA mmm

00:04:14,459 --> 00:04:21,750
allegedly chose to put a backdoor into a

00:04:18,570 --> 00:04:24,960
major US government crypto standard they

00:04:21,750 --> 00:04:26,090
chose allegedly the random number

00:04:24,960 --> 00:04:28,700
generator so

00:04:26,090 --> 00:04:33,169
this is obviously a very important part

00:04:28,700 --> 00:04:37,070
of eavesdropping an interception now

00:04:33,169 --> 00:04:41,930
whenever we're talking about a security

00:04:37,070 --> 00:04:43,550
system in order to avoid the sort of

00:04:41,930 --> 00:04:45,350
Voodoo that you encounter in discussions

00:04:43,550 --> 00:04:48,050
of lots of discussions of dev random and

00:04:45,350 --> 00:04:49,610
W random you have to have a an

00:04:48,050 --> 00:04:51,410
application in mind what are you trying

00:04:49,610 --> 00:04:53,570
to accomplish with this system you have

00:04:51,410 --> 00:04:56,540
to have a threat model who is trying to

00:04:53,570 --> 00:04:58,190
screw you up and you have to have a set

00:04:56,540 --> 00:04:59,300
of intended security properties what are

00:04:58,190 --> 00:05:03,919
you trying to make sure the bad guys

00:04:59,300 --> 00:05:07,760
can't do so in this case we are trying

00:05:03,919 --> 00:05:11,090
to just generate bits with uniform

00:05:07,760 --> 00:05:13,490
random distribution there are several

00:05:11,090 --> 00:05:17,030
possible threat models who I consider a

00:05:13,490 --> 00:05:20,030
very easy one is that the attacker might

00:05:17,030 --> 00:05:23,630
be reading from dev random or dev u

00:05:20,030 --> 00:05:25,250
random on the same machine now maybe not

00:05:23,630 --> 00:05:29,630
by running a process on that machine but

00:05:25,250 --> 00:05:31,789
maybe by looking at the TLS packets on

00:05:29,630 --> 00:05:33,950
some other conversation which reveals

00:05:31,789 --> 00:05:37,900
some output that's usually directly from

00:05:33,950 --> 00:05:39,770
the applications that are a generator

00:05:37,900 --> 00:05:41,510
another threat model is that the

00:05:39,770 --> 00:05:44,810
attacker may try to influence Devi or

00:05:41,510 --> 00:05:47,210
random by feeding in by feeding an

00:05:44,810 --> 00:05:49,250
entropy from either by like banging on

00:05:47,210 --> 00:05:51,200
your own keyboard or by sending Network

00:05:49,250 --> 00:05:54,880
packet timings which are where there's

00:05:51,200 --> 00:05:58,789
two places where the operating system

00:05:54,880 --> 00:06:01,280
tries to derive some of its random

00:05:58,789 --> 00:06:03,800
decisions another possible threat model

00:06:01,280 --> 00:06:07,190
is the attacker can totally compromise

00:06:03,800 --> 00:06:09,370
your machine and get at the totally a

00:06:07,190 --> 00:06:14,539
complete internal state of kernel memory

00:06:09,370 --> 00:06:16,310
now this is not a threat model that you

00:06:14,539 --> 00:06:19,490
can do all that much about but there is

00:06:16,310 --> 00:06:23,470
one thing that that we that we can

00:06:19,490 --> 00:06:25,880
defend against with that which is about

00:06:23,470 --> 00:06:27,650
making sure that if you have generated a

00:06:25,880 --> 00:06:30,800
key from dev random our W random in the

00:06:27,650 --> 00:06:32,960
past and somebody later compromises your

00:06:30,800 --> 00:06:36,710
machine you want to make sure that they

00:06:32,960 --> 00:06:38,000
still can't predict what your key was so

00:06:36,710 --> 00:06:41,530
these are three different threat models

00:06:38,000 --> 00:06:41,530
that are relevant in

00:06:41,600 --> 00:06:45,990
in in discussion discussion of dev

00:06:44,130 --> 00:06:47,520
random interview random and anytime that

00:06:45,990 --> 00:06:48,570
you're worried about the security

00:06:47,520 --> 00:06:50,040
properties you need to consider the

00:06:48,570 --> 00:06:52,139
threat models that the properties are

00:06:50,040 --> 00:06:55,139
relative to so I want to make sure that

00:06:52,139 --> 00:06:56,820
whatever the attacker is they shouldn't

00:06:55,139 --> 00:06:58,530
be able to predict any output from dev

00:06:56,820 --> 00:07:01,590
random or W random that they haven't

00:06:58,530 --> 00:07:03,419
seen before now if they get the total

00:07:01,590 --> 00:07:05,220
internal state they can predict future

00:07:03,419 --> 00:07:07,040
outputs because if your machine is

00:07:05,220 --> 00:07:09,990
rooted then you're hosed in the future

00:07:07,040 --> 00:07:11,220
but they shouldn't be able to create any

00:07:09,990 --> 00:07:14,960
past ones they should be able to figure

00:07:11,220 --> 00:07:14,960
out what PGP key you generated last week

00:07:15,620 --> 00:07:22,470
so in order to I discuss what

00:07:20,669 --> 00:07:24,360
unpredictable to an attacker means we

00:07:22,470 --> 00:07:26,790
have to have some formalization of

00:07:24,360 --> 00:07:28,740
unpredictability and we're gonna use the

00:07:26,790 --> 00:07:30,570
language of probability theory very

00:07:28,740 --> 00:07:33,000
briefly in just a couple of slides to

00:07:30,570 --> 00:07:35,789
talk about that so a random variable is

00:07:33,000 --> 00:07:37,710
just a model for a physical system that

00:07:35,789 --> 00:07:39,120
you can imagine observing and you can

00:07:37,710 --> 00:07:41,220
imagine it taking on some particular

00:07:39,120 --> 00:07:45,270
value say little x0 a little x1 whatever

00:07:41,220 --> 00:07:46,260
now and we have a probability theory

00:07:45,270 --> 00:07:48,360
notation for writing what the

00:07:46,260 --> 00:07:50,039
probability of observing one particular

00:07:48,360 --> 00:07:53,729
value of this random variable at this

00:07:50,039 --> 00:07:56,729
physical system is now given a random

00:07:53,729 --> 00:07:58,680
variable we need some way to measure how

00:07:56,729 --> 00:08:00,030
unpredictable it is because random

00:07:58,680 --> 00:08:02,130
variable here just means that there is

00:08:00,030 --> 00:08:04,710
some level of uncertainty in what you

00:08:02,130 --> 00:08:06,539
might observe but doesn't mean anything

00:08:04,710 --> 00:08:12,450
beyond that doesn't mean uniform random

00:08:06,539 --> 00:08:14,639
for example so the usual popular

00:08:12,450 --> 00:08:17,160
approach of measuring how unpredictable

00:08:14,639 --> 00:08:19,200
a physical observation of physical

00:08:17,160 --> 00:08:21,570
system a random variable is is Shannon

00:08:19,200 --> 00:08:23,610
entropy and you've probably heard of

00:08:21,570 --> 00:08:25,080
information theory and entropy in the

00:08:23,610 --> 00:08:29,130
past and this is the formal definition

00:08:25,080 --> 00:08:32,430
of it roughly it gives the if you have

00:08:29,130 --> 00:08:35,279
in a physical system that has some

00:08:32,430 --> 00:08:36,870
number of bits of information literally

00:08:35,279 --> 00:08:39,900
like you thought you have you consider

00:08:36,870 --> 00:08:41,640
maybe a pair of coin flips that has two

00:08:39,900 --> 00:08:48,180
bits of information well two bits of

00:08:41,640 --> 00:08:49,950
output literally but if the probability

00:08:48,180 --> 00:08:52,140
of if for some reason you're gonna flip

00:08:49,950 --> 00:08:53,370
always heads for both of them or always

00:08:52,140 --> 00:08:55,020
tails for both of them

00:08:53,370 --> 00:08:56,700
and you're never gonna flip heads for

00:08:55,020 --> 00:08:59,940
one and tails for the other or tails for

00:08:56,700 --> 00:09:02,730
one heads for the other then the entropy

00:08:59,940 --> 00:09:07,440
in this physical process of flipping two

00:09:02,730 --> 00:09:09,710
coins is only one bit of actual entropy

00:09:07,440 --> 00:09:12,660
per bits of the random variable so the

00:09:09,710 --> 00:09:17,880
the rate of information is one half bit

00:09:12,660 --> 00:09:18,750
of entropy per bit of output so that's

00:09:17,880 --> 00:09:20,400
the popular thing that you will

00:09:18,750 --> 00:09:23,220
encounter in the information theory and

00:09:20,400 --> 00:09:25,080
especially in coding theory and tyskie

00:09:23,220 --> 00:09:26,670
discussing you know Cara correcting

00:09:25,080 --> 00:09:29,700
codes and communication channels and

00:09:26,670 --> 00:09:34,290
whatnot but it's actually not terribly

00:09:29,700 --> 00:09:36,780
useful for crypto because if we have

00:09:34,290 --> 00:09:39,740
some random variable big X say and there

00:09:36,780 --> 00:09:42,240
are a lot of possibility possible

00:09:39,740 --> 00:09:45,620
observations for what X is and let's say

00:09:42,240 --> 00:09:47,670
maybe X is your choice of password and

00:09:45,620 --> 00:09:50,610
half the time you choose the password

00:09:47,670 --> 00:09:51,840
hunter to but all of the times you

00:09:50,610 --> 00:09:54,900
choose uniformly at random from the

00:09:51,840 --> 00:09:57,870
other possibilities the Shannon entropy

00:09:54,900 --> 00:09:59,040
makes it look like there's there's it

00:09:57,870 --> 00:10:01,290
looks like there's a lot of entropy in

00:09:59,040 --> 00:10:03,150
here that is it looks like there's if I

00:10:01,290 --> 00:10:06,060
wanted to if I as an attacker wanted to

00:10:03,150 --> 00:10:08,970
exhaustively search the possibilities to

00:10:06,060 --> 00:10:10,050
looking for your password if I have some

00:10:08,970 --> 00:10:12,510
way to check through whether your

00:10:10,050 --> 00:10:14,610
whether my guess is correct Shannon

00:10:12,510 --> 00:10:19,290
entropy says that should take a long

00:10:14,610 --> 00:10:20,910
time right because if there are well you

00:10:19,290 --> 00:10:22,920
know you know if there are 2 to the

00:10:20,910 --> 00:10:24,240
128th possibilities then you have to

00:10:22,920 --> 00:10:29,400
search what half of those before you get

00:10:24,240 --> 00:10:31,650
to get the right one on average but in

00:10:29,400 --> 00:10:33,630
this case I have a pretty good guess

00:10:31,650 --> 00:10:35,940
what your password is if this is the

00:10:33,630 --> 00:10:37,110
model that I have and this is how you

00:10:35,940 --> 00:10:39,000
know password Packers like John the

00:10:37,110 --> 00:10:40,560
Ripper work they have a you know the

00:10:39,000 --> 00:10:42,360
passwords are not chosen uniformly at

00:10:40,560 --> 00:10:43,770
random and John the Ripper will guests

00:10:42,360 --> 00:10:46,080
gonna guess password first I think as

00:10:43,770 --> 00:10:50,160
password 1 2 3 next probably and hunter

00:10:46,080 --> 00:10:51,900
2 is probably pretty high up there so

00:10:50,160 --> 00:10:55,100
instead in crypto we use a concept

00:10:51,900 --> 00:10:57,690
called min entropy which is a measure of

00:10:55,100 --> 00:11:02,510
sort of the worst case here rather than

00:10:57,690 --> 00:11:04,530
the average case so in in in the case of

00:11:02,510 --> 00:11:07,560
half the time you're passed with hunter

00:11:04,530 --> 00:11:09,270
2 and all the rest of the cases it's you

00:11:07,560 --> 00:11:11,490
know each possibility has very low

00:11:09,270 --> 00:11:14,340
probability the min entropy of that is

00:11:11,490 --> 00:11:16,890
going to be 1/2 and there are there's

00:11:14,340 --> 00:11:20,130
gonna be one there's only one bit of min

00:11:16,890 --> 00:11:23,400
entropy there which is means it's very

00:11:20,130 --> 00:11:24,390
predictable now if we're looking at a

00:11:23,400 --> 00:11:25,590
random variable with uniform

00:11:24,390 --> 00:11:28,770
distribution that is every possibility

00:11:25,590 --> 00:11:31,080
has the same probability for example a

00:11:28,770 --> 00:11:33,810
nice unbiased coin where the heads and

00:11:31,080 --> 00:11:37,650
tails both have 1/2 probability then the

00:11:33,810 --> 00:11:40,290
min entropy is just the number of bits

00:11:37,650 --> 00:11:42,300
in the possible outcome so if you if you

00:11:40,290 --> 00:11:44,340
have you know if one bit outcome in the

00:11:42,300 --> 00:11:46,680
monography of that is gonna be 1 if you

00:11:44,340 --> 00:11:48,600
have 128-bit string if you're drunk

00:11:46,680 --> 00:11:49,950
randomly from those and with uniform

00:11:48,600 --> 00:11:54,020
distribution then the min entropy of

00:11:49,950 --> 00:11:57,510
that is going to be 128 and in crypto

00:11:54,020 --> 00:12:01,470
the standard practice is to use if

00:11:57,510 --> 00:12:04,170
you're you know if you're making a very

00:12:01,470 --> 00:12:05,610
weak system maybe 80 bits but usually at

00:12:04,170 --> 00:12:07,050
least hundred twenty eight or if you're

00:12:05,610 --> 00:12:09,270
a little more paranoid or worried about

00:12:07,050 --> 00:12:14,610
quantum computing then turn to physics

00:12:09,270 --> 00:12:18,810
bits of min entropy okay so the kernels

00:12:14,610 --> 00:12:23,790
job with a dev random and W random is to

00:12:18,810 --> 00:12:26,370
make reading K bits from the device that

00:12:23,790 --> 00:12:28,050
is the physical process of reading K

00:12:26,370 --> 00:12:29,520
bits from the device that that should

00:12:28,050 --> 00:12:33,060
that should if you modeled in random

00:12:29,520 --> 00:12:36,330
variable have K bits of entropy so it is

00:12:33,060 --> 00:12:38,310
it is it's supposed to be very hard for

00:12:36,330 --> 00:12:40,200
an attacker to predict what the bits are

00:12:38,310 --> 00:12:42,240
and if you draw you know one bit then

00:12:40,200 --> 00:12:43,950
it's well the attacker has a 50/50

00:12:42,240 --> 00:12:46,170
chance I'm guessing right if you draw

00:12:43,950 --> 00:12:50,600
128 bits the attacker has a very very

00:12:46,170 --> 00:12:54,180
very small chance of guessing right now

00:12:50,600 --> 00:12:55,590
how does the kernel choose which bits to

00:12:54,180 --> 00:12:57,900
produce of course if the kernel is a

00:12:55,590 --> 00:12:59,910
nice single threaded computer program

00:12:57,900 --> 00:13:02,640
then it should be deterministic but

00:12:59,910 --> 00:13:06,800
kernels have access to physical devices

00:13:02,640 --> 00:13:11,030
of course and they make various non

00:13:06,800 --> 00:13:12,930
deterministic observations of the

00:13:11,030 --> 00:13:15,570
physical devices that are attached to

00:13:12,930 --> 00:13:16,529
them for example the computers really

00:13:15,570 --> 00:13:18,899
have more than one clock

00:13:16,529 --> 00:13:21,719
and two clocks are never quite

00:13:18,899 --> 00:13:25,079
synchronized right so if you look at the

00:13:21,719 --> 00:13:26,489
skew between the two clocks that may be

00:13:25,079 --> 00:13:27,659
a little bit harder you know a little

00:13:26,489 --> 00:13:30,269
hard to predict if you're not actually

00:13:27,659 --> 00:13:31,679
observing the Fox or cell so if if you

00:13:30,269 --> 00:13:34,409
are an attacker on the other end of the

00:13:31,679 --> 00:13:37,919
ethernet cable it may be hard if you to

00:13:34,409 --> 00:13:40,739
observe the two oscillators inside the

00:13:37,919 --> 00:13:42,269
computer you're trying to attack other

00:13:40,739 --> 00:13:45,149
possibilities are the timings of network

00:13:42,269 --> 00:13:47,339
packets or keyword input you know what

00:13:45,149 --> 00:13:49,769
how far apart my keystrokes are and

00:13:47,339 --> 00:13:52,139
which keys I'm hitting so if you run GPG

00:13:49,769 --> 00:13:53,909
- genki to produce a new key it'll print

00:13:52,139 --> 00:13:56,999
out a message kind of like this well not

00:13:53,909 --> 00:13:58,469
literally this but um asking you to bang

00:13:56,999 --> 00:14:00,799
on the keyboard like a monkey until it

00:13:58,469 --> 00:14:05,999
has enough entropy to generate the key

00:14:00,799 --> 00:14:08,969
so all of these devices that the kernel

00:14:05,999 --> 00:14:10,259
observes are themselves random variables

00:14:08,969 --> 00:14:14,459
but they don't have nice uniform

00:14:10,259 --> 00:14:16,679
distribution the spacing between my

00:14:14,459 --> 00:14:18,419
keystrokes is very much non-uniform

00:14:16,679 --> 00:14:21,119
right now I am NOT typing any keys at

00:14:18,419 --> 00:14:22,649
all so there's a very long gap but if I

00:14:21,119 --> 00:14:24,149
were to go and type the URL to this

00:14:22,649 --> 00:14:25,769
presentation then there would be a bunch

00:14:24,149 --> 00:14:30,289
of very short caps so it's not it's not

00:14:25,769 --> 00:14:34,589
uniform at all and sometimes these

00:14:30,289 --> 00:14:35,519
sources of entropy are under the

00:14:34,589 --> 00:14:37,439
influence of attackers

00:14:35,519 --> 00:14:39,299
so if you have a network attacker and

00:14:37,439 --> 00:14:42,929
you're using the timing between network

00:14:39,299 --> 00:14:44,819
packets as a source of entropy as a

00:14:42,929 --> 00:14:46,979
source of unpredictability for dev

00:14:44,819 --> 00:14:48,569
random on your system then well maybe

00:14:46,979 --> 00:14:49,589
the attacker can send packets on very

00:14:48,569 --> 00:14:50,999
regular intervals

00:14:49,589 --> 00:14:54,119
you know maybe every millisecond or

00:14:50,999 --> 00:14:57,109
something or every 10 milliseconds or if

00:14:54,119 --> 00:14:59,549
the attacker is trying to log into yours

00:14:57,109 --> 00:15:01,529
unlock your screen lock maybe your

00:14:59,549 --> 00:15:04,919
attacker can bang on the keyboard very

00:15:01,529 --> 00:15:09,089
robotic Li rather than like a monkey

00:15:04,919 --> 00:15:10,409
and so that yes.well or the or the

00:15:09,089 --> 00:15:12,389
attacker can hold onto the space key

00:15:10,409 --> 00:15:19,709
until the screen Locker crashes but

00:15:12,389 --> 00:15:22,169
that's a separate issue so in order to

00:15:19,709 --> 00:15:23,849
do this the kernel uses some crypto

00:15:22,169 --> 00:15:25,529
magic called an entropy extractor and

00:15:23,849 --> 00:15:28,499
I'm not going to go into the details of

00:15:25,529 --> 00:15:29,920
all the crypto here and so but basically

00:15:28,499 --> 00:15:32,350
it's

00:15:29,920 --> 00:15:34,269
entropy sources into a funnel and mixes

00:15:32,350 --> 00:15:38,019
them around so that they look a lot more

00:15:34,269 --> 00:15:39,820
uniform rather than very non-uniform

00:15:38,019 --> 00:15:42,550
like banging on the keyboard like a

00:15:39,820 --> 00:15:44,019
robot or you know long gaps between

00:15:42,550 --> 00:15:47,890
keystrokes and followed by a very short

00:15:44,019 --> 00:15:50,410
ones and then once the kernel has mixed

00:15:47,890 --> 00:15:52,810
all this into a big funnel and produced

00:15:50,410 --> 00:15:55,149
a little output it will use that as the

00:15:52,810 --> 00:15:56,709
seed for a pseudo-random number

00:15:55,149 --> 00:15:59,740
generator that is a deterministic

00:15:56,709 --> 00:16:03,459
program that expands a short

00:15:59,740 --> 00:16:07,269
unpredictable secret into a very long

00:16:03,459 --> 00:16:10,630
sequence of unpredictable secrets now

00:16:07,269 --> 00:16:12,459
you notice I said this is the case for

00:16:10,630 --> 00:16:13,930
dev random and a view random there's no

00:16:12,459 --> 00:16:17,230
difference between them here it's not

00:16:13,930 --> 00:16:20,860
that dev random usually spits out stuff

00:16:17,230 --> 00:16:24,730
directly from the entropy funnel the

00:16:20,860 --> 00:16:27,089
entry pool here and dev you random makes

00:16:24,730 --> 00:16:29,500
something up and then uses a

00:16:27,089 --> 00:16:31,240
deterministic algorithm to spit out

00:16:29,500 --> 00:16:33,579
results they both go through the same

00:16:31,240 --> 00:16:34,630
suturing on our generator they both go

00:16:33,579 --> 00:16:39,160
to go through the same deterministic

00:16:34,630 --> 00:16:45,640
process seeded by bits from the entropy

00:16:39,160 --> 00:16:47,800
sources now what if you don't have all

00:16:45,640 --> 00:16:49,300
that much entropy what if I've just

00:16:47,800 --> 00:16:50,709
booted out the machine I just hit the

00:16:49,300 --> 00:16:53,140
power button and I haven't typed any

00:16:50,709 --> 00:16:55,630
keystrokes and it's a fresh install of

00:16:53,140 --> 00:17:00,640
my operating system and sshd starts up

00:16:55,630 --> 00:17:03,190
and auto generates keys then well if I

00:17:00,640 --> 00:17:05,079
did this twice there's a good chance I

00:17:03,190 --> 00:17:06,699
would get the same results or at the

00:17:05,079 --> 00:17:08,620
very least there's a fairly small

00:17:06,699 --> 00:17:10,150
collection of results that I might get

00:17:08,620 --> 00:17:15,189
that an attacker couldn't easily cycle

00:17:10,150 --> 00:17:18,040
through similar to the Debian open ssl

00:17:15,189 --> 00:17:23,860
debacle several years ago where the open

00:17:18,040 --> 00:17:25,569
ssl userland PRNG was using a CD that

00:17:23,860 --> 00:17:26,890
was much too small so that there was

00:17:25,569 --> 00:17:32,679
only a very small number of possible

00:17:26,890 --> 00:17:37,950
keys that it would ever produce so this

00:17:32,679 --> 00:17:42,470
would be bad and you want to prevent

00:17:37,950 --> 00:17:45,100
anything from trying to use entropy when

00:17:42,470 --> 00:17:50,029
there when the system is actually

00:17:45,100 --> 00:17:55,250
predictable so how do we prevent this

00:17:50,029 --> 00:17:57,200
well the naive answer is that we wait

00:17:55,250 --> 00:18:00,200
until I have Bank on the keyboard like a

00:17:57,200 --> 00:18:03,080
monkey wait until the disk has started

00:18:00,200 --> 00:18:04,970
spinning and we have observed the heads

00:18:03,080 --> 00:18:07,610
on the disk have taken some time to move

00:18:04,970 --> 00:18:09,259
around and or we've observed some

00:18:07,610 --> 00:18:13,940
network packets and that's enough but

00:18:09,259 --> 00:18:17,149
and and then well so traditionally dev

00:18:13,940 --> 00:18:18,500
random will block until the system has

00:18:17,149 --> 00:18:19,700
determined that enough of these events

00:18:18,500 --> 00:18:21,350
have happened I've banged the keyboard

00:18:19,700 --> 00:18:25,100
like enough of a monkey not enough of a

00:18:21,350 --> 00:18:27,860
robot enough of a monkey or there enough

00:18:25,100 --> 00:18:30,409
Network Packers have come in so

00:18:27,860 --> 00:18:33,590
applications can use dev random as a

00:18:30,409 --> 00:18:37,610
sort of barrier to wait for entropy to

00:18:33,590 --> 00:18:39,289
become available so you could for

00:18:37,610 --> 00:18:41,899
example you could have just an init

00:18:39,289 --> 00:18:44,600
script in your little embedded system

00:18:41,899 --> 00:18:47,059
that reads from dev random before it

00:18:44,600 --> 00:18:49,340
launches anything that needs entropy as

00:18:47,059 --> 00:18:51,889
soon as dev random returns the kernel

00:18:49,340 --> 00:18:55,700
has determined I think that I'm

00:18:51,889 --> 00:19:00,559
unpredictable enough to have you random

00:18:55,700 --> 00:19:02,059
and contrast never blocks so I even if

00:19:00,559 --> 00:19:03,950
you use it early at boot before you bang

00:19:02,059 --> 00:19:05,990
on the keyboard like a monkey it will

00:19:03,950 --> 00:19:11,899
not block it'll just return data that

00:19:05,990 --> 00:19:13,340
well might be actually predictable so

00:19:11,899 --> 00:19:15,799
even if there's been nothing said in the

00:19:13,340 --> 00:19:17,779
gantry pool the kernel will use I mean

00:19:15,799 --> 00:19:22,730
it might be all zeroes as a key you as a

00:19:17,779 --> 00:19:27,279
seed for the P are on gene the trouble

00:19:22,730 --> 00:19:27,279
is with the obligatory Dilbert reference

00:19:27,309 --> 00:19:32,750
you can't actually tell from any

00:19:30,110 --> 00:19:35,929
particular state whether that state is

00:19:32,750 --> 00:19:39,769
unpredictable if I roll it you know d-10

00:19:35,929 --> 00:19:43,309
six times and get nines out as a result

00:19:39,769 --> 00:19:45,980
that's a perfectly valid result even if

00:19:43,309 --> 00:19:47,419
the die is totally fair and you can't

00:19:45,980 --> 00:19:50,019
tell just from looking at the output

00:19:47,419 --> 00:19:52,549
whether I actually rolled the die to

00:19:50,019 --> 00:19:55,030
produce the result or whether I just

00:19:52,549 --> 00:19:57,830
read Dilbert

00:19:55,030 --> 00:20:01,550
what you can do in which Dilbert doesn't

00:19:57,830 --> 00:20:03,860
really addresses is assess whether the

00:20:01,550 --> 00:20:07,040
process that you are using to produce

00:20:03,860 --> 00:20:11,600
the output is unpredictable so if I tell

00:20:07,040 --> 00:20:15,230
you I'm gonna roll a d-10 six times then

00:20:11,600 --> 00:20:16,700
well you have the ten to the six one in

00:20:15,230 --> 00:20:19,120
ten to the six chance of guessing what

00:20:16,700 --> 00:20:22,730
to write it what the outcome will be

00:20:19,120 --> 00:20:25,340
whereas if I tell you that I got nine

00:20:22,730 --> 00:20:30,290
nine nine nine nine nine then well the

00:20:25,340 --> 00:20:32,530
chance of that is with one so it's

00:20:30,290 --> 00:20:35,390
probably so yeah that it's it's hard to

00:20:32,530 --> 00:20:39,860
for a kernel to determine whether it is

00:20:35,390 --> 00:20:42,350
currently unpredictable it can try to

00:20:39,860 --> 00:20:44,090
make some estimates by using the

00:20:42,350 --> 00:20:46,010
deterministic algorithm to try to

00:20:44,090 --> 00:20:47,840
predict itself what the next output of

00:20:46,010 --> 00:20:51,350
the entry source will be or given two

00:20:47,840 --> 00:20:54,050
outputs it will try to assess if I knew

00:20:51,350 --> 00:20:56,900
the first output would the second output

00:20:54,050 --> 00:20:59,390
be a surprise to me and so there's some

00:20:56,900 --> 00:21:02,540
ad hoc logic in most kernels that will

00:20:59,390 --> 00:21:03,980
try to guess do these look like they're

00:21:02,540 --> 00:21:06,290
this look like as unpredictable given

00:21:03,980 --> 00:21:07,640
the first output and if so maybe I got

00:21:06,290 --> 00:21:10,070
one did eventually may got two bits of

00:21:07,640 --> 00:21:12,440
entropy and it will slowly add up the

00:21:10,070 --> 00:21:15,590
bits of entropy that it has counted

00:21:12,440 --> 00:21:18,920
using this ad hoc approach until it gets

00:21:15,590 --> 00:21:22,510
to a certain threshold but this isn't

00:21:18,920 --> 00:21:24,520
really a good solution because you can

00:21:22,510 --> 00:21:30,260
you could you could certainly imagine

00:21:24,520 --> 00:21:34,130
using a you know using a sequence of

00:21:30,260 --> 00:21:36,440
keystroke timings that you got from a

00:21:34,130 --> 00:21:40,730
suitor another generator seated by zero

00:21:36,440 --> 00:21:42,170
so the output of that will look

00:21:40,730 --> 00:21:44,360
indistinguishable to random somebody who

00:21:42,170 --> 00:21:45,710
doesn't know the seed was zero but if

00:21:44,360 --> 00:21:48,020
you know this heat is zero then you can

00:21:45,710 --> 00:21:54,260
predict exactly what the resulting

00:21:48,020 --> 00:21:57,380
output will be so it's not it's there's

00:21:54,260 --> 00:21:58,430
no real good answer here usually it's

00:21:57,380 --> 00:22:04,940
just it's a matter of system engineering

00:21:58,430 --> 00:22:07,040
to decide how you know how in your whole

00:22:04,940 --> 00:22:08,780
system you can determine whether there's

00:22:07,040 --> 00:22:10,950
enough

00:22:08,780 --> 00:22:13,170
there's also this other concept of

00:22:10,950 --> 00:22:14,970
running out of entropy which you'll

00:22:13,170 --> 00:22:17,040
encounter in a lot of the man pages and

00:22:14,970 --> 00:22:19,050
documentation on the web and discussions

00:22:17,040 --> 00:22:21,810
on the web and the interwebs and and an

00:22:19,050 --> 00:22:24,180
IRC and everywhere about how sometimes

00:22:21,810 --> 00:22:26,880
if you use a lot of data from dev random

00:22:24,180 --> 00:22:28,470
you'll deplete the entropy pool you'll

00:22:26,880 --> 00:22:30,510
run out of entropy like running out of

00:22:28,470 --> 00:22:32,580
gas when you're driving your car or

00:22:30,510 --> 00:22:34,140
something and then all of a sudden your

00:22:32,580 --> 00:22:39,480
car slows down and it can't produce

00:22:34,140 --> 00:22:43,380
secrets anymore and that actually that

00:22:39,480 --> 00:22:47,760
doesn't really make sense the the only

00:22:43,380 --> 00:22:49,830
way that it conceivably makes sense in

00:22:47,760 --> 00:22:53,100
the real world no not in the really the

00:22:49,830 --> 00:22:55,350
theoretical world is that if an attacker

00:22:53,100 --> 00:22:58,680
witnessed the whole internal state of

00:22:55,350 --> 00:23:00,570
your kernel and then walked away without

00:22:58,680 --> 00:23:02,820
doing anything with it and you got some

00:23:00,570 --> 00:23:05,970
more entropy maybe then you would want

00:23:02,820 --> 00:23:07,800
to wait a little bit after they've read

00:23:05,970 --> 00:23:10,950
your whole internal state before trying

00:23:07,800 --> 00:23:12,480
to read more from dev random but if the

00:23:10,950 --> 00:23:14,340
attacker has already witnessed the full

00:23:12,480 --> 00:23:15,840
internal state of your kernel there's a

00:23:14,340 --> 00:23:18,510
good chance they can do lots of other

00:23:15,840 --> 00:23:21,470
nefarious things and you probably just

00:23:18,510 --> 00:23:29,120
don't want to use that machine anymore

00:23:21,470 --> 00:23:32,190
so why would you know that that very

00:23:29,120 --> 00:23:34,110
peculiar theoretical use case aside why

00:23:32,190 --> 00:23:36,630
would you want to block in dev random

00:23:34,110 --> 00:23:42,060
long after boot well there actually is a

00:23:36,630 --> 00:23:43,800
reason so if you're using dev random as

00:23:42,060 --> 00:23:47,450
a sort of unpredictability barrier that

00:23:43,800 --> 00:23:50,780
is as a way to ask the system please

00:23:47,450 --> 00:23:54,270
wait until you know or let me know when

00:23:50,780 --> 00:23:56,130
you've got enough entropy you would like

00:23:54,270 --> 00:23:57,870
to keep that code path exercise because

00:23:56,130 --> 00:23:59,490
if you run your application on your

00:23:57,870 --> 00:24:01,410
laptop in your development laptop you'll

00:23:59,490 --> 00:24:02,700
always have enough entropy so it'll

00:24:01,410 --> 00:24:03,960
never block you'll never actually use

00:24:02,700 --> 00:24:07,140
the Keele never actually see the code

00:24:03,960 --> 00:24:08,760
path where the blocking happens you will

00:24:07,140 --> 00:24:11,160
see your application just snappily goes

00:24:08,760 --> 00:24:15,600
along and read stuff from dev Randleman

00:24:11,160 --> 00:24:18,000
and never blocks until you write an

00:24:15,600 --> 00:24:19,800
application that someone else at some

00:24:18,000 --> 00:24:20,630
other company uses on an embedded device

00:24:19,800 --> 00:24:22,970
and they

00:24:20,630 --> 00:24:24,860
it causes all of their network to hang

00:24:22,970 --> 00:24:26,480
once they did an update to add your new

00:24:24,860 --> 00:24:30,620
code and and that was because you

00:24:26,480 --> 00:24:32,330
started using dev random and now all of

00:24:30,620 --> 00:24:34,460
their devices don't have enough entropy

00:24:32,330 --> 00:24:35,810
at boot and you never tested the

00:24:34,460 --> 00:24:37,130
blocking code path and if they just

00:24:35,810 --> 00:24:38,390
never get past boot because your

00:24:37,130 --> 00:24:43,280
application never launched because it

00:24:38,390 --> 00:24:48,170
couldn't get entropy from dev random all

00:24:43,280 --> 00:24:52,460
that said that's a fairly obscure use

00:24:48,170 --> 00:24:54,470
case and most applications are totally

00:24:52,460 --> 00:24:56,060
happy with just using dev you random so

00:24:54,470 --> 00:24:57,110
let me reiterate if you're writing an

00:24:56,060 --> 00:25:02,420
application that needs an untraceable

00:24:57,110 --> 00:25:04,280
secret used a few random now what if

00:25:02,420 --> 00:25:07,070
there are no entropy sources like on

00:25:04,280 --> 00:25:08,840
such an embedded device where at boot it

00:25:07,070 --> 00:25:11,000
just didn't have anything

00:25:08,840 --> 00:25:12,650
there's no disk there's no mouse you can

00:25:11,000 --> 00:25:14,060
move around there is no keyboard you can

00:25:12,650 --> 00:25:17,750
bang on and even if you had a keyboard

00:25:14,060 --> 00:25:19,850
the monkey wouldn't help you so in that

00:25:17,750 --> 00:25:21,400
case the system the kernel and the whole

00:25:19,850 --> 00:25:25,820
system might be totally deterministic

00:25:21,400 --> 00:25:27,710
and it can't provide anything from dev

00:25:25,820 --> 00:25:29,570
you random usefully that is anything it

00:25:27,710 --> 00:25:31,430
spits out of dev random or W random an

00:25:29,570 --> 00:25:33,350
attacker can predict because they can

00:25:31,430 --> 00:25:34,910
buy you the same embedded device run the

00:25:33,350 --> 00:25:39,770
same soft run and get exactly the same

00:25:34,910 --> 00:25:43,790
outputs and this is presumably what

00:25:39,770 --> 00:25:46,400
happened with the factor botnet survey

00:25:43,790 --> 00:25:50,330
that would resulting in the mining your

00:25:46,400 --> 00:25:51,830
P's and Q's paper there were presumably

00:25:50,330 --> 00:25:53,720
a lot of embedded appliances that just

00:25:51,830 --> 00:25:55,400
had no entropy and they booted up and

00:25:53,720 --> 00:25:57,080
generated the keys and on to different

00:25:55,400 --> 00:25:58,490
appliances it was the same keys or at

00:25:57,080 --> 00:26:00,290
least one of the same factors because

00:25:58,490 --> 00:26:03,830
there wasn't much entropy just a little

00:26:00,290 --> 00:26:08,780
tiny bit so this is a real problem in

00:26:03,830 --> 00:26:13,070
practice and well one thing you can do

00:26:08,780 --> 00:26:16,150
is when you install your system when you

00:26:13,070 --> 00:26:19,010
flash the flash it with a oh s image

00:26:16,150 --> 00:26:21,620
which you maybe do from your laptop or

00:26:19,010 --> 00:26:25,000
from something else your laptop probably

00:26:21,620 --> 00:26:27,050
is in an unpredictable state so you can

00:26:25,000 --> 00:26:29,300
take some entropy from dev random on

00:26:27,050 --> 00:26:32,180
your laptop and just store it on the

00:26:29,300 --> 00:26:34,310
embedded device in a little non-volatile

00:26:32,180 --> 00:26:34,460
storage location takes only 32 bytes to

00:26:34,310 --> 00:26:36,530
be

00:26:34,460 --> 00:26:43,730
reliable that's 256 bits and that's

00:26:36,530 --> 00:26:48,200
enough for any crypto and I then you

00:26:43,730 --> 00:26:50,030
might later also want to save it again

00:26:48,200 --> 00:26:51,350
when you reboot the Amedda device and so

00:26:50,030 --> 00:26:52,850
you can restore it when you start up

00:26:51,350 --> 00:26:54,770
again so that each boot will get

00:26:52,850 --> 00:26:56,240
different outputs so it doesn't generate

00:26:54,770 --> 00:27:01,970
the same session can use over and over

00:26:56,240 --> 00:27:05,870
again and if you do this then you don't

00:27:01,970 --> 00:27:07,430
need in your whole system the use of dev

00:27:05,870 --> 00:27:09,850
random is an unprepped ability barrier

00:27:07,430 --> 00:27:12,500
because the whole system has ensured

00:27:09,850 --> 00:27:15,110
your whole process of flashing the

00:27:12,500 --> 00:27:18,080
device with entropy derived from your

00:27:15,110 --> 00:27:22,070
laptop or something so whole system has

00:27:18,080 --> 00:27:23,480
ensured that the the system is is always

00:27:22,070 --> 00:27:28,720
in an unpredictable it's always

00:27:23,480 --> 00:27:31,070
unpredictable to an attacker now I

00:27:28,720 --> 00:27:33,980
mentioned earlier that the the kernel

00:27:31,070 --> 00:27:35,600
will draw from various different

00:27:33,980 --> 00:27:36,950
possible sources of entropy that is

00:27:35,600 --> 00:27:40,460
various possible different physical

00:27:36,950 --> 00:27:41,990
systems and sometimes these physical

00:27:40,460 --> 00:27:44,570
systems are under the influence of an

00:27:41,990 --> 00:27:46,220
attacker you know the attacker can

00:27:44,570 --> 00:27:48,320
easily influence network packet timings

00:27:46,220 --> 00:27:50,210
especially if they're on a LAN on the

00:27:48,320 --> 00:27:52,520
same LAN as you for example if you're in

00:27:50,210 --> 00:27:55,790
a coffee shop and the attacker is on the

00:27:52,520 --> 00:27:57,650
same Wi-Fi network sometimes you talk

00:27:55,790 --> 00:27:59,450
good influence keystroke timings I mean

00:27:57,650 --> 00:28:02,800
if you leave your laptop unattended an

00:27:59,450 --> 00:28:05,690
attacker can just walk up and type at it

00:28:02,800 --> 00:28:09,590
sometimes you might be worried about the

00:28:05,690 --> 00:28:14,900
attacker compromising your CPU and this

00:28:09,590 --> 00:28:17,210
sounds really far-fetched but it is I

00:28:14,900 --> 00:28:18,380
see some people shaking their heads here

00:28:17,210 --> 00:28:28,310
because to them it is not far-fetched

00:28:18,380 --> 00:28:30,800
but mamytwink's a got your cpu and so

00:28:28,310 --> 00:28:38,630
that's your host your your you're gone

00:28:30,800 --> 00:28:42,650
you're done but it's very easy in theory

00:28:38,630 --> 00:28:46,220
to modify the for example the read Rand

00:28:42,650 --> 00:28:48,770
instruction on Intel CPUs so that it has

00:28:46,220 --> 00:28:50,929
certain biases now

00:28:48,770 --> 00:28:55,010
the biases are going to be hard for you

00:28:50,929 --> 00:28:57,470
and I to predict or to even measure but

00:28:55,010 --> 00:28:59,480
for the dedicated attacker who put them

00:28:57,470 --> 00:29:01,760
there maybe there is a secret key that

00:28:59,480 --> 00:29:04,370
lets them distinguish the bias or let

00:29:01,760 --> 00:29:10,220
lets them lets lets them follow the

00:29:04,370 --> 00:29:12,380
biases through say a TLS session and the

00:29:10,220 --> 00:29:14,750
same very dedicated attacker who can

00:29:12,380 --> 00:29:16,100
make a little tiny change to your CPU

00:29:14,750 --> 00:29:18,440
that you're not gonna detect even with a

00:29:16,100 --> 00:29:22,340
microscope there's a paper just last

00:29:18,440 --> 00:29:24,500
year what was its ehe yes I forget what

00:29:22,340 --> 00:29:26,780
that anyway about and how you could

00:29:24,500 --> 00:29:29,150
modify the see the silicon so that you

00:29:26,780 --> 00:29:32,600
can't detect it with a CPU but some bits

00:29:29,150 --> 00:29:35,000
are wired to zero inside or something so

00:29:32,600 --> 00:29:37,520
an attacker who maybe can do that maybe

00:29:35,000 --> 00:29:39,170
they don't want to more broadly

00:29:37,520 --> 00:29:40,550
compromised your CPU maybe they don't

00:29:39,170 --> 00:29:42,200
want to add a bunch more gates in it

00:29:40,550 --> 00:29:44,900
that will leak information somewhere

00:29:42,200 --> 00:29:47,240
else maybe they don't want to make it

00:29:44,900 --> 00:29:49,400
you know leave tracks that will make it

00:29:47,240 --> 00:29:52,790
clear that they did actually compromised

00:29:49,400 --> 00:29:55,130
your CPU so at this point I would like

00:29:52,790 --> 00:29:57,350
to mention that when I started looking

00:29:55,130 --> 00:30:00,320
into dev random and W end of an FPS D

00:29:57,350 --> 00:30:03,650
but a year and a half ago I found that

00:30:00,320 --> 00:30:04,940
on FreeBSD on IV Intel Ivy Bridge

00:30:03,650 --> 00:30:07,580
systems which were the first ones that

00:30:04,940 --> 00:30:09,530
supported the read rand instruction dev

00:30:07,580 --> 00:30:12,890
random and Debu random both sourced

00:30:09,530 --> 00:30:14,660
directly from the read Rand instruction

00:30:12,890 --> 00:30:16,250
that is there were no other entropy

00:30:14,660 --> 00:30:18,440
sources involved no matter how much you

00:30:16,250 --> 00:30:20,300
bank Tony keyboard like a monkey that

00:30:18,440 --> 00:30:22,760
wouldn't affect the output of dev random

00:30:20,300 --> 00:30:27,740
it was only from the CPUs ran number

00:30:22,760 --> 00:30:29,270
generator I talked to some previous

00:30:27,740 --> 00:30:31,820
students I talk to Colin Percival about

00:30:29,270 --> 00:30:33,230
this and and at the time he said well if

00:30:31,820 --> 00:30:36,820
you thinking compromised CPUs and it's

00:30:33,230 --> 00:30:39,460
not much of an issue one year ago after

00:30:36,820 --> 00:30:42,020
some of mr. Snowden's disclosures

00:30:39,460 --> 00:30:46,000
FreeBSD reverted to using the read Rand

00:30:42,020 --> 00:30:46,000
as just one of several entropy sources

00:31:00,429 --> 00:31:10,960
ah so so for the for the recorded

00:31:08,080 --> 00:31:12,610
audience Hyuk just added that in there

00:31:10,960 --> 00:31:14,879
was a Northbridge random number

00:31:12,610 --> 00:31:18,330
generator some time ago

00:31:14,879 --> 00:31:21,070
- which Intel applied a die shrink and

00:31:18,330 --> 00:31:23,740
in doing so some of the diodes inside

00:31:21,070 --> 00:31:25,539
they were supposed to provide noise they

00:31:23,740 --> 00:31:31,509
were supposed to provide entropy went

00:31:25,539 --> 00:31:35,649
away and stopped writing entropy so in

00:31:31,509 --> 00:31:38,889
addition to the the sort of mundane and

00:31:35,649 --> 00:31:41,009
not very uniform entropy sources that

00:31:38,889 --> 00:31:43,720
I've discussed and there are also

00:31:41,009 --> 00:31:45,519
various Hardware runner or generous

00:31:43,720 --> 00:31:47,320
Hardware entropy sources on the market

00:31:45,519 --> 00:31:49,029
now you get PCI devices you could add to

00:31:47,320 --> 00:31:51,759
your you know add to your workstation

00:31:49,029 --> 00:31:56,379
various systems on chip

00:31:51,759 --> 00:31:58,269
I have entropy sources on the die and

00:31:56,379 --> 00:32:00,789
then there are CPU instructions like the

00:31:58,269 --> 00:32:06,220
Intel read Rand instruction or the via

00:32:00,789 --> 00:32:07,629
padlock instructions now I've never

00:32:06,220 --> 00:32:11,200
personally looked into how any of these

00:32:07,629 --> 00:32:12,700
physically work if you pay money for

00:32:11,200 --> 00:32:15,100
them you would hope that they work well

00:32:12,700 --> 00:32:18,129
to be unpredictable but who knows I

00:32:15,100 --> 00:32:20,019
don't know so actually my favorite

00:32:18,129 --> 00:32:22,659
Hardware entropy source you probably

00:32:20,019 --> 00:32:25,509
have in your pocket it is just a coin

00:32:22,659 --> 00:32:28,570
here and now if you are practiced you

00:32:25,509 --> 00:32:30,909
can make yourself reliably flip two

00:32:28,570 --> 00:32:33,669
heads or tails whichever you want but to

00:32:30,909 --> 00:32:35,259
all of you folks what I flip is pretty

00:32:33,669 --> 00:32:37,419
unpredictable and in fact I'm not very

00:32:35,259 --> 00:32:42,249
good at I don't even know how to how to

00:32:37,419 --> 00:32:44,889
make it flip heads or tails myself so I

00:32:42,249 --> 00:32:46,809
I mentioned earlier you can write to

00:32:44,889 --> 00:32:48,369
have a random and so you can act as your

00:32:46,809 --> 00:32:49,779
own little entropy source writing to

00:32:48,369 --> 00:32:51,730
have random just provides entropy that

00:32:49,779 --> 00:32:53,679
goes into the entropy funnel and then is

00:32:51,730 --> 00:32:55,840
used to seed the PRNG

00:32:53,679 --> 00:32:57,249
and so if you if you want to generate a

00:32:55,840 --> 00:32:58,690
key that you're kind of paranoid about

00:32:57,249 --> 00:33:01,149
and you're confident there are no

00:32:58,690 --> 00:33:02,350
cameras looking at you so you know maybe

00:33:01,149 --> 00:33:04,779
doing your own bathroom at home or

00:33:02,350 --> 00:33:06,009
something and hope you haven't attracted

00:33:04,779 --> 00:33:08,679
the interest of a launch a nation-state

00:33:06,009 --> 00:33:11,379
then just it takes

00:33:08,679 --> 00:33:13,389
I mean 128 flips if you know if you if

00:33:11,379 --> 00:33:14,290
you want a decent key if you're bored

00:33:13,389 --> 00:33:15,580
you can do two disks

00:33:14,290 --> 00:33:18,760
it's you know it just takes a couple

00:33:15,580 --> 00:33:20,260
minutes and for a long term key you know

00:33:18,760 --> 00:33:21,610
if you want to keep a key to last for

00:33:20,260 --> 00:33:23,650
ten years without being compromised

00:33:21,610 --> 00:33:28,950
without being gassed then you know maybe

00:33:23,650 --> 00:33:33,850
a couple minutes is worth that time so

00:33:28,950 --> 00:33:35,950
that's all about the dev random and W

00:33:33,850 --> 00:33:36,820
random in general about a year and a

00:33:35,950 --> 00:33:39,040
half ago as I mentioned I started

00:33:36,820 --> 00:33:43,060
looking at the implementation in that

00:33:39,040 --> 00:33:46,120
BSD and I found a lot of things where I

00:33:43,060 --> 00:33:47,470
wanted to improve it so just a few

00:33:46,120 --> 00:33:51,190
little details of how it works in that

00:33:47,470 --> 00:33:54,490
bsd when you open dev random when you

00:33:51,190 --> 00:33:57,520
opened every random eye you'll get your

00:33:54,490 --> 00:34:00,220
own per thread or per well your own

00:33:57,520 --> 00:34:02,800
profile descriptor state or per cpu

00:34:00,220 --> 00:34:04,840
state if you just make small reads from

00:34:02,800 --> 00:34:05,740
dev your random which is a little bit

00:34:04,840 --> 00:34:09,100
silly I'm not sure that's the right

00:34:05,740 --> 00:34:12,429
thing but yeah so the point of this is

00:34:09,100 --> 00:34:13,679
that I never NW random on that BSD scale

00:34:12,429 --> 00:34:16,000
you don't need to worry about

00:34:13,679 --> 00:34:18,040
multiprocessor issues that they're not

00:34:16,000 --> 00:34:19,510
you know if two processes reading from

00:34:18,040 --> 00:34:23,110
dev you random can do it on different

00:34:19,510 --> 00:34:26,590
cores about interfering for generating

00:34:23,110 --> 00:34:30,910
key material for crypto and that bsd

00:34:26,590 --> 00:34:32,350
uses the NIST counter mode drbg

00:34:30,910 --> 00:34:34,600
deterministic grant a bit generator

00:34:32,350 --> 00:34:38,740
synonym for PRNG pseudo-random number

00:34:34,600 --> 00:34:41,679
generator this is not the famous dual EC

00:34:38,740 --> 00:34:44,440
drbg this is one of the three totally

00:34:41,679 --> 00:34:49,480
reasonable algorithms in the same

00:34:44,440 --> 00:34:52,810
standard which it's not plausible to

00:34:49,480 --> 00:34:55,390
have been back doored so it's it just

00:34:52,810 --> 00:34:56,860
uses a block cipher in counter mode to

00:34:55,390 --> 00:34:58,330
generate some outputs and then reseed

00:34:56,860 --> 00:35:04,270
itself from the last output as a block

00:34:58,330 --> 00:35:06,310
cipher and we use AES 128 for non key

00:35:04,270 --> 00:35:08,770
material inside the kernel we use a much

00:35:06,310 --> 00:35:14,830
faster PRNG much faster a stream cipher

00:35:08,770 --> 00:35:17,380
chacha eight this is only for preventing

00:35:14,830 --> 00:35:19,360
an attacker from preemptively guessing

00:35:17,380 --> 00:35:21,160
what the output will be rather than

00:35:19,360 --> 00:35:23,230
retro actively guessing so it provides

00:35:21,160 --> 00:35:24,910
predictive resistance but not

00:35:23,230 --> 00:35:27,360
backtracking resistance so we don't use

00:35:24,910 --> 00:35:30,630
it for key material we use it only for

00:35:27,360 --> 00:35:33,000
like NFS transaction IDs similarly the

00:35:30,630 --> 00:35:36,150
userland arc for random which Theo gave

00:35:33,000 --> 00:35:38,040
a talk about just an hour or two ago we

00:35:36,150 --> 00:35:42,630
are going to implement that soon with

00:35:38,040 --> 00:35:44,300
cha-cha 8 and basically have it be more

00:35:42,630 --> 00:35:48,450
or less the same as the colonel's fast

00:35:44,300 --> 00:35:51,060
PRNG although I did some surveys and I I

00:35:48,450 --> 00:35:54,950
couldn't find any code that uses the ark

00:35:51,060 --> 00:35:58,230
for random API to generate key material

00:35:54,950 --> 00:36:00,660
if you know of such code please let me

00:35:58,230 --> 00:36:02,970
know I would like it if there weren't

00:36:00,660 --> 00:36:04,890
such code so we could just not penalize

00:36:02,970 --> 00:36:08,280
the code that doesn't need backtracking

00:36:04,890 --> 00:36:09,570
resistance but I would like to know if

00:36:08,280 --> 00:36:11,520
anybody really does use it for key

00:36:09,570 --> 00:36:13,800
material for key material as his head

00:36:11,520 --> 00:36:23,880
earlier if you want to generate key used

00:36:13,800 --> 00:36:25,950
a view random I looked at OpenSSH and I

00:36:23,880 --> 00:36:29,180
don't recall what it uses to generate

00:36:25,950 --> 00:36:29,180
keys but I'm

00:36:37,540 --> 00:36:43,970
okay I had thought that OpenSSH used the

00:36:41,540 --> 00:36:46,490
OpenSSL PRNG but maybe not I don't

00:36:43,970 --> 00:36:49,870
remember I'm not I'm not sure I see some

00:36:46,490 --> 00:36:49,870
people not taking their heads

00:37:04,599 --> 00:37:14,960
so yeah so but the what what yeah so the

00:37:11,329 --> 00:37:17,450
question for the recordings is I both

00:37:14,960 --> 00:37:21,200
know it doesn't OpenSSH use arc for

00:37:17,450 --> 00:37:25,009
random for session keys and York says it

00:37:21,200 --> 00:37:26,509
does but only in the child process and

00:37:25,009 --> 00:37:29,660
the child process will have only one

00:37:26,509 --> 00:37:33,200
session future child processes will be

00:37:29,660 --> 00:37:35,240
reseeded separately so you can't use

00:37:33,200 --> 00:37:36,859
their session keys or anything about

00:37:35,240 --> 00:37:38,930
them total compromises the future child

00:37:36,859 --> 00:37:42,619
processes - gasps the session Keys of

00:37:38,930 --> 00:37:43,999
past child processes that's my that's

00:37:42,619 --> 00:37:45,109
that's my guess right now but I'm not

00:37:43,999 --> 00:37:50,619
sure about this so we can we can take

00:37:45,109 --> 00:37:58,390
this offline further so that's some

00:37:50,619 --> 00:37:58,390
that's it eww random any questions

00:38:04,430 --> 00:38:09,410
you mentioned the case of dev random

00:38:06,920 --> 00:38:13,369
blocking in the case when it has enough

00:38:09,410 --> 00:38:15,460
entropy how how does it know when to

00:38:13,369 --> 00:38:22,759
block and when to unblock in this case

00:38:15,460 --> 00:38:24,739
so basically there is one of these

00:38:22,759 --> 00:38:27,640
little accounting trolls sitting inside

00:38:24,739 --> 00:38:30,049
the implementation of dev random and it

00:38:27,640 --> 00:38:33,739
debits a little counter every time you

00:38:30,049 --> 00:38:35,660
read data from the entropy pool roughly

00:38:33,739 --> 00:38:37,309
this is though traditionally works and

00:38:35,660 --> 00:38:38,480
once the entropy count goes down to a

00:38:37,309 --> 00:38:42,200
certain amount then it aside it's time

00:38:38,480 --> 00:38:44,599
to block this doesn't really have any

00:38:42,200 --> 00:38:47,349
physical significance it's just the way

00:38:44,599 --> 00:38:50,509
it's traditionally done personally I

00:38:47,349 --> 00:38:53,779
would consider just having it flip a

00:38:50,509 --> 00:38:55,400
coin to decide whether to block just so

00:38:53,779 --> 00:38:57,890
that your code paths get exercised and

00:38:55,400 --> 00:39:01,249
otherwise you're not led down a path of

00:38:57,890 --> 00:39:05,359
treating entropy like a scarce resource

00:39:01,249 --> 00:39:07,789
like oil you can deplete so you

00:39:05,359 --> 00:39:10,130
recommend using the view random what

00:39:07,789 --> 00:39:13,220
about the new syscall wasn't done oh

00:39:10,130 --> 00:39:15,259
yeah so the trouble with the new system

00:39:13,220 --> 00:39:17,360
call or the new system calls or the new

00:39:15,259 --> 00:39:19,310
system calls with multiple flags or

00:39:17,360 --> 00:39:22,010
which are different and different the

00:39:19,310 --> 00:39:23,060
point is there are multiple proposals

00:39:22,010 --> 00:39:25,580
floating around right now

00:39:23,060 --> 00:39:29,870
one implemented OpenBSD one implement in

00:39:25,580 --> 00:39:33,560
linux bsd has a cisco node that you can

00:39:29,870 --> 00:39:35,210
use to grab entropy and that's how yeah

00:39:33,560 --> 00:39:37,340
I have FreeBSD - that's how arc for

00:39:35,210 --> 00:39:39,500
random and Lib C seeds itself doesn't

00:39:37,340 --> 00:39:41,330
used every random that's all well and

00:39:39,500 --> 00:39:44,450
good but right now if you're running an

00:39:41,330 --> 00:39:46,910
application you can make it you know

00:39:44,450 --> 00:39:49,250
like four lines of code to open dev you

00:39:46,910 --> 00:39:51,020
random and read from it rather than 60

00:39:49,250 --> 00:39:52,100
lines of C preprocessor to detect what

00:39:51,020 --> 00:39:53,720
operating system you're on whether it

00:39:52,100 --> 00:39:55,550
has de Vieux random plus the auto comp

00:39:53,720 --> 00:39:58,250
stuff to decide we or whatever else you

00:39:55,550 --> 00:40:00,130
know so I you know soon enough maybe

00:39:58,250 --> 00:40:03,500
there will be a standard library call

00:40:00,130 --> 00:40:07,100
that we can all use for generating key

00:40:03,500 --> 00:40:15,470
material but right now I still say use

00:40:07,100 --> 00:40:19,280
dev you random just comment there's

00:40:15,470 --> 00:40:21,980
moved to standardize for random or some

00:40:19,280 --> 00:40:27,620
similar variants in POSIX now you know

00:40:21,980 --> 00:40:33,610
okay I had not heard about that I missed

00:40:27,620 --> 00:40:33,610
the yos talk I'm afraid more questions

00:40:38,050 --> 00:40:44,840
so one of the big problems with deaf you

00:40:41,120 --> 00:40:47,300
random as you might know until did

00:40:44,840 --> 00:40:52,100
mention that is that basically you can

00:40:47,300 --> 00:40:54,290
be in change route or use capsicum in

00:40:52,100 --> 00:40:59,450
FreeBSD which we use more and more now

00:40:54,290 --> 00:41:02,660
so using global namespaces to actually

00:40:59,450 --> 00:41:05,750
locate the random device it is a bit

00:41:02,660 --> 00:41:08,750
problematic so CTL is much better

00:41:05,750 --> 00:41:13,640
solution for now or some dedicated

00:41:08,750 --> 00:41:17,510
system called for that yes nevertheless

00:41:13,640 --> 00:41:20,570
I think right now it is much easier for

00:41:17,510 --> 00:41:23,750
most applications to get by using the

00:41:20,570 --> 00:41:25,850
via random and is what you said about

00:41:23,750 --> 00:41:27,650
four lines of code I think it's much

00:41:25,850 --> 00:41:30,740
complex than that because sure you also

00:41:27,650 --> 00:41:32,870
have to handle the case when when you

00:41:30,740 --> 00:41:35,300
cannot open the from them and what to do

00:41:32,870 --> 00:41:39,620
next well then you from which abort

00:41:35,300 --> 00:41:41,690
crash not if you are in a library so it

00:41:39,620 --> 00:41:45,260
does complicate what happens if the

00:41:41,690 --> 00:41:47,840
Cisco system call fails it is much

00:41:45,260 --> 00:41:51,610
easier to make it impossible to fail or

00:41:47,840 --> 00:41:51,610
the system call to make it possible to

00:41:51,820 --> 00:41:56,990
understand the portability the argument

00:41:55,430 --> 00:41:59,270
of course so yeah I mean I I think that

00:41:56,990 --> 00:42:01,100
it would be good if if we had a system

00:41:59,270 --> 00:42:02,090
call that were simpler than there is a

00:42:01,100 --> 00:42:05,180
standard library routine that were

00:42:02,090 --> 00:42:06,020
simpler than a few random I think that

00:42:05,180 --> 00:42:09,910
sounds great

00:42:06,020 --> 00:42:09,910
but right now that's not there yet and

00:42:12,130 --> 00:42:19,730
another question because as far as I

00:42:16,730 --> 00:42:22,430
understand and from what I saw from some

00:42:19,730 --> 00:42:24,860
previous discussions when you guys

00:42:22,430 --> 00:42:29,420
designed all this that you have two

00:42:24,860 --> 00:42:34,870
kinds of randomness faster and let's say

00:42:29,420 --> 00:42:38,420
we current yeah that was the the slow

00:42:34,870 --> 00:42:41,240
CTR drbg with AES versus the fast ish

00:42:38,420 --> 00:42:44,660
which I also find a bit controversial

00:42:41,240 --> 00:42:47,430
because you pass the burden to the

00:42:44,660 --> 00:42:52,170
application writer to actually decide

00:42:47,430 --> 00:42:55,890
which to use and of course I think that

00:42:52,170 --> 00:42:57,900
the better move is to remove such a

00:42:55,890 --> 00:43:01,859
burden from application writers because

00:42:57,900 --> 00:43:04,319
because honestly most of them have no

00:43:01,859 --> 00:43:10,260
idea which one to use yeah that's that's

00:43:04,319 --> 00:43:13,349
that's there I don't disagree we should

00:43:10,260 --> 00:43:17,549
create one eh oh yeah this is this is

00:43:13,349 --> 00:43:19,950
these are just just within the kernel so

00:43:17,549 --> 00:43:22,319
with for userland programs dev random

00:43:19,950 --> 00:43:26,069
and w random it's it's all that all goes

00:43:22,319 --> 00:43:28,049
through the AES CTR drbg that's all go

00:43:26,069 --> 00:43:31,619
through the the slow one that's fit for

00:43:28,049 --> 00:43:34,440
key material yeah I agree that using the

00:43:31,619 --> 00:43:36,869
counter mode drbg is a much better idea

00:43:34,440 --> 00:43:39,599
but I have written applications that use

00:43:36,869 --> 00:43:43,319
millions of bits of entropy and aes-128

00:43:39,599 --> 00:43:46,230
that CR CTR is very very slow when

00:43:43,319 --> 00:43:48,480
you're consuming millions of it yeah so

00:43:46,230 --> 00:43:50,520
that's that was that motivated the

00:43:48,480 --> 00:43:52,770
choice of ChaCha 8 which is very fast

00:43:50,520 --> 00:43:54,750
and even in very naive C code and has a

00:43:52,770 --> 00:43:56,250
very low footprint just a you know a

00:43:54,750 --> 00:43:59,700
couple of cache lines so you can

00:43:56,250 --> 00:44:03,809
distributed across CPUs thank you and

00:43:59,700 --> 00:44:07,589
why giant and no ChaCha 20 it's a lot

00:44:03,809 --> 00:44:09,720
faster and currently there a ChaCha

00:44:07,589 --> 00:44:13,740
eight remains unbroken to the best of my

00:44:09,720 --> 00:44:16,740
knowledge so cha-cha 8 you can compute

00:44:13,740 --> 00:44:20,359
64 bytes of output in about 300 Ivy

00:44:16,740 --> 00:44:24,240
Bridge cycles on using naive C code

00:44:20,359 --> 00:44:26,849
ChaCha 20 takes a good deal more so did

00:44:24,240 --> 00:44:29,900
you discuss weave OpenBSD guys while you

00:44:26,849 --> 00:44:29,900
choose Church or 20

00:44:32,130 --> 00:44:43,940
I will not repeat yogs a pointed comment

00:44:40,920 --> 00:44:51,870
about OpenBSD for the recorded audience

00:44:43,940 --> 00:45:00,870
any more questions okay thanks

00:44:51,870 --> 00:45:04,730
thank you oh yes and there's a fun

00:45:00,870 --> 00:45:04,730
little entropy game on the website to I

00:45:04,970 --> 00:45:09,150
as an instructive exercise in why you

00:45:07,290 --> 00:45:12,690
should not try to come up with your own

00:45:09,150 --> 00:45:14,070
passwords or flip a coin in your head so

00:45:12,690 --> 00:45:16,370
this is this is the passive manager that

00:45:14,070 --> 00:45:16,370

YouTube URL: https://www.youtube.com/watch?v=kXUmlBnTTHg


