Title: Taming OpenBSD Network Stack Dragons - Martin Pieuchot
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

After more than 30 years of evolution, the network stack used in OpenBSD still carries a lot from its original architecture.The ongoing work to make it process network packets on multiple cores, led us to reconsider some parts if this architecture after understanding how its data structures and interfaces were really used.This talk describes some of the non obvious internals of OpenBSDâ€™s network stack, the dragons, and the work that has been done in order to tame them.

Speaker biography:

Martin Pieuchot is an OpenBSD developer and a R&D engineer working for Compumatica secure networks, a Dutch/German networking appliance manufacturer.
Captions: 
	00:00:00,030 --> 00:00:07,589
Oh afternoon welcome to yerba seek on

00:00:04,170 --> 00:00:10,800
ours an announcement from the from the

00:00:07,589 --> 00:00:13,349
organizers if please look to your right

00:00:10,800 --> 00:00:17,340
and if there is a or if you're telling

00:00:13,349 --> 00:00:19,410
that that so I on your left

00:00:17,340 --> 00:00:21,390
if there is a free space so we're doing

00:00:19,410 --> 00:00:23,189
without any this side of us move overs

00:00:21,390 --> 00:00:24,769
because people will be arriving late for

00:00:23,189 --> 00:00:29,220
its session

00:00:24,769 --> 00:00:30,660
and yeah I see people still arriving but

00:00:29,220 --> 00:00:33,210
we're trying to keep the schedule here

00:00:30,660 --> 00:00:36,390
so please welcome Martin here who is a

00:00:33,210 --> 00:00:38,820
no BCU developer who's been shaming the

00:00:36,390 --> 00:00:42,840
network stack so take it away Martin

00:00:38,820 --> 00:00:46,200
thank you very much so thank you for

00:00:42,840 --> 00:00:48,450
being here as Peter said ah I'm a

00:00:46,200 --> 00:00:51,480
OpenBSD developer and bit late into the

00:00:48,450 --> 00:00:53,520
party that's an interesting fact for the

00:00:51,480 --> 00:00:56,129
talk I'm giving right now because I'm

00:00:53,520 --> 00:00:58,559
mostly working on what I'm going to talk

00:00:56,129 --> 00:01:02,070
about it about code that is older than I

00:00:58,559 --> 00:01:03,780
am as you can see with the name of the

00:01:02,070 --> 00:01:07,340
presentation I'm going to buy to talk

00:01:03,780 --> 00:01:09,869
about network network what exactly I

00:01:07,340 --> 00:01:11,400
found a really funny name that comes

00:01:09,869 --> 00:01:14,490
from a joke that I would explain a bit

00:01:11,400 --> 00:01:17,549
later so timing those OpenBSD networks

00:01:14,490 --> 00:01:20,970
type dragons for those that don't really

00:01:17,549 --> 00:01:26,100
know me and I spend a lot of time in

00:01:20,970 --> 00:01:29,520
open BSD kernel as day job to the

00:01:26,100 --> 00:01:32,130
network and during the night working on

00:01:29,520 --> 00:01:36,689
USB poor piece II or some different

00:01:32,130 --> 00:01:39,119
stuff they're in here so what I'm doing

00:01:36,689 --> 00:01:41,670
exactly to talk about what as those

00:01:39,119 --> 00:01:45,930
dragon that well I'm mentioning this

00:01:41,670 --> 00:01:47,939
life the first or maybe the is your way

00:01:45,930 --> 00:01:51,659
to present to introduce you to those

00:01:47,939 --> 00:01:53,970
dragons it's to let's read a command

00:01:51,659 --> 00:01:57,509
that you can find if if you're looking

00:01:53,970 --> 00:02:01,579
at to the the network code in the side

00:01:57,509 --> 00:02:03,750
the open BSD source tree in the criminal

00:02:01,579 --> 00:02:06,000
that's an interesting question that I've

00:02:03,750 --> 00:02:09,899
to add that might occur I want to know

00:02:06,000 --> 00:02:12,750
maybe how many person family always with

00:02:09,899 --> 00:02:13,750
the internal of the BSD networking

00:02:12,750 --> 00:02:15,850
subsystem or maybe

00:02:13,750 --> 00:02:19,320
according maybe can you raise your hand

00:02:15,850 --> 00:02:19,320
if you know something about that

00:02:20,640 --> 00:02:25,960
it's okay society I try to adapt the

00:02:23,770 --> 00:02:28,660
language so the comment I was talking

00:02:25,960 --> 00:02:34,510
about you can find it in these in this

00:02:28,660 --> 00:02:38,650
file and as you can see when we are

00:02:34,510 --> 00:02:41,770
afraid of something we call it dragon a

00:02:38,650 --> 00:02:43,840
dragon is is a legendary animal I don't

00:02:41,770 --> 00:02:46,750
know how many of a few readies have

00:02:43,840 --> 00:02:49,120
already seen a dragon I didn't but the

00:02:46,750 --> 00:02:53,739
effect that dragon can do at least in in

00:02:49,120 --> 00:02:57,250
a kernel I quote terrific this this tall

00:02:53,739 --> 00:03:00,100
could have been named how to badly break

00:02:57,250 --> 00:03:02,860
you Network stack it coming out of a

00:03:00,100 --> 00:03:04,239
joke that that as a world that really

00:03:02,860 --> 00:03:06,190
interesting stuff that I don't know how

00:03:04,239 --> 00:03:09,489
many people know about the bsd story

00:03:06,190 --> 00:03:11,290
this design why do you want to brag that

00:03:09,489 --> 00:03:13,120
way do you want to change that that's a

00:03:11,290 --> 00:03:15,160
really interesting question so I tried

00:03:13,120 --> 00:03:17,140
to do a talk here in 45 minutes

00:03:15,160 --> 00:03:19,810
a lot of people already told me that if

00:03:17,140 --> 00:03:21,459
I want to explain what I didn't know how

00:03:19,810 --> 00:03:24,190
many times I break through the network

00:03:21,459 --> 00:03:26,290
stack it wouldn't fit in one talk so

00:03:24,190 --> 00:03:27,970
I'll try to be short here but don't

00:03:26,290 --> 00:03:31,920
hesitate to ask question to further

00:03:27,970 --> 00:03:35,500
details so what are the motivation that

00:03:31,920 --> 00:03:38,110
leads me to to look for those dragons

00:03:35,500 --> 00:03:40,660
those creators that that are in your

00:03:38,110 --> 00:03:43,000
thirty years old a bit more than thirty

00:03:40,660 --> 00:03:45,459
years old operating system in this code

00:03:43,000 --> 00:03:48,010
there that's the first part of the

00:03:45,459 --> 00:03:50,739
agenda right after that since we are

00:03:48,010 --> 00:03:53,019
talking here about network and I don't

00:03:50,739 --> 00:03:55,380
know how many of you are familiar with

00:03:53,019 --> 00:03:57,670
the notion of addresses and and routes

00:03:55,380 --> 00:04:00,430
is it right the right place to talk

00:03:57,670 --> 00:04:02,799
about that well you tell me but I will

00:04:00,430 --> 00:04:06,450
introduce that and and specifically how

00:04:02,799 --> 00:04:09,820
from my point of view as a network

00:04:06,450 --> 00:04:12,880
developer as a colonel network developer

00:04:09,820 --> 00:04:15,100
we choose or at least I was told that

00:04:12,880 --> 00:04:17,919
the BSD people the guy in Berkeley

00:04:15,100 --> 00:04:20,049
decided to represent them that's really

00:04:17,919 --> 00:04:22,120
interesting to understand how they are

00:04:20,049 --> 00:04:26,229
represented because since I'm looking

00:04:22,120 --> 00:04:27,639
into this this network stack and I found

00:04:26,229 --> 00:04:29,379
a lot of dragon there

00:04:27,639 --> 00:04:31,870
I won't understand where they are

00:04:29,379 --> 00:04:34,719
leaving and why we could find some

00:04:31,870 --> 00:04:38,020
dragons then the change that leads me to

00:04:34,719 --> 00:04:40,300
break stuff that the change why why

00:04:38,020 --> 00:04:41,699
would you like to break stuff what what

00:04:40,300 --> 00:04:44,919
kind of change get break stuff

00:04:41,699 --> 00:04:48,580
what kind of change did we do on OpenBSD

00:04:44,919 --> 00:04:51,909
that none of the other BSD did that we

00:04:48,580 --> 00:04:56,530
found some specifically complex design

00:04:51,909 --> 00:04:59,409
decision on the original bsd kernel in

00:04:56,530 --> 00:05:03,090
the network stack where those changed

00:04:59,409 --> 00:05:05,080
lasers that's the point of of now and

00:05:03,090 --> 00:05:07,900
finally I will concrete about this

00:05:05,080 --> 00:05:11,500
experience which represent about one and

00:05:07,900 --> 00:05:13,029
a half year of work so feel free to

00:05:11,500 --> 00:05:17,199
interrupt me if you have some question

00:05:13,029 --> 00:05:20,439
if I'm not clear as I said there's a lot

00:05:17,199 --> 00:05:23,800
to say but I think we can manage to Co

00:05:20,439 --> 00:05:27,449
the author of all of the slides so first

00:05:23,800 --> 00:05:30,759
point the motivation what bring me here

00:05:27,449 --> 00:05:32,889
to talk about those dragons right well

00:05:30,759 --> 00:05:35,259
the first point is obviously to give a

00:05:32,889 --> 00:05:38,319
talk to the Europe years to come that's

00:05:35,259 --> 00:05:41,889
that's what every PhD developer are

00:05:38,319 --> 00:05:44,589
working for and you might like As I am

00:05:41,889 --> 00:05:47,860
to enjoy code of the 80s I was born in

00:05:44,589 --> 00:05:49,930
the 80s after this the code I'm touching

00:05:47,860 --> 00:05:51,639
has been written and well it's

00:05:49,930 --> 00:05:53,169
interesting and I was not particularly

00:05:51,639 --> 00:05:56,529
interested in in a story what was

00:05:53,169 --> 00:06:00,219
interesting but the why I enjoyed this

00:05:56,529 --> 00:06:04,539
code or I don't enjoy this code it's

00:06:00,219 --> 00:06:07,569
because I would like to make it easier

00:06:04,539 --> 00:06:11,889
for other people for myself to run it in

00:06:07,569 --> 00:06:16,029
parallel I don't know if you drink some

00:06:11,889 --> 00:06:20,400
bells here computer used to have one

00:06:16,029 --> 00:06:23,770
central processing unit now as day job

00:06:20,400 --> 00:06:28,360
my employer wants to sell Rueter based

00:06:23,770 --> 00:06:30,729
on on open BSD it wants to sell Reuter

00:06:28,360 --> 00:06:32,289
that are fast that's something well I

00:06:30,729 --> 00:06:36,370
don't know people are interested in fast

00:06:32,289 --> 00:06:37,990
software and one of the way to make it

00:06:36,370 --> 00:06:41,530
faster at least that's what he told me

00:06:37,990 --> 00:06:46,110
and that was did they hire me for

00:06:41,530 --> 00:06:49,090
it's too executor on multiple CPU so

00:06:46,110 --> 00:06:50,830
what I'm I'm writing here on the sub

00:06:49,090 --> 00:06:54,160
point of of making and run in parallel

00:06:50,830 --> 00:06:57,010
is that the motivation on the important

00:06:54,160 --> 00:07:01,060
motivation that leads me to make the

00:06:57,010 --> 00:07:04,360
change Network stack is to be able to

00:07:01,060 --> 00:07:06,760
make it easier to simplify the code that

00:07:04,360 --> 00:07:08,560
we want to run in parallel and I will be

00:07:06,760 --> 00:07:10,770
focusing on the forwarding path because

00:07:08,560 --> 00:07:13,690
the company that makes retirement

00:07:10,770 --> 00:07:17,169
resting in those performance it's quite

00:07:13,690 --> 00:07:19,360
a long talk it's quite big piece of code

00:07:17,169 --> 00:07:22,419
but it's interesting

00:07:19,360 --> 00:07:26,760
um I'm presiding on the second part that

00:07:22,419 --> 00:07:29,080
I took an approach that I wrote on top

00:07:26,760 --> 00:07:30,910
because other developer are approaching

00:07:29,080 --> 00:07:33,940
this this question of running code on

00:07:30,910 --> 00:07:35,830
multiple CPU and it's interesting when

00:07:33,940 --> 00:07:38,500
we work in software development if we

00:07:35,830 --> 00:07:41,260
work as a team so we share the work some

00:07:38,500 --> 00:07:42,640
people as a position of a topic I could

00:07:41,260 --> 00:07:44,770
say the bottom that are addressing our

00:07:42,640 --> 00:07:48,280
interesting the problem directly from

00:07:44,770 --> 00:07:50,800
the close to the hardware so from the

00:07:48,280 --> 00:07:53,650
driver system I look at some allocation

00:07:50,800 --> 00:07:55,930
mechanism I will look more at something

00:07:53,650 --> 00:07:59,770
which is even for people that don't

00:07:55,930 --> 00:08:03,729
really do operating system development

00:07:59,770 --> 00:08:06,280
can understand it's it's basically the

00:08:03,729 --> 00:08:08,140
top what we call ioctl that's what was

00:08:06,280 --> 00:08:11,350
the process when they entered the kernel

00:08:08,140 --> 00:08:14,110
to do some configuration change do what

00:08:11,350 --> 00:08:17,950
kind of of data they want to write to

00:08:14,110 --> 00:08:20,320
modify and of course the code that we

00:08:17,950 --> 00:08:22,690
run when we want to send a packet from

00:08:20,320 --> 00:08:25,570
one interface to another one that's what

00:08:22,690 --> 00:08:27,850
I mean when I write IP forward path now

00:08:25,570 --> 00:08:29,530
an interesting point about this work

00:08:27,850 --> 00:08:32,289
since I mean when you when you think

00:08:29,530 --> 00:08:35,200
about a strategy that that you have to

00:08:32,289 --> 00:08:38,080
deploy that you have to change to make

00:08:35,200 --> 00:08:41,020
it friend in parallel or at least to

00:08:38,080 --> 00:08:43,890
help it make it run in parallel is that

00:08:41,020 --> 00:08:46,780
a lot of the tricks are also true for

00:08:43,890 --> 00:08:49,510
plug-and-play problematics I mean that

00:08:46,780 --> 00:08:51,670
when you plug an interface that I appear

00:08:49,510 --> 00:08:52,450
to work on on USB 2 so I know what I'm

00:08:51,670 --> 00:08:54,100
talking about

00:08:52,450 --> 00:08:54,920
that when you plug an interface a remove

00:08:54,100 --> 00:08:57,980
it so

00:08:54,920 --> 00:08:59,870
now the current states change that you

00:08:57,980 --> 00:09:01,550
are representing an interface your

00:08:59,870 --> 00:09:03,350
computer in the memories some

00:09:01,550 --> 00:09:06,889
information and then you're removing

00:09:03,350 --> 00:09:09,920
that how do you manage to maintain the

00:09:06,889 --> 00:09:11,540
integrity of your kernel it's it's bit

00:09:09,920 --> 00:09:14,060
it's similar and I will come to a bit

00:09:11,540 --> 00:09:18,410
more detail later and the last point is

00:09:14,060 --> 00:09:20,449
I think interesting to to to explain it

00:09:18,410 --> 00:09:22,399
for people that are not really familiar

00:09:20,449 --> 00:09:28,399
with the the process development on the

00:09:22,399 --> 00:09:31,399
OpenBSD community is that it's probably

00:09:28,399 --> 00:09:33,709
impossible at least even if I with the

00:09:31,399 --> 00:09:36,709
team of you I'm working to test all the

00:09:33,709 --> 00:09:39,139
change so when we have such huge cause

00:09:36,709 --> 00:09:41,990
codebase and and I think that that Ted

00:09:39,139 --> 00:09:44,930
was saying something similar in the

00:09:41,990 --> 00:09:47,240
previous talk that you can only find all

00:09:44,930 --> 00:09:49,519
the big one or at least a lot of the big

00:09:47,240 --> 00:09:51,320
when you're really running the code in

00:09:49,519 --> 00:09:54,050
production well when you're really

00:09:51,320 --> 00:09:56,720
running in the you scare that sure your

00:09:54,050 --> 00:10:00,980
regression tests help you sure you can

00:09:56,720 --> 00:10:03,470
have a test set up and you should but we

00:10:00,980 --> 00:10:07,160
want it to commit it early so that

00:10:03,470 --> 00:10:11,060
people can try it it will found bag it

00:10:07,160 --> 00:10:12,589
always brought something its reverted so

00:10:11,060 --> 00:10:14,180
that people can still use open BSD

00:10:12,589 --> 00:10:16,040
otherwise it don't trust us anymore it's

00:10:14,180 --> 00:10:19,190
broken system how can use a current

00:10:16,040 --> 00:10:20,810
system which is broken fix it I should

00:10:19,190 --> 00:10:22,550
add apologize in between we have recom

00:10:20,810 --> 00:10:24,079
eyes basically apologize because I break

00:10:22,550 --> 00:10:28,210
the Machine of something and commit it

00:10:24,079 --> 00:10:29,350
again and repeat with the next step so

00:10:28,210 --> 00:10:32,120
[Music]

00:10:29,350 --> 00:10:34,899
but that's the motivation that lets me

00:10:32,120 --> 00:10:38,930
okay why do I want to change something

00:10:34,899 --> 00:10:39,709
what why changing something is hard and

00:10:38,930 --> 00:10:42,019
break something

00:10:39,709 --> 00:10:45,880
that's what coming after what what are

00:10:42,019 --> 00:10:49,850
those dragons so let's go to

00:10:45,880 --> 00:10:54,319
representation of addresses and routes

00:10:49,850 --> 00:10:57,350
which is basically the blocks true to

00:10:54,319 --> 00:11:03,699
represent to to imagine this abstraction

00:10:57,350 --> 00:11:06,180
that is a network no question so far

00:11:03,699 --> 00:11:09,310
okay

00:11:06,180 --> 00:11:13,990
well maybe you use your bit familiar

00:11:09,310 --> 00:11:17,410
with that what is an address what do we

00:11:13,990 --> 00:11:20,230
use addresses for and this might be

00:11:17,410 --> 00:11:22,930
superfluous or trivial for some people

00:11:20,230 --> 00:11:27,460
but I wrote on the left side of this

00:11:22,930 --> 00:11:29,250
slide to question and those two question

00:11:27,460 --> 00:11:31,960
are really interesting because

00:11:29,250 --> 00:11:36,910
everywhere in the kernel in the in the

00:11:31,960 --> 00:11:39,220
network park when you want or you access

00:11:36,910 --> 00:11:41,800
some somehow the representation of a

00:11:39,220 --> 00:11:45,720
network address it's to ask one of those

00:11:41,800 --> 00:11:51,090
two questions I don't if appear that's

00:11:45,720 --> 00:11:55,000
who receive who should receive who

00:11:51,090 --> 00:11:57,280
supposedly sent the packet that's that's

00:11:55,000 --> 00:12:00,310
a question basically to know is it for

00:11:57,280 --> 00:12:03,970
me did you did you send that that's that

00:12:00,310 --> 00:12:06,700
cat to me and the second question is

00:12:03,970 --> 00:12:09,490
where should I send the end the answer

00:12:06,700 --> 00:12:12,490
why should I send something on the

00:12:09,490 --> 00:12:16,900
right-hand side you see a picture

00:12:12,490 --> 00:12:19,660
representing and a fixed header of the

00:12:16,900 --> 00:12:23,530
version four of the IP protocol I will

00:12:19,660 --> 00:12:27,340
be concentrating on the code touching by

00:12:23,530 --> 00:12:28,960
P protocol M and as an example the

00:12:27,340 --> 00:12:31,480
profession for we can talk about the

00:12:28,960 --> 00:12:34,720
version six but I will prefer to keep

00:12:31,480 --> 00:12:36,700
that for later and an interesting point

00:12:34,720 --> 00:12:39,370
I put in read the information that

00:12:36,700 --> 00:12:43,360
correspond to to to the question on left

00:12:39,370 --> 00:12:46,840
and this is chancof of this

00:12:43,360 --> 00:12:48,670
representation of chunk of data we

00:12:46,840 --> 00:12:49,750
cannot choose to change it that's that's

00:12:48,670 --> 00:12:52,240
something that we have to deal with

00:12:49,750 --> 00:12:55,000
that's really interesting that as an

00:12:52,240 --> 00:12:57,640
operating system developer as a zone

00:12:55,000 --> 00:12:59,530
architects you can decide to represent

00:12:57,640 --> 00:13:02,020
things as you want why your table is

00:12:59,530 --> 00:13:04,690
this size why do you want to paint this

00:13:02,020 --> 00:13:06,670
color it leads to a lot of funny back

00:13:04,690 --> 00:13:08,170
shading that's interesting but that we

00:13:06,670 --> 00:13:14,200
cannot change it so we have to work with

00:13:08,170 --> 00:13:16,240
that now in a position to this Oh before

00:13:14,200 --> 00:13:20,649
before the position oh yeah

00:13:16,240 --> 00:13:22,500
what happened in you and you Colonel

00:13:20,649 --> 00:13:26,200
what's happening in your protein system

00:13:22,500 --> 00:13:29,920
when you when you receive a packet what

00:13:26,200 --> 00:13:33,100
happened when you send packets in order

00:13:29,920 --> 00:13:36,490
to to give support to my words I draw a

00:13:33,100 --> 00:13:38,770
simple picture that I will be

00:13:36,490 --> 00:13:42,910
illustrating with with more programming

00:13:38,770 --> 00:13:44,800
a question later on on the left hand

00:13:42,910 --> 00:13:47,350
side you see that well you have some

00:13:44,800 --> 00:13:50,440
people I won't go in detail how does it

00:13:47,350 --> 00:13:52,300
work but you have a packet you mash

00:13:50,440 --> 00:13:56,430
another packet the question you are

00:13:52,300 --> 00:13:58,570
asking is this packet from me well

00:13:56,430 --> 00:14:01,779
because if it's for you you want to look

00:13:58,570 --> 00:14:03,430
at it that's what I put on on on right

00:14:01,779 --> 00:14:06,339
hand side so you deliver the packet by

00:14:03,430 --> 00:14:09,339
delivering I mean you trust me the

00:14:06,339 --> 00:14:11,140
packet to whoever is supposed to receive

00:14:09,339 --> 00:14:15,040
it on your operating system which

00:14:11,140 --> 00:14:17,680
application but a lot of possibilities

00:14:15,040 --> 00:14:19,600
but what's interesting here is the

00:14:17,680 --> 00:14:22,000
question is it from you this question I

00:14:19,600 --> 00:14:24,339
turn it to the today I don't teach

00:14:22,000 --> 00:14:27,850
identity point that I previously

00:14:24,339 --> 00:14:31,120
presented on the side now if it's not

00:14:27,850 --> 00:14:33,190
for you and for some reason you appear

00:14:31,120 --> 00:14:35,560
to want to send this back up just to

00:14:33,190 --> 00:14:37,390
another computer I don't know if some of

00:14:35,560 --> 00:14:39,339
you have a view route or equipment if

00:14:37,390 --> 00:14:41,920
you use a I don't know Wi-Fi access

00:14:39,339 --> 00:14:44,440
point in conferences or in your home

00:14:41,920 --> 00:14:47,170
well they certainly send this packet to

00:14:44,440 --> 00:14:48,760
somebody else that's what what we call

00:14:47,170 --> 00:14:50,920
forwarding so do you ask question well

00:14:48,760 --> 00:14:53,709
I'm supposed to forward this packet

00:14:50,920 --> 00:14:57,459
there's a various question to say yes or

00:14:53,709 --> 00:14:59,140
no and if if you appear just you to be

00:14:57,459 --> 00:15:01,420
able or would you want to forward this

00:14:59,140 --> 00:15:04,660
packet then you have to say well but

00:15:01,420 --> 00:15:07,839
where typically when you plug your

00:15:04,660 --> 00:15:10,930
computer to a switch a router it has

00:15:07,839 --> 00:15:12,310
multiple ports how does it know which

00:15:10,930 --> 00:15:14,260
port you're going to send the packet

00:15:12,310 --> 00:15:17,170
does it is it supposed to send to all we

00:15:14,260 --> 00:15:19,209
can go to history about that but as an

00:15:17,170 --> 00:15:22,000
operating system OpenBSD as a mechanism

00:15:19,209 --> 00:15:24,520
to select well where is going to send it

00:15:22,000 --> 00:15:26,020
if you have only one cable basic

00:15:24,520 --> 00:15:27,790
traditional laptop it would be easy

00:15:26,020 --> 00:15:29,890
because you will be receiving always

00:15:27,790 --> 00:15:30,160
from the one from this cable and sending

00:15:29,890 --> 00:15:33,310
to the

00:15:30,160 --> 00:15:35,560
cable and that's basically what I'm

00:15:33,310 --> 00:15:37,240
writing on on the left-hand side one UIC

00:15:35,560 --> 00:15:39,459
cent if you're sending a packet if you

00:15:37,240 --> 00:15:41,589
are sending information well you just

00:15:39,459 --> 00:15:43,600
have to pick well which port which

00:15:41,589 --> 00:15:47,769
interface I'm going to send you and send

00:15:43,600 --> 00:15:50,050
it now this question which interface you

00:15:47,769 --> 00:15:52,389
want to use it's basically the question

00:15:50,050 --> 00:15:54,490
wet where I am used supposed to which

00:15:52,389 --> 00:15:57,459
route do you want to take or do you want

00:15:54,490 --> 00:16:00,850
to tell the packet to to take that's the

00:15:57,459 --> 00:16:03,730
second question that are inside this

00:16:00,850 --> 00:16:05,769
forwarding path now this question are

00:16:03,730 --> 00:16:10,029
present in different places in the

00:16:05,769 --> 00:16:13,660
kernel but I'm going to concentrate on

00:16:10,029 --> 00:16:16,480
on on this particular code path because

00:16:13,660 --> 00:16:18,939
that's what critical performant that's

00:16:16,480 --> 00:16:23,069
good is executed for every packet you

00:16:18,939 --> 00:16:27,069
are passing true so if that code is slow

00:16:23,069 --> 00:16:28,899
well you will have a slope forwarding

00:16:27,069 --> 00:16:30,160
machine and if you want to make it fast

00:16:28,899 --> 00:16:31,980
you have to understand how it works

00:16:30,160 --> 00:16:33,250
that's what we are going to talk about

00:16:31,980 --> 00:16:37,689
now

00:16:33,250 --> 00:16:41,980
I I showed the representation of the the

00:16:37,689 --> 00:16:44,529
IP packet head hi Piero how is it

00:16:41,980 --> 00:16:47,410
represented in your kernel I hope you

00:16:44,529 --> 00:16:50,430
not scare with some C structure

00:16:47,410 --> 00:16:55,269
declaration with some love from Berkeley

00:16:50,430 --> 00:16:56,470
but in your in your kernel m and I come

00:16:55,269 --> 00:16:58,569
back a bit later

00:16:56,470 --> 00:17:03,189
I think this tractor got introduced in

00:16:58,569 --> 00:17:05,409
85 and something around that and it's

00:17:03,189 --> 00:17:07,900
basically containing the information

00:17:05,409 --> 00:17:12,400
that you want to match to the packet

00:17:07,900 --> 00:17:14,439
you're going to receive is this an

00:17:12,400 --> 00:17:16,209
address that it's configured on an

00:17:14,439 --> 00:17:18,569
interface on your system that's the

00:17:16,209 --> 00:17:21,819
first field even if you don't understand

00:17:18,569 --> 00:17:25,959
the C semantics you can read comment

00:17:21,819 --> 00:17:28,390
that quite explicit is it a destination

00:17:25,959 --> 00:17:30,039
address if you have a point-to-point

00:17:28,390 --> 00:17:33,640
interface that's that's for point to

00:17:30,039 --> 00:17:36,909
point um here we are

00:17:33,640 --> 00:17:40,390
it's a reused trick if you appear to

00:17:36,909 --> 00:17:43,659
have a broadcast address configure on

00:17:40,390 --> 00:17:44,200
this interface that is full of dragon

00:17:43,659 --> 00:17:46,720
for example

00:17:44,200 --> 00:17:49,090
that's something that well people want

00:17:46,720 --> 00:17:51,789
to save space at some point so no need

00:17:49,090 --> 00:17:53,200
to add another field now when you have

00:17:51,789 --> 00:17:56,529
some generic code that deals with

00:17:53,200 --> 00:17:58,240
addresses and that might know if this

00:17:56,529 --> 00:18:00,010
field is representing a point a

00:17:58,240 --> 00:18:02,740
destination address or broadcast address

00:18:00,010 --> 00:18:07,330
because it's the same field so there you

00:18:02,740 --> 00:18:09,970
can have a lot of crash the rest of the

00:18:07,330 --> 00:18:11,320
the fill up quite self explainable one

00:18:09,970 --> 00:18:14,470
interesting point and then we come back

00:18:11,320 --> 00:18:15,610
to that right right after that you have

00:18:14,470 --> 00:18:17,740
a pointer that means that you have a

00:18:15,610 --> 00:18:19,779
link that show you which interface this

00:18:17,740 --> 00:18:22,210
address is configured on when you do

00:18:19,779 --> 00:18:25,139
I've config the name of your interface

00:18:22,210 --> 00:18:27,549
that address maybe some of you do well

00:18:25,139 --> 00:18:30,610
that's the interface let's say a.m. 0

00:18:27,549 --> 00:18:34,539
the IFP thatum that is using in our

00:18:30,610 --> 00:18:37,000
language of developer and in the address

00:18:34,539 --> 00:18:38,980
that you will put on this interface

00:18:37,000 --> 00:18:43,210
command will add up encoded in this

00:18:38,980 --> 00:18:44,950
field so how does that glue together to

00:18:43,210 --> 00:18:48,519
draw a picture in the memory

00:18:44,950 --> 00:18:52,600
representation of your kernel well let's

00:18:48,519 --> 00:18:55,840
start simple start simple you boot your

00:18:52,600 --> 00:18:58,269
computer of course what I'm talking here

00:18:55,840 --> 00:19:00,909
I forget to mention that previously

00:18:58,269 --> 00:19:04,990
right um I'm obviously talking about

00:19:00,909 --> 00:19:07,179
how's it in open BSD but most of it

00:19:04,990 --> 00:19:10,480
applied to all of the BSD system because

00:19:07,179 --> 00:19:12,760
they share the same stack right with

00:19:10,480 --> 00:19:15,010
some details I would mention right now

00:19:12,760 --> 00:19:18,159
so you boot you butcher your machine

00:19:15,010 --> 00:19:19,450
reboot your machine and it appeared that

00:19:18,159 --> 00:19:21,700
you have a network interface in your

00:19:19,450 --> 00:19:26,139
machine at least one let's say we are in

00:19:21,700 --> 00:19:29,019
2013 and what this network interface is

00:19:26,139 --> 00:19:33,909
here represented by the EFP symbol right

00:19:29,019 --> 00:19:39,330
IFP on top of that you have what I call

00:19:33,909 --> 00:19:43,419
the interface list this square rectangle

00:19:39,330 --> 00:19:46,120
means that the this list is a global

00:19:43,419 --> 00:19:50,730
structure name of the slightest global

00:19:46,120 --> 00:19:55,210
data structure which element or list

00:19:50,730 --> 00:19:57,850
trees pointing to object can be reached

00:19:55,210 --> 00:20:00,850
from anywhere in your kernel that's that

00:19:57,850 --> 00:20:04,120
really similar that the colonel just a

00:20:00,850 --> 00:20:06,310
simple a program which global variable

00:20:04,120 --> 00:20:10,720
let's say so you have a global variable

00:20:06,310 --> 00:20:12,940
that you can use to reach interface this

00:20:10,720 --> 00:20:15,130
one is the interface list a list of

00:20:12,940 --> 00:20:19,810
interface so you have an interface and

00:20:15,130 --> 00:20:22,270
it's in the list now this might

00:20:19,810 --> 00:20:27,760
represent more or less what was in in

00:20:22,270 --> 00:20:31,000
OpenBSD five four and before where every

00:20:27,760 --> 00:20:32,710
time you had an interface you had what I

00:20:31,000 --> 00:20:35,080
wrote it a link layer address of

00:20:32,710 --> 00:20:37,630
physical address associated to this

00:20:35,080 --> 00:20:40,050
interface no matter which kind of

00:20:37,630 --> 00:20:43,720
interface no matter if this interface

00:20:40,050 --> 00:20:46,470
really has a physical interface it was

00:20:43,720 --> 00:20:48,820
present it was always present

00:20:46,470 --> 00:20:51,420
it was always present so it's like

00:20:48,820 --> 00:20:53,620
one-to-one mapping with your with you

00:20:51,420 --> 00:20:57,340
interface right you have an interface

00:20:53,620 --> 00:20:59,230
you have a link layer address the I

00:20:57,340 --> 00:21:00,850
wrote that are represented there so you

00:20:59,230 --> 00:21:03,760
see the road that comes from the

00:21:00,850 --> 00:21:05,580
interface back to the interface to from

00:21:03,760 --> 00:21:07,840
the address back to the interface is

00:21:05,580 --> 00:21:10,510
this field do you see here of the back

00:21:07,840 --> 00:21:13,720
pointer to the interface I hope I'm not

00:21:10,510 --> 00:21:16,870
too confusing don't hesitate to stop me

00:21:13,720 --> 00:21:19,870
if I am now the interesting point is

00:21:16,870 --> 00:21:21,850
that you see that there is a red a rope

00:21:19,870 --> 00:21:24,760
starting from the interface are going

00:21:21,850 --> 00:21:30,070
through the address this represents a

00:21:24,760 --> 00:21:32,490
list of addresses configured on the

00:21:30,070 --> 00:21:35,410
interface right so you boot your system

00:21:32,490 --> 00:21:38,950
you have an interface you put it in the

00:21:35,410 --> 00:21:41,050
list you add physical address and you

00:21:38,950 --> 00:21:46,270
put it on the list of the interface

00:21:41,050 --> 00:21:48,100
right now since this address this this

00:21:46,270 --> 00:21:50,380
physical distinct layer address let's

00:21:48,100 --> 00:21:55,360
say is represented like any other

00:21:50,380 --> 00:21:58,420
address in openbsd and it's still true

00:21:55,360 --> 00:22:01,000
right now it no it's no longer truth in

00:21:58,420 --> 00:22:03,340
some months but in five four it was true

00:22:01,000 --> 00:22:06,040
each while also ending up in a red black

00:22:03,340 --> 00:22:08,080
tree which is also square while

00:22:06,040 --> 00:22:11,110
rectangle which means it's another

00:22:08,080 --> 00:22:11,950
global data structure that's something

00:22:11,110 --> 00:22:14,260
you can access on

00:22:11,950 --> 00:22:19,510
anywhere any kind of network code can

00:22:14,260 --> 00:22:22,389
use it to reach your address so what we

00:22:19,510 --> 00:22:26,260
see here that if you start using any

00:22:22,389 --> 00:22:28,720
kind of code in your kernel you can find

00:22:26,260 --> 00:22:30,690
the representation of your address by

00:22:28,720 --> 00:22:34,299
two different by using two different

00:22:30,690 --> 00:22:36,370
structure either you say well let's look

00:22:34,299 --> 00:22:39,340
at the interface I have on the list and

00:22:36,370 --> 00:22:43,059
which address they have on every

00:22:39,340 --> 00:22:46,110
interface oh well look at the tree what

00:22:43,059 --> 00:22:48,549
address did we put in that that's

00:22:46,110 --> 00:22:54,730
representation of an interface without

00:22:48,549 --> 00:22:56,789
address right no question okay let's put

00:22:54,730 --> 00:23:01,990
an address on this interface that

00:22:56,789 --> 00:23:03,190
happens it's a bit scary and I don't

00:23:01,990 --> 00:23:07,360
have a picture when I work with that

00:23:03,190 --> 00:23:12,240
it's almost well there's a lot of stuff

00:23:07,360 --> 00:23:12,240
missing but then I will scare everybody

00:23:12,630 --> 00:23:17,019
okay

00:23:13,870 --> 00:23:20,769
so now we are adding an IP address right

00:23:17,019 --> 00:23:23,289
you did your eyes config command so what

00:23:20,769 --> 00:23:25,600
I'm calling I file on the bottom of

00:23:23,289 --> 00:23:28,120
slide is the representation that just

00:23:25,600 --> 00:23:29,799
I've just shown before that will contain

00:23:28,120 --> 00:23:33,549
the address you just configure on your

00:23:29,799 --> 00:23:37,179
interface this either as you see there

00:23:33,549 --> 00:23:39,100
is a red red arrow pointing to it that

00:23:37,179 --> 00:23:43,000
means that it is also in the list of

00:23:39,100 --> 00:23:44,649
addresses of your interface that it's

00:23:43,000 --> 00:23:49,539
part of the interface you did i've

00:23:44,649 --> 00:23:53,860
config mg row blah blah then this blah

00:23:49,539 --> 00:23:56,049
blah is on am zero list since it's an

00:23:53,860 --> 00:23:58,480
address it's also appearing in the tree

00:23:56,049 --> 00:24:02,110
all the dress we're put in we put in

00:23:58,480 --> 00:24:04,990
there since in an IP address well we

00:24:02,110 --> 00:24:07,750
find another structure that's because

00:24:04,990 --> 00:24:10,750
it's easier for us to work with that so

00:24:07,750 --> 00:24:13,179
we have another global structure that we

00:24:10,750 --> 00:24:17,950
can reach from anywhere that points to

00:24:13,179 --> 00:24:19,649
this address and now um since you want

00:24:17,950 --> 00:24:23,970
to use this address in the real world

00:24:19,649 --> 00:24:25,750
you want to say well I would like to

00:24:23,970 --> 00:24:30,280
reach

00:24:25,750 --> 00:24:32,350
the Euro BSD Khan website so you say

00:24:30,280 --> 00:24:34,090
well where should I send this packet so

00:24:32,350 --> 00:24:37,870
that it reads a euro bsd come server

00:24:34,090 --> 00:24:39,640
hosting the website well certainly you

00:24:37,870 --> 00:24:40,990
should use the address that's configured

00:24:39,640 --> 00:24:43,420
because if you have only one address

00:24:40,990 --> 00:24:46,960
it's probably the good one but the

00:24:43,420 --> 00:24:49,780
mechanism that that decide that make the

00:24:46,960 --> 00:24:52,060
decision of destination one of the two

00:24:49,780 --> 00:24:55,870
question I was presenting before it's

00:24:52,060 --> 00:24:59,980
done through the routing table so the

00:24:55,870 --> 00:25:05,050
routing table contains route entry that

00:24:59,980 --> 00:25:08,020
I wrote there as RT entry those entries

00:25:05,050 --> 00:25:12,160
say well it's just the pass just the

00:25:08,020 --> 00:25:16,200
route go there but what's interesting in

00:25:12,160 --> 00:25:18,910
our point that those route entry

00:25:16,200 --> 00:25:20,500
appointing also to the address because

00:25:18,910 --> 00:25:24,490
that's address you want to use in the

00:25:20,500 --> 00:25:26,350
end now it appear that the routing table

00:25:24,490 --> 00:25:28,840
is also rectangle so if you follow

00:25:26,350 --> 00:25:31,570
they're not asleep after lunch you get

00:25:28,840 --> 00:25:34,150
that it's also a global structure that's

00:25:31,570 --> 00:25:36,550
what I'm going to talk about why is that

00:25:34,150 --> 00:25:39,370
interesting because when you look at

00:25:36,550 --> 00:25:41,890
this picture I don't know how funny I'll

00:25:39,370 --> 00:25:47,080
familiar you are with multiprocessor

00:25:41,890 --> 00:25:51,000
developments concurrence history but the

00:25:47,080 --> 00:25:54,880
first problem that you have is that well

00:25:51,000 --> 00:25:57,610
if have so many structure we have the

00:25:54,880 --> 00:25:59,460
data of my address and first of all I

00:25:57,610 --> 00:26:04,620
have to make sure that there are

00:25:59,460 --> 00:26:07,300
coherent because if one doesn't get the

00:26:04,620 --> 00:26:09,910
change that I just did on that my

00:26:07,300 --> 00:26:12,280
address what will happen to my network

00:26:09,910 --> 00:26:14,470
well you will find dragons on you on

00:26:12,280 --> 00:26:18,370
your purging system something will break

00:26:14,470 --> 00:26:23,020
and that's that was already a point we

00:26:18,370 --> 00:26:25,870
are not executing accessing this kind of

00:26:23,020 --> 00:26:28,000
resources in parallel but even for

00:26:25,870 --> 00:26:30,510
configuring this resources configuring

00:26:28,000 --> 00:26:34,560
these these global data structures it's

00:26:30,510 --> 00:26:37,419
complicated I won't mention names

00:26:34,560 --> 00:26:40,929
drivers

00:26:37,419 --> 00:26:44,299
but we can talk about it with beers now

00:26:40,929 --> 00:26:48,110
apart from currency as soon as you're

00:26:44,299 --> 00:26:49,940
going to say well I want to add a new

00:26:48,110 --> 00:26:52,850
address and at the same time ask the

00:26:49,940 --> 00:26:56,870
question where which which route should

00:26:52,850 --> 00:27:00,649
I use to send this packet you might end

00:26:56,870 --> 00:27:02,779
up modifying or accessing one of those

00:27:00,649 --> 00:27:08,619
for global structure at the same time

00:27:02,779 --> 00:27:12,350
and put Assembly crashing your Colonel I

00:27:08,619 --> 00:27:17,119
won't go into the detail of why but the

00:27:12,350 --> 00:27:20,419
point is you have to protect somehow

00:27:17,119 --> 00:27:26,360
those global states when you're working

00:27:20,419 --> 00:27:30,830
in in multiple in parallel M programs so

00:27:26,360 --> 00:27:32,960
the question is well ok start looking at

00:27:30,830 --> 00:27:36,350
that without pictures it's an incomplete

00:27:32,960 --> 00:27:39,259
pictures Claudia said and he's right now

00:27:36,350 --> 00:27:44,570
if we look just at that and we say well

00:27:39,259 --> 00:27:50,029
I have to make that code accessing to

00:27:44,570 --> 00:27:52,999
that work in parallel well I wish me

00:27:50,029 --> 00:27:55,850
good luck because I'm already scared

00:27:52,999 --> 00:28:00,559
just as looking the picture the question

00:27:55,850 --> 00:28:03,369
was well if I have to make Dan code

00:28:00,559 --> 00:28:05,960
written in the eighties running parallel

00:28:03,369 --> 00:28:08,149
would it be better first to start to

00:28:05,960 --> 00:28:09,499
simplify it because you see you have

00:28:08,149 --> 00:28:10,850
four different way to reach to your

00:28:09,499 --> 00:28:13,429
address do you really need four

00:28:10,850 --> 00:28:14,990
different ways what the answer is no

00:28:13,429 --> 00:28:16,429
otherwise I wouldn't be giving a talk

00:28:14,990 --> 00:28:22,340
here and that's what I'm going to

00:28:16,429 --> 00:28:23,869
explain but most importantly before

00:28:22,340 --> 00:28:26,240
starting to say well which one of them

00:28:23,869 --> 00:28:28,970
we can use let's say where they're used

00:28:26,240 --> 00:28:32,659
so you have four rectangle for global

00:28:28,970 --> 00:28:34,460
structure you remember this picture well

00:28:32,659 --> 00:28:39,889
the first question we were asking is is

00:28:34,460 --> 00:28:42,200
it for me the packet identifying with

00:28:39,889 --> 00:28:45,049
the receiver of the packet well truth is

00:28:42,200 --> 00:28:47,330
that we use tree of the structure this

00:28:45,049 --> 00:28:50,510
is mainly known in the function for the

00:28:47,330 --> 00:28:55,170
version for the IP protocol in IP input

00:28:50,510 --> 00:28:59,280
once again that's represent how open b54

00:28:55,170 --> 00:29:01,110
and what-what was in open OpenBSD 5 4 i

00:28:59,280 --> 00:29:06,140
will come to what's now right

00:29:01,110 --> 00:29:08,610
um this is I I didn't really check but I

00:29:06,140 --> 00:29:11,700
encourage people from the other BSD to

00:29:08,610 --> 00:29:15,720
go look and I don't know how true it is

00:29:11,700 --> 00:29:17,570
but I assume it's mostly the same now if

00:29:15,720 --> 00:29:20,280
you're supposed to forward the packet

00:29:17,570 --> 00:29:23,910
you're going to access one global

00:29:20,280 --> 00:29:27,360
structure and when you're sending a

00:29:23,910 --> 00:29:30,600
packet at least three of them now you

00:29:27,360 --> 00:29:32,730
have a star here because in the cane of

00:29:30,600 --> 00:29:36,000
your forwarding you're also sending

00:29:32,730 --> 00:29:37,650
obviously but you won't access the

00:29:36,000 --> 00:29:41,940
routing table twice it's one or the

00:29:37,650 --> 00:29:44,790
other so I put it here because you might

00:29:41,940 --> 00:29:47,190
just want to send a packet right in this

00:29:44,790 --> 00:29:49,410
case you will use the routing table in

00:29:47,190 --> 00:29:51,330
the Select interface block that we see

00:29:49,410 --> 00:29:58,790
here that it was printed by the IP

00:29:51,330 --> 00:29:58,790
output function this is me

00:30:00,110 --> 00:30:05,929
well we could include it but it's it's

00:30:03,230 --> 00:30:08,720
it's true to the question to make it

00:30:05,929 --> 00:30:11,750
clear for the code right so we have the

00:30:08,720 --> 00:30:14,679
picture of how scary it is of at least

00:30:11,750 --> 00:30:18,850
one small piece how it scary it is now

00:30:14,679 --> 00:30:20,870
we mostly know in this particular

00:30:18,850 --> 00:30:22,640
functional piece of code which is

00:30:20,870 --> 00:30:24,470
executed when you forward it back in

00:30:22,640 --> 00:30:26,120
where they are accessed that means that

00:30:24,470 --> 00:30:29,559
there are also access and in different

00:30:26,120 --> 00:30:34,280
code paths but I only have 45 minutes

00:30:29,559 --> 00:30:38,450
now the question is what can we do what

00:30:34,280 --> 00:30:45,650
has been done how that change and sadly

00:30:38,450 --> 00:30:47,510
what break in the meantime so first

00:30:45,650 --> 00:30:50,049
question is we have for this global

00:30:47,510 --> 00:30:53,660
structure how can we reduce the number

00:30:50,049 --> 00:30:57,740
to how many of them which one should we

00:30:53,660 --> 00:31:01,309
pick now it's quite easy to say because

00:30:57,740 --> 00:31:05,929
the work has been mostly completely done

00:31:01,309 --> 00:31:08,380
so I wrote down some rules that might be

00:31:05,929 --> 00:31:13,970
useful for other people I don't know

00:31:08,380 --> 00:31:15,910
about the global list the first point I

00:31:13,970 --> 00:31:19,910
explained when I was trying the

00:31:15,910 --> 00:31:23,809
representation of a kernel that just

00:31:19,910 --> 00:31:25,429
boot without configured address that the

00:31:23,809 --> 00:31:27,440
link layer address no matter what kind

00:31:25,429 --> 00:31:29,960
of interface you have no matter if it's

00:31:27,440 --> 00:31:33,020
a real interface not no matter if it has

00:31:29,960 --> 00:31:38,630
a link layer address not has a memory

00:31:33,020 --> 00:31:40,549
chunk which is used by the kernel to

00:31:38,630 --> 00:31:43,160
represent something that should be the

00:31:40,549 --> 00:31:48,169
link layer address so if you always have

00:31:43,160 --> 00:31:50,780
it why would you look for it because you

00:31:48,169 --> 00:31:54,590
know it will be present what would you

00:31:50,780 --> 00:31:56,200
have to search trollese where is it it's

00:31:54,590 --> 00:31:59,840
there don't worry

00:31:56,200 --> 00:32:01,480
so just remove the look the list lookup

00:31:59,840 --> 00:32:05,540
that look for it

00:32:01,480 --> 00:32:07,970
first rule that's quite easy to do and

00:32:05,540 --> 00:32:11,690
quite interesting

00:32:07,970 --> 00:32:14,570
there's a interesting point that that

00:32:11,690 --> 00:32:18,169
about the design of socket ODL that are

00:32:14,570 --> 00:32:20,590
if you're using also user language used

00:32:18,169 --> 00:32:23,629
to to do user land and networking

00:32:20,590 --> 00:32:26,539
programming or works with demons it's an

00:32:23,629 --> 00:32:30,070
interesting API and to take an example

00:32:26,539 --> 00:32:32,179
of something that you should not do I

00:32:30,070 --> 00:32:35,740
won't go into detail but that's quite

00:32:32,179 --> 00:32:38,899
interesting over beer the second rule is

00:32:35,740 --> 00:32:42,379
well I've shown on the picture that you

00:32:38,899 --> 00:32:45,409
have this red arrows right so if if you

00:32:42,379 --> 00:32:48,500
already know which I've FP by FP I mean

00:32:45,409 --> 00:32:49,970
interface right you remember the where

00:32:48,500 --> 00:32:53,480
you port where you're going to plug your

00:32:49,970 --> 00:32:56,259
cable into it the packet is coming true

00:32:53,480 --> 00:32:58,940
or you're supposed to sign it too right

00:32:56,259 --> 00:33:01,179
if you already know that why would you

00:32:58,940 --> 00:33:04,070
lose to to look in all the possible

00:33:01,179 --> 00:33:06,039
interface in your system to find an

00:33:04,070 --> 00:33:08,720
address that you know that is on this

00:33:06,039 --> 00:33:12,200
configured on this IFP on this interface

00:33:08,720 --> 00:33:15,620
well ii will just use this local list as

00:33:12,200 --> 00:33:20,389
i as i named them there's something that

00:33:15,620 --> 00:33:23,000
might be I don't know obvious for some

00:33:20,389 --> 00:33:26,450
people but when you work with code that

00:33:23,000 --> 00:33:29,779
is order that you are some time with

00:33:26,450 --> 00:33:33,669
carry commit messages you end up looking

00:33:29,779 --> 00:33:37,159
at function that you have really no idea

00:33:33,669 --> 00:33:40,429
why doubt doing a loop and something can

00:33:37,159 --> 00:33:43,090
just kill them so you have to go back in

00:33:40,429 --> 00:33:46,129
time look in the sphere Seljuk archives

00:33:43,090 --> 00:33:48,139
say why is that here why did he wrote

00:33:46,129 --> 00:33:53,509
that in the first time oh but it's not

00:33:48,139 --> 00:33:55,789
needed well remove that III

00:33:53,509 --> 00:33:59,500
when I see this kind of chunk whoa I'm

00:33:55,789 --> 00:34:01,789
really really late when I will be late

00:33:59,500 --> 00:34:05,120
when I see this kind of shank I said

00:34:01,789 --> 00:34:06,980
well thankfully I I didn't go deeply

00:34:05,120 --> 00:34:10,099
into protecting those chunk because you

00:34:06,980 --> 00:34:14,240
can simply remove them and finally and I

00:34:10,099 --> 00:34:16,909
will explain a wide bit later um if you

00:34:14,240 --> 00:34:19,520
don't have to use one is just use the

00:34:16,909 --> 00:34:21,260
interface list has to be one will

00:34:19,520 --> 00:34:23,119
just reduce to one

00:34:21,260 --> 00:34:24,950
so here you have some example of what

00:34:23,119 --> 00:34:26,679
I've been changing some function you can

00:34:24,950 --> 00:34:29,690
go look at it

00:34:26,679 --> 00:34:31,490
coming to the interface list I'll be a

00:34:29,690 --> 00:34:35,300
bit short about that but what's our

00:34:31,490 --> 00:34:36,649
interesting in the history of of this

00:34:35,300 --> 00:34:38,290
structure that represent all the

00:34:36,649 --> 00:34:41,149
interface that you have on your system

00:34:38,290 --> 00:34:43,070
when it was what did and what do I

00:34:41,149 --> 00:34:48,369
looked when I look at the history of the

00:34:43,070 --> 00:34:51,050
of the BSD and code and so that in 81

00:34:48,369 --> 00:34:54,619
every interface has only one address so

00:34:51,050 --> 00:34:56,179
you have a perfect match between looking

00:34:54,619 --> 00:34:57,890
at your interface you already got your

00:34:56,179 --> 00:35:00,170
address like I was saying for the for

00:34:57,890 --> 00:35:02,840
the link address and actually those

00:35:00,170 --> 00:35:03,940
function that I used to iterate over

00:35:02,840 --> 00:35:08,840
this list

00:35:03,940 --> 00:35:11,600
we're not named I found but if like

00:35:08,840 --> 00:35:13,910
interface what's really interesting is

00:35:11,600 --> 00:35:16,940
that when you look at this code none of

00:35:13,910 --> 00:35:19,700
this code wants an address they wants to

00:35:16,940 --> 00:35:21,080
know the interface which are the rest or

00:35:19,700 --> 00:35:24,560
they want to know if an interface has an

00:35:21,080 --> 00:35:28,580
address so we are we have a lot of use

00:35:24,560 --> 00:35:30,080
less code because this API got written

00:35:28,580 --> 00:35:35,540
for something totally differently that

00:35:30,080 --> 00:35:36,920
is useful now when in 85 the structure

00:35:35,540 --> 00:35:38,770
that I presented before that

00:35:36,920 --> 00:35:41,450
representing an address got introduced

00:35:38,770 --> 00:35:44,210
well the loop that used to be just

00:35:41,450 --> 00:35:48,830
iterating over one list of interface

00:35:44,210 --> 00:35:50,510
matching addresses that's God change

00:35:48,830 --> 00:35:53,300
into a loop iterating over the interface

00:35:50,510 --> 00:35:56,359
and a loop for each interface iterating

00:35:53,300 --> 00:35:57,830
over addresses which in some system

00:35:56,359 --> 00:36:00,800
right now when you have a lot of

00:35:57,830 --> 00:36:03,800
interface a lot of addresses is really

00:36:00,800 --> 00:36:06,859
slow looking on this list that's why in

00:36:03,800 --> 00:36:11,109
2010 a tree red black tree was

00:36:06,859 --> 00:36:13,850
introduced to make this look at faster

00:36:11,109 --> 00:36:18,080
an interesting point is the other

00:36:13,850 --> 00:36:20,630
structure I was talking about the per

00:36:18,080 --> 00:36:23,240
protocol address that's the name of the

00:36:20,630 --> 00:36:25,640
ipv4 version also got introduced in 85

00:36:23,240 --> 00:36:28,160
basically I couldn't find the reason why

00:36:25,640 --> 00:36:29,930
it's really easier to write code when

00:36:28,160 --> 00:36:33,850
you know that all the IP address are

00:36:29,930 --> 00:36:38,020
there instead of all the addresses

00:36:33,850 --> 00:36:42,250
this list is used in the version Cal for

00:36:38,020 --> 00:36:46,030
the protocol and this one too that was

00:36:42,250 --> 00:36:48,480
replaced by their the by the red black

00:36:46,030 --> 00:36:51,610
tree as I presented before the slide

00:36:48,480 --> 00:36:56,050
when you decide to forward the packet to

00:36:51,610 --> 00:36:57,610
know is it my address one interesting

00:36:56,050 --> 00:37:00,040
part is that when the ipv6 got

00:36:57,610 --> 00:37:03,580
integrated and came people explain the

00:37:00,040 --> 00:37:05,520
choice they did in 99 and say we will go

00:37:03,580 --> 00:37:08,860
we will use the routing table for that

00:37:05,520 --> 00:37:10,720
to know if the address that's the

00:37:08,860 --> 00:37:14,920
destination of the packet is our our

00:37:10,720 --> 00:37:19,720
system or not they use basically hack to

00:37:14,920 --> 00:37:24,280
do that but that's where we are now in

00:37:19,720 --> 00:37:27,010
open BSD the solution or the evolution

00:37:24,280 --> 00:37:29,820
of the network hack is to use the

00:37:27,010 --> 00:37:35,500
routing table for all those operation

00:37:29,820 --> 00:37:37,590
regarding searching an address routing

00:37:35,500 --> 00:37:39,850
table are not really used for that or

00:37:37,590 --> 00:37:42,940
we're not designed for that but we can

00:37:39,850 --> 00:37:46,000
use that so what I did is consolidate

00:37:42,940 --> 00:37:48,610
what I call the loopback hack that came

00:37:46,000 --> 00:37:50,680
implemented that just say well if this

00:37:48,610 --> 00:37:52,420
address is figured on your system that

00:37:50,680 --> 00:37:54,700
it's somehow related to your loopback

00:37:52,420 --> 00:38:01,540
address I hope you back address the low

00:37:54,700 --> 00:38:03,640
zero something the consolidation camera

00:38:01,540 --> 00:38:06,400
is an indication with flag okay this

00:38:03,640 --> 00:38:09,910
route represent a local address so it

00:38:06,400 --> 00:38:12,930
goes to local flu flag for ipv4 we need

00:38:09,910 --> 00:38:15,130
also the information of the broadcast

00:38:12,930 --> 00:38:17,590
addresses that are associated to your

00:38:15,130 --> 00:38:20,080
unicast addresses so we also have this

00:38:17,590 --> 00:38:24,850
information like we had route to sun

00:38:20,080 --> 00:38:28,750
nets now with this change we can go to

00:38:24,850 --> 00:38:30,700
only one global structure so no problem

00:38:28,750 --> 00:38:34,200
of Korea coherency between the structure

00:38:30,700 --> 00:38:37,390
only one focus that we have to protect

00:38:34,200 --> 00:38:39,220
then we have to think about how to use

00:38:37,390 --> 00:38:43,210
it will correctly use it to be run on

00:38:39,220 --> 00:38:46,240
multiple CPU and the tests that we run

00:38:43,210 --> 00:38:47,380
in order to choose the solution and that

00:38:46,240 --> 00:38:49,779
will also confirm

00:38:47,380 --> 00:38:52,779
by the paper talking about the red black

00:38:49,779 --> 00:38:55,240
tree all the paper and that that was

00:38:52,779 --> 00:38:57,279
written for from the cab came guy that

00:38:55,240 --> 00:38:59,589
is not slower faster than the actual

00:38:57,279 --> 00:39:04,660
tree that we are using for looking

00:38:59,589 --> 00:39:06,400
addresses since I don't have time I will

00:39:04,660 --> 00:39:09,579
skip this slide that was a good example

00:39:06,400 --> 00:39:12,549
of why you need to change the structure

00:39:09,579 --> 00:39:14,890
and I will get it directly to some

00:39:12,549 --> 00:39:16,930
related terms because I'm here focusing

00:39:14,890 --> 00:39:19,619
on the forwarding path and the global

00:39:16,930 --> 00:39:24,369
structure but thinking about how to make

00:39:19,619 --> 00:39:26,559
a subsystem or an entire kernel and I

00:39:24,369 --> 00:39:30,069
would say NP safer or easier to run on

00:39:26,559 --> 00:39:33,789
multiple CPU can lead you to rethink

00:39:30,069 --> 00:39:37,529
completely the design of the subsystem

00:39:33,789 --> 00:39:40,240
of those programs so as I said before

00:39:37,529 --> 00:39:43,359
removing the loops of the further link

00:39:40,240 --> 00:39:45,359
layer address my mean that we can simply

00:39:43,359 --> 00:39:47,710
remove the link address from any list

00:39:45,359 --> 00:39:52,150
that's information that I don't have to

00:39:47,710 --> 00:39:53,440
put in the routing table I already

00:39:52,150 --> 00:39:57,670
mentioned that there were many dragon in

00:39:53,440 --> 00:40:02,170
there so I won't expand the option that

00:39:57,670 --> 00:40:05,319
was describing in in in tcp/ip volume 2

00:40:02,170 --> 00:40:09,670
I guess of so don't routes that you can

00:40:05,319 --> 00:40:13,809
set on socket which is defined as used

00:40:09,670 --> 00:40:15,369
to bypass the routing table is just

00:40:13,809 --> 00:40:16,900
ignored on on open busy right now

00:40:15,369 --> 00:40:18,640
because we don't want to bypass a

00:40:16,900 --> 00:40:21,789
routing table anymore we just want to

00:40:18,640 --> 00:40:24,490
use a routing table we can reemployment

00:40:21,789 --> 00:40:27,160
it differently but it's easier to get

00:40:24,490 --> 00:40:28,930
rid of the old code and if somebody

00:40:27,160 --> 00:40:32,619
really needs that just come talk to me

00:40:28,930 --> 00:40:41,819
and we see what we can do I doubt it

00:40:32,619 --> 00:40:45,190
now now for reason regarding and

00:40:41,819 --> 00:40:47,440
dangling pointers and when you try it's

00:40:45,190 --> 00:40:49,509
really related to what what Ted you

00:40:47,440 --> 00:40:51,839
talked this morning right you try to

00:40:49,509 --> 00:40:56,109
access the memory or something that got

00:40:51,839 --> 00:40:57,789
removed or replaced and that is really

00:40:56,109 --> 00:41:00,190
easy to trigger if you start having

00:40:57,789 --> 00:41:01,059
multiple processor because one might

00:41:00,190 --> 00:41:03,039
remove something

00:41:01,059 --> 00:41:08,199
and the other want to access at the same

00:41:03,039 --> 00:41:10,439
time so there is some trick that's

00:41:08,199 --> 00:41:14,529
that's basically some computer science

00:41:10,439 --> 00:41:19,319
solution and one of them was to to to

00:41:14,529 --> 00:41:23,439
use a big table where every index of

00:41:19,319 --> 00:41:25,359
interface every every chunk in this

00:41:23,439 --> 00:41:26,799
table hold the pointer to an interface

00:41:25,359 --> 00:41:30,099
so we don't need to use the pointer

00:41:26,799 --> 00:41:32,739
directly we just given index give it

00:41:30,099 --> 00:41:34,329
token and get back a pointer if the

00:41:32,739 --> 00:41:36,640
pointer get cleared that means that the

00:41:34,329 --> 00:41:40,900
object is gone if not that means it's

00:41:36,640 --> 00:41:42,309
here that is interesting because we we

00:41:40,900 --> 00:41:44,199
already have a lot of pointers

00:41:42,309 --> 00:41:47,169
everywhere because when this subsystem

00:41:44,199 --> 00:41:50,799
was written things were not so plug and

00:41:47,169 --> 00:41:53,789
playing there were only one CPU it was

00:41:50,799 --> 00:41:57,549
much more easier to maintain currency

00:41:53,789 --> 00:42:01,599
and finally we replace some function

00:41:57,549 --> 00:42:04,209
that we're using a global buffer to use

00:42:01,599 --> 00:42:07,059
a buffer pass on the stack that's the

00:42:04,209 --> 00:42:10,269
last part of this slide now where we are

00:42:07,059 --> 00:42:11,679
after all this change well it's

00:42:10,269 --> 00:42:15,909
basically the conclusion of the work

00:42:11,679 --> 00:42:18,999
right and we are almost on time that's

00:42:15,909 --> 00:42:21,749
how it looks like now I don't know if

00:42:18,999 --> 00:42:27,339
you remember the previous previous scary

00:42:21,749 --> 00:42:28,659
representation right we were here and we

00:42:27,339 --> 00:42:30,039
are here right you don't need to

00:42:28,659 --> 00:42:35,669
understand what's on the slide or what

00:42:30,039 --> 00:42:35,669
links but it's simpler it looks simpler

00:42:36,630 --> 00:42:41,799
now where this is used so you see that

00:42:40,089 --> 00:42:44,709
you have to rectangle right routing

00:42:41,799 --> 00:42:47,699
table and there interface list well in

00:42:44,709 --> 00:42:52,599
the chunk of code that I was analyzing

00:42:47,699 --> 00:42:54,429
before well we are using that and the

00:42:52,599 --> 00:42:58,900
storming that you are using here or

00:42:54,429 --> 00:43:01,029
there so we move from trickable

00:42:58,900 --> 00:43:06,869
structure here and basically tree here

00:43:01,029 --> 00:43:09,600
to just one in the wall code path I'm

00:43:06,869 --> 00:43:11,980
almost not lying

00:43:09,600 --> 00:43:16,150
some bits are not yet integrated in

00:43:11,980 --> 00:43:19,480
OpenBSD right this is what I have in my

00:43:16,150 --> 00:43:20,830
development environment now you can look

00:43:19,480 --> 00:43:23,110
at the code if you are interested in two

00:43:20,830 --> 00:43:25,690
on the on the mailing list we use to

00:43:23,110 --> 00:43:27,220
share and to cut review that you can

00:43:25,690 --> 00:43:28,900
even review it if you're not a developer

00:43:27,220 --> 00:43:34,000
that's really interesting you can run it

00:43:28,900 --> 00:43:35,440
can test it um they're still there the

00:43:34,000 --> 00:43:38,260
second point means that is still link

00:43:35,440 --> 00:43:40,600
between the interface and the routing

00:43:38,260 --> 00:43:44,170
entry that that I uh it's not removed

00:43:40,600 --> 00:43:47,770
yet but that's that's a part of the of

00:43:44,170 --> 00:43:49,119
the removal of the came tag and I was

00:43:47,770 --> 00:43:50,770
lying when I was saying there's only one

00:43:49,119 --> 00:43:53,650
lookup I'm sorry

00:43:50,770 --> 00:43:56,350
with the DIF that I sent we are actually

00:43:53,650 --> 00:43:58,780
in the forwarding case doing one look up

00:43:56,350 --> 00:44:01,480
here and another one here but that's

00:43:58,780 --> 00:44:04,869
just some code shuffling to have only

00:44:01,480 --> 00:44:08,770
one instead of two hopefully that will

00:44:04,869 --> 00:44:10,690
be integrated in five seven well depend

00:44:08,770 --> 00:44:14,800
how many dragon this will find so I hope

00:44:10,690 --> 00:44:19,650
you will test it concluding we are late

00:44:14,800 --> 00:44:21,820
but let's go for conclusion so

00:44:19,650 --> 00:44:25,660
refactoring thirty years old code is

00:44:21,820 --> 00:44:28,420
hard but well pretty good story that you

00:44:25,660 --> 00:44:30,400
know which person is to blame so you

00:44:28,420 --> 00:44:32,230
could you will be borrow maybe some of

00:44:30,400 --> 00:44:34,750
you on future developer will blame me

00:44:32,230 --> 00:44:37,540
later for being don't think that are not

00:44:34,750 --> 00:44:41,730
adapted to shoot to software hopefully

00:44:37,540 --> 00:44:46,030
peers you will still be used now and

00:44:41,730 --> 00:44:51,880
since a number of people working on this

00:44:46,030 --> 00:44:54,010
refactoring is me and myself it's quite

00:44:51,880 --> 00:44:56,920
difficult to get feedback from people so

00:44:54,010 --> 00:44:58,810
I find dragons every of those change

00:44:56,920 --> 00:45:02,020
that are presented break at least one

00:44:58,810 --> 00:45:04,510
set up it's not a feature it's not

00:45:02,020 --> 00:45:05,980
interesting it's not cool nobody wants

00:45:04,510 --> 00:45:07,359
to look at it and when they look at it

00:45:05,980 --> 00:45:09,850
they know that will break something so

00:45:07,359 --> 00:45:10,869
that's quite hard that's why I

00:45:09,850 --> 00:45:13,300
understanding what you're changing is

00:45:10,869 --> 00:45:15,250
important and I hope that what I

00:45:13,300 --> 00:45:19,840
presented here has a slide that that can

00:45:15,250 --> 00:45:23,920
be a compliment to to design of the of

00:45:19,840 --> 00:45:26,530
the networking stack on base G colonel

00:45:23,920 --> 00:45:29,080
is interesting because you have how

00:45:26,530 --> 00:45:31,860
basically it was in the eighties and how

00:45:29,080 --> 00:45:34,570
its evolving or how it is right now

00:45:31,860 --> 00:45:36,490
sadly there's still a lot of work to do

00:45:34,570 --> 00:45:39,430
in the picture that you've seen are

00:45:36,490 --> 00:45:43,690
really simple compared to what's missing

00:45:39,430 --> 00:45:45,760
so we find a lot of dragon oh I'm too

00:45:43,690 --> 00:45:47,770
fast that's what it's bet it so I should

00:45:45,760 --> 00:46:09,370
have any question I'll try to answer

00:45:47,770 --> 00:46:12,220
them a year ago I read a paper about the

00:46:09,370 --> 00:46:16,650
multipath OpenBSD support and threw out

00:46:12,220 --> 00:46:20,350
preferences in the end of the paper

00:46:16,650 --> 00:46:22,570
people say it's very good but it's very

00:46:20,350 --> 00:46:25,140
dangerous there are many dragons I would

00:46:22,570 --> 00:46:27,610
like to know if it is has changed

00:46:25,140 --> 00:46:30,310
something has changed but there's still

00:46:27,610 --> 00:46:33,310
a lot of dragons if you want to have

00:46:30,310 --> 00:46:35,410
more detail about that I recommend you

00:46:33,310 --> 00:46:39,700
to talk with claudio that is trying to

00:46:35,410 --> 00:46:42,220
tamp those dragons to where I'm not the

00:46:39,700 --> 00:46:44,620
expert on that subject I'm just here to

00:46:42,220 --> 00:46:47,250
put more pressure on the subsystem to

00:46:44,620 --> 00:46:47,250
make it break

00:46:54,090 --> 00:46:58,390
actually the dissertation on the on the

00:46:56,470 --> 00:47:00,580
slide is coming from this area of the

00:46:58,390 --> 00:47:11,320
code so that might hands are your

00:47:00,580 --> 00:47:13,840
question a few other questions do you

00:47:11,320 --> 00:47:14,860
have any test results after you make

00:47:13,840 --> 00:47:17,740
these changes

00:47:14,860 --> 00:47:19,990
I mean how fast is it now and what

00:47:17,740 --> 00:47:23,410
actually how long it took to make these

00:47:19,990 --> 00:47:25,420
changes and know what pending changes

00:47:23,410 --> 00:47:28,750
you do have you said it will be released

00:47:25,420 --> 00:47:30,910
in one year from today about hopefully

00:47:28,750 --> 00:47:37,860
like a tricky tricky question at the

00:47:30,910 --> 00:47:37,860
time the first one was what can you

00:47:38,460 --> 00:47:43,960
performance tests and the performance

00:47:41,260 --> 00:47:48,250
testers have I here to make sure that

00:47:43,960 --> 00:47:50,910
it's not slower and not not at least

00:47:48,250 --> 00:47:53,740
because I'm not interesting right now

00:47:50,910 --> 00:47:56,220
into gaining performances I'm

00:47:53,740 --> 00:47:58,420
interesting into refactoring the

00:47:56,220 --> 00:48:01,560
simplification the code so that we it

00:47:58,420 --> 00:48:04,270
makes easier to gain performances not do

00:48:01,560 --> 00:48:09,040
twice at the same time that will be

00:48:04,270 --> 00:48:12,400
horrible but most of the function that I

00:48:09,040 --> 00:48:16,810
change well most of them some of them I

00:48:12,400 --> 00:48:19,450
was talking about useless lookups so for

00:48:16,810 --> 00:48:22,090
in particular cases for example with the

00:48:19,450 --> 00:48:24,730
cab driver you you have performance

00:48:22,090 --> 00:48:28,390
improvement because you do less lookups

00:48:24,730 --> 00:48:31,300
but that's really insane effect that's

00:48:28,390 --> 00:48:34,300
one two persons it's not the aim of the

00:48:31,300 --> 00:48:36,280
work right and you say what I was saying

00:48:34,300 --> 00:48:40,420
about when it will be integrated right

00:48:36,280 --> 00:48:44,290
and this little slide about where it is

00:48:40,420 --> 00:48:48,250
right now is a slide that where how it

00:48:44,290 --> 00:48:50,770
will be when the defy sent beginning of

00:48:48,250 --> 00:48:54,960
the week will be integrated hopefully in

00:48:50,770 --> 00:48:54,960
the next weeks or months right and

00:48:55,770 --> 00:49:02,790
that's that's answer your question any

00:49:00,310 --> 00:49:02,790
other question

00:49:03,090 --> 00:49:14,660
don't be shy gone let's thank our

00:49:08,610 --> 00:49:14,660

YouTube URL: https://www.youtube.com/watch?v=OYqrfUw-P3E


