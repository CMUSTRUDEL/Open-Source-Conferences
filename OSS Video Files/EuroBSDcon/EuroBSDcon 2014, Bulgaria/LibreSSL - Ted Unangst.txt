Title: LibreSSL - Ted Unangst
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

A walkthrough of the changes the OpenBSD team has made to the OpenSSL (now LibreSSL) codebase in order to conduct an audit. Design flaws in a code base can quickly turn into real flaws. Often, a second design flaw then masks the existence of the first flaw, making it difficult to fix. We’ve tried to reveal, if not correct, many of these flaws by simpliyfing and reducing the code. Along the way, we’ve made some mistakes as well.

Speaker biography:

I have been an OpenBSD developer for 11 years, working in many areas, but have recently been spending a lot of time in the libssl directory. I stumbled into, and possibly initiated, LibreSSL development after trying to determine why OpenBSD’s exploit mitigation tachniques were useless against Heartbleed.
Captions: 
	00:00:11,160 --> 00:00:15,980
more than 30 days later

00:00:13,660 --> 00:00:18,260
so Leah SSL

00:00:15,980 --> 00:00:23,750
to the world just about exactly five

00:00:18,260 --> 00:00:26,029
months ago and Bob gave a pop up talk at

00:00:23,750 --> 00:00:29,210
BST can about everything that happened

00:00:26,029 --> 00:00:31,730
in the first 30 days so for those of you

00:00:29,210 --> 00:00:34,250
who weren't there I'm gonna view a

00:00:31,730 --> 00:00:37,190
little bit of that material but I think

00:00:34,250 --> 00:00:41,239
it's better to watch it online if you

00:00:37,190 --> 00:00:44,030
care so then I'm gonna move on to some

00:00:41,239 --> 00:00:46,970
of the newer updates and what's been

00:00:44,030 --> 00:00:54,050
happening in the 30 days or in the four

00:00:46,970 --> 00:00:58,520
months after those first 30 days so

00:00:54,050 --> 00:01:02,239
let's review what is open SSL because

00:00:58,520 --> 00:01:05,810
Lieber SSL is a fork of the popular open

00:01:02,239 --> 00:01:08,179
SSL crypto and TLS library and TLS is

00:01:05,810 --> 00:01:10,880
the standard name for the SSL protocol

00:01:08,179 --> 00:01:13,399
which is that other secure transport

00:01:10,880 --> 00:01:17,240
protocol that was developed in the 90s

00:01:13,399 --> 00:01:19,550
and it's used for HTTP most notably but

00:01:17,240 --> 00:01:21,440
also IMAP SMTP and pretty much

00:01:19,550 --> 00:01:23,390
everything

00:01:21,440 --> 00:01:25,819
probably most apply in traffic for

00:01:23,390 --> 00:01:28,069
end-users on the Internet today is

00:01:25,819 --> 00:01:30,830
encrypted with TLS so it's pretty

00:01:28,069 --> 00:01:33,380
important and there's a couple

00:01:30,830 --> 00:01:39,080
implementations but really it boils down

00:01:33,380 --> 00:01:42,800
to two and open SSL is or was the de

00:01:39,080 --> 00:01:45,789
facto standard for servers and also for

00:01:42,800 --> 00:01:49,250
a lot of clients the main alternative

00:01:45,789 --> 00:01:51,979
client library is NSS the Netscape

00:01:49,250 --> 00:01:54,880
security services library which is used

00:01:51,979 --> 00:01:59,179
by browsers such as Firefox and Chrome

00:01:54,880 --> 00:02:02,810
but if you didn't upgrade and assess

00:01:59,179 --> 00:02:05,209
last week you should go do that and so

00:02:02,810 --> 00:02:08,450
you know there's bugs in all TLS

00:02:05,209 --> 00:02:10,970
libraries and that's because

00:02:08,450 --> 00:02:14,420
cryptography in general is very hard and

00:02:10,970 --> 00:02:16,670
TLS in particular is pretty difficult to

00:02:14,420 --> 00:02:18,349
get right the TLS protocols has been

00:02:16,670 --> 00:02:20,930
hacked on and hacked on and hacked on

00:02:18,349 --> 00:02:22,400
over the years where they find bugs and

00:02:20,930 --> 00:02:24,200
then they try to fix it and then they

00:02:22,400 --> 00:02:26,409
find a bug and the workaround and try to

00:02:24,200 --> 00:02:28,870
fix that and then they tell you to use

00:02:26,409 --> 00:02:31,000
CBC mode no use RC

00:02:28,870 --> 00:02:34,150
no don't do that either use like a es

00:02:31,000 --> 00:02:36,370
but not block mode do something else and

00:02:34,150 --> 00:02:39,400
so there's all these workarounds to

00:02:36,370 --> 00:02:42,250
defeat and mitigate many attacks and so

00:02:39,400 --> 00:02:49,569
leads to a pretty ugly implementation

00:02:42,250 --> 00:02:51,910
problem now so as I mentioned OpenSSL

00:02:49,569 --> 00:02:53,349
kind of dominates in the server space so

00:02:51,910 --> 00:02:55,870
there's pretty much a monoculture

00:02:53,349 --> 00:02:58,510
there and that isn't strictly a bad

00:02:55,870 --> 00:03:00,010
thing because hey you know let's put all

00:02:58,510 --> 00:03:04,120
our eggs in one basket and it will wash

00:03:00,010 --> 00:03:08,440
that basket very carefully the problem

00:03:04,120 --> 00:03:10,450
is nobody was watching the basket so and

00:03:08,440 --> 00:03:12,670
then I think that also kind of led to a

00:03:10,450 --> 00:03:14,769
mentality where well I'll use open SSL

00:03:12,670 --> 00:03:16,870
and yeah I'll get burned by some bugs

00:03:14,769 --> 00:03:19,930
but everybody else will get burned by

00:03:16,870 --> 00:03:23,349
bugs so I won't be any worse than

00:03:19,930 --> 00:03:25,180
anybody else out there kind of bizarre

00:03:23,349 --> 00:03:32,790
mindset but you know it's kind of how

00:03:25,180 --> 00:03:35,670
people run do things and so let's

00:03:32,790 --> 00:03:39,850
fast-forward past a hundred other bugs

00:03:35,670 --> 00:03:41,549
and open SSL to heartbleed also known as

00:03:39,850 --> 00:03:44,079
the worst bug in the history of ever

00:03:41,549 --> 00:03:47,380
although that title is pretty heavily

00:03:44,079 --> 00:03:50,260
contested I hear Bash has announced it

00:03:47,380 --> 00:03:55,060
is entering the contest for where's the

00:03:50,260 --> 00:03:58,599
blog ever so what was unusual about

00:03:55,060 --> 00:04:00,700
heartbleed as far as I can tell it was

00:03:58,599 --> 00:04:03,579
kind of unique because it was a

00:04:00,700 --> 00:04:08,139
vulnerability instead of an exploit that

00:04:03,579 --> 00:04:09,760
got a name and a website and a logo but

00:04:08,139 --> 00:04:12,579
previously you know we'd seen the

00:04:09,760 --> 00:04:15,280
Internet worm the code red blaster

00:04:12,579 --> 00:04:18,039
Stuxnet and really the only difference

00:04:15,280 --> 00:04:20,739
there is we named the exploits we didn't

00:04:18,039 --> 00:04:23,050
name the vulnerability I don't think I

00:04:20,739 --> 00:04:26,190
mean can anybody give me the name of the

00:04:23,050 --> 00:04:29,590
vulnerabilities that Stuxnet exploited

00:04:26,190 --> 00:04:31,419
but you know heartbleed can't even be

00:04:29,590 --> 00:04:34,240
considered the worst open a cell open

00:04:31,419 --> 00:04:36,250
SSL vulnerability previous bugs of

00:04:34,240 --> 00:04:39,490
worship and numerous have resulted in

00:04:36,250 --> 00:04:40,760
remote code execution in fact about 10

00:04:39,490 --> 00:04:45,920
years ago there was a

00:04:40,760 --> 00:04:50,240
worm called flapper and that exploited a

00:04:45,920 --> 00:04:53,620
bug which had the sexy title of SS LV to

00:04:50,240 --> 00:04:56,930
client master key buffer overflow and

00:04:53,620 --> 00:04:59,540
that gave up not just the encrypted data

00:04:56,930 --> 00:05:01,460
on your Apache server it also gave up

00:04:59,540 --> 00:05:04,070
the private key because what code

00:05:01,460 --> 00:05:06,230
execution gives up everything gave you

00:05:04,070 --> 00:05:08,390
remote shell on the server and then the

00:05:06,230 --> 00:05:10,520
worm propagated itself to other servers

00:05:08,390 --> 00:05:12,740
so yeah that was probably worse than

00:05:10,520 --> 00:05:17,090
heartbleed but it didn't get headlines

00:05:12,740 --> 00:05:19,220
so yeah you know whatever know the

00:05:17,090 --> 00:05:22,010
reason I'm kind of going on and on about

00:05:19,220 --> 00:05:24,920
this is just to reinforce that leer SSL

00:05:22,010 --> 00:05:29,120
is not the result of the worst bug ever

00:05:24,920 --> 00:05:31,490
it wasn't one bug and so you know I may

00:05:29,120 --> 00:05:33,410
call you dirty names but I'm not going

00:05:31,490 --> 00:05:41,530
to fork your project on the basis of one

00:05:33,410 --> 00:05:47,300
missing overflow check okay so why fork

00:05:41,530 --> 00:05:49,880
open SSL Libre SSL is here because of a

00:05:47,300 --> 00:05:53,570
kind of tragic comedy of other errors

00:05:49,880 --> 00:05:55,700
and we'll start with the obvious why

00:05:53,570 --> 00:05:58,790
we're heartbeats which is a feature only

00:05:55,700 --> 00:06:02,150
useful for the D TLS protocol over UDP

00:05:58,790 --> 00:06:05,090
built into the TLS protocol that runs

00:06:02,150 --> 00:06:07,900
over TCP and why was this entirely

00:06:05,090 --> 00:06:11,270
useless feature enabled by default

00:06:07,900 --> 00:06:13,010
and so we looked into that and then we

00:06:11,270 --> 00:06:14,840
asked ourselves some other questions

00:06:13,010 --> 00:06:17,150
then we dug a little deeper and then we

00:06:14,840 --> 00:06:18,620
asked we saw this nonsense with some

00:06:17,150 --> 00:06:21,020
buffer allocator and then there's some

00:06:18,620 --> 00:06:23,300
nonsense with free lists and exploit

00:06:21,020 --> 00:06:24,950
mitigation countermeasures and you know

00:06:23,300 --> 00:06:27,620
we keep on digging and we keep on

00:06:24,950 --> 00:06:30,380
finding stuff we don't like Bob stock

00:06:27,620 --> 00:06:31,400
has a lot more detail on that so I'll

00:06:30,380 --> 00:06:34,300
just cut to the chase

00:06:31,400 --> 00:06:38,300
why Fork why not start over from scratch

00:06:34,300 --> 00:06:40,640
we got to start somewhere and as I said

00:06:38,300 --> 00:06:43,370
TLS is a very complicated protocol it's

00:06:40,640 --> 00:06:44,930
built on piles and piles of hacks and so

00:06:43,370 --> 00:06:45,730
if you start from scratch today you're

00:06:44,930 --> 00:06:48,380
gonna have a hard time

00:06:45,730 --> 00:06:52,640
interoperating with other real world

00:06:48,380 --> 00:06:53,700
implementations and also the libra SSL

00:06:52,640 --> 00:06:56,190
team we have

00:06:53,700 --> 00:06:59,820
more experience in secure coding than

00:06:56,190 --> 00:07:02,730
necessarily the TLS protocol I know how

00:06:59,820 --> 00:07:05,430
to free memory after I'm done using it

00:07:02,730 --> 00:07:07,050
but not before I'm done using it and so

00:07:05,430 --> 00:07:09,300
I can find those kinds of bugs in a

00:07:07,050 --> 00:07:12,240
library much more easily than I can

00:07:09,300 --> 00:07:14,670
analyze the state machine of protocols

00:07:12,240 --> 00:07:17,580
complexes TLS and so I didn't want to be

00:07:14,670 --> 00:07:20,130
messing with the hard bits while there

00:07:17,580 --> 00:07:25,650
was still a lot of comparatively easy

00:07:20,130 --> 00:07:28,800
fixes to be made and why not start with

00:07:25,650 --> 00:07:30,090
some other library side reality is all

00:07:28,800 --> 00:07:34,320
the other libraries are pretty much

00:07:30,090 --> 00:07:36,330
equally bad if you may recall not so

00:07:34,320 --> 00:07:38,520
long before heartbleed there was the

00:07:36,330 --> 00:07:42,360
Apple go to fail bug which at the time

00:07:38,520 --> 00:07:44,850
was also the worst bug ever you know so

00:07:42,360 --> 00:07:46,770
pretty much par for the course that your

00:07:44,850 --> 00:07:53,150
TLS library is gonna have the worst bug

00:07:46,770 --> 00:07:56,430
ever on a regular basis all right so

00:07:53,150 --> 00:07:59,130
what have we done in libros a cell we

00:07:56,430 --> 00:08:01,530
gutted the junk and then we rewrote a

00:07:59,130 --> 00:08:03,750
bunch of functions and then we added a

00:08:01,530 --> 00:08:10,290
couple cool new things and that's pretty

00:08:03,750 --> 00:08:13,710
much what i'm gonna talk about today all

00:08:10,290 --> 00:08:16,800
right so let's look at some POSIX code

00:08:13,710 --> 00:08:18,600
here and I could probably spend you you

00:08:16,800 --> 00:08:20,610
know I could talk for a full hour

00:08:18,600 --> 00:08:23,490
explaining why supporting obsolete

00:08:20,610 --> 00:08:25,940
broken systems is a terrible idea and

00:08:23,490 --> 00:08:28,860
detrimental to your overall code quality

00:08:25,940 --> 00:08:30,930
and but unfortunately if I told you all

00:08:28,860 --> 00:08:33,060
the things that I have learned about VMs

00:08:30,930 --> 00:08:38,790
it would probably violate your human

00:08:33,060 --> 00:08:42,120
rights so instead I think this one

00:08:38,790 --> 00:08:44,099
example will suffice this is you know

00:08:42,120 --> 00:08:46,740
obviously a cut-down example of code

00:08:44,099 --> 00:08:49,680
from open SSL but you know there's some

00:08:46,740 --> 00:08:51,660
if def checking for a define than where

00:08:49,680 --> 00:08:53,010
we got some great working code and then

00:08:51,660 --> 00:08:55,050
if the defines not there we got some

00:08:53,010 --> 00:08:56,760
crappy workaround which tries to run on

00:08:55,050 --> 00:09:00,030
you know whatever platforms don't have

00:08:56,760 --> 00:09:02,880
non-blocking i/o now in theory you know

00:09:00,030 --> 00:09:04,500
this is a reasonable kind of thing but

00:09:02,880 --> 00:09:06,510
there's one small problem

00:09:04,500 --> 00:09:09,930
the code is testing for this

00:09:06,510 --> 00:09:12,870
macro that macro is only defined if you

00:09:09,930 --> 00:09:15,030
include the F control H header if you

00:09:12,870 --> 00:09:17,460
forget to include the header the macro

00:09:15,030 --> 00:09:20,130
doesn't get defined and then the crappy

00:09:17,460 --> 00:09:22,560
workaround code runs guess what header

00:09:20,130 --> 00:09:26,220
the file that this code came from forgot

00:09:22,560 --> 00:09:28,440
to include the working code was never

00:09:26,220 --> 00:09:29,040
executed on any platform even when it

00:09:28,440 --> 00:09:30,960
would have worked

00:09:29,040 --> 00:09:33,990
instead the crappy workaround always

00:09:30,960 --> 00:09:35,760
existed so this is a problem where you

00:09:33,990 --> 00:09:39,810
have workarounds and they get picked up

00:09:35,760 --> 00:09:41,550
accidentally because by permitting bad

00:09:39,810 --> 00:09:43,620
code to exist you pretty much

00:09:41,550 --> 00:09:45,480
guaranteeing that the bad code is going

00:09:43,620 --> 00:09:53,870
to continue to exist and actually be

00:09:45,480 --> 00:09:56,850
executed all right so I kind of lied

00:09:53,870 --> 00:09:59,010
there's this picture was just too good

00:09:56,850 --> 00:10:02,130
and the sock auntie workaround and open

00:09:59,010 --> 00:10:04,800
SSL was too horrible to skip over this

00:10:02,130 --> 00:10:09,350
has been talked about before but I you

00:10:04,800 --> 00:10:11,880
know I love the picture too much so

00:10:09,350 --> 00:10:14,070
here's the problem you want to create a

00:10:11,880 --> 00:10:17,520
variable and you want that variable to

00:10:14,070 --> 00:10:18,240
be the same size as sock monkey how do

00:10:17,520 --> 00:10:21,210
you do this

00:10:18,240 --> 00:10:23,210
well one fairly obvious solution would

00:10:21,210 --> 00:10:24,450
be to declare a variable with type

00:10:23,210 --> 00:10:28,390
cilenti

00:10:24,450 --> 00:10:31,880
that's not how open SSL does it

00:10:28,390 --> 00:10:35,030
instead let's create a union of a couple

00:10:31,880 --> 00:10:37,940
different intz of different sizes then

00:10:35,030 --> 00:10:40,370
we'll call accept and then we'll inspect

00:10:37,940 --> 00:10:42,410
the different fields of the Union to see

00:10:40,370 --> 00:10:45,980
which one's the kernel overwrote and

00:10:42,410 --> 00:10:48,770
that will tell us maybe how big the INT

00:10:45,980 --> 00:10:50,330
is but we have to remember that some

00:10:48,770 --> 00:10:52,370
platforms are big endian and some

00:10:50,330 --> 00:10:54,140
platforms or little-endian and so you

00:10:52,370 --> 00:10:56,690
have to check the top word and the

00:10:54,140 --> 00:10:58,700
bottom word of the end of the union to

00:10:56,690 --> 00:11:01,340
see which ones were overridden and then

00:10:58,700 --> 00:11:02,630
you do a assertion to make sure that you

00:11:01,340 --> 00:11:04,280
didn't actually overflow your buffer

00:11:02,630 --> 00:11:15,110
once you figure out what the size of the

00:11:04,280 --> 00:11:25,070
sock line was so it's not just legacy

00:11:15,110 --> 00:11:26,630
code and workaround excuse me even

00:11:25,070 --> 00:11:29,630
though a lot of the new code in openness

00:11:26,630 --> 00:11:31,970
ssl as a Byzantine mess and so I'm gonna

00:11:29,630 --> 00:11:33,440
point out you know just to sample

00:11:31,970 --> 00:11:36,680
options from open SSL here

00:11:33,440 --> 00:11:38,210
no heartbeats no buff free lists but

00:11:36,680 --> 00:11:41,120
pretty much every one of them looks like

00:11:38,210 --> 00:11:45,650
this and this is defined that you'll

00:11:41,120 --> 00:11:48,380
pick up in your SSL constic header now

00:11:45,650 --> 00:11:50,030
the naming convention alone reveals that

00:11:48,380 --> 00:11:52,520
there's this default on mentality

00:11:50,030 --> 00:11:54,230
everything is on and you have to pick

00:11:52,520 --> 00:11:56,570
and choose which options to turn off

00:11:54,230 --> 00:11:58,220
this is the opposite of how you want to

00:11:56,570 --> 00:11:59,750
secure your library to work you want to

00:11:58,220 --> 00:12:03,170
minimize your attack surface you don't

00:11:59,750 --> 00:12:05,930
want to maximize it and second this

00:12:03,170 --> 00:12:07,580
makes applications developing code to

00:12:05,930 --> 00:12:10,100
test for such options actually rather

00:12:07,580 --> 00:12:12,620
problematic because old versions of the

00:12:10,100 --> 00:12:15,290
library that don't have the feature also

00:12:12,620 --> 00:12:18,650
don't have the no feature defined so

00:12:15,290 --> 00:12:20,810
it's actually very difficult to check to

00:12:18,650 --> 00:12:25,970
see if a feature is present or not in

00:12:20,810 --> 00:12:27,440
user code and even more bizarrely as we

00:12:25,970 --> 00:12:30,100
discovered when we started stripping

00:12:27,440 --> 00:12:33,650
these things out of libres a cell as

00:12:30,100 --> 00:12:36,140
open SSL adds new features we are going

00:12:33,650 --> 00:12:40,140
to have to continue to add new no

00:12:36,140 --> 00:12:42,960
feature defines to libre SSL

00:12:40,140 --> 00:12:49,680
and a current roadmap plans on adding

00:12:42,960 --> 00:12:54,630
lots more not features so that's

00:12:49,680 --> 00:12:58,020
actually things me to my next slide here

00:12:54,630 --> 00:13:00,420
so a big part of what we're doing is

00:12:58,020 --> 00:13:02,520
actually not doing anything we're

00:13:00,420 --> 00:13:04,620
slowing things down and we're trying to

00:13:02,520 --> 00:13:06,720
present a smaller target not a larger

00:13:04,620 --> 00:13:09,870
target so we've pretty much applied the

00:13:06,720 --> 00:13:11,340
brakes on new developments and I'm gonna

00:13:09,870 --> 00:13:13,920
pick on the previous two you guys here

00:13:11,340 --> 00:13:18,480
for a bit but it's not their fault so

00:13:13,920 --> 00:13:20,670
don't blame them so August 6 OpenSSL

00:13:18,480 --> 00:13:23,220
advisory comes out a bunch of bugs some

00:13:20,670 --> 00:13:26,630
crashing some buffer overflows you know

00:13:23,220 --> 00:13:30,240
the usual and then on September 9th

00:13:26,630 --> 00:13:32,700
FreeBSD issued their patch and security

00:13:30,240 --> 00:13:34,890
advisory that was equivalent to the open

00:13:32,700 --> 00:13:37,140
ssl advisory that's over a month later

00:13:34,890 --> 00:13:38,430
so you know it's like hey guys what do

00:13:37,140 --> 00:13:40,350
you guys what were you doing that was a

00:13:38,430 --> 00:13:42,180
month but I'll tell you what they were

00:13:40,350 --> 00:13:44,580
doing because I did the same thing they

00:13:42,180 --> 00:13:47,760
were waiting through the 13 thousand

00:13:44,580 --> 00:13:52,740
lines of DIF that open SSL decided to

00:13:47,760 --> 00:13:54,810
drop as part of that update it was a

00:13:52,740 --> 00:13:56,190
security release update and the diff

00:13:54,810 --> 00:14:00,360
between the previous release was

00:13:56,190 --> 00:14:02,280
thirteen thousand lines so projects need

00:14:00,360 --> 00:14:03,840
to consider how downstream users are

00:14:02,280 --> 00:14:06,120
actually going to deal with their

00:14:03,840 --> 00:14:07,500
copious volume of security patches if

00:14:06,120 --> 00:14:10,170
you're dropping security patches on a

00:14:07,500 --> 00:14:12,870
regular basis that cannot be 13,000

00:14:10,170 --> 00:14:15,180
lines because and so this goes back to

00:14:12,870 --> 00:14:17,190
how did heartbeats get into the

00:14:15,180 --> 00:14:19,620
ecosystem people are applying these

00:14:17,190 --> 00:14:21,570
patches blindly without reviewing them

00:14:19,620 --> 00:14:24,060
auditing them or even inspecting them

00:14:21,570 --> 00:14:25,950
casually because nobody's gonna look

00:14:24,060 --> 00:14:27,690
through this hey there's a bug we got to

00:14:25,950 --> 00:14:29,940
fix it BAM and goes to the next version

00:14:27,690 --> 00:14:32,070
hey there's another bug BAM and goes the

00:14:29,940 --> 00:14:35,040
next version and so all of sudden you

00:14:32,070 --> 00:14:36,840
end up with this you know menagerie of

00:14:35,040 --> 00:14:42,720
features that you never knew existed and

00:14:36,840 --> 00:14:44,490
they're all turned on now I don't want

00:14:42,720 --> 00:14:46,590
to say that libra cell development is

00:14:44,490 --> 00:14:48,870
completely frozen for instance we've

00:14:46,590 --> 00:14:51,590
added support for a few new ciphers

00:14:48,870 --> 00:14:55,520
notably Chacho 20

00:14:51,590 --> 00:14:58,480
but as we do so we consider what new

00:14:55,520 --> 00:15:01,310
failure modes we can introduce and so

00:14:58,480 --> 00:15:03,500
buffer overflows are actually pretty

00:15:01,310 --> 00:15:06,350
rare in the implementation of a cipher

00:15:03,500 --> 00:15:08,960
because the inputs outputs of the cipher

00:15:06,350 --> 00:15:10,610
are generally very fixed and so we've

00:15:08,960 --> 00:15:12,830
felt pretty confident that we could

00:15:10,610 --> 00:15:15,460
review the code test the code and make

00:15:12,830 --> 00:15:18,110
sure that it worked as intended

00:15:15,460 --> 00:15:19,850
usually ciphers come with great test

00:15:18,110 --> 00:15:22,010
Suites you know they encrypt all sorts

00:15:19,850 --> 00:15:24,260
of funny Latin fake strings and then

00:15:22,010 --> 00:15:28,850
check that the output is you know a

00:15:24,260 --> 00:15:30,590
known value and so we're pretty comprar

00:15:28,850 --> 00:15:32,900
this doesn't exclude the possibility

00:15:30,590 --> 00:15:36,380
that there's a crypto break which allows

00:15:32,900 --> 00:15:37,790
you to decrypt all this traffic but it's

00:15:36,380 --> 00:15:42,320
a little harder for an attacker to

00:15:37,790 --> 00:15:44,180
exploit that and also in TLS the server

00:15:42,320 --> 00:15:46,220
and the client both have to agree on a

00:15:44,180 --> 00:15:48,080
cipher before they're able to use it so

00:15:46,220 --> 00:15:50,890
you would have to be connecting to a

00:15:48,080 --> 00:15:53,300
malicious server to force it to use you

00:15:50,890 --> 00:15:55,310
in order for it to force your client to

00:15:53,300 --> 00:15:57,320
use a weak cipher and at that point

00:15:55,310 --> 00:15:58,580
you're talking to a malicious server so

00:15:57,320 --> 00:16:04,190
I don't think the encryption is going to

00:15:58,580 --> 00:16:07,970
be the problem no actually one more

00:16:04,190 --> 00:16:13,280
timeline on May 5th

00:16:07,970 --> 00:16:15,050
I removed the srp code from lib SSL and

00:16:13,280 --> 00:16:16,520
around the time we've removed Kerberos

00:16:15,050 --> 00:16:19,940
support and some other protocol

00:16:16,520 --> 00:16:22,190
extensions the problem with the way this

00:16:19,940 --> 00:16:24,590
code is integrated is it sprinkles about

00:16:22,190 --> 00:16:26,930
a dozen if deaths and it's crazy nested

00:16:24,590 --> 00:16:28,880
if-else chained right into the heart of

00:16:26,930 --> 00:16:31,750
some of the most critical functions in

00:16:28,880 --> 00:16:33,140
the TLS protocol like the key exchange

00:16:31,750 --> 00:16:35,900
so

00:16:33,140 --> 00:16:39,380
auditing these thousand line functions

00:16:35,900 --> 00:16:41,540
is impossible when they're just shredded

00:16:39,380 --> 00:16:43,340
by code that's either on or off and you

00:16:41,540 --> 00:16:44,990
can't tell what's going on and they have

00:16:43,340 --> 00:16:46,760
all these conditions where maybe this

00:16:44,990 --> 00:16:49,370
field is set and maybe this field is not

00:16:46,760 --> 00:16:53,810
set and so we cut it back down to the

00:16:49,370 --> 00:16:57,470
basics you get RSA DSA CDH and so forth

00:16:53,810 --> 00:17:00,170
now at this time the SRP code and alig

00:16:57,470 --> 00:17:01,610
crypto was left alone because it wasn't

00:17:00,170 --> 00:17:05,120
in the way and it wasn't interfering

00:17:01,610 --> 00:17:09,439
with auditing of TLS

00:17:05,120 --> 00:17:11,029
on July 2nd OpenSSL received

00:17:09,439 --> 00:17:14,809
notification that there was a crash

00:17:11,029 --> 00:17:16,970
causing bug in the TLS srp code which is

00:17:14,809 --> 00:17:20,539
the code that had been removed on May

00:17:16,970 --> 00:17:24,439
5th in leader SSL July 2nd though the

00:17:20,539 --> 00:17:28,880
bug was not yet publicly known so on

00:17:24,439 --> 00:17:32,240
July 28th I deleted the srp code from

00:17:28,880 --> 00:17:34,760
lib crypto and at the time in my commit

00:17:32,240 --> 00:17:37,610
message I mentioned hey there's a bug in

00:17:34,760 --> 00:17:39,350
this code but the details are secret now

00:17:37,610 --> 00:17:41,809
this is actually kind of misleading

00:17:39,350 --> 00:17:44,809
because the secret bug was not in the

00:17:41,809 --> 00:17:46,750
code I deleted the bug was in code that

00:17:44,809 --> 00:17:50,000
had been removed months earlier

00:17:46,750 --> 00:17:53,149
nevertheless three days later on July

00:17:50,000 --> 00:17:56,029
31st two researchers found a remotely

00:17:53,149 --> 00:17:57,500
exploitable buffer overflow in the live

00:17:56,029 --> 00:17:59,510
crypto srp code

00:17:57,500 --> 00:18:02,299
it's like throw a rock you're going to

00:17:59,510 --> 00:18:04,789
hit something like

00:18:02,299 --> 00:18:12,679
I pointed people in the wrong direction

00:18:04,789 --> 00:18:20,659
and they still found a bug so on August

00:18:12,679 --> 00:18:23,239
6th OpenSSL 1.01 eye is released and

00:18:20,659 --> 00:18:25,429
that contained fixes for both of the

00:18:23,239 --> 00:18:27,049
above issues along with like twelve

00:18:25,429 --> 00:18:31,759
thousand eight hundred lines of diff for

00:18:27,049 --> 00:18:34,729
other assorted things and then on August

00:18:31,759 --> 00:18:37,789
8th a user reported that SRP support and

00:18:34,729 --> 00:18:39,559
the new release was broken the and that

00:18:37,789 --> 00:18:44,299
was the fix for the first issue that

00:18:39,559 --> 00:18:47,149
broke SRP support so to be clear OpenSSL

00:18:44,299 --> 00:18:52,579
sat on an embargoed bug for over a month

00:18:47,149 --> 00:18:53,089
and nobody tested the fix what's the

00:18:52,579 --> 00:18:56,029
lesson here

00:18:53,089 --> 00:18:58,399
don't drop jumbo security patches on

00:18:56,029 --> 00:19:01,279
users they can't handle them and also

00:18:58,399 --> 00:19:03,309
anybody actually using SRP around this

00:19:01,279 --> 00:19:06,679
time was in quite a bit of a pickle

00:19:03,309 --> 00:19:08,989
they couldn't upgrade to get the fix for

00:19:06,679 --> 00:19:11,749
the buffer overflow because that broke

00:19:08,989 --> 00:19:13,909
SRP support entirely instead they had to

00:19:11,749 --> 00:19:15,889
go through that giant diff and try to

00:19:13,909 --> 00:19:16,450
pick out the one little gem that they

00:19:15,889 --> 00:19:18,979
needed

00:19:16,450 --> 00:19:22,549
now if the patches had been issued

00:19:18,979 --> 00:19:26,029
separately such as the TLS diff released

00:19:22,549 --> 00:19:28,549
in the beginning of July and the lib

00:19:26,029 --> 00:19:30,469
crypto overflowed fix released at the

00:19:28,549 --> 00:19:32,959
end of July then there would have been

00:19:30,469 --> 00:19:36,109
time to get the first diff right and

00:19:32,959 --> 00:19:37,940
then users could apply that then you

00:19:36,109 --> 00:19:42,019
could issue the second fix and users

00:19:37,940 --> 00:19:45,079
could apply that now so nobody's perfect

00:19:42,019 --> 00:19:47,769
you know I flubbed a few patches myself

00:19:45,079 --> 00:19:50,779
and that's exactly why you don't combine

00:19:47,769 --> 00:19:52,639
security fixes if they had been

00:19:50,779 --> 00:19:55,729
separated the regression could have been

00:19:52,639 --> 00:19:57,079
discovered and fixed and then the buffer

00:19:55,729 --> 00:19:59,919
overflow fix would have just applied

00:19:57,079 --> 00:19:59,919
like that

00:20:08,910 --> 00:20:18,300
sorry this is my fancy displayed

00:20:11,460 --> 00:20:19,560
technology here so I still haven't

00:20:18,300 --> 00:20:21,150
actually talked too much about what

00:20:19,560 --> 00:20:24,210
we've done in the last update and that's

00:20:21,150 --> 00:20:27,750
kind of on purpose because there hasn't

00:20:24,210 --> 00:20:30,680
been a lot going on we've mostly stopped

00:20:27,750 --> 00:20:33,230
deleting code the rampage is over

00:20:30,680 --> 00:20:35,280
there's still some scary code left but

00:20:33,230 --> 00:20:37,770
unfortunately a lot of it is actually in

00:20:35,280 --> 00:20:41,040
use and so we're gonna have to rewrite

00:20:37,770 --> 00:20:43,170
it the slow way and there was also a bit

00:20:41,040 --> 00:20:45,000
of a summer law there was a hackathon

00:20:43,170 --> 00:20:49,500
and then after the hackathon people like

00:20:45,000 --> 00:20:51,750
to decompress and then OpenBSD 5-6 went

00:20:49,500 --> 00:20:54,060
into freeze so we couldn't really work

00:20:51,750 --> 00:20:56,850
on things too much but things are

00:20:54,060 --> 00:20:59,160
picking up again and you know the usual

00:20:56,850 --> 00:21:02,460
way do we do this is you go into a

00:20:59,160 --> 00:21:05,820
directory VI star dot C start hitting

00:21:02,460 --> 00:21:07,940
page down and you know you'll look at

00:21:05,820 --> 00:21:10,200
all the points where memory is allocated

00:21:07,940 --> 00:21:12,180
then you'll look at all the places where

00:21:10,200 --> 00:21:14,880
the memory is freed and you make sure

00:21:12,180 --> 00:21:19,140
it's free one time and exactly one time

00:21:14,880 --> 00:21:21,630
no more no less and you know sorry to

00:21:19,140 --> 00:21:23,760
make it sound so tame but avoiding

00:21:21,630 --> 00:21:26,160
excitement is really part of the plan

00:21:23,760 --> 00:21:29,490
now you know the first 30 days we're all

00:21:26,160 --> 00:21:34,380
about the revolution but now we're in

00:21:29,490 --> 00:21:37,410
evolution mode because we had some time

00:21:34,380 --> 00:21:40,470
there from when the rampage started to

00:21:37,410 --> 00:21:42,990
just kind of whack blindly and then fix

00:21:40,470 --> 00:21:45,150
it later but you know five six had to go

00:21:42,990 --> 00:21:46,800
out the door and users gonna be starting

00:21:45,150 --> 00:21:54,000
to run that and so we're slowing down

00:21:46,800 --> 00:21:56,100
and I think also you know the ramp the

00:21:54,000 --> 00:21:56,460
rampage did it like accomplish its

00:21:56,100 --> 00:21:58,020
mission

00:21:56,460 --> 00:22:00,580
you know we deleted all the code we

00:21:58,020 --> 00:22:01,870
needed to delete

00:22:00,580 --> 00:22:04,700
[Music]

00:22:01,870 --> 00:22:08,080
so that actually brings me to portable

00:22:04,700 --> 00:22:12,110
and due to the quirks of release timing

00:22:08,080 --> 00:22:14,360
the first version of Libra sell released

00:22:12,110 --> 00:22:16,940
was actually the portable version not

00:22:14,360 --> 00:22:19,430
the OpenBSD native version the first

00:22:16,940 --> 00:22:22,490
native Libra sell release will not

00:22:19,430 --> 00:22:28,370
actually be coming out until November

00:22:22,490 --> 00:22:30,920
when five six is released and so I

00:22:28,370 --> 00:22:33,020
personally do not work on the portable

00:22:30,920 --> 00:22:35,570
version there are other people who do

00:22:33,020 --> 00:22:38,630
that I kind of keep my eye on things but

00:22:35,570 --> 00:22:41,480
in some ways the less I know the better

00:22:38,630 --> 00:22:42,010
and but I'll tell you what they've been

00:22:41,480 --> 00:22:45,350
up to

00:22:42,010 --> 00:22:47,720
first you'll be happy to know Libra sell

00:22:45,350 --> 00:22:51,380
portable should work on all the BSD

00:22:47,720 --> 00:22:54,740
platforms it works on some other OS is -

00:22:51,380 --> 00:22:57,620
I've heard but you know whatever you

00:22:54,740 --> 00:23:00,740
know so the good news is most of the

00:22:57,620 --> 00:23:04,430
extensions that we use extensively such

00:23:00,740 --> 00:23:06,980
as store L copy and so forth

00:23:04,430 --> 00:23:09,400
are already on other BSD platforms this

00:23:06,980 --> 00:23:12,110
makes the port very straightforward you

00:23:09,400 --> 00:23:15,890
probably don't even need the portable

00:23:12,110 --> 00:23:19,430
configure build system if you're gonna

00:23:15,890 --> 00:23:21,620
import Lear SSL into another BSD system

00:23:19,430 --> 00:23:23,690
I think it would be simpler and easier

00:23:21,620 --> 00:23:26,680
to just copy the be it OpenBSD make

00:23:23,690 --> 00:23:30,350
files and build it that way and use the

00:23:26,680 --> 00:23:33,380
BSD make make framework instead of

00:23:30,350 --> 00:23:35,930
taking the BSD make framework converted

00:23:33,380 --> 00:23:40,870
to configure Auto make whatever nonsense

00:23:35,930 --> 00:23:44,620
and then building that on a BSD system

00:23:40,870 --> 00:23:47,890
now that's the good news the bad news

00:23:44,620 --> 00:23:50,330
for now is that Lieber SSL uses

00:23:47,890 --> 00:23:54,020
functions that exist on the operating

00:23:50,330 --> 00:23:57,190
system if it finds them and notably arc

00:23:54,020 --> 00:24:01,640
for random that is the source of all

00:23:57,190 --> 00:24:05,350
random numbers in libres a cell now do

00:24:01,640 --> 00:24:08,570
as a talk coming up on the evolution of

00:24:05,350 --> 00:24:11,510
artful random but it's enough for me to

00:24:08,570 --> 00:24:11,750
say that open BSD has changed it quite a

00:24:11,510 --> 00:24:13,820
bit

00:24:11,750 --> 00:24:14,790
it doesn't even use the rc4 cipher

00:24:13,820 --> 00:24:18,690
anymore

00:24:14,790 --> 00:24:21,150
it's art Chacho 20 based and FreeBSD and

00:24:18,690 --> 00:24:23,370
fbst and dragonfly are all kind of

00:24:21,150 --> 00:24:26,700
lagging I think in that regard I know

00:24:23,370 --> 00:24:29,610
there's some patches for freebsd to

00:24:26,700 --> 00:24:32,100
update it to be a lot more similar to

00:24:29,610 --> 00:24:35,670
the code and OpenBSD but the patches

00:24:32,100 --> 00:24:42,060
seem to have stalled so somebody's gonna

00:24:35,670 --> 00:24:46,500
want to pick that up and yeah okay cool

00:24:42,060 --> 00:24:49,290
so the there was an issue earlier where

00:24:46,500 --> 00:24:51,810
Libra SSL would try to override arc for

00:24:49,290 --> 00:24:53,730
random regardless but that led to a

00:24:51,810 --> 00:24:55,080
whole bunch of crazy linking issues

00:24:53,730 --> 00:24:56,880
where you have two symbols of the same

00:24:55,080 --> 00:24:59,430
name in the program and it can you don't

00:24:56,880 --> 00:25:01,020
know which one's gonna run and so the

00:24:59,430 --> 00:25:03,420
solution is to configure script if it

00:25:01,020 --> 00:25:04,530
detects arc for random it is not going

00:25:03,420 --> 00:25:06,210
to build it it's gonna use whatever

00:25:04,530 --> 00:25:08,190
you've got on your operating system and

00:25:06,210 --> 00:25:11,580
if the one on your operating system is

00:25:08,190 --> 00:25:13,440
in fork safe or whatever then you know

00:25:11,580 --> 00:25:16,160
unfortunately bris the cell can't really

00:25:13,440 --> 00:25:19,820
deal with that that's an OS problem and

00:25:16,160 --> 00:25:21,690
we're still targeting POSIX platforms

00:25:19,820 --> 00:25:23,670
windows support isn't out of the

00:25:21,690 --> 00:25:25,860
question it just kind of requires

00:25:23,670 --> 00:25:28,830
somebody to figure out you know a build

00:25:25,860 --> 00:25:31,440
system on Windows because I think like a

00:25:28,830 --> 00:25:35,070
cygwin port of libra cell is kind of

00:25:31,440 --> 00:25:36,560
useless probably for most people and I

00:25:35,070 --> 00:25:39,090
think there were some patches for like

00:25:36,560 --> 00:25:51,780
Debian FreeBSD or whatever you know I

00:25:39,090 --> 00:25:54,450
hybrid weird things but second tier so

00:25:51,780 --> 00:25:58,560
now I want to spend a bit of time

00:25:54,450 --> 00:26:00,360
talking about what I hope is gonna be

00:25:58,560 --> 00:26:06,240
the future here and this is more

00:26:00,360 --> 00:26:08,880
forward-looking so a lot of the initial

00:26:06,240 --> 00:26:11,130
reactions to the announcement of the

00:26:08,880 --> 00:26:13,710
breast asal was like oh my god you guys

00:26:11,130 --> 00:26:16,260
are crazy the open SSL API is so bad

00:26:13,710 --> 00:26:18,120
that nobody would want to preserve this

00:26:16,260 --> 00:26:18,570
you guys should just throw it away right

00:26:18,120 --> 00:26:23,010
now

00:26:18,570 --> 00:26:25,650
and I'm inclined to agree but we've

00:26:23,010 --> 00:26:28,269
preserved the API because that's what

00:26:25,650 --> 00:26:31,419
the install base that we have

00:26:28,269 --> 00:26:33,009
is using and we need to work with the

00:26:31,419 --> 00:26:36,190
programs that exist today in order to

00:26:33,009 --> 00:26:38,700
succeed but that doesn't mean that we're

00:26:36,190 --> 00:26:43,089
married to this API long term

00:26:38,700 --> 00:26:46,450
so Joel Singh and I have been working on

00:26:43,089 --> 00:26:49,599
a replacement API and we have

00:26:46,450 --> 00:26:55,749
appropriately named it Russell

00:26:49,599 --> 00:26:59,739
re SSL which is reimagined SSL and our

00:26:55,749 --> 00:27:03,070
goals are consistency and simplicity in

00:26:59,739 --> 00:27:04,929
particular we are trying to answer the

00:27:03,070 --> 00:27:08,649
question what would a user like to do

00:27:04,929 --> 00:27:13,570
and not the questions what does the TLS

00:27:08,649 --> 00:27:16,059
protocol allow you to do or what can we

00:27:13,570 --> 00:27:20,259
make the user do in order to establish a

00:27:16,059 --> 00:27:23,079
secure connection and so you make you

00:27:20,259 --> 00:27:24,219
know what do you want to do you may want

00:27:23,079 --> 00:27:29,799
to make a secure connection to the

00:27:24,219 --> 00:27:31,479
server and so and you can also host a

00:27:29,799 --> 00:27:35,769
secure server and you can read and write

00:27:31,479 --> 00:27:38,889
data over that connection but there are

00:27:35,769 --> 00:27:41,559
no open SSL types or functions exposed

00:27:38,889 --> 00:27:45,789
the wrestle api is completely standalone

00:27:41,559 --> 00:27:47,769
from a programmatic point of view and in

00:27:45,789 --> 00:27:49,899
fact not even any wrestle internals are

00:27:47,769 --> 00:27:52,839
exposed we were very careful to expose

00:27:49,899 --> 00:27:57,129
only opaque types and use functions for

00:27:52,839 --> 00:27:59,229
getting and setting fields and cardinal

00:27:57,129 --> 00:28:02,159
role you should never ever need to

00:27:59,229 --> 00:28:06,249
contemplate the existence of x.509 or

00:28:02,159 --> 00:28:09,549
sn1 or anything like that and those are

00:28:06,249 --> 00:28:11,589
details that are far beyond the level

00:28:09,549 --> 00:28:17,619
that most developers are going to care

00:28:11,589 --> 00:28:19,719
about and so we just said no you know

00:28:17,619 --> 00:28:22,570
you don't get that so what you do get is

00:28:19,719 --> 00:28:24,759
an interface that actually could almost

00:28:22,570 --> 00:28:26,829
equally well describe transport over SSH

00:28:24,759 --> 00:28:28,239
tunnels you know like what do you want

00:28:26,829 --> 00:28:30,219
do you want a secure connection

00:28:28,239 --> 00:28:36,099
hey we give you a secure connection

00:28:30,219 --> 00:28:40,029
details don't worry about them and we've

00:28:36,099 --> 00:28:41,580
also tried to keep this easily bindable

00:28:40,029 --> 00:28:43,170
from other languages and so

00:28:41,580 --> 00:28:44,820
I have a kind of particular interest

00:28:43,170 --> 00:28:47,850
here in that like languages like Ruby

00:28:44,820 --> 00:28:49,890
and Python and Lua can pick this up and

00:28:47,850 --> 00:28:52,320
interface with it very easily without

00:28:49,890 --> 00:28:59,150
having to try to figure out the calling

00:28:52,320 --> 00:29:01,560
conventions for some strange API and the

00:28:59,150 --> 00:29:05,610
implementation of wrestle however is not

00:29:01,560 --> 00:29:08,670
tied to libre ssl the liberal library

00:29:05,610 --> 00:29:13,290
works with open ssl out of the box it's

00:29:08,670 --> 00:29:15,630
very portable and it will even allow

00:29:13,290 --> 00:29:18,120
other implementations to be used and so

00:29:15,630 --> 00:29:21,630
I think previous efforts at replacing

00:29:18,120 --> 00:29:23,990
open SSL like the new TLS or whatever

00:29:21,630 --> 00:29:26,880
have usually ended up with these

00:29:23,990 --> 00:29:30,180
Compassion's where they try to emulate

00:29:26,880 --> 00:29:32,160
the open SSL API and that's terrible

00:29:30,180 --> 00:29:34,500
because you have this ridiculous like

00:29:32,160 --> 00:29:36,750
mismatch of types and function

00:29:34,500 --> 00:29:38,910
definitions where unless you actually do

00:29:36,750 --> 00:29:40,470
things in the crazy way that open SSL

00:29:38,910 --> 00:29:43,350
does them you're gonna have to jump

00:29:40,470 --> 00:29:46,320
through hoops to make it happen instead

00:29:43,350 --> 00:29:49,350
we've pushed the API up to a much higher

00:29:46,320 --> 00:29:51,750
level where you don't worry about what's

00:29:49,350 --> 00:29:53,580
happening you just kind of say hey send

00:29:51,750 --> 00:29:54,780
this data over the socket and if you

00:29:53,580 --> 00:29:57,210
would encrypt it for me that would be

00:29:54,780 --> 00:29:59,700
nice and then you know the details of

00:29:57,210 --> 00:30:01,350
how you encrypt it and so forth are left

00:29:59,700 --> 00:30:06,210
to the implementation and the user

00:30:01,350 --> 00:30:07,770
doesn't get involved in that now but I

00:30:06,210 --> 00:30:10,920
think the most important thing here is

00:30:07,770 --> 00:30:13,710
that the API is abstract enough that

00:30:10,920 --> 00:30:17,970
others are welcome to the party now

00:30:13,710 --> 00:30:21,360
clearly I'm claiming that leer SSL is B

00:30:17,970 --> 00:30:23,400
or one of the best quality pls stacks

00:30:21,360 --> 00:30:26,820
that you can get and that's what you

00:30:23,400 --> 00:30:28,140
know that's one of our goals but going

00:30:26,820 --> 00:30:30,600
all the way back to the beginning

00:30:28,140 --> 00:30:34,110
I think the ecosystem benefits when we

00:30:30,600 --> 00:30:37,470
break the monoculture you know if we're

00:30:34,110 --> 00:30:41,820
SSL when liebherr SSL is a runaway

00:30:37,470 --> 00:30:43,560
success and becomes the de facto TLS

00:30:41,820 --> 00:30:45,630
stack it's actually gonna make me a

00:30:43,560 --> 00:30:47,480
little sad because I think it means we

00:30:45,630 --> 00:30:49,570
didn't learn an important lesson about

00:30:47,480 --> 00:30:52,540
variability

00:30:49,570 --> 00:30:55,210
and you know competition I do not want

00:30:52,540 --> 00:30:57,910
to see Libra SSL actually become the one

00:30:55,210 --> 00:31:02,590
and only TLS stack that people use and

00:30:57,910 --> 00:31:04,510
so a compatible API like Russell which

00:31:02,590 --> 00:31:08,260
allows other people to plug in and

00:31:04,510 --> 00:31:09,640
replace our code and keeps you know all

00:31:08,260 --> 00:31:12,220
the important programs that you want to

00:31:09,640 --> 00:31:14,110
run you know gives them the flexibility

00:31:12,220 --> 00:31:15,970
to pick and choose their implementation

00:31:14,110 --> 00:31:20,170
I think that benefits everyone in the

00:31:15,970 --> 00:31:23,700
long term and but one of the things that

00:31:20,170 --> 00:31:28,240
we're trying to do right I mentioned is

00:31:23,700 --> 00:31:30,670
secure by default and so public service

00:31:28,240 --> 00:31:35,350
announcement here host name verification

00:31:30,670 --> 00:31:39,010
if you've ever written any TLS code I'm

00:31:35,350 --> 00:31:40,840
using open SSL and you did not verify

00:31:39,010 --> 00:31:43,270
your hostname which is actually kind of

00:31:40,840 --> 00:31:47,560
likely you have a pretty wide gaping

00:31:43,270 --> 00:31:50,170
man-in-the-middle hole there so in order

00:31:47,560 --> 00:31:51,670
to make a secure TLS connection you have

00:31:50,170 --> 00:31:53,830
to do two things you have to validate

00:31:51,670 --> 00:31:56,440
the certificate and then you have to

00:31:53,830 --> 00:31:58,270
validate its trust chain everybody kind

00:31:56,440 --> 00:32:00,910
of knows this then you have to verify

00:31:58,270 --> 00:32:02,440
that the hostname and the certificate is

00:32:00,910 --> 00:32:06,190
the same as the hostname that you're

00:32:02,440 --> 00:32:08,170
connected to if you connected to not pay

00:32:06,190 --> 00:32:10,720
power if you connect to paypal.com

00:32:08,170 --> 00:32:13,540
and you get a certificate that says not

00:32:10,720 --> 00:32:15,220
PayPal calm no matter how valid that

00:32:13,540 --> 00:32:16,810
certificate is you're not talking to

00:32:15,220 --> 00:32:18,360
PayPal and so you don't want to be using

00:32:16,810 --> 00:32:21,010
that connection

00:32:18,360 --> 00:32:23,110
unfortunately open SSL doesn't give you

00:32:21,010 --> 00:32:25,450
a lot of assistance in verifying the

00:32:23,110 --> 00:32:27,880
hostname you have to do it yourself

00:32:25,450 --> 00:32:30,610
which requires pulling things out of the

00:32:27,880 --> 00:32:32,290
x.509 certificate and you have to know

00:32:30,610 --> 00:32:35,920
about things like component names and

00:32:32,290 --> 00:32:37,750
subject alt names and ridiculous things

00:32:35,920 --> 00:32:38,920
that you probably haven't heard of or if

00:32:37,750 --> 00:32:40,360
you haven't heard of these things and

00:32:38,920 --> 00:32:44,350
you've written TLS code you're in big

00:32:40,360 --> 00:32:46,990
trouble and I mean the best thing that

00:32:44,350 --> 00:32:48,910
we can say about this is that popular

00:32:46,990 --> 00:32:51,670
bindings for languages like Python and

00:32:48,910 --> 00:32:55,060
Ruby include a function to verify the

00:32:51,670 --> 00:32:57,190
host name in their wrapper but the bad

00:32:55,060 --> 00:32:59,740
news is calling this function is

00:32:57,190 --> 00:33:02,610
entirely optional and if you go on

00:32:59,740 --> 00:33:05,610
github or whatever pick a random Ruby

00:33:02,610 --> 00:33:08,220
project or Python project that uses TLS

00:33:05,610 --> 00:33:10,470
it does not verify the hostname it's not

00:33:08,220 --> 00:33:13,650
going to call that function the Lewis

00:33:10,470 --> 00:33:16,250
sec binding for instance for Lua to open

00:33:13,650 --> 00:33:18,720
SSL doesn't even include such a function

00:33:16,250 --> 00:33:23,640
and then if you go and look at other

00:33:18,720 --> 00:33:26,040
libraries like thrift or you know

00:33:23,640 --> 00:33:27,929
something else that does it right you'll

00:33:26,040 --> 00:33:29,580
find that everybody since everybody has

00:33:27,929 --> 00:33:31,530
to write this hostname verification

00:33:29,580 --> 00:33:34,679
function everybody does it a little bit

00:33:31,530 --> 00:33:37,549
differently and you can tell just by

00:33:34,679 --> 00:33:40,590
inspection that they're going to accept

00:33:37,549 --> 00:33:42,630
in particular in the case of wildcard

00:33:40,590 --> 00:33:44,549
certificates and everybody else's

00:33:42,630 --> 00:33:46,799
favorite feature embedded null bytes in

00:33:44,549 --> 00:33:48,090
the host name everybody is going to give

00:33:46,799 --> 00:33:52,620
you a different answer for whether a

00:33:48,090 --> 00:33:55,890
hostname is verified or not and so we've

00:33:52,620 --> 00:33:58,559
pulled this up into our API and it's on

00:33:55,890 --> 00:34:00,090
by default and whenever you make an ssl

00:33:58,559 --> 00:34:02,640
connection you have to pass a hostname

00:34:00,090 --> 00:34:05,070
and it has to verify and you can't

00:34:02,640 --> 00:34:10,950
accidentally forget to call this

00:34:05,070 --> 00:34:14,429
function i think that's our biggest

00:34:10,950 --> 00:34:16,320
contribution to date would be a api that

00:34:14,429 --> 00:34:21,480
does host name verification by default

00:34:16,320 --> 00:34:23,159
as far as i know go which is actually

00:34:21,480 --> 00:34:24,540
what the russell api is kind of modeled

00:34:23,159 --> 00:34:27,419
on is one of the few other

00:34:24,540 --> 00:34:32,580
implementations that enforces this by

00:34:27,419 --> 00:34:35,280
default now currently there are two

00:34:32,580 --> 00:34:39,960
programs using the russell api the

00:34:35,280 --> 00:34:41,429
OpenBSD ftp client and the OpenBSD httpd

00:34:39,960 --> 00:34:45,629
so we have a client and we have a server

00:34:41,429 --> 00:34:51,929
and this allows us to test things out

00:34:45,629 --> 00:34:53,700
and move them forward and we're I would

00:34:51,929 --> 00:34:56,159
say not nearly ready to call for

00:34:53,700 --> 00:34:58,200
third-party support so don't rush out

00:34:56,159 --> 00:35:00,480
yet and start porting programs to the

00:34:58,200 --> 00:35:02,700
Russell API but if this is something

00:35:00,480 --> 00:35:05,160
that interests is interests you I would

00:35:02,700 --> 00:35:09,660
encourage you to look at it look at what

00:35:05,160 --> 00:35:11,250
we're doing you know like an hour ago

00:35:09,660 --> 00:35:13,770
sitting in the lobby actually committed

00:35:11,250 --> 00:35:16,050
a DIF that changed how the configuration

00:35:13,770 --> 00:35:17,060
works so things are clearly still in

00:35:16,050 --> 00:35:20,630
flux

00:35:17,060 --> 00:35:22,310
but I would say you know by five seven

00:35:20,630 --> 00:35:24,640
so that's another six months from now I

00:35:22,310 --> 00:35:33,500
think I'd like to have things lock down

00:35:24,640 --> 00:35:38,240
and then that will do that and I think I

00:35:33,500 --> 00:35:42,350
ran through a little faster than I was

00:35:38,240 --> 00:35:45,190
planning but I'm at the end so I'll open

00:35:42,350 --> 00:35:45,190
the floor to questions

00:35:59,570 --> 00:36:08,700
so hi first question group in the ssl do

00:36:05,760 --> 00:36:12,000
you plan to have anything to make this a

00:36:08,700 --> 00:36:13,920
play more useful in tradit applications

00:36:12,000 --> 00:36:16,950
because using open ssl and create

00:36:13,920 --> 00:36:19,260
applications is there's

00:36:16,950 --> 00:36:22,080
documentation on how to do this which

00:36:19,260 --> 00:36:24,060
conflicts with itself so it's hit and

00:36:22,080 --> 00:36:26,220
miss most attempt out exactly to gate so

00:36:24,060 --> 00:36:27,420
for example we have a piece of code that

00:36:26,220 --> 00:36:30,890
we know that two works and we never

00:36:27,420 --> 00:36:33,270
touch it like we copied from project to

00:36:30,890 --> 00:36:37,380
the hard part there is we are building

00:36:33,270 --> 00:36:42,330
on open ssl for now and so it's gonna be

00:36:37,380 --> 00:36:44,220
hard for us to avoid some open ssl

00:36:42,330 --> 00:36:47,790
peculiarities in with respect to thread

00:36:44,220 --> 00:36:54,750
support for as long as we're using open

00:36:47,790 --> 00:36:56,130
ssl under the covers but the actually

00:36:54,750 --> 00:36:57,870
could you be a little more specific like

00:36:56,130 --> 00:37:00,210
I'm trying to think of what would be a

00:36:57,870 --> 00:37:03,270
particular issue there was a problem

00:37:00,210 --> 00:37:06,510
that there's from when do initialized

00:37:03,270 --> 00:37:08,340
open SSL which initialization functions

00:37:06,510 --> 00:37:11,100
to Co interestingly to code before the

00:37:08,340 --> 00:37:13,410
call of Ted's and also another problem

00:37:11,100 --> 00:37:15,090
with I'm not really sure which I think

00:37:13,410 --> 00:37:16,740
some global structures that top Anna

00:37:15,090 --> 00:37:19,620
still uses that if you link openness out

00:37:16,740 --> 00:37:21,240
twice in some way for example you can

00:37:19,620 --> 00:37:23,420
for Pasha you've kept up a sweet open

00:37:21,240 --> 00:37:25,800
SSL when you give PHP which links the

00:37:23,420 --> 00:37:26,880
PostgreSQL quiet which links open SL

00:37:25,800 --> 00:37:38,340
just segfault

00:37:26,880 --> 00:37:40,740
most of them stuff like that thank you

00:37:38,340 --> 00:37:42,840
and one more thing so open SSL is

00:37:40,740 --> 00:37:44,640
actually the second word software left

00:37:42,840 --> 00:37:54,750
I've played with to the first one big

00:37:44,640 --> 00:37:58,020
ffmpeg so thank you for this hi so let

00:37:54,750 --> 00:38:02,340
me understand things correctly so SSL

00:37:58,020 --> 00:38:09,130
API Restless API it uses slip crypto or

00:38:02,340 --> 00:38:10,780
leap crypto and leap SSL and lip crypto

00:38:09,130 --> 00:38:13,030
because you have to call into it what

00:38:10,780 --> 00:38:16,210
crypto for the bleep SSL uses sleep

00:38:13,030 --> 00:38:18,010
crypto basically yeah and is there any

00:38:16,210 --> 00:38:21,190
ongoing discussion on the API on the

00:38:18,010 --> 00:38:25,690
design of API because what I'm worried

00:38:21,190 --> 00:38:27,610
about is that the IP I would be nice and

00:38:25,690 --> 00:38:31,720
clean but only for some very specific

00:38:27,610 --> 00:38:34,600
needs and if for example we would need

00:38:31,720 --> 00:38:35,740
like certificate pinning and we don't

00:38:34,600 --> 00:38:37,660
care about hosting we care about

00:38:35,740 --> 00:38:39,310
fingerprint of the destination

00:38:37,660 --> 00:38:42,520
certificate and you will make the

00:38:39,310 --> 00:38:45,730
hostname mandatory that's a problem

00:38:42,520 --> 00:38:47,890
so I wonder if if there is some

00:38:45,730 --> 00:38:50,580
discussion going on on the API so we can

00:38:47,890 --> 00:38:55,600
actually comment on the very early stage

00:38:50,580 --> 00:38:57,580
I think that's actually why I brought

00:38:55,600 --> 00:38:59,140
this up now is I want to increase

00:38:57,580 --> 00:39:02,290
awareness of what we're doing and kind

00:38:59,140 --> 00:39:03,850
of solicit feedback and we didn't want

00:39:02,290 --> 00:39:06,670
to do this necessarily before we had any

00:39:03,850 --> 00:39:08,350
code because I think you got you had a

00:39:06,670 --> 00:39:09,910
you need to throw something out there so

00:39:08,350 --> 00:39:12,400
that people can look at it and see what

00:39:09,910 --> 00:39:16,450
you're doing concrete terms but

00:39:12,400 --> 00:39:21,610
certainly I think now you you know you

00:39:16,450 --> 00:39:24,700
can you can turn the verification off if

00:39:21,610 --> 00:39:27,250
you need to and you can also specify a

00:39:24,700 --> 00:39:31,360
certificate so you can specify either a

00:39:27,250 --> 00:39:39,210
root cert or a particular sort that you

00:39:31,360 --> 00:39:41,710
expect so the the API that we're

00:39:39,210 --> 00:39:44,650
evolving I think we are trying to do it

00:39:41,710 --> 00:39:47,680
somewhat slowly where we're gonna look

00:39:44,650 --> 00:39:51,730
at the needs of particular programs and

00:39:47,680 --> 00:39:54,750
then add functions as necessary to the

00:39:51,730 --> 00:40:00,550
API to support the functionality needed

00:39:54,750 --> 00:40:02,590
but without expert I think what I was

00:40:00,550 --> 00:40:05,560
trying to get at is we want to see what

00:40:02,590 --> 00:40:08,020
people need to do and versus necessarily

00:40:05,560 --> 00:40:12,940
what or how they're doing it today and

00:40:08,020 --> 00:40:15,730
so we want to do make it easier for

00:40:12,940 --> 00:40:17,890
people to do things versus you know give

00:40:15,730 --> 00:40:19,540
them like people say oh I want a hammer

00:40:17,890 --> 00:40:21,359
and we're like well maybe a screwdriver

00:40:19,540 --> 00:40:24,839
would be better

00:40:21,359 --> 00:40:24,839
okay thank you

00:40:25,950 --> 00:40:29,000
[Music]

00:40:39,830 --> 00:40:51,510
[Applause]

00:40:43,760 --> 00:40:51,510

YouTube URL: https://www.youtube.com/watch?v=i9ibV-sPPz0


