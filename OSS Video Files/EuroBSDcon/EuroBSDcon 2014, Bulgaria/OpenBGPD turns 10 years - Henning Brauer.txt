Title: OpenBGPD turns 10 years - Henning Brauer
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

The Border Gateway Protocol, BGP, is used on the internet between ISPs to announce reachability of networks. Routers build their routing tables using this information. The global IPv4 routing table has about 470000 entries today. In 2004, I was upset enough with the imlementation we were using back then, zebra, to start writing an own one. After showing an early prototype other developers jumped in and helped. Quickly thereafter we had a working BGP implentation that not only I have used ever since then. We’ll look at OpenBGPD’s design and how it differs from other implementations, the frameworks established and later used for other purposes, and the lessons we learned over the last 10 years.

Speaker biography:

Henning Brauer is 35 and lives in Hamburg, Germany. He is running the Internet Service Provider “BS Web Services GmbH” there, and has done so for about 15 years. He recently took over net-activities GmbH as well and serves as CEO at both companies. He joined OpenBSD in 2002 and has been working on many things, most network related, since. He started OpenBGPD and OpenNTPD, the framework he has written for bgpd is used by almost all newer daemons in OpenBSD. He has been working on the OpenBSD packet filter, pf, from the beginning and has architected and written a very large fraction of today’s pf. Whe he’s not hacking you can find him mountain biking, traveling and hiking, or in one of the many bars in his neighborhood with his friends, enjoying brewer’s art and often playing tabletop soccer. He’s also involved in local politics as well as the EuroBSDcon foundation.
Captions: 
	00:00:06,620 --> 00:00:14,420
someone is raring to go here so next up

00:00:10,830 --> 00:00:14,420
is Peter hansteen announcing myself

00:00:18,619 --> 00:00:24,720
again so your pc cohn next session is

00:00:22,020 --> 00:00:29,369
heading Brower well-known obesity

00:00:24,720 --> 00:00:31,949
Network hacker who will help us

00:00:29,369 --> 00:00:35,040
celebrate the ten years open open bgp d

00:00:31,949 --> 00:00:36,030
take it away heading yes thank you for

00:00:35,040 --> 00:00:41,129
coming to the birthday party

00:00:36,030 --> 00:00:44,460
so 2014 as the title kind of indicates

00:00:41,129 --> 00:00:48,980
marks the 10th anniversary of Mitra PD I

00:00:44,460 --> 00:00:52,170
initially started it in late 2004 and

00:00:48,980 --> 00:00:54,780
well the 10th anniversary of course is a

00:00:52,170 --> 00:00:56,760
very very good opportunity to recycle a

00:00:54,780 --> 00:00:58,949
Taniya I mean to look back at the design

00:00:56,760 --> 00:01:03,600
and implementation and the lessons

00:00:58,949 --> 00:01:05,400
learned some backgrounds what do I do

00:01:03,600 --> 00:01:11,790
with BGP why I'm uninterested in that I

00:01:05,400 --> 00:01:13,710
run a nice feed since 96 98 ish we are

00:01:11,790 --> 00:01:17,869
heavily using OpenBSD we're basically

00:01:13,710 --> 00:01:23,630
only using open and free software open

00:01:17,869 --> 00:01:27,060
BSD since 2000 dish and back then our

00:01:23,630 --> 00:01:30,720
core routers were running obviously of

00:01:27,060 --> 00:01:36,090
course but well a software package

00:01:30,720 --> 00:01:38,670
called zebra for the BGP needs back then

00:01:36,090 --> 00:01:41,070
there really was no choice there was

00:01:38,670 --> 00:01:42,810
nothing else there was one alternate

00:01:41,070 --> 00:01:48,560
implementation that didn't work at all

00:01:42,810 --> 00:01:48,560
basically so it was zebra or bio cisco

00:01:48,920 --> 00:01:59,060
zebra is interesting these days it's

00:01:53,280 --> 00:02:01,530
called what was it now Quorra right

00:01:59,060 --> 00:02:03,630
that's a good example on how to not

00:02:01,530 --> 00:02:08,369
design a network demon and especially

00:02:03,630 --> 00:02:11,250
not a bgp demon first first big big big

00:02:08,369 --> 00:02:13,830
mistake they use threats second mistake

00:02:11,250 --> 00:02:17,070
is cooperate of threats

00:02:13,830 --> 00:02:19,980
they do have a central event queue which

00:02:17,070 --> 00:02:21,510
means that that everything that's

00:02:19,980 --> 00:02:23,160
supposed to happen some part goes into

00:02:21,510 --> 00:02:25,470
the queue so there are some critical

00:02:23,160 --> 00:02:27,900
events like the keeper lives you have to

00:02:25,470 --> 00:02:30,180
send to your peers so that he doesn't

00:02:27,900 --> 00:02:32,370
think that you you died in between and

00:02:30,180 --> 00:02:34,560
if those don't arrive in time the the

00:02:32,370 --> 00:02:37,680
peer will drop the connection to you and

00:02:34,560 --> 00:02:39,870
drop the routes and well losing routes

00:02:37,680 --> 00:02:44,640
is bad at worst the worst case you're

00:02:39,870 --> 00:02:47,010
offline now after a while when we figure

00:02:44,640 --> 00:02:49,710
out that we have to send out the keeper

00:02:47,010 --> 00:02:51,690
life and the sessions already gone

00:02:49,710 --> 00:02:53,370
we noticed the sessions guard gets

00:02:51,690 --> 00:02:56,880
reestablished of course that generates

00:02:53,370 --> 00:02:59,220
another shiploads amount of it like it

00:02:56,880 --> 00:03:00,780
not a big amount of events flooding the

00:02:59,220 --> 00:03:05,430
event queue even more making the problem

00:03:00,780 --> 00:03:07,320
worse next biggest next big problem with

00:03:05,430 --> 00:03:11,850
that thing there was almost no

00:03:07,320 --> 00:03:13,560
documentation the little bit that was

00:03:11,850 --> 00:03:16,620
there wasn't revenues and might revenues

00:03:13,560 --> 00:03:19,610
is not very good even the comments in

00:03:16,620 --> 00:03:24,570
the source code are partially Japanese

00:03:19,610 --> 00:03:27,420
so I tried to deal with that um I found

00:03:24,570 --> 00:03:29,970
and fixed the worst bugs like the the

00:03:27,420 --> 00:03:33,950
ones that really disturbed the daily

00:03:29,970 --> 00:03:36,780
operations most I got it to kind of

00:03:33,950 --> 00:03:38,130
reasonably stable stable it was still

00:03:36,780 --> 00:03:40,140
slow as hell

00:03:38,130 --> 00:03:41,430
throwing hardware at the problem was not

00:03:40,140 --> 00:03:46,350
an option because that was already

00:03:41,430 --> 00:03:48,540
pretty decent hot there a little bit

00:03:46,350 --> 00:03:51,030
later the zebra author tried to

00:03:48,540 --> 00:03:54,810
commercialize it and make a living off

00:03:51,030 --> 00:03:56,040
it which ended like it usually does when

00:03:54,810 --> 00:03:59,520
people try that with open source

00:03:56,040 --> 00:04:00,600
software diet the most frustrated users

00:03:59,520 --> 00:04:04,850
then for croire

00:04:00,600 --> 00:04:07,830
and still try to try to cope with it but

00:04:04,850 --> 00:04:11,130
since the the basic design is already so

00:04:07,830 --> 00:04:16,950
far often so wrong this has no chance of

00:04:11,130 --> 00:04:21,290
working so starting with bgp di sends a

00:04:16,950 --> 00:04:21,290
pattern here Theo is to blame

00:04:22,960 --> 00:04:29,260
at one point one point when I was in

00:04:25,360 --> 00:04:33,180
Calgary I the veers to blame of course

00:04:29,260 --> 00:04:33,180
but I think you bought it

00:04:33,690 --> 00:04:39,070
so I mentioned I mentioned all this too

00:04:37,270 --> 00:04:43,830
for you and I kind of mentioned that

00:04:39,070 --> 00:04:46,420
that I kinda consider writing my own

00:04:43,830 --> 00:04:49,120
implementation but you know it seemed to

00:04:46,420 --> 00:04:51,520
be a way too big task and unfortunately

00:04:49,120 --> 00:04:55,510
I feel didn't drink enough so he did

00:04:51,520 --> 00:04:59,710
remember this the next morning and kept

00:04:55,510 --> 00:05:02,880
nagging until I actually started I was

00:04:59,710 --> 00:05:05,710
in late 2003 I was like 2004

00:05:02,880 --> 00:05:09,790
there's no you anyway

00:05:05,710 --> 00:05:13,090
anyway so I eventually start hacking by

00:05:09,790 --> 00:05:15,550
the time I was able to speak to another

00:05:13,090 --> 00:05:18,130
PG fear or another BGP implementation

00:05:15,550 --> 00:05:19,930
like the entire session management but

00:05:18,130 --> 00:05:23,320
not actually exchanging any routing

00:05:19,930 --> 00:05:24,820
information I started to to show the

00:05:23,320 --> 00:05:27,640
prototype to a couple of people

00:05:24,820 --> 00:05:30,390
the one person who sent a meaningful

00:05:27,640 --> 00:05:35,680
reply was Claudio did he leave the room

00:05:30,390 --> 00:05:39,520
yes he did the one person who sent me

00:05:35,680 --> 00:05:41,770
over I said was Claudio and in December

00:05:39,520 --> 00:05:43,810
we finally reached the state where we

00:05:41,770 --> 00:05:45,910
could exchange very basic routing

00:05:43,810 --> 00:05:49,990
information with another peer and at

00:05:45,910 --> 00:05:52,300
that point we imported my initial PGP

00:05:49,990 --> 00:05:56,130
implementation into the OpenBSD tree or

00:05:52,300 --> 00:05:56,130
while doing so we also imported Claudio

00:05:57,210 --> 00:06:03,700
the protocol itself is surprisingly

00:06:01,120 --> 00:06:06,300
simple actually which of you is Borak

00:06:03,700 --> 00:06:09,690
every protocol its defined in that our

00:06:06,300 --> 00:06:13,270
sea-ice please taught that to each other

00:06:09,690 --> 00:06:15,580
every ISP basically announces the list

00:06:13,270 --> 00:06:18,910
of networks that are reachable through

00:06:15,580 --> 00:06:22,840
him not just his own ones but through

00:06:18,910 --> 00:06:25,240
him since dealing with that at the

00:06:22,840 --> 00:06:29,140
network level is a lot of data like the

00:06:25,240 --> 00:06:31,840
traceroute style a lot of data and it's

00:06:29,140 --> 00:06:33,430
sometimes inaccurate you summarize the

00:06:31,840 --> 00:06:34,210
networks into autonomous systems so

00:06:33,430 --> 00:06:40,259
typically

00:06:34,210 --> 00:06:45,729
ISP is one autonomous system instead of

00:06:40,259 --> 00:06:48,789
dealing with IP Panthers BGP looks at a

00:06:45,729 --> 00:06:53,979
s path so each and every ISP is just one

00:06:48,789 --> 00:06:58,150
hop one a s a BGP speaker will announce

00:06:53,979 --> 00:07:02,500
the networks that like the the this is

00:06:58,150 --> 00:07:05,020
piece own networks and it can doesn't

00:07:02,500 --> 00:07:08,530
necessarily have to but it can announce

00:07:05,020 --> 00:07:10,599
the networks it learned from other BGP

00:07:08,530 --> 00:07:15,330
speakers so typically that would be

00:07:10,599 --> 00:07:18,880
downstream customers the a s Panthers

00:07:15,330 --> 00:07:21,310
are just the a s numbers written written

00:07:18,880 --> 00:07:23,770
by on each other starting first one this

00:07:21,310 --> 00:07:26,470
is the the next one this is the final

00:07:23,770 --> 00:07:28,389
destination in this case the OpenBSD a s

00:07:26,470 --> 00:07:32,229
and to reach that we have to go through

00:07:28,389 --> 00:07:37,900
these two guesses that probably changed

00:07:32,229 --> 00:07:40,630
by an order path if he really only knows

00:07:37,900 --> 00:07:43,000
about four messages there's a fifth

00:07:40,630 --> 00:07:45,340
added later but basically four messages

00:07:43,000 --> 00:07:47,949
there's an open message that you send

00:07:45,340 --> 00:07:50,289
once the TCP session is established that

00:07:47,949 --> 00:07:52,030
tells you appear your own a s number a

00:07:50,289 --> 00:07:55,300
couple of timing parameters and stuff

00:07:52,030 --> 00:07:56,530
like that there are the keeper lives are

00:07:55,300 --> 00:07:59,650
already mentioned that are frequently

00:07:56,530 --> 00:08:01,870
exchanged to make sure that the the

00:07:59,650 --> 00:08:03,270
connectivity between the BGP speakers is

00:08:01,870 --> 00:08:05,830
still there

00:08:03,270 --> 00:08:07,449
we have update messages which are the

00:08:05,830 --> 00:08:09,250
the interesting ones because those

00:08:07,449 --> 00:08:13,570
contain the actual routing information

00:08:09,250 --> 00:08:16,360
and there's the the one you don't want

00:08:13,570 --> 00:08:18,940
to see the notification that means that

00:08:16,360 --> 00:08:21,400
a fatal error happened and when you send

00:08:18,940 --> 00:08:23,440
a notification or receive one you are

00:08:21,400 --> 00:08:29,500
required to tear the session down and

00:08:23,440 --> 00:08:31,709
delete the routes so BGP design I did

00:08:29,500 --> 00:08:37,300
not want to go for threats surprisingly

00:08:31,709 --> 00:08:40,440
so we went for three processes one I

00:08:37,300 --> 00:08:43,810
named T session engine which is just

00:08:40,440 --> 00:08:47,300
responsible for dealing with the TCP

00:08:43,810 --> 00:08:50,270
connections to to the other BGP speakers

00:08:47,300 --> 00:08:51,560
it does not itself in any way deal with

00:08:50,270 --> 00:08:54,590
the routing information it has not even

00:08:51,560 --> 00:08:58,160
parsed that part it just passes that on

00:08:54,590 --> 00:09:01,240
to the route decision engine which does

00:08:58,160 --> 00:09:03,770
all the world useful all the routing

00:09:01,240 --> 00:09:05,630
that's also the point where the decision

00:09:03,770 --> 00:09:08,540
which route to a given destination as

00:09:05,630 --> 00:09:12,940
best is taken and there's a parent

00:09:08,540 --> 00:09:16,070
process that talks to the kernel and

00:09:12,940 --> 00:09:21,590
starts the the session engine and the

00:09:16,070 --> 00:09:22,760
RTE so that's the basic design slightly

00:09:21,590 --> 00:09:27,080
more complicated than that but that's

00:09:22,760 --> 00:09:30,200
the basic design the master process to

00:09:27,080 --> 00:09:32,540
the left runs as route it has to because

00:09:30,200 --> 00:09:33,740
it wants to change career outing the

00:09:32,540 --> 00:09:39,170
corner routing table which requires

00:09:33,740 --> 00:09:42,650
route it also deals with encryption keys

00:09:39,170 --> 00:09:45,920
which is also a function that requires

00:09:42,650 --> 00:09:47,060
root permissions it Forks off the

00:09:45,920 --> 00:09:49,940
session end on the road to certain

00:09:47,060 --> 00:09:52,700
engine which then drop privileges to an

00:09:49,940 --> 00:09:54,980
unprivileged user and Truitt's itself

00:09:52,700 --> 00:10:00,020
into VAR MT which as the name indicates

00:09:54,980 --> 00:10:02,590
is empty almost upon - recently there

00:10:00,020 --> 00:10:05,660
was a logic socket in there

00:10:02,590 --> 00:10:08,360
the communication between those

00:10:05,660 --> 00:10:10,700
processes happens over over socket pairs

00:10:08,360 --> 00:10:12,230
so the master process sends

00:10:10,700 --> 00:10:15,560
configuration information to the other

00:10:12,230 --> 00:10:16,730
two the session engine sends the routing

00:10:15,560 --> 00:10:19,550
information that learns from its

00:10:16,730 --> 00:10:21,980
neighbors to the rata certain engine and

00:10:19,550 --> 00:10:22,840
of course events like that peer just

00:10:21,980 --> 00:10:27,290
went away

00:10:22,840 --> 00:10:29,330
the route decision engine talks to the

00:10:27,290 --> 00:10:31,370
master process to validate the next

00:10:29,330 --> 00:10:32,870
stops it learns from from its peers you

00:10:31,370 --> 00:10:35,180
don't want to install a route into the

00:10:32,870 --> 00:10:39,230
kernel where the next gate way is not

00:10:35,180 --> 00:10:40,970
reachable right and eventually it fits

00:10:39,230 --> 00:10:43,310
the routes to the master process or the

00:10:40,970 --> 00:10:45,890
master process can enter them into the

00:10:43,310 --> 00:10:49,150
kernel routing table the session endl is

00:10:45,890 --> 00:10:52,400
the only one talking to the network and

00:10:49,150 --> 00:10:52,820
as I mentioned this is an important

00:10:52,400 --> 00:10:55,730
point

00:10:52,820 --> 00:10:57,740
these run without any meaningful

00:10:55,730 --> 00:10:59,580
privileges they have no special features

00:10:57,740 --> 00:11:04,370
in the system whatsoever

00:10:59,580 --> 00:11:06,300
and our chain rule is we are once again

00:11:04,370 --> 00:11:09,600
following the principle of least

00:11:06,300 --> 00:11:11,459
privilege here so the the each and every

00:11:09,600 --> 00:11:15,330
process only has the privileges it

00:11:11,459 --> 00:11:17,459
really needs to do fulfill its task when

00:11:15,330 --> 00:11:20,310
the when one of the unwritten processes

00:11:17,459 --> 00:11:22,920
need some some operation to be done

00:11:20,310 --> 00:11:24,720
that requires privileges it asks the

00:11:22,920 --> 00:11:27,570
master process to do that for other

00:11:24,720 --> 00:11:32,100
parent process to do that and send back

00:11:27,570 --> 00:11:33,600
the results kind of the session engine

00:11:32,100 --> 00:11:38,279
its root privileges for one single

00:11:33,600 --> 00:11:42,690
operation that's binding to the TCP port

00:11:38,279 --> 00:11:44,490
on 197 and as I mentioned the parent

00:11:42,690 --> 00:11:46,680
process obviously needs root formation

00:11:44,490 --> 00:11:49,380
since its modifies the corner routing

00:11:46,680 --> 00:11:55,649
table and IPSec flows but we will get to

00:11:49,380 --> 00:12:00,329
that later so - to be able to bind to -

00:11:55,649 --> 00:12:02,070
that low port you could just bind to the

00:12:00,329 --> 00:12:03,930
port and then drop privileges but that

00:12:02,070 --> 00:12:06,450
doesn't quite work out because we might

00:12:03,930 --> 00:12:09,000
have to do this again later after

00:12:06,450 --> 00:12:13,260
dropping privileges so the way we do

00:12:09,000 --> 00:12:15,600
this is the parent process thus creates

00:12:13,260 --> 00:12:18,480
the socket and binds to it and then uses

00:12:15,600 --> 00:12:23,670
fire descriptor passing to send the

00:12:18,480 --> 00:12:25,410
socket over to the session engine the

00:12:23,670 --> 00:12:28,589
parent unfortunately has to keep track

00:12:25,410 --> 00:12:30,870
of which file descriptors the session is

00:12:28,589 --> 00:12:33,959
open so it doesn't bind to the same I'm

00:12:30,870 --> 00:12:39,120
sorry to the same port on the same

00:12:33,959 --> 00:12:41,640
Epirus again since now the session

00:12:39,120 --> 00:12:43,890
engine is not doing that point itself

00:12:41,640 --> 00:12:48,089
anymore it's perfectly fine to run

00:12:43,890 --> 00:12:51,899
without any special privileges so

00:12:48,089 --> 00:12:53,930
session engine as I've probably made

00:12:51,899 --> 00:12:55,760
clear I don't quite believe in threats

00:12:53,930 --> 00:12:58,980
[Music]

00:12:55,760 --> 00:13:01,709
so if you are not doing one one thread

00:12:58,980 --> 00:13:03,630
per connection the other end model to do

00:13:01,709 --> 00:13:06,660
this without one process for connection

00:13:03,630 --> 00:13:08,790
which is also stupid the the only other

00:13:06,660 --> 00:13:11,790
option is to go for a non-blocking a

00:13:08,790 --> 00:13:13,170
synchronous design that last not least

00:13:11,790 --> 00:13:15,300
means we have to put

00:13:13,170 --> 00:13:17,880
all sockets a non-locking note what does

00:13:15,300 --> 00:13:21,839
that mean usually when we have a socket

00:13:17,880 --> 00:13:23,910
and we call right on it say with 64

00:13:21,839 --> 00:13:30,089
bytes so that's a little bit more

00:13:23,910 --> 00:13:32,339
perhaps 128 bytes and at that time the

00:13:30,089 --> 00:13:34,699
kernel can only get rid of say 50 of

00:13:32,339 --> 00:13:37,949
those bytes because the peers to slow

00:13:34,699 --> 00:13:42,779
the right call will block and will only

00:13:37,949 --> 00:13:44,940
return to your to your code once it's

00:13:42,779 --> 00:13:49,800
done with 120 bytes completely it will

00:13:44,940 --> 00:13:53,610
sleep once we switched the socket of non

00:13:49,800 --> 00:13:55,529
locking mode it as soon as it cannot

00:13:53,610 --> 00:13:58,170
proceed immediately it will not sleep it

00:13:55,529 --> 00:14:01,800
will return tell us hey I wrote 50 bytes

00:13:58,170 --> 00:14:03,930
and the remaining 78 bytes you will have

00:14:01,800 --> 00:14:08,880
to write again later but you need to

00:14:03,930 --> 00:14:11,220
take care of that in your code so that

00:14:08,880 --> 00:14:12,930
the consequence of that is that you have

00:14:11,220 --> 00:14:14,550
to do the buffer management yourself and

00:14:12,930 --> 00:14:16,529
keep track of which of those bytes you

00:14:14,550 --> 00:14:23,160
already got rid of at which you still

00:14:16,529 --> 00:14:26,040
have to write out to to abstract that I

00:14:23,160 --> 00:14:30,449
designed and pretty easy to use buffer

00:14:26,040 --> 00:14:33,930
API that's hiding all these details on

00:14:30,449 --> 00:14:35,279
top of that I added an API for the

00:14:33,930 --> 00:14:38,339
messaging between the process is called

00:14:35,279 --> 00:14:42,029
which I called I message does nothing it

00:14:38,339 --> 00:14:46,350
has nothing to do with that company with

00:14:42,029 --> 00:14:50,070
that company from the US that that

00:14:46,350 --> 00:14:51,570
turned out to be pretty I'm surprised

00:14:50,070 --> 00:14:54,360
myself but that turned out to be a

00:14:51,570 --> 00:14:57,540
pretty smart thing because we're now

00:14:54,360 --> 00:14:59,370
using this this very same API and almost

00:14:57,540 --> 00:15:00,839
all newer open BSD daemon so of course

00:14:59,370 --> 00:15:03,149
it evolved and of course it's not just

00:15:00,839 --> 00:15:05,610
my code anymore but that was the the

00:15:03,149 --> 00:15:08,250
groundwork so these days it's actually

00:15:05,610 --> 00:15:18,120
in the util and not not duplicated on

00:15:08,250 --> 00:15:20,790
all the produce anymore that's an

00:15:18,120 --> 00:15:23,790
incomplete list of of programs in open

00:15:20,790 --> 00:15:25,860
BSD using that I think that's kind

00:15:23,790 --> 00:15:27,130
impressive you have to add HTTP Dino for

00:15:25,860 --> 00:15:30,830
example

00:15:27,130 --> 00:15:32,209
so the messaging obviously when you to

00:15:30,830 --> 00:15:33,980
prove a separate demons and have

00:15:32,209 --> 00:15:35,810
multiple processes each only running

00:15:33,980 --> 00:15:39,680
with the privileges it really needs the

00:15:35,810 --> 00:15:42,770
messaging is a core component BPD turn

00:15:39,680 --> 00:15:45,110
out to to be kinda complex within that

00:15:42,770 --> 00:15:47,720
area we went up to 66 different message

00:15:45,110 --> 00:15:51,529
type that's a lot to compare opens H has

00:15:47,720 --> 00:15:53,000
less they're not just using that

00:15:51,529 --> 00:15:55,610
messaging framework internally between

00:15:53,000 --> 00:15:57,610
the processes we're also using this

00:15:55,610 --> 00:16:01,010
between the little control utility

00:15:57,610 --> 00:16:02,870
hup-hup control which talks to be GPD

00:16:01,010 --> 00:16:06,110
using the very same library functions

00:16:02,870 --> 00:16:10,089
but instead of using a socket pair it

00:16:06,110 --> 00:16:12,020
goes over a UNIX domain sockets and

00:16:10,089 --> 00:16:14,149
iMessage doesn't really care about the

00:16:12,020 --> 00:16:18,620
underlying transport mechanism is it

00:16:14,149 --> 00:16:21,470
works over TCP just as well so session

00:16:18,620 --> 00:16:24,140
engine this mansion just maintains the

00:16:21,470 --> 00:16:26,390
sessions that's its job nothing else as

00:16:24,140 --> 00:16:28,250
soon as the session is established and

00:16:26,390 --> 00:16:30,620
all the parameters are negotiated it

00:16:28,250 --> 00:16:32,930
frequently seats the case since the

00:16:30,620 --> 00:16:34,550
keeper lives out it keeps track of the

00:16:32,930 --> 00:16:36,980
keeper lives it gets from its neighbor

00:16:34,550 --> 00:16:40,250
so it can drop the connection if the

00:16:36,980 --> 00:16:41,720
peer is dead and it does not deal with

00:16:40,250 --> 00:16:46,370
routes at all I cannot stress this

00:16:41,720 --> 00:16:48,440
enough due to that we can be reasonably

00:16:46,370 --> 00:16:51,620
certain that we will never miss sending

00:16:48,440 --> 00:16:53,000
out the keep alive in time the session

00:16:51,620 --> 00:16:55,399
it is very very light light it's

00:16:53,000 --> 00:16:57,800
typically under five megabytes of RAM if

00:16:55,399 --> 00:16:59,870
it does get get bigger that's an

00:16:57,800 --> 00:17:02,120
indicator that one of your peers is very

00:16:59,870 --> 00:17:08,420
very very slow because it has to buffer

00:17:02,120 --> 00:17:11,480
a lot the RTE is where most of the magic

00:17:08,420 --> 00:17:13,459
happens that maintains the so called

00:17:11,480 --> 00:17:17,329
routing information base that's all the

00:17:13,459 --> 00:17:23,150
routes towards its implemented mostly as

00:17:17,329 --> 00:17:24,980
as massively interlink tables the most

00:17:23,150 --> 00:17:27,230
important ones are the prefix tables

00:17:24,980 --> 00:17:31,040
that's the the network's the routes the

00:17:27,230 --> 00:17:34,400
IP IP prefixes and of course the ass

00:17:31,040 --> 00:17:36,110
path tables the filtering runs there

00:17:34,400 --> 00:17:39,320
because you don't want to accept

00:17:36,110 --> 00:17:40,960
everything a random peer sense you it

00:17:39,320 --> 00:17:43,029
decides

00:17:40,960 --> 00:17:47,259
which of the path is it learns for

00:17:43,029 --> 00:17:49,659
specific prefix is the best and some

00:17:47,259 --> 00:17:52,210
well there's an algorithm saying this is

00:17:49,659 --> 00:17:56,619
the best what you call the best of

00:17:52,210 --> 00:17:58,779
course is up for a discussion and it

00:17:56,619 --> 00:18:01,450
does generate the routing updates to be

00:17:58,779 --> 00:18:02,769
sent out to the peers itself hence them

00:18:01,450 --> 00:18:06,669
off to the session angel' itll hands it

00:18:02,769 --> 00:18:09,940
off to the peers so um as mentioned

00:18:06,669 --> 00:18:13,119
heavily interlink tables the point here

00:18:09,940 --> 00:18:17,499
the main point here being that we do not

00:18:13,119 --> 00:18:20,830
want to do any table walks that's the

00:18:17,499 --> 00:18:26,129
way a certain commercial route of endor

00:18:20,830 --> 00:18:28,539
implemented this starts with lucy and

00:18:26,129 --> 00:18:30,190
that turned out to be a giant

00:18:28,539 --> 00:18:32,440
performance issue for them because every

00:18:30,190 --> 00:18:34,559
couple of minutes these walk the tables

00:18:32,440 --> 00:18:36,999
and clean them up process started and

00:18:34,559 --> 00:18:39,970
blocked off other operations so I did

00:18:36,999 --> 00:18:41,679
not want to repeat that mistake it

00:18:39,970 --> 00:18:43,450
obviously has to be very memory

00:18:41,679 --> 00:18:45,690
efficient because we potentially deal

00:18:43,450 --> 00:18:50,649
over there with a lot of routes here and

00:18:45,690 --> 00:18:53,740
of course I want it to be fast the

00:18:50,649 --> 00:18:57,429
decision process I mentioned to decide

00:18:53,740 --> 00:19:01,059
which of the path is is best the first

00:18:57,429 --> 00:19:03,549
track is the prefix eligible which

00:19:01,059 --> 00:19:05,710
really means is the gateway reachable

00:19:03,549 --> 00:19:11,320
was once again we don't want to install

00:19:05,710 --> 00:19:13,629
their routes second step is the

00:19:11,320 --> 00:19:15,820
so-called local preference that comes

00:19:13,629 --> 00:19:18,429
from your configuration which you can

00:19:15,820 --> 00:19:21,669
use to force BGP need to pick a certain

00:19:18,429 --> 00:19:24,730
part for certain prefix the third one is

00:19:21,669 --> 00:19:28,990
the one that is supposed to kick in

00:19:24,730 --> 00:19:33,330
usually you want to pick the shortest

00:19:28,990 --> 00:19:36,669
path first that's likely the fastest

00:19:33,330 --> 00:19:38,830
these days with ISPs becoming bigger and

00:19:36,669 --> 00:19:42,789
bigger and some is is covering half the

00:19:38,830 --> 00:19:46,419
world that it's not the best manner

00:19:42,789 --> 00:19:50,799
anymore but well still everything after

00:19:46,419 --> 00:19:55,180
is really mostly there to make sure that

00:19:50,799 --> 00:19:58,990
we decide on a best one so the next step

00:19:55,180 --> 00:20:01,150
is origin which indicates whether that

00:19:58,990 --> 00:20:03,850
route originally comes from OSPF or

00:20:01,150 --> 00:20:05,710
statically configured or the like

00:20:03,850 --> 00:20:07,480
then there's the multi exit

00:20:05,710 --> 00:20:11,770
discriminator please don't make me

00:20:07,480 --> 00:20:13,930
explain that then kind of already gives

00:20:11,770 --> 00:20:16,030
up external EGP is cooler than the

00:20:13,930 --> 00:20:19,780
internal BGP sessions internal is of

00:20:16,030 --> 00:20:23,170
both yourself the same is number the

00:20:19,780 --> 00:20:25,600
added weight that comes from the

00:20:23,170 --> 00:20:27,640
configuration as well you can use that

00:20:25,600 --> 00:20:31,450
to indicate a preference for a certain

00:20:27,640 --> 00:20:34,270
link the next one is another extension

00:20:31,450 --> 00:20:37,390
we edit the older one is better because

00:20:34,270 --> 00:20:38,950
the older is more stable well and then

00:20:37,390 --> 00:20:41,650
it becomes kind of hilarious

00:20:38,950 --> 00:20:44,559
the lowest bgp ID wins what's the BGP ID

00:20:41,650 --> 00:20:50,530
the BGP ID is the numerically lowest

00:20:44,559 --> 00:20:54,220
ipv4 address on the system if that still

00:20:50,530 --> 00:20:56,890
doesn't doesn't give a winner which is

00:20:54,220 --> 00:20:59,650
kind of possible but so the shorter

00:20:56,890 --> 00:21:01,510
class the list will ignore that cluster

00:20:59,650 --> 00:21:01,960
stuff for a moment if that still doesn't

00:21:01,510 --> 00:21:03,580
work

00:21:01,960 --> 00:21:06,910
the numerically lowest pure address

00:21:03,580 --> 00:21:13,450
works good indicator and if that doesn't

00:21:06,910 --> 00:21:16,150
work you're screwed so um you see

00:21:13,450 --> 00:21:18,460
equally long a s path is more and more

00:21:16,150 --> 00:21:22,870
because the bigger ISP is all peer in

00:21:18,460 --> 00:21:24,309
the same spots at least in Europe and

00:21:22,870 --> 00:21:26,500
for traffic engineering you want to be

00:21:24,309 --> 00:21:29,800
able to express a preference for for one

00:21:26,500 --> 00:21:31,390
of your upstream providers this is not

00:21:29,800 --> 00:21:33,400
local preference because local

00:21:31,390 --> 00:21:35,770
preference you force traffic onto that

00:21:33,400 --> 00:21:38,230
one you just want to indicate if they

00:21:35,770 --> 00:21:40,600
are equally good prefer that one and

00:21:38,230 --> 00:21:46,210
that's really what that great extension

00:21:40,600 --> 00:21:50,260
we added is coming back to the parent

00:21:46,210 --> 00:21:54,580
process which really is BGP DS interface

00:21:50,260 --> 00:21:57,309
to the kernel besides getting the actual

00:21:54,580 --> 00:21:59,230
routes and through the kernel it does

00:21:57,309 --> 00:22:00,640
the next of validation for the RTE as

00:21:59,230 --> 00:22:02,890
mentioned you don't want to install that

00:22:00,640 --> 00:22:05,100
out so we have to figure out that the

00:22:02,890 --> 00:22:07,399
next stops next stops the Gateway is

00:22:05,100 --> 00:22:10,669
actually reachable

00:22:07,399 --> 00:22:12,320
to be able to do that it maintains its

00:22:10,669 --> 00:22:13,549
own copy of the corner routing table it

00:22:12,320 --> 00:22:15,139
can be quite big right we're talking

00:22:13,549 --> 00:22:16,929
four hundred thousand interest around

00:22:15,139 --> 00:22:21,859
sorry

00:22:16,929 --> 00:22:23,419
four thousand entries roughly so to do

00:22:21,859 --> 00:22:25,999
that it fetches the entire corner rowing

00:22:23,419 --> 00:22:28,489
table on on startup and the interface

00:22:25,999 --> 00:22:31,159
list as well and now it obviously has to

00:22:28,489 --> 00:22:34,629
keep that in suit with the kernel to do

00:22:31,159 --> 00:22:37,879
that it listens to the rowdy sockets

00:22:34,629 --> 00:22:39,379
whenever a route is chained or to change

00:22:37,879 --> 00:22:40,820
the route from user to send a message to

00:22:39,379 --> 00:22:42,679
on the routing socket to the kernel and

00:22:40,820 --> 00:22:44,779
the kernel will relay that message to

00:22:42,679 --> 00:22:47,570
all listeners on their audio socket so

00:22:44,779 --> 00:22:53,359
as long as you see all the messages and

00:22:47,570 --> 00:22:58,190
don't miss one which actually is

00:22:53,359 --> 00:23:00,950
possible you can we can keep your

00:22:58,190 --> 00:23:02,599
internal coffee in sook and well that's

00:23:00,950 --> 00:23:05,719
exactly how we do it and that also means

00:23:02,599 --> 00:23:07,879
that if you manually modify routes on on

00:23:05,719 --> 00:23:10,429
the bgp router which we people noticed

00:23:07,879 --> 00:23:16,369
that and cope with it which the other

00:23:10,429 --> 00:23:17,719
implementations don't or many other we

00:23:16,369 --> 00:23:20,059
also need to list of interfaces because

00:23:17,719 --> 00:23:22,489
the interface goes down we want to

00:23:20,059 --> 00:23:30,259
invalidate all routes that use that

00:23:22,489 --> 00:23:32,419
interface obviously since we keep that

00:23:30,259 --> 00:23:35,029
and sync by listening to the Raleigh

00:23:32,419 --> 00:23:38,119
socket interface link state is announced

00:23:35,029 --> 00:23:39,729
there the BGP D process actually notices

00:23:38,119 --> 00:23:43,669
when you pull the cable and reacts and

00:23:39,729 --> 00:23:46,099
sorry reacts immediately opposed to a

00:23:43,669 --> 00:23:48,229
certain commercial implementation that

00:23:46,099 --> 00:23:51,460
has to wait for the next or next run of

00:23:48,229 --> 00:23:51,460
that table cleanup process

00:23:53,980 --> 00:24:02,240
so that that internal view of the kernel

00:23:59,900 --> 00:24:03,470
routing table can be coupled and

00:24:02,240 --> 00:24:07,100
decoupled from the kernel

00:24:03,470 --> 00:24:09,980
why because I could basically it's it's

00:24:07,100 --> 00:24:11,390
you have to have a mode to run be GPD

00:24:09,980 --> 00:24:13,640
without modifying the corner routing

00:24:11,390 --> 00:24:15,980
table if you're not actually running on

00:24:13,640 --> 00:24:18,530
a on a router but on the system that

00:24:15,980 --> 00:24:21,890
just relays BGP info information to

00:24:18,530 --> 00:24:24,710
other BGP speakers there is no point in

00:24:21,890 --> 00:24:28,460
updating the corner routing table since

00:24:24,710 --> 00:24:31,010
the code was was there to do couple or

00:24:28,460 --> 00:24:33,560
decouple it could as well make that a

00:24:31,010 --> 00:24:37,820
switch to be able to do this run time

00:24:33,560 --> 00:24:40,400
and surprisingly this was super fast on

00:24:37,820 --> 00:24:43,310
ten years old hardware in written ten

00:24:40,400 --> 00:24:47,240
years ago I took under 10 seconds to

00:24:43,310 --> 00:24:50,630
feed the entire back then three hundred

00:24:47,240 --> 00:24:54,530
thousand four fifty thousand rods into

00:24:50,630 --> 00:24:58,040
the kernel within ten seconds it's

00:24:54,530 --> 00:25:00,200
pretty impressive memory efficiency is

00:24:58,040 --> 00:25:02,810
still there we still managed to squeeze

00:25:00,200 --> 00:25:09,260
four thousand routes and roughly 32

00:25:02,810 --> 00:25:12,650
megabytes so since its kind of obvious

00:25:09,260 --> 00:25:14,780
that that your bgp sessions are in the

00:25:12,650 --> 00:25:18,050
ETP TCP sessions are a nice attack

00:25:14,780 --> 00:25:20,510
vector somebody manages to make that

00:25:18,050 --> 00:25:22,790
session go away you remove the routes on

00:25:20,510 --> 00:25:26,180
the end your you might be offline if

00:25:22,790 --> 00:25:27,950
somebody manages to smuggle packets onto

00:25:26,180 --> 00:25:30,350
your TCP session you're even more

00:25:27,950 --> 00:25:34,640
screwed because he can make you route

00:25:30,350 --> 00:25:37,610
traffic towards his sniffing box so you

00:25:34,640 --> 00:25:41,210
really want to protect those and the BGP

00:25:37,610 --> 00:25:44,900
standards have an extension TCP md5

00:25:41,210 --> 00:25:47,870
which really is at the TCP level and not

00:25:44,900 --> 00:25:50,570
at the BGP level and it turned out that

00:25:47,870 --> 00:25:55,670
PSD always had code for that

00:25:50,570 --> 00:25:59,180
well that that code was not even for not

00:25:55,670 --> 00:26:01,970
just full of dragons it was even worse

00:25:59,180 --> 00:26:05,600
there was no way this code has ever ever

00:26:01,970 --> 00:26:06,800
worked impossible so the carried code

00:26:05,600 --> 00:26:11,060
around four-thirty

00:26:06,800 --> 00:26:12,560
that never worked brilliant so we just

00:26:11,060 --> 00:26:15,440
deleted it because it was pointless in

00:26:12,560 --> 00:26:20,360
unfixable and the notation was wrong

00:26:15,440 --> 00:26:23,480
instead we re implemented TCP md5 within

00:26:20,360 --> 00:26:27,410
the IPSec framework because it is kind

00:26:23,480 --> 00:26:30,620
of a special form of IPSec right that

00:26:27,410 --> 00:26:33,080
unfortunately means that I had to add

00:26:30,620 --> 00:26:36,560
the PF key interface to bgp which is the

00:26:33,080 --> 00:26:40,010
interface the kernel provides too many

00:26:36,560 --> 00:26:42,530
flights IPSec information that interface

00:26:40,010 --> 00:26:45,290
has been designed by a committee which

00:26:42,530 --> 00:26:47,030
is a guarantee for the specification

00:26:45,290 --> 00:26:52,910
completely suck at rabida completely

00:26:47,030 --> 00:26:54,860
decoupled from reality still it's the

00:26:52,910 --> 00:26:57,980
standard so I implemented that it was

00:26:54,860 --> 00:27:00,470
painful but that means that I could

00:26:57,980 --> 00:27:02,330
already talk to the crowd about a piece

00:27:00,470 --> 00:27:05,090
X stuff and that obviously made it much

00:27:02,330 --> 00:27:09,470
easier to read real crypto like use the

00:27:05,090 --> 00:27:11,930
real IPSec there's a nice example here

00:27:09,470 --> 00:27:17,210
on how to not implement md5 signatures

00:27:11,930 --> 00:27:19,490
and it's from FreeBSD in 2006 they added

00:27:17,210 --> 00:27:22,430
code to be able to calculate that that

00:27:19,490 --> 00:27:24,500
md5 signature and send it out but they

00:27:22,430 --> 00:27:26,780
did not bother adding the code to

00:27:24,500 --> 00:27:33,350
actually check the signature on incoming

00:27:26,780 --> 00:27:35,480
packets really really useful another way

00:27:33,350 --> 00:27:40,430
on how to not implement this is provided

00:27:35,480 --> 00:27:44,570
by a certain commercial vendor they do

00:27:40,430 --> 00:27:46,850
the TCP md5 signature check before they

00:27:44,570 --> 00:27:50,870
do the regular TCP tracks like sequence

00:27:46,850 --> 00:27:53,860
number match checksum matching so that

00:27:50,870 --> 00:27:58,880
actually became a denial-of-service

00:27:53,860 --> 00:28:03,080
backdoor why would you do the most

00:27:58,880 --> 00:28:05,930
expensive check first doesn't make sense

00:28:03,080 --> 00:28:08,750
to me this unfortunately spread the myth

00:28:05,930 --> 00:28:09,890
that TCP md5 stators because it opens

00:28:08,750 --> 00:28:13,880
the door for the amount of service

00:28:09,890 --> 00:28:16,160
attacks it seems like only juniper and

00:28:13,880 --> 00:28:17,690
open BSD got this right and this is

00:28:16,160 --> 00:28:19,550
astounding because it's not actually all

00:28:17,690 --> 00:28:21,500
that hard

00:28:19,550 --> 00:28:27,140
I think previously Estes fixed by now

00:28:21,500 --> 00:28:30,890
and I'm not sure about Cisco so instead

00:28:27,140 --> 00:28:33,380
of this half-baked crypto MV 5 GC and we

00:28:30,890 --> 00:28:35,000
5 stuff why why wouldn't we be able to

00:28:33,380 --> 00:28:37,220
do real IP second we're at the interface

00:28:35,000 --> 00:28:41,260
already so let's do that well static

00:28:37,220 --> 00:28:44,300
keys it's it's really not all that hard

00:28:41,260 --> 00:28:46,130
how does it work eg PD loads the

00:28:44,300 --> 00:28:48,320
security associations that's basically

00:28:46,130 --> 00:28:49,670
the keys into the kernel and it sets up

00:28:48,320 --> 00:28:53,420
the flows and you don't have to do

00:28:49,670 --> 00:28:55,280
anything manually turns out Juniper can

00:28:53,420 --> 00:28:58,640
do the same you can do the same thing

00:28:55,280 --> 00:28:59,980
and we are perfectly compatible and also

00:28:58,640 --> 00:29:01,670
all just works

00:28:59,980 --> 00:29:03,980
unfortunately and this is one of the

00:29:01,670 --> 00:29:05,630
lessons we learned even though juniper

00:29:03,980 --> 00:29:09,920
juniper machines support that drove us

00:29:05,630 --> 00:29:14,060
supports that basically no ISP enables

00:29:09,920 --> 00:29:16,520
that it's not being used most eyes

00:29:14,060 --> 00:29:19,000
please don't even use TCP md5 they keep

00:29:16,520 --> 00:29:22,970
their sessions entirely unencrypted and

00:29:19,000 --> 00:29:27,050
too easy to attack Cisco can't do that

00:29:22,970 --> 00:29:29,090
of course I mean it's entirely possible

00:29:27,050 --> 00:29:30,260
that there's some there's some features

00:29:29,090 --> 00:29:32,320
that you could pay extra for that

00:29:30,260 --> 00:29:36,380
implements that but as far as I'm aware

00:29:32,320 --> 00:29:39,050
it doesn't even exist and yeah well as

00:29:36,380 --> 00:29:42,410
mentioned unfortunately it's very very

00:29:39,050 --> 00:29:46,660
very uncommon to use any any of these

00:29:42,410 --> 00:29:50,540
techniques to protect the TCP sessions

00:29:46,660 --> 00:29:53,240
static heat IPSec is nice but how about

00:29:50,540 --> 00:29:57,770
dynamically key this would be even even

00:29:53,240 --> 00:30:01,220
better so you need isakmp reef these

00:29:57,770 --> 00:30:04,250
days could probably use Ike T to do the

00:30:01,220 --> 00:30:07,970
the keying so the keys are changed

00:30:04,250 --> 00:30:10,430
regularily the implementations actually

00:30:07,970 --> 00:30:12,110
are not that hard Beauty gets an unused

00:30:10,430 --> 00:30:14,750
pair of FB is that some kind of

00:30:12,110 --> 00:30:17,030
identifier basically from the kernel

00:30:14,750 --> 00:30:19,880
that uses them it still sets up the

00:30:17,030 --> 00:30:24,020
flows which is hard to do manually in

00:30:19,880 --> 00:30:26,360
the Isaac and VD configuration and PGP D

00:30:24,020 --> 00:30:28,700
already knows the endpoints so there's

00:30:26,360 --> 00:30:31,010
no point in the admins try having to

00:30:28,700 --> 00:30:33,500
repeat that information into another

00:30:31,010 --> 00:30:35,480
contract file which also means the eyes

00:30:33,500 --> 00:30:39,020
MPD only needs to deal with the keying

00:30:35,480 --> 00:30:41,870
now not all the other stuff when that a

00:30:39,020 --> 00:30:46,340
turn means that you can run Osaka MPD

00:30:41,870 --> 00:30:48,050
without any configuration it really is

00:30:46,340 --> 00:30:50,090
as simple as copying the key files over

00:30:48,050 --> 00:30:55,720
there are automatically generated start

00:30:50,090 --> 00:30:55,720
BGP D with the KF legs and go for beer

00:30:55,750 --> 00:31:09,530
so the TCP window size interesting topic

00:31:02,840 --> 00:31:12,370
in 2006 I think there was a kind of

00:31:09,530 --> 00:31:17,750
famous attack where people realized that

00:31:12,370 --> 00:31:21,740
it was kind of easy to smuggle the TCP

00:31:17,750 --> 00:31:24,110
rst onto an existing TCP search like

00:31:21,740 --> 00:31:26,090
from the outside and the reason being

00:31:24,110 --> 00:31:27,650
that the TCP windows were too big so the

00:31:26,090 --> 00:31:31,820
window of a loud sequence numbers was

00:31:27,650 --> 00:31:36,470
too big for PGP this is critical because

00:31:31,820 --> 00:31:40,820
session Gohan means routes gone so the

00:31:36,470 --> 00:31:44,330
default window is be used the default

00:31:40,820 --> 00:31:46,670
window unless you turn on TCP md5 or

00:31:44,330 --> 00:31:50,810
IPSec then we grow the window as far as

00:31:46,670 --> 00:31:58,220
we can to 64 K so conclusion IPSec or

00:31:50,810 --> 00:32:01,610
cryptography improved performance at

00:31:58,220 --> 00:32:03,680
some point we figure out that BGP is not

00:32:01,610 --> 00:32:05,090
just good for exchanging routing

00:32:03,680 --> 00:32:07,070
information I mean who are out that's

00:32:05,090 --> 00:32:09,940
just an IP address and and netmask

00:32:07,070 --> 00:32:13,280
basically right or prefix length so

00:32:09,940 --> 00:32:13,970
can't we use this for something else yes

00:32:13,280 --> 00:32:17,630
we can

00:32:13,970 --> 00:32:19,400
one of the more interesting ideas to use

00:32:17,630 --> 00:32:21,380
that that finally is being implemented

00:32:19,400 --> 00:32:25,880
now and Peter is giving the presentation

00:32:21,380 --> 00:32:27,760
right now I think right all right it's

00:32:25,880 --> 00:32:31,550
the integration with spam D to exchange

00:32:27,760 --> 00:32:37,430
IP addresses of hosts that send too much

00:32:31,550 --> 00:32:40,450
them always doing the other talk sorry

00:32:37,430 --> 00:32:44,530
[Music]

00:32:40,450 --> 00:32:48,500
I'm adding confusion here sorry for that

00:32:44,530 --> 00:32:51,770
so to make use of that BGP D needs to be

00:32:48,500 --> 00:32:55,240
able to talk to PF and well I might be

00:32:51,770 --> 00:32:58,490
biased here but also work a lot on VF I

00:32:55,240 --> 00:33:03,679
was kind of interested in in integrating

00:32:58,490 --> 00:33:05,480
the two how does that work in the BGP D

00:33:03,679 --> 00:33:07,520
filter language we have a way to pick

00:33:05,480 --> 00:33:11,960
the prefixes we want to insert into a

00:33:07,520 --> 00:33:13,160
specific table in PF that table with a

00:33:11,960 --> 00:33:15,470
table in the air if you could do

00:33:13,160 --> 00:33:18,620
anything that PF can do we can filter

00:33:15,470 --> 00:33:20,630
based on that if that information you

00:33:18,620 --> 00:33:23,179
can redirect back it's based on that

00:33:20,630 --> 00:33:27,110
information that's what's being done in

00:33:23,179 --> 00:33:28,660
the span breakfast distribution case you

00:33:27,110 --> 00:33:33,320
also kind of quality of service

00:33:28,660 --> 00:33:38,870
processing if you want opens up some

00:33:33,320 --> 00:33:42,710
pretty interesting options we have route

00:33:38,870 --> 00:33:44,660
labels now that's an extension I did in

00:33:42,710 --> 00:33:48,590
the kernel routing table where we are

00:33:44,660 --> 00:33:51,140
basically able to add originally 32 I

00:33:48,590 --> 00:33:53,540
think we do this to 64 bytes now free

00:33:51,140 --> 00:33:57,590
text from a sheet or out if you do a

00:33:53,540 --> 00:34:00,890
route get just see the label that's

00:33:57,590 --> 00:34:06,080
clear text stored in the kernel routing

00:34:00,890 --> 00:34:08,330
table with the route it's it's it's

00:34:06,080 --> 00:34:10,520
being set in the BGP filter language so

00:34:08,330 --> 00:34:12,500
here we match everything from a specific

00:34:10,520 --> 00:34:16,310
neighbor from a specific autonomous

00:34:12,500 --> 00:34:19,850
system and add that specific label that

00:34:16,310 --> 00:34:26,210
then ends up in the corner routing table

00:34:19,850 --> 00:34:29,149
PF can filter based on those labels said

00:34:26,210 --> 00:34:30,740
you can you can block traffic based on

00:34:29,149 --> 00:34:33,770
that but it's it's much more interesting

00:34:30,740 --> 00:34:36,200
to use that for other bits like quality

00:34:33,770 --> 00:34:38,210
of server processing so you can put all

00:34:36,200 --> 00:34:43,580
the routes that point to a specific eye

00:34:38,210 --> 00:34:45,440
speed and to a specific queue and of

00:34:43,580 --> 00:34:47,899
course you can slow this queue down and

00:34:45,440 --> 00:34:50,060
you can tell your customers I always

00:34:47,899 --> 00:34:51,250
told you that is PU slow

00:34:50,060 --> 00:34:54,290
[Music]

00:34:51,250 --> 00:34:56,780
it is really really powerful there are

00:34:54,290 --> 00:34:59,839
more useful applications I listed some

00:34:56,780 --> 00:35:01,580
here you can limit the states for a

00:34:59,839 --> 00:35:02,960
source address depending on the source

00:35:01,580 --> 00:35:05,330
there so if you know that most of you

00:35:02,960 --> 00:35:08,960
your attacks come from a specific ISP

00:35:05,330 --> 00:35:14,030
you can only apply those limitations to

00:35:08,960 --> 00:35:19,030
that isp it really helps in fighting

00:35:14,030 --> 00:35:22,790
this really not of service attacks carp

00:35:19,030 --> 00:35:25,040
your PGP router obviously is kind of

00:35:22,790 --> 00:35:27,109
important if it's down you're offline so

00:35:25,040 --> 00:35:31,310
how about being able to use two and a

00:35:27,109 --> 00:35:33,470
redundant set up and failover generally

00:35:31,310 --> 00:35:36,440
have carp to do that but now we just

00:35:33,470 --> 00:35:39,550
need to integrate the to be to be severe

00:35:36,440 --> 00:35:45,530
of the carp master or a backup state I

00:35:39,550 --> 00:35:49,220
have my own which is ver of the carp

00:35:45,530 --> 00:35:52,730
master backup state when the when the

00:35:49,220 --> 00:35:54,530
carpenter phase is in backup state BGP

00:35:52,730 --> 00:35:57,589
just keeps all the sessions depending on

00:35:54,530 --> 00:36:00,140
that one in idle state doing nothing and

00:35:57,589 --> 00:36:03,410
as soon as the carpenter phase becomes

00:36:00,140 --> 00:36:05,780
master which would be immediately tries

00:36:03,410 --> 00:36:06,980
to establish all the sessions to to cut

00:36:05,780 --> 00:36:09,080
the failover time and it's actually

00:36:06,980 --> 00:36:11,030
pretty damn efficient it works very very

00:36:09,080 --> 00:36:13,880
well that's exactly the setup I'm using

00:36:11,030 --> 00:36:22,460
for more than 10 years now I'm sorry for

00:36:13,880 --> 00:36:25,250
10 years the other way around who works

00:36:22,460 --> 00:36:29,119
as well PGP we can influence the carp

00:36:25,250 --> 00:36:31,099
master backup decision you do not want

00:36:29,119 --> 00:36:33,430
to become hard master I mean the carp

00:36:31,099 --> 00:36:35,570
interface is typically your your your

00:36:33,430 --> 00:36:37,940
default route for the inside machines

00:36:35,570 --> 00:36:40,369
right and you don't want your freshly

00:36:37,940 --> 00:36:43,250
rebooted bgp router to become master

00:36:40,369 --> 00:36:45,250
before it actually learned the routes so

00:36:43,250 --> 00:36:48,130
that's why the GPD

00:36:45,250 --> 00:36:51,980
can demote the carp interfaces to

00:36:48,130 --> 00:36:55,250
prevent that it'll only mode it when it

00:36:51,980 --> 00:36:56,690
has the the importantly you marked all

00:36:55,250 --> 00:37:00,020
sessions and the configuration

00:36:56,690 --> 00:37:01,369
it'll under mode car when the imported

00:37:00,020 --> 00:37:03,390
sessions are there established and

00:37:01,369 --> 00:37:08,839
they're all information is being

00:37:03,390 --> 00:37:15,420
changed one of my favorite topics

00:37:08,839 --> 00:37:18,930
ipv6 do I need to say anything about

00:37:15,420 --> 00:37:31,769
that really can you read the government

00:37:18,930 --> 00:37:33,420
message or do I have to read it out what

00:37:31,769 --> 00:37:42,299
these by sets have to be zero by

00:37:33,420 --> 00:37:46,400
definition no I don't know what to say

00:37:42,299 --> 00:37:49,980
what is really it's so horrible I mean

00:37:46,400 --> 00:37:53,940
next here's another example here's a

00:37:49,980 --> 00:37:56,819
function that's the the ipv4 version it

00:37:53,940 --> 00:38:00,329
takes takes the netmask and converts it

00:37:56,819 --> 00:38:03,180
into a prefix length so that's four

00:38:00,329 --> 00:38:04,859
lines of code and it's only four lines

00:38:03,180 --> 00:38:06,539
of code because the default route is a

00:38:04,859 --> 00:38:09,539
special case otherwise it would be one

00:38:06,539 --> 00:38:14,609
now let's look at the ipv6 version I'm

00:38:09,539 --> 00:38:17,089
sorry it doesn't fit the slide and yeah

00:38:14,609 --> 00:38:17,089
it's incomprehensible

00:38:18,740 --> 00:38:29,519
so PGP D filter language being so

00:38:24,569 --> 00:38:32,400
involved in PF I I tried to try to make

00:38:29,519 --> 00:38:35,190
the filters really look like PF and use

00:38:32,400 --> 00:38:36,930
the same approach so it's one big filter

00:38:35,190 --> 00:38:39,900
rule set and instead of having filter

00:38:36,930 --> 00:38:42,660
blocks or one filter / neighbor the

00:38:39,900 --> 00:38:45,930
syntax is like PF like PF it is last

00:38:42,660 --> 00:38:47,730
metrans it actually is a properly

00:38:45,930 --> 00:38:49,980
designed language this is nice to use

00:38:47,730 --> 00:38:52,759
it's not not just the software accident

00:38:49,980 --> 00:39:00,119
that happened which is the case for

00:38:52,759 --> 00:39:04,079
certain commercial implementations the

00:39:00,119 --> 00:39:06,869
filters are are typically very important

00:39:04,079 --> 00:39:09,029
unfortunately once again most is please

00:39:06,869 --> 00:39:11,670
don't do any filtering they'll receive

00:39:09,029 --> 00:39:16,470
anything their peers announced them so

00:39:11,670 --> 00:39:17,490
if your if your 5 employee peer suddenly

00:39:16,470 --> 00:39:19,920
announces hello

00:39:17,490 --> 00:39:21,420
Microsoft they believe it and this has

00:39:19,920 --> 00:39:25,230
happened that this frequently happens

00:39:21,420 --> 00:39:26,850
this is a big problem with proper

00:39:25,230 --> 00:39:30,960
filters in place this would not be

00:39:26,850 --> 00:39:34,890
positive but well at exchange points

00:39:30,960 --> 00:39:36,720
it's it's even more important at

00:39:34,890 --> 00:39:38,490
exchange points everybody typically

00:39:36,720 --> 00:39:40,230
peers for the route service because

00:39:38,490 --> 00:39:42,660
everybody peering with everybody

00:39:40,230 --> 00:39:44,100
obviously doesn't quite scale so there

00:39:42,660 --> 00:39:45,240
are route service everybody peers with

00:39:44,100 --> 00:39:48,750
the route service and the route service

00:39:45,240 --> 00:39:52,080
redistribute that information these

00:39:48,750 --> 00:39:55,170
route servers better filter what they

00:39:52,080 --> 00:39:57,240
accept from the exchange point members

00:39:55,170 --> 00:40:01,170
before redistributing that for everybody

00:39:57,240 --> 00:40:03,990
else right it's only some exchange

00:40:01,170 --> 00:40:07,800
points doing that the other is roughly

00:40:03,990 --> 00:40:09,180
half by now I'd say the other half of

00:40:07,800 --> 00:40:15,300
the accession points don't do any

00:40:09,180 --> 00:40:18,000
filtering at all once again this is

00:40:15,300 --> 00:40:21,320
especially problematic since everybody

00:40:18,000 --> 00:40:24,570
trusts those small service right and

00:40:21,320 --> 00:40:28,470
since since some exchange points get

00:40:24,570 --> 00:40:33,450
quite big the filters get very big we

00:40:28,470 --> 00:40:37,050
did we did load the filter used at the

00:40:33,450 --> 00:40:40,200
filtering used in Frankfurt at g6 the

00:40:37,050 --> 00:40:42,510
resulting route set was some 150,000

00:40:40,200 --> 00:40:45,900
lines or so because very massive and

00:40:42,510 --> 00:40:48,720
that's exactly the problem here with

00:40:45,900 --> 00:40:51,000
trying to implement those just like PF

00:40:48,720 --> 00:40:53,190
like one big rule set sequential

00:40:51,000 --> 00:40:56,010
evaluation and last metrons

00:40:53,190 --> 00:40:58,920
we do have a big performance problem

00:40:56,010 --> 00:41:01,440
there that was a mistake which we still

00:40:58,920 --> 00:41:02,910
haven't fixed unfortunately it will be

00:41:01,440 --> 00:41:05,160
much better to just do smaller filter

00:41:02,910 --> 00:41:09,330
blocks to apply them on a per neighbor

00:41:05,160 --> 00:41:10,770
basis at one point we'll have to do this

00:41:09,330 --> 00:41:12,869
but we keep saying this for these five

00:41:10,770 --> 00:41:14,300
years now it's not funny all the time to

00:41:12,869 --> 00:41:18,630
do so

00:41:14,300 --> 00:41:21,210
missed the example the ecosystem is

00:41:18,630 --> 00:41:22,650
quite important record UNIX UNIX machine

00:41:21,210 --> 00:41:25,140
doesn't suddenly become a good router

00:41:22,650 --> 00:41:29,570
just by installing a BGP speaker on so

00:41:25,140 --> 00:41:31,350
it's not just the BGP implementation we

00:41:29,570 --> 00:41:33,750
modified the kernel

00:41:31,350 --> 00:41:35,490
to make OpenBSD better Radha because

00:41:33,750 --> 00:41:37,740
there are priorities we've got multiple

00:41:35,490 --> 00:41:40,170
routes multiple routing tables and

00:41:37,740 --> 00:41:43,260
eventually routing domains we even got

00:41:40,170 --> 00:41:48,060
an MPLS stack and also it's not just BGP

00:41:43,260 --> 00:41:51,150
you also want SPF DV m RP D for

00:41:48,060 --> 00:41:56,760
multicast stuff and for the few places

00:41:51,150 --> 00:42:00,930
that's the run run let's the run rip we

00:41:56,760 --> 00:42:03,960
even got a rip tear implementation Hot

00:42:00,930 --> 00:42:08,850
Topic so called software versus

00:42:03,960 --> 00:42:10,350
so-called hardware routers many many ISP

00:42:08,850 --> 00:42:11,580
employees keep claiming they have to buy

00:42:10,350 --> 00:42:14,250
Hardware orders because all that

00:42:11,580 --> 00:42:17,760
software stuff is just and slow

00:42:14,250 --> 00:42:19,980
and whatever in reality most of the

00:42:17,760 --> 00:42:22,530
so-called hardware routers share exactly

00:42:19,980 --> 00:42:25,140
the same design it's basically a PC

00:42:22,530 --> 00:42:27,590
running software it's only the really

00:42:25,140 --> 00:42:30,500
really really big and expensive routers

00:42:27,590 --> 00:42:35,640
maybe on hundred thousand euros that

00:42:30,500 --> 00:42:39,360
implement implement more bits in

00:42:35,640 --> 00:42:42,870
dedicated hardware software orders can

00:42:39,360 --> 00:42:47,310
be realistically used up to somewhere

00:42:42,870 --> 00:42:49,380
around 10 gigabits that is quite a bit

00:42:47,310 --> 00:42:52,050
in reality you want to go a little bit

00:42:49,380 --> 00:42:54,990
lower because you you want to maintain

00:42:52,050 --> 00:42:58,380
some Headroom for attacks on the other

00:42:54,990 --> 00:43:00,030
hand of course that limit goes upwards

00:42:58,380 --> 00:43:04,890
every year because the hardware becomes

00:43:00,030 --> 00:43:06,810
faster and really nine percent serve the

00:43:04,890 --> 00:43:08,520
install PGP rollers don't handle that

00:43:06,810 --> 00:43:11,240
much for a fix so they are perfectly

00:43:08,520 --> 00:43:13,620
fine with a software implementation and

00:43:11,240 --> 00:43:15,360
obviously which would be to give much

00:43:13,620 --> 00:43:18,060
more flexibility than the dedicated

00:43:15,360 --> 00:43:20,190
hardware last at least because you can

00:43:18,060 --> 00:43:23,150
run TCP dump which you can't do on your

00:43:20,190 --> 00:43:25,530
on your commercial routers and

00:43:23,150 --> 00:43:28,430
especially the use cases like route

00:43:25,530 --> 00:43:31,370
servers that don't forward traffic

00:43:28,430 --> 00:43:34,920
really cry for software implementation

00:43:31,370 --> 00:43:37,220
so status it's rock-solid it's reliable

00:43:34,920 --> 00:43:39,000
as hell I can stand here not worry about

00:43:37,220 --> 00:43:41,820
dropping off the internet

00:43:39,000 --> 00:43:44,370
it is pretty much feature complete it's

00:43:41,820 --> 00:43:45,150
in use by many ISPs and exchange points

00:43:44,370 --> 00:43:47,670
I just learned

00:43:45,150 --> 00:43:51,240
we despite the filter performance

00:43:47,670 --> 00:43:55,799
problem have a market share about 30% at

00:43:51,240 --> 00:43:57,900
exchange points 1/3 not too bad there

00:43:55,799 --> 00:43:59,940
are some really really really big is

00:43:57,900 --> 00:44:01,470
piece using that so when you are sending

00:43:59,940 --> 00:44:03,210
or traffic from the internet chances of

00:44:01,470 --> 00:44:08,039
that passing and open usually in running

00:44:03,210 --> 00:44:12,869
BGP D is quite high of course it's much

00:44:08,039 --> 00:44:16,740
cheaper to buy run and operate than

00:44:12,869 --> 00:44:21,480
buying the big brand so-called hardware

00:44:16,740 --> 00:44:23,490
routers and for those who don't trust

00:44:21,480 --> 00:44:26,279
themselves of course you can buy

00:44:23,490 --> 00:44:30,359
commercial support from a couple of

00:44:26,279 --> 00:44:34,049
companies including mine and that's

00:44:30,359 --> 00:44:41,670
basically we don't have time for

00:44:34,049 --> 00:44:51,230
questions okay so it's coffee your

00:44:41,670 --> 00:44:57,029
questions well hi how do you cope with

00:44:51,230 --> 00:44:59,940
routing messages that are lost that's

00:44:57,029 --> 00:45:03,089
almost a separate talk because it's kind

00:44:59,940 --> 00:45:07,829
of hard we modified we modified the

00:45:03,089 --> 00:45:10,260
kernel to to figure out when that

00:45:07,829 --> 00:45:12,660
happens so in the kernel we know when

00:45:10,260 --> 00:45:14,730
that happens and then we sent a special

00:45:12,660 --> 00:45:17,059
message up the routing socket indicating

00:45:14,730 --> 00:45:19,200
hey you lost a couple of messages which

00:45:17,059 --> 00:45:25,440
you can use in userland

00:45:19,200 --> 00:45:29,640
to to refetch the entire stuff and how

00:45:25,440 --> 00:45:35,099
do you debug open BGP d these three

00:45:29,640 --> 00:45:38,369
beasts three that's a very that's not

00:45:35,099 --> 00:45:39,869
very specific most of the time by just

00:45:38,369 --> 00:45:43,740
adding a couple of front offs

00:45:39,869 --> 00:45:45,900
sometimes by inspecting the core image

00:45:43,740 --> 00:45:48,150
with GV if it actually done core which

00:45:45,900 --> 00:45:50,309
hasn't happened in a long time for me it

00:45:48,150 --> 00:45:53,190
really depends on what you're on right

00:45:50,309 --> 00:45:54,720
now but usually you get away with a

00:45:53,190 --> 00:45:59,210
couple of printers and it's faster than

00:45:54,720 --> 00:45:59,210
all the other techniques thank you

00:46:03,380 --> 00:46:11,900
what number of routes would you consider

00:46:06,079 --> 00:46:13,939
is production safe from the diesel

00:46:11,900 --> 00:46:16,059
maximum number from the BGP learned from

00:46:13,939 --> 00:46:20,869
the BGP decider from the chrono side

00:46:16,059 --> 00:46:24,559
actually both from the BGP decide the

00:46:20,869 --> 00:46:26,539
the only limit radius memory so I can't

00:46:24,559 --> 00:46:29,989
give you a number it's kind it's not

00:46:26,539 --> 00:46:33,170
infinite but for practical purposes it

00:46:29,989 --> 00:46:37,269
is the biggest one I'm aware of has over

00:46:33,170 --> 00:46:41,420
over 2 million ok so just for full feet

00:46:37,269 --> 00:46:45,499
but yeah that's just for 4 feets right

00:46:41,420 --> 00:46:47,989
no no more than 2 million prefixes ok

00:46:45,499 --> 00:46:50,239
it's a very large ISP that has all the

00:46:47,989 --> 00:46:51,949
customer rods in there like the DIA

00:46:50,239 --> 00:46:55,160
created ones that he's not going to

00:46:51,949 --> 00:46:56,749
publish outside it's very large fun and

00:46:55,160 --> 00:46:59,779
they do load them in the kernel it works

00:46:56,749 --> 00:47:01,999
so 2 million is definitely not yet a

00:46:59,779 --> 00:47:04,670
problem in the crowd of the limited

00:47:01,999 --> 00:47:05,929
really only is memory 2 but the kernel

00:47:04,670 --> 00:47:06,439
memory infrastructure is different than

00:47:05,929 --> 00:47:11,209
userland

00:47:06,439 --> 00:47:13,459
I can't give you a number it's once

00:47:11,209 --> 00:47:15,289
again for practical purposes not limited

00:47:13,459 --> 00:47:16,789
of course the bigger your chrono routing

00:47:15,289 --> 00:47:18,469
table the slower there's no other

00:47:16,789 --> 00:47:20,449
lookups so for the packet forwarding

00:47:18,469 --> 00:47:25,640
path that is a could be a performance

00:47:20,449 --> 00:47:30,459
problem and another question um I think

00:47:25,640 --> 00:47:36,619
two years ago I tried to use open BT PDF

00:47:30,459 --> 00:47:39,459
to implement C BGP and it does not had

00:47:36,619 --> 00:47:42,619
support does this process will change to

00:47:39,459 --> 00:47:46,189
bgp configurations is this changed now

00:47:42,619 --> 00:47:48,640
no ok so we are not feature complete

00:47:46,189 --> 00:47:48,640
groups

00:47:56,010 --> 00:48:00,700
so the questions

00:47:58,260 --> 00:48:04,800
everybody is strife everybody's like

00:48:00,700 --> 00:48:04,800

YouTube URL: https://www.youtube.com/watch?v=y_krYfVqljE


