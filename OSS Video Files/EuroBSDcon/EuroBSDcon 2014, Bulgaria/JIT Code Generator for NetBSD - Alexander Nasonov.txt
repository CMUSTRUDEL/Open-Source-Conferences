Title: JIT Code Generator for NetBSD - Alexander Nasonov
Publication date: 2019-10-13
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

The next release of NetBSD will have a support for Just-In-Time (JIT) compilation of bpf programs in the kernel; this change will greatly speed-up traffic sniffing on multiple platforms. Unlike similar interface in other operating systems, bpfjit uses a unified programming interface for code generation which is based on Stack Less JIT Compiler library (SLJIT) and which supports x86, mips, arm, sparc and some other platforms.The speaker will give an overview of SLJIT API and discuss some implementation details of the bpfjit code with emphasis on supported optimizations of bpf programs by JIT engine. He will also touch on unit testing of dynamically generated code running inside the kernel and on other areas in the NetBSD project where bpfjit can help in boosting performance.

Speaker biography:

Alex is a software developer working in the financial sector in the City of London. He often amuses fellow tube passengers with C or Lua coding in NetBSD console and sometimes even with the green kernel debugger prompt.
Captions: 
	00:00:01,100 --> 00:00:06,990
welcome everybody I'd like to introduce

00:00:04,080 --> 00:00:10,260
Alex and Anna's on off to you and he's

00:00:06,990 --> 00:00:12,559
going to talk about Justin time code

00:00:10,260 --> 00:00:14,490
generator inside the net beastie Colonel

00:00:12,559 --> 00:00:20,130
something we don't even have for

00:00:14,490 --> 00:00:22,170
architectures and Firefox hi so yeah I'm

00:00:20,130 --> 00:00:23,820
Alex and sorry I'm going to see it

00:00:22,170 --> 00:00:28,230
during my talk because I have a slight

00:00:23,820 --> 00:00:33,300
problem with my work and yeah it's going

00:00:28,230 --> 00:00:34,800
mostly to be talked about development

00:00:33,300 --> 00:00:37,110
this feature so it's mostly for

00:00:34,800 --> 00:00:40,530
developers but even though it's inside

00:00:37,110 --> 00:00:42,750
the kernel there is a it's not I will

00:00:40,530 --> 00:00:45,149
show you not only C code but I also show

00:00:42,750 --> 00:00:47,160
you lower court which can run in the

00:00:45,149 --> 00:00:49,920
kernel and you know it just just brings

00:00:47,160 --> 00:00:53,280
new possibilities and I only started

00:00:49,920 --> 00:00:55,590
doing while do well preparing for this

00:00:53,280 --> 00:00:56,910
talk because I needed some graphs and

00:00:55,590 --> 00:01:00,079
you know there is just ways to generate

00:00:56,910 --> 00:01:04,970
graphs rather than draw them manually

00:01:00,079 --> 00:01:09,110
and I've got quite quite a few of them

00:01:04,970 --> 00:01:14,280
so let's start so this project started

00:01:09,110 --> 00:01:16,020
near the Christmas time and I just I did

00:01:14,280 --> 00:01:18,210
before Christmas I did some research and

00:01:16,020 --> 00:01:20,880
I make a decision to start working on

00:01:18,210 --> 00:01:23,610
the project on the 26th of December and

00:01:20,880 --> 00:01:26,009
I created a repository on github but

00:01:23,610 --> 00:01:29,100
still there but it at the moment it's on

00:01:26,009 --> 00:01:31,530
them it's postponed till next March but

00:01:29,100 --> 00:01:36,000
I'm working on a switch to not be d3 and

00:01:31,530 --> 00:01:38,700
I like one year wait I I added the code

00:01:36,000 --> 00:01:41,520
to an abyss d3 but it was just the

00:01:38,700 --> 00:01:43,259
beginning I since then I did a couple of

00:01:41,520 --> 00:01:47,430
more iterations including some

00:01:43,259 --> 00:01:52,380
extensions to be pf1 which for our new

00:01:47,430 --> 00:01:54,990
packet filter by request so from in

00:01:52,380 --> 00:01:58,920
Davos and yeah and still working

00:01:54,990 --> 00:02:00,420
progress and you know just well prepared

00:01:58,920 --> 00:02:02,880
for the presentation I you know just

00:02:00,420 --> 00:02:05,219
discovered how cool to use lower hand

00:02:02,880 --> 00:02:06,509
you know just I'm going to switch that

00:02:05,219 --> 00:02:09,300
least reporter typing I'm going to

00:02:06,509 --> 00:02:13,560
switch to a you'll see

00:02:09,300 --> 00:02:15,610
so yeah I'll start with just basic basic

00:02:13,560 --> 00:02:19,690
just I think I assume everyone

00:02:15,610 --> 00:02:22,840
understand what DPF is and it's to

00:02:19,690 --> 00:02:25,180
enable jit you just need like if you run

00:02:22,840 --> 00:02:27,490
into and you know it's more I'm most

00:02:25,180 --> 00:02:31,140
likely module unless you compiled

00:02:27,490 --> 00:02:34,510
analytical yourself and you just need to

00:02:31,140 --> 00:02:36,580
load VP of mojo which automatically

00:02:34,510 --> 00:02:39,070
worlds associate module associate is the

00:02:36,580 --> 00:02:42,340
vibrator which I use for cogeneration

00:02:39,070 --> 00:02:50,610
I'll talk about it in a moment and then

00:02:42,340 --> 00:02:54,010
you just enable get through CTL - and

00:02:50,610 --> 00:02:56,380
for monolithic kernel you need to

00:02:54,010 --> 00:02:58,180
compile with associate options and be

00:02:56,380 --> 00:02:59,709
purged it option and also have to

00:02:58,180 --> 00:03:03,310
compile you also we need to turn it on

00:02:59,709 --> 00:03:07,860
and - you to use it you just need like

00:03:03,310 --> 00:03:10,000
type TCP dump then your filter program

00:03:07,860 --> 00:03:12,280
and then you can check whether it's

00:03:10,000 --> 00:03:14,470
compiled to not just use enough start

00:03:12,280 --> 00:03:16,950
and grab project and if you see the

00:03:14,470 --> 00:03:19,750
while and then you know this you have

00:03:16,950 --> 00:03:25,060
your program running the coolness is

00:03:19,750 --> 00:03:30,040
jittered and one one thing to note here

00:03:25,060 --> 00:03:32,950
is this you can you can turn on and off

00:03:30,040 --> 00:03:34,570
BPF at any time but it doesn't affect

00:03:32,950 --> 00:03:39,130
running programs if you put some

00:03:34,570 --> 00:03:40,630
programs not compiled then they will not

00:03:39,130 --> 00:03:42,310
be compiled when you turn on the g it

00:03:40,630 --> 00:03:47,200
they will continue our onion until

00:03:42,310 --> 00:03:50,130
interpreted until you restart if you

00:03:47,200 --> 00:03:55,299
stop TCP dump a start again will be

00:03:50,130 --> 00:04:00,070
compiled so why why I'm doing this well

00:03:55,299 --> 00:04:01,810
first of all it was for fun and there

00:04:00,070 --> 00:04:04,000
are some implementations in other

00:04:01,810 --> 00:04:05,890
operating systems and I thought it you

00:04:04,000 --> 00:04:10,620
know it would be nice to catch up and

00:04:05,890 --> 00:04:14,530
have our own GT bf interpreter or so it

00:04:10,620 --> 00:04:17,350
not interpreted the compiler achieve

00:04:14,530 --> 00:04:19,239
this this slide is supposed to be to

00:04:17,350 --> 00:04:22,660
show one one by a wine wine wine but I

00:04:19,239 --> 00:04:25,289
didn't managed to do it so yeah good

00:04:22,660 --> 00:04:28,930
news BPF is fast

00:04:25,289 --> 00:04:32,280
because VP of interpreters fast because

00:04:28,930 --> 00:04:35,139
it's in a small compact interpreter and

00:04:32,280 --> 00:04:37,630
but jib compile is is several times fast

00:04:35,139 --> 00:04:39,780
I'd I didn't do a lot of performance

00:04:37,630 --> 00:04:42,720
measurements it's clear that the kind of

00:04:39,780 --> 00:04:45,460
compiled code is faster and for short

00:04:42,720 --> 00:04:47,320
for short problem I tested one or two

00:04:45,460 --> 00:04:49,479
programs for one particular program it

00:04:47,320 --> 00:04:54,850
was four times faster roughly four times

00:04:49,479 --> 00:04:59,860
faster on my boxing on arm mg was

00:04:54,850 --> 00:05:02,370
running net the arm I was on was

00:04:59,860 --> 00:05:05,979
on on Linux because when I started I

00:05:02,370 --> 00:05:12,280
used I use not busy at home and used my

00:05:05,979 --> 00:05:15,250
arm Chromebook like just and I mostly

00:05:12,280 --> 00:05:18,039
mostly did according on the trail using

00:05:15,250 --> 00:05:20,199
my Chromebook but unfortunately it was

00:05:18,039 --> 00:05:27,039
Linux not-not-not unfortunately because

00:05:20,199 --> 00:05:28,930
you know I I maintained platform

00:05:27,039 --> 00:05:32,650
independence not independent but just

00:05:28,930 --> 00:05:34,479
you know it works on Linux and yeah it

00:05:32,650 --> 00:05:36,010
worked on Linux and I'ma be doing I'm

00:05:34,479 --> 00:05:43,000
pretty sure it should be straightforward

00:05:36,010 --> 00:05:46,389
to ported to to FreeBSD and yeah it was

00:05:43,000 --> 00:05:50,250
actually mostly user space but I waited

00:05:46,389 --> 00:05:52,599
just adapted it to the kernel space

00:05:50,250 --> 00:05:57,729
yeah and there is a because I'm using

00:05:52,599 --> 00:05:59,520
the Sajit library and I describe what

00:05:57,729 --> 00:06:01,810
they saw jet libraries but it has a

00:05:59,520 --> 00:06:04,449
small other head especially especially

00:06:01,810 --> 00:06:06,580
for short programs I think most of your

00:06:04,449 --> 00:06:08,470
head is in a provocative work of

00:06:06,580 --> 00:06:11,500
functions so it needs to save some

00:06:08,470 --> 00:06:14,110
registers when when you call a

00:06:11,500 --> 00:06:21,310
generative function like they have a

00:06:14,110 --> 00:06:26,440
special kind of ABI for : power to pass

00:06:21,310 --> 00:06:27,280
in arguments and stuff so yeah I will

00:06:26,440 --> 00:06:29,560
briefly discuss what

00:06:27,280 --> 00:06:31,240
BPF is I'm pretty sure everyone's

00:06:29,560 --> 00:06:33,009
familiar with this so basically it's a

00:06:31,240 --> 00:06:36,250
renter face to the kernel

00:06:33,009 --> 00:06:37,090
just to do packet filtering in the Cure

00:06:36,250 --> 00:06:39,840
now

00:06:37,090 --> 00:06:43,060
and it comes with machine machine

00:06:39,840 --> 00:06:44,530
compact machine language for not for

00:06:43,060 --> 00:06:49,930
real hardware but for some virtual

00:06:44,530 --> 00:06:53,080
machine and it's very simple so and it's

00:06:49,930 --> 00:06:55,090
usually wrapped or it's wrapped and we

00:06:53,080 --> 00:06:57,220
pick a pliable and this is what normally

00:06:55,090 --> 00:06:58,870
what people normally use but they don't

00:06:57,220 --> 00:07:02,080
have to use it you could send directly

00:06:58,870 --> 00:07:05,410
to the BPF device so when you do TCP

00:07:02,080 --> 00:07:09,310
dump it compiles the program from the

00:07:05,410 --> 00:07:11,080
high level field filter language to low

00:07:09,310 --> 00:07:12,490
level machine language and it send the

00:07:11,080 --> 00:07:15,040
ascenders to the kernel through the raw

00:07:12,490 --> 00:07:19,330
interface and it's usually interpreted

00:07:15,040 --> 00:07:20,979
in the kernel but it can be compiled so

00:07:19,330 --> 00:07:23,590
yeah as I said it's it's it's very

00:07:20,979 --> 00:07:26,340
simple outside it looks like function

00:07:23,590 --> 00:07:30,400
and a special written special assembly

00:07:26,340 --> 00:07:32,770
which you call and yeah if it has a

00:07:30,400 --> 00:07:35,919
single entry it doesn't do nested calls

00:07:32,770 --> 00:07:37,720
and has no side effect you just what you

00:07:35,919 --> 00:07:41,890
get back is the return value which is

00:07:37,720 --> 00:07:43,990
unsigned 32-bit integer so it has two

00:07:41,890 --> 00:07:45,729
registers a and XS the main religious

00:07:43,990 --> 00:07:48,789
tax is still early

00:07:45,729 --> 00:07:52,330
I think register sometimes it's used and

00:07:48,789 --> 00:07:57,640
that comes with a small stack 16 32 bit

00:07:52,330 --> 00:08:01,539
memory words and simple instructions

00:07:57,640 --> 00:08:05,520
like add multiply bit bit operations

00:08:01,539 --> 00:08:08,229
yeah the one exception because it was

00:08:05,520 --> 00:08:11,200
originally PF is interpreted and they

00:08:08,229 --> 00:08:14,169
thought if they combine two accurate

00:08:11,200 --> 00:08:16,150
three just here to operation then they

00:08:14,169 --> 00:08:19,300
get a speed-up for some very common

00:08:16,150 --> 00:08:24,370
operation so they are not backward jumps

00:08:19,300 --> 00:08:28,960
it always jumps forwards and therefore

00:08:24,370 --> 00:08:31,330
there are no loops this this was made

00:08:28,960 --> 00:08:33,130
for security yeah for security purpose

00:08:31,330 --> 00:08:36,880
because you don't want to hang your

00:08:33,130 --> 00:08:40,930
system from user space so no matter what

00:08:36,880 --> 00:08:44,290
it should finish in finite number of

00:08:40,930 --> 00:08:46,510
steps and there is also a limit of how

00:08:44,290 --> 00:08:49,810
long you can your program can

00:08:46,510 --> 00:08:52,650
so it indeed finishes in finite number

00:08:49,810 --> 00:08:56,980
of steps and it's quite quite small

00:08:52,650 --> 00:08:59,050
instructions so you can do that because

00:08:56,980 --> 00:09:01,060
it's filtering it's Everson is around

00:08:59,050 --> 00:09:05,680
loading from a packet and we can load

00:09:01,060 --> 00:09:12,790
the body half world and 32-bit word so

00:09:05,680 --> 00:09:15,000
there are some examples here oops so

00:09:12,790 --> 00:09:19,300
that index Lord sometimes you need to

00:09:15,000 --> 00:09:24,640
allow that unknown offset and use the X

00:09:19,300 --> 00:09:28,300
register so X past nine means at the the

00:09:24,640 --> 00:09:32,950
content of X is 9 and just load that

00:09:28,300 --> 00:09:38,580
data set and I also asked for a while

00:09:32,950 --> 00:09:43,120
ago asked to disable wraparound so I

00:09:38,580 --> 00:09:45,970
think wraparound is because for outside

00:09:43,120 --> 00:09:47,770
it's unscientific and there is no other

00:09:45,970 --> 00:09:51,580
flaws than other force its modular

00:09:47,770 --> 00:09:53,740
matrix that's why I call a wraparound so

00:09:51,580 --> 00:10:06,730
if you want to do X minus 1 law that X

00:09:53,740 --> 00:10:13,810
minus 1 offset you cannot do this by how

00:10:06,730 --> 00:10:16,260
you use it for the first time all right

00:10:13,810 --> 00:10:19,480
so this one so you cannot do this

00:10:16,260 --> 00:10:25,710
because it you know just the fact it's

00:10:19,480 --> 00:10:29,080
effectively mean this and it's not what

00:10:25,710 --> 00:10:30,910
EPA programs do they if if if they want

00:10:29,080 --> 00:10:33,700
to achieve the same effect they would

00:10:30,910 --> 00:10:38,050
just subtract 1 from X and you know just

00:10:33,700 --> 00:10:40,780
glow that X offset it has a genetic

00:10:38,050 --> 00:10:42,970
operation also by requests of indigo

00:10:40,780 --> 00:10:45,520
side the two extensions but these two

00:10:42,970 --> 00:10:50,170
extensions available inside the kernel

00:10:45,520 --> 00:10:51,940
and they introduce a very significant

00:10:50,170 --> 00:10:54,510
change to the

00:10:51,940 --> 00:10:56,890
at least to the compiler because those

00:10:54,510 --> 00:10:59,800
Kapusta function selection remember they

00:10:56,890 --> 00:11:02,290
both have side effects so it's not no

00:10:59,800 --> 00:11:04,150
it's not any more return value and

00:11:02,290 --> 00:11:06,100
that's all we get so you can modify

00:11:04,150 --> 00:11:07,930
external memory or you call it your own

00:11:06,100 --> 00:11:13,390
function which can you know modify

00:11:07,930 --> 00:11:14,740
something outside of vpf but this this

00:11:13,390 --> 00:11:16,390
is strictly limited to the kernel

00:11:14,740 --> 00:11:18,280
because we especially miss co-producer

00:11:16,390 --> 00:11:20,110
functions we can do a lot of stuff if

00:11:18,280 --> 00:11:25,840
you know if you do it from user space it

00:11:20,110 --> 00:11:30,190
we can break stuff is okay let's yeah

00:11:25,840 --> 00:11:31,900
let's take not sure it's it's not very

00:11:30,190 --> 00:11:33,550
visible I'm afraid and I have bigger

00:11:31,900 --> 00:11:39,240
this is the smallest

00:11:33,550 --> 00:11:45,670
filter problem so basically it starts by

00:11:39,240 --> 00:11:48,480
you know just trying to understand maybe

00:11:45,670 --> 00:11:48,480
I can zoom in

00:11:59,600 --> 00:12:08,240
so basically heat load setup set 12 half

00:12:04,490 --> 00:12:10,139
offset 12 and then it does a comparison

00:12:08,240 --> 00:12:12,660
here

00:12:10,139 --> 00:12:15,569
was it aria first of all it's for tcp/ip

00:12:12,660 --> 00:12:18,389
like simple very simple I you want to

00:12:15,569 --> 00:12:20,699
see IP packets so you just you know this

00:12:18,389 --> 00:12:22,499
program it's very simple just check the

00:12:20,699 --> 00:12:26,339
it's not enough set it checks the

00:12:22,499 --> 00:12:31,110
protocol field and compares with the

00:12:26,339 --> 00:12:33,209
based on value and if it's what if it's

00:12:31,110 --> 00:12:34,949
IP then it will reach on this value you

00:12:33,209 --> 00:12:40,410
short marks otherwise it will reach one

00:12:34,949 --> 00:12:42,720
zero and it's very common to the the

00:12:40,410 --> 00:12:44,369
last instructions each one zero and the

00:12:42,720 --> 00:12:46,350
one before is returned you shot marks

00:12:44,369 --> 00:12:49,350
normally filter problems just either

00:12:46,350 --> 00:12:53,179
reject all or accept all and this is you

00:12:49,350 --> 00:12:53,179
know how you say accept or reject on

00:12:53,929 --> 00:13:03,749
so and forget to mention their own on in

00:13:00,540 --> 00:13:06,379
in the round round rectangle on the

00:13:03,749 --> 00:13:10,049
right side you see a packet lands

00:13:06,379 --> 00:13:14,999
minimum packet lands you you need to be

00:13:10,049 --> 00:13:17,879
able to to load that half half water

00:13:14,999 --> 00:13:20,369
table set 12 you need 14 like it a

00:13:17,879 --> 00:13:21,929
packet of Florence 14 or more and if

00:13:20,369 --> 00:13:25,110
it's shorter then there is an implicit

00:13:21,929 --> 00:13:27,600
return 0 and there's always simplicity

00:13:25,110 --> 00:13:31,889
on 0 if your packet is to show this and

00:13:27,600 --> 00:13:37,160
I put 14 in the box that means you need

00:13:31,889 --> 00:13:37,160
the packet at least 13 bits bytes long

00:13:38,209 --> 00:13:45,480
so and now it's more a bit more

00:13:42,749 --> 00:13:48,149
complicated filter which corresponds to

00:13:45,480 --> 00:13:50,540
ICMP the same to note here is there are

00:13:48,149 --> 00:13:50,540
two loads

00:13:53,280 --> 00:14:00,790
this one is offset 14 and this one is a

00:13:57,160 --> 00:14:03,220
offset the first one at 12 the second

00:14:00,790 --> 00:14:06,780
one is the 23 worldwide that have said

00:14:03,220 --> 00:14:10,780
23 and this is a pattern actually see

00:14:06,780 --> 00:14:13,480
access to packet by its inclusion at

00:14:10,780 --> 00:14:15,640
Atkinson offsets and it's typical

00:14:13,480 --> 00:14:19,380
because when you go through a protocol

00:14:15,640 --> 00:14:21,550
layers they usually would just go in a

00:14:19,380 --> 00:14:25,660
protocol headers Gold increases at

00:14:21,550 --> 00:14:28,020
accretion offset just off to the case

00:14:25,660 --> 00:14:31,270
but not always about the case and

00:14:28,020 --> 00:14:32,800
actually can happen some for some

00:14:31,270 --> 00:14:34,330
optimizations and again you see this

00:14:32,800 --> 00:14:41,260
return 0 is John

00:14:34,330 --> 00:14:43,420
you shot marks on this slide yeah this

00:14:41,260 --> 00:14:46,380
one is again with two implicit each on 0

00:14:43,420 --> 00:14:46,380
no checks

00:14:47,640 --> 00:14:59,580
yeah I think it's even I'm sorry I don't

00:14:51,880 --> 00:14:59,580
know how to fix this certain are socio

00:15:04,110 --> 00:15:07,290
that is

00:15:08,470 --> 00:15:22,150
no I think it always anyway

00:15:17,610 --> 00:15:27,070
this might be like yeah I can do this

00:15:22,150 --> 00:15:31,290
but it's not so this this one is for

00:15:27,070 --> 00:15:37,810
particulates in p-type which is ICP deca

00:15:31,290 --> 00:15:40,570
requests and you know just again some

00:15:37,810 --> 00:15:42,310
clawed branch load branch of decreasing

00:15:40,570 --> 00:15:45,250
offset but not always an occasion of jet

00:15:42,310 --> 00:15:50,530
work sometimes because now I cannot even

00:15:45,250 --> 00:15:52,830
kill a high license anymore and this one

00:15:50,530 --> 00:15:52,830
has a

00:15:53,370 --> 00:16:02,350
this one introduces a new instruction

00:15:56,910 --> 00:16:05,290
loaded index table set with index by X

00:16:02,350 --> 00:16:07,780
and because there is no wraparound I

00:16:05,290 --> 00:16:10,660
know the package should be at least 5 15

00:16:07,780 --> 00:16:12,330
bytes just 15 bytes here and somewhere

00:16:10,660 --> 00:16:17,500
on top you see it's actually need some

00:16:12,330 --> 00:16:19,180
more than 15 24 well yeah the main thing

00:16:17,500 --> 00:16:21,160
is there are many fall backs to return 0

00:16:19,180 --> 00:16:22,840
both implicit and explicit these are

00:16:21,160 --> 00:16:24,520
explicit returns like basically check

00:16:22,840 --> 00:16:25,990
the field it's not it's not what you

00:16:24,520 --> 00:16:34,840
want just fall back to the return 0

00:16:25,990 --> 00:16:39,000
otherwise go go down the step until you

00:16:34,840 --> 00:16:39,000
had the region 0 origin accept or reject

00:16:43,230 --> 00:16:53,910
yeah and this this one again with 1 2 3

00:16:46,900 --> 00:16:56,560
4 5 implicit 5 digit returns and oops

00:16:53,910 --> 00:16:59,560
and this one actually has two checks one

00:16:56,560 --> 00:17:01,270
is because X plus 14 can also wrap

00:16:59,560 --> 00:17:03,220
around it it needs an additional check

00:17:01,270 --> 00:17:05,680
so there are actually two checks one is

00:17:03,220 --> 00:17:07,540
you know just X plus 14 and the second

00:17:05,680 --> 00:17:10,449
one is for the result of X plus 14

00:17:07,540 --> 00:17:13,530
student was one byte this this one

00:17:10,449 --> 00:17:13,530
student wrap around

00:17:13,600 --> 00:17:19,029
because you don't know the value of

00:17:15,500 --> 00:17:24,799
action advances and this actually that

00:17:19,029 --> 00:17:28,370
this this is the exception to the simple

00:17:24,799 --> 00:17:31,039
risk role of BPF it's a it's an

00:17:28,370 --> 00:17:36,289
instruction to quickly load IP header

00:17:31,039 --> 00:17:41,210
length or adjust in P tent with F X F +

00:17:36,289 --> 00:17:45,470
x for just bided offset 14 and do some

00:17:41,210 --> 00:17:48,440
just a couple of simple directions so

00:17:45,470 --> 00:17:53,210
enough enough about the filter programs

00:17:48,440 --> 00:17:55,220
I'm going to to talk more about the

00:17:53,210 --> 00:17:57,909
subject and what it is and how it works

00:17:55,220 --> 00:18:02,240
so basically SLG this necklace JIT

00:17:57,909 --> 00:18:04,490
compiler its Big D license and it

00:18:02,240 --> 00:18:12,440
support multiple architectures so into

00:18:04,490 --> 00:18:18,230
x86 1064 forever are 32 64 0 the oceans

00:18:12,440 --> 00:18:21,799
of arm PowerPC nips nips 64 sparks 82 it

00:18:18,230 --> 00:18:28,059
doesn't have support for sparks as 64

00:18:21,799 --> 00:18:30,320
did and someone did the teller Airport

00:18:28,059 --> 00:18:36,860
everything except my report is written

00:18:30,320 --> 00:18:47,179
by zoltán and I work with him on on some

00:18:36,860 --> 00:18:49,419
new stuff and done improvements is it

00:18:47,179 --> 00:18:49,419
okay

00:18:49,790 --> 00:18:54,290
so I'm going to talk about the new

00:18:52,280 --> 00:18:56,420
Walken previous version of still SOG

00:18:54,290 --> 00:18:58,280
Zoltan made a lot of changes and he

00:18:56,420 --> 00:19:00,850
renamed registers he renamed

00:18:58,280 --> 00:19:04,640
instructions it's just not here he's

00:19:00,850 --> 00:19:07,220
like thinkin about rethinking about the

00:19:04,640 --> 00:19:09,140
project and just making changes so the

00:19:07,220 --> 00:19:11,990
new yours will not be compatible but

00:19:09,140 --> 00:19:14,750
once he he implemented we at some point

00:19:11,990 --> 00:19:19,960
I will port import it into the Nabi g3

00:19:14,750 --> 00:19:24,860
and I will switch to it so it's

00:19:19,960 --> 00:19:26,660
stateless means it doesn't use the stack

00:19:24,860 --> 00:19:32,870
for temporaries but it emulates

00:19:26,660 --> 00:19:36,380
instructions so and it's a kind of it's

00:19:32,870 --> 00:19:38,810
like an assembler in some strange for

00:19:36,380 --> 00:19:41,450
some for some strange architecture but

00:19:38,810 --> 00:19:43,400
each as a simple instruction is actually

00:19:41,450 --> 00:19:46,780
API a function call so if you want to

00:19:43,400 --> 00:19:49,430
generate you know just if you want to

00:19:46,780 --> 00:19:52,850
add an instruction to your stream just

00:19:49,430 --> 00:19:55,670
you know my Micah call and it has ten

00:19:52,850 --> 00:19:59,560
registers and there are some how map to

00:19:55,670 --> 00:20:02,770
native registers but mappings are

00:19:59,560 --> 00:20:06,140
different on different architectures the

00:20:02,770 --> 00:20:09,820
up to nine in reality you have less than

00:20:06,140 --> 00:20:12,590
up to ten you have less than ten

00:20:09,820 --> 00:20:16,070
registers to us than ten scratchy and

00:20:12,590 --> 00:20:17,720
wasn't saved registers but in total they

00:20:16,070 --> 00:20:20,840
at least eight registers they share the

00:20:17,720 --> 00:20:24,830
same pool of real real Hardware

00:20:20,840 --> 00:20:26,600
registers and they approach from from

00:20:24,830 --> 00:20:33,440
from two different from the opposite

00:20:26,600 --> 00:20:35,810
ends and some of some of those registers

00:20:33,440 --> 00:20:37,520
are emulated which means they use dead

00:20:35,810 --> 00:20:41,870
but to emulate registers and I think

00:20:37,520 --> 00:20:47,570
it's only for x86 they don't have enough

00:20:41,870 --> 00:20:55,010
register other architectures have enough

00:20:47,570 --> 00:20:58,630
registers to to be able to take at least

00:20:55,010 --> 00:21:01,190
ten registers available from the pool

00:20:58,630 --> 00:21:03,860
yeah you can also you can you have

00:21:01,190 --> 00:21:08,590
access to the stack

00:21:03,860 --> 00:21:08,590
let's be real just this is a cheat

00:21:09,130 --> 00:21:20,450
constant is it just kind of a name of

00:21:18,080 --> 00:21:23,540
some some register and all registers are

00:21:20,450 --> 00:21:29,450
named associate underscore R zero so on

00:21:23,540 --> 00:21:33,710
and we can also vote omit an instruction

00:21:29,450 --> 00:21:35,600
to load as the stack pointer into a

00:21:33,710 --> 00:21:41,860
register few choice we can just say I

00:21:35,600 --> 00:21:41,860
won't step point in r2 like this

00:21:45,370 --> 00:21:54,410
internal implemented yeah yeah and when

00:21:53,060 --> 00:21:56,510
you generate a function you can say I

00:21:54,410 --> 00:21:58,580
want this number of bytes available in

00:21:56,510 --> 00:22:01,100
my stack and they will be available to

00:21:58,580 --> 00:22:09,050
you yeah and the stackless means for

00:22:01,100 --> 00:22:10,190
emulating for emulating instructions not

00:22:09,050 --> 00:22:11,600
register because when you write

00:22:10,190 --> 00:22:16,490
registers you know you have no choice

00:22:11,600 --> 00:22:18,650
but and and for example it quite often

00:22:16,490 --> 00:22:21,200
immolate registers for example in SOG

00:22:18,650 --> 00:22:24,470
you can you can you can have three

00:22:21,200 --> 00:22:26,720
apparent instructions where a

00:22:24,470 --> 00:22:29,120
destination register is different from

00:22:26,720 --> 00:22:31,810
two source registers and not all

00:22:29,120 --> 00:22:34,120
architectures support and not all

00:22:31,810 --> 00:22:36,800
instructions support three appearance

00:22:34,120 --> 00:22:38,920
and those will be emulated using

00:22:36,800 --> 00:22:42,050
additional you know morph instructions

00:22:38,920 --> 00:22:46,130
so also associate has labels and jumps

00:22:42,050 --> 00:22:48,800
and there are objects and they they will

00:22:46,130 --> 00:22:51,970
be available as soon as your is they

00:22:48,800 --> 00:22:56,120
come parent compiled object is available

00:22:51,970 --> 00:22:59,120
and also it's it's it's JIT just in time

00:22:56,120 --> 00:23:01,280
I think it means not only you can

00:22:59,120 --> 00:23:03,740
generate on the fly but also you can

00:23:01,280 --> 00:23:05,870
fetch your code on the fly so it has

00:23:03,740 --> 00:23:07,340
some support for changing constants

00:23:05,870 --> 00:23:10,430
after you generated you know after

00:23:07,340 --> 00:23:11,410
genetic origins if you use special flags

00:23:10,430 --> 00:23:14,200
to mark

00:23:11,410 --> 00:23:16,389
rewritable jumps and

00:23:14,200 --> 00:23:19,690
rewritable constants we can update them

00:23:16,389 --> 00:23:19,690
from the fly

00:23:21,100 --> 00:23:26,899
so yeah the main registers associate

00:23:23,629 --> 00:23:28,429
move this one yeah it can move data

00:23:26,899 --> 00:23:33,500
between registers between reach the

00:23:28,429 --> 00:23:36,169
memory yeah obviously have load store of

00:23:33,500 --> 00:23:39,919
different width but half it's called

00:23:36,169 --> 00:23:41,629
half it's not half covered because there

00:23:39,919 --> 00:23:46,370
is word is it can be 32-bit or 64-bit

00:23:41,629 --> 00:23:48,909
when just half means 16-bit and also

00:23:46,370 --> 00:23:52,210
32-bit integer which is contained and

00:23:48,909 --> 00:23:55,009
they it has the word

00:23:52,210 --> 00:23:58,419
wheels which is either 32-bit or 32-bit

00:23:55,009 --> 00:24:00,950
platforms or 64-bit on 64-bit platforms

00:23:58,419 --> 00:24:05,029
and has different addressing modes like

00:24:00,950 --> 00:24:06,950
you can load this means you can load the

00:24:05,029 --> 00:24:12,649
constant and actually this constant is

00:24:06,950 --> 00:24:14,990
not real compile constant it's like if

00:24:12,649 --> 00:24:18,470
ever some some function in your in your

00:24:14,990 --> 00:24:20,450
in your C code and you can pass it to

00:24:18,470 --> 00:24:21,769
while generating the code you can and it

00:24:20,450 --> 00:24:24,980
will be the constant because you know it

00:24:21,769 --> 00:24:26,929
doesn't change while the generated code

00:24:24,980 --> 00:24:29,720
is executing so it's constant for

00:24:26,929 --> 00:24:33,230
because you are doing it at runtime not

00:24:29,720 --> 00:24:36,200
at link time so you can also do register

00:24:33,230 --> 00:24:41,690
plus offset and you can do I register

00:24:36,200 --> 00:24:49,610
plus offset x two four and eight on

00:24:41,690 --> 00:24:49,789
64-bit platforms so and also you can do

00:24:49,610 --> 00:24:52,610
it

00:24:49,789 --> 00:24:53,899
32-bit mode and on 64-bit platforms and

00:24:52,610 --> 00:24:56,240
this one is a it's particularly

00:24:53,899 --> 00:24:59,870
important for VP of G because all the P

00:24:56,240 --> 00:25:03,320
of G stuff obvi PF stuff is 32-bit mod

00:24:59,870 --> 00:25:05,840
you know 32-bit arithmetic

00:25:03,320 --> 00:25:09,740
while on 64-bit platforms you know on

00:25:05,840 --> 00:25:12,049
Intel there there is a IX II IX so you

00:25:09,740 --> 00:25:14,450
can have you can work with 32-bit

00:25:12,049 --> 00:25:17,480
numbers and you need to use this flag

00:25:14,450 --> 00:25:20,659
mark your alterations business flat to

00:25:17,480 --> 00:25:23,090
make sure they will be as digital bit

00:25:20,659 --> 00:25:24,900
there will be politicians from switched

00:25:23,090 --> 00:25:27,640
a bit

00:25:24,900 --> 00:25:29,710
three appearance instructions I already

00:25:27,640 --> 00:25:32,260
explained what it is and they often

00:25:29,710 --> 00:25:34,200
immolated I thought it has double and

00:25:32,260 --> 00:25:36,790
single precision floating point I

00:25:34,200 --> 00:25:40,030
disabled it in the corner because we

00:25:36,790 --> 00:25:48,790
don't normally use fourteen points in

00:25:40,030 --> 00:25:50,470
the Chrome and and yeah there's some

00:25:48,790 --> 00:25:54,100
limitations and the biggest limitation

00:25:50,470 --> 00:25:56,580
is you can only call a function external

00:25:54,100 --> 00:25:59,410
functions up to three arguments if you

00:25:56,580 --> 00:26:03,400
and this this mutation comes from the

00:25:59,410 --> 00:26:05,800
fact that associate is it works on many

00:26:03,400 --> 00:26:08,170
platforms and like limitation of a

00:26:05,800 --> 00:26:10,570
single platform you know just eliminate

00:26:08,170 --> 00:26:14,590
all other architectures because you you

00:26:10,570 --> 00:26:17,830
basically write one code and it runs

00:26:14,590 --> 00:26:20,350
everywhere it's not quite correct you

00:26:17,830 --> 00:26:22,390
need to like you wrote code once tested

00:26:20,350 --> 00:26:24,520
twice and then run it everywhere because

00:26:22,390 --> 00:26:26,020
you need to attempt to test at least

00:26:24,520 --> 00:26:28,690
once a little bit platform and at least

00:26:26,020 --> 00:26:31,840
one 64-bit platform and you know just

00:26:28,690 --> 00:26:33,850
run right once to test twice and run

00:26:31,840 --> 00:26:36,820
everywhere so this how it worked for me

00:26:33,850 --> 00:26:38,260
and when I when I did the first version

00:26:36,820 --> 00:26:39,550
I was surprised there was a bug and I

00:26:38,260 --> 00:26:41,980
couldn't run it from the first try but

00:26:39,550 --> 00:26:45,610
when I fix the barking it worked and I

00:26:41,980 --> 00:26:48,690
you know got home switch from 32-bit to

00:26:45,610 --> 00:26:52,150
64-bit and yeah it was mostly working

00:26:48,690 --> 00:26:56,680
but I fixed one more to move bugs and

00:26:52,150 --> 00:26:59,350
you know what was done there's special

00:26:56,680 --> 00:27:02,800
mechanism for doing first cause but it's

00:26:59,350 --> 00:27:04,660
very specific to associate and I I don't

00:27:02,800 --> 00:27:09,790
I don't use it it and some other

00:27:04,660 --> 00:27:12,430
features I don't use them in BPF jet

00:27:09,790 --> 00:27:15,880
code generator so I'm going to give you

00:27:12,430 --> 00:27:19,150
some example I still okay to see this

00:27:15,880 --> 00:27:25,990
okay so this is fast 32-bit division and

00:27:19,150 --> 00:27:28,630
I this code comes from NetBSD so netbsd

00:27:25,990 --> 00:27:30,850
has this fast device that you to prepare

00:27:28,630 --> 00:27:32,610
and first divide but first divide has a

00:27:30,850 --> 00:27:33,790
bit different prototype i would claim

00:27:32,610 --> 00:27:38,160
shortly

00:27:33,790 --> 00:27:42,970
so basically replaces the division by

00:27:38,160 --> 00:27:44,650
multiplication to be division by 64-bit

00:27:42,970 --> 00:27:47,770
multiplication by magic number

00:27:44,650 --> 00:27:51,460
which is now a variable here and two

00:27:47,770 --> 00:27:57,220
shifts and the real fast dividing

00:27:51,460 --> 00:27:59,680
ability is similar to what what you see

00:27:57,220 --> 00:28:06,430
here but it also passes all these four

00:27:59,680 --> 00:28:08,320
arguments by values in here and i I pass

00:28:06,430 --> 00:28:09,760
only a single value just because I'm

00:28:08,320 --> 00:28:11,620
going to show you some assembler but

00:28:09,760 --> 00:28:14,230
you'll probably not see it with the

00:28:11,620 --> 00:28:16,450
screen is too small but it's you know if

00:28:14,230 --> 00:28:17,430
I pass them as if I pass this object as

00:28:16,450 --> 00:28:20,230
Bobo's

00:28:17,430 --> 00:28:25,140
it's it's more easy to compare so

00:28:20,230 --> 00:28:25,140
generated code with what GCC generates

00:28:25,980 --> 00:28:33,040
sorry this this one this one is

00:28:28,600 --> 00:28:34,990
important so and it's not C code

00:28:33,040 --> 00:28:38,080
it's it slow code I you know I wrote it

00:28:34,990 --> 00:28:42,030
by occupant to the talk and I think I

00:28:38,080 --> 00:28:42,030
should zoom it in a little bit

00:28:47,740 --> 00:28:56,440
so this lower kotas gets called from

00:28:50,889 --> 00:28:56,440
from this crazy

00:28:58,120 --> 00:29:13,009
so it's gets cold okay it gets cold from

00:29:10,700 --> 00:29:16,039
the hosts here so this this is embedded

00:29:13,009 --> 00:29:19,240
and you call it from the sea and from

00:29:16,039 --> 00:29:21,440
see you pass these three integers and

00:29:19,240 --> 00:29:28,039
they're accessible as did this special

00:29:21,440 --> 00:29:30,379
syntax for assigning arguments of you

00:29:28,039 --> 00:29:32,690
received two multiple values

00:29:30,379 --> 00:29:35,360
this represents all values passed to

00:29:32,690 --> 00:29:38,799
your function and this is a chunk of

00:29:35,360 --> 00:29:40,909
code and it's represented as a function

00:29:38,799 --> 00:29:47,000
display common in scripting language

00:29:40,909 --> 00:29:51,019
then I use I use you know I create a

00:29:47,000 --> 00:29:53,269
compiler and I use chaining so it this

00:29:51,019 --> 00:29:55,700
this syntax means a method I call a

00:29:53,269 --> 00:29:58,429
method of this object and I use changing

00:29:55,700 --> 00:30:00,769
so H each method returns the object

00:29:58,429 --> 00:30:04,490
itself and you know just more convenient

00:30:00,769 --> 00:30:07,370
to have to use changing so I first of

00:30:04,490 --> 00:30:10,009
all I am a function which accepts one

00:30:07,370 --> 00:30:12,049
argument and it uses one saved saves

00:30:10,009 --> 00:30:14,299
means a number of registers which are

00:30:12,049 --> 00:30:15,889
say like if if this function will this

00:30:14,299 --> 00:30:17,659
one will not do any function calls but

00:30:15,889 --> 00:30:20,210
if if a function does generate

00:30:17,659 --> 00:30:22,610
functional function called this saved

00:30:20,210 --> 00:30:24,070
registers will be saved after they will

00:30:22,610 --> 00:30:28,580
have the same value after the call is

00:30:24,070 --> 00:30:32,299
returns and and you need also need saved

00:30:28,580 --> 00:30:35,480
for argument so that always at least at

00:30:32,299 --> 00:30:38,809
least if there is one argument and there

00:30:35,480 --> 00:30:41,330
always at least one set register and you

00:30:38,809 --> 00:30:44,750
need one scratch register so one safety

00:30:41,330 --> 00:30:49,570
is ss0 this one one scratch is a zero

00:30:44,750 --> 00:30:56,740
and yes it makes yes

00:30:49,570 --> 00:30:56,740
maybe I can just do this and do it later

00:30:58,270 --> 00:31:04,070
so yeah it generates you know just

00:31:00,380 --> 00:31:06,170
function a function Prolog and then you

00:31:04,070 --> 00:31:08,120
want to yeah I forgot to say on the

00:31:06,170 --> 00:31:11,450
previous slide the pattern is you do

00:31:08,120 --> 00:31:15,050
binary operation followed by shift and

00:31:11,450 --> 00:31:17,780
do it three times first one is 64 bit

00:31:15,050 --> 00:31:20,060
more they just use small I I want to you

00:31:17,780 --> 00:31:23,420
know just generate mal multiplication

00:31:20,060 --> 00:31:25,760
the destination will be a zero square

00:31:23,420 --> 00:31:27,680
just and I want to multiply a zero and

00:31:25,760 --> 00:31:32,000
immediate value mod which comes from the

00:31:27,680 --> 00:31:34,360
horsey program and this one is often

00:31:32,000 --> 00:31:36,680
immolated because it's three apparent

00:31:34,360 --> 00:31:40,100
instruction and then you just shift your

00:31:36,680 --> 00:31:42,560
shift by 32 immediate value and the

00:31:40,100 --> 00:31:44,810
result goes to the same register 0 and

00:31:42,560 --> 00:31:49,580
this instructs they're similar but then

00:31:44,810 --> 00:31:52,670
when the many differences the I which

00:31:49,580 --> 00:31:55,700
which means a 32-bit mode so the rest

00:31:52,670 --> 00:32:02,960
will work in 32-bit mode because you

00:31:55,700 --> 00:32:09,680
know we want to such a bit logic and the

00:32:02,960 --> 00:32:11,630
last one shift the last one means I am

00:32:09,680 --> 00:32:13,490
returning from this function so this

00:32:11,630 --> 00:32:21,410
generates an instruction to return from

00:32:13,490 --> 00:32:24,860
from this function and move move move

00:32:21,410 --> 00:32:27,470
the content of register r0 to the return

00:32:24,860 --> 00:32:31,010
register well r0 is always the rich on

00:32:27,470 --> 00:32:34,190
register no no Sajit support

00:32:31,010 --> 00:32:36,620
architectures and this mean move 32-bit

00:32:34,190 --> 00:32:38,030
integer unsigned 32-bit integer it

00:32:36,620 --> 00:32:40,160
probably doesn't doesn't matter he

00:32:38,030 --> 00:32:43,640
because when we do initial shift by 32

00:32:40,160 --> 00:32:45,950
was 64 it you know just zeroed out hi hi

00:32:43,640 --> 00:32:49,280
hi were just just to demonstrate we can

00:32:45,950 --> 00:32:51,830
do this if you want to return mask out

00:32:49,280 --> 00:32:56,720
the high bit sandwich on 32-bit or

00:32:51,830 --> 00:32:58,070
64-bit platforms so that's that's you

00:32:56,720 --> 00:32:58,660
know that's how much code you need to

00:32:58,070 --> 00:33:01,760
generate

00:32:58,660 --> 00:33:03,030
first division and this corresponds to

00:33:01,760 --> 00:33:06,270
real DP FD

00:33:03,030 --> 00:33:09,630
instruction it's not done in in my code

00:33:06,270 --> 00:33:11,340
yet because in C it's it no it's quite

00:33:09,630 --> 00:33:14,850
bigger than this one I'll show you in a

00:33:11,340 --> 00:33:16,320
second and it's the division is not it's

00:33:14,850 --> 00:33:18,470
not very common instruction in peer

00:33:16,320 --> 00:33:26,270
programs because it's long everyone

00:33:18,470 --> 00:33:26,270
watch it and don't do first

00:33:32,820 --> 00:33:41,610
and this is how I respond Jian XI code

00:33:36,780 --> 00:33:44,250
looks like and it's it's not all it's

00:33:41,610 --> 00:33:46,860
not all instructions from from from the

00:33:44,250 --> 00:33:54,450
website just just the about three I

00:33:46,860 --> 00:33:58,260
think so if you the first one is you

00:33:54,450 --> 00:34:02,670
create the compiled object in NC you

00:33:58,260 --> 00:34:05,460
have a error checking and the word just

00:34:02,670 --> 00:34:06,960
throws you and assuming you you run your

00:34:05,460 --> 00:34:10,830
lower court and protected inside the

00:34:06,960 --> 00:34:13,080
protected call the C should shoot catch

00:34:10,830 --> 00:34:14,929
an error and reported some hard work in

00:34:13,080 --> 00:34:17,940
this case in the student report any are

00:34:14,929 --> 00:34:30,200
you have full control of this code from

00:34:17,940 --> 00:34:30,200
C and then the next one okay

00:34:33,470 --> 00:34:39,090
just not the same that they all my

00:34:36,780 --> 00:34:40,830
functions correspond one-to-one to

00:34:39,090 --> 00:34:44,070
associate but they don't have associate

00:34:40,830 --> 00:34:46,109
underscore prefix and this is

00:34:44,070 --> 00:34:47,790
essentially the same except that you can

00:34:46,109 --> 00:34:50,550
do you can part the same arguments here

00:34:47,790 --> 00:34:53,040
and this is like named arguments and

00:34:50,550 --> 00:34:54,629
thrust 1 first 0 is options it's always

00:34:53,040 --> 00:34:57,119
0 right you know it's not present here

00:34:54,629 --> 00:34:59,070
this 3 corresponds to this and this they

00:34:57,119 --> 00:35:03,750
are the same but for floating point

00:34:59,070 --> 00:35:06,359
numbers I used a 14 point for 14 points

00:35:03,750 --> 00:35:09,450
registers I don't use 20 registers and

00:35:06,359 --> 00:35:10,980
also you know I checked the error but in

00:35:09,450 --> 00:35:16,109
associate you don't have to check any

00:35:10,980 --> 00:35:18,840
ruffridge after each function you can do

00:35:16,109 --> 00:35:20,820
it once in a while and because you know

00:35:18,840 --> 00:35:23,000
it will remember your last error but

00:35:20,820 --> 00:35:28,349
it's good to detect

00:35:23,000 --> 00:35:32,160
earlier but it contributes to the code

00:35:28,349 --> 00:35:35,760
size quite a bit and it becomes it's

00:35:32,160 --> 00:35:42,810
important becomes unreadable just you

00:35:35,760 --> 00:35:45,420
know just this this much here here and

00:35:42,810 --> 00:35:47,940
also you this this is for 64-bit

00:35:45,420 --> 00:35:49,980
platforms because this is used using the

00:35:47,940 --> 00:35:51,060
same wheels multiplication or 32-bit

00:35:49,980 --> 00:35:52,770
platforms you need double this

00:35:51,060 --> 00:35:57,180
multiplication because you need 64-bit

00:35:52,770 --> 00:35:59,339
multiplication here no 32 bit will have

00:35:57,180 --> 00:36:02,099
a different code and you need some if

00:35:59,339 --> 00:36:04,140
here if else right and similarly here

00:36:02,099 --> 00:36:07,740
and also there are some special cases

00:36:04,140 --> 00:36:13,080
like yours one of the shift is 0 or like

00:36:07,740 --> 00:36:15,390
your you divide by a power of 2 and you

00:36:13,080 --> 00:36:17,550
know this at some point it becomes you

00:36:15,390 --> 00:36:21,270
know just just quite quite difficult to

00:36:17,550 --> 00:36:22,830
track like to understand what's where

00:36:21,270 --> 00:36:26,910
are you in the court and you know what's

00:36:22,830 --> 00:36:30,660
what's going on and it's a bit easier if

00:36:26,910 --> 00:36:32,900
you do war so you're not next slide I

00:36:30,660 --> 00:36:32,900
think

00:36:36,100 --> 00:36:44,110
so I will zoom in each code and I'm

00:36:40,610 --> 00:36:44,110
going to compare the Soviet with GCC

00:36:49,720 --> 00:36:58,340
it's long so this is just the lower code

00:36:55,910 --> 00:37:00,110
that corresponds to just to finish the

00:36:58,340 --> 00:37:01,700
law implementation so first we push

00:37:00,110 --> 00:37:05,930
through a program to the stack to the

00:37:01,700 --> 00:37:07,670
lower stack it's it's it's in glowing of

00:37:05,930 --> 00:37:10,580
code plus you know two lines for Eric

00:37:07,670 --> 00:37:13,820
chicken but it's basically what you know

00:37:10,580 --> 00:37:16,910
just loads that lower court to the lower

00:37:13,820 --> 00:37:19,990
stack and it it will be represented as a

00:37:16,910 --> 00:37:23,330
function and then pushes three three

00:37:19,990 --> 00:37:26,270
integers and then it calls that the

00:37:23,330 --> 00:37:27,820
function you know that chunk of code you

00:37:26,270 --> 00:37:30,770
push to the function with three

00:37:27,820 --> 00:37:33,170
arguments and it returns to one argument

00:37:30,770 --> 00:37:36,890
which is the subject compiled object and

00:37:33,170 --> 00:37:41,360
then you just I'm using my low associate

00:37:36,890 --> 00:37:42,140
library and you just and get the pointer

00:37:41,360 --> 00:37:43,760
to that object

00:37:42,140 --> 00:37:45,710
from the top of the stack minus one

00:37:43,760 --> 00:37:50,840
means get me an object from the top of

00:37:45,710 --> 00:37:52,760
the stack and every every all objects

00:37:50,840 --> 00:37:54,350
created inside the lower are managed by

00:37:52,760 --> 00:37:56,840
a garbage collector so if you create

00:37:54,350 --> 00:38:01,100
multiple objects like jumps labels they

00:37:56,840 --> 00:38:05,720
will all be managed and if you can use

00:38:01,100 --> 00:38:07,220
the compiler when if if you if you make

00:38:05,720 --> 00:38:09,050
sure it's it's some way and the lowest

00:38:07,220 --> 00:38:11,410
tech so it's available to low it's not

00:38:09,050 --> 00:38:14,030
that then you can use the compiler and

00:38:11,410 --> 00:38:15,560
then you can generate code and when you

00:38:14,030 --> 00:38:17,540
generate code you detach your compiled

00:38:15,560 --> 00:38:19,280
object from the generated code you can

00:38:17,540 --> 00:38:20,660
you know just destroy the compiled

00:38:19,280 --> 00:38:22,130
object and because it's managed by the

00:38:20,660 --> 00:38:26,240
law you can just close the lower state

00:38:22,130 --> 00:38:29,210
and if you you know it will allocate

00:38:26,240 --> 00:38:31,820
memory for all for all objects default

00:38:29,210 --> 00:38:35,000
dependent objects so you know just it's

00:38:31,820 --> 00:38:38,330
it's a bit easier to manage once you

00:38:35,000 --> 00:38:43,880
have once you have the bindings once we

00:38:38,330 --> 00:38:46,400
have the library for for managing your

00:38:43,880 --> 00:38:48,560
associate bindings to

00:38:46,400 --> 00:38:51,500
everything happens just manages

00:38:48,560 --> 00:38:54,080
automatically by law and then you need

00:38:51,500 --> 00:38:56,240
to flee the court some some point later

00:38:54,080 --> 00:38:57,980
but I'm going to show in the on the

00:38:56,240 --> 00:39:00,380
assembly slide I will show you the the

00:38:57,980 --> 00:39:04,750
content of this function which is

00:39:00,380 --> 00:39:04,750
generated on the fly of course Rajat

00:39:09,940 --> 00:39:16,880
next one is this you you've already seen

00:39:13,550 --> 00:39:18,950
this but the pattern is binary operation

00:39:16,880 --> 00:39:21,530
followed by shift two more times and

00:39:18,950 --> 00:39:24,200
that's actually I think multiplication

00:39:21,530 --> 00:39:26,080
by a residual scaled residual with the

00:39:24,200 --> 00:39:29,900
correction step that's what it is

00:39:26,080 --> 00:39:32,870
and so this is one particular

00:39:29,900 --> 00:39:35,300
implementation and on the right side you

00:39:32,870 --> 00:39:38,030
see very simple code for the compiler

00:39:35,300 --> 00:39:39,740
and it's the compiler is not limited to

00:39:38,030 --> 00:39:41,450
this particular implementation in the

00:39:39,740 --> 00:39:44,050
middle you can do you know other other

00:39:41,450 --> 00:39:47,570
can apply try other alternatives and

00:39:44,050 --> 00:39:50,630
it's indeed much much shorter so this

00:39:47,570 --> 00:39:52,220
one is compiler generated code it

00:39:50,630 --> 00:39:53,870
doesn't use you know this loader is

00:39:52,220 --> 00:40:07,220
because it uses a single shift and

00:39:53,870 --> 00:40:09,410
different magic magic number real

00:40:07,220 --> 00:40:11,660
difference here this is a subject code

00:40:09,410 --> 00:40:14,600
and it's a bit bigger because the push

00:40:11,660 --> 00:40:19,910
and you know just what can be stack

00:40:14,600 --> 00:40:22,550
pointer not-not-not SLG to that point I

00:40:19,910 --> 00:40:25,060
just you know this is machine stack

00:40:22,550 --> 00:40:27,920
pointer and I think this one is Morgan

00:40:25,060 --> 00:40:31,160
our safe register somewhere because you

00:40:27,920 --> 00:40:36,650
know it's to save it and this also has

00:40:31,160 --> 00:40:38,990
some overhead yeah yeah and this move

00:40:36,650 --> 00:40:41,900
actually comes from remember which one

00:40:38,990 --> 00:40:44,660
32-bit did a special move underscore u

00:40:41,900 --> 00:40:46,580
UI which a 32-bit mean I think you can

00:40:44,660 --> 00:40:49,490
get rid of this by just not omitting

00:40:46,580 --> 00:40:51,770
that that instruction and other words

00:40:49,490 --> 00:40:54,000
it's similar

00:40:51,770 --> 00:40:55,680
just a bit shorter here because you

00:40:54,000 --> 00:40:57,900
don't have to load the constant from the

00:40:55,680 --> 00:41:00,420
global memory you know like you are

00:40:57,900 --> 00:41:04,650
shifting by 1 and here shifting by 4 you

00:41:00,420 --> 00:41:06,900
just use the immediate constants for

00:41:04,650 --> 00:41:09,270
multiplication you know it's three

00:41:06,900 --> 00:41:12,150
instructions to load your constant you

00:41:09,270 --> 00:41:14,910
move because it's three IP round fusion

00:41:12,150 --> 00:41:18,540
you move safe register somewhere and

00:41:14,910 --> 00:41:20,010
just do unsigned multiplication here so

00:41:18,540 --> 00:41:23,820
that's you know how it looks like and

00:41:20,010 --> 00:41:25,109
you know it's just right once oh yeah in

00:41:23,820 --> 00:41:31,520
some cases into two different

00:41:25,109 --> 00:41:31,520
implementations but it works everywhere

00:41:31,760 --> 00:41:39,599
usually it works everywhere so yeah

00:41:34,830 --> 00:41:44,400
running a bit of time but because you

00:41:39,599 --> 00:41:49,250
know just and by the way I yeah all all

00:41:44,400 --> 00:41:52,200
graphs were drawn using Lua and graph is

00:41:49,250 --> 00:41:55,290
that's why I have so many so many graphs

00:41:52,200 --> 00:42:07,710
because it's so easy to to draw and I

00:41:55,290 --> 00:42:11,970
did this all this just into evening so

00:42:07,710 --> 00:42:14,640
yeah VP of optimizations I it's it's

00:42:11,970 --> 00:42:17,240
it's run in the kernel and I you know

00:42:14,640 --> 00:42:23,130
it's you need to be more paranoid about

00:42:17,240 --> 00:42:26,130
doing optimizations in the kernel and so

00:42:23,130 --> 00:42:27,930
what I do I assume that BPF program

00:42:26,130 --> 00:42:30,180
coming from the user space is actually

00:42:27,930 --> 00:42:32,010
is already optimized like for example if

00:42:30,180 --> 00:42:34,170
it's it's coming from lipika pliability

00:42:32,010 --> 00:42:37,770
and it's already optimized and for

00:42:34,170 --> 00:42:39,540
example if i like if i look at some

00:42:37,770 --> 00:42:42,180
particular program and i see it's moving

00:42:39,540 --> 00:42:44,160
value between a and X register ten times

00:42:42,180 --> 00:42:45,839
and you see and a and adjust the single

00:42:44,160 --> 00:42:48,359
move so I don't do it because this can

00:42:45,839 --> 00:42:50,040
be done in the user space so you just

00:42:48,359 --> 00:42:54,150
don't do it I don't don't move stuff

00:42:50,040 --> 00:42:58,349
unnecessarily yeah and I I have some

00:42:54,150 --> 00:43:02,460
exceptions but they come when like when

00:42:58,349 --> 00:43:04,420
I I need when I need something and like

00:43:02,460 --> 00:43:06,309
they come from for free

00:43:04,420 --> 00:43:07,569
all mostly free then I add those

00:43:06,309 --> 00:43:09,490
optimizations and unreachable

00:43:07,569 --> 00:43:11,200
instructions is a natural step when you

00:43:09,490 --> 00:43:13,240
do it like initial for analysis it's an

00:43:11,200 --> 00:43:15,609
you know a natural step to see where the

00:43:13,240 --> 00:43:16,809
stitch instructions issue or not but in

00:43:15,609 --> 00:43:18,819
a normal problem you do sandwich

00:43:16,809 --> 00:43:23,440
construction say they should be

00:43:18,819 --> 00:43:25,869
optimized and also a and X might be used

00:43:23,440 --> 00:43:29,589
an uninitialized and in the in those

00:43:25,869 --> 00:43:31,329
cases I said them to zero but actually

00:43:29,589 --> 00:43:33,400
if you don't initialize them explicitly

00:43:31,329 --> 00:43:36,819
in your filter program that Corona will

00:43:33,400 --> 00:43:40,720
not accept them because there's no file

00:43:36,819 --> 00:43:42,519
validation step but yeah just they don't

00:43:40,720 --> 00:43:46,210
have to do it but I still do it as a say

00:43:42,519 --> 00:43:47,859
fitting that and because I'm not I'm not

00:43:46,210 --> 00:43:51,670
limited to not busy but be carefully

00:43:47,859 --> 00:43:52,660
that does this yeah and I do fixed

00:43:51,670 --> 00:43:56,740
number of passes through the filter

00:43:52,660 --> 00:43:58,599
program to prevent any you know just if

00:43:56,740 --> 00:44:01,440
infinite iterations trying to find an

00:43:58,599 --> 00:44:07,569
optimal solution I just fixed number of

00:44:01,440 --> 00:44:09,430
passes and that's it so yeah I implement

00:44:07,569 --> 00:44:11,619
trivial hints and I think everyone knows

00:44:09,430 --> 00:44:13,390
implement evil heels like if X is not

00:44:11,619 --> 00:44:14,619
available is not used anywhere in your

00:44:13,390 --> 00:44:16,569
program then don't use it and you will

00:44:14,619 --> 00:44:20,650
save some instructions in provoke

00:44:16,569 --> 00:44:22,960
epilogue of of a generator function yeah

00:44:20,650 --> 00:44:28,509
find use before you need again it's not

00:44:22,960 --> 00:44:30,430
it's not they will not pop if you use if

00:44:28,509 --> 00:44:31,779
you need if you used before we need them

00:44:30,430 --> 00:44:34,220
they those programs will not pass

00:44:31,779 --> 00:44:37,370
validation but I still do it

00:44:34,220 --> 00:44:37,370
[Music]

00:44:37,680 --> 00:44:41,759
yeah and I have a rebound the main

00:44:40,059 --> 00:44:44,349
optimization is there a bounced check

00:44:41,759 --> 00:44:47,079
elimination and I do it in two passes I

00:44:44,349 --> 00:44:51,730
don't have time to explain it in details

00:44:47,079 --> 00:44:54,759
but I'll show you the results so it

00:44:51,730 --> 00:45:00,519
applies to packet reads and because

00:44:54,759 --> 00:45:02,400
filter programs often read by tonality

00:45:00,519 --> 00:45:05,109
position offsets you you can save some

00:45:02,400 --> 00:45:10,089
optimize away some checks by you know

00:45:05,109 --> 00:45:13,569
just checking the like if it's going to

00:45:10,089 --> 00:45:15,670
read no packet at offset that 24 goodbye

00:45:13,569 --> 00:45:16,210
to that works out of CA 23 anyway then

00:45:15,670 --> 00:45:20,530
you can

00:45:16,210 --> 00:45:32,829
just check it at the beginning and again

00:45:20,530 --> 00:45:37,030
this one is not so yeah basically it

00:45:32,829 --> 00:45:39,280
needs 14 like a 13 bars and this one is

00:45:37,030 --> 00:45:41,380
24 and I can just move it to the check

00:45:39,280 --> 00:45:44,140
here and don't check no don't do this

00:45:41,380 --> 00:45:50,470
check at all and actually though this is

00:45:44,140 --> 00:45:53,710
needs 14 bytes 24 22 15 15 and some

00:45:50,470 --> 00:45:55,450
unknown upset but basically it's you

00:45:53,710 --> 00:46:00,250
know just akin to the single check here

00:45:55,450 --> 00:46:01,660
24 24 it is a 24 or more than go there

00:46:00,250 --> 00:46:04,240
otherwise it's too short go just

00:46:01,660 --> 00:46:05,470
straight to each one 0 and you just have

00:46:04,240 --> 00:46:07,750
some additional check here and I think

00:46:05,470 --> 00:46:09,970
that's the the two checks you have like

00:46:07,750 --> 00:46:14,250
one check here and only one instead of

00:46:09,970 --> 00:46:14,250
two checks here and no checks for this

00:46:14,309 --> 00:46:20,079
so you illuminate it actually four

00:46:17,020 --> 00:46:22,210
checks one here and three of those and

00:46:20,079 --> 00:46:25,980
that's just what my optimization does

00:46:22,210 --> 00:46:28,359
can i implement it in law that's why you

00:46:25,980 --> 00:46:30,940
so I don't have time to explain you

00:46:28,359 --> 00:46:38,640
about execution trees and how my

00:46:30,940 --> 00:46:38,640
algorithm works but basically yeah is

00:46:39,000 --> 00:46:49,059
actually this when you look at this they

00:46:46,839 --> 00:46:52,329
always fall back to reach 1 0 H 1 0 and

00:46:49,059 --> 00:46:56,109
there are no no reads at all in this

00:46:52,329 --> 00:46:57,700
branch and does that mean you you need

00:46:56,109 --> 00:47:00,640
to disable the optimization like because

00:46:57,700 --> 00:47:07,030
in one part it's 24 but in the other

00:47:00,640 --> 00:47:12,400
pass it's just 0 but because because

00:47:07,030 --> 00:47:14,290
laws at high offsets are not returned 0

00:47:12,400 --> 00:47:16,210
anyway and there are no side effects and

00:47:14,290 --> 00:47:20,400
vpr programs you can just assume that

00:47:16,210 --> 00:47:23,559
instead of H 1 0 we can say load loads

00:47:20,400 --> 00:47:26,319
packet by the in this case is about the

00:47:23,559 --> 00:47:29,590
world at an infinitive yet it's in

00:47:26,319 --> 00:47:32,260
reality it's here in 32 MUX plus 4

00:47:29,590 --> 00:47:34,420
it's not high enough and higher than any

00:47:32,260 --> 00:47:35,860
real offset because you know the slot is

00:47:34,420 --> 00:47:38,620
in distinguished what will return zero

00:47:35,860 --> 00:47:40,450
anyway and yeah it was previously on

00:47:38,620 --> 00:47:42,760
zero now it's just loaded this

00:47:40,450 --> 00:47:44,820
ridiculous offset because they both sit

00:47:42,760 --> 00:47:50,520
on zero and there are no side effects

00:47:44,820 --> 00:47:55,000
and yeah that's what you have in the end

00:47:50,520 --> 00:47:56,650
just just check here and one check here

00:47:55,000 --> 00:48:02,830
instead of two and all those are

00:47:56,650 --> 00:48:04,540
optimized way and if you if you change

00:48:02,830 --> 00:48:06,670
this to return zero here instead of

00:48:04,540 --> 00:48:07,810
short marks the whole program would

00:48:06,670 --> 00:48:10,840
collapse but I don't do this

00:48:07,810 --> 00:48:14,800
optimization and like if this was a part

00:48:10,840 --> 00:48:16,360
of a bigger a program then I could apply

00:48:14,800 --> 00:48:18,460
some optimizations to the other part

00:48:16,360 --> 00:48:19,780
because like if if this program use it

00:48:18,460 --> 00:48:21,550
like this pregnant you just some stuff

00:48:19,780 --> 00:48:24,070
but this one doesn't I can just you know

00:48:21,550 --> 00:48:26,110
just take advantage of it but this is

00:48:24,070 --> 00:48:29,350
not you know this didn't see it in real

00:48:26,110 --> 00:48:32,680
programs that you know if you just the

00:48:29,350 --> 00:48:37,240
they they like they are not unreachable

00:48:32,680 --> 00:48:40,300
code in in real DPF programs which you

00:48:37,240 --> 00:48:42,510
see from user space and yeah i think i

00:48:40,300 --> 00:48:47,980
don't have time for future musicians but

00:48:42,510 --> 00:48:50,200
and for him buff stuff and for testing

00:48:47,980 --> 00:48:52,600
yeah I used a user on for testing that's

00:48:50,200 --> 00:48:54,940
very modular and just like every time I

00:48:52,600 --> 00:48:57,610
the feature just run it through the test

00:48:54,940 --> 00:48:59,440
and test is both user space and kernel

00:48:57,610 --> 00:49:03,850
and there are some differences in the

00:48:59,440 --> 00:49:05,800
kernel because they the above and above

00:49:03,850 --> 00:49:10,740
chains and they're a bit different to

00:49:05,800 --> 00:49:10,740
work with so yeah

00:49:12,320 --> 00:49:16,750
thank you any questions

00:49:23,490 --> 00:49:26,490
yeah

00:49:30,200 --> 00:49:34,349
how easy is it to add new architecture

00:49:33,150 --> 00:49:38,039
support service

00:49:34,349 --> 00:49:42,539
well I yeah tell era was done by by one

00:49:38,039 --> 00:49:46,230
person I think it should be quite

00:49:42,539 --> 00:49:48,539
straightforward and it will take some

00:49:46,230 --> 00:49:52,349
time and you need someone who is skilled

00:49:48,539 --> 00:49:54,450
to you know to do to know enough about

00:49:52,349 --> 00:49:57,329
the architects well yeah I think you can

00:49:54,450 --> 00:49:59,880
just read the instruction format and ABI

00:49:57,329 --> 00:50:03,059
specs and do it even if you don't have

00:49:59,880 --> 00:50:05,099
enough skills but just to answer yeah I

00:50:03,059 --> 00:50:07,380
actually looked at adding sparc64

00:50:05,099 --> 00:50:13,500
support and it's like five hundred of

00:50:07,380 --> 00:50:15,000
code yeah and the autumn doesn't ask him

00:50:13,500 --> 00:50:17,250
he doesn't have time and he doesn't have

00:50:15,000 --> 00:50:18,960
hardware but I told him it wouldn't be

00:50:17,250 --> 00:50:20,430
problem you know if you feel if you want

00:50:18,960 --> 00:50:23,130
to work on a spark sixty four we can

00:50:20,430 --> 00:50:26,390
deny to hardware I definitely have for

00:50:23,130 --> 00:50:26,390
my to do this but it's not

00:50:33,610 --> 00:50:36,760

YouTube URL: https://www.youtube.com/watch?v=YgUY_wPLpKw


