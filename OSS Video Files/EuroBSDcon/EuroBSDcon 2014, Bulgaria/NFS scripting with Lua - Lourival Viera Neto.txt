Title: NFS scripting with Lua - Lourival Viera Neto
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	NFS scripting with Lua - Lourival Viera Neto
Captions: 
	00:00:08,210 --> 00:00:14,660
hello my name is olive all a month at

00:00:12,260 --> 00:00:17,870
BSD developer

00:00:14,660 --> 00:00:22,670
where I worked mainly on providing ways

00:00:17,870 --> 00:00:26,420
to script the it the netbsd colonel with

00:00:22,670 --> 00:00:30,680
Lua today I'll present a special use

00:00:26,420 --> 00:00:37,970
case on scripting the nut bsd packet

00:00:30,680 --> 00:00:44,360
filter the npf i'd like to start with

00:00:37,970 --> 00:00:48,260
that thought that sports that we can

00:00:44,360 --> 00:00:54,470
split complex programs written see in a

00:00:48,260 --> 00:00:59,950
core part a configuration part using a

00:00:54,470 --> 00:01:08,210
scripting language that's the the idea

00:00:59,950 --> 00:01:13,100
we want to use here I'll first introduce

00:01:08,210 --> 00:01:18,799
the concept of script of operating

00:01:13,100 --> 00:01:24,789
system and the use case on scripting and

00:01:18,799 --> 00:01:30,229
packet filter next I usual an example

00:01:24,789 --> 00:01:34,159
inspecting the ssh version then i you

00:01:30,229 --> 00:01:39,530
present some issues on scripting

00:01:34,159 --> 00:01:43,240
operating system motivate why choose Lua

00:01:39,530 --> 00:01:48,889
as the scripting language for the kernel

00:01:43,240 --> 00:01:54,079
then I will show our kernel scripting

00:01:48,889 --> 00:01:58,340
environment in at BST then I'll present

00:01:54,079 --> 00:02:05,229
Lua data library for binding the system

00:01:58,340 --> 00:02:10,840
memory to the Lua script general present

00:02:05,229 --> 00:02:15,500
the entire fluid the bind between the

00:02:10,840 --> 00:02:19,209
Lua interpreter and NP F and finally

00:02:15,500 --> 00:02:19,209
I'll show all conclusions

00:02:20,170 --> 00:02:27,850
so where is a scriptable operating

00:02:24,110 --> 00:02:32,140
system a script of operating system

00:02:27,850 --> 00:02:35,140
the combination of extensible operating

00:02:32,140 --> 00:02:38,740
system with scripting language is the

00:02:35,140 --> 00:02:43,680
application of a scripting language to

00:02:38,740 --> 00:02:47,970
write extensions in our operating system

00:02:43,680 --> 00:02:52,450
the motivation to have operation system

00:02:47,970 --> 00:02:54,930
is scriptable is to give more

00:02:52,450 --> 00:02:59,580
flexibility to the operating system

00:02:54,930 --> 00:03:07,270
helping users to meet new requirements

00:02:59,580 --> 00:03:11,140
to configure the kernel subsistence also

00:03:07,270 --> 00:03:17,290
to allow non kernel developers to change

00:03:11,140 --> 00:03:21,610
the behavior of the kernel and also we

00:03:17,290 --> 00:03:27,990
can prototype new features using a

00:03:21,610 --> 00:03:32,500
scripting language we could have the

00:03:27,990 --> 00:03:37,030
operating system scriptable both in its

00:03:32,500 --> 00:03:40,750
user space and its kernel but the key

00:03:37,030 --> 00:03:43,930
idea here is to script the operating

00:03:40,750 --> 00:03:47,530
system kernel which I call kernel

00:03:43,930 --> 00:03:53,140
scripting it is the halfway between

00:03:47,530 --> 00:03:56,650
using just kernel parameters and actual

00:03:53,140 --> 00:04:00,340
kernel modules and there have also the

00:03:56,650 --> 00:04:05,580
half way between using domain specific

00:04:00,340 --> 00:04:05,580
language and system programming language

00:04:05,790 --> 00:04:15,430
there are two ways to provide the script

00:04:10,900 --> 00:04:19,270
to scripting to kernel we can extending

00:04:15,430 --> 00:04:23,170
our script scripting language in that

00:04:19,270 --> 00:04:27,580
way the scripts will treat the kernel as

00:04:23,170 --> 00:04:31,170
a library they will invoke the operating

00:04:27,580 --> 00:04:35,380
system kernel and can embed the

00:04:31,170 --> 00:04:37,870
scripting language in that way the

00:04:35,380 --> 00:04:40,940
scripts will treat the kernel as a

00:04:37,870 --> 00:04:48,410
framework the kernel will invoke

00:04:40,940 --> 00:04:52,490
the scripts to perform the extension we

00:04:48,410 --> 00:04:56,870
have some use case for scripting the

00:04:52,490 --> 00:05:02,870
kernel by embedding we could have a

00:04:56,870 --> 00:05:07,780
packet future dawning in using scripts

00:05:02,870 --> 00:05:11,750
is the main purpose of this presentation

00:05:07,780 --> 00:05:14,390
but we could also have device drivers

00:05:11,750 --> 00:05:17,990
implemented or partially implemented

00:05:14,390 --> 00:05:23,890
using scripting language we could have

00:05:17,990 --> 00:05:28,880
process schedulers invoking schedule the

00:05:23,890 --> 00:05:35,390
routines to decide which process should

00:05:28,880 --> 00:05:39,550
run by extending we could have protocols

00:05:35,390 --> 00:05:42,290
implemented in the kernel using a

00:05:39,550 --> 00:05:51,500
scripting language for example could

00:05:42,290 --> 00:05:57,440
have HTTP server using Lua the

00:05:51,500 --> 00:06:02,240
motivation to have a package filter is

00:05:57,440 --> 00:06:05,510
scriptable is too deep inspection on

00:06:02,240 --> 00:06:09,410
their packets the network packets we

00:06:05,510 --> 00:06:11,630
could have could provides it trafficking

00:06:09,410 --> 00:06:16,220
shape or intrusion detection and

00:06:11,630 --> 00:06:18,530
prevention and we could also have new

00:06:16,220 --> 00:06:24,190
features implemented in the packet

00:06:18,530 --> 00:06:24,190
filter like per Larkin or new protocols

00:06:28,450 --> 00:06:42,110
suppose we have a ssh server with have

00:06:36,610 --> 00:06:50,150
with wit has a vulnerable winnable

00:06:42,110 --> 00:06:55,520
version we can use Lua script to inspect

00:06:50,150 --> 00:06:58,700
the application layer to identify which

00:06:55,520 --> 00:07:03,290
version is running on this server before

00:06:58,700 --> 00:07:08,650
it communicates the it's version to the

00:07:03,290 --> 00:07:15,230
client and then drop the the

00:07:08,650 --> 00:07:24,640
communication here is a script designer

00:07:15,230 --> 00:07:31,040
to to do that job it just use the blue

00:07:24,640 --> 00:07:35,000
string library to to match the version

00:07:31,040 --> 00:07:43,070
of the to pattern match the version of

00:07:35,000 --> 00:07:45,919
the SSH protocol and if the version is

00:07:43,070 --> 00:07:50,500
the winner the vulnerable version it

00:07:45,919 --> 00:07:53,900
drops the packet otherwise each it is

00:07:50,500 --> 00:07:56,830
like the the packet will go through the

00:07:53,900 --> 00:07:56,830
network

00:07:58,300 --> 00:08:08,180
we also have some issues on developing

00:08:03,340 --> 00:08:12,680
script of operating system we need to

00:08:08,180 --> 00:08:16,669
ensure that the scripts will not

00:08:12,680 --> 00:08:20,150
compromise the overall integrity of the

00:08:16,669 --> 00:08:26,300
operating system we need to ensure

00:08:20,150 --> 00:08:28,850
correctness the script should not incur

00:08:26,300 --> 00:08:34,580
in harm to the operating system

00:08:28,850 --> 00:08:39,260
we should guarantee the isolation

00:08:34,580 --> 00:08:44,330
between the the scripts one

00:08:39,260 --> 00:08:48,320
scripts extinction should not modify

00:08:44,330 --> 00:08:52,330
another one and the quill you should

00:08:48,320 --> 00:08:56,960
preserve their liveliness of the system

00:08:52,330 --> 00:09:01,160
also to make sense scriptable operate

00:08:56,960 --> 00:09:07,700
system have to provide ease of

00:09:01,160 --> 00:09:12,340
development for the extensions and it

00:09:07,700 --> 00:09:16,100
must provide ways to the users implement

00:09:12,340 --> 00:09:22,150
effect useful things using the script

00:09:16,100 --> 00:09:26,570
language and run you know if efficiently

00:09:22,150 --> 00:09:33,140
reasonable amount of time to dono to do

00:09:26,570 --> 00:09:36,980
not compromise the decision operation we

00:09:33,140 --> 00:09:40,430
can achieve correctness by scent box in

00:09:36,980 --> 00:09:45,310
the scripting language we can remove

00:09:40,430 --> 00:09:49,010
features that could cause harm to the

00:09:45,310 --> 00:09:53,870
system we can have automatic memory

00:09:49,010 --> 00:09:59,420
management to prevent scripts from the

00:09:53,870 --> 00:10:03,010
reference new pointers or leak memory we

00:09:59,420 --> 00:10:08,060
can have only one thread for each

00:10:03,010 --> 00:10:13,160
extension to prevent deadlocks we can't

00:10:08,060 --> 00:10:18,920
have protected calls to let the system

00:10:13,160 --> 00:10:22,610
failsafe when the script performs

00:10:18,920 --> 00:10:26,540
incorrectly and can use the same

00:10:22,610 --> 00:10:32,230
strategy of the kernel modules allowing

00:10:26,540 --> 00:10:38,870
only privileged users to load scripts

00:10:32,230 --> 00:10:43,250
you can't have isolation by have fully

00:10:38,870 --> 00:10:48,110
isolated execution states on the the

00:10:43,250 --> 00:10:51,759
scripting language each station purpose

00:10:48,110 --> 00:10:55,119
could have the its own

00:10:51,759 --> 00:10:58,899
is a Kishin state and they can achieve

00:10:55,119 --> 00:11:02,199
lightness by having by capping the

00:10:58,899 --> 00:11:07,829
number of these acute instructions of

00:11:02,199 --> 00:11:11,470
the scripts the ease of development

00:11:07,829 --> 00:11:14,739
could be achieved by the nature of the

00:11:11,470 --> 00:11:17,529
scripting language they are very high

00:11:14,739 --> 00:11:20,279
level language and usually dynamically

00:11:17,529 --> 00:11:24,819
type it and can also provide

00:11:20,279 --> 00:11:32,319
domain-specific api's to users for users

00:11:24,819 --> 00:11:35,679
writing writing extensions and can

00:11:32,319 --> 00:11:39,699
achieve effectiveness efficiency by

00:11:35,679 --> 00:11:42,519
providing proper binds binds are the

00:11:39,699 --> 00:11:48,089
interface between the scripts and the

00:11:42,519 --> 00:11:51,809
kernel if you want to extend a specific

00:11:48,089 --> 00:11:55,209
subsystem we have to provide newer binds

00:11:51,809 --> 00:11:59,589
to connect their kernel and the scripts

00:11:55,209 --> 00:12:03,970
we can have both our binds to the EM

00:11:59,589 --> 00:12:12,730
badge use case that our shop for and for

00:12:03,970 --> 00:12:16,230
the extent use case proper binds our can

00:12:12,730 --> 00:12:19,629
also help us to achieve there others

00:12:16,230 --> 00:12:23,139
issues on developing scriptable

00:12:19,629 --> 00:12:25,809
operation system by half proper binds

00:12:23,139 --> 00:12:29,789
you can deliver to user scripts

00:12:25,809 --> 00:12:33,999
domain-specific app api's and you can

00:12:29,789 --> 00:12:39,669
perform the verification zone on the

00:12:33,999 --> 00:12:42,689
bind scient but it is also the most

00:12:39,669 --> 00:12:46,059
difficult tasks on scripting the

00:12:42,689 --> 00:12:50,980
operating system for example in our case

00:12:46,059 --> 00:12:54,749
on at BSD we have our kernel environment

00:12:50,980 --> 00:13:00,869
to script the kernel but we lack

00:12:54,749 --> 00:13:03,869
bindings to extend the subsistence using

00:13:00,869 --> 00:13:03,869
scripts

00:13:05,380 --> 00:13:14,930
so why choose Lua as the scripting

00:13:09,560 --> 00:13:19,790
language for a kernel Lua was designed

00:13:14,930 --> 00:13:25,130
to be a extinction and St extensible

00:13:19,790 --> 00:13:28,790
extension language it can be both extent

00:13:25,130 --> 00:13:34,400
embeddable and extended by the host

00:13:28,790 --> 00:13:39,980
application also it is just a C library

00:13:34,400 --> 00:13:42,650
a usual ISO C library Lua is almost

00:13:39,980 --> 00:13:47,600
freestanding it's really easy to part

00:13:42,650 --> 00:13:55,160
Lua it has no dependence of the

00:13:47,600 --> 00:13:59,720
operating system in its kernel each

00:13:55,160 --> 00:14:07,930
score Lua has a little very small

00:13:59,720 --> 00:14:14,780
footprint it has only 240 kilobytes on

00:14:07,930 --> 00:14:19,520
currently not BSD on amd64 though is

00:14:14,780 --> 00:14:24,470
proving fast he it performed very well

00:14:19,520 --> 00:14:31,970
in many independent benchmark tests and

00:14:24,470 --> 00:14:34,460
it is MIT license it who also has saved

00:14:31,970 --> 00:14:38,120
features like automatic memory

00:14:34,460 --> 00:14:42,050
management protected call and which is

00:14:38,120 --> 00:14:48,320
really important here for fully isolated

00:14:42,050 --> 00:14:53,090
states we can have separated States for

00:14:48,320 --> 00:14:55,720
each purpose of extension and can also

00:14:53,090 --> 00:15:01,010
cap the number of the executed

00:14:55,720 --> 00:15:05,510
instructions and why not should choose

00:15:01,010 --> 00:15:11,770
something else like Python or Perl and

00:15:05,510 --> 00:15:15,200
the may answer is the size both have

00:15:11,770 --> 00:15:22,040
around megabytes or

00:15:15,200 --> 00:15:26,960
of size Python has two per one which is

00:15:22,040 --> 00:15:31,250
the same magnet or no and also both have

00:15:26,960 --> 00:15:36,850
always dependent code and they are hard

00:15:31,250 --> 00:15:40,660
to embed the they are mainly use it

00:15:36,850 --> 00:15:45,050
extended extending the this the language

00:15:40,660 --> 00:15:48,890
to write the the final application using

00:15:45,050 --> 00:15:57,500
the dilemma the scripting language not

00:15:48,890 --> 00:16:03,250
otherwise so in that best net bsd we

00:15:57,500 --> 00:16:07,610
have our kernel scripting environment i

00:16:03,250 --> 00:16:12,260
start to work home on a kernel script

00:16:07,610 --> 00:16:18,230
environment on 2008 with luna-chick for

00:16:12,260 --> 00:16:22,700
linux then ported it to net bsd in a

00:16:18,230 --> 00:16:26,680
google Summer of Code project and then

00:16:22,700 --> 00:16:32,660
mark Palmer develop it a new

00:16:26,680 --> 00:16:39,950
infrastructure around the the Lua part

00:16:32,660 --> 00:16:45,890
for the net bsd in this year start to

00:16:39,950 --> 00:16:48,710
work on anti-flu this year's case the

00:16:45,890 --> 00:16:52,460
Lua for is composed by the kernel

00:16:48,710 --> 00:16:56,960
embedded Lua which is the the lo

00:16:52,460 --> 00:17:00,290
interpreter ported to the kernel

00:16:56,960 --> 00:17:04,820
the main difference of this version of

00:17:00,290 --> 00:17:08,560
the Lua interpreter is that it has no

00:17:04,820 --> 00:17:14,480
float pointing numbers it has only

00:17:08,560 --> 00:17:17,420
integers we also have in Lua for user

00:17:14,480 --> 00:17:22,790
interface the lower control program to

00:17:17,420 --> 00:17:25,430
load scripts into the kernel our kernel

00:17:22,790 --> 00:17:27,680
programming interface to allow the

00:17:25,430 --> 00:17:30,080
kernel developers to

00:17:27,680 --> 00:17:33,230
prepared the super systems to be

00:17:30,080 --> 00:17:42,580
scriptable using the word which is

00:17:33,230 --> 00:17:46,670
defined in CC / fluid rotate so when a

00:17:42,580 --> 00:17:57,500
kernel developer wants to script the

00:17:46,670 --> 00:18:02,390
it's his sub system what she would need

00:17:57,500 --> 00:18:06,950
to do first she'll need to write a

00:18:02,390 --> 00:18:15,110
binding to connect the lure interpreter

00:18:06,950 --> 00:18:22,850
and her subsystem this bind could be in

00:18:15,110 --> 00:18:27,230
the way of extending providing api's for

00:18:22,850 --> 00:18:34,010
the for writing extensions or in the way

00:18:27,230 --> 00:18:37,700
of embedding calling a script in a

00:18:34,010 --> 00:18:41,450
specific point for example in NP F we

00:18:37,700 --> 00:18:44,720
use the imagining way we call the user

00:18:41,450 --> 00:18:50,660
script when a package arrived in the

00:18:44,720 --> 00:18:56,390
interface so once the developer has

00:18:50,660 --> 00:19:02,450
extended his subsystem to be scriptable

00:18:56,390 --> 00:19:08,470
with Lua the user can vote the the strip

00:19:02,450 --> 00:19:15,890
using the lower control user interface

00:19:08,470 --> 00:19:19,580
then the in that case of NP F the kernel

00:19:15,890 --> 00:19:23,380
subsystem can call the this script to

00:19:19,580 --> 00:19:23,380
perform some action

00:19:26,489 --> 00:19:39,999
what data is a binding for connect the

00:19:33,609 --> 00:19:43,509
system memory the Lua scripts it's it is

00:19:39,999 --> 00:19:47,979
a regular Lua library that could run

00:19:43,509 --> 00:19:52,239
both found kernel and user space and it

00:19:47,979 --> 00:19:57,279
binds the memory by pushing memory

00:19:52,239 --> 00:20:01,960
blocks repaired represented by a pointer

00:19:57,279 --> 00:20:06,669
and the size or an both structure which

00:20:01,960 --> 00:20:12,940
is used to represent the packets in the

00:20:06,669 --> 00:20:18,629
kernel it performs body verification on

00:20:12,940 --> 00:20:18,629
each access on the packet

00:20:18,659 --> 00:20:30,219
it has port for packet data using

00:20:22,769 --> 00:20:34,089
declarative layouts the data also have

00:20:30,219 --> 00:20:39,719
support for bit fields and for string

00:20:34,089 --> 00:20:44,049
fields and conversion we can convert

00:20:39,719 --> 00:20:47,679
data objects to Lewis strings then you

00:20:44,049 --> 00:20:51,789
can for example apply pattern matching

00:20:47,679 --> 00:21:00,070
to the packets and we also have support

00:20:51,789 --> 00:21:05,139
for Angela's conversion in the SSA SSH

00:21:00,070 --> 00:21:10,929
version example I will use it Lua data

00:21:05,139 --> 00:21:16,419
to convert the packet into a Louis drink

00:21:10,929 --> 00:21:21,849
it's the on point we have data copied in

00:21:16,419 --> 00:21:28,779
in this example when we push package to

00:21:21,849 --> 00:21:32,200
the the MPF Lua using raw data we

00:21:28,779 --> 00:21:36,669
perform no copy on the on that package

00:21:32,200 --> 00:21:39,000
on the amber fee structure but when we

00:21:36,669 --> 00:21:42,240
want to access it

00:21:39,000 --> 00:21:44,420
as a string as a lure string object we

00:21:42,240 --> 00:21:48,810
need to copy that

00:21:44,420 --> 00:21:53,610
we could for example the limit segment

00:21:48,810 --> 00:21:57,030
to cop just a part of the packet too but

00:21:53,610 --> 00:22:05,010
that case we caught the whole packet

00:21:57,030 --> 00:22:09,230
then we apply that pattern I highlighted

00:22:05,010 --> 00:22:13,890
that two points where we are actually

00:22:09,230 --> 00:22:19,640
using Lua data in this example to

00:22:13,890 --> 00:22:19,640
convert the damn birth to a lower string

00:22:21,080 --> 00:22:31,050
we can also have declarative data data

00:22:26,970 --> 00:22:39,690
in using lower data we define a special

00:22:31,050 --> 00:22:45,540
lower table using offsets and size in

00:22:39,690 --> 00:22:50,720
that case we are presently the RTP

00:22:45,540 --> 00:22:56,970
header for the side the if a packet

00:22:50,720 --> 00:23:02,070
holding the h.263 encode should pass or

00:22:56,970 --> 00:23:04,980
not through the network then we just

00:23:02,070 --> 00:23:09,420
have to define our offset for that field

00:23:04,980 --> 00:23:13,920
and the size then we apply the layout to

00:23:09,420 --> 00:23:21,140
the data object finally we can access

00:23:13,920 --> 00:23:25,340
the that portion of data on the packet

00:23:21,140 --> 00:23:25,340
using the Lua table notation

00:23:29,020 --> 00:23:41,590
the MPF is the nut bsd packet future its

00:23:34,220 --> 00:23:48,049
parts layers three and four inspection

00:23:41,590 --> 00:23:50,900
stateful filing ipv4 in v6 and it has a

00:23:48,049 --> 00:23:55,220
special feature that is important here

00:23:50,900 --> 00:23:58,429
it is extensible it sports rule

00:23:55,220 --> 00:24:02,660
procedures to be applied once we have

00:23:58,429 --> 00:24:08,350
matches one rule then in that the

00:24:02,660 --> 00:24:13,419
example of the ssh protocol we can have

00:24:08,350 --> 00:24:18,010
MPF rule regular file who to rule to

00:24:13,419 --> 00:24:22,340
match the connection on SSH port and

00:24:18,010 --> 00:24:30,049
then apply our script to perform deep

00:24:22,340 --> 00:24:33,610
inspection npf Lua is the binding

00:24:30,049 --> 00:24:38,590
between the NP F sub system and the Lua

00:24:33,610 --> 00:24:44,000
scripting language we have a kernel

00:24:38,590 --> 00:24:50,030
module and a part model to two

00:24:44,000 --> 00:24:54,710
interpreter the MPF configuration so we

00:24:50,030 --> 00:24:58,549
can define a procedure in NP F that we

00:24:54,710 --> 00:25:03,980
call a special function named filter on

00:24:58,549 --> 00:25:07,720
the user script and in that example we

00:25:03,980 --> 00:25:14,390
can apply that script on all traffic

00:25:07,720 --> 00:25:18,770
passing in the the interface once you

00:25:14,390 --> 00:25:22,070
have the NP F configured by using the

00:25:18,770 --> 00:25:27,160
Lua script we can load the user script

00:25:22,070 --> 00:25:27,160
using lower control program

00:25:34,500 --> 00:25:48,029
it is already sorry who we are if some

00:25:42,779 --> 00:25:53,730
ongoing project yet we are under

00:25:48,029 --> 00:25:57,870
development we have some issues that we

00:25:53,730 --> 00:26:01,710
are working right now like have actual

00:25:57,870 --> 00:26:05,360
lower rules instead of using rule

00:26:01,710 --> 00:26:10,440
prostitutes because rule procedures

00:26:05,360 --> 00:26:13,080
cannot be used to match the packets we

00:26:10,440 --> 00:26:16,470
can't we have to match it before have

00:26:13,080 --> 00:26:20,820
the fire rule applied it then apply our

00:26:16,470 --> 00:26:25,100
script using actual Lua rules biting it

00:26:20,820 --> 00:26:30,200
inside the NP F we can use it on the

00:26:25,100 --> 00:26:34,490
regular order of evaluation of the fire

00:26:30,200 --> 00:26:38,759
we have some adjustments we have to do

00:26:34,490 --> 00:26:44,460
and buffer handling we have to failsafe

00:26:38,759 --> 00:26:50,789
when we can't when the poodle pull down

00:26:44,460 --> 00:26:54,809
API fail we want to have support for non

00:26:50,789 --> 00:27:00,779
continuous strings using the Lua elbow

00:26:54,809 --> 00:27:07,470
API for not having to ensure the

00:27:00,779 --> 00:27:13,429
continuance of the n buff we could copy

00:27:07,470 --> 00:27:16,529
just the piece on the chain of them both

00:27:13,429 --> 00:27:22,129
you also want to have sparked Pope for

00:27:16,529 --> 00:27:25,710
package mangling modify the the package

00:27:22,129 --> 00:27:31,649
we loaddata has ports for modifying the

00:27:25,710 --> 00:27:37,759
packets but we are not communicating the

00:27:31,649 --> 00:27:40,980
npf already we want to have support for

00:27:37,759 --> 00:27:45,510
automatically scripting loading in the

00:27:40,980 --> 00:27:46,560
MPF configuration instead of having an

00:27:45,510 --> 00:27:51,690
additional

00:27:46,560 --> 00:27:57,840
two loads the scripts predefined it

00:27:51,690 --> 00:28:00,600
layouts like IP TCP UDP to users don't

00:27:57,840 --> 00:28:06,720
have to - right the their own layouts

00:28:00,600 --> 00:28:10,020
for such regular use we want to have a

00:28:06,720 --> 00:28:15,350
Lua network library for the final

00:28:10,020 --> 00:28:23,400
address for example ruler cheating

00:28:15,350 --> 00:28:26,790
editing using to modify the the rules

00:28:23,400 --> 00:28:32,880
present on the npf configuration in

00:28:26,790 --> 00:28:36,240
runtime and also we wanted to have an PF

00:28:32,880 --> 00:28:45,470
configuration entirely retaining Lua on

00:28:36,240 --> 00:28:48,330
the from the user space we have used a

00:28:45,470 --> 00:28:52,020
full-fledged and general proposed

00:28:48,330 --> 00:28:55,800
language for packet future where we can

00:28:52,020 --> 00:29:04,530
pattern matching using hash table for

00:28:55,800 --> 00:29:11,160
example what which allow us to to do

00:29:04,530 --> 00:29:16,290
deep inspection on packets our SSH

00:29:11,160 --> 00:29:25,950
version example have had no suitable

00:29:16,290 --> 00:29:32,820
overhead on a 100 mega MVP MVP as Vito

00:29:25,950 --> 00:29:39,330
network interface we achieved 96 and PM

00:29:32,820 --> 00:29:46,280
vpf with or without using scripting this

00:29:39,330 --> 00:29:51,960
example has only 12 lines of Lua code a

00:29:46,280 --> 00:29:54,780
testing it is simplistic and what data

00:29:51,960 --> 00:29:58,200
is a generic binding that could be used

00:29:54,780 --> 00:30:00,419
for other extensions purpose such as

00:29:58,200 --> 00:30:05,730
device drivers or implements

00:30:00,419 --> 00:30:15,799
network protocols here are some

00:30:05,730 --> 00:30:19,230
reference that you can look after that

00:30:15,799 --> 00:30:20,039
the source code code is not in the tree

00:30:19,230 --> 00:30:25,559
already

00:30:20,039 --> 00:30:30,210
but the pads can be rigid in the site

00:30:25,559 --> 00:30:34,730
and lower data are also is also in the

00:30:30,210 --> 00:30:41,759
github and you can use on other systems

00:30:34,730 --> 00:30:54,419
only user space so if you have any

00:30:41,759 --> 00:30:56,159
questions hi so when you're doing deep

00:30:54,419 --> 00:30:59,279
packet inspection inspection what

00:30:56,159 --> 00:31:02,159
happens if the data that you want to

00:30:59,279 --> 00:31:03,779
examine is not sent in a single packet

00:31:02,159 --> 00:31:07,769
what happens if a string is split

00:31:03,779 --> 00:31:10,679
between two packets dry you can you hold

00:31:07,769 --> 00:31:13,649
a packet for later you can hold

00:31:10,679 --> 00:31:18,059
information for later you can for

00:31:13,649 --> 00:31:22,519
example use hash table to to a whole

00:31:18,059 --> 00:31:29,119
deformation of the state on the script

00:31:22,519 --> 00:31:32,929
but if you will hold the entire packet I

00:31:29,119 --> 00:31:42,539
think it's not a good idea but you can

00:31:32,929 --> 00:31:45,359
one will not hurt but so you're taking

00:31:42,539 --> 00:31:47,070
what you're taking wired you're taking

00:31:45,359 --> 00:31:50,429
wire data and you're converting it into

00:31:47,070 --> 00:31:54,029
a string in Lua what are you doing to

00:31:50,429 --> 00:31:58,289
sanitize the data you receive I'm not

00:31:54,029 --> 00:32:00,330
did any sanitizer on day so that means

00:31:58,289 --> 00:32:01,909
that if there's a hole in Lua I can

00:32:00,330 --> 00:32:07,009
basically get control of your firewall

00:32:01,909 --> 00:32:07,009
no I think you know

00:32:10,280 --> 00:32:19,190
I really think not but you you can

00:32:14,990 --> 00:32:24,980
safely put in lure a stranger wave from

00:32:19,190 --> 00:32:27,710
sea with suffering to them characters

00:32:24,980 --> 00:32:32,870
you can Lou a socket for example the

00:32:27,710 --> 00:32:36,500
bind library use it in men place use the

00:32:32,870 --> 00:32:40,940
a Lewis ring for that to represent

00:32:36,500 --> 00:32:43,340
binary day data don't think he is a role

00:32:40,940 --> 00:32:47,200
that but we can talk about it before

00:32:43,340 --> 00:32:47,200
after that useful

00:32:57,850 --> 00:33:01,480
any other question

00:33:11,260 --> 00:33:19,070
hi have you thought of making some

00:33:15,520 --> 00:33:22,880
enhancements in Lua so that you can skip

00:33:19,070 --> 00:33:27,470
the copying of the packet yeah

00:33:22,880 --> 00:33:33,050
sorry miss the the heat of the sentence

00:33:27,470 --> 00:33:36,170
well have you thought of changing the

00:33:33,050 --> 00:33:41,360
way you handle packets in do I mean you

00:33:36,170 --> 00:33:46,820
said that you made copies of the packet

00:33:41,360 --> 00:33:49,310
can we skip that for for using the

00:33:46,820 --> 00:33:54,700
lowest rate library I think here we

00:33:49,310 --> 00:33:59,830
cannot because Lua has its own

00:33:54,700 --> 00:34:04,100
representation of strings and it will

00:33:59,830 --> 00:34:07,010
obligates you to to copy that if you

00:34:04,100 --> 00:34:11,179
want to use the lower string library but

00:34:07,010 --> 00:34:14,360
you can have your own string library too

00:34:11,179 --> 00:34:17,210
don't copy the delete but are you you

00:34:14,360 --> 00:34:21,760
will need to implement features that

00:34:17,210 --> 00:34:21,760
want such as pattern matching

00:34:27,750 --> 00:34:42,510
I would like to know how you debug these

00:34:35,609 --> 00:34:48,929
Lua scripts how with the bug yes yeah we

00:34:42,510 --> 00:34:52,260
can print in the log interface in the

00:34:48,929 --> 00:34:53,820
system log interface and you can use the

00:34:52,260 --> 00:35:02,849
lured debug library

00:34:53,820 --> 00:35:04,470
it is also ported for the colonel I have

00:35:02,849 --> 00:35:07,320
a question myself how do you deal with

00:35:04,470 --> 00:35:10,170
the memory model the memory management

00:35:07,320 --> 00:35:12,960
model used by Lua compared to what you

00:35:10,170 --> 00:35:15,180
do in the kernel itself because the

00:35:12,960 --> 00:35:20,030
memories you have more constraint and

00:35:15,180 --> 00:35:24,119
all that yeah Lua in fact don't have

00:35:20,030 --> 00:35:27,450
memory allocator in its core it allows

00:35:24,119 --> 00:35:32,780
the host program to deliver its own

00:35:27,450 --> 00:35:38,730
memory allocator so it defines a

00:35:32,780 --> 00:35:43,200
prototype that must respect - it's such

00:35:38,730 --> 00:35:47,550
a real lock that could be called - a

00:35:43,200 --> 00:35:52,380
lock memory and free memory and we just

00:35:47,550 --> 00:35:59,970
have to plant our locator and give that

00:35:52,380 --> 00:36:02,300
to Lou I don't know if any other

00:35:59,970 --> 00:36:02,300
question

00:36:07,990 --> 00:36:14,660
so in the estate version example you you

00:36:12,920 --> 00:36:17,180
said that there is no measurable

00:36:14,660 --> 00:36:21,080
performance overhead with and without

00:36:17,180 --> 00:36:23,720
the Lua script and how is this possible

00:36:21,080 --> 00:36:28,220
since with the Lua script we you have an

00:36:23,720 --> 00:36:32,060
additional memory copy yeah

00:36:28,220 --> 00:36:39,380
it's limited by the network not by the

00:36:32,060 --> 00:36:43,280
copy we are making we are making the

00:36:39,380 --> 00:36:50,750
other the Latins of the network is

00:36:43,280 --> 00:36:57,950
bigger than the copy we are done we have

00:36:50,750 --> 00:37:00,320
done so this on a are the Lua scripts

00:36:57,950 --> 00:37:04,150
ran on a per packet basis or on a per

00:37:00,320 --> 00:37:07,460
stream basis like if I'm trying to

00:37:04,150 --> 00:37:13,790
detect whether a user is downloading an

00:37:07,460 --> 00:37:18,050
ISO is it going to you know make a

00:37:13,790 --> 00:37:21,800
string that is for gigs 4.7 gigs in size

00:37:18,050 --> 00:37:25,010
in memory so it can run that Lua script

00:37:21,800 --> 00:37:29,870
on that stream no you have on the

00:37:25,010 --> 00:37:33,590
packets you you can save some states as

00:37:29,870 --> 00:37:36,370
you talk it before but it's not

00:37:33,590 --> 00:37:36,370
streaming

00:37:42,940 --> 00:37:49,420
in pair fizzes stateful firewall does it

00:37:46,870 --> 00:37:52,510
can you set it to process the first

00:37:49,420 --> 00:37:57,040
packet of a state for example the TCP

00:37:52,510 --> 00:37:59,980
connection if I can like the first

00:37:57,040 --> 00:38:04,300
packet is this yeah yes okay you can

00:37:59,980 --> 00:38:08,140
write a regular MTF rule to match the

00:38:04,300 --> 00:38:11,880
packet and apply the the lua script for

00:38:08,140 --> 00:38:17,740
that after you match that packet using

00:38:11,880 --> 00:38:22,330
the MPF and in every packet you can

00:38:17,740 --> 00:38:29,740
apply a tcp layout to inspect the fields

00:38:22,330 --> 00:38:36,030
of the the tcp and also you can have you

00:38:29,740 --> 00:38:48,450
can use bit fields like that on TCP or

00:38:36,030 --> 00:38:48,450
IP no more questions

00:38:56,519 --> 00:39:00,179
Thanks

00:38:57,880 --> 00:39:03,159
so since you mentioned originally that

00:39:00,179 --> 00:39:06,939
this feature is meant to be secure and

00:39:03,159 --> 00:39:09,549
safe and data isolation and unboxing

00:39:06,939 --> 00:39:11,109
you actually support individual instance

00:39:09,549 --> 00:39:13,989
becoming multiple individual instances

00:39:11,109 --> 00:39:17,409
of their low interpreter much blow in

00:39:13,989 --> 00:39:24,069
fluent ur pretoria yes we support but is

00:39:17,409 --> 00:39:28,029
whom my to-do list to have it own MPF by

00:39:24,069 --> 00:39:30,909
now we have only one low estate for MTF

00:39:28,029 --> 00:39:34,529
but in the kernel we have multiple Louis

00:39:30,909 --> 00:39:38,849
States for any purpose you want for

00:39:34,529 --> 00:39:38,849
specifically super systems yes thank you

00:39:49,540 --> 00:39:59,270
right here no more questions here is my

00:39:55,900 --> 00:40:04,180
information if you want to talk to me

00:39:59,270 --> 00:40:04,180
later please be welcome

00:40:04,760 --> 00:40:17,280
[Applause]

00:40:10,990 --> 00:40:17,280

YouTube URL: https://www.youtube.com/watch?v=LoJ4Bg2P0nc


