Title: Developing Software in a Hostile Environment - Ted Unangst
Publication date: 2019-10-14
Playlist: EuroBSDcon 2014, Bulgaria
Description: 
	Abstract:

Previous talks about exploit mitigation have generally focused on changes designed to prevent or resist system compromise by an attacker. However, many of these changes are also useful in the general software development process. I’ll present an overview of features present on OpenBSD and how they can help developers for all platforms.
Speaker biography:

I have been an OpenBSD developer for 11 years. When not hacking and slashing LibreSSL, I’m engaged in an ongoing battle with the ports team to break as many ports as possible.
Captions: 
	00:00:00,890 --> 00:00:06,359
let me welcome Ted to announce who will

00:00:04,130 --> 00:00:08,370
talk about developing software in a

00:00:06,359 --> 00:00:10,980
hostile environment and has made a

00:00:08,370 --> 00:00:13,710
career out of removing software so that

00:00:10,980 --> 00:00:17,220
his account name has become a verb in

00:00:13,710 --> 00:00:23,660
open BSD community so sure this involves

00:00:17,220 --> 00:00:23,660
lots of removals in surviving all right

00:00:25,160 --> 00:00:30,750
thank you hello so talking about

00:00:28,380 --> 00:00:34,890
developing software in a hostile

00:00:30,750 --> 00:00:36,320
environment so let's just talk about and

00:00:34,890 --> 00:00:38,840
who is it for

00:00:36,320 --> 00:00:42,120
I'm gonna begin by referencing

00:00:38,840 --> 00:00:44,129
referencing some talks that Theo has

00:00:42,120 --> 00:00:46,950
given over the years on exploit

00:00:44,129 --> 00:00:49,860
mitigation and what it is how it works

00:00:46,950 --> 00:00:54,469
and why you want it and usually his

00:00:49,860 --> 00:00:56,850
focus is on stopping the bad guys and I

00:00:54,469 --> 00:00:58,649
notice something a bit funny about how

00:00:56,850 --> 00:01:00,930
the material for these talks is

00:00:58,649 --> 00:01:03,510
structured it's usually on the one hand

00:01:00,930 --> 00:01:06,240
very technical how exploits work and how

00:01:03,510 --> 00:01:08,970
you stop them but then on the other hand

00:01:06,240 --> 00:01:11,549
you have the people who care most about

00:01:08,970 --> 00:01:13,290
this is probably end-users who want to

00:01:11,549 --> 00:01:15,240
you know they don't really have a choice

00:01:13,290 --> 00:01:17,490
and what software they run they they're

00:01:15,240 --> 00:01:19,290
given some crap and they need to use it

00:01:17,490 --> 00:01:24,119
but they want to run it in a secure

00:01:19,290 --> 00:01:25,890
environment and so they so there's kind

00:01:24,119 --> 00:01:28,409
of this gap where you've got the people

00:01:25,890 --> 00:01:30,479
developing you know the exploit

00:01:28,409 --> 00:01:33,570
mitigation technology and the people who

00:01:30,479 --> 00:01:35,400
are benefiting the most from it but I

00:01:33,570 --> 00:01:37,829
wanted to take a look from a different

00:01:35,400 --> 00:01:42,720
viewpoint which is how can we use this

00:01:37,829 --> 00:01:46,590
to help the good guys us and so this is

00:01:42,720 --> 00:01:48,630
a talk about developing software and my

00:01:46,590 --> 00:01:52,200
examples are all pretty much gonna come

00:01:48,630 --> 00:01:54,890
from open BSD but that doesn't mean I'm

00:01:52,200 --> 00:01:57,450
only talking to open BSD developers

00:01:54,890 --> 00:01:59,670
actually I'm talking to people who are

00:01:57,450 --> 00:02:03,180
not open BSD developers but people who

00:01:59,670 --> 00:02:06,119
develop software which will run on open

00:02:03,180 --> 00:02:08,970
BSD or which somebody else might want to

00:02:06,119 --> 00:02:13,470
run on open BSD if you are writing the

00:02:08,970 --> 00:02:18,720
software and so in this case open BSD

00:02:13,470 --> 00:02:21,090
is the hostile environment and what I

00:02:18,720 --> 00:02:23,040
mean by that is you know if you're only

00:02:21,090 --> 00:02:25,320
just now discovering that the Internet

00:02:23,040 --> 00:02:30,030
is a hostile environment you're about 20

00:02:25,320 --> 00:02:33,150
years too late to the party so what

00:02:30,030 --> 00:02:35,640
makes OpenBSD a hostile environment it

00:02:33,150 --> 00:02:39,660
doesn't always conform to expectations

00:02:35,640 --> 00:02:42,180
and it certainly doesn't condone many

00:02:39,660 --> 00:02:44,880
mistakes so developers talk a lot about

00:02:42,180 --> 00:02:47,010
standards is the C standard the POSIX

00:02:44,880 --> 00:02:49,410
standard but then there's also real

00:02:47,010 --> 00:02:51,240
world the facto standards like what you

00:02:49,410 --> 00:02:55,260
can get away with and what seems to work

00:02:51,240 --> 00:02:57,480
and so let's challenge some of the

00:02:55,260 --> 00:02:59,310
assumptions that people make let's go

00:02:57,480 --> 00:03:01,740
back to the standard and see what it

00:02:59,310 --> 00:03:04,680
says we can do what says and what it

00:03:01,740 --> 00:03:08,330
says we must do and then try to change

00:03:04,680 --> 00:03:11,130
what most other systems actually do and

00:03:08,330 --> 00:03:15,060
see what you know shake the tree see

00:03:11,130 --> 00:03:18,209
what falls out and basically a strictly

00:03:15,060 --> 00:03:20,330
conforming program will run just fine it

00:03:18,209 --> 00:03:25,290
conforms to the standard open BSD

00:03:20,330 --> 00:03:27,720
conforms to the standard maybe and so a

00:03:25,290 --> 00:03:29,250
well-written program or work but a

00:03:27,720 --> 00:03:31,560
poorly written program which makes

00:03:29,250 --> 00:03:34,170
assumptions and cuts corners is going to

00:03:31,560 --> 00:03:36,060
have a lot of trouble and those are the

00:03:34,170 --> 00:03:38,670
kinds of programs that you don't want to

00:03:36,060 --> 00:03:42,690
be running on a you know on a platform

00:03:38,670 --> 00:03:44,400
that provides the even that you don't

00:03:42,690 --> 00:03:46,799
want to run those programs on platforms

00:03:44,400 --> 00:03:49,560
that provide those assumptions because

00:03:46,799 --> 00:03:53,070
those assumptions are sometimes violated

00:03:49,560 --> 00:03:58,200
or it can be violated by an attacker and

00:03:53,070 --> 00:04:01,860
so everybody loves secure software but

00:03:58,200 --> 00:04:04,350
as OpenBSD project has maintained but oh

00:04:01,860 --> 00:04:09,690
no no no that's that's good I like that

00:04:04,350 --> 00:04:12,900
slide so you know as we've maintained

00:04:09,690 --> 00:04:17,190
for some time secure software is simply

00:04:12,900 --> 00:04:19,229
a subset of correct software and so I my

00:04:17,190 --> 00:04:21,180
focus here today is not on how exploit

00:04:19,229 --> 00:04:23,610
mitigation makes your software more

00:04:21,180 --> 00:04:24,990
secure it's how you can use this to

00:04:23,610 --> 00:04:27,530
develop develop software which is

00:04:24,990 --> 00:04:27,530
correct

00:04:28,830 --> 00:04:34,090
yeah

00:04:29,979 --> 00:04:36,550
so so the outline I'm gonna start off by

00:04:34,090 --> 00:04:38,680
discussing a few features that someone

00:04:36,550 --> 00:04:41,289
developing software on open BSD might

00:04:38,680 --> 00:04:43,210
want to use and then I'm gonna discuss

00:04:41,289 --> 00:04:46,539
the theory behind these features like

00:04:43,210 --> 00:04:49,120
why we change things the way we do and

00:04:46,539 --> 00:04:55,180
what kind of bugs this shakes out of a

00:04:49,120 --> 00:04:57,639
program and then okay and so and along

00:04:55,180 --> 00:05:00,699
the way I'll mix in a few examples from

00:04:57,639 --> 00:05:02,080
open BSD so there's lots of bugs that

00:05:00,699 --> 00:05:06,220
we've discovered over the years which

00:05:02,080 --> 00:05:08,500
laid dormant for 10 20 years and then

00:05:06,220 --> 00:05:11,050
you make some change to malloc you make

00:05:08,500 --> 00:05:14,020
some change to the kernel you randomized

00:05:11,050 --> 00:05:15,580
this and all of a sudden programs start

00:05:14,020 --> 00:05:18,009
crashing they start misbehaving and

00:05:15,580 --> 00:05:19,990
these bugs had always been there we just

00:05:18,009 --> 00:05:24,849
didn't know about it because they were

00:05:19,990 --> 00:05:26,979
kind of skating by and so my philosophy

00:05:24,849 --> 00:05:30,370
is software's bugs

00:05:26,979 --> 00:05:33,190
everybody knows this and lots of bugs go

00:05:30,370 --> 00:05:33,639
unnoticed but that doesn't mean they're

00:05:33,190 --> 00:05:35,349
harmless

00:05:33,639 --> 00:05:38,259
it just means you haven't noticed them

00:05:35,349 --> 00:05:40,509
yet but sooner or later somebody is

00:05:38,259 --> 00:05:43,180
going to notice them and so what we want

00:05:40,509 --> 00:05:45,460
to do is provide an environment where

00:05:43,180 --> 00:05:51,130
bugs are noticed as quickly as possible

00:05:45,460 --> 00:05:54,250
and whenever we've been adding new

00:05:51,130 --> 00:05:56,860
exploit mitigation techniques to OpenBSD

00:05:54,250 --> 00:06:00,099
something almost always breaks just

00:05:56,860 --> 00:06:02,080
always and this makes the development of

00:06:00,099 --> 00:06:05,979
such features pretty exciting because

00:06:02,080 --> 00:06:08,800
you make a change and I don't know any

00:06:05,979 --> 00:06:10,449
names but certain programs or pretty

00:06:08,800 --> 00:06:12,759
much guaranteed not to start after you

00:06:10,449 --> 00:06:14,710
make certain changes and then you kind

00:06:12,759 --> 00:06:17,740
of wonder hey did I you know it was a

00:06:14,710 --> 00:06:19,719
change I made wrong or is that program

00:06:17,740 --> 00:06:23,740
always been broken and I'm just kind of

00:06:19,719 --> 00:06:27,729
exercising some you know latent mistake

00:06:23,740 --> 00:06:31,690
and so from a high-level my philosophy

00:06:27,729 --> 00:06:34,180
is instability today leads to stability

00:06:31,690 --> 00:06:37,810
tomorrow and the sooner we can break it

00:06:34,180 --> 00:06:39,400
the better and everybody will tell you

00:06:37,810 --> 00:06:39,910
the same thing you know you want to fix

00:06:39,400 --> 00:06:41,200
bugs and

00:06:39,910 --> 00:06:43,420
development you don't want to wait until

00:06:41,200 --> 00:06:47,110
you push things out to production to fix

00:06:43,420 --> 00:06:50,650
them but there's this kind of mindset

00:06:47,110 --> 00:06:53,350
then where people once they deploy it

00:06:50,650 --> 00:06:54,940
they want to play it safe they get super

00:06:53,350 --> 00:06:58,090
conservative and they think that they

00:06:54,940 --> 00:07:01,420
can postpone or eliminate bugs and

00:06:58,090 --> 00:07:04,840
production by keeping things real steady

00:07:01,420 --> 00:07:06,400
I think that's a mistake because two

00:07:04,840 --> 00:07:08,530
years down the line when you get a bug

00:07:06,400 --> 00:07:10,240
in a production system that code is 2

00:07:08,530 --> 00:07:13,060
years old you don't know what it's doing

00:07:10,240 --> 00:07:14,530
and you're so far past it on your

00:07:13,060 --> 00:07:17,290
current branches it becomes very

00:07:14,530 --> 00:07:19,930
difficult to debug and and then you're

00:07:17,290 --> 00:07:21,850
also in a bit of a panic I think it's

00:07:19,930 --> 00:07:25,660
much better to have a bug in production

00:07:21,850 --> 00:07:27,130
one month after you deploy and you don't

00:07:25,660 --> 00:07:29,920
you can't avoid the bug it's gonna

00:07:27,130 --> 00:07:41,620
happen and so it's always better to pull

00:07:29,920 --> 00:07:48,100
it forward in time so the big thing here

00:07:41,620 --> 00:07:50,320
is malecon this is a symlink that you

00:07:48,100 --> 00:07:52,990
can use to control the behavior of

00:07:50,320 --> 00:07:54,370
Malick it's on every BSD platform I'm

00:07:52,990 --> 00:07:57,280
gonna talk specifically about open BSD

00:07:54,370 --> 00:08:00,460
although a good chunk of this applies to

00:07:57,280 --> 00:08:01,720
other platforms as well so probably most

00:08:00,460 --> 00:08:04,810
people are familiar with this I think

00:08:01,720 --> 00:08:08,440
it's kind of discussed fairly frequently

00:08:04,810 --> 00:08:11,110
in the BSD community and so it's a great

00:08:08,440 --> 00:08:13,210
place to start and then after I discuss

00:08:11,110 --> 00:08:15,070
some of the malloc features we're gonna

00:08:13,210 --> 00:08:17,110
move on to some of the theory behind

00:08:15,070 --> 00:08:19,060
this and dive a little bit deeper into

00:08:17,110 --> 00:08:21,280
how allocators work and how this affects

00:08:19,060 --> 00:08:23,350
the program behavior and how your

00:08:21,280 --> 00:08:27,760
program can have hidden dependencies on

00:08:23,350 --> 00:08:30,610
specific allocator behaviors so the BSD

00:08:27,760 --> 00:08:32,650
Malick's all support malloc seconf

00:08:30,610 --> 00:08:37,419
I think it made its appearance in PH k

00:08:32,650 --> 00:08:40,000
malik way way back when and then it was

00:08:37,419 --> 00:08:43,240
subsequently retained in both je Malik

00:08:40,000 --> 00:08:45,490
and Otto Malik and there's been some

00:08:43,240 --> 00:08:48,730
divergence and available options since

00:08:45,490 --> 00:08:51,880
then but basically you create a symlink

00:08:48,730 --> 00:08:53,590
in Etsy and you pointed at some string

00:08:51,880 --> 00:08:56,740
of letters and every lighter turns on

00:08:53,590 --> 00:09:00,070
off a particular option some of them are

00:08:56,740 --> 00:09:02,650
only useful in education some of them

00:09:00,070 --> 00:09:06,460
are pretty useful all the time my

00:09:02,650 --> 00:09:08,410
favorite option is je for junk and what

00:09:06,460 --> 00:09:11,380
this does is it pre-fills

00:09:08,410 --> 00:09:13,810
memory so when you allocate memory it

00:09:11,380 --> 00:09:15,490
overrides it so it it's nonzero when

00:09:13,810 --> 00:09:17,110
it's returned from malloc and then when

00:09:15,490 --> 00:09:20,230
you free memory it also immediately

00:09:17,110 --> 00:09:21,670
overrides it so that whatever previous

00:09:20,230 --> 00:09:24,580
contents of the memory were are

00:09:21,670 --> 00:09:26,980
overwritten and this catches two

00:09:24,580 --> 00:09:31,000
different classes of bucks

00:09:26,980 --> 00:09:33,070
first many programs fail to completely

00:09:31,000 --> 00:09:35,050
initialize heap objects this is just

00:09:33,070 --> 00:09:37,870
like a classic stack uninitialized

00:09:35,050 --> 00:09:39,310
variable but it's a lot harder to detect

00:09:37,870 --> 00:09:42,940
your compiler gives you very little

00:09:39,310 --> 00:09:45,700
support for detecting these bugs and so

00:09:42,940 --> 00:09:47,740
they also go unnoticed because initially

00:09:45,700 --> 00:09:49,870
when a program starts malloc is

00:09:47,740 --> 00:09:52,180
returning new memory it gets this memory

00:09:49,870 --> 00:09:54,610
from the kernel and the kernel is almost

00:09:52,180 --> 00:09:56,260
certainly zero filling it for you and so

00:09:54,610 --> 00:09:58,000
all the memory coming back from malloc

00:09:56,260 --> 00:10:00,460
when you run your test cases is zero

00:09:58,000 --> 00:10:01,780
filled and it looks like hey you know

00:10:00,460 --> 00:10:04,540
it's great I don't have to initialize

00:10:01,780 --> 00:10:07,330
this but then as a program runs and runs

00:10:04,540 --> 00:10:09,190
over time it starts freeing memory and

00:10:07,330 --> 00:10:11,230
then malloc starts reusing that memory

00:10:09,190 --> 00:10:15,460
and it has the contents of whatever the

00:10:11,230 --> 00:10:17,980
previous usage was and so you end up not

00:10:15,460 --> 00:10:21,910
getting so lucky and then the bug

00:10:17,980 --> 00:10:25,110
manifests much better you know my mind

00:10:21,910 --> 00:10:28,630
to catch it on the first allocation and

00:10:25,110 --> 00:10:31,360
second thing is many youssef to free

00:10:28,630 --> 00:10:32,290
bugs rely on the memory remaining

00:10:31,360 --> 00:10:34,960
untouched

00:10:32,290 --> 00:10:38,140
after you free it so you free an object

00:10:34,960 --> 00:10:40,000
and until the next malloc call you can

00:10:38,140 --> 00:10:42,640
almost certainly continue reading that

00:10:40,000 --> 00:10:45,250
object and writing to it without ill

00:10:42,640 --> 00:10:47,860
effect because the memory is still there

00:10:45,250 --> 00:10:49,930
and the contents are still there and so

00:10:47,860 --> 00:10:51,700
if you you know free something and then

00:10:49,930 --> 00:10:54,430
dereference a pointer and a struct that

00:10:51,700 --> 00:10:56,560
you just freed hey you know no harm no

00:10:54,430 --> 00:10:59,320
foul but we don't want things to work

00:10:56,560 --> 00:11:02,770
like that so if we override it with a

00:10:59,320 --> 00:11:04,000
junk pattern then that pointer all the

00:11:02,770 --> 00:11:06,050
pointers in a struct will become

00:11:04,000 --> 00:11:13,339
invalidate it and you

00:11:06,050 --> 00:11:16,810
Oh crash great now there's no guarantee

00:11:13,339 --> 00:11:20,209
that junking memory will flush out a bug

00:11:16,810 --> 00:11:22,250
the depending on how you you know

00:11:20,209 --> 00:11:24,529
initialize or don't initialize the

00:11:22,250 --> 00:11:27,380
memory or what kind of use pattern you

00:11:24,529 --> 00:11:31,190
have you're not going to trigger every

00:11:27,380 --> 00:11:34,190
bug but it's the bugs that it triggers

00:11:31,190 --> 00:11:35,630
are a good subset of bugs in real-world

00:11:34,190 --> 00:11:38,300
oh you've seen a lot of programs where

00:11:35,630 --> 00:11:39,740
you crash and then you look back at the

00:11:38,300 --> 00:11:43,670
instruction pointer and when you see

00:11:39,740 --> 00:11:45,649
like do-do-do-do as the pointer that you

00:11:43,670 --> 00:11:48,920
tried to jump to it's pretty obvious

00:11:45,649 --> 00:11:51,500
what happened now

00:11:48,920 --> 00:11:53,750
the man page for malloc in my mind

00:11:51,500 --> 00:11:56,329
unfortunately kind of downplays the J

00:11:53,750 --> 00:11:58,790
option recommends it for debugging and

00:11:56,329 --> 00:12:02,149
testing I think it's a great option to

00:11:58,790 --> 00:12:04,370
use all the time and it's not just for

00:12:02,149 --> 00:12:06,079
debugging or testing and so despite

00:12:04,370 --> 00:12:08,029
whatever warnings are in the man page

00:12:06,079 --> 00:12:09,890
and I think actually that FreeBSD Man

00:12:08,029 --> 00:12:14,329
page kind of goes over the top and like

00:12:09,890 --> 00:12:16,579
specifically advises not using J you

00:12:14,329 --> 00:12:19,130
know I think it's fine to run J in

00:12:16,579 --> 00:12:20,959
production because I mean you have to

00:12:19,130 --> 00:12:22,339
measure it there is a performance hit

00:12:20,959 --> 00:12:24,110
obviously because you're overriding it

00:12:22,339 --> 00:12:26,720
but the amount of time you're gonna

00:12:24,110 --> 00:12:28,310
spend overriding memory compared to

00:12:26,720 --> 00:12:32,870
running the rest of your program

00:12:28,310 --> 00:12:39,190
hopefully isn't you know the ratio is

00:12:32,870 --> 00:12:41,930
not going to be too bad and so and

00:12:39,190 --> 00:12:43,490
basically there are two scenarios you

00:12:41,930 --> 00:12:47,870
run with J and your program doesn't work

00:12:43,490 --> 00:12:51,680
well that's not good and or you run with

00:12:47,870 --> 00:12:53,329
J and program works fine now the problem

00:12:51,680 --> 00:12:54,920
is so you're like oh well the program

00:12:53,329 --> 00:12:58,490
doesn't work with J I'm going to turn J

00:12:54,920 --> 00:13:01,550
off that program is still buggy using

00:12:58,490 --> 00:13:03,320
like disabling the malloc option didn't

00:13:01,550 --> 00:13:06,070
make the bug go away it just means

00:13:03,320 --> 00:13:08,180
you're gonna hit the bug later and so

00:13:06,070 --> 00:13:10,070
you know you should think carefully

00:13:08,180 --> 00:13:12,230
about whether you actually want to be

00:13:10,070 --> 00:13:13,790
running a program which can't be run

00:13:12,230 --> 00:13:18,380
with these kinds of options turned on

00:13:13,790 --> 00:13:21,260
and lots of

00:13:18,380 --> 00:13:25,190
Oh BSD users I think already run with

00:13:21,260 --> 00:13:28,700
Malik J and so a lot of the bugs that a

00:13:25,190 --> 00:13:29,750
caches have been already caught and but

00:13:28,700 --> 00:13:31,550
you know there's always some that

00:13:29,750 --> 00:13:33,620
slipped through because nobody's testing

00:13:31,550 --> 00:13:37,040
all the time and so one of the changes I

00:13:33,620 --> 00:13:39,940
recently made is to start junking small

00:13:37,040 --> 00:13:42,920
chunks by default and this immediately

00:13:39,940 --> 00:13:45,980
just triggered a bug in the Postgres

00:13:42,920 --> 00:13:48,770
ruby gem where it was using memory after

00:13:45,980 --> 00:13:52,130
it had freed it and nobody had happened

00:13:48,770 --> 00:13:54,740
to run this particular code with malloc

00:13:52,130 --> 00:13:57,980
honk J turned on before and so as soon

00:13:54,740 --> 00:14:07,760
as we switched to junk by default BAM

00:13:57,980 --> 00:14:09,800
the blood came out now the so the change

00:14:07,760 --> 00:14:13,180
that I made describing a little more

00:14:09,800 --> 00:14:15,860
depth to the default is not the full J

00:14:13,180 --> 00:14:17,540
and you can actually disable it by going

00:14:15,860 --> 00:14:25,250
to lowercase J so it's kind of like a

00:14:17,540 --> 00:14:27,890
Midway 1/2 uppercase J and the way the

00:14:25,250 --> 00:14:29,240
reason we did it that way is we had a

00:14:27,890 --> 00:14:31,430
couple of choices to full J as I

00:14:29,240 --> 00:14:32,780
mentioned it can be expensive we don't

00:14:31,430 --> 00:14:35,480
necessarily want to impose a penalty on

00:14:32,780 --> 00:14:38,690
everybody but we looked at the class of

00:14:35,480 --> 00:14:42,290
bugs that exist and what kind of bugs we

00:14:38,690 --> 00:14:45,050
hope to catch and so we kept it to only

00:14:42,290 --> 00:14:47,300
junking small chunks we don't want to

00:14:45,050 --> 00:14:50,090
necessarily go and junk hundreds of

00:14:47,300 --> 00:14:53,510
megabytes of memory that you freed in

00:14:50,090 --> 00:14:55,490
particular malloc because it uses a map

00:14:53,510 --> 00:14:58,190
it's zero fill on demand and so you

00:14:55,490 --> 00:14:59,840
might not even have paged in all of

00:14:58,190 --> 00:15:03,110
those pages and so it's silly for malloc

00:14:59,840 --> 00:15:05,540
to fault the page in just to zero it or

00:15:03,110 --> 00:15:08,140
junk it when it never would have been

00:15:05,540 --> 00:15:11,720
you know allocated in the first place

00:15:08,140 --> 00:15:14,780
and also I think use after free bugs are

00:15:11,720 --> 00:15:18,110
more pervasive and more dangerous than

00:15:14,780 --> 00:15:21,110
uninitialized bugs and so that's why we

00:15:18,110 --> 00:15:23,210
don't do this on the front side coming

00:15:21,110 --> 00:15:26,030
out of Mallik we only do it on the

00:15:23,210 --> 00:15:27,410
structures that go back into free and

00:15:26,030 --> 00:15:29,750
that actually works out pretty well

00:15:27,410 --> 00:15:32,300
because then as a side effect if this

00:15:29,750 --> 00:15:34,370
object is recycled when you

00:15:32,300 --> 00:15:37,040
malakut again it's already been junked

00:15:34,370 --> 00:15:41,660
by the previous free so it's a pretty

00:15:37,040 --> 00:15:43,700
efficient way to flush out bugs and you

00:15:41,660 --> 00:15:47,510
know so we turn this on by default

00:15:43,700 --> 00:15:50,720
because for as much as you know the user

00:15:47,510 --> 00:15:52,580
base is run with J turned on you can

00:15:50,720 --> 00:15:55,160
always find more bugs by conscripting

00:15:52,580 --> 00:15:56,990
more testers and so you know if you

00:15:55,160 --> 00:16:02,780
don't want to volunteer you're gonna be

00:15:56,990 --> 00:16:04,490
volunteered no there's some other

00:16:02,780 --> 00:16:07,280
options that can be interesting there's

00:16:04,490 --> 00:16:09,560
the F and u options which are free guard

00:16:07,280 --> 00:16:12,590
and unmapped and what they do is they on

00:16:09,560 --> 00:16:14,480
map the free pages list this is a little

00:16:12,590 --> 00:16:17,740
bit more of an expensive operation and

00:16:14,480 --> 00:16:21,410
it only works at a page size granularity

00:16:17,740 --> 00:16:24,290
but this can trigger and detect a couple

00:16:21,410 --> 00:16:26,720
other cases of bugs where instead of

00:16:24,290 --> 00:16:29,360
just overriding the data by actually on

00:16:26,720 --> 00:16:32,240
mapping the page entirely we used a

00:16:29,360 --> 00:16:34,280
kernel memory protection to trigger seg

00:16:32,240 --> 00:16:39,530
faults whenever the page is accessed and

00:16:34,280 --> 00:16:46,040
so you know this there are some other

00:16:39,530 --> 00:16:50,480
options the p option as well and ongoing

00:16:46,040 --> 00:16:52,760
work i have is to try to keep distinct

00:16:50,480 --> 00:16:54,140
objects on distinct pages so that you

00:16:52,760 --> 00:16:57,050
actually end up being able to UM

00:16:54,140 --> 00:16:58,700
unmapped pages more frequently because

00:16:57,050 --> 00:17:00,350
right now there's a situation where you

00:16:58,700 --> 00:17:01,520
allocate one chunk and then you allocate

00:17:00,350 --> 00:17:03,500
another chunk then you free the first

00:17:01,520 --> 00:17:05,209
chunk as long as the second chunk is

00:17:03,500 --> 00:17:08,930
still allocated the page can't be

00:17:05,209 --> 00:17:10,520
unmapped but if we can keep separate

00:17:08,930 --> 00:17:13,820
chunks and separate pages and kind of

00:17:10,520 --> 00:17:17,690
actually fragment the address space on

00:17:13,820 --> 00:17:22,610
purpose then we get the ability to run

00:17:17,690 --> 00:17:24,200
map more aggressively and one option

00:17:22,610 --> 00:17:26,900
that I'm gonna mention which I think

00:17:24,200 --> 00:17:28,250
used to be more popular and I don't

00:17:26,900 --> 00:17:30,620
necessarily recommend it as much anymore

00:17:28,250 --> 00:17:35,270
is the G option which turns on guard

00:17:30,620 --> 00:17:37,420
pages currently the kernel actually does

00:17:35,270 --> 00:17:41,000
a pretty good job of sending down

00:17:37,420 --> 00:17:43,220
randomized addresses for each allocated

00:17:41,000 --> 00:17:45,620
space that map has and so you end up

00:17:43,220 --> 00:17:46,310
with implicit guard pages between a lot

00:17:45,620 --> 00:17:51,170
of the

00:17:46,310 --> 00:17:52,700
and that's I would say sufficient for

00:17:51,170 --> 00:17:54,770
you know running all the time if you

00:17:52,700 --> 00:17:59,600
want to turn on G you can that comes

00:17:54,770 --> 00:18:01,130
with a heavier performance hit and so it

00:17:59,600 --> 00:18:02,960
actually affects some of the important

00:18:01,130 --> 00:18:04,340
code paths like every allocation has to

00:18:02,960 --> 00:18:06,230
allocate their guard page and then it

00:18:04,340 --> 00:18:07,850
has to M protect it and when you freed

00:18:06,230 --> 00:18:09,560
us to M protect it again and it does all

00:18:07,850 --> 00:18:11,540
these you know crazy dances with it and

00:18:09,560 --> 00:18:14,000
so if you're looking to conserve

00:18:11,540 --> 00:18:17,450
performance you know I'd skip on that

00:18:14,000 --> 00:18:19,430
one doubt you know it works like

00:18:17,450 --> 00:18:21,560
obviously more options is better and it

00:18:19,430 --> 00:18:23,870
works better than the option without but

00:18:21,560 --> 00:18:27,200
I think in long term the number of bugs

00:18:23,870 --> 00:18:34,310
it's going to flush out is not as great

00:18:27,200 --> 00:18:39,890
as some of the other things okay oh

00:18:34,310 --> 00:18:43,160
that's nice too big so another term for

00:18:39,890 --> 00:18:45,380
junking memory is poisoning and so this

00:18:43,160 --> 00:18:47,390
comes this is a term we using a VSD

00:18:45,380 --> 00:18:48,770
kernel for instance and so I'm going to

00:18:47,390 --> 00:18:50,570
talk a little bit more about kind of a

00:18:48,770 --> 00:18:53,330
little bit of the theory behind junking

00:18:50,570 --> 00:18:57,500
and go discuss like some other ways that

00:18:53,330 --> 00:18:59,270
we can use this to our advantage and so

00:18:57,500 --> 00:19:01,160
malloc which i've been discussing is the

00:18:59,270 --> 00:19:02,840
general-purpose allocator you give it a

00:19:01,160 --> 00:19:05,720
number of bytes it gives you back bytes

00:19:02,840 --> 00:19:06,980
and so it kind of operates on memory but

00:19:05,720 --> 00:19:09,650
I want to switch the discussion now to

00:19:06,980 --> 00:19:11,960
discussing objects because I think that

00:19:09,650 --> 00:19:14,690
helps to better understand and

00:19:11,960 --> 00:19:17,990
comprehend the kinds of bugs we're gonna

00:19:14,690 --> 00:19:21,260
have and so every object has a lifetime

00:19:17,990 --> 00:19:25,160
it's allocated then use it and then you

00:19:21,260 --> 00:19:27,680
free it or destroy it and bugs result

00:19:25,160 --> 00:19:30,950
when the code using an object doesn't

00:19:27,680 --> 00:19:32,420
respect the lifetime appropriately and

00:19:30,950 --> 00:19:34,310
so what we're looking for is an

00:19:32,420 --> 00:19:37,700
enforcement mechanism and that's where

00:19:34,310 --> 00:19:40,820
poisoning comes in and poisoning an

00:19:37,700 --> 00:19:42,470
object it can be as simple as overriding

00:19:40,820 --> 00:19:44,650
the memory with a simple pattern but it

00:19:42,470 --> 00:19:48,380
can also be considerably more complex

00:19:44,650 --> 00:19:52,430
for instance you can try to pick a fill

00:19:48,380 --> 00:19:56,240
pattern that is deliberately designed so

00:19:52,430 --> 00:19:57,980
that pointers are invalid and so in

00:19:56,240 --> 00:20:00,050
kernel

00:19:57,980 --> 00:20:03,250
the popular choice for this is kind of

00:20:00,050 --> 00:20:07,820
like dead beef but actually on the i386

00:20:03,250 --> 00:20:10,220
architecture the Oh X stead beef pointer

00:20:07,820 --> 00:20:13,240
is in use only an address space and so

00:20:10,220 --> 00:20:14,750
you don't necessarily want to be

00:20:13,240 --> 00:20:18,740
dereferencing that because it actually

00:20:14,750 --> 00:20:21,080
might work so what we did instead is we

00:20:18,740 --> 00:20:24,350
changed it to an o x ee something

00:20:21,080 --> 00:20:26,600
address and that page is guaranteed to

00:20:24,350 --> 00:20:30,650
be unmapped and so dereferencing that

00:20:26,600 --> 00:20:32,240
pointer is guaranteed to crash and you

00:20:30,650 --> 00:20:36,350
can also use a few different fill

00:20:32,240 --> 00:20:38,360
patterns because bugs as I'll mention

00:20:36,350 --> 00:20:41,150
have a tendency to adapt to whatever you

00:20:38,360 --> 00:20:45,920
do and so this is a case where despite

00:20:41,150 --> 00:20:47,660
all the things that we were doing there

00:20:45,920 --> 00:20:49,970
were still bunch of bucks and this is a

00:20:47,660 --> 00:20:52,370
while for a while now Theo and I had

00:20:49,970 --> 00:20:55,130
been discussing the possibility that the

00:20:52,370 --> 00:20:57,080
dead beef value we had been using in the

00:20:55,130 --> 00:21:00,320
kernel might have accidentally

00:20:57,080 --> 00:21:04,100
conveniently aligned with some flag

00:21:00,320 --> 00:21:07,180
values that were actually valid and so

00:21:04,100 --> 00:21:10,730
you would free an object and it would

00:21:07,180 --> 00:21:13,520
clear or set particular flag fields in

00:21:10,730 --> 00:21:21,620
the struct which rendered the struct

00:21:13,520 --> 00:21:25,690
still valid and now what happened was so

00:21:21,620 --> 00:21:29,030
as an experiment earlier this summer I

00:21:25,690 --> 00:21:30,590
inverted the bit patterns used and it

00:21:29,030 --> 00:21:37,520
wasn't long before the smoke came

00:21:30,590 --> 00:21:39,410
pouring out and so it's actually two

00:21:37,520 --> 00:21:41,690
values used an open BSD kernel but they

00:21:39,410 --> 00:21:43,310
are actually they're very similar one

00:21:41,690 --> 00:21:47,330
was originally used for pool and one was

00:21:43,310 --> 00:21:49,040
used for malloc and they they're just

00:21:47,330 --> 00:21:51,350
they've only vary in a couple bits but a

00:21:49,040 --> 00:21:53,740
lot of the bits are the same but by

00:21:51,350 --> 00:21:57,410
inverting them we ended up with an

00:21:53,740 --> 00:21:59,750
entirely different bit pattern and there

00:21:57,410 --> 00:22:03,200
was a bug where the function which

00:21:59,750 --> 00:22:06,830
establishes interrupt handlers on a 386

00:22:03,200 --> 00:22:11,040
failed to initialize the flags field of

00:22:06,830 --> 00:22:14,490
a struct and so it would just get

00:22:11,040 --> 00:22:16,530
like Oh ex dead beef set in it and that

00:22:14,490 --> 00:22:19,710
was fine because the flags that were

00:22:16,530 --> 00:22:21,840
being set or not set were meaningless

00:22:19,710 --> 00:22:24,390
and so the code continued to work

00:22:21,840 --> 00:22:28,200
however when we inverted the bit pattern

00:22:24,390 --> 00:22:30,630
it set the MP safe flag and so when you

00:22:28,200 --> 00:22:34,080
marked an interrupt handler as MP safe

00:22:30,630 --> 00:22:39,450
and it's not MP safe that's when bad

00:22:34,080 --> 00:22:40,740
things happen now unfortunately this is

00:22:39,450 --> 00:22:43,650
actually kind of difficult to track down

00:22:40,740 --> 00:22:46,710
because you don't crash right away

00:22:43,650 --> 00:22:48,870
instead the interrupt handler is running

00:22:46,710 --> 00:22:50,640
without the kernel lock and all sudden

00:22:48,870 --> 00:22:53,040
and may be corrupt some memory maybe

00:22:50,640 --> 00:22:55,200
triggers some other assertions and only

00:22:53,040 --> 00:22:58,980
some drivers were affected and only on

00:22:55,200 --> 00:23:00,540
some machines because the way interrupt

00:22:58,980 --> 00:23:02,700
handlers to run like sometimes you have

00:23:00,540 --> 00:23:03,870
the big lock anyway and you know it was

00:23:02,700 --> 00:23:05,460
like a very complicated thing but

00:23:03,870 --> 00:23:08,340
certain machines were just kind of like

00:23:05,460 --> 00:23:12,120
boom and so we start kind of backing out

00:23:08,340 --> 00:23:15,330
diffs and finally somebody backed out

00:23:12,120 --> 00:23:17,640
the poison DIF that I had realized hey

00:23:15,330 --> 00:23:19,320
now the kernel works again and then we

00:23:17,640 --> 00:23:21,780
realize okay so this is uninitialized

00:23:19,320 --> 00:23:24,750
memory so let's start taking a look at

00:23:21,780 --> 00:23:27,900
all of the fields that have been touched

00:23:24,750 --> 00:23:30,510
and we inspected the interrupt handler

00:23:27,900 --> 00:23:32,580
structure looked at its flags field and

00:23:30,510 --> 00:23:34,049
realized that the value there didn't

00:23:32,580 --> 00:23:37,040
make any sense because it had a lot of

00:23:34,049 --> 00:23:40,500
bits set that should not have been set

00:23:37,040 --> 00:23:42,809
fix that bug I think there were still

00:23:40,500 --> 00:23:46,410
two or three other bugs that were

00:23:42,809 --> 00:23:49,770
suspected of being caused by the bitten

00:23:46,410 --> 00:23:51,660
version change so the change was

00:23:49,770 --> 00:23:53,790
actually backed out because we were kind

00:23:51,660 --> 00:23:57,290
of going into release and it was causing

00:23:53,790 --> 00:24:00,870
too much trouble and so just kind of a

00:23:57,290 --> 00:24:02,340
cautionary tale that you know you add

00:24:00,870 --> 00:24:05,010
these options and you want to flush out

00:24:02,340 --> 00:24:07,440
bugs but then you end up with bugs that

00:24:05,010 --> 00:24:10,710
depend on the bug like detecting you

00:24:07,440 --> 00:24:13,080
know code and so you want to change

00:24:10,710 --> 00:24:16,429
things up from time to time and keep the

00:24:13,080 --> 00:24:20,059
patterns that you're using variable and

00:24:16,429 --> 00:24:22,679
one last thing that the the kernel does

00:24:20,059 --> 00:24:24,830
and unfortunately userland doesn't do

00:24:22,679 --> 00:24:27,440
this at present although

00:24:24,830 --> 00:24:29,750
I kind of had some work going along

00:24:27,440 --> 00:24:35,480
these lines is that you check the poison

00:24:29,750 --> 00:24:37,340
value and so okay we good said that

00:24:35,480 --> 00:24:38,770
don't depend on poison but you want to

00:24:37,340 --> 00:24:43,430
check that it remains invalid and so

00:24:38,770 --> 00:24:45,050
this can detect right after free well

00:24:43,430 --> 00:24:48,980
you know you feel an object without wax

00:24:45,050 --> 00:24:50,150
dead beef and then the pool coat is

00:24:48,980 --> 00:24:53,000
actually pretty good about this where

00:24:50,150 --> 00:24:55,910
you can set an option in pool where on

00:24:53,000 --> 00:24:57,830
every allocation and every free a then

00:24:55,910 --> 00:24:59,270
walks its entire free list to make sure

00:24:57,830 --> 00:25:01,850
that all of the objects which have been

00:24:59,270 --> 00:25:04,840
previously freed are still in their

00:25:01,850 --> 00:25:09,170
pristine poisoned State and nobody has

00:25:04,840 --> 00:25:11,540
muddled with them in any way and so if

00:25:09,170 --> 00:25:16,060
anybody changes an object after you

00:25:11,540 --> 00:25:21,680
freed it that's a good time to panic and

00:25:16,060 --> 00:25:24,290
now so the well I'm on that subject so

00:25:21,680 --> 00:25:29,900
this brings us to the topic of recycling

00:25:24,290 --> 00:25:33,710
and so recycling policy is when a

00:25:29,900 --> 00:25:37,460
allocator decides to reuse memory you're

00:25:33,710 --> 00:25:38,960
going to have a free list doesn't

00:25:37,460 --> 00:25:43,160
actually necessarily have to be a list

00:25:38,960 --> 00:25:47,780
like user land malloc actually uses a

00:25:43,160 --> 00:25:49,820
bit array but in in the kernel like the

00:25:47,780 --> 00:25:51,860
kernel malloc it literally is just a

00:25:49,820 --> 00:25:55,940
list with pointers to the next free

00:25:51,860 --> 00:25:58,100
chunk as you go and so there's two

00:25:55,940 --> 00:26:01,910
things that how recycling relates to

00:25:58,100 --> 00:26:04,580
poisoning is if you poison an object

00:26:01,910 --> 00:26:07,370
after you free it but then you allocate

00:26:04,580 --> 00:26:09,320
it again it's gonna be reinitialized and

00:26:07,370 --> 00:26:12,320
so then you can't detect a use after

00:26:09,320 --> 00:26:14,270
free on that object anymore because the

00:26:12,320 --> 00:26:17,300
poison has kind of been washed off and

00:26:14,270 --> 00:26:19,340
now the previously dangling pointer is

00:26:17,300 --> 00:26:20,750
pointing to a valid object again it's

00:26:19,340 --> 00:26:24,230
not the object that thinks it's pointing

00:26:20,750 --> 00:26:26,180
to but it's a valid object and so this

00:26:24,230 --> 00:26:28,780
just causes more and more corruption and

00:26:26,180 --> 00:26:32,410
kind of delays the detection of the book

00:26:28,780 --> 00:26:34,910
so there's a couple ways that a

00:26:32,410 --> 00:26:37,830
allocator can decide whether it's gonna

00:26:34,910 --> 00:26:40,769
what pointers to recycle or not

00:26:37,830 --> 00:26:43,259
and probably the most common policy in a

00:26:40,769 --> 00:26:46,529
lot of systems is fast recycle which is

00:26:43,259 --> 00:26:47,249
last in first out this is you free

00:26:46,529 --> 00:26:49,019
something

00:26:47,249 --> 00:26:51,480
the very next call to malloc is gonna

00:26:49,019 --> 00:26:54,389
return the same object that was

00:26:51,480 --> 00:26:56,220
previously freed this is great for

00:26:54,389 --> 00:27:00,090
performance because it keeps staying as

00:26:56,220 --> 00:27:03,419
hot in the cache unfortunately it's not

00:27:00,090 --> 00:27:06,960
so great for detecting bucks as I was

00:27:03,419 --> 00:27:08,549
explaining you have an object you put it

00:27:06,960 --> 00:27:09,960
you free it and so you got this thing

00:27:08,549 --> 00:27:11,249
that you're marked free and you want to

00:27:09,960 --> 00:27:12,929
watch it and make sure it doesn't change

00:27:11,249 --> 00:27:15,690
and you want to detect bugs in it and

00:27:12,929 --> 00:27:17,669
keeping these crazy Poisson values but

00:27:15,690 --> 00:27:19,830
then if you allocate it again and turn

00:27:17,669 --> 00:27:22,139
it back into an object all the code that

00:27:19,830 --> 00:27:28,049
is buggy and uses that object is going

00:27:22,139 --> 00:27:34,100
to see a valid object and so yeah this

00:27:28,049 --> 00:27:38,940
is you know causes a lot of problems and

00:27:34,100 --> 00:27:41,070
you know also from a security standpoint

00:27:38,940 --> 00:27:43,019
this is also pretty bad because this is

00:27:41,070 --> 00:27:45,149
probably the most predictable

00:27:43,019 --> 00:27:48,450
deterministic behavior that an alligator

00:27:45,149 --> 00:27:50,759
can have and so you know going a little

00:27:48,450 --> 00:27:52,529
bit and so we've been addressing this in

00:27:50,759 --> 00:27:55,980
part from the direction of exploit

00:27:52,529 --> 00:27:59,070
mitigation where if you read about how

00:27:55,980 --> 00:28:01,049
exploits and the heap work you generally

00:27:59,070 --> 00:28:02,580
require allocating and freeing and

00:28:01,049 --> 00:28:04,769
allocating and freeing objects in a

00:28:02,580 --> 00:28:07,980
particular pattern that pattern is

00:28:04,769 --> 00:28:11,369
easiest to manipulate with a fast

00:28:07,980 --> 00:28:13,739
recycling allocator and then that gives

00:28:11,369 --> 00:28:15,659
the attacker control over the heap and

00:28:13,739 --> 00:28:17,609
allows them to guarantee that an old and

00:28:15,659 --> 00:28:21,269
new object will overlap in the same

00:28:17,609 --> 00:28:24,119
region of memory now the opposite policy

00:28:21,269 --> 00:28:28,590
would be slow recycle which is first in

00:28:24,119 --> 00:28:31,320
first out or last in last out and so

00:28:28,590 --> 00:28:33,509
this is where you free something and

00:28:31,320 --> 00:28:36,840
then it stays on the free list for as

00:28:33,509 --> 00:28:39,239
long as possible this is how are you and

00:28:36,840 --> 00:28:42,109
you know like the buffer cache uses slow

00:28:39,239 --> 00:28:43,799
recycle because you want to keep buffers

00:28:42,109 --> 00:28:47,580
valid if for as long as possible

00:28:43,799 --> 00:28:50,350
although you know buffer caches are

00:28:47,580 --> 00:28:55,070
quite like an alligator so you know

00:28:50,350 --> 00:29:00,050
but now this is difficult to implement

00:28:55,070 --> 00:29:03,140
in some cases and also it's probably the

00:29:00,050 --> 00:29:04,880
least performance friendly in terms of

00:29:03,140 --> 00:29:06,170
you have an object in cash and you're

00:29:04,880 --> 00:29:07,100
gonna put that at the end of the free

00:29:06,170 --> 00:29:08,060
list and then you're gonna take

00:29:07,100 --> 00:29:11,870
something from the head of the free list

00:29:08,060 --> 00:29:17,960
which is not been in cash for as long as

00:29:11,870 --> 00:29:19,610
possible but what do you see in a number

00:29:17,960 --> 00:29:21,470
of allocators actually is in deterrent

00:29:19,610 --> 00:29:24,740
what I'll call indeterminate recycling

00:29:21,470 --> 00:29:26,690
and I'm not sure that this is a great

00:29:24,740 --> 00:29:29,570
name I don't really have a better name

00:29:26,690 --> 00:29:30,980
and what I mean by this is most

00:29:29,570 --> 00:29:34,460
allocators kind of have a hybrid

00:29:30,980 --> 00:29:36,770
approach where you have a number of free

00:29:34,460 --> 00:29:39,920
lists like in malloc you'll have a free

00:29:36,770 --> 00:29:41,390
list for each page and so you have a

00:29:39,920 --> 00:29:45,560
current working page which you're gonna

00:29:41,390 --> 00:29:48,980
return objects from and that page will

00:29:45,560 --> 00:29:50,590
be fast recycle the last object put into

00:29:48,980 --> 00:29:53,210
that page is gonna be the first one out

00:29:50,590 --> 00:29:55,460
but if you free an object from a

00:29:53,210 --> 00:29:59,810
different page it's gonna get stashed

00:29:55,460 --> 00:30:02,420
away somewhere else and won't get

00:29:59,810 --> 00:30:05,150
recycled right away now the problem is

00:30:02,420 --> 00:30:06,980
this can often decay too fast recycling

00:30:05,150 --> 00:30:08,480
where you allocate something you put it

00:30:06,980 --> 00:30:10,250
back you allocate something you put it

00:30:08,480 --> 00:30:13,520
back those objects are always going to

00:30:10,250 --> 00:30:15,050
come from the current page and so then

00:30:13,520 --> 00:30:15,890
you're going to put them back in the

00:30:15,050 --> 00:30:18,050
current page and you're going to get

00:30:15,890 --> 00:30:19,340
them back from you know malloc is going

00:30:18,050 --> 00:30:24,470
to come from the current page and so

00:30:19,340 --> 00:30:28,250
back and forth and so in both userland

00:30:24,470 --> 00:30:31,580
malloc and in the kernel pool code we

00:30:28,250 --> 00:30:34,310
try to avoid this by occasionally rhe

00:30:31,580 --> 00:30:36,350
selecting a random current page and so

00:30:34,310 --> 00:30:37,850
you'll run for a while with the current

00:30:36,350 --> 00:30:40,250
page but then after every so many

00:30:37,850 --> 00:30:41,870
allocations the code will just say okay

00:30:40,250 --> 00:30:45,080
that's enough for this page we need to

00:30:41,870 --> 00:30:47,450
swap to a different page to make sure

00:30:45,080 --> 00:30:50,590
that we get a little variety and where

00:30:47,450 --> 00:30:56,060
our objects are coming from and then

00:30:50,590 --> 00:30:59,810
there's random recycling and so userland

00:30:56,060 --> 00:31:03,820
free and open BSD does this where you

00:30:59,810 --> 00:31:06,860
deliberately try to avoid

00:31:03,820 --> 00:31:09,919
deterministic order for allocating

00:31:06,860 --> 00:31:12,080
patterns and what we do is when you free

00:31:09,919 --> 00:31:15,380
an object it's not actually freed it

00:31:12,080 --> 00:31:18,260
goes into a queue of objects to be freed

00:31:15,380 --> 00:31:22,039
and then we randomly select something on

00:31:18,260 --> 00:31:24,799
that queue to be actually freed but

00:31:22,039 --> 00:31:28,580
because it's random you shuffle the

00:31:24,799 --> 00:31:30,770
order and this was at it as a security

00:31:28,580 --> 00:31:33,500
feature because it wore its efforts to

00:31:30,770 --> 00:31:34,880
create a deterministic pattern but it's

00:31:33,500 --> 00:31:42,710
also great at mixing things up in

00:31:34,880 --> 00:31:45,860
everyday programs as well on this

00:31:42,710 --> 00:31:49,850
subject I wanted to point you to the

00:31:45,860 --> 00:31:52,309
Google project zero blog this is very

00:31:49,850 --> 00:31:55,750
technical blog they write up how they

00:31:52,309 --> 00:31:59,360
exploit some current vulnerabilities to

00:31:55,750 --> 00:32:02,360
in particular are an earlier post

00:31:59,360 --> 00:32:06,820
opponent or fun bug exploiting Safari

00:32:02,360 --> 00:32:09,470
and more recent post exploiting flash

00:32:06,820 --> 00:32:12,710
both of these bugs were heap exploits

00:32:09,470 --> 00:32:15,409
and their blog posts do a great job of

00:32:12,710 --> 00:32:17,510
explaining how they arranged all the

00:32:15,409 --> 00:32:21,470
structures in memory so that their

00:32:17,510 --> 00:32:24,679
exploit work and the even if you're not

00:32:21,470 --> 00:32:27,260
an exploit developer understanding how

00:32:24,679 --> 00:32:29,450
alligators work is key to understanding

00:32:27,260 --> 00:32:32,260
how programs work and so this there's a

00:32:29,450 --> 00:32:37,240
lot of useful information in these posts

00:32:32,260 --> 00:32:37,240
for everyday developers

00:32:52,900 --> 00:33:00,500
okay so I need address a topic of kind

00:32:56,960 --> 00:33:02,030
of mostly harmless bugs and as I

00:33:00,500 --> 00:33:03,260
mentioned one of the things that you

00:33:02,030 --> 00:33:05,150
know we added an exploit mitigation

00:33:03,260 --> 00:33:08,120
technology and then it shakes out a

00:33:05,150 --> 00:33:10,100
bunch of new bugs one of the more

00:33:08,120 --> 00:33:14,150
difficult things that we integrated was

00:33:10,100 --> 00:33:16,370
a stack protector pro-police because

00:33:14,150 --> 00:33:19,790
lots of latent bugs

00:33:16,370 --> 00:33:21,530
turned up and we added that and in large

00:33:19,790 --> 00:33:24,080
part that's because it uses not only a

00:33:21,530 --> 00:33:26,300
stack cookie to protect the stack but it

00:33:24,080 --> 00:33:28,970
also rearranges stack buffers so that

00:33:26,300 --> 00:33:33,080
even small one byte overflows are going

00:33:28,970 --> 00:33:34,940
to hit the cookie and in practice this

00:33:33,080 --> 00:33:37,850
means that lots of tiny one byte

00:33:34,940 --> 00:33:40,190
overflows are detected and then we did a

00:33:37,850 --> 00:33:42,200
similar thing in malloc where we try to

00:33:40,190 --> 00:33:46,730
rearrange pointers and shuffle things

00:33:42,200 --> 00:33:49,340
around so that allocations are going to

00:33:46,730 --> 00:33:51,530
end on an unmapped page and so as soon

00:33:49,340 --> 00:33:56,240
as you overflow even by one byte your

00:33:51,530 --> 00:33:58,280
programs seg faults and unfortunately

00:33:56,240 --> 00:34:00,530
this kind of this mentality whenever a

00:33:58,280 --> 00:34:02,990
one byte overflow is found that people

00:34:00,530 --> 00:34:05,000
are like oh that's harmless then they

00:34:02,990 --> 00:34:07,760
kind of revise that - oh it's mostly

00:34:05,000 --> 00:34:12,320
harmless then well possibly harmless

00:34:07,760 --> 00:34:17,590
then okay so it's not so harmless and so

00:34:12,320 --> 00:34:20,810
I think finding these bugs in everyday

00:34:17,590 --> 00:34:22,370
running is very important because it

00:34:20,810 --> 00:34:24,919
flushes them out because you don't want

00:34:22,370 --> 00:34:26,300
somebody else to find them later and be

00:34:24,919 --> 00:34:29,840
able to exploit them and so we're trying

00:34:26,300 --> 00:34:36,100
to kind of like self exploit here for a

00:34:29,840 --> 00:34:36,100
little bit and drive out more bugs

00:34:36,370 --> 00:34:44,179
actually so another random digression

00:34:39,860 --> 00:34:48,050
here there's a option in OpenBSD to GCC

00:34:44,179 --> 00:34:50,720
call def stack shuffle as I mentioned

00:34:48,050 --> 00:34:53,120
pro-police rearranges the buffers so

00:34:50,720 --> 00:34:55,129
that a buffer that might overflow is

00:34:53,120 --> 00:34:57,290
right next to the cookie the problem is

00:34:55,129 --> 00:34:59,210
if you have a function with two buffers

00:34:57,290 --> 00:35:00,920
only one of them could be next to the

00:34:59,210 --> 00:35:03,210
cookie the other buffer is going to be

00:35:00,920 --> 00:35:05,180
next to the buffer

00:35:03,210 --> 00:35:08,400
and so you might not attack the overflow

00:35:05,180 --> 00:35:10,589
the those buffer overflows are perhaps

00:35:08,400 --> 00:35:12,990
not exploitable because you haven't

00:35:10,589 --> 00:35:16,109
overflowed to the return address on the

00:35:12,990 --> 00:35:19,349
stack but it's still a bug and we still

00:35:16,109 --> 00:35:22,529
want to catch these so the F stack

00:35:19,349 --> 00:35:23,520
shuffle randomly sorts all the buffers

00:35:22,529 --> 00:35:26,309
on the stack

00:35:23,520 --> 00:35:28,500
every time you compile the program so

00:35:26,309 --> 00:35:31,710
that they're different this is a compile

00:35:28,500 --> 00:35:33,809
time option it's not run time so you

00:35:31,710 --> 00:35:35,460
don't if you want to test a different

00:35:33,809 --> 00:35:36,930
sort option you have to recompile

00:35:35,460 --> 00:35:40,260
unfortunately it's kind of hard to

00:35:36,930 --> 00:35:44,339
generate random stack frames at run time

00:35:40,260 --> 00:35:49,200
but this as soon as we added this to the

00:35:44,339 --> 00:35:54,630
tree within I believe like one day two

00:35:49,200 --> 00:35:58,799
bugs were found but it's not on by

00:35:54,630 --> 00:36:01,799
default so okay so yeah that was the fly

00:35:58,799 --> 00:36:05,760
so I think mio did a build with this

00:36:01,799 --> 00:36:09,779
option turned on and F just broke and

00:36:05,760 --> 00:36:13,500
aldia so broke I think and so but he

00:36:09,779 --> 00:36:25,880
didn't even attempt a ports build so who

00:36:13,500 --> 00:36:28,980
knows what else is out there okay so now

00:36:25,880 --> 00:36:31,470
in practice you know there are other

00:36:28,980 --> 00:36:35,520
approaches to bug detection this static

00:36:31,470 --> 00:36:39,119
analysis of course there's being careful

00:36:35,520 --> 00:36:40,260
this code review and so what I've been

00:36:39,119 --> 00:36:42,359
talking about is kind of in a category

00:36:40,260 --> 00:36:44,640
of dynamic tooling and it's lots of

00:36:42,359 --> 00:36:46,950
options there I always like to kind of

00:36:44,640 --> 00:36:48,779
reference electric fence watch expense

00:36:46,950 --> 00:36:49,799
was you know kind of the original

00:36:48,779 --> 00:36:53,789
inspiration for a lot of the work that

00:36:49,799 --> 00:36:55,710
we've done in malloc does Val grind and

00:36:53,789 --> 00:36:59,339
the problem think a lot of these tools

00:36:55,710 --> 00:37:01,859
is you don't use them enough back in

00:36:59,339 --> 00:37:05,250
school we had purify which was

00:37:01,859 --> 00:37:08,069
phenomenal at what it does but the thing

00:37:05,250 --> 00:37:09,750
is you the bug and test your program and

00:37:08,069 --> 00:37:12,059
then like right before you submit it

00:37:09,750 --> 00:37:13,470
you'd run make purify then you'd like

00:37:12,059 --> 00:37:15,480
run the purify bill to make sure it

00:37:13,470 --> 00:37:16,980
didn't print anything out because the TA

00:37:15,480 --> 00:37:18,990
would take points off for that

00:37:16,980 --> 00:37:20,760
but you didn't run it normally and then

00:37:18,990 --> 00:37:22,260
if purify did find a bug you're like oh

00:37:20,760 --> 00:37:24,329
crap then you're like you went back but

00:37:22,260 --> 00:37:26,640
you didn't know what change triggered

00:37:24,329 --> 00:37:29,280
the purified bug because we weren't

00:37:26,640 --> 00:37:32,310
running it after every change every

00:37:29,280 --> 00:37:33,210
compile yeah that's the silly thing to

00:37:32,310 --> 00:37:35,490
do we should have been doing all the

00:37:33,210 --> 00:37:42,510
time but you know it's human nature to

00:37:35,490 --> 00:37:44,250
kind of take shortcuts and so what we've

00:37:42,510 --> 00:37:47,180
been trying to build here with open BSD

00:37:44,250 --> 00:37:58,230
is a system that's on all the time and

00:37:47,180 --> 00:38:01,500
so we catch more bugs this way here and

00:37:58,230 --> 00:38:03,599
just one final point of that is you know

00:38:01,500 --> 00:38:05,010
no matter how good your test coverage is

00:38:03,599 --> 00:38:07,740
it's never going to account for all

00:38:05,010 --> 00:38:10,020
real-world inputs and so it's really

00:38:07,740 --> 00:38:11,880
only by running code in the real world

00:38:10,020 --> 00:38:18,839
with these kinds of mechanisms in place

00:38:11,880 --> 00:38:22,500
that you detect all the bugs okay so

00:38:18,839 --> 00:38:24,859
putting this to use you know if you

00:38:22,500 --> 00:38:29,099
don't run open BSD I think you should

00:38:24,859 --> 00:38:31,470
you know and if you are a software

00:38:29,099 --> 00:38:37,140
developer you should consider adding you

00:38:31,470 --> 00:38:38,460
know open BSD to your tests farm and I

00:38:37,140 --> 00:38:40,650
think there are a lot of reasons to pick

00:38:38,460 --> 00:38:43,290
open BSD but hopefully you know it kind

00:38:40,650 --> 00:38:45,810
of giving you one more here and software

00:38:43,290 --> 00:38:48,720
that's developed on open BSD tends to

00:38:45,810 --> 00:38:51,839
work on other platforms the reverse

00:38:48,720 --> 00:38:54,300
isn't always true and I'm not talking

00:38:51,839 --> 00:38:57,300
about api's and portability I'm simply

00:38:54,300 --> 00:38:59,099
talking about correctness here and so I

00:38:57,300 --> 00:39:01,040
am you know actually unfortunately think

00:38:59,099 --> 00:39:04,050
this affects open vsts reputation

00:39:01,040 --> 00:39:05,970
somewhat negatively because people say

00:39:04,050 --> 00:39:08,849
oh hey you know this program crashes

00:39:05,970 --> 00:39:12,720
when I run it on an open BSD am an open

00:39:08,849 --> 00:39:15,619
BSD sucks you know sorry I beg to differ

00:39:12,720 --> 00:39:17,730
I think it's the program that sucks and

00:39:15,619 --> 00:39:19,290
just because the program doesn't crash

00:39:17,730 --> 00:39:20,940
when you run it on some other platform

00:39:19,290 --> 00:39:23,310
doesn't mean it can't be induced to

00:39:20,940 --> 00:39:25,260
crash you should actually try to run

00:39:23,310 --> 00:39:28,920
your programs on the platform that

00:39:25,260 --> 00:39:30,910
crashes the most if you're developing a

00:39:28,920 --> 00:39:32,470
library don't fight the operating

00:39:30,910 --> 00:39:35,500
system if you're developing an

00:39:32,470 --> 00:39:38,650
application you should be aware of how

00:39:35,500 --> 00:39:40,539
your libraries are allocating memory and

00:39:38,650 --> 00:39:42,490
how they're treating it said you can be

00:39:40,539 --> 00:39:44,530
aware of these issues and you know kind

00:39:42,490 --> 00:39:46,809
of be on guard for what kind of latent

00:39:44,530 --> 00:39:48,630
bugs you might be introducing on what

00:39:46,809 --> 00:39:50,619
kind of assumptions you're making

00:39:48,630 --> 00:39:55,869
implicitly based on your library's

00:39:50,619 --> 00:39:59,619
behavior fast recycling is very common

00:39:55,869 --> 00:40:03,130
in custom allocators and caches and it

00:39:59,619 --> 00:40:06,460
hides lots of bugs so to pick on one

00:40:03,130 --> 00:40:09,369
example another music developer told me

00:40:06,460 --> 00:40:12,520
they patched the apache portable runtime

00:40:09,369 --> 00:40:15,400
which has a pool allocator they changed

00:40:12,520 --> 00:40:18,220
it to just pass through directly to open

00:40:15,400 --> 00:40:26,339
BSD malloc and free and subversion

00:40:18,220 --> 00:40:26,339
stopped working so there was a buck next

00:40:28,829 --> 00:40:35,319
so we have the assertions so usually I

00:40:33,789 --> 00:40:38,740
think people this is kind of a more

00:40:35,319 --> 00:40:40,750
general development technique but we add

00:40:38,740 --> 00:40:42,039
assertions to you know say hey this has

00:40:40,750 --> 00:40:44,049
to happen or you know make sure this

00:40:42,039 --> 00:40:45,520
didn't happen but there's another thing

00:40:44,049 --> 00:40:48,819
that you can do with assertions which is

00:40:45,520 --> 00:40:51,520
you can say well this can happen excuse

00:40:48,819 --> 00:40:54,369
me and so let's make it happen

00:40:51,520 --> 00:40:57,220
we did this in the open BSD kernel where

00:40:54,369 --> 00:40:58,660
you can call pool or malloc with a flag

00:40:57,220 --> 00:41:00,730
that says wait okay

00:40:58,660 --> 00:41:02,680
and so when you indicate this flag it

00:41:00,730 --> 00:41:04,869
means that you can go to sleep waiting

00:41:02,680 --> 00:41:08,170
for resources and then wake up sometime

00:41:04,869 --> 00:41:10,029
later so I made a change where when you

00:41:08,170 --> 00:41:13,550
pass that flag instead of being able to

00:41:10,029 --> 00:41:14,920
sleep you always sleep and boom

00:41:13,550 --> 00:41:20,109
[Music]

00:41:14,920 --> 00:41:23,440
NFS broke pee trace broke the UVM cam

00:41:20,109 --> 00:41:24,700
thread allocator broke like everything

00:41:23,440 --> 00:41:26,920
there were race conditions everywhere

00:41:24,700 --> 00:41:28,740
where people were assuming that these

00:41:26,920 --> 00:41:31,029
calls to malloc were going to be atomic

00:41:28,740 --> 00:41:32,680
even though they were saying hey this is

00:41:31,029 --> 00:41:35,589
safe it's you know you can sleep I'm

00:41:32,680 --> 00:41:39,099
aware of my state but it turns out none

00:41:35,589 --> 00:41:45,009
of them were and so there were you know

00:41:39,099 --> 00:41:47,049
this is just a an example that if you

00:41:45,009 --> 00:41:49,089
you know general principle if something

00:41:47,049 --> 00:41:51,220
if if you can do something make it

00:41:49,089 --> 00:41:54,279
happen or if you don't have to do

00:41:51,220 --> 00:42:01,569
something don't ever do it and then see

00:41:54,279 --> 00:42:07,210
what happens here

00:42:01,569 --> 00:42:08,769
so randomization along those lines if

00:42:07,210 --> 00:42:11,499
something can be random make it random

00:42:08,769 --> 00:42:14,200
this is good for security but also good

00:42:11,499 --> 00:42:17,529
for development I have a funny story

00:42:14,200 --> 00:42:20,619
about a long time ago there was a bug

00:42:17,529 --> 00:42:23,039
and liberar thread which shortly after

00:42:20,619 --> 00:42:28,109
we switched to live our thread and

00:42:23,039 --> 00:42:30,900
released it somebody noticed a crash and

00:42:28,109 --> 00:42:33,849
this is kind of technical but the

00:42:30,900 --> 00:42:35,680
highlights are there is a Reaper

00:42:33,849 --> 00:42:38,680
function which would garbage collect

00:42:35,680 --> 00:42:41,799
stacks that were no longer in use but it

00:42:38,680 --> 00:42:44,309
did this by determining which threads

00:42:41,799 --> 00:42:48,519
had exited based on their pit

00:42:44,309 --> 00:42:50,440
unfortunately there was a race where a

00:42:48,519 --> 00:42:52,029
thread could exit and then a new thread

00:42:50,440 --> 00:42:54,279
could be created with the same pit as

00:42:52,029 --> 00:42:58,710
the exited pit and then the Reaper will

00:42:54,279 --> 00:42:58,710
delete the stack of the new thread and

00:42:58,890 --> 00:43:04,660
so that caused the program to crash this

00:43:01,960 --> 00:43:06,099
was noticed by a user

00:43:04,660 --> 00:43:07,660
he's sending the bug report with a stack

00:43:06,099 --> 00:43:10,390
trace and I was like hey that looks like

00:43:07,660 --> 00:43:12,569
you're deleting a stack of a newly

00:43:10,390 --> 00:43:15,219
created thread I wonder what happened

00:43:12,569 --> 00:43:18,009
wrote a short test case which just

00:43:15,219 --> 00:43:19,450
created and deleted a whole bunch of

00:43:18,009 --> 00:43:21,190
threads and kind of interleaved them a

00:43:19,450 --> 00:43:23,259
little bit and was able to have a

00:43:21,190 --> 00:43:25,839
reproducible test case in a matter of

00:43:23,259 --> 00:43:28,539
minutes this is the kind of bug that

00:43:25,839 --> 00:43:30,999
would have gone undetected probably for

00:43:28,539 --> 00:43:33,969
years if we had used sequential pidz

00:43:30,999 --> 00:43:37,269
because the probability of reusing a

00:43:33,969 --> 00:43:39,940
pid' if you're strictly you know cycling

00:43:37,269 --> 00:43:41,799
around is actually very very low however

00:43:39,940 --> 00:43:43,839
that doesn't mean it can't happen so

00:43:41,799 --> 00:43:45,369
what would have happened is somebody

00:43:43,839 --> 00:43:48,099
would have some box with like four years

00:43:45,369 --> 00:43:50,589
of uptime and some like massive Java you

00:43:48,099 --> 00:43:52,509
know process that had been running and

00:43:50,589 --> 00:43:54,430
running for years and years and they

00:43:52,509 --> 00:43:55,529
would hit this race condition right at

00:43:54,430 --> 00:43:56,980
the instant when pids

00:43:55,529 --> 00:44:00,820
happened to roll

00:43:56,980 --> 00:44:02,859
/ then there you know billion dollar

00:44:00,820 --> 00:44:04,240
Java process is gonna crash and they're

00:44:02,859 --> 00:44:06,700
gonna be very sad and it's gonna be

00:44:04,240 --> 00:44:08,109
impossible to debug because we won't be

00:44:06,700 --> 00:44:12,450
able to reproduce it for another four

00:44:08,109 --> 00:44:15,850
years and nobody's gonna care and so

00:44:12,450 --> 00:44:19,869
ironically a feature that was designed

00:44:15,850 --> 00:44:22,210
to prevent race conditions by reducing

00:44:19,869 --> 00:44:25,570
the predictability of pids actually

00:44:22,210 --> 00:44:29,380
helped create a race condition and make

00:44:25,570 --> 00:44:32,020
it more easy to well exploit actually

00:44:29,380 --> 00:44:33,640
and so then by exploiting this race

00:44:32,020 --> 00:44:38,580
condition in Lib our thread we were able

00:44:33,640 --> 00:44:44,170
to fix the bug there was another bug in

00:44:38,580 --> 00:44:48,160
this is hysterical in hibernate that

00:44:44,170 --> 00:44:50,230
Mike found where for a long time the

00:44:48,160 --> 00:44:52,900
stack protector cookie in the kernel was

00:44:50,230 --> 00:44:54,340
a fixed value because you can't there

00:44:52,900 --> 00:44:56,020
was nowhere to get a random value for

00:44:54,340 --> 00:44:58,869
the stack cookie from by the time the

00:44:56,020 --> 00:45:00,580
random sub system was up and running you

00:44:58,869 --> 00:45:02,859
had already kind of been running for too

00:45:00,580 --> 00:45:05,230
long to use a random value for the stack

00:45:02,859 --> 00:45:07,390
cookie and so it's a fixed value of like

00:45:05,230 --> 00:45:08,440
a null byte and a carriage return and

00:45:07,390 --> 00:45:13,810
some other stuff you know to make it

00:45:08,440 --> 00:45:15,100
hard to stuff into a string but we made

00:45:13,810 --> 00:45:17,500
a change to the bootloader

00:45:15,100 --> 00:45:20,619
where now the bootloader can inject a

00:45:17,500 --> 00:45:23,950
random stack cookie and the way

00:45:20,619 --> 00:45:26,530
hibernate works is you boot one kernel

00:45:23,950 --> 00:45:29,380
and then it loads the old running image

00:45:26,530 --> 00:45:32,560
from swap and copies it over itself and

00:45:29,380 --> 00:45:33,250
then keeps running but the problem is it

00:45:32,560 --> 00:45:36,040
did this

00:45:33,250 --> 00:45:39,850
it changed the stack cookie from the one

00:45:36,040 --> 00:45:42,040
on the running kernel to the stack

00:45:39,850 --> 00:45:44,980
cookie from the previously running

00:45:42,040 --> 00:45:48,369
cookie but it didn't change its own

00:45:44,980 --> 00:45:50,290
stack and so then when it returned the

00:45:48,369 --> 00:45:53,980
stack cookie didn't match what it should

00:45:50,290 --> 00:45:56,020
have been and the kernel panicked and so

00:45:53,980 --> 00:45:57,850
this is just kind of the bug I think was

00:45:56,020 --> 00:46:00,340
that we were running on the wrong stack

00:45:57,850 --> 00:46:03,880
for too long and we should have switched

00:46:00,340 --> 00:46:05,590
to a stack on the new kernel or the old

00:46:03,880 --> 00:46:09,100
colonel and I did every it's kind of

00:46:05,590 --> 00:46:10,690
confusing but you know just you know

00:46:09,100 --> 00:46:13,060
more or less stories we

00:46:10,690 --> 00:46:15,720
changed some of the conditions that the

00:46:13,060 --> 00:46:17,740
colonel was operating in and this

00:46:15,720 --> 00:46:20,380
challenge some of the assumptions that

00:46:17,740 --> 00:46:22,720
the code running had been using and a

00:46:20,380 --> 00:46:24,370
bug was found you know and again it was

00:46:22,720 --> 00:46:25,900
a case where the bug was harmless but

00:46:24,370 --> 00:46:26,770
probably would have been flushed out

00:46:25,900 --> 00:46:29,710
sooner or later

00:46:26,770 --> 00:46:32,110
by some other change but this particular

00:46:29,710 --> 00:46:35,680
change brought it to light sooner and so

00:46:32,110 --> 00:46:43,090
that's what made it a good change and I

00:46:35,680 --> 00:46:45,240
think the next slide says QA yes I'm

00:46:43,090 --> 00:46:45,240
done

00:46:46,100 --> 00:46:56,880
[Applause]

00:46:53,280 --> 00:46:56,880
any questions

00:47:00,360 --> 00:47:04,180
have you considered making greed and

00:47:03,190 --> 00:47:08,080
wipes his calls

00:47:04,180 --> 00:47:11,050
Anthony returned I enter randomly

00:47:08,080 --> 00:47:14,410
returning II inter we were talking about

00:47:11,050 --> 00:47:19,270
this at dinner last night for some other

00:47:14,410 --> 00:47:23,080
system calls actually but yes

00:47:19,270 --> 00:47:25,540
I think there is some work there and

00:47:23,080 --> 00:47:26,800
actually I'm you know if you you know

00:47:25,540 --> 00:47:31,150
probably some of you always have heard

00:47:26,800 --> 00:47:32,500
about the Netflix chaos monkey thing

00:47:31,150 --> 00:47:34,270
where that just goes around and kills

00:47:32,500 --> 00:47:37,060
random processes in their distributed

00:47:34,270 --> 00:47:39,640
system and that proves that their load

00:47:37,060 --> 00:47:41,230
balancing and you know redundancy is

00:47:39,640 --> 00:47:43,120
working correctly and the only way to

00:47:41,230 --> 00:47:45,580
test that is to actually you know pull

00:47:43,120 --> 00:47:47,260
the plug and kill random processes I

00:47:45,580 --> 00:47:49,030
think that's a little aggressive to

00:47:47,260 --> 00:47:53,080
actually you know be running on your

00:47:49,030 --> 00:47:55,810
desktop and so we're trying to kind of

00:47:53,080 --> 00:48:01,800
stay within the bounds of make things a

00:47:55,810 --> 00:48:05,280
little challenging but yeah I think the

00:48:01,800 --> 00:48:07,600
rate of progress here is hampered by

00:48:05,280 --> 00:48:10,750
maintaining some degree of system

00:48:07,600 --> 00:48:18,540
stability and being able to run software

00:48:10,750 --> 00:48:18,540
that we want to run any other questions

00:48:18,760 --> 00:48:25,849
all right let's thank our speaker

00:48:21,760 --> 00:48:25,849

YouTube URL: https://www.youtube.com/watch?v=_q8zzWHj15Q


