Title: Fuzzing the kernel by Andrew Turner
Publication date: 2019-10-21
Playlist: EuroBSDCon 2019, Norway
Description: 
	Fuzzing the kernel

Modern C compilers include support for tools to help find bugs in code. These tools, the sanitizers, add instrumentation to the generated code that can be compiled into the kernel to help the kernel developers. In early 2018 I became interested in using these in the FreeBSD kernel to assist bug finding and debugging.

This talk will discuss the current state of kernel sanitizers on FreeBSD. This will include the kernel coverage sanitizer that can be used with fuzzers, the undefined behaviour sanitizer to warn when code relies on undefined behaviour, and the address sanitizer to detect out of bounds accesses. It will also discuss future work to port new sanitizers and the use hardware based acceleration.

The main fuzzer to use these sanitizers is the syzkaller fuzzer from Google. I will talk about my experiences using this, bugs it has found, and future work to port other fuzzers to work with the kernel.

More Info:
https://2019.eurobsdcon.org/talk-speakers/#fuzzing
Captions: 
	00:00:04,210 --> 00:00:11,650
welcome everyone back from lunch I hope

00:00:07,660 --> 00:00:14,290
you still have some mental capacity to

00:00:11,650 --> 00:00:16,510
follow a couple of more thoughts please

00:00:14,290 --> 00:00:22,769
welcome Andrew Turner he's going to talk

00:00:16,510 --> 00:00:22,769
about fuzzing FreeBSD obviously sorry

00:00:23,550 --> 00:00:27,210
that's why come on

00:00:25,500 --> 00:00:31,239
[Applause]

00:00:27,210 --> 00:00:34,960
ok so I'm going to talk about well I say

00:00:31,239 --> 00:00:36,820
that Kuno bet I won't I am a FreeBSD

00:00:34,960 --> 00:00:39,550
commit that I'm not just going to talk

00:00:36,820 --> 00:00:45,300
about FreeBSD I will I have looked at

00:00:39,550 --> 00:00:45,300
the state on FreeBSD NetBSD and OpenBSD

00:00:46,590 --> 00:00:54,070
so myself I'm a Phoebe I said I'm a

00:00:51,339 --> 00:00:55,929
FreeBSD committer you may have

00:00:54,070 --> 00:01:00,670
previously previously seen me doing

00:00:55,929 --> 00:01:02,949
things like I'm 64 supports and I'm a

00:01:00,670 --> 00:01:05,409
research associate in the University of

00:01:02,949 --> 00:01:07,930
Cambridge so if you were in books of

00:01:05,409 --> 00:01:12,940
talk this morning on sherry ABI I work

00:01:07,930 --> 00:01:14,890
on the same project we're doing trying

00:01:12,940 --> 00:01:16,720
to add more security by the folks into

00:01:14,890 --> 00:01:20,100
hardware in their fall into your

00:01:16,720 --> 00:01:22,720
software and sometimes I pretend to be a

00:01:20,100 --> 00:01:28,150
freelance software engineer if people

00:01:22,720 --> 00:01:30,400
feel like paying me money so I'm gonna

00:01:28,150 --> 00:01:32,620
start off with talking about the

00:01:30,400 --> 00:01:34,830
sanitizers so even though I store

00:01:32,620 --> 00:01:38,080
concerned I see those on fuzzing it's

00:01:34,830 --> 00:01:40,560
sanitized without it the synthesizers

00:01:38,080 --> 00:01:44,620
are useful because forth fuzzing and as

00:01:40,560 --> 00:01:47,520
sort of explained and Athena ties as I

00:01:44,620 --> 00:01:50,380
want to say well you've got some code

00:01:47,520 --> 00:01:52,930
but do you know we've got the quality of

00:01:50,380 --> 00:01:54,420
your code ibi you've we've got this big

00:01:52,930 --> 00:01:56,800
piece of code we called the kernel

00:01:54,420 --> 00:02:00,240
there's lots of different parts of it

00:01:56,800 --> 00:02:03,670
what what's the quality is it is it the

00:02:00,240 --> 00:02:08,110
mini buffer overflows leading to somehow

00:02:03,670 --> 00:02:09,970
somehow exploiting the system the we

00:02:08,110 --> 00:02:12,629
accidentally leaking memory and

00:02:09,970 --> 00:02:15,719
therefore leaking some some informations

00:02:12,629 --> 00:02:17,939
a user shouldn't get extra Stewie you

00:02:15,719 --> 00:02:23,040
know what do we know do we have a way of

00:02:17,939 --> 00:02:24,390
figuring this out so the same size is

00:02:23,040 --> 00:02:26,719
what the hell they were you know they

00:02:24,390 --> 00:02:30,030
just you can think of it as

00:02:26,719 --> 00:02:32,790
instrumentation of your code in some way

00:02:30,030 --> 00:02:35,120
yes they're all it's generally the

00:02:32,790 --> 00:02:38,129
compiler will be doing this we inserting

00:02:35,120 --> 00:02:40,019
a function called somewhere in the code

00:02:38,129 --> 00:02:43,530
depending on the sanitizer

00:02:40,019 --> 00:02:45,359
so these some that could say if you're

00:02:43,530 --> 00:02:48,030
entering into a basic block at Warren's

00:02:45,359 --> 00:02:50,459
in so it's a function called year some

00:02:48,030 --> 00:02:52,560
will if you're doing a comparison to see

00:02:50,459 --> 00:02:55,980
what you what mean we you're comparing

00:02:52,560 --> 00:03:01,079
or if you were doing a load or store it

00:02:55,980 --> 00:03:03,599
will enter in and I mean exactly what we

00:03:01,079 --> 00:03:07,620
do with it is the what these at one time

00:03:03,599 --> 00:03:11,970
they will handle with us and use user

00:03:07,620 --> 00:03:15,269
space they cling or GCC will provide you

00:03:11,970 --> 00:03:16,799
a runtime hopefully not so much in the

00:03:15,269 --> 00:03:19,470
kernel we have to we have to do this

00:03:16,799 --> 00:03:25,079
ourselves because it's just always a

00:03:19,470 --> 00:03:29,359
special environment yeah undefined

00:03:25,079 --> 00:03:29,359
behaviour oh it's a favorite too

00:03:29,639 --> 00:03:35,669
so he uses place undefined behavior

00:03:32,699 --> 00:03:37,139
sensitizer and so you couldn't

00:03:35,669 --> 00:03:42,120
equivalents which always usually starts

00:03:37,139 --> 00:03:43,919
with a K it's much of mini there was

00:03:42,120 --> 00:03:46,260
often defined baby we can may be able to

00:03:43,919 --> 00:03:48,299
do detected in the compile time but a

00:03:46,260 --> 00:03:52,889
lot of it there's only one time

00:03:48,299 --> 00:03:57,810
detective all things like misaligned or

00:03:52,889 --> 00:03:59,699
null pointer dereference so you use i

00:03:57,810 --> 00:04:01,709
saw the fans actually went into the

00:03:59,699 --> 00:04:04,379
sweet sunny where you accidentally get

00:04:01,709 --> 00:04:06,060
given a null pointer somehow and you

00:04:04,379 --> 00:04:08,669
can't possibly detect this because it

00:04:06,060 --> 00:04:11,250
comes from user space and you're just

00:04:08,669 --> 00:04:15,030
missing and no pointer cheek or you may

00:04:11,250 --> 00:04:18,120
be shifting by a variable amount and

00:04:15,030 --> 00:04:20,760
they're very maybe 64 and roy and a

00:04:18,120 --> 00:04:26,130
32-bit at and which is well west side of

00:04:20,760 --> 00:04:29,970
his range thanks to new bsd we have the

00:04:26,130 --> 00:04:34,980
might vary you be saying van time which

00:04:29,970 --> 00:04:39,180
I have I imported the previous Sony PSD

00:04:34,980 --> 00:04:42,960
is committed it over you ago you and I

00:04:39,180 --> 00:04:46,070
imported it late last year in the open B

00:04:42,960 --> 00:04:51,510
Steve has done to the same this year

00:04:46,070 --> 00:04:54,140
you do get some issues though I can't

00:04:51,510 --> 00:04:57,030
Beweave it big but I'll show you so here

00:04:54,140 --> 00:05:04,680
were three examples I found in the in

00:04:57,030 --> 00:05:08,430
FreeBSD you can yeah trying to trying to

00:05:04,680 --> 00:05:11,640
alignment if you use often it's often

00:05:08,430 --> 00:05:13,440
there a case we are the compiler may

00:05:11,640 --> 00:05:15,030
actually deceive you soon you've sold it

00:05:13,440 --> 00:05:16,830
it's going to be hundred twenty-eight by

00:05:15,030 --> 00:05:20,550
the lines and then you give a 64-byte

00:05:16,830 --> 00:05:22,230
aligned thing I've seen plenty of mini

00:05:20,550 --> 00:05:23,490
cases we have that happens and in

00:05:22,230 --> 00:05:26,580
suddenly you're reading the wrong thing

00:05:23,490 --> 00:05:31,620
and you could easily turn this into a

00:05:26,580 --> 00:05:34,920
security vulnerability no there's no

00:05:31,620 --> 00:05:38,130
point to do refunds as actually this is

00:05:34,920 --> 00:05:42,230
using trying to find the off seat of a

00:05:38,130 --> 00:05:45,180
value inside a strat by taking the strut

00:05:42,230 --> 00:05:48,810
casting now to this tot the type and

00:05:45,180 --> 00:05:52,800
then finding the address of the eye to

00:05:48,810 --> 00:05:56,340
the entry you want the physics is now I

00:05:52,800 --> 00:05:59,850
think claim definitely has a way of what

00:05:56,340 --> 00:06:03,420
doing this I think I speak GCC we have

00:05:59,850 --> 00:06:07,740
the same way don't just cast now to a

00:06:03,420 --> 00:06:09,810
strut please anymore and if we things

00:06:07,740 --> 00:06:13,830
like chip South about so this is all

00:06:09,810 --> 00:06:15,960
things that you can't assume you know

00:06:13,830 --> 00:06:17,550
the compiler will can make students umph

00:06:15,960 --> 00:06:24,990
shins that you don't want to ever do

00:06:17,550 --> 00:06:26,190
these and if you do the compiler could

00:06:24,990 --> 00:06:32,550
do anything if you am hitter

00:06:26,190 --> 00:06:35,390
and I'm behavior almost it could don't

00:06:32,550 --> 00:06:38,760
require don't rely on undefined behavior

00:06:35,390 --> 00:06:42,090
either not changing across

00:06:38,760 --> 00:06:45,360
I compiled versions compiling you know

00:06:42,090 --> 00:06:46,830
two different compilers GC sync saying

00:06:45,360 --> 00:06:50,460
we'll probably do something different

00:06:46,830 --> 00:06:53,310
with you undefined behavior playing

00:06:50,460 --> 00:06:58,740
eight and nine babe could do something

00:06:53,310 --> 00:07:02,490
because there was examples of new hello

00:06:58,740 --> 00:07:05,670
playing nine will now if effort can show

00:07:02,490 --> 00:07:07,080
that a view of all is Const in your in

00:07:05,670 --> 00:07:08,610
your writing to it it can say all that

00:07:07,080 --> 00:07:13,110
can't possibly happen it will just drop

00:07:08,610 --> 00:07:16,440
it they'd store in some cases so you

00:07:13,110 --> 00:07:18,240
don't if you can for you yeah

00:07:16,440 --> 00:07:21,620
don't align for hindfoot don't try to

00:07:18,240 --> 00:07:21,620
remove undefined behavior if you can

00:07:22,460 --> 00:07:26,940
okay so that wouldn't that was sort of

00:07:24,690 --> 00:07:31,260
the easy one that was Libya's theater

00:07:26,940 --> 00:07:32,820
that there are some issues with we

00:07:31,260 --> 00:07:34,260
haven't enabled that we can delete favor

00:07:32,820 --> 00:07:36,120
we divide default because it blows the

00:07:34,260 --> 00:07:40,410
kernel size but it's possible to build

00:07:36,120 --> 00:07:44,060
Kunal's it will work but the secret one

00:07:40,410 --> 00:07:46,920
is is there's a coverage sanitizer so

00:07:44,060 --> 00:07:50,310
when the compiler you're when you are

00:07:46,920 --> 00:07:52,350
running your code what how does you what

00:07:50,310 --> 00:07:54,300
you run a system call with is with is

00:07:52,350 --> 00:07:57,510
the and car you know what pads

00:07:54,300 --> 00:08:02,880
through your code does it take so it

00:07:57,510 --> 00:08:05,810
will use its traces into into the

00:08:02,880 --> 00:08:09,480
compiled until your codes to say I've

00:08:05,810 --> 00:08:12,630
entered into a new function or I am now

00:08:09,480 --> 00:08:14,790
running this if statement and here is

00:08:12,630 --> 00:08:17,010
the two values that you're comparing in

00:08:14,790 --> 00:08:22,710
some information about that about what

00:08:17,010 --> 00:08:24,000
side what would so this comparison is so

00:08:22,710 --> 00:08:31,260
it could be this one is actually very

00:08:24,000 --> 00:08:34,530
powerful and it's all three - BSD

00:08:31,260 --> 00:08:38,300
FreeBSD NetBSD have evidence support for

00:08:34,530 --> 00:08:40,890
this which we'll see later exactly why

00:08:38,300 --> 00:08:47,190
so you know Dave this is this has been

00:08:40,890 --> 00:08:50,670
done the I the FreeBSD code originally

00:08:47,190 --> 00:08:51,460
started as a co-op student they hid

00:08:50,670 --> 00:08:54,340
mastheads

00:08:51,460 --> 00:08:58,210
and then I took oh I took the kite and

00:08:54,340 --> 00:09:03,310
we've done this a bit more and got I

00:08:58,210 --> 00:09:07,240
mean get committed so it will do things

00:09:03,310 --> 00:09:12,310
like this so we have a buffer we we we

00:09:07,240 --> 00:09:14,230
ask the kunafa buffer and we starts off

00:09:12,310 --> 00:09:16,210
with just the you know the number of

00:09:14,230 --> 00:09:18,070
entries in the buffer the number of

00:09:16,210 --> 00:09:20,560
other din trees in the buffer in just

00:09:18,070 --> 00:09:22,660
the list of basic blocks that's gone to

00:09:20,560 --> 00:09:25,390
your program Kansas for inside basic

00:09:22,660 --> 00:09:27,730
block the actual you can just imagine it

00:09:25,390 --> 00:09:29,560
doesn't have to be an actual PC value it

00:09:27,730 --> 00:09:32,020
could be it just has to be something

00:09:29,560 --> 00:09:38,530
unique in each each plate at location

00:09:32,020 --> 00:09:41,820
def F a at all continues freebsd netbsd

00:09:38,530 --> 00:09:44,290
both these are all 64-bit open BSD it's

00:09:41,820 --> 00:09:46,690
working for you and pointer tears so it

00:09:44,290 --> 00:09:49,050
could be so 64 bits on the 64 bit

00:09:46,690 --> 00:09:49,050
architecture

00:09:50,430 --> 00:09:54,520
yes probably the just normally it's just

00:09:53,080 --> 00:09:57,280
the between address of the function

00:09:54,520 --> 00:10:01,260
that's the exact value doesn't actually

00:09:57,280 --> 00:10:04,120
matter that much as long as doing unique

00:10:01,260 --> 00:10:07,990
so this is good for if you wanted to

00:10:04,120 --> 00:10:11,230
find out just how you're just just what

00:10:07,990 --> 00:10:13,690
path you you talk through the code but

00:10:11,230 --> 00:10:15,700
then these some issues of well okay do I

00:10:13,690 --> 00:10:17,710
want to even try a different path

00:10:15,700 --> 00:10:21,430
through the code how do I modify my

00:10:17,710 --> 00:10:23,380
input to figure this out well did

00:10:21,430 --> 00:10:27,070
probably do some if statements in the

00:10:23,380 --> 00:10:30,430
year but we don't know we're he just

00:10:27,070 --> 00:10:34,600
addresses that may may be related to the

00:10:30,430 --> 00:10:37,630
if statement so we have this comparison

00:10:34,600 --> 00:10:42,460
trace which is a this one's the Rees

00:10:37,630 --> 00:10:44,230
fall for for fuzzing we are we have the

00:10:42,460 --> 00:10:47,350
same thing we have a number of entries

00:10:44,230 --> 00:10:48,580
the exact name the number of each piece

00:10:47,350 --> 00:10:51,720
is slightly different in this and this

00:10:48,580 --> 00:10:57,370
number of these different groups of

00:10:51,720 --> 00:11:00,310
Faddis we can see and say well we now

00:10:57,370 --> 00:11:03,430
know okay so to means I don't know

00:11:00,310 --> 00:11:05,610
exactly like a eight bytes comparison

00:11:03,430 --> 00:11:10,390
for example

00:11:05,610 --> 00:11:15,130
and it might be you know the two values

00:11:10,390 --> 00:11:17,350
that they're comparing so 16x20 and the

00:11:15,130 --> 00:11:19,960
address this comparison approximately

00:11:17,350 --> 00:11:22,570
address the other value for where the

00:11:19,960 --> 00:11:26,260
comparison was and then you have a

00:11:22,570 --> 00:11:28,510
second comparison later so you could

00:11:26,260 --> 00:11:30,459
imagine if we've got some input of an

00:11:28,510 --> 00:11:34,420
input data we've we were passing in and

00:11:30,459 --> 00:11:36,430
then we see it in here and it was Phi

00:11:34,420 --> 00:11:38,950
over to comparison maybe if we change it

00:11:36,430 --> 00:11:40,570
would could if we change it could we try

00:11:38,950 --> 00:11:43,570
finding a new path through the kernel

00:11:40,570 --> 00:11:48,850
so that would would mean that comparison

00:11:43,570 --> 00:11:50,740
actually succeeds so this is just you

00:11:48,850 --> 00:11:53,130
know this is you know finding parts we

00:11:50,740 --> 00:11:57,580
know it's not necessarily going to find

00:11:53,130 --> 00:11:59,770
effect that you've got a buffer overflow

00:11:57,580 --> 00:12:02,770
anything I would just say here's how you

00:11:59,770 --> 00:12:04,209
got he's here to help you find here's

00:12:02,770 --> 00:12:11,410
how to get to the battle overflow not

00:12:04,209 --> 00:12:13,750
actually you have a buffalo and soak a

00:12:11,410 --> 00:12:15,820
cake offers the you can think of this as

00:12:13,750 --> 00:12:18,310
the interface that's you have a device

00:12:15,820 --> 00:12:22,870
somewhere and there's less information

00:12:18,310 --> 00:12:24,670
there has entered is been put into a

00:12:22,870 --> 00:12:27,339
shared buffer he's da cunha win user

00:12:24,670 --> 00:12:30,400
space so that such that as a user space

00:12:27,339 --> 00:12:33,250
program i can in read it in doing more

00:12:30,400 --> 00:12:38,410
information about the point they the

00:12:33,250 --> 00:12:41,740
system cause I've executed is these

00:12:38,410 --> 00:12:45,089
alternative interfaces we are a FL which

00:12:41,740 --> 00:12:48,700
is maybe the American fuzzy lop buzzer

00:12:45,089 --> 00:12:53,200
and est there was a talk just now event

00:12:48,700 --> 00:12:58,630
for me BST about peer support for it I

00:12:53,200 --> 00:13:01,170
also have pictures for a FreeBSD so it

00:12:58,630 --> 00:13:06,910
adds support to take off at least you

00:13:01,170 --> 00:13:08,260
extract the relevant information but you

00:13:06,910 --> 00:13:11,350
know I've also got picture than your

00:13:08,260 --> 00:13:12,730
wave we can say well if you've got in a

00:13:11,350 --> 00:13:14,260
completely different idea of how else we

00:13:12,730 --> 00:13:16,930
work I wouldn't you do that as well and

00:13:14,260 --> 00:13:20,050
then I've split out the actual

00:13:16,930 --> 00:13:22,360
sanitize that from the interface so we

00:13:20,050 --> 00:13:25,510
could have intervened faces so if anyone

00:13:22,360 --> 00:13:28,450
has any ideas of what you'd want to do

00:13:25,510 --> 00:13:32,440
with runtime information about every

00:13:28,450 --> 00:13:33,820
possible comparison and kernel let me

00:13:32,440 --> 00:13:35,260
know I'm sure we can come up with a

00:13:33,820 --> 00:13:39,630
module that will give you this

00:13:35,260 --> 00:13:42,630
information break the Kuna even more

00:13:39,630 --> 00:13:42,630
yeah

00:13:44,350 --> 00:13:49,690
so those losers hood you know there are

00:13:47,350 --> 00:13:50,680
two nice ones to have but these are the

00:13:49,690 --> 00:13:51,760
ones that were actually break you

00:13:50,680 --> 00:13:55,890
couldn't knew these are the ones that

00:13:51,760 --> 00:13:58,420
will find tell you you were doing these

00:13:55,890 --> 00:14:03,630
beautiful security vulnerabilities so

00:13:58,420 --> 00:14:03,630
Idris the Jewish space sanitizer is

00:14:03,960 --> 00:14:13,690
cheap Mimi so memory accesses I are you

00:14:09,760 --> 00:14:17,620
I give you a pointer you can say it's a

00:14:13,690 --> 00:14:20,650
it's a ever I say and I'll give you a

00:14:17,620 --> 00:14:23,200
links what happens if I use the link

00:14:20,650 --> 00:14:26,740
isn't quite right and then you try to

00:14:23,200 --> 00:14:28,570
read it or you've got a bag for you

00:14:26,740 --> 00:14:29,850
actually read one past the links or

00:14:28,570 --> 00:14:32,320
something similar

00:14:29,850 --> 00:14:35,080
the idea was recent they just my

00:14:32,320 --> 00:14:41,890
sanitizer is it will catch this sort of

00:14:35,080 --> 00:14:45,100
thing and it will help try and help you

00:14:41,890 --> 00:14:51,339
find small buffer overflows not you know

00:14:45,100 --> 00:14:54,940
in the in the range of eight bytes sort

00:14:51,339 --> 00:14:57,100
of area so it's it's not as going to get

00:14:54,940 --> 00:14:58,570
you there are off by one errors you may

00:14:57,100 --> 00:15:01,300
find a way this is really help you with

00:14:58,570 --> 00:15:04,570
a very large you will somehow manage to

00:15:01,300 --> 00:15:09,160
cross your pointer you know odd ways

00:15:04,570 --> 00:15:11,410
yeah but that will find so the way it

00:15:09,160 --> 00:15:16,660
works is it will it will it's got a

00:15:11,410 --> 00:15:18,970
shadow map so if we eight bytes of

00:15:16,660 --> 00:15:23,260
wintry space you have an extra bite of

00:15:18,970 --> 00:15:28,590
the shadow map and then we mark one by

00:15:23,260 --> 00:15:31,920
what we marks zero to eight bytes of day

00:15:28,590 --> 00:15:37,220
there's buffer this these eight bytes is

00:15:31,920 --> 00:15:41,010
valid and so if we load and store using

00:15:37,220 --> 00:15:43,140
hevachick to say is this void going to

00:15:41,010 --> 00:15:48,089
as if we bite in the state of store

00:15:43,140 --> 00:15:51,330
valid they has to be the first zero two

00:15:48,089 --> 00:15:53,460
eight bytes and they they must be

00:15:51,330 --> 00:15:57,540
contiguous they can't you can't say I

00:15:53,460 --> 00:16:00,240
want the first third and seventh bytes

00:15:57,540 --> 00:16:03,120
it's not going to work just because of

00:16:00,240 --> 00:16:08,310
the way the format works and you can

00:16:03,120 --> 00:16:10,800
also mark when you mocking me me is

00:16:08,310 --> 00:16:12,930
invalid you can you can we got specific

00:16:10,800 --> 00:16:16,230
values that will say this is valid

00:16:12,930 --> 00:16:18,060
because it was a free that's been freed

00:16:16,230 --> 00:16:20,700
memory and so we know it's a use after

00:16:18,060 --> 00:16:23,190
free or it is the buff the pitting that

00:16:20,700 --> 00:16:26,190
you have to malloc so it's a buffer

00:16:23,190 --> 00:16:28,260
overflow on the Millat buffer or these

00:16:26,190 --> 00:16:30,390
or this is used

00:16:28,260 --> 00:16:33,600
it says pending between two veggies on

00:16:30,390 --> 00:16:35,280
the stick so and it's in its the top of

00:16:33,600 --> 00:16:36,900
this or it's the top of the sake or

00:16:35,280 --> 00:16:39,260
something you can you know you get a

00:16:36,900 --> 00:16:41,610
little bit of information about why

00:16:39,260 --> 00:16:44,400
you've got your buffer overflow so you

00:16:41,610 --> 00:16:48,690
can help helps you funny and switch see

00:16:44,400 --> 00:16:53,310
what you've done wrong so how it works

00:16:48,690 --> 00:16:56,250
is this is your memory you've allocated

00:16:53,310 --> 00:16:58,950
yeah I've given you three examples of I

00:16:56,250 --> 00:17:02,550
mean we it's been allocated you could

00:16:58,950 --> 00:17:05,550
have say you've got three bytes yeah and

00:17:02,550 --> 00:17:09,179
because because it always a saying works

00:17:05,550 --> 00:17:10,920
on eight byte chunks before you always

00:17:09,179 --> 00:17:14,040
you want to get the extra five bytes at

00:17:10,920 --> 00:17:15,900
the end so you got three bytes of memory

00:17:14,040 --> 00:17:19,800
fell out in five points

00:17:15,900 --> 00:17:22,530
invalid or you could have if we if we

00:17:19,800 --> 00:17:26,069
bite valid or nothing

00:17:22,530 --> 00:17:29,130
and so you at the top you'll see these a

00:17:26,069 --> 00:17:31,770
white box which is in so in is just the

00:17:29,130 --> 00:17:38,400
there's the equivalent there this blocks

00:17:31,770 --> 00:17:41,120
shadow memory so it's a fixed offset it

00:17:38,400 --> 00:17:43,539
will say depending on the value of in

00:17:41,120 --> 00:17:47,630
it will mean that if it means positive

00:17:43,539 --> 00:17:50,900
you have some number of zero to once at

00:17:47,630 --> 00:17:53,330
7 bytes of additive in zero all bytes of

00:17:50,900 --> 00:18:00,890
a loads and the fins negative did

00:17:53,330 --> 00:18:02,150
nothing as wellas so like I see all our

00:18:00,890 --> 00:18:04,640
location this does mean all our

00:18:02,150 --> 00:18:06,590
locations have to be at least 8 bytes of

00:18:04,640 --> 00:18:09,380
lines which so it's going to cause a

00:18:06,590 --> 00:18:11,539
little bit of overheat and mean we over

00:18:09,380 --> 00:18:14,809
here they have been they have to be

00:18:11,539 --> 00:18:20,779
assigned 20 bytes sized because of the

00:18:14,809 --> 00:18:23,179
way it works which means that small I've

00:18:20,779 --> 00:18:27,260
a small other buffer overflows it

00:18:23,179 --> 00:18:27,740
detected in then you can add on by

00:18:27,260 --> 00:18:30,159
default

00:18:27,740 --> 00:18:32,899
I think we're freebies the aides one by

00:18:30,159 --> 00:18:36,440
will we know implemented ed one one byte

00:18:32,899 --> 00:18:38,779
a one block of eight bytes afterwards

00:18:36,440 --> 00:18:40,520
but you could imagine if you think these

00:18:38,779 --> 00:18:45,100
going to be a lot if you've got a larger

00:18:40,520 --> 00:18:45,100
overflow we could add more if we need to

00:18:45,130 --> 00:18:50,149
enough because I've copied this I'm

00:18:48,649 --> 00:18:54,500
using the same one time as new BST I

00:18:50,149 --> 00:18:57,230
believe they have we the same so here's

00:18:54,500 --> 00:18:59,470
an example I hopefully this one doesn't

00:18:57,230 --> 00:19:04,039
have any buffer overflows

00:18:59,470 --> 00:19:07,159
I'm asking I have other catered to me me

00:19:04,039 --> 00:19:11,390
and if you're not familiar with FreeBSD

00:19:07,159 --> 00:19:13,640
they this is just a manic which in theme

00:19:11,390 --> 00:19:15,799
just is give me a simply values it I

00:19:13,640 --> 00:19:18,370
don't care about the titers just a

00:19:15,799 --> 00:19:22,100
certain type to say for later to say

00:19:18,370 --> 00:19:25,279
trekking of who's using memory and white

00:19:22,100 --> 00:19:28,730
okay means I'm heavy with sleeping as

00:19:25,279 --> 00:19:31,510
long as you so guarantees that the the

00:19:28,730 --> 00:19:34,279
value will a a non that will vary they

00:19:31,510 --> 00:19:36,350
will be returned so me me so I don't

00:19:34,279 --> 00:19:38,960
need about what they're worth a no chick

00:19:36,350 --> 00:19:42,049
in this case because it's guaranteed

00:19:38,960 --> 00:19:44,000
this it will be valid and I get some

00:19:42,049 --> 00:19:47,960
memory I get some data so I call a

00:19:44,000 --> 00:19:50,720
function past the point of in and I want

00:19:47,960 --> 00:19:53,840
to return it so I copy it into just onto

00:19:50,720 --> 00:19:58,130
the stack in for you freezer

00:19:53,840 --> 00:20:00,610
the the Malik's memory I'm only using in

00:19:58,130 --> 00:20:03,500
this case I'm using malloc just because

00:20:00,610 --> 00:20:04,120
just to show you that how would work

00:20:03,500 --> 00:20:06,620
what's there

00:20:04,120 --> 00:20:09,110
you could imagine that this is actually

00:20:06,620 --> 00:20:13,190
more complex in there in malloc and free

00:20:09,110 --> 00:20:16,550
maybe in different functions but this is

00:20:13,190 --> 00:20:19,400
a simplified case so what's happening

00:20:16,550 --> 00:20:20,810
other kate's the memory in this case

00:20:19,400 --> 00:20:25,250
because I see that's like his to be 8

00:20:20,810 --> 00:20:27,950
bytes aligned in date bite-sized there

00:20:25,250 --> 00:20:31,760
where they say the first 8 bytes and

00:20:27,950 --> 00:20:34,570
it's rounded up to a second buffer so we

00:20:31,760 --> 00:20:36,650
can do buffer overflow detection of

00:20:34,570 --> 00:20:38,690
guaranteed then we'll have something

00:20:36,650 --> 00:20:41,660
after the bath after their memory we've

00:20:38,690 --> 00:20:45,560
allocated and I knew the first four

00:20:41,660 --> 00:20:49,790
bytes amount is valid we've been put in

00:20:45,560 --> 00:20:55,900
some data into the shadow map so we say

00:20:49,790 --> 00:21:01,880
4 bytes valid in the first entry in if B

00:20:55,900 --> 00:21:03,530
is saying it's a man acht buffer so it's

00:21:01,880 --> 00:21:05,360
saying it's going to if we do a buffer

00:21:03,530 --> 00:21:08,330
have a buffer overflow dear well you

00:21:05,360 --> 00:21:13,850
know it's from I'm Alex breathing past

00:21:08,330 --> 00:21:15,890
scenes of a Malachi so yes so I say the

00:21:13,850 --> 00:21:18,110
first half is valid in a apparently

00:21:15,890 --> 00:21:25,760
forgot to write the second buffer the

00:21:18,110 --> 00:21:29,480
second block is Magda's is mount so like

00:21:25,760 --> 00:21:32,720
a load of store this includes bytes 14 3

00:21:29,480 --> 00:21:36,380
15 will be detected as long as it's in

00:21:32,720 --> 00:21:38,030
code that's been imitated you know say

00:21:36,380 --> 00:21:42,140
this one through being built with the

00:21:38,030 --> 00:21:44,300
sanitizer enabled in we can either then

00:21:42,140 --> 00:21:47,150
well if we do teach that we can mean

00:21:44,300 --> 00:21:50,180
either use printf or Penix so Pennock

00:21:47,150 --> 00:21:54,890
will stop the world principal just say

00:21:50,180 --> 00:21:57,440
you've done something naughty a load or

00:21:54,890 --> 00:22:00,610
store annoyed of store outside of this

00:21:57,440 --> 00:22:03,650
range may or may not be detected like we

00:22:00,610 --> 00:22:05,720
okay I saying doesn't Siri give you your

00:22:03,650 --> 00:22:06,610
perfect security that's not the security

00:22:05,720 --> 00:22:09,870
tool as

00:22:06,610 --> 00:22:09,870
just give you a idea

00:22:12,040 --> 00:22:21,750
so the my example again what happen what

00:22:16,780 --> 00:22:24,370
we what the compiler will do is in

00:22:21,750 --> 00:22:28,210
malloc we see it up to show their map

00:22:24,370 --> 00:22:30,240
and will insert and we have a function

00:22:28,210 --> 00:22:34,750
instituted by the compiler

00:22:30,240 --> 00:22:39,179
so the SE C in those four will implement

00:22:34,750 --> 00:22:39,179
at the the cheeks on the shelling map

00:22:39,390 --> 00:22:45,100
there was a you know so it'll be it

00:22:43,330 --> 00:22:47,260
knows the compiler would he know he's

00:22:45,100 --> 00:22:51,400
size of you know in an integer is 4

00:22:47,260 --> 00:22:55,919
bytes obviously so we all know to insert

00:22:51,400 --> 00:22:59,130
the four bytes wide thing yeah check and

00:22:55,919 --> 00:23:02,260
exactly what I say in those four does is

00:22:59,130 --> 00:23:04,270
one time to pin there so you the new

00:23:02,260 --> 00:23:06,850
piece the code that we use a new piece

00:23:04,270 --> 00:23:10,630
the users will into a look up on the

00:23:06,850 --> 00:23:13,030
show they met cheek that you you've got

00:23:10,630 --> 00:23:17,340
valid me me and if anyone there you

00:23:13,030 --> 00:23:17,340
built up in you do the pin oak or xx

00:23:17,700 --> 00:23:23,290
offense did we were to do this and I've

00:23:20,799 --> 00:23:25,570
if you know the defense's here I'm

00:23:23,290 --> 00:23:28,600
reading the data 0 and here I'm reading

00:23:25,570 --> 00:23:33,160
days one now I've been suited actually

00:23:28,600 --> 00:23:36,929
obviously to the buffer overflow this

00:23:33,160 --> 00:23:41,710
will then move to the next part the next

00:23:36,929 --> 00:23:44,260
entry so date up plus 4 bytes later and

00:23:41,710 --> 00:23:48,760
say well you know what is what's the

00:23:44,260 --> 00:23:52,380
value dean in with hope set the code

00:23:48,760 --> 00:23:54,460
willing to take this buffer virus its

00:23:52,380 --> 00:23:57,250
it'll print in the imprint of message

00:23:54,460 --> 00:24:00,520
saying exactly we're was and because

00:23:57,250 --> 00:24:02,350
it's white besides the use hopefully

00:24:00,520 --> 00:24:04,780
they feeling mean we'll go figure out

00:24:02,350 --> 00:24:07,020
exactly we're in their code day issue

00:24:04,780 --> 00:24:07,020
was

00:24:09,790 --> 00:24:12,840
now question

00:24:13,950 --> 00:24:20,410
so quick so in other cases yes

00:24:18,790 --> 00:24:23,410
except in one case where I've got a

00:24:20,410 --> 00:24:25,660
panic if you know that so nothing

00:24:23,410 --> 00:24:29,710
designer if you know that you may I'd

00:24:25,660 --> 00:24:33,490
like to talk I'm not better yes I

00:24:29,710 --> 00:24:35,590
actually got a thief yes so neat

00:24:33,490 --> 00:24:41,380
beasties had this for a long time for

00:24:35,590 --> 00:24:44,830
year I've had a sum of co student

00:24:41,380 --> 00:24:46,980
working on that who did a lot of their

00:24:44,830 --> 00:24:52,290
work and we managed to get a

00:24:46,980 --> 00:24:55,750
successfully booting FreeBSD on amd64

00:24:52,290 --> 00:25:00,760
this was with my previous runtime which

00:24:55,750 --> 00:25:02,830
I decided that I didn't like place after

00:25:00,760 --> 00:25:04,330
some of code I've never also reported to

00:25:02,830 --> 00:25:06,760
their Phoebe's the neat beastly runtime

00:25:04,330 --> 00:25:08,110
and I have pushed it to a get that

00:25:06,760 --> 00:25:11,800
branch if people were interested in

00:25:08,110 --> 00:25:16,990
playing with it I am currently testing

00:25:11,800 --> 00:25:19,360
and trying to break it and I have found

00:25:16,990 --> 00:25:23,050
one that one known issue and um a that

00:25:19,360 --> 00:25:27,460
is with my my use of my case at KS n

00:25:23,050 --> 00:25:29,800
sides not um a size so ok that's the

00:25:27,460 --> 00:25:33,580
problem I've got is with my code not

00:25:29,800 --> 00:25:35,080
worth the existing going so far and

00:25:33,580 --> 00:25:37,240
because of the way it works so we'll

00:25:35,080 --> 00:25:40,840
wing me free we also Mac Mimi's invalids

00:25:37,240 --> 00:25:46,900
it will also detect use after free which

00:25:40,840 --> 00:25:51,120
is nice so there's another useful

00:25:46,900 --> 00:25:54,490
interesting I say um sanitizer called

00:25:51,120 --> 00:26:00,640
good hardware based hardware assisted

00:25:54,490 --> 00:26:03,010
one so am 64 his support for a single

00:26:00,640 --> 00:26:06,730
top bite ignore we are we can mark a top

00:26:03,010 --> 00:26:08,170
bite of pointers as told a hard way to

00:26:06,730 --> 00:26:10,300
it just ignore the value in there it

00:26:08,170 --> 00:26:15,130
doesn't it's going to be could be

00:26:10,300 --> 00:26:19,960
anything I mean when we you know a few

00:26:15,130 --> 00:26:21,850
neighborhoods and in the hardware we can

00:26:19,960 --> 00:26:25,240
mean done and leave we cheek we can then

00:26:21,850 --> 00:26:26,780
say what if you've got yeah we could

00:26:25,240 --> 00:26:28,970
then use that value as

00:26:26,780 --> 00:26:32,540
as some information about whether or not

00:26:28,970 --> 00:26:37,370
this is a valid pointer or pointing

00:26:32,540 --> 00:26:39,350
invalid memory so so what we'll do is

00:26:37,370 --> 00:26:43,370
we'll store they 8-bit tag in this in

00:26:39,350 --> 00:26:45,260
this in the field and then as the HUD we

00:26:43,370 --> 00:26:47,960
will ignore it and loads and stores we

00:26:45,260 --> 00:26:50,210
can then when we use from it the code we

00:26:47,960 --> 00:26:51,950
can then use no chicken bean but we

00:26:50,210 --> 00:26:57,320
don't have to do modify the point to 18

00:26:51,950 --> 00:27:02,480
you to you will move it it's this is an

00:26:57,320 --> 00:27:05,480
arm 64 specific thing is I don't know if

00:27:02,480 --> 00:27:06,830
I don't know of any other hardware in

00:27:05,480 --> 00:27:10,250
any other architecture that supports

00:27:06,830 --> 00:27:17,390
something similar there will leave

00:27:10,250 --> 00:27:20,360
nothing there PBC supports runs it does

00:27:17,390 --> 00:27:26,030
mean you have to allocate you using

00:27:20,360 --> 00:27:32,150
allocate random tags in such way so we

00:27:26,030 --> 00:27:33,020
start off with white here is all is just

00:27:32,150 --> 00:27:37,880
the default

00:27:33,020 --> 00:27:41,900
so and another cated memory so we've got

00:27:37,880 --> 00:27:44,060
a we start off saying the points that

00:27:41,900 --> 00:27:45,920
you know the when you do a though you're

00:27:44,060 --> 00:27:50,330
stored it's gone to coasters become they

00:27:45,920 --> 00:27:54,230
don't mean reason valid we do some

00:27:50,330 --> 00:27:56,960
allocations and so in this case me and

00:27:54,230 --> 00:27:59,600
reduce is one intervene map is blue and

00:27:56,960 --> 00:28:01,160
so you point to has to have the crypt

00:27:59,600 --> 00:28:06,800
for a whatever the color what even then

00:28:01,160 --> 00:28:08,120
but is for blue to designs Mme and then

00:28:06,800 --> 00:28:10,400
eventually you know who do some more

00:28:08,120 --> 00:28:13,280
allocations they may not be and there

00:28:10,400 --> 00:28:16,430
may you may have kept some things 5 as

00:28:13,280 --> 00:28:19,280
long as later on and if you want to

00:28:16,430 --> 00:28:20,870
safely load some familiar location 3 was

00:28:19,280 --> 00:28:26,510
a blue a pointer that's been marked as

00:28:20,870 --> 00:28:31,430
blue you will fail this one has the

00:28:26,510 --> 00:28:33,520
advantage of it means that you you can

00:28:31,430 --> 00:28:36,410
get you can say well larger

00:28:33,520 --> 00:28:38,040
out-of-bounds allocations and more

00:28:36,410 --> 00:28:40,050
likely to fail

00:28:38,040 --> 00:28:41,970
because if we have we even if we've got

00:28:40,050 --> 00:28:43,980
of others even if we've allocated memory

00:28:41,970 --> 00:28:46,890
there if we have another case that the

00:28:43,980 --> 00:28:55,620
memory was the creep with a quick tag it

00:28:46,890 --> 00:28:59,370
will fail bet it does and it does also

00:28:55,620 --> 00:29:01,800
it also gives you use after free well

00:28:59,370 --> 00:29:03,720
because as you when you free me me it

00:29:01,800 --> 00:29:11,700
will clear the turkey of that egg on let

00:29:03,720 --> 00:29:14,940
me lip piece of memory it does you do

00:29:11,700 --> 00:29:16,920
any key so you add one bite of with

00:29:14,940 --> 00:29:19,950
your space piercing for 16 bytes

00:29:16,920 --> 00:29:23,130
allocated and if we need B me needs to

00:29:19,950 --> 00:29:28,560
be 16 byte aligned and you don't need to

00:29:23,130 --> 00:29:30,930
do a you don't need a because then if

00:29:28,560 --> 00:29:33,060
you are allocating your the tags

00:29:30,930 --> 00:29:34,980
randomly you can use a proper

00:29:33,060 --> 00:29:36,720
ballistically to mislead of saying well

00:29:34,980 --> 00:29:38,370
the probably than the Excel occasions a

00:29:36,720 --> 00:29:41,010
different color or it has different

00:29:38,370 --> 00:29:43,980
value so we don't necessarily we don't

00:29:41,010 --> 00:29:47,400
need to do allocate a pet any petting

00:29:43,980 --> 00:29:52,770
for slightly out of bounds it does mean

00:29:47,400 --> 00:29:55,170
that you lose you don't get the if

00:29:52,770 --> 00:29:57,960
you're only one byte other bands on a 7

00:29:55,170 --> 00:29:59,850
byte a location I won't to take that but

00:29:57,960 --> 00:30:03,390
it will detect if you're 16 by itself a

00:29:59,850 --> 00:30:08,390
bad so you can't you won't necessarily

00:30:03,390 --> 00:30:10,800
get the slightly as a band failure and

00:30:08,390 --> 00:30:13,590
because a new gives us just that that's

00:30:10,800 --> 00:30:17,910
just slightly under because of you a few

00:30:13,590 --> 00:30:21,720
values other if you use as a reserved

00:30:17,910 --> 00:30:24,270
you'll give birth and owed 1 in 256 but

00:30:21,720 --> 00:30:27,750
probability of getting the wrong color

00:30:24,270 --> 00:30:32,640
of getting the clip they color of your

00:30:27,750 --> 00:30:35,340
pointer when you shouldn't have I don't

00:30:32,640 --> 00:30:36,840
know a venue I only know of the next

00:30:35,340 --> 00:30:38,520
meeting this so if anyone wants to do

00:30:36,840 --> 00:30:40,830
this on

00:30:38,520 --> 00:30:42,870
Phoebe's day or need-based even if they

00:30:40,830 --> 00:30:45,800
come and talk to me I'll be interested

00:30:42,870 --> 00:30:45,800
in the runtime

00:30:49,440 --> 00:30:55,419
then I'll learn in a we've got cheery

00:30:53,109 --> 00:30:56,889
which is if you were in books has talked

00:30:55,419 --> 00:31:00,309
this morning and not not tomorrow

00:30:56,889 --> 00:31:01,989
because he been you were you would have

00:31:00,309 --> 00:31:04,629
been talking about cherry or go and have

00:31:01,989 --> 00:31:08,820
a look on this as the the videos we

00:31:04,629 --> 00:31:12,690
never posted data it's basically you say

00:31:08,820 --> 00:31:17,229
make pointers on bigger store bounds

00:31:12,690 --> 00:31:19,539
more likely bouncing dear if you use a

00:31:17,229 --> 00:31:21,940
few and make sure they're not for jabal

00:31:19,539 --> 00:31:23,169
so that a five given if you've got a

00:31:21,940 --> 00:31:26,440
case of this capability

00:31:23,169 --> 00:31:28,539
you can't possibly use it to access many

00:31:26,440 --> 00:31:32,349
outside of the bounds no matter how much

00:31:28,539 --> 00:31:36,669
you try you also really to my features

00:31:32,349 --> 00:31:37,929
like bounds and permissions and and they

00:31:36,669 --> 00:31:39,759
can only be derived from other

00:31:37,929 --> 00:31:43,090
capabilities so you can only shrink them

00:31:39,759 --> 00:31:44,409
you can't expand them and going back in

00:31:43,090 --> 00:31:46,269
time and see books has talked this

00:31:44,409 --> 00:31:51,789
morning if you're interested in learning

00:31:46,269 --> 00:31:53,590
more about this div is we should see

00:31:51,789 --> 00:31:55,239
some hardware it's an experimental

00:31:53,590 --> 00:31:55,960
hardware they're suing and they're in a

00:31:55,239 --> 00:31:59,080
few years

00:31:55,960 --> 00:32:02,879
what's I said it's his arm is is

00:31:59,080 --> 00:32:02,879
interested have been working on this

00:32:03,720 --> 00:32:11,379
yeah so we can say we can detect oh as

00:32:09,399 --> 00:32:13,539
long as we keep looking at the

00:32:11,379 --> 00:32:16,090
capabilities that see that quickly we

00:32:13,539 --> 00:32:18,580
can detect out of bounds and not just

00:32:16,090 --> 00:32:20,229
you know we if you've got a diet

00:32:18,580 --> 00:32:25,629
allocation we won't we may miss a

00:32:20,229 --> 00:32:27,720
slightly other bands like Exodus but

00:32:25,629 --> 00:32:31,570
we'll did seek a large as bands X's

00:32:27,720 --> 00:32:36,099
because these note a collision and

00:32:31,570 --> 00:32:40,419
locking of K said KH the other had very

00:32:36,099 --> 00:32:43,090
saying we've got interesting work on

00:32:40,419 --> 00:32:45,159
going on so this has been ported the

00:32:43,090 --> 00:32:49,869
kernel we have got a kernel with it will

00:32:45,159 --> 00:32:55,179
boot to use a space worth for every

00:32:49,869 --> 00:32:59,259
pointer is the capability any we've got

00:32:55,179 --> 00:33:01,159
work on had weight on reducing cap bands

00:32:59,259 --> 00:33:04,609
so arrays inside

00:33:01,159 --> 00:33:09,229
who have bounds on them for example with

00:33:04,609 --> 00:33:13,070
subobject beyond bounds but they may

00:33:09,229 --> 00:33:17,619
need annotations okay cute if it was the

00:33:13,070 --> 00:33:23,809
main one cute I chosen many one thing

00:33:17,619 --> 00:33:25,999
lastly memory as tuned to you know it's

00:33:23,809 --> 00:33:27,919
possible to be excellently white mean

00:33:25,999 --> 00:33:30,559
you know to actually read me me before

00:33:27,919 --> 00:33:33,409
you've written to it which is undefined

00:33:30,559 --> 00:33:36,769
exactly what will be in the memory in if

00:33:33,409 --> 00:33:39,080
you're reading me me is past data user

00:33:36,769 --> 00:33:46,099
space then you could actually take

00:33:39,080 --> 00:33:49,129
information so I am saying is a it will

00:33:46,099 --> 00:33:51,799
do that so we cheek though say you've

00:33:49,129 --> 00:33:54,409
just said we store bets to say is this

00:33:51,799 --> 00:34:00,739
me me being initialized and then on use

00:33:54,409 --> 00:34:03,259
it will cheek is use as we've is

00:34:00,739 --> 00:34:05,419
interesting in the gerson is it's used

00:34:03,259 --> 00:34:08,359
in the conditional so using the Neff

00:34:05,419 --> 00:34:10,700
statement or wives Damon or point to do

00:34:08,359 --> 00:34:13,730
refunds or copied out they'll use the

00:34:10,700 --> 00:34:16,399
space so that's one was there to stop

00:34:13,730 --> 00:34:23,029
peeking information to these two out of

00:34:16,399 --> 00:34:27,230
the kernel so here we go example of you

00:34:23,029 --> 00:34:29,779
know we create a variable B equals I is

00:34:27,230 --> 00:34:30,980
not only a use in this case it's not

00:34:29,779 --> 00:34:34,129
because it's not in there conditioner

00:34:30,980 --> 00:34:35,869
what's not being used to change the in

00:34:34,129 --> 00:34:38,270
the flow of the program it's just an

00:34:35,869 --> 00:34:40,419
assignment so prop that all been that

00:34:38,270 --> 00:34:44,179
the fact that a is

00:34:40,419 --> 00:34:46,010
uninitialized will propagate to be any

00:34:44,179 --> 00:34:48,909
no and coffee out which is copying from

00:34:46,010 --> 00:34:51,379
user space to Colonel to use a space

00:34:48,909 --> 00:34:54,079
Dean you will warn that you've done and

00:34:51,379 --> 00:34:58,220
then and initialized you've used at at

00:34:54,079 --> 00:35:04,010
that point or a second Lisa

00:34:58,220 --> 00:35:06,799
more surprising one uses this code so

00:35:04,010 --> 00:35:12,799
you see it was a plus B see yeah

00:35:06,799 --> 00:35:14,570
that's not consider the use but the AFC

00:35:12,799 --> 00:35:21,320
will become or have a

00:35:14,570 --> 00:35:23,180
flex it depending on if the flag father

00:35:21,320 --> 00:35:27,020
you was sittin are so if we went to EDF

00:35:23,180 --> 00:35:30,440
case and this this condition then C will

00:35:27,020 --> 00:35:33,500
be Caesar has been initialized otherwise

00:35:30,440 --> 00:35:35,480
will be clear and then I saw and be used

00:35:33,500 --> 00:35:38,480
to plague again to know if we want to

00:35:35,480 --> 00:35:40,750
copy it out so their case C what we

00:35:38,480 --> 00:35:46,880
initialize copy out I'm assuming B is

00:35:40,750 --> 00:35:50,240
initialized in this example no certainly

00:35:46,880 --> 00:35:53,810
more complex one this is you know in the

00:35:50,240 --> 00:35:57,380
conditional so when you allocate memory

00:35:53,810 --> 00:36:07,190
it will market orders uninitialized and

00:35:57,380 --> 00:36:10,040
this and this you've not to and on the

00:36:07,190 --> 00:36:11,780
flick on the reading of a Fagor Devine

00:36:10,040 --> 00:36:17,090
will say well given actually in this

00:36:11,780 --> 00:36:20,630
Isis it's invalid use but Kate Ange uses

00:36:17,090 --> 00:36:23,150
a sharing map one as only needs one bits

00:36:20,630 --> 00:36:24,380
per byte so each each byte of memory has

00:36:23,150 --> 00:36:26,780
a bits in the show they may have some

00:36:24,380 --> 00:36:30,770
ways say this has been initialized or

00:36:26,780 --> 00:36:34,610
not which when you allocate memory is

00:36:30,770 --> 00:36:37,130
poisoned and I'm poison and we need zero

00:36:34,610 --> 00:36:40,730
it or allocate right to it in some way

00:36:37,130 --> 00:36:42,620
it's an poisoned and the sure though

00:36:40,730 --> 00:36:45,170
space is propagated so when you do an

00:36:42,620 --> 00:36:48,680
assignment we fight we propagates the

00:36:45,170 --> 00:36:55,100
state so that when you actually use it

00:36:48,680 --> 00:36:57,040
later then we'll know in Dusty's familiy

00:36:55,100 --> 00:36:59,840
other cases is kay-kay leak which is

00:36:57,040 --> 00:37:02,780
similar by here is no duplicate exactly

00:36:59,840 --> 00:37:04,880
to be duplicated than it BSD

00:37:02,780 --> 00:37:07,190
where it's used because it is in vain

00:37:04,880 --> 00:37:10,970
signaling so it's more likely to you'll

00:37:07,190 --> 00:37:12,530
get false positives it uses a value when

00:37:10,970 --> 00:37:14,810
you allocate me me you'll put a known

00:37:12,530 --> 00:37:16,970
value in in or copyright you check if

00:37:14,810 --> 00:37:20,300
that value is and your point is in your

00:37:16,970 --> 00:37:20,810
structure you're copying out with some

00:37:20,300 --> 00:37:23,000
information

00:37:20,810 --> 00:37:25,250
you know they they've kind of done some

00:37:23,000 --> 00:37:27,230
science and looked at least likely value

00:37:25,250 --> 00:37:28,760
least likely when byte values have been

00:37:27,230 --> 00:37:31,400
copied out

00:37:28,760 --> 00:37:33,579
and use those and rotate them and these

00:37:31,400 --> 00:37:37,250
are pay for and those fewer interested

00:37:33,579 --> 00:37:39,320
it doesn't it's not because it's Indian

00:37:37,250 --> 00:37:44,780
signaling it may detect may get false

00:37:39,320 --> 00:37:45,460
positives in tweeting as through the

00:37:44,780 --> 00:37:49,369
heart

00:37:45,460 --> 00:37:52,970
there was a there is a cruelties T

00:37:49,369 --> 00:37:55,690
saying I'm not sure what statuses I

00:37:52,970 --> 00:37:58,250
don't ask him it I saw as a match to the

00:37:55,690 --> 00:37:59,720
Linux tree from Google so I'm not I

00:37:58,250 --> 00:38:01,490
don't know exactly I haven't looked

00:37:59,720 --> 00:38:06,280
recently if there's been any progress

00:38:01,490 --> 00:38:19,460
there they've inserted a anywhere else

00:38:06,280 --> 00:38:22,270
but so why find bags it is manual by no

00:38:19,460 --> 00:38:26,060
fussing which I've talked about so is

00:38:22,270 --> 00:38:27,740
you know it helps you know needs often

00:38:26,060 --> 00:38:30,579
needs the sort of thing and it makes it

00:38:27,740 --> 00:38:33,140
makes fussing much more powerful

00:38:30,579 --> 00:38:35,089
especially is the comparison example I

00:38:33,140 --> 00:38:38,500
gave you is it it will feed you know

00:38:35,089 --> 00:38:42,140
means that the fuzzing can feedback and

00:38:38,500 --> 00:38:44,210
as you make faxing more like these find

00:38:42,140 --> 00:38:46,880
code paths it makes us more like fine

00:38:44,210 --> 00:38:49,069
bags so it's basically feeds bacon on

00:38:46,880 --> 00:38:56,390
yeah if you can make it easier to find

00:38:49,069 --> 00:38:57,950
bags you'll find more bags so these two

00:38:56,390 --> 00:38:59,089
facets I'm going to talk about the first

00:38:57,950 --> 00:39:03,140
is sis Keller

00:38:59,089 --> 00:39:05,990
it's from as a project from Google where

00:39:03,140 --> 00:39:11,060
it will it understands a lot about

00:39:05,990 --> 00:39:16,030
different system calls it's also an EBT

00:39:11,060 --> 00:39:19,780
OpenBSD in freebsd supported by it and

00:39:16,030 --> 00:39:22,190
so what I will do is that fine it will

00:39:19,780 --> 00:39:23,569
it's as good at finding new ways and you

00:39:22,190 --> 00:39:31,400
and interesting ways of picking the

00:39:23,569 --> 00:39:33,230
kernel from user space which may by by

00:39:31,400 --> 00:39:38,930
composing different system calls

00:39:33,230 --> 00:39:41,210
together as you can see this was I this

00:39:38,930 --> 00:39:45,710
is from you

00:39:41,210 --> 00:39:48,410
in the we can it will give you a list of

00:39:45,710 --> 00:39:51,140
Penix you know Google will provide and

00:39:48,410 --> 00:39:53,690
provides us but you know that there's

00:39:51,140 --> 00:39:57,980
only one there's no to but it was at the

00:39:53,690 --> 00:40:00,230
time there's only one priciest so one of

00:39:57,980 --> 00:40:03,770
these fuzzers wedding which is CI

00:40:00,230 --> 00:40:05,180
FreeBSD may there's no a second one

00:40:03,770 --> 00:40:07,579
would search for FreeBSD which is

00:40:05,180 --> 00:40:11,869
binding on i386 so if you wanted to find

00:40:07,579 --> 00:40:15,440
compare TT two issues compared it to

00:40:11,869 --> 00:40:17,480
Linux where they've got you know

00:40:15,440 --> 00:40:19,790
different they have different compiler

00:40:17,480 --> 00:40:22,849
options they have mini k a saying

00:40:19,790 --> 00:40:26,450
they've km saying so it would be nice

00:40:22,849 --> 00:40:29,270
you know Eve didn't what the Beasties I

00:40:26,450 --> 00:40:31,849
think it beasties might have case and

00:40:29,270 --> 00:40:33,349
they would by default I'm not sure I saw

00:40:31,849 --> 00:40:40,460
some case in panics when I looked

00:40:33,349 --> 00:40:42,980
earlier so it works by it will try to

00:40:40,460 --> 00:40:47,530
find you new power to see the colonel it

00:40:42,980 --> 00:40:51,230
uses the comparison sanitizers to say

00:40:47,530 --> 00:40:53,660
I've given you this data I see these

00:40:51,230 --> 00:40:58,040
comparisons that you possibly use this

00:40:53,660 --> 00:41:00,099
data if I try to change it to what's the

00:40:58,040 --> 00:41:03,730
other side of the comparison is does it

00:41:00,099 --> 00:41:06,290
doesn't mean I get into a new code pass

00:41:03,730 --> 00:41:08,180
it so it's we good at this is house

00:41:06,290 --> 00:41:11,390
works if you know is good at finding

00:41:08,180 --> 00:41:12,859
these bags from the colonel by using

00:41:11,390 --> 00:41:16,460
feedback information deck from the

00:41:12,859 --> 00:41:18,380
colonel it under stains various

00:41:16,460 --> 00:41:20,359
arguments and how they relate to each

00:41:18,380 --> 00:41:22,670
other and it will do things you don't

00:41:20,359 --> 00:41:24,680
expect it will take a socket and then

00:41:22,670 --> 00:41:26,630
pass the value in because it's a file

00:41:24,680 --> 00:41:28,250
descriptor over the impasse it's into

00:41:26,630 --> 00:41:30,829
something that definitely doesn't expect

00:41:28,250 --> 00:41:37,250
that if it be a socket passed in and see

00:41:30,829 --> 00:41:39,500
what happens it will try to it will do

00:41:37,250 --> 00:41:42,980
you know so many different things that

00:41:39,500 --> 00:41:47,420
you don't expect stitch is way you know

00:41:42,980 --> 00:41:48,950
initial kernel crashes or heaven and see

00:41:47,420 --> 00:41:52,609
only it's it's very good painting on the

00:41:48,950 --> 00:41:55,370
coil and it will try to find you a

00:41:52,609 --> 00:41:59,630
refugee sir so I'll give you a CT skate

00:41:55,370 --> 00:42:01,070
if it can find one anything synthesizers

00:41:59,630 --> 00:42:05,180
makes things it you know a lot easy to

00:42:01,070 --> 00:42:09,710
find these banks though so this is this

00:42:05,180 --> 00:42:13,430
is why a sin sizer is good is it if we

00:42:09,710 --> 00:42:15,560
do that it will be hang if we had the

00:42:13,430 --> 00:42:17,180
sanitizers it will find more bugs we can

00:42:15,560 --> 00:42:19,700
fix them we can hopefully cut make

00:42:17,180 --> 00:42:24,410
better claims about you know if you are

00:42:19,700 --> 00:42:27,470
bugs in the air colonel in before so it

00:42:24,410 --> 00:42:28,910
will give you if it finds Pennock it

00:42:27,470 --> 00:42:31,490
will give you some information it will

00:42:28,910 --> 00:42:33,500
give you the stick trace for example

00:42:31,490 --> 00:42:35,390
this is this is just this tendon

00:42:33,500 --> 00:42:39,350
naturally this just comes as a freebie

00:42:35,390 --> 00:42:43,700
steamy way on the pic if you look down

00:42:39,350 --> 00:42:45,590
the bottom it's found there was a log

00:42:43,700 --> 00:42:49,190
you'll see the information is there as a

00:42:45,590 --> 00:42:51,140
log it will give you a kind of refugee

00:42:49,190 --> 00:42:53,690
so which is just a textual description

00:42:51,140 --> 00:42:55,940
of system calls and how it rain things

00:42:53,690 --> 00:42:58,520
and it will find your CV producer for

00:42:55,940 --> 00:43:03,590
cane which you can in download and then

00:42:58,520 --> 00:43:05,150
try to reproduce locally it will email

00:43:03,590 --> 00:43:07,130
is amazing list

00:43:05,150 --> 00:43:10,880
join the mailing list of the appropriate

00:43:07,130 --> 00:43:12,790
one for your BSD or of your operating

00:43:10,880 --> 00:43:15,860
system of your choice

00:43:12,790 --> 00:43:17,930
we knew you fix if people fix things if

00:43:15,860 --> 00:43:21,260
they take them then sis can order to

00:43:17,930 --> 00:43:24,050
teach this it follows it will follow is

00:43:21,260 --> 00:43:26,060
it pulls in new source code your new

00:43:24,050 --> 00:43:28,040
changes it would--it eats that you've

00:43:26,060 --> 00:43:29,270
got effects for something rather it'll

00:43:28,040 --> 00:43:32,060
give you an email juries to save

00:43:29,270 --> 00:43:37,400
reported by and then we'll check that

00:43:32,060 --> 00:43:40,250
you have HD fixed it a you fair which is

00:43:37,400 --> 00:43:43,820
milk and fuzzies offers so far system so

00:43:40,250 --> 00:43:46,310
far for me buzzer I'll skip over there

00:43:43,820 --> 00:43:48,200
sweet birth but I have as the new

00:43:46,310 --> 00:43:55,340
piously talk was previously was about

00:43:48,200 --> 00:43:58,190
this there's been pictures and I found

00:43:55,340 --> 00:44:00,260
them to be slowly and fortunately a few

00:43:58,190 --> 00:44:05,020
coyotes of speeding before improving

00:44:00,260 --> 00:44:08,380
performance of this over so conclusion

00:44:05,020 --> 00:44:08,380
fuzzums good

00:44:10,420 --> 00:44:17,090
since ice is a good for fuzzing we have

00:44:15,260 --> 00:44:19,940
we have case we have cake off with

00:44:17,090 --> 00:44:22,520
Phoebe saying my sayings good seems to

00:44:19,940 --> 00:44:27,080
be good by in the finding bags other

00:44:22,520 --> 00:44:28,850
ones need need more work Google will

00:44:27,080 --> 00:44:31,430
fast for you if you give them that if

00:44:28,850 --> 00:44:37,160
you ask them to which if your wedding

00:44:31,430 --> 00:44:38,690
winners the BCCI nobody ends yeah look

00:44:37,160 --> 00:44:46,450
through these reports if you're

00:44:38,690 --> 00:44:46,450
interested in this any questions yes

00:44:49,780 --> 00:44:58,070
perhaps I missed it but where can the

00:44:52,340 --> 00:45:00,470
reports be fine mr. bivas Sporto calm I

00:44:58,070 --> 00:45:03,110
think but on things with killer tipster

00:45:00,470 --> 00:45:05,120
Bach or my well if you ask me they after

00:45:03,110 --> 00:45:11,750
the afterwards I can find that okay hey

00:45:05,120 --> 00:45:15,230
you know your leg I'm interested in the

00:45:11,750 --> 00:45:17,180
work on coverage did you use any of the

00:45:15,230 --> 00:45:20,120
hardware facility is like core site on

00:45:17,180 --> 00:45:23,690
arm or Intel VT for that no recovered

00:45:20,120 --> 00:45:29,000
synthesizer just uses the the compiler

00:45:23,690 --> 00:45:32,510
to insuit yeah and soup fried points

00:45:29,000 --> 00:45:34,550
basically enter your code via I have

00:45:32,510 --> 00:45:38,570
talked we have thought about using these

00:45:34,550 --> 00:45:41,090
sorts of tools on on arm and x86 but it

00:45:38,570 --> 00:45:42,740
depends a bit on if they commuted in the

00:45:41,090 --> 00:45:47,780
hard way which has may not be the case

00:45:42,740 --> 00:45:50,740
now so yeah a few you got ideas about

00:45:47,780 --> 00:45:52,210
that and yeah let's have a beer later

00:45:50,740 --> 00:45:56,080
[Music]

00:45:52,210 --> 00:45:56,080
any more questions

00:45:57,950 --> 00:46:05,940
so when you're using 'too sanitizer and

00:46:01,920 --> 00:46:08,249
cover two coverage tools i guess that

00:46:05,940 --> 00:46:11,309
the coverage to cannot coverage itself

00:46:08,249 --> 00:46:14,579
as it will cause their recursion and

00:46:11,309 --> 00:46:16,710
feedback loop and yeah we have to be

00:46:14,579 --> 00:46:21,269
very careful to build the coverage tool

00:46:16,710 --> 00:46:26,249
without coverage enabled right so that

00:46:21,269 --> 00:46:28,200
was my question yes I said one times you

00:46:26,249 --> 00:46:31,170
have to build without to sanitize the

00:46:28,200 --> 00:46:33,089
support otherwise if things get very so

00:46:31,170 --> 00:46:40,650
very quickly and you don't even get to

00:46:33,089 --> 00:46:43,109
the first predict any more questions not

00:46:40,650 --> 00:46:45,230
in that case thank you for your

00:46:43,109 --> 00:46:50,380
presentation

00:46:45,230 --> 00:46:50,380
[Applause]

00:46:59,650 --> 00:47:01,710

YouTube URL: https://www.youtube.com/watch?v=yyQFdWJDmh0


