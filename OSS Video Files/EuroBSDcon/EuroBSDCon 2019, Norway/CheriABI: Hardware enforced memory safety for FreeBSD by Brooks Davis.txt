Title: CheriABI: Hardware enforced memory safety for FreeBSD by Brooks Davis
Publication date: 2019-10-21
Playlist: EuroBSDCon 2019, Norway
Description: 
	CheriABI: Hardware enforced memory safety for FreeBSD

Memory safety bugs such as buffer overflows are an ongoing source of security vulnerabilities. CheriABI is a new process model for FreeBSD on the Capability Hardware Enhanced RISC Instructions (CHERI) hardware platform which eliminates the vast majority of buffer overflows and significantly increases the difficulty of control-flow attacks such as return-oriented programming.

Our protections cover programs, the C run-time environment including the dynamic linker, and kernel access to user memory. We have ported virtually all of the FreeBSD user space this platform demonstrating that memory safety can be fitted to existing C software.

More Info:
CheriABI: Hardware enforced memory safety for FreeBSD

Memory safety bugs such as buffer overflows are an ongoing source of security vulnerabilities. CheriABI is a new process model for FreeBSD on the Capability Hardware Enhanced RISC Instructions (CHERI) hardware platform which eliminates the vast majority of buffer overflows and significantly increases the difficulty of control-flow attacks such as return-oriented programming.

Our protections cover programs, the C run-time environment including the dynamic linker, and kernel access to user memory. We have ported virtually all of the FreeBSD user space this platform demonstrating that memory safety can be fitted to existing C software.
Captions: 
	00:00:04,160 --> 00:00:11,170
[Applause]

00:00:07,200 --> 00:00:13,420
thank you yeah so yeah I'm Brooks I'm

00:00:11,170 --> 00:00:15,250
here to talk to you today about a

00:00:13,420 --> 00:00:18,280
hardware enforced memory safety scheme

00:00:15,250 --> 00:00:21,040
that we've implemented on FreeBSD so

00:00:18,280 --> 00:00:22,450
that's you know we it would be

00:00:21,040 --> 00:00:24,190
reasonable to express a certain amount

00:00:22,450 --> 00:00:26,740
of disbelief that this could work we'll

00:00:24,190 --> 00:00:29,140
skip straight to the punchline it really

00:00:26,740 --> 00:00:30,760
does work we have a full FreeBSD

00:00:29,140 --> 00:00:32,050
operating system with spatial and

00:00:30,760 --> 00:00:34,300
referential memory safety

00:00:32,050 --> 00:00:36,690
this covers programs libraries linkers

00:00:34,300 --> 00:00:40,480
and kernel access to user memory

00:00:36,690 --> 00:00:42,370
performance is pretty good and we can

00:00:40,480 --> 00:00:45,789
run real world software both C and C++

00:00:42,370 --> 00:00:47,350
software so let me give you an

00:00:45,789 --> 00:00:48,399
introduction to cherry the technology

00:00:47,350 --> 00:00:50,530
we've built this off

00:00:48,399 --> 00:00:52,899
cherry introduces a new register type

00:00:50,530 --> 00:00:55,449
the capability you can think of this is

00:00:52,899 --> 00:00:56,440
a bit like there are integer registers

00:00:55,449 --> 00:00:59,260
and there are floating-point registers

00:00:56,440 --> 00:01:01,780
now we have capability registers chary

00:00:59,260 --> 00:01:03,670
capabilities grant access to a bounded

00:01:01,780 --> 00:01:05,590
region of address space they're

00:01:03,670 --> 00:01:08,430
protected in memory by tags and I'll

00:01:05,590 --> 00:01:08,430
explain that a little more later

00:01:08,640 --> 00:01:13,840
architectural e speaking cherry

00:01:10,720 --> 00:01:16,270
capabilities have a virtual address just

00:01:13,840 --> 00:01:19,180
like an ordinary pointer there's a tag

00:01:16,270 --> 00:01:21,190
bit off to the side which ensures that

00:01:19,180 --> 00:01:22,930
if you perform an invalid manipulation

00:01:21,190 --> 00:01:27,970
that tag is stripped you can no longer

00:01:22,930 --> 00:01:30,220
load through a capability and also that

00:01:27,970 --> 00:01:33,060
if you overwrite the memory with random

00:01:30,220 --> 00:01:35,740
stuff that is the tag is clear

00:01:33,060 --> 00:01:38,200
additionally we have a length and a base

00:01:35,740 --> 00:01:40,420
notionally which is the range of memory

00:01:38,200 --> 00:01:41,590
that can be accessed by manipulating

00:01:40,420 --> 00:01:43,810
that virtual address if you push that

00:01:41,590 --> 00:01:47,040
address out of bounds you get a fault

00:01:43,810 --> 00:01:49,120
rather than access to memory

00:01:47,040 --> 00:01:51,400
additionally there are permissions on

00:01:49,120 --> 00:01:53,640
these control things like load store or

00:01:51,400 --> 00:01:57,660
instruction fetch from capabilities

00:01:53,640 --> 00:02:00,640
however as you might notice here this is

00:01:57,660 --> 00:02:03,940
257 bits which is a bit large for a

00:02:00,640 --> 00:02:05,800
pointer so we've cut it down a bit

00:02:03,940 --> 00:02:07,150
internally we have a compressed mode

00:02:05,800 --> 00:02:11,560
where we have floating we make the

00:02:07,150 --> 00:02:12,970
bounds floating point and we compress

00:02:11,560 --> 00:02:14,740
them relative to the virtual address

00:02:12,970 --> 00:02:17,319
there's a bunch of clever tricks there's

00:02:14,740 --> 00:02:17,790
a long 20 odd page journal paper that

00:02:17,319 --> 00:02:20,209
explains

00:02:17,790 --> 00:02:23,730
in great detail and with lots of math

00:02:20,209 --> 00:02:27,209
but the the short the short version is

00:02:23,730 --> 00:02:28,829
that we compress the bounds so you have

00:02:27,209 --> 00:02:30,209
to you have to pad your allocations a

00:02:28,829 --> 00:02:33,269
bit what your allocator probably does

00:02:30,209 --> 00:02:37,010
anyway we maintain all the security

00:02:33,269 --> 00:02:39,689
properties of the architectural view and

00:02:37,010 --> 00:02:41,549
we have strong support for C language so

00:02:39,689 --> 00:02:43,560
we see language features that are

00:02:41,549 --> 00:02:44,909
commonly used even if they're not

00:02:43,560 --> 00:02:46,500
technically correct

00:02:44,909 --> 00:02:48,120
for instance allowing pointers to drift

00:02:46,500 --> 00:02:50,790
out of bounds and then come be brought

00:02:48,120 --> 00:02:54,420
back in before they're used this is used

00:02:50,790 --> 00:02:56,609
both for dubious optimizations and

00:02:54,420 --> 00:02:58,680
simply as of matter as a matter of the

00:02:56,609 --> 00:03:00,150
way pointer arithmetic is performed on

00:02:58,680 --> 00:03:01,650
pointers sometimes you make multiple

00:03:00,150 --> 00:03:04,680
operations you're moving that address

00:03:01,650 --> 00:03:06,840
around and then in the process you go

00:03:04,680 --> 00:03:10,500
out and then back in because you apply

00:03:06,840 --> 00:03:15,409
the arithmetic in the particular order

00:03:10,500 --> 00:03:17,849
this increases the dense tag density but

00:03:15,409 --> 00:03:19,980
otherwise it sure it but it shrinks the

00:03:17,849 --> 00:03:21,829
size of the pointers that's them in half

00:03:19,980 --> 00:03:25,769
which means we're only twice as big now

00:03:21,829 --> 00:03:27,989
which is hopefully more palatable and

00:03:25,769 --> 00:03:29,489
we've got a so all of this work we've

00:03:27,989 --> 00:03:37,560
got a full prototype with a software

00:03:29,489 --> 00:03:39,870
stack on an FPGA and in qmo now so how

00:03:37,560 --> 00:03:43,500
does cherry work how does cherry work

00:03:39,870 --> 00:03:47,040
well cherry impinges on all on all

00:03:43,500 --> 00:03:48,840
memory accesses so either that's

00:03:47,040 --> 00:03:50,400
explicitly by new instructions which

00:03:48,840 --> 00:03:53,310
load and store via capabilities are

00:03:50,400 --> 00:03:54,930
jumped via capabilities or implicitly so

00:03:53,310 --> 00:03:56,819
if you're using a legacy MIPS load or

00:03:54,930 --> 00:03:59,579
store instruction it's by a default data

00:03:56,819 --> 00:04:01,019
capability or if you're setting

00:03:59,579 --> 00:04:02,729
addresses of the program counter it's by

00:04:01,019 --> 00:04:07,739
our program it's relative to a program

00:04:02,729 --> 00:04:09,359
counter capability obviously all this

00:04:07,739 --> 00:04:11,010
wouldn't be any good wouldn't be of much

00:04:09,359 --> 00:04:13,650
use if you could just make up your own

00:04:11,010 --> 00:04:15,209
capabilities and and have your own

00:04:13,650 --> 00:04:16,739
pointers to anything because that would

00:04:15,209 --> 00:04:18,209
just be what we have now we're virtual

00:04:16,739 --> 00:04:20,159
addresses you just make up a number and

00:04:18,209 --> 00:04:21,630
you try to access it and sometimes it

00:04:20,159 --> 00:04:24,830
works sometimes it explodes

00:04:21,630 --> 00:04:27,000
sometimes you own the system so

00:04:24,830 --> 00:04:29,460
capabilities are used and manipulated in

00:04:27,000 --> 00:04:31,409
capability registers the manipulations

00:04:29,460 --> 00:04:31,680
are monotonic which is to say that they

00:04:31,409 --> 00:04:33,240
can

00:04:31,680 --> 00:04:35,520
reduce bounds and permissions but they

00:04:33,240 --> 00:04:37,740
can't increase them so every capability

00:04:35,520 --> 00:04:40,979
has to be derived from more privileged

00:04:37,740 --> 00:04:43,080
capability when stored in memory they're

00:04:40,979 --> 00:04:45,270
protected by tags so as I mentioned

00:04:43,080 --> 00:04:46,949
before if you have a classic stack

00:04:45,270 --> 00:04:48,300
buffer overflow and you run over your

00:04:46,949 --> 00:04:50,490
return address well you've just written

00:04:48,300 --> 00:04:52,970
text over the top of your pointer you

00:04:50,490 --> 00:04:56,600
lose the tag and you crash on return

00:04:52,970 --> 00:04:59,789
which is much more friendly than before

00:04:56,600 --> 00:05:00,990
additionally though we put bounds on

00:04:59,789 --> 00:05:02,400
that stack address so you're not gonna

00:05:00,990 --> 00:05:04,620
get there anyway so you'd only get there

00:05:02,400 --> 00:05:06,870
if you had a compiler bug in the first

00:05:04,620 --> 00:05:09,509
place now

00:05:06,870 --> 00:05:11,430
cherri capabilities were designed from

00:05:09,509 --> 00:05:13,919
the beginning to be usable as seed

00:05:11,430 --> 00:05:15,599
pointers there have been a number of

00:05:13,919 --> 00:05:18,270
capability systems including some memory

00:05:15,599 --> 00:05:20,550
capability systems that we take we take

00:05:18,270 --> 00:05:23,039
inspiration from but they weren't

00:05:20,550 --> 00:05:24,300
designed to work with C so we as I said

00:05:23,039 --> 00:05:26,370
you know as I mentioned before we allow

00:05:24,300 --> 00:05:29,370
out-of-bounds pointers between D

00:05:26,370 --> 00:05:31,800
references we can store 64 bit full

00:05:29,370 --> 00:05:33,720
64-bit integers untagged in memory

00:05:31,800 --> 00:05:36,570
because in the in the pointer because we

00:05:33,720 --> 00:05:39,599
do that either most often we store

00:05:36,570 --> 00:05:42,389
Sentinel values so things near 0 minus 1

00:05:39,599 --> 00:05:45,090
when we're returning from a map and in

00:05:42,389 --> 00:05:46,860
an error or that sort of thing but there

00:05:45,090 --> 00:05:50,840
are coding models where you need to

00:05:46,860 --> 00:05:53,970
store full integers inside a pointer and

00:05:50,840 --> 00:05:55,590
importantly we don't have any tables so

00:05:53,970 --> 00:05:59,340
we don't have a protection lookaside

00:05:55,590 --> 00:06:02,190
buffer we don't have MP X's strewing

00:05:59,340 --> 00:06:04,800
your bounds all across memory and taking

00:06:02,190 --> 00:06:09,720
with I think normal virtualization up to

00:06:04,800 --> 00:06:11,550
192 page faults to read a byte so we

00:06:09,720 --> 00:06:13,020
don't do that we take we don't increase

00:06:11,550 --> 00:06:16,050
the number of page faults that you take

00:06:13,020 --> 00:06:17,849
except insofar as your structures got a

00:06:16,050 --> 00:06:20,370
bit bigger so you know cache effects in

00:06:17,849 --> 00:06:22,500
the life we support two compilation

00:06:20,370 --> 00:06:24,900
modes a hybrid mode where we annotate

00:06:22,500 --> 00:06:26,759
select pointers as being capabilities so

00:06:24,900 --> 00:06:28,349
they become their capabilities and the

00:06:26,759 --> 00:06:28,970
rest of the pointers remain flat virtual

00:06:28,349 --> 00:06:31,259
addresses

00:06:28,970 --> 00:06:33,710
additionally support appear capability

00:06:31,259 --> 00:06:37,880
mode where all pointers are capabilities

00:06:33,710 --> 00:06:41,159
that's the focus of the work today so

00:06:37,880 --> 00:06:43,610
chary api takes that compilation mode

00:06:41,159 --> 00:06:45,960
and we've built a pure capability

00:06:43,610 --> 00:06:48,630
process environment

00:06:45,960 --> 00:06:51,600
within FreeBSD so we've added a new

00:06:48,630 --> 00:06:59,460
compatibility layer much like FreeBSD 32

00:06:51,600 --> 00:07:02,040
yes you have a question oh so it's the

00:06:59,460 --> 00:07:04,250
question is what are the implications of

00:07:02,040 --> 00:07:07,920
context which is are they still required

00:07:04,250 --> 00:07:09,240
in the current system the contacts which

00:07:07,920 --> 00:07:11,310
there's more context which overhead

00:07:09,240 --> 00:07:15,270
because there are more registers so we

00:07:11,310 --> 00:07:18,180
we we take that that cost and we retain

00:07:15,270 --> 00:07:21,270
the classic virtualization model we have

00:07:18,180 --> 00:07:24,000
work in progress where we are looking at

00:07:21,270 --> 00:07:25,320
a single address space units where there

00:07:24,000 --> 00:07:27,710
would still be a context which it which

00:07:25,320 --> 00:07:30,660
is didn't say you swap your register set

00:07:27,710 --> 00:07:32,970
but you wouldn't swap your address space

00:07:30,660 --> 00:07:37,590
potentially but that's that's research

00:07:32,970 --> 00:07:39,480
field let's see so all programs here are

00:07:37,590 --> 00:07:40,920
you know as it's in the peer capability

00:07:39,480 --> 00:07:43,050
mode so all pointers are capabilities

00:07:40,920 --> 00:07:47,220
then include system call arguments and

00:07:43,050 --> 00:07:50,430
return values our goals are our goal is

00:07:47,220 --> 00:07:52,080
to minimize bounds on objects both C

00:07:50,430 --> 00:07:54,570
language objects which is the compilers

00:07:52,080 --> 00:07:56,520
problem and the runtimes problem and

00:07:54,570 --> 00:07:59,100
what pointers returned by the kernel

00:07:56,520 --> 00:08:01,140
which is to say when um map some memory

00:07:59,100 --> 00:08:02,670
you get some memory by calling M map and

00:08:01,140 --> 00:08:05,580
you map a region of address space with

00:08:02,670 --> 00:08:07,890
some backing pages you get a capability

00:08:05,580 --> 00:08:12,630
that references that address base and

00:08:07,890 --> 00:08:14,700
nothing more and we have a that and our

00:08:12,630 --> 00:08:16,950
overall goal is a compatibility goal

00:08:14,700 --> 00:08:19,500
which is to run pure capability programs

00:08:16,950 --> 00:08:21,150
with simple recompilation we'd like you

00:08:19,500 --> 00:08:23,460
to get all the benefits of memory safety

00:08:21,150 --> 00:08:27,210
with no work we don't quite get there

00:08:23,460 --> 00:08:30,540
but I think we do pretty well so the

00:08:27,210 --> 00:08:31,800
implementation in the kernel it's as I

00:08:30,540 --> 00:08:34,880
said implement it as a compatibility

00:08:31,800 --> 00:08:37,760
layer much like 32-bit compat in freebsd

00:08:34,880 --> 00:08:39,930
the kernel is a hybrid seed program

00:08:37,760 --> 00:08:41,520
that's because we weren't ready to do

00:08:39,930 --> 00:08:44,120
pure capability and because the kernel

00:08:41,520 --> 00:08:46,710
does a lot of evil things with addresses

00:08:44,120 --> 00:08:48,650
so it was easier not to solve all the

00:08:46,710 --> 00:08:51,780
problems at once

00:08:48,650 --> 00:08:53,520
and and we but we've modified both those

00:08:51,780 --> 00:08:54,780
all the pointers from user space or the

00:08:53,520 --> 00:08:58,590
system call arguments and as they

00:08:54,780 --> 00:08:59,279
percolate down and also select data

00:08:58,590 --> 00:09:02,629
structures

00:08:59,279 --> 00:09:05,370
struct IO vac which takes a vector of

00:09:02,629 --> 00:09:07,379
which is used a constructor vector of

00:09:05,370 --> 00:09:11,310
pointers and lengths inside the kernel

00:09:07,379 --> 00:09:13,670
those are now always capabilities so all

00:09:11,310 --> 00:09:16,559
user space accesses yif capabilities

00:09:13,670 --> 00:09:18,180
it's and it's direct the direct access

00:09:16,559 --> 00:09:22,490
so we have a set of new copy and copy

00:09:18,180 --> 00:09:24,930
out functions for the ordinary path and

00:09:22,490 --> 00:09:27,420
when you're in a cherry API program we

00:09:24,930 --> 00:09:29,279
have broken the old ones completely we

00:09:27,420 --> 00:09:31,649
haven't removed them because it's a

00:09:29,279 --> 00:09:34,259
bunch of work and I don't need to fix I

00:09:31,649 --> 00:09:37,860
3d6 only drivers and things like that

00:09:34,259 --> 00:09:40,319
but and by default capabilities aren't

00:09:37,860 --> 00:09:43,110
copied from user space to the kernel or

00:09:40,319 --> 00:09:45,600
vac the reason for this is most of the

00:09:43,110 --> 00:09:47,009
time most structures that you're copying

00:09:45,600 --> 00:09:48,480
from the kernel don't contain

00:09:47,009 --> 00:09:50,069
capabilities or shouldn't and you don't

00:09:48,480 --> 00:09:53,009
want to be leaking them back and forth

00:09:50,069 --> 00:09:55,949
not because I think the kernel has bugs

00:09:53,009 --> 00:09:57,629
in this area but because I'm paranoid I

00:09:55,949 --> 00:09:58,589
don't I don't want to introduce the

00:09:57,629 --> 00:10:00,600
possibility of bugs

00:09:58,589 --> 00:10:02,519
I would like this small number of copy

00:10:00,600 --> 00:10:04,740
and cap and copy out cap calls to be

00:10:02,519 --> 00:10:07,439
something I could audit in a couple days

00:10:04,740 --> 00:10:10,620
and right now I could audit them all in

00:10:07,439 --> 00:10:11,910
a day it's fairly straightforward if you

00:10:10,620 --> 00:10:13,259
were got it all the way down the call

00:10:11,910 --> 00:10:14,699
stack from those points it would be more

00:10:13,259 --> 00:10:17,360
work but it's it's something you could

00:10:14,699 --> 00:10:21,120
do so that was an important design goal

00:10:17,360 --> 00:10:23,129
so let me step aside and talk a little

00:10:21,120 --> 00:10:24,629
bit about a theoretical concept that we

00:10:23,129 --> 00:10:27,029
came up with in the process of this work

00:10:24,629 --> 00:10:28,019
which is the abstract capability so one

00:10:27,029 --> 00:10:29,610
of the issues we have when you're

00:10:28,019 --> 00:10:31,079
thinking about this theoretically is how

00:10:29,610 --> 00:10:34,829
how should the programmers think about

00:10:31,079 --> 00:10:36,600
bounds if you have a mental model of how

00:10:34,829 --> 00:10:39,360
C should work or a theoretical model of

00:10:36,600 --> 00:10:42,540
how C should work the kernel user space

00:10:39,360 --> 00:10:44,579
interaction is really kind of weird so

00:10:42,540 --> 00:10:46,350
we came with this idea the abstract

00:10:44,579 --> 00:10:49,620
capability there's a set of permissions

00:10:46,350 --> 00:10:52,439
of the process which is to say the pages

00:10:49,620 --> 00:10:53,939
that can be accessed and what it means

00:10:52,439 --> 00:10:57,959
when you load from a particular virtual

00:10:53,939 --> 00:10:59,639
address for instance this includes a

00:10:57,959 --> 00:11:02,399
certain amount of ghost State such as

00:10:59,639 --> 00:11:05,519
the fact that when you swap a page out

00:11:02,399 --> 00:11:07,110
it may have made store permissions and

00:11:05,519 --> 00:11:08,879
that's not available it also includes

00:11:07,110 --> 00:11:11,850
the address mapping in the current in

00:11:08,879 --> 00:11:13,560
the program so at any given moment you

00:11:11,850 --> 00:11:15,870
might have to take

00:11:13,560 --> 00:11:17,850
tlb faults in order to access particular

00:11:15,870 --> 00:11:19,500
pages of physical memory this all

00:11:17,850 --> 00:11:24,060
constructed and maintained by the kernel

00:11:19,500 --> 00:11:26,940
and the language runtime so let's talk

00:11:24,060 --> 00:11:28,830
about how it is at power up when the

00:11:26,940 --> 00:11:31,380
system powers on we have two

00:11:28,830 --> 00:11:32,850
capabilities in the system the default

00:11:31,380 --> 00:11:35,790
data capability and the program counter

00:11:32,850 --> 00:11:37,709
capability are both omniscient you could

00:11:35,790 --> 00:11:40,200
take a stronger view and do a WX or X

00:11:37,709 --> 00:11:43,290
thing here but we have not because that

00:11:40,200 --> 00:11:45,050
would be a lot of work and then all the

00:11:43,290 --> 00:11:48,300
other capability registers are now

00:11:45,050 --> 00:11:52,649
additionally all the tags in memory are

00:11:48,300 --> 00:11:55,170
clear so in early in boot we start doing

00:11:52,649 --> 00:11:57,600
some capability manipulation we take the

00:11:55,170 --> 00:12:00,200
DDC and in the kernel we stripped the

00:11:57,600 --> 00:12:03,920
execute bit off of it so we're W X or X

00:12:00,200 --> 00:12:06,950
from the very beginning of Lokar

00:12:03,920 --> 00:12:09,360
similarly we take the right bit off PCC

00:12:06,950 --> 00:12:10,680
so you have to at least be principled in

00:12:09,360 --> 00:12:14,370
your axis even if they are fully

00:12:10,680 --> 00:12:16,680
overlapping we then create a user root

00:12:14,370 --> 00:12:18,360
capability which is only contains the

00:12:16,680 --> 00:12:21,149
portion of address space that user the

00:12:18,360 --> 00:12:23,300
user can access a swap root capability

00:12:21,149 --> 00:12:25,890
which is unfortunately omniscient

00:12:23,300 --> 00:12:27,690
because we need to restore anything that

00:12:25,890 --> 00:12:33,709
might be swapped out and that currently

00:12:27,690 --> 00:12:37,410
does include some kernel things it's

00:12:33,709 --> 00:12:44,220
pretend it's in the working set the

00:12:37,410 --> 00:12:46,350
order of operations differs no well I

00:12:44,220 --> 00:12:47,730
mean the swap capability is an obnoxious

00:12:46,350 --> 00:12:57,480
backdoor we'd like to do something about

00:12:47,730 --> 00:12:59,459
that yes the the swap root is this is

00:12:57,480 --> 00:13:02,490
all X and that's from zero so it's the

00:12:59,459 --> 00:13:06,449
entire range of address space that's to

00:13:02,490 --> 00:13:07,800
be fixed so now so we that's sort of the

00:13:06,449 --> 00:13:09,240
basics of setting up the carnal the

00:13:07,800 --> 00:13:11,760
kernel doesn't do much more manipulation

00:13:09,240 --> 00:13:14,310
beyond setting up user address spaces so

00:13:11,760 --> 00:13:16,500
let's talk about user address spaces so

00:13:14,310 --> 00:13:18,839
when we're exacting a program we have an

00:13:16,500 --> 00:13:20,579
initial register file which is zeroed we

00:13:18,839 --> 00:13:24,600
have a weak mapping a thread stack a

00:13:20,579 --> 00:13:26,580
program binary the runtime linker some

00:13:24,600 --> 00:13:29,490
process arguments base that

00:13:26,580 --> 00:13:31,230
the argument to environment strings the

00:13:29,490 --> 00:13:34,279
elf axillary arguments factor the

00:13:31,230 --> 00:13:37,380
environment vector the argument vector

00:13:34,279 --> 00:13:41,459
is pointing to the strings in various

00:13:37,380 --> 00:13:42,390
places this is all this is all basically

00:13:41,459 --> 00:13:44,100
normal

00:13:42,390 --> 00:13:45,600
we have pointers back to the program in

00:13:44,100 --> 00:13:47,279
the runtime linker the only difference

00:13:45,600 --> 00:13:49,020
here is that the pointers are all

00:13:47,279 --> 00:13:51,959
capability pointers and they're bounded

00:13:49,020 --> 00:13:54,690
more or less appropriately in cherry ABI

00:13:51,959 --> 00:13:56,779
I said you know don't EDC is where a DD

00:13:54,690 --> 00:13:58,830
C is where you access use MIPS

00:13:56,779 --> 00:14:00,089
instructions well we make it null here

00:13:58,830 --> 00:14:02,149
so you can't use legacy MIPS

00:14:00,089 --> 00:14:04,440
instructions you must use capabilities

00:14:02,149 --> 00:14:07,800
we have a program counter capability

00:14:04,440 --> 00:14:10,260
points to the runtime linker we have the

00:14:07,800 --> 00:14:12,779
stack we point it in the right place and

00:14:10,260 --> 00:14:15,839
then we have changed the process ABI

00:14:12,779 --> 00:14:17,670
normally you pass either on the either

00:14:15,839 --> 00:14:19,410
through your stack argument convention

00:14:17,670 --> 00:14:23,820
on x86 or through your register

00:14:19,410 --> 00:14:26,279
convention you pass arg c RV and env as

00:14:23,820 --> 00:14:28,529
the arguments to the start function in

00:14:26,279 --> 00:14:30,600
our case we pass only the pointer of the

00:14:28,529 --> 00:14:33,060
elf axillary arguments vector and we've

00:14:30,600 --> 00:14:34,800
extended it to have pointers to the

00:14:33,060 --> 00:14:36,300
other to the other bit so we do all our

00:14:34,800 --> 00:14:38,550
rendezvous through the elf exhilarate

00:14:36,300 --> 00:14:45,660
arguments vector it's much easier it's

00:14:38,550 --> 00:14:47,089
extensible and sorry yeah I think well I

00:14:45,660 --> 00:14:50,520
probably took some inspiration

00:14:47,089 --> 00:14:51,779
incidentally from cloud API and was

00:14:50,520 --> 00:14:55,200
starting to do much of that work about

00:14:51,779 --> 00:14:57,060
the time I was working on this so now

00:14:55,200 --> 00:15:00,170
virtual memory the virtual memory system

00:14:57,060 --> 00:15:03,329
has both have programmer visible aspects

00:15:00,170 --> 00:15:04,860
which is to say that it allocates read

00:15:03,329 --> 00:15:06,870
new regions of address space to a

00:15:04,860 --> 00:15:08,670
process and arranges their map their

00:15:06,870 --> 00:15:11,520
backings that's via M map and friends

00:15:08,670 --> 00:15:14,850
and xem app it also alters and frees

00:15:11,520 --> 00:15:16,920
mappings and then abstract capability

00:15:14,850 --> 00:15:18,959
baton it's which is it's responsible for

00:15:16,920 --> 00:15:20,550
ensuring that your virtual the physical

00:15:18,959 --> 00:15:23,339
mapping is correct we haven't done

00:15:20,550 --> 00:15:25,399
anything here we are assuming that the

00:15:23,339 --> 00:15:28,200
FreeBSD kernel is correct in this regard

00:15:25,399 --> 00:15:30,089
I think generally we believe that's true

00:15:28,200 --> 00:15:33,089
or we boxes would be getting owned left

00:15:30,089 --> 00:15:35,040
and right so we're just count on that

00:15:33,089 --> 00:15:36,810
it also perverse preserves stored

00:15:35,040 --> 00:15:38,820
capabilities so we'll talk about that in

00:15:36,810 --> 00:15:40,230
a little bit first

00:15:38,820 --> 00:15:43,260
M map

00:15:40,230 --> 00:15:45,390
m-matt has an annoyingly conflated set

00:15:43,260 --> 00:15:47,340
of jobs it allocates virtual address

00:15:45,390 --> 00:15:50,550
space and it puts pages behind those

00:15:47,340 --> 00:15:52,050
behind that and it can do one that it's

00:15:50,550 --> 00:15:56,520
one and then it can poke things in and

00:15:52,050 --> 00:16:02,010
out it's it's a terrible API so chary

00:15:56,520 --> 00:16:05,190
api and map returns a bounded pointer so

00:16:02,010 --> 00:16:07,710
if you make a really weirdly sized m map

00:16:05,190 --> 00:16:09,510
request right now we just reject that if

00:16:07,710 --> 00:16:12,930
if we can't represent that due to the

00:16:09,510 --> 00:16:14,520
floating-point use in our current in our

00:16:12,930 --> 00:16:17,490
current model we're not seeing problems

00:16:14,520 --> 00:16:19,740
with it in practice but there are there

00:16:17,490 --> 00:16:23,130
is work to be done to make it easier so

00:16:19,740 --> 00:16:25,200
to map really strange sized things so

00:16:23,130 --> 00:16:29,040
users have to round up unreasonable

00:16:25,200 --> 00:16:32,700
requests and then permissions are based

00:16:29,040 --> 00:16:34,500
on the page permissions requested in the

00:16:32,700 --> 00:16:38,100
in the m map request so their pointer

00:16:34,500 --> 00:16:41,100
permissions to allow a semi common

00:16:38,100 --> 00:16:43,290
pattern of doing a prot none which is to

00:16:41,100 --> 00:16:45,750
say no permissions and then poking holes

00:16:43,290 --> 00:16:47,250
in it to map things this is Vince's used

00:16:45,750 --> 00:16:52,080
in the runtime linker so slightly

00:16:47,250 --> 00:16:55,800
important we've added to cherry BSD and

00:16:52,080 --> 00:16:57,390
also to FreeBSD now a max prot macro

00:16:55,800 --> 00:17:01,140
which allows you to specify the maximum

00:16:57,390 --> 00:17:03,780
permissions of a of the page that both

00:17:01,140 --> 00:17:06,120
enforces that in in the virtual memory

00:17:03,780 --> 00:17:09,680
system and tells us what permissions we

00:17:06,120 --> 00:17:13,110
should actually use for that pointer

00:17:09,680 --> 00:17:16,050
slightly annoyingly I did it about the

00:17:13,110 --> 00:17:17,610
same time net bsd did something else and

00:17:16,050 --> 00:17:19,260
we have slightly different semantics and

00:17:17,610 --> 00:17:23,840
they're incompatible but it's m map

00:17:19,260 --> 00:17:23,840
every extension is a incompatible mess

00:17:24,560 --> 00:17:28,590
and then so swap I'm gonna give you a

00:17:26,910 --> 00:17:31,050
quick picture of how we do swap so let's

00:17:28,590 --> 00:17:34,830
consider a user page a little page of

00:17:31,050 --> 00:17:37,050
user memory here and then we have a file

00:17:34,830 --> 00:17:38,370
store we haven't touched device drivers

00:17:37,050 --> 00:17:41,060
and storage and whatnot

00:17:38,370 --> 00:17:41,060
in question

00:17:51,570 --> 00:17:57,130
know it so it has two functions one is

00:17:55,180 --> 00:17:59,200
it it controls the maximum permissions

00:17:57,130 --> 00:18:00,730
of the page that your current the pages

00:17:59,200 --> 00:18:03,730
you're currently mapping rather than

00:18:00,730 --> 00:18:07,240
doing it sort of some way implicitly it

00:18:03,730 --> 00:18:10,330
also so if you say prop max of read

00:18:07,240 --> 00:18:14,560
write on a page you can not later and

00:18:10,330 --> 00:18:16,480
protect it to be executable we enforce

00:18:14,560 --> 00:18:18,400
that the second thing is for capably the

00:18:16,480 --> 00:18:19,960
capabilities we choose the permit we

00:18:18,400 --> 00:18:21,610
derive the permissions from the max prot

00:18:19,960 --> 00:18:25,300
if you give one rather than from the

00:18:21,610 --> 00:18:27,340
permissions because you need if your

00:18:25,300 --> 00:18:28,570
mapping if you need a single pointer

00:18:27,340 --> 00:18:30,280
that can be used for a run to the

00:18:28,570 --> 00:18:35,740
runtime linker it needs to be an RW x

00:18:30,280 --> 00:18:37,600
pointer so we've got unmodified tag

00:18:35,740 --> 00:18:40,090
storage here where we've got unmodified

00:18:37,600 --> 00:18:42,430
storage here it's just disk as usual we

00:18:40,090 --> 00:18:46,390
want to swap out to it so we create a

00:18:42,430 --> 00:18:49,150
tag bitmap that we store in the swap

00:18:46,390 --> 00:18:51,700
structure currently and we store that

00:18:49,150 --> 00:18:55,890
alongside and then we store the contents

00:18:51,700 --> 00:18:59,290
of the page in in memory or in in

00:18:55,890 --> 00:19:01,720
spinning rust or whatever and then on

00:18:59,290 --> 00:19:03,730
restore we combine that information with

00:19:01,720 --> 00:19:06,550
the swap root capability to reader I of

00:19:03,730 --> 00:19:08,560
these capabilities so that's that's how

00:19:06,550 --> 00:19:12,310
we preserve from the user's perspective

00:19:08,560 --> 00:19:16,000
that this page never left we preserve

00:19:12,310 --> 00:19:18,730
those capabilities so the runtime linker

00:19:16,000 --> 00:19:20,470
is involved in various bits of setup it

00:19:18,730 --> 00:19:22,900
links and loads runtime light dynamic

00:19:20,470 --> 00:19:24,970
libraries as usual it resolves symbols

00:19:22,900 --> 00:19:28,480
and synthesizes all the capabilities

00:19:24,970 --> 00:19:30,370
within the process one interesting thing

00:19:28,480 --> 00:19:32,740
with capabilities is that even a

00:19:30,370 --> 00:19:34,030
statically linked program has a has a

00:19:32,740 --> 00:19:36,130
pointer synthesis

00:19:34,030 --> 00:19:37,630
portion of the startup where it has to

00:19:36,130 --> 00:19:40,450
create all the Global's that are

00:19:37,630 --> 00:19:42,400
pointers and derive them at runtime

00:19:40,450 --> 00:19:45,760
because we can't just store them linked

00:19:42,400 --> 00:19:48,070
on disk and they jumps to the program

00:19:45,760 --> 00:19:49,750
entry point and then the program runs as

00:19:48,070 --> 00:19:51,940
usual there's a little bit of additional

00:19:49,750 --> 00:19:54,130
runtime linker interaction both demand

00:19:51,940 --> 00:19:56,920
loading of libraries and handling it

00:19:54,130 --> 00:20:00,940
doing exception handling

00:19:56,920 --> 00:20:03,400
the C runtime is a intimately involved

00:20:00,940 --> 00:20:05,020
in all sorts of bits of capability

00:20:03,400 --> 00:20:08,770
preservation and setting bounds

00:20:05,020 --> 00:20:10,690
appropriately so malloc when you malloc

00:20:08,770 --> 00:20:12,340
memory the bounds are set to the

00:20:10,690 --> 00:20:14,430
requested size or at least a slightly

00:20:12,340 --> 00:20:16,660
rounded version of the requested size

00:20:14,430 --> 00:20:19,510
depending on the requirements in order

00:20:16,660 --> 00:20:21,400
to make that that bound only cover the

00:20:19,510 --> 00:20:24,790
allocation the underlying allocation

00:20:21,400 --> 00:20:26,530
realloc either adjusts bounds in the

00:20:24,790 --> 00:20:29,470
case that there's an in-place expansion

00:20:26,530 --> 00:20:32,830
available or allocates new storage and

00:20:29,470 --> 00:20:35,050
then thread local storage is allocated

00:20:32,830 --> 00:20:37,480
through it yet another malloc

00:20:35,050 --> 00:20:55,960
implementation it is currently bounded

00:20:37,480 --> 00:20:59,020
per thread question okay so so the

00:20:55,960 --> 00:21:01,840
question is basically about rounding in

00:20:59,020 --> 00:21:03,400
malloc and if malloc rounds up for

00:21:01,840 --> 00:21:05,200
various reasons is the capability the

00:21:03,400 --> 00:21:14,470
original the requested size or the

00:21:05,200 --> 00:21:17,500
rounded size the answer is both yes yeah

00:21:14,470 --> 00:21:20,590
so that so the the slightly more

00:21:17,500 --> 00:21:22,720
detailed answer is if the if what you

00:21:20,590 --> 00:21:25,300
requested is representable which is to

00:21:22,720 --> 00:21:27,490
say so what don't say anything under a

00:21:25,300 --> 00:21:30,760
page is representable in practice if you

00:21:27,490 --> 00:21:34,650
asked for 4k minus one you will get a

00:21:30,760 --> 00:21:36,790
capability to 4k minus one address space

00:21:34,650 --> 00:21:40,510
malloc will have allocated a page

00:21:36,790 --> 00:21:43,360
probably if you ask for some weirdly

00:21:40,510 --> 00:21:45,130
shaped thing that's very large we will

00:21:43,360 --> 00:21:49,000
have to round it up and round up its

00:21:45,130 --> 00:21:50,170
alignment in order to for the in order

00:21:49,000 --> 00:21:52,180
for the capability to be fully

00:21:50,170 --> 00:21:56,860
represented we will give you them the

00:21:52,180 --> 00:21:59,370
smallest capability we can but we will

00:21:56,860 --> 00:22:06,040
have rounded up both your allocation and

00:21:59,370 --> 00:22:08,440
and the bounds so in addition to the

00:22:06,040 --> 00:22:10,750
these bits in the runtime library the

00:22:08,440 --> 00:22:11,920
compiler generates bounds if you for

00:22:10,750 --> 00:22:14,170
instance take a reference to something

00:22:11,920 --> 00:22:17,530
to a stack and pass it to a function we

00:22:14,170 --> 00:22:21,450
give we bound that reference and as well

00:22:17,530 --> 00:22:21,450
as we bound references to global objects

00:22:23,310 --> 00:22:26,590
okay

00:22:24,490 --> 00:22:28,510
let's consider system calls since a lot

00:22:26,590 --> 00:22:30,460
of the point of this whole work was that

00:22:28,510 --> 00:22:32,140
I I wanted pure capability programs to

00:22:30,460 --> 00:22:35,290
have system have their system call

00:22:32,140 --> 00:22:36,760
pointers be respected by the kernel so

00:22:35,290 --> 00:22:39,190
that we don't have a potential confused

00:22:36,760 --> 00:22:41,290
deputy TAC or for instance we call read

00:22:39,190 --> 00:22:45,190
with a buffer of length you know let's

00:22:41,290 --> 00:22:46,660
say 10 and n bytes of 20 you could for

00:22:45,190 --> 00:22:48,490
instance if the kernel didn't respect

00:22:46,660 --> 00:22:50,560
your capability pointers you could use

00:22:48,490 --> 00:22:53,590
the kernel to implement for instance the

00:22:50,560 --> 00:22:56,920
stack buffer overflow interestingly I

00:22:53,590 --> 00:22:58,750
haven't found a single case of these I'm

00:22:56,920 --> 00:23:00,430
sure they exist in people have exploited

00:22:58,750 --> 00:23:02,010
this sort of thing but I suspect that no

00:23:00,430 --> 00:23:04,420
one's bothered in practice because

00:23:02,010 --> 00:23:05,210
unmodified C is so terrible why would

00:23:04,420 --> 00:23:07,279
you even have to

00:23:05,210 --> 00:23:11,690
involved the colonel most of the time to

00:23:07,279 --> 00:23:14,450
break it so we have got a thread stack

00:23:11,690 --> 00:23:16,039
we put a buffer on it we're gonna go

00:23:14,450 --> 00:23:17,270
call a system call so we load an

00:23:16,039 --> 00:23:19,010
argument that says hey we're gonna call

00:23:17,270 --> 00:23:20,390
the read system call another one that

00:23:19,010 --> 00:23:22,630
says here's our file descriptor

00:23:20,390 --> 00:23:26,570
here's a capability to the buffer and

00:23:22,630 --> 00:23:28,789
here's the length we then call into the

00:23:26,570 --> 00:23:32,750
kernel that in our case calls into the

00:23:28,789 --> 00:23:35,029
cherry ABI read call it calls in turn

00:23:32,750 --> 00:23:36,980
calls Kern read V which is the

00:23:35,029 --> 00:23:40,370
implementation of read in the general

00:23:36,980 --> 00:23:44,299
case bit more work eventually we got a

00:23:40,370 --> 00:23:49,549
copy out this copy out uses is in fact a

00:23:44,299 --> 00:23:52,549
copy out C uses this buffer and if that

00:23:49,549 --> 00:23:54,289
if your length is wrong you will you'll

00:23:52,549 --> 00:23:59,690
get a Fault in the copy out and you'll

00:23:54,289 --> 00:24:01,220
get a EEPROM error so let's consider

00:23:59,690 --> 00:24:02,419
some kernel change changes we had to

00:24:01,220 --> 00:24:06,169
make to the kernel to make this all work

00:24:02,419 --> 00:24:07,730
so here's the the the user read thing

00:24:06,169 --> 00:24:09,679
which is sits in the middle of that

00:24:07,730 --> 00:24:12,830
stack where the dots were where some of

00:24:09,679 --> 00:24:14,740
the dots were it is abstracted out so

00:24:12,830 --> 00:24:18,200
it's it's basically it takes the normal

00:24:14,740 --> 00:24:20,740
arguments to read the thread pointer

00:24:18,200 --> 00:24:26,059
file descriptor capability buffer now

00:24:20,740 --> 00:24:27,799
and and bite it does the usual bits of

00:24:26,059 --> 00:24:32,570
checking we have a new macro that we've

00:24:27,799 --> 00:24:34,520
right now we have a new set of macros

00:24:32,570 --> 00:24:37,279
from regulating I of X that's because I

00:24:34,520 --> 00:24:38,720
of X now have capability annotations I

00:24:37,279 --> 00:24:40,610
didn't want to have to write capability

00:24:38,720 --> 00:24:44,179
everywhere I can't type it even after

00:24:40,610 --> 00:24:46,669
working on this project for 8 years we

00:24:44,179 --> 00:24:48,590
so I can't type it fast so we have a new

00:24:46,669 --> 00:24:52,669
set of macros that init that manipulate

00:24:48,590 --> 00:24:54,590
I of X and then that's really most of

00:24:52,669 --> 00:24:57,169
the changes this function is also new

00:24:54,590 --> 00:24:59,360
because I've added extra compatibility

00:24:57,169 --> 00:25:03,230
layers and I'm now allergic to duplicate

00:24:59,360 --> 00:25:05,360
code so this would typically be in the

00:25:03,230 --> 00:25:07,760
sis implementation or in the Cherry ibi

00:25:05,360 --> 00:25:12,230
implementation and now I have a freebsd

00:25:07,760 --> 00:25:13,850
64 implementation so life is better when

00:25:12,230 --> 00:25:18,779
I just add more functions so I'm doing

00:25:13,850 --> 00:25:22,019
that like any proper computer scientist

00:25:18,779 --> 00:25:25,559
so another another example of changes

00:25:22,019 --> 00:25:27,809
when I talked before about very briefly

00:25:25,559 --> 00:25:30,509
about how about capability manipulation

00:25:27,809 --> 00:25:33,419
well the old bit of code here is an

00:25:30,509 --> 00:25:34,799
example of a semi common pattern which

00:25:33,419 --> 00:25:36,570
violates the rule so you're taking

00:25:34,799 --> 00:25:41,190
you've done up here you've done a

00:25:36,570 --> 00:25:43,350
reallocation of memory you're replacing

00:25:41,190 --> 00:25:47,850
this let's see where are we going here

00:25:43,350 --> 00:25:51,450
you're replacing this words with a noose

00:25:47,850 --> 00:25:54,840
with a new string or you're replacing

00:25:51,450 --> 00:25:56,490
pointers into in into those right

00:25:54,840 --> 00:26:00,179
exploiters into a copy of this this

00:25:56,490 --> 00:26:01,919
strings very member and you're doing an

00:26:00,179 --> 00:26:04,289
update in a way if it works because

00:26:01,919 --> 00:26:05,759
integer virtual address integers virtual

00:26:04,289 --> 00:26:07,950
addresses or pointers here in the old

00:26:05,759 --> 00:26:10,649
world so you've got this old pointer

00:26:07,950 --> 00:26:11,999
we're just gonna increment it by the

00:26:10,649 --> 00:26:15,749
difference between the new and old

00:26:11,999 --> 00:26:18,119
allocation the provenance is wrong here

00:26:15,749 --> 00:26:19,740
so you've now you know derived from the

00:26:18,119 --> 00:26:22,289
old value not the new one so we have to

00:26:19,740 --> 00:26:24,720
make this change here so we derive the

00:26:22,289 --> 00:26:27,179
value from the new pointer rather than

00:26:24,720 --> 00:26:28,289
the old one it's a simple change it's

00:26:27,179 --> 00:26:31,919
worth noting that this is still

00:26:28,289 --> 00:26:34,019
undefined behavior and and that

00:26:31,919 --> 00:26:36,149
basically no use of realloc that isn't

00:26:34,019 --> 00:26:40,889
reality extending a string or an array

00:26:36,149 --> 00:26:47,159
is anything but you be just stop

00:26:40,889 --> 00:26:50,100
don't use realloc that's bad so a quick

00:26:47,159 --> 00:26:53,159
summary of the changes we had to make so

00:26:50,100 --> 00:26:56,369
in userspace we changed about 200 files

00:26:53,159 --> 00:26:59,490
in in the freebsd source tree that's may

00:26:56,369 --> 00:27:02,369
have 1% ish those changes are mostly in

00:26:59,490 --> 00:27:05,240
libraries and most programs required no

00:27:02,369 --> 00:27:08,090
changes so to give an example here

00:27:05,240 --> 00:27:12,509
OpenSSL required a number of changes

00:27:08,090 --> 00:27:15,480
because OpenSSL does some interesting

00:27:12,509 --> 00:27:17,999
things in in an attempt to do constant

00:27:15,480 --> 00:27:20,850
constant time conditional assignment it

00:27:17,999 --> 00:27:22,919
X ORS pointers needless to say that it's

00:27:20,850 --> 00:27:26,070
not a capability pointer operation that

00:27:22,919 --> 00:27:27,990
we support it's trying to hide the fact

00:27:26,070 --> 00:27:30,749
from the compiler to ensure that both

00:27:27,990 --> 00:27:32,010
branches are taken ironically if they

00:27:30,749 --> 00:27:34,950
did if the code was

00:27:32,010 --> 00:27:36,930
open coded which is to say do one thing

00:27:34,950 --> 00:27:39,300
or the other thing the compiler probably

00:27:36,930 --> 00:27:40,950
would have turned it into a C move which

00:27:39,300 --> 00:27:45,990
is more likely to be constant than the

00:27:40,950 --> 00:27:48,630
mess that they made but here we are so

00:27:45,990 --> 00:27:51,090
but but interesting OpenSSH for instance

00:27:48,630 --> 00:27:54,690
only required one change and that change

00:27:51,090 --> 00:27:56,520
was to stop sending pointers to members

00:27:54,690 --> 00:28:02,850
of an array between the child and parent

00:27:56,520 --> 00:28:06,330
that's been fixed I think we have one

00:28:02,850 --> 00:28:07,950
yeah I think we do there is one thing to

00:28:06,330 --> 00:28:10,800
be aware of with using C move for

00:28:07,950 --> 00:28:13,170
constant time operation no is a actually

00:28:10,800 --> 00:28:16,680
guarantees that it's constant or in fact

00:28:13,170 --> 00:28:22,620
that both sides are evaluated because

00:28:16,680 --> 00:28:24,690
superscalar but anyway the kernel we had

00:28:22,620 --> 00:28:26,790
more changes so we had about 6% of lines

00:28:24,690 --> 00:28:29,790
of code this is because we're doing a

00:28:26,790 --> 00:28:31,560
hybrid program so everywhere our user

00:28:29,790 --> 00:28:33,870
space our pointer comes down from user

00:28:31,560 --> 00:28:37,260
space and ends up somewhere we have to

00:28:33,870 --> 00:28:40,290
change the file additionally every

00:28:37,260 --> 00:28:42,990
network driver that takes a struct if

00:28:40,290 --> 00:28:46,050
rack in one of our prototype in point in

00:28:42,990 --> 00:28:48,900
our 256 bit implementation which was the

00:28:46,050 --> 00:28:51,180
initial prototype the size of effect

00:28:48,900 --> 00:28:56,100
changes because it's it's a structure

00:28:51,180 --> 00:28:58,500
with a 16 byte name and then and then a

00:28:56,100 --> 00:29:02,370
pointer so there's an alignment gap and

00:28:58,500 --> 00:29:03,270
now I had to edit all those files so in

00:29:02,370 --> 00:29:07,160
case you were wondering why always

00:29:03,270 --> 00:29:07,160
deleting old network drivers that's why

00:29:08,720 --> 00:29:14,280
so they're pervasive changes a peer

00:29:12,780 --> 00:29:15,870
capability kernel would definitely

00:29:14,280 --> 00:29:17,310
reduce the number of changes although it

00:29:15,870 --> 00:29:19,140
would introduce new changes in the vm

00:29:17,310 --> 00:29:22,980
system for instance detangling the

00:29:19,140 --> 00:29:24,060
concept of virtual address which

00:29:22,980 --> 00:29:27,060
sometimes you're definitely talking

00:29:24,060 --> 00:29:28,470
about virtual address and pointer

00:29:27,060 --> 00:29:31,350
because sometimes you're definitely

00:29:28,470 --> 00:29:34,080
getting a pointer and the kernel musha's

00:29:31,350 --> 00:29:35,100
those together a bit so we've we're we

00:29:34,080 --> 00:29:37,560
have a grad student who's working on

00:29:35,100 --> 00:29:40,980
this and there's a bunch of science you

00:29:37,560 --> 00:29:42,330
have to do so one thing it's useful one

00:29:40,980 --> 00:29:45,330
thing it's good to note here many of

00:29:42,330 --> 00:29:45,710
these changes improve code quality or

00:29:45,330 --> 00:29:47,840
just

00:29:45,710 --> 00:29:49,220
we're just writing better see because

00:29:47,840 --> 00:29:55,900
we're not allowing you to be quite so

00:29:49,220 --> 00:29:58,190
clever how many bugs in existing code um

00:29:55,900 --> 00:30:01,430
fewer that I might have expected when we

00:29:58,190 --> 00:30:03,020
started out we were mostly finding quite

00:30:01,430 --> 00:30:04,640
small subtle things

00:30:03,020 --> 00:30:06,320
I mean we're finding things like that

00:30:04,640 --> 00:30:08,810
realloc mess that I shared you that was

00:30:06,320 --> 00:30:12,440
has like three instances of you be in

00:30:08,810 --> 00:30:15,830
six lines of code but mostly we're

00:30:12,440 --> 00:30:19,880
finding very subtle off by ones so I

00:30:15,830 --> 00:30:21,830
think my favorite example is in this in

00:30:19,880 --> 00:30:24,200
the tea shell implementation that's the

00:30:21,830 --> 00:30:27,440
default on FreeBSD if you hit tab on a

00:30:24,200 --> 00:30:30,170
blank line prior to the change that we

00:30:27,440 --> 00:30:33,650
made you read one byte before the

00:30:30,170 --> 00:30:36,980
beginning of a buffer however it's in

00:30:33,650 --> 00:30:44,570
BSS most people are on little endian

00:30:36,980 --> 00:30:47,750
systems that whites always zero I mean

00:30:44,570 --> 00:30:50,980
you know modulo compiler layout issues

00:30:47,750 --> 00:30:53,270
and linkers and everything so probably

00:30:50,980 --> 00:30:54,980
every once in a while somebody got a bad

00:30:53,270 --> 00:30:57,920
compiler hitting tab on the command line

00:30:54,980 --> 00:31:00,200
caused a crash but the extremely rare it

00:30:57,920 --> 00:31:02,960
was definitely always mapped memory so

00:31:00,200 --> 00:31:04,160
it's that sort of thing where you stick

00:31:02,960 --> 00:31:06,110
bounds on things you start finding

00:31:04,160 --> 00:31:08,510
strange things similarly we've found

00:31:06,110 --> 00:31:11,300
we've recently added support to a

00:31:08,510 --> 00:31:13,160
compiler for sub-object bounds which is

00:31:11,300 --> 00:31:16,070
to say if you take a reference to an

00:31:13,160 --> 00:31:19,280
array in a struct you can put bounds on

00:31:16,070 --> 00:31:21,290
it with some exceptions and we're

00:31:19,280 --> 00:31:25,220
finding more of those we found quite a

00:31:21,290 --> 00:31:27,940
few we think all hard most so far in Lib

00:31:25,220 --> 00:31:31,280
archive for instance where there was a

00:31:27,940 --> 00:31:33,890
there was always an read which was then

00:31:31,280 --> 00:31:35,780
dead because it was unused just as the

00:31:33,890 --> 00:31:40,220
way as a result of the way loop was

00:31:35,780 --> 00:31:42,280
structured and so that's that's the sort

00:31:40,220 --> 00:31:44,480
of thing we're finding we have not found

00:31:42,280 --> 00:31:46,580
they're not found any astonishing

00:31:44,480 --> 00:31:49,270
massive security bugs which makes me a

00:31:46,580 --> 00:31:49,270
little sad but

00:31:51,790 --> 00:31:57,170
yes we support all well we support most

00:31:55,820 --> 00:31:58,850
of those things we also have escape

00:31:57,170 --> 00:32:03,260
hatches so you can you can say yes I'm a

00:31:58,850 --> 00:32:05,570
bad person yeah we support can we

00:32:03,260 --> 00:32:06,800
support container of we can do it both

00:32:05,570 --> 00:32:09,650
in a fine-grained at a coarse-grained

00:32:06,800 --> 00:32:10,580
way that's also grad student work that's

00:32:09,650 --> 00:32:14,810
still in progress

00:32:10,580 --> 00:32:16,220
he's busy writing up so yeah so most

00:32:14,810 --> 00:32:18,200
changes I would say improve code quality

00:32:16,220 --> 00:32:20,420
I've also brought in a bunch of FreeBSD

00:32:18,200 --> 00:32:22,490
32 changes where I found I needed

00:32:20,420 --> 00:32:24,950
compatibility support for something that

00:32:22,490 --> 00:32:26,690
no one had bothered implement so got the

00:32:24,950 --> 00:32:30,740
FreeBSD 32 version

00:32:26,690 --> 00:32:33,200
I might have tested it so here we are so

00:32:30,740 --> 00:32:35,120
we want one thing an example of one of

00:32:33,200 --> 00:32:37,780
our goals was we'd like to reduce bounds

00:32:35,120 --> 00:32:41,360
on pointers so I've got here a graph of

00:32:37,780 --> 00:32:44,390
the size distribution of pointers in a

00:32:41,360 --> 00:32:45,770
simple OpenSSL server run this is

00:32:44,390 --> 00:32:47,090
created through instruction traces to

00:32:45,770 --> 00:32:49,010
which why it's not a big complicated

00:32:47,090 --> 00:32:50,810
program because the instruction traces

00:32:49,010 --> 00:32:54,950
take forever and then it takes 8 hours

00:32:50,810 --> 00:32:57,890
to generate this graph with after quite

00:32:54,950 --> 00:33:01,700
a few rounds of optimization so how to

00:32:57,890 --> 00:33:04,460
read this graph is that this way up

00:33:01,700 --> 00:33:07,010
upper left is better which is to say

00:33:04,460 --> 00:33:09,200
things are smaller so if your curve is

00:33:07,010 --> 00:33:10,400
way over on the upper left-hand side

00:33:09,200 --> 00:33:14,450
that means most of your pointers are

00:33:10,400 --> 00:33:17,420
small if you consider a classic hybrid

00:33:14,450 --> 00:33:19,310
program most of the pointers are off the

00:33:17,420 --> 00:33:20,480
screen - there's a vertical line off the

00:33:19,310 --> 00:33:24,110
screen to the right we just say all

00:33:20,480 --> 00:33:26,960
pointers can access all memory so we've

00:33:24,110 --> 00:33:29,960
we've shrunk the pointers quite a bit

00:33:26,960 --> 00:33:33,800
most capabilities are under a page so

00:33:29,960 --> 00:33:35,720
that's you know something there's a few

00:33:33,800 --> 00:33:37,990
references to the whole stack as just

00:33:35,720 --> 00:33:40,160
part of set up and stack manipulation

00:33:37,990 --> 00:33:41,930
likewise there's a small number of whole

00:33:40,160 --> 00:33:44,030
of pointers to the whole object because

00:33:41,930 --> 00:33:48,800
obviously somebody had to have a pointer

00:33:44,030 --> 00:33:51,530
to the object so you could blank it yeah

00:33:48,800 --> 00:33:53,600
so so I think it shows that we are

00:33:51,530 --> 00:33:55,310
reducing pointers it's hard to come up

00:33:53,600 --> 00:33:58,340
with an objective measure of what ideal

00:33:55,310 --> 00:34:02,020
would be here so we're working a bit on

00:33:58,340 --> 00:34:02,020
that but it you it's hard to say

00:34:05,090 --> 00:34:13,649
we have two variants we have we have two

00:34:11,790 --> 00:34:16,679
variants the compiler has two modes that

00:34:13,649 --> 00:34:19,099
the compiler has two modes and they're

00:34:16,679 --> 00:34:19,099
not compatible

00:34:20,899 --> 00:34:26,669
no they're they're no they're not part

00:34:25,530 --> 00:34:28,139
of the same instruction set they are

00:34:26,669 --> 00:34:30,060
variants of the instruction set which

00:34:28,139 --> 00:34:32,639
are mutually exclusive so you could have

00:34:30,060 --> 00:34:35,369
either 128-bit pointers or 256 bit

00:34:32,639 --> 00:34:38,849
pointers we hope to kill 256 pointers

00:34:35,369 --> 00:34:41,070
thanks bit fighters there thorn in my

00:34:38,849 --> 00:34:42,780
side and combinatorics are not your

00:34:41,070 --> 00:34:48,060
friend when you add more pointer sizes

00:34:42,780 --> 00:34:49,590
to your CI system and you'll see why I

00:34:48,060 --> 00:34:51,540
care about that in a few slides

00:34:49,590 --> 00:34:54,149
so a quick bit of performance here's a

00:34:51,540 --> 00:34:56,070
graph showing we assert reasonable

00:34:54,149 --> 00:34:58,800
performance on a bunch of micro

00:34:56,070 --> 00:35:01,080
benchmarks many of these are like are

00:34:58,800 --> 00:35:05,820
designed to make it awful to use

00:35:01,080 --> 00:35:07,500
pointers so you know we have we have

00:35:05,820 --> 00:35:11,609
some things I think Patricia mostly

00:35:07,500 --> 00:35:13,500
makes trees with no contents so it's

00:35:11,609 --> 00:35:15,690
it's rather pointer intensive

00:35:13,500 --> 00:35:18,570
we've also it here I've excluded a bunch

00:35:15,690 --> 00:35:22,560
of crypto anihilation metrics benchmarks

00:35:18,570 --> 00:35:25,290
that do to an artifact of our of our

00:35:22,560 --> 00:35:28,170
system design now we whatever a sorry a

00:35:25,290 --> 00:35:30,150
week one decision back in 2010 was that

00:35:28,170 --> 00:35:31,859
we would do the MIPS II thing here which

00:35:30,150 --> 00:35:33,660
is to say we're adding a new feature so

00:35:31,859 --> 00:35:35,070
we're gonna use a coprocessor extension

00:35:33,660 --> 00:35:38,400
which means a separate set of register a

00:35:35,070 --> 00:35:40,890
separate set of registers it turns out

00:35:38,400 --> 00:35:42,599
if your code is register bound which

00:35:40,890 --> 00:35:44,970
crypto and bit manipulation code tends

00:35:42,599 --> 00:35:48,839
to be and you add more 32 more registers

00:35:44,970 --> 00:35:50,190
for pointers your code gets faster so we

00:35:48,839 --> 00:35:51,570
don't include those there because it's

00:35:50,190 --> 00:35:56,070
fair even though we're using more memory

00:35:51,570 --> 00:35:58,080
and taking more page folds so okay so a

00:35:56,070 --> 00:36:00,450
few reflections on using freebsd for

00:35:58,080 --> 00:36:02,280
this process since it's always I think

00:36:00,450 --> 00:36:04,170
good to talk about what's good and

00:36:02,280 --> 00:36:07,950
what's bad about freebsd is a research

00:36:04,170 --> 00:36:10,200
operating system so the good news

00:36:07,950 --> 00:36:13,920
there's a well abstracted model for

00:36:10,200 --> 00:36:14,370
adding new program ABI is to freebsd so

00:36:13,920 --> 00:36:17,340
we already

00:36:14,370 --> 00:36:22,770
have FreeBSD 32 we have several Linux

00:36:17,340 --> 00:36:29,150
implementations we have three BSD a dot

00:36:22,770 --> 00:36:31,680
out support for i386 so that's all there

00:36:29,150 --> 00:36:34,920
this is the the current abstraction

00:36:31,680 --> 00:36:38,640
somewhat baek's in the system five the

00:36:34,920 --> 00:36:41,660
the x86 system five ABI which is to say

00:36:38,640 --> 00:36:45,300
Arg V and Argosy are passed on the stack

00:36:41,660 --> 00:36:46,800
and they're expected to be you're

00:36:45,300 --> 00:36:49,440
expected to have Arg C which is

00:36:46,800 --> 00:36:52,680
confusingly along instead of int and

00:36:49,440 --> 00:36:54,540
then you have all of the arguments array

00:36:52,680 --> 00:36:56,970
all of the environment array and then

00:36:54,540 --> 00:36:58,800
all of the oxides array and in fact in a

00:36:56,970 --> 00:37:01,460
bit of cuteness you'll find a bit of Lib

00:36:58,800 --> 00:37:04,830
C if where you find the oxides array by

00:37:01,460 --> 00:37:07,260
finding the environment array to walking

00:37:04,830 --> 00:37:12,960
to the end jumping off the cliff and

00:37:07,260 --> 00:37:16,020
then there it is so we wanted to get

00:37:12,960 --> 00:37:19,100
route we got rid of that but the

00:37:16,020 --> 00:37:21,510
abstraction problem here is not bad the

00:37:19,100 --> 00:37:23,670
fact that we have central generated

00:37:21,510 --> 00:37:25,680
system call tables and sub generation

00:37:23,670 --> 00:37:27,900
code is enormous ly helpful but this

00:37:25,680 --> 00:37:30,000
system calls aren't hint though they

00:37:27,900 --> 00:37:31,770
call the bits around hooking them up to

00:37:30,000 --> 00:37:34,170
the various factors isn't hand coded its

00:37:31,770 --> 00:37:36,870
enormous ly helpful I did add over a

00:37:34,170 --> 00:37:41,000
thousand lines of code to the awk that

00:37:36,870 --> 00:37:44,430
we use for that but it is there and

00:37:41,000 --> 00:37:46,740
having a single relatively hackable with

00:37:44,430 --> 00:37:48,690
some pain and suffering build system

00:37:46,740 --> 00:37:52,140
where I can build seven or eight hundred

00:37:48,690 --> 00:37:54,090
programs and I was able to change things

00:37:52,140 --> 00:37:57,660
around so I could decide which ABI I was

00:37:54,090 --> 00:37:59,040
building each program for was really

00:37:57,660 --> 00:38:01,620
helpful so I could get a whole bunch of

00:37:59,040 --> 00:38:05,580
code in place and only have to hack one

00:38:01,620 --> 00:38:07,920
set of make files and not hack you know

00:38:05,580 --> 00:38:11,750
this program see make and this thing's

00:38:07,920 --> 00:38:13,830
broken Auto conf and blah blah blah

00:38:11,750 --> 00:38:16,020
they're having a lot of stuff in one

00:38:13,830 --> 00:38:17,670
place is actually really helpful so not

00:38:16,020 --> 00:38:19,920
slimming the base system down too much

00:38:17,670 --> 00:38:24,240
he's in fact extraordinarily useful for

00:38:19,920 --> 00:38:26,310
this sort of purpose the bad the eye

00:38:24,240 --> 00:38:27,960
octal implementation a decision made in

00:38:26,310 --> 00:38:29,460
FreeBSD I don't actually remember

00:38:27,960 --> 00:38:32,010
the other vsts do this I don't remember

00:38:29,460 --> 00:38:34,740
when the decision was taken in FreeBSD

00:38:32,010 --> 00:38:36,470
the copy and and copy out for structures

00:38:34,740 --> 00:38:40,680
it structure arguments that I octal

00:38:36,470 --> 00:38:43,320
occurs out the occurs in the general

00:38:40,680 --> 00:38:46,200
layer before things are passed down this

00:38:43,320 --> 00:38:49,290
means you can't forget and whatnot but

00:38:46,200 --> 00:38:50,820
it also means you don't actually know

00:38:49,290 --> 00:38:52,980
anything about the type you're copying

00:38:50,820 --> 00:38:55,230
you only know the length that means I

00:38:52,980 --> 00:38:58,020
always have to copy in capabilities and

00:38:55,230 --> 00:39:00,089
copy out capabilities for every I octal

00:38:58,020 --> 00:39:02,369
which I don't which as I said way back

00:39:00,089 --> 00:39:04,440
in the beginning I don't like doing it

00:39:02,369 --> 00:39:07,560
offends me it also makes it hard to do

00:39:04,440 --> 00:39:09,510
compatibility in that you know copy this

00:39:07,560 --> 00:39:10,830
thing in and then you get finally down

00:39:09,510 --> 00:39:12,780
to where you are where you want to

00:39:10,830 --> 00:39:14,580
manipulate something and you actually

00:39:12,780 --> 00:39:16,109
know what type it is and you're like oh

00:39:14,580 --> 00:39:17,430
now it's the wrong type so I need to

00:39:16,109 --> 00:39:19,410
convert it to the right type so I could

00:39:17,430 --> 00:39:21,420
actually do some work on it it'd be nice

00:39:19,410 --> 00:39:27,170
if we could that so that's that's an

00:39:21,420 --> 00:39:29,280
annoyance and our test framework

00:39:27,170 --> 00:39:32,070
requires things that aren't in the base

00:39:29,280 --> 00:39:33,390
system and that's that means I don't get

00:39:32,070 --> 00:39:35,190
the benefit at the hackle at the build

00:39:33,390 --> 00:39:38,280
system instead I get the really broken

00:39:35,190 --> 00:39:39,839
auto con fulfilled system so I've spent

00:39:38,280 --> 00:39:42,630
hours trying to build this stupid thing

00:39:39,839 --> 00:39:46,859
static and had no luck so that's been

00:39:42,630 --> 00:39:48,330
quite frustrating but in general it's

00:39:46,859 --> 00:39:50,369
been a pretty good platform for us I

00:39:48,330 --> 00:39:52,589
think we had a we were able to get

00:39:50,369 --> 00:39:53,790
enough code up and running so that when

00:39:52,589 --> 00:39:56,700
we got to the point where we wanted to

00:39:53,790 --> 00:39:59,040
use Postgres we'd shaken most of the

00:39:56,700 --> 00:40:00,930
bugs out and so we were able to you know

00:39:59,040 --> 00:40:04,530
then modify post-crisis build system

00:40:00,930 --> 00:40:06,109
then modify WebKit's build system etc so

00:40:04,530 --> 00:40:08,730
some work in progress

00:40:06,109 --> 00:40:12,210
we are currently porting the ISA from

00:40:08,730 --> 00:40:15,960
MIPS to risk 5 under a DARPA program and

00:40:12,210 --> 00:40:19,470
I can announce here that arm has a port

00:40:15,960 --> 00:40:20,849
of the is a two arm v8 and they are

00:40:19,470 --> 00:40:22,619
doing a prototype Hardware

00:40:20,849 --> 00:40:25,830
implementation with UK government

00:40:22,619 --> 00:40:27,900
funding the implementation is a version

00:40:25,830 --> 00:40:29,940
of the architecture which is definitely

00:40:27,900 --> 00:40:31,859
a prototype and definitely a dead end

00:40:29,940 --> 00:40:33,869
which is to say it has a number of

00:40:31,859 --> 00:40:36,480
features in it which will not ship they

00:40:33,869 --> 00:40:37,800
just don't know which ones because there

00:40:36,480 --> 00:40:39,890
are some science questions we haven't

00:40:37,800 --> 00:40:41,920
answer then our best answered it's scale

00:40:39,890 --> 00:40:45,280
so for instance

00:40:41,920 --> 00:40:48,550
more than one way to implement tags and

00:40:45,280 --> 00:40:49,870
so they are implementing so they are

00:40:48,550 --> 00:40:52,360
implementing both of them in this

00:40:49,870 --> 00:40:55,630
hardware there will be boards in about

00:40:52,360 --> 00:40:57,550
two years they will be performant and

00:40:55,630 --> 00:40:59,590
there will be a funding call at the UK

00:40:57,550 --> 00:41:03,760
for people who could use UK government

00:40:59,590 --> 00:41:05,140
money let's see we have we have a new

00:41:03,760 --> 00:41:07,720
format for compress capabilities which

00:41:05,140 --> 00:41:10,120
I've actually adopted that now the

00:41:07,720 --> 00:41:12,460
bounds are smaller or the we do a bit

00:41:10,120 --> 00:41:13,690
more rounding now we were working on

00:41:12,460 --> 00:41:15,100
temporal memory safety which is say

00:41:13,690 --> 00:41:17,410
we've solved the spatial memory safety

00:41:15,100 --> 00:41:18,730
problem more or less so now we would

00:41:17,410 --> 00:41:20,980
like to get rid of all your use after

00:41:18,730 --> 00:41:23,680
freeze that's also a work in progress

00:41:20,980 --> 00:41:25,830
hope you submit a paper on that soon we

00:41:23,680 --> 00:41:29,080
have some pretty promising results there

00:41:25,830 --> 00:41:31,240
I'm gonna swap things around and stop

00:41:29,080 --> 00:41:32,980
using a compact area API and make the

00:41:31,240 --> 00:41:35,620
default that should reduce the total

00:41:32,980 --> 00:41:40,840
number of gifts in the system and also a

00:41:35,620 --> 00:41:44,740
pure capability kernel so let's see I'm

00:41:40,840 --> 00:41:46,480
gonna go ahead and skip this slide so we

00:41:44,740 --> 00:41:48,430
have again we have a full unix-like

00:41:46,480 --> 00:41:50,020
operating system with spatial and

00:41:48,430 --> 00:41:52,240
referential memory safety we have

00:41:50,020 --> 00:41:54,820
programs linkers libraries everything's

00:41:52,240 --> 00:41:56,020
covered we didn't just cheat and do a

00:41:54,820 --> 00:41:57,670
bunch of high performance compute a

00:41:56,020 --> 00:42:00,880
bunch of little micro benchmarks and

00:41:57,670 --> 00:42:03,850
call it good like all the kernel

00:42:00,880 --> 00:42:07,410
accesses are protected so the kernel

00:42:03,850 --> 00:42:09,670
can't be used as a confused deputy and

00:42:07,410 --> 00:42:12,100
well there were some fundamental changes

00:42:09,670 --> 00:42:13,600
required we feel that the overall set of

00:42:12,100 --> 00:42:15,730
changes generally pretty non-disruptive

00:42:13,600 --> 00:42:18,220
and it's not just throwing into the

00:42:15,730 --> 00:42:20,530
freebsd based system we have Postgres

00:42:18,220 --> 00:42:22,840
which is a big c program and we have

00:42:20,530 --> 00:42:24,790
WebKit which is an enormous C++ program

00:42:22,840 --> 00:42:28,510
and they are both running and running

00:42:24,790 --> 00:42:31,240
pretty well so I would be happy to take

00:42:28,510 --> 00:42:36,210
any further questions there's further

00:42:31,240 --> 00:42:36,210
reading on our website and

00:42:40,850 --> 00:42:45,270
so the question is have we benchmarked

00:42:43,200 --> 00:42:47,700
the overhead for JIT compilers we have

00:42:45,270 --> 00:42:49,800
not done much with JIT compilation yet

00:42:47,700 --> 00:42:51,540
that's in fact one of the things that's

00:42:49,800 --> 00:42:54,240
explicitly mentioned in this funding

00:42:51,540 --> 00:42:56,400
call for the new arm prototypes is

00:42:54,240 --> 00:42:58,790
people to work on language runtimes I

00:42:56,400 --> 00:43:02,400
will say that we have done we had a

00:42:58,790 --> 00:43:04,640
student who worked on changes to the

00:43:02,400 --> 00:43:07,110
rust runtime which is not a jet but

00:43:04,640 --> 00:43:10,530
working on the restaurant time to make

00:43:07,110 --> 00:43:13,350
the unsafe parts safe by using

00:43:10,530 --> 00:43:17,100
capabilities and we've actually done

00:43:13,350 --> 00:43:19,380
that with Java j8i so we've made the

00:43:17,100 --> 00:43:22,110
million lines of C code that run that

00:43:19,380 --> 00:43:26,790
makes your JIT your your Java J and I

00:43:22,110 --> 00:43:28,710
run weave or JVM run rather we pushed

00:43:26,790 --> 00:43:32,910
capabilities into that and we enforce

00:43:28,710 --> 00:43:37,560
the Java model on them any other

00:43:32,910 --> 00:43:39,330
questions yes the slides will be I think

00:43:37,560 --> 00:43:40,950
the slides are on there these slides are

00:43:39,330 --> 00:43:43,260
identical to the BSD can ones they're on

00:43:40,950 --> 00:43:44,520
this website there will be if the

00:43:43,260 --> 00:43:47,240
organizers tell me where to put them I

00:43:44,520 --> 00:43:47,240
will send them

00:43:58,259 --> 00:44:03,490
yes we can run we can run unmodified

00:44:00,749 --> 00:44:06,539
programs we can also run hybrid programs

00:44:03,490 --> 00:44:08,890
in fact what tipic what we what we

00:44:06,539 --> 00:44:10,900
envision is the likely model is that

00:44:08,890 --> 00:44:13,720
high is that you'll get a hybrid lib see

00:44:10,900 --> 00:44:19,180
whether you want one or not that mostly

00:44:13,720 --> 00:44:21,940
means you get faster mem copy huh well

00:44:19,180 --> 00:44:26,470
yeah on architectures where you don't

00:44:21,940 --> 00:44:27,789
already have 128-bit registers so yes

00:44:26,470 --> 00:44:30,279
yeah that's that's a key part of the

00:44:27,789 --> 00:44:32,799
transition strategy is in fact that we

00:44:30,279 --> 00:44:34,299
keep everything working so you can start

00:44:32,799 --> 00:44:38,700
with the you can start with one move to

00:44:34,299 --> 00:44:38,700
the next question back there

00:44:46,560 --> 00:44:51,700
what's blocking us from doing a full

00:44:48,520 --> 00:44:53,920
capability Colonel um time I mean it's

00:44:51,700 --> 00:44:56,110
we have one booting it does work

00:44:53,920 --> 00:45:00,280
remarkably well we've started putting

00:44:56,110 --> 00:45:03,520
bounds on things like em buffs so it is

00:45:00,280 --> 00:45:06,820
it is a matter of merging that well of

00:45:03,520 --> 00:45:08,280
getting that branch polished getting all

00:45:06,820 --> 00:45:10,600
the other things that need to be merged

00:45:08,280 --> 00:45:12,960
merged and then getting it merged it's a

00:45:10,600 --> 00:45:15,370
big thing actually is the transition of

00:45:12,960 --> 00:45:17,470
cherry API to being the default ABI

00:45:15,370 --> 00:45:19,960
because it really makes sense when

00:45:17,470 --> 00:45:26,650
everything's already a capability and

00:45:19,960 --> 00:45:28,390
we're so that's that's the big thing yes

00:45:26,650 --> 00:45:39,220
that's true he did he did port go thank

00:45:28,390 --> 00:45:41,590
you we're well we're merging the

00:45:39,220 --> 00:45:43,650
register file so we'll only have one

00:45:41,590 --> 00:45:46,800
register file registers just get wider

00:45:43,650 --> 00:45:49,270
arm has taken the same approach there

00:45:46,800 --> 00:45:51,790
there's I think we are we are going to

00:45:49,270 --> 00:45:53,230
support both models transiently because

00:45:51,790 --> 00:45:56,490
we want to do the science and make sure

00:45:53,230 --> 00:45:59,050
it really makes sense there's other

00:45:56,490 --> 00:46:01,120
that's probably the biggest one we've

00:45:59,050 --> 00:46:02,350
been we've had a lot of flag days so

00:46:01,120 --> 00:46:04,830
we've been willing to polish works off

00:46:02,350 --> 00:46:04,830
as we go

00:46:21,690 --> 00:46:27,070
yeah I mean the the kernel code is

00:46:24,220 --> 00:46:31,300
mostly written by mostly written by

00:46:27,070 --> 00:46:33,730
software developers not grad students so

00:46:31,300 --> 00:46:35,110
so we have a lot of freebsd experience

00:46:33,730 --> 00:46:36,850
so we've tried to do the right thing

00:46:35,110 --> 00:46:38,590
that is not to say we've always

00:46:36,850 --> 00:46:47,860
succeeded so jon is running into that

00:46:38,590 --> 00:46:49,080
with the RISC 540 thank you all for

00:46:47,860 --> 00:46:54,580
coming

00:46:49,080 --> 00:46:54,580
[Applause]

00:46:59,900 --> 00:47:01,960

YouTube URL: https://www.youtube.com/watch?v=cAuhWjDDM0k


