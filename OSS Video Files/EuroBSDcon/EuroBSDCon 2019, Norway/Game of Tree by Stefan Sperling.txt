Title: Game of Tree by Stefan Sperling
Publication date: 2019-10-21
Playlist: EuroBSDCon 2019, Norway
Description: 
	Game of Trees

Stefan Sperling

Stefan Sperling works as a freelance open source developer and consultant and is based in Berlin. Stefan has been involved in the OpenBSD project for a decade, and he is also one of the main contributors to the Apache Subversion version control system.

More Info:
https://2019.eurobsdcon.org/talk-speakers/#trees
Captions: 
	00:00:03,679 --> 00:00:09,590
good afternoon everyone Europeans econ

00:00:06,560 --> 00:00:12,020
is very very happy to have Stephan

00:00:09,590 --> 00:00:13,299
Sperling this afternoon talking about

00:00:12,020 --> 00:00:15,650
game of trees

00:00:13,299 --> 00:00:20,539
hopefully the ending will be better than

00:00:15,650 --> 00:00:22,310
Game of Thrones quick note this is gonna

00:00:20,539 --> 00:00:25,310
be a rather long talk so there won't

00:00:22,310 --> 00:00:27,349
probably be time for a Q&A session so if

00:00:25,310 --> 00:00:28,880
you need to ask Stefan some questions

00:00:27,349 --> 00:00:31,609
don't hesitate to kidnapping

00:00:28,880 --> 00:00:40,400
after talk all right have fun thanks

00:00:31,609 --> 00:00:47,170
Evan thank you hear me okay good

00:00:40,400 --> 00:00:50,540
so this is slightly far all right

00:00:47,170 --> 00:00:53,150
so game of trees tries to be a version

00:00:50,540 --> 00:00:57,590
control system that is appealing to all

00:00:53,150 --> 00:00:59,600
be severe persons in particular not just

00:00:57,590 --> 00:01:01,250
at the functional level but also in the

00:00:59,600 --> 00:01:02,750
implementation and the coding style and

00:01:01,250 --> 00:01:08,780
the design and the architecture of the

00:01:02,750 --> 00:01:11,210
whole thing the license is is C and for

00:01:08,780 --> 00:01:15,829
various reasons it's compatible with git

00:01:11,210 --> 00:01:19,390
repositories and also we try to have

00:01:15,829 --> 00:01:22,899
nice man pages that are easy to follow

00:01:19,390 --> 00:01:25,490
there is a couple of people that have

00:01:22,899 --> 00:01:27,380
had input into this project it's not

00:01:25,490 --> 00:01:28,909
just me even though it might appear to

00:01:27,380 --> 00:01:31,520
be that way but there's actually quite a

00:01:28,909 --> 00:01:34,310
few people I've had discussions with and

00:01:31,520 --> 00:01:36,259
this extends beyond open beasties

00:01:34,310 --> 00:01:38,479
community as well because you'll see it

00:01:36,259 --> 00:01:41,119
the former and the current litigate -

00:01:38,479 --> 00:01:46,060
maintainer on the slide we work together

00:01:41,119 --> 00:01:49,549
at a company and so they helped me a lot

00:01:46,060 --> 00:01:52,549
now this is the overview of the general

00:01:49,549 --> 00:01:54,109
design you have currently there are two

00:01:52,549 --> 00:01:55,549
front end applications one is the

00:01:54,109 --> 00:01:57,380
command line to a god and the other one

00:01:55,549 --> 00:02:00,439
is a graphic hole and cursus based

00:01:57,380 --> 00:02:02,240
browser called shard and you have a

00:02:00,439 --> 00:02:04,340
library which contains most of the

00:02:02,240 --> 00:02:06,859
version for version control machinery

00:02:04,340 --> 00:02:10,250
you would expect like you can handle

00:02:06,859 --> 00:02:13,220
objects cache them you have differences

00:02:10,250 --> 00:02:16,280
between objects you have quota manager

00:02:13,220 --> 00:02:20,209
work tree and all the sorts of stuff

00:02:16,280 --> 00:02:23,209
and what's unique about the design in

00:02:20,209 --> 00:02:27,590
this case is the arrow that is labeled

00:02:23,209 --> 00:02:30,140
fork and exact because when we read get

00:02:27,590 --> 00:02:31,910
repositories we don't assume that there

00:02:30,140 --> 00:02:34,160
are a trusted source of information but

00:02:31,910 --> 00:02:37,790
they are copied from somewhere on the

00:02:34,160 --> 00:02:39,260
internet and we are scared of being

00:02:37,790 --> 00:02:42,020
exploited and stuff so it might be

00:02:39,260 --> 00:02:44,300
useful to wrap these accesses in a

00:02:42,020 --> 00:02:46,550
different address space with different

00:02:44,300 --> 00:02:49,459
utilities that then run in a separate

00:02:46,550 --> 00:02:51,680
process context and that's how we read

00:02:49,459 --> 00:02:55,269
data from the repository when we write

00:02:51,680 --> 00:02:58,459
to the repository we just do it directly

00:02:55,269 --> 00:03:00,769
there is forget users this is probably

00:02:58,459 --> 00:03:02,900
surprising we don't use the actual get

00:03:00,769 --> 00:03:04,670
word tree that gets maintains in its

00:03:02,900 --> 00:03:06,830
repository so usually you'd have the

00:03:04,670 --> 00:03:08,900
rectory and the target folder but here

00:03:06,830 --> 00:03:10,160
we just ignore the files above the

00:03:08,900 --> 00:03:13,459
docket folder because we don't care

00:03:10,160 --> 00:03:15,350
about those this has some advantages for

00:03:13,459 --> 00:03:17,810
example it allows you to really operate

00:03:15,350 --> 00:03:20,630
with post rules on the same on the same

00:03:17,810 --> 00:03:23,329
object which is kind of neat it also

00:03:20,630 --> 00:03:26,360
allows God to be a little bit different

00:03:23,329 --> 00:03:27,829
in the sense that and it really only

00:03:26,360 --> 00:03:30,799
requires you to keep one copy of the

00:03:27,829 --> 00:03:31,880
repository on a on a local disk and you

00:03:30,799 --> 00:03:33,440
can create as many work trees as you

00:03:31,880 --> 00:03:34,790
want from it and you can also check out

00:03:33,440 --> 00:03:37,220
sub trees from those work trees so you

00:03:34,790 --> 00:03:39,079
could have say user source checked out

00:03:37,220 --> 00:03:41,600
from it you could have your couple of

00:03:39,079 --> 00:03:43,519
kernels checked out or some user land

00:03:41,600 --> 00:03:47,150
utilities like T max put them somewhere

00:03:43,519 --> 00:03:50,810
separately and work on them the work

00:03:47,150 --> 00:03:53,420
tree remembers the past and repository

00:03:50,810 --> 00:03:54,950
it remembers the branch it's on so

00:03:53,420 --> 00:03:59,150
there's a sticky branch for the entire

00:03:54,950 --> 00:04:00,410
work tree and it also remembers the

00:03:59,150 --> 00:04:02,480
commit that was checked out from this

00:04:00,410 --> 00:04:04,250
branch and the commits are tracked or

00:04:02,480 --> 00:04:06,500
file they're not like usually you think

00:04:04,250 --> 00:04:08,690
of it as a global thing but this tool is

00:04:06,500 --> 00:04:10,549
actually able to pull out some different

00:04:08,690 --> 00:04:15,890
commits just like it would be if you

00:04:10,549 --> 00:04:18,380
asked it to this is the platform assist

00:04:15,890 --> 00:04:20,090
that we're using currently there is no

00:04:18,380 --> 00:04:22,669
network access yet so you don't have

00:04:20,090 --> 00:04:24,950
eyelet and DNS in here those would of

00:04:22,669 --> 00:04:28,270
course have to be added in case network

00:04:24,950 --> 00:04:30,789
support is implemented but

00:04:28,270 --> 00:04:33,400
the helpers that actually read data they

00:04:30,789 --> 00:04:35,979
have a very limited exposure to system

00:04:33,400 --> 00:04:37,389
calls so they can really only do things

00:04:35,979 --> 00:04:40,690
like a map and they take file

00:04:37,389 --> 00:04:43,500
descriptors for for reading data and

00:04:40,690 --> 00:04:47,620
file descriptors for outputting data and

00:04:43,500 --> 00:04:49,240
so if an attacker gets in there they

00:04:47,620 --> 00:04:53,889
can't really do a lot at the system code

00:04:49,240 --> 00:04:55,900
level we also use unveil where we limit

00:04:53,889 --> 00:04:58,300
the application to the pass the text is

00:04:55,900 --> 00:04:59,770
actually needing so of course the

00:04:58,300 --> 00:05:01,330
repository needs to be read the work

00:04:59,770 --> 00:05:05,319
tree needs to be read the temp directory

00:05:01,330 --> 00:05:06,940
is used and also if you import on

00:05:05,319 --> 00:05:10,300
version files into the repository we

00:05:06,940 --> 00:05:12,940
need to read those of course when you

00:05:10,300 --> 00:05:15,610
type a commit message unvail has not yet

00:05:12,940 --> 00:05:19,030
applied at this point because unreal is

00:05:15,610 --> 00:05:22,000
supposed to extend from one process to

00:05:19,030 --> 00:05:23,800
another through execute fork this is

00:05:22,000 --> 00:05:25,900
actually not currently the case in the

00:05:23,800 --> 00:05:28,030
implementation but the design of unveil

00:05:25,900 --> 00:05:31,719
is supposed to make that happen

00:05:28,030 --> 00:05:33,280
eventually so we can't really use unveil

00:05:31,719 --> 00:05:34,719
before the editor is done because the

00:05:33,280 --> 00:05:36,520
editor might read its own configuration

00:05:34,719 --> 00:05:38,889
file it's launched at libraries and all

00:05:36,520 --> 00:05:40,659
sorts of stuff that we can't control so

00:05:38,889 --> 00:05:41,680
for the commit command you get another

00:05:40,659 --> 00:05:44,259
protection as soon as you're done

00:05:41,680 --> 00:05:46,569
writing your long message we also read

00:05:44,259 --> 00:05:50,020
the git config file that only to get

00:05:46,569 --> 00:05:51,969
user and author username email

00:05:50,020 --> 00:05:53,860
information that you might want to use

00:05:51,969 --> 00:05:56,469
just for default values you can

00:05:53,860 --> 00:06:00,759
overwrite those separately and this is

00:05:56,469 --> 00:06:02,020
the any parser it's used for to read

00:06:00,759 --> 00:06:05,830
this file and it runs in a separate

00:06:02,020 --> 00:06:08,830
process as well since I talked to my

00:06:05,830 --> 00:06:10,630
time about this last night and he asked

00:06:08,830 --> 00:06:11,800
me what are all the helpers and I

00:06:10,630 --> 00:06:15,759
realized I didn't have a slide for this

00:06:11,800 --> 00:06:17,590
so this is the list you have the object

00:06:15,759 --> 00:06:19,449
reader is basically just reading the

00:06:17,590 --> 00:06:20,830
header so in case we only want to know

00:06:19,449 --> 00:06:22,719
the ID in the size or something like

00:06:20,830 --> 00:06:25,500
that we use that and then you have

00:06:22,719 --> 00:06:28,630
readers for the different object types

00:06:25,500 --> 00:06:30,130
which are parsing the loose objects that

00:06:28,630 --> 00:06:32,380
are in the file system and then you have

00:06:30,130 --> 00:06:33,759
a reader for PAC files where objects can

00:06:32,380 --> 00:06:37,690
be extracted from and you have a reader

00:06:33,759 --> 00:06:40,029
for the good config file I'm going to

00:06:37,690 --> 00:06:41,980
explain some git basics so in case

00:06:40,029 --> 00:06:44,230
people now get already the

00:06:41,980 --> 00:06:45,850
a few slides will might contain all

00:06:44,230 --> 00:06:49,330
information but we're trying to keep

00:06:45,850 --> 00:06:52,330
this short so it has several object

00:06:49,330 --> 00:06:55,090
types the blobs can bottom restore fire

00:06:52,330 --> 00:06:56,860
content pretty much as is the three

00:06:55,090 --> 00:06:59,380
objects are essentially directory I

00:06:56,860 --> 00:07:02,320
nodes in this virtual file system tree

00:06:59,380 --> 00:07:05,020
and the commit objects point at one

00:07:02,320 --> 00:07:06,850
particular tree to create a snapshot of

00:07:05,020 --> 00:07:08,890
your project and then you can change

00:07:06,850 --> 00:07:11,680
those commit objects to create basically

00:07:08,890 --> 00:07:14,380
versions of your project as chain of

00:07:11,680 --> 00:07:15,850
snapshots you also have tagged objects

00:07:14,380 --> 00:07:18,270
which allow you to label commits as

00:07:15,850 --> 00:07:24,010
release versions that's pretty much the

00:07:18,270 --> 00:07:26,650
simple data model on disk objects are

00:07:24,010 --> 00:07:27,880
often stored in loose form as it's

00:07:26,650 --> 00:07:29,610
called when you create them which means

00:07:27,880 --> 00:07:32,800
each object has a separate file on disk

00:07:29,610 --> 00:07:34,240
named after its ID and this ID is

00:07:32,800 --> 00:07:36,430
derived from its content so you have a

00:07:34,240 --> 00:07:38,800
type header size header and then the

00:07:36,430 --> 00:07:40,420
data and this all is hashed currently

00:07:38,800 --> 00:07:43,630
with sha-1 they'll get might change that

00:07:40,420 --> 00:07:45,670
at some point and after hashing you also

00:07:43,630 --> 00:07:47,560
confess the data with C lip and write

00:07:45,670 --> 00:07:52,780
out the file that's basically how you

00:07:47,560 --> 00:07:54,250
create an object in the repository now

00:07:52,780 --> 00:07:55,570
this could be very inefficient because

00:07:54,250 --> 00:07:57,580
of course you don't want to have

00:07:55,570 --> 00:08:00,610
thousands of objects lying around on

00:07:57,580 --> 00:08:02,530
this King up AI notes and things so get

00:08:00,610 --> 00:08:05,890
invented pack file format which is

00:08:02,530 --> 00:08:07,990
pretty neat actually because while many

00:08:05,890 --> 00:08:09,880
version control systems will usually

00:08:07,990 --> 00:08:11,620
delta phi between versions of individual

00:08:09,880 --> 00:08:13,120
files like CVS does for example this

00:08:11,620 --> 00:08:15,670
allows you to identify across entire

00:08:13,120 --> 00:08:17,020
collections of files and so for example

00:08:15,670 --> 00:08:18,670
if the license header is the same in all

00:08:17,020 --> 00:08:21,670
of them the Delta argument it can you

00:08:18,670 --> 00:08:24,250
see that and it can basically those

00:08:21,670 --> 00:08:25,570
layers of deltas to construct files and

00:08:24,250 --> 00:08:28,000
be really space efficient when it's

00:08:25,570 --> 00:08:29,770
saving things and to do this they add a

00:08:28,000 --> 00:08:32,160
to object types in fact files which only

00:08:29,770 --> 00:08:34,540
occur there one of the is a delta object

00:08:32,160 --> 00:08:36,130
with an offset that tells you where and

00:08:34,540 --> 00:08:38,320
the pack file the other object is that

00:08:36,130 --> 00:08:41,680
you need to read to apply the Delta on

00:08:38,320 --> 00:08:44,560
top off and the other one is a delta

00:08:41,680 --> 00:08:49,060
which refers to its base by the by the

00:08:44,560 --> 00:08:50,290
sha-1 ID of the object and you also have

00:08:49,060 --> 00:08:52,570
a pack index which is stored in a

00:08:50,290 --> 00:08:54,400
separate file and that allows you to to

00:08:52,570 --> 00:08:55,860
know where the objects are basically

00:08:54,400 --> 00:08:57,959
it's just a list of IDs and

00:08:55,860 --> 00:09:00,000
that's into the pack fire when this kid

00:08:57,959 --> 00:09:02,339
looks like this you have to pack index

00:09:00,000 --> 00:09:04,589
and you have the pack file and this is a

00:09:02,339 --> 00:09:07,170
whole source tree that I that I packed

00:09:04,589 --> 00:09:10,110
it's a gig of storage which is a lot

00:09:07,170 --> 00:09:13,200
more efficient than CVS and the pack

00:09:10,110 --> 00:09:15,420
files are also used in git for

00:09:13,200 --> 00:09:17,459
communication purposes so when you send

00:09:15,420 --> 00:09:19,649
a collection of objects between servers

00:09:17,459 --> 00:09:22,019
they will usually be packed in a fact

00:09:19,649 --> 00:09:25,260
file so you use the same space

00:09:22,019 --> 00:09:28,579
efficiency to get to limit the amount of

00:09:25,260 --> 00:09:28,579
network traffic that's being sent around

00:09:28,820 --> 00:09:33,470
it also has a concept of references

00:09:31,440 --> 00:09:35,880
which allows you to basically apply

00:09:33,470 --> 00:09:39,690
user-defined labels or names to

00:09:35,880 --> 00:09:41,700
particular objects generally it's just a

00:09:39,690 --> 00:09:44,310
mapping from a string to an ax or sha-1

00:09:41,700 --> 00:09:47,790
ID or from a string to another reference

00:09:44,310 --> 00:09:50,339
and mostly you use those to identify

00:09:47,790 --> 00:09:52,560
your branches because when you have a

00:09:50,339 --> 00:09:55,700
reference to a commit object that you

00:09:52,560 --> 00:10:00,209
can interpret that as a head of a branch

00:09:55,700 --> 00:10:02,100
and references have the names are

00:10:00,209 --> 00:10:04,260
strings but they look like file system

00:10:02,100 --> 00:10:07,019
paths in a way and they always start

00:10:04,260 --> 00:10:08,310
with refs and then you have several

00:10:07,019 --> 00:10:10,890
categories you have the heads for the

00:10:08,310 --> 00:10:14,070
branch heads you have tags to find the

00:10:10,890 --> 00:10:16,500
tag object and remotes contains multiple

00:10:14,070 --> 00:10:18,709
directories want a remote repository

00:10:16,500 --> 00:10:21,449
that your repository knows about and

00:10:18,709 --> 00:10:25,110
contains copies of the history that

00:10:21,449 --> 00:10:26,730
exists in those repositories and give

00:10:25,110 --> 00:10:28,170
more trees internally uses references

00:10:26,730 --> 00:10:31,500
for a couple of things and stores those

00:10:28,170 --> 00:10:33,000
in in the refs cough namespace when you

00:10:31,500 --> 00:10:35,160
use it on the command line you don't

00:10:33,000 --> 00:10:36,600
have to type refs heads refs tags and so

00:10:35,160 --> 00:10:37,949
on all the time you can just provide a

00:10:36,600 --> 00:10:40,529
name and it will be looked at in the

00:10:37,949 --> 00:10:45,269
given order there and to disambiguate

00:10:40,529 --> 00:10:47,610
you can just use the full name ok

00:10:45,269 --> 00:10:51,140
anybody that's hanging still have

00:10:47,610 --> 00:10:58,290
questions ok you're good you can go on

00:10:51,140 --> 00:11:02,310
sorry so this interface that that was

00:10:58,290 --> 00:11:04,199
built for this isn't like very new

00:11:02,310 --> 00:11:07,170
invention it's just a combination of

00:11:04,199 --> 00:11:09,390
things that I happen to to like and

00:11:07,170 --> 00:11:11,670
version control systems that I use

00:11:09,390 --> 00:11:13,800
and I use all of the ones that are there

00:11:11,670 --> 00:11:15,990
on the slide and I also use fossil and

00:11:13,800 --> 00:11:20,000
I've basically because I've been working

00:11:15,990 --> 00:11:22,079
on SVN for many years I have to sort of

00:11:20,000 --> 00:11:24,000
understand what everyone else is doing

00:11:22,079 --> 00:11:25,500
and so I have a fairly broad idea of how

00:11:24,000 --> 00:11:27,060
people have implemented all these

00:11:25,500 --> 00:11:31,050
operations that version control systems

00:11:27,060 --> 00:11:33,149
do and so I thought about what would I

00:11:31,050 --> 00:11:35,790
like to see when I am working with the

00:11:33,149 --> 00:11:39,630
git repository and started to to just

00:11:35,790 --> 00:11:41,610
implement it bit by bit and I also

00:11:39,630 --> 00:11:43,560
wanted to make sure that I only write

00:11:41,610 --> 00:11:45,390
code that's actually going to be used by

00:11:43,560 --> 00:11:47,300
OpenBSD developers and I don't want to

00:11:45,390 --> 00:11:50,010
add features that they won't need so

00:11:47,300 --> 00:11:53,790
this saves time and it also keeps the

00:11:50,010 --> 00:11:56,850
same interface simpler I also made sure

00:11:53,790 --> 00:11:58,410
that I don't use long options so you

00:11:56,850 --> 00:11:59,579
only have single letter options I just

00:11:58,410 --> 00:12:01,140
kept the amount of options at the

00:11:59,579 --> 00:12:05,459
minimum so we only have the office you

00:12:01,140 --> 00:12:07,140
absolutely need and you end up with a

00:12:05,459 --> 00:12:11,670
list like this for local version control

00:12:07,140 --> 00:12:13,050
operations you can maybe look over this

00:12:11,670 --> 00:12:16,649
and see if you find your favorite

00:12:13,050 --> 00:12:18,180
commands there or not and in particular

00:12:16,649 --> 00:12:20,459
though you should not assume that any of

00:12:18,180 --> 00:12:24,110
these do whatever they do in the version

00:12:20,459 --> 00:12:24,110
control systems you already used to

00:12:24,440 --> 00:12:30,630
because they produce that's a different

00:12:28,290 --> 00:12:33,420
way of consistency that doesn't exist

00:12:30,630 --> 00:12:34,410
elsewhere getting every sort of tool has

00:12:33,420 --> 00:12:36,180
their own way of making things

00:12:34,410 --> 00:12:40,019
consistent and this is just consistent

00:12:36,180 --> 00:12:41,459
in a different way this is a small

00:12:40,019 --> 00:12:42,810
example project that we're going to use

00:12:41,459 --> 00:12:44,490
so I just want to show you the interface

00:12:42,810 --> 00:12:46,350
for a bit so we can just walk through

00:12:44,490 --> 00:12:48,329
some of the operations so you see it's a

00:12:46,350 --> 00:12:51,570
hello world project to make file and a

00:12:48,329 --> 00:12:53,070
readme you would start off by creating a

00:12:51,570 --> 00:12:55,140
new repository of course you can also

00:12:53,070 --> 00:12:57,779
use git to clone one and operate on that

00:12:55,140 --> 00:12:59,100
that's possible but for displaying

00:12:57,779 --> 00:13:01,410
around with it this is the easy way to

00:12:59,100 --> 00:13:02,880
start so we create a repository and we

00:13:01,410 --> 00:13:06,209
import files and from a temporary

00:13:02,880 --> 00:13:09,209
directory into it and two things happen

00:13:06,209 --> 00:13:11,820
here well the files get added obviously

00:13:09,209 --> 00:13:13,709
it writes objects as we just in the way

00:13:11,820 --> 00:13:15,480
we've just seen and it creates two

00:13:13,709 --> 00:13:18,270
things it creates the commit hash that

00:13:15,480 --> 00:13:20,160
you then use as the first commit in your

00:13:18,270 --> 00:13:21,060
entire line of history so this commit

00:13:20,160 --> 00:13:22,860
has no parents

00:13:21,060 --> 00:13:25,020
it's a root comment

00:13:22,860 --> 00:13:27,540
and also it creates a branch for you

00:13:25,020 --> 00:13:29,610
because in game of treats you cannot

00:13:27,540 --> 00:13:31,620
work on any thing unless it's on a

00:13:29,610 --> 00:13:34,740
branch and because the work trees have

00:13:31,620 --> 00:13:36,390
to know which branch they're on and it

00:13:34,740 --> 00:13:38,760
also creates a head reference but that's

00:13:36,390 --> 00:13:41,490
mostly forget so the kid knows what's

00:13:38,760 --> 00:13:43,410
going on and we only use the head

00:13:41,490 --> 00:13:46,170
reference as a default references you

00:13:43,410 --> 00:13:47,700
don't if you don't specify one and so

00:13:46,170 --> 00:13:49,710
after an import the repository looks

00:13:47,700 --> 00:13:52,140
like this it has the head reference the

00:13:49,710 --> 00:13:55,560
master reference and the objects and the

00:13:52,140 --> 00:13:57,060
tree as discussed before and then we

00:13:55,560 --> 00:13:58,920
actually do work on this because we

00:13:57,060 --> 00:14:01,350
don't have a rectory yet just have this

00:13:58,920 --> 00:14:03,360
bear git repository on the disk you do a

00:14:01,350 --> 00:14:06,630
check out and you get that creates a

00:14:03,360 --> 00:14:08,220
work tree and this can be placed

00:14:06,630 --> 00:14:13,740
anywhere and you can create as many as

00:14:08,220 --> 00:14:16,800
you want and eat and you can also check

00:14:13,740 --> 00:14:19,620
out the same work tree from the same

00:14:16,800 --> 00:14:23,640
branch many times which is something

00:14:19,620 --> 00:14:24,930
that it makes it hard to do then you do

00:14:23,640 --> 00:14:30,690
some changes you can view your changes

00:14:24,930 --> 00:14:31,320
with status you can use diff to look at

00:14:30,690 --> 00:14:33,870
if command

00:14:31,320 --> 00:14:35,430
to see the changes you've made and this

00:14:33,870 --> 00:14:38,010
is a lot of boilerplate text and I had

00:14:35,430 --> 00:14:40,740
some some divs on the future slides just

00:14:38,010 --> 00:14:42,240
to lit all this context so but you can

00:14:40,740 --> 00:14:43,800
nicely see that it presents you all the

00:14:42,240 --> 00:14:47,490
IDs involved in the diff so you know

00:14:43,800 --> 00:14:49,830
what's been left and two commits use the

00:14:47,490 --> 00:14:52,380
commit command and you create commits

00:14:49,830 --> 00:14:53,880
with that of course I'm writing the full

00:14:52,380 --> 00:14:55,530
name of each command here but they also

00:14:53,880 --> 00:14:57,180
have short alliances to make it easier

00:14:55,530 --> 00:14:59,010
to type them but these license are not

00:14:57,180 --> 00:15:00,810
flexible you cannot use or define them

00:14:59,010 --> 00:15:02,340
because I don't want people to go off

00:15:00,810 --> 00:15:04,200
and redesign the interface to their

00:15:02,340 --> 00:15:06,630
liking because I want people to be able

00:15:04,200 --> 00:15:08,640
to communicate a mostly to other how to

00:15:06,630 --> 00:15:10,890
use the tool and that only works if

00:15:08,640 --> 00:15:15,930
everyone speaks the same language so no

00:15:10,890 --> 00:15:20,940
configurable Elias is here so once we

00:15:15,930 --> 00:15:22,500
have a commit basically this is a same

00:15:20,940 --> 00:15:23,820
diagram again except you don't see the

00:15:22,500 --> 00:15:25,800
tree of the first commit which still

00:15:23,820 --> 00:15:27,060
exists but you see a new tree and you

00:15:25,800 --> 00:15:29,100
see how the commits are linked and you

00:15:27,060 --> 00:15:31,280
see that the master reference has moved

00:15:29,100 --> 00:15:31,280
up

00:15:32,290 --> 00:15:35,980
can also describe the local changes of

00:15:33,970 --> 00:15:37,810
course and for that like an SVM you'd

00:15:35,980 --> 00:15:40,029
use the revert command which is

00:15:37,810 --> 00:15:41,800
destructive and really deletes things

00:15:40,029 --> 00:15:47,259
you've written so you have to be careful

00:15:41,800 --> 00:15:50,350
when using it and you can also use this

00:15:47,259 --> 00:15:51,730
to pick individual changes from files

00:15:50,350 --> 00:15:54,790
which is something that SVN does not

00:15:51,730 --> 00:15:56,290
offer but get does so basically forget

00:15:54,790 --> 00:15:58,089
users this is the equivalent of check

00:15:56,290 --> 00:16:00,190
out that piece so if you have two

00:15:58,089 --> 00:16:02,829
changes in the file you can run the

00:16:00,190 --> 00:16:04,660
revert - P you can individually select

00:16:02,829 --> 00:16:06,819
the changes that you want and say yes or

00:16:04,660 --> 00:16:09,009
no for each of them so here we say no

00:16:06,819 --> 00:16:10,300
because we liked f adults and here we

00:16:09,009 --> 00:16:12,819
say yes because we don't like syntax

00:16:10,300 --> 00:16:18,040
errors and after that the file is like

00:16:12,819 --> 00:16:20,199
this and we can commit it and so this

00:16:18,040 --> 00:16:22,930
actually happened because JC has told me

00:16:20,199 --> 00:16:24,430
he often uses get where he fixes about

00:16:22,930 --> 00:16:27,130
and he adds lots of debug printers to

00:16:24,430 --> 00:16:28,990
code it eventually fixes the bug in a

00:16:27,130 --> 00:16:30,310
small section of the file and then he

00:16:28,990 --> 00:16:32,709
has to go through and remove all these

00:16:30,310 --> 00:16:35,500
debug foreign toughs again and there's a

00:16:32,709 --> 00:16:38,529
couple of ways of then committing only

00:16:35,500 --> 00:16:40,480
that change he actually won't and one of

00:16:38,529 --> 00:16:41,980
these is to just revert all the changes

00:16:40,480 --> 00:16:43,449
you don't want and so you can go through

00:16:41,980 --> 00:16:45,160
this interactively you don't have to

00:16:43,449 --> 00:16:46,779
like open the file in editor search for

00:16:45,160 --> 00:16:48,940
the printers you just go through them

00:16:46,779 --> 00:16:50,440
though because revert is destructive you

00:16:48,940 --> 00:16:51,760
currently have to be careful what you do

00:16:50,440 --> 00:16:54,010
at this prompt because the change will

00:16:51,760 --> 00:16:55,660
be lost and I'm thinking that maybe

00:16:54,010 --> 00:16:56,980
that's not such a great idea and that we

00:16:55,660 --> 00:17:00,029
should produce the backup in that case

00:16:56,980 --> 00:17:02,649
but that's an implementation detail

00:17:00,029 --> 00:17:04,659
another example of how things are done

00:17:02,649 --> 00:17:08,199
here is that when you back out the

00:17:04,659 --> 00:17:11,860
change has already committed it's again

00:17:08,199 --> 00:17:14,110
modeled a bit on subversion soryu you

00:17:11,860 --> 00:17:16,540
need a work three which is at the latest

00:17:14,110 --> 00:17:20,230
head of the branch which contained the

00:17:16,540 --> 00:17:21,909
bad change and you might already have

00:17:20,230 --> 00:17:24,730
local changes in there we don't care

00:17:21,909 --> 00:17:26,919
about that but this worked we will carry

00:17:24,730 --> 00:17:28,690
the changes that you're undoing which me

00:17:26,919 --> 00:17:30,909
it basically means you apply the inverse

00:17:28,690 --> 00:17:32,530
diff of a commit that was already

00:17:30,909 --> 00:17:33,820
committed in history and the command for

00:17:32,530 --> 00:17:36,100
this is called backup and you just give

00:17:33,820 --> 00:17:37,870
it the ID which as you can see here can

00:17:36,100 --> 00:17:39,520
be abbreviated and then it just made us

00:17:37,870 --> 00:17:43,169
change and you have the change in your

00:17:39,520 --> 00:17:43,169
working copy like this

00:17:43,840 --> 00:17:54,890
nobody will ever need that I think I've

00:17:47,960 --> 00:17:56,330
backed up some dust before okay let's

00:17:54,890 --> 00:17:59,390
talk about branches a bit so we know

00:17:56,330 --> 00:18:01,100
that nobody is the we don't really use

00:17:59,390 --> 00:18:04,150
branches what we do is to some extent we

00:18:01,100 --> 00:18:06,560
have Sabre branches for releases and we

00:18:04,150 --> 00:18:09,650
specifically switched the purpose of the

00:18:06,560 --> 00:18:11,240
head into release mode ahead of release

00:18:09,650 --> 00:18:12,800
which could also be considered a form of

00:18:11,240 --> 00:18:16,100
a branch it's just that we do it on the

00:18:12,800 --> 00:18:17,570
same on the same set of files we just

00:18:16,100 --> 00:18:20,390
declare that the purpose of this branch

00:18:17,570 --> 00:18:22,850
has now changed but we still have stable

00:18:20,390 --> 00:18:25,130
branches and also we have some some

00:18:22,850 --> 00:18:27,200
vendor branches in the cork tree to

00:18:25,130 --> 00:18:29,990
import things like LVM and things like

00:18:27,200 --> 00:18:31,400
this but now for now just keep in mind

00:18:29,990 --> 00:18:32,690
that we have references and they point

00:18:31,400 --> 00:18:36,170
out commits and that's what a branch is

00:18:32,690 --> 00:18:37,610
is modeled as what you cannot do yet in

00:18:36,170 --> 00:18:39,770
game of trees is you cannot create merge

00:18:37,610 --> 00:18:41,210
commits because I haven't yet found a

00:18:39,770 --> 00:18:43,310
way where I need this for my own

00:18:41,210 --> 00:18:45,830
workflow against the OpenBSD source tree

00:18:43,310 --> 00:18:47,330
it could eventually be added but I would

00:18:45,830 --> 00:18:52,210
discourage this use and confine it to

00:18:47,330 --> 00:18:57,290
very few areas such as vendor branches

00:18:52,210 --> 00:18:59,720
because we want a linear history that's

00:18:57,290 --> 00:19:04,250
easy to understand even for external

00:18:59,720 --> 00:19:05,930
consumers and having having lots of

00:19:04,250 --> 00:19:08,180
branches in the project would just just

00:19:05,930 --> 00:19:09,620
make progress harder for us so currently

00:19:08,180 --> 00:19:10,820
there's no way of doing this it would be

00:19:09,620 --> 00:19:13,460
easy to add it wouldn't be a problem

00:19:10,820 --> 00:19:14,810
there's already code to do it a theory

00:19:13,460 --> 00:19:18,290
it will just have to be added as a

00:19:14,810 --> 00:19:19,850
front-end and to create a branch and

00:19:18,290 --> 00:19:21,890
game of trees you use a branch command

00:19:19,850 --> 00:19:23,750
you give a name by default it uses the

00:19:21,890 --> 00:19:25,130
current party honors the base and then

00:19:23,750 --> 00:19:28,280
you can list your branches and you see

00:19:25,130 --> 00:19:30,020
that another one has appeared now what

00:19:28,280 --> 00:19:31,070
all this did was really just created

00:19:30,020 --> 00:19:32,750
reference it didn't change your work

00:19:31,070 --> 00:19:39,380
tree in any way it just added the second

00:19:32,750 --> 00:19:41,000
reference to this commit and I just said

00:19:39,380 --> 00:19:45,490
that we don't really use branches norm

00:19:41,000 --> 00:19:48,230
BSD so why are we creating a branch now

00:19:45,490 --> 00:19:51,290
the problem is that in this data model

00:19:48,230 --> 00:19:53,360
you cannot see changes other people have

00:19:51,290 --> 00:19:55,160
made before you copy them to your

00:19:53,360 --> 00:19:56,450
repository so you need to store those

00:19:55,160 --> 00:19:57,010
changes somewhere before you can even

00:19:56,450 --> 00:20:00,530
see the

00:19:57,010 --> 00:20:03,860
let alone merge them so you need a space

00:20:00,530 --> 00:20:05,450
some reference that says this is what

00:20:03,860 --> 00:20:07,580
happened elsewhere and this is what

00:20:05,450 --> 00:20:07,970
happened locally and you need to have

00:20:07,580 --> 00:20:10,340
that

00:20:07,970 --> 00:20:12,590
so normally ideally in a networked

00:20:10,340 --> 00:20:14,330
version of this you would store it under

00:20:12,590 --> 00:20:16,610
remote somewhere but it's really just a

00:20:14,330 --> 00:20:19,580
name I mean you know you just decide

00:20:16,610 --> 00:20:21,050
that some references some represent

00:20:19,580 --> 00:20:22,760
external state and some references

00:20:21,050 --> 00:20:24,890
represent your local branches and then

00:20:22,760 --> 00:20:27,440
that's that and so for this example we

00:20:24,890 --> 00:20:30,230
can pretend that the master branch is

00:20:27,440 --> 00:20:35,450
the remote state and the hiking branches

00:20:30,230 --> 00:20:36,920
are our local state and to switch

00:20:35,450 --> 00:20:38,800
directly between branches you use the

00:20:36,920 --> 00:20:40,880
update command with the dash be flag

00:20:38,800 --> 00:20:42,620
normally update would not allow you to

00:20:40,880 --> 00:20:45,410
switch branches it would only move you

00:20:42,620 --> 00:20:47,720
up and down in the same branch but with

00:20:45,410 --> 00:20:49,880
Debbie you can say yes I want to change

00:20:47,720 --> 00:20:51,970
the branch please reassociate this work

00:20:49,880 --> 00:20:54,140
tree with a different one and then

00:20:51,970 --> 00:20:55,580
nothing happens really because the

00:20:54,140 --> 00:20:56,900
hashes started the same with both of the

00:20:55,580 --> 00:21:00,110
branches but the metadata has been

00:20:56,900 --> 00:21:04,330
updated so now we commit two changes

00:21:00,110 --> 00:21:07,880
that are related to hiking somewhat and

00:21:04,330 --> 00:21:10,150
we end up with a repository structure

00:21:07,880 --> 00:21:13,910
that looks like this

00:21:10,150 --> 00:21:16,190
so hiking has moved up and master is

00:21:13,910 --> 00:21:20,660
still at the old commit that we started

00:21:16,190 --> 00:21:24,770
out so now someone else somewhere in the

00:21:20,660 --> 00:21:27,200
world makes another change if you try to

00:21:24,770 --> 00:21:29,420
slowly just get a second work tree to

00:21:27,200 --> 00:21:32,870
commit to the master branch it's just

00:21:29,420 --> 00:21:34,400
essentially the same situation and you

00:21:32,870 --> 00:21:35,840
end up like this so now you have two

00:21:34,400 --> 00:21:38,930
branches and they have diverged they

00:21:35,840 --> 00:21:40,610
have a common ancestor commit and you

00:21:38,930 --> 00:21:43,130
have two references that look at and

00:21:40,610 --> 00:21:45,260
look at their worst history so now

00:21:43,130 --> 00:21:47,180
what's important here is that because we

00:21:45,260 --> 00:21:50,780
consider the master branch to be an

00:21:47,180 --> 00:21:53,240
external branch it's basically part of

00:21:50,780 --> 00:21:56,030
the official public history that the

00:21:53,240 --> 00:21:57,560
project has produced right and our

00:21:56,030 --> 00:22:04,610
hiking branch our local changes that

00:21:57,560 --> 00:22:06,680
that only we see because we're not

00:22:04,610 --> 00:22:08,540
allowed to change commit IDs of things

00:22:06,680 --> 00:22:10,290
that are already already declared part

00:22:08,540 --> 00:22:12,690
of official history absolute

00:22:10,290 --> 00:22:16,980
we cannot change the IDs of things on

00:22:12,690 --> 00:22:21,090
the master branch so so 3 3 a B & 3 4 90

00:22:16,980 --> 00:22:24,180
are fixed you cannot change them however

00:22:21,090 --> 00:22:27,180
the other commits can change and since

00:22:24,180 --> 00:22:29,880
the hashing of get runs through the

00:22:27,180 --> 00:22:32,430
entire trail of objects that reference

00:22:29,880 --> 00:22:35,220
each other and these hashes will change

00:22:32,430 --> 00:22:37,590
if we change the base of these commits

00:22:35,220 --> 00:22:40,440
but we have to do that in order to keep

00:22:37,590 --> 00:22:43,410
linear history linear so if you want to

00:22:40,440 --> 00:22:44,580
make history linear again we have to

00:22:43,410 --> 00:22:46,710
take those two commits on the hiking

00:22:44,580 --> 00:22:48,810
branch and move them up to the current

00:22:46,710 --> 00:22:52,440
head of the master and that's called

00:22:48,810 --> 00:22:54,510
rebasing and this is basically how you

00:22:52,440 --> 00:23:00,660
merge your local changes with the

00:22:54,510 --> 00:23:05,600
incoming changes in this tool so to

00:23:00,660 --> 00:23:08,810
rebase you need again a work tree and

00:23:05,600 --> 00:23:12,510
this time this work tree comes from

00:23:08,810 --> 00:23:15,000
commit 3 3 a b and it's on the master

00:23:12,510 --> 00:23:17,370
branch because that's where we want to

00:23:15,000 --> 00:23:20,130
rebase hiking on top off so we basically

00:23:17,370 --> 00:23:24,060
we get the base that we want this

00:23:20,130 --> 00:23:25,350
history to be applied on to and we're

00:23:24,060 --> 00:23:26,880
not allowed to have any local changes in

00:23:25,350 --> 00:23:30,600
this work tree because that just avoids

00:23:26,880 --> 00:23:31,950
unnecessary merge conflicts then game of

00:23:30,600 --> 00:23:34,020
trees will internally switch this worked

00:23:31,950 --> 00:23:36,180
it to a temporary branch and apply the

00:23:34,020 --> 00:23:38,490
commits that you've made before on top

00:23:36,180 --> 00:23:41,070
of the new base and once all that is

00:23:38,490 --> 00:23:42,660
done and has succeeded it will take a

00:23:41,070 --> 00:23:45,330
Semper Airy branch and this one becomes

00:23:42,660 --> 00:23:47,580
the new hiking branch and the old hiking

00:23:45,330 --> 00:23:48,870
branch basically just sits there in the

00:23:47,580 --> 00:23:50,400
repository and can be garbage collected

00:23:48,870 --> 00:23:53,190
at some point which is not yet

00:23:50,400 --> 00:23:54,630
implemented so you could run get GC or

00:23:53,190 --> 00:23:58,980
something like this to really delete it

00:23:54,630 --> 00:24:00,360
but it's not really important and so

00:23:58,980 --> 00:24:02,460
this looks and the user interface it

00:24:00,360 --> 00:24:06,540
looks like this you switch back to the

00:24:02,460 --> 00:24:08,280
master branch and you say hi rebase or

00:24:06,540 --> 00:24:12,420
hiking branch please and then you get

00:24:08,280 --> 00:24:17,090
conflicts of course as usual now the

00:24:12,420 --> 00:24:17,090
conflicts look as you would expect and

00:24:17,840 --> 00:24:22,650
you know and the status command you

00:24:20,130 --> 00:24:23,750
would see a C for this file because it

00:24:22,650 --> 00:24:25,010
contains conflict markers

00:24:23,750 --> 00:24:27,590
so there's a couple of ways version

00:24:25,010 --> 00:24:29,390
control systems have done this some have

00:24:27,590 --> 00:24:30,740
special conflict metadata that says like

00:24:29,390 --> 00:24:32,300
this file was in conflict and you have

00:24:30,740 --> 00:24:34,370
to run a command to clear this flag so

00:24:32,300 --> 00:24:35,990
that you may commit it in this tool it

00:24:34,370 --> 00:24:38,210
simply looked for these conflict markers

00:24:35,990 --> 00:24:40,490
and if they're still present you cannot

00:24:38,210 --> 00:24:43,000
commit once you remove them or change

00:24:40,490 --> 00:24:48,440
them even it allows you to commit them

00:24:43,000 --> 00:24:53,120
and I wanted to briefly explain I think

00:24:48,440 --> 00:24:55,280
we have enough time still that how this

00:24:53,120 --> 00:24:56,840
merge is actually done how do we why do

00:24:55,280 --> 00:25:00,350
we get this conflict and why do we get

00:24:56,840 --> 00:25:02,510
this output that we see because I've

00:25:00,350 --> 00:25:03,620
seen a lot of people actually using

00:25:02,510 --> 00:25:05,450
these tools but never really

00:25:03,620 --> 00:25:06,950
understanding how the merge conflicts

00:25:05,450 --> 00:25:10,130
come about and always complaining that

00:25:06,950 --> 00:25:12,170
which conflicts happen man and it's all

00:25:10,130 --> 00:25:15,290
magic and not really clear how it's

00:25:12,170 --> 00:25:17,180
happening so there's a simple way to

00:25:15,290 --> 00:25:18,560
into to represent or to do to

00:25:17,180 --> 00:25:20,690
communicate the idea of how drift 3

00:25:18,560 --> 00:25:25,670
actually works so the best if 3 you get

00:25:20,690 --> 00:25:28,280
3 files as input and in our case there's

00:25:25,670 --> 00:25:30,440
an original file which is the one that

00:25:28,280 --> 00:25:32,900
was in the commit at the very bottom of

00:25:30,440 --> 00:25:34,760
the shared history of the branches as we

00:25:32,900 --> 00:25:39,610
see them sort of before so maybe I go

00:25:34,760 --> 00:25:42,920
back and till you see this

00:25:39,610 --> 00:25:45,230
so the the base comes from the original

00:25:42,920 --> 00:25:46,490
comes from commit 3 for an ID that's

00:25:45,230 --> 00:25:50,500
where we take one file form the other

00:25:46,490 --> 00:25:50,500
two files are on the tips of each branch

00:25:52,330 --> 00:25:58,960
so then we call these files a and B and

00:25:56,200 --> 00:26:01,130
you can imagine here that every number

00:25:58,960 --> 00:26:04,010
represents a line of text in the files

00:26:01,130 --> 00:26:08,600
just to is easier to make it easier to

00:26:04,010 --> 00:26:11,150
visualize the algorithm works so what it

00:26:08,600 --> 00:26:17,120
does it is compares the original file to

00:26:11,150 --> 00:26:19,550
a DI file number a and again in the

00:26:17,120 --> 00:26:22,310
original file to the drive D it never

00:26:19,550 --> 00:26:24,110
compares a and B directly and it marks

00:26:22,310 --> 00:26:25,880
the the regions for each of these files

00:26:24,110 --> 00:26:27,440
differ from the original and if they if

00:26:25,880 --> 00:26:29,840
these readers don't overlap it just

00:26:27,440 --> 00:26:32,390
produces the output below and it

00:26:29,840 --> 00:26:34,490
basically takes the sexual set the files

00:26:32,390 --> 00:26:37,490
wanted to change and in this case the

00:26:34,490 --> 00:26:39,080
merge says it's all good whether this

00:26:37,490 --> 00:26:40,820
and actually works is a different

00:26:39,080 --> 00:26:42,679
question this is not the responsibility

00:26:40,820 --> 00:26:47,330
of diff three but if three produces

00:26:42,679 --> 00:26:49,940
immersed version that that corresponds

00:26:47,330 --> 00:26:53,660
to this algorithm if you do this with

00:26:49,940 --> 00:26:56,390
different inputs so for instance a B

00:26:53,660 --> 00:26:58,700
like this you would more end up marking

00:26:56,390 --> 00:27:00,950
overlapping sections and in that case

00:26:58,700 --> 00:27:05,380
the algorithm can't decide what to do it

00:27:00,950 --> 00:27:07,580
has two versions of changes that don't

00:27:05,380 --> 00:27:09,320
that are not the same on either side so

00:27:07,580 --> 00:27:11,300
it has to offer you both possibilities

00:27:09,320 --> 00:27:13,580
and that's that's why I see these

00:27:11,300 --> 00:27:14,929
conflict markers in the output that's

00:27:13,580 --> 00:27:16,520
perhaps a bit confusing is that you

00:27:14,929 --> 00:27:19,250
don't ever see the original file on this

00:27:16,520 --> 00:27:21,920
output subversion has started actually

00:27:19,250 --> 00:27:25,160
to show it a few releases ago so now we

00:27:21,920 --> 00:27:26,660
there we produce four-way output or

00:27:25,160 --> 00:27:29,120
3-way output for actual diff three

00:27:26,660 --> 00:27:31,970
results and some users have responded to

00:27:29,120 --> 00:27:33,710
that very positively so I haven't yet

00:27:31,970 --> 00:27:37,280
decided by the game of Twister to the

00:27:33,710 --> 00:27:38,420
same but it's an option anyways you want

00:27:37,280 --> 00:27:40,190
to know more about this three there's

00:27:38,420 --> 00:27:44,660
this fantastic paper which also explains

00:27:40,190 --> 00:27:48,679
the algorithm but these may be tables

00:27:44,660 --> 00:27:51,800
and has a lot more details now we've

00:27:48,679 --> 00:27:54,020
fixed the conflict basically the

00:27:51,800 --> 00:27:55,730
resolution is arbitrary it depends on

00:27:54,020 --> 00:27:58,040
what the programmer really wants and we

00:27:55,730 --> 00:28:00,440
say please continue by saying now we

00:27:58,040 --> 00:28:01,970
create a new community that has we see

00:28:00,440 --> 00:28:03,830
the old and new ID of this commit that's

00:28:01,970 --> 00:28:05,360
been rebase but again we have conflict

00:28:03,830 --> 00:28:07,580
so we have to do this all over again and

00:28:05,360 --> 00:28:09,590
this time we see that oh yeah we added a

00:28:07,580 --> 00:28:12,080
second line and in our branch and we

00:28:09,590 --> 00:28:14,179
also have to have to merge that so

00:28:12,080 --> 00:28:15,650
generally you don't really get conflicts

00:28:14,179 --> 00:28:17,059
all the time like this but because of

00:28:15,650 --> 00:28:20,450
these toy examples I'm using of course

00:28:17,059 --> 00:28:22,760
they they occur I've managed Wireless

00:28:20,450 --> 00:28:25,610
changes with like 140 commits on top of

00:28:22,760 --> 00:28:32,900
the BST master and it's fine but it's

00:28:25,610 --> 00:28:35,000
not a burden so then we fix this up and

00:28:32,900 --> 00:28:36,740
maybe even at other context or not

00:28:35,000 --> 00:28:38,840
changes whatever the tool doesn't care

00:28:36,740 --> 00:28:42,410
and we just say ok we're done with

00:28:38,840 --> 00:28:43,880
resolving this conflict and now there

00:28:42,410 --> 00:28:47,510
are two new commits our work tree is

00:28:43,880 --> 00:28:48,860
called under hiking branch it's on the

00:28:47,510 --> 00:28:50,320
hiking branch again but this time it's

00:28:48,860 --> 00:28:55,270
the new version of the hiking branch

00:28:50,320 --> 00:28:56,410
is reversed so now again we have a

00:28:55,270 --> 00:28:59,650
linear chain of commits in the

00:28:56,410 --> 00:29:01,180
repository and everything's good you can

00:28:59,650 --> 00:29:02,890
look at those in detail with the lock -

00:29:01,180 --> 00:29:04,420
P command and you see the lock messages

00:29:02,890 --> 00:29:06,270
to date author information and the

00:29:04,420 --> 00:29:08,620
changes that were actually committed and

00:29:06,270 --> 00:29:10,180
so what's nice about this tool is that

00:29:08,620 --> 00:29:11,830
compared to CVS it gives you actual

00:29:10,180 --> 00:29:14,560
change sets across several files and

00:29:11,830 --> 00:29:17,260
everything and this really helps me also

00:29:14,560 --> 00:29:19,000
just looking to basically I stopped

00:29:17,260 --> 00:29:20,290
pretty much following the commitment

00:29:19,000 --> 00:29:22,720
listen I just update might get

00:29:20,290 --> 00:29:24,160
repository and browse it to see what

00:29:22,720 --> 00:29:32,980
people have been working on it's pretty

00:29:24,160 --> 00:29:34,600
neat the browser Oh No okay so people

00:29:32,980 --> 00:29:35,890
have requested features so I was

00:29:34,600 --> 00:29:37,870
basically done at that point but the

00:29:35,890 --> 00:29:39,850
feature set that was all I needed

00:29:37,870 --> 00:29:43,060
apart from adding or removing files and

00:29:39,850 --> 00:29:46,690
things like that and you can also state

00:29:43,060 --> 00:29:48,130
changes for commit and contrary to get

00:29:46,690 --> 00:29:49,660
in this tool staging is entirely

00:29:48,130 --> 00:29:51,610
optional so you don't have to use it you

00:29:49,660 --> 00:29:55,870
can just run commit and always commit

00:29:51,610 --> 00:29:58,390
everything that's in the work tree but

00:29:55,870 --> 00:30:00,400
if you have state changes the commit and

00:29:58,390 --> 00:30:02,080
diff commands and status commands change

00:30:00,400 --> 00:30:04,720
their behavior accordingly and only show

00:30:02,080 --> 00:30:06,460
you either staged on our state changes

00:30:04,720 --> 00:30:08,890
depending on what you ask for and commit

00:30:06,460 --> 00:30:11,710
will never allow you to commit unstaged

00:30:08,890 --> 00:30:14,920
us if you already have something staged

00:30:11,710 --> 00:30:19,000
you also cannot update files which have

00:30:14,920 --> 00:30:20,710
state changes and if you run into a

00:30:19,000 --> 00:30:23,950
problem there where you're behind you're

00:30:20,710 --> 00:30:25,450
the head of the branch and you want to

00:30:23,950 --> 00:30:27,190
commit but can't you have to actually on

00:30:25,450 --> 00:30:29,290
stage your changes which means you merge

00:30:27,190 --> 00:30:32,220
them back into the work tree and then

00:30:29,290 --> 00:30:34,540
update and then stage again if you like

00:30:32,220 --> 00:30:36,550
then there's a history command which is

00:30:34,540 --> 00:30:38,260
like what get calls interactively base

00:30:36,550 --> 00:30:41,140
and it allows you to reorder commits

00:30:38,260 --> 00:30:42,670
change to merge them and add a lot of

00:30:41,140 --> 00:30:43,990
messages and all this kind of stuff and

00:30:42,670 --> 00:30:46,240
this would of course only be done in

00:30:43,990 --> 00:30:48,490
with your local history but this is a

00:30:46,240 --> 00:30:51,700
great way of preparing this for review

00:30:48,490 --> 00:30:53,140
and throwing out I needed changes that

00:30:51,700 --> 00:30:55,270
you weren't really sure whether you

00:30:53,140 --> 00:30:57,010
needed them or not just committed and

00:30:55,270 --> 00:30:59,920
all the sort of stuff so this is but

00:30:57,010 --> 00:31:02,090
those two features combined allow you to

00:30:59,920 --> 00:31:06,739
manage your divs pretty well

00:31:02,090 --> 00:31:09,619
there's a browser talk which allows you

00:31:06,739 --> 00:31:12,409
to browse commits if you dis annotate

00:31:09,619 --> 00:31:16,309
files and read the tree of the

00:31:12,409 --> 00:31:19,309
repository browser and I wrote this

00:31:16,309 --> 00:31:22,659
mostly because it's a really really nice

00:31:19,309 --> 00:31:25,700
way of prototyping needed functionality

00:31:22,659 --> 00:31:28,039
so this actually started very early on

00:31:25,700 --> 00:31:29,929
before it could read all this all the

00:31:28,039 --> 00:31:33,320
objects I already had some interface for

00:31:29,929 --> 00:31:34,940
this and it allowed me to verify quickly

00:31:33,320 --> 00:31:38,929
that my code was doing the right thing

00:31:34,940 --> 00:31:41,450
and I already had a user which is MPI

00:31:38,929 --> 00:31:43,969
who used this tool a lot to dig through

00:31:41,450 --> 00:31:45,859
history and learn about how the network

00:31:43,969 --> 00:31:46,399
stack works in all versions of PSC and

00:31:45,859 --> 00:31:48,559
things like that

00:31:46,399 --> 00:31:51,229
so he was using a tool called take

00:31:48,559 --> 00:31:53,539
before that and which is also okay but

00:31:51,229 --> 00:31:55,729
based on git and this is basically the

00:31:53,539 --> 00:31:57,469
equivalent but written in C and is

00:31:55,729 --> 00:32:03,619
faster actually even though it's per

00:31:57,469 --> 00:32:06,440
second so how did this start um actually

00:32:03,619 --> 00:32:07,940
the roots of this whole thing go back to

00:32:06,440 --> 00:32:09,589
your BSD code in Paris where a

00:32:07,940 --> 00:32:11,239
surprising number of people started

00:32:09,589 --> 00:32:13,460
talking about it for some reason and the

00:32:11,239 --> 00:32:16,190
hallway at dinners and things like this

00:32:13,460 --> 00:32:17,809
and when I was present people looked at

00:32:16,190 --> 00:32:22,580
me and said well you know worst control

00:32:17,809 --> 00:32:23,899
so can you give input and yeah so we

00:32:22,580 --> 00:32:25,009
ended up I ended up thinking well it

00:32:23,899 --> 00:32:28,609
seems like a couple of people interested

00:32:25,009 --> 00:32:32,119
in this and I can help and I invited

00:32:28,609 --> 00:32:34,339
Carlos who's at github now and he's a

00:32:32,119 --> 00:32:36,919
lip tattoo maintainer to a hackathon

00:32:34,339 --> 00:32:38,299
where he showed up in an afternoon and

00:32:36,919 --> 00:32:41,929
we went to the back room that everyone

00:32:38,299 --> 00:32:44,589
had on their port stuff but a couple of

00:32:41,929 --> 00:32:46,789
us went back with Carlos to discuss how

00:32:44,589 --> 00:32:49,460
realistic such a project would be and

00:32:46,789 --> 00:32:50,929
what the defaults would be and we just

00:32:49,460 --> 00:32:54,649
basically people just threw in their

00:32:50,929 --> 00:32:56,229
opinions and their ideas and we

00:32:54,649 --> 00:32:58,070
discussed them and and he basically

00:32:56,229 --> 00:33:01,489
vetted them against his own

00:32:58,070 --> 00:33:03,919
understanding of gear and at the sakkath

00:33:01,489 --> 00:33:05,899
on I started writing code to read

00:33:03,919 --> 00:33:09,139
references which is very simple and

00:33:05,899 --> 00:33:11,809
started reading objects and but the next

00:33:09,139 --> 00:33:13,970
second I had done all the objects of the

00:33:11,809 --> 00:33:14,800
object parsing it was not using for said

00:33:13,970 --> 00:33:18,130
yet it was just

00:33:14,800 --> 00:33:19,960
like pricing code and pretty soon later

00:33:18,130 --> 00:33:24,310
I could if objects and I started pack

00:33:19,960 --> 00:33:25,900
files because a lot of tests I wrote for

00:33:24,310 --> 00:33:28,090
this tool were operating on its own git

00:33:25,900 --> 00:33:29,500
repository initially and then I did a

00:33:28,090 --> 00:33:30,730
fetch or do the clone a clone at

00:33:29,500 --> 00:33:33,430
somewhere else and all the tests started

00:33:30,730 --> 00:33:34,990
failing because now things were packed

00:33:33,430 --> 00:33:38,050
and I didn't have code to read the tax

00:33:34,990 --> 00:33:40,330
so that was kind of unfortunate so I

00:33:38,050 --> 00:33:43,330
realized oh yeah I have to also add code

00:33:40,330 --> 00:33:44,980
to be taxed later there was a

00:33:43,330 --> 00:33:48,730
command-line tool I started using pledge

00:33:44,980 --> 00:33:51,760
I started to add fork and so on so it

00:33:48,730 --> 00:33:54,400
took like about a year to get to the

00:33:51,760 --> 00:34:03,970
point where it actually had a work tree

00:33:54,400 --> 00:34:07,300
that could be they could actually be

00:34:03,970 --> 00:34:11,080
used to change files and and edit them

00:34:07,300 --> 00:34:14,110
and I started using this tool for my own

00:34:11,080 --> 00:34:16,330
PC development in February this year and

00:34:14,110 --> 00:34:17,980
it couldn't create commits yet but it

00:34:16,330 --> 00:34:20,740
could manage local disks which was all I

00:34:17,980 --> 00:34:22,870
needed to get going but with mailing

00:34:20,740 --> 00:34:25,750
gifts out for a review but also couldn't

00:34:22,870 --> 00:34:27,070
handle adds and deletes yet but that was

00:34:25,750 --> 00:34:29,740
okay because I knew how to work around

00:34:27,070 --> 00:34:34,030
those things and added that support

00:34:29,740 --> 00:34:35,520
pretty much after that I added the

00:34:34,030 --> 00:34:38,590
ability to update individual paths

00:34:35,520 --> 00:34:40,510
thanks based on feedback from Theo who

00:34:38,590 --> 00:34:44,169
says that his build process pretty much

00:34:40,510 --> 00:34:47,380
requires the ability to do that and in

00:34:44,169 --> 00:34:49,360
at the general hackathon this year we

00:34:47,380 --> 00:34:52,570
thought god how to create commit objects

00:34:49,360 --> 00:34:54,760
and then things started to move a lot

00:34:52,570 --> 00:34:57,370
faster as you can see once you have sort

00:34:54,760 --> 00:34:58,960
of like a basic tool set and all the

00:34:57,370 --> 00:35:00,730
stuff is there that you need to build

00:34:58,960 --> 00:35:03,940
more things on top it just accelerates

00:35:00,730 --> 00:35:05,500
and getting all this rebasing and

00:35:03,940 --> 00:35:07,510
basically I started with this

00:35:05,500 --> 00:35:09,760
cherry-pick feature and and then I had

00:35:07,510 --> 00:35:11,350
merged had file merges and then I could

00:35:09,760 --> 00:35:14,740
just do degree basis on top of that and

00:35:11,350 --> 00:35:16,540
everything just went really fast so in

00:35:14,740 --> 00:35:18,520
April in August this year we did a first

00:35:16,540 --> 00:35:20,950
release and we've had a lot of perfect

00:35:18,520 --> 00:35:25,900
releases since they've been about one or

00:35:20,950 --> 00:35:27,940
two per month or even per week so every

00:35:25,900 --> 00:35:29,530
couple days I just went through what

00:35:27,940 --> 00:35:32,410
had either committed or what they had

00:35:29,530 --> 00:35:33,670
sent me and know what I had done and if

00:35:32,410 --> 00:35:35,200
there were more than four or five

00:35:33,670 --> 00:35:36,460
changes that look useful I just pushed

00:35:35,200 --> 00:35:38,500
out a release and it's in the port's

00:35:36,460 --> 00:35:43,270
tree you can get it there and it's

00:35:38,500 --> 00:35:46,660
always up-to-date so this is where we

00:35:43,270 --> 00:35:48,309
are we have local versioning it's useful

00:35:46,660 --> 00:35:51,250
for individual developers at this point

00:35:48,309 --> 00:35:53,410
it's good enough to replace get for all

00:35:51,250 --> 00:35:56,589
the regular version tasks I only run git

00:35:53,410 --> 00:36:00,400
now to do fetch and and push that's all

00:35:56,589 --> 00:36:02,530
I do with it the next thing that we need

00:36:00,400 --> 00:36:04,150
to make this really useful is to

00:36:02,530 --> 00:36:05,680
generate pack files because that's a

00:36:04,150 --> 00:36:09,819
prerequisite also for network traffic

00:36:05,680 --> 00:36:11,349
and this in my view from my point of

00:36:09,819 --> 00:36:13,240
view should be like a separate main

00:36:11,349 --> 00:36:16,569
utility that you used to do repository

00:36:13,240 --> 00:36:19,440
administration and consistency checks

00:36:16,569 --> 00:36:22,599
garbage collection and we also need

00:36:19,440 --> 00:36:24,160
support for an external format of this

00:36:22,599 --> 00:36:26,049
data so git has what's called fast

00:36:24,160 --> 00:36:27,930
import or forest-like export streams I

00:36:26,049 --> 00:36:29,859
never remember which one it is that

00:36:27,930 --> 00:36:31,720
basically gives you a plain text

00:36:29,859 --> 00:36:34,839
representation of data which is

00:36:31,720 --> 00:36:37,750
important because if path if all you

00:36:34,839 --> 00:36:39,190
have is a packed file and you can't even

00:36:37,750 --> 00:36:40,779
decompress it anymore because of bit

00:36:39,190 --> 00:36:43,059
flips on the disks then you pretty much

00:36:40,779 --> 00:36:45,490
house and you can't you can forget about

00:36:43,059 --> 00:36:47,470
your project and I don't want people to

00:36:45,490 --> 00:36:49,599
rely on external clones for backup

00:36:47,470 --> 00:36:52,960
that's not a viable strategy I think we

00:36:49,599 --> 00:36:56,529
need a way to fix broken repositories

00:36:52,960 --> 00:36:59,109
locally just like Theo today's in able

00:36:56,529 --> 00:37:02,770
to fix RCS files right and I don't want

00:36:59,109 --> 00:37:05,079
to take that away from from people I can

00:37:02,770 --> 00:37:06,880
who really have a tight ship to run have

00:37:05,079 --> 00:37:08,890
a lot of responsibility and this data is

00:37:06,880 --> 00:37:11,319
really precious and you just can't

00:37:08,890 --> 00:37:13,809
afford to lose it so there are still

00:37:11,319 --> 00:37:15,490
looking for solutions and maybe these

00:37:13,809 --> 00:37:17,140
streams that get is writing are not

00:37:15,490 --> 00:37:19,690
entirely suitable for it maybe they are

00:37:17,140 --> 00:37:23,920
I haven't really checked and but if they

00:37:19,690 --> 00:37:26,890
aren't we can just make up our own there

00:37:23,920 --> 00:37:31,480
needs to be some kind of server and one

00:37:26,890 --> 00:37:34,029
important aspect of this is that and we

00:37:31,480 --> 00:37:37,420
don't want to use the sort of merge

00:37:34,029 --> 00:37:39,039
master model that Linux is using you

00:37:37,420 --> 00:37:41,079
know how this works so they they keep

00:37:39,039 --> 00:37:41,750
pushing up changes between repositories

00:37:41,079 --> 00:37:43,610
and there's always

00:37:41,750 --> 00:37:45,470
a person who takes care of merging

00:37:43,610 --> 00:37:46,970
changes into this repository and process

00:37:45,470 --> 00:37:49,250
process the collection up to the next

00:37:46,970 --> 00:37:50,870
one the problem that we have with this

00:37:49,250 --> 00:37:52,220
is that we don't want to co2 end up

00:37:50,870 --> 00:37:54,500
having to merge everything because he

00:37:52,220 --> 00:37:56,210
doesn't have the time and also that's

00:37:54,500 --> 00:37:57,650
not the whole that's not how the project

00:37:56,210 --> 00:38:00,380
is supposed to operate we're supposed to

00:37:57,650 --> 00:38:02,020
operate as an equal collection of peers

00:38:00,380 --> 00:38:04,220
who have access to the entire tree and

00:38:02,020 --> 00:38:06,830
people are allowed to change things

00:38:04,220 --> 00:38:08,480
anywhere they want if they have enough

00:38:06,830 --> 00:38:10,490
review or if they follow the community

00:38:08,480 --> 00:38:14,210
process then nobody stops me from going

00:38:10,490 --> 00:38:15,590
into utf-8 or Wireless or even even

00:38:14,210 --> 00:38:19,340
relay to you are other things if I have

00:38:15,590 --> 00:38:21,770
something to fix there and we can't

00:38:19,340 --> 00:38:24,200
require a hackathon of 70 people or 40

00:38:21,770 --> 00:38:26,030
people who average to keep fetching

00:38:24,200 --> 00:38:28,760
changes from the server every time

00:38:26,030 --> 00:38:32,030
someone makes one commit so we have to

00:38:28,760 --> 00:38:35,150
have a way of basically doing rebasing

00:38:32,030 --> 00:38:37,070
of changes on a server if you've used

00:38:35,150 --> 00:38:38,950
garrett before or tools like this you

00:38:37,070 --> 00:38:41,300
will pretty much know how this works

00:38:38,950 --> 00:38:43,430
except we can skip all the review part

00:38:41,300 --> 00:38:44,770
and such tools they basically code

00:38:43,430 --> 00:38:46,940
review tools that allow you to manage

00:38:44,770 --> 00:38:49,670
commits and merge them only once they're

00:38:46,940 --> 00:38:53,000
ready we would do our review as before

00:38:49,670 --> 00:38:54,560
in an email but a queuing mechanism

00:38:53,000 --> 00:38:57,290
could exist on the server that allows

00:38:54,560 --> 00:38:59,540
people to just keep adding changes and

00:38:57,290 --> 00:39:01,760
the server makes sure that they're that

00:38:59,540 --> 00:39:04,760
they can actually be folded in without

00:39:01,760 --> 00:39:07,880
colliding so you would provide the

00:39:04,760 --> 00:39:09,920
hashes of your based blobs and the paths

00:39:07,880 --> 00:39:11,900
that you believe these blobs exist at

00:39:09,920 --> 00:39:14,030
and if those assumptions are no longer

00:39:11,900 --> 00:39:16,490
true then you commit us out of date this

00:39:14,030 --> 00:39:18,500
is pretty much how as unit CVS do it so

00:39:16,490 --> 00:39:21,500
you can just emulate this but the key

00:39:18,500 --> 00:39:23,030
mechanism in git and you would have your

00:39:21,500 --> 00:39:24,260
changes in the main repository with

00:39:23,030 --> 00:39:25,760
different communities but it doesn't

00:39:24,260 --> 00:39:27,740
matter because they come back eventually

00:39:25,760 --> 00:39:29,600
round trip to your own repository and

00:39:27,740 --> 00:39:31,910
then you're just rebase your own commits

00:39:29,600 --> 00:39:34,720
on top and some of your local changes

00:39:31,910 --> 00:39:36,770
will just disappear in the merge and

00:39:34,720 --> 00:39:40,490
this should only use encrypted

00:39:36,770 --> 00:39:42,050
communication for obvious reasons it

00:39:40,490 --> 00:39:45,560
could also be used to support a

00:39:42,050 --> 00:39:49,310
mirroring infrastructure and it would

00:39:45,560 --> 00:39:51,290
also be nice to have a protocol speaker

00:39:49,310 --> 00:39:53,660
here that's compatible with regular git

00:39:51,290 --> 00:39:56,120
I don't have details in my hat for this

00:39:53,660 --> 00:39:58,700
yet but I think it would be good

00:39:56,120 --> 00:40:00,740
because then this could become an easy

00:39:58,700 --> 00:40:03,380
repository hosting solution for small

00:40:00,740 --> 00:40:06,290
setups that are secure run maybe on your

00:40:03,380 --> 00:40:10,810
home firewall or introduced OpenBSD in

00:40:06,290 --> 00:40:10,810
free learn and valent pledge and so on

00:40:10,930 --> 00:40:18,050
of course we want to be able to transfer

00:40:14,060 --> 00:40:21,710
changes between repositories for pulling

00:40:18,050 --> 00:40:24,860
it would basically fetch changes and put

00:40:21,710 --> 00:40:27,350
them somewhere and in a reference so you

00:40:24,860 --> 00:40:30,620
can access them and perhaps even

00:40:27,350 --> 00:40:33,080
automatically rebase a branch that

00:40:30,620 --> 00:40:35,690
you're on in your work tree but if it

00:40:33,080 --> 00:40:36,920
can't do that because of conflicts or

00:40:35,690 --> 00:40:40,760
whatever you would have to manually git

00:40:36,920 --> 00:40:42,290
rebase pushing changes should ideally be

00:40:40,760 --> 00:40:48,520
supported by the server as I just

00:40:42,290 --> 00:40:51,440
explained and Teva had this idea that he

00:40:48,520 --> 00:40:53,920
doesn't want to see the branches he just

00:40:51,440 --> 00:40:58,880
wants to keep working as he does now and

00:40:53,920 --> 00:41:00,620
I guess that's a valid valid use case

00:40:58,880 --> 00:41:02,540
and it's also something that I guess not

00:41:00,620 --> 00:41:05,360
he would want but other people want to

00:41:02,540 --> 00:41:07,070
and it's also something that fossil is

00:41:05,360 --> 00:41:10,190
already implementing so fossil by

00:41:07,070 --> 00:41:11,540
default person's commits to more more

00:41:10,190 --> 00:41:14,210
than one repository when you run a

00:41:11,540 --> 00:41:15,800
commit so I thought well this must be

00:41:14,210 --> 00:41:17,810
possible somehow alright we could

00:41:15,800 --> 00:41:20,210
probably do that and so there is a good

00:41:17,810 --> 00:41:21,860
way of doing this if you only look at

00:41:20,210 --> 00:41:24,230
local changes that aren't committed yet

00:41:21,860 --> 00:41:26,300
you can create a temporary commit object

00:41:24,230 --> 00:41:28,730
that the user doesn't see and you use

00:41:26,300 --> 00:41:31,250
the same push mechanism as you would

00:41:28,730 --> 00:41:33,260
normally use to upload this change to

00:41:31,250 --> 00:41:34,700
the server and once that has worked you

00:41:33,260 --> 00:41:36,020
know that your changes in history and

00:41:34,700 --> 00:41:39,500
you can just apply it locally and you're

00:41:36,020 --> 00:41:42,140
done otherwise you require a fad and

00:41:39,500 --> 00:41:43,700
basically then it just you boil the

00:41:42,140 --> 00:41:46,100
command set down even further and you

00:41:43,700 --> 00:41:48,710
won't have to use rebase unless you

00:41:46,100 --> 00:41:50,510
really have real conflict and you could

00:41:48,710 --> 00:41:52,400
just basically use the checkout commit

00:41:50,510 --> 00:41:54,950
update commit update workflow that

00:41:52,400 --> 00:41:58,370
people are used to from tools like CVS

00:41:54,950 --> 00:42:00,800
and SVM this is of course something that

00:41:58,370 --> 00:42:03,710
would need to be added once all this

00:42:00,800 --> 00:42:04,880
other stuff is there but I am in my and

00:42:03,710 --> 00:42:06,260
my vision that could be something where

00:42:04,880 --> 00:42:07,940
you say like oh I want this branch to

00:42:06,260 --> 00:42:10,220
say synchronize to the main

00:42:07,940 --> 00:42:11,900
server and then the branch would operate

00:42:10,220 --> 00:42:13,160
like that whereas if you have other

00:42:11,900 --> 00:42:15,950
branches where you say like nah this one

00:42:13,160 --> 00:42:18,470
is local or this one is not soon it's

00:42:15,950 --> 00:42:19,850
just pulling or pushing to this other

00:42:18,470 --> 00:42:24,290
server then you wouldn't have this

00:42:19,850 --> 00:42:25,550
behavior that's one possibility another

00:42:24,290 --> 00:42:28,160
thing I'd like to have is a web

00:42:25,550 --> 00:42:31,040
front-end that it works pretty much like

00:42:28,160 --> 00:42:33,590
CVS web so this could just be a another

00:42:31,040 --> 00:42:36,050
front-end alongside God and talk and it

00:42:33,590 --> 00:42:38,750
would use some existing web technologies

00:42:36,050 --> 00:42:40,310
that we have probably it it should

00:42:38,750 --> 00:42:42,230
probably be written and see because that

00:42:40,310 --> 00:42:43,760
makes gives you easy access to the

00:42:42,230 --> 00:42:45,740
library that is already there but I

00:42:43,760 --> 00:42:47,000
wouldn't be opposed to adding providing

00:42:45,740 --> 00:42:50,150
soar something like that if people

00:42:47,000 --> 00:42:54,320
prefer to have an easier time writing

00:42:50,150 --> 00:42:54,860
this kind of stuff okay I'm just two

00:42:54,320 --> 00:42:58,760
minutes over

00:42:54,860 --> 00:43:02,360
I think or I'm a few minutes under is it

00:42:58,760 --> 00:43:05,720
45 or 40 minutes good it's great all

00:43:02,360 --> 00:43:07,190
right we have time for questions yeah we

00:43:05,720 --> 00:43:11,200
have a telephone for a couple questions

00:43:07,190 --> 00:43:11,200
if you guys come in the front

00:43:18,270 --> 00:43:22,930
Salem thanks for your talk was quite

00:43:20,290 --> 00:43:25,900
interesting I'm curious if you see this

00:43:22,930 --> 00:43:30,220
as a potential replacement of CVS in

00:43:25,900 --> 00:43:32,560
base for general development not in its

00:43:30,220 --> 00:43:34,150
current state for students current said

00:43:32,560 --> 00:43:35,740
it's good enough for myself I'm happy

00:43:34,150 --> 00:43:38,140
with that it's good enough for people to

00:43:35,740 --> 00:43:39,550
try it's just a package at away I would

00:43:38,140 --> 00:43:44,770
guess that we'd need a couple of more

00:43:39,550 --> 00:43:46,390
years for it to mature and it's already

00:43:44,770 --> 00:43:47,950
considered to move it to do the

00:43:46,390 --> 00:43:49,630
development of this tool in base but

00:43:47,950 --> 00:43:52,300
there's a bit of a chicken and egg

00:43:49,630 --> 00:43:53,830
problem especially because once there is

00:43:52,300 --> 00:43:56,290
a server I would like to use that server

00:43:53,830 --> 00:43:57,700
with this project and then having to

00:43:56,290 --> 00:43:59,560
convert back from CVS to gate which

00:43:57,700 --> 00:44:01,180
could be done but it's just cumbersome

00:43:59,560 --> 00:44:11,140
so for now it's in a separate repository

00:44:01,180 --> 00:44:13,780
that that I maintain thanks speaking of

00:44:11,140 --> 00:44:16,540
your personal repository is it already

00:44:13,780 --> 00:44:18,609
self hosted not yet but the server is

00:44:16,540 --> 00:44:20,859
there now so I was waiting for a proxy

00:44:18,609 --> 00:44:22,450
in Berlin to set up a server and that's

00:44:20,859 --> 00:44:23,859
been done and now I have to find time to

00:44:22,450 --> 00:44:25,810
actually set it up but it's gonna just

00:44:23,859 --> 00:44:28,720
use standard key tooling that it exists

00:44:25,810 --> 00:44:36,040
on Linux if I had a server already I

00:44:28,720 --> 00:44:39,570
would use it but I don't all right thank

00:44:36,040 --> 00:44:39,570
you very much Stefan thank you

00:44:41,609 --> 00:44:43,670
you

00:44:51,380 --> 00:44:53,440

YouTube URL: https://www.youtube.com/watch?v=PRIgeouw7-4


