Title: Improving modularity of NetBSD’s compat code
Publication date: 2019-10-21
Playlist: EuroBSDCon 2019, Norway
Description: 
	Improving modularity of NetBSD’s compat code
by Paul Goyette

This presentation will describe recent changes to the NetBSD code that provides compatability with earlier versions. We will discuss some of the short-comings of the NetBSD-8 implementation, such as the lack of granularity of loadable modules and inability to include all of the compatability code in the loadable modules. We will describe the approaches taken to resolve these issues, and some of the infrastructure changes needed to accomodate them, with detailed focus on the mechanisms which ensure that code being executed does not get unloaded. Finally, we will discuss the current state of the implementation, along with a list of things that remain to be done.

More Info:
https://2019.eurobsdcon.org/talk-speakers/#compat
Captions: 
	00:00:26,520 --> 00:00:31,750
good morning everybody hold good this

00:00:28,810 --> 00:00:33,489
thing's actually working so anyways my

00:00:31,750 --> 00:00:37,060
name is Paul go ahead I've been with net

00:00:33,489 --> 00:00:40,329
bsd now for a very long time at least

00:00:37,060 --> 00:00:42,810
like 12 years and been contributing for

00:00:40,329 --> 00:00:44,829
25 years so it's been a little while

00:00:42,810 --> 00:00:47,320
today we're going to talk about some

00:00:44,829 --> 00:00:51,250
work that I did over the last year and a

00:00:47,320 --> 00:00:53,829
half in changing the module that the the

00:00:51,250 --> 00:00:57,160
modular approach to the net bsd compact

00:00:53,829 --> 00:00:59,340
code talked a little bit about the

00:00:57,160 --> 00:01:02,379
motivation why I did it

00:00:59,340 --> 00:01:05,740
some of the issues that were involved

00:01:02,379 --> 00:01:10,240
approached the implementation status and

00:01:05,740 --> 00:01:11,709
finally at the end some thank yous so if

00:01:10,240 --> 00:01:13,299
there's any questions along the way feel

00:01:11,709 --> 00:01:15,130
free to interrupt this is not going to

00:01:13,299 --> 00:01:18,100
take the full session time unless

00:01:15,130 --> 00:01:19,509
something miraculous happens so feel

00:01:18,100 --> 00:01:23,590
free to interrupt with questions along

00:01:19,509 --> 00:01:26,859
the way so anyways the net bsd has

00:01:23,590 --> 00:01:29,590
always prided itself on being able to

00:01:26,859 --> 00:01:32,170
maintain compatibility with older

00:01:29,590 --> 00:01:34,959
versions of net bsd we actually have

00:01:32,170 --> 00:01:38,139
code that says if you have a net bsd 0.9

00:01:34,959 --> 00:01:41,130
image it will still run today if you've

00:01:38,139 --> 00:01:44,319
included the compact code in your kernel

00:01:41,130 --> 00:01:49,419
and anything anything that's ever run on

00:01:44,319 --> 00:01:52,419
that bsd will still run pretty much we

00:01:49,419 --> 00:01:54,999
also have the ability to load kernel

00:01:52,419 --> 00:01:57,209
components dynamically as needed and

00:01:54,999 --> 00:02:00,710
unload them when we're done with them

00:01:57,209 --> 00:02:06,850
either automatically or on

00:02:00,710 --> 00:02:11,090
user control and we at one point we had

00:02:06,850 --> 00:02:15,860
the compact code was just monolithic and

00:02:11,090 --> 00:02:18,020
built into the kernel so now we can do

00:02:15,860 --> 00:02:20,840
it in modules mix life a little easier

00:02:18,020 --> 00:02:23,990
and we made the work I was doing a

00:02:20,840 --> 00:02:25,910
little bit less difficult to do the main

00:02:23,990 --> 00:02:28,460
reason I started all this is because I

00:02:25,910 --> 00:02:34,520
got bit by one of the main problems that

00:02:28,460 --> 00:02:36,800
we have and my systems I only run highly

00:02:34,520 --> 00:02:38,840
modular eyes kernels I basically strip

00:02:36,800 --> 00:02:40,610
everything out of the kernel and load

00:02:38,840 --> 00:02:44,000
everything as a module if and when I

00:02:40,610 --> 00:02:47,060
need it so with the generic kernel

00:02:44,000 --> 00:02:49,850
fournette bsd has somewhere around 250

00:02:47,060 --> 00:02:52,370
modules that are built in to the kernel

00:02:49,850 --> 00:02:55,880
so that everybody gets everything when

00:02:52,370 --> 00:03:01,000
my kernel boots it's got 20 modules or

00:02:55,880 --> 00:03:05,720
22 I think I counted last night I have

00:03:01,000 --> 00:03:06,890
at peak runtime above 70 modules running

00:03:05,720 --> 00:03:10,970
and this is all the stuff that gets

00:03:06,890 --> 00:03:13,220
loaded dynamically when needed so one of

00:03:10,970 --> 00:03:15,950
the things that got changed one day

00:03:13,220 --> 00:03:17,540
while I was running somebody changed the

00:03:15,950 --> 00:03:22,700
way they get I F adder works

00:03:17,540 --> 00:03:25,340
they changed the code in RTC and my

00:03:22,700 --> 00:03:28,190
kernel didn't work anymore even if I

00:03:25,340 --> 00:03:30,680
loaded the compact module it had all the

00:03:28,190 --> 00:03:34,220
compact code in the world built in but

00:03:30,680 --> 00:03:37,670
it didn't work turns out that if he

00:03:34,220 --> 00:03:39,769
hadn't defined the comp at macro when

00:03:37,670 --> 00:03:41,989
you built your kernel there was nothing

00:03:39,769 --> 00:03:44,269
to call the compact code it didn't

00:03:41,989 --> 00:03:49,100
matter if he had the code available if

00:03:44,269 --> 00:03:50,330
you don't call it it hit don't work so I

00:03:49,100 --> 00:03:52,100
actually had to go back and start

00:03:50,330 --> 00:03:54,590
running a generic kernel until I fixed

00:03:52,100 --> 00:04:00,410
the problem oh my god what was that all

00:03:54,590 --> 00:04:02,660
about right so even if I loaded the

00:04:00,410 --> 00:04:05,260
compact module couldn't work had to do

00:04:02,660 --> 00:04:05,260
it manually

00:04:05,660 --> 00:04:11,030
some of the big issues are the fact that

00:04:09,260 --> 00:04:14,900
the compact code was all controlled by a

00:04:11,030 --> 00:04:18,110
bunch of if deaf spaghetti there's a

00:04:14,900 --> 00:04:21,709
comp at xxxx for every single version of

00:04:18,110 --> 00:04:24,110
net bsd that's ever been issued and it

00:04:21,709 --> 00:04:26,720
gets kind of nested at times and got

00:04:24,110 --> 00:04:29,630
really messy and the heart the heart job

00:04:26,720 --> 00:04:31,460
was to pull it all apart and separate

00:04:29,630 --> 00:04:34,370
the code out the code that you need for

00:04:31,460 --> 00:04:36,380
comp at five oh goes in one module the

00:04:34,370 --> 00:04:39,950
comp for code you need for comp at 600

00:04:36,380 --> 00:04:42,610
goes in another module and sometimes the

00:04:39,950 --> 00:04:45,590
compact code replaced other compact code

00:04:42,610 --> 00:04:48,670
everett there were few situations where

00:04:45,590 --> 00:04:51,740
we'd gone through multiple revisions of

00:04:48,670 --> 00:04:53,390
certain syscalls in particular there was

00:04:51,740 --> 00:04:55,040
a forget which one it was not that was

00:04:53,390 --> 00:05:00,230
actually one that had gone through three

00:04:55,040 --> 00:05:02,630
separate revisions so there was a if

00:05:00,230 --> 00:05:06,050
there was an old an old old and an old

00:05:02,630 --> 00:05:12,770
old old version of the cisco as well as

00:05:06,050 --> 00:05:17,180
the current one got really nasty and the

00:05:12,770 --> 00:05:19,370
huh the worst part was compact over the

00:05:17,180 --> 00:05:23,090
modules can be unloaded when they're

00:05:19,370 --> 00:05:26,030
done well how do you know when you're

00:05:23,090 --> 00:05:27,890
done with compact code how do you know

00:05:26,030 --> 00:05:32,690
you're not already executing it on

00:05:27,890 --> 00:05:35,240
another cpu really nasty if you do a mod

00:05:32,690 --> 00:05:40,450
unload of some syscall while this is

00:05:35,240 --> 00:05:40,450
calls executing burn or an i/o control

00:05:42,960 --> 00:05:50,150
lots of other modular are options in

00:05:45,600 --> 00:05:54,380
building these modules - for example the

00:05:50,150 --> 00:05:59,310
ffs code file system code it's built

00:05:54,380 --> 00:06:01,260
conditional on the white BL whatever I

00:05:59,310 --> 00:06:03,240
forget what the acronym stands for it's

00:06:01,260 --> 00:06:06,540
the logging the journaling portion of

00:06:03,240 --> 00:06:11,120
the filesystem code it's not LFS but

00:06:06,540 --> 00:06:14,130
it's the it's the journaling for ffs the

00:06:11,120 --> 00:06:17,810
ffs module depends on whether you've

00:06:14,130 --> 00:06:17,810
defined that that code or not

00:06:18,860 --> 00:06:27,990
so anyways comp that modules have their

00:06:24,000 --> 00:06:31,530
own copy of those macros to define which

00:06:27,990 --> 00:06:36,210
code gets built in got to keep them in

00:06:31,530 --> 00:06:39,450
sync and there was no clear way to find

00:06:36,210 --> 00:06:41,940
out whether the optional code was and it

00:06:39,450 --> 00:06:44,190
was included and the example I had

00:06:41,940 --> 00:06:47,580
before where the artists are code

00:06:44,190 --> 00:06:50,340
changed there was no way for the for the

00:06:47,580 --> 00:06:52,440
current version of the RT SOT code to

00:06:50,340 --> 00:06:56,760
determine if it neva needed to try to

00:06:52,440 --> 00:07:04,140
look for the FIFO compact code or the 6l

00:06:56,760 --> 00:07:05,810
compact code it just didn't know so kind

00:07:04,140 --> 00:07:08,580
of made a really nasty

00:07:05,810 --> 00:07:13,620
you don't know if codes there but you

00:07:08,580 --> 00:07:15,450
got to call it if it is and that RT sock

00:07:13,620 --> 00:07:17,430
code basically always assumed that the

00:07:15,450 --> 00:07:21,720
code was built into the kernel didn't

00:07:17,430 --> 00:07:24,570
didn't bother checking standard builds

00:07:21,720 --> 00:07:28,490
only provided one version of the combat

00:07:24,570 --> 00:07:28,490
modules look at the monolithic module

00:07:30,610 --> 00:07:37,000
and there were no provisions in the

00:07:33,639 --> 00:07:39,250
original model for well let's say I

00:07:37,000 --> 00:07:41,680
built my colonel with combat five-o so

00:07:39,250 --> 00:07:44,800
anything that was built for net bsd 500

00:07:41,680 --> 00:07:50,740
and above would work oh crap now I got a

00:07:44,800 --> 00:07:53,080
for old image that I want to run you

00:07:50,740 --> 00:07:55,840
couldn't add the four row compatibility

00:07:53,080 --> 00:07:57,370
code to your kernel without removing all

00:07:55,840 --> 00:07:59,379
the existing compatibility called

00:07:57,370 --> 00:08:01,590
building a new module with 400 code

00:07:59,379 --> 00:08:03,280
built in and then loading the new module

00:08:01,590 --> 00:08:07,840
just didn't happen

00:08:03,280 --> 00:08:09,460
you couldn't incrementally increase the

00:08:07,840 --> 00:08:15,520
amount of fruit though or the number of

00:08:09,460 --> 00:08:18,520
versions back you went device driver

00:08:15,520 --> 00:08:22,680
modules have a way of determining if

00:08:18,520 --> 00:08:27,370
they have any instances created

00:08:22,680 --> 00:08:29,020
Cisco modules actually can tell whether

00:08:27,370 --> 00:08:30,969
they're active or not we have to keep a

00:08:29,020 --> 00:08:33,729
flag of every time a cisco has entered

00:08:30,969 --> 00:08:37,240
this is called table entry as a rough

00:08:33,729 --> 00:08:40,029
count and even the buffer queue strategy

00:08:37,240 --> 00:08:42,760
modules have a reference count but some

00:08:40,029 --> 00:08:46,449
of this compact code isn't syscalls

00:08:42,760 --> 00:08:50,980
it's additional options within the i/o

00:08:46,449 --> 00:08:53,290
control call there was no way for it to

00:08:50,980 --> 00:08:56,829
know that the code was there and no way

00:08:53,290 --> 00:08:58,810
to know if the code was active and again

00:08:56,829 --> 00:09:07,839
if you happen to unload a module while

00:08:58,810 --> 00:09:12,570
you're executing bad things happen we

00:09:07,839 --> 00:09:12,570
didn't have the ability to do that so I

00:09:12,899 --> 00:09:21,940
worked with one of our other guys taylor

00:09:18,579 --> 00:09:25,269
campbell to define a module hook

00:09:21,940 --> 00:09:26,450
mechanism so that when a when when the

00:09:25,269 --> 00:09:29,990
of the

00:09:26,450 --> 00:09:33,940
that module code is loaded it installs a

00:09:29,990 --> 00:09:33,940
hook in a known location in the kernel

00:09:34,180 --> 00:09:40,820
code that might want to call compact

00:09:37,940 --> 00:09:44,060
code if it exists does an indirect call

00:09:40,820 --> 00:09:46,760
through that hook if the hook is set it

00:09:44,060 --> 00:09:48,860
calls the comp compact code if the hooks

00:09:46,760 --> 00:09:53,660
not set it doesn't do anything just

00:09:48,860 --> 00:09:55,670
returns a pass through that would have

00:09:53,660 --> 00:09:57,650
been great all by itself just having the

00:09:55,670 --> 00:10:02,150
function pointer and in fact some of the

00:09:57,650 --> 00:10:04,670
code had been in direct call modified

00:10:02,150 --> 00:10:07,910
previously but it didn't solve the

00:10:04,670 --> 00:10:11,860
problem of unloading the code it out

00:10:07,910 --> 00:10:11,860
from underneath the code being executed

00:10:13,030 --> 00:10:18,140
the second thing that was done was to

00:10:15,410 --> 00:10:20,570
split the compact code into V V is the

00:10:18,140 --> 00:10:24,620
version specific modules so that we

00:10:20,570 --> 00:10:26,930
could incrementally increase the number

00:10:24,620 --> 00:10:29,240
of versions back that we go and then

00:10:26,930 --> 00:10:31,220
unload just the piece that we don't need

00:10:29,240 --> 00:10:33,200
anymore when we're done with it without

00:10:31,220 --> 00:10:37,040
having to unload everything no more

00:10:33,200 --> 00:10:43,850
monolithic compact now its comp at v of

00:10:37,040 --> 00:10:46,250
combat 600 comp at 700 and so forth so

00:10:43,850 --> 00:10:49,720
as I said the when the module code is

00:10:46,250 --> 00:10:53,180
loaded it sets the hook when a caller

00:10:49,720 --> 00:10:55,670
needs to possibly call compatibility

00:10:53,180 --> 00:10:57,260
code it's determined for example that it

00:10:55,670 --> 00:11:00,050
doesn't know what the current IO control

00:10:57,260 --> 00:11:03,470
function is maybe it's a compact code

00:11:00,050 --> 00:11:06,620
maybe not call through the the hook and

00:11:03,470 --> 00:11:09,380
see if it can handle it if the hook

00:11:06,620 --> 00:11:11,600
doesn't handle it you haven't lost

00:11:09,380 --> 00:11:16,880
anything except a few instruction cycles

00:11:11,600 --> 00:11:18,710
of calling most times if the hooks not

00:11:16,880 --> 00:11:21,190
set we simply return he knows this

00:11:18,710 --> 00:11:21,190
instead

00:11:26,250 --> 00:11:34,530
so the mechanism that was used for

00:11:30,960 --> 00:11:37,470
protecting the hook from unloading it's

00:11:34,530 --> 00:11:39,450
actually fairly heavy weight couldn't

00:11:37,470 --> 00:11:42,390
think of a very lightweight way to do it

00:11:39,450 --> 00:11:45,450
unfortunately but we actually have

00:11:42,390 --> 00:11:50,040
passive serialization involved to

00:11:45,450 --> 00:11:54,630
prevent someone from starting to acquire

00:11:50,040 --> 00:11:56,610
a local count synchronization item the

00:11:54,630 --> 00:12:00,780
local count on the and the second is the

00:11:56,610 --> 00:12:03,840
rough count for the actual invocation of

00:12:00,780 --> 00:12:05,910
the compact code but if you want to

00:12:03,840 --> 00:12:09,270
unload the compact code you have to wait

00:12:05,910 --> 00:12:10,890
and drain the local count and the local

00:12:09,270 --> 00:12:14,090
count has a requirement that you must

00:12:10,890 --> 00:12:17,310
provide a mechanism to prevent further

00:12:14,090 --> 00:12:20,490
acquires of that local count from

00:12:17,310 --> 00:12:23,640
happening and in the multi CPU

00:12:20,490 --> 00:12:28,200
environment it was actually possible for

00:12:23,640 --> 00:12:31,260
the check to see if the local count

00:12:28,200 --> 00:12:33,120
needed to be drained and the actual

00:12:31,260 --> 00:12:35,000
starting of the draining could kind of

00:12:33,120 --> 00:12:38,010
race with each other and there was this

00:12:35,000 --> 00:12:40,280
possibility still of having the code

00:12:38,010 --> 00:12:43,500
unloaded from outside underneath itself

00:12:40,280 --> 00:12:46,440
so the passive serialization is used to

00:12:43,500 --> 00:12:48,540
prevent new acquires the local count is

00:12:46,440 --> 00:12:51,230
used to attract the active references

00:12:48,540 --> 00:12:54,300
and before we unset the hook which is a

00:12:51,230 --> 00:12:56,940
prerequisite for unloading the module we

00:12:54,300 --> 00:12:58,560
drain the local count which makes sure

00:12:56,940 --> 00:13:03,030
that no new local cuff scheme of

00:12:58,560 --> 00:13:07,110
references can get at it so the module

00:13:03,030 --> 00:13:09,150
hook is just defined though it's a macro

00:13:07,110 --> 00:13:11,480
that defines the hook it's got a mutex

00:13:09,150 --> 00:13:15,270
in the conv or a local count and a

00:13:11,480 --> 00:13:17,940
passive serialization is then it's got

00:13:15,270 --> 00:13:20,390
the two important things one is the flag

00:13:17,940 --> 00:13:26,850
that says the hook is set or not set and

00:13:20,390 --> 00:13:31,350
if it's set then there's a function

00:13:26,850 --> 00:13:34,680
pointer with an argument list inside the

00:13:31,350 --> 00:13:37,230
structure so the hook structure itself

00:13:34,680 --> 00:13:38,440
is all synchronization variables and oh

00:13:37,230 --> 00:13:43,000
by the way we have a function

00:13:38,440 --> 00:13:47,290
Poynter well it's fairly heavyweight but

00:13:43,000 --> 00:13:53,860
you don't do it that often and it's not

00:13:47,290 --> 00:13:55,600
really all that much memory because all

00:13:53,860 --> 00:13:58,650
the hooks were different there they they

00:13:55,600 --> 00:14:01,860
all had individual or unique prototypes

00:13:58,650 --> 00:14:05,680
use the macro approach rather than a

00:14:01,860 --> 00:14:09,640
fixed type for the for the hook function

00:14:05,680 --> 00:14:13,990
itself and you can see here we've got

00:14:09,640 --> 00:14:21,400
the individual macros that are used to

00:14:13,990 --> 00:14:24,190
access the hooks for invoking the

00:14:21,400 --> 00:14:25,810
optional code before you would basically

00:14:24,190 --> 00:14:31,900
check a function pointer and see if the

00:14:25,810 --> 00:14:40,990
function pointer was set if it was call

00:14:31,900 --> 00:14:44,950
it now you call the macro for call the

00:14:40,990 --> 00:14:47,850
hook and it does the same thing that's a

00:14:44,950 --> 00:14:53,440
little bit more behind the scenes but it

00:14:47,850 --> 00:14:56,640
complices the same result the module

00:14:53,440 --> 00:15:00,100
initialization code sets the hook on

00:14:56,640 --> 00:15:06,790
finished code clear so pretty simple

00:15:00,100 --> 00:15:10,360
stuff there's there's a compact stub dot

00:15:06,790 --> 00:15:13,660
H that defines all the hooks as types

00:15:10,360 --> 00:15:17,640
and the actual hook memory is allocated

00:15:13,660 --> 00:15:17,640
in contacts table C

00:15:21,899 --> 00:15:26,829
as I said earlier the second major

00:15:24,309 --> 00:15:31,749
change besides defining the hooks was to

00:15:26,829 --> 00:15:33,849
split everything up we had a lot of

00:15:31,749 --> 00:15:37,269
different versions of compact code all

00:15:33,849 --> 00:15:38,889
going all the way back to 0.9 even

00:15:37,269 --> 00:15:41,619
though some of its been disabled by

00:15:38,889 --> 00:15:44,259
default just by default we start with

00:15:41,619 --> 00:15:48,849
one point 5 and up but we can add the

00:15:44,259 --> 00:15:52,359
other code if we want so the zero point

00:15:48,849 --> 00:15:53,819
9 code assumes that you've got 1.0 code

00:15:52,359 --> 00:15:56,319
because if you're going to go back to

00:15:53,819 --> 00:15:58,329
0.9 you better have everything in

00:15:56,319 --> 00:16:00,099
between your current and where you're

00:15:58,329 --> 00:16:02,679
going back to because you never know

00:16:00,099 --> 00:16:06,489
what's going to happen so the 0.9

00:16:02,679 --> 00:16:10,239
depends on 1.0 1.0 depends on 1.1 1.1

00:16:06,489 --> 00:16:14,189
and so forth 1.5 depends on 2.0 which

00:16:10,239 --> 00:16:18,579
depends on 3.0 and for toto the

00:16:14,189 --> 00:16:20,799
dependency list kept pretty long and all

00:16:18,579 --> 00:16:23,289
we used to have a hard-wired constant of

00:16:20,799 --> 00:16:27,879
how many dependencies you could have in

00:16:23,289 --> 00:16:30,549
a given module what we exceeded that we

00:16:27,879 --> 00:16:34,359
could possibly have made the module

00:16:30,549 --> 00:16:36,339
initialization code recursively call the

00:16:34,359 --> 00:16:38,379
module load code for the things that

00:16:36,339 --> 00:16:41,529
needed explicitly rather than just

00:16:38,379 --> 00:16:44,019
depending up on on the required module

00:16:41,529 --> 00:16:48,399
list but there was a limit of those too

00:16:44,019 --> 00:16:52,179
and guess what we exceeded that so we

00:16:48,399 --> 00:16:58,149
had to get rid of a couple of compile

00:16:52,179 --> 00:17:02,679
time constants as well and oh yes this

00:16:58,149 --> 00:17:05,980
is the key thing syscalls master some of

00:17:02,679 --> 00:17:11,439
these compact codes were actual sis

00:17:05,980 --> 00:17:15,759
calls and sis calls that master many

00:17:11,439 --> 00:17:19,240
several years ago I guess learned how to

00:17:15,759 --> 00:17:21,639
auto load the combat module if it needed

00:17:19,240 --> 00:17:25,569
a comp at Cisco oh by the way that was

00:17:21,639 --> 00:17:27,369
my fault I did that too but now that

00:17:25,569 --> 00:17:27,910
we're splitting the compact module into

00:17:27,369 --> 00:17:30,490
all these

00:17:27,910 --> 00:17:33,880
small version specific comp at modules

00:17:30,490 --> 00:17:37,570
we had to go back and fix syscalls

00:17:33,880 --> 00:17:40,750
master so it did the same thing but only

00:17:37,570 --> 00:17:42,550
for the specific module version or

00:17:40,750 --> 00:17:48,430
version specific module that it needed

00:17:42,550 --> 00:17:50,680
to load as I said there's the compiled

00:17:48,430 --> 00:17:53,260
time limits we used to have a maximum

00:17:50,680 --> 00:17:57,850
number of dependencies of ten and if you

00:17:53,260 --> 00:18:01,000
start counting you find 0.91 - it adds

00:17:57,850 --> 00:18:04,960
up to a lot more than ten and even if he

00:18:01,000 --> 00:18:07,900
went through the recursion process the

00:18:04,960 --> 00:18:10,540
explicit recursion on having a big one

00:18:07,900 --> 00:18:13,480
modules initialization code do a mod

00:18:10,540 --> 00:18:20,100
autoload there was a limit of that of a

00:18:13,480 --> 00:18:23,590
six as well that was hard coded in so

00:18:20,100 --> 00:18:25,660
where are we now there's a lot of work

00:18:23,590 --> 00:18:29,800
that went into this I took me about a

00:18:25,660 --> 00:18:31,900
year of the elapsed time I didn't even

00:18:29,800 --> 00:18:36,000
start counting the hours or days of

00:18:31,900 --> 00:18:39,100
actual work on it there were days when I

00:18:36,000 --> 00:18:40,720
coded all day long and then there were

00:18:39,100 --> 00:18:42,220
weeks when I did nothing because I was

00:18:40,720 --> 00:18:45,460
getting frustrated and couldn't figure

00:18:42,220 --> 00:18:49,330
something out altogether it took about a

00:18:45,460 --> 00:18:52,780
year to do we merged it into head in the

00:18:49,330 --> 00:18:54,940
middle of January of this year that was

00:18:52,780 --> 00:18:58,530
back in the time when we thought we were

00:18:54,940 --> 00:19:01,600
going to pull the net bsd 9 branch

00:18:58,530 --> 00:19:04,300
imminently of course when are we gonna

00:19:01,600 --> 00:19:06,430
pull the nine branch soon

00:19:04,300 --> 00:19:10,900
oh we pulled the branch we just haven't

00:19:06,430 --> 00:19:17,740
released the code yet so it will be one

00:19:10,900 --> 00:19:19,780
net bsd nine ships real soon now the the

00:19:17,740 --> 00:19:22,920
changes that we're talking about today

00:19:19,780 --> 00:19:22,920
will be in that code

00:19:23,130 --> 00:19:29,380
hello there we go there's still a few

00:19:27,580 --> 00:19:32,380
little bits and pieces that didn't get

00:19:29,380 --> 00:19:33,440
done the compile time restrictions were

00:19:32,380 --> 00:19:38,060
removed

00:19:33,440 --> 00:19:39,950
and oh by the way if we had because we

00:19:38,060 --> 00:19:42,230
changed the way the modules worked we

00:19:39,950 --> 00:19:44,750
had to add some compact code to make it

00:19:42,230 --> 00:19:47,990
compatible with older versions of mud

00:19:44,750 --> 00:19:50,930
stat which still thought there was a

00:19:47,990 --> 00:19:54,830
fixed limit so yeah I actually had to

00:19:50,930 --> 00:19:58,660
build the comp at 8.0 to hold the code

00:19:54,830 --> 00:20:01,220
that allowed me to have comp at 8 oh

00:19:58,660 --> 00:20:03,650
yeah that was interesting if we

00:20:01,220 --> 00:20:08,060
subsequently had some other changes as

00:20:03,650 --> 00:20:10,520
well that have gone in more in the in

00:20:08,060 --> 00:20:16,850
the archie sock code that Artie Sacco

00:20:10,520 --> 00:20:18,350
really is pretty ugly stuff a little bit

00:20:16,850 --> 00:20:20,660
more on that when we get to the thank

00:20:18,350 --> 00:20:24,590
yous at the end because that's one of

00:20:20,660 --> 00:20:28,280
the things so all the version specific

00:20:24,590 --> 00:20:30,950
modules were created pretty much all the

00:20:28,280 --> 00:20:33,110
compact code calls were converted to use

00:20:30,950 --> 00:20:36,470
the hooks there's a couple of cases

00:20:33,110 --> 00:20:37,730
where the compact code not the compact

00:20:36,470 --> 00:20:42,820
oh but there's a couple of cases where

00:20:37,730 --> 00:20:45,860
optional code cannot be modularized and

00:20:42,820 --> 00:20:47,810
at this point I got lazy and didn't use

00:20:45,860 --> 00:20:51,080
hooks for things that could never get

00:20:47,810 --> 00:20:56,210
unloaded because there's not modular

00:20:51,080 --> 00:20:58,370
code yet I think some ntp code is falls

00:20:56,210 --> 00:21:00,620
into that category either your kernel

00:20:58,370 --> 00:21:04,910
has NTP code or it doesn't you can't

00:21:00,620 --> 00:21:08,870
module load the NTP code so the NTP

00:21:04,910 --> 00:21:11,410
hooks that are done as a result of

00:21:08,870 --> 00:21:14,450
including NTP are still just old-style

00:21:11,410 --> 00:21:19,520
indirect function pointers without all

00:21:14,450 --> 00:21:22,640
the synchronization turns out that the

00:21:19,520 --> 00:21:24,140
net bsd 32 compact code also needs to

00:21:22,640 --> 00:21:27,290
get pretty much all these changes

00:21:24,140 --> 00:21:30,890
because if you want to run 32-bit

00:21:27,290 --> 00:21:31,790
compact images on your 64-bit AMD

00:21:30,890 --> 00:21:34,010
processor

00:21:31,790 --> 00:21:36,650
well yeah you still need the compact

00:21:34,010 --> 00:21:40,250
code and it didn't make sense to use to

00:21:36,650 --> 00:21:42,110
split the monolithic 64-bit code also

00:21:40,250 --> 00:21:46,090
splitting up the 30

00:21:42,110 --> 00:21:48,679
so I bit the bullet and did that as well

00:21:46,090 --> 00:21:51,410
still a few areas that aren't done

00:21:48,679 --> 00:21:56,380
there's some machine-dependent bits and

00:21:51,410 --> 00:21:59,120
pieces most notably in the amd64 the

00:21:56,380 --> 00:22:00,350
code that does micro code update is

00:21:59,120 --> 00:22:03,350
optional

00:22:00,350 --> 00:22:05,179
it's modularized and there's actually

00:22:03,350 --> 00:22:06,440
some compatibility code in there as well

00:22:05,179 --> 00:22:07,940
because something changed I don't even

00:22:06,440 --> 00:22:16,730
remember the details off the top of my

00:22:07,940 --> 00:22:20,840
head doesn't work in Zen so we the build

00:22:16,730 --> 00:22:23,540
infrastructure doesn't include the right

00:22:20,840 --> 00:22:25,370
headers for the modules even though it

00:22:23,540 --> 00:22:27,230
knows how to build Zen versions of

00:22:25,370 --> 00:22:29,929
modules it doesn't include the right

00:22:27,230 --> 00:22:32,840
headers in the right order and just

00:22:29,929 --> 00:22:35,660
never got it to compile christos says

00:22:32,840 --> 00:22:39,220
he's looking at it in his copious spare

00:22:35,660 --> 00:22:42,410
time yeah we'll see what that happens

00:22:39,220 --> 00:22:47,450
there's still a couple of old-style

00:22:42,410 --> 00:22:50,059
calls and the gpio code and WS MUX and I

00:22:47,450 --> 00:22:51,650
have not yet done a full audit to see if

00:22:50,059 --> 00:22:54,679
there's anything else that I missed I

00:22:51,650 --> 00:22:55,490
tried to find everything but you know

00:22:54,679 --> 00:22:57,770
how that goes

00:22:55,490 --> 00:23:04,669
you always miss something just don't

00:22:57,770 --> 00:23:07,160
know where yet a couple of area areas of

00:23:04,669 --> 00:23:10,010
improvement is really the hook

00:23:07,160 --> 00:23:12,040
definition mechanism as I said at the

00:23:10,010 --> 00:23:14,809
beginning is a little bit heavyweight

00:23:12,040 --> 00:23:17,809
it's got a lot of synchronization issues

00:23:14,809 --> 00:23:20,000
or structures built into the hook just

00:23:17,809 --> 00:23:21,830
to make sure that you don't pull the

00:23:20,000 --> 00:23:24,350
hook out from underneath the code while

00:23:21,830 --> 00:23:25,669
it's executing you can I can't figure

00:23:24,350 --> 00:23:27,890
out a way to get rid of it nobody else

00:23:25,669 --> 00:23:29,240
could either but it'd be really nice if

00:23:27,890 --> 00:23:32,950
we could make it a little bit simpler

00:23:29,240 --> 00:23:38,080
it'd also be nice if we didn't have to

00:23:32,950 --> 00:23:41,630
have the the current underscores stub

00:23:38,080 --> 00:23:43,309
stuff to actually allocate the hooks the

00:23:41,630 --> 00:23:45,290
hooks themselves have to be there

00:23:43,309 --> 00:23:48,290
whether or not the code that they point

00:23:45,290 --> 00:23:49,550
into is there otherwise you wouldn't

00:23:48,290 --> 00:23:52,440
have a place to go through for the

00:23:49,550 --> 00:23:55,170
indirect pointers so there's

00:23:52,440 --> 00:23:58,470
a little bit of static more permanently

00:23:55,170 --> 00:23:59,970
allocated memory in the kernel to occupy

00:23:58,470 --> 00:24:01,770
these and it'd be nice if we could get

00:23:59,970 --> 00:24:08,150
rid of him but again couldn't figure out

00:24:01,770 --> 00:24:10,740
a way to do that so there's a couple of

00:24:08,150 --> 00:24:13,370
comments I've received from other people

00:24:10,740 --> 00:24:17,310
that G adding a new hook is laborious

00:24:13,370 --> 00:24:20,940
yeah well it could be worse could be

00:24:17,310 --> 00:24:23,670
better but it could be worse so possibly

00:24:20,940 --> 00:24:29,280
some sort of non procedural definition

00:24:23,670 --> 00:24:31,470
mechanism might help anybody think about

00:24:29,280 --> 00:24:33,570
config and maybe teaching it how to do

00:24:31,470 --> 00:24:34,800
this kind of stuff I don't know I don't

00:24:33,570 --> 00:24:42,390
want to touch config

00:24:34,800 --> 00:24:45,540
it's a mess so this was an example of of

00:24:42,390 --> 00:24:49,050
an example that somebody sent me there's

00:24:45,540 --> 00:24:53,760
one possible way to think about doing

00:24:49,050 --> 00:24:55,490
this and it's in a future project not

00:24:53,760 --> 00:24:59,730
done yet

00:24:55,490 --> 00:25:01,650
so I get most of the work here but

00:24:59,730 --> 00:25:03,000
definitely could not have done it

00:25:01,650 --> 00:25:06,530
without a lot of help

00:25:03,000 --> 00:25:09,210
Taylor Campbell came up with the initial

00:25:06,530 --> 00:25:12,990
structure for the the hook and the

00:25:09,210 --> 00:25:15,510
synchronization turns out I actually had

00:25:12,990 --> 00:25:19,590
to add the passive serialization to

00:25:15,510 --> 00:25:24,450
prevent the local count race from having

00:25:19,590 --> 00:25:26,640
a new local count acquire running at the

00:25:24,450 --> 00:25:29,820
same time as the local count drain was

00:25:26,640 --> 00:25:31,680
starting yeah that would have been

00:25:29,820 --> 00:25:34,800
pretty nasty because the counters would

00:25:31,680 --> 00:25:38,450
get all whacked out and Christophe

00:25:34,800 --> 00:25:40,790
civiles provided major encouragement

00:25:38,450 --> 00:25:43,920
said earlier there were a lot of places

00:25:40,790 --> 00:25:45,390
where I just shut down for a week or two

00:25:43,920 --> 00:25:47,370
at a time because I couldn't do it

00:25:45,390 --> 00:25:49,740
it's Christos that kept nudging me and

00:25:47,370 --> 00:25:51,930
making suggestions on how to approach

00:25:49,740 --> 00:25:57,030
things that got me over a lot of the

00:25:51,930 --> 00:26:00,090
humps along the way especially been the

00:25:57,030 --> 00:26:04,390
RT socket C code T sock dot C code is

00:26:00,090 --> 00:26:08,260
really ugly it basically included

00:26:04,390 --> 00:26:11,860
or pound sign included most of itself in

00:26:08,260 --> 00:26:16,140
the compact code with different

00:26:11,860 --> 00:26:19,299
definitions of compile time options so

00:26:16,140 --> 00:26:22,240
essentially I ended up with with running

00:26:19,299 --> 00:26:28,090
the code or compiling the code twice in

00:26:22,240 --> 00:26:31,440
one object code once with and once

00:26:28,090 --> 00:26:35,290
without various things being defined

00:26:31,440 --> 00:26:39,010
really nasty stuff I pulled that up that

00:26:35,290 --> 00:26:41,650
out and the the duplicated code is now a

00:26:39,010 --> 00:26:43,780
separate source module so it's actually

00:26:41,650 --> 00:26:47,559
you can actually find out where the code

00:26:43,780 --> 00:26:51,610
is and whether it's built once or twice

00:26:47,559 --> 00:26:54,130
doesn't matter the place of where the

00:26:51,610 --> 00:26:56,730
common code gets included defines

00:26:54,130 --> 00:27:01,780
ultimate they've to compile macros

00:26:56,730 --> 00:27:05,590
appropriately so the real help came

00:27:01,780 --> 00:27:09,970
after the merge I know all the bugs that

00:27:05,590 --> 00:27:13,840
I created got found there were a few I

00:27:09,970 --> 00:27:17,230
think we found all of them but the

00:27:13,840 --> 00:27:19,690
entire bsd community users and

00:27:17,230 --> 00:27:23,230
developers both had a major contribution

00:27:19,690 --> 00:27:28,140
here just by finding and identifying the

00:27:23,230 --> 00:27:34,200
bugs so we could get them fixed so

00:27:28,140 --> 00:27:34,200
that's it anybody got any questions

00:27:49,130 --> 00:27:56,330
just curious what do we do for auto loan

00:27:52,700 --> 00:28:00,590
in like IR controls how do we configure

00:27:56,330 --> 00:28:04,520
that now so the the little backstory

00:28:00,590 --> 00:28:06,710
so when GCC was upgrade I'm great at

00:28:04,520 --> 00:28:10,790
some time ago it started to produce new

00:28:06,710 --> 00:28:14,480
kinds of locations and so the kernel

00:28:10,790 --> 00:28:17,330
linker code inspiration port for example

00:28:14,480 --> 00:28:19,460
that was not prepared for that started

00:28:17,330 --> 00:28:24,050
spewing warnings about that each time

00:28:19,460 --> 00:28:27,740
you law right try to load a module and I

00:28:24,050 --> 00:28:30,080
know things like if you run the I it

00:28:27,740 --> 00:28:33,800
issues some terminal fire control and

00:28:30,080 --> 00:28:36,650
some of the IR control routines tries to

00:28:33,800 --> 00:28:40,490
auto load kompot to see if that will

00:28:36,650 --> 00:28:43,060
handle that IR control so you know each

00:28:40,490 --> 00:28:45,950
invocation you get the model out loaded

00:28:43,060 --> 00:28:49,100
you check oh I cannot handle that IR

00:28:45,950 --> 00:28:51,560
control its unloaded then the next time

00:28:49,100 --> 00:28:53,570
you run rates get auto loaded unloaded

00:28:51,560 --> 00:28:55,940
so on how are you gonna figure out a way

00:28:53,570 --> 00:28:57,980
to make it take nine plus seconds in

00:28:55,940 --> 00:29:01,160
between the load of the unload so that

00:28:57,980 --> 00:29:03,260
the auto unload won't happen or manually

00:29:01,160 --> 00:29:05,180
load the module that's involved because

00:29:03,260 --> 00:29:09,680
manually loaded modules will not get

00:29:05,180 --> 00:29:11,750
auto unloaded but yeah that's that's not

00:29:09,680 --> 00:29:15,470
a problem that was on it was part of the

00:29:11,750 --> 00:29:18,230
scope of this project there's lots of

00:29:15,470 --> 00:29:21,350
problems with modules in general if

00:29:18,230 --> 00:29:23,300
anybody really wants to look at it I got

00:29:21,350 --> 00:29:25,130
so tired of having to remember all the

00:29:23,300 --> 00:29:28,040
problems I actually wrote them down and

00:29:25,130 --> 00:29:30,470
then collected some enhancements for

00:29:28,040 --> 00:29:33,170
that list so there's actually a to-do in

00:29:30,470 --> 00:29:36,470
the source slash dock directory to do

00:29:33,170 --> 00:29:40,310
dot modules I think it last kind of had

00:29:36,470 --> 00:29:42,140
more than twenty items of areas that

00:29:40,310 --> 00:29:46,690
need improvement with the module

00:29:42,140 --> 00:29:52,510
subsystem not specific to the contact oh

00:29:46,690 --> 00:29:52,510
thanks feel free to help

00:29:56,560 --> 00:30:00,420
the case I want to thank you

00:30:05,710 --> 00:30:07,770

YouTube URL: https://www.youtube.com/watch?v=TarGM0f3_x0


