Title: Wireless Fidelity with bwfm(4)
Publication date: 2019-10-27
Playlist: EuroBSDCon 2019, Norway
Description: 
	The Broadcom Wireless FullMAC chip has been one of the biggest hurdles in properly supporting Apple MacBooks in the recent years. But that has not been the only place where this chip has popped up. bwfm(4) is a new OpenBSD driver that supports these chips and was also ported to NetBSD. This talks gives an overview of the chip, an in-depth view into how one communicates with the chip on the three different supported busses, and the higher layer protocol that’s being run on top. It also shows issues properly combining the driver with the OpenBSD net80211 stack, which isn’t written to handle FullMACs. The talk also shows the Firmware and NVRAM distribution issues.

Patrick Wildt has been maintaining and improving the OpenBSD armv7 and arm64 subtree for several years, adding support for multiple SoCs and adding device tree support. Recently he wrote bwfm(4) to add support for the Broadcom FullMAC chips.

Patrick Wildt

Patrick Wildt works for genua, a company that builds OpenBSD based firewalls and VPN gateways. He has been an OpenBSD developer since 2012, where he takes care of the ARM subtree, writes device drivers to support new hardware, and occasionally updates the compiler infrastructure.
Captions: 
	00:00:03,480 --> 00:00:11,379
hello hello good morning everyone

00:00:07,930 --> 00:00:13,959
we're gonna start this lot the euro/usd

00:00:11,379 --> 00:00:16,779
Khan Foundation is very happy to have a

00:00:13,959 --> 00:00:20,109
Patrick felt today who's going to talk

00:00:16,779 --> 00:00:27,730
to us about Wi-Fi fidelity work on

00:00:20,109 --> 00:00:32,310
Patrick and thank you very much yeah

00:00:27,730 --> 00:00:36,040
welcome and let's talk about PWM or

00:00:32,310 --> 00:00:40,330
first about me Who am I I'm just an open

00:00:36,040 --> 00:00:44,110
BSD developer I took her with katanas

00:00:40,330 --> 00:00:47,320
and jsg of the arm 64 subtree so I

00:00:44,110 --> 00:00:51,370
implemented many drivers at a support

00:00:47,320 --> 00:00:54,610
for many boards and I also used to

00:00:51,370 --> 00:00:56,620
update the LLVM subtree which we

00:00:54,610 --> 00:00:59,680
unfortunately cannot do anymore because

00:00:56,620 --> 00:01:02,770
of the license change but well that

00:00:59,680 --> 00:01:05,619
makes my plate a bit lighter considering

00:01:02,770 --> 00:01:07,990
that I am one of the maintainer of the

00:01:05,619 --> 00:01:10,390
arm 64 subtree I also have plenty of

00:01:07,990 --> 00:01:12,549
boards plenty of SBC's plenty of hundred

00:01:10,390 --> 00:01:16,240
edge just laying around and essentially

00:01:12,549 --> 00:01:19,659
doing nothing and I gathered a

00:01:16,240 --> 00:01:21,219
collection of devices like the cubox I

00:01:19,659 --> 00:01:25,090
from solid run which is a tiny little

00:01:21,219 --> 00:01:27,999
cube a MacBook which isn't an SBC a

00:01:25,090 --> 00:01:30,909
verse three PI 3 and some interval-based

00:01:27,999 --> 00:01:34,929
mini PC and all of those machines have

00:01:30,909 --> 00:01:37,990
in common that they have a wife had

00:01:34,929 --> 00:01:40,990
shipped abroad compilers full Mac and I

00:01:37,990 --> 00:01:43,780
was wondering how hard would it be to to

00:01:40,990 --> 00:01:45,340
make it work if you look at the

00:01:43,780 --> 00:01:49,810
milestones you can see that I started

00:01:45,340 --> 00:01:51,549
sometime in 2016 and it took quite a

00:01:49,810 --> 00:01:55,359
while I don't know exactly what happened

00:01:51,549 --> 00:01:56,649
until September 2017 I well don't

00:01:55,359 --> 00:01:59,350
remember anything what happened there

00:01:56,649 --> 00:02:01,270
but at some point in 2017 I got a wife a

00:01:59,350 --> 00:02:03,969
scan running so there was a lot of work

00:02:01,270 --> 00:02:06,520
involved in my spare time making it work

00:02:03,969 --> 00:02:08,470
and after I got the first wife a scan

00:02:06,520 --> 00:02:12,220
like I could seen if config all the

00:02:08,470 --> 00:02:14,080
nodes that were around me it was

00:02:12,220 --> 00:02:16,030
basically enough to get it committed

00:02:14,080 --> 00:02:17,500
clean

00:02:16,030 --> 00:02:19,420
and as you can see like in the following

00:02:17,500 --> 00:02:20,980
month our implemented and host AP mode

00:02:19,420 --> 00:02:24,150
so we can be an access point for

00:02:20,980 --> 00:02:29,740
ourselves and added a PCI Express and

00:02:24,150 --> 00:02:32,470
SDIO back-end so generally how do you

00:02:29,740 --> 00:02:37,080
attempt to write a driver for a hardware

00:02:32,470 --> 00:02:40,420
first of all try to find documentation

00:02:37,080 --> 00:02:42,310
just get grab an operating system search

00:02:40,420 --> 00:02:44,500
for data sheets try to find something

00:02:42,310 --> 00:02:46,959
that already has information for you

00:02:44,500 --> 00:02:49,000
data that you can use if you don't have

00:02:46,959 --> 00:02:51,150
any of that you can basically just quit

00:02:49,000 --> 00:02:53,440
now because it doesn't make any sense

00:02:51,150 --> 00:02:55,510
there are some hard core people who like

00:02:53,440 --> 00:02:58,930
to reverse engineer blobs if your

00:02:55,510 --> 00:03:02,380
country's law allow that but that's so

00:02:58,930 --> 00:03:04,239
much work and essentially you don't do

00:03:02,380 --> 00:03:08,019
anything else but we worst engineering

00:03:04,239 --> 00:03:10,269
yet Bob so yeah but if you find code if

00:03:08,019 --> 00:03:12,850
you find data sheets try to understand

00:03:10,269 --> 00:03:15,400
how the device is actually working how

00:03:12,850 --> 00:03:16,930
its supposed to interact with you or how

00:03:15,400 --> 00:03:21,519
you are supposed to interact with the

00:03:16,930 --> 00:03:24,370
device and that will help you implement

00:03:21,519 --> 00:03:27,130
a skeleton's and implement all the

00:03:24,370 --> 00:03:29,579
layers that that you need and in the end

00:03:27,130 --> 00:03:31,959
realize it's going to be a long project

00:03:29,579 --> 00:03:33,640
because as you have seen in the

00:03:31,959 --> 00:03:35,829
milestones it takes quite a while to get

00:03:33,640 --> 00:03:39,640
it running especially if you if you just

00:03:35,829 --> 00:03:45,239
do that in your spare time first of all

00:03:39,640 --> 00:03:47,799
let's talk about Wi-Fi or what this chip

00:03:45,239 --> 00:03:50,500
why does chip is special compared to the

00:03:47,799 --> 00:03:52,720
other chips that we have this chip is a

00:03:50,500 --> 00:03:56,680
so-called full mac and as you can see in

00:03:52,720 --> 00:04:00,280
that simplified there the mac layer is

00:03:56,680 --> 00:04:02,650
now part of device essentially there's

00:04:00,280 --> 00:04:04,390
thunder running on a device like like an

00:04:02,650 --> 00:04:07,299
operating system but it's probably some

00:04:04,390 --> 00:04:10,450
small real-time environment that takes

00:04:07,299 --> 00:04:12,549
care of all the Wi-Fi handling that

00:04:10,450 --> 00:04:14,500
makes it easier for us because we don't

00:04:12,549 --> 00:04:16,479
have to do all of that the firmware does

00:04:14,500 --> 00:04:19,600
it but it increases a complexity in

00:04:16,479 --> 00:04:21,010
November but still the layer to the

00:04:19,600 --> 00:04:24,970
firmware to the hardware is so much

00:04:21,010 --> 00:04:27,010
easier compared to to doing the mac

00:04:24,970 --> 00:04:30,000
layer yourself now if you look at our

00:04:27,010 --> 00:04:34,030
open BC stack we we see that there is

00:04:30,000 --> 00:04:36,310
essentially one part of our system that

00:04:34,030 --> 00:04:39,640
is responsible for Wi-Fi and it's the

00:04:36,310 --> 00:04:41,680
net 802 11 stack and this one was

00:04:39,640 --> 00:04:43,180
written with softmax in mind because at

00:04:41,680 --> 00:04:47,680
that time the chips weren't powerful

00:04:43,180 --> 00:04:50,050
enough to do that which means that will

00:04:47,680 --> 00:04:52,120
be more interesting or it will be harder

00:04:50,050 --> 00:04:55,300
for the chip to be supported in our

00:04:52,120 --> 00:04:59,920
stack because we don't have that kind of

00:04:55,300 --> 00:05:02,980
abstraction so I looked around and I

00:04:59,920 --> 00:05:05,110
found at an extravert and thankfully it

00:05:02,980 --> 00:05:07,450
was actually IRC license which means I

00:05:05,110 --> 00:05:11,010
could just grab code however I wanted to

00:05:07,450 --> 00:05:13,630
and read code however I wanted to and

00:05:11,010 --> 00:05:16,180
there are actually two drivers two

00:05:13,630 --> 00:05:19,500
drivers that were committed by Broadcom

00:05:16,180 --> 00:05:22,450
written in 2011 or something like that

00:05:19,500 --> 00:05:25,420
one of them is for the full max the full

00:05:22,450 --> 00:05:27,040
max are the newer generation chips which

00:05:25,420 --> 00:05:29,320
are more powerful and the other one is

00:05:27,040 --> 00:05:31,390
for a soft mac and a soft mac has the

00:05:29,320 --> 00:05:34,360
mac layer in code and you can see that

00:05:31,390 --> 00:05:36,130
also in the lines of code like it's it's

00:05:34,360 --> 00:05:38,590
a big difference especially there's one

00:05:36,130 --> 00:05:41,830
file which has 28 thousand bytes of

00:05:38,590 --> 00:05:43,600
magic look at it the first 10k lines are

00:05:41,830 --> 00:05:46,110
essentially magic numbers that do

00:05:43,600 --> 00:05:49,330
something or nothing

00:05:46,110 --> 00:05:53,530
porting that driver would also be a

00:05:49,330 --> 00:05:55,270
horrible task so on the bright side this

00:05:53,530 --> 00:05:56,680
is a driver that is only used on older

00:05:55,270 --> 00:05:59,650
MacBook so when people come to me and

00:05:56,680 --> 00:06:01,750
say hey if this chip supported and I see

00:05:59,650 --> 00:06:04,980
it's too old then I can say no it just

00:06:01,750 --> 00:06:08,560
would take too long to write a driver

00:06:04,980 --> 00:06:12,070
but still you have those 28 k lines of

00:06:08,560 --> 00:06:15,250
magic do what what did Bert can probably

00:06:12,070 --> 00:06:17,530
do well I guess they put that file into

00:06:15,250 --> 00:06:20,200
the filler so all the complexity and all

00:06:17,530 --> 00:06:23,850
the issues that they have are put into

00:06:20,200 --> 00:06:26,830
the full Mac into the full Mac number

00:06:23,850 --> 00:06:28,210
but still it makes our job easier

00:06:26,830 --> 00:06:30,190
because we don't have to do anything

00:06:28,210 --> 00:06:32,170
about beacons of frequencies or whatever

00:06:30,190 --> 00:06:36,130
we don't care about that all we have to

00:06:32,170 --> 00:06:40,780
do is basically initiate scan configure

00:06:36,130 --> 00:06:42,160
an SSID say join that SSID and handle

00:06:40,780 --> 00:06:43,360
the event and handle the data that

00:06:42,160 --> 00:06:50,560
arrived on the

00:06:43,360 --> 00:06:54,699
interrupts on the data pipes so let's

00:06:50,560 --> 00:06:56,860
talk first about how how the chip

00:06:54,699 --> 00:06:59,229
connects to the best layers and how we

00:06:56,860 --> 00:07:02,199
how its structured essentially the chip

00:06:59,229 --> 00:07:05,469
has three different bus buses that it

00:07:02,199 --> 00:07:07,960
can talk over their say use B bus which

00:07:05,469 --> 00:07:10,629
is used on some USB USB dongle

00:07:07,960 --> 00:07:15,280
there's the SDO bus which is essentially

00:07:10,629 --> 00:07:17,620
like an SD card and it's being used on

00:07:15,280 --> 00:07:19,840
plenty of SBC's lactose all in our

00:07:17,620 --> 00:07:21,490
boards and I even have an internal

00:07:19,840 --> 00:07:23,169
hardware that has it connected like that

00:07:21,490 --> 00:07:26,650
and then there's the PCI Express

00:07:23,169 --> 00:07:29,050
back-end which is being used on Mac

00:07:26,650 --> 00:07:32,949
books and there are even a few M two

00:07:29,050 --> 00:07:37,419
cards that you can put into your APU

00:07:32,949 --> 00:07:40,120
using a mini PCI Express adapter and the

00:07:37,419 --> 00:07:44,560
USB and as the apart have a middle layer

00:07:40,120 --> 00:07:47,680
command bcbc DC which is a very simple

00:07:44,560 --> 00:07:51,879
layer PCI Express is a bit more complex

00:07:47,680 --> 00:07:54,729
because under PCI Express bus the device

00:07:51,879 --> 00:07:57,430
can actually DMA from your memory so to

00:07:54,729 --> 00:08:00,279
make it faster it it's our really

00:07:57,430 --> 00:08:02,710
different system while on a while for

00:08:00,279 --> 00:08:07,000
USB Nessie you essentially sent packets

00:08:02,710 --> 00:08:09,490
and and frames to the other side what I

00:08:07,000 --> 00:08:11,560
did is I started with SEO because that

00:08:09,490 --> 00:08:14,379
was the first Hardware I had like the

00:08:11,560 --> 00:08:16,930
Intel hardware and realized that testing

00:08:14,379 --> 00:08:19,689
will be too slow essentially because I

00:08:16,930 --> 00:08:22,180
had my I don't know 40 inch TV and it

00:08:19,689 --> 00:08:23,710
was the only monitor I had and the

00:08:22,180 --> 00:08:25,509
internal machine didn't have a serial so

00:08:23,710 --> 00:08:29,400
every time I was sitting on my couch

00:08:25,509 --> 00:08:34,810
looking at my big TV with a damask and

00:08:29,400 --> 00:08:37,000
well so I bought a USB device my

00:08:34,810 --> 00:08:38,979
so-called official Raspberry Pi USB

00:08:37,000 --> 00:08:41,079
dongle because at that time when they

00:08:38,979 --> 00:08:46,120
produced the dongle the Raspberry Pi

00:08:41,079 --> 00:08:48,970
didn't have inbuilt Wi-Fi and since the

00:08:46,120 --> 00:08:51,100
Broadcom since the Raspberry Pi uses a

00:08:48,970 --> 00:08:52,990
Broadcom chipset and it's kind of from

00:08:51,100 --> 00:08:55,990
Broadcom they also used the Broadcom

00:08:52,990 --> 00:08:57,200
Wi-Fi I started building the lower

00:08:55,990 --> 00:09:01,970
layers like how do you

00:08:57,200 --> 00:09:03,860
Medicaid was to use video wise and then

00:09:01,970 --> 00:09:07,430
add at the top players to complete like

00:09:03,860 --> 00:09:09,440
a full chain of how you talk to device

00:09:07,430 --> 00:09:11,360
how you do Wi-Fi how you set the

00:09:09,440 --> 00:09:14,510
configuration and then edit a PCI

00:09:11,360 --> 00:09:17,990
Express and sto back-end later how does

00:09:14,510 --> 00:09:19,880
it use B Berg well no I'm not there yet

00:09:17,990 --> 00:09:21,410
first of all what do you do when you

00:09:19,880 --> 00:09:23,540
write a driver you write a skeleton

00:09:21,410 --> 00:09:25,100
driver something that simply attaches

00:09:23,540 --> 00:09:27,860
don't think that just says hey I've

00:09:25,100 --> 00:09:31,610
attached and then you build on top you

00:09:27,860 --> 00:09:33,500
say you try to find out how do you talk

00:09:31,610 --> 00:09:35,810
over the bus like if it's memory map you

00:09:33,500 --> 00:09:39,710
can just bust baby bass bass bass map it

00:09:35,810 --> 00:09:42,560
and go ahead if it's used B you will try

00:09:39,710 --> 00:09:45,230
to find the pipes so that you can send

00:09:42,560 --> 00:09:46,940
messages over the pipe and once you did

00:09:45,230 --> 00:09:49,490
that try to find out if the devices are

00:09:46,940 --> 00:09:52,220
lifelike read its chip ideally read its

00:09:49,490 --> 00:09:54,830
version read a MAC address and see if it

00:09:52,220 --> 00:09:56,920
responds and if you got that going then

00:09:54,830 --> 00:09:59,000
you know ok I can talk to device and

00:09:56,920 --> 00:10:05,540
then you can start building all the

00:09:59,000 --> 00:10:07,070
layers on top to use be interesting

00:10:05,540 --> 00:10:10,970
looks like I've got those already all

00:10:07,070 --> 00:10:12,610
slides anyway first of all you have some

00:10:10,970 --> 00:10:18,650
kind of control pipe that you need to

00:10:12,610 --> 00:10:21,310
send messages so that you can set the

00:10:18,650 --> 00:10:25,370
SSID set akiza's actually very simple

00:10:21,310 --> 00:10:28,520
and then you look for the data and the

00:10:25,370 --> 00:10:30,950
event pipes like you have an Rx pipe and

00:10:28,520 --> 00:10:34,280
TX pipe where you send packets over it

00:10:30,950 --> 00:10:35,900
and once you have those set up you can

00:10:34,280 --> 00:10:37,850
basically start setting the

00:10:35,900 --> 00:10:40,640
configuration and when you have the

00:10:37,850 --> 00:10:42,500
configuration you can set the SSID start

00:10:40,640 --> 00:10:43,850
a scan and then essentially wait for

00:10:42,500 --> 00:10:46,850
events to happen because at that time

00:10:43,850 --> 00:10:51,110
when you have the pipes open you will

00:10:46,850 --> 00:10:52,970
get transfer complete and get

00:10:51,110 --> 00:10:55,700
information how do you set a

00:10:52,970 --> 00:10:59,360
configuration on a top layer it's really

00:10:55,700 --> 00:11:02,180
simple it's essentially a key value with

00:10:59,360 --> 00:11:05,330
the key being an ASCII string and a

00:11:02,180 --> 00:11:07,790
value being some binary data so you fill

00:11:05,330 --> 00:11:09,890
a struct with the information that you

00:11:07,790 --> 00:11:10,910
need like when you scan you can you can

00:11:09,890 --> 00:11:12,560
say which frequents

00:11:10,910 --> 00:11:14,680
you want to scan or if it's an active or

00:11:12,560 --> 00:11:19,160
passive scan and then you basically say

00:11:14,680 --> 00:11:20,870
doing a scan with those parameters so

00:11:19,160 --> 00:11:23,570
now if you if you imagine writing a

00:11:20,870 --> 00:11:25,580
driver like that it's very simple

00:11:23,570 --> 00:11:28,160
because you have all those command

00:11:25,580 --> 00:11:29,870
saying set this configuration key to

00:11:28,160 --> 00:11:35,240
that set this configuration to key to

00:11:29,870 --> 00:11:38,030
that and it's it's easy to read and it's

00:11:35,240 --> 00:11:40,970
also easier to write after you've done

00:11:38,030 --> 00:11:44,630
that essentially it would look like this

00:11:40,970 --> 00:11:48,100
you concatenate the key and the

00:11:44,630 --> 00:11:50,230
parameters and it's basically the

00:11:48,100 --> 00:11:53,420
delimiters basically didn't alter memory

00:11:50,230 --> 00:11:55,850
terminator of the string you prepared

00:11:53,420 --> 00:11:58,340
some header the header specifies if it's

00:11:55,850 --> 00:12:00,170
I get or a set and the whole length of

00:11:58,340 --> 00:12:03,190
what you're said whatever setting or

00:12:00,170 --> 00:12:06,310
getting and that's essentially it

00:12:03,190 --> 00:12:08,720
not much not much more magic than that

00:12:06,310 --> 00:12:12,440
once you have done that essentially you

00:12:08,720 --> 00:12:15,680
can say do a scan and once you will do a

00:12:12,440 --> 00:12:18,200
scan you will get all the events the

00:12:15,680 --> 00:12:19,370
events and the data are essentially is

00:12:18,200 --> 00:12:23,750
enough packets you can see it on the

00:12:19,370 --> 00:12:26,270
right side there essentially is a packet

00:12:23,750 --> 00:12:28,310
with a prepended header the so-called

00:12:26,270 --> 00:12:30,410
BCDC header and in between there are

00:12:28,310 --> 00:12:32,840
ephemeral signals the most important

00:12:30,410 --> 00:12:35,120
part of the BCD C header is essentially

00:12:32,840 --> 00:12:38,150
the data offset because this one will

00:12:35,120 --> 00:12:43,640
tell you when the actual Ethernet data

00:12:38,150 --> 00:12:45,800
is starting events are also just easel

00:12:43,640 --> 00:12:49,460
friends but what are events first of all

00:12:45,800 --> 00:12:52,970
events are I have seen a node I have

00:12:49,460 --> 00:12:55,510
associated I have authenticated so all

00:12:52,970 --> 00:12:59,480
that stuff that happens on a Wi-Fi is

00:12:55,510 --> 00:13:04,370
transferred to you as a driver as either

00:12:59,480 --> 00:13:06,530
packets so you can see that so you can

00:13:04,370 --> 00:13:12,380
see that it's essentially a specific

00:13:06,530 --> 00:13:17,630
either type that that they use for the

00:13:12,380 --> 00:13:21,260
events now if you look at SD a OSD arrow

00:13:17,630 --> 00:13:23,080
is a whole different bus and it works

00:13:21,260 --> 00:13:24,840
completely differently but it has

00:13:23,080 --> 00:13:26,880
something in common you

00:13:24,840 --> 00:13:30,240
get the pack has the event packets on

00:13:26,880 --> 00:13:31,830
the incoming line and you sent but your

00:13:30,240 --> 00:13:36,450
Center configuration and data on the

00:13:31,830 --> 00:13:38,070
outgoing line you have a bit more than

00:13:36,450 --> 00:13:40,470
that because you can actually access

00:13:38,070 --> 00:13:42,630
more registers but essentially you have

00:13:40,470 --> 00:13:44,610
a FIFO where you write your bytes into

00:13:42,630 --> 00:13:46,980
so you when you read a packet you

00:13:44,610 --> 00:13:49,440
essentially do a read of a certain two

00:13:46,980 --> 00:13:51,240
bit integer or 16 bit integer first you

00:13:49,440 --> 00:13:53,730
see it has a specific line and then you

00:13:51,240 --> 00:13:59,550
read from that fee for the length of the

00:13:53,730 --> 00:14:03,930
whole packet there's something special

00:13:59,550 --> 00:14:06,450
on on s pcs with the SD i/o bus usually

00:14:03,930 --> 00:14:09,600
you would imagine it's just an SD SD

00:14:06,450 --> 00:14:11,370
card that you can put in but it doesn't

00:14:09,600 --> 00:14:14,160
completely work that way because on all

00:14:11,370 --> 00:14:16,110
the SDM on all the SDS pcs it's

00:14:14,160 --> 00:14:18,330
essentially soldered on the chip itself

00:14:16,110 --> 00:14:22,470
it's just soldered on the board itself

00:14:18,330 --> 00:14:25,730
and there's the back that happens on

00:14:22,470 --> 00:14:29,310
some host controllers so when you do

00:14:25,730 --> 00:14:31,950
SDIO with a one bit channel you have one

00:14:29,310 --> 00:14:34,230
pin where the data goes over but

00:14:31,950 --> 00:14:39,150
obviously you need some more speed so

00:14:34,230 --> 00:14:40,860
you do a four bit data communication but

00:14:39,150 --> 00:14:42,900
there's an interrupt pin and the inter

00:14:40,860 --> 00:14:46,740
up in a shirt with one of the data pins

00:14:42,900 --> 00:14:50,430
so the specification says that doing a

00:14:46,740 --> 00:14:54,060
specific interrupted this ayah cue pin

00:14:50,430 --> 00:14:56,130
is supposed to be sampled and some host

00:14:54,060 --> 00:14:58,170
controllers have trouble with that what

00:14:56,130 --> 00:15:02,190
I essentially work around with is they

00:14:58,170 --> 00:15:05,310
they route a GPIO pin outside to some

00:15:02,190 --> 00:15:06,780
other GPO and that will be used as

00:15:05,310 --> 00:15:13,950
atropine and then you don't have to

00:15:06,780 --> 00:15:16,860
simply enter up in itself that's well if

00:15:13,950 --> 00:15:19,500
you look at like a device tree it will

00:15:16,860 --> 00:15:23,670
look like a big hack but I guess it

00:15:19,500 --> 00:15:26,940
works and it makes it faster so why not

00:15:23,670 --> 00:15:29,100
then let's have a look at PCI Express I

00:15:26,940 --> 00:15:32,010
would go essentially into lust detail on

00:15:29,100 --> 00:15:35,010
PCI Express because it's much more

00:15:32,010 --> 00:15:37,080
complex with all the DMA going on

00:15:35,010 --> 00:15:39,209
essentially you have multiple ring

00:15:37,080 --> 00:15:41,639
buffers that you stuff data into and

00:15:39,209 --> 00:15:44,209
receive data from you have first of all

00:15:41,639 --> 00:15:46,410
the TX control ring which you used to

00:15:44,209 --> 00:15:49,470
send a configuration data for instance

00:15:46,410 --> 00:15:52,319
or to create flow rings and some like

00:15:49,470 --> 00:15:55,619
that so to send commands to the chip

00:15:52,319 --> 00:15:57,899
itself then you have an R exposed ring

00:15:55,619 --> 00:15:59,670
where you put empty buffers inside

00:15:57,899 --> 00:16:02,220
essentially it's a command telling the

00:15:59,670 --> 00:16:04,740
firmware hey here's an empty MF you can

00:16:02,220 --> 00:16:06,059
fill this one with data with input data

00:16:04,740 --> 00:16:11,569
that you receive from the outside world

00:16:06,059 --> 00:16:14,369
so you give the device and an buff and

00:16:11,569 --> 00:16:18,749
the device will tell you once

00:16:14,369 --> 00:16:21,600
it sends Eric's complete that packet ID

00:16:18,749 --> 00:16:23,189
whatever like number 120 has completed

00:16:21,600 --> 00:16:26,610
and then you look need to look up what

00:16:23,189 --> 00:16:30,240
is packet ID 120 get the M before that

00:16:26,610 --> 00:16:32,910
and put the amber back into the back

00:16:30,240 --> 00:16:34,769
into the tree network stack also

00:16:32,910 --> 00:16:36,119
obviously you have an control on TX

00:16:34,769 --> 00:16:40,470
control ring so it will let you know

00:16:36,119 --> 00:16:43,649
once once the commands that you have

00:16:40,470 --> 00:16:46,319
sent have completed also you have

00:16:43,649 --> 00:16:49,439
so-called flow rings those flow rings

00:16:46,319 --> 00:16:51,809
are dynamically allocated and those are

00:16:49,439 --> 00:16:54,929
essentially the actual TX ranks that you

00:16:51,809 --> 00:16:57,540
used to transmit data to a client or to

00:16:54,929 --> 00:16:59,670
an Access Point what you can do is it

00:16:57,540 --> 00:17:02,189
apparently is that you have multiple

00:16:59,670 --> 00:17:07,049
queues per node for instance of your in

00:17:02,189 --> 00:17:08,819
Access Point so I guess the chip itself

00:17:07,049 --> 00:17:12,360
can do some better queuing will with

00:17:08,819 --> 00:17:14,909
that and you have to open it up and tear

00:17:12,360 --> 00:17:19,620
down when a node attaches or detaches

00:17:14,909 --> 00:17:22,949
the interesting bit also about PCI

00:17:19,620 --> 00:17:25,740
Express and sjo is that you can read

00:17:22,949 --> 00:17:28,230
from basically the chip itself the chip

00:17:25,740 --> 00:17:30,289
itself looks a bit like this you have a

00:17:28,230 --> 00:17:33,600
bus and with a PCI Express and SDIO

00:17:30,289 --> 00:17:37,649
back-end and overdose you can talk to

00:17:33,600 --> 00:17:40,049
the OTP or to the RAM which you need to

00:17:37,649 --> 00:17:42,960
upload a symbol for the device so

00:17:40,049 --> 00:17:44,549
essentially you turn the arm off then

00:17:42,960 --> 00:17:46,380
you upload the firmware and then you

00:17:44,549 --> 00:17:48,360
kick start the arm core again so that it

00:17:46,380 --> 00:17:51,899
starts the firmware and you also write

00:17:48,360 --> 00:17:53,000
some configuration at the nvram what you

00:17:51,899 --> 00:18:00,289
can also do is

00:17:53,000 --> 00:18:02,600
some kind of damask essentially with the

00:18:00,289 --> 00:18:05,270
standard tremor it will write s click

00:18:02,600 --> 00:18:09,500
characters like printed it will print to

00:18:05,270 --> 00:18:12,530
some buffer and you can use that

00:18:09,500 --> 00:18:14,809
information to debug your own

00:18:12,530 --> 00:18:16,850
issues when you when you debug the

00:18:14,809 --> 00:18:19,730
driver for instance I had an issue where

00:18:16,850 --> 00:18:21,380
I sent too many packets to the device

00:18:19,730 --> 00:18:23,090
and then the device started complaining

00:18:21,380 --> 00:18:25,600
in a damask which was really really

00:18:23,090 --> 00:18:28,520
helpful to figure out what was going on

00:18:25,600 --> 00:18:31,010
but still as this tells you that the

00:18:28,520 --> 00:18:33,820
defender is actually quite huge it

00:18:31,010 --> 00:18:35,720
creates even a packet that part of some

00:18:33,820 --> 00:18:37,640
configuration stuff it prints

00:18:35,720 --> 00:18:44,240
information it kind of looks like Linux

00:18:37,640 --> 00:18:47,990
but I guess it isn't and if you look at

00:18:44,240 --> 00:18:49,640
the fembra itself like just runs drinks

00:18:47,990 --> 00:18:53,620
on the fembra you will see at the end

00:18:49,640 --> 00:18:56,409
that they have some feature flags and

00:18:53,620 --> 00:18:59,330
when they create efemer they essentially

00:18:56,409 --> 00:19:02,150
enable and disable what the chip and the

00:18:59,330 --> 00:19:04,100
fembra can do for instance this is a PCI

00:19:02,150 --> 00:19:07,299
Express firmware it can do peer-to-peer

00:19:04,100 --> 00:19:10,159
which Apple uses for the adverb feature

00:19:07,299 --> 00:19:12,730
SR stands for suspend and resume which

00:19:10,159 --> 00:19:15,470
means that if the firmware helps you in

00:19:12,730 --> 00:19:19,190
suspending and resuming a chip so that

00:19:15,470 --> 00:19:22,400
it can save its state there's the M Chan

00:19:19,190 --> 00:19:25,159
feature and it also has the mbss feature

00:19:22,400 --> 00:19:29,090
which is not on on that but it's a Ember

00:19:25,159 --> 00:19:30,890
feature that you can read this is used

00:19:29,090 --> 00:19:32,330
for if you want to create two access

00:19:30,890 --> 00:19:35,870
points for instance or if you want to

00:19:32,330 --> 00:19:38,720
operate on multiple channels and yeah

00:19:35,870 --> 00:19:42,620
you can also run basically a get

00:19:38,720 --> 00:19:44,750
ephemeral get features command so it's

00:19:42,620 --> 00:19:46,429
basically the same system as setting a

00:19:44,750 --> 00:19:48,260
variable you can read every label and

00:19:46,429 --> 00:19:51,409
there's a variable that tells you what

00:19:48,260 --> 00:19:56,179
features the firmware has the chip has

00:19:51,409 --> 00:19:59,990
and then you can act on that the tricky

00:19:56,179 --> 00:20:02,419
bits are bit floor control for instance

00:19:59,990 --> 00:20:05,240
honest SDIO I sent too many packets and

00:20:02,419 --> 00:20:06,590
then it just essentially gave up and

00:20:05,240 --> 00:20:09,320
then it was kind of hard

00:20:06,590 --> 00:20:11,720
figure out how does it how am I supposed

00:20:09,320 --> 00:20:14,120
to know if it's too much there are

00:20:11,720 --> 00:20:16,909
actually multiple ways of doing that one

00:20:14,120 --> 00:20:19,610
of it is in every packet that you send

00:20:16,909 --> 00:20:21,799
you you set a sequence number and every

00:20:19,610 --> 00:20:23,539
time you receive a packet it has a

00:20:21,799 --> 00:20:25,010
maximum sequence number so you can

00:20:23,539 --> 00:20:27,529
basically calculate the difference

00:20:25,010 --> 00:20:30,409
between the maximum that you're allowed

00:20:27,529 --> 00:20:33,590
to send and the one that you have sent

00:20:30,409 --> 00:20:37,580
so far also you have an issue with as

00:20:33,590 --> 00:20:41,570
increments control messages just imagine

00:20:37,580 --> 00:20:45,980
you you you establish a you attach to an

00:20:41,570 --> 00:20:47,899
access point and then you set the WPA

00:20:45,980 --> 00:20:50,029
keys and only after that you are

00:20:47,899 --> 00:20:53,029
supposed to send network packets because

00:20:50,029 --> 00:20:55,970
otherwise they are not encrypted and if

00:20:53,029 --> 00:20:57,559
you don't think that synchronously well

00:20:55,970 --> 00:21:01,520
you will send a packet before the keys

00:20:57,559 --> 00:21:04,549
are set and that means that you have to

00:21:01,520 --> 00:21:06,770
essentially make sure that it that it

00:21:04,549 --> 00:21:10,250
works in order but if you look at PCI

00:21:06,770 --> 00:21:11,870
Express there you send commands you send

00:21:10,250 --> 00:21:14,419
commands and at some point in time you

00:21:11,870 --> 00:21:17,570
will receive a packet back which tells

00:21:14,419 --> 00:21:19,640
you oh it finished but that means that

00:21:17,570 --> 00:21:22,490
until then you have to sleep and wait

00:21:19,640 --> 00:21:24,380
until it arrives which you can only do

00:21:22,490 --> 00:21:25,309
in process contacts and OpenBSD so

00:21:24,380 --> 00:21:27,830
you're not allowed to sleep in

00:21:25,309 --> 00:21:31,909
interrupts also the whole network stack

00:21:27,830 --> 00:21:36,350
integration is tough essentially because

00:21:31,909 --> 00:21:37,880
it was written for softmax so what we

00:21:36,350 --> 00:21:41,330
have to do in some parts of like if you

00:21:37,880 --> 00:21:44,740
receive a beacon which says hey I saw an

00:21:41,330 --> 00:21:47,000
Access Point or here I'm an access point

00:21:44,740 --> 00:21:49,549
we don't really get that kind of

00:21:47,000 --> 00:21:51,919
information but our stack expects that

00:21:49,549 --> 00:21:54,049
beacon so we have to essentially fake it

00:21:51,919 --> 00:21:57,169
we have to create a Wi-Fi frame

00:21:54,049 --> 00:21:59,840
internally in the driver which sets all

00:21:57,169 --> 00:22:01,909
the bits with the network which the

00:21:59,840 --> 00:22:05,480
Wi-Fi stack will expect so we fill that

00:22:01,909 --> 00:22:06,919
and put it into a stack they say it's

00:22:05,480 --> 00:22:09,679
the same with association and

00:22:06,919 --> 00:22:13,159
authentication so when we get the event

00:22:09,679 --> 00:22:15,530
that we are authenticated we still have

00:22:13,159 --> 00:22:17,960
to craft a Wi-Fi frame and send it into

00:22:15,530 --> 00:22:19,610
this deck so that our stack knows that

00:22:17,960 --> 00:22:22,470
it actually happened

00:22:19,610 --> 00:22:24,389
that's not nice but I guess for now

00:22:22,470 --> 00:22:27,629
that's a good start and then we can

00:22:24,389 --> 00:22:28,980
start on abstracting it and making it I

00:22:27,629 --> 00:22:31,440
don't know like the Linux with us with

00:22:28,980 --> 00:22:33,239
another layer but that also means that

00:22:31,440 --> 00:22:35,580
people would have to work on it and I

00:22:33,239 --> 00:22:38,070
guess that's a lot of time so it was

00:22:35,580 --> 00:22:39,649
easier to do it this way and maybe also

00:22:38,070 --> 00:22:42,929
keep it this way

00:22:39,649 --> 00:22:47,309
we also have issues like I told you it

00:22:42,929 --> 00:22:49,470
has a thunder and December well it's big

00:22:47,309 --> 00:22:55,440
it got many features and it also has

00:22:49,470 --> 00:22:56,929
bugs I told you also about the events

00:22:55,440 --> 00:23:00,029
that are even at packets

00:22:56,929 --> 00:23:02,460
well someone asked himself what happens

00:23:00,029 --> 00:23:04,669
if I sent us even a packet or those

00:23:02,460 --> 00:23:07,980
event packets from the outside and

00:23:04,669 --> 00:23:10,399
apparently well I think it was just

00:23:07,980 --> 00:23:13,830
passed through to the to the driver

00:23:10,399 --> 00:23:16,259
which means that you can send militia

00:23:13,830 --> 00:23:20,369
speckles from the outside to your driver

00:23:16,259 --> 00:23:23,909
which then tries to parse they the CVE

00:23:20,369 --> 00:23:27,090
was in 2016 and they fixed it I think

00:23:23,909 --> 00:23:30,929
more than a year later there was also

00:23:27,090 --> 00:23:35,009
crack which they also fixed sometime

00:23:30,929 --> 00:23:38,309
later and this information is based on a

00:23:35,009 --> 00:23:42,179
Linux member gate so it can be possible

00:23:38,309 --> 00:23:45,299
that if you are a bot manufacturer and

00:23:42,179 --> 00:23:48,299
you get the the chip from Broadcom or

00:23:45,299 --> 00:23:50,309
form some other supply in a chain then

00:23:48,299 --> 00:23:53,220
that they might have and your firmware

00:23:50,309 --> 00:23:55,799
for you but for the end user like us who

00:23:53,220 --> 00:23:59,129
are often getting some binary blobs of

00:23:55,799 --> 00:24:00,539
lumber from the deluxe Wilbur gate it

00:23:59,129 --> 00:24:02,909
will take some while until you actually

00:24:00,539 --> 00:24:05,220
get affixes so the information is

00:24:02,909 --> 00:24:09,480
released but the former isn't updated so

00:24:05,220 --> 00:24:11,700
that's not really nice for crack what we

00:24:09,480 --> 00:24:15,929
did is essentially we turn the feature

00:24:11,700 --> 00:24:20,100
off it has an inbuilt supplicant so you

00:24:15,929 --> 00:24:23,749
can tell that the chip that you can use

00:24:20,100 --> 00:24:26,609
this w this Wi-Fi key whatever it is and

00:24:23,749 --> 00:24:28,879
then it will do the WPA handshake for

00:24:26,609 --> 00:24:31,379
you but we turn it off

00:24:28,879 --> 00:24:32,240
let our stack handle it we have to fix

00:24:31,379 --> 00:24:35,210
this

00:24:32,240 --> 00:24:37,190
it works another issue is the so-called

00:24:35,210 --> 00:24:40,910
nvram this is essentially a

00:24:37,190 --> 00:24:44,840
configuration of the chip for the board

00:24:40,910 --> 00:24:46,640
so imagine you're a board manufacturer

00:24:44,840 --> 00:24:48,830
you buy the chip and then you go through

00:24:46,640 --> 00:24:51,620
C testing and the C testing will

00:24:48,830 --> 00:24:54,890
complain that are you draw too much

00:24:51,620 --> 00:24:57,500
power you do too much this and that and

00:24:54,890 --> 00:25:00,170
then you have to adjust that so there is

00:24:57,500 --> 00:25:03,679
and you can't change the filmer so what

00:25:00,170 --> 00:25:05,780
you changes the configuration this is

00:25:03,679 --> 00:25:07,670
always or sometimes sometimes needed on

00:25:05,780 --> 00:25:08,870
PCI Express like the MacBooks work out

00:25:07,670 --> 00:25:12,320
of the box you don't need to supply the

00:25:08,870 --> 00:25:15,530
envy Ram but there are those like the

00:25:12,320 --> 00:25:18,110
DPD pocket which is a very tiny into a

00:25:15,530 --> 00:25:20,630
based computer where you have to supply

00:25:18,110 --> 00:25:23,240
it on SDI oh you always have to supply

00:25:20,630 --> 00:25:26,030
there is no way around it and for USB

00:25:23,240 --> 00:25:29,660
you don't need it it's it's very simple

00:25:26,030 --> 00:25:32,000
you don't need it device hazard itself

00:25:29,660 --> 00:25:34,760
but there are also not many USB devices

00:25:32,000 --> 00:25:38,179
around where do you get that file well

00:25:34,760 --> 00:25:40,850
if you produce that hardware you create

00:25:38,179 --> 00:25:43,309
a file and what those bot manufacturers

00:25:40,850 --> 00:25:46,970
also produce is usually a Linux image or

00:25:43,309 --> 00:25:50,809
some some mechanism to build images and

00:25:46,970 --> 00:25:52,640
that one will have the files so if

00:25:50,809 --> 00:25:54,590
you're open be seen trying to supply

00:25:52,640 --> 00:25:57,020
open bc where are you going to get the

00:25:54,590 --> 00:25:58,309
files from you would have to look for or

00:25:57,020 --> 00:26:04,610
you would have to implement it for each

00:25:58,309 --> 00:26:07,940
port the GPD pocket which has the PCI

00:26:04,610 --> 00:26:10,460
Express back-end actually has the

00:26:07,940 --> 00:26:13,130
configuration stored in an ephah

00:26:10,460 --> 00:26:15,380
variable which means that well you can

00:26:13,130 --> 00:26:19,480
start Linux and then try to grab the

00:26:15,380 --> 00:26:22,160
file open BC so far has no way of

00:26:19,480 --> 00:26:23,900
reading the if a variable when being in

00:26:22,160 --> 00:26:27,140
well I'm booting up and being in a

00:26:23,900 --> 00:26:28,460
kernel that would be cool to have but as

00:26:27,140 --> 00:26:32,150
long as we don't have it there's no way

00:26:28,460 --> 00:26:34,820
to do that but what linux forever

00:26:32,150 --> 00:26:36,679
actually recently did is they gathered a

00:26:34,820 --> 00:26:39,830
collection of those and vram

00:26:36,679 --> 00:26:42,559
configuration files so it's getting

00:26:39,830 --> 00:26:44,970
better but it's still only for a handful

00:26:42,559 --> 00:26:47,760
of devices it's growing but mmm

00:26:44,970 --> 00:26:51,510
still applies so the biggest issue with

00:26:47,760 --> 00:26:53,580
running OpenBSD with all the DOS classes

00:26:51,510 --> 00:26:56,220
is when you don't have the env room how

00:26:53,580 --> 00:26:58,320
do you get it so far we have no solution

00:26:56,220 --> 00:27:00,560
for that other than sending me a mail

00:26:58,320 --> 00:27:06,390
and I will reply with what you need

00:27:00,560 --> 00:27:10,320
well current status this picture is

00:27:06,390 --> 00:27:12,600
pretty good JCS took it after PCI

00:27:10,320 --> 00:27:15,030
Express brought he essentially booted

00:27:12,600 --> 00:27:17,970
his MacBook with open BSD and run speed

00:27:15,030 --> 00:27:20,270
test so it's like 200 megabits down 100

00:27:17,970 --> 00:27:22,290
app that's actually pretty decent

00:27:20,270 --> 00:27:24,810
especially compared with the other

00:27:22,290 --> 00:27:28,620
drivers that we have in the tree at the

00:27:24,810 --> 00:27:30,660
moment so it works as a client it's

00:27:28,620 --> 00:27:32,280
really fast because all of the advice I

00:27:30,660 --> 00:27:33,990
stuff you don't have to do that the chip

00:27:32,280 --> 00:27:35,730
does it for you does all the queuing you

00:27:33,990 --> 00:27:38,730
just have to supply the packets and it

00:27:35,730 --> 00:27:40,260
does it for you the chips are on recent

00:27:38,730 --> 00:27:43,730
Mac books I don't know if the current

00:27:40,260 --> 00:27:47,700
generation still works with the driver

00:27:43,730 --> 00:27:52,350
the chip is also on raspberry PI's

00:27:47,700 --> 00:27:54,570
so a very popular SBC has that and it's

00:27:52,350 --> 00:27:59,970
also available available as USB dongle

00:27:54,570 --> 00:28:02,190
but it's only 802 11 N and only 2.4

00:27:59,970 --> 00:28:04,110
gigahertz and I'm not sure if you can

00:28:02,190 --> 00:28:06,240
still buy it because those were produced

00:28:04,110 --> 00:28:09,000
when you're asleep I didn't have inbuilt

00:28:06,240 --> 00:28:11,510
Wi-Fi yet and that's why it was the

00:28:09,000 --> 00:28:15,860
official verse berry pie Wi-Fi also

00:28:11,510 --> 00:28:19,380
often enough it works as access point

00:28:15,860 --> 00:28:21,870
sometimes it doesn't my co-workers wife

00:28:19,380 --> 00:28:23,730
always complains when a Wi-Fi doesn't

00:28:21,870 --> 00:28:26,130
work and then he tells her to reboot the

00:28:23,730 --> 00:28:28,350
machine and she's desperately waiting

00:28:26,130 --> 00:28:31,800
for me to find it back and fix the back

00:28:28,350 --> 00:28:34,670
so I guess that is something that I will

00:28:31,800 --> 00:28:38,610
have to do in the future at some point

00:28:34,670 --> 00:28:41,460
also we have the possibility to create

00:28:38,610 --> 00:28:43,020
multiple access points or to be an exit

00:28:41,460 --> 00:28:45,780
point and be a client at the same time

00:28:43,020 --> 00:28:47,610
you can create virtual interfaces on

00:28:45,780 --> 00:28:49,470
that on that member and then send

00:28:47,610 --> 00:28:52,980
packets based on the interface index

00:28:49,470 --> 00:28:54,330
that would be really cool to have but it

00:28:52,980 --> 00:28:56,790
also means that you would have to think

00:28:54,330 --> 00:28:58,169
about how do I create such virtual

00:28:56,790 --> 00:29:01,350
interfaces in the off

00:28:58,169 --> 00:29:04,710
writing system open BC does have a way

00:29:01,350 --> 00:29:06,629
like that but I also have an idea on how

00:29:04,710 --> 00:29:09,929
to do it but I haven't started yet

00:29:06,629 --> 00:29:12,359
also suspend resume well that should be

00:29:09,929 --> 00:29:13,919
a feature that everyone should have when

00:29:12,359 --> 00:29:16,320
when they have a laptop they want to

00:29:13,919 --> 00:29:18,090
suspend resume I didn't have a device

00:29:16,320 --> 00:29:20,609
which I could use to test has been

00:29:18,090 --> 00:29:22,830
resumed so far so I wasn't able to

00:29:20,609 --> 00:29:26,249
implement it and that's also why JCS

00:29:22,830 --> 00:29:28,499
isn't using it anymore then there are

00:29:26,249 --> 00:29:31,169
so-called filmer signals those are being

00:29:28,499 --> 00:29:34,499
used in the BCDC packet that we saw

00:29:31,169 --> 00:29:36,960
previously there are some kind of invent

00:29:34,499 --> 00:29:38,730
signaling which I haven't looked at and

00:29:36,960 --> 00:29:41,519
there's plenty of code to parse that and

00:29:38,730 --> 00:29:45,210
I'm not sure yet what well what this is

00:29:41,519 --> 00:29:47,100
for but I will have a look and basically

00:29:45,210 --> 00:29:50,489
the last thing is support more devices

00:29:47,100 --> 00:29:54,629
and the biggest part of that is not

00:29:50,489 --> 00:29:57,899
actually improving the B wfm driver it's

00:29:54,629 --> 00:30:00,690
more about adding support for all those

00:29:57,899 --> 00:30:03,149
SPC's across the PCI Express back and

00:30:00,690 --> 00:30:05,039
it's written use B's written sta back in

00:30:03,149 --> 00:30:06,690
this written but what is not written the

00:30:05,039 --> 00:30:11,009
driver data that the drivers that are

00:30:06,690 --> 00:30:13,049
still missing is the connection to the

00:30:11,009 --> 00:30:14,909
system so there are plenty of SPC's

00:30:13,049 --> 00:30:19,049
around from all winner or whatever else

00:30:14,909 --> 00:30:21,389
which have that SD card controller but

00:30:19,049 --> 00:30:24,149
we don't have a driver for that yet for

00:30:21,389 --> 00:30:27,419
example the Raspberry Pi we run on the

00:30:24,149 --> 00:30:29,489
Raspberry Pi but we have no store yet

00:30:27,419 --> 00:30:32,629
because they have two SD card

00:30:29,489 --> 00:30:35,759
controllers two different ones one for

00:30:32,629 --> 00:30:37,769
the Wi-Fi and one for day for the SD

00:30:35,759 --> 00:30:41,909
card and you're still missing the driver

00:30:37,769 --> 00:30:45,779
for that now I'm at the end I have to

00:30:41,909 --> 00:30:48,509
thank Stefan spelling he's been an

00:30:45,779 --> 00:30:50,730
immense help in getting the driver into

00:30:48,509 --> 00:30:54,090
the tree into adding all the features

00:30:50,730 --> 00:30:57,059
into well integrating it into the stack

00:30:54,090 --> 00:31:00,450
and how to actually write a driver and

00:30:57,059 --> 00:31:03,619
how to structure it and well much thanks

00:31:00,450 --> 00:31:03,619
to our Wi-Fi god

00:31:08,560 --> 00:31:17,330
Thank You Patrick we have time for

00:31:11,120 --> 00:31:21,310
questions come on up please

00:31:17,330 --> 00:31:24,620
so you did you pour it Linux driver the

00:31:21,310 --> 00:31:26,980
ISE a Linux driver or did you just look

00:31:24,620 --> 00:31:29,360
at it from time to time

00:31:26,980 --> 00:31:33,170
both actually I didn't report it because

00:31:29,360 --> 00:31:36,560
it was well it was like 35 K lines of

00:31:33,170 --> 00:31:37,820
code yeah and then adjust the drivers it

00:31:36,560 --> 00:31:40,520
will be too much so essentially what I

00:31:37,820 --> 00:31:43,370
did was I wrote a skeleton driver and I

00:31:40,520 --> 00:31:46,520
started like adding the feature of means

00:31:43,370 --> 00:31:48,860
by building on B but beat some bits I

00:31:46,520 --> 00:31:50,900
could just cope and I just copy and

00:31:48,860 --> 00:31:52,670
adjust and other bits are completely

00:31:50,900 --> 00:31:55,430
rewrote but based on the information

00:31:52,670 --> 00:31:57,920
that I saw in the deluxe driver okay and

00:31:55,430 --> 00:32:00,470
so forth of film where did you take

00:31:57,920 --> 00:32:02,570
everything that is in Linux firmware and

00:32:00,470 --> 00:32:04,940
you created a open BSD package or

00:32:02,570 --> 00:32:06,830
whatever yeah we have an open BSD ports

00:32:04,940 --> 00:32:10,280
packet which is based on a Linux one

00:32:06,830 --> 00:32:13,730
Birgit yep okay thank you so if you

00:32:10,280 --> 00:32:17,480
actually if you plug in a a chip and you

00:32:13,730 --> 00:32:19,520
boot up the firmware update program will

00:32:17,480 --> 00:32:20,780
pick it up and see it's a BW vendor that

00:32:19,520 --> 00:32:24,290
hatched and then it will install the

00:32:20,780 --> 00:32:27,710
favor for you are you aware of any work

00:32:24,290 --> 00:32:32,510
that's being done to create like an you

00:32:27,710 --> 00:32:39,260
know 802 11

00:32:32,510 --> 00:32:40,880
I guess interface to our net 802 or

00:32:39,260 --> 00:32:43,910
other than interface to make porting

00:32:40,880 --> 00:32:45,980
Linux drivers generally easier there are

00:32:43,910 --> 00:32:48,020
a few in the tree right now that have an

00:32:45,980 --> 00:32:50,060
acceptable license that aren't GPL

00:32:48,020 --> 00:32:52,460
contaminated that would be nice to bring

00:32:50,060 --> 00:32:55,160
over but since they're coded to a

00:32:52,460 --> 00:33:00,230
different network interface and then if

00:32:55,160 --> 00:33:02,150
net and then 802 11 it's rather

00:33:00,230 --> 00:33:04,130
difficult to do is are you aware of any

00:33:02,150 --> 00:33:08,510
efforts in that area either on open BSD

00:33:04,130 --> 00:33:10,280
or other BS DS I know that we don't have

00:33:08,510 --> 00:33:13,100
plans to do that and I think we won't

00:33:10,280 --> 00:33:15,560
actually do that because there's also so

00:33:13,100 --> 00:33:17,779
much work to restructure it and well the

00:33:15,560 --> 00:33:20,090
gains are copying files

00:33:17,779 --> 00:33:22,729
but also on the other hand those files

00:33:20,090 --> 00:33:24,710
won't just automatically compile because

00:33:22,729 --> 00:33:26,899
there's so much infrastructure that is

00:33:24,710 --> 00:33:29,570
completely different and it's not also

00:33:26,899 --> 00:33:31,460
the net the the Wi-Fi stack but also

00:33:29,570 --> 00:33:33,710
other parts of the stack that you cannot

00:33:31,460 --> 00:33:36,529
just drop it in what we do is

00:33:33,710 --> 00:33:39,529
essentially we implement it driver by

00:33:36,529 --> 00:33:43,519
driver essentially so we were improving

00:33:39,529 --> 00:33:47,149
the IWM driver for newer trips and for

00:33:43,519 --> 00:33:51,409
November we would like to have the 88

00:33:47,149 --> 00:33:54,799
the SRS 10-k driver implemented but we

00:33:51,409 --> 00:33:56,389
also won't copy the driver we have a new

00:33:54,799 --> 00:33:59,779
implementation basically which is based

00:33:56,389 --> 00:34:01,969
on that driver and then there are plenty

00:33:59,779 --> 00:34:05,629
of other drivers which have well a

00:34:01,969 --> 00:34:07,549
license that doesn't work with us and I

00:34:05,629 --> 00:34:09,710
would say that most of the devices that

00:34:07,549 --> 00:34:12,559
you want to have are essentially the

00:34:09,710 --> 00:34:16,250
Intel chips because those are available

00:34:12,559 --> 00:34:18,889
and basically every computer or every

00:34:16,250 --> 00:34:22,309
laptop and then you have the eighth row

00:34:18,889 --> 00:34:27,409
skip yeah except my my laptop doesn't

00:34:22,309 --> 00:34:35,169
have an Intel chip in it it has a ralink

00:34:27,409 --> 00:34:39,909
chip in it RT and wireless and the

00:34:35,169 --> 00:34:43,190
freebsd kernel has a number of winix api

00:34:39,909 --> 00:34:45,139
calls that you can use from drivers so

00:34:43,190 --> 00:34:48,799
that's one of the big missing pieces or

00:34:45,139 --> 00:34:52,760
the bits from how do you interface to

00:34:48,799 --> 00:34:54,470
the network stack and given the number

00:34:52,760 --> 00:34:56,059
of different drivers we could choose

00:34:54,470 --> 00:34:59,059
from it seems like it would be less work

00:34:56,059 --> 00:35:01,849
to provide that than to for each new

00:34:59,059 --> 00:35:08,450
chipset that comes out rewrite it to our

00:35:01,849 --> 00:35:10,369
old Sam Lafleur era networking code so I

00:35:08,450 --> 00:35:12,619
was just curious if people were thinking

00:35:10,369 --> 00:35:17,109
about that are still doing it one at a

00:35:12,619 --> 00:35:17,109
time as the need came up so

00:35:26,609 --> 00:35:31,569
to get it on the record actually because

00:35:29,560 --> 00:35:33,240
definite now speaking who's the wife I

00:35:31,569 --> 00:35:37,690
got of OpenBSD he's saying that

00:35:33,240 --> 00:35:40,810
essentially writing the interface to

00:35:37,690 --> 00:35:42,430
drop in the Linux drivers more work than

00:35:40,810 --> 00:35:51,910
just maintaining and writing the drivers

00:35:42,430 --> 00:36:07,599
ourselves yeah okay we will get stephan

00:35:51,910 --> 00:36:15,310
on the mic so if you look at you so if

00:36:07,599 --> 00:36:16,900
you okay so the thing is the drivers

00:36:15,310 --> 00:36:18,579
already take care of a lot of hardware

00:36:16,900 --> 00:36:20,470
abstractions and they do this in

00:36:18,579 --> 00:36:23,109
regardless of operating systems and this

00:36:20,470 --> 00:36:25,480
is already quite a lot of code now this

00:36:23,109 --> 00:36:26,920
is the hardware side now the operating

00:36:25,480 --> 00:36:28,780
system side is a different piece is

00:36:26,920 --> 00:36:31,690
basically the driver sits beneath these

00:36:28,780 --> 00:36:33,940
two layers and between them and so what

00:36:31,690 --> 00:36:35,109
you're proposing is like okay well take

00:36:33,940 --> 00:36:37,780
all the hardware stuff from these

00:36:35,109 --> 00:36:39,010
drivers and make your kernel work with

00:36:37,780 --> 00:36:41,650
them but also make your kernel

00:36:39,010 --> 00:36:43,359
compatible with the upper interface so

00:36:41,650 --> 00:36:45,940
you're duplicating effort you're making

00:36:43,359 --> 00:36:48,130
more you're creating more work because

00:36:45,940 --> 00:36:50,230
now you have to maintain not just a

00:36:48,130 --> 00:36:51,910
hardware interfacing side of things but

00:36:50,230 --> 00:36:53,950
also the kernel interfacing side of

00:36:51,910 --> 00:36:55,810
things so you have a lot more code to

00:36:53,950 --> 00:36:58,240
take care of and we are like

00:36:55,810 --> 00:36:59,800
two-and-a-half people and the project

00:36:58,240 --> 00:37:01,329
taken care of Wi-Fi and we can't even

00:36:59,800 --> 00:37:03,780
keep up with the current number of

00:37:01,329 --> 00:37:06,780
hardware devices that are out there and

00:37:03,780 --> 00:37:06,780
so

00:37:09,900 --> 00:37:15,309
so I think and also the Linux is moving

00:37:13,269 --> 00:37:16,839
so fast and they have so many developers

00:37:15,309 --> 00:37:19,239
and they are changing things all the

00:37:16,839 --> 00:37:21,099
time and keeping track of stuff and for

00:37:19,239 --> 00:37:23,199
example the graphics stack as you can

00:37:21,099 --> 00:37:24,959
see is already difficult and doing the

00:37:23,199 --> 00:37:27,519
same in Wi-Fi I think just won't scale

00:37:24,959 --> 00:37:27,910
if you look at commits like Broadcom and

00:37:27,519 --> 00:37:30,430
Linux

00:37:27,910 --> 00:37:32,319
Intel drivers and Linux and you will see

00:37:30,430 --> 00:37:33,880
that only the developers of those

00:37:32,319 --> 00:37:36,069
companies were employed there actually

00:37:33,880 --> 00:37:38,289
commit meaningful things that are

00:37:36,069 --> 00:37:39,519
related to hardware changes all the

00:37:38,289 --> 00:37:41,499
other people in the community just to

00:37:39,519 --> 00:37:43,690
clean up work and refactorings but they

00:37:41,499 --> 00:37:45,579
don't actually do any thing that matters

00:37:43,690 --> 00:37:47,049
as far as the drivers are concerned so

00:37:45,579 --> 00:37:49,299
you need like they have like an army of

00:37:47,049 --> 00:37:51,219
employed people and we can't keep up

00:37:49,299 --> 00:37:52,599
with that so it's just hard enough or

00:37:51,219 --> 00:37:54,549
ready to do this from the for the

00:37:52,599 --> 00:37:55,900
hardware itself but also doing it for

00:37:54,549 --> 00:38:00,309
the rest of the kernel would just be

00:37:55,900 --> 00:38:02,259
impossible ok so it's basically

00:38:00,309 --> 00:38:05,440
interface velocity and Linux which has

00:38:02,259 --> 00:38:08,339
been a known problem and the complexity

00:38:05,440 --> 00:38:11,709
of maintaining effectively to 802 11

00:38:08,339 --> 00:38:14,289
stacks in the tree that is what makes

00:38:11,709 --> 00:38:17,949
the idea of having a Linux compatibility

00:38:14,289 --> 00:38:19,599
layer difficult to first of all

00:38:17,949 --> 00:38:20,949
implement because it's so big and second

00:38:19,599 --> 00:38:22,779
of all to maintain because it's moving

00:38:20,949 --> 00:38:24,910
so fast and it's easier just to pull the

00:38:22,779 --> 00:38:27,069
hardware bits in ok exactly and also

00:38:24,910 --> 00:38:28,599
then it's actually only has not just one

00:38:27,069 --> 00:38:29,890
Mac layer implementation but several

00:38:28,599 --> 00:38:33,519
because some of the drivers don't use

00:38:29,890 --> 00:38:34,599
Intel's Mac 802 11 they use others for

00:38:33,519 --> 00:38:37,569
all the hardware generations in

00:38:34,599 --> 00:38:38,769
particular so the the proton driver is

00:38:37,569 --> 00:38:42,489
large because it doesn't use that

00:38:38,769 --> 00:38:45,160
framework for example parts of it but

00:38:42,489 --> 00:38:47,259
not not the way it'll does so it's yeah

00:38:45,160 --> 00:38:49,479
I've worked it exactly one driver so

00:38:47,259 --> 00:38:51,239
it's like oh this uses this interface

00:38:49,479 --> 00:38:53,829
why don't we have this interface I

00:38:51,239 --> 00:38:55,329
thought it would be simple but as you

00:38:53,829 --> 00:38:58,269
just explained that it makes sense

00:38:55,329 --> 00:38:59,619
thank you for adding some color to what

00:38:58,269 --> 00:39:03,809
seems like a simple problem but actually

00:38:59,619 --> 00:39:03,809
is complicated no worries thank you

00:39:07,830 --> 00:39:17,190
hello so would you describe now Broadcom

00:39:13,480 --> 00:39:23,980
as a bit more open-source friendly

00:39:17,190 --> 00:39:26,320
entity no I wouldn't try to get data

00:39:23,980 --> 00:39:28,480
sheets essentially there are none

00:39:26,320 --> 00:39:30,010
well they don't see that those exist but

00:39:28,480 --> 00:39:32,860
really documentation which talked about

00:39:30,010 --> 00:39:34,840
the register how to interact with it it

00:39:32,860 --> 00:39:37,150
it doesn't exist and it you can see that

00:39:34,840 --> 00:39:40,450
with plenty of other devices and plenty

00:39:37,150 --> 00:39:43,000
of other ships so it's pretty good to

00:39:40,450 --> 00:39:44,290
have that driver a C license but I feel

00:39:43,000 --> 00:39:48,190
like that's like the only thing that

00:39:44,290 --> 00:39:50,320
they actually produced the previous

00:39:48,190 --> 00:39:52,960
driver and the one that they are still

00:39:50,320 --> 00:39:56,710
still shipping to customers is some

00:39:52,960 --> 00:39:58,840
internally developed driver which you

00:39:56,710 --> 00:40:00,790
are not allowed to show anyone to the

00:39:58,840 --> 00:40:03,430
outside so the one that is in Linux is

00:40:00,790 --> 00:40:05,760
basically a reimplementation of the

00:40:03,430 --> 00:40:08,320
driver that they ship to their customers

00:40:05,760 --> 00:40:10,360
but otherwise that's essentially the

00:40:08,320 --> 00:40:13,210
only open thing I have seen about

00:40:10,360 --> 00:40:14,830
Broadcom but I guess there are different

00:40:13,210 --> 00:40:16,900
divisions because they also brought come

00:40:14,830 --> 00:40:18,010
with a big company they do also some

00:40:16,900 --> 00:40:22,540
other network controllers and whatever

00:40:18,010 --> 00:40:25,170
else so maybe some departments are a bit

00:40:22,540 --> 00:40:25,170
different about that

00:40:30,490 --> 00:40:37,240
am I saying that Cypress now owns

00:40:34,290 --> 00:40:39,640
Broadcom and yes there are of Cypress

00:40:37,240 --> 00:40:42,880
chips or Cypress chips that are

00:40:39,640 --> 00:40:46,510
essentially Broadcom chips but I don't

00:40:42,880 --> 00:40:54,300
know if that will change we will I guess

00:40:46,510 --> 00:40:54,300
not all right Thank You Patrick

00:41:00,040 --> 00:41:02,100

YouTube URL: https://www.youtube.com/watch?v=8N0IL8APCHg


