Title: Fuzzing Filesystems on NetBSD via AFL+KCOV by Maciej Grochowski
Publication date: 2019-10-21
Playlist: EuroBSDCon 2019, Norway
Description: 
	Fuzzing Filesystems on NetBSD via AFL+KCOV

Filesystems are one of the most important parts of OS. Because they are responsible for storing user data, any software bug can potentially cause damage and data corruption. So from OS users perspective, data needs to be safe and bulletproof. Any data corruption may imminently cause users to switch to other software stacks. Because of that part of the NetBSD, the community decided to spend more effort on hardening FSes. For the last few years, NetBSD became strong with new security features in the BSD world as Sanitizers or Fuzzers. Now this work is being used to finding and fixing different FS bugs.

Maciej Grochowski

System Engineer experienced at work with various Operating Systems: from Solaris, Linux to FreeBSD. Currently helping NetBSD. Interested in Storage and Filesystems, Fast and Low latency code, and modern kernel features. Ex. Intel, Veritas, NTT. At this moment developing infrastructure for Cloud Gaming at Playstation

More Info:
https://2019.eurobsdcon.org/talk-speakers/#AFL
Captions: 
	00:00:05,279 --> 00:00:36,579
welcome to the second slot of the CSD

00:00:10,179 --> 00:00:40,120
come with us a good murder can run my

00:00:36,579 --> 00:00:42,910
name is machi and I was spotted I

00:00:40,120 --> 00:00:45,340
started working on that BSD fuzzing with

00:00:42,910 --> 00:00:47,410
American fuzzy lube and take off so I

00:00:45,340 --> 00:00:50,019
have this pleasure to be your presenter

00:00:47,410 --> 00:00:53,250
before the lunch break so it's not ideal

00:00:50,019 --> 00:00:56,829
but hopefully we were able to make it

00:00:53,250 --> 00:00:58,960
let's start with the outline so today I

00:00:56,829 --> 00:01:01,899
will be talking about in the passing but

00:00:58,960 --> 00:01:05,170
the fasiq is part it was part of larger

00:01:01,899 --> 00:01:09,070
initiative inside the net bsd which is

00:01:05,170 --> 00:01:10,540
net bsd a quality assurance and so i

00:01:09,070 --> 00:01:12,730
first of all will touch on this topic

00:01:10,540 --> 00:01:17,050
and also i have a couple more more

00:01:12,730 --> 00:01:21,610
slides that new was done in this area

00:01:17,050 --> 00:01:23,260
and then I will move I touch a little

00:01:21,610 --> 00:01:25,540
bit what the fuzzing is probably

00:01:23,260 --> 00:01:28,540
everyone is already familiar what the

00:01:25,540 --> 00:01:30,700
fighting is but just as a reference and

00:01:28,540 --> 00:01:34,720
some background some kind of obligated

00:01:30,700 --> 00:01:37,030
to do this and then we'll talk about the

00:01:34,720 --> 00:01:39,310
work that I was doing for porting

00:01:37,030 --> 00:01:42,880
American fuzzy live too fast

00:01:39,310 --> 00:01:45,760
net BSD kernel and file system subsystem

00:01:42,880 --> 00:01:49,660
in general because I'm mostly interested

00:01:45,760 --> 00:01:52,980
in file systems and some work for

00:01:49,660 --> 00:01:55,890
coverage and kick off that what I was

00:01:52,980 --> 00:01:58,570
doing with some members in the community

00:01:55,890 --> 00:02:02,160
then I will show some basic advising

00:01:58,570 --> 00:02:04,870
setup and how we can easily do the

00:02:02,160 --> 00:02:08,140
passing of the file system so I will try

00:02:04,870 --> 00:02:10,959
to convince you that something with in

00:02:08,140 --> 00:02:12,440
this way is really simple and everyone

00:02:10,959 --> 00:02:15,560
who is writing some kernel

00:02:12,440 --> 00:02:19,010
code can also do this by its own so you

00:02:15,560 --> 00:02:20,600
don't have to do some very complicated

00:02:19,010 --> 00:02:22,790
setup with multiple virtual machines

00:02:20,600 --> 00:02:27,890
some servers you can just do this

00:02:22,790 --> 00:02:33,470
locally just like a very low entry bar

00:02:27,890 --> 00:02:36,320
and end up with some conclusions and as

00:02:33,470 --> 00:02:39,170
I said earlier I have also a couple of

00:02:36,320 --> 00:02:43,130
slides from my click Camille about the

00:02:39,170 --> 00:02:45,200
state of 90s dqe so I plan to do those

00:02:43,130 --> 00:02:52,850
slides after and then I will be able to

00:02:45,200 --> 00:02:55,010
take her questions so as I said we have

00:02:52,850 --> 00:02:58,880
this inertia initiative inside the

00:02:55,010 --> 00:03:03,140
community to improve the quality of not

00:02:58,880 --> 00:03:05,780
vsd so we have many different ideas and

00:03:03,140 --> 00:03:08,620
a couple of people working as a

00:03:05,780 --> 00:03:13,520
community to improving the quality and

00:03:08,620 --> 00:03:16,400
this started couple years ago when we

00:03:13,520 --> 00:03:19,850
got some security researcher finding

00:03:16,400 --> 00:03:22,630
multiple bags in that bsd some of them

00:03:19,850 --> 00:03:26,030
were in a kind of style code or not

00:03:22,630 --> 00:03:30,290
frequently used but as i remember

00:03:26,030 --> 00:03:32,930
correctly there was something like 8080

00:03:30,290 --> 00:03:35,750
netbsd bags which were fixed very

00:03:32,930 --> 00:03:40,150
quickly but people started thinking okay

00:03:35,750 --> 00:03:44,450
so how we can make sure that our quality

00:03:40,150 --> 00:03:46,730
as a small community will be able to

00:03:44,450 --> 00:03:49,390
scale and how we can improve how we can

00:03:46,730 --> 00:03:54,470
improve the quality so we have

00:03:49,390 --> 00:03:58,220
sanitizers free disease currently very

00:03:54,470 --> 00:04:00,940
well sanitize across the business and so

00:03:58,220 --> 00:04:06,400
recently we got MK sanitizers which is

00:04:00,940 --> 00:04:09,950
really nice too to get our user space

00:04:06,400 --> 00:04:12,440
for us for fuzzing because when you are

00:04:09,950 --> 00:04:16,519
doing the fuzzing you usually also would

00:04:12,440 --> 00:04:19,730
like to run with sanitizers topple

00:04:16,519 --> 00:04:21,830
kernel sanitizers leaks ionizers address

00:04:19,730 --> 00:04:25,700
space centers undefined behavior

00:04:21,830 --> 00:04:28,400
sanitizer we have security team so

00:04:25,700 --> 00:04:29,870
if you find any bugs or have some

00:04:28,400 --> 00:04:32,960
concerns you can talk with them directly

00:04:29,870 --> 00:04:36,740
so my part of the work is related to

00:04:32,960 --> 00:04:39,550
fuzzing with AFL American fuzzy loop but

00:04:36,740 --> 00:04:43,130
also there are a couple more buzzers

00:04:39,550 --> 00:04:46,100
this this summer we had a couple

00:04:43,130 --> 00:04:48,260
students working on sis color finding a

00:04:46,100 --> 00:04:53,150
lot of interesting things inside the SIS

00:04:48,260 --> 00:04:58,790
color we also get people from I think

00:04:53,150 --> 00:05:02,660
from Google to Iran also this is color

00:04:58,790 --> 00:05:05,990
because scholar is a cool project on ESD

00:05:02,660 --> 00:05:10,910
and even yesterday we got couple reports

00:05:05,990 --> 00:05:12,680
I think three or four crashes and I have

00:05:10,910 --> 00:05:16,220
felt three fours another at google

00:05:12,680 --> 00:05:20,150
Summer of Code project I also very

00:05:16,220 --> 00:05:22,220
interesting and we also have ROM kernels

00:05:20,150 --> 00:05:23,030
which are very interesting topic I won't

00:05:22,220 --> 00:05:25,880
be talking too much

00:05:23,030 --> 00:05:28,220
load from Carlos today but also

00:05:25,880 --> 00:05:30,710
encourage you to research a little bit

00:05:28,220 --> 00:05:34,600
this area so there are other things like

00:05:30,710 --> 00:05:37,850
stack protector static code analysis

00:05:34,600 --> 00:05:39,740
Hardware back mitigation that was of

00:05:37,850 --> 00:05:43,910
people looking after I'm not very

00:05:39,740 --> 00:05:45,770
familiar in this part but also if you

00:05:43,910 --> 00:05:48,710
have any other idea how we can improve

00:05:45,770 --> 00:05:52,000
the quality feel good feel free to join

00:05:48,710 --> 00:05:55,550
us the simple way is just about this dqe

00:05:52,000 --> 00:05:56,500
on freenode there's a couple of people

00:05:55,550 --> 00:06:01,910
over there

00:05:56,500 --> 00:06:06,470
some also started this spring working on

00:06:01,910 --> 00:06:09,320
the AFL some kind of kind of like a not

00:06:06,470 --> 00:06:12,410
very old not very old a member of this

00:06:09,320 --> 00:06:18,470
community my I found is really nice and

00:06:12,410 --> 00:06:20,180
also I think also an entry bar is very

00:06:18,470 --> 00:06:23,840
low and you can start doing some

00:06:20,180 --> 00:06:26,930
interesting things quickly so starting

00:06:23,840 --> 00:06:28,880
with the passing I won't be talking too

00:06:26,930 --> 00:06:31,580
much about this but just a simple

00:06:28,880 --> 00:06:33,880
reference so you can write the simpler

00:06:31,580 --> 00:06:36,620
faster you can just get some random data

00:06:33,880 --> 00:06:38,300
let's assume that you have some binary

00:06:36,620 --> 00:06:41,449
that you like to fast

00:06:38,300 --> 00:06:44,599
and this binary takers are I recommend a

00:06:41,449 --> 00:06:47,389
path to the file this file have to the

00:06:44,599 --> 00:06:50,030
file can be for example 1k in size so we

00:06:47,389 --> 00:06:53,509
can just get a thousand bytes from

00:06:50,030 --> 00:06:58,580
random and put them as a file and then

00:06:53,509 --> 00:07:01,280
run the file in binary with this file so

00:06:58,580 --> 00:07:03,919
this actually is the simplest way that

00:07:01,280 --> 00:07:06,620
you can do from the other side and as

00:07:03,919 --> 00:07:10,009
you can imagine the space of all

00:07:06,620 --> 00:07:12,710
possible inputs exponentially

00:07:10,009 --> 00:07:16,340
exponentially large and most of those

00:07:12,710 --> 00:07:19,400
inputs won't really fit to your program

00:07:16,340 --> 00:07:22,250
because usually the program expect some

00:07:19,400 --> 00:07:25,789
particular format of the data so you may

00:07:22,250 --> 00:07:29,930
have a program that needs some image for

00:07:25,789 --> 00:07:33,259
example jpg or PNG you may have

00:07:29,930 --> 00:07:34,849
something that requires some document so

00:07:33,259 --> 00:07:37,819
if you are passing in this way and just

00:07:34,849 --> 00:07:40,729
getting the random data you most likely

00:07:37,819 --> 00:07:44,960
will be iterating over and over again on

00:07:40,729 --> 00:07:47,990
some header tags on some very some entry

00:07:44,960 --> 00:07:51,680
code of the program and you won't be

00:07:47,990 --> 00:07:57,229
executing the Buffs so how how we can do

00:07:51,680 --> 00:08:01,099
this phasing process much smarter so we

00:07:57,229 --> 00:08:03,889
can start thinking first of all if you

00:08:01,099 --> 00:08:05,870
what about this program you can try to

00:08:03,889 --> 00:08:09,650
improve somehow the way how we generate

00:08:05,870 --> 00:08:14,000
the input so we can for example have

00:08:09,650 --> 00:08:17,270
some idea what the input format is so if

00:08:14,000 --> 00:08:21,770
we know that we are passing that for

00:08:17,270 --> 00:08:27,800
example images we can take some in some

00:08:21,770 --> 00:08:30,349
input as I example like the image file

00:08:27,800 --> 00:08:34,130
and then try to change and play with

00:08:30,349 --> 00:08:36,729
bits from it and this kind of this is

00:08:34,130 --> 00:08:39,919
kind of the way how much

00:08:36,729 --> 00:08:42,740
iteration phasing works so motivational

00:08:39,919 --> 00:08:46,250
fuzzers essentially take some seat and

00:08:42,740 --> 00:08:50,160
then have some idea about because

00:08:46,250 --> 00:08:52,740
College grammar or structure of

00:08:50,160 --> 00:08:55,050
of the file if you will and then tie

00:08:52,740 --> 00:08:58,050
with this structure flip the bits from

00:08:55,050 --> 00:09:02,370
one side put some things in other

00:08:58,050 --> 00:09:07,340
section and from the program by design

00:09:02,370 --> 00:09:09,930
most of them do not do not take that

00:09:07,340 --> 00:09:14,580
don't take the feedback from your

00:09:09,930 --> 00:09:17,070
program and from the other side this

00:09:14,580 --> 00:09:20,250
feedback thing is something that is used

00:09:17,070 --> 00:09:22,670
commonly in evolutionary fastener so

00:09:20,250 --> 00:09:25,590
evolutionary father is the father that

00:09:22,670 --> 00:09:27,570
integrate many times and observe the

00:09:25,590 --> 00:09:30,090
behavior of the program so the simplest

00:09:27,570 --> 00:09:33,590
think about the simplest way to think

00:09:30,090 --> 00:09:36,300
about this is you can have some feedback

00:09:33,590 --> 00:09:38,460
coming from your program which for

00:09:36,300 --> 00:09:41,550
example can be execution time so if you

00:09:38,460 --> 00:09:44,070
know that this thousands of bites of all

00:09:41,550 --> 00:09:46,440
zeros execute for example for one second

00:09:44,070 --> 00:09:48,630
and then if you flip one byte somewhere

00:09:46,440 --> 00:09:51,150
and then your program will execute this

00:09:48,630 --> 00:09:54,630
input for ten seconds that means maybe

00:09:51,150 --> 00:09:57,090
this one bit really does matter and move

00:09:54,630 --> 00:09:59,130
your input to some other execution path

00:09:57,090 --> 00:10:02,510
so then maybe this is something that you

00:09:59,130 --> 00:10:05,180
should consider the Rinker phasing and

00:10:02,510 --> 00:10:08,070
over the time I will create another

00:10:05,180 --> 00:10:12,990
generations of those inputs and also we

00:10:08,070 --> 00:10:16,620
take we take the we take the feedback

00:10:12,990 --> 00:10:20,720
after every generation so this is also

00:10:16,620 --> 00:10:23,310
the way how American fuzzy loop works

00:10:20,720 --> 00:10:25,980
someone may argue American father also

00:10:23,310 --> 00:10:27,690
is doing some mutational of the state

00:10:25,980 --> 00:10:30,570
and that was also correct

00:10:27,690 --> 00:10:33,810
because today's software mostly is very

00:10:30,570 --> 00:10:35,940
complicated so it's not just one or

00:10:33,810 --> 00:10:46,880
another one but you combine those

00:10:35,940 --> 00:10:49,230
approaches so as I said I FL is AFL is

00:10:46,880 --> 00:10:53,790
evolutionary father which take our

00:10:49,230 --> 00:10:55,470
coverage as as a feedback so we have a

00:10:53,790 --> 00:11:00,510
feedback loop based on their coverage of

00:10:55,470 --> 00:11:00,950
the code so I FL use the map or array of

00:11:00,510 --> 00:11:04,280
the

00:11:00,950 --> 00:11:05,570
source and destination branches and so

00:11:04,280 --> 00:11:07,430
the way how it was originally

00:11:05,570 --> 00:11:10,940
implemented when you compile your

00:11:07,430 --> 00:11:13,670
program you comply with specific FL

00:11:10,940 --> 00:11:16,000
compiler dis compiler to some custom

00:11:13,670 --> 00:11:19,310
instrumentation so it put additional

00:11:16,000 --> 00:11:21,860
instructions on every branch in your

00:11:19,310 --> 00:11:25,460
program so then while you're executing

00:11:21,860 --> 00:11:27,860
you have some short memory and inside

00:11:25,460 --> 00:11:29,480
this short memory every time when you

00:11:27,860 --> 00:11:32,300
hit the branch you have couple of

00:11:29,480 --> 00:11:34,730
instructions which see which see the

00:11:32,300 --> 00:11:38,150
source branch and destination branch so

00:11:34,730 --> 00:11:42,110
we get this pair and he put this pair to

00:11:38,150 --> 00:11:45,650
the array and because of that the father

00:11:42,110 --> 00:11:48,860
gets a hint okay so we saw already saw

00:11:45,650 --> 00:11:51,110
already this path in the execution graph

00:11:48,860 --> 00:11:53,600
so this path already was covered or

00:11:51,110 --> 00:11:56,090
maybe this path wasn't cover and I can

00:11:53,600 --> 00:11:59,560
take this as a hint as my feedback to

00:11:56,090 --> 00:12:03,410
create another to create another

00:11:59,560 --> 00:12:05,200
generation of the input from the other

00:12:03,410 --> 00:12:10,370
side in ldsd

00:12:05,200 --> 00:12:13,850
8 we had takeoff coverage device which

00:12:10,370 --> 00:12:17,420
provides us a PC trace program counter

00:12:13,850 --> 00:12:20,690
trace and comparation trace so the way

00:12:17,420 --> 00:12:23,270
how PC trace work you run your process

00:12:20,690 --> 00:12:25,790
and then inside the kernel we also have

00:12:23,270 --> 00:12:28,160
instrumentation which are done during

00:12:25,790 --> 00:12:31,360
the computation so you have to compile

00:12:28,160 --> 00:12:34,550
your and it be the kernel I have with

00:12:31,360 --> 00:12:38,300
option in order to escape of you cannot

00:12:34,550 --> 00:12:41,030
get it as normal image and run cooperate

00:12:38,300 --> 00:12:43,310
on it you need to recompile it and so

00:12:41,030 --> 00:12:47,480
it's very simple you just go to the

00:12:43,310 --> 00:12:50,000
config and you enable click off and it

00:12:47,480 --> 00:12:51,800
should work so then you have done every

00:12:50,000 --> 00:12:55,580
time when you execute the kernel code

00:12:51,800 --> 00:12:57,710
for specific process you can collect the

00:12:55,580 --> 00:12:59,630
coverage data inside the buffer which is

00:12:57,710 --> 00:13:02,840
inside the kernel space and then the

00:12:59,630 --> 00:13:05,210
buffer also s map or can be marked

00:13:02,840 --> 00:13:07,010
because you don't have to do it but this

00:13:05,210 --> 00:13:09,320
is usually your case if you are doing a

00:13:07,010 --> 00:13:12,490
passing as of this buffer then is mapped

00:13:09,320 --> 00:13:16,740
to the user space by n map I

00:13:12,490 --> 00:13:20,740
and you can see I had the coverage data

00:13:16,740 --> 00:13:25,899
so in order to make American fuzzy loop

00:13:20,740 --> 00:13:31,480
works on my PhD with cake off I needed

00:13:25,899 --> 00:13:34,959
to fix a little bit this tracing so as I

00:13:31,480 --> 00:13:38,890
said we had the at least long list of

00:13:34,959 --> 00:13:41,050
the addresses in the kernel space and we

00:13:38,890 --> 00:13:44,230
need to come I needed to convert it to

00:13:41,050 --> 00:13:49,510
get the different to essentially create

00:13:44,230 --> 00:13:52,000
the 64k buffer for the fuzzing and so

00:13:49,510 --> 00:13:54,550
this conversion is very simple you just

00:13:52,000 --> 00:13:59,020
go for the whole list and you see the

00:13:54,550 --> 00:14:01,420
current PC counter and the previous one

00:13:59,020 --> 00:14:03,279
and then you do the XOR on them of

00:14:01,420 --> 00:14:06,610
course we also have to make sure that

00:14:03,279 --> 00:14:11,800
you are in line in the size of your

00:14:06,610 --> 00:14:14,050
array and that's mostly but we had some

00:14:11,800 --> 00:14:17,579
discussion how to do this properly so

00:14:14,050 --> 00:14:21,279
the first idea was okay so let's live

00:14:17,579 --> 00:14:24,040
coverage device at Isis and do the

00:14:21,279 --> 00:14:26,380
conversion on the user space side which

00:14:24,040 --> 00:14:30,070
end up that is not a very good idea

00:14:26,380 --> 00:14:33,190
because net bsd kernel is a little bit

00:14:30,070 --> 00:14:38,350
more verbose that we expected so your

00:14:33,190 --> 00:14:40,630
cause of your trace can be like multiple

00:14:38,350 --> 00:14:42,100
thousands of entries and doing the work

00:14:40,630 --> 00:14:45,220
first of all inside the kernel

00:14:42,100 --> 00:14:48,550
collecting and then doing conversion in

00:14:45,220 --> 00:14:51,100
the user space doesn't really work well

00:14:48,550 --> 00:14:53,589
because you are going for the same list

00:14:51,100 --> 00:14:58,020
twice and inside the fuzzing with the

00:14:53,589 --> 00:15:03,550
performance is really important and so I

00:14:58,020 --> 00:15:05,410
decided to do this inside the kernel to

00:15:03,550 --> 00:15:09,190
do this inside the kernel as a kind of

00:15:05,410 --> 00:15:12,130
like a addition to the cake of other

00:15:09,190 --> 00:15:14,829
things that American fuzzy loop require

00:15:12,130 --> 00:15:17,709
was changed simple things like changing

00:15:14,829 --> 00:15:20,740
the shark memory to the end map for the

00:15:17,709 --> 00:15:25,300
for the coverage device opening the

00:15:20,740 --> 00:15:27,750
files so not much here in the user space

00:15:25,300 --> 00:15:27,750
to change

00:15:30,189 --> 00:15:39,470
but as I said because I put ASL inside

00:15:34,850 --> 00:15:43,720
the internal space we were talking a

00:15:39,470 --> 00:15:47,389
little bit how to do this properly and

00:15:43,720 --> 00:15:50,749
there was some work for example done in

00:15:47,389 --> 00:15:54,740
Linux where people decided to provide

00:15:50,749 --> 00:15:58,670
additional trace type which will be IFL

00:15:54,740 --> 00:16:01,369
as in order to handle this correctly

00:15:58,670 --> 00:16:04,009
which is not ideal because I fell it's

00:16:01,369 --> 00:16:05,869
not really that tracing format it's more

00:16:04,009 --> 00:16:10,939
like the standard standard for the

00:16:05,869 --> 00:16:14,509
program so in order to handle this we

00:16:10,939 --> 00:16:18,790
modify the cake of device so there is

00:16:14,509 --> 00:16:21,619
there would be some changes coming soon

00:16:18,790 --> 00:16:24,619
where the module where you can have your

00:16:21,619 --> 00:16:26,689
own the module for coverage so you can

00:16:24,619 --> 00:16:29,029
register your model for doing the

00:16:26,689 --> 00:16:32,119
coverage and this registration I require

00:16:29,029 --> 00:16:34,910
to fill that a structure so this

00:16:32,119 --> 00:16:37,879
structure essentially require you to

00:16:34,910 --> 00:16:39,559
provide open free operation it will have

00:16:37,879 --> 00:16:42,860
a hoops - coverages

00:16:39,559 --> 00:16:48,619
right now we have PC and cmp coverages

00:16:42,860 --> 00:16:53,299
have a in future and be more and after

00:16:48,619 --> 00:16:56,540
you register your plugin when you do

00:16:53,299 --> 00:16:58,639
anything from user space to coverage

00:16:56,540 --> 00:17:01,879
device you will be hitting those

00:16:58,639 --> 00:17:04,610
functions but from the other side you

00:17:01,879 --> 00:17:06,679
will still use the same code as okay

00:17:04,610 --> 00:17:09,740
cough device so we won't have

00:17:06,679 --> 00:17:12,679
duplication of the code and also will

00:17:09,740 --> 00:17:15,020
have one common code for dealing with

00:17:12,679 --> 00:17:17,949
the coverage which from my perspective

00:17:15,020 --> 00:17:17,949
really good thing

00:17:20,100 --> 00:17:28,079
so as I said generic type of module

00:17:24,620 --> 00:17:30,450
which move the responsibility of doing

00:17:28,079 --> 00:17:33,840
anything do processing anything with

00:17:30,450 --> 00:17:36,660
coverage data move it to the plugin we

00:17:33,840 --> 00:17:42,000
still handle the raw coverage inside the

00:17:36,660 --> 00:17:44,610
cake off data is easily accessible using

00:17:42,000 --> 00:17:47,130
the callbacks we can support potentially

00:17:44,610 --> 00:17:48,929
multiple different fuzzing for every

00:17:47,130 --> 00:17:51,179
father you just need to write your

00:17:48,929 --> 00:17:55,890
simple module which is usually just take

00:17:51,179 --> 00:17:58,590
a look for example a file module or like

00:17:55,890 --> 00:18:02,130
a sample module that's also was written

00:17:58,590 --> 00:18:05,130
and then you can see which operations

00:18:02,130 --> 00:18:07,410
essentially will be different from your

00:18:05,130 --> 00:18:10,410
and then you implement them and you it

00:18:07,410 --> 00:18:13,980
should be ready to go

00:18:10,410 --> 00:18:17,570
also we can do stuff like filtering the

00:18:13,980 --> 00:18:20,880
coverage data which is also important so

00:18:17,570 --> 00:18:24,059
the simple setup of the father I

00:18:20,880 --> 00:18:26,700
describe a little bit the sharp memory

00:18:24,059 --> 00:18:31,919
how it works and also take off so we

00:18:26,700 --> 00:18:34,380
have coverage device and plug-in so the

00:18:31,919 --> 00:18:38,010
whole setup is a require couple of more

00:18:34,380 --> 00:18:42,150
components so we need those wrapper for

00:18:38,010 --> 00:18:44,760
AFL so the proper itself is something

00:18:42,150 --> 00:18:47,429
that is specific to your type of fuzzing

00:18:44,760 --> 00:18:49,830
for instance in my interest

00:18:47,429 --> 00:18:52,980
there are file systems so I need some

00:18:49,830 --> 00:18:55,410
way to get my code executed inside the

00:18:52,980 --> 00:18:57,900
kernel inside the file system stack

00:18:55,410 --> 00:19:00,870
somehow so I need to get my router and

00:18:57,900 --> 00:19:03,900
right inside this wrapper some old

00:19:00,870 --> 00:19:06,360
operation I need also to prepare the

00:19:03,900 --> 00:19:09,919
blunt device but I won't have dog device

00:19:06,360 --> 00:19:12,690
straightaway so I need to get a file

00:19:09,919 --> 00:19:15,150
pretend that this file is a block device

00:19:12,690 --> 00:19:18,660
and then run amount on the block device

00:19:15,150 --> 00:19:20,460
and during that call I will collect the

00:19:18,660 --> 00:19:24,140
whole coverage data from the Siskel's

00:19:20,460 --> 00:19:28,830
from the FS from in core file system

00:19:24,140 --> 00:19:31,680
then translated to Eiffel and

00:19:28,830 --> 00:19:35,730
everything inside the memory the father

00:19:31,680 --> 00:19:38,760
itself although I will analyze this data

00:19:35,730 --> 00:19:42,870
and to do some modification create

00:19:38,760 --> 00:19:47,490
different different files that in

00:19:42,870 --> 00:19:48,930
different generations of the inputs the

00:19:47,490 --> 00:19:52,770
next thing that I found is really

00:19:48,930 --> 00:19:55,710
interesting in this project was I had to

00:19:52,770 --> 00:19:57,330
dis I had this set up and then My

00:19:55,710 --> 00:19:59,250
Starving okay so I would like to run

00:19:57,330 --> 00:20:03,480
some kind of hello world for fuzzing as

00:19:59,250 --> 00:20:05,250
I create some simple hello world for

00:20:03,480 --> 00:20:09,530
father which is usually which is

00:20:05,250 --> 00:20:11,910
something that is many different fuzzing

00:20:09,530 --> 00:20:13,830
tutorials that you can find online

00:20:11,910 --> 00:20:16,710
so it just bright you just hard code

00:20:13,830 --> 00:20:20,100
some magical pattern and then you get

00:20:16,710 --> 00:20:23,940
input from from your father and you are

00:20:20,100 --> 00:20:26,220
trying to break the magic and you see

00:20:23,940 --> 00:20:29,510
how of us it takes for example to break

00:20:26,220 --> 00:20:33,450
something like four five six characters

00:20:29,510 --> 00:20:36,330
magical password hard-coded password so

00:20:33,450 --> 00:20:38,820
I run this and it was running and

00:20:36,330 --> 00:20:40,230
running and after a week my father was

00:20:38,820 --> 00:20:44,420
still not able to break the magic

00:20:40,230 --> 00:20:47,820
password and they surgery okay so I know

00:20:44,420 --> 00:20:51,300
we usually think about the father I saw

00:20:47,820 --> 00:20:54,030
some kind of like a magic process that

00:20:51,300 --> 00:20:57,000
just take a program as a black box and

00:20:54,030 --> 00:20:59,520
execute on it but if you essentially

00:20:57,000 --> 00:21:02,070
would like to see what the data are

00:20:59,520 --> 00:21:05,400
visible for your for your father what

00:21:02,070 --> 00:21:08,700
you can do to first of all as I didn't

00:21:05,400 --> 00:21:12,140
debug it the process I get the list of

00:21:08,700 --> 00:21:14,850
the trace for my for my mount process I

00:21:12,140 --> 00:21:18,350
translated to their particular functions

00:21:14,850 --> 00:21:21,360
and then I wasn't able to find anything

00:21:18,350 --> 00:21:25,500
related to my code so just kind of

00:21:21,360 --> 00:21:28,740
surprising so then I get all of those

00:21:25,500 --> 00:21:31,890
traces and count unique entries for

00:21:28,740 --> 00:21:36,540
those traces what what we found was

00:21:31,890 --> 00:21:39,540
essentially we have first couple of

00:21:36,540 --> 00:21:42,059
hundred entries was usually the code the

00:21:39,540 --> 00:21:47,129
kernel code not related to our housing

00:21:42,059 --> 00:21:50,609
and as especially we had a lot of a lot

00:21:47,129 --> 00:21:55,109
of built on memory operations the page

00:21:50,609 --> 00:21:59,070
faults so there was about 20,000 entries

00:21:55,109 --> 00:22:02,219
and from them 1500 for example was

00:21:59,070 --> 00:22:05,999
related the page fault so my initial

00:22:02,219 --> 00:22:09,330
thought was hang on the moment because I

00:22:05,999 --> 00:22:10,469
am the way how AFL works it detects the

00:22:09,330 --> 00:22:13,559
part of the source and destination

00:22:10,469 --> 00:22:16,109
branch so in theory we should be able to

00:22:13,559 --> 00:22:20,249
see that okay so this is something that

00:22:16,109 --> 00:22:22,619
we see but this we already saw this

00:22:20,249 --> 00:22:25,799
execution branch because it is in the

00:22:22,619 --> 00:22:27,749
map but it turns out that you can have

00:22:25,799 --> 00:22:29,389
multiple different combination of those

00:22:27,749 --> 00:22:32,369
source destinations

00:22:29,389 --> 00:22:34,739
so essentially you are not facing the

00:22:32,369 --> 00:22:42,419
file system you're facing just built on

00:22:34,739 --> 00:22:43,489
memory subsystem so how how we can fix

00:22:42,419 --> 00:22:46,619
that

00:22:43,489 --> 00:22:49,979
first of all in English I can because

00:22:46,619 --> 00:22:52,379
the instrumentation our compiled time

00:22:49,979 --> 00:22:55,739
operation I can just go to every of

00:22:52,379 --> 00:22:59,190
those functions every couple thousand of

00:22:55,739 --> 00:23:01,559
them and change and remove them from the

00:22:59,190 --> 00:23:05,129
choice I can add no instrument function

00:23:01,559 --> 00:23:09,839
a keyboard from GCC and let's try this

00:23:05,129 --> 00:23:13,469
and turn out because at that time we

00:23:09,839 --> 00:23:16,080
still had GCC seven so this is seven for

00:23:13,469 --> 00:23:19,559
compiling the kernel and GCC seven does

00:23:16,080 --> 00:23:21,119
not it does have this keyboard but

00:23:19,559 --> 00:23:24,960
essentially this is not working for

00:23:21,119 --> 00:23:26,729
seven so in order to make it work I

00:23:24,960 --> 00:23:28,919
started compiling the kernel of GCC

00:23:26,729 --> 00:23:30,869
eight that was long story a lot of

00:23:28,919 --> 00:23:35,940
warnings I don't know if anyone compiled

00:23:30,869 --> 00:23:40,559
with g8 and the kernel not many people

00:23:35,940 --> 00:23:44,879
as but I realized maybe it will be

00:23:40,559 --> 00:23:48,419
easier to get to get those information

00:23:44,879 --> 00:23:50,879
in run time so we can so I create a

00:23:48,419 --> 00:23:54,070
black listing of those addresses so how

00:23:50,879 --> 00:23:56,200
its works you get your addresses for the

00:23:54,070 --> 00:24:01,660
that you would like to exclude from the

00:23:56,200 --> 00:24:04,800
phazon put them to the list and IFL have

00:24:01,660 --> 00:24:07,360
iocked own operation where you can put

00:24:04,800 --> 00:24:09,670
addresses to the list this list in the

00:24:07,360 --> 00:24:13,060
kernel space is sorted so finding the

00:24:09,670 --> 00:24:15,220
entry is not the big overhead still some

00:24:13,060 --> 00:24:17,470
operation which probably is better to do

00:24:15,220 --> 00:24:20,590
this as statically but from the other

00:24:17,470 --> 00:24:27,250
side I wanted also to keep going with my

00:24:20,590 --> 00:24:29,080
research and and then we have the filter

00:24:27,250 --> 00:24:31,570
which every time when you have a trace

00:24:29,080 --> 00:24:35,770
and you end up with the Butte on memory

00:24:31,570 --> 00:24:38,320
we just do not include this to your to

00:24:35,770 --> 00:24:42,640
your coverage data which reduce the

00:24:38,320 --> 00:24:45,160
space a lot so coming back to the

00:24:42,640 --> 00:24:47,140
coverage benchmark so that's the

00:24:45,160 --> 00:24:50,880
coverage benchmark we have six

00:24:47,140 --> 00:24:52,650
characters that our user need I need to

00:24:50,880 --> 00:24:58,540
need to guess

00:24:52,650 --> 00:25:02,770
I call it panic lottery so before some

00:24:58,540 --> 00:25:04,330
small reminder those are really really

00:25:02,770 --> 00:25:06,580
approximate numbers

00:25:04,330 --> 00:25:08,320
you shouldn't code them anywhere which

00:25:06,580 --> 00:25:11,500
was the way how I was playing with the

00:25:08,320 --> 00:25:15,370
father but at the very beginning I run

00:25:11,500 --> 00:25:18,880
my process to just cuss this input for

00:25:15,370 --> 00:25:21,220
two weeks and it was not able to it

00:25:18,880 --> 00:25:23,860
wasn't able to win the panic lottery

00:25:21,220 --> 00:25:27,870
after applying the filtering I was able

00:25:23,860 --> 00:25:33,730
to fix that in less than 24 hours and

00:25:27,870 --> 00:25:36,070
also I used the same seed input so it

00:25:33,730 --> 00:25:38,320
makes sure also that because sometimes

00:25:36,070 --> 00:25:41,560
the fuzzing can also be tricky depends

00:25:38,320 --> 00:25:45,220
what are your input data what your

00:25:41,560 --> 00:25:48,070
material can starting condition so I

00:25:45,220 --> 00:25:50,320
make sure that this is this is the

00:25:48,070 --> 00:25:52,150
father see the same thing so I run this

00:25:50,320 --> 00:25:54,580
on the view on machine I get the

00:25:52,150 --> 00:25:58,090
snapshot and from the second one with

00:25:54,580 --> 00:26:00,790
that second one with the filtering

00:25:58,090 --> 00:26:03,550
enable if you do something similar in

00:26:00,790 --> 00:26:05,270
userspace this is something that every

00:26:03,550 --> 00:26:08,150
how to do

00:26:05,270 --> 00:26:12,770
IFL thousand monologuing internet is

00:26:08,150 --> 00:26:14,710
doing us a thirst and of first slide you

00:26:12,770 --> 00:26:19,250
will be able to break this in

00:26:14,710 --> 00:26:22,550
approximately couple of hours so the

00:26:19,250 --> 00:26:26,170
next thing is I spoke about the coverage

00:26:22,550 --> 00:26:30,680
so in order to something step will be to

00:26:26,170 --> 00:26:33,920
provide the proper so for my case I need

00:26:30,680 --> 00:26:38,690
to I wanted to file it for example ffs

00:26:33,920 --> 00:26:42,200
file system so we need first of all to

00:26:38,690 --> 00:26:45,560
make sure that we set up our process for

00:26:42,200 --> 00:26:49,370
phasing and we'll be executing the same

00:26:45,560 --> 00:26:52,160
and we'll be executing the correct part

00:26:49,370 --> 00:26:54,290
of the kernel code so in this case we

00:26:52,160 --> 00:26:58,910
are focusing about the mount but mount

00:26:54,290 --> 00:27:01,250
came also with we need a device that can

00:26:58,910 --> 00:27:03,110
be mounted also it needs to do the

00:27:01,250 --> 00:27:05,300
preparation you need to do the cleaning

00:27:03,110 --> 00:27:08,600
so the good way is to start with bash

00:27:05,300 --> 00:27:10,010
and then move to the sea or you don't

00:27:08,600 --> 00:27:12,230
have to move all this to this you can

00:27:10,010 --> 00:27:14,930
see pass pass rust and anything that

00:27:12,230 --> 00:27:18,440
provides you good performance but the

00:27:14,930 --> 00:27:21,140
reminder here is performance is the key

00:27:18,440 --> 00:27:24,980
for the fuzzing so do not use the bash

00:27:21,140 --> 00:27:29,300
script as a mounter as I do not use the

00:27:24,980 --> 00:27:31,400
bash script as part of your fuzzing loop

00:27:29,300 --> 00:27:34,100
because that will slow down the process

00:27:31,400 --> 00:27:36,710
a lot and the phasing of the kernel is

00:27:34,100 --> 00:27:39,020
already slow because you because of the

00:27:36,710 --> 00:27:41,960
way how the communication with the

00:27:39,020 --> 00:27:45,050
kernel works so make sure that you get

00:27:41,960 --> 00:27:49,490
everything from your mount cradle from

00:27:45,050 --> 00:27:52,490
your mount code and try to be as close

00:27:49,490 --> 00:27:55,840
to royalty skulls because the

00:27:52,490 --> 00:28:01,360
performance is very crucial

00:27:55,840 --> 00:28:05,570
ok so let's then do the local setup so

00:28:01,360 --> 00:28:09,050
we have already our wrapper will create

00:28:05,570 --> 00:28:14,510
that will create the file in this case

00:28:09,050 --> 00:28:16,700
to be ATK of size V in the config to

00:28:14,510 --> 00:28:20,450
create it

00:28:16,700 --> 00:28:24,059
as a to creating a certain blog device

00:28:20,450 --> 00:28:27,419
then create the new file system on it

00:28:24,059 --> 00:28:30,600
someone may ask why you don't just leave

00:28:27,419 --> 00:28:32,640
your father to guess the structure of

00:28:30,600 --> 00:28:35,669
the file system but you already give it

00:28:32,640 --> 00:28:38,250
as a hint that this is the structure of

00:28:35,669 --> 00:28:41,130
the file system you can also you can

00:28:38,250 --> 00:28:44,760
also get just zeros and then run your

00:28:41,130 --> 00:28:46,590
father on with just as euros but that's

00:28:44,760 --> 00:28:49,860
what that will take some time for your

00:28:46,590 --> 00:28:53,220
father to guess and also in I was

00:28:49,860 --> 00:28:57,240
working on this blacklisting so I was

00:28:53,220 --> 00:28:59,940
thinking it's probably a good idea it's

00:28:57,240 --> 00:29:04,289
probably a good idea to have your father

00:28:59,940 --> 00:29:08,130
works on already preppy part set of the

00:29:04,289 --> 00:29:11,039
data and then you can just run your

00:29:08,130 --> 00:29:14,400
father you can then just run your father

00:29:11,039 --> 00:29:16,919
with care - case which this is also

00:29:14,400 --> 00:29:19,860
something new and you need to provide

00:29:16,919 --> 00:29:21,780
the amount script be careful with this

00:29:19,860 --> 00:29:23,970
because essentially you're just fuzzing

00:29:21,780 --> 00:29:25,770
the binary that you're running on so do

00:29:23,970 --> 00:29:30,630
not cut the branch that you were sitting

00:29:25,770 --> 00:29:33,090
off and every time when I talk about

00:29:30,630 --> 00:29:36,630
this people ask me how many bags did

00:29:33,090 --> 00:29:40,350
found how how many kernel crushes are

00:29:36,630 --> 00:29:43,799
you able to report and so let's do

00:29:40,350 --> 00:29:48,690
something very simple to also inst so

00:29:43,799 --> 00:29:50,610
people that we are not only finding the

00:29:48,690 --> 00:29:52,910
kernel crushes and so here I have my

00:29:50,610 --> 00:29:56,219
director with the father

00:29:52,910 --> 00:29:56,219
[Music]

00:29:59,870 --> 00:30:10,890
so let's surround this scripted the same

00:30:04,710 --> 00:30:13,830
thing around the fuzziness no 90

00:30:10,890 --> 00:30:14,460
operation per second bomb and something

00:30:13,830 --> 00:30:16,560
went wrong

00:30:14,460 --> 00:30:18,960
and so this actually is not something

00:30:16,560 --> 00:30:22,410
that is wrong in our script but this is

00:30:18,960 --> 00:30:24,480
actually the bug inside the Paranal so

00:30:22,410 --> 00:30:30,270
it's happening we are doing the Mount

00:30:24,480 --> 00:30:34,680
I have algebra small time but we are

00:30:30,270 --> 00:30:41,550
doing the mount on /mnt one and we can

00:30:34,680 --> 00:30:43,350
see so we have MNT one is in the kernel

00:30:41,550 --> 00:30:45,920
that if we will try to do any operation

00:30:43,350 --> 00:30:49,760
now after mounting uncorrupted value

00:30:45,920 --> 00:30:53,520
there is no file stop

00:30:49,760 --> 00:30:58,280
91 which also doesn't for it also don't

00:30:53,520 --> 00:31:02,490
work so during my passing the filesystem

00:30:58,280 --> 00:31:05,790
I also find some kind of like a logical

00:31:02,490 --> 00:31:07,710
box so this for example is not this is

00:31:05,790 --> 00:31:10,610
not a simple crash that you may expect

00:31:07,710 --> 00:31:12,810
from the car from the fuzzing the kernel

00:31:10,610 --> 00:31:15,840
but this is also something that you may

00:31:12,810 --> 00:31:21,870
find that there are some logical bugs

00:31:15,840 --> 00:31:25,560
which also will be nice to handle ok so

00:31:21,870 --> 00:31:29,640
I will probably skip the conclusions

00:31:25,560 --> 00:31:32,130
because 10 minutes some resources so we

00:31:29,640 --> 00:31:36,540
have a net BSD block it's really good

00:31:32,130 --> 00:31:38,670
place to find your to fight to find some

00:31:36,540 --> 00:31:41,640
information what we are doing inside the

00:31:38,670 --> 00:31:45,330
kernel for the QV and there are also two

00:31:41,640 --> 00:31:49,830
posts that I that we provided about the

00:31:45,330 --> 00:31:56,400
fuzzing with evil mmm I would like then

00:31:49,830 --> 00:32:02,910
to move to another slide deck and figure

00:31:56,400 --> 00:32:04,800
out from cameo and ok so this came from

00:32:02,910 --> 00:32:10,120
Cameo and fortunately wasn't able to

00:32:04,800 --> 00:32:12,730
join us today but give also some other

00:32:10,120 --> 00:32:17,350
some other things that are done for QE

00:32:12,730 --> 00:32:20,140
as I said earlier we have a center which

00:32:17,350 --> 00:32:24,460
is really important thing for quality in

00:32:20,140 --> 00:32:26,830
the kernel which essentially is your mm

00:32:24,460 --> 00:32:29,550
is your starting point if you are trying

00:32:26,830 --> 00:32:32,830
to do the phasing of the user space

00:32:29,550 --> 00:32:35,080
because if you are if we will try to

00:32:32,830 --> 00:32:37,930
compile everything with different

00:32:35,080 --> 00:32:43,120
sanitizers is almost impossible I was

00:32:37,930 --> 00:32:45,220
trying to compile FSDB and it's really

00:32:43,120 --> 00:32:49,000
hard so NP st. Arthur is really

00:32:45,220 --> 00:32:56,440
important and current is covering about

00:32:49,000 --> 00:32:59,470
95% of things that we have in in user

00:32:56,440 --> 00:33:01,230
space there's still a lot of there's

00:32:59,470 --> 00:33:04,780
still a lot of issues over there so

00:33:01,230 --> 00:33:08,800
you're more than welcome to help with

00:33:04,780 --> 00:33:10,750
that and so enticing Kaiser's

00:33:08,800 --> 00:33:12,940
essentially provides your way to use

00:33:10,750 --> 00:33:15,610
other sanitizers and compile everything

00:33:12,940 --> 00:33:18,220
with the same settings so you can have

00:33:15,610 --> 00:33:21,310
address integer and undefined behavior

00:33:18,220 --> 00:33:24,180
scientists read sanitizers member

00:33:21,310 --> 00:33:27,240
sensors Ehrlich's ionizers and

00:33:24,180 --> 00:33:30,130
additionally we also have the father

00:33:27,240 --> 00:33:34,690
stuck hard during x-ray which is also

00:33:30,130 --> 00:33:37,650
coming in the future yes I already said

00:33:34,690 --> 00:33:42,700
I'm a scientist already works and

00:33:37,650 --> 00:33:47,700
possible 95% of upstream tests 100

00:33:42,700 --> 00:33:47,700
hundred issues still to fail to be fixed

00:33:50,420 --> 00:33:55,520
okay so then you can also take a look

00:33:53,240 --> 00:33:58,190
about the files in their parallel code

00:33:55,520 --> 00:34:03,320
inside user space so this is the round

00:33:58,190 --> 00:34:07,670
kernel fuzzing here people also use the

00:34:03,320 --> 00:34:09,800
hang-hang class and together with from

00:34:07,670 --> 00:34:15,340
kernel and so this is the way how you

00:34:09,800 --> 00:34:17,870
build any sanitizer nothing special here

00:34:15,340 --> 00:34:20,510
you installed the home food come first

00:34:17,870 --> 00:34:23,090
is a little bit more complicated project

00:34:20,510 --> 00:34:24,980
than something that they just shows you

00:34:23,090 --> 00:34:27,590
in the terminal so we need to spend a

00:34:24,980 --> 00:34:30,470
little bit more time at configure it

00:34:27,590 --> 00:34:33,280
properly and I need to do in the mount

00:34:30,470 --> 00:34:38,149
for different subsystems for the ramp

00:34:33,280 --> 00:34:39,860
change the route then you also for run

00:34:38,149 --> 00:34:43,250
colonel you also need kind of the

00:34:39,860 --> 00:34:46,070
wrapper because around karna is also is

00:34:43,250 --> 00:34:49,720
your space library so us

00:34:46,070 --> 00:34:53,110
I used the wrapper for using for just

00:34:49,720 --> 00:34:58,630
pausing the Carlo is something similar

00:34:53,110 --> 00:35:02,950
for the ROM starting the home for father

00:34:58,630 --> 00:35:07,280
with some friend educated corpuses and

00:35:02,950 --> 00:35:10,700
then serve the trusses so 16 minutes

00:35:07,280 --> 00:35:13,490
after starting the fuzzing we got the

00:35:10,700 --> 00:35:16,910
external crash for the also for the

00:35:13,490 --> 00:35:19,340
month so this is so this is also fuzzing

00:35:16,910 --> 00:35:21,230
the amount but not inside your kernel

00:35:19,340 --> 00:35:25,430
but actually inside a ROM which is

00:35:21,230 --> 00:35:29,480
running in your user space so we need to

00:35:25,430 --> 00:35:31,720
go for a lot of travel a lot of logs

00:35:29,480 --> 00:35:37,430
like for example found this a little bit

00:35:31,720 --> 00:35:42,860
shrieking and but this is doable I can

00:35:37,430 --> 00:35:45,380
be improved a little bit but this was I

00:35:42,860 --> 00:35:49,820
think this was reported couple weeks ago

00:35:45,380 --> 00:35:52,580
so you have the we have essentially Auto

00:35:49,820 --> 00:35:55,760
out-of-band for

00:35:52,580 --> 00:36:00,350
very early mesh and after we found her

00:35:55,760 --> 00:36:02,480
back in fix the back you repeat and we

00:36:00,350 --> 00:36:09,200
found another back and this is how we

00:36:02,480 --> 00:36:13,670
prove the quality so Colonel sanitizers

00:36:09,200 --> 00:36:19,940
already covered up there so undefined

00:36:13,670 --> 00:36:22,270
behavior run alone all ports terminal

00:36:19,940 --> 00:36:25,130
calif is kind of very our special

00:36:22,270 --> 00:36:27,100
assignment i sirs there are still a

00:36:25,130 --> 00:36:30,590
couple of things that are not merged yet

00:36:27,100 --> 00:36:32,510
for some place out maxime running thread

00:36:30,590 --> 00:36:39,320
sanitizers and bother already to be able

00:36:32,510 --> 00:36:43,010
to catch thirst back using bit so the

00:36:39,320 --> 00:36:47,110
project that is so second one of my

00:36:43,010 --> 00:36:51,140
first slide sis color so this color was

00:36:47,110 --> 00:36:53,810
run by she died

00:36:51,140 --> 00:36:56,810
goggles google Summer of Code you can

00:36:53,810 --> 00:37:03,890
also read on our mid BSD blog about it

00:36:56,810 --> 00:37:07,400
so currently also was improved improved

00:37:03,890 --> 00:37:09,620
by the Damier from Google and I said he

00:37:07,400 --> 00:37:14,360
started finding some process and this is

00:37:09,620 --> 00:37:16,790
running 24/7 and I mean some fathom for

00:37:14,360 --> 00:37:22,100
Colonel another interesting project

00:37:16,790 --> 00:37:24,380
three folders I fell done by uncle and I

00:37:22,100 --> 00:37:26,210
was a part of Google summer code so he

00:37:24,380 --> 00:37:29,930
was also able to find a lot of

00:37:26,210 --> 00:37:31,790
interesting bugs also using sign and

00:37:29,930 --> 00:37:34,070
sanitizers most of them were already

00:37:31,790 --> 00:37:39,890
fixed but also we can read about them on

00:37:34,070 --> 00:37:45,020
our dog under interesting thing done by

00:37:39,890 --> 00:37:47,960
Maxine there was some some USB device so

00:37:45,020 --> 00:37:49,550
currently Maxim came with some episode

00:37:47,960 --> 00:37:52,370
the device software device that is able

00:37:49,550 --> 00:37:55,970
to just inject the packets to the USB

00:37:52,370 --> 00:37:58,910
stack so they can you have some idea to

00:37:55,970 --> 00:38:02,850
connect the father to this device and

00:37:58,910 --> 00:38:09,640
then start fighting the USB stack

00:38:02,850 --> 00:38:18,970
and as improvements instruments of

00:38:09,640 --> 00:38:20,410
utilization so then excite better in

00:38:18,970 --> 00:38:22,810
induction for everyone

00:38:20,410 --> 00:38:26,110
validator Colonel Kotov sanitizers so

00:38:22,810 --> 00:38:29,860
right now we have a lot of good tools in

00:38:26,110 --> 00:38:32,290
that VSD we have a lot of progress with

00:38:29,860 --> 00:38:34,930
sanitizers so if you are doing the

00:38:32,290 --> 00:38:39,070
fuzzing into the thousand plus sign

00:38:34,930 --> 00:38:42,100
phasing yeah and there are still a lot

00:38:39,070 --> 00:38:45,040
of things that we need to improve in the

00:38:42,100 --> 00:38:48,090
future but slowly but surely we are

00:38:45,040 --> 00:38:51,220
progressing yeah

00:38:48,090 --> 00:38:56,320
so I already cover all of those yeah so

00:38:51,220 --> 00:38:59,460
that's all they have for today so do you

00:38:56,320 --> 00:38:59,460
have any thanks for the questions

00:39:01,210 --> 00:39:14,370
[Applause]

00:39:04,290 --> 00:39:14,370
who has a question stop being shy

00:39:17,610 --> 00:39:21,120
do you think you guys

00:39:28,420 --> 00:39:30,480

YouTube URL: https://www.youtube.com/watch?v=bbNCqFdQEyk


