Title: 23 years of software side channel attacks by Dr. Colin Percival
Publication date: 2019-10-27
Playlist: EuroBSDCon 2019, Norway
Description: 
	23 years of software side channel attacks

I will present a historical review of software side channel attacks, from Paul Kocherâ€™s 1996 timing attacks against asymmetric cryptography to the latest microarchitectural vulnerabilities. While there have been too many attacks discovered to spend time describing every one, I will highlight attacks which were particularly novel or influential, explaining both the history of how attacks build on earlier work and some of the reasons behind the decisions which led to these attacks being possible.

No knowledge of cryptography will be assumed, but the audience may benefit from a basic understanding of CPU architecture (instructions, pipelining, caches, etc).

More Info:
https://2019.eurobsdcon.org/talk-speakers/#side
Captions: 
	00:00:03,980 --> 00:00:08,420
please welcome : Percival he'll be

00:00:06,229 --> 00:00:11,049
talking about 23 years of software side

00:00:08,420 --> 00:00:11,049
channel tax

00:00:15,840 --> 00:00:19,869
okay

00:00:17,349 --> 00:00:22,329
this is my first time speaking at Europe

00:00:19,869 --> 00:00:24,640
ESD con but it's been a while since I

00:00:22,329 --> 00:00:25,680
was last year so for those of you who

00:00:24,640 --> 00:00:29,219
don't know me

00:00:25,680 --> 00:00:32,079
I've been phoebe steve alford since 2004

00:00:29,219 --> 00:00:34,379
my first major contributions to FreeBSD

00:00:32,079 --> 00:00:37,360
you were FreeBSD update and port snap

00:00:34,379 --> 00:00:40,510
these days my main contribution is

00:00:37,360 --> 00:00:43,000
maintaining the FreeBSD ec2 platform so

00:00:40,510 --> 00:00:45,190
when Amazon changes things which they do

00:00:43,000 --> 00:00:47,289
on a fairly frequent basis I make sure

00:00:45,190 --> 00:00:51,069
that newer versions of FreeBSD will

00:00:47,289 --> 00:00:54,219
support new devices new features and so

00:00:51,069 --> 00:00:57,550
on I spent seven years as FreeBSD

00:00:54,219 --> 00:01:02,850
security officer and relevant to this

00:00:57,550 --> 00:01:04,870
talk I am an occasional cryptographer

00:01:02,850 --> 00:01:10,630
you'll see later on some of the work I

00:01:04,870 --> 00:01:14,080
did but also s script in 2009 is a key

00:01:10,630 --> 00:01:16,870
derivation function my day job is as the

00:01:14,080 --> 00:01:19,410
author of car snap this actually came

00:01:16,870 --> 00:01:22,150
out of my work on FreeBSD I was

00:01:19,410 --> 00:01:23,680
concerned as foo BSD security officer

00:01:22,150 --> 00:01:26,260
that I had a lot of very sensitive

00:01:23,680 --> 00:01:28,420
information on my laptop and if somebody

00:01:26,260 --> 00:01:30,610
got access to my backups they might find

00:01:28,420 --> 00:01:32,980
out about a large number of remote

00:01:30,610 --> 00:01:37,690
volatilities that we were in the process

00:01:32,980 --> 00:01:39,070
of fixing I couldn't find any good

00:01:37,690 --> 00:01:41,980
solution for backups so I decided to

00:01:39,070 --> 00:01:45,990
make my own and toss that is my day job

00:01:41,980 --> 00:01:48,190
and it's what paying for me to be here

00:01:45,990 --> 00:01:52,780
so I'm going to talk about software side

00:01:48,190 --> 00:01:56,200
channel tax so just so you have some

00:01:52,780 --> 00:01:58,780
idea what I'm talking about here black

00:01:56,200 --> 00:02:02,170
boxes we think of code is being a black

00:01:58,780 --> 00:02:06,280
box inputs go in something happens and

00:02:02,170 --> 00:02:09,039
then output comes out but in fact these

00:02:06,280 --> 00:02:10,750
black boxes are not very black

00:02:09,039 --> 00:02:12,819
they leak information via

00:02:10,750 --> 00:02:15,610
electromagnetic radiation they leak

00:02:12,819 --> 00:02:18,400
information by power consumption sound

00:02:15,610 --> 00:02:22,650
is actually more of an issue than you

00:02:18,400 --> 00:02:24,849
might think sound

00:02:22,650 --> 00:02:28,480
depending on how much power a system is

00:02:24,849 --> 00:02:31,689
using it will heat up and as things heat

00:02:28,480 --> 00:02:33,609
up they expand you can actually hear the

00:02:31,689 --> 00:02:37,109
the power consumption of devices as well

00:02:33,609 --> 00:02:39,670
as measuring it over the wire

00:02:37,109 --> 00:02:41,260
also of course information comes in

00:02:39,670 --> 00:02:43,269
something happens in information comes

00:02:41,260 --> 00:02:46,989
out but how long it takes before that

00:02:43,269 --> 00:02:49,569
comes out reveals information and then

00:02:46,989 --> 00:02:53,230
in some cases these black boxes have

00:02:49,569 --> 00:02:55,599
internal stage and you might not leak

00:02:53,230 --> 00:02:57,220
information during the process of

00:02:55,599 --> 00:02:59,889
performing operation but you might be

00:02:57,220 --> 00:03:03,310
able to extract it later on to another

00:02:59,889 --> 00:03:04,900
operation if you're leaking information

00:03:03,310 --> 00:03:07,439
deliberately we call this a covert

00:03:04,900 --> 00:03:09,700
channel this is development in

00:03:07,439 --> 00:03:15,389
situations like Mansoori access control

00:03:09,700 --> 00:03:17,829
so think nineteen seventy's CIA has

00:03:15,389 --> 00:03:19,150
shared computers which some people with

00:03:17,829 --> 00:03:21,250
top-secret clearance have and some

00:03:19,150 --> 00:03:22,689
people with lower clearance have you

00:03:21,250 --> 00:03:24,730
ought to make sure that the people with

00:03:22,689 --> 00:03:26,739
top-secret clearance cannot deliberately

00:03:24,730 --> 00:03:28,690
leaked information to the people with

00:03:26,739 --> 00:03:29,949
lower clearance because the people with

00:03:28,690 --> 00:03:31,299
lower clearance aren't going to be

00:03:29,949 --> 00:03:35,709
searched when they walk out the door

00:03:31,299 --> 00:03:37,479
with it but relevant to this talk if

00:03:35,709 --> 00:03:41,590
you're leaking information accidentally

00:03:37,479 --> 00:03:44,109
then that's a side channel software side

00:03:41,590 --> 00:03:46,030
channels what I mean here is simply

00:03:44,109 --> 00:03:47,769
those that you don't need any special

00:03:46,030 --> 00:03:50,949
hardware or physical access to exploit

00:03:47,769 --> 00:03:52,299
so if you're looking at something over

00:03:50,949 --> 00:03:54,599
the Internet you won't be able to

00:03:52,299 --> 00:03:57,400
measure electronic magnetic radiation

00:03:54,599 --> 00:04:01,329
power consumption at least not with the

00:03:57,400 --> 00:04:02,709
granule granularity is that you need but

00:04:01,329 --> 00:04:05,650
you can measure how long an operation

00:04:02,709 --> 00:04:11,079
takes and in some cases internal stage

00:04:05,650 --> 00:04:12,639
may leak at a later point and if you can

00:04:11,079 --> 00:04:14,109
get anything that we care about through

00:04:12,639 --> 00:04:18,310
a side channel when we say you have a

00:04:14,109 --> 00:04:19,630
side channel of hack typically when when

00:04:18,310 --> 00:04:21,340
we're looking at leaking secrets through

00:04:19,630 --> 00:04:24,130
side channels were talking about

00:04:21,340 --> 00:04:27,330
cryptographic secrets there's two

00:04:24,130 --> 00:04:29,680
reasons first first historically

00:04:27,330 --> 00:04:31,510
information that was being dealt with

00:04:29,680 --> 00:04:33,250
cryptographically whether it's being

00:04:31,510 --> 00:04:34,520
encrypted or decrypted or the keys

00:04:33,250 --> 00:04:36,410
themselves

00:04:34,520 --> 00:04:38,120
it's it's important information because

00:04:36,410 --> 00:04:40,970
why would you bother using cryptography

00:04:38,120 --> 00:04:42,919
on anything it doesn't matter of course

00:04:40,970 --> 00:04:46,460
these days you're probably using TLS

00:04:42,919 --> 00:04:47,630
when you watch cat videos so it's not so

00:04:46,460 --> 00:04:52,789
much of a correlation anymore but

00:04:47,630 --> 00:04:54,680
historically it was and second side

00:04:52,789 --> 00:04:57,289
channels are inherently low bandwidth

00:04:54,680 --> 00:04:59,960
and so if you're going to be using an

00:04:57,289 --> 00:05:02,080
attack like this you're going to want to

00:04:59,960 --> 00:05:04,009
apply it to a situation where there's a

00:05:02,080 --> 00:05:06,800
small amount of data which is very

00:05:04,009 --> 00:05:12,050
valuable so krypter krypter have a keys

00:05:06,800 --> 00:05:13,580
they might be 128 maybe 256 bits it's a

00:05:12,050 --> 00:05:17,270
lot easier to leak that much data that I

00:05:13,580 --> 00:05:22,820
used to leak a file of gigabytes for

00:05:17,270 --> 00:05:24,919
instance now I said I'm going to talk

00:05:22,820 --> 00:05:27,289
about 23 years of side channel attacks

00:05:24,919 --> 00:05:31,569
but to set the stage first I need to go

00:05:27,289 --> 00:05:34,190
back a little bit further 42 years in

00:05:31,569 --> 00:05:37,039
1977 Rivest Shamir and Adleman published

00:05:34,190 --> 00:05:40,159
the RSA cryptosystem and this was the

00:05:37,039 --> 00:05:43,430
first published asymmetric cryptosystem

00:05:40,159 --> 00:05:45,590
I say published because in fact

00:05:43,430 --> 00:05:48,530
asymmetric cryptography was discovered

00:05:45,590 --> 00:05:52,699
by a mathematician at GCHQ about four

00:05:48,530 --> 00:05:53,870
years earlier but it wasn't published at

00:05:52,699 --> 00:05:58,009
this point it was essentially a

00:05:53,870 --> 00:06:01,940
mathematical curiosity for those of you

00:05:58,009 --> 00:06:03,080
who went to Warner's talk about the

00:06:01,940 --> 00:06:06,820
early days of Unix

00:06:03,080 --> 00:06:09,979
yesterday just a back-of-the-envelope

00:06:06,820 --> 00:06:12,199
calculation if you were on a PDP 7 and

00:06:09,979 --> 00:06:13,240
you wanted to run an RSA with typical

00:06:12,199 --> 00:06:16,699
key sizes

00:06:13,240 --> 00:06:18,229
the mark the box was big enough but it

00:06:16,699 --> 00:06:19,849
would take you about five minutes to do

00:06:18,229 --> 00:06:22,550
a single cryptographic operation a

00:06:19,849 --> 00:06:23,659
private key operation on a PDP 7 I will

00:06:22,550 --> 00:06:29,090
take you about two weeks to generate

00:06:23,659 --> 00:06:30,800
your keys in the first place but of

00:06:29,090 --> 00:06:32,870
course computers get faster over time

00:06:30,800 --> 00:06:36,289
and they get bigger and people like more

00:06:32,870 --> 00:06:40,039
code so June 1991 Phil's Everman

00:06:36,289 --> 00:06:42,169
released PGP originally he intended to

00:06:40,039 --> 00:06:45,080
release it only to the US he didn't

00:06:42,169 --> 00:06:48,080
realize that the US only tagged on

00:06:45,080 --> 00:06:48,860
Usenet news net messages wasn't actually

00:06:48,080 --> 00:06:50,569
in

00:06:48,860 --> 00:06:51,649
so what he thought he was publishing to

00:06:50,569 --> 00:06:54,169
the states and not being published

00:06:51,649 --> 00:06:55,759
around the world the US government was

00:06:54,169 --> 00:06:58,460
not very happy with him

00:06:55,759 --> 00:07:00,740
there was a five-year saga where they

00:06:58,460 --> 00:07:03,349
tried to throw him in jail for exporting

00:07:00,740 --> 00:07:04,249
munitions illegally because as far as

00:07:03,349 --> 00:07:09,439
the US government is concerned

00:07:04,249 --> 00:07:11,360
cryptography is a weapon of war this

00:07:09,439 --> 00:07:13,969
isn't where the story of saigon fact

00:07:11,360 --> 00:07:16,159
starts though because it's really

00:07:13,969 --> 00:07:18,619
difficult to target PGP with a side

00:07:16,159 --> 00:07:21,889
channel attack somebody downloads an

00:07:18,619 --> 00:07:25,610
encrypted email message they type in

00:07:21,889 --> 00:07:27,469
their passwords it decrypts it they read

00:07:25,610 --> 00:07:31,069
the email some point later they write a

00:07:27,469 --> 00:07:33,169
response you can't really measure what's

00:07:31,069 --> 00:07:38,719
going on on their system unless you're

00:07:33,169 --> 00:07:41,839
actually on the system of course but for

00:07:38,719 --> 00:07:44,209
for common uses of PGP there wasn't much

00:07:41,839 --> 00:07:45,830
opportunity for attackers to get close

00:07:44,209 --> 00:07:52,309
enough to the the cryptographic

00:07:45,830 --> 00:07:56,629
operations February 2 1995 however SSL

00:07:52,309 --> 00:07:58,279
2.0 is released and this completely

00:07:56,629 --> 00:08:00,349
changes thing as far as I tell hacks are

00:07:58,279 --> 00:08:02,479
concerned because now RSA is being used

00:08:00,349 --> 00:08:03,830
interactively you've got a web server

00:08:02,479 --> 00:08:06,740
which is connected to the Internet a

00:08:03,830 --> 00:08:10,580
message comes in which is encrypted with

00:08:06,740 --> 00:08:12,680
RSA and that web server is is

00:08:10,580 --> 00:08:15,379
immediately doing this traffic operation

00:08:12,680 --> 00:08:16,879
and something like 400 milliseconds

00:08:15,379 --> 00:08:20,119
later it's finished doing the arithmetic

00:08:16,879 --> 00:08:21,800
and it sends a response back it's not

00:08:20,119 --> 00:08:23,779
going to sit around and wait five

00:08:21,800 --> 00:08:25,610
minutes for you to read an email because

00:08:23,779 --> 00:08:29,719
there's somebody trying to load a web

00:08:25,610 --> 00:08:33,249
page and so at this point now there's

00:08:29,719 --> 00:08:33,249
suddenly an opening for timing attacks

00:08:34,240 --> 00:08:40,550
and as you might expect it didn't take

00:08:36,349 --> 00:08:42,169
very long so 1996 culture published this

00:08:40,550 --> 00:08:43,880
paper timing attacks on the

00:08:42,169 --> 00:08:47,779
implementations of diffie-hellman RSA

00:08:43,880 --> 00:08:51,709
tss and other systems there's a lot of

00:08:47,779 --> 00:08:54,069
of crypto systems mentioned there but

00:08:51,709 --> 00:08:57,709
all they have in common that they use

00:08:54,069 --> 00:08:59,540
large integer arithmetic and the

00:08:57,709 --> 00:09:02,110
standard way of doing arithmetic at the

00:08:59,540 --> 00:09:05,440
time used not a constant time

00:09:02,110 --> 00:09:10,300
modular multiplication routines it was

00:09:05,440 --> 00:09:12,010
fairly straightforward to look at the

00:09:10,300 --> 00:09:13,600
operation being performed and figure out

00:09:12,010 --> 00:09:15,160
is this multiplication going to take

00:09:13,600 --> 00:09:19,060
slightly more time than normal or

00:09:15,160 --> 00:09:20,860
slightly less time than normal and if

00:09:19,060 --> 00:09:24,880
you can do that then you can feed

00:09:20,860 --> 00:09:27,040
particular inputs to this web server the

00:09:24,880 --> 00:09:30,490
RSA Oracle that's doing these

00:09:27,040 --> 00:09:32,070
calculations for you and by measuring

00:09:30,490 --> 00:09:34,570
how long it takes to get response back

00:09:32,070 --> 00:09:38,529
you can get one or two bits for each

00:09:34,570 --> 00:09:41,709
each message that you send it so around

00:09:38,529 --> 00:09:44,529
a thousand RSA operations are a thousand

00:09:41,709 --> 00:09:50,110
connections to the server and you can

00:09:44,529 --> 00:09:51,700
steal its private key this was a

00:09:50,110 --> 00:09:54,760
theoretical attack it really wasn't very

00:09:51,700 --> 00:09:59,290
practical it took around four hundred

00:09:54,760 --> 00:10:00,730
milliseconds to perform the entire RSA

00:09:59,290 --> 00:10:03,519
operation that you would be you met

00:10:00,730 --> 00:10:05,620
measuring and the difference between a

00:10:03,519 --> 00:10:09,130
fast modular multiplication and a slow

00:10:05,620 --> 00:10:10,560
one was around 20 microseconds so you

00:10:09,130 --> 00:10:15,310
would have to measure a difference of

00:10:10,560 --> 00:10:18,160
one part per 20,000 in order to

00:10:15,310 --> 00:10:19,660
distinguish whether a particular bit of

00:10:18,160 --> 00:10:23,079
decryption have a key is a zero or one

00:10:19,660 --> 00:10:24,579
and to make it worse the networking at

00:10:23,079 --> 00:10:27,670
the time fast ethernet had just been

00:10:24,579 --> 00:10:30,430
released 1,500 byte package took hundred

00:10:27,670 --> 00:10:33,519
twenty microseconds to transmit and so

00:10:30,430 --> 00:10:35,019
your signal could be absolutely dwarfed

00:10:33,519 --> 00:10:41,560
lie single packet getting in the way on

00:10:35,019 --> 00:10:45,130
over the network but over time attacks

00:10:41,560 --> 00:10:46,750
all get better so 2003 Bonet and Bromley

00:10:45,130 --> 00:10:50,110
published this paper remote timing

00:10:46,750 --> 00:10:51,850
attacks are practical they attacked our

00:10:50,110 --> 00:10:53,949
I say in a slightly different way they

00:10:51,850 --> 00:10:58,390
were looking at a timing channel on

00:10:53,949 --> 00:10:59,589
Montgomery reproduction RSA

00:10:58,390 --> 00:11:00,640
implementations were done slightly

00:10:59,589 --> 00:11:01,810
differently now it slightly more

00:11:00,640 --> 00:11:05,560
efficiently using the Chinese remainder

00:11:01,810 --> 00:11:08,440
theorem but the key observation they

00:11:05,560 --> 00:11:10,839
made was if you can't measure how long

00:11:08,440 --> 00:11:12,880
it takes to perform one operation with

00:11:10,839 --> 00:11:14,380
enough accuracy you can measure how long

00:11:12,880 --> 00:11:15,490
it takes to perform lots of operations

00:11:14,380 --> 00:11:18,640
and

00:11:15,490 --> 00:11:22,690
calculate the average and if you average

00:11:18,640 --> 00:11:25,779
enough your noise level goes down it's

00:11:22,690 --> 00:11:27,460
like public opinion polling if you poll

00:11:25,779 --> 00:11:29,320
four times as many people your margin of

00:11:27,460 --> 00:11:30,720
error on your opinion poll is is half

00:11:29,320 --> 00:11:34,060
the size

00:11:30,720 --> 00:11:36,700
so rather than timing around a thousand

00:11:34,060 --> 00:11:39,459
RSA operations they are now timing about

00:11:36,700 --> 00:11:42,040
two million operations so now they're

00:11:39,459 --> 00:11:44,890
making two million connections to a

00:11:42,040 --> 00:11:46,480
secure web server they say in their

00:11:44,890 --> 00:11:49,510
paper it takes about two hours to do

00:11:46,480 --> 00:11:51,490
this so the joke at the time was if you

00:11:49,510 --> 00:11:53,680
suddenly notice that you're mostly idle

00:11:51,490 --> 00:11:55,480
web server has its CPU being pegged to a

00:11:53,680 --> 00:11:58,260
hundred percent for two hours somebody's

00:11:55,480 --> 00:12:00,730
trying to steal your RSA key of course

00:11:58,260 --> 00:12:03,880
that's if somebody's being really

00:12:00,730 --> 00:12:05,500
obvious about it you can't do it in two

00:12:03,880 --> 00:12:07,000
hours but you could spread the the

00:12:05,500 --> 00:12:09,459
connections over a long period of time

00:12:07,000 --> 00:12:12,149
and then not have us as obvious a signal

00:12:09,459 --> 00:12:15,190
in terms of the amount of traffic but

00:12:12,149 --> 00:12:18,910
this attack which was considered to be

00:12:15,190 --> 00:12:21,310
purely theoretical against RSA at this

00:12:18,910 --> 00:12:23,050
point now suddenly whose wheel you can

00:12:21,310 --> 00:12:24,790
steal people script traffic keys over

00:12:23,050 --> 00:12:27,730
the network by measuring how long it

00:12:24,790 --> 00:12:29,940
takes for them to respond to you so you

00:12:27,730 --> 00:12:32,860
need to fix your webserver so your your

00:12:29,940 --> 00:12:39,339
OpenSSL stack or whichever RSA stack

00:12:32,860 --> 00:12:41,170
you're using fortunately there's an easy

00:12:39,339 --> 00:12:44,950
way to fix it for these particular

00:12:41,170 --> 00:12:47,560
attacks these attacks make use of chosen

00:12:44,950 --> 00:12:49,240
inputs so you're connecting to the

00:12:47,560 --> 00:12:51,190
server and you're deciding what value to

00:12:49,240 --> 00:12:54,370
send to it for it to perform an RSA

00:12:51,190 --> 00:12:57,910
operation on this is very common theme

00:12:54,370 --> 00:13:00,070
with cryptography it is always easier to

00:12:57,910 --> 00:13:02,079
attack crypt systems if you can make use

00:13:00,070 --> 00:13:05,170
of chosen inputs whether it's chosen

00:13:02,079 --> 00:13:07,750
plaintext or chosen ciphertext and in

00:13:05,170 --> 00:13:10,570
fact it's a common practice in designing

00:13:07,750 --> 00:13:12,250
crypts kind of protocols that if you

00:13:10,570 --> 00:13:15,130
want to design protocol to be secure

00:13:12,250 --> 00:13:18,010
even if some of their components end up

00:13:15,130 --> 00:13:19,990
being not as strong as you hoped you

00:13:18,010 --> 00:13:22,420
design your protocol to avoid allowing

00:13:19,990 --> 00:13:26,410
attackers to choose what values are

00:13:22,420 --> 00:13:29,260
going to be operating on so the defense

00:13:26,410 --> 00:13:29,769
that they provided here the blinding

00:13:29,260 --> 00:13:32,649
approach

00:13:29,769 --> 00:13:34,209
is rather than operating on the value X

00:13:32,649 --> 00:13:37,420
that you've given amazing its power D

00:13:34,209 --> 00:13:39,160
you can pick up ahead in value our way

00:13:37,420 --> 00:13:41,769
the power e which is a small number the

00:13:39,160 --> 00:13:44,259
the RSA encryption exponent multiply

00:13:41,769 --> 00:13:45,850
that into X now you have a different

00:13:44,259 --> 00:13:48,730
value which you raise the power D your

00:13:45,850 --> 00:13:50,519
RSA decryption exponent and then you can

00:13:48,730 --> 00:13:55,689
divide out the value R at the end

00:13:50,519 --> 00:13:58,989
because the way RSA works are to the e

00:13:55,689 --> 00:14:02,079
to the D is just R it cancelled out you

00:13:58,989 --> 00:14:04,600
get the same answer at the end but

00:14:02,079 --> 00:14:07,329
you're not performing the explanation

00:14:04,600 --> 00:14:10,869
exponentiation cloudy with a value that

00:14:07,329 --> 00:14:13,779
was provided by the attacker since the

00:14:10,869 --> 00:14:17,170
public exponent E is much smaller than

00:14:13,779 --> 00:14:21,749
the the private exponent calculating out

00:14:17,170 --> 00:14:25,869
power D and our inverse R was very fast

00:14:21,749 --> 00:14:28,059
in only paper they they say typically

00:14:25,869 --> 00:14:31,660
two to five percent performance cost of

00:14:28,059 --> 00:14:34,509
applying this defense and as long as a

00:14:31,660 --> 00:14:37,059
new random value R is chosen for every

00:14:34,509 --> 00:14:39,549
operation there's no way for the

00:14:37,059 --> 00:14:42,100
attacker to predict what value are going

00:14:39,549 --> 00:14:45,429
to be raising power D and so there's no

00:14:42,100 --> 00:14:47,949
way that a chosen input attack can

00:14:45,429 --> 00:14:49,360
reveal anything to them they will see

00:14:47,949 --> 00:14:52,019
that some operations are faster than

00:14:49,360 --> 00:14:55,929
others but it will be completely random

00:14:52,019 --> 00:15:03,369
as long as it's a different random value

00:14:55,929 --> 00:15:04,119
R for each operation the next year

00:15:03,369 --> 00:15:07,869
though

00:15:04,119 --> 00:15:11,589
Bernstein published the first cache

00:15:07,869 --> 00:15:15,459
timing attack now we're heading away

00:15:11,589 --> 00:15:18,369
from pure lead timing attacks where you

00:15:15,459 --> 00:15:20,439
can look at the C code and say well in

00:15:18,369 --> 00:15:22,389
this case we're doing more operations

00:15:20,439 --> 00:15:26,139
than this other case and now we start

00:15:22,389 --> 00:15:28,769
looking at how the details of particular

00:15:26,139 --> 00:15:30,850
CPUs matter

00:15:28,769 --> 00:15:34,029
AES is the Advanced Encryption standard

00:15:30,850 --> 00:15:36,759
it is the standard symmetric cipher

00:15:34,029 --> 00:15:39,189
which is used in pretty much every

00:15:36,759 --> 00:15:41,800
system out there well ok some now some

00:15:39,189 --> 00:15:44,220
people switching to ChaCha but for

00:15:41,800 --> 00:15:46,899
about two decades it was the standard

00:15:44,220 --> 00:15:50,739
way that we perform symmetric

00:15:46,899 --> 00:15:52,600
cryptography and a straight forward

00:15:50,739 --> 00:15:58,179
elephant ation uses these things called

00:15:52,600 --> 00:16:01,209
s box table lookups so at many points in

00:15:58,179 --> 00:16:04,720
in the AES computation you take a single

00:16:01,209 --> 00:16:07,329
by H value you lock it up in a table 256

00:16:04,720 --> 00:16:08,350
entries depending on to implementation

00:16:07,329 --> 00:16:10,869
you're looking up one byte you're

00:16:08,350 --> 00:16:12,670
looking up four bytes by the point is

00:16:10,869 --> 00:16:15,189
you are looking up a value in a table

00:16:12,670 --> 00:16:18,279
and the first set of values that you

00:16:15,189 --> 00:16:21,399
look up are always the key XOR it with

00:16:18,279 --> 00:16:25,209
the blocks that the corresponding bytes

00:16:21,399 --> 00:16:27,670
of the block of input to your cipher if

00:16:25,209 --> 00:16:29,019
some table entries take longer to access

00:16:27,670 --> 00:16:32,529
than others

00:16:29,019 --> 00:16:35,139
you will find that certain values of

00:16:32,529 --> 00:16:37,809
input will take longer to compute than

00:16:35,139 --> 00:16:39,730
others and which which values of input

00:16:37,809 --> 00:16:41,860
take longer will tell you something

00:16:39,730 --> 00:16:43,480
about what the key is that which is

00:16:41,860 --> 00:16:46,929
being exhort with it before you look up

00:16:43,480 --> 00:16:49,720
in this table and it turns out yes in

00:16:46,929 --> 00:16:51,790
fact there are many reasons that certain

00:16:49,720 --> 00:16:54,610
offsets will be longer to look up than

00:16:51,790 --> 00:16:57,730
others you have whether the values in

00:16:54,610 --> 00:17:00,149
the cache at the time you have loads

00:16:57,730 --> 00:17:02,860
drawer conflicts on the cache where

00:17:00,149 --> 00:17:04,480
you're trying to load and store to the

00:17:02,860 --> 00:17:06,339
same part of the cache at the same time

00:17:04,480 --> 00:17:08,230
with different instructions you have

00:17:06,339 --> 00:17:12,510
cash bank conflicts if you're trying to

00:17:08,230 --> 00:17:14,380
load two different values from different

00:17:12,510 --> 00:17:17,459
locations but different locations that

00:17:14,380 --> 00:17:22,360
are part of the same Bank of the cache

00:17:17,459 --> 00:17:24,939
and it turns out that with about 1

00:17:22,360 --> 00:17:29,139
billion random inputs to a yes Bern's

00:17:24,939 --> 00:17:30,039
humans able to steal a s keys now the

00:17:29,139 --> 00:17:31,270
defense against this is pretty

00:17:30,039 --> 00:17:34,270
straightforward

00:17:31,270 --> 00:17:36,730
don't do a s and software these days

00:17:34,270 --> 00:17:39,309
pretty much every CPU out there has a

00:17:36,730 --> 00:17:40,799
yes Hardware circuits they don't have

00:17:39,309 --> 00:17:44,799
any table lookup so you just have

00:17:40,799 --> 00:17:46,929
circuits and they don't have any side

00:17:44,799 --> 00:17:50,649
channels of these not side channels of

00:17:46,929 --> 00:17:53,860
notes of note in them if you do need to

00:17:50,649 --> 00:17:55,299
run AES and software it is possible to

00:17:53,860 --> 00:17:58,600
do it without having

00:17:55,299 --> 00:18:00,730
table lookups Bernstein wrote a very

00:17:58,600 --> 00:18:03,309
great length about ways to do this but

00:18:00,730 --> 00:18:06,009
all of the ways of doing a Essen

00:18:03,309 --> 00:18:08,379
software are if you want to avoid side

00:18:06,009 --> 00:18:09,940
channels are very slow so you really do

00:18:08,379 --> 00:18:12,119
want to use a hardware circuits whenever

00:18:09,940 --> 00:18:12,119
possible

00:18:12,450 --> 00:18:20,049
moving along my contribution to this

00:18:15,100 --> 00:18:22,029
story in 2005 at BSD can 2005 I

00:18:20,049 --> 00:18:24,549
published this paper cash missing for

00:18:22,029 --> 00:18:27,309
fun and profit this was a first attack

00:18:24,549 --> 00:18:31,409
on first published attack on Intel

00:18:27,309 --> 00:18:34,029
hyper-threading the attack here is

00:18:31,409 --> 00:18:36,700
making taking advantage of the fact that

00:18:34,029 --> 00:18:39,809
there's two threads running on the CPU

00:18:36,700 --> 00:18:43,029
and they're sharing the same l1 cache

00:18:39,809 --> 00:18:45,730
what you can do is in the thread that

00:18:43,029 --> 00:18:47,440
you control you fill the cache with your

00:18:45,730 --> 00:18:49,090
data so you just you access a whole

00:18:47,440 --> 00:18:52,059
bunch of different locations in memory

00:18:49,090 --> 00:18:53,769
and the cache will obligingly load those

00:18:52,059 --> 00:18:56,230
values for you it assumes you're going

00:18:53,769 --> 00:18:58,509
to be using them again then a moment

00:18:56,230 --> 00:19:01,480
later you go back try to access all the

00:18:58,509 --> 00:19:03,779
same locations again but you measure how

00:19:01,480 --> 00:19:06,489
long it takes for you to access those

00:19:03,779 --> 00:19:08,320
how long it took who reveals to you

00:19:06,489 --> 00:19:10,570
whether those values are still in the

00:19:08,320 --> 00:19:12,519
cache run art if the other thread hasn't

00:19:10,570 --> 00:19:15,279
touched any memory everything will be

00:19:12,519 --> 00:19:17,830
fast if the other thread has touched

00:19:15,279 --> 00:19:19,269
some locations in memory then some of

00:19:17,830 --> 00:19:22,869
your data will have been displaced in my

00:19:19,269 --> 00:19:24,039
cache and which values have been at

00:19:22,869 --> 00:19:26,440
which memory locations have been

00:19:24,039 --> 00:19:27,999
displaced tell you something about which

00:19:26,440 --> 00:19:32,889
particular memory addresses the other

00:19:27,999 --> 00:19:35,889
thread used it's important to note here

00:19:32,889 --> 00:19:37,989
that in this attack you're never

00:19:35,889 --> 00:19:39,970
measuring how long a cryptographic

00:19:37,989 --> 00:19:41,350
operation takes the only thing you're

00:19:39,970 --> 00:19:45,639
measuring is how long it takes for you

00:19:41,350 --> 00:19:47,350
to access your own memory so people have

00:19:45,639 --> 00:19:50,470
sometimes referred to my attack as being

00:19:47,350 --> 00:19:53,909
a timing attack but it isn't it is in

00:19:50,470 --> 00:19:57,429
fact a micro architectural attack so

00:19:53,909 --> 00:20:00,940
this is an entirely new family of hacks

00:19:57,429 --> 00:20:03,129
it's I mentioned before side channels

00:20:00,940 --> 00:20:06,249
sometimes you have information which is

00:20:03,129 --> 00:20:08,610
go staying inside that black box and you

00:20:06,249 --> 00:20:11,090
can extract at a later point

00:20:08,610 --> 00:20:13,640
here the cryptograph cooperation is

00:20:11,090 --> 00:20:15,809
leaving some state in the form of

00:20:13,640 --> 00:20:17,850
whether it loaded values into the cash

00:20:15,809 --> 00:20:20,670
and then I am extracting that

00:20:17,850 --> 00:20:24,960
information by measuring my own

00:20:20,670 --> 00:20:26,580
operations to see whether data was

00:20:24,960 --> 00:20:30,960
loaded into particular cache lines or

00:20:26,580 --> 00:20:34,880
not and this allows much higher

00:20:30,960 --> 00:20:37,080
bandwidth with a standard timing attack

00:20:34,880 --> 00:20:39,690
and all patience being performed and you

00:20:37,080 --> 00:20:42,030
measure how long it takes and you might

00:20:39,690 --> 00:20:45,900
get one bit of information you know was

00:20:42,030 --> 00:20:47,880
it fast or was it slow maybe you know is

00:20:45,900 --> 00:20:49,860
it very fast or slightly fast or

00:20:47,880 --> 00:20:52,290
slightly slower very slow so you might

00:20:49,860 --> 00:20:54,210
have two bits of information more often

00:20:52,290 --> 00:20:56,549
from a timing attack you you get like

00:20:54,210 --> 00:20:58,770
0.1 bits of information because you need

00:20:56,549 --> 00:21:01,160
to perform the operation many times and

00:20:58,770 --> 00:21:04,470
average things to get even a single bit

00:21:01,160 --> 00:21:06,299
but here because you can be measuring

00:21:04,470 --> 00:21:09,419
the stage of the cache while this is

00:21:06,299 --> 00:21:11,309
going on you can get in fact enough

00:21:09,419 --> 00:21:15,419
information to steal the entire RSA key

00:21:11,309 --> 00:21:17,460
just by watching a single operation and

00:21:15,419 --> 00:21:23,190
this is what it looks like this is a

00:21:17,460 --> 00:21:24,960
slide from my talk in 2005 the the

00:21:23,190 --> 00:21:27,150
x-axis here is the cash concurrency

00:21:24,960 --> 00:21:34,820
class on the the CPU I was looking at I

00:21:27,150 --> 00:21:37,950
think it was a pentium MMX like I ever

00:21:34,820 --> 00:21:41,250
on the CP I was looking at there were 32

00:21:37,950 --> 00:21:42,750
cache Congress lis classes so 32

00:21:41,250 --> 00:21:44,520
different places that data might get

00:21:42,750 --> 00:21:47,600
loaded into when you access it from

00:21:44,520 --> 00:21:51,330
memory and it comes into the cache and

00:21:47,600 --> 00:21:54,179
the y-axis is the clock by the time in

00:21:51,330 --> 00:21:58,380
cycles as we're going through measuring

00:21:54,179 --> 00:22:00,450
this and all I did here was repeatedly

00:21:58,380 --> 00:22:03,360
measure how long it took to access the

00:22:00,450 --> 00:22:06,059
same locations in memory and the I

00:22:03,360 --> 00:22:07,500
believe the black cells there are the

00:22:06,059 --> 00:22:12,120
ones that took longer in the white cells

00:22:07,500 --> 00:22:13,559
took less time and you can see certain

00:22:12,120 --> 00:22:15,870
patterns there there's a repeating

00:22:13,559 --> 00:22:20,429
pattern on the right through you're

00:22:15,870 --> 00:22:22,340
about four or five blocks high which

00:22:20,429 --> 00:22:26,690
corresponds to every time that

00:22:22,340 --> 00:22:29,090
CEL squaring a value and then maybe

00:22:26,690 --> 00:22:31,370
seven blocks high is a different pattern

00:22:29,090 --> 00:22:35,120
which corresponds to a module develop

00:22:31,370 --> 00:22:40,120
multiplication you can also if you look

00:22:35,120 --> 00:22:42,140
very closely see some values which are

00:22:40,120 --> 00:22:43,820
darker because those are the values are

00:22:42,140 --> 00:22:45,799
to being loaded out of memory for

00:22:43,820 --> 00:22:48,610
particular values that OpenSSL is

00:22:45,799 --> 00:22:51,260
multiplying by you can also see three

00:22:48,610 --> 00:22:53,200
horizontal lines which I think are clock

00:22:51,260 --> 00:22:55,760
interrupts happening where the

00:22:53,200 --> 00:22:57,950
everything's getting displaced because

00:22:55,760 --> 00:23:01,490
the kernel is doing something with the

00:22:57,950 --> 00:23:03,020
clock interrupt but as you can see

00:23:01,490 --> 00:23:07,610
there's a lot of information here and

00:23:03,020 --> 00:23:14,029
this this is less than 1% of the RSA

00:23:07,610 --> 00:23:16,549
operation about two months after I

00:23:14,029 --> 00:23:18,399
published my paper the team of ostrich

00:23:16,549 --> 00:23:20,539
Amira and Romer published their work

00:23:18,399 --> 00:23:22,010
they had been investigating the same

00:23:20,539 --> 00:23:25,460
issue with hyper-threading concurrently

00:23:22,010 --> 00:23:27,529
with me they were a few weeks behind me

00:23:25,460 --> 00:23:29,330
all the way through but instead of

00:23:27,529 --> 00:23:30,700
looking at RSA they were looking at a

00:23:29,330 --> 00:23:33,500
AES

00:23:30,700 --> 00:23:36,110
they use the same approach of looking at

00:23:33,500 --> 00:23:38,149
the how long it takes to access your own

00:23:36,110 --> 00:23:40,429
data you load into the cache and then

00:23:38,149 --> 00:23:43,880
measure how long hates to access the

00:23:40,429 --> 00:23:48,110
same values again in order to steal all

00:23:43,880 --> 00:23:50,539
a AES keys as before because the l1

00:23:48,110 --> 00:23:52,370
cache is charged you can measure what's

00:23:50,539 --> 00:23:55,730
happening with somebody else using the

00:23:52,370 --> 00:24:00,860
same l1 cache they also demonstrated

00:23:55,730 --> 00:24:05,059
stealing a s keys after the fact so they

00:24:00,860 --> 00:24:08,450
looked at Linux DM crypt this is fairly

00:24:05,059 --> 00:24:11,720
similar to freebsd x' jelly it's an

00:24:08,450 --> 00:24:13,669
encrypted filesystem and what they would

00:24:11,720 --> 00:24:16,700
do is they they had a filesystem mounted

00:24:13,669 --> 00:24:20,330
and an unprivileged user would write

00:24:16,700 --> 00:24:22,549
something to disk and after the kernel

00:24:20,330 --> 00:24:24,440
returned to use land so the cryptography

00:24:22,549 --> 00:24:27,679
have happened the disk access has

00:24:24,440 --> 00:24:29,539
happened maybe 10 milliseconds later

00:24:27,679 --> 00:24:31,789
after it's been written to disk returns

00:24:29,539 --> 00:24:34,100
to use land and then they measured the

00:24:31,789 --> 00:24:36,350
stage of the l1 cache and even at that

00:24:34,100 --> 00:24:36,550
point there's enough information left in

00:24:36,350 --> 00:24:38,950
the

00:24:36,550 --> 00:24:41,410
on cash that they could steal the a s

00:24:38,950 --> 00:24:45,400
key that DM crypt was using inside the

00:24:41,410 --> 00:24:48,310
kernel and what they showed was

00:24:45,400 --> 00:24:50,470
depending on CPU and whether they're

00:24:48,310 --> 00:24:53,470
measuring the operations while they're

00:24:50,470 --> 00:24:55,330
taking place or after the fact it was

00:24:53,470 --> 00:24:57,400
between a hundred and a million a s

00:24:55,330 --> 00:25:01,500
operations they need to measure in order

00:24:57,400 --> 00:25:03,400
to steal that AES key so again this is

00:25:01,500 --> 00:25:06,130
compared to the Bernstein's attack

00:25:03,400 --> 00:25:08,770
Bernstein was measuring 1 billion AAS

00:25:06,130 --> 00:25:10,930
operations here it's between 100 and

00:25:08,770 --> 00:25:12,700
million so you have a lot more bandwidth

00:25:10,930 --> 00:25:14,980
when you're throwing a micro

00:25:12,700 --> 00:25:20,440
architectural attack rather than simply

00:25:14,980 --> 00:25:23,830
looking at timing again we know how to

00:25:20,440 --> 00:25:27,250
defend against these attacks in my 2005

00:25:23,830 --> 00:25:31,210
paper I explained exactly what you need

00:25:27,250 --> 00:25:33,570
to do you need to avoid having any way

00:25:31,210 --> 00:25:36,400
that your secrets are leaking through

00:25:33,570 --> 00:25:38,800
conditional branches so which which

00:25:36,400 --> 00:25:41,110
project which particular instructions

00:25:38,800 --> 00:25:44,860
you end up executing so don't put your

00:25:41,110 --> 00:25:48,940
secrets into if statements or selection

00:25:44,860 --> 00:25:51,940
operators or for while loops and don't

00:25:48,940 --> 00:25:55,570
put any of them into array indexing so

00:25:51,940 --> 00:25:57,700
make sure that the the exact sequence of

00:25:55,570 --> 00:26:01,120
memory locations you access does not

00:25:57,700 --> 00:26:03,570
depend on anything secret in some cases

00:26:01,120 --> 00:26:06,700
this will mean your code will be slower

00:26:03,570 --> 00:26:08,770
instead of having a conditional a

00:26:06,700 --> 00:26:10,570
selection operator where depending on

00:26:08,770 --> 00:26:13,510
its condition you either do foo or you

00:26:10,570 --> 00:26:16,840
do bar what you would need to do is do

00:26:13,510 --> 00:26:19,240
foo and bar and then based on the

00:26:16,840 --> 00:26:22,330
condition combine them and get the right

00:26:19,240 --> 00:26:24,510
value Xu of both sides instead of just

00:26:22,330 --> 00:26:24,510
one

00:26:24,660 --> 00:26:30,160
typically in cryptography this isn't a

00:26:26,770 --> 00:26:32,110
big deal if you were writing the

00:26:30,160 --> 00:26:34,780
database it will be very difficult to

00:26:32,110 --> 00:26:37,000
write code like this but cryptography

00:26:34,780 --> 00:26:39,790
you're dealing with a fairly small

00:26:37,000 --> 00:26:41,200
amount of data there's a fairly small

00:26:39,790 --> 00:26:43,810
number of different things you might be

00:26:41,200 --> 00:26:46,390
doing so it's not too difficult to write

00:26:43,810 --> 00:26:49,760
your code to avoid vulnerabilities like

00:26:46,390 --> 00:26:51,890
this and there's also a side benefit

00:26:49,760 --> 00:26:53,990
that in addition to preventing any micro

00:26:51,890 --> 00:26:56,390
architectural side channels this also

00:26:53,990 --> 00:26:58,970
gives you a guarantee against timing

00:26:56,390 --> 00:27:00,080
side channels it does not mean that your

00:26:58,970 --> 00:27:02,660
code is always going to take the same

00:27:00,080 --> 00:27:04,790
amount of time to run depending on stage

00:27:02,660 --> 00:27:06,050
of the cache it may take longer because

00:27:04,790 --> 00:27:09,020
you need to load your data into the

00:27:06,050 --> 00:27:10,160
cache but whether it takes longer or not

00:27:09,020 --> 00:27:12,380
will not reveal anything about your

00:27:10,160 --> 00:27:14,570
secrets because you're loading the same

00:27:12,380 --> 00:27:20,540
values into the cache regardless of the

00:27:14,570 --> 00:27:25,060
secret value so you care about over the

00:27:20,540 --> 00:27:28,340
years after 2005 we got more attacks

00:27:25,060 --> 00:27:30,800
Intel in 2005 claims they had an attack

00:27:28,340 --> 00:27:34,490
against RSA exploiting the shared l2

00:27:30,800 --> 00:27:38,510
cache or than the l1 cache I say claimed

00:27:34,490 --> 00:27:40,130
they never published this this claim

00:27:38,510 --> 00:27:41,900
came up when they were trying to

00:27:40,130 --> 00:27:43,730
convince me that this attack on

00:27:41,900 --> 00:27:45,920
hyper-threading really wasn't a big deal

00:27:43,730 --> 00:27:49,130
and really you don't need to give this

00:27:45,920 --> 00:27:50,510
conference talk later on where I said

00:27:49,130 --> 00:27:51,650
you know I really do think I need to

00:27:50,510 --> 00:27:53,780
give this conference talk they then

00:27:51,650 --> 00:27:56,060
moved on to trying to tell Yahoo to fire

00:27:53,780 --> 00:27:59,050
me which was funny because I didn't work

00:27:56,060 --> 00:28:01,910
for Yahoo but somehow they thought I did

00:27:59,050 --> 00:28:04,940
so I take Intel's claims here with a

00:28:01,910 --> 00:28:07,460
little bit of a grain of salt but the

00:28:04,940 --> 00:28:12,760
fact is whether they did it with the l2

00:28:07,460 --> 00:28:15,590
cache or not to the next year this team

00:28:12,760 --> 00:28:17,540
showed that you could use the the state

00:28:15,590 --> 00:28:21,320
of the CPU branch predictors to leak

00:28:17,540 --> 00:28:26,150
information the next year of the stage

00:28:21,320 --> 00:28:27,470
of the l1 instruction cache 2015 it was

00:28:26,150 --> 00:28:31,070
shown that you could leak information

00:28:27,470 --> 00:28:35,720
through the l3 cache so now we've gone

00:28:31,070 --> 00:28:37,700
from a 32 kilobyte cache l1 cache which

00:28:35,720 --> 00:28:41,870
is attached to two hyper heads on a

00:28:37,700 --> 00:28:47,090
single core up to a I think 24 megabyte

00:28:41,870 --> 00:28:48,170
cache which is attached to 16 cores but

00:28:47,090 --> 00:28:51,220
there was enough enough information

00:28:48,170 --> 00:28:54,290
there for them to to steal keys

00:28:51,220 --> 00:28:57,650
20:18 the translation lookaside buffer

00:28:54,290 --> 00:29:00,110
of course at this point we needed to

00:28:57,650 --> 00:29:01,430
have flashy names for vulnerabilities so

00:29:00,110 --> 00:29:03,750
they referred to it as a translational

00:29:01,430 --> 00:29:08,250
ecocide buffer and call this the tea

00:29:03,750 --> 00:29:10,500
bleed attack the same year last year we

00:29:08,250 --> 00:29:12,660
had an attack making use of CPU

00:29:10,500 --> 00:29:15,450
execution ports this one going back to

00:29:12,660 --> 00:29:17,490
hyper threading where each core has a

00:29:15,450 --> 00:29:19,050
certain number of execution ports which

00:29:17,490 --> 00:29:23,370
are shared between the two threads and

00:29:19,050 --> 00:29:25,080
they call this the port smash attack and

00:29:23,370 --> 00:29:27,660
I'm sure there are many other attacks

00:29:25,080 --> 00:29:30,750
that I've forgotten haven't put onto the

00:29:27,660 --> 00:29:35,100
slide by the point is over time attacks

00:29:30,750 --> 00:29:37,670
always get better and where you say in

00:29:35,100 --> 00:29:40,440
2005 well here's a way to exploit this

00:29:37,670 --> 00:29:42,480
using one particular bit of shared state

00:29:40,440 --> 00:29:44,550
and you know maybe you can do it with

00:29:42,480 --> 00:29:46,560
other bits of shared state it turns out

00:29:44,550 --> 00:29:48,510
yeah pretty much anytime you have a

00:29:46,560 --> 00:29:51,860
resource which is shared you'll be able

00:29:48,510 --> 00:29:54,090
to exploit it but the good news here is

00:29:51,860 --> 00:29:57,000
if you write your code according to the

00:29:54,090 --> 00:29:57,960
guidelines like a view and 2005 you

00:29:57,000 --> 00:29:59,460
don't need to worry about all of these

00:29:57,960 --> 00:30:02,580
because all of these attacks are

00:29:59,460 --> 00:30:05,310
exploiting either different memory

00:30:02,580 --> 00:30:13,650
locations being accessed or different

00:30:05,310 --> 00:30:16,200
code paths being executed before I move

00:30:13,650 --> 00:30:18,060
on to further attacks I just want to go

00:30:16,200 --> 00:30:20,700
back and talk a little bit about CPU

00:30:18,060 --> 00:30:22,230
architecture those of you who took a CPU

00:30:20,700 --> 00:30:27,380
architecture course in university can

00:30:22,230 --> 00:30:31,770
fall asleep for five minutes in 1961

00:30:27,380 --> 00:30:34,860
IBM released the IBM stretch which was a

00:30:31,770 --> 00:30:39,150
first major system that used CPU

00:30:34,860 --> 00:30:40,650
pipelining the idea here is if you can

00:30:39,150 --> 00:30:42,420
start excusing if you can start

00:30:40,650 --> 00:30:44,640
processing one instruction before you

00:30:42,420 --> 00:30:47,490
finish passing the previous one you can

00:30:44,640 --> 00:30:49,710
make things faster so the classic risk

00:30:47,490 --> 00:30:51,540
pipeline the first thing you do is you

00:30:49,710 --> 00:30:54,270
fetch instructions memory then you

00:30:51,540 --> 00:30:56,070
decode them then you execute them then

00:30:54,270 --> 00:30:58,980
you do any memory accesses that you need

00:30:56,070 --> 00:31:00,810
and finally you commit the operations so

00:30:58,980 --> 00:31:05,340
you write to your your register file on

00:31:00,810 --> 00:31:07,380
the CPU so classically this pipeline

00:31:05,340 --> 00:31:10,770
you've got five stages so five clock

00:31:07,380 --> 00:31:12,440
cycles typically for each instruction

00:31:10,770 --> 00:31:15,570
making its way through the processor

00:31:12,440 --> 00:31:16,900
modern x86 pipelines typically route 15

00:31:15,570 --> 00:31:21,580
stages

00:31:16,900 --> 00:31:24,370
in fact it's not just x86 pretty much

00:31:21,580 --> 00:31:31,779
all modern CPUs will have pipelines of

00:31:24,370 --> 00:31:34,299
around that depth 1990 IBM brought us

00:31:31,779 --> 00:31:38,409
out of order execution with the the

00:31:34,299 --> 00:31:41,080
power one the phrase out of order

00:31:38,409 --> 00:31:43,419
execution is important because the start

00:31:41,080 --> 00:31:45,309
of pipeline fetching instructions and

00:31:43,419 --> 00:31:46,659
decoding em that is still an order

00:31:45,309 --> 00:31:48,640
you can't we order instructions until

00:31:46,659 --> 00:31:50,320
you know what they are and the end of

00:31:48,640 --> 00:31:54,299
the pipeline where you you commit the

00:31:50,320 --> 00:31:54,299
instructions that is also still an order

00:31:54,840 --> 00:31:59,529
it's not immediately obvious why the the

00:31:57,549 --> 00:32:01,690
commit station has been order but in

00:31:59,529 --> 00:32:03,580
fact anytime that you if you want to

00:32:01,690 --> 00:32:05,470
deal with exceptions it's important to

00:32:03,580 --> 00:32:08,620
have the the commits happening in order

00:32:05,470 --> 00:32:11,549
because if you're going to say throw a

00:32:08,620 --> 00:32:14,830
division by zero or error at some point

00:32:11,549 --> 00:32:16,149
you want to make sure that whatever

00:32:14,830 --> 00:32:17,529
exception handle you have maybe you

00:32:16,149 --> 00:32:19,210
maybe your exception handlers so I'd say

00:32:17,529 --> 00:32:22,360
if you try to divide by zero just insert

00:32:19,210 --> 00:32:23,710
a zero there is instead and then if you

00:32:22,360 --> 00:32:26,440
want to go back and resume from that

00:32:23,710 --> 00:32:28,659
point you need to know how to resume and

00:32:26,440 --> 00:32:30,610
the only obvious way to resume is to say

00:32:28,659 --> 00:32:33,789
well everything before this instruction

00:32:30,610 --> 00:32:36,520
should have completed and then we can

00:32:33,789 --> 00:32:37,600
continue from the next instruction if

00:32:36,520 --> 00:32:40,059
you're committing instructions out of

00:32:37,600 --> 00:32:43,779
order then you're sort of lost there's

00:32:40,059 --> 00:32:45,010
no way to to deal with exceptions out of

00:32:43,779 --> 00:32:46,870
order execution that in fact turns out

00:32:45,010 --> 00:32:51,580
to be very important on x86 because it

00:32:46,870 --> 00:32:54,059
has very few registers these days we

00:32:51,580 --> 00:32:56,409
have sixteen registers but back in the

00:32:54,059 --> 00:32:59,679
qubit days we have we just had eight

00:32:56,409 --> 00:33:01,090
general-purpose registers and if you've

00:32:59,679 --> 00:33:05,559
looked at assembly code you get from

00:33:01,090 --> 00:33:07,659
unrolling loops you need you find that

00:33:05,559 --> 00:33:11,110
you've got the same measures being used

00:33:07,659 --> 00:33:12,279
over and over again because you just you

00:33:11,110 --> 00:33:13,570
don't have enough to use different

00:33:12,279 --> 00:33:17,380
registers for for each time you go

00:33:13,570 --> 00:33:21,070
through the loop and so out of order

00:33:17,380 --> 00:33:22,179
execution allows the instructions to

00:33:21,070 --> 00:33:24,159
refer to the same register but

00:33:22,179 --> 00:33:27,700
internally they they end up being remap

00:33:24,159 --> 00:33:30,610
different registers about for the past

00:33:27,700 --> 00:33:32,470
40 years of CPU design

00:33:30,610 --> 00:33:35,500
has really been built around the idea

00:33:32,470 --> 00:33:38,950
that the instructions must must flow it

00:33:35,500 --> 00:33:40,210
is very easy to add another ALU to your

00:33:38,950 --> 00:33:44,289
CPU it's very easy to add another

00:33:40,210 --> 00:33:46,480
multiplier even to chromatic

00:33:44,289 --> 00:33:48,610
instructions these days the amount of

00:33:46,480 --> 00:33:50,769
dye area you need in a floating-point

00:33:48,610 --> 00:33:54,760
unit for those is very very small

00:33:50,769 --> 00:33:57,250
compared to the amount of of dye area

00:33:54,760 --> 00:34:01,809
that we have dedicated to decoding

00:33:57,250 --> 00:34:03,700
instructions and reordering them and of

00:34:01,809 --> 00:34:06,100
course these days most of most of you

00:34:03,700 --> 00:34:12,520
diarrhea on the cache on the CPU is just

00:34:06,100 --> 00:34:14,589
the cache so these give us a lot of

00:34:12,520 --> 00:34:16,780
improved performance

00:34:14,589 --> 00:34:19,690
but of course they do bring risks with

00:34:16,780 --> 00:34:23,020
them I'm sure you've been waiting to see

00:34:19,690 --> 00:34:25,030
the word speculative execution so modern

00:34:23,020 --> 00:34:26,440
CPUs you start executing you start

00:34:25,030 --> 00:34:28,800
handling instruction and +1

00:34:26,440 --> 00:34:30,730
B for instruction number n has completed

00:34:28,800 --> 00:34:31,839
there's an exception here if you insert

00:34:30,730 --> 00:34:34,409
something called a serializing

00:34:31,839 --> 00:34:36,639
instruction and then that tells the CPU

00:34:34,409 --> 00:34:39,940
stop here wait until everything is

00:34:36,639 --> 00:34:41,619
finished then you can proceed but

00:34:39,940 --> 00:34:43,419
normally you don't you don't insert

00:34:41,619 --> 00:34:52,570
those because well that slows everything

00:34:43,419 --> 00:34:55,300
down but when you're dealing with spec

00:34:52,570 --> 00:34:57,849
with an order execution or even a

00:34:55,300 --> 00:34:59,980
specular pipelines sometimes things

00:34:57,849 --> 00:35:01,089
don't go the way that the CPU expects so

00:34:59,980 --> 00:35:04,359
we have these things called pipeline

00:35:01,089 --> 00:35:06,369
flashes if you mispredicted branch you

00:35:04,359 --> 00:35:07,839
you're running a loop when the CPU says

00:35:06,369 --> 00:35:10,420
oh you you've been going on this loop a

00:35:07,839 --> 00:35:11,920
thousand times let's just assume that

00:35:10,420 --> 00:35:13,599
you keep on going on the loop eventually

00:35:11,920 --> 00:35:15,490
you exit the loop and I CPU sighs Oh

00:35:13,599 --> 00:35:18,130
didn't think you're going to do that ok

00:35:15,490 --> 00:35:20,859
let's stop here throw away everything

00:35:18,130 --> 00:35:22,330
that we've done for the next time you're

00:35:20,859 --> 00:35:24,910
on the loop that you ended up decide not

00:35:22,330 --> 00:35:27,250
to do and go back and continue where

00:35:24,910 --> 00:35:30,730
we're supposed to go indirect branch

00:35:27,250 --> 00:35:33,010
target miss prediction if you have

00:35:30,730 --> 00:35:34,690
function pointers typically you're

00:35:33,010 --> 00:35:36,700
usually calling the same function many

00:35:34,690 --> 00:35:39,190
times occasionally you call a different

00:35:36,700 --> 00:35:41,349
function in order to speed things up the

00:35:39,190 --> 00:35:43,480
CPU tries to predict where the code is

00:35:41,349 --> 00:35:43,900
going to go next sometimes it gets it

00:35:43,480 --> 00:35:46,210
wrong

00:35:43,900 --> 00:35:46,990
he's you a pipeline flash exception

00:35:46,210 --> 00:35:51,910
handling for us

00:35:46,990 --> 00:35:53,580
I mentioned / zero if the CPU waited

00:35:51,910 --> 00:35:56,470
every time it's hard revised instruction

00:35:53,580 --> 00:35:57,550
and said let's let's wait here until we

00:35:56,470 --> 00:35:59,440
make sure that we're out dividing by

00:35:57,550 --> 00:36:00,940
zero it would slow things down so the

00:35:59,440 --> 00:36:03,460
CPU will just hope that you're not

00:36:00,940 --> 00:36:05,140
dividing by zero keep on going it turns

00:36:03,460 --> 00:36:07,890
out there's an exception flush the

00:36:05,140 --> 00:36:12,220
pipeline keep on going after that point

00:36:07,890 --> 00:36:16,060
data hazards and my personal favorite

00:36:12,220 --> 00:36:18,400
self-modifying code if you write to

00:36:16,060 --> 00:36:19,660
memory location which is the location

00:36:18,400 --> 00:36:22,900
that you're fetching instructions from

00:36:19,660 --> 00:36:24,970
the CPU will say oh okay

00:36:22,900 --> 00:36:26,080
that instruction I fetched isn't the one

00:36:24,970 --> 00:36:29,230
that you actually want me to execute

00:36:26,080 --> 00:36:31,390
flush a pipeline reload the new values

00:36:29,230 --> 00:36:34,600
that you stored into inter memory with

00:36:31,390 --> 00:36:35,980
their self-modifying code every time you

00:36:34,600 --> 00:36:37,990
see a pipeline flash happening the

00:36:35,980 --> 00:36:39,720
speculative lie accuser state is not

00:36:37,990 --> 00:36:42,070
committed because it gets flushed away

00:36:39,720 --> 00:36:45,310
and so the architectural state the value

00:36:42,070 --> 00:36:47,260
of registers is not changed but the

00:36:45,310 --> 00:36:50,200
microkernel state may have changed and

00:36:47,260 --> 00:36:52,150
this is a fun one because all these

00:36:50,200 --> 00:36:57,160
speculatively exclusion instructions may

00:36:52,150 --> 00:37:00,430
have affected things like caches so the

00:36:57,160 --> 00:37:02,710
meltdown attack this was referred to by

00:37:00,430 --> 00:37:04,950
some people Spectre v2 but I think is

00:37:02,710 --> 00:37:07,240
actually the the sensible place to start

00:37:04,950 --> 00:37:09,760
try to read from a location memory that

00:37:07,240 --> 00:37:13,480
you can't actually access do something

00:37:09,760 --> 00:37:16,750
with a value you just read hope that you

00:37:13,480 --> 00:37:19,180
do that before that trap that you know

00:37:16,750 --> 00:37:22,720
is going to happen gets to the end of

00:37:19,180 --> 00:37:26,530
pipeline and is committed on Intel CPUs

00:37:22,720 --> 00:37:30,790
they are handling traps at the time of

00:37:26,530 --> 00:37:33,640
instruction commit not when it first

00:37:30,790 --> 00:37:36,190
deals with the instruction as a result

00:37:33,640 --> 00:37:38,470
even though the pipeline is flushed you

00:37:36,190 --> 00:37:40,330
can see the state in your cache that was

00:37:38,470 --> 00:37:45,430
affected by these speculative

00:37:40,330 --> 00:37:48,130
instructions similar approach called the

00:37:45,430 --> 00:37:50,530
rogue system registry read the the IOD

00:37:48,130 --> 00:37:53,680
MSR instruction if you are not

00:37:50,530 --> 00:37:55,120
privileged it will trap but it traps

00:37:53,680 --> 00:37:56,980
when it gets to the end of the pipeline

00:37:55,120 --> 00:37:57,700
you can do something before you get to

00:37:56,980 --> 00:38:00,580
that point and have

00:37:57,700 --> 00:38:03,250
I'm flash the lazy floating-point state

00:38:00,580 --> 00:38:05,110
switching attack if the floating-point

00:38:03,250 --> 00:38:07,540
unit is marked is not present which is

00:38:05,110 --> 00:38:11,380
what we used to do when we were didn't

00:38:07,540 --> 00:38:13,360
want to copy state in and out because

00:38:11,380 --> 00:38:17,130
some postures set some instruction some

00:38:13,360 --> 00:38:17,130
processes do not use the photopoint unit

00:38:17,790 --> 00:38:23,740
you could access something on the FPU it

00:38:21,400 --> 00:38:25,000
would trap but meanwhile before the trap

00:38:23,740 --> 00:38:26,230
actually happens you can do something

00:38:25,000 --> 00:38:29,950
with a value that you were just accessed

00:38:26,230 --> 00:38:32,440
swapped yes same thing in all these

00:38:29,950 --> 00:38:34,420
cases because the exception is being

00:38:32,440 --> 00:38:35,680
handled at the end of the pipeline you

00:38:34,420 --> 00:38:38,890
can speculate through defaulting

00:38:35,680 --> 00:38:42,580
instructions as far as I know this is

00:38:38,890 --> 00:38:44,470
just an Intel issue AMD and other non in

00:38:42,580 --> 00:38:48,190
healthy fuse are at least mostly not

00:38:44,470 --> 00:38:50,410
affected because when faults happen they

00:38:48,190 --> 00:38:51,640
are dealt with sooner rather than

00:38:50,410 --> 00:38:54,520
waiting until they get to the end of

00:38:51,640 --> 00:38:55,900
pipeline they do something earlier I

00:38:54,520 --> 00:39:00,250
don't know the details cuz I haven't

00:38:55,900 --> 00:39:03,970
seen the internals of those GPUs but for

00:39:00,250 --> 00:39:05,920
everything I understand they identify

00:39:03,970 --> 00:39:07,870
these as being faulting instructions and

00:39:05,920 --> 00:39:10,090
then do not allow the result of those

00:39:07,870 --> 00:39:14,650
instructions to be used by other

00:39:10,090 --> 00:39:16,690
instructions there's more CP design

00:39:14,650 --> 00:39:19,930
issues speculative store bypass this

00:39:16,690 --> 00:39:22,360
effects pretty much every modern CPU you

00:39:19,930 --> 00:39:23,440
have an instruction that that writes to

00:39:22,360 --> 00:39:24,520
a location memory you have another

00:39:23,440 --> 00:39:28,450
instruction that reads from the same

00:39:24,520 --> 00:39:30,430
location if the CPU realizes that it's

00:39:28,450 --> 00:39:33,250
the same location in memory then it will

00:39:30,430 --> 00:39:36,100
say let's not run this read until that

00:39:33,250 --> 00:39:38,650
light is finished if the CPU doesn't

00:39:36,100 --> 00:39:42,580
realize it's the same location which can

00:39:38,650 --> 00:39:44,950
happen without a water execution then it

00:39:42,580 --> 00:39:46,360
will read the value from memory it may

00:39:44,950 --> 00:39:48,130
go ahead you may go ahead and do

00:39:46,360 --> 00:39:50,710
something with outlook value and then

00:39:48,130 --> 00:39:53,560
only later when that when it realizes oh

00:39:50,710 --> 00:39:56,530
you were waiting to that location then

00:39:53,560 --> 00:39:57,190
it will say whoops that we shouldn't

00:39:56,530 --> 00:40:00,040
have happened

00:39:57,190 --> 00:40:01,840
flush the pipeline let the right happen

00:40:00,040 --> 00:40:04,150
and then go back and proceed with the

00:40:01,840 --> 00:40:07,750
instructions that you that the code

00:40:04,150 --> 00:40:08,980
actually set out but you may do

00:40:07,750 --> 00:40:11,780
something with a value that was read

00:40:08,980 --> 00:40:15,260
from the old value memory

00:40:11,780 --> 00:40:19,190
and leak information even though if you

00:40:15,260 --> 00:40:21,140
look at the code and look at it one

00:40:19,190 --> 00:40:23,270
instruction at a time you would realize

00:40:21,140 --> 00:40:25,130
that no there's no way that you should

00:40:23,270 --> 00:40:26,450
be able to read the value because you've

00:40:25,130 --> 00:40:30,730
just written to that same location in

00:40:26,450 --> 00:40:34,780
memory microarchitecture buffer sampling

00:40:30,730 --> 00:40:37,250
there's several things on Intel CPUs

00:40:34,780 --> 00:40:39,590
none have been published for other CPUs

00:40:37,250 --> 00:40:44,990
but I suspect that other CPUs do have

00:40:39,590 --> 00:40:46,970
these same issues in many cases it makes

00:40:44,990 --> 00:40:49,520
sense to buffer data you've got strong

00:40:46,970 --> 00:40:52,250
buffers where you have a whole bunch of

00:40:49,520 --> 00:40:54,560
values being written to memory and they

00:40:52,250 --> 00:40:55,940
will go into the l1 cache eventually but

00:40:54,560 --> 00:40:57,740
you don't want to whole things up

00:40:55,940 --> 00:40:58,910
waiting for the l1 cache to be ready for

00:40:57,740 --> 00:41:03,650
you so you just put them into a queue

00:40:58,910 --> 00:41:06,560
and let them happen later same thing on

00:41:03,650 --> 00:41:08,960
the read side data may be being read

00:41:06,560 --> 00:41:11,180
into the l1 cache you want to be able to

00:41:08,960 --> 00:41:14,390
access it before you finish dealing with

00:41:11,180 --> 00:41:16,670
things on the l1 l1 cache in some cases

00:41:14,390 --> 00:41:17,900
in order to speed things up the process

00:41:16,670 --> 00:41:20,480
here is for it engaging for one one

00:41:17,900 --> 00:41:23,270
place to another but it's doing it

00:41:20,480 --> 00:41:24,650
optimistically and it may be that it

00:41:23,270 --> 00:41:27,680
realizes too late that it shouldn't

00:41:24,650 --> 00:41:31,940
afforded that data so what does it do it

00:41:27,680 --> 00:41:33,650
if flash is a pipeline but if you've

00:41:31,940 --> 00:41:38,240
really use that data in a way that that

00:41:33,650 --> 00:41:39,740
leaks state then it's too late in some

00:41:38,240 --> 00:41:42,770
of these cases the leak only happens

00:41:39,740 --> 00:41:43,970
between hack resides but I believe

00:41:42,770 --> 00:41:49,040
there's other cases where it can happen

00:41:43,970 --> 00:41:50,870
even between cores and as I say these

00:41:49,040 --> 00:41:53,780
are only been demonstrated on Intel CPUs

00:41:50,870 --> 00:41:55,190
but the the nature of the design

00:41:53,780 --> 00:41:55,880
elements and CPUs that make this

00:41:55,190 --> 00:41:58,490
possible

00:41:55,880 --> 00:42:00,950
makes me think probably other CPUs have

00:41:58,490 --> 00:42:03,200
these same issues because these design

00:42:00,950 --> 00:42:07,300
elements are very useful for making CPUs

00:42:03,200 --> 00:42:10,400
faster and people care about performance

00:42:07,300 --> 00:42:13,610
now a for Spector is the the broad

00:42:10,400 --> 00:42:14,690
category effective execution attacks the

00:42:13,610 --> 00:42:18,040
first one that was demonstrated a

00:42:14,690 --> 00:42:20,990
bounced check attack the CPU

00:42:18,040 --> 00:42:23,210
mispredicted branch usually in this code

00:42:20,990 --> 00:42:24,440
your bounds check says oh yes everything

00:42:23,210 --> 00:42:25,359
is fine you're accessing a value in the

00:42:24,440 --> 00:42:29,539
buffer

00:42:25,359 --> 00:42:32,420
so the CPU learns predict that this will

00:42:29,539 --> 00:42:34,520
happen well if you then go in and access

00:42:32,420 --> 00:42:37,089
something outside of the buffer the CPU

00:42:34,520 --> 00:42:39,859
soul predicts it's inside the buffer and

00:42:37,089 --> 00:42:42,559
it's too late when it realizes that it

00:42:39,859 --> 00:42:43,789
wasn't because you've now used use that

00:42:42,559 --> 00:42:47,119
value from outside of the buffer and

00:42:43,789 --> 00:42:50,510
leaked the information branch token

00:42:47,119 --> 00:42:52,579
injection the CPU again to make things

00:42:50,510 --> 00:42:55,760
faster it is predicting where your

00:42:52,579 --> 00:42:58,700
function pointer is going but you may be

00:42:55,760 --> 00:43:02,420
able to trick it into calling the wrong

00:42:58,700 --> 00:43:03,349
code it realizes eventually but by that

00:43:02,420 --> 00:43:06,470
point it's too late you've already

00:43:03,349 --> 00:43:07,910
leaked information and this is a general

00:43:06,470 --> 00:43:09,859
issue with speculative execution if a

00:43:07,910 --> 00:43:11,390
possibly miss speculates you may run

00:43:09,859 --> 00:43:14,390
code that you were not paying on running

00:43:11,390 --> 00:43:17,450
and every margin CPU is vulnerable to

00:43:14,390 --> 00:43:20,089
this best miss frictions happen even in

00:43:17,450 --> 00:43:21,109
good times yeah I mean if you want to

00:43:20,089 --> 00:43:23,030
exploit this of course you will

00:43:21,109 --> 00:43:26,299
deliberately make the CPU miss predict

00:43:23,030 --> 00:43:28,430
it's very very easy to do that but even

00:43:26,299 --> 00:43:31,069
without doing it deliberately good

00:43:28,430 --> 00:43:34,750
branch predictors on CPUs you're looking

00:43:31,069 --> 00:43:37,279
at maybe 98% success but 2% of the time

00:43:34,750 --> 00:43:40,940
the CPU is not predicting where you're

00:43:37,279 --> 00:43:42,200
going to be running code next but the

00:43:40,940 --> 00:43:44,270
good news here is that this does not

00:43:42,200 --> 00:43:47,480
bypass operating system level privilege

00:43:44,270 --> 00:43:49,400
boundaries so sandbox as I offend if you

00:43:47,480 --> 00:43:50,930
can put the information that you care

00:43:49,400 --> 00:43:53,650
about your cryptographic information for

00:43:50,930 --> 00:43:56,299
instance into a different process then

00:43:53,650 --> 00:43:58,190
straight forward specter attacks will

00:43:56,299 --> 00:44:00,559
not be able to leak that information

00:43:58,190 --> 00:44:02,299
because it is speculatively excusing

00:44:00,559 --> 00:44:04,789
something that that process could have

00:44:02,299 --> 00:44:07,520
executed it just wasn't what you were

00:44:04,789 --> 00:44:10,190
trying to execute and there's many

00:44:07,520 --> 00:44:13,010
possible exploit paths here one that I

00:44:10,190 --> 00:44:16,549
haven't seen anybody demonstrate yet but

00:44:13,010 --> 00:44:18,170
I'm sure is out there is P code machines

00:44:16,549 --> 00:44:21,710
we've got a switch statement and

00:44:18,170 --> 00:44:24,140
depending on the the P code operation

00:44:21,710 --> 00:44:26,990
it's doing a different thing with its

00:44:24,140 --> 00:44:28,039
operand this is exactly the sort of

00:44:26,990 --> 00:44:29,869
place where you would expect to see

00:44:28,039 --> 00:44:32,750
bears from a branch mispredictions and

00:44:29,869 --> 00:44:35,270
so your P code machines are probably

00:44:32,750 --> 00:44:38,500
spectively running the wrong code with

00:44:35,270 --> 00:44:41,140
your your op code and if it

00:44:38,500 --> 00:44:42,580
one of your your up codes is jump to

00:44:41,140 --> 00:44:45,460
this location and run the wrong machine

00:44:42,580 --> 00:44:47,500
code then it is very likely that you can

00:44:45,460 --> 00:44:52,270
be tricked into speculatively running

00:44:47,500 --> 00:44:55,570
something dangerous I'm just about out

00:44:52,270 --> 00:44:59,020
of time but just before I go I just want

00:44:55,570 --> 00:45:01,120
to say point out that almost all attacks

00:44:59,020 --> 00:45:03,000
demonstrated so far have been leaking

00:45:01,120 --> 00:45:06,130
information through the l1 data cache

00:45:03,000 --> 00:45:07,750
this is the way I demonstrate in 2005 to

00:45:06,130 --> 00:45:10,180
leaked information through a micro

00:45:07,750 --> 00:45:12,310
textual side channel and it's the

00:45:10,180 --> 00:45:14,500
easiest way to do it but it is not the

00:45:12,310 --> 00:45:16,480
only way to do it as I mentioned on that

00:45:14,500 --> 00:45:19,570
slide showing all the different attacks

00:45:16,480 --> 00:45:21,340
people have come up with since 2005 you

00:45:19,570 --> 00:45:22,630
can leak information to the instruction

00:45:21,340 --> 00:45:24,280
cache through the branch predictors

00:45:22,630 --> 00:45:25,870
through the translation lookaside buffer

00:45:24,280 --> 00:45:30,850
through the cpu exclusion port

00:45:25,870 --> 00:45:34,120
contention so all even though all of the

00:45:30,850 --> 00:45:35,500
attacks demonstrated so far have been in

00:45:34,120 --> 00:45:37,120
one particular category that does not

00:45:35,500 --> 00:45:39,790
mean that that's the only way to attack

00:45:37,120 --> 00:45:44,830
systems it's just that was the easiest

00:45:39,790 --> 00:45:46,330
way and in fact you don't even need to

00:45:44,830 --> 00:45:49,720
execute instructions in order to leak

00:45:46,330 --> 00:45:51,750
information instruction pre decode leaks

00:45:49,720 --> 00:45:54,460
loads data from the l1 data cache and

00:45:51,750 --> 00:45:56,160
when that happens of course it leaves a

00:45:54,460 --> 00:45:58,810
footprint behind in the l1 data cache

00:45:56,160 --> 00:46:02,050
but the speed of P decode depends on the

00:45:58,810 --> 00:46:07,240
date bytes that are being decoded modern

00:46:02,050 --> 00:46:10,240
Intel CPUs if there's a 0 X 66 or 67

00:46:07,240 --> 00:46:17,080
byte these are prefixes that modify the

00:46:10,240 --> 00:46:19,330
the length of registers being used these

00:46:17,080 --> 00:46:21,220
don't come up very often but when they

00:46:19,330 --> 00:46:22,690
do the P decoder slows down dramatically

00:46:21,220 --> 00:46:27,010
it takes the extra three cycles to

00:46:22,690 --> 00:46:28,690
handle each of these normally the P

00:46:27,010 --> 00:46:33,100
decoders hand is parsing four

00:46:28,690 --> 00:46:35,050
instructions every clock cycle but if

00:46:33,100 --> 00:46:37,660
when those bytes comes up then the

00:46:35,050 --> 00:46:41,440
feeder will slow down if you can trick

00:46:37,660 --> 00:46:45,250
the processor into speculatively loading

00:46:41,440 --> 00:46:48,040
code and then measure how far it got in

00:46:45,250 --> 00:46:50,500
that in in the l1 cache how much data it

00:46:48,040 --> 00:46:52,900
loaded into the l1 cache that tells you

00:46:50,500 --> 00:46:55,990
something about what those bytes are who

00:46:52,900 --> 00:46:57,220
is trying to 3d code that tells me

00:46:55,990 --> 00:47:01,330
something about the information that

00:46:57,220 --> 00:47:03,070
it's passing there so even without

00:47:01,330 --> 00:47:04,570
actually executing the instructions the

00:47:03,070 --> 00:47:06,910
simple act of looking at them and

00:47:04,570 --> 00:47:09,730
decoding them into instructions reveals

00:47:06,910 --> 00:47:15,970
information so there's a lot of ways

00:47:09,730 --> 00:47:21,240
there to leak information from CPUs any

00:47:15,970 --> 00:47:24,190
questions so yeah as far as I understand

00:47:21,240 --> 00:47:26,050
the CPUs perform all this magic

00:47:24,190 --> 00:47:30,280
speculative and out of all instruction

00:47:26,050 --> 00:47:32,290
execution so we as programmers being

00:47:30,280 --> 00:47:35,680
lazy can keep the programming model of

00:47:32,290 --> 00:47:37,930
simple inorder instruction pretending

00:47:35,680 --> 00:47:38,410
our modern machines are still pdp-11 or

00:47:37,930 --> 00:47:41,140
something

00:47:38,410 --> 00:47:44,230
and still gain this vast performance

00:47:41,140 --> 00:47:47,350
boost that we now have has historically

00:47:44,230 --> 00:47:49,810
there ever been an active discussion

00:47:47,350 --> 00:47:52,450
about the programming model how we could

00:47:49,810 --> 00:47:55,150
scale CPUs was tricked in order

00:47:52,450 --> 00:47:57,880
execution while changing the programming

00:47:55,150 --> 00:48:00,820
model or has the stuff just happened

00:47:57,880 --> 00:48:05,470
because faster CPUs are successful in

00:48:00,820 --> 00:48:07,120
the marketplace I think this has just

00:48:05,470 --> 00:48:08,620
happened because people care to a

00:48:07,120 --> 00:48:11,050
performance and weren't thinking about

00:48:08,620 --> 00:48:13,210
implications of speculative execution I

00:48:11,050 --> 00:48:15,670
do not think that the solution here is

00:48:13,210 --> 00:48:18,930
to get rid of I would have an out of

00:48:15,670 --> 00:48:21,250
order execution and pipelining because I

00:48:18,930 --> 00:48:23,290
mean you might do all right with staying

00:48:21,250 --> 00:48:24,940
with in order execution but if you get

00:48:23,290 --> 00:48:28,900
rid of pipelining then you're looking at

00:48:24,940 --> 00:48:30,940
a huge performance cut I think you can

00:48:28,900 --> 00:48:33,940
design CPUs which do not have these

00:48:30,940 --> 00:48:36,940
vulnerabilities but you need to redesign

00:48:33,940 --> 00:48:40,000
all the components so if you can design

00:48:36,940 --> 00:48:41,650
your caches so that data gets loaded but

00:48:40,000 --> 00:48:44,170
it it sort of goes into some sort of

00:48:41,650 --> 00:48:46,030
temporary location and doesn't actually

00:48:44,170 --> 00:48:49,930
go into the cache until you tell it yes

00:48:46,030 --> 00:48:51,460
that load actually happened but it's

00:48:49,930 --> 00:48:52,900
it's I I think you're looking at a

00:48:51,460 --> 00:48:54,760
decade before you have CPUs that fix

00:48:52,900 --> 00:48:56,830
this okay so you besides shadow

00:48:54,760 --> 00:48:58,990
registers you also need shadow caches

00:48:56,830 --> 00:49:02,760
and shadow everything for everything you

00:48:58,990 --> 00:49:02,760
do speculatively something like that yes

00:49:05,730 --> 00:49:12,220
is there anything in risk 5 or any other

00:49:09,070 --> 00:49:16,630
sort of on the horizon technology that

00:49:12,220 --> 00:49:19,270
addresses any of this I I'm not an

00:49:16,630 --> 00:49:22,030
expert on risk 5 as far as I'm aware

00:49:19,270 --> 00:49:25,030
there is nothing published that

00:49:22,030 --> 00:49:26,620
addresses this I strongly suspect that

00:49:25,030 --> 00:49:29,430
Intel has teams that are looking at

00:49:26,620 --> 00:49:33,400
doing what I just described in terms of

00:49:29,430 --> 00:49:36,970
redesigning caches and branch predictors

00:49:33,400 --> 00:49:39,580
and translation lookaside refers so that

00:49:36,970 --> 00:49:42,160
things can happen speculatively but do

00:49:39,580 --> 00:49:44,980
not affect the visible state until the

00:49:42,160 --> 00:49:51,040
instructions are committed but I'm not

00:49:44,980 --> 00:49:52,630
aware of anything published so far is

00:49:51,040 --> 00:49:55,930
this from the outside it looks as if

00:49:52,630 --> 00:49:59,050
Intel is actually sitting on a lot more

00:49:55,930 --> 00:50:01,900
leaks and were actually not disclosing

00:49:59,050 --> 00:50:04,690
one what do you feel about that sorry

00:50:01,900 --> 00:50:07,270
can you repeat that I mean each few mas

00:50:04,690 --> 00:50:11,770
who we get a new leak coming from Intel

00:50:07,270 --> 00:50:15,270
and the timing timing attack in my

00:50:11,770 --> 00:50:18,160
opinion that Intel is actually knowing

00:50:15,270 --> 00:50:20,980
lots more of its attacks and we are just

00:50:18,160 --> 00:50:24,040
not dealing thing to the public yet what

00:50:20,980 --> 00:50:27,760
do you think of it I'm sure there are

00:50:24,040 --> 00:50:29,530
many more attacks out there and I given

00:50:27,760 --> 00:50:31,360
the conversations I've had with Intel I

00:50:29,530 --> 00:50:35,590
think they're trying to do their best to

00:50:31,360 --> 00:50:39,400
get things fixed the we can maybe I like

00:50:35,590 --> 00:50:41,020
about the exact timing of do you wait

00:50:39,400 --> 00:50:44,260
until everybody's got a fix or do you

00:50:41,020 --> 00:50:48,280
publish something and hope that most

00:50:44,260 --> 00:50:49,780
people get things fixed in time I'm I'm

00:50:48,280 --> 00:50:51,790
no longer FreeBSD security officers I'm

00:50:49,780 --> 00:50:57,340
not involved in those conversations I'm

00:50:51,790 --> 00:51:00,130
I'm inclined to say that Intel is trying

00:50:57,340 --> 00:51:02,470
to do the right thing here they they

00:51:00,130 --> 00:51:04,390
have come a long way since 2005 when

00:51:02,470 --> 00:51:07,720
they just watched it you know sweep

00:51:04,390 --> 00:51:09,370
things under the rug whether they have

00:51:07,720 --> 00:51:11,140
people who understand how to deal with

00:51:09,370 --> 00:51:12,250
the open source community I mean are

00:51:11,140 --> 00:51:13,480
they right they have some whether

00:51:12,250 --> 00:51:15,330
they're in the right position something

00:51:13,480 --> 00:51:18,420
I don't know but

00:51:15,330 --> 00:51:21,020
my my general feeling is that they are

00:51:18,420 --> 00:51:24,600
they're trying to do the right thing and

00:51:21,020 --> 00:51:32,460
you know nobody gets everything right

00:51:24,600 --> 00:51:34,260
all the time we need to get ready for

00:51:32,460 --> 00:51:35,670
the next stalk but thank you very much

00:51:34,260 --> 00:51:43,280
for your talk

00:51:35,670 --> 00:51:43,280
[Applause]

00:51:48,349 --> 00:51:50,410

YouTube URL: https://www.youtube.com/watch?v=UNoP3qVyU8w


