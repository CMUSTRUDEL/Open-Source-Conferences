Title: Rust: Systems Programmers Can Have Nice Things
Publication date: 2019-10-27
Playlist: EuroBSDCon 2019, Norway
Description: 
	Arun Thomas presents.

Rust is a new programming language, originally from Mozilla, that combines the safety and productivity of a high-level language with the performance and low-level control of a traditional systems language. Rust achieves this combination through clever and pragmatic programming language design â€” along with awesome tooling and libraries.

In this talk, I will dive into the features that make Rust the right choice for 21st-century systems programming. I will give a general introduction to the language and an overview of the Rust ecosystem. I will also walk through the process of developing Rust on BSD.

Arun Thomas

Arun Thomas is an operating systems researcher and an open source developer. He got his first taste of BSD in 2002.

Arun is a Principal Scientist at Draper Laboratory. At Draper, Arun leads the DARPA-funded SSITH/HOPE project, a research collaboration with the University of Pennsylvania, MIT, PSU, INRIA, Dover Microsystems, and Dornerworks to develop a hardware security architecture that enables flexible, verified policy enforcement on RISC-V. Recently, he has been exploring the use of Rust as a foundational technology for building secure systems. Arun has spoken about systems programming topics at ARM TechCon, the Embedded Systems Conference (ESC), BSDCan, EuroBSDcon, BSDTW, FOSDEM, Systems We Love, the RISC-V Workshop, and the Oxidize Embedded Rust Conference.
Captions: 
	00:00:29,820 --> 00:00:32,449
yeah

00:01:08,950 --> 00:01:12,059
[Music]

00:01:55,450 --> 00:01:58,609
[Music]

00:02:05,690 --> 00:02:20,930
the 11:30 talk showing and rotating

00:02:17,490 --> 00:02:25,710
credentials sadly not going to happen

00:02:20,930 --> 00:02:28,350
instead eric is going to talk about what

00:02:25,710 --> 00:02:32,750
he may or may not have learned from sent

00:02:28,350 --> 00:02:36,810
mail so you might want to go there and

00:02:32,750 --> 00:02:39,000
now for our actual scheduled talk please

00:02:36,810 --> 00:02:40,740
welcome Aaron Thomas he's going to talk

00:02:39,000 --> 00:02:42,330
about what happens when you use

00:02:40,740 --> 00:03:05,880
flamethrower

00:02:42,330 --> 00:03:09,959
on an operating system welcome him check

00:03:05,880 --> 00:03:12,540
check okay all right cool

00:03:09,959 --> 00:03:14,250
start over then my name is aroun Thomas

00:03:12,540 --> 00:03:15,750
and my talk is titled rust systems

00:03:14,250 --> 00:03:18,330
programmers can have nice things

00:03:15,750 --> 00:03:20,390
thanks for coming in it's still pretty

00:03:18,330 --> 00:03:22,709
early in the morning I appreciate it all

00:03:20,390 --> 00:03:26,220
right how many of you consider yourself

00:03:22,709 --> 00:03:27,780
a systems programmer okay most of the

00:03:26,220 --> 00:03:30,600
room

00:03:27,780 --> 00:03:32,820
yes programming is fun but it's like

00:03:30,600 --> 00:03:34,170
it's pretty painful I don't know if

00:03:32,820 --> 00:03:37,590
you've read this piece by James Mickens

00:03:34,170 --> 00:03:40,530
but like really resonates for me so I've

00:03:37,590 --> 00:03:42,630
liked the quotes that you read it says a

00:03:40,530 --> 00:03:44,400
systems programmer has seen the terrors

00:03:42,630 --> 00:03:47,100
of the world and understood the

00:03:44,400 --> 00:03:49,049
intrinsic horror of existence and this

00:03:47,100 --> 00:03:50,400
is sort of like what it is to be a

00:03:49,049 --> 00:03:53,040
systems programmer right you see a lot

00:03:50,400 --> 00:03:54,420
of like really gnarly nasty stuff you're

00:03:53,040 --> 00:03:56,730
looking at like Hardware bugs

00:03:54,420 --> 00:03:58,440
concurrency stuff there's bugs at all

00:03:56,730 --> 00:04:00,299
layers of the stack compiler could be

00:03:58,440 --> 00:04:03,510
broken it's like it's a lot of pain

00:04:00,299 --> 00:04:06,150
right so that's just kind of the life

00:04:03,510 --> 00:04:07,920
that we lead and but I'm wondering if

00:04:06,150 --> 00:04:10,080
maybe it doesn't have to be that way or

00:04:07,920 --> 00:04:13,459
maybe it could be a little bit less

00:04:10,080 --> 00:04:16,190
painful so I make system software hard

00:04:13,459 --> 00:04:17,959
there's a few things one the stakes are

00:04:16,190 --> 00:04:19,910
high so system software is critical to

00:04:17,959 --> 00:04:21,139
enforcing safety and security it's the

00:04:19,910 --> 00:04:22,910
foundation that all the other software

00:04:21,139 --> 00:04:25,580
on the system runs on so like you have

00:04:22,910 --> 00:04:26,960
to make sure it works so when I when I

00:04:25,580 --> 00:04:29,570
say system software I mean things like

00:04:26,960 --> 00:04:31,610
kernels hypervisors firmware boot

00:04:29,570 --> 00:04:33,680
loaders embedded software language

00:04:31,610 --> 00:04:35,030
language runtimes and even browsers or I

00:04:33,680 --> 00:04:36,710
would consider system software now

00:04:35,030 --> 00:04:40,370
they're basically mini OSS they're

00:04:36,710 --> 00:04:42,289
really complicated mini oasis and

00:04:40,370 --> 00:04:44,930
they're usually written in C or C++ for

00:04:42,289 --> 00:04:47,389
performance but the problem is that C

00:04:44,930 --> 00:04:49,850
and C++ are not memory safe and as we've

00:04:47,389 --> 00:04:52,760
learned over the last few decades that

00:04:49,850 --> 00:04:53,630
causes a lot of problems so you see a

00:04:52,760 --> 00:04:55,430
lot of these memory corruption

00:04:53,630 --> 00:04:57,350
vulnerabilities they bound they're

00:04:55,430 --> 00:05:00,320
exploited there's a recent Microsoft

00:04:57,350 --> 00:05:02,600
study about this so Microsoft found that

00:05:00,320 --> 00:05:04,729
memory unsafety is a problem they found

00:05:02,600 --> 00:05:08,000
that Microsoft found essentially it's

00:05:04,729 --> 00:05:09,590
yeah not a surprise but in their

00:05:08,000 --> 00:05:12,470
products they did a study over I think

00:05:09,590 --> 00:05:14,509
like from 2006 to 2018 and they found

00:05:12,470 --> 00:05:16,009
that 70% of the CVS and their products

00:05:14,509 --> 00:05:18,590
each year continue to be memory safety

00:05:16,009 --> 00:05:20,479
issues so this was presented pretty

00:05:18,590 --> 00:05:23,090
recently at the blue hat conference that

00:05:20,479 --> 00:05:24,650
Microsoft organizes and now all the BSD

00:05:23,090 --> 00:05:26,150
programmers a much better programmers

00:05:24,650 --> 00:05:28,400
than the ones that Microsoft of course

00:05:26,150 --> 00:05:30,050
and we're all 10x programmers but still

00:05:28,400 --> 00:05:32,180
we encounter a lot of these same issues

00:05:30,050 --> 00:05:34,699
memory safety is a problem industry-wide

00:05:32,180 --> 00:05:37,310
or memory safety bugs and memory

00:05:34,699 --> 00:05:39,680
corruption vulnerabilities so what can

00:05:37,310 --> 00:05:41,570
we do about it so Microsoft had a series

00:05:39,680 --> 00:05:43,550
of posts about this and one of the

00:05:41,570 --> 00:05:44,780
things that they are interested in

00:05:43,550 --> 00:05:47,449
exploring and announce that they're

00:05:44,780 --> 00:05:49,190
exploring is rust so they said we

00:05:47,449 --> 00:05:50,780
believe rust changes the game when it

00:05:49,190 --> 00:05:52,729
comes to writing safe system software

00:05:50,780 --> 00:05:53,990
rust provides the performance and

00:05:52,729 --> 00:05:55,940
control needed to write low-level

00:05:53,990 --> 00:05:57,530
systems while empowering software

00:05:55,940 --> 00:05:59,120
developers to write robust secure

00:05:57,530 --> 00:06:00,740
programs there's a lot of people who

00:05:59,120 --> 00:06:03,039
were kind of getting on the kind of like

00:06:00,740 --> 00:06:05,479
rust bandwagon for I think good reasons

00:06:03,039 --> 00:06:08,270
Intel also starting to invest in rust

00:06:05,479 --> 00:06:10,430
there was a talk at the I guess it was

00:06:08,270 --> 00:06:12,860
Intel's open source technology summit

00:06:10,430 --> 00:06:15,770
there was a guy who was leading up the

00:06:12,860 --> 00:06:17,510
FFI working group to improve so rust

00:06:15,770 --> 00:06:19,699
actually is really good interoperability

00:06:17,510 --> 00:06:21,169
with C but they're making sure to get

00:06:19,699 --> 00:06:22,820
rid of all the kind of like remaining

00:06:21,169 --> 00:06:23,749
issues basically and so this guy's

00:06:22,820 --> 00:06:26,269
leaning that up and

00:06:23,749 --> 00:06:28,189
he gave a talk about Intel's roll with

00:06:26,269 --> 00:06:30,049
rust and sort of the future of systems

00:06:28,189 --> 00:06:32,029
programming so you see a lot of people

00:06:30,049 --> 00:06:34,519
who are interested in rust nowadays and

00:06:32,029 --> 00:06:37,129
basically a lot for basically because

00:06:34,519 --> 00:06:38,539
it's a it's a safe language but it's low

00:06:37,129 --> 00:06:41,089
level enough that you can actually you

00:06:38,539 --> 00:06:43,639
know do operating systems and that kind

00:06:41,089 --> 00:06:45,439
of thing so that's kind of like the

00:06:43,639 --> 00:06:48,049
motivation and so I'll kind of give you

00:06:45,439 --> 00:06:49,249
the quick overview of the talk so the

00:06:48,049 --> 00:06:51,529
systems programmers can have nice things

00:06:49,249 --> 00:06:53,569
that's not me that's a quote I got from

00:06:51,529 --> 00:06:55,099
a robert O'Callahan he's a engineer at

00:06:53,569 --> 00:06:58,429
Mozilla so I was in a blog post I

00:06:55,099 --> 00:07:00,469
thought it was pretty fitting so the

00:06:58,429 --> 00:07:03,409
talk has three parts first I'll give you

00:07:00,469 --> 00:07:04,369
a quick pitch about why rust it'll be

00:07:03,409 --> 00:07:05,899
pretty high level I'll talk about some

00:07:04,369 --> 00:07:07,249
of the features I'll show you a little

00:07:05,899 --> 00:07:09,079
bit of syntax but I don't really have

00:07:07,249 --> 00:07:10,669
time to go do a deep tour of the

00:07:09,079 --> 00:07:12,050
language but I'll give you links to

00:07:10,669 --> 00:07:13,969
resources if you want to dig in more

00:07:12,050 --> 00:07:15,409
about like the various features I kind

00:07:13,969 --> 00:07:17,269
of get up to speed the language just

00:07:15,409 --> 00:07:18,739
takes a little bit of time to get up to

00:07:17,269 --> 00:07:20,689
speed with so there was enough time in

00:07:18,739 --> 00:07:21,949
this talk the second part of the talk

00:07:20,689 --> 00:07:23,899
we'll talk about rust for system

00:07:21,949 --> 00:07:25,969
software so you're starting to see more

00:07:23,899 --> 00:07:28,639
and more people applying rust to

00:07:25,969 --> 00:07:30,110
building system software in industry and

00:07:28,639 --> 00:07:32,449
in academia but I'll focus more on

00:07:30,110 --> 00:07:36,559
industry and then finally I'll give you

00:07:32,449 --> 00:07:38,599
a quick like a quick refresher on or

00:07:36,559 --> 00:07:40,909
like quick description of how to get up

00:07:38,599 --> 00:07:44,209
to get to how to get BSC get rust

00:07:40,909 --> 00:07:46,669
running on BSD and so basically it's

00:07:44,209 --> 00:07:48,949
pretty easy to do and the packages are

00:07:46,669 --> 00:07:51,019
actually mmm you can actually grab bruss

00:07:48,949 --> 00:07:52,219
packages using standard package manager

00:07:51,019 --> 00:07:56,089
so it's actually pretty easy to get up

00:07:52,219 --> 00:07:59,239
and going okay so why rust why is rust

00:07:56,089 --> 00:08:03,229
interesting there's a lot of hype around

00:07:59,239 --> 00:08:04,489
rust why why should you care so first

00:08:03,229 --> 00:08:08,419
I'll give the disclaimer I actually like

00:08:04,489 --> 00:08:09,949
C I think it's fun it's uh it's maybe

00:08:08,419 --> 00:08:11,659
it's Stockholm Syndrome I don't know but

00:08:09,949 --> 00:08:13,159
like it's like you feel the power right

00:08:11,659 --> 00:08:14,239
every jjigae you can do whatever you

00:08:13,159 --> 00:08:16,789
want

00:08:14,239 --> 00:08:18,409
but I think maybe it's not the best

00:08:16,789 --> 00:08:21,249
language for building large-scale

00:08:18,409 --> 00:08:23,719
systems now that we have other options

00:08:21,249 --> 00:08:26,059
so the thing is like I mean seas great i

00:08:23,719 --> 00:08:28,159
mean c is thing that c is it's almost 50

00:08:26,059 --> 00:08:29,659
years old right and it turns out

00:08:28,159 --> 00:08:31,269
programming languages have evolved a bit

00:08:29,659 --> 00:08:33,199
in the last 50 years

00:08:31,269 --> 00:08:34,669
programming languages researchers at

00:08:33,199 --> 00:08:36,259
academia have been doing things industry

00:08:34,669 --> 00:08:37,250
people been doing things and maybe we

00:08:36,259 --> 00:08:38,930
should use language that's

00:08:37,250 --> 00:08:40,099
some of these lessons especially when

00:08:38,930 --> 00:08:42,349
you have to worry about all these

00:08:40,099 --> 00:08:44,780
vulnerabilities and securities much more

00:08:42,349 --> 00:08:45,820
much more serious problem as is safety

00:08:44,780 --> 00:08:49,220
and if you want to build really

00:08:45,820 --> 00:08:50,450
rock-solid systems I feel like maybe C

00:08:49,220 --> 00:08:51,920
is not the best option if you're

00:08:50,450 --> 00:08:53,660
building a new system you should

00:08:51,920 --> 00:08:55,010
definitely consider safe languages like

00:08:53,660 --> 00:08:57,020
rust I mean there are other options as

00:08:55,010 --> 00:09:00,800
well but I think rust is a particularly

00:08:57,020 --> 00:09:03,470
good option so I think rust does makes a

00:09:00,800 --> 00:09:05,600
it's a good blend of the pitch was

00:09:03,470 --> 00:09:07,340
basically rust is a safe fast productive

00:09:05,600 --> 00:09:09,170
systems foreign language and so I think

00:09:07,340 --> 00:09:11,150
the thing that it does well is it gives

00:09:09,170 --> 00:09:12,620
you a lot of the high level the

00:09:11,150 --> 00:09:13,970
productivity of high-level high level

00:09:12,620 --> 00:09:16,430
languages and the safety of high level

00:09:13,970 --> 00:09:19,970
languages but also it has the

00:09:16,430 --> 00:09:21,410
performance that's like C or C++ so it

00:09:19,970 --> 00:09:23,510
kind of blends the productivity of a

00:09:21,410 --> 00:09:25,250
high level language with the really like

00:09:23,510 --> 00:09:26,480
low level control and the performance

00:09:25,250 --> 00:09:28,010
that you need for something like

00:09:26,480 --> 00:09:31,790
operating system kernels language

00:09:28,010 --> 00:09:34,040
runtimes and things like that so where

00:09:31,790 --> 00:09:37,400
does rust come from so Mozilla research

00:09:34,040 --> 00:09:38,780
originally created language they they're

00:09:37,400 --> 00:09:40,550
neutral use case was they're creating

00:09:38,780 --> 00:09:41,990
this new experimental browser engine so

00:09:40,550 --> 00:09:45,140
they wanted to do something they want to

00:09:41,990 --> 00:09:48,290
start over basically they had Firefox

00:09:45,140 --> 00:09:49,460
which and I mean Firefox is a good

00:09:48,290 --> 00:09:50,750
browser but they wanted to see if they

00:09:49,460 --> 00:09:52,490
could push it farther especially I'm

00:09:50,750 --> 00:09:53,780
like multicores and your architectures

00:09:52,490 --> 00:09:55,130
looking more reliable architecture so

00:09:53,780 --> 00:09:56,600
they're rebuilding this new browser

00:09:55,130 --> 00:09:57,710
engine and they've sort of at the same

00:09:56,600 --> 00:10:01,520
time we're Co designing a new language

00:09:57,710 --> 00:10:04,070
to design this browser engine in so over

00:10:01,520 --> 00:10:07,370
time the language matured it's been I

00:10:04,070 --> 00:10:10,280
guess 1.0 was four years ago and then in

00:10:07,370 --> 00:10:12,290
2016 they actually started taking some

00:10:10,280 --> 00:10:14,839
of these components from servo that were

00:10:12,290 --> 00:10:17,320
written in rust and they actually

00:10:14,839 --> 00:10:20,300
started shipping them in Firefox so

00:10:17,320 --> 00:10:23,630
Mozilla has a cute term for this process

00:10:20,300 --> 00:10:25,339
of converting Firefox into like rust

00:10:23,630 --> 00:10:29,000
components it's called oxidization which

00:10:25,339 --> 00:10:32,420
I thought was cool and they've kind of

00:10:29,000 --> 00:10:34,160
been focusing on the pieces of Firefox

00:10:32,420 --> 00:10:36,320
that will either of security or

00:10:34,160 --> 00:10:38,780
performance so one of the things they

00:10:36,320 --> 00:10:41,360
looked at is they replace there and

00:10:38,780 --> 00:10:43,400
before metadata parser so this is a this

00:10:41,360 --> 00:10:45,470
is lip stage-fright it was there's a big

00:10:43,400 --> 00:10:47,900
vulnerability in android previously it's

00:10:45,470 --> 00:10:49,670
a pretty buggy thing to do and so by

00:10:47,900 --> 00:10:50,550
getting rid of this vulnerable parser

00:10:49,670 --> 00:10:52,500
they were able to make

00:10:50,550 --> 00:10:55,290
Firefox substantially safer at least for

00:10:52,500 --> 00:10:57,690
this particular attack vector and then

00:10:55,290 --> 00:11:00,750
for performance they they they basically

00:10:57,690 --> 00:11:04,230
use this they they brought over the

00:11:00,750 --> 00:11:06,020
stylo parallel CSS engine and using rust

00:11:04,230 --> 00:11:08,490
concurrency primitives they were able to

00:11:06,020 --> 00:11:10,170
substantially speed-up page loads I

00:11:08,490 --> 00:11:11,760
think by like 70 percent or something

00:11:10,170 --> 00:11:13,110
like that it was Australis abstention

00:11:11,760 --> 00:11:15,510
depending on how many cores you have but

00:11:13,110 --> 00:11:16,770
it seemed to pair a lot as well so rust

00:11:15,510 --> 00:11:19,709
has been having pretty good experience

00:11:16,770 --> 00:11:21,570
like applying rust to these sorts of

00:11:19,709 --> 00:11:23,310
systems problems and so they're going

00:11:21,570 --> 00:11:26,520
through this process of like over time

00:11:23,310 --> 00:11:28,589
upgrading Firefox to use more and more

00:11:26,520 --> 00:11:30,000
rust components really focusing on the

00:11:28,589 --> 00:11:36,750
security critical and performance

00:11:30,000 --> 00:11:39,240
critical pieces of the stack so the kind

00:11:36,750 --> 00:11:42,000
of overall pitch for rust is that it's

00:11:39,240 --> 00:11:43,620
performance is on par with C you have

00:11:42,000 --> 00:11:44,580
memory safety without garbage collection

00:11:43,620 --> 00:11:46,500
overheads which is kind of an

00:11:44,580 --> 00:11:48,360
interesting trade-off so typically with

00:11:46,500 --> 00:11:49,740
safe languages your you have to deal

00:11:48,360 --> 00:11:51,209
with the overheads if garbage collection

00:11:49,740 --> 00:11:52,740
or you have to deal with like a

00:11:51,209 --> 00:11:54,510
mandatory runtime and that's not really

00:11:52,740 --> 00:11:55,890
ideal for low-level system software

00:11:54,510 --> 00:11:58,680
especially if you're doing like deeply

00:11:55,890 --> 00:12:02,070
embedded kinds of things the only thing

00:11:58,680 --> 00:12:03,930
that rust has is thread safety data race

00:12:02,070 --> 00:12:06,060
freedom what they call fearless

00:12:03,930 --> 00:12:07,560
concurrency and so there's no currency

00:12:06,060 --> 00:12:09,540
bugs associated with multi-threaded code

00:12:07,560 --> 00:12:11,070
and the way they do this is they

00:12:09,540 --> 00:12:12,690
basically you have a sophisticated type

00:12:11,070 --> 00:12:14,670
system that would tracks ownership and

00:12:12,690 --> 00:12:20,250
it enforces the memory and thread safety

00:12:14,670 --> 00:12:21,899
properties statically compiled level so

00:12:20,250 --> 00:12:23,430
in addition it's a fairly productive

00:12:21,899 --> 00:12:24,990
language if you're doing systems

00:12:23,430 --> 00:12:27,589
programming you need good inner

00:12:24,990 --> 00:12:30,000
interoperable interoperability with C

00:12:27,589 --> 00:12:31,079
this is there's a lot of C software

00:12:30,000 --> 00:12:33,620
that's out there so you need to make

00:12:31,079 --> 00:12:36,329
sure the RUS code interoperates with it

00:12:33,620 --> 00:12:39,270
and it also number has a number of fancy

00:12:36,329 --> 00:12:41,399
language features that you know gets

00:12:39,270 --> 00:12:43,860
programming languages people excited

00:12:41,399 --> 00:12:45,839
things like type inference which also is

00:12:43,860 --> 00:12:47,820
just generally useful algebraic data

00:12:45,839 --> 00:12:50,100
types pattern matching traits generics

00:12:47,820 --> 00:12:52,709
if you're familiar with go this is kind

00:12:50,100 --> 00:12:54,089
of like interfaces sort of more for

00:12:52,709 --> 00:12:55,079
Haskell it's kind of like type classes

00:12:54,089 --> 00:12:56,310
and things like that if you're from

00:12:55,079 --> 00:13:00,140
Haskell or oh camel

00:12:56,310 --> 00:13:02,550
it also has modules hygienic macros so

00:13:00,140 --> 00:13:03,360
instead of using CPP it actually has

00:13:02,550 --> 00:13:05,130
macros that are

00:13:03,360 --> 00:13:08,519
the compiler can check and make sure you

00:13:05,130 --> 00:13:10,350
don't do anything too crazy and as like

00:13:08,519 --> 00:13:12,240
little niceties like handy literals

00:13:10,350 --> 00:13:14,370
you've got binary literals you can have

00:13:12,240 --> 00:13:16,529
literals we have underscores which makes

00:13:14,370 --> 00:13:18,990
the literals much more readable so it's

00:13:16,529 --> 00:13:21,510
a kind of a they've done a lot of these

00:13:18,990 --> 00:13:23,279
things that make it nice to use there's

00:13:21,510 --> 00:13:25,950
also a really great tooling and

00:13:23,279 --> 00:13:28,529
developer environment general so the

00:13:25,950 --> 00:13:30,360
compiler has it's pretty friendly and

00:13:28,529 --> 00:13:32,670
has useful error messages often it will

00:13:30,360 --> 00:13:34,680
tell you well it'll tell you how to fix

00:13:32,670 --> 00:13:37,410
things I mean so the the ownership model

00:13:34,680 --> 00:13:39,600
requires some getting used to but the

00:13:37,410 --> 00:13:41,040
compiler errors are generally useful and

00:13:39,600 --> 00:13:42,990
that they tell you usually how to fix

00:13:41,040 --> 00:13:44,310
the thing but you do have to get your

00:13:42,990 --> 00:13:48,300
I'll talk about the ownership model a

00:13:44,310 --> 00:13:49,769
little bit later so cargo I think is a

00:13:48,300 --> 00:13:51,180
great package manager so it's pretty

00:13:49,769 --> 00:13:53,160
nice to have like a systems language

00:13:51,180 --> 00:13:55,110
where you can easily have something that

00:13:53,160 --> 00:13:57,000
brings in packages manages all the

00:13:55,110 --> 00:13:59,760
dependencies for you you don't deal with

00:13:57,000 --> 00:14:01,740
like I don't know a crazy C mate setup

00:13:59,760 --> 00:14:03,990
or anything like that so I think cargos

00:14:01,740 --> 00:14:06,630
actually really nice and was one of the

00:14:03,990 --> 00:14:09,420
big advantages of using rust for systems

00:14:06,630 --> 00:14:10,949
programming and then like rust format I

00:14:09,420 --> 00:14:12,570
think it's great to you know have two

00:14:10,949 --> 00:14:13,890
bike shed over coating styles there's

00:14:12,570 --> 00:14:16,320
just one coding style the tool will

00:14:13,890 --> 00:14:18,930
enforce it so other languages have this

00:14:16,320 --> 00:14:22,019
like go and things like that so I like

00:14:18,930 --> 00:14:23,910
that a lot so I'm gonna kind of quickly

00:14:22,019 --> 00:14:25,140
go over a few snippets of what Russ

00:14:23,910 --> 00:14:27,209
looks like I don't really have time to

00:14:25,140 --> 00:14:29,880
go into the language in detail but uh

00:14:27,209 --> 00:14:32,279
this is what a hello world looks like so

00:14:29,880 --> 00:14:34,440
FN is how you declare a function and

00:14:32,279 --> 00:14:36,269
then you got main and then print Lin is

00:14:34,440 --> 00:14:38,760
how you print something and so the the

00:14:36,269 --> 00:14:40,949
bang the exclamation point indicates

00:14:38,760 --> 00:14:43,050
that this is a macro so this is actually

00:14:40,949 --> 00:14:44,760
using a lot of the kind of like calls

00:14:43,050 --> 00:14:46,980
like this the system call or the kind of

00:14:44,760 --> 00:14:49,350
like utilities they're actually macros

00:14:46,980 --> 00:14:53,250
so they're actually I might see these

00:14:49,350 --> 00:14:56,820
are actually safe things so here's a

00:14:53,250 --> 00:14:58,890
quick example of factorial it looks you

00:14:56,820 --> 00:15:01,560
know kind of like C ish except you know

00:14:58,890 --> 00:15:03,240
the the arguments are a little bit

00:15:01,560 --> 00:15:05,910
different there's fewer parentheses so

00:15:03,240 --> 00:15:07,350
that return argument is on the right it

00:15:05,910 --> 00:15:10,680
looks a little bit like go if you've

00:15:07,350 --> 00:15:13,730
used it so but yeah so this is kind of a

00:15:10,680 --> 00:15:13,730
standard factorial thing

00:15:13,940 --> 00:15:17,810
so one difference is if when you if you

00:15:16,670 --> 00:15:19,280
want to declare variables is how you

00:15:17,810 --> 00:15:21,380
declare them by default they're

00:15:19,280 --> 00:15:23,510
immutable so when you do let x equals

00:15:21,380 --> 00:15:25,310
two that's an immutable variable so if

00:15:23,510 --> 00:15:27,770
you try to change it then you get an

00:15:25,310 --> 00:15:30,290
error so the compiler will complain if

00:15:27,770 --> 00:15:32,150
you want to make a mutable variable you

00:15:30,290 --> 00:15:34,190
actually have to specify if to use the

00:15:32,150 --> 00:15:36,080
mutable keyword so you say let mute x

00:15:34,190 --> 00:15:39,140
equals two then you act can actually

00:15:36,080 --> 00:15:42,730
modify it so they increments it so

00:15:39,140 --> 00:15:46,850
that's what happens here so my default

00:15:42,730 --> 00:15:50,350
variables are immutable references are

00:15:46,850 --> 00:15:54,800
kind of how you do pointers in rusts so

00:15:50,350 --> 00:15:57,890
this is how you declare a vector of so

00:15:54,800 --> 00:16:00,440
one two three the ampersand is how you

00:15:57,890 --> 00:16:03,470
get a reference and so it's essentially

00:16:00,440 --> 00:16:07,730
a pointer to the same data structure and

00:16:03,470 --> 00:16:10,580
the it takes some getting used to the

00:16:07,730 --> 00:16:12,650
rules for how to do the what what rest

00:16:10,580 --> 00:16:14,360
calls this is a borrow and so the

00:16:12,650 --> 00:16:15,590
understanding the sort of type system

00:16:14,360 --> 00:16:17,750
and how borrows work is a little bit

00:16:15,590 --> 00:16:18,740
complicated and is one of the things

00:16:17,750 --> 00:16:22,790
that you'll have to get used to if you

00:16:18,740 --> 00:16:25,850
get into rest stuff so one of the things

00:16:22,790 --> 00:16:28,790
that happens a lot of what Russ does is

00:16:25,850 --> 00:16:31,100
you get into this process where you're

00:16:28,790 --> 00:16:34,040
trying to make sure that you can satisfy

00:16:31,100 --> 00:16:35,960
the invariants that Brust is trying to

00:16:34,040 --> 00:16:37,400
guarantee and one of the things that it

00:16:35,960 --> 00:16:39,080
tries to make sure is that there's only

00:16:37,400 --> 00:16:40,850
one mutable reference in a given scope

00:16:39,080 --> 00:16:42,800
on this is important for data race

00:16:40,850 --> 00:16:46,220
freedom so in this example you have a

00:16:42,800 --> 00:16:48,440
mutable string and then you basically

00:16:46,220 --> 00:16:51,140
have a couple immutable references

00:16:48,440 --> 00:16:53,210
that's fine but then when in our three

00:16:51,140 --> 00:16:54,500
or if you can see that but there's

00:16:53,210 --> 00:16:55,910
another immutable reference since you

00:16:54,500 --> 00:16:57,560
have two mutable references at the same

00:16:55,910 --> 00:17:00,020
time the compiler gives you an error

00:16:57,560 --> 00:17:01,610
that gets checked statically so this

00:17:00,020 --> 00:17:04,640
sort of gives you the kind of flavor of

00:17:01,610 --> 00:17:06,890
sort of what the memory like sort of

00:17:04,640 --> 00:17:09,140
what reference is and what the syntax

00:17:06,890 --> 00:17:11,330
looks like a little bit so this part is

00:17:09,140 --> 00:17:14,720
actually one of the one of the pieces of

00:17:11,330 --> 00:17:16,339
language that is it's fairly innovative

00:17:14,720 --> 00:17:18,410
it's where a lot of the kind of

00:17:16,339 --> 00:17:21,459
interesting guarantees of Russ come from

00:17:18,410 --> 00:17:23,600
but also takes some getting used to so

00:17:21,459 --> 00:17:24,949
it's powerful but it takes some time to

00:17:23,600 --> 00:17:26,480
fully grok

00:17:24,949 --> 00:17:28,639
so there's some simple rules what the

00:17:26,480 --> 00:17:31,399
compiler does essentially is it'll track

00:17:28,639 --> 00:17:33,379
the ownership in borrowing and use and

00:17:31,399 --> 00:17:35,960
essentially does this to determine

00:17:33,379 --> 00:17:38,659
object lifetimes and restrict mutation

00:17:35,960 --> 00:17:40,759
of states so the way these references

00:17:38,659 --> 00:17:42,679
work is you want to make the compiler

00:17:40,759 --> 00:17:45,590
basically allow you to do mutation or

00:17:42,679 --> 00:17:47,269
allow sharing so you can't modify shared

00:17:45,590 --> 00:17:48,879
mutable state because then you'd have a

00:17:47,269 --> 00:17:53,299
you could potentially have a data race

00:17:48,879 --> 00:17:55,850
so the rules at a high level are each

00:17:53,299 --> 00:17:58,009
value has a single single variable it's

00:17:55,850 --> 00:18:00,139
the owner of that variable and you can

00:17:58,009 --> 00:18:01,730
only have one owner at a time and when

00:18:00,139 --> 00:18:04,399
the owner goes out of skin out of scope

00:18:01,730 --> 00:18:07,309
the value will be dropped so the rules

00:18:04,399 --> 00:18:09,220
here seem fairly simple but sort of like

00:18:07,309 --> 00:18:13,039
applying it to code requires practice

00:18:09,220 --> 00:18:16,309
and I won't go into it in very great

00:18:13,039 --> 00:18:17,539
detail but this this model does have a

00:18:16,309 --> 00:18:19,220
fair amount of power because this is

00:18:17,539 --> 00:18:21,230
where you get a lot of safety so by

00:18:19,220 --> 00:18:24,200
following these rules you can get memory

00:18:21,230 --> 00:18:26,090
safety and thread safety but if you want

00:18:24,200 --> 00:18:27,980
to get into it a bit more deeply there's

00:18:26,090 --> 00:18:30,619
a good chapter and the the rust book and

00:18:27,980 --> 00:18:33,169
also the the part of the kind of the

00:18:30,619 --> 00:18:34,580
canonical do the free rust book that's

00:18:33,169 --> 00:18:36,409
online and also the programming rust

00:18:34,580 --> 00:18:40,100
book both hasn't both have good chapters

00:18:36,409 --> 00:18:41,929
on this so now I'll talk about so that's

00:18:40,100 --> 00:18:43,309
kind of a really quick description of

00:18:41,929 --> 00:18:46,730
like rust I didn't really get into a lot

00:18:43,309 --> 00:18:48,169
of the advanced features but I'll give

00:18:46,730 --> 00:18:50,720
you references for digging more into

00:18:48,169 --> 00:18:52,159
that so now I'll talk more about how

00:18:50,720 --> 00:18:54,409
rust is being used for system software

00:18:52,159 --> 00:18:57,519
so there's been increasing use for a

00:18:54,409 --> 00:18:59,779
various system software use cases

00:18:57,519 --> 00:19:02,659
there's several operating systems that

00:18:59,779 --> 00:19:04,639
are being written in rust so a lot of

00:19:02,659 --> 00:19:06,289
them are sort of you know OS OS dev

00:19:04,639 --> 00:19:08,690
life-like projects so basically

00:19:06,289 --> 00:19:09,559
hobbyists writing operating systems but

00:19:08,690 --> 00:19:12,279
there's a couple ones that are

00:19:09,559 --> 00:19:13,789
particularly I think talk is an OS for

00:19:12,279 --> 00:19:15,740
microcontrollers it was originally a

00:19:13,789 --> 00:19:18,230
research project from I think it was

00:19:15,740 --> 00:19:20,200
Stanford Princeton and Michigan so

00:19:18,230 --> 00:19:22,460
they're looking at building a

00:19:20,200 --> 00:19:24,679
microcontroller OS for really deeply

00:19:22,460 --> 00:19:27,230
embedded systems where you actually care

00:19:24,679 --> 00:19:30,110
about trust and you have mutually

00:19:27,230 --> 00:19:31,340
distrusting components and they they

00:19:30,110 --> 00:19:33,169
were able to get multi programming

00:19:31,340 --> 00:19:34,970
running and 64k of memory which i

00:19:33,169 --> 00:19:37,010
thought was pretty cool so if you want

00:19:34,970 --> 00:19:39,740
to read up more on this this paper

00:19:37,010 --> 00:19:41,900
SOS p17 was pretty interesting there's

00:19:39,740 --> 00:19:43,220
also if you're into like OS dev like

00:19:41,900 --> 00:19:44,270
things like I kind of like small

00:19:43,220 --> 00:19:45,920
operating systems

00:19:44,270 --> 00:19:47,480
there's redox they're kind of ramp

00:19:45,920 --> 00:19:49,340
lamenting a clean slate rust kernel and

00:19:47,480 --> 00:19:51,200
then there's this guy I think Phillip

00:19:49,340 --> 00:19:52,880
Opperman he's writing a blog series on

00:19:51,200 --> 00:19:54,020
how to write no ice and rust and that's

00:19:52,880 --> 00:19:58,490
kind of cool if you're interested in

00:19:54,020 --> 00:20:00,680
digging into that so there's a number of

00:19:58,490 --> 00:20:02,840
people doing hypervisors in rust nap so

00:20:00,680 --> 00:20:05,870
Google Amazon and Intel or developing

00:20:02,840 --> 00:20:10,580
rust based hypervisors so there's the

00:20:05,870 --> 00:20:12,050
chromium cross VM hypervisor and then

00:20:10,580 --> 00:20:14,210
that's from Google and then fire

00:20:12,050 --> 00:20:16,280
crackers from Amazon they forked cross

00:20:14,210 --> 00:20:18,830
VM and they kind of changed some things

00:20:16,280 --> 00:20:20,930
to meet their design case there's meet

00:20:18,830 --> 00:20:23,060
some of their design considerations and

00:20:20,930 --> 00:20:25,610
they're now deploying it as a micro VM

00:20:23,060 --> 00:20:28,430
in AWS and then Intel is developing this

00:20:25,610 --> 00:20:31,400
cloud hypervisor thing so they were all

00:20:28,430 --> 00:20:33,890
kind of using similar code and kind of

00:20:31,400 --> 00:20:35,090
forking off each other and so recently I

00:20:33,890 --> 00:20:36,680
guess in the last few months they've

00:20:35,090 --> 00:20:38,900
gotten together and they're there's this

00:20:36,680 --> 00:20:41,060
rust vmm initiative to kind of increase

00:20:38,900 --> 00:20:43,460
sharing collaboration between the three

00:20:41,060 --> 00:20:44,990
hypervisors so it's a it's kind of cool

00:20:43,460 --> 00:20:48,680
that there's like three different groups

00:20:44,990 --> 00:20:49,850
working on hypervisors I think also Red

00:20:48,680 --> 00:20:51,410
Hat is involved in this and a couple

00:20:49,850 --> 00:20:54,950
other people so it seems like a pretty

00:20:51,410 --> 00:20:56,000
interesting initiative so this thing I

00:20:54,950 --> 00:20:57,650
thought was particularly cool so I was

00:20:56,000 --> 00:21:00,620
at the risk 5 workshop and I was giving

00:20:57,650 --> 00:21:03,110
a rust talk there about rust support on

00:21:00,620 --> 00:21:04,370
risk 5 and one of the core of you

00:21:03,110 --> 00:21:06,800
developers came up to me and said hey

00:21:04,370 --> 00:21:08,150
we're we're trying to rewrite coreboot

00:21:06,800 --> 00:21:10,460
and rust and I was like whoa that's

00:21:08,150 --> 00:21:12,170
pretty cool so they they I like the name

00:21:10,460 --> 00:21:14,810
so they named it or boot so it's core

00:21:12,170 --> 00:21:16,790
boot with C removed so those kind of

00:21:14,810 --> 00:21:19,040
clever and so they gave a talk at the

00:21:16,790 --> 00:21:22,280
open source firmware conference like a

00:21:19,040 --> 00:21:23,390
month ago or so and basically they they

00:21:22,280 --> 00:21:24,470
got it working and apparently they're

00:21:23,390 --> 00:21:26,900
pretty happy with like the performance

00:21:24,470 --> 00:21:28,670
and now it's going there they don't have

00:21:26,900 --> 00:21:31,990
any C in there it's just rust in some

00:21:28,670 --> 00:21:34,940
assembly so it's pretty it's pretty cool

00:21:31,990 --> 00:21:38,660
and they have initial support for risk 5

00:21:34,940 --> 00:21:40,400
which is pretty exciting so Microsoft is

00:21:38,660 --> 00:21:42,350
using rust so they're using it for their

00:21:40,400 --> 00:21:45,590
IOT edge device so that is a security

00:21:42,350 --> 00:21:47,690
demon thing that they're using rust for

00:21:45,590 --> 00:21:50,090
Google is now using rust for a fuchsia

00:21:47,690 --> 00:21:52,430
components apparently they I don't know

00:21:50,090 --> 00:21:53,780
if there's gonna be the official Network

00:21:52,430 --> 00:21:55,250
stack but they rewrote the network stack

00:21:53,780 --> 00:21:56,570
and some of their OS components in there

00:21:55,250 --> 00:22:00,020
so that's pretty interesting fuchsia is

00:21:56,570 --> 00:22:01,220
this next-generation kernel from Google

00:22:00,020 --> 00:22:03,020
I don't know if they're actually gonna

00:22:01,220 --> 00:22:04,190
end up using it but they've got a bunch

00:22:03,020 --> 00:22:06,290
of people working on and it seems pretty

00:22:04,190 --> 00:22:07,430
interesting especially if you if you

00:22:06,290 --> 00:22:10,550
were just in micro kernels and things

00:22:07,430 --> 00:22:14,090
like that Facebook has been using rust

00:22:10,550 --> 00:22:15,650
for their libero cryptocurrency so you

00:22:14,090 --> 00:22:20,860
know rust has arrived because it's now

00:22:15,650 --> 00:22:20,860
being used for cryptocurrency and then

00:22:22,840 --> 00:22:28,310
and then also parts of the H HBM PHP

00:22:26,930 --> 00:22:30,470
runtime which is the runtime that runs

00:22:28,310 --> 00:22:32,270
facebook.com/ they're rewriting some

00:22:30,470 --> 00:22:34,100
parts of oh camel a lot of the old camel

00:22:32,270 --> 00:22:36,260
code into rust so you're starting to see

00:22:34,100 --> 00:22:37,940
more deployment there as well until

00:22:36,260 --> 00:22:39,500
contributed to vxworks target which we

00:22:37,940 --> 00:22:41,840
thought was kind of cool so you can

00:22:39,500 --> 00:22:44,210
actually run rust code and vxworks if

00:22:41,840 --> 00:22:46,640
you want to do that Mozilla and fastly

00:22:44,210 --> 00:22:48,800
are writing web assembly runtimes so

00:22:46,640 --> 00:22:51,590
there's this the Mozilla ones buy some

00:22:48,800 --> 00:22:53,750
time and the fastly ones loose it so

00:22:51,590 --> 00:22:54,620
it's kind of cool actually so like web

00:22:53,750 --> 00:22:55,820
assembly is the thing that was

00:22:54,620 --> 00:22:57,560
originally for the browser so you can

00:22:55,820 --> 00:22:58,970
run native code in the browser but now

00:22:57,560 --> 00:23:00,620
people want to run it like outside of

00:22:58,970 --> 00:23:01,880
the browser so people are coming off of

00:23:00,620 --> 00:23:03,530
system call interfaces

00:23:01,880 --> 00:23:06,410
this isn't called huazi where you can

00:23:03,530 --> 00:23:08,570
run like web assembly on basically like

00:23:06,410 --> 00:23:09,980
anything so it's a kind of an

00:23:08,570 --> 00:23:12,340
interesting initiative it's pretty early

00:23:09,980 --> 00:23:15,260
but it seems promising

00:23:12,340 --> 00:23:16,610
and then CloudFlare dropbox are using

00:23:15,260 --> 00:23:17,750
rust for a bunch of back-end services so

00:23:16,610 --> 00:23:19,490
you see a fair amount of variety and

00:23:17,750 --> 00:23:20,750
people who were using rust for different

00:23:19,490 --> 00:23:23,710
things but particularly you see a lot of

00:23:20,750 --> 00:23:26,000
these cases for like kernels and like

00:23:23,710 --> 00:23:29,570
embedded embedded seems like a

00:23:26,000 --> 00:23:32,570
particularly big use case I gave a talk

00:23:29,570 --> 00:23:35,900
at a embedded rust conference and there

00:23:32,570 --> 00:23:37,640
was this guy who he he programmed like

00:23:35,900 --> 00:23:40,130
it was basically a Bluetooth controlled

00:23:37,640 --> 00:23:42,620
skateboard in rust which I thought was

00:23:40,130 --> 00:23:44,030
pretty cool he actually did a demo it

00:23:42,620 --> 00:23:45,920
was pretty impressive so he was kind of

00:23:44,030 --> 00:23:51,050
like skating around via the conference

00:23:45,920 --> 00:23:53,640
room was good so I don't know if you saw

00:23:51,050 --> 00:23:55,470
this Brian Cantrell gave a talk

00:23:53,640 --> 00:23:57,960
I forget where Q Khan or something and

00:23:55,470 --> 00:23:59,940
so he's also he's a fan of rust now he's

00:23:57,960 --> 00:24:01,410
been playing around with it and the

00:23:59,940 --> 00:24:02,790
question he asked was is it time to

00:24:01,410 --> 00:24:06,330
rewrite the operating system and rust

00:24:02,790 --> 00:24:07,590
and so I was wondering yeah it seems

00:24:06,330 --> 00:24:12,270
like a question is it time to rewrite

00:24:07,590 --> 00:24:15,090
like BSD and rust and so I think the

00:24:12,270 --> 00:24:17,550
answer is mostly no because there's a

00:24:15,090 --> 00:24:19,380
lot of energy invested there's a lot of

00:24:17,550 --> 00:24:20,280
code rewriting the whole thing's just

00:24:19,380 --> 00:24:22,050
gonna take too long

00:24:20,280 --> 00:24:25,650
but I think maybe there's some use cases

00:24:22,050 --> 00:24:28,820
that would be interested in explore in

00:24:25,650 --> 00:24:32,250
particular things like device drivers

00:24:28,820 --> 00:24:35,580
file systems usual and utilities network

00:24:32,250 --> 00:24:36,780
services so the core kernel I think is

00:24:35,580 --> 00:24:38,610
gonna be difficult like especially

00:24:36,780 --> 00:24:40,170
because BSD is a large kernel I mean if

00:24:38,610 --> 00:24:41,280
you're starting clean slate you may have

00:24:40,170 --> 00:24:45,900
to do it I mean there's still some

00:24:41,280 --> 00:24:47,790
issues with doing a pure rust kernel

00:24:45,900 --> 00:24:50,930
people have done it but there some

00:24:47,790 --> 00:24:54,240
issues but because you have this large

00:24:50,930 --> 00:24:55,800
kernel that already works I think you

00:24:54,240 --> 00:24:57,000
don't want it like it's doesn't make

00:24:55,800 --> 00:24:59,010
sense it's like it would be too

00:24:57,000 --> 00:25:00,960
expensive to completely rewrite it so I

00:24:59,010 --> 00:25:02,760
think the places where it might make

00:25:00,960 --> 00:25:04,470
sense or device drivers um so the

00:25:02,760 --> 00:25:06,360
studies have shown that device drivers

00:25:04,470 --> 00:25:08,280
have three to seven times the default

00:25:06,360 --> 00:25:10,530
the defect rates of the rest of the kind

00:25:08,280 --> 00:25:13,290
of the core kernel so that's a good

00:25:10,530 --> 00:25:15,960
place to look into and file systems also

00:25:13,290 --> 00:25:19,950
userland utilities potentially and just

00:25:15,960 --> 00:25:21,750
generally network services bind and all

00:25:19,950 --> 00:25:23,910
that kind of thing would be potentially

00:25:21,750 --> 00:25:25,230
useful and on the device driver front

00:25:23,910 --> 00:25:28,650
there's been a couple groups looking

00:25:25,230 --> 00:25:32,160
into this there was a student at kth in

00:25:28,650 --> 00:25:34,380
Sweden who did some work on doing safe

00:25:32,160 --> 00:25:35,730
device safe kernel programming with rust

00:25:34,380 --> 00:25:37,590
basically you wrote a device driver

00:25:35,730 --> 00:25:39,180
framework for FreeBSD and rust that was

00:25:37,590 --> 00:25:41,340
pretty interesting and then there was a

00:25:39,180 --> 00:25:43,230
group I think it was at EU Munich that

00:25:41,340 --> 00:25:44,940
also did some work exploring a bunch of

00:25:43,230 --> 00:25:46,290
different languages for doing high-level

00:25:44,940 --> 00:25:47,400
like basically drivers and a bunch of

00:25:46,290 --> 00:25:50,370
different high-level languages so they

00:25:47,400 --> 00:25:52,260
had go and rust and a bunch of other

00:25:50,370 --> 00:25:55,830
languages that I can't remember but I've

00:25:52,260 --> 00:25:57,390
found that they were able to do get very

00:25:55,830 --> 00:25:58,620
close performance actually I think they

00:25:57,390 --> 00:26:00,480
were only off by like a couple

00:25:58,620 --> 00:26:03,030
percentages a couple percentage points

00:26:00,480 --> 00:26:04,890
for the the rust driver at least so they

00:26:03,030 --> 00:26:06,960
they're pretty

00:26:04,890 --> 00:26:08,399
we're pretty enthusiastic about rust for

00:26:06,960 --> 00:26:12,409
this kind of thing so it'd be cool to

00:26:08,399 --> 00:26:14,279
kind of explore the Sun for freebsd more

00:26:12,409 --> 00:26:16,740
so if you actually want to play around

00:26:14,279 --> 00:26:19,049
with rust it's fairly easy it's already

00:26:16,740 --> 00:26:21,659
packaged up so on freebsd you can just

00:26:19,049 --> 00:26:23,159
package install rust and the knight

00:26:21,659 --> 00:26:24,630
leaves also packaged up so it's actually

00:26:23,159 --> 00:26:25,919
pretty cool so if you want to get your

00:26:24,630 --> 00:26:27,360
gonna sort of try out the bleeding edge

00:26:25,919 --> 00:26:30,419
features you can grab the nightly and

00:26:27,360 --> 00:26:32,340
start playing around with it so nepia

00:26:30,419 --> 00:26:37,919
see and OpenBSD also have it packaged as

00:26:32,340 --> 00:26:39,539
this dragonfly the sort of preferred way

00:26:37,919 --> 00:26:42,059
or especially be doing if you're

00:26:39,539 --> 00:26:44,220
managing multiple rust tool chains is to

00:26:42,059 --> 00:26:48,389
use rust up so their support for freebsd

00:26:44,220 --> 00:26:50,340
and a pc for doing that so i think so

00:26:48,389 --> 00:26:52,830
rust has this thing where they have like

00:26:50,340 --> 00:26:55,230
tiers of support so freebsd and FPC are

00:26:52,830 --> 00:26:56,760
in tier two so like the the rust people

00:26:55,230 --> 00:26:57,899
will actually provide binary images so

00:26:56,760 --> 00:27:02,220
you can actually grab this stuff more

00:26:57,899 --> 00:27:04,429
easily using rust up so grabbing rust up

00:27:02,220 --> 00:27:06,899
is pretty easy to do the curl sh thing

00:27:04,429 --> 00:27:10,080
the car life stage patterns not required

00:27:06,899 --> 00:27:12,389
and probably not recommended but yes you

00:27:10,080 --> 00:27:13,710
can uh but it's pretty easy to grab if

00:27:12,389 --> 00:27:17,399
you want to just start playing around

00:27:13,710 --> 00:27:18,000
rust so if you want to create a new

00:27:17,399 --> 00:27:20,429
project

00:27:18,000 --> 00:27:22,230
I think cargo makes it pretty easy so

00:27:20,429 --> 00:27:24,059
there's a few commands and you can get

00:27:22,230 --> 00:27:26,490
up and running basically so you run

00:27:24,059 --> 00:27:28,620
cargo new you've got it creates a

00:27:26,490 --> 00:27:30,929
project for you you can specify whether

00:27:28,620 --> 00:27:33,630
you're making a binary or libraries so

00:27:30,929 --> 00:27:34,649
here I say cargo new bin hello you can

00:27:33,630 --> 00:27:36,090
specify whether you're creating a

00:27:34,649 --> 00:27:38,370
release binary or not in this case I

00:27:36,090 --> 00:27:40,950
created a debug binary you go into that

00:27:38,370 --> 00:27:43,730
directory you run Karkar run it'll build

00:27:40,950 --> 00:27:46,590
it and then you get your hello world

00:27:43,730 --> 00:27:49,190
then you can modify your source files so

00:27:46,590 --> 00:27:52,169
like your main dot c file change it

00:27:49,190 --> 00:27:53,940
there's a file called cargo tamil that's

00:27:52,169 --> 00:27:55,590
basically how you define your package

00:27:53,940 --> 00:27:57,330
dependencies so if you're gonna bring in

00:27:55,590 --> 00:27:59,970
a red x package or something like that

00:27:57,330 --> 00:28:01,740
or like some sort of concurrency library

00:27:59,970 --> 00:28:03,840
you basically add it there and then you

00:28:01,740 --> 00:28:06,990
run a cargo run again it'll build it and

00:28:03,840 --> 00:28:08,159
then you get your new binary so if cargo

00:28:06,990 --> 00:28:10,649
also has a number of other features

00:28:08,159 --> 00:28:12,530
where you can you go in a cargo format

00:28:10,649 --> 00:28:15,440
they have Lintz they have a test

00:28:12,530 --> 00:28:17,600
framework that's built in it's a pretty

00:28:15,440 --> 00:28:21,340
productive framework on their CI stuff

00:28:17,600 --> 00:28:24,410
so it's a it's it's a pretty nice tool

00:28:21,340 --> 00:28:25,730
so if you want to learn more about rust

00:28:24,410 --> 00:28:27,470
there's a bunch of resources that are

00:28:25,730 --> 00:28:29,690
out there the rust programming language

00:28:27,470 --> 00:28:31,760
book is online it's free you can also

00:28:29,690 --> 00:28:33,980
get a prayer you can also get a printed

00:28:31,760 --> 00:28:35,510
copy if you want I'm particularly fond

00:28:33,980 --> 00:28:36,890
of the programming rust book form or

00:28:35,510 --> 00:28:39,710
Riley I think it's really good it's from

00:28:36,890 --> 00:28:41,000
a some Mozilla I think some I think

00:28:39,710 --> 00:28:43,040
Mozilla people have been around for a

00:28:41,000 --> 00:28:45,470
while I think we doing C and C++ systems

00:28:43,040 --> 00:28:47,660
programming for a long time and then

00:28:45,470 --> 00:28:50,270
there's some like courses where you can

00:28:47,660 --> 00:28:51,470
run through like they you can run

00:28:50,270 --> 00:28:53,150
through some examples they kind of walk

00:28:51,470 --> 00:28:55,250
you through how to get up to speed on

00:28:53,150 --> 00:28:57,740
rust they have this rust by example

00:28:55,250 --> 00:28:59,180
tutorial so there's a bunch of useful

00:28:57,740 --> 00:29:01,850
materials you could kind of gun it if

00:28:59,180 --> 00:29:04,190
you want to get up and going so I showed

00:29:01,850 --> 00:29:06,080
you I mean basically getting if you

00:29:04,190 --> 00:29:07,700
install a cargo I mean if you do the

00:29:06,080 --> 00:29:09,050
rust up thing and you create a cargo

00:29:07,700 --> 00:29:10,520
project you're basically up and going

00:29:09,050 --> 00:29:11,840
and then you can just grab one of the

00:29:10,520 --> 00:29:13,430
books and start playing around with it I

00:29:11,840 --> 00:29:15,770
think you'll find that you can get

00:29:13,430 --> 00:29:17,810
pretty far fairly quickly and then you

00:29:15,770 --> 00:29:21,650
have to learn more about ownership and

00:29:17,810 --> 00:29:23,840
all that stuff so yeah so in summary I

00:29:21,650 --> 00:29:26,690
think rust is a fairly compelling

00:29:23,840 --> 00:29:29,930
language so you have a lot of the

00:29:26,690 --> 00:29:33,620
higher-level language features and the

00:29:29,930 --> 00:29:34,730
safety is necessary for the kind of

00:29:33,620 --> 00:29:37,250
world that we live in where you have a

00:29:34,730 --> 00:29:39,680
lot of these serious vulnerabilities and

00:29:37,250 --> 00:29:41,000
you have a lot of and it also has the

00:29:39,680 --> 00:29:43,000
low-level language performance that you

00:29:41,000 --> 00:29:44,690
need for systems programming so

00:29:43,000 --> 00:29:46,280
especially if you're doing something

00:29:44,690 --> 00:29:48,050
like a kernel or like really embedded

00:29:46,280 --> 00:29:51,490
software and you're starting to see

00:29:48,050 --> 00:29:53,870
growing use in industry I mean

00:29:51,490 --> 00:29:55,640
particularly among like the big like

00:29:53,870 --> 00:29:57,320
Amazon's and Google's and whatnot Google

00:29:55,640 --> 00:30:02,030
in particular has been doing a lot of

00:29:57,320 --> 00:30:03,830
projects in in rust and it's it's

00:30:02,030 --> 00:30:04,790
actually well supportive and bsd so if

00:30:03,830 --> 00:30:06,260
you want to start playing around with

00:30:04,790 --> 00:30:08,660
rust and bsd it's pretty easy to get up

00:30:06,260 --> 00:30:10,120
and going and I'm particularly

00:30:08,660 --> 00:30:13,640
interested in playing around with more

00:30:10,120 --> 00:30:15,170
getting more rust components on BSD I

00:30:13,640 --> 00:30:16,850
think the rust driver framework I think

00:30:15,170 --> 00:30:18,880
we could pretty fun to work on so I'd

00:30:16,850 --> 00:30:21,669
like to sort of explore that some more

00:30:18,880 --> 00:30:22,870
so we'll see where I get and yeah if

00:30:21,669 --> 00:30:25,600
anyone else is interested I'd like to

00:30:22,870 --> 00:30:42,850
chat with you more about that so yeah

00:30:25,600 --> 00:30:45,159
thanks in one having question so in in

00:30:42,850 --> 00:30:46,929
rust they have the notion of unsafe

00:30:45,159 --> 00:30:49,120
which get around the block where you

00:30:46,929 --> 00:30:51,190
can't really follow the rules yep

00:30:49,120 --> 00:30:54,009
and as soon as you've done even one of

00:30:51,190 --> 00:30:56,950
those a lot of the guarantees fall

00:30:54,009 --> 00:30:58,899
through and all of any significant rust

00:30:56,950 --> 00:30:59,830
that I've ever looked at has unsafe

00:30:58,899 --> 00:31:01,870
blocks in it

00:30:59,830 --> 00:31:04,659
I think example calling NEC function is

00:31:01,870 --> 00:31:07,570
an unsafe thing to do yeah yeah I mean I

00:31:04,659 --> 00:31:10,690
think like I think what you want to do

00:31:07,570 --> 00:31:12,039
is basically try to reduce the number of

00:31:10,690 --> 00:31:13,059
unsafe things that you have to do I

00:31:12,039 --> 00:31:16,059
think there's a lot of code that you can

00:31:13,059 --> 00:31:17,830
write without using needing unsafe but

00:31:16,059 --> 00:31:19,269
if you do need unsafe it's useful to

00:31:17,830 --> 00:31:20,830
have it if you're linking against C code

00:31:19,269 --> 00:31:23,889
there are people who are looking at

00:31:20,830 --> 00:31:26,169
proving properties of the unsafe

00:31:23,889 --> 00:31:27,759
libraries and things like that so

00:31:26,169 --> 00:31:29,679
there's work going on there but yeah I

00:31:27,759 --> 00:31:31,750
mean if you're doing really low-level

00:31:29,679 --> 00:31:32,919
system stuff in some cases you're

00:31:31,750 --> 00:31:34,659
probably gonna have to do unsafe things

00:31:32,919 --> 00:31:38,169
and they're working on ways to make that

00:31:34,659 --> 00:31:40,870
better but in some cases the the unsafe

00:31:38,169 --> 00:31:44,080
things can be checked in other ways

00:31:40,870 --> 00:31:46,240
there's a group in MPI is looking at

00:31:44,080 --> 00:31:48,789
sort of verifying some unsafe portions

00:31:46,240 --> 00:31:50,889
in particular but I think the value

00:31:48,789 --> 00:31:53,529
there is most of the code that you write

00:31:50,889 --> 00:31:55,120
is a safe and then what you have to do

00:31:53,529 --> 00:31:59,429
is audit the unsafe portions essentially

00:31:55,120 --> 00:31:59,429
so it does reduce the other burden a bit

00:32:03,460 --> 00:32:13,759
yeah yeah yeah exactly but I still think

00:32:08,059 --> 00:32:15,679
it buys you a fair amount the first have

00:32:13,759 --> 00:32:18,049
the notion of shared libraries because

00:32:15,679 --> 00:32:20,330
in in my experience in freebies Deportes

00:32:18,049 --> 00:32:23,239
you know all the penances all crates are

00:32:20,330 --> 00:32:27,830
compiled into a big basically static

00:32:23,239 --> 00:32:29,899
binary and if if one of the if one of

00:32:27,830 --> 00:32:33,409
the dependencies has a vulnerability it

00:32:29,899 --> 00:32:35,029
means you have to recompile or Russ

00:32:33,409 --> 00:32:37,190
programs that use that one because it's

00:32:35,029 --> 00:32:40,190
bundled with it yeah that's a good

00:32:37,190 --> 00:32:42,409
question I don't so you can build

00:32:40,190 --> 00:32:47,049
libraries I think typically you build

00:32:42,409 --> 00:32:47,049
statically I'm not I'm actually not sure

00:32:50,499 --> 00:32:59,389
so the source files for rust dot c files

00:32:54,919 --> 00:33:01,879
dot RS those RS but three slides ago can

00:32:59,389 --> 00:33:02,509
you maybe yeah there's a typo in the

00:33:01,879 --> 00:33:05,629
year

00:33:02,509 --> 00:33:07,759
so VI SRC oh yeah it was my bad

00:33:05,629 --> 00:33:11,299
it took an RS i'ts I'm just so used to

00:33:07,759 --> 00:33:14,169
like putting stuck see I guess thanks

00:33:11,299 --> 00:33:14,169
sorry about that

00:33:14,710 --> 00:33:18,350
well actually I meant I didn't mean to

00:33:17,059 --> 00:33:21,799
include us lied about that there is a

00:33:18,350 --> 00:33:25,090
tool from unit that called Sita rust and

00:33:21,799 --> 00:33:28,249
so it allows you to unlike factor

00:33:25,090 --> 00:33:30,139
semi-automatically for some features C

00:33:28,249 --> 00:33:33,139
to unsafe rust and they're creating a

00:33:30,139 --> 00:33:35,749
refactoring tool that converts safe rust

00:33:33,139 --> 00:33:37,609
or unsafe rust to safe rust but it

00:33:35,749 --> 00:33:39,350
requires some a fair amount of manual

00:33:37,609 --> 00:33:46,690
intervention but it's it's pretty

00:33:39,350 --> 00:33:46,690
interesting tool yeah I guess I wasn't

00:33:47,090 --> 00:34:00,320
I see yeah yeah I am

00:33:57,740 --> 00:34:03,559
yeah the person about the tier two

00:34:00,320 --> 00:34:07,789
things I mean what we should do as

00:34:03,559 --> 00:34:11,290
community to move the free/busy supports

00:34:07,789 --> 00:34:13,460
or a busy support in general to Tier one

00:34:11,290 --> 00:34:16,579
let's take a question I think basically

00:34:13,460 --> 00:34:18,889
we probably need maybe some committers

00:34:16,579 --> 00:34:21,740
on what the rusty basically so I think

00:34:18,889 --> 00:34:24,250
tier 1 tier 2 basically means that like

00:34:21,740 --> 00:34:27,310
every commit that goes into the rust

00:34:24,250 --> 00:34:30,290
compiler essentially and like language

00:34:27,310 --> 00:34:31,490
has to at least build and tier one you

00:34:30,290 --> 00:34:33,079
get some sort of guarantee basically

00:34:31,490 --> 00:34:35,000
every commit that goes in actually

00:34:33,079 --> 00:34:37,339
passes CI so probably there's some

00:34:35,000 --> 00:34:39,679
effort in like making sure that like the

00:34:37,339 --> 00:34:42,020
FreeBSD CI is like working or whatever

00:34:39,679 --> 00:34:44,540
BSD that you're working on and maybe

00:34:42,020 --> 00:34:46,970
also like getting some FreeBSD or BSD

00:34:44,540 --> 00:34:48,889
people as committers to like upstream

00:34:46,970 --> 00:34:51,109
rust would probably help but getting the

00:34:48,889 --> 00:34:52,730
CI sorted out is probably the first

00:34:51,109 --> 00:34:54,889
thing and I should have looked at it so

00:34:52,730 --> 00:34:57,920
it actually have the status is like the

00:34:54,889 --> 00:34:59,329
previous DCI or an FPS DCI is because I

00:34:57,920 --> 00:35:02,150
think those are the only two that are

00:34:59,329 --> 00:35:05,710
probably running but I think that would

00:35:02,150 --> 00:35:05,710
be a good first step at least

00:35:10,099 --> 00:35:15,630
I'm just curious what language rust is

00:35:13,319 --> 00:35:18,779
written in music built around rust is

00:35:15,630 --> 00:35:21,960
mostly written in rust I think I think I

00:35:18,779 --> 00:35:27,349
think basically all rust used LVM in the

00:35:21,960 --> 00:35:27,349
backend so it does have a C++ dependency

00:35:32,779 --> 00:35:38,819
and it's always written and it's one of

00:35:35,670 --> 00:35:41,130
the constant sources of pain that was

00:35:38,819 --> 00:35:44,339
written vast and typically even in the

00:35:41,130 --> 00:35:47,609
last version of us so bootstrapping is a

00:35:44,339 --> 00:35:53,880
pain if you actually want to do it more

00:35:47,609 --> 00:35:57,749
questions well I have one for operating

00:35:53,880 --> 00:36:01,039
systems we typically have fancy data

00:35:57,749 --> 00:36:03,779
structures like lists or tweezer

00:36:01,039 --> 00:36:06,960
self-referential which don't go well

00:36:03,779 --> 00:36:10,289
with the ownership model of what's how

00:36:06,960 --> 00:36:12,390
do the existing attempts at worst an

00:36:10,289 --> 00:36:14,099
operating systems actually actually deal

00:36:12,390 --> 00:36:16,529
with that this is a good question I

00:36:14,099 --> 00:36:19,680
think basically they do the unsafe thing

00:36:16,529 --> 00:36:22,170
I think there's more work to be done

00:36:19,680 --> 00:36:24,710
there there is it as a challenge

00:36:22,170 --> 00:36:27,119
basically doing these sorts of like

00:36:24,710 --> 00:36:28,769
mutually own kinds of data structures

00:36:27,119 --> 00:36:30,509
and doubly linked links and that kind

00:36:28,769 --> 00:36:33,630
thing so there's more work to be done

00:36:30,509 --> 00:36:37,529
there I think there are patterns where

00:36:33,630 --> 00:36:40,259
you can do basically create greatest

00:36:37,529 --> 00:36:43,140
safe data structures in those scenarios

00:36:40,259 --> 00:36:47,640
but it's it's pretty challenging so

00:36:43,140 --> 00:36:50,329
there's more work to be done there any

00:36:47,640 --> 00:36:50,329
other questions

00:36:51,720 --> 00:36:57,060
have you considered the problem of when

00:36:54,510 --> 00:36:58,650
you rewrite the whole thing interest you

00:36:57,060 --> 00:37:00,750
basically lose all of the history

00:36:58,650 --> 00:37:03,540
because most of the time when I am

00:37:00,750 --> 00:37:08,369
digging through C files I can track each

00:37:03,540 --> 00:37:09,750
line decades or even more back so but

00:37:08,369 --> 00:37:12,030
regretting the whole thing I would

00:37:09,750 --> 00:37:14,310
basically lose track of all the progress

00:37:12,030 --> 00:37:18,780
that was made on one thing throughout

00:37:14,310 --> 00:37:20,130
the systems was that's considered I mean

00:37:18,780 --> 00:37:24,990
that's a fair great that's a fair

00:37:20,130 --> 00:37:26,220
concern actually I mean I guess so some

00:37:24,990 --> 00:37:29,160
of these tools where people are looking

00:37:26,220 --> 00:37:31,349
at converting C to rusts they're looking

00:37:29,160 --> 00:37:33,630
at creating specifications and like

00:37:31,349 --> 00:37:35,400
basically verifying that the behavior is

00:37:33,630 --> 00:37:36,900
the same so it doesn't really address

00:37:35,400 --> 00:37:38,640
your question of getting like a change

00:37:36,900 --> 00:37:41,310
log or anything like that or sort of

00:37:38,640 --> 00:37:44,550
losing the history but if you want to

00:37:41,310 --> 00:37:46,530
create basically equivalent behavior

00:37:44,550 --> 00:37:48,240
then that's one way to go but yeah I

00:37:46,530 --> 00:37:58,170
don't think it doesn't address your

00:37:48,240 --> 00:38:00,270
specific concern about history those are

00:37:58,170 --> 00:38:01,720
all the questions thank you very much

00:38:00,270 --> 00:38:07,900
thanks a lot

00:38:01,720 --> 00:38:07,900
[Applause]

00:38:12,800 --> 00:38:14,860

YouTube URL: https://www.youtube.com/watch?v=M2dkr4seKto


