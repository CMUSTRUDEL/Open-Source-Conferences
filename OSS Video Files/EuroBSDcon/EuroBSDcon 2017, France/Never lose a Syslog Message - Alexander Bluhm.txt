Title: Never lose a Syslog Message - Alexander Bluhm
Publication date: 2019-10-16
Playlist: EuroBSDcon 2017, France
Description: 
	Description:

On security systems logging is crucial. You have to know what an
attacker was doing. Also the attacker could provoke that important
information is lost. To provide a reliable view of the system, I
have implemented a bunch of mechanisms in the OpenBSD kernel and
syslogd(8).
Unfortunately traditional BSD syslog protocol is based on datagram
sockets and UDP messages. Both may fail unnoticed. The new system
call sendmessage(2) makes local logging work in harsh conditions
and also provides a single point from where errors can be reported.
Overflow of dmesg(8) buffer is detected and reported. For remote
logging TCP and TLS transport have been implemented together with
counters of lost messages due to buffer exhaustion.

The talk will explain these mechanisms together with more new
features in OpenBSD syslogd(8).

Speaker biography:

 - developer bluhm@openbsd.org since 2007
 - working for genua GmbH, a company which builds OpenBSD based firewalls
Captions: 
	00:00:00,050 --> 00:00:05,970
yeah thank you very much so a few words

00:00:03,449 --> 00:00:08,519
to myself I work for quinoa we are a

00:00:05,970 --> 00:00:11,759
company building BST based OpenBSD based

00:00:08,519 --> 00:00:14,700
firewalls and i'm OpenBSD committer

00:00:11,759 --> 00:00:20,970
since 10 years now so I can combine my

00:00:14,700 --> 00:00:23,910
profession with my hobby so what we'll

00:00:20,970 --> 00:00:25,830
talk about first of all why do we need

00:00:23,910 --> 00:00:28,050
something else it has been said already

00:00:25,830 --> 00:00:30,269
syslog is a very old program and just

00:00:28,050 --> 00:00:33,059
works and that's what we expect from it

00:00:30,269 --> 00:00:36,750
where are we now starting position what

00:00:33,059 --> 00:00:39,600
did I do to make the local logging

00:00:36,750 --> 00:00:42,360
better on the machine what did I change

00:00:39,600 --> 00:00:45,239
with remote logging sending messages to

00:00:42,360 --> 00:00:52,020
other machines and I have a short

00:00:45,239 --> 00:00:53,910
summary of what I did ok why do we need

00:00:52,020 --> 00:00:56,820
logging and why do we need reliable

00:00:53,910 --> 00:00:59,010
logging so we do system analysis we want

00:00:56,820 --> 00:01:01,320
to know what on the machine is going on

00:00:59,010 --> 00:01:02,969
if you debug a problem and if some log

00:01:01,320 --> 00:01:06,890
messages are missing and we don't see

00:01:02,969 --> 00:01:09,990
that then it makes our task harder

00:01:06,890 --> 00:01:13,860
second thing is we have attackers in the

00:01:09,990 --> 00:01:16,049
Internet and they try to avoid that we

00:01:13,860 --> 00:01:17,700
see their traces they try to avoid that

00:01:16,049 --> 00:01:19,799
we see lock messages so if they can

00:01:17,700 --> 00:01:21,420
bring the system who stayed where it

00:01:19,799 --> 00:01:23,369
doesn't look anymore they can make their

00:01:21,420 --> 00:01:26,009
tag and we don't see that it did

00:01:23,369 --> 00:01:38,430
something evil and then the third thing

00:01:26,009 --> 00:01:40,680
is we certify and we do a certification

00:01:38,430 --> 00:01:42,899
for our product with Common Criteria and

00:01:40,680 --> 00:01:44,700
there someone wrote into the documents

00:01:42,899 --> 00:01:48,210
yeah we do live reliable syslog and we

00:01:44,700 --> 00:01:50,729
don't lose lock messages so we had a

00:01:48,210 --> 00:01:53,970
bunch of dirty hacks in our product to

00:01:50,729 --> 00:01:55,740
make that and I thought let's move all

00:01:53,970 --> 00:01:58,200
the intelligence into the system into

00:01:55,740 --> 00:02:01,229
the syslog did so that the community and

00:01:58,200 --> 00:02:03,509
community can have an advantage for it

00:02:01,229 --> 00:02:06,590
and we have cleaner code and don't

00:02:03,509 --> 00:02:06,590
require our hacks

00:02:09,300 --> 00:02:16,330
so what can go wrong first of all syslog

00:02:13,780 --> 00:02:19,360
is doing if it does remote logging it

00:02:16,330 --> 00:02:21,670
with UDP forever and UDP is not known

00:02:19,360 --> 00:02:24,250
for being reliable it's basically

00:02:21,670 --> 00:02:26,019
unreliable you can just lose it if you

00:02:24,250 --> 00:02:31,170
lose you 2p packet you don't see the log

00:02:26,019 --> 00:02:31,170
message then we have UNIX Datagram

00:02:32,519 --> 00:02:38,890
sockets for local delivery they you need

00:02:36,010 --> 00:02:41,170
file descriptors then you have to need

00:02:38,890 --> 00:02:42,670
need access to the file you can be run

00:02:41,170 --> 00:02:45,239
change router then you don't see it

00:02:42,670 --> 00:02:47,890
anymore so it's def

00:02:45,239 --> 00:02:52,030
thing and there are things that can go

00:02:47,890 --> 00:02:54,400
wrong so and then we have timestamps and

00:02:52,030 --> 00:02:56,650
time zones and you run change routed the

00:02:54,400 --> 00:02:59,079
classical syslog takes the timezone from

00:02:56,650 --> 00:03:01,269
the local file system and the client

00:02:59,079 --> 00:03:03,579
who's logging it so when you have when

00:03:01,269 --> 00:03:05,349
you forget to put your etc' local time

00:03:03,579 --> 00:03:06,730
and you change route environments who

00:03:05,349 --> 00:03:08,829
gets this lock messages there are

00:03:06,730 --> 00:03:12,880
different time zones some of them are

00:03:08,829 --> 00:03:14,380
UTC some of them are local time and time

00:03:12,880 --> 00:03:15,910
stamps is also a problem when you do

00:03:14,380 --> 00:03:18,810
remote logging when you have a global

00:03:15,910 --> 00:03:21,190
environment and every search lock is

00:03:18,810 --> 00:03:23,530
logging in local time and then you have

00:03:21,190 --> 00:03:25,209
a common lock file with all things and

00:03:23,530 --> 00:03:32,190
every machine has a different time

00:03:25,209 --> 00:03:35,370
stamps that's really hard to debug okay

00:03:32,190 --> 00:03:38,889
where did we start from so that's how

00:03:35,370 --> 00:03:43,269
this lock works when you you just go

00:03:38,889 --> 00:03:46,269
through so that's how a syslog works

00:03:43,269 --> 00:03:47,829
when you you are a C programmer so

00:03:46,269 --> 00:03:51,510
there's a Lipsy function that's called

00:03:47,829 --> 00:03:53,880
syslog you can say okay I have several

00:03:51,510 --> 00:04:00,510
severity s here we have an error message

00:03:53,880 --> 00:04:04,930
you can do some printf style formatting

00:04:00,510 --> 00:04:06,790
then everything goes to Lipsy there the

00:04:04,930 --> 00:04:09,250
priority is processed so this is

00:04:06,790 --> 00:04:10,989
converted to a number you have time

00:04:09,250 --> 00:04:13,859
stamps that are added there the the

00:04:10,989 --> 00:04:17,590
print is done and then it's sent to

00:04:13,859 --> 00:04:21,850
Deathlok that's a UNIX file UNIX domain

00:04:17,590 --> 00:04:25,090
socket and syslog D is listening on that

00:04:21,850 --> 00:04:27,910
so then the syslog be is receiving the

00:04:25,090 --> 00:04:31,990
thing rights into a log file or Zen set

00:04:27,910 --> 00:04:38,650
via UDP so this has been there for

00:04:31,990 --> 00:04:41,320
forever more or less so now we look into

00:04:38,650 --> 00:04:43,780
details how that works so we have some

00:04:41,320 --> 00:04:47,140
priorities facilities level severity and

00:04:43,780 --> 00:04:49,540
options that we can pass there the first

00:04:47,140 --> 00:04:52,510
confusion starts the main page speaks of

00:04:49,540 --> 00:04:55,120
level the RFC calls it severity the

00:04:52,510 --> 00:04:58,360
header files called it priority while

00:04:55,120 --> 00:05:03,010
the RFC means the combined thing between

00:04:58,360 --> 00:05:07,690
severity and facility is the priority so

00:05:03,010 --> 00:05:10,780
what so what do you do we have an open

00:05:07,690 --> 00:05:13,120
lock let's this Lipsy function that a

00:05:10,780 --> 00:05:14,620
program called and it starts running and

00:05:13,120 --> 00:05:17,140
there it can say it's okay my name is

00:05:14,620 --> 00:05:19,090
FTP demon so take this name to all the

00:05:17,140 --> 00:05:21,670
lot message so the user knows where it

00:05:19,090 --> 00:05:24,550
comes from it can say okay and I want

00:05:21,670 --> 00:05:27,760
that my pit file my pit number is locked

00:05:24,550 --> 00:05:28,560
in all messages and if logging goes

00:05:27,760 --> 00:05:31,600
wrong

00:05:28,560 --> 00:05:33,610
the message cannot reach this lock the

00:05:31,600 --> 00:05:35,860
message should show up at the console

00:05:33,610 --> 00:05:38,890
then you can lock cons and there are

00:05:35,860 --> 00:05:41,290
some other options there and then we

00:05:38,890 --> 00:05:43,330
have the facility facility means that

00:05:41,290 --> 00:05:45,490
every program there are some classes of

00:05:43,330 --> 00:05:46,570
programs for example FTP programs then

00:05:45,490 --> 00:05:49,630
we have uucp

00:05:46,570 --> 00:05:51,850
the news the syslog the mail so it's

00:05:49,630 --> 00:05:54,430
basically for the server in the

00:05:51,850 --> 00:05:56,710
beginning of the 80s could have and then

00:05:54,430 --> 00:05:59,700
we have local facilities local zero to

00:05:56,710 --> 00:06:06,340
local eight that's everything else

00:05:59,700 --> 00:06:09,910
what's local 12 16 I don't know so those

00:06:06,340 --> 00:06:12,790
are our numbers and the the facility and

00:06:09,910 --> 00:06:17,440
the severity they are are together

00:06:12,790 --> 00:06:22,410
called priority and the Lipsy generates

00:06:17,440 --> 00:06:25,930
such a string so it this one is in HTML

00:06:22,410 --> 00:06:28,000
notation those two are together and you

00:06:25,930 --> 00:06:31,960
have the timestamp that's the classical

00:06:28,000 --> 00:06:35,730
BSD timestamp then the program name the

00:06:31,960 --> 00:06:35,730
pit and the message

00:06:37,530 --> 00:06:47,830
so what can be changed here so we

00:06:44,830 --> 00:06:49,870
rewrite that to Deathlok that means we

00:06:47,830 --> 00:06:53,620
need a file descriptor so when do we

00:06:49,870 --> 00:06:56,350
acquire the file descriptor we can

00:06:53,620 --> 00:06:58,930
either do it with open lock or we can do

00:06:56,350 --> 00:07:01,300
it when we do the syslog call and there

00:06:58,930 --> 00:07:03,760
we have a special switch that's n delay

00:07:01,300 --> 00:07:06,040
when we say no delay to open lock it

00:07:03,760 --> 00:07:07,600
opens the file descriptor immediately so

00:07:06,040 --> 00:07:09,790
that set isn't has an advantage so we

00:07:07,600 --> 00:07:12,670
have opened it advanced it

00:07:09,790 --> 00:07:15,010
so before you change route and also when

00:07:12,670 --> 00:07:17,260
you go into a change route environment

00:07:15,010 --> 00:07:19,510
then logging still works although you

00:07:17,260 --> 00:07:21,760
have no socket there but then you get a

00:07:19,510 --> 00:07:26,020
c-cup to the syslog T that means he

00:07:21,760 --> 00:07:28,000
closes all the listening sockets and you

00:07:26,020 --> 00:07:30,100
have to reconnect Lipsy will do that

00:07:28,000 --> 00:07:34,330
unless you're in change route and unless

00:07:30,100 --> 00:07:36,250
you have specified to slock t2 to add an

00:07:34,330 --> 00:07:41,020
additional lock socket into the change

00:07:36,250 --> 00:07:45,550
route so and then see you rot edit

00:07:41,020 --> 00:07:48,970
pledge to open BSD where you can specify

00:07:45,550 --> 00:07:51,700
there only special classes of system

00:07:48,970 --> 00:07:54,430
calls are allowed but you want to allow

00:07:51,700 --> 00:07:56,200
every program to write its lock messages

00:07:54,430 --> 00:07:58,570
because there are the errors they are

00:07:56,200 --> 00:08:02,500
the traces for the attacker and that's

00:07:58,570 --> 00:08:06,550
common so all this concept makes it

00:08:02,500 --> 00:08:08,590
quite complicated because you need this

00:08:06,550 --> 00:08:10,570
file descriptor you can run out of file

00:08:08,590 --> 00:08:12,400
descriptors because you have this log n

00:08:10,570 --> 00:08:14,800
delay you have to reopen it during

00:08:12,400 --> 00:08:19,210
operation and you have to allow some

00:08:14,800 --> 00:08:21,130
houses lock socket is somehow the UNIX

00:08:19,210 --> 00:08:24,460
domain socket so you have to pledge UNIX

00:08:21,130 --> 00:08:28,150
everything so that's not good and when

00:08:24,460 --> 00:08:29,950
you say lock cons and the Lipsey's makes

00:08:28,150 --> 00:08:31,990
it sent to and sees o

00:08:29,950 --> 00:08:33,790
switch lagdi is not running now I have

00:08:31,990 --> 00:08:35,500
to open the console file descriptor dev

00:08:33,790 --> 00:08:37,200
console so you need another device in

00:08:35,500 --> 00:08:39,850
your change route don't forget that and

00:08:37,200 --> 00:08:41,320
you need them file descriptors I mean if

00:08:39,850 --> 00:08:44,530
you run out of file descriptor and want

00:08:41,320 --> 00:08:46,450
to lock that it doesn't work and so

00:08:44,530 --> 00:08:48,790
that's that's the implementation

00:08:46,450 --> 00:08:52,590
nightmare especially in

00:08:48,790 --> 00:08:54,550
in situations where something went wrong

00:08:52,590 --> 00:08:57,730
so what's the solution

00:08:54,550 --> 00:08:59,740
give a new system called Sophie you

00:08:57,730 --> 00:09:04,240
invented it it's called sensors lock and

00:08:59,740 --> 00:09:05,610
there we move tasks from Lipsy to the

00:09:04,240 --> 00:09:08,500
colonel

00:09:05,610 --> 00:09:10,750
so how does it work it has an integer

00:09:08,500 --> 00:09:13,330
return where well you like most of our

00:09:10,750 --> 00:09:15,670
system calls they also see some some

00:09:13,330 --> 00:09:18,340
some error if something didn't work for

00:09:15,670 --> 00:09:21,850
example a no buffs if you run out of em

00:09:18,340 --> 00:09:24,940
buffs and you put in the message it's

00:09:21,850 --> 00:09:28,990
not null terminated or in most cases it

00:09:24,940 --> 00:09:32,680
is but basically you give a length of

00:09:28,990 --> 00:09:34,780
the message and you pass some flags so

00:09:32,680 --> 00:09:37,660
there's only one flag supported at the

00:09:34,780 --> 00:09:40,720
moment and that's lock cons where you

00:09:37,660 --> 00:09:43,180
have to want to lock on the console if

00:09:40,720 --> 00:09:44,920
the sent to the syslog fails and the

00:09:43,180 --> 00:09:47,410
advantage is that you don't need a file

00:09:44,920 --> 00:09:49,690
descriptor because the kernel has opened

00:09:47,410 --> 00:09:51,730
the console anyway and it knows what to

00:09:49,690 --> 00:09:54,070
do so it's not tasks of the program

00:09:51,730 --> 00:10:00,880
anymore to grab the console the kernel

00:09:54,070 --> 00:10:04,840
does it so here's an example of what I

00:10:00,880 --> 00:10:07,590
call I put in the string the length and

00:10:04,840 --> 00:10:07,590
the flag

00:10:10,610 --> 00:10:19,130
and no no does not come okay the

00:10:17,089 --> 00:10:21,829
question was whether I need the the pit

00:10:19,130 --> 00:10:24,260
here or not and I need it all the other

00:10:21,829 --> 00:10:27,290
processing is still in Lipsy colonel is

00:10:24,260 --> 00:10:31,459
only responsible for sending it so Lipsy

00:10:27,290 --> 00:10:34,220
will generate the the priority the time

00:10:31,459 --> 00:10:35,630
stamp the name that you gave with open

00:10:34,220 --> 00:10:37,850
log otherwise you have to store all that

00:10:35,630 --> 00:10:39,709
in the Coronel it adds the pit so the

00:10:37,850 --> 00:10:42,829
pit is not reliable everyone can send

00:10:39,709 --> 00:10:45,680
whatever pit he wants and all the printf

00:10:42,829 --> 00:10:53,420
this Park processing it's still done in

00:10:45,680 --> 00:10:55,040
Lipsy so how do we get the message out

00:10:53,420 --> 00:10:56,930
of the kernel again before it's just

00:10:55,040 --> 00:10:59,360
lucky just opened a listen socket on the

00:10:56,930 --> 00:11:02,060
UNIX domain socket and here's this lagdi

00:10:59,360 --> 00:11:04,100
creates a socket pair a soccer pair is a

00:11:02,060 --> 00:11:06,680
system call and you get it's something

00:11:04,100 --> 00:11:08,600
like a pipe its socket with two ends and

00:11:06,680 --> 00:11:10,550
you can write in one end and get it from

00:11:08,600 --> 00:11:14,660
the other end and the other way around

00:11:10,550 --> 00:11:17,180
and then syslog details the kernel with

00:11:14,660 --> 00:11:19,100
an octal it opens def k lock and does

00:11:17,180 --> 00:11:21,440
this yeah i octal with a file script of

00:11:19,100 --> 00:11:24,070
one end of the socket pair and says oh

00:11:21,440 --> 00:11:27,320
this is my logging file descriptor and

00:11:24,070 --> 00:11:29,720
then the kernel registers and it knows

00:11:27,320 --> 00:11:32,680
one logging file descriptor and every

00:11:29,720 --> 00:11:35,269
time you call census lock uses this and

00:11:32,680 --> 00:11:38,000
syslog d listens on the other end and

00:11:35,269 --> 00:11:40,399
kernel writes into this because it knows

00:11:38,000 --> 00:11:43,490
which one it is because of this i octal

00:11:40,399 --> 00:11:45,170
the kernel also knows when the sent to

00:11:43,490 --> 00:11:48,949
doesn't work then it writes to the

00:11:45,170 --> 00:11:50,810
console it has it open anyway you can K

00:11:48,949 --> 00:11:52,940
trace everything that's going through

00:11:50,810 --> 00:11:55,190
there we have added some K trace hooks

00:11:52,940 --> 00:11:57,829
just have to cater a to program and you

00:11:55,190 --> 00:12:00,170
see what it's logging normally you write

00:11:57,829 --> 00:12:01,820
a file descriptor here - one is written

00:12:00,170 --> 00:12:05,180
because the program doesn't have a file

00:12:01,820 --> 00:12:07,459
descriptor for that and what it's new I

00:12:05,180 --> 00:12:10,040
can count the arrows the kernel can

00:12:07,459 --> 00:12:12,860
count the arrows so what does reliable

00:12:10,040 --> 00:12:13,850
logging me so either when we see oh we

00:12:12,860 --> 00:12:17,000
cannot lock anymore

00:12:13,850 --> 00:12:17,600
we hold the system until it works but we

00:12:17,000 --> 00:12:21,529
don't want that

00:12:17,600 --> 00:12:23,810
and so my solution for reliable logging

00:12:21,529 --> 00:12:24,590
is counting the errors and lock the

00:12:23,810 --> 00:12:26,660
errors when it

00:12:24,590 --> 00:12:28,520
works again so you see there was a

00:12:26,660 --> 00:12:30,950
problem the system works and works and

00:12:28,520 --> 00:12:34,310
continues and then we say and be careful

00:12:30,950 --> 00:12:35,930
we lost five messages and here the

00:12:34,310 --> 00:12:38,510
kernel can count the error we have one

00:12:35,930 --> 00:12:41,390
kernel one central place and every time

00:12:38,510 --> 00:12:48,800
the sending to the SIS lochte fails it

00:12:41,390 --> 00:12:49,570
increments the counter so we have it in

00:12:48,800 --> 00:12:51,950
this slide

00:12:49,570 --> 00:12:55,910
the problem is with error logging and

00:12:51,950 --> 00:12:58,220
error handling that the syslog function

00:12:55,910 --> 00:13:01,100
that is implemented in Lipsy and more or

00:12:58,220 --> 00:13:04,100
less standard is void so the program

00:13:01,100 --> 00:13:06,740
never knows or never knows whether it

00:13:04,100 --> 00:13:08,060
failed and even if it would know it

00:13:06,740 --> 00:13:11,720
cannot do anything because it cannot

00:13:08,060 --> 00:13:14,950
lock so doing it in the program is the

00:13:11,720 --> 00:13:19,550
wrong place and we do it in the kernel

00:13:14,950 --> 00:13:21,410
we count it there and then when we

00:13:19,550 --> 00:13:23,150
continue logging and the Siuslaw kernel

00:13:21,410 --> 00:13:25,610
tries to write to syslog again and again

00:13:23,150 --> 00:13:29,030
and once it's recognized oh it works

00:13:25,610 --> 00:13:30,950
again then it writes out a message to

00:13:29,030 --> 00:13:33,470
tell the user it didn't work

00:13:30,950 --> 00:13:36,140
so it says sensors lock dropped to

00:13:33,470 --> 00:13:40,970
messages and it writes the arrow of the

00:13:36,140 --> 00:13:43,670
first failed sensors lock so I think

00:13:40,970 --> 00:13:48,320
that's a no before not connected

00:13:43,670 --> 00:13:50,060
something like that I think that's not

00:13:48,320 --> 00:13:52,430
connected so if you lock something

00:13:50,060 --> 00:13:57,110
before log D is running you get a not

00:13:52,430 --> 00:13:59,440
connected so our next thing the time

00:13:57,110 --> 00:13:59,440
stamps

00:14:06,389 --> 00:14:14,439
so as I said before we take the local

00:14:09,429 --> 00:14:16,869
time in in every change route because

00:14:14,439 --> 00:14:20,679
it's done by Lipsy when the lock message

00:14:16,869 --> 00:14:23,319
is generate generated that's bad and

00:14:20,679 --> 00:14:26,399
when you look at the format we have no

00:14:23,319 --> 00:14:29,670
year we have no time zone we have no

00:14:26,399 --> 00:14:32,769
daylight saving time indication so you

00:14:29,670 --> 00:14:34,809
one time in a year you see for one time

00:14:32,769 --> 00:14:37,779
every lock message there are double lock

00:14:34,809 --> 00:14:42,519
messages and then you have one hour gap

00:14:37,779 --> 00:14:47,829
a half year later we have only second

00:14:42,519 --> 00:14:49,449
precision no second precision and kernel

00:14:47,829 --> 00:14:51,939
and when the kernel is logging something

00:14:49,449 --> 00:14:54,309
like the damask buffer the boot up

00:14:51,939 --> 00:14:58,059
messages they don't have a timestamp

00:14:54,309 --> 00:15:06,850
anyway so this lock has to do something

00:14:58,059 --> 00:15:08,949
for kernel messages so what is always

00:15:06,850 --> 00:15:10,480
doing for kernel messages is adding the

00:15:08,949 --> 00:15:13,149
timestamp looks the message as all

00:15:10,480 --> 00:15:15,999
there's no time stamp let's add one and

00:15:13,149 --> 00:15:18,100
I extended that so that the the

00:15:15,999 --> 00:15:19,809
timestamp is always optional syslog

00:15:18,100 --> 00:15:22,299
tries to parse it and if there's no

00:15:19,809 --> 00:15:25,059
timestamps yeah the net1 that also

00:15:22,299 --> 00:15:28,869
corresponds to the way what is written

00:15:25,059 --> 00:15:31,389
in this RFC yeah we also have devices

00:15:28,869 --> 00:15:33,910
that won't write x times so syslog has

00:15:31,389 --> 00:15:35,470
to be capable to add one if the device

00:15:33,910 --> 00:15:40,089
that we get the remote message from

00:15:35,470 --> 00:15:42,459
doesn't have a clock so and what I

00:15:40,089 --> 00:15:43,449
changed is that Lipsy doesn't generate a

00:15:42,459 --> 00:15:45,459
timestamp anymore

00:15:43,449 --> 00:15:48,879
so we always take the syslog timestamp

00:15:45,459 --> 00:15:52,679
and we have one central instance that is

00:15:48,879 --> 00:15:56,199
responsible for generating timestamps

00:15:52,679 --> 00:16:01,509
new people coming to the talk you'll

00:15:56,199 --> 00:16:07,269
just go in find a place and be quick so

00:16:01,509 --> 00:16:09,610
syslog D generates the the timestamp

00:16:07,269 --> 00:16:15,220
it's one central instance you don't have

00:16:09,610 --> 00:16:17,589
going timestamps going back it is a

00:16:15,220 --> 00:16:19,570
difference now before you locked when

00:16:17,589 --> 00:16:20,950
the message have to give you did

00:16:19,570 --> 00:16:23,260
times them in the program when the

00:16:20,950 --> 00:16:27,580
message happened now you do it in syslog

00:16:23,260 --> 00:16:32,550
so you have a delay there and depending

00:16:27,580 --> 00:16:38,800
on when just look at scheduled it may be

00:16:32,550 --> 00:16:42,310
bigger or not bigger so we can use as a

00:16:38,800 --> 00:16:44,950
new so the solutions for all this is you

00:16:42,310 --> 00:16:50,920
can turn syslog T you can give it the

00:16:44,950 --> 00:16:54,520
option minus that and then it generates

00:16:50,920 --> 00:16:55,900
in the new either format in UTC that

00:16:54,520 --> 00:16:57,880
it's the solution for we have no

00:16:55,900 --> 00:17:01,150
daylight saving time no time zone

00:16:57,880 --> 00:17:05,170
whatever and there we have advantages we

00:17:01,150 --> 00:17:07,810
can also use millisecond precision so

00:17:05,170 --> 00:17:10,480
this format is in you are syslog RFC's

00:17:07,810 --> 00:17:15,550
and you see here you have the year the

00:17:10,480 --> 00:17:17,800
month to date the hour minute second and

00:17:15,550 --> 00:17:20,740
you have a precision and this that means

00:17:17,800 --> 00:17:23,980
it's Zulu time so it's more or less UTC

00:17:20,740 --> 00:17:28,890
GMT whatever you call it

00:17:23,980 --> 00:17:32,370
here we are allow up to six tickets

00:17:28,890 --> 00:17:38,130
precision or fractions of seconds and

00:17:32,370 --> 00:17:38,130
you should what saying saying there

00:17:40,110 --> 00:17:45,220
that's correct

00:17:41,890 --> 00:17:48,250
and what does our lucky do i I have to

00:17:45,220 --> 00:17:50,920
quickly repeat it sorry so Henning says

00:17:48,250 --> 00:17:54,850
that UTC is without leap seconds and GT

00:17:50,920 --> 00:18:00,390
GMT is with and we lock in our systems

00:17:54,850 --> 00:18:04,840
without leap seconds thank you

00:18:00,390 --> 00:18:07,300
so you have the precision here you are

00:18:04,840 --> 00:18:10,030
allowed to specify it by RFC up to six

00:18:07,300 --> 00:18:11,950
tickets I only do three because I'm do

00:18:10,030 --> 00:18:14,710
the measurement how how long is the

00:18:11,950 --> 00:18:16,900
delay between logging in the program and

00:18:14,710 --> 00:18:18,580
reading it and syslog D and I don't get

00:18:16,900 --> 00:18:21,340
a better precision and that's roughly

00:18:18,580 --> 00:18:22,870
correct and the RFC says by specifying

00:18:21,340 --> 00:18:26,880
the number of tickets you can say how

00:18:22,870 --> 00:18:26,880
precise you are it's like physics

00:18:32,100 --> 00:18:40,179
so if other advantages buys using

00:18:37,000 --> 00:18:42,520
sensors lock directly so there are one

00:18:40,179 --> 00:18:45,090
some situations where you don't want to

00:18:42,520 --> 00:18:47,559
call the Lipsy functions for you as

00:18:45,090 --> 00:18:50,140
application programmers just you slip

00:18:47,559 --> 00:18:52,720
C's does everything for you but we can

00:18:50,140 --> 00:18:54,670
do other things we can call sensors log

00:18:52,720 --> 00:18:59,740
from a system signal handler is its

00:18:54,670 --> 00:19:03,220
signal handler safe we do have it in our

00:18:59,740 --> 00:19:06,970
lip see when we see that mem copy does

00:19:03,220 --> 00:19:09,340
overlap we have mem move that's when you

00:19:06,970 --> 00:19:12,190
have memory regions that do overlap and

00:19:09,340 --> 00:19:14,920
you have mem copy that is not allowed to

00:19:12,190 --> 00:19:18,059
use if the region's do overlap because

00:19:14,920 --> 00:19:20,380
then it could do read over writings and

00:19:18,059 --> 00:19:23,679
if a programmer does it wrong then

00:19:20,380 --> 00:19:25,929
OpenBSD Lipsy we generate a lot message

00:19:23,679 --> 00:19:28,570
but we don't want to call other Lipsy

00:19:25,929 --> 00:19:32,290
francs from there so we just did it for

00:19:28,570 --> 00:19:34,410
a raw sentence lock then we have to

00:19:32,290 --> 00:19:36,700
stack protector handler that sees that a

00:19:34,410 --> 00:19:38,740
stack cookie has been overwritten by a

00:19:36,700 --> 00:19:41,350
buffer overflow and in that cases you

00:19:38,740 --> 00:19:44,350
don't want to call other Lipsy functions

00:19:41,350 --> 00:19:46,809
to to make it worse yeah and it calls

00:19:44,350 --> 00:19:51,000
printf and does some formatting so we do

00:19:46,809 --> 00:19:54,820
call some functions we we call some

00:19:51,000 --> 00:19:59,290
estroux little cut to create the message

00:19:54,820 --> 00:20:01,809
but only that and and then we just

00:19:59,290 --> 00:20:04,210
called sensors lock directly so we get

00:20:01,809 --> 00:20:07,030
the message without doing more on this

00:20:04,210 --> 00:20:09,340
broken stack and we also have some lock

00:20:07,030 --> 00:20:11,559
message from the jennette dynamic linker

00:20:09,340 --> 00:20:13,720
it also cannot call Lipsy because it's

00:20:11,559 --> 00:20:18,910
there to load Lipsy there we also use

00:20:13,720 --> 00:20:25,000
that but don't we do it it's never

00:20:18,910 --> 00:20:27,820
necessary except for those cases so

00:20:25,000 --> 00:20:30,340
there are other places where we can lose

00:20:27,820 --> 00:20:32,140
lock messages we have the the damask

00:20:30,340 --> 00:20:34,120
where the kernel prints the boot up

00:20:32,140 --> 00:20:36,160
messages and print some debug messages

00:20:34,120 --> 00:20:38,620
if you enable device driver debugging

00:20:36,160 --> 00:20:40,990
and basically it's a it's a ring buffer

00:20:38,620 --> 00:20:41,890
so kernel rights and this lock reads

00:20:40,990 --> 00:20:45,670
there's

00:20:41,890 --> 00:20:49,450
it doesn't read on deaf K lock and can

00:20:45,670 --> 00:20:51,400
overflow and if this lock is reading

00:20:49,450 --> 00:20:53,740
slower than your device debugging

00:20:51,400 --> 00:20:57,130
messages appear then it will overwrite

00:20:53,740 --> 00:20:59,980
and you lose some messages and it's very

00:20:57,130 --> 00:21:01,870
hard I once I try to debug the USB stick

00:20:59,980 --> 00:21:04,300
in the filter I have this message and

00:21:01,870 --> 00:21:06,970
have that message and how can that

00:21:04,300 --> 00:21:08,710
happen and I read the code and it

00:21:06,970 --> 00:21:11,770
couldn't happen yeah but just know

00:21:08,710 --> 00:21:14,350
aright and those messages had nothing to

00:21:11,770 --> 00:21:18,130
do with each other a lot of other

00:21:14,350 --> 00:21:20,020
messages in between so the kernel is

00:21:18,130 --> 00:21:23,530
counting the bytes it is overwriting it

00:21:20,020 --> 00:21:25,150
can count the bytes and when such lock

00:21:23,530 --> 00:21:27,610
doesn't read and I see the counter is

00:21:25,150 --> 00:21:28,960
not zero and I've locked lost some byte

00:21:27,610 --> 00:21:31,750
and the first thing the carnival rides

00:21:28,960 --> 00:21:34,690
to the syslog is this message and then

00:21:31,750 --> 00:21:36,640
you see ah there was a gap now I know

00:21:34,690 --> 00:21:42,700
what's going on when I'm debugging this

00:21:36,640 --> 00:21:46,840
device driver so what do we do when we

00:21:42,700 --> 00:21:49,350
lock remotely so this lock D can do a

00:21:46,840 --> 00:21:49,350
lot of things

00:21:57,169 --> 00:22:04,350
so we have a sender some some lock host

00:22:01,200 --> 00:22:06,149
that is sending us messages we can get

00:22:04,350 --> 00:22:09,000
messages from some processors who do

00:22:06,149 --> 00:22:10,230
logging the kernel generates its

00:22:09,000 --> 00:22:13,889
messages himself

00:22:10,230 --> 00:22:16,649
and then we can write it to a file we

00:22:13,889 --> 00:22:19,049
can spawn a process and pipe it into it

00:22:16,649 --> 00:22:23,039
we have a memory buffer where we can

00:22:19,049 --> 00:22:25,139
store such log messages temporarily

00:22:23,039 --> 00:22:28,159
that's interesting for diskless machines

00:22:25,139 --> 00:22:31,139
and then we have a special syslog C

00:22:28,159 --> 00:22:33,120
command that communicates with over UNIX

00:22:31,139 --> 00:22:37,169
domain socket this is lock and then it

00:22:33,120 --> 00:22:39,990
reads out the messages yeah it has been

00:22:37,169 --> 00:22:41,610
added to OpenBSD it was there when I

00:22:39,990 --> 00:22:54,600
looked into it but it's an open BSD

00:22:41,610 --> 00:22:58,889
feature then yeah but I think I saw it

00:22:54,600 --> 00:23:01,740
in other beasties so hmm so pipe is

00:22:58,889 --> 00:23:07,980
there in FreeBSD so whoever copied it

00:23:01,740 --> 00:23:09,720
from okay so Henning says so Henning

00:23:07,980 --> 00:23:13,980
says everybody copies from open BSD

00:23:09,720 --> 00:23:16,350
there's no other direction but I'm doubt

00:23:13,980 --> 00:23:18,120
that that's right and I would also say

00:23:16,350 --> 00:23:20,399
it's not good if it's if it would be

00:23:18,120 --> 00:23:24,559
right because they're also good other

00:23:20,399 --> 00:23:24,559
things another BSD that we should share

00:23:27,500 --> 00:23:32,580
so Hanning so I'm supposed to repeat

00:23:30,690 --> 00:23:36,440
everything that Henning says and now

00:23:32,580 --> 00:23:36,440
handing did some jokes about himself

00:23:38,240 --> 00:23:46,080
okay so we can send the messages to

00:23:42,899 --> 00:23:48,899
other remote logging facilities we can

00:23:46,080 --> 00:23:51,389
write something to the console we can

00:23:48,899 --> 00:23:53,610
write something to every users terminal

00:23:51,389 --> 00:23:55,620
right all we can write something to

00:23:53,610 --> 00:23:58,320
special users you can put users in your

00:23:55,620 --> 00:24:01,590
syslog file so root gets messages or

00:23:58,320 --> 00:24:08,159
Hennig or whatever and you can write

00:24:01,590 --> 00:24:10,260
some specialty device so let's look at

00:24:08,159 --> 00:24:12,629
the at the details that's more or less

00:24:10,260 --> 00:24:15,210
what I already explained when you have

00:24:12,629 --> 00:24:17,730
the process it uses either the Newton

00:24:15,210 --> 00:24:19,980
method sensors lock or death lock we

00:24:17,730 --> 00:24:22,049
kept the old method to be backwards

00:24:19,980 --> 00:24:25,919
compatible not everyone is using lip see

00:24:22,049 --> 00:24:27,750
there's a problem modules lock where you

00:24:25,919 --> 00:24:29,549
can say I use UNIX domain socket and

00:24:27,750 --> 00:24:32,159
uses that perhaps you have some programs

00:24:29,549 --> 00:24:34,049
around that still use that and then you

00:24:32,159 --> 00:24:37,139
can add additional UNIX sockets that's

00:24:34,049 --> 00:24:39,510
basically for putting your def lock in

00:24:37,139 --> 00:24:41,129
all your change root environments you

00:24:39,510 --> 00:24:46,980
can specify multiple of them on the

00:24:41,129 --> 00:24:48,960
command line and then we have def K lock

00:24:46,980 --> 00:24:54,899
that's for the messages generated

00:24:48,960 --> 00:24:58,260
generated by the colonel himself so

00:24:54,899 --> 00:25:00,840
let's look at the remote logging okay we

00:24:58,260 --> 00:25:02,760
have ipv4 and ipv6 when I started

00:25:00,840 --> 00:25:08,370
looking at syslog there was only ipv4

00:25:02,760 --> 00:25:15,419
and we can do UDP TCP TLS on both sides

00:25:08,370 --> 00:25:19,919
when I started we only had two UDP so

00:25:15,419 --> 00:25:22,740
how does UDP locking look like we have a

00:25:19,919 --> 00:25:25,740
single UDP packet and that contains a

00:25:22,740 --> 00:25:29,190
lot message and that's it then we have

00:25:25,740 --> 00:25:33,419
some RFC's talking about the size with

00:25:29,190 --> 00:25:35,429
old RFC's that's a I should not more

00:25:33,419 --> 00:25:37,799
than thousand and the end we have others

00:25:35,429 --> 00:25:41,460
who say yeah perhaps we should process

00:25:37,799 --> 00:25:44,669
2000 and then we have on 1 RFC if you

00:25:41,460 --> 00:25:47,909
don't make it longer than 1180 the

00:25:44,669 --> 00:25:49,350
payload then you can assume that it

00:25:47,909 --> 00:25:51,570
doesn't get fragmented and if

00:25:49,350 --> 00:25:52,919
doesn't get fragmented then the chances

00:25:51,570 --> 00:25:58,260
are higher that it will reach the

00:25:52,919 --> 00:26:01,770
destination so what I did is I took this

00:25:58,260 --> 00:26:04,140
value from one of the RFC's and truncate

00:26:01,770 --> 00:26:08,700
every message that I sent to UDP to this

00:26:04,140 --> 00:26:10,559
length so how does it look like we have

00:26:08,700 --> 00:26:13,320
the priority we've seen before

00:26:10,559 --> 00:26:16,410
if the timestamp depending on how you

00:26:13,320 --> 00:26:19,289
set your syslog with - set or not you

00:26:16,410 --> 00:26:22,200
get via the the bsd timestamp or the ESO

00:26:19,289 --> 00:26:28,169
timestamp so then the RFC says here

00:26:22,200 --> 00:26:31,980
comes the first time if our C is called

00:26:28,169 --> 00:26:34,140
BSD syslog format but ours this lock

00:26:31,980 --> 00:26:36,260
doesn't at the hostname so I don't know

00:26:34,140 --> 00:26:40,580
which piece this is log they referred to

00:26:36,260 --> 00:26:45,799
we have an option markers I think edited

00:26:40,580 --> 00:26:48,750
where we can say - H to add this

00:26:45,799 --> 00:26:54,870
hostname or IP address - to every

00:26:48,750 --> 00:26:57,480
message so on then there that there

00:26:54,870 --> 00:27:04,710
comes that what we receive from Lipsy it

00:26:57,480 --> 00:27:06,720
doesn't change yes the question was

00:27:04,710 --> 00:27:10,830
whether I added at sending or receiving

00:27:06,720 --> 00:27:17,820
and the answer is we add it when we send

00:27:10,830 --> 00:27:19,559
it so we so what I do when we when we

00:27:17,820 --> 00:27:21,120
receive a message we start parsing it we

00:27:19,559 --> 00:27:24,330
are looking at the priority that we

00:27:21,120 --> 00:27:26,159
filter it with our config file we look

00:27:24,330 --> 00:27:29,039
at the timestamp we add one if there is

00:27:26,159 --> 00:27:31,200
none I've also added the the - set

00:27:29,039 --> 00:27:33,390
option if you find the old format I

00:27:31,200 --> 00:27:35,640
replace it with a new format because

00:27:33,390 --> 00:27:40,679
here you don't see anything if you have

00:27:35,640 --> 00:27:45,900
global logging and and then it also adds

00:27:40,679 --> 00:27:49,049
this when it doesn't UDP sent but that's

00:27:45,900 --> 00:27:53,909
also an open B is the extension another

00:27:49,049 --> 00:27:55,860
question it's the question is what

00:27:53,909 --> 00:27:58,020
happens if the message is longer and the

00:27:55,860 --> 00:28:00,620
answer is it gets truncated I just

00:27:58,020 --> 00:28:00,620
carried off

00:28:04,220 --> 00:28:12,750
so how does it look in TCP so they are a

00:28:09,600 --> 00:28:14,430
bunch of RFC's we look for Matt doesn't

00:28:12,750 --> 00:28:20,250
know anything about TCP and we have

00:28:14,430 --> 00:28:22,230
newer rfcs RFC about syslog in general

00:28:20,250 --> 00:28:24,780
the next one is all about syslog over

00:28:22,230 --> 00:28:27,330
UDP next one is about syslog over TLS

00:28:24,780 --> 00:28:29,700
and there's no tcp but then you have

00:28:27,330 --> 00:28:33,960
another RC with a bigger number larger

00:28:29,700 --> 00:28:37,200
number and there somebody has written

00:28:33,960 --> 00:28:40,520
down what he's found what syslog

00:28:37,200 --> 00:28:43,290
implementation who is found that use TCP

00:28:40,520 --> 00:28:46,700
so it's a collection of things that are

00:28:43,290 --> 00:28:49,950
out there and usually it just works so

00:28:46,700 --> 00:28:52,460
what we do in the TCP stream we just put

00:28:49,950 --> 00:28:54,750
a new line to split the messages and

00:28:52,460 --> 00:28:56,640
then there are other implementations

00:28:54,750 --> 00:28:59,550
that said oh we want new lines in our

00:28:56,640 --> 00:29:01,080
sausages but that doesn't work if you

00:28:59,550 --> 00:29:03,150
write in the log file because then you

00:29:01,080 --> 00:29:06,390
can't because they are of course the new

00:29:03,150 --> 00:29:08,910
line is the delimiter and I replace

00:29:06,390 --> 00:29:11,510
every Nuala new line that I get

00:29:08,910 --> 00:29:15,630
somewhere with an underscore by the way

00:29:11,510 --> 00:29:20,460
so somebody also use null delimiter to

00:29:15,630 --> 00:29:23,370
split TCP messages and and then they are

00:29:20,460 --> 00:29:26,820
so I split when I read it I think with

00:29:23,370 --> 00:29:29,640
new line and now and then there's an

00:29:26,820 --> 00:29:31,290
octet counting format that's the new

00:29:29,640 --> 00:29:34,920
sheets that's already there's also in

00:29:31,290 --> 00:29:37,590
the in the in the TLS RFC it says are

00:29:34,920 --> 00:29:39,840
you write a decimal number with a number

00:29:37,590 --> 00:29:45,570
of bytes then you make a space and then

00:29:39,840 --> 00:29:48,570
here are 60 bytes till here and then the

00:29:45,570 --> 00:29:51,810
next message starts so what I do when I

00:29:48,570 --> 00:29:55,320
send a message at a new line here so I'm

00:29:51,810 --> 00:30:00,420
compatible with everything except when

00:29:55,320 --> 00:30:04,260
somebody explicitly is expect no

00:30:00,420 --> 00:30:06,270
delimiter but I don't think that that is

00:30:04,260 --> 00:30:08,040
the case so everybody in split splits

00:30:06,270 --> 00:30:11,460
that new line it's just written in that

00:30:08,040 --> 00:30:14,850
RFC and another advantage is when you

00:30:11,460 --> 00:30:16,440
put a new line here it's much easier to

00:30:14,850 --> 00:30:20,100
those messages if you just print them

00:30:16,440 --> 00:30:22,830
out you get a new line every time you

00:30:20,100 --> 00:30:28,050
see a new message and just the the the

00:30:22,830 --> 00:30:30,720
octet county in front so TLS format

00:30:28,050 --> 00:30:32,690
there we have an RFC and it says octet

00:30:30,720 --> 00:30:36,840
counting is the only supported format

00:30:32,690 --> 00:30:41,880
then you must support 2000 rights and

00:30:36,840 --> 00:30:46,940
you should support 8100 and what I did

00:30:41,880 --> 00:30:49,680
is I added a global constant that says

00:30:46,940 --> 00:30:51,540
messages have that maximum size and

00:30:49,680 --> 00:30:53,310
everything else is truncated so

00:30:51,540 --> 00:30:56,250
truncated in Lipsy it's truncated in

00:30:53,310 --> 00:30:57,690
kernel and it's truncated in syslog it

00:30:56,250 --> 00:30:59,130
can even truncate it multiple times

00:30:57,690 --> 00:31:00,990
because we are adding all those

00:30:59,130 --> 00:31:02,370
timestamps and changing things and so it

00:31:00,990 --> 00:31:06,780
can get longer and then gets truncated

00:31:02,370 --> 00:31:09,240
again so truncation is the the right

00:31:06,780 --> 00:31:11,340
thing what to do with syslog messages if

00:31:09,240 --> 00:31:13,440
it don't fit because most of the time

00:31:11,340 --> 00:31:15,300
people can get out figure out what's

00:31:13,440 --> 00:31:17,630
going on at the beginning and it's much

00:31:15,300 --> 00:31:21,150
better than dropping it don't drop them

00:31:17,630 --> 00:31:24,320
so what I did also is converting syslog

00:31:21,150 --> 00:31:27,390
to live event before I had Paul loop and

00:31:24,320 --> 00:31:31,020
doing all this tcp with multiple senders

00:31:27,390 --> 00:31:34,530
and multiple listeners and doing TLS is

00:31:31,020 --> 00:31:36,900
quite hard with paul so theo recommended

00:31:34,530 --> 00:31:40,050
to change to lib TLS that leap event

00:31:36,900 --> 00:31:43,530
that was the first thing I did and then

00:31:40,050 --> 00:31:48,410
I linked to lip TLS to do the TLS stuff

00:31:43,530 --> 00:31:51,720
and I wrote a little wrapper that does

00:31:48,410 --> 00:31:54,540
encryption of lib event buffers by

00:31:51,720 --> 00:31:57,000
sending them through Lib TLS since then

00:31:54,540 --> 00:32:00,780
instead of doing plain read and writes

00:31:57,000 --> 00:32:02,820
and this is one C file located and this

00:32:00,780 --> 00:32:07,980
lock directory and it has already been

00:32:02,820 --> 00:32:11,190
copied to our LDAP D demon that also

00:32:07,980 --> 00:32:13,140
needs that feature and you are the

00:32:11,190 --> 00:32:15,660
things that in open BSD we have a rather

00:32:13,140 --> 00:32:19,500
old lip TLS because we think the new one

00:32:15,660 --> 00:32:19,830
lip TLS to is lip event sorry sorry

00:32:19,500 --> 00:32:22,560
sorry

00:32:19,830 --> 00:32:27,320
lip event the live event is its feature

00:32:22,560 --> 00:32:28,380
bloat so we have a lip event of 114

00:32:27,320 --> 00:32:34,050
something

00:32:28,380 --> 00:32:36,360
yeah yeah yeah we are still a P a P

00:32:34,050 --> 00:32:38,700
comfortable so things that when you

00:32:36,360 --> 00:32:41,700
develop something with the OpenBSD lip

00:32:38,700 --> 00:32:44,160
event and copy it to Linux and take the

00:32:41,700 --> 00:32:47,010
old lip event there then it still works

00:32:44,160 --> 00:32:49,260
but I've done a lot of clean up there

00:32:47,010 --> 00:32:51,450
and internally it looks quite different

00:32:49,260 --> 00:32:54,570
that's also the reason why I didn't that

00:32:51,450 --> 00:32:56,190
it's feature to our lip event because

00:32:54,570 --> 00:32:58,440
then we wouldn't be our P comfortable

00:32:56,190 --> 00:33:00,170
anymore anymore I've looked in lip event

00:32:58,440 --> 00:33:04,170
too they have something like that

00:33:00,170 --> 00:33:06,600
so if you write portable programs just

00:33:04,170 --> 00:33:13,340
use lip event - and if you do OpenBSD

00:33:06,600 --> 00:33:13,340
programming just edit here locally

00:33:24,250 --> 00:33:29,830
so what you also have to do when you do

00:33:26,350 --> 00:33:32,320
TLS you have to care about identifying

00:33:29,830 --> 00:33:35,440
your communication partner and doing

00:33:32,320 --> 00:33:38,260
some certificate checks and as usual

00:33:35,440 --> 00:33:41,169
certificates complicated you have this

00:33:38,260 --> 00:33:42,730
public key infrastructure and nobody can

00:33:41,169 --> 00:33:46,210
set it up and understands how it should

00:33:42,730 --> 00:33:48,909
work and what it really does so I've

00:33:46,210 --> 00:33:51,760
implemented everything what you what you

00:33:48,909 --> 00:33:58,120
may need and now I've put it on four

00:33:51,760 --> 00:34:00,039
slides for every use case so what you

00:33:58,120 --> 00:34:02,799
always have to do if you want to accept

00:34:00,039 --> 00:34:03,850
encrypted messages you have to provide a

00:34:02,799 --> 00:34:06,429
server certificate

00:34:03,850 --> 00:34:12,190
so our syslog d-- uses the service

00:34:06,429 --> 00:34:16,060
certificate here and you put it in et

00:34:12,190 --> 00:34:17,590
Cie SSL together with the hostname you

00:34:16,060 --> 00:34:20,710
have you can also put an IP address here

00:34:17,590 --> 00:34:22,300
so the idea is to enable receiving TLS

00:34:20,710 --> 00:34:26,560
it's not enabled by default

00:34:22,300 --> 00:34:29,050
you put a t here minus capital T and you

00:34:26,560 --> 00:34:34,060
say the host where you that's an IP

00:34:29,050 --> 00:34:36,879
address you can also say to listen on a

00:34:34,060 --> 00:34:41,770
star socket you put a port if you leave

00:34:36,879 --> 00:34:45,010
it out the TLS port is 6514 we also have

00:34:41,770 --> 00:34:49,659
a 514 for UDP and there's no well-known

00:34:45,010 --> 00:34:51,429
port for TCP because the 514 TCP number

00:34:49,659 --> 00:34:58,450
has been used by some remote shell

00:34:51,429 --> 00:35:00,369
whatever old UNIX tool so but people use

00:34:58,450 --> 00:35:05,440
it anyway just just use this nobody it

00:35:00,369 --> 00:35:08,310
does remote shell and so what I did here

00:35:05,440 --> 00:35:11,470
it Real ID does the same so you can put

00:35:08,310 --> 00:35:13,450
certificates for your your machine and

00:35:11,470 --> 00:35:16,150
keys and private keys you just put them

00:35:13,450 --> 00:35:18,580
there and then syslog D uses it you can

00:35:16,150 --> 00:35:20,560
also add the port here then you can use

00:35:18,580 --> 00:35:26,320
specific certificates for syslog and

00:35:20,560 --> 00:35:28,180
Real ID so why do we do that because

00:35:26,320 --> 00:35:31,119
when we have a certificate here's our

00:35:28,180 --> 00:35:33,910
certificate here the sender knows with

00:35:31,119 --> 00:35:36,760
whom it's talking so the sender can

00:35:33,910 --> 00:35:37,640
identify the drain of all the messages

00:35:36,760 --> 00:35:40,069
and that

00:35:37,640 --> 00:35:42,529
means the attacker cannot redirect the

00:35:40,069 --> 00:35:49,369
messages to himself and you cannot see

00:35:42,529 --> 00:35:51,650
our messages so another thing

00:35:49,369 --> 00:35:56,390
funny thing about LS is you can have

00:35:51,650 --> 00:35:58,609
client certificates so then the client

00:35:56,390 --> 00:36:01,069
provides a certificate and we want to

00:35:58,609 --> 00:36:03,710
figure out whether it's the correct one

00:36:01,069 --> 00:36:07,609
first we have to enable it enable using

00:36:03,710 --> 00:36:12,260
TCP or TLS at all and we specify a

00:36:07,609 --> 00:36:14,690
certificate authority file and every

00:36:12,260 --> 00:36:16,279
time a sender tries to connect to us we

00:36:14,690 --> 00:36:19,369
asked him show me your client

00:36:16,279 --> 00:36:24,440
certificate and we check whether it's

00:36:19,369 --> 00:36:25,940
signed with this CA and if it is we we

00:36:24,440 --> 00:36:27,950
take the message otherwise we don't take

00:36:25,940 --> 00:36:30,529
it that means this is logged II can

00:36:27,950 --> 00:36:33,680
identify the sender who wants to talk to

00:36:30,529 --> 00:36:35,779
us and the attacker cannot inject

00:36:33,680 --> 00:36:42,500
messages so nobody else is allowed to

00:36:35,779 --> 00:36:45,309
send something to us so that's the other

00:36:42,500 --> 00:36:48,519
side when we want to send something out

00:36:45,309 --> 00:36:51,470
so first the first thing I had to do is

00:36:48,519 --> 00:36:54,230
thinking about a format how to specify

00:36:51,470 --> 00:36:56,930
that I want to use TLS if you give it in

00:36:54,230 --> 00:36:58,819
the in the config file of syslog this

00:36:56,930 --> 00:37:00,740
lock conf and what it was there

00:36:58,819 --> 00:37:03,529
classically is that you use a net sign

00:37:00,740 --> 00:37:06,140
and then IP or hostname and then you

00:37:03,529 --> 00:37:08,450
send you two UDP packet there and what I

00:37:06,140 --> 00:37:12,410
wanted to do was able to specify all

00:37:08,450 --> 00:37:17,750
tagged TCP take ipv4 take ipv6 so you

00:37:12,410 --> 00:37:19,849
can say here TLS tcp or UDP and then you

00:37:17,750 --> 00:37:21,769
can also optionally add in for or in six

00:37:19,849 --> 00:37:24,380
and then it will you will be forced to

00:37:21,769 --> 00:37:26,869
that protocol to that IP version and

00:37:24,380 --> 00:37:29,359
yeah i thought about how to specify it

00:37:26,869 --> 00:37:31,880
and then I took just something that

00:37:29,359 --> 00:37:33,799
looks like and you're the prefix of a

00:37:31,880 --> 00:37:35,450
URL because I'm sure that that will not

00:37:33,799 --> 00:37:37,700
collide with the hostname and I can

00:37:35,450 --> 00:37:40,940
parse it reliably if somebody has better

00:37:37,700 --> 00:37:46,930
idea and does things that doesn't look

00:37:40,940 --> 00:37:52,380
like I'm open for suggestions so

00:37:46,930 --> 00:37:56,380
then if we want to send something out

00:37:52,380 --> 00:37:58,030
the receivers this lock cost the

00:37:56,380 --> 00:38:01,480
receiver lock cost as a server

00:37:58,030 --> 00:38:03,160
certificate is every TLS server and we

00:38:01,480 --> 00:38:08,560
want to validate it so you can either

00:38:03,160 --> 00:38:11,170
specify a CA file if it's PK or if you

00:38:08,560 --> 00:38:13,870
want to send something too well-known so

00:38:11,170 --> 00:38:15,460
it's not T is that the NSA or at Google

00:38:13,870 --> 00:38:17,860
or wherever you want to have your

00:38:15,460 --> 00:38:20,620
messages then just take something that

00:38:17,860 --> 00:38:26,010
is provided by upstream that's the

00:38:20,620 --> 00:38:31,510
default certificate store and OpenBSD so

00:38:26,010 --> 00:38:33,160
Swiss lock must know the CA and the the

00:38:31,510 --> 00:38:37,030
hostname must also be in the service

00:38:33,160 --> 00:38:42,160
certificate so that nobody else that

00:38:37,030 --> 00:38:45,190
belongs to the same infrastructure can

00:38:42,160 --> 00:38:49,030
can spoof it and so the hostname you

00:38:45,190 --> 00:38:52,780
specify here must be in the common name

00:38:49,030 --> 00:38:55,000
of the certificate or in the subject out

00:38:52,780 --> 00:38:59,680
named lib TLS and Allah handles that for

00:38:55,000 --> 00:39:03,610
us and so we we can identify to whom we

00:38:59,680 --> 00:39:08,230
are sending messages and so we the

00:39:03,610 --> 00:39:10,870
attacker cannot redirect it and the

00:39:08,230 --> 00:39:14,110
messages are confidential and if

00:39:10,870 --> 00:39:16,330
everything this PKA and this thing is

00:39:14,110 --> 00:39:17,410
too complicated turned on by default you

00:39:16,330 --> 00:39:19,570
can just disable it

00:39:17,410 --> 00:39:21,070
so for test environments that might be

00:39:19,570 --> 00:39:23,170
useful or if you don't care who's

00:39:21,070 --> 00:39:26,520
reading your messages and just want to

00:39:23,170 --> 00:39:26,520
get it off get them off

00:39:27,960 --> 00:39:38,820
so that's the final certificate slide so

00:39:35,200 --> 00:39:41,350
here we use client certificates

00:39:38,820 --> 00:39:45,700
ourselves you can specify them on the

00:39:41,350 --> 00:39:48,160
command line and then the receiver can

00:39:45,700 --> 00:39:52,750
check them and so he's sure that he's

00:39:48,160 --> 00:39:56,400
getting the messages from us and the

00:39:52,750 --> 00:39:56,400
attacker does not inject anything

00:39:59,660 --> 00:40:06,380
so how does the error handling work we

00:40:08,770 --> 00:40:11,920
[Music]

00:40:13,910 --> 00:40:23,849
know we wanted to say that that we we

00:40:17,789 --> 00:40:26,910
lock all incoming connections so what I

00:40:23,849 --> 00:40:28,680
first implemented is that we write a

00:40:26,910 --> 00:40:31,710
message every time we accept something

00:40:28,680 --> 00:40:34,529
and somebody closes the connection to us

00:40:31,710 --> 00:40:36,869
and then somebody complained all its

00:40:34,529 --> 00:40:39,660
fills up all our lock file so I

00:40:36,869 --> 00:40:42,630
converted that to debug messages so this

00:40:39,660 --> 00:40:44,640
lock is in a special facility so syslog

00:40:42,630 --> 00:40:46,259
can Andy you can identify all the

00:40:44,640 --> 00:40:48,809
messages that again have generated by

00:40:46,259 --> 00:40:50,819
syslog itself it's a facility and I

00:40:48,809 --> 00:40:53,670
changed the priority to or the severity

00:40:50,819 --> 00:40:55,920
to debug and so it's not locked by

00:40:53,670 --> 00:40:57,900
default but you can turn it on and see

00:40:55,920 --> 00:40:59,910
but who is connecting to me and when you

00:40:57,900 --> 00:41:02,640
set up your users log environment it's

00:40:59,910 --> 00:41:04,859
maybe useful and you can leave it on if

00:41:02,640 --> 00:41:07,200
you don't have too many messages but if

00:41:04,859 --> 00:41:09,059
you have thousand clients rebooting

00:41:07,200 --> 00:41:12,809
every hour then of course you don't want

00:41:09,059 --> 00:41:15,719
to see all that we lock connection

00:41:12,809 --> 00:41:17,489
errors so when when something goes wrong

00:41:15,719 --> 00:41:19,469
with a connection to a client we lock an

00:41:17,489 --> 00:41:21,479
error and you see oh something is wrong

00:41:19,469 --> 00:41:24,450
and I lost some messages or may lose

00:41:21,479 --> 00:41:29,150
some messages and we count the dropped

00:41:24,450 --> 00:41:31,799
messages we have buffers buffers to

00:41:29,150 --> 00:41:34,920
sending buffers for for the messages and

00:41:31,799 --> 00:41:36,779
if we get a sick hop we throw them away

00:41:34,920 --> 00:41:38,819
if you cannot kind of write anymore they

00:41:36,779 --> 00:41:41,880
fill up and get its hiccup we throw them

00:41:38,819 --> 00:41:44,039
away we get a sick term we throw them

00:41:41,880 --> 00:41:47,219
away then we count the messages that are

00:41:44,039 --> 00:41:52,019
in the buffer and lock that so you can

00:41:47,219 --> 00:41:56,519
see how many messages were not sent to a

00:41:52,019 --> 00:41:58,799
TCP destination it's not completely

00:41:56,519 --> 00:42:02,700
reliable because the kernel also locks

00:41:58,799 --> 00:42:04,529
some messages and the kernel throws the

00:42:02,700 --> 00:42:08,519
buffers away if there's an error on the

00:42:04,529 --> 00:42:11,520
TCP connection and but when you see oh

00:42:08,519 --> 00:42:14,040
we have an connection error

00:42:11,520 --> 00:42:15,630
then you know although it may also some

00:42:14,040 --> 00:42:17,850
lock messages be lost because the

00:42:15,630 --> 00:42:19,680
colonel has thrown away the kernel

00:42:17,850 --> 00:42:21,869
buffers and more than that are locked

00:42:19,680 --> 00:42:25,560
here that are the messages that are

00:42:21,869 --> 00:42:27,480
dropped in userland it's just luck to

00:42:25,560 --> 00:42:30,000
use a line so it looks like this so it's

00:42:27,480 --> 00:42:33,330
lucky because generated the message just

00:42:30,000 --> 00:42:35,190
drop two messages and it also locks the

00:42:33,330 --> 00:42:38,970
name of the host where it wanted to send

00:42:35,190 --> 00:42:44,190
them and what are also implemented when

00:42:38,970 --> 00:42:46,260
you have multiple messages mmm then just

00:42:44,190 --> 00:42:47,640
lock T writes message repeated it

00:42:46,260 --> 00:42:49,560
doesn't write the same stuff all the

00:42:47,640 --> 00:42:51,000
time it's important for local logging

00:42:49,560 --> 00:42:53,460
because otherwise you can fill up your

00:42:51,000 --> 00:42:54,869
log files easily but it's bad for remote

00:42:53,460 --> 00:42:58,200
logging because when you have multiple

00:42:54,869 --> 00:43:03,210
suits locks then you're not sure to

00:42:58,200 --> 00:43:05,790
which message the the last message drop

00:43:03,210 --> 00:43:08,610
belongs then you can turn it off either

00:43:05,790 --> 00:43:12,180
for remote logging or even globally with

00:43:08,610 --> 00:43:19,470
a minus R option so now let's go to the

00:43:12,180 --> 00:43:21,900
conclusion so I've the new message flow

00:43:19,470 --> 00:43:23,550
of here and I have made it italic

00:43:21,900 --> 00:43:25,109
everything that has changed so for the

00:43:23,550 --> 00:43:28,530
program nothing has changed this is what

00:43:25,109 --> 00:43:31,050
Cole looks the same and here and let's

00:43:28,530 --> 00:43:32,880
see we have no timestamp anymore and we

00:43:31,050 --> 00:43:35,760
do call the special sense

00:43:32,880 --> 00:43:38,130
this locks us call and not a cent the

00:43:35,760 --> 00:43:39,810
kernel has the sensors log and it knows

00:43:38,130 --> 00:43:42,900
about logging errors and counts the

00:43:39,810 --> 00:43:45,090
arrows and this log de still receives it

00:43:42,900 --> 00:43:47,340
it's no different whether we use receive

00:43:45,090 --> 00:43:47,790
from a socket pair or from or from UNIX

00:43:47,340 --> 00:43:50,520
socket

00:43:47,790 --> 00:43:52,710
it adds the timestamp so we have one

00:43:50,520 --> 00:43:56,190
sing an instant this is responsible for

00:43:52,710 --> 00:43:58,619
timestamps it writes it to a log file

00:43:56,190 --> 00:44:06,330
that didn't change and you can also send

00:43:58,619 --> 00:44:09,690
to TLS or TCP so that's new so what also

00:44:06,330 --> 00:44:11,520
has to be done to be reliable logging to

00:44:09,690 --> 00:44:14,119
have a reliable lock system on your

00:44:11,520 --> 00:44:16,290
machine first of all syslog may not die

00:44:14,119 --> 00:44:19,560
normally when you write programs it's a

00:44:16,290 --> 00:44:22,260
good idea to die and fix the back if

00:44:19,560 --> 00:44:24,570
anything goes wrong die but if circular

00:44:22,260 --> 00:44:25,260
dies you're blind you don't see anything

00:44:24,570 --> 00:44:27,210
what's going

00:44:25,260 --> 00:44:30,780
perhaps the attacker wanted to kill this

00:44:27,210 --> 00:44:31,950
lock by some funky thing and you don't

00:44:30,780 --> 00:44:34,830
know what's going on

00:44:31,950 --> 00:44:36,750
so soos lock tries to run it locks all

00:44:34,830 --> 00:44:38,640
the errors it gets it start up or and

00:44:36,750 --> 00:44:39,420
whatever maybe you lose some lock

00:44:38,640 --> 00:44:41,820
systems

00:44:39,420 --> 00:44:43,950
you can't bind to the UDP socket and you

00:44:41,820 --> 00:44:46,980
it doesn't work or TCP socket is wrong

00:44:43,950 --> 00:44:50,430
doesn't work gets a lock message but

00:44:46,980 --> 00:44:53,100
still running other messages appear so

00:44:50,430 --> 00:44:56,880
we count the dropped messages internally

00:44:53,100 --> 00:44:58,740
we make TCP and TLS support because they

00:44:56,880 --> 00:45:02,190
are more reliable and more confidential

00:44:58,740 --> 00:45:04,560
than UDP we changed everything to live

00:45:02,190 --> 00:45:07,650
event that means we get safe signal

00:45:04,560 --> 00:45:09,990
handlers we don't have to to do all

00:45:07,650 --> 00:45:12,630
those dances with sig prop mask 2 to

00:45:09,990 --> 00:45:14,310
avoid some races here and there all the

00:45:12,630 --> 00:45:16,050
signal handlers are not real signal

00:45:14,310 --> 00:45:19,800
handlers they run the main program flow

00:45:16,050 --> 00:45:22,140
live event handles that for us we cope

00:45:19,800 --> 00:45:24,570
with file descriptor exhaustion when you

00:45:22,140 --> 00:45:27,660
write a server that accepts a lot of

00:45:24,570 --> 00:45:29,970
things like incoming TLS syslog messages

00:45:27,660 --> 00:45:35,790
you run against your process limit and

00:45:29,970 --> 00:45:37,680
then and then you critical file

00:45:35,790 --> 00:45:39,090
descriptors you cannot open anymore for

00:45:37,680 --> 00:45:41,100
example if we run with proof SAP that

00:45:39,090 --> 00:45:46,530
means we have file descriptor passing

00:45:41,100 --> 00:45:49,740
between a low privileged process that

00:45:46,530 --> 00:45:51,720
does all the the network handling

00:45:49,740 --> 00:45:53,990
because now we do TLS we have to be

00:45:51,720 --> 00:45:56,550
careful here and we have a privileged

00:45:53,990 --> 00:45:58,680
program that opens the lock file we have

00:45:56,550 --> 00:46:00,930
to do it at every CCAP for example and

00:45:58,680 --> 00:46:03,780
we have to open consoles and TT wise and

00:46:00,930 --> 00:46:08,820
read user databases to census messages

00:46:03,780 --> 00:46:11,310
to special users so and then we do file

00:46:08,820 --> 00:46:14,720
descriptor passing so we have to we need

00:46:11,310 --> 00:46:17,820
a reserved for file descriptors and

00:46:14,720 --> 00:46:19,710
syslog handles test because incoming TCP

00:46:17,820 --> 00:46:23,369
and TLS connections will always leave

00:46:19,710 --> 00:46:27,420
about 10 file descriptors not allocated

00:46:23,369 --> 00:46:32,550
there for internal use you know already

00:46:27,420 --> 00:46:35,240
set we have proof sec proofs app what's

00:46:32,550 --> 00:46:37,350
important to to avoid blind rope attacks

00:46:35,240 --> 00:46:38,970
there's there's an attack when you have

00:46:37,350 --> 00:46:42,690
when you do four

00:46:38,970 --> 00:46:44,490
same address random andrás layout in two

00:46:42,690 --> 00:46:46,319
processes and if you can probe the one

00:46:44,490 --> 00:46:48,750
you can gather information about the

00:46:46,319 --> 00:46:49,670
other and to fix that you have to make

00:46:48,750 --> 00:46:53,369
an exit call

00:46:49,670 --> 00:46:55,740
normally we exact the child here we exit

00:46:53,369 --> 00:46:57,690
the parent because it was much easier to

00:46:55,740 --> 00:46:59,849
implement in this locti because this

00:46:57,690 --> 00:47:04,650
lagdi does a lot of startup things with

00:46:59,849 --> 00:47:06,900
four and then it has the fork and so if

00:47:04,650 --> 00:47:10,380
I exact the child all the startup is is

00:47:06,900 --> 00:47:14,880
lost and the child needs the startup the

00:47:10,380 --> 00:47:17,040
startup in in its initialization and the

00:47:14,880 --> 00:47:19,050
the parent only serves some some

00:47:17,040 --> 00:47:21,210
requests like doing do D and s open some

00:47:19,050 --> 00:47:23,640
log files and there it's better to lose

00:47:21,210 --> 00:47:26,310
all the states so I do the exact and

00:47:23,640 --> 00:47:29,940
I've just a minimal program just doing

00:47:26,310 --> 00:47:32,339
the I message to request things and we

00:47:29,940 --> 00:47:34,940
run pledge in both processes the child

00:47:32,339 --> 00:47:34,940
and the parent

00:47:36,410 --> 00:47:42,210
so I've already written some tests

00:47:38,970 --> 00:47:47,339
usually before I change programs I I

00:47:42,210 --> 00:47:49,589
write some regression tests and then I

00:47:47,339 --> 00:47:51,660
fixed the box and then I add the new

00:47:49,589 --> 00:47:53,280
features that's the the evil thing about

00:47:51,660 --> 00:47:55,560
writing tests you always find box and

00:47:53,280 --> 00:48:00,089
then you have fixed them so don't do

00:47:55,560 --> 00:48:02,760
that so the tests work in the way that

00:48:00,089 --> 00:48:06,690
they generate some some country

00:48:02,760 --> 00:48:08,609
sark this is lock D then they process

00:48:06,690 --> 00:48:10,319
the client process generates some log

00:48:08,609 --> 00:48:13,740
files then let's stop everything and

00:48:10,319 --> 00:48:15,569
then I check and what can I check I can

00:48:13,740 --> 00:48:17,220
check the standard error output of this

00:48:15,569 --> 00:48:19,650
lock pieces like these runs in debug

00:48:17,220 --> 00:48:21,540
mode where every debug message and all

00:48:19,650 --> 00:48:24,450
other log messages are print is there so

00:48:21,540 --> 00:48:26,099
I can see what's going on the client

00:48:24,450 --> 00:48:28,619
writes a lock but it's sending to syslog

00:48:26,099 --> 00:48:33,690
he can use native so in syslog methods

00:48:28,619 --> 00:48:35,250
or UDP or TLS or tcp or whatever the

00:48:33,690 --> 00:48:37,589
server also has a lock what you've

00:48:35,250 --> 00:48:39,300
received from syslog d we have a log

00:48:37,589 --> 00:48:41,609
file we can look into that i spawned

00:48:39,300 --> 00:48:44,910
some pipes there and I look into that I

00:48:41,609 --> 00:48:46,829
make some console redirection to see

00:48:44,910 --> 00:48:51,329
that everything goes to the console that

00:48:46,829 --> 00:48:52,589
is specified there I create some fake

00:48:51,329 --> 00:48:57,839
users

00:48:52,589 --> 00:49:00,150
and that I enter in the user temp file

00:48:57,839 --> 00:49:01,799
and then syslog looks into that and

00:49:00,150 --> 00:49:03,449
writes there on the console and if

00:49:01,799 --> 00:49:05,339
redirect with the console look into the

00:49:03,449 --> 00:49:06,630
users console oh they use those

00:49:05,339 --> 00:49:08,819
terminals sorry it's it's terminal

00:49:06,630 --> 00:49:12,329
redirection and I look into the terminal

00:49:08,819 --> 00:49:14,459
that from my fake user just locti

00:49:12,329 --> 00:49:16,019
creates a kay trace I can grab in the K

00:49:14,459 --> 00:49:18,630
trace if it does the the correct system

00:49:16,019 --> 00:49:22,619
calls and I can look in the F step if

00:49:18,630 --> 00:49:30,539
it's has opened the ride sockets yes a

00:49:22,619 --> 00:49:33,630
question oh that's not regression

00:49:30,539 --> 00:49:35,729
framework itself it's the other question

00:49:33,630 --> 00:49:38,489
repeating the question was how I test

00:49:35,729 --> 00:49:40,229
that something has been written to the

00:49:38,489 --> 00:49:44,219
console with our regression framework

00:49:40,229 --> 00:49:45,869
and the answer is it's not a framework

00:49:44,219 --> 00:49:48,390
itself it's something implemented in

00:49:45,869 --> 00:49:51,719
this syslog test some pearl modules that

00:49:48,390 --> 00:49:54,089
do things and there's the thing that you

00:49:51,719 --> 00:49:56,789
have in X you have the X console it's a

00:49:54,089 --> 00:49:58,709
program and it tells the kernel redirect

00:49:56,789 --> 00:50:01,109
everything that written to the console

00:49:58,709 --> 00:50:03,779
into this window and I use that

00:50:01,109 --> 00:50:06,959
mechanism to lock everything that is

00:50:03,779 --> 00:50:08,759
written to the console into a process in

00:50:06,959 --> 00:50:12,170
the process rights into the file and at

00:50:08,759 --> 00:50:12,170
the end of the test I grab in the file

00:50:12,229 --> 00:50:15,229
yep

00:50:16,160 --> 00:50:21,779
so and of course software is never

00:50:19,259 --> 00:50:25,679
finished I always say only that projects

00:50:21,779 --> 00:50:28,589
generate stable software so what else

00:50:25,679 --> 00:50:31,049
can we do here so the thing is when you

00:50:28,589 --> 00:50:33,119
prepare such a talk you look into the

00:50:31,049 --> 00:50:36,059
code and think oh that's all buggy that

00:50:33,119 --> 00:50:38,699
could be done better so the first thing

00:50:36,059 --> 00:50:40,319
I thought is all those in a civilization

00:50:38,699 --> 00:50:42,359
errors that I've written to standard

00:50:40,319 --> 00:50:45,359
error or the console when syslog goes up

00:50:42,359 --> 00:50:48,299
cannot be written into a log file

00:50:45,359 --> 00:50:49,979
because they are not there and I could

00:50:48,299 --> 00:50:52,319
count the arrows have a different for

00:50:49,979 --> 00:50:54,420
that it's on tech and that's meant as a

00:50:52,319 --> 00:51:05,910
hint for some code developers to do the

00:50:54,420 --> 00:51:06,540
review then I went to the our quality

00:51:05,910 --> 00:51:08,490
assurance

00:51:06,540 --> 00:51:10,230
at in WA and said oh now we have

00:51:08,490 --> 00:51:11,850
reliable walking and we don't lose

00:51:10,230 --> 00:51:15,060
anything and he tested it and says oh

00:51:11,850 --> 00:51:16,290
and the file system is full you stop

00:51:15,060 --> 00:51:18,690
logging yeah and it's true it's just

00:51:16,290 --> 00:51:21,120
luck gets twice an error when right so

00:51:18,690 --> 00:51:23,550
file descriptor and file system

00:51:21,120 --> 00:51:25,260
exhausted then it stops logging there

00:51:23,550 --> 00:51:27,720
even if the file system gets empty again

00:51:25,260 --> 00:51:29,460
so if it if for that but it it sits on

00:51:27,720 --> 00:51:31,050
top on the other diff so I will send it

00:51:29,460 --> 00:51:33,450
out when the first one has been reviewed

00:51:31,050 --> 00:51:34,200
and committed I also have a test for

00:51:33,450 --> 00:51:38,400
that I filler

00:51:34,200 --> 00:51:40,620
I create a file system with def VND fill

00:51:38,400 --> 00:51:44,550
it up right lock file to that get the

00:51:40,620 --> 00:51:45,900
error and then check that it and I empty

00:51:44,550 --> 00:51:48,240
it again and check that it's rocked

00:51:45,900 --> 00:51:52,350
again and read all the debug messages

00:51:48,240 --> 00:51:54,690
that just lofty creates for that so then

00:51:52,350 --> 00:51:57,900
I have read the read the old RFC with

00:51:54,690 --> 00:52:01,110
the host name and there's a new RFC how

00:51:57,900 --> 00:52:02,460
to write remote source lock messages and

00:52:01,110 --> 00:52:05,040
they have version numbers there and

00:52:02,460 --> 00:52:08,460
other features and we are somewhere in

00:52:05,040 --> 00:52:12,840
between but not quite and perhaps we

00:52:08,460 --> 00:52:15,030
should get more RFC compliant that's

00:52:12,840 --> 00:52:17,670
also whenever preparing to talk and then

00:52:15,030 --> 00:52:19,290
yeah you go through this conferences

00:52:17,670 --> 00:52:21,210
talk to other develop says oh I do a

00:52:19,290 --> 00:52:23,310
talk here make some promotion that

00:52:21,210 --> 00:52:25,770
people come here and then MPI says oh I

00:52:23,310 --> 00:52:29,280
still have a back there and can you fix

00:52:25,770 --> 00:52:31,890
it before you do it talk no didn't fix

00:52:29,280 --> 00:52:36,870
it but I promised him to put it on the

00:52:31,890 --> 00:52:39,810
slide and then yesterday at the social

00:52:36,870 --> 00:52:42,630
event I was talking with Umbra from the

00:52:39,810 --> 00:52:44,520
Dragonfly project and he said oh yeah

00:52:42,630 --> 00:52:47,940
you know when you when you when you do

00:52:44,520 --> 00:52:49,890
this startup then you get the DMS things

00:52:47,940 --> 00:52:51,510
and when so Spock reads the DM is

00:52:49,890 --> 00:52:53,370
buffered it's the time time there and

00:52:51,510 --> 00:52:55,800
wouldn't it be better when the kana

00:52:53,370 --> 00:52:57,840
let's the time stamp it could use the

00:52:55,800 --> 00:53:00,120
the uptime and syslog can create it to

00:52:57,840 --> 00:53:03,300
to regular timestamps then we would know

00:53:00,120 --> 00:53:04,830
in what order those messages come and so

00:53:03,300 --> 00:53:08,220
the problem is in our company we have a

00:53:04,830 --> 00:53:09,660
central configuration thing and they put

00:53:08,220 --> 00:53:12,360
every lock message in a database and

00:53:09,660 --> 00:53:14,010
then they sort by time stem and all

00:53:12,360 --> 00:53:15,690
those messages coming from currently at

00:53:14,010 --> 00:53:18,870
the same time stem because when they

00:53:15,690 --> 00:53:20,340
were read and then they log it showed

00:53:18,870 --> 00:53:24,060
randomly to the user

00:53:20,340 --> 00:53:26,400
that's a bad thing to do and the idea

00:53:24,060 --> 00:53:30,270
was if the colonel would log it we would

00:53:26,400 --> 00:53:33,030
see when when the the domestic messages

00:53:30,270 --> 00:53:34,350
appear we can see where were the delays

00:53:33,030 --> 00:53:37,620
how long did it take

00:53:34,350 --> 00:53:39,660
that's one thing and then I thought

00:53:37,620 --> 00:53:42,030
about it when we would do that also for

00:53:39,660 --> 00:53:45,720
the sensors lock Hall we would get the

00:53:42,030 --> 00:53:48,300
the time when the program does the lock

00:53:45,720 --> 00:53:50,010
and that when just lucky gets scheduled

00:53:48,300 --> 00:53:53,160
and reads the log and we could get more

00:53:50,010 --> 00:53:58,880
precision so I'll think about that if I

00:53:53,160 --> 00:53:58,880
want to implement it yeah and that's it

00:54:01,010 --> 00:54:06,990
so it turns out you have already talked

00:54:04,080 --> 00:54:08,960
about the my first of my notes about

00:54:06,990 --> 00:54:13,020
beam up time and the colonel and colonel

00:54:08,960 --> 00:54:15,780
time stems but they have another one you

00:54:13,020 --> 00:54:18,600
said you are opening a socket pair and

00:54:15,780 --> 00:54:21,450
you're marking a socket as used by

00:54:18,600 --> 00:54:25,980
syslog by this special I or two right

00:54:21,450 --> 00:54:30,440
yes so there is a race condition if you

00:54:25,980 --> 00:54:33,060
do that and then some program tries to

00:54:30,440 --> 00:54:35,670
represent itself as a syslog 'man and

00:54:33,060 --> 00:54:38,910
then it waits before until this is

00:54:35,670 --> 00:54:41,000
logged it gets sick up when it closes

00:54:38,910 --> 00:54:46,680
everything and tries to reopen again

00:54:41,000 --> 00:54:48,900
then you do the Yocto on the deaf K log

00:54:46,680 --> 00:54:50,730
file descriptor yeah so you have to open

00:54:48,900 --> 00:54:53,760
the FK lock and depending on your

00:54:50,730 --> 00:54:56,460
permissions in /dev only root can do

00:54:53,760 --> 00:54:58,770
that okay yeah so you have to check for

00:54:56,460 --> 00:55:03,570
root and you have to check to be not

00:54:58,770 --> 00:55:07,170
rooted in this case right yeah because

00:55:03,570 --> 00:55:09,900
there's no device otherwise okay so you

00:55:07,170 --> 00:55:12,990
need to have access to deaf K log two to

00:55:09,900 --> 00:55:14,670
BSS lock reader for sensor Spock yeah

00:55:12,990 --> 00:55:19,290
and if you are root you're up

00:55:14,670 --> 00:55:22,950
anyways yeah right for again more

00:55:19,290 --> 00:55:24,960
questions for your new Cisco while

00:55:22,950 --> 00:55:26,640
you're using the void pointer is very

00:55:24,960 --> 00:55:30,740
very few scares why it's not a character

00:55:26,640 --> 00:55:33,710
pointer actually well that's the idea

00:55:30,740 --> 00:55:35,839
okay so I have to ask him of a question

00:55:33,710 --> 00:55:38,030
because it's if it's only because it's

00:55:35,839 --> 00:55:40,760
like right and read that stupid there's

00:55:38,030 --> 00:55:42,950
no very good skills for so it's not to

00:55:40,760 --> 00:55:44,480
be a character you this is not systemd

00:55:42,950 --> 00:55:46,099
after all yeah so there are two

00:55:44,480 --> 00:55:48,170
possibilities either Theo has a good

00:55:46,099 --> 00:55:49,790
reason for it oh it was just too stupid

00:55:48,170 --> 00:56:00,440
to copy it correctly from the main page

00:55:49,790 --> 00:56:02,660
okay I'm curious what's the motivation

00:56:00,440 --> 00:56:04,820
for using the additional circuit pair

00:56:02,660 --> 00:56:09,349
instead of reading and writing directly

00:56:04,820 --> 00:56:11,690
from the Kay look for the messages so in

00:56:09,349 --> 00:56:13,210
K log you have the real colonel messages

00:56:11,690 --> 00:56:15,830
they have a different format they are

00:56:13,210 --> 00:56:18,500
different from from user messages so you

00:56:15,830 --> 00:56:20,540
want to have a differe difference the K

00:56:18,500 --> 00:56:24,320
log buffer is more or less the thing

00:56:20,540 --> 00:56:25,970
that is in damask so if you call the log

00:56:24,320 --> 00:56:28,609
function in the kernel it gets added to

00:56:25,970 --> 00:56:30,500
the D mask and it can be read by syslog

00:56:28,609 --> 00:56:32,750
D from the FK log that's very that's

00:56:30,500 --> 00:56:37,910
very distinct from user land logging so

00:56:32,750 --> 00:56:41,740
we added the new syslog the sis call

00:56:37,910 --> 00:56:44,480
centers lock and their new mechanism was

00:56:41,740 --> 00:56:46,990
needed and field that did it with the

00:56:44,480 --> 00:56:49,520
socket pair and I think it's a good idea

00:56:46,990 --> 00:56:56,440
so but I don't know exactly why this

00:56:49,520 --> 00:56:59,000
approach was chosen any more questions

00:56:56,440 --> 00:56:59,820
and let's hang Alexander for his great

00:56:59,000 --> 00:57:07,639
presentation

00:56:59,820 --> 00:57:07,639

YouTube URL: https://www.youtube.com/watch?v=8p6lnxClMak


