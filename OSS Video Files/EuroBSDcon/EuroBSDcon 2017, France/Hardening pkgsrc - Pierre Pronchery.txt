Title: Hardening pkgsrc - Pierre Pronchery
Publication date: 2019-10-16
Playlist: EuroBSDcon 2017, France
Description: 
	Description:

pkgsrc is a package management system, providing over 17.000 packages
today. Even though it originates from the NetBSD Project, it supports
many other platforms, even as the official source for packages for some
of them.
This talk will illustrate how pkgsrc can be used to attempt to enforce
hardening features on every package at once, and whenever possible also
to detect when these features are effectively enabled or failed to
function. The methodology, current status, and ideas for future work in
this direction will be gathered in the talk.

Speaker biography:

Pierre Pronchery (khorben@) joined the NetBSD Foundation in May 2012,
where he focuses on desktop and mobile integration. An IT-Security
consultant at Defora Networks GbR in Germany, he can also be found
promoting Open Source Hardware or researching on Clean-Slate Internet
and the Internet of Things. The outcome of this work is eventually
gathered within the DeforaOS project, an experimental Operating System
project. For about three years now, he has also been leading the EdgeBSD
Project, as an alternative way to work with and contribute to the NetBSD
Project.
Captions: 
	00:00:00,030 --> 00:00:06,270
all right the next get started I would

00:00:03,419 --> 00:00:09,120
briefly introduce myself getting rid of

00:00:06,270 --> 00:00:11,099
this right away I'm an earthling what

00:00:09,120 --> 00:00:14,849
you may discover from my accent that I'm

00:00:11,099 --> 00:00:16,350
French but also I have the ambition to

00:00:14,849 --> 00:00:18,390
write an operating system in my own

00:00:16,350 --> 00:00:19,650
which is what drove me to netbsd

00:00:18,390 --> 00:00:22,560
actually because it's an excellent way

00:00:19,650 --> 00:00:24,689
to learn how to do it and I use it also

00:00:22,560 --> 00:00:27,359
as a base for my current work which I

00:00:24,689 --> 00:00:29,160
put under the umbrella of defer always

00:00:27,359 --> 00:00:33,000
like here this project that I've been

00:00:29,160 --> 00:00:35,280
running since 2004 most of my work my

00:00:33,000 --> 00:00:38,090
work happens offline so I'm working

00:00:35,280 --> 00:00:40,680
mostly on a DSG we get instead of CVS

00:00:38,090 --> 00:00:44,340
through the HPC project where I'll

00:00:40,680 --> 00:00:47,280
publish all of my public repositories

00:00:44,340 --> 00:00:49,140
and also welcome other contributors to

00:00:47,280 --> 00:00:52,590
participate we have a small community

00:00:49,140 --> 00:00:54,420
since August 2013 over there which even

00:00:52,590 --> 00:00:58,070
brought some developers to the net bsd

00:00:54,420 --> 00:01:01,050
project itself alright but now - what's

00:00:58,070 --> 00:01:02,340
interesting to us right now if you do

00:01:01,050 --> 00:01:03,449
not know about packaged sauce here this

00:01:02,340 --> 00:01:06,000
is the right place

00:01:03,449 --> 00:01:09,090
it's a project managed by the net BSD

00:01:06,000 --> 00:01:11,460
Foundation as in here initially the way

00:01:09,090 --> 00:01:14,340
to obtain third-party software for net

00:01:11,460 --> 00:01:15,810
BST since we insist on doing the right

00:01:14,340 --> 00:01:18,229
thing we managed to get it to work

00:01:15,810 --> 00:01:22,290
across systems so it's now portable and

00:01:18,229 --> 00:01:23,610
ported over 17 platforms now package

00:01:22,290 --> 00:01:28,130
shot itself is not the subject of this

00:01:23,610 --> 00:01:31,380
talk but really my motivation I - to

00:01:28,130 --> 00:01:34,020
work on this no I'm going to see cyber

00:01:31,380 --> 00:01:36,390
but there is a cyber war going on right

00:01:34,020 --> 00:01:38,100
now I'm working a security because it's

00:01:36,390 --> 00:01:40,740
a hostile world out there and I feel

00:01:38,100 --> 00:01:43,770
like I have to protect my systems I do

00:01:40,740 --> 00:01:46,110
so this as a job actually but when it

00:01:43,770 --> 00:01:48,299
comes to the context of package host and

00:01:46,110 --> 00:01:50,549
busy and distributing software we have a

00:01:48,299 --> 00:01:52,590
responsibility towards our user because

00:01:50,549 --> 00:01:54,750
they rely on us for their daily

00:01:52,590 --> 00:01:55,259
operations they need updates for

00:01:54,750 --> 00:01:57,689
instance

00:01:55,259 --> 00:02:00,540
security updates in particular and it is

00:01:57,689 --> 00:02:04,380
also true for packaged sauce we can

00:02:00,540 --> 00:02:06,360
probably even go a bit further and be

00:02:04,380 --> 00:02:09,300
pre-emptive about it and this is where I

00:02:06,360 --> 00:02:12,420
chipped in so what can be done about

00:02:09,300 --> 00:02:13,800
this in this talk I will introduce the

00:02:12,420 --> 00:02:16,740
security management that's already

00:02:13,800 --> 00:02:19,020
in package sauce we have different teams

00:02:16,740 --> 00:02:21,180
taking care of security I will also

00:02:19,020 --> 00:02:25,320
speak about technical measures that we

00:02:21,180 --> 00:02:28,620
can or are applying now for hardening

00:02:25,320 --> 00:02:30,270
the codebase of your system and future

00:02:28,620 --> 00:02:32,850
work different perspectives for the

00:02:30,270 --> 00:02:34,650
improvements what we can work on and of

00:02:32,850 --> 00:02:38,630
course at the end Q&A if we have enough

00:02:34,650 --> 00:02:41,970
time all right so now moving on to

00:02:38,630 --> 00:02:46,710
security management we have two options

00:02:41,970 --> 00:02:48,690
as sherry just mentioned we can either a

00:02:46,710 --> 00:02:51,150
panic or we can try to recover from

00:02:48,690 --> 00:02:53,130
critical situations and in the case of

00:02:51,150 --> 00:02:55,470
netbsd we have two teams which help us

00:02:53,130 --> 00:02:56,880
recover I will detail their roles we

00:02:55,470 --> 00:02:59,750
have the security team and a release

00:02:56,880 --> 00:03:04,730
engineering group hopefully we also have

00:02:59,750 --> 00:03:07,140
some tools and also there are specific

00:03:04,730 --> 00:03:09,180
branches releases that you can use as a

00:03:07,140 --> 00:03:13,820
user and that are expected to be stable

00:03:09,180 --> 00:03:16,640
and kept up to date regarding security

00:03:13,820 --> 00:03:22,680
so the security team in particular has

00:03:16,640 --> 00:03:25,170
two duties to may important duties it

00:03:22,680 --> 00:03:27,060
handles security issues regarding

00:03:25,170 --> 00:03:31,290
package shows there is an email address

00:03:27,060 --> 00:03:33,630
for that and a PGP key of course for

00:03:31,290 --> 00:03:35,550
emailing them and this team in

00:03:33,630 --> 00:03:38,640
particular maintains the vendor beta

00:03:35,550 --> 00:03:41,190
database which can actually be updated

00:03:38,640 --> 00:03:43,260
by any netbsd operational developer but

00:03:41,190 --> 00:03:47,430
has to be signed and uploaded by the

00:03:43,260 --> 00:03:50,670
security team this database is assembled

00:03:47,430 --> 00:03:52,200
from different sources we use release

00:03:50,670 --> 00:03:54,510
notes from a trim packages of course

00:03:52,200 --> 00:03:56,970
when they report security issues there

00:03:54,510 --> 00:04:00,360
are also external vendors which may

00:03:56,970 --> 00:04:03,360
report security issues to advisories we

00:04:00,360 --> 00:04:05,970
used to depend on Secunia but they cut

00:04:03,360 --> 00:04:08,550
the feed for us so unfortunately we have

00:04:05,970 --> 00:04:10,800
to use something else now of course

00:04:08,550 --> 00:04:13,170
there are also public mailing lists like

00:04:10,800 --> 00:04:15,239
OSS security or backtrack and so on full

00:04:13,170 --> 00:04:16,620
disclosure where security issues may be

00:04:15,239 --> 00:04:21,299
announced so we have to keep an eye on

00:04:16,620 --> 00:04:23,000
that and also we get irritated or

00:04:21,299 --> 00:04:25,260
advisories from other distributions

00:04:23,000 --> 00:04:27,170
governmental agencies different certs

00:04:25,260 --> 00:04:29,750
and so on

00:04:27,170 --> 00:04:33,260
and as I just mentioned there is a PGP

00:04:29,750 --> 00:04:37,280
key for you to report security issues to

00:04:33,260 --> 00:04:41,060
us safely confidentially all right now

00:04:37,280 --> 00:04:42,740
as a user how do we make sure that the

00:04:41,060 --> 00:04:45,460
system is actually up-to-date regarding

00:04:42,740 --> 00:04:47,930
security using the system this database

00:04:45,460 --> 00:04:49,880
you can have the system denied it every

00:04:47,930 --> 00:04:52,430
day if you use netbsd in particular this

00:04:49,880 --> 00:04:53,960
is going to be done in dari conf with

00:04:52,430 --> 00:04:55,790
this variable fetch package

00:04:53,960 --> 00:04:58,460
vulnerabilities for this we need the

00:04:55,790 --> 00:05:00,260
system to run 24/7 actually because the

00:04:58,460 --> 00:05:04,370
cron job will be at some point in the

00:05:00,260 --> 00:05:08,780
day it's all you have to adapt the cron

00:05:04,370 --> 00:05:11,780
job to run when the system is up you can

00:05:08,780 --> 00:05:14,300
also fetch the database manually if you

00:05:11,780 --> 00:05:15,500
prefer this is done with package admin

00:05:14,300 --> 00:05:18,560
it's pretty much what the cron job does

00:05:15,500 --> 00:05:20,780
I do not forget the minus sign there

00:05:18,560 --> 00:05:22,220
because this is what actually will tell

00:05:20,780 --> 00:05:25,520
package and mint you check the signature

00:05:22,220 --> 00:05:26,960
for the vulnerability database and then

00:05:25,520 --> 00:05:29,450
if you want to use the vanilla database

00:05:26,960 --> 00:05:31,490
to audit your system there is a command

00:05:29,450 --> 00:05:33,740
for that or social package admin package

00:05:31,490 --> 00:05:35,270
I mean audit and there are also list of

00:05:33,740 --> 00:05:37,490
different options you can do this per

00:05:35,270 --> 00:05:39,020
package you can even check packages with

00:05:37,490 --> 00:05:40,910
versions which are not actually

00:05:39,020 --> 00:05:42,890
installed yet to check if for instance

00:05:40,910 --> 00:05:47,540
an update would actually fix an issue

00:05:42,890 --> 00:05:49,070
that you have alright so in practice how

00:05:47,540 --> 00:05:50,990
does this look what happens if you

00:05:49,070 --> 00:05:53,720
install a vulnerable package from source

00:05:50,990 --> 00:05:57,650
for instance here I picked the Zen

00:05:53,720 --> 00:05:59,360
candle in version 455 and is turning it

00:05:57,650 --> 00:06:02,300
from source we is making store as you

00:05:59,360 --> 00:06:03,860
can see here we get a warning after a

00:06:02,300 --> 00:06:05,600
check for vulnerabilities

00:06:03,860 --> 00:06:08,480
more than a warning here it's an error

00:06:05,600 --> 00:06:11,000
the system is telling you please change

00:06:08,480 --> 00:06:13,280
your configuration files to allow this

00:06:11,000 --> 00:06:15,620
package specifically to be installed or

00:06:13,280 --> 00:06:19,880
generally vulnerable packages to be

00:06:15,620 --> 00:06:23,210
installed in the case of binaries I

00:06:19,880 --> 00:06:24,950
picked Wireshark in this case which on

00:06:23,210 --> 00:06:26,630
my system actually right now has an

00:06:24,950 --> 00:06:29,780
infinite loop inability for instance in

00:06:26,630 --> 00:06:31,760
version 2 to 5 and in this case you get

00:06:29,780 --> 00:06:34,520
a similar message which also comes from

00:06:31,760 --> 00:06:37,130
the vulnerability database and package

00:06:34,520 --> 00:06:39,050
ad will say it will it was not able to

00:06:37,130 --> 00:06:41,030
install the package because there is no

00:06:39,050 --> 00:06:44,080
known vulnerability

00:06:41,030 --> 00:06:46,760
this can be tweaked of course

00:06:44,080 --> 00:06:48,890
typically in package instructed conf you

00:06:46,760 --> 00:06:51,800
would have check vulnerabilities as

00:06:48,890 --> 00:06:54,170
always if you never want to install any

00:06:51,800 --> 00:06:55,940
package with known vulnerabilities you

00:06:54,170 --> 00:06:57,500
can change it however for it to be a bit

00:06:55,940 --> 00:06:59,180
more convenient as a user because there

00:06:57,500 --> 00:07:01,280
are still many vulnerabilities which are

00:06:59,180 --> 00:07:03,710
not fixed for number of packages

00:07:01,280 --> 00:07:06,170
unfortunately but at least they are

00:07:03,710 --> 00:07:08,030
known and you can agree or not to have

00:07:06,170 --> 00:07:10,820
them on your system so in a case of

00:07:08,030 --> 00:07:14,419
Wireshark here I could simply say yes or

00:07:10,820 --> 00:07:17,860
no after a list of non variabilities to

00:07:14,419 --> 00:07:20,870
agree or not to install this package so

00:07:17,860 --> 00:07:23,480
this is how this is configured and I

00:07:20,870 --> 00:07:25,310
like to take this opportunity during

00:07:23,480 --> 00:07:28,250
this talk to thank the security team for

00:07:25,310 --> 00:07:30,250
maintaining this some of these members

00:07:28,250 --> 00:07:33,919
are here actually

00:07:30,250 --> 00:07:38,050
thank you seven and everybody else but

00:07:33,919 --> 00:07:42,919
ha no it was in the other team I will

00:07:38,050 --> 00:07:46,400
yeah yeah all right

00:07:42,919 --> 00:07:48,979
I've seen your go so around anyway

00:07:46,400 --> 00:07:51,710
the other group as we get to this the

00:07:48,979 --> 00:07:53,870
origin reason Janine group which I will

00:07:51,710 --> 00:07:54,410
call a railing here it's easier to

00:07:53,870 --> 00:07:57,350
pronounce

00:07:54,410 --> 00:07:59,419
it's also relevant for security even if

00:07:57,350 --> 00:08:02,479
its job is actually to release - to

00:07:59,419 --> 00:08:04,250
manage releases sorry so it manages the

00:08:02,479 --> 00:08:06,800
stable branches but it also processes

00:08:04,250 --> 00:08:09,020
the pull up requests when we have

00:08:06,800 --> 00:08:11,570
changes we want to apply to stable

00:08:09,020 --> 00:08:14,840
releases we have a process called flops

00:08:11,570 --> 00:08:17,030
and this is also even - security since

00:08:14,840 --> 00:08:20,419
some of these fixes actually implies

00:08:17,030 --> 00:08:22,669
security fixes there are freezing

00:08:20,419 --> 00:08:24,740
periods in particular for package shows

00:08:22,669 --> 00:08:28,520
every three months the tree enters the

00:08:24,740 --> 00:08:31,910
the freeze in which case we proceed not

00:08:28,520 --> 00:08:33,740
yet in pull ups but we mostly focus on

00:08:31,910 --> 00:08:38,360
security fixes and bill fixes for

00:08:33,740 --> 00:08:42,800
instance all right so this is how the

00:08:38,360 --> 00:08:45,410
pull up requests list look like as of

00:08:42,800 --> 00:08:47,839
yesterday we have a couple issues open

00:08:45,410 --> 00:08:51,140
for a few weeks but the rest is just a

00:08:47,839 --> 00:08:52,560
few days behind I see one year with run

00:08:51,140 --> 00:08:57,010
cube

00:08:52,560 --> 00:09:00,820
regular vendor unfortunately but it is

00:08:57,010 --> 00:09:05,770
not the topic today but coming to stable

00:09:00,820 --> 00:09:09,850
releases we have right now a freeze on

00:09:05,770 --> 00:09:12,040
the 2017 q3 branch meaning it's about to

00:09:09,850 --> 00:09:15,640
be released we focus on security and

00:09:12,040 --> 00:09:17,110
build issues okay there is no branch yet

00:09:15,640 --> 00:09:18,160
but that's that's - head basically yeah

00:09:17,110 --> 00:09:21,310
that's right

00:09:18,160 --> 00:09:23,560
thanks penny the latest Abel is still q2

00:09:21,310 --> 00:09:27,760
which accepts pull up requests and then

00:09:23,560 --> 00:09:30,130
q1 is no longer maintained we do not

00:09:27,760 --> 00:09:32,800
offer long-term support in package shows

00:09:30,130 --> 00:09:34,500
as a project itself however giant

00:09:32,800 --> 00:09:37,750
company using package shows regularly

00:09:34,500 --> 00:09:41,140
does it for its customers they focus on

00:09:37,750 --> 00:09:44,950
smart wise which is where the the

00:09:41,140 --> 00:09:47,920
service that they offer i I think they

00:09:44,950 --> 00:09:50,830
also have packages for mac OS I do not

00:09:47,920 --> 00:09:53,830
know if they have it for maintained for

00:09:50,830 --> 00:09:57,520
ATS also if they build it for it yes but

00:09:53,830 --> 00:10:00,460
if you interested in older stable

00:09:57,520 --> 00:10:01,570
releases for stability on your systems

00:10:00,460 --> 00:10:05,160
for instance if you do not want to

00:10:01,570 --> 00:10:07,900
upgrade your HP mouse you can use giants

00:10:05,160 --> 00:10:10,150
source trees instead for package shows

00:10:07,900 --> 00:10:11,860
and it will be usually maintained for

00:10:10,150 --> 00:10:17,170
security then you can build your

00:10:11,860 --> 00:10:21,010
binaries from there the welding team is

00:10:17,170 --> 00:10:25,180
composed of a few members been in Petra

00:10:21,010 --> 00:10:28,270
here so thank you also for for your work

00:10:25,180 --> 00:10:33,190
and with this done I would like to move

00:10:28,270 --> 00:10:34,990
on to the technical aspect of security

00:10:33,190 --> 00:10:37,840
in package shows and how we are trying

00:10:34,990 --> 00:10:39,390
to improve the security level of the

00:10:37,840 --> 00:10:42,430
system as a whole

00:10:39,390 --> 00:10:44,410
17,000 packages at a time so which tools

00:10:42,430 --> 00:10:46,390
do we have we have a number of tools

00:10:44,410 --> 00:10:50,290
here already that I'm listing package

00:10:46,390 --> 00:10:53,470
signatures SSP fortify stock check PI

00:10:50,290 --> 00:10:55,720
and well row I will go through them one

00:10:53,470 --> 00:10:57,190
by one do not worry if you are not

00:10:55,720 --> 00:11:00,880
familiar with any one of them I will try

00:10:57,190 --> 00:11:04,210
to clarify this so starting with package

00:11:00,880 --> 00:11:05,240
signatures I believe we were and package

00:11:04,210 --> 00:11:06,580
shows

00:11:05,240 --> 00:11:10,490
one of the first if not the first

00:11:06,580 --> 00:11:14,930
project to introduce this support as a

00:11:10,490 --> 00:11:16,670
distribution initially in 2001 which was

00:11:14,930 --> 00:11:18,850
already supporting two different

00:11:16,670 --> 00:11:21,650
mechanisms to implement that either

00:11:18,850 --> 00:11:25,370
x.509 certificates as managed by open

00:11:21,650 --> 00:11:27,550
ssl for instance always new PG this

00:11:25,370 --> 00:11:29,990
ensures authenticity and integrity

00:11:27,550 --> 00:11:32,960
meaning that package signatures do not

00:11:29,990 --> 00:11:36,170
actually help with finding or fixing or

00:11:32,960 --> 00:11:38,870
mitigating flaws in packages it's more

00:11:36,170 --> 00:11:41,330
about when you download the package you

00:11:38,870 --> 00:11:43,070
will know it has not been altered on its

00:11:41,330 --> 00:11:45,890
way so it's safe to actually download it

00:11:43,070 --> 00:11:48,620
over HTTP or FTP as long as the checksum

00:11:45,890 --> 00:11:50,090
algorithms are not broken and then you

00:11:48,620 --> 00:11:52,550
can be sure that it was actually built

00:11:50,090 --> 00:11:55,790
by the person who owns the key if the

00:11:52,550 --> 00:12:00,680
key was not reached giant has enabled

00:11:55,790 --> 00:12:03,320
signatures in production in 2014 and in

00:12:00,680 --> 00:12:05,540
package shows upstream we still have

00:12:03,320 --> 00:12:09,380
kind of a difficult situation right now

00:12:05,540 --> 00:12:11,090
we cannot easily do this I will mention

00:12:09,380 --> 00:12:14,090
why

00:12:11,090 --> 00:12:16,490
on one hand we could rely on the x.509

00:12:14,090 --> 00:12:20,030
but it is quite complex in both sitting

00:12:16,490 --> 00:12:21,530
a PKI and then every group eg is a lot

00:12:20,030 --> 00:12:24,800
easier but still we need to determine

00:12:21,530 --> 00:12:28,430
how to ship the key which policy should

00:12:24,800 --> 00:12:30,710
apply to the key but there are also a

00:12:28,430 --> 00:12:33,980
number of other technical issues with

00:12:30,710 --> 00:12:36,230
group eg on net bsd in particular we

00:12:33,980 --> 00:12:39,050
have a chicken-and-egg problem because

00:12:36,230 --> 00:12:40,550
glue PG is not a variable in base so how

00:12:39,050 --> 00:12:42,650
do you install a package which is

00:12:40,550 --> 00:12:45,170
supposed to check its own signature that

00:12:42,650 --> 00:12:48,680
doesn't work so instead I've been trying

00:12:45,170 --> 00:12:51,320
to add support for net PGP which is

00:12:48,680 --> 00:12:55,610
another implementation of grip eg in

00:12:51,320 --> 00:12:57,320
Bayes available in bales in a BST would

00:12:55,610 --> 00:12:59,540
I wrote a command line wrapper which

00:12:57,320 --> 00:13:01,520
takes the new PG syntax and adapts it

00:12:59,540 --> 00:13:04,160
for net PGP instead so I called it g PG

00:13:01,520 --> 00:13:06,980
to net PGP this still requires a few

00:13:04,160 --> 00:13:10,130
patches I imported a lot of them

00:13:06,980 --> 00:13:12,620
recently in net PGP but there are still

00:13:10,130 --> 00:13:13,760
some issues this is not enough still for

00:13:12,620 --> 00:13:15,200
instance there is a security issue

00:13:13,760 --> 00:13:19,010
remaining with detached

00:13:15,200 --> 00:13:22,370
signatures with no PGP that we have to

00:13:19,010 --> 00:13:24,780
so this is still a work in progress

00:13:22,370 --> 00:13:27,480
however if you want to test it out for

00:13:24,780 --> 00:13:30,510
yourself you can first generate a key

00:13:27,480 --> 00:13:31,380
with loop in G always met PGP this is

00:13:30,510 --> 00:13:34,920
how you would do it

00:13:31,380 --> 00:13:39,090
then in magcon you should enable some

00:13:34,920 --> 00:13:41,270
packages and mention GPG and then for

00:13:39,090 --> 00:13:44,160
the individual tools to know how to call

00:13:41,270 --> 00:13:46,890
gbg you can set it and force it to a

00:13:44,160 --> 00:13:49,020
specific implementation and if you want

00:13:46,890 --> 00:13:51,750
to try things with PGP would use my

00:13:49,020 --> 00:13:54,360
wrapper for instance changing it here

00:13:51,750 --> 00:13:56,910
you can specify of course a particular

00:13:54,360 --> 00:13:58,980
key to use if you have multiple ones on

00:13:56,910 --> 00:14:00,750
your system and you can also specify

00:13:58,980 --> 00:14:03,720
keyrings if you want to separate things

00:14:00,750 --> 00:14:07,440
even even further then you just use

00:14:03,720 --> 00:14:12,030
package source from source normally to

00:14:07,440 --> 00:14:14,760
generate signed packages will show this

00:14:12,030 --> 00:14:17,880
in an instant but when it comes to

00:14:14,760 --> 00:14:19,800
installing signed packages you have of

00:14:17,880 --> 00:14:22,530
course to import the public key of the

00:14:19,800 --> 00:14:24,930
user who had which was building the

00:14:22,530 --> 00:14:26,760
packages you can use GPG for that if you

00:14:24,930 --> 00:14:29,970
already have it or need PGP you should

00:14:26,760 --> 00:14:32,490
also work this is simply done with jpg -

00:14:29,970 --> 00:14:35,640
- import then you just pipe the kyani's

00:14:32,490 --> 00:14:40,950
and an input for instance you can

00:14:35,640 --> 00:14:42,810
configure as I mentioned a lot like with

00:14:40,950 --> 00:14:44,940
vulnerabilities you can enforce

00:14:42,810 --> 00:14:47,100
signatures to be involved on packages

00:14:44,940 --> 00:14:50,670
using in packaging so that conf the

00:14:47,100 --> 00:14:52,290
verified installation parameter and you

00:14:50,670 --> 00:14:55,830
can use package shows normally this time

00:14:52,290 --> 00:14:57,380
from binaries and it will tell you when

00:14:55,830 --> 00:15:01,080
you install packages that the signature

00:14:57,380 --> 00:15:03,480
is there and if it's valid or not will

00:15:01,080 --> 00:15:06,260
even like at the moment give you the

00:15:03,480 --> 00:15:10,200
fingerprint we could probably make this

00:15:06,260 --> 00:15:11,760
silent but run on this is how you can

00:15:10,200 --> 00:15:16,440
confirm that the package was actually

00:15:11,760 --> 00:15:19,590
signed and validated all right now

00:15:16,440 --> 00:15:22,470
moving on to different mechanism SSP for

00:15:19,590 --> 00:15:25,110
Stax machine protection this technology

00:15:22,470 --> 00:15:26,570
was initially introduced by IBM then

00:15:25,110 --> 00:15:28,920
picked up by open BSD

00:15:26,570 --> 00:15:31,230
you can actually find bugs in programs

00:15:28,920 --> 00:15:32,790
since instead of

00:15:31,230 --> 00:15:34,890
currently corrupting a memory which is

00:15:32,790 --> 00:15:38,520
what attackers use to subvert your

00:15:34,890 --> 00:15:40,770
programs the program itself will detect

00:15:38,520 --> 00:15:43,020
that it was altered when returning from

00:15:40,770 --> 00:15:47,040
functions checking a canary value in the

00:15:43,020 --> 00:15:49,170
stack and then crash this implies a

00:15:47,040 --> 00:15:51,090
different memory layout if you want it

00:15:49,170 --> 00:15:53,990
to be very efficient because you want

00:15:51,090 --> 00:15:56,550
your buffers you can tell overflow to

00:15:53,990 --> 00:15:57,090
overwrite the canary value as soon as

00:15:56,550 --> 00:15:58,890
possible

00:15:57,090 --> 00:16:01,320
as close as possible so that even enough

00:15:58,890 --> 00:16:04,260
buy one will actually trigger a crash

00:16:01,320 --> 00:16:06,570
instead of corrupting memory there is a

00:16:04,260 --> 00:16:09,780
slight performance penalty associated

00:16:06,570 --> 00:16:11,340
with this measure I would say between

00:16:09,780 --> 00:16:13,850
one and five percent depending on the

00:16:11,340 --> 00:16:15,900
settings and program that you use and

00:16:13,850 --> 00:16:18,480
unfortunately this is not perfect this

00:16:15,900 --> 00:16:22,680
is just a mitigation it will not fix and

00:16:18,480 --> 00:16:25,200
magically block every bug and every

00:16:22,680 --> 00:16:27,390
exploit it can be defeated for instance

00:16:25,200 --> 00:16:29,520
through memory leaks if the attacker

00:16:27,390 --> 00:16:31,920
discovers the canary value because there

00:16:29,520 --> 00:16:33,840
is a arbitrary reach somewhere for

00:16:31,920 --> 00:16:39,000
instance and you stuck address is known

00:16:33,840 --> 00:16:40,950
then this can be defeated we support it

00:16:39,000 --> 00:16:43,350
on netbsd on almost every architecture

00:16:40,950 --> 00:16:46,020
in package shows I have added the

00:16:43,350 --> 00:16:49,140
support also for Linux x86 and FreeBSD

00:16:46,020 --> 00:16:52,770
x86 simply because I didn't I couldn't

00:16:49,140 --> 00:16:54,690
test it somewhere else but it should be

00:16:52,770 --> 00:16:57,060
really easy to to add support for

00:16:54,690 --> 00:16:58,920
further systems and architectures just a

00:16:57,060 --> 00:17:01,620
matter of testing it and making sure

00:16:58,920 --> 00:17:04,620
sorry that GCC supports it effectively

00:17:01,620 --> 00:17:06,720
over there in MCDOT confid can be

00:17:04,620 --> 00:17:08,550
enabled systematically for the whole

00:17:06,720 --> 00:17:10,140
system of course this applies only when

00:17:08,550 --> 00:17:13,500
building packages not when installing

00:17:10,140 --> 00:17:15,930
binaries in this case is his package

00:17:13,500 --> 00:17:19,590
shows us SSP which you can set to yes or

00:17:15,930 --> 00:17:22,800
to all or too strong the difference this

00:17:19,590 --> 00:17:25,320
makes is that if you set yes it will set

00:17:22,800 --> 00:17:28,470
a computation flag in the case of GCC

00:17:25,320 --> 00:17:31,290
and clang - F stack protector but it

00:17:28,470 --> 00:17:33,900
will only protect some functions the one

00:17:31,290 --> 00:17:36,180
functions where the compiler sees there

00:17:33,900 --> 00:17:38,960
is a buffer in this function and it's

00:17:36,180 --> 00:17:41,430
actually relevant to put a canary value

00:17:38,960 --> 00:17:44,490
in some other cases it's actually

00:17:41,430 --> 00:17:47,160
useless or apparently useless to put

00:17:44,490 --> 00:17:49,559
values you can however enforce it using

00:17:47,160 --> 00:17:50,730
all instead of yes so that every

00:17:49,559 --> 00:17:53,940
function is actually covered with a

00:17:50,730 --> 00:17:57,420
canary and protected by a CSP or you can

00:17:53,940 --> 00:18:01,290
use a patch from Google which uses which

00:17:57,420 --> 00:18:03,750
is then used by strong the patch applies

00:18:01,290 --> 00:18:07,620
to GCC so you have to rebuild GCC to to

00:18:03,750 --> 00:18:09,360
improve that so logically this requires

00:18:07,620 --> 00:18:10,890
the package that you're trying to build

00:18:09,360 --> 00:18:12,330
to support C flags

00:18:10,890 --> 00:18:15,380
since this is added to do see Flags

00:18:12,330 --> 00:18:17,700
automatically by package shows

00:18:15,380 --> 00:18:19,200
thankfully more and more packages now

00:18:17,700 --> 00:18:23,610
support supplies we've been focusing on

00:18:19,200 --> 00:18:26,850
that in the past few months and as a

00:18:23,610 --> 00:18:29,130
corollary this only protects C C++

00:18:26,850 --> 00:18:32,040
programs or interpreters written in C or

00:18:29,130 --> 00:18:34,020
C++ and in particular just-in-time

00:18:32,040 --> 00:18:36,679
compilation is not protected since this

00:18:34,020 --> 00:18:39,750
is then code that's generated and run

00:18:36,679 --> 00:18:42,420
executed at one time it has nothing to

00:18:39,750 --> 00:18:44,220
do with the compiler and if it's if it

00:18:42,420 --> 00:18:46,860
wants to protect its own stack it has to

00:18:44,220 --> 00:18:50,429
implement it itself so this is not

00:18:46,860 --> 00:18:52,290
perfectly covering every situation you

00:18:50,429 --> 00:18:54,059
can make it stronger as mentioned with a

00:18:52,290 --> 00:18:57,540
stack predictor or or with the patch

00:18:54,059 --> 00:18:59,309
from Google who is strong we can have to

00:18:57,540 --> 00:19:00,780
put form of comparison platforms so feel

00:18:59,309 --> 00:19:06,270
free to check on your own platform

00:19:00,780 --> 00:19:09,740
package shows and if you can add a bit

00:19:06,270 --> 00:19:12,750
of glue to enable your system to use SSP

00:19:09,740 --> 00:19:14,700
if you want to validate and check be

00:19:12,750 --> 00:19:18,270
sure that SSP was actually applied when

00:19:14,700 --> 00:19:20,730
building your packages you can check the

00:19:18,270 --> 00:19:23,610
binaries built for instance with an EM

00:19:20,730 --> 00:19:25,530
listing the symbols present inside the

00:19:23,610 --> 00:19:27,900
binary and if you see you know score

00:19:25,530 --> 00:19:30,240
underscore stack check fail or stock

00:19:27,900 --> 00:19:31,740
check guard you can be fairly sure at

00:19:30,240 --> 00:19:34,770
least one part of the binary

00:19:31,740 --> 00:19:39,000
was built using SSP it will not

00:19:34,770 --> 00:19:40,590
definitively say definitely say that all

00:19:39,000 --> 00:19:44,160
of the binary was built this way but

00:19:40,590 --> 00:19:46,260
usually it should apply everywhere this

00:19:44,160 --> 00:19:49,230
has been enabled by default in open BSD

00:19:46,260 --> 00:19:52,130
since 2003 in their own ports also in

00:19:49,230 --> 00:19:54,990
fedora on Ubuntu since 2006 dragonfly

00:19:52,130 --> 00:19:57,560
2013 and now also packaged sauce as of

00:19:54,990 --> 00:20:00,290
the Commun release that's run on freeze

00:19:57,560 --> 00:20:02,360
we have enabled SSP by default we're

00:20:00,290 --> 00:20:06,050
supported so I'm quite excited about

00:20:02,360 --> 00:20:08,090
this it is great and as a companion

00:20:06,050 --> 00:20:12,320
technology to SSP we also support

00:20:08,090 --> 00:20:16,040
fortify it's a bit different in the

00:20:12,320 --> 00:20:19,190
sense that it will this time change

00:20:16,040 --> 00:20:21,860
course to specific functions so if you

00:20:19,190 --> 00:20:23,720
if the code uses unsafe notoriously

00:20:21,860 --> 00:20:27,380
unsafe functions from the Lib C for

00:20:23,720 --> 00:20:30,470
instance as printf or string cats or may

00:20:27,380 --> 00:20:32,120
move the compiler will automatically

00:20:30,470 --> 00:20:34,760
replace this cause when it has knowledge

00:20:32,120 --> 00:20:38,120
of the size of the buffer who is safer

00:20:34,760 --> 00:20:40,490
versions so in this case is completely

00:20:38,120 --> 00:20:43,210
mitigates some buffer overflows the ones

00:20:40,490 --> 00:20:46,040
which will actually use these functions

00:20:43,210 --> 00:20:47,840
but it involves support from the Lib C

00:20:46,040 --> 00:20:50,120
through the system headers in particular

00:20:47,840 --> 00:20:53,000
which have to be reflecting the compiler

00:20:50,120 --> 00:20:56,780
reviews in this case the performance

00:20:53,000 --> 00:20:57,860
impact is relative named legible the one

00:20:56,780 --> 00:20:59,540
difference it will make is that you will

00:20:57,860 --> 00:21:02,380
actually check the size of the buffer so

00:20:59,540 --> 00:21:05,030
that's typically just one check and

00:21:02,380 --> 00:21:06,710
again the program will crash instead of

00:21:05,030 --> 00:21:09,200
silently corrupting your memory and

00:21:06,710 --> 00:21:11,500
allowing hackers maybe to execute

00:21:09,200 --> 00:21:15,110
unfriendly code to say the least

00:21:11,500 --> 00:21:17,270
so in package shows we supported using

00:21:15,110 --> 00:21:20,300
packaged shows use 45 which can be set

00:21:17,270 --> 00:21:23,900
to yes or to week we support it right

00:21:20,300 --> 00:21:27,140
now on Linux and BSD with GCC in

00:21:23,900 --> 00:21:30,350
practice this sets a pre-processing flag

00:21:27,140 --> 00:21:33,080
or throws foolish' flags which is 45

00:21:30,350 --> 00:21:35,300
sauce equals to in the case of yes this

00:21:33,080 --> 00:21:37,190
requires again the package to support C

00:21:35,300 --> 00:21:41,420
flags so every same limitation as he as

00:21:37,190 --> 00:21:44,720
with SSP however as of today this is the

00:21:41,420 --> 00:21:47,180
case for most packages maybe not

00:21:44,720 --> 00:21:49,820
absolutely all of them but again it

00:21:47,180 --> 00:21:52,340
protects only C C++ programs and

00:21:49,820 --> 00:21:56,360
interpreters trisystem compilation will

00:21:52,340 --> 00:21:58,250
not be protected and additionally there

00:21:56,360 --> 00:22:03,710
is something else that's quite tricky

00:21:58,250 --> 00:22:06,200
with fortify it requires the compiler

00:22:03,710 --> 00:22:07,860
the flags to be set to an optimization

00:22:06,200 --> 00:22:10,559
level of one or more

00:22:07,860 --> 00:22:12,299
this is because comparing the binary in

00:22:10,559 --> 00:22:15,660
this case will be slightly different

00:22:12,299 --> 00:22:17,220
from the source code so the user has to

00:22:15,660 --> 00:22:20,850
agree that this will happen that

00:22:17,220 --> 00:22:22,440
something will be optimized so it's

00:22:20,850 --> 00:22:24,270
entirely possible that even though

00:22:22,440 --> 00:22:28,350
you're complaining with 45 source equals

00:22:24,270 --> 00:22:29,730
to 45 will not actually be applied we

00:22:28,350 --> 00:22:31,559
can of course add support for more

00:22:29,730 --> 00:22:34,350
comparison platforms and to check that

00:22:31,559 --> 00:22:37,740
it works on your platform again there is

00:22:34,350 --> 00:22:39,809
a way using symbols very helpful with an

00:22:37,740 --> 00:22:42,210
M again from materials you can check if

00:22:39,809 --> 00:22:45,840
the symbol for instance the printf check

00:22:42,210 --> 00:22:48,870
is used by the program in this case

00:22:45,840 --> 00:22:51,380
specific to GCC or netbsd but you can

00:22:48,870 --> 00:22:54,840
look for similar functions and it will

00:22:51,380 --> 00:22:57,809
tell that 45 was used at least in in one

00:22:54,840 --> 00:23:00,780
place and it has been enabled a default

00:22:57,809 --> 00:23:02,929
in Ubuntu Linux for a good while and

00:23:00,780 --> 00:23:06,360
enjoy it maybe even from the beginning

00:23:02,929 --> 00:23:09,720
and in package shows since the coming

00:23:06,360 --> 00:23:14,809
release 2017 this is also now enable by

00:23:09,720 --> 00:23:17,940
default very similarly to SSP this time

00:23:14,809 --> 00:23:20,460
stuck check which generates code to

00:23:17,940 --> 00:23:22,580
verify the boundary of the stack it's a

00:23:20,460 --> 00:23:25,290
lot less relevant in production or

00:23:22,580 --> 00:23:26,760
globally for every package since at

00:23:25,290 --> 00:23:29,010
least according to the manual page for

00:23:26,760 --> 00:23:31,620
GCC this is only really useful for

00:23:29,010 --> 00:23:35,220
multi-threaded code it involves support

00:23:31,620 --> 00:23:36,600
from the compiler this is not in package

00:23:35,220 --> 00:23:39,720
sauce yet but I have an external patch

00:23:36,600 --> 00:23:42,110
in HP HD which implements that we could

00:23:39,720 --> 00:23:45,510
consider combining it with the building

00:23:42,110 --> 00:23:48,150
building definition for piece read since

00:23:45,510 --> 00:23:50,520
it's a good hint that there is

00:23:48,150 --> 00:23:54,960
multi-threaded code inside the current

00:23:50,520 --> 00:23:58,100
package and so we should not really

00:23:54,960 --> 00:24:00,690
apply it to every binary in any system

00:23:58,100 --> 00:24:03,030
it sets this computation flag in the

00:24:00,690 --> 00:24:05,580
case of GCC and so again we need to

00:24:03,030 --> 00:24:10,590
support C flags to actually implement

00:24:05,580 --> 00:24:12,480
that stack check doesn't work on every

00:24:10,590 --> 00:24:16,740
compiler I do not know at this point if

00:24:12,480 --> 00:24:18,120
Clank supports it it apparently applies

00:24:16,740 --> 00:24:19,980
for multi-threaded applications only I

00:24:18,120 --> 00:24:21,690
mentioned that I do not know how to

00:24:19,980 --> 00:24:24,360
validate if this mitigation is

00:24:21,690 --> 00:24:27,350
effectively News and we should also

00:24:24,360 --> 00:24:32,610
investigate if it is relevant by default

00:24:27,350 --> 00:24:35,610
if at all all right now moving on to PI

00:24:32,610 --> 00:24:38,730
I know we just had dessert but this is

00:24:35,610 --> 00:24:40,889
not related this means actually position

00:24:38,730 --> 00:24:44,700
independent executable and it is a

00:24:40,889 --> 00:24:46,679
companion to the packs SLR mechanism

00:24:44,700 --> 00:24:48,809
from the candle in more and more kennels

00:24:46,679 --> 00:24:50,700
nowadays there is support for

00:24:48,809 --> 00:24:55,019
randomizing the address space for

00:24:50,700 --> 00:24:58,440
processes in New Zealand and a necessary

00:24:55,019 --> 00:25:00,330
mechanism regarding binaries to take the

00:24:58,440 --> 00:25:03,029
most advantage of that is to build

00:25:00,330 --> 00:25:05,429
position independent executables so that

00:25:03,029 --> 00:25:07,799
they can actually be placed in arbitrary

00:25:05,429 --> 00:25:09,570
positions in memory and therefore make

00:25:07,799 --> 00:25:10,980
is partition more difficult because then

00:25:09,570 --> 00:25:14,610
the hacker needs to know at which offset

00:25:10,980 --> 00:25:18,330
will be which code there are mechanisms

00:25:14,610 --> 00:25:23,070
for hackers to to walk around that but

00:25:18,330 --> 00:25:24,960
there are more complex to use usually so

00:25:23,070 --> 00:25:26,309
in this case it's a bit different from

00:25:24,960 --> 00:25:27,990
what I just mentioned because it

00:25:26,309 --> 00:25:31,019
involves not only the computation phase

00:25:27,990 --> 00:25:33,269
but also the linking phase so let's have

00:25:31,019 --> 00:25:36,539
a look at how this is enabled in package

00:25:33,269 --> 00:25:39,659
shows using package halls magpie sets

00:25:36,539 --> 00:25:42,450
set to yes in this case is just yes or

00:25:39,659 --> 00:25:46,230
no and it will first set a computation

00:25:42,450 --> 00:25:49,409
flag minus F peak and it also needs an

00:25:46,230 --> 00:25:53,129
LD flag for linking time however there

00:25:49,409 --> 00:25:55,259
is a caveat in this case since this

00:25:53,129 --> 00:25:57,809
computation I mean this linking phase

00:25:55,259 --> 00:26:00,059
must be completed with minus PI but only

00:25:57,809 --> 00:26:03,659
for executables and not for libraries

00:26:00,059 --> 00:26:05,129
otherwise it will just not build this is

00:26:03,659 --> 00:26:07,679
implementing right now in the GCC

00:26:05,129 --> 00:26:11,039
wrapper in package shows so we can

00:26:07,679 --> 00:26:12,480
easily walk around limitations in LD

00:26:11,039 --> 00:26:14,879
flag because we can tell in the wrapper

00:26:12,480 --> 00:26:19,110
if we're building a library shadow

00:26:14,879 --> 00:26:20,610
object or an executable and also as of

00:26:19,110 --> 00:26:23,309
the current release of fact package

00:26:20,610 --> 00:26:25,559
shows this is supported in syllabus the

00:26:23,309 --> 00:26:27,389
new way introduced by yoga recently to

00:26:25,559 --> 00:26:28,019
gain performance among other things when

00:26:27,389 --> 00:26:31,679
building

00:26:28,019 --> 00:26:32,970
package shows there are advantages

00:26:31,679 --> 00:26:35,389
actually to PI

00:26:32,970 --> 00:26:37,929
also since package is not compiled with

00:26:35,389 --> 00:26:41,809
propriate see flags will fail to build

00:26:37,929 --> 00:26:45,499
since the rapper will always enforce

00:26:41,809 --> 00:26:48,049
mine aspire to be used and pi will not

00:26:45,499 --> 00:26:50,169
build if the package was not I mean if

00:26:48,049 --> 00:26:52,489
the objects were not built with - F pick

00:26:50,169 --> 00:26:54,700
the package will not build if the

00:26:52,489 --> 00:26:57,589
mechanism is actually not enforced

00:26:54,700 --> 00:26:59,749
implemented so these reviews which

00:26:57,589 --> 00:27:01,700
packages are not implementing see flies

00:26:59,749 --> 00:27:04,309
well D Flags right away which is great

00:27:01,700 --> 00:27:06,499
so if you want to test across the entire

00:27:04,309 --> 00:27:09,440
a tree you can simply enable magpie and

00:27:06,499 --> 00:27:12,019
see what breaks this can be combined

00:27:09,440 --> 00:27:14,559
with packs control for the few binaries

00:27:12,019 --> 00:27:17,779
which actually crash right now

00:27:14,559 --> 00:27:20,899
legitimately when using a cell our

00:27:17,779 --> 00:27:22,789
unprotect we're trying to fix that but

00:27:20,899 --> 00:27:25,369
in the meantime you can use in a package

00:27:22,789 --> 00:27:28,489
definitions not packs SL are safe and it

00:27:25,369 --> 00:27:30,859
packs and protect safe these variables

00:27:28,489 --> 00:27:32,779
expect fine names the path to the

00:27:30,859 --> 00:27:35,690
executable files and if you're

00:27:32,779 --> 00:27:37,999
interested in fixing some packages in

00:27:35,690 --> 00:27:40,309
this regard we can check this file from

00:27:37,999 --> 00:27:43,879
the package source framework for more

00:27:40,309 --> 00:27:47,919
details on how to use that to validate

00:27:43,879 --> 00:27:50,149
if pi was actually news you can do it at

00:27:47,919 --> 00:27:52,879
after building the package anyway using

00:27:50,149 --> 00:27:54,769
file which will tell you even for

00:27:52,879 --> 00:27:57,950
executables that you actually build a

00:27:54,769 --> 00:27:59,719
shared object it's a bit weird but it

00:27:57,950 --> 00:28:02,239
works anyway as an executable and it

00:27:59,719 --> 00:28:06,320
will tell you okay this is very likely

00:28:02,239 --> 00:28:08,749
to have been built with PI enabled okay

00:28:06,320 --> 00:28:11,329
now one of the last mechanisms that are

00:28:08,749 --> 00:28:14,119
readily available in in package shows in

00:28:11,329 --> 00:28:16,099
my list at least railro which will

00:28:14,119 --> 00:28:19,999
protect our physical table programs it's

00:28:16,099 --> 00:28:23,989
specific to this to this specification

00:28:19,999 --> 00:28:27,589
right now and it will prevent hackers to

00:28:23,989 --> 00:28:31,099
tamper with relocations at runtime so if

00:28:27,589 --> 00:28:32,869
hackers can arbitrary write different

00:28:31,099 --> 00:28:35,239
values in the lookup table for

00:28:32,869 --> 00:28:37,940
procedures in at one time they can

00:28:35,239 --> 00:28:41,539
actually use jump tables to exact good

00:28:37,940 --> 00:28:44,239
code outside of the normal perimeter but

00:28:41,539 --> 00:28:46,700
this can be prevented since a program

00:28:44,239 --> 00:28:47,750
can be started now with by non-railroad

00:28:46,700 --> 00:28:49,400
so

00:28:47,750 --> 00:28:51,440
that before running any code it will

00:28:49,400 --> 00:28:53,150
relocate everything as it was required

00:28:51,440 --> 00:28:55,640
look up looking up every symbol that can

00:28:53,150 --> 00:28:58,010
potentially be used and then making this

00:28:55,640 --> 00:29:00,140
page with these join tables read only so

00:28:58,010 --> 00:29:02,210
that they cannot be altered by attackers

00:29:00,140 --> 00:29:04,400
anymore so there is a performance

00:29:02,210 --> 00:29:06,830
penalty when studying big programs but

00:29:04,400 --> 00:29:08,840
only when the program is starting after

00:29:06,830 --> 00:29:11,750
that it can actually be faster since

00:29:08,840 --> 00:29:14,570
every symbol is already looked up this

00:29:11,750 --> 00:29:18,140
involves the linking files only in the

00:29:14,570 --> 00:29:20,960
case of GCC this will be done using the

00:29:18,140 --> 00:29:24,290
rail row and now flags

00:29:20,960 --> 00:29:27,500
Algie flags so therefore for body to the

00:29:24,290 --> 00:29:30,650
linker in package shows this would be

00:29:27,500 --> 00:29:32,720
enabled using value o equals yes okay so

00:29:30,650 --> 00:29:35,570
she was railro it can also be set to

00:29:32,720 --> 00:29:38,570
partial in which case only railroad will

00:29:35,570 --> 00:29:43,340
be set and not now which means basically

00:29:38,570 --> 00:29:45,170
that the symbols are not all relocated

00:29:43,340 --> 00:29:48,320
when starting the program but right away

00:29:45,170 --> 00:29:50,000
if I'm correct this requires the package

00:29:48,320 --> 00:29:52,550
to support all the flags address mention

00:29:50,000 --> 00:29:55,820
that and there are still a few

00:29:52,550 --> 00:29:58,840
challenges with rail row and by now

00:29:55,820 --> 00:30:01,070
right now specifically for X or --g

00:29:58,840 --> 00:30:04,370
because of the way some programs

00:30:01,070 --> 00:30:07,460
implement plugins they may load drivers

00:30:04,370 --> 00:30:10,340
shared objects which then in turn

00:30:07,460 --> 00:30:12,230
declare which dependencies they have for

00:30:10,340 --> 00:30:14,600
the symbols that they use and then

00:30:12,230 --> 00:30:15,920
asking exhort to load the subsequent

00:30:14,600 --> 00:30:18,200
drivers implementing that and

00:30:15,920 --> 00:30:20,870
unfortunately since symbols are looked

00:30:18,200 --> 00:30:23,030
up right away like also when loading

00:30:20,870 --> 00:30:24,740
shadow objects the program will crash

00:30:23,030 --> 00:30:28,160
because the symbol doesn't exist it

00:30:24,740 --> 00:30:30,710
doesn't find it and it it it breaks so

00:30:28,160 --> 00:30:33,590
right now xorg has to be built using

00:30:30,710 --> 00:30:37,040
partial railro and doesn't support full

00:30:33,590 --> 00:30:39,440
well this could be adapted to more

00:30:37,040 --> 00:30:43,160
platforms however not considering the

00:30:39,440 --> 00:30:44,930
issue with xorg the support I mean I put

00:30:43,160 --> 00:30:47,450
in place only works on that busy I think

00:30:44,930 --> 00:30:50,330
it should be easy to also adapted for

00:30:47,450 --> 00:30:52,460
open BSD and Linux but again is requires

00:30:50,330 --> 00:30:54,620
support from packages to actually

00:30:52,460 --> 00:30:56,500
implement see flags and on LD Flags this

00:30:54,620 --> 00:30:58,600
time

00:30:56,500 --> 00:31:01,179
we can confirm that the binary was built

00:30:58,600 --> 00:31:04,570
with rel run by now this time it's very

00:31:01,179 --> 00:31:06,820
definite we use up jump to list the

00:31:04,570 --> 00:31:10,210
different sections in the earth binary

00:31:06,820 --> 00:31:11,770
and if there is a a section called by

00:31:10,210 --> 00:31:15,160
now which is actually the dummy value

00:31:11,770 --> 00:31:18,640
the linker will see that and apply

00:31:15,160 --> 00:31:20,790
railroad mmediately and otherwise the

00:31:18,640 --> 00:31:24,040
relocation table will be also

00:31:20,790 --> 00:31:27,130
pre-prepared under the name rail row in

00:31:24,040 --> 00:31:28,720
the program header this verification is

00:31:27,130 --> 00:31:33,640
now automated in package shows I

00:31:28,720 --> 00:31:36,880
implemented a check using the an ox

00:31:33,640 --> 00:31:42,640
script this was my first auto program

00:31:36,880 --> 00:31:44,320
actually and this is enabled if you

00:31:42,640 --> 00:31:45,520
enable package developer which will then

00:31:44,320 --> 00:31:47,200
automatically enable the number of

00:31:45,520 --> 00:31:50,590
checks when you build packages and then

00:31:47,200 --> 00:31:54,640
run the railroad check in each PSD I

00:31:50,590 --> 00:31:57,220
also created a small package just in to

00:31:54,640 --> 00:31:58,990
verify that everything is fine so it's a

00:31:57,220 --> 00:32:03,700
program which does nothing but links to

00:31:58,990 --> 00:32:07,150
library and then it runs itself it can

00:32:03,700 --> 00:32:10,600
tell you as the library code if it was

00:32:07,150 --> 00:32:12,520
built with epoch he can see you then

00:32:10,600 --> 00:32:14,110
as part of the executive all code using

00:32:12,520 --> 00:32:17,380
the library if it was also built with F

00:32:14,110 --> 00:32:20,490
pick it can be improved further by using

00:32:17,380 --> 00:32:22,150
F PI but this is not strictly necessary

00:32:20,490 --> 00:32:23,980
programs can also tell if they were

00:32:22,150 --> 00:32:27,309
built with fortify sauce since the

00:32:23,980 --> 00:32:29,440
preprocessor will present the macro to

00:32:27,309 --> 00:32:31,809
them and then I have also even an

00:32:29,440 --> 00:32:35,950
additional tech check for a map in which

00:32:31,809 --> 00:32:38,500
case we still do not implement the

00:32:35,950 --> 00:32:41,860
security of a map as good as it could be

00:32:38,500 --> 00:32:46,390
as well as it could be but this is also

00:32:41,860 --> 00:32:49,750
being worked on now let's pray the demo

00:32:46,390 --> 00:32:52,059
gods for for the demo well you could use

00:32:49,750 --> 00:32:53,890
it that I don't have to because this is

00:32:52,059 --> 00:32:56,740
a demo my system is running right now on

00:32:53,890 --> 00:33:00,660
binary build of package shows with all

00:32:56,740 --> 00:33:02,980
of that enabled except maybe a sec stack

00:33:00,660 --> 00:33:05,679
so my goose island has every feature I

00:33:02,980 --> 00:33:08,620
mentioned so far except for xorg with

00:33:05,679 --> 00:33:09,930
partial railro and even live office was

00:33:08,620 --> 00:33:15,030
built on my system here

00:33:09,930 --> 00:33:19,140
nice laptop using pi 45s SP and it works

00:33:15,030 --> 00:33:21,750
fine and I can fly I can swap slides

00:33:19,140 --> 00:33:23,670
okay it's not super fast right now but

00:33:21,750 --> 00:33:24,740
you can blame Libre Office for that it's

00:33:23,670 --> 00:33:29,360
not me

00:33:24,740 --> 00:33:33,240
all right now for what's left to do I

00:33:29,360 --> 00:33:34,500
haven't reviewed this part of my talk as

00:33:33,240 --> 00:33:36,420
much as I should have

00:33:34,500 --> 00:33:38,420
I give this talk ready actually at a

00:33:36,420 --> 00:33:40,440
trapeze de conan bt-yakin is here and

00:33:38,420 --> 00:33:42,720
before that there was also a

00:33:40,440 --> 00:33:44,100
reproducible build some it or I was

00:33:42,720 --> 00:33:46,770
introduced to this community it's a very

00:33:44,100 --> 00:33:48,570
nice community right now encode a lot in

00:33:46,770 --> 00:33:52,560
Debian but what they actually try to

00:33:48,570 --> 00:33:54,780
achieve is a set of software development

00:33:52,560 --> 00:33:56,880
practice which create verifiable paths

00:33:54,780 --> 00:33:59,700
from human readable source to the binary

00:33:56,880 --> 00:34:01,950
code generated so what this means in

00:33:59,700 --> 00:34:04,440
other words is that you have a given

00:34:01,950 --> 00:34:06,300
source and a given system to build it

00:34:04,440 --> 00:34:10,020
you want to be sure that it will

00:34:06,300 --> 00:34:11,280
actually compile to the same binary like

00:34:10,020 --> 00:34:13,620
bits

00:34:11,280 --> 00:34:15,120
bitwise you can compare bitwise the

00:34:13,620 --> 00:34:17,820
binary tree generated there will be the

00:34:15,120 --> 00:34:20,700
same this isn't a purpose of verifying

00:34:17,820 --> 00:34:21,899
your computation chain if you want to be

00:34:20,700 --> 00:34:24,210
sure that everybody has the same

00:34:21,899 --> 00:34:26,850
computation chain and that no one else

00:34:24,210 --> 00:34:30,690
fooled you compiler to make your code

00:34:26,850 --> 00:34:33,720
generate something else then you can

00:34:30,690 --> 00:34:36,240
verify against binaries built by other

00:34:33,720 --> 00:34:36,740
people if you could generate the same

00:34:36,240 --> 00:34:42,330
package

00:34:36,740 --> 00:34:44,730
this involves many changes in in the

00:34:42,330 --> 00:34:47,399
tool chain and also inside the source

00:34:44,730 --> 00:34:48,810
code of the packages you have to make

00:34:47,399 --> 00:34:52,159
sure that for instance we test Suites

00:34:48,810 --> 00:34:54,000
will not be present inside the final

00:34:52,159 --> 00:34:56,580
binaries if they include the current

00:34:54,000 --> 00:35:00,240
data date and time or build a number

00:34:56,580 --> 00:35:01,950
this is also relevant for about

00:35:00,240 --> 00:35:04,080
dialogues when people like to put in

00:35:01,950 --> 00:35:06,030
place which tool chain was used and at

00:35:04,080 --> 00:35:07,740
what time the system was the package was

00:35:06,030 --> 00:35:09,150
built this needs to be removed because

00:35:07,740 --> 00:35:11,370
we need to have the same binary

00:35:09,150 --> 00:35:12,930
everywhere all we need to use the same

00:35:11,370 --> 00:35:15,390
time stamps I mean there are a number of

00:35:12,930 --> 00:35:15,810
implications so basically we want to

00:35:15,390 --> 00:35:18,930
reach

00:35:15,810 --> 00:35:20,880
deterministic build system this doesn't

00:35:18,930 --> 00:35:22,440
bring security right away but it allows

00:35:20,880 --> 00:35:23,560
you to check that your tool chain is

00:35:22,440 --> 00:35:26,220
actually

00:35:23,560 --> 00:35:29,800
or that you share it with everybody else

00:35:26,220 --> 00:35:32,620
OpenBSD does that in a sense that the

00:35:29,800 --> 00:35:34,270
only supports their own binaries did you

00:35:32,620 --> 00:35:36,130
not support packages that you may have

00:35:34,270 --> 00:35:37,990
built on your side because when they get

00:35:36,130 --> 00:35:42,550
bug reports they want everybody to be

00:35:37,990 --> 00:35:47,770
using the same binary to restrict the

00:35:42,550 --> 00:35:50,260
number of invariants to the what

00:35:47,770 --> 00:35:52,660
everybody can actually verify all right

00:35:50,260 --> 00:35:56,380
so then with that users can reproduce

00:35:52,660 --> 00:35:58,840
and verify what they build this is

00:35:56,380 --> 00:36:02,200
already implemented in FreeBSD sports it

00:35:58,840 --> 00:36:05,110
doesn't work yet across every package of

00:36:02,200 --> 00:36:07,690
that tree but we could also try to

00:36:05,110 --> 00:36:09,040
achieve that in in package shows and

00:36:07,690 --> 00:36:10,810
this is already the case for the basis

00:36:09,040 --> 00:36:13,660
to me and BSD but we do not have it yet

00:36:10,810 --> 00:36:17,350
in in package shows some things actually

00:36:13,660 --> 00:36:18,970
very easy to to get built reproducibly

00:36:17,350 --> 00:36:22,900
just by setting an environment variable

00:36:18,970 --> 00:36:26,070
so date epoch and some flags may also be

00:36:22,900 --> 00:36:28,830
relevant for GCC for instance when

00:36:26,070 --> 00:36:31,360
importing debugging symbols for instance

00:36:28,830 --> 00:36:33,760
they typically include the absolute

00:36:31,360 --> 00:36:35,740
paths to use the source code while it

00:36:33,760 --> 00:36:38,560
was built but this can be replaced with

00:36:35,740 --> 00:36:40,960
debug prefix map for instance and so on

00:36:38,560 --> 00:36:44,680
there's a number of ways to alter that

00:36:40,960 --> 00:36:47,740
so that everybody has the same binaries

00:36:44,680 --> 00:36:50,800
eventually all right the name is also

00:36:47,740 --> 00:36:52,600
code flow integrity CFI which prevents

00:36:50,800 --> 00:36:54,940
exploits from the right redirecting the

00:36:52,600 --> 00:36:56,830
execution flow of programs I'm gonna

00:36:54,940 --> 00:36:58,570
have it off the top of my head to

00:36:56,830 --> 00:37:01,360
explain it in other words but basically

00:36:58,570 --> 00:37:03,090
again you get control crashes instead of

00:37:01,360 --> 00:37:06,070
undefined behavior that can be exploited

00:37:03,090 --> 00:37:08,290
but Gautreau's would be a great test bed

00:37:06,070 --> 00:37:10,540
for this feature since we can take care

00:37:08,290 --> 00:37:13,450
of thousands and thousands of packages

00:37:10,540 --> 00:37:15,730
that at once through the 3d framework

00:37:13,450 --> 00:37:20,470
this is a variable right now in clang

00:37:15,730 --> 00:37:24,700
which we support and it involves see

00:37:20,470 --> 00:37:27,190
flags typically fa2 and sanitized equals

00:37:24,700 --> 00:37:30,640
CFI there's a number of different

00:37:27,190 --> 00:37:32,230
machines which can be selected possibly

00:37:30,640 --> 00:37:35,400
you can add visibility:hidden I do not

00:37:32,230 --> 00:37:36,940
remember the details right now but

00:37:35,400 --> 00:37:39,010
basically

00:37:36,940 --> 00:37:41,140
it has a negligible performance impact

00:37:39,010 --> 00:37:43,210
which means that it can even be suitable

00:37:41,140 --> 00:37:47,410
for release build and bring an extra

00:37:43,210 --> 00:37:49,000
level of security when using Clank with

00:37:47,410 --> 00:37:50,950
clang again you can enable safe stock

00:37:49,000 --> 00:37:54,730
which is maybe even more interesting

00:37:50,950 --> 00:37:57,790
than CFI right now this is the

00:37:54,730 --> 00:38:02,560
definition from the clang website it

00:37:57,790 --> 00:38:04,960
involves see flags FC meter is set to

00:38:02,560 --> 00:38:07,150
safe stack and if I remember right it

00:38:04,960 --> 00:38:09,430
will divide the stack into different

00:38:07,150 --> 00:38:12,880
stacks actually yes the safe and the

00:38:09,430 --> 00:38:15,360
unsafe the safe stack has the code flow

00:38:12,880 --> 00:38:18,520
so it will store the return addresses

00:38:15,360 --> 00:38:20,680
local variables that are always accessed

00:38:18,520 --> 00:38:22,330
in a safe way while the unsafe stack

00:38:20,680 --> 00:38:24,220
stores everything else what can be

00:38:22,330 --> 00:38:27,760
corrupted and will not have an impact

00:38:24,220 --> 00:38:30,400
for instance on the execution flow so

00:38:27,760 --> 00:38:34,260
then if it's overwritten it's less drama

00:38:30,400 --> 00:38:37,030
than if it would be the return address

00:38:34,260 --> 00:38:40,360
okay then in GT C we also have some

00:38:37,030 --> 00:38:42,340
mechanisms that we can apply through C

00:38:40,360 --> 00:38:45,070
flags the address sanitizer F sanitized

00:38:42,340 --> 00:38:48,850
is set to address it will detect

00:38:45,070 --> 00:38:50,260
out-of-bounds use or use F to free by

00:38:48,850 --> 00:38:53,730
instrumenting memory access instructions

00:38:50,260 --> 00:38:57,130
I still commented on your GCC website

00:38:53,730 --> 00:38:59,130
however it has a huge performance impact

00:38:57,130 --> 00:39:01,810
and it's not always suitable for

00:38:59,130 --> 00:39:04,900
production binaries it can be used

00:39:01,810 --> 00:39:07,870
however for fuzzers if you first code it

00:39:04,900 --> 00:39:10,240
this is very useful and it will very

00:39:07,870 --> 00:39:13,240
easily detect invalid memory accesses

00:39:10,240 --> 00:39:15,480
even without using Lipsy functions and

00:39:13,240 --> 00:39:18,490
so on and jeans instruction level

00:39:15,480 --> 00:39:21,700
alright since time is also slowly

00:39:18,490 --> 00:39:23,470
running out I will conclude I think that

00:39:21,700 --> 00:39:26,170
packet Rose is a great project for

00:39:23,470 --> 00:39:28,570
testing security features you can

00:39:26,170 --> 00:39:30,910
implement it once through framework and

00:39:28,570 --> 00:39:34,030
then it will be applied across the

00:39:30,910 --> 00:39:35,530
entire tree and since we support so many

00:39:34,030 --> 00:39:37,480
different packages many different

00:39:35,530 --> 00:39:39,610
packages are available this can be

00:39:37,480 --> 00:39:43,060
applied to an entire distribution at

00:39:39,610 --> 00:39:45,010
once some mechanisms are enabled by

00:39:43,060 --> 00:39:48,040
default now among the ones that I just

00:39:45,010 --> 00:39:49,570
mentioned particularly SSP in 45 I hope

00:39:48,040 --> 00:39:53,290
you can get also PI or

00:39:49,570 --> 00:39:55,990
soon what more can still be done I will

00:39:53,290 --> 00:39:57,850
welcome you to have a look at the

00:39:55,990 --> 00:40:01,300
features I just mentioned or even

00:39:57,850 --> 00:40:04,270
further ones if you feel like it my own

00:40:01,300 --> 00:40:08,170
current focus is on testing full well

00:40:04,270 --> 00:40:10,900
roll getting pie to work working again

00:40:08,170 --> 00:40:12,790
on package signatures and implementing

00:40:10,900 --> 00:40:16,890
additional checks in package developer

00:40:12,790 --> 00:40:19,690
of course you can beat me to it please

00:40:16,890 --> 00:40:22,330
so that my 2 reduces magically that's

00:40:19,690 --> 00:40:25,390
great I love that and otherwise I can

00:40:22,330 --> 00:40:26,880
only thank you for listening so far -

00:40:25,390 --> 00:40:30,160
you're busy icon for having me

00:40:26,880 --> 00:40:32,290
package shows project giant for helping

00:40:30,160 --> 00:40:34,300
out scale I'm also really helpful with

00:40:32,290 --> 00:40:35,950
the H PSD project the different

00:40:34,300 --> 00:40:38,470
communities which support me providing

00:40:35,950 --> 00:40:41,590
shells and otherwise bits of knowledge

00:40:38,470 --> 00:40:52,930
and I'm available at net busy - at work

00:40:41,590 --> 00:40:55,330
korban so thank you very much if you

00:40:52,930 --> 00:41:00,060
have any question I will be happy to go

00:40:55,330 --> 00:41:00,060
ahead yeah we have one two three

00:41:01,320 --> 00:41:09,550
so mark lots of question but limit

00:41:06,520 --> 00:41:12,480
myself to three of them this one is

00:41:09,550 --> 00:41:15,730
probably very simple but fortify like

00:41:12,480 --> 00:41:17,920
using ink for four cores like my move

00:41:15,730 --> 00:41:19,750
which is usually a built-in in compilers

00:41:17,920 --> 00:41:21,910
how does it where we respect to that

00:41:19,750 --> 00:41:24,880
it's always going to admit my move check

00:41:21,910 --> 00:41:27,520
or is it still going to be able to do

00:41:24,880 --> 00:41:31,660
some built-in work so what happens is

00:41:27,520 --> 00:41:35,410
that Lipsy headers are automatically

00:41:31,660 --> 00:41:37,890
redirected if fortify source is set to

00:41:35,410 --> 00:41:41,110
one or two to a different one which will

00:41:37,890 --> 00:41:43,150
through a macro change the call to move

00:41:41,110 --> 00:41:46,780
to something else like man move check

00:41:43,150 --> 00:41:49,120
and then this will only be done for

00:41:46,780 --> 00:41:51,490
instance if GCC is also in news did

00:41:49,120 --> 00:41:54,460
checking this macro and then it will use

00:41:51,490 --> 00:41:57,760
attributes to talk to GCC and tell it to

00:41:54,460 --> 00:42:00,130
change which code to use okay so when

00:41:57,760 --> 00:42:01,020
you use the built-in actually sorry you

00:42:00,130 --> 00:42:03,450
lose

00:42:01,020 --> 00:42:05,340
it was the built-in it's also a built-in

00:42:03,450 --> 00:42:08,220
from GCC it just has a different name

00:42:05,340 --> 00:42:10,619
yeah but for instance the fact that it

00:42:08,220 --> 00:42:14,220
can be optimized to you know encode he

00:42:10,619 --> 00:42:16,530
was not completely yeah probably

00:42:14,220 --> 00:42:19,440
possibly yes but as soon as you see

00:42:16,530 --> 00:42:23,030
smart enough to also inline the memo

00:42:19,440 --> 00:42:23,030
version with the boundary check if it's

00:42:25,820 --> 00:42:33,690
amount one you're aware but we have a

00:42:29,520 --> 00:42:35,490
way to work around by now issue like we

00:42:33,690 --> 00:42:37,950
have the system call which is called I

00:42:35,490 --> 00:42:40,260
think a bind which has the picture ID

00:42:37,950 --> 00:42:44,130
but it can only be called from one

00:42:40,260 --> 00:42:46,320
address in process less and we use what

00:42:44,130 --> 00:42:50,930
you know in a McClintock curve so we can

00:42:46,320 --> 00:42:54,960
still have Lizzie binding and still have

00:42:50,930 --> 00:42:57,390
almost a strongest from really a row as

00:42:54,960 --> 00:43:01,500
you have okay you might want to look at

00:42:57,390 --> 00:43:03,960
that probably haven't already I think we

00:43:01,500 --> 00:43:06,359
got your hello almost live from the tool

00:43:03,960 --> 00:43:09,000
chain because it's involves the dynamic

00:43:06,359 --> 00:43:11,640
loader and okay the image folder is from

00:43:09,000 --> 00:43:16,800
Melanie teapot from us because parts in

00:43:11,640 --> 00:43:19,530
the camera but otherwise by now is

00:43:16,800 --> 00:43:20,880
impractical for stuff like your fish if

00:43:19,530 --> 00:43:23,310
you still want to have any kind of

00:43:20,880 --> 00:43:26,510
performance so that may be useful for us

00:43:23,310 --> 00:43:28,859
okay but I didn't notice any specific

00:43:26,510 --> 00:43:30,690
issue with live office also have a

00:43:28,859 --> 00:43:33,330
modern laptop quite recently so this

00:43:30,690 --> 00:43:36,030
could also be the reason and last

00:43:33,330 --> 00:43:39,180
question is controversial but you've got

00:43:36,030 --> 00:43:42,330
lots of options to make things more

00:43:39,180 --> 00:43:44,670
secure yeah and I'm still wondering why

00:43:42,330 --> 00:43:47,450
don't you turn them on by default like

00:43:44,670 --> 00:43:50,600
for instance what why do you even have

00:43:47,450 --> 00:43:53,910
to say that you want to have sign

00:43:50,600 --> 00:43:57,060
vulnerability database package instead

00:43:53,910 --> 00:43:59,430
of having it check the signature by

00:43:57,060 --> 00:44:00,800
default and always have the most recent

00:43:59,430 --> 00:44:03,180
version unless you a specific

00:44:00,800 --> 00:44:05,640
specifically asked otherwise and stuff

00:44:03,180 --> 00:44:07,080
like that so actually were right over I

00:44:05,640 --> 00:44:10,800
described is already enabled by default

00:44:07,080 --> 00:44:12,030
I call so the package vulnerability

00:44:10,800 --> 00:44:13,290
database

00:44:12,030 --> 00:44:15,510
I don't think it's downloaded

00:44:13,290 --> 00:44:19,200
automatically every day but the

00:44:15,510 --> 00:44:21,330
signatures are verified by default then

00:44:19,200 --> 00:44:22,710
now in package shows we have SSP and 45

00:44:21,330 --> 00:44:26,520
enable by default okay

00:44:22,710 --> 00:44:28,110
I did actually this talk to push for it

00:44:26,520 --> 00:44:30,690
because a year ago it was not in place

00:44:28,110 --> 00:44:32,910
and I did it explained it and I had to

00:44:30,690 --> 00:44:36,540
go around the world to convince

00:44:32,910 --> 00:44:39,240
everybody that this is ok but I was also

00:44:36,540 --> 00:44:41,160
very experienced and I keep pushing and

00:44:39,240 --> 00:44:43,830
this was more second part of a question

00:44:41,160 --> 00:44:46,320
like for signatures you only show this

00:44:43,830 --> 00:44:48,000
what you do when you add one single

00:44:46,320 --> 00:44:50,640
package and you show the full signature

00:44:48,000 --> 00:44:52,800
yeah if you add the list of packages and

00:44:50,640 --> 00:44:54,360
we all have the same signature I assume

00:44:52,800 --> 00:44:56,550
that you're only going to shove

00:44:54,360 --> 00:44:57,810
information once right no the

00:44:56,550 --> 00:44:59,520
information is displayed for each and

00:44:57,810 --> 00:45:01,380
every package that you install but

00:44:59,520 --> 00:45:03,690
something that you can fix and that will

00:45:01,380 --> 00:45:14,850
quickly reduce the number of information

00:45:03,690 --> 00:45:17,460
displayed ok should be easy you said

00:45:14,850 --> 00:45:19,980
that address sanitizes - slow - for a

00:45:17,460 --> 00:45:23,160
fraction build yes you wouldn't want to

00:45:19,980 --> 00:45:27,660
use it for the thing you and your users

00:45:23,160 --> 00:45:29,520
install but but one way you could use it

00:45:27,660 --> 00:45:32,940
in a sensible way perhaps would be to

00:45:29,520 --> 00:45:36,270
provide a pack a target that would build

00:45:32,940 --> 00:45:38,250
the package with a center and on and

00:45:36,270 --> 00:45:41,670
then run the regression tests yeah like

00:45:38,250 --> 00:45:43,650
make test - a sign or something yeah

00:45:41,670 --> 00:45:46,890
this would be great I do not know if we

00:45:43,650 --> 00:45:49,710
have the notion of the package have a

00:45:46,890 --> 00:45:52,320
regression test in package sauce yet in

00:45:49,710 --> 00:45:55,110
a framework but if we could do that

00:45:52,320 --> 00:45:58,140
that'd be great of course well you don't

00:45:55,110 --> 00:45:59,520
really need that you can just what

00:45:58,140 --> 00:46:01,200
happens now if you do make tests and the

00:45:59,520 --> 00:46:02,040
package doesn't have tests it's just you

00:46:01,200 --> 00:46:04,830
know it does nothing

00:46:02,040 --> 00:46:06,840
yeah but it also needs to be specified

00:46:04,830 --> 00:46:09,570
for each package how to run the test and

00:46:06,840 --> 00:46:12,600
yeah it's quite a bit of work and you

00:46:09,570 --> 00:46:20,420
can probably also do T son at the same

00:46:12,600 --> 00:46:20,420
time thread sanitizer yeah yeah yeah

00:46:21,390 --> 00:46:32,440
christos son so I see that the security

00:46:30,910 --> 00:46:35,050
model you propose here is quite

00:46:32,440 --> 00:46:39,280
centralized and it's a strongly relying

00:46:35,050 --> 00:46:41,800
on the compiler yeah if I look at

00:46:39,280 --> 00:46:43,720
security nowadays it tends to be really

00:46:41,800 --> 00:46:46,510
decentralized that are like technologies

00:46:43,720 --> 00:46:49,540
like blockchain for example who tends to

00:46:46,510 --> 00:46:51,550
decentralize things so my question is do

00:46:49,540 --> 00:46:54,640
you think there would be like a better

00:46:51,550 --> 00:46:58,090
way to do it instead of relying only on

00:46:54,640 --> 00:47:00,370
the compiler of software which is like

00:46:58,090 --> 00:47:02,890
Jesus in this case it's not really that

00:47:00,370 --> 00:47:05,230
we rely on a compiler I'm just using

00:47:02,890 --> 00:47:07,660
features offered by the compiler in

00:47:05,230 --> 00:47:11,290
package shows and enabling it for the

00:47:07,660 --> 00:47:12,460
entire range of submission what the

00:47:11,290 --> 00:47:14,770
package is doing themselves is not

00:47:12,460 --> 00:47:16,800
relevant to us they we are only a

00:47:14,770 --> 00:47:19,990
framework to build a distribution

00:47:16,800 --> 00:47:21,580
security then is also a field which

00:47:19,990 --> 00:47:24,430
applies to everything there is an

00:47:21,580 --> 00:47:26,260
security dimension to everything you do

00:47:24,430 --> 00:47:27,640
even sitting on a chair someone has

00:47:26,260 --> 00:47:30,460
actually tested that chair to be safe

00:47:27,640 --> 00:47:33,190
that it doesn't break in pieces and cut

00:47:30,460 --> 00:47:35,230
your hands if if it fails so we cannot

00:47:33,190 --> 00:47:36,970
cover everything sensually or this you

00:47:35,230 --> 00:47:39,670
know decentralized matter alright this

00:47:36,970 --> 00:47:42,280
is highly context specific and there is

00:47:39,670 --> 00:47:52,240
no magic wand to just secure everything

00:47:42,280 --> 00:47:53,590
unfortunately hi my question is may

00:47:52,240 --> 00:47:55,660
probably been asked I'm not sure because

00:47:53,590 --> 00:47:59,050
it was slightly technical and I'm not a

00:47:55,660 --> 00:48:01,600
security person but the way the same way

00:47:59,050 --> 00:48:03,340
that like we do testing with an eater or

00:48:01,600 --> 00:48:04,780
never used a for example where a bunch

00:48:03,340 --> 00:48:08,140
of test cases are done and there's an

00:48:04,780 --> 00:48:09,970
automated way to test I'm wondering if

00:48:08,140 --> 00:48:12,280
something like a pen testing tool like

00:48:09,970 --> 00:48:15,100
Kali or something could be run real-time

00:48:12,280 --> 00:48:16,960
to continuously probe if our security so

00:48:15,100 --> 00:48:19,570
again instead of building the fort and

00:48:16,960 --> 00:48:21,280
not you know zooming in a work is there

00:48:19,570 --> 00:48:23,380
a way to kind of continually through

00:48:21,280 --> 00:48:24,580
whatever challenges or whatever known

00:48:23,380 --> 00:48:26,380
threats there are out there

00:48:24,580 --> 00:48:29,370
so I'm just wondering if that's part of

00:48:26,380 --> 00:48:31,240
a broad design approach to this

00:48:29,370 --> 00:48:32,340
infrastructure of there's possibility

00:48:31,240 --> 00:48:34,170
for that

00:48:32,340 --> 00:48:36,840
I think it should be possible to do a

00:48:34,170 --> 00:48:38,490
lot more in this direction I do not have

00:48:36,840 --> 00:48:40,590
any specific idea on top of my head

00:48:38,490 --> 00:48:47,280
outside of what we just mentioned with

00:48:40,590 --> 00:48:48,540
buzzing maybe Christos so Google has is

00:48:47,280 --> 00:48:52,050
offering a great project it's called

00:48:48,540 --> 00:48:54,000
Oasis fuzz and basically you can submit

00:48:52,050 --> 00:48:57,450
your open-source project and they have a

00:48:54,000 --> 00:48:59,490
library API for fuzzing so you they will

00:48:57,450 --> 00:49:03,510
run your code and they will actually

00:48:59,490 --> 00:49:05,460
open bug reports to you they run you

00:49:03,510 --> 00:49:09,450
know your code against you know

00:49:05,460 --> 00:49:11,940
arbitrary inputs using both all three

00:49:09,450 --> 00:49:15,330
sanitizers I think both Amazon you basan

00:49:11,940 --> 00:49:19,470
and Aysen and you know this is a great

00:49:15,330 --> 00:49:21,540
way to get cheap cycles to run your

00:49:19,470 --> 00:49:24,600
functions against whatever you want so

00:49:21,540 --> 00:49:26,070
if packages want to get more secure you

00:49:24,600 --> 00:49:29,750
know they should just subscribe to that

00:49:26,070 --> 00:49:32,880
and actually there is also money back

00:49:29,750 --> 00:49:35,370
you know Google will pay you money if

00:49:32,880 --> 00:49:37,470
you know you they you advertise and you

00:49:35,370 --> 00:49:39,480
find bugs and you introduce with their

00:49:37,470 --> 00:49:42,720
build so that's a great plug-in for

00:49:39,480 --> 00:49:44,820
Google or I don't work for them if you

00:49:42,720 --> 00:49:47,190
want to do it in package source since we

00:49:44,820 --> 00:49:49,830
have the framework we can easily for

00:49:47,190 --> 00:49:51,360
each and every target build the system

00:49:49,830 --> 00:49:53,610
up to the package you want to test and

00:49:51,360 --> 00:49:55,200
then build this one with a scientist and

00:49:53,610 --> 00:49:57,480
you'll be son and so on and then run

00:49:55,200 --> 00:50:04,860
these test Suites and easily scripted

00:49:57,480 --> 00:50:07,380
through package shows for maybe I just

00:50:04,860 --> 00:50:12,420
wanted to comment that it's probably not

00:50:07,380 --> 00:50:15,200
useful if a package sauce has tests for

00:50:12,420 --> 00:50:19,560
Firefox Firefox already does them

00:50:15,200 --> 00:50:21,330
themselves so it depends on the package

00:50:19,560 --> 00:50:24,540
if it makes sense to do this from

00:50:21,330 --> 00:50:31,770
packaged sauce or if the project we are

00:50:24,540 --> 00:50:33,120
using is doing it themselves yeah I

00:50:31,770 --> 00:50:36,210
think we should disable test which by

00:50:33,120 --> 00:50:37,620
default when building in Burke and but

00:50:36,210 --> 00:50:40,590
then tell package sauce how to actually

00:50:37,620 --> 00:50:43,350
run it if people want to have it

00:50:40,590 --> 00:50:47,130
so as I said you can do like a icing the

00:50:43,350 --> 00:50:49,020
test target equals something and yeah

00:50:47,130 --> 00:50:51,360
it's not run as part of the build

00:50:49,020 --> 00:50:54,810
normally except I think you can set a

00:50:51,360 --> 00:50:58,140
variable that will run it after building

00:50:54,810 --> 00:51:01,380
absolutely the other thing you mentioned

00:50:58,140 --> 00:51:03,060
Google's offering I don't know if David

00:51:01,380 --> 00:51:06,630
Maxwell still does that but there were

00:51:03,060 --> 00:51:10,080
the security scans what was the name of

00:51:06,630 --> 00:51:12,900
the company Coverity Coverity right so

00:51:10,080 --> 00:51:15,930
their their approach last time I looked

00:51:12,900 --> 00:51:17,970
at it was your thing you want to test

00:51:15,930 --> 00:51:19,920
must be in package sauce and I use that

00:51:17,970 --> 00:51:21,840
for building and then I tested with a

00:51:19,920 --> 00:51:23,310
static analyzer which is normally a

00:51:21,840 --> 00:51:26,640
commercial very expensive product and

00:51:23,310 --> 00:51:29,190
they'll send your report and you can

00:51:26,640 --> 00:51:32,610
look at all the boxes found there's like

00:51:29,190 --> 00:51:36,630
dozens of them typically yeah thanks

00:51:32,610 --> 00:51:38,720
Benny is there anyone else who yeah over

00:51:36,630 --> 00:51:38,720
there

00:51:45,860 --> 00:51:51,980
thanks a lot first um I'm actually I'm

00:51:49,430 --> 00:51:54,530
not very familiar with net bsd or a pkg

00:51:51,980 --> 00:51:57,020
source so there was a great overwhelming

00:51:54,530 --> 00:51:59,180
introduction for me um I just learned

00:51:57,020 --> 00:52:01,250
the repository and well it was just

00:51:59,180 --> 00:52:04,700
about one gigabyte so I'm very sorry for

00:52:01,250 --> 00:52:06,440
blocking the network here and I was

00:52:04,700 --> 00:52:09,080
wondering why it's so huge I had to look

00:52:06,440 --> 00:52:11,750
and it seems like all the ports were in

00:52:09,080 --> 00:52:14,480
there first and a lot of stuff already

00:52:11,750 --> 00:52:18,470
have you thought about splitting that up

00:52:14,480 --> 00:52:21,100
and just offering without the bootstrap

00:52:18,470 --> 00:52:23,780
travel but just the sources themselves

00:52:21,100 --> 00:52:27,490
can someone else answer that because

00:52:23,780 --> 00:52:27,490
this is not where I'm the most familiar

00:52:30,310 --> 00:52:34,840
so I'm gonna give a half cynical answer

00:52:35,830 --> 00:52:42,770
is not a lot of disk space downloading

00:52:40,220 --> 00:52:45,140
what we give out is not nice but you

00:52:42,770 --> 00:52:47,270
could have started from the Tuareg set

00:52:45,140 --> 00:52:49,940
which is less than 30 megabytes and I

00:52:47,270 --> 00:52:56,350
think it's relatively reasonable to be

00:52:49,940 --> 00:52:56,350
downloading 30 megabytes thanks

00:52:59,930 --> 00:53:06,119
okay so should I conclude here okay

00:53:02,570 --> 00:53:06,119

YouTube URL: https://www.youtube.com/watch?v=w9h0sqiq0sk


