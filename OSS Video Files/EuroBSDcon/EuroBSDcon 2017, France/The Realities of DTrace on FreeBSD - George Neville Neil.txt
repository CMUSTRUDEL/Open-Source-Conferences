Title: The Realities of DTrace on FreeBSD - George Neville Neil
Publication date: 2019-10-16
Playlist: EuroBSDcon 2017, France
Description: 
	Description:

This presentation is based upon the work of five authors:
Jonathan Anderson, Brian Kidney, George Neville-Neil, Arun Thomas, and
Robert Watson.

For more than a year we have been using DTrace as one of the three core
components of a security research project, CADETS. Unlike earlier users
of DTrace, which were focused on occasional, deep debugging sessions,
the CADETS project uses DTrace to bring total system transparency to
both the operating system and the applications that are running on top
of it. The use of “always-on tracing” pushes the DTrace system up to,
and often, past its limits and shows how some of the original design
tradeoffs need to be revisited to address the needs of our project. Our
talk covers our current efforts to extend and improve the DTrace
framework in FreeBSD, including performance and programming improvements
to address the needs of always-on tracing as well as integration with
FreeBSD’s audit subsystem and the addition of machine-readable output
for use by creators of downstream security-analysis tools.

Speaker biography:

George Neville-Neil works on networking and operating system code for
fun and profit. He also teaches various courses on subjects related to
computer programming. His professional areas of interest include code
spelunking, operating systems, networking, time and security. He is the
co-author with Marshall Kirk McKusick and Robert Watson of The Design
and Implementation of the FreeBSD Operating System and is the columnist
behind ACM Queue’s “Kode Vicious.” Mr. Neville-Neil earned his
bachelor’s degree in computer science at Northeastern University in
Boston, Massachusetts, and is a member of the ACM, the Usenix
Association, the IEEE, and is one of the Directors of the FreeBSD
Foundation. He is an avid bicyclist and traveler who currently resides
in New York City.
Captions: 
	00:00:00,319 --> 00:00:04,440
well I hope everyone is awake I

00:00:02,760 --> 00:00:05,819
considered giving this talk in French

00:00:04,440 --> 00:00:07,350
just so that none of you would know what

00:00:05,819 --> 00:00:09,929
I was talking about including the French

00:00:07,350 --> 00:00:11,160
people but instead I'm going to give it

00:00:09,929 --> 00:00:13,380
in English and people will still not

00:00:11,160 --> 00:00:15,450
know what I'm talking about this is work

00:00:13,380 --> 00:00:17,310
done jointly with the other lovely

00:00:15,450 --> 00:00:18,690
people on the slide here and Jonathan

00:00:17,310 --> 00:00:21,689
Anderson Brian kidney who gave a

00:00:18,690 --> 00:00:25,350
previous version of this talk at the SD

00:00:21,689 --> 00:00:30,929
can or in Thomas and Robert Watson and

00:00:25,350 --> 00:00:32,540
yes today is not the 23rd so what am I

00:00:30,929 --> 00:00:35,010
going to talk about over the next hour

00:00:32,540 --> 00:00:37,620
to try and keep you awake after having

00:00:35,010 --> 00:00:40,230
lunch so I'd like to talk about a few

00:00:37,620 --> 00:00:42,000
things generally when I give a dtrace

00:00:40,230 --> 00:00:44,190
talk I give a bit of history of DTrace

00:00:42,000 --> 00:00:47,370
some you know in this audience more

00:00:44,190 --> 00:00:48,989
people might notice than others I'd like

00:00:47,370 --> 00:00:52,530
to talk about the motivation for the

00:00:48,989 --> 00:00:53,610
work we're doing with dtrace and how the

00:00:52,530 --> 00:00:55,680
group of us that you saw on the first

00:00:53,610 --> 00:00:57,899
slide are trying to use DTrace

00:00:55,680 --> 00:01:01,050
sort of in broad outline because that

00:00:57,899 --> 00:01:04,320
really underpins some of the changes

00:01:01,050 --> 00:01:05,700
we're trying to make to DTrace I'll talk

00:01:04,320 --> 00:01:07,740
about some recent improvements that

00:01:05,700 --> 00:01:09,600
we've made to DTrace both in our own

00:01:07,740 --> 00:01:11,729
private repos which we will eventually

00:01:09,600 --> 00:01:14,670
upstream some changes who have gone into

00:01:11,729 --> 00:01:16,350
upstream some changes if not some

00:01:14,670 --> 00:01:19,280
changes we think are more acceptable to

00:01:16,350 --> 00:01:23,070
the broader community and some of them

00:01:19,280 --> 00:01:26,310
I'd like to talk a little bit about how

00:01:23,070 --> 00:01:29,250
people actually use dtrace because I

00:01:26,310 --> 00:01:31,920
know this is not a room of only kernel

00:01:29,250 --> 00:01:34,140
developers but the majority of kernel

00:01:31,920 --> 00:01:37,619
developers who use dtrace sometimes

00:01:34,140 --> 00:01:39,630
don't understand how normal people you

00:01:37,619 --> 00:01:42,899
see the quotes from there normal people

00:01:39,630 --> 00:01:45,329
use two types or less abnormal and then

00:01:42,899 --> 00:01:49,290
I'll talk about I said I've normal when

00:01:45,329 --> 00:01:51,689
the lights came on because I need to be

00:01:49,290 --> 00:01:53,369
better lit and then I'll talk about some

00:01:51,689 --> 00:01:56,219
future improvements and the changes

00:01:53,369 --> 00:02:01,320
we're planning to make as we continue to

00:01:56,219 --> 00:02:03,509
grow and improve the dtrace code so this

00:02:01,320 --> 00:02:07,320
is my piece tomorrow blicket wah this is

00:02:03,509 --> 00:02:08,640
my obligatory history so DTrace have

00:02:07,320 --> 00:02:11,039
originally developed by a company called

00:02:08,640 --> 00:02:12,730
sun some of you may hurt may have heard

00:02:11,039 --> 00:02:15,160
of it and

00:02:12,730 --> 00:02:17,140
back in 2005 was sort of the first

00:02:15,160 --> 00:02:19,239
public release that you could get in

00:02:17,140 --> 00:02:22,930
Solaris but it was developed over time

00:02:19,239 --> 00:02:27,310
before that first ported by John Burrell

00:02:22,930 --> 00:02:30,130
to FreeBSD in 2008 has also been ported

00:02:27,310 --> 00:02:33,130
to Mac OS so you happen to be running a

00:02:30,130 --> 00:02:34,930
glowing Apple you also have some button

00:02:33,130 --> 00:02:42,160
you have dtrace although it may or may

00:02:34,930 --> 00:02:45,310
not be in mac OS and and since its

00:02:42,160 --> 00:02:47,260
initial ports it has been maintained

00:02:45,310 --> 00:02:49,870
separately with some cross patching

00:02:47,260 --> 00:02:52,269
between different versions so I'll talk

00:02:49,870 --> 00:02:54,400
a bit about that towards the end of the

00:02:52,269 --> 00:02:56,670
discussion but it's an important point

00:02:54,400 --> 00:02:58,569
to come back to it because we have this

00:02:56,670 --> 00:03:00,010
open source code base that had been

00:02:58,569 --> 00:03:04,180
modified by different groups of people

00:03:00,010 --> 00:03:11,019
with some amount of coordination but not

00:03:04,180 --> 00:03:13,660
with it okay so what are the motivations

00:03:11,019 --> 00:03:15,849
we have we being the research project

00:03:13,660 --> 00:03:17,260
they're working on also some of the

00:03:15,849 --> 00:03:21,850
people we've been working with in the

00:03:17,260 --> 00:03:22,739
community for using DTrace and why do we

00:03:21,850 --> 00:03:26,980
care about

00:03:22,739 --> 00:03:29,260
dtrace as a technology so DTrace is not

00:03:26,980 --> 00:03:33,970
the first tracing system ever built for

00:03:29,260 --> 00:03:36,639
an operating system it is you know

00:03:33,970 --> 00:03:40,630
there's a quite comprehensive system but

00:03:36,639 --> 00:03:42,970
you know I spend a lot of time working

00:03:40,630 --> 00:03:45,489
with people who are older even than me

00:03:42,970 --> 00:03:47,139
and as far as I can tell everything in

00:03:45,489 --> 00:03:50,590
computer science was done on the atlas

00:03:47,139 --> 00:03:53,340
in 1953 so I'm sure someone will tell me

00:03:50,590 --> 00:03:55,180
that there was a tracing system on that

00:03:53,340 --> 00:03:56,980
one of the reasons that we're very

00:03:55,180 --> 00:03:59,380
interested in dtrace is because it's an

00:03:56,980 --> 00:04:01,060
excellent open source system for tracing

00:03:59,380 --> 00:04:04,330
that is relatively well

00:04:01,060 --> 00:04:06,850
and relatively easy to understand and we

00:04:04,330 --> 00:04:09,250
believe that using DTrace we can improve

00:04:06,850 --> 00:04:10,690
the state of tracing on large systems so

00:04:09,250 --> 00:04:13,330
for those of you who have ever seen the

00:04:10,690 --> 00:04:16,540
title of my tutorial the subtitle is no

00:04:13,330 --> 00:04:19,989
more princess right so what I would like

00:04:16,540 --> 00:04:22,330
to do is live in a world past the 1970s

00:04:19,989 --> 00:04:23,740
where I don't have to use printf to the

00:04:22,330 --> 00:04:26,500
bug everything and I'd actually like

00:04:23,740 --> 00:04:30,730
tracing systems to be a pervasive common

00:04:26,500 --> 00:04:32,470
feature of operating systems another

00:04:30,730 --> 00:04:34,750
motivation that we have the research

00:04:32,470 --> 00:04:36,880
project is to expand tracing to

00:04:34,750 --> 00:04:39,190
distributed systems and I'll talk about

00:04:36,880 --> 00:04:41,080
this a bit more in a couple of slides

00:04:39,190 --> 00:04:43,750
but for those of you who've used the

00:04:41,080 --> 00:04:46,870
current D trace DTrace is usable on your

00:04:43,750 --> 00:04:48,730
single node it's a very powerful system

00:04:46,870 --> 00:04:50,770
but what if you could apply that to a

00:04:48,730 --> 00:04:53,110
distributed system how powerful would

00:04:50,770 --> 00:04:54,900
that be and there are again there are

00:04:53,110 --> 00:04:57,580
distributed tracing systems that exist

00:04:54,900 --> 00:04:59,500
but we believe that you trace is a good

00:04:57,580 --> 00:05:03,820
base from which to build more

00:04:59,500 --> 00:05:06,280
distributed person systems now some of

00:05:03,820 --> 00:05:09,790
us Robert Watson and myself have found

00:05:06,280 --> 00:05:11,770
that using tracing we're able to teach

00:05:09,790 --> 00:05:12,940
about complex systems so for this

00:05:11,770 --> 00:05:16,330
audience that maybe teach about

00:05:12,940 --> 00:05:18,940
operation so when I occasionally teach

00:05:16,330 --> 00:05:21,100
undergraduates because people are silly

00:05:18,940 --> 00:05:23,140
enough to ask me come to come teach

00:05:21,100 --> 00:05:25,360
undergraduates it's like a mistake on

00:05:23,140 --> 00:05:26,530
their part or when Robert teaches

00:05:25,360 --> 00:05:29,590
graduate students which seems like a

00:05:26,530 --> 00:05:31,780
good idea instead of making them

00:05:29,590 --> 00:05:33,380
reimplemented ikkyu lessly simple device

00:05:31,780 --> 00:05:35,360
driver for which they will learn

00:05:33,380 --> 00:05:36,950
think about the operating system we take

00:05:35,360 --> 00:05:38,510
them on a tour de force of the entire

00:05:36,950 --> 00:05:41,270
operating system using the tracing

00:05:38,510 --> 00:05:44,750
system so a good tracing system like

00:05:41,270 --> 00:05:47,390
DTrace allows us to in eight weeks for

00:05:44,750 --> 00:05:50,540
Robert or in a week of full-time work

00:05:47,390 --> 00:05:52,280
for myself take a class of twenty or

00:05:50,540 --> 00:05:55,520
thirty computer science students and

00:05:52,280 --> 00:05:56,960
show them how does TCP work how does the

00:05:55,520 --> 00:05:59,480
file system work how does a memory

00:05:56,960 --> 00:06:01,400
allocation work let's show you what

00:05:59,480 --> 00:06:03,500
happened to the locking things that

00:06:01,400 --> 00:06:05,270
would take you know much longer when

00:06:03,500 --> 00:06:07,580
you're making them write C code from

00:06:05,270 --> 00:06:09,080
scratch now of course we all know that

00:06:07,580 --> 00:06:12,140
forcing the door in C code from scratch

00:06:09,080 --> 00:06:14,570
builds character that's what we're out

00:06:12,140 --> 00:06:15,950
for but we believe that tracing is

00:06:14,570 --> 00:06:17,930
really an excellent way to teach people

00:06:15,950 --> 00:06:20,180
about large complex systems and to give

00:06:17,930 --> 00:06:21,440
them problem-solving techniques to

00:06:20,180 --> 00:06:24,740
understand those systems

00:06:21,440 --> 00:06:27,280
that's another motivation um we want

00:06:24,740 --> 00:06:31,130
dtrace to always be production writing

00:06:27,280 --> 00:06:32,630
sometimes it is mostly it is and we want

00:06:31,130 --> 00:06:36,110
to do it in open source because well

00:06:32,630 --> 00:06:38,630
open source is good okay so that those

00:06:36,110 --> 00:06:41,870
are our motivations for for continuing

00:06:38,630 --> 00:06:45,200
to push the do trace technological this

00:06:41,870 --> 00:06:46,700
is one of my favorite films this is a

00:06:45,200 --> 00:06:48,740
film called Reservoir Dogs

00:06:46,700 --> 00:06:51,830
I have no idea how to translate that

00:06:48,740 --> 00:06:54,710
into French but you don't know again we

00:06:51,830 --> 00:06:56,540
just get to see of Reservoir Dogs with

00:06:54,710 --> 00:07:00,230
my terrible terrible accident

00:06:56,540 --> 00:07:02,960
so another motivation this is a crisis

00:07:00,230 --> 00:07:06,380
meeting and I have been to these

00:07:02,960 --> 00:07:10,120
meetings happily without the guns so

00:07:06,380 --> 00:07:12,980
when people debug real-world problems in

00:07:10,120 --> 00:07:15,440
large data centers or large distributed

00:07:12,980 --> 00:07:19,160
applications usually there are two or

00:07:15,440 --> 00:07:21,380
three interested parties so in this

00:07:19,160 --> 00:07:23,150
particular this is called a Mexican

00:07:21,380 --> 00:07:26,000
standoff by the way and this particular

00:07:23,150 --> 00:07:27,230
Mexican standoff it doesn't matter who

00:07:26,000 --> 00:07:29,510
is who

00:07:27,230 --> 00:07:31,130
but you usually have someone from LAN

00:07:29,510 --> 00:07:32,390
say this guy's from the Systems Group

00:07:31,130 --> 00:07:36,230
name they're the Systems Administrator

00:07:32,390 --> 00:07:39,170
they keep the system running this old

00:07:36,230 --> 00:07:40,670
guy here is a mafia boss in this but

00:07:39,170 --> 00:07:41,610
actually is the network administration

00:07:40,670 --> 00:07:42,870
group they're like

00:07:41,610 --> 00:07:45,990
they keep all the computers connected

00:07:42,870 --> 00:07:49,770
together and then Harvey Keitel's is my

00:07:45,990 --> 00:07:51,060
favorite character in the movie Keys the

00:07:49,770 --> 00:07:52,800
programming group they're the people who

00:07:51,060 --> 00:07:55,560
actually take the programs and run them

00:07:52,800 --> 00:07:58,229
on ministry cluster and what happens is

00:07:55,560 --> 00:08:00,030
usually Harvey over here sends in a bug

00:07:58,229 --> 00:08:02,430
report that says your data center you

00:08:00,030 --> 00:08:04,379
know your massive compute cluster of a

00:08:02,430 --> 00:08:07,379
thousand nodes or five thousand roads is

00:08:04,379 --> 00:08:09,300
slow and then these two guys here go no

00:08:07,379 --> 00:08:11,460
it's not and then they start pointing

00:08:09,300 --> 00:08:13,020
guns at each other and bad things happen

00:08:11,460 --> 00:08:15,509
now you'll notice there's a character

00:08:13,020 --> 00:08:17,039
lying bleeding on the floor down here at

00:08:15,509 --> 00:08:18,810
the bottom right this is the actual

00:08:17,039 --> 00:08:24,840
consumer of the data who just wants an

00:08:18,810 --> 00:08:27,900
answer but he dies first so this kind of

00:08:24,840 --> 00:08:30,449
discussion and this kind of problem

00:08:27,900 --> 00:08:32,640
problem solving by the way the problem

00:08:30,449 --> 00:08:35,789
does get solved at the end it does not

00:08:32,640 --> 00:08:38,669
go well this kind of problem solving is

00:08:35,789 --> 00:08:41,849
really amenable to something like a

00:08:38,669 --> 00:08:44,930
distributive tracing system well not the

00:08:41,849 --> 00:08:48,390
gun part but actually having currently

00:08:44,930 --> 00:08:52,290
what we have in large to certain systems

00:08:48,390 --> 00:08:54,180
are uncorrelated data right so a switch

00:08:52,290 --> 00:08:55,589
generates some type of data which is

00:08:54,180 --> 00:08:57,269
uncorrelated to what you get out of the

00:08:55,589 --> 00:08:58,890
server which is uncorrelated to what you

00:08:57,269 --> 00:09:00,930
get out of a program wouldn't it be

00:08:58,890 --> 00:09:03,420
wonderful wouldn't it be a wonderful

00:09:00,930 --> 00:09:05,310
world if you actually had a system where

00:09:03,420 --> 00:09:07,560
you could trace all of that and

00:09:05,310 --> 00:09:09,449
correlate all of that data together to

00:09:07,560 --> 00:09:11,490
try and form a more coherent picture of

00:09:09,449 --> 00:09:13,019
where the problem is as opposed to

00:09:11,490 --> 00:09:14,880
standing around pointing guns at each

00:09:13,019 --> 00:09:17,610
other and excusing the other one of

00:09:14,880 --> 00:09:20,339
breaking the system um so this is

00:09:17,610 --> 00:09:22,320
actually well I won't say that this

00:09:20,339 --> 00:09:24,269
photo but this idea and having been

00:09:22,320 --> 00:09:27,570
through these kinds of discussions with

00:09:24,269 --> 00:09:29,670
people very loud discussions or one of

00:09:27,570 --> 00:09:32,310
the reasons that I got interested in

00:09:29,670 --> 00:09:35,410
this sort of tracing area

00:09:32,310 --> 00:09:37,240
okay so I keep saying we

00:09:35,410 --> 00:09:38,800
I'll mention the project that we're

00:09:37,240 --> 00:09:41,200
working on at the moment this is cadets

00:09:38,800 --> 00:09:44,860
which is the causal adaptive distributed

00:09:41,200 --> 00:09:48,730
and efficient tracing system the idea

00:09:44,860 --> 00:09:50,350
behind debts is that we can look at all

00:09:48,730 --> 00:09:52,649
of the events we can have a transparency

00:09:50,350 --> 00:09:55,990
into a distributed system to answer

00:09:52,649 --> 00:09:57,730
answer an important question now cadets

00:09:55,990 --> 00:10:00,519
is focused a cadet sees a DARPA program

00:09:57,730 --> 00:10:02,769
so it's focused on security but the

00:10:00,519 --> 00:10:05,649
problem the question we're trying to

00:10:02,769 --> 00:10:07,029
answer when something goes wrong in any

00:10:05,649 --> 00:10:09,519
system but certainly something goes

00:10:07,029 --> 00:10:11,110
wrong in a distributed system is also

00:10:09,519 --> 00:10:13,660
the question the answer to the question

00:10:11,110 --> 00:10:18,100
my mother used to yell at me when I was

00:10:13,660 --> 00:10:21,399
like my brother which is who did what to

00:10:18,100 --> 00:10:23,589
whom and when and that is the the

00:10:21,399 --> 00:10:27,010
question that you wish to answer any

00:10:23,589 --> 00:10:28,779
sort of large distributed system who was

00:10:27,010 --> 00:10:30,670
the actor that caused the thing to

00:10:28,779 --> 00:10:31,060
happen and when did it happen show me

00:10:30,670 --> 00:10:33,700
the order

00:10:31,060 --> 00:10:35,680
so cadets because it was sort of the

00:10:33,700 --> 00:10:38,140
deficient racing system attempts to

00:10:35,680 --> 00:10:40,060
answer that and we're using DTrace and

00:10:38,140 --> 00:10:45,279
that technology is one of the components

00:10:40,060 --> 00:10:47,140
here to try and give more transparency

00:10:45,279 --> 00:10:49,029
into what's going on on a single node

00:10:47,140 --> 00:10:53,649
and eventually what's going on in all of

00:10:49,029 --> 00:10:55,870
the nodes in a distributed system so

00:10:53,649 --> 00:10:57,970
there are two components to this I will

00:10:55,870 --> 00:11:00,220
talk a lot more about DTrace I will not

00:10:57,970 --> 00:11:02,380
talk about so much I will talk about how

00:11:00,220 --> 00:11:04,149
we apply it mostly I'll talk about

00:11:02,380 --> 00:11:06,220
dtrace we'll talk a little bit about

00:11:04,149 --> 00:11:10,089
Loom which is work that's being done

00:11:06,220 --> 00:11:15,040
within LLVM to generate in program or in

00:11:10,089 --> 00:11:17,649
program implementation so let's get all

00:11:15,040 --> 00:11:18,940
that on the screen and so lumen is

00:11:17,649 --> 00:11:21,220
specification driven program

00:11:18,940 --> 00:11:23,740
instrumentation this will result in

00:11:21,220 --> 00:11:26,579
things like that binaries of course

00:11:23,740 --> 00:11:30,279
everything's built on freebsd because

00:11:26,579 --> 00:11:32,279
and then we're using dtrace as our

00:11:30,279 --> 00:11:34,690
tracing framework because in order to

00:11:32,279 --> 00:11:37,150
have this transparency we're going to

00:11:34,690 --> 00:11:40,060
use tracer

00:11:37,150 --> 00:11:43,490
so how do we use these highest Abed soon

00:11:40,060 --> 00:11:45,140
so we used each race on a single node we

00:11:43,490 --> 00:11:48,380
also leverage it for distributed

00:11:45,140 --> 00:11:50,240
distributed instrumentation which means

00:11:48,380 --> 00:11:53,300
we can have a single client that goes

00:11:50,240 --> 00:11:55,670
out to a large set of nodes and tells

00:11:53,300 --> 00:11:58,220
them to all perform certain types of

00:11:55,670 --> 00:12:03,680
tracing and feed that trace those trace

00:11:58,220 --> 00:12:07,460
records back to a central point so this

00:12:03,680 --> 00:12:09,410
has interesting side effects so if you

00:12:07,460 --> 00:12:11,180
want total transparency into the system

00:12:09,410 --> 00:12:14,600
you're not going to use D trace as it

00:12:11,180 --> 00:12:17,300
was perhaps originally envisioned DTrace

00:12:14,600 --> 00:12:19,460
was envisioned as a way of debugging a

00:12:17,300 --> 00:12:20,510
problem at the time I have a problem I'm

00:12:19,460 --> 00:12:22,310
gonna go look into it

00:12:20,510 --> 00:12:24,770
but if you're building a system that's

00:12:22,310 --> 00:12:26,960
trying to build a a set of records that

00:12:24,770 --> 00:12:28,550
gives you total transparency into

00:12:26,960 --> 00:12:31,070
everything going on in the system or a

00:12:28,550 --> 00:12:33,470
distributed system then it's not turn on

00:12:31,070 --> 00:12:36,280
turn off it's always on so in our

00:12:33,470 --> 00:12:39,350
project we call is always on tracing

00:12:36,280 --> 00:12:41,180
there are some side effects to that that

00:12:39,350 --> 00:12:43,040
relate to doing security work which I

00:12:41,180 --> 00:12:45,530
won't go to go into in depth but does

00:12:43,040 --> 00:12:47,870
mean that there are parts of D trace

00:12:45,530 --> 00:12:49,520
that can be used exploited by an

00:12:47,870 --> 00:12:52,610
attacker against us we have to worry

00:12:49,520 --> 00:12:55,430
about that and it also means that this

00:12:52,610 --> 00:12:56,960
is to some extent a novel way to be

00:12:55,430 --> 00:12:58,910
traced people have certainly built full

00:12:56,960 --> 00:13:01,760
telemetry system gandhi's race official

00:12:58,910 --> 00:13:02,930
explodes than that I know that would

00:13:01,760 --> 00:13:05,570
Isilon have done things like that the

00:13:02,930 --> 00:13:07,220
three nice folks do that but they're not

00:13:05,570 --> 00:13:09,770
looking at everything in the system all

00:13:07,220 --> 00:13:12,710
the time they're looking at subsets and

00:13:09,770 --> 00:13:15,110
that is different than trying to trace

00:13:12,710 --> 00:13:17,780
all system calls or all of the

00:13:15,110 --> 00:13:24,280
interactions between programs and

00:13:17,780 --> 00:13:28,670
assurances so that requires okay so

00:13:24,280 --> 00:13:30,890
safety first so one of the things that's

00:13:28,670 --> 00:13:34,100
important to understand about how we use

00:13:30,890 --> 00:13:36,350
D trace and how we would like to improve

00:13:34,100 --> 00:13:38,210
D tracer mundi trace forward you have to

00:13:36,350 --> 00:13:41,660
go back to the D trace design principles

00:13:38,210 --> 00:13:43,280
so when D trace has originally built it

00:13:41,660 --> 00:13:45,920
was built so that it would have no

00:13:43,280 --> 00:13:46,190
overhead when not in use and people seem

00:13:45,920 --> 00:13:49,040
to

00:13:46,190 --> 00:13:51,440
the last part they're like that's

00:13:49,040 --> 00:13:53,030
supposed to be free like at some point

00:13:51,440 --> 00:13:55,190
you have to execute an instruction no

00:13:53,030 --> 00:13:56,960
longer free but the idea is that when

00:13:55,190 --> 00:13:59,150
you ship a binary you should a single

00:13:56,960 --> 00:14:01,100
binary you don't have a debug binary in

00:13:59,150 --> 00:14:03,230
a regular binary type the binary and

00:14:01,100 --> 00:14:05,780
then if you don't turn on tracing then

00:14:03,230 --> 00:14:08,750
the overhead should be zero or very very

00:14:05,780 --> 00:14:10,820
very very small it's that's by the way a

00:14:08,750 --> 00:14:15,020
scientific measure of a very very very

00:14:10,820 --> 00:14:17,570
personal really important don't panic

00:14:15,020 --> 00:14:19,070
the kernel turns out if in front on your

00:14:17,570 --> 00:14:21,290
tracing in the kernel panics people get

00:14:19,070 --> 00:14:23,650
really annoyed it's actually even to

00:14:21,290 --> 00:14:27,500
them in production

00:14:23,650 --> 00:14:29,390
unless their Twitter them to them so and

00:14:27,500 --> 00:14:32,210
yet to check the kernel of all costs

00:14:29,390 --> 00:14:34,700
well this has some side effects on

00:14:32,210 --> 00:14:37,160
things you can and cannot do in DTrace

00:14:34,700 --> 00:14:40,550
which we then have to think about as we

00:14:37,160 --> 00:14:44,810
apply dtrace to our workload or add new

00:14:40,550 --> 00:14:45,980
features because so in particular for

00:14:44,810 --> 00:14:49,580
those of you who have ever programmed in

00:14:45,980 --> 00:14:51,140
dee dee has no loops because you can

00:14:49,580 --> 00:14:52,930
shove a loop in the kernel then it might

00:14:51,140 --> 00:14:57,860
be forever because it turns out turn

00:14:52,930 --> 00:14:59,750
period and so no loops there are no

00:14:57,860 --> 00:15:01,910
basic blocks there are a bunch of things

00:14:59,750 --> 00:15:02,990
that as programmers we kind of expect

00:15:01,910 --> 00:15:05,240
that of the language that don't

00:15:02,990 --> 00:15:07,070
currently exist in dtrace and for the

00:15:05,240 --> 00:15:08,870
most part they don't exist because the

00:15:07,070 --> 00:15:12,290
designers are dtrace for trying to make

00:15:08,870 --> 00:15:14,900
sure that the purp the tracing system

00:15:12,290 --> 00:15:18,650
they added to their kernel to know

00:15:14,900 --> 00:15:22,000
solaris couldn't either accidentally or

00:15:18,650 --> 00:15:24,200
maliciously be used to cause the kernel

00:15:22,000 --> 00:15:25,910
it turns out when the kernel crashes so

00:15:24,200 --> 00:15:28,010
it everybody's programs and people get

00:15:25,910 --> 00:15:31,100
cranky safety first

00:15:28,010 --> 00:15:33,680
i'm so d the scripting languages like c

00:15:31,100 --> 00:15:37,120
but sit the problem is that we need some

00:15:33,680 --> 00:15:37,120
of that safety for possibly wall

00:15:39,149 --> 00:15:44,220
another bit of background about dtrace

00:15:42,480 --> 00:15:46,250
and I figured I put this in here for

00:15:44,220 --> 00:15:50,700
those who actually work with it

00:15:46,250 --> 00:15:53,519
so DTrace is built on or about 2005 it

00:15:50,700 --> 00:15:58,380
was a simpler time with smaller memories

00:15:53,519 --> 00:16:00,990
and slower CPUs this is your

00:15:58,380 --> 00:16:03,680
grandparents computer not really any of

00:16:00,990 --> 00:16:06,089
my grandparents we're not born in 2005

00:16:03,680 --> 00:16:07,980
but I thank you to the wayback machine

00:16:06,089 --> 00:16:09,990
for keeping all of the marketing

00:16:07,980 --> 00:16:11,550
material of every company for the last

00:16:09,990 --> 00:16:13,680
20 years because when I want to talk

00:16:11,550 --> 00:16:15,990
about what a computer was like in 2005 I

00:16:13,680 --> 00:16:19,260
just go to the wayback machine so this

00:16:15,990 --> 00:16:23,100
was if you bought a Sunfire v-8 90

00:16:19,260 --> 00:16:27,630
server in 2005 you could have up to 64

00:16:23,100 --> 00:16:29,880
gigs of memory I think I probably don't

00:16:27,630 --> 00:16:34,649
have that much in my phone but I could

00:16:29,880 --> 00:16:35,880
so not a lot of memory and this was you

00:16:34,649 --> 00:16:38,519
know some hardware was nice

00:16:35,880 --> 00:16:42,990
top-of-the-line high quality stuff if

00:16:38,519 --> 00:16:47,490
you went bought a Super Micro at the

00:16:42,990 --> 00:16:49,079
time you get out up to 16 gigs of 400s

00:16:47,490 --> 00:16:52,800
pentagram I don't know why I just Europe

00:16:49,079 --> 00:16:57,089
and you know not a lot of memory slow

00:16:52,800 --> 00:17:02,490
cards etc 3.6 pr8 hundred megahertz

00:16:57,089 --> 00:17:03,839
front side bus you know now you wouldn't

00:17:02,490 --> 00:17:09,020
even bother putting this in a data

00:17:03,839 --> 00:17:11,640
center right so that means what so

00:17:09,020 --> 00:17:13,770
sometimes when we apply dtrace on a

00:17:11,640 --> 00:17:16,980
running system using the original

00:17:13,770 --> 00:17:18,209
defaults we run out of steam yes - yes

00:17:16,980 --> 00:17:21,150
that train really did go out that

00:17:18,209 --> 00:17:23,790
station so for those of you who use

00:17:21,150 --> 00:17:28,230
dtrace in anger you've seen things like

00:17:23,790 --> 00:17:30,590
this and please don't tell me dtrace is

00:17:28,230 --> 00:17:32,820
broken when that happens some you have

00:17:30,590 --> 00:17:34,950
dtrace is not broken it's actually

00:17:32,820 --> 00:17:37,080
working as it's designed to work

00:17:34,950 --> 00:17:38,040
remember going back a couple of slides

00:17:37,080 --> 00:17:39,990
safety first

00:17:38,040 --> 00:17:41,640
alright if we're going to tell the

00:17:39,990 --> 00:17:43,890
operating system kernel to start

00:17:41,640 --> 00:17:47,130
recording events about everything that's

00:17:43,890 --> 00:17:47,370
going on in the system we are not going

00:17:47,130 --> 00:17:49,230
to

00:17:47,370 --> 00:17:51,930
lock on all other events we're gonna

00:17:49,230 --> 00:17:53,370
have a ring buffer it's a thing

00:17:51,930 --> 00:17:54,750
we're gonna bring buffer or we're gonna

00:17:53,370 --> 00:17:56,220
have some sort of buffering system

00:17:54,750 --> 00:17:59,130
whereby when we get behind we're gonna

00:17:56,220 --> 00:18:00,809
be like okay I'm I can't keep up so

00:17:59,130 --> 00:18:04,110
throw away some records the D trace is

00:18:00,809 --> 00:18:06,120
not broken but it is a bit miss tuned at

00:18:04,110 --> 00:18:08,700
the moment so there are three tuning

00:18:06,120 --> 00:18:11,490
parameters buff size which currently

00:18:08,700 --> 00:18:12,960
defaults to four mags and was were

00:18:11,490 --> 00:18:15,240
reasons that I have never understood

00:18:12,960 --> 00:18:17,970
severely limited on previously but we

00:18:15,240 --> 00:18:20,100
will change that by a tunable and so

00:18:17,970 --> 00:18:22,950
peep if you're having a lot of drops you

00:18:20,100 --> 00:18:24,720
can try increasing that the switch rate

00:18:22,950 --> 00:18:27,390
which says how often we're pulling

00:18:24,720 --> 00:18:29,730
buffers out of the system on which the

00:18:27,390 --> 00:18:31,020
bolts the one parts on which you can

00:18:29,730 --> 00:18:31,350
increase it again if you have a bunch of

00:18:31,020 --> 00:18:37,080
those guys

00:18:31,350 --> 00:18:41,090
and lastly so again DTrace built for

00:18:37,080 --> 00:18:44,490
safety built in 2005 smaller memory time

00:18:41,090 --> 00:18:46,770
there are you know there's two main

00:18:44,490 --> 00:18:48,929
memory sizing things one is buff sized

00:18:46,770 --> 00:18:53,340
the other is the dynamic variable so you

00:18:48,929 --> 00:18:55,110
might see this 103 dynamic variable

00:18:53,340 --> 00:18:57,059
drops with a different than the buffer

00:18:55,110 --> 00:19:00,980
drops so you might want to increase this

00:18:57,059 --> 00:19:00,980
as well and now

00:19:01,650 --> 00:19:06,760
okay so now you might say well you know

00:19:04,540 --> 00:19:10,840
it is 2017 why don't we just make all of

00:19:06,760 --> 00:19:13,660
it bigger well it turns out that dtrace

00:19:10,840 --> 00:19:16,630
especially DTrace on FreeBSD runs on a

00:19:13,660 --> 00:19:18,430
wide variety of platform in fact it runs

00:19:16,630 --> 00:19:19,900
on some embedded platforms as well as

00:19:18,430 --> 00:19:23,520
service so we can't have a

00:19:19,900 --> 00:19:23,520
one-size-fits-all yeah actually

00:19:24,910 --> 00:19:29,560
let's talk about some improvements that

00:19:26,740 --> 00:19:32,230
we've made to DTrace we being the

00:19:29,560 --> 00:19:34,810
connects project so the first one we did

00:19:32,230 --> 00:19:38,260
was machine readable output so each race

00:19:34,810 --> 00:19:41,730
was built that people who loved awk now

00:19:38,260 --> 00:19:45,280
I know we all along I love walking today

00:19:41,730 --> 00:19:48,100
but the output that comes out of this

00:19:45,280 --> 00:19:50,020
race is not easily parsable by program

00:19:48,100 --> 00:19:52,600
and generally it's not meant to be meant

00:19:50,020 --> 00:19:55,030
to be parsed by a human who's looking at

00:19:52,600 --> 00:19:57,940
the console or maybe they build a flame

00:19:55,030 --> 00:19:59,800
graph which we will feel about later but

00:19:57,940 --> 00:20:01,840
it's not really meant to be ingested

00:19:59,800 --> 00:20:04,150
into another program it's meant to be

00:20:01,840 --> 00:20:07,600
sort of read over by so one of the first

00:20:04,150 --> 00:20:10,450
things we added was EXO support so now

00:20:07,600 --> 00:20:12,240
you can have your output in XML and

00:20:10,450 --> 00:20:15,550
you're welcome

00:20:12,240 --> 00:20:17,710
also Jason because we want to be able to

00:20:15,550 --> 00:20:19,810
build tools that consume the data from

00:20:17,710 --> 00:20:21,970
trips

00:20:19,810 --> 00:20:23,380
we've added some new providers the urban

00:20:21,970 --> 00:20:26,950
providers added by other people in the

00:20:23,380 --> 00:20:30,010
community so one in particular is audit

00:20:26,950 --> 00:20:33,520
Mac and Mac framework open crypto known

00:20:30,010 --> 00:20:35,860
as a provider so to justin.tv transport

00:20:33,520 --> 00:20:38,860
protocol of the expedient stuff so as as

00:20:35,860 --> 00:20:40,810
the code has been adapted and adopted by

00:20:38,860 --> 00:20:43,210
the community we've added you know more

00:20:40,810 --> 00:20:45,190
providers and providers are just a way

00:20:43,210 --> 00:20:47,530
of collecting trace points together and

00:20:45,190 --> 00:20:50,140
expressing some form of functionality or

00:20:47,530 --> 00:20:54,160
duplex the other thing we started doing

00:20:50,140 --> 00:20:56,380
is performance analysis now you know

00:20:54,160 --> 00:20:59,170
going back to a much earlier slide

00:20:56,380 --> 00:21:01,060
DTrace is nearly free when it turned off

00:20:59,170 --> 00:21:02,620
and people will then immediately ask

00:21:01,060 --> 00:21:05,200
well how much does it cost to HR on a

00:21:02,620 --> 00:21:07,840
single probe and the answer is we're not

00:21:05,200 --> 00:21:10,660
really sure yet but we have someone

00:21:07,840 --> 00:21:11,950
doing a PhD about that so we're starting

00:21:10,660 --> 00:21:14,070
to do quite a bit of performance

00:21:11,950 --> 00:21:15,760
analysis to see where we can do

00:21:14,070 --> 00:21:18,280
improvements so that when we're doing

00:21:15,760 --> 00:21:20,590
always-on tracing and there's a ton of

00:21:18,280 --> 00:21:23,110
trace point enabled at all times we

00:21:20,590 --> 00:21:25,390
actually don't have a ton of buffer

00:21:23,110 --> 00:21:29,410
drops but for other performance overhead

00:21:25,390 --> 00:21:30,970
cost we're doing that analysis now we

00:21:29,410 --> 00:21:33,490
also started documenting quite a bit of

00:21:30,970 --> 00:21:36,520
the internals so the Solaris looks work

00:21:33,490 --> 00:21:39,690
great code going look the include files

00:21:36,520 --> 00:21:42,160
they have really excellent comments

00:21:39,690 --> 00:21:45,040
which I really appreciate

00:21:42,160 --> 00:21:48,400
but they are not written in a way that

00:21:45,040 --> 00:21:51,580
you could then take a specification and

00:21:48,400 --> 00:21:54,580
for instance with worm implementation or

00:21:51,580 --> 00:21:56,170
you know explained someone simply how

00:21:54,580 --> 00:22:01,030
they would do extensions so we're doing

00:21:56,170 --> 00:22:03,400
that - the comments explain the what

00:22:01,030 --> 00:22:05,820
they explain a little bit of the how but

00:22:03,400 --> 00:22:09,810
none of the wall

00:22:05,820 --> 00:22:11,730
so machine readable output this is a

00:22:09,810 --> 00:22:13,800
simple DTrace one-liner

00:22:11,730 --> 00:22:15,330
and you know you say something like oh

00:22:13,800 --> 00:22:18,360
hey you know tell me want us to spell

00:22:15,330 --> 00:22:22,800
when right fired and bang you get a

00:22:18,360 --> 00:22:25,500
bunch of text output if we tell it we

00:22:22,800 --> 00:22:28,320
want Jason up but we get this we get

00:22:25,500 --> 00:22:30,000
this nice little object that can

00:22:28,320 --> 00:22:33,950
actually be parsed by something that we

00:22:30,000 --> 00:22:33,950
chase up right so you're not so

00:22:34,200 --> 00:22:38,490
people are normal but normal people

00:22:36,270 --> 00:22:42,540
should not read this did you go into a

00:22:38,490 --> 00:22:44,280
tool so the the Jason output gives us

00:22:42,540 --> 00:22:47,130
the ability to do things like give a

00:22:44,280 --> 00:22:48,480
time stamp to every event and you know

00:22:47,130 --> 00:22:49,890
separate and things that happen like

00:22:48,480 --> 00:22:52,799
this is a function that this is was

00:22:49,890 --> 00:22:55,170
named into their separate elements and

00:22:52,799 --> 00:22:56,700
this is done by done automatically so

00:22:55,170 --> 00:23:01,020
instead of having to write a script that

00:22:56,700 --> 00:23:03,059
converts something from text into JSON

00:23:01,020 --> 00:23:06,299
we just spit it out and then we can feed

00:23:03,059 --> 00:23:09,210
this into tools that can do analysis for

00:23:06,299 --> 00:23:11,850
us remember part of our overall goal and

00:23:09,210 --> 00:23:14,520
that's project is to deliver a system

00:23:11,850 --> 00:23:16,590
that can be used by security analysts to

00:23:14,520 --> 00:23:19,799
look at what's going on in a distributed

00:23:16,590 --> 00:23:21,990
system security analysts are not going

00:23:19,799 --> 00:23:24,179
to read this there are 93 tests with a

00:23:21,990 --> 00:23:26,330
build tool data so machine readable

00:23:24,179 --> 00:23:26,330
output

00:23:26,690 --> 00:23:31,309
we've made a few improvements to the D

00:23:29,240 --> 00:23:33,020
language so have the other people

00:23:31,309 --> 00:23:37,280
actually some of them have been imported

00:23:33,020 --> 00:23:38,660
by people in this room so what does GED

00:23:37,280 --> 00:23:42,820
is as you like language with supports

00:23:38,660 --> 00:23:45,970
all the operators feel instructed by God

00:23:42,820 --> 00:23:49,250
has thread and clause local variables

00:23:45,970 --> 00:23:55,039
subroutines to handle common tasks but

00:23:49,250 --> 00:23:56,419
you can't write your own so we've we've

00:23:55,039 --> 00:24:02,000
started doing a series of improvements

00:23:56,419 --> 00:24:05,179
to make Judy do more of what we want one

00:24:02,000 --> 00:24:07,340
of the things we had to add was a way to

00:24:05,179 --> 00:24:09,950
get it amongst so if you're working in a

00:24:07,340 --> 00:24:12,020
distributed system it's fine if you know

00:24:09,950 --> 00:24:14,090
about socket connection you can see to

00:24:12,020 --> 00:24:15,530
city and all that stuff but sometimes

00:24:14,090 --> 00:24:17,630
you want to do packet inspection on

00:24:15,530 --> 00:24:17,960
packets that are coming in or out of the

00:24:17,630 --> 00:24:20,830
system

00:24:17,960 --> 00:24:24,350
and in 3d we FM box was very complicated

00:24:20,830 --> 00:24:27,770
but very useful method of encapsulating

00:24:24,350 --> 00:24:30,530
network clear so this allows us to read

00:24:27,770 --> 00:24:32,539
chained in buffs and be it's really

00:24:30,530 --> 00:24:34,880
important for all the BSD Paria systems

00:24:32,539 --> 00:24:37,940
so for those of you who are attempting

00:24:34,880 --> 00:24:41,510
to move toward each race to the other

00:24:37,940 --> 00:24:42,860
VSDs and at these degrees need you

00:24:41,510 --> 00:24:44,510
probably want something like this

00:24:42,860 --> 00:24:48,340
because it does not exist in the

00:24:44,510 --> 00:24:48,340
original the most / Solaris code

00:24:48,840 --> 00:24:57,870
area and that allows us to do this cute

00:24:52,019 --> 00:24:59,669
little tricky so on TCP input I've got

00:24:57,870 --> 00:25:02,580
an M Bob I happen to know that it's in

00:24:59,669 --> 00:25:05,490
this zeroth argument and it doesn't

00:25:02,580 --> 00:25:09,720
matter if that M bub is locally stored

00:25:05,490 --> 00:25:11,730
or in a cluster the scriptwriter which

00:25:09,720 --> 00:25:14,490
is the person we want to enable with

00:25:11,730 --> 00:25:16,230
this just calls this one routine and

00:25:14,490 --> 00:25:19,679
gets a pointer back and then they get

00:25:16,230 --> 00:25:21,179
this I call this nice output but then

00:25:19,679 --> 00:25:22,320
I'm a colonel programmers on a terrible

00:25:21,179 --> 00:25:24,149
person

00:25:22,320 --> 00:25:25,860
this is the IP packet you can tell by

00:25:24,149 --> 00:25:29,100
the magic for five byte at the beginning

00:25:25,860 --> 00:25:31,950
and so this gives people using FreeBSD

00:25:29,100 --> 00:25:34,049
and other beauties adopt this easy

00:25:31,950 --> 00:25:37,740
access to network public's right we

00:25:34,049 --> 00:25:39,869
needed this so what are some other

00:25:37,740 --> 00:25:43,679
things we'd like to see turns out port

00:25:39,869 --> 00:25:46,909
numbers really like if statements and D

00:25:43,679 --> 00:25:46,909
has this ternary operator

00:25:47,760 --> 00:25:51,600
I usually decide people to tell me what

00:25:50,100 --> 00:25:56,070
this is and some of them email me one

00:25:51,600 --> 00:26:00,120
I'm not going to do that ternary

00:25:56,070 --> 00:26:01,860
operators are fine but they're not great

00:26:00,120 --> 00:26:04,679
so if statements improve readability

00:26:01,860 --> 00:26:06,559
remember we want analysts to use tools

00:26:04,679 --> 00:26:09,330
but we also have to have people to write

00:26:06,559 --> 00:26:10,529
analysis scripts in deep because those G

00:26:09,330 --> 00:26:12,870
scripts going to be distributed to the

00:26:10,529 --> 00:26:18,570
entire cluster or whatever it is and

00:26:12,870 --> 00:26:21,950
we'd like people you know write in

00:26:18,570 --> 00:26:24,090
modern languages to be living right so

00:26:21,950 --> 00:26:26,399
this leras actually I guess this is the

00:26:24,090 --> 00:26:29,700
illumise group did a syntactic sugar

00:26:26,399 --> 00:26:33,419
version of this so if we want of an F

00:26:29,700 --> 00:26:37,289
I'll make it to spill in so this is an

00:26:33,419 --> 00:26:40,080
if block in a D program this is the

00:26:37,289 --> 00:26:42,200
source code and the way this works for

00:26:40,080 --> 00:26:46,169
more breaks

00:26:42,200 --> 00:26:49,559
this reminds who did the work of doing

00:26:46,169 --> 00:26:53,240
the syntactic sugar version so this is

00:26:49,559 --> 00:26:53,240
what happens when you compile this

00:26:54,600 --> 00:26:59,490
yep goes out the bottom of this life on

00:26:56,700 --> 00:27:04,139
purpose so what happens is it actually

00:26:59,490 --> 00:27:05,850
just blows out the script to still have

00:27:04,139 --> 00:27:07,470
a much larger D script that sort of

00:27:05,850 --> 00:27:10,610
encapsulates or if it's not a real

00:27:07,470 --> 00:27:14,800
absolutely it is sufficient for simple

00:27:10,610 --> 00:27:16,720
scripting but it is not what we want one

00:27:14,800 --> 00:27:19,510
but I mentioned other things we added so

00:27:16,720 --> 00:27:22,090
in the connects project we are using

00:27:19,510 --> 00:27:25,420
audit audit subsystem in freebsd to

00:27:22,090 --> 00:27:28,090
audit the system as a product and audit

00:27:25,420 --> 00:27:30,340
provider so this is a subsystem

00:27:28,090 --> 00:27:32,260
providing security related events it was

00:27:30,340 --> 00:27:34,780
originally done for the US government's

00:27:32,260 --> 00:27:36,670
comma criteria security standards it's

00:27:34,780 --> 00:27:38,320
been optional in freebsd since 2000

00:27:36,670 --> 00:27:42,130
Torrance's work done by Robert Watson

00:27:38,320 --> 00:27:43,600
and others so we know what a provider is

00:27:42,130 --> 00:27:46,570
each race code that collects together a

00:27:43,600 --> 00:27:48,970
set of trees points what are the this

00:27:46,570 --> 00:27:53,290
one get us this gives us access to their

00:27:48,970 --> 00:27:56,260
whole audit framework so that means we

00:27:53,290 --> 00:27:59,760
can turn on audit and then we can use D

00:27:56,260 --> 00:28:02,350
to filter the data and get statistics

00:27:59,760 --> 00:28:06,179
which we would have to write special

00:28:02,350 --> 00:28:06,179
programs to get from the audits

00:28:06,440 --> 00:28:13,160
dtrace performance so I talked about

00:28:08,960 --> 00:28:13,700
tuning earlier but tuning only goes so

00:28:13,160 --> 00:28:15,950
far

00:28:13,700 --> 00:28:18,980
there are components of DTrace that are

00:28:15,950 --> 00:28:21,350
not as efficient as they could do so for

00:28:18,980 --> 00:28:24,200
instance the D compiler that takes the

00:28:21,350 --> 00:28:25,700
source code and turns it into your D

00:28:24,200 --> 00:28:30,800
byte code that gets executed in the

00:28:25,700 --> 00:28:32,600
kernel is not optimized I wouldn't call

00:28:30,800 --> 00:28:34,640
it a pessimism compiler because that

00:28:32,600 --> 00:28:37,700
would be unfair but it is definitely not

00:28:34,640 --> 00:28:41,390
an optimizer so the the scripts

00:28:37,700 --> 00:28:43,779
themselves generate bytecode that is not

00:28:41,390 --> 00:28:46,989
as efficient as a possible

00:28:43,779 --> 00:28:48,279
and so the idea is that the idea behind

00:28:46,989 --> 00:28:49,869
each race of course is that it shouldn't

00:28:48,279 --> 00:28:51,369
degrade performance you'd like them to

00:28:49,869 --> 00:28:54,669
not the great performance too badly

00:28:51,369 --> 00:28:57,999
while in use now one of the nice things

00:28:54,669 --> 00:28:59,469
about working on a DARPA project when we

00:28:57,999 --> 00:29:02,259
first started working on it

00:28:59,469 --> 00:29:03,729
I asked as one of the engineering types

00:29:02,259 --> 00:29:05,710
as opposed to a research that like I

00:29:03,729 --> 00:29:07,509
just I do frankly I don't know how the

00:29:05,710 --> 00:29:09,519
research thing works there well how much

00:29:07,509 --> 00:29:11,440
penalty are you willing to pay to get

00:29:09,519 --> 00:29:13,239
transparency in through certain system

00:29:11,440 --> 00:29:16,659
and they said one hundred percent

00:29:13,239 --> 00:29:20,379
overhead would be alright I'm like ok

00:29:16,659 --> 00:29:21,909
give me your money but it's still it's

00:29:20,379 --> 00:29:23,469
still our goal that when you turn on

00:29:21,909 --> 00:29:28,690
each race it doesn't make the system

00:29:23,469 --> 00:29:32,109
very slow so right now when DTrace gets

00:29:28,690 --> 00:29:33,940
behind it drops records the colonel can

00:29:32,109 --> 00:29:35,289
kill the tracing under high loads one of

00:29:33,940 --> 00:29:39,549
the other protections that

00:29:35,289 --> 00:29:41,320
dtrace as against someone asking for too

00:29:39,549 --> 00:29:43,479
much data is that a dtrace sees that

00:29:41,320 --> 00:29:44,950
it's getting behind it'll just kill the

00:29:43,479 --> 00:29:48,309
colonel burn the colonel side we'll just

00:29:44,950 --> 00:29:51,460
building exercise like no no too slow go

00:29:48,309 --> 00:29:53,349
away and then the colonel will and so

00:29:51,460 --> 00:29:55,149
there are some you know what are the

00:29:53,349 --> 00:29:56,799
possible solutions to dealing with this

00:29:55,149 --> 00:29:58,779
if we want to try and get every record

00:29:56,799 --> 00:30:01,539
so if you think about a security

00:29:58,779 --> 00:30:03,759
application of a logging system and a

00:30:01,539 --> 00:30:06,549
security application never want to drop

00:30:03,759 --> 00:30:08,379
a record right but if you never drop a

00:30:06,549 --> 00:30:10,570
record then you will block all forward

00:30:08,379 --> 00:30:14,549
progress on waiting for something to

00:30:10,570 --> 00:30:14,549
happen like lighting the record to exist

00:30:14,789 --> 00:30:19,869
so we can look at things like changing

00:30:17,320 --> 00:30:22,179
online monitoring cycle we can do the

00:30:19,869 --> 00:30:23,710
buffer size is we can improve the

00:30:22,179 --> 00:30:26,469
decompiler which is one of the things

00:30:23,710 --> 00:30:29,339
we're doing now and then we can look at

00:30:26,469 --> 00:30:35,399
the efficiency of the underlying beaker

00:30:29,339 --> 00:30:39,879
both in the kernel and we can get the

00:30:35,399 --> 00:30:42,909
byte codes and we can leverage LLVM this

00:30:39,879 --> 00:30:44,759
is one of the areas in which we're doing

00:30:42,909 --> 00:30:47,649
a lot more research

00:30:44,759 --> 00:30:49,659
Jonathan Anderson is doing this with the

00:30:47,649 --> 00:30:53,109
loom work which was related but not

00:30:49,659 --> 00:30:54,250
currently the same interest work but we

00:30:53,109 --> 00:30:58,000
believe that we can use

00:30:54,250 --> 00:30:59,620
again and apply some of the as compilers

00:30:58,000 --> 00:31:01,410
will get to apply it to some of the

00:30:59,620 --> 00:31:03,750
problems

00:31:01,410 --> 00:31:06,840
so I keep mentioning loom here's a quick

00:31:03,750 --> 00:31:08,490
aside so loom is this is an

00:31:06,840 --> 00:31:11,430
instrumentation framework based on the

00:31:08,490 --> 00:31:14,000
album containing P what it does is it

00:31:11,430 --> 00:31:16,170
puts instrumentation directly into the

00:31:14,000 --> 00:31:20,280
intermediate representation generated by

00:31:16,170 --> 00:31:23,340
all odm the information instrumentation

00:31:20,280 --> 00:31:24,840
is defined in their own policy files the

00:31:23,340 --> 00:31:27,150
instrumentation can be done at any time

00:31:24,840 --> 00:31:28,770
the one guy R is still available so I

00:31:27,150 --> 00:31:31,040
mean ship a binary and AD

00:31:28,770 --> 00:31:35,790
instrumentation later as opposed to

00:31:31,040 --> 00:31:36,960
currently in a dese race context we

00:31:35,790 --> 00:31:38,610
might have to add a statically defined

00:31:36,960 --> 00:31:40,230
trace point to get something or if

00:31:38,610 --> 00:31:41,580
you're using spaces simply being the

00:31:40,230 --> 00:31:47,100
trace of a particular instruction that

00:31:41,580 --> 00:31:48,210
we get the right the idea with one of

00:31:47,100 --> 00:31:50,370
the things we wanted in the bloom is

00:31:48,210 --> 00:31:54,660
actually make it talk to G trace in user

00:31:50,370 --> 00:31:59,580
space so this required another change so

00:31:54,660 --> 00:32:02,340
USD T's work kind of like this we've got

00:31:59,580 --> 00:32:04,920
a provider file we get it included we

00:32:02,340 --> 00:32:06,690
compile that we compile a couple other

00:32:04,920 --> 00:32:10,850
bits and we get this binary that comes

00:32:06,690 --> 00:32:14,010
up with loom unlike with you Justin to

00:32:10,850 --> 00:32:17,240
the fat binary that comes out of the end

00:32:14,010 --> 00:32:17,240
can be instrumented later

00:32:17,710 --> 00:32:30,550
so music GT performance is similar to

00:32:24,430 --> 00:32:32,590
the kernel performance so Napoles so but

00:32:30,550 --> 00:32:34,630
there's some problems with this in terms

00:32:32,590 --> 00:32:37,480
of shipping the code which is why we're

00:32:34,630 --> 00:32:39,840
doing the L the interest that's the D

00:32:37,480 --> 00:32:43,540
trace tool is modifying the final binary

00:32:39,840 --> 00:32:46,030
it doesn't need to set it doesn't leave

00:32:43,540 --> 00:32:50,440
it aside to modify it and he'll doesn't

00:32:46,030 --> 00:32:55,800
play well with me I'm told we locates

00:32:50,440 --> 00:32:58,300
quite a bit of things so we're adding

00:32:55,800 --> 00:33:01,660
this bloom based using land tracing

00:32:58,300 --> 00:33:03,700
where we just take a simple C file we

00:33:01,660 --> 00:33:07,780
use the compiler and generate the fat

00:33:03,700 --> 00:33:09,820
binary and then we ship the app and then

00:33:07,780 --> 00:33:12,610
we can actually have a provider D file

00:33:09,820 --> 00:33:16,930
that can be moved later in the field and

00:33:12,610 --> 00:33:19,290
lume will actually blend together could

00:33:16,930 --> 00:33:19,290
you trace it

00:33:20,019 --> 00:33:26,299
so we're currently working on this we

00:33:24,470 --> 00:33:27,649
have a prototype system called GG probe

00:33:26,299 --> 00:33:32,120
you didn't want to be able with all

00:33:27,649 --> 00:33:33,559
probes from a user space program so we

00:33:32,120 --> 00:33:36,649
had an intern system called that is not

00:33:33,559 --> 00:33:39,549
introduced in school but this is used by

00:33:36,649 --> 00:33:41,539
the Loon system reviewing segmentation

00:33:39,549 --> 00:33:44,379
no change in the binary when they're

00:33:41,539 --> 00:33:44,379
doing some mutation

00:33:46,039 --> 00:33:51,159
so some testing provided interation

00:33:51,230 --> 00:33:56,750
and I get to that slide too soon okay so

00:33:54,880 --> 00:33:59,030
that's kind of what we're doing with

00:33:56,750 --> 00:34:01,720
loom want to know more about Lu I'll

00:33:59,030 --> 00:34:04,880
point you at the work of Brian today and

00:34:01,720 --> 00:34:07,040
Jonathan Anderson and now

00:34:04,880 --> 00:34:12,800
okay I've given away this slide there

00:34:07,040 --> 00:34:16,640
can be only one so I pointed out the

00:34:12,800 --> 00:34:19,010
dese race was not the first and you know

00:34:16,640 --> 00:34:20,870
wasn't even the only dynamic tracing

00:34:19,010 --> 00:34:22,429
system that had ever been built it turns

00:34:20,870 --> 00:34:26,270
out some people on another operating

00:34:22,429 --> 00:34:31,370
system that built a tracing system based

00:34:26,270 --> 00:34:33,470
around the app called EBP F using EBP F

00:34:31,370 --> 00:34:35,210
at the lowest level is like programming

00:34:33,470 --> 00:34:37,850
an assembly language which that is

00:34:35,210 --> 00:34:39,020
crowded like yeah that's fine but for

00:34:37,850 --> 00:34:40,210
everybody else is like why would I do

00:34:39,020 --> 00:34:44,860
that

00:34:40,210 --> 00:34:47,950
but you know things improve over time

00:34:44,860 --> 00:34:52,040
EVP epenow had a DCC see like front-end

00:34:47,950 --> 00:34:54,950
and more interesting to many actually is

00:34:52,040 --> 00:34:57,800
pol I work Gil why work with the Python

00:34:54,950 --> 00:35:03,820
funk so one of the real downsides of

00:34:57,800 --> 00:35:06,650
deep is that you still have to be

00:35:03,820 --> 00:35:10,400
relatively conversant with both the

00:35:06,650 --> 00:35:13,400
kernel and user space to write effective

00:35:10,400 --> 00:35:17,360
big effective these scripts 21 liners as

00:35:13,400 --> 00:35:20,600
those of that and what you would like in

00:35:17,360 --> 00:35:22,190
a trace language is something more like

00:35:20,600 --> 00:35:28,160
the languages people use for stripping

00:35:22,190 --> 00:35:29,810
like Python God did in youth Perl yeah

00:35:28,160 --> 00:35:33,020
I'm gonna get that one in every time I

00:35:29,810 --> 00:35:36,230
give a talk so you want something like

00:35:33,020 --> 00:35:37,850
Python or maybe you'd like Lua but you

00:35:36,230 --> 00:35:40,220
know you want a higher-level language

00:35:37,850 --> 00:35:44,000
that gives you something that's readable

00:35:40,220 --> 00:35:46,220
after 15 minutes so each race now has

00:35:44,000 --> 00:35:48,350
competition from UPF and all of these

00:35:46,220 --> 00:35:51,310
other things BCC aplly which are built

00:35:48,350 --> 00:35:51,310
on top of there

00:35:52,030 --> 00:35:56,250
according to someone who actually is in

00:35:54,280 --> 00:35:58,690
the audience and will be talking later

00:35:56,250 --> 00:36:01,770
eb PF now has feature pirate in two

00:35:58,690 --> 00:36:04,869
pieces so we've got serious competition

00:36:01,770 --> 00:36:09,609
there cannot be on one

00:36:04,869 --> 00:36:12,579
so I mentioned the history of DTrace how

00:36:09,609 --> 00:36:15,519
does geese race get developed and so

00:36:12,579 --> 00:36:19,180
this is the current source flow of how

00:36:15,519 --> 00:36:21,800
code reads between various systems you

00:36:19,180 --> 00:36:26,090
notice there's a Windows port

00:36:21,800 --> 00:36:29,180
I have been running terrifying idea but

00:36:26,090 --> 00:36:32,450
the the main current users and I guess

00:36:29,180 --> 00:36:35,540
I'll have to a WC didn't slide into the

00:36:32,450 --> 00:36:37,970
main current users of each race Mac OS

00:36:35,540 --> 00:36:39,740
and will mostly use these sort of share

00:36:37,970 --> 00:36:41,450
code amongst each other you know the

00:36:39,740 --> 00:36:43,460
original importance here are we contain

00:36:41,450 --> 00:36:44,870
input some stuff Mac OS pulls things

00:36:43,460 --> 00:36:49,100
from us and I think the else get stuff

00:36:44,870 --> 00:36:52,550
from illumos we send patches back there

00:36:49,100 --> 00:36:55,490
is a Linux port it's know whatever don't

00:36:52,550 --> 00:36:58,760
over accepted but I'd like to make

00:36:55,490 --> 00:37:01,640
little sense to do it so that the source

00:36:58,760 --> 00:37:04,130
sort of flows between various projects

00:37:01,640 --> 00:37:08,510
but there's no one project that can

00:37:04,130 --> 00:37:09,980
really be the ultimate upstream most

00:37:08,510 --> 00:37:13,840
people are still looking to Allah most

00:37:09,980 --> 00:37:13,840
video print are three bubbles the yellow

00:37:13,920 --> 00:37:17,360
so what are we going to do next

00:37:19,330 --> 00:37:26,180
so we're proposing to do open de tres I

00:37:23,870 --> 00:37:30,080
will not put the pisode floor on this

00:37:26,180 --> 00:37:31,700
line I'm a new hope so the idea is to

00:37:30,080 --> 00:37:33,500
have a cross platform it's already

00:37:31,700 --> 00:37:36,920
relatively poor affordable we're using

00:37:33,500 --> 00:37:41,810
the same RFQ process that joint and son

00:37:36,920 --> 00:37:44,450
used to do requests for changes it's

00:37:41,810 --> 00:37:46,730
already in an organization and we've

00:37:44,450 --> 00:37:49,310
been this is where we've started to put

00:37:46,730 --> 00:37:51,590
all the stuff that relates only to these

00:37:49,310 --> 00:37:53,150
rates so changes that still need to go

00:37:51,590 --> 00:37:56,690
into freebsd will go under previously

00:37:53,150 --> 00:38:00,470
had over hopefully a short period of

00:37:56,690 --> 00:38:04,100
months there will then be a source base

00:38:00,470 --> 00:38:06,470
and open de três which will be a feature

00:38:04,100 --> 00:38:08,210
parity will have feature parity across

00:38:06,470 --> 00:38:11,540
all of the operating systems and will be

00:38:08,210 --> 00:38:13,790
in portable by and operating system that

00:38:11,540 --> 00:38:16,490
wishes which would be a big and

00:38:13,790 --> 00:38:20,240
interesting job people were acting on

00:38:16,490 --> 00:38:22,490
that chip in part so I mentioned earlier

00:38:20,240 --> 00:38:24,200
the specification so you know I know

00:38:22,490 --> 00:38:25,850
roomful of programmers going around so

00:38:24,200 --> 00:38:27,850
I've got documentation but it turns out

00:38:25,850 --> 00:38:30,890
to be very useful

00:38:27,850 --> 00:38:33,050
so what are we specifying diff dot and

00:38:30,890 --> 00:38:36,320
CTF these are sort of the three major

00:38:33,050 --> 00:38:40,120
components the data structures the

00:38:36,320 --> 00:38:43,060
things that make dtrace go as a system

00:38:40,120 --> 00:38:46,010
we're improving the testing framework

00:38:43,060 --> 00:38:48,890
were supporting an expectation so things

00:38:46,010 --> 00:38:50,000
like legit um that's why we would expect

00:38:48,890 --> 00:38:52,670
and then I can figure out a lot of

00:38:50,000 --> 00:38:55,100
whetted it makes it easier to do feature

00:38:52,670 --> 00:38:56,300
extensions right at the moment someone

00:38:55,100 --> 00:38:57,440
who wants to make an extension go to the

00:38:56,300 --> 00:38:59,360
woods in the source code do you think

00:38:57,440 --> 00:39:01,220
they know what's going on and then they

00:38:59,360 --> 00:39:03,710
add something and maybe it works and

00:39:01,220 --> 00:39:05,540
maybe has a terrible knock-on effect um

00:39:03,710 --> 00:39:07,420
also the last for a clean room

00:39:05,540 --> 00:39:10,640
reimplementation there's at least one

00:39:07,420 --> 00:39:18,440
attempt to remember member cincy apfel's

00:39:10,640 --> 00:39:21,770
with where due to let's call it a

00:39:18,440 --> 00:39:22,640
license allergy people wish to not use

00:39:21,770 --> 00:39:23,749
this video

00:39:22,640 --> 00:39:26,930
they want to have a clean room we're in

00:39:23,749 --> 00:39:29,059
limitations in it so we write the

00:39:26,930 --> 00:39:31,279
specification correctly by reading the

00:39:29,059 --> 00:39:33,529
code and testing a bunch of stuff not

00:39:31,279 --> 00:39:35,299
only do we have a way of communicating

00:39:33,529 --> 00:39:37,369
to people who wish to extend or build on

00:39:35,299 --> 00:39:39,410
these rays how to do it but if people

00:39:37,369 --> 00:39:42,499
want to remain mentally working on my

00:39:39,410 --> 00:39:44,210
thing then they can go so what are some

00:39:42,499 --> 00:39:47,749
of the things we want to do as we move

00:39:44,210 --> 00:39:49,160
into the open be traced ensure you know

00:39:47,749 --> 00:39:52,059
I'd like to have basic Watson if you

00:39:49,160 --> 00:39:54,799
language if we're going to keep D at all

00:39:52,059 --> 00:39:56,900
bounded loops turns out programmers like

00:39:54,799 --> 00:39:57,680
loops but it turns out they're also

00:39:56,900 --> 00:40:01,249
super dangerous

00:39:57,680 --> 00:40:03,380
so bounded leads be nice to be able to

00:40:01,249 --> 00:40:06,140
include 1d script and another have them

00:40:03,380 --> 00:40:10,160
refer to each other in modules we're

00:40:06,140 --> 00:40:12,259
going to improve performance not just

00:40:10,160 --> 00:40:13,999
because the project I'm working on needs

00:40:12,259 --> 00:40:16,460
it for always on tracing but because

00:40:13,999 --> 00:40:21,920
it's a good overall you want to build a

00:40:16,460 --> 00:40:24,769
really impressive telemetry system or

00:40:21,920 --> 00:40:26,569
some sort of storage device or some sort

00:40:24,769 --> 00:40:29,029
of network device you're going to need

00:40:26,569 --> 00:40:31,670
higher performance out of each race so

00:40:29,029 --> 00:40:33,710
that the deeps race the tracing system

00:40:31,670 --> 00:40:36,529
itself isn't stealing all of the cycles

00:40:33,710 --> 00:40:39,349
from the actual competition the group

00:40:36,529 --> 00:40:41,660
test suite really or more tests were

00:40:39,349 --> 00:40:43,660
less ports so one of the interesting

00:40:41,660 --> 00:40:46,700
things about working on the dtrace

00:40:43,660 --> 00:40:49,970
source code it's incredibly well written

00:40:46,700 --> 00:40:53,930
it's portable it's we mean portable to

00:40:49,970 --> 00:40:55,999
two architectures under Solaris now with

00:40:53,930 --> 00:40:58,369
boorda the FreeBSD very clever or in Mac

00:40:55,999 --> 00:41:01,700
OS very clever but we'd like to see more

00:40:58,369 --> 00:41:05,499
or less ports in particular court to our

00:41:01,700 --> 00:41:08,539
towns was an embedded system this plan

00:41:05,499 --> 00:41:10,630
and I think during important Linux will

00:41:08,539 --> 00:41:14,539
be funding into the one level and a few

00:41:10,630 --> 00:41:17,539
more architecture support so again it

00:41:14,539 --> 00:41:19,099
was quite portable to be tuned to types

00:41:17,539 --> 00:41:22,249
of systems and son sold at the time

00:41:19,099 --> 00:41:25,029
which was in challenge Park Sunday I

00:41:22,249 --> 00:41:27,769
will pull spark out of the FreeBSD tree

00:41:25,029 --> 00:41:29,150
but we would like to know on the

00:41:27,769 --> 00:41:29,739
previous east side we've already ported

00:41:29,150 --> 00:41:32,260
it to

00:41:29,739 --> 00:41:37,490
PowerPC on the

00:41:32,260 --> 00:41:40,280
3232 arms before and mips64 and we want

00:41:37,490 --> 00:41:42,290
to end with five work done by wrestling

00:41:40,280 --> 00:41:43,910
so we want to make sure that that

00:41:42,290 --> 00:41:45,980
architecture support continues and that

00:41:43,910 --> 00:41:49,850
the system didn't support you no more

00:41:45,980 --> 00:41:53,780
architecture than a finer grain

00:41:49,850 --> 00:41:58,250
libraries so it's quite possible that we

00:41:53,780 --> 00:41:59,900
will tear up live DTrace into components

00:41:58,250 --> 00:42:03,470
that make it easier to put it into

00:41:59,900 --> 00:42:06,290
programmable that way I can have my PL y

00:42:03,470 --> 00:42:07,430
like Python that talks to G trace

00:42:06,290 --> 00:42:11,210
instead of having to write my scripts

00:42:07,430 --> 00:42:12,830
and do and we want it to be their goal

00:42:11,210 --> 00:42:14,510
of finding name libraries and Z's will

00:42:12,830 --> 00:42:18,080
come other language so be great if I

00:42:14,510 --> 00:42:26,780
could write rust but you know address to

00:42:18,080 --> 00:42:28,960
talk to D trace or - or go and fight on

00:42:26,780 --> 00:42:28,960
less

00:42:30,420 --> 00:42:37,480
absolutely other nations in the wrong

00:42:34,660 --> 00:42:39,340
direction so when we talk about multiple

00:42:37,480 --> 00:42:40,540
architect and multiple systems and the

00:42:39,340 --> 00:42:45,760
kinds of things we're going to have to

00:42:40,540 --> 00:42:47,950
do to keep each race working so in son

00:42:45,760 --> 00:42:50,530
world and if you go back and look at

00:42:47,950 --> 00:42:52,450
that quite a trip down memory lane to

00:42:50,530 --> 00:42:54,040
look at the wayback machine eunice you

00:42:52,450 --> 00:42:57,070
know what could I buy from the Sun in

00:42:54,040 --> 00:42:59,740
2005 actually I couldn't buy anything

00:42:57,070 --> 00:43:04,180
from 2005 everything was super expensive

00:42:59,740 --> 00:43:05,680
but opened each race because it's going

00:43:04,180 --> 00:43:07,840
to run on mobile art architecture the

00:43:05,680 --> 00:43:09,550
mobile system is going to run across the

00:43:07,840 --> 00:43:12,130
spectrum of machines and it currently

00:43:09,550 --> 00:43:14,080
runs on all three of these as far as you

00:43:12,130 --> 00:43:16,420
know there's a BeagleBone that blackness

00:43:14,080 --> 00:43:18,910
is weather lots and cheetahs on this is

00:43:16,420 --> 00:43:21,730
the ps4 this is the machine that happens

00:43:18,910 --> 00:43:24,840
you have on the destined target so um

00:43:21,730 --> 00:43:24,840
there you go

00:43:25,900 --> 00:43:29,740
so these open these reasons to be able

00:43:28,270 --> 00:43:31,420
to run on a spectrum machines small

00:43:29,740 --> 00:43:35,260
memory to large room from low-power

00:43:31,420 --> 00:43:38,830
processes the high power processors to

00:43:35,260 --> 00:43:41,380
that rights are our goal with the

00:43:38,830 --> 00:43:43,600
serpentines racing to be able to run the

00:43:41,380 --> 00:43:46,390
same descriptive you one always mama to

00:43:43,600 --> 00:43:49,020
across album in those days I didn't

00:43:46,390 --> 00:43:49,020
count on was the

00:43:50,000 --> 00:43:57,090
how do we see dtrace open DTrace being

00:43:53,850 --> 00:43:58,170
used we expect there to be more kernel

00:43:57,090 --> 00:44:00,570
space points because a lot of

00:43:58,170 --> 00:44:02,640
programmers work on it instead things

00:44:00,570 --> 00:44:06,000
like it's a networking players can

00:44:02,640 --> 00:44:10,890
probably have some more GM and kam trace

00:44:06,000 --> 00:44:12,750
points more drivers there are 75

00:44:10,890 --> 00:44:14,520
different sets of debug macaron

00:44:12,750 --> 00:44:16,200
differently from kernel and 10,000

00:44:14,520 --> 00:44:18,150
faulty device printf and or device

00:44:16,200 --> 00:44:21,480
drivers I would like all the device

00:44:18,150 --> 00:44:24,200
print destined die in a fire so my goal

00:44:21,480 --> 00:44:26,850
is to get things like DJ's to request

00:44:24,200 --> 00:44:29,100
more user space tool so we talked about

00:44:26,850 --> 00:44:32,540
in commutable output I'd like to see

00:44:29,100 --> 00:44:35,520
fool like Jeff Roberson skin-graft

00:44:32,540 --> 00:44:37,380
modernized in wins dtrace to pull

00:44:35,520 --> 00:44:41,010
locking information and scheduler

00:44:37,380 --> 00:44:42,210
information into flame graft or simply

00:44:41,010 --> 00:44:42,600
looks more like a software so that's

00:44:42,210 --> 00:44:46,170
good

00:44:42,600 --> 00:44:48,900
good grab lock grapple looking to

00:44:46,170 --> 00:44:50,130
performative clips with plain graphs are

00:44:48,900 --> 00:44:54,930
all the rage so we're going to plane

00:44:50,130 --> 00:44:57,120
graph all the things and then our goal

00:44:54,930 --> 00:44:58,890
is to have a development model where we

00:44:57,120 --> 00:45:03,540
can have a single upstream similar to

00:44:58,890 --> 00:45:05,760
open benefit and where it is milking

00:45:03,540 --> 00:45:10,100
dtrace and then we can share everything

00:45:05,760 --> 00:45:10,100
amongst all of the operating system

00:45:12,770 --> 00:45:18,660
Linux windows

00:45:16,050 --> 00:45:23,210
I'm not

00:45:18,660 --> 00:45:23,210
all right and questions

00:45:30,400 --> 00:45:32,460
you

00:45:33,590 --> 00:45:43,790
no questions okay so thank you right

00:45:39,290 --> 00:45:43,790

YouTube URL: https://www.youtube.com/watch?v=j_TVpq8S2Io


