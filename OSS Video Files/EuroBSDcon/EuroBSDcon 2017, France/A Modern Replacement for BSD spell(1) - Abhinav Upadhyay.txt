Title: A Modern Replacement for BSD spell(1) - Abhinav Upadhyay
Publication date: 2019-10-15
Playlist: EuroBSDcon 2017, France
Description: 
	Description:

The spell(1) utility in NetBSD is quite ancient and primitive. It is several
decades old based on an implementation which came with AT&T Version 7 Unix 1975.
It falls short of expectations on multiple fronts. For instance, it is not
capable of suggesting corrections for the misspelled words, it merely checks a
dictionary to decide if a spelling is correct or not. Not only that, it does
spell checking based on a set of rules, which are pretty tightly
tied to the English language, making it unusable for text involving
other languages. Also, those rules are not very accurate and are prone
to failure in case of many common misspellings.
Because of so many glaring problems in the existing spell(1) and for the lack
of a reusable library interface for other applications to add spell checking
functionality, I started work on writing a new implementation of spell(1)
with the goal of overcoming these problems and also building a library
to add spell checking feature to apropos(1) in NetBSD.

In this presentation I will talk about:

- current implementation of spell(1) and demonstrate its short comings
spell correction algorithms – Levenshtein distance, metaphone and n-grams
work done to implement these techniques resulting in a new spell(1) with a
library interface
- performance comparison of the new implementation against against one of the
most popular open source spell checker – GNU Aspell
- Demonstrate integration of the library interface with other applications such
as apropos(1) and sh(1) to do spell correction and context sensitive text
auto-completion

Speaker biography:

Abhinav Upadhyay is a NetBSD developer and works for Reve Marketing,
a martech startup of Pramati Technologies, as a Senior Software Engineer.
Abhinav first worked for The NetBSD Foundation during Google Summer of Code 2011.
He is responsible for rewriting apropos(1) in NetBSD, implementing full text
search for man pages. He has also created man-k.org – a web interface to
NetBSD’s apropos(1). His interests lie in the areas of systems software
and machine learning. He enjoys working in the cross section of the two domains
to build novel tools and interface.
Captions: 
	00:00:00,089 --> 00:00:07,170
Thank You York for the introduction and

00:00:03,350 --> 00:00:08,550
thanks to everyone for coming here for

00:00:07,170 --> 00:00:13,710
the first talk in the morning

00:00:08,550 --> 00:00:15,780
so so I will be talking about a new

00:00:13,710 --> 00:00:19,340
implementation for the spell utility

00:00:15,780 --> 00:00:24,869
that I have been working on for about

00:00:19,340 --> 00:00:28,710
one year so a bit of an introduction

00:00:24,869 --> 00:00:30,720
about myself as York said I work about

00:00:28,710 --> 00:00:35,130
five years back for net BST in the

00:00:30,720 --> 00:00:36,420
google Summer of Code program and so I

00:00:35,130 --> 00:00:40,170
worked on writing a new implementation

00:00:36,420 --> 00:00:45,510
of the aPOPO utility which had full-text

00:00:40,170 --> 00:00:48,510
search feature and and I got the net BST

00:00:45,510 --> 00:00:52,050
commit bit about last one one year back

00:00:48,510 --> 00:00:55,309
and so this project started about at the

00:00:52,050 --> 00:00:58,920
same time so I'll be talking about this

00:00:55,309 --> 00:01:00,629
so these are the five major topics I

00:00:58,920 --> 00:01:03,140
would like to cover today so I'll

00:01:00,629 --> 00:01:07,110
briefly talk about what are the

00:01:03,140 --> 00:01:09,630
shortcomings in the current spell

00:01:07,110 --> 00:01:13,290
implementation that is there in the bsts

00:01:09,630 --> 00:01:15,509
so from now onwards I would like to call

00:01:13,290 --> 00:01:17,159
this the old spell implementation and

00:01:15,509 --> 00:01:20,520
what I have been working on I will call

00:01:17,159 --> 00:01:22,619
that as a new implementation so based on

00:01:20,520 --> 00:01:24,750
the shortcomings I have come up with the

00:01:22,619 --> 00:01:26,189
set of features or requirements for that

00:01:24,750 --> 00:01:29,759
a modern spell implementation should

00:01:26,189 --> 00:01:32,250
have I'll talk about the some

00:01:29,759 --> 00:01:34,619
implementation details that I have done

00:01:32,250 --> 00:01:37,619
in this project I will compare the

00:01:34,619 --> 00:01:40,229
performance of some of the major spell

00:01:37,619 --> 00:01:42,210
implementations and with the this

00:01:40,229 --> 00:01:45,299
implementation and I'll show one small

00:01:42,210 --> 00:01:47,430
demo of integration with other shell

00:01:45,299 --> 00:01:54,570
utilities of how to use spells spell

00:01:47,430 --> 00:01:56,280
check so this idea of a new spell

00:01:54,570 --> 00:01:58,350
checker came to me when I was working on

00:01:56,280 --> 00:02:01,560
the google Summer of Code project about

00:01:58,350 --> 00:02:03,390
five years back but at that time I

00:02:01,560 --> 00:02:05,399
realized that writing a spell checker is

00:02:03,390 --> 00:02:08,190
not trivial and I could not do it in the

00:02:05,399 --> 00:02:10,229
Summer of Code and I dropped the idea at

00:02:08,190 --> 00:02:13,860
that point of time and about two or

00:02:10,229 --> 00:02:17,280
three years back David Holland decided

00:02:13,860 --> 00:02:20,190
a bug that we should just remove the

00:02:17,280 --> 00:02:22,110
spell utility from NetBSD because it

00:02:20,190 --> 00:02:25,710
just doesn't work so he gave cited

00:02:22,110 --> 00:02:28,410
several examples of some invalid

00:02:25,710 --> 00:02:32,000
Spelling's and spell will just never

00:02:28,410 --> 00:02:35,670
complain that those are incorrect words

00:02:32,000 --> 00:02:37,200
so at that point of time I volunteered

00:02:35,670 --> 00:02:39,420
that and I said that I would like to

00:02:37,200 --> 00:02:45,020
work on this and I finally got around

00:02:39,420 --> 00:02:47,400
and started working on this last year so

00:02:45,020 --> 00:02:50,580
I'll talk about some of the shortcomings

00:02:47,400 --> 00:02:55,110
that spell has so it's a very old

00:02:50,580 --> 00:02:59,459
implementation as per Wikipedia it was

00:02:55,110 --> 00:03:03,300
created around UNIX version 7 from AT&T

00:02:59,459 --> 00:03:05,220
so Douglas macro I created this

00:03:03,300 --> 00:03:12,140
implementation spell he's also credited

00:03:05,220 --> 00:03:15,150
with creation of I think diff salt TR

00:03:12,140 --> 00:03:18,090
join and some of those utilities he also

00:03:15,150 --> 00:03:19,500
created this spell implementation so the

00:03:18,090 --> 00:03:23,190
problem with this implementation is that

00:03:19,500 --> 00:03:25,230
it uses to decide whether a word is a

00:03:23,190 --> 00:03:28,590
correctly spelling or not it uses a set

00:03:25,230 --> 00:03:33,660
of rules called inflection rules so

00:03:28,590 --> 00:03:35,850
essentially these rules are so when

00:03:33,660 --> 00:03:37,709
looking at it at a word if it it will

00:03:35,850 --> 00:03:39,959
first check whether this would exist as

00:03:37,709 --> 00:03:43,769
it is in the dictionary or not if it

00:03:39,959 --> 00:03:46,380
doesn't then it will it has a list of

00:03:43,769 --> 00:03:48,480
prefixes and suffixes so it will remove

00:03:46,380 --> 00:03:50,850
if it it will check that whether this

00:03:48,480 --> 00:03:52,830
word consists of any of these prefixes

00:03:50,850 --> 00:03:55,200
or not if it does it will remove all

00:03:52,830 --> 00:03:57,989
those prefixes similarly it will check

00:03:55,200 --> 00:04:00,299
for all the suffixes if it has any

00:03:57,989 --> 00:04:02,700
suffixes it will remove those and

00:04:00,299 --> 00:04:03,900
finally whatever is left it will check

00:04:02,700 --> 00:04:08,930
whether that word is in the dictionary

00:04:03,900 --> 00:04:12,480
or not so as it happens if you saw that

00:04:08,930 --> 00:04:15,360
so these are all popular suffix s so

00:04:12,480 --> 00:04:18,030
fragment frog mental frog good if you

00:04:15,360 --> 00:04:19,470
add any suffix to a word spell you'll

00:04:18,030 --> 00:04:21,570
think it's valid but because if you

00:04:19,470 --> 00:04:27,510
remove the suffix whatever remains is

00:04:21,570 --> 00:04:27,860
also a valid word so while it's a handy

00:04:27,510 --> 00:04:38,120
trick

00:04:27,860 --> 00:04:39,949
do but it's quite inaccurate and another

00:04:38,120 --> 00:04:42,259
major drawback is that all these rules

00:04:39,949 --> 00:04:45,080
are restrictive applied to the English

00:04:42,259 --> 00:04:47,240
language so you probably will not have

00:04:45,080 --> 00:04:50,780
all these prefixes and suffixes being

00:04:47,240 --> 00:04:52,280
useful in other languages so if you want

00:04:50,780 --> 00:04:54,620
to use the same spell implementation

00:04:52,280 --> 00:04:56,389
with a different dictionary it will

00:04:54,620 --> 00:05:02,810
probably not work unless the languages

00:04:56,389 --> 00:05:05,060
English or English like and another

00:05:02,810 --> 00:05:07,190
drawback that I consider missing feature

00:05:05,060 --> 00:05:08,569
is that it does not give spelling

00:05:07,190 --> 00:05:10,759
correction so it just checks whether

00:05:08,569 --> 00:05:12,530
this is a correct of it or not but it

00:05:10,759 --> 00:05:17,389
will not say what should be the correct

00:05:12,530 --> 00:05:19,099
spelling and finally it lacks a library

00:05:17,389 --> 00:05:20,599
interface so for example when I was

00:05:19,099 --> 00:05:23,060
working on a proponent I wanted to

00:05:20,599 --> 00:05:26,479
integrate a spell checking functionality

00:05:23,060 --> 00:05:27,949
but even though there is a spell checker

00:05:26,479 --> 00:05:29,750
I could not use it because it doesn't

00:05:27,949 --> 00:05:32,900
have any library interface that I could

00:05:29,750 --> 00:05:34,729
just call some api's and do it so I

00:05:32,900 --> 00:05:39,979
would have to end up implementing the

00:05:34,729 --> 00:05:43,099
whole spell checking interface myself so

00:05:39,979 --> 00:05:47,050
based on these shortcomings I have come

00:05:43,099 --> 00:05:49,849
up with these set of requirements so

00:05:47,050 --> 00:05:51,740
just apart from doing a spell check it

00:05:49,849 --> 00:05:53,719
should also do spelling suggestions so

00:05:51,740 --> 00:05:55,639
it should come up with some possible

00:05:53,719 --> 00:06:01,159
correct spellings for the misspelled

00:05:55,639 --> 00:06:02,599
word it should also use algorithms which

00:06:01,159 --> 00:06:03,199
are not strictly tied to the English

00:06:02,599 --> 00:06:05,560
language

00:06:03,199 --> 00:06:08,919
so for example those inflection rules

00:06:05,560 --> 00:06:12,069
will not work with other languages so if

00:06:08,919 --> 00:06:15,020
if we can come up with algorithms which

00:06:12,069 --> 00:06:16,759
don't use such kind of rules that will

00:06:15,020 --> 00:06:18,080
be good so we can use the same

00:06:16,759 --> 00:06:22,849
implementation with a different language

00:06:18,080 --> 00:06:24,229
dictionary and it should work and it

00:06:22,849 --> 00:06:26,479
would also be nice to have a library

00:06:24,229 --> 00:06:29,870
interface so other applications for

00:06:26,479 --> 00:06:32,419
example the shell apropos or similar

00:06:29,870 --> 00:06:37,490
applications could also easily hook up

00:06:32,419 --> 00:06:41,009
and do spell checks so as part of this

00:06:37,490 --> 00:06:45,869
project these are the four

00:06:41,009 --> 00:06:47,490
major things that I have done so I've

00:06:45,869 --> 00:06:49,800
created a bigger dictionary because the

00:06:47,490 --> 00:06:52,860
existing dictionary that is there in net

00:06:49,800 --> 00:06:56,279
VST that is user share dict words it's

00:06:52,860 --> 00:07:00,899
it doesn't have all the words so I work

00:06:56,279 --> 00:07:03,089
going expanding it and then I worked on

00:07:00,899 --> 00:07:05,639
writing a new spell implementation using

00:07:03,089 --> 00:07:09,050
some of these algorithms the Edit

00:07:05,639 --> 00:07:11,249
distance double met upon and not rise I

00:07:09,050 --> 00:07:13,949
compared the performance against some of

00:07:11,249 --> 00:07:16,589
the other open source spell

00:07:13,949 --> 00:07:20,279
implementation such as a spell I spell

00:07:16,589 --> 00:07:22,499
infants spell and I also tried to

00:07:20,279 --> 00:07:25,589
integrate with other for example with

00:07:22,499 --> 00:07:32,999
with the shell to see how easy it is to

00:07:25,589 --> 00:07:35,969
integrate so the existing dictionary

00:07:32,999 --> 00:07:39,199
that is there in the BST is that is the

00:07:35,969 --> 00:07:42,990
user sheer decked words it is the

00:07:39,199 --> 00:07:45,919
Merriam Webster's dictionary but the

00:07:42,990 --> 00:07:48,569
problem is that it does not have all the

00:07:45,919 --> 00:07:51,949
word form so for example if there is a

00:07:48,569 --> 00:07:54,389
verb it will not have its its past and

00:07:51,949 --> 00:07:57,499
other work forms or if there is a noun

00:07:54,389 --> 00:08:01,110
it will not have the plural forms so

00:07:57,499 --> 00:08:03,599
that's why the holy spell implementation

00:08:01,110 --> 00:08:05,219
use those rules because it could use

00:08:03,599 --> 00:08:07,349
those rules and even though dictionary

00:08:05,219 --> 00:08:09,029
doesn't have all those possible words it

00:08:07,349 --> 00:08:10,620
can remove the prefixes and suffixes and

00:08:09,029 --> 00:08:12,809
it can still figure out if it is a

00:08:10,620 --> 00:08:14,309
correct spelling or not but if you want

00:08:12,809 --> 00:08:16,229
to get rid of those rules we need to

00:08:14,309 --> 00:08:20,939
have the full dictionary with all the

00:08:16,229 --> 00:08:24,089
possible word forms so I expanded the

00:08:20,939 --> 00:08:26,490
dictionary and so this is the difference

00:08:24,089 --> 00:08:28,499
that I have currently so the old

00:08:26,490 --> 00:08:30,149
dictionary had around two hundred thirty

00:08:28,499 --> 00:08:33,860
five thousand words and the size was

00:08:30,149 --> 00:08:36,000
about two point five megabytes and the

00:08:33,860 --> 00:08:37,349
expanded dictionary has around four

00:08:36,000 --> 00:08:38,969
hundred twenty-one thousand words and

00:08:37,349 --> 00:08:45,510
the size is around four point five

00:08:38,969 --> 00:08:49,139
megabytes now are talking about the

00:08:45,510 --> 00:08:51,060
spell checking issue so when we want to

00:08:49,139 --> 00:08:53,730
do spell checking there are two major

00:08:51,060 --> 00:08:54,660
kinds of spell checking errors that can

00:08:53,730 --> 00:08:57,660
be made

00:08:54,660 --> 00:09:01,560
so one is a non-word error so for

00:08:57,660 --> 00:09:04,769
example if you if you misspell applied

00:09:01,560 --> 00:09:06,990
as Apple so if you mean if you miss the

00:09:04,769 --> 00:09:09,660
eye then it becomes Apple and Apple is

00:09:06,990 --> 00:09:12,120
not a dictionary word so that is not a

00:09:09,660 --> 00:09:15,360
real word so it's a non word error we

00:09:12,120 --> 00:09:17,160
can easily figure this out and then

00:09:15,360 --> 00:09:20,190
there are real word errors so for

00:09:17,160 --> 00:09:22,589
example if you want to spell desert but

00:09:20,190 --> 00:09:24,959
if you add an extra s and becomes again

00:09:22,589 --> 00:09:26,009
desert but that's also a word if you

00:09:24,959 --> 00:09:28,889
want to write there

00:09:26,009 --> 00:09:30,839
but you exchange are any it becomes

00:09:28,889 --> 00:09:33,750
three that is also word if you want to

00:09:30,839 --> 00:09:36,209
write peace you use a different spelling

00:09:33,750 --> 00:09:40,709
that is also a word these are much

00:09:36,209 --> 00:09:44,310
harder to figure out so how do we handle

00:09:40,709 --> 00:09:46,440
real murderers it's a much harder

00:09:44,310 --> 00:09:49,589
problem the weak because all of these

00:09:46,440 --> 00:09:50,970
are actual real real word words so we

00:09:49,589 --> 00:09:55,319
can't just look up the dictionary and

00:09:50,970 --> 00:09:58,319
say this is not a correct spelling so we

00:09:55,319 --> 00:10:00,029
can use diagrams or trigrams to figure

00:09:58,319 --> 00:10:02,490
out based on the surrounding context

00:10:00,029 --> 00:10:05,699
like for example if the word is I'll be

00:10:02,490 --> 00:10:09,660
there as soon as possible but okay

00:10:05,699 --> 00:10:12,389
Sunnis misspelled but and now there are

00:10:09,660 --> 00:10:16,170
two possible corrections to that surname

00:10:12,389 --> 00:10:19,589
soon but based on the pattern we know

00:10:16,170 --> 00:10:20,579
that as soon is much more likely to be

00:10:19,589 --> 00:10:24,540
there as compared to

00:10:20,579 --> 00:10:26,790
Assin so based on that based on these

00:10:24,540 --> 00:10:28,649
kind of heuristics we can figure out

00:10:26,790 --> 00:10:30,180
okay this is not a correctly spelled

00:10:28,649 --> 00:10:33,449
word and we should replace it with this

00:10:30,180 --> 00:10:36,060
word but this is much expensive to do

00:10:33,449 --> 00:10:39,180
because if you want to do this you have

00:10:36,060 --> 00:10:43,339
to scan the every word because you

00:10:39,180 --> 00:10:43,339
cannot just say you cannot depend on

00:10:44,480 --> 00:10:49,769
just doing a dictionary lookup you have

00:10:46,709 --> 00:10:52,949
to scan every consecutive pair of words

00:10:49,769 --> 00:10:57,930
in the file and check if this is a

00:10:52,949 --> 00:11:00,420
likely diagram or not so this is a much

00:10:57,930 --> 00:11:02,250
harder problem and it has a performance

00:11:00,420 --> 00:11:05,550
impact so I did not work on this during

00:11:02,250 --> 00:11:08,010
this project but I have worked on

00:11:05,550 --> 00:11:11,610
handling the non word problem which is a

00:11:08,010 --> 00:11:14,370
a simpler problem to start with so these

00:11:11,610 --> 00:11:15,690
are much simpler to detect you just can

00:11:14,370 --> 00:11:17,100
through all the words in the file and

00:11:15,690 --> 00:11:18,600
you check the dictionary if it is not

00:11:17,100 --> 00:11:22,650
there in the diction it is most probably

00:11:18,600 --> 00:11:25,140
a spelling error and if you use an

00:11:22,650 --> 00:11:33,330
expanded dictionary we don't need those

00:11:25,140 --> 00:11:36,120
inflection rules so how do we represent

00:11:33,330 --> 00:11:38,820
a dictionary in the memory so the oldest

00:11:36,120 --> 00:11:43,020
spell implementation used nice trick so

00:11:38,820 --> 00:11:45,360
it used to a map the whole file whole

00:11:43,020 --> 00:11:48,690
whole dictionary into the memory and it

00:11:45,360 --> 00:11:50,310
would do a binary search so it was just

00:11:48,690 --> 00:11:53,010
whatever word is there it will do a

00:11:50,310 --> 00:11:56,250
binary search and figure out if it is

00:11:53,010 --> 00:11:59,550
there in the file or not although it

00:11:56,250 --> 00:12:03,390
works and it's quite it doesn't require

00:11:59,550 --> 00:12:08,330
a lot of memory but I believe I did not

00:12:03,390 --> 00:12:08,330
use this so my first instinct was that

00:12:08,390 --> 00:12:14,970
if I if I want to expose this as a

00:12:11,820 --> 00:12:18,350
library interface and if an application

00:12:14,970 --> 00:12:21,030
wants to do a lot of spell checks then

00:12:18,350 --> 00:12:28,620
going through a file like that memory

00:12:21,030 --> 00:12:30,600
map file might not be a good thing to do

00:12:28,620 --> 00:12:33,690
so I decided to read the whole

00:12:30,600 --> 00:12:36,330
dictionary into the memory although I

00:12:33,690 --> 00:12:38,760
have not compared a performance of a map

00:12:36,330 --> 00:12:41,850
version versus reading the whole diction

00:12:38,760 --> 00:12:46,200
into the memory but I have tried some of

00:12:41,850 --> 00:12:47,820
these things so we need a fast lookup

00:12:46,200 --> 00:12:50,190
data structure to represent this

00:12:47,820 --> 00:12:52,650
dictionary into the memory so we could

00:12:50,190 --> 00:12:54,450
use a hash table but it does not

00:12:52,650 --> 00:12:58,380
guarantee a worst-case performance so if

00:12:54,450 --> 00:13:00,330
the dictionary issue is huge it might

00:12:58,380 --> 00:13:04,280
have performance impact so even though

00:13:00,330 --> 00:13:06,390
in normally our hash table guarantees

00:13:04,280 --> 00:13:12,120
open performance but in the worst case

00:13:06,390 --> 00:13:14,190
it might just become linear but we could

00:13:12,120 --> 00:13:18,750
use red black tree also which guarantees

00:13:14,190 --> 00:13:21,520
order login performance but so if you

00:13:18,750 --> 00:13:23,230
have a huge dictionary and you want to

00:13:21,520 --> 00:13:25,440
see whether a word is in the dictionary

00:13:23,230 --> 00:13:28,990
or not and you have it represented as

00:13:25,440 --> 00:13:31,410
our bee tree you have to do string

00:13:28,990 --> 00:13:34,630
comparisons it at every node in the tree

00:13:31,410 --> 00:13:37,990
you'll end up doing a lot of string

00:13:34,630 --> 00:13:41,650
comparisons tries are a specialized data

00:13:37,990 --> 00:13:43,660
structure which avoid this problem with

00:13:41,650 --> 00:13:45,460
doing that many string comparisons these

00:13:43,660 --> 00:13:48,400
are like binary search trees but every

00:13:45,460 --> 00:13:50,200
node has a single character and you just

00:13:48,400 --> 00:13:52,960
traverse the tree based on matching the

00:13:50,200 --> 00:14:01,390
characters so you don't end up calling

00:13:52,960 --> 00:14:04,900
strcmp a lot of times so these I've used

00:14:01,390 --> 00:14:06,990
these ternary search tries so these are

00:14:04,900 --> 00:14:11,650
much like a binary search tree but

00:14:06,990 --> 00:14:14,520
instead of having two nodes every it has

00:14:11,650 --> 00:14:18,670
at every level it has three nodes and

00:14:14,520 --> 00:14:22,510
every node stores one character of the

00:14:18,670 --> 00:14:24,310
world and in the next node if the next

00:14:22,510 --> 00:14:26,470
character is smaller than this character

00:14:24,310 --> 00:14:27,820
we'll go to the left and if the next

00:14:26,470 --> 00:14:29,950
character is greater than this character

00:14:27,820 --> 00:14:31,450
we go to the right and if it is the if

00:14:29,950 --> 00:14:35,710
it matches with the current character we

00:14:31,450 --> 00:14:43,600
go to the middle node so that's how we

00:14:35,710 --> 00:14:48,160
Travis so and this also has order log in

00:14:43,600 --> 00:14:51,700
performance and another cherry on the

00:14:48,160 --> 00:14:54,040
top is that we can do prefix matches so

00:14:51,700 --> 00:14:57,100
for example if I want to see how many

00:14:54,040 --> 00:15:00,100
words are there with a certain prefix I

00:14:57,100 --> 00:15:03,460
can easily do that with this kind of

00:15:00,100 --> 00:15:05,020
data structure in the log in time so

00:15:03,460 --> 00:15:08,620
this is an example of a ternary search

00:15:05,020 --> 00:15:11,680
try in memory so for example if I want

00:15:08,620 --> 00:15:15,160
to insert a word cat so I'll start with

00:15:11,680 --> 00:15:17,320
C and then this is the first first word

00:15:15,160 --> 00:15:19,270
we'll just go down the middle node if I

00:15:17,320 --> 00:15:22,180
want to insert another node in another

00:15:19,270 --> 00:15:23,920
word let's say bug I'll go since be

00:15:22,180 --> 00:15:25,720
smaller than C we'll come to the left

00:15:23,920 --> 00:15:28,420
and since there is nothing here we'll go

00:15:25,720 --> 00:15:31,180
down the middle if I want to insert cup

00:15:28,420 --> 00:15:34,300
so C is already there U is greater than

00:15:31,180 --> 00:15:34,870
C so we'll come down to the right and

00:15:34,300 --> 00:15:37,900
then we

00:15:34,870 --> 00:15:40,960
come again to the middle and this way

00:15:37,900 --> 00:15:44,920
you can do again binary search kind of

00:15:40,960 --> 00:15:56,800
look up and insert and get the words in

00:15:44,920 --> 00:15:59,500
log in time so for doing spell

00:15:56,800 --> 00:16:01,360
correction so that was about how do we

00:15:59,500 --> 00:16:02,710
represent the dictionary so once you

00:16:01,360 --> 00:16:04,300
have the dictionary we can look up the

00:16:02,710 --> 00:16:06,940
dictionary and we can figure out if it

00:16:04,300 --> 00:16:09,460
is a correctly spelled word or not but

00:16:06,940 --> 00:16:12,280
now to do spell correction there are

00:16:09,460 --> 00:16:14,110
different set of algorithms so one of

00:16:12,280 --> 00:16:16,180
the popular techniques is the added

00:16:14,110 --> 00:16:19,540
distance technique so if you get out how

00:16:16,180 --> 00:16:22,360
many Edit distances this word is from

00:16:19,540 --> 00:16:24,340
another word and then there are sound

00:16:22,360 --> 00:16:29,590
based algorithms such as the metaphor

00:16:24,340 --> 00:16:33,580
and we use Engram models to figure out

00:16:29,590 --> 00:16:37,530
which is the most correct spelling of

00:16:33,580 --> 00:16:41,200
the or of all these possible Corrections

00:16:37,530 --> 00:16:43,990
so the added distance is basically if we

00:16:41,200 --> 00:16:46,060
have towards so how many edits are

00:16:43,990 --> 00:16:47,830
needed in this word to convert it into

00:16:46,060 --> 00:16:50,290
the other words so the possible edits

00:16:47,830 --> 00:16:51,940
are there the insertion so you insert

00:16:50,290 --> 00:16:54,160
you can insert any character in the

00:16:51,940 --> 00:16:56,710
world or you can delete any character in

00:16:54,160 --> 00:17:02,310
the world or you can replace characters

00:16:56,710 --> 00:17:05,290
with another character and it has been

00:17:02,310 --> 00:17:06,820
found that a majority of spelling

00:17:05,290 --> 00:17:11,350
Corrections are just fun edit distance

00:17:06,820 --> 00:17:17,740
away from the correct spelling yeah

00:17:11,350 --> 00:17:21,540
transposition is also there this is an

00:17:17,740 --> 00:17:24,970
example of for example if the word is I

00:17:21,540 --> 00:17:27,880
misspelled dies ha so then these are the

00:17:24,970 --> 00:17:31,720
possible this is not a complete list I

00:17:27,880 --> 00:17:34,030
just shortened it but so for example if

00:17:31,720 --> 00:17:36,550
you delete one character at a time so if

00:17:34,030 --> 00:17:39,100
you remove the T it will become eh and

00:17:36,550 --> 00:17:43,450
if you remove the e then it becomes th

00:17:39,100 --> 00:17:46,540
remove the e then become H becomes then

00:17:43,450 --> 00:17:47,850
becomes T and so on so these are the

00:17:46,540 --> 00:17:51,840
possible

00:17:47,850 --> 00:17:53,700
words from Tao at 180 distance once we

00:17:51,840 --> 00:17:55,620
have this list again we can look up all

00:17:53,700 --> 00:17:57,450
these and see how many of these are

00:17:55,620 --> 00:17:58,740
there in the dictionary and then those

00:17:57,450 --> 00:18:04,830
are the possible Corrections of a

00:17:58,740 --> 00:18:06,840
misspelled word so these are all added

00:18:04,830 --> 00:18:08,550
distance one if we want to go to edit

00:18:06,840 --> 00:18:11,010
distance 2 we take all these words and

00:18:08,550 --> 00:18:13,920
from these words we go to the next cell

00:18:11,010 --> 00:18:15,900
how many words are there at the distance

00:18:13,920 --> 00:18:20,220
phone from here and those are any

00:18:15,900 --> 00:18:23,180
distance 2 but as we go on the the list

00:18:20,220 --> 00:18:25,740
of words increases very rapidly so

00:18:23,180 --> 00:18:28,280
looking up dictionary becomes quite

00:18:25,740 --> 00:18:28,280
expensive

00:18:29,540 --> 00:18:34,920
another popular technique is the meta

00:18:32,640 --> 00:18:38,100
phone algorithm so this is a phonetic

00:18:34,920 --> 00:18:39,840
algorithm there was a very popular

00:18:38,100 --> 00:18:43,800
algorithm called sound x which was

00:18:39,840 --> 00:18:46,310
developed in the 50s or the 60s and so

00:18:43,800 --> 00:18:49,320
essentially based on how a word is

00:18:46,310 --> 00:18:51,360
pronounced or however sounds it

00:18:49,320 --> 00:18:57,360
generates a code so every word gets a

00:18:51,360 --> 00:18:59,760
code and based on the misspelled word we

00:18:57,360 --> 00:19:01,860
can generate its meta phone and we can

00:18:59,760 --> 00:19:04,140
see how many words are there which have

00:19:01,860 --> 00:19:07,080
the same meta phone as similar to this

00:19:04,140 --> 00:19:11,400
and then those are the possible

00:19:07,080 --> 00:19:13,040
Corrections for this particular world so

00:19:11,400 --> 00:19:15,450
the advantage of sounding Sewer

00:19:13,040 --> 00:19:19,800
advantage of meta phone over sound x is

00:19:15,450 --> 00:19:23,460
that it not it covers not only English

00:19:19,800 --> 00:19:26,520
but also many other languages so if you

00:19:23,460 --> 00:19:29,700
want to use it it for other languages

00:19:26,520 --> 00:19:32,790
this works quite well and there have

00:19:29,700 --> 00:19:36,270
been three meta phone algorithms the

00:19:32,790 --> 00:19:39,240
first one was developed in 1990 and but

00:19:36,270 --> 00:19:41,250
it had some bugs and then the next

00:19:39,240 --> 00:19:45,060
version called double meta phone came in

00:19:41,250 --> 00:19:50,430
2000 and the final version came in

00:19:45,060 --> 00:19:52,200
around not sure but that is a commercial

00:19:50,430 --> 00:19:54,390
version so we cannot use it but a double

00:19:52,200 --> 00:19:58,580
meta phone algorithm is available as

00:19:54,390 --> 00:20:03,299
open so we can easily use it

00:19:58,580 --> 00:20:05,850
and finally once we have these possible

00:20:03,299 --> 00:20:07,529
Corrections for a misspelled word we

00:20:05,850 --> 00:20:09,029
have to figure out out of all these

00:20:07,529 --> 00:20:11,520
possible Corrections which are the most

00:20:09,029 --> 00:20:13,950
possible ones so as I described

00:20:11,520 --> 00:20:15,570
previously we can use by grams or

00:20:13,950 --> 00:20:21,690
trigrams to see the surrounding words

00:20:15,570 --> 00:20:23,760
and see how many of these are I mean how

00:20:21,690 --> 00:20:25,950
many of these are the most possible

00:20:23,760 --> 00:20:29,220
Corrections here so this is an example

00:20:25,950 --> 00:20:30,870
if I have a sentence like this I am not

00:20:29,220 --> 00:20:36,450
feeling very well and I've misspelled

00:20:30,870 --> 00:20:39,149
very as W ery now I'll have suggestions

00:20:36,450 --> 00:20:42,779
I Hal I will have Corrections such as

00:20:39,149 --> 00:20:46,890
very WEA ry that is also a valid word

00:20:42,779 --> 00:20:49,799
and all I will have correction as very V

00:20:46,890 --> 00:20:54,149
ery both are possible Corrections but if

00:20:49,799 --> 00:20:58,350
I compare by grams then V ery very well

00:20:54,149 --> 00:21:01,770
is much more likely than wer I Y very

00:20:58,350 --> 00:21:06,230
well so this is a technique to filter

00:21:01,770 --> 00:21:06,230
down this list of possible Corrections

00:21:06,470 --> 00:21:12,360
and once you have all these algorithms

00:21:09,890 --> 00:21:15,750
we have to figure out how to combine all

00:21:12,360 --> 00:21:16,760
of these to get the best possible

00:21:15,750 --> 00:21:19,559
accuracy

00:21:16,760 --> 00:21:22,020
there are various choices here so you

00:21:19,559 --> 00:21:24,360
can't just take all the words at any

00:21:22,020 --> 00:21:26,520
distance one and just stop there so if a

00:21:24,360 --> 00:21:27,090
match is found it at a distance one just

00:21:26,520 --> 00:21:31,140
take that

00:21:27,090 --> 00:21:33,750
but although that gets good accuracy

00:21:31,140 --> 00:21:36,260
around 70 to 80 percent but it does not

00:21:33,750 --> 00:21:39,779
cover all possible spelling errors

00:21:36,260 --> 00:21:41,429
another possibility is once you you go

00:21:39,779 --> 00:21:44,960
another distance so you go to enter

00:21:41,429 --> 00:21:47,580
distance to but any distance to gets

00:21:44,960 --> 00:21:51,570
because a number of words at any

00:21:47,580 --> 00:21:52,890
distance 2 is much higher the number of

00:21:51,570 --> 00:21:55,320
comparisons you have to see in the

00:21:52,890 --> 00:21:59,250
dictionary is much higher also so it

00:21:55,320 --> 00:22:03,929
becomes lower so what I have found is

00:21:59,250 --> 00:22:06,659
that these 3 steps so first check all

00:22:03,929 --> 00:22:08,789
the words at any distance 1 if a matches

00:22:06,659 --> 00:22:09,389
won't stop there if does if there is no

00:22:08,789 --> 00:22:11,820
match found

00:22:09,389 --> 00:22:14,160
we will try to find all the

00:22:11,820 --> 00:22:16,950
words having the same meta phone or a

00:22:14,160 --> 00:22:19,110
meta phone at distance one or two and

00:22:16,950 --> 00:22:21,930
out of those will see if a match is

00:22:19,110 --> 00:22:23,550
found in the dictionary or not if no

00:22:21,930 --> 00:22:27,470
match is found and will go to any

00:22:23,550 --> 00:22:31,980
distance - so this is an increasing or

00:22:27,470 --> 00:22:35,070
increasing order of runtime complexity

00:22:31,980 --> 00:22:36,840
because this is a very fast this is also

00:22:35,070 --> 00:22:38,730
fast but this is very slow so with this

00:22:36,840 --> 00:22:40,320
you only want to do in the worst case

00:22:38,730 --> 00:22:47,250
then when we are not able to find

00:22:40,320 --> 00:22:50,460
anything and then in the research

00:22:47,250 --> 00:22:51,930
literature there have been some tricks

00:22:50,460 --> 00:22:54,210
which have been found so it has been

00:22:51,930 --> 00:22:56,610
found that there is a much less chance

00:22:54,210 --> 00:23:00,810
that you someone will misspell the first

00:22:56,610 --> 00:23:03,270
character of a word so if when we are

00:23:00,810 --> 00:23:06,870
generating the possible correct

00:23:03,270 --> 00:23:08,910
spellings if the first word is being

00:23:06,870 --> 00:23:11,490
changed and will give it a lower weight

00:23:08,910 --> 00:23:14,970
because it is very much less likely that

00:23:11,490 --> 00:23:21,150
this is a person will make this kind of

00:23:14,970 --> 00:23:25,290
a mistake and similarly when we have a

00:23:21,150 --> 00:23:27,360
set of Corrections and out of those the

00:23:25,290 --> 00:23:29,730
words which sound similar that is they

00:23:27,360 --> 00:23:33,560
have a similar meta phone code we can

00:23:29,730 --> 00:23:36,030
give those words a higher weight because

00:23:33,560 --> 00:23:37,560
because they are sounding similar most

00:23:36,030 --> 00:23:43,200
probably that could be the correct

00:23:37,560 --> 00:23:45,470
spelling so based on these heuristics I

00:23:43,200 --> 00:23:50,630
have done some comparison with the other

00:23:45,470 --> 00:23:50,630
major open source spell implementations

00:23:51,770 --> 00:23:58,730
so this is an openly available data set

00:23:55,860 --> 00:24:01,440
which a spell uses to publish its

00:23:58,730 --> 00:24:05,400
benchmarks so I have used the same data

00:24:01,440 --> 00:24:08,640
set and compare the performances so the

00:24:05,400 --> 00:24:10,680
a spell so there are two variations in a

00:24:08,640 --> 00:24:12,720
spell there is a normal mode and there

00:24:10,680 --> 00:24:18,690
is a slow mode so in the slow mode and

00:24:12,720 --> 00:24:21,780
then there is so this is like if a match

00:24:18,690 --> 00:24:23,910
is founded of in the first place that is

00:24:21,780 --> 00:24:25,440
if a spell is generating just one

00:24:23,910 --> 00:24:28,440
suggestion and that is the correct match

00:24:25,440 --> 00:24:30,660
and if a spell is generating five

00:24:28,440 --> 00:24:32,910
Corrections and a match is found in any

00:24:30,660 --> 00:24:35,220
of them this is one to ten that is a

00:24:32,910 --> 00:24:37,740
match is found in any of the top ten

00:24:35,220 --> 00:24:40,950
Corrections and this is the same as for

00:24:37,740 --> 00:24:43,740
the top 25 so for the first position a

00:24:40,950 --> 00:24:46,860
spell gets around 73 or 74 percent

00:24:43,740 --> 00:24:48,809
accuracy but if we go to top five a

00:24:46,860 --> 00:24:51,720
spell gets much better so it jumps to

00:24:48,809 --> 00:24:55,289
ninety six point one and in the top 10

00:24:51,720 --> 00:24:58,049
it goes to 97 and then 98 the slow

00:24:55,289 --> 00:25:03,140
version is likely better it has 74 and

00:24:58,049 --> 00:25:06,000
then ninety six point six hunt spell is

00:25:03,140 --> 00:25:08,909
better in the if we are doing the

00:25:06,000 --> 00:25:10,530
comparing the first match in the first

00:25:08,909 --> 00:25:13,950
position so then it will have around 80

00:25:10,530 --> 00:25:17,190
point five accuracy and the top 25 goes

00:25:13,950 --> 00:25:22,559
to 97 I spell is the oldest of all these

00:25:17,190 --> 00:25:24,000
all so it has accuracy around 77 percent

00:25:22,559 --> 00:25:28,230
and in the top 25

00:25:24,000 --> 00:25:30,299
it goes to 85 so I also have done two

00:25:28,230 --> 00:25:32,700
variations of comparison so there is no

00:25:30,299 --> 00:25:35,250
slower mode and there is a fast mode so

00:25:32,700 --> 00:25:38,039
in the slow mode it gets around 91%

00:25:35,250 --> 00:25:41,850
accuracy and then in the top five it

00:25:38,039 --> 00:25:45,630
goes 95 and then the improvement is very

00:25:41,850 --> 00:25:46,580
marginal so it almost stops at 95 in the

00:25:45,630 --> 00:25:49,110
fast version

00:25:46,580 --> 00:25:51,570
it starts at eighty eighty eight point

00:25:49,110 --> 00:25:54,539
seven and goes to 93 and ninety three

00:25:51,570 --> 00:25:58,799
point four so the difference between the

00:25:54,539 --> 00:26:01,700
fast and a slow mode is that this test

00:25:58,799 --> 00:26:04,320
data set contains about 4,000 words and

00:26:01,700 --> 00:26:08,039
the slow mode takes around two minutes

00:26:04,320 --> 00:26:09,919
to compare to come up with spelling

00:26:08,039 --> 00:26:18,450
Corrections for all those 4,000 words

00:26:09,919 --> 00:26:21,090
the fast mode takes around around eight

00:26:18,450 --> 00:26:30,780
to ten seconds to do spell Corrections

00:26:21,090 --> 00:26:36,000
for 4,000 words so I have also created a

00:26:30,780 --> 00:26:38,700
small demo to show how this works if we

00:26:36,000 --> 00:26:51,060
want to integrate in

00:26:38,700 --> 00:26:54,450
she'll so I wanted to integrate this

00:26:51,060 --> 00:26:56,580
into actual into an actual shell but I

00:26:54,450 --> 00:27:01,290
didn't have the time so I just created a

00:26:56,580 --> 00:27:07,920
shell myself and integrated it the spell

00:27:01,290 --> 00:27:14,100
checking functionality there so for

00:27:07,920 --> 00:27:16,080
example if I type anything wrong it will

00:27:14,100 --> 00:27:17,550
figure out ok I spelled the command on I

00:27:16,080 --> 00:27:19,380
mean this is an existing functionality

00:27:17,550 --> 00:27:22,980
that may most of the shells already have

00:27:19,380 --> 00:27:26,790
but I just wanted to show how simple it

00:27:22,980 --> 00:27:29,790
is to do this then since I'm using your

00:27:26,790 --> 00:27:31,860
track data structure and it can do

00:27:29,790 --> 00:27:35,730
prefix searches so it is very simple to

00:27:31,860 --> 00:27:41,430
do Auto completions as well so for

00:27:35,730 --> 00:27:43,470
example if I want to see you this is

00:27:41,430 --> 00:27:45,540
also an existing functionality but since

00:27:43,470 --> 00:27:47,670
we already have all the words in the

00:27:45,540 --> 00:27:55,620
memory and we can do this kind of stuff

00:27:47,670 --> 00:27:59,490
also so and another thing is if you want

00:27:55,620 --> 00:28:01,500
to do context-sensitive Auto completion

00:27:59,490 --> 00:28:04,440
so for example if I'm doing I want to

00:28:01,500 --> 00:28:09,570
look up a man page and I type man and

00:28:04,440 --> 00:28:12,510
then I type I do tab and then it will

00:28:09,570 --> 00:28:14,720
autocomplete it to the possible man page

00:28:12,510 --> 00:28:14,720
name

00:28:34,690 --> 00:28:48,369
yeah and similarly if another example of

00:28:45,009 --> 00:28:55,869
context-sensitive auto-completion is is

00:28:48,369 --> 00:28:58,090
it visible okay so another example of

00:28:55,869 --> 00:29:00,609
context-sensitive look auto-completion

00:28:58,090 --> 00:29:02,769
is for example if I want to do install a

00:29:00,609 --> 00:29:05,529
package and I type package ad and then I

00:29:02,769 --> 00:29:09,009
want to see all I want to install some

00:29:05,529 --> 00:29:10,960
group package so I just go and it will

00:29:09,009 --> 00:29:14,440
show me all the packages that therefore

00:29:10,960 --> 00:29:17,679
go so I built individual dictionaries

00:29:14,440 --> 00:29:20,470
for man pages package names commands and

00:29:17,679 --> 00:29:23,259
I am based on the context that is if I

00:29:20,470 --> 00:29:25,379
have typed man I'm doing use looking up

00:29:23,259 --> 00:29:28,149
the dictionary of man pages if I am

00:29:25,379 --> 00:29:29,859
trying to install package then I looking

00:29:28,149 --> 00:29:34,330
up the dictionary of packages I am doing

00:29:29,859 --> 00:29:37,419
Auto completion based on that so all of

00:29:34,330 --> 00:29:40,769
this is quite simple to do with the

00:29:37,419 --> 00:29:40,769
library likely interface

00:29:49,170 --> 00:29:56,730
so I would like to conclude with saying

00:29:52,860 --> 00:30:00,830
that although it does not meet a spell

00:29:56,730 --> 00:30:03,420
or unspell in in their top 25

00:30:00,830 --> 00:30:05,940
Corrections but it still is able to

00:30:03,420 --> 00:30:11,100
match in the in the first order top 5

00:30:05,940 --> 00:30:12,510
comparisons and there is still much room

00:30:11,100 --> 00:30:14,520
for improving the accuracy and the

00:30:12,510 --> 00:30:16,920
performance so because I'm using an

00:30:14,520 --> 00:30:19,230
in-memory dictionary there is an issue

00:30:16,920 --> 00:30:21,510
about using too much memory so for

00:30:19,230 --> 00:30:24,120
example if the dictionary is too big it

00:30:21,510 --> 00:30:26,540
will consume a lot of memory so that is

00:30:24,120 --> 00:30:29,040
something to look into

00:30:26,540 --> 00:30:31,890
but it still it would be nice to have a

00:30:29,040 --> 00:30:34,620
BSD licensed spell checker plus a

00:30:31,890 --> 00:30:40,890
library so that we can use in our own

00:30:34,620 --> 00:30:44,130
applications and all this code is

00:30:40,890 --> 00:30:46,260
currently available on github so it is

00:30:44,130 --> 00:30:48,840
not part of nate BST as of you know and

00:30:46,260 --> 00:30:52,980
I am not sure if it will be but I will

00:30:48,840 --> 00:30:55,320
try to post it on the mailing list I am

00:30:52,980 --> 00:31:00,840
still working on this so there might be

00:30:55,320 --> 00:31:19,230
a lot of work still any questions if you

00:31:00,840 --> 00:31:22,410
have so are you looking at what keywords

00:31:19,230 --> 00:31:25,350
people are using so you can say what

00:31:22,410 --> 00:31:31,799
characters are possibly the replacement

00:31:25,350 --> 00:31:34,169
for a typo not yet so that is a I guess

00:31:31,799 --> 00:31:37,650
that is a different set of algorithm

00:31:34,169 --> 00:31:39,240
probably I will have to see because for

00:31:37,650 --> 00:31:42,929
example the edit distance one so I am

00:31:39,240 --> 00:31:44,340
using the normal ask ie order but if I

00:31:42,929 --> 00:31:46,950
want to use the keyboard order then

00:31:44,340 --> 00:31:50,160
that's a different kind of I need to

00:31:46,950 --> 00:31:51,990
figure out how to get that ordering of I

00:31:50,160 --> 00:31:56,059
mean how the keys are placed on the

00:31:51,990 --> 00:31:56,059
keyboard that is the possibility yes

00:32:00,519 --> 00:32:08,450
so in your damp in your in your demo you

00:32:06,159 --> 00:32:11,599
showed your special shell which was

00:32:08,450 --> 00:32:13,070
expanding context was that's one

00:32:11,599 --> 00:32:16,309
approach the other pouch would be to

00:32:13,070 --> 00:32:20,539
maybe modify package involve manual to

00:32:16,309 --> 00:32:22,729
use your infrastructure yeah what would

00:32:20,539 --> 00:32:25,940
you propose because both of them are

00:32:22,729 --> 00:32:28,749
kind of intrusive and somehow it has to

00:32:25,940 --> 00:32:34,669
be a model which you would use for your

00:32:28,749 --> 00:32:37,729
deployment of this spelling so for

00:32:34,669 --> 00:32:40,009
example using for example if I want to

00:32:37,729 --> 00:32:44,570
modify a package ID and that should do

00:32:40,009 --> 00:32:46,879
the auto completion or the question is

00:32:44,570 --> 00:32:50,379
what you build it into the shell or what

00:32:46,879 --> 00:32:50,379
you build it into each and every command

00:32:50,440 --> 00:32:58,820
it is simpler to do in the shell because

00:32:53,450 --> 00:33:00,889
that is one place and we can modularize

00:32:58,820 --> 00:33:03,830
it so we can provide hoops into the

00:33:00,889 --> 00:33:06,379
shell that shell should call should use

00:33:03,830 --> 00:33:10,309
this this dictionary to look up when

00:33:06,379 --> 00:33:12,349
someone is typing this command modifying

00:33:10,309 --> 00:33:18,950
each and every command will be much more

00:33:12,349 --> 00:33:22,039
time taking I can answer that because I

00:33:18,950 --> 00:33:24,859
written this thing before for TC show so

00:33:22,039 --> 00:33:26,899
there certain common completion so

00:33:24,859 --> 00:33:29,389
depending position if you're a command

00:33:26,899 --> 00:33:31,429
or you're a file and or if you're

00:33:29,389 --> 00:33:33,440
expecting a directory or not a directory

00:33:31,429 --> 00:33:35,029
so all of these are common so you can

00:33:33,440 --> 00:33:37,009
put it in the language of the shell

00:33:35,029 --> 00:33:39,049
putting it each command would require

00:33:37,009 --> 00:33:41,330
executing the command every time you

00:33:39,049 --> 00:33:45,739
have to ask it what the completions are

00:33:41,330 --> 00:33:47,719
and that can be inefficient example

00:33:45,739 --> 00:33:49,759
where I would like to modify the command

00:33:47,719 --> 00:33:52,039
is for example in a propose so if

00:33:49,759 --> 00:33:54,649
someone types a query and that does not

00:33:52,039 --> 00:33:57,139
get any results but apropos can see oh

00:33:54,649 --> 00:33:59,119
you misspelled this thing as something

00:33:57,139 --> 00:34:02,239
else so I it can say did you mean this

00:33:59,119 --> 00:34:04,909
so someone can know okay I misspelled

00:34:02,239 --> 00:34:06,799
this thing I need to another query that

00:34:04,909 --> 00:34:08,869
is one place you I can modify the

00:34:06,799 --> 00:34:12,309
command itself for auto completion it

00:34:08,869 --> 00:34:12,309
makes sense to modify the shell

00:34:12,340 --> 00:34:29,029
[Music]

00:34:20,000 --> 00:34:29,029
okay we have something for you

00:34:29,050 --> 00:34:32,159

YouTube URL: https://www.youtube.com/watch?v=3aMLmLmSjcg


