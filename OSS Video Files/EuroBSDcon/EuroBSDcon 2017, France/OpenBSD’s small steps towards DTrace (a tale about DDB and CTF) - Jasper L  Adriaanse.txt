Title: OpenBSDâ€™s small steps towards DTrace (a tale about DDB and CTF) - Jasper L  Adriaanse
Publication date: 2019-10-16
Playlist: EuroBSDcon 2017, France
Description: 
	Description:

This talk will be about the work that is going on in OpenBSD to develop a
dynamic tracing/profiling system, not unlike DTrace.
The road towards a fully working DTrace-like implementation is long and a lot
of that depends on having binaries annotated with CTF.

CTF is a converted subset of DWARF that can be embedded in all a wide range of binaries, including the kernel.

Throughout this presentation I will discuss the dynamic profiling part that has
been developed by Martin Pieuchot and I will go into the work that went into
adding support for inspecting kernel CTF-data with DDB. Lastly the status quo
will be reviewed as well as what pieces are still missing from the puzzle.

Speaker biography:

Jasper Lievisse Adriaanse is an OpenBSD developer from the Netherlands. He
joined the project in 2006 and has since been involved in many areas of the
tree, ranging from Octeon and GNOME to CTF.
Captions: 
	00:00:00,380 --> 00:00:06,529
so welcome everyone that's good market

00:00:03,300 --> 00:00:11,910
after the booze cruise from last night's

00:00:06,529 --> 00:00:14,570
so of course our software has no box the

00:00:11,910 --> 00:00:17,039
hardware we run on has no issues and

00:00:14,570 --> 00:00:21,600
everything works as it should so we're

00:00:17,039 --> 00:00:24,330
all happy campers however sometimes we

00:00:21,600 --> 00:00:27,480
do need to find and need to debug

00:00:24,330 --> 00:00:32,040
something to inspect our system and

00:00:27,480 --> 00:00:36,420
analyze what's going on and we've always

00:00:32,040 --> 00:00:42,960
had tools such as sky trace gdb or even

00:00:36,420 --> 00:00:43,829
good old DB to help us analyze and debug

00:00:42,960 --> 00:00:47,360
our problems

00:00:43,829 --> 00:00:50,489
in those rare cases where we have them

00:00:47,360 --> 00:00:54,239
but sometimes we need a tool that allows

00:00:50,489 --> 00:00:56,610
us to dig deeper into the system and to

00:00:54,239 --> 00:01:00,809
give us more holistic view of what's

00:00:56,610 --> 00:01:03,780
going on and dtrace can be a valuable

00:01:00,809 --> 00:01:08,549
addition to the list of tools we already

00:01:03,780 --> 00:01:11,939
have so DTrace is the dynamic tracing

00:01:08,549 --> 00:01:14,610
and analysis tool originating at CERN or

00:01:11,939 --> 00:01:16,860
at least made production-ready by Sun

00:01:14,610 --> 00:01:19,860
and it's found its way into many other

00:01:16,860 --> 00:01:25,500
systems so it was initially developed

00:01:19,860 --> 00:01:28,229
for Solaris and of course FreeBSD NetBSD

00:01:25,500 --> 00:01:31,619
Mac OS and Linux all have an

00:01:28,229 --> 00:01:35,369
implementation these days so today I'd

00:01:31,619 --> 00:01:37,590
like to talk to you about the efforts in

00:01:35,369 --> 00:01:41,759
open BSD and the ongoing efforts I

00:01:37,590 --> 00:01:48,689
should say of perhaps eventually someday

00:01:41,759 --> 00:01:53,630
maybe we'll have dtrace proper so first

00:01:48,689 --> 00:01:58,939
of all look at dtrace what it is and why

00:01:53,630 --> 00:02:01,680
we should care about it now go into CTF

00:01:58,939 --> 00:02:07,399
give an overview of the current state of

00:02:01,680 --> 00:02:07,399
affairs CTF and dtrace in open BSD

00:02:08,010 --> 00:02:15,990
so for those of you who don't know me

00:02:10,590 --> 00:02:19,290
yes / leave us I have the answer or jaws

00:02:15,990 --> 00:02:24,330
/ for shorts been involved with OpenBSD

00:02:19,290 --> 00:02:28,140
since about 2006 mostly while working in

00:02:24,330 --> 00:02:30,900
ports and particular Nome been playing

00:02:28,140 --> 00:02:33,990
with Aki on and more recently true

00:02:30,900 --> 00:02:38,940
random number generators for the urng

00:02:33,990 --> 00:02:41,310
driver and of course CTF so by day I

00:02:38,940 --> 00:02:43,770
work as a UNIX engineer at snow in the

00:02:41,310 --> 00:02:47,220
Netherlands and by night I hide behind

00:02:43,770 --> 00:02:49,140
these aliases on get up and Twitter so

00:02:47,220 --> 00:02:57,420
it can stalk me or harass me if you

00:02:49,140 --> 00:02:57,630
prefer so so perhaps a long time from

00:02:57,420 --> 00:03:02,130
now

00:02:57,630 --> 00:03:05,840
in the source tree still far away but at

00:03:02,130 --> 00:03:09,120
least the DB and CTF parts have been

00:03:05,840 --> 00:03:13,680
undergoing for a little over a year now

00:03:09,120 --> 00:03:15,570
and was mentioned the purpose of this

00:03:13,680 --> 00:03:18,930
talk is to give you a status update of

00:03:15,570 --> 00:03:19,860
where we are and the efforts that went

00:03:18,930 --> 00:03:22,860
into it

00:03:19,860 --> 00:03:25,680
of course brief explanation of DTrace in

00:03:22,860 --> 00:03:31,380
the city of itself so let's start with

00:03:25,680 --> 00:03:35,270
the end game or end goal first it's our

00:03:31,380 --> 00:03:38,700
goal to have DTrace one way or another

00:03:35,270 --> 00:03:41,040
but it does require many other pieces to

00:03:38,700 --> 00:03:42,840
be in place first

00:03:41,040 --> 00:03:44,700
an analogy I've been using in the past

00:03:42,840 --> 00:03:47,580
couple of days to describe to people

00:03:44,700 --> 00:03:50,820
where we are and how far away we are

00:03:47,580 --> 00:03:53,610
from having these races picture a puzzle

00:03:50,820 --> 00:03:56,580
so we have the corner pieces we found

00:03:53,610 --> 00:03:59,100
them we are working on filling in the

00:03:56,580 --> 00:04:00,750
edges and we sort of know what the

00:03:59,100 --> 00:04:03,720
picture what the puzzle should look like

00:04:00,750 --> 00:04:07,470
when it's completed by looking at other

00:04:03,720 --> 00:04:10,470
systems and we're slowly but surely

00:04:07,470 --> 00:04:16,610
working on filling in the missing pieces

00:04:10,470 --> 00:04:16,610
which at this point are still a lot

00:04:18,570 --> 00:04:27,480
so what is DTrace really it's what the

00:04:24,010 --> 00:04:31,510
name implies a dynamic tracing framework

00:04:27,480 --> 00:04:36,010
the way it works is that it's using

00:04:31,510 --> 00:04:37,990
minimal impact probes which don't have

00:04:36,010 --> 00:04:43,390
any effect wendy trades is not enabled

00:04:37,990 --> 00:04:47,230
and have a minimal or as small as

00:04:43,390 --> 00:04:48,310
possible effect when it is in place so

00:04:47,230 --> 00:04:51,700
as i mentioned it was made

00:04:48,310 --> 00:04:54,010
production-ready by sun 2003 publicly

00:04:51,700 --> 00:04:57,340
released in solaris a couple of years

00:04:54,010 --> 00:05:01,690
later and since i found its way into mac

00:04:57,340 --> 00:05:04,900
OS around 2007 freebsd netbsd and linux

00:05:01,690 --> 00:05:07,990
followed shortly there has been an

00:05:04,900 --> 00:05:10,960
attempt to port DTrace to Q and X

00:05:07,990 --> 00:05:16,660
however just like UNIX is future it's

00:05:10,960 --> 00:05:20,260
sort of unknown and dtrace is CDL

00:05:16,660 --> 00:05:22,900
license which may not be an issue for

00:05:20,260 --> 00:05:26,260
certain systems however it's a clear

00:05:22,900 --> 00:05:29,290
blocker for open BSD so that's the main

00:05:26,260 --> 00:05:32,980
reason why we cannot simply take the

00:05:29,290 --> 00:05:37,390
original source code of distress and of

00:05:32,980 --> 00:05:39,610
the tools around it such as these CTF

00:05:37,390 --> 00:05:46,800
tools so we cannot import those because

00:05:39,610 --> 00:05:49,150
of licensing issues so dtrace works with

00:05:46,800 --> 00:05:52,240
providers and probes which I'll show a

00:05:49,150 --> 00:05:55,420
bit more about next slides but I also

00:05:52,240 --> 00:05:59,770
want to mention D the language D which

00:05:55,420 --> 00:06:02,740
allows for writing scripts of course the

00:05:59,770 --> 00:06:05,260
main way of interacting with dtrace is

00:06:02,740 --> 00:06:09,850
by writing D expressions on the command

00:06:05,260 --> 00:06:12,970
line and Brandon Greg wrote the 3d trace

00:06:09,850 --> 00:06:17,170
toolkit which is a very comprehensive

00:06:12,970 --> 00:06:19,000
set of scripts or using D trace but

00:06:17,170 --> 00:06:21,990
providing top or iocean applied

00:06:19,000 --> 00:06:21,990
functionality

00:06:28,160 --> 00:06:36,360
so this is one way to as much very short

00:06:33,600 --> 00:06:40,080
demonstration of what DTrace looks like

00:06:36,360 --> 00:06:44,580
so you call dtrace and you provide it

00:06:40,080 --> 00:06:47,360
with a probe to use in this case we're

00:06:44,580 --> 00:06:53,100
using a wild card so we're using the

00:06:47,360 --> 00:06:55,550
Cisco three Collins entry probe which

00:06:53,100 --> 00:07:00,020
means that there's a wild card in there

00:06:55,550 --> 00:07:02,940
so this is called provider then to

00:07:00,020 --> 00:07:05,550
namespace separators and an invisible

00:07:02,940 --> 00:07:09,150
wild card a column and the entry so what

00:07:05,550 --> 00:07:12,690
that means is the what we're doing right

00:07:09,150 --> 00:07:17,700
here is for every Cisco that gets

00:07:12,690 --> 00:07:21,030
entered ends the entry probe we print or

00:07:17,700 --> 00:07:22,530
we trace the executable name so for

00:07:21,030 --> 00:07:25,770
example as you can see when we fire up

00:07:22,530 --> 00:07:29,840
the trace you see that's entering the

00:07:25,770 --> 00:07:33,630
i/o control Cisco twice and then qmu

00:07:29,840 --> 00:07:39,770
comes along and does some other things

00:07:33,630 --> 00:07:39,770
and the sample was taken from smart OS

00:07:40,610 --> 00:07:45,419
so as you can see we're not inspecting a

00:07:43,350 --> 00:07:47,610
single application here we're

00:07:45,419 --> 00:07:50,580
instrumenting the system as a whole

00:07:47,610 --> 00:07:52,530
I didn't provide any application to

00:07:50,580 --> 00:07:59,850
trace and you can see that DTrace and

00:07:52,530 --> 00:08:03,740
qmu are running so another slightly more

00:07:59,850 --> 00:08:08,850
complex example but still near trivial

00:08:03,740 --> 00:08:14,280
is to show the number of bytes written

00:08:08,850 --> 00:08:16,650
per process and summing them and when

00:08:14,280 --> 00:08:19,520
you quit dtrace you know print its

00:08:16,650 --> 00:08:21,870
summary and based on this you can

00:08:19,520 --> 00:08:25,260
analyze your system further create some

00:08:21,870 --> 00:08:28,530
fancy graphs and these were taken from

00:08:25,260 --> 00:08:30,450
Brandon's DTrace one-liner so txt which

00:08:28,530 --> 00:08:33,360
if you don't know it it's a small

00:08:30,450 --> 00:08:40,229
treasure trove of needs one-liners such

00:08:33,360 --> 00:08:42,899
this one so why should you care about

00:08:40,229 --> 00:08:45,860
dtrace if you know DTrace and if you've

00:08:42,899 --> 00:08:48,959
used it you probably consider it

00:08:45,860 --> 00:08:54,269
valuable and very handy tool but if you

00:08:48,959 --> 00:08:56,070
don't why should you be interested in

00:08:54,269 --> 00:09:00,000
perhaps to get involved in the effort

00:08:56,070 --> 00:09:03,660
and OpenBSD so we have a number of tools

00:09:00,000 --> 00:09:05,339
tres que tres estrellas and el tres of

00:09:03,660 --> 00:09:08,880
which the latter two we have from

00:09:05,339 --> 00:09:12,959
OpenBSD already but they're Cisco

00:09:08,880 --> 00:09:17,040
tracers or only for tracing userland

00:09:12,959 --> 00:09:20,990
and what these tools certainly have

00:09:17,040 --> 00:09:30,089
their application they may give you a to

00:09:20,990 --> 00:09:32,370
narrow view of the system and dtrace

00:09:30,089 --> 00:09:34,740
also address addresses the observability

00:09:32,370 --> 00:09:37,769
problem so what that means is when you

00:09:34,740 --> 00:09:40,709
inspect something or observe something

00:09:37,769 --> 00:09:45,000
the thing you're observing is affected

00:09:40,709 --> 00:09:47,910
by you looking at it for example if your

00:09:45,000 --> 00:09:51,029
K tracing an application it may behave

00:09:47,910 --> 00:09:55,769
differently from when it's running under

00:09:51,029 --> 00:09:58,190
a trace which is quite the opposite of

00:09:55,769 --> 00:10:00,899
what you're doing since you're observing

00:09:58,190 --> 00:10:03,029
more bad behavior for example you want

00:10:00,899 --> 00:10:04,620
to see why that's happening and you're

00:10:03,029 --> 00:10:06,589
characterizing it and it may end up

00:10:04,620 --> 00:10:10,680
doing something else for behaving

00:10:06,589 --> 00:10:14,600
slightly different waste and what it's

00:10:10,680 --> 00:10:22,620
doing otherwise and dtrace does not

00:10:14,600 --> 00:10:25,610
exhibit this behavior and also DTrace

00:10:22,620 --> 00:10:29,579
allows for very very fine-grained

00:10:25,610 --> 00:10:31,170
inspection albeit short term you

00:10:29,579 --> 00:10:35,670
wouldn't want to write your monitoring

00:10:31,170 --> 00:10:37,440
scripts or long-term analysis using D

00:10:35,670 --> 00:10:39,959
trace

00:10:37,440 --> 00:10:41,790
there are more appropriate tools for

00:10:39,959 --> 00:10:44,970
that since it's more for short-term

00:10:41,790 --> 00:10:49,259
inspection and debugging and analysis

00:10:44,970 --> 00:10:51,600
and speaking of inspection you've

00:10:49,259 --> 00:10:55,500
probably all seen the shouting in the

00:10:51,600 --> 00:10:59,160
data center the video if not I urge you

00:10:55,500 --> 00:11:03,769
to look it up on YouTube it's a prime

00:10:59,160 --> 00:11:06,959
example of how to use or abuse

00:11:03,769 --> 00:11:13,230
dtrace to observe what's going on in

00:11:06,959 --> 00:11:18,269
your system of course with a more

00:11:13,230 --> 00:11:22,259
complete tool chest of tools you don't

00:11:18,269 --> 00:11:27,139
need printf Department anymore or let's

00:11:22,259 --> 00:11:27,139
not overstate the case less at least

00:11:32,220 --> 00:11:39,360
so how does dtrace actually work so

00:11:36,690 --> 00:11:41,400
there are a number of providers for

00:11:39,360 --> 00:11:45,960
example the Cisco providers that I

00:11:41,400 --> 00:11:49,320
showed earlier there's the i/o provider

00:11:45,960 --> 00:11:52,260
these days info but also FBT that's the

00:11:49,320 --> 00:11:56,940
function boundary tracing provider of

00:11:52,260 --> 00:12:01,260
these FBT will be the first targets

00:11:56,940 --> 00:12:04,950
provider in open BSD so providers

00:12:01,260 --> 00:12:09,390
provides probes and we saw the Cisco

00:12:04,950 --> 00:12:12,960
entry probe earlier using the wildcards

00:12:09,390 --> 00:12:16,200
in here where for example the Cisco exec

00:12:12,960 --> 00:12:24,210
feed entry probe is just for inspecting

00:12:16,200 --> 00:12:29,130
the exactly Cisco so the FPT probe works

00:12:24,210 --> 00:12:32,190
by fetching the function boundaries so

00:12:29,130 --> 00:12:37,350
as soon as you are about to execute a

00:12:32,190 --> 00:12:41,430
function the function Prolog will be

00:12:37,350 --> 00:12:43,380
dynamically altered or or fetched it

00:12:41,430 --> 00:12:46,680
saves the original instruction you are

00:12:43,380 --> 00:12:49,860
about to execute it then runs the probe

00:12:46,680 --> 00:12:53,250
which does whatever it needs to do and

00:12:49,860 --> 00:12:56,070
when the probe is done running

00:12:53,250 --> 00:12:58,170
it'll emulate the original instruction

00:12:56,070 --> 00:13:01,680
you were about to execute when you enter

00:12:58,170 --> 00:13:04,710
the function so currently we do have

00:13:01,680 --> 00:13:08,370
code for this no VC already it was

00:13:04,710 --> 00:13:10,320
committed by Martin during or shortly

00:13:08,370 --> 00:13:13,410
before the general hackathon in

00:13:10,320 --> 00:13:16,410
Cambridge although right now it's it's

00:13:13,410 --> 00:13:22,140
hidden under the DB prof kernel

00:13:16,410 --> 00:13:24,680
compartment option but it's the first

00:13:22,140 --> 00:13:24,680
real

00:13:24,710 --> 00:13:34,940
KO's we have four for tracing or probing

00:13:30,410 --> 00:13:39,900
so when a function is about to return

00:13:34,940 --> 00:13:45,570
the last step would be to execute the

00:13:39,900 --> 00:13:47,160
probe if it needs to do that and when

00:13:45,570 --> 00:13:49,470
the probe is done processing it all

00:13:47,160 --> 00:13:51,900
emulate the last instructional function

00:13:49,470 --> 00:13:53,580
and the function itself returns normally

00:13:51,900 --> 00:13:58,350
so from the outside point of view

00:13:53,580 --> 00:14:00,570
nothing happened the function still did

00:13:58,350 --> 00:14:07,770
what it need to do it just got its

00:14:00,570 --> 00:14:10,140
prologue and epilogue altered so one key

00:14:07,770 --> 00:14:13,200
thing with dtrace compared to other

00:14:10,140 --> 00:14:17,700
tools is that it saves its results in

00:14:13,200 --> 00:14:20,550
per CPU buffers and it doesn't directly

00:14:17,700 --> 00:14:23,340
export these back into userland so

00:14:20,550 --> 00:14:25,740
you're not running into the top problem

00:14:23,340 --> 00:14:28,320
so if you're running top on the system

00:14:25,740 --> 00:14:32,030
with a lot of processes running you'll

00:14:28,320 --> 00:14:34,980
see that top itself will be one of the

00:14:32,030 --> 00:14:37,140
processes consuming most CPU time that's

00:14:34,980 --> 00:14:40,170
because it's continuously gathering the

00:14:37,140 --> 00:14:43,290
information and directly providing it

00:14:40,170 --> 00:14:46,940
back to you whereas with DTrace at all

00:14:43,290 --> 00:14:49,500
by default on one second intervals it'll

00:14:46,940 --> 00:14:51,360
it'll collect the data and at the given

00:14:49,500 --> 00:14:56,360
interval it'll export it back to useless

00:14:51,360 --> 00:14:58,760
so you're not continuously impacting the

00:14:56,360 --> 00:15:01,470
application or system you're tracing

00:14:58,760 --> 00:15:03,750
with the tool that is tracing it and

00:15:01,470 --> 00:15:09,410
they're playing or they're they're

00:15:03,750 --> 00:15:14,310
battling for CPU time so that's a key

00:15:09,410 --> 00:15:17,040
feature of dtrace of course

00:15:14,310 --> 00:15:19,080
dtrace need to know about what functions

00:15:17,040 --> 00:15:22,740
are which symbols are available and

00:15:19,080 --> 00:15:25,130
their types and that's where CTF comes

00:15:22,740 --> 00:15:25,130
into play

00:15:30,910 --> 00:15:39,999
and no not this CDF this one the complex

00:15:37,220 --> 00:15:39,999
type formats

00:15:42,140 --> 00:15:52,040
so CTF can be considered a compact

00:15:46,700 --> 00:15:54,589
notation of labels functions and for the

00:15:52,040 --> 00:15:58,970
other types of it supports is the full

00:15:54,589 --> 00:16:05,300
list it's generally though in practice

00:15:58,970 --> 00:16:08,829
basically always compressed with CF and

00:16:05,300 --> 00:16:12,709
there are two versions of CTF available

00:16:08,829 --> 00:16:16,160
but within open BSD we only target right

00:16:12,709 --> 00:16:17,930
now the version to latest version first

00:16:16,160 --> 00:16:20,240
one isn't really in active use anymore

00:16:17,930 --> 00:16:26,649
so there's no reason why we should

00:16:20,240 --> 00:16:31,250
develop our tools to use that on Solaris

00:16:26,649 --> 00:16:35,089
it CTF is extracted from steps aware as

00:16:31,250 --> 00:16:38,600
some other systems it's using dwarf so

00:16:35,089 --> 00:16:41,390
dwarf is generated by the compiler when

00:16:38,600 --> 00:16:44,470
you compile your source code with the -

00:16:41,390 --> 00:16:47,570
G option to generate the debug symbols

00:16:44,470 --> 00:16:51,649
the compiler will keep track of

00:16:47,570 --> 00:16:54,920
everything that might be useful for

00:16:51,649 --> 00:17:00,339
future debugging and saves it into

00:16:54,920 --> 00:17:06,790
several sections in the elf object file

00:17:00,339 --> 00:17:10,990
however because dwarf is so well huge

00:17:06,790 --> 00:17:13,760
it's not feasible to distribute kernels

00:17:10,990 --> 00:17:17,569
that always have this extra information

00:17:13,760 --> 00:17:21,290
add so for example kernel built with all

00:17:17,569 --> 00:17:23,959
the debug options sorry all the debug

00:17:21,290 --> 00:17:26,600
information stored in it is but four

00:17:23,959 --> 00:17:32,410
times bigger with all the dwarf or it's

00:17:26,600 --> 00:17:36,230
compared to just having CTS back on

00:17:32,410 --> 00:17:39,679
August when we enabled including CTF in

00:17:36,230 --> 00:17:42,200
all the kernels the growth was about one

00:17:39,679 --> 00:17:44,780
to two Mac and that's including the

00:17:42,200 --> 00:17:47,320
natural growth that just happens during

00:17:44,780 --> 00:17:47,320
hackathon

00:17:47,800 --> 00:17:55,450
so the CTF data gets stored into the elf

00:17:52,820 --> 00:18:01,100
objects file as well it can be

00:17:55,450 --> 00:18:05,390
distributed as a separate binary data

00:18:01,100 --> 00:18:08,750
file however in practice it's always

00:18:05,390 --> 00:18:10,670
stored in the standard thoughts and WCT

00:18:08,750 --> 00:18:13,160
app sections so when you look at a

00:18:10,670 --> 00:18:14,990
kernel of OpenBSD these days you'll see

00:18:13,160 --> 00:18:17,540
that it does have this particular

00:18:14,990 --> 00:18:19,940
section which means that it does have

00:18:17,540 --> 00:18:22,010
all the CTF data of all the symbols

00:18:19,940 --> 00:18:31,060
functions friable strings you name it

00:18:22,010 --> 00:18:36,290
it's in there so it can be considered a

00:18:31,060 --> 00:18:39,680
subset of dwarf but in reality it's more

00:18:36,290 --> 00:18:44,030
dd extracted form of whatever is

00:18:39,680 --> 00:18:44,780
relevant for DTrace or CTF or in our

00:18:44,030 --> 00:18:52,610
case right now

00:18:44,780 --> 00:18:54,710
DB dwarf also supports many other

00:18:52,610 --> 00:18:57,890
languages than what we care about in our

00:18:54,710 --> 00:19:03,110
kernel where we don't care about pascal

00:18:57,890 --> 00:19:07,760
or modular or c++ or whatever CTF is

00:19:03,110 --> 00:19:14,240
only concerned with C pure simple C no

00:19:07,760 --> 00:19:17,900
assembler that either so dwarf also

00:19:14,240 --> 00:19:20,660
contains information on line numbers to

00:19:17,900 --> 00:19:22,910
be able to map your code into line

00:19:20,660 --> 00:19:27,910
numbers of file information that is not

00:19:22,910 --> 00:19:32,870
part of CDF however it is information we

00:19:27,910 --> 00:19:35,060
are quite interested in in providing so

00:19:32,870 --> 00:19:38,410
right now for a developer to extracted

00:19:35,060 --> 00:19:41,660
information they have to be running a

00:19:38,410 --> 00:19:47,000
kernel which contains all the debug

00:19:41,660 --> 00:19:49,640
information however we generally don't

00:19:47,000 --> 00:19:53,060
recommend users running this kernel so

00:19:49,640 --> 00:19:55,580
when they do run into a crash we have to

00:19:53,060 --> 00:19:58,919
provide them with this kernel so they

00:19:55,580 --> 00:20:02,039
can retrigger the crash get you relevant

00:19:58,919 --> 00:20:05,179
it would be so much simpler if we could

00:20:02,039 --> 00:20:08,789
also save this information in some way

00:20:05,179 --> 00:20:21,299
not part of CTF but it's something that

00:20:08,789 --> 00:20:25,850
that that dwarf provides so here's an

00:20:21,299 --> 00:20:31,049
example of CTF dumb it's one of our own

00:20:25,850 --> 00:20:34,259
CTF tools so running this on the bsd

00:20:31,049 --> 00:20:37,109
kernel just shows the header with the

00:20:34,259 --> 00:20:39,299
CTF magic number

00:20:37,109 --> 00:20:41,609
diversion encoded and further

00:20:39,299 --> 00:20:44,879
information that's relevant to parsing

00:20:41,609 --> 00:20:47,639
tools of this fairly simple and

00:20:44,879 --> 00:20:51,840
structured format it's not like dwarf

00:20:47,639 --> 00:20:54,840
where you have your completion you need

00:20:51,840 --> 00:21:00,239
your your debugging information entry

00:20:54,840 --> 00:21:02,340
and all sorts of extra tags and fields

00:21:00,239 --> 00:21:03,799
that you need to parse in order to get

00:21:02,340 --> 00:21:08,820
whatever is relevant

00:21:03,799 --> 00:21:11,509
so for dwarf the relevant information is

00:21:08,820 --> 00:21:15,960
stored primarily in two sections the

00:21:11,509 --> 00:21:21,869
info debug info and debug abbreviation

00:21:15,960 --> 00:21:25,859
section abbreviated to RF so within the

00:21:21,869 --> 00:21:30,739
compilation unit a die is generated for

00:21:25,859 --> 00:21:34,889
every variable type function etc and

00:21:30,739 --> 00:21:38,789
these dies themselves can be attacked

00:21:34,889 --> 00:21:41,239
with whatever is applicable to this this

00:21:38,789 --> 00:21:46,139
die so it can be attacked as a rival or

00:21:41,239 --> 00:21:51,570
a pointer as well as attributes relevant

00:21:46,139 --> 00:21:54,570
to it and because dice can be nested it

00:21:51,570 --> 00:21:57,779
creates a tree like structure that tools

00:21:54,570 --> 00:22:01,230
like a dwarf them are able to traverse

00:21:57,779 --> 00:22:07,640
and dump a representation of the elf of

00:22:01,230 --> 00:22:10,580
authority dwarf information so this is a

00:22:07,640 --> 00:22:14,600
some outputs of dwarf them with all the

00:22:10,580 --> 00:22:18,770
information it knows about this object

00:22:14,600 --> 00:22:30,429
file and most of it is quite relevant to

00:22:18,770 --> 00:22:33,049
a debugger but not for CTF so the dwarf

00:22:30,429 --> 00:22:40,910
code that gets generated in open BSD

00:22:33,049 --> 00:22:43,070
right now is dwarf to a newer versions

00:22:40,910 --> 00:22:46,340
of dwarf have been released in over

00:22:43,070 --> 00:22:50,179
recent years so for example version 3

00:22:46,340 --> 00:22:53,950
added support for c++ or better support

00:22:50,179 --> 00:22:56,870
for c++ fortran 90 allocatable data

00:22:53,950 --> 00:22:58,940
version 4 came with better compression

00:22:56,870 --> 00:23:01,880
which is interesting but also support

00:22:58,940 --> 00:23:07,130
for c++ then which well we have no use

00:23:01,880 --> 00:23:10,160
for in our kernel version luckily person

00:23:07,130 --> 00:23:11,110
5 was released earlier this date this

00:23:10,160 --> 00:23:14,929
year

00:23:11,110 --> 00:23:17,270
standardized actually and came with many

00:23:14,929 --> 00:23:20,179
other improvements such as what way

00:23:17,270 --> 00:23:23,030
better compression still faster lookups

00:23:20,179 --> 00:23:27,080
better annotations and descriptions

00:23:23,030 --> 00:23:31,940
however the compiler we have right now

00:23:27,080 --> 00:23:34,610
doesn't fully amidst war 5 but it may be

00:23:31,940 --> 00:23:38,750
at one point interesting to move further

00:23:34,610 --> 00:23:40,130
along with what our tools can use since

00:23:38,750 --> 00:23:42,610
they're currently still limited to

00:23:40,130 --> 00:23:42,610
version 2

00:23:59,050 --> 00:24:06,590
so CTF tools it's great to have an

00:24:04,190 --> 00:24:10,010
object file which contains the dwarf

00:24:06,590 --> 00:24:11,750
information but in order to make

00:24:10,010 --> 00:24:16,340
something useful out of it and to turn

00:24:11,750 --> 00:24:19,280
it into CTF we need a number of tools so

00:24:16,340 --> 00:24:21,590
Solaris developed the city of tools

00:24:19,280 --> 00:24:26,360
package which contains city of convert

00:24:21,590 --> 00:24:30,530
merge and dump however their cvd are

00:24:26,360 --> 00:24:33,590
licensed so there was a a blocker for us

00:24:30,530 --> 00:24:39,010
to move forward with CTF since we

00:24:33,590 --> 00:24:42,800
couldn't import it into our tree back in

00:24:39,010 --> 00:24:45,470
2016 we did import it into ports where

00:24:42,800 --> 00:24:48,260
were a bit more lenient when it comes to

00:24:45,470 --> 00:24:49,360
licensing and it's using the lip dwarf

00:24:48,260 --> 00:24:51,920
and lip elf

00:24:49,360 --> 00:24:56,570
libraries which we don't have in base

00:24:51,920 --> 00:24:59,320
either and it was quite the effort to

00:24:56,570 --> 00:25:03,500
find the right combination of

00:24:59,320 --> 00:25:06,740
lip L for not using lip elf to port the

00:25:03,500 --> 00:25:11,240
Solaris specific data structures to open

00:25:06,740 --> 00:25:17,750
BSD which applies specifically to city

00:25:11,240 --> 00:25:22,370
of merge at some point we may also want

00:25:17,750 --> 00:25:25,160
to use lips ETF if we have enough

00:25:22,370 --> 00:25:28,760
consumers in the base system right now

00:25:25,160 --> 00:25:31,220
we only have a very small number but as

00:25:28,760 --> 00:25:33,290
its usage increases we could also

00:25:31,220 --> 00:25:36,080
distribute that is part of the base

00:25:33,290 --> 00:25:41,260
system it is part of other operating

00:25:36,080 --> 00:25:44,960
systems on the other hands so having the

00:25:41,260 --> 00:25:48,080
CDL license CTF tools and ports was a

00:25:44,960 --> 00:25:51,890
great Kickstarter for us to move forward

00:25:48,080 --> 00:25:57,500
not worry about this part of the problem

00:25:51,890 --> 00:26:00,220
but actually move forward on using the

00:25:57,500 --> 00:26:00,220
CTF data

00:26:01,100 --> 00:26:09,830
so MPI set out to rewriting rather

00:26:06,559 --> 00:26:13,769
creating a new implementation under a

00:26:09,830 --> 00:26:16,980
more liberal license that it is fit for

00:26:13,769 --> 00:26:19,580
inclusion in the open BSD basis so we

00:26:16,980 --> 00:26:23,100
ended up with CTF conf which has

00:26:19,580 --> 00:26:28,230
functionality similar or equivalent to

00:26:23,100 --> 00:26:29,870
CTF convert we dropped CTF merge I'll

00:26:28,230 --> 00:26:35,519
tell you why in a bit

00:26:29,870 --> 00:26:38,340
we have CTF dump which is a visual

00:26:35,519 --> 00:26:43,309
representation of the CTF data which is

00:26:38,340 --> 00:26:44,700
a very helpful tool in verifying that

00:26:43,309 --> 00:26:47,100
CTF conf

00:26:44,700 --> 00:26:52,320
actually works and generates what we

00:26:47,100 --> 00:26:57,830
expected it and then we have CTF

00:26:52,320 --> 00:27:01,409
straight and this is a really nice trick

00:26:57,830 --> 00:27:03,480
so our kernels now get built with minus

00:27:01,409 --> 00:27:08,399
G by default so they generate all the

00:27:03,480 --> 00:27:11,009
dwarf data and then we strip them but

00:27:08,399 --> 00:27:13,769
we're not using the regular strip we're

00:27:11,009 --> 00:27:17,309
using CTF strip which the CTF converts

00:27:13,769 --> 00:27:19,679
on the object file and if that fails it

00:27:17,309 --> 00:27:22,259
will fall back to plain strip which

00:27:19,679 --> 00:27:25,529
removes all the dwarf data and we end up

00:27:22,259 --> 00:27:29,309
with a regular kernel no Cydia however

00:27:25,529 --> 00:27:32,549
CTF convert worked it wrote out the CTF

00:27:29,309 --> 00:27:35,460
data into a separate file which we then

00:27:32,549 --> 00:27:37,950
use option copy to insert back into the

00:27:35,460 --> 00:27:41,460
object file and that's basically what

00:27:37,950 --> 00:27:44,879
city of merge does it takes all the

00:27:41,460 --> 00:27:47,779
object files and merges all of their

00:27:44,879 --> 00:27:51,000
city of data into a single

00:27:47,779 --> 00:27:56,309
representation which then gets entered

00:27:51,000 --> 00:27:59,820
into the final object file that's quite

00:27:56,309 --> 00:28:05,070
a complex process the merging itself but

00:27:59,820 --> 00:28:08,369
also to insert the data into the object

00:28:05,070 --> 00:28:12,539
file and we have obscure P in inve so

00:28:08,369 --> 00:28:15,269
why not make small little shortcuts

00:28:12,539 --> 00:28:18,239
and use what's there already maybe at

00:28:15,269 --> 00:28:22,039
some point we can add more smarts to see

00:28:18,239 --> 00:28:26,070
Jeff's trip but then we basically end up

00:28:22,039 --> 00:28:36,869
implementing large parts of obscure P in

00:28:26,070 --> 00:28:40,229
CGS trips oh yeah why why go there so

00:28:36,869 --> 00:28:44,009
that said we do have CTF data available

00:28:40,229 --> 00:28:47,309
for all our platforms right now we have

00:28:44,009 --> 00:28:51,589
some support for it in DDP which allows

00:28:47,309 --> 00:28:58,129
all the platforms to make use of this

00:28:51,589 --> 00:29:00,599
there are some some portability or tasks

00:28:58,129 --> 00:29:03,539
related to portability in other parts of

00:29:00,599 --> 00:29:07,639
this effort but CTF is available for all

00:29:03,539 --> 00:29:07,639
our platforms and all our kernels so

00:29:08,779 --> 00:29:14,609
this is a quick example of running CTF

00:29:12,269 --> 00:29:18,599
jump on a kernel from a couple of weeks

00:29:14,609 --> 00:29:22,440
ago displaying the strengths available

00:29:18,599 --> 00:29:25,919
in the object fountain or the current on

00:29:22,440 --> 00:29:29,759
these guys so the first column are the

00:29:25,919 --> 00:29:33,029
indices which are referred to from other

00:29:29,759 --> 00:29:37,219
parts of the city of data as we can see

00:29:33,029 --> 00:29:37,219
right here for example for the types

00:29:43,510 --> 00:29:53,030
so in this representation we can see

00:29:47,510 --> 00:29:56,870
that the type integer has index 12 its

00:29:53,030 --> 00:29:58,610
encoding assigns and the others it's

00:29:56,870 --> 00:30:02,090
it's a long way so I just snipped it for

00:29:58,610 --> 00:30:05,240
brevity but here we can see how it's

00:30:02,090 --> 00:30:08,360
used so for example the DB no marks

00:30:05,240 --> 00:30:10,760
function which is used by the trace

00:30:08,360 --> 00:30:14,660
command from DB to look up the number of

00:30:10,760 --> 00:30:17,720
arguments that function has so it's

00:30:14,660 --> 00:30:29,240
index is four thousand nine and it

00:30:17,720 --> 00:30:32,150
returns 12 d12 refers back to the so the

00:30:29,240 --> 00:30:34,640
twelfth up here refers back to the

00:30:32,150 --> 00:30:37,160
twelve ter so we know that D be no marks

00:30:34,640 --> 00:30:41,120
returns an integer which in this case is

00:30:37,160 --> 00:30:44,680
the number of arguments we can also see

00:30:41,120 --> 00:30:50,030
that its arguments are of these types

00:30:44,680 --> 00:30:52,250
which is a pointer which refers to a

00:30:50,030 --> 00:30:55,960
struct so we know that the first

00:30:52,250 --> 00:31:01,540
arguments of DB no marks is a struct

00:30:55,960 --> 00:31:06,500
call frame struct we can defer the rest

00:31:01,540 --> 00:31:09,860
based on what else is there so this is

00:31:06,500 --> 00:31:13,270
also an interesting way of parsing all

00:31:09,860 --> 00:31:17,470
your your functions and mapping their

00:31:13,270 --> 00:31:17,470
types and their arguments

00:31:20,360 --> 00:31:30,629
so d DB DB is the in kernel debugger of

00:31:26,629 --> 00:31:34,950
obvious DS and it was actually the first

00:31:30,629 --> 00:31:39,690
consumer of CTF data so back at the the

00:31:34,950 --> 00:31:44,340
hackathon 2016 we started working on CTF

00:31:39,690 --> 00:31:46,529
and we needed a way to verify that the

00:31:44,340 --> 00:31:49,409
work we were doing was valid and would

00:31:46,529 --> 00:31:52,190
actually lead to somewhere and DDP

00:31:49,409 --> 00:31:55,259
seemed like the obvious starting point

00:31:52,190 --> 00:31:58,049
which for me was a very fun and

00:31:55,259 --> 00:32:00,809
challenging project during the hackathon

00:31:58,049 --> 00:32:04,409
to dive into the bootloader

00:32:00,809 --> 00:32:12,570
in order to load the city of data as

00:32:04,409 --> 00:32:16,019
well as an adventure in 2d DB so from

00:32:12,570 --> 00:32:19,559
within d DB we can inspect the CTF data

00:32:16,019 --> 00:32:20,820
of the currently running kernel so when

00:32:19,559 --> 00:32:25,799
the colonel gets loaded by the boot

00:32:20,820 --> 00:32:30,090
loader the dots and w's CTF data gets

00:32:25,799 --> 00:32:35,460
loaded and DB knows where it's loaded at

00:32:30,090 --> 00:32:40,100
and when required it it's using that

00:32:35,460 --> 00:32:42,870
data for example for trace so trace on

00:32:40,100 --> 00:32:47,129
amd64 and i386 at a time

00:32:42,870 --> 00:32:48,960
it showed you the function names but it

00:32:47,129 --> 00:32:51,840
couldn't figure out how many arguments

00:32:48,960 --> 00:32:55,710
the functions had other platforms such

00:32:51,840 --> 00:32:58,610
as sparc64 did have well architectural

00:32:55,710 --> 00:33:06,179
advantages and they could figure it out

00:32:58,610 --> 00:33:11,129
but aim d6 fri 36 couldn't later the P

00:33:06,179 --> 00:33:14,240
prints commando or commands became CTF

00:33:11,129 --> 00:33:18,750
aware and most recently the show structs

00:33:14,240 --> 00:33:24,090
commands as well so this is what trace

00:33:18,750 --> 00:33:27,210
looked like in DB before having CTF so

00:33:24,090 --> 00:33:31,830
as you can see it has no idea of the

00:33:27,210 --> 00:33:34,749
number of arguments and with DB

00:33:31,830 --> 00:33:39,879
yes at the PNTR still doesn't have any

00:33:34,749 --> 00:33:42,879
but the others are properly filled in so

00:33:39,879 --> 00:33:44,889
that was the first validation of Wow so

00:33:42,879 --> 00:33:47,049
it's actually working what we're

00:33:44,889 --> 00:33:49,419
producing even though it's with the

00:33:47,049 --> 00:33:51,629
original CTF tools but still the way

00:33:49,419 --> 00:34:00,850
we're integrating it into our kernel

00:33:51,629 --> 00:34:03,249
does work so pretty printing and CPUs

00:34:00,850 --> 00:34:05,080
are pretty printing in general is using

00:34:03,249 --> 00:34:10,060
the CTF data in order to figure out how

00:34:05,080 --> 00:34:12,550
to represent the kernel data as

00:34:10,060 --> 00:34:22,569
something human readable and defer the

00:34:12,550 --> 00:34:29,379
types from it so as you can see we're

00:34:22,569 --> 00:34:35,790
printing the DB CTF variable and right

00:34:29,379 --> 00:34:38,859
here we have the city of header so using

00:34:35,790 --> 00:34:42,849
the show struct commands we know that

00:34:38,859 --> 00:34:46,089
it's a struct we can also print that and

00:34:42,849 --> 00:34:49,839
see everything that's contained in it so

00:34:46,089 --> 00:34:53,020
this is the city of header data of the

00:34:49,839 --> 00:34:56,520
kernel that's actually running right now

00:34:53,020 --> 00:34:56,520
or at the time

00:35:05,559 --> 00:35:13,609
so where are we at right now the dynamic

00:35:10,609 --> 00:35:17,720
profiling part from MPI was committed

00:35:13,609 --> 00:35:19,849
during the 2016 general hackathon and at

00:35:17,720 --> 00:35:22,720
that time we really made some great

00:35:19,849 --> 00:35:24,920
efforts into getting started and

00:35:22,720 --> 00:35:30,049
figuring out all the components needed

00:35:24,920 --> 00:35:33,319
at least CTF wise so we imported the

00:35:30,049 --> 00:35:35,059
original tools into ports and they're

00:35:33,319 --> 00:35:39,470
still there at the moment even though we

00:35:35,059 --> 00:35:41,740
have our own free tools in base system

00:35:39,470 --> 00:35:45,349
but I still serve as a useful reference

00:35:41,740 --> 00:35:48,890
implementation that hackathon the Ridgid

00:35:45,349 --> 00:35:54,920
original ddb code for CTF was committed

00:35:48,890 --> 00:35:58,040
as well and then about a year later the

00:35:54,920 --> 00:36:01,010
tools were imported into base and we

00:35:58,040 --> 00:36:04,790
actually built CTF enabled kernels by

00:36:01,010 --> 00:36:07,490
default so this was a huge step in

00:36:04,790 --> 00:36:10,880
moving forward and getting CTF to the

00:36:07,490 --> 00:36:13,609
people as it were so sometime after your

00:36:10,880 --> 00:36:18,650
hackathon actually one of our developers

00:36:13,609 --> 00:36:21,069
dlg committed go to remove the old ddb

00:36:18,650 --> 00:36:24,740
struct kernel compile-time option and

00:36:21,069 --> 00:36:30,099
have show struct use CTF so there was

00:36:24,740 --> 00:36:33,650
another way of moving forward and

00:36:30,099 --> 00:36:35,660
validating the efforts and as you can

00:36:33,650 --> 00:36:38,240
see the hackathons have been

00:36:35,660 --> 00:36:41,869
tremendously important in the

00:36:38,240 --> 00:36:43,569
development of not only CTF but of open

00:36:41,869 --> 00:36:45,890
BSD in general

00:36:43,569 --> 00:36:47,839
so what they are sponsored by the

00:36:45,890 --> 00:36:51,700
OpenBSD foundation but essentially

00:36:47,839 --> 00:36:51,700
funded by you so keep them coming

00:36:54,330 --> 00:37:01,830
of course there's still a lot more work

00:36:58,290 --> 00:37:04,080
to be done for example we could make an

00:37:01,830 --> 00:37:09,390
effort in catching up on modern or more

00:37:04,080 --> 00:37:13,620
recent work versions we could cut out

00:37:09,390 --> 00:37:16,710
CTF conf and see if the compiler could

00:37:13,620 --> 00:37:20,700
actually be made to work for us since it

00:37:16,710 --> 00:37:24,360
already knows all the the types and

00:37:20,700 --> 00:37:26,960
everything that has to go into Dwarf why

00:37:24,360 --> 00:37:31,500
not make an intermediate step and

00:37:26,960 --> 00:37:33,600
generate CTF right away of course there

00:37:31,500 --> 00:37:36,630
are some portability issues to be

00:37:33,600 --> 00:37:40,650
addressed still so for example the

00:37:36,630 --> 00:37:45,710
dynamic profiling part is only 4 MB 6436

00:37:40,650 --> 00:37:49,490
at the moment and we can extend the

00:37:45,710 --> 00:37:51,930
usage of CTF for trays into other

00:37:49,490 --> 00:37:56,360
architectures as well because most of

00:37:51,930 --> 00:37:56,360
them have been relying on their internal

00:37:56,510 --> 00:38:03,980
resolving of the number of arguments but

00:38:00,240 --> 00:38:09,600
why not make use of CTF since it's there

00:38:03,980 --> 00:38:12,860
of course eventually we may have dtrace

00:38:09,600 --> 00:38:16,470
it's still long ways down the road but

00:38:12,860 --> 00:38:17,790
we're making an effort and getting the

00:38:16,470 --> 00:38:20,520
word out to people and getting people

00:38:17,790 --> 00:38:25,640
interested and involved that will really

00:38:20,520 --> 00:38:25,640
help to get this completed

00:38:27,150 --> 00:38:37,230
so to recap we have our own ISP licensed

00:38:32,400 --> 00:38:39,510
CTF toolchain in base all our kernels

00:38:37,230 --> 00:38:43,200
are built with CTF data and properly

00:38:39,510 --> 00:38:45,330
inspected all through ddb still a long

00:38:43,200 --> 00:38:50,250
way to go but we're making good progress

00:38:45,330 --> 00:38:53,220
of course you can help so I'd like to

00:38:50,250 --> 00:38:56,790
thank MPI for always hard work at

00:38:53,220 --> 00:39:00,630
getting us started writing the tools and

00:38:56,790 --> 00:39:03,330
being well mental support of course your

00:39:00,630 --> 00:39:06,060
beautycon foundation for inviting me

00:39:03,330 --> 00:39:09,380
here and snow for having given me the

00:39:06,060 --> 00:39:09,380
time to attend this year's conference

00:39:10,280 --> 00:39:19,209
[Applause]

00:39:34,060 --> 00:39:39,770
well it's it's not 40 minutes it's it's

00:39:37,640 --> 00:39:43,430
part of the build process so it's

00:39:39,770 --> 00:39:46,750
something that users don't see or don't

00:39:43,430 --> 00:39:50,510
notice a delay when they boot a kernel

00:39:46,750 --> 00:39:58,310
it on a fast amd64 machine like this

00:39:50,510 --> 00:40:01,070
laptop it takes it I've actually not

00:39:58,310 --> 00:40:06,290
verified or tested how long CT of script

00:40:01,070 --> 00:40:09,170
tags on well arm 32 or something less

00:40:06,290 --> 00:40:12,430
fast but it'll probably several minutes

00:40:09,170 --> 00:40:12,430
and not 40

00:40:31,440 --> 00:40:38,120
[Music]

00:40:33,220 --> 00:40:40,790
yeah yeah definitely and I think we

00:40:38,120 --> 00:40:43,070
should spend the time as well to look at

00:40:40,790 --> 00:40:46,610
other architectures and see the impact

00:40:43,070 --> 00:40:48,760
there and extend and improve on those as

00:40:46,610 --> 00:40:48,760
well

00:41:11,910 --> 00:41:22,470
well so with the load bits elf black I

00:41:18,839 --> 00:41:24,690
believe that data gets also the CTF data

00:41:22,470 --> 00:41:28,829
also gets written out to your core file

00:41:24,690 --> 00:41:32,299
and then you can do post-mortem analysis

00:41:28,829 --> 00:41:35,069
on your your userland binary at least

00:41:32,299 --> 00:41:39,619
for now our effort is mainly focused

00:41:35,069 --> 00:41:42,000
towards the kernel but yeah it will be

00:41:39,619 --> 00:41:52,380
quite helpful to the post-mortem

00:41:42,000 --> 00:41:52,860
analysis and debugging eventually thank

00:41:52,380 --> 00:41:59,189
you

00:41:52,860 --> 00:41:59,189

YouTube URL: https://www.youtube.com/watch?v=yHKx57Wv6DA


