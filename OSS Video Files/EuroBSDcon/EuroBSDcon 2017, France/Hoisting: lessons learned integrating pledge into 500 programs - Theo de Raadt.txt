Title: Hoisting: lessons learned integrating pledge into 500 programs - Theo de Raadt
Publication date: 2019-10-16
Playlist: EuroBSDcon 2017, France
Description: 
	Description:

I would like to focus on lessons learned integrating pledge into 500 programs.
Probably emphasize how programs were subtly modified to fit the restrictive
model, with some examples. For instance, we further strengthened existing
privsep designs along the way because pledge showed the way. Another
conversation is about a dev process we call “hoisting”, invariant code found in
the main loop was pulled into pre-pledge initialization.

Speaker biography:

Theo is the founder and long time contributor to the OpenBSD project.
Captions: 
	00:00:00,030 --> 00:00:08,580
I I popped in and watch Gil talk about

00:00:04,890 --> 00:00:12,389
SMTP D and there was one particular

00:00:08,580 --> 00:00:13,889
slide that was interesting to me where

00:00:12,389 --> 00:00:18,150
he started talking about all security

00:00:13,889 --> 00:00:21,900
risks and trying to manage the design so

00:00:18,150 --> 00:00:24,750
that in case of a failure the the part

00:00:21,900 --> 00:00:26,760
of SMTP D wouldn't become a big risk

00:00:24,750 --> 00:00:32,700
factor and he used the word nightmare

00:00:26,760 --> 00:00:36,059
and pledge is just the latest piece of

00:00:32,700 --> 00:00:37,980
the puzzle for some things which have

00:00:36,059 --> 00:00:42,540
been worrying me for a long time and

00:00:37,980 --> 00:00:45,420
keeping me awake and it basically comes

00:00:42,540 --> 00:00:47,820
down to two papers I just want to get

00:00:45,420 --> 00:00:51,629
show of hands have how many of you have

00:00:47,820 --> 00:00:53,340
read either of these two papers okay

00:00:51,629 --> 00:00:55,920
actually do in a different way how many

00:00:53,340 --> 00:00:58,410
have read the first paper okay phew and

00:00:55,920 --> 00:00:59,879
how many have read the second paper okay

00:00:58,410 --> 00:01:04,110
all of you should read the second paper

00:00:59,879 --> 00:01:11,610
this is the most scary paper in computer

00:01:04,110 --> 00:01:14,250
science in the last 20 years and I was

00:01:11,610 --> 00:01:16,860
just stunned when I saw this paper as to

00:01:14,250 --> 00:01:18,960
as to the number of additional

00:01:16,860 --> 00:01:22,860
mitigations we're going to need in open

00:01:18,960 --> 00:01:25,439
BSD so first of all to get started the

00:01:22,860 --> 00:01:28,320
first one the first paper is about the

00:01:25,439 --> 00:01:29,990
about a methodology that you called raw

00:01:28,320 --> 00:01:31,890
which is used for attacking and

00:01:29,990 --> 00:01:33,750
originally people thought this was

00:01:31,890 --> 00:01:36,030
really was only a problem on x86

00:01:33,750 --> 00:01:38,220
architectures with some of their

00:01:36,030 --> 00:01:41,130
instruction formats and stuff like this

00:01:38,220 --> 00:01:42,840
so the guys in the first paper they

00:01:41,130 --> 00:01:46,909
actually went and did return oriented

00:01:42,840 --> 00:01:49,020
programming on sixth on 64-bit SPARC

00:01:46,909 --> 00:01:51,750
since they knew where the gadgets were

00:01:49,020 --> 00:01:54,030
they then wrote the C compiler a meaning

00:01:51,750 --> 00:01:57,000
C compiler that were directly from C

00:01:54,030 --> 00:01:59,009
code generate attack code and upload it

00:01:57,000 --> 00:02:02,070
directly into the application it was

00:01:59,009 --> 00:02:04,110
absolutely ridiculous just to show how

00:02:02,070 --> 00:02:06,600
many how much tooling just a couple of

00:02:04,110 --> 00:02:08,940
university graduates can build to have a

00:02:06,600 --> 00:02:13,040
complete straight from C to attack

00:02:08,940 --> 00:02:15,860
approach then acting blind

00:02:13,040 --> 00:02:17,480
is a paper about be robbed okay I'm just

00:02:15,860 --> 00:02:19,909
going to jump ahead explain so return

00:02:17,480 --> 00:02:22,819
oriented programming is where you hijack

00:02:19,909 --> 00:02:24,349
the controls flow normally you're going

00:02:22,819 --> 00:02:26,209
up and down the stack saving return

00:02:24,349 --> 00:02:28,250
addresses and jr. hat in your code all

00:02:26,209 --> 00:02:29,930
by yourself but in the return oriented

00:02:28,250 --> 00:02:32,060
program or what the attacker does is he

00:02:29,930 --> 00:02:34,189
uploads a replacement stack that

00:02:32,060 --> 00:02:36,620
contains return addresses but the return

00:02:34,189 --> 00:02:38,840
addresses return into tiny little

00:02:36,620 --> 00:02:42,739
fragments of the code which are called

00:02:38,840 --> 00:02:44,930
gadgets a gadget being a number of

00:02:42,739 --> 00:02:46,609
instructions before a return instruction

00:02:44,930 --> 00:02:48,950
and those number of instructions above

00:02:46,609 --> 00:02:51,560
the return instruction modify the

00:02:48,950 --> 00:02:53,180
registers somewhat in some way and by

00:02:51,560 --> 00:02:55,909
chaining these together with false

00:02:53,180 --> 00:02:57,739
return patterns he's sometimes able to

00:02:55,909 --> 00:03:00,079
generate perhaps even all the way to a

00:02:57,739 --> 00:03:03,189
tutoring complete behavior or perhaps

00:03:00,079 --> 00:03:06,970
just damage the machine and then return

00:03:03,189 --> 00:03:08,870
on on x86 architectures is even worse

00:03:06,970 --> 00:03:10,669
because you don't just have return

00:03:08,870 --> 00:03:12,439
instructions but because it's a variable

00:03:10,669 --> 00:03:14,930
size architecture you also have

00:03:12,439 --> 00:03:17,150
polymorphic sequences that occur in the

00:03:14,930 --> 00:03:19,030
in the in the instruction stream for

00:03:17,150 --> 00:03:21,620
example if you have an instruction which

00:03:19,030 --> 00:03:24,109
loads a value to register but the value

00:03:21,620 --> 00:03:26,180
it's loading contains two bytes III that

00:03:24,109 --> 00:03:28,099
but invites c3 will occur in the

00:03:26,180 --> 00:03:30,319
instruction scene it's a return and

00:03:28,099 --> 00:03:31,760
therefore the instructions before the

00:03:30,319 --> 00:03:33,470
load whatever their meaning may be

00:03:31,760 --> 00:03:35,239
they're not actual real instructions

00:03:33,470 --> 00:03:37,430
they weren't intended to be but they are

00:03:35,239 --> 00:03:38,540
instructions an attacker can actually

00:03:37,430 --> 00:03:41,209
use those as well

00:03:38,540 --> 00:03:43,760
so it's quite a terrible are terrifying

00:03:41,209 --> 00:03:45,319
architecture the attacker needs to know

00:03:43,760 --> 00:03:46,760
a few things and this is a recurring

00:03:45,319 --> 00:03:49,459
trend you'll notice that the attacker

00:03:46,760 --> 00:03:51,169
needs to knew a few things there's some

00:03:49,459 --> 00:03:53,500
other techniques called job than s crop

00:03:51,169 --> 00:03:57,530
which tie into this as well

00:03:53,500 --> 00:04:00,189
blind Rock is is based upon the

00:03:57,530 --> 00:04:03,169
observation of the fundamentals of

00:04:00,189 --> 00:04:05,239
learning about the outer space that you

00:04:03,169 --> 00:04:07,879
need for Rob what it is it's an address

00:04:05,239 --> 00:04:09,319
space Oracle and it works specifically

00:04:07,879 --> 00:04:11,750
against address spaces which have been

00:04:09,319 --> 00:04:14,329
reused for example if you take a process

00:04:11,750 --> 00:04:16,190
and you create a for copy of the process

00:04:14,329 --> 00:04:18,320
now it has the same one and if this

00:04:16,190 --> 00:04:20,449
process dies if your parent keeps on

00:04:18,320 --> 00:04:21,190
creating a new child which is exactly

00:04:20,449 --> 00:04:23,440
the same

00:04:21,190 --> 00:04:26,080
layout that is when beer up comes into

00:04:23,440 --> 00:04:28,240
play because across a socket what the

00:04:26,080 --> 00:04:30,190
attacker will do is he'll first look for

00:04:28,240 --> 00:04:32,710
a way to make the program fail in a way

00:04:30,190 --> 00:04:34,630
such that it crashes that's the easy

00:04:32,710 --> 00:04:36,310
part then he will search with his

00:04:34,630 --> 00:04:38,020
payloads that he's able to upload and

00:04:36,310 --> 00:04:40,210
try to find him circumstance where the

00:04:38,020 --> 00:04:41,980
program spins then he can close the

00:04:40,210 --> 00:04:44,500
socket but now he has a difference

00:04:41,980 --> 00:04:48,460
between two behaviors a stop and a spin

00:04:44,500 --> 00:04:50,200
and now he convinced around again trying

00:04:48,460 --> 00:04:52,750
to find if he can find a stop that's

00:04:50,200 --> 00:04:58,360
controlled by a spin and searching this

00:04:52,750 --> 00:04:59,560
way it sounds a bit of a logical jump

00:04:58,360 --> 00:05:02,170
it's described in the paper

00:04:59,560 --> 00:05:04,260
soon he can start guessing bite by bite

00:05:02,170 --> 00:05:07,150
what the stack protector cookie is and

00:05:04,260 --> 00:05:09,480
then soon after that he can start

00:05:07,150 --> 00:05:11,620
scanning the address space for where

00:05:09,480 --> 00:05:14,080
instruction sequences are which give him

00:05:11,620 --> 00:05:15,940
tremendous power such as writing out the

00:05:14,080 --> 00:05:18,580
entire code segment back over the socket

00:05:15,940 --> 00:05:20,530
to himself at which point he knows what

00:05:18,580 --> 00:05:23,050
the memory layout looks like and then he

00:05:20,530 --> 00:05:25,600
can upload a proper rap sequence because

00:05:23,050 --> 00:05:32,170
he has all the knowledge so it's very

00:05:25,600 --> 00:05:35,260
very scary technique now the problem at

00:05:32,170 --> 00:05:38,410
large is that software will never be

00:05:35,260 --> 00:05:40,450
perfect we just are not capable of doing

00:05:38,410 --> 00:05:42,190
it with the tools that we have today and

00:05:40,450 --> 00:05:45,100
the way that we apply those tools

00:05:42,190 --> 00:05:47,860
because it it really only takes one or

00:05:45,100 --> 00:05:52,000
two mistaken if statements to end up in

00:05:47,860 --> 00:05:54,550
a logic error which creates some sort of

00:05:52,000 --> 00:05:56,500
a memory a piece of memory has been

00:05:54,550 --> 00:05:58,810
damaged or a piece of memory has not

00:05:56,500 --> 00:06:01,120
been initialized and yet we're barreling

00:05:58,810 --> 00:06:03,550
on and therefore you can end up with all

00:06:01,120 --> 00:06:06,190
these consequent behavior and keeps on

00:06:03,550 --> 00:06:08,020
cascading this when software goes wrong

00:06:06,190 --> 00:06:10,510
it doesn't stop immediately at that

00:06:08,020 --> 00:06:12,490
fault I mean many of us have been in

00:06:10,510 --> 00:06:14,730
debuggers and seen a fault but have to

00:06:12,490 --> 00:06:17,530
back trace it to a condition that was

00:06:14,730 --> 00:06:19,510
completely unrelated and thousands and

00:06:17,530 --> 00:06:21,940
thousands of steps before hands and the

00:06:19,510 --> 00:06:24,340
software has simply kept on trying to do

00:06:21,940 --> 00:06:29,020
its job unaware that a condition has

00:06:24,340 --> 00:06:30,430
happened there's no hard failure so

00:06:29,020 --> 00:06:33,580
therefore I work on these things called

00:06:30,430 --> 00:06:34,860
mitigations there's small tweaks that

00:06:33,580 --> 00:06:39,450
are designed to

00:06:34,860 --> 00:06:44,640
to slow to hurt these are these attack

00:06:39,450 --> 00:06:47,220
methods so that either they they it's

00:06:44,640 --> 00:06:49,380
it's harder to either you can't exercise

00:06:47,220 --> 00:06:53,340
the full capability of what the method

00:06:49,380 --> 00:06:54,900
would normally give you or you or or

00:06:53,340 --> 00:06:59,280
completely stops it those those are

00:06:54,900 --> 00:07:06,270
those are more rare but it also spots

00:06:59,280 --> 00:07:09,090
cases in the run time where an anomalous

00:07:06,270 --> 00:07:10,500
condition occurs that that that we

00:07:09,090 --> 00:07:12,330
shouldn't continue on a farm and it

00:07:10,500 --> 00:07:14,160
tries to turn these into hard failures

00:07:12,330 --> 00:07:17,460
so we failed close so we can head

00:07:14,160 --> 00:07:20,600
towards robustness now robustness is a

00:07:17,460 --> 00:07:23,220
word that I've been struggling for a lot

00:07:20,600 --> 00:07:26,010
as to the way it's used in computer

00:07:23,220 --> 00:07:28,080
science so what we found a definition

00:07:26,010 --> 00:07:31,050
for robust and it's this crazy

00:07:28,080 --> 00:07:32,850
definition it suggests that that when a

00:07:31,050 --> 00:07:35,070
system starts breaking it should keep on

00:07:32,850 --> 00:07:37,620
trying to keep on running and I don't

00:07:35,070 --> 00:07:39,120
agree with that at all like it says it

00:07:37,620 --> 00:07:40,860
can recover I don't see how you can

00:07:39,120 --> 00:07:42,810
recover from a mistake that you didn't

00:07:40,860 --> 00:07:44,910
even know about this just doesn't seem a

00:07:42,810 --> 00:07:45,900
real this definition doesn't seem real

00:07:44,910 --> 00:07:47,970
to me at all

00:07:45,900 --> 00:07:51,330
that's not the way that that my

00:07:47,970 --> 00:07:53,460
experience with the debugger over the

00:07:51,330 --> 00:07:55,410
last couple of decades has been we don't

00:07:53,460 --> 00:07:57,480
have robustness and the reason is

00:07:55,410 --> 00:07:59,670
because we don't have a substantial set

00:07:57,480 --> 00:08:02,040
of feel close behaviors that cause

00:07:59,670 --> 00:08:04,470
software once it goes wrong to stop

00:08:02,040 --> 00:08:08,490
quickly instead it just keeps on

00:08:04,470 --> 00:08:12,990
barreling along so mitigations are

00:08:08,490 --> 00:08:16,170
supposed to try to stop us earlier now

00:08:12,990 --> 00:08:20,130
what's a good mitigation if we can

00:08:16,170 --> 00:08:22,890
diminish the effectiveness of an attack

00:08:20,130 --> 00:08:24,630
that's good it should be low overhead

00:08:22,890 --> 00:08:27,330
because nobody wants a five percent

00:08:24,630 --> 00:08:30,480
slowdown of their machine to gain the

00:08:27,330 --> 00:08:32,310
safety safety or for example in managed

00:08:30,480 --> 00:08:34,260
languages some types of problems people

00:08:32,310 --> 00:08:37,170
are dealing with parts of this with

00:08:34,260 --> 00:08:38,820
garbage collectors it's too slow right

00:08:37,170 --> 00:08:41,460
and then people don't you don't prefer

00:08:38,820 --> 00:08:43,260
not to use a type of tooling the the

00:08:41,460 --> 00:08:45,570
mitigation should be easier pretty easy

00:08:43,260 --> 00:08:46,730
to understand so that people don't get

00:08:45,570 --> 00:08:48,070
confused

00:08:46,730 --> 00:08:51,290
as to whether this thing is actually

00:08:48,070 --> 00:08:54,110
artificially slowing down or causing

00:08:51,290 --> 00:08:55,820
various problems for them and and we

00:08:54,110 --> 00:08:58,339
shouldn't assume that one mitigation is

00:08:55,820 --> 00:09:01,279
gonna solve a wide set of problems it

00:08:58,339 --> 00:09:03,079
might only solve one problem in one way

00:09:01,279 --> 00:09:04,730
but sometimes when we build these

00:09:03,079 --> 00:09:07,310
mitigations we can also be optimistic

00:09:04,730 --> 00:09:09,920
that two or three these mitigations near

00:09:07,310 --> 00:09:14,360
each other may combine into it as a

00:09:09,920 --> 00:09:19,519
slightly sort of stronger surface okay

00:09:14,360 --> 00:09:21,199
and if a mitigation is good it usually

00:09:19,519 --> 00:09:23,180
also develops a cult of people who

00:09:21,199 --> 00:09:25,100
believe that this mitigation is good and

00:09:23,180 --> 00:09:26,630
because some mitigations are not just

00:09:25,100 --> 00:09:29,029
automatic some of them actually requires

00:09:26,630 --> 00:09:29,990
some interplay with the developer it's

00:09:29,029 --> 00:09:31,880
good if you also have people who

00:09:29,990 --> 00:09:34,190
understand it well enough to believe in

00:09:31,880 --> 00:09:36,380
it and try to miss are try to modify

00:09:34,190 --> 00:09:39,589
their code to to become closer towards

00:09:36,380 --> 00:09:43,100
the behavior of the medication when I

00:09:39,589 --> 00:09:44,570
backtrack up to the types of so how an

00:09:43,100 --> 00:09:47,240
attack actually works and what people

00:09:44,570 --> 00:09:48,649
actually play with but the first thing

00:09:47,240 --> 00:09:52,459
the attacker needs is a need knowledge

00:09:48,649 --> 00:09:54,470
so he needs to find a bug okay after

00:09:52,459 --> 00:09:57,050
that the most powerful tool he has

00:09:54,470 --> 00:10:01,190
available to himself is that this

00:09:57,050 --> 00:10:02,779
substantial sips consistency in the

00:10:01,190 --> 00:10:04,819
address space layout at the moment of

00:10:02,779 --> 00:10:07,190
the crash generally the attacker is

00:10:04,819 --> 00:10:10,819
attacker on his machine has exactly the

00:10:07,190 --> 00:10:12,589
same binary that you have running on

00:10:10,819 --> 00:10:14,120
your machine so he knows what the

00:10:12,589 --> 00:10:15,649
instruction layout generated by the

00:10:14,120 --> 00:10:18,110
compiler was the instructions are

00:10:15,649 --> 00:10:19,940
generally in exactly the same place he

00:10:18,110 --> 00:10:21,980
knows this address based randomization

00:10:19,940 --> 00:10:23,750
in play so for example the shared

00:10:21,980 --> 00:10:25,610
libraries may be a different place but

00:10:23,750 --> 00:10:27,620
he has the same shared libraries as you

00:10:25,610 --> 00:10:29,449
so the fixed offsets within the

00:10:27,620 --> 00:10:30,980
executable are the same and the fixed

00:10:29,449 --> 00:10:33,260
offsets within the shared libraries are

00:10:30,980 --> 00:10:35,449
the same there's also a stack which

00:10:33,260 --> 00:10:37,459
could be anywhere but that stack inside

00:10:35,449 --> 00:10:39,889
itself also has objects in the same

00:10:37,459 --> 00:10:41,389
consistent order so even though base

00:10:39,889 --> 00:10:43,699
addresses for these objects are

00:10:41,389 --> 00:10:45,380
randomized the relative addresses

00:10:43,699 --> 00:10:47,540
between these objects are still the same

00:10:45,380 --> 00:10:49,880
the attacker finds himself in a

00:10:47,540 --> 00:10:52,190
circumstance where he has registers

00:10:49,880 --> 00:10:53,899
available at that attack moment and some

00:10:52,190 --> 00:10:56,209
of them are fixed values because the

00:10:53,899 --> 00:10:58,970
compile the code as it was running has

00:10:56,209 --> 00:11:01,160
these variables in these known load

00:10:58,970 --> 00:11:04,070
in these known conditions but also

00:11:01,160 --> 00:11:06,050
certain registers have pointers in them

00:11:04,070 --> 00:11:07,340
and these pointers may be inside an

00:11:06,050 --> 00:11:10,370
object which he doesn't know the address

00:11:07,340 --> 00:11:12,320
for but he knows what thing in that

00:11:10,370 --> 00:11:14,420
object it is so therefore he may have a

00:11:12,320 --> 00:11:16,220
pointer to a function in live C but

00:11:14,420 --> 00:11:17,750
therefore at a fixed offset off that

00:11:16,220 --> 00:11:20,480
thing inside let's see there's another

00:11:17,750 --> 00:11:22,070
object so this consistency is a very

00:11:20,480 --> 00:11:26,000
powerful thing for the attacker to

00:11:22,070 --> 00:11:28,370
utilize he also uses things these things

00:11:26,000 --> 00:11:29,870
called gadgets this is the constants

00:11:28,370 --> 00:11:31,610
like I said the pointers in the register

00:11:29,870 --> 00:11:36,050
values he combines these things using a

00:11:31,610 --> 00:11:38,090
variety of of of he he combines these

00:11:36,050 --> 00:11:42,860
with these with with the gadgets to try

00:11:38,090 --> 00:11:45,110
to build to get towards his goal so the

00:11:42,860 --> 00:11:47,690
mechanism users with gadgets to the ends

00:11:45,110 --> 00:11:50,600
up reusing code that you already have

00:11:47,690 --> 00:11:53,030
inside your that's inside your your

00:11:50,600 --> 00:11:54,980
binary and he tries to reach out toward

00:11:53,030 --> 00:11:56,720
system calls and eventually of course is

00:11:54,980 --> 00:11:58,790
going to be operating on file system on

00:11:56,720 --> 00:12:00,530
the file system space if possible or

00:11:58,790 --> 00:12:02,030
it's going to be trying to do operations

00:12:00,530 --> 00:12:03,740
and open file descriptors such as

00:12:02,030 --> 00:12:06,410
sockets or wherever else so that's the

00:12:03,740 --> 00:12:09,170
components and this is the area where we

00:12:06,410 --> 00:12:10,550
want to start messing things with so how

00:12:09,170 --> 00:12:13,070
do we mess with that I'm just going to

00:12:10,550 --> 00:12:15,620
show a couple of examples so over 17

00:12:13,070 --> 00:12:16,970
years these are the types of medications

00:12:15,620 --> 00:12:21,130
that we've been squeezing into the

00:12:16,970 --> 00:12:25,240
system to try to make it harder for

00:12:21,130 --> 00:12:28,160
things to work in an unorganized fashion

00:12:25,240 --> 00:12:30,860
many almost all of these things do not

00:12:28,160 --> 00:12:32,450
change any of the the normal way that

00:12:30,860 --> 00:12:34,250
any of you are supposed to do with

00:12:32,450 --> 00:12:36,860
software you're supposed to deal with

00:12:34,250 --> 00:12:38,750
the API that's provided by the functions

00:12:36,860 --> 00:12:40,640
and at some point you have

00:12:38,750 --> 00:12:42,770
considerations about the ABI of a

00:12:40,640 --> 00:12:44,930
function but almost all of these things

00:12:42,770 --> 00:12:47,060
operate at a level below that which are

00:12:44,930 --> 00:12:49,580
not things that are guaranteed by the

00:12:47,060 --> 00:12:54,080
system to work in a certain way so we're

00:12:49,580 --> 00:12:55,520
allowed to change these things the the

00:12:54,080 --> 00:13:00,170
ones in red are not done yet

00:12:55,520 --> 00:13:03,590
but they're work in progress so these

00:13:00,170 --> 00:13:07,890
things try to make a Burin software

00:13:03,590 --> 00:13:11,339
crash earlier

00:13:07,890 --> 00:13:13,079
and of course I'm a heretic because BSD

00:13:11,339 --> 00:13:15,029
got this wrong I've got this right many

00:13:13,079 --> 00:13:16,380
many years ago of course it was perfect

00:13:15,029 --> 00:13:18,630
there's no reason to change these

00:13:16,380 --> 00:13:20,940
underlying mechanisms but I think that's

00:13:18,630 --> 00:13:23,730
not true I think the rules of engagement

00:13:20,940 --> 00:13:25,740
with the you should with the user base

00:13:23,730 --> 00:13:28,019
the user base has first of all exploded

00:13:25,740 --> 00:13:30,060
inside that user base criminal elements

00:13:28,019 --> 00:13:31,380
have shown up people have gotten clever

00:13:30,060 --> 00:13:32,700
they've recognized that our machine

00:13:31,380 --> 00:13:35,370
architects aren't so good

00:13:32,700 --> 00:13:37,740
and the security concerns who didn't

00:13:35,370 --> 00:13:39,779
exist inside a small community 3040

00:13:37,740 --> 00:13:41,579
years ago they are now here and we have

00:13:39,779 --> 00:13:45,450
to deal with them so we cannot ignore

00:13:41,579 --> 00:13:47,339
these problems so I see academic papers

00:13:45,450 --> 00:13:48,810
all the time coming up with ideas to how

00:13:47,339 --> 00:13:52,380
they solve these problems and in the

00:13:48,810 --> 00:13:55,290
same vein I'm using open BSD to try to

00:13:52,380 --> 00:13:57,930
see if we can do a better job so it's a

00:13:55,290 --> 00:14:00,180
research for me open BSD is all about

00:13:57,930 --> 00:14:02,910
research in this area and I want to

00:14:00,180 --> 00:14:04,920
discover new these new patterns which

00:14:02,910 --> 00:14:06,990
will which will resolve some of these

00:14:04,920 --> 00:14:10,920
problems and have a very very powerful

00:14:06,990 --> 00:14:12,899
community and test zone around me which

00:14:10,920 --> 00:14:15,180
is basically the entire base operating

00:14:12,899 --> 00:14:17,579
system is a test zone and we have our

00:14:15,180 --> 00:14:19,529
ports tree which is something like 8,000

00:14:17,579 --> 00:14:21,390
pieces of software and if we can add a

00:14:19,529 --> 00:14:22,680
mitigation and it doesn't break 8,000

00:14:21,390 --> 00:14:25,740
pieces of software then we know we're on

00:14:22,680 --> 00:14:27,300
the right track and if we can find that

00:14:25,740 --> 00:14:28,560
it actually goes in breaks 20 pieces of

00:14:27,300 --> 00:14:29,550
software and it turns out those 20

00:14:28,560 --> 00:14:31,380
pieces of software have a pre-existing

00:14:29,550 --> 00:14:34,350
bug then we know we're on the right

00:14:31,380 --> 00:14:36,089
track also so once in a while a piece of

00:14:34,350 --> 00:14:37,769
software though once in awhile a

00:14:36,089 --> 00:14:39,570
mitigation we work actually does run

00:14:37,769 --> 00:14:41,310
into a bit of a wall and then we

00:14:39,570 --> 00:14:42,050
backtrack and see if we can find a way

00:14:41,310 --> 00:14:44,190
out of that

00:14:42,050 --> 00:14:47,040
so I'm skewing an example though that

00:14:44,190 --> 00:14:49,620
it's not like a one step process for

00:14:47,040 --> 00:14:52,769
example a SLR a SLR is been an open BSD

00:14:49,620 --> 00:14:55,380
since 2001 and first of all we used it

00:14:52,769 --> 00:14:56,760
to randomize the for example I'm just

00:14:55,380 --> 00:14:58,529
gonna speak about shared libraries and

00:14:56,760 --> 00:15:00,449
stuff like that we randomized all the

00:14:58,529 --> 00:15:02,279
shared libraries so their base address

00:15:00,449 --> 00:15:04,440
so their base addresses for randomized

00:15:02,279 --> 00:15:05,699
we recognized pretty seen that since

00:15:04,440 --> 00:15:08,399
some of the shared libraries are fairly

00:15:05,699 --> 00:15:11,250
fixed sizes the gaps between them still

00:15:08,399 --> 00:15:13,380
looked a little bit familiar they were

00:15:11,250 --> 00:15:15,089
still men so two years later we

00:15:13,380 --> 00:15:17,100
randomize the order that we actually

00:15:15,089 --> 00:15:19,890
mapped the shared libraries and that was

00:15:17,100 --> 00:15:20,700
obvious and then we realized while

00:15:19,890 --> 00:15:22,860
they're packed together

00:15:20,700 --> 00:15:26,730
so in 2005 that we put little guard

00:15:22,860 --> 00:15:29,400
zones in between them and then in 2007 I

00:15:26,730 --> 00:15:30,990
mean this is just recently somebody

00:15:29,400 --> 00:15:32,430
discovered that you could that you could

00:15:30,990 --> 00:15:34,680
actually reach off the bottom and the

00:15:32,430 --> 00:15:36,960
stack and so we added a guard on the

00:15:34,680 --> 00:15:38,760
bottom of our randomly located stack and

00:15:36,960 --> 00:15:41,790
now I'm playing with actually

00:15:38,760 --> 00:15:44,220
randomizing the internal the internals

00:15:41,790 --> 00:15:46,590
of shared libraries and the kernel so

00:15:44,220 --> 00:15:48,840
for example I'm we're real inking lib

00:15:46,590 --> 00:15:50,640
see a draw at boot time where real

00:15:48,840 --> 00:15:53,160
inking lib see so that all the other

00:15:50,640 --> 00:15:55,470
binaries using that lib see actually the

00:15:53,160 --> 00:15:58,560
attacker will see I have a pointer into

00:15:55,470 --> 00:16:00,600
let's see but I don't know what offset

00:15:58,560 --> 00:16:02,760
printf is that I don't know where Wright

00:16:00,600 --> 00:16:04,320
is because there dot o files in the

00:16:02,760 --> 00:16:07,230
random library have been randomly linked

00:16:04,320 --> 00:16:10,610
to every single boot so it's another

00:16:07,230 --> 00:16:13,260
it's just the mitigation strategy so

00:16:10,610 --> 00:16:15,660
what's going on to get to backtrack we

00:16:13,260 --> 00:16:17,730
are we are trying to remove knowledge

00:16:15,660 --> 00:16:24,510
that an external attacker can discern

00:16:17,730 --> 00:16:26,550
from from outside we're trying to remove

00:16:24,510 --> 00:16:28,410
historical weaknesses of permission

00:16:26,550 --> 00:16:31,200
models that you're not supposed to rely

00:16:28,410 --> 00:16:33,750
on like for example the fact that that

00:16:31,200 --> 00:16:36,150
executable code is always readable like

00:16:33,750 --> 00:16:40,980
the fact that the right of my memory is

00:16:36,150 --> 00:16:42,780
always readable like that's static Const

00:16:40,980 --> 00:16:44,250
the data used to be in the data segment

00:16:42,780 --> 00:16:45,900
we now have it in there are Oh data

00:16:44,250 --> 00:16:49,920
segments we're trying to do things like

00:16:45,900 --> 00:16:51,840
this but it's not enough it's not enough

00:16:49,920 --> 00:16:54,780
doing these low-level changes is not

00:16:51,840 --> 00:16:57,000
enough it's great but it's not enough

00:16:54,780 --> 00:16:58,860
because if someone can still bypass all

00:16:57,000 --> 00:17:01,530
of these low-level mitigations and still

00:16:58,860 --> 00:17:05,760
succeed at actually executing code then

00:17:01,530 --> 00:17:07,440
he can do go do system calls so we've

00:17:05,760 --> 00:17:09,750
done a pretty good job at getting rid of

00:17:07,440 --> 00:17:11,790
the low-level things that they're not

00:17:09,750 --> 00:17:13,920
for the knowledge for the attacker but

00:17:11,790 --> 00:17:16,199
it's time to start working on more sort

00:17:13,920 --> 00:17:18,030
of structured control things and the way

00:17:16,199 --> 00:17:20,490
system calls are used to access to the

00:17:18,030 --> 00:17:28,170
resources so we're still concerned about

00:17:20,490 --> 00:17:29,580
that area over there I've got a slightly

00:17:28,170 --> 00:17:31,650
different way of looking at the problem

00:17:29,580 --> 00:17:33,120
originally people used to do stack

00:17:31,650 --> 00:17:36,240
overflow type of

00:17:33,120 --> 00:17:38,070
tax with directly putting the the code

00:17:36,240 --> 00:17:40,470
right there and then we made it so they

00:17:38,070 --> 00:17:42,270
couldn't write out to the staff so those

00:17:40,470 --> 00:17:44,520
are the mitigations we added in that era

00:17:42,270 --> 00:17:46,559
and then we Rob came in we started

00:17:44,520 --> 00:17:48,720
privilege separating programs so the

00:17:46,559 --> 00:17:51,180
address space between the two sides was

00:17:48,720 --> 00:17:52,380
more different but then B Rob came along

00:17:51,180 --> 00:17:54,120
and told us we're not allowed to share

00:17:52,380 --> 00:17:56,160
address spaces so we started doing forth

00:17:54,120 --> 00:17:57,510
in exact and now we're working on pledge

00:17:56,160 --> 00:18:00,120
and red card we're gonna try to make the

00:17:57,510 --> 00:18:01,680
code segments execute only okay and then

00:18:00,120 --> 00:18:04,410
we're gonna try to see if we can get rid

00:18:01,680 --> 00:18:06,090
of the polymorphic returns in the in the

00:18:04,410 --> 00:18:08,309
actually in the text segment as well

00:18:06,090 --> 00:18:11,370
pretty crazy stuff pretty crazy stuff

00:18:08,309 --> 00:18:13,020
don't know if it's ever gonna finish so

00:18:11,370 --> 00:18:16,290
but I just want to talk about this area

00:18:13,020 --> 00:18:19,710
over there okay so privilege separation

00:18:16,290 --> 00:18:23,370
is a strategy a design pattern that we

00:18:19,710 --> 00:18:30,480
started doing an open BSD 2004 Hennig

00:18:23,370 --> 00:18:30,929
about 2004 sshd ssh marcus Friedel Niels

00:18:30,480 --> 00:18:39,270
Provos

00:18:30,929 --> 00:18:40,890
mm mm yeah yeah so sshd was basically

00:18:39,270 --> 00:18:42,780
the first major privilege separate

00:18:40,890 --> 00:18:44,910
program which used bob scripture passing

00:18:42,780 --> 00:18:46,050
there were two programs before hands

00:18:44,910 --> 00:18:49,380
which did which were privileged

00:18:46,050 --> 00:18:52,470
separated they were postfix and Kumail

00:18:49,380 --> 00:18:56,070
okay Kumail did it by filesystem

00:18:52,470 --> 00:18:59,220
scanning postfix did it by passing

00:18:56,070 --> 00:19:00,600
objects over pipes but sshd was the

00:18:59,220 --> 00:19:02,700
first one which started doing file

00:19:00,600 --> 00:19:05,850
descriptor passing so father stripper

00:19:02,700 --> 00:19:08,070
passing is the fundamental concept that

00:19:05,850 --> 00:19:10,950
we use now for in between in many of our

00:19:08,070 --> 00:19:14,340
demons the fundamental idea is pretty

00:19:10,950 --> 00:19:16,710
simple it's to take two parts of the

00:19:14,340 --> 00:19:19,020
program that follow different work

00:19:16,710 --> 00:19:20,400
domains and move them into separate

00:19:19,020 --> 00:19:23,660
processes and have them communicate

00:19:20,400 --> 00:19:26,520
across an IPC mechanism of some sort

00:19:23,660 --> 00:19:27,780
it's really really simple so if you've

00:19:26,520 --> 00:19:29,670
got a piece of code that you just don't

00:19:27,780 --> 00:19:31,590
trust then you go put it off in a

00:19:29,670 --> 00:19:32,940
separate process and does the work but

00:19:31,590 --> 00:19:34,650
you've got a front-end that goes and

00:19:32,940 --> 00:19:36,720
does the tricky stuff in the front in

00:19:34,650 --> 00:19:40,679
the front so you separate them out a

00:19:36,720 --> 00:19:44,490
really good example did anybody see that

00:19:40,679 --> 00:19:46,720
list of 300 TCP dump bugs about a week

00:19:44,490 --> 00:19:51,400
ago yeah art

00:19:46,720 --> 00:19:53,140
hilarious hilarious III saw it and I and

00:19:51,400 --> 00:19:55,360
I ignored it I don't care about it

00:19:53,140 --> 00:19:57,789
because our TCP dump is written this way

00:19:55,360 --> 00:19:59,440
and all of those bugs are in the crap

00:19:57,789 --> 00:20:01,240
string tangle handling area of the

00:19:59,440 --> 00:20:03,610
software over there and we've completely

00:20:01,240 --> 00:20:05,230
locked that down but we used to use

00:20:03,610 --> 00:20:08,500
locking down using CH word and other

00:20:05,230 --> 00:20:09,970
things but if we don't use the CH or

00:20:08,500 --> 00:20:12,520
anything then the problem with this

00:20:09,970 --> 00:20:15,010
approach over here is we have separated

00:20:12,520 --> 00:20:17,830
the domains but really it's only in

00:20:15,010 --> 00:20:19,809
theory in theory that process could

00:20:17,830 --> 00:20:22,450
perhaps still do something he still has

00:20:19,809 --> 00:20:24,010
access to all the system calls and I

00:20:22,450 --> 00:20:26,200
didn't like them having the system calls

00:20:24,010 --> 00:20:28,150
so there's been many many ideas about

00:20:26,200 --> 00:20:30,669
how to separate system calls and contain

00:20:28,150 --> 00:20:32,980
them systrace was one of the original

00:20:30,669 --> 00:20:36,250
ones the ideas in that were copied and

00:20:32,980 --> 00:20:38,950
turned into SEC comp and Linux but I've

00:20:36,250 --> 00:20:41,740
never liked these because they is too

00:20:38,950 --> 00:20:43,720
low the abstraction is that the it

00:20:41,740 --> 00:20:45,520
forces developers to know what the

00:20:43,720 --> 00:20:47,350
system call numbers are then what the

00:20:45,520 --> 00:20:50,350
system calls are which are going to be

00:20:47,350 --> 00:20:52,630
used perhaps by layers and layers of

00:20:50,350 --> 00:20:54,640
library calls they have to the

00:20:52,630 --> 00:20:56,110
abstraction is all the way down so I

00:20:54,640 --> 00:20:59,909
wanted to do something which is more

00:20:56,110 --> 00:21:01,960
conceptual so that's what pledge is

00:20:59,909 --> 00:21:03,370
originally is called team but I thought

00:21:01,960 --> 00:21:07,240
the name is kind of tame and so change

00:21:03,370 --> 00:21:10,090
it to pledge so a pledge request is done

00:21:07,240 --> 00:21:13,650
by a process at the point after it's

00:21:10,090 --> 00:21:16,750
done initialization to lock out to

00:21:13,650 --> 00:21:19,270
register the types of functionality it

00:21:16,750 --> 00:21:20,799
will use in the future anything it's not

00:21:19,270 --> 00:21:21,309
going to use in the future it's simply a

00:21:20,799 --> 00:21:24,030
mess

00:21:21,309 --> 00:21:27,100
there's the subset are a little bit

00:21:24,030 --> 00:21:28,960
hokey sounding but they're hokey

00:21:27,100 --> 00:21:30,490
sounding because the entire idea is I'm

00:21:28,960 --> 00:21:34,090
trying to create a high level

00:21:30,490 --> 00:21:37,600
understanding of amongst the development

00:21:34,090 --> 00:21:39,640
community as what the types of parts of

00:21:37,600 --> 00:21:41,260
UNIX they're actually using so I had to

00:21:39,640 --> 00:21:43,480
come up with names for these sub

00:21:41,260 --> 00:21:45,360
components like standard i/o with the

00:21:43,480 --> 00:21:48,970
ability to read a path to write a path

00:21:45,360 --> 00:21:52,270
file attribute changes I net of course

00:21:48,970 --> 00:21:54,990
opening and managing sockets DNS we've

00:21:52,270 --> 00:21:58,929
separate DNS out from regular sockets a

00:21:54,990 --> 00:22:00,220
proc an executive fork an exact proc is

00:21:58,929 --> 00:22:01,720
not called fork because they

00:22:00,220 --> 00:22:02,890
gives you a couple of bit more things

00:22:01,720 --> 00:22:05,590
that you usually use when you're

00:22:02,890 --> 00:22:07,390
spawning a process things like this and

00:22:05,590 --> 00:22:10,059
it's not just done at the actual system

00:22:07,390 --> 00:22:12,730
call level some of the there's a few

00:22:10,059 --> 00:22:14,799
tricky bits that are done in the kernel

00:22:12,730 --> 00:22:16,539
too because we're trying to also because

00:22:14,799 --> 00:22:18,970
fundamentally we have to make sure Lipsy

00:22:16,539 --> 00:22:21,100
is happy we need to make sure Lipsy is

00:22:18,970 --> 00:22:23,830
happy we need to remove some of the

00:22:21,100 --> 00:22:24,940
warts and weird things that UNIX does so

00:22:23,830 --> 00:22:28,780
that people don't have to think about

00:22:24,940 --> 00:22:33,850
them directly so they're plastics

00:22:28,780 --> 00:22:36,340
subsets this is I think is very

00:22:33,850 --> 00:22:38,080
important for people to understand when

00:22:36,340 --> 00:22:40,210
you pledge a program there are no

00:22:38,080 --> 00:22:41,860
behavior changes except for that the

00:22:40,210 --> 00:22:44,830
parts you said you wouldn't use are

00:22:41,860 --> 00:22:46,390
inaccessible to you there are no error

00:22:44,830 --> 00:22:48,880
returns from any of these functions

00:22:46,390 --> 00:22:50,710
which you're not allowed to call if you

00:22:48,880 --> 00:22:53,370
use a piece of UNIX which you said you

00:22:50,710 --> 00:22:57,970
weren't gonna use your process is killed

00:22:53,370 --> 00:23:00,340
this stuff fails closed this is easy for

00:22:57,970 --> 00:23:02,620
developers to learn they don't have to

00:23:00,340 --> 00:23:04,570
go through their code and find places

00:23:02,620 --> 00:23:06,940
where they didn't check an error return

00:23:04,570 --> 00:23:09,039
and then the program keeps on cascading

00:23:06,940 --> 00:23:11,830
through failure by not having error

00:23:09,039 --> 00:23:17,760
returns we don't create new failure

00:23:11,830 --> 00:23:19,870
conditions that's very very important so

00:23:17,760 --> 00:23:23,080
this finally allows us to apply

00:23:19,870 --> 00:23:25,990
enforcement to the design that we had

00:23:23,080 --> 00:23:28,390
before the plants process over there

00:23:25,990 --> 00:23:29,950
it's a crappy string handling process

00:23:28,390 --> 00:23:32,380
over there where the pledge of standard

00:23:29,950 --> 00:23:36,669
i/o basically can only read or write

00:23:32,380 --> 00:23:39,640
back up towards its network speaker the

00:23:36,669 --> 00:23:42,039
standard i/o includes a variety of calls

00:23:39,640 --> 00:23:43,809
like read and write it has enough so

00:23:42,039 --> 00:23:46,690
that you can do a map it has the

00:23:43,809 --> 00:23:49,720
fundamentals that you would need for

00:23:46,690 --> 00:23:52,080
continued operation of a process without

00:23:49,720 --> 00:23:54,669
giving if any ability to allocate new

00:23:52,080 --> 00:23:54,940
descriptor resources or anything like

00:23:54,669 --> 00:23:57,429
that

00:23:54,940 --> 00:23:59,740
you cannot receive file descriptors you

00:23:57,429 --> 00:24:01,929
can only act upon what you already have

00:23:59,740 --> 00:24:04,419
see that's not hard anybody can do this

00:24:01,929 --> 00:24:06,010
anybody can do this and that was so

00:24:04,419 --> 00:24:08,289
strange about pledge coming in open BSD

00:24:06,010 --> 00:24:10,240
yet we had we had 50 new developers show

00:24:08,289 --> 00:24:12,970
up just out of the blue sending a pledge

00:24:10,240 --> 00:24:14,260
for a program they just showed up it was

00:24:12,970 --> 00:24:16,299
easy for them to do and they were very

00:24:14,260 --> 00:24:17,740
satisfied with their result and then

00:24:16,299 --> 00:24:22,659
they started becoming better and better

00:24:17,740 --> 00:24:24,490
developers after time so what kind of

00:24:22,659 --> 00:24:26,770
really is the second specification of

00:24:24,490 --> 00:24:29,280
what the program said we did that's them

00:24:26,770 --> 00:24:31,720
I think that's a very important point

00:24:29,280 --> 00:24:33,370
for people to understand that is what

00:24:31,720 --> 00:24:35,650
separates it from the other security

00:24:33,370 --> 00:24:38,020
designs other people are talking about

00:24:35,650 --> 00:24:42,900
there's no behavior changes and for

00:24:38,020 --> 00:24:45,429
example if you define pledge to zero and

00:24:42,900 --> 00:24:47,260
compile the entire OpenBSD tree it'll

00:24:45,429 --> 00:24:49,030
continue working the pledges haven't

00:24:47,260 --> 00:24:50,950
done anything they're just they're just

00:24:49,030 --> 00:24:57,520
a specification which will be

00:24:50,950 --> 00:25:00,880
mandatorily honored I've been sort of

00:24:57,520 --> 00:25:04,950
this slide over over a weird criticism

00:25:00,880 --> 00:25:09,340
that that pledges received sometimes

00:25:04,950 --> 00:25:11,110
many programs in UNIX are shells like of

00:25:09,340 --> 00:25:13,210
course the shell is a shell but there's

00:25:11,110 --> 00:25:14,890
other programs in the UNIX the UNIX

00:25:13,210 --> 00:25:16,360
model is with the shell you take two

00:25:14,890 --> 00:25:18,520
programs you pipe them together and

00:25:16,360 --> 00:25:21,429
that's your piping model for yourself

00:25:18,520 --> 00:25:23,799
but there are programs which do this

00:25:21,429 --> 00:25:25,780
spawning internally to themselves they

00:25:23,799 --> 00:25:28,150
just simply decide that they want to go

00:25:25,780 --> 00:25:31,720
run some sub command so they'll do a

00:25:28,150 --> 00:25:33,970
fork and an exec if we ignore that

00:25:31,720 --> 00:25:36,640
requirement then those programs cannot

00:25:33,970 --> 00:25:38,669
be protected with pledges at all they

00:25:36,640 --> 00:25:41,130
cannot be protected with capsicum either

00:25:38,669 --> 00:25:44,409
that cannot be protected with SATCOM

00:25:41,130 --> 00:25:47,470
you're not allowing a process to have a

00:25:44,409 --> 00:25:49,000
child and and continue on from there so

00:25:47,470 --> 00:25:50,830
therefore you can't protect the parent

00:25:49,000 --> 00:25:53,110
because you have to give the parent the

00:25:50,830 --> 00:25:56,289
ability to create a child it's just the

00:25:53,110 --> 00:25:58,990
reality you can't take that away so

00:25:56,289 --> 00:26:03,220
pledge has proc and exec permissions

00:25:58,990 --> 00:26:05,740
which permit these operations an exec ve

00:26:03,220 --> 00:26:07,960
turns off these plot the pledge features

00:26:05,740 --> 00:26:10,360
in the child it leaves them untouched in

00:26:07,960 --> 00:26:12,030
the parent because we anticipate that

00:26:10,360 --> 00:26:15,250
the new image we're about to execute

00:26:12,030 --> 00:26:16,960
will immediately since its open BSD and

00:26:15,250 --> 00:26:18,789
everything almost everything is pledged

00:26:16,960 --> 00:26:21,280
will immediately pledged itself and

00:26:18,789 --> 00:26:23,169
during that window when it starts up and

00:26:21,280 --> 00:26:24,970
when it actually pledges it's not

00:26:23,169 --> 00:26:26,380
actually doing any real work yet it's

00:26:24,970 --> 00:26:27,730
just initializing

00:26:26,380 --> 00:26:31,929
so that it can get to the point where it

00:26:27,730 --> 00:26:33,490
calls Pledge so an OpenSSH sh for

00:26:31,929 --> 00:26:37,870
example since it with the way its

00:26:33,490 --> 00:26:39,309
pledged if you find a bug in it and you

00:26:37,870 --> 00:26:41,950
manage to actually start running some

00:26:39,309 --> 00:26:44,020
rough code in it you'll discover that

00:26:41,950 --> 00:26:46,330
you can't open sockets you'll discover

00:26:44,020 --> 00:26:48,789
you can't pass file descriptors you

00:26:46,330 --> 00:26:50,500
can't do dns lookups that process that k

00:26:48,789 --> 00:26:53,230
shell is not supposed to do those things

00:26:50,500 --> 00:26:55,150
and it never has done those things the

00:26:53,230 --> 00:26:57,490
work that type of work is actually done

00:26:55,150 --> 00:26:59,230
by if going and asking another program

00:26:57,490 --> 00:27:02,200
to do it that's it doesn't do them it

00:26:59,230 --> 00:27:08,110
selves so these programs are protected

00:27:02,200 --> 00:27:09,760
about 20 of them also watching the

00:27:08,110 --> 00:27:12,750
developers who started playing with

00:27:09,760 --> 00:27:16,330
pledge that we noticed another

00:27:12,750 --> 00:27:18,789
development technique show up and we

00:27:16,330 --> 00:27:22,330
soon started calling it wasting and it

00:27:18,789 --> 00:27:26,140
it was very interesting watching the

00:27:22,330 --> 00:27:28,450
disappointment to glee sequence occur

00:27:26,140 --> 00:27:30,549
multiple times a person will take a

00:27:28,450 --> 00:27:32,590
program a quite a large program at a

00:27:30,549 --> 00:27:34,330
pledge to add pledge to it and they'll

00:27:32,590 --> 00:27:35,950
discover soon that their promises

00:27:34,330 --> 00:27:38,470
they're adding to it are wrapping off

00:27:35,950 --> 00:27:42,150
the end of the line the program needs

00:27:38,470 --> 00:27:44,350
almost all the resources and so it works

00:27:42,150 --> 00:27:46,900
and they're happy but they're not really

00:27:44,350 --> 00:27:48,700
happy but now that they know what the

00:27:46,900 --> 00:27:50,830
parts of unix are that the program uses

00:27:48,700 --> 00:27:52,539
later on they'll take one of those

00:27:50,830 --> 00:27:54,490
keywords and knowing what it does

00:27:52,539 --> 00:27:56,590
they'll go through the program and

00:27:54,490 --> 00:27:58,630
they'll search for initialization code

00:27:56,590 --> 00:28:00,730
which uses that functionality later on

00:27:58,630 --> 00:28:02,530
and they'll try to move it to the top of

00:28:00,730 --> 00:28:05,020
the program hoisting it is the word that

00:28:02,530 --> 00:28:06,580
we started calling it and then if

00:28:05,020 --> 00:28:08,350
they're successful then they can remove

00:28:06,580 --> 00:28:10,059
that pledge and now they're super happy

00:28:08,350 --> 00:28:11,980
and therefore they go and look at the

00:28:10,059 --> 00:28:13,809
next one that they can do the same thing

00:28:11,980 --> 00:28:15,970
with so we've had programs that

00:28:13,809 --> 00:28:19,390
initially were pledged and had something

00:28:15,970 --> 00:28:21,250
like like 20 like 20 promises and after

00:28:19,390 --> 00:28:23,740
successive refactorings people have

00:28:21,250 --> 00:28:25,840
gotten down to four or five there's a

00:28:23,740 --> 00:28:27,010
there's an effort going on in our TCP

00:28:25,840 --> 00:28:29,980
dump right now that's really

00:28:27,010 --> 00:28:32,679
ridiculously funny the things the thing

00:28:29,980 --> 00:28:34,600
is just being really speed dumps

00:28:32,679 --> 00:28:36,970
internals are just being a rearrange and

00:28:34,600 --> 00:28:38,590
Wynn's things done both of the processes

00:28:36,970 --> 00:28:39,440
will have almost no permissions it's

00:28:38,590 --> 00:28:41,480
just ink

00:28:39,440 --> 00:28:45,830
it's just incredible to watch it people

00:28:41,480 --> 00:28:47,600
really get involved in this I'm also

00:28:45,830 --> 00:28:49,820
working with that two other developers

00:28:47,600 --> 00:28:52,580
on a file system containment model

00:28:49,820 --> 00:28:56,600
called pledged path flex path will be

00:28:52,580 --> 00:28:59,210
done before pledge it is a registration

00:28:56,600 --> 00:29:00,950
mechanism where you register files that

00:28:59,210 --> 00:29:03,260
you're interested in files or

00:29:00,950 --> 00:29:05,690
directories you register them and the V

00:29:03,260 --> 00:29:07,760
node is grabbed and held and then later

00:29:05,690 --> 00:29:11,000
on when you do the your standard open

00:29:07,760 --> 00:29:13,100
calls or snap calls or whatever else as

00:29:11,000 --> 00:29:15,260
permitted by your pledge promises later

00:29:13,100 --> 00:29:17,330
on it at that point will discover that

00:29:15,260 --> 00:29:19,460
this V node was one that you registered

00:29:17,330 --> 00:29:20,840
that you were interested in and then it

00:29:19,460 --> 00:29:22,760
will turn it into a file descriptor or

00:29:20,840 --> 00:29:29,150
allow you to directory traverse across

00:29:22,760 --> 00:29:30,950
it in a safe way it's I think it's gonna

00:29:29,150 --> 00:29:32,720
work out the semantics are a little bit

00:29:30,950 --> 00:29:34,490
weird but it doesn't have any time of

00:29:32,720 --> 00:29:37,090
time of check versus time of use risks

00:29:34,490 --> 00:29:39,230
so it fits the metaphor of fail closed

00:29:37,090 --> 00:29:44,150
we're not going to encourage people to

00:29:39,230 --> 00:29:46,580
use it in all scenarios and it also

00:29:44,150 --> 00:29:50,210
feels kind of right because the diff is

00:29:46,580 --> 00:29:54,460
under 300 lines so that's usually a sign

00:29:50,210 --> 00:29:54,460
that I'm had that something's done right

00:29:58,220 --> 00:30:02,570
so the the strength of pledge is that

00:30:00,919 --> 00:30:05,179
it's really easy for people to use and

00:30:02,570 --> 00:30:06,649
so they will use it and then it when

00:30:05,179 --> 00:30:08,809
they use it sometimes to refactor a

00:30:06,649 --> 00:30:10,879
program to make it better let's one

00:30:08,809 --> 00:30:12,379
speak up the fact that people will say

00:30:10,879 --> 00:30:15,110
it will only be used on simple programs

00:30:12,379 --> 00:30:20,990
so yeah we can't use it on Firefox it is

00:30:15,110 --> 00:30:23,299
this amorphous piece of junk it has no

00:30:20,990 --> 00:30:27,500
inherent security in it let alone

00:30:23,299 --> 00:30:29,480
privilege separation it's all basically

00:30:27,500 --> 00:30:30,860
written the old style of software where

00:30:29,480 --> 00:30:35,360
everything is just the function call

00:30:30,860 --> 00:30:37,789
away the layering is just not ready for

00:30:35,360 --> 00:30:40,009
this type of thing and so everything

00:30:37,789 --> 00:30:41,659
must be allowed in fact Firefox doesn't

00:30:40,009 --> 00:30:44,870
even run if you pledge it with all of

00:30:41,659 --> 00:30:46,970
our pledges because we it actually it it

00:30:44,870 --> 00:30:48,169
fundamentally uses everything and who

00:30:46,970 --> 00:30:50,389
knows when it will pull in a shared

00:30:48,169 --> 00:30:53,659
library to do to do more you just don't

00:30:50,389 --> 00:30:56,330
know so it can't be done but in contrast

00:30:53,659 --> 00:30:59,120
to that chrome was designed to be

00:30:56,330 --> 00:31:02,299
privileged separated from the start it

00:30:59,120 --> 00:31:04,009
the chrome was basically pretty much the

00:31:02,299 --> 00:31:05,779
fourth or fifth privileged separate

00:31:04,009 --> 00:31:11,240
program in the entire ecosystem

00:31:05,779 --> 00:31:13,960
you know queue mail post fix sshd then

00:31:11,240 --> 00:31:18,049
something else and then chrome and then

00:31:13,960 --> 00:31:22,940
we really started our rush with yeah but

00:31:18,049 --> 00:31:25,490
Chrome's outside OpenBSD yeah but chrome

00:31:22,940 --> 00:31:31,100
is already before that was chrome before

00:31:25,490 --> 00:31:33,019
PGP D must be GPD before chrome ok ok

00:31:31,100 --> 00:31:34,610
then we're W then we're good yep so ok

00:31:33,019 --> 00:31:35,899
so by the time chrome is privileged

00:31:34,610 --> 00:31:37,850
separate anything we probably had 40

00:31:35,899 --> 00:31:39,379
programs to privilege separated yeah I

00:31:37,850 --> 00:31:41,889
think we now I've liked about I think we

00:31:39,379 --> 00:31:46,399
have 72 programs privileged separated

00:31:41,889 --> 00:31:48,169
yeah yeah so it was designed to be

00:31:46,399 --> 00:31:50,480
privileged separated from the start and

00:31:48,169 --> 00:31:54,259
the privilege separation after chrome

00:31:50,480 --> 00:31:57,139
was driven by their attempt to use set

00:31:54,259 --> 00:32:00,909
comp so set comp being a system called

00:31:57,139 --> 00:32:03,559
limiter but at a very very low technical

00:32:00,909 --> 00:32:05,509
granularity therefore makes it possible

00:32:03,559 --> 00:32:07,730
for us to also determine what the high

00:32:05,509 --> 00:32:10,009
level of abstraction is that fits into

00:32:07,730 --> 00:32:11,269
it and so Robert did the work is Robert

00:32:10,009 --> 00:32:13,120
is here Robert didn't take you about a

00:32:11,269 --> 00:32:17,090
week

00:32:13,120 --> 00:32:19,490
okay yeah about a week yeah yeah it's

00:32:17,090 --> 00:32:21,470
five processes five potential potential

00:32:19,490 --> 00:32:23,840
places where you pledged yeah so there's

00:32:21,470 --> 00:32:27,650
five some of them are threads right but

00:32:23,840 --> 00:32:29,750
they turn into processes yeah okay so if

00:32:27,650 --> 00:32:31,580
large programs designed for this work

00:32:29,750 --> 00:32:37,730
with it then I think that's fantastic

00:32:31,580 --> 00:32:40,970
okay so and finally I'd like to remind

00:32:37,730 --> 00:32:42,530
you all the open Vista foundation takes

00:32:40,970 --> 00:32:46,010
contributions and then helps out the

00:32:42,530 --> 00:32:49,880
OpenBSD project and that is really with

00:32:46,010 --> 00:32:52,540
the hackathons and and the resources to

00:32:49,880 --> 00:32:56,030
give us that really is the foundation

00:32:52,540 --> 00:32:58,070
that allows a community to exist because

00:32:56,030 --> 00:33:00,050
I couldn't have been pledged on my own I

00:32:58,070 --> 00:33:02,450
was able to do pledge because of this

00:33:00,050 --> 00:33:04,190
large community and access to and the

00:33:02,450 --> 00:33:05,990
developers from the port's tree and

00:33:04,190 --> 00:33:08,360
developers from the base system who

00:33:05,990 --> 00:33:10,580
lifted up an applied pledge in to all

00:33:08,360 --> 00:33:12,890
the programs at the same time and by

00:33:10,580 --> 00:33:14,510
doing so allowed me to make sure that

00:33:12,890 --> 00:33:16,040
the semantics were correct and then

00:33:14,510 --> 00:33:17,990
other kernel developers worked with me

00:33:16,040 --> 00:33:22,520
to make the semantics correct so it's a

00:33:17,990 --> 00:33:26,540
team effort and it is basically possible

00:33:22,520 --> 00:33:28,580
because of the the the the risk factors

00:33:26,540 --> 00:33:30,170
of running a group this large and trying

00:33:28,580 --> 00:33:32,540
to get it together taken away so

00:33:30,170 --> 00:33:36,010
remember to pledge there as well please

00:33:32,540 --> 00:33:36,010
okay thank you very much

00:33:43,230 --> 00:33:56,679
are there any questions as far as I

00:33:53,500 --> 00:34:00,159
understood its sort of programming

00:33:56,679 --> 00:34:02,890
pattern so it's a sort of programming

00:34:00,159 --> 00:34:04,990
pattern yes no not entirely

00:34:02,890 --> 00:34:09,730
No pledge is not a programming pattern

00:34:04,990 --> 00:34:12,369
pledge encourages better patterns okay

00:34:09,730 --> 00:34:17,320
so my question is is there any paper

00:34:12,369 --> 00:34:21,089
describing in a formal way the way you

00:34:17,320 --> 00:34:24,580
should use pledge if they're a paper

00:34:21,089 --> 00:34:27,820
document that you can you refer to in

00:34:24,580 --> 00:34:32,649
order to be able to apply those pledge

00:34:27,820 --> 00:34:35,470
rules to your software yes there's a

00:34:32,649 --> 00:34:38,020
manual page and there are 600 programs

00:34:35,470 --> 00:34:40,119
that are examples and so those 600

00:34:38,020 --> 00:34:41,440
examples in our three I think are

00:34:40,119 --> 00:34:44,020
probably the best way to approach the

00:34:41,440 --> 00:34:47,740
problem that you go look for a similar

00:34:44,020 --> 00:34:51,730
problem and then you follow that pattern

00:34:47,740 --> 00:34:54,490
that we're not really academics who

00:34:51,730 --> 00:35:01,900
write papers I think that's probably the

00:34:54,490 --> 00:35:04,990
correct answer there was an abbreviation

00:35:01,900 --> 00:35:08,940
I didn't know toc eto you time of check

00:35:04,990 --> 00:35:08,940
versus time with use okay thank you

00:35:12,100 --> 00:35:22,360
I actually think that memory safe more

00:35:19,540 --> 00:35:26,200
consideration because I don't think that

00:35:22,360 --> 00:35:30,880
a SLR will ever become a fully

00:35:26,200 --> 00:35:32,950
watertight okay so when it comes to

00:35:30,880 --> 00:35:34,660
memory safe programming languages I'm

00:35:32,950 --> 00:35:37,900
would like to ask a question

00:35:34,660 --> 00:35:40,420
where's LS and where's Kat and we're

00:35:37,900 --> 00:35:42,610
sort and where's grep and where's word

00:35:40,420 --> 00:35:47,440
count and where's the K shell and

00:35:42,610 --> 00:35:49,960
where's the colonel I haven't seen any

00:35:47,440 --> 00:35:53,200
UNIX program written in a memory safe

00:35:49,960 --> 00:35:54,640
language yet so where's the ecosystem if

00:35:53,200 --> 00:35:56,440
there isn't that attempt to write the

00:35:54,640 --> 00:35:58,570
first program in a memory safe language

00:35:56,440 --> 00:36:02,790
how can we even talk about memory safe

00:35:58,570 --> 00:36:11,110
languages I noticed that there's our IP

00:36:02,790 --> 00:36:12,760
and there's redox okay first is

00:36:11,110 --> 00:36:16,060
compatible is that grep command

00:36:12,760 --> 00:36:17,860
Possible's compatible if does its manual

00:36:16,060 --> 00:36:26,170
page have exactly all the options that

00:36:17,860 --> 00:36:27,940
grep has that's exactly exactly so that

00:36:26,170 --> 00:36:31,180
is the that is the problem with that

00:36:27,940 --> 00:36:33,730
entire ecosystem is that they they just

00:36:31,180 --> 00:36:35,110
are not replacing Unix and so until

00:36:33,730 --> 00:36:36,940
there is someone who actually goes and

00:36:35,110 --> 00:36:39,190
replaces Unix and says memory with

00:36:36,940 --> 00:36:40,900
memory safety then we're not there and

00:36:39,190 --> 00:36:43,300
memory safety is not the only problem

00:36:40,900 --> 00:36:45,760
here memory safe tina swill not solve

00:36:43,300 --> 00:36:49,120
all of these problems doesn't solve all

00:36:45,760 --> 00:36:53,710
problems but it solves all that blind to

00:36:49,120 --> 00:36:58,230
return oriented programming and no it

00:36:53,710 --> 00:37:00,400
doesn't now no it doesn't because

00:36:58,230 --> 00:37:02,200
eventually in that memory safe thing

00:37:00,400 --> 00:37:04,120
they're gonna make a mistake and then

00:37:02,200 --> 00:37:06,130
someone's gonna you find that mistake

00:37:04,120 --> 00:37:09,310
and play with it like an or play Oracle

00:37:06,130 --> 00:37:11,170
against it and now since since none of

00:37:09,310 --> 00:37:15,700
the other mitigations will be there the

00:37:11,170 --> 00:37:18,460
rapp attacks will be even easier so you

00:37:15,700 --> 00:37:22,140
know we're human we make mistakes and so

00:37:18,460 --> 00:37:25,660
to go we say that both languages are

00:37:22,140 --> 00:37:29,470
memory safe which is probably

00:37:25,660 --> 00:37:32,440
which maybe two because there will will

00:37:29,470 --> 00:37:36,730
almost always be some some sort of seek

00:37:32,440 --> 00:37:39,880
out or assembler code or or a compiler

00:37:36,730 --> 00:37:43,750
in there that that we trust that is

00:37:39,880 --> 00:37:46,539
memory safe yeah so like the Gila

00:37:43,750 --> 00:37:47,920
ecosystem with C go and soon as CEO

00:37:46,539 --> 00:37:49,869
becomes popular and go

00:37:47,920 --> 00:37:56,890
they added address based randomization

00:37:49,869 --> 00:37:58,690
and yeah right way to use not to you see

00:37:56,890 --> 00:38:00,759
go of course so fundamentally these

00:37:58,690 --> 00:38:04,779
mitigations are cheap they're free so

00:38:00,759 --> 00:38:07,210
why not have them but I agree and

00:38:04,779 --> 00:38:09,549
address based randomization done on the

00:38:07,210 --> 00:38:11,789
minimal is very weak I agree with that

00:38:09,549 --> 00:38:11,789
point

00:38:20,660 --> 00:38:26,550
you mentioned that some programs don't

00:38:24,390 --> 00:38:28,920
run with the full fledge sit so what's

00:38:26,550 --> 00:38:33,480
the things that you can't do with

00:38:28,920 --> 00:38:35,580
voltage set some programs start with if

00:38:33,480 --> 00:38:37,560
you do the full fledge status or every

00:38:35,580 --> 00:38:38,910
single option some programs still don't

00:38:37,560 --> 00:38:42,330
work like you see Firefox doesn't work

00:38:38,910 --> 00:38:44,310
with that yeah okay some of the pledge

00:38:42,330 --> 00:38:47,670
semantics light up the moment that you

00:38:44,310 --> 00:38:49,320
actually call pledge so a pledge with

00:38:47,670 --> 00:38:52,740
all of the options does not include all

00:38:49,320 --> 00:38:55,050
the system calls it's true and one exact

00:38:52,740 --> 00:38:56,790
like I don't have any examples on me

00:38:55,050 --> 00:38:59,280
right now I can't think of a clear one

00:38:56,790 --> 00:39:03,420
but it from the from the from the get-go

00:38:59,280 --> 00:39:05,340
the each of the subsets was designed as

00:39:03,420 --> 00:39:07,470
a subset that's necessary for this

00:39:05,340 --> 00:39:09,690
function and so there was never an

00:39:07,470 --> 00:39:11,910
effort to ensure that this that the the

00:39:09,690 --> 00:39:14,100
inclusion of all subsets ends up as the

00:39:11,910 --> 00:39:15,960
full set that's the reason that's what

00:39:14,100 --> 00:39:18,630
that's basically where we stopped work

00:39:15,960 --> 00:39:21,690
before that oh and one other thing was

00:39:18,630 --> 00:39:24,840
in the capsicum talk he mentioned that

00:39:21,690 --> 00:39:27,930
if you can if you permission to fork

00:39:24,840 --> 00:39:31,020
then you can bypass so it's when you

00:39:27,930 --> 00:39:34,470
said sh can't talk to a socket but it

00:39:31,020 --> 00:39:36,870
can create netcat instance for example

00:39:34,470 --> 00:39:40,470
if you fork a process the child has the

00:39:36,870 --> 00:39:43,110
same has the same pledge x ik so if you

00:39:40,470 --> 00:39:46,710
have exact rights so sh can create an

00:39:43,110 --> 00:39:49,860
instance of netcat yeah so sh can fork

00:39:46,710 --> 00:39:51,240
and exec netcat okay yeah and what's the

00:39:49,860 --> 00:39:53,970
problem that's that's what it's supposed

00:39:51,240 --> 00:39:56,640
to do yeah yeah I'm just saying it's it

00:39:53,970 --> 00:39:58,590
can still connect you can still connect

00:39:56,640 --> 00:40:00,180
to the internet so by running another

00:39:58,590 --> 00:40:01,580
program yeah but that's what it's

00:40:00,180 --> 00:40:03,990
supposed to do

00:40:01,580 --> 00:40:05,120
that's what SH is supposed to run

00:40:03,990 --> 00:40:07,950
programs

00:40:05,120 --> 00:40:09,210
sowhat's yes but the slide said that one

00:40:07,950 --> 00:40:11,820
of the strengths was s as you cannot

00:40:09,210 --> 00:40:13,320
talk to the Internet yeah s H the

00:40:11,820 --> 00:40:15,120
program cannot talk to the Internet

00:40:13,320 --> 00:40:17,460
technically yeah ok yeah it has to run a

00:40:15,120 --> 00:40:19,530
command right but let's say for example

00:40:17,460 --> 00:40:21,570
you take an SH binary let me create an

00:40:19,530 --> 00:40:23,550
artificial model a CH or jail I've got a

00:40:21,570 --> 00:40:25,770
see-through jail and inside the th rule

00:40:23,550 --> 00:40:27,810
out of a statically linked SH and that s

00:40:25,770 --> 00:40:30,060
H over there is handling some objects

00:40:27,810 --> 00:40:31,380
but somehow it's given some data and in

00:40:30,060 --> 00:40:33,270
that data somewhere managed to wrap

00:40:31,380 --> 00:40:34,020
attack and start executing code inside

00:40:33,270 --> 00:40:36,569
that si

00:40:34,020 --> 00:40:38,880
but that Sh is in a jail where it has no

00:40:36,569 --> 00:40:41,880
other programs that can execute so how

00:40:38,880 --> 00:40:43,890
does it open a socket in our world that

00:40:41,880 --> 00:40:45,180
Sh cannot open a socket because it

00:40:43,890 --> 00:40:48,329
doesn't have a command that can execute

00:40:45,180 --> 00:40:49,829
that can open a socket that's the

00:40:48,329 --> 00:40:51,900
security model we're trying to bring to

00:40:49,829 --> 00:40:54,750
here that the program itself cannot do

00:40:51,900 --> 00:40:56,369
that but unfortunately I'm sorry but Sh

00:40:54,750 --> 00:41:00,690
is supposed to run programs that can do

00:40:56,369 --> 00:41:03,990
anything so like what are what do the

00:41:00,690 --> 00:41:05,550
capsicum people want us to do what do

00:41:03,990 --> 00:41:08,609
they want us to do what's their proposal

00:41:05,550 --> 00:41:10,559
that we should not allow sh 2x AK or

00:41:08,609 --> 00:41:13,740
should we follow their pattern that you

00:41:10,559 --> 00:41:17,760
can't capsicum Michelle so that's their

00:41:13,740 --> 00:41:20,910
answer you can't capsicum Sh right and

00:41:17,760 --> 00:41:23,599
you can't set comp that on Linux so

00:41:20,910 --> 00:41:25,920
instead we've provided a security

00:41:23,599 --> 00:41:28,079
enhancement which no one else has and

00:41:25,920 --> 00:41:30,000
we're receiving criticism for it it

00:41:28,079 --> 00:41:31,829
doesn't make any sense to me it doesn't

00:41:30,000 --> 00:41:33,420
make any sense I'm willing to be

00:41:31,829 --> 00:41:35,520
criticized by people who haven't done

00:41:33,420 --> 00:41:36,960
something similar to what we've done but

00:41:35,520 --> 00:41:39,030
I'm not really criticized by people who

00:41:36,960 --> 00:41:44,160
haven't done anything it's crazy

00:41:39,030 --> 00:41:46,730
okay thank you all right if there are no

00:41:44,160 --> 00:41:46,730
more questions

00:41:54,190 --> 00:41:59,329
thank you various like so do I say

00:41:57,619 --> 00:42:00,859
correctly this is entirely a runtime

00:41:59,329 --> 00:42:02,660
mechanism or do you some most ethically

00:42:00,859 --> 00:42:05,599
check that you've pledged the right

00:42:02,660 --> 00:42:07,369
things or because you from what you said

00:42:05,599 --> 00:42:09,560
you're registering something when you

00:42:07,369 --> 00:42:14,630
start a process essentially at runtime

00:42:09,560 --> 00:42:16,339
you do something yeah so I understand

00:42:14,630 --> 00:42:17,869
that it works really well for operating

00:42:16,339 --> 00:42:20,660
systems and things that are like built

00:42:17,869 --> 00:42:23,390
in a very close community but don't

00:42:20,660 --> 00:42:24,530
aren't you afraid that if like if you

00:42:23,390 --> 00:42:26,540
develop something in a very high

00:42:24,530 --> 00:42:28,220
velocity means like you do something and

00:42:26,540 --> 00:42:30,440
you link a library from someone else and

00:42:28,220 --> 00:42:33,109
he then suddenly starts to do something

00:42:30,440 --> 00:42:34,760
you shouldn't that it suddenly becomes a

00:42:33,109 --> 00:42:35,900
denial of service vulnerability simply

00:42:34,760 --> 00:42:39,700
because you're going to be shot down

00:42:35,900 --> 00:42:41,420
because some dependencies of yours now

00:42:39,700 --> 00:42:44,329
requires something that you haven't

00:42:41,420 --> 00:42:46,640
pledged for to you somehow transitively

00:42:44,329 --> 00:42:48,980
transfer things that you've pledged

00:42:46,640 --> 00:42:50,359
although some librarian but I I guess

00:42:48,980 --> 00:42:50,900
you don't because it's a process start

00:42:50,359 --> 00:42:54,079
up right

00:42:50,900 --> 00:42:55,820
no pledge blocks that process and all of

00:42:54,079 --> 00:42:57,410
its shared libraries so the scenario

00:42:55,820 --> 00:42:59,900
you're talking to it I suppose the

00:42:57,410 --> 00:43:02,720
answer for that is that's just you're

00:42:59,900 --> 00:43:04,520
talking about Pam to be quite honest

00:43:02,720 --> 00:43:06,079
okay so shared libraries come in and

00:43:04,520 --> 00:43:07,730
they do who knows what but it's a

00:43:06,079 --> 00:43:09,079
response but how are we gonna protect a

00:43:07,730 --> 00:43:11,660
process if it's shared libraries are

00:43:09,079 --> 00:43:13,400
doing crazy things and so if you've got

00:43:11,660 --> 00:43:16,010
a bug in the program its attacked I'm

00:43:13,400 --> 00:43:17,180
sorry I don't want a shared library to

00:43:16,010 --> 00:43:22,099
do something which I didn't anticipate

00:43:17,180 --> 00:43:25,040
that program to do so pam pam is a is a

00:43:22,099 --> 00:43:26,450
big problem yeah and that's why the bsd

00:43:25,040 --> 00:43:28,760
authentication system is a much safer

00:43:26,450 --> 00:43:30,829
system by separating them in once again

00:43:28,760 --> 00:43:31,970
it's privilege separation so this is

00:43:30,829 --> 00:43:35,270
combination of privilege separation

00:43:31,970 --> 00:43:38,210
separation and pledge which really show

00:43:35,270 --> 00:43:42,770
how to build safety safe designs and the

00:43:38,210 --> 00:43:44,750
dl open model of of of doing things it

00:43:42,770 --> 00:43:47,300
has no safety there's no there's no

00:43:44,750 --> 00:43:53,690
seatbelts in that whole model so i think

00:43:47,300 --> 00:43:55,579
it's you know it's on the operating

00:43:53,690 --> 00:43:59,270
system level i can see that working well

00:43:55,579 --> 00:44:01,480
well and the application level not so

00:43:59,270 --> 00:44:04,890
sure that i would be able to

00:44:01,480 --> 00:44:04,890
this for my code for example

00:44:10,130 --> 00:44:17,989
I guess just one more yeah so as a

00:44:16,099 --> 00:44:19,759
specific response to the question a

00:44:17,989 --> 00:44:21,499
number of interpreted programming

00:44:19,759 --> 00:44:22,819
languages do have pledged available

00:44:21,499 --> 00:44:25,549
within them to call

00:44:22,819 --> 00:44:27,769
I believe in Lua and Python and several

00:44:25,549 --> 00:44:29,809
others as well so those application

00:44:27,769 --> 00:44:34,539
developers can use Python in our canoes

00:44:29,809 --> 00:44:34,539
pledged in their programs if they desire

00:44:36,700 --> 00:44:41,589
all right thank you very much thank you

00:44:39,259 --> 00:44:41,589

YouTube URL: https://www.youtube.com/watch?v=Er44ur7wkXQ


