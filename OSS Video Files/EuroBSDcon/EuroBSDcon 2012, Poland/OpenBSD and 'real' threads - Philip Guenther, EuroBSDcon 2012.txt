Title: OpenBSD and 'real' threads - Philip Guenther, EuroBSDcon 2012
Publication date: 2012-12-07
Playlist: EuroBSDcon 2012, Poland
Description: 
	EuroBSDcon 2012
Warsaw, Poland 18-21 October
Captions: 
	                              they're there about that so the if a                               child set the file descriptor being                               owned on block and the parent would also                               see it is Oh Knobloch and if it didn't                               really anticipate that you can get all                               sorts of funds because it would start                               seeing me again you would block errors a                               classic symptom in that we used as CNO                               ba openbsd is you would have a threaded                                program die so it can reset the file                                descriptor state and then you try to                                fire a VI or something and VI would                                instantly exit because it would try to                                read get a again from the the terminal                                and exit it looks like he did end a file                                so it was really kind of annoying and we                                put in various workarounds at various                                times but they were just workarounds in                                the end you can't solve that problem                                with that particular tool of course the                                non-blocking own unlock doesn't let you                                do everything non-blocking really                                there's absolutely no way for you to do                                a non-blocking opened ability of a fifo                                in file system if you tried to do it                                it'll return an error but you can't then                                pull for when you would actually succeed                                which kind of defeats the whole purpose                                of the of that whole process you also                                have to deal with things like k event                                and sake timeouts we eventually did put                                in code to deal with socket timeouts but                                it meant that you have lots and lots of                                system calls just to check to see you                                look did I put a set of socket timeout                                on the same and some things would go                                ahead and block EV even though you                                didn't want them to be blocking disk i/o                                wheel block no matter what you say if                                you're NFS server is down other threads                                will not get to run so at some point                                said okay everyone knows the right                                answer the right answer is you go ahead                                and teach the kernel threads so what we                                call this was our threads standard                                one-to-one architecture every single                                thread user space is a thread in kernel                                as well it's minimizes amount of changes                                you don't have to have                                you know the vast complexity of a thread                                scheduler in user space or anything like                                that you can just let the colonel deal                                with it indeed many of the other                                operating systems that did go the                                so-called n dem method about since then                                said you know this is too much work                                let's all go to one to one solaris did                                that for instance in solaris                                         made it optional and solaris                                           only way to do it freebsd i believe you                                guys did that as well hmm so                                           first initial effort was just minimal                                changes okay would just stick a struct                                process above this truck proc so struck                                prop remains this the schedule bowl                                entity the thing that actually is the                                thread level and just a handful of                                system calls to actually pull this off                                our fork which existed for kind of                                stolen from plan                                                  thread was added to say create this as a                                thread inside the process you have to                                have a way to say just kill one thread                                exit continues to take down the entire                                process and then you need some weed                                identify what thread this guy is & sig                                divert is you may have is a way to                                handle the sig weight system call in in                                POSIX this is a way for one thread to a                                steal for signals from the process and                                finally need some way to have the                                threads actually go to sleep and wake                                each other up and for openbsd this was                                basically an export of the Colonel's t                                sleep and wake up primitives to user                                space where you pass an identifier as a                                rendezvous point and actually digging up                                for this paper and discovered that Ted                                actually presented this you're at euros                                BST gone back seven years ago so it uh                                it what he did it                                yeah yeah the yeah so the anything else                                well yeah so is any saying that the                                original one is just make it so xmms the                                the audio player would actually not skip                                when you're dealing with the playlist                                and stuff honestly that was my first use                                of it too and it turns out we've                                actually solved that problem now the                                 their sound system is so much better now                                 that it's rarely a problem even now so a                                 bunch of things had two were not right                                 about that the minimal implementation                                 was exactly i minimal and created all                                 sorts of fun problems because it wasn't                                 doing things where you'd expect some of                                 you may have flashbacks of this diagram                                 from your unix courses this is the rough                                 diagram of the enterprise in the                                 Colonel's data structures for processes                                 and process groups it's the p group                                 their session structures the TTYL                                 showing how all the connections between                                 them as a pointer out okay who's my                                 sibling the chains and Lissa stuff so                                 one of the things we had to change is to                                 fix this all up because these were all                                 done with the initial implementation was                                 the threads were actually still chained                                 together siblings it's meant things like                                 a thread would fork and another thread                                 we try to wait for the child of the                                 first thread and it couldn't do it                                 because it wasn't on that threads                                 children list okay that's just wrong                                 okay so we have to move that around have                                 moved that stuff up to the process                                 structure set PG ID actually lets you                                 put different threads in different                                 process groups which yeah job control                                 was a little hosed if you try to pull                                 off them of that stuff and so we tried                                 to very started just use parts of this                                 okay made this price move the children                                 bits and the parent pointers around okay                                 no it doesn't work how about if I move                                 the process group session stuff and                                 leave the children so now it turns out                                 these things are just so bad totally                                 related to each other that you just have                                 to move mall at once you just have to go                                 through and say okay change all this                                 stuff to Prague can prop the process                                 change all this stuff you know move                                 these members around this has to be one                                 big change there was a spent most of one                                 of our hackathons and cow in                                 edmonton doing this and we committed to                                 the week after and it actually worked on                                 the first try which is wonderful what an                                 interesting note about this is that                                 there's things like one of the security                                 checks and set pGAD for to change your                                 process group is that you're allowed to                                 change the process group of a process                                 which is one of your descendants so you                                 have to walk how it does this how the                                 check McConnell checks this is that                                 actually starts with one process they                                 suppose it it descendant and it just                                 walks the parent pointers up until it                                 finds the the you know either it runs                                 into this process we're doing the test                                 for or runs into in it ok it's                                 assumption you're you know the process                                 tree it's a it's a directed acyclic                                 graph so that's an example of some place                                 where you have to be doing these sorts                                 of interrelations between the process                                 tree and the process group kind of stuff                                 I want to had a bug in it though                                 interesting get back to that so what                                 other things um cig acts in the kernel                                 side so this is where all the signal                                 information is stored in everything that                                 you do with sig action stuff here so the                                 handler whether it's ignore it or not is                                 sa info set all that kind of bits that's                                 actually was already shared we actually                                 had that share because it was in a                                 separate data structure which there was                                 a common reference count for it but the                                 information about what signals there was                                 caches so some of the stuff there was a                                 pea under bar sig ignore was basically                                 just a bit set of all the signals that                                 this process was ignoring the problem is                                 that this was stuck in the proc                                 structure so you could actually if you                                 created some threads and then change                                 your signal disposition you could have                                 different threads having different                                 conceptions of which signals were being                                 ignored so that not very easy so we had                                 to move that stuff all up to this truck                                 sig acts and then NFS caught fire                                 this picture on the right is actually a                                 Baalbek Theo fib and myself reading the                                 NFS call graph sorry delayed right when                                 you duel right it can be left pending                                 waiting for some other stuff until the                                 NFS decides he needs to flush it out it                                 carries a pointer in the the uio                                 structure inside of it even if it's a                                 delayed right and there was nothing to                                 keep the process from going ahead and                                 exiting so we were actually having this                                 pointer to a dangling process in a few                                 someone hit a ctrl C at the right point                                 then the signature code in the wood that                                 says okay you can you can interrupt NFS                                 rights would actually be looking at this                                 dangling rock this was a bug before we                                 just never knew it because the pointers                                 were not actually they were still mapped                                 in the kernel space so it was a                                 dereference of an invalid of a free                                 pointer and just you got away with it                                 but now with the moving of the best cash                                 information to CX now it has to do                                 another dereference which at this point                                 have been overwritten as part of the                                 free process and so we started seeing                                 panics so we actually to back it out                                 track this down stair at the NFS call                                 graph rip the pieces of our hair out and                                 then find the right places they know if                                 you're doing the delayed right you don't                                 actually care about the process that                                 actually started anymore drop that off                                 set it to null you know you can't                                 interrupt those anymore and off you go                                 so I did go in just took some hair other                                 example things you know there's a key                                 event there's one of the filters in cave                                 inlet to monitor processes you can say I                                 want to watch you know exits for                                 acceptance or a thing except was                                 watching threads actually sitting and                                 you didn't have any way to know which                                 was a thread and what was a process easy                                 to fix the only trick there is that we                                 were actually using that in our thread                                 library to detect when a threat had gone                                 away when the tricky parts of thread                                 Larry's is at some point you want to                                 free a threads stack so how do you know                                 when it's safe to free the stack okay                                 that thread on its way out can turn off                                 the light or something but but it still                                 has to make that system call to go away                                 so it it's pushing some stuff onto the                                 stack right then so you you need to do                                 something after on the                                 side the colonel to let everyone else                                 know okay yes the threads gone it                                 stopped using it stack you can free it                                 you can do whatever we want to it so                                 we'd been using K event by sending a                                 Kate event you'd be Phil prox to say                                 watch the thread but that couldn't I                                 with the fix to how we wanted came into                                 work we couldn't do that so we have to                                 change it to use                                                         the thread thing now actually set the                                 flag for you in user space there's a                                 copy out that's actually some stole that                                 idea one of the great things about doing                                 that openbsd by being one of the last                                 people if last groups to do this is that                                 we get to steal great ideas from all the                                 rest of you so I was taken a bit from                                 the Linux cologne stuff there's a thing                                 where you can itself where is a flag                                 where it says zero out the the tid okay                                 so you pass that it same sort of idea k                                 trace k trees add a little bit there's                                 some fun bits in it in order to deal                                 with credentials of what credentials                                 should be writing cage trace records as                                 but i mainly want to mention this so I                                 could thank whoever this is a smart                                 cookie of freebsd who said let's write                                 structures too because that really made                                 life a lot better and easier to debug                                 things when you actually instead of just                                 seen oh look this function was being                                 called system call have this nice point                                 your argument okay great cool was it                                 pointing at but you could actually have                                 a dump the actual structure information                                 entire values and you can say oh oh we                                 were passing in something completely                                 bogus and it's very proved very useful                                 for debugging helping working with the                                 port our porch group to debug third                                 party stuff where when you're lost in a                                 maze of C++ code and you can't figure                                 out where the hell that call is coming                                 from you can at least get what the                                 arguments in the structure will host                                 we've actually run with it's quite a bit                                 automorphic ipod miss mangled his name                                 with openbsd is adding lots of flag                                 decoding and it's it's much nicer now                                 resource limits usages you really want                                 these accumulated and i actually didn't                                 think this was that important and then                                 SB start                                 throwing things at me when back in                                 February we finally made the switch and                                 said okay that's it we're turning the                                 lib pthread is no longer the old user                                 space is now the new one above all the                                 version numbers blah blah blah and they                                 said well headache the resource usage                                 information is all wrong and it's                                 screwing up dpb or those who attended                                 the talk yesterday learn how the ports                                 build stuff automation now by measuring                                 usages can schedule the order of the                                 ports down to the point where they all                                 finish in five seconds on eight                                 different machines so by having they                                 needed that accurate usage information                                 so they could estimate and place and                                 schedule things in the right order so by                                 doing that we they made me put that                                 further up in the list and mix it in it                                 it is useful to know for instance when                                 that one thread and Firefox is spinning                                 not that it ever happens so yeah exactly                                 um one of the eviler things that you                                 have to do as you work with the threads                                 in the kernel is it there's certain                                 operations which just have to be single                                 threaded if not they will you'll pull                                 your hair out exec fee for instance is                                 defined as when it succeeds there's only                                 one thread in the process after that so                                 all the other threads have to be hauled                                 out and shot somehow and you need to do                                 that at this safe point because you                                 really want to make sure that they can't                                 as their last operation you will copy                                 out or something in the noodle processes                                 space and trash it's thanks o space teen                                 on ideas from freebsd set up a couple of                                 things and functions for basically                                 catching when you know sending some                                 flags in the process structure that                                 processes check on entry to the colonel                                 and then whenever they go to sleep so                                 that they can know okay instead of going                                 to sleep i'm going to bail all the way                                 out stop and die or suspend or whatever                                 you also have to do this for court                                 dumping this is actually one of the                                 things i've got me involved in our                                 threads was i was working with                                 our threads in xmms and discovered that                                 affects mms core dump sometimes your                                 machine would panic because the court                                 dumped code in the colonel would walk                                 the thread list see okay how many how                                 many elf notes about registers for                                 processes i need to write and then it                                 would actually right walk the list again                                 and actually write them out sometimes                                 one of the threads would go away in the                                 process of that and an assertion to say                                 did i get the same count both times                                 would fail so you have to really lock                                 those all down say no no here's the                                 actual set to go so thank you freebsd                                 ptrace this was one of the last things                                 we actually got right mainly because                                 ptrace is really complicated by the                                 latter know how many people know this                                 but ptrace when you want to win gdb for                                 instance you attached to a process and                                 actually in the kernel does so by the                                 kernel r apparents the process the                                 target process so if i'm debugging you                                 know LS or something LS that LS process                                 instead of being a child of the shell                                 that i started down perhaps is now                                 becomes a child of gdb okay so that's                                 how it then gets all the events and can                                 do wait it can actually wait for the                                 events and stuff you have to add some                                 some bits so that there's some way for                                 you can use ptrace to say okay what is                                 the list of all the process that the                                 threads where are they what's our status                                 kind of thing you also need to do that                                 using that single threading you have to                                 be all the way to stop all of them so                                 when you once you can leverage your                                 single threading its offer to you a bit                                 easier but there's lots of little XE                                 pieces of okay what is the right state                                 and if when I do want to restart one                                 what do I do it's an interesting little                                 gotcha here which you might not catch                                 repairin teen what happens if Yuri                                 parent your own parent your process tree                                 is no longer a directed acyclic graph it                                 now has a loop remember how i mentioned                                 how set PG ID had a call where it walked                                 up the process tree until it reached in                                 it                                 guess what you can put your kernel in                                 the loop on last I checked this actually                                 affected everyone including Mac so we                                 actually did put a check in to our                                 ptrace code I sent a note to some                                 security mailing list but so some other                                 changes we need to make for a cisco API                                 some things where originally they were                                 fairly simple api's we decided you know                                 we used our spark to create a thread and                                 things like that we need to make them a                                 little richer the previous one mckaylee                                 it we actually had a and as a simply                                 stub which actually did the real are for                                 call and then it did the fix-up of the                                 stack pointer because well that's all                                 point is different thread as a different                                 sack and then invoke the start function                                 for the the thread uh there's a catch                                 there what happens if you get a signal                                 before you set before you fix up the                                 stack pointer um well it gets the thread                                 and runs it on the parent threads stack                                 this is bad I'm for some reason it seems                                 like functional language interpreters                                 like to send a lot of signals to new                                 threads because it seemed that our ports                                 of I think it was the Haskell                                 implementation one of this somewhat one                                 of the other ones really really liked                                 hitting this so you can't do that you                                 need to close that that hole so uh huh                                 which you instead want is you want the                                 colonel to actually do the setting of                                 the the stack pointer register in the                                 new thread when it creates it where's                                 our park doesn't actually have any place                                 for you to put that so we ended up                                 coming with a new system call called it                                 t                                                                       has and among at the the stack the there                                 you have to deal with all the the                                 machine dependent work in the colonel I                                 really didn't want to know that much                                 about the HPP a stack frame and then you                                 have to do you still need the atom                                 wrapper in user space the problem is                                 that you're making us still doing a call                                 so you still need you still need a stack                                 frame for that call so you have to do                                 shifting at wobble okay the thing you                                 really really want is you want a per                                 thread air no it's required and if you                                 don't eventually you will have xmms die                                 because it claims that the X call failed                                 with error                                                           case of really it was a non-blocking                                 call and it got a wood block and aaron                                 oh god overwritten which is annoying so                                 you need some way to have a this per                                 thread thing the you also want it makes                                 it useful to be have some way to get a                                 fast way to find out what this your                                 current threads pthread t structure is                                 there's lots of useful information there                                 that you'll want so there's actually uh                                 the elf people actually have an ABI that                                 they've defined for many platforms for                                 per thread red storage class so that you                                 can actually define stuff which is per                                 thread and want to be able to leverage                                 that at some point so what we have is a                                 kernel value which is per thread which                                 the and the user space can request me so                                 you can set it with set TCB that's the                                 address of your thread control block                                 corollas actually care where points but                                 it just gives you a build lets you set                                 it and retrieve it and you need to pass                                 that in on your r                                                   thread start out with this correct value                                 because once again you want their you                                 don't want any windows where you know if                                 you got a signal you'd have the wrong                                 TCB value you need aaron owed to work                                 correctly inside signal handlers too so                                 I have to have that set for you by the                                 colonel so what this actually ends up                                 looking like this is the kind of what it                                 would look the actual structures end up                                 looking like here                                                     hppa on a CPA see our                                                  is reserved as the pointer to your                                 thread control block so for the initial                                 thread your thread control block it's                                 just a couple words the one the first                                 one DTV that's actually for the elf ABI                                 it's going to point to something later                                 on                                 um for implementing the thread-local                                 storage we don't support that yet we're                                 getting there but the other important                                 thing is that is a pointer to the third                                 structure and then you can have in the                                 third structure a pointer to your actual                                 air know you then have to have a                                 override for the Aronov under barn door                                 errno function so that it actually knows                                 okay dereference all this not yard                                 there's like other platforms define                                 things slightly different these are                                 there's two different EB is defined by L                                 this is for instance amd                                                 segment register points directly to your                                 TCB and then we cheated a little and we                                 actually put the ER no pointer into the                                 the TCP itself so it's a stay saves one                                 pointer chase for their his room now we                                 do map this to whatever they off a br it                                 defines where we can I three six percent                                 yeah so on as a couple which there are                                 definitions for how to do this we just                                 haven't gone around actually doing the                                 md work so you can actually set this up                                 but this means how r is that the get TCB                                 function that i mentioned it is very                                 rarely used I'm on Molly platforms like                                 spark for instance instead of calling                                 that function you just look at the                                 register the register points to my TCB                                 whoa if I go errno is fast it's just on                                 platforms like alpha an arm right now                                 where we be still updating every time                                 you actually do anything with errno it                                 actually makes another system call so                                 not the best we'll make it faster now                                 note this is only done in the the thread                                 library i'll live see the little ypsi                                 base definitions for all this stuff                                 don't do that they they can just use the                                 the the static mining itself so it's not                                 a problem there then a little bit of fun                                 stuff in the thread library to actually                                 set this do that set up all those                                 pointers when you finally actually open                                 the third library we have to add make                                 some tweaks to our thread the sleep wake                                 up functions as well the very simple you                                 can see the original publications from                                 if an identifier that's just a                                 synchronization address basically the                                 colonel when you someone sleeps on what                                 address the third wake up just looks for                                 the same address somewhere in the by                                 another call and wakes it up the timeout                                 was relative well we really it was kind                                 of like poll you know as milliseconds                                 kind of thing but we really wanted to                                 actually be an absolute timeout because                                 it turns out all the time outs in the P                                 threaded standard our absolute timeouts                                 where you actually specify this point in                                 time of the clock you know when you                                 billion                                                               want to wake up so we changed it to                                 actually pass in a struct I'm spec and                                 then a clock ID so right the clock ID                                 for those who don't know is that there's                                 actually POSIX to find the number of                                 different clocks there's a real time                                 clock which is okay second system since                                                                                                         usually something like second send food                                 in effect or something like that but                                 it's a clock that never gets shifted and                                 there's others that are possible so this                                 is just a way we can say okay which                                 which clock are you measuring from                                 cancellation the sorry for the record I                                 hate cancellation anyone you're like it                                 okay sorry cancellation for cancellation                                 is a way to tell say okay that's right                                 over there I want you to do I'm done                                 with whatever you're doing you're you're                                 no longer useful to me firing you and                                 you send it basically it's in effect                                 it's kind of it's modeled after signals                                 where there's certain points what are                                 called cancellation points where the the                                 process is expected to say oh look i was                                 cancelled i'm going to do the tricky                                 bits are that one of the cancellation                                 points is defined as is pthread cond                                 wait conditional variable wait and                                 there's a requirement in this back that                                 says okay if you are interrupt if you're                                 canceled and you are waiting at                                 conditional variable then you have to                                 grab the mutex again before you exit so                                 always you come out of it with the mutex                                 variable again so there you have to                                 reduce a little extra clean up                                 processing and it makes it so you have                                 to be very careful and arranging exactly                                 what state you're in so in order to                                 actually do this correctly                                 not have hangs we added is yet another                                 argument sorry to thur sleep where                                 there's a way to say look I know you're                                 trying to go to sleep but if this value                                 has been set its flag variable then act                                 like you were interrupted it's a way to                                 close the race condition between a                                 signal coming before and coming after                                 the sleep has started one of the fun                                 things we did on openbsd is some years                                 ago it is that the right exclusive works                                 executed bits where normally in openbsd                                 no segments of memory in a process is                                 both writable and executable makes it a                                 lot harder for someone to come in and                                 like overwrite your your code segment                                 with some cool garbage for i                                            that for most platforms this is really                                 easy because they're there mmm you                                 actually has the ability to say okay                                 these pages are read-only and these                                 pages are executed only but I                                         ability to say which pages are not                                 executable is pretty limited there's is                                 you have to set the code segment limit                                 and it's kind of annoying so in order to                                 do that what was done back in                                          that a shared memory a shared library in                                 on a                                                                     the code segment and then there's the                                 data segment and their map exactly a set                                 distance apart one gigabyte apart and                                 actually the the bindings inside them                                 anticipate this so they need to be                                 placed that distance apart so LDS oh                                 when you tell it to map in a shared                                 library it says okay I need to put the                                 code of this I need to find someplace I                                 can put the codes I minto so ask the                                 colonel to give it a location and it                                 says now try putting the data segment                                 above it the right distance and uses                                 edit a assistant call em query which is                                 like a map except it doesn't actually do                                 the mapping it just says could the                                 mapping take place so it goes through in                                 it for each of the segments to try and                                 find see if it can find a base oh wait                                 there was a conflict okay move this guy                                 up and try again so on okay it worked                                 okay                                 ok well there's a time of check the ton                                 of youths race there M query doesn't                                 actually reserved the address that you                                 did initially so what if I say okay look                                 I can put the code down here let's go                                 put something up here and then something                                 else come one of your other thread comes                                 in it does maps over the bottom area LDS                                 oh well then smack on top of it and                                 you'll actually end up with mappings put                                 over where you thought they should be                                 things would not be mapped the way you                                 want them to be that's bad so what we                                 needed is kind of the equivalent of Oh                                 exclusive so I so created so exclusive                                 we need map fixed is too and there isn't                                 thing so we added map no replace which                                 is basically a way to say okay I'm gonna                                 map at this if you can map it this fixed                                 address do so if you can't don't                                 override it just fail if you don't use                                 map fix than the colonel but are picking                                 another address but we don't we can't                                 use that other dress it's not the right                                 distance apart so this is okay back it                                 out we can then back out all the napkins                                 we are actually already did and then try                                 again with a new place we actually                                 almost had it so that we could just get                                 rid of em query I mean really did it                                 says is this useful I mean it's not it's                                 it creates this whole time of checked i                                 may use problem but it turns out that                                 the fact that it doesn't actually make                                 the page table changes is actually big                                 savings in time if you've seen a lot of                                 conflicts if it has to do a lot of                                 retries then actually just trying                                 without actually making the tape page                                 table changes can really save a lot of                                 computation because every page table                                 change is probably a TLB flush it's it                                 gets expensive so we go ahead and it                                 first choice with em query and then it                                 says okay this looks good let's try to                                 get this in a way that's safe user space                                 test bits the ports people god bless                                 them i hate you all                                 they found all the the the problems that                                 we didn't anticipate and then someone's                                 we did I like for instance yes people                                 actually do put things like deal clothes                                 into their shared library finney                                 sections I think they're insane but they                                 do it and unfortunately everyone else                                 supports it so we have to do it as well                                 so it means your block you put around                                 the DL opened deal closed functions has                                 to be recursive because you do need to                                 be able to do a deal closed from inside                                 deal closed not all operating systems                                 punish people who do things like                                 unlocking unlocked mutexes or locking                                 your own muted not everyone does that we                                 were really strict and we've had to back                                 off from that there's some really broken                                 code out there which gets away with it                                 because no one else tries to call them                                 on it it's a shame we actually do have                                 our default is still strings more                                 stringent than is required but there's                                 only so much pushing you can do from                                 just the ports group and they're the                                 ones who actually end up doing the                                 pushing because I'm betting it on this                                 stuff are mutex and conditional variable                                 imitation originally was based on                                 semaphores and you can do this basically                                 the conditional weight is a down                                 conditional signal is an up if anyone's                                 blocked and then broadcast you have to                                 count off and send them ops but there's                                 a bug in that well ok first of all it's                                 inefficient for those who don't know                                 when you do a conditional when someone's                                 doing the conditional weight when they                                 get woken up they reacquire the mutex                                 this means that if you do a broadcast                                 they all suddenly all the threads are                                 now walking on the mutex and if they all                                 have to actually wake up move over to                                 the other Q then you thrash all your                                 your caches is all these you know it's a                                 hundred threat they'll wake up and do                                 this it said kind of a thundering herd                                 kind of problem so what you can do you                                 can do this more efficiently by actually                                 does having the the broadcast operation                                 ok look these guys are asleep this while                                 they're asleep let's just quietly move                                 them over to the other q                                 put them there and then wake one up and                                 it can go off and actually grab the                                 mutex the bigger proper is that that                                 some of for implementation isn't                                 actually safe what it can happen is ok                                 you have one thread up there that blocks                                 on the conditional variable ok so it's                                 kind of doing a semaphore down and then                                 some other thread comes in and says okay                                 let's signal it doesn't up and then                                 before that first thread can actually                                 get around to waking up and grabbing the                                 the semaphore I have the second thread                                 do another down on it in effect you can                                 have a thread catch its own signal that                                 it sent now this sounds like a really                                 dumb thing to to have this actually hurt                                 I mean why is your design such a problem                                 threads that are well on a conditional                                 variable you shouldn't be waiting on the                                 conditional variable feet of signal                                 model you can get arguments of design                                 but actually POSIX actually specializing                                 that no you conditional signal can only                                 wake up threads that are must wake up at                                 least one thread which is blocked at the                                 time of the signal and this                                 implementation did not do that you could                                 lose a wake up in effect so we had to                                 change that and programs do depend on                                 that behavior so we actually just moved                                 all the quake use into user space we                                 actually have explicit queues now in                                 user space where every new text hasn't                                 list of ok here's all the threads that                                 are waiting for me and then when someone                                 needs to wake up it described the next                                 one off wakes up and goes it goes on on                                 this con cygnus conditionals variable                                 signal and broadcast operations can now                                 transfer threads wholesale between the                                 queues it's a bit complicated um and I                                 don't see a direct way to actually make                                 this work with process shared or                                 probably have to actually follow what                                 the FreeBSD you guys did and and                                 actually have specific system calls for                                 handling can this stuff when we go on to                                 due process yard and you actually can                                 kind of do priority inheritance which                                 I've now it misspelled I guess but it's                                 better than before and it doesn't have                                 that particular bug which was actually                                 causing a bunch of headaches                                 interestingly enough this bug                                 is there was just two weeks ago there                                 was a posting on to the Austin group                                 mailing list which is the                                 standardization group that keeps                                 shepherding posix forward where someone                                 says what is a shepherd do because what                                 does the shepherd do with the sheep at                                 the end of the season the someone saying                                 gee Lib C has the same problem the new                                 people apparently actually ended up                                 driving into this exact same rat hole                                 and with their food Tech's                                 implementation actually managed to get                                 it so that it can lose wake ups and have                                 a pride catch its own wake up so there's                                 now been a tighter word mean of the                                 standards say no really don't do that oh                                 there's some other receipts f one of the                                 nice things i mentioned how thirst sleep                                 now has that clock ID thing that's                                 actually exported all the way to users                                 pay to the application level with                                 conditional variables you can actually                                 say wait wait until appointed time so                                 this lets you also say okay wait until                                 this point in time on that clock useful                                 if you have lots of problems with ntpd                                 moving your clock around or something                                 finally implemented barriers spin locks                                 the cancellation stuff is a lot of                                 rappers that is quietly copied the                                 freebsd code filed the copyright up no                                 David just kidding still not done is                                 stuff to do the this signal depending                                 signal set these are the signals that                                 are not yet delivered but that have been                                 sent to this process right now we just                                 have one per thread that is correct                                 you're supposed to have one per thread                                 we also need to have one that's process                                 wide so that threads so that you can                                 have a signal that if it hasn't decided                                 what thread then can end up taking it                                 they can actually be pending for all we                                 actually map that on top of the main the                                 original the initial threads pending set                                 and that does mean that some cases where                                 you can have a thread get a signal that                                 it shouldn't have actually gotten                                 pthread kill is not entirely reliable as                                 a                                 but it turns out it doesn't happen that                                 out it's I can't get a fix it sorry yes                                 oh we want to fix big things faster of                                 course big lock yes we still most                                 everything in the colonel in openbsd                                 still big lock kirche is Kirk you're                                 actually I'm going to steal your notes                                 for your talk later well that's a nice                                 Mac okay a couple other guys hey Burt as                                 Burt is working on the schedule och                                 making it less contended Pete raised                                 mention of the some issues there and                                 we've already got some stuff working                                 forward towards being able to due                                 process shared new Texas where you need                                 the identifiers that inside the kernel                                 of it that you're matching on has to be                                 associated with if you have if you have                                 shared memory between two different                                 processes so they both have a some                                 shared memory segment the address of                                 that should Megan Reese I mean it can be                                 different in the two so you have to kind                                 of transform those addresses into a real                                 unique identifier inside the colonel so                                 you can match them up when you want to                                 identify someone else's mutex a mute                                 exiting the shared memory for instance                                 so we actually got some work going on                                 that already preliminary implementation                                 of the necessary bits there oh of course                                 empty beds for pls and alpha and really                                 would like to get some of these other                                 rocky stuff one cool thing is idea that                                 is that ok on openbsd our God PLT ia the                                 technical stuff from elf standard these                                 are the in direction tables that are                                 used for for linking the thieves are                                 made read-only most the time they're                                 only made rewrite when LDS oh actually                                 needs to update a binding inside one of                                 these so normally when the shared                                 library first goes these are actually                                 all the got entries all point to a an                                 address inside LDS oh and then when you                                 actually try to use a symbol LDS Oh says                                 oh hey you would pass this and it puts                                 the real address in place well in order                                 to do that we have chef too                                 quite a bit of work if to block signals                                 because you we need to do this the key                                 things we have to do this this memory                                 protection beds well because there's no                                 like reference counting on how many                                 times you've made something read/write                                 read-only we need to make sure you don't                                 re-enter this particular chunk of code                                 so we have to block all signals so we                                 can't get interrupted and come back                                 around through it binding again and we                                 also have to make sure that another                                 thread doesn't do the same thing so                                 suddenly this is a simple Oh operate                                 this update this lazy entry suddenly                                 turns into you have two system two more                                 system calls and spin lock if you're if                                 you have the threads library loaded and                                 import tech tyne often involves TLB                                 flushes because you have to go Thresh                                 the page tables a few times and for                                 short-lived processes yes almost all you                                 know most your system calls maybe these                                 lazy binding resolutions k trace can                                 look kind of embarrassing at times in                                 fact unfortunately these are relatively                                 fast system calls the well the sig proc                                 mask is and protect isn't unfortunately                                 but that's that's annoying so what if we                                 actually just had a system call which to                                 do take care of all the mms addy                                 guarantees and because it's in the                                 kernel that can actually cheat and                                 updates the the address some of the map                                 pins behind your back you don't have to                                 flush all the tlds you do have to flush                                 on the caches you have two other let                                 other cpus know so they don't have bad                                 bait you know cached versions of the                                 page it's been updated but you can pull                                 off some some optimizations there so                                 this was a one idea the idea is that                                 you'd actually tell the colonel also yes                                 I know this area is read-only just do it                                 anyway this isn't Rick's ok PowerPC you                                 actually have to write a couple                                 different things so suddenly the system                                 call starts growing more arguments and                                 getting more complicated it's yo-yo of                                 your on spark you have to write the                                 bytes in backwards order and call i sync                                 between HP man and then ok is this this                                 going to turn into a problem because                                 look if aren't people isn't this the                                 first thing the attacker is going to try                                 to use because hey look i can write over                                 a read-only page whoo so maybe with                                 to figure kind of work out what are the                                 how can we prevent to this from being                                 that sort of a problem can we walk it                                 into LDS Oh some way tell the colonel                                 ahead of time only this caught well                                 returns to oriented programming it's a                                 nominee people here and what rough is                                 returned over to programming basically                                 it's a it's a task method where instead                                 of calling into lipsy to do something                                 you set up a stack which says I need to                                 return into a Lib C function the middle                                 of illiteracy function which happens to                                 do the right operations and then do a                                 return and on platforms like i                                         may involve returning into the middle of                                 an instruction which when decoded on the                                  non anticipated instruction boundary                                  looks like the right instructions now                                  this seems kind of okay really could                                  this work okay here's how far it's gone                                  there's some guys who came up with a                                  compiler for compiling sparks okay so                                  fixed instruction size spark on solaris                                  return oriented programs i have a Turing                                  machine built on top of gadgets stuffed                                  in lid see so oh and this involves no                                  writing over of text or anything all you                                  have to do is be able to write over                                  someone stack if you can write over                                  someone stack you can run a Turing                                  machine yeah so if they could return                                  into LDS toe and hit this then they                                  could over they could do whatever they                                  want it that way so the finding some way                                  to actually protect this would be                                  necessary before we actually try making                                  this real other things would really like                                  for a local storage with the the bits of                                  the the TCP stuff we have most of the we                                  have the curl based basically what's not                                  there has been utilises GCC ok bin utils                                  we have is an old urban utils they                                  change some lights a license in annoying                                  way and it was never fully implemented                                  for at least a couple of our hppa i                                  think and spark actually they might not                                  have the ganoub in utils might not have                                  actually got that one done so we'd have                                  to update that but there is some stuff                                  that now really wants to use it um you                                  can't deal and some other annoying                                  things oh yeah we want to fix inbox i                                  hear                                  urgently and the annoying thing of                                  there's a big lock in lib see around the                                  resolver which means that for instance                                  in Mozilla if you have a slow with some                                  dns resolver out there which is slow it                                  often well look I can't resolve any web                                  pages okay so we're working on a sink                                  resolvers a different thread son of a                                  problem any questions either very good                                  or very bad SB um you have to go that's                                  basically what the interaction to the                                  jump table does is you basically move                                  out of LDL so particular three locations                                  LDS oh we could I guess you could try to                                  hack an LDS Oh a way to say flush a set                                  of relocations the problem is someone                                  enough could you be in the middle of one                                  of those calls and what's gonna happen                                  when you try to return back out of that                                  so it's I guess it's probably possible                                  but it's the node method is to go ahead                                  and use the jump table that's what                                  solaris freebsd i think probably never                                  see Bobby that dead to it so it's that                                  the known method in everyone knows it                                  work so we probably doesn't do the same                                  thing rather than try to I don't think                                  trying to teach all the s.o is the                                  benefit for doing it for other things is                                  probably pretty if no one else does it                                  then no one's can take advantage of it                                  if we took it matter okay                                  correct we assist sis Pete race now                                  actually has a call to inferiors itself                                  to say Oh am I trying to parent recall                                  this on one of my own parents if so ban                                  it the one exception is if you are in                                  permanently in secure mode then you can                                  do in it because otherwise there'd be no                                  way to ever p trace it and so someone                                  could probably come up with a useful                                  case for doing that so I said okay if                                  you're probably in security that the                                  check is turned off but ya know                                  otherwise no nope your parenting your                                  parent no be parenting your parent no                                  one else let's calls out of the girl
YouTube URL: https://www.youtube.com/watch?v=xAJpfy_Hhy4


