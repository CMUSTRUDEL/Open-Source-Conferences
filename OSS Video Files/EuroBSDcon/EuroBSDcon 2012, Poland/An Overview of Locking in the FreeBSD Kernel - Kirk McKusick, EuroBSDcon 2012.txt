Title: An Overview of Locking in the FreeBSD Kernel - Kirk McKusick, EuroBSDcon 2012
Publication date: 2012-12-07
Playlist: EuroBSDcon 2012, Poland
Description: 
	EuroBSDcon 2012
Warsaw, Poland 18-21 October
Captions: 
	                              okay well thank you all for choosing to                               come to my talk not freedom from choice                               right what you get with a single track                               okay so what I want to talk about is an                               overview of walking in the freebsd                               kernel I don't really think of this as a                               keynote talk I think of it as sort of a                               technical talk but you you can go out                               you know thinking about locking which                                some people seem to spend a good deal of                                their life doing this it was pointed out                                to me that that is not the Polish                                spelling of University it's also not the                                English spelling of University it's just                                a spelling error okay so I'm gonna start                                by giving you sort of a talk about how                                we historically did synchronization that                                was back in the the Dark Ages before                                many of you were born dinosaurs and                                mainframes ruled the earth etc will then                                move into the modern age with how we                                historically did move into the modern                                historically it's moved into the modern                                shot and then I'm gonna go through                                turnstiles and sleep cues which is the                                underlying mechanism that we use to                                implement locks and then I'm going to go                                through and give you sort of a slide by                                slide detail of each of the types of                                locks that we have in the system and try                                and motivate why it is that we need                                about eight different ways of doing                                locking and then finally we'll talk                                about the witness system which is the                                mechanism that we use to avoid deadlocks                                okay so the historic synchronization was                                done in sort of the as shown in this                                slide we would start by checking for a                                resource so just to make this concrete                                let's say we need the the page that                                represents the password file and that'll                                normally have been brought into memory                                it'll be sitting around in memory                                somewhere so we'll go find that page in                                memory and then to check for the                                resource we need                                see whether it's available or not and                                there's just a couple of flags that are                                defined there one is a walk flag a walk                                flag is said it's in use and if the                                locked leg is clear it's available so if                                we go and we find that the walk flag is                                set we know that someone else is using                                that reading/writing whatever and so we                                can't have it right now and so there's                                another flag the want flag and we set                                the want flag and then we go to sleep on                                it and when we talk about going to sleep                                on it what does it mean to sleep on a                                resource well for those of you that took                                my tutorial you know that forever is not                                a word that you want to use in the same                                sentence with operating system so we do                                not want to sleep forever                                for example and so you have to tell it                                why it is you're going to sleep what                                resource you're waiting for you can't                                just decide that you've stayed up too                                late last night and want a nap you                                actually have to set an alarm clock so                                in this case the identifier for the                                resource is just the address of the                                first byte in the resource and so you'll                                see sleep being passed all these                                pointers to proc entries and buffers and                                other things it's never dereference ism                                it's just using that as a unique number                                okay so we go to sleep on it and then at                                some point in the future when it becomes                                available we'll be awakened so whoever                                is comes along and doesn't find it                                locked ie it is available will start by                                setting the lock flag and then they'll                                use it possibly sleeping in the process                                of using it anyway when they're                                eventually done they will clear the lock                                flag to indicate they're no longer using                                it and then they check to the one flag                                to see if it's set and if it is set then                                they know that while they had it lock                                some other process came along that                                wanted it and they will end up waking up                                all the processes that are sleeping on                                that resource why all of them why not                                just one of them                                well again we just want to be able to be                                absolutely certain that we're never                                going to leave anything asleep forever                                if we just wake them all up those that                                 care about it can dive in and fight over                                 it and the rest of them can wander                                 do whatever if we know that the                                 processes will never wander off they                                 will always come around and use it we                                 can use a version of wake-up called wake                                 up one that wakes up just the one that's                                 been sleeping the longest and then when                                 it's done it'll wake up the next one and                                 so on                                 but if you're not sure then you just do                                 a wake up on everything and let them                                 fight it out and of course if you've                                 done blocking properly you've got the                                 right level of granularity you'll                                 typically never have more than one thing                                 waiting anyway so it shouldn't normally                                 be an issue okay so all of this business                                 of setting want flags and lock flags and                                 so on worked fine because we were                                 running on a you know processor and                                 there was a single thread of control                                 running and we didn't have to worry                                 about you know checking that the lock                                 flag was not set and then between the                                 time we did that and and set the wait                                 flag and went to sleep the other thing                                 we'll bet cetera so it was very                                 straightforward very easy to do once you                                 start getting multi-threading going on                                 in the operating system now you have to                                 be much more careful about the way you'd                                 manipulate these things when you get                                 down to the bottom of it a lot of the                                 flocks we're gonna look at still have                                 things like locked legs and want legs                                 but they're hidden inside the locking                                 API and they have new Texas around them                                 to make sure that the right things                                 happen and so on okay so that's the old                                 world what's the new world the new world                                 is that we have this whole hierarchy of                                 locks and this slide goes from the                                 lowest level locks which is the hardware                                 all the way down to the highest level                                 which is the witnessing code that's                                 making sure that bad things aren't                                 happening at the very bottom level we                                 need to have hardware support we cannot                                 implement locks without some support                                 from the hardware itself and the sort of                                 generic low level hardware in operation                                 that we need is something that both                                 reads and writes a location in memory                                 with no intervening operations on that                                 memory look                                 testin set is the traditional thing that                                 you would learn in the textbook that is                                 we pull an existing value out of the                                 memory and then set it to let's say                                   and then look at what you pulled out and                                 if what you pulled out is zero you know                                 that you've got the lock and if what you                                 pulled out is                                                          else had the lock and because those two                                 operations never interleave you don't                                 get one thread that pulls out a zero                                 another thread that pulls out a zero and                                 then them both sticking one in there                                 once I pulled out the zero I'm                                 guaranteed that the one it's going to be                                 put in before any other thread is going                                 to be able to look at that memory                                 location and that locking is something                                 that the hardware has to give to us now                                 as you'll see we actually use something                                 that's a little higher level than test                                 and set we use compare exchange which                                 I'll talk about the method that we use                                 for using that operation but it's the                                 same idea we pull a value out and then                                 we stick another value in there so with                                 this low level interface low level                                 instruction we can then start to build                                 software locks and the lowest level lock                                 that we build is what's called a spin                                 mutex so a mutex it is a mutual                                 exclusion so it's single user exclusive                                 use and it's the spin lock is going to                                 work by looping over at least logically                                 looping over tapped and said it's gonna                                 do test and set did I get it no testing                                 set did I get it no and it's just gonna                                 wait until someone else comes along or                                 whoever holds it comes along and puts a                                 zero back into that location to say that                                 it's now available now obviously a spin                                 lock is you're not getting anything else                                 done you're just sitting there and so                                 these types of locks are only used for                                 operations that you do not expect to                                 take very long it's something like you                                 want to insert something into a linked                                 list so you lock the list because you                                 don't want someone to you know get                                 corrupted while you're changing the                                 forward and backward pointers                                 and then you release it so small numbers                                 of instructions and hence it's actually                                 more efficient to just sit there and                                 wait for something to become available                                 than it is to contacts which way and                                 then come back later because context                                 switching away it's typically several                                 hundred instructions coming back as                                 several hundred instructions more and if                                 you're only going to wait for ten                                 instructions you're better off to just                                 wait okay now as you'll see spin new                                 Texas are actually used in just a very                                 small number of places in the system                                 because what actually makes a little                                 more sense is what's called an adaptive                                 lock and that's going to be this whole                                 next set of locks here these are locks                                 that can block briefly but they're not                                 allowed to go to sleep now what do I                                 mean by blocking briefly the thing that                                 really sort of identifies this class of                                 locks are things that someone else may                                 hold the lock but the only reason that                                 they hold it it's is that you know                                 they're gonna do some upset of                                 operations and when they've done that                                 set of operations there they're gonna                                 release the lock and so if something is                                 locked then what we will typically do is                                 just spin and wait for it if the process                                 that holds the lock is actually running                                 if the process that holds the lock is                                 not running typically because they're                                 waiting for some other lock to clear                                 then we will block in particular so that                                 we can hand potentially the CPU over to                                 whatever holds the lock because if they                                 simply get an opportunity to run then                                 they will do so and give up the lock and                                 then when they give up the lock we grab                                 the CPU back again so this blocking as                                 you'll see is the only a very brief                                 block it's not going to sleep and going                                 off and and doing something else as                                 you'll see for this later class of locks                                 down here alright so in this class the                                 locks that are built around this concept                                 of blocking but not sleeping we have                                 first of all the block                                 mutex which is spin for a while and then                                 block on a turnstile I'll describe                                 turnstile shortly we have what are                                 called pool mutexes it turns out that                                 creating a mutex is a non-trivial amount                                 of work you have to initialize the mutex                                 which you know clears the memory and if                                 we're running the witnessing code                                 registers the mutex with the witness and                                 then when you're done with the mutex you                                 have to unregister with the witness and                                 pull it out of the various lists that's                                 on before you can discard it and there's                                 some data structures that we need to                                 allocate that don't live for very long                                 the classic of this is the Select system                                 call where you come in you create a                                 bunch of data structures correspondent                                 all things you're interested in in                                 finding out about and then when                                 something becomes ready then we clear                                 all those things out and tell you what's                                 ready and so the lifetime of the the                                 piece of memory that's allocated for                                 each of those is the lifetime of one                                 select call and it turns out that                                 creating and destroying the mutex would                                 nearly double the cost of setting that                                 thing up and so we just keep this pool                                 of pre-allocated mutexes and when we                                 need one briefly we just go to the pool                                 grab it use it and then just give it                                 back to the pool and so we don't have to                                 initialize it we don't have to free it                                 and in fact we don't even need to                                 allocate space because they're fairly                                 big things we just have a pointer that                                 points at this mutex so they're just                                 like the blocking new Texas but they're                                 just it's a pool of them that are                                 available for short-term use next up on                                 the hierarchy or reader/writer locks                                 these are mutexes that have shared                                 exclusive semantics so unlike the the                                 sort of low-level mutexes which was                                 early mutual exclusion these are you can                                 have shared so you have multiple people                                 that are reading or course a single one                                 that has it for writing and then finally                                 in this class we have something called                                 read mostly locks and these are locks                                 that are optimized for the read case so                                 if you have something that you're mostly                                 reading and only occasionally writing                                 than you                                 use these sorts of locks because the                                 reed case is quick and the the right                                 case is much slower than it would be for                                 one of these others and again I'm going                                 to give you the details of these as we                                 start drilling down into them                                 alright this the other class of locks                                 that we have here are things that are                                 using the sleep queue interface they                                 look a lot like those traditional ones                                 that I described and in fact this really                                 is just kind of wrappers around that                                 sleep and wake up paradigm we have                                 shared exclusive locks these are fast                                 and simple versions of sleep locks these                                 locks are used in the instance where you                                 have some sort of a long-term event a                                 long-term event is going to be something                                 like I need to do disk i/o and so I'm                                 gonna be blocked waiting for the disc to                                 respond so maybe                                                        can get a lot done in                                          milliseconds that's obviously millions                                 of instructions and so you're it's well                                 worth going to sleep and letting other                                 things run and then when the i/o                                 completes we'll switch back this is also                                 going to be events like waiting for                                 network traffic waiting for users to                                 type things at keyboards some of these                                 long-term events can be very long-term                                 events all right                                 we have condition variables which is                                 really just a wrapper on that                                 traditional sleep and wake up and then                                 finally we have the lock manager these                                 are long-term this is the all-singing                                 all-dancing we do everything interface                                 so you have shared and exclusive and you                                 can upgrade and downgrade and drain                                 things in preparation for freeing them                                 and other things of that ilk and then                                 finally the bane of locking is deadlock                                 so I'll talk about what deadlock is for                                 the three of you that don't know and                                 then talk about how we can monitor                                 what's going on to avoid having that                                 happen okay so before we actually look                                 at the locks themselves I want to look                                 at the data structure that we are you                                 going to use in order to                                 these locks because if you understand                                 the data structure the blocking just                                 kind of falls out so these things are                                 called turnstiles these are used by the                                 blocking mutexes the reader writer and                                 the read mostly locks and of course the                                 pool locks as I've already said these                                 are designed for short periods typically                                 tens of instructions and you what you                                 actually use them for is to protect read                                 and write access to data structures so                                 for example with the the walking that we                                 looked at earlier we need to have a                                 mutex around checking to see if the lock                                 flag is set and setting the wait flag                                 because we don't want to have a race                                 condition where we check it and I think                                 it's locked and then set wait only to                                 have it be freed while we're doing that                                 so that's the sort of operations that                                 you'll typically see mutex they say                                 they're usually in the same place on                                 your screens you know sort of mutex a                                 few lines of code and then we free the                                 mutex okay the one of the rules that we                                 have is that you're not allowed to hold                                 a turnstile essentially a mutex when you                                 request a sleep lock it is not                                 permissible to go to sleep holding one                                 of these short-term utexas because if                                 you did that now the mutex is going to                                 be held for a very long time potentially                                 we don't want that to happen in                                 particular one of the rules about these                                 mutexes is that you can always get it to                                 be released                                 simply by scheduling whoever holds it to                                 run now as you'll see that may                                 recursively cause other things to run                                 but the point is that the only reason                                 the thing is held is because is simply                                 either hasn't gotten to the end of its                                 critical section yet or it's just                                 waiting to be scheduled so that it can                                 do that all right we need to track the                                 current holder of the mutex and the                                 reason that we need to track the current                                 holder of the mutex is for something                                 that we call priority inversion one of                                 the issues that we can have is that some                                 relatively low priority process is sort                                 of plodding along                                 in its thing and it acquires a mutex and                                 now some really high level high priority                                 important critical thread is comes along                                 and it needs that mutex and it can't                                 have it because it's locked and the                                 problem is that that's low priority                                 thing may not get to run for a long time                                 and we need that mutex now not some time                                 when that other process gets around to                                 being scheduled and so what we do is                                 something called priority propogation so                                 this high and mighty thread comes along                                 and it sees that this other low-level                                 thread is not running at the moment and                                 so what it will do is it will block and                                 hand the CPU to that low priority thread                                 and say as of right now you're in my way                                 so you're important have this high                                 priority and bam the thing starts                                 running it goes a few more instructions                                 it releases the mutex and suddenly it                                 loses all popularity and gets whacked                                 back down where it came from                                 and the priority comes back to the high                                 priority thread who now rips on through                                 we had this experience actually when we                                 took the train from Berlin to Warsaw we                                 were on the Express train and they were                                 doing a lot of track work and so they                                 had a single track whenever our Express                                 train would get there all the other                                 trains would be stopped so we could go                                 the wrong you know way down the other                                 tracks we'd come out the other side of                                 this thing and there'd be like                                           all these people staring out but who's                                 you know forcing us to sit here for                                    minutes it's like okay so let's take a                                 look at the implementation of turnstiles                                 here so I'm going to sort of flip back                                 and forth between this slide and the                                 this slide that actually how's the                                 picture ah not so the first thing that                                 we need to be able to do is to quickly                                 find the turnstile that's associated                                 with the lock and so we have a hashing                                 header obviously and then a set of                                 pointers so if we have in this picture                                 across the top I find a button across                                 the top here is the hash header and now                                 down the left hand                                 you can see I have six threads one two                                 three four five six and then these boxes                                 out here are the things that are keeping                                 track of what's going on so we can see                                 up here that thread number one is the                                 owner of the this pointer here said this                                 this turnstile is referencing block                                 number                                                             thread number one over here and then we                                 can see from thread number one the                                 things that actually owns is this which                                 is lock                                                              here it also holds the block                                            we can see waiting for this lock number                                                                                                     thread number three if we have a                                 question of who owns lock number                                       can just do a hash on the the hashing                                 header is here based on the lock number                                 and so                                                                 and so then what we do is we go here we                                 see yes that's lock                                                     quickly identify that thread number                                   here is the owner I'm not quite sure why                                 it's doing all this okay so the the hash                                 header then is the thing that allows us                                 to the time                                 eat a turnstile each time a thread                                 blocks so if a thread blocks then we                                 need to have one of those turnstiles                                 that tells us who we now when thread two                                 comes along we need one of these                                 structures now we could have one of                                 these structures allocated for every                                 single lock in the system but in fact if                                 you think about it a thread can only                                 ever be blocked on one thing at a time                                 because if it's blocked well it's not                                 running                                 and it can't therefore try and get                                 something else so instead of allocating                                 one of these turnstiles for every lock                                 in the system we allocate one for every                                 thread so when part of creating a thread                                 is you also allocate a turnstile to go                                 with it and so when thread two shows up                                 and wants to get lock                                                   it hands its turnstile structure over to                                 this to the kernel and the kernel then                                 uses it to link this in now thread                                   comes along and it also blocks and you'd                                 say well you know it's gonna give it                                 turnstile                                 over but we already have this turnstile                                 so you would think well we don't need                                 the one from thread                                                     it so you see this one over here it's                                 not linked into anything it's just                                 hanging off this list of extras and the                                 reason for this is that once thread                                   gives up the lock we're now going to be                                 able to give it the lock to thread                                   well thread                                                              and so it's going to meet one its                                 turnstile back but its turnstile is                                 still in use here tracking the fact that                                 thread number                                                           we have thread number three's turnstile                                 that it turned in here so we just give                                 that the thread number                                                necessarily get back the one that you                                 gave but you'll get a turnstile and now                                 thread                                                                   and now finally when thread number                                   gets to run after thread twos release                                 the lock now there's nobody waiting so                                 we can pull this out of abuse here and                                 turn this turnstile back to thread                                       let it go wandering off                                 and you know the reason that we allocate                                 one per thread is that there are far                                 fewer threads in the system than there                                 are locks if you think about it                                 every process entry has at least two or                                 three mutexes in it itself all by itself                                 and then of course there's new Texas all                                 over the place for lots of other things                                 so it's actually a lot more efficient to                                 just have one per thread than it would                                 be to have one per lock okay so that's                                 how these things get get managed okay so                                 going back here                                 turnstiles need me when it blocks can                                 only block in one at a time so it                                 provides its turnstile the unneeded                                 turnstiles are saved and returned when                                 the thread awakens and this is the                                 priority inversion that I've already                                 talked about if the holder of a lock has                                 a lower priority than the thread that's                                 about to be blocked we recursively                                 propagate the higher priority to the                                 holder but only until it releases the                                 lock so it propagates to the whoever                                 holds the lock if they're blocked by                                 some other thread then it will propagate                                 down to that thread and we'll just keep                                 going down until we find a thread that                                 is just waiting to be scheduled and then                                 once we schedule it it releases lock and                                 then it just would have bubbles all the                                 way back up again                                 okay so turnstiles are really sort of                                 the the crux of how all this is going to                                 work and so if you just sort of keep                                 that in mind                                 the implementation of the locks becomes                                 fairly straightforward okay sleep queues                                 look a lot like the turnstiles I've just                                 described these are used by the                                 longer-term locks designed for long-term                                 periods                                 there's no priority propogation that                                 goes on with sleep cues because they're                                 not waiting for CPU they're waiting for                                 some event to happen                                 making a process that's asleep waiting                                 for disk i/o runnable isn't going to                                 make the i/o finish any sooner it's                                 gonna finish when it finishes and it's                                 pointless to give it a higher scheduling                                 priority you cannot own a turnstile type                                 of lock when you request a sleep queue                                 because that would then make it                                 impossible to do priority propogation                                 like the                                 the others we do track the current                                 exclusive lock holder but by default we                                 do not track all of the readers of a                                 lock as you'll see we actually have one                                 interface that allows you to do that                                 if desire and then these locks are                                 allowed to be recursive now what do I                                 mean by a recursive lock what I mean by                                 a recursive lock is that you can come in                                 and grab an exclusive access to a lock                                 and then later come along and ask for                                 the same lock exclusively a second time                                 and you'll get it and what will happen                                 is we just keep a reference count of how                                 many times you've asked for an exclusive                                 lock it just goes up up up and then each                                 time you do an unlock we decrement the                                 count and when the count goes to zero                                 then the lock is released now you might                                 wonder why it is that you would want                                 recursive locks and the answer is                                 normally you don't if you ask for the                                 lock that you already own a second time                                 that's usually a programming error we                                 sometimes refer to these as books so by                                 default locks do not allow recursion and                                 if you ask for a lock that you already                                 own you will panic with locking against                                 myself                                 however there are places where it is                                 sensible to have recursive locks an                                 example of this is the layering that we                                 have a file system so you can have a ZFS                                 file system and then on sitting on top                                 of that it can be NFS which is exporting                                 it somewhere else                                 so you come into the NFS layer and it                                 locks the the object that you're trying                                 to deal with and then it actually gets                                 passed down to ZFS to provide the actual                                 data and ZFS being unaware of the fact                                 that the request is coming from NFS goes                                 ahead and locks the thing that is about                                 to manipulate and if we didn't have                                 recursion at that point we'd panic and                                 in the old days we didn't allow                                 recursive locks and so there was all                                 this flags you'd pass up and down saying                                 I've already got it locked don't ask for                                 a lock and that you just never get that                                 right                                 so besides which is a horrible layering                                 violation so we just said fine we'll                                 just allow locks to be recursive and so                                 that can be locked by NFS and then                                 locked by ZF house and ZFS unlocks it                                 and then NFS unlocks it and then it's                                 released okay but that when you create                                 the lock you have to say that this one                                 should be recursive if that's the case                                 of course people get the panic locking                                 against myself sometimes their solutions                                 say oh just make the lock recursive it's                                 like no think about this there's a                                 reason we have that panic in there okay                                 so let's now just want to work our way                                 up through all the various different                                 locks that we have the first thing that                                 we have isn't really a lock per se is                                 what's called a critical section and it                                 uses critical enter and critical exit                                 and when you go do a critical enter that                                 says that you may not be D scheduled and                                 you may not be moved to another CPU you                                 are on this CPU you're not going to be                                 moved anywhere else you're not going to                                 be preempted you're just going to run                                 until you do critical access and so the                                 the critical sections are used much like                                 the old single threaded kernel used to                                 do things called SPL where you could                                 block out classes of interrupts for a                                 period of time so you knew that an                                 interrupt wouldn't come in and mess                                 around with things they're useful for                                 protecting her CPU data structures so if                                 you have a run cube that's only ever                                 going to be accessed by that CPU you can                                 just use a critical section to protect                                 access to it and then you don't need                                 that to have locks and mutexes around                                 that thing it does not protect                                 system-wide data structure because other                                 CPUs can continue running and so if you                                 have a data structure that can be                                 accessible to different CPUs a critical                                 section is not going to help you in that                                 case but there's a small amount of per                                 CPU data and it is protected with these                                 critical sections okay now I already                                 sort of gave you the thumbnail sketch                                 about the hardware requirements for                                 locking the minimum requirement is test                                 and set on modern hardware                                 there's compare-and-swap which is what                                 freebsd uses now you need to be a little                                 careful about the way you actually                                 implement these instructions or use                                 these instructions you'll notice on most                                 architectures that they're sort of two                                 flavors of tests and Sanger                                 compare-and-swap there's the sort of                                 lightweight version which just makes                                 sure that within if there's a you know a                                 contact switch that the instruction will                                 have completed or will not have started                                 it won't gets what a half way through                                 the instruction and but it's not really                                 locking against other CPUs and then                                 there's the the testing set interlocked                                 which is historically unlocked the                                 memory bus so that nothing else could                                 get on there while it did the tube the                                 read and the write operation                                 well locking the memory bus is not real                                 good for performance if you do a lot of                                 that so you do not want to create a spin                                 lock by doing test and set interlocked                                 and just keeping the memory bus totally                                 locked up all the time so what you'll                                 typically see is that you do the hard                                 core test and set interlocked and then                                 if you don't get it you just tore do the                                 lightweight thing to wait until you                                 looks like it's gonna be available and                                 then you do another single one of these                                 hardcore test them set interlocked and                                 type of instructions and you may or may                                 not get it because someone else may have                                 beat you to the punch                                 but you you you want to avoid doing the                                 thing that's gonna cause that's this                                 memory bus locking now modern                                 architectures don't block the whole                                 memory bus anymore that but they do lock                                 a chunk of address range and so you                                 still a good idea to avoid using those                                 anymore than necessary okay now the                                 compare and swap instruction instead of                                 just doing a single bit is is takes a                                 thing to be compared                                 so pulls out the the entire value of the                                 word compares it with the thing you've                                 asked it to compare with and then sticks                                 in whatever it is that you tell it to                                 put in there so the owner field for a                                 lock that's free contains this scratch                                 define thing called mutex unknown so it                                 says this thing is                                 is is not currently in use it's it's                                 free it's available and then the owner                                 field for a whole lot that's held that                                 that somebody holds contains a pointer                                 to the thread that actually owns the                                 thing and so what will happen is that                                 when we do the compare and swap the                                 allocation attempt compares the lock                                 owner with mutex Unown and then if it                                 matches if the thing that it pulls out                                 matches mutex unknown then it stores                                 into that location a pointer to the                                 thread that's just acquired the lock if                                 it doesn't match new Texan owned ie has                                 already held then it leaves the the                                 previous owner value in there and that                                 of course is what we have to look at so                                 after that instruction we look at what                                 the previous value was and if the                                 previous value was a pointer to some                                 thread then we know that it was held and                                 in fact we know what thread holds it if                                 the value that we got back was mutex                                 unknown then we know that our pointer                                 has been stored in there and we are the                                 happy owners of this mutex okay so when                                 we're done with it it's very trivial to                                 give it back we'll just unconditionally                                 store new tax on owned into that field                                 and that then makes it available for                                 someone else to grab okay                                 so that's the sort of low-level                                 mechanism that we have for implementing                                 all of these other locks okay so                                 starting with spin mutexes this is                                 exclusive access only it's going to loop                                 waiting for the mutex to become                                 available so it's just gonna sit there                                 trying over and over and over to get it                                 and it runs inside a critical section                                 while the lock is held or while we're                                 doing that to essentially avoid                                 deadlocks and I don't really have time                                 to explain the deadlock situation it's                                 actually more expensive to obtain than a                                 blocking mutex and in freebsd is only                                 used for low-level scheduling and                                 context switching so other than that one                                 little                                 domaine everything else is going to be a                                 higher-level                                 type of lock like a blocking mutex okay                                 blocking mutexes are also exclusive                                 access it uses adaptive spinning so                                 it'll only spin waiting as long as the                                 holder of the lock the current holder of                                 the lock is actually running so if the                                 current holder of the lock is not                                 running then we will block typically so                                 that we can hand our CPU over to however                                 holds the lock so they'll finish using                                 it and then assuming we're higher                                 priority we'll grab it back as soon as                                 they're done with it when a when we                                 finish using a lock you remember there                                 was that list of others that were                                 waiting for access to the lock and in                                 fact we awaken all of them we do not                                 just awaken the first one we go through                                 we awake and all of them the reason for                                 this is it's much cheaper to release an                                 uncontested lock because all we need to                                 do is store that value in there we don't                                 need to run around and deal with                                 turnstiles and rundown lists and all                                 those other things and you'd say oh yeah                                 but then they're all gonna dive in                                 potentially on separate CPUs and they're                                 all gonna just fight with each other and                                 we're gonna end up creating turnstiles                                 again but that's not going to happen                                 because of the adaptive nature of these                                 locks what's going to happen is one of                                 them's going to get it and the other is                                 going to see that they the one that has                                 it is running so they're just gonna sit                                 and spinning waiting and then when they                                 give it up built the the one that's                                 spinning and waiting will get it so the                                 the other thing is that if they're all                                 at the same priority then typically                                 they're going to get scheduled one after                                 the other anyway but in any case the                                 upshot is that it's just cheaper to just                                 wake everybody up now again there's a                                 certain assumption going on here that                                 you have fine enough granularity on your                                 mutexes that you're not going to end up                                 with hundreds of things waiting on a                                 mutex you have got hundreds of things                                 waiting on a mutex you probably need to                                 rethink the way you are implementing                                 that data access                                 okay Poole mutexes again I pretty much                                 giving you the details on this it's used                                 for small short-lived data structures                                 something where you just need a mutex                                 for a little bit and it's not worth the                                 whole cost of setting it up and tearing                                 it down and it keeps your data structure                                 small because it just needs a pointer                                 instead of embedding an entire mutex and                                 as I said the typical example this is                                 the polling system where you need a                                 structure just long enough to track a                                 request and during a period of a single                                 system call okay the last of the                                 short-term locks is actually not the                                 last the next the last is the                                 reader/writer locks in addition to the                                 exclusive access that you get it also                                 provides shared semantics and it uses a                                 turnstile so obviously you can't sleep                                 as with any of these other short-term                                 locks it has priority propogation for                                 the exclusive access but it does not                                 provide priority propogation for the                                 shared access and again unlike the                                 others these type of the redirection can                                 say that they're recursive in the way                                 that I described okay the last of the                                 short-term locks are the so called read                                 mostly locks they have the same                                 properties as the reader/writer locks                                 except they do add priority propogation                                 for shared access where they can and                                 they use that the problem is that you                                 need a data structure to keep track of                                 who all the readers are and so if you                                 want to have the readers tracked in                                 order to provide priority propogation                                 the interface to it requires the caller                                 into the lock to pass in a data                                 structure that's going to be used to                                 track all the readers so each time a                                 reader comes in they hand in one of                                 these structures and then it's really                                 just a linked list and each element                                 there then points to a reader and so you                                 just add that little structure on to the                                 list and set its pointer to point to who                                 gave it to you and in this way we can                                 figure out who all the the readers are                                 so if a reader comes along                                 we have a writer that's really low                                 priority holding the lock and we got a                                 bunch of readers and a high priority                                 reader comes along they can propagate                                 that priority to the writer so the                                 writer will finish using the lock and                                 now the readers can get in okay it is                                 designed for fast access for readers I                                 think I've said that about                                              and it assumes that there's not going to                                 be very many writers and so we do what's                                 called opportunistic locking that is we                                 just assume that there's not going to be                                 any writers and then it certainly turns                                 out after you know after the fact that                                 we were wrong then we have to back up                                 and do the whole thing the hard way so                                 the the place that you find this for                                 example in the system is something like                                 the routing table the routing table                                 doesn't change all that often but you're                                 looking up routes pretty much on every                                 packet that's going off the machine and                                 so lots of readers of the routing table                                 not too many writers and so having the                                 read pace be optimized to be fast is a                                 benefit okay                                 so the actual best way to implement read                                 mostly locks is patented by IBM now IBM                                 allows GPL code to use their patented                                 implementation at no cost but if you're                                 not GPL then you're not allowed to use                                 the patent and they're obvious                                 motivation here I mean we went to them                                 and said well you know we're open source                                 software can't we use it and there's                                 they said well basically you know if we                                 let you do it then essentially it makes                                 the patent worthless to us because now                                 anybody can pretty much use it at that                                 point they had a point but what it means                                 is that since the FreeBSD is not GPL                                 this actually it works against us                                 because we can't use this optimal                                 solution so we have to use a slightly                                 slower technique the fact that matter is                                 that it's like well it's pretty close to                                 that but it's just far enough off that                                 it doesn't violate the patent and                                 surprisingly it looks rather similar to                                 that technique and isn't really very                                 much slower                                 I think that's enough about that since                                 I'm on video okay shared exclusive locks                                 but it's the fastest and simpler lock                                 fastest and simplest of the locks that                                 are allowed to sleep and it provides                                 unsurprisingly shared and exclusive                                 access it you can specify that it's okay                                 for it to recurse some of the things                                 that where it starts to differ is that                                 the request you can you can say that you                                 will allow it to be interrupted by a                                 signal and in fact if it's a really                                 long-term sleep you should allow it to                                 be interrupted by a signal so the sort                                 of rule of thumb is that if it's a lock                                 that might be held for more than about a                                 second then you really should set it up                                 to allow signals to come in if it's                                 something like disk i/o since disks                                 never flake out and always respond                                 within                                                                   say if a signal comes in just hold that                                 signal pending and let me finish doing                                 what I'm doing and then after I've you                                 know gone through and gotten ready to                                 return back to the user will post the                                 signal at that time it makes the code                                 very easy because you know that when the                                 sleep wakes up the only reason it wakes                                 up is because whatever you were waiting                                 for is done and so you don't have to                                 check anything you just proceed and go                                 if it's a long-term issue for example                                  you're waiting for the user to type                                  something you don't really know when the                                  user is going to type the next key and                                  now some of these users go off and take                                  five week vacation I mean work jaunts                                  and you know it's going to be five weeks                                  before they're going to type the next                                  character and you know holding the                                  signal for that long probably not a good                                  plan so in the cases where it was                                  potentially a long term sleep you set a                                  flag in saying I'm willing to be                                  interrupted by a signal what this means                                  is that when the sleep wakes up when you                                  return from the sleep you have to check                                  and see did I wake up because what I was                                  waiting for is done or did I wake up                                  because a signal came in and if a signal                                  came in then you have to clean up and                                  whatever it was you're doing return back                                  up post the signal and then if                                  user returns from the signal handler                                  than and has requested that system calls                                  be restarted which is a default then you                                  have to come all the way back down and                                  get everything all set up again so it's                                  much more coding and things to worry                                  about if you say that you can be                                  interrupted by a signal so you just as                                  soon not do that but if it's going to                                  potentially be a long time you need to                                  this has very limited upgrade and                                  downgrade capabilities and like all C                                  blocks does not implement priority                                  propogation okay next up is condition                                  variables this is really just a wrapper                                  on the traditional sleep and wake up so                                  you can wait you can have an optional                                  timing out you can be interrupted you                                  can specify that you want to be                                  interrupted by signals that the timeout                                  just says I want to go to sleep and wait                                  for this but if it doesn't happen in ten                                  seconds I want to wake up anyway                                  because I'm bored and one do something                                  else so you can specify the timeout you                                  can specify that if a signal comes in                                  you should be awakened and of course if                                  you specify either of those things you                                  need to check and see if that's what                                  happened when you returned from the                                  sleep it does allow you to wake up just                                  one of the potential waiters or you can                                  say wake up everyone if you're not sure                                  which one of these you should use use                                  someone that wakes everybody up because                                  otherwise you could potentially end up                                  with something sleeping forever there's                                  that bad word in a sentence so if if                                  you're not sure do the wake up everyone                                  if you absolutely know that anybody                                  that's waiting is going to play well and                                  come home and wake up the next one all                                  right you can go ahead and do that but                                  much as with the new taxes waking                                  everybody up doesn't typically end up                                  with everyone diving in and going back                                  to sleep they tend to serialize ok one                                  little rule is that you have to hold a                                  mutex before you wake up somebody or if                                  you're going to wait so the you have to                                  get a mutex and then say I want to go to                                  sleep and what will happen is that this                                  is to avoid a race condition whereby you                                  don't                                  get to sleep get to sleep before someone                                  else comes along and tries to wake you                                  up and they go to wake you up and you're                                  not asleep yet so they don't see you and                                  now the wake up is lost you go to sleep                                  and you're asleep forever so what ends                                  up happening is you set this mutex it                                  then gets you all the way to sleep and                                  then as the last step of putting you to                                  sleep the mutex is released and now when                                  someone wants to to wake you up                                  what will happen is that again the mutex                                  will be used so that the wakeup won't be                                  done while you're in the process of                                  going to sleep and so you get the mutex                                  then you call the wakeup and the wakeup                                  will free the mutex as part of doing the                                  wakeup okay                                  finally we have the all-singing                                  all-dancing lock manager locks the                                  full-featured it provides shared and                                  exclusive access you can do recursion                                  and you can do timeouts interruptions by                                  signals you can do downgrades you can do                                  upgrades you can do exclusive upgrades                                  which say I want to upgrade from shared                                  to exclusive and I don't want anyone                                  else to sneak in and get exclusive                                  between the last reader going away and                                  me getting it and if you can't provide                                  that to me then return an error rather                                  than giving me the lock you can have the                                  ability to pass ownership of the lock                                  from a thread to the kernel this turns                                  out to be a very useful thing for things                                  like IO because some applications gonna                                  come along it's going to do a right                                  we're gonna lock the buffer while the                                  right is being done but the application                                  typically doesn't wait for it so we just                                  hand it off to the disk and now we                                  return back up to the application later                                  when the IO completes then that lock is                                  going to be released well first of all                                  by the time the IO is complete the                                  process that initiated it may not even                                  be around anymore it may have exited me                                  completely out of the system so it can't                                  undo unlock the resource and there's a                                  check that says whoever unlocks it has                                  to be the one that locked it you don't                                  want some other random person to come                                  along and say I want that oh it's locked                                  well good you unlock it now let me have                                  it so it's again a panic if you unlock a                                  lock that you did                                  acquire well that's not gonna work very                                  well when the disk driver tries to                                  unlock this thing that is finished doing                                  the i/o on the process that got the lock                                  in the first place doesn't even exist                                  anymore and so we have to have some way                                  of dealing with this so what happens is                                  if you're gonna hand it off to the disk                                  driver you change the ownership you say                                  I am no longer the owner of this I am                                  passing ownership of this lock to the                                  kernel and now when the device driver is                                  done it's going to do the unlock it's                                  the kernel and so that's fine and you                                  won't get a panic okay we have the                                  ability to drain all of the accessing                                  threads so if this is a lock that's in                                  embedded in a data structure that I want                                  a free I want to make sure there's                                  nobody like blocked waiting to get                                  access to it so I essentially calling                                  the lock manager and say drain this lock                                  don't let any new requests come in and                                  when all the ones that are already                                  waiting have have proceeded through so                                  there's nobody waiting for it let me                                  know and then once you've done that you                                  know it's now safe to deallocate it and                                  of course like all sleep blocks it does                                  not do priority propogation ok so we                                  finally get to the the yesterday's a                                  stall and that is how do we deal with                                  deadlock well first of all in order to                                  have deadlock you've got to own two or                                  more locks if you only ever owned a                                  single lock you're not going to get                                  deadlock but unfortunately nice as it                                  would be to set a rule that says you're                                  never allowed to own more than one lock                                  at a time that is not a practical thing                                  to do and so we need to have some                                  mechanism for avoiding deadlock well the                                  the sort of issue is to just want to                                  talk about how we get into a deadlock                                  situation here is we have two threads                                  thread Eddy and thread B so if thread a                                  comes along and acquires this lock r                                   and that that'll be fine it gets it it's                                  locked                                  thread B comes along and and asks for                                  our two and that's fine it gets it and                                  now thread a comes along and ask for our                                  two we say oh well that's already held                                  you have to wait until that's available                                  and then two                                  our chagrin the thread becomes along and                                  asked for lock r                                                          sleep saying oh well that's not                                  available we'll put you to sleep until                                  it becomes available and it could take a                                  long time so we traditionally in                                  operating systems if you sort of look                                  back at in the old days first of all                                  there weren't all that many locks since                                  but more to the point was it didn't tend                                  to get in deadlock so what they did is                                  they just had a deadlock manager process                                  and it would just wander around and look                                  for situations like this happening and                                  if it saw that it happened then it would                                  just arbitrarily pick one of these and                                  say okay you dead and that solved the                                  problem which was fine unless it was                                  your max that you hadn't written out the                                  final in two hours which case you might                                  be a little cranky so when the time came                                  to do locking and the UNIX system we                                  decided that rather than running around                                  and trying to find deadlock which is                                  actually not all that easy I mean this                                  one is sort of obvious but they can be a                                  lot harder to detect we want it instead                                  to simply come up with a way of ensuring                                  that we never could deadlock and so what                                  you need to do is to put on what's                                  called a partial ordering of your lock                                  requests and the two rules for partial                                  ordering is we take all locks and we put                                  them in classes so class one here has r                                   and r                                                                     two is r                                                            double prime and now the rules are a                                  thread can only acquire one lock in a                                  class so you can only acquire one you                                  can't get r                                                            those and then the second rule is you                                  can only acquire a lock in a higher                                  numbered class than the highest numbered                                  class for which you already hold a lock                                  so in this case if you hold r                                           allocate something out of our out of                                  class too but if you hold class                                           not allowed to ask for something from                                  class                                                                    comes along and gets r                                               thread B gets r                                               a comes along asks for r                                                  class than the one that r                                            that's fine it blocks now thread bead                                  wants r                                                                   numbered classes in the lock I already                                  hold so I'd have to release lock r                                       then I quest r                                                          as it releases are to thread a is gonna                                  get it                                  thread a is gonna run thread a is gonna                                  release both of these locks and now                                  thread B is gonna get r                                                that it can now come back and reacquire                                  r                                                                     code where you'll be coming along and                                  will release a lock a quieter a lock and                                  then reacquire the one we just released                                  and if you're wondering why in the world                                  that code is there it's precisely to                                  make sure that we followed this set of                                  rules okay well in the old days the set                                  of rules were codified in the comments                                  so every data structure that we had                                  locked associated with it would have                                  comments explaining you know which class                                  it was in or this or that and of course                                  everybody read the comments then the                                  comments were always completely up to                                  date and so we didn't have any problems                                  unfortunately once we started putting in                                  the multi-threading stuff now in                                  addition to all the sleep locks which we                                  had traditionally you've got all these                                  mutexes and there's just this explosion                                  of number of locks in the system and                                  keeping track of you know what the                                  classes are particularly if it's an area                                  you don't normally work in you know so I                                  I know the file system block hierarchy                                  but you know you get me in the                                  networking and it's like scratching my                                  head trying to figure it out and so it's                                  it's difficult with so many locks to                                  just be knowledgeable about the order in                                  which you can get them and some of them                                  are non-obvious orders so what God                                  introduced was this thing called the                                  witnessing code and the idea is the                                  witnessing code is it's going to                                  actually keep track of these classes and                                  the you know the hierarchy the ordering                                  of these classes and it's going to watch                                  every lock allocation and our                                  acquisition and freeing to make sure                                  that the rules get followed and if they                                  aren't followed then it's going to                                  complain about it well this still                                  requires that we figure out what all                                  these                                  classes are and what the correct                                  ordering is and that's a lot of work all                                  by itself so although it's possible for                                  programmers to define these classes in                                  the order of those classes and a little                                  bit of that needs to be done for the                                  most part we just let the witness code                                  figure it out and so what happens is                                  that the witness code simply observes                                  the way locks are being used and from                                  that into its what the classes must be                                  and you'd say well what if it gets it                                  wrong well when it gets it wrong that's                                  when the programmers go in and define                                  things for it and as I say there's                                  probably                                                          definitions and once those are in place                                  it's it's you know sort of the Rubik's                                  Cube you know there's there's just a few                                  little variables and once you've got it                                  sort of lock down it just is what it is                                  and the fact of the matter is that the                                  witness code figures out pretty much as                                  the system boots up because that's when                                  many if not all of most of the locks are                                  allocated certainly all the classes are                                  being defined and the startup code                                  doesn't change a whole lot and so the                                  ordering that it discovers during the                                  startup together with the hints that                                  it's been given pretty much locks it                                  down and it's very very rare that it                                  they you know some change gets made and                                  causes you to have to go fix it now when                                  one of these lock order reversals occurs                                  you actually get a lot of information                                  what it will do is it will essentially                                  give you a back trace of where you are                                  at the time that the second lock was                                  acquired and it will say in that                                  function at that line you acquired this                                  lock and now you at this function at                                  this line you are trying to acquire this                                  lock and you know how to acquire that                                  lock when you hold this other one and                                  usually you look at it and you go go and                                  fix it sometimes you look at it you go                                  huh and in fact there is a mailing list                                  called the lor list the lock order                                  reversal list where some of these really                                  nasty problems get posted it's like well                                  I got this how can I possibly fix it and                                  so then you know endless debate rages                                  and eventually people come to a                                  conclusion and the kind of places that                                  it gets really nasty is things like just                                  to pick one of my favorite things to                                  pick on the networking code where you                                  have a flow of data that starts at the                                  socket and flows down out to the network                                  and you have a flow of data that's                                  coming from the network up to the socket                                  well the obvious order to lock is top to                                  bottom for one bottom to top for the                                  other when you go by now we're gonna                                  have a gazillion lock water reversals                                  and so how do you do the networking so                                  as to not have lor s this is an exercise                                  that's left for the reader because I'm                                  out of time thank you very much
YouTube URL: https://www.youtube.com/watch?v=UfiTV9QWhM4


