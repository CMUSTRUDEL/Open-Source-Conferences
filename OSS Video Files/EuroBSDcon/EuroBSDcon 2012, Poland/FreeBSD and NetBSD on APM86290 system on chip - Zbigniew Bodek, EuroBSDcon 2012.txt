Title: FreeBSD and NetBSD on APM86290 system on chip - Zbigniew Bodek, EuroBSDcon 2012
Publication date: 2012-12-07
Playlist: EuroBSDcon 2012, Poland
Description: 
	EuroBSDcon 2012
Warsaw, Poland 18-21 October
Captions: 
	                              greetings everyone my name is Biggio                               paddock I work in semi half embedded                               systems and today i will be presenting                               our freebsd n that busy ports for the                               APM                                                                  micro during that presentation I would                               like to compare about systems in case of                               the portability but I'm not willing to                               make any statements which system is                                better and which is not I would like you                                to make that decision after the                                presentation so this is a brief                                introduction to my presentation first I                                would like to say a few words about                                embedded systems in general and market                                requirements for those systems then we                                were going to take a look on the                                hardware that we worked on it means the                                APM and especially I would like to have                                you to say some words about method                                passing architecture which was                                introduced to the trip then I will tell                                something about porting operating system                                to an embedded platform and this                                actually can be divided into some parts                                some stages and those stages are going                                to be described and last but not least                                I'm going to say something about testing                                at the bagging and current state and                                future work that we would like to                                perform on this on this part so                                first question what is in a budget                                system actually it is hard to say                                nowadays because embedded systems are                                actually everywhere starting from the                                door bells & ink on several boards but                                the subject of our interest is mainly                                not x                                                                 the market requirements modern                                telecommunication industry demands more                                and more packet processing from the                                embedded platforms along with lower                                energy consumption of course additional                                hardware extra features like packet                                packet classification security                                extensions and uploading engines are                                highly appreciated and according to that                                very important features that are a often                                implied in the upright in the embedded                                systems are these evolving and jeans and                                software maybe few words about software                                in general even most sophisticated chip                                is and just an empty vessel without                                software that is operating its features                                and capabilities and usually we want                                this software as soon as possible and                                when the target is on the market it has                                to be already supported by the operating                                system of course reliability license and                                availability and this is important for                                us because bsd license is very friendly                                for the vendors                                because not everyone wants to share                                their work for free and bsd license                                gives the ownership of the code to the                                person who is developing it and of                                course support for the tips extra                                features okay now few words about the                                hardware a PM                                                        powerpc book he compiled a course in the                                single package apart from other details                                concerning course it is it it is                                delivered with a bunch of peripherals                                integrated in the chip this includes                                gigabit ethernet pci express mount                                memory SATA USB i square C and others                                and of course unship processors are                                assisted with a rich set of configurable                                hardware accelerators focused on packet                                classification scheduling packet                                manipulation and security extensions and                                scheduling and pocket and data                                manipulation is combined in a facility                                named message passing architecture                                okay now i would like to say a few words                                about message passing architecture                                implemented in the APM the core the                                central point of this of this idea is                                Queen manager it allows most efficient                                moving data and packets between the                                processor and integrated peripherals and                                it offloads the CPUs from the from the                                expensive that are servicing and the                                queue manager interface a QMI it is it                                is located in each of the supported                                devices on the trip and it maintains the                                quick the cuse status and a preferred                                buffer status                                okay so data transfers can be organized                                 in queues and qm allows system notes to                                 communicate with each other through the                                 program viewing points and the main man                                 the main abstractions that mechanism                                 distinguishes is Q and a message and the                                 buffer so queues are organized in a                                 circle prefers buffers and our start of                                 chip into main memory and Q and its                                 contents are prefetched on chips as                                 needed the Q state is maintained on trip                                 for each queue and it contains pointer                                 to head and tail occupancy level and                                 other parameters and and when the Q                                 contains messages that are pointers to                                 free buffers in the memory it has to be                                 configured as a people otherwise when                                 the these messages are pointing to and                                 occupied buffers in my memory it has to                                 be configured us working Q so basically                                 we have two kinds of messages in in this                                 in this idea a standard message is                                    kilobytes long and can point to one                                 packet one buffer means packet stored in                                 DRAM and expanded message which is                                    kilobyte lock can point to a maximum six                                 messages                                                                case                                 this next data address for is pointing                                 to another message of the same size                                 ahead so it looks a little bit                                 complicated and this is an example of                                 expanded message research regarding                                 buffers they are fixed size memory                                 locations that are used to store data                                 for instance packets or something else                                 they are kept outside of the chip in                                 theorem and messages in the working you                                 are assigned correspond are assigned                                 have assigned battles a corresponding to                                 the they are assigned to the buffers                                 corresponding buffers in my memory and                                 this assignment is one to one and we                                 have two models of Q usage first one is                                 when where we have one people and one                                 working Q and the second one is when we                                 have one people and one working Q and in                                 addition a completion Q and this this                                 second example is when the producer of                                 the of data wants to know the status of                                 the completion status of the comment he                                 sent                                 this is this is an example of the first                                 model as we can see the producer gets                                 free pools from the triple Q then he                                 updates the corresponding buffer in my                                 memory and then he sends a message The                                 Roar to the work queue of the consumer                                 and from that point the producer is no                                 longer concerned about transferring that                                 duck data so he can eat go back to his                                 own jobs at the time and the consumer                                 and might be occupied doing something                                 else at the time so this data is not                                 lost it's just waiting for for his time                                 to be a processed and after that time he                                 takes the data from the main memory of                                 corresponding address from the message                                 and then the message is a brought back                                 to the people second model and has an                                 additional compassion cue the start is                                 the same practically so the only the                                 only difference is that consumer returns                                 a message to the completion q I saw that                                 producer menu that the command has                                 finished was executed on the on the                                 consumer and then this free message and                                 goes back to the people                                 okay so now i'm going to say few words                                 about porting janeiro phases of porting                                 are divided for instance in a way like i                                 did first is the bicycle selection then                                 a cross built environment preparation                                 system bootstrap early colonel                                 initialization in local s and platform                                 in civilization device drivers along                                 with support for chief special features                                 and the last is testing at the backing                                 so i will start with the first point in                                 our development we started from a                                 freebsd                                                               basic support for PPC                                                 was unofficial part and not integrated                                 to the main source and finally we wanted                                 to move our work to freebsd nine but                                 this was a good start and we had more                                 out of experience and examples of this                                 this kind of trip from the previous                                 works so we need to rebase after basic                                 preparations but we have a firm base                                 line of the older brother of PPC                                     okay a regarding net bsd we started from                                 the port for npc                                                     current                                 at that time this was five point                                        this probably wasn't a very good                                 decision because there were also more                                 similar platforms luck walnut but we                                 thought that this would be the right way                                 because earlier port for PPC                                         basing on MPC                                                          part of a concerning bootloader because                                 our port was already supplied with                                 sufficient bootloader Amy's boot so I I                                 will talk about first code that executes                                 in the colonel and this is locura                                 thought ass or in that bsd at the start                                 pot for every pattern and as i said                                 before we made us we made an assumption                                 that the boot already did basic thoughts                                 sock initialization and we have initial                                 mappings presently in the TLB so that                                 our code could be executed I might say                                 at this point that bookie platforms in                                 Boogie platforms there is no way to                                 switch off the MMU so there always has                                 to be varied translation in the TLB so                                 that we could execute the code okay so                                 start code is written in the assembly                                 language because it is capable to be                                 executed for any place apart from C code                                 and goals to achieve at that point are                                 to remap the colonel in                                 Oh space so that and situps temporary                                 stack so that we could execute C code                                 and regarding this mm you issue we had                                 to slightly Huck at this point because                                 we wanted to in order to remap the                                 colonel and we had to create and                                 temporary mapping switch to it then                                 create a final mapping for Colonel                                 switch to it and in the end we invited                                 it or other entries in gob so a                                 comparison of Lokar and star caught                                 between freebsd netbsd we hooked up to                                 the existing local s                                                    in freebsd and setup of the exception                                 factors so called ivars in freebsd also                                 i was in book processors these registers                                 contain and offsets to exception                                 handlers so this is set in the in the                                 low car and this is the mapping process                                 which i described a minute ago and this                                 stock setup and after that we were able                                 to go to the bathroom initialization in                                 seek out in that busy there is always a                                 new file for a new platform and this of                                 course gives a little bit redundancy in                                 the code because on example of the                                 bookie platforms it could be combined in                                 one file                                 and the rest was practically the same as                                 to the freebsd and except for the local                                 in that BST is generic / platform and                                 basically it creates only the temporary                                 stack okay so in the platform                                 initialization and our main goals to                                 achieve were to create mappings for the                                 stock registers the CPU initialization                                 and method buffer and console easy                                 ization and in the end virtual memory                                 subsystem bootstrap and once again in                                 freebsd we hooked up to the existing                                 mocked up for bookie we extracted the                                 common apart for the bookie and the                                 platform dependent markup and next we                                 map the source registers and at this                                 point i have to say that basically in                                 freebsd all of the platforms and by the                                 platform's have their internal memory                                 mapped registers organized in one place                                 in this single continuous trunk of the                                 memory but a PM has a couple of of                                 chunks this this area is divided into                                 few few chunks so we had to create a                                 table with with the translations and map                                 our registers according to the table and                                 we applied minor changes to newark and                                 set up the console and at this point in                                 freebsd nine                                 in three Disney nine we set up the f dt                                 framework in net bsd of course a new mac                                 that file for a new platform i was                                 created and the rest was basically the                                 same except for the feeling of the stub                                 functions for the interrupts for bookie                                 processors excuse me exception for                                 booking processors which are initialize                                 at that point and pacing god on that                                 steps okay maybe one more thing to                                 unclear and the low memory management                                 support now it's most sensible re is the                                 most sensible area of the operating                                 system all of the packs that are located                                 in the memory management are the most                                 fatal for the overall system operation                                 and then a lower level a the lowest                                 level of the freebsd sand that is this                                 virtual memory subsystem is pin up and                                 team up basically manages physical                                 address maps maintain the page tables                                 and handle my handle memory management                                 hardware and this was what this was this                                 was our point of interest and because                                 this was a real to adjust for our                                 upcoming ports so we had to implement                                 the operations on TOB this was                                 consisting of                                 creating functions for he'll be writing                                 to you'll be reading in violating                                 particular entry and flashing in sin                                 validating and inviting a particular                                 entry with a translation ID okay so                                 regarding device drivers in freebsd                                 starting from a                                                       concept has been adapted and f dt is                                 basically the hardware description for                                 embedded platforms that describes the                                 existing hardware in a unified way and                                 thanks to f dt we can use the same                                 kernel for different platforms of the                                 same family which are different in case                                 of registers or configuration or                                 peripherals amount of peripherals and so                                 on and few words about f delta f dt bus                                 and simple bus f dt bus is a glue                                 between a native freebsd new bus device                                 drivers framework and flatten device                                   device description and simple bus is a                                 main bus lying on f dt bus simple bus is                                 managing is adding children                                 the new bus framework and FDT buses                                 managing resources like interrupts and                                 and memory resources in this area we had                                 to do a little modification because as I                                 said before a simple bus assumes that                                 fdg assumes that all trips registers are                                 grouped in one place and we obtained we                                 got the DTS file which describes the                                 hardware that was actually reflecting                                 the actual kuraki baskar key and device                                 correctly in the hardware so we modified                                 a little bit fdg in order to store to                                 pass resources properly in that bsd                                 there is an outer configuration process                                 during config the table width device                                 description is created and there are two                                 possible ways to configure the device                                 direct and indirect configuration and                                 first in the first example the bus is                                 fully aware of the device in the system                                 even if the corresponding driver is not                                 present in a second example if I says to                                 probe the bus for the for the resource                                 and in that beast we had to write bus                                 drivers from scratch when on freebsd we                                 we had ready to use a DT bus and simple                                 bus okay and this is summary of that                                 what I said regarding the device drivers                                 and this is the list of devices that                                 were elaborated during our work on a                                 p.m. it is interrupt controller Gigabit                                 Ethernet along with queue manager pci                                 express us because you are i I score CG                                 pale and earthly see as it goes with                                 Inter controller and the APM                                 incorporates interp controller which is                                 compliant with open peak register                                 interface specification                                             well-known piece of hardware on freebsd                                 it there was already ready to use open                                 pic driver and machine dependent                                 interrupt management layer which was                                 located in I enter my dad and very                                 useful feature in freebsd is that                                 interrupts incoming interrupts are                                 serviced in a similar way that treats                                 our service so the full preemption of                                 the interrupts is implemented in a busy                                 there was no ready to use open pic                                 driver however there was there were a                                 public drivers but there were other                                 designed or designated for the special                                 platforms and we decided to combine the                                 generic interrupt liar for powerpc our                                 own code and I                                 authentic driver to fulfill the                                 requirement of the open qik controller                                 and unfortunately in that busy we have s                                 pls it means system purity level and                                 this gave us a little bit trouble during                                 development so a turn at controller is                                 incorporating with the qm to maximize                                 performance and and we created four                                 types of use for for the ethernet                                 controller first is receive you transmit                                 queue and these are working use and                                 completion queue and free pool of course                                 and also in data path there was a packet                                 classifier which is not currently                                 supported but it light in a way so it is                                 programmed to pass through all the                                 incoming packets and when the networks                                 that wants to transfer a packet it calls                                 the Amy if start and am I eight it's a                                 shortcut for applied micro telnet just                                 to be clear and it starts sending                                 packets so in that moment qm is and is                                 taking the messages from the processor                                 and feeling the call box for for the                                 compassion queue and the message is sent                                 to the controller and after that the                                 callback handlers are executed and                                 package this package is being sent and                                 the processor is in front back that the                                 compassion about the completion of the                                 task and regarding receiving messages                                 receiving packets when a packet is is is                                 being received by the controller and the                                 handler receive under is called and so                                 that message to the processor is sent                                 and the data could be acquired from the                                 buffer of course in order to improve our                                 development we implemented extended                                 debugging features connected to the a                                 building kernel debugger so it is fully                                 supported ok testing and debugging part                                 from track the buggers and integrated                                 the buggers in the chip it is convenient                                 that kernel has his own facilities and                                 these are going to be presented now and                                 this will be the testing framers and                                 kernel debugging features okay so both                                 freebsd netbsd incorporates they in                                 kernel debugger this can be enabled                                 easily from the colonel configuration                                 file by adding two options k DB and DD b                                 and this needs basic console insulation                                 in order to communicate with the user                                 and Colonel try tracing facility eight                                 here is a freebsd feature and can be                                 added by adding an option click here to                                 the collector no configuration file and                                 this basically locks Colonel actions                                 while turning is working and this could                                 be according to configuration either                                 printed to the screen or stored in the                                 memory and read after the problem occurs                                 and that bsd is quipped in automated                                 testing framework and it is located in                                 the user / test running is very simple                                 as it can could be seen but in that case                                 we have to have working system and it                                 basically is good for finding and issues                                 that are not visible at first sight so                                 this this kind of testing framework is                                 included to the net busy and our current                                 state is that we support full core                                 complex of the PPC                                                      were described before and                                 special features of the trip which is                                 support for data passing architecture                                 and it would be nice if we support SNP                                 because there are two processors in the                                 package SATA advocate and let's extend                                 our utilization of the qm because not                                 only ethernet controller can always able                                 to use that facility and of course                                 cryptographic engines power management                                 support which is the main which is the                                 main feature or one of the most                                 appreciated features of the APM                                        processor I would like to thank some                                 people at that point rafa velocity and                                 pant waseca mentors of this project and                                 all the people who committed their work                                 for the project and these are dragger                                 Bernard King hamaso Martin ropa Booker's                                 wig and cabbage a chick this is all semi                                 health group so this would be all for me                                 are there any questions                                 if not then thank you yeah                                 I would rather not answer this question                                 if personally it was easier for me to                                 work with freebsd than with net bsd                                 according to the Power PC platforms yeah                                 okay yeah Mike's I have a short question                                 you talked about some queue management                                 system implemented in hardware which                                 free POS can use this system currently                                 you talked about Ethernet can use it or                                 are more free periods using it ethernet                                 controller is using it and other other                                 peripherals are can also incorporate                                 these features for instance USB i                                 believe and crypto yes                                 yes one more time because I can hear you                                 I'm sorry and it's your parting work                                 shared back into the trees very busy in                                 nappies d we are going to integrate this                                 to the freebsd main line but currently                                 there are no plans to integrate to the                                 net BST yeah he was a fellow dirtiest                                 how much more work to integrate the                                 cryptographic celery and i believe i                                 can't answer the discussion because I                                 simply don't know but if you are very                                 curious about this please leave me some                                 contacts and we will answer a few days                                 ok so i think that's all thank you very                                 much for attention
YouTube URL: https://www.youtube.com/watch?v=RlowLXP0Cro


