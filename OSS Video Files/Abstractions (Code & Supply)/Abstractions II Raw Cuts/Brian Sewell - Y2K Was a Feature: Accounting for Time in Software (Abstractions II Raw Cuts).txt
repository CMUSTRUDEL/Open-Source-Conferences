Title: Brian Sewell - Y2K Was a Feature: Accounting for Time in Software (Abstractions II Raw Cuts)
Publication date: 2019-11-25
Playlist: Abstractions II Raw Cuts
Description: 
	Presented at Abstractions II, a software conference Code & Supply in Pittsburgh, PA August 21-23, 2019. Learn more at http://www.codeandsupply.co or https://abstractions.io. 

The RAW CUTS series is comprised of selections from a few of our stages wherein the raw video was of high enough quality for C&S to release it before post-production. 

Post-production for a community-run conference with as many speakers and as low of a budget as Abstractions is an enormous and time-consuming undertaking. If you're interested in volunteering your time and CPU cycles to help with post-production, we can use your help. Email us at support@codeandsupply.co and we'll get you into the mix. You'll be permitted to credit yourself in the video pre-roll and credits and we'll thank you in this text and on social media.

Interested in sponsoring professional post-production costs in exchange for your company's name and logo in the video forevermore? Contact us at sponsorship@abstractions.io. Opportunities start at $1,000.

-----

Time is a complex mechanism in programming. Whether you are building a calendar app or a chatbot, time will likely play an important role in your software.

Popular bugs like Y2K have brought a lot of attention to how easily software can overlook such a vital part of everyday life. These bugs may be fun anecdotes, but they illustrate how difficult it can be to successfully account for every edge case time presents. Why is time so hard to deal with? It goes much further than time zones, daylight savings, and leap years.

As product designers and developers, it is essential that we better understand the gap between user expectations and the realities of how time operates.

We’ll chronicle some time-related programming bugs and what we can learn from them (and laugh at ourselves a little). We’ll also cover how different languages handle time and some best practices for storing, retrieving, and presenting time. Lastly we’ll dive into the special cases to be aware of as we design and build our software.

https://abstractions.io/schedule/#Y2K%20Was%20a%20Feature:%20Accounting%20for%20Time%20in%20Software-Brian%20Sewell
Captions: 
	00:00:00,030 --> 00:00:05,130
alright hello everybody welcome to y2k

00:00:03,360 --> 00:00:07,680
was a feature accounting for time and

00:00:05,130 --> 00:00:10,139
software my name is Brian Sewell I am

00:00:07,680 --> 00:00:12,330
from Durham North Carolina if you need

00:00:10,139 --> 00:00:14,250
to reach me my email is up there I will

00:00:12,330 --> 00:00:17,160
post it again at the end of the talk I

00:00:14,250 --> 00:00:18,390
am a engineer a tad works in Durham I've

00:00:17,160 --> 00:00:21,270
been there for almost three years now

00:00:18,390 --> 00:00:22,590
and if you are interested in learning a

00:00:21,270 --> 00:00:25,109
little bit more about what we do we are

00:00:22,590 --> 00:00:28,590
hiring so catch me in the hallway after

00:00:25,109 --> 00:00:31,679
the talk so when I was researching

00:00:28,590 --> 00:00:33,840
topics for this there were a handful of

00:00:31,679 --> 00:00:35,730
routes I could have gone but I wanted to

00:00:33,840 --> 00:00:37,680
focus on some of the bugs that we've run

00:00:35,730 --> 00:00:39,600
into when dealing with time and software

00:00:37,680 --> 00:00:42,180
because they're the ones that seem to

00:00:39,600 --> 00:00:44,760
bite us the most and when I was doing my

00:00:42,180 --> 00:00:46,890
research came across this super helpful

00:00:44,760 --> 00:00:49,980
Wikipedia page that listed every single

00:00:46,890 --> 00:00:51,629
time related programming bug at least to

00:00:49,980 --> 00:00:54,930
most people's knowledge and I came

00:00:51,629 --> 00:00:59,399
across y2k so here who here knows what

00:00:54,930 --> 00:01:02,969
y2k is ok great who here was alive

00:00:59,399 --> 00:01:05,790
during y2k ok I have to ask

00:01:02,969 --> 00:01:09,450
alright cool I'm assuming 99% of you

00:01:05,790 --> 00:01:10,710
were born before 2000 all right so for

00:01:09,450 --> 00:01:14,220
those who are unfamiliar with what what

00:01:10,710 --> 00:01:16,439
2k y2k is it referred to the issue where

00:01:14,220 --> 00:01:18,750
we were storing years as two digits

00:01:16,439 --> 00:01:21,570
instead of four and the consequences of

00:01:18,750 --> 00:01:23,009
that when we would hit the year 2000 it

00:01:21,570 --> 00:01:26,180
was called a millennium bug the year

00:01:23,009 --> 00:01:28,110
2000 problem or y2k for short and

00:01:26,180 --> 00:01:29,850
businesses and governments all around

00:01:28,110 --> 00:01:32,610
the world were funneling billions of

00:01:29,850 --> 00:01:35,490
dollars into trying to replace hardware

00:01:32,610 --> 00:01:37,530
and patch software anything that could

00:01:35,490 --> 00:01:39,420
have been affected by y2k or anything

00:01:37,530 --> 00:01:41,820
that people could convince them that was

00:01:39,420 --> 00:01:43,649
would be affected by y2k there'd be

00:01:41,820 --> 00:01:47,640
toasters that would have y2k compliance

00:01:43,649 --> 00:01:50,009
stickers on them so even though y2k was

00:01:47,640 --> 00:01:53,009
the perfect anecdote for a talk about

00:01:50,009 --> 00:01:55,740
time and programming my first thought

00:01:53,009 --> 00:01:57,689
was honestly what a perfect buzzword to

00:01:55,740 --> 00:02:00,000
put in the title to get people to come

00:01:57,689 --> 00:02:01,049
and look at mine and watch my talk so

00:02:00,000 --> 00:02:02,450
thanks for taking the bait I really

00:02:01,049 --> 00:02:04,979
appreciate it

00:02:02,450 --> 00:02:07,350
so despite y2k almost always been

00:02:04,979 --> 00:02:09,660
referred to as a bug I would argue that

00:02:07,350 --> 00:02:11,459
it wasn't a bug at all and it was more

00:02:09,660 --> 00:02:13,319
of a design compromise right the

00:02:11,459 --> 00:02:13,710
compromise was to store years as two

00:02:13,319 --> 00:02:16,740
digits

00:02:13,710 --> 00:02:18,240
for to save space you know space was

00:02:16,740 --> 00:02:20,070
limited and expensive early on in

00:02:18,240 --> 00:02:23,790
computing and this just sort of became

00:02:20,070 --> 00:02:26,010
the norm for how we stored years and it

00:02:23,790 --> 00:02:28,050
stayed the norm for a very long time all

00:02:26,010 --> 00:02:30,540
the way up until about 2000 no one could

00:02:28,050 --> 00:02:32,220
have really predicted that all the

00:02:30,540 --> 00:02:34,650
systems that were storing things as two

00:02:32,220 --> 00:02:37,890
digits for their year would still be in

00:02:34,650 --> 00:02:40,080
use by that time so y2k was just one of

00:02:37,890 --> 00:02:41,550
these examples of a design compromise

00:02:40,080 --> 00:02:44,580
that we are constantly making in

00:02:41,550 --> 00:02:47,340
software how many times do we design a

00:02:44,580 --> 00:02:50,040
like a temporary solution that we know

00:02:47,340 --> 00:02:51,600
is not bulletproof but it will last long

00:02:50,040 --> 00:02:53,640
enough and we'll just fix it later right

00:02:51,600 --> 00:02:56,250
and we just assume that we are going to

00:02:53,640 --> 00:02:58,260
fix it ourselves or somebody else will

00:02:56,250 --> 00:03:02,540
we'll deal with the problems that we put

00:02:58,260 --> 00:03:04,770
in there so y2k was sort of this

00:03:02,540 --> 00:03:07,560
accumulation of technical debt that

00:03:04,770 --> 00:03:09,450
snowball at the end of the 90s and as

00:03:07,560 --> 00:03:12,450
much as I would love to talk about y2k

00:03:09,450 --> 00:03:15,390
in more depth we're gonna talk about how

00:03:12,450 --> 00:03:18,810
to avoid problems like y2k specifically

00:03:15,390 --> 00:03:21,240
storing time parsing time and presenting

00:03:18,810 --> 00:03:24,030
time now there's a whole lot to unpack

00:03:21,240 --> 00:03:25,920
here so I'm gonna stick to some of the

00:03:24,030 --> 00:03:28,590
the basics or at least some of the most

00:03:25,920 --> 00:03:31,670
relevant topics like time zones daylight

00:03:28,590 --> 00:03:36,150
saving time UTC leap years and

00:03:31,670 --> 00:03:39,210
formatting so we'll start with this

00:03:36,150 --> 00:03:40,770
question how does time affect you more

00:03:39,210 --> 00:03:43,710
specifically how does it affect your app

00:03:40,770 --> 00:03:45,750
or business not every app or business

00:03:43,710 --> 00:03:47,790
revolves around a key component of time

00:03:45,750 --> 00:03:50,340
but almost everyone is going to be

00:03:47,790 --> 00:03:52,230
affected by in some way so maybe you

00:03:50,340 --> 00:03:54,990
send out marketing emails on a schedule

00:03:52,230 --> 00:03:56,910
or maybe you have scheduled jobs or

00:03:54,990 --> 00:03:59,370
maybe you're ingesting a third party API

00:03:56,910 --> 00:04:01,830
and you're storing timestamps from that

00:03:59,370 --> 00:04:03,690
API in your database or maybe you have

00:04:01,830 --> 00:04:05,400
your own API where you're transiting

00:04:03,690 --> 00:04:09,150
dates and times from your database for

00:04:05,400 --> 00:04:10,950
other people to ingest or maybe your

00:04:09,150 --> 00:04:13,170
business does have a key component of

00:04:10,950 --> 00:04:15,420
time maybe you facilitate online auction

00:04:13,170 --> 00:04:18,180
it's like eBay or you've got a fantasy

00:04:15,420 --> 00:04:19,620
football app with live online drafts or

00:04:18,180 --> 00:04:21,030
maybe you're an airline that has to let

00:04:19,620 --> 00:04:25,230
your customers check into your flight

00:04:21,030 --> 00:04:26,340
know sooner than 24 hours or maybe

00:04:25,230 --> 00:04:27,360
you're at facilitate some sort of

00:04:26,340 --> 00:04:31,919
scheduling like

00:04:27,360 --> 00:04:34,020
a calendar or HR software so let's start

00:04:31,919 --> 00:04:37,949
with this first aspect which is storing

00:04:34,020 --> 00:04:39,629
time and it's the beefiest one so aside

00:04:37,949 --> 00:04:41,969
from not storing years is two digits

00:04:39,629 --> 00:04:43,889
what are some best practices that we can

00:04:41,969 --> 00:04:45,719
follow of course this depends if you're

00:04:43,889 --> 00:04:48,120
storing a date or a time stamp or a

00:04:45,719 --> 00:04:50,250
duration but there are some standard

00:04:48,120 --> 00:04:52,939
formats that we can lean on and the most

00:04:50,250 --> 00:04:55,020
common one that you'll see is ISO 8601

00:04:52,939 --> 00:04:57,569
with this was a standard that was

00:04:55,020 --> 00:05:00,449
adopted in 1988 to help prevent

00:04:57,569 --> 00:05:02,969
ambiguous time stamps or at least date

00:05:00,449 --> 00:05:08,069
formats and it defines these acceptable

00:05:02,969 --> 00:05:10,379
ways to to display dates and times so an

00:05:08,069 --> 00:05:11,879
ISO 8601 formatted time stamp would look

00:05:10,379 --> 00:05:14,129
like this

00:05:11,879 --> 00:05:16,199
you've got the very first part which is

00:05:14,129 --> 00:05:18,030
the year the second part is the month

00:05:16,199 --> 00:05:20,430
the last part where the third part is

00:05:18,030 --> 00:05:22,979
the day then you have this T delimiter

00:05:20,430 --> 00:05:26,159
in between the date and the time the

00:05:22,979 --> 00:05:27,150
time is in a 24-hour format so 15 is 3

00:05:26,159 --> 00:05:28,860
p.m.

00:05:27,150 --> 00:05:29,789
you've got your minutes your seconds and

00:05:28,860 --> 00:05:33,840
then the last little bit is this

00:05:29,789 --> 00:05:36,120
timezone offset there are a few other

00:05:33,840 --> 00:05:38,039
formats that you'll see and they're used

00:05:36,120 --> 00:05:42,539
for specific use cases

00:05:38,039 --> 00:05:45,960
RFC 3 3 3 9 is a stricter version of ISO

00:05:42,539 --> 00:05:48,330
8601 it basically says you can't leave

00:05:45,960 --> 00:05:49,229
anything out you have to include time in

00:05:48,330 --> 00:05:51,270
your time stamp

00:05:49,229 --> 00:05:54,029
you can't just represent the date and

00:05:51,270 --> 00:05:56,009
you can't convert it to midnight I think

00:05:54,029 --> 00:05:57,839
the only optional thing you can add here

00:05:56,009 --> 00:05:59,969
are like milliseconds or fractional

00:05:57,839 --> 00:06:03,599
seconds

00:05:59,969 --> 00:06:06,000
RFC - 8 - 2 defines the dates so the way

00:06:03,599 --> 00:06:09,120
dates and time should look like an email

00:06:06,000 --> 00:06:13,710
headers so once again the most common

00:06:09,120 --> 00:06:16,770
one you'll pricee is iso 8601 so let's

00:06:13,710 --> 00:06:19,789
talk about time zones because I know

00:06:16,770 --> 00:06:22,650
you're all really excited about it

00:06:19,789 --> 00:06:25,589
these can be extremely tricky and

00:06:22,650 --> 00:06:27,029
probably are the most common cause for

00:06:25,589 --> 00:06:29,310
some of the issues that we run into when

00:06:27,029 --> 00:06:32,190
dealing with time but before we get into

00:06:29,310 --> 00:06:35,159
exactly why or how we should store time

00:06:32,190 --> 00:06:38,060
zones let's talk about why time zones

00:06:35,159 --> 00:06:40,460
exist and like how they came about

00:06:38,060 --> 00:06:42,380
so before time zones existed we

00:06:40,460 --> 00:06:44,450
basically told time by where the Sun was

00:06:42,380 --> 00:06:47,570
and this wasn't that long ago it's only

00:06:44,450 --> 00:06:49,340
like 135 years ago there could be a

00:06:47,570 --> 00:06:52,460
10-minute difference between cities that

00:06:49,340 --> 00:06:53,750
were not even 100 miles apart and this

00:06:52,460 --> 00:06:56,930
was just because that was the standard

00:06:53,750 --> 00:06:59,410
and it caused a lot of confusion this is

00:06:56,930 --> 00:07:04,010
a timetable that was published in 1857

00:06:59,410 --> 00:07:05,510
listing all about a hundred important US

00:07:04,010 --> 00:07:08,360
cities that people would normally travel

00:07:05,510 --> 00:07:10,640
to by by rail and what the time was

00:07:08,360 --> 00:07:14,240
relative to when it was noon in

00:07:10,640 --> 00:07:15,950
Washington DC and railroad passengers

00:07:14,240 --> 00:07:17,570
would have to use these timetables to

00:07:15,950 --> 00:07:19,390
adjust their clocks and watches whenever

00:07:17,570 --> 00:07:22,040
they would get to their destination

00:07:19,390 --> 00:07:24,380
however each railroad company used a

00:07:22,040 --> 00:07:26,960
different standard for telling time as

00:07:24,380 --> 00:07:29,540
well and they would post their schedules

00:07:26,960 --> 00:07:31,460
using their standard so the more rail

00:07:29,540 --> 00:07:34,400
companies that did this the more

00:07:31,460 --> 00:07:36,770
confusion there was in fact it led to a

00:07:34,400 --> 00:07:38,270
couple of collisions where the train

00:07:36,770 --> 00:07:40,370
guards on different trains had

00:07:38,270 --> 00:07:42,350
completely different time even if it was

00:07:40,370 --> 00:07:43,580
ten minutes off they had no idea there

00:07:42,350 --> 00:07:46,190
was another train on that track and it

00:07:43,580 --> 00:07:47,780
led to fatalities so this became a

00:07:46,190 --> 00:07:51,550
bigger problem as more people traveled

00:07:47,780 --> 00:07:53,540
by rail so in October of 1883 the

00:07:51,550 --> 00:07:56,270
railroad companies in the United States

00:07:53,540 --> 00:07:57,830
and Canada held a convention in Chicago

00:07:56,270 --> 00:07:59,360
and said we've got to fix this problem

00:07:57,830 --> 00:08:02,270
we need to get everybody on this

00:07:59,360 --> 00:08:04,970
standard way of telling time and so they

00:08:02,270 --> 00:08:07,400
agreed that at the end of it we would we

00:08:04,970 --> 00:08:10,340
would have these four five ish major

00:08:07,400 --> 00:08:12,820
time zones in North America and this is

00:08:10,340 --> 00:08:15,710
kind of where time zones were born ish

00:08:12,820 --> 00:08:17,840
after that we saw a large adoption all

00:08:15,710 --> 00:08:21,320
over the world a lot of a lot more time

00:08:17,840 --> 00:08:24,669
zones started showing up but today we

00:08:21,320 --> 00:08:26,360
have 39 time zones which doesn't seem

00:08:24,669 --> 00:08:28,700
super normal

00:08:26,360 --> 00:08:31,250
since there's 24 hours in a day but

00:08:28,700 --> 00:08:33,260
we'll get to some of the weird ones

00:08:31,250 --> 00:08:35,719
so like Australia is kind of odd they

00:08:33,260 --> 00:08:37,460
have four time zones one is off by 30

00:08:35,719 --> 00:08:39,860
minutes and the fourth one is way too

00:08:37,460 --> 00:08:43,550
small to highlight here but it's off by

00:08:39,860 --> 00:08:44,900
45 minutes instead of 30 Russia has gone

00:08:43,550 --> 00:08:47,720
through a whole lot of time zone changes

00:08:44,900 --> 00:08:50,500
in the last ten years and from 2004 to

00:08:47,720 --> 00:08:52,480
2010 they had 11 time zones

00:08:50,500 --> 00:08:56,110
and then they reduced it to nine and

00:08:52,480 --> 00:08:58,720
then in 2011 all of them shifted forward

00:08:56,110 --> 00:09:01,360
an hour and then in 2014 they all

00:08:58,720 --> 00:09:04,810
shifted back an hour and added two more

00:09:01,360 --> 00:09:06,700
time zones again and then the most

00:09:04,810 --> 00:09:08,350
recent change in 2016 just a couple

00:09:06,700 --> 00:09:10,420
parts of the country shifted forward an

00:09:08,350 --> 00:09:13,840
hour again so this is where we are in

00:09:10,420 --> 00:09:15,400
Russia today so China they used to be

00:09:13,840 --> 00:09:18,730
split into five time zones but they only

00:09:15,400 --> 00:09:20,170
have one now so over summer there are

00:09:18,730 --> 00:09:22,720
parts of western China that don't see

00:09:20,170 --> 00:09:24,910
the sunset until after midnight but this

00:09:22,720 --> 00:09:26,320
isn't a huge deal because like 95% of

00:09:24,910 --> 00:09:29,530
their population lives in the eastern

00:09:26,320 --> 00:09:31,120
half of the country there have been

00:09:29,530 --> 00:09:33,040
numerous instances where countries have

00:09:31,120 --> 00:09:35,440
moved from one side of the International

00:09:33,040 --> 00:09:37,930
Dateline to the other so they either

00:09:35,440 --> 00:09:41,410
skip over a day or relive the same day

00:09:37,930 --> 00:09:42,940
twice they did this to align with their

00:09:41,410 --> 00:09:44,440
trading partners because there was a

00:09:42,940 --> 00:09:47,080
potential of them missing out on an

00:09:44,440 --> 00:09:50,710
entire workday so it was an economic and

00:09:47,080 --> 00:09:52,870
political issue in the u.s. we don't

00:09:50,710 --> 00:09:55,450
have time zones that match our state

00:09:52,870 --> 00:09:57,700
geographical borders perfectly we have

00:09:55,450 --> 00:10:01,180
fourteen states that are split between

00:09:57,700 --> 00:10:02,950
two time zones okay so this seems like a

00:10:01,180 --> 00:10:04,600
whole lot of edge cases to keep track of

00:10:02,950 --> 00:10:06,700
look how do we do this

00:10:04,600 --> 00:10:08,590
luckily there's this thing called the TZ

00:10:06,700 --> 00:10:10,030
database and it keeps track of all this

00:10:08,590 --> 00:10:12,220
historical information so that we don't

00:10:10,030 --> 00:10:13,810
have to worry about it and it gets

00:10:12,220 --> 00:10:15,370
updated periodically in fact I think it

00:10:13,810 --> 00:10:17,770
was updated in July the very beginning

00:10:15,370 --> 00:10:20,080
of July this typically lives on your

00:10:17,770 --> 00:10:24,100
machine to interact with libraries and

00:10:20,080 --> 00:10:27,280
other languages so how should we store a

00:10:24,100 --> 00:10:29,650
time zone what's the proper way to get

00:10:27,280 --> 00:10:32,740
this into our database let's say we

00:10:29,650 --> 00:10:34,690
wanted to store a user's preference for

00:10:32,740 --> 00:10:37,650
their time zone what's the best way to

00:10:34,690 --> 00:10:39,730
do this so some languages and frameworks

00:10:37,650 --> 00:10:41,140
have defined their own like friendly

00:10:39,730 --> 00:10:43,450
names for these time zones and you'll

00:10:41,140 --> 00:10:45,310
see these a lot like Eastern Time

00:10:43,450 --> 00:10:46,960
these are usually meant for displaying

00:10:45,310 --> 00:10:49,720
purposes they're not really meant for

00:10:46,960 --> 00:10:51,850
storage each time zone also has an

00:10:49,720 --> 00:10:55,480
abbreviation est for Eastern Standard

00:10:51,850 --> 00:10:57,330
Time they will also have an offset and

00:10:55,480 --> 00:11:00,330
this is defined as the number of hours

00:10:57,330 --> 00:11:03,220
ahead or behind of Greenwich Mean Time

00:11:00,330 --> 00:11:03,550
and then there's the identifier the

00:11:03,220 --> 00:11:06,519
Kanaan

00:11:03,550 --> 00:11:08,709
name that is in the TZ database so which

00:11:06,519 --> 00:11:11,080
of these should we use which which one

00:11:08,709 --> 00:11:13,029
should we store in our database well

00:11:11,080 --> 00:11:14,589
once again the the first one is usually

00:11:13,029 --> 00:11:16,330
pretty specific to the language or

00:11:14,589 --> 00:11:18,010
framework you're using so because it's

00:11:16,330 --> 00:11:22,060
not a standard we probably want to avoid

00:11:18,010 --> 00:11:23,800
this the abbreviations aren't always the

00:11:22,060 --> 00:11:25,120
same for the same timezone either

00:11:23,800 --> 00:11:27,730
they'll change and we'll get into that

00:11:25,120 --> 00:11:29,410
in a bit and the offsets could be

00:11:27,730 --> 00:11:31,839
ambiguous numerous time zones could have

00:11:29,410 --> 00:11:34,450
the same offset so that leaves us with

00:11:31,839 --> 00:11:36,310
the TZ database name this is probably

00:11:34,450 --> 00:11:38,920
your best bet for if you needed to store

00:11:36,310 --> 00:11:40,209
a time zone it's unambiguous and it is a

00:11:38,920 --> 00:11:44,079
standard used in almost every

00:11:40,209 --> 00:11:47,500
programming language so back to that

00:11:44,079 --> 00:11:49,480
abbreviation est it seems like a very

00:11:47,500 --> 00:11:51,160
attractive option right developers are

00:11:49,480 --> 00:11:54,399
like oh my god an abbreviation it seems

00:11:51,160 --> 00:11:56,110
so simple but these will actually change

00:11:54,399 --> 00:11:56,860
so est once again stands for Eastern

00:11:56,110 --> 00:11:58,779
Standard Time

00:11:56,860 --> 00:12:00,519
but it's only a time zone for four

00:11:58,779 --> 00:12:02,769
months out of the year the other eight

00:12:00,519 --> 00:12:04,240
months its Eastern Daylight Time and

00:12:02,769 --> 00:12:05,980
that's because of this wonderful thing

00:12:04,240 --> 00:12:08,860
called daylight saving time

00:12:05,980 --> 00:12:10,540
so other than messing up your sleep

00:12:08,860 --> 00:12:14,140
schedule or making you hungry an hour

00:12:10,540 --> 00:12:16,029
early before lunch in the fall daylight

00:12:14,140 --> 00:12:17,230
saving time can really wreak havoc in

00:12:16,029 --> 00:12:20,410
your app if you're not accounting for it

00:12:17,230 --> 00:12:22,600
properly so the first thing to note is

00:12:20,410 --> 00:12:25,029
not everyone observes daylight saving

00:12:22,600 --> 00:12:26,800
time in fact I think the majority of the

00:12:25,029 --> 00:12:28,959
population of the world doesn't observe

00:12:26,800 --> 00:12:30,220
daylight saving time remember how

00:12:28,959 --> 00:12:34,720
Australia had those weird time zones

00:12:30,220 --> 00:12:36,130
well only parts of the country observe

00:12:34,720 --> 00:12:38,339
daylight saving time so you get more

00:12:36,130 --> 00:12:40,750
time zones during only part of the year

00:12:38,339 --> 00:12:42,250
the United States Arizona doesn't

00:12:40,750 --> 00:12:45,279
observe daylight saving time except for

00:12:42,250 --> 00:12:46,779
the Navajo Nation Hawaii has never

00:12:45,279 --> 00:12:50,949
observe daylight saving time because

00:12:46,779 --> 00:12:52,420
they don't really need to they're

00:12:50,949 --> 00:12:53,949
actually handful of states that have

00:12:52,420 --> 00:12:55,630
passed bills are currently trying to

00:12:53,949 --> 00:12:57,399
pass bills to permanently observe

00:12:55,630 --> 00:13:01,199
daylight saving time so when that

00:12:57,399 --> 00:13:01,199
happens buckle up

00:13:02,310 --> 00:13:06,970
so not everyone who does observe

00:13:04,660 --> 00:13:09,250
daylight saving time starts and ends at

00:13:06,970 --> 00:13:10,990
the same time each year either this

00:13:09,250 --> 00:13:13,180
varies by country as well in the United

00:13:10,990 --> 00:13:15,880
States we start on the second Sunday of

00:13:13,180 --> 00:13:19,570
March and we end in the last Sunday of

00:13:15,880 --> 00:13:21,970
November and in the UK they start on the

00:13:19,570 --> 00:13:24,760
last Sunday of March and end on the last

00:13:21,970 --> 00:13:26,529
Sunday in October because Australia is

00:13:24,760 --> 00:13:28,839
in the southern hemisphere they start

00:13:26,529 --> 00:13:31,480
daylight saving time in October and end

00:13:28,839 --> 00:13:33,310
in April and even the hour the

00:13:31,480 --> 00:13:35,279
changeover happens is different by

00:13:33,310 --> 00:13:37,600
country so in the United States when we

00:13:35,279 --> 00:13:39,730
start daylight savings time we're losing

00:13:37,600 --> 00:13:41,620
an hour right and so we are skipping

00:13:39,730 --> 00:13:44,560
over an hour completely that happens at

00:13:41,620 --> 00:13:46,899
2:00 a.m. here so we go from 159 Eastern

00:13:44,560 --> 00:13:47,890
Standard Time straight over to 3 a.m.

00:13:46,899 --> 00:13:49,870
Eastern Daylight Time

00:13:47,890 --> 00:13:53,800
2:00 a.m. Eastern Standard Time does not

00:13:49,870 --> 00:13:56,500
exist in the UK this happens at 1 a.m.

00:13:53,800 --> 00:13:58,959
instead of 2 a.m. they go from 1259

00:13:56,500 --> 00:14:01,540
Greenwich Mean Time to 2 a.m. British

00:13:58,959 --> 00:14:04,959
summer time when daylight saving time

00:14:01,540 --> 00:14:07,270
ends both UK and the United States do

00:14:04,959 --> 00:14:10,120
this at 2:00 a.m. so they relive 1 a.m.

00:14:07,270 --> 00:14:12,339
twice so there's plenty of edge cases

00:14:10,120 --> 00:14:14,230
that we have to deal with in daylight

00:14:12,339 --> 00:14:17,470
saving time and luckily it's all in the

00:14:14,230 --> 00:14:19,060
TZ database all the historical changes

00:14:17,470 --> 00:14:21,160
and all the current up-to-date

00:14:19,060 --> 00:14:24,160
information it lives there and it once

00:14:21,160 --> 00:14:26,350
again gets updated periodically so why

00:14:24,160 --> 00:14:28,660
do we care even with the help of the TZ

00:14:26,350 --> 00:14:30,459
database time zones in daylight saving

00:14:28,660 --> 00:14:33,250
time is an added complexity that we need

00:14:30,459 --> 00:14:34,959
to be aware of if you have emails or

00:14:33,250 --> 00:14:36,760
text messages that you're sending to

00:14:34,959 --> 00:14:38,470
your customers maybe I'd like the close

00:14:36,760 --> 00:14:40,390
of business each day are you sending

00:14:38,470 --> 00:14:42,520
those in their time zone or in your time

00:14:40,390 --> 00:14:43,959
zone because if you are on the East

00:14:42,520 --> 00:14:45,270
Coast and you want to send somebody an

00:14:43,959 --> 00:14:46,950
email at 8 a.m.

00:14:45,270 --> 00:14:49,640
everyone on the west coast is going to

00:14:46,950 --> 00:14:52,080
get it at 5 a.m. same for scheduled jobs

00:14:49,640 --> 00:14:53,339
if you are calculating durations

00:14:52,080 --> 00:14:55,440
anywhere like doing some manual date

00:14:53,339 --> 00:14:57,870
math first of all that's terrifying

00:14:55,440 --> 00:14:59,339
second of all you might have to account

00:14:57,870 --> 00:15:01,350
for the daylight saving time changeover

00:14:59,339 --> 00:15:03,660
it might mess up your durations imagine

00:15:01,350 --> 00:15:05,370
if somebody was using RunKeeper and they

00:15:03,660 --> 00:15:07,140
decided to go for a run during one of

00:15:05,370 --> 00:15:08,580
these change overs and then they open

00:15:07,140 --> 00:15:09,959
their app and it said that they ran for

00:15:08,580 --> 00:15:11,480
negative 40 minutes or something like

00:15:09,959 --> 00:15:13,770
that

00:15:11,480 --> 00:15:16,890
all right so let's go back to this time

00:15:13,770 --> 00:15:19,170
stamp this is that this negative oh four

00:15:16,890 --> 00:15:22,410
zero zero bit it represents the time

00:15:19,170 --> 00:15:24,600
zone but what is it relative to so time

00:15:22,410 --> 00:15:27,660
zone offsets are defined relative to UTC

00:15:24,600 --> 00:15:30,750
and UTC stands for coordinated Universal

00:15:27,660 --> 00:15:31,709
Time it was formally adopted in 1972 and

00:15:30,750 --> 00:15:34,170
if you're wondering what's up with that

00:15:31,709 --> 00:15:36,750
acronym that's because the French

00:15:34,170 --> 00:15:38,910
abbreviation was tu C for their

00:15:36,750 --> 00:15:42,450
translation and the english-speaking

00:15:38,910 --> 00:15:44,370
countries still used Cu T and so they

00:15:42,450 --> 00:15:52,940
just picked UTC because it was the same

00:15:44,370 --> 00:15:55,649
in every language it gets worse

00:15:52,940 --> 00:15:57,540
so UTC is a standard to help regulate

00:15:55,649 --> 00:16:00,600
clocks around the world and we define

00:15:57,540 --> 00:16:02,279
time zone offsets relative to UTC so if

00:16:00,600 --> 00:16:04,740
we put all the time zones on a number

00:16:02,279 --> 00:16:07,680
line zero would be kind of in the middle

00:16:04,740 --> 00:16:10,680
so during standard time the eastern time

00:16:07,680 --> 00:16:13,589
zone in the US is five hours behind so -

00:16:10,680 --> 00:16:17,399
oh five zero zero and China is eight

00:16:13,589 --> 00:16:19,350
hours ahead of UTC so plus Oh 800 but

00:16:17,399 --> 00:16:21,390
during daylight saving time Eastern

00:16:19,350 --> 00:16:23,550
times just forward an hour so now the

00:16:21,390 --> 00:16:24,720
offset is - oh four two zero zero and

00:16:23,550 --> 00:16:25,980
the Train is offset remains the same

00:16:24,720 --> 00:16:28,200
because they don't observe daylight

00:16:25,980 --> 00:16:30,180
saving time but you can see the this is

00:16:28,200 --> 00:16:32,160
how those offsets are ambiguous negative

00:16:30,180 --> 00:16:34,279
Oh 400 doesn't always mean Eastern

00:16:32,160 --> 00:16:37,050
Standard Time or Eastern Daylight Time

00:16:34,279 --> 00:16:40,050
so to keep things simple if you are

00:16:37,050 --> 00:16:42,660
storing a timestamp in your database you

00:16:40,050 --> 00:16:43,829
should probably use UTC you'll save

00:16:42,660 --> 00:16:46,320
yourself some headaches down the road

00:16:43,829 --> 00:16:48,959
and you can convert it to whatever time

00:16:46,320 --> 00:16:52,980
zone you need upon retrieval but store

00:16:48,959 --> 00:16:55,560
and UTC keeps it unambiguous and the way

00:16:52,980 --> 00:16:57,590
we do this in ISO 8601 is we replace the

00:16:55,560 --> 00:17:01,630
offset with the letter Z

00:16:57,590 --> 00:17:03,680
this represents the zero offset from UTC

00:17:01,630 --> 00:17:05,870
so there's another way to store time

00:17:03,680 --> 00:17:07,280
stamps that doesn't require us to keep

00:17:05,870 --> 00:17:09,770
track of the individual components like

00:17:07,280 --> 00:17:12,650
the month or even the time zone and

00:17:09,770 --> 00:17:14,840
that's this concept of unix time unix

00:17:12,650 --> 00:17:18,350
time is defined as the number of seconds

00:17:14,840 --> 00:17:19,700
since january 1st 1970 the unix epoch or

00:17:18,350 --> 00:17:21,530
epoch however you would like to

00:17:19,700 --> 00:17:24,350
pronounce it and it's essentially a

00:17:21,530 --> 00:17:25,880
relative point in time so a unix

00:17:24,350 --> 00:17:27,620
timestamp would look like this if we

00:17:25,880 --> 00:17:30,530
converted today's date to a unix

00:17:27,620 --> 00:17:32,860
timestamp at midnight i guess a lot of

00:17:30,530 --> 00:17:35,270
systems use these timestamps to store

00:17:32,860 --> 00:17:37,250
store store time they'll use UNIX

00:17:35,270 --> 00:17:40,910
timestamps and they do so by storing

00:17:37,250 --> 00:17:43,850
them as signed 32-bit integers you don't

00:17:40,910 --> 00:17:46,760
know a lot of binary and neither do I so

00:17:43,850 --> 00:17:48,710
I only know enough to put up up put it

00:17:46,760 --> 00:17:51,770
up on this slide so please just use the

00:17:48,710 --> 00:17:54,080
squint test here if you represent a UNIX

00:17:51,770 --> 00:17:55,460
timestamp as a sign 32-bit integer it

00:17:54,080 --> 00:17:57,410
looks like this bunch of ones and zeros

00:17:55,460 --> 00:18:00,050
right signed means that you are

00:17:57,410 --> 00:18:02,000
sacrificing a bit to represent whether

00:18:00,050 --> 00:18:04,460
or not it is positive or negative this

00:18:02,000 --> 00:18:07,190
first bit is used to encode that so 0

00:18:04,460 --> 00:18:09,200
means positive 1 means negative the

00:18:07,190 --> 00:18:11,600
maximum positive integer that we can

00:18:09,200 --> 00:18:13,880
represent as a 32-bit signed integer

00:18:11,600 --> 00:18:15,710
looks like this all ones except for that

00:18:13,880 --> 00:18:19,640
first one means that means it's positive

00:18:15,710 --> 00:18:22,610
so if this was unix time what date would

00:18:19,640 --> 00:18:24,710
it represent so you'll get January

00:18:22,610 --> 00:18:27,620
nineteen twenty thirty eight about 3:00

00:18:24,710 --> 00:18:32,120
a.m. UTC that's what happens when we

00:18:27,620 --> 00:18:34,010
pass this date and time so depending on

00:18:32,120 --> 00:18:35,360
the system the conversion at day time

00:18:34,010 --> 00:18:39,410
might just stay the same might think

00:18:35,360 --> 00:18:41,090
it's that date forever or it could roll

00:18:39,410 --> 00:18:43,400
over and think it's 1901 and start

00:18:41,090 --> 00:18:47,090
counting up from there which could be a

00:18:43,400 --> 00:18:50,150
problem either way this is known as the

00:18:47,090 --> 00:18:54,230
2038 problem and it's being sold as the

00:18:50,150 --> 00:18:56,870
next y2k we're actually closer to this

00:18:54,230 --> 00:19:00,190
date than we are to January 1st 2000 so

00:18:56,870 --> 00:19:00,190
it's time to panic again

00:19:00,690 --> 00:19:05,200
maybe not yet so there's already been

00:19:03,610 --> 00:19:08,440
some pretty high-profile instances of

00:19:05,200 --> 00:19:11,350
this issue NASA launched a probe back in

00:19:08,440 --> 00:19:13,330
2005 to inspect the interior of a comet

00:19:11,350 --> 00:19:15,250
and it succeeded in its mission and was

00:19:13,330 --> 00:19:17,289
going off doing other missions and they

00:19:15,250 --> 00:19:21,519
lost contact with it in August of 23

00:19:17,289 --> 00:19:22,720
2013 and NASA reported that they lost

00:19:21,519 --> 00:19:24,129
contact with it because the onboard

00:19:22,720 --> 00:19:26,740
computer just kept rebooting over and

00:19:24,129 --> 00:19:29,080
over and over and over again and they

00:19:26,740 --> 00:19:31,029
determined that the reason for it was

00:19:29,080 --> 00:19:33,129
similar to this exact same problem

00:19:31,029 --> 00:19:35,350
dealing with time they were tracking the

00:19:33,129 --> 00:19:38,559
runtime of the probe by the number of

00:19:35,350 --> 00:19:41,110
tenth seconds since January 1st 2000 and

00:19:38,559 --> 00:19:43,330
they were storing that value as a 32-bit

00:19:41,110 --> 00:19:44,710
integer and it rolled over the exact

00:19:43,330 --> 00:19:47,460
moment that the computer just started

00:19:44,710 --> 00:19:50,250
rebooting over and over and over again

00:19:47,460 --> 00:19:56,309
the total cost of developing that probe

00:19:50,250 --> 00:19:59,409
was 330 million dollars so it was not a

00:19:56,309 --> 00:20:01,389
wasn't a minor bug it was definitely a

00:19:59,409 --> 00:20:03,850
problem and there was no way to fix it

00:20:01,389 --> 00:20:06,879
right in space so you got to do this

00:20:03,850 --> 00:20:09,820
beforehand this problem is not limited

00:20:06,879 --> 00:20:11,350
to tracking time either if you're using

00:20:09,820 --> 00:20:13,149
my sequel or Postgres and you have a

00:20:11,350 --> 00:20:15,970
table that's approaching 2 billion rows

00:20:13,149 --> 00:20:18,340
you probably could run into this issue

00:20:15,970 --> 00:20:21,129
at Adworks we actually ran into it this

00:20:18,340 --> 00:20:25,179
month we had a table that we were using

00:20:21,129 --> 00:20:27,250
for like audit logs and uh-huh we we

00:20:25,179 --> 00:20:28,600
kept getting this honey badger saying

00:20:27,250 --> 00:20:31,330
that we are having like a duplicate

00:20:28,600 --> 00:20:32,980
entry for a primary key and I saw this

00:20:31,330 --> 00:20:34,389
and I freaked out

00:20:32,980 --> 00:20:35,830
because I was in the middle of preparing

00:20:34,389 --> 00:20:39,850
this talk and this number had been

00:20:35,830 --> 00:20:42,129
haunting my nightmares so yeah

00:20:39,850 --> 00:20:44,289
the auto increment function in my sequel

00:20:42,129 --> 00:20:45,639
just kept trying to use that max value

00:20:44,289 --> 00:20:48,970
over and over and over again so we kept

00:20:45,639 --> 00:20:53,139
giving this error YouTube they had to

00:20:48,970 --> 00:20:55,779
update their view count column to store

00:20:53,139 --> 00:20:58,000
their yeah their view count has 64 bits

00:20:55,779 --> 00:21:00,539
instead of 32 bits because back in 2014

00:20:58,000 --> 00:21:03,639
Gangnam style was about to hit the limit

00:21:00,539 --> 00:21:05,559
and in fact we've had many more YouTube

00:21:03,639 --> 00:21:07,509
has exceeded that limit since but they

00:21:05,559 --> 00:21:08,960
never thought anybody would ever watch a

00:21:07,509 --> 00:21:12,680
video that many times

00:21:08,960 --> 00:21:14,390
they had they have alright so this is

00:21:12,680 --> 00:21:17,180
the max number we can represent it's 32

00:21:14,390 --> 00:21:19,370
bits if we update our columns to be 64

00:21:17,180 --> 00:21:22,010
bits what's our new max number well it's

00:21:19,370 --> 00:21:24,920
this I don't know how to say it but

00:21:22,010 --> 00:21:27,460
that's it so we convert this to a UNIX

00:21:24,920 --> 00:21:34,130
timestamp it gives us this date which I

00:21:27,460 --> 00:21:35,960
think will be good all right so whatever

00:21:34,130 --> 00:21:39,650
you're parsing time from an API or a

00:21:35,960 --> 00:21:43,640
user input obviously you cannot control

00:21:39,650 --> 00:21:44,930
what format they send you but most

00:21:43,640 --> 00:21:47,750
languages will give you some sort of a

00:21:44,930 --> 00:21:49,670
best guest a parser that you can use so

00:21:47,750 --> 00:21:52,010
PHP has a string to time function

00:21:49,670 --> 00:21:53,630
there's also a date parse function that

00:21:52,010 --> 00:21:56,420
will give you like an array of all the

00:21:53,630 --> 00:21:58,730
date components all of Ruby's date and

00:21:56,420 --> 00:22:01,190
time classes will have a parse method

00:21:58,730 --> 00:22:03,410
but they all kind of expect the string

00:22:01,190 --> 00:22:05,840
you're passing it in to be like ISO 8601

00:22:03,410 --> 00:22:08,780
ish otherwise it'll just raise an

00:22:05,840 --> 00:22:11,240
exception there's a date util module in

00:22:08,780 --> 00:22:13,610
Python that has similar behavior and

00:22:11,240 --> 00:22:15,200
native JavaScript can parse things into

00:22:13,610 --> 00:22:18,380
date as dates as well and you can do it

00:22:15,200 --> 00:22:19,910
two ways so you can pass a string as in

00:22:18,380 --> 00:22:21,620
to the date object and it will spit out

00:22:19,910 --> 00:22:23,360
a date object or you can use the parse

00:22:21,620 --> 00:22:25,760
function and it will spit out unix time

00:22:23,360 --> 00:22:27,380
in milliseconds and there are some

00:22:25,760 --> 00:22:30,860
oddities we will want to be aware of

00:22:27,380 --> 00:22:34,910
when using javascript so what date will

00:22:30,860 --> 00:22:38,870
we expect when we parse this looks iso

00:22:34,910 --> 00:22:42,170
8601 right everything should be great so

00:22:38,870 --> 00:22:43,820
on my machine since I have since well I

00:22:42,170 --> 00:22:45,290
guess I'm in Pittsburgh so it thinks I'm

00:22:43,820 --> 00:22:47,540
in Eastern Standard Time Eastern

00:22:45,290 --> 00:22:50,540
Daylight Time it actually converts it to

00:22:47,540 --> 00:22:52,940
my local time so for whatever reason it

00:22:50,540 --> 00:22:56,000
parsed it as if it were UTC and then

00:22:52,940 --> 00:23:00,770
spit out for hours before midnight was a

00:22:56,000 --> 00:23:05,270
p.m. yesterday which is a little odd so

00:23:00,770 --> 00:23:07,250
if we add in the time suddenly it thinks

00:23:05,270 --> 00:23:09,380
that it's actually local time and it

00:23:07,250 --> 00:23:11,810
will give me local time I don't know why

00:23:09,380 --> 00:23:13,850
just be careful when parsing dates and

00:23:11,810 --> 00:23:17,030
times with JavaScript because you might

00:23:13,850 --> 00:23:18,890
get something you don't expect what if

00:23:17,030 --> 00:23:23,560
we parse the exact same date but in this

00:23:18,890 --> 00:23:23,560
format we can expect the same ping right

00:23:24,409 --> 00:23:28,649
nope

00:23:25,730 --> 00:23:32,369
for whatever reason this format parses

00:23:28,649 --> 00:23:33,869
as midnight in your local time I don't

00:23:32,369 --> 00:23:36,149
know why I think it has something to do

00:23:33,869 --> 00:23:39,570
with the ISO 8601 format it might be

00:23:36,149 --> 00:23:41,009
expecting but yeah it's once again just

00:23:39,570 --> 00:23:43,860
being the lookout for stuff like this

00:23:41,009 --> 00:23:45,210
with JavaScript and you will need to

00:23:43,860 --> 00:23:47,070
parse states like this every once in a

00:23:45,210 --> 00:23:49,799
while a lot of people store and display

00:23:47,070 --> 00:23:53,879
their dates with the day first in the

00:23:49,799 --> 00:23:55,559
month second so your best guess date

00:23:53,879 --> 00:23:57,269
parsers are just not going to work here

00:23:55,559 --> 00:23:59,730
because they're probably expecting a

00:23:57,269 --> 00:24:02,009
different format so we're going to avoid

00:23:59,730 --> 00:24:03,509
these kinds of ambiguities most

00:24:02,009 --> 00:24:05,999
languages will also give you another

00:24:03,509 --> 00:24:08,879
method where you can define the format

00:24:05,999 --> 00:24:10,889
that you were expecting to see like Ruby

00:24:08,879 --> 00:24:12,590
and Python they both have one derp time

00:24:10,889 --> 00:24:15,029
I think is that's how I say it

00:24:12,590 --> 00:24:17,879
most of these will let you pass in that

00:24:15,029 --> 00:24:20,249
format as like tokens of whatever part

00:24:17,879 --> 00:24:22,590
of the data it is so like what is it D

00:24:20,249 --> 00:24:24,119
for the day and M for the month Y for

00:24:22,590 --> 00:24:26,220
the year

00:24:24,119 --> 00:24:28,590
PHP has a stirrup time at the two but I

00:24:26,220 --> 00:24:31,860
think the more preferred method is

00:24:28,590 --> 00:24:33,539
create from format I have not used PHP

00:24:31,860 --> 00:24:35,460
in seven years so don't quote me on that

00:24:33,539 --> 00:24:37,350
I just used a github search and

00:24:35,460 --> 00:24:41,369
apparently more people using that which

00:24:37,350 --> 00:24:46,429
might not be a great measurement of

00:24:41,369 --> 00:24:48,659
whether or not it's right so disclaimer

00:24:46,429 --> 00:24:50,669
JavaScript does not have a function to

00:24:48,659 --> 00:24:53,869
do this out of the box so you have to

00:24:50,669 --> 00:24:57,149
use a library like JJ s or moment Jas

00:24:53,869 --> 00:24:59,580
alright so let's say we have a form

00:24:57,149 --> 00:25:02,100
submission or an API response and we

00:24:59,580 --> 00:25:05,639
wanted to store the start set or in that

00:25:02,100 --> 00:25:07,759
date in our database what to convert

00:25:05,639 --> 00:25:10,230
these times or these strings into dates

00:25:07,759 --> 00:25:12,809
now these since these timestamps are

00:25:10,230 --> 00:25:15,179
actually already kind of formatted like

00:25:12,809 --> 00:25:17,220
ISO 8601 our best guess date parsers are

00:25:15,179 --> 00:25:20,580
probably to be just fine here and same

00:25:17,220 --> 00:25:22,649
if they use unix time but if they're

00:25:20,580 --> 00:25:25,529
sending it to you in numerous pieces

00:25:22,649 --> 00:25:26,730
you'll have to do some more work this

00:25:25,529 --> 00:25:30,389
might be more common if you're using

00:25:26,730 --> 00:25:31,710
like a date picker in an HTML form what

00:25:30,389 --> 00:25:34,019
if you need to parse natural language

00:25:31,710 --> 00:25:35,330
right some languages will have plugins

00:25:34,019 --> 00:25:37,399
to help with this

00:25:35,330 --> 00:25:39,169
like you'll still need to clear up some

00:25:37,399 --> 00:25:43,009
ambiguities it's like noon in which time

00:25:39,169 --> 00:25:45,110
zone for instance like chronic use

00:25:43,009 --> 00:25:46,369
rubygem it's been around for a while and

00:25:45,110 --> 00:25:48,619
it's well maintained

00:25:46,369 --> 00:25:51,309
it supports full-text parsing like this

00:25:48,619 --> 00:25:53,690
there's a day parser library in Python

00:25:51,309 --> 00:25:55,279
there's some also some good natural

00:25:53,690 --> 00:25:57,049
language processing api's out there if

00:25:55,279 --> 00:25:59,259
your language doesn't support it or

00:25:57,049 --> 00:26:01,159
there's not already an existing library

00:25:59,259 --> 00:26:03,200
alright so once you have a date object

00:26:01,159 --> 00:26:04,730
most languages will let you extract

00:26:03,200 --> 00:26:07,820
information from the date object late

00:26:04,730 --> 00:26:10,789
what day of the week it is or what's the

00:26:07,820 --> 00:26:13,340
name of the day or what week in the year

00:26:10,789 --> 00:26:16,249
it is JavaScript has a lot of these

00:26:13,340 --> 00:26:18,379
functions built-in surprisingly but

00:26:16,249 --> 00:26:22,909
there's one you do not want to use and

00:26:18,379 --> 00:26:25,399
that's get year for y2k purposes it

00:26:22,909 --> 00:26:31,009
returns the year as the number of years

00:26:25,399 --> 00:26:32,840
- 1900 it was deprecated back in 1997 in

00:26:31,009 --> 00:26:35,509
favor of 'get full year which does

00:26:32,840 --> 00:26:37,129
return the year in four digits but now

00:26:35,509 --> 00:26:40,129
everyone ran and updated all their codes

00:26:37,129 --> 00:26:43,009
so get years actually still in use a lot

00:26:40,129 --> 00:26:44,330
and it's it's in the ACMA script

00:26:43,009 --> 00:26:45,980
standard for backwards compatibility

00:26:44,330 --> 00:26:46,749
purposes but they just recommend you not

00:26:45,980 --> 00:26:49,659
use it anymore

00:26:46,749 --> 00:26:51,529
alright so why do we care right so

00:26:49,659 --> 00:26:53,989
things to keep in mind when you're

00:26:51,529 --> 00:26:55,999
parsing dates if you're parsing dates

00:26:53,989 --> 00:26:58,789
from a third party API check to see what

00:26:55,999 --> 00:27:01,070
format they're singing it to and if they

00:26:58,789 --> 00:27:03,950
aren't sending it to you and like ISO

00:27:01,070 --> 00:27:05,809
8601 use one of those parsing methods

00:27:03,950 --> 00:27:08,210
where you can accommodate that specific

00:27:05,809 --> 00:27:10,100
format there is really no

00:27:08,210 --> 00:27:12,649
one-size-fits-all method here you're

00:27:10,100 --> 00:27:14,629
just gonna have to be vigilant leap

00:27:12,649 --> 00:27:16,999
years probably the last thing you're

00:27:14,629 --> 00:27:19,369
worrying about but they do have some

00:27:16,999 --> 00:27:20,859
rules we need to be aware of so how do

00:27:19,369 --> 00:27:23,269
you determine if a year's a leap year

00:27:20,859 --> 00:27:25,609
the rules are if the year is divisible

00:27:23,269 --> 00:27:29,700
by four and it's not divisible by a

00:27:25,609 --> 00:27:32,080
hundred unless it's divisible by 400

00:27:29,700 --> 00:27:33,990
I'm glad you guys got laughs out of that

00:27:32,080 --> 00:27:37,420
because I had no idea this was a thing I

00:27:33,990 --> 00:27:40,510
felt really weird but so this means that

00:27:37,420 --> 00:27:42,970
1600 and 2000 were leap years but all

00:27:40,510 --> 00:27:46,320
the other Centennial years weren't so

00:27:42,970 --> 00:27:48,490
2400 is our next Centennial leap year

00:27:46,320 --> 00:27:50,650
yeah once again I had no idea until I

00:27:48,490 --> 00:27:52,450
had to research it for this I asked my

00:27:50,650 --> 00:27:54,670
entire family I was like hey who knows

00:27:52,450 --> 00:27:56,020
how we peers work and ailments everyone

00:27:54,670 --> 00:27:58,680
was like I don't know every four years

00:27:56,020 --> 00:28:01,630
like cool I'm puttin it into the talk

00:27:58,680 --> 00:28:04,750
alright so if we wanted to use a write a

00:28:01,630 --> 00:28:06,880
function to check this logic we could we

00:28:04,750 --> 00:28:08,080
could do so or we could lean on some of

00:28:06,880 --> 00:28:10,090
the date libraries or our languages

00:28:08,080 --> 00:28:13,360
might already have native JavaScript

00:28:10,090 --> 00:28:14,530
does not have one so once again you'll

00:28:13,360 --> 00:28:15,880
have to write something like this this

00:28:14,530 --> 00:28:18,610
is actually straight out of the moment J

00:28:15,880 --> 00:28:21,070
s library and you can check a leap year

00:28:18,610 --> 00:28:22,810
in a little bit more of a bizarre way in

00:28:21,070 --> 00:28:25,000
JavaScript and so you can initialize

00:28:22,810 --> 00:28:27,910
this data object and you can pass in for

00:28:25,000 --> 00:28:30,010
the date or the day field more days than

00:28:27,910 --> 00:28:33,280
are actually in that month and it will

00:28:30,010 --> 00:28:35,980
give you like whatever day it is so like

00:28:33,280 --> 00:28:39,030
the 32nd day in December is really

00:28:35,980 --> 00:28:43,000
January 1st of the next year this works

00:28:39,030 --> 00:28:44,680
by the way I don't know why so 11 here

00:28:43,000 --> 00:28:50,710
represents December because it's a zero

00:28:44,680 --> 00:28:52,240
based system so we could write a

00:28:50,710 --> 00:28:54,670
function using that right we could just

00:28:52,240 --> 00:28:57,250
pass in a year and check to see if the

00:28:54,670 --> 00:29:00,070
date is in the month of February and if

00:28:57,250 --> 00:29:01,120
it is it's a leap year this is actually

00:29:00,070 --> 00:29:03,490
a more common method used in

00:29:01,120 --> 00:29:04,600
spreadsheets where you don't have a

00:29:03,490 --> 00:29:07,980
whole lot of functions to manipulate

00:29:04,600 --> 00:29:10,480
dates and the 80s and 90s IBM Lotus

00:29:07,980 --> 00:29:12,220
users could determine if a leap year was

00:29:10,480 --> 00:29:15,040
a leap year by doing the same type of

00:29:12,220 --> 00:29:17,110
calculation and they would enter the

00:29:15,040 --> 00:29:19,390
29th of February and say hey is the

00:29:17,110 --> 00:29:21,160
month equal to three then it's not a

00:29:19,390 --> 00:29:25,810
leap year or the months equal to two it

00:29:21,160 --> 00:29:29,860
is but a bug made 1900 actually return

00:29:25,810 --> 00:29:31,570
true so Excel decided that they would

00:29:29,860 --> 00:29:33,190
support this functionality for backwards

00:29:31,570 --> 00:29:36,370
compatibility and it made its way into

00:29:33,190 --> 00:29:38,790
the OpenOffice OpenOffice XML standard

00:29:36,370 --> 00:29:40,570
and it's still there

00:29:38,790 --> 00:29:42,590
so if you ever develop anything

00:29:40,570 --> 00:29:46,759
supporting that

00:29:42,590 --> 00:29:48,629
you have to make 1900 illipe here

00:29:46,759 --> 00:29:51,149
alright so why do we care

00:29:48,629 --> 00:29:53,909
Lily if yours is so predictable like why

00:29:51,149 --> 00:29:55,289
do we need to worry about them well

00:29:53,909 --> 00:29:57,240
maybe you're making some sort of payroll

00:29:55,289 --> 00:29:59,159
software right and you're sitting out

00:29:57,240 --> 00:30:01,230
checks at the end of the month sitting

00:29:59,159 --> 00:30:04,769
how to check a day early not a big deal

00:30:01,230 --> 00:30:06,629
day late probably a big deal maybe you

00:30:04,769 --> 00:30:10,200
need to program in some subscription but

00:30:06,629 --> 00:30:12,090
the subscription billing or maybe you

00:30:10,200 --> 00:30:15,450
have a calendar app or something that

00:30:12,090 --> 00:30:17,129
schedules events in general or you'd

00:30:15,450 --> 00:30:18,690
want to validate that the 29th of

00:30:17,129 --> 00:30:19,830
February is an actual date in whatever

00:30:18,690 --> 00:30:23,519
year they're trying to create an event

00:30:19,830 --> 00:30:26,970
and then anyway you're dividing by 365 I

00:30:23,519 --> 00:30:28,619
don't know why I thought of this I think

00:30:26,970 --> 00:30:31,139
we've done this numerous times in our

00:30:28,619 --> 00:30:33,389
code base so if you just search for 365

00:30:31,139 --> 00:30:37,049
or maybe like you know slash 365 you

00:30:33,389 --> 00:30:39,809
might be surprised alright so the last

00:30:37,049 --> 00:30:41,909
but not least the most of the most

00:30:39,809 --> 00:30:43,499
important part but one of the last

00:30:41,909 --> 00:30:45,149
little bit is presenting time how are we

00:30:43,499 --> 00:30:47,490
going to use all this information about

00:30:45,149 --> 00:30:49,499
how we want to store time and parse time

00:30:47,490 --> 00:30:52,740
and use it to be good shepherds of like

00:30:49,499 --> 00:30:55,379
presenting time to everybody so if you

00:30:52,740 --> 00:30:57,929
need to transit time via an API like a

00:30:55,379 --> 00:31:02,279
time stamp your best bet is to use ISO

00:30:57,929 --> 00:31:04,139
8601 or unix time if you're having a

00:31:02,279 --> 00:31:05,309
hard time choosing a format don't feel

00:31:04,139 --> 00:31:08,299
bad

00:31:05,309 --> 00:31:11,399
stripe a stripes API uses unix time

00:31:08,299 --> 00:31:13,950
Facebook's API uses ISO 8601 with a

00:31:11,399 --> 00:31:15,899
timezone offset for local time Twitter

00:31:13,950 --> 00:31:20,009
uses the JavaScript full text format

00:31:15,899 --> 00:31:21,629
github uses ISO 8601 in UTC and Google

00:31:20,009 --> 00:31:25,049
Drive formats their time stamps using

00:31:21,629 --> 00:31:27,570
RFC 3339 with milliseconds so once again

00:31:25,049 --> 00:31:32,129
just pick one of the standards in and be

00:31:27,570 --> 00:31:34,470
consistent and be aware of time zones as

00:31:32,129 --> 00:31:36,899
well if you are sending a time stamp out

00:31:34,470 --> 00:31:39,210
and the time zone is important send the

00:31:36,899 --> 00:31:41,970
time stamp as UTC and the time zone

00:31:39,210 --> 00:31:45,840
along as its actual identifier from the

00:31:41,970 --> 00:31:47,789
TZ database this way the users can

00:31:45,840 --> 00:31:50,789
convert to whatever local time they need

00:31:47,789 --> 00:31:52,710
to or they want to if you are displaying

00:31:50,789 --> 00:31:55,090
a time zone in a UI you've got a few

00:31:52,710 --> 00:31:58,060
more options you can

00:31:55,090 --> 00:32:00,430
it as the abbreviation you can show it

00:31:58,060 --> 00:32:04,360
as the offset you can show it as the

00:32:00,430 --> 00:32:06,760
friendly name it's really up to you if

00:32:04,360 --> 00:32:10,300
your desplaines starting in times in

00:32:06,760 --> 00:32:12,270
your app and the start time has a

00:32:10,300 --> 00:32:14,320
different time zone than the end time

00:32:12,270 --> 00:32:16,810
you're near you I should probably

00:32:14,320 --> 00:32:18,700
reflect that this is a Southwest flight

00:32:16,810 --> 00:32:20,470
itinerary I had last week and I was

00:32:18,700 --> 00:32:22,870
surprised even in the app and the email

00:32:20,470 --> 00:32:25,990
at a glance I'm like oh cool my flights

00:32:22,870 --> 00:32:27,460
almost 25 minutes long even though it

00:32:25,990 --> 00:32:29,020
shows on the right-hand side that it's

00:32:27,460 --> 00:32:30,940
an hour in 25 minutes there's no time

00:32:29,020 --> 00:32:33,550
zone information here so how did glance

00:32:30,940 --> 00:32:34,810
it kind of be weird especially if you're

00:32:33,550 --> 00:32:36,160
traveling from the West Coast all the

00:32:34,810 --> 00:32:38,770
way to the East Coast it would be a very

00:32:36,160 --> 00:32:40,510
long looking flight you'd be like oh my

00:32:38,770 --> 00:32:43,360
god that's a 10-hour flight from San

00:32:40,510 --> 00:32:45,160
Francisco to Raleigh so if you're

00:32:43,360 --> 00:32:47,110
displaying a date or time on a web page

00:32:45,160 --> 00:32:48,910
you can use this time tag and this will

00:32:47,110 --> 00:32:51,670
help make it written machine readable so

00:32:48,910 --> 00:32:53,860
for screen readers or for search engines

00:32:51,670 --> 00:32:55,840
and you can add a date/time attribute as

00:32:53,860 --> 00:32:57,820
well if you need to represent some sort

00:32:55,840 --> 00:33:01,750
of relative date or something that's not

00:32:57,820 --> 00:33:04,210
a standard for everything else you do

00:33:01,750 --> 00:33:05,860
with presenting time just be consistent

00:33:04,210 --> 00:33:07,360
right just pick a format that is

00:33:05,860 --> 00:33:11,530
relevant to whatever you're using it for

00:33:07,360 --> 00:33:14,830
and adopt a standard where possible all

00:33:11,530 --> 00:33:17,290
right so to wrap things up let's list a

00:33:14,830 --> 00:33:18,460
few things that we can use to be a

00:33:17,290 --> 00:33:20,410
little bit more diligent when dealing

00:33:18,460 --> 00:33:22,870
with time alright first we can stop

00:33:20,410 --> 00:33:25,540
start by adopting some standards ISO

00:33:22,870 --> 00:33:27,730
8601 is a widely used standard it's very

00:33:25,540 --> 00:33:30,430
simple and you're probably even using it

00:33:27,730 --> 00:33:32,800
right now without knowing it try to

00:33:30,430 --> 00:33:36,190
store timestamps and UTC rather than in

00:33:32,800 --> 00:33:38,590
local time store and present time zones

00:33:36,190 --> 00:33:40,420
using the name in the TZ database

00:33:38,590 --> 00:33:43,720
instead of maybe the friendly name or

00:33:40,420 --> 00:33:45,370
the offset present time zones when

00:33:43,720 --> 00:33:48,760
necessary like that flight itinerary

00:33:45,370 --> 00:33:49,540
example start storing UNIX timestamps is

00:33:48,760 --> 00:33:54,460
64 bits

00:33:49,540 --> 00:33:56,050
soonish don't wait til 20 37 be aware of

00:33:54,460 --> 00:33:57,760
leap years because they could they could

00:33:56,050 --> 00:34:01,660
throw a wrench in the mix and we've got

00:33:57,760 --> 00:34:03,220
one coming up 2020 is a leap year so and

00:34:01,660 --> 00:34:05,710
here's some things we just need to be

00:34:03,220 --> 00:34:06,160
aware of like how the world deals with

00:34:05,710 --> 00:34:07,660
time

00:34:06,160 --> 00:34:08,070
not everyone observes daylight saving

00:34:07,660 --> 00:34:10,530
time and

00:34:08,070 --> 00:34:13,620
who do don't do so at the same date or

00:34:10,530 --> 00:34:16,020
time and and the daylight saving time

00:34:13,620 --> 00:34:17,370
rules will change in fact I think the

00:34:16,020 --> 00:34:20,070
United States they changed them back in

00:34:17,370 --> 00:34:23,690
2007 and they're bound to change in the

00:34:20,070 --> 00:34:26,880
next 10 years time zones change as well

00:34:23,690 --> 00:34:29,490
the offsets with respect to UTC are

00:34:26,880 --> 00:34:31,170
ambiguous - the time zones like - Oh 400

00:34:29,490 --> 00:34:33,960
is not always the same for the East

00:34:31,170 --> 00:34:36,570
Coast and not everyone uses the same

00:34:33,960 --> 00:34:39,960
format for dates and times so things to

00:34:36,570 --> 00:34:41,510
be aware of so thank you all so much for

00:34:39,960 --> 00:34:45,150
coming I really do appreciate you

00:34:41,510 --> 00:34:46,920
finishing the the week here if you have

00:34:45,150 --> 00:34:48,660
any fun y2k stories that you want to

00:34:46,920 --> 00:34:52,350
tell me about I will be out here on my

00:34:48,660 --> 00:34:55,760
way to the the keynote and also one last

00:34:52,350 --> 00:34:59,210
thing I want to give out is for my wife

00:34:55,760 --> 00:35:02,010
this last two months I've basically been

00:34:59,210 --> 00:35:03,840
coming home every day and sitting in my

00:35:02,010 --> 00:35:05,130
office for numerous hours trying to prep

00:35:03,840 --> 00:35:07,290
for this and if there are any speakers

00:35:05,130 --> 00:35:11,670
in here you know how much time goes into

00:35:07,290 --> 00:35:12,690
this so thank you Nicki so much for for

00:35:11,670 --> 00:35:15,270
taking care of our daughter basically

00:35:12,690 --> 00:35:17,490
single-handed in the last two months I

00:35:15,270 --> 00:35:19,170
love you very much and honestly this

00:35:17,490 --> 00:35:21,210
will would not have happened if it

00:35:19,170 --> 00:35:23,400
wasn't for her so thank you everybody

00:35:21,210 --> 00:35:26,150
enjoy the final keynote and come talk to

00:35:23,400 --> 00:35:26,150
me afterwards

00:35:35,079 --> 00:35:39,999

YouTube URL: https://www.youtube.com/watch?v=E2W-rNT5_9A


