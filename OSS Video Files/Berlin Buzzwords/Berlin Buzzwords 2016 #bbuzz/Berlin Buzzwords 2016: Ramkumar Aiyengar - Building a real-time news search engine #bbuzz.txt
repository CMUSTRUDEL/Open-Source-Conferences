Title: Berlin Buzzwords 2016: Ramkumar Aiyengar - Building a real-time news search engine #bbuzz
Publication date: 2016-06-13
Playlist: Berlin Buzzwords 2016 #bbuzz
Description: 
	What challenges could a search engine have? Large number of documents? Large query load? Very complex queries? A challenging privileging model? Expected low query latency? High volume of document updates? Updates to documents reflected in milliseconds? Realtime alerting for any search? Absolutely no downtime any time of the day, week or year? What if a search engine had all these challenges? Meet the backend which drives News Search at Bloomberg LP. 

In this talk, Ramkumar Aiyengar talks about how he and his colleagues successfully pushed Solr over the last three years to unchartered territories, to deliver a real-time search engine critical to the workflow of hundreds of thousands of customers worldwide.

Read more:
https://2016.berlinbuzzwords.de/session/building-real-time-news-search-engine

About Ramkumar Aiyengar:
https://2016.berlinbuzzwords.de/users/ramkumar-aiyengar

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:03,470 --> 00:00:08,700
thank you welcome to the building the

00:00:06,390 --> 00:00:12,080
new search engine talk in purple that's

00:00:08,700 --> 00:00:12,080
a feature you have to trust me on that

00:00:14,030 --> 00:00:20,070
so briefly about a Bloomberg and a bit

00:00:17,190 --> 00:00:21,840
about me it almost looks like artsy now

00:00:20,070 --> 00:00:24,269
with the purple on I didn't quite

00:00:21,840 --> 00:00:26,609
intended effect Bloomberg is a

00:00:24,269 --> 00:00:29,099
technology company our focus and

00:00:26,609 --> 00:00:31,260
strength is data you probably know

00:00:29,099 --> 00:00:33,750
Bloomberg through the channel you see on

00:00:31,260 --> 00:00:35,760
TV but the biggest product we do have is

00:00:33,750 --> 00:00:37,559
what is called the terminal which is a

00:00:35,760 --> 00:00:40,050
one-stop shop for people in the

00:00:37,559 --> 00:00:42,000
financial industry as well as garments

00:00:40,050 --> 00:00:43,680
and economists and other people and

00:00:42,000 --> 00:00:45,960
other professional disciplines to get

00:00:43,680 --> 00:00:47,219
data visualize data do calculations on

00:00:45,960 --> 00:00:51,149
data and pretty much carry out their

00:00:47,219 --> 00:00:53,190
workflow based on the screens that the

00:00:51,149 --> 00:00:55,820
terminal provides we also offer other

00:00:53,190 --> 00:00:58,890
vertical portals on on the web for

00:00:55,820 --> 00:01:00,870
various different disciplines like the

00:00:58,890 --> 00:01:02,910
if you are interested in the garments or

00:01:00,870 --> 00:01:07,530
if you're interested if you are a lawyer

00:01:02,910 --> 00:01:11,490
interested litigation and those from our

00:01:07,530 --> 00:01:13,229
customer base a bit about me I started

00:01:11,490 --> 00:01:15,810
Bloomberg nine years back I'm now the

00:01:13,229 --> 00:01:17,549
team lead for the new search team which

00:01:15,810 --> 00:01:19,740
is responsible for the search alerting

00:01:17,549 --> 00:01:22,770
and ingest infrastructure for news there

00:01:19,740 --> 00:01:25,460
are other teams within Bloomberg which

00:01:22,770 --> 00:01:27,390
work on such as well we even have like a

00:01:25,460 --> 00:01:28,920
generating platform which allows people

00:01:27,390 --> 00:01:31,229
to build applications based on search

00:01:28,920 --> 00:01:34,950
Steve my colleague is responsible for

00:01:31,229 --> 00:01:36,990
that but this this job will mostly focus

00:01:34,950 --> 00:01:39,920
on the news side and how we went about

00:01:36,990 --> 00:01:42,540
building the new search platform I

00:01:39,920 --> 00:01:44,310
started with solar leucine pretty much

00:01:42,540 --> 00:01:46,829
sort of like with hello world three

00:01:44,310 --> 00:01:48,210
years back we found during the course of

00:01:46,829 --> 00:01:49,710
a project that we needed to deal with

00:01:48,210 --> 00:01:52,470
solar and leucine and its internals a

00:01:49,710 --> 00:01:54,360
lot we kept coding making changes I'm

00:01:52,470 --> 00:01:57,000
now committed with the project with

00:01:54,360 --> 00:01:58,530
apache so leucine we actually have two

00:01:57,000 --> 00:02:01,979
more computers in the company now after

00:01:58,530 --> 00:02:03,869
me and this talk is going to be a lot

00:02:01,979 --> 00:02:05,430
about the changes we have done to solar

00:02:03,869 --> 00:02:08,990
as well and about what kind of

00:02:05,430 --> 00:02:08,990
challenges we faced and so on

00:02:09,350 --> 00:02:15,860
so even before i go into what we did

00:02:12,770 --> 00:02:20,060
this is pretty much a typical such this

00:02:15,860 --> 00:02:21,920
ecosystem if i would call that what

00:02:20,060 --> 00:02:24,320
happens when you search you go to any

00:02:21,920 --> 00:02:26,510
any any search engine you start typing

00:02:24,320 --> 00:02:29,030
the system starts suggesting queries as

00:02:26,510 --> 00:02:30,410
soon as a user is typing you end up

00:02:29,030 --> 00:02:31,850
typing some query either based on

00:02:30,410 --> 00:02:34,070
suggestion or you type it out yourself

00:02:31,850 --> 00:02:35,750
then the system tries to understand the

00:02:34,070 --> 00:02:37,880
query and tries to figure out what you

00:02:35,750 --> 00:02:39,800
exactly meant using NLP entity

00:02:37,880 --> 00:02:42,950
recognition disambiguation spell

00:02:39,800 --> 00:02:44,540
checking etc at the end of it you get a

00:02:42,950 --> 00:02:47,360
more structured query which looks for

00:02:44,540 --> 00:02:49,640
keywords and metadata of documents you

00:02:47,360 --> 00:02:51,470
search for that you get results often

00:02:49,640 --> 00:02:53,150
you get results which are in millions

00:02:51,470 --> 00:02:55,600
then your biggest problem then is to

00:02:53,150 --> 00:02:58,580
sort the results as the usage dictates

00:02:55,600 --> 00:02:59,900
sometimes the search could be sought

00:02:58,580 --> 00:03:01,370
short order could be something very

00:02:59,900 --> 00:03:03,050
simple like show me in reverse

00:03:01,370 --> 00:03:05,330
chronological order but the most common

00:03:03,050 --> 00:03:08,300
ones and it tends to be by search

00:03:05,330 --> 00:03:10,850
relevance as in how relevant is this

00:03:08,300 --> 00:03:12,110
document to the user you also have some

00:03:10,850 --> 00:03:14,120
cases where you need more

00:03:12,110 --> 00:03:16,340
diversification or you want sort of like

00:03:14,120 --> 00:03:17,450
some results from what of others in in

00:03:16,340 --> 00:03:18,650
essence you get an ordering of the

00:03:17,450 --> 00:03:22,310
results based on the results you have

00:03:18,650 --> 00:03:24,110
retrieved in many cases including ours

00:03:22,310 --> 00:03:25,790
and this this forms a more exciting part

00:03:24,110 --> 00:03:29,390
of what we do there is a real-time

00:03:25,790 --> 00:03:32,300
element to it very unique but you also

00:03:29,390 --> 00:03:35,150
need to display alerts as soon as a new

00:03:32,300 --> 00:03:37,820
search result comes up and then on top

00:03:35,150 --> 00:03:40,520
of that you need to expose facets and be

00:03:37,820 --> 00:03:42,560
able to tell people what else to search

00:03:40,520 --> 00:03:45,200
on and finally you end up sometimes

00:03:42,560 --> 00:03:49,490
recommending searches and recommending

00:03:45,200 --> 00:03:51,260
stories as well for people to do this in

00:03:49,490 --> 00:03:55,670
this talk in particular I'm going to

00:03:51,260 --> 00:03:57,560
focus on just two lines of it as many of

00:03:55,670 --> 00:03:59,810
you probably already know each one of

00:03:57,560 --> 00:04:01,790
this stands a talk by itself you can you

00:03:59,810 --> 00:04:03,680
can't talk for an hour almost on how

00:04:01,790 --> 00:04:05,690
such infrastructure is built what the

00:04:03,680 --> 00:04:08,390
entire sort of stack behind it and so on

00:04:05,690 --> 00:04:09,890
there is a lot to be talked up but in

00:04:08,390 --> 00:04:11,360
interest interest of time I'll be

00:04:09,890 --> 00:04:14,480
focusing mostly on the searching and

00:04:11,360 --> 00:04:17,140
sorting more to do with what sola

00:04:14,480 --> 00:04:17,140
leucine does

00:04:17,560 --> 00:04:22,610
as with everything the challenge always

00:04:21,080 --> 00:04:24,620
is not just an implementation but also

00:04:22,610 --> 00:04:27,350
the scale of it and Bloomberg has its

00:04:24,620 --> 00:04:30,290
own share of challenges we have around

00:04:27,350 --> 00:04:32,180
320,000 27,000 customers almost all of

00:04:30,290 --> 00:04:34,790
them use news we get around 10 million

00:04:32,180 --> 00:04:37,370
searches a day not the greatest amount

00:04:34,790 --> 00:04:39,290
that you have ever seen quoted but the

00:04:37,370 --> 00:04:41,510
main challenge there is that the search

00:04:39,290 --> 00:04:44,060
needs to be real time as well as need to

00:04:41,510 --> 00:04:46,610
respond fast so our average response

00:04:44,060 --> 00:04:47,960
time is around 1 80 milliseconds the

00:04:46,610 --> 00:04:49,640
mean is actually less than hundred which

00:04:47,960 --> 00:04:51,110
is a different entirely interesting

00:04:49,640 --> 00:04:54,860
story as well which I will skip at this

00:04:51,110 --> 00:04:56,690
point we get over 500 story is a second

00:04:54,860 --> 00:04:59,110
sometimes at peak rate it tends to be

00:04:56,690 --> 00:05:02,090
very spiky traffic as new softness and

00:04:59,110 --> 00:05:03,740
the real challenge here is that these

00:05:02,090 --> 00:05:05,900
results need to be available for search

00:05:03,740 --> 00:05:08,030
in a 100 milliseconds if you're familiar

00:05:05,900 --> 00:05:10,550
with search this is often a big dilemma

00:05:08,030 --> 00:05:13,130
you face with how how fast can your

00:05:10,550 --> 00:05:17,330
search results be retrieved and how how

00:05:13,130 --> 00:05:18,770
real time is your search really overall

00:05:17,330 --> 00:05:20,750
we have an index of around 500 million

00:05:18,770 --> 00:05:22,310
stories obviously with news like the

00:05:20,750 --> 00:05:23,960
older the story goes sometimes it's not

00:05:22,310 --> 00:05:27,230
just important and we sometimes discuss

00:05:23,960 --> 00:05:29,600
stories and also as I mentioned this is

00:05:27,230 --> 00:05:31,340
a real-time system so whatever we do to

00:05:29,600 --> 00:05:33,890
get initial set of results we also need

00:05:31,340 --> 00:05:35,480
to alert on top of that especially we

00:05:33,890 --> 00:05:37,760
have a very strong case for

00:05:35,480 --> 00:05:40,190
chronological search results we do

00:05:37,760 --> 00:05:42,170
relevant sorted results as well both are

00:05:40,190 --> 00:05:43,520
equally important use cases but

00:05:42,170 --> 00:05:46,490
especially for the chronological search

00:05:43,520 --> 00:05:48,140
results day traders for example in the

00:05:46,490 --> 00:05:50,090
financial industry expect results to

00:05:48,140 --> 00:05:52,400
show up on their screen as soon as it

00:05:50,090 --> 00:05:54,320
arrives and this holds good for any any

00:05:52,400 --> 00:05:56,720
search what any search that they come up

00:05:54,320 --> 00:05:58,370
with it could be arbitrarily complex we

00:05:56,720 --> 00:06:02,120
are we have around 1.5 million of those

00:05:58,370 --> 00:06:04,700
seif searches and we endeavor to provide

00:06:02,120 --> 00:06:07,850
a lot Susan hundred millisecond so the

00:06:04,700 --> 00:06:09,650
story coming in either either in front

00:06:07,850 --> 00:06:13,550
of their screens or there are other

00:06:09,650 --> 00:06:16,250
mechanisms available as well in

00:06:13,550 --> 00:06:18,920
particular what's kind of kept us busy

00:06:16,250 --> 00:06:22,310
in the last few years and it's still

00:06:18,920 --> 00:06:23,800
ongoing is we used to have an existing

00:06:22,310 --> 00:06:27,350
system which was based on a proprietary

00:06:23,800 --> 00:06:29,710
system it was a it was past tense of

00:06:27,350 --> 00:06:31,260
end-of-life it was inflexible it had no

00:06:29,710 --> 00:06:32,970
scalable relevance

00:06:31,260 --> 00:06:36,090
thing had a lot of other limitations

00:06:32,970 --> 00:06:39,090
like you typically would associate with

00:06:36,090 --> 00:06:40,320
a third-party software so around a few

00:06:39,090 --> 00:06:42,330
years a few years back around three

00:06:40,320 --> 00:06:43,950
years back we started looking at other

00:06:42,330 --> 00:06:47,190
solutions especially open source

00:06:43,950 --> 00:06:48,390
solutions and we did a bit of a survey

00:06:47,190 --> 00:06:51,960
and we finally ended up with solar

00:06:48,390 --> 00:06:54,300
leucine for a few reasons many of you

00:06:51,960 --> 00:06:56,520
probably know this this region features

00:06:54,300 --> 00:06:58,230
extensible it's actively maintained it's

00:06:56,520 --> 00:07:00,180
free software which means that we can

00:06:58,230 --> 00:07:04,290
contribute back to it we can modify the

00:07:00,180 --> 00:07:05,310
source to our requirements and as a part

00:07:04,290 --> 00:07:07,440
of this one of the challenges were

00:07:05,310 --> 00:07:09,570
though was that we had to build in from

00:07:07,440 --> 00:07:11,820
scratch alerting backend which we did

00:07:09,570 --> 00:07:13,320
based on leucine in lugok I probably

00:07:11,820 --> 00:07:15,600
won't have too much of a chance to cover

00:07:13,320 --> 00:07:17,360
the alerting backend which as a certain

00:07:15,600 --> 00:07:20,880
of beginning dis also talk of its own

00:07:17,360 --> 00:07:23,670
but it's it's it's just as exciting at

00:07:20,880 --> 00:07:26,670
this one the entire exercise was not

00:07:23,670 --> 00:07:28,410
just a something we did to change the

00:07:26,670 --> 00:07:30,990
back end but it was an architectural

00:07:28,410 --> 00:07:32,940
revamp one of the driving goals of this

00:07:30,990 --> 00:07:36,000
change was to make the entire system

00:07:32,940 --> 00:07:37,890
scalable and this is especially

00:07:36,000 --> 00:07:40,320
important in the kind of search that we

00:07:37,890 --> 00:07:42,210
do news tends to be spiky our

00:07:40,320 --> 00:07:45,420
requirements change quite dramatically

00:07:42,210 --> 00:07:46,830
in quick succession and often you are

00:07:45,420 --> 00:07:49,770
left with the place where you need to

00:07:46,830 --> 00:07:51,390
scale quite heavily right I need to be

00:07:49,770 --> 00:07:53,580
prepared for a case where tomorrow I

00:07:51,390 --> 00:07:54,840
might be getting ten times the amount of

00:07:53,580 --> 00:07:56,610
load or ten times the number of new

00:07:54,840 --> 00:07:58,050
stories and I should start thinking

00:07:56,610 --> 00:08:01,860
ahead in terms of what I should be doing

00:07:58,050 --> 00:08:03,300
then so this architectural revamp also

00:08:01,860 --> 00:08:05,160
tries to make this entire system

00:08:03,300 --> 00:08:06,450
scalable and also maintain a bill as

00:08:05,160 --> 00:08:10,850
well so that it's very easy to add

00:08:06,450 --> 00:08:14,790
metadata reindex all the data and so on

00:08:10,850 --> 00:08:20,070
so as I did it in four easy steps easy

00:08:14,790 --> 00:08:22,440
being subjective make it work make it

00:08:20,070 --> 00:08:24,390
fast surprising how many people sort of

00:08:22,440 --> 00:08:27,750
like don't think think is important the

00:08:24,390 --> 00:08:29,460
first we spent around a year on the

00:08:27,750 --> 00:08:32,970
first and more than a year one and half

00:08:29,460 --> 00:08:38,849
years on the second make it stable

00:08:32,970 --> 00:08:44,229
that's important and then make it better

00:08:38,849 --> 00:08:50,889
thank you very much have a nice day ok

00:08:44,229 --> 00:08:52,720
let's go deeper so before I go any

00:08:50,889 --> 00:08:55,240
further let's try to understand what

00:08:52,720 --> 00:08:56,800
actually goes into the system this is

00:08:55,240 --> 00:08:58,060
what tends to be typical of a search

00:08:56,800 --> 00:09:02,259
engine you have a document and you have

00:08:58,060 --> 00:09:03,970
a query in our case in particular we

00:09:02,259 --> 00:09:07,569
have new stories research documents

00:09:03,970 --> 00:09:08,889
tweets anything which kind of falls into

00:09:07,569 --> 00:09:10,410
new sometimes doesn't fall so much

00:09:08,889 --> 00:09:12,699
introduce things you are interested in

00:09:10,410 --> 00:09:15,389
public stories mostly but it doesn't

00:09:12,699 --> 00:09:17,740
have to be I will talk about that a bit

00:09:15,389 --> 00:09:19,360
for every new story there's a story body

00:09:17,740 --> 00:09:22,720
obviously there's a headline there's a

00:09:19,360 --> 00:09:24,879
time of arrival there is source there

00:09:22,720 --> 00:09:26,290
are tags associated the story I'm draw

00:09:24,879 --> 00:09:27,670
this talk I'm going to probably skip an

00:09:26,290 --> 00:09:29,680
entire pipeline of events which is

00:09:27,670 --> 00:09:32,040
leading up to the search engine one of

00:09:29,680 --> 00:09:34,689
them is a classifier but which is

00:09:32,040 --> 00:09:37,180
particular part machine learned part

00:09:34,689 --> 00:09:39,939
rules-based and that essentially tries

00:09:37,180 --> 00:09:41,439
to influence the tags associated the

00:09:39,939 --> 00:09:44,319
story and gives them sort of confidence

00:09:41,439 --> 00:09:46,029
intervals and then we have queries

00:09:44,319 --> 00:09:47,800
sometimes they can be a very simple

00:09:46,029 --> 00:09:49,300
query sometimes it could be a simple

00:09:47,800 --> 00:09:51,699
query which is put in the user which is

00:09:49,300 --> 00:09:55,360
interpreted as a more structured complex

00:09:51,699 --> 00:09:56,889
expression but equally and this this

00:09:55,360 --> 00:09:58,269
tends to be not a very common use case

00:09:56,889 --> 00:10:00,699
but is very important for the financial

00:09:58,269 --> 00:10:02,139
industry is we give them full

00:10:00,699 --> 00:10:03,880
flexibility over the search query

00:10:02,139 --> 00:10:06,100
language takes the exposed to search

00:10:03,880 --> 00:10:07,959
query language to them which admittedly

00:10:06,100 --> 00:10:10,540
not a lot of people use it's it's still

00:10:07,959 --> 00:10:14,860
a minority power user base which uses it

00:10:10,540 --> 00:10:16,360
but it's equally important so in this

00:10:14,860 --> 00:10:18,610
example for example you have multiple

00:10:16,360 --> 00:10:20,439
fields you have keywords topics regions

00:10:18,610 --> 00:10:23,470
sources you have boolean queries

00:10:20,439 --> 00:10:25,029
proximity zoning operators especially

00:10:23,470 --> 00:10:27,279
tends to be important sometimes in news

00:10:25,029 --> 00:10:28,870
because news tends to follow that

00:10:27,279 --> 00:10:30,550
pattern the most important thing gets

00:10:28,870 --> 00:10:32,279
mentioned upfront and awful people

00:10:30,550 --> 00:10:36,009
sometimes look for references in that

00:10:32,279 --> 00:10:38,410
phrase searches wildcards searches range

00:10:36,009 --> 00:10:41,589
queries you want time time-based ranges

00:10:38,410 --> 00:10:43,569
search filters we have we have multiple

00:10:41,589 --> 00:10:44,980
languages you sometimes want to filter

00:10:43,569 --> 00:10:47,110
on the relevance of the tag associated

00:10:44,980 --> 00:10:49,800
with the story that's actually the

00:10:47,110 --> 00:10:49,800
default by the way

00:10:50,990 --> 00:10:54,389
some of the interesting aspects of this

00:10:53,430 --> 00:10:56,189
is there as I mentioned it's an

00:10:54,389 --> 00:10:58,819
arbitrary complex boolean expression and

00:10:56,189 --> 00:11:01,079
this applies to both search and alerting

00:10:58,819 --> 00:11:03,240
have seen users actually sort of like

00:11:01,079 --> 00:11:05,329
create 2,000 character such expressions

00:11:03,240 --> 00:11:07,410
don't ask me why they do it they do it

00:11:05,329 --> 00:11:08,699
sometimes they almost considered their

00:11:07,410 --> 00:11:11,689
intellectual property they've built it

00:11:08,699 --> 00:11:11,689
over yours the years of experience

00:11:12,170 --> 00:11:16,189
sometimes it could be a list of metadata

00:11:14,189 --> 00:11:18,480
which is just specified in shorthand

00:11:16,189 --> 00:11:20,910
let's say I'm a portfolio manager I am

00:11:18,480 --> 00:11:23,429
interested in a security portfolio which

00:11:20,910 --> 00:11:25,769
is thousands of securities I just say

00:11:23,429 --> 00:11:29,339
show me news on my portfolio and that

00:11:25,769 --> 00:11:31,889
will translate effectively to an odd

00:11:29,339 --> 00:11:35,189
expression of company a or company b or

00:11:31,889 --> 00:11:36,600
company c thousand times as you can see

00:11:35,189 --> 00:11:38,040
that becomes complex from search engine

00:11:36,600 --> 00:11:40,529
point of view but it's quite easy for

00:11:38,040 --> 00:11:44,429
the user to enter we have stories from

00:11:40,529 --> 00:11:46,170
over 125,000 sources Bloomberg itself is

00:11:44,429 --> 00:11:48,389
a media company and that's probably one

00:11:46,170 --> 00:11:50,459
of our biggest sources but equally we

00:11:48,389 --> 00:11:52,499
have lots of news coming in from major

00:11:50,459 --> 00:11:54,149
newspapers across the world we have

00:11:52,499 --> 00:11:56,370
tie-ups with various research providers

00:11:54,149 --> 00:11:59,490
who provide us news we have social media

00:11:56,370 --> 00:12:00,959
like from Twitter and the interesting

00:11:59,490 --> 00:12:02,579
aspect of this is that all of these

00:12:00,959 --> 00:12:06,230
sources can be turned on or off per user

00:12:02,579 --> 00:12:08,670
and either as a matter of choice like an

00:12:06,230 --> 00:12:11,790
old school guy I don't want tweets for

00:12:08,670 --> 00:12:14,100
example or just because they may not be

00:12:11,790 --> 00:12:15,600
privy permission for it some of this

00:12:14,100 --> 00:12:17,399
research content especially sort of like

00:12:15,600 --> 00:12:18,720
people put in a fair amount of effort to

00:12:17,399 --> 00:12:19,740
produce a research content and they

00:12:18,720 --> 00:12:22,379
obviously don't want to share with

00:12:19,740 --> 00:12:25,589
everyone we thought them paying for so

00:12:22,379 --> 00:12:26,990
we have AC else which can have few many

00:12:25,589 --> 00:12:29,339
are all users for each of these sources

00:12:26,990 --> 00:12:32,309
we have such as in stories in 40

00:12:29,339 --> 00:12:33,629
languages one great thing about solar

00:12:32,309 --> 00:12:37,019
lucene is that it often comes up with

00:12:33,629 --> 00:12:39,439
very good analysis chains or ways to

00:12:37,019 --> 00:12:43,740
sort of like tokenize these languages

00:12:39,439 --> 00:12:46,049
but especially in the sort of like as we

00:12:43,740 --> 00:12:47,279
went through to production ization every

00:12:46,049 --> 00:12:48,600
use case is different and that's what

00:12:47,279 --> 00:12:51,119
you typically realizing a search engine

00:12:48,600 --> 00:12:53,129
the way we interpret Chinese is not

00:12:51,119 --> 00:12:55,769
exactly the way Chinese solar interprets

00:12:53,129 --> 00:12:58,110
Chinese and so on and then that happens

00:12:55,769 --> 00:12:59,639
for everyone all these languages any

00:12:58,110 --> 00:13:01,199
user can have a subset of the selected

00:12:59,639 --> 00:13:03,030
at any point of time so you need to be

00:13:01,199 --> 00:13:07,770
able to accommodate for multiple

00:13:03,030 --> 00:13:09,330
languages how we do this we have a new

00:13:07,770 --> 00:13:11,640
search cloud which has lots of Linux

00:13:09,330 --> 00:13:14,460
machines hosting hundreds of shards

00:13:11,640 --> 00:13:16,680
thousands of solar course there are

00:13:14,460 --> 00:13:18,450
multiple tiers this especially helps in

00:13:16,680 --> 00:13:21,720
case of news because news tends to focus

00:13:18,450 --> 00:13:23,880
a lot on the recent stories so you have

00:13:21,720 --> 00:13:25,710
a recent collection which which we try

00:13:23,880 --> 00:13:27,480
to use first if that doesn't work out

00:13:25,710 --> 00:13:29,880
then we use a fuller collection which is

00:13:27,480 --> 00:13:32,430
likely slower cross data center

00:13:29,880 --> 00:13:34,230
redundancy obviously for stability

00:13:32,430 --> 00:13:36,360
reasons which is quite interesting rumor

00:13:34,230 --> 00:13:38,280
solar point of view because doesn't as

00:13:36,360 --> 00:13:43,500
yet natively support crowd datacenter

00:13:38,280 --> 00:13:44,310
and also there are there at any given

00:13:43,500 --> 00:13:46,830
point of time you could have multiple

00:13:44,310 --> 00:13:48,750
generations of collections as I said one

00:13:46,830 --> 00:13:51,090
of the important aspects of this

00:13:48,750 --> 00:13:53,130
redesign is to allow for easy addition

00:13:51,090 --> 00:13:55,050
of metadata and sometimes let's say you

00:13:53,130 --> 00:13:57,300
make a major analysis change you have to

00:13:55,050 --> 00:13:59,490
reindex all the data so you often end up

00:13:57,300 --> 00:14:01,980
with multiple generations of the same

00:13:59,490 --> 00:14:05,100
data coexisting and trying to sort of

00:14:01,980 --> 00:14:06,390
phase one out of the other as I

00:14:05,100 --> 00:14:07,980
mentioned previously stories are

00:14:06,390 --> 00:14:10,650
available for search in 125 milliseconds

00:14:07,980 --> 00:14:13,110
so caching almost doesn't make sense in

00:14:10,650 --> 00:14:15,150
the way sort of you typically expect it

00:14:13,110 --> 00:14:16,740
from a solar or leucine level there is

00:14:15,150 --> 00:14:18,150
obviously lots of caching that happens

00:14:16,740 --> 00:14:20,940
to the OS level and we depend a lot on

00:14:18,150 --> 00:14:22,830
it but there is almost very little

00:14:20,940 --> 00:14:24,960
caching on top of it because kind of

00:14:22,830 --> 00:14:29,250
pointless by the time you start using

00:14:24,960 --> 00:14:30,960
the cash it's gone anyway we have custom

00:14:29,250 --> 00:14:32,460
cumference for almost everything and I

00:14:30,960 --> 00:14:34,620
think this is what you would expect from

00:14:32,460 --> 00:14:37,380
a major installation in any case for

00:14:34,620 --> 00:14:39,440
parsing for indexing for searching for

00:14:37,380 --> 00:14:43,620
for privileged view suppose filtering

00:14:39,440 --> 00:14:46,380
some of this I'll go a bit go a go bit

00:14:43,620 --> 00:14:50,340
more in depth but almost everything is

00:14:46,380 --> 00:14:53,310
customized to some extent here so that's

00:14:50,340 --> 00:14:56,520
a story so in the order in which i

00:14:53,310 --> 00:14:58,050
described first making it work a couple

00:14:56,520 --> 00:14:58,890
of interesting examples over there and

00:14:58,050 --> 00:15:00,120
the way I'm going to structure this

00:14:58,890 --> 00:15:02,580
presentation is I'm just going to give

00:15:00,120 --> 00:15:04,440
lots and lots of examples so feel free

00:15:02,580 --> 00:15:06,030
to come back to me towards end of this

00:15:04,440 --> 00:15:09,180
talk or when we have time for questions

00:15:06,030 --> 00:15:10,590
more on what exactly are sort of the

00:15:09,180 --> 00:15:11,940
more interesting details in this I'm

00:15:10,590 --> 00:15:14,280
just going to go through sort of one

00:15:11,940 --> 00:15:16,310
after their kind of challenges in in the

00:15:14,280 --> 00:15:18,770
almost almost like a worse

00:15:16,310 --> 00:15:20,810
retelling in some sort so the first

00:15:18,770 --> 00:15:22,160
thing is to make it work right and a big

00:15:20,810 --> 00:15:24,529
aspect of that is to power search

00:15:22,160 --> 00:15:26,300
queries in particular we have an

00:15:24,529 --> 00:15:27,410
in-house search syntax if you recall I

00:15:26,300 --> 00:15:31,040
mentioned that people have the ability

00:15:27,410 --> 00:15:33,700
to provide search queries in in a

00:15:31,040 --> 00:15:36,410
full-fledged boolean expression syntax

00:15:33,700 --> 00:15:38,750
we need to validate and privileged tags

00:15:36,410 --> 00:15:40,790
based on databases we have outside solar

00:15:38,750 --> 00:15:42,529
we need to present part of the search

00:15:40,790 --> 00:15:44,210
query in the UI even with the person

00:15:42,529 --> 00:15:46,070
specifies the you are in that native

00:15:44,210 --> 00:15:47,750
format or the or the expressive format

00:15:46,070 --> 00:15:50,690
you need to break it down and some

00:15:47,750 --> 00:15:54,230
present the search query in in a more

00:15:50,690 --> 00:15:56,810
sort of like you I friendly fashion if

00:15:54,230 --> 00:15:58,279
you will and sometimes you need to

00:15:56,810 --> 00:16:01,700
understand the query to do other things

00:15:58,279 --> 00:16:03,070
on top of the search itself a very

00:16:01,700 --> 00:16:05,779
interesting example is that we often

00:16:03,070 --> 00:16:07,760
modify the base set of sources you're

00:16:05,779 --> 00:16:09,770
getting news from or the set of sources

00:16:07,760 --> 00:16:12,980
we consider the most important depending

00:16:09,770 --> 00:16:15,170
on the query because obviously some

00:16:12,980 --> 00:16:17,330
sources have better information about

00:16:15,170 --> 00:16:21,650
some topics than others so you need to

00:16:17,330 --> 00:16:22,940
often customize how you do it so one

00:16:21,650 --> 00:16:24,950
thing we did to in order to accommodate

00:16:22,940 --> 00:16:27,530
all of this is that we decided quite

00:16:24,950 --> 00:16:29,660
early on that it's not going to help us

00:16:27,530 --> 00:16:33,860
if we try to push all this complexity to

00:16:29,660 --> 00:16:35,330
solar so we went for a there was this

00:16:33,860 --> 00:16:37,970
very old ticket which was trying to

00:16:35,330 --> 00:16:40,070
represent the solar query in an XML

00:16:37,970 --> 00:16:42,470
format and I say XML you can be semi

00:16:40,070 --> 00:16:44,360
structured not a big fan of XML myself

00:16:42,470 --> 00:16:47,360
pretty would have any many in this blue

00:16:44,360 --> 00:16:49,339
mood agree perhaps but the key part is

00:16:47,360 --> 00:16:51,770
that is it's it's semi structured and

00:16:49,339 --> 00:16:53,210
almost very little happens on the solar

00:16:51,770 --> 00:16:56,390
side before it actually goes to the

00:16:53,210 --> 00:16:59,180
lucille and so we construct the query

00:16:56,390 --> 00:17:00,860
well in advance and solar just

00:16:59,180 --> 00:17:02,630
reinterprets that pretty much and

00:17:00,860 --> 00:17:05,600
constructs a query object in losing

00:17:02,630 --> 00:17:08,390
terms so you get through from outside

00:17:05,600 --> 00:17:10,760
solar to a query object which is getting

00:17:08,390 --> 00:17:12,740
searched on with minimal translation

00:17:10,760 --> 00:17:15,290
some translation still needs to be done

00:17:12,740 --> 00:17:17,480
a very good example is when you specify

00:17:15,290 --> 00:17:19,429
a keyword that needs to be tokenized and

00:17:17,480 --> 00:17:21,140
broken down and that's important and

00:17:19,429 --> 00:17:23,670
that only solar can do because it don't

00:17:21,140 --> 00:17:26,700
understand the schema

00:17:23,670 --> 00:17:29,100
but the idea is that you allow as much

00:17:26,700 --> 00:17:31,850
flexibility as possible so that you can

00:17:29,100 --> 00:17:34,590
control the carina tighter fashion and

00:17:31,850 --> 00:17:35,870
it has served as well in many cases as I

00:17:34,590 --> 00:17:37,650
shall describe in the next few slides

00:17:35,870 --> 00:17:39,690
sometimes you had to do a lot of

00:17:37,650 --> 00:17:42,960
optimizations which often means that we

00:17:39,690 --> 00:17:44,460
create new query types at Lucy level and

00:17:42,960 --> 00:17:47,010
it was it was going to be a pain if we

00:17:44,460 --> 00:17:49,410
start exposing all of that in a in a

00:17:47,010 --> 00:17:52,590
query parser what this allows us to do

00:17:49,410 --> 00:17:54,990
is that I can just get a builder for the

00:17:52,590 --> 00:17:56,930
class and then specify it with the

00:17:54,990 --> 00:17:59,340
arguments for the query straightaway

00:17:56,930 --> 00:18:02,850
sometimes we needed to originally at

00:17:59,340 --> 00:18:07,230
least use a fork version of solar this

00:18:02,850 --> 00:18:10,950
is a for called flax search allenwood

00:18:07,230 --> 00:18:12,810
bodies around if you can find him used

00:18:10,950 --> 00:18:15,300
to have a fork of solar consoler

00:18:12,810 --> 00:18:17,160
intervals which actually helped us with

00:18:15,300 --> 00:18:18,570
some of the functionality which was not

00:18:17,160 --> 00:18:21,210
present at the solar originally started

00:18:18,570 --> 00:18:22,950
it we actually work with him later on to

00:18:21,210 --> 00:18:26,460
get that upstream with 5.3 that's no

00:18:22,950 --> 00:18:28,050
longer the case but in some cases we

00:18:26,460 --> 00:18:30,330
used a folk version of leucine to get

00:18:28,050 --> 00:18:31,560
additional query capabilities like kind

00:18:30,330 --> 00:18:34,680
of something like this right i mean you

00:18:31,560 --> 00:18:38,370
have you have a phrase expression with

00:18:34,680 --> 00:18:40,110
the near query nested near queries some

00:18:38,370 --> 00:18:46,020
of this earlier versions of leucine were

00:18:40,110 --> 00:18:48,780
not able to work with the next challenge

00:18:46,020 --> 00:18:50,340
was obviously i mentioned that we had we

00:18:48,780 --> 00:18:53,580
have a classification system which tries

00:18:50,340 --> 00:18:55,230
to find out tags a very interesting idea

00:18:53,580 --> 00:18:57,930
with this classification system is that

00:18:55,230 --> 00:18:59,130
it has a built in relevant score

00:18:57,930 --> 00:19:01,200
associated with it it gives you a

00:18:59,130 --> 00:19:03,840
confidence of if i say the story is

00:19:01,200 --> 00:19:05,520
about oil it's seventy percent i'm

00:19:03,840 --> 00:19:07,140
seventy percent confidence about oil or

00:19:05,520 --> 00:19:11,490
ninety-five percent confident about it's

00:19:07,140 --> 00:19:13,110
a toy each jury has topics companies

00:19:11,490 --> 00:19:15,030
regions people attack with it it has

00:19:13,110 --> 00:19:16,560
each one of them has a relevance there

00:19:15,030 --> 00:19:19,560
are multiple tags depressing pastori

00:19:16,560 --> 00:19:21,090
millions overall and the tag relevance

00:19:19,560 --> 00:19:23,490
needed to be considered for both scoring

00:19:21,090 --> 00:19:25,170
and filtering if you are scoring search

00:19:23,490 --> 00:19:26,850
results he wants if and if you ask for

00:19:25,170 --> 00:19:28,290
are you you obviously want something you

00:19:26,850 --> 00:19:30,990
have more confidence it's about oil to

00:19:28,290 --> 00:19:33,600
float up to the top you sometimes use it

00:19:30,990 --> 00:19:35,250
for filtering when you try to display

00:19:33,600 --> 00:19:36,360
the Sultan chronological order as well I

00:19:35,250 --> 00:19:37,890
want

00:19:36,360 --> 00:19:40,710
in chronological order but I want to

00:19:37,890 --> 00:19:42,390
restrict my results to only those which

00:19:40,710 --> 00:19:44,670
have oil at a very high relevance I'm

00:19:42,390 --> 00:19:46,590
pretty sure so I don't want my feed

00:19:44,670 --> 00:19:49,650
cluttered with stories which may be or

00:19:46,590 --> 00:19:51,059
may not be here before you so one very

00:19:49,650 --> 00:19:52,500
interesting challenge was how do we

00:19:51,059 --> 00:19:55,170
build this infrastructure in a scalable

00:19:52,500 --> 00:19:57,929
way as well as allow for normalizing

00:19:55,170 --> 00:20:01,620
relevance like for example if I have

00:19:57,929 --> 00:20:03,390
keywords Obamacare or topic health right

00:20:01,620 --> 00:20:06,270
one is a topic there is a keyword how do

00:20:03,390 --> 00:20:08,010
you normalize this course one thing we

00:20:06,270 --> 00:20:10,770
did was to repurpose keyword ranking for

00:20:08,010 --> 00:20:12,929
these tags pretty much use or tf-idf or

00:20:10,770 --> 00:20:16,080
in the future if you come up with a

00:20:12,929 --> 00:20:17,940
different ranking use that instead for

00:20:16,080 --> 00:20:20,850
tags as much as keywords and that allows

00:20:17,940 --> 00:20:22,620
us to normalize and we can also modify

00:20:20,850 --> 00:20:25,080
search is to be filtered based on ninjas

00:20:22,620 --> 00:20:27,150
of these tf-idf scores so as far as the

00:20:25,080 --> 00:20:29,280
system sees it it sees 70 occurrences of

00:20:27,150 --> 00:20:31,020
the topic oil and there's a seventy

00:20:29,280 --> 00:20:38,010
percent confidence or somewhat like that

00:20:31,020 --> 00:20:41,250
with a logical scale so that's as far as

00:20:38,010 --> 00:20:45,120
the getting stuff to work I'm so long as

00:20:41,250 --> 00:20:46,980
I mentioned earlier much of the the job

00:20:45,120 --> 00:20:48,720
here is to optimize it when we initially

00:20:46,980 --> 00:20:50,309
started off and we had the initial

00:20:48,720 --> 00:20:52,350
prototype when you try to push the full

00:20:50,309 --> 00:20:54,929
load through it if you up nothing came

00:20:52,350 --> 00:20:56,040
up we did a few optimizations to the

00:20:54,929 --> 00:20:58,890
point where they at least wouldn't blow

00:20:56,040 --> 00:21:02,460
up and we started seeing mean times over

00:20:58,890 --> 00:21:10,169
130 plus seconds which is nowhere near 1

00:21:02,460 --> 00:21:11,910
80 milliseconds on me so I saw the very

00:21:10,169 --> 00:21:13,950
interesting examples here is to do with

00:21:11,910 --> 00:21:15,450
Nicolas searching as I described you

00:21:13,950 --> 00:21:17,610
have like a huge list of companies

00:21:15,450 --> 00:21:19,080
you're trying to search on in the knife

00:21:17,610 --> 00:21:21,690
fashion you can do pretty much something

00:21:19,080 --> 00:21:24,360
like a boolean of thousand ours and the

00:21:21,690 --> 00:21:26,280
challenge here was that the default

00:21:24,360 --> 00:21:29,070
setting was such that the company had

00:21:26,280 --> 00:21:31,350
had a relevance filter set so it was not

00:21:29,070 --> 00:21:33,929
just a term query on a company it was

00:21:31,350 --> 00:21:36,120
actually a tuncurry wrapped around a

00:21:33,929 --> 00:21:39,929
check of what the term frequency range

00:21:36,120 --> 00:21:41,880
was and that with thousands of them so

00:21:39,929 --> 00:21:43,770
we went through a series of steps to

00:21:41,880 --> 00:21:45,690
essentially condense this more and more

00:21:43,770 --> 00:21:47,220
and finally get it to a place where this

00:21:45,690 --> 00:21:49,549
entire thing can be represented by one

00:21:47,220 --> 00:21:51,139
query and we

00:21:49,549 --> 00:21:53,629
as much of the complexity down to the

00:21:51,139 --> 00:21:55,519
lowest level possible and that gives us

00:21:53,629 --> 00:21:57,889
a few orders of magnitude in terms of

00:21:55,519 --> 00:22:00,110
benefit just in terms of this is a very

00:21:57,889 --> 00:22:02,419
good example in which I optimized a

00:22:00,110 --> 00:22:04,369
particular leucine query for the use

00:22:02,419 --> 00:22:07,129
case and got a very good benefit out of

00:22:04,369 --> 00:22:10,009
it and another example for this is

00:22:07,129 --> 00:22:11,419
essentially we have as I mentioned a big

00:22:10,009 --> 00:22:13,759
user base which is also interested in

00:22:11,419 --> 00:22:15,739
searching by time this is feature which

00:22:13,759 --> 00:22:18,710
came on a quite a while back in lucene

00:22:15,739 --> 00:22:20,389
about a sorting index segments by time

00:22:18,710 --> 00:22:22,669
so that you can optimize searches by

00:22:20,389 --> 00:22:24,739
time as well but there was support

00:22:22,669 --> 00:22:27,289
missing on solar side so we went ahead

00:22:24,739 --> 00:22:29,119
and implemented it and we factored a few

00:22:27,289 --> 00:22:33,049
things just so a solar to be able to use

00:22:29,119 --> 00:22:35,090
that properly so there's some changes

00:22:33,049 --> 00:22:37,700
like this which are more at the query

00:22:35,090 --> 00:22:40,639
level which try to optimize the

00:22:37,700 --> 00:22:42,080
performance there are others which are

00:22:40,639 --> 00:22:44,239
at a different level in terms of what

00:22:42,080 --> 00:22:45,529
the hardware we have goes without saying

00:22:44,239 --> 00:22:47,239
for the kind of scale that you want you

00:22:45,529 --> 00:22:50,539
need lots of SSDs you can't depend on

00:22:47,239 --> 00:22:52,940
spinny disk but there is a fair amount

00:22:50,539 --> 00:22:55,609
of tuning you can do on top of what

00:22:52,940 --> 00:22:58,970
lucene gives by default in terms of how

00:22:55,609 --> 00:23:00,739
aggressive your much policy is and this

00:22:58,970 --> 00:23:03,409
is probably one thing which is often

00:23:00,739 --> 00:23:04,609
overlooked by a lot of people you can

00:23:03,409 --> 00:23:07,909
never sort of underestimate the value

00:23:04,609 --> 00:23:09,859
that kind of tuning gives you you often

00:23:07,909 --> 00:23:11,419
can end up sort of especially if you

00:23:09,859 --> 00:23:13,220
have direct really good SSDs there's a

00:23:11,419 --> 00:23:15,350
lot you can do to just tax your system

00:23:13,220 --> 00:23:18,619
more and more try to aggressively merge

00:23:15,350 --> 00:23:19,879
segments together so that you can get a

00:23:18,619 --> 00:23:25,159
lot more out of your necessities but

00:23:19,879 --> 00:23:27,590
make you such as faster kind of skipping

00:23:25,159 --> 00:23:29,269
our few details here of if you need more

00:23:27,590 --> 00:23:34,009
details on this like please feel to

00:23:29,269 --> 00:23:35,749
research it to be later so we went past

00:23:34,009 --> 00:23:37,519
that phase and we get got to a point

00:23:35,749 --> 00:23:39,859
where we optimized as much as we could

00:23:37,519 --> 00:23:41,570
to the extent we could and realize that

00:23:39,859 --> 00:23:44,869
a lot of the bottlenecks were going down

00:23:41,570 --> 00:23:46,249
to the Java level right searchers would

00:23:44,869 --> 00:23:47,749
work out fast you till you reach a point

00:23:46,249 --> 00:23:50,330
where it had a garbage collection

00:23:47,749 --> 00:23:52,639
collect and for the kind of real-time

00:23:50,330 --> 00:23:54,109
latency requirements we had there's lot

00:23:52,639 --> 00:23:56,090
of stuff happening in the indexing side

00:23:54,109 --> 00:23:57,529
as well and you will end up with garbage

00:23:56,090 --> 00:23:59,389
collection process for eight seconds

00:23:57,529 --> 00:24:02,630
kind of pointless having your search

00:23:59,389 --> 00:24:03,890
come down to less than 100

00:24:02,630 --> 00:24:06,200
seconds if you have to sometimes tall

00:24:03,890 --> 00:24:07,970
for eight seconds so lot you can do to

00:24:06,200 --> 00:24:10,130
essentially sort of optimize it small

00:24:07,970 --> 00:24:13,250
inefficiencies multiplied scale that

00:24:10,130 --> 00:24:15,830
that I think it's it's pretty

00:24:13,250 --> 00:24:17,180
underappreciated you often sometimes

00:24:15,830 --> 00:24:19,220
need to know what the colonel is doing

00:24:17,180 --> 00:24:20,780
as well watch by the time is spent

00:24:19,220 --> 00:24:23,420
sometimes you can end up with the place

00:24:20,780 --> 00:24:24,710
where you think you're you're you keep

00:24:23,420 --> 00:24:26,450
trying to optimize your query then you

00:24:24,710 --> 00:24:27,800
realize that the query is actually fast

00:24:26,450 --> 00:24:30,110
that you're not funneling enough through

00:24:27,800 --> 00:24:32,270
it you might realize that there might be

00:24:30,110 --> 00:24:34,130
there's some hard-coded number right in

00:24:32,270 --> 00:24:35,720
the code which is actually limiting it's

00:24:34,130 --> 00:24:37,570
like some person at some point that like

00:24:35,720 --> 00:24:41,600
who would need more than 20 of these

00:24:37,570 --> 00:24:43,310
guess what we need it so you you have to

00:24:41,600 --> 00:24:44,960
often go through that analysis to find

00:24:43,310 --> 00:24:46,580
out where that hard coded number is or

00:24:44,960 --> 00:24:48,950
where that bottleneck is before you come

00:24:46,580 --> 00:24:50,960
up and goes without saying and this is

00:24:48,950 --> 00:24:52,310
more to as operational side you all you

00:24:50,960 --> 00:24:53,840
also need to do a fair amount of

00:24:52,310 --> 00:24:56,060
instrumenting along the way so that you

00:24:53,840 --> 00:24:58,040
can find that number right we were a

00:24:56,060 --> 00:24:59,420
very interesting place where how many if

00:24:58,040 --> 00:25:03,170
you guys have used ye AR Kait this a

00:24:59,420 --> 00:25:04,670
profiler which is pretty common so the

00:25:03,170 --> 00:25:06,620
first challenge we had with your kid was

00:25:04,670 --> 00:25:10,190
that you start run at two seconds solar

00:25:06,620 --> 00:25:11,930
would die just like that because there

00:25:10,190 --> 00:25:13,370
are their challenges to using something

00:25:11,930 --> 00:25:15,290
as intrusive as that even with the

00:25:13,370 --> 00:25:17,090
minimal options turned on so you often

00:25:15,290 --> 00:25:18,800
have to sort of like building real code

00:25:17,090 --> 00:25:21,460
instrumentation not rely on a profiler

00:25:18,800 --> 00:25:23,150
to sometimes give you insights at scale

00:25:21,460 --> 00:25:24,710
sometimes there is no longer true

00:25:23,150 --> 00:25:27,920
thankfully I mean we once found the case

00:25:24,710 --> 00:25:30,350
where jetty had a bug which would

00:25:27,920 --> 00:25:32,330
sometimes stall and cause a timeout

00:25:30,350 --> 00:25:34,570
Ramsay in my team is over here he spent

00:25:32,330 --> 00:25:37,490
a few months trying to nail that down

00:25:34,570 --> 00:25:38,690
and it turns out that jetty had a race

00:25:37,490 --> 00:25:41,150
condition which used to trigger

00:25:38,690 --> 00:25:43,820
thankfully again it's not there with JT

00:25:41,150 --> 00:25:46,180
nine which would cause request to just

00:25:43,820 --> 00:25:48,560
wait for the entire time out and install

00:25:46,180 --> 00:25:49,880
again kind of pointless optimizing if

00:25:48,560 --> 00:25:56,060
you had wait for 50 seconds on a race

00:25:49,880 --> 00:25:57,200
condition sometimes going beyond so we

00:25:56,060 --> 00:25:59,930
got it to a place where it is fast

00:25:57,200 --> 00:26:02,300
enough now you need to do scale things

00:25:59,930 --> 00:26:03,680
on the on the you need to make things

00:26:02,300 --> 00:26:05,960
more stable one of our biggest

00:26:03,680 --> 00:26:08,920
challenges was to make this stable

00:26:05,960 --> 00:26:11,600
across maintenance machine maintenance

00:26:08,920 --> 00:26:13,100
we often have during weekend sort of

00:26:11,600 --> 00:26:15,170
like machines going undergoing regular

00:26:13,100 --> 00:26:16,310
maintenance and hundreds of course

00:26:15,170 --> 00:26:17,690
essentially a

00:26:16,310 --> 00:26:19,400
around a quarter to one-sixth of the

00:26:17,690 --> 00:26:22,610
system going down for maintenance and

00:26:19,400 --> 00:26:24,380
coming back up and those are places

00:26:22,610 --> 00:26:26,420
where the distributed coordination of a

00:26:24,380 --> 00:26:29,180
system as large as this starts getting

00:26:26,420 --> 00:26:30,710
tested there's still lots of work going

00:26:29,180 --> 00:26:32,180
on still there's a lot of work needed on

00:26:30,710 --> 00:26:33,530
scaling what is called the cluster state

00:26:32,180 --> 00:26:36,730
which holds the entire solar clock

00:26:33,530 --> 00:26:39,050
together but you often find out that

00:26:36,730 --> 00:26:41,000
these are things we need to scale and

00:26:39,050 --> 00:26:42,770
you find out only at a scale where you

00:26:41,000 --> 00:26:46,360
have like hundreds of shots thousands of

00:26:42,770 --> 00:26:49,940
course that things start sort of

00:26:46,360 --> 00:26:53,300
developing cracks if you were notified

00:26:49,940 --> 00:26:55,340
wise never sort of try to scalar I mean

00:26:53,300 --> 00:26:57,230
not never but be very careful when

00:26:55,340 --> 00:27:00,050
trying to scale a solo cloud be 1000

00:26:57,230 --> 00:27:03,050
2500 notes that has been our breaking

00:27:00,050 --> 00:27:04,640
point and you know what the breaking

00:27:03,050 --> 00:27:08,540
point is in what's the cross by just

00:27:04,640 --> 00:27:11,570
needs work in many cases it's just an

00:27:08,540 --> 00:27:13,400
old-fashioned sort of you shouldn't have

00:27:11,570 --> 00:27:15,620
all your leaders be present in the same

00:27:13,400 --> 00:27:17,690
place because it just tends to tax the

00:27:15,620 --> 00:27:19,250
machine out so in some cases you just

00:27:17,690 --> 00:27:22,790
said leave algorithmic improvements you

00:27:19,250 --> 00:27:24,170
sort of help scale things better in the

00:27:22,790 --> 00:27:26,000
other more challenging thing has been

00:27:24,170 --> 00:27:28,400
that when something goes down comes back

00:27:26,000 --> 00:27:29,960
up it tries to recover you shouldn't

00:27:28,400 --> 00:27:31,280
have that effect live traffic or worse

00:27:29,960 --> 00:27:33,290
it shouldn't affect cloud stability we

00:27:31,280 --> 00:27:35,480
had cases where something would saturate

00:27:33,290 --> 00:27:37,250
network performance that when that in

00:27:35,480 --> 00:27:41,000
turn would affect other traffic which is

00:27:37,250 --> 00:27:43,130
more critical on the machine and lead

00:27:41,000 --> 00:27:44,840
the entire cloud to disaster in some

00:27:43,130 --> 00:27:47,030
cases you can throttle not the greatest

00:27:44,840 --> 00:27:49,610
of solutions but because your startup

00:27:47,030 --> 00:27:51,590
takes longer but works we actually

00:27:49,610 --> 00:27:53,720
recently moved to it if using a

00:27:51,590 --> 00:27:55,070
different network for this entirely so

00:27:53,720 --> 00:27:57,530
right at the network level we use a

00:27:55,070 --> 00:27:59,180
different network interface that that

00:27:57,530 --> 00:28:00,710
needed some interesting changes on the

00:27:59,180 --> 00:28:02,120
solar side which we are still working on

00:28:00,710 --> 00:28:05,360
but we at least have a solution for

00:28:02,120 --> 00:28:07,130
ourselves at this point using

00:28:05,360 --> 00:28:09,410
transaction log recovery stories those

00:28:07,130 --> 00:28:12,020
two kinds of recovery is possible of you

00:28:09,410 --> 00:28:14,030
you can tune this now and this is one of

00:28:12,020 --> 00:28:16,580
the changes we had to do so that you try

00:28:14,030 --> 00:28:18,530
to avoid copying full parts of the

00:28:16,580 --> 00:28:20,960
indexes to from one machine to another

00:28:18,530 --> 00:28:23,710
and try to do as little as possible in

00:28:20,960 --> 00:28:23,710
terms of recovering

00:28:24,760 --> 00:28:31,039
but there will be problems in particular

00:28:29,120 --> 00:28:34,130
I think we started from a place where

00:28:31,039 --> 00:28:36,409
the solar collection with we had had

00:28:34,130 --> 00:28:39,919
like eight shots and we kept doubling it

00:28:36,409 --> 00:28:41,210
up and we we figured out that each time

00:28:39,919 --> 00:28:43,010
we double the number of shots we would

00:28:41,210 --> 00:28:44,240
find a new race condition right it's

00:28:43,010 --> 00:28:46,580
almost the race condition of the

00:28:44,240 --> 00:28:49,370
iteration on what sometimes multiple of

00:28:46,580 --> 00:28:51,710
them good news is that you don't have to

00:28:49,370 --> 00:28:53,210
deal with this now I think we started at

00:28:51,710 --> 00:28:54,770
a place where solar was a lot less

00:28:53,210 --> 00:28:57,590
stable with these things lots of work

00:28:54,770 --> 00:28:58,789
has gone from our side from others in

00:28:57,590 --> 00:29:00,080
the solar community as well there's lots

00:28:58,789 --> 00:29:03,289
and lots of work which is gone into

00:29:00,080 --> 00:29:05,480
making things more stable the nice thing

00:29:03,289 --> 00:29:07,280
here is that well nice depending on how

00:29:05,480 --> 00:29:09,049
you look at it if there is a dazed

00:29:07,280 --> 00:29:13,039
condition we will hit it right it's just

00:29:09,049 --> 00:29:14,750
a matter of time what happens is it safe

00:29:13,039 --> 00:29:16,580
to stop multiple replicas of a shard

00:29:14,750 --> 00:29:18,650
simultaneously you'd of thought so but

00:29:16,580 --> 00:29:20,630
there is a race condition what happens

00:29:18,650 --> 00:29:22,340
if you shut down just when the lucene

00:29:20,630 --> 00:29:24,230
indexes in the middle of a merge and the

00:29:22,340 --> 00:29:26,659
shutdown takes just a little bit longer

00:29:24,230 --> 00:29:29,510
or little bit less and that triggers

00:29:26,659 --> 00:29:30,919
race condition what is this a delhi by

00:29:29,510 --> 00:29:32,929
query happening just around when a

00:29:30,919 --> 00:29:34,549
leadership switches and then there's a

00:29:32,929 --> 00:29:37,429
recovery which tries to deal with the

00:29:34,549 --> 00:29:39,440
delete by prairie and that ends up

00:29:37,429 --> 00:29:40,970
stalling the recovery process by just

00:29:39,440 --> 00:29:42,799
the right amount of time to delay

00:29:40,970 --> 00:29:44,750
leadership transfer and you start

00:29:42,799 --> 00:29:47,900
getting time modes all of this as like a

00:29:44,750 --> 00:29:49,100
file line step process leading from one

00:29:47,900 --> 00:29:51,280
leading to the other two leading to the

00:29:49,100 --> 00:29:54,590
leading to it finally to a disaster so

00:29:51,280 --> 00:29:55,970
and the funny bit is that even if I to

00:29:54,590 --> 00:29:57,289
screw up yet to be controlled about one

00:29:55,970 --> 00:29:59,720
of our changes was actually to make

00:29:57,289 --> 00:30:02,059
checks for misbehaving machine each

00:29:59,720 --> 00:30:03,799
light there was a case where there was a

00:30:02,059 --> 00:30:05,299
machine which is underperforming all the

00:30:03,799 --> 00:30:08,390
thousand course I'd asking hey are you

00:30:05,299 --> 00:30:09,830
healthy can you talk to you again yes if

00:30:08,390 --> 00:30:18,350
you hadn't asked me I would have been

00:30:09,830 --> 00:30:20,210
healthy so if there's a network

00:30:18,350 --> 00:30:21,679
partition that's the reality of life

00:30:20,210 --> 00:30:23,659
right i mean like network partitions

00:30:21,679 --> 00:30:26,020
happen will the cloud always heal it

00:30:23,659 --> 00:30:30,020
should it should it's always it should

00:30:26,020 --> 00:30:32,299
it doesn't sometimes as with realize

00:30:30,020 --> 00:30:34,399
sometimes democracy can be annoying when

00:30:32,299 --> 00:30:35,899
you have leadership elections which kind

00:30:34,399 --> 00:30:36,509
of say that i have to be elected

00:30:35,899 --> 00:30:39,179
democratic

00:30:36,509 --> 00:30:41,369
I can't have a dictator you'll end up

00:30:39,179 --> 00:30:46,079
going around in circles sometimes one

00:30:41,369 --> 00:30:48,539
trying to like the other sometimes the

00:30:46,079 --> 00:30:50,219
problem is not to do with so much with a

00:30:48,539 --> 00:30:52,379
systemic problem but a small problem

00:30:50,219 --> 00:30:54,089
which can blow over one of the things

00:30:52,379 --> 00:30:56,489
with infinite query flexibility is that

00:30:54,089 --> 00:30:58,409
you can have poisonous queries I can

00:30:56,489 --> 00:31:00,149
tell you my experience that no good can

00:30:58,409 --> 00:31:04,099
come out with phrases wild cards and

00:31:00,149 --> 00:31:06,149
spans indexes you gotta trust me on this

00:31:04,099 --> 00:31:07,859
people who try to do things right i mean

00:31:06,149 --> 00:31:09,599
like why don't take copy paste an entire

00:31:07,859 --> 00:31:10,979
excerpt i have into the search field so

00:31:09,599 --> 00:31:13,319
that i can find the article that you

00:31:10,979 --> 00:31:14,849
have not a good idea guys search engine

00:31:13,319 --> 00:31:17,759
is there so that you can just put a few

00:31:14,849 --> 00:31:19,169
keywords in or my keyboard has the key

00:31:17,759 --> 00:31:21,149
stuck I can't figure out what to do

00:31:19,169 --> 00:31:23,249
about it I call the IT guy up let me go

00:31:21,149 --> 00:31:26,299
for lunch that thing is sending key

00:31:23,249 --> 00:31:29,609
presses all the time in the background

00:31:26,299 --> 00:31:31,919
solo has better and having made this up

00:31:29,609 --> 00:31:34,559
trust me these these happen these cost

00:31:31,919 --> 00:31:36,949
out teaches solo now has better circuit

00:31:34,559 --> 00:31:41,759
breakers for queries this came with

00:31:36,949 --> 00:31:43,679
around a year or so back which is great

00:31:41,759 --> 00:31:45,690
because you should realize that a long

00:31:43,679 --> 00:31:48,089
query doesn't just have a ability to

00:31:45,690 --> 00:31:50,129
reduce your query bandwidth like you're

00:31:48,089 --> 00:31:52,019
not just taking a thread away you can

00:31:50,129 --> 00:31:54,299
actually take down replicas we have

00:31:52,019 --> 00:31:56,489
taken down replicas because of a 1 batt

00:31:54,299 --> 00:31:58,469
query because it did so much garbage

00:31:56,489 --> 00:32:00,959
collection it created so much garbage

00:31:58,469 --> 00:32:03,499
that garbage collection went through the

00:32:00,959 --> 00:32:06,269
roof and took the entire lip licker down

00:32:03,499 --> 00:32:08,879
so it's great that we have circuit

00:32:06,269 --> 00:32:10,319
breakers but we can't do better so often

00:32:08,879 --> 00:32:12,119
you have to account for a certain amount

00:32:10,319 --> 00:32:15,690
in terms of circuit breakers you that

00:32:12,119 --> 00:32:17,279
might be too late so I mean the dream

00:32:15,690 --> 00:32:19,019
would be and you're starting to work on

00:32:17,279 --> 00:32:21,719
this now to see whether you can have

00:32:19,019 --> 00:32:23,759
statistical query plans for searches and

00:32:21,719 --> 00:32:25,379
try to come up with models which can

00:32:23,759 --> 00:32:27,899
dictate whether research will be slow or

00:32:25,379 --> 00:32:31,469
fast it's a very hard problem but we can

00:32:27,899 --> 00:32:35,339
start taking steps there you can use a

00:32:31,469 --> 00:32:36,749
replica affinity where you often realize

00:32:35,339 --> 00:32:38,489
that people can be very persistent about

00:32:36,749 --> 00:32:40,769
their failed queries right i mean like

00:32:38,489 --> 00:32:42,839
so they've already taken down a replica

00:32:40,769 --> 00:32:44,129
because of their battery they try again

00:32:42,839 --> 00:32:46,619
they try again and you reach a point

00:32:44,129 --> 00:32:48,559
where the system tries to be nice takes

00:32:46,619 --> 00:32:50,659
on the entire cloud for them

00:32:48,559 --> 00:32:52,340
you need to use a replica affinity so

00:32:50,659 --> 00:32:53,779
that that can't happen you need to

00:32:52,340 --> 00:32:58,070
protect the system against one user

00:32:53,779 --> 00:32:59,509
taking down the cloud sometimes even if

00:32:58,070 --> 00:33:02,600
it is systemic failure you need to

00:32:59,509 --> 00:33:05,360
protect one system from the other often

00:33:02,600 --> 00:33:07,220
cases a very common cases where you have

00:33:05,360 --> 00:33:10,340
like a spike of indexing which could

00:33:07,220 --> 00:33:11,840
starve out searching for example is one

00:33:10,340 --> 00:33:13,279
of the things to choose on going in the

00:33:11,840 --> 00:33:14,870
solar community on seeing whether we can

00:33:13,279 --> 00:33:18,009
isolate thread pools for searching and

00:33:14,870 --> 00:33:20,330
indexing we have already worked on

00:33:18,009 --> 00:33:22,519
isolating query Federation so there's a

00:33:20,330 --> 00:33:24,080
solar process which tries to federate

00:33:22,519 --> 00:33:26,360
out a query to multiple nodes gets back

00:33:24,080 --> 00:33:29,240
the results that query doesn't need to

00:33:26,360 --> 00:33:31,879
host data bytes own though it can this

00:33:29,240 --> 00:33:33,470
again helps you to sort of isolate the

00:33:31,879 --> 00:33:35,860
federated use case from the searching

00:33:33,470 --> 00:33:38,539
use case and kuhn for them differently

00:33:35,860 --> 00:33:39,769
isolating critical roles like the

00:33:38,539 --> 00:33:42,980
overseers is something which is present

00:33:39,769 --> 00:33:44,659
in solar overseer is a very critical

00:33:42,980 --> 00:33:46,820
part of the component you can't just

00:33:44,659 --> 00:33:48,200
afford for it to go down so you need to

00:33:46,820 --> 00:33:51,889
put it in a place where there is very

00:33:48,200 --> 00:33:53,029
little risk of it going to the future

00:33:51,889 --> 00:33:55,039
really and this comes back to the query

00:33:53,029 --> 00:33:57,080
plans thing is like isolating costly

00:33:55,039 --> 00:33:58,490
queries from cheap ones so it's not just

00:33:57,080 --> 00:34:00,919
a poisonous way it will just be a costly

00:33:58,490 --> 00:34:04,009
query but you don't want too many costly

00:34:00,919 --> 00:34:06,379
critics taking down the system the other

00:34:04,009 --> 00:34:08,510
angle to this is that it's you often

00:34:06,379 --> 00:34:10,899
sort of like try to make things too

00:34:08,510 --> 00:34:13,339
consistent and that's always a problem

00:34:10,899 --> 00:34:15,020
it's all one happy cloud till garbage

00:34:13,339 --> 00:34:16,579
gets into the input your system is just

00:34:15,020 --> 00:34:19,099
becomes as stable as what your input

00:34:16,579 --> 00:34:20,780
pipeline is and if that input pipeline

00:34:19,099 --> 00:34:22,040
is changing it has a bug you don't want

00:34:20,780 --> 00:34:23,510
a definite system where there is bad

00:34:22,040 --> 00:34:25,609
data everywhere because you have

00:34:23,510 --> 00:34:28,879
successfully managed to replicate it in

00:34:25,609 --> 00:34:30,740
real time so sometimes you need tightly

00:34:28,879 --> 00:34:32,149
coupled replicas and they need multiple

00:34:30,740 --> 00:34:34,399
copies of them which are loosely coupled

00:34:32,149 --> 00:34:36,859
so that you can make changes to the

00:34:34,399 --> 00:34:38,329
input 5921 one of the one of the loosely

00:34:36,859 --> 00:34:41,720
coupled replicas then move to the next

00:34:38,329 --> 00:34:43,700
move to the next and so on the challenge

00:34:41,720 --> 00:34:44,869
is then is trying to meet me in the

00:34:43,700 --> 00:34:46,700
right balance where they are loosely

00:34:44,869 --> 00:34:48,829
coupled but you can still easily

00:34:46,700 --> 00:34:51,500
synchronize them without having to do

00:34:48,829 --> 00:34:53,119
sort of like lots of manual work this is

00:34:51,500 --> 00:34:56,149
something which is which is still pretty

00:34:53,119 --> 00:34:58,310
hard but there is work we are working

00:34:56,149 --> 00:35:02,140
with lucid works and charlaine fear in

00:34:58,310 --> 00:35:06,680
the audience aware a that needs

00:35:02,140 --> 00:35:08,539
he's working on helping us get CDCR

00:35:06,680 --> 00:35:09,529
cross data center application to get to

00:35:08,539 --> 00:35:12,650
a point where it can help the

00:35:09,529 --> 00:35:14,390
synchronization and soon we will be able

00:35:12,650 --> 00:35:19,450
to do this much more ultimate in an

00:35:14,390 --> 00:35:22,670
automated fashion okay we made it stable

00:35:19,450 --> 00:35:24,079
now to make it better one of the things

00:35:22,670 --> 00:35:26,930
which we had to carry over from the old

00:35:24,079 --> 00:35:28,220
system was grouping right you have where

00:35:26,930 --> 00:35:30,079
there's a different part in the pipeline

00:35:28,220 --> 00:35:31,819
which tries to collapse content which

00:35:30,079 --> 00:35:33,259
are which are about the same thing but

00:35:31,819 --> 00:35:35,630
different newspapers are published it

00:35:33,259 --> 00:35:37,339
for example that's great as long as its

00:35:35,630 --> 00:35:38,660
pragmatic the problem with grouping is

00:35:37,339 --> 00:35:40,819
that especially if you have deep pages

00:35:38,660 --> 00:35:42,259
and again we have seen users sometimes

00:35:40,819 --> 00:35:43,700
go to hundreds of pages right I mean

00:35:42,259 --> 00:35:45,559
especially this is that day job they are

00:35:43,700 --> 00:35:49,339
looking through new stories then they do

00:35:45,559 --> 00:35:50,869
tend to go pretty deep on searches but

00:35:49,339 --> 00:35:52,430
the problem with deep aging is that

00:35:50,869 --> 00:35:54,859
especially with grouping there is no

00:35:52,430 --> 00:35:56,480
solution which is available to be more

00:35:54,859 --> 00:35:58,160
pragmatic about it if the search engine

00:35:56,480 --> 00:36:00,049
starts thinking that a result in the

00:35:58,160 --> 00:36:03,200
first page could be grouped with

00:36:00,049 --> 00:36:04,519
something 150 pages later then it has to

00:36:03,200 --> 00:36:06,410
retrieve all the hundred and fifty pages

00:36:04,519 --> 00:36:08,839
of information before it can decide on

00:36:06,410 --> 00:36:10,880
what to return so there's a fair amount

00:36:08,839 --> 00:36:13,180
of work we need to go through to cons

00:36:10,880 --> 00:36:15,470
make it consider window of end results

00:36:13,180 --> 00:36:16,700
for grouping and then deep paging on

00:36:15,470 --> 00:36:20,630
something we haven't contributed back

00:36:16,700 --> 00:36:22,279
but we will eventually one of the big

00:36:20,630 --> 00:36:24,289
corner stores from last year for us has

00:36:22,279 --> 00:36:27,739
been to implement a learning to rank

00:36:24,289 --> 00:36:29,180
framework and solar this is this is this

00:36:27,739 --> 00:36:33,349
is a pretty big effort spanning multiple

00:36:29,180 --> 00:36:35,150
teams that we try to get a standard

00:36:33,349 --> 00:36:37,940
framework wouldn't solar where you can

00:36:35,150 --> 00:36:39,200
define features define models and be

00:36:37,940 --> 00:36:41,809
able to rank results get back feature

00:36:39,200 --> 00:36:44,749
values with responses to train models

00:36:41,809 --> 00:36:46,369
offline this is being is this in the

00:36:44,749 --> 00:36:50,329
past part of being sort of pushed

00:36:46,369 --> 00:36:52,369
upstream there's the going on on trying

00:36:50,329 --> 00:36:53,749
to commit this upstream and if you're

00:36:52,369 --> 00:36:55,670
more interested as an entire talk on

00:36:53,749 --> 00:36:57,650
this film lucid leucine revolution last

00:36:55,670 --> 00:37:01,430
year just search for learning to rank in

00:36:57,650 --> 00:37:03,349
solar and that will take you more lastly

00:37:01,430 --> 00:37:04,940
it's not just useful to show people

00:37:03,349 --> 00:37:07,160
results is also be useful to show them

00:37:04,940 --> 00:37:09,920
what they should be looking for that's

00:37:07,160 --> 00:37:11,989
the trending part of news and what I

00:37:09,920 --> 00:37:13,910
call intelligent faceting so not you

00:37:11,989 --> 00:37:15,230
don't just facet but you be more

00:37:13,910 --> 00:37:15,650
intelligent about what you show up in

00:37:15,230 --> 00:37:19,550
those play

00:37:15,650 --> 00:37:22,430
and this is one part where solar can

00:37:19,550 --> 00:37:24,830
really help the stream document

00:37:22,430 --> 00:37:26,870
frequencies out to a different system

00:37:24,830 --> 00:37:29,960
which can then be used as a trend

00:37:26,870 --> 00:37:34,700
detection pipeline to consume and detect

00:37:29,960 --> 00:37:36,800
anomalies so that's that's what we have

00:37:34,700 --> 00:37:39,500
done so far there's there's still a lot

00:37:36,800 --> 00:37:41,510
going on in the pipeline relevance by

00:37:39,500 --> 00:37:43,880
itself can almost be something we can

00:37:41,510 --> 00:37:45,590
talk on for go on for endlessly rhyming

00:37:43,880 --> 00:37:48,770
you can keep tuning getting better user

00:37:45,590 --> 00:37:50,990
models one challenge has always been

00:37:48,770 --> 00:37:52,640
sort of how you can improve what is

00:37:50,990 --> 00:37:54,290
called information arbitrage when you

00:37:52,640 --> 00:37:56,990
have information in multiple languages

00:37:54,290 --> 00:37:58,340
how do you get that effectively better

00:37:56,990 --> 00:38:00,320
searching across using social media

00:37:58,340 --> 00:38:02,660
social media as many of users of error

00:38:00,320 --> 00:38:04,100
is a separate beast by itself it speaks

00:38:02,660 --> 00:38:07,760
its own language it has its own

00:38:04,100 --> 00:38:10,280
demographic trying to integrate our new

00:38:07,760 --> 00:38:12,620
searches in challenge searching and

00:38:10,280 --> 00:38:14,090
scoring effectively in bulk we often

00:38:12,620 --> 00:38:16,460
have challenges where we need to run

00:38:14,090 --> 00:38:20,240
four thousand searches in bulk in a very

00:38:16,460 --> 00:38:23,150
short amount of time leadership sorted

00:38:20,240 --> 00:38:24,680
views on search self-explanatory we have

00:38:23,150 --> 00:38:26,660
two major use cases to do with sort of

00:38:24,680 --> 00:38:28,670
chronological relevant slack results and

00:38:26,660 --> 00:38:30,830
often a challenge is to see whether we

00:38:28,670 --> 00:38:36,350
can combine those two workflows get them

00:38:30,830 --> 00:38:40,910
to blend better it's pretty much it so

00:38:36,350 --> 00:38:42,920
that's the hope you can see them that's

00:38:40,910 --> 00:38:45,230
the that's the Bloomberg team or a part

00:38:42,920 --> 00:38:46,790
of it which was set loose in solution 20

00:38:45,230 --> 00:38:52,570
or 30 of us working on different aspects

00:38:46,790 --> 00:38:52,570
of solar really the challenges continue

00:39:00,300 --> 00:39:09,520
perfect just a question how do you store

00:39:07,480 --> 00:39:12,490
your user cars and how do you do these

00:39:09,520 --> 00:39:14,920
excess control say say can you vote how

00:39:12,490 --> 00:39:18,160
do you store the user story I the user

00:39:14,920 --> 00:39:20,350
searches and how do you do these access

00:39:18,160 --> 00:39:24,010
control with that it's basically that's

00:39:20,350 --> 00:39:28,840
not one user can can see and destroy

00:39:24,010 --> 00:39:31,150
these searches of others so the users

00:39:28,840 --> 00:39:32,830
queries are stored in sort of like we

00:39:31,150 --> 00:39:35,800
have separate databases is not in solar

00:39:32,830 --> 00:39:37,330
we have separate databases which try to

00:39:35,800 --> 00:39:39,220
sort of partition user queries and

00:39:37,330 --> 00:39:41,380
there's logic around trying to make them

00:39:39,220 --> 00:39:43,000
private to the user so that's nothing

00:39:41,380 --> 00:39:44,650
else or that's that's that's just a

00:39:43,000 --> 00:39:46,960
separate system which is how tenancies

00:39:44,650 --> 00:39:48,280
during these queries as it gets to the

00:39:46,960 --> 00:39:49,780
system it's used in a different ways

00:39:48,280 --> 00:39:51,190
right not so much its search search is

00:39:49,780 --> 00:39:53,920
just one query getting in getting out

00:39:51,190 --> 00:39:55,870
many results but we often need to sort

00:39:53,920 --> 00:39:58,120
of like have in memory representation

00:39:55,870 --> 00:39:59,350
sometimes when we do alerting that's

00:39:58,120 --> 00:40:01,330
something I haven't touched in a lot in

00:39:59,350 --> 00:40:03,160
detail where you try to sort of like

00:40:01,330 --> 00:40:05,590
look at all the queries and then try to

00:40:03,160 --> 00:40:07,300
find out which is there and for a lot of

00:40:05,590 --> 00:40:09,640
this do you also your question privilege

00:40:07,300 --> 00:40:12,040
is embedded at the lowest level so that

00:40:09,640 --> 00:40:14,290
there is no risk of essentially queries

00:40:12,040 --> 00:40:16,450
getting out of the system and other

00:40:14,290 --> 00:40:18,820
users seeing other people's results so

00:40:16,450 --> 00:40:20,290
that's that's a big requirement any of

00:40:18,820 --> 00:40:23,470
these both and such as well as alerting

00:40:20,290 --> 00:40:25,420
is you have the lowest layer in this

00:40:23,470 --> 00:40:38,020
case lucene pretty much handling the

00:40:25,420 --> 00:40:43,150
provision logic using filtering we've

00:40:38,020 --> 00:40:46,960
got to prepare the next talk but thank

00:40:43,150 --> 00:40:49,960
you for your talk do meter data texts

00:40:46,960 --> 00:40:52,840
have relations such as same as broader

00:40:49,960 --> 00:40:56,050
and if so how do you query against these

00:40:52,840 --> 00:40:58,150
relations so the question is do metadata

00:40:56,050 --> 00:41:02,290
tags of relationships and how can we

00:40:58,150 --> 00:41:04,270
carry these relationships currently it's

00:41:02,290 --> 00:41:05,800
not part of the metadata so we have a

00:41:04,270 --> 00:41:07,540
separate system which tries to

00:41:05,800 --> 00:41:09,520
understand user intent and converts it

00:41:07,540 --> 00:41:09,860
to query that sometimes understands

00:41:09,520 --> 00:41:12,650
machine

00:41:09,860 --> 00:41:14,330
the relationship between queries but

00:41:12,650 --> 00:41:16,430
there is a longer-term plan to actually

00:41:14,330 --> 00:41:18,890
get this into the solar index so that

00:41:16,430 --> 00:41:20,270
you can I still don't know what we're

00:41:18,890 --> 00:41:23,510
going to do about it it's it's a pretty

00:41:20,270 --> 00:41:25,010
interesting challenge but yeah so

00:41:23,510 --> 00:41:26,780
correctly you can search for those

00:41:25,010 --> 00:41:28,070
relationships and the index provides

00:41:26,780 --> 00:41:29,840
mechanism but the connections are

00:41:28,070 --> 00:41:36,100
outside and we tend to use less in that

00:41:29,840 --> 00:41:36,100

YouTube URL: https://www.youtube.com/watch?v=mz41RGhDu_k


