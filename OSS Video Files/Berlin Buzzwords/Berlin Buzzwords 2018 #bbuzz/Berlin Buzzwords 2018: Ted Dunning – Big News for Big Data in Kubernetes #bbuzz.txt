Title: Berlin Buzzwords 2018: Ted Dunning – Big News for Big Data in Kubernetes #bbuzz
Publication date: 2018-06-13
Playlist: Berlin Buzzwords 2018 #bbuzz
Description: 
	The folk wisdom has always been that when running stateful applications inside containers that the only viable choice was to externalize the state so that the containers themselves are stateless or nearly so. Keeping large amounts of state inside containers is possible, but it is considered a problem because stateful containers generally can’t preserve that state across restarts.

In practice, this complicates the management of large-scale Kubernetes-based infrastructure because these high-performance storage systems require separate management. In terms of overall system management, it would be ideal if we could run a software-defined storage system directly in containers managed by Kubernetes, but that has been hampered by lack of direct device access and difficult questions about what happens to the state on container restarts.

I will describe recent developments that make it possible for Kubernetes to manage both compute and storage tiers in the same cluster. Container restarts can be handled gracefully without loss of data or a requirement to rebuild storage structures and access to storage from compute containers is extremely fast. In some environments it is even possible to implement elastic storage frameworks that can fold data onto just a few containers during quiescent periods or explode it in just a few seconds across a large number of machines when higher speed access is required.

The benefits of systems like this extends beyond management simplicity because applications can be more agile precisely because the storage layer is more stable and can be uniformly accessed from any container host. Even better, it makes it a snap to configure and deploy a full-scale compute and storage infrastructure.

Read more:
https://2018.berlinbuzzwords.de/18/session/big-news-big-data-kubernetes

About Ted Dunning:
https://2018.berlinbuzzwords.de/users/ted-dunning

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,030 --> 00:00:09,929
[Applause]

00:00:14,900 --> 00:00:20,070
you can see the intermittency of the

00:00:17,880 --> 00:00:22,320
traffic you can measure the capacity of

00:00:20,070 --> 00:00:24,210
the elevator I think if we just kept

00:00:22,320 --> 00:00:26,490
that data that's a problem that we keep

00:00:24,210 --> 00:00:29,460
discarding data we could have known

00:00:26,490 --> 00:00:33,420
something there so I'm gonna talk today

00:00:29,460 --> 00:00:37,590
about kubernetes and the first big fact

00:00:33,420 --> 00:00:39,809
about kubernetes is my clickers not

00:00:37,590 --> 00:00:42,360
turned on is there we go

00:00:39,809 --> 00:00:44,580
kubernetes is coming it's coming in a

00:00:42,360 --> 00:00:47,610
very very dramatic fashion I don't think

00:00:44,580 --> 00:00:52,129
I've seen quite such a switch in a

00:00:47,610 --> 00:00:52,129
marketplace as quickly in a long time

00:00:52,400 --> 00:00:57,720
why do we say that but what is it

00:00:55,350 --> 00:00:59,729
well for one thing there's enormous

00:00:57,720 --> 00:01:01,949
community support there there's enormous

00:00:59,729 --> 00:01:06,420
corporate support but there's enormous

00:01:01,949 --> 00:01:07,950
community support as well we see a lot

00:01:06,420 --> 00:01:10,740
of people adopting it a lot of people

00:01:07,950 --> 00:01:13,770
contributing we see support from all

00:01:10,740 --> 00:01:17,400
three of the major clouds and in fact

00:01:13,770 --> 00:01:20,220
others as well see massive customer

00:01:17,400 --> 00:01:24,270
adoption rate of words of 80 or 90

00:01:20,220 --> 00:01:26,490
percent among our customers and I hear

00:01:24,270 --> 00:01:31,190
90 percent among one of the giant cloud

00:01:26,490 --> 00:01:35,190
vendors so it's happening very very fast

00:01:31,190 --> 00:01:39,210
which raises of course the question for

00:01:35,190 --> 00:01:41,340
all of us either one year ago or now or

00:01:39,210 --> 00:01:43,909
five minutes from now all of us are

00:01:41,340 --> 00:01:47,490
going to be asking what is kubernetes

00:01:43,909 --> 00:01:48,570
besides a really cool Greek word you

00:01:47,490 --> 00:01:51,840
know it's the word that we got

00:01:48,570 --> 00:01:55,320
cybernetics from know about vino came up

00:01:51,840 --> 00:01:58,530
with that hibernate ease is the the

00:01:55,320 --> 00:02:01,409
pilot the one who steers the ship and it

00:01:58,530 --> 00:02:04,140
started his life as the Omega scheduler

00:02:01,409 --> 00:02:08,759
and and systems around that as the

00:02:04,140 --> 00:02:10,709
successor to the Borg at at Google the

00:02:08,759 --> 00:02:13,200
board was the system that Google used

00:02:10,709 --> 00:02:16,130
for a long time to scheduled processes

00:02:13,200 --> 00:02:18,810
and containers and it was a core

00:02:16,130 --> 00:02:20,910
competitive advantage for them for quite

00:02:18,810 --> 00:02:23,340
some time to be able to schedule

00:02:20,910 --> 00:02:24,030
so quickly and so effectively but

00:02:23,340 --> 00:02:26,160
kubernetes

00:02:24,030 --> 00:02:28,860
is as we mentioned earlier an entire

00:02:26,160 --> 00:02:32,940
ecosystem with enormous numbers of

00:02:28,860 --> 00:02:35,610
products there to support it and it is a

00:02:32,940 --> 00:02:40,920
container orchestration machine but

00:02:35,610 --> 00:02:43,410
there are others of those but the the

00:02:40,920 --> 00:02:46,680
orchestration war is effectively over

00:02:43,410 --> 00:02:49,470
almost before people realized it was

00:02:46,680 --> 00:02:51,900
beginning it was just a few years ago

00:02:49,470 --> 00:02:54,600
that a friend of mine was saying that at

00:02:51,900 --> 00:02:57,300
their big cloud 60% of the clusters

00:02:54,600 --> 00:03:00,120
being started in production were Miso's

00:02:57,300 --> 00:03:04,290
and now the number two years later is

00:03:00,120 --> 00:03:06,480
over 90% kubernetes now there isn't the

00:03:04,290 --> 00:03:09,540
the actual number of clusters running in

00:03:06,480 --> 00:03:12,360
the cloud lags that of course because

00:03:09,540 --> 00:03:14,340
some big clusters continue to operate

00:03:12,360 --> 00:03:17,370
and probably will continue to operate

00:03:14,340 --> 00:03:21,390
for years but the adoption rate in terms

00:03:17,370 --> 00:03:23,400
of new clusters it's all one way and

00:03:21,390 --> 00:03:25,590
those are the similar numbers especially

00:03:23,400 --> 00:03:28,440
interestingly in Europe we've seen

00:03:25,590 --> 00:03:31,830
faster corporate adoption of kubernetes

00:03:28,440 --> 00:03:35,040
among large corporations in Europe than

00:03:31,830 --> 00:03:39,090
in the u.s. kind of a reverse trend but

00:03:35,040 --> 00:03:41,220
it makes a lot of sense friends at a

00:03:39,090 --> 00:03:43,500
very large German corporation near

00:03:41,220 --> 00:03:46,170
Heidelberg said that they started eight

00:03:43,500 --> 00:03:50,300
different technology evaluation groups

00:03:46,170 --> 00:03:52,440
to decide how to deal with containers

00:03:50,300 --> 00:03:55,940
informally they say they've never had

00:03:52,440 --> 00:03:59,070
two such groups agree in the past and

00:03:55,940 --> 00:04:01,440
all eight groups from different

00:03:59,070 --> 00:04:03,060
competing parts of the company came up

00:04:01,440 --> 00:04:05,040
with the answer that kubernetes was the

00:04:03,060 --> 00:04:07,500
only solution that they could use and

00:04:05,040 --> 00:04:10,519
they've now adopted it full-fledged and

00:04:07,500 --> 00:04:13,560
that took place over a period of months

00:04:10,519 --> 00:04:15,450
last year and this is in a company that

00:04:13,560 --> 00:04:18,840
more normally makes decisions over a

00:04:15,450 --> 00:04:22,410
period of years the pace is amazing but

00:04:18,840 --> 00:04:27,510
but again what is kubernetes kubernetes

00:04:22,410 --> 00:04:30,210
runs containers what are containers the

00:04:27,510 --> 00:04:33,600
best answer there is that they are not a

00:04:30,210 --> 00:04:34,289
VM that's a little bit of a negative

00:04:33,600 --> 00:04:36,749
answer

00:04:34,289 --> 00:04:39,240
but it's really the important thing

00:04:36,749 --> 00:04:40,710
because people think when you start

00:04:39,240 --> 00:04:43,649
saying what the advantages of a

00:04:40,710 --> 00:04:46,409
container are in terms of isolation and

00:04:43,649 --> 00:04:48,449
an apparently independent operation that

00:04:46,409 --> 00:04:50,699
oh that sounds like a VM but importantly

00:04:48,449 --> 00:04:55,139
it's not there's technical at reasons

00:04:50,699 --> 00:04:57,389
that here with a VM you have an extra OS

00:04:55,139 --> 00:05:00,029
layer you have multiple copies not just

00:04:57,389 --> 00:05:02,309
to running you have to in the pathway to

00:05:00,029 --> 00:05:04,770
the hardware but you could have dozens

00:05:02,309 --> 00:05:06,809
of copies of the OS running it might

00:05:04,770 --> 00:05:08,909
take advantage of virtual memory or if

00:05:06,809 --> 00:05:11,999
you want to avoid specter and meltdown

00:05:08,909 --> 00:05:15,029
it probably won't you have a hypervisor

00:05:11,999 --> 00:05:16,619
running as well with containers a lot of

00:05:15,029 --> 00:05:18,809
that overhead a lot of that replication

00:05:16,619 --> 00:05:20,399
is gone so you could very often around

00:05:18,809 --> 00:05:23,759
hundreds of containers where you could

00:05:20,399 --> 00:05:25,529
only run a dozen or two VMs but the

00:05:23,759 --> 00:05:28,740
really really core difference is not

00:05:25,529 --> 00:05:33,389
these technical details it has to do

00:05:28,740 --> 00:05:36,479
with kittens and cows think about it

00:05:33,389 --> 00:05:39,899
well you know friend of mine has a farm

00:05:36,479 --> 00:05:41,999
and he denies this he says this is

00:05:39,899 --> 00:05:44,189
nothing like what happens because he

00:05:41,999 --> 00:05:47,370
names his cows but if you think about it

00:05:44,189 --> 00:05:47,849
if you have a pet you feed it you name

00:05:47,370 --> 00:05:50,430
it

00:05:47,849 --> 00:05:54,629
you cuddle it you take cute pictures of

00:05:50,430 --> 00:05:56,639
it ok and if you get sick you pay

00:05:54,629 --> 00:06:01,110
enormous amounts of money to make it

00:05:56,639 --> 00:06:05,550
better if you have a cow you don't name

00:06:01,110 --> 00:06:09,029
them you give them numbers and if they

00:06:05,550 --> 00:06:12,059
get sick you feel bad you really you do

00:06:09,029 --> 00:06:17,430
but not nearly as bad and it's all

00:06:12,059 --> 00:06:19,860
economics at that point now anybody

00:06:17,430 --> 00:06:23,159
remember naming each new server that you

00:06:19,860 --> 00:06:25,379
got I named them after the stops in the

00:06:23,159 --> 00:06:28,080
iliad friends of mine named them after

00:06:25,379 --> 00:06:30,599
mountains and hobbits and things like

00:06:28,080 --> 00:06:35,699
that remember naming machines those are

00:06:30,599 --> 00:06:37,529
pets and then people say vm's well

00:06:35,699 --> 00:06:41,779
that's just a way be more flexible

00:06:37,529 --> 00:06:45,029
those are pets containers or cows and

00:06:41,779 --> 00:06:46,439
not the pretty nice cows that people put

00:06:45,029 --> 00:06:47,729
in advertisements these are the

00:06:46,439 --> 00:06:49,740
industrial

00:06:47,729 --> 00:06:51,589
number on them don't name them because

00:06:49,740 --> 00:06:53,909
then you'll feel bad when they go away

00:06:51,589 --> 00:06:56,219
sort of cows okay

00:06:53,909 --> 00:06:58,819
so aside from people who live on for who

00:06:56,219 --> 00:07:03,990
he lives on a farm or lived on a farm

00:06:58,819 --> 00:07:07,699
okay I'm safe okay when I talked like

00:07:03,990 --> 00:07:10,979
this in Wisconsin it's not so good

00:07:07,699 --> 00:07:14,400
maybe Austria I don't know Switzerland

00:07:10,979 --> 00:07:17,610
so they give us isolation and they give

00:07:14,400 --> 00:07:20,969
it to us through two mechanisms one is

00:07:17,610 --> 00:07:22,680
to do with namespaces files shared

00:07:20,969 --> 00:07:25,559
memory and things like that the other is

00:07:22,680 --> 00:07:28,949
ephemeral resources like memory and CPU

00:07:25,559 --> 00:07:32,879
the core idea is that we build images up

00:07:28,949 --> 00:07:35,879
from multiple read-only layers and a

00:07:32,879 --> 00:07:39,409
final writable layer so that we have

00:07:35,879 --> 00:07:43,080
what appears to be an entire file system

00:07:39,409 --> 00:07:46,680
without actually necessarily copying all

00:07:43,080 --> 00:07:50,610
those files then we use change route

00:07:46,680 --> 00:07:53,370
which allows us to tell the processes

00:07:50,610 --> 00:07:56,219
inside the container that that virtual

00:07:53,370 --> 00:07:58,589
file system is all that exists and we do

00:07:56,219 --> 00:08:01,379
things like see groups and and other

00:07:58,589 --> 00:08:04,199
names face things to convince it that

00:08:01,379 --> 00:08:07,249
everything is independent but in fact

00:08:04,199 --> 00:08:11,370
it's really just ordinary processes

00:08:07,249 --> 00:08:13,740
running under the same OS with just a

00:08:11,370 --> 00:08:15,990
little bit of magic trick to make it

00:08:13,740 --> 00:08:21,779
appear more independent it is nothing

00:08:15,990 --> 00:08:26,089
like as isolated as a VM but it is

00:08:21,779 --> 00:08:29,009
nothing like as expensive as a VM either

00:08:26,089 --> 00:08:31,379
now these are wonderful people talk

00:08:29,009 --> 00:08:33,149
about them people love them it's it's a

00:08:31,379 --> 00:08:36,139
great way to do this because you

00:08:33,149 --> 00:08:39,329
combined all of the environmental

00:08:36,139 --> 00:08:41,310
dependencies into a container so if he

00:08:39,329 --> 00:08:42,750
wants one version of live C and I want a

00:08:41,310 --> 00:08:45,899
different version and he wants Java

00:08:42,750 --> 00:08:47,160
eight and I want Java nine and we just

00:08:45,899 --> 00:08:51,110
put them in our container we're all

00:08:47,160 --> 00:08:55,800
happy but there's a big big problem and

00:08:51,110 --> 00:08:58,800
that is if you aren't careful you find

00:08:55,800 --> 00:09:01,380
yourself SSH into your container and

00:08:58,800 --> 00:09:05,220
fixing something

00:09:01,380 --> 00:09:10,200
the problem is that this becomes a pet

00:09:05,220 --> 00:09:11,920
not account and pets will not let you go

00:09:10,200 --> 00:09:14,800
they own you

00:09:11,920 --> 00:09:15,850
just as much as you on them you can

00:09:14,800 --> 00:09:18,760
never get away from them

00:09:15,850 --> 00:09:24,060
you've got to figure out some way to

00:09:18,760 --> 00:09:26,470
support them in a nameless fashion and

00:09:24,060 --> 00:09:28,750
things have been built up from the

00:09:26,470 --> 00:09:31,920
bottom to try to do some of this but

00:09:28,750 --> 00:09:35,260
docker itself is really built up around

00:09:31,920 --> 00:09:39,400
managing a few of these really built up

00:09:35,260 --> 00:09:42,280
around managing pets and what we want to

00:09:39,400 --> 00:09:44,800
do is have something that is much more

00:09:42,280 --> 00:09:48,220
industrial about how containers are

00:09:44,800 --> 00:09:50,560
managed I do not want to talk about how

00:09:48,220 --> 00:09:52,810
many web servers I have well how many

00:09:50,560 --> 00:09:54,880
I'm happy to talk about but I don't want

00:09:52,810 --> 00:09:57,340
to talk about any given one of them I

00:09:54,880 --> 00:10:00,910
want them just to exist out there and

00:09:57,340 --> 00:10:03,010
some unnamed masse the magical view here

00:10:00,910 --> 00:10:06,340
is we want kubernetes to live there

00:10:03,010 --> 00:10:08,890
it starts processes and we don't really

00:10:06,340 --> 00:10:13,390
care it starts them somewhere it decides

00:10:08,890 --> 00:10:15,730
it starts another application and it may

00:10:13,390 --> 00:10:17,530
be associated because of affinities it

00:10:15,730 --> 00:10:20,080
may be isolated because of anti

00:10:17,530 --> 00:10:22,150
infinities it may be near a GPU because

00:10:20,080 --> 00:10:25,270
of that same sort of thing it may have

00:10:22,150 --> 00:10:27,100
more or less requirements it should deal

00:10:25,270 --> 00:10:29,500
with them we should think of our

00:10:27,100 --> 00:10:35,260
applications as groups of these things

00:10:29,500 --> 00:10:37,510
not as single single machines and it

00:10:35,260 --> 00:10:39,880
provides naming and things like that so

00:10:37,510 --> 00:10:42,430
that it could be really really fast to

00:10:39,880 --> 00:10:46,420
refer to things by name which we do not

00:10:42,430 --> 00:10:49,420
know where they are we don't think about

00:10:46,420 --> 00:10:51,880
which machine it's running on at all at

00:10:49,420 --> 00:10:56,410
that point and we don't if we do it well

00:10:51,880 --> 00:10:58,750
even think about what IP address it has

00:10:56,410 --> 00:11:04,750
or which container we might be talking

00:10:58,750 --> 00:11:06,220
to no more names from The Hobbit there

00:11:04,750 --> 00:11:08,460
are going to be no containers named

00:11:06,220 --> 00:11:11,470
Frodo it's just not going to be that way

00:11:08,460 --> 00:11:14,440
now the impact here

00:11:11,470 --> 00:11:17,610
is that we can do real software

00:11:14,440 --> 00:11:21,100
engineering and if you think about it

00:11:17,610 --> 00:11:25,920
the process of software engineering is

00:11:21,100 --> 00:11:29,860
the process of freezing away variability

00:11:25,920 --> 00:11:32,350
well some people kind of view it as you

00:11:29,860 --> 00:11:34,120
know expressing the potential but I feel

00:11:32,350 --> 00:11:36,670
it much more like sculpture we're

00:11:34,120 --> 00:11:38,440
cutting away all of the potential of the

00:11:36,670 --> 00:11:41,590
Machine all of the things it could do

00:11:38,440 --> 00:11:45,190
and we're leaving only things we wanted

00:11:41,590 --> 00:11:49,270
to do now a little bit of history is

00:11:45,190 --> 00:11:52,870
useful here a long time ago if I wanted

00:11:49,270 --> 00:11:56,500
a file in my application we would have a

00:11:52,870 --> 00:11:59,740
meeting seriously and I would be asked

00:11:56,500 --> 00:12:02,740
questions like do you have hardware

00:11:59,740 --> 00:12:04,050
authority for your file budget because

00:12:02,740 --> 00:12:07,390
you're gonna need Hardware aren't you

00:12:04,050 --> 00:12:09,940
this is crazy and then they would say do

00:12:07,390 --> 00:12:13,680
you have somebody to call after hours if

00:12:09,940 --> 00:12:16,360
the file breaks this is crazy

00:12:13,680 --> 00:12:18,970
they would say do you have a contingency

00:12:16,360 --> 00:12:22,480
plan if your file grows bigger than you

00:12:18,970 --> 00:12:24,010
say it will and and so we would go in

00:12:22,480 --> 00:12:26,050
and we would change things we would fix

00:12:24,010 --> 00:12:28,300
things we would have a program running

00:12:26,050 --> 00:12:29,920
and to avoid having another meeting we

00:12:28,300 --> 00:12:33,400
would do things like we would change the

00:12:29,920 --> 00:12:37,060
bits of the running program as it's

00:12:33,400 --> 00:12:39,130
running because hey you had to do it you

00:12:37,060 --> 00:12:40,900
couldn't afford to run this on another

00:12:39,130 --> 00:12:44,080
machine for a little bit you couldn't

00:12:40,900 --> 00:12:46,960
afford to stop it you had to change it

00:12:44,080 --> 00:12:50,470
hot these are all crazy

00:12:46,960 --> 00:12:53,290
by today's standards and so if it's

00:12:50,470 --> 00:12:56,560
crazy to reach in and change the bits of

00:12:53,290 --> 00:12:58,450
a running program you guys don't seem to

00:12:56,560 --> 00:13:00,460
be reacting quite as strongly to that as

00:12:58,450 --> 00:13:03,030
I expect who here thinks that's a good

00:13:00,460 --> 00:13:06,580
idea okay good

00:13:03,030 --> 00:13:09,910
see I cleverly put it so that the

00:13:06,580 --> 00:13:14,170
sensible thing is no action because it's

00:13:09,910 --> 00:13:16,150
after lunch so anytime I want you to

00:13:14,170 --> 00:13:18,970
agree that will be the no action side of

00:13:16,150 --> 00:13:22,840
the things so it's crazy to change the

00:13:18,970 --> 00:13:25,089
bits of a running program okay people

00:13:22,840 --> 00:13:27,249
also didn't use source couldn't

00:13:25,089 --> 00:13:28,869
roll they would just change the source

00:13:27,249 --> 00:13:31,209
whatever and it was on some machine

00:13:28,869 --> 00:13:32,619
somewhere and if they were good they

00:13:31,209 --> 00:13:38,889
would remind somebody else did they

00:13:32,619 --> 00:13:41,589
change something that was crazy but if

00:13:38,889 --> 00:13:45,639
you think about it these are about

00:13:41,589 --> 00:13:49,419
freezing the state once the program runs

00:13:45,639 --> 00:13:51,879
we don't mess with it once we declared

00:13:49,419 --> 00:13:55,709
this is the version of source code we're

00:13:51,879 --> 00:13:58,539
going to run we don't mess with it

00:13:55,709 --> 00:14:01,979
the same sort of place where I started

00:13:58,539 --> 00:14:04,809
had a program that was written on an IBM

00:14:01,979 --> 00:14:07,479
1109 which was running on an IBM 1401

00:14:04,809 --> 00:14:11,889
emulator which was running on an IBM 360

00:14:07,479 --> 00:14:14,139
emulator on an IBM 370 the person who

00:14:11,889 --> 00:14:19,989
had written the code had lost the source

00:14:14,139 --> 00:14:24,129
code and then died and so nobody had

00:14:19,989 --> 00:14:26,919
ever even seen an 1109 the machine that

00:14:24,129 --> 00:14:28,929
was coded for they had never seen the

00:14:26,919 --> 00:14:32,699
computer language that that was written

00:14:28,929 --> 00:14:35,199
for and yet it was a fight vital

00:14:32,699 --> 00:14:38,979
fundraising application for the hospital

00:14:35,199 --> 00:14:41,589
I was in and so what they did is to

00:14:38,979 --> 00:14:45,069
maintain this program they hired a woman

00:14:41,589 --> 00:14:47,319
back then of course to draw a red line

00:14:45,069 --> 00:14:51,819
through columns of output that are

00:14:47,319 --> 00:14:54,489
always wrong and to draw a wavy blue

00:14:51,819 --> 00:14:57,489
line through columns that were sometimes

00:14:54,489 --> 00:15:00,309
wrong that was how they maintained the

00:14:57,489 --> 00:15:03,039
software that's crazy that's crazy so we

00:15:00,309 --> 00:15:05,799
we have version control now so that if a

00:15:03,039 --> 00:15:08,229
person does die or leave or whatever we

00:15:05,799 --> 00:15:10,569
can figure out what happened we compile

00:15:08,229 --> 00:15:13,179
the code to a binary state and that's

00:15:10,569 --> 00:15:15,939
what we run you don't patch it you don't

00:15:13,179 --> 00:15:18,609
change it the code is the code the

00:15:15,939 --> 00:15:22,419
output of the compiler is what we run we

00:15:18,609 --> 00:15:25,419
have removed potential there we have

00:15:22,419 --> 00:15:28,149
frozen away variability the code could

00:15:25,419 --> 00:15:31,359
have been anything at all we have frozen

00:15:28,149 --> 00:15:33,309
it to be what we want the binary could

00:15:31,359 --> 00:15:36,459
be anything we want the compiler is just

00:15:33,309 --> 00:15:38,089
a suggestion we have frozen it to what

00:15:36,459 --> 00:15:41,300
the compiler produces

00:15:38,089 --> 00:15:43,699
but that's not enough the idea of

00:15:41,300 --> 00:15:47,059
freezing the source code freezing the

00:15:43,699 --> 00:15:49,639
output of the of the compiler and the

00:15:47,059 --> 00:15:51,079
linking is not enough we need to freeze

00:15:49,639 --> 00:15:54,319
some more we need to freeze the

00:15:51,079 --> 00:15:56,360
environment which version of libraries

00:15:54,319 --> 00:15:59,360
do we use which version of the operating

00:15:56,360 --> 00:16:01,430
system do we use which resources which

00:15:59,360 --> 00:16:04,120
configurations those should be frozen

00:16:01,430 --> 00:16:07,850
and packaged together this is where

00:16:04,120 --> 00:16:10,730
containers work but there's more that we

00:16:07,850 --> 00:16:13,430
need to do we need to be able to say

00:16:10,730 --> 00:16:16,610
here's the shape of the system I want to

00:16:13,430 --> 00:16:18,499
build I want to have some servers here I

00:16:16,610 --> 00:16:20,059
don't know how many I want them to talk

00:16:18,499 --> 00:16:23,420
to these other servers through a load

00:16:20,059 --> 00:16:27,559
balancer I want those to talk to some

00:16:23,420 --> 00:16:30,079
kind of data now there's parts of that I

00:16:27,559 --> 00:16:32,360
still wave my hands I don't want to

00:16:30,079 --> 00:16:34,490
commit to how many of the different

00:16:32,360 --> 00:16:37,160
kinds of services yet I don't want to

00:16:34,490 --> 00:16:40,009
commit to exactly which load balancer or

00:16:37,160 --> 00:16:42,199
exactly where the data is but I do want

00:16:40,009 --> 00:16:45,079
to commit to these are the functions

00:16:42,199 --> 00:16:48,589
that go here and here and this is the

00:16:45,079 --> 00:16:52,040
shape of the service I want to freeze

00:16:48,589 --> 00:16:54,490
away possibilities and make it so I can

00:16:52,040 --> 00:16:57,559
make it do what I want it to do and

00:16:54,490 --> 00:17:00,740
that's what helm does helm is part of

00:16:57,559 --> 00:17:06,289
kubernetes it lets me build a template a

00:17:00,740 --> 00:17:08,449
shape of a service as an artifact that I

00:17:06,289 --> 00:17:11,929
conversion control and I can now build

00:17:08,449 --> 00:17:15,740
that system and then ultimately I can

00:17:11,929 --> 00:17:20,959
deploy it and when I deploy it I will

00:17:15,740 --> 00:17:23,419
insert keys and DNS records as necessary

00:17:20,959 --> 00:17:25,959
to actually connect it so you know you

00:17:23,419 --> 00:17:28,760
can't run anything unless it has

00:17:25,959 --> 00:17:31,190
certificates and ands tickets and things

00:17:28,760 --> 00:17:32,750
like that and you can't really run it

00:17:31,190 --> 00:17:35,000
unless you know how many there are

00:17:32,750 --> 00:17:37,279
perhaps you could change that later but

00:17:35,000 --> 00:17:39,110
you have to know how many to start and

00:17:37,279 --> 00:17:41,029
you can't really run it unless you have

00:17:39,110 --> 00:17:45,280
the load balancer and the data elements

00:17:41,029 --> 00:17:48,740
actually attached so that final part is

00:17:45,280 --> 00:17:51,580
kubernetes running that system

00:17:48,740 --> 00:17:55,640
and at each stage we have removed

00:17:51,580 --> 00:17:58,010
changes and variability and frozen down

00:17:55,640 --> 00:18:00,890
the configuration so that's what

00:17:58,010 --> 00:18:05,690
kubernetes in essence is doing is taking

00:18:00,890 --> 00:18:07,790
us from 40 years ago 20 years ago 10

00:18:05,690 --> 00:18:10,070
years ago or something like that docker

00:18:07,790 --> 00:18:12,770
is the last few years but we're now

00:18:10,070 --> 00:18:15,770
taking the next few steps of how we can

00:18:12,770 --> 00:18:18,650
build repeatable things how we can

00:18:15,770 --> 00:18:21,920
deployed repeatable things that do what

00:18:18,650 --> 00:18:25,640
we intend and that we don't go in and

00:18:21,920 --> 00:18:27,770
mess with at runtime we want to change

00:18:25,640 --> 00:18:30,760
those kubernetes will let us do it

00:18:27,770 --> 00:18:33,320
upgrade and it'll do a rolling upgrade

00:18:30,760 --> 00:18:35,450
it will replace every one of those

00:18:33,320 --> 00:18:39,760
containers with a new completely

00:18:35,450 --> 00:18:44,540
controlled packaged container

00:18:39,760 --> 00:18:46,940
this is absolutely glorious if you lived

00:18:44,540 --> 00:18:49,520
through the dark ages it's even more

00:18:46,940 --> 00:18:52,370
glorious imagine about five times more

00:18:49,520 --> 00:18:55,280
brilliant than then you see it as that's

00:18:52,370 --> 00:18:58,640
the way I see it it's just fabulous we

00:18:55,280 --> 00:19:02,840
can actually say what we meant and the

00:18:58,640 --> 00:19:04,340
computers will do it as opposed to

00:19:02,840 --> 00:19:10,550
waking up in the middle of the night and

00:19:04,340 --> 00:19:16,730
messing with stuff but there is one huge

00:19:10,550 --> 00:19:19,910
glaring omission intentional but it's a

00:19:16,730 --> 00:19:25,520
thing that kubernetes doesn't do pretty

00:19:19,910 --> 00:19:29,360
much at all and that's state state data

00:19:25,520 --> 00:19:31,400
gets in the way the assumption here is I

00:19:29,360 --> 00:19:33,820
could just stop this container here and

00:19:31,400 --> 00:19:36,559
start it over there and and all that

00:19:33,820 --> 00:19:38,570
well that that's totally implausible if

00:19:36,559 --> 00:19:44,059
it's carrying around 100 terabytes of

00:19:38,570 --> 00:19:46,400
data or more and so we're not done yet

00:19:44,059 --> 00:19:49,070
this this idea of this little system

00:19:46,400 --> 00:19:52,880
that we built we froze and we configure

00:19:49,070 --> 00:19:55,910
it and we deployed the big big problem

00:19:52,880 --> 00:19:59,090
still is how do we deal with that state

00:19:55,910 --> 00:20:02,350
there it really messes up the

00:19:59,090 --> 00:20:04,929
assumptions of a sea of container

00:20:02,350 --> 00:20:07,390
it messes up the assumptions that

00:20:04,929 --> 00:20:09,070
they're portable it messes with the

00:20:07,390 --> 00:20:10,030
assumptions that we could just restart

00:20:09,070 --> 00:20:12,669
them somewhere else

00:20:10,030 --> 00:20:14,710
well if they're talking to disks on one

00:20:12,669 --> 00:20:19,000
machine and they just start up on some

00:20:14,710 --> 00:20:22,210
other that's just all gone so that that

00:20:19,000 --> 00:20:25,320
just doesn't work if we try to put into

00:20:22,210 --> 00:20:28,480
the applications replication of state

00:20:25,320 --> 00:20:31,360
that becomes complex very very quickly

00:20:28,480 --> 00:20:33,910
and that requires systems types of

00:20:31,360 --> 00:20:36,429
skills which application developers

00:20:33,910 --> 00:20:39,010
notoriously lack at least from the point

00:20:36,429 --> 00:20:41,289
of view of the systems developers it

00:20:39,010 --> 00:20:43,480
goes the other way too like human skills

00:20:41,289 --> 00:20:45,730
are notoriously lacking in systems

00:20:43,480 --> 00:20:50,710
people so they just don't build you eyes

00:20:45,730 --> 00:20:52,690
like users oh and but that mismatch that

00:20:50,710 --> 00:20:55,210
cultural mismatch means that application

00:20:52,690 --> 00:20:57,940
developers never build data replication

00:20:55,210 --> 00:20:59,980
that's very good it's always kind of

00:20:57,940 --> 00:21:01,780
broken and that's not what they're

00:20:59,980 --> 00:21:05,409
focused on it's like the system

00:21:01,780 --> 00:21:06,970
developers UI and the state lifecycle

00:21:05,409 --> 00:21:10,419
doesn't really match the app lifecycle

00:21:06,970 --> 00:21:14,080
the state should last a long time the

00:21:10,419 --> 00:21:16,780
app could come up and go down but we

00:21:14,080 --> 00:21:19,690
don't want them to match we want the

00:21:16,780 --> 00:21:23,559
state to have an existence independent

00:21:19,690 --> 00:21:25,960
of the containers we want it to persist

00:21:23,559 --> 00:21:29,520
I mean that's the whole point right with

00:21:25,960 --> 00:21:32,049
why we call it persistence is so it does

00:21:29,520 --> 00:21:36,250
well let's let's think about this what

00:21:32,049 --> 00:21:37,539
is a service service is something you

00:21:36,250 --> 00:21:40,690
asked to serve you right

00:21:37,539 --> 00:21:43,630
you give it like an RPC and this is the

00:21:40,690 --> 00:21:47,230
i synchronous idea hey you do something

00:21:43,630 --> 00:21:49,539
and you go yes sir and and and you do

00:21:47,230 --> 00:21:50,980
something for me that's the way we like

00:21:49,539 --> 00:21:53,610
to think about servers they don't always

00:21:50,980 --> 00:21:56,950
do that but I'd like to pretend they do

00:21:53,610 --> 00:22:00,490
that's one way but there's an

00:21:56,950 --> 00:22:03,010
asynchronous way as well we could make

00:22:00,490 --> 00:22:06,130
all of our calls have to complete before

00:22:03,010 --> 00:22:07,780
we get on we could pretend that we're

00:22:06,130 --> 00:22:10,630
not really waiting for them with some

00:22:07,780 --> 00:22:12,460
sort of callback mechanism but in fact

00:22:10,630 --> 00:22:14,330
we are waiting for them to finish that's

00:22:12,460 --> 00:22:19,740
a synchronous call

00:22:14,330 --> 00:22:22,350
call and return but we can defer some

00:22:19,740 --> 00:22:24,960
work to it that's very common like you

00:22:22,350 --> 00:22:27,210
know what color is the sky you tell me

00:22:24,960 --> 00:22:30,090
blue and you make a note yeah somebody

00:22:27,210 --> 00:22:33,540
asked what color it is again and that

00:22:30,090 --> 00:22:35,670
note then becomes deferred work later

00:22:33,540 --> 00:22:37,920
somebody will analyze how often do they

00:22:35,670 --> 00:22:40,290
ask certain questions and then they'll

00:22:37,920 --> 00:22:42,510
start cashing the answers to certain

00:22:40,290 --> 00:22:45,660
things so this is a very common pattern

00:22:42,510 --> 00:22:47,340
I ask you to do something and you do the

00:22:45,660 --> 00:22:49,530
minimum amount of work so you can give

00:22:47,340 --> 00:22:51,510
me an answer fast and then you defer

00:22:49,530 --> 00:22:55,260
some work that doesn't have to happen

00:22:51,510 --> 00:23:03,090
right now do some defer some is a very

00:22:55,260 --> 00:23:06,480
very common measure of idiom so there's

00:23:03,090 --> 00:23:08,340
a RPC that comes in and a little bit of

00:23:06,480 --> 00:23:12,060
deferred work that comes out the other

00:23:08,340 --> 00:23:15,410
end and somebody will we trust read that

00:23:12,060 --> 00:23:18,420
stream of deferred work and do it later

00:23:15,410 --> 00:23:20,360
when we have some more time but we'll

00:23:18,420 --> 00:23:25,800
get the answer to the RPC very quickly

00:23:20,360 --> 00:23:29,670
so this idea gives us the possibility to

00:23:25,800 --> 00:23:32,910
isolate things this is the essence of

00:23:29,670 --> 00:23:34,590
what a service is if I ask you to do

00:23:32,910 --> 00:23:37,470
something and you give me an answer in

00:23:34,590 --> 00:23:38,850
such a wonderful spirited way I don't

00:23:37,470 --> 00:23:41,670
care how you did it

00:23:38,850 --> 00:23:44,930
really I shouldn't I probably do but I

00:23:41,670 --> 00:23:47,220
shouldn't I should let you do that I

00:23:44,930 --> 00:23:49,980
shouldn't look inside the kitchen when

00:23:47,220 --> 00:23:52,710
they first feed me lunch I'm sure it's

00:23:49,980 --> 00:23:55,650
lovely but I shouldn't look and that's

00:23:52,710 --> 00:23:58,290
the idea is that an RPC lets me isolate

00:23:55,650 --> 00:24:01,020
that implementation from the fact that I

00:23:58,290 --> 00:24:05,880
need the response but there's more

00:24:01,020 --> 00:24:07,590
isolation then we can have if my service

00:24:05,880 --> 00:24:10,260
and the other service can be

00:24:07,590 --> 00:24:12,660
independently deployed taken up take it

00:24:10,260 --> 00:24:16,950
down that's the definition of a micro

00:24:12,660 --> 00:24:19,140
service well some people say micro

00:24:16,950 --> 00:24:21,720
service but I've heard about somebody

00:24:19,140 --> 00:24:23,820
who has a database they take the changes

00:24:21,720 --> 00:24:26,460
out of the database they process it

00:24:23,820 --> 00:24:27,779
through ten different things and then it

00:24:26,460 --> 00:24:29,190
goes back in the database and

00:24:27,779 --> 00:24:31,080
causes more things to go around the

00:24:29,190 --> 00:24:33,239
circle's and they can only restart

00:24:31,080 --> 00:24:35,340
things in the right order

00:24:33,239 --> 00:24:36,659
first the database then the first thing

00:24:35,340 --> 00:24:39,269
then the second thing and so on

00:24:36,659 --> 00:24:41,869
otherwise it doesn't work those are not

00:24:39,269 --> 00:24:45,840
micro services those are a big mistake

00:24:41,869 --> 00:24:47,369
don't do that and so this idea of I

00:24:45,840 --> 00:24:48,929
could just independently redeploy it

00:24:47,369 --> 00:24:51,239
means I would be able to start those

00:24:48,929 --> 00:24:53,700
things in any order and if they were

00:24:51,239 --> 00:24:56,759
done as good Micra services it would be

00:24:53,700 --> 00:24:59,729
ok there would be no interlocking state

00:24:56,759 --> 00:25:02,219
of what's pending and so on

00:24:59,729 --> 00:25:05,489
if I can hide the details of exactly

00:25:02,219 --> 00:25:07,440
when something is being done I have

00:25:05,489 --> 00:25:11,820
something more than just a micro service

00:25:07,440 --> 00:25:14,460
I have a streaming micro service that's

00:25:11,820 --> 00:25:17,309
really really a powerful extension of

00:25:14,460 --> 00:25:20,159
this idea of service and micro service

00:25:17,309 --> 00:25:22,200
it's a streaming micro service I don't

00:25:20,159 --> 00:25:24,629
really care if you give me the answer

00:25:22,200 --> 00:25:27,479
now I just ask you something and I move

00:25:24,629 --> 00:25:29,969
on you will do it I trust you that's a

00:25:27,479 --> 00:25:33,239
streaming micro service and that gives

00:25:29,969 --> 00:25:36,119
me all kinds of power so a producer of

00:25:33,239 --> 00:25:38,700
some work like the deferred work we saw

00:25:36,119 --> 00:25:41,389
earlier produces the work into a stream

00:25:38,700 --> 00:25:44,879
and the consumer is not even running

00:25:41,389 --> 00:25:46,289
remember I said temporal isolation they

00:25:44,879 --> 00:25:49,139
don't have to be running at the same

00:25:46,289 --> 00:25:52,379
time they don't have to do the work when

00:25:49,139 --> 00:25:54,570
the work is requested the consumer may

00:25:52,379 --> 00:25:57,950
not have been written yet that's the

00:25:54,570 --> 00:26:00,570
ultimate implementation detail I

00:25:57,950 --> 00:26:03,210
sometimes invoke that detail I just

00:26:00,570 --> 00:26:07,169
don't bother me it's just some details

00:26:03,210 --> 00:26:09,679
missing like I haven't done it ok so

00:26:07,169 --> 00:26:12,509
then the consumer could run later

00:26:09,679 --> 00:26:14,639
excellent that would be a deferred sort

00:26:12,509 --> 00:26:16,859
of thing but we can actually hide other

00:26:14,639 --> 00:26:20,039
details like the consumer could be an

00:26:16,859 --> 00:26:22,109
entire ocean away doesn't really matter

00:26:20,039 --> 00:26:25,019
if it's deferred this is the kind of

00:26:22,109 --> 00:26:28,409
freedom that a streaming service should

00:26:25,019 --> 00:26:30,899
give us now unfortunately all of this

00:26:28,409 --> 00:26:34,379
leads to persistence all of this leads

00:26:30,899 --> 00:26:38,149
to state which is exactly the stuff that

00:26:34,379 --> 00:26:41,430
kubernetes isn't solving we have files

00:26:38,149 --> 00:26:44,950
many people use files machine learning

00:26:41,430 --> 00:26:45,760
configuration files very very useful not

00:26:44,950 --> 00:26:47,650
always right

00:26:45,760 --> 00:26:50,290
tables are sometimes much better we can

00:26:47,650 --> 00:26:52,690
delete the middle of a table by rows by

00:26:50,290 --> 00:26:54,460
so on streams are very important we saw

00:26:52,690 --> 00:26:57,010
an example of that from the streaming

00:26:54,460 --> 00:26:59,440
micro service point of view all of those

00:26:57,010 --> 00:27:01,540
are important we want to build those

00:26:59,440 --> 00:27:04,630
kubernetes applications like we talked

00:27:01,540 --> 00:27:07,360
about before with lots of things we want

00:27:04,630 --> 00:27:10,090
them to connect with files and streams

00:27:07,360 --> 00:27:12,130
and tables and and even direct RPC now

00:27:10,090 --> 00:27:15,310
kubernetes is going to help us with the

00:27:12,130 --> 00:27:17,140
RPC because it does load balancers but

00:27:15,310 --> 00:27:21,430
it's not going to do us any good at all

00:27:17,140 --> 00:27:24,790
on the bottom part we need something

00:27:21,430 --> 00:27:27,340
there for all of that state all of that

00:27:24,790 --> 00:27:31,210
persistence and we don't want it to be

00:27:27,340 --> 00:27:33,820
here and it's emphatically not here we

00:27:31,210 --> 00:27:36,700
need something else we need a data

00:27:33,820 --> 00:27:43,090
platform that can hide all of those

00:27:36,700 --> 00:27:45,280
pieces that can abstract away state and

00:27:43,090 --> 00:27:47,890
persistence the same way kubernetes

00:27:45,280 --> 00:27:49,900
abstracts away which machine are you

00:27:47,890 --> 00:27:53,650
running on just tell me what you need

00:27:49,900 --> 00:27:55,780
I'll get it for you same thing with data

00:27:53,650 --> 00:27:58,000
we should be able to say tell me what

00:27:55,780 --> 00:28:00,370
you need and I'll get it for you and as

00:27:58,000 --> 00:28:04,930
I see it this is now going from

00:28:00,370 --> 00:28:06,550
reporting to opinion as I see it these

00:28:04,930 --> 00:28:09,610
are the requirements that we absolutely

00:28:06,550 --> 00:28:12,790
need in a data platform we need to be

00:28:09,610 --> 00:28:14,260
able to name things that's obviously

00:28:12,790 --> 00:28:18,070
true of services but we need to be able

00:28:14,260 --> 00:28:21,850
to name data a certain right look

00:28:18,070 --> 00:28:23,680
appears on this man's face we need to be

00:28:21,850 --> 00:28:26,320
able to name them between clusters so we

00:28:23,680 --> 00:28:28,350
can refer to data far away we need to

00:28:26,320 --> 00:28:31,360
have all of those forms not just files

00:28:28,350 --> 00:28:35,170
files tables and streams they should all

00:28:31,360 --> 00:28:37,590
be there and naming and the three kinds

00:28:35,170 --> 00:28:40,240
of persistence should be orthogonal I

00:28:37,590 --> 00:28:42,580
should be able to have a directory with

00:28:40,240 --> 00:28:45,460
all three kinds of persistence in it why

00:28:42,580 --> 00:28:47,590
not why is it named good for a file but

00:28:45,460 --> 00:28:51,430
not good for a stream do you remember

00:28:47,590 --> 00:28:53,640
the crazy conversation about the file he

00:28:51,430 --> 00:28:53,640
does

00:28:53,790 --> 00:28:57,190
but we still have those crazy

00:28:55,690 --> 00:28:59,650
conversations about streams

00:28:57,190 --> 00:29:02,320
you say you want streams I say with my

00:28:59,650 --> 00:29:04,800
authoritarian voice do you have hardware

00:29:02,320 --> 00:29:07,360
authority for your cluster that you want

00:29:04,800 --> 00:29:09,490
why do I assume that he wants a cluster

00:29:07,360 --> 00:29:12,370
why doesn't he just create the stream

00:29:09,490 --> 00:29:15,400
the same way he would create a file he

00:29:12,370 --> 00:29:16,930
shouldn't need to come to me I mean I'd

00:29:15,400 --> 00:29:20,500
love being an authority figure and all

00:29:16,930 --> 00:29:22,960
that but shouldn't need to happen if you

00:29:20,500 --> 00:29:24,460
want a file touch create the file

00:29:22,960 --> 00:29:27,100
whatever you know we have some

00:29:24,460 --> 00:29:29,170
generalized budget requirements you want

00:29:27,100 --> 00:29:31,480
to stream create a stream it should be

00:29:29,170 --> 00:29:32,830
just like that all of them should be

00:29:31,480 --> 00:29:35,470
inherently scalable we should be

00:29:32,830 --> 00:29:37,540
abstracting away these details of server

00:29:35,470 --> 00:29:39,400
addresses and things like that you

00:29:37,540 --> 00:29:41,290
should name something you should

00:29:39,400 --> 00:29:43,510
organize it with directories and you

00:29:41,290 --> 00:29:46,750
should have uniform access to all of

00:29:43,510 --> 00:29:49,810
this and uniform control at that data

00:29:46,750 --> 00:29:50,560
level are you allowed to even write to

00:29:49,810 --> 00:29:54,160
that stuff

00:29:50,560 --> 00:29:55,480
no give me a break you're a developer no

00:29:54,160 --> 00:29:58,560
way I would let you write to production

00:29:55,480 --> 00:30:06,400
data I should be able to say that and

00:29:58,560 --> 00:30:08,640
mean it so turns out I don't have my map

00:30:06,400 --> 00:30:11,080
our hat anymore because of certain other

00:30:08,640 --> 00:30:14,770
considerations but I used to wear a map

00:30:11,080 --> 00:30:18,280
art had a lot I still do you just can't

00:30:14,770 --> 00:30:21,280
see it and as it happens we have that

00:30:18,280 --> 00:30:23,770
right now we can inside the yamo

00:30:21,280 --> 00:30:27,580
configuration for a pod this is a very

00:30:23,770 --> 00:30:30,340
simple one all of this stuff is the the

00:30:27,580 --> 00:30:36,070
process itself but down here we say what

00:30:30,340 --> 00:30:40,780
about volumes and we can mount a volume

00:30:36,070 --> 00:30:43,360
directly inside the containers pathname

00:30:40,780 --> 00:30:46,660
so that it can see all the other data

00:30:43,360 --> 00:30:51,490
elements across an entire data platform

00:30:46,660 --> 00:30:55,150
cluster look I guess magnifying doesn't

00:30:51,490 --> 00:30:58,300
really help Stephanie so the idea here

00:30:55,150 --> 00:31:00,700
is cubelet is the element of kubernetes

00:30:58,300 --> 00:31:04,470
that actually invokes a container on a

00:31:00,700 --> 00:31:06,250
machine it would normally invoke docker

00:31:04,470 --> 00:31:08,530
docker would run

00:31:06,250 --> 00:31:11,140
the pod pod they had to have yet another

00:31:08,530 --> 00:31:13,360
buzzword you know so pod is several

00:31:11,140 --> 00:31:15,790
containers glued together that live on

00:31:13,360 --> 00:31:18,850
the single machine and the pod is run by

00:31:15,790 --> 00:31:20,830
docker and normally the pod would

00:31:18,850 --> 00:31:24,000
interact with machine resources directly

00:31:20,830 --> 00:31:27,430
all we have to do is add one plug-in

00:31:24,000 --> 00:31:29,800
this is a new capability like four

00:31:27,430 --> 00:31:33,370
months old in kubernetes just I guess

00:31:29,800 --> 00:31:38,500
medium old by kubernetes pace and that

00:31:33,370 --> 00:31:42,130
can then drive a fuse driver to access

00:31:38,500 --> 00:31:48,250
this data layer what that gives us is

00:31:42,130 --> 00:31:50,770
the ability to have data that spans the

00:31:48,250 --> 00:31:52,870
globe we can have files that exist

00:31:50,770 --> 00:31:55,090
wherever we want them we're going to

00:31:52,870 --> 00:31:57,430
have files of any scale we'd like we're

00:31:55,090 --> 00:32:00,040
going to have streams that come from a

00:31:57,430 --> 00:32:01,840
hundred data centers to one that live in

00:32:00,040 --> 00:32:04,330
all these places and we can build

00:32:01,840 --> 00:32:06,190
applications using the full power of

00:32:04,330 --> 00:32:09,270
kubernetes and now with the full power

00:32:06,190 --> 00:32:14,050
of the comparable state abstraction

00:32:09,270 --> 00:32:16,780
below it the plugin is a kubernetes

00:32:14,050 --> 00:32:20,920
operation no per node attention is

00:32:16,780 --> 00:32:24,460
required no pod changes are required you

00:32:20,920 --> 00:32:27,670
can take a standard my sequel pod out of

00:32:24,460 --> 00:32:31,150
the repository and run it against this

00:32:27,670 --> 00:32:35,050
state layer transparently with zero

00:32:31,150 --> 00:32:37,930
changes and we can scale compute and

00:32:35,050 --> 00:32:41,860
storage completely independently and

00:32:37,930 --> 00:32:44,680
they can Co reside so state is no longer

00:32:41,860 --> 00:32:46,210
a dirty word for kubernetes even

00:32:44,680 --> 00:32:49,570
high-performance computing can be done

00:32:46,210 --> 00:32:53,710
at its level things like gigabytes tens

00:32:49,570 --> 00:32:56,290
of gigabytes per second per node and we

00:32:53,710 --> 00:32:58,840
can do the boring things as well on

00:32:56,290 --> 00:33:00,610
kubernetes without having storage

00:32:58,840 --> 00:33:02,860
appliances we can integrate that

00:33:00,610 --> 00:33:06,280
directly into the computation cluster

00:33:02,860 --> 00:33:09,340
and previously crazy things now become

00:33:06,280 --> 00:33:12,250
mundane and hopefully certain aspects of

00:33:09,340 --> 00:33:14,890
computing become boring now we've got

00:33:12,250 --> 00:33:18,620
some additional resources books Ellen

00:33:14,890 --> 00:33:21,030
and I are there's Ellen co-author

00:33:18,620 --> 00:33:24,120
have written a number of books about

00:33:21,030 --> 00:33:25,200
deployment and production considerations

00:33:24,120 --> 00:33:28,490
in machine learning

00:33:25,200 --> 00:33:30,570
streaming architecture machine learning

00:33:28,490 --> 00:33:32,549
recommendations and anomaly detection

00:33:30,570 --> 00:33:36,299
there's other things like blogs and so

00:33:32,549 --> 00:33:39,809
on and we have a new one about to come

00:33:36,299 --> 00:33:42,990
out about this idea of data systems in

00:33:39,809 --> 00:33:47,660
production now I'd like to point out

00:33:42,990 --> 00:33:50,640
that when I was in Malaysia last year

00:33:47,660 --> 00:33:53,280
the audience was roughly half women this

00:33:50,640 --> 00:33:55,559
is an Islamic country presumably not so

00:33:53,280 --> 00:33:58,290
advanced Here I am in Germany much more

00:33:55,559 --> 00:34:01,919
advanced and where we got a quarter we

00:33:58,290 --> 00:34:05,850
got a road to hoe we can do better so

00:34:01,919 --> 00:34:09,690
anyway let's engage questions we still

00:34:05,850 --> 00:34:12,480
have several minutes not a whole lot but

00:34:09,690 --> 00:34:14,330
enough yeah if there are questions let's

00:34:12,480 --> 00:34:19,220
talk about it

00:34:14,330 --> 00:34:23,940
yeah large so could you comment on the

00:34:19,220 --> 00:34:25,350
differences to other solutions for state

00:34:23,940 --> 00:34:27,330
income bananas for example there is

00:34:25,350 --> 00:34:30,030
something called like persistent sets or

00:34:27,330 --> 00:34:31,290
yeah and also you have if you're in the

00:34:30,030 --> 00:34:34,619
cloud you have the option of light

00:34:31,290 --> 00:34:36,570
mounting of a volume into your

00:34:34,619 --> 00:34:37,859
containers for example if you in Google

00:34:36,570 --> 00:34:41,850
Cloud you can say I want this more

00:34:37,859 --> 00:34:43,980
volume mounted yeah and related that do

00:34:41,850 --> 00:34:45,540
you support multiple writers because I

00:34:43,980 --> 00:34:48,419
guess that's yeah I know the difference

00:34:45,540 --> 00:34:52,740
and very good question there are other

00:34:48,419 --> 00:34:55,740
options for state so you can build

00:34:52,740 --> 00:34:57,420
things that are transmitted to all of

00:34:55,740 --> 00:34:59,490
the containers or all of the containers

00:34:57,420 --> 00:35:02,640
part of the cluster in a read-only

00:34:59,490 --> 00:35:05,400
fashion that's that's a very nice thing

00:35:02,640 --> 00:35:07,530
and those can be these volume sets or

00:35:05,400 --> 00:35:10,590
they can be secrets or they can be

00:35:07,530 --> 00:35:12,960
configured if uhrin twice depending on

00:35:10,590 --> 00:35:16,350
what scale they are you could also have

00:35:12,960 --> 00:35:20,580
a classic storage appliance a San or or

00:35:16,350 --> 00:35:23,420
an ass that you just access and and you

00:35:20,580 --> 00:35:26,820
would have a fixed size and very limited

00:35:23,420 --> 00:35:29,570
bandwidth type of tool there you can

00:35:26,820 --> 00:35:34,050
also if you are in Google's cloud access

00:35:29,570 --> 00:35:35,220
Google's tables and Google's blobs you

00:35:34,050 --> 00:35:37,680
don't usually get access to

00:35:35,220 --> 00:35:40,410
honest-to-god files you couldn't

00:35:37,680 --> 00:35:45,510
normally run for instance on a page blob

00:35:40,410 --> 00:35:47,790
in Microsoft Azure you can't run my

00:35:45,510 --> 00:35:51,030
sequel for instance because those are

00:35:47,790 --> 00:35:54,600
single large blobs that are immutable

00:35:51,030 --> 00:35:56,670
and those are also accessible and this

00:35:54,600 --> 00:35:57,990
is you alluded to that in the last part

00:35:56,670 --> 00:36:01,980
of your question those are accessible

00:35:57,990 --> 00:36:04,020
typically from one part one system only

00:36:01,980 --> 00:36:08,010
whereas what we're talking about here is

00:36:04,020 --> 00:36:10,830
a completely distributed data system so

00:36:08,010 --> 00:36:14,790
the differences are typically very

00:36:10,830 --> 00:36:17,250
limited semantics usually for

00:36:14,790 --> 00:36:20,670
large-scale things right once readable

00:36:17,250 --> 00:36:22,170
many limited semantics in that if they

00:36:20,670 --> 00:36:25,350
are updatable they're almost always

00:36:22,170 --> 00:36:28,109
updatable only from one machine or only

00:36:25,350 --> 00:36:30,900
slowly and limited semantics in that

00:36:28,109 --> 00:36:33,359
they're almost always just file like or

00:36:30,900 --> 00:36:35,640
blob like very rarely are they

00:36:33,359 --> 00:36:38,580
integrated with streams files and tables

00:36:35,640 --> 00:36:41,310
those are the three life cycles of bytes

00:36:38,580 --> 00:36:42,900
that I see in real applications and I

00:36:41,310 --> 00:36:45,650
don't see any reason that they shouldn't

00:36:42,900 --> 00:36:47,460
all be primitive when we have a

00:36:45,650 --> 00:36:50,310
transient state right now where people

00:36:47,460 --> 00:36:50,790
implement their own so that's the big

00:36:50,310 --> 00:36:54,510
difference

00:36:50,790 --> 00:36:57,900
and the results are geo distribution and

00:36:54,510 --> 00:37:01,440
the ability to be cloud neutral we have

00:36:57,900 --> 00:37:04,109
a humongous battle of the gods forming

00:37:01,440 --> 00:37:09,150
right now as to who will own the future

00:37:04,109 --> 00:37:11,940
of computing and as you're fighting

00:37:09,150 --> 00:37:17,910
against the other Easter you know Amazon

00:37:11,940 --> 00:37:21,030
and the key question there is can they

00:37:17,910 --> 00:37:24,420
lock in computing or can people make

00:37:21,030 --> 00:37:26,609
them be commodity providers where they

00:37:24,420 --> 00:37:29,310
can switch easily and so the key

00:37:26,609 --> 00:37:32,100
question there is cloud neutrality can I

00:37:29,310 --> 00:37:34,109
run exactly the same code in multiple

00:37:32,100 --> 00:37:37,140
clouds and that is something you get

00:37:34,109 --> 00:37:40,109
with this approach that's a big deal if

00:37:37,140 --> 00:37:41,730
you've ever bought Oracle you understand

00:37:40,109 --> 00:37:45,390
that the future is going to be much

00:37:41,730 --> 00:37:48,810
worse if we don't commoditize

00:37:45,390 --> 00:37:51,520
other questions

00:37:48,810 --> 00:37:52,450
the man is twitting you know this is

00:37:51,520 --> 00:37:55,480
like an auction

00:37:52,450 --> 00:37:57,369
if you twitch it you you may have to ask

00:37:55,480 --> 00:37:58,810
a question even if you didn't know what

00:37:57,369 --> 00:38:04,210
to question you would have here's one

00:37:58,810 --> 00:38:06,310
buddy who's really asking ya remember an

00:38:04,210 --> 00:38:09,430
original Hadoop that people always like

00:38:06,310 --> 00:38:12,880
data locality can you elaborate a little

00:38:09,430 --> 00:38:15,040
bit on how this is supposed to work now

00:38:12,880 --> 00:38:17,230
that and everything is even more

00:38:15,040 --> 00:38:19,300
distributed it's like you know you

00:38:17,230 --> 00:38:22,869
wanted to to run your computations about

00:38:19,300 --> 00:38:26,560
your data boys and so on so let's talk

00:38:22,869 --> 00:38:29,680
about this right there and the question

00:38:26,560 --> 00:38:32,770
was about data locality and that's a

00:38:29,680 --> 00:38:35,740
classic thing in Hadoop now in Hadoop

00:38:32,770 --> 00:38:38,560
with HDFS there's a very large ratio

00:38:35,740 --> 00:38:41,530
between the speed local and the speed

00:38:38,560 --> 00:38:44,320
distant it because being local you can

00:38:41,530 --> 00:38:46,480
actually be passed a file descriptor for

00:38:44,320 --> 00:38:48,940
the blocks it's called the read bypass

00:38:46,480 --> 00:38:51,369
it bypasses a lot of the abstraction

00:38:48,940 --> 00:38:55,240
layers and most importantly it bypasses

00:38:51,369 --> 00:38:56,859
about three copies that's a pretty

00:38:55,240 --> 00:39:01,150
cheesy way to build a file system

00:38:56,859 --> 00:39:05,970
frankly and that ratio if you build a

00:39:01,150 --> 00:39:09,760
file system well is much smaller so off

00:39:05,970 --> 00:39:12,160
system we can maintain 16 gigabytes per

00:39:09,760 --> 00:39:15,670
second reads from a system if you have

00:39:12,160 --> 00:39:18,160
enough network obviously on system we

00:39:15,670 --> 00:39:21,849
can only go about 20 percent higher than

00:39:18,160 --> 00:39:24,220
that so that's if the network is fast

00:39:21,849 --> 00:39:27,339
enough obviously if you have 100 megabit

00:39:24,220 --> 00:39:29,500
network and you have 48 drives then it's

00:39:27,339 --> 00:39:31,089
pretty stupid to try to do anything off

00:39:29,500 --> 00:39:33,400
of that machine because it's it's worse

00:39:31,089 --> 00:39:38,140
than your home network

00:39:33,400 --> 00:39:39,550
I suppose that's being done pretty often

00:39:38,140 --> 00:39:42,460
and then people wonder why things get

00:39:39,550 --> 00:39:45,359
slow so so so you have to balance the

00:39:42,460 --> 00:39:49,720
hardware so you you have something like

00:39:45,359 --> 00:39:54,250
24 drives for 1 or 2 or 3 10 gigabit

00:39:49,720 --> 00:39:57,580
links if you have 16 nvme flash drives

00:39:54,250 --> 00:39:59,620
then you have 400 gigabit links

00:39:57,580 --> 00:40:02,260
you balance the hardware when you buy it

00:39:59,620 --> 00:40:03,880
and and that stays pretty well balanced

00:40:02,260 --> 00:40:06,850
later and then if you have good software

00:40:03,880 --> 00:40:10,470
it doesn't matter as much now in the

00:40:06,850 --> 00:40:13,120
meantime kubernetes can be given hints

00:40:10,470 --> 00:40:16,210
about which machines have which data

00:40:13,120 --> 00:40:18,400
assets and then the applications when

00:40:16,210 --> 00:40:20,440
they run can give hints back about which

00:40:18,400 --> 00:40:23,620
data assets they would like to be near

00:40:20,440 --> 00:40:25,560
and a good data platform before I have

00:40:23,620 --> 00:40:30,220
one I'm trying not to say that too much

00:40:25,560 --> 00:40:32,650
can also control where things live so I

00:40:30,220 --> 00:40:34,420
can say private things live here machine

00:40:32,650 --> 00:40:38,410
learning training sets live next to the

00:40:34,420 --> 00:40:42,100
GPUs and we can control that so similar

00:40:38,410 --> 00:40:44,140
mechanism similar considerations as with

00:40:42,100 --> 00:40:46,840
a dupe but the numbers are all different

00:40:44,140 --> 00:40:49,360
the ratios have changed and so we have

00:40:46,840 --> 00:40:52,560
to reanalyze what we need but we also

00:40:49,360 --> 00:40:56,890
have to give knobs and controls to

00:40:52,560 --> 00:40:59,230
manage that yeah thank you very much

00:40:56,890 --> 00:41:01,050
that thank you and I hope you enjoyed it

00:40:59,230 --> 00:41:04,149
it I'll be around

00:41:01,050 --> 00:41:04,149
[Applause]

00:41:06,570 --> 00:41:08,630

YouTube URL: https://www.youtube.com/watch?v=0UaC1tGdDe4


