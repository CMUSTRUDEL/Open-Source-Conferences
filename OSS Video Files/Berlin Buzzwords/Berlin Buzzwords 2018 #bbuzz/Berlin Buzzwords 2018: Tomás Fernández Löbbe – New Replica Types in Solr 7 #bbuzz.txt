Title: Berlin Buzzwords 2018: Tomás Fernández Löbbe – New Replica Types in Solr 7 #bbuzz
Publication date: 2018-06-14
Playlist: Berlin Buzzwords 2018 #bbuzz
Description: 
	For the majority of cases, the current SolrCloud distributed indexing works great. There is a subset of use cases for which Solr's legacy Master/Slave replication may be a better fit, like cases where NRT is not required, and where read availability is more important than consistency. Solr 7 now ships with three different types of replicas to choose depending on different consistency and availability needs. 

With a combination of replica types, one can create a SolrCloud cluster that behaves like the Master/Slave architecture from Solr lower than 4.0 and provides separation of responsibilities (search vs index) while still getting most of the SolrCloud benefits, like high availability of writes, replica discovery, collections API, etc. 

This talk will be a deep dive into the new Replica Type feature: reasons for implementing it, differences between the types and how/why one would choose to use them, and implementation details of the feature.

Read more:
https://2018.berlinbuzzwords.de/18/session/new-replica-types-solr-7

About Tomás Fernández Löbbe:
https://2018.berlinbuzzwords.de/users/tomas-fernandez-lobbe

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:04,560 --> 00:00:09,450
yeah thank you for coming for my talk to

00:00:06,690 --> 00:00:13,709
my talk this is about replica types a

00:00:09,450 --> 00:00:16,440
new feature added in solar 7 this is the

00:00:13,709 --> 00:00:18,120
agenda for my talk first for context and

00:00:16,440 --> 00:00:20,369
history maybe we're going to start

00:00:18,120 --> 00:00:23,130
talking about scaling in solar how it

00:00:20,369 --> 00:00:24,560
was before solar cloud how it is in

00:00:23,130 --> 00:00:27,420
solar cloud

00:00:24,560 --> 00:00:31,260
why or what things are we trying to

00:00:27,420 --> 00:00:32,850
address with replica types then with

00:00:31,260 --> 00:00:35,760
which replica table types were added

00:00:32,850 --> 00:00:37,019
then one of the use cases that you can

00:00:35,760 --> 00:00:38,690
achieve with replica types which is

00:00:37,019 --> 00:00:43,079
having some sort of master slave

00:00:38,690 --> 00:00:45,329
architecture in solar cloud then how to

00:00:43,079 --> 00:00:47,909
use them and some to do some future work

00:00:45,329 --> 00:00:52,710
or think things that needs to be done or

00:00:47,909 --> 00:00:54,659
that can be done yeah so before we first

00:00:52,710 --> 00:00:56,100
saw a cloud the first order for the way

00:00:54,659 --> 00:00:58,679
to scale solar was by doing a

00:00:56,100 --> 00:01:00,659
master/slave architecture where all the

00:00:58,679 --> 00:01:02,729
updates would go to the master and all

00:01:00,659 --> 00:01:04,650
the queries would go to the slave then

00:01:02,729 --> 00:01:07,290
in the background the slave would be

00:01:04,650 --> 00:01:09,390
doing a segment replication and copying

00:01:07,290 --> 00:01:12,930
the latest updates from the master to

00:01:09,390 --> 00:01:15,689
the slave this works

00:01:12,930 --> 00:01:18,990
this works pretty well to some extent I

00:01:15,689 --> 00:01:22,680
had some issues before I go into that

00:01:18,990 --> 00:01:25,649
just some key concepts required to

00:01:22,680 --> 00:01:27,539
understand segment replication solar is

00:01:25,649 --> 00:01:30,329
built on top of a bachelor since most

00:01:27,539 --> 00:01:32,939
people already know that the way solar

00:01:30,329 --> 00:01:35,100
stores in stores the index is by writing

00:01:32,939 --> 00:01:38,700
segments as you continue adding

00:01:35,100 --> 00:01:41,670
documents to solar at or to the scene it

00:01:38,700 --> 00:01:44,670
will ask every time you open a new

00:01:41,670 --> 00:01:46,229
searcher or you do a comment or every

00:01:44,670 --> 00:01:48,750
time the memory buffer fields is going

00:01:46,229 --> 00:01:50,640
to write a new segment to disk and the

00:01:48,750 --> 00:01:52,439
important part is that that segment once

00:01:50,640 --> 00:01:55,079
it's written in never it never changes

00:01:52,439 --> 00:01:57,270
okay there's going to be another thread

00:01:55,079 --> 00:01:59,609
that's going to be choosing segments and

00:01:57,270 --> 00:02:01,409
merging them merging those creating a

00:01:59,609 --> 00:02:05,929
new bigger segment and then dropping the

00:02:01,409 --> 00:02:08,610
old ones so solar uses these

00:02:05,929 --> 00:02:10,710
characteristic of the Lucian indexing to

00:02:08,610 --> 00:02:14,220
to perform segment replication and the

00:02:10,710 --> 00:02:15,540
way it works is that the slave server is

00:02:14,220 --> 00:02:17,819
going to ask the master hey which

00:02:15,540 --> 00:02:18,330
segments do you have the master is going

00:02:17,819 --> 00:02:20,190
to explain

00:02:18,330 --> 00:02:21,960
to say I have segments in this case for

00:02:20,190 --> 00:02:24,660
example it would say I have segment 1 2

00:02:21,960 --> 00:02:26,610
& 3 the slave is going to compare the

00:02:24,660 --> 00:02:30,000
segments that the master has versus what

00:02:26,610 --> 00:02:34,410
will suffice and download only the

00:02:30,000 --> 00:02:37,980
updated the new segments and since since

00:02:34,410 --> 00:02:39,330
he knows that the segment wanted to

00:02:37,980 --> 00:02:42,420
didn't change he doesn't need to

00:02:39,330 --> 00:02:44,640
download memory again this strategy does

00:02:42,420 --> 00:02:46,980
not support near-real-time so you cannot

00:02:44,640 --> 00:02:49,980
open a any real-time structure on top of

00:02:46,980 --> 00:02:52,260
of those segments until so you need to

00:02:49,980 --> 00:02:53,790
Hart commit get the get the latest

00:02:52,260 --> 00:02:57,300
segments and then open a searcher and

00:02:53,790 --> 00:02:58,230
that's when it's available for search so

00:02:57,300 --> 00:03:01,260
this worked very well

00:02:58,230 --> 00:03:02,820
it has some issues a lot of all the

00:03:01,260 --> 00:03:04,830
configuration for master slave before

00:03:02,820 --> 00:03:06,450
solar cloud was manual you had to

00:03:04,830 --> 00:03:09,840
specify who was the master who was the

00:03:06,450 --> 00:03:12,060
slave also there was no high

00:03:09,840 --> 00:03:15,240
availability for rights so if the master

00:03:12,060 --> 00:03:16,830
go down the updates would fail the good

00:03:15,240 --> 00:03:20,280
thing is that the queries would still

00:03:16,830 --> 00:03:21,930
succeed and then you would have to get

00:03:20,280 --> 00:03:23,730
go fix that master or add some other

00:03:21,930 --> 00:03:26,810
node to become a master but that again

00:03:23,730 --> 00:03:29,580
is manual work so then with solar for

00:03:26,810 --> 00:03:31,800
solar cloud came solar cloud is

00:03:29,580 --> 00:03:34,500
essentially just the set of features of

00:03:31,800 --> 00:03:37,709
or capabilities added to solar to have a

00:03:34,500 --> 00:03:40,650
high availability no recovery no

00:03:37,709 --> 00:03:43,800
discovery automatic load balancing all

00:03:40,650 --> 00:03:46,080
those things one of the main features

00:03:43,800 --> 00:03:50,190
added to solar cloud was distributed

00:03:46,080 --> 00:03:52,260
indexing so you don't know no longer

00:03:50,190 --> 00:03:54,030
needed this segment replication in order

00:03:52,260 --> 00:03:56,310
to send the documents to the different

00:03:54,030 --> 00:03:58,470
replicas of a particular chart the way

00:03:56,310 --> 00:04:01,560
it works with distributed indexing is

00:03:58,470 --> 00:04:03,300
that when a user adds a document it will

00:04:01,560 --> 00:04:05,100
go to the leader if the leader doesn't

00:04:03,300 --> 00:04:06,570
receive it immediately with whoever

00:04:05,100 --> 00:04:08,640
receives that document is going to send

00:04:06,570 --> 00:04:10,140
it to the leader and then the leader is

00:04:08,640 --> 00:04:12,690
going to add that document locally and

00:04:10,140 --> 00:04:15,840
then send it to all the replicas of the

00:04:12,690 --> 00:04:17,580
shard all the followers each of those

00:04:15,840 --> 00:04:19,769
replicas are going to add the document

00:04:17,580 --> 00:04:21,090
locally and then respond to the use to

00:04:19,769 --> 00:04:22,979
the leader and then the leader will

00:04:21,090 --> 00:04:25,080
respond to the user we have your

00:04:22,979 --> 00:04:26,760
document the good thing about these

00:04:25,080 --> 00:04:29,970
strategies that now this supports me a

00:04:26,760 --> 00:04:32,039
real-time get sorry near real-time so

00:04:29,970 --> 00:04:32,370
those those replicas they can open a

00:04:32,039 --> 00:04:33,750
search

00:04:32,370 --> 00:04:35,520
and since they have everyday all the

00:04:33,750 --> 00:04:37,740
documents they can provide search for

00:04:35,520 --> 00:04:41,100
all the latest documents that it

00:04:37,740 --> 00:04:43,470
received another big feature added to

00:04:41,100 --> 00:04:46,370
solar cloud was a transaction log the

00:04:43,470 --> 00:04:48,600
transaction law is a certified that

00:04:46,370 --> 00:04:50,900
essentially it contains all the

00:04:48,600 --> 00:04:55,470
documents updated since the last commit

00:04:50,900 --> 00:04:57,030
and this these file is needed for for

00:04:55,470 --> 00:05:01,440
reals and get and it's also needed for

00:04:57,030 --> 00:05:04,050
recovering and also another feature was

00:05:01,440 --> 00:05:05,790
self recovery of notes right so what

00:05:04,050 --> 00:05:09,270
happens if in this situation where we

00:05:05,790 --> 00:05:11,100
had the distributed indexing as I was

00:05:09,270 --> 00:05:12,810
explaining before before but in this

00:05:11,100 --> 00:05:15,150
case the replica too for whatever reason

00:05:12,810 --> 00:05:17,850
couldn't respond to the update for

00:05:15,150 --> 00:05:20,510
example because it was either with some

00:05:17,850 --> 00:05:22,500
Network issue or the replica was down or

00:05:20,510 --> 00:05:24,360
there was some garbage collection or

00:05:22,500 --> 00:05:26,729
whatever reason it just can't respond to

00:05:24,360 --> 00:05:28,950
the leader what's going to happen is

00:05:26,729 --> 00:05:32,220
that replica one is going to proceed the

00:05:28,950 --> 00:05:33,510
same way and the leader is going to tell

00:05:32,220 --> 00:05:36,600
that replica that it needs to recover

00:05:33,510 --> 00:05:39,260
okay in some way so that replica is

00:05:36,600 --> 00:05:42,330
missing data and essentially it can't

00:05:39,260 --> 00:05:45,780
now that it's going to be in recovery

00:05:42,330 --> 00:05:50,160
state it can't provide search you can

00:05:45,780 --> 00:05:52,440
respond to search from users anymore and

00:05:50,160 --> 00:05:54,270
it needs to recover the way recovery

00:05:52,440 --> 00:05:57,210
works is that the replica once it's back

00:05:54,270 --> 00:05:59,550
up it notices that it's it's being put

00:05:57,210 --> 00:06:02,070
place in recovery so it's going to go to

00:05:59,550 --> 00:06:05,039
the leader hey I'm ready um I need to

00:06:02,070 --> 00:06:08,160
become active again the leader is going

00:06:05,039 --> 00:06:10,050
to start sending first every new update

00:06:08,160 --> 00:06:10,889
is going to be going to this replica

00:06:10,050 --> 00:06:13,349
that's intercutting

00:06:10,889 --> 00:06:15,539
and the replica instead of indexing that

00:06:13,349 --> 00:06:17,849
document is going to start buffering

00:06:15,539 --> 00:06:19,440
them and at the same time is going to

00:06:17,849 --> 00:06:21,750
start the first phase of recovering

00:06:19,440 --> 00:06:23,099
which is called piercing the piercing

00:06:21,750 --> 00:06:24,690
essentially is where the replica is

00:06:23,099 --> 00:06:26,280
going to ask the leader hey which

00:06:24,690 --> 00:06:29,130
documents did I miss this is the last

00:06:26,280 --> 00:06:31,020
document I got how many did I miss okay

00:06:29,130 --> 00:06:33,060
and the leader is going to say okay I

00:06:31,020 --> 00:06:36,599
have already this number of documents

00:06:33,060 --> 00:06:40,320
that you don't have is that number is

00:06:36,599 --> 00:06:41,550
small by default is less than 100 then

00:06:40,320 --> 00:06:43,650
the leader is going to start sending

00:06:41,550 --> 00:06:45,210
those documents individually to the

00:06:43,650 --> 00:06:46,080
replicas the replicas will update those

00:06:45,210 --> 00:06:48,360
in the in

00:06:46,080 --> 00:06:50,699
next and then replay the replay the

00:06:48,360 --> 00:06:52,199
buffer and then it becomes active but if

00:06:50,699 --> 00:06:54,690
the number of documents missing there is

00:06:52,199 --> 00:06:56,400
more than 100 or if you if you configure

00:06:54,690 --> 00:06:58,500
that to some other number to your

00:06:56,400 --> 00:07:00,599
particular number the way the replica

00:06:58,500 --> 00:07:02,099
will recover is by doing the same

00:07:00,599 --> 00:07:04,039
segment recovery that we were talking

00:07:02,099 --> 00:07:05,940
about in before he master slave

00:07:04,039 --> 00:07:08,129
essentially it will commit to the leader

00:07:05,940 --> 00:07:10,440
is going to start replication is going

00:07:08,129 --> 00:07:13,110
to download all the segments after that

00:07:10,440 --> 00:07:16,979
is going to replay the buffer and then

00:07:13,110 --> 00:07:20,479
become active so if the if all of these

00:07:16,979 --> 00:07:23,190
works then why do we need replica types

00:07:20,479 --> 00:07:25,740
in master slave one of the things that

00:07:23,190 --> 00:07:27,150
that was interesting was that the the

00:07:25,740 --> 00:07:30,090
indexing process and the searching

00:07:27,150 --> 00:07:32,699
process were were separated right so if

00:07:30,090 --> 00:07:35,610
you had like a expensive documents or a

00:07:32,699 --> 00:07:37,110
spike in number of updates they would

00:07:35,610 --> 00:07:39,240
not affect the search the search traffic

00:07:37,110 --> 00:07:40,469
the search latency or throughput or the

00:07:39,240 --> 00:07:42,870
other way around if you have a very

00:07:40,469 --> 00:07:45,210
expensive query and that would not

00:07:42,870 --> 00:07:46,560
affect the updates right this was not

00:07:45,210 --> 00:07:50,120
possible in solar cloud because now

00:07:46,560 --> 00:07:53,009
every replica does everything so

00:07:50,120 --> 00:07:56,849
expensive updates will affect queries

00:07:53,009 --> 00:07:58,259
and the other way around too so one of

00:07:56,849 --> 00:08:00,330
the nice things of the distributed

00:07:58,259 --> 00:08:02,669
indexing is that its support near

00:08:00,330 --> 00:08:04,349
real-time but some use cases don't

00:08:02,669 --> 00:08:07,409
really need near real-time some cases

00:08:04,349 --> 00:08:10,490
are okay with serving data that's mean

00:08:07,409 --> 00:08:14,449
it's old or I don't know seconds even

00:08:10,490 --> 00:08:14,449
even that may be fast

00:08:16,340 --> 00:08:21,300
also I need initiator recovery that

00:08:19,440 --> 00:08:23,159
recovery state can become a problem

00:08:21,300 --> 00:08:24,810
let's say you have a big cluster and

00:08:23,159 --> 00:08:26,430
there's some sort of network partition

00:08:24,810 --> 00:08:28,650
and the leader tries to send the update

00:08:26,430 --> 00:08:30,779
to its I don't know hundreds of replicas

00:08:28,650 --> 00:08:32,909
or whatever and one third of the one

00:08:30,779 --> 00:08:35,130
third of the replicas are cannot respond

00:08:32,909 --> 00:08:37,469
so all these replicas are going to go

00:08:35,130 --> 00:08:39,360
into recovery state state and that means

00:08:37,469 --> 00:08:41,070
that those replicas cannot serve such

00:08:39,360 --> 00:08:46,800
traffic anymore and that may be a

00:08:41,070 --> 00:08:48,510
problem for you also like like every

00:08:46,800 --> 00:08:51,060
replicas doing everything can sometimes

00:08:48,510 --> 00:08:53,850
be wasteful so let's say if you have a

00:08:51,060 --> 00:08:57,240
three node cluster a three replicas

00:08:53,850 --> 00:08:59,200
shard then you may be you may want that

00:08:57,240 --> 00:09:00,760
every replica has everything ever

00:08:59,200 --> 00:09:02,740
I can be leader and they have all the

00:09:00,760 --> 00:09:05,200
updates but if you have a 50 replica

00:09:02,740 --> 00:09:07,780
shard um that may not mean it you may

00:09:05,200 --> 00:09:10,380
not need that the 50 the 50 replicas are

00:09:07,780 --> 00:09:10,380
doing everything

00:09:10,690 --> 00:09:15,430
also in that recovery that I was showing

00:09:13,780 --> 00:09:18,460
with the piercing and the segment

00:09:15,430 --> 00:09:21,340
replication um with cases with higher

00:09:18,460 --> 00:09:23,470
throughput the piercing has little

00:09:21,340 --> 00:09:25,410
chance of succeeding because if it is

00:09:23,470 --> 00:09:27,910
like 100 documents which is the default

00:09:25,410 --> 00:09:30,130
100 documents maybe a second or two of

00:09:27,910 --> 00:09:33,880
coverage like slow garbage collection

00:09:30,130 --> 00:09:35,950
can can can cause this right and then

00:09:33,880 --> 00:09:37,660
especially again in high up high

00:09:35,950 --> 00:09:39,250
indexing throughput case is the number

00:09:37,660 --> 00:09:41,200
of segments that the replica needs to

00:09:39,250 --> 00:09:46,000
download maybe too many because it

00:09:41,200 --> 00:09:49,300
changes all the time right and this

00:09:46,000 --> 00:09:51,970
problem can happen in when recovering

00:09:49,300 --> 00:09:53,890
doing a segment replication so I show

00:09:51,970 --> 00:09:56,020
you before how in master slave the

00:09:53,890 --> 00:09:58,660
replication is somewhat incremental only

00:09:56,020 --> 00:10:00,070
the new segment sites are downloaded but

00:09:58,660 --> 00:10:03,310
let's think about this case where you

00:10:00,070 --> 00:10:06,310
have three nodes a B and C is the leader

00:10:03,310 --> 00:10:09,340
and C is in recovery let's assume for

00:10:06,310 --> 00:10:11,470
now that the that the piercing fails so

00:10:09,340 --> 00:10:13,420
node C is going to go and say the leader

00:10:11,470 --> 00:10:15,670
hey which which segments do I need to

00:10:13,420 --> 00:10:19,420
download and the leader is going to say

00:10:15,670 --> 00:10:21,340
I have segments a1 and a2 note C is

00:10:19,420 --> 00:10:24,760
going to say okay have segment c1 and

00:10:21,340 --> 00:10:26,440
then not a is going to say now that's

00:10:24,760 --> 00:10:28,900
fine you don't need that one throw it

00:10:26,440 --> 00:10:30,220
away download in a1 and a2 so

00:10:28,900 --> 00:10:33,880
essentially is doing a food segment a

00:10:30,220 --> 00:10:38,050
full index replication okay that he did

00:10:33,880 --> 00:10:39,400
Rob Nazis Achtung now it's working some

00:10:38,050 --> 00:10:42,490
time passes and then it goes into

00:10:39,400 --> 00:10:43,810
recovery again now the leader is not

00:10:42,490 --> 00:10:45,910
being there was a leader change and

00:10:43,810 --> 00:10:48,850
nobody has its own segments because

00:10:45,910 --> 00:10:51,220
every every rep guys I think is indexing

00:10:48,850 --> 00:10:52,780
locally is merging locally so each each

00:10:51,220 --> 00:10:57,430
replica would have its own its segments

00:10:52,780 --> 00:10:58,570
right so not be so don't think it's

00:10:57,430 --> 00:11:01,630
going to go to the leader and say hey

00:10:58,570 --> 00:11:03,570
who which segments do I need and nobody

00:11:01,630 --> 00:11:05,590
is going to say you need b1 b2 and b3

00:11:03,570 --> 00:11:07,600
okay I have a1 and a2

00:11:05,590 --> 00:11:11,260
throw those away just download the full

00:11:07,600 --> 00:11:14,500
index again yeah and

00:11:11,260 --> 00:11:16,950
this can be a problem so to address some

00:11:14,500 --> 00:11:20,920
of these issues we are the replica types

00:11:16,950 --> 00:11:22,330
three types of replicas we're added NRT

00:11:20,920 --> 00:11:24,760
that stands for near-real-time

00:11:22,330 --> 00:11:29,050
Dillo that stands for transaction log

00:11:24,760 --> 00:11:30,670
and pool because it pulls in this inner

00:11:29,050 --> 00:11:32,230
team replicas is not really a new type

00:11:30,670 --> 00:11:34,180
this is essentially the name that we

00:11:32,230 --> 00:11:37,450
gave to the existing types in solar

00:11:34,180 --> 00:11:39,550
cloud and this is exactly the same it

00:11:37,450 --> 00:11:41,950
will do that the replication is the same

00:11:39,550 --> 00:11:44,230
it will handle the updates the same way

00:11:41,950 --> 00:11:45,730
that it was doing before there's no

00:11:44,230 --> 00:11:48,190
change again this is the replica that

00:11:45,730 --> 00:11:49,750
existed today when a document is added

00:11:48,190 --> 00:11:52,330
the leader is going to add it locally

00:11:49,750 --> 00:11:55,060
update the transaction log send it to

00:11:52,330 --> 00:11:56,970
all the new real-time replicas and then

00:11:55,060 --> 00:11:59,380
they are going to index the document

00:11:56,970 --> 00:12:01,870
update the transaction log and respond

00:11:59,380 --> 00:12:03,280
and then respond to the user so for now

00:12:01,870 --> 00:12:05,200
let's not think about what type of

00:12:03,280 --> 00:12:06,340
replica the leader is in this case let's

00:12:05,200 --> 00:12:10,660
just think about the replica on the

00:12:06,340 --> 00:12:11,980
right yeah so new real-time replicas

00:12:10,660 --> 00:12:14,440
they support everything that solar costs

00:12:11,980 --> 00:12:16,510
firstly they support soft commits they

00:12:14,440 --> 00:12:22,210
support real-time gets they can become

00:12:16,510 --> 00:12:23,980
leaders the this the Telegraph Rica is

00:12:22,210 --> 00:12:25,570
one of the new types added and

00:12:23,980 --> 00:12:28,060
essentially it works it works very

00:12:25,570 --> 00:12:29,710
similar to near real-time the difference

00:12:28,060 --> 00:12:31,540
is that when a telegraphic are receives

00:12:29,710 --> 00:12:34,150
an update it will update the transaction

00:12:31,540 --> 00:12:35,590
log but it won't update the index ok it

00:12:34,150 --> 00:12:38,950
will respond to the leader I have the

00:12:35,590 --> 00:12:40,690
document but it won't be available for

00:12:38,950 --> 00:12:42,910
search until the till of replicas will

00:12:40,690 --> 00:12:47,200
do a periodic replication from the

00:12:42,910 --> 00:12:49,050
leader ok so essentially the tiller will

00:12:47,200 --> 00:12:52,180
only will you continuously do

00:12:49,050 --> 00:12:53,740
replication and it will only update the

00:12:52,180 --> 00:12:56,560
transaction log whenever Hanna updates

00:12:53,740 --> 00:12:58,960
if she is received because it works like

00:12:56,560 --> 00:13:01,810
this Tillich replicas do not support any

00:12:58,960 --> 00:13:05,380
real-time and they also do not support

00:13:01,810 --> 00:13:07,480
real-time gets the third type of

00:13:05,380 --> 00:13:09,600
replicas is pull replicas the pull

00:13:07,480 --> 00:13:12,280
replicas are slightly different because

00:13:09,600 --> 00:13:14,800
what they do is that they don't even

00:13:12,280 --> 00:13:16,150
receive updates from the leader the only

00:13:14,800 --> 00:13:17,800
the only thing they do is like a

00:13:16,150 --> 00:13:19,120
periodic replication the same

00:13:17,800 --> 00:13:20,980
replication that the tea logs to

00:13:19,120 --> 00:13:22,440
understand replication that master slave

00:13:20,980 --> 00:13:27,240
used to do

00:13:22,440 --> 00:13:29,250
so pull replicas cannot support the soft

00:13:27,240 --> 00:13:31,200
commits do not support real-time gets

00:13:29,250 --> 00:13:33,300
and they actually cannot become leaders

00:13:31,200 --> 00:13:35,850
because there are missing they don't

00:13:33,300 --> 00:13:39,390
have all the latest data so why are they

00:13:35,850 --> 00:13:40,890
good for essentially the best thing

00:13:39,390 --> 00:13:42,660
about that the pull replicas is that

00:13:40,890 --> 00:13:44,670
they cannot go into leader initiated

00:13:42,660 --> 00:13:47,790
recovery so because the leader is not

00:13:44,670 --> 00:13:49,020
trying to contact them for updates that

00:13:47,790 --> 00:13:50,820
replica is not going to in place in

00:13:49,020 --> 00:13:52,590
recovery even if there is some sort of

00:13:50,820 --> 00:13:55,050
network issue between the leader and the

00:13:52,590 --> 00:13:56,610
replica as long as the rep as the full

00:13:55,050 --> 00:14:00,870
replica still connected to zookeeper is

00:13:56,610 --> 00:14:02,370
going to remain active that means of

00:14:00,870 --> 00:14:04,890
course that it can become out-of-date

00:14:02,370 --> 00:14:06,180
so it could be if this if this problem

00:14:04,890 --> 00:14:07,950
between the leader and the pull replica

00:14:06,180 --> 00:14:10,080
remains there for a long time pull

00:14:07,950 --> 00:14:14,460
replica could be serving all all data

00:14:10,080 --> 00:14:15,750
for some time so in summary near

00:14:14,460 --> 00:14:17,730
real-time replicas they write to the

00:14:15,750 --> 00:14:19,980
index they write to the transaction log

00:14:17,730 --> 00:14:21,930
they receive every update and they

00:14:19,980 --> 00:14:24,120
replicate periodically sorry and they do

00:14:21,930 --> 00:14:26,640
not replicate periodically tillich

00:14:24,120 --> 00:14:28,410
replicas do not write the index they do

00:14:26,640 --> 00:14:30,060
write the transaction though they

00:14:28,410 --> 00:14:31,980
receive every update and they replicate

00:14:30,060 --> 00:14:34,740
periodically and see how there is an

00:14:31,980 --> 00:14:36,420
asterick in the till log doesn't write

00:14:34,740 --> 00:14:38,850
to the index and the reason for this is

00:14:36,420 --> 00:14:41,190
that when the telegraphic ayah becomes

00:14:38,850 --> 00:14:43,710
leader it will behave exactly as a near

00:14:41,190 --> 00:14:46,290
real-time so it will the telegraphic are

00:14:43,710 --> 00:14:48,060
that is leader is going to write to the

00:14:46,290 --> 00:14:51,960
index okay so that every one every other

00:14:48,060 --> 00:14:54,330
telegraphic I can replicate from pull

00:14:51,960 --> 00:14:55,860
replicas do not write to the index do

00:14:54,330 --> 00:14:57,480
not write to the transaction log they

00:14:55,860 --> 00:14:59,250
receive they do not receive every update

00:14:57,480 --> 00:15:02,190
and they replicate periodically from the

00:14:59,250 --> 00:15:05,250
leader so to show the data flow again

00:15:02,190 --> 00:15:07,970
let's say you have these two log two

00:15:05,250 --> 00:15:10,320
telegraphic ass and pull replica

00:15:07,970 --> 00:15:11,820
when an update is received it will go to

00:15:10,320 --> 00:15:14,490
the index and the transaction log of

00:15:11,820 --> 00:15:16,740
note a which again is a telegraphic abut

00:15:14,490 --> 00:15:18,420
because it's a leader its indexing it

00:15:16,740 --> 00:15:21,090
will go to the transaction log of all

00:15:18,420 --> 00:15:22,980
the node all the other T log replicas

00:15:21,090 --> 00:15:24,840
and then the index is going to be

00:15:22,980 --> 00:15:30,000
replicated for all the T log or full

00:15:24,840 --> 00:15:31,470
replicas so what do they support near

00:15:30,000 --> 00:15:32,760
real-time replicas again it supports

00:15:31,470 --> 00:15:33,210
everything that solar cloud supports

00:15:32,760 --> 00:15:35,820
right now

00:15:33,210 --> 00:15:38,010
soft commits real-time gets they

00:15:35,820 --> 00:15:40,320
can become leader and they can go into

00:15:38,010 --> 00:15:42,780
leader initiated recovery Telegraph

00:15:40,320 --> 00:15:44,430
bigges do not support off commits do not

00:15:42,780 --> 00:15:46,830
support real-time get again there's an

00:15:44,430 --> 00:15:48,840
asterisk here they can become the leader

00:15:46,830 --> 00:15:50,310
by apply so when a deal of replica needs

00:15:48,840 --> 00:15:51,300
to become a leader essentially it will

00:15:50,310 --> 00:15:53,790
apply everything that's in the

00:15:51,300 --> 00:15:56,910
transaction log and it has the most

00:15:53,790 --> 00:15:59,550
recent data and they can go into either

00:15:56,910 --> 00:16:02,460
initiate a recovery and again the

00:15:59,550 --> 00:16:03,930
asterisk here is because that's not

00:16:02,460 --> 00:16:05,460
super real-time get as long as you are

00:16:03,930 --> 00:16:06,840
not the leader if you had a deal log and

00:16:05,460 --> 00:16:10,560
you're the leader and you do variate and

00:16:06,840 --> 00:16:12,000
get it will respond and pull replicas do

00:16:10,560 --> 00:16:13,890
not support soft commits they do not

00:16:12,000 --> 00:16:15,810
support yet then get they cannot become

00:16:13,890 --> 00:16:18,210
leaders but they can also not go into

00:16:15,810 --> 00:16:21,960
the canticle go to leader initiated

00:16:18,210 --> 00:16:24,330
recovering yeah so now when you create a

00:16:21,960 --> 00:16:25,980
collection in solar you can specify the

00:16:24,330 --> 00:16:28,440
number of replicas that we want of each

00:16:25,980 --> 00:16:30,990
type right right or when you wanna add a

00:16:28,440 --> 00:16:33,210
shard but not all the combinations of

00:16:30,990 --> 00:16:36,180
replicas types are supported or

00:16:33,210 --> 00:16:38,310
recommended these are the the

00:16:36,180 --> 00:16:40,380
recommendations for combinations of

00:16:38,310 --> 00:16:43,050
replicas types first it's all in real

00:16:40,380 --> 00:16:45,150
time that again this is the default if

00:16:43,050 --> 00:16:47,010
the existing before seven and if you

00:16:45,150 --> 00:16:49,770
don't specify replica type is going to

00:16:47,010 --> 00:16:51,090
go into this configuration and this is

00:16:49,770 --> 00:16:54,300
the only configuration that would

00:16:51,090 --> 00:16:55,830
support any real-time and otherwise is

00:16:54,300 --> 00:16:58,350
also recommended for small to medium

00:16:55,830 --> 00:17:00,870
clusters or when the indexing throughput

00:16:58,350 --> 00:17:04,829
is not too high you can also choose to

00:17:00,870 --> 00:17:06,390
have all telegraphic ass and you would

00:17:04,829 --> 00:17:08,910
use this combination when there's no

00:17:06,390 --> 00:17:11,939
need for any real-time when there's high

00:17:08,910 --> 00:17:15,300
update throughput or when there's medium

00:17:11,939 --> 00:17:17,160
to high medium to big cluster but you

00:17:15,300 --> 00:17:21,240
still want every replica to have every

00:17:17,160 --> 00:17:22,740
document and then set of T log plot plus

00:17:21,240 --> 00:17:25,620
a set of pool replicas that's also a

00:17:22,740 --> 00:17:27,570
good combi combination and you would use

00:17:25,620 --> 00:17:31,140
it when you don't need near real-time

00:17:27,570 --> 00:17:35,120
when the update throughput is high when

00:17:31,140 --> 00:17:38,100
from medium or to big clusters or with

00:17:35,120 --> 00:17:40,050
high or high throughput but also where

00:17:38,100 --> 00:17:44,990
you prefer search availability over near

00:17:40,050 --> 00:17:48,390
real-time or consistency this last two

00:17:44,990 --> 00:17:49,160
combinations also have another benefit

00:17:48,390 --> 00:17:51,350
is

00:17:49,160 --> 00:17:53,030
that issue would recovery that I was

00:17:51,350 --> 00:17:55,550
mentioning before it's not a problem

00:17:53,030 --> 00:17:57,800
anymore because let's go to that example

00:17:55,550 --> 00:18:00,020
again but now let's think about not a

00:17:57,800 --> 00:18:02,120
and not B being telegraphic us and not

00:18:00,020 --> 00:18:06,350
sieving either till o or Apple replicant

00:18:02,120 --> 00:18:07,790
recovery so yeah the note C is going to

00:18:06,350 --> 00:18:10,550
ask the leader hey which segments we

00:18:07,790 --> 00:18:13,280
have I have segments a1 and a2 okay I

00:18:10,550 --> 00:18:16,760
don't know that but see how in this case

00:18:13,280 --> 00:18:18,320
no B has also a segment a 1 and a 2

00:18:16,760 --> 00:18:22,130
because it's essentially also

00:18:18,320 --> 00:18:24,200
replicating all the time and then not C

00:18:22,130 --> 00:18:26,480
is not very reliable and we will go to

00:18:24,200 --> 00:18:31,070
recovery again and in this case the

00:18:26,480 --> 00:18:34,730
leader is not V but nobody has a segment

00:18:31,070 --> 00:18:36,800
a 1 and 2 and B 3 and so segments a1 and

00:18:34,730 --> 00:18:38,840
a2 are already not in Nazi so it doesn't

00:18:36,800 --> 00:18:43,790
need to copy those so it it's back to

00:18:38,840 --> 00:18:45,350
being incremented in that sense a couple

00:18:43,790 --> 00:18:48,800
of combinations I didn't mention in the

00:18:45,350 --> 00:18:51,560
recommend that ones are near real time

00:18:48,800 --> 00:18:56,300
with either T log or pull replicas or

00:18:51,560 --> 00:18:58,160
all pull replicas so that issue with the

00:18:56,300 --> 00:19:00,740
recovery that I mentioned before it

00:18:58,160 --> 00:19:02,090
becomes much worse in if you mix near

00:19:00,740 --> 00:19:04,340
real time with pull replicas or

00:19:02,090 --> 00:19:05,930
telegraphy cos because it doesn't even

00:19:04,340 --> 00:19:07,670
need to go to and no doesn't even need

00:19:05,930 --> 00:19:10,040
to go to recovery it's replicating

00:19:07,670 --> 00:19:12,830
periodically from the leader if the

00:19:10,040 --> 00:19:14,990
leader changes that means that all the

00:19:12,830 --> 00:19:17,600
pool or telegraphy cos that you have out

00:19:14,990 --> 00:19:19,370
there in the next replication phase they

00:19:17,600 --> 00:19:22,310
are going to download the full index so

00:19:19,370 --> 00:19:25,310
you have to be very careful and all pool

00:19:22,310 --> 00:19:27,440
replicas because um because pool

00:19:25,310 --> 00:19:28,940
replicas cannot be leaders if you have

00:19:27,440 --> 00:19:30,980
all full replicas you essentially have a

00:19:28,940 --> 00:19:32,540
little less charge and this actually is

00:19:30,980 --> 00:19:34,340
a combination and it's not supported so

00:19:32,540 --> 00:19:38,630
if you try to create it solar is going

00:19:34,340 --> 00:19:41,180
to complain so I mentioned in the agenda

00:19:38,630 --> 00:19:43,340
that one of the feed nice features that

00:19:41,180 --> 00:19:45,530
you could have by using combinations of

00:19:43,340 --> 00:19:48,080
replica types is a master slave

00:19:45,530 --> 00:19:49,490
architecture in solar cloud and it's

00:19:48,080 --> 00:19:51,620
very easy to think about how to do it

00:19:49,490 --> 00:19:53,390
you just need to have a tillich replica

00:19:51,620 --> 00:19:55,490
that's going to be the leader and then a

00:19:53,390 --> 00:19:58,760
bunch of pull replicas to do queries

00:19:55,490 --> 00:20:00,490
from and you can do even better now you

00:19:58,760 --> 00:20:02,990
can have a set of D lock replicas that

00:20:00,490 --> 00:20:05,150
are going to be writing and then

00:20:02,990 --> 00:20:07,700
of pool replicas for queries right and

00:20:05,150 --> 00:20:09,500
you get the benefits of solar cloud so

00:20:07,700 --> 00:20:11,510
if the leader goes down now you

00:20:09,500 --> 00:20:13,610
automatically get a leader leader

00:20:11,510 --> 00:20:15,890
election another now is going to become

00:20:13,610 --> 00:20:17,750
a leader and then the replication is

00:20:15,890 --> 00:20:19,970
going to continue and you won't even

00:20:17,750 --> 00:20:21,559
notice from the search or from in the

00:20:19,970 --> 00:20:23,150
updates you may have a small leap but

00:20:21,559 --> 00:20:28,910
then it will continue to work

00:20:23,150 --> 00:20:30,730
automatically so you get you get to

00:20:28,910 --> 00:20:33,170
prefer search availability over

00:20:30,730 --> 00:20:36,350
consistency or near real-time about

00:20:33,170 --> 00:20:38,000
using something like this you get to do

00:20:36,350 --> 00:20:40,880
that separation of responsibilities that

00:20:38,000 --> 00:20:42,470
was Gooding in master/slave but you also

00:20:40,880 --> 00:20:43,970
get most of the benefits of solar cloud

00:20:42,470 --> 00:20:49,520
you have higher value high availability

00:20:43,970 --> 00:20:52,550
of rights financing no recovery and most

00:20:49,520 --> 00:20:54,740
of this Oracle cloud features and this

00:20:52,550 --> 00:20:57,440
also of course I'm showing it as a

00:20:54,740 --> 00:20:59,140
single index but essentially you since

00:20:57,440 --> 00:21:03,040
you can have multiple collections or

00:20:59,140 --> 00:21:05,600
multiple shots for a collection you can

00:21:03,040 --> 00:21:07,460
you you could use auto scaling group so

00:21:05,600 --> 00:21:09,110
that some some nodes only get

00:21:07,460 --> 00:21:11,270
telegraphic cuts and some other nodes

00:21:09,110 --> 00:21:13,240
only get full replicas and that gives

00:21:11,270 --> 00:21:15,410
you that separation of responsibilities

00:21:13,240 --> 00:21:17,150
completely right because if you have

00:21:15,410 --> 00:21:20,030
multiple shots and then in a node you

00:21:17,150 --> 00:21:22,190
have the leader of one and then and then

00:21:20,030 --> 00:21:23,570
pull replicas they there's still no

00:21:22,190 --> 00:21:25,340
separation because if there is a spike

00:21:23,570 --> 00:21:28,040
in updates they're probably going to go

00:21:25,340 --> 00:21:30,170
to all the shots and then you wouldn't

00:21:28,040 --> 00:21:32,210
get that separation so you can use auto

00:21:30,170 --> 00:21:35,000
scaling rules to make sure that some

00:21:32,210 --> 00:21:38,510
types of replicas only go to some notes

00:21:35,000 --> 00:21:39,860
and some other types to some others so

00:21:38,510 --> 00:21:43,370
how do you use them how do you use

00:21:39,860 --> 00:21:45,740
replica types it's actually pretty easy

00:21:43,370 --> 00:21:47,240
and essentially when you create a

00:21:45,740 --> 00:21:50,660
collection or when you create a shard

00:21:47,240 --> 00:21:53,330
you can specify the number of replicas

00:21:50,660 --> 00:21:57,140
for different types that you want for

00:21:53,330 --> 00:21:59,179
for that channel also when you create a

00:21:57,140 --> 00:22:01,670
replica you can specify the type that

00:21:59,179 --> 00:22:03,740
you want if you don't this is backward

00:22:01,670 --> 00:22:05,059
compatible so if you don't and you

00:22:03,740 --> 00:22:08,510
create a collection without specifying

00:22:05,059 --> 00:22:10,250
the types of the different number of

00:22:08,510 --> 00:22:12,559
replicas for different types and you

00:22:10,250 --> 00:22:14,030
just say replication factor that's going

00:22:12,559 --> 00:22:15,710
to translate automatically to

00:22:14,030 --> 00:22:16,620
near-real-time which is the existing

00:22:15,710 --> 00:22:18,630
type before

00:22:16,620 --> 00:22:20,520
seven the same with AD replica if you

00:22:18,630 --> 00:22:23,280
don't specify the type it's gonna be

00:22:20,520 --> 00:22:28,290
near real-time and there's of course a

00:22:23,280 --> 00:22:30,270
v2 option there's also support for solo

00:22:28,290 --> 00:22:32,430
Jane so if you create a collections

00:22:30,270 --> 00:22:34,320
using solid J then you just those

00:22:32,430 --> 00:22:37,020
numbers there are the number of charts

00:22:34,320 --> 00:22:39,690
number of near-real-time replicas still

00:22:37,020 --> 00:22:41,670
out and pull out and pull replicas and

00:22:39,690 --> 00:22:43,410
when you create and when you add

00:22:41,670 --> 00:22:47,520
replicas you can specify the type that

00:22:43,410 --> 00:22:49,590
you want it to be as I was saying before

00:22:47,520 --> 00:22:51,960
you can use the auto scaling policy

00:22:49,590 --> 00:22:53,910
framework so that you can choose which

00:22:51,960 --> 00:22:57,570
types of replicas goes to different

00:22:53,910 --> 00:23:03,210
notes and the rules would look something

00:22:57,570 --> 00:23:05,790
like this to identify the types of

00:23:03,210 --> 00:23:07,559
replicas the type replica is the way the

00:23:05,790 --> 00:23:10,350
way to do is is by looking at the at the

00:23:07,559 --> 00:23:13,290
cluster state there's going to be for

00:23:10,350 --> 00:23:15,780
each replica that the type key that's

00:23:13,290 --> 00:23:17,640
going to tell you which type it is and

00:23:15,780 --> 00:23:20,400
also there's a small but very important

00:23:17,640 --> 00:23:23,400
detail that now when you create the

00:23:20,400 --> 00:23:27,800
collections via in the occupations API

00:23:23,400 --> 00:23:31,380
the core is going to include the type of

00:23:27,800 --> 00:23:32,880
replicas hosting in this case it's T

00:23:31,380 --> 00:23:34,080
that stands for T log while it would be

00:23:32,880 --> 00:23:37,860
n for near-real-time

00:23:34,080 --> 00:23:39,630
or P for pool and why I think this is

00:23:37,860 --> 00:23:42,030
important because solar includes in the

00:23:39,630 --> 00:23:45,929
logs for the majority of the log system

00:23:42,030 --> 00:23:49,170
it includes the core name of the well

00:23:45,929 --> 00:23:50,640
it's logging so you can say okay this is

00:23:49,170 --> 00:23:52,320
that this is a tillich replica that's

00:23:50,640 --> 00:23:56,130
why it's it's logging about doing

00:23:52,320 --> 00:23:57,840
replication that makes sense there's an

00:23:56,130 --> 00:24:01,380
I'm cheating a week here because this is

00:23:57,840 --> 00:24:05,100
not yet committed but this is in India

00:24:01,380 --> 00:24:07,860
that's soon to be committed by by rocket

00:24:05,100 --> 00:24:09,540
and eating so there will be in the ape

00:24:07,860 --> 00:24:16,530
in the UI you would be able to see which

00:24:09,540 --> 00:24:19,410
type the replicas are then so another

00:24:16,530 --> 00:24:22,260
interesting part is you can choose you

00:24:19,410 --> 00:24:25,410
can set the preference of which replica

00:24:22,260 --> 00:24:28,140
types you want to respond for a query so

00:24:25,410 --> 00:24:29,970
you can say for example in this case I'm

00:24:28,140 --> 00:24:30,450
going to start send this query and I

00:24:29,970 --> 00:24:35,300
want it to

00:24:30,450 --> 00:24:39,630
respond by replicas of type of pool and

00:24:35,300 --> 00:24:40,950
as long as there is one and you can set

00:24:39,630 --> 00:24:43,230
reference that's much more complicated

00:24:40,950 --> 00:24:45,060
like this you could say first pour and

00:24:43,230 --> 00:24:47,960
then active and the idea is that we

00:24:45,060 --> 00:24:50,730
could keep we could add more rules here

00:24:47,960 --> 00:24:57,330
there's you can choose also location of

00:24:50,730 --> 00:24:59,940
the replica like like a IP prefix or

00:24:57,330 --> 00:25:03,210
something like that and the idea is that

00:24:59,940 --> 00:25:05,310
this is going to sort which replicas are

00:25:03,210 --> 00:25:07,500
available for a shot and then if there

00:25:05,310 --> 00:25:08,820
is at least one that's pool and is

00:25:07,500 --> 00:25:11,160
active is going to be used for

00:25:08,820 --> 00:25:15,890
responding your query the important part

00:25:11,160 --> 00:25:18,780
is that if there isn't one that's that's

00:25:15,890 --> 00:25:21,350
applying to to this rule then any other

00:25:18,780 --> 00:25:23,880
replica is going to be used in this case

00:25:21,350 --> 00:25:25,170
the same way I mean it will default it

00:25:23,880 --> 00:25:28,520
will it will go to the default which is

00:25:25,170 --> 00:25:31,350
to take any replica there's this other

00:25:28,520 --> 00:25:34,410
feature that's also not committed but

00:25:31,350 --> 00:25:36,510
soon that you can use to filter types

00:25:34,410 --> 00:25:38,250
and in this case what you want to want

00:25:36,510 --> 00:25:40,200
to say is that if there is I want to

00:25:38,250 --> 00:25:42,360
query only a replica of type bool and if

00:25:40,200 --> 00:25:44,250
it's not there and if there's no active

00:25:42,360 --> 00:25:46,140
pool replica for a shot just give me an

00:25:44,250 --> 00:25:48,390
error I don't want to care query in any

00:25:46,140 --> 00:25:50,280
other replica and the reason why this is

00:25:48,390 --> 00:25:52,440
also important is that if you are doing

00:25:50,280 --> 00:25:54,120
that master slave architecture and you

00:25:52,440 --> 00:25:59,210
don't really want to go to the leaders

00:25:54,120 --> 00:26:03,600
you can you can do that so what's next

00:25:59,210 --> 00:26:06,870
to do this is some of the stuff that I

00:26:03,600 --> 00:26:10,530
think can be done there's more that

00:26:06,870 --> 00:26:12,350
people can think of this is so one of

00:26:10,530 --> 00:26:14,820
the main thing that came during the

00:26:12,350 --> 00:26:17,160
development of this feature was that

00:26:14,820 --> 00:26:19,410
issue that I mentioned before that if

00:26:17,160 --> 00:26:22,830
the pool replicas cannot talk with a

00:26:19,410 --> 00:26:25,170
leader for a long time it will continue

00:26:22,830 --> 00:26:27,900
to be serving search traffic and that

00:26:25,170 --> 00:26:31,140
such traffic may be may be may be

00:26:27,900 --> 00:26:34,440
responding with a very old data right so

00:26:31,140 --> 00:26:36,450
there's options there's this JIRA to

00:26:34,440 --> 00:26:39,630
address that the options that were

00:26:36,450 --> 00:26:42,270
discussed are either let's let's make

00:26:39,630 --> 00:26:44,039
the replicas we can't go to recovery if

00:26:42,270 --> 00:26:45,929
it fails X amount of

00:26:44,039 --> 00:26:48,179
vacations or if it phase for this amount

00:26:45,929 --> 00:26:50,940
of time another option that that we were

00:26:48,179 --> 00:26:53,909
thinking is including the response the

00:26:50,940 --> 00:26:55,259
time of the last rapid successful

00:26:53,909 --> 00:26:57,899
replication so that the client can

00:26:55,259 --> 00:27:01,259
choose okay this day guys way to all I'm

00:26:57,899 --> 00:27:02,879
going to do another query another

00:27:01,259 --> 00:27:05,609
another thing that needs to be done I

00:27:02,879 --> 00:27:07,470
think is that right now replication is

00:27:05,609 --> 00:27:09,809
always going to happen from the leader

00:27:07,470 --> 00:27:12,450
and that's not really necessary because

00:27:09,809 --> 00:27:13,769
all the all the telegraphic a sample

00:27:12,450 --> 00:27:17,279
replicas are going to contain the same

00:27:13,769 --> 00:27:19,649
segments the the leader will have the

00:27:17,279 --> 00:27:22,710
latest one but if you are ok with being

00:27:19,649 --> 00:27:24,869
a little bit more behind you could say

00:27:22,710 --> 00:27:28,799
okay replicate from any Telegraph Raqqah

00:27:24,869 --> 00:27:30,119
um and that would I mean because the

00:27:28,799 --> 00:27:31,739
otherwise they can be a bottleneck in

00:27:30,119 --> 00:27:35,729
the leader if everyone is trying to

00:27:31,739 --> 00:27:38,099
replicate from it integration with the

00:27:35,729 --> 00:27:39,869
CLI is not done so if you use being

00:27:38,099 --> 00:27:44,039
solar to create collections

00:27:39,869 --> 00:27:47,779
you can't specify right now how many how

00:27:44,039 --> 00:27:51,269
many replicas you want for each type so

00:27:47,779 --> 00:27:53,399
the Sharpe preference is also only

00:27:51,269 --> 00:27:56,369
supported in the multi shard case it's

00:27:53,399 --> 00:27:58,109
yeah in the yeah in the multi sharp case

00:27:56,369 --> 00:28:02,820
if you have a collection with a single

00:27:58,109 --> 00:28:04,710
char right now it won't it won't it

00:28:02,820 --> 00:28:07,049
won't support that parameter the reason

00:28:04,710 --> 00:28:10,049
is that if you have a single shard

00:28:07,049 --> 00:28:12,599
collection the the code that is that

00:28:10,049 --> 00:28:14,489
decides were word query is in the client

00:28:12,599 --> 00:28:15,989
so we need to we need to make sure that

00:28:14,489 --> 00:28:17,700
this code can run in the client too

00:28:15,989 --> 00:28:22,200
and there's an open JIRA for that but

00:28:17,700 --> 00:28:24,119
that that's not done yet another thing

00:28:22,200 --> 00:28:26,609
that could be done is that as I

00:28:24,119 --> 00:28:28,409
mentioned you we don't mix near

00:28:26,609 --> 00:28:30,210
real-time replicas with pool or tea logs

00:28:28,409 --> 00:28:33,450
and the reason is that if they need to

00:28:30,210 --> 00:28:35,429
replicate from one and then and then

00:28:33,450 --> 00:28:37,049
there's a little change and the new

00:28:35,429 --> 00:28:40,950
leader has a completely different set of

00:28:37,049 --> 00:28:43,259
segments that that would cause a full

00:28:40,950 --> 00:28:48,570
download of the index from for every

00:28:43,259 --> 00:28:51,899
kilo or pool of replicas but so what we

00:28:48,570 --> 00:28:53,849
really need is that if there's near

00:28:51,899 --> 00:28:55,710
real-time replicas let's just make sure

00:28:53,849 --> 00:28:57,630
that they don't become leaders so if

00:28:55,710 --> 00:28:59,340
there is a use case

00:28:57,630 --> 00:29:01,410
for the same collection you want to do

00:28:59,340 --> 00:29:05,480
some near real-time queries but some

00:29:01,410 --> 00:29:11,040
others are are okay with having some

00:29:05,480 --> 00:29:12,810
stained data then you could have a

00:29:11,040 --> 00:29:14,460
cluster where you mix all the different

00:29:12,810 --> 00:29:17,220
types you just need to make sure that

00:29:14,460 --> 00:29:20,340
the near real-time replicas do not

00:29:17,220 --> 00:29:23,820
become leaders and yeah this is not this

00:29:20,340 --> 00:29:26,430
is not supported right now another thing

00:29:23,820 --> 00:29:29,280
that would be interesting is that as I

00:29:26,430 --> 00:29:32,640
said solar doesn't support any real-time

00:29:29,280 --> 00:29:34,980
when doing replication and the reason

00:29:32,640 --> 00:29:36,750
for this is because when I think the

00:29:34,980 --> 00:29:40,680
replication was implemented way long ago

00:29:36,750 --> 00:29:43,350
and soft communities not exist then and

00:29:40,680 --> 00:29:45,120
then with Sora cloud that's stopped

00:29:43,350 --> 00:29:47,550
mattering because the replication was

00:29:45,120 --> 00:29:50,460
only used for recovery but now that

00:29:47,550 --> 00:29:53,100
we're going to use replication for for

00:29:50,460 --> 00:29:56,310
updating the index we may want to be

00:29:53,100 --> 00:29:59,160
closer more more real-time right and

00:29:56,310 --> 00:30:02,400
loose in actually the replicator module

00:29:59,160 --> 00:30:05,100
supports near real-time replication on

00:30:02,400 --> 00:30:06,540
the software means but it so that's not

00:30:05,100 --> 00:30:08,460
yet supported in solar that's something

00:30:06,540 --> 00:30:10,770
that could be added and the Telegraph

00:30:08,460 --> 00:30:14,970
because the full replicas could get more

00:30:10,770 --> 00:30:19,650
up-to-date data so yeah that's my talk

00:30:14,970 --> 00:30:21,930
thank you very much make sure you're

00:30:19,650 --> 00:30:24,140
rooting for the right team in the workup

00:30:21,930 --> 00:30:30,540
that's why I'm putting that there

00:30:24,140 --> 00:30:32,430
brain storm brain don't ribbit ok I

00:30:30,540 --> 00:30:37,050
think we have time for questions here

00:30:32,430 --> 00:30:39,000
I see mentioned small medium and large

00:30:37,050 --> 00:30:40,290
sized clusters what what are they in

00:30:39,000 --> 00:30:42,390
your view sorry

00:30:40,290 --> 00:30:43,920
well I'm small medium and large what do

00:30:42,390 --> 00:30:46,040
they mean yeah that's like that's a good

00:30:43,920 --> 00:30:49,260
question I don't have an answer actually

00:30:46,040 --> 00:30:52,080
it really depends on each use case right

00:30:49,260 --> 00:30:55,020
because it's not a single I mentioned

00:30:52,080 --> 00:30:57,360
two off big too smart to be it's also

00:30:55,020 --> 00:30:59,340
the number of replicas the number of

00:30:57,360 --> 00:31:03,930
nodes the traffic that you are that you

00:30:59,340 --> 00:31:06,870
are using so I I've heard people using

00:31:03,930 --> 00:31:10,490
telegraphy cos it's much more stable

00:31:06,870 --> 00:31:12,110
even for not so big clusters and then

00:31:10,490 --> 00:31:14,150
yeah there's people that uses

00:31:12,110 --> 00:31:16,250
near-real-time replicas for very big

00:31:14,150 --> 00:31:19,640
clusters and still good for them so it's

00:31:16,250 --> 00:31:21,470
there's no I mean it's kind of a blurry

00:31:19,640 --> 00:31:33,980
thing that you you will have to design

00:31:21,470 --> 00:31:38,480
with your define with your own data hi

00:31:33,980 --> 00:31:42,470
question about the t lock replica you

00:31:38,480 --> 00:31:44,900
said it when when object comes in and

00:31:42,470 --> 00:31:46,100
the transactional updated in t log it's

00:31:44,900 --> 00:31:48,020
actually not such a bully it's not

00:31:46,100 --> 00:31:51,530
committed until leader initiates

00:31:48,020 --> 00:31:53,750
replication or what what sugars she

00:31:51,530 --> 00:31:55,909
looked actually make the change is

00:31:53,750 --> 00:31:58,190
searchable sorry I didn't Oh

00:31:55,909 --> 00:31:59,419
in order to make the change searchable

00:31:58,190 --> 00:32:02,630
in the dialogue yeah exactly

00:31:59,419 --> 00:32:05,900
it the tillow is actually not going to

00:32:02,630 --> 00:32:10,070
use at all unless unless it needs to

00:32:05,900 --> 00:32:11,900
become a leader so the the information

00:32:10,070 --> 00:32:14,150
is not going to be searchable until the

00:32:11,900 --> 00:32:16,490
replication happens is there any way to

00:32:14,150 --> 00:32:20,320
trigger that application like force it

00:32:16,490 --> 00:32:23,120
to happen without being becoming leader

00:32:20,320 --> 00:32:26,150
replication or or indexing from the

00:32:23,120 --> 00:32:28,460
tillow index from key lock no in fact

00:32:26,150 --> 00:32:30,530
it's something that you don't want again

00:32:28,460 --> 00:32:33,440
if you have more than one node writing

00:32:30,530 --> 00:32:35,240
index at any point in time you can cause

00:32:33,440 --> 00:32:36,620
a lot of trouble because anyone will

00:32:35,240 --> 00:32:39,820
have a different set of segments and

00:32:36,620 --> 00:32:39,820
then every everyone needs to download

00:32:41,080 --> 00:32:47,900
any more questions I'm actually trying

00:32:45,980 --> 00:32:49,760
to understand the practical use case of

00:32:47,900 --> 00:32:52,850
the polo replicas if you can explain

00:32:49,760 --> 00:32:56,330
learn more the practical use case of

00:32:52,850 --> 00:32:58,400
what of full replicas yes the main the

00:32:56,330 --> 00:33:00,169
main use case of that is that it doesn't

00:32:58,400 --> 00:33:02,450
need to go into leader initiated

00:33:00,169 --> 00:33:06,200
recovery so if you have a big cluster

00:33:02,450 --> 00:33:08,120
and you are afraid of losing a part of a

00:33:06,200 --> 00:33:10,460
cluster because of some blip in the

00:33:08,120 --> 00:33:12,620
network those replicas are still going

00:33:10,460 --> 00:33:14,270
to be active as long as they don't

00:33:12,620 --> 00:33:15,890
disconnect from zookeeper and the

00:33:14,270 --> 00:33:17,630
timeout for that is much longer than

00:33:15,890 --> 00:33:21,679
just a single update failing at a

00:33:17,630 --> 00:33:23,510
particular point in time you know did

00:33:21,679 --> 00:33:25,610
yes yes yes poor replica parties

00:33:23,510 --> 00:33:27,380
reading search yes and there they are in

00:33:25,610 --> 00:33:32,570
fact that for that particular for that

00:33:27,380 --> 00:33:41,810
thing yes they still have time for some

00:33:32,570 --> 00:33:44,330
more questions yeah I talked a lot about

00:33:41,810 --> 00:33:46,250
leader initiated recovery is it possible

00:33:44,330 --> 00:33:48,260
to have a replica initiated recovery

00:33:46,250 --> 00:33:50,540
where it knows the desire of day instead

00:33:48,260 --> 00:33:52,940
of a leader kind of a replica initiated

00:33:50,540 --> 00:33:54,710
initiating recovery for what so they

00:33:52,940 --> 00:33:57,080
know if the replica knows it's out of

00:33:54,710 --> 00:34:00,890
date it can go and recover as opposed to

00:33:57,080 --> 00:34:02,360
the leader initiation know so the the

00:34:00,890 --> 00:34:03,890
replica won't go into recovery

00:34:02,360 --> 00:34:16,540
automatically as long as it doesn't

00:34:03,890 --> 00:34:16,540
disconnect from zookeeper any questions

00:34:19,850 --> 00:34:25,940
so how often does the T log replica I

00:34:23,760 --> 00:34:29,700
think that was part of someone's machine

00:34:25,940 --> 00:34:32,340
replicate from the leader who's writing

00:34:29,700 --> 00:34:36,090
the index so right now that's not

00:34:32,340 --> 00:34:39,149
configurable but it's set to have the

00:34:36,090 --> 00:34:41,610
outer commit time so if you the way to

00:34:39,149 --> 00:34:44,220
the way to configure right now is to set

00:34:41,610 --> 00:34:45,899
the auto commit time and half that time

00:34:44,220 --> 00:34:48,600
is going to be used for replication but

00:34:45,899 --> 00:34:51,419
then if the that is just how when the

00:34:48,600 --> 00:34:55,379
replication is triggered so if you is

00:34:51,419 --> 00:34:56,700
there's really no strong definition of

00:34:55,379 --> 00:34:58,890
how long it's going to take to see the

00:34:56,700 --> 00:35:01,800
new data because if for whatever reason

00:34:58,890 --> 00:35:03,870
one replication takes X amount of

00:35:01,800 --> 00:35:06,060
seconds and that's more than the Neary

00:35:03,870 --> 00:35:08,220
at time than than the auto commit time

00:35:06,060 --> 00:35:10,170
the new replication is not going to

00:35:08,220 --> 00:35:11,550
start until the other one finishes and

00:35:10,170 --> 00:35:14,730
there could have been multiple commits

00:35:11,550 --> 00:35:16,050
on the leader during this time so

00:35:14,730 --> 00:35:20,360
eventually it will that it will be there

00:35:16,050 --> 00:35:20,360
but it's not you don't know exactly one

00:35:26,800 --> 00:35:33,950
are there any more questions okay if

00:35:30,760 --> 00:35:39,770
none thanks Thomas Fitz take it off

00:35:33,950 --> 00:35:39,770

YouTube URL: https://www.youtube.com/watch?v=C8C9GRTCSzY


