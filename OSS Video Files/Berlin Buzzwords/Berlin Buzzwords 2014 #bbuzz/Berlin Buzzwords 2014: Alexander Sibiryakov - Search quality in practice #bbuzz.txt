Title: Berlin Buzzwords 2014: Alexander Sibiryakov - Search quality in practice #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	1. Understanding search quality: relevancy, snippets, user interface(?)
2. How to measure search quality: metrics, comparison of two search systems request-by-request, classic evaluation of top N, by-pair evaluation with swiss system. The cheapest way.
3. Examples of search quality problems.
4. Production system. Which data available: clicks, queries, shows in SERPs.
5. Text relevancy ranking: different approaches, absence of silver bullet. BM25, tf*idf, using hits of different types, using language models, quorum, words proximity in query and document.
6. How to effectively mix all signals: manual linear model, polynomial model, gradient decision trees, known implementations. Where to get labels?
7. Doing snippets well: candidates labeling, blind test, infrastructure for candidates ranking, features examples, infrastructure for candidates features and ranking, features examples.
8. How to measure search quality using clicks?
9. Other signals: comments, likes.
10. Example project: Filesystem path classifier based on search results.

Read more:
https://2014.berlinbuzzwords.de/session/search-quality-practice

About Alexander Sibiryakov:
https://2014.berlinbuzzwords.de/user/157/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,180 --> 00:00:15,370
so hi everybody I'm really glad that you

00:00:12,010 --> 00:00:17,590
are all here my name is cibulkova

00:00:15,370 --> 00:00:22,390
Alexander and I will be talking about

00:00:17,590 --> 00:00:27,100
search quality in practice so here's the

00:00:22,390 --> 00:00:33,219
agenda of my talk please show me the

00:00:27,100 --> 00:00:37,450
hands who knows what Yandex is Wow let's

00:00:33,219 --> 00:00:42,960
get so Yandex is the biggest search

00:00:37,450 --> 00:00:44,800
engine in Russia it's like Google and I

00:00:42,960 --> 00:00:48,309
unfortunately I didn't have a slide

00:00:44,800 --> 00:00:51,309
about my my previous experience but I

00:00:48,309 --> 00:00:53,469
will just say it so i was working five

00:00:51,309 --> 00:00:57,399
years in the department of search

00:00:53,469 --> 00:01:00,850
quality in Yandex and my talk today will

00:00:57,399 --> 00:01:04,089
be about what kind of problems do exist

00:01:00,850 --> 00:01:07,120
with search quality what is it and also

00:01:04,089 --> 00:01:12,700
about how to improve the things without

00:01:07,120 --> 00:01:14,850
investing too much resources so first we

00:01:12,700 --> 00:01:18,100
will talk about what is search quality

00:01:14,850 --> 00:01:21,070
then we will take a look about examples

00:01:18,100 --> 00:01:24,039
of such quality problems when I will

00:01:21,070 --> 00:01:26,350
describe three methods of how to

00:01:24,039 --> 00:01:30,250
evaluate information retrieval systems

00:01:26,350 --> 00:01:33,100
then we will have a look at the signals

00:01:30,250 --> 00:01:36,640
I have some like bunch of signals for

00:01:33,100 --> 00:01:39,219
your inspiration and finally we will

00:01:36,640 --> 00:01:42,009
take a look about how to produce good

00:01:39,219 --> 00:01:46,630
snippets if we will have time and so

00:01:42,009 --> 00:01:49,090
let's go first of all search quality is

00:01:46,630 --> 00:01:51,340
abstract term it includes user

00:01:49,090 --> 00:01:54,670
experience or advance and the real sugar

00:01:51,340 --> 00:01:57,189
all effectiveness of search by humans at

00:01:54,670 --> 00:02:00,850
the same time relevance is a measure of

00:01:57,189 --> 00:02:04,899
conformity of user information need to

00:02:00,850 --> 00:02:07,539
document found so basically when user

00:02:04,899 --> 00:02:15,040
wants to find something he starts with

00:02:07,539 --> 00:02:18,099
his intent so for example when I first

00:02:15,040 --> 00:02:19,250
get a Hadoop I've faced with streaming

00:02:18,099 --> 00:02:23,480
jobs

00:02:19,250 --> 00:02:28,580
are breaking when the code in the

00:02:23,480 --> 00:02:31,400
streaming map is throwing a nonzero exit

00:02:28,580 --> 00:02:34,130
code so i started to google it my intent

00:02:31,400 --> 00:02:35,959
was to solve my problem now how to

00:02:34,130 --> 00:02:40,100
disable crushing of streaming of nonzero

00:02:35,959 --> 00:02:43,040
exit code so we see first the results

00:02:40,100 --> 00:02:45,650
they are about Hadoop and they are about

00:02:43,040 --> 00:02:48,670
nonzero exit code so it looks like a

00:02:45,650 --> 00:02:53,830
relevant and but the second two is

00:02:48,670 --> 00:02:57,560
completely out of sense you know so and

00:02:53,830 --> 00:02:59,870
you also see that the highlighting shows

00:02:57,560 --> 00:03:02,570
that words are distinct so it means like

00:02:59,870 --> 00:03:13,150
nothing useful is found so the question

00:03:02,570 --> 00:03:13,150
why am I see this here so about search

00:03:13,930 --> 00:03:20,930
we've searched we have quite a bunch of

00:03:18,500 --> 00:03:23,239
problems for example search has no

00:03:20,930 --> 00:03:26,150
definition formulation and it also has a

00:03:23,239 --> 00:03:30,739
considerable uncertainty what does it

00:03:26,150 --> 00:03:33,470
means for example it's it's not possible

00:03:30,739 --> 00:03:35,570
to define a search for example like a

00:03:33,470 --> 00:03:37,820
erp system or internet banking

00:03:35,570 --> 00:03:40,150
application it's a complex finks think

00:03:37,820 --> 00:03:42,950
because it's work it is working with

00:03:40,150 --> 00:03:45,110
Nader queries written in natural

00:03:42,950 --> 00:03:46,940
language and it also works with

00:03:45,110 --> 00:03:49,220
documents written in natural language

00:03:46,940 --> 00:03:56,140
which is kind of your rational hard to

00:03:49,220 --> 00:03:59,989
formulate formalize also search research

00:03:56,140 --> 00:04:04,370
working real users whose behavior is

00:03:59,989 --> 00:04:09,680
very hard to somehow explain or also

00:04:04,370 --> 00:04:12,110
formalize and also they have a kind of

00:04:09,680 --> 00:04:15,090
unexplainable and not predictable needs

00:04:12,110 --> 00:04:22,030
always in you

00:04:15,090 --> 00:04:24,400
mmm okay so also the developers are not

00:04:22,030 --> 00:04:25,840
prepared to tackle the search we cannot

00:04:24,400 --> 00:04:27,430
manage high tech step change in

00:04:25,840 --> 00:04:30,070
cross-functional and user to enter a

00:04:27,430 --> 00:04:34,210
challenge of course if we are not Google

00:04:30,070 --> 00:04:37,139
so what what am I talking about to build

00:04:34,210 --> 00:04:39,220
a good search system we need to know

00:04:37,139 --> 00:04:40,660
knowledge from different domains for

00:04:39,220 --> 00:04:43,690
example how to build high-performance

00:04:40,660 --> 00:04:46,630
system and the second thing is

00:04:43,690 --> 00:04:49,030
linguistics so we have to understand how

00:04:46,630 --> 00:04:52,479
morphology works how post taking works

00:04:49,030 --> 00:04:55,080
house in taxes and so on also we have to

00:04:52,479 --> 00:04:57,790
know how how much in learning works and

00:04:55,080 --> 00:05:01,540
finally we need to have some knowledge

00:04:57,790 --> 00:05:03,310
about the domain you know if we are

00:05:01,540 --> 00:05:05,050
searching for financial documents will

00:05:03,310 --> 00:05:09,340
have to know something about financial

00:05:05,050 --> 00:05:11,710
stuff so also the role of search and

00:05:09,340 --> 00:05:13,150
user experience is underestimated there

00:05:11,710 --> 00:05:16,030
followed by the measuring knows how good

00:05:13,150 --> 00:05:18,430
is it this is true especially for open

00:05:16,030 --> 00:05:22,030
source world where everybody just

00:05:18,430 --> 00:05:26,919
downloads the archive installs it and

00:05:22,030 --> 00:05:32,410
that's it job is done and so here's how

00:05:26,919 --> 00:05:34,530
it looks like basically this is a big

00:05:32,410 --> 00:05:36,910
elephant in relatively small room

00:05:34,530 --> 00:05:39,850
somebody is guessing that it is there

00:05:36,910 --> 00:05:48,940
but nobody sees it and nobody knows how

00:05:39,850 --> 00:05:52,150
exactly it looks like so this is how it

00:05:48,940 --> 00:05:58,120
comes from emotional perspective of your

00:05:52,150 --> 00:06:02,680
users so if users pessimistic the

00:05:58,120 --> 00:06:04,840
beginning it could end up well with bad

00:06:02,680 --> 00:06:07,599
user experience and finally defeating

00:06:04,840 --> 00:06:13,510
and abandoning for a phone and email so

00:06:07,599 --> 00:06:16,210
search will simply not work it could be

00:06:13,510 --> 00:06:19,740
of other way which could be an

00:06:16,210 --> 00:06:22,180
interesting source of discoveries and

00:06:19,740 --> 00:06:24,580
finally user will end up with

00:06:22,180 --> 00:06:27,610
satisfaction and using it again and

00:06:24,580 --> 00:06:28,830
again so let's take a look closer to

00:06:27,610 --> 00:06:34,260
examples of

00:06:28,830 --> 00:06:36,090
problems these examples are for big

00:06:34,260 --> 00:06:42,390
search systems like Google you can try

00:06:36,090 --> 00:06:44,730
it but these examples these kind of

00:06:42,390 --> 00:06:48,180
problems they are also persists in

00:06:44,730 --> 00:06:51,330
lucene world and its ecosystem so first

00:06:48,180 --> 00:06:56,420
thing is searching of model numbers and

00:06:51,330 --> 00:07:00,030
articles so you see these two queries

00:06:56,420 --> 00:07:03,690
6167 and so on this is a article for a

00:07:00,030 --> 00:07:06,980
telescopic muzzle for BMW 3-series the

00:07:03,690 --> 00:07:10,350
difference is replacement of spaces and

00:07:06,980 --> 00:07:12,990
for the second query you will get much

00:07:10,350 --> 00:07:16,040
more broader and interesting response of

00:07:12,990 --> 00:07:20,280
research system then Tory first one so

00:07:16,040 --> 00:07:23,130
basically if your typical user and you

00:07:20,280 --> 00:07:27,990
don't know how our system works you will

00:07:23,130 --> 00:07:32,310
not get it you know because user will

00:07:27,990 --> 00:07:34,650
simply abandon the search and at the

00:07:32,310 --> 00:07:38,160
same time search system itself knows

00:07:34,650 --> 00:07:40,980
much more better for which kind of query

00:07:38,160 --> 00:07:45,090
for which placement of spaces it has a

00:07:40,980 --> 00:07:46,560
better results second question is

00:07:45,090 --> 00:07:52,350
detection and correction of typing

00:07:46,560 --> 00:07:54,720
errors this is kind of interesting thing

00:07:52,350 --> 00:07:57,960
this is a Czech language and I'm

00:07:54,720 --> 00:08:02,850
searching for a soap holder in your

00:07:57,960 --> 00:08:06,120
bathroom and this differences in this

00:08:02,850 --> 00:08:09,420
queries in one word in the in one letter

00:08:06,120 --> 00:08:12,120
in the second word and the difference I

00:08:09,420 --> 00:08:16,680
think here that first query was not

00:08:12,120 --> 00:08:21,870
corrected why because the second word

00:08:16,680 --> 00:08:25,020
Mila is means to wash and also basically

00:08:21,870 --> 00:08:28,590
this is the right word the right form

00:08:25,020 --> 00:08:32,490
but of a different word so we have two

00:08:28,590 --> 00:08:34,710
different words and they that way we

00:08:32,490 --> 00:08:36,900
were ending with lexical ambiguity so

00:08:34,710 --> 00:08:40,740
search system simply has nothing to do

00:08:36,900 --> 00:08:42,450
this it the only way to solve it is to

00:08:40,740 --> 00:08:45,450
take into account

00:08:42,450 --> 00:08:47,370
previous history of the queries or to

00:08:45,450 --> 00:08:52,910
take into account with surroundings of a

00:08:47,370 --> 00:08:57,980
query the surrounding words so first

00:08:52,910 --> 00:09:04,920
example is requesting search for example

00:08:57,980 --> 00:09:06,900
for some reason Google is completely

00:09:04,920 --> 00:09:09,210
forgetting about what am i searching for

00:09:06,900 --> 00:09:11,370
when I'm searching how to buy a used

00:09:09,210 --> 00:09:15,630
Xperia experience the sony ericsson

00:09:11,370 --> 00:09:18,710
mobile phone model name and so he's

00:09:15,630 --> 00:09:21,990
starting to give me some results about

00:09:18,710 --> 00:09:25,320
how to buy used things but the most

00:09:21,990 --> 00:09:27,060
important word in this queries xperia if

00:09:25,320 --> 00:09:30,920
you change it on how to buy used

00:09:27,060 --> 00:09:33,420
smartphone it works ok so it means like

00:09:30,920 --> 00:09:36,800
it has a different weighting of

00:09:33,420 --> 00:09:40,230
important words sometimes it's wrong

00:09:36,800 --> 00:09:44,700
there are also fundamental problems for

00:09:40,230 --> 00:09:47,460
example stupid query berlin by tomatoes

00:09:44,700 --> 00:09:53,160
where can i buy tomatoes in the big city

00:09:47,460 --> 00:10:00,240
so now and google actually found funnel

00:09:53,160 --> 00:10:07,740
in berlin total fail you know so the

00:10:00,240 --> 00:10:10,350
thing here is when you are we when we

00:10:07,740 --> 00:10:13,200
are putting search on our website we are

00:10:10,350 --> 00:10:16,650
always presuming assuming that our users

00:10:13,200 --> 00:10:20,310
have understanding of what they can

00:10:16,650 --> 00:10:26,220
search and what we could found but this

00:10:20,310 --> 00:10:31,530
is not always true and so try to figure

00:10:26,220 --> 00:10:34,590
out if there was a zero given result

00:10:31,530 --> 00:10:37,620
what user was found and you probably

00:10:34,590 --> 00:10:46,520
will be inspired a lot what do they find

00:10:37,620 --> 00:10:46,520
try to found this is a another example

00:10:49,230 --> 00:10:56,640
systems is that example of bad user

00:10:52,620 --> 00:11:00,270
experience so it systems is that anybody

00:10:56,640 --> 00:11:04,080
knows what systems is that uh-huh only

00:11:00,270 --> 00:11:08,010
few people systems is that is a check

00:11:04,080 --> 00:11:10,050
search system and only four countries in

00:11:08,010 --> 00:11:13,350
the world has its own search technology

00:11:10,050 --> 00:11:18,990
and Czech Republic is there so Russians

00:11:13,350 --> 00:11:23,430
checks china by do koreans and rest is

00:11:18,990 --> 00:11:26,310
my google so this is a check sir system

00:11:23,430 --> 00:11:28,470
and they tried experimented with this

00:11:26,310 --> 00:11:32,880
new user interface what we did they put

00:11:28,470 --> 00:11:38,460
a big snapshots of a website and so as a

00:11:32,880 --> 00:11:40,770
result what they have because of big

00:11:38,460 --> 00:11:45,840
snapshots which are giving not so much

00:11:40,770 --> 00:11:48,690
in useful information it has big bad

00:11:45,840 --> 00:11:51,210
user experience also order is not clear

00:11:48,690 --> 00:11:54,560
you know which result is better by means

00:11:51,210 --> 00:11:58,800
of search system right one or left one

00:11:54,560 --> 00:12:04,310
hard to say also half of a page is spent

00:11:58,800 --> 00:12:09,660
on advertisement and on domain Otto said

00:12:04,310 --> 00:12:12,660
so basically if you have such problems

00:12:09,660 --> 00:12:14,820
with interface well it could be not

00:12:12,660 --> 00:12:19,830
surprising that your users will not use

00:12:14,820 --> 00:12:25,230
your search too much yeah here's the

00:12:19,830 --> 00:12:26,940
examples of Russian web interface so if

00:12:25,230 --> 00:12:28,410
you are waiting too long for a loading

00:12:26,940 --> 00:12:32,190
kaif additional page you also could

00:12:28,410 --> 00:12:37,740
conclude that results are not so great

00:12:32,190 --> 00:12:45,750
and abandon the search okay so let's

00:12:37,740 --> 00:12:47,730
talk about evaluation so evaluation is

00:12:45,750 --> 00:12:51,470
basement for improvement of the

00:12:47,730 --> 00:12:54,570
relevance at the same time there is no

00:12:51,470 --> 00:12:57,600
ideal measure and it's just much more

00:12:54,570 --> 00:12:59,100
better to consult different measures

00:12:57,600 --> 00:13:00,810
when you are making a decision but it's

00:12:59,100 --> 00:13:02,270
matter has its own properties so you

00:13:00,810 --> 00:13:06,410
have to think about it

00:13:02,270 --> 00:13:11,230
yeah if it will show something wrong it

00:13:06,410 --> 00:13:13,940
doesn't have to be something wrong also

00:13:11,230 --> 00:13:17,360
evaluation of search could be done using

00:13:13,940 --> 00:13:19,550
click behavior of your users so or other

00:13:17,360 --> 00:13:24,340
interaction behavior if you have it so

00:13:19,550 --> 00:13:30,140
basically recording of alex is the mast

00:13:24,340 --> 00:13:32,420
so relevance is subjective why because

00:13:30,140 --> 00:13:37,490
of the context of a problem you try and

00:13:32,420 --> 00:13:41,510
solve for example if I would like to

00:13:37,490 --> 00:13:46,130
move from point A to B and I'm searching

00:13:41,510 --> 00:13:49,340
for a taxi so search system looks at it

00:13:46,130 --> 00:13:52,490
okay he wants Texas so I will show him

00:13:49,340 --> 00:13:56,300
the best website about the taxi so

00:13:52,490 --> 00:13:59,930
basically the search system lacks of the

00:13:56,300 --> 00:14:04,460
context of a problem and simply will not

00:13:59,930 --> 00:14:05,780
give me a relevant result I need and the

00:14:04,460 --> 00:14:10,220
second thing is awareness about a

00:14:05,780 --> 00:14:12,860
problem so if you are interested for

00:14:10,220 --> 00:14:16,970
example in the conflict on Ukraine and

00:14:12,860 --> 00:14:18,980
you would like to know what is the last

00:14:16,970 --> 00:14:22,280
news so you entering the query last news

00:14:18,980 --> 00:14:24,920
in the advil Ukraine and if their system

00:14:22,280 --> 00:14:26,870
will not give you a nothing Neal from

00:14:24,920 --> 00:14:32,240
your perspective you could conclude with

00:14:26,870 --> 00:14:34,880
relevance is bad for this query end and

00:14:32,240 --> 00:14:37,010
so on so also user interface could

00:14:34,880 --> 00:14:40,490
affect decisions about user about

00:14:37,010 --> 00:14:44,770
relevance bad document annotations it

00:14:40,490 --> 00:14:48,320
was shown on the previous slide that

00:14:44,770 --> 00:14:50,870
good good lead also to decision of

00:14:48,320 --> 00:14:52,460
battery levels presentation form and

00:14:50,870 --> 00:14:56,080
previous experience with his search

00:14:52,460 --> 00:15:01,220
system which is very important because

00:14:56,080 --> 00:15:04,130
for example some search systems has its

00:15:01,220 --> 00:15:08,210
own properties like Yandex Russians your

00:15:04,130 --> 00:15:11,050
system works not so well for developers

00:15:08,210 --> 00:15:15,550
queries I mean software development and

00:15:11,050 --> 00:15:20,230
so system societies works

00:15:15,550 --> 00:15:25,029
also badly for for English queries and

00:15:20,230 --> 00:15:26,920
so on so we will talk talk about free

00:15:25,029 --> 00:15:28,720
methods query by quick comparison of two

00:15:26,920 --> 00:15:31,420
system classic clever dunne's cranfield

00:15:28,720 --> 00:15:35,140
and pairwise evaluation that one is

00:15:31,420 --> 00:15:37,899
experimental so queerly back video

00:15:35,140 --> 00:15:42,839
comparison if you have to search systems

00:15:37,899 --> 00:15:47,230
and you want to compare them you can

00:15:42,839 --> 00:15:50,110
this method works only if the search

00:15:47,230 --> 00:15:52,360
results do differ significantly for

00:15:50,110 --> 00:15:55,420
minor changes it doesn't work so if you

00:15:52,360 --> 00:15:57,579
take 100 of the curious then query each

00:15:55,420 --> 00:16:00,700
system and will wait the whole syrup

00:15:57,579 --> 00:16:04,930
search engines results page for top end

00:16:00,700 --> 00:16:07,420
results with with one judgment and the

00:16:04,930 --> 00:16:10,000
scale is simple good very good bad very

00:16:07,420 --> 00:16:15,000
bad so and then count judgments of each

00:16:10,000 --> 00:16:17,560
type so here I evaluated to queries of

00:16:15,000 --> 00:16:21,250
Berlin buzzwords and Java byte output

00:16:17,560 --> 00:16:25,779
stream and I see you see there but

00:16:21,250 --> 00:16:30,130
Google is has a very good pink is kind

00:16:25,779 --> 00:16:32,470
of good and finally there is a summary

00:16:30,130 --> 00:16:35,410
we see that google is better because it

00:16:32,470 --> 00:16:37,990
has to 14 very good and the world and

00:16:35,410 --> 00:16:41,350
one for good and being has one for good

00:16:37,990 --> 00:16:42,640
and one for that so of course numbers

00:16:41,350 --> 00:16:45,880
will be much more higher when you

00:16:42,640 --> 00:16:48,610
evaluate 100 queries and that way you

00:16:45,880 --> 00:16:50,829
can make decision you can apply it for

00:16:48,610 --> 00:16:54,579
example if you have the same search

00:16:50,829 --> 00:16:57,640
engine but different search databases or

00:16:54,579 --> 00:17:00,220
you can apply it if you have the same

00:16:57,640 --> 00:17:02,260
search database but different engines

00:17:00,220 --> 00:17:04,240
when you are testing which ranking is

00:17:02,260 --> 00:17:06,459
better or if you are changing the

00:17:04,240 --> 00:17:10,600
similarity model you can also test it by

00:17:06,459 --> 00:17:12,880
the vet approach here's the thyroid

00:17:10,600 --> 00:17:15,429
clever done he is the British librarian

00:17:12,880 --> 00:17:17,169
and he is best known for his work on the

00:17:15,429 --> 00:17:21,280
evaluation information retrieval system

00:17:17,169 --> 00:17:23,980
that guy is responsible for the classic

00:17:21,280 --> 00:17:27,339
approach which is heavily used in all

00:17:23,980 --> 00:17:28,710
major search systems like Google bank

00:17:27,339 --> 00:17:34,360
and yonder

00:17:28,710 --> 00:17:41,080
so he's also responsible for he proved

00:17:34,360 --> 00:17:43,660
that use H of a flexible terms list in

00:17:41,080 --> 00:17:49,300
the index bringing more quality than the

00:17:43,660 --> 00:17:52,600
fixed lexicon it wasn't clear before so

00:17:49,300 --> 00:17:54,670
what components it has document

00:17:52,600 --> 00:17:58,390
collection set of queries and then set

00:17:54,670 --> 00:18:01,450
of relevance judgments so and then

00:17:58,390 --> 00:18:03,430
measures precision is a fraction of

00:18:01,450 --> 00:18:06,370
retrieve documents that are relevant and

00:18:03,430 --> 00:18:11,860
recall percent of all relevant documents

00:18:06,370 --> 00:18:15,760
returned by the search system so recall

00:18:11,860 --> 00:18:19,360
is the kind of thing which is very hard

00:18:15,760 --> 00:18:21,700
to measure because you need to know how

00:18:19,360 --> 00:18:24,460
much relevant documents is in your

00:18:21,700 --> 00:18:27,330
collection which is very hard to judge

00:18:24,460 --> 00:18:31,840
manually because collections are big

00:18:27,330 --> 00:18:34,780
usually so this is an example for query

00:18:31,840 --> 00:18:38,020
Berlin buzzwords we have seven documents

00:18:34,780 --> 00:18:40,780
and here is the judgment relevant is

00:18:38,020 --> 00:18:42,790
relevant and our is not relevant so and

00:18:40,780 --> 00:18:45,310
finally we calculate measures so

00:18:42,790 --> 00:18:48,610
precision is about 71 percent we simply

00:18:45,310 --> 00:18:52,060
divide count of relevance on our account

00:18:48,610 --> 00:18:53,890
and recall is not shown because when you

00:18:52,060 --> 00:18:56,680
are working with web scale collection

00:18:53,890 --> 00:19:01,800
you never know how many relevant results

00:18:56,680 --> 00:19:05,590
the results do exist so when you are

00:19:01,800 --> 00:19:07,300
evaluating many queries then you have to

00:19:05,590 --> 00:19:09,700
somehow calculate the final measure

00:19:07,300 --> 00:19:13,360
there are two ways you can do micro

00:19:09,700 --> 00:19:16,630
averaging and microwave a raging the

00:19:13,360 --> 00:19:19,690
difference here is imagine you have a

00:19:16,630 --> 00:19:22,090
free classes of queries queries with

00:19:19,690 --> 00:19:28,410
good precision we receive bad precision

00:19:22,090 --> 00:19:32,800
and queries with an average precision so

00:19:28,410 --> 00:19:36,060
simply micro average will will reflect

00:19:32,800 --> 00:19:40,550
the class which represents the majority

00:19:36,060 --> 00:19:43,790
know if you want to know something about

00:19:40,550 --> 00:19:46,070
how it behaves on less popular classes

00:19:43,790 --> 00:19:47,720
you have to use micro average there are

00:19:46,070 --> 00:19:51,050
also add variations of this measure

00:19:47,720 --> 00:19:53,480
which is working only counting four top

00:19:51,050 --> 00:19:55,160
5 4 4 10 10 results and they call

00:19:53,480 --> 00:20:01,880
precision one precision five or

00:19:55,160 --> 00:20:04,400
precision ten another measure is well

00:20:01,880 --> 00:20:07,220
known in the information retrieval

00:20:04,400 --> 00:20:10,430
community on all learning to rank

00:20:07,220 --> 00:20:12,050
challenges is called nirmala is

00:20:10,430 --> 00:20:14,030
discounted cumulative gain and it

00:20:12,050 --> 00:20:16,160
measures usefulness or gain of document

00:20:14,030 --> 00:20:19,970
based on its position in the result list

00:20:16,160 --> 00:20:21,710
so the gain is accumulated from the top

00:20:19,970 --> 00:20:23,720
afrezza a place to the bottom with a

00:20:21,710 --> 00:20:26,480
gain of each result discounted at lower

00:20:23,720 --> 00:20:29,420
ranks in the formula of dcg you see the

00:20:26,480 --> 00:20:32,450
denominator and in denominator we have I

00:20:29,420 --> 00:20:37,970
the position number so basically the

00:20:32,450 --> 00:20:40,040
nominator does the discounting so the

00:20:37,970 --> 00:20:43,370
core difference of this measure from

00:20:40,040 --> 00:20:45,590
precision is that this measure takes

00:20:43,370 --> 00:20:47,840
into account the position where document

00:20:45,590 --> 00:20:53,150
was marked as relevant for example

00:20:47,840 --> 00:20:55,400
precision if you have two queries for a

00:20:53,150 --> 00:20:58,340
first query you have real relevant at

00:20:55,400 --> 00:20:59,660
the bottom for the second query for

00:20:58,340 --> 00:21:00,980
bottom of the list and for the second

00:20:59,660 --> 00:21:03,560
where you have at the top of the list

00:21:00,980 --> 00:21:05,960
relevance for precision then it will be

00:21:03,560 --> 00:21:09,800
the same but this measure will reflect

00:21:05,960 --> 00:21:11,600
the difference in the positions so in

00:21:09,800 --> 00:21:13,580
order to calculate normalize discounted

00:21:11,600 --> 00:21:16,630
cumulative give me you have to calculate

00:21:13,580 --> 00:21:20,420
IDC tree which is for ideal ranking and

00:21:16,630 --> 00:21:25,130
so this is done by simply searching the

00:21:20,420 --> 00:21:27,980
results of your evaluated query by

00:21:25,130 --> 00:21:32,420
relevance putting relevant on top that

00:21:27,980 --> 00:21:34,550
way you will get ideal ranking and you

00:21:32,420 --> 00:21:43,060
can calculate IDC G that way by the same

00:21:34,550 --> 00:21:43,060
formula sorry so here's a pairwise

00:21:43,120 --> 00:21:50,420
evaluation with Swiss tournament system

00:21:47,770 --> 00:21:53,980
and guess the most complex fink in this

00:21:50,420 --> 00:21:59,690
talk so

00:21:53,980 --> 00:22:03,200
first of all this this kind of method is

00:21:59,690 --> 00:22:04,580
true is working for document pairs so

00:22:03,200 --> 00:22:06,680
you're not judging the whole query

00:22:04,580 --> 00:22:09,860
you're judging with document pairs for

00:22:06,680 --> 00:22:12,770
it simply you have to answer each time

00:22:09,860 --> 00:22:15,340
the simple simple answer which document

00:22:12,770 --> 00:22:21,650
is more relevant to the query X and then

00:22:15,340 --> 00:22:23,930
I'm can say left right or equal and so

00:22:21,650 --> 00:22:25,610
if you say left left one will get one

00:22:23,930 --> 00:22:27,980
point if you say right right one will

00:22:25,610 --> 00:22:32,540
get one point equal both will get by one

00:22:27,980 --> 00:22:36,620
point so chosen document is getting okay

00:22:32,540 --> 00:22:40,580
lready said it so the tricky thing here

00:22:36,620 --> 00:22:45,320
is the preparation of pairs here's the

00:22:40,580 --> 00:22:48,050
complex him about it so let's think we

00:22:45,320 --> 00:22:51,770
started with initial set no ranking at

00:22:48,050 --> 00:22:56,720
all so we we are randomly shuffling it

00:22:51,770 --> 00:23:01,190
and dividing on two parts and then doing

00:22:56,720 --> 00:23:03,620
the first pass so in the first pass you

00:23:01,190 --> 00:23:05,660
have to compare first from the first

00:23:03,620 --> 00:23:08,090
half and first from the second half and

00:23:05,660 --> 00:23:13,250
so on so second from the first half

00:23:08,090 --> 00:23:17,630
second from second half you see it on

00:23:13,250 --> 00:23:23,990
the table in the right then you have the

00:23:17,630 --> 00:23:27,620
results of a first pass so g46 d2 d1 got

00:23:23,990 --> 00:23:30,230
by one point doing the same for them so

00:23:27,620 --> 00:23:33,680
only winners will participate in the

00:23:30,230 --> 00:23:37,310
next pass so in the second pass we are

00:23:33,680 --> 00:23:42,500
comparing drd4 vers versus d 2 and d 6

00:23:37,310 --> 00:23:45,620
vs do you want so d2 and d1 taking by

00:23:42,500 --> 00:23:50,270
one point and go into the third pass

00:23:45,620 --> 00:23:53,930
third passes needs one click so third

00:23:50,270 --> 00:23:56,360
pass will get d one and the same and now

00:23:53,930 --> 00:23:59,480
they see the final ranking by the points

00:23:56,360 --> 00:24:04,780
so d1 got the free point we do 22 points

00:23:59,480 --> 00:24:04,780
before and just six by one point so

00:24:05,680 --> 00:24:15,620
pairwise evaluation which this system

00:24:08,750 --> 00:24:19,730
takes about 10 judgments maximum 9410

00:24:15,620 --> 00:24:22,430
documenter interest for one query why am

00:24:19,730 --> 00:24:27,680
I proposing this because it is much more

00:24:22,430 --> 00:24:29,390
cheaper to click for two documents to to

00:24:27,680 --> 00:24:34,900
judge from the two documents when to

00:24:29,390 --> 00:24:34,900
judge the whole top top 10 because

00:24:34,960 --> 00:24:41,360
because usually when you're doing

00:24:38,300 --> 00:24:43,760
judgment you need to make it in some

00:24:41,360 --> 00:24:46,460
reliable way because if two different

00:24:43,760 --> 00:24:50,750
people will make judgments it's quite

00:24:46,460 --> 00:24:53,270
likely that we will not agree so the

00:24:50,750 --> 00:24:55,490
agreement between two judges using

00:24:53,270 --> 00:25:03,650
pairwise evaluation is much more easier

00:24:55,490 --> 00:25:05,600
to get than for classic approach so this

00:25:03,650 --> 00:25:08,660
is kind of achievement replayed cheap

00:25:05,600 --> 00:25:10,730
replacement of a classic approach after

00:25:08,660 --> 00:25:13,550
judgment is finished ringing is built by

00:25:10,730 --> 00:25:16,040
gifford points and according to position

00:25:13,550 --> 00:25:18,290
weights are assigned to the documents

00:25:16,040 --> 00:25:20,540
and then using weights the machine

00:25:18,290 --> 00:25:23,650
learned model can be trained or you can

00:25:20,540 --> 00:25:30,020
calculate and ECG NTC is perfectly fit

00:25:23,650 --> 00:25:32,840
into this model so here's a example of

00:25:30,020 --> 00:25:35,060
how weights could be assigned basically

00:25:32,840 --> 00:25:40,910
i'm getting i'm giving more weight to

00:25:35,060 --> 00:25:47,300
the first documents than to the last so

00:25:40,910 --> 00:25:50,780
signals here is a small agenda of this

00:25:47,300 --> 00:25:54,440
part the text relevance has a diversity

00:25:50,780 --> 00:25:56,090
of tasks and use hmm any signals

00:25:54,440 --> 00:25:59,450
including query classifiers it's the

00:25:56,090 --> 00:26:01,900
only way and also production system if

00:25:59,450 --> 00:26:06,380
you have it what data we have available

00:26:01,900 --> 00:26:10,659
social signals and if we have some

00:26:06,380 --> 00:26:14,349
integration of social media or we have a

00:26:10,659 --> 00:26:16,710
some components of social social

00:26:14,349 --> 00:26:19,619
networks you include it on your website

00:26:16,710 --> 00:26:23,320
and finally how to mix the signals

00:26:19,619 --> 00:26:26,080
simple menu linear model or the most

00:26:23,320 --> 00:26:30,059
advanced a state of art technique

00:26:26,080 --> 00:26:36,159
gradient this with the decision trees so

00:26:30,059 --> 00:26:38,019
diversity of text for example if you

00:26:36,159 --> 00:26:41,409
have a phrase search phrase search is a

00:26:38,019 --> 00:26:43,929
when you are have a long sequence of

00:26:41,409 --> 00:26:46,210
words and you want to find it exactly

00:26:43,929 --> 00:26:49,090
matching and this is called the phrase

00:26:46,210 --> 00:26:51,849
search search for named entities like

00:26:49,090 --> 00:26:54,129
cities names search for of codes

00:26:51,849 --> 00:26:56,489
articles telephone numbers search of

00:26:54,129 --> 00:27:00,879
your questions search of set expressions

00:26:56,489 --> 00:27:03,039
all these types of queries having

00:27:00,879 --> 00:27:06,159
differences for example they are

00:27:03,039 --> 00:27:10,479
different in length they are different

00:27:06,159 --> 00:27:14,259
in turn frequency distributions they are

00:27:10,479 --> 00:27:21,489
different in idf's anybody knows what

00:27:14,259 --> 00:27:25,479
IDF is uh huh IDF is the inverted

00:27:21,489 --> 00:27:34,049
document frequency it is calculated for

00:27:25,479 --> 00:27:39,700
the whole search collection so basically

00:27:34,049 --> 00:27:44,159
it's very hard for a one model to work

00:27:39,700 --> 00:27:44,159
well on all types of these queries so

00:27:44,249 --> 00:27:51,849
the solution is many signals so first

00:27:48,700 --> 00:27:54,849
thing is a query type detection so we

00:27:51,849 --> 00:27:58,509
can build a simple rules or classifiers

00:27:54,849 --> 00:28:01,899
to somehow detect a query type and then

00:27:58,509 --> 00:28:06,789
use it as a signal then we can calculate

00:28:01,899 --> 00:28:09,249
the end 25-5 zoned version usually all

00:28:06,789 --> 00:28:11,950
HTML documents has a meta description

00:28:09,249 --> 00:28:14,889
meta keywords field so we can calculate

00:28:11,950 --> 00:28:16,659
especially for these fields at bn25 we

00:28:14,889 --> 00:28:18,729
can calculate the m25 and query

00:28:16,659 --> 00:28:22,749
expansions so we can expand the existing

00:28:18,729 --> 00:28:23,990
query using word forms we can expand it

00:28:22,749 --> 00:28:26,419
using this

00:28:23,990 --> 00:28:34,490
we can expand it using abbreviations

00:28:26,419 --> 00:28:37,140
translate and fragments we can also use

00:28:34,490 --> 00:28:38,850
properties of distribution of count of

00:28:37,140 --> 00:28:41,820
subsequent query words found in the

00:28:38,850 --> 00:28:45,570
document we can use the same thing for a

00:28:41,820 --> 00:28:47,640
query order the same thing for a

00:28:45,570 --> 00:28:51,270
distance plus minus three one two three

00:28:47,640 --> 00:28:53,309
words and so on we can also build a

00:28:51,270 --> 00:28:55,980
language model document and use it for

00:28:53,309 --> 00:28:59,340
ranking or we can build a language model

00:28:55,980 --> 00:29:02,820
for a query language model is simply a

00:28:59,340 --> 00:29:05,610
dictionary of words this is language

00:29:02,820 --> 00:29:08,669
would order a language model of first

00:29:05,610 --> 00:29:12,419
order connected with a frequencies with

00:29:08,669 --> 00:29:14,220
probabilities of a peer Inc of with

00:29:12,419 --> 00:29:17,429
words and this probabilities can be used

00:29:14,220 --> 00:29:22,710
to the signals so here is the simple

00:29:17,429 --> 00:29:26,669
example of how we can mix signals so

00:29:22,710 --> 00:29:30,140
ABCD can be estimated manually or it can

00:29:26,669 --> 00:29:30,140
be estimated using relevance judgments

00:29:34,820 --> 00:29:42,570
so ok if we have production system so

00:29:39,720 --> 00:29:46,230
what does it means it means that we have

00:29:42,570 --> 00:29:49,580
a real search and users are making

00:29:46,230 --> 00:29:53,850
queries there and we're clicking results

00:29:49,580 --> 00:29:56,370
so it means that we can record this data

00:29:53,850 --> 00:29:59,960
process it in the background or in real

00:29:56,370 --> 00:30:03,210
time if you can afford it and then

00:29:59,960 --> 00:30:07,380
extract signals from it and use it in

00:30:03,210 --> 00:30:10,020
ranking this is actually how do all big

00:30:07,380 --> 00:30:16,460
search system works like Google binky

00:30:10,020 --> 00:30:20,090
and X so first office that will be I

00:30:16,460 --> 00:30:24,950
will just count examples of possible

00:30:20,090 --> 00:30:27,210
features we could get from from clicks

00:30:24,950 --> 00:30:29,039
so for documents we can get a

00:30:27,210 --> 00:30:30,690
click-through rate of a document click

00:30:29,039 --> 00:30:33,570
through rate is a count of clicks

00:30:30,690 --> 00:30:36,870
divided on the count of shows we can get

00:30:33,570 --> 00:30:37,440
absolute number of clicks count of times

00:30:36,870 --> 00:30:39,480
when docking

00:30:37,440 --> 00:30:42,090
was clicked first in search engine

00:30:39,480 --> 00:30:45,090
results page the same time when it was

00:30:42,090 --> 00:30:47,279
clicked last count of clicks on the same

00:30:45,090 --> 00:30:54,539
search engines resulted before after the

00:30:47,279 --> 00:30:57,269
document was clicked so then we can get

00:30:54,539 --> 00:30:59,039
some features for our shows for example

00:30:57,269 --> 00:31:02,389
count of times when document was

00:30:59,039 --> 00:31:06,120
displayed on search engine results page

00:31:02,389 --> 00:31:08,100
so is it popular or not count of unique

00:31:06,120 --> 00:31:10,679
queries where document was displayed if

00:31:08,100 --> 00:31:15,149
we are finding one document for a mini

00:31:10,679 --> 00:31:18,350
queries it means something perhaps it

00:31:15,149 --> 00:31:23,250
contains a lot of diverse information

00:31:18,350 --> 00:31:26,750
and we should show it more for example

00:31:23,250 --> 00:31:30,029
document position properties

00:31:26,750 --> 00:31:31,830
distribution properties where do we show

00:31:30,029 --> 00:31:39,629
this document in average on what

00:31:31,830 --> 00:31:41,759
position for queries we can collect for

00:31:39,629 --> 00:31:45,269
example absolute click count on query

00:31:41,759 --> 00:31:48,570
this query clickable at all is this kind

00:31:45,269 --> 00:31:53,450
of a successful query we can collect

00:31:48,570 --> 00:31:57,539
abandonment rate and so how many times

00:31:53,450 --> 00:32:03,149
user enters the query and then abandon

00:31:57,539 --> 00:32:05,129
the search at all CGR of the query time

00:32:03,149 --> 00:32:09,710
spent on search engines results page so

00:32:05,129 --> 00:32:12,059
if users are looking something in this

00:32:09,710 --> 00:32:14,759
well looking for a long time on this

00:32:12,059 --> 00:32:20,039
query it means that there is something

00:32:14,759 --> 00:32:24,029
to look so time spent till first last

00:32:20,039 --> 00:32:28,710
click so is results accessible on this

00:32:24,029 --> 00:32:32,070
query or not query frequency count of

00:32:28,710 --> 00:32:35,909
words in the query finally count of

00:32:32,070 --> 00:32:39,090
query reformulations our formulation is

00:32:35,909 --> 00:32:42,750
when you have a subsequent queries but

00:32:39,090 --> 00:32:46,289
you have a changes only in one word or

00:32:42,750 --> 00:32:48,580
two words and so user is doing the same

00:32:46,289 --> 00:32:51,539
query changing one word just

00:32:48,580 --> 00:32:55,149
looking for something and try trying to

00:32:51,539 --> 00:32:59,649
defeat the search system and so this

00:32:55,149 --> 00:33:02,320
kind of stuff is very important and we

00:32:59,649 --> 00:33:04,269
also can count of how much there was a

00:33:02,320 --> 00:33:11,289
query reformulation for this query and

00:33:04,269 --> 00:33:12,850
see char of these reformulations if we

00:33:11,289 --> 00:33:16,539
have some integration with social media

00:33:12,850 --> 00:33:19,809
or we have a some parts of social media

00:33:16,539 --> 00:33:22,240
in on our website we can use count of

00:33:19,809 --> 00:33:25,120
readers commenters of the content we can

00:33:22,240 --> 00:33:27,399
also count the comments published during

00:33:25,120 --> 00:33:32,710
some time period which is velocity so

00:33:27,399 --> 00:33:35,159
how this big Grove we can count time

00:33:32,710 --> 00:33:39,490
since last comment we can also count

00:33:35,159 --> 00:33:44,370
speed of likes Grove we can count how

00:33:39,490 --> 00:33:47,230
much time was since last like and so on

00:33:44,370 --> 00:33:49,480
how to mix the signals there is a

00:33:47,230 --> 00:33:53,679
well-known problem in machine learning

00:33:49,480 --> 00:33:56,610
called learning to rank so basically

00:33:53,679 --> 00:33:59,200
this is application of machine learning

00:33:56,610 --> 00:34:04,210
studying how to construct the good

00:33:59,200 --> 00:34:06,190
ranking model there are some in learning

00:34:04,210 --> 00:34:08,440
to rank challenges for example yahoo

00:34:06,190 --> 00:34:12,520
learning to rank challenge where they

00:34:08,440 --> 00:34:16,570
are just giving them to participants the

00:34:12,520 --> 00:34:19,270
judge data set and they create models

00:34:16,570 --> 00:34:22,750
for this data set and then measure

00:34:19,270 --> 00:34:25,659
somehow which model is better whose mod

00:34:22,750 --> 00:34:27,280
model is better so this is a full-scale

00:34:25,659 --> 00:34:31,030
process how it is done in Big Sur

00:34:27,280 --> 00:34:33,909
systems like Google Bing and X first we

00:34:31,030 --> 00:34:36,399
have a do prepared training set so they

00:34:33,909 --> 00:34:39,399
prepare documents queries and relevance

00:34:36,399 --> 00:34:42,070
judgments and they renew this so very

00:34:39,399 --> 00:34:48,339
nude adding new documents adding new

00:34:42,070 --> 00:34:52,649
queries and renewing relevance judgments

00:34:48,339 --> 00:34:57,160
because it could happen that's for some

00:34:52,649 --> 00:35:02,349
reason the document was irrelevant now

00:34:57,160 --> 00:35:04,479
it is not then they have a framework

00:35:02,349 --> 00:35:07,329
if you have a distributed search system

00:35:04,479 --> 00:35:09,249
on many machines you need a way how to

00:35:07,329 --> 00:35:14,710
get the feature vectors for your machine

00:35:09,249 --> 00:35:17,650
learning it means it could be not so

00:35:14,710 --> 00:35:21,609
easy to do if you if you have it

00:35:17,650 --> 00:35:23,499
distributed then we do learning mode of

00:35:21,609 --> 00:35:28,660
the model so it means we have some

00:35:23,499 --> 00:35:29,890
implementation of how to say it some

00:35:28,660 --> 00:35:33,190
implementation for learning algorithm

00:35:29,890 --> 00:35:35,710
and they do use it and then they do

00:35:33,190 --> 00:35:39,400
evaluation for example they have a be

00:35:35,710 --> 00:35:44,499
testing where we can compare fifty to

00:35:39,400 --> 00:35:46,660
fifty percent which ranking is better if

00:35:44,499 --> 00:35:48,400
previous ranking is better we can we

00:35:46,660 --> 00:35:52,140
learn the model and so on and they do

00:35:48,400 --> 00:35:54,789
repetition of all that stuff because

00:35:52,140 --> 00:35:58,890
internet is changing so features are

00:35:54,789 --> 00:36:05,499
also changing so from time to time Model

00:35:58,890 --> 00:36:07,690
Model degrades mm-hmm how to mix signals

00:36:05,499 --> 00:36:11,410
do it yourself wave so we can do it

00:36:07,690 --> 00:36:14,769
easier well we can try to do it cheaper

00:36:11,410 --> 00:36:17,049
or indie way so we can choose manually

00:36:14,769 --> 00:36:18,759
some set of features which we think a

00:36:17,049 --> 00:36:20,650
good predictors and then we can create a

00:36:18,759 --> 00:36:27,099
simple linear model this is an example

00:36:20,650 --> 00:36:29,799
and here the coefficients needs to be

00:36:27,099 --> 00:36:32,410
filled so we can take ten representative

00:36:29,799 --> 00:36:35,049
query spent one hour and fit them

00:36:32,410 --> 00:36:37,509
manually this is better than nothing of

00:36:35,049 --> 00:36:42,219
course this is a dump approach but it

00:36:37,509 --> 00:36:47,140
works it works somehow so gradient

00:36:42,219 --> 00:36:50,289
boosted decision trees here basically is

00:36:47,140 --> 00:36:53,099
the state-of-art method if you want to

00:36:50,289 --> 00:36:57,460
mix them if you have relevance judgments

00:36:53,099 --> 00:37:04,109
you can use this kind of algorithm to

00:36:57,460 --> 00:37:11,099
mix these signals so do you have time

00:37:04,109 --> 00:37:14,050
one minute so here's the

00:37:11,099 --> 00:37:17,250
small explanation of how big and boosted

00:37:14,050 --> 00:37:20,530
decision trees working this is simply an

00:37:17,250 --> 00:37:25,240
example of the small trees not so deep

00:37:20,530 --> 00:37:27,970
so basically each tree is learned on the

00:37:25,240 --> 00:37:32,560
subsample of a whole training set it

00:37:27,970 --> 00:37:36,040
means it means that you it will learn

00:37:32,560 --> 00:37:40,030
the all nuances of your or trade

00:37:36,040 --> 00:37:45,099
training set that way because it they

00:37:40,030 --> 00:37:46,480
babe we are becoming more more like more

00:37:45,099 --> 00:37:52,390
important when you're working with

00:37:46,480 --> 00:37:55,330
subsample and then it adds the result of

00:37:52,390 --> 00:37:58,900
each decision tree on each iteration so

00:37:55,330 --> 00:38:01,660
there could be a thousand sophistries so

00:37:58,900 --> 00:38:05,310
you see there are learning to rank

00:38:01,660 --> 00:38:08,440
challenge of Yahoo and we can see the

00:38:05,310 --> 00:38:14,859
expected reciprocal rank and normalized

00:38:08,440 --> 00:38:16,750
ECG of comparison so as we see gradient

00:38:14,859 --> 00:38:20,890
boosting trees is the best by all

00:38:16,750 --> 00:38:24,160
measures and the difference in the

00:38:20,890 --> 00:38:31,900
second digit after the coma is the most

00:38:24,160 --> 00:38:34,599
important one so these results are of

00:38:31,900 --> 00:38:37,810
the LGBT is with showing great

00:38:34,599 --> 00:38:40,180
difference between B and 25 f and g be

00:38:37,810 --> 00:38:43,810
geeky rank is van is ranking sem and

00:38:40,180 --> 00:38:45,880
bn25 f is one future text future below

00:38:43,810 --> 00:38:50,230
you see that very used a pretty big data

00:38:45,880 --> 00:38:52,630
set like 20 thousands of queries and for

00:38:50,230 --> 00:38:55,510
training and about 7,000 for testing

00:38:52,630 --> 00:38:58,000
which is a lot so okay we have no time

00:38:55,510 --> 00:39:00,700
for snippets but presentation will be

00:38:58,000 --> 00:39:06,720
published if you are interested you can

00:39:00,700 --> 00:39:06,720
download it and read it thank you

00:39:10,910 --> 00:39:17,579
great thanks maybe we have time for one

00:39:14,220 --> 00:39:20,819
quick really good question so who wants

00:39:17,579 --> 00:39:25,319
to take it I'm no one so what's the

00:39:20,819 --> 00:39:27,779
question so I have a question most of

00:39:25,319 --> 00:39:31,400
your optimization is carried out for and

00:39:27,779 --> 00:39:35,210
ECG right you look at other metrics like

00:39:31,400 --> 00:39:38,309
diversity like in trollese diversity or

00:39:35,210 --> 00:39:40,170
how popular are the websites you show

00:39:38,309 --> 00:39:46,049
and things like that other properties

00:39:40,170 --> 00:39:48,960
beyond pure accuracy and I did not hurt

00:39:46,049 --> 00:39:51,359
you well for do you look more properties

00:39:48,960 --> 00:39:53,990
besides end ECG and accuracy do you look

00:39:51,359 --> 00:39:56,880
at things like diversity in the list or

00:39:53,990 --> 00:40:00,119
or how popular are the results you are

00:39:56,880 --> 00:40:02,160
showing because then I guess you might

00:40:00,119 --> 00:40:04,799
fall into the filter bubble and not

00:40:02,160 --> 00:40:09,049
allow users to discover new content may

00:40:04,799 --> 00:40:12,740
be so it's come to get across in here

00:40:09,049 --> 00:40:15,359
sorry for that I really don't hear very

00:40:12,740 --> 00:40:17,730
curse maybe we can take it from outsides

00:40:15,359 --> 00:40:20,369
better well I will definitely answer you

00:40:17,730 --> 00:40:22,609
sure great well thank you very much

00:40:20,369 --> 00:40:22,609

YouTube URL: https://www.youtube.com/watch?v=z8MJZaPbnHw


