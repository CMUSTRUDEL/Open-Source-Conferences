Title: Berlin Buzzwords 2014: Clinton Gormley - ElasticSearch Query DSL - Not just for wizards #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	The ElasticSearch Query DSL is a rich, flexible, powerful query language for full text and structured search, but with power comes complexity. Which of the 40 available queries should you use? What's a filter and when should you use it? How do you combine multiple filters, or multiple queries or queries with filters?

To most users, "relevance", and how it is affected by different queries, is a black box. Multi-field queries in particular can be difficult to get right if you don't understand how they work. 

In this talk, I will explain the Query DSL from the ground up: how filters and queries use the inverted index to find matching documents, how the relevance score is calculated, how to combine the filter/query building blocks into complex statements. And finally, I will talk about the pitfalls of multi-field queries and how to avoid them.

Read more: 
https://2014.berlinbuzzwords.de/session/elasticsearch-query-dsl-not-just-wizards

About Clinton Gormley:
https://2014.berlinbuzzwords.de/user/285/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,530 --> 00:00:13,960
I all so we begin my name is Clinton

00:00:11,950 --> 00:00:16,299
Gormley I work at elastic

00:00:13,960 --> 00:00:29,759
and I've been involved with elastic

00:00:16,299 --> 00:00:31,750
search for is that me or I back been

00:00:29,759 --> 00:00:33,370
involved with elastic search for four

00:00:31,750 --> 00:00:36,310
years now since the first release and

00:00:33,370 --> 00:00:39,070
I'm currently writing the definitive

00:00:36,310 --> 00:00:42,070
guide with O'Reilly and my colleague

00:00:39,070 --> 00:00:45,070
Zack tongue which is aimed to be

00:00:42,070 --> 00:00:47,670
released in November but you can see it

00:00:45,070 --> 00:00:51,609
online and read it online for free at

00:00:47,670 --> 00:00:54,460
elasticsearch orgs slash guide I'm

00:00:51,609 --> 00:00:55,809
guessing that most of you have heard of

00:00:54,460 --> 00:00:57,910
elastic search which is why are you here

00:00:55,809 --> 00:01:01,269
how many people are using it in

00:00:57,910 --> 00:01:05,379
production okay a fair number

00:01:01,269 --> 00:01:06,730
so this slide probably doesn't it isn't

00:01:05,379 --> 00:01:08,710
really necessary for most of you but

00:01:06,730 --> 00:01:11,070
I'll go through it for those who may not

00:01:08,710 --> 00:01:14,220
know elastic search is a real-time

00:01:11,070 --> 00:01:17,800
distributed search and analytics engine

00:01:14,220 --> 00:01:19,869
so it does search which is what Lusine

00:01:17,800 --> 00:01:22,930
does but it handles full text and

00:01:19,869 --> 00:01:25,540
structured values like numbers dates to

00:01:22,930 --> 00:01:27,909
your locations etc as well it can

00:01:25,540 --> 00:01:30,250
perform analytics on those values it

00:01:27,909 --> 00:01:32,409
does this all in real time and it's

00:01:30,250 --> 00:01:34,990
distributed so can scale are

00:01:32,409 --> 00:01:38,649
horizontally and support a huge amount

00:01:34,990 --> 00:01:41,200
of data and the search part requires

00:01:38,649 --> 00:01:43,360
three chunks of functionality the

00:01:41,200 --> 00:01:45,399
mapping which is really how you define

00:01:43,360 --> 00:01:47,770
your fields is this an integer is it a

00:01:45,399 --> 00:01:50,590
date is it a geolocation is it a string

00:01:47,770 --> 00:01:52,780
if it's a string is an exact value

00:01:50,590 --> 00:01:55,960
string like a status code or something

00:01:52,780 --> 00:01:58,359
or is it a full text string if it's a

00:01:55,960 --> 00:02:00,189
full text string you want to analyze it

00:01:58,359 --> 00:02:03,219
before you index it to make it more

00:02:00,189 --> 00:02:05,590
searchable and then once you've got

00:02:03,219 --> 00:02:07,990
these two bits in place you use the

00:02:05,590 --> 00:02:11,230
query DSL to actually query the data

00:02:07,990 --> 00:02:13,540
that's in there the mapping and analysis

00:02:11,230 --> 00:02:17,170
parts are talks on their own right they

00:02:13,540 --> 00:02:19,120
are there can be very complex and but

00:02:17,170 --> 00:02:21,310
we're gonna start with some sort of very

00:02:19,120 --> 00:02:24,230
simple analysis and we're gonna focus on

00:02:21,310 --> 00:02:27,530
just the query DSL

00:02:24,230 --> 00:02:30,770
the query DSL it's how you query

00:02:27,530 --> 00:02:32,959
elasticsearch it's it's flexible it's

00:02:30,770 --> 00:02:36,349
powerful you can really express complex

00:02:32,959 --> 00:02:39,880
sets of logic and relevance calculations

00:02:36,349 --> 00:02:42,440
and but it's a bit of a black box people

00:02:39,880 --> 00:02:45,739
tend to copy and paste bits together

00:02:42,440 --> 00:02:48,080
throw it in into one big chunk of Jason

00:02:45,739 --> 00:02:50,150
and hope that it works not many people

00:02:48,080 --> 00:02:53,060
understand how it works and this is what

00:02:50,150 --> 00:02:55,250
the talk is about there are actually two

00:02:53,060 --> 00:02:57,880
types of clauses in the query DSL

00:02:55,250 --> 00:03:00,380
they're queries and they're filters and

00:02:57,880 --> 00:03:03,350
they're very similar but they differ in

00:03:00,380 --> 00:03:05,720
a few aspects the first is the answer

00:03:03,350 --> 00:03:07,340
that they provide so if it feels it just

00:03:05,720 --> 00:03:09,620
gives you a yes/no answer does this

00:03:07,340 --> 00:03:12,440
thing match or doesn't it is the price

00:03:09,620 --> 00:03:15,769
10 or isn't it is it the price between

00:03:12,440 --> 00:03:18,319
ten and a hundred or isn't it queries on

00:03:15,769 --> 00:03:21,019
the other hand look at relevance how

00:03:18,319 --> 00:03:23,060
relevant is this document for this query

00:03:21,019 --> 00:03:25,010
string all right it's a much more subtle

00:03:23,060 --> 00:03:28,790
on server it's going to give back to you

00:03:25,010 --> 00:03:31,280
it's not 1 or 0 it's base it makes you

00:03:28,790 --> 00:03:34,880
be any floating-point number in the

00:03:31,280 --> 00:03:37,970
positive range filters you tend to use

00:03:34,880 --> 00:03:39,560
for exact values so you know numbers

00:03:37,970 --> 00:03:42,320
dates and so on but for Strings

00:03:39,560 --> 00:03:44,420
where we're status equals active would

00:03:42,320 --> 00:03:47,180
be a typical example of where you use a

00:03:44,420 --> 00:03:50,329
filter while queries are ready for full

00:03:47,180 --> 00:03:52,489
text looking for the quick brown fox in

00:03:50,329 --> 00:03:56,810
the body of an email or something like

00:03:52,489 --> 00:04:00,140
that because of the simple nature of the

00:03:56,810 --> 00:04:01,940
result of a filter it's easy to cache so

00:04:00,140 --> 00:04:05,299
not only does it not have to calculate

00:04:01,940 --> 00:04:08,060
the relevant score it can be represented

00:04:05,299 --> 00:04:10,910
very in a very small amount of space

00:04:08,060 --> 00:04:13,040
so filters can be cached making them

00:04:10,910 --> 00:04:16,430
really fast queries on the other hand

00:04:13,040 --> 00:04:18,650
can't be cached and the result is that

00:04:16,430 --> 00:04:20,930
filters are typically faster and queries

00:04:18,650 --> 00:04:23,210
are slower so what you want to do is to

00:04:20,930 --> 00:04:24,950
filter out everything that you can at

00:04:23,210 --> 00:04:26,660
the beginning and then just run the

00:04:24,950 --> 00:04:32,150
queries on the documents that remain in

00:04:26,660 --> 00:04:34,070
your set the next bit we look at is some

00:04:32,150 --> 00:04:36,110
syntax because you need to plug these

00:04:34,070 --> 00:04:38,039
filters inquiries into something and

00:04:36,110 --> 00:04:41,599
we've got the Search API here

00:04:38,039 --> 00:04:44,939
and the API takes a query parameter so

00:04:41,599 --> 00:04:48,059
into this spot we can fill in any query

00:04:44,939 --> 00:04:51,479
for instance we can look for search in

00:04:48,059 --> 00:04:54,180
the title field and if you don't know

00:04:51,479 --> 00:04:56,039
this query match all just matches all

00:04:54,180 --> 00:04:57,689
documents equally and in fact if you

00:04:56,039 --> 00:05:00,629
don't specify a query that's why you're

00:04:57,689 --> 00:05:03,899
getting by default filters on the other

00:05:00,629 --> 00:05:06,809
hand can't be passed directly to this

00:05:03,899 --> 00:05:08,520
query they need to be you need to sort

00:05:06,809 --> 00:05:11,009
of switch into filter context and

00:05:08,520 --> 00:05:13,979
there's a special query exactly for that

00:05:11,009 --> 00:05:17,039
called the filtered query and it takes a

00:05:13,979 --> 00:05:20,339
query and filtered parameter so we can

00:05:17,039 --> 00:05:22,649
move our search in the title field

00:05:20,339 --> 00:05:25,050
clause into the query field and we can

00:05:22,649 --> 00:05:29,099
say we're going to filter on documents

00:05:25,050 --> 00:05:31,229
where the status field is active if you

00:05:29,099 --> 00:05:33,389
just want the filter well you could use

00:05:31,229 --> 00:05:35,729
a match old query there and in fact you

00:05:33,389 --> 00:05:37,709
could just leave it out altogether okay

00:05:35,729 --> 00:05:39,509
so this gives you the sort of structure

00:05:37,709 --> 00:05:42,899
for where to plug these queries and

00:05:39,509 --> 00:05:44,520
clauses and obviously this already takes

00:05:42,899 --> 00:05:45,659
up a fair bit of space on the screen so

00:05:44,520 --> 00:05:48,870
I'm not going to repeat this all the

00:05:45,659 --> 00:05:51,800
time and but what you wanting to do is

00:05:48,870 --> 00:05:55,769
either fill in Aquarion filter here or

00:05:51,800 --> 00:05:59,159
at the top level a query here you'll see

00:05:55,769 --> 00:06:02,370
this in action the next thing to think

00:05:59,159 --> 00:06:04,159
about is how your data is indexed so

00:06:02,370 --> 00:06:07,019
let's say we've got these two documents

00:06:04,159 --> 00:06:10,620
quick brown rabbits brown rabbits are

00:06:07,019 --> 00:06:12,360
commonly seen keeping pets healthy my

00:06:10,620 --> 00:06:16,769
quick brown fox eats rabbits on a

00:06:12,360 --> 00:06:19,379
regular basis now I'm sure we've all

00:06:16,769 --> 00:06:21,419
done this where we put this into an SQL

00:06:19,379 --> 00:06:23,099
database and run a query like this just

00:06:21,419 --> 00:06:26,159
give me everything you know wild card

00:06:23,099 --> 00:06:27,749
brown white cough Fox that's slow and

00:06:26,159 --> 00:06:30,449
inflexible it's really not going to give

00:06:27,749 --> 00:06:31,889
you decent results and instead what we

00:06:30,449 --> 00:06:33,539
want to do is to take these string

00:06:31,889 --> 00:06:35,399
values and pass them through some

00:06:33,539 --> 00:06:38,699
analysis process and like I said

00:06:35,399 --> 00:06:41,639
analysis can be quite complex but the

00:06:38,699 --> 00:06:43,499
basis is fairly simple essentially we

00:06:41,639 --> 00:06:45,930
want to take all of these words divide

00:06:43,499 --> 00:06:48,870
them up into separate words and then

00:06:45,930 --> 00:06:50,969
normalize those words normalization can

00:06:48,870 --> 00:06:51,360
mean lots of things but typically lower

00:06:50,969 --> 00:06:54,030
case

00:06:51,360 --> 00:06:55,949
thing is a good example of that so this

00:06:54,030 --> 00:06:57,860
just becomes a list of quick brown

00:06:55,949 --> 00:07:00,840
rabbits brown rabbits calmly scene and

00:06:57,860 --> 00:07:05,039
the cat of the capital letters have been

00:07:00,840 --> 00:07:07,590
lower kissed then we build a sorted list

00:07:05,039 --> 00:07:11,729
of unique terms that occur across across

00:07:07,590 --> 00:07:15,300
all of our documents and we mark where

00:07:11,729 --> 00:07:17,849
they occur all right so now if we want

00:07:15,300 --> 00:07:20,099
to do the query for brown fox all we

00:07:17,849 --> 00:07:22,379
have to do is look up brown in the terms

00:07:20,099 --> 00:07:24,569
of it in this sorted terms list Fox in

00:07:22,379 --> 00:07:26,610
the sorted terms list and we've got a

00:07:24,569 --> 00:07:31,020
result so there

00:07:26,610 --> 00:07:34,439
document 1 and document to document 1

00:07:31,020 --> 00:07:36,539
matches both terms sorry I can't read

00:07:34,439 --> 00:07:38,159
document 1 matches one term document 2

00:07:36,539 --> 00:07:40,469
matches both terms and we've got an

00:07:38,159 --> 00:07:42,990
answer and this structure is called an

00:07:40,469 --> 00:07:45,300
inverted index and it's not just for

00:07:42,990 --> 00:07:48,900
text it can equally be used for dates

00:07:45,300 --> 00:07:51,659
numbers boolean as geolocations geo

00:07:48,900 --> 00:07:54,500
shapes pretty much any data type of data

00:07:51,659 --> 00:07:58,199
can be represented in an inverted index

00:07:54,500 --> 00:08:00,029
so that's how it's stored and we're

00:07:58,199 --> 00:08:01,889
going to start now looking at the types

00:08:00,029 --> 00:08:03,569
of questions that you want to ask of

00:08:01,889 --> 00:08:05,460
your data and we'll start with the

00:08:03,569 --> 00:08:07,740
simple stuff the structured queries that

00:08:05,460 --> 00:08:12,960
you'll be used to from SQL things like

00:08:07,740 --> 00:08:16,589
where field equals value now looking at

00:08:12,960 --> 00:08:18,449
here you can see that the the content

00:08:16,589 --> 00:08:23,729
field in document 1 has actually got

00:08:18,449 --> 00:08:27,089
lots of values so where field is value

00:08:23,729 --> 00:08:31,080
actually is where field contains value

00:08:27,089 --> 00:08:33,329
all right and for that we use something

00:08:31,080 --> 00:08:35,969
called a term filter this is what it

00:08:33,329 --> 00:08:38,849
looks like if specify the type of filter

00:08:35,969 --> 00:08:42,269
the field and the exact value that we're

00:08:38,849 --> 00:08:45,630
looking for just to plug it in into the

00:08:42,269 --> 00:08:47,790
context we've got our search request the

00:08:45,630 --> 00:08:51,029
query parameter we need to use the

00:08:47,790 --> 00:08:53,820
filtered query we have to fit in the

00:08:51,029 --> 00:08:57,180
filter and a query we just want to

00:08:53,820 --> 00:09:00,360
filter so this is a match all and we

00:08:57,180 --> 00:09:02,250
plug our filter in here all right so I'm

00:09:00,360 --> 00:09:04,980
not gonna repeat the rest of this on

00:09:02,250 --> 00:09:06,160
later examples but you can see how to

00:09:04,980 --> 00:09:09,740
play

00:09:06,160 --> 00:09:11,630
how does this actually work well we go

00:09:09,740 --> 00:09:14,420
to the inverted index for the title

00:09:11,630 --> 00:09:18,110
field and we look up the value in this

00:09:14,420 --> 00:09:20,450
sorted list we find Brown that gives us

00:09:18,110 --> 00:09:24,160
document 1 was a yes result document 2

00:09:20,450 --> 00:09:27,650
with a no and we've got our answer so

00:09:24,160 --> 00:09:30,170
the this term filter ends up with a

00:09:27,650 --> 00:09:32,960
result that is represented as a bit set

00:09:30,170 --> 00:09:35,960
one bit for every document and that bit

00:09:32,960 --> 00:09:38,960
set looks like that document one has is

00:09:35,960 --> 00:09:41,150
true document two is false the nice

00:09:38,960 --> 00:09:43,220
thing about this is it's really small

00:09:41,150 --> 00:09:44,810
you can represent lots and lots of

00:09:43,220 --> 00:09:46,580
documents in a very small amount of

00:09:44,810 --> 00:09:49,160
space so we can cache it

00:09:46,580 --> 00:09:50,840
and here we cache it as title Brown and

00:09:49,160 --> 00:09:53,360
we've done the next time we run this

00:09:50,840 --> 00:09:55,910
filter it is going to reuse the cached

00:09:53,360 --> 00:09:57,380
value and these are smart caches you

00:09:55,910 --> 00:09:59,690
don't have to think about expiring then

00:09:57,380 --> 00:10:03,980
you don't as soon as you index something

00:09:59,690 --> 00:10:08,060
new there are the caches are updated and

00:10:03,980 --> 00:10:10,760
ok so then another common SQL form where

00:10:08,060 --> 00:10:12,830
filled in value and for that it's the

00:10:10,760 --> 00:10:14,960
terms filter which looks a lot like the

00:10:12,830 --> 00:10:19,160
term filter basically it takes an array

00:10:14,960 --> 00:10:21,280
instead of a single value and here we

00:10:19,160 --> 00:10:24,460
find pets and quick we've got one

00:10:21,280 --> 00:10:27,200
matching what one match in each document

00:10:24,460 --> 00:10:30,560
gives us a bit set of 1 comma 1 and

00:10:27,200 --> 00:10:33,080
again we can cache it so these are very

00:10:30,560 --> 00:10:34,820
simple tools but they form the building

00:10:33,080 --> 00:10:37,820
blocks of the more complicated things we

00:10:34,820 --> 00:10:41,480
come to later on similarly we've got

00:10:37,820 --> 00:10:44,720
ranges which uses the range filter you

00:10:41,480 --> 00:10:46,790
specify a range content and then the

00:10:44,720 --> 00:10:48,350
comparators so greater than greater than

00:10:46,790 --> 00:10:50,900
equal to less than less than equal to

00:10:48,350 --> 00:10:53,630
you make there can be unbounded so you

00:10:50,900 --> 00:10:56,720
can just leave out the less than or

00:10:53,630 --> 00:10:59,350
whatever it is you want to do and here

00:10:56,720 --> 00:11:02,330
we're looking for everything from A to M

00:10:59,350 --> 00:11:05,030
so the way this works as it goes to this

00:11:02,330 --> 00:11:06,740
terms list and it basically scans

00:11:05,030 --> 00:11:09,830
through the list looking for everything

00:11:06,740 --> 00:11:14,240
that fits into that range and counts up

00:11:09,830 --> 00:11:16,670
the matching docks over here again gives

00:11:14,240 --> 00:11:19,130
us a bit set which we can cache and this

00:11:16,670 --> 00:11:21,470
funny syntax here is a sort of loose

00:11:19,130 --> 00:11:25,040
in syntax we're a square bracket means

00:11:21,470 --> 00:11:29,450
inclusive and a curly brackets exclusive

00:11:25,040 --> 00:11:34,850
doesn't matter and we can run ranges on

00:11:29,450 --> 00:11:37,010
date fields as well the when you index

00:11:34,850 --> 00:11:38,750
in a numeric or date field it adds a

00:11:37,010 --> 00:11:41,030
bunch of extra terms to make range as

00:11:38,750 --> 00:11:43,640
much more efficient than they are in the

00:11:41,030 --> 00:11:46,310
sort of standard string case because

00:11:43,640 --> 00:11:51,050
this is usually where ranges are used on

00:11:46,310 --> 00:11:52,970
numbers and dates not on strings and you

00:11:51,050 --> 00:11:57,860
can even use date maths so we could say

00:11:52,970 --> 00:12:00,800
everything from now - one hour but now

00:11:57,860 --> 00:12:02,780
has a millisecond resolution okay so

00:12:00,800 --> 00:12:05,690
it's very unlikely we are ever going to

00:12:02,780 --> 00:12:07,850
reuse this clause again so using now

00:12:05,690 --> 00:12:10,970
like that means this filter is not going

00:12:07,850 --> 00:12:12,470
to be cached however we can round it off

00:12:10,970 --> 00:12:13,820
to the nearest hour in which case

00:12:12,470 --> 00:12:18,500
there's a good chance we will use it

00:12:13,820 --> 00:12:20,480
again and that it is cached some other

00:12:18,500 --> 00:12:23,410
structures where field is not now what

00:12:20,480 --> 00:12:27,800
really means where field has any term

00:12:23,410 --> 00:12:30,320
and that's the exists filter looks like

00:12:27,800 --> 00:12:34,850
that and the opposite where field has no

00:12:30,320 --> 00:12:37,010
term uses the missing filter those are

00:12:34,850 --> 00:12:38,720
kind of the individual parts now we want

00:12:37,010 --> 00:12:42,350
to combine them with boolean logic

00:12:38,720 --> 00:12:44,570
alright and for that we use the bull

00:12:42,350 --> 00:12:47,510
filter which looks like this

00:12:44,570 --> 00:12:50,360
you've got must should and must not each

00:12:47,510 --> 00:12:53,750
of these take a number of filters and

00:12:50,360 --> 00:12:58,610
the must basically maps to and should to

00:12:53,750 --> 00:13:01,940
or and must not to not so here we could

00:12:58,610 --> 00:13:04,970
say that our document must have rabbits

00:13:01,940 --> 00:13:07,280
in the title field should have either

00:13:04,970 --> 00:13:10,940
quick in the content or quick in the

00:13:07,280 --> 00:13:15,890
title field and must not have Fox in the

00:13:10,940 --> 00:13:19,790
content field now what if we wanted to

00:13:15,890 --> 00:13:22,120
say it must have quick and rabbits in

00:13:19,790 --> 00:13:24,620
the title field or the content field

00:13:22,120 --> 00:13:27,470
well the nice thing is that we can nest

00:13:24,620 --> 00:13:29,030
these bulls so when I said that must

00:13:27,470 --> 00:13:31,370
should and must not can take air any

00:13:29,030 --> 00:13:32,310
filters they can also take other bull

00:13:31,370 --> 00:13:34,350
filters

00:13:32,310 --> 00:13:39,209
so this is how you end up building a

00:13:34,350 --> 00:13:41,730
fairly complex sort of logic tree so we

00:13:39,209 --> 00:13:44,370
reorganize it and in the mass clause we

00:13:41,730 --> 00:13:46,499
have two bulls and here we've got should

00:13:44,370 --> 00:13:48,600
have rabbits in the title content field

00:13:46,499 --> 00:13:51,269
and should have Creek in the title

00:13:48,600 --> 00:13:54,899
content field okay so from here you can

00:13:51,269 --> 00:13:57,660
see how you can express exactly the

00:13:54,899 --> 00:14:01,589
logic that you need what's important to

00:13:57,660 --> 00:14:05,790
note about the bull filter is that this

00:14:01,589 --> 00:14:08,309
part is not cached these internal

00:14:05,790 --> 00:14:10,199
clauses are cached and of course each of

00:14:08,309 --> 00:14:13,259
these internal clauses just produces a

00:14:10,199 --> 00:14:15,839
bit set as a result so what the bull

00:14:13,259 --> 00:14:18,439
filter will do is combine the results of

00:14:15,839 --> 00:14:20,490
all of these using bit set logic and

00:14:18,439 --> 00:14:22,709
that's pretty much what it looks like

00:14:20,490 --> 00:14:26,160
the bit said from that clause all the

00:14:22,709 --> 00:14:30,300
bits set from that and that and not that

00:14:26,160 --> 00:14:32,279
so you don't have it you don't end up

00:14:30,300 --> 00:14:34,589
caching this whole complicated structure

00:14:32,279 --> 00:14:35,790
but each of these parts which are the

00:14:34,589 --> 00:14:37,110
more expensive parts because they

00:14:35,790 --> 00:14:39,870
actually have to go to disk and look

00:14:37,110 --> 00:14:43,050
things up are cached and can be reused

00:14:39,870 --> 00:14:47,279
wherever they appear in the query so

00:14:43,050 --> 00:14:52,500
title rabbits just because it happens to

00:14:47,279 --> 00:14:55,199
be so deep in this in the structure here

00:14:52,500 --> 00:14:56,610
it doesn't mean that it's limited to

00:14:55,199 --> 00:14:58,079
being used in that structure if it

00:14:56,610 --> 00:15:01,430
appears somewhere completely different

00:14:58,079 --> 00:15:01,430
it will still be reused

00:15:01,459 --> 00:15:07,920
so to recap boolean results yes or no it

00:15:05,850 --> 00:15:11,040
either matches or it doesn't use for

00:15:07,920 --> 00:15:13,709
exact values it's cashable faster than

00:15:11,040 --> 00:15:18,720
queries usually and you want to filter

00:15:13,709 --> 00:15:19,980
first and then query so now we move on

00:15:18,720 --> 00:15:22,290
to queries which are the more

00:15:19,980 --> 00:15:24,389
interesting thing and if somebody's

00:15:22,290 --> 00:15:26,730
coming from a relational database

00:15:24,389 --> 00:15:29,009
background it's it's the kind of magical

00:15:26,730 --> 00:15:32,459
part of how something like elasticsearch

00:15:29,009 --> 00:15:36,360
works the question is how relevant is

00:15:32,459 --> 00:15:38,069
the term that we're looking for and the

00:15:36,360 --> 00:15:40,379
building block for Jones for this

00:15:38,069 --> 00:15:43,110
question is the term query which is

00:15:40,379 --> 00:15:44,649
pretty much like the term filter plus

00:15:43,110 --> 00:15:47,259
relevance

00:15:44,649 --> 00:15:50,290
now you actually probably won't use the

00:15:47,259 --> 00:15:52,540
term query very often yourself it's it's

00:15:50,290 --> 00:15:54,430
a bit of a sort of low-level query yeah

00:15:52,540 --> 00:15:55,990
we'll come to the match query later on

00:15:54,430 --> 00:15:58,420
which is the query that you will use a

00:15:55,990 --> 00:15:59,860
lot but understanding how this works

00:15:58,420 --> 00:16:02,649
will help you to understand how the

00:15:59,860 --> 00:16:06,550
match query works so it looks just like

00:16:02,649 --> 00:16:08,589
the turn filter term title Brown and

00:16:06,550 --> 00:16:10,209
here we plug it in of course it's a

00:16:08,589 --> 00:16:15,069
query not a filter so we plug in it in

00:16:10,209 --> 00:16:17,230
at the query level and and when we get

00:16:15,069 --> 00:16:18,459
our results back we have this score as

00:16:17,230 --> 00:16:21,220
part of it

00:16:18,459 --> 00:16:23,189
the score represents how relevant this

00:16:21,220 --> 00:16:25,899
document is and and

00:16:23,189 --> 00:16:28,749
the absolute value is not important what

00:16:25,899 --> 00:16:31,869
is important is the relative value

00:16:28,749 --> 00:16:33,879
between two documents so your results

00:16:31,869 --> 00:16:36,009
are being sorted by relevance so they're

00:16:33,879 --> 00:16:37,329
being sorted by score the documents near

00:16:36,009 --> 00:16:39,040
the top have got a higher score the

00:16:37,329 --> 00:16:43,629
documents in the bottom have got a lower

00:16:39,040 --> 00:16:45,220
score so we need to understand where

00:16:43,629 --> 00:16:46,869
this relevant score comes from and

00:16:45,220 --> 00:16:49,420
really the three factors that are

00:16:46,869 --> 00:16:52,870
important how common is the word we're

00:16:49,420 --> 00:16:54,879
looking for in this document more common

00:16:52,870 --> 00:16:57,309
it is the more often that word appears

00:16:54,879 --> 00:16:59,410
within the document the more important

00:16:57,309 --> 00:17:01,360
it's going to be but then you also have

00:16:59,410 --> 00:17:06,699
to look at how common the word is in the

00:17:01,360 --> 00:17:10,120
whole index so words like that and must

00:17:06,699 --> 00:17:14,289
are very common and so they have little

00:17:10,120 --> 00:17:16,299
importance if you had obsequious Ness

00:17:14,289 --> 00:17:18,490
that's going to appear very seldom and

00:17:16,299 --> 00:17:21,579
is so is going to be a really important

00:17:18,490 --> 00:17:24,880
term to look for and then finally we've

00:17:21,579 --> 00:17:27,699
got the question of how long the

00:17:24,880 --> 00:17:30,789
document is we're actually talking about

00:17:27,699 --> 00:17:32,710
fields rather than documents okay but so

00:17:30,789 --> 00:17:35,770
how long is this field if you've got a

00:17:32,710 --> 00:17:37,870
title field that's a short thing and if

00:17:35,770 --> 00:17:39,850
a word appears in that short title field

00:17:37,870 --> 00:17:41,799
it's likely to be more important than if

00:17:39,850 --> 00:17:45,370
the same word appears in the long body

00:17:41,799 --> 00:17:49,419
of an email and the official word or

00:17:45,370 --> 00:17:52,360
terms for these factors as known in the

00:17:49,419 --> 00:17:55,950
Lucene similarity algorithm is term

00:17:52,360 --> 00:17:58,980
frequency inverse document frequency and

00:17:55,950 --> 00:18:01,289
the field length norm

00:17:58,980 --> 00:18:04,649
and you'll hear these mentioned a lot in

00:18:01,289 --> 00:18:08,580
elasticsearch and leucine and and that's

00:18:04,649 --> 00:18:11,220
basically it the term query looks at the

00:18:08,580 --> 00:18:13,470
term finds the matching documents and

00:18:11,220 --> 00:18:16,950
then calculates the relevant score using

00:18:13,470 --> 00:18:18,870
the algorithm that we've explained so

00:18:16,950 --> 00:18:22,230
now let's look at how you combine these

00:18:18,870 --> 00:18:25,019
to add some logic to it we've got the

00:18:22,230 --> 00:18:29,100
bull query which looks a lot like the

00:18:25,019 --> 00:18:31,860
bull filter but is different master must

00:18:29,100 --> 00:18:34,049
not are pretty much the same but should

00:18:31,860 --> 00:18:35,639
is not quite the same and you've got

00:18:34,049 --> 00:18:39,179
this extra parameter called minimum

00:18:35,639 --> 00:18:40,830
should match which is can be a bit

00:18:39,179 --> 00:18:45,450
tricky to understand and it's probably

00:18:40,830 --> 00:18:47,700
easier by example if you have no must

00:18:45,450 --> 00:18:51,330
queries so we're saying it should match

00:18:47,700 --> 00:18:53,850
either quick or brown or rabbits in this

00:18:51,330 --> 00:18:55,799
case at least one of these values has to

00:18:53,850 --> 00:18:58,379
match for a document to be considered a

00:18:55,799 --> 00:19:01,139
match in other words the minimum should

00:18:58,379 --> 00:19:01,610
match parameter defaults to 1 in this

00:19:01,139 --> 00:19:07,610
case

00:19:01,610 --> 00:19:10,710
however if you have a must clause then

00:19:07,610 --> 00:19:13,830
these should clauses are optional none

00:19:10,710 --> 00:19:17,309
of them have to match and so minimum

00:19:13,830 --> 00:19:19,230
should match a zero so if none of these

00:19:17,309 --> 00:19:22,019
clauses have to match what's the point

00:19:19,230 --> 00:19:24,090
of having them well the answer lies in

00:19:22,019 --> 00:19:27,090
the results you get from these things

00:19:24,090 --> 00:19:28,740
the bull filter just says yes or no so

00:19:27,090 --> 00:19:31,559
it makes sense for the should clauses to

00:19:28,740 --> 00:19:34,529
always count but the bull query gives

00:19:31,559 --> 00:19:37,320
you a score and as we said that score is

00:19:34,529 --> 00:19:38,850
much more subtle so it's not just a

00:19:37,320 --> 00:19:42,000
question of whether it matched it's a

00:19:38,850 --> 00:19:45,000
question of how well it matched the

00:19:42,000 --> 00:19:48,740
score from a bull query is calculated by

00:19:45,000 --> 00:19:51,470
taking the score of every matching query

00:19:48,740 --> 00:19:55,100
times the number of matching queries

00:19:51,470 --> 00:19:58,950
divided by the number of queries so

00:19:55,100 --> 00:20:01,860
these should clauses count all right

00:19:58,950 --> 00:20:04,080
they the more matching should clauses

00:20:01,860 --> 00:20:06,059
you have the higher the relevance of

00:20:04,080 --> 00:20:07,799
that document so while they're not

00:20:06,059 --> 00:20:10,529
required to match they are very useful

00:20:07,799 --> 00:20:12,730
to push the more relevant documents up

00:20:10,529 --> 00:20:16,570
to the top of the list

00:20:12,730 --> 00:20:19,580
they give you a better relevant score

00:20:16,570 --> 00:20:21,970
the minimum should match parameter can

00:20:19,580 --> 00:20:25,580
also be used to trim the long tail of

00:20:21,970 --> 00:20:27,980
low-quality results so this will match

00:20:25,580 --> 00:20:29,960
at quick or brown or rabbits in the

00:20:27,980 --> 00:20:34,970
title field but it's going to match

00:20:29,960 --> 00:20:36,980
brown hag handbags quick wins which

00:20:34,970 --> 00:20:39,350
documents which are really pretty

00:20:36,980 --> 00:20:42,230
irrelevant to the users search if they

00:20:39,350 --> 00:20:45,140
have looked for quick brown rabbits so

00:20:42,230 --> 00:20:50,000
we could say we want all of the values

00:20:45,140 --> 00:20:51,800
to match or we could say we want 75% of

00:20:50,000 --> 00:20:55,930
the words of the the user searched on to

00:20:51,800 --> 00:20:58,130
match of course 75% of three terms

00:20:55,930 --> 00:21:00,320
doesn't really work out but the book

00:20:58,130 --> 00:21:02,840
query is smart enough to round things

00:21:00,320 --> 00:21:04,820
down so it really this means two out of

00:21:02,840 --> 00:21:06,710
these three values must match for a

00:21:04,820 --> 00:21:09,050
document to be considered a match and so

00:21:06,710 --> 00:21:13,790
you you trim out the all those documents

00:21:09,050 --> 00:21:15,980
that only match one term here now we

00:21:13,790 --> 00:21:18,110
move on to the query that you are going

00:21:15,980 --> 00:21:20,810
to use a lot and that is the match query

00:21:18,110 --> 00:21:23,840
and the match query is a high level

00:21:20,810 --> 00:21:28,010
query that understands the field mapping

00:21:23,840 --> 00:21:31,940
and the analysis chain okay we'll

00:21:28,010 --> 00:21:33,920
explain how this works so the match

00:21:31,940 --> 00:21:36,740
query first is going to take the query

00:21:33,920 --> 00:21:38,420
string the user passes in pass it

00:21:36,740 --> 00:21:40,580
through an analyzer like we did when we

00:21:38,420 --> 00:21:42,110
index the document and then it's going

00:21:40,580 --> 00:21:44,180
to rewrite the query into the sort of

00:21:42,110 --> 00:21:46,790
low-level queries that are actually

00:21:44,180 --> 00:21:51,470
going to execute it so if we start with

00:21:46,790 --> 00:21:53,300
the one word query match title quick if

00:21:51,470 --> 00:21:55,130
we'd use the term clause here this

00:21:53,300 --> 00:21:57,500
wouldn't have found anything because the

00:21:55,130 --> 00:21:59,360
exact value quicken capsules with an

00:21:57,500 --> 00:22:02,840
exclamation mark doesn't exist in the

00:21:59,360 --> 00:22:05,180
inverted index but if we analyze that

00:22:02,840 --> 00:22:07,510
value we end up with a single term quick

00:22:05,180 --> 00:22:10,340
and that does exist in the index so now

00:22:07,510 --> 00:22:12,230
this match query gets rewritten as a

00:22:10,340 --> 00:22:14,840
single term query and you know how that

00:22:12,230 --> 00:22:19,730
works already looks up calculates the

00:22:14,840 --> 00:22:21,740
relevant score multi-word queries do a

00:22:19,730 --> 00:22:24,350
similar sort of thing so we start off

00:22:21,740 --> 00:22:25,280
with quick fox analyzed that and it

00:22:24,350 --> 00:22:27,830
gives us two two

00:22:25,280 --> 00:22:31,100
queries quick in the title field Vox in

00:22:27,830 --> 00:22:33,440
the title field and then we need to

00:22:31,100 --> 00:22:36,800
combine these schools so just wraps them

00:22:33,440 --> 00:22:39,440
in a boolean and it'll add these two

00:22:36,800 --> 00:22:40,850
schools together and the documents that

00:22:39,440 --> 00:22:42,440
I've got both of them will appear higher

00:22:40,850 --> 00:22:45,260
up the list documents with one lower

00:22:42,440 --> 00:22:48,440
down the list so it's very simple how it

00:22:45,260 --> 00:22:51,670
gets rewritten and perhaps you want to

00:22:48,440 --> 00:22:55,250
say that all of the words must match

00:22:51,670 --> 00:22:58,160
here our title Creek Fox needs to change

00:22:55,250 --> 00:23:02,270
a bit is to take an extra parameter and

00:22:58,160 --> 00:23:05,020
we add operator and and all that does is

00:23:02,270 --> 00:23:08,330
change they should in this bull query

00:23:05,020 --> 00:23:11,000
into the must that's the only effect it

00:23:08,330 --> 00:23:12,440
has similarly if we want to trim the

00:23:11,000 --> 00:23:15,950
long tail we can specify a minimum

00:23:12,440 --> 00:23:17,480
should match and we're it still assured

00:23:15,950 --> 00:23:20,270
it but now the minimum should match

00:23:17,480 --> 00:23:22,160
parameters filled in there so it with

00:23:20,270 --> 00:23:24,320
that you can understand why you get the

00:23:22,160 --> 00:23:27,530
results you do the match query is no

00:23:24,320 --> 00:23:28,910
longer just this magic box it does a

00:23:27,530 --> 00:23:31,340
bunch of other stuff as well for

00:23:28,910 --> 00:23:34,520
instance it'll handle fuzzy queries for

00:23:31,340 --> 00:23:38,570
you the fuzzy queries use the Levenstein

00:23:34,520 --> 00:23:40,730
at a distance what that means is how

00:23:38,570 --> 00:23:43,100
many changes do you need to make to one

00:23:40,730 --> 00:23:45,410
word to convert it into another so for

00:23:43,100 --> 00:23:49,520
instance here we can insert a letter to

00:23:45,410 --> 00:23:53,510
make brown brown we could change delete

00:23:49,520 --> 00:23:56,300
a letter foxes to fox we can substitute

00:23:53,510 --> 00:23:57,920
one letter for another and we can

00:23:56,300 --> 00:24:00,710
transpose to you letters switch them

00:23:57,920 --> 00:24:03,140
switch their order each one of these

00:24:00,710 --> 00:24:05,420
steps is an edit distance of one and in

00:24:03,140 --> 00:24:08,720
this case we've got an edit distance of

00:24:05,420 --> 00:24:09,920
two an edit distance of two happens to

00:24:08,720 --> 00:24:12,500
be the maximum that

00:24:09,920 --> 00:24:14,750
Lusine allows but you can see how many

00:24:12,500 --> 00:24:16,940
changes you can make to a word with just

00:24:14,750 --> 00:24:22,100
a distance of two it can match something

00:24:16,940 --> 00:24:24,080
that is quite far from the original if

00:24:22,100 --> 00:24:26,090
we were to specify an edit distance of

00:24:24,080 --> 00:24:29,540
two was something like bran a short word

00:24:26,090 --> 00:24:30,980
like that we could change it into some

00:24:29,540 --> 00:24:32,720
completely different word with

00:24:30,980 --> 00:24:35,240
absolutely no relation to the original

00:24:32,720 --> 00:24:38,720
so rather than having to specify one or

00:24:35,240 --> 00:24:41,599
two we can use the author parameter in a

00:24:38,720 --> 00:24:43,369
and it'll calculate the appropriate edit

00:24:41,599 --> 00:24:46,039
distance based upon the length of the of

00:24:43,369 --> 00:24:49,729
the word to up to a maximum of two so

00:24:46,039 --> 00:24:54,320
quick Ron Fox will match the data in a

00:24:49,729 --> 00:24:57,470
in our index we can also use phrase of

00:24:54,320 --> 00:24:59,179
proximity queries where we're saying not

00:24:57,470 --> 00:25:01,249
only want to match all of these words I

00:24:59,179 --> 00:25:03,259
want to match them in this order all

00:25:01,249 --> 00:25:06,830
right so no words in between anything

00:25:03,259 --> 00:25:09,619
like that so here we can use the match

00:25:06,830 --> 00:25:12,739
phrase query or it also works as the

00:25:09,619 --> 00:25:15,440
match query type phrase quick brown fox

00:25:12,739 --> 00:25:19,669
in that order exists in our index and so

00:25:15,440 --> 00:25:22,460
it's going to match if we want to be

00:25:19,669 --> 00:25:24,679
less concerned about order or perhaps

00:25:22,460 --> 00:25:27,229
allow a few words to appear in between

00:25:24,679 --> 00:25:29,210
you can specify a slot parameter which

00:25:27,229 --> 00:25:31,099
gives it's bit like an edit distance for

00:25:29,210 --> 00:25:35,840
position it allows things to be a little

00:25:31,099 --> 00:25:38,599
more flexible and of course you can take

00:25:35,840 --> 00:25:42,519
these the standard match query fuzzy and

00:25:38,599 --> 00:25:46,399
phrase query and combine them together

00:25:42,519 --> 00:25:49,729
so we're going to require that at least

00:25:46,399 --> 00:25:53,989
75% of the words the user actually typed

00:25:49,729 --> 00:25:56,629
in are in our index by using a minimum

00:25:53,989 --> 00:25:58,129
should match clause here and that just

00:25:56,629 --> 00:26:00,320
looks like what we had before

00:25:58,129 --> 00:26:04,820
it's a query with the words we're after

00:26:00,320 --> 00:26:06,889
and minimum should match 75% then we

00:26:04,820 --> 00:26:08,599
want to expand the range a bit and

00:26:06,889 --> 00:26:10,639
perhaps match them on words that are

00:26:08,599 --> 00:26:14,149
misspelled so in one of the should

00:26:10,639 --> 00:26:20,119
clauses will use fuzzy matching and with

00:26:14,149 --> 00:26:23,479
fuzzy Auto and then if the they have ten

00:26:20,119 --> 00:26:25,460
minutes that's possible if if they have

00:26:23,479 --> 00:26:27,409
the exact phrase that the user typed in

00:26:25,460 --> 00:26:29,899
then we want to boost those up to the

00:26:27,409 --> 00:26:33,379
top so we can add a proximity clause in

00:26:29,899 --> 00:26:35,359
here and anything that matches that this

00:26:33,379 --> 00:26:38,149
query is going to be bumped up to the

00:26:35,359 --> 00:26:42,289
top and that's a reasonable way of

00:26:38,149 --> 00:26:45,309
combining queries now we come to the

00:26:42,289 --> 00:26:48,109
hard bit and that's multi field queries

00:26:45,309 --> 00:26:51,169
and you often see things like this on on

00:26:48,109 --> 00:26:52,640
websites called advanced search and

00:26:51,169 --> 00:26:55,580
actually this is really

00:26:52,640 --> 00:26:57,650
easy to do because the users telling you

00:26:55,580 --> 00:27:01,940
what feels the state has in so you can

00:26:57,650 --> 00:27:06,770
just use a simple bull query here this

00:27:01,940 --> 00:27:08,720
is not so easy you the user expects you

00:27:06,770 --> 00:27:13,280
to figure out what fields this data is

00:27:08,720 --> 00:27:16,100
in and we could start off by say using a

00:27:13,280 --> 00:27:19,760
boolean here quick brown fox on the

00:27:16,100 --> 00:27:24,740
title and content fields and but

00:27:19,760 --> 00:27:26,000
actually this quick brown fox in in the

00:27:24,740 --> 00:27:30,110
second document which is the better

00:27:26,000 --> 00:27:33,800
match is being beaten because both

00:27:30,110 --> 00:27:36,050
fields here match brown alright so two

00:27:33,800 --> 00:27:39,410
matches are better than one and we're

00:27:36,050 --> 00:27:40,640
getting results in the wrong order the

00:27:39,410 --> 00:27:42,800
bull query is not the only way to

00:27:40,640 --> 00:27:45,770
combine queries we've also got the disc

00:27:42,800 --> 00:27:48,080
max query and the logic is slightly

00:27:45,770 --> 00:27:50,960
different it takes all of the documents

00:27:48,080 --> 00:27:54,440
which match any query and then uses the

00:27:50,960 --> 00:27:58,400
best matching query to prove you produce

00:27:54,440 --> 00:28:03,470
the score so now if we change this to a

00:27:58,400 --> 00:28:05,360
dis max query the quick brown fox is the

00:28:03,470 --> 00:28:09,440
best matching clause and so this

00:28:05,360 --> 00:28:11,180
document moves up to the top there's

00:28:09,440 --> 00:28:15,020
another parameter that this Mac takes

00:28:11,180 --> 00:28:18,080
called the tiebreaker and we matched

00:28:15,020 --> 00:28:19,640
Brown here but currently we're

00:28:18,080 --> 00:28:21,640
discounting it completely because we're

00:28:19,640 --> 00:28:24,470
just looking for the best matching field

00:28:21,640 --> 00:28:26,570
but by specifying its high breaker we

00:28:24,470 --> 00:28:28,700
can still take these secondary matches

00:28:26,570 --> 00:28:31,430
into account and all it does is takes

00:28:28,700 --> 00:28:33,890
the best matching query and adds on the

00:28:31,430 --> 00:28:38,600
tiebreaker times the scores from the

00:28:33,890 --> 00:28:41,030
lesser matching queries we have a melty

00:28:38,600 --> 00:28:43,730
match query which is like the match

00:28:41,030 --> 00:28:45,500
query on multiple fields and it helps to

00:28:43,730 --> 00:28:49,550
reduce the amount of writing you have to

00:28:45,500 --> 00:28:51,460
do so here's our dis max query and it

00:28:49,550 --> 00:28:54,710
can be re-written as a multi match query

00:28:51,460 --> 00:28:56,810
like this we specify the query the

00:28:54,710 --> 00:28:59,000
fields to run on and if you like the

00:28:56,810 --> 00:29:02,360
tiebreaker and they're actually three

00:28:59,000 --> 00:29:05,630
main types of multi match query this

00:29:02,360 --> 00:29:06,290
type the default is called best fields

00:29:05,630 --> 00:29:08,690
so

00:29:06,290 --> 00:29:12,590
on the best fields out there and give me

00:29:08,690 --> 00:29:15,170
the score from that and so the best

00:29:12,590 --> 00:29:18,140
fields type is best when you're looking

00:29:15,170 --> 00:29:19,820
for a whole concept in a single field

00:29:18,140 --> 00:29:21,650
and you don't know what field that is in

00:29:19,820 --> 00:29:24,200
so we're looking for quick quick brown

00:29:21,650 --> 00:29:26,360
fox those words together in a single

00:29:24,200 --> 00:29:28,630
field make more sense than those same

00:29:26,360 --> 00:29:31,940
words scattered across several fields

00:29:28,630 --> 00:29:36,980
and and like we said it gets rewritten

00:29:31,940 --> 00:29:38,900
as a dis max query but quite often we

00:29:36,980 --> 00:29:41,210
have a single title fee or something

00:29:38,900 --> 00:29:42,980
like a title field which we want to

00:29:41,210 --> 00:29:46,090
analyze in different ways for different

00:29:42,980 --> 00:29:49,040
purposes and we can do this using

00:29:46,090 --> 00:29:50,990
subfields here so perhaps we want to

00:29:49,040 --> 00:29:53,000
stem it reduce all of the words to their

00:29:50,990 --> 00:29:55,700
root forms so that instead of matching

00:29:53,000 --> 00:29:59,540
just jumps we can match jumps jumped

00:29:55,700 --> 00:30:01,910
jumping jump and and perhaps we want to

00:29:59,540 --> 00:30:03,890
run it through edge engrams to use it

00:30:01,910 --> 00:30:07,450
for autocomplete as well so search is

00:30:03,890 --> 00:30:09,770
the type we can match on that just to

00:30:07,450 --> 00:30:13,010
give you an example of what these

00:30:09,770 --> 00:30:14,660
analyzers produce the title field using

00:30:13,010 --> 00:30:16,760
the standard analyzer pretty much just

00:30:14,660 --> 00:30:20,090
breaks things up by words removes

00:30:16,760 --> 00:30:23,240
punctuation title drops dimmed changes

00:30:20,090 --> 00:30:25,420
jumped there to jump and be also

00:30:23,240 --> 00:30:27,620
complete with edged engrams

00:30:25,420 --> 00:30:30,110
basically gives you all the parts of the

00:30:27,620 --> 00:30:33,080
words anchored to the beginning so you

00:30:30,110 --> 00:30:36,230
can see how if somebody types brown fox

00:30:33,080 --> 00:30:39,860
J we can match from brown muck natural

00:30:36,230 --> 00:30:43,420
fox and match and yeah and it's a likely

00:30:39,860 --> 00:30:47,350
to be a good result to actually use that

00:30:43,420 --> 00:30:50,330
query we specified the fields in the

00:30:47,350 --> 00:30:53,390
multi match query but in here we use

00:30:50,330 --> 00:30:55,820
type most fields so we've got the same

00:30:53,390 --> 00:30:58,160
text in every field just analyzed in

00:30:55,820 --> 00:31:00,890
different ways so the more matching

00:30:58,160 --> 00:31:01,220
fields the more fields that match the

00:31:00,890 --> 00:31:08,680
better

00:31:01,220 --> 00:31:12,160
oh the slide agrees with me

00:31:08,680 --> 00:31:14,350
and and so instead of using a dis max

00:31:12,160 --> 00:31:17,290
here it gets wrapped up in the bull

00:31:14,350 --> 00:31:21,280
query that we saw initially there's one

00:31:17,290 --> 00:31:23,980
last case which is when your data is

00:31:21,280 --> 00:31:26,020
scattered across several fields and more

00:31:23,980 --> 00:31:30,520
than one field needs to match in order

00:31:26,020 --> 00:31:31,900
for a match to be valid and so here we

00:31:30,520 --> 00:31:35,980
got first named Reginald middle name

00:31:31,900 --> 00:31:37,960
Kenneth last name Dwight and the

00:31:35,980 --> 00:31:39,340
temptation here is to think well we want

00:31:37,960 --> 00:31:43,420
to match on all of these fields and

00:31:39,340 --> 00:31:46,090
count all of those matches so perhaps we

00:31:43,420 --> 00:31:49,720
should use the most fields match but

00:31:46,090 --> 00:31:52,060
this is wrong and I explain why the

00:31:49,720 --> 00:31:54,070
problem is that at most fields and best

00:31:52,060 --> 00:31:56,880
fields and for that matter our birth

00:31:54,070 --> 00:31:59,680
field centric so the most fields query

00:31:56,880 --> 00:32:04,270
gets rewritten into something like this

00:31:59,680 --> 00:32:05,350
and it'll match anything that's got

00:32:04,270 --> 00:32:07,090
first name Reginald

00:32:05,350 --> 00:32:09,400
middle name Reginald and last name

00:32:07,090 --> 00:32:12,870
Reginald as a good match so it's

00:32:09,400 --> 00:32:16,030
completely ignored two of our terms and

00:32:12,870 --> 00:32:18,400
next problem is that we can't apply

00:32:16,030 --> 00:32:21,070
something like operator and or minimum

00:32:18,400 --> 00:32:23,080
should match if we apply the and

00:32:21,070 --> 00:32:27,760
operator it applies just to their field

00:32:23,080 --> 00:32:30,400
so it would only define documents that

00:32:27,760 --> 00:32:32,740
had Reginald Kenneth and Weiss in the

00:32:30,400 --> 00:32:34,600
first name field all the middle all the

00:32:32,740 --> 00:32:38,290
last name field that's not gonna happen

00:32:34,600 --> 00:32:41,500
doesn't work next problem is term

00:32:38,290 --> 00:32:45,220
frequencies first name as Dwight is

00:32:41,500 --> 00:32:47,470
common dwight di eisenhower last name

00:32:45,220 --> 00:32:50,500
Dwight is uncommon and what do we know

00:32:47,470 --> 00:32:55,060
about uncommon words they have more

00:32:50,500 --> 00:32:58,030
weight so an uncommon last name may have

00:32:55,060 --> 00:33:00,120
more value than the common first name

00:32:58,030 --> 00:33:02,980
that the user is actually searching for

00:33:00,120 --> 00:33:05,610
we have two solutions available to us

00:33:02,980 --> 00:33:08,260
the first is an index time solution and

00:33:05,610 --> 00:33:10,930
that's basically to index everything

00:33:08,260 --> 00:33:13,360
into a single full name field we can

00:33:10,930 --> 00:33:14,830
still keep them separate but we can

00:33:13,360 --> 00:33:15,220
index them into the full name field as

00:33:14,830 --> 00:33:16,990
well

00:33:15,220 --> 00:33:19,510
so we've got the first middle and last

00:33:16,990 --> 00:33:22,269
names here we're going to add a full

00:33:19,510 --> 00:33:24,879
name field and

00:33:22,269 --> 00:33:26,799
P these values when we index from first

00:33:24,879 --> 00:33:27,629
middle and last into the full name field

00:33:26,799 --> 00:33:30,330
as well

00:33:27,629 --> 00:33:33,549
this becomes simple it's just a single

00:33:30,330 --> 00:33:35,919
field query so we've got all of the

00:33:33,549 --> 00:33:38,669
power of the minimum should match I'm

00:33:35,919 --> 00:33:40,749
sorry of the match query ax our disposal

00:33:38,669 --> 00:33:42,909
of course we don't always think about

00:33:40,749 --> 00:33:46,509
these things before we index so we have

00:33:42,909 --> 00:33:51,009
a query time solution as well and it's a

00:33:46,509 --> 00:33:54,339
term centric query so instead of looking

00:33:51,009 --> 00:33:57,459
at fields first we change it around and

00:33:54,339 --> 00:33:59,289
we consider each term individually so we

00:33:57,459 --> 00:34:01,779
want to find Reginald in the first

00:33:59,289 --> 00:34:03,519
middle last fields Kenneth in the first

00:34:01,779 --> 00:34:07,719
middle last and Dwight in the first

00:34:03,519 --> 00:34:10,510
middle and last that solves the problem

00:34:07,719 --> 00:34:12,190
of NIM should match and making sure you

00:34:10,510 --> 00:34:13,899
hit as many of different terms as

00:34:12,190 --> 00:34:17,139
possible but it still doesn't solve the

00:34:13,899 --> 00:34:19,029
term frequencies problem because first

00:34:17,139 --> 00:34:21,730
name Dwight is going to score a lot less

00:34:19,029 --> 00:34:25,119
than last name Dwight and two versions

00:34:21,730 --> 00:34:28,149
ago in elasticsearch we released a new

00:34:25,119 --> 00:34:32,049
type of multi match query and it uses

00:34:28,149 --> 00:34:33,669
blending so what it does is look up it

00:34:32,049 --> 00:34:36,960
looks up Reginald in the first middle

00:34:33,669 --> 00:34:40,869
and last fields and calculates a blended

00:34:36,960 --> 00:34:43,000
frequency score for those fields and

00:34:40,869 --> 00:34:45,909
this makes our matching much more

00:34:43,000 --> 00:34:49,419
accurate and this type is called cross

00:34:45,909 --> 00:34:53,099
fields so it's used to query multiple

00:34:49,419 --> 00:34:55,899
fields as if they were one single field

00:34:53,099 --> 00:34:58,390
and everything looks the same as it did

00:34:55,899 --> 00:35:00,670
before except we specify cross fields

00:34:58,390 --> 00:35:05,140
here we can use minimum should match

00:35:00,670 --> 00:35:06,730
quite happily and the the only thing

00:35:05,140 --> 00:35:08,829
that you have to be aware of here is

00:35:06,730 --> 00:35:11,349
that the first middle and last names

00:35:08,829 --> 00:35:13,809
must use the same analyzer

00:35:11,349 --> 00:35:15,970
you can't come have different analysis

00:35:13,809 --> 00:35:17,859
processes in these fields they have to

00:35:15,970 --> 00:35:18,490
produce a single analyzer for this to

00:35:17,859 --> 00:35:23,289
work well

00:35:18,490 --> 00:35:27,039
so to recap best fields when you have a

00:35:23,289 --> 00:35:29,140
whole concept in one field most fields

00:35:27,039 --> 00:35:31,390
same text in several fields with

00:35:29,140 --> 00:35:33,039
different analysis chains and cross

00:35:31,390 --> 00:35:35,740
fields when you're trying to treat

00:35:33,039 --> 00:35:38,050
multiple fields as a single

00:35:35,740 --> 00:35:40,450
field if you can understand these

00:35:38,050 --> 00:35:43,450
building blocks even though the many

00:35:40,450 --> 00:35:46,450
more queries out there the rest is just

00:35:43,450 --> 00:35:48,640
details this gives you a solid

00:35:46,450 --> 00:35:51,820
foundation to understanding how to use

00:35:48,640 --> 00:35:55,830
the the other things out there thank you

00:35:51,820 --> 00:35:55,830
very much and thank you to elasticsearch

00:35:57,450 --> 00:36:00,990
we have time for questions

00:36:03,240 --> 00:36:07,410
one minute make it fast

00:36:11,680 --> 00:36:16,869
those elastic serves have some kind of

00:36:13,720 --> 00:36:19,480
built-in capability to provide it with

00:36:16,869 --> 00:36:21,310
multiple queries and then do a full back

00:36:19,480 --> 00:36:23,800
if the first one doesn't match then use

00:36:21,310 --> 00:36:27,369
the second one no it doesn't it doesn't

00:36:23,800 --> 00:36:30,640
have that kind of fall back and but what

00:36:27,369 --> 00:36:33,070
if you combine several queries say in a

00:36:30,640 --> 00:36:35,619
boolean should in should clauses then

00:36:33,070 --> 00:36:37,570
the ones that match best are going to be

00:36:35,619 --> 00:36:40,119
pushed to the top if nothing matches the

00:36:37,570 --> 00:36:43,240
best Clause then you're still going to

00:36:40,119 --> 00:36:45,580
have these low quality clauses available

00:36:43,240 --> 00:36:46,840
and so those documents will rise to the

00:36:45,580 --> 00:36:49,150
top because there's nothing about them

00:36:46,840 --> 00:36:51,700
yeah exactly is the idea being for

00:36:49,150 --> 00:36:55,390
example in in product search in product

00:36:51,700 --> 00:36:57,160
search very often you want to if you

00:36:55,390 --> 00:37:00,720
have a number of high precision matches

00:36:57,160 --> 00:37:03,609
you want to show those and nothing else

00:37:00,720 --> 00:37:05,650
you could you'd have to run those four

00:37:03,609 --> 00:37:10,980
queries yeah which you could do at the

00:37:05,650 --> 00:37:10,980
same time using lot n search thank you

00:37:12,180 --> 00:37:17,109
so the question is what other types of

00:37:14,440 --> 00:37:23,200
analyzers do you have the answer is a

00:37:17,109 --> 00:37:24,970
lot yes Germans they're they're about 20

00:37:23,200 --> 00:37:27,040
something languages supported out the

00:37:24,970 --> 00:37:31,930
box there are the plugins that support

00:37:27,040 --> 00:37:35,560
other languages the you know Unicode

00:37:31,930 --> 00:37:38,530
supporting things there's engrams edging

00:37:35,560 --> 00:37:40,740
grands a patterns regex there's lots of

00:37:38,530 --> 00:37:40,740
things

00:37:43,370 --> 00:37:48,410
do we support German compound words

00:37:45,810 --> 00:37:52,260
there is the compound words token filter

00:37:48,410 --> 00:37:56,880
it's how well it works depends on how

00:37:52,260 --> 00:38:00,180
good your dictionary is and it's it's

00:37:56,880 --> 00:38:01,320
also quite heavy so I frankly I think

00:38:00,180 --> 00:38:01,770
it's the filter that needs for your

00:38:01,320 --> 00:38:07,140
writing

00:38:01,770 --> 00:38:09,870
it means rewriting in Lucene but yes

00:38:07,140 --> 00:38:14,100
that exists and or an alternate approach

00:38:09,870 --> 00:38:16,560
would be to use an Engram approach I am

00:38:14,100 --> 00:38:18,270
very sorry we are running out of time

00:38:16,560 --> 00:38:20,700
I'll be around your goodness

00:38:18,270 --> 00:38:22,380
thanks Clinton for your talk thank you

00:38:20,700 --> 00:38:25,700
very much and maybe you'll find him

00:38:22,380 --> 00:38:25,700

YouTube URL: https://www.youtube.com/watch?v=bZGSHm-XE1A


