Title: Berlin Buzzwords 2014: Peter Bourgon - CRDTs: Consistency without consensus #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	When you think of distributed systems, you probably think in terms of consistency via consensus. That is, enabling a heterogeneous group of systems to agree on facts, while remaining robust in the face of failure. But, as any distributed systems developer can attest, it's harder than it sounds. Failure happens in myriad, byzantine ways, and failure modes interact unpredictably. 

Reliable distributed systems need more than competent engineering: they need a robust theoretical foundation. CRDTs, or Convergent Replicated Data Types, are a set of properties or behaviors, discovered more than invented, which enable a distributed system to achieve consistency without consensus, and sidestep entire classes of problems altogether. 

Read more:
https://2014.berlinbuzzwords.de/session/crdts-consistency-without-consensus

About Peter Bourgon:
https://2014.berlinbuzzwords.de/user/155/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,990 --> 00:00:14,170
okay so i guess we're getting close to

00:00:11,830 --> 00:00:17,260
the time and we're at the time hi

00:00:14,170 --> 00:00:19,480
everybody my name is Peter and this talk

00:00:17,260 --> 00:00:21,460
is called consistency without consensus

00:00:19,480 --> 00:00:22,900
and I guess it's very similar to another

00:00:21,460 --> 00:00:25,180
talk that's coming up right after this

00:00:22,900 --> 00:00:26,560
which is has a very similar title I

00:00:25,180 --> 00:00:30,670
forget the name but that one's cool to

00:00:26,560 --> 00:00:33,280
go to that one as for this one it's it's

00:00:30,670 --> 00:00:36,399
ultimately a talk about distributed

00:00:33,280 --> 00:00:41,469
systems so I'd like to start by talking

00:00:36,399 --> 00:00:43,320
a bit distributed systems theory so if

00:00:41,469 --> 00:00:45,159
you're a distributed programmer or

00:00:43,320 --> 00:00:46,629
you're interested in distributed

00:00:45,159 --> 00:00:50,079
programming i guess i'd like to read a

00:00:46,629 --> 00:00:52,690
quote about the topic and that is this

00:00:50,079 --> 00:00:54,249
that distributed programming is the art

00:00:52,690 --> 00:00:55,960
of solving the same problem that you can

00:00:54,249 --> 00:00:58,839
solve on a single computer using

00:00:55,960 --> 00:01:00,999
multiple computers I have another quotes

00:00:58,839 --> 00:01:02,949
and that is that distributed programming

00:01:00,999 --> 00:01:05,650
is generally a bad idea and you should

00:01:02,949 --> 00:01:07,780
try to avoid it if possible and I think

00:01:05,650 --> 00:01:09,100
like this is pretty intuitive it's I

00:01:07,780 --> 00:01:13,090
think it's easier to understand why this

00:01:09,100 --> 00:01:16,329
is true so as an example consider the

00:01:13,090 --> 00:01:18,850
case of setting a single variable or to

00:01:16,329 --> 00:01:21,100
use a more academic term setting a

00:01:18,850 --> 00:01:23,200
register on a single computer it's

00:01:21,100 --> 00:01:25,420
pretty easy like you load up I Python

00:01:23,200 --> 00:01:26,860
and then you like type that and then you

00:01:25,420 --> 00:01:29,619
type that and then you get that right

00:01:26,860 --> 00:01:31,240
and if you didn't observe that behavior

00:01:29,619 --> 00:01:32,439
then there'd be something pretty

00:01:31,240 --> 00:01:34,329
fundamentally wrong with your computer

00:01:32,439 --> 00:01:38,229
like something totally devastating to

00:01:34,329 --> 00:01:40,000
your ability to continue to program now

00:01:38,229 --> 00:01:41,619
consider the same interaction against a

00:01:40,000 --> 00:01:43,060
distributed system there's many ways to

00:01:41,619 --> 00:01:46,539
do it but maybe here's one you would

00:01:43,060 --> 00:01:48,369
curl up a post request to some restful

00:01:46,539 --> 00:01:50,649
endpoint rest dish endpoint you pass

00:01:48,369 --> 00:01:52,869
some data and then of course you get you

00:01:50,649 --> 00:01:54,880
know this back it's like okay well maybe

00:01:52,869 --> 00:01:57,759
maybe worked anyway let's try doing a

00:01:54,880 --> 00:01:58,869
get and internal server error right it

00:01:57,759 --> 00:02:00,520
might as well be like an ascii art

00:01:58,869 --> 00:02:03,340
middle finger right for all the good it

00:02:00,520 --> 00:02:04,960
does you and this what's crucial here is

00:02:03,340 --> 00:02:07,240
this this isn't in any way abnormal

00:02:04,960 --> 00:02:09,580
right like whenever you interact with

00:02:07,240 --> 00:02:12,100
any distributed system you see errors

00:02:09,580 --> 00:02:13,870
like this all the time no matter how

00:02:12,100 --> 00:02:15,099
routine are conceptually simple what

00:02:13,870 --> 00:02:17,709
you're doing is you have to deal with

00:02:15,099 --> 00:02:19,180
stuff on this level and you have to deal

00:02:17,709 --> 00:02:19,390
with these failures in these errors that

00:02:19,180 --> 00:02:21,790
are

00:02:19,390 --> 00:02:23,500
like myriad complex ways that everything

00:02:21,790 --> 00:02:24,970
can go wrong and these are all things

00:02:23,500 --> 00:02:26,350
that we have to account for and defend

00:02:24,970 --> 00:02:28,810
against when we're doing distributed

00:02:26,350 --> 00:02:30,400
programming so I'm not the first guy to

00:02:28,810 --> 00:02:33,520
recognize this even back in the days of

00:02:30,400 --> 00:02:35,020
like ARPANET people knew distributing

00:02:33,520 --> 00:02:38,080
distributed programming was harder than

00:02:35,020 --> 00:02:39,400
regular programming and so I came up

00:02:38,080 --> 00:02:41,610
with all these nice primitives and

00:02:39,400 --> 00:02:44,500
patterns to deal with the complexity and

00:02:41,610 --> 00:02:47,440
in the early days I will argue the

00:02:44,500 --> 00:02:49,959
dominant primitive and pattern was its

00:02:47,440 --> 00:02:52,840
concept of the RPC so this is saying

00:02:49,959 --> 00:02:56,050
that network communication can be

00:02:52,840 --> 00:02:58,330
modeled like a function call and we can

00:02:56,050 --> 00:03:01,030
kind of treat it in the same conceptual

00:02:58,330 --> 00:03:02,380
way unfortunately there's a big

00:03:01,030 --> 00:03:04,690
difference between moving a program

00:03:02,380 --> 00:03:05,860
counter in a CPU and serializing a

00:03:04,690 --> 00:03:07,150
request sending it over network and

00:03:05,860 --> 00:03:08,709
getting it back and I'm going to argue

00:03:07,150 --> 00:03:12,220
that it's a difference not only in

00:03:08,709 --> 00:03:16,810
degree but also in kind fundamental

00:03:12,220 --> 00:03:19,630
difference so next leap forward I would

00:03:16,810 --> 00:03:20,739
argue is in the 90s there's this thing

00:03:19,630 --> 00:03:22,269
called korba and like all these

00:03:20,739 --> 00:03:26,799
middlewares does anybody who's korbo

00:03:22,269 --> 00:03:29,920
before I'm so sorry yeah korbo was

00:03:26,799 --> 00:03:31,630
really bad so there's like a lot of

00:03:29,920 --> 00:03:33,190
things in korba that they tried to use

00:03:31,630 --> 00:03:34,750
to make things easier there's this thing

00:03:33,190 --> 00:03:36,670
called a distributed object paradigm

00:03:34,750 --> 00:03:39,280
there's this thing they tried to

00:03:36,670 --> 00:03:41,410
implement called location transparency

00:03:39,280 --> 00:03:43,239
basically if you held a reference to

00:03:41,410 --> 00:03:45,250
some object or some data it shouldn't

00:03:43,239 --> 00:03:47,079
matter in the corba world if it was like

00:03:45,250 --> 00:03:49,890
on your local machine or if it was on

00:03:47,079 --> 00:03:52,120
the other end of the network connection

00:03:49,890 --> 00:03:56,200
I'm going to argue that middlewares like

00:03:52,120 --> 00:03:57,610
went too far too fast and that they

00:03:56,200 --> 00:03:59,530
treated the network kind of is more

00:03:57,610 --> 00:04:00,910
reliable than an hour then it actually

00:03:59,530 --> 00:04:02,380
was and they didn't provide good

00:04:00,910 --> 00:04:06,239
abstractions for dealing with the errors

00:04:02,380 --> 00:04:08,500
that networks inevitably would give you

00:04:06,239 --> 00:04:10,299
so we build a lot of systems with

00:04:08,500 --> 00:04:11,860
Corbett like if you're interacting with

00:04:10,299 --> 00:04:13,269
your bank these days almost certainly

00:04:11,860 --> 00:04:17,229
you're going through some korba layer at

00:04:13,269 --> 00:04:18,640
some point and whether or not these

00:04:17,229 --> 00:04:21,700
systems are reliable is open for debate

00:04:18,640 --> 00:04:26,380
but we didn't have really anything

00:04:21,700 --> 00:04:28,419
better to base our built engineered

00:04:26,380 --> 00:04:31,240
systems on until I will argue the year

00:04:28,419 --> 00:04:33,639
2000 and in that year there was a thing

00:04:31,240 --> 00:04:36,879
called the cap theorem by this

00:04:33,639 --> 00:04:39,210
named Eric Brewer and often this is

00:04:36,879 --> 00:04:42,009
summarized kind of incorrectly as

00:04:39,210 --> 00:04:45,969
consistency availability partition

00:04:42,009 --> 00:04:47,439
tolerance you can pick two of them so

00:04:45,969 --> 00:04:49,689
more than anything I'm going to argue

00:04:47,439 --> 00:04:51,520
that the cap theorem represented like a

00:04:49,689 --> 00:04:54,789
fundamental shift in the way we look at

00:04:51,520 --> 00:04:56,499
distributed programming specifically it

00:04:54,789 --> 00:05:01,349
made us confront the reality of

00:04:56,499 --> 00:05:03,580
partitions so partition tolerance is

00:05:01,349 --> 00:05:06,819
that the system continues to operate

00:05:03,580 --> 00:05:09,789
despite message loss due to network and

00:05:06,819 --> 00:05:11,770
node failure that's one way to formulate

00:05:09,789 --> 00:05:14,080
the idea and because we haven't yet

00:05:11,770 --> 00:05:15,340
invented like perfect networks this is

00:05:14,080 --> 00:05:16,960
an invariant in distributed programming

00:05:15,340 --> 00:05:19,870
nodes are going to fail the network is

00:05:16,960 --> 00:05:22,020
going to fail so when we're constructing

00:05:19,870 --> 00:05:26,169
systems through the lens of the cap

00:05:22,020 --> 00:05:27,879
theorem we must choose P we must choose

00:05:26,169 --> 00:05:31,000
partition tolerance so you've probably

00:05:27,879 --> 00:05:33,909
seen this diagram the cap theorem says

00:05:31,000 --> 00:05:36,279
that we can't do that we can't have all

00:05:33,909 --> 00:05:37,750
three we gotta pick two and because

00:05:36,279 --> 00:05:40,180
networks are fallible we have to pick

00:05:37,750 --> 00:05:43,180
partition tolerance so that leaves us

00:05:40,180 --> 00:05:44,710
with basically two options right so

00:05:43,180 --> 00:05:47,409
called CP systems that choose

00:05:44,710 --> 00:05:51,189
consistency and so-called ap systems

00:05:47,409 --> 00:05:53,560
that choose availability so CP systems

00:05:51,189 --> 00:05:54,909
forgive me if this is like something

00:05:53,560 --> 00:05:56,830
you've all heard before but it's

00:05:54,909 --> 00:06:00,849
important to lay the groundwork CP

00:05:56,830 --> 00:06:02,050
systems they're typically bill around

00:06:00,849 --> 00:06:04,180
something called a consensus algorithm

00:06:02,050 --> 00:06:06,699
or consensus protocol here are some

00:06:04,180 --> 00:06:08,919
examples taxes is maybe the most famous

00:06:06,699 --> 00:06:11,229
consensus protocol there's some systems

00:06:08,919 --> 00:06:13,659
built on that Doozer is one written and

00:06:11,229 --> 00:06:15,610
go chubby is the Google paxos

00:06:13,659 --> 00:06:17,319
implementation there's another one

00:06:15,610 --> 00:06:21,069
called Zab which is very similar but not

00:06:17,319 --> 00:06:22,509
the same zookeeper uses Zab raft is a

00:06:21,069 --> 00:06:24,639
new like hipster consensus algorithm

00:06:22,509 --> 00:06:27,009
there's a couple of things using raft

00:06:24,639 --> 00:06:28,719
console is the latest and greatest at CD

00:06:27,009 --> 00:06:30,490
uses another implementation of raft

00:06:28,719 --> 00:06:31,659
there's still another one which is super

00:06:30,490 --> 00:06:33,250
academic it's called view stamp

00:06:31,659 --> 00:06:34,360
replication I'm not aware of any systems

00:06:33,250 --> 00:06:35,409
that are built using it but it's a fun

00:06:34,360 --> 00:06:38,649
read if you're into this sort of thing

00:06:35,409 --> 00:06:41,680
so these protocols are robust and CPW

00:06:38,649 --> 00:06:44,680
systems are often provably reliable and

00:06:41,680 --> 00:06:47,350
corrects but they're relatively

00:06:44,680 --> 00:06:48,970
difficult to explain to the layperson

00:06:47,350 --> 00:06:50,980
and as a result they're kind of

00:06:48,970 --> 00:06:55,750
difficult to implement and debug and

00:06:50,980 --> 00:06:57,550
maintain their also relatively slow with

00:06:55,750 --> 00:07:00,100
kind of high operational Layton sees for

00:06:57,550 --> 00:07:03,460
every interaction and low operational

00:07:00,100 --> 00:07:04,720
throughput so they're kind of unsuitable

00:07:03,460 --> 00:07:06,820
for a lot of things you want to use

00:07:04,720 --> 00:07:08,500
distributed systems for for example you

00:07:06,820 --> 00:07:11,050
probably couldn't store your tweet

00:07:08,500 --> 00:07:12,400
stream in acp replicated log for those

00:07:11,050 --> 00:07:15,640
kind of things we need to consider the

00:07:12,400 --> 00:07:19,210
other side of the cap spectrum which is

00:07:15,640 --> 00:07:22,300
AP and this is choosing availability and

00:07:19,210 --> 00:07:23,980
partition tolerance but so called AP

00:07:22,300 --> 00:07:25,780
systems like these don't actually

00:07:23,980 --> 00:07:29,100
sacrifice consistency they just use a

00:07:25,780 --> 00:07:32,230
different form of it so CP systems are

00:07:29,100 --> 00:07:34,150
strongly consistent and AP systems are

00:07:32,230 --> 00:07:35,200
less than strongly consistent and

00:07:34,150 --> 00:07:37,030
there's different types of less than

00:07:35,200 --> 00:07:38,500
strong consistency I'm going to talk

00:07:37,030 --> 00:07:39,700
about one which you've all probably

00:07:38,500 --> 00:07:42,190
heard of it's called eventual

00:07:39,700 --> 00:07:44,230
consistency and that basically means

00:07:42,190 --> 00:07:46,990
that you accept that some nodes in the

00:07:44,230 --> 00:07:49,540
system may be stale at a given point in

00:07:46,990 --> 00:07:52,300
the in time but you try to ensure that

00:07:49,540 --> 00:07:55,120
no nodes will be completely wrong and so

00:07:52,300 --> 00:07:57,460
if that's your constraint you can build

00:07:55,120 --> 00:08:00,040
systems in a way that potentially

00:07:57,460 --> 00:08:02,200
satisfies it so a lot of energy would

00:08:00,040 --> 00:08:04,090
spend the last decade or so trying to

00:08:02,200 --> 00:08:06,060
get eventual consistency to work well in

00:08:04,090 --> 00:08:10,150
the general case and these are some

00:08:06,060 --> 00:08:12,850
products of that of that energy a lot of

00:08:10,150 --> 00:08:16,510
them do a really admirable job right but

00:08:12,850 --> 00:08:19,390
the path to that current state where we

00:08:16,510 --> 00:08:20,560
live today was a bumpy one especially in

00:08:19,390 --> 00:08:24,610
the early days there was a lot of

00:08:20,560 --> 00:08:26,320
frustration and public failure and I'm

00:08:24,610 --> 00:08:30,100
going to argue that it was a function of

00:08:26,320 --> 00:08:32,140
a gap between what people expected these

00:08:30,100 --> 00:08:34,419
systems to be able to do and what the

00:08:32,140 --> 00:08:37,570
system's actually promised or could do

00:08:34,419 --> 00:08:40,570
and there was an I'm gonna argue

00:08:37,570 --> 00:08:42,690
continues to be a large gap between the

00:08:40,570 --> 00:08:45,820
theoretical state of the art and ap

00:08:42,690 --> 00:08:47,470
information theory and the engineering

00:08:45,820 --> 00:08:51,430
practice that produces products like

00:08:47,470 --> 00:08:54,280
this now recently relatively recently

00:08:51,430 --> 00:08:56,770
there's been kind of a conceptual

00:08:54,280 --> 00:08:59,020
revolution there's been a big leap that

00:08:56,770 --> 00:09:00,700
closes that gap and that's ultimately

00:08:59,020 --> 00:09:03,190
what I'm going to talk about consists

00:09:00,700 --> 00:09:04,630
see without consensus so I'll explain

00:09:03,190 --> 00:09:07,060
what i think are two formulations of

00:09:04,630 --> 00:09:09,430
that idea kind of the same idea and they

00:09:07,060 --> 00:09:11,980
all have to do with this idea of failure

00:09:09,430 --> 00:09:13,810
so partitioning in a network is one

00:09:11,980 --> 00:09:15,580
broad class of failure but there's other

00:09:13,810 --> 00:09:19,840
like more subtle ways that partitioning

00:09:15,580 --> 00:09:21,730
can happen specifically messages in a

00:09:19,840 --> 00:09:23,460
network can be delayed they can arrive

00:09:21,730 --> 00:09:25,900
out of order from the way they were sent

00:09:23,460 --> 00:09:29,440
they can be dropped all together and

00:09:25,900 --> 00:09:31,780
they can be duplicated and these are all

00:09:29,440 --> 00:09:35,230
invariants in our networks we have to

00:09:31,780 --> 00:09:36,910
deal with these conditions and one way

00:09:35,230 --> 00:09:40,050
maybe the best way to deal with in

00:09:36,910 --> 00:09:42,130
variance is to allow them to happen

00:09:40,050 --> 00:09:44,050
allow them to happen without corrupting

00:09:42,130 --> 00:09:46,660
the system state that we build on top of

00:09:44,050 --> 00:09:48,990
it so how can we how can we allow these

00:09:46,660 --> 00:09:52,300
things to happen and that's what these

00:09:48,990 --> 00:09:56,980
solutions that's what these big leaps

00:09:52,300 --> 00:09:59,380
recent leaps attempt to implement so the

00:09:56,980 --> 00:10:02,170
first one is this thing called the comm

00:09:59,380 --> 00:10:04,090
principle has anybody heard of this good

00:10:02,170 --> 00:10:08,820
great I'm introducing you to new ideas

00:10:04,090 --> 00:10:12,430
calm stands for consistency as logical

00:10:08,820 --> 00:10:16,300
monotonicity and that's a big an

00:10:12,430 --> 00:10:18,460
abstract way of saying a system can only

00:10:16,300 --> 00:10:23,230
really grow over time in one direction

00:10:18,460 --> 00:10:24,880
or should rather so imagine a number

00:10:23,230 --> 00:10:28,450
that you can only add to and never

00:10:24,880 --> 00:10:31,300
subtract from the bloom language its

00:10:28,450 --> 00:10:33,460
bloom lang org is built with this kind

00:10:31,300 --> 00:10:35,290
of guiding principle in mind but it's a

00:10:33,460 --> 00:10:36,760
little bit abstract so there's another

00:10:35,290 --> 00:10:38,110
formulation of this idea which i think

00:10:36,760 --> 00:10:40,930
is a little easier to get your head

00:10:38,110 --> 00:10:42,610
around and that's so called acid two

00:10:40,930 --> 00:10:44,110
point oh so probably you guys have heard

00:10:42,610 --> 00:10:45,880
of acid in the context of databases

00:10:44,110 --> 00:10:49,170
right and I think I forget what it's

00:10:45,880 --> 00:10:52,500
like atomicity what's the other one

00:10:49,170 --> 00:10:56,200
consistency is all right independent

00:10:52,500 --> 00:10:58,990
isolation and durability right okay so

00:10:56,200 --> 00:11:01,060
that's cool that's like our DBMS is are

00:10:58,990 --> 00:11:02,980
built on these principles so some smart

00:11:01,060 --> 00:11:05,050
fella back around twenty two thousand

00:11:02,980 --> 00:11:06,610
nine or 2010 he was like aha I can use

00:11:05,050 --> 00:11:10,270
this acronym and the field of

00:11:06,610 --> 00:11:14,310
distributed systems so for him acid two

00:11:10,270 --> 00:11:18,210
point O is associative associativity

00:11:14,310 --> 00:11:20,010
commutativity idem potency and then he

00:11:18,210 --> 00:11:23,400
kind of ran out of stream steam she was

00:11:20,010 --> 00:11:24,930
like okay distributed yeah whatever and

00:11:23,400 --> 00:11:28,050
it would argue this is basically the

00:11:24,930 --> 00:11:31,080
same idea as calm but kind of reified

00:11:28,050 --> 00:11:35,310
like made more concrete and it means

00:11:31,080 --> 00:11:37,740
that a system which is acid two point O

00:11:35,310 --> 00:11:40,550
compliant has operations which satisfy

00:11:37,740 --> 00:11:46,770
all of these things well the first three

00:11:40,550 --> 00:11:51,770
so that brings us kind of to the name of

00:11:46,770 --> 00:11:55,400
the talk which is CR DTS crd T's are

00:11:51,770 --> 00:11:59,310
conflict-free replicated data types and

00:11:55,400 --> 00:12:01,550
it's a distributed data type like a

00:11:59,310 --> 00:12:04,980
simple variable or a set which is

00:12:01,550 --> 00:12:09,660
provably eventually consistent without

00:12:04,980 --> 00:12:12,240
consensus so CR dt's achieve eventual

00:12:09,660 --> 00:12:16,860
consistency by using acid to point o or

00:12:12,240 --> 00:12:19,860
calm compliant operations the seminal

00:12:16,860 --> 00:12:22,170
paper on CR DTS like the the source

00:12:19,860 --> 00:12:24,780
material is by this guy named Mark

00:12:22,170 --> 00:12:26,820
Shapiro he's I think of Microsoft or

00:12:24,780 --> 00:12:29,100
formulae of Microsoft but it's super

00:12:26,820 --> 00:12:31,170
academic and kind of difficult to wrap

00:12:29,100 --> 00:12:32,940
your head around and for me at least the

00:12:31,170 --> 00:12:35,700
best way to understand what is a crdt is

00:12:32,940 --> 00:12:37,080
by example so let's try that let's pick

00:12:35,700 --> 00:12:39,000
a motivating example and I think the

00:12:37,080 --> 00:12:41,400
easiest one is something called an

00:12:39,000 --> 00:12:42,630
increment only counter so you can

00:12:41,400 --> 00:12:44,610
imagine what is the counter it's a

00:12:42,630 --> 00:12:47,220
number you can add to our remove or

00:12:44,610 --> 00:12:50,250
subtract from but an increment only

00:12:47,220 --> 00:12:52,350
counter is a replicated integer

00:12:50,250 --> 00:12:56,250
supporting operations increments to

00:12:52,350 --> 00:13:02,010
update and value to query so plus one or

00:12:56,250 --> 00:13:03,540
read so let's think about the reeds easy

00:13:02,010 --> 00:13:05,850
right you just read the value that's

00:13:03,540 --> 00:13:07,380
there that shouldn't be too tricky but

00:13:05,850 --> 00:13:10,620
let's think about the the write

00:13:07,380 --> 00:13:12,779
operation that the plus so what are the

00:13:10,620 --> 00:13:15,510
properties of addition integer addition

00:13:12,779 --> 00:13:19,110
well it turns out it is associative

00:13:15,510 --> 00:13:20,880
meaning this statement is true and it is

00:13:19,110 --> 00:13:24,000
commutative meaning that statement is

00:13:20,880 --> 00:13:26,250
true but it's not I Denton because

00:13:24,000 --> 00:13:28,230
that's that's false so addition by

00:13:26,250 --> 00:13:30,630
itself isn't a crdt

00:13:28,230 --> 00:13:32,520
acid to point o compliant calm compliant

00:13:30,630 --> 00:13:34,800
operation so we have to play a little

00:13:32,520 --> 00:13:38,520
bit of a game to get an increment only

00:13:34,800 --> 00:13:41,790
counter into crdt semantics so in the

00:13:38,520 --> 00:13:45,030
paper he describes a data type called a

00:13:41,790 --> 00:13:46,980
G counter and it works like this let's

00:13:45,030 --> 00:13:50,010
say you have a note distributed system

00:13:46,980 --> 00:13:52,740
with three nodes each node is going to

00:13:50,010 --> 00:13:56,790
hold an array and in the array there's

00:13:52,740 --> 00:13:58,710
going to be three indices on node1 let's

00:13:56,790 --> 00:14:00,540
say the red node is going to own the

00:13:58,710 --> 00:14:01,770
first index in that array on node 2 it's

00:14:00,540 --> 00:14:06,650
going to own the second index in that

00:14:01,770 --> 00:14:09,270
array and so forth now let's and

00:14:06,650 --> 00:14:12,600
crucially the other indices represents

00:14:09,270 --> 00:14:13,830
the state of the machine the

00:14:12,600 --> 00:14:15,780
corresponding machine I hope I've made

00:14:13,830 --> 00:14:17,460
that clear with the colors so let's

00:14:15,780 --> 00:14:19,320
consider how a write operation would

00:14:17,460 --> 00:14:21,600
work let's say someone comes along and

00:14:19,320 --> 00:14:23,250
issues a increment operation into this

00:14:21,600 --> 00:14:27,450
distributed system and it just so

00:14:23,250 --> 00:14:29,370
happens to hit the second node so what's

00:14:27,450 --> 00:14:32,670
going to happen is the second note is

00:14:29,370 --> 00:14:36,450
going to update its owned index in the

00:14:32,670 --> 00:14:39,150
array and now the value of this counter

00:14:36,450 --> 00:14:41,610
is considered to be the sum of that

00:14:39,150 --> 00:14:43,770
array so at the moment the value is now

00:14:41,610 --> 00:14:45,390
one on the other nodes the value is

00:14:43,770 --> 00:14:47,520
still 0 so in this way it's an

00:14:45,390 --> 00:14:50,070
inconsistent state but it's eventually

00:14:47,520 --> 00:14:51,420
consistent we'll see how okay so that

00:14:50,070 --> 00:14:53,820
write operation worked in now if someone

00:14:51,420 --> 00:14:55,770
else read from the second node it would

00:14:53,820 --> 00:14:57,000
see the correct value they read from

00:14:55,770 --> 00:15:00,000
either the other two nodes they would

00:14:57,000 --> 00:15:02,370
see an incorrect value the second note

00:15:00,000 --> 00:15:04,470
is now going to take ownership of this

00:15:02,370 --> 00:15:06,870
state change its going to propagate it

00:15:04,470 --> 00:15:08,820
to the other nodes in the system whom he

00:15:06,870 --> 00:15:11,820
presumably knows about knows how to

00:15:08,820 --> 00:15:16,590
contact them so step one is to issue

00:15:11,820 --> 00:15:19,530
this message up to node 0 but crucially

00:15:16,590 --> 00:15:23,310
it's not a +1 the message content says I

00:15:19,530 --> 00:15:26,610
am node want the second node and my

00:15:23,310 --> 00:15:28,560
value is currently one that's it's

00:15:26,610 --> 00:15:30,330
important that it not be +1 because +1

00:15:28,560 --> 00:15:32,250
as we saw isn't I'd impotent but what I

00:15:30,330 --> 00:15:34,290
just said is if that happens three or

00:15:32,250 --> 00:15:37,860
four times the Penn State is going to be

00:15:34,290 --> 00:15:39,900
the same does the same thing down there

00:15:37,860 --> 00:15:41,610
and now we have a consistent state no

00:15:39,900 --> 00:15:44,070
matter which node you read from

00:15:41,610 --> 00:15:47,190
you're going to see the same value which

00:15:44,070 --> 00:15:48,810
is one okay let's consider another write

00:15:47,190 --> 00:15:52,079
operation another increment this time to

00:15:48,810 --> 00:15:54,779
this guy same thing now his state is too

00:15:52,079 --> 00:15:56,310
it's going to propagate it there so far

00:15:54,779 --> 00:15:59,730
so good but let's say that this message

00:15:56,310 --> 00:16:01,140
is lost or delayed we have an

00:15:59,730 --> 00:16:04,440
inconsistent state in the overall system

00:16:01,140 --> 00:16:08,100
that's not great and it's going to stay

00:16:04,440 --> 00:16:10,470
there absent the state's going to remain

00:16:08,100 --> 00:16:12,690
inconsistent absent some motivating

00:16:10,470 --> 00:16:16,230
condition but check out what happens now

00:16:12,690 --> 00:16:18,660
if we get another plus one to the same

00:16:16,230 --> 00:16:21,570
node it's going to replicate remember

00:16:18,660 --> 00:16:23,790
with these like State semantics and if

00:16:21,570 --> 00:16:27,510
it makes it down there we're suddenly

00:16:23,790 --> 00:16:30,920
consistent again so that's cool and

00:16:27,510 --> 00:16:33,899
again if it gets duplicated no change

00:16:30,920 --> 00:16:35,760
we're still good so this is cool this is

00:16:33,899 --> 00:16:37,800
a way to make an increment only counter

00:16:35,760 --> 00:16:40,589
work unfortunately it does have some

00:16:37,800 --> 00:16:42,930
downsides it requires that the list of

00:16:40,589 --> 00:16:44,550
nodes be both known to all nodes in the

00:16:42,930 --> 00:16:46,260
network and kind of static because it's

00:16:44,550 --> 00:16:47,910
these arrays are like allocated in that

00:16:46,260 --> 00:16:49,860
way so it turns out we can do a little

00:16:47,910 --> 00:16:54,180
bit better and the paper talks about

00:16:49,860 --> 00:16:56,010
this too let's consider a better way to

00:16:54,180 --> 00:16:59,640
do an increment only counter and for

00:16:56,010 --> 00:17:02,279
this we turn two sets so when you have a

00:16:59,640 --> 00:17:05,429
set rather than an integer your addition

00:17:02,279 --> 00:17:08,549
operator is a union so let's run through

00:17:05,429 --> 00:17:10,530
the list again if we have a set

00:17:08,549 --> 00:17:13,620
containing one union with a second

00:17:10,530 --> 00:17:17,630
hanging two and three that statement is

00:17:13,620 --> 00:17:20,760
true so Union operation is associative

00:17:17,630 --> 00:17:23,040
that's also true I hope is clear so it's

00:17:20,760 --> 00:17:26,069
commutative but handily it's also

00:17:23,040 --> 00:17:27,750
adamant in other words if you Union a

00:17:26,069 --> 00:17:29,520
set containing a value with a set

00:17:27,750 --> 00:17:33,210
already containing that value you get

00:17:29,520 --> 00:17:36,240
the identity set so that's cool can we

00:17:33,210 --> 00:17:38,790
model this incremental encounter using

00:17:36,240 --> 00:17:42,720
sets instead of integers well it turns

00:17:38,790 --> 00:17:45,360
out we can but it's a bit interesting

00:17:42,720 --> 00:17:46,890
because the expression plus one isn't by

00:17:45,360 --> 00:17:48,650
itself unique and in order for something

00:17:46,890 --> 00:17:51,090
to be in a set it should be unique so

00:17:48,650 --> 00:17:52,980
what we have to do for this to work is

00:17:51,090 --> 00:17:55,080
take a step back and consider our

00:17:52,980 --> 00:17:55,690
application domain and we have to say

00:17:55,080 --> 00:17:57,730
well your

00:17:55,690 --> 00:18:00,759
longer just issuing a plus 1 into this

00:17:57,730 --> 00:18:02,889
increment only distributed counter you

00:18:00,759 --> 00:18:05,259
have to do something else to it let's

00:18:02,889 --> 00:18:07,389
say for example the counter represents

00:18:05,259 --> 00:18:09,820
the number of unique plays that attract

00:18:07,389 --> 00:18:12,250
on Soundcloud gets and so what we can do

00:18:09,820 --> 00:18:15,940
is instead of saying plus 1 we can send

00:18:12,250 --> 00:18:19,750
into the network the user ID of the

00:18:15,940 --> 00:18:22,750
person who press play and so this would

00:18:19,750 --> 00:18:24,850
be unique because I user ID can only

00:18:22,750 --> 00:18:28,720
uniquely play a trap once and can never

00:18:24,850 --> 00:18:30,639
revoke it so it kind of makes sense so

00:18:28,720 --> 00:18:32,379
now here's what it looks like instead of

00:18:30,639 --> 00:18:34,990
an array we have three sets currently

00:18:32,379 --> 00:18:36,639
empty and in order to compute the value

00:18:34,990 --> 00:18:38,529
of this replicated integer of this

00:18:36,639 --> 00:18:40,149
increment only counter we're going to

00:18:38,529 --> 00:18:41,500
compute the cardinality of these sets

00:18:40,149 --> 00:18:45,279
and right now there's nothing in them so

00:18:41,500 --> 00:18:48,340
the cardinality 0 same basic state ok

00:18:45,279 --> 00:18:50,769
let's consider user ID 123 it's play on

00:18:48,340 --> 00:18:53,830
this track remember this increment only

00:18:50,769 --> 00:18:55,720
counter represents a single track so

00:18:53,830 --> 00:18:58,860
that's going to hit one node randomly in

00:18:55,720 --> 00:19:02,740
our distributed system it's going to

00:18:58,860 --> 00:19:05,429
enter that set the same semantics for

00:19:02,740 --> 00:19:08,529
replicating that to the other sets and

00:19:05,429 --> 00:19:10,870
now we have consistent eventually

00:19:08,529 --> 00:19:13,929
consistent cardinality of one across

00:19:10,870 --> 00:19:18,809
this integer same thing you can imagine

00:19:13,929 --> 00:19:22,509
ok exact same operations so this is

00:19:18,809 --> 00:19:24,309
solving the same problem that the

00:19:22,509 --> 00:19:26,230
original array based implementation did

00:19:24,309 --> 00:19:30,039
but it relaxes this restriction of

00:19:26,230 --> 00:19:32,250
having to know a priori the topology of

00:19:30,039 --> 00:19:38,009
our distributed network so this is cool

00:19:32,250 --> 00:19:40,559
and it works so now a brief interlude

00:19:38,009 --> 00:19:43,419
crd T's give us these really nice

00:19:40,559 --> 00:19:44,769
properties there a solution that gives

00:19:43,419 --> 00:19:47,350
us these really nice properties that we

00:19:44,769 --> 00:19:49,419
want to leverage and sometimes that

00:19:47,350 --> 00:19:52,649
requires bending the definition of our

00:19:49,419 --> 00:19:57,669
problem to fit them i think tomorrow

00:19:52,649 --> 00:20:01,269
morning the keynote eyes by this beer

00:19:57,669 --> 00:20:03,669
ops young woman and she's going to talk

00:20:01,269 --> 00:20:06,220
about the DevOps revolution and i'd like

00:20:03,669 --> 00:20:07,960
to draw a parallel here in analogy in

00:20:06,220 --> 00:20:09,190
the battle days we used to build these

00:20:07,960 --> 00:20:10,150
binary artifacts and

00:20:09,190 --> 00:20:11,950
we would deal like works on my machine

00:20:10,150 --> 00:20:13,540
and then like throw it to the sis

00:20:11,950 --> 00:20:15,280
admin's right and then they say you guys

00:20:13,540 --> 00:20:16,810
you should run this in production and

00:20:15,280 --> 00:20:20,620
you should get paged when it goes down

00:20:16,810 --> 00:20:22,960
and you should scale it out we

00:20:20,620 --> 00:20:24,820
eventually recognized an invariant in

00:20:22,960 --> 00:20:26,680
software engineering which was that as

00:20:24,820 --> 00:20:29,200
the authors of a piece of software we

00:20:26,680 --> 00:20:31,630
are like uniquely qualified to run that

00:20:29,200 --> 00:20:33,580
piece of software in production we're

00:20:31,630 --> 00:20:36,070
best whether we're going to be the best

00:20:33,580 --> 00:20:38,140
person to do it so we had this like

00:20:36,070 --> 00:20:40,570
DevOps revolution right and we changed

00:20:38,140 --> 00:20:42,010
our methodology and we said programmers

00:20:40,570 --> 00:20:44,410
are expected not just to type the code

00:20:42,010 --> 00:20:46,750
in build a war file and throw it at

00:20:44,410 --> 00:20:48,970
somebody but to deploy to production

00:20:46,750 --> 00:20:50,980
ourselves and to monitor it and it get

00:20:48,970 --> 00:20:54,460
paged when it breaks and to fix it and

00:20:50,980 --> 00:20:55,960
then to scale it down when or scale it

00:20:54,460 --> 00:20:58,300
up when we need more capacity and scale

00:20:55,960 --> 00:21:01,270
it down when the next version of the

00:20:58,300 --> 00:21:03,370
software comes along and we're better

00:21:01,270 --> 00:21:04,900
for it as an industry I think all the

00:21:03,370 --> 00:21:06,910
best software shops work this way I hope

00:21:04,900 --> 00:21:11,320
you work this way if you don't it's bad

00:21:06,910 --> 00:21:15,520
you should feel bad but we're better for

00:21:11,320 --> 00:21:17,470
doing things this way similarly if we i

00:21:15,520 --> 00:21:19,360
would i would say that we used to write

00:21:17,470 --> 00:21:21,880
distributed systems very optimistically

00:21:19,360 --> 00:21:23,380
we categorically dismissed huge numbers

00:21:21,880 --> 00:21:26,140
of failure modes in our networks and

00:21:23,380 --> 00:21:27,790
everything everything beneath that but

00:21:26,140 --> 00:21:29,380
the cap theorem came around and showed

00:21:27,790 --> 00:21:31,090
us that they are in variance and

00:21:29,380 --> 00:21:34,090
distributed programming that we need to

00:21:31,090 --> 00:21:35,830
design for and accommodate and see our

00:21:34,090 --> 00:21:38,350
dt's i believe are the current like

00:21:35,830 --> 00:21:41,260
best-in-class solution to deal with

00:21:38,350 --> 00:21:42,970
those invariants so the fundamental

00:21:41,260 --> 00:21:44,920
argument that I'm making here is that as

00:21:42,970 --> 00:21:47,950
users and implementers of distributed

00:21:44,920 --> 00:21:50,410
systems we should read we should be like

00:21:47,950 --> 00:21:51,550
ready willing and able to change our

00:21:50,410 --> 00:21:53,890
methodology to change our way of

00:21:51,550 --> 00:21:55,840
thinking and not to hold our problem

00:21:53,890 --> 00:21:58,030
invariant and say I need to be able to

00:21:55,840 --> 00:22:01,300
say plus 1 and the system needs to

00:21:58,030 --> 00:22:03,040
support that and then try to bend the

00:22:01,300 --> 00:22:07,090
solutions that we have to fit that

00:22:03,040 --> 00:22:09,220
problem instead hold your good solutions

00:22:07,090 --> 00:22:12,010
invariant understand what is a crdt for

00:22:09,220 --> 00:22:14,440
example understand what it requires of

00:22:12,010 --> 00:22:16,870
the application domain and then bend

00:22:14,440 --> 00:22:18,670
your problem to fit it I believe that

00:22:16,870 --> 00:22:20,830
type of methodology that type of

00:22:18,670 --> 00:22:22,540
thinking produces like better more best

00:22:20,830 --> 00:22:24,850
more robust

00:22:22,540 --> 00:22:28,450
blur more reliable software and I think

00:22:24,850 --> 00:22:30,520
that benefits all of us okay that's my

00:22:28,450 --> 00:22:33,700
little speech and now we get to the

00:22:30,520 --> 00:22:37,960
interesting part which is crd tease in

00:22:33,700 --> 00:22:40,630
production and the system I'm capable of

00:22:37,960 --> 00:22:43,390
talking about so I for this company it's

00:22:40,630 --> 00:22:47,170
also there that's cool we put your

00:22:43,390 --> 00:22:48,880
sounds and cloud we're ultimately like

00:22:47,170 --> 00:22:50,530
many websites we have a social network

00:22:48,880 --> 00:22:52,540
component so if you create an account

00:22:50,530 --> 00:22:54,640
and you log in you'll be encouraged to

00:22:52,540 --> 00:22:56,560
follow other users other Creators on the

00:22:54,640 --> 00:22:59,260
platform if you follow enough people

00:22:56,560 --> 00:23:01,030
then you have this thing called the

00:22:59,260 --> 00:23:02,680
stream and you see all the things that

00:23:01,030 --> 00:23:05,380
they do all the tracks they upload all

00:23:02,680 --> 00:23:07,120
the sets that they repost and and this

00:23:05,380 --> 00:23:10,870
sort of thing so here's the stream and

00:23:07,120 --> 00:23:12,820
the stream is not unlike the facebook

00:23:10,870 --> 00:23:15,850
feed or the Twitter tweet timeline or

00:23:12,820 --> 00:23:18,460
whatever you can imagine it's comprised

00:23:15,850 --> 00:23:21,190
of things we call events and events all

00:23:18,460 --> 00:23:22,650
take basically the same form an event is

00:23:21,190 --> 00:23:25,740
the timestamp for the thing that happens

00:23:22,650 --> 00:23:28,180
the user or the actor who did the thing

00:23:25,740 --> 00:23:30,220
the verb of the thing that was done like

00:23:28,180 --> 00:23:32,380
uploaded or reposted or something like

00:23:30,220 --> 00:23:34,960
this and then a unique identifier of the

00:23:32,380 --> 00:23:36,340
thing to which the verb was applied that

00:23:34,960 --> 00:23:39,130
sounds awkward but I hope it's kind of

00:23:36,340 --> 00:23:43,180
clear what I mean so as an example on

00:23:39,130 --> 00:23:45,910
the 26 of maat 1204 56 Snoop Dogg might

00:23:43,180 --> 00:23:47,950
have reposted The Economist's podcast or

00:23:45,910 --> 00:23:50,700
something like this so that's an example

00:23:47,950 --> 00:23:52,330
of an event unlikely though it may be

00:23:50,700 --> 00:23:55,420
okay so when you're constructing

00:23:52,330 --> 00:23:58,750
timeline services tweet services this

00:23:55,420 --> 00:24:01,360
sort of thing I'm going to argue there's

00:23:58,750 --> 00:24:02,710
like two ways of doing it the first in

00:24:01,360 --> 00:24:05,500
kind of most obvious way is so-called

00:24:02,710 --> 00:24:08,260
fan out on right so imagine this is your

00:24:05,500 --> 00:24:10,090
social network you have your Creator

00:24:08,260 --> 00:24:12,730
here on the left and you have all of

00:24:10,090 --> 00:24:14,530
these listeners on the right and in this

00:24:12,730 --> 00:24:17,800
model all the listeners get kind of an

00:24:14,530 --> 00:24:19,510
inbox and so what happens is when

00:24:17,800 --> 00:24:23,440
assuming all these guys are following

00:24:19,510 --> 00:24:25,720
this guy when he produces a new track or

00:24:23,440 --> 00:24:27,970
repost something what's going to happen

00:24:25,720 --> 00:24:33,360
is that's going to get written to the

00:24:27,970 --> 00:24:33,360
inboxes of everybody who follows him

00:24:33,610 --> 00:24:38,890
and that's kind of the data model fan

00:24:35,049 --> 00:24:43,049
out on right so the locality of the data

00:24:38,890 --> 00:24:47,170
is very close to the consumer make sense

00:24:43,049 --> 00:24:49,480
so there's another way and so called fan

00:24:47,170 --> 00:24:51,520
and on read and in this model the

00:24:49,480 --> 00:24:54,220
locality of the data is close to the

00:24:51,520 --> 00:24:55,840
producer so when they upload or produce

00:24:54,220 --> 00:24:58,480
a new track or whatever it goes into

00:24:55,840 --> 00:25:01,510
their outbox and then what happens is

00:24:58,480 --> 00:25:03,429
whenever I as a listener open up my

00:25:01,510 --> 00:25:05,740
stream page what I'm going to do is

00:25:03,429 --> 00:25:08,169
query to see who I follow go to all of

00:25:05,740 --> 00:25:12,520
their out boxes and kind of pull in

00:25:08,169 --> 00:25:14,590
their recent stuff merge it together and

00:25:12,520 --> 00:25:18,120
then produce kind of a dynamic view of

00:25:14,590 --> 00:25:18,120
what my stream is at that point in time

00:25:18,480 --> 00:25:22,780
without getting into details this

00:25:20,610 --> 00:25:24,490
carries a lot of advantages you can

00:25:22,780 --> 00:25:26,679
think of that a product level it's much

00:25:24,490 --> 00:25:29,290
easier to do fun dynamic things with

00:25:26,679 --> 00:25:32,620
your stream if you can manipulate it

00:25:29,290 --> 00:25:35,950
kind of on the fly so maybe there's a

00:25:32,620 --> 00:25:38,919
way we can that our goal here is to

00:25:35,950 --> 00:25:41,620
implement a fan in on read model of the

00:25:38,919 --> 00:25:42,970
event stream perhaps using crd tease

00:25:41,620 --> 00:25:47,679
otherwise this talk would be kind of

00:25:42,970 --> 00:25:50,230
weird so let's see is there a way we can

00:25:47,679 --> 00:25:51,790
do this with what we know already it

00:25:50,230 --> 00:25:54,130
turns out that events are unique in the

00:25:51,790 --> 00:25:57,010
sense that Snoop Dogg can only repost

00:25:54,130 --> 00:25:58,809
that one economist podcast once like

00:25:57,010 --> 00:26:00,460
that that is a unique formulation of

00:25:58,809 --> 00:26:03,240
this idea should only appear in the

00:26:00,460 --> 00:26:05,860
stream once so maybe we can use the set

00:26:03,240 --> 00:26:07,780
we already know about this G set which

00:26:05,860 --> 00:26:08,950
is when I described earlier but it

00:26:07,780 --> 00:26:10,900
doesn't work because you can't delete

00:26:08,950 --> 00:26:13,809
from it so increment only you can only

00:26:10,900 --> 00:26:16,510
add things into it if you continue to

00:26:13,809 --> 00:26:17,950
read the seminal paper on C or D tease

00:26:16,510 --> 00:26:20,110
you describe some other sets which you

00:26:17,950 --> 00:26:23,500
can delete from describes a two-piece

00:26:20,110 --> 00:26:24,940
set so-called to pset you can add and

00:26:23,500 --> 00:26:27,790
delete but then you can never re ad

00:26:24,940 --> 00:26:29,380
again so that's not great there's

00:26:27,790 --> 00:26:31,720
another one called an o are set and

00:26:29,380 --> 00:26:34,179
observe remove set this does allow you

00:26:31,720 --> 00:26:36,160
to add and delete kind of indefinitely

00:26:34,179 --> 00:26:40,179
but it comes coupled with a storage

00:26:36,160 --> 00:26:41,770
overhead that is not great for us and it

00:26:40,179 --> 00:26:43,419
also imposes some restrictions on the

00:26:41,770 --> 00:26:46,809
topology of the distributed system which

00:26:43,419 --> 00:26:47,350
we we don't want but to summarize all

00:26:46,809 --> 00:26:48,730
these

00:26:47,350 --> 00:26:50,650
that's kind of work in roughly the same

00:26:48,730 --> 00:26:53,610
way I'll crdt sets kind of work in

00:26:50,650 --> 00:26:56,440
roughly the same way which is as follows

00:26:53,610 --> 00:26:58,630
there is a concept of a logical a single

00:26:56,440 --> 00:27:01,510
logical set which is split into two

00:26:58,630 --> 00:27:05,320
physical sets there's a so-called add

00:27:01,510 --> 00:27:06,730
set times like S Plus this contains all

00:27:05,320 --> 00:27:10,210
the elements that should be considered

00:27:06,730 --> 00:27:13,120
to be in the set there's a so-called

00:27:10,210 --> 00:27:14,710
remove set s minus and then the way you

00:27:13,120 --> 00:27:16,179
produce these are the two physical sets

00:27:14,710 --> 00:27:18,549
the way you produce the logical set is

00:27:16,179 --> 00:27:22,480
by doing a semantic merge of them so

00:27:18,549 --> 00:27:25,720
kind of if you merge ABC with B then

00:27:22,480 --> 00:27:28,570
this is the result right so this is kind

00:27:25,720 --> 00:27:30,490
of conceptually how they all work so now

00:27:28,570 --> 00:27:33,659
I'm going to describe a new set that we

00:27:30,490 --> 00:27:37,929
kind of came up with which powers the

00:27:33,659 --> 00:27:40,030
soundcloud stream so here are the

00:27:37,929 --> 00:27:42,520
semantics is very similar we still have

00:27:40,030 --> 00:27:44,230
an ad set but we couple each element

00:27:42,520 --> 00:27:46,059
with a piece of metadata which you can

00:27:44,230 --> 00:27:48,340
consider a score it's actually the

00:27:46,059 --> 00:27:49,990
timestamp I'll just have them as

00:27:48,340 --> 00:27:51,880
integers here for simplicity there's

00:27:49,990 --> 00:27:53,350
still a remove set exactly the same

00:27:51,880 --> 00:27:57,039
thing and we still do the same semantic

00:27:53,350 --> 00:28:00,669
merging but these timestamp metod it has

00:27:57,039 --> 00:28:05,500
give us a bonus feature or a set of

00:28:00,669 --> 00:28:09,460
bonus features so asn't just to make it

00:28:05,500 --> 00:28:11,640
clear what these things mean the the set

00:28:09,460 --> 00:28:14,260
key the logical set name would be the

00:28:11,640 --> 00:28:15,789
the user ID for whom the out box

00:28:14,260 --> 00:28:19,830
represents so for example Snoop Dogg's

00:28:15,789 --> 00:28:23,500
outbox the elements in that set or a

00:28:19,830 --> 00:28:25,330
unique combination of the actor the

00:28:23,500 --> 00:28:27,250
thing that was done and the identifier

00:28:25,330 --> 00:28:28,630
so this is actually the unique thing

00:28:27,250 --> 00:28:33,100
that should only appear once in any

00:28:28,630 --> 00:28:35,860
given stream and then the extra piece of

00:28:33,100 --> 00:28:40,929
metadata the score is the timestamp of

00:28:35,860 --> 00:28:42,429
the event as it was done ok so if that's

00:28:40,929 --> 00:28:45,250
our data model then reading is easy you

00:28:42,429 --> 00:28:46,470
just read the two sets you'd perform the

00:28:45,250 --> 00:28:51,179
semantic marriage and then you're done

00:28:46,470 --> 00:28:51,179
what's interesting is writing and

00:28:51,450 --> 00:28:55,720
particularly what's interesting is

00:28:53,140 --> 00:28:59,610
writing while ensuring these asset to

00:28:55,720 --> 00:29:02,440
point o calm semantics are maintained so

00:28:59,610 --> 00:29:05,140
to consider the insert operation answer

00:29:02,440 --> 00:29:10,060
it is always key element score here's

00:29:05,140 --> 00:29:13,540
how it works if either the ad set or the

00:29:10,060 --> 00:29:16,570
remove set for that key already contains

00:29:13,540 --> 00:29:18,340
the element then you look at it and if

00:29:16,570 --> 00:29:20,380
the existing score is greater than or

00:29:18,340 --> 00:29:22,060
equal to the score that you're trying to

00:29:20,380 --> 00:29:26,050
put in the score you're trying to insert

00:29:22,060 --> 00:29:27,640
it then it's a no op and you exit this

00:29:26,050 --> 00:29:31,030
means that if you insert an older

00:29:27,640 --> 00:29:33,070
elements into your sets then it doesn't

00:29:31,030 --> 00:29:36,940
beat the existing element so it's kind

00:29:33,070 --> 00:29:38,920
of dropped on the floor otherwise you

00:29:36,940 --> 00:29:41,920
insert the incoming element into your ad

00:29:38,920 --> 00:29:43,120
set and you delete any matching element

00:29:41,920 --> 00:29:44,950
from the delete set and in this way

00:29:43,120 --> 00:29:50,470
ensure that each element each unique

00:29:44,950 --> 00:29:52,330
thing only exists once in this outbox ok

00:29:50,470 --> 00:29:54,490
that's insert you can imagine delete is

00:29:52,330 --> 00:29:57,040
actually exactly the same thing except

00:29:54,490 --> 00:29:58,690
you swap inserting into the ad set with

00:29:57,040 --> 00:30:02,530
inserting into the delete set and vice

00:29:58,690 --> 00:30:07,300
versa ok that's a bit abstract let's

00:30:02,530 --> 00:30:09,400
look at an example let's consider that

00:30:07,300 --> 00:30:12,520
this is our current state we have a set

00:30:09,400 --> 00:30:16,630
s consider it Snoop Dogg's outbox he has

00:30:12,520 --> 00:30:19,330
ADD set elements a and B with scores of

00:30:16,630 --> 00:30:21,370
one and two delete set helmets he score

00:30:19,330 --> 00:30:24,490
of three and here comes a write

00:30:21,370 --> 00:30:26,380
operation answer D for show of hands who

00:30:24,490 --> 00:30:30,580
knows what happens where does it go

00:30:26,380 --> 00:30:32,560
where does it go that's plus correct

00:30:30,580 --> 00:30:35,260
bonus point you get a t-shirt you

00:30:32,560 --> 00:30:36,550
already have a t-shirt ok that's clear

00:30:35,260 --> 00:30:39,460
right because D doesn't exist anywhere

00:30:36,550 --> 00:30:40,750
it can go into the ad set cool here

00:30:39,460 --> 00:30:44,860
comes to know it's the same operation

00:30:40,750 --> 00:30:46,540
again what happens right it detects it's

00:30:44,860 --> 00:30:50,400
there the score doesn't beat it so it's

00:30:46,540 --> 00:30:54,370
a no op in no state change insert d3

00:30:50,400 --> 00:30:58,720
correct d3 does not beat d4 no stay

00:30:54,370 --> 00:31:00,640
change delete d3 like a broken record

00:30:58,720 --> 00:31:05,620
that's right we checked both sets

00:31:00,640 --> 00:31:08,860
because d3 doesn't bd4 similarly delete

00:31:05,620 --> 00:31:13,100
d4 it doesn't beat the existing store so

00:31:08,860 --> 00:31:17,240
it's a no op haha but d5 hopeful

00:31:13,100 --> 00:31:20,299
not a--not up so we check both sets we

00:31:17,240 --> 00:31:23,120
see d exists but five beats four so five

00:31:20,299 --> 00:31:26,059
kills 4 D 5 goes into the delete set and

00:31:23,120 --> 00:31:30,140
now this is our state if we had an

00:31:26,059 --> 00:31:33,470
uncertainty 5 d 5 does not beat t5 so

00:31:30,140 --> 00:31:36,980
it's a no op but a delete d6 would have

00:31:33,470 --> 00:31:42,230
the effect of updating the score on that

00:31:36,980 --> 00:31:43,880
element ok so that's how it feels right

00:31:42,230 --> 00:31:46,400
everyone kind of like understand how

00:31:43,880 --> 00:31:47,570
that works and it looks pretty good on

00:31:46,400 --> 00:31:48,770
keynote slides but the question now is

00:31:47,570 --> 00:31:51,350
we have to make it real we have to make

00:31:48,770 --> 00:31:54,380
it perform so let's talk about making it

00:31:51,350 --> 00:31:56,900
real and the question was do we need to

00:31:54,380 --> 00:31:58,789
write new software to implement these

00:31:56,900 --> 00:32:01,400
kind of set semantics and the script out

00:31:58,789 --> 00:32:03,140
is I described and it turns out we don't

00:32:01,400 --> 00:32:05,990
it turns out that there's this thing in

00:32:03,140 --> 00:32:09,289
the world called Redis and Redis is a

00:32:05,990 --> 00:32:12,289
data structure server not to be confused

00:32:09,289 --> 00:32:13,789
with the database and Retta supports

00:32:12,289 --> 00:32:17,360
directly something called a sorted set

00:32:13,789 --> 00:32:19,340
AZ set which provides exactly the

00:32:17,360 --> 00:32:21,890
semantics we want its add remove get the

00:32:19,340 --> 00:32:24,380
score retta's also has this atomic Lua

00:32:21,890 --> 00:32:25,280
scripting so that's really cool so we

00:32:24,380 --> 00:32:28,220
can safely implement our write

00:32:25,280 --> 00:32:30,890
operations but our data set is large

00:32:28,220 --> 00:32:32,240
revis is an in-memory server and so we

00:32:30,890 --> 00:32:34,490
don't fit the whole data set into one

00:32:32,240 --> 00:32:36,230
reticence tins so naturally we do what

00:32:34,490 --> 00:32:37,610
most people do and we shard rightist

00:32:36,230 --> 00:32:39,590
instances and this actually works really

00:32:37,610 --> 00:32:41,000
great because we have a natural shard

00:32:39,590 --> 00:32:44,390
key every operation is always based

00:32:41,000 --> 00:32:46,669
around this set ID set a name and we can

00:32:44,390 --> 00:32:48,980
hash that and do really nice easy

00:32:46,669 --> 00:32:51,620
sharting at the application layer so we

00:32:48,980 --> 00:32:52,970
wrote a very simple library sit in front

00:32:51,620 --> 00:32:55,250
of a bunch of Redis instances do that

00:32:52,970 --> 00:32:58,429
charting for us and on top of that we

00:32:55,250 --> 00:33:00,080
wrote something called cluster and that

00:32:58,429 --> 00:33:05,809
provides us a very simple insert delete

00:33:00,080 --> 00:33:07,309
select API on top of the shard API ok

00:33:05,809 --> 00:33:09,320
but remember this still represents a

00:33:07,309 --> 00:33:11,750
single logical node in our distributed

00:33:09,320 --> 00:33:13,520
system and by that I mean that Snoop

00:33:11,750 --> 00:33:16,010
Dogg's outbox only appears once in all

00:33:13,520 --> 00:33:18,080
of these boxes so in order for this to

00:33:16,010 --> 00:33:20,059
be a nice reliable distributed system we

00:33:18,080 --> 00:33:23,360
want to replicate this picture and

00:33:20,059 --> 00:33:26,269
indeed that's what we do as many times

00:33:23,360 --> 00:33:27,409
as you want to replicate this stack

00:33:26,269 --> 00:33:29,209
and what's interesting about this

00:33:27,409 --> 00:33:32,239
architecture is that none of these

00:33:29,209 --> 00:33:33,859
components talk to each other right none

00:33:32,239 --> 00:33:35,359
of the Redis is talk to each other none

00:33:33,859 --> 00:33:38,539
of these cluster stacks talk to each

00:33:35,359 --> 00:33:40,369
other and in this way it's I think a bit

00:33:38,539 --> 00:33:42,409
of a different architecture than you see

00:33:40,369 --> 00:33:44,179
in a lot of distributed systems where

00:33:42,409 --> 00:33:47,539
the nodes will kind of gossip with each

00:33:44,179 --> 00:33:51,469
other I'm going to argue that this makes

00:33:47,539 --> 00:33:53,929
this system better more reliable easy to

00:33:51,469 --> 00:33:55,489
your easier to understand easier to

00:33:53,929 --> 00:33:59,469
reason about because it exposes it to

00:33:55,489 --> 00:34:02,299
fewer modes of failure okay so we have

00:33:59,469 --> 00:34:04,089
finally this final layer which

00:34:02,299 --> 00:34:07,459
communicates with all the clusters and

00:34:04,089 --> 00:34:09,260
we package the farm the clusters in the

00:34:07,459 --> 00:34:11,240
pool into a single binary stateless

00:34:09,260 --> 00:34:13,700
binary which communicates with all of

00:34:11,240 --> 00:34:16,210
the stateful reddest instances so we can

00:34:13,700 --> 00:34:18,770
do horizontal scaling with this binary

00:34:16,210 --> 00:34:22,520
talking to the stateless stateful layer

00:34:18,770 --> 00:34:24,139
and that's basically our system so at

00:34:22,520 --> 00:34:25,819
this high level writing is very easy

00:34:24,139 --> 00:34:28,190
every write operation should be sent to

00:34:25,819 --> 00:34:30,740
every cluster because that's what you

00:34:28,190 --> 00:34:32,359
want straightforward but reading is

00:34:30,740 --> 00:34:34,909
interesting here because we have options

00:34:32,359 --> 00:34:38,240
when a read request hits the farm layer

00:34:34,909 --> 00:34:40,129
what do you do well the easiest thing to

00:34:38,240 --> 00:34:42,319
do is just to send it to one cluster

00:34:40,129 --> 00:34:44,240
pick randomly shore and return the

00:34:42,319 --> 00:34:45,799
result directly this is cool it's easy

00:34:44,240 --> 00:34:47,569
to understand it's fast you only have

00:34:45,799 --> 00:34:49,220
one network round trip but you only get

00:34:47,569 --> 00:34:51,619
one response back and if that cluster

00:34:49,220 --> 00:34:53,149
happens to be out of sync inconsistent

00:34:51,619 --> 00:34:56,960
we have no way to know we just have to

00:34:53,149 --> 00:34:59,480
return the data back the alternative is

00:34:56,960 --> 00:35:00,589
to send it to all the clusters we can do

00:34:59,480 --> 00:35:03,109
this kind of efficiently we can do a

00:35:00,589 --> 00:35:07,309
scatter gather that bounds us to the

00:35:03,109 --> 00:35:11,539
slowest of the three in this case but it

00:35:07,309 --> 00:35:14,779
means that we get multiple responses

00:35:11,539 --> 00:35:15,980
back and remember these are sets that

00:35:14,779 --> 00:35:18,589
are coming back so we can do interesting

00:35:15,980 --> 00:35:19,839
things with that let's say this is what

00:35:18,589 --> 00:35:21,770
we got back from such a request

00:35:19,839 --> 00:35:23,630
everything looks good except as last

00:35:21,770 --> 00:35:27,430
cluster apparently missed the B element

00:35:23,630 --> 00:35:30,950
somehow so that means it's inconsistent

00:35:27,430 --> 00:35:32,809
what do we do well you can Union all of

00:35:30,950 --> 00:35:34,130
these responses and this is what you get

00:35:32,809 --> 00:35:37,220
and it's interesting that this is

00:35:34,130 --> 00:35:39,619
actually the correct response right this

00:35:37,220 --> 00:35:42,289
is this is this is what is provable

00:35:39,619 --> 00:35:43,549
be totally correct and it turns out if

00:35:42,289 --> 00:35:45,380
you think about it as long as each

00:35:43,549 --> 00:35:48,140
cluster has representation for each

00:35:45,380 --> 00:35:50,359
element at least once at least once then

00:35:48,140 --> 00:35:52,819
the union is going to be the overall

00:35:50,359 --> 00:35:54,019
correct response and that's cool we can

00:35:52,819 --> 00:35:55,819
send that back to the client he doesn't

00:35:54,019 --> 00:35:57,829
see the inconsistency there's another

00:35:55,819 --> 00:36:00,019
operation and set world called I think a

00:35:57,829 --> 00:36:01,099
symmetric difference which selects the

00:36:00,019 --> 00:36:03,109
things which aren't in perfect agreement

00:36:01,099 --> 00:36:06,740
across all the sets in this case it's

00:36:03,109 --> 00:36:09,319
the element B and knowing that we can

00:36:06,740 --> 00:36:11,569
then compare we can ask each cluster

00:36:09,319 --> 00:36:13,579
what do you know about the element B get

00:36:11,569 --> 00:36:15,559
responses back compare the responses

00:36:13,579 --> 00:36:18,619
based on the scores we can determine

00:36:15,559 --> 00:36:20,599
which one is the most correct and then

00:36:18,619 --> 00:36:21,950
perform a diff against the responses we

00:36:20,599 --> 00:36:23,539
got back and then reissue write

00:36:21,950 --> 00:36:25,549
operations to the clusters that were

00:36:23,539 --> 00:36:27,349
inconsistent so this is very similar to

00:36:25,549 --> 00:36:30,200
Cassandra read repair in fact it's

00:36:27,349 --> 00:36:32,119
called read repair and so what we can do

00:36:30,200 --> 00:36:34,519
then is build this hybrid read strategy

00:36:32,119 --> 00:36:36,259
where we send the request to all the

00:36:34,519 --> 00:36:38,779
clusters we return the first one that

00:36:36,259 --> 00:36:40,460
comes back maybe it's inconsistent but

00:36:38,779 --> 00:36:42,319
we linger around and we receive all the

00:36:40,460 --> 00:36:45,890
responses from the other clusters we

00:36:42,319 --> 00:36:47,210
perform this diff and when we see that

00:36:45,890 --> 00:36:48,619
there's anything inconsistent we send

00:36:47,210 --> 00:36:51,170
the right operations all asynchronously

00:36:48,619 --> 00:36:53,930
and in this way the system kind of

00:36:51,170 --> 00:36:56,660
becomes self repairing assuming you have

00:36:53,930 --> 00:36:58,700
sufficient read volume so that's like

00:36:56,660 --> 00:37:02,599
the incredibly fast five minute overview

00:36:58,700 --> 00:37:04,640
of this production crdt system the full

00:37:02,599 --> 00:37:06,619
thing is totally open source we recently

00:37:04,640 --> 00:37:08,779
did a blog post you can go to this

00:37:06,619 --> 00:37:10,130
website we spent a lot of time building

00:37:08,779 --> 00:37:12,980
a readme that I hope is easy to

00:37:10,130 --> 00:37:15,799
understand the whole project is written

00:37:12,980 --> 00:37:18,650
and go except for the reddest bit it's

00:37:15,799 --> 00:37:21,559
about 2500 lines altogether so not that

00:37:18,650 --> 00:37:23,779
big easy to understand I hope and we're

00:37:21,559 --> 00:37:25,059
in the process of rolling it out to

00:37:23,779 --> 00:37:28,519
serve this dream to all of our users

00:37:25,059 --> 00:37:32,299
we've load tested it very significantly

00:37:28,519 --> 00:37:33,589
to several orders of magnitude growth

00:37:32,299 --> 00:37:35,569
beyond what we currently have several

00:37:33,589 --> 00:37:37,279
years of exponential growth ahead so

00:37:35,569 --> 00:37:39,109
we're very confident so this is a real

00:37:37,279 --> 00:37:41,599
deal right it's a production crdt system

00:37:39,109 --> 00:37:45,109
built from first principles simple and

00:37:41,599 --> 00:37:46,430
fast take a look okay conclusions I

00:37:45,109 --> 00:37:50,089
think I still have two minutes i think i

00:37:46,430 --> 00:37:52,460
am ok cool so consistency without

00:37:50,089 --> 00:37:54,740
consensus current best

00:37:52,460 --> 00:37:57,200
option available in the field of

00:37:54,740 --> 00:38:01,099
distributed systems is the crdt learn it

00:37:57,200 --> 00:38:03,230
know it love it taking a step back

00:38:01,099 --> 00:38:04,640
speaking a bit more generally every time

00:38:03,230 --> 00:38:05,900
you write software you have to deal with

00:38:04,640 --> 00:38:06,950
invariants whether they come from the

00:38:05,900 --> 00:38:10,369
business world or whether they come from

00:38:06,950 --> 00:38:12,010
like the structure the the grid of the

00:38:10,369 --> 00:38:14,960
technology that you build on top of and

00:38:12,010 --> 00:38:18,200
it's a fool's errand time arguing to try

00:38:14,960 --> 00:38:20,420
to code them away rather you should

00:38:18,200 --> 00:38:22,190
embrace them you should acknowledge them

00:38:20,420 --> 00:38:24,020
as first order things and you should

00:38:22,190 --> 00:38:25,940
bend what you're trying to do to them

00:38:24,020 --> 00:38:28,250
rather than trying to abstract them away

00:38:25,940 --> 00:38:33,440
I think this is the lesson of successful

00:38:28,250 --> 00:38:36,349
distributed programming and I've just

00:38:33,440 --> 00:38:37,970
said that so I won't say it again that's

00:38:36,349 --> 00:38:39,349
basically a thank you so much I work for

00:38:37,970 --> 00:38:40,790
soundcloud if you want to work on hard

00:38:39,349 --> 00:38:43,730
problems like this we're hiring there's

00:38:40,790 --> 00:38:45,170
the website and maybe I have like time

00:38:43,730 --> 00:38:47,589
for one or two quick questions but thank

00:38:45,170 --> 00:38:47,589
you very much

00:38:55,320 --> 00:39:05,860
anybody 20 sorry there's two Pete

00:39:04,510 --> 00:39:10,630
there's one guy right behind you is like

00:39:05,860 --> 00:39:12,550
oh okay how do you ensure that the time

00:39:10,630 --> 00:39:15,010
stamps are consistent or that they are

00:39:12,550 --> 00:39:17,110
monotonically increasing yes different

00:39:15,010 --> 00:39:18,160
clusters yeah so this is the question

00:39:17,110 --> 00:39:19,480
was how do you ensure the time stamps

00:39:18,160 --> 00:39:21,550
are consistent indeed this is the

00:39:19,480 --> 00:39:24,160
problem that I've totally like glassed

00:39:21,550 --> 00:39:26,350
over the way we built the system was

00:39:24,160 --> 00:39:29,010
that all of the events are coming from

00:39:26,350 --> 00:39:31,660
kind of some source in the distance and

00:39:29,010 --> 00:39:33,100
the assumption in the system is that the

00:39:31,660 --> 00:39:34,510
time stamps that come with the events

00:39:33,100 --> 00:39:37,200
and they then they do come with the

00:39:34,510 --> 00:39:40,300
events are correct so if that's not true

00:39:37,200 --> 00:39:42,280
we're totally subservient to those time

00:39:40,300 --> 00:39:43,750
stamps and that is definitely a cheat in

00:39:42,280 --> 00:39:45,490
the system there's this whole field to

00:39:43,750 --> 00:39:47,620
study like Lamport clocks vector clocks

00:39:45,490 --> 00:39:49,030
that deal with exactly this problem we

00:39:47,620 --> 00:39:51,370
chose not to address it in this and this

00:39:49,030 --> 00:39:53,500
in the system and like exported that

00:39:51,370 --> 00:39:59,410
complexity to the producer side of the

00:39:53,500 --> 00:40:02,290
system cool okay so I go what do you do

00:39:59,410 --> 00:40:04,840
if one of your clusters is so

00:40:02,290 --> 00:40:07,150
inconsistent that it's not acceptable

00:40:04,840 --> 00:40:09,670
for the user so maybe you put up a new

00:40:07,150 --> 00:40:12,130
note it's empty I mean it would repair

00:40:09,670 --> 00:40:15,970
itself but you can't give that to the

00:40:12,130 --> 00:40:18,040
user it might be annoyed yeah so this is

00:40:15,970 --> 00:40:19,870
an interesting case you can't give it to

00:40:18,040 --> 00:40:21,550
the user and in this hybrid mode that I

00:40:19,870 --> 00:40:23,680
showed at the end you couldn't return

00:40:21,550 --> 00:40:25,210
that right away so we hope in the

00:40:23,680 --> 00:40:26,920
general case of the operation of the

00:40:25,210 --> 00:40:29,710
system no cluster falls into this state

00:40:26,920 --> 00:40:31,600
but one interesting way of growing the

00:40:29,710 --> 00:40:33,580
system is indeed to boot up an empty

00:40:31,600 --> 00:40:36,520
cluster and let read repair just kind of

00:40:33,580 --> 00:40:38,470
fill it in overtime and this works great

00:40:36,520 --> 00:40:41,320
except you have to put a kind of a flag

00:40:38,470 --> 00:40:43,810
on that cluster and you have to say this

00:40:41,320 --> 00:40:45,190
cluster can receive write operations but

00:40:43,810 --> 00:40:47,200
it you should never serve read

00:40:45,190 --> 00:40:49,300
operations from it directly and so

00:40:47,200 --> 00:40:51,780
that's kind of how we do with it we

00:40:49,300 --> 00:40:54,850
could have a way of like dynamically

00:40:51,780 --> 00:40:56,800
deducing error rates from cluster by

00:40:54,850 --> 00:40:58,900
cluster basis and at some threshold like

00:40:56,800 --> 00:41:01,630
kick it out we don't currently do that

00:40:58,900 --> 00:41:03,840
but that could be possible yeah okay I

00:41:01,630 --> 00:41:05,900
think that's time thanks again

00:41:03,840 --> 00:41:05,900

YouTube URL: https://www.youtube.com/watch?v=U6xLcIf1Qlw


