Title: Berlin Buzzwords 2014: Neha Narula - Consensus and Consistency - Why should I care? #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	We've all heard about the infamous CAP theorem, and how it's impossible to "beat". But what does that really mean? Should we throw down our keyboards and give up on running a distributed system?

This talk will discuss consensus protocols, the actual definitions of every letter in that acronym, and what real issues come up when it comes to running a performant, correct, distributed system. If you've ever wondered why Paxos has to be so complicated or what "partition tolerance" really means this talk is for you.

Read more:
https://2014.berlinbuzzwords.de/session/consensus-and-consistency-why-should-i-care

About Neha Narula:
https://2014.berlinbuzzwords.de/user/324/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,080 --> 00:00:11,940
okay hi hello everyone so my name is

00:00:09,299 --> 00:00:15,209
Neha narula and I'm a PhD student at MIT

00:00:11,940 --> 00:00:17,880
and I'm here to talk about consensus and

00:00:15,209 --> 00:00:20,759
consistency so first a little bit about

00:00:17,880 --> 00:00:22,619
me in former life I was a software

00:00:20,759 --> 00:00:23,699
engineer at Google and I worked on a

00:00:22,619 --> 00:00:25,769
bunch of different products there

00:00:23,699 --> 00:00:27,480
including a shopping website which we

00:00:25,769 --> 00:00:30,390
launched in Germany that was fun frugal

00:00:27,480 --> 00:00:32,879
um and a storage system for large binary

00:00:30,390 --> 00:00:36,900
objects and then for the past six years

00:00:32,879 --> 00:00:38,159
I've been a PhD student at MIT and while

00:00:36,900 --> 00:00:40,739
a bit at MIT have been working on

00:00:38,159 --> 00:00:42,540
systems and more specifically been

00:00:40,739 --> 00:00:45,659
focused on systems which make various

00:00:42,540 --> 00:00:47,940
consistency trade-offs so specifically I

00:00:45,659 --> 00:00:50,309
worked on a distributed query executor

00:00:47,940 --> 00:00:54,119
so for sequel databases I worked on a

00:00:50,309 --> 00:00:55,830
cache which stores precomputed data and

00:00:54,119 --> 00:00:57,570
most recently I've been working on a

00:00:55,830 --> 00:01:01,019
concurrency control mechanism for

00:00:57,570 --> 00:01:02,489
multi-core databases so what this talk

00:01:01,019 --> 00:01:04,860
is going to be about it's going to be

00:01:02,489 --> 00:01:06,210
about consistency okay and specifically

00:01:04,860 --> 00:01:07,530
why we need it so I'm going to try to

00:01:06,210 --> 00:01:09,119
make an argument to you the consistency

00:01:07,530 --> 00:01:11,039
is important and that we shouldn't just

00:01:09,119 --> 00:01:12,539
throw it out the window I'm going to

00:01:11,039 --> 00:01:15,329
talk briefly about the different types

00:01:12,539 --> 00:01:16,799
of consistency and then get into the

00:01:15,329 --> 00:01:19,799
problem of consensus which is

00:01:16,799 --> 00:01:21,899
distributed consistency finally speak a

00:01:19,799 --> 00:01:25,049
bit about the cap theorem and what it

00:01:21,899 --> 00:01:27,719
actually means and then finally give a

00:01:25,049 --> 00:01:30,240
little bit of a few thoughts on how I

00:01:27,719 --> 00:01:32,450
think we should actually deal with all

00:01:30,240 --> 00:01:35,640
this and what we should do going forward

00:01:32,450 --> 00:01:37,499
so okay consistency well the way that I

00:01:35,640 --> 00:01:39,810
like to think about it is when you're

00:01:37,499 --> 00:01:42,240
building your application how bad can

00:01:39,810 --> 00:01:43,890
things get and that is your answer to

00:01:42,240 --> 00:01:46,560
what kind of consistency you're willing

00:01:43,890 --> 00:01:49,439
to deal with um so here's a very classic

00:01:46,560 --> 00:01:51,539
example this is a comments on an unnamed

00:01:49,439 --> 00:01:53,310
social network and what has happened

00:01:51,539 --> 00:01:55,319
here is this guy posted a comment and

00:01:53,310 --> 00:01:56,969
it's somehow appeared four times it

00:01:55,319 --> 00:01:58,590
turned into many comments and so there's

00:01:56,969 --> 00:02:00,780
many different reasons why this could

00:01:58,590 --> 00:02:03,509
have happened maybe an application web

00:02:00,780 --> 00:02:05,009
server didn't get a reply saying the

00:02:03,509 --> 00:02:06,689
comment had been received successfully

00:02:05,009 --> 00:02:09,539
and so it kept trying over and over

00:02:06,689 --> 00:02:12,569
again maybe for some reason this guy's

00:02:09,539 --> 00:02:14,010
request went to one data center and then

00:02:12,569 --> 00:02:15,010
failed and then went to another data

00:02:14,010 --> 00:02:16,599
center and then

00:02:15,010 --> 00:02:19,200
another one and this is how they got

00:02:16,599 --> 00:02:21,189
reconciled together you know this is a

00:02:19,200 --> 00:02:24,430
reconciliation technique issue just

00:02:21,189 --> 00:02:25,450
merge all of the rights um and then you

00:02:24,430 --> 00:02:27,040
know the point here though is that

00:02:25,450 --> 00:02:29,019
what's happening is the datastore is

00:02:27,040 --> 00:02:30,220
happily taking each of these as a new

00:02:29,019 --> 00:02:32,140
comment and that is not what the

00:02:30,220 --> 00:02:33,760
application intended but this is pretty

00:02:32,140 --> 00:02:37,120
innocuous right I mean you know who

00:02:33,760 --> 00:02:39,069
cares if I don't get the message that my

00:02:37,120 --> 00:02:40,299
mom liked my status on facebook this is

00:02:39,069 --> 00:02:42,370
not the end of the world these are

00:02:40,299 --> 00:02:43,870
social networks right but what about

00:02:42,370 --> 00:02:45,970
more critical applications on the web

00:02:43,870 --> 00:02:49,030
for example let's say we had a

00:02:45,970 --> 00:02:52,150
completely decentralized currency where

00:02:49,030 --> 00:02:55,000
there's no way to undo transfers um in

00:02:52,150 --> 00:02:57,099
situations of fraud as an example so

00:02:55,000 --> 00:02:58,690
remember how in the news recently have

00:02:57,099 --> 00:03:00,670
you guys heard about how a lot of

00:02:58,690 --> 00:03:02,319
Bitcoin exchanges have been going under

00:03:00,670 --> 00:03:04,810
is that is that something you guys know

00:03:02,319 --> 00:03:06,519
about right um you know lots of times

00:03:04,810 --> 00:03:08,409
because they suffer some sort of attack

00:03:06,519 --> 00:03:11,799
some kind of hacker hacking attack and

00:03:08,409 --> 00:03:13,030
they someone transfers out a large

00:03:11,799 --> 00:03:15,370
amount of Bitcoin into their own

00:03:13,030 --> 00:03:16,720
personal wallets well I've been looking

00:03:15,370 --> 00:03:18,730
into this a little bit and I found an

00:03:16,720 --> 00:03:20,230
interesting example you know usually

00:03:18,730 --> 00:03:22,449
these are described as security attacks

00:03:20,230 --> 00:03:23,949
like the security on the website wasn't

00:03:22,449 --> 00:03:25,750
good enough but here's what happened in

00:03:23,949 --> 00:03:28,780
at least one case and this is with an

00:03:25,750 --> 00:03:30,639
exchange called polini X and this is a

00:03:28,780 --> 00:03:33,430
quote from an ARS technica article and

00:03:30,639 --> 00:03:35,530
the quote says the hacker discovered

00:03:33,430 --> 00:03:38,199
that multiple simultaneous withdrawals

00:03:35,530 --> 00:03:40,090
are processed essentially at the same

00:03:38,199 --> 00:03:41,799
time and that the system software

00:03:40,090 --> 00:03:45,250
doesn't check quickly enough for a

00:03:41,799 --> 00:03:47,470
negative balance so this is not a

00:03:45,250 --> 00:03:50,410
security problem to me this is a very

00:03:47,470 --> 00:03:51,970
classic transaction problem this what

00:03:50,410 --> 00:03:53,349
you want here is you want to be able to

00:03:51,970 --> 00:03:55,239
do the check and the decrement

00:03:53,349 --> 00:03:57,849
atomically you want them to happen

00:03:55,239 --> 00:03:59,500
together and for whatever reason I don't

00:03:57,849 --> 00:04:01,930
know the details of this implementation

00:03:59,500 --> 00:04:03,730
that wasn't happening but we know how to

00:04:01,930 --> 00:04:07,359
build systems that do this this is not

00:04:03,730 --> 00:04:09,190
an unsolved problem and that's the point

00:04:07,359 --> 00:04:11,650
of consistency consistency guarantees

00:04:09,190 --> 00:04:15,879
help us reason about our code and avoid

00:04:11,650 --> 00:04:17,919
subtle bugs um so the word consistency

00:04:15,879 --> 00:04:19,959
unfortunately has come to mean so many

00:04:17,919 --> 00:04:21,459
different things in computer science I

00:04:19,959 --> 00:04:25,810
think it's one of the most misused words

00:04:21,459 --> 00:04:28,510
ever so there's the sea in acid so

00:04:25,810 --> 00:04:31,610
consistent acid stands for atomic

00:04:28,510 --> 00:04:33,400
consistent isolation and durable and it

00:04:31,610 --> 00:04:35,450
describes transactions in a database

00:04:33,400 --> 00:04:38,240
these are the four properties that

00:04:35,450 --> 00:04:40,760
transaction should preserve and when you

00:04:38,240 --> 00:04:42,919
see the sea and acid that's actually a

00:04:40,760 --> 00:04:45,200
very specific type of consistency what

00:04:42,919 --> 00:04:46,730
that means is that once a transaction

00:04:45,200 --> 00:04:49,820
completes the database should be in a

00:04:46,730 --> 00:04:51,770
consistent state and that is dependent

00:04:49,820 --> 00:04:53,750
upon whatever the application developer

00:04:51,770 --> 00:04:57,260
decides the consistent state is like as

00:04:53,750 --> 00:05:00,380
an example maybe some key value should

00:04:57,260 --> 00:05:01,880
never go below zero and so if a database

00:05:00,380 --> 00:05:03,950
is consistent and you write your

00:05:01,880 --> 00:05:05,690
transactions correctly as a developer

00:05:03,950 --> 00:05:07,760
then that means that at the end of every

00:05:05,690 --> 00:05:09,229
transaction the guarantee will be

00:05:07,760 --> 00:05:11,570
maintained that a balance never went

00:05:09,229 --> 00:05:13,070
below zero but it that's like a very

00:05:11,570 --> 00:05:17,000
specific type of consistency that

00:05:13,070 --> 00:05:18,530
involves application constraints then

00:05:17,000 --> 00:05:20,530
there's consistency as in the cap

00:05:18,530 --> 00:05:23,660
theorem ok so this stands for

00:05:20,530 --> 00:05:26,900
consistency availability and partition

00:05:23,660 --> 00:05:30,500
tolerance and this is consistency in the

00:05:26,900 --> 00:05:32,330
case of multiple servers so the previous

00:05:30,500 --> 00:05:34,400
one we can talk about consistency in the

00:05:32,330 --> 00:05:36,110
case of one server too so in one server

00:05:34,400 --> 00:05:37,820
we can totally screw things up and not

00:05:36,110 --> 00:05:40,250
have consistency so the cap theorem

00:05:37,820 --> 00:05:41,840
really addresses really relies in the

00:05:40,250 --> 00:05:44,690
definition of consistency that applies

00:05:41,840 --> 00:05:45,890
to many servers and what it means is

00:05:44,690 --> 00:05:47,660
that what it's essentially saying at a

00:05:45,890 --> 00:05:51,080
high level is to maintain consistency

00:05:47,660 --> 00:05:53,360
you may have to halt perhaps

00:05:51,080 --> 00:05:55,090
indefinitely instead of just going ahead

00:05:53,360 --> 00:05:57,440
and processing or reading the right

00:05:55,090 --> 00:05:59,840
we'll get we'll get more into this later

00:05:57,440 --> 00:06:01,580
um and then finally there's many

00:05:59,840 --> 00:06:03,919
different types of consistency with

00:06:01,580 --> 00:06:07,070
varying guarantees and really what all

00:06:03,919 --> 00:06:09,830
of them are trying to describe are an

00:06:07,070 --> 00:06:12,020
execution of reads and writes and what

00:06:09,830 --> 00:06:14,900
is valid to be returned so if you issue

00:06:12,020 --> 00:06:18,680
some reads and writes to a system what

00:06:14,900 --> 00:06:20,300
are valid results so um you know a lot

00:06:18,680 --> 00:06:22,419
of people think the mechanisms to

00:06:20,300 --> 00:06:25,039
enforce consistency are too strong and

00:06:22,419 --> 00:06:27,229
that it's not worth building it into our

00:06:25,039 --> 00:06:29,360
systems but actually you know there's a

00:06:27,229 --> 00:06:31,639
mechanism at work enforcing consistency

00:06:29,360 --> 00:06:33,950
on every single reading right of every

00:06:31,639 --> 00:06:37,190
single computer and that is cache

00:06:33,950 --> 00:06:39,320
coherence so cache coherence is provided

00:06:37,190 --> 00:06:41,870
by our hardware and the idea is that our

00:06:39,320 --> 00:06:44,870
hardware is automatically keeping

00:06:41,870 --> 00:06:47,420
individual processors l1 caches up to

00:06:44,870 --> 00:06:48,740
date and keeping them consistent as

00:06:47,420 --> 00:06:50,570
they've read and write from central

00:06:48,740 --> 00:06:52,490
memory and as we move into the age of

00:06:50,570 --> 00:06:54,380
multi-core these caches become more and

00:06:52,490 --> 00:06:55,880
more important it becomes very important

00:06:54,380 --> 00:06:57,800
that processors can access caches

00:06:55,880 --> 00:06:59,590
locally and read and write data locally

00:06:57,800 --> 00:07:01,490
because memory accessing memory can be

00:06:59,590 --> 00:07:04,700
hundreds of thousands of times more

00:07:01,490 --> 00:07:06,680
expensive um has anyone here ever tried

00:07:04,700 --> 00:07:10,550
to program a system without cache

00:07:06,680 --> 00:07:11,960
coherence yeah I think it would be a

00:07:10,550 --> 00:07:15,680
nightmare I think it would be absolutely

00:07:11,960 --> 00:07:17,840
horrible um the fact that our Hardware

00:07:15,680 --> 00:07:19,790
provides this for us lets us reason

00:07:17,840 --> 00:07:21,530
about our program and pretend like it's

00:07:19,790 --> 00:07:24,950
running on a single processor and that's

00:07:21,530 --> 00:07:26,960
really important so the type of

00:07:24,950 --> 00:07:30,200
consistency that cache coherence tries

00:07:26,960 --> 00:07:31,400
to provide is sequential consistency so

00:07:30,200 --> 00:07:33,500
you might see this term around and

00:07:31,400 --> 00:07:34,730
actually cache coherence doesn't provide

00:07:33,500 --> 00:07:36,200
this but what's that's like a whole

00:07:34,730 --> 00:07:37,730
nother talk so let's just go with this

00:07:36,200 --> 00:07:40,910
for the moment and what sequential

00:07:37,730 --> 00:07:43,490
consistency means is that the result of

00:07:40,910 --> 00:07:45,920
any execution of reads and writes is as

00:07:43,490 --> 00:07:47,450
though they happened in some order so

00:07:45,920 --> 00:07:50,120
there's some ordering to the reads and

00:07:47,450 --> 00:07:54,710
writes like someone wrote x equals 1 and

00:07:50,120 --> 00:07:56,510
someone read that x equals one and one

00:07:54,710 --> 00:07:58,400
key thing here with sequential consensus

00:07:56,510 --> 00:08:01,010
consistency is that order doesn't have

00:07:58,400 --> 00:08:03,590
to match time and we'll see what that

00:08:01,010 --> 00:08:06,230
means in a bit but order does have to

00:08:03,590 --> 00:08:07,640
match what each processor sees and so

00:08:06,230 --> 00:08:08,900
that means that if multiple processors

00:08:07,640 --> 00:08:11,240
are reading and writing the same

00:08:08,900 --> 00:08:13,040
location in memory and interleaving

00:08:11,240 --> 00:08:14,690
their reads and writes sequential

00:08:13,040 --> 00:08:17,150
consistency says that the processor

00:08:14,690 --> 00:08:19,520
should see the reads and writes in the

00:08:17,150 --> 00:08:22,550
same order and so here's an example okay

00:08:19,520 --> 00:08:27,770
so here we have four processors p1

00:08:22,550 --> 00:08:31,430
through p4 and wxa means write the value

00:08:27,770 --> 00:08:34,100
a 2x + RX a means read the value out of

00:08:31,430 --> 00:08:37,400
X ok and so what's happening here is

00:08:34,100 --> 00:08:40,130
that p one's writing x equals a p2 is

00:08:37,400 --> 00:08:45,380
writing x equals bp3 reads bna and then

00:08:40,130 --> 00:08:46,910
p for reads bna as well so okay based on

00:08:45,380 --> 00:08:51,040
what i said is this sequentially

00:08:46,910 --> 00:08:51,040
consistent what do you guys think

00:08:51,950 --> 00:08:58,550
how many people think it is how many

00:08:55,370 --> 00:09:00,170
people think it isn't oh okay Wow okay

00:08:58,550 --> 00:09:02,390
so actually this is sequentially

00:09:00,170 --> 00:09:04,460
consistent um and I find this incredibly

00:09:02,390 --> 00:09:05,990
confusing as well and the reason it's

00:09:04,460 --> 00:09:08,180
sequentially consistent is because we

00:09:05,990 --> 00:09:10,610
are allowed to reorder things if we want

00:09:08,180 --> 00:09:12,740
to with sequential consistency as long

00:09:10,610 --> 00:09:14,750
as it matches what each process sees and

00:09:12,740 --> 00:09:17,030
it still makes sense with the values

00:09:14,750 --> 00:09:20,150
returned and so what we can do here is

00:09:17,030 --> 00:09:23,660
we can basically pretend like p1

00:09:20,150 --> 00:09:26,210
actually wrote a later and p2 wrote um

00:09:23,660 --> 00:09:27,950
be first and the reason we can do that

00:09:26,210 --> 00:09:29,570
is because p1 and p2 are just sort of

00:09:27,950 --> 00:09:32,120
issuing these rights off into the ether

00:09:29,570 --> 00:09:33,980
you know they have no idea when they're

00:09:32,120 --> 00:09:35,690
right happened they don't do a read to

00:09:33,980 --> 00:09:37,040
actually see that they're right you know

00:09:35,690 --> 00:09:39,410
happened at this point in time at that

00:09:37,040 --> 00:09:40,910
point in time and so under sequential

00:09:39,410 --> 00:09:41,990
consistency we're allowed to reorder

00:09:40,910 --> 00:09:44,090
this and then all of a sudden this

00:09:41,990 --> 00:09:48,170
execution makes sense right be read be

00:09:44,090 --> 00:09:51,350
right a read a um so I I find this

00:09:48,170 --> 00:09:53,270
extremely confusing and yet that's the

00:09:51,350 --> 00:09:55,310
form of consistency most of us operate

00:09:53,270 --> 00:09:57,320
under actually most of our machines most

00:09:55,310 --> 00:09:59,570
of our systems they don't even provide

00:09:57,320 --> 00:10:01,210
that but um but there's this better form

00:09:59,570 --> 00:10:04,190
called external consistency and

00:10:01,210 --> 00:10:07,460
basically this says that results match

00:10:04,190 --> 00:10:08,630
time and so what this means is that you

00:10:07,460 --> 00:10:10,820
can imagine as though you had an

00:10:08,630 --> 00:10:13,640
external observer looking at your system

00:10:10,820 --> 00:10:15,590
from the outside and if an external

00:10:13,640 --> 00:10:16,880
observer reads in your system and sees

00:10:15,590 --> 00:10:19,340
that the value of a variable is

00:10:16,880 --> 00:10:21,740
something that has to be preserved and

00:10:19,340 --> 00:10:24,320
so in this example we can see that it's

00:10:21,740 --> 00:10:25,370
not externally consistent and the reason

00:10:24,320 --> 00:10:27,650
for that is that it makes little

00:10:25,370 --> 00:10:29,540
external observer could come along and

00:10:27,650 --> 00:10:31,580
notice that hey that right to be

00:10:29,540 --> 00:10:33,800
actually happened after the right to a

00:10:31,580 --> 00:10:35,990
in terms of time that is how it happened

00:10:33,800 --> 00:10:37,370
and so then when this happens the

00:10:35,990 --> 00:10:38,960
external observer will note that like

00:10:37,370 --> 00:10:40,460
nothing makes sense well why does it

00:10:38,960 --> 00:10:42,020
look as though the right to be happened

00:10:40,460 --> 00:10:44,360
before the right day and so this

00:10:42,020 --> 00:10:45,950
execution is not externally consistent

00:10:44,360 --> 00:10:48,920
even though it is sequentially

00:10:45,950 --> 00:10:50,300
consistent so I've been talking about

00:10:48,920 --> 00:10:51,950
everything in terms of multiple

00:10:50,300 --> 00:10:53,480
processors on a single machine right now

00:10:51,950 --> 00:10:55,100
but when we move this into the

00:10:53,480 --> 00:10:57,920
distributed setting things get even

00:10:55,100 --> 00:11:01,190
crazier so instead of shared memory all

00:10:57,920 --> 00:11:02,990
we have is communication we have

00:11:01,190 --> 00:11:04,880
replication but we don't have hardware

00:11:02,990 --> 00:11:05,430
cache coherence to help keep replicas

00:11:04,880 --> 00:11:07,350
up-to-date

00:11:05,430 --> 00:11:09,690
and time kind of becomes the fights

00:11:07,350 --> 00:11:11,190
fuzzy concept and so because of this and

00:11:09,690 --> 00:11:14,010
because it's so much harder to deal with

00:11:11,190 --> 00:11:15,060
consistency in this context people have

00:11:14,010 --> 00:11:17,520
introduced the idea of eventual

00:11:15,060 --> 00:11:20,370
consistency the sky from amazon amazon

00:11:17,520 --> 00:11:23,339
CTO werner vogels has written about this

00:11:20,370 --> 00:11:25,550
extensively and the idea here is that if

00:11:23,339 --> 00:11:28,170
no new updates are made to an object

00:11:25,550 --> 00:11:30,959
eventually all accesses will return the

00:11:28,170 --> 00:11:33,360
last updated value and the thing here is

00:11:30,959 --> 00:11:35,070
that actually time like I said it's a

00:11:33,360 --> 00:11:38,220
fuzzy concept in a distributed system so

00:11:35,070 --> 00:11:39,870
who knows what last even means um and

00:11:38,220 --> 00:11:40,980
also this is what always gets me about

00:11:39,870 --> 00:11:43,860
the definition of eventual consistency

00:11:40,980 --> 00:11:45,959
when do we stop writing to things like

00:11:43,860 --> 00:11:47,430
when do we just freeze and let the

00:11:45,959 --> 00:11:48,750
system coalesce I don't think that

00:11:47,430 --> 00:11:50,790
actually really ever happens in real

00:11:48,750 --> 00:11:54,630
systems so eventual consistency is like

00:11:50,790 --> 00:11:56,760
it's a very fuzzy concept um and so when

00:11:54,630 --> 00:11:58,200
we actually want chunker consistency

00:11:56,760 --> 00:12:00,540
guarantees in a distributed system we

00:11:58,200 --> 00:12:02,370
turn to the problem of consensus and

00:12:00,540 --> 00:12:04,980
consensus is the idea of everyone

00:12:02,370 --> 00:12:06,180
agreeing on the same value and so the

00:12:04,980 --> 00:12:09,149
most famous consensus algorithm

00:12:06,180 --> 00:12:11,820
obviously is paxos ah how many people

00:12:09,149 --> 00:12:13,110
have heard of paxos ok great ok so

00:12:11,820 --> 00:12:15,510
really quickly going to go through this

00:12:13,110 --> 00:12:17,100
invented by Leslie Lamport he recently

00:12:15,510 --> 00:12:19,350
won the Turing award and park for this

00:12:17,100 --> 00:12:21,180
algorithm which is amazing I mean the

00:12:19,350 --> 00:12:23,820
idea is that you know someone proposes a

00:12:21,180 --> 00:12:27,000
value and sends it to the other servers

00:12:23,820 --> 00:12:28,950
in the system they receive it and if the

00:12:27,000 --> 00:12:30,330
unique number included with that value

00:12:28,950 --> 00:12:32,790
is higher than anything they see and

00:12:30,330 --> 00:12:34,740
they say okay and then the guy few years

00:12:32,790 --> 00:12:36,870
from majority says okay well everyone

00:12:34,740 --> 00:12:39,060
then accept this value and they say okay

00:12:36,870 --> 00:12:41,220
and then this guy knows that the value

00:12:39,060 --> 00:12:43,410
has been decided all based on majorities

00:12:41,220 --> 00:12:46,860
so pretty simple algorithm two phases

00:12:43,410 --> 00:12:49,320
make sense um the idea what Paxos is

00:12:46,860 --> 00:12:51,779
that we can handle conflict so if two

00:12:49,320 --> 00:12:52,709
proposals happen at the same time given

00:12:51,779 --> 00:12:54,630
the fact that we're dealing with

00:12:52,709 --> 00:12:56,160
majorities here only one proposal can

00:12:54,630 --> 00:12:57,660
win only one proposal will have a higher

00:12:56,160 --> 00:12:59,790
number and it will talk to a majority of

00:12:57,660 --> 00:13:01,800
servers and it can end that keeps us

00:12:59,790 --> 00:13:05,310
from deciding to different values for

00:13:01,800 --> 00:13:07,290
the same at the same time and this is

00:13:05,310 --> 00:13:10,079
the paxos algorithm so we can see here

00:13:07,290 --> 00:13:12,060
it's actually not that complicated so

00:13:10,079 --> 00:13:13,440
this is from the distributed systems

00:13:12,060 --> 00:13:16,260
class at MIT the students have to

00:13:13,440 --> 00:13:18,150
implement paxus in a lab and this is the

00:13:16,260 --> 00:13:19,139
entirety of the pseudocode this is what

00:13:18,150 --> 00:13:22,290
they do it fits

00:13:19,139 --> 00:13:24,329
one slide um but unfortunately one

00:13:22,290 --> 00:13:26,129
instance of agreement is not really

00:13:24,329 --> 00:13:28,649
enough in our distributed systems today

00:13:26,129 --> 00:13:31,049
what we really want is this global log

00:13:28,649 --> 00:13:35,009
primitive and that means that each

00:13:31,049 --> 00:13:37,139
operation is seen as a read or write in

00:13:35,009 --> 00:13:38,759
the log everyone agrees on the log and

00:13:37,139 --> 00:13:40,169
the ordering of the log and then

00:13:38,759 --> 00:13:42,389
everyone applies those operations in

00:13:40,169 --> 00:13:44,100
order and so that's we can get external

00:13:42,389 --> 00:13:46,109
consistency doing this because instead

00:13:44,100 --> 00:13:48,509
of using time to order our operations

00:13:46,109 --> 00:13:49,949
we're actually running a round of

00:13:48,509 --> 00:13:51,449
agreement for everything that's

00:13:49,949 --> 00:13:52,859
happening in the system in order to

00:13:51,449 --> 00:13:55,199
agree on the order in which things

00:13:52,859 --> 00:13:56,669
happen in addition to Paxos there's a

00:13:55,199 --> 00:13:58,679
couple of other algorithms that do this

00:13:56,669 --> 00:14:02,249
Zab by zookeeper and view stamped

00:13:58,679 --> 00:14:03,809
replication and so so like I said this

00:14:02,249 --> 00:14:05,850
is externally consistent an outside

00:14:03,809 --> 00:14:07,859
observer can look at the log and see

00:14:05,850 --> 00:14:10,589
exactly what the values are for the

00:14:07,859 --> 00:14:12,689
entire system and so what does this have

00:14:10,589 --> 00:14:14,399
to do with a cap theorem well paxus lets

00:14:12,689 --> 00:14:16,319
us guarantee correctness with a

00:14:14,399 --> 00:14:19,649
functioning majority but it does not

00:14:16,319 --> 00:14:21,269
guarantee liveness and liveness is the

00:14:19,649 --> 00:14:24,149
idea that things will progress that the

00:14:21,269 --> 00:14:26,369
system will make progress and so okay

00:14:24,149 --> 00:14:28,799
here's the cap theorem the cap theorem

00:14:26,369 --> 00:14:31,410
was born of Erik Brewers pudsey talk in

00:14:28,799 --> 00:14:32,910
2000 which was titled consistency

00:14:31,410 --> 00:14:35,129
availability and partition tolerance

00:14:32,910 --> 00:14:36,899
choose to the idea here is that

00:14:35,129 --> 00:14:39,059
partition tolerance is a failure model

00:14:36,899 --> 00:14:41,069
okay and really what this theorem is

00:14:39,059 --> 00:14:43,199
saying is you make a choice can you

00:14:41,069 --> 00:14:45,660
process reads or writes during a

00:14:43,199 --> 00:14:47,339
partition or not do you want to go ahead

00:14:45,660 --> 00:14:49,259
and process them and possibly get things

00:14:47,339 --> 00:14:52,019
into an inconsistent State where'd you

00:14:49,259 --> 00:14:55,019
rather stop and wait and this is based

00:14:52,019 --> 00:14:58,709
on actually based on a paper written in

00:14:55,019 --> 00:15:00,839
1985 by Fisher Lynch and Patterson

00:14:58,709 --> 00:15:02,639
called the impossibility of distribute

00:15:00,839 --> 00:15:04,079
consensus with one faulty process and

00:15:02,639 --> 00:15:05,970
what this paper saying it's a

00:15:04,079 --> 00:15:08,669
distributed algorithms paper is that

00:15:05,970 --> 00:15:10,559
under an asynchronous model we can't

00:15:08,669 --> 00:15:13,529
tell the difference between a message

00:15:10,559 --> 00:15:15,809
being delayed and a machine failing that

00:15:13,529 --> 00:15:17,339
is the core of the cap algorithm or the

00:15:15,809 --> 00:15:20,549
cap theorem right there that right there

00:15:17,339 --> 00:15:22,470
it's this idea that you can't tell if a

00:15:20,549 --> 00:15:27,959
machine just taking a really long time

00:15:22,470 --> 00:15:31,019
or if it actually failed and and so what

00:15:27,959 --> 00:15:32,810
this means is that if one machine fails

00:15:31,019 --> 00:15:34,790
at exactly the wrong time

00:15:32,810 --> 00:15:35,900
if another machines fails exactly the

00:15:34,790 --> 00:15:39,470
wrong time and this continues to happen

00:15:35,900 --> 00:15:42,230
then then we'll never reach consensus

00:15:39,470 --> 00:15:43,580
and so it's an impossibility result you

00:15:42,230 --> 00:15:45,470
know it doesn't mean that this it's

00:15:43,580 --> 00:15:48,320
impossible to reach consensus ever it

00:15:45,470 --> 00:15:51,680
means that um you know I mean it means

00:15:48,320 --> 00:15:53,150
something else and so so you know we

00:15:51,680 --> 00:15:54,860
hear about the cap thermal you think it

00:15:53,150 --> 00:15:56,510
means we just can't have it all you know

00:15:54,860 --> 00:15:58,279
we can't have correct data and

00:15:56,510 --> 00:16:00,620
availability and partition tolerance um

00:15:58,279 --> 00:16:02,270
well so here's an analogy that I really

00:16:00,620 --> 00:16:04,880
like so have any of you ever play candy

00:16:02,270 --> 00:16:06,320
crush okay so I haven't actually played

00:16:04,880 --> 00:16:08,570
it but I played a lot of other tiling

00:16:06,320 --> 00:16:10,790
games um and it turns out that this

00:16:08,570 --> 00:16:13,100
class of games is np-hard did you know

00:16:10,790 --> 00:16:15,110
that so theoretically this class of

00:16:13,100 --> 00:16:16,820
games is unsolvable given all the time

00:16:15,110 --> 00:16:19,370
in the universe we're not able to solve

00:16:16,820 --> 00:16:21,200
these games yet do we play these games

00:16:19,370 --> 00:16:25,310
do we enjoy them yes do we even

00:16:21,200 --> 00:16:27,620
sometimes beat them um and so what this

00:16:25,310 --> 00:16:29,150
means for the cap theorem is that it is

00:16:27,620 --> 00:16:30,950
impossible to one hundred percent of the

00:16:29,150 --> 00:16:33,410
time decide everything on the internet

00:16:30,950 --> 00:16:36,410
if we can't rely on synchronous

00:16:33,410 --> 00:16:37,910
messaging but we can one hundred percent

00:16:36,410 --> 00:16:40,310
of the time decide everything if

00:16:37,910 --> 00:16:43,430
partitions heal which means that we know

00:16:40,310 --> 00:16:45,440
the upper bound on message delays and we

00:16:43,430 --> 00:16:47,360
it's not actually asynchronous messaging

00:16:45,440 --> 00:16:49,040
it's synchronous messaging um I think

00:16:47,360 --> 00:16:50,360
this is a really key idea that's often

00:16:49,040 --> 00:16:52,760
ignored and when you talk about the cap

00:16:50,360 --> 00:16:54,980
theorem is that if we know about on

00:16:52,760 --> 00:16:59,030
message delays we're actually the result

00:16:54,980 --> 00:17:01,790
actually doesn't hold um yeah and so we

00:16:59,030 --> 00:17:03,470
can still play candy crush um and and

00:17:01,790 --> 00:17:04,790
and so I think the real question which

00:17:03,470 --> 00:17:06,920
we should be talking about and running

00:17:04,790 --> 00:17:08,209
out of time is that we should really be

00:17:06,920 --> 00:17:10,100
looking at consistency versus

00:17:08,209 --> 00:17:12,829
performance not consistency versus

00:17:10,100 --> 00:17:14,630
availability how do we reduce the number

00:17:12,829 --> 00:17:16,339
of messages you know Paxos had a ton of

00:17:14,630 --> 00:17:18,770
messages how do we reduce that number

00:17:16,339 --> 00:17:20,959
while still producing a correct ordering

00:17:18,770 --> 00:17:25,459
and handling failures in making progress

00:17:20,959 --> 00:17:26,420
um and so one example of of where they

00:17:25,459 --> 00:17:28,850
actually went in the other direction

00:17:26,420 --> 00:17:30,560
from you know no sequel and went back to

00:17:28,850 --> 00:17:32,720
sort of consistent systems is with

00:17:30,560 --> 00:17:34,640
Google spanner the giant distributed

00:17:32,720 --> 00:17:36,620
database and they said we believe it's

00:17:34,640 --> 00:17:38,570
better to have application programmers

00:17:36,620 --> 00:17:40,190
deal with performance problems do the

00:17:38,570 --> 00:17:41,750
overuse of transactions rather than

00:17:40,190 --> 00:17:44,730
coding around the lack of transactions

00:17:41,750 --> 00:17:46,559
so consistency is really important it's

00:17:44,730 --> 00:17:50,760
it's it's vital for us to reason about

00:17:46,559 --> 00:17:52,650
our code um and so in summary we should

00:17:50,760 --> 00:17:55,350
be thinking about how to build fast

00:17:52,650 --> 00:17:56,820
systems that preserve consistency and

00:17:55,350 --> 00:17:58,290
then the slides will be available

00:17:56,820 --> 00:17:59,730
there's a little bit of further reading

00:17:58,290 --> 00:18:03,230
and that's it and I might have a minute

00:17:59,730 --> 00:18:03,230
or two for questions Thanks yeah

00:18:07,790 --> 00:18:23,400
questions ok so I really liked that last

00:18:19,919 --> 00:18:25,320
statement but I mean Google was kind of

00:18:23,400 --> 00:18:27,150
in a unique position to go that way

00:18:25,320 --> 00:18:28,950
right they had a lot of money that I

00:18:27,150 --> 00:18:31,320
could throw on the data centers at these

00:18:28,950 --> 00:18:34,169
really high precision clocks to everyone

00:18:31,320 --> 00:18:35,429
and so on so what do you do unless

00:18:34,169 --> 00:18:37,380
you're in the same position or would you

00:18:35,429 --> 00:18:38,790
say you are encouraging amazon and have

00:18:37,380 --> 00:18:40,740
a host status send us to add these

00:18:38,790 --> 00:18:42,240
clocks as well and often it now I to

00:18:40,740 --> 00:18:43,860
people I understand what you sub for

00:18:42,240 --> 00:18:46,260
people who don't know spanner uses

00:18:43,860 --> 00:18:47,820
atomic clocks so they bound the amounts

00:18:46,260 --> 00:18:49,890
that clocks can drift and that lets them

00:18:47,820 --> 00:18:51,299
do a lot of really cool tricks and the

00:18:49,890 --> 00:18:52,500
answer is yeah we don't all have a Tom

00:18:51,299 --> 00:18:54,840
o'clock so you're right but there are

00:18:52,500 --> 00:18:56,610
still other tricks that we can play so

00:18:54,840 --> 00:18:57,990
there's a ton of optimizations on paxos

00:18:56,610 --> 00:18:59,520
people are still doing research in this

00:18:57,990 --> 00:19:01,620
area to reduce the number of messages

00:18:59,520 --> 00:19:03,419
within a data center it might be more

00:19:01,620 --> 00:19:06,240
reasonable to talk about bounded clocks

00:19:03,419 --> 00:19:07,590
instead of across datacenters I guess

00:19:06,240 --> 00:19:09,570
spanner might might not be the answer

00:19:07,590 --> 00:19:10,410
for everyone but i think it's evidence

00:19:09,570 --> 00:19:17,040
that we should be going in this

00:19:10,410 --> 00:19:19,940
direction whole questions if not thank

00:19:17,040 --> 00:19:19,940

YouTube URL: https://www.youtube.com/watch?v=JAqnDwXGnSk


