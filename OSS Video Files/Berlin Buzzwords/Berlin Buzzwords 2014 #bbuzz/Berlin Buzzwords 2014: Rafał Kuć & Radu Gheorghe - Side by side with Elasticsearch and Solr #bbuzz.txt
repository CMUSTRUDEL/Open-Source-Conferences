Title: Berlin Buzzwords 2014: Rafał Kuć & Radu Gheorghe - Side by side with Elasticsearch and Solr #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	Solr - established, mature and well known open-source search server, commonly used. Elasticsearch - still young, but quickly gaining popularity, with over 200k downloads per month. Both search servers are based on Lucene - the open-source full text searching Java library, but each with their own extensions, their pros and cons.

We all know that Solr and Elasticsearch are different, but what those differences are and which solution is the best fit for a particular use case is a frequent question. We will try to make those differences clear, not by showing slides and compare them, but by showing online demo of both Elasticsearch and Solr:

- Set up and start both search servers. 
- See what you need to prepare and launch Solr and Elasticsearch.
- Index data right after the server was started using the "schemaless" mode
- Create index structure and modify it using the provided API
- Explore different query use cases
- Scale by adding and removing nodes from the cluster, creating indices and managing shards. 
- See how that affects data indexing and querying.
- Monitor and administer clusters.  

See what metrics can be seen out of the box, how to get them and what tools can provide you with the graphical view of all the goodies that each search server can provide.

Read more:
https://2014.berlinbuzzwords.de/session/side-side-elasticsearch-and-solr

About Rafał Kuć:
https://2014.berlinbuzzwords.de/user/199/event/1

About Radu Gheorghe:
https://2014.berlinbuzzwords.de/user/281/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,799 --> 00:00:11,990
hello hello everyone welcome to today's

00:00:09,230 --> 00:00:14,809
talk side-by-side with solar and

00:00:11,990 --> 00:00:17,480
elasticsearch we hope you had a nice day

00:00:14,809 --> 00:00:21,320
yesterday at the buzzwords and enjoy the

00:00:17,480 --> 00:00:24,530
after party before we start I would like

00:00:21,320 --> 00:00:28,400
to ask two or three questions how many

00:00:24,530 --> 00:00:30,289
of you know soar okay

00:00:28,400 --> 00:00:33,680
that's nice how many of you know

00:00:30,289 --> 00:00:38,390
elasticsearch great I won't ask the

00:00:33,680 --> 00:00:41,390
third question then before we start I

00:00:38,390 --> 00:00:43,429
will talk about the video search site I

00:00:41,390 --> 00:00:46,670
would like to introduce my colleague rod

00:00:43,429 --> 00:00:51,409
oh don't hide we are working together

00:00:46,670 --> 00:00:54,589
sama text he's a father and a husband we

00:00:51,409 --> 00:00:56,479
were working a consulting side we are

00:00:54,589 --> 00:00:58,579
working together locks on fertilization

00:00:56,479 --> 00:01:01,370
software called logs in he also happens

00:00:58,579 --> 00:01:03,829
to be an outer of elasticsearch in

00:01:01,370 --> 00:01:06,170
action for available at the manager

00:01:03,829 --> 00:01:08,330
early access project so if you want a

00:01:06,170 --> 00:01:11,720
nice book about elasticsearch here's the

00:01:08,330 --> 00:01:14,990
guy to talk to and here's the file my

00:01:11,720 --> 00:01:18,410
colleague we work together on consulting

00:01:14,990 --> 00:01:20,180
projects we work together on logs een he

00:01:18,410 --> 00:01:24,230
works with both elasticsearch and solar

00:01:20,180 --> 00:01:26,270
heroes books about both and he's a

00:01:24,230 --> 00:01:30,470
general nice guy a family man you cannot

00:01:26,270 --> 00:01:33,080
not like him once you get to meet him so

00:01:30,470 --> 00:01:34,820
let's let's have an overview of what

00:01:33,080 --> 00:01:36,890
we're going to talk about today as

00:01:34,820 --> 00:01:39,500
Rafael said I actually didn't say that

00:01:36,890 --> 00:01:43,910
but anyway let's let's imagine the use

00:01:39,500 --> 00:01:47,450
case that we want to build search over

00:01:43,910 --> 00:01:49,070
some video metadata so stuff like who

00:01:47,450 --> 00:01:52,760
the uploader is the title the

00:01:49,070 --> 00:01:54,680
description and so on so at this point

00:01:52,760 --> 00:01:56,750
let's assume that we don't know which

00:01:54,680 --> 00:01:58,850
which one fits best whether it's solar

00:01:56,750 --> 00:02:00,140
or elasticsearch so what we're going to

00:01:58,850 --> 00:02:02,690
do is we're going to show you an

00:02:00,140 --> 00:02:05,420
overview of how you do it in both search

00:02:02,690 --> 00:02:08,000
engines from indexing searching to doing

00:02:05,420 --> 00:02:09,440
some facets of analytics and to

00:02:08,000 --> 00:02:13,549
administering and scaling out your

00:02:09,440 --> 00:02:15,680
cluster we'll start with the data let's

00:02:13,549 --> 00:02:18,109
assume that our documents the videos

00:02:15,680 --> 00:02:19,400
we're going to index actually do the

00:02:18,109 --> 00:02:21,560
metadata about the video

00:02:19,400 --> 00:02:25,010
are stored in adjacent a simple JSON

00:02:21,560 --> 00:02:26,810
file will show you will for development

00:02:25,010 --> 00:02:28,730
mode will use a schema less modes for

00:02:26,810 --> 00:02:31,129
both solar and elasticsearch that's why

00:02:28,730 --> 00:02:33,319
we don't care about schema yet then

00:02:31,129 --> 00:02:35,510
after we index the data we want to run

00:02:33,319 --> 00:02:36,650
searches on it both of course elastic

00:02:35,510 --> 00:02:38,780
search and solar provides that

00:02:36,650 --> 00:02:41,359
functionality we also want to give data

00:02:38,780 --> 00:02:43,939
the meaning so we use facets in solar we

00:02:41,359 --> 00:02:45,590
can use aggregations and percolation in

00:02:43,939 --> 00:02:48,109
elastic search we will talk about it

00:02:45,590 --> 00:02:50,750
later of course a single node can be

00:02:48,109 --> 00:02:54,290
tuned to the way that is going to run

00:02:50,750 --> 00:02:56,780
smooth but at a certain point you end up

00:02:54,290 --> 00:02:58,730
with scaling out and the need of it so

00:02:56,780 --> 00:03:02,030
we'll also show you how to scale out

00:02:58,730 --> 00:03:04,129
both solutions finally maybe not finally

00:03:02,030 --> 00:03:06,980
you want to do backups and if you don't

00:03:04,129 --> 00:03:09,769
do you will do it I was at the point

00:03:06,980 --> 00:03:12,859
where I didn't do them and lesson

00:03:09,769 --> 00:03:15,980
learned that's a fact and finally we'll

00:03:12,859 --> 00:03:18,859
get to an ecosystem around both of those

00:03:15,980 --> 00:03:21,019
because it's large and there are many

00:03:18,859 --> 00:03:22,909
tools that will help you on your way to

00:03:21,019 --> 00:03:25,299
getting to the final product in

00:03:22,909 --> 00:03:29,419
production let's start with a simple

00:03:25,299 --> 00:03:32,060
data file our data files looks like this

00:03:29,419 --> 00:03:34,250
is a simple JSON with a few fields some

00:03:32,060 --> 00:03:36,290
of them are single valued like the ID or

00:03:34,250 --> 00:03:38,510
the title and some of them are multi

00:03:36,290 --> 00:03:41,180
valued like the tax field which has an

00:03:38,510 --> 00:03:43,250
array of values you can look the older

00:03:41,180 --> 00:03:45,349
for all the data files that the provided

00:03:43,250 --> 00:03:47,180
github account there are also commands

00:03:45,349 --> 00:03:51,169
that will allow you to index them

00:03:47,180 --> 00:03:53,690
without any any trouble so let's now

00:03:51,169 --> 00:03:56,209
index the data anyway this is a real car

00:03:53,690 --> 00:04:01,400
I'll switch to the video and show you

00:03:56,209 --> 00:04:03,139
something so we start with unpacking

00:04:01,400 --> 00:04:05,540
both solar and elasticsearch we choose

00:04:03,139 --> 00:04:08,930
the 4/8 version to fit the presentation

00:04:05,540 --> 00:04:11,329
and we choose 101 100 elasticsearch we

00:04:08,930 --> 00:04:14,829
unpack those two it takes a bit longer

00:04:11,329 --> 00:04:19,099
with sorb because the package is a bit

00:04:14,829 --> 00:04:21,650
weights more after we unpack it in terms

00:04:19,099 --> 00:04:24,229
of solar elasticsearch works with

00:04:21,650 --> 00:04:25,820
schema-less by default in solar we have

00:04:24,229 --> 00:04:27,560
to do some additional things what we

00:04:25,820 --> 00:04:29,060
will do is we actually will remove the

00:04:27,560 --> 00:04:31,940
default collection provided with solar

00:04:29,060 --> 00:04:32,930
and we'll replace it with this schema

00:04:31,940 --> 00:04:35,389
less example

00:04:32,930 --> 00:04:39,080
provide it again with the example

00:04:35,389 --> 00:04:42,759
deployment Solar has after that we'll

00:04:39,080 --> 00:04:45,350
need to copy it just a second

00:04:42,759 --> 00:04:49,100
so we copy it's called this example

00:04:45,350 --> 00:04:51,680
schema-less and now we can just start

00:04:49,100 --> 00:04:54,710
them we hit be an elastic search with

00:04:51,680 --> 00:04:59,660
elastic search and we hit Java jar start

00:04:54,710 --> 00:05:01,970
and we're and we're ready okay we

00:04:59,660 --> 00:05:07,100
started solar we can see that an elastic

00:05:01,970 --> 00:05:09,770
search is starting as well after that we

00:05:07,100 --> 00:05:11,720
can use the commands provided to get

00:05:09,770 --> 00:05:14,479
help to index the data it's really

00:05:11,720 --> 00:05:15,889
simple however there is one additional

00:05:14,479 --> 00:05:19,220
thing I would like to mention when it

00:05:15,889 --> 00:05:21,949
comes to solar that the files that are

00:05:19,220 --> 00:05:24,260
on github they need to be surrounded by

00:05:21,949 --> 00:05:26,870
square brackets because that's what the

00:05:24,260 --> 00:05:29,030
solar format is after that if you can

00:05:26,870 --> 00:05:31,310
see that they're indexed and ready for

00:05:29,030 --> 00:05:36,770
searching and we will do that in just a

00:05:31,310 --> 00:05:39,010
few ok let's get back of course we

00:05:36,770 --> 00:05:42,169
talked that we want to use the schemas

00:05:39,010 --> 00:05:44,479
first but in production environment you

00:05:42,169 --> 00:05:47,750
usually don't want to go with schemas

00:05:44,479 --> 00:05:50,389
why because you want custom analysis

00:05:47,750 --> 00:05:53,030
defined by you to match your use case in

00:05:50,389 --> 00:05:55,010
terms of solar we do that by default by

00:05:53,030 --> 00:05:58,669
altering the schema XML file or

00:05:55,010 --> 00:06:00,530
providing our own we push the day we

00:05:58,669 --> 00:06:03,440
push all the configurations to Kisuke

00:06:00,530 --> 00:06:05,389
per which holds the configurations is

00:06:03,440 --> 00:06:07,699
responsible for helping with overseer

00:06:05,389 --> 00:06:10,669
election and stuff like that provides

00:06:07,699 --> 00:06:12,919
the cluster state the schema XML is a

00:06:10,669 --> 00:06:15,470
really simple file an XML file that

00:06:12,919 --> 00:06:19,400
provides all the fields that you will

00:06:15,470 --> 00:06:21,919
use and that show your index structure

00:06:19,400 --> 00:06:24,889
and provides all the field types that

00:06:21,919 --> 00:06:26,570
define your analysis with elastic search

00:06:24,889 --> 00:06:28,760
you probably know that you have the

00:06:26,570 --> 00:06:32,330
mapping as the equivalent of the schema

00:06:28,760 --> 00:06:35,479
and you can put it using the put mapping

00:06:32,330 --> 00:06:38,419
API and you can also use the put mapping

00:06:35,479 --> 00:06:42,409
API to extend the existing mapping with

00:06:38,419 --> 00:06:44,990
new fields you can see that it's in JSON

00:06:42,409 --> 00:06:45,800
but the key difference here is that with

00:06:44,990 --> 00:06:49,099
elastic

00:06:45,800 --> 00:06:51,080
you can have multiple mappings in the

00:06:49,099 --> 00:06:54,650
same index so this is useful when you

00:06:51,080 --> 00:06:56,870
have for example videos which have the

00:06:54,650 --> 00:06:58,370
documents have one structure and users

00:06:56,870 --> 00:07:00,229
will documents have a different

00:06:58,370 --> 00:07:03,610
structure and you can put them in the

00:07:00,229 --> 00:07:06,949
same index under different mapping types

00:07:03,610 --> 00:07:08,389
let's move to searching if you if you

00:07:06,949 --> 00:07:11,509
want to run a quick query on

00:07:08,389 --> 00:07:14,330
elasticsearch you would hit the search

00:07:11,509 --> 00:07:17,690
endpoint and you would look at the Q

00:07:14,330 --> 00:07:20,120
parameter and put your Lucene query

00:07:17,690 --> 00:07:24,229
string there you will get a JSON reply

00:07:20,120 --> 00:07:26,990
with the results ranked by relevancy

00:07:24,229 --> 00:07:29,210
score by default and you can see in the

00:07:26,990 --> 00:07:33,440
source field there there's the original

00:07:29,210 --> 00:07:35,810
JSON that you indexed when it comes to

00:07:33,440 --> 00:07:37,580
solar we need to provide the collection

00:07:35,810 --> 00:07:39,710
name you want to run searches against

00:07:37,580 --> 00:07:42,169
and we choose the request Handler we

00:07:39,710 --> 00:07:45,080
want to run our searches to which is the

00:07:42,169 --> 00:07:46,940
Select one which is here it basically

00:07:45,080 --> 00:07:48,560
provides the functionality of getting

00:07:46,940 --> 00:07:51,620
our parameters and passing into the

00:07:48,560 --> 00:07:53,810
correct request parse a query parser as

00:07:51,620 --> 00:07:55,430
you can see the queries again simple as

00:07:53,810 --> 00:07:58,099
it can be we passing the Q parameter

00:07:55,430 --> 00:08:00,560
with elastic search and because by

00:07:58,099 --> 00:08:04,550
default solar doesn't return score for

00:08:00,560 --> 00:08:06,979
each document we need to alter the

00:08:04,550 --> 00:08:09,380
fields this parameter that's why we

00:08:06,979 --> 00:08:12,219
decide star which means give me all the

00:08:09,380 --> 00:08:15,169
stored fields in result and the score

00:08:12,219 --> 00:08:17,599
the result returned by solar is by

00:08:15,169 --> 00:08:19,639
default XML file which contains all the

00:08:17,599 --> 00:08:22,669
stored fields we don't have source in

00:08:19,639 --> 00:08:24,889
solar and you can change the response

00:08:22,669 --> 00:08:28,009
format to whatever you choose and it's

00:08:24,889 --> 00:08:30,770
available like JSON CSV files serialized

00:08:28,009 --> 00:08:33,740
PHP Java Bean and all the other stuff

00:08:30,770 --> 00:08:37,969
that's that's there however the standard

00:08:33,740 --> 00:08:40,909
query URI request query is not something

00:08:37,969 --> 00:08:43,490
you'll stick for long apparently so

00:08:40,909 --> 00:08:46,160
that's why solar provides you with

00:08:43,490 --> 00:08:49,630
multiple request parse the query parsers

00:08:46,160 --> 00:08:52,399
actually sorry and we can do that we can

00:08:49,630 --> 00:08:54,680
they have multiple parameters different

00:08:52,399 --> 00:08:56,270
ones and they just parse our queries for

00:08:54,680 --> 00:08:59,029
example here we use the standard query

00:08:56,270 --> 00:08:59,960
parser provided by solar we want to get

00:08:59,029 --> 00:09:02,180
the documents with the

00:08:59,960 --> 00:09:04,100
elasticsearch entitle and logs in the

00:09:02,180 --> 00:09:07,540
tax field and we just run a simple query

00:09:04,100 --> 00:09:10,040
we can also leverage the query parser

00:09:07,540 --> 00:09:12,350
functionality and remove the logical

00:09:10,040 --> 00:09:14,930
operator from the query some and pass it

00:09:12,350 --> 00:09:17,029
with the additional cue a parameter with

00:09:14,930 --> 00:09:18,950
elastic search you have the query DSL

00:09:17,029 --> 00:09:21,550
and I just want to ask who went to the

00:09:18,950 --> 00:09:23,899
query DSL talk from yesterday

00:09:21,550 --> 00:09:26,720
alright so for those of you who weren't

00:09:23,899 --> 00:09:28,910
the point is that you would put a JSON

00:09:26,720 --> 00:09:30,860
as the payload to your HTTP request and

00:09:28,910 --> 00:09:33,680
in that JSON you would define your

00:09:30,860 --> 00:09:36,440
queries in this case you can see there's

00:09:33,680 --> 00:09:40,220
a bull query which has a shoot clause

00:09:36,440 --> 00:09:42,860
and that PO query can be used to wrap

00:09:40,220 --> 00:09:45,170
other queries for example the match

00:09:42,860 --> 00:09:47,899
query which will look for elastic search

00:09:45,170 --> 00:09:50,990
in the title and the term query which

00:09:47,899 --> 00:09:56,240
will look for the exact term logs in the

00:09:50,990 --> 00:09:57,920
tags field let's move to to some use

00:09:56,240 --> 00:10:01,910
cases that might not be typical to a

00:09:57,920 --> 00:10:04,790
search engine for example let's say that

00:10:01,910 --> 00:10:08,300
we want to be alerted every time we get

00:10:04,790 --> 00:10:11,810
a new video uploaded with elastic search

00:10:08,300 --> 00:10:13,940
in the tags field and to do that we can

00:10:11,810 --> 00:10:16,490
use the percolator and I want to ask who

00:10:13,940 --> 00:10:22,270
was at the percolator workshop talked

00:10:16,490 --> 00:10:26,120
yesterday so this is a typical use case

00:10:22,270 --> 00:10:29,060
the point is you can index queries as

00:10:26,120 --> 00:10:31,520
you normally index documents except you

00:10:29,060 --> 00:10:34,580
put them in the Pirkle in dot /

00:10:31,520 --> 00:10:37,130
percolator type and then you can hit the

00:10:34,580 --> 00:10:38,900
percolate endpoint with documents and

00:10:37,130 --> 00:10:42,620
what you will get back is the list of

00:10:38,900 --> 00:10:45,980
queries that would match the document

00:10:42,620 --> 00:10:48,829
that you percolate in solar we don't

00:10:45,980 --> 00:10:51,920
have percolator apparently but imagine

00:10:48,829 --> 00:10:54,320
of a certain use case we want to have

00:10:51,920 --> 00:10:56,720
more diversified results with solar for

00:10:54,320 --> 00:10:59,270
example we would like to have a single

00:10:56,720 --> 00:11:01,970
document a single video returned for

00:10:59,270 --> 00:11:04,070
each uploader of our events so what we

00:11:01,970 --> 00:11:05,420
can do is we can use a grouping call

00:11:04,070 --> 00:11:08,120
also called field collapsing

00:11:05,420 --> 00:11:10,400
functionality we can run cue elastic

00:11:08,120 --> 00:11:12,020
search like the query we've already run

00:11:10,400 --> 00:11:13,920
and we turn on the grouping

00:11:12,020 --> 00:11:15,750
functionality by

00:11:13,920 --> 00:11:18,690
finding the group equals true parameters

00:11:15,750 --> 00:11:20,970
and we specify the name of the field we

00:11:18,690 --> 00:11:22,980
want to group on in this case uploaded

00:11:20,970 --> 00:11:25,079
by which holds our upload lives what

00:11:22,980 --> 00:11:27,240
solar will do is it will take the terms

00:11:25,079 --> 00:11:30,360
from the uploaded by field and we'll

00:11:27,240 --> 00:11:32,910
divide our results returning a single

00:11:30,360 --> 00:11:35,880
document by default for each of the

00:11:32,910 --> 00:11:38,370
terms in the uploaded by field so we'll

00:11:35,880 --> 00:11:39,930
get a single document for new thinking

00:11:38,370 --> 00:11:42,089
communication which is uploaded for

00:11:39,930 --> 00:11:45,079
Berlin buzzwords videos for example of

00:11:42,089 --> 00:11:47,310
course we can alter the default

00:11:45,079 --> 00:11:49,800
functionality to return more documents

00:11:47,310 --> 00:11:52,410
the key point here is that solar will

00:11:49,800 --> 00:11:55,769
return the most relevant documents for

00:11:52,410 --> 00:12:01,139
each of the groups of course in real

00:11:55,769 --> 00:12:04,860
world data is not flat at all so both of

00:12:01,139 --> 00:12:06,690
the the great certain sort an elastic

00:12:04,860 --> 00:12:08,850
search provides the support for

00:12:06,690 --> 00:12:11,070
hierarchies imagine the fact that we

00:12:08,850 --> 00:12:14,970
would like to have names of the

00:12:11,070 --> 00:12:17,070
presenters like us two here divide it

00:12:14,970 --> 00:12:19,890
into different fields so we want to

00:12:17,070 --> 00:12:24,269
avoid cross matches so rather couch

00:12:19,890 --> 00:12:27,839
wouldn't be a match right so what we can

00:12:24,269 --> 00:12:30,800
get from solar and elastic search is

00:12:27,839 --> 00:12:35,010
first the nested documents support its

00:12:30,800 --> 00:12:37,500
rely on on the blog joint functionality

00:12:35,010 --> 00:12:39,660
provided by loosing library and actually

00:12:37,500 --> 00:12:42,870
it indexes that the parent and the

00:12:39,660 --> 00:12:44,820
nested documents in the same segment so

00:12:42,870 --> 00:12:46,949
they are nil and they can be searched in

00:12:44,820 --> 00:12:49,320
a very efficient way the other thing

00:12:46,949 --> 00:12:51,449
that we can use is the parent-child

00:12:49,320 --> 00:12:54,060
functionality which in store is a pure

00:12:51,449 --> 00:12:56,610
query time join an elastic search you

00:12:54,060 --> 00:12:58,980
need to provide the document identifier

00:12:56,610 --> 00:13:03,029
the parent document a data fire for the

00:12:58,980 --> 00:13:05,579
each of the child documents we also want

00:13:03,029 --> 00:13:08,160
to give our data meaning in terms of

00:13:05,579 --> 00:13:11,399
solar we have the facet functionality

00:13:08,160 --> 00:13:15,690
what facet is is actually term connected

00:13:11,399 --> 00:13:17,940
to some number usually account to build

00:13:15,690 --> 00:13:19,980
a simple pack cloud of our search

00:13:17,940 --> 00:13:22,440
results we would use the field faceting

00:13:19,980 --> 00:13:27,160
on the tax field and what's or we'll do

00:13:22,440 --> 00:13:29,800
is we'll return all the top count tags

00:13:27,160 --> 00:13:32,920
the terms from the tax filled with the

00:13:29,800 --> 00:13:36,100
count specifying how many documents were

00:13:32,920 --> 00:13:39,550
found with the given tag we also may

00:13:36,100 --> 00:13:42,910
want to have a variance of that we will

00:13:39,550 --> 00:13:44,680
if you are only interested in some of

00:13:42,910 --> 00:13:48,160
the uploaders not all of them we can

00:13:44,680 --> 00:13:49,780
tune the query to return only the facets

00:13:48,160 --> 00:13:52,060
for those two uploaders we are

00:13:49,780 --> 00:13:54,040
interested in and that's why Seoul

00:13:52,060 --> 00:13:56,320
provides the face of query functionality

00:13:54,040 --> 00:13:58,540
and in this case the facet query would

00:13:56,320 --> 00:14:00,810
return only counts for leucine solar

00:13:58,540 --> 00:14:03,010
revolution and Newton in communications

00:14:00,810 --> 00:14:04,990
with the elastic search you also have

00:14:03,010 --> 00:14:08,320
facets but they have been superseded

00:14:04,990 --> 00:14:10,330
recently by aggregations and I want to

00:14:08,320 --> 00:14:15,430
ask again who was that the aggregation

00:14:10,330 --> 00:14:19,090
star came yesterday all right so now

00:14:15,430 --> 00:14:21,700
quickly sum it up basically aggregations

00:14:19,090 --> 00:14:24,730
are like facets if you only use them one

00:14:21,700 --> 00:14:26,530
by one and they are divided in their

00:14:24,730 --> 00:14:28,540
multiple types and they are dividing two

00:14:26,530 --> 00:14:30,880
categories there are pocket aggregations

00:14:28,540 --> 00:14:33,910
like this terms aggregation here which

00:14:30,880 --> 00:14:36,250
will get you like a tag cloud because it

00:14:33,910 --> 00:14:40,000
will make you a bucket of documents out

00:14:36,250 --> 00:14:41,530
of each out of each tag so the documents

00:14:40,000 --> 00:14:43,030
that match that tag will be in one

00:14:41,530 --> 00:14:46,240
bucket and the next step

00:14:43,030 --> 00:14:48,250
tag another bucket and there are metrics

00:14:46,240 --> 00:14:49,840
aggregations which will only return you

00:14:48,250 --> 00:14:52,300
one number so for example the

00:14:49,840 --> 00:14:54,520
cardinality aggregation will get you the

00:14:52,300 --> 00:14:58,230
number of unique values in a certain

00:14:54,520 --> 00:15:00,550
field now the real power of facets is

00:14:58,230 --> 00:15:03,000
aggregations there is the power of

00:15:00,550 --> 00:15:06,070
aggregations I said facets yes

00:15:03,000 --> 00:15:09,480
okay so the real power of aggregations

00:15:06,070 --> 00:15:13,000
is the fact that you can nest them the

00:15:09,480 --> 00:15:16,150
the bucket aggregations can have sub

00:15:13,000 --> 00:15:19,840
aggregations so for example we can get

00:15:16,150 --> 00:15:23,430
the tag cloud but also for each tag we

00:15:19,840 --> 00:15:26,080
can get the number of videos uploaded

00:15:23,430 --> 00:15:31,180
yeah for each tag each month

00:15:26,080 --> 00:15:33,640
does that make sense yes okay okay don't

00:15:31,180 --> 00:15:35,350
kill me those two things are not equal

00:15:33,640 --> 00:15:38,650
when it comes to functionality however

00:15:35,350 --> 00:15:41,180
the subset of functionality in solar we

00:15:38,650 --> 00:15:44,660
can do with people facets

00:15:41,180 --> 00:15:47,420
we again set the facet parameter to true

00:15:44,660 --> 00:15:49,940
to enable them and we use the facet

00:15:47,420 --> 00:15:53,450
pivot parameter what we'll get in result

00:15:49,940 --> 00:15:55,430
is that Solar will nest the facets here

00:15:53,450 --> 00:15:58,700
facet counts for example in this in this

00:15:55,430 --> 00:16:00,590
case we will get the tags group of

00:15:58,700 --> 00:16:02,240
facets and under each tag we'll get

00:16:00,590 --> 00:16:04,880
their views and the number of documents

00:16:02,240 --> 00:16:07,310
with the given view it's not as powerful

00:16:04,880 --> 00:16:11,390
as aggregations but still sometimes it's

00:16:07,310 --> 00:16:13,820
worth checking out what we would like to

00:16:11,390 --> 00:16:16,070
show you now at least a small portion of

00:16:13,820 --> 00:16:16,670
it is that we like to graph things all

00:16:16,070 --> 00:16:19,220
of them

00:16:16,670 --> 00:16:21,890
we have monitoring solution called SPM

00:16:19,220 --> 00:16:24,320
in cymatics we have search analytics we

00:16:21,890 --> 00:16:26,800
also do graph logs and what we will now

00:16:24,320 --> 00:16:29,720
show you is a small portion of logging

00:16:26,800 --> 00:16:31,730
graphing right yes how many of you

00:16:29,720 --> 00:16:32,990
already know Cubana I know some of you

00:16:31,730 --> 00:16:38,360
don't do all right

00:16:32,990 --> 00:16:41,420
so Cubana is a okay so Cubana is a

00:16:38,360 --> 00:16:44,030
visualization tool built to work with

00:16:41,420 --> 00:16:46,550
elastic search and you can build your

00:16:44,030 --> 00:16:50,180
own dashboards and basically graph all

00:16:46,550 --> 00:16:52,490
the things this is just an example of

00:16:50,180 --> 00:16:54,830
what you can do on the left side you

00:16:52,490 --> 00:16:57,680
have a widget that will show you the

00:16:54,830 --> 00:17:00,620
breakdown of videos for each tag and on

00:16:57,680 --> 00:17:02,390
the right yeah also breakdown of videos

00:17:00,620 --> 00:17:04,130
for each tag but this time will not show

00:17:02,390 --> 00:17:08,630
the number of videos put the number of

00:17:04,130 --> 00:17:10,819
views and if you search for something

00:17:08,630 --> 00:17:12,980
then all the graphs will be

00:17:10,819 --> 00:17:17,030
automatically adjusted to only the

00:17:12,980 --> 00:17:20,240
results that match your search there's

00:17:17,030 --> 00:17:22,310
also a or actually more than one work of

00:17:20,240 --> 00:17:26,829
kibana that should work for solar I

00:17:22,310 --> 00:17:33,800
didn't actually use them but they work

00:17:26,829 --> 00:17:35,330
and when it comes to operations when it

00:17:33,800 --> 00:17:38,660
comes to operations you probably want to

00:17:35,330 --> 00:17:40,340
monitor your search engine the lots of

00:17:38,660 --> 00:17:41,840
monitoring products out there we have

00:17:40,340 --> 00:17:43,790
our own SPM that works with

00:17:41,840 --> 00:17:45,950
elasticsearch solar and a bunch of other

00:17:43,790 --> 00:17:48,140
stuff but for now we want to show you

00:17:45,950 --> 00:17:50,660
what works out of the box and with

00:17:48,140 --> 00:17:53,130
elastic search you have the stats api's

00:17:50,660 --> 00:17:55,320
which will get you

00:17:53,130 --> 00:17:57,420
lots of metrics from how much time you

00:17:55,320 --> 00:17:59,760
spend indexing to how fast your queries

00:17:57,420 --> 00:18:03,870
are or how much memory is used and stuff

00:17:59,760 --> 00:18:06,770
like that in solar it's not a single API

00:18:03,870 --> 00:18:10,020
that is available however we can get

00:18:06,770 --> 00:18:13,320
statistics from all the ambans that are

00:18:10,020 --> 00:18:15,900
provided in JMX by solar so we can

00:18:13,320 --> 00:18:18,180
connect to the JMX using a simple tools

00:18:15,900 --> 00:18:21,120
just like j console from the GDK that

00:18:18,180 --> 00:18:24,480
you have and we can check each plug-in

00:18:21,120 --> 00:18:26,790
that is registered in this JMX mbeans

00:18:24,480 --> 00:18:29,940
and we can check things like number of

00:18:26,790 --> 00:18:32,970
requests percentiles error counts

00:18:29,940 --> 00:18:35,010
average response times average run times

00:18:32,970 --> 00:18:38,090
and stuff like that the thing is that

00:18:35,010 --> 00:18:40,470
all those statistics are per node

00:18:38,090 --> 00:18:42,420
displayed in the solar at mean by

00:18:40,470 --> 00:18:45,780
default so if you go to the solar mean

00:18:42,420 --> 00:18:48,900
you can see the standard the top image

00:18:45,780 --> 00:18:51,540
the standard stuff that when it comes to

00:18:48,900 --> 00:18:54,930
memory usage and of course the bottom

00:18:51,540 --> 00:18:56,700
image shows some statistics fetched from

00:18:54,930 --> 00:18:59,790
the JMX like we can see the handler

00:18:56,700 --> 00:19:02,370
start timestamp we can see the request

00:18:59,790 --> 00:19:05,310
number errors timeouts total time

00:19:02,370 --> 00:19:07,140
averages percentiles and so on in

00:19:05,310 --> 00:19:09,090
addition to that we have the cluster

00:19:07,140 --> 00:19:10,980
state which is stored in the zookeeper

00:19:09,090 --> 00:19:13,470
and provides us with the information

00:19:10,980 --> 00:19:15,900
about all the cluster related things

00:19:13,470 --> 00:19:18,540
like where the nodes are how they are

00:19:15,900 --> 00:19:20,640
named what are the replicas word what

00:19:18,540 --> 00:19:22,740
are the leaders how healthy there are

00:19:20,640 --> 00:19:27,150
and stuff like that you can just get it

00:19:22,740 --> 00:19:29,310
from zookeeper or or from solar we told

00:19:27,150 --> 00:19:32,820
you in the beginning about the backup

00:19:29,310 --> 00:19:35,940
however we left the left side of solar

00:19:32,820 --> 00:19:38,730
or with the backup empty that's on

00:19:35,940 --> 00:19:41,400
purpose because you can do a hack in

00:19:38,730 --> 00:19:44,520
salt cloud actually to enable multiple

00:19:41,400 --> 00:19:46,530
replication handlers however the data

00:19:44,520 --> 00:19:48,360
will be replicated outside to a second

00:19:46,530 --> 00:19:50,430
cluster or a second or a secondary node

00:19:48,360 --> 00:19:53,670
or something like that however that's

00:19:50,430 --> 00:19:55,860
not automated enough in at least for

00:19:53,670 --> 00:19:57,420
from our point of view to be considered

00:19:55,860 --> 00:19:59,760
a viable backup solution because you

00:19:57,420 --> 00:20:02,640
can't just restore it on-demand you

00:19:59,760 --> 00:20:04,740
can't store snapshots or in a given time

00:20:02,640 --> 00:20:05,860
another that's not a viable solution

00:20:04,740 --> 00:20:08,649
that

00:20:05,860 --> 00:20:11,620
we would use apparently and that can be

00:20:08,649 --> 00:20:13,630
used without additional automation with

00:20:11,620 --> 00:20:16,299
elasticsearch as with everything you

00:20:13,630 --> 00:20:19,480
have an API this one is called snapshot

00:20:16,299 --> 00:20:21,250
restored and the point is you you would

00:20:19,480 --> 00:20:22,840
define a location where you want to

00:20:21,250 --> 00:20:24,789
store your backups and then you can

00:20:22,840 --> 00:20:28,570
start running incremental backups by

00:20:24,789 --> 00:20:30,909
hitting the snapshot API there and you

00:20:28,570 --> 00:20:36,130
can also use the same API to restore and

00:20:30,909 --> 00:20:40,779
this works this works across all the

00:20:36,130 --> 00:20:42,700
data of your cluster so speaking of

00:20:40,779 --> 00:20:44,200
clusters let let us show you how you

00:20:42,700 --> 00:20:46,630
would scale out both solar and

00:20:44,200 --> 00:20:49,620
elasticsearch and I want to ask how many

00:20:46,630 --> 00:20:54,220
of you already know how solar scales

00:20:49,620 --> 00:20:55,539
right okay about elastic search a bit

00:20:54,220 --> 00:21:00,179
more okay great

00:20:55,539 --> 00:21:03,850
so we'll start our gain video with solar

00:21:00,179 --> 00:21:06,460
what we'll start with is a single node

00:21:03,850 --> 00:21:08,380
deployment we will start it and run it

00:21:06,460 --> 00:21:10,659
in a salt cloud mode however we don't

00:21:08,380 --> 00:21:13,450
use external zookeeper to keep the

00:21:10,659 --> 00:21:15,730
single to keep things simple instead we

00:21:13,450 --> 00:21:17,529
will use an embedded one by specifying

00:21:15,730 --> 00:21:22,990
the city run parameter will also specify

00:21:17,529 --> 00:21:25,210
this the host and we just start solar it

00:21:22,990 --> 00:21:27,340
started however to create a collection

00:21:25,210 --> 00:21:30,250
we need a configuration to be uploaded

00:21:27,340 --> 00:21:32,889
to zookeeper so we can just check it

00:21:30,250 --> 00:21:35,289
just no collections available so let's

00:21:32,889 --> 00:21:37,029
create one to do that as I already

00:21:35,289 --> 00:21:39,700
mentioned we need the configuration

00:21:37,029 --> 00:21:41,649
stored in zookeeper we will do that by

00:21:39,700 --> 00:21:45,610
using a standard script provided in

00:21:41,649 --> 00:21:48,159
solid deployment that's the GTA client

00:21:45,610 --> 00:21:51,190
but we can upload config to a given

00:21:48,159 --> 00:21:53,830
zookeeper specifying the configuration

00:21:51,190 --> 00:21:56,110
directory and the name of our collection

00:21:53,830 --> 00:21:58,630
it will upload leave all the files that

00:21:56,110 --> 00:22:01,059
are relevant and we can now use the

00:21:58,630 --> 00:22:03,610
collections API to create a new

00:22:01,059 --> 00:22:05,950
collection will name it scale this will

00:22:03,610 --> 00:22:07,899
give it to a single chart with

00:22:05,950 --> 00:22:10,299
replication one which means it will only

00:22:07,899 --> 00:22:12,519
create a leader and we use the

00:22:10,299 --> 00:22:16,240
collection named called IBAs which we

00:22:12,519 --> 00:22:19,100
recently uploaded when it's given as

00:22:16,240 --> 00:22:21,019
second actually too

00:22:19,100 --> 00:22:22,730
and we can now refresh the admin page

00:22:21,019 --> 00:22:24,769
and we can see that the scale this

00:22:22,730 --> 00:22:27,230
collection has been created with one

00:22:24,769 --> 00:22:29,210
shard and placed on a note let's now at

00:22:27,230 --> 00:22:31,909
the second node because we are running

00:22:29,210 --> 00:22:34,039
on a single PC we started the node on

00:22:31,909 --> 00:22:37,460
just a different jelly port and we

00:22:34,039 --> 00:22:39,889
pointed the ZK host parameter to a local

00:22:37,460 --> 00:22:41,840
host 1983 which means that they will it

00:22:39,889 --> 00:22:44,059
will the next node will use the same

00:22:41,840 --> 00:22:47,389
zookeeper which was embedded in this

00:22:44,059 --> 00:22:50,480
first one it started started actually

00:22:47,389 --> 00:22:53,659
and we can see that the number of nodes

00:22:50,480 --> 00:22:56,210
were updated and we can now add a

00:22:53,659 --> 00:22:59,629
replica here so to do that we'll again

00:22:56,210 --> 00:23:02,419
leverage the collections API with a

00:22:59,629 --> 00:23:05,480
command called add replicas we specify

00:23:02,419 --> 00:23:08,059
the shard identifier the collection name

00:23:05,480 --> 00:23:10,669
and we specify the node name on which we

00:23:08,059 --> 00:23:13,100
should create the replicas the thing is

00:23:10,669 --> 00:23:16,429
that solar won't automatically place

00:23:13,100 --> 00:23:18,740
your replica on the node you want it to

00:23:16,429 --> 00:23:20,360
be so that's why you need to specify the

00:23:18,740 --> 00:23:23,299
name of the node you can get the name

00:23:20,360 --> 00:23:26,629
out of the cluster state however it's

00:23:23,299 --> 00:23:28,759
built very easily to guess the name

00:23:26,629 --> 00:23:31,700
because it's an IP address the port

00:23:28,759 --> 00:23:37,039
underscore solar so let's run the

00:23:31,700 --> 00:23:38,750
command ok it executes it and now we can

00:23:37,039 --> 00:23:40,519
look at the admin panel to see what

00:23:38,750 --> 00:23:42,559
happened as we can see we have two

00:23:40,519 --> 00:23:44,240
collections now single leader and the

00:23:42,559 --> 00:23:47,240
second one which is a replica and is

00:23:44,240 --> 00:23:49,490
active and now let's create a third node

00:23:47,240 --> 00:23:53,539
running again on the same PC with a

00:23:49,490 --> 00:23:56,120
different with a different port start it

00:23:53,539 --> 00:23:59,990
and let's create a second replica here

00:23:56,120 --> 00:24:05,899
so we'll have high availability on a

00:23:59,990 --> 00:24:08,809
single PC again collections API were

00:24:05,899 --> 00:24:14,000
used was used and we have it let's look

00:24:08,809 --> 00:24:17,929
at the two replicas oh okay so now a

00:24:14,000 --> 00:24:20,299
little bit of magic let me let's imagine

00:24:17,929 --> 00:24:22,759
that we have a certain use case we've

00:24:20,299 --> 00:24:26,059
indexed our data we don't have our

00:24:22,759 --> 00:24:28,909
initial data available what to do when

00:24:26,059 --> 00:24:30,980
it comes to a time when we don't have

00:24:28,909 --> 00:24:33,180
the capacity of a single node to handle

00:24:30,980 --> 00:24:35,880
data so give us four

00:24:33,180 --> 00:24:38,490
to death which means that it can split

00:24:35,880 --> 00:24:41,250
the shark out of the box let's do that

00:24:38,490 --> 00:24:43,470
let's split our shark into two new ones

00:24:41,250 --> 00:24:46,650
we do that again with a simple API

00:24:43,470 --> 00:24:48,330
command which is the split chart as you

00:24:46,650 --> 00:24:51,030
can see in the bottom we specify the

00:24:48,330 --> 00:24:53,400
collection name and the shark we want to

00:24:51,030 --> 00:24:55,320
split the sample as running that command

00:24:53,400 --> 00:24:58,260
and we'll see in the panel admin panel

00:24:55,320 --> 00:25:01,470
what happened actually

00:24:58,260 --> 00:25:04,350
Saur created two collections to shards

00:25:01,470 --> 00:25:07,020
out of the our initial one the short one

00:25:04,350 --> 00:25:09,480
oh and the short one one of course all

00:25:07,020 --> 00:25:12,450
the replicas were created they are now

00:25:09,480 --> 00:25:15,170
recovering when i refresh it and after

00:25:12,450 --> 00:25:18,000
that you can see that we have three

00:25:15,170 --> 00:25:22,170
sharks being available one the original

00:25:18,000 --> 00:25:22,710
one which is empty and solar left it on

00:25:22,170 --> 00:25:26,360
purpose

00:25:22,710 --> 00:25:29,340
there are many use cases where that's

00:25:26,360 --> 00:25:31,890
how it should be because people still

00:25:29,340 --> 00:25:33,870
run queries against that chart however

00:25:31,890 --> 00:25:36,510
that collection that chart will be empty

00:25:33,870 --> 00:25:39,720
so in the background distributed all the

00:25:36,510 --> 00:25:42,150
data it divided the data in more or less

00:25:39,720 --> 00:25:43,860
health and pushed some of the data to

00:25:42,150 --> 00:25:47,550
one short some of the data to the other

00:25:43,860 --> 00:25:51,240
shot the hash ranges were divided so the

00:25:47,550 --> 00:25:54,150
cluster state is again stable and useful

00:25:51,240 --> 00:25:56,550
and we can now if you want delay delete

00:25:54,150 --> 00:25:59,010
the initial chart and we'll be left with

00:25:56,550 --> 00:26:01,530
two two charts of course on large data

00:25:59,010 --> 00:26:04,230
that can be a painful process but if you

00:26:01,530 --> 00:26:06,600
don't have any other solutions that's

00:26:04,230 --> 00:26:07,440
one of the available let's now look at

00:26:06,600 --> 00:26:12,690
elastic search

00:26:07,440 --> 00:26:15,720
okay so elastic search is this is yes it

00:26:12,690 --> 00:26:17,910
is okay so lastly search is clustered by

00:26:15,720 --> 00:26:19,950
default so if you just start one node

00:26:17,910 --> 00:26:23,640
you will say hey I'm the master of my

00:26:19,950 --> 00:26:25,410
own cluster and what we're going to do

00:26:23,640 --> 00:26:34,830
here is we're going to create a new

00:26:25,410 --> 00:26:38,580
index with two shards and this thing is

00:26:34,830 --> 00:26:39,990
the elastic search head plugin it's a

00:26:38,580 --> 00:26:43,800
small plugin that you can use to

00:26:39,990 --> 00:26:46,080
visualize the state of your cluster in

00:26:43,800 --> 00:26:49,559
this case you can see our node and

00:26:46,080 --> 00:26:51,360
the index with two shots and you can

00:26:49,559 --> 00:26:54,690
also see for each shot there is one

00:26:51,360 --> 00:26:57,720
replica that because the last research

00:26:54,690 --> 00:26:59,730
wants to replicate by default the the

00:26:57,720 --> 00:27:01,440
data once but in this case because we

00:26:59,730 --> 00:27:05,909
only have one note it doesn't make sense

00:27:01,440 --> 00:27:08,700
of the replicas pic are unassigned but

00:27:05,909 --> 00:27:11,220
if we start another note then by default

00:27:08,700 --> 00:27:12,659
it will look through multicast it will

00:27:11,220 --> 00:27:15,630
look to see if there are other notes

00:27:12,659 --> 00:27:18,169
already available and we have one so it

00:27:15,630 --> 00:27:21,649
joins the the cluster of the first note

00:27:18,169 --> 00:27:24,029
and what happens next is that the

00:27:21,649 --> 00:27:33,870
replicas that were previously unassigned

00:27:24,029 --> 00:27:36,450
would be created on the new note so now

00:27:33,870 --> 00:27:43,649
we want to scale out even more so we

00:27:36,450 --> 00:27:46,740
start to other nodes and again they will

00:27:43,649 --> 00:27:50,159
join the cluster and from this point on

00:27:46,740 --> 00:27:55,230
all the shards in the replicas will be

00:27:50,159 --> 00:27:59,639
balanced across the available nodes any

00:27:55,230 --> 00:28:01,620
moment now and this also happens when

00:27:59,639 --> 00:28:04,500
you scale back down so if you shot the

00:28:01,620 --> 00:28:07,169
unloads what happens is that if a

00:28:04,500 --> 00:28:09,139
primary shard is not available then the

00:28:07,169 --> 00:28:12,450
rep one of the replicas will get

00:28:09,139 --> 00:28:15,179
promoted to a primary and new replicas

00:28:12,450 --> 00:28:19,399
will be automatically created so you get

00:28:15,179 --> 00:28:19,399
back to the state that you configured

00:28:22,460 --> 00:28:29,880
and now we should be back to the one

00:28:25,019 --> 00:28:31,860
known situation so this was the overview

00:28:29,880 --> 00:28:37,919
of the features that we wanted to show

00:28:31,860 --> 00:28:40,970
you should I just thank you I want to

00:28:37,919 --> 00:28:43,460
show you from solar and elasticsearch

00:28:40,970 --> 00:28:45,960
but the thing to remember here is that

00:28:43,460 --> 00:28:48,360
both are very active projects are

00:28:45,960 --> 00:28:52,080
supported by strong communities so

00:28:48,360 --> 00:28:54,980
there's juicy stuff always added to both

00:28:52,080 --> 00:28:54,980
search engines

00:28:55,400 --> 00:29:01,790
so to get your some of the new juicy

00:28:59,240 --> 00:29:03,800
things that will happen here so for

00:29:01,790 --> 00:29:06,950
example let's start with solar we have

00:29:03,800 --> 00:29:09,770
the facet from by function issue that is

00:29:06,950 --> 00:29:13,280
being worked on and that will promises

00:29:09,770 --> 00:29:15,710
to give us a possibility of calculating

00:29:13,280 --> 00:29:17,690
facets on the on the values of return of

00:29:15,710 --> 00:29:19,670
return fact by functions so that's

00:29:17,690 --> 00:29:22,040
something with something very very nice

00:29:19,670 --> 00:29:24,950
at least in my opinion will also get

00:29:22,040 --> 00:29:27,380
which is already almost finished the

00:29:24,950 --> 00:29:30,860
analytics component will allow us to do

00:29:27,380 --> 00:29:33,440
more extended analysis or our data so

00:29:30,860 --> 00:29:35,120
solar will be not only search engine

00:29:33,440 --> 00:29:37,970
with some additional functionalities

00:29:35,120 --> 00:29:40,850
when it comes to data mining but also an

00:29:37,970 --> 00:29:43,760
analytics platform finally hopefully

00:29:40,850 --> 00:29:45,950
four five oh and the talks were started

00:29:43,760 --> 00:29:47,870
Seoul will get to a point where

00:29:45,950 --> 00:29:50,059
elasticsearch is right now when it comes

00:29:47,870 --> 00:29:53,210
to handling and installing it will

00:29:50,059 --> 00:29:55,460
become a standalone application just

00:29:53,210 --> 00:29:57,920
like you in silastic search my sequel or

00:29:55,460 --> 00:30:01,520
any other solutions out there so if you

00:29:57,920 --> 00:30:05,510
saw no more web app no apparently it

00:30:01,520 --> 00:30:09,640
will still expose HTTP API because

00:30:05,510 --> 00:30:12,050
that's solar but but no web app there

00:30:09,640 --> 00:30:14,179
when it comes to elastic search the

00:30:12,050 --> 00:30:16,850
thing is remember we mentioned grouping

00:30:14,179 --> 00:30:19,760
so it was already committed the top hits

00:30:16,850 --> 00:30:23,300
aggregation will give us the possibility

00:30:19,760 --> 00:30:25,670
of field collapsing occur grouping on

00:30:23,300 --> 00:30:27,440
this d2 in distributed manner and it's

00:30:25,670 --> 00:30:29,690
coming in one three elastic search was

00:30:27,440 --> 00:30:31,940
committed to master already will have

00:30:29,690 --> 00:30:34,460
the minimum should match on has child

00:30:31,940 --> 00:30:36,260
queries which again is a nice thing at

00:30:34,460 --> 00:30:38,929
least in my opinion we'll be able to

00:30:36,260 --> 00:30:41,059
control that and finally what we wanted

00:30:38,929 --> 00:30:43,280
to say is that filter segregation will

00:30:41,059 --> 00:30:45,980
be also available in elastic search and

00:30:43,280 --> 00:30:48,050
will give us the possibility of using

00:30:45,980 --> 00:30:51,550
filters in aggregation calculating

00:30:48,050 --> 00:30:55,250
aggregations on the basis of the filters

00:30:51,550 --> 00:30:58,250
finally a few words about what to choose

00:30:55,250 --> 00:31:01,580
because those are usually the thing that

00:30:58,250 --> 00:31:04,670
can when a client comes to us and say ok

00:31:01,580 --> 00:31:08,880
which platform to choose and we tend to

00:31:04,670 --> 00:31:12,279
say that they're very small

00:31:08,880 --> 00:31:14,200
very few showstoppers out there to tell

00:31:12,279 --> 00:31:16,450
you that you shouldn't go with that

00:31:14,200 --> 00:31:18,190
solution at all however there are many

00:31:16,450 --> 00:31:20,470
small differences because doors are

00:31:18,190 --> 00:31:23,320
totally different products that's that's

00:31:20,470 --> 00:31:25,259
how it is if you are ready at least in

00:31:23,320 --> 00:31:28,600
our opinion if you already use

00:31:25,259 --> 00:31:31,360
elasticsearch or solar in your company

00:31:28,600 --> 00:31:34,600
on your environment go with it why not

00:31:31,360 --> 00:31:38,799
why bother and chew and tell DevOps

00:31:34,600 --> 00:31:40,629
to you learn different things to learn

00:31:38,799 --> 00:31:43,299
how to scale how to tune how to

00:31:40,629 --> 00:31:45,610
configure it and give them a pain

00:31:43,299 --> 00:31:48,399
actually they will love it for it if

00:31:45,610 --> 00:31:50,289
you'd say I'm going to for elasticsearch

00:31:48,399 --> 00:31:52,330
because we already use it in certain

00:31:50,289 --> 00:31:56,230
products I'm going for solar because of

00:31:52,330 --> 00:31:58,570
the same so in our in at least the work

00:31:56,230 --> 00:32:03,549
with the work we do most projects will

00:31:58,570 --> 00:32:05,950
fit both solar and elasticsearch there

00:32:03,549 --> 00:32:08,440
are some things that can't be achieved

00:32:05,950 --> 00:32:11,700
using one or the other but there are

00:32:08,440 --> 00:32:14,440
very few use cases that will go that way

00:32:11,700 --> 00:32:15,639
what I would like to say is go for the

00:32:14,440 --> 00:32:18,220
one you like the best

00:32:15,639 --> 00:32:21,429
go for the one you are actually familiar

00:32:18,220 --> 00:32:23,440
with maybe and you like to laugh would

00:32:21,429 --> 00:32:26,169
you love to work with but because that's

00:32:23,440 --> 00:32:28,360
what we actually do so if you want to

00:32:26,169 --> 00:32:31,509
work with elasticsearch or solar or both

00:32:28,360 --> 00:32:32,230
we're hiring wherever you are and thank

00:32:31,509 --> 00:32:35,679
you very much

00:32:32,230 --> 00:32:37,659
by the way all the commands and things

00:32:35,679 --> 00:32:39,970
we've used are available on that each

00:32:37,659 --> 00:32:41,679
would have a github account that URL so

00:32:39,970 --> 00:32:43,480
if you want to do the scaling for

00:32:41,679 --> 00:32:46,720
yourself you just run a single command

00:32:43,480 --> 00:32:48,220
and it will download soul elasticsearch

00:32:46,720 --> 00:32:50,590
for you it will run the commands and

00:32:48,220 --> 00:32:52,899
packet index your data and show you the

00:32:50,590 --> 00:32:54,960
scaling stuff thank you very much thank

00:32:52,899 --> 00:32:54,960
you

00:32:59,050 --> 00:33:11,410
okay we rush the gift so if you have any

00:33:02,120 --> 00:33:11,410
questions please just do the rock star

00:33:12,160 --> 00:33:21,560
you know so a question about scalability

00:33:16,690 --> 00:33:23,660
you had so the the video on how to scale

00:33:21,560 --> 00:33:26,360
solar mm-hmm I have the impression that

00:33:23,660 --> 00:33:30,590
you had a single point of failure in

00:33:26,360 --> 00:33:34,100
your in your architecture there the

00:33:30,590 --> 00:33:36,320
zookeeper exact you you can use multiple

00:33:34,100 --> 00:33:38,720
zookeepers this is this was only a

00:33:36,320 --> 00:33:41,960
simplicity for simplicity reasons I've

00:33:38,720 --> 00:33:44,180
run it with the embedded one actually in

00:33:41,960 --> 00:33:46,790
production what would like to do is have

00:33:44,180 --> 00:33:49,100
another example so called with multi

00:33:46,790 --> 00:33:50,990
multiple zookeepers running and talking

00:33:49,100 --> 00:33:53,090
to each other apart apparently to have

00:33:50,990 --> 00:33:55,700
an assemble you need at least three of

00:33:53,090 --> 00:33:59,150
them to be running those are really nice

00:33:55,700 --> 00:34:01,250
and light processes to run and in

00:33:59,150 --> 00:34:05,450
production usually you start with three

00:34:01,250 --> 00:34:07,820
because that's when you can allow one to

00:34:05,450 --> 00:34:11,720
fail and still the example to be

00:34:07,820 --> 00:34:16,190
available solar allows you to give him

00:34:11,720 --> 00:34:18,770
the it the list of of zookeeper

00:34:16,190 --> 00:34:20,480
addresses so there is no a single point

00:34:18,770 --> 00:34:22,070
of failure introduction of course in

00:34:20,480 --> 00:34:24,830
developer mode or something like that or

00:34:22,070 --> 00:34:27,320
like the demo here you don't need em

00:34:24,830 --> 00:34:29,150
extinct some additional cluster of

00:34:27,320 --> 00:34:29,480
zookeepers but that's that's how it

00:34:29,150 --> 00:34:33,320
works

00:34:29,480 --> 00:34:36,620
okay so in your example if if the first

00:34:33,320 --> 00:34:39,200
node was down then your whole cluster

00:34:36,620 --> 00:34:41,120
was down yes yes this is this is how it

00:34:39,200 --> 00:34:43,880
would work in example because we have

00:34:41,120 --> 00:34:46,250
only a single zookeeper in that's why we

00:34:43,880 --> 00:34:48,500
didn't show for simplicity reason what

00:34:46,250 --> 00:34:50,210
happens when the first node was down how

00:34:48,500 --> 00:34:52,910
the replicas are actually taking the

00:34:50,210 --> 00:34:55,010
leader in the leader roles however it

00:34:52,910 --> 00:34:56,540
will happen automatically which solve

00:34:55,010 --> 00:34:59,000
that's that's the whole reason why we

00:34:56,540 --> 00:35:00,440
have replicas right however yeah please

00:34:59,000 --> 00:35:04,040
remember that for production you want

00:35:00,440 --> 00:35:05,840
and extreme external zookeeper and

00:35:04,040 --> 00:35:08,360
sample to be running not the one with

00:35:05,840 --> 00:35:10,250
solar that's not definitive production

00:35:08,360 --> 00:35:12,010
wise thing

00:35:10,250 --> 00:35:14,690
I also want to add something about

00:35:12,010 --> 00:35:17,470
elasticsearch here so what we didn't do

00:35:14,690 --> 00:35:21,200
and we show you the scale thing is that

00:35:17,470 --> 00:35:24,230
for example if we have four clusters and

00:35:21,200 --> 00:35:26,810
four nodes and two can't communicate

00:35:24,230 --> 00:35:29,930
with the other two then you have a split

00:35:26,810 --> 00:35:33,010
brain and that is very nasty so what you

00:35:29,930 --> 00:35:35,990
can do to prevent that is to set up the

00:35:33,010 --> 00:35:38,359
minimum master nodes configuration to

00:35:35,990 --> 00:35:42,650
more than half of your cluster so that

00:35:38,359 --> 00:35:44,750
would what what this does is if on the

00:35:42,650 --> 00:35:48,020
on the side of the split brain there are

00:35:44,750 --> 00:35:52,270
less than that configured manual master

00:35:48,020 --> 00:35:54,950
nodes as in master eligible nodes then

00:35:52,270 --> 00:35:58,420
those nodes will not form a cluster so

00:35:54,950 --> 00:36:02,410
that you you won't have a split brain

00:35:58,420 --> 00:36:02,410
okay any more questions

00:36:03,670 --> 00:36:09,580
No thank you very much and enjoy the

00:36:06,920 --> 00:36:09,580

YouTube URL: https://www.youtube.com/watch?v=LA-rbmuSROM


