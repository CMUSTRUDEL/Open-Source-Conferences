Title: Berlin Buzzwords 2014: Dawid Weiss - Randomize your tests and it will blow your socks off #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	Apache Lucene, Solr and ElasticSearch all utilize the concept of randomized tests. These tests have helped in locating and fixing a number of bugs -- and not just in these projects, but also in third party libraries and JVMs the tests were executed on. 

In this talk I would like to explain what test randomization is about and what kind of tools Lucene, Solr and ElasticSearch use for randomized testing. The ambitious goal is to make you, dear listener, leave the talk with hands burning to implement these ideas in your own projects.

Read more:
https://2014.berlinbuzzwords.de/session/randomize-your-tests-and-it-will-blow-your-socks

About Dawid Weiss 
https://2014.berlinbuzzwords.de/user/277/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,790 --> 00:00:14,949
alright so we will start a little bit

00:00:10,690 --> 00:00:17,289
out of time good afternoon my name is

00:00:14,949 --> 00:00:20,529
David vice I work for carrot search and

00:00:17,289 --> 00:00:24,610
let me quickly quickly introduce myself

00:00:20,529 --> 00:00:27,340
so I like coding I like cycling I like

00:00:24,610 --> 00:00:30,040
baking cheesecake but most of all I like

00:00:27,340 --> 00:00:32,439
just to chill which seems to be a family

00:00:30,040 --> 00:00:36,280
feature because my son somehow inherited

00:00:32,439 --> 00:00:38,070
it we're doomed man anyway uh today I'd

00:00:36,280 --> 00:00:40,690
like to tell you a little bit about the

00:00:38,070 --> 00:00:43,839
testing paradigm found in lucene

00:00:40,690 --> 00:00:47,230
elasticsearch and solar which is based

00:00:43,839 --> 00:00:50,859
on randomizing tests randomizing how

00:00:47,230 --> 00:00:53,800
they execute so this talk is actually

00:00:50,859 --> 00:00:55,809
going to be shorter than my planned I

00:00:53,800 --> 00:00:58,300
thought it would last like 40 minutes

00:00:55,809 --> 00:01:00,489
and I only got 20 so we will have to

00:00:58,300 --> 00:01:03,309
fast forward a little bit some of the

00:01:00,489 --> 00:01:04,930
slides later on but basically I'd like

00:01:03,309 --> 00:01:07,090
to tell you a little bit about what

00:01:04,930 --> 00:01:11,200
randomized testing is and how we use it

00:01:07,090 --> 00:01:16,170
in the scene what the foundations are so

00:01:11,200 --> 00:01:19,840
the introduction as a historical node

00:01:16,170 --> 00:01:27,610
which leads me to the conclusion of the

00:01:19,840 --> 00:01:29,200
introduction which is you know it's

00:01:27,610 --> 00:01:32,380
really serious about those 40 minutes

00:01:29,200 --> 00:01:35,200
anyway so the unit tests like I said

00:01:32,380 --> 00:01:36,820
before uh you know they have they serve

00:01:35,200 --> 00:01:39,220
three purposes they increase the

00:01:36,820 --> 00:01:40,840
confidence in implementations so if you

00:01:39,220 --> 00:01:43,690
wrote the unit test you ran your

00:01:40,840 --> 00:01:44,920
software it passes it diffuses your

00:01:43,690 --> 00:01:46,870
confidence in your tests in your

00:01:44,920 --> 00:01:49,600
implementation obviously there is a

00:01:46,870 --> 00:01:50,740
correlation obviously well we think

00:01:49,600 --> 00:01:52,390
there is a correlation between the

00:01:50,740 --> 00:01:55,690
number of unit tests and the reliability

00:01:52,390 --> 00:01:57,070
in the software and most of all it

00:01:55,690 --> 00:01:58,630
provides insurance against future

00:01:57,070 --> 00:01:59,980
changes so if you change something in

00:01:58,630 --> 00:02:02,230
your code and you have lots of unit

00:01:59,980 --> 00:02:05,800
tests covering a lot of you know code

00:02:02,230 --> 00:02:07,870
execution paths you can kind of rely on

00:02:05,800 --> 00:02:09,940
future changes if something interview to

00:02:07,870 --> 00:02:12,610
change changes either you change it or

00:02:09,940 --> 00:02:15,040
somebody else changes it and those tests

00:02:12,610 --> 00:02:18,489
still pass you can be confident that the

00:02:15,040 --> 00:02:21,370
software is still okay but there's there

00:02:18,489 --> 00:02:23,260
is a big problem namely unit tests

00:02:21,370 --> 00:02:24,220
relying on assumptions you by writing

00:02:23,260 --> 00:02:26,200
unit tests you

00:02:24,220 --> 00:02:28,930
typically embed your own assumptions

00:02:26,200 --> 00:02:32,050
about the world and the software and

00:02:28,930 --> 00:02:35,200
this really doesn't match with the real

00:02:32,050 --> 00:02:38,020
world offers so for instance if I give

00:02:35,200 --> 00:02:42,220
you this snippet of code and watch this

00:02:38,020 --> 00:02:43,720
the hardware zoom ah if I show you this

00:02:42,220 --> 00:02:46,390
snippet of code can you tell me can you

00:02:43,720 --> 00:02:48,730
see it in the back all right can you

00:02:46,390 --> 00:02:52,600
tell me if this can ever had failed like

00:02:48,730 --> 00:02:56,050
what what's the catch here okay the

00:02:52,600 --> 00:02:59,500
catch is this function this this one

00:02:56,050 --> 00:03:01,180
math apps like the absolute value of a

00:02:59,500 --> 00:03:04,420
number of an integer what's the catch

00:03:01,180 --> 00:03:07,120
the catch is math apps can actually

00:03:04,420 --> 00:03:09,430
return a negative number which many

00:03:07,120 --> 00:03:12,310
people wouldn't think possible right but

00:03:09,430 --> 00:03:14,530
if you pass it min value there is no

00:03:12,310 --> 00:03:16,720
positive counterpart of min value within

00:03:14,530 --> 00:03:18,910
the inter Ainge so it just returns the

00:03:16,720 --> 00:03:20,560
min value so apps is not returning a

00:03:18,910 --> 00:03:22,060
positive number it returns the negative

00:03:20,560 --> 00:03:24,310
number and this example can actually

00:03:22,060 --> 00:03:26,440
fail with an array index out of bounds

00:03:24,310 --> 00:03:30,910
exception which you know is like what

00:03:26,440 --> 00:03:32,890
but it can happen so generalizing this a

00:03:30,910 --> 00:03:34,930
bit what you think about your code

00:03:32,890 --> 00:03:36,250
depicted here with this blue rectangle

00:03:34,930 --> 00:03:38,320
and what do you think about your

00:03:36,250 --> 00:03:41,769
assertions depicted here with the red

00:03:38,320 --> 00:03:44,560
you know lines and circles these are far

00:03:41,769 --> 00:03:48,459
off from what the real world is actually

00:03:44,560 --> 00:03:51,340
like I mean the test still passes it

00:03:48,459 --> 00:03:54,220
just does things that you wouldn't think

00:03:51,340 --> 00:03:55,930
are at actually happening or it doesn't

00:03:54,220 --> 00:03:58,630
do things that you think it should be

00:03:55,930 --> 00:04:00,820
doing so just to you know just to make a

00:03:58,630 --> 00:04:03,370
parallel to the real world you you ride

00:04:00,820 --> 00:04:04,870
a car and you listen to song listen to

00:04:03,370 --> 00:04:07,209
this song and radio and you have this

00:04:04,870 --> 00:04:09,970
heavenly you know female voice and you

00:04:07,209 --> 00:04:12,310
have this perceptual image of this girl

00:04:09,970 --> 00:04:16,169
sing in it but then it turns out it's

00:04:12,310 --> 00:04:19,479
the Eurovision Eurovision winner of

00:04:16,169 --> 00:04:22,930
Conchita forest which you know amazingly

00:04:19,479 --> 00:04:25,810
it's just it's like an improbable event

00:04:22,930 --> 00:04:27,940
you know but it all goes well with

00:04:25,810 --> 00:04:30,280
Murphy's Law I mean you know if if there

00:04:27,940 --> 00:04:31,690
is if there's an improbable chance of

00:04:30,280 --> 00:04:34,419
something happening it will eventually

00:04:31,690 --> 00:04:36,750
happen and it will eventually happen in

00:04:34,419 --> 00:04:39,610
your code at the wrong moment

00:04:36,750 --> 00:04:42,069
so we will try to kind of face this

00:04:39,610 --> 00:04:43,930
problem and provide an answer for it

00:04:42,069 --> 00:04:47,169
with randomized testing what is

00:04:43,930 --> 00:04:51,190
randomized testing first of all it is

00:04:47,169 --> 00:04:54,190
not a priority i'm shifting because

00:04:51,190 --> 00:04:56,139
people are afraid of departing from what

00:04:54,190 --> 00:04:58,240
they know so they know unit tests they

00:04:56,139 --> 00:05:00,699
are afraid of departing from those

00:04:58,240 --> 00:05:02,830
familar et zone they are you know

00:05:00,699 --> 00:05:04,930
comfortable in their own of in their

00:05:02,830 --> 00:05:07,330
domain of unit tests and they don't want

00:05:04,930 --> 00:05:09,099
to try anything else it's not a paradigm

00:05:07,330 --> 00:05:11,190
shift there are still unit tests there

00:05:09,099 --> 00:05:16,479
are just a slightly different ones and

00:05:11,190 --> 00:05:18,729
and another thing randomized test in

00:05:16,479 --> 00:05:21,580
randomized testing it's not mutation

00:05:18,729 --> 00:05:24,370
based so there is no uncontrolled

00:05:21,580 --> 00:05:27,310
changes introduced to your software you

00:05:24,370 --> 00:05:29,320
are in full control over what that

00:05:27,310 --> 00:05:31,449
randomized test would like will actually

00:05:29,320 --> 00:05:33,009
be doing the only thing changing is that

00:05:31,449 --> 00:05:35,110
there is a seed of randomness and there

00:05:33,009 --> 00:05:37,720
is some you know random choices of

00:05:35,110 --> 00:05:39,669
components of data but you still are in

00:05:37,720 --> 00:05:42,190
control over what's being randomized

00:05:39,669 --> 00:05:43,449
which is contrary to the pie test for

00:05:42,190 --> 00:05:47,680
instance if you know the package pie

00:05:43,449 --> 00:05:50,020
test it's not what pie test is doing so

00:05:47,680 --> 00:05:52,570
what is randomizing randomized testing

00:05:50,020 --> 00:05:56,080
about what's the main points of it well

00:05:52,570 --> 00:05:58,780
there are three first ideally we would

00:05:56,080 --> 00:06:01,539
like our tests to run a different

00:05:58,780 --> 00:06:04,090
execution path on every execution so

00:06:01,539 --> 00:06:07,419
every execution will run a different set

00:06:04,090 --> 00:06:10,060
of you know code paths through your

00:06:07,419 --> 00:06:12,460
program this is done by either

00:06:10,060 --> 00:06:15,099
substituting components of runtime or

00:06:12,460 --> 00:06:17,050
substituting data diversifying data fed

00:06:15,099 --> 00:06:21,520
to the program how it's done I'll show

00:06:17,050 --> 00:06:24,639
you in a bit the next thing is each run

00:06:21,520 --> 00:06:27,009
has to be deterministic so it's

00:06:24,639 --> 00:06:29,380
randomized but it's not random it's

00:06:27,009 --> 00:06:31,810
pseudo randomness you know if you start

00:06:29,380 --> 00:06:33,940
from the same initial seed of this

00:06:31,810 --> 00:06:36,460
randomness every single execution is

00:06:33,940 --> 00:06:39,880
repeatable should be repeatable you know

00:06:36,460 --> 00:06:42,699
in an ideal case and then the third

00:06:39,880 --> 00:06:44,889
point is since this it's essentially a

00:06:42,699 --> 00:06:47,710
stochastic process so every single

00:06:44,889 --> 00:06:50,300
execution will be different and you just

00:06:47,710 --> 00:06:52,449
need a lot of samples over the search

00:06:50,300 --> 00:06:55,220
so you need to run those builds

00:06:52,449 --> 00:06:58,069
continuously over and over on a build

00:06:55,220 --> 00:07:00,979
server it's not just on commit run the

00:06:58,069 --> 00:07:02,960
test it's over and over again because it

00:07:00,979 --> 00:07:05,150
increases your coverage it increases the

00:07:02,960 --> 00:07:07,550
you know the coverage of the search

00:07:05,150 --> 00:07:09,789
space of those randomized parameters

00:07:07,550 --> 00:07:12,830
that you're going to put in your code a

00:07:09,789 --> 00:07:14,030
valid question would be why not just

00:07:12,830 --> 00:07:15,979
test everything like all the

00:07:14,030 --> 00:07:17,449
combinations of you know inputs all the

00:07:15,979 --> 00:07:20,000
combinations of components and the

00:07:17,449 --> 00:07:21,830
answer is it's typically just not

00:07:20,000 --> 00:07:24,379
possible I mean there's just so many of

00:07:21,830 --> 00:07:26,990
them that you know the search space is

00:07:24,379 --> 00:07:29,300
so large that the taste that the test

00:07:26,990 --> 00:07:32,360
would take forever to execute so we're

00:07:29,300 --> 00:07:35,449
going to sample from this space and run

00:07:32,360 --> 00:07:38,270
those tests at a fraction of the cost

00:07:35,449 --> 00:07:40,069
and still kind of ensure that they work

00:07:38,270 --> 00:07:41,870
maybe not on the first run maybe not in

00:07:40,069 --> 00:07:44,360
the second but eventually you know the

00:07:41,870 --> 00:07:51,259
worst thing conchita wurst will happen I

00:07:44,360 --> 00:07:55,430
mean something will happen so um now

00:07:51,259 --> 00:07:58,210
let's get down to the bottom of it what

00:07:55,430 --> 00:08:01,940
can we randomize at the unit test level

00:07:58,210 --> 00:08:03,770
and how can we assert what can we you

00:08:01,940 --> 00:08:07,580
know what type of assertions can we add

00:08:03,770 --> 00:08:09,440
to our code that somehow verify whether

00:08:07,580 --> 00:08:11,509
to test actually execute it in the right

00:08:09,440 --> 00:08:13,250
way if the inputs are randomized so if

00:08:11,509 --> 00:08:14,719
the inputs are changing how do we add

00:08:13,250 --> 00:08:18,830
assertions that are verifying that

00:08:14,719 --> 00:08:22,490
something went right or wrong let's

00:08:18,830 --> 00:08:24,080
first handle the first part so the most

00:08:22,490 --> 00:08:27,229
obvious thing that we can randomize is

00:08:24,080 --> 00:08:30,139
our input data iteration counts and

00:08:27,229 --> 00:08:33,560
arguments if you have a component that

00:08:30,139 --> 00:08:35,829
accepts a string don't feed it just esky

00:08:33,560 --> 00:08:40,370
I characters you know don't feed it just

00:08:35,829 --> 00:08:43,449
ABC feed it a random Unicode sequence of

00:08:40,370 --> 00:08:46,820
characters that is valid but not obvious

00:08:43,449 --> 00:08:49,070
if you have a component that has in the

00:08:46,820 --> 00:08:51,529
contract that the methods can be called

00:08:49,070 --> 00:08:53,420
an arbitrary order to call it in

00:08:51,529 --> 00:08:56,690
arbitrary order you know randomize the

00:08:53,420 --> 00:08:59,149
the sequence of method calls and let it

00:08:56,690 --> 00:09:01,279
run I mean you know don't hardcode just

00:08:59,149 --> 00:09:03,829
one particular sequence let it run

00:09:01,279 --> 00:09:04,150
randomly if you if you have other our

00:09:03,829 --> 00:09:06,250
game

00:09:04,150 --> 00:09:09,310
is that are possibly constrained but

00:09:06,250 --> 00:09:12,430
from a range of values randomize them

00:09:09,310 --> 00:09:15,550
run the tests here we have some examples

00:09:12,430 --> 00:09:18,640
from leucine for instance the iteration

00:09:15,550 --> 00:09:20,200
counts ah you know we picked them at

00:09:18,640 --> 00:09:22,330
random if there is something that runs

00:09:20,200 --> 00:09:23,950
that can run many times we pick at

00:09:22,330 --> 00:09:26,470
random the number of times that it you

00:09:23,950 --> 00:09:29,890
know is invoked with and run it the same

00:09:26,470 --> 00:09:32,800
thing goes with the parameters you know

00:09:29,890 --> 00:09:34,750
we picked somehow we pick random strings

00:09:32,800 --> 00:09:37,090
somehow we pick simple strings somehow

00:09:34,750 --> 00:09:40,480
we pick sometimes we pick longer strings

00:09:37,090 --> 00:09:42,340
it all it's all within the constraints

00:09:40,480 --> 00:09:45,070
and within contracts of a given

00:09:42,340 --> 00:09:48,280
component but tries to search the whole

00:09:45,070 --> 00:09:49,870
space of possible possibilities the next

00:09:48,280 --> 00:09:52,510
thing you can randomize is software

00:09:49,870 --> 00:09:54,010
components an interface is a prime

00:09:52,510 --> 00:09:56,500
example of this if you have an interface

00:09:54,010 --> 00:10:00,190
there should be multiple implementations

00:09:56,500 --> 00:10:03,310
of that interface do substitute those

00:10:00,190 --> 00:10:06,040
implementations at test time so that a

00:10:03,310 --> 00:10:08,040
test written for an interface is not

00:10:06,040 --> 00:10:10,540
just running against this one particular

00:10:08,040 --> 00:10:13,240
implementation but it's being fed with

00:10:10,540 --> 00:10:15,730
different configuration of you know

00:10:13,240 --> 00:10:17,860
implementations of those interfaces with

00:10:15,730 --> 00:10:20,470
one interface this is pretty obvious but

00:10:17,860 --> 00:10:22,270
if you have multiple interfaces in your

00:10:20,470 --> 00:10:24,910
program and multiple implementations in

00:10:22,270 --> 00:10:27,190
your program again the search space the

00:10:24,910 --> 00:10:29,980
number of different configurations goes

00:10:27,190 --> 00:10:31,900
sky-high and then you the only thing you

00:10:29,980 --> 00:10:36,790
can do is actually probe those random

00:10:31,900 --> 00:10:38,950
configurations of components lastly the

00:10:36,790 --> 00:10:40,740
environment you know this is this is the

00:10:38,950 --> 00:10:43,750
most obvious thing to randomize

00:10:40,740 --> 00:10:46,780
randomized locale randomize the time

00:10:43,750 --> 00:10:48,940
zone the JVM itself you know sometimes

00:10:46,780 --> 00:10:52,120
the JVM is the source of a bug that you

00:10:48,940 --> 00:10:53,410
don't know if the operating system if

00:10:52,120 --> 00:10:56,070
you're running on Windows it will behave

00:10:53,410 --> 00:11:00,040
differently from other operating systems

00:10:56,070 --> 00:11:04,260
anywhere in the world so our exceptional

00:11:00,040 --> 00:11:07,480
triggers you can also add some like

00:11:04,260 --> 00:11:09,940
bonus things like IO like cause random

00:11:07,480 --> 00:11:11,740
i/o problems or network problems but

00:11:09,940 --> 00:11:15,370
these are far advanced for this talk so

00:11:11,740 --> 00:11:17,889
I'm not gonna dealt there now how to

00:11:15,370 --> 00:11:20,259
assert on those randomized you know

00:11:17,889 --> 00:11:23,350
puts what how do we build assertions

00:11:20,259 --> 00:11:25,269
there are a few ways to handle that

00:11:23,350 --> 00:11:28,959
first if you have a component if you

00:11:25,269 --> 00:11:31,059
have a piece of software and you have a

00:11:28,959 --> 00:11:33,549
number of different implementations

00:11:31,059 --> 00:11:35,350
again either a naive implementation or a

00:11:33,549 --> 00:11:39,339
previous version of a component that is

00:11:35,350 --> 00:11:41,379
not optimized feet the same input to

00:11:39,339 --> 00:11:42,730
both of these and compared the outputs

00:11:41,379 --> 00:11:44,439
you don't know you don't need to know

00:11:42,730 --> 00:11:45,999
what these outputs are they just need to

00:11:44,439 --> 00:11:48,189
be identical you know if you have a

00:11:45,999 --> 00:11:50,290
sorting algorithm feed it with the

00:11:48,189 --> 00:11:54,429
sequence of integers it should be sorted

00:11:50,290 --> 00:11:57,759
in the output the next thing you can do

00:11:54,429 --> 00:12:00,759
is sanity checks so what this boils down

00:11:57,759 --> 00:12:03,660
to is basically throw some and your

00:12:00,759 --> 00:12:05,769
software and wait for it to hit the fan

00:12:03,660 --> 00:12:08,499
basically that's what it is you know you

00:12:05,769 --> 00:12:10,569
randomize the input throw it at your

00:12:08,499 --> 00:12:12,910
program and wait for an insertion to

00:12:10,569 --> 00:12:15,669
happen if it happens correct the bug if

00:12:12,910 --> 00:12:18,879
it doesn't happen fine you know nothing

00:12:15,669 --> 00:12:21,009
nothing wasted and lastly you can do

00:12:18,879 --> 00:12:22,779
nothing and this is the you know the

00:12:21,009 --> 00:12:25,149
stronger version is the previous one

00:12:22,779 --> 00:12:28,329
which is you don't assert on anything

00:12:25,149 --> 00:12:30,730
you just wait for an unchecked exception

00:12:28,329 --> 00:12:33,669
for a JVM crash which happens a lot in

00:12:30,730 --> 00:12:35,470
the scene if you're tracking the build

00:12:33,669 --> 00:12:37,629
logs it's surprising how the world

00:12:35,470 --> 00:12:41,860
actually spins with all the JVM bugs

00:12:37,629 --> 00:12:44,110
that we discover notoriously all right

00:12:41,860 --> 00:12:47,019
so that was the theory now the practice

00:12:44,110 --> 00:12:48,040
if you take a look at the scene there

00:12:47,019 --> 00:12:50,079
are a number of quality assurance

00:12:48,040 --> 00:12:52,269
components some of them divided between

00:12:50,079 --> 00:12:54,189
the static checks and the runtime checks

00:12:52,269 --> 00:12:56,799
static checks over we'll be talking

00:12:54,189 --> 00:13:00,009
about so I'll skip these and runtime

00:12:56,799 --> 00:13:01,809
checks are we have a number of rules in

00:13:00,009 --> 00:13:03,610
lucene test case that are really

00:13:01,809 --> 00:13:05,799
interesting if you're if you haven't

00:13:03,610 --> 00:13:07,869
seen a really complex your unit system

00:13:05,799 --> 00:13:11,289
lucene test case is the class to take a

00:13:07,869 --> 00:13:13,059
look at there are rules for detecting

00:13:11,289 --> 00:13:14,769
static memory leaks stray threads

00:13:13,059 --> 00:13:16,239
temporary file cleanups it starts with

00:13:14,769 --> 00:13:18,160
such a lots of interesting things there

00:13:16,239 --> 00:13:20,589
I just don't have the time to cover them

00:13:18,160 --> 00:13:24,189
all the one I would like to focus on is

00:13:20,589 --> 00:13:26,350
randomized runner which is r.j. unit run

00:13:24,189 --> 00:13:28,269
therefore running tests so it's

00:13:26,350 --> 00:13:30,369
essentially something that runs takes

00:13:28,269 --> 00:13:31,550
your J unit tests and runs them what

00:13:30,369 --> 00:13:34,640
were the goals for this

00:13:31,550 --> 00:13:37,130
 first of all compatibility so if

00:13:34,640 --> 00:13:39,860
you know j unit you can run those

00:13:37,130 --> 00:13:41,420
randomized tests there's nothing special

00:13:39,860 --> 00:13:44,839
about it the only thing you need to do

00:13:41,420 --> 00:13:48,019
is to add one annotation the second

00:13:44,839 --> 00:13:51,649
thing is it provides some helpers that

00:13:48,019 --> 00:13:53,959
you know help you to organize this work

00:13:51,649 --> 00:13:56,240
with randomized testing first of all it

00:13:53,959 --> 00:13:59,269
picks the random seed the initial random

00:13:56,240 --> 00:14:01,040
seed for every test and the second thing

00:13:59,269 --> 00:14:02,120
is it provides you with that seat

00:14:01,040 --> 00:14:05,089
otherwise you wouldn't know how to

00:14:02,120 --> 00:14:07,279
repeat a test in case of a failure there

00:14:05,089 --> 00:14:09,740
is also other things that are part of

00:14:07,279 --> 00:14:11,959
the package that I won't be going into

00:14:09,740 --> 00:14:13,730
because it's a 20-minute talk but if

00:14:11,959 --> 00:14:17,540
you're interested catch me somewhere and

00:14:13,730 --> 00:14:20,870
I'll gladly explain them to you so an

00:14:17,540 --> 00:14:23,990
example an example we have two classes

00:14:20,870 --> 00:14:27,620
here I know if you can see them can you

00:14:23,990 --> 00:14:30,920
okay we have two classes here are six

00:14:27,620 --> 00:14:32,660
Tests that the what makes it run with

00:14:30,920 --> 00:14:34,399
the randomized runner is the annotation

00:14:32,660 --> 00:14:37,279
on top it's the standard j unit

00:14:34,399 --> 00:14:40,040
annotation run with provided with the

00:14:37,279 --> 00:14:43,270
randomized runner class that runs those

00:14:40,040 --> 00:14:46,640
tests in that randomized environment and

00:14:43,270 --> 00:14:49,459
what even this does is you know if you

00:14:46,640 --> 00:14:51,980
run it in eclipse three times every

00:14:49,459 --> 00:14:55,190
single time you run it you notice that

00:14:51,980 --> 00:14:57,709
the order of tests the order of test

00:14:55,190 --> 00:15:00,829
methods changes so if you compare the

00:14:57,709 --> 00:15:03,459
first one to the second one to the third

00:15:00,829 --> 00:15:06,860
one every execution is different and

00:15:03,459 --> 00:15:09,560
what it depends on is it depends on this

00:15:06,860 --> 00:15:11,089
master seed that was picked by the

00:15:09,560 --> 00:15:13,399
framework at the beginning of the

00:15:11,089 --> 00:15:15,770
execution of the test so this master

00:15:13,399 --> 00:15:19,279
seed here is different from this one is

00:15:15,770 --> 00:15:21,709
different from this one and what

00:15:19,279 --> 00:15:24,079
important is if you pick the same master

00:15:21,709 --> 00:15:25,820
seed over and over the execution the

00:15:24,079 --> 00:15:28,399
order of those methods will remain the

00:15:25,820 --> 00:15:30,589
same so it's predictable it's

00:15:28,399 --> 00:15:34,579
pseudonymous it's not you know random

00:15:30,589 --> 00:15:36,680
it's pseudo-random but you get you you

00:15:34,579 --> 00:15:41,089
get the control over which starting see

00:15:36,680 --> 00:15:42,949
that starts from okay so you would

00:15:41,089 --> 00:15:44,930
probably want to utilize this this

00:15:42,949 --> 00:15:48,200
randomness somehow since you're

00:15:44,930 --> 00:15:50,180
you're about to write a random test this

00:15:48,200 --> 00:15:53,020
is how it's done it can be done in a

00:15:50,180 --> 00:15:55,310
number of ways you know with those

00:15:53,020 --> 00:15:58,070
utility methods so you don't have to

00:15:55,310 --> 00:16:01,430
know anything about the internals or you

00:15:58,070 --> 00:16:03,980
can explicitly call for the randomized

00:16:01,430 --> 00:16:05,380
context which is the context that

00:16:03,980 --> 00:16:07,850
provides you with those random

00:16:05,380 --> 00:16:09,860
generators random number generators and

00:16:07,850 --> 00:16:11,600
then you get a random and then you just

00:16:09,860 --> 00:16:15,140
use that random you know you just pick

00:16:11,600 --> 00:16:16,670
whatever values or whatever inputs you

00:16:15,140 --> 00:16:19,760
want for your program and run your

00:16:16,670 --> 00:16:22,430
program with those values here we have

00:16:19,760 --> 00:16:24,680
an example that asserts true on a random

00:16:22,430 --> 00:16:26,660
variable what should this test do well

00:16:24,680 --> 00:16:31,370
it should Tet it should fail on every

00:16:26,660 --> 00:16:32,959
other run right so if we run it in

00:16:31,370 --> 00:16:35,450
eclipse chances are it will run

00:16:32,959 --> 00:16:38,180
successfully but from time to time it

00:16:35,450 --> 00:16:40,490
will fail and now comes an important

00:16:38,180 --> 00:16:43,190
part of the framework because if a test

00:16:40,490 --> 00:16:45,709
fails you need to know what the master

00:16:43,190 --> 00:16:47,660
seed was otherwise you won't be able to

00:16:45,709 --> 00:16:51,230
repeat the same sequence of operations

00:16:47,660 --> 00:16:54,320
and what's cool about it is that any

00:16:51,230 --> 00:16:56,150
exception thrown from a unit test with

00:16:54,320 --> 00:16:59,630
the randomized runner you know running

00:16:56,150 --> 00:17:02,930
above it will have this synthetic stack

00:16:59,630 --> 00:17:06,260
trace entry that contains the seed which

00:17:02,930 --> 00:17:08,780
is here so all you need to know is this

00:17:06,260 --> 00:17:11,030
seed and then repeat the test and it

00:17:08,780 --> 00:17:12,740
should predictably run in the same way

00:17:11,030 --> 00:17:15,860
and it should be able to figure out what

00:17:12,740 --> 00:17:17,540
was wrong if your test never ends which

00:17:15,860 --> 00:17:19,819
means you know it hung somewhere it's

00:17:17,540 --> 00:17:21,740
froze somewhere you can still get the

00:17:19,819 --> 00:17:23,689
seed because you can ping it and you can

00:17:21,740 --> 00:17:26,209
dump all the stack traces and one of the

00:17:23,689 --> 00:17:30,220
threads will have the seed in its name

00:17:26,209 --> 00:17:33,740
so we can still get the seed even though

00:17:30,220 --> 00:17:40,130
what is it safe haven 15 minutes I like

00:17:33,740 --> 00:17:42,260
you so uh alright so now once you've hit

00:17:40,130 --> 00:17:43,850
a failure you have to face the ball I

00:17:42,260 --> 00:17:46,700
mean you have to face the bout and

00:17:43,850 --> 00:17:49,610
sometimes the bug or the boo will turn

00:17:46,700 --> 00:17:51,830
your world upside down ah but you do

00:17:49,610 --> 00:17:54,020
have a chance of reproducing it right

00:17:51,830 --> 00:17:56,900
you know the master seed all you need to

00:17:54,020 --> 00:17:58,460
do is fix the master seat either with an

00:17:56,900 --> 00:18:01,280
annotation on top of a class

00:17:58,460 --> 00:18:04,160
or bypassing assistant property with the

00:18:01,280 --> 00:18:05,990
seed embedded in it you can also repeat

00:18:04,160 --> 00:18:08,120
the framework allows you to repeat a

00:18:05,990 --> 00:18:10,940
unit test a number of times so if you

00:18:08,120 --> 00:18:13,790
run this ah take a look at the slide

00:18:10,940 --> 00:18:17,050
it's the repetition of that single test

00:18:13,790 --> 00:18:19,640
20 times over with different seeds

00:18:17,050 --> 00:18:22,190
starting from the one you've provided so

00:18:19,640 --> 00:18:24,620
this this seed is identical to what

00:18:22,190 --> 00:18:27,260
we've provided in the annotation every

00:18:24,620 --> 00:18:29,270
other one is different they are split

00:18:27,260 --> 00:18:31,550
between the static context and instance

00:18:29,270 --> 00:18:34,130
context i'm not going to go there but

00:18:31,550 --> 00:18:35,750
every other execution is different and

00:18:34,130 --> 00:18:38,060
you can see that you know pretty much

00:18:35,750 --> 00:18:40,100
fifty percent of the test failed this is

00:18:38,060 --> 00:18:42,980
a good information because it means that

00:18:40,100 --> 00:18:45,110
your test is failing sometimes and it's

00:18:42,980 --> 00:18:49,280
running sometimes you know it's it's

00:18:45,110 --> 00:18:51,290
randomly failing now if we fix both both

00:18:49,280 --> 00:18:54,230
of those seeds the instance level and

00:18:51,290 --> 00:18:58,400
the master seed and rerunning again see

00:18:54,230 --> 00:19:01,130
the seeds are all constant and now the

00:18:58,400 --> 00:19:02,540
test is always failing and this is again

00:19:01,130 --> 00:19:04,970
an important information because it

00:19:02,540 --> 00:19:07,430
means that your test is failing

00:19:04,970 --> 00:19:09,830
predictably for that particular seed if

00:19:07,430 --> 00:19:12,080
it if there were some successes here

00:19:09,830 --> 00:19:14,240
that would mean you're screwed because

00:19:12,080 --> 00:19:15,860
your test is not really relying on the

00:19:14,240 --> 00:19:17,540
source of randomness from the framework

00:19:15,860 --> 00:19:20,090
it's also relying on some other

00:19:17,540 --> 00:19:21,890
information that is outside which means

00:19:20,090 --> 00:19:25,880
you know it's pretty it's really random

00:19:21,890 --> 00:19:29,420
it's unpredictable so what are the

00:19:25,880 --> 00:19:33,380
downsides of randomizing tests are there

00:19:29,420 --> 00:19:36,260
are a number first sometimes it's really

00:19:33,380 --> 00:19:38,690
hard to achieve or participate

00:19:36,260 --> 00:19:41,060
especially with tests that rely on

00:19:38,690 --> 00:19:43,190
multiple threads that are you know have

00:19:41,060 --> 00:19:45,890
race conditions that are time-based or

00:19:43,190 --> 00:19:49,280
something like that for these it's going

00:19:45,890 --> 00:19:51,170
to be difficult second there may be some

00:19:49,280 --> 00:19:52,820
incompatible random component

00:19:51,170 --> 00:19:54,860
configurations which you'll have to

00:19:52,820 --> 00:19:57,200
ignore and this happens tutorial in the

00:19:54,860 --> 00:19:59,600
scene like some component configurations

00:19:57,200 --> 00:20:02,240
just last forever or doesn't work at all

00:19:59,600 --> 00:20:05,420
and we just assumption ignore them so we

00:20:02,240 --> 00:20:08,360
ignore them at runtime and finally those

00:20:05,420 --> 00:20:11,180
randomized tests are pretty hairy like

00:20:08,360 --> 00:20:12,380
you know you try to debug something that

00:20:11,180 --> 00:20:14,180
looks like this and

00:20:12,380 --> 00:20:16,610
is a random input for a test like a

00:20:14,180 --> 00:20:18,740
parameter or something try to debug it

00:20:16,610 --> 00:20:23,360
it's just sometimes it's you know it's

00:20:18,740 --> 00:20:25,850
difficult to take to somehow capture the

00:20:23,360 --> 00:20:28,220
sanity in this randomized chaos that is

00:20:25,850 --> 00:20:32,480
randomized test another example is the

00:20:28,220 --> 00:20:35,990
JVM bug if you hit a JVM bag which again

00:20:32,480 --> 00:20:38,450
we really do reproducing that is a

00:20:35,990 --> 00:20:41,120
nightmare because the you know the

00:20:38,450 --> 00:20:43,340
assortment of components and the data

00:20:41,120 --> 00:20:46,160
involved is random you didn't write it

00:20:43,340 --> 00:20:49,070
it just generated itself and this is

00:20:46,160 --> 00:20:51,290
like an in like in line tree from a

00:20:49,070 --> 00:20:54,560
method that notoriously fails for us and

00:20:51,290 --> 00:20:58,460
nobody knows how to fix it nobody not us

00:20:54,560 --> 00:21:02,530
not JVM developers you know I rebooted

00:20:58,460 --> 00:21:07,190
myself a few times that's what it was

00:21:02,530 --> 00:21:10,640
all right so to sum it up I hope those

00:21:07,190 --> 00:21:13,070
20 minutes gave you some kind of flavor

00:21:10,640 --> 00:21:15,260
and that you're interested in this topic

00:21:13,070 --> 00:21:17,030
and that you'll take a look at those

00:21:15,260 --> 00:21:19,400
randomized tests either in lucini

00:21:17,030 --> 00:21:20,750
elasticsearch or somewhere else they

00:21:19,400 --> 00:21:22,400
allow you to explore the complex

00:21:20,750 --> 00:21:25,430
boundary conditions found the software

00:21:22,400 --> 00:21:28,280
and they're really really neat I mean

00:21:25,430 --> 00:21:31,940
they found bugs that you know nobody

00:21:28,280 --> 00:21:34,790
else thought were possible what are the

00:21:31,940 --> 00:21:36,950
downsides the failures once you hit them

00:21:34,790 --> 00:21:40,550
there are sometimes really difficult to

00:21:36,950 --> 00:21:43,670
debug or reproduce and the ugly parts

00:21:40,550 --> 00:21:46,250
are within the framework itself so blame

00:21:43,670 --> 00:21:47,870
me because I wrote most of it ah there

00:21:46,250 --> 00:21:49,640
are some problems with repeating with

00:21:47,870 --> 00:21:53,300
the different master seed and most of

00:21:49,640 --> 00:21:55,310
all some people just hate it I mean you

00:21:53,300 --> 00:21:58,220
know you get something that every every

00:21:55,310 --> 00:21:59,950
time you run it is running differently

00:21:58,220 --> 00:22:02,450
and some people don't like this kind of

00:21:59,950 --> 00:22:04,700
uncomfortable feeling that every test

00:22:02,450 --> 00:22:06,070
run is I don't know sorting methods in a

00:22:04,700 --> 00:22:09,560
different order or something like that

00:22:06,070 --> 00:22:11,720
so it's not for everyone but if you're

00:22:09,560 --> 00:22:16,600
keen on trying please do let me know how

00:22:11,720 --> 00:22:16,600
it went thanks Fabian

00:22:21,530 --> 00:22:26,780
now he's going to say we don't have time

00:22:23,420 --> 00:22:30,290
for questions he's gonna not going to

00:22:26,780 --> 00:22:32,270
say anything ok ah great thank you very

00:22:30,290 --> 00:22:33,830
much for your talk again as you might

00:22:32,270 --> 00:22:37,940
know of course we don't have time for

00:22:33,830 --> 00:22:40,010
questions I'm sorry but as David already

00:22:37,940 --> 00:22:41,950
said if you have any questions just grab

00:22:40,010 --> 00:22:45,860
them outside today are you here tomorrow

00:22:41,950 --> 00:22:47,720
I'm here tomorrow and all day today so

00:22:45,860 --> 00:22:51,520
you have a lot of time just get him

00:22:47,720 --> 00:22:51,520

YouTube URL: https://www.youtube.com/watch?v=-uVE_w8flIU


