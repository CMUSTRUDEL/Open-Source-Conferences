Title: Berlin Buzzwords 2014: Robert Muir - Apache Lucene 4 #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	Apache Lucene is an open-source search engine library written in Java. This talk will give an overview of its current capabilities.

This talk will give an up-to-date overview of Lucene's features. Many improvements have been added since the last revision of Lucene in Action (e.g. autosuggest and faceting), and many previous talks about these incremental improvements, but the idea is to summarize the current state of what Lucene can do.
 
Read more:
https://2014.berlinbuzzwords.de/session/apache-lucene-4

About Robert Muir:
https://2014.berlinbuzzwords.de/user/297/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,670 --> 00:00:10,210
this tall kind of tries to say this is

00:00:08,290 --> 00:00:12,010
Lucy now and this is what we can do I

00:00:10,210 --> 00:00:14,770
can't talk about everything it can do

00:00:12,010 --> 00:00:17,050
because there's too much but we can kind

00:00:14,770 --> 00:00:18,400
of get into the major areas and if you

00:00:17,050 --> 00:00:20,460
haven't usually seen then you might have

00:00:18,400 --> 00:00:25,540
an idea of what this thing is all about

00:00:20,460 --> 00:00:27,940
so just to start this is my idea will

00:00:25,540 --> 00:00:30,070
will overview loose teen so if you

00:00:27,940 --> 00:00:31,630
download this thing and unzip it that's

00:00:30,070 --> 00:00:33,719
what we're going to talk about what are

00:00:31,630 --> 00:00:35,829
the different folders and what can it do

00:00:33,719 --> 00:00:39,399
afterwards I'll just make some general

00:00:35,829 --> 00:00:40,629
conclusions and then we'll have QA we

00:00:39,399 --> 00:00:44,289
can dig into anything that you're

00:00:40,629 --> 00:00:46,179
interested in so again if you download

00:00:44,289 --> 00:00:48,730
bluestein you're going to see a list of

00:00:46,179 --> 00:00:51,190
stuff like this there's actually

00:00:48,730 --> 00:00:52,659
probably 15 or 20 of these but we don't

00:00:51,190 --> 00:00:54,399
have all the time in the world so we'll

00:00:52,659 --> 00:00:55,780
just do some of them but these are

00:00:54,399 --> 00:00:57,280
basically the different modules of

00:00:55,780 --> 00:01:00,429
leucine it used to be that you had

00:00:57,280 --> 00:01:02,769
leucine core and kind of everything was

00:01:00,429 --> 00:01:05,229
shoved in there and then you had various

00:01:02,769 --> 00:01:06,909
contributions that were external but

00:01:05,229 --> 00:01:08,920
we've tried to organize it so it makes

00:01:06,909 --> 00:01:11,680
more sense in losing four and this is

00:01:08,920 --> 00:01:13,479
what it looks like so we'll kind of go

00:01:11,680 --> 00:01:16,360
through the important ones here starting

00:01:13,479 --> 00:01:18,790
with losing core so the leucine core

00:01:16,360 --> 00:01:20,649
library this is the minimal you need to

00:01:18,790 --> 00:01:22,539
do anything related to search with

00:01:20,649 --> 00:01:24,310
leucine the other stuff is kind of

00:01:22,539 --> 00:01:28,780
optional but but this one's mandatory

00:01:24,310 --> 00:01:30,789
and we'll talk about why so at the basic

00:01:28,780 --> 00:01:33,039
level this is what we're trying to solve

00:01:30,789 --> 00:01:35,439
here the ability to type in some

00:01:33,039 --> 00:01:38,430
keywords like this and and get search

00:01:35,439 --> 00:01:41,350
results very fast they're relevant so

00:01:38,430 --> 00:01:45,549
the key parts of this are a fast

00:01:41,350 --> 00:01:47,109
response time irrelevant results and you

00:01:45,549 --> 00:01:49,270
know everything else is sort of a bonus

00:01:47,109 --> 00:01:53,079
so this is this is what search is all

00:01:49,270 --> 00:01:55,810
about here so how does this work how is

00:01:53,079 --> 00:01:57,549
it fast well the main reason it would be

00:01:55,810 --> 00:01:59,469
fast first to say a database because we

00:01:57,549 --> 00:02:02,020
just searched say billions of web pages

00:01:59,469 --> 00:02:04,570
very quickly is that we have inverted

00:02:02,020 --> 00:02:06,369
index and the index is sort of like back

00:02:04,570 --> 00:02:08,500
of a book you turn to the back of the

00:02:06,369 --> 00:02:10,630
book and you find your search term

00:02:08,500 --> 00:02:11,770
because you sort of know that there you

00:02:10,630 --> 00:02:13,599
know the words in the back of the book

00:02:11,770 --> 00:02:15,519
are in a certain order they make sense

00:02:13,599 --> 00:02:17,380
and then once you find your term then

00:02:15,519 --> 00:02:19,510
you have a list of pages that it appear

00:02:17,380 --> 00:02:21,730
and this is actually exactly what's

00:02:19,510 --> 00:02:24,610
happening with leucine and that's all

00:02:21,730 --> 00:02:28,990
it's doing so you can do it manually or

00:02:24,610 --> 00:02:31,530
you can use listening to do it so this

00:02:28,990 --> 00:02:34,480
process of creating this reverse index

00:02:31,530 --> 00:02:36,340
this is what leucine court does it can

00:02:34,480 --> 00:02:39,360
do it pretty fast you can use multiple

00:02:36,340 --> 00:02:41,680
threads to do it this this all works

00:02:39,360 --> 00:02:43,390
with some hardware you can get like

00:02:41,680 --> 00:02:45,640
speeds like 200 gigabytes per hour which

00:02:43,390 --> 00:02:47,590
is pretty fast it does depend on the

00:02:45,640 --> 00:02:50,050
size of your documents and the type of

00:02:47,590 --> 00:02:51,190
processing you're doing what your speed

00:02:50,050 --> 00:02:53,350
will be and we'll talk about some of

00:02:51,190 --> 00:02:56,530
that processing later but in general

00:02:53,350 --> 00:02:58,300
it's pretty fast one thing about it is

00:02:56,530 --> 00:03:00,040
you don't just build this one time like

00:02:58,300 --> 00:03:02,350
I have my book let's build an index for

00:03:00,040 --> 00:03:04,690
it you can sort of do this incrementally

00:03:02,350 --> 00:03:07,180
so you can as you're writing your book

00:03:04,690 --> 00:03:08,620
you know you're also updating the index

00:03:07,180 --> 00:03:12,190
and this is important you can also

00:03:08,620 --> 00:03:13,870
delete things as well so this this sort

00:03:12,190 --> 00:03:16,360
of is different than the old batch model

00:03:13,870 --> 00:03:19,210
and we've seen sort of grown to be very

00:03:16,360 --> 00:03:21,100
well at near real-time search so when

00:03:19,210 --> 00:03:24,970
new documents are coming in there

00:03:21,100 --> 00:03:27,280
they're searchable very quickly beyond

00:03:24,970 --> 00:03:29,470
full text like we think of this is the

00:03:27,280 --> 00:03:31,300
classical I our problem of search but

00:03:29,470 --> 00:03:34,030
these days people have structured data

00:03:31,300 --> 00:03:36,340
is very common so you have numeric

00:03:34,030 --> 00:03:37,870
fields you have dates and listing has

00:03:36,340 --> 00:03:40,330
support for for doing search with these

00:03:37,870 --> 00:03:42,520
kind of things as well so it's it's more

00:03:40,330 --> 00:03:44,740
than just a text search you can use it

00:03:42,520 --> 00:03:48,240
actually to zoo kind of a mix of

00:03:44,740 --> 00:03:50,500
structured data and unstructured data so

00:03:48,240 --> 00:03:53,200
let's talk about how we might customize

00:03:50,500 --> 00:03:55,420
this process probably the most important

00:03:53,200 --> 00:03:57,550
part is called the analysis chain and

00:03:55,420 --> 00:03:59,050
what this does is this this is the rules

00:03:57,550 --> 00:04:00,730
for when we're creating this index in

00:03:59,050 --> 00:04:02,740
the back of the book this is the rule

00:04:00,730 --> 00:04:04,570
for what is going in there when we take

00:04:02,740 --> 00:04:06,010
a document or a page of a document how

00:04:04,570 --> 00:04:07,810
do we determine what should go in the

00:04:06,010 --> 00:04:09,520
index which words are important which

00:04:07,810 --> 00:04:11,140
ones aren't important you know how

00:04:09,520 --> 00:04:12,940
should they be listed there and that

00:04:11,140 --> 00:04:14,290
that's what this is all about and so

00:04:12,940 --> 00:04:15,820
this is probably the most important part

00:04:14,290 --> 00:04:17,650
to understand about leucine if you want

00:04:15,820 --> 00:04:20,200
to improve your search results because

00:04:17,650 --> 00:04:23,770
this is what it's all about so analysis

00:04:20,200 --> 00:04:25,900
is at a basic level we think of taking a

00:04:23,770 --> 00:04:27,580
page and we want to get the words out of

00:04:25,900 --> 00:04:31,050
it words are pretty good features for

00:04:27,580 --> 00:04:33,240
search and so on the first

00:04:31,050 --> 00:04:35,310
for this is a tokenizer how can we split

00:04:33,240 --> 00:04:37,680
it into words you know a simple one is

00:04:35,310 --> 00:04:39,539
to split on white space for it for some

00:04:37,680 --> 00:04:42,659
cases but we might also want to do more

00:04:39,539 --> 00:04:44,940
we split in two we split into words but

00:04:42,659 --> 00:04:46,110
this isn't quite enough you know we may

00:04:44,940 --> 00:04:48,720
want people to be able to type in

00:04:46,110 --> 00:04:50,430
uppercase or lowercase and in these kind

00:04:48,720 --> 00:04:53,539
of fancy things so so we might do some

00:04:50,430 --> 00:04:56,550
normalization and processing as well and

00:04:53,539 --> 00:04:57,960
this is all language dependent so there

00:04:56,550 --> 00:05:00,150
are some language independent techniques

00:04:57,960 --> 00:05:02,039
but generally for each language you have

00:05:00,150 --> 00:05:06,180
a different strategy and we'll talk

00:05:02,039 --> 00:05:07,860
about what loosing does here so again we

00:05:06,180 --> 00:05:09,599
start with a tokenizer we need to split

00:05:07,860 --> 00:05:12,389
things into words that's the job of the

00:05:09,599 --> 00:05:13,979
tokenizer and we've seen and then to do

00:05:12,389 --> 00:05:16,050
the normalization we have token filters

00:05:13,979 --> 00:05:18,060
and so when I talk about an analysis

00:05:16,050 --> 00:05:19,919
chain it means you have a combination of

00:05:18,060 --> 00:05:22,560
these things you have a tokenizer and

00:05:19,919 --> 00:05:23,789
some filters it's not mandatory to have

00:05:22,560 --> 00:05:25,110
any of the filters you can just have a

00:05:23,789 --> 00:05:26,909
tokenizer you can keep things very

00:05:25,110 --> 00:05:29,840
simple it's probably a good place to

00:05:26,909 --> 00:05:32,520
start but you got to have something so

00:05:29,840 --> 00:05:34,889
here's an example tokenizer just to

00:05:32,520 --> 00:05:36,779
illustrate what I'm talking about so we

00:05:34,889 --> 00:05:39,000
have we have a small document it's just

00:05:36,779 --> 00:05:40,650
one sentence and we just want to split

00:05:39,000 --> 00:05:43,050
it into words this is all it's going to

00:05:40,650 --> 00:05:44,880
do so there is one of leucine called the

00:05:43,050 --> 00:05:46,440
whitespace tokenizer and then there's

00:05:44,880 --> 00:05:48,539
there's 20 more some of them are very

00:05:46,440 --> 00:05:51,180
fancy and complicated and some like this

00:05:48,539 --> 00:05:53,159
one are very simple but in this case

00:05:51,180 --> 00:05:56,039
this one does a pretty good job it's

00:05:53,159 --> 00:05:58,110
almost exactly what we want for the

00:05:56,039 --> 00:06:00,180
token filter again we want to do some

00:05:58,110 --> 00:06:01,349
normalization the the words that I split

00:06:00,180 --> 00:06:03,509
weren't quite good enough for search

00:06:01,349 --> 00:06:05,789
because we want people to type in you

00:06:03,509 --> 00:06:08,400
know uppercase lowercase we maybe don't

00:06:05,789 --> 00:06:11,159
want to have worried about plural forms

00:06:08,400 --> 00:06:12,509
versus singular forms and so we have

00:06:11,159 --> 00:06:15,330
some filters that can do this we have a

00:06:12,509 --> 00:06:17,039
lowercase filter and it lower cases

00:06:15,330 --> 00:06:21,029
these words that were in uppercase and

00:06:17,039 --> 00:06:24,180
we have a stomach laurels or try to and

00:06:21,029 --> 00:06:26,400
so there's there's almost a hundred of

00:06:24,180 --> 00:06:28,349
these filters in the scene to do various

00:06:26,400 --> 00:06:29,810
tasks so it's really flexible what you

00:06:28,349 --> 00:06:31,830
can do when you build this chain of

00:06:29,810 --> 00:06:34,259
processing and you can say I went to

00:06:31,830 --> 00:06:38,009
first do synonyms and lowercase stop

00:06:34,259 --> 00:06:39,509
words whatever you want to do so you can

00:06:38,009 --> 00:06:40,800
also write your own you can plug in if

00:06:39,509 --> 00:06:43,199
you don't like what we have but I think

00:06:40,800 --> 00:06:46,009
generally we found that what we have in

00:06:43,199 --> 00:06:49,199
lucene is enough for a lot of use cases

00:06:46,009 --> 00:06:50,909
so again we can think of this list of

00:06:49,199 --> 00:06:52,949
tokenizer xand token filters as an

00:06:50,909 --> 00:06:56,639
analysis chain we call that enlisting

00:06:52,949 --> 00:06:58,740
the analyzer and this analyzer is is

00:06:56,639 --> 00:07:01,199
usually a next time and it's also used a

00:06:58,740 --> 00:07:03,509
query time so when the documents come in

00:07:01,199 --> 00:07:04,949
we analyze them when the queries come in

00:07:03,509 --> 00:07:07,319
we also analyze them as if they were

00:07:04,949 --> 00:07:10,319
documents and and and that's how search

00:07:07,319 --> 00:07:12,719
works that's how we have search terms so

00:07:10,319 --> 00:07:15,659
for the different languages we have 35

00:07:12,719 --> 00:07:18,060
languages in the scene out of box so you

00:07:15,659 --> 00:07:19,560
may find that it does enough for it

00:07:18,060 --> 00:07:21,060
doesn't but it's better

00:07:19,560 --> 00:07:24,509
internationalization support than

00:07:21,060 --> 00:07:28,050
previous versions of leucine so um you

00:07:24,509 --> 00:07:29,099
know this will be useful for you so now

00:07:28,050 --> 00:07:31,159
that we've talked about the analysis

00:07:29,099 --> 00:07:33,330
chain there's a little bit more involved

00:07:31,159 --> 00:07:37,589
we want to take these queries from the

00:07:33,330 --> 00:07:42,509
user but we don't want to have to you

00:07:37,589 --> 00:07:44,669
know define rules to the user like SQL

00:07:42,509 --> 00:07:47,459
where the user has to type the you know

00:07:44,669 --> 00:07:49,860
special syntax to get their results how

00:07:47,459 --> 00:07:51,690
should this work you know if you if you

00:07:49,860 --> 00:07:53,520
have unpaired punctuation in Google does

00:07:51,690 --> 00:07:56,279
it give you an error or does it just

00:07:53,520 --> 00:07:58,169
continue to give you results but in some

00:07:56,279 --> 00:08:00,240
cases you know maybe you do care you're

00:07:58,169 --> 00:08:02,279
very specific about what you want and

00:08:00,240 --> 00:08:04,199
you do want this error like SQL so

00:08:02,279 --> 00:08:05,699
English seeing we give you we give you

00:08:04,199 --> 00:08:08,550
both ways to do things and I'll talk

00:08:05,699 --> 00:08:10,110
about that and basically unlike other

00:08:08,550 --> 00:08:13,830
search engines we've seen does not have

00:08:10,110 --> 00:08:16,289
a query language we have several and you

00:08:13,830 --> 00:08:18,500
can write your own so it's not hardwired

00:08:16,289 --> 00:08:22,289
into leucine and this is a big benefit

00:08:18,500 --> 00:08:23,639
so again back to our index let's start

00:08:22,289 --> 00:08:26,339
to think about how queries could be

00:08:23,639 --> 00:08:28,229
built from this index we have our search

00:08:26,339 --> 00:08:30,959
terms and our list of documents

00:08:28,229 --> 00:08:34,169
associated with each one and I'll make

00:08:30,959 --> 00:08:35,699
an example here circuit in parallel and

00:08:34,169 --> 00:08:37,560
we can take these lists and think about

00:08:35,699 --> 00:08:40,289
how you would do say in or query or an

00:08:37,560 --> 00:08:42,630
end query or not query and it's the

00:08:40,289 --> 00:08:45,390
obvious choice is just if we want to do

00:08:42,630 --> 00:08:47,279
an or then we will Union the lists if we

00:08:45,390 --> 00:08:49,410
want to do an end we intersect them and

00:08:47,279 --> 00:08:50,010
for not it's just subtraction so it's

00:08:49,410 --> 00:08:52,410
working

00:08:50,010 --> 00:08:54,360
sets right so in this case we just

00:08:52,410 --> 00:08:56,730
created sort of three queries for our

00:08:54,360 --> 00:09:00,930
back of the book index that we wrote on

00:08:56,730 --> 00:09:02,820
a piece of paper and now we have queries

00:09:00,930 --> 00:09:05,490
and we've seen has api's for this to do

00:09:02,820 --> 00:09:07,710
end or not programmatically so you don't

00:09:05,490 --> 00:09:10,680
have to use a query language but it's

00:09:07,710 --> 00:09:12,360
much nicer to use one because instead of

00:09:10,680 --> 00:09:14,520
you know having to write an API each

00:09:12,360 --> 00:09:16,230
time the user can actually use these you

00:09:14,520 --> 00:09:18,900
know special syntax like the plus sign

00:09:16,230 --> 00:09:20,310
in Google or and or whatnot and so we

00:09:18,900 --> 00:09:23,130
have two ways again the strict one

00:09:20,310 --> 00:09:25,260
throws an exception like SQL and then a

00:09:23,130 --> 00:09:27,270
lenient one that's that doesn't it just

00:09:25,260 --> 00:09:28,950
does the best it can takes a guest at

00:09:27,270 --> 00:09:31,080
what the user wants which is more like

00:09:28,950 --> 00:09:37,230
Google or if you're not happy with this

00:09:31,080 --> 00:09:39,360
build your own another feature pretty

00:09:37,230 --> 00:09:42,510
important is is we we did the search at

00:09:39,360 --> 00:09:44,400
return the documents but why and and do

00:09:42,510 --> 00:09:45,930
I care about this document how do I know

00:09:44,400 --> 00:09:49,170
without actually reading the document

00:09:45,930 --> 00:09:50,310
it's like chicken in the egg so you know

00:09:49,170 --> 00:09:51,900
an important feature is called

00:09:50,310 --> 00:09:54,030
highlighting and what this does is it

00:09:51,900 --> 00:09:56,190
allows you to make relevance judgment as

00:09:54,030 --> 00:09:58,440
a user is this document relevant to my

00:09:56,190 --> 00:09:59,970
search or not it's really important so

00:09:58,440 --> 00:10:01,440
there's two main features of this that

00:09:59,970 --> 00:10:03,810
that are key to think about and that's

00:10:01,440 --> 00:10:06,090
the snippets these are sort of the

00:10:03,810 --> 00:10:08,340
sentences I'm choosing for this document

00:10:06,090 --> 00:10:09,750
and then the search terms themselves the

00:10:08,340 --> 00:10:11,400
this is highlighting what the user

00:10:09,750 --> 00:10:14,790
actually typed in so they see the

00:10:11,400 --> 00:10:18,320
context in lucene we have three

00:10:14,790 --> 00:10:20,640
highlighters they all have different

00:10:18,320 --> 00:10:21,870
sort of feature sets different

00:10:20,640 --> 00:10:24,450
capabilities use different data

00:10:21,870 --> 00:10:25,770
structures and algorithms it depends on

00:10:24,450 --> 00:10:27,330
your use case I'd recommend just using

00:10:25,770 --> 00:10:29,760
the one called highlighter as a start

00:10:27,330 --> 00:10:31,170
but you know you have other choices you

00:10:29,760 --> 00:10:33,600
can do you can customize how these

00:10:31,170 --> 00:10:35,400
sentences are picked you can customize

00:10:33,600 --> 00:10:37,830
how the search terms are highlighted

00:10:35,400 --> 00:10:40,170
should they be bold or colored red and

00:10:37,830 --> 00:10:41,610
things like that so you have a lot of

00:10:40,170 --> 00:10:43,230
flexibility all the highlighters have

00:10:41,610 --> 00:10:48,270
these features but they work slightly

00:10:43,230 --> 00:10:50,460
differently for four different cases so

00:10:48,270 --> 00:10:52,860
we talked about search and entering in

00:10:50,460 --> 00:10:55,740
keywords it turns out these days this

00:10:52,860 --> 00:10:57,840
isn't enough like users don't type

00:10:55,740 --> 00:10:58,770
things correctly users may be don't even

00:10:57,840 --> 00:11:01,770
know what they're searching for

00:10:58,770 --> 00:11:03,379
completely so it would be good if as

00:11:01,770 --> 00:11:04,849
soon as I start typing characters

00:11:03,379 --> 00:11:06,589
we can start to give them relevant

00:11:04,849 --> 00:11:08,509
information even if that's just

00:11:06,589 --> 00:11:10,129
suggesting what they may want to type or

00:11:08,509 --> 00:11:12,229
actually giving them instant search with

00:11:10,129 --> 00:11:13,970
documents so when we've seen we kind of

00:11:12,229 --> 00:11:15,949
think about a suggest package where

00:11:13,970 --> 00:11:17,839
we're we're suggesting things to the

00:11:15,949 --> 00:11:19,819
user this might be what you want right

00:11:17,839 --> 00:11:22,249
and so we're going to suggest either

00:11:19,819 --> 00:11:24,139
queries or did you mean try to correct

00:11:22,249 --> 00:11:25,939
your query and these are two features I

00:11:24,139 --> 00:11:28,909
think are expected these days of any

00:11:25,939 --> 00:11:30,859
search engine so we start with suggest I

00:11:28,909 --> 00:11:32,269
think everyone's seen this you know you

00:11:30,859 --> 00:11:35,019
go into google and you type in a few

00:11:32,269 --> 00:11:37,849
words and we've already completed with

00:11:35,019 --> 00:11:38,689
Berlin buzzwords just typing be you so

00:11:37,849 --> 00:11:42,019
that's that's kind of interesting

00:11:38,689 --> 00:11:43,159
buzzers is getting pretty popular but we

00:11:42,019 --> 00:11:46,639
can do this english teen we have the

00:11:43,159 --> 00:11:48,109
same feature for auto suggest and it has

00:11:46,639 --> 00:11:50,149
a lot of power and a lot of flexibility

00:11:48,109 --> 00:11:53,359
one is that analysis ching i talked

00:11:50,149 --> 00:11:54,979
about the suggester can use that so you

00:11:53,359 --> 00:11:57,049
can actually implement all those rules

00:11:54,979 --> 00:11:59,809
like do I want it to be case sensitive

00:11:57,049 --> 00:12:01,970
or not do I want to remove accents and

00:11:59,809 --> 00:12:04,249
things like this so the analysis chain

00:12:01,970 --> 00:12:05,899
plugs in to the suggester and this is a

00:12:04,249 --> 00:12:08,299
powerful combination I don't recommend

00:12:05,899 --> 00:12:10,519
anything crazy with it but it's it's

00:12:08,299 --> 00:12:13,279
enough that you can tweak the behavior a

00:12:10,519 --> 00:12:14,659
good deal another thing that has that

00:12:13,279 --> 00:12:17,989
sort of separate from this is the

00:12:14,659 --> 00:12:19,879
ability to correct typos so you know I i

00:12:17,989 --> 00:12:21,049
misspelled things all the time and so I

00:12:19,879 --> 00:12:23,479
always appreciate it when the auto

00:12:21,049 --> 00:12:26,509
suggester just corrects my spelling is

00:12:23,479 --> 00:12:29,359
this makes life so much easier this can

00:12:26,509 --> 00:12:31,069
also be kind of risky you could you can

00:12:29,359 --> 00:12:33,259
bring back bad suggestions so you have

00:12:31,069 --> 00:12:35,089
to be careful about it but we do we do

00:12:33,259 --> 00:12:37,489
offer the the option and leucine to do

00:12:35,089 --> 00:12:39,649
this and then finally there's sort of

00:12:37,489 --> 00:12:41,419
another way to correct errors and that's

00:12:39,649 --> 00:12:43,579
I put the words in the completely wrong

00:12:41,419 --> 00:12:46,129
order we can think of that as in fixed

00:12:43,579 --> 00:12:47,539
suggestions so that's it happens

00:12:46,129 --> 00:12:49,009
occasionally with google it seems kind

00:12:47,539 --> 00:12:51,379
of rare but you're typing in keywords

00:12:49,009 --> 00:12:53,419
and then it just suggested you one right

00:12:51,379 --> 00:12:55,579
in the middle and sort of reorganizes

00:12:53,419 --> 00:12:59,329
the order of the words you typed in but

00:12:55,579 --> 00:13:02,119
this can be useful in some cases finally

00:12:59,329 --> 00:13:04,220
you know there's the idea of suggesting

00:13:02,119 --> 00:13:06,049
queries to the user but sometimes we

00:13:04,220 --> 00:13:07,849
want to suggest we want to attach a

00:13:06,049 --> 00:13:11,119
little bit more like if we're doing

00:13:07,849 --> 00:13:12,679
Facebook and we do auto-suggest why not

00:13:11,119 --> 00:13:13,999
show their picture you know why not have

00:13:12,679 --> 00:13:15,499
a linked right to their Facebook page

00:13:13,999 --> 00:13:16,940
why should I actually have to search

00:13:15,499 --> 00:13:19,550
don't suggest a queer

00:13:16,940 --> 00:13:20,990
you just suggest the person to me so you

00:13:19,550 --> 00:13:22,880
can attach something called a payload

00:13:20,990 --> 00:13:25,010
for example the idea of the document or

00:13:22,880 --> 00:13:26,420
a link to their photo or whatever and

00:13:25,010 --> 00:13:30,860
you can do this with the scene the same

00:13:26,420 --> 00:13:33,200
way and finally one part about

00:13:30,860 --> 00:13:36,200
suggesting is tricky is what about this

00:13:33,200 --> 00:13:37,880
order of the suggestions coming back you

00:13:36,200 --> 00:13:39,800
know this is really important to get the

00:13:37,880 --> 00:13:42,080
right order because usually users are

00:13:39,800 --> 00:13:43,970
they're looking at this as a type and in

00:13:42,080 --> 00:13:45,380
the ones you know closest to them or

00:13:43,970 --> 00:13:48,980
might be the ones they're going to pick

00:13:45,380 --> 00:13:51,830
so you have this idea that we can kind

00:13:48,980 --> 00:13:53,000
of define a scoring algorithm for for

00:13:51,830 --> 00:13:54,830
how these things should be ranked and

00:13:53,000 --> 00:13:56,360
leucine leaves that to you and we have

00:13:54,830 --> 00:13:58,640
this module called expressions that

00:13:56,360 --> 00:14:02,720
allows you to define that and we'll talk

00:13:58,640 --> 00:14:04,160
about that in a little bit so i talked

00:14:02,720 --> 00:14:06,460
about suggests we have the idea of did

00:14:04,160 --> 00:14:08,750
you mean this is sort of after the fact

00:14:06,460 --> 00:14:10,460
old-school spell checking i think it's

00:14:08,750 --> 00:14:12,530
it's sort of less useful then then

00:14:10,460 --> 00:14:13,580
suggest the idea is if you can catch it

00:14:12,530 --> 00:14:16,160
while they're typing it that's better

00:14:13,580 --> 00:14:17,660
but sometimes you know it Google

00:14:16,160 --> 00:14:19,610
suggests something to me I just ignore

00:14:17,660 --> 00:14:21,620
it and keep typing my wrong stuff anyway

00:14:19,610 --> 00:14:23,660
and it'll say okay really did you mean

00:14:21,620 --> 00:14:24,800
this or maybe even I i went ahead and

00:14:23,660 --> 00:14:26,480
searched on this for you because i

00:14:24,800 --> 00:14:29,450
really think you screwed it up so

00:14:26,480 --> 00:14:31,400
instead of returning zero results this

00:14:29,450 --> 00:14:33,260
still has a use case right you may not

00:14:31,400 --> 00:14:35,960
want to return zero results so you can

00:14:33,260 --> 00:14:38,840
just say did you mean this and it's it's

00:14:35,960 --> 00:14:40,520
something more useful to the user we can

00:14:38,840 --> 00:14:42,470
do sort of the same similar algorithms

00:14:40,520 --> 00:14:44,720
and we've seen you can use in grams

00:14:42,470 --> 00:14:47,030
through to do this kind of correction

00:14:44,720 --> 00:14:48,320
here you can use edit distance so

00:14:47,030 --> 00:14:50,720
there's different ways to figure out how

00:14:48,320 --> 00:14:52,220
to correct typos and you sort of can

00:14:50,720 --> 00:14:53,900
choose what those are well one thing

00:14:52,220 --> 00:14:56,930
that's interesting is is when the words

00:14:53,900 --> 00:14:58,250
themselves you know our have spaces sort

00:14:56,930 --> 00:15:00,260
of speak they typed in not just

00:14:58,250 --> 00:15:02,210
misspelled words but you know the the

00:15:00,260 --> 00:15:03,680
words aren't even correct an example of

00:15:02,210 --> 00:15:05,450
this is I you know if i type buzzwords

00:15:03,680 --> 00:15:08,300
and put a space in it we all know

00:15:05,450 --> 00:15:09,650
buzzwords doesn't have one here but you

00:15:08,300 --> 00:15:11,330
know if you do this actually Google will

00:15:09,650 --> 00:15:14,420
bring back Berlin buzzwords it will work

00:15:11,330 --> 00:15:19,339
fine so this is like a form of spell

00:15:14,420 --> 00:15:21,200
correction so controlling the ranking of

00:15:19,339 --> 00:15:22,730
this stuff with the search engine we

00:15:21,200 --> 00:15:25,310
have this built-in ranking that's you

00:15:22,730 --> 00:15:27,530
know sort of based on how close the

00:15:25,310 --> 00:15:29,180
aquarius to the document but for all to

00:15:27,530 --> 00:15:30,590
suggest how should this work you know

00:15:29,180 --> 00:15:33,290
how should we rank things and

00:15:30,590 --> 00:15:35,090
the idea here is that you just define

00:15:33,290 --> 00:15:37,400
the formula yourself we don't know it

00:15:35,090 --> 00:15:38,870
usually depends on your use case so this

00:15:37,400 --> 00:15:40,610
is sort of a newer module added in

00:15:38,870 --> 00:15:43,010
loosing for and I'll give an example

00:15:40,610 --> 00:15:45,320
search here I go into Google Maps and

00:15:43,010 --> 00:15:48,010
just search for beer this is actually a

00:15:45,320 --> 00:15:50,510
query that I have run recently but uh

00:15:48,010 --> 00:15:52,280
look at you know on the side it comes

00:15:50,510 --> 00:15:53,840
back with these with these documents you

00:15:52,280 --> 00:15:55,700
know these are places I can get beer

00:15:53,840 --> 00:15:57,980
what is the ranking how did they figure

00:15:55,700 --> 00:15:59,600
this out is it based on how close they

00:15:57,980 --> 00:16:02,030
are to me is it based on how many

00:15:59,600 --> 00:16:04,190
reviews that each one had and what was

00:16:02,030 --> 00:16:05,750
the average rating I have no idea maybe

00:16:04,190 --> 00:16:07,910
some combination of those things and

00:16:05,750 --> 00:16:09,080
practiced right all these different you

00:16:07,910 --> 00:16:10,970
know things that contribute to the

00:16:09,080 --> 00:16:12,710
relevance of each one well this is sort

00:16:10,970 --> 00:16:14,960
of what the expressions module is about

00:16:12,710 --> 00:16:18,230
is allowing you to just define something

00:16:14,960 --> 00:16:20,120
like that yourself in JavaScript so you

00:16:18,230 --> 00:16:21,980
can come by and say leucine score some

00:16:20,120 --> 00:16:24,320
numeric field you have like like rating

00:16:21,980 --> 00:16:26,450
or popularity and your and you can even

00:16:24,320 --> 00:16:28,910
do things like geographic distance just

00:16:26,450 --> 00:16:30,380
like this example so I'll give a fake

00:16:28,910 --> 00:16:31,880
version I don't know that this is their

00:16:30,380 --> 00:16:34,400
ranking algorithm is something I made up

00:16:31,880 --> 00:16:37,040
but this you know take the average

00:16:34,400 --> 00:16:39,110
rating multiply it by you know number of

00:16:37,040 --> 00:16:41,060
ratings / distance something like that

00:16:39,110 --> 00:16:43,190
this this is what this package does and

00:16:41,060 --> 00:16:45,020
what and when you do it and you created

00:16:43,190 --> 00:16:46,850
it it's not it's not slow like

00:16:45,020 --> 00:16:49,340
JavaScript it uses the language but we

00:16:46,850 --> 00:16:50,660
we compile it to java bytecodes so it's

00:16:49,340 --> 00:16:52,850
the same as if you win and leucine and

00:16:50,660 --> 00:16:55,730
extend it a bunch of classes yourself in

00:16:52,850 --> 00:17:02,270
Java and wrote your own sort algorithm

00:16:55,730 --> 00:17:05,510
so it's very fast so we talked about

00:17:02,270 --> 00:17:07,970
suggestions we've talked about basic

00:17:05,510 --> 00:17:09,230
searching highlighting what about when

00:17:07,970 --> 00:17:10,970
it documents get a little more

00:17:09,230 --> 00:17:13,130
complicated they have saved more than

00:17:10,970 --> 00:17:14,720
one dimension well this is this is sort

00:17:13,130 --> 00:17:17,840
of what the joint module is about we can

00:17:14,720 --> 00:17:20,000
we can look at this example here if

00:17:17,840 --> 00:17:21,709
you're in the US this is a funny example

00:17:20,000 --> 00:17:25,190
i think in europe you may not get the

00:17:21,709 --> 00:17:26,930
joke but uh this three wolf shirt you

00:17:25,190 --> 00:17:29,690
know I'm gonna go on Amazon I really

00:17:26,930 --> 00:17:33,440
want this shirt so I might search for

00:17:29,690 --> 00:17:35,990
the size I want and the color in this

00:17:33,440 --> 00:17:40,430
case I want it in blue extra large wolf

00:17:35,990 --> 00:17:43,130
shirt well it may turn out that behind

00:17:40,430 --> 00:17:44,270
the scenes I sell this product this this

00:17:43,130 --> 00:17:47,480
wolf shirt

00:17:44,270 --> 00:17:49,100
they only have you know blue ones in a

00:17:47,480 --> 00:17:51,470
certain size so I have blue ones in

00:17:49,100 --> 00:17:54,410
extra-large and I only have the red ones

00:17:51,470 --> 00:17:57,170
in size small well if I search for you

00:17:54,410 --> 00:17:59,210
know an extra large one that's red

00:17:57,170 --> 00:18:01,550
should i should i get back any documents

00:17:59,210 --> 00:18:03,950
no i mean and this is kind of hard to uh

00:18:01,550 --> 00:18:05,180
to deal with this normalization in a

00:18:03,950 --> 00:18:07,820
database you might use a joint

00:18:05,180 --> 00:18:10,070
historically and so that's how this this

00:18:07,820 --> 00:18:12,080
feature got its name but the way we

00:18:10,070 --> 00:18:13,940
solve it is instead of sort of de

00:18:12,080 --> 00:18:15,920
normalizing this into one big fat row

00:18:13,940 --> 00:18:17,960
because it doesn't really fit right it's

00:18:15,920 --> 00:18:20,270
one too many then we'll just actually

00:18:17,960 --> 00:18:22,130
represent it one too many as a nested

00:18:20,270 --> 00:18:23,780
document and that's what this this

00:18:22,130 --> 00:18:26,690
feature allows you to do so i can

00:18:23,780 --> 00:18:28,790
actually do a search this says search

00:18:26,690 --> 00:18:30,620
give me a wolf shirt with this size in

00:18:28,790 --> 00:18:35,510
this color and it sort of joins those

00:18:30,620 --> 00:18:36,920
those records together so this again

00:18:35,510 --> 00:18:39,500
it's an alternative you could still do

00:18:36,920 --> 00:18:42,320
normalize yourself but I think sometimes

00:18:39,500 --> 00:18:45,890
this is a way more intuitive way to look

00:18:42,320 --> 00:18:47,630
at your data so there's been two talks

00:18:45,890 --> 00:18:50,990
on this feature already I think they

00:18:47,630 --> 00:18:52,610
came at it from 11 from leucine and went

00:18:50,990 --> 00:18:56,710
from elastic search side it's called the

00:18:52,610 --> 00:18:58,970
percolator but this is the idea of

00:18:56,710 --> 00:19:02,000
turning search backwards I'm turning it

00:18:58,970 --> 00:19:04,460
around actually I do it in Google I I

00:19:02,000 --> 00:19:06,170
register an alert it says you know if a

00:19:04,460 --> 00:19:08,090
new document comes into the internet and

00:19:06,170 --> 00:19:10,910
it's about this that you know tell me

00:19:08,090 --> 00:19:12,350
about it send me an email alert me so I

00:19:10,910 --> 00:19:14,270
don't know if anyone's use this feature

00:19:12,350 --> 00:19:16,670
but you know I can I can go and register

00:19:14,270 --> 00:19:18,440
Berlin buzzwords and if a new document

00:19:16,670 --> 00:19:20,810
shows up talking about Berlin buzzwords

00:19:18,440 --> 00:19:22,550
I would get notified about it how would

00:19:20,810 --> 00:19:24,830
you do this you know it sounds pretty

00:19:22,550 --> 00:19:26,360
tricky but actually leucine already has

00:19:24,830 --> 00:19:28,880
this feature built-in it's had it for a

00:19:26,360 --> 00:19:30,200
long time the way it actually works

00:19:28,880 --> 00:19:32,450
behind the scenes is each time a

00:19:30,200 --> 00:19:34,550
document comes in we built the back of

00:19:32,450 --> 00:19:36,350
the book index for that one document we

00:19:34,550 --> 00:19:37,970
run a ton of queries against it which

00:19:36,350 --> 00:19:40,670
are all very fast because it's a tiny

00:19:37,970 --> 00:19:43,070
index and then we throw it all away and

00:19:40,670 --> 00:19:44,630
I mean it sounds terrible but this

00:19:43,070 --> 00:19:46,730
actually works really fast and so you

00:19:44,630 --> 00:19:49,460
can register you know thousands of these

00:19:46,730 --> 00:19:51,260
alerts and an index of one document run

00:19:49,460 --> 00:19:52,970
them all very fast less than a second

00:19:51,260 --> 00:19:55,570
and then send out your alerts and

00:19:52,970 --> 00:19:55,570
everything works

00:19:55,660 --> 00:20:00,650
so our back of the book index we've

00:19:59,570 --> 00:20:02,030
talked about you know all these

00:20:00,650 --> 00:20:05,270
different capabilities we can build off

00:20:02,030 --> 00:20:07,040
of it but uh you know how does this

00:20:05,270 --> 00:20:08,540
thing actually look we know it doesn't

00:20:07,040 --> 00:20:10,790
actually look like the back of the book

00:20:08,540 --> 00:20:12,320
that we've been describing but in fact

00:20:10,790 --> 00:20:13,730
there's compression and and there's

00:20:12,320 --> 00:20:14,840
there's different choices you can make

00:20:13,730 --> 00:20:16,610
and different data structures and

00:20:14,840 --> 00:20:18,200
trade-offs it's what we didn't leave

00:20:16,610 --> 00:20:19,940
seen is we made these these backends

00:20:18,200 --> 00:20:21,590
pluggable the way we represent this

00:20:19,940 --> 00:20:23,600
thing and I'm going to give a little

00:20:21,590 --> 00:20:25,610
example on you know how that would work

00:20:23,600 --> 00:20:27,950
so let's take our back of the book index

00:20:25,610 --> 00:20:29,780
on a piece of paper and let's think

00:20:27,950 --> 00:20:32,450
about how we might compress this a

00:20:29,780 --> 00:20:34,790
little bit right just our own form of

00:20:32,450 --> 00:20:37,730
stupid compression so here's an example

00:20:34,790 --> 00:20:39,170
I have the O's in the peas and you know

00:20:37,730 --> 00:20:40,700
what we know here in our back of the

00:20:39,170 --> 00:20:42,950
book index that all the words beginning

00:20:40,700 --> 00:20:44,600
with oh we put them under oh and we all

00:20:42,950 --> 00:20:47,059
the ones under P we put them with P so

00:20:44,600 --> 00:20:48,800
there's some redundancy here right why

00:20:47,059 --> 00:20:50,990
do i need to actually have the peas for

00:20:48,800 --> 00:20:52,460
parallel and proton when I already know

00:20:50,990 --> 00:20:55,429
they all start with P because they're in

00:20:52,460 --> 00:20:56,630
the P section so that's exactly how our

00:20:55,429 --> 00:20:59,900
little compression here is going to work

00:20:56,630 --> 00:21:02,720
right I'm just removing the redundancy

00:20:59,900 --> 00:21:04,790
here so this is sort of what the codec

00:21:02,720 --> 00:21:06,440
module is about I had this idea it's

00:21:04,790 --> 00:21:08,570
kind of silly and it's a basic example

00:21:06,440 --> 00:21:11,179
but I did a little bit of compression

00:21:08,570 --> 00:21:13,190
here and I think maybe this is useful so

00:21:11,179 --> 00:21:15,110
I can implement a back-end that stores

00:21:13,190 --> 00:21:17,300
my back of the book index this way and

00:21:15,110 --> 00:21:19,040
and you might have a different approach

00:21:17,300 --> 00:21:20,840
that you want to do that's different we

00:21:19,040 --> 00:21:23,059
don't have to have just one format for

00:21:20,840 --> 00:21:24,710
leucine anymore we can have choices and

00:21:23,059 --> 00:21:28,010
they work for different use cases and

00:21:24,710 --> 00:21:29,480
this is what the Codex module is so for

00:21:28,010 --> 00:21:32,120
example right now there's someone

00:21:29,480 --> 00:21:34,880
working on one specific for primary keys

00:21:32,120 --> 00:21:36,200
unique IDs that there's formats that are

00:21:34,880 --> 00:21:38,270
sort of geared at different use cases

00:21:36,200 --> 00:21:39,830
and they're more efficient or and they

00:21:38,270 --> 00:21:41,630
might be less efficient in general but

00:21:39,830 --> 00:21:43,700
for this type of data they're they're

00:21:41,630 --> 00:21:45,500
very good so with the Codex module you

00:21:43,700 --> 00:21:48,110
can plug this in you can customize how

00:21:45,500 --> 00:21:50,630
the back of the book index works even if

00:21:48,110 --> 00:21:52,220
/ field level for your documents you can

00:21:50,630 --> 00:21:55,100
say again that this is the primary key

00:21:52,220 --> 00:21:57,020
field use use this format this is a you

00:21:55,100 --> 00:21:59,330
know a big big piece of text use this

00:21:57,020 --> 00:22:00,920
other format and so you know this is

00:21:59,330 --> 00:22:02,720
pretty powerful you can you can really

00:22:00,920 --> 00:22:04,670
implement your own stuff your own

00:22:02,720 --> 00:22:07,610
customizations to loose teen you could

00:22:04,670 --> 00:22:08,250
plug into some you know crazy way that

00:22:07,610 --> 00:22:09,660
the current

00:22:08,250 --> 00:22:11,520
lucene doesn't have a clean way to do

00:22:09,660 --> 00:22:12,810
because you have a lot of a lot of power

00:22:11,520 --> 00:22:15,570
here you're kind of underneath all the

00:22:12,810 --> 00:22:17,130
guts so an example here would be you

00:22:15,570 --> 00:22:20,400
know maybe I want to put my terms in a

00:22:17,130 --> 00:22:22,680
in a try structure or another guy wants

00:22:20,400 --> 00:22:23,970
a binary tree or whatever and we could

00:22:22,680 --> 00:22:26,070
argue about it or we could just

00:22:23,970 --> 00:22:27,450
implement both of them and give people

00:22:26,070 --> 00:22:32,010
the choice and that's what the Codex

00:22:27,450 --> 00:22:33,390
module does so I went through a lot of

00:22:32,010 --> 00:22:35,940
these modules i wish i could do all of

00:22:33,390 --> 00:22:38,670
them but there's a snotty enough time so

00:22:35,940 --> 00:22:40,020
what I want to do quickly is list the

00:22:38,670 --> 00:22:42,240
other modules that we have available

00:22:40,020 --> 00:22:44,910
with just sort of a quick summary of

00:22:42,240 --> 00:22:47,760
what they do including the ones I wasn't

00:22:44,910 --> 00:22:50,130
able to address so we have a

00:22:47,760 --> 00:22:52,710
benchmarking packaging we've seen this

00:22:50,130 --> 00:22:54,510
just is a way to sort of write it write

00:22:52,710 --> 00:22:56,100
a file that says I want to do

00:22:54,510 --> 00:22:57,720
benchmarking of this specific component

00:22:56,100 --> 00:23:00,930
it's kind of useful if you're developing

00:22:57,720 --> 00:23:02,400
leucine code we have a classification

00:23:00,930 --> 00:23:04,680
this is actually doing document

00:23:02,400 --> 00:23:07,020
classification based on the statistics

00:23:04,680 --> 00:23:11,460
in the index so it's an interesting way

00:23:07,020 --> 00:23:14,190
to look at it that's new that's new and

00:23:11,460 --> 00:23:15,600
listing for we have a demo module this

00:23:14,190 --> 00:23:17,070
might be the first place to start if

00:23:15,600 --> 00:23:18,930
you're actually playing with the code

00:23:17,070 --> 00:23:20,520
and you're looking at you know this list

00:23:18,930 --> 00:23:23,040
of folders and thinking well where do I

00:23:20,520 --> 00:23:24,870
start I start with the demo because this

00:23:23,040 --> 00:23:26,640
is a small little app that can index

00:23:24,870 --> 00:23:30,780
stuff and search it and you can maybe

00:23:26,640 --> 00:23:32,160
your start and build off of that we have

00:23:30,780 --> 00:23:35,490
faceting which I really wanted to talk

00:23:32,160 --> 00:23:37,770
about fascinating is is is sort of this

00:23:35,490 --> 00:23:39,300
this browsing and searching combined

00:23:37,770 --> 00:23:41,340
that you used to when you go to

00:23:39,300 --> 00:23:44,040
e-commerce site and it tells you your

00:23:41,340 --> 00:23:45,450
search match things in these different

00:23:44,040 --> 00:23:47,310
departments and things like that but

00:23:45,450 --> 00:23:49,500
this is really powerful it has a lot of

00:23:47,310 --> 00:23:51,320
features based on it you note just

00:23:49,500 --> 00:23:54,030
unfastening for example you can use

00:23:51,320 --> 00:23:55,590
ranges that's it by distance you can

00:23:54,030 --> 00:23:58,590
plug into the expressions I talked about

00:23:55,590 --> 00:24:00,570
earlier so it hooks into other into

00:23:58,590 --> 00:24:03,750
other things we have grouping in a

00:24:00,570 --> 00:24:06,120
similar way you can group by um you know

00:24:03,750 --> 00:24:08,610
terms so this is like I have results

00:24:06,120 --> 00:24:09,840
it's different than the join in the

00:24:08,610 --> 00:24:12,330
sense that they're not really

00:24:09,840 --> 00:24:14,040
parent-child they're just related and so

00:24:12,330 --> 00:24:15,300
this is the idea I just want them

00:24:14,040 --> 00:24:17,310
together and sometimes when you search

00:24:15,300 --> 00:24:19,860
like Berlin buzzwords i think is a good

00:24:17,310 --> 00:24:21,470
one if you search for it you'll find

00:24:19,860 --> 00:24:22,880
that google returns like five

00:24:21,470 --> 00:24:24,080
six documents and it groups them all

00:24:22,880 --> 00:24:26,299
under Berlin buzzwords because they're

00:24:24,080 --> 00:24:27,950
all at that website so that might be an

00:24:26,299 --> 00:24:29,750
example use case for grouping but you

00:24:27,950 --> 00:24:32,360
can group by function you can group by

00:24:29,750 --> 00:24:34,429
expression so it again has the same

00:24:32,360 --> 00:24:37,190
hooks into things like fastening does so

00:24:34,429 --> 00:24:39,799
you can combine these modules to really

00:24:37,190 --> 00:24:42,049
customize the experience we have a

00:24:39,799 --> 00:24:44,299
folder full of index tools this is low

00:24:42,049 --> 00:24:46,280
level stuff like splitting an index in

00:24:44,299 --> 00:24:48,559
half things like that this can be useful

00:24:46,280 --> 00:24:50,659
if you're doing a distributed computing

00:24:48,559 --> 00:24:52,330
you want to split your index to sort of

00:24:50,659 --> 00:24:54,980
to Rashard and there's some other

00:24:52,330 --> 00:24:57,740
interesting tools in there like pre sort

00:24:54,980 --> 00:25:00,740
your index and things like that it's you

00:24:57,740 --> 00:25:02,960
just have to look and play around I

00:25:00,740 --> 00:25:06,140
talked about queries we built a little n

00:25:02,960 --> 00:25:08,210
or and not query for our back of the

00:25:06,140 --> 00:25:10,309
book index but there's a lot more type

00:25:08,210 --> 00:25:12,289
of queries you can use for example you

00:25:10,309 --> 00:25:13,520
know you could imagine an ex or query I

00:25:12,289 --> 00:25:15,409
don't think it would be useful but you

00:25:13,520 --> 00:25:16,909
could build it and so that kind of thing

00:25:15,409 --> 00:25:19,429
goes into the queries module is just

00:25:16,909 --> 00:25:21,590
additional queries that met someone's

00:25:19,429 --> 00:25:24,650
use case at one point in time we have

00:25:21,590 --> 00:25:27,679
replication this is just sort of a

00:25:24,650 --> 00:25:29,240
simple API to take the contents of one

00:25:27,679 --> 00:25:31,580
index and keep them in sync across

00:25:29,240 --> 00:25:33,740
machines and this is useful if you have

00:25:31,580 --> 00:25:35,270
more website traffic than you know you

00:25:33,740 --> 00:25:37,970
had before you just want to scale it

00:25:35,270 --> 00:25:39,500
scale it out by adding more replicas so

00:25:37,970 --> 00:25:43,760
we have you can do that just what we've

00:25:39,500 --> 00:25:45,500
seen we have a sandbox uh this is where

00:25:43,760 --> 00:25:47,090
I like to put code now when I write it

00:25:45,500 --> 00:25:49,400
because I feel like it has a lower bar

00:25:47,090 --> 00:25:50,419
to entry but you just you know this is

00:25:49,400 --> 00:25:51,980
something that it's not quite right

00:25:50,419 --> 00:25:54,350
about the code but there's some

00:25:51,980 --> 00:25:57,530
interesting fun stuff in there so look

00:25:54,350 --> 00:25:58,850
around we have we have spatial support

00:25:57,530 --> 00:26:00,620
more than what I talked about with the

00:25:58,850 --> 00:26:03,710
hammer sine function in the expressions

00:26:00,620 --> 00:26:05,870
that's very basic but there's also you

00:26:03,710 --> 00:26:07,520
know some some polygons support and more

00:26:05,870 --> 00:26:10,730
complex geospatial support in that

00:26:07,520 --> 00:26:12,679
module and we have this test framework

00:26:10,730 --> 00:26:15,169
finally and there's an important one

00:26:12,679 --> 00:26:16,789
because this is basically our test

00:26:15,169 --> 00:26:18,740
harness we use to test Alou scene itself

00:26:16,789 --> 00:26:20,659
so if you're using loosing as a library

00:26:18,740 --> 00:26:22,220
you can just you also use our test

00:26:20,659 --> 00:26:24,200
harness if you'd like to test your own

00:26:22,220 --> 00:26:26,360
code and we found it does a lot of

00:26:24,200 --> 00:26:27,890
things like detect file leaks as you

00:26:26,360 --> 00:26:29,780
know things like that usually if you

00:26:27,890 --> 00:26:31,130
start with just j unit you're not going

00:26:29,780 --> 00:26:33,230
to have that level of test cover data

00:26:31,130 --> 00:26:34,600
box so if you want to use the same test

00:26:33,230 --> 00:26:36,850
infrastructure that

00:26:34,600 --> 00:26:41,980
we use it's just a library and you can

00:26:36,850 --> 00:26:43,630
use it so I kind of ripped through as

00:26:41,980 --> 00:26:46,390
fast as possible all of the different

00:26:43,630 --> 00:26:47,710
modules in lucene I wish that I could

00:26:46,390 --> 00:26:49,929
have gone in depth on each one of them

00:26:47,710 --> 00:26:52,750
because they're interesting but you know

00:26:49,929 --> 00:26:54,460
since we only have so much time for a

00:26:52,750 --> 00:26:56,440
deeper look I would just download

00:26:54,460 --> 00:26:57,730
leucine unzip it you're going to see the

00:26:56,440 --> 00:27:00,640
same structure that i just presented

00:26:57,730 --> 00:27:02,410
here and accept then you can go and look

00:27:00,640 --> 00:27:07,090
at the source code and get way more

00:27:02,410 --> 00:27:08,950
information on it if you haven't been to

00:27:07,090 --> 00:27:10,600
the loosing website we have the javadocs

00:27:08,950 --> 00:27:12,640
for all the api's you can get the

00:27:10,600 --> 00:27:14,919
download leucine in action is still be

00:27:12,640 --> 00:27:16,590
useful it's a good book to start with if

00:27:14,919 --> 00:27:18,970
you're just getting started with racine

00:27:16,590 --> 00:27:20,710
but it's a little out of date in the

00:27:18,970 --> 00:27:22,600
sense that it mostly these modules you

00:27:20,710 --> 00:27:25,559
won't find in lucena in action because I

00:27:22,600 --> 00:27:30,000
think they didn't exist at the time so

00:27:25,559 --> 00:27:30,000
that's it questions

00:27:41,390 --> 00:27:45,230
please wait for the mic

00:27:55,080 --> 00:28:05,070
I am actually have several questions one

00:28:01,740 --> 00:28:08,250
is about generating tokenizer code I

00:28:05,070 --> 00:28:09,779
remember you were using J flex but it

00:28:08,250 --> 00:28:12,510
was kind of not very well supported

00:28:09,779 --> 00:28:14,940
library back then I did anything change

00:28:12,510 --> 00:28:16,740
from this time and the second question

00:28:14,940 --> 00:28:18,720
about classification can you please

00:28:16,740 --> 00:28:21,809
elaborate more on it what kind of

00:28:18,720 --> 00:28:25,169
classification you do and how does work

00:28:21,809 --> 00:28:26,940
just in a few words thank God okay let's

00:28:25,169 --> 00:28:31,169
start first with the the tokenizer one

00:28:26,940 --> 00:28:32,789
so um yes we still use J flex for for

00:28:31,169 --> 00:28:35,850
our standard tokenizer but as I

00:28:32,789 --> 00:28:37,710
mentioned we have 20 different tokenizer

00:28:35,850 --> 00:28:39,690
'he's so you don't have to use it if you

00:28:37,710 --> 00:28:41,820
don't like you you know you could

00:28:39,690 --> 00:28:44,039
implement your own using using anything

00:28:41,820 --> 00:28:46,350
you like you can just hand write it in

00:28:44,039 --> 00:28:48,450
Java code if you want but yeah that is

00:28:46,350 --> 00:28:50,580
that is our standard one and we still

00:28:48,450 --> 00:28:52,740
used a flex and one of the committers on

00:28:50,580 --> 00:28:54,539
j flex is also a leucine committer so i

00:28:52,740 --> 00:28:56,190
think it's it's it's still being

00:28:54,539 --> 00:28:58,139
maintained its it's still being released

00:28:56,190 --> 00:28:59,970
and it works quite well it's just you

00:28:58,139 --> 00:29:02,460
know the the generated code doesn't look

00:28:59,970 --> 00:29:04,139
great because it's generated code that's

00:29:02,460 --> 00:29:06,809
just the way it works as far as the

00:29:04,139 --> 00:29:10,820
classification module you're asking how

00:29:06,809 --> 00:29:13,200
the scoring works for classification

00:29:10,820 --> 00:29:15,240
what type of algorithms as far as we

00:29:13,200 --> 00:29:18,029
remember we we have K nearest neighbor

00:29:15,240 --> 00:29:21,600
and there's one more that we have simple

00:29:18,029 --> 00:29:23,190
simple naive Bayes some yeah so I'm not

00:29:21,600 --> 00:29:24,419
really a classification guy you're gonna

00:29:23,190 --> 00:29:25,799
have to look at the code if you want

00:29:24,419 --> 00:29:30,779
more information on it that's probably

00:29:25,799 --> 00:29:32,519
the best place to start thank you for a

00:29:30,779 --> 00:29:34,559
talk have questions are gonna garbage

00:29:32,519 --> 00:29:36,659
character i think in old times listen

00:29:34,559 --> 00:29:39,299
was trying to minimize number four Jack

00:29:36,659 --> 00:29:41,429
two generated during queria so to

00:29:39,299 --> 00:29:43,080
minimize water and garbage character is

00:29:41,429 --> 00:29:46,049
it the same as interesting for you

00:29:43,080 --> 00:29:48,600
change in approach so do you mean um

00:29:46,049 --> 00:29:53,340
where the code is written a little bit

00:29:48,600 --> 00:29:54,750
funky way yeah yeah unfortunately it's

00:29:53,340 --> 00:29:56,880
still this way I think you know

00:29:54,750 --> 00:29:58,289
ultimately it will improve in Java you

00:29:56,880 --> 00:30:00,990
see that they're trying to propose

00:29:58,289 --> 00:30:03,059
changes like value types in Java and so

00:30:00,990 --> 00:30:05,429
maybe when Java improves we can take a

00:30:03,059 --> 00:30:07,230
big pass on the code and try to remove

00:30:05,429 --> 00:30:09,090
some of this complicated

00:30:07,230 --> 00:30:10,620
but yeah there's some extent you know we

00:30:09,090 --> 00:30:12,270
try to make it efficient and then

00:30:10,620 --> 00:30:15,090
there's always sort of a trade-off like

00:30:12,270 --> 00:30:16,860
you know make the code readable and

00:30:15,090 --> 00:30:18,809
maintainable and it's open source right

00:30:16,860 --> 00:30:21,419
this is important but also make it

00:30:18,809 --> 00:30:23,210
efficient in production and so you

00:30:21,419 --> 00:30:25,650
there's got to be a balance there right

00:30:23,210 --> 00:30:32,900
but yeah it's still kind of funky like

00:30:25,650 --> 00:30:35,400
that right now I thank you for talk the

00:30:32,900 --> 00:30:37,530
quality of a suggestion module or

00:30:35,400 --> 00:30:39,840
suggestion function depends a lot on how

00:30:37,530 --> 00:30:42,450
users use the system is there some way

00:30:39,840 --> 00:30:46,230
to take into account things like query

00:30:42,450 --> 00:30:48,660
logs or user clicks in a simple way will

00:30:46,230 --> 00:30:50,610
the scene well right so basically what

00:30:48,660 --> 00:30:52,710
we do when it comes to this and that's

00:30:50,610 --> 00:30:55,350
why we have modules like the expressions

00:30:52,710 --> 00:30:57,059
module and stuff is we bail out on how

00:30:55,350 --> 00:30:58,890
you should rank suggestions completely

00:30:57,059 --> 00:31:00,540
and we leave it totally up to you like

00:30:58,890 --> 00:31:03,270
you have to figure out this problem so

00:31:00,540 --> 00:31:05,790
yes I mean we don't provide tools to do

00:31:03,270 --> 00:31:08,160
state query log analysis or any of that

00:31:05,790 --> 00:31:10,230
kind of stuff I think on someone else

00:31:08,160 --> 00:31:12,480
maybe can do a better job than us when

00:31:10,230 --> 00:31:14,790
it comes to those kind of tools but you

00:31:12,480 --> 00:31:16,740
know it's something we bail on we just

00:31:14,790 --> 00:31:18,929
say hey will give you the infrastructure

00:31:16,740 --> 00:31:22,650
to do suggestions and as far as how you

00:31:18,929 --> 00:31:25,710
rank them that's that's up to you it's

00:31:22,650 --> 00:31:28,080
hard I know you're running a lot of time

00:31:25,710 --> 00:31:30,450
here but in a very few words if you

00:31:28,080 --> 00:31:32,460
could tell us what what sort of the next

00:31:30,450 --> 00:31:34,169
big things coming up for the scene the

00:31:32,460 --> 00:31:36,179
next big thing I wish I knew I mean it

00:31:34,169 --> 00:31:37,950
one of you guys could come online right

00:31:36,179 --> 00:31:39,120
now with a big patch that changes

00:31:37,950 --> 00:31:41,730
everything and then that would be the

00:31:39,120 --> 00:31:43,490
next big thing right so I don't know I

00:31:41,730 --> 00:31:47,040
know we're working on improving the way

00:31:43,490 --> 00:31:49,140
you know positional queries work I think

00:31:47,040 --> 00:31:51,240
is something that will come in the past

00:31:49,140 --> 00:31:53,160
they've been kind of slower and and not

00:31:51,240 --> 00:31:54,690
as flexible as we would like so this is

00:31:53,160 --> 00:31:57,870
something that we would really like to

00:31:54,690 --> 00:31:59,100
fix soon so for example the queries sort

00:31:57,870 --> 00:32:01,679
of like the functionality you get from

00:31:59,100 --> 00:32:04,919
span queries making this a more core

00:32:01,679 --> 00:32:06,390
thing that works so I think that'll be

00:32:04,919 --> 00:32:08,429
more useful it will also improve things

00:32:06,390 --> 00:32:11,280
like highlighting because we just have

00:32:08,429 --> 00:32:13,530
better proximity support maybe provide

00:32:11,280 --> 00:32:15,860
stuff like proximity-based ranking out

00:32:13,530 --> 00:32:18,570
of box that builds on top of that

00:32:15,860 --> 00:32:20,179
otherwise I can see like you know more

00:32:18,570 --> 00:32:22,970
codecs like

00:32:20,179 --> 00:32:24,889
in this specialized format just 44

00:32:22,970 --> 00:32:26,869
unique IDs I think we'll start to see

00:32:24,889 --> 00:32:28,399
more of that it's it's really useful and

00:32:26,869 --> 00:32:31,039
practical and we can plug in and cleanly

00:32:28,399 --> 00:32:33,590
so I think we'll just be an expansion

00:32:31,039 --> 00:32:34,909
better compression things like that but

00:32:33,590 --> 00:32:36,559
in general it's open source we don't

00:32:34,909 --> 00:32:38,809
know there's no plan or anything it's

00:32:36,559 --> 00:32:42,039
just whatever comes up on the list

00:32:38,809 --> 00:32:42,039
that's that's will happen

00:32:59,200 --> 00:33:04,489
so we'd like to thank you again for your

00:33:02,119 --> 00:33:07,960
talk oh and thanks for your questions

00:33:04,489 --> 00:33:07,960

YouTube URL: https://www.youtube.com/watch?v=KyA44hBB5t4


