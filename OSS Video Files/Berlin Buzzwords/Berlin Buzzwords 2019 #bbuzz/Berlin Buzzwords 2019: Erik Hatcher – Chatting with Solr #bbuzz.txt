Title: Berlin Buzzwords 2019: Erik Hatcher â€“ Chatting with Solr #bbuzz
Publication date: 2019-06-27
Playlist: Berlin Buzzwords 2019 #bbuzz
Description: 
	Building a chat system relies on recognizing known entities being spoken. The Solr Tagger, a powerful unique capability of Apache Solr, provides performant tagging of known, concrete items in free text. Using the Solr Tagger as a first stage of query interpretation provides rich entity metadata that can be leveraged to hone in on user intent.

This session will introduce the Solr Tagger and its myriad of use cases culminating with a chat application that creatively uses the tagger for query interpretation.

This talk is presented by Lucidworks.

Read more:
https://2019.berlinbuzzwords.de/19/session/chatting-solr

About Erik Hatcher:
https://2019.berlinbuzzwords.de/users/erik-hatcher

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,250 --> 00:00:10,600
all right thank you everybody for coming

00:00:10,660 --> 00:00:15,410
first time in Berlin first time to

00:00:13,040 --> 00:00:18,110
buzzwords I regret not having made it

00:00:15,410 --> 00:00:23,240
here long ago I've been on the program

00:00:18,110 --> 00:00:24,950
committee as he said before and also I'm

00:00:23,240 --> 00:00:28,730
a leucine solar committer and a

00:00:24,950 --> 00:00:32,809
co-founder of lucid works which is the

00:00:28,730 --> 00:00:34,100
platinum sponsor of this event so I'm

00:00:32,809 --> 00:00:36,649
gonna do a talk called chatting with

00:00:34,100 --> 00:00:39,140
solar it is not will Hayes's talk and

00:00:36,649 --> 00:00:40,970
I'll go into that in just a second but

00:00:39,140 --> 00:00:42,560
first I want to give you a word from our

00:00:40,970 --> 00:00:44,660
sponsor

00:00:42,560 --> 00:00:46,399
again not will Hayes's talk his talk

00:00:44,660 --> 00:00:48,110
title was building and scaling a

00:00:46,399 --> 00:00:53,059
high-performance delta performing

00:00:48,110 --> 00:00:56,180
development team he couldn't make it to

00:00:53,059 --> 00:00:59,059
Berlin this week so he commissioned me

00:00:56,180 --> 00:01:02,170
to to fill in and and I couldn't give

00:00:59,059 --> 00:01:04,939
his talk because I can't put words in to

00:01:02,170 --> 00:01:08,299
put my words to his intelligent thoughts

00:01:04,939 --> 00:01:09,680
there so I've made up my own talk over

00:01:08,299 --> 00:01:13,689
the last couple of days when I learned I

00:01:09,680 --> 00:01:15,530
needed to do this and my take on his

00:01:13,689 --> 00:01:17,359
title they're building and scaling a

00:01:15,530 --> 00:01:20,209
high-performing development team is that

00:01:17,359 --> 00:01:22,429
we do that with folks like you folks

00:01:20,209 --> 00:01:26,359
that are passionate smart caring and

00:01:22,429 --> 00:01:30,020
diverse and absolutely with open source

00:01:26,359 --> 00:01:32,209
we're loosing solar spark a zookeeper

00:01:30,020 --> 00:01:35,029
and the whole stack of that those

00:01:32,209 --> 00:01:38,840
technologies we are absolutely hiring

00:01:35,029 --> 00:01:43,810
we're in a very strong growth period

00:01:38,840 --> 00:01:46,849
right now I kind of rift off of Will's

00:01:43,810 --> 00:01:49,579
text here he said his he proposed a fun

00:01:46,849 --> 00:01:51,020
non-technical talk for members of de

00:01:49,579 --> 00:01:52,429
bump teams all levels looking increased

00:01:51,020 --> 00:01:54,560
performance in productivity I kind of

00:01:52,429 --> 00:01:57,380
ripped off of that and came up with my

00:01:54,560 --> 00:02:00,919
own little blurb there in a second and

00:01:57,380 --> 00:02:02,619
I'll show you that come visit our booth

00:02:00,919 --> 00:02:04,969
we have a booth right there in the lobby

00:02:02,619 --> 00:02:08,090
and we're giving away these autocomplete

00:02:04,969 --> 00:02:10,700
t-shirts they're nice and soft and fun

00:02:08,090 --> 00:02:12,050
and the ladies really like them actually

00:02:10,700 --> 00:02:14,300
so good stuff

00:02:12,050 --> 00:02:17,120
so you autocomplete us is what I'm

00:02:14,300 --> 00:02:18,300
riffing on there and saying that we'd

00:02:17,120 --> 00:02:22,560
love to

00:02:18,300 --> 00:02:24,780
further and about your involvement with

00:02:22,560 --> 00:02:29,580
open source with your involvement and

00:02:24,780 --> 00:02:31,320
interest in lucid works all right so

00:02:29,580 --> 00:02:33,360
just kind of a riff off of what we'll

00:02:31,320 --> 00:02:35,910
put in his abstract there this is

00:02:33,360 --> 00:02:38,730
hopefully going to be a fun technical

00:02:35,910 --> 00:02:41,490
talk for development teams at all levels

00:02:38,730 --> 00:02:42,960
looking increase the relevancy and value

00:02:41,490 --> 00:02:50,700
in their search systems and data

00:02:42,960 --> 00:02:54,180
pipelines using solar this is a link

00:02:50,700 --> 00:02:56,220
that I saw this morning I I have

00:02:54,180 --> 00:02:58,590
unfortunately had to stay at the booth

00:02:56,220 --> 00:03:00,600
this entire conference and the rest of

00:02:58,590 --> 00:03:02,700
the day after this talk so I haven't

00:03:00,600 --> 00:03:04,290
been able to see the talks here but you

00:03:02,700 --> 00:03:06,630
know I've see I follow the tweets and

00:03:04,290 --> 00:03:09,060
their and the agenda and there's a lot

00:03:06,630 --> 00:03:11,040
of talks about chat and this is an

00:03:09,060 --> 00:03:14,160
article about how Bank of America has a

00:03:11,040 --> 00:03:17,780
system called Erica that is a chat

00:03:14,160 --> 00:03:23,760
interface to get at banking information

00:03:17,780 --> 00:03:26,489
so there's there's that so without

00:03:23,760 --> 00:03:28,500
further ado we're just going to go back

00:03:26,489 --> 00:03:30,600
to the talk I'm gonna take off this

00:03:28,500 --> 00:03:33,959
corporate shirt here and get back to

00:03:30,600 --> 00:03:35,700
being a developer okay so now we're

00:03:33,959 --> 00:03:38,340
gonna get technical about this stuff

00:03:35,700 --> 00:03:41,850
okay so chatting with solar the ideas

00:03:38,340 --> 00:03:46,850
here it was to build something that

00:03:41,850 --> 00:03:52,680
could respond back to utterances with a

00:03:46,850 --> 00:03:55,610
reasonable response and we're gonna use

00:03:52,680 --> 00:03:59,910
a tool called the solar text tagger to

00:03:55,610 --> 00:04:03,600
be part of the and a very important and

00:03:59,910 --> 00:04:07,050
powerful part of of the system to do

00:04:03,600 --> 00:04:08,760
that so for a while I'm going to talk

00:04:07,050 --> 00:04:13,650
about the solar text tagger which is a

00:04:08,760 --> 00:04:16,350
unique feature to solar and then go into

00:04:13,650 --> 00:04:19,080
a demonstration of the tagger and then

00:04:16,350 --> 00:04:20,700
talk about the the chat system that I

00:04:19,080 --> 00:04:23,370
built and how it leverages the tagger

00:04:20,700 --> 00:04:25,169
okay that's going to be the talk agenda

00:04:23,370 --> 00:04:26,880
there I'm not going to read all this

00:04:25,169 --> 00:04:28,350
this is actually just a copy and paste

00:04:26,880 --> 00:04:29,610
from that link right there I just wanted

00:04:28,350 --> 00:04:30,800
to put it out there so that's in the

00:04:29,610 --> 00:04:35,380
slides

00:04:30,800 --> 00:04:40,190
the solar tagger is a high-performance

00:04:35,380 --> 00:04:42,889
entity naive entity recognizer and it

00:04:40,190 --> 00:04:45,259
does that by you inputting the entities

00:04:42,889 --> 00:04:49,729
that you want to be recognized and then

00:04:45,259 --> 00:04:54,130
you hit an endpoint into solar that tags

00:04:49,729 --> 00:04:58,009
that with the entities that it knows of

00:04:54,130 --> 00:05:02,150
it's a very straightforward tool the

00:04:58,009 --> 00:05:04,130
output is very sensible the cleverness

00:05:02,150 --> 00:05:05,659
comes in what you do with this so you

00:05:04,130 --> 00:05:09,860
can do a lot of things with the tagger

00:05:05,659 --> 00:05:11,150
and of course this is about doing chat

00:05:09,860 --> 00:05:14,090
but we're going to talk about a few

00:05:11,150 --> 00:05:16,699
different use cases there so just to

00:05:14,090 --> 00:05:21,080
kind of give you a grounding of the

00:05:16,699 --> 00:05:25,610
basics of the tagger again we tagged

00:05:21,080 --> 00:05:28,220
concrete known texturing entities tags

00:05:25,610 --> 00:05:28,970
are actually documents they're they're

00:05:28,220 --> 00:05:32,060
full-fledged

00:05:28,970 --> 00:05:34,370
individual documents in a solar

00:05:32,060 --> 00:05:36,409
collection there's a couple of special

00:05:34,370 --> 00:05:38,840
things about that solar collection to

00:05:36,409 --> 00:05:41,810
leverage the tagger there is a field

00:05:38,840 --> 00:05:42,949
type a change that you need to make you

00:05:41,810 --> 00:05:46,610
need to make sure that you have this

00:05:42,949 --> 00:05:49,340
catenate graph filter factory at the end

00:05:46,610 --> 00:05:52,070
of your analysis chain the index

00:05:49,340 --> 00:05:52,969
analysis chain so there's kind of some

00:05:52,070 --> 00:05:54,650
specialized stuff look at the

00:05:52,969 --> 00:05:57,889
documentation for the taggers see what

00:05:54,650 --> 00:06:00,440
about how it leverages analysis at query

00:05:57,889 --> 00:06:01,940
time and an index time there and then

00:06:00,440 --> 00:06:04,039
there's a specialized endpoint that's

00:06:01,940 --> 00:06:08,539
not automatically registered in the

00:06:04,039 --> 00:06:13,039
default solar configuration it's a

00:06:08,539 --> 00:06:15,050
simple JSON API to enable that tag

00:06:13,039 --> 00:06:17,479
request Handler and those are the only

00:06:15,050 --> 00:06:22,159
two pieces that you need to light solar

00:06:17,479 --> 00:06:25,009
up to leverage this text tagger what can

00:06:22,159 --> 00:06:28,639
you use this text tagger for you can use

00:06:25,009 --> 00:06:32,300
it at index time as a preprocessor to

00:06:28,639 --> 00:06:34,909
take the full text of a document run it

00:06:32,300 --> 00:06:36,680
through the text tagger grab the known

00:06:34,909 --> 00:06:40,699
entities that are in the full text

00:06:36,680 --> 00:06:43,039
document people's names places other

00:06:40,699 --> 00:06:44,180
entities that you may want to recognize

00:06:43,039 --> 00:06:46,130
that

00:06:44,180 --> 00:06:49,759
that are strings that you can match on

00:06:46,130 --> 00:06:54,020
it will give you back the offsets and

00:06:49,759 --> 00:06:57,020
the tags there and then at index time

00:06:54,020 --> 00:06:59,360
you can peel those values away and put

00:06:57,020 --> 00:07:03,169
them into additional fields for faceting

00:06:59,360 --> 00:07:06,350
and of course navigation so very useful

00:07:03,169 --> 00:07:08,960
they're rudimentary in terms of the

00:07:06,350 --> 00:07:11,630
actual effect but very powerful in that

00:07:08,960 --> 00:07:16,910
it's very performant and you can have

00:07:11,630 --> 00:07:20,720
millions of entities in a very high

00:07:16,910 --> 00:07:23,960
performance manner at query time the

00:07:20,720 --> 00:07:28,759
tagger can be leveraged for some very

00:07:23,960 --> 00:07:30,500
clever things use the tags to improve

00:07:28,759 --> 00:07:34,280
relevancy and how do you do that you

00:07:30,500 --> 00:07:38,030
peel away things that you know about if

00:07:34,280 --> 00:07:40,430
you know about the colors and you are a

00:07:38,030 --> 00:07:42,800
shopping site shoe shopping site and

00:07:40,430 --> 00:07:46,250
someone searches for blue shoes you

00:07:42,800 --> 00:07:49,970
recognize blue as a color and so now you

00:07:46,250 --> 00:07:52,729
have a very specific fielded way to

00:07:49,970 --> 00:07:55,090
either boost by things that are blue or

00:07:52,729 --> 00:07:59,090
to filter by things that are blue so you

00:07:55,090 --> 00:08:01,760
can very easily leverage the text tagger

00:07:59,090 --> 00:08:03,080
to give you straightforward information

00:08:01,760 --> 00:08:06,639
like that that can be leveraged to

00:08:03,080 --> 00:08:12,080
improve relevancy and a straightforward

00:08:06,639 --> 00:08:16,030
a simple trick like this really really

00:08:12,080 --> 00:08:19,190
can improve relevancy so very powerful

00:08:16,030 --> 00:08:22,039
technique there so I'm going to show you

00:08:19,190 --> 00:08:24,770
the demo is going to build upon on the

00:08:22,039 --> 00:08:28,630
source of things here's an example of

00:08:24,770 --> 00:08:31,610
tagging the text buzzwords in Berlin and

00:08:28,630 --> 00:08:35,209
this is just a screenshot from postman

00:08:31,610 --> 00:08:41,930
doing a post to the slash tag endpoint

00:08:35,209 --> 00:08:43,399
and I'm saying here's the text what tags

00:08:41,930 --> 00:08:45,829
do you know about and the only data that

00:08:43,399 --> 00:08:47,899
I have in my tagger collection in this

00:08:45,829 --> 00:08:52,730
example words cities I have a database

00:08:47,899 --> 00:08:54,470
of or I have a text file of all of the

00:08:52,730 --> 00:08:57,320
cities in the world that have a

00:08:54,470 --> 00:08:59,210
population greater than 15,000

00:08:57,320 --> 00:09:00,740
is the data that I'm using in here which

00:08:59,210 --> 00:09:03,650
is about a hundred and twenty four

00:09:00,740 --> 00:09:05,360
thousand cities I believe and there's a

00:09:03,650 --> 00:09:09,260
number of cities named Berlin actually

00:09:05,360 --> 00:09:13,790
but in this case it picked out a city

00:09:09,260 --> 00:09:15,140
Berlin and it told me and and I'll go

00:09:13,790 --> 00:09:17,120
into this a little bit more detailed you

00:09:15,140 --> 00:09:20,660
see the fields that are being returned

00:09:17,120 --> 00:09:23,330
their type name and ID name is the very

00:09:20,660 --> 00:09:26,900
specific field that I'm using as the

00:09:23,330 --> 00:09:29,480
tagger strings and then I because it's a

00:09:26,900 --> 00:09:32,150
solar collection I can put in any other

00:09:29,480 --> 00:09:34,430
fields that I want on to those documents

00:09:32,150 --> 00:09:36,080
you have one specialized field you could

00:09:34,430 --> 00:09:38,540
actually have multiple fields that are

00:09:36,080 --> 00:09:40,640
used for tagging

00:09:38,540 --> 00:09:42,260
but generally you'd have one field

00:09:40,640 --> 00:09:44,930
that's used for tagging and then the

00:09:42,260 --> 00:09:49,400
rest are just freeform whatever field

00:09:44,930 --> 00:09:51,440
types and that you need to leverage this

00:09:49,400 --> 00:09:54,290
information and one very valuable piece

00:09:51,440 --> 00:09:57,230
of information in this kind of custom

00:09:54,290 --> 00:09:59,330
collection here is just a field a string

00:09:57,230 --> 00:10:01,160
field called type this gives us some

00:09:59,330 --> 00:10:04,190
meta information about what type of

00:10:01,160 --> 00:10:06,620
thing we are tagging in this case I only

00:10:04,190 --> 00:10:07,760
have cities in there but in another

00:10:06,620 --> 00:10:11,150
example I'm going to show you I've got

00:10:07,760 --> 00:10:13,910
colors and brands and cities in there so

00:10:11,150 --> 00:10:16,610
it disambiguates what type of thing

00:10:13,910 --> 00:10:20,570
you're talking about and that's just a

00:10:16,610 --> 00:10:22,370
custom or nothing to do with the tagger

00:10:20,570 --> 00:10:25,070
it just happens to do with solar and

00:10:22,370 --> 00:10:28,640
fields in this case for the for the type

00:10:25,070 --> 00:10:30,200
field the tagger parameters that are

00:10:28,640 --> 00:10:33,860
being used in that last example are

00:10:30,200 --> 00:10:37,250
these when you tag text you could have

00:10:33,860 --> 00:10:40,910
overlapping tags for example there is a

00:10:37,250 --> 00:10:44,570
brand of product called white linen

00:10:40,910 --> 00:10:47,810
white is a color but Lin white linen is

00:10:44,570 --> 00:10:49,460
a brand so if you tag that with a tagger

00:10:47,810 --> 00:10:53,480
collection that knew about colors and

00:10:49,460 --> 00:10:56,060
brands what do you want to get back out

00:10:53,480 --> 00:11:01,460
of that you can get back both of those

00:10:56,060 --> 00:11:03,020
or you can get back the maximal tags

00:11:01,460 --> 00:11:05,450
span there so it would only give you

00:11:03,020 --> 00:11:07,199
back white linen as a brand rather than

00:11:05,450 --> 00:11:09,089
white as a color

00:11:07,199 --> 00:11:11,309
again you could get them all back if you

00:11:09,089 --> 00:11:12,959
want or kind of take the bigger the

00:11:11,309 --> 00:11:16,379
bigger sets of tags that are

00:11:12,959 --> 00:11:18,089
non-overlapping so it's up to you how

00:11:16,379 --> 00:11:22,199
many tags you want back and whether you

00:11:18,089 --> 00:11:23,819
want them overlapping and so on so again

00:11:22,199 --> 00:11:29,549
you can and you can limit the number of

00:11:23,819 --> 00:11:32,069
tags the other tagger special parameter

00:11:29,549 --> 00:11:34,730
is that match text and that simply gives

00:11:32,069 --> 00:11:37,019
you back the text that was matched

00:11:34,730 --> 00:11:40,169
rather than you having to do the math

00:11:37,019 --> 00:11:42,269
yourself client side and take the

00:11:40,169 --> 00:11:45,569
offsets and grab the text yourself it

00:11:42,269 --> 00:11:51,359
just automatically does that beyond that

00:11:45,569 --> 00:11:53,339
it supports standard solar FQ as well as

00:11:51,359 --> 00:11:56,629
the FL parameter so you can pick which

00:11:53,339 --> 00:12:00,480
fields you want back from tag from tags

00:11:56,629 --> 00:12:04,169
and you can also narrow down the types

00:12:00,480 --> 00:12:07,350
of things that you are going to tag in

00:12:04,169 --> 00:12:09,720
the text so if you have cities and

00:12:07,350 --> 00:12:12,089
colors and brands I could say I'm gonna

00:12:09,720 --> 00:12:13,470
take this text string and only tell me

00:12:12,089 --> 00:12:19,139
about the cities that are in it no

00:12:13,470 --> 00:12:22,290
matter and so ifq type : city this also

00:12:19,139 --> 00:12:24,660
comes in handy when the data for example

00:12:22,290 --> 00:12:28,410
cities have a lat/long on them so they

00:12:24,660 --> 00:12:30,569
have a location and so I can FQ and say

00:12:28,410 --> 00:12:33,480
only give me cities within a certain

00:12:30,569 --> 00:12:34,769
radius of a known point perhaps the

00:12:33,480 --> 00:12:40,829
point that I'm at right now

00:12:34,769 --> 00:12:43,410
find me food in Berlin which Berlin out

00:12:40,829 --> 00:12:45,989
of the Dozen of so cities in the world

00:12:43,410 --> 00:12:48,329
with the word Berlin in their name which

00:12:45,989 --> 00:12:51,619
one well you know where I'm at from my

00:12:48,329 --> 00:12:53,549
mobile app let's narrow it down and now

00:12:51,619 --> 00:12:56,160
straightforward there's only one city

00:12:53,549 --> 00:13:01,019
that's going to get tagged so that's the

00:12:56,160 --> 00:13:04,470
parameters for the tagger let's kind of

00:13:01,019 --> 00:13:08,850
go look at it from a big perspective

00:13:04,470 --> 00:13:13,230
here the tagger is just a tool it's just

00:13:08,850 --> 00:13:16,289
a screwdriver or a hammer you can do

00:13:13,230 --> 00:13:18,809
lots with it it's what you do with it in

00:13:16,289 --> 00:13:20,499
combination with other things that makes

00:13:18,809 --> 00:13:22,959
it valuable in your app

00:13:20,499 --> 00:13:25,809
vacation so just tagging texts is a

00:13:22,959 --> 00:13:27,459
great parlor trick it's not useful in

00:13:25,809 --> 00:13:29,979
and of itself you need to combine this

00:13:27,459 --> 00:13:35,469
with other techniques so for example the

00:13:29,979 --> 00:13:41,129
text tagger text tags known strings it's

00:13:35,469 --> 00:13:44,769
not gonna pick out years or dates out of

00:13:41,129 --> 00:13:46,269
full text unless you had them as tags

00:13:44,769 --> 00:13:48,999
which would be kind of a ridiculous

00:13:46,269 --> 00:13:50,679
thing to do so you would use this in

00:13:48,999 --> 00:13:54,669
conjunction with other techniques that

00:13:50,679 --> 00:13:56,529
are going to understand the text so you

00:13:54,669 --> 00:13:58,149
could use regular expressions to pull

00:13:56,529 --> 00:14:01,479
out four digit numbers or email

00:13:58,149 --> 00:14:04,689
addresses or URLs or things of that

00:14:01,479 --> 00:14:07,329
nature the text tagger is not the tool

00:14:04,689 --> 00:14:10,959
for that so again it works in

00:14:07,329 --> 00:14:12,069
conjunction with those things and the

00:14:10,959 --> 00:14:13,929
types of things that you are going to

00:14:12,069 --> 00:14:16,419
use in conjunction with the context of

00:14:13,929 --> 00:14:18,129
the query all of the other things that

00:14:16,419 --> 00:14:19,419
you know about the user and the

00:14:18,129 --> 00:14:22,629
parameters are coming in on the query

00:14:19,419 --> 00:14:25,839
and so on so you need to leverage that

00:14:22,629 --> 00:14:28,419
as well as ultimately natural language

00:14:25,839 --> 00:14:33,669
processing if that's the the goal of

00:14:28,419 --> 00:14:35,649
your use case there so again just one

00:14:33,669 --> 00:14:39,369
piece of the puzzle but a very powerful

00:14:35,649 --> 00:14:41,309
useful piece of it you need a hammer but

00:14:39,369 --> 00:14:44,499
it's not the only tool in your toolbox

00:14:41,309 --> 00:14:48,819
the tagger collection while it is

00:14:44,499 --> 00:14:52,329
tagging known things you can build that

00:14:48,819 --> 00:14:55,419
collection any which way you like in my

00:14:52,329 --> 00:15:02,439
case I'm building it from a static data

00:14:55,419 --> 00:15:06,039
file of cities in other cases you could

00:15:02,439 --> 00:15:08,349
use machine learning to populate the

00:15:06,039 --> 00:15:10,989
tagger collection with things such as

00:15:08,349 --> 00:15:13,749
head and tail analysis and other query

00:15:10,989 --> 00:15:16,329
rewrites our own platform lucid works

00:15:13,749 --> 00:15:19,509
fusion leverages the text tagger in a

00:15:16,329 --> 00:15:24,309
very big way right now in the as a first

00:15:19,509 --> 00:15:28,179
stage in the query pipeline and in that

00:15:24,309 --> 00:15:31,439
stage we are tagging things that we have

00:15:28,179 --> 00:15:33,220
learned from the usage of the system so

00:15:31,439 --> 00:15:36,490
misspellings

00:15:33,220 --> 00:15:38,440
a head and tail analysis and other types

00:15:36,490 --> 00:15:42,759
of query right rules that are in there

00:15:38,440 --> 00:15:44,560
so again that's kind of a clever use of

00:15:42,759 --> 00:15:52,350
the tagger

00:15:44,560 --> 00:15:56,199
within a tool chain everybody ok so far

00:15:52,350 --> 00:15:58,079
okay so tagger in perspective let me

00:15:56,199 --> 00:16:00,699
just show you kind of the end goal of

00:15:58,079 --> 00:16:03,910
well actually let me take a quick look

00:16:00,699 --> 00:16:06,519
at my slides here make sure let me let

00:16:03,910 --> 00:16:09,160
me pause right there and bounce to a

00:16:06,519 --> 00:16:14,079
demo of the tagger so that you can see

00:16:09,160 --> 00:16:17,680
just the tagger itself in action

00:16:14,079 --> 00:16:20,050
I've got postman fired up right here I

00:16:17,680 --> 00:16:23,649
can send that same text so this is

00:16:20,050 --> 00:16:29,040
Berlin buzzwords here our buzzwords in

00:16:23,649 --> 00:16:33,189
Berlin and it matched the word Berlin in

00:16:29,040 --> 00:16:34,899
offsets thirteen to nineteen and I have

00:16:33,189 --> 00:16:36,430
that match text turned on so it actually

00:16:34,899 --> 00:16:38,680
told me that was Berlin I could have

00:16:36,430 --> 00:16:41,889
computed that by using those offsets

00:16:38,680 --> 00:16:45,360
into this text but it's a convenience to

00:16:41,889 --> 00:16:48,630
get that back and I get back a standard

00:16:45,360 --> 00:16:51,430
solar result set actually it's not

00:16:48,630 --> 00:16:53,110
relevancy ranked there's no scoring in

00:16:51,430 --> 00:16:56,550
what you get back you're just getting

00:16:53,110 --> 00:17:01,089
all of the tags up to the tags limit

00:16:56,550 --> 00:17:04,089
that that are in that text and it's not

00:17:01,089 --> 00:17:09,579
in any you know particular order there

00:17:04,089 --> 00:17:11,079
other than it's just all of them so now

00:17:09,579 --> 00:17:14,110
it's off to the races what do you do

00:17:11,079 --> 00:17:19,329
with this well let's see let me show you

00:17:14,110 --> 00:17:21,130
my tagger demo here's the documentation

00:17:19,329 --> 00:17:22,750
actually first things first the

00:17:21,130 --> 00:17:26,650
documentation and I want to point this

00:17:22,750 --> 00:17:29,169
out because this is an example of very

00:17:26,650 --> 00:17:32,919
very well done open source contribution

00:17:29,169 --> 00:17:36,250
a committer for the solar project David

00:17:32,919 --> 00:17:40,750
smiley created the solar text tagger and

00:17:36,250 --> 00:17:43,480
then contributed it to solar and he

00:17:40,750 --> 00:17:45,640
wrote a very nice tutorial about it and

00:17:43,480 --> 00:17:46,940
it just works right out of the box you

00:17:45,640 --> 00:17:49,850
fire up solar as

00:17:46,940 --> 00:17:52,130
is and you run through this tutorial

00:17:49,850 --> 00:17:53,810
with geonames which is kind of what I

00:17:52,130 --> 00:17:56,270
based my thing on with a couple of

00:17:53,810 --> 00:17:58,490
additional fields where you create a

00:17:56,270 --> 00:18:00,170
collection geonames you run that

00:17:58,490 --> 00:18:03,290
configuration like I said you need this

00:18:00,170 --> 00:18:06,380
catenate graph filter in there and then

00:18:03,290 --> 00:18:08,750
you need the tag request hand tagger

00:18:06,380 --> 00:18:11,060
request handler there so you can see it

00:18:08,750 --> 00:18:13,550
got registered as an endpoint slash tag

00:18:11,060 --> 00:18:16,970
and that's the tagger 2 configuration

00:18:13,550 --> 00:18:18,980
now load data now do queries and tags so

00:18:16,970 --> 00:18:21,920
you can see tag New York City and there

00:18:18,980 --> 00:18:24,670
it is so I just wanted to point that out

00:18:21,920 --> 00:18:27,050
because it's a very nice way to

00:18:24,670 --> 00:18:30,350
understand and have the tagger right

00:18:27,050 --> 00:18:33,860
there with you know a fairly large

00:18:30,350 --> 00:18:40,690
amount of of cities they're easily

00:18:33,860 --> 00:18:43,850
taggable let's see okay so tagger demo

00:18:40,690 --> 00:18:44,540
let's see I probably ought up a little

00:18:43,850 --> 00:18:47,420
bit here

00:18:44,540 --> 00:18:49,490
I did a meetup tour a couple of months

00:18:47,420 --> 00:18:51,920
ago and this is the demo I did for the

00:18:49,490 --> 00:18:53,810
meetup tour and one of the stops was in

00:18:51,920 --> 00:18:56,620
San Francisco so that's why the demo is

00:18:53,810 --> 00:19:00,440
tailored for that but I could easily say

00:18:56,620 --> 00:19:02,180
sushi in Berlin and it recognized Berlin

00:19:00,440 --> 00:19:06,050
as a city but you can see how many

00:19:02,180 --> 00:19:08,420
Berlin's there actually are in there and

00:19:06,050 --> 00:19:10,400
you can see where they are so this is

00:19:08,420 --> 00:19:12,860
the Germany one and so on all the

00:19:10,400 --> 00:19:15,530
different Berlin's this is the one in

00:19:12,860 --> 00:19:19,160
Wisconsin I believe it is

00:19:15,530 --> 00:19:20,450
I don't output which state it's in so

00:19:19,160 --> 00:19:25,610
you can see actually there's a number of

00:19:20,450 --> 00:19:27,950
Berlin's in the US actually alright so

00:19:25,610 --> 00:19:30,950
that's a quick view of this thing so I

00:19:27,950 --> 00:19:33,740
could do San let me go back to this one

00:19:30,950 --> 00:19:37,490
because it kind of points out that what

00:19:33,740 --> 00:19:41,330
I can do with that FQ clause with the

00:19:37,490 --> 00:19:44,300
tagger and limit which entities I'm

00:19:41,330 --> 00:19:48,230
going to tag and in this particular case

00:19:44,300 --> 00:19:50,030
the term San Francisco there's a whole

00:19:48,230 --> 00:19:52,460
lot of cities named San Francisco out

00:19:50,030 --> 00:19:54,920
there a lot 42 of them is what it's

00:19:52,460 --> 00:19:58,670
matching right now that doesn't really

00:19:54,920 --> 00:20:00,470
help me find sushi because sushi in San

00:19:58,670 --> 00:20:04,179
Francisco Costa Rica

00:20:00,470 --> 00:20:06,470
is not going to get there in time so I

00:20:04,179 --> 00:20:09,020
have this checkbox here when I check

00:20:06,470 --> 00:20:11,299
this checkbox it adds an FQ clause that

00:20:09,020 --> 00:20:13,700
limits it to the lat/long

00:20:11,299 --> 00:20:16,039
of our headquarters in downtown San

00:20:13,700 --> 00:20:19,809
Francisco so when I do that and it

00:20:16,039 --> 00:20:24,070
limits it to within 10 kilometers of

00:20:19,809 --> 00:20:30,740
this point this latitude longitude and

00:20:24,070 --> 00:20:35,120
now I only get one San Francisco ok so

00:20:30,740 --> 00:20:38,270
that's the magic of adding an FQ to the

00:20:35,120 --> 00:20:42,380
tagger to give some context to what your

00:20:38,270 --> 00:20:44,240
tagging in this particular collection

00:20:42,380 --> 00:20:47,049
that I have I'm going to show you two

00:20:44,240 --> 00:20:52,250
demos there are two separate solar

00:20:47,049 --> 00:20:54,530
collections I have some other entities

00:20:52,250 --> 00:20:57,110
in here I have a couple of colors in

00:20:54,530 --> 00:21:01,460
there I have that white linen brand in

00:20:57,110 --> 00:21:05,630
there and then I have cities so blue

00:21:01,460 --> 00:21:06,799
there's a color white is a color I don't

00:21:05,630 --> 00:21:11,630
have red in there just blue and white

00:21:06,799 --> 00:21:15,289
but white linen is a brand so what we

00:21:11,630 --> 00:21:25,510
can see down here is I used the

00:21:15,289 --> 00:21:26,720
parameter to only tag pull the no

00:21:25,510 --> 00:21:29,570
subtags

00:21:26,720 --> 00:21:31,760
so I don't get white as a color I only

00:21:29,570 --> 00:21:34,669
get it as a brand because it's white and

00:21:31,760 --> 00:21:36,950
then white linen and it removed inner

00:21:34,669 --> 00:21:39,470
tags and said you just really want the

00:21:36,950 --> 00:21:43,480
outer ones so I just get brands so I get

00:21:39,470 --> 00:21:48,130
brand white linen and I get color blue

00:21:43,480 --> 00:21:55,970
now I could say white linen in Berlin so

00:21:48,130 --> 00:21:57,679
why did it oh I see I still have this

00:21:55,970 --> 00:22:02,030
tag so I can't tag cities that are there

00:21:57,679 --> 00:22:04,309
sorry so let me go back to Berlin all

00:22:02,030 --> 00:22:06,080
right so I can tag three different types

00:22:04,309 --> 00:22:08,350
of entities there and you can see I'm

00:22:06,080 --> 00:22:11,120
still getting a lot of Berlin's

00:22:08,350 --> 00:22:13,610
but I have the the UI just highlights

00:22:11,120 --> 00:22:17,600
that that is a tag

00:22:13,610 --> 00:22:23,550
okay so that's the tagger in a nutshell

00:22:17,600 --> 00:22:26,210
what it can what it can do gonna go back

00:22:23,550 --> 00:22:26,210
to the slides

00:22:26,780 --> 00:22:38,490
alright so basic tagger next up is how

00:22:34,920 --> 00:22:39,450
to use this tagger within a chat

00:22:38,490 --> 00:22:43,190
application

00:22:39,450 --> 00:22:49,110
I created this silly thing called Lou

00:22:43,190 --> 00:22:53,730
lucid works Lou right so hey Lou who are

00:22:49,110 --> 00:22:56,810
you and I have a grammar document that

00:22:53,730 --> 00:22:59,760
responds with I'm Lou from lucid works

00:22:56,810 --> 00:23:02,190
those other bullet points there are the

00:22:59,760 --> 00:23:05,310
demo that I'm gonna do as well so I have

00:23:02,190 --> 00:23:11,250
those supported in in in the system as

00:23:05,310 --> 00:23:13,590
well here's what Lou does Lou tags and

00:23:11,250 --> 00:23:18,210
replaces things I called it things

00:23:13,590 --> 00:23:22,140
people call it entities same thing of I

00:23:18,210 --> 00:23:28,350
tag things mentioned in the utterance

00:23:22,140 --> 00:23:30,390
and it gives me back basic information

00:23:28,350 --> 00:23:31,860
the ID and the type and the name I'm not

00:23:30,390 --> 00:23:34,050
so concerned about the ID in this case

00:23:31,860 --> 00:23:39,380
really the type and the name are

00:23:34,050 --> 00:23:42,900
important here especially the type so

00:23:39,380 --> 00:23:44,610
and again like I mentioned in this

00:23:42,900 --> 00:23:47,430
tagger collection you can put in

00:23:44,610 --> 00:23:48,660
additional fields that are useful to you

00:23:47,430 --> 00:23:50,520
and type it happens to be one of these

00:23:48,660 --> 00:23:52,490
the tagger itself doesn't know anything

00:23:50,520 --> 00:23:58,020
about a type field that's just a

00:23:52,490 --> 00:23:59,490
construct that I made for this there's

00:23:58,020 --> 00:24:01,560
two collections there's the things

00:23:59,490 --> 00:24:02,970
collection and there's the grammar

00:24:01,560 --> 00:24:05,010
collection the grammar collection is

00:24:02,970 --> 00:24:05,760
just a straight-up default solar

00:24:05,010 --> 00:24:07,770
collection

00:24:05,760 --> 00:24:14,100
nothing specialized in there at this

00:24:07,770 --> 00:24:17,850
point and that contains utterances that

00:24:14,100 --> 00:24:21,480
I support that Luz supports and it does

00:24:17,850 --> 00:24:24,870
it in a slotted way such that I don't

00:24:21,480 --> 00:24:27,130
have a grammar item that says where is

00:24:24,870 --> 00:24:31,330
Berlin I have a grammar

00:24:27,130 --> 00:24:37,510
item that says where is city so when I

00:24:31,330 --> 00:24:40,090
tagged where is Berlin I replaced that

00:24:37,510 --> 00:24:44,170
through some processing in the query

00:24:40,090 --> 00:24:47,260
pipeline with where is city use that to

00:24:44,170 --> 00:24:51,250
query the grammar collection and now I

00:24:47,260 --> 00:24:54,490
have a match on that slotted or

00:24:51,250 --> 00:25:00,150
templated utterance and then I leveraged

00:24:54,490 --> 00:25:03,970
that the fields in that document tell me

00:25:00,150 --> 00:25:07,990
tillu what to do with the the grammar

00:25:03,970 --> 00:25:10,480
match so where is Berlin is at at where

00:25:07,990 --> 00:25:13,720
is city is attached to an action that

00:25:10,480 --> 00:25:15,820
says plot that city by lat/long on to

00:25:13,720 --> 00:25:16,590
OpenStreetMaps so we'll see that in a

00:25:15,820 --> 00:25:20,950
moment

00:25:16,590 --> 00:25:23,200
and this describes what I just said I

00:25:20,950 --> 00:25:25,120
should have gone to the slide earlier so

00:25:23,200 --> 00:25:28,960
where is Berlin the tagger comes along

00:25:25,120 --> 00:25:31,870
and says where is Berlin and that comes

00:25:28,960 --> 00:25:34,750
back with basically the the JSON looking

00:25:31,870 --> 00:25:37,000
stuff there and then in my grammar I

00:25:34,750 --> 00:25:39,010
have where is city so you can see type

00:25:37,000 --> 00:25:41,020
city there again just substituted that

00:25:39,010 --> 00:25:52,540
in there and looked at and then I render

00:25:41,020 --> 00:25:54,280
a map makes sense so the next thing I

00:25:52,540 --> 00:26:00,070
want to point out here before we really

00:25:54,280 --> 00:26:03,630
demo the the Luo system is that tags

00:26:00,070 --> 00:26:09,700
this tagger is an immensely valuable

00:26:03,630 --> 00:26:11,980
feature in a broad ecosystem of search

00:26:09,700 --> 00:26:14,650
applications and we have embedded the

00:26:11,980 --> 00:26:18,730
solar tagger in Toulouse it works fusion

00:26:14,650 --> 00:26:24,190
as a first pass in the query pipeline as

00:26:18,730 --> 00:26:27,300
such what it does is tags things that

00:26:24,190 --> 00:26:29,860
have been machine learned from

00:26:27,300 --> 00:26:32,320
underperforming queries with query

00:26:29,860 --> 00:26:34,360
rewriting with misspellings that have

00:26:32,320 --> 00:26:36,610
been detected with we have spark jobs

00:26:34,360 --> 00:26:39,539
that detect misspellings in the query

00:26:36,610 --> 00:26:43,649
logs phrase detection and

00:26:39,539 --> 00:26:46,109
detection all of those get machine

00:26:43,649 --> 00:26:48,239
learned through spark jobs written to a

00:26:46,109 --> 00:26:52,739
rewrite collection which is a tagger

00:26:48,239 --> 00:26:55,529
collection and then at query time this

00:26:52,739 --> 00:26:58,229
is what the default query pipeline and

00:26:55,529 --> 00:27:00,479
fusion looks like and the very first

00:26:58,229 --> 00:27:03,029
stage in our latest versions is that

00:27:00,479 --> 00:27:06,090
text tagger staged that text tagger

00:27:03,029 --> 00:27:11,759
stage is built to tag the Q parameter

00:27:06,090 --> 00:27:14,429
and you can control which of the machine

00:27:11,759 --> 00:27:17,940
learned pieces that you want to bring

00:27:14,429 --> 00:27:21,259
into the mix further down the query

00:27:17,940 --> 00:27:25,999
pipeline and it will use those to

00:27:21,259 --> 00:27:25,999
replace the query as it goes through

00:27:26,149 --> 00:27:46,590
okay so now is query time for Lu so

00:27:35,879 --> 00:27:48,090
let's take a look at Lu and i refresh

00:27:46,590 --> 00:27:52,830
this we'll get to that colorful thing in

00:27:48,090 --> 00:27:56,789
a minute I know that I'm gonna have

00:27:52,830 --> 00:27:59,129
additional time and I am prepared to

00:27:56,789 --> 00:28:00,570
kind of drill down into the inner

00:27:59,129 --> 00:28:04,019
workings of this thing so I'm going to

00:28:00,570 --> 00:28:06,769
show you this kind of methodically and

00:28:04,019 --> 00:28:10,830
then we'll take it from there and see

00:28:06,769 --> 00:28:15,299
how much more we break down what what

00:28:10,830 --> 00:28:17,759
makes this thing tick okay so I can type

00:28:15,299 --> 00:28:19,710
into this box but I have all of these

00:28:17,759 --> 00:28:26,210
items over here that I can just click on

00:28:19,710 --> 00:28:29,879
as if I typed it so I can say hey Lu

00:28:26,210 --> 00:28:35,330
what time time this is why I'm not going

00:28:29,879 --> 00:28:40,139
to type them all time is it okay so that

00:28:35,330 --> 00:28:41,369
utterance went to fusions query pipeline

00:28:40,139 --> 00:28:45,239
a custom query pipeline that I had

00:28:41,369 --> 00:28:47,460
developed that hits the tagger in this

00:28:45,239 --> 00:28:49,859
particular case there's nothing to tag

00:28:47,460 --> 00:28:52,680
because none of the utterance of the

00:28:49,859 --> 00:28:55,710
words or phrases in this text

00:28:52,680 --> 00:29:00,990
are in the tagger collection so it

00:28:55,710 --> 00:29:05,400
tagged nothing however I do have in my

00:29:00,990 --> 00:29:07,500
grammar collection and utterance called

00:29:05,400 --> 00:29:09,750
what time that says what time is it

00:29:07,500 --> 00:29:11,400
again I strip off hey Lu that's just

00:29:09,750 --> 00:29:13,110
kind of the prefix there so if that if

00:29:11,400 --> 00:29:15,300
that's in the front it stripped off and

00:29:13,110 --> 00:29:18,860
I so I have a grammar that says what

00:29:15,300 --> 00:29:24,500
time is it and the action of that is to

00:29:18,860 --> 00:29:28,080
client-side get the time and display it

00:29:24,500 --> 00:29:31,200
okay so what I'm gonna do

00:29:28,080 --> 00:29:35,250
refresh the browser here so I have I I

00:29:31,200 --> 00:29:38,400
built this late last night to set an

00:29:35,250 --> 00:29:40,350
alert at some point so what I can do is

00:29:38,400 --> 00:29:42,420
I click this one and again it's just

00:29:40,350 --> 00:29:44,940
like I typed it hey Lu remind me soon to

00:29:42,420 --> 00:29:47,340
wrap up this demo what that actually did

00:29:44,940 --> 00:29:50,190
was set a JavaScript timer in the

00:29:47,340 --> 00:29:53,550
browser and an alert will pop up in five

00:29:50,190 --> 00:29:56,490
minutes and you know let us know that we

00:29:53,550 --> 00:29:59,760
should move on to something else here so

00:29:56,490 --> 00:30:03,780
we've got that we did the what time is

00:29:59,760 --> 00:30:05,190
it hey Lou who are you like I just

00:30:03,780 --> 00:30:07,590
hard-coded some silly things in there

00:30:05,190 --> 00:30:08,340
nothing is tagged in that utterance

00:30:07,590 --> 00:30:12,350
either

00:30:08,340 --> 00:30:15,450
it's just a simple grammar match there

00:30:12,350 --> 00:30:19,230
hey Lou where are you again nothing is

00:30:15,450 --> 00:30:20,610
gonna get tagged in that one I just have

00:30:19,230 --> 00:30:27,090
kind of a hard code of grammar where are

00:30:20,610 --> 00:30:32,880
you where is Berlin and the zoom level

00:30:27,090 --> 00:30:38,370
is a little bit is a little bit low here

00:30:32,880 --> 00:30:41,460
but the lat/long of berlin is there now

00:30:38,370 --> 00:30:44,070
I my my you I I'm not a UI developer so

00:30:41,460 --> 00:30:48,410
it's not pretty just functional but I

00:30:44,070 --> 00:30:51,630
tagged I I list out as I'm doing this I

00:30:48,410 --> 00:30:53,850
collect in the browser all of the things

00:30:51,630 --> 00:30:57,630
or all of the entities that have ever

00:30:53,850 --> 00:30:59,250
been uttered in that session so the city

00:30:57,630 --> 00:31:01,770
Berlin I can click on that and actually

00:30:59,250 --> 00:31:04,640
you know get that get that back over

00:31:01,770 --> 00:31:04,640
here as well

00:31:05,300 --> 00:31:11,120
where is Berlin we did that one okay so

00:31:08,420 --> 00:31:13,790
now what is the population of Berlin

00:31:11,120 --> 00:31:16,670
also in that cities data that I have is

00:31:13,790 --> 00:31:17,630
population information so just like

00:31:16,670 --> 00:31:20,540
pulling out the lat/long

00:31:17,630 --> 00:31:22,100
I pull out the population there I don't

00:31:20,540 --> 00:31:24,050
know how dated this information is I'm

00:31:22,100 --> 00:31:28,250
sure it's some years old that data file

00:31:24,050 --> 00:31:31,100
I happen to live in Charlottesville

00:31:28,250 --> 00:31:38,540
Virginia so I can do that much smaller

00:31:31,100 --> 00:31:42,160
town so I have access in the response

00:31:38,540 --> 00:31:44,030
there all of the fields that are in that

00:31:42,160 --> 00:31:46,580
document that was put in the tag

00:31:44,030 --> 00:31:49,460
collection so in the cities again

00:31:46,580 --> 00:31:55,120
populations there there's there's zip

00:31:49,460 --> 00:31:58,880
code lat/long it's not zip code sorry

00:31:55,120 --> 00:32:00,410
country state so there's a there's a

00:31:58,880 --> 00:32:05,120
number of fields that are there that are

00:32:00,410 --> 00:32:06,890
useful okay so that's where the tagger

00:32:05,120 --> 00:32:08,690
came in again I can you know I can click

00:32:06,890 --> 00:32:10,910
on this entity we mentioned that one and

00:32:08,690 --> 00:32:18,530
that's you know lovely Charlottesville

00:32:10,910 --> 00:32:20,240
Virginia and let's see what else because

00:32:18,530 --> 00:32:22,220
I'm tagging things that are in my

00:32:20,240 --> 00:32:25,460
collection they're one of the things

00:32:22,220 --> 00:32:27,860
that I can do is inject additional tags

00:32:25,460 --> 00:32:31,640
and what I did in fusion was create a

00:32:27,860 --> 00:32:34,460
data source that index the names of the

00:32:31,640 --> 00:32:36,350
data sources available so in fusion we

00:32:34,460 --> 00:32:39,020
have a concept of data sources let's see

00:32:36,350 --> 00:32:44,750
if I can kind of pop over there to that

00:32:39,020 --> 00:32:50,330
and let's see one second I should have

00:32:44,750 --> 00:32:52,820
primed this up here so the things

00:32:50,330 --> 00:32:55,040
collection so the data sources that are

00:32:52,820 --> 00:32:58,250
available in my things collection our

00:32:55,040 --> 00:33:03,200
city's data sources and demo entities so

00:32:58,250 --> 00:33:05,210
if I run my data sources data source it

00:33:03,200 --> 00:33:06,800
populates the tagger collection with the

00:33:05,210 --> 00:33:08,660
names of the data sources and one of the

00:33:06,800 --> 00:33:13,490
data sources is called cities so what I

00:33:08,660 --> 00:33:16,760
can do here is learn cities and what

00:33:13,490 --> 00:33:19,130
that did was hit the Fusion API and

00:33:16,760 --> 00:33:23,600
started that data source

00:33:19,130 --> 00:33:26,510
in this case reindex the city's data so

00:33:23,600 --> 00:33:28,160
I could have other entities that are

00:33:26,510 --> 00:33:30,980
sitting there off the side that aren't

00:33:28,160 --> 00:33:33,650
learned yet and then learn those and

00:33:30,980 --> 00:33:36,050
they would kick those jobs off so the

00:33:33,650 --> 00:33:38,180
data source cities document looks like

00:33:36,050 --> 00:33:41,540
this so there's nothing in there other

00:33:38,180 --> 00:33:43,310
than its of type data source and it has

00:33:41,540 --> 00:33:46,640
a string called cities that we recognize

00:33:43,310 --> 00:33:50,390
so very simple there but because I know

00:33:46,640 --> 00:33:53,480
that it's a data source I can start it

00:33:50,390 --> 00:34:02,720
right so that type is a very special

00:33:53,480 --> 00:34:05,450
field in this case and finally last year

00:34:02,720 --> 00:34:08,060
I kind of I don't know what kind of

00:34:05,450 --> 00:34:10,820
motivated me but I love this game set do

00:34:08,060 --> 00:34:13,970
you know the game set the pattern

00:34:10,820 --> 00:34:16,580
matching game and I thought it would be

00:34:13,970 --> 00:34:18,409
fun to kind of build a JavaScript

00:34:16,580 --> 00:34:21,169
version of that just to kind of play

00:34:18,409 --> 00:34:23,090
around so I built that that's it's open

00:34:21,169 --> 00:34:25,340
source on my github my personal github

00:34:23,090 --> 00:34:28,399
and I embedded it in here so I can say

00:34:25,340 --> 00:34:31,700
hey Lu playset and it pops the board up

00:34:28,399 --> 00:34:34,010
in there and so I don't know is anybody

00:34:31,700 --> 00:34:36,649
see a set already in there there should

00:34:34,010 --> 00:34:40,060
be there's five sets in there I don't

00:34:36,649 --> 00:34:40,060
really see them that quickly

00:34:42,869 --> 00:34:49,149
I don't know well I can't think while

00:34:47,710 --> 00:34:51,730
I'm up here talking but there's five

00:34:49,149 --> 00:34:53,409
sets in this in that thing that have the

00:34:51,730 --> 00:34:55,240
right match there so you can play the

00:34:53,409 --> 00:34:58,660
little game through here so just a cute

00:34:55,240 --> 00:35:04,300
little Easter egg I put in there all

00:34:58,660 --> 00:35:05,920
right so I've been given the 5-minute

00:35:04,300 --> 00:35:11,589
alert so we've got a just a couple more

00:35:05,920 --> 00:35:14,530
minutes here I wrote a blog on the

00:35:11,589 --> 00:35:16,900
tagger as well about the kinds of things

00:35:14,530 --> 00:35:19,720
that you just saw and that is this right

00:35:16,900 --> 00:35:22,000
here so using a solar tagger for

00:35:19,720 --> 00:35:23,680
improving relevancy and I go through the

00:35:22,000 --> 00:35:26,410
stuff that you just saw a point at David

00:35:23,680 --> 00:35:30,930
Smiley's awesome presentation that

00:35:26,410 --> 00:35:30,930
details the gory

00:35:31,109 --> 00:35:37,480
Lusine magic using finite state

00:35:34,570 --> 00:35:39,880
transducers and the kind of the term

00:35:37,480 --> 00:35:42,550
magic and that catenate grass filter and

00:35:39,880 --> 00:35:45,070
all that he said goes very detailed into

00:35:42,550 --> 00:35:47,560
that and then I just go through the same

00:35:45,070 --> 00:35:51,550
thing of tagging cities and then you can

00:35:47,560 --> 00:35:53,170
pull the color blue off and boost or

00:35:51,550 --> 00:35:54,760
filter by blue if somebody searches for

00:35:53,170 --> 00:35:58,570
blue shoes right so now you've got

00:35:54,760 --> 00:36:01,119
better relevancy based off of that so

00:35:58,570 --> 00:36:04,420
there's that and let me just show you

00:36:01,119 --> 00:36:08,250
this one real quick so our chief

00:36:04,420 --> 00:36:11,260
algorithms officer Trey Granger took

00:36:08,250 --> 00:36:15,250
where I was with this tagger and thought

00:36:11,260 --> 00:36:17,470
of something even above and beyond

00:36:15,250 --> 00:36:20,250
thinking that I had about this stuff and

00:36:17,470 --> 00:36:22,900
he created commands that were tags and

00:36:20,250 --> 00:36:24,880
used the semantic knowledge graph which

00:36:22,900 --> 00:36:27,250
is another very special feature of solar

00:36:24,880 --> 00:36:29,349
and put all of that stuff together and

00:36:27,250 --> 00:36:31,000
when you say and haystack was a

00:36:29,349 --> 00:36:33,089
conference where he presented this so

00:36:31,000 --> 00:36:35,290
haystack in Charlottesville Virginia

00:36:33,089 --> 00:36:39,369
which is and his tagger

00:36:35,290 --> 00:36:43,599
parlance is an event that is tied to a

00:36:39,369 --> 00:36:46,270
venue that is tied to a location so you

00:36:43,599 --> 00:36:49,869
have to he used the graph parser to

00:36:46,270 --> 00:36:53,080
navigate from venue to for event to

00:36:49,869 --> 00:36:54,440
venue to location and then use the the

00:36:53,080 --> 00:36:56,210
tagger to tag near

00:36:54,440 --> 00:37:01,069
to get the command that means that

00:36:56,210 --> 00:37:02,450
you're gonna do a geo centric query

00:37:01,069 --> 00:37:04,160
there and they use the semantic

00:37:02,450 --> 00:37:08,000
knowledge graph for the pieces that were

00:37:04,160 --> 00:37:10,609
left over so that barbecue b BQ expands

00:37:08,000 --> 00:37:13,160
- meaning things that are restaurants

00:37:10,609 --> 00:37:15,410
that in the terms from the semantic

00:37:13,160 --> 00:37:19,250
knowledge graph our b BQ ribs brisket

00:37:15,410 --> 00:37:21,829
pork and type restaurants so all of that

00:37:19,250 --> 00:37:24,220
with a couple of pieces of technology

00:37:21,829 --> 00:37:28,490
from solar

00:37:24,220 --> 00:37:30,829
so in conclusion and i have a pointer

00:37:28,490 --> 00:37:32,539
there to trace stuff so please go visit

00:37:30,829 --> 00:37:34,760
that i'm very impressed by this i'm

00:37:32,539 --> 00:37:37,190
gonna start building stuff on top of the

00:37:34,760 --> 00:37:41,630
way he's doing it now seeing this

00:37:37,190 --> 00:37:44,000
cleverness so in conclusion the solar

00:37:41,630 --> 00:37:48,400
tagger provides known entity tagging of

00:37:44,000 --> 00:37:51,589
text it's very fast even on large text

00:37:48,400 --> 00:37:55,089
it's a great first stage i would dare

00:37:51,589 --> 00:37:58,329
say a necessary first stage in most

00:37:55,089 --> 00:38:02,359
scenarios that provides valuable

00:37:58,329 --> 00:38:04,190
metadata and matching there that can be

00:38:02,359 --> 00:38:07,210
leveraged to enhance query

00:38:04,190 --> 00:38:10,029
interpretation and result relevancy and

00:38:07,210 --> 00:38:12,829
it's useful in an index pipeline

00:38:10,029 --> 00:38:15,309
preprocessor to extract known entities

00:38:12,829 --> 00:38:20,650
and peel those away so that you have

00:38:15,309 --> 00:38:20,650
known things as facets or navigation

00:38:21,940 --> 00:38:27,950
alright so that's the conclusion of the

00:38:25,430 --> 00:38:32,270
Taggart talk while I have your attention

00:38:27,950 --> 00:38:33,829
I will invite you to our happy hour

00:38:32,270 --> 00:38:35,510
tonight

00:38:33,829 --> 00:38:36,680
I don't know Berlin but apparently this

00:38:35,510 --> 00:38:41,089
is only like a eight minute walk from

00:38:36,680 --> 00:38:49,039
here so please join us tonight for some

00:38:41,089 --> 00:38:51,470
beer and there's that let's see also I

00:38:49,039 --> 00:38:53,359
want to remind you visit our booth get a

00:38:51,470 --> 00:38:55,369
free t-shirt we do not want to carry

00:38:53,359 --> 00:38:59,760
these things home we would love for you

00:38:55,369 --> 00:39:06,349
to carry it home yourself thank you

00:38:59,760 --> 00:39:08,119
[Applause]

00:39:06,349 --> 00:39:11,390
I'm happy to take questions if there's

00:39:08,119 --> 00:39:14,000
time sure um since we have run out of

00:39:11,390 --> 00:39:19,570
time maybe one or two questions if you

00:39:14,000 --> 00:39:19,570
have any any questions

00:39:21,440 --> 00:39:25,310
so you mentioned indexing like in real

00:39:23,660 --> 00:39:27,650
time right when you can just trigger

00:39:25,310 --> 00:39:29,329
this endpoint for cities if you have a

00:39:27,650 --> 00:39:31,730
big collection of those whatever

00:39:29,329 --> 00:39:33,680
entities or things that you're having

00:39:31,730 --> 00:39:35,599
does it also influence performance of

00:39:33,680 --> 00:39:36,710
your as a request or is it like just

00:39:35,599 --> 00:39:38,780
forking and somewhere in the background

00:39:36,710 --> 00:39:43,579
what is the cost of running that for big

00:39:38,780 --> 00:39:47,150
collection the text tagger is extremely

00:39:43,579 --> 00:39:49,700
fast so it's not a performance

00:39:47,150 --> 00:39:52,220
bottleneck in that case if even having a

00:39:49,700 --> 00:39:54,320
lot of tags is not a problem based off

00:39:52,220 --> 00:39:55,670
of the data structure the way the and

00:39:54,320 --> 00:39:57,140
you can look at David Smiley's thing to

00:39:55,670 --> 00:40:00,530
see how it does it does it's magic

00:39:57,140 --> 00:40:02,450
so I would not say that there's going to

00:40:00,530 --> 00:40:03,530
be you're gonna encounter any issues one

00:40:02,450 --> 00:40:05,780
of the interesting things about the

00:40:03,530 --> 00:40:08,810
tagger collection is that because the

00:40:05,780 --> 00:40:10,700
documents are generally small you could

00:40:08,810 --> 00:40:12,530
create a very large tiger collection

00:40:10,700 --> 00:40:16,490
millions and millions of documents that

00:40:12,530 --> 00:40:20,510
that readily fit in a single core single

00:40:16,490 --> 00:40:22,040
node a single shard scenario and so one

00:40:20,510 --> 00:40:24,470
of the best practices that comes out of

00:40:22,040 --> 00:40:26,690
this is that because you're going to be

00:40:24,470 --> 00:40:29,270
running your text tagger a lot is to

00:40:26,690 --> 00:40:31,010
replicate that tagger collection to all

00:40:29,270 --> 00:40:35,329
your nodes so that they are just right

00:40:31,010 --> 00:40:44,540
there handy rather than having it just

00:40:35,329 --> 00:40:47,329
on a single node okay with that we come

00:40:44,540 --> 00:40:49,970
to the end of this session we thank you

00:40:47,329 --> 00:40:52,210
so very much for for having joined us

00:40:49,970 --> 00:40:56,219
and we thank you for thank you speaking

00:40:52,210 --> 00:40:56,219

YouTube URL: https://www.youtube.com/watch?v=I6LIS-VFbwk


