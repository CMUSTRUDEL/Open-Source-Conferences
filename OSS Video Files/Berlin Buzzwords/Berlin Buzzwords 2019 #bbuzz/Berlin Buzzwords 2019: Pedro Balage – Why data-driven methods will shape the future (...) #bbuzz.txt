Title: Berlin Buzzwords 2019: Pedro Balage – Why data-driven methods will shape the future (...) #bbuzz
Publication date: 2019-06-28
Playlist: Berlin Buzzwords 2019 #bbuzz
Description: 
	Pedro Balage talking about "Why data-driven methods will shape the future of relevance search".

You already have your search engine in place, users have started using it and now see that your results could do better. You hire some engineers to get you through this and they included a synonym here, an exception there, and asked you to create a taxonomy to organize your items. After a few months,  everything seems to work fine except for a few minor issues that you got your team working on. 

Now, your company needs to expand to meet the new demands of your business, so you get a wider range of products in your catalog. Your search results start to show some issues and your team is having a hard time controlling all of your search parameters and maintaining rules and exceptions. You know that improving your results will be the key to the success of your company. You now get yourself the biggest decision to make: should I hire more relevance engineers to handle it?

The first part of this talk will show why it is so complicated to scale an engineering approach of relevance based only on synonyms, taxonomies, rules, and exceptions. As a consequence of these limitations, the second part will focus on the latest advancements of natural language processing and information retrieval to show that all you need are good data scientists responsible for providing new data-driven solutions to your needs without causing any change into your search stack. 

With the vast amounts of data collected, you can find applications of it for all your search needs. The talk will guide you through topics such as language modeling for autocompletion, deep neural networks for named-entity recognition, network embeddings for relevance score, and query-product embeddings to improve the discoverability of your most exquisite items. All of this, optimized by your learning-to-rank algorithm and enabling you to personalization capabilities.

Read more:
https://2019.berlinbuzzwords.de/19/session/why-data-driven-methods-will-shape-future-relevance-search

About Pedro Balage:
https://2019.berlinbuzzwords.de/users/pedro-balage

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,720 --> 00:00:10,380
take a remote for evolution hello

00:00:08,040 --> 00:00:12,840
everyone good afternoon my name is petit

00:00:10,380 --> 00:00:15,540
balázs I'm currently lead data scientist

00:00:12,840 --> 00:00:18,420
at four fetch for fetches online

00:00:15,540 --> 00:00:20,039
e-commerce of fashion we have offices in

00:00:18,420 --> 00:00:22,769
Portugal we have offices in London and

00:00:20,039 --> 00:00:24,539
have offices worldwide today I'm not

00:00:22,769 --> 00:00:27,840
going to talk about for fetch I'm going

00:00:24,539 --> 00:00:29,640
to talk about how can you drive your

00:00:27,840 --> 00:00:32,279
search teams into the future using

00:00:29,640 --> 00:00:35,010
data-driven methods so to start the

00:00:32,279 --> 00:00:37,290
topic I will put a question here and I

00:00:35,010 --> 00:00:39,600
am going to ask you that what do you

00:00:37,290 --> 00:00:42,329
think about relevant search so some of

00:00:39,600 --> 00:00:44,160
you may not know search where may not

00:00:42,329 --> 00:00:47,010
know what means relevant search in the

00:00:44,160 --> 00:00:48,930
context of a commerce search so input

00:00:47,010 --> 00:00:50,820
some words and I explain later so

00:00:48,930 --> 00:00:52,649
relevant search is the ability to you to

00:00:50,820 --> 00:00:54,030
retrieve relevant results meaningful

00:00:52,649 --> 00:00:56,910
results you don't want to retrieve the

00:00:54,030 --> 00:00:59,250
results that are not cool to the user

00:00:56,910 --> 00:01:02,039
given the query or results that or you

00:00:59,250 --> 00:01:04,260
you don't want to miss out results that

00:01:02,039 --> 00:01:06,150
could be retrieved and the user could

00:01:04,260 --> 00:01:10,020
click and buy your product for example

00:01:06,150 --> 00:01:13,320
and the question that I put it because

00:01:10,020 --> 00:01:15,479
relevant searcher is today it's kind of

00:01:13,320 --> 00:01:18,360
art because it's a very complex and

00:01:15,479 --> 00:01:20,009
difficult thing so but before entering

00:01:18,360 --> 00:01:24,600
in relevant search entering the search

00:01:20,009 --> 00:01:26,070
problem let's start from and by the way

00:01:24,600 --> 00:01:28,680
this presentation is going to have some

00:01:26,070 --> 00:01:32,369
pieces of art let's start from the

00:01:28,680 --> 00:01:35,189
beginning this of how search teams are

00:01:32,369 --> 00:01:38,430
created and how relevant search comes

00:01:35,189 --> 00:01:40,140
into play so in the start when a company

00:01:38,430 --> 00:01:42,240
decides to implement some search

00:01:40,140 --> 00:01:44,040
mechanism for example does anybody have

00:01:42,240 --> 00:01:47,759
a search interface to the user it

00:01:44,040 --> 00:01:50,369
usually does not cause specialists that

00:01:47,759 --> 00:01:53,579
sit together in the table and have a

00:01:50,369 --> 00:01:55,500
very long run plan about how your search

00:01:53,579 --> 00:01:59,579
will be developed usually you call

00:01:55,500 --> 00:02:01,590
someone who is his CV has like elastic

00:01:59,579 --> 00:02:03,990
search or Solaire or something like that

00:02:01,590 --> 00:02:06,000
and ask okay could you please implement

00:02:03,990 --> 00:02:08,340
a search engine for us and that

00:02:06,000 --> 00:02:10,890
technician guy implement a search engine

00:02:08,340 --> 00:02:13,480
that works pretty well it's very simple

00:02:10,890 --> 00:02:16,540
straightforward to implement

00:02:13,480 --> 00:02:18,489
out-of-the-box solution nowadays so

00:02:16,540 --> 00:02:20,830
initially you focus on very technical

00:02:18,489 --> 00:02:23,860
specs you put that search engine to work

00:02:20,830 --> 00:02:25,959
but later when you run your business you

00:02:23,860 --> 00:02:28,030
starting figuring out that some of your

00:02:25,959 --> 00:02:30,340
results are not relevant or you are not

00:02:28,030 --> 00:02:32,830
retrieving given the queries you're not

00:02:30,340 --> 00:02:34,900
retrieving results that a user may like

00:02:32,830 --> 00:02:37,330
or you were treating a lot of results

00:02:34,900 --> 00:02:40,870
that the user is really not looking for

00:02:37,330 --> 00:02:44,560
so later it comes the attention to the

00:02:40,870 --> 00:02:45,459
search quality and we have a problem

00:02:44,560 --> 00:02:47,170
here

00:02:45,459 --> 00:02:51,579
the company starts to having a lot of

00:02:47,170 --> 00:02:54,970
pain problems or pain points first the

00:02:51,579 --> 00:02:57,280
lack of planning ahead so remember that

00:02:54,970 --> 00:03:00,310
you just put in place a search engine

00:02:57,280 --> 00:03:03,250
but you didn't figure out what the mens

00:03:00,310 --> 00:03:06,340
of expertise for your engineering team

00:03:03,250 --> 00:03:10,239
or for your search team in order to run

00:03:06,340 --> 00:03:12,970
this search engine so it kind of

00:03:10,239 --> 00:03:15,849
restricts the growth of your company and

00:03:12,970 --> 00:03:17,859
you know that any company nowadays needs

00:03:15,849 --> 00:03:23,500
to grow needs to be ahead of its

00:03:17,859 --> 00:03:25,109
competitors also you and probably that's

00:03:23,500 --> 00:03:28,419
the case you have a very good team of

00:03:25,109 --> 00:03:30,250
engineers that understands the technical

00:03:28,419 --> 00:03:32,889
specs of your relevant or your search

00:03:30,250 --> 00:03:33,730
engine but they like some expertise in

00:03:32,889 --> 00:03:35,739
search quality

00:03:33,730 --> 00:03:39,280
so usually you ask that guy that's

00:03:35,739 --> 00:03:40,950
usually a programmer or a DevOps to

00:03:39,280 --> 00:03:43,840
implement some relevant search

00:03:40,950 --> 00:03:47,019
measurement so to look for synonyms to

00:03:43,840 --> 00:03:49,750
look for related words to tweak boosts

00:03:47,019 --> 00:03:51,910
and that guy like oil I like to program

00:03:49,750 --> 00:03:54,130
I don't like to look for results and

00:03:51,910 --> 00:04:00,400
would like to really checking search

00:03:54,130 --> 00:04:03,519
quality and that complexity of imposing

00:04:00,400 --> 00:04:06,430
relevant search tasks to the team it

00:04:03,519 --> 00:04:07,319
just grows over time so it gets more and

00:04:06,430 --> 00:04:11,459
more complex

00:04:07,319 --> 00:04:14,109
let's check why so and just before I

00:04:11,459 --> 00:04:16,930
just give you some initial thoughts

00:04:14,109 --> 00:04:19,209
about relevant search revel search is a

00:04:16,930 --> 00:04:22,210
very difficult thing to state what it is

00:04:19,209 --> 00:04:23,370
so it's better to say what you should

00:04:22,210 --> 00:04:25,260
not have

00:04:23,370 --> 00:04:27,180
and then you can understand what

00:04:25,260 --> 00:04:28,919
relevant search is important so in your

00:04:27,180 --> 00:04:30,300
search engine what what are the things

00:04:28,919 --> 00:04:32,970
that should not happen

00:04:30,300 --> 00:04:34,710
you should not retrieve him you are also

00:04:32,970 --> 00:04:36,510
what should not happen you are

00:04:34,710 --> 00:04:39,510
retrieving items that are not relevant

00:04:36,510 --> 00:04:42,330
so we put a coil you have a product and

00:04:39,510 --> 00:04:45,449
that product is really doesn't what you

00:04:42,330 --> 00:04:48,300
want to just do by to your commerce or

00:04:45,449 --> 00:04:50,550
your missing items that are relevant so

00:04:48,300 --> 00:04:52,770
some our products are made it scribe

00:04:50,550 --> 00:04:55,110
with other words and then your queries

00:04:52,770 --> 00:04:56,850
just returning that specific words that

00:04:55,110 --> 00:04:58,770
the user party for and then therefore

00:04:56,850 --> 00:05:01,620
you don't have these products in your

00:04:58,770 --> 00:05:04,950
search results or you are showing the

00:05:01,620 --> 00:05:07,169
items but the top toppest items are not

00:05:04,950 --> 00:05:10,979
the relevant ones and then you have a

00:05:07,169 --> 00:05:12,600
problem of rank ranking here some steps

00:05:10,979 --> 00:05:16,020
sure relevant search there is very

00:05:12,600 --> 00:05:19,080
famous books available for relevant

00:05:16,020 --> 00:05:22,110
search for tweaking ask search Solar in

00:05:19,080 --> 00:05:27,060
terms of relevance and most of them are

00:05:22,110 --> 00:05:30,180
more technical but in a matter of points

00:05:27,060 --> 00:05:32,220
that a relevance engineer or someone in

00:05:30,180 --> 00:05:36,060
your company that may address relevance

00:05:32,220 --> 00:05:38,190
can work it's you can tweak the relevant

00:05:36,060 --> 00:05:41,039
score the way that you score your

00:05:38,190 --> 00:05:42,990
products against the queries that the

00:05:41,039 --> 00:05:45,060
users are doing for example can use

00:05:42,990 --> 00:05:49,380
tf-idf that's a common metric in

00:05:45,060 --> 00:05:51,330
information rhythm or PM 25 that's the

00:05:49,380 --> 00:05:53,520
current metric of relevance that's it's

00:05:51,330 --> 00:05:55,650
a variation of tftf that's play main

00:05:53,520 --> 00:05:57,780
data for elastic search for example you

00:05:55,650 --> 00:05:59,430
can use mood feud matching so you're not

00:05:57,780 --> 00:06:01,190
just looking for your product name but

00:05:59,430 --> 00:06:03,840
for a product description or for some

00:06:01,190 --> 00:06:05,880
categorical attributes of your product

00:06:03,840 --> 00:06:08,580
and then as you're looking for different

00:06:05,880 --> 00:06:11,789
fields you may need to require boosting

00:06:08,580 --> 00:06:13,979
so I want that a match in the name of

00:06:11,789 --> 00:06:16,169
the products more it should be much more

00:06:13,979 --> 00:06:18,470
relevant than a matching the description

00:06:16,169 --> 00:06:21,510
that should be more relevant that may be

00:06:18,470 --> 00:06:24,539
imagining some attributes so you need to

00:06:21,510 --> 00:06:27,389
boost distinctly itchy food and then you

00:06:24,539 --> 00:06:30,630
need to go to match or sale you how you

00:06:27,389 --> 00:06:32,219
match two strings so you could use a

00:06:30,630 --> 00:06:34,169
phrase matching matching the whole

00:06:32,219 --> 00:06:36,720
string you could use query matching so

00:06:34,169 --> 00:06:39,660
the terms in your query could

00:06:36,720 --> 00:06:41,280
match isolated and then you can consider

00:06:39,660 --> 00:06:43,230
if you're gonna use a composition from

00:06:41,280 --> 00:06:44,640
chef both and you can use for example

00:06:43,230 --> 00:06:48,710
for the matching that you're gonna match

00:06:44,640 --> 00:06:51,930
in terms that could contain month letter

00:06:48,710 --> 00:06:55,350
change it for example could have some

00:06:51,930 --> 00:06:58,020
fuzziness true to the original term some

00:06:55,350 --> 00:07:02,100
tech normalizations could also happens

00:06:58,020 --> 00:07:03,720
in place for a simple steaming dealing

00:07:02,100 --> 00:07:07,110
with florals or for example gender

00:07:03,720 --> 00:07:13,350
variations of the words are something

00:07:07,110 --> 00:07:16,620
that we usually do in search engines you

00:07:13,350 --> 00:07:19,380
may require two synonyms taxonomy and

00:07:16,620 --> 00:07:21,540
ontology that are somehow ways to

00:07:19,380 --> 00:07:26,010
include more knowledge to a retrieval

00:07:21,540 --> 00:07:29,280
and at the end you can you can resort to

00:07:26,010 --> 00:07:31,500
rules and exceptions so this is more or

00:07:29,280 --> 00:07:33,960
less a guide for someone that's working

00:07:31,500 --> 00:07:36,540
relevant search we try from the top and

00:07:33,960 --> 00:07:39,300
then we're trying to do things that are

00:07:36,540 --> 00:07:42,000
more or less common to all your keywords

00:07:39,300 --> 00:07:44,460
and at the end if nothing works you just

00:07:42,000 --> 00:07:47,610
put an exception the problem of putting

00:07:44,460 --> 00:07:50,370
rules and exceptions and to resource to

00:07:47,610 --> 00:07:52,760
use resource like synonyms taxonomy is

00:07:50,370 --> 00:07:55,770
how to keep them all right

00:07:52,760 --> 00:07:58,020
and my question to you is how is this

00:07:55,770 --> 00:08:00,150
human thing they control over all these

00:07:58,020 --> 00:08:02,160
parameters so if you are a relevance

00:08:00,150 --> 00:08:04,080
engineer if you're taking care of the

00:08:02,160 --> 00:08:07,410
relevant search of your e-commerce

00:08:04,080 --> 00:08:10,050
search how do you keep track of all the

00:08:07,410 --> 00:08:13,200
chains how you maintain control this is

00:08:10,050 --> 00:08:15,090
something very complex alright is a

00:08:13,200 --> 00:08:20,790
complex test because there is a lot of

00:08:15,090 --> 00:08:23,310
notes and knobs and buttons that need to

00:08:20,790 --> 00:08:25,710
press in order to configure URL ask

00:08:23,310 --> 00:08:29,880
search for example search engine in your

00:08:25,710 --> 00:08:33,240
ears over here and not usually they are

00:08:29,880 --> 00:08:35,339
independent let's say that if you change

00:08:33,240 --> 00:08:37,440
the boosts you may also need to change

00:08:35,339 --> 00:08:38,880
for this infrequently synonyms if you

00:08:37,440 --> 00:08:42,150
change the synonyms you know you need

00:08:38,880 --> 00:08:44,490
also to review some rules and then they

00:08:42,150 --> 00:08:47,070
are very dependent tasks so that's why

00:08:44,490 --> 00:08:48,910
they are complex and at the same time I

00:08:47,070 --> 00:08:51,370
asked for youth

00:08:48,910 --> 00:08:53,080
to work in a company that is targeted

00:08:51,370 --> 00:08:55,540
for the future is looking for growing

00:08:53,080 --> 00:08:58,690
looking for opening markets how do you

00:08:55,540 --> 00:09:01,000
expect to work in such environment that

00:08:58,690 --> 00:09:03,700
you need a complex team that you need to

00:09:01,000 --> 00:09:06,130
develop complex tasks in order to do

00:09:03,700 --> 00:09:08,260
very based not basically but a very

00:09:06,130 --> 00:09:11,700
straightforward thing that is relevant

00:09:08,260 --> 00:09:15,010
search so we are in an area of

00:09:11,700 --> 00:09:17,620
disruptive innovation we really want to

00:09:15,010 --> 00:09:20,770
be ahead of competitors we really want

00:09:17,620 --> 00:09:22,780
to deliver excellence what happens for

00:09:20,770 --> 00:09:26,230
example if you have new products if you

00:09:22,780 --> 00:09:28,570
receive for example a batch of you

00:09:26,230 --> 00:09:32,170
duplicate your catalog for example all

00:09:28,570 --> 00:09:34,120
the parameters all the knobs that you're

00:09:32,170 --> 00:09:37,570
read finally tune it in your search end

00:09:34,120 --> 00:09:39,730
engine needs to be changed again or you

00:09:37,570 --> 00:09:42,160
open to new markets or you have for

00:09:39,730 --> 00:09:44,260
example new categories what happens if

00:09:42,160 --> 00:09:46,240
you want to pursue internationalization

00:09:44,260 --> 00:09:49,930
of your business if you want to go to

00:09:46,240 --> 00:09:52,060
China or go to Russia or go to Arabic

00:09:49,930 --> 00:09:54,670
countries how are gonna deal with those

00:09:52,060 --> 00:09:57,430
languages do you need to require to hire

00:09:54,670 --> 00:09:59,620
more relevant engineers to hire more

00:09:57,430 --> 00:10:02,350
people who are going to scale in this

00:09:59,620 --> 00:10:06,130
age one thing for sure is that you

00:10:02,350 --> 00:10:08,740
require first adaptation and if you

00:10:06,130 --> 00:10:12,940
don't have a dictation you are not going

00:10:08,740 --> 00:10:14,380
to last too much in the business so my

00:10:12,940 --> 00:10:17,440
questions to you first question is

00:10:14,380 --> 00:10:20,230
whether searches a kind of heart and I

00:10:17,440 --> 00:10:21,910
agree with you with that and there are

00:10:20,230 --> 00:10:25,240
other questions can really well search

00:10:21,910 --> 00:10:28,720
be more signs and then now I'm gonna

00:10:25,240 --> 00:10:31,120
take more towards my bias and can ask

00:10:28,720 --> 00:10:33,690
you if that could be a data science

00:10:31,120 --> 00:10:37,450
because I'm from data science background

00:10:33,690 --> 00:10:39,880
so if you analyze just what kind of data

00:10:37,450 --> 00:10:42,640
because the science is based on the

00:10:39,880 --> 00:10:45,190
collection processing and ultimate isin

00:10:42,640 --> 00:10:47,230
twos based on data what kind of data do

00:10:45,190 --> 00:10:48,880
we have and we have a lot of data for

00:10:47,230 --> 00:10:50,800
example have search logs we know what

00:10:48,880 --> 00:10:52,570
the users are searching or nor website

00:10:50,800 --> 00:10:54,340
we have clicked through logs what the

00:10:52,570 --> 00:10:56,290
user are clicking we have navigation

00:10:54,340 --> 00:10:58,630
logs we understand how the user is

00:10:56,290 --> 00:11:01,390
navigating between pages what's the user

00:10:58,630 --> 00:11:02,760
track we have user preferences if the

00:11:01,390 --> 00:11:05,220
user is a

00:11:02,760 --> 00:11:08,040
for or have some preference for one

00:11:05,220 --> 00:11:11,090
specific category or bought some

00:11:08,040 --> 00:11:14,100
specific products we can also resource

00:11:11,090 --> 00:11:16,920
go to a/b testing if you want to collect

00:11:14,100 --> 00:11:19,170
more data specific to some hypothesis

00:11:16,920 --> 00:11:21,870
that we want to verify and you can go

00:11:19,170 --> 00:11:22,920
you can go to external sources so for

00:11:21,870 --> 00:11:25,410
example you can look for our competitors

00:11:22,920 --> 00:11:27,240
or can download some database that are

00:11:25,410 --> 00:11:32,100
available online in order to improve

00:11:27,240 --> 00:11:34,140
your your search engine so the lesson

00:11:32,100 --> 00:11:37,230
here is that we have a lot of data and a

00:11:34,140 --> 00:11:41,040
lot of an expert data how to export this

00:11:37,230 --> 00:11:43,560
data so data size contains both

00:11:41,040 --> 00:11:44,970
statistical methods to export data and

00:11:43,560 --> 00:11:47,970
also some machine learning methods to

00:11:44,970 --> 00:11:50,400
automate the exploration or to make some

00:11:47,970 --> 00:11:52,710
classification some decision function

00:11:50,400 --> 00:11:54,390
based on the data and the lesson that I

00:11:52,710 --> 00:11:58,020
want to bring here is that machine

00:11:54,390 --> 00:12:00,330
learning is not a very difficult thing

00:11:58,020 --> 00:12:04,740
no matter facts very easy ok if you look

00:12:00,330 --> 00:12:07,050
for and it is machine learning is just a

00:12:04,740 --> 00:12:09,120
mathematical function let's remember

00:12:07,050 --> 00:12:10,860
Euler and a definition of mathematical

00:12:09,120 --> 00:12:13,770
function that you receive a some

00:12:10,860 --> 00:12:16,110
parameter in the case a data all right

00:12:13,770 --> 00:12:18,660
and you try to model that using some

00:12:16,110 --> 00:12:20,580
parameters that it's not the case for us

00:12:18,660 --> 00:12:23,190
to discuss right now but it's just

00:12:20,580 --> 00:12:26,460
trying to mimic some behavior and then

00:12:23,190 --> 00:12:28,350
to produce an output ok the output of

00:12:26,460 --> 00:12:31,260
that function so you have an input data

00:12:28,350 --> 00:12:32,340
you model that function to a training

00:12:31,260 --> 00:12:34,140
algorithm that is going to be your

00:12:32,340 --> 00:12:35,970
machine learning algorithm and then you

00:12:34,140 --> 00:12:38,340
have a prediction the difference between

00:12:35,970 --> 00:12:40,380
your prediction your truth data is what

00:12:38,340 --> 00:12:42,240
your training our team is gonna look is

00:12:40,380 --> 00:12:44,910
gonna look for the patterns it's gonna

00:12:42,240 --> 00:12:47,160
input these patterns in your function

00:12:44,910 --> 00:12:48,990
and you're going to work with that so

00:12:47,160 --> 00:12:52,860
matter of fact is just a mathematical

00:12:48,990 --> 00:12:56,400
functions very simple so how can I use

00:12:52,860 --> 00:12:58,410
so if machine learning the mathematical

00:12:56,400 --> 00:13:00,300
function how can I use machine learning

00:12:58,410 --> 00:13:03,060
to build better

00:13:00,300 --> 00:13:06,050
search engines the traditional approach

00:13:03,060 --> 00:13:10,350
and the approach that I'm gonna pursue

00:13:06,050 --> 00:13:10,740
in the second part of this talk is this

00:13:10,350 --> 00:13:13,680
one

00:13:10,740 --> 00:13:15,490
so usually have different modules in the

00:13:13,680 --> 00:13:17,620
different modules you could have

00:13:15,490 --> 00:13:20,470
for example solutions in place that

00:13:17,620 --> 00:13:22,839
could be provided for your search engine

00:13:20,470 --> 00:13:25,540
or solutions that you could have a

00:13:22,839 --> 00:13:27,399
machine learning module in place you

00:13:25,540 --> 00:13:30,760
could have a round complete module you

00:13:27,399 --> 00:13:32,890
are complete it's gonna give you out

00:13:30,760 --> 00:13:35,910
complete or suggestions is gonna give

00:13:32,890 --> 00:13:39,300
you hints to your user in order to

00:13:35,910 --> 00:13:41,589
search for am a more specific term

00:13:39,300 --> 00:13:43,300
you're gonna you're gonna have a query

00:13:41,589 --> 00:13:44,770
understanding we're going to understand

00:13:43,300 --> 00:13:46,600
your query and what are the parts are

00:13:44,770 --> 00:13:48,430
carry and what the what the user

00:13:46,600 --> 00:13:51,339
intention you're gonna have a query

00:13:48,430 --> 00:13:53,140
expansion we're going to take this quite

00:13:51,339 --> 00:13:56,020
understanding and trying to go to your

00:13:53,140 --> 00:13:57,970
database and retrieve retrieve items

00:13:56,020 --> 00:13:59,830
that are relevant to that your original

00:13:57,970 --> 00:14:02,800
understanding you're going to try to

00:13:59,830 --> 00:14:05,110
risk or designs that you retrieved for

00:14:02,800 --> 00:14:07,390
some products you were ranked then

00:14:05,110 --> 00:14:10,470
you're gonna have your final products

00:14:07,390 --> 00:14:13,450
that's more or less a traditional

00:14:10,470 --> 00:14:16,899
architecture of search of course in

00:14:13,450 --> 00:14:19,149
order to provide data to all these

00:14:16,899 --> 00:14:20,890
modules or all these mathematical

00:14:19,149 --> 00:14:23,320
functions machine learning components

00:14:20,890 --> 00:14:28,200
you have your click locks and now the

00:14:23,320 --> 00:14:30,610
data that you have in your e-commerce

00:14:28,200 --> 00:14:32,680
but when it said that we are going to

00:14:30,610 --> 00:14:33,850
use data when in gain gonna use machine

00:14:32,680 --> 00:14:35,560
learning you also come up in your mind

00:14:33,850 --> 00:14:36,010
ok that guy's going to talk about you

00:14:35,560 --> 00:14:37,930
baloney

00:14:36,010 --> 00:14:40,029
all right or that guy's going to talk

00:14:37,930 --> 00:14:42,850
about some very weird to think that's

00:14:40,029 --> 00:14:44,620
gonna come queries products I'm gonna

00:14:42,850 --> 00:14:46,690
bed everything to the same space and

00:14:44,620 --> 00:14:48,970
predict in a matter of fact this is the

00:14:46,690 --> 00:14:53,140
modern approach there is some talks in

00:14:48,970 --> 00:14:55,600
the past here a bit I guess at building

00:14:53,140 --> 00:14:59,110
buzzwords as well to how to do product

00:14:55,600 --> 00:15:02,440
search using full end-to-end deploying

00:14:59,110 --> 00:15:05,290
approach ok so one thing that you could

00:15:02,440 --> 00:15:07,360
do is you have a queries you can have an

00:15:05,290 --> 00:15:09,339
encoding layer to encode the text in

00:15:07,360 --> 00:15:11,410
your queries in some numerical vector

00:15:09,339 --> 00:15:13,180
space so you have a numerical

00:15:11,410 --> 00:15:15,910
representation for queries you have your

00:15:13,180 --> 00:15:16,930
products you can have for example your

00:15:15,910 --> 00:15:18,430
product to name your product

00:15:16,930 --> 00:15:21,100
descriptions your product attributes in

00:15:18,430 --> 00:15:24,040
your product image and embed everything

00:15:21,100 --> 00:15:26,140
into encoding layer into again internal

00:15:24,040 --> 00:15:28,390
miracle representation of a product and

00:15:26,140 --> 00:15:29,569
if you use a mathematical function and

00:15:28,390 --> 00:15:32,600
autoimmune

00:15:29,569 --> 00:15:35,899
that's gonna map this to representations

00:15:32,600 --> 00:15:38,420
this modeling is gonna use the click

00:15:35,899 --> 00:15:40,220
logs to understand which queries lead to

00:15:38,420 --> 00:15:42,499
each products and it's going to build a

00:15:40,220 --> 00:15:44,990
representation forever to your modem the

00:15:42,499 --> 00:15:48,050
modem on the reports are amazing they

00:15:44,990 --> 00:15:50,360
are in that scientific perspective they

00:15:48,050 --> 00:15:53,959
are the most beautiful thing I ever saw

00:15:50,360 --> 00:15:58,040
in information three of them but they

00:15:53,959 --> 00:15:59,660
didn't work so well it's not the it's

00:15:58,040 --> 00:16:02,089
not effect so it's not the fact that

00:15:59,660 --> 00:16:05,420
they didn't work they work myself and my

00:16:02,089 --> 00:16:07,850
company with my team we tested some deep

00:16:05,420 --> 00:16:09,800
learning and twin approach they worked

00:16:07,850 --> 00:16:11,059
it pretty well but they have some issues

00:16:09,800 --> 00:16:14,360
some issues that we need to do for

00:16:11,059 --> 00:16:15,620
example bias in the data the

00:16:14,360 --> 00:16:17,569
distribution the data you have more

00:16:15,620 --> 00:16:19,100
products that are popular than the

00:16:17,569 --> 00:16:20,809
products that are not popular and how do

00:16:19,100 --> 00:16:22,610
you deal with unpopular products or

00:16:20,809 --> 00:16:25,459
products that do not have data to model

00:16:22,610 --> 00:16:27,920
your your your algorithms how are you

00:16:25,459 --> 00:16:30,230
tweak for example you're learning

00:16:27,920 --> 00:16:31,490
functions or how do you do if your loss

00:16:30,230 --> 00:16:34,129
functions so there is a lot of

00:16:31,490 --> 00:16:36,379
challenges ahead and I think that's why

00:16:34,129 --> 00:16:38,179
we are not still using that but I bet

00:16:36,379 --> 00:16:40,550
that in the future you're gonna see more

00:16:38,179 --> 00:16:42,139
and more these fool Tomatoes end-to-end

00:16:40,550 --> 00:16:45,110
approach but here today I'm going to

00:16:42,139 --> 00:16:47,209
talk about more more traditional

00:16:45,110 --> 00:16:50,029
architectures why because these

00:16:47,209 --> 00:16:52,759
architectures are very solid we know I

00:16:50,029 --> 00:16:55,759
know companies that are using this

00:16:52,759 --> 00:16:58,220
architecture so it's tested industry

00:16:55,759 --> 00:17:00,259
tested and the tech sector is very easy

00:16:58,220 --> 00:17:01,699
to be interpreted so if you're if you're

00:17:00,259 --> 00:17:03,709
relevant search if your query is not

00:17:01,699 --> 00:17:06,079
working you can open the components

00:17:03,709 --> 00:17:08,959
understand why okay and then you can

00:17:06,079 --> 00:17:11,809
support weekly support business needs if

00:17:08,959 --> 00:17:14,299
somehow someone or some of your boss

00:17:11,809 --> 00:17:16,760
knock your door and ask I want that done

00:17:14,299 --> 00:17:18,100
in two hours you're gonna be not going

00:17:16,760 --> 00:17:21,589
to be able to open the machine learning

00:17:18,100 --> 00:17:24,589
the neural network foo n2 any approach

00:17:21,589 --> 00:17:27,500
in order to tweak that but here you can

00:17:24,589 --> 00:17:31,070
add one rule add one exception it's much

00:17:27,500 --> 00:17:34,159
easier true to work with so in this talk

00:17:31,070 --> 00:17:38,600
this is the second part I'm gonna I hope

00:17:34,159 --> 00:17:39,980
I convinced you that it's necessary to

00:17:38,600 --> 00:17:42,419
have a better approach to relevant

00:17:39,980 --> 00:17:44,399
search that's not as complex as to

00:17:42,419 --> 00:17:46,679
someone to look for all that complexity

00:17:44,399 --> 00:17:49,559
that is to have synonyms to work with

00:17:46,679 --> 00:17:51,809
rules to work with parameters in your

00:17:49,559 --> 00:17:53,669
search ends engine and then I'm going to

00:17:51,809 --> 00:17:55,409
show you what's the path chordate

00:17:53,669 --> 00:17:59,960
relieved in search engine so remember

00:17:55,409 --> 00:17:59,960
the architecture that is poke you about

00:18:03,230 --> 00:18:08,549
we're going to start talking about out

00:18:06,720 --> 00:18:10,769
complete suggestions why does this

00:18:08,549 --> 00:18:12,419
components is most is one of the most

00:18:10,769 --> 00:18:15,080
component well important components for

00:18:12,419 --> 00:18:18,389
your company because it's here that you

00:18:15,080 --> 00:18:20,999
drive your users to what he's looking

00:18:18,389 --> 00:18:22,859
for most of the users start searching

00:18:20,999 --> 00:18:24,899
but they don't have a quite idea about

00:18:22,859 --> 00:18:27,239
what you're looking for especially if

00:18:24,899 --> 00:18:29,159
you are in a very specific domain for

00:18:27,239 --> 00:18:31,799
example fashion and the user is not a

00:18:29,159 --> 00:18:33,809
specialist of that domain so the user

00:18:31,799 --> 00:18:36,779
does not know the terms of that domain

00:18:33,809 --> 00:18:39,509
to search for and then enough complete

00:18:36,779 --> 00:18:42,989
you can help or support user in the

00:18:39,509 --> 00:18:45,659
exploration of your products there is a

00:18:42,989 --> 00:18:48,210
lot of alternatives so the most simple

00:18:45,659 --> 00:18:48,809
one you can implement that in a sequel

00:18:48,210 --> 00:18:51,480
database

00:18:48,809 --> 00:18:57,539
it's a feud based not complete so we

00:18:51,480 --> 00:19:02,879
just do that in select field like and

00:18:57,539 --> 00:19:05,309
you put like you just select thing in

00:19:02,879 --> 00:19:07,679
your field are the words that started

00:19:05,309 --> 00:19:08,789
with that prefix it's a very simple

00:19:07,679 --> 00:19:12,960
thing most of the companies are doing

00:19:08,789 --> 00:19:17,879
that what's what's not so good because

00:19:12,960 --> 00:19:19,470
it's very done you could also go to more

00:19:17,879 --> 00:19:21,330
sophisticated methods for example a

00:19:19,470 --> 00:19:23,700
phrase database not complete what does

00:19:21,330 --> 00:19:25,529
it means it means that you go to your

00:19:23,700 --> 00:19:26,909
search logs you go to your click logs

00:19:25,529 --> 00:19:29,399
and understand what the user is

00:19:26,909 --> 00:19:31,169
searching for and then you score the

00:19:29,399 --> 00:19:32,609
items that the user is searching but how

00:19:31,169 --> 00:19:34,409
do you do that for example you have a

00:19:32,609 --> 00:19:36,359
vocabulary things that the user usually

00:19:34,409 --> 00:19:39,179
type let's say that you have 2000 words

00:19:36,359 --> 00:19:41,840
and then you build a phrase database of

00:19:39,179 --> 00:19:44,909
the combination of all these words and

00:19:41,840 --> 00:19:46,919
within this phrase database you can have

00:19:44,909 --> 00:19:49,289
for example score this based on your

00:19:46,919 --> 00:19:51,899
training database in your search use use

00:19:49,289 --> 00:19:54,419
and then offer to the user in the

00:19:51,899 --> 00:19:55,559
autocomplete function okay one thing

00:19:54,419 --> 00:19:56,010
that's important

00:19:55,559 --> 00:19:58,710
the

00:19:56,010 --> 00:20:01,110
of course you you should prune this

00:19:58,710 --> 00:20:03,059
database because for example if you have

00:20:01,110 --> 00:20:05,340
two thousand items and you have just

00:20:03,059 --> 00:20:08,250
three words is two thousand in a

00:20:05,340 --> 00:20:09,960
combination of three times it's eight

00:20:08,250 --> 00:20:11,610
billion times so you don't have a

00:20:09,960 --> 00:20:13,410
database it's your keep that and it's

00:20:11,610 --> 00:20:16,200
just three words say we need to have

00:20:13,410 --> 00:20:19,590
some pruning mechanism for that one more

00:20:16,200 --> 00:20:22,140
wise way to do what complete it's called

00:20:19,590 --> 00:20:24,720
language modeling language modeling just

00:20:22,140 --> 00:20:26,160
to simplify you is what Google does when

00:20:24,720 --> 00:20:28,260
you go to Google search and it

00:20:26,160 --> 00:20:31,440
understands you it's the language

00:20:28,260 --> 00:20:33,120
modeling place so you could use a more

00:20:31,440 --> 00:20:36,750
probabilistic approach using hidden

00:20:33,120 --> 00:20:39,240
Markov models so you are modeling the

00:20:36,750 --> 00:20:40,860
probabilistic jump from one word draw

00:20:39,240 --> 00:20:42,840
the water from one character to other

00:20:40,860 --> 00:20:44,790
character all right using hidden Markov

00:20:42,840 --> 00:20:47,160
models or you could go to neural

00:20:44,790 --> 00:20:48,809
language modeling then your language

00:20:47,160 --> 00:20:51,750
modeling is the actual state of the art

00:20:48,809 --> 00:20:56,130
for this kind of tasks so this is the

00:20:51,750 --> 00:21:00,299
one I'm gonna exemplify badan and just

00:20:56,130 --> 00:21:02,669
to to tell you that's very learning very

00:21:00,299 --> 00:21:04,890
easy to learn such model you have a

00:21:02,669 --> 00:21:06,990
query you have your computer model your

00:21:04,890 --> 00:21:10,110
autocomplete is learning for click locks

00:21:06,990 --> 00:21:11,820
and hear yourself contain some learning

00:21:10,110 --> 00:21:14,730
model that's going to provide you the

00:21:11,820 --> 00:21:18,000
autocomplete function so language

00:21:14,730 --> 00:21:20,340
modeling they standard language modeling

00:21:18,000 --> 00:21:23,160
consists of recurrent neural networks

00:21:20,340 --> 00:21:25,230
that are these building blocks here and

00:21:23,160 --> 00:21:28,559
some embedded the space for them tokens

00:21:25,230 --> 00:21:31,169
could be the words or the characters you

00:21:28,559 --> 00:21:32,669
embed that to space that's very good for

00:21:31,169 --> 00:21:34,980
modeling because it don't have the

00:21:32,669 --> 00:21:36,929
restriction of how many words do you

00:21:34,980 --> 00:21:39,090
have you just embedded that to mean

00:21:36,929 --> 00:21:40,679
space and because it's a recurrence so

00:21:39,090 --> 00:21:44,130
it's the same cell that's recruiting

00:21:40,679 --> 00:21:46,440
time over time you are unbounded by the

00:21:44,130 --> 00:21:49,350
sentence length so it could have

00:21:46,440 --> 00:21:51,929
sentences you could have queries of all

00:21:49,350 --> 00:21:55,770
sizes so you're going to suggest for

00:21:51,929 --> 00:21:59,040
example a tenth or the length or how

00:21:55,770 --> 00:22:01,980
many words would you require and at the

00:21:59,040 --> 00:22:06,100
end you have modeling that with data you

00:22:01,980 --> 00:22:09,010
have the probability of scene

00:22:06,100 --> 00:22:12,220
a phrase seeing some set of words to

00:22:09,010 --> 00:22:14,410
predict the next word there is some

00:22:12,220 --> 00:22:16,270
vector representation of words exist in

00:22:14,410 --> 00:22:17,770
the literature you're going to find

00:22:16,270 --> 00:22:19,840
words of X a very popular one

00:22:17,770 --> 00:22:21,430
you also have aquarium rec there is no

00:22:19,840 --> 00:22:23,170
reference here and the slides are

00:22:21,430 --> 00:22:27,040
already available if you want to

00:22:23,170 --> 00:22:28,390
download it's good because you have

00:22:27,040 --> 00:22:30,610
involved in vocabulary and sentence

00:22:28,390 --> 00:22:33,490
sizes and it's very important because

00:22:30,610 --> 00:22:35,860
you can extend that language model for a

00:22:33,490 --> 00:22:38,650
sequence to sequence model and for

00:22:35,860 --> 00:22:41,740
example to adapt to do with Spelling's

00:22:38,650 --> 00:22:43,870
the user are doing right but it's

00:22:41,740 --> 00:22:46,180
missing some character you're out

00:22:43,870 --> 00:22:47,560
completes not gonna work anymore in this

00:22:46,180 --> 00:22:52,180
case it's gonna work because it's gonna

00:22:47,560 --> 00:22:53,980
be permissive to spelling errors any

00:22:52,180 --> 00:22:56,530
could also have different words so it

00:22:53,980 --> 00:22:58,210
starting looking for as some word and

00:22:56,530 --> 00:23:01,690
you have synonyms of that word you could

00:22:58,210 --> 00:23:05,950
not just not complete but out suggest to

00:23:01,690 --> 00:23:08,590
the user all right so there is a lot of

00:23:05,950 --> 00:23:10,120
different words in this direction quite

00:23:08,590 --> 00:23:13,210
understanding so the second step after

00:23:10,120 --> 00:23:16,060
or this is the first step or completed

00:23:13,210 --> 00:23:17,710
they start a self-contained so the

00:23:16,060 --> 00:23:21,790
cornerstone is the first step towards

00:23:17,710 --> 00:23:23,290
the total search relevance you could

00:23:21,790 --> 00:23:24,730
have different reports again you

00:23:23,290 --> 00:23:27,160
couldn't percolate your query there is a

00:23:24,730 --> 00:23:29,320
function in the major search engines

00:23:27,160 --> 00:23:33,190
that you could percolate queries and use

00:23:29,320 --> 00:23:38,650
that percolated results to understand or

00:23:33,190 --> 00:23:41,470
to match individual words against feuds

00:23:38,650 --> 00:23:43,120
in your database ok there is a lot of

00:23:41,470 --> 00:23:45,640
documentation about that or you could

00:23:43,120 --> 00:23:47,910
use some naming recognition system the

00:23:45,640 --> 00:23:50,380
name it recognition system is the most

00:23:47,910 --> 00:23:52,390
advanced in user approach where you're

00:23:50,380 --> 00:23:55,450
going to look for your sequence of words

00:23:52,390 --> 00:23:58,780
and understand when each word belongs or

00:23:55,450 --> 00:24:01,210
not your category trend or a size or

00:23:58,780 --> 00:24:03,430
true product name or true product or

00:24:01,210 --> 00:24:06,010
attribute alright so you're gonna find

00:24:03,430 --> 00:24:07,780
naming these these entities in your

00:24:06,010 --> 00:24:10,090
queries there is the conditional run of

00:24:07,780 --> 00:24:12,280
huge that's their standard another

00:24:10,090 --> 00:24:14,230
protein there's again the neuro

00:24:12,280 --> 00:24:17,140
name is recognition system that's the

00:24:14,230 --> 00:24:19,180
current state of the art so the narrow

00:24:17,140 --> 00:24:19,840
name is recognition system it's very

00:24:19,180 --> 00:24:21,580
similar

00:24:19,840 --> 00:24:23,920
the language model we have again the

00:24:21,580 --> 00:24:25,720
embedding layer we're going to embed

00:24:23,920 --> 00:24:28,060
each word that's a lexical

00:24:25,720 --> 00:24:29,710
representation into a numeric space and

00:24:28,060 --> 00:24:32,080
that's the trick of the near approach

00:24:29,710 --> 00:24:35,020
you need to embed that in America's

00:24:32,080 --> 00:24:37,390
space in that numeric space could for

00:24:35,020 --> 00:24:39,340
example model some similarity among

00:24:37,390 --> 00:24:41,650
words in the case of word track for

00:24:39,340 --> 00:24:44,260
example when used Latin Bernese you're

00:24:41,650 --> 00:24:46,210
gonna have an LST M lane because that

00:24:44,260 --> 00:24:48,100
gets to be directional because it it

00:24:46,210 --> 00:24:52,090
goes to both sides

00:24:48,100 --> 00:24:54,130
Alice TM it's AI space it's it's a unit

00:24:52,090 --> 00:24:55,870
that's some specification of the

00:24:54,130 --> 00:24:57,490
recurrent neural networks Steve a

00:24:55,870 --> 00:25:00,190
recurrent neural network but with some

00:24:57,490 --> 00:25:02,200
pluses let's say it's the most

00:25:00,190 --> 00:25:04,990
traditional approach to resilience for

00:25:02,200 --> 00:25:09,070
for this kind of task then you project

00:25:04,990 --> 00:25:12,490
for each word some projection of your

00:25:09,070 --> 00:25:15,630
state from the likes TM to a finer state

00:25:12,490 --> 00:25:19,660
where you're going to do some global

00:25:15,630 --> 00:25:23,260
some global normalization using Viterbi

00:25:19,660 --> 00:25:25,600
algorithm that gonna provide the output

00:25:23,260 --> 00:25:27,460
for each word the label that each word

00:25:25,600 --> 00:25:29,110
has for example if I have the first word

00:25:27,460 --> 00:25:31,660
that's a category is gonna say is a

00:25:29,110 --> 00:25:33,670
category the second word may be an

00:25:31,660 --> 00:25:36,490
attribute it is an attribute the third

00:25:33,670 --> 00:25:38,080
word may be starting for example Brent

00:25:36,490 --> 00:25:39,310
I'm gonna say this word is starting a

00:25:38,080 --> 00:25:41,950
brand that the second word is going to

00:25:39,310 --> 00:25:46,720
be the continuation of that brand and

00:25:41,950 --> 00:25:54,820
and so on okay why'd you use neuron

00:25:46,720 --> 00:25:57,580
image recognition state-of-the-art it's

00:25:54,820 --> 00:25:59,410
it's really one of the best it's not

00:25:57,580 --> 00:26:01,600
just a little bit more complicated it's

00:25:59,410 --> 00:26:03,970
in a matter of fact it's simpler then

00:26:01,600 --> 00:26:06,340
let's hear if the models are very easy

00:26:03,970 --> 00:26:10,330
you could that you could that in Python

00:26:06,340 --> 00:26:11,560
with six or seven lines of code using

00:26:10,330 --> 00:26:14,430
standard frameworks for deep learning

00:26:11,560 --> 00:26:17,170
it's very easy to do that it could do

00:26:14,430 --> 00:26:20,680
with some word variations when use some

00:26:17,170 --> 00:26:23,230
character in bindings for that and

00:26:20,680 --> 00:26:26,500
misspellings usually requires

00:26:23,230 --> 00:26:28,900
what's cone here but it's something that

00:26:26,500 --> 00:26:30,130
we're used to in machine learning you

00:26:28,900 --> 00:26:33,620
require data to Train

00:26:30,130 --> 00:26:37,010
so it may require some human annotate

00:26:33,620 --> 00:26:38,990
chill a/b label you some data with

00:26:37,010 --> 00:26:41,090
entities there is how some companies

00:26:38,990 --> 00:26:43,700
that could provide that and there is a

00:26:41,090 --> 00:26:47,000
set of open-source libraries available I

00:26:43,700 --> 00:26:48,670
know that saloon for example a very

00:26:47,000 --> 00:26:51,500
interesting and good company

00:26:48,670 --> 00:26:54,640
open-source the Flair that's a framework

00:26:51,500 --> 00:26:58,250
to do name it recognition it's among the

00:26:54,640 --> 00:27:01,250
state-of-the-art of tools for that is

00:26:58,250 --> 00:27:04,250
very simple to use okay

00:27:01,250 --> 00:27:06,860
second component in my opinion the most

00:27:04,250 --> 00:27:08,570
important one query expansion okay I

00:27:06,860 --> 00:27:10,430
understood the query so I have the

00:27:08,570 --> 00:27:12,200
annotated a query stating which sky

00:27:10,430 --> 00:27:16,490
category which the designer which the

00:27:12,200 --> 00:27:18,650
term that I don't know what can I do in

00:27:16,490 --> 00:27:22,460
terms of search with that that query

00:27:18,650 --> 00:27:24,650
expansion module is gonna tell me what I

00:27:22,460 --> 00:27:26,780
should do for example I could go to a

00:27:24,650 --> 00:27:30,440
faceted search when for example if the

00:27:26,780 --> 00:27:31,610
user just put a word that for me means a

00:27:30,440 --> 00:27:34,010
category

00:27:31,610 --> 00:27:35,930
I just want to apply the category filter

00:27:34,010 --> 00:27:37,670
on a website and retrieve all the

00:27:35,930 --> 00:27:41,870
results from that category I don't

00:27:37,670 --> 00:27:44,930
really need to go to retrieving a lot of

00:27:41,870 --> 00:27:46,730
items I just apply facets here I could

00:27:44,930 --> 00:27:48,080
go to different paths so imagine here in

00:27:46,730 --> 00:27:50,980
the CRO explanation model that you have

00:27:48,080 --> 00:27:53,540
a to its position its position so

00:27:50,980 --> 00:27:55,820
several additional knowledge ease okay

00:27:53,540 --> 00:27:58,190
and effort each additional knowledge you

00:27:55,820 --> 00:27:58,910
don't know too much if that's gonna help

00:27:58,190 --> 00:28:00,830
or not

00:27:58,910 --> 00:28:03,650
so you're going to take different paths

00:28:00,830 --> 00:28:07,310
you're gonna in q1 try for example

00:28:03,650 --> 00:28:10,220
facets in key to try synonyms or maybe

00:28:07,310 --> 00:28:12,530
expand similar words in q3 taxonomy

00:28:10,220 --> 00:28:14,090
Scientologist knowledge graphs you can

00:28:12,530 --> 00:28:16,160
have for example taxonomy zoom:1

00:28:14,090 --> 00:28:18,290
ontology and all other so it's not

00:28:16,160 --> 00:28:20,810
bounded it to four okay just president

00:28:18,290 --> 00:28:24,110
purification can have as many as you

00:28:20,810 --> 00:28:25,930
wish of course there is here Samara

00:28:24,110 --> 00:28:28,910
Samsung engineering

00:28:25,930 --> 00:28:32,000
concern but let's say that you can have

00:28:28,910 --> 00:28:34,250
as many different components as you want

00:28:32,000 --> 00:28:36,980
and it can also have some graphic based

00:28:34,250 --> 00:28:38,960
techniques i will exemplify this last

00:28:36,980 --> 00:28:43,220
one that's a very interesting one to

00:28:38,960 --> 00:28:45,650
extract from Dayton if we look for our

00:28:43,220 --> 00:28:47,000
click logs what you're gonna find we're

00:28:45,650 --> 00:28:49,549
gonna find in one side

00:28:47,000 --> 00:28:51,080
queries in and other side I think that

00:28:49,549 --> 00:28:54,830
we retrieve usually products for a

00:28:51,080 --> 00:28:57,860
commerce okay and you guys see that said

00:28:54,830 --> 00:29:00,049
one query lead to a click in one product

00:28:57,860 --> 00:29:02,390
and another and another or the query

00:29:00,049 --> 00:29:04,549
needed to click to other products what

00:29:02,390 --> 00:29:07,690
kind of information and that's my

00:29:04,549 --> 00:29:10,490
question you can I were to affirm that

00:29:07,690 --> 00:29:12,169
that's a lot of things work with so

00:29:10,490 --> 00:29:15,470
there is a lot of information that's led

00:29:12,169 --> 00:29:17,809
latent to this representation one

00:29:15,470 --> 00:29:20,150
example I could look for all the queries

00:29:17,809 --> 00:29:21,860
that are related if you one query led to

00:29:20,150 --> 00:29:23,809
the semi-products exactly the same

00:29:21,860 --> 00:29:27,020
products as the other query the two

00:29:23,809 --> 00:29:28,400
queries are similar okay if the

00:29:27,020 --> 00:29:31,190
intersection of the products that two

00:29:28,400 --> 00:29:32,780
queries led to are like eighty ninety

00:29:31,190 --> 00:29:35,600
percent I could say that they are eighty

00:29:32,780 --> 00:29:37,460
ninety percent similar okay you could

00:29:35,600 --> 00:29:39,260
retrieve that the same in the product

00:29:37,460 --> 00:29:42,980
side I could look for the product side

00:29:39,260 --> 00:29:45,320
and see which products are similar so

00:29:42,980 --> 00:29:46,580
they should be clustered together and if

00:29:45,320 --> 00:29:49,010
you look some products that are very

00:29:46,580 --> 00:29:50,630
similar and one query is not is

00:29:49,010 --> 00:29:52,370
retrieving this product but not the

00:29:50,630 --> 00:29:53,900
other I could for example tell my search

00:29:52,370 --> 00:29:58,039
engine to hit rip the other project and

00:29:53,900 --> 00:30:01,010
send that additional information you

00:29:58,039 --> 00:30:03,080
could also do some transferring so I

00:30:01,010 --> 00:30:05,450
understand direct Perry B contains some

00:30:03,080 --> 00:30:08,659
terms some words and then I'm gonna

00:30:05,450 --> 00:30:10,250
transfer these attributes to the other

00:30:08,659 --> 00:30:12,650
products that the query B is related

00:30:10,250 --> 00:30:14,659
true okay these products they contain

00:30:12,650 --> 00:30:17,179
attributes as well as gonna and then I'm

00:30:14,659 --> 00:30:19,340
gonna transfer back these attributes and

00:30:17,179 --> 00:30:21,679
I'm gonna jump in from one side or the

00:30:19,340 --> 00:30:24,590
side transferring this knowledge and

00:30:21,679 --> 00:30:26,450
then the end I'm gonna converge in the

00:30:24,590 --> 00:30:29,059
same vector space of representation of

00:30:26,450 --> 00:30:32,600
wolf sites okay that's the idea for

00:30:29,059 --> 00:30:33,919
example of a vector propagation there is

00:30:32,600 --> 00:30:38,419
the paper here it's a very interesting

00:30:33,919 --> 00:30:40,010
work we already work refactor this kind

00:30:38,419 --> 00:30:43,130
of techniques and they are they are very

00:30:40,010 --> 00:30:45,980
good we couldn't go further graphing

00:30:43,130 --> 00:30:48,980
banning is one of the most recent

00:30:45,980 --> 00:30:51,500
techniques 2018 that also does the same

00:30:48,980 --> 00:30:53,990
it's more specific graphic embeddings

00:30:51,500 --> 00:30:57,770
true recommendation systems but it works

00:30:53,990 --> 00:31:00,320
perfectly in such results and then you

00:30:57,770 --> 00:31:04,909
can use all these informations to

00:31:00,320 --> 00:31:08,210
to improve your search queries of course

00:31:04,909 --> 00:31:12,860
I got a lot of results and then I got

00:31:08,210 --> 00:31:14,269
results from q1 q3 before I have for

00:31:12,860 --> 00:31:15,679
some results I have the same products

00:31:14,269 --> 00:31:17,120
for all these I have extreme products

00:31:15,679 --> 00:31:21,049
how am I going

00:31:17,120 --> 00:31:23,240
risk or that bunch of scores okay

00:31:21,049 --> 00:31:25,460
because I have different paths in each

00:31:23,240 --> 00:31:27,860
path my me trust a little bit more a

00:31:25,460 --> 00:31:31,190
little bit less for that I'm gonna use a

00:31:27,860 --> 00:31:33,860
parameterized model or parameterized a

00:31:31,190 --> 00:31:35,750
function this is very used to the

00:31:33,860 --> 00:31:38,539
literature for example the goo-goo

00:31:35,750 --> 00:31:41,299
engine uses that okay this is a very

00:31:38,539 --> 00:31:44,149
simple function here I'm going just to

00:31:41,299 --> 00:31:46,220
interpolate out this course for each

00:31:44,149 --> 00:31:50,899
product all the scores that are received

00:31:46,220 --> 00:31:53,750
in this lanes let's say by some lambda

00:31:50,899 --> 00:31:55,639
factor so lambda 1 is a nice color

00:31:53,750 --> 00:31:59,600
it's a numeric value that's gonna tell

00:31:55,639 --> 00:32:01,370
the importance of the Q 1 lambda 2 is or

00:31:59,600 --> 00:32:03,169
the numeric value that's gonna tell the

00:32:01,370 --> 00:32:05,899
importance of kitchen and so on

00:32:03,169 --> 00:32:07,490
I could also have a very more detailed a

00:32:05,899 --> 00:32:09,559
machine learning model but I'm just

00:32:07,490 --> 00:32:12,889
going to attain to the simplicity of

00:32:09,559 --> 00:32:16,309
this concept here and then I may use

00:32:12,889 --> 00:32:19,820
some click logs children so I have for

00:32:16,309 --> 00:32:22,700
example here I receive a product here

00:32:19,820 --> 00:32:26,090
I didn't he or no here I received my

00:32:22,700 --> 00:32:28,039
score here another here another and this

00:32:26,090 --> 00:32:31,220
product was click 'add so I'm going to

00:32:28,039 --> 00:32:32,929
reinforce that this is called a right if

00:32:31,220 --> 00:32:37,159
the product are not click 'add for

00:32:32,929 --> 00:32:40,519
example or are miss it we can tell also

00:32:37,159 --> 00:32:43,009
to to the learn mechanism that it should

00:32:40,519 --> 00:32:45,500
not be enforced for example you could

00:32:43,009 --> 00:32:48,590
use some learning in the direction of

00:32:45,500 --> 00:32:50,679
course after I have a lot of products

00:32:48,590 --> 00:32:53,179
and I have a lot of products wrist cord

00:32:50,679 --> 00:32:54,559
remember that I expanded my knowledge

00:32:53,179 --> 00:32:57,110
so I'm retrieving more products than

00:32:54,559 --> 00:33:01,789
necessary so instead of retrieving just

00:32:57,110 --> 00:33:05,539
like 100 I'm retrieving 1000 but they

00:33:01,789 --> 00:33:08,419
don't want to display to user then 1000

00:33:05,539 --> 00:33:13,129
products I want to find that the point

00:33:08,419 --> 00:33:13,970
and I and then here I assume that they

00:33:13,129 --> 00:33:16,370
are rain

00:33:13,970 --> 00:33:18,290
by relevance I want to find a point

00:33:16,370 --> 00:33:20,420
where the problems are not really want

00:33:18,290 --> 00:33:22,730
to declare anymore and then I'm going to

00:33:20,420 --> 00:33:25,370
start from top to down and find a point

00:33:22,730 --> 00:33:28,460
where I'm gonna cut that so for example

00:33:25,370 --> 00:33:29,960
in your last you have some threshold cut

00:33:28,460 --> 00:33:32,030
that you could impose to your search and

00:33:29,960 --> 00:33:34,910
say after that relevance score

00:33:32,030 --> 00:33:36,980
I mean don't want more lightens okay

00:33:34,910 --> 00:33:39,050
that's aesthetic you could use a more

00:33:36,980 --> 00:33:41,900
dynamic approach for example using the

00:33:39,050 --> 00:33:44,300
standard deviation of your results it's

00:33:41,900 --> 00:33:46,580
better or you could also use machine

00:33:44,300 --> 00:33:48,020
learning to determine debt so use

00:33:46,580 --> 00:33:49,790
machine learning based on click logs of

00:33:48,020 --> 00:33:51,980
course you're going to need to start

00:33:49,790 --> 00:33:54,530
with a more permissive approach you're

00:33:51,980 --> 00:33:56,930
gonna need to show to the users more

00:33:54,530 --> 00:33:58,070
items so the user may click or not click

00:33:56,930 --> 00:34:00,260
and then you're going to learn a

00:33:58,070 --> 00:34:04,360
function in order to understand where is

00:34:00,260 --> 00:34:09,130
the best point to cut so far so good

00:34:04,360 --> 00:34:11,240
perfect so the last one is about ranking

00:34:09,130 --> 00:34:13,880
I'm not going to pay so much attention

00:34:11,240 --> 00:34:15,500
about ranking because the ranking there

00:34:13,880 --> 00:34:17,870
is a lot of algorithms the algorithms

00:34:15,500 --> 00:34:21,020
themselves they have a lot of different

00:34:17,870 --> 00:34:22,460
mathematical concepts but here I just

00:34:21,020 --> 00:34:24,470
want to mention you that they already

00:34:22,460 --> 00:34:27,170
have my relevance results so I'm a

00:34:24,470 --> 00:34:29,420
relevant search ends here okay I read

00:34:27,170 --> 00:34:32,480
have the set of results that are

00:34:29,420 --> 00:34:35,720
relevant but for some aspects I want to

00:34:32,480 --> 00:34:39,110
hear rank then I I know that they are

00:34:35,720 --> 00:34:41,990
relevant but I want to rank for example

00:34:39,110 --> 00:34:42,530
to improve my profitability of my

00:34:41,990 --> 00:34:44,720
business

00:34:42,530 --> 00:34:50,060
right so I want to put the Polish that

00:34:44,720 --> 00:34:51,770
has more margin of gain first or for

00:34:50,060 --> 00:34:54,320
example I have some business decisions I

00:34:51,770 --> 00:34:58,010
want to boost the sales or for some

00:34:54,320 --> 00:35:00,230
brand or for some partner alright so for

00:34:58,010 --> 00:35:02,630
that the ranking it's a module itself

00:35:00,230 --> 00:35:05,000
and then in the ranking capability to

00:35:02,630 --> 00:35:07,520
have different irregular items they are

00:35:05,000 --> 00:35:10,430
pretty standard some of them already

00:35:07,520 --> 00:35:11,930
implemented in the most recent search

00:35:10,430 --> 00:35:15,350
engines or the most standard search

00:35:11,930 --> 00:35:20,720
engines and you can work with them okay

00:35:15,350 --> 00:35:21,470
but at the end just true to conclude my

00:35:20,720 --> 00:35:23,690
line of thought

00:35:21,470 --> 00:35:25,310
showing you how these components I could

00:35:23,690 --> 00:35:27,770
say odds components they are machine

00:35:25,310 --> 00:35:30,800
learning and then I said to you that

00:35:27,770 --> 00:35:32,930
machine learning is a function so if I

00:35:30,800 --> 00:35:35,480
have for all the components machine

00:35:32,930 --> 00:35:38,530
learning I have a set of functions one

00:35:35,480 --> 00:35:43,070
of the other if I now work in that way a

00:35:38,530 --> 00:35:44,180
set of the following functions it's so

00:35:43,070 --> 00:35:46,250
every company into a subject

00:35:44,180 --> 00:35:49,790
architecture is a function a composition

00:35:46,250 --> 00:35:52,670
of functions is also a function so every

00:35:49,790 --> 00:35:54,530
how that architecture is here is a

00:35:52,670 --> 00:35:56,180
single function of course you could

00:35:54,530 --> 00:35:57,860
componentize that you could work with

00:35:56,180 --> 00:35:59,330
different components but what I'm

00:35:57,860 --> 00:36:02,660
explained to you is that as as I'm

00:35:59,330 --> 00:36:04,850
inputting data from our logs and then

00:36:02,660 --> 00:36:07,070
extracting some predictive models I

00:36:04,850 --> 00:36:09,530
could work that as a single function I

00:36:07,070 --> 00:36:11,330
could work with that as I have just one

00:36:09,530 --> 00:36:14,360
function that you tell me relevance and

00:36:11,330 --> 00:36:18,290
I don't want to look for synonyms I

00:36:14,360 --> 00:36:20,930
don't want to look for nerds and knob

00:36:18,290 --> 00:36:24,980
knobs and buttons that I need to push in

00:36:20,930 --> 00:36:30,380
this search engine anymore so it's much

00:36:24,980 --> 00:36:34,400
more simpler more as it's a function I

00:36:30,380 --> 00:36:36,800
could condition that function to

00:36:34,400 --> 00:36:40,580
particular interests so for example I'm

00:36:36,800 --> 00:36:41,690
taking my data and I might here you

00:36:40,580 --> 00:36:44,570
understand that I take you the holiday

00:36:41,690 --> 00:36:47,390
to but if I want to have a specific view

00:36:44,570 --> 00:36:49,280
for an user segment so I know that some

00:36:47,390 --> 00:36:51,710
specific users the VIP uses for example

00:36:49,280 --> 00:36:53,810
they bought more of this product or some

00:36:51,710 --> 00:36:56,060
users are more trained in to buy some

00:36:53,810 --> 00:36:58,130
ordered specific product or I'm pushing

00:36:56,060 --> 00:37:00,710
some marketing of veins or I want to do

00:36:58,130 --> 00:37:02,240
if originality issues or example they

00:37:00,710 --> 00:37:03,350
uses in the same country from one place

00:37:02,240 --> 00:37:05,300
are different from the user from the

00:37:03,350 --> 00:37:07,970
other place I could segment those data

00:37:05,300 --> 00:37:10,460
this data all right so I have a

00:37:07,970 --> 00:37:12,980
conditional data have a data segmented

00:37:10,460 --> 00:37:15,230
for that particular interest that I have

00:37:12,980 --> 00:37:17,600
I'm gonna train the same learning

00:37:15,230 --> 00:37:20,170
relevant search flying function and I'm

00:37:17,600 --> 00:37:22,160
gonna have another function here did you

00:37:20,170 --> 00:37:25,850
this is a distinct function I could

00:37:22,160 --> 00:37:28,820
apply that for some cases I don't have

00:37:25,850 --> 00:37:32,480
enough data or my functions not strong

00:37:28,820 --> 00:37:35,660
enough this new function G what I could

00:37:32,480 --> 00:37:38,840
do is to use the mood for models so I

00:37:35,660 --> 00:37:41,420
could use a composition function between

00:37:38,840 --> 00:37:43,970
F that was my first function and

00:37:41,420 --> 00:37:46,849
gee that's more my conditional function

00:37:43,970 --> 00:37:49,309
alright and I can use a composition of

00:37:46,849 --> 00:37:51,500
both so I gotta catch get score of F and

00:37:49,309 --> 00:37:53,720
get score of G and try to compositions

00:37:51,500 --> 00:37:55,839
functions by some parameter I said learn

00:37:53,720 --> 00:37:58,450
and then I gonna have a friend of idea

00:37:55,839 --> 00:38:02,390
okay

00:37:58,450 --> 00:38:04,510
Rama wrap up the lessons that I want to

00:38:02,390 --> 00:38:07,670
send to you should tell you is that

00:38:04,510 --> 00:38:10,339
companies that have has have a

00:38:07,670 --> 00:38:12,530
significant value of search should focus

00:38:10,339 --> 00:38:14,180
more than dated research methods as a

00:38:12,530 --> 00:38:17,690
way of scaling open new markets

00:38:14,180 --> 00:38:19,880
you only can survive in some deductive

00:38:17,690 --> 00:38:21,770
innovation scenario work with

00:38:19,880 --> 00:38:23,150
state-of-the-art working new

00:38:21,770 --> 00:38:25,130
technologies that's going to allow you

00:38:23,150 --> 00:38:27,770
to grow it's going to allow you to scale

00:38:25,130 --> 00:38:30,049
and then I believe it's on my personal

00:38:27,770 --> 00:38:32,089
belief that data-driven methods are the

00:38:30,049 --> 00:38:35,059
path to that data scientist are

00:38:32,089 --> 00:38:37,520
important they provide data-driven

00:38:35,059 --> 00:38:40,099
approach to research more than that they

00:38:37,520 --> 00:38:42,260
are not just why data scientist what not

00:38:40,099 --> 00:38:44,510
macchina engineers but not research

00:38:42,260 --> 00:38:46,520
scientists because in my opinion data

00:38:44,510 --> 00:38:47,900
science are the ones who can look for

00:38:46,520 --> 00:38:51,109
your data who can clean your data

00:38:47,900 --> 00:38:53,180
because there is a lot of workload to

00:38:51,109 --> 00:38:55,549
clean your data to prepare your data to

00:38:53,180 --> 00:38:57,170
train your machine many models that I

00:38:55,549 --> 00:38:58,970
believe that's not the case true and

00:38:57,170 --> 00:39:00,530
this fully understand the machine model

00:38:58,970 --> 00:39:02,299
to develop new machinery mods because

00:39:00,530 --> 00:39:04,220
they already exist you just need to

00:39:02,299 --> 00:39:07,040
understand what there is and work with

00:39:04,220 --> 00:39:08,450
that okay and then they need to

00:39:07,040 --> 00:39:10,220
understand the results and you need to

00:39:08,450 --> 00:39:11,780
link with the business they need to

00:39:10,220 --> 00:39:15,440
understand the business requirement here

00:39:11,780 --> 00:39:18,500
I don't want to implement AFER's some

00:39:15,440 --> 00:39:20,630
complex and fancy framework I want to

00:39:18,500 --> 00:39:22,819
deliver results to the business and

00:39:20,630 --> 00:39:25,400
that's why I think data science are good

00:39:22,819 --> 00:39:28,280
on that relevance engineers there is

00:39:25,400 --> 00:39:29,960
important I don't want to send you the

00:39:28,280 --> 00:39:32,000
message that we don't don't need then we

00:39:29,960 --> 00:39:34,220
need we need but I think the relevance

00:39:32,000 --> 00:39:36,650
engineers should focus more on relevant

00:39:34,220 --> 00:39:39,049
search quality measure search quality

00:39:36,650 --> 00:39:41,780
tell us that we are doing right or wrong

00:39:39,049 --> 00:39:43,280
and of course if there is some quickly

00:39:41,780 --> 00:39:46,190
demand of the business please change

00:39:43,280 --> 00:39:48,710
that please make that search work they

00:39:46,190 --> 00:39:52,010
are there for that ok they could provide

00:39:48,710 --> 00:39:54,319
some adjustments very quickly so

00:39:52,010 --> 00:39:55,270
remember in the beginning of the talk

00:39:54,319 --> 00:39:58,280
and just to

00:39:55,270 --> 00:40:00,410
I mentioned to you that relevant search

00:39:58,280 --> 00:40:03,890
may be an art or maybe a science in my

00:40:00,410 --> 00:40:05,090
opinions both okay and a message that I

00:40:03,890 --> 00:40:07,460
want to send you is that data-driven

00:40:05,090 --> 00:40:12,440
methods are the future or relevant

00:40:07,460 --> 00:40:15,230
search and just for context this paint

00:40:12,440 --> 00:40:18,590
it's a portrait of Edmund Bellamy was

00:40:15,230 --> 00:40:20,600
generated by adversarial Network your

00:40:18,590 --> 00:40:25,060
networks it's a machine line component

00:40:20,600 --> 00:40:28,010
and it was sold in 2018 by over 400,000

00:40:25,060 --> 00:40:38,030
ok so the future is here thank you very

00:40:28,010 --> 00:40:45,440
much for attention I mean questions in

00:40:38,030 --> 00:40:47,180
the room thank you for the talk you

00:40:45,440 --> 00:40:50,030
mentioned there's two methods the

00:40:47,180 --> 00:40:53,120
traditional search and the new method or

00:40:50,030 --> 00:40:55,130
test the new search and the new search

00:40:53,120 --> 00:40:56,840
doesn't work in most of the cases or

00:40:55,130 --> 00:40:59,270
some of the cases have you thought about

00:40:56,840 --> 00:41:00,860
merging the two methods and using them

00:40:59,270 --> 00:41:02,840
together in the same system that's our

00:41:00,860 --> 00:41:04,820
next experiment yeah I know matter of

00:41:02,840 --> 00:41:06,790
fact this parameter is a model that I

00:41:04,820 --> 00:41:10,280
showed to you that's what we're gonna do

00:41:06,790 --> 00:41:11,900
let him go that so we have carry he

00:41:10,280 --> 00:41:13,940
writes here but a matter of fact I have

00:41:11,900 --> 00:41:15,740
a scoring functions off acquired given a

00:41:13,940 --> 00:41:16,970
product all right so I have a product in

00:41:15,740 --> 00:41:18,890
a query I have a scoring function I

00:41:16,970 --> 00:41:21,230
could use this modern approach so a deep

00:41:18,890 --> 00:41:24,590
neural network to provide me a score and

00:41:21,230 --> 00:41:27,710
I could learn some lambda value that

00:41:24,590 --> 00:41:30,440
could trust or not trust depending on if

00:41:27,710 --> 00:41:32,240
it's a top query if it's some query that

00:41:30,440 --> 00:41:35,150
they could not answer another way so

00:41:32,240 --> 00:41:37,070
yeah basically you could still using

00:41:35,150 --> 00:41:40,070
this approach but I'm a person I believe

00:41:37,070 --> 00:41:47,830
that is its it should be included this

00:41:40,070 --> 00:41:47,830
desert texture more questions

00:41:49,570 --> 00:41:55,730
so you have added first sanitation and

00:41:52,700 --> 00:41:57,200
afterwards expansion which about two

00:41:55,730 --> 00:41:58,910
expansions mostly string-based so said

00:41:57,200 --> 00:42:01,790
any reasoning for doing it or is that

00:41:58,910 --> 00:42:04,210
order not the other all around so your

00:42:01,790 --> 00:42:07,820
questions about the he convinced though

00:42:04,210 --> 00:42:09,590
which one sorry two more yeah this one

00:42:07,820 --> 00:42:11,060
so here you have annotated query and

00:42:09,590 --> 00:42:12,140
then afterwards to do the expansion but

00:42:11,060 --> 00:42:14,330
you could also do it the other way

00:42:12,140 --> 00:42:17,870
around because you're the annotation may

00:42:14,330 --> 00:42:20,780
heavily depend on the type of engine yes

00:42:17,870 --> 00:42:23,360
the current expansion sometimes it's mix

00:42:20,780 --> 00:42:25,640
it then it's not wrong and right with

00:42:23,360 --> 00:42:27,710
the retrieval part so if you tell me

00:42:25,640 --> 00:42:29,030
that your query expansion is when you go

00:42:27,710 --> 00:42:31,760
to retrieve the engine in retrieve

00:42:29,030 --> 00:42:33,680
results you're right but in that case

00:42:31,760 --> 00:42:36,890
please point this is a machine learning

00:42:33,680 --> 00:42:41,150
module that's gonna tell me what kind of

00:42:36,890 --> 00:42:42,920
different knowledge I'm gonna trying to

00:42:41,150 --> 00:42:45,800
find the notated query to generate

00:42:42,920 --> 00:42:47,990
multiple queries and that multiple

00:42:45,800 --> 00:42:49,340
queries are going to change they're

00:42:47,990 --> 00:42:51,530
going to be sent to the search engine

00:42:49,340 --> 00:42:54,380
this step so here I'm just going to do

00:42:51,530 --> 00:43:01,160
in query here phrasing your query query

00:42:54,380 --> 00:43:03,610
here right that's the way I see more

00:43:01,160 --> 00:43:03,610
questions

00:43:05,350 --> 00:43:09,160
[Applause]

00:43:06,670 --> 00:43:11,410
thanks for the interesting talk in the

00:43:09,160 --> 00:43:16,120
first effort to build an end-to-end

00:43:11,410 --> 00:43:19,960
model in that case was the model similar

00:43:16,120 --> 00:43:22,020
to the combination of the later existing

00:43:19,960 --> 00:43:25,330
models and in that case we're using

00:43:22,020 --> 00:43:29,790
auxilary loss functions throughout to

00:43:25,330 --> 00:43:32,680
sort of maintain a sort of sensible

00:43:29,790 --> 00:43:34,480
output of each yeah we did some

00:43:32,680 --> 00:43:36,040
experiences in triple loss function we

00:43:34,480 --> 00:43:39,070
did those some experiments using other

00:43:36,040 --> 00:43:40,780
loss functions and the problem that we

00:43:39,070 --> 00:43:42,850
found in your case were first basic

00:43:40,780 --> 00:43:45,970
scenario very specific data set is

00:43:42,850 --> 00:43:47,770
convergence so we trained a lot and the

00:43:45,970 --> 00:43:49,870
results were not converging with trying

00:43:47,770 --> 00:43:52,510
to use other losses we try to use

00:43:49,870 --> 00:43:56,860
composite losses and it's not fair as

00:43:52,510 --> 00:43:59,110
well because we are a company and we

00:43:56,860 --> 00:44:01,000
don't have unlimited time to explore the

00:43:59,110 --> 00:44:03,730
problem let's say that what I would love

00:44:01,000 --> 00:44:06,070
to have we needed sure just stop by to

00:44:03,730 --> 00:44:07,990
your forms of exploration with that

00:44:06,070 --> 00:44:10,960
initial results that we documented and

00:44:07,990 --> 00:44:13,390
then we expected in the future to have a

00:44:10,960 --> 00:44:15,820
better understand of this deep neural

00:44:13,390 --> 00:44:18,970
networks approach and to continue that

00:44:15,820 --> 00:44:20,620
project from that standpoint but yeah

00:44:18,970 --> 00:44:22,690
there was a very different ways to

00:44:20,620 --> 00:44:26,390
approach that and I could I could line

00:44:22,690 --> 00:44:28,480
going details about what we did

00:44:26,390 --> 00:44:34,940
[Applause]

00:44:28,480 --> 00:44:37,160
okay yes in your talk you didn't mention

00:44:34,940 --> 00:44:40,730
anything about like how will you

00:44:37,160 --> 00:44:43,510
evaluate the relevance like in your

00:44:40,730 --> 00:44:45,740
experience were using IR matrix like

00:44:43,510 --> 00:44:47,960
precision at rate K mean average

00:44:45,740 --> 00:44:51,470
precision but they helpful or you always

00:44:47,960 --> 00:44:54,440
measured relevance by a/b testing like

00:44:51,470 --> 00:44:56,120
there was no part about evaluation yeah

00:44:54,440 --> 00:44:57,890
you're right I should have included

00:44:56,120 --> 00:44:59,540
volition here it's a very important

00:44:57,890 --> 00:45:01,190
thing because as you're dealing with

00:44:59,540 --> 00:45:03,230
machine components you need to evaluate

00:45:01,190 --> 00:45:06,170
in order to understand how close you are

00:45:03,230 --> 00:45:08,990
of the best solution and but for

00:45:06,170 --> 00:45:11,780
evaluation just to give you some big

00:45:08,990 --> 00:45:14,120
picture we usually value a 10 any DCG

00:45:11,780 --> 00:45:16,430
and then you can do a procedural stand

00:45:14,120 --> 00:45:17,510
precision of 20 but it depends so much

00:45:16,430 --> 00:45:20,660
of your business

00:45:17,510 --> 00:45:23,780
because I could have of course I need to

00:45:20,660 --> 00:45:25,610
have a label data set it's very

00:45:23,780 --> 00:45:28,190
important but that label data set as

00:45:25,610 --> 00:45:30,380
human label it's it will not be your

00:45:28,190 --> 00:45:32,120
whole data set will be static over time

00:45:30,380 --> 00:45:33,830
so you have some difficulties of that

00:45:32,120 --> 00:45:35,810
you could do a/b experimentation we

00:45:33,830 --> 00:45:37,130
already do that if experiment it's a

00:45:35,810 --> 00:45:39,710
good source to understand where your

00:45:37,130 --> 00:45:41,510
methods are improve or not but your

00:45:39,710 --> 00:45:44,630
evaluation is important to train your

00:45:41,510 --> 00:45:46,850
methods so we use basically some

00:45:44,630 --> 00:45:50,270
stuttered data set where a human

00:45:46,850 --> 00:45:53,480
we don't use but the message that I want

00:45:50,270 --> 00:45:55,160
to send is that the way to do that is

00:45:53,480 --> 00:45:58,820
that we need to have a standard data set

00:45:55,160 --> 00:46:00,920
with a human lay human rater checking

00:45:58,820 --> 00:46:02,180
for a query a list of results which

00:46:00,920 --> 00:46:07,370
results are more relevant than others

00:46:02,180 --> 00:46:09,170
and lay being that lay beneath at okay

00:46:07,370 --> 00:46:13,010
now we can do we can discuss that

00:46:09,170 --> 00:46:14,810
offline we were five like I'll built

00:46:13,010 --> 00:46:17,360
over time and there's a coffee break now

00:46:14,810 --> 00:46:18,830
so I suggested anyone who wants to ask

00:46:17,360 --> 00:46:20,900
more questions stays in the room and the

00:46:18,830 --> 00:46:22,450
other ones go for coffee thank you very

00:46:20,900 --> 00:46:26,780
much guys Thanks

00:46:22,450 --> 00:46:26,780

YouTube URL: https://www.youtube.com/watch?v=TrG9fkl73Ss


