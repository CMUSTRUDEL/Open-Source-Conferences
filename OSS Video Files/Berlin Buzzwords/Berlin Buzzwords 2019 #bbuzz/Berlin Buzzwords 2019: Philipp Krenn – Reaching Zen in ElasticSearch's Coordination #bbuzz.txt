Title: Berlin Buzzwords 2019: Philipp Krenn – Reaching Zen in ElasticSearch's Coordination #bbuzz
Publication date: 2019-06-27
Playlist: Berlin Buzzwords 2019 #bbuzz
Description: 
	Elasticsearch's cluster coordination system, called Zen Discovery, got a rewrite in version 7.0. Starting from a formal model, the coordination layer was rebuilt to address multiple issues discovered over the years. 

This talk shows the main improvements of the new implementation: Master elections are much faster, the infamous minimum_master_nodes setting has been removed, growing and shrinking clusters becomes safer and easier, and leaves less room to misconfigure the system. Let us join the new, more Zen way of cluster coordination.

Read more:
https://2019.berlinbuzzwords.de/19/session/reaching-zen-elasticsearchs-coordination

About Philipp Krenn:
https://2019.berlinbuzzwords.de/users/philipp-krenn

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,350 --> 00:00:12,660
thank you hye-won everybody still awake

00:00:10,280 --> 00:00:14,660
more or less yeah okay

00:00:12,660 --> 00:00:17,600
let's see this is a bit of a threat

00:00:14,660 --> 00:00:19,760
topic so let's see how dry it will be so

00:00:17,600 --> 00:00:22,010
I assume that everybody has an idea what

00:00:19,760 --> 00:00:24,439
elasticsearch is right so we don't need

00:00:22,010 --> 00:00:25,820
to cover like shards and illnesses and

00:00:24,439 --> 00:00:27,830
stuff like that and you know what nodes

00:00:25,820 --> 00:00:29,900
are so we'll just build on top of that

00:00:27,830 --> 00:00:32,360
otherwise shout if anything is missing

00:00:29,900 --> 00:00:34,520
so I work for elastic the company behind

00:00:32,360 --> 00:00:36,200
the entire stack my official role is

00:00:34,520 --> 00:00:38,390
developer advocate so I mostly travel

00:00:36,200 --> 00:00:40,280
around and show what we're changing or

00:00:38,390 --> 00:00:42,020
what we're trying to build and that's

00:00:40,280 --> 00:00:42,829
pretty much my role definition so let's

00:00:42,020 --> 00:00:45,920
see what we have

00:00:42,829 --> 00:00:48,200
so what is what is it even when I say

00:00:45,920 --> 00:00:49,700
cluster coordination what what are you

00:00:48,200 --> 00:00:55,040
expecting when I say cluster

00:00:49,700 --> 00:00:58,810
coordination any expectations what might

00:00:55,040 --> 00:00:58,810
be caster coordination in elasticsearch

00:01:01,030 --> 00:01:05,540
yeah so you have different node types

00:01:03,560 --> 00:01:07,100
that you want to get to yes and the

00:01:05,540 --> 00:01:09,079
general idea is you want to have

00:01:07,100 --> 00:01:10,460
something we call the cluster state so

00:01:09,079 --> 00:01:12,500
the cluster coordination takes care of

00:01:10,460 --> 00:01:14,840
the cluster state now obviously the next

00:01:12,500 --> 00:01:16,909
question is what is the cluster state

00:01:14,840 --> 00:01:18,500
and that is exactly when you have

00:01:16,909 --> 00:01:20,420
different nodes but it's not just the

00:01:18,500 --> 00:01:23,030
different nodes it's much more than that

00:01:20,420 --> 00:01:25,429
so what you have is you have cluster

00:01:23,030 --> 00:01:27,530
wide settings you have index meta data

00:01:25,429 --> 00:01:29,240
so cluster wide settings might be like

00:01:27,530 --> 00:01:31,399
these are all the nodes that make up my

00:01:29,240 --> 00:01:33,049
cluster could be a single node could be

00:01:31,399 --> 00:01:34,340
3 nodes could be two hundred nodes

00:01:33,049 --> 00:01:36,679
whatever you have there

00:01:34,340 --> 00:01:39,020
you could have index metadata that might

00:01:36,679 --> 00:01:40,700
be for example you have one index that

00:01:39,020 --> 00:01:42,649
is the specific mapping for that those

00:01:40,700 --> 00:01:44,179
are the settings for that index and the

00:01:42,649 --> 00:01:45,709
mapping settings that you have in those

00:01:44,179 --> 00:01:47,420
you could also have additional

00:01:45,709 --> 00:01:49,999
information like for example the index

00:01:47,420 --> 00:01:52,399
is broken up into one or more shards on

00:01:49,999 --> 00:01:54,619
which nodes are these shards are the

00:01:52,399 --> 00:01:56,179
replicas of that chart in sync with the

00:01:54,619 --> 00:01:58,399
primary shard and all of that

00:01:56,179 --> 00:01:59,689
information that is the cluster state so

00:01:58,399 --> 00:02:01,789
that is basically the meta information

00:01:59,689 --> 00:02:03,950
that keeps your cluster life and keeps

00:02:01,789 --> 00:02:06,709
everything working and lots of other

00:02:03,950 --> 00:02:08,450
different pieces this is not about them

00:02:06,709 --> 00:02:11,300
it that data you keep in your cluster

00:02:08,450 --> 00:02:14,780
itself this is just the metadata to keep

00:02:11,300 --> 00:02:16,430
your cluster operational you can check

00:02:14,780 --> 00:02:19,370
what you have in there with underscore

00:02:16,430 --> 00:02:20,900
cluster state and you can only see what

00:02:19,370 --> 00:02:23,990
is kind of like the meta data you have

00:02:20,900 --> 00:02:26,660
in there important is if you lose data

00:02:23,990 --> 00:02:28,220
there in our opinion it's much worse

00:02:26,660 --> 00:02:29,960
than losing a single document we

00:02:28,220 --> 00:02:32,120
losing a single document you have one

00:02:29,960 --> 00:02:35,630
documented discontent losing an entire

00:02:32,120 --> 00:02:36,830
chart or the mapping for some index is

00:02:35,630 --> 00:02:39,470
much worse than that

00:02:36,830 --> 00:02:41,060
and that might have or might impact lots

00:02:39,470 --> 00:02:43,280
of documents and not just a single one

00:02:41,060 --> 00:02:45,830
so for us the cluster state is the thing

00:02:43,280 --> 00:02:48,530
that needs to be in a good state and

00:02:45,830 --> 00:02:50,570
only moving forward if you ever lose any

00:02:48,530 --> 00:02:52,970
cluster updates it's also very bad stay

00:02:50,570 --> 00:02:55,250
for your cluster and that is kind of the

00:02:52,970 --> 00:02:57,680
important part so we want to keep that

00:02:55,250 --> 00:03:01,100
data in a good shape and only moving

00:02:57,680 --> 00:03:02,870
forward one example here this is

00:03:01,100 --> 00:03:05,750
normally very long for example you can

00:03:02,870 --> 00:03:08,060
see I have version 29 of a cluster I've

00:03:05,750 --> 00:03:09,830
just started up with just my taco

00:03:08,060 --> 00:03:11,270
cluster which I have running locally

00:03:09,830 --> 00:03:13,040
here but that would contain a lot of

00:03:11,270 --> 00:03:14,840
other information so it would know all

00:03:13,040 --> 00:03:17,150
the indices I have in there the mappings

00:03:14,840 --> 00:03:19,220
of those indices like which version of

00:03:17,150 --> 00:03:20,750
which mapping are half and all those

00:03:19,220 --> 00:03:23,060
pieces of information that is the

00:03:20,750 --> 00:03:26,150
cluster state that I have in there now

00:03:23,060 --> 00:03:29,360
the three main components of the entire

00:03:26,150 --> 00:03:32,030
discovery well it kind of tie across the

00:03:29,360 --> 00:03:33,890
state is you have discovery which are

00:03:32,030 --> 00:03:36,260
the other nodes in my cluster what can

00:03:33,890 --> 00:03:39,620
form one cluster you have the master

00:03:36,260 --> 00:03:41,540
election like which single node is the

00:03:39,620 --> 00:03:44,390
master and keeps track of that state and

00:03:41,540 --> 00:03:47,030
that is the only one who can write to

00:03:44,390 --> 00:03:49,070
that cluster state and the publication

00:03:47,030 --> 00:03:50,870
of the cluster state in the end to

00:03:49,070 --> 00:03:52,700
actually spread out the current cluster

00:03:50,870 --> 00:03:56,209
state to all the other nodes in your

00:03:52,700 --> 00:03:59,209
cluster so we've used something called

00:03:56,209 --> 00:04:02,300
Zen for a long time if it was always so

00:03:59,209 --> 00:04:04,190
Sen we could discuss but the general

00:04:02,300 --> 00:04:06,500
idea is we have sent to do the discovery

00:04:04,190 --> 00:04:08,959
and the election and we've recently for

00:04:06,500 --> 00:04:11,900
version seven rewritten that to send to

00:04:08,959 --> 00:04:13,220
however we don't really emphasize sin as

00:04:11,900 --> 00:04:15,410
a name that much anymore

00:04:13,220 --> 00:04:17,540
because it's not pluggable as soon as

00:04:15,410 --> 00:04:20,359
you have elasticsearch you have sent to

00:04:17,540 --> 00:04:22,460
nowadays doing everything for cluster

00:04:20,359 --> 00:04:24,770
coordination for you you cannot throw in

00:04:22,460 --> 00:04:26,840
anything else that is intentional

00:04:24,770 --> 00:04:28,669
we don't plan to have any alternatives

00:04:26,840 --> 00:04:30,620
to that so you're stuck with that that's

00:04:28,669 --> 00:04:32,660
why we generally don't emphasize send

00:04:30,620 --> 00:04:34,190
that much but this is the thing or

00:04:32,660 --> 00:04:36,919
implementation that we have in there and

00:04:34,190 --> 00:04:38,450
the general idea is that Zen is pretty

00:04:36,919 --> 00:04:40,820
much like whatever is happening in your

00:04:38,450 --> 00:04:41,750
cluster your master should be pretty

00:04:40,820 --> 00:04:43,070
stay

00:04:41,750 --> 00:04:44,960
like sitting in the middle and whatever

00:04:43,070 --> 00:04:47,120
happens around it doesn't affect its

00:04:44,960 --> 00:04:49,880
state so much there is the general idea

00:04:47,120 --> 00:04:52,070
of having this sin idea maybe in the

00:04:49,880 --> 00:04:54,200
past it wasn't always that sin but the

00:04:52,070 --> 00:04:58,610
idea is to have it more sin in the

00:04:54,200 --> 00:05:00,830
future why we have this resiliency page

00:04:58,610 --> 00:05:03,500
in elasticsearch which documents all the

00:05:00,830 --> 00:05:05,300
things that could go wrong either in

00:05:03,500 --> 00:05:07,880
practice or in theory in your cluster

00:05:05,300 --> 00:05:09,440
and one very important point that we had

00:05:07,880 --> 00:05:11,210
on there that we were recently able to

00:05:09,440 --> 00:05:14,630
strike off because of this rewrite of

00:05:11,210 --> 00:05:16,370
sin was that if you have repeated the

00:05:14,630 --> 00:05:18,890
repeated is important repeated network

00:05:16,370 --> 00:05:21,770
procedure partitions you could lose

00:05:18,890 --> 00:05:23,330
cluster state updates which was a very

00:05:21,770 --> 00:05:25,070
bad day for the cluster if that happened

00:05:23,330 --> 00:05:26,750
it was kind of complicated to trigger

00:05:25,070 --> 00:05:29,780
because it had to be repeated in a

00:05:26,750 --> 00:05:30,710
specific order and timing window but it

00:05:29,780 --> 00:05:32,690
could happen

00:05:30,710 --> 00:05:35,330
and then you would lose important

00:05:32,690 --> 00:05:38,600
information and there was one part of

00:05:35,330 --> 00:05:41,030
that cluster reor the sin rewrite that

00:05:38,600 --> 00:05:43,280
we did it was also because sin initially

00:05:41,030 --> 00:05:45,380
was kind of like a bit homegrown and was

00:05:43,280 --> 00:05:48,020
just put together and then patched up

00:05:45,380 --> 00:05:50,120
over time to just work better and better

00:05:48,020 --> 00:05:51,650
and we like experimented like these are

00:05:50,120 --> 00:05:53,030
the right time outs here we know that

00:05:51,650 --> 00:05:55,820
these are the kind of right settings in

00:05:53,030 --> 00:05:58,340
combination these normally work but it

00:05:55,820 --> 00:06:01,340
wasn't really proven or as theoretically

00:05:58,340 --> 00:06:04,340
founded and grounded as you would want

00:06:01,340 --> 00:06:06,590
so the general idea was we want to redo

00:06:04,340 --> 00:06:09,170
this to fix issues like this one and

00:06:06,590 --> 00:06:11,030
basically with we started with

00:06:09,170 --> 00:06:13,250
elasticsearch foreign models which is

00:06:11,030 --> 00:06:15,760
another public repository we have and

00:06:13,250 --> 00:06:19,070
this started with theoretical

00:06:15,760 --> 00:06:23,080
specification in TLA plus and we also

00:06:19,070 --> 00:06:25,720
have model checking for that in TLC I

00:06:23,080 --> 00:06:28,340
have managed to stay away from those

00:06:25,720 --> 00:06:30,110
specifications and I don't really know

00:06:28,340 --> 00:06:31,550
what they're doing but it might look

00:06:30,110 --> 00:06:33,560
something like this and if this is you

00:06:31,550 --> 00:06:36,140
thing you might have a great day diving

00:06:33,560 --> 00:06:38,000
into those I I'm fine and believe my

00:06:36,140 --> 00:06:39,920
colleagues who work on that and that

00:06:38,000 --> 00:06:42,740
they can prove that the cluster state is

00:06:39,920 --> 00:06:44,690
going right from one good state to

00:06:42,740 --> 00:06:46,430
another good state and we don't have any

00:06:44,690 --> 00:06:48,710
anomalies like on a theoretical level

00:06:46,430 --> 00:06:51,170
and then can prove that our algorithms

00:06:48,710 --> 00:06:55,210
that we build on top of those also do

00:06:51,170 --> 00:06:57,589
the right thing so

00:06:55,210 --> 00:06:59,629
discoveries generally we had these three

00:06:57,589 --> 00:07:02,659
things and the first thing was the

00:06:59,629 --> 00:07:05,629
discovery where are my master eligible

00:07:02,659 --> 00:07:08,020
notes is there a master already this is

00:07:05,629 --> 00:07:10,729
kind of like the part of discovery

00:07:08,020 --> 00:07:12,559
basically the idea is if you have three

00:07:10,729 --> 00:07:14,089
nodes they should all come to the same

00:07:12,559 --> 00:07:16,249
conclusion what your cluster looks like

00:07:14,089 --> 00:07:17,779
because right now you can see the three

00:07:16,249 --> 00:07:19,490
nodes all have a different opinion of

00:07:17,779 --> 00:07:21,080
what the cluster might look like you

00:07:19,490 --> 00:07:23,029
have like the one in the bottom left

00:07:21,080 --> 00:07:24,529
thinks there are only two nodes the one

00:07:23,029 --> 00:07:26,149
on the bottom right thinks directionally

00:07:24,529 --> 00:07:29,539
four nodes which probably don't exist

00:07:26,149 --> 00:07:31,309
here but the idea is to have one uniform

00:07:29,539 --> 00:07:33,460
version of what the cluster looks like

00:07:31,309 --> 00:07:35,779
and what you have in your system

00:07:33,460 --> 00:07:38,210
previously you had the following

00:07:35,779 --> 00:07:40,129
settings or actually first you have the

00:07:38,210 --> 00:07:42,259
old settings and in seven we have these

00:07:40,129 --> 00:07:43,759
new settings the old ones still work

00:07:42,259 --> 00:07:45,559
they're deprecated but they will be

00:07:43,759 --> 00:07:49,159
removed in the next major version so

00:07:45,559 --> 00:07:51,559
what used to be Zen ping unicast hosts

00:07:49,159 --> 00:07:54,050
is now just called discovery seed hosts

00:07:51,559 --> 00:07:56,659
since I said sin is not pluggable we

00:07:54,050 --> 00:07:58,099
just threw it out of the API because

00:07:56,659 --> 00:08:00,649
well you cannot change it anyway you

00:07:58,099 --> 00:08:02,839
will always have sin in there anyway so

00:08:00,649 --> 00:08:05,539
by discovery seed host you basically

00:08:02,839 --> 00:08:09,169
provide the host names of all the hosts

00:08:05,539 --> 00:08:11,509
or some of the seed hosts that can start

00:08:09,169 --> 00:08:13,069
forming your cluster initially if you

00:08:11,509 --> 00:08:15,169
have a more dynamic environment like a

00:08:13,069 --> 00:08:18,110
cloud provider you could provide either

00:08:15,169 --> 00:08:19,759
a file or some specific tagging firewall

00:08:18,110 --> 00:08:21,919
group whatever in from your cloud

00:08:19,759 --> 00:08:24,080
provider that the nodes find each other

00:08:21,919 --> 00:08:25,729
and then form a cluster so you don't

00:08:24,080 --> 00:08:27,709
have to know the DNS names or IP

00:08:25,729 --> 00:08:29,269
addresses in that setting you could just

00:08:27,709 --> 00:08:31,099
provide another mean to find the right

00:08:29,269 --> 00:08:32,990
nodes or if you have a more static

00:08:31,099 --> 00:08:35,060
setting you could just provide the seed

00:08:32,990 --> 00:08:37,039
host which is like a set of starting

00:08:35,060 --> 00:08:38,990
nodes don't have to be all of them but

00:08:37,039 --> 00:08:40,579
one node needs to reach at least one of

00:08:38,990 --> 00:08:45,019
the other seat nodes and then they will

00:08:40,579 --> 00:08:46,490
form one large cluster over all the

00:08:45,019 --> 00:08:48,860
master election that happens once the

00:08:46,490 --> 00:08:50,990
nodes have found each other will then be

00:08:48,860 --> 00:08:53,300
like who should be master and then they

00:08:50,990 --> 00:08:55,010
will form a cluster and unless something

00:08:53,300 --> 00:08:57,139
goes terribly wrong they will always be

00:08:55,010 --> 00:08:59,120
exactly one last node in an

00:08:57,139 --> 00:09:00,860
elasticsearch cluster and ideally you

00:08:59,120 --> 00:09:03,560
form that pretty quickly because you

00:09:00,860 --> 00:09:06,110
cannot run any major updates while you

00:09:03,560 --> 00:09:08,690
don't have a cluster or you cannot write

00:09:06,110 --> 00:09:10,970
do any changes actually at all

00:09:08,690 --> 00:09:12,350
so the general idea is you have that

00:09:10,970 --> 00:09:17,300
leader and everybody else is following

00:09:12,350 --> 00:09:19,250
that master note to whatever next state

00:09:17,300 --> 00:09:21,650
your step you want to take that's the

00:09:19,250 --> 00:09:25,760
general idea when you have the master so

00:09:21,650 --> 00:09:27,050
what you did have is and for some the

00:09:25,760 --> 00:09:29,210
resolution here is not what it should be

00:09:27,050 --> 00:09:32,720
but it's called discovery send minimum

00:09:29,210 --> 00:09:34,850
master notes which Simon mentioned in

00:09:32,720 --> 00:09:37,130
his talk earlier is something you always

00:09:34,850 --> 00:09:38,780
use to set if you didn't set that you

00:09:37,130 --> 00:09:41,930
would have a cluster that probably would

00:09:38,780 --> 00:09:44,450
be in a very bad state the problem is it

00:09:41,930 --> 00:09:46,610
has to be set manually and the first

00:09:44,450 --> 00:09:49,850
thing is do you trust your users always

00:09:46,610 --> 00:09:52,730
to set that correctly as we have learnt

00:09:49,850 --> 00:09:54,380
you probably should not because people

00:09:52,730 --> 00:09:56,240
will often set it incorrectly or not set

00:09:54,380 --> 00:09:58,640
it at all and the other problem is that

00:09:56,240 --> 00:10:01,940
if you have changed in a number of

00:09:58,640 --> 00:10:03,650
master eligible nodes you might also run

00:10:01,940 --> 00:10:05,930
into trouble because what this might

00:10:03,650 --> 00:10:07,760
look like is let's say we have a three

00:10:05,930 --> 00:10:10,460
node cluster and you say you start those

00:10:07,760 --> 00:10:12,170
three nodes up and right now there is no

00:10:10,460 --> 00:10:14,360
cluster here just three independent

00:10:12,170 --> 00:10:16,520
nodes and let's say we didn't set

00:10:14,360 --> 00:10:18,590
minimum master nodes and then you could

00:10:16,520 --> 00:10:21,920
can see like they could form three

00:10:18,590 --> 00:10:23,570
independent clusters by the different

00:10:21,920 --> 00:10:25,160
colors like each one of them could think

00:10:23,570 --> 00:10:26,840
well I'm the only node I will start my

00:10:25,160 --> 00:10:29,420
own cluster and there is no way to

00:10:26,840 --> 00:10:31,280
reconcile that afterwards so you cannot

00:10:29,420 --> 00:10:32,780
easily merge the data together if you

00:10:31,280 --> 00:10:35,690
have independent masters and they

00:10:32,780 --> 00:10:37,520
diverge so that's not to say we want to

00:10:35,690 --> 00:10:40,430
have what you would always need to do is

00:10:37,520 --> 00:10:42,950
the majority of three is obviously two

00:10:40,430 --> 00:10:44,630
so you would need to set it to to you so

00:10:42,950 --> 00:10:47,090
you could have these two nodes could

00:10:44,630 --> 00:10:48,970
form a cluster or these two nodes and

00:10:47,090 --> 00:10:51,650
well there would be a third combination

00:10:48,970 --> 00:10:54,440
with the combination of two or all of

00:10:51,650 --> 00:10:56,960
the nodes together form one cluster so

00:10:54,440 --> 00:10:58,940
that's good that works the problem is

00:10:56,960 --> 00:11:01,490
what happens if you want to scale that

00:10:58,940 --> 00:11:03,110
cluster up so let's say we keep the

00:11:01,490 --> 00:11:05,960
minimum master nodes - but we want to

00:11:03,110 --> 00:11:07,760
add one more master eligible node what

00:11:05,960 --> 00:11:09,290
could then happen is that suddenly you

00:11:07,760 --> 00:11:11,630
add another node and then you have two

00:11:09,290 --> 00:11:13,790
clusters again because you satisfy that

00:11:11,630 --> 00:11:16,160
condition their minimum master nodes you

00:11:13,790 --> 00:11:17,570
have two here you have two there but you

00:11:16,160 --> 00:11:20,480
have two independent clusters in the end

00:11:17,570 --> 00:11:21,740
so this is not very healthy the other

00:11:20,480 --> 00:11:23,840
thing is if you want to scale

00:11:21,740 --> 00:11:26,210
and you have a single node and you said

00:11:23,840 --> 00:11:27,770
minimum masternodes to two well you

00:11:26,210 --> 00:11:30,590
couldn't elect the master so your caster

00:11:27,770 --> 00:11:32,600
wouldn't do anything so these situations

00:11:30,590 --> 00:11:34,460
were kind of tricky to always like scale

00:11:32,600 --> 00:11:36,950
them the master eligible nodes and that

00:11:34,460 --> 00:11:38,630
set incorrectly on all the nodes that

00:11:36,950 --> 00:11:40,730
proved to be tricky and people would

00:11:38,630 --> 00:11:42,590
just set it incorrectly and that was the

00:11:40,730 --> 00:11:46,160
number one source for issues and data

00:11:42,590 --> 00:11:48,470
loss in elasticsearch in general so the

00:11:46,160 --> 00:11:50,210
idea is probably to automate that and

00:11:48,470 --> 00:11:52,490
make that setting go away so people

00:11:50,210 --> 00:11:55,240
don't have to set it or have the pain

00:11:52,490 --> 00:11:58,990
the possibility to set it incorrectly so

00:11:55,240 --> 00:12:01,820
what we have now is initial master nodes

00:11:58,990 --> 00:12:04,910
which is basically the list for the very

00:12:01,820 --> 00:12:06,650
first election so the bootstrap process

00:12:04,910 --> 00:12:08,840
when the cluster comes up the very first

00:12:06,650 --> 00:12:11,930
time that setting is being used and

00:12:08,840 --> 00:12:13,280
after that only the cluster itself will

00:12:11,930 --> 00:12:15,170
keep track of what are the master

00:12:13,280 --> 00:12:17,840
eligible nodes and it will automatically

00:12:15,170 --> 00:12:20,270
set the number of minimum master nodes

00:12:17,840 --> 00:12:22,490
basically internally you cannot set that

00:12:20,270 --> 00:12:24,350
explicitly anymore and you don't have to

00:12:22,490 --> 00:12:26,540
so this is only for the very first

00:12:24,350 --> 00:12:28,640
bootstrapping approach even when you do

00:12:26,540 --> 00:12:30,800
a full cluster restart and you have an

00:12:28,640 --> 00:12:32,630
existing data directory we will keep

00:12:30,800 --> 00:12:34,550
that information there so this is really

00:12:32,630 --> 00:12:37,940
just when forming the cluster for the

00:12:34,550 --> 00:12:42,110
very first time then this initial master

00:12:37,940 --> 00:12:44,690
nodes a list will be used it is okay to

00:12:42,110 --> 00:12:46,280
set this on multiple nodes as long as

00:12:44,690 --> 00:12:48,490
they are all consistent what you

00:12:46,280 --> 00:12:51,170
shouldn't do is you shouldn't set like

00:12:48,490 --> 00:12:53,240
one node as the minimum initial master

00:12:51,170 --> 00:12:55,280
nodes on one node and three on another

00:12:53,240 --> 00:12:58,130
like the list of those hosts because

00:12:55,280 --> 00:13:00,290
that would not be easy to like find a

00:12:58,130 --> 00:13:01,940
conclusion to that if you set it on more

00:13:00,290 --> 00:13:06,830
than one node it needs to be in a

00:13:01,940 --> 00:13:08,780
consistent state once a cluster or a

00:13:06,830 --> 00:13:10,730
node joins a cluster even if it's just

00:13:08,780 --> 00:13:12,350
being restarted that setting will be

00:13:10,730 --> 00:13:15,890
ignored so it's just for the very first

00:13:12,350 --> 00:13:18,290
time you start it up you don't have to

00:13:15,890 --> 00:13:20,330
set that when a node joins an existing

00:13:18,290 --> 00:13:22,300
cluster it would just be ignored so you

00:13:20,330 --> 00:13:25,070
don't have to set it afterwards anymore

00:13:22,300 --> 00:13:28,070
when you upgrade from version six to

00:13:25,070 --> 00:13:30,020
seven and you do a full cluster restart

00:13:28,070 --> 00:13:32,150
then you have to set that if you do a

00:13:30,020 --> 00:13:33,650
rolling upgrade you don't have to set

00:13:32,150 --> 00:13:36,050
that because you still have the minimum

00:13:33,650 --> 00:13:38,420
master nodes from before you're just joy

00:13:36,050 --> 00:13:40,220
and then the new nodes in seven would

00:13:38,420 --> 00:13:42,740
figure out like okay these were the

00:13:40,220 --> 00:13:44,810
right settings in the past and I know

00:13:42,740 --> 00:13:46,520
how the cluster should look like so I

00:13:44,810 --> 00:13:48,650
know what the minimum masternodes

00:13:46,520 --> 00:13:50,300
basically are there is no need to set

00:13:48,650 --> 00:13:54,650
that explicitly anymore because the

00:13:50,300 --> 00:13:56,810
cluster will know on its own if you

00:13:54,650 --> 00:13:58,910
start a cluster fresh and you did not

00:13:56,810 --> 00:14:01,220
set cluster initial master nodes and you

00:13:58,910 --> 00:14:04,310
have three nodes what you will get is

00:14:01,220 --> 00:14:06,470
you will get an error or actually it

00:14:04,310 --> 00:14:09,050
will get a one message the cluster would

00:14:06,470 --> 00:14:11,300
not form but it would continuously lock

00:14:09,050 --> 00:14:13,760
that message and it is actually helpful

00:14:11,300 --> 00:14:15,170
with that new message because that

00:14:13,760 --> 00:14:17,480
contains quite a bit of debugging

00:14:15,170 --> 00:14:19,760
information so this is the first page of

00:14:17,480 --> 00:14:21,770
three so you can see here I'm logging

00:14:19,760 --> 00:14:24,110
that I have a three node elasticsearch

00:14:21,770 --> 00:14:26,420
cluster which my clusters called docker

00:14:24,110 --> 00:14:28,910
cluster and I'm on the elasticsearch two

00:14:26,420 --> 00:14:31,040
node here and this one give me will give

00:14:28,910 --> 00:14:34,730
me continuously messages telling me what

00:14:31,040 --> 00:14:38,450
is wrong and you can see here master not

00:14:34,730 --> 00:14:40,220
discovered yet and this node has not

00:14:38,450 --> 00:14:42,590
previously joined the bootstrap cluster

00:14:40,220 --> 00:14:44,780
and it will basically say like hey I'm

00:14:42,590 --> 00:14:46,850
master eligible and I have found these

00:14:44,780 --> 00:14:49,460
other two nodes so it has found and

00:14:46,850 --> 00:14:51,860
elasticsearch one and elasticsearch

00:14:49,460 --> 00:14:53,960
three node though three together

00:14:51,860 --> 00:14:56,720
well they had learned half the initial

00:14:53,960 --> 00:14:58,580
master node set but they've found each

00:14:56,720 --> 00:15:00,200
other but they cannot form a cluster

00:14:58,580 --> 00:15:02,450
because they don't know maybe there

00:15:00,200 --> 00:15:03,650
should be three more or maybe there

00:15:02,450 --> 00:15:05,020
should be two more they don't really

00:15:03,650 --> 00:15:07,040
know how much there should be in total

00:15:05,020 --> 00:15:08,750
because you haven't applied that right

00:15:07,040 --> 00:15:11,750
setting for the very first time you

00:15:08,750 --> 00:15:13,730
start them up and then you would also

00:15:11,750 --> 00:15:15,680
get some more information that it will

00:15:13,730 --> 00:15:17,870
tell you it will try to continue

00:15:15,680 --> 00:15:19,520
discovering like the current node is the

00:15:17,870 --> 00:15:22,040
elastic search - that is running this

00:15:19,520 --> 00:15:24,560
here it will also tell you this was the

00:15:22,040 --> 00:15:26,300
last cluster state that I knew since

00:15:24,560 --> 00:15:28,910
this is just right from the start up

00:15:26,300 --> 00:15:31,310
none of these values have any have been

00:15:28,910 --> 00:15:35,900
ever set so the cluster has never formed

00:15:31,310 --> 00:15:37,910
and just didn't form correctly if you

00:15:35,900 --> 00:15:40,790
want to scale a cluster dynamically once

00:15:37,910 --> 00:15:42,530
it has formed correctly if you add any

00:15:40,790 --> 00:15:44,240
nodes that are not master eligible

00:15:42,530 --> 00:15:46,310
nothing changes everything is like

00:15:44,240 --> 00:15:48,620
before if you add and must master

00:15:46,310 --> 00:15:49,520
eligible node just do it because the

00:15:48,620 --> 00:15:51,920
cluster will then

00:15:49,520 --> 00:15:53,630
Oh ders another must eligible note do I

00:15:51,920 --> 00:15:55,610
need to change how many nodes I need to

00:15:53,630 --> 00:15:58,190
have to actually have the mass selection

00:15:55,610 --> 00:15:59,899
and have the majority and the Casa we'll

00:15:58,190 --> 00:16:02,630
figure that out automatically you can

00:15:59,899 --> 00:16:05,570
also remove mass eligible nodes the only

00:16:02,630 --> 00:16:07,459
thing you cannot do is do not remove

00:16:05,570 --> 00:16:10,970
more than half of the master eligible

00:16:07,459 --> 00:16:12,890
nodes at once otherwise the cluster will

00:16:10,970 --> 00:16:14,630
not be happy because suddenly it lost

00:16:12,890 --> 00:16:17,620
the majority and it would not form know

00:16:14,630 --> 00:16:19,730
how to form a cluster anymore

00:16:17,620 --> 00:16:21,380
the cluster State publication is

00:16:19,730 --> 00:16:22,820
basically the last step once you have

00:16:21,380 --> 00:16:24,649
formed the cluster there's pretty much

00:16:22,820 --> 00:16:26,930
like the master node does the right

00:16:24,649 --> 00:16:28,910
operation it tries to apply it to the

00:16:26,930 --> 00:16:31,010
majority of the master eligible nodes

00:16:28,910 --> 00:16:33,680
only then it can be sure that the

00:16:31,010 --> 00:16:35,690
majority has it and if even if the

00:16:33,680 --> 00:16:37,370
master dies like another node will have

00:16:35,690 --> 00:16:39,440
that state and then it will actually

00:16:37,370 --> 00:16:41,870
broadcast the updates which looks pretty

00:16:39,440 --> 00:16:44,630
much like this so you have this is our

00:16:41,870 --> 00:16:46,070
master eligible node this line here you

00:16:44,630 --> 00:16:48,050
get a change for example you add an

00:16:46,070 --> 00:16:51,200
index or you add a node and then you

00:16:48,050 --> 00:16:53,029
basically try to publish that event to

00:16:51,200 --> 00:16:54,680
the majority of the nodes so for example

00:16:53,029 --> 00:16:56,930
the master has it and one of the other

00:16:54,680 --> 00:16:59,270
nodes has it so then we have two of the

00:16:56,930 --> 00:17:01,310
three nodes half that state then you

00:16:59,270 --> 00:17:03,290
have published it successfully and then

00:17:01,310 --> 00:17:05,000
you can commit it so then the master

00:17:03,290 --> 00:17:07,100
commits it to both of the other nodes

00:17:05,000 --> 00:17:09,500
and then they apply it and that's how

00:17:07,100 --> 00:17:11,420
you publish the cluster state or an

00:17:09,500 --> 00:17:13,220
update to the cluster state only the

00:17:11,420 --> 00:17:15,650
master node can actually change the

00:17:13,220 --> 00:17:18,079
cluster state and will first apply it to

00:17:15,650 --> 00:17:19,520
get to the majority of nodes and then

00:17:18,079 --> 00:17:21,800
once it has the majority it will

00:17:19,520 --> 00:17:24,290
actually commit that change and that is

00:17:21,800 --> 00:17:25,490
how the publication works and generally

00:17:24,290 --> 00:17:27,530
the cluster looks something like this

00:17:25,490 --> 00:17:29,630
you have the master and it will just

00:17:27,530 --> 00:17:31,220
have a peer to peer connection to all

00:17:29,630 --> 00:17:33,920
the other nodes and broadcast to them

00:17:31,220 --> 00:17:36,950
what is happening in the cluster to wrap

00:17:33,920 --> 00:17:38,660
up normally I would try or give you a

00:17:36,950 --> 00:17:40,160
demo with a rolling upgrade and failure

00:17:38,660 --> 00:17:43,220
states and everything but 20 minutes is

00:17:40,160 --> 00:17:45,050
not quite enough to do that I will

00:17:43,220 --> 00:17:46,970
publish the slides afterwards basically

00:17:45,050 --> 00:17:48,290
what you have here is I have my three

00:17:46,970 --> 00:17:51,110
talker containers in a rolling update

00:17:48,290 --> 00:17:53,480
scenario these two here the same send

00:17:51,110 --> 00:17:55,970
ping unicast these were the old settings

00:17:53,480 --> 00:17:57,980
these two here these you can remove and

00:17:55,970 --> 00:17:59,809
these are the new settings and you can

00:17:57,980 --> 00:18:01,550
see the seat host is kind of like a

00:17:59,809 --> 00:18:03,200
direct representation from this one and

00:18:01,550 --> 00:18:05,120
instead of saying minimum

00:18:03,200 --> 00:18:07,580
so notice - you basically provide the

00:18:05,120 --> 00:18:09,860
list of these are the three nodes that

00:18:07,580 --> 00:18:14,440
are master eligible and they form the

00:18:09,860 --> 00:18:18,500
master eligible status in the end okay

00:18:14,440 --> 00:18:20,539
then - then - generally faster the

00:18:18,500 --> 00:18:22,190
elections will be much faster it's safer

00:18:20,539 --> 00:18:24,529
and it should also be more debuggable

00:18:22,190 --> 00:18:27,019
because the debugging output is better

00:18:24,529 --> 00:18:29,510
otherwise you should not really notice

00:18:27,019 --> 00:18:31,340
and except for some bad configurations

00:18:29,510 --> 00:18:34,519
we haven't really seen much trouble in

00:18:31,340 --> 00:18:36,409
the discussed forums by the way if you

00:18:34,519 --> 00:18:38,570
don't have enough of elasticsearch yet

00:18:36,409 --> 00:18:40,419
today we'll have a meet-up tonight so if

00:18:38,570 --> 00:18:43,399
you want drinks and more discussions

00:18:40,419 --> 00:18:44,750
come to commune commander at 7:00 p.m.

00:18:43,399 --> 00:18:47,630
where we'll have the meet up and have

00:18:44,750 --> 00:18:51,470
some Modi's elasticsearch talks that's

00:18:47,630 --> 00:18:58,880
it do we have time for questions yes

00:18:51,470 --> 00:19:02,269
like two minutes okay any questions how

00:18:58,880 --> 00:19:06,080
do you discriminate between a dying note

00:19:02,269 --> 00:19:10,639
and a note that you just remove so

00:19:06,080 --> 00:19:12,470
suppose that I remove a master note well

00:19:10,639 --> 00:19:16,809
so what we have is we have these health

00:19:12,470 --> 00:19:19,669
checks which are basically pings which

00:19:16,809 --> 00:19:21,500
every X seconds I forgot which how many

00:19:19,669 --> 00:19:23,360
seconds five or something like that we

00:19:21,500 --> 00:19:25,850
ping a note and once it's not reachable

00:19:23,360 --> 00:19:27,169
like I think if we pay fail three pings

00:19:25,850 --> 00:19:28,940
or something like that don't

00:19:27,169 --> 00:19:30,289
maybe those numbers are wrong but it's

00:19:28,940 --> 00:19:32,210
something like that then we'll just

00:19:30,289 --> 00:19:33,950
assume the note is that we cannot

00:19:32,210 --> 00:19:36,350
determine if it has really been removed

00:19:33,950 --> 00:19:37,880
or if it's just like stuck in a long

00:19:36,350 --> 00:19:39,799
garbage collection for example or if the

00:19:37,880 --> 00:19:41,960
network is down but then it will just be

00:19:39,799 --> 00:19:43,789
removed from the cluster and later on if

00:19:41,960 --> 00:19:45,380
it comes back it can rejoin the cluster

00:19:43,789 --> 00:19:46,820
but we don't really make that

00:19:45,380 --> 00:19:49,850
differentiation if it has been

00:19:46,820 --> 00:19:52,340
explicitly removed or not what you could

00:19:49,850 --> 00:19:54,470
do is if you know you want to rotate out

00:19:52,340 --> 00:19:56,659
the node you could for example vacate

00:19:54,470 --> 00:19:58,070
the location and move all the data that

00:19:56,659 --> 00:20:00,380
you have on that note if it's a data

00:19:58,070 --> 00:20:01,610
node and two other nodes and then remove

00:20:00,380 --> 00:20:05,440
it more gracefully that you don't really

00:20:01,610 --> 00:20:05,440
have like data being impacted by that

00:20:07,300 --> 00:20:14,890
but are basically mentis when you remove

00:20:10,450 --> 00:20:18,580
from after note the cluster rebalances

00:20:14,890 --> 00:20:20,980
Jung internally does it state state

00:20:18,580 --> 00:20:22,420
processing if it's the actual master

00:20:20,980 --> 00:20:24,550
that you removed then the other notes

00:20:22,420 --> 00:20:26,470
keep pinging that one as well and then

00:20:24,550 --> 00:20:28,420
we'll figure out okay the master is not

00:20:26,470 --> 00:20:31,030
reachable anymore and then they will

00:20:28,420 --> 00:20:32,620
check like hey do we have enough master

00:20:31,030 --> 00:20:34,360
eligible nodes to actually form a new

00:20:32,620 --> 00:20:36,190
cluster and then they will hold an

00:20:34,360 --> 00:20:37,690
election and for minima or an and elect

00:20:36,190 --> 00:20:40,030
a new master and that is now much faster

00:20:37,690 --> 00:20:41,560
because we were able previously we had

00:20:40,030 --> 00:20:43,990
like some tweaks around the time outs

00:20:41,560 --> 00:20:45,430
with the new protocol that is much

00:20:43,990 --> 00:20:47,080
quicker than we figure out all the

00:20:45,430 --> 00:20:50,200
master is not there and we don't have to

00:20:47,080 --> 00:20:52,930
wait until everybody has made it so this

00:20:50,200 --> 00:20:55,630
is much quicker but generally everybody

00:20:52,930 --> 00:20:57,010
is pinging everybody else and when when

00:20:55,630 --> 00:20:59,200
the node is not reachable it will just

00:20:57,010 --> 00:21:00,850
be removed and if it was the master node

00:20:59,200 --> 00:21:03,160
we will hold an election and actually

00:21:00,850 --> 00:21:06,580
elect another master if you have enough

00:21:03,160 --> 00:21:08,170
master eligible nodes left because if

00:21:06,580 --> 00:21:10,300
you have for example three mass eligible

00:21:08,170 --> 00:21:12,460
nodes and to disappear the remaining one

00:21:10,300 --> 00:21:13,990
cannot vote because it might just be a

00:21:12,460 --> 00:21:16,660
network petition and the other two might

00:21:13,990 --> 00:21:18,700
be somewhere else so you need to have

00:21:16,660 --> 00:21:20,410
the majority still to be able to do that

00:21:18,700 --> 00:21:22,660
that's why you cannot remove the

00:21:20,410 --> 00:21:24,670
majority of mast eligible nodes at once

00:21:22,660 --> 00:21:27,210
because otherwise the Kaster would just

00:21:24,670 --> 00:21:32,530
not be able to elect the new master

00:21:27,210 --> 00:21:34,870
makes sense yes come to me later

00:21:32,530 --> 00:21:36,820
since we're completely out of time we'll

00:21:34,870 --> 00:21:40,860
take one more question sure

00:21:36,820 --> 00:21:43,900
hi hi you mentioned debug ability and

00:21:40,860 --> 00:21:48,400
I'm also got a question regarding the

00:21:43,900 --> 00:21:49,720
Zen pings is there any way that because

00:21:48,400 --> 00:21:53,530
the elasticsearch risk is quite

00:21:49,720 --> 00:21:56,200
sensitive to network issues to

00:21:53,530 --> 00:21:59,950
introspect the latency of the pings or

00:21:56,200 --> 00:22:05,680
if there's like a ongoing issue is the

00:21:59,950 --> 00:22:08,320
way to like introspect this so I think

00:22:05,680 --> 00:22:10,480
generally the the error messages that

00:22:08,320 --> 00:22:11,530
you run into have changed quite a bit

00:22:10,480 --> 00:22:13,480
and should give you much more

00:22:11,530 --> 00:22:16,030
information than before I haven't

00:22:13,480 --> 00:22:18,670
recently tried out like how the time-out

00:22:16,030 --> 00:22:20,530
message looks like but I think normally

00:22:18,670 --> 00:22:21,130
it's very verbose and will tell you like

00:22:20,530 --> 00:22:23,140
hey

00:22:21,130 --> 00:22:25,090
was not reachable and this is how many

00:22:23,140 --> 00:22:26,980
times it failed and this is the time it

00:22:25,090 --> 00:22:31,090
took so that should generally be more

00:22:26,980 --> 00:22:32,650
debuggable than before yeah so that the

00:22:31,090 --> 00:22:35,919
idea was also to make the entire thing

00:22:32,650 --> 00:22:37,390
more debuggable than before because

00:22:35,919 --> 00:22:39,400
sometimes it was a bit hard to see and

00:22:37,390 --> 00:22:42,039
as long as people provide like the full

00:22:39,400 --> 00:22:44,289
stack traces or the full error messages

00:22:42,039 --> 00:22:46,750
we were in a discuss forums pretty quick

00:22:44,289 --> 00:22:48,010
to actually debug what was going on the

00:22:46,750 --> 00:22:49,419
main problem is if we don't have like

00:22:48,010 --> 00:22:50,559
all the outputs then it's sometimes a

00:22:49,419 --> 00:22:53,289
bit hard to know what is really

00:22:50,559 --> 00:22:55,870
happening but given the full of outputs

00:22:53,289 --> 00:22:56,909
recently from what I've seen debugging

00:22:55,870 --> 00:22:59,750
improved quite a bit

00:22:56,909 --> 00:23:04,259
cool thanks a lot

00:22:59,750 --> 00:23:04,259

YouTube URL: https://www.youtube.com/watch?v=Ns1Erg4I92U


