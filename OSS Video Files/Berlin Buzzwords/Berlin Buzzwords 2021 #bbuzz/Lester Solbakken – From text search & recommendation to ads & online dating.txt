Title: Lester Solbakken – From text search & recommendation to ads & online dating
Publication date: 2021-06-29
Playlist: Berlin Buzzwords 2021 #bbuzz
Description: 
	Full title: From text search and recommendation to ads and online dating; approximate nearest neighbors in real world applications

Anything can be represented by a vector. Text can be represented by vectors describing the text's meaning. Images can be represented by the objects it contains. Users of a system can be represented by their interests and preferences. Even time-based entities such as video, sound, or user interactions can be represented by vectors. Finding the most similar vectors has all kinds of useful applications. 

There are many libraries to choose from for similarity search. However, in real-world applications, there are additional complications that need to be addressed. For instance, similarity search needs to scale up while ensuring that data indexed in the system is searchable immediately without any time-consuming index building in the background. Most importantly, however, additional search filters are often combined with the similarity search. This can severely limit the end result's quality, as post-filtering can prevent otherwise relevant results from surfacing. 

In this talk, we'll explore some real cases where combining approximate nearest neighbors (ANN) search with filtering causes problems. The solution is to integrate the ANN search with filtering, however, most libraries for nearest-neighbor search work in isolation and do not support this. To our knowledge, the only open-source platform that does is Vespa.ai, and we'll delve into how Vespa.ai solves this problem.

Speaker: 
Lester Solbakken – https://2021.berlinbuzzwords.de/member/lester-solbakken

More: https://2021.berlinbuzzwords.de/session/text-search-and-recommendation-ads-and-online-dating-approximate-nearest-neighbors-real
Captions: 
	00:00:07,440 --> 00:00:10,880
all right

00:00:08,160 --> 00:00:13,040
uh thanks for that thanks for tuning in

00:00:10,880 --> 00:00:15,920
so as sergey mentioned my name is uh

00:00:13,040 --> 00:00:16,480
is lester uh i work at verizon media

00:00:15,920 --> 00:00:19,199
group

00:00:16,480 --> 00:00:20,640
previously uh yahoo and as as sergey

00:00:19,199 --> 00:00:21,760
also mentioned we're soon to be called

00:00:20,640 --> 00:00:25,359
yahoo

00:00:21,760 --> 00:00:27,279
yet again um i primarily work on

00:00:25,359 --> 00:00:28,880
machine learning solutions and today

00:00:27,279 --> 00:00:32,079
i'll be talking about

00:00:28,880 --> 00:00:32,640
nearest neighbor search um specifically

00:00:32,079 --> 00:00:34,320
some

00:00:32,640 --> 00:00:36,800
practical issues to think about when

00:00:34,320 --> 00:00:38,879
using a ns in search applications

00:00:36,800 --> 00:00:40,399
uh because there's been a lot of buzz

00:00:38,879 --> 00:00:42,000
around the nearest neighbors in recent

00:00:40,399 --> 00:00:44,719
years we've seen a lot of libraries and

00:00:42,000 --> 00:00:46,320
platforms appear um

00:00:44,719 --> 00:00:48,000
but not too much talk about some of the

00:00:46,320 --> 00:00:50,239
more you know practical problems that

00:00:48,000 --> 00:00:52,079
need to be solved and i'll try to

00:00:50,239 --> 00:00:54,160
exemplify them using some some real

00:00:52,079 --> 00:00:56,399
applications

00:00:54,160 --> 00:00:58,640
uh so as as you mentioned at verizon i

00:00:56,399 --> 00:01:01,280
work on on the vespa platform

00:00:58,640 --> 00:01:01,680
and if you're not familiar with it vespa

00:01:01,280 --> 00:01:05,199
is

00:01:01,680 --> 00:01:07,950
the open source platform for low latency

00:01:05,199 --> 00:01:09,360
computations over large evolving data

00:01:07,950 --> 00:01:10,799
[Music]

00:01:09,360 --> 00:01:13,040
it's a platform we've been developing

00:01:10,799 --> 00:01:13,439
over many years has roots spanning back

00:01:13,040 --> 00:01:15,200
to

00:01:13,439 --> 00:01:17,439
you know research and wars of the late

00:01:15,200 --> 00:01:19,119
1990s

00:01:17,439 --> 00:01:20,479
but we opened sources a few years back

00:01:19,119 --> 00:01:22,720
so while it may seem

00:01:20,479 --> 00:01:24,400
new to many people it's been battle

00:01:22,720 --> 00:01:26,080
tested over many years

00:01:24,400 --> 00:01:28,159
and today serves hundreds of thousands

00:01:26,080 --> 00:01:30,880
of queries per second uh at any

00:01:28,159 --> 00:01:31,680
given time all over the world uh serving

00:01:30,880 --> 00:01:33,360
hundreds of

00:01:31,680 --> 00:01:35,520
applications hundreds of millions of

00:01:33,360 --> 00:01:38,720
users each month and so on

00:01:35,520 --> 00:01:41,920
um there's a debate i think on thursday

00:01:38,720 --> 00:01:44,000
uh which compares vespa to elasticsearch

00:01:41,920 --> 00:01:45,360
and lucien which will surely be great

00:01:44,000 --> 00:01:47,520
to check that one out if you're

00:01:45,360 --> 00:01:51,040
interested in invespa

00:01:47,520 --> 00:01:53,759
um so vesp is fairly feature-rich for

00:01:51,040 --> 00:01:55,280
many types of applications

00:01:53,759 --> 00:01:56,960
and its features all included and

00:01:55,280 --> 00:02:00,079
tightly integrated with each other

00:01:56,960 --> 00:02:02,000
each other uh such as you know advanced

00:02:00,079 --> 00:02:03,600
relevant scoring with tensors machine

00:02:02,000 --> 00:02:05,360
learning models

00:02:03,600 --> 00:02:07,119
one of the really cool features of usb

00:02:05,360 --> 00:02:08,800
is ability to you know string together

00:02:07,119 --> 00:02:11,039
or pipeline various machine learning

00:02:08,800 --> 00:02:13,599
models from various platforms

00:02:11,039 --> 00:02:15,360
uh together across different phases to

00:02:13,599 --> 00:02:16,319
calculate relevant scores and so on for

00:02:15,360 --> 00:02:18,400
queries but

00:02:16,319 --> 00:02:20,080
but that's another talk for this talk

00:02:18,400 --> 00:02:24,480
we'll be looking at

00:02:20,080 --> 00:02:26,319
nearest neighbors um

00:02:24,480 --> 00:02:28,480
so with nearest neighbors uh we need to

00:02:26,319 --> 00:02:31,200
start with uh representations

00:02:28,480 --> 00:02:33,519
um so pretty much anything can be you

00:02:31,200 --> 00:02:35,920
know represented by a list of numbers

00:02:33,519 --> 00:02:37,440
uh or more formally a point or vector in

00:02:35,920 --> 00:02:41,040
high dimension space

00:02:37,440 --> 00:02:41,920
you know text images um this is an image

00:02:41,040 --> 00:02:44,239
of my dog

00:02:41,920 --> 00:02:46,000
he's not really sure what's going on uh

00:02:44,239 --> 00:02:49,280
he doesn't like his nearest neighbors

00:02:46,000 --> 00:02:51,519
they're mostly cats but

00:02:49,280 --> 00:02:53,440
even you know things like based on time

00:02:51,519 --> 00:02:55,519
such as sound or video or even user

00:02:53,440 --> 00:02:58,800
interactions that can be represented by

00:02:55,519 --> 00:03:00,879
you know such representations

00:02:58,800 --> 00:03:03,360
so i'm not really going to talk about

00:03:00,879 --> 00:03:05,040
how we generate these representations

00:03:03,360 --> 00:03:07,760
representation learning is a talk of its

00:03:05,040 --> 00:03:08,800
own but it's had great progress recently

00:03:07,760 --> 00:03:10,959
with deep learning

00:03:08,800 --> 00:03:12,480
um there's however one thing i'd like to

00:03:10,959 --> 00:03:14,879
say and that

00:03:12,480 --> 00:03:16,480
we've seen great results when using

00:03:14,879 --> 00:03:19,280
representations that are you know

00:03:16,480 --> 00:03:21,599
trained or adapted specifically for

00:03:19,280 --> 00:03:23,680
for the use case but these

00:03:21,599 --> 00:03:25,440
representations don't necessarily work

00:03:23,680 --> 00:03:27,680
all that well when transferred out of

00:03:25,440 --> 00:03:28,480
the domain so for instance for text

00:03:27,680 --> 00:03:30,080
we've really seen

00:03:28,480 --> 00:03:31,920
we haven't seen great results when using

00:03:30,080 --> 00:03:33,440
things like you know universal sentence

00:03:31,920 --> 00:03:35,120
encoders in relation to

00:03:33,440 --> 00:03:37,599
you know more classical approaches such

00:03:35,120 --> 00:03:37,920
as bm25 for certain cases so but again

00:03:37,599 --> 00:03:40,000
i'm

00:03:37,920 --> 00:03:42,640
digressing that's that's another talk

00:03:40,000 --> 00:03:44,720
but anyway these representations that we

00:03:42,640 --> 00:03:46,000
generate in some way they map objects

00:03:44,720 --> 00:03:49,840
into some high

00:03:46,000 --> 00:03:51,920
high dimensional space um

00:03:49,840 --> 00:03:53,360
this allows us to you know find or

00:03:51,920 --> 00:03:55,599
search for nearest neighbors for

00:03:53,360 --> 00:03:57,760
instance to some some query points

00:03:55,599 --> 00:03:59,680
um the nearest neighbors are measured by

00:03:57,760 --> 00:04:01,599
some you know distance functions such as

00:03:59,680 --> 00:04:02,879
you know geometric distance or or

00:04:01,599 --> 00:04:06,000
euclidean

00:04:02,879 --> 00:04:06,560
uh distance uh we have cosine angles

00:04:06,000 --> 00:04:09,439
which

00:04:06,560 --> 00:04:11,680
work well for sparse representations of

00:04:09,439 --> 00:04:14,000
particular texts

00:04:11,680 --> 00:04:16,320
manhattan distance having distance from

00:04:14,000 --> 00:04:19,199
working bit vectors and so on

00:04:16,320 --> 00:04:20,720
um to actually you know find the nearest

00:04:19,199 --> 00:04:22,160
neighbors what we can do is just scan

00:04:20,720 --> 00:04:24,160
through all points

00:04:22,160 --> 00:04:25,759
in a kind of brute force uh manner and

00:04:24,160 --> 00:04:27,280
determine the closest ones

00:04:25,759 --> 00:04:29,520
according to some some this distance

00:04:27,280 --> 00:04:31,440
measure um

00:04:29,520 --> 00:04:32,880
of course you know this brute force

00:04:31,440 --> 00:04:34,320
doesn't really scale that well so we

00:04:32,880 --> 00:04:34,880
need some sort of index structure to

00:04:34,320 --> 00:04:38,639
help us

00:04:34,880 --> 00:04:39,919
you know navigate this space um

00:04:38,639 --> 00:04:41,919
unfortunately there aren't really any

00:04:39,919 --> 00:04:43,199
known methods of doing this exactly so

00:04:41,919 --> 00:04:45,680
we need to resort to

00:04:43,199 --> 00:04:47,840
approximate solutions which hopefully

00:04:45,680 --> 00:04:50,080
gives us good enough results

00:04:47,840 --> 00:04:51,919
there are a few different methods for

00:04:50,080 --> 00:04:53,600
this and i basically divide them into

00:04:51,919 --> 00:04:55,840
whether or not they can be

00:04:53,600 --> 00:04:57,440
represented with traditional inverse

00:04:55,840 --> 00:04:59,680
indexes

00:04:57,440 --> 00:05:03,360
those are can such as k-means or product

00:04:59,680 --> 00:05:03,360
quantization and its relatives

00:05:03,840 --> 00:05:08,080
locality sensitive hashing basically

00:05:06,080 --> 00:05:09,680
create groups of centroids or buckets

00:05:08,080 --> 00:05:11,280
for similar items and you can kind of

00:05:09,680 --> 00:05:13,680
find the most similar bucket or

00:05:11,280 --> 00:05:15,120
centroid to the query and prune away a

00:05:13,680 --> 00:05:16,080
lot of the search space you know that

00:05:15,120 --> 00:05:17,840
way

00:05:16,080 --> 00:05:19,360
uh the other group of methods is those

00:05:17,840 --> 00:05:20,320
that you know don't use these inverse

00:05:19,360 --> 00:05:22,160
indexes

00:05:20,320 --> 00:05:24,800
such as you know hierarchical and how we

00:05:22,160 --> 00:05:25,919
call small worlds or hmsw

00:05:24,800 --> 00:05:28,479
which i'll get back to a little bit

00:05:25,919 --> 00:05:31,360
later but basically this is a graph

00:05:28,479 --> 00:05:33,120
structure that we search through instead

00:05:31,360 --> 00:05:34,720
but you know for most cases this is a

00:05:33,120 --> 00:05:35,680
little bit you know too low level

00:05:34,720 --> 00:05:39,039
instead we use

00:05:35,680 --> 00:05:41,720
libraries to help us do this

00:05:39,039 --> 00:05:44,720
and a great resource for that is a

00:05:41,720 --> 00:05:44,720
nnbenchmarks.com

00:05:45,199 --> 00:05:48,960
this site compares various libraries

00:05:46,960 --> 00:05:50,400
across many different data sets that

00:05:48,960 --> 00:05:52,080
have different distance measures and

00:05:50,400 --> 00:05:54,240
vector lengths and so on

00:05:52,080 --> 00:05:55,919
and they're graphically compared in

00:05:54,240 --> 00:05:57,840
figures such as this which compares

00:05:55,919 --> 00:06:00,880
recall to queries per second

00:05:57,840 --> 00:06:03,199
so up and to the right is is

00:06:00,880 --> 00:06:06,639
is better uh you know giving higher

00:06:03,199 --> 00:06:07,520
recall with with higher qps um

00:06:06,639 --> 00:06:09,039
just kind of short where in the

00:06:07,520 --> 00:06:10,479
measurements here you know these these

00:06:09,039 --> 00:06:12,400
graphs are all single cpu

00:06:10,479 --> 00:06:13,840
single threads so so they measure the

00:06:12,400 --> 00:06:15,360
latency and don't really measure the

00:06:13,840 --> 00:06:18,080
potential for throughput or

00:06:15,360 --> 00:06:19,520
or maximizing the queries per second uh

00:06:18,080 --> 00:06:20,800
using for instance multiple threads

00:06:19,520 --> 00:06:22,880
which is just as

00:06:20,800 --> 00:06:24,479
or maybe even more important from many

00:06:22,880 --> 00:06:25,840
types of applications so

00:06:24,479 --> 00:06:27,039
uh when choosing a library this is

00:06:25,840 --> 00:06:28,240
something you might want to think about

00:06:27,039 --> 00:06:29,759
at least it's something we care a lot

00:06:28,240 --> 00:06:33,120
about that

00:06:29,759 --> 00:06:34,000
at vespa anyways um here i turn just a

00:06:33,120 --> 00:06:36,000
few libraries

00:06:34,000 --> 00:06:38,319
to declutter a little bit uh notable

00:06:36,000 --> 00:06:40,319
ones are scanned from from google

00:06:38,319 --> 00:06:41,680
uh files from facebook and away from

00:06:40,319 --> 00:06:45,440
spotify and and of course

00:06:41,680 --> 00:06:46,000
vespa um so we have a pull request into

00:06:45,440 --> 00:06:48,479
an

00:06:46,000 --> 00:06:49,520
a nnn benchmarks to include vespas and

00:06:48,479 --> 00:06:51,759
an implementation

00:06:49,520 --> 00:06:53,599
even though it's not really available as

00:06:51,759 --> 00:06:55,039
a standalone library

00:06:53,599 --> 00:06:56,800
but we wanted to measure how good our

00:06:55,039 --> 00:06:58,960
implementation is against the others

00:06:56,800 --> 00:07:01,120
and as you might see it's not right at

00:06:58,960 --> 00:07:02,560
the top but it's competitive with others

00:07:01,120 --> 00:07:06,240
we compare

00:07:02,560 --> 00:07:08,960
ourselves to which is if if you kind of

00:07:06,240 --> 00:07:09,880
able to see that are other libraries

00:07:08,960 --> 00:07:13,360
that use this

00:07:09,880 --> 00:07:13,360
hmsw approach

00:07:13,840 --> 00:07:17,680
and the reason for that is that vespa's

00:07:15,680 --> 00:07:18,800
implementation is of course based on h

00:07:17,680 --> 00:07:22,560
and sw for

00:07:18,800 --> 00:07:23,680
a few good reasons um one is of course

00:07:22,560 --> 00:07:25,919
you know it performs well during

00:07:23,680 --> 00:07:27,520
retrieval but perhaps more importantly

00:07:25,919 --> 00:07:30,560
is that it allows for

00:07:27,520 --> 00:07:30,960
incremental modification and now most of

00:07:30,560 --> 00:07:32,560
the

00:07:30,960 --> 00:07:35,120
other approaches i mentioned they build

00:07:32,560 --> 00:07:37,440
indexes offline you know in batches

00:07:35,120 --> 00:07:38,479
uh so the index is kind of immutable and

00:07:37,440 --> 00:07:41,520
requires some

00:07:38,479 --> 00:07:43,360
or sometimes lengthy indexing periods

00:07:41,520 --> 00:07:45,759
you know particularly for for large data

00:07:43,360 --> 00:07:47,759
sets uh but essential design of

00:07:45,759 --> 00:07:49,919
vespa is that data that's indexed should

00:07:47,759 --> 00:07:51,280
be you know immediately available for

00:07:49,919 --> 00:07:53,360
searching

00:07:51,280 --> 00:07:54,960
uh and for many types of application

00:07:53,360 --> 00:07:56,479
that's that's really important

00:07:54,960 --> 00:07:58,560
and it's directly supported by the say

00:07:56,479 --> 00:08:01,120
nhsw algorithm

00:07:58,560 --> 00:08:02,960
and now we've done some modifications to

00:08:01,120 --> 00:08:05,520
this algorithm such as allowing removes

00:08:02,960 --> 00:08:08,960
as well which is equally

00:08:05,520 --> 00:08:11,039
important removing stale data

00:08:08,960 --> 00:08:12,479
so in the previous slide we saw some

00:08:11,039 --> 00:08:14,479
libraries that do

00:08:12,479 --> 00:08:16,240
vector similarity search um they're also

00:08:14,479 --> 00:08:16,800
higher level platforms such as you know

00:08:16,240 --> 00:08:20,240
perhaps

00:08:16,800 --> 00:08:22,080
nilvis we v8 pine cone and so on that

00:08:20,240 --> 00:08:24,479
offers a vector search service that you

00:08:22,080 --> 00:08:26,720
can call out to from your serving stack

00:08:24,479 --> 00:08:28,160
um which library or platform you

00:08:26,720 --> 00:08:29,680
ultimately choose of course depends on

00:08:28,160 --> 00:08:30,720
what type of system you're developing i

00:08:29,680 --> 00:08:32,640
mean background

00:08:30,720 --> 00:08:34,560
index building might be perfectly

00:08:32,640 --> 00:08:36,479
acceptable solution for

00:08:34,560 --> 00:08:38,240
applications where data doesn't really

00:08:36,479 --> 00:08:40,000
change that often

00:08:38,240 --> 00:08:42,399
however when it comes to you know search

00:08:40,000 --> 00:08:45,440
and and recommendation applications

00:08:42,399 --> 00:08:47,760
um there is an another important aspect

00:08:45,440 --> 00:08:49,040
uh which isn't touched upon uh that

00:08:47,760 --> 00:08:52,480
often

00:08:49,040 --> 00:08:54,880
and that is uh filtering on metadata

00:08:52,480 --> 00:08:55,920
so what i mean by that is that most

00:08:54,880 --> 00:08:57,920
often in

00:08:55,920 --> 00:08:59,600
a search application each item in the

00:08:57,920 --> 00:09:01,680
data usually has

00:08:59,600 --> 00:09:03,760
associated data with it or side

00:09:01,680 --> 00:09:05,600
information or metadata

00:09:03,760 --> 00:09:07,360
and now this metadata is usually stored

00:09:05,600 --> 00:09:09,040
separately from the library or service

00:09:07,360 --> 00:09:10,399
implementing the nearest neighbor search

00:09:09,040 --> 00:09:13,920
and

00:09:10,399 --> 00:09:17,279
this can become problematic as we'll see

00:09:13,920 --> 00:09:20,000
shortly so

00:09:17,279 --> 00:09:21,040
the first example is a semantic search

00:09:20,000 --> 00:09:24,000
for text

00:09:21,040 --> 00:09:25,519
now again assume you have some way of

00:09:24,000 --> 00:09:28,240
encoding text such that you know

00:09:25,519 --> 00:09:30,720
documents or paragraphs or sentences

00:09:28,240 --> 00:09:32,320
you can encode them to two vectors uh

00:09:30,720 --> 00:09:34,160
one common way these days is to use

00:09:32,320 --> 00:09:35,519
transformer models such as purge and so

00:09:34,160 --> 00:09:37,120
on to

00:09:35,519 --> 00:09:38,880
and use one of the token vector

00:09:37,120 --> 00:09:39,760
representations there as an embedding

00:09:38,880 --> 00:09:42,000
vector

00:09:39,760 --> 00:09:43,600
um any way you do this you can you know

00:09:42,000 --> 00:09:47,279
visualize these points

00:09:43,600 --> 00:09:47,279
in some high dimensional space

00:09:48,640 --> 00:09:52,080
now assume also that you have some way

00:09:51,680 --> 00:09:54,080
of

00:09:52,080 --> 00:09:55,360
encoding a query so that it maps into

00:09:54,080 --> 00:09:57,839
the same space

00:09:55,360 --> 00:10:01,120
so that the closest documents in this

00:09:57,839 --> 00:10:02,800
space is the most relevant to the query

00:10:01,120 --> 00:10:04,880
now queries usually have some different

00:10:02,800 --> 00:10:07,120
properties and documents

00:10:04,880 --> 00:10:09,200
for one they're typically much shorter

00:10:07,120 --> 00:10:10,560
um so they typically don't use the same

00:10:09,200 --> 00:10:12,320
encoding model

00:10:10,560 --> 00:10:14,160
but to ensure that they kind of map into

00:10:12,320 --> 00:10:16,240
the same space we can use like

00:10:14,160 --> 00:10:17,920
a two tower configuration which includes

00:10:16,240 --> 00:10:20,800
a distance function

00:10:17,920 --> 00:10:21,760
and propagate the tuning process but uh

00:10:20,800 --> 00:10:24,000
anyway

00:10:21,760 --> 00:10:25,040
mapping the query into the same space we

00:10:24,000 --> 00:10:27,440
can find

00:10:25,040 --> 00:10:28,800
what here for instance the 10 most

00:10:27,440 --> 00:10:33,120
relevant documents to

00:10:28,800 --> 00:10:37,120
to the query and this works well

00:10:33,120 --> 00:10:38,720
however search applications might allow

00:10:37,120 --> 00:10:40,800
the user to kind of drill into the

00:10:38,720 --> 00:10:43,680
results by for instance

00:10:40,800 --> 00:10:44,880
here filtering on the publication year

00:10:43,680 --> 00:10:46,959
of the document

00:10:44,880 --> 00:10:49,040
now since we've first retrieved the top

00:10:46,959 --> 00:10:51,760
then 10 documents using

00:10:49,040 --> 00:10:53,600
nearest neighbor search and then we

00:10:51,760 --> 00:10:56,240
filter for the year 2021

00:10:53,600 --> 00:10:58,160
we only actually here retrieve the three

00:10:56,240 --> 00:10:59,600
relevant documents to the query

00:10:58,160 --> 00:11:01,600
i mean the other documents the one in

00:10:59,600 --> 00:11:02,720
orange here that are in this space are

00:11:01,600 --> 00:11:04,480
not recall at all

00:11:02,720 --> 00:11:06,800
even though they are irrelevant to the

00:11:04,480 --> 00:11:09,040
user now this is kind of a

00:11:06,800 --> 00:11:10,160
constructed example but you know clearly

00:11:09,040 --> 00:11:12,320
shows the problem

00:11:10,160 --> 00:11:13,440
we need to solve so again to repeat that

00:11:12,320 --> 00:11:15,279
i mean the nearest

00:11:13,440 --> 00:11:16,560
neighbor search returns the 10 closest

00:11:15,279 --> 00:11:19,600
items to the query

00:11:16,560 --> 00:11:21,839
and applying the filter 2021

00:11:19,600 --> 00:11:23,760
7 out of those 10 results are filtered

00:11:21,839 --> 00:11:25,200
away leaving only the three that

00:11:23,760 --> 00:11:28,880
actually pass the filter

00:11:25,200 --> 00:11:31,440
which is ultimate result of this search

00:11:28,880 --> 00:11:32,320
so naively you know to return the top 10

00:11:31,440 --> 00:11:35,040
documents that

00:11:32,320 --> 00:11:36,399
actually do pass the filter we need to

00:11:35,040 --> 00:11:37,279
search in this case for you know

00:11:36,399 --> 00:11:40,240
something around

00:11:37,279 --> 00:11:41,279
50 results instead of time problem is we

00:11:40,240 --> 00:11:43,839
don't really know

00:11:41,279 --> 00:11:45,120
how much to search for beforehand so but

00:11:43,839 --> 00:11:47,920
we'll see later how we can

00:11:45,120 --> 00:11:47,920
improve upon this

00:11:49,040 --> 00:11:55,279
so another example recommendation so

00:11:52,720 --> 00:11:55,920
recommendation is similar to search but

00:11:55,279 --> 00:12:00,560
the query

00:11:55,920 --> 00:12:02,560
is the actual user profile

00:12:00,560 --> 00:12:04,320
we want to search for items to to

00:12:02,560 --> 00:12:07,920
recommend given what we know

00:12:04,320 --> 00:12:10,240
about a user so classically we'd use

00:12:07,920 --> 00:12:12,000
approaches such as matrix factorization

00:12:10,240 --> 00:12:13,120
and these days of course use more deep

00:12:12,000 --> 00:12:14,959
learning approaches

00:12:13,120 --> 00:12:16,959
such as neural collaborative filtering

00:12:14,959 --> 00:12:18,320
and its descendants

00:12:16,959 --> 00:12:20,480
these figures here by the way they're

00:12:18,320 --> 00:12:20,880
from a news recommendation tutorial we

00:12:20,480 --> 00:12:22,839
have

00:12:20,880 --> 00:12:24,560
uh for westbound in case you're

00:12:22,839 --> 00:12:26,560
interested

00:12:24,560 --> 00:12:28,880
in any case we create this user

00:12:26,560 --> 00:12:30,880
embeddings and item embeddings and

00:12:28,880 --> 00:12:32,079
find the items to recommend by doing a

00:12:30,880 --> 00:12:34,160
dot product or

00:12:32,079 --> 00:12:37,040
or inner product search between the user

00:12:34,160 --> 00:12:38,880
embeddings and the item embeddings

00:12:37,040 --> 00:12:41,040
this is called maximum inner product

00:12:38,880 --> 00:12:42,639
search uh and it isn't really you know

00:12:41,040 --> 00:12:44,480
directly implementable

00:12:42,639 --> 00:12:46,800
in the approximate nearest neighbor

00:12:44,480 --> 00:12:48,240
algorithms so we need to convert the

00:12:46,800 --> 00:12:50,000
mips problem to for instance the

00:12:48,240 --> 00:12:53,839
euclidean distance problem which which

00:12:50,000 --> 00:12:55,920
allows us to do so

00:12:53,839 --> 00:12:58,320
now for recommendation services such as

00:12:55,920 --> 00:13:00,079
youtube and tick tock and so on

00:12:58,320 --> 00:13:01,440
there are a lot of you know inherent

00:13:00,079 --> 00:13:03,839
filters we need to consider

00:13:01,440 --> 00:13:05,120
such as you know age appropriateness

00:13:03,839 --> 00:13:08,240
band content

00:13:05,120 --> 00:13:10,560
region availability language and so on

00:13:08,240 --> 00:13:12,560
and there might be more dynamic filters

00:13:10,560 --> 00:13:15,760
such as business rules for

00:13:12,560 --> 00:13:18,320
diversity and deduplication and

00:13:15,760 --> 00:13:20,160
so on but all these kind of serve to

00:13:18,320 --> 00:13:22,160
potentially you know filter away a lot

00:13:20,160 --> 00:13:24,480
of otherwise relevant items

00:13:22,160 --> 00:13:26,560
so that the effect is that we recall far

00:13:24,480 --> 00:13:28,959
a few items than what we otherwise

00:13:26,560 --> 00:13:28,959
could have

00:13:31,440 --> 00:13:35,360
add search another example similar

00:13:34,399 --> 00:13:37,519
application really

00:13:35,360 --> 00:13:39,040
um the image here to the to the right

00:13:37,519 --> 00:13:40,240
here is taken from the front page of

00:13:39,040 --> 00:13:42,079
yahoo.com

00:13:40,240 --> 00:13:44,480
uh which to the large degree runs on

00:13:42,079 --> 00:13:45,199
vespa and you have this kind of infinite

00:13:44,480 --> 00:13:48,240
scrolling

00:13:45,199 --> 00:13:50,000
stream uh new stream which has these

00:13:48,240 --> 00:13:51,120
kind of native ads kind of hidden in the

00:13:50,000 --> 00:13:54,560
stream

00:13:51,120 --> 00:13:56,639
um likewise users have profiles

00:13:54,560 --> 00:13:58,160
as as do ads and the dot product between

00:13:56,639 --> 00:13:59,920
these two you know correspond to the

00:13:58,160 --> 00:14:00,560
kind of interestingness so they add to

00:13:59,920 --> 00:14:04,320
the user

00:14:00,560 --> 00:14:06,079
at least hopefully um now these these

00:14:04,320 --> 00:14:07,680
ads also have a lot of metadata such as

00:14:06,079 --> 00:14:10,000
you know target group uh

00:14:07,680 --> 00:14:11,199
target location geographic location and

00:14:10,000 --> 00:14:13,440
so on and so on

00:14:11,199 --> 00:14:14,399
um but one very important piece of data

00:14:13,440 --> 00:14:17,600
is the ads or

00:14:14,399 --> 00:14:18,880
or ad campaigns budgets so the

00:14:17,600 --> 00:14:20,959
advertiser might

00:14:18,880 --> 00:14:22,959
pay for each impression and we don't

00:14:20,959 --> 00:14:25,519
earn any money if we show an ad that has

00:14:22,959 --> 00:14:26,720
suspended budget so so likewise if we

00:14:25,519 --> 00:14:28,320
first do a vector search and then

00:14:26,720 --> 00:14:30,160
perform filters afterwards there's a

00:14:28,320 --> 00:14:31,920
real possibility that we aren't really

00:14:30,160 --> 00:14:33,519
you know retrieving the most interesting

00:14:31,920 --> 00:14:37,120
or most profitable ads

00:14:33,519 --> 00:14:37,120
to show to the user

00:14:38,399 --> 00:14:44,079
uh so in online dating

00:14:41,680 --> 00:14:44,880
you have your uh your profile of of

00:14:44,079 --> 00:14:47,279
interests

00:14:44,880 --> 00:14:49,040
um now that's what you are interested in

00:14:47,279 --> 00:14:52,079
it could be like pets and travel and

00:14:49,040 --> 00:14:54,959
food and tv shows working out etc etc

00:14:52,079 --> 00:14:56,000
now this is your your representation um

00:14:54,959 --> 00:14:57,760
when searching for

00:14:56,000 --> 00:14:59,920
potential matches you also have a set of

00:14:57,760 --> 00:15:01,839
preferences or filters such as you know

00:14:59,920 --> 00:15:03,600
geographical location

00:15:01,839 --> 00:15:05,760
you might want to meet people close to

00:15:03,600 --> 00:15:08,800
you a gender age range

00:15:05,760 --> 00:15:10,079
are they at least six feet tall and

00:15:08,800 --> 00:15:11,839
other filters

00:15:10,079 --> 00:15:13,600
particularly for services such as tinder

00:15:11,839 --> 00:15:15,199
where you

00:15:13,600 --> 00:15:17,760
filter away users where you already

00:15:15,199 --> 00:15:20,079
swipe them left or right

00:15:17,760 --> 00:15:21,120
uh so again if if first retrieving

00:15:20,079 --> 00:15:22,800
profiles using

00:15:21,120 --> 00:15:24,320
nearest neighbors there's a big chance

00:15:22,800 --> 00:15:25,920
that the people that you know best match

00:15:24,320 --> 00:15:27,440
your interest don't pass all of these

00:15:25,920 --> 00:15:29,759
filters

00:15:27,440 --> 00:15:30,800
so many potential matches are are not

00:15:29,759 --> 00:15:33,600
retrieved and

00:15:30,800 --> 00:15:33,600
no date for you

00:15:35,360 --> 00:15:39,680
shopping another obvious example really

00:15:37,839 --> 00:15:42,079
this example here is from a use case in

00:15:39,680 --> 00:15:44,720
our documentation for using

00:15:42,079 --> 00:15:46,320
a vespan shopping the use case sample

00:15:44,720 --> 00:15:48,560
appear even comes with a front end this

00:15:46,320 --> 00:15:49,600
can be seen here

00:15:48,560 --> 00:15:51,279
now products can have their

00:15:49,600 --> 00:15:52,959
representations and queries can be

00:15:51,279 --> 00:15:54,000
mapped to the same vector space as the

00:15:52,959 --> 00:15:55,199
products and

00:15:54,000 --> 00:15:57,600
products have a lot of metadata of

00:15:55,199 --> 00:16:00,240
course the price category brands

00:15:57,600 --> 00:16:01,839
even rating probably one of the

00:16:00,240 --> 00:16:04,240
important ones is where not the item is

00:16:01,839 --> 00:16:05,839
in stock

00:16:04,240 --> 00:16:07,360
getting results for items that can't be

00:16:05,839 --> 00:16:08,160
purchased because they're out of stock

00:16:07,360 --> 00:16:11,279
might be a

00:16:08,160 --> 00:16:11,279
poor user experience

00:16:11,440 --> 00:16:14,560
and again by by first retrieving

00:16:13,120 --> 00:16:15,680
products using nearest neighbors and

00:16:14,560 --> 00:16:17,839
filtering using

00:16:15,680 --> 00:16:19,040
metadata would likely lead to a lot of

00:16:17,839 --> 00:16:22,320
relevant products not

00:16:19,040 --> 00:16:25,920
not being retrieved

00:16:22,320 --> 00:16:27,920
uh finally um local business search

00:16:25,920 --> 00:16:29,440
um let's say i want to search for

00:16:27,920 --> 00:16:31,199
restaurants near me

00:16:29,440 --> 00:16:32,560
and we've implemented some sort of

00:16:31,199 --> 00:16:34,639
personalized search so that my

00:16:32,560 --> 00:16:36,399
preference profile is used to

00:16:34,639 --> 00:16:38,639
retrieve the restaurants that best fit

00:16:36,399 --> 00:16:40,800
my profile now uh

00:16:38,639 --> 00:16:42,720
assume that my profile uh retrieves only

00:16:40,800 --> 00:16:45,120
the best restaurants in the world

00:16:42,720 --> 00:16:46,320
uh of course it's it's unlikely that

00:16:45,120 --> 00:16:48,240
they're close to me

00:16:46,320 --> 00:16:50,079
at least for the small town that i live

00:16:48,240 --> 00:16:52,560
up north which is the red dot up at the

00:16:50,079 --> 00:16:54,959
top there

00:16:52,560 --> 00:16:56,480
well it's not actually not true we do

00:16:54,959 --> 00:16:58,800
have some great restaurants here we do

00:16:56,480 --> 00:17:01,600
have a few michelin stars

00:16:58,800 --> 00:17:02,880
here but anyway restaurants that best

00:17:01,600 --> 00:17:05,280
fit my profile

00:17:02,880 --> 00:17:06,000
globally are pretty unlikely to be close

00:17:05,280 --> 00:17:07,280
to me

00:17:06,000 --> 00:17:09,360
meaning that you would very likely not

00:17:07,280 --> 00:17:11,520
return any results at all

00:17:09,360 --> 00:17:13,360
so this is this is kind of an extreme

00:17:11,520 --> 00:17:13,760
example obviously you wouldn't do this

00:17:13,360 --> 00:17:18,559
but

00:17:13,760 --> 00:17:21,039
but the point stands

00:17:18,559 --> 00:17:21,839
so uh the point being uh is that you

00:17:21,039 --> 00:17:24,959
know post

00:17:21,839 --> 00:17:27,120
filtering of metadata doesn't really

00:17:24,959 --> 00:17:28,559
work all that well so what can you do

00:17:27,120 --> 00:17:33,280
about that

00:17:28,559 --> 00:17:35,760
um one obvious approach is to

00:17:33,280 --> 00:17:37,039
recall more and just return more items

00:17:35,760 --> 00:17:39,200
from the nearest neighbor search

00:17:37,039 --> 00:17:41,120
um however that can become quite

00:17:39,200 --> 00:17:41,440
expensive you know both in processing

00:17:41,120 --> 00:17:43,120
and

00:17:41,440 --> 00:17:44,799
in time especially if these need to come

00:17:43,120 --> 00:17:46,720
across the network

00:17:44,799 --> 00:17:48,320
and still this isn't really guaranteed

00:17:46,720 --> 00:17:50,000
to work

00:17:48,320 --> 00:17:51,760
another option is to you know set up

00:17:50,000 --> 00:17:54,000
multiple indexes

00:17:51,760 --> 00:17:55,200
with one per filter for instance in a

00:17:54,000 --> 00:17:58,320
text search example

00:17:55,200 --> 00:17:58,720
one index per publication year now this

00:17:58,320 --> 00:18:00,160
might

00:17:58,720 --> 00:18:01,919
work if you have a small number of

00:18:00,160 --> 00:18:03,520
filters and can avoid the explosion of

00:18:01,919 --> 00:18:07,120
combinations but but still

00:18:03,520 --> 00:18:08,559
this adds a lot of complexity um

00:18:07,120 --> 00:18:10,240
now the solution really is to do a

00:18:08,559 --> 00:18:11,039
nearest neighbor search only among the

00:18:10,240 --> 00:18:13,840
items that have

00:18:11,039 --> 00:18:14,960
survived filtering is pre-filtering and

00:18:13,840 --> 00:18:16,640
the approaches that i mentioned

00:18:14,960 --> 00:18:18,799
previously you know the libraries and

00:18:16,640 --> 00:18:20,240
platforms they don't really support this

00:18:18,799 --> 00:18:21,520
as the nearest neighbor index and

00:18:20,240 --> 00:18:23,039
metadata usually are you know in

00:18:21,520 --> 00:18:25,200
separate systems

00:18:23,039 --> 00:18:29,360
however in vespa we've modified the

00:18:25,200 --> 00:18:33,440
basic hmsw to to support this

00:18:29,360 --> 00:18:35,679
by introducing eligibility lists

00:18:33,440 --> 00:18:37,039
this causes the algorithm to effectively

00:18:35,679 --> 00:18:40,160
skip items that are not

00:18:37,039 --> 00:18:41,760
in this list so in this figure again the

00:18:40,160 --> 00:18:42,720
orange are the items that pass the

00:18:41,760 --> 00:18:44,960
filter the blue

00:18:42,720 --> 00:18:46,400
items that we want to skip so the

00:18:44,960 --> 00:18:49,760
algorithm effectively

00:18:46,400 --> 00:18:51,360
dynamically increases the search area

00:18:49,760 --> 00:18:53,440
according to the number of items that we

00:18:51,360 --> 00:18:56,000
want to retrieve and the items in the

00:18:53,440 --> 00:18:57,760
eligibility list

00:18:56,000 --> 00:18:59,280
and this is nice because we only return

00:18:57,760 --> 00:19:01,280
the exact number of results that you

00:18:59,280 --> 00:19:04,080
want to the solving you know the problem

00:19:01,280 --> 00:19:06,160
of post filtering

00:19:04,080 --> 00:19:07,840
um there's perhaps one thing that should

00:19:06,160 --> 00:19:09,600
be mentioned and that there's a

00:19:07,840 --> 00:19:11,760
still a slight cost to navigate the

00:19:09,600 --> 00:19:13,760
graph for items that are skipped

00:19:11,760 --> 00:19:15,360
so if the filter is strong meaning there

00:19:13,760 --> 00:19:17,440
are relatively few items in

00:19:15,360 --> 00:19:18,720
in this eligibility list the cost of

00:19:17,440 --> 00:19:21,360
searching the graph

00:19:18,720 --> 00:19:22,640
can be high and to solve this problem

00:19:21,360 --> 00:19:25,360
vespa falls back to

00:19:22,640 --> 00:19:27,120
exact nearest neighbor scan only through

00:19:25,360 --> 00:19:27,840
the list of eligible items when this

00:19:27,120 --> 00:19:29,440
happens

00:19:27,840 --> 00:19:31,520
because that's actually more efficient

00:19:29,440 --> 00:19:33,120
than navigating the graph

00:19:31,520 --> 00:19:34,640
so and this threshold is of course

00:19:33,120 --> 00:19:34,960
configurable and that's one of the kind

00:19:34,640 --> 00:19:37,200
of

00:19:34,960 --> 00:19:39,600
nice things that the best adds to to the

00:19:37,200 --> 00:19:42,720
table

00:19:39,600 --> 00:19:44,160
so uh to kind of uh sum up um

00:19:42,720 --> 00:19:46,160
vespa innovates a little bit with

00:19:44,160 --> 00:19:48,000
approximate nearest neighbors uh

00:19:46,160 --> 00:19:49,919
search to fit in with you know many of

00:19:48,000 --> 00:19:52,720
the different aspects that are important

00:19:49,919 --> 00:19:54,880
in search applications

00:19:52,720 --> 00:19:56,240
one is the dynamic modification of the

00:19:54,880 --> 00:19:57,120
graph by you know particularly

00:19:56,240 --> 00:20:00,240
supporting

00:19:57,120 --> 00:20:01,919
removing of items use efficient data

00:20:00,240 --> 00:20:04,159
structures and methods to

00:20:01,919 --> 00:20:05,840
increase the performance when building

00:20:04,159 --> 00:20:09,360
indexes

00:20:05,840 --> 00:20:14,000
and it modifies h and sw to to support

00:20:09,360 --> 00:20:17,120
pre-filtering um

00:20:14,000 --> 00:20:19,440
now the implementation we chose

00:20:17,120 --> 00:20:20,559
to support a ns are really a consequence

00:20:19,440 --> 00:20:22,720
of fitting in with

00:20:20,559 --> 00:20:24,240
design philosophy of vespa and it's

00:20:22,720 --> 00:20:26,080
important to note that vesp is much more

00:20:24,240 --> 00:20:27,600
than a vector search engine and all the

00:20:26,080 --> 00:20:29,600
examples that we saw previously are

00:20:27,600 --> 00:20:32,400
actual applications using

00:20:29,600 --> 00:20:32,720
using vespa so some other use cases here

00:20:32,400 --> 00:20:34,400
in

00:20:32,720 --> 00:20:36,240
text search using both classic

00:20:34,400 --> 00:20:37,840
information retrieval techniques such as

00:20:36,240 --> 00:20:39,280
bm25

00:20:37,840 --> 00:20:41,440
and more modern approaches such as

00:20:39,280 --> 00:20:43,679
vector similarity and transformers such

00:20:41,440 --> 00:20:45,440
as bird etc

00:20:43,679 --> 00:20:47,039
recommendation and personalization using

00:20:45,440 --> 00:20:50,799
again vector search machine learned

00:20:47,039 --> 00:20:52,000
models true partial updates and so on

00:20:50,799 --> 00:20:53,520
another example which you have a pretty

00:20:52,000 --> 00:20:54,960
good sample app for is question

00:20:53,520 --> 00:20:58,240
answering which uses

00:20:54,960 --> 00:21:00,400
a ns to select passages with answers to

00:20:58,240 --> 00:21:01,520
questions and uses burp models to

00:21:00,400 --> 00:21:03,760
extract the

00:21:01,520 --> 00:21:05,840
exact answer to the question and and we

00:21:03,760 --> 00:21:08,320
have many more examples but

00:21:05,840 --> 00:21:09,840
even finding love um okay cupid the

00:21:08,320 --> 00:21:11,520
inspiration for the online dating

00:21:09,840 --> 00:21:12,000
example is a great blog post on why they

00:21:11,520 --> 00:21:16,799
chose

00:21:12,000 --> 00:21:19,760
vespo ver elasticsearch

00:21:16,799 --> 00:21:21,360
so that pretty much sums up my talk uh

00:21:19,760 --> 00:21:23,600
if you want to know more about vespa

00:21:21,360 --> 00:21:24,799
check out these these resources uh we

00:21:23,600 --> 00:21:27,600
have an open source version

00:21:24,799 --> 00:21:29,360
and the cloud offering as well um which

00:21:27,600 --> 00:21:30,720
currently has a free trial if you want

00:21:29,360 --> 00:21:33,600
to check us out

00:21:30,720 --> 00:21:35,039
and other than that tune in to the the

00:21:33,600 --> 00:21:38,159
search engine debate

00:21:35,039 --> 00:21:40,640
on thursday to to learn more uh

00:21:38,159 --> 00:21:43,039
so that thanks i'm going to open the

00:21:40,640 --> 00:21:43,039
questions

00:21:43,120 --> 00:21:46,400
thank you for the great talk and uh what

00:21:44,880 --> 00:21:49,200
is the way to finish it up with

00:21:46,400 --> 00:21:49,600
finding the love also this vespa right

00:21:49,200 --> 00:21:52,640
yeah

00:21:49,600 --> 00:21:54,720
exactly very nice so we got a few

00:21:52,640 --> 00:21:57,200
questions from the audience um so

00:21:54,720 --> 00:21:59,200
first question would be how customizable

00:21:57,200 --> 00:22:00,799
is vespa can we deal develop and plug

00:21:59,200 --> 00:22:01,840
custom relevance algorithm

00:22:00,799 --> 00:22:03,520
it's like you mentioned a bit of like

00:22:01,840 --> 00:22:04,720
custom models right but how actually

00:22:03,520 --> 00:22:06,480
complicated is that to

00:22:04,720 --> 00:22:09,280
you know develop a new similarity model

00:22:06,480 --> 00:22:13,280
or like new algorithm right and

00:22:09,280 --> 00:22:15,200
it's very customizable so basically uh

00:22:13,280 --> 00:22:16,960
is divided a little bit in two we call

00:22:15,200 --> 00:22:18,400
it the kind of stateless

00:22:16,960 --> 00:22:20,320
front end and we have a kind of a

00:22:18,400 --> 00:22:21,919
stateful backend which

00:22:20,320 --> 00:22:23,440
where you have all the content and all

00:22:21,919 --> 00:22:24,799
the kind of that's where all the

00:22:23,440 --> 00:22:27,200
computation is done

00:22:24,799 --> 00:22:28,400
so on the back end you can write your

00:22:27,200 --> 00:22:31,039
custom

00:22:28,400 --> 00:22:32,799
ranking functions to do pretty much

00:22:31,039 --> 00:22:34,159
whatever computation you want to do

00:22:32,799 --> 00:22:35,760
using tensors and

00:22:34,159 --> 00:22:37,600
combining them with the machine learning

00:22:35,760 --> 00:22:39,360
models and so on

00:22:37,600 --> 00:22:41,200
in the front in the stateless layer you

00:22:39,360 --> 00:22:42,400
can add your custom java code which

00:22:41,200 --> 00:22:44,880
pretty much can do any form of

00:22:42,400 --> 00:22:47,360
processing both when

00:22:44,880 --> 00:22:49,600
handling queries or ingesting data and

00:22:47,360 --> 00:22:51,600
so on so i would say this is very

00:22:49,600 --> 00:22:53,840
customizable

00:22:51,600 --> 00:22:55,120
nice very good and uh kind of like a

00:22:53,840 --> 00:22:55,679
similar question but from other

00:22:55,120 --> 00:22:57,679
direction

00:22:55,679 --> 00:22:58,880
um does vespa also support traditional

00:22:57,679 --> 00:23:02,000
relevance algorithm

00:22:58,880 --> 00:23:04,080
for example bm25 tf-idfs if yes

00:23:02,000 --> 00:23:05,679
how does it work right can you combine

00:23:04,080 --> 00:23:06,480
them right or you need to decide like

00:23:05,679 --> 00:23:09,840
it's either one

00:23:06,480 --> 00:23:12,960
or another one no as i as i mentioned

00:23:09,840 --> 00:23:14,240
in just a few slides ago um bm25 or at

00:23:12,960 --> 00:23:15,840
least you know these traditional

00:23:14,240 --> 00:23:17,520
information retrieval techniques

00:23:15,840 --> 00:23:21,919
uh they're very well supported that's

00:23:17,520 --> 00:23:22,320
the kind of basis really of of vespa um

00:23:21,919 --> 00:23:23,919
and

00:23:22,320 --> 00:23:26,080
they're supported both in forms of

00:23:23,919 --> 00:23:27,440
matching and uh you know the first phase

00:23:26,080 --> 00:23:29,280
and you're searching for all documents

00:23:27,440 --> 00:23:31,679
and using them in ranking as well

00:23:29,280 --> 00:23:33,200
so so that's very flexible and how you

00:23:31,679 --> 00:23:36,320
actually match these documents

00:23:33,200 --> 00:23:38,960
or or rank upon them as well so yeah the

00:23:36,320 --> 00:23:41,039
these are definitely uh supported but

00:23:38,960 --> 00:23:43,120
one of the nice things is that is that

00:23:41,039 --> 00:23:44,559
you can kind of combine these more

00:23:43,120 --> 00:23:45,440
traditional information retrievable

00:23:44,559 --> 00:23:46,640
approaches

00:23:45,440 --> 00:23:48,960
with more modern informational

00:23:46,640 --> 00:23:51,120
retrievals as well and and

00:23:48,960 --> 00:23:52,559
adding machine learned models to like a

00:23:51,120 --> 00:23:55,600
later phase model

00:23:52,559 --> 00:23:59,039
or um later phase expression or uh

00:23:55,600 --> 00:24:01,440
calculation as well so uh yes vespa is

00:23:59,039 --> 00:24:03,760
very flexible in in that regard

00:24:01,440 --> 00:24:05,520
so essentially you can get like you know

00:24:03,760 --> 00:24:07,600
uh top whatever and right from a

00:24:05,520 --> 00:24:09,360
neighborhood right and after sword by

00:24:07,600 --> 00:24:11,120
whatever your like tfidf that you were

00:24:09,360 --> 00:24:11,600
actually before right as an example

00:24:11,120 --> 00:24:15,279
right

00:24:11,600 --> 00:24:17,520
yeah exactly true okay nice um

00:24:15,279 --> 00:24:18,720
and uh what else i have here with

00:24:17,520 --> 00:24:20,240
questions there's like more questions

00:24:18,720 --> 00:24:22,240
popping up that's why like

00:24:20,240 --> 00:24:24,240
okay so first question or like third one

00:24:22,240 --> 00:24:25,039
actually um what are the core features

00:24:24,240 --> 00:24:27,120
of lucien

00:24:25,039 --> 00:24:28,240
that are not supported by vespa yeah i

00:24:27,120 --> 00:24:29,760
guess like people will be like hey this

00:24:28,240 --> 00:24:32,320
is like so amazing so why do i still

00:24:29,760 --> 00:24:35,919
need to have this him

00:24:32,320 --> 00:24:37,919
to be blatantly honest uh i

00:24:35,919 --> 00:24:39,360
don't work too much with lucine in that

00:24:37,919 --> 00:24:41,600
i'm a fan of vespa

00:24:39,360 --> 00:24:42,880
so so that's my focus and to to get a

00:24:41,600 --> 00:24:45,600
good answer that question

00:24:42,880 --> 00:24:46,559
uh i'd uh refer to the great debate on

00:24:45,600 --> 00:24:49,360
thursday

00:24:46,559 --> 00:24:49,760
uh which will have experts both on vespa

00:24:49,360 --> 00:24:52,400
and

00:24:49,760 --> 00:24:55,039
lucine and on elasticsearch to answer a

00:24:52,400 --> 00:24:56,799
lot of those different questions there

00:24:55,039 --> 00:24:58,720
sounds good some people also asking

00:24:56,799 --> 00:25:00,240
about performance this comparison i know

00:24:58,720 --> 00:25:01,520
i read but i think the benchmarks that

00:25:00,240 --> 00:25:03,279
you mentioned would be like really the

00:25:01,520 --> 00:25:04,720
ultimate answer for those right so

00:25:03,279 --> 00:25:06,799
just like go to the website and people

00:25:04,720 --> 00:25:10,240
can find it right uh definitely

00:25:06,799 --> 00:25:12,559
so uh so again um we've added a

00:25:10,240 --> 00:25:13,760
pull request to add the the performance

00:25:12,559 --> 00:25:15,200
of the a ns

00:25:13,760 --> 00:25:17,440
implementation of usb 2 and and

00:25:15,200 --> 00:25:19,919
benchmarks uh but

00:25:17,440 --> 00:25:21,120
we don't really you know uh provides the

00:25:19,919 --> 00:25:22,960
n

00:25:21,120 --> 00:25:24,880
code invest as a library as a

00:25:22,960 --> 00:25:27,039
stand-alone library it's part of you

00:25:24,880 --> 00:25:29,919
know the the bigger system

00:25:27,039 --> 00:25:31,039
um still we want to see how how well it

00:25:29,919 --> 00:25:34,880
performs

00:25:31,039 --> 00:25:36,960
but it's um important to note that it's

00:25:34,880 --> 00:25:38,559
it's working in the context of a larger

00:25:36,960 --> 00:25:39,840
you know search system which does a lot

00:25:38,559 --> 00:25:43,200
of other stuff

00:25:39,840 --> 00:25:44,640
as well so so um that needs to be taken

00:25:43,200 --> 00:25:46,400
into consideration too

00:25:44,640 --> 00:25:48,080
yeah so that's good um another question

00:25:46,400 --> 00:25:50,240
actually from my side so you mentioned

00:25:48,080 --> 00:25:51,679
this uh example with a budget right and

00:25:50,240 --> 00:25:53,840
me coming from e-commerce i kind of like

00:25:51,679 --> 00:25:56,080
seen it like across the board right

00:25:53,840 --> 00:25:57,360
so do you see because i mean the easy

00:25:56,080 --> 00:25:59,039
solution would be saying like hey if

00:25:57,360 --> 00:26:00,559
budget is like out right you just like

00:25:59,039 --> 00:26:02,080
stop showing the things right

00:26:00,559 --> 00:26:03,919
but it also means that there's a website

00:26:02,080 --> 00:26:05,679
like the yahoo for instance right

00:26:03,919 --> 00:26:07,039
you can have like you know like lots of

00:26:05,679 --> 00:26:08,240
impressions right and after suddenly

00:26:07,039 --> 00:26:10,159
they go like to zero

00:26:08,240 --> 00:26:11,760
is there like any ways that you can see

00:26:10,159 --> 00:26:13,679
that it's like still scalable

00:26:11,760 --> 00:26:14,799
and you can do it more dynamically right

00:26:13,679 --> 00:26:16,559
so you can you know like a boost

00:26:14,799 --> 00:26:18,480
visibility a bit of like last right

00:26:16,559 --> 00:26:19,919
and kind of like a dual for uh

00:26:18,480 --> 00:26:20,320
controlling algorithm like in the way

00:26:19,919 --> 00:26:21,679
right

00:26:20,320 --> 00:26:23,120
but there's like a lot of budget right

00:26:21,679 --> 00:26:24,400
you have this ability if not like it's

00:26:23,120 --> 00:26:25,840
kind of like becoming like less and less

00:26:24,400 --> 00:26:27,840
but not drastically right from one to

00:26:25,840 --> 00:26:30,080
zero

00:26:27,840 --> 00:26:32,159
yeah so uh i guess there's different

00:26:30,080 --> 00:26:34,720
ways of of uh of handling that

00:26:32,159 --> 00:26:36,320
um you can kind of bake that into your

00:26:34,720 --> 00:26:37,520
kind of ranking function in a way and

00:26:36,320 --> 00:26:40,640
then you have a

00:26:37,520 --> 00:26:41,679
sort of kind of a graded decrease and so

00:26:40,640 --> 00:26:43,120
on you don't want to you know

00:26:41,679 --> 00:26:45,120
suddenly come into the position where

00:26:43,120 --> 00:26:47,200
you you you only have

00:26:45,120 --> 00:26:49,039
uh ads to show which all of them have

00:26:47,200 --> 00:26:49,919
used used up their budgets and so on of

00:26:49,039 --> 00:26:53,760
course

00:26:49,919 --> 00:26:55,840
so um we have different teams um

00:26:53,760 --> 00:26:57,200
that that work on this specifically and

00:26:55,840 --> 00:26:59,679
those are just one of the kind of many

00:26:57,200 --> 00:27:02,720
applications that are in vespa

00:26:59,679 --> 00:27:05,120
and um i i really don't have full

00:27:02,720 --> 00:27:07,360
view into how they handle exactly this

00:27:05,120 --> 00:27:21,840
question but they definitely have to

00:27:07,360 --> 00:27:21,840
solve that so that's good thank you

00:27:30,000 --> 00:27:32,080

YouTube URL: https://www.youtube.com/watch?v=-NjETJIe-Xs


