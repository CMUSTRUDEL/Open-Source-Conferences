Title: Tzu-Li (Gordon) Tai – Stateful Functions 3.0: Towards a Cross-Platform Stateful Serverless Stack
Publication date: 2021-07-01
Playlist: Berlin Buzzwords 2021 #bbuzz
Description: 
	Stateful Functions (StateFun), a project developed under the umbrella of Apache Flink, provides consistent messaging and distributed state management for stateful serverless applications. It does so in a vendor, platform and language agnostic manner - applications are composed of inter-messaging, polyglot functions that can be deployed on a mixture of your preferred FaaS platforms, as a Spring Boot application on Kubernetes, or really any deployment method typically used in modern cloud-native architectures.

In this session, you will learn about the core concepts behind the project and the abstractions that developers would work with, all up to date to the latest upcoming 3.0 release. For new users, the content of this talk will be a perfect place to get started with StateFun. For existing users, this will be a great opportunity to catch up with the latest advancements in the project, including improved ergonomics around zero-downtime upgrade capabilities of StateFun applications, type system for messages and function state, as well as an extended array of new language SDKs.

Speaker:
Tzu-Li (Gordon) Tai – https://2021.berlinbuzzwords.de/member/tzu-li-gordon-tai

More: https://2021.berlinbuzzwords.de/session/stateful-functions-30-towards-cross-platform-stateful-serverless-stack
Captions: 
	00:00:07,040 --> 00:00:10,320
welcome

00:00:07,600 --> 00:00:11,040
to this talk um about stifle functions

00:00:10,320 --> 00:00:13,840
um

00:00:11,040 --> 00:00:14,160
this is as fabian already mentioned this

00:00:13,840 --> 00:00:16,400
is

00:00:14,160 --> 00:00:17,840
a sub project under the apache flink

00:00:16,400 --> 00:00:19,920
umbrella

00:00:17,840 --> 00:00:21,039
it's heading more or less in a new

00:00:19,920 --> 00:00:24,320
direction for

00:00:21,039 --> 00:00:27,519
what stream processing can be used for

00:00:24,320 --> 00:00:30,640
beyond data streaming analytics

00:00:27,519 --> 00:00:32,480
so we just released the 3.0 newest

00:00:30,640 --> 00:00:33,840
version of stateful functions with some

00:00:32,480 --> 00:00:35,840
major changes

00:00:33,840 --> 00:00:37,600
but this talk will be more or less a

00:00:35,840 --> 00:00:40,079
introductory talk for

00:00:37,600 --> 00:00:42,640
new users in general to give you an idea

00:00:40,079 --> 00:00:44,879
of what exactly still for functions is

00:00:42,640 --> 00:00:46,239
and because of we have around 20 minutes

00:00:44,879 --> 00:00:47,680
or 30 minutes or so

00:00:46,239 --> 00:00:49,600
so we wouldn't be able to go into too

00:00:47,680 --> 00:00:52,160
much into detail but

00:00:49,600 --> 00:00:53,520
the major takeaways would be you would

00:00:52,160 --> 00:00:56,879
know what a simple function

00:00:53,520 --> 00:00:58,000
application looks like and how you can

00:00:56,879 --> 00:01:01,359
maybe start

00:00:58,000 --> 00:01:04,400
with trying out po singing poc

00:01:01,359 --> 00:01:05,600
with stateful functions um you can just

00:01:04,400 --> 00:01:08,080
call me gordon

00:01:05,600 --> 00:01:08,720
um i'm currently a flink pmc member in

00:01:08,080 --> 00:01:11,920
the

00:01:08,720 --> 00:01:13,600
apache fling community and for the past

00:01:11,920 --> 00:01:17,520
few years i've been working on

00:01:13,600 --> 00:01:20,400
various areas in the flink project

00:01:17,520 --> 00:01:22,000
including ecosystem connectors the type

00:01:20,400 --> 00:01:23,759
sterilization stack

00:01:22,000 --> 00:01:26,000
upgradability of stateful streaming

00:01:23,759 --> 00:01:29,520
applications and most importantly

00:01:26,000 --> 00:01:31,200
um in the recent one or two years or so

00:01:29,520 --> 00:01:34,400
working on the staff of functions

00:01:31,200 --> 00:01:38,000
project exclusively

00:01:34,400 --> 00:01:40,640
okay um right

00:01:38,000 --> 00:01:41,200
so the agenda for today um we'll just be

00:01:40,640 --> 00:01:43,920
covering

00:01:41,200 --> 00:01:45,360
covering three major topics first of all

00:01:43,920 --> 00:01:47,439
is what exactly is

00:01:45,360 --> 00:01:49,360
stateful functions and the big idea

00:01:47,439 --> 00:01:51,520
behind it

00:01:49,360 --> 00:01:53,520
stuff functions is actually targeted

00:01:51,520 --> 00:01:54,399
towards more general application

00:01:53,520 --> 00:01:57,119
developers

00:01:54,399 --> 00:01:57,520
but this being the stock being in stream

00:01:57,119 --> 00:01:59,200
track

00:01:57,520 --> 00:02:00,880
it actually has some relevance with

00:01:59,200 --> 00:02:03,040
stream processing because

00:02:00,880 --> 00:02:04,320
we are borrowing some big ideas from

00:02:03,040 --> 00:02:07,840
stream processing

00:02:04,320 --> 00:02:10,560
into the application development space

00:02:07,840 --> 00:02:10,959
second of all we'll give we'll take a

00:02:10,560 --> 00:02:14,640
quick

00:02:10,959 --> 00:02:16,000
brief overview of what code you would

00:02:14,640 --> 00:02:16,879
write with a stateful function

00:02:16,000 --> 00:02:19,760
application

00:02:16,879 --> 00:02:21,120
and how you would maybe deploy it for

00:02:19,760 --> 00:02:23,760
quick examples

00:02:21,120 --> 00:02:24,480
and last of all we can take a quick

00:02:23,760 --> 00:02:27,120
overview

00:02:24,480 --> 00:02:29,040
of what you might be able to expect in

00:02:27,120 --> 00:02:31,519
some upcoming major versions let's say

00:02:29,040 --> 00:02:33,760
3.1 or 3.2

00:02:31,519 --> 00:02:35,360
but don't uh but it would be an

00:02:33,760 --> 00:02:36,080
estimation because this would all be

00:02:35,360 --> 00:02:39,280
based on

00:02:36,080 --> 00:02:40,000
what exactly some user feedback is

00:02:39,280 --> 00:02:42,959
asking for

00:02:40,000 --> 00:02:46,000
in the patch of link mailing lists for

00:02:42,959 --> 00:02:46,000
for stateful functions

00:02:46,160 --> 00:02:51,360
okay so let's start with what exactly is

00:02:49,280 --> 00:02:54,160
stateful functions

00:02:51,360 --> 00:02:56,400
if you've read our documentation before

00:02:54,160 --> 00:02:57,360
there is one very simple sentence to put

00:02:56,400 --> 00:03:00,879
it

00:02:57,360 --> 00:03:02,640
it is a stack consisting of various

00:03:00,879 --> 00:03:06,080
language sdks

00:03:02,640 --> 00:03:08,640
and a runtime for user developers

00:03:06,080 --> 00:03:09,519
for users to develop to more easily

00:03:08,640 --> 00:03:12,319
develop

00:03:09,519 --> 00:03:13,120
distributed stateful applications and

00:03:12,319 --> 00:03:15,840
also

00:03:13,120 --> 00:03:17,360
more easily operate these distributed

00:03:15,840 --> 00:03:20,239
stateful applications

00:03:17,360 --> 00:03:20,640
but what exactly does that mean um i

00:03:20,239 --> 00:03:24,159
think

00:03:20,640 --> 00:03:27,280
this would be most easiest to to explain

00:03:24,159 --> 00:03:30,319
by actually going through an overview of

00:03:27,280 --> 00:03:33,840
the architecture of what a stateful

00:03:30,319 --> 00:03:36,159
function application actually looks like

00:03:33,840 --> 00:03:37,280
so what is set for the functions say for

00:03:36,159 --> 00:03:40,239
functions well

00:03:37,280 --> 00:03:40,640
right off the bat you would build state

00:03:40,239 --> 00:03:43,760
fund

00:03:40,640 --> 00:03:45,920
applications using functions now these

00:03:43,760 --> 00:03:46,640
functions are essentially a small piece

00:03:45,920 --> 00:03:49,040
of logic

00:03:46,640 --> 00:03:50,319
that represents entities within your

00:03:49,040 --> 00:03:53,519
application

00:03:50,319 --> 00:03:55,439
now to to motivate this let's um

00:03:53,519 --> 00:03:56,560
the previous talk actually use a similar

00:03:55,439 --> 00:03:59,519
uh example

00:03:56,560 --> 00:04:00,159
so i think this is a good follow-up so

00:03:59,519 --> 00:04:01,760
let's say

00:04:00,159 --> 00:04:04,000
let's imagine you have a shopping cart

00:04:01,760 --> 00:04:05,599
application right and what entities

00:04:04,000 --> 00:04:06,879
would be for in this application you

00:04:05,599 --> 00:04:09,120
would have user cards

00:04:06,879 --> 00:04:10,239
you would have an inventory function and

00:04:09,120 --> 00:04:12,879
you might also have

00:04:10,239 --> 00:04:16,160
a fraud detection service in charge of

00:04:12,879 --> 00:04:18,400
detecting any fraudulent activities

00:04:16,160 --> 00:04:20,160
payment activities from from some user

00:04:18,400 --> 00:04:22,400
from some specific user

00:04:20,160 --> 00:04:23,520
right and let's say that this

00:04:22,400 --> 00:04:26,639
application

00:04:23,520 --> 00:04:29,440
sits behind some front-end web ui

00:04:26,639 --> 00:04:29,919
to actually drive these the shopping

00:04:29,440 --> 00:04:33,280
cart

00:04:29,919 --> 00:04:35,360
um back end now these

00:04:33,280 --> 00:04:37,440
individual functions it would be

00:04:35,360 --> 00:04:38,560
implemented with various language as the

00:04:37,440 --> 00:04:41,600
case

00:04:38,560 --> 00:04:45,600
now save a function provides

00:04:41,600 --> 00:04:49,440
officially supports two sdks one is java

00:04:45,600 --> 00:04:52,800
and one is python and these would be

00:04:49,440 --> 00:04:55,360
running behind standalone http services

00:04:52,800 --> 00:04:56,400
now i'll go through the code some code

00:04:55,360 --> 00:04:58,880
snippets

00:04:56,400 --> 00:05:00,639
in a sec to actually show you what that

00:04:58,880 --> 00:05:01,440
exactly means how to expose these

00:05:00,639 --> 00:05:04,320
functions

00:05:01,440 --> 00:05:04,720
through an actual http server but for

00:05:04,320 --> 00:05:06,479
now

00:05:04,720 --> 00:05:08,800
you just need to picture that these are

00:05:06,479 --> 00:05:11,759
your separate processes

00:05:08,800 --> 00:05:12,800
exposed exposing their functions and for

00:05:11,759 --> 00:05:15,680
function logic

00:05:12,800 --> 00:05:17,440
behind a http service endpoint that's

00:05:15,680 --> 00:05:20,720
all you need to know for the time being

00:05:17,440 --> 00:05:23,039
okay now to

00:05:20,720 --> 00:05:24,560
actually express your logic for your

00:05:23,039 --> 00:05:26,880
shopping cart application

00:05:24,560 --> 00:05:27,759
what you would do is actually define

00:05:26,880 --> 00:05:29,759
messages

00:05:27,759 --> 00:05:31,680
that are being passed from the outside

00:05:29,759 --> 00:05:34,479
world which is let's say our web

00:05:31,680 --> 00:05:35,199
front-end web ui into this application

00:05:34,479 --> 00:05:37,199
and also

00:05:35,199 --> 00:05:39,360
in between functions in between these

00:05:37,199 --> 00:05:42,320
entities of our application

00:05:39,360 --> 00:05:42,720
so let's picture that you have a web ui

00:05:42,320 --> 00:05:46,160
and

00:05:42,720 --> 00:05:49,280
the user the user clicks

00:05:46,160 --> 00:05:49,600
i want to add a specific item to let's

00:05:49,280 --> 00:05:52,720
say

00:05:49,600 --> 00:05:55,600
joe's user card okay joe does this

00:05:52,720 --> 00:05:57,440
he wants to add a pair of socks to to

00:05:55,600 --> 00:05:59,680
his card

00:05:57,440 --> 00:06:00,639
this event being sent to the user card

00:05:59,680 --> 00:06:04,880
function

00:06:00,639 --> 00:06:06,880
it would um resolve into

00:06:04,880 --> 00:06:08,880
several follow-up functions being sent

00:06:06,880 --> 00:06:10,960
from the user card to

00:06:08,880 --> 00:06:12,720
follow-up messages sorry from usercard

00:06:10,960 --> 00:06:15,520
to let's say the inventory function

00:06:12,720 --> 00:06:16,639
so let's say the usercard function of

00:06:15,520 --> 00:06:19,680
joe now sends

00:06:16,639 --> 00:06:22,160
a message to inventory function sucks

00:06:19,680 --> 00:06:22,800
but i want to reserve some amount of

00:06:22,160 --> 00:06:25,440
songs

00:06:22,800 --> 00:06:27,360
okay now the inventory function might do

00:06:25,440 --> 00:06:30,880
some things like it checks its

00:06:27,360 --> 00:06:34,479
state do i actually have enough quantity

00:06:30,880 --> 00:06:36,639
uh to to fulfill this reservation

00:06:34,479 --> 00:06:38,720
if i do i acknowledge this reservation

00:06:36,639 --> 00:06:40,720
send a message back to user joe

00:06:38,720 --> 00:06:42,080
and say okay you can go ahead and add

00:06:40,720 --> 00:06:45,520
this to your user card

00:06:42,080 --> 00:06:47,520
okay and let's imagine now that the web

00:06:45,520 --> 00:06:50,560
ui has a follow-up click event

00:06:47,520 --> 00:06:52,400
to say proceed to checkout

00:06:50,560 --> 00:06:54,479
this is sent to the user card function

00:06:52,400 --> 00:06:55,759
which in turn also sends an event a

00:06:54,479 --> 00:06:59,440
checkout event maybe

00:06:55,759 --> 00:07:01,440
to a fraud detection service

00:06:59,440 --> 00:07:02,800
to handle this specific checkout which

00:07:01,440 --> 00:07:06,560
might then

00:07:02,800 --> 00:07:09,759
result in this checkout

00:07:06,560 --> 00:07:10,639
succeeds or based on some user history

00:07:09,759 --> 00:07:13,759
activity

00:07:10,639 --> 00:07:17,199
for user joe this this payment

00:07:13,759 --> 00:07:18,319
is is not allowed so this is just a very

00:07:17,199 --> 00:07:21,680
oversimplified

00:07:18,319 --> 00:07:22,400
idea of what entities mean in in your

00:07:21,680 --> 00:07:25,840
application

00:07:22,400 --> 00:07:26,800
and how logic is is implemented via

00:07:25,840 --> 00:07:30,319
message parsing

00:07:26,800 --> 00:07:33,199
message passing okay now

00:07:30,319 --> 00:07:33,919
one thing we can already mention um with

00:07:33,199 --> 00:07:36,080
this

00:07:33,919 --> 00:07:39,120
we would even be more tangible once we

00:07:36,080 --> 00:07:40,800
see uh what the code looks like is that

00:07:39,120 --> 00:07:42,160
messaging between functions is

00:07:40,800 --> 00:07:44,000
completely transparent

00:07:42,160 --> 00:07:45,199
now what that means is we don't for

00:07:44,000 --> 00:07:46,800
example use the card

00:07:45,199 --> 00:07:48,240
function sending a message to the

00:07:46,800 --> 00:07:49,360
inventory function we don't need to know

00:07:48,240 --> 00:07:51,599
the physical

00:07:49,360 --> 00:07:53,039
address of the inventory function where

00:07:51,599 --> 00:07:55,360
it is actually deployed

00:07:53,039 --> 00:07:56,720
we just need to know the logical address

00:07:55,360 --> 00:07:59,440
of

00:07:56,720 --> 00:08:00,879
where we want our messages to be sent to

00:07:59,440 --> 00:08:03,599
so

00:08:00,879 --> 00:08:05,759
application developers of let's have a

00:08:03,599 --> 00:08:08,639
user card function you just need to know

00:08:05,759 --> 00:08:09,599
the logical address which is consists of

00:08:08,639 --> 00:08:13,039
two information

00:08:09,599 --> 00:08:15,759
one is the type of a function the second

00:08:13,039 --> 00:08:16,400
is the id of the instance of that

00:08:15,759 --> 00:08:18,560
function

00:08:16,400 --> 00:08:20,000
it wants to invoke okay so in this

00:08:18,560 --> 00:08:22,800
example

00:08:20,000 --> 00:08:23,440
one logical address would be inventory

00:08:22,800 --> 00:08:25,199
socks

00:08:23,440 --> 00:08:26,639
and stocks being the id and inventory

00:08:25,199 --> 00:08:28,160
being the type of function

00:08:26,639 --> 00:08:30,560
that is a logical address and that is

00:08:28,160 --> 00:08:32,640
all you need to know in order to send

00:08:30,560 --> 00:08:34,640
a message to another function okay so

00:08:32,640 --> 00:08:36,320
every over routing of the messages is

00:08:34,640 --> 00:08:39,599
completely transparent

00:08:36,320 --> 00:08:42,000
in user code space

00:08:39,599 --> 00:08:43,680
now the next uh which you might have

00:08:42,000 --> 00:08:44,320
already observed is that this whole

00:08:43,680 --> 00:08:46,959
logic

00:08:44,320 --> 00:08:47,920
is it is stateful right for computation

00:08:46,959 --> 00:08:50,320
is stateful

00:08:47,920 --> 00:08:51,839
for example the user card the state is

00:08:50,320 --> 00:08:54,399
obviously

00:08:51,839 --> 00:08:55,680
what items are already reserved in a

00:08:54,399 --> 00:08:58,080
user's cart

00:08:55,680 --> 00:08:58,800
and for the inventory function the state

00:08:58,080 --> 00:09:02,320
would be

00:08:58,800 --> 00:09:03,680
how many um socks how many how many of

00:09:02,320 --> 00:09:06,399
each inventory do i have

00:09:03,680 --> 00:09:08,000
for each uh do i have left right i have

00:09:06,399 --> 00:09:11,279
a fraud detection function

00:09:08,000 --> 00:09:14,640
for state it could be the history

00:09:11,279 --> 00:09:17,360
of user activity okay so this

00:09:14,640 --> 00:09:19,120
is the state of this application now

00:09:17,360 --> 00:09:19,519
this is where things gets interesting

00:09:19,120 --> 00:09:22,560
right

00:09:19,519 --> 00:09:25,040
because we all know um that

00:09:22,560 --> 00:09:25,920
handling distributed applications with

00:09:25,040 --> 00:09:29,760
state

00:09:25,920 --> 00:09:33,120
it gets much much more complex beyond

00:09:29,760 --> 00:09:34,959
is as if if it were stateless right

00:09:33,120 --> 00:09:36,959
now to actually explain how staple

00:09:34,959 --> 00:09:38,399
functions handles this for the user so

00:09:36,959 --> 00:09:40,160
that is completely transparent

00:09:38,399 --> 00:09:42,320
and the user does not need to worry

00:09:40,160 --> 00:09:43,920
about it the application developer does

00:09:42,320 --> 00:09:46,959
not need to worry about it

00:09:43,920 --> 00:09:50,240
i want to slightly branch out a bit

00:09:46,959 --> 00:09:51,200
into this slide here so let's quickly go

00:09:50,240 --> 00:09:54,880
through how

00:09:51,200 --> 00:09:56,959
normally um nowadays for applications

00:09:54,880 --> 00:09:59,440
how do they actually handle messaging

00:09:56,959 --> 00:10:01,040
and consistency of state

00:09:59,440 --> 00:10:04,560
so let's say you have an application

00:10:01,040 --> 00:10:06,640
which this this diagram is just

00:10:04,560 --> 00:10:08,399
a abstraction of what we're going

00:10:06,640 --> 00:10:10,720
through with our shopping cart where

00:10:08,399 --> 00:10:12,720
one application might be broken up into

00:10:10,720 --> 00:10:14,880
several independent services

00:10:12,720 --> 00:10:16,079
and each service would have their own

00:10:14,880 --> 00:10:18,720
database

00:10:16,079 --> 00:10:19,760
to to maintain the state of that

00:10:18,720 --> 00:10:22,880
individual service

00:10:19,760 --> 00:10:26,800
right and when one service gets invoked

00:10:22,880 --> 00:10:29,279
it could do a few separate a few um

00:10:26,800 --> 00:10:29,839
several things for one it could update

00:10:29,279 --> 00:10:32,640
its own

00:10:29,839 --> 00:10:33,680
state in the database second it might

00:10:32,640 --> 00:10:35,680
invoke

00:10:33,680 --> 00:10:36,959
another service to receive some

00:10:35,680 --> 00:10:39,519
information

00:10:36,959 --> 00:10:40,079
and invoking that other service it might

00:10:39,519 --> 00:10:42,560
in turn

00:10:40,079 --> 00:10:43,440
also let that service update its own

00:10:42,560 --> 00:10:46,079
state

00:10:43,440 --> 00:10:47,519
okay so it's pretty straightforward and

00:10:46,079 --> 00:10:49,680
this is nice because

00:10:47,519 --> 00:10:51,200
in the computer what happens in this

00:10:49,680 --> 00:10:54,000
architecture is that in the

00:10:51,200 --> 00:10:54,720
computer it doesn't contain any state

00:10:54,000 --> 00:10:59,440
state is

00:10:54,720 --> 00:11:01,360
all kept in the database layer

00:10:59,440 --> 00:11:03,200
but of course we know that in reality

00:11:01,360 --> 00:11:05,440
it's never just that simple

00:11:03,200 --> 00:11:06,880
it gets much more complex when you start

00:11:05,440 --> 00:11:09,839
considering

00:11:06,880 --> 00:11:10,399
what happens in the case of some failure

00:11:09,839 --> 00:11:13,279
right

00:11:10,399 --> 00:11:14,880
let's say the message invocation from

00:11:13,279 --> 00:11:18,079
service 1 to service 2

00:11:14,880 --> 00:11:19,279
actually fails now what exactly do the

00:11:18,079 --> 00:11:21,760
application tier

00:11:19,279 --> 00:11:22,720
needs to consider now for example

00:11:21,760 --> 00:11:26,079
application 1

00:11:22,720 --> 00:11:28,399
it needs to consider should i re

00:11:26,079 --> 00:11:31,360
should i read send a send a nervous

00:11:28,399 --> 00:11:33,760
retry request to application 2.

00:11:31,360 --> 00:11:34,800
if i do that does application 2 actually

00:11:33,760 --> 00:11:38,079
handle

00:11:34,800 --> 00:11:41,200
this duplicate invocations

00:11:38,079 --> 00:11:42,560
item potent and this is all concerns

00:11:41,200 --> 00:11:46,480
that needs to be considered

00:11:42,560 --> 00:11:49,920
that makes this scenario more complex

00:11:46,480 --> 00:11:52,959
than we really wanted to be right

00:11:49,920 --> 00:11:53,519
now this is the point where safer

00:11:52,959 --> 00:11:56,800
functions

00:11:53,519 --> 00:11:58,800
is actually a technique that

00:11:56,800 --> 00:11:59,839
we've been using in stream processing

00:11:58,800 --> 00:12:04,639
for several years

00:11:59,839 --> 00:12:08,720
up to now already which is bundling

00:12:04,639 --> 00:12:11,920
handling messaging and state updates

00:12:08,720 --> 00:12:15,200
coherently within a single system

00:12:11,920 --> 00:12:16,320
okay so that's the basic idea um so you

00:12:15,200 --> 00:12:18,639
can picture this

00:12:16,320 --> 00:12:20,240
let's say we hand over message not in

00:12:18,639 --> 00:12:22,800
the application tier

00:12:20,240 --> 00:12:24,959
but actually and let me actually see if

00:12:22,800 --> 00:12:27,360
i can bring out my laser pointer

00:12:24,959 --> 00:12:29,360
so we don't have we don't handle the

00:12:27,360 --> 00:12:31,040
messaging in the computer but we handle

00:12:29,360 --> 00:12:34,399
it in the storage tier

00:12:31,040 --> 00:12:34,880
now what that means is um abstraction

00:12:34,399 --> 00:12:36,160
wise

00:12:34,880 --> 00:12:38,240
what that means is let's say one

00:12:36,160 --> 00:12:40,560
database handles the input event

00:12:38,240 --> 00:12:41,360
it knows that this input event should be

00:12:40,560 --> 00:12:44,800
routed to

00:12:41,360 --> 00:12:46,720
some service computer compute process

00:12:44,800 --> 00:12:48,639
now with this routing of that input

00:12:46,720 --> 00:12:52,079
message to that service

00:12:48,639 --> 00:12:54,959
it also carries state that is relevant

00:12:52,079 --> 00:12:56,079
for that specific input event okay now

00:12:54,959 --> 00:12:58,639
the computer

00:12:56,079 --> 00:12:59,600
receives the message and the state that

00:12:58,639 --> 00:13:01,920
goes with it

00:12:59,600 --> 00:13:04,000
it does a few things it has some side

00:13:01,920 --> 00:13:06,320
effects these side effects

00:13:04,000 --> 00:13:08,000
more concretely concretely speaking it

00:13:06,320 --> 00:13:09,279
would be updating maybe updating the

00:13:08,000 --> 00:13:12,000
state and also

00:13:09,279 --> 00:13:13,040
sending also some um extra outgoing

00:13:12,000 --> 00:13:15,680
messages

00:13:13,040 --> 00:13:16,560
or invoking other other applications

00:13:15,680 --> 00:13:18,839
okay

00:13:16,560 --> 00:13:20,000
all of the side effect is encoded

00:13:18,839 --> 00:13:22,880
embodied

00:13:20,000 --> 00:13:24,240
in the response of this computer sent

00:13:22,880 --> 00:13:27,600
back to the database layer

00:13:24,240 --> 00:13:30,160
and the database layer handles this

00:13:27,600 --> 00:13:31,760
outgoing messages and state updates of

00:13:30,160 --> 00:13:35,600
this service atomically

00:13:31,760 --> 00:13:37,920
it sends it to the other database uh for

00:13:35,600 --> 00:13:38,880
service two to be handled and let's say

00:13:37,920 --> 00:13:41,279
now something

00:13:38,880 --> 00:13:42,320
happens in between an error also still

00:13:41,279 --> 00:13:44,720
occurs right

00:13:42,320 --> 00:13:46,240
if that occurs everything is rolled back

00:13:44,720 --> 00:13:49,920
to a consistent point in time

00:13:46,240 --> 00:13:51,120
before and we re-invoke from that

00:13:49,920 --> 00:13:54,639
consistent point of time

00:13:51,120 --> 00:13:57,920
re-invoke each individual service okay

00:13:54,639 --> 00:13:59,920
now because each invocation

00:13:57,920 --> 00:14:02,240
from the database to the service layer

00:13:59,920 --> 00:14:04,240
is now encapsulated

00:14:02,240 --> 00:14:05,519
encapsulated meaning that the recast

00:14:04,240 --> 00:14:08,079
contains everything

00:14:05,519 --> 00:14:09,600
the computation needs and response

00:14:08,079 --> 00:14:12,959
contains oversight effects

00:14:09,600 --> 00:14:16,000
this retry is effectively idempotent

00:14:12,959 --> 00:14:18,320
so this is the big idea might sound very

00:14:16,000 --> 00:14:19,440
complicated but this is all handled by

00:14:18,320 --> 00:14:21,760
safer functions

00:14:19,440 --> 00:14:23,360
so that the computer does not need to

00:14:21,760 --> 00:14:26,160
worry about a failures at

00:14:23,360 --> 00:14:27,839
all in the application code and this

00:14:26,160 --> 00:14:30,079
exactly is the approach that circle

00:14:27,839 --> 00:14:31,839
functions is taking with what

00:14:30,079 --> 00:14:34,560
distributed stable application

00:14:31,839 --> 00:14:35,760
architecture should look like so apart

00:14:34,560 --> 00:14:39,040
from the separate

00:14:35,760 --> 00:14:41,360
function processes we also have now

00:14:39,040 --> 00:14:43,120
a state fund cluster and this system

00:14:41,360 --> 00:14:45,680
cluster is in charge of messaging

00:14:43,120 --> 00:14:47,360
and state handling okay and because

00:14:45,680 --> 00:14:48,320
we're borrowing a lot of techniques from

00:14:47,360 --> 00:14:50,480
stream processing

00:14:48,320 --> 00:14:53,600
the runtime of safer functions is built

00:14:50,480 --> 00:14:55,920
exactly on top of apache flink

00:14:53,600 --> 00:14:57,199
and as i mentioned or messages sent to

00:14:55,920 --> 00:14:58,720
and from functions

00:14:57,199 --> 00:15:00,399
as well as functions they can use a

00:14:58,720 --> 00:15:03,279
routed throughput cluster using the

00:15:00,399 --> 00:15:05,040
simple http request reply protocol

00:15:03,279 --> 00:15:06,880
now this protocol makes sure that the

00:15:05,040 --> 00:15:09,519
computer these functions

00:15:06,880 --> 00:15:10,720
still remain stateless or be able to do

00:15:09,519 --> 00:15:14,079
stateless

00:15:10,720 --> 00:15:15,519
stateful logic okay now

00:15:14,079 --> 00:15:18,240
if you come from flink you would also

00:15:15,519 --> 00:15:20,560
know that uh with stream processing

00:15:18,240 --> 00:15:22,399
handle these interactions between

00:15:20,560 --> 00:15:24,560
services as a data flow

00:15:22,399 --> 00:15:26,560
we we no longer need a database to

00:15:24,560 --> 00:15:28,639
actually provide this consistency

00:15:26,560 --> 00:15:30,959
and durability what therefore function

00:15:28,639 --> 00:15:33,360
actually does is that periodically

00:15:30,959 --> 00:15:34,800
and asynchronously it snapshots

00:15:33,360 --> 00:15:37,120
overstayed across

00:15:34,800 --> 00:15:38,639
all the functions consistently to mass

00:15:37,120 --> 00:15:40,560
storage let's say aws

00:15:38,639 --> 00:15:42,480
as free okay so this is done

00:15:40,560 --> 00:15:44,320
periodically now

00:15:42,480 --> 00:15:46,240
what is really really cool here is that

00:15:44,320 --> 00:15:47,120
out of box we have messaging and state

00:15:46,240 --> 00:15:50,720
consistency

00:15:47,120 --> 00:15:52,399
as if all messages are processed exactly

00:15:50,720 --> 00:15:55,600
once by all services

00:15:52,399 --> 00:15:57,600
as if there were no failures and there

00:15:55,600 --> 00:15:58,399
is no database intervening in this

00:15:57,600 --> 00:16:01,519
architecture

00:15:58,399 --> 00:16:02,160
so this is pretty nice now for the

00:16:01,519 --> 00:16:05,120
remaining

00:16:02,160 --> 00:16:06,560
uh oh sorry one last thing is that uh we

00:16:05,120 --> 00:16:08,000
also mentioned that the invocation

00:16:06,560 --> 00:16:10,480
itself this protocol

00:16:08,000 --> 00:16:12,880
makes the computer remain stateless

00:16:10,480 --> 00:16:15,920
right operation-wise it is stateless

00:16:12,880 --> 00:16:17,759
so operation is very flexible function

00:16:15,920 --> 00:16:20,079
deployments are stateless processes

00:16:17,759 --> 00:16:21,680
so it is still straightforward to deploy

00:16:20,079 --> 00:16:23,360
and elastically scale them

00:16:21,680 --> 00:16:25,920
on any modern cloud native

00:16:23,360 --> 00:16:28,959
infrastructure so kubernetes

00:16:25,920 --> 00:16:29,680
api gateways or on some functional

00:16:28,959 --> 00:16:32,399
service

00:16:29,680 --> 00:16:32,959
popular functionality service let's say

00:16:32,399 --> 00:16:35,759
um

00:16:32,959 --> 00:16:37,519
aws lumber okay and it's super easy to

00:16:35,759 --> 00:16:38,399
do rolling upgrades of these individual

00:16:37,519 --> 00:16:40,160
functions

00:16:38,399 --> 00:16:41,920
and also adding new functions to the

00:16:40,160 --> 00:16:44,160
application as we have a new service

00:16:41,920 --> 00:16:46,000
that needs to participate in the logic

00:16:44,160 --> 00:16:48,320
and existing functions need to start

00:16:46,000 --> 00:16:49,759
sending messages to that new function

00:16:48,320 --> 00:16:51,920
all this can be done without any

00:16:49,759 --> 00:16:54,720
downtime with the state phone cluster

00:16:51,920 --> 00:16:56,160
which is super nice okay so you still

00:16:54,720 --> 00:16:58,480
retain the benefits of

00:16:56,160 --> 00:16:59,839
what a serve what a stateless

00:16:58,480 --> 00:17:02,320
application look like

00:16:59,839 --> 00:17:03,440
but with the safe and cluster in place

00:17:02,320 --> 00:17:05,919
now

00:17:03,440 --> 00:17:06,799
actually having stateful logic is much

00:17:05,919 --> 00:17:10,000
more easier to

00:17:06,799 --> 00:17:13,120
to maintain so for the remaining

00:17:10,000 --> 00:17:14,319
um five minutes or so i want to quickly

00:17:13,120 --> 00:17:17,679
skim through

00:17:14,319 --> 00:17:19,039
what code function code would look like

00:17:17,679 --> 00:17:21,520
and what you would need to do to

00:17:19,039 --> 00:17:25,439
actually deploy your application

00:17:21,520 --> 00:17:27,839
so again an overview as a developer

00:17:25,439 --> 00:17:29,840
you would write several functions and

00:17:27,839 --> 00:17:32,640
you would also

00:17:29,840 --> 00:17:34,320
run the statement cluster to help manage

00:17:32,640 --> 00:17:35,600
your messaging and sit between all of

00:17:34,320 --> 00:17:37,600
these functions

00:17:35,600 --> 00:17:39,520
so one thing you would do is develop

00:17:37,600 --> 00:17:42,640
functions using a language sdk

00:17:39,520 --> 00:17:43,360
okay so without going too much into

00:17:42,640 --> 00:17:45,520
detail

00:17:43,360 --> 00:17:46,799
you can see here that this is the java

00:17:45,520 --> 00:17:48,640
sdk but

00:17:46,799 --> 00:17:49,840
python sdk side would be almost

00:17:48,640 --> 00:17:53,840
identical to

00:17:49,840 --> 00:17:53,840
to this in terms of concepts and

00:17:54,000 --> 00:17:57,760
syntax wise it also looks pretty similar

00:17:56,799 --> 00:17:59,280
so

00:17:57,760 --> 00:18:01,760
you would receive a message and you

00:17:59,280 --> 00:18:03,120
would see whether or not it is a message

00:18:01,760 --> 00:18:05,120
it's let's say we're looking at the

00:18:03,120 --> 00:18:06,320
inventory function now and the inventory

00:18:05,120 --> 00:18:08,960
function from our

00:18:06,320 --> 00:18:10,480
data flow that we just described is it

00:18:08,960 --> 00:18:12,000
expecting reserve messages

00:18:10,480 --> 00:18:14,799
if it isn't then something must have

00:18:12,000 --> 00:18:16,559
been wrong okay so referral basically

00:18:14,799 --> 00:18:18,799
will say the exception

00:18:16,559 --> 00:18:19,600
otherwise it should be a reserve if it

00:18:18,799 --> 00:18:21,679
is a reserve

00:18:19,600 --> 00:18:22,960
we access our state now from the

00:18:21,679 --> 00:18:25,039
function code

00:18:22,960 --> 00:18:27,039
user space it would be as if you would

00:18:25,039 --> 00:18:29,280
actually be working with a storage

00:18:27,039 --> 00:18:31,039
to process to to manipulate and store

00:18:29,280 --> 00:18:31,760
your state but of course we know that

00:18:31,039 --> 00:18:34,000
this storage

00:18:31,760 --> 00:18:37,120
actually is on the staple function site

00:18:34,000 --> 00:18:39,520
nothing is readily cached or maintained

00:18:37,120 --> 00:18:40,880
as state in the computer of the function

00:18:39,520 --> 00:18:43,600
side okay

00:18:40,880 --> 00:18:45,120
so you would access storage now here is

00:18:43,600 --> 00:18:47,600
called address scope storage

00:18:45,120 --> 00:18:48,559
meaning that let's say this invocation

00:18:47,600 --> 00:18:52,240
is actually for

00:18:48,559 --> 00:18:53,760
inventory socks which is the id socks

00:18:52,240 --> 00:18:56,080
what you would see in the storage is

00:18:53,760 --> 00:18:59,200
specifically for the infantry stocks

00:18:56,080 --> 00:19:01,840
so you would see okay i still have x

00:18:59,200 --> 00:19:03,039
number of stocks inventory i do a check

00:19:01,840 --> 00:19:06,400
of the stock and reserve

00:19:03,039 --> 00:19:09,280
and maybe also update the storage

00:19:06,400 --> 00:19:10,799
that i have left in this in this for

00:19:09,280 --> 00:19:14,080
stocks

00:19:10,799 --> 00:19:15,280
and after this stateful logic you would

00:19:14,080 --> 00:19:18,000
do

00:19:15,280 --> 00:19:20,320
um you want to send back a message to

00:19:18,000 --> 00:19:22,720
the caller which is the user function

00:19:20,320 --> 00:19:23,440
which which send out this reservation

00:19:22,720 --> 00:19:26,559
say okay

00:19:23,440 --> 00:19:27,440
um this is the acknowledgement of your

00:19:26,559 --> 00:19:30,000
reserve

00:19:27,440 --> 00:19:31,200
um go ahead right now here i'm

00:19:30,000 --> 00:19:34,000
simplifying things

00:19:31,200 --> 00:19:35,280
uh the address the destination address

00:19:34,000 --> 00:19:37,919
of this message

00:19:35,280 --> 00:19:39,679
is the caller of this co of this of this

00:19:37,919 --> 00:19:40,480
implication which would be that user

00:19:39,679 --> 00:19:42,640
function right

00:19:40,480 --> 00:19:44,480
but you could you could also do um

00:19:42,640 --> 00:19:45,360
address this directly using logical

00:19:44,480 --> 00:19:47,360
addresses to

00:19:45,360 --> 00:19:49,520
let's say another new function just like

00:19:47,360 --> 00:19:50,160
i said using a function type and also

00:19:49,520 --> 00:19:51,919
the id

00:19:50,160 --> 00:19:54,720
of that function instance you're trying

00:19:51,919 --> 00:19:57,360
to invoke okay

00:19:54,720 --> 00:19:58,880
now last of all after you've implemented

00:19:57,360 --> 00:20:02,000
the stateful function

00:19:58,880 --> 00:20:04,559
um you would you would want to expose

00:20:02,000 --> 00:20:05,360
this function via some http service

00:20:04,559 --> 00:20:08,480
right

00:20:05,360 --> 00:20:10,720
so it's also pretty simple um

00:20:08,480 --> 00:20:13,360
for each function that you want to

00:20:10,720 --> 00:20:15,200
participate in this specific service

00:20:13,360 --> 00:20:16,799
you would do inventory you would you

00:20:15,200 --> 00:20:19,200
would define a stable function

00:20:16,799 --> 00:20:20,240
spec specs defines a few things

00:20:19,200 --> 00:20:23,520
including

00:20:20,240 --> 00:20:25,360
what state participates for this

00:20:23,520 --> 00:20:26,640
specific function what i what said i

00:20:25,360 --> 00:20:29,840
want to be declared

00:20:26,640 --> 00:20:29,840
and also how to

00:20:30,559 --> 00:20:34,400
create new instances of this of this

00:20:33,200 --> 00:20:36,559
inventory function

00:20:34,400 --> 00:20:38,559
okay you will register the spec with a

00:20:36,559 --> 00:20:40,720
save for functions registry

00:20:38,559 --> 00:20:42,880
which in turn provides you with a

00:20:40,720 --> 00:20:43,840
request reply handler now this handler

00:20:42,880 --> 00:20:46,080
is

00:20:43,840 --> 00:20:47,039
where the request reply protocol which i

00:20:46,080 --> 00:20:50,000
mentioned before

00:20:47,039 --> 00:20:52,159
is actually implemented okay you could

00:20:50,000 --> 00:20:52,640
you just need to expose this handler

00:20:52,159 --> 00:20:55,200
with

00:20:52,640 --> 00:20:56,400
an http server start the server and now

00:20:55,200 --> 00:20:58,559
you have a function

00:20:56,400 --> 00:21:00,720
that is invokable from cellphone

00:20:58,559 --> 00:21:03,200
function the save a function cluster

00:21:00,720 --> 00:21:04,640
now the next step obviously would be to

00:21:03,200 --> 00:21:06,640
actually make this visible

00:21:04,640 --> 00:21:07,679
in the cellphone cluster right and the

00:21:06,640 --> 00:21:10,159
way you would do that

00:21:07,679 --> 00:21:11,039
is compose a module specification yaml

00:21:10,159 --> 00:21:15,760
file

00:21:11,039 --> 00:21:18,880
um to a specific

00:21:15,760 --> 00:21:19,919
specification yammer file to define the

00:21:18,880 --> 00:21:22,559
service endpoints

00:21:19,919 --> 00:21:24,240
of the participating functions okay so

00:21:22,559 --> 00:21:27,120
that's the second step

00:21:24,240 --> 00:21:28,880
now this is just a example of what that

00:21:27,120 --> 00:21:32,400
yaml file might look like

00:21:28,880 --> 00:21:33,760
you define endpoints and one endpoint

00:21:32,400 --> 00:21:36,960
would be this thing

00:21:33,760 --> 00:21:38,720
so you would say all functions oh by the

00:21:36,960 --> 00:21:40,960
way something that i might have not

00:21:38,720 --> 00:21:42,000
been clear about clear about before is

00:21:40,960 --> 00:21:44,960
that all functions

00:21:42,000 --> 00:21:46,720
are identified by a namespace and a name

00:21:44,960 --> 00:21:48,960
so for example

00:21:46,720 --> 00:21:52,159
this infantry function here it is

00:21:48,960 --> 00:21:53,760
identified by the namespace com.my.org

00:21:52,159 --> 00:21:56,400
and then the name of function is called

00:21:53,760 --> 00:21:59,440
inventory okay so it has namespace

00:21:56,400 --> 00:21:59,840
and a name now the way you would define

00:21:59,440 --> 00:22:03,760
this

00:21:59,840 --> 00:22:05,600
in the yaml spec is so all functions

00:22:03,760 --> 00:22:09,679
under this specific namespace

00:22:05,600 --> 00:22:12,960
should go to this url with a templated

00:22:09,679 --> 00:22:13,520
format so this actually works quite nice

00:22:12,960 --> 00:22:17,360
with

00:22:13,520 --> 00:22:20,480
some um for example nginx or let's say

00:22:17,360 --> 00:22:22,559
um aws api gateway where you can now

00:22:20,480 --> 00:22:23,679
dynamically add functions under a given

00:22:22,559 --> 00:22:26,640
namespace

00:22:23,679 --> 00:22:27,520
if you actually still need to add new

00:22:26,640 --> 00:22:30,000
name spaces

00:22:27,520 --> 00:22:31,120
to your application you still need to

00:22:30,000 --> 00:22:32,880
restart

00:22:31,120 --> 00:22:34,799
your save for function cluster because

00:22:32,880 --> 00:22:37,760
this is where this yaml

00:22:34,799 --> 00:22:38,480
would need to be provided it needs

00:22:37,760 --> 00:22:40,080
that's

00:22:38,480 --> 00:22:42,240
it needs to be provided to the safer

00:22:40,080 --> 00:22:45,200
function cluster

00:22:42,240 --> 00:22:46,159
but under um non-changing constant

00:22:45,200 --> 00:22:48,159
namespaces

00:22:46,159 --> 00:22:49,520
you can just add functions into your

00:22:48,159 --> 00:22:51,919
application as you

00:22:49,520 --> 00:22:54,400
as you wish okay so this all is always

00:22:51,919 --> 00:22:56,720
dynamic without any downtime on the save

00:22:54,400 --> 00:22:58,720
for function cluster

00:22:56,720 --> 00:23:00,400
and that best match is basically it

00:22:58,720 --> 00:23:02,720
there is some more details

00:23:00,400 --> 00:23:04,159
on also how to define ingresses and

00:23:02,720 --> 00:23:07,520
egresses for your functions

00:23:04,159 --> 00:23:08,000
but this is the majority of what the

00:23:07,520 --> 00:23:10,400
application

00:23:08,000 --> 00:23:11,280
developer for stateful functions um

00:23:10,400 --> 00:23:13,280
would need to

00:23:11,280 --> 00:23:14,400
develop functions and then configure the

00:23:13,280 --> 00:23:17,520
statement cluster

00:23:14,400 --> 00:23:18,960
to be able to connect to these function

00:23:17,520 --> 00:23:21,360
endpoints

00:23:18,960 --> 00:23:22,080
so finally uh just very quickly let's go

00:23:21,360 --> 00:23:25,679
through a future

00:23:22,080 --> 00:23:28,400
roadmap um right now

00:23:25,679 --> 00:23:30,320
uh one thing that i find most important

00:23:28,400 --> 00:23:33,120
is actually providing ideals

00:23:30,320 --> 00:23:34,000
or interface to finish languages for

00:23:33,120 --> 00:23:35,919
functions

00:23:34,000 --> 00:23:37,919
right now as you can see it's based on

00:23:35,919 --> 00:23:39,919
just raw message passing

00:23:37,919 --> 00:23:41,919
from functions to other functions it

00:23:39,919 --> 00:23:43,360
would be nice if we actually have some

00:23:41,919 --> 00:23:46,240
ideas in place

00:23:43,360 --> 00:23:47,600
to provide a more easily understandable

00:23:46,240 --> 00:23:50,159
abstraction

00:23:47,600 --> 00:23:51,120
of how functions or services interact

00:23:50,159 --> 00:23:53,360
with each other

00:23:51,120 --> 00:23:55,679
right you can think of this more or less

00:23:53,360 --> 00:23:59,120
somewhat similar to what grpc provides

00:23:55,679 --> 00:24:02,480
like you can just write an idl with text

00:23:59,120 --> 00:24:04,880
and that automatically generates uh

00:24:02,480 --> 00:24:05,520
the server code for you this is somewhat

00:24:04,880 --> 00:24:07,840
um

00:24:05,520 --> 00:24:09,679
what we're thinking about in terms of

00:24:07,840 --> 00:24:12,640
making it easier to develop

00:24:09,679 --> 00:24:14,799
simple function applications and also

00:24:12,640 --> 00:24:17,679
more higher level messaging primitives

00:24:14,799 --> 00:24:18,000
this goes hand in hand with the idls

00:24:17,679 --> 00:24:19,840
right

00:24:18,000 --> 00:24:22,320
now it is just one asynchronous fire and

00:24:19,840 --> 00:24:23,840
forget messages between functions but

00:24:22,320 --> 00:24:25,360
i'm thinking about actually expanding

00:24:23,840 --> 00:24:27,840
that a bit more and

00:24:25,360 --> 00:24:30,159
also very importantly is to introduce

00:24:27,840 --> 00:24:32,960
more language sdks into

00:24:30,159 --> 00:24:33,760
the what we currently provide um we

00:24:32,960 --> 00:24:36,000
already have

00:24:33,760 --> 00:24:38,080
already have a golang sdk on the

00:24:36,000 --> 00:24:41,279
pipeline um to be contributed

00:24:38,080 --> 00:24:42,559
and may be available in the upcoming

00:24:41,279 --> 00:24:46,240
release

00:24:42,559 --> 00:24:46,640
okay um i oh one last thing uh here are

00:24:46,240 --> 00:24:49,600
some

00:24:46,640 --> 00:24:51,520
links i'm pretty sure that the this uh

00:24:49,600 --> 00:24:54,880
slides would be available to download

00:24:51,520 --> 00:24:57,200
after uh the conference so here are some

00:24:54,880 --> 00:24:58,880
links for you to check out if you want

00:24:57,200 --> 00:25:00,799
to further understand what

00:24:58,880 --> 00:25:01,919
read about therefore functions i would

00:25:00,799 --> 00:25:03,760
personally

00:25:01,919 --> 00:25:06,159
recommend starting with the tutorials

00:25:03,760 --> 00:25:07,679
examples at the flink statement

00:25:06,159 --> 00:25:10,720
playground repository

00:25:07,679 --> 00:25:13,200
there's a lot of examples there for

00:25:10,720 --> 00:25:14,559
patterns of how you would design staple

00:25:13,200 --> 00:25:15,840
function applications

00:25:14,559 --> 00:25:18,320
and also for example how you would

00:25:15,840 --> 00:25:19,679
deploy on let's say aws under or

00:25:18,320 --> 00:25:24,960
kubernetes

00:25:19,679 --> 00:25:24,960
okay i think that covers up this talk

00:25:26,159 --> 00:25:29,679
and thank you i don't think we have um

00:25:28,320 --> 00:25:32,080
time for questions but um

00:25:29,679 --> 00:25:34,720
i'm pretty excited to hear from you in

00:25:32,080 --> 00:25:36,400
the breakout session

00:25:34,720 --> 00:25:38,080
currently there are also not no

00:25:36,400 --> 00:25:39,679
questions from the audience yet

00:25:38,080 --> 00:25:41,120
but let's give them a little bit of time

00:25:39,679 --> 00:25:44,240
um so

00:25:41,120 --> 00:25:45,360
what kind of use cases is this um can

00:25:44,240 --> 00:25:46,080
you talk a little bit more about the use

00:25:45,360 --> 00:25:48,640
cases that

00:25:46,080 --> 00:25:49,200
this uh framework is designed for are

00:25:48,640 --> 00:25:51,520
they

00:25:49,200 --> 00:25:52,720
are you aware of any users or projects

00:25:51,520 --> 00:25:54,960
that have that that are

00:25:52,720 --> 00:25:56,480
being built with the stapler functions

00:25:54,960 --> 00:26:00,000
yeah one thing i can

00:25:56,480 --> 00:26:03,120
confidently say about is it is a natural

00:26:00,000 --> 00:26:06,640
match for um that's a digital twin

00:26:03,120 --> 00:26:08,480
pattern type of applications um in this

00:26:06,640 --> 00:26:10,320
in the shopping cart scenario that is

00:26:08,480 --> 00:26:14,240
one example of what a digital twin

00:26:10,320 --> 00:26:17,039
means right you would have a entity

00:26:14,240 --> 00:26:17,840
which is a function a user or inventory

00:26:17,039 --> 00:26:19,760
or let's say

00:26:17,840 --> 00:26:21,840
it's a ride sharing application you

00:26:19,760 --> 00:26:24,159
would have a ride coordinator you had a

00:26:21,840 --> 00:26:25,039
driver tracking the locations all of

00:26:24,159 --> 00:26:27,919
this

00:26:25,039 --> 00:26:29,039
it's a pretty natural programming match

00:26:27,919 --> 00:26:31,120
model wise

00:26:29,039 --> 00:26:32,400
for central function applications and

00:26:31,120 --> 00:26:39,840
it's also what we're seeing

00:26:32,400 --> 00:26:39,840
quite a lot for our first few users

00:26:56,400 --> 00:26:58,480

YouTube URL: https://www.youtube.com/watch?v=vw0q4Sm4XvI


