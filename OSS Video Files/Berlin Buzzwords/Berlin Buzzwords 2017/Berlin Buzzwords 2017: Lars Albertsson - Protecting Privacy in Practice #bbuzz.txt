Title: Berlin Buzzwords 2017: Lars Albertsson - Protecting Privacy in Practice #bbuzz
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	With the rise of data-intensive applications, privacy and personal integrity has become a focus topic. Although companies may have incentive to collect all available data forever, privacy regulations act counter balance. Regulations limit the data that may be stored, for how long it may be stored, how access is given, and give users rights to have their data deleted and get information about the data stored by companies. 

The regulations put constraints on technical solutions, and makes it challenging to architect and implement systems that allow engineers to efficiently make beneficial use of sensitive data. Unfortunately, failures to properly protect privacy can be very expensive, since the work required to rework core data models and wash tainted data can be massive.

This talk provides an engineering perspective on privacy protection. The intended audience is architects, developers, data scientists, and engineering managers that build applications handling user data. We highlight topics that require attention at an early design stage, and go through pitfalls and potentially expensive architectural mistakes. 

We describe a number of technical patterns for complying with privacy regulations without sacrificing the ability to use data for product features. The content of the talk is based on real world experience from handling privacy protection in large scale data processing environments.  

Read more:
https://2017.berlinbuzzwords.de/17/session/protecting-privacy-practice

About Lars Albertsson:
https://2017.berlinbuzzwords.de/users/lars-albertsson

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,680 --> 00:00:18,400
all right thank you

00:00:09,230 --> 00:00:18,400
you hear me okay waiting from technology

00:00:31,210 --> 00:00:35,840
anyway thank you for coming and for

00:00:34,040 --> 00:00:38,270
climbing all of the stairs finding your

00:00:35,840 --> 00:00:41,059
way here and for coming here in spite of

00:00:38,270 --> 00:00:43,129
Ted Dunning talking downstairs he's an

00:00:41,059 --> 00:00:50,780
excellent speaker so make sure to watch

00:00:43,129 --> 00:00:53,239
his video later we're good to go okay

00:00:50,780 --> 00:00:57,830
hear me well blended

00:00:53,239 --> 00:00:59,210
you already heard my name as most

00:00:57,830 --> 00:01:01,700
speakers here I've done a bunch of

00:00:59,210 --> 00:01:04,309
things and working with data has been

00:01:01,700 --> 00:01:06,020
one of the themes of my career from like

00:01:04,309 --> 00:01:08,000
twenty years ago when I did my master's

00:01:06,020 --> 00:01:10,250
thesis at the supercomputing Center in

00:01:08,000 --> 00:01:15,259
Stockholm working with scary things like

00:01:10,250 --> 00:01:18,860
MPI and Cray vector machines there will

00:01:15,259 --> 00:01:22,399
be data at the time and many of the

00:01:18,860 --> 00:01:24,619
things that I have learned during these

00:01:22,399 --> 00:01:26,300
years of picked up working at Spotify

00:01:24,619 --> 00:01:28,070
with data infrastructure and data

00:01:26,300 --> 00:01:30,619
modelling in their Hadoop based

00:01:28,070 --> 00:01:32,720
environment and their Hadoop cluster

00:01:30,619 --> 00:01:34,340
actually turns 10 this year which is

00:01:32,720 --> 00:01:38,179
scary thought that was like

00:01:34,340 --> 00:01:40,190
bleeding-edge not long ago and nowadays

00:01:38,179 --> 00:01:43,780
I work as an independent consultant

00:01:40,190 --> 00:01:50,360
helping companies get value out of data

00:01:43,780 --> 00:01:52,759
and I'm interested in privacy sort of a

00:01:50,360 --> 00:01:54,170
passion of mine and my clients are also

00:01:52,759 --> 00:01:55,789
interested in producing because they

00:01:54,170 --> 00:01:59,270
need to comply with gdpr and other

00:01:55,789 --> 00:02:01,789
requirements so I went scouted for

00:01:59,270 --> 00:02:03,830
resources on the web and the resources

00:02:01,789 --> 00:02:06,920
that I could find were like falling into

00:02:03,830 --> 00:02:08,539
two categories either a very problem

00:02:06,920 --> 00:02:09,979
oriented the legal aspect here's

00:02:08,539 --> 00:02:11,540
everything that you might go wrong and

00:02:09,979 --> 00:02:15,140
you might get a large fine if you don't

00:02:11,540 --> 00:02:16,849
get it right or like someone selling a

00:02:15,140 --> 00:02:18,620
product to me and I put all of your data

00:02:16,849 --> 00:02:21,530
into our system and everything will be

00:02:18,620 --> 00:02:23,540
much better what I failed to find was

00:02:21,530 --> 00:02:26,599
like engineering oriented resources how

00:02:23,540 --> 00:02:28,670
to actually go about protecting users

00:02:26,599 --> 00:02:32,180
privacy without sacrificing all of the

00:02:28,670 --> 00:02:35,360
goodies that we have so I decided to try

00:02:32,180 --> 00:02:37,220
to give that talk myself but we you get

00:02:35,360 --> 00:02:39,230
only bits and pieces so please if you

00:02:37,220 --> 00:02:42,200
have things to contribute in this area

00:02:39,230 --> 00:02:47,800
you know see this as an inspirational

00:02:42,200 --> 00:02:53,120
of telling the world there are a lot of

00:02:47,800 --> 00:02:54,950
angles that you have to cover and if you

00:02:53,120 --> 00:02:59,060
want to protect users privacy and that

00:02:54,950 --> 00:03:01,370
you had to work on and I will focus on

00:02:59,060 --> 00:03:03,050
the bottom ones here architecture and

00:03:01,370 --> 00:03:05,140
culture most of the talk will be

00:03:03,050 --> 00:03:07,580
technical there will also be some like

00:03:05,140 --> 00:03:11,450
bottom-up culture awareness for

00:03:07,580 --> 00:03:13,910
engineers I will only give you tools

00:03:11,450 --> 00:03:15,290
patterns not a whole system that will

00:03:13,910 --> 00:03:18,530
solve everything for you so you have to

00:03:15,290 --> 00:03:20,690
take the pieces and assemble them as you

00:03:18,530 --> 00:03:22,970
see fit it's kind of like then an IKEA

00:03:20,690 --> 00:03:25,700
piece of Ikea furniture you have to do

00:03:22,970 --> 00:03:28,130
the last work yourself and I will assume

00:03:25,700 --> 00:03:29,420
that you have other ways to solve the

00:03:28,130 --> 00:03:31,790
other aspects for example that you have

00:03:29,420 --> 00:03:33,319
security primitives in place to like

00:03:31,790 --> 00:03:37,069
limit access and so forth so I will not

00:03:33,319 --> 00:03:39,290
touch the subject and I believe that the

00:03:37,069 --> 00:03:41,060
reason I'm here and nobody else is that

00:03:39,290 --> 00:03:43,190
I'm independent if somebody comes from a

00:03:41,060 --> 00:03:45,079
company speak about previously the first

00:03:43,190 --> 00:03:46,790
question they get is so what is like a

00:03:45,079 --> 00:03:51,319
jewel company and nobody wants that

00:03:46,790 --> 00:03:53,720
question so but the IV not enough places

00:03:51,319 --> 00:03:56,030
to cuss like reasonable doubt so what

00:03:53,720 --> 00:03:59,389
I'm saying today does not describe

00:03:56,030 --> 00:04:00,980
practices at any specific company there

00:03:59,389 --> 00:04:04,069
are bits and pieces that I picked up

00:04:00,980 --> 00:04:05,959
during my junior journey both from

00:04:04,069 --> 00:04:08,690
companies solving things the good way

00:04:05,959 --> 00:04:13,850
and company making companies making

00:04:08,690 --> 00:04:17,750
mistakes so from an engineer architect

00:04:13,850 --> 00:04:19,280
or developer perspective there are some

00:04:17,750 --> 00:04:23,389
things that you need to be prepared for

00:04:19,280 --> 00:04:25,669
and I'm going to spend a lot most of the

00:04:23,389 --> 00:04:27,710
time on the top one the ability to

00:04:25,669 --> 00:04:30,650
delete users and forget the information

00:04:27,710 --> 00:04:32,630
because that's a tricky one but there

00:04:30,650 --> 00:04:34,760
are a number of other things that you

00:04:32,630 --> 00:04:36,979
also need to be care about like limiting

00:04:34,760 --> 00:04:39,860
the access that employees up to date and

00:04:36,979 --> 00:04:41,630
limiting the access that any hackers

00:04:39,860 --> 00:04:45,340
that intruder a system might have to

00:04:41,630 --> 00:04:48,330
data and so forth and you there are also

00:04:45,340 --> 00:04:50,849
upcoming requirement of

00:04:48,330 --> 00:04:52,770
being able to export all of the users

00:04:50,849 --> 00:04:54,389
data so forth I'll touch a bit of those

00:04:52,770 --> 00:04:59,159
but most of the time will be spent on

00:04:54,389 --> 00:05:01,560
the right to be forgotten so to set some

00:04:59,159 --> 00:05:04,020
context here if you go back in time to

00:05:01,560 --> 00:05:04,770
our first like web applications things

00:05:04,020 --> 00:05:06,509
simple

00:05:04,770 --> 00:05:09,960
there was a monolith and all the

00:05:06,509 --> 00:05:11,729
database and all of the state of the

00:05:09,960 --> 00:05:15,539
users were generally stored in that

00:05:11,729 --> 00:05:17,729
database so if you get a request from a

00:05:15,539 --> 00:05:19,050
user and say can you please delete all

00:05:17,729 --> 00:05:21,569
the information that you have on me and

00:05:19,050 --> 00:05:25,379
remove me and or what data we got to me

00:05:21,569 --> 00:05:30,000
that was a fairly simple thing to comply

00:05:25,379 --> 00:05:33,930
with and if you even if today you read

00:05:30,000 --> 00:05:35,580
like it takes written by people that do

00:05:33,930 --> 00:05:37,349
not understand how data processing

00:05:35,580 --> 00:05:40,409
systems works today this seems to be

00:05:37,349 --> 00:05:42,270
sometimes it to be an assumption so this

00:05:40,409 --> 00:05:46,550
is like a cultural bridge that you may

00:05:42,270 --> 00:05:50,009
have to get today we don't work this way

00:05:46,550 --> 00:05:53,340
since the comment of the doop we now

00:05:50,009 --> 00:05:55,139
have the power both economic and

00:05:53,340 --> 00:05:57,659
technical to store everything that has

00:05:55,139 --> 00:06:01,500
ever happened and we do so because it

00:05:57,659 --> 00:06:04,500
gives us the power to go back and the

00:06:01,500 --> 00:06:07,979
new pipelines to get more data and we

00:06:04,500 --> 00:06:10,020
organize things in a in pipelines that

00:06:07,979 --> 00:06:14,250
refine this raw data and data is copied

00:06:10,020 --> 00:06:18,060
in these pythons and so forth we do this

00:06:14,250 --> 00:06:21,240
for good reasons this in comparison to

00:06:18,060 --> 00:06:23,580
the sort of database centric well that

00:06:21,240 --> 00:06:26,699
we used to live in enables us to do much

00:06:23,580 --> 00:06:29,699
more complex things it enables us to her

00:06:26,699 --> 00:06:31,830
be tolerant to human error we can it's

00:06:29,699 --> 00:06:33,629
easy to fix bugs on and the data

00:06:31,830 --> 00:06:37,259
processing side by reprocessing and so

00:06:33,629 --> 00:06:39,810
forth so we are not going to give this

00:06:37,259 --> 00:06:42,599
up and go back to a sort of mutable

00:06:39,810 --> 00:06:44,849
database world because this is one of

00:06:42,599 --> 00:06:46,770
the factors that sort of separate the

00:06:44,849 --> 00:06:49,199
wheat companies from the chaff companies

00:06:46,770 --> 00:06:51,840
so we have to find a way in such an

00:06:49,199 --> 00:06:55,050
environment to to be able to delete

00:06:51,840 --> 00:06:59,039
users anyway if you scale this up this

00:06:55,050 --> 00:07:00,570
is roughly what a data processing system

00:06:59,039 --> 00:07:01,950
today looks like in the companies that I

00:07:00,570 --> 00:07:04,320
work with

00:07:01,950 --> 00:07:06,960
you collect either events on the left

00:07:04,320 --> 00:07:09,330
side or dump databases and you pour them

00:07:06,960 --> 00:07:11,220
all into something that goes by the bus

00:07:09,330 --> 00:07:14,340
word data Lake this is the bus first

00:07:11,220 --> 00:07:16,320
conference I'm happy to use buzzwords

00:07:14,340 --> 00:07:21,240
without shame you can also call it cold

00:07:16,320 --> 00:07:23,280
store roll store that rule a cool store

00:07:21,240 --> 00:07:25,290
you never change typically unless

00:07:23,280 --> 00:07:27,060
privacy comes along but for technical

00:07:25,290 --> 00:07:29,580
reasons you preferred not to changes and

00:07:27,060 --> 00:07:32,730
then you have pipelines refining that

00:07:29,580 --> 00:07:35,130
data combining it and then produce like

00:07:32,730 --> 00:07:36,840
refined artifacts on the right side for

00:07:35,130 --> 00:07:40,740
example recommendation in this list and

00:07:36,840 --> 00:07:44,280
so forth now I need your help here how

00:07:40,740 --> 00:07:46,110
many people recognize this as a fair

00:07:44,280 --> 00:07:49,070
description of the kind of systems they

00:07:46,110 --> 00:07:52,320
work with or would like to work with

00:07:49,070 --> 00:07:54,270
okay good most of the owners because the

00:07:52,320 --> 00:07:58,710
what I'm saying is relevant for this

00:07:54,270 --> 00:08:00,840
context but not for other context one

00:07:58,710 --> 00:08:03,900
key component here which we'll get back

00:08:00,840 --> 00:08:07,740
to a few times is workflow manager and

00:08:03,900 --> 00:08:10,050
that is the sort of glue that holds your

00:08:07,740 --> 00:08:13,410
pipelines together and knows about the

00:08:10,050 --> 00:08:15,650
dependencies and helps you like backfill

00:08:13,410 --> 00:08:18,780
when something goes wrong and helps you

00:08:15,650 --> 00:08:23,790
build a stable system out of fragile

00:08:18,780 --> 00:08:25,950
components and a lot of companies today

00:08:23,790 --> 00:08:28,410
tend to use the Luigi or airflow way

00:08:25,950 --> 00:08:31,530
have a python-based DSL for expressing

00:08:28,410 --> 00:08:34,350
the DAGs and you have a fairly rich way

00:08:31,530 --> 00:08:36,930
to express your your DAGs now how many

00:08:34,350 --> 00:08:41,520
in here use either Luigi or outflow or

00:08:36,930 --> 00:08:43,530
something similar just a few okay then

00:08:41,520 --> 00:08:45,900
that will be my first advice of the day

00:08:43,530 --> 00:08:49,230
if you're using something that is more

00:08:45,900 --> 00:08:52,580
primitive like Lucy or bash script or

00:08:49,230 --> 00:08:54,630
whatever you will have a difficult time

00:08:52,580 --> 00:08:56,130
solving the or following the

00:08:54,630 --> 00:08:59,040
recommendations that I give up here so

00:08:56,130 --> 00:09:01,680
that the I really would like to

00:08:59,040 --> 00:09:04,830
recommend you to go with a more

00:09:01,680 --> 00:09:06,150
competent workflow manager you might

00:09:04,830 --> 00:09:07,920
have completely different solutions that

00:09:06,150 --> 00:09:09,150
are not allowed in that case I would

00:09:07,920 --> 00:09:11,540
like to love to hear about them

00:09:09,150 --> 00:09:11,540
afterwards

00:09:13,429 --> 00:09:22,559
so the there are some patterns that will

00:09:20,160 --> 00:09:24,569
fall into in order to make these fairly

00:09:22,559 --> 00:09:27,929
complex complex systems work and be

00:09:24,569 --> 00:09:30,569
stable in production we tend to favor

00:09:27,929 --> 00:09:32,489
image mutability when we create datasets

00:09:30,569 --> 00:09:35,369
we tried not to touch the mavs arrestor

00:09:32,489 --> 00:09:37,470
and we have systems that are with at

00:09:35,369 --> 00:09:41,220
least one semantics and redundancy and

00:09:37,470 --> 00:09:44,850
do things more times rather than too few

00:09:41,220 --> 00:09:49,589
times and so forth and we architect

00:09:44,850 --> 00:09:52,529
these dependency graphs by making copies

00:09:49,589 --> 00:09:55,949
of the data everywhere in order to have

00:09:52,529 --> 00:09:57,929
reproducible systems it's it's actually

00:09:55,949 --> 00:10:00,119
fairly common to have thousands of

00:09:57,929 --> 00:10:02,309
copies for example of your entire user

00:10:00,119 --> 00:10:06,480
database which of course makes it more

00:10:02,309 --> 00:10:10,889
difficult to delete your users so in a

00:10:06,480 --> 00:10:14,249
system where these like philosophies are

00:10:10,889 --> 00:10:15,720
applied the quit the request please

00:10:14,249 --> 00:10:17,249
delete everything that you have on me

00:10:15,720 --> 00:10:19,889
you please enumerate everything that you

00:10:17,249 --> 00:10:29,309
have on me can be really difficult to to

00:10:19,889 --> 00:10:32,160
answer so I have a couple of solution

00:10:29,309 --> 00:10:33,839
ideas to present you they some are some

00:10:32,160 --> 00:10:36,720
are purely technical making it

00:10:33,839 --> 00:10:38,790
technically at feasible and sort of

00:10:36,720 --> 00:10:42,660
economically feasible to actually comply

00:10:38,790 --> 00:10:44,339
with requests for deletion and some are

00:10:42,660 --> 00:10:46,350
purely on the cultural side making

00:10:44,339 --> 00:10:48,480
developers aware and then there are some

00:10:46,350 --> 00:10:51,029
in between whether you can architect the

00:10:48,480 --> 00:10:52,579
technology to to sort of push developers

00:10:51,029 --> 00:10:55,220
to do the right thing

00:10:52,579 --> 00:10:57,809
we'll start on the cultural side I

00:10:55,220 --> 00:11:00,869
recommend that the the one of the first

00:10:57,809 --> 00:11:07,679
things that you do is to classify the

00:11:00,869 --> 00:11:10,259
data that you have and I the GDP are

00:11:07,679 --> 00:11:12,029
another sophistication speed VAR

00:11:10,259 --> 00:11:15,029
classifications this is not an example

00:11:12,029 --> 00:11:17,610
of a classification this is an example

00:11:15,029 --> 00:11:20,339
of an classification that you might

00:11:17,610 --> 00:11:21,389
decide to use in your company each

00:11:20,339 --> 00:11:23,040
company would have a different

00:11:21,389 --> 00:11:24,199
classification and you need to make your

00:11:23,040 --> 00:11:27,000
own decisions

00:11:24,199 --> 00:11:29,279
it is common to classify in three tiers

00:11:27,000 --> 00:11:32,550
on the bottom tier things that are not

00:11:29,279 --> 00:11:33,779
attached to any people at all for

00:11:32,550 --> 00:11:38,310
convenience I will give these color

00:11:33,779 --> 00:11:40,529
names red yellow green and the middle

00:11:38,310 --> 00:11:43,529
classification is information that is

00:11:40,529 --> 00:11:46,350
not in particularly sensitive but might

00:11:43,529 --> 00:11:50,820
be attached to a person like names or IP

00:11:46,350 --> 00:11:53,940
addresses and so forth whereas most

00:11:50,820 --> 00:11:57,089
companies also handle some sensitive

00:11:53,940 --> 00:11:59,370
data you might think that you don't

00:11:57,089 --> 00:12:01,139
because you don't handle financial stuff

00:11:59,370 --> 00:12:02,850
for medical records but it's actually

00:12:01,139 --> 00:12:05,070
easy to end up with some real sensitive

00:12:02,850 --> 00:12:07,019
data anyway if you have like messages in

00:12:05,070 --> 00:12:10,500
your application or if you have GPS

00:12:07,019 --> 00:12:12,089
coordinates then there will be some

00:12:10,500 --> 00:12:16,970
stuff that falls into some kind of very

00:12:12,089 --> 00:12:19,649
song that's difficult to classify and

00:12:16,970 --> 00:12:22,529
when you process this data there's some

00:12:19,649 --> 00:12:24,600
kind of like approximate arithmetic that

00:12:22,529 --> 00:12:26,490
apply if you take something sensitive

00:12:24,600 --> 00:12:27,899
and concatenate it with something long

00:12:26,490 --> 00:12:30,180
sensitive line yet still have something

00:12:27,899 --> 00:12:34,980
sensitive for example if you put the

00:12:30,180 --> 00:12:37,019
user some food in a mail message if you

00:12:34,980 --> 00:12:42,779
aggregate things for example by counting

00:12:37,019 --> 00:12:44,819
them none sir I'm saying usually is that

00:12:42,779 --> 00:12:48,060
you always apply but you have something

00:12:44,819 --> 00:12:50,880
non sensitive enough of it you can

00:12:48,060 --> 00:12:52,920
actually draw conclusions from from that

00:12:50,880 --> 00:12:55,470
data so if you manage to have enough

00:12:52,920 --> 00:12:57,930
data on user that can be identified to

00:12:55,470 --> 00:12:59,940
users you might actually be able to draw

00:12:57,930 --> 00:13:03,750
some sensitive conclusions about their

00:12:59,940 --> 00:13:07,019
but the like behavior and so forth so

00:13:03,750 --> 00:13:08,910
these rules are like not clear and if

00:13:07,019 --> 00:13:12,510
you make machine learning models out of

00:13:08,910 --> 00:13:14,430
sensitive or semi sensitive data you in

00:13:12,510 --> 00:13:17,339
theory you would hope that the machine

00:13:14,430 --> 00:13:19,260
learning models generalize so that you

00:13:17,339 --> 00:13:21,480
end up with something that's non

00:13:19,260 --> 00:13:24,569
sensitive but because of overfitting it

00:13:21,480 --> 00:13:26,790
turns out that if you probe these models

00:13:24,569 --> 00:13:28,050
you can actually identify identify users

00:13:26,790 --> 00:13:30,319
again so that's something to be careful

00:13:28,050 --> 00:13:30,319
with

00:13:31,780 --> 00:13:35,980
also on the cultural side I would

00:13:34,540 --> 00:13:38,860
recommend that you use these

00:13:35,980 --> 00:13:40,450
classifications and make them throw them

00:13:38,860 --> 00:13:42,670
in the face of the developers make them

00:13:40,450 --> 00:13:45,970
visible at all times

00:13:42,670 --> 00:13:48,280
for example in names of datasets I

00:13:45,970 --> 00:13:51,310
usually recommend to put them like early

00:13:48,280 --> 00:13:54,790
in the path of your datasets or field

00:13:51,310 --> 00:13:56,830
names or in wherever names are

00:13:54,790 --> 00:14:00,220
appropriate because these makes the

00:13:56,830 --> 00:14:02,080
developers aware of the privacy issues

00:14:00,220 --> 00:14:07,090
exist on earth at their camping with

00:14:02,080 --> 00:14:09,250
with personal data it also if you're

00:14:07,090 --> 00:14:14,530
consistent it also enables you to write

00:14:09,250 --> 00:14:17,590
them some simple cooling one of the

00:14:14,530 --> 00:14:20,380
reasons that I recommend putting the PII

00:14:17,590 --> 00:14:24,400
levels first in the prefixes is that

00:14:20,380 --> 00:14:28,480
usually access rights are given on a

00:14:24,400 --> 00:14:29,770
prefix basis at least in an Amazon s3 so

00:14:28,480 --> 00:14:31,390
there if you if you have for example

00:14:29,770 --> 00:14:32,980
have green first then you know that you

00:14:31,390 --> 00:14:34,510
can give full access rights to anybody

00:14:32,980 --> 00:14:36,280
in the company on all the green stuff

00:14:34,510 --> 00:14:43,990
and it simplifies your access rights

00:14:36,280 --> 00:14:47,830
management so one other cultural thing

00:14:43,990 --> 00:14:50,080
that we did at the company was to wrap

00:14:47,830 --> 00:14:52,480
all of this sort of supported data

00:14:50,080 --> 00:14:55,839
functionality into a single gateway tool

00:14:52,480 --> 00:14:58,180
this this tool is similar to like the

00:14:55,839 --> 00:15:01,060
AWS command-line tool or the g-cloud

00:14:58,180 --> 00:15:04,660
command line 2 but it's specific for the

00:15:01,060 --> 00:15:06,400
company and then we push that all of the

00:15:04,660 --> 00:15:09,820
data sciences and people that work with

00:15:06,400 --> 00:15:11,920
data to use this tool it's this tool had

00:15:09,820 --> 00:15:14,589
no business logic whatsoever

00:15:11,920 --> 00:15:17,080
it only was it was only thin wrapper to

00:15:14,589 --> 00:15:18,790
other programs and it had hardwired

00:15:17,080 --> 00:15:21,250
configuration so I knew about the

00:15:18,790 --> 00:15:24,220
production clusters and so forth and

00:15:21,250 --> 00:15:27,390
this gave us a central point of like

00:15:24,220 --> 00:15:31,170
governance where we could do audits and

00:15:27,390 --> 00:15:34,240
to some degree verifications and also

00:15:31,170 --> 00:15:35,710
enforce like policies that we want to

00:15:34,240 --> 00:15:38,110
judge so for example if somebody made a

00:15:35,710 --> 00:15:39,640
temporary cluster to the sample sample

00:15:38,110 --> 00:15:41,410
with some temporary data that we could

00:15:39,640 --> 00:15:43,360
enforce the dis cluster with the day

00:15:41,410 --> 00:15:45,440
that was deleted after a while and so

00:15:43,360 --> 00:15:49,440
forth

00:15:45,440 --> 00:15:51,330
this may seem like like enforcing

00:15:49,440 --> 00:15:53,010
bureaucracy but it turned out that the

00:15:51,330 --> 00:15:56,070
data scientists were really happy with

00:15:53,010 --> 00:15:57,960
this because it provided them with a

00:15:56,070 --> 00:15:59,940
directory of all the things you can do

00:15:57,960 --> 00:16:02,100
and it also shielded them from the

00:15:59,940 --> 00:16:04,470
operations like the details of what

00:16:02,100 --> 00:16:11,130
names or IP addresses and clusters worth

00:16:04,470 --> 00:16:15,000
so they felt really enabled and and it

00:16:11,130 --> 00:16:16,950
also pushed people to also doing the

00:16:15,000 --> 00:16:19,440
right thing so one thing you don't want

00:16:16,950 --> 00:16:20,610
people to do is download PII data on

00:16:19,440 --> 00:16:22,890
their laptops because then you lose

00:16:20,610 --> 00:16:24,450
control of it so there was no command

00:16:22,890 --> 00:16:26,640
for downloading to laptop there was

00:16:24,450 --> 00:16:29,330
there were commands for creating

00:16:26,640 --> 00:16:33,480
temporary resources in the cloud instead

00:16:29,330 --> 00:16:35,430
now the data scientists felt so enabled

00:16:33,480 --> 00:16:37,800
by this that they started spinning up

00:16:35,430 --> 00:16:39,360
clusters back and forth and then the

00:16:37,800 --> 00:16:41,940
manager said I want these numbers by

00:16:39,360 --> 00:16:44,850
tomorrow so after a few weeks we had

00:16:41,940 --> 00:16:50,210
somebody who were now in in charge of

00:16:44,850 --> 00:16:50,210
cost control which I see as a good sign

00:16:50,330 --> 00:16:57,360
all right now tools the technical stuff

00:16:53,250 --> 00:17:00,660
and forgetting about things if you have

00:16:57,360 --> 00:17:02,430
a something like an adult cluster and

00:17:00,660 --> 00:17:03,660
then a bunch of pipe lines and everybody

00:17:02,430 --> 00:17:08,130
writes a new pipe lines

00:17:03,660 --> 00:17:12,060
if you drop in a piece of my personal

00:17:08,130 --> 00:17:14,280
data somewhere if you don't focus this

00:17:12,060 --> 00:17:17,070
will spread like weed all over your all

00:17:14,280 --> 00:17:19,650
over your cluster and out into the to

00:17:17,070 --> 00:17:23,790
the online databases that you have for

00:17:19,650 --> 00:17:25,620
serving users and so forth so you have

00:17:23,790 --> 00:17:27,300
to have some kind of plan in order to

00:17:25,620 --> 00:17:29,580
prevent this from from happening you

00:17:27,300 --> 00:17:32,700
need to like pricing governance like

00:17:29,580 --> 00:17:35,790
bureaucracy on the cluster or to

00:17:32,700 --> 00:17:37,440
encapsulate data or to drop data the

00:17:35,790 --> 00:17:40,890
best thing from a probe is a perspective

00:17:37,440 --> 00:17:44,720
of course to drop data so you start by

00:17:40,890 --> 00:17:44,720
dropping the data that you don't need so

00:17:44,750 --> 00:17:51,080
you can either make your data completely

00:17:48,450 --> 00:17:54,360
anonymous for example if you have

00:17:51,080 --> 00:17:56,520
pageviews or somebody played a video

00:17:54,360 --> 00:17:57,370
whatever you just drop the the user ID

00:17:56,520 --> 00:18:00,249
and

00:17:57,370 --> 00:18:03,940
it's for each record there is no way to

00:18:00,249 --> 00:18:07,269
get back to the user ID when the data is

00:18:03,940 --> 00:18:09,249
anonymous now unfortunately with

00:18:07,269 --> 00:18:10,690
anonymous data is not luck you can do

00:18:09,249 --> 00:18:13,779
you can count things but not more than

00:18:10,690 --> 00:18:15,549
that you can still make the data

00:18:13,779 --> 00:18:18,490
anonymous and type some information if

00:18:15,549 --> 00:18:20,049
you look up the user and join in with

00:18:18,490 --> 00:18:22,419
for example course demographical

00:18:20,049 --> 00:18:25,749
information what age country gender and

00:18:22,419 --> 00:18:29,499
so forth users when the data at the end

00:18:25,749 --> 00:18:31,960
of the pipeline becomes more useful for

00:18:29,499 --> 00:18:34,409
example for business insights but you

00:18:31,960 --> 00:18:38,230
still have completely anonymous records

00:18:34,409 --> 00:18:42,490
but if you add enough data so that some

00:18:38,230 --> 00:18:44,679
data is actually rare for example they

00:18:42,490 --> 00:18:47,919
are not in some set codes only very few

00:18:44,679 --> 00:18:49,990
people live then you actually no longer

00:18:47,919 --> 00:18:52,509
have known anonymize data and you can

00:18:49,990 --> 00:18:55,149
connect it back to users if you have

00:18:52,509 --> 00:18:57,940
really anonymous data the GDP are states

00:18:55,149 --> 00:18:59,379
that the these rules no longer apply so

00:18:57,940 --> 00:19:01,480
you don't have to fulfill all the rules

00:18:59,379 --> 00:19:03,639
but I'm not a lawyer

00:19:01,480 --> 00:19:06,539
don't take my advices as legal this is

00:19:03,639 --> 00:19:09,580
just a link for your general information

00:19:06,539 --> 00:19:11,230
you will need to go back to your company

00:19:09,580 --> 00:19:17,200
and solve all of the legal things and

00:19:11,230 --> 00:19:23,019
get approvals and so forth so you can

00:19:17,200 --> 00:19:27,909
halfway anonymize things for example by

00:19:23,019 --> 00:19:29,769
replacing the user ID with a consistent

00:19:27,909 --> 00:19:34,119
hash of the user ID it's the upper

00:19:29,769 --> 00:19:36,159
example here then the all of the records

00:19:34,119 --> 00:19:38,740
are still linked back so you can see

00:19:36,159 --> 00:19:40,629
that the same user was doing all of

00:19:38,740 --> 00:19:42,580
these records they don't know which user

00:19:40,629 --> 00:19:45,460
if you just look at one data set this is

00:19:42,580 --> 00:19:47,200
called pseudonym ization there's a

00:19:45,460 --> 00:19:49,269
misconception here that if you do this

00:19:47,200 --> 00:19:51,159
it's called anonymization it's not it's

00:19:49,269 --> 00:19:53,710
called pseudonym ization so don't mix

00:19:51,159 --> 00:19:55,330
these up because these terms appear in

00:19:53,710 --> 00:19:56,100
legal texts and so forth so be careful

00:19:55,330 --> 00:19:59,110
with it

00:19:56,100 --> 00:20:01,119
and this is still pretty sensitive

00:19:59,110 --> 00:20:03,190
information because you can trace things

00:20:01,119 --> 00:20:04,990
back to the user perhaps not by looking

00:20:03,190 --> 00:20:06,639
at one data set they combined by

00:20:04,990 --> 00:20:09,690
combining with other data sets so all of

00:20:06,639 --> 00:20:12,269
the rules still apply so forth

00:20:09,690 --> 00:20:15,119
like if you make it consistent - then

00:20:12,269 --> 00:20:18,889
you if you have the user ID later you

00:20:15,119 --> 00:20:22,769
can hash that and figure out which users

00:20:18,889 --> 00:20:25,109
belong to which records so you can in a

00:20:22,769 --> 00:20:26,969
student muxu donna mais pipeline like

00:20:25,109 --> 00:20:28,769
build recommendation indexes and then in

00:20:26,969 --> 00:20:35,820
your online service look up which users

00:20:28,769 --> 00:20:38,969
is which if you you can also go like

00:20:35,820 --> 00:20:40,999
half way by adding a salt into the into

00:20:38,969 --> 00:20:44,219
your hashing so it's no longer

00:20:40,999 --> 00:20:50,219
reproducible who wants me to explain the

00:20:44,219 --> 00:20:51,989
concept of salting okay good then it

00:20:50,219 --> 00:20:54,570
cannot be used for for things like

00:20:51,989 --> 00:20:56,549
recommendations but you still get a feel

00:20:54,570 --> 00:20:58,889
for the extent still get an information

00:20:56,549 --> 00:21:00,450
about the user journey so you can use it

00:20:58,889 --> 00:21:03,389
for like product insights and for

00:21:00,450 --> 00:21:05,249
looking at user sessions and the travels

00:21:03,389 --> 00:21:14,249
of users inside your website and so

00:21:05,249 --> 00:21:16,769
forth so if you don't if you're not

00:21:14,249 --> 00:21:19,049
discarding data or in complement to

00:21:16,769 --> 00:21:24,209
discarding data you want to forget users

00:21:19,049 --> 00:21:26,999
and then you will have your your online

00:21:24,209 --> 00:21:29,249
user database you remove the the user

00:21:26,999 --> 00:21:31,139
from the database and in your blue

00:21:29,249 --> 00:21:32,759
cluster or SC or whatever the dump of

00:21:31,139 --> 00:21:35,700
the debate database no longer contains

00:21:32,759 --> 00:21:37,049
that user but that uses information has

00:21:35,700 --> 00:21:38,940
been copied throughout all of the

00:21:37,049 --> 00:21:40,379
downstream jobs so you need to do

00:21:38,940 --> 00:21:44,190
something about that this sort of

00:21:40,379 --> 00:21:47,669
simplest brute force solution is to

00:21:44,190 --> 00:21:49,440
rerun all of your downstream jobs and in

00:21:47,669 --> 00:21:51,499
this case this is the these are the

00:21:49,440 --> 00:21:53,940
cases where you might benefit from a

00:21:51,499 --> 00:21:55,440
fairly sophisticated workflow manager

00:21:53,940 --> 00:21:57,929
because that's tool to help you do

00:21:55,440 --> 00:21:59,789
reruns of us unfortunately they don't go

00:21:57,929 --> 00:22:02,249
all the way for example there there are

00:21:59,789 --> 00:22:04,019
no built-in support for like versioning

00:22:02,249 --> 00:22:06,389
and revisions of data set so you have to

00:22:04,019 --> 00:22:08,669
do a bunch of work on your own in order

00:22:06,389 --> 00:22:11,249
to get this to work well it's also

00:22:08,669 --> 00:22:12,809
really computational expensive but you

00:22:11,249 --> 00:22:18,989
can start doing this today without

00:22:12,809 --> 00:22:20,789
changing your data models so there are

00:22:18,989 --> 00:22:22,050
better patterns if you tweak with the

00:22:20,789 --> 00:22:25,380
data model

00:22:22,050 --> 00:22:28,620
for example you can encapsulate your PII

00:22:25,380 --> 00:22:30,390
data by not putting it and copying it

00:22:28,620 --> 00:22:33,060
around and all of you get your data set

00:22:30,390 --> 00:22:36,030
instead you put a like a hash or you

00:22:33,060 --> 00:22:38,100
UUID in your data sets and that refers

00:22:36,030 --> 00:22:40,350
to some kind of table where the PII

00:22:38,100 --> 00:22:41,720
information is stored and then once you

00:22:40,350 --> 00:22:44,460
remove things from the table

00:22:41,720 --> 00:22:46,650
nothing can no one can access that

00:22:44,460 --> 00:22:48,240
information anymore so that now you are

00:22:46,650 --> 00:22:51,480
going to have one place we need to

00:22:48,240 --> 00:22:56,310
remove things in order to drop useless

00:22:51,480 --> 00:22:58,800
data and the drawback is that you need

00:22:56,310 --> 00:23:00,720
to join with this table all the time but

00:22:58,800 --> 00:23:07,740
from a previous respect perspective this

00:23:00,720 --> 00:23:10,920
is a lot better now I'm mixing up a

00:23:07,740 --> 00:23:12,750
couple of concepts here I'm saying

00:23:10,920 --> 00:23:14,190
tables which is something that belongs

00:23:12,750 --> 00:23:15,930
to a database world and I'm speaking

00:23:14,190 --> 00:23:19,260
about data sets and so forth you can

00:23:15,930 --> 00:23:22,590
have things like that like the PII table

00:23:19,260 --> 00:23:23,400
in a day in a database usually it's a an

00:23:22,590 --> 00:23:26,400
anti-pattern

00:23:23,400 --> 00:23:29,070
to query live databases from from your

00:23:26,400 --> 00:23:34,140
pipeline code but in this case it might

00:23:29,070 --> 00:23:37,950
be a good exception you can also have

00:23:34,140 --> 00:23:40,470
data sets that represent this this

00:23:37,950 --> 00:23:44,910
lookup table which is what I would

00:23:40,470 --> 00:23:47,580
recommend and in a usually in a

00:23:44,910 --> 00:23:50,340
dependency graph or pipeline if you're

00:23:47,580 --> 00:23:52,260
computing and data set for a particular

00:23:50,340 --> 00:23:55,700
date say in this case in this example

00:23:52,260 --> 00:23:58,500
all the purchases formed a you would

00:23:55,700 --> 00:24:00,420
constructed your dependency graph to

00:23:58,500 --> 00:24:02,430
point on the source data sets for the

00:24:00,420 --> 00:24:04,740
same day so the uses for the same day

00:24:02,430 --> 00:24:07,680
the orders for the same song and then

00:24:04,740 --> 00:24:09,240
you make an exception for this dii table

00:24:07,680 --> 00:24:11,820
so that you always depend on the latest

00:24:09,240 --> 00:24:14,420
one so that you know that whenever you

00:24:11,820 --> 00:24:16,050
remove something that it's going to move

00:24:14,420 --> 00:24:19,260
normally we would want to have a

00:24:16,050 --> 00:24:20,910
reproducibility but not in this case you

00:24:19,260 --> 00:24:22,440
explicitly want things not to be

00:24:20,910 --> 00:24:26,250
reproducible because you want to be able

00:24:22,440 --> 00:24:28,200
to remove users and this is easily

00:24:26,250 --> 00:24:30,600
accessible this this syntax here is

00:24:28,200 --> 00:24:32,100
example from Luigi where this is fairly

00:24:30,600 --> 00:24:34,880
easy to do I'm sure you can find

00:24:32,100 --> 00:24:34,880
examples out there

00:24:38,150 --> 00:24:47,580
so this is a variation of the the PII

00:24:43,610 --> 00:24:50,940
table where you don't put the actual

00:24:47,580 --> 00:24:55,020
data in a separate table instead you put

00:24:50,940 --> 00:24:58,020
in a decryption keys so you encrypt all

00:24:55,020 --> 00:25:01,080
of your PII data and copy it around all

00:24:58,020 --> 00:25:02,700
of the data sets but in order to decrypt

00:25:01,080 --> 00:25:05,040
the data for your pipeline processing

00:25:02,700 --> 00:25:08,910
you need to go and look up in this PII

00:25:05,040 --> 00:25:10,650
key table and then when you want to

00:25:08,910 --> 00:25:13,049
remove a user you just throw the

00:25:10,650 --> 00:25:15,059
decryption key out of the table you

00:25:13,049 --> 00:25:17,250
still have still have all of the

00:25:15,059 --> 00:25:18,690
encrypted data out there but since you

00:25:17,250 --> 00:25:20,910
like a key you cannot use it and

00:25:18,690 --> 00:25:24,030
therefore the user is protected

00:25:20,910 --> 00:25:25,830
some companies legal departments might

00:25:24,030 --> 00:25:28,110
not agree with this you need to get your

00:25:25,830 --> 00:25:31,320
approval I can't vouch for that but this

00:25:28,110 --> 00:25:32,760
is actually a super practical pattern so

00:25:31,320 --> 00:25:35,460
if you don't know where to start in this

00:25:32,760 --> 00:25:39,510
in this journey this this might be the

00:25:35,460 --> 00:25:43,290
slide you want to go back to you can

00:25:39,510 --> 00:25:45,690
also use this decryption decryption key

00:25:43,290 --> 00:25:47,280
to decrypt multiple fields so that

00:25:45,690 --> 00:25:48,990
simplifies life for you so you can

00:25:47,280 --> 00:25:51,240
typically you would have a record with

00:25:48,990 --> 00:25:52,890
lots lots of PII data and names email

00:25:51,240 --> 00:25:55,020
addresses and so forth and you encrypt

00:25:52,890 --> 00:25:57,059
them them all with the same record then

00:25:55,020 --> 00:26:02,610
you only have one table where to remove

00:25:57,059 --> 00:26:05,010
the keys and if you want to make this

00:26:02,610 --> 00:26:08,370
more granular you can have different

00:26:05,010 --> 00:26:14,570
keys depending on four different types

00:26:08,370 --> 00:26:17,820
of data this gives users the ability to

00:26:14,570 --> 00:26:20,250
ask for a partial oblivion please forget

00:26:17,820 --> 00:26:22,530
some of my information but not others so

00:26:20,250 --> 00:26:24,840
for example users might want you to

00:26:22,530 --> 00:26:26,309
forget all of their information about

00:26:24,840 --> 00:26:28,140
their whereabouts their GPS tracking

00:26:26,309 --> 00:26:30,929
which you might be tracking for some

00:26:28,140 --> 00:26:32,429
reason but they still maybe want the

00:26:30,929 --> 00:26:34,500
personalization to work well more

00:26:32,429 --> 00:26:38,600
accumulation indexes which are not

00:26:34,500 --> 00:26:38,600
dependent on on the GPS tracking

00:26:42,250 --> 00:26:50,390
there's another variation where you can

00:26:46,720 --> 00:26:53,720
discard the ability to link to join

00:26:50,390 --> 00:26:56,210
between datasets so in this case you

00:26:53,720 --> 00:27:00,710
have two datasets for example like

00:26:56,210 --> 00:27:05,150
activities and users and you have a key

00:27:00,710 --> 00:27:07,820
field in these datasets which you use to

00:27:05,150 --> 00:27:11,000
join the datasets now if you encrypt

00:27:07,820 --> 00:27:13,190
that key on both sides and store the

00:27:11,000 --> 00:27:18,020
encryption key here in the in the key

00:27:13,190 --> 00:27:21,710
table once you throw away that key you

00:27:18,020 --> 00:27:24,530
can no longer join these two together

00:27:21,710 --> 00:27:27,620
which means that if one of these

00:27:24,530 --> 00:27:28,520
datasets holds your activities if you

00:27:27,620 --> 00:27:30,140
throw away the key

00:27:28,520 --> 00:27:31,730
you can still benefit from the

00:27:30,140 --> 00:27:34,190
activities for example to feed your

00:27:31,730 --> 00:27:36,050
recommendation engines but you can no

00:27:34,190 --> 00:27:40,730
longer figure out which user it was that

00:27:36,050 --> 00:27:44,570
actually made these actions in all of

00:27:40,730 --> 00:27:48,020
the key table account patterns that I've

00:27:44,570 --> 00:27:50,720
shown here you can also apply a salt

00:27:48,020 --> 00:27:53,990
thing if you want some cases if you

00:27:50,720 --> 00:27:56,660
don't so you get consistent you get

00:27:53,990 --> 00:27:59,270
consistent encryptions so that you if if

00:27:56,660 --> 00:28:01,610
you don't solve in your encryption with

00:27:59,270 --> 00:28:05,380
the key in your data set or cross

00:28:01,610 --> 00:28:07,670
datasets one clear text thing will be

00:28:05,380 --> 00:28:09,770
encrypted that's the same thing so you

00:28:07,670 --> 00:28:11,720
can connect things together which you

00:28:09,770 --> 00:28:14,660
may or may not want whereas if you use

00:28:11,720 --> 00:28:17,030
salting you can still do the decryption

00:28:14,660 --> 00:28:19,220
and get all of the information back but

00:28:17,030 --> 00:28:21,920
if you only have the encrypted variant

00:28:19,220 --> 00:28:29,960
you can no longer connect things

00:28:21,920 --> 00:28:31,820
together now in some cases you have

00:28:29,960 --> 00:28:34,520
conflicting requirements for example you

00:28:31,820 --> 00:28:36,290
may have legal requirements to never

00:28:34,520 --> 00:28:40,280
forget anything for for like financial

00:28:36,290 --> 00:28:42,850
reasons or for for crime prevention

00:28:40,280 --> 00:28:44,930
reasons and this is in conflict with

00:28:42,850 --> 00:28:47,420
forgetting users but there is a trick

00:28:44,930 --> 00:28:49,850
here that you use the same key table

00:28:47,420 --> 00:28:51,560
pattern but when you discover the key

00:28:49,850 --> 00:28:52,910
you don't drop it completely you just

00:28:51,560 --> 00:28:54,530
drop it familiar all of your records

00:28:52,910 --> 00:28:56,390
then you give it to somebody else

00:28:54,530 --> 00:28:58,160
this somebody else might be user and you

00:28:56,390 --> 00:28:59,900
can tell the user here's the key if you

00:28:58,160 --> 00:29:02,120
want to make any claims towards us you

00:28:59,900 --> 00:29:05,210
need to provide this key or it can be

00:29:02,120 --> 00:29:08,360
some kind of external entity that will

00:29:05,210 --> 00:29:11,320
only give back the key for example in

00:29:08,360 --> 00:29:11,320
with a code Lord

00:29:14,650 --> 00:29:23,270
so this enough about oblivion this is a

00:29:20,870 --> 00:29:25,730
slide with some mistakes but I've seen

00:29:23,270 --> 00:29:30,830
made that are very costly very very

00:29:25,730 --> 00:29:34,850
costly one of them is to use personal

00:29:30,830 --> 00:29:37,550
data as keys as now I mean not

00:29:34,850 --> 00:29:40,190
encryption keys but as primary keys and

00:29:37,550 --> 00:29:42,050
joining keys in your data models because

00:29:40,190 --> 00:29:46,610
then they're really difficult to throw

00:29:42,050 --> 00:29:50,450
away and reworking all of your data from

00:29:46,610 --> 00:29:53,630
such a state is very expensive the other

00:29:50,450 --> 00:29:55,730
mistake the C made is to publish things

00:29:53,630 --> 00:29:57,980
that actually contain PII data and you

00:29:55,730 --> 00:30:02,240
might do this by accident for example if

00:29:57,980 --> 00:30:04,610
you if you your users might publish be

00:30:02,240 --> 00:30:06,500
able to publish some kind of list with

00:30:04,610 --> 00:30:08,690
compilations or document or whatever and

00:30:06,500 --> 00:30:10,550
that URI contains the username or

00:30:08,690 --> 00:30:12,770
something it that that's an easy mistake

00:30:10,550 --> 00:30:16,760
to make but once you publish things you

00:30:12,770 --> 00:30:19,160
cannot forget them and the third mistake

00:30:16,760 --> 00:30:20,690
is to publish pseudonymous datasets

00:30:19,160 --> 00:30:22,760
under the impression that they're

00:30:20,690 --> 00:30:24,530
somehow anonymous and there are plenty

00:30:22,760 --> 00:30:28,850
of examples where companies have moved

00:30:24,530 --> 00:30:31,400
up here the AOL search dataset is the

00:30:28,850 --> 00:30:34,970
most famous the you might remember the

00:30:31,400 --> 00:30:36,680
Det Netflix like recommendation

00:30:34,970 --> 00:30:39,680
competition apparently somebody

00:30:36,680 --> 00:30:41,780
managed to dicen or pseudonymous that by

00:30:39,680 --> 00:30:43,850
correlating activities with activities

00:30:41,780 --> 00:30:47,210
on IMDB and they could figure out who

00:30:43,850 --> 00:30:49,730
the users were so there's absolutely no

00:30:47,210 --> 00:30:55,310
way to be sure if you publish the Donna

00:30:49,730 --> 00:30:58,070
my data so juices just don't so another

00:30:55,310 --> 00:31:00,170
trick the previous trickster spoke about

00:30:58,070 --> 00:31:03,470
they they work best in the pipeline

00:31:00,170 --> 00:31:06,980
domain where you have a

00:31:03,470 --> 00:31:08,630
move scenario when you compute things in

00:31:06,980 --> 00:31:10,760
pipelines you can go out and pull this

00:31:08,630 --> 00:31:12,799
data set in and pull the table in in

00:31:10,760 --> 00:31:14,240
your online services they might not do

00:31:12,799 --> 00:31:17,809
this pool they might be online all the

00:31:14,240 --> 00:31:20,600
time so it's useful to publish a sort of

00:31:17,809 --> 00:31:23,110
data set or a stream of all of the users

00:31:20,600 --> 00:31:26,570
that want to be forgotten

00:31:23,110 --> 00:31:29,020
so that online services can consume this

00:31:26,570 --> 00:31:32,950
and do whatever they need to do in that

00:31:29,020 --> 00:31:36,320
serving database is not to remove users

00:31:32,950 --> 00:31:37,700
where you should from a previously

00:31:36,320 --> 00:31:39,500
perspective it's better to strive

00:31:37,700 --> 00:31:42,140
towards the pool pattern so if you can

00:31:39,500 --> 00:31:44,780
change your online services to like

00:31:42,140 --> 00:31:47,090
rebuilder in the six indices on a

00:31:44,780 --> 00:31:48,860
regular basis or something then you're

00:31:47,090 --> 00:31:50,960
safer in terms of PII the push pattern

00:31:48,860 --> 00:31:56,480
is more fragile because it's easy to to

00:31:50,960 --> 00:31:58,700
miss you have PII leaks now I'm saying

00:31:56,480 --> 00:32:00,200
the leak like that's a really simple

00:31:58,700 --> 00:32:02,720
thing to do it turns out that it's not

00:32:00,200 --> 00:32:04,190
because all of the our components and

00:32:02,720 --> 00:32:06,230
all of our abstraction layers they also

00:32:04,190 --> 00:32:10,340
have this like immutability and then

00:32:06,230 --> 00:32:13,520
redundancy and so forth and just take an

00:32:10,340 --> 00:32:15,230
example I guess a whole bunch of people

00:32:13,520 --> 00:32:18,020
here know how roughly our Cassander

00:32:15,230 --> 00:32:20,240
works you have a bunch of nodes and if

00:32:18,020 --> 00:32:21,770
you actually want to delete some data in

00:32:20,240 --> 00:32:24,919
there you don't go up to the nodes and

00:32:21,770 --> 00:32:27,650
delete it you publish the or Cassandra

00:32:24,919 --> 00:32:31,460
under the hood publishes a tombstone

00:32:27,650 --> 00:32:33,409
record saying that this data is should

00:32:31,460 --> 00:32:35,270
no longer be there and then spreads to

00:32:33,409 --> 00:32:37,789
all of the nodes and everybody's in

00:32:35,270 --> 00:32:40,179
agreement except that the date actual

00:32:37,789 --> 00:32:42,200
data is kept for quite a long time until

00:32:40,179 --> 00:32:44,510
you run something called major

00:32:42,200 --> 00:32:47,840
compaction where you clean things up but

00:32:44,510 --> 00:32:50,480
for some configurations of Cassandra you

00:32:47,840 --> 00:32:52,010
cannot actually do major compaction and

00:32:50,480 --> 00:32:54,049
it's common to see installations where

00:32:52,010 --> 00:32:55,150
they are never done so data never gets

00:32:54,049 --> 00:32:57,409
deleted

00:32:55,150 --> 00:32:59,419
likewise if nodes are connected for a

00:32:57,409 --> 00:33:02,900
while or disconnected for a while they

00:32:59,419 --> 00:33:04,880
are not aware of this deletion so the

00:33:02,900 --> 00:33:06,679
bottom line here that's for every

00:33:04,880 --> 00:33:08,900
component you use you need to have

00:33:06,679 --> 00:33:10,460
component specific expertise on how to

00:33:08,900 --> 00:33:12,880
really delete things and this can be

00:33:10,460 --> 00:33:16,350
quite tricky

00:33:12,880 --> 00:33:20,370
likewise for every storage

00:33:16,350 --> 00:33:22,740
storage layer they use be it virtual

00:33:20,370 --> 00:33:24,809
disks or storage as a service or

00:33:22,740 --> 00:33:28,559
whatever you need to figure out how to

00:33:24,809 --> 00:33:34,409
actually delete things so I have a

00:33:28,559 --> 00:33:36,990
couple of pieces of advice here keep the

00:33:34,409 --> 00:33:39,330
number of components down in order to

00:33:36,990 --> 00:33:42,380
minimize this comtesse that you need

00:33:39,330 --> 00:33:46,110
keep the number of storage layers down

00:33:42,380 --> 00:33:47,700
so that there are fewer things that you

00:33:46,110 --> 00:33:51,659
need to know if you use cloud storage

00:33:47,700 --> 00:33:52,919
layers if I understand the legal aspect

00:33:51,659 --> 00:33:54,870
size you need to go out and get

00:33:52,919 --> 00:33:57,000
agreements from from the providers and

00:33:54,870 --> 00:33:58,740
saying that we they will comply if you

00:33:57,000 --> 00:34:02,039
delete things and so on so that there's

00:33:58,740 --> 00:34:04,320
a non-technical aspect to it as well and

00:34:02,039 --> 00:34:07,169
try to come up with simple strategies so

00:34:04,320 --> 00:34:12,210
if you for example if you're you're in

00:34:07,169 --> 00:34:14,579
the cloud and use Cassandra you can run

00:34:12,210 --> 00:34:16,679
your major compactions and then actually

00:34:14,579 --> 00:34:19,440
cycle the machine so that no machine

00:34:16,679 --> 00:34:21,659
lives for more than 30 days or 90 days

00:34:19,440 --> 00:34:23,339
or whatever and as you cycle the

00:34:21,659 --> 00:34:25,409
machines and remove the block storage

00:34:23,339 --> 00:34:27,810
layer that's probably going to work out

00:34:25,409 --> 00:34:29,790
well is to get an agreement with with

00:34:27,810 --> 00:34:33,690
your cloud provider so find some kind of

00:34:29,790 --> 00:34:37,649
simple strategy like this I can also

00:34:33,690 --> 00:34:39,899
observe that the there's a cost to

00:34:37,649 --> 00:34:42,599
heterogeneity in general I mean each

00:34:39,899 --> 00:34:46,710
component that you bring in this is not

00:34:42,599 --> 00:34:48,389
so high in a in a like a micro service

00:34:46,710 --> 00:34:51,629
world where you have autonomous teams

00:34:48,389 --> 00:34:53,790
and so forth because the teams can

00:34:51,629 --> 00:34:55,139
actually fairly autonomous in the data

00:34:53,790 --> 00:34:58,200
processing world the cost of

00:34:55,139 --> 00:35:01,140
heterogeneity heterogeneity is much

00:34:58,200 --> 00:35:02,970
higher because the data is naturally

00:35:01,140 --> 00:35:05,130
more coupled you pass data all through

00:35:02,970 --> 00:35:07,890
your organization through many teams

00:35:05,130 --> 00:35:10,829
these the privacy regulations may

00:35:07,890 --> 00:35:13,069
increase the cost of heterogeneity even

00:35:10,829 --> 00:35:13,069
more

00:35:16,000 --> 00:35:19,690
you not only need to comply with

00:35:18,070 --> 00:35:22,030
forgetting users who want to be

00:35:19,690 --> 00:35:25,930
forgotten you also need to limit the

00:35:22,030 --> 00:35:29,200
amount of time that you that you store

00:35:25,930 --> 00:35:30,760
data and I would advise you to try to

00:35:29,200 --> 00:35:32,920
solve this in your workflow manager

00:35:30,760 --> 00:35:34,590
because that's where data creation is

00:35:32,920 --> 00:35:38,950
controlled that's where data destruction

00:35:34,590 --> 00:35:41,740
also should happen make the default a

00:35:38,950 --> 00:35:43,690
short retention and do an exceptional

00:35:41,740 --> 00:35:45,220
whitelist of the exceptions rather than

00:35:43,690 --> 00:35:47,110
the other way around because if you do

00:35:45,220 --> 00:35:50,590
blacklist thing you will miss something

00:35:47,110 --> 00:35:53,830
from Peru now fortunately retention

00:35:50,590 --> 00:35:55,840
ideal or retention requirement is in

00:35:53,830 --> 00:35:57,850
conflict with the technical ideal that

00:35:55,840 --> 00:36:00,100
you'd like to keep all of the data

00:35:57,850 --> 00:36:01,510
around or forever in raw form so that

00:36:00,100 --> 00:36:06,580
you can go back in case you make

00:36:01,510 --> 00:36:10,390
mistakes and so forth so what you can do

00:36:06,580 --> 00:36:12,310
here is if you have PII a PII data set

00:36:10,390 --> 00:36:15,490
that you need to remove because of

00:36:12,310 --> 00:36:18,600
retention rules then we can take it to

00:36:15,490 --> 00:36:21,070
take the first downstream data sets and

00:36:18,600 --> 00:36:23,200
sort of promote them to your cold

00:36:21,070 --> 00:36:26,020
storage to your data like and say that

00:36:23,200 --> 00:36:27,670
we are now regarding this as the raw

00:36:26,020 --> 00:36:31,210
data we will no longer be able to

00:36:27,670 --> 00:36:34,930
reproduce it this has the advantage that

00:36:31,210 --> 00:36:37,660
the all of your workflow management bags

00:36:34,930 --> 00:36:39,820
still work as expected you know it's

00:36:37,660 --> 00:36:42,640
just a sort of a social convention that

00:36:39,820 --> 00:36:46,300
you no longer are able to discard this

00:36:42,640 --> 00:36:49,210
data and if you make this first step

00:36:46,300 --> 00:36:52,090
kind of washing and cleaning where you

00:36:49,210 --> 00:36:54,760
remove the PII data or separate the PII

00:36:52,090 --> 00:36:58,650
data then you are sort of maximizing

00:36:54,760 --> 00:37:02,560
your ability to to rerun things later

00:36:58,650 --> 00:37:05,550
there is a concept of lineage which

00:37:02,560 --> 00:37:08,740
isn't talked a lot about but it will be

00:37:05,550 --> 00:37:10,540
needed for the requirements to export

00:37:08,740 --> 00:37:12,520
all of the data to users and to

00:37:10,540 --> 00:37:13,000
enumerate all of the data we have what

00:37:12,520 --> 00:37:15,670
you have

00:37:13,000 --> 00:37:17,320
it's basically tracking data flow as it

00:37:15,670 --> 00:37:20,050
goes through the through your pipeline

00:37:17,320 --> 00:37:22,540
tags you can either these do this on a

00:37:20,050 --> 00:37:24,790
granite large of data sets and then your

00:37:22,540 --> 00:37:26,800
workflow manager is your best friend

00:37:24,790 --> 00:37:28,970
there are no ready-made tools for it but

00:37:26,800 --> 00:37:32,060
it's a good place to implement it

00:37:28,970 --> 00:37:33,920
or on the granularity of fields there

00:37:32,060 --> 00:37:36,319
are some tools how to do this I am to

00:37:33,920 --> 00:37:38,839
work with them they do is typically by

00:37:36,319 --> 00:37:42,740
instrumenting like spark or similar

00:37:38,839 --> 00:37:44,800
tools today this is done mostly for for

00:37:42,740 --> 00:37:47,839
like foreign generators pipeline change

00:37:44,800 --> 00:37:50,420
management and so forth but it's also

00:37:47,839 --> 00:37:52,700
useful concept to do when for example

00:37:50,420 --> 00:37:54,770
when tracking that personal data is

00:37:52,700 --> 00:37:58,700
leaking through datasets where it's

00:37:54,770 --> 00:38:03,170
actually not needed and I have a

00:37:58,700 --> 00:38:05,000
challenge to throw out out there I don't

00:38:03,170 --> 00:38:08,060
believe it instrumenting the frameworks

00:38:05,000 --> 00:38:10,060
is a good idea or a good place to solve

00:38:08,060 --> 00:38:12,500
these things I think they might be much

00:38:10,060 --> 00:38:14,869
more useful if you sold them inside a

00:38:12,500 --> 00:38:16,869
type system so if there are any Scala

00:38:14,869 --> 00:38:19,310
geeks in the audience this one's for you

00:38:16,869 --> 00:38:21,109
you could for example wrap your data

00:38:19,310 --> 00:38:24,140
type standard data types with an

00:38:21,109 --> 00:38:27,440
ornament them with with light pii level

00:38:24,140 --> 00:38:29,960
information and or history information

00:38:27,440 --> 00:38:31,550
to trace where the actual data comes

00:38:29,960 --> 00:38:33,380
from and build tooling around that I

00:38:31,550 --> 00:38:36,200
haven't seen any such tool so this is

00:38:33,380 --> 00:38:37,940
like a solicitation provocation to any

00:38:36,200 --> 00:38:44,420
people out there that might want to hack

00:38:37,940 --> 00:38:47,270
on this contact me if you want that's it

00:38:44,420 --> 00:38:49,670
I couldn't touch down this myself so

00:38:47,270 --> 00:38:51,619
there are a bunch of people who deserve

00:38:49,670 --> 00:38:56,690
credit for helping me with the contents

00:38:51,619 --> 00:38:59,930
of this presentation and in case you

00:38:56,690 --> 00:39:01,930
want more context on all things like

00:38:59,930 --> 00:39:05,089
building pipelines and the types of

00:39:01,930 --> 00:39:07,430
structures that I'm assuming or workflow

00:39:05,089 --> 00:39:08,960
managers or so forth there are these

00:39:07,430 --> 00:39:11,359
links up there the first one is a

00:39:08,960 --> 00:39:14,359
presentation I made last year and the

00:39:11,359 --> 00:39:16,550
second one is a likely curated déja

00:39:14,359 --> 00:39:17,859
engineering reading list contains a lot

00:39:16,550 --> 00:39:22,220
of good information

00:39:17,859 --> 00:39:23,930
the other two links are the the only

00:39:22,220 --> 00:39:27,160
material that I could find there from

00:39:23,930 --> 00:39:29,089
from like government authorities that

00:39:27,160 --> 00:39:31,099
contain some kind of practical

00:39:29,089 --> 00:39:33,410
information to help you going with this

00:39:31,099 --> 00:39:36,680
I haven't dug too far but I like the

00:39:33,410 --> 00:39:39,819
material that I saw it was solution more

00:39:36,680 --> 00:39:39,819
solution and problem oriented

00:39:41,319 --> 00:39:45,219
all right questions

00:39:46,590 --> 00:40:01,119
[Applause]

00:39:56,380 --> 00:40:01,119
we have time for one quick question

00:40:13,869 --> 00:40:19,630
thank you for the great talk I never saw

00:40:17,590 --> 00:40:21,790
any of these buttons applied in practice

00:40:19,630 --> 00:40:24,550
but I have a question on one of those

00:40:21,790 --> 00:40:25,810
you presented where you delete the day

00:40:24,550 --> 00:40:30,960
encryption key

00:40:25,810 --> 00:40:36,359
what if an user once there is their data

00:40:30,960 --> 00:40:40,060
to be recorded again but then it's ID is

00:40:36,359 --> 00:40:43,030
present associated to all data with the

00:40:40,060 --> 00:40:46,650
old encryption key and the new

00:40:43,030 --> 00:40:52,840
encryption key how do you end of that

00:40:46,650 --> 00:40:56,849
the closest answer is this where you

00:40:52,840 --> 00:41:01,240
might you might opt to give the user the

00:40:56,849 --> 00:41:04,210
decryption key in case he would like he

00:41:01,240 --> 00:41:07,660
or she would like to bring the data out

00:41:04,210 --> 00:41:09,970
again if the user has to be forgotten

00:41:07,660 --> 00:41:12,130
and you don't do this then the parent

00:41:09,970 --> 00:41:13,359
data is permanently gone there's no way

00:41:12,130 --> 00:41:15,720
to get it back does that ask you a

00:41:13,359 --> 00:41:15,720
question

00:41:34,580 --> 00:41:40,920
one day I'll deliver some sugar for the

00:41:38,580 --> 00:41:42,920
user and a new key that was generated

00:41:40,920 --> 00:41:45,420
and still associated to the same user

00:41:42,920 --> 00:41:47,700
maybe its knife problem at that's why

00:41:45,420 --> 00:41:49,320
you don't understand but are you

00:41:47,700 --> 00:41:52,440
referring to this scenario where you

00:41:49,320 --> 00:41:54,990
have multiple keys for the user even

00:41:52,440 --> 00:41:58,530
with these for example if I drop the key

00:41:54,990 --> 00:42:02,040
for just one set of TF and they want to

00:41:58,530 --> 00:42:05,040
start encrypting again with a new key

00:42:02,040 --> 00:42:08,370
because the previous one is lost how can

00:42:05,040 --> 00:42:10,620
i dissociate between the old data with

00:42:08,370 --> 00:42:12,960
the old encryption key and the new data

00:42:10,620 --> 00:42:14,550
for the same user with the new

00:42:12,960 --> 00:42:17,460
encryption key I mean for some the the

00:42:14,550 --> 00:42:20,700
corruption will fail is that enough of a

00:42:17,460 --> 00:42:22,560
criteria two outside areas okay the

00:42:20,700 --> 00:42:25,140
decryption fails maybe there was an

00:42:22,560 --> 00:42:28,010
elegant way to do so but okay these are

00:42:25,140 --> 00:42:29,790
so lucky I don't have one for you sir

00:42:28,010 --> 00:42:31,560
unfortunately we're out of time but

00:42:29,790 --> 00:42:37,599
thank you Lars

00:42:31,560 --> 00:42:37,599

YouTube URL: https://www.youtube.com/watch?v=QR3347Qr58A


