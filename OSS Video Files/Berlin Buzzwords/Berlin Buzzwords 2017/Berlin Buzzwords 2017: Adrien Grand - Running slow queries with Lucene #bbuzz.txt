Title: Berlin Buzzwords 2017: Adrien Grand - Running slow queries with Lucene #bbuzz
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	Search engines like Lucene have been designed to run full-text queries as fast as possible. You can search for combinations of keywords using boolean operators, and Lucene will give you results in milliseconds. This is possible thanks to the inverted index structure, which gives you a sorted list of ids for every term. 

Then boolean queries just have to compute the intersection or union of these sorted lists, which is a cheap operation. However in the real world, users often want to run more complicated queries like phrase queries, range queries or queries on scripts, which can't easily get you a sorted list of ids. 

In this session, we will dive into how Lucene executes queries and in particular recent improvements around execution of slow queries. No prior knowledge about Lucene is required, however users who have been exposed to Lucene, Solr or Elasticsearch in the past are more likely to enjoy this session.

Read more:
https://2017.berlinbuzzwords.de/17/session/running-slow-queries-lucene

About Adrien Grand:
https://2017.berlinbuzzwords.de/users/adrien-grand

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,650 --> 00:00:11,170
okay let's start so we are going to

00:00:07,990 --> 00:00:13,929
spend together some time talking and

00:00:11,170 --> 00:00:16,480
exploring harrassing runs through

00:00:13,929 --> 00:00:18,610
queries so that they are not too slow

00:00:16,480 --> 00:00:20,380
so before we start some background on

00:00:18,610 --> 00:00:21,970
myself I've been working in surf for

00:00:20,380 --> 00:00:24,759
some time now and in particular I've

00:00:21,970 --> 00:00:27,899
been loosing commuters in 2012 and I've

00:00:24,759 --> 00:00:30,399
been working at electric since 2013 and

00:00:27,899 --> 00:00:32,439
quarry processing is part of the things

00:00:30,399 --> 00:00:34,200
I enjoy working on so that's something

00:00:32,439 --> 00:00:37,629
that's what I'm going to talk about

00:00:34,200 --> 00:00:39,309
right now so Cory processing tends to be

00:00:37,629 --> 00:00:41,739
an interesting topic of this world

00:00:39,309 --> 00:00:45,789
earlier today we had talked by Alan wood

00:00:41,739 --> 00:00:49,359
world about how Lusine uses quarries and

00:00:45,789 --> 00:00:50,739
collect all other framework works so

00:00:49,359 --> 00:00:52,780
that you can find matches in your

00:00:50,739 --> 00:00:54,850
inverting disease and also in the past

00:00:52,780 --> 00:00:57,309
if you look at the history of talks that

00:00:54,850 --> 00:00:59,499
we had at burgers world where we already

00:00:57,309 --> 00:01:01,300
had some talks about query processing

00:00:59,499 --> 00:01:01,899
and in particular how we can make Horace

00:01:01,300 --> 00:01:05,920
faster

00:01:01,899 --> 00:01:08,850
for instance in 2015 we had to talk

00:01:05,920 --> 00:01:11,410
about using SM the instruction so simple

00:01:08,850 --> 00:01:13,330
instruction which per data include

00:01:11,410 --> 00:01:15,040
training earth speed up the decoding of

00:01:13,330 --> 00:01:17,290
postings which can be useful in order to

00:01:15,040 --> 00:01:18,940
make some queries in single combination

00:01:17,290 --> 00:01:22,810
of SAMCRO is using Google Chrome is

00:01:18,940 --> 00:01:27,160
faster and for instance in 2012 we had a

00:01:22,810 --> 00:01:29,170
lotta talk by Stephen Pohl about an

00:01:27,160 --> 00:01:31,030
algorithm which is called Mexico which

00:01:29,170 --> 00:01:33,370
can be used in order to speed up these

00:01:31,030 --> 00:01:37,570
junctions so queries that look like a or

00:01:33,370 --> 00:01:39,130
B or C or potentially more closest but

00:01:37,570 --> 00:01:41,200
today we are going to do something else

00:01:39,130 --> 00:01:43,960
something else which is talking about

00:01:41,200 --> 00:01:45,700
slow queries and Allison deals with them

00:01:43,960 --> 00:01:47,110
and I think that's especially

00:01:45,700 --> 00:01:49,960
interesting because that's something

00:01:47,110 --> 00:01:51,430
that recently started tackling about two

00:01:49,960 --> 00:01:53,230
years ago in spite of the fact that

00:01:51,430 --> 00:01:55,210
person has been have has been out for

00:01:53,230 --> 00:02:00,190
something like fifteen to twenty years

00:01:55,210 --> 00:02:02,860
now so first we need to explain what the

00:02:00,190 --> 00:02:04,780
slow query is so if you get queries the

00:02:02,860 --> 00:02:06,610
the main responsibility as far as

00:02:04,780 --> 00:02:09,190
matching is concerned let's forget

00:02:06,610 --> 00:02:11,980
scoring entirely for now is that the

00:02:09,190 --> 00:02:13,959
segment then it's produce an iterator of

00:02:11,980 --> 00:02:16,390
other cadiz and that story turn it to be

00:02:13,959 --> 00:02:18,340
indicate the order that property is very

00:02:16,390 --> 00:02:18,890
important because the fact that this

00:02:18,340 --> 00:02:21,560
stream

00:02:18,890 --> 00:02:23,959
Cady's is another Israel help realtor

00:02:21,560 --> 00:02:26,900
and efficient conjunctions so a and B

00:02:23,959 --> 00:02:31,010
and C and potentially la Cruces or the

00:02:26,900 --> 00:02:33,850
exemptions a or B or C and from the

00:02:31,010 --> 00:02:37,040
cetera does we expect that they have two

00:02:33,850 --> 00:02:39,350
properties in order to be fast first

00:02:37,040 --> 00:02:42,140
they need to be able to iterate over my

00:02:39,350 --> 00:02:44,180
cheese efficiently meaning that given a

00:02:42,140 --> 00:02:46,040
matched in the index they need to be

00:02:44,180 --> 00:02:48,680
able to very quickly find the next match

00:02:46,040 --> 00:02:51,470
to the next dog ad in the cage order

00:02:48,680 --> 00:02:53,470
that also matches degree and also they

00:02:51,470 --> 00:02:56,030
need to be able to efficiently skip

00:02:53,470 --> 00:03:00,019
overlap ranges of the cages which are

00:02:56,030 --> 00:03:01,790
not useful and that keep feature is

00:03:00,019 --> 00:03:05,060
produced especially useful for

00:03:01,790 --> 00:03:08,870
conjunctions so as you might have

00:03:05,060 --> 00:03:10,519
guessed now if your career is low it

00:03:08,870 --> 00:03:13,750
means that at least one of those two

00:03:10,519 --> 00:03:16,459
properties is not or not and actually

00:03:13,750 --> 00:03:19,130
that's where wants to do because we have

00:03:16,459 --> 00:03:20,900
two gangs of strawberries first we have

00:03:19,130 --> 00:03:23,390
decrees that concentrate efficiently and

00:03:20,900 --> 00:03:25,820
those queries will be quite like race

00:03:23,390 --> 00:03:27,709
queries and script queries the current

00:03:25,820 --> 00:03:29,780
for culture history is that they have a

00:03:27,709 --> 00:03:31,970
lot of work to do on the per document

00:03:29,780 --> 00:03:34,820
basis in order to check whether or not

00:03:31,970 --> 00:03:36,860
it matches the decree so indicator

00:03:34,820 --> 00:03:38,269
scripts you need to run the scripts if

00:03:36,860 --> 00:03:39,850
you don't run the script you can't know

00:03:38,269 --> 00:03:42,590
whether or not the document matches

00:03:39,850 --> 00:03:44,510
recurring and indicator phrases you have

00:03:42,590 --> 00:03:46,400
a lot of positions to read in order to

00:03:44,510 --> 00:03:48,680
check whether or not the two words that

00:03:46,400 --> 00:03:50,870
you're searching for can be found at

00:03:48,680 --> 00:03:52,519
consecutive positions in index

00:03:50,870 --> 00:03:55,910
okay so that's a lot of work to the

00:03:52,519 --> 00:03:58,040
document and then we have a second class

00:03:55,910 --> 00:04:00,440
of quarries which are praise that comes

00:03:58,040 --> 00:04:02,180
keep so when I said it comes keep I may

00:04:00,440 --> 00:04:05,329
be saying actually the iterator that did

00:04:02,180 --> 00:04:08,660
provide that The Scream provide it can't

00:04:05,329 --> 00:04:10,850
keep but those queries are based on data

00:04:08,660 --> 00:04:11,750
structures that make it very hard to

00:04:10,850 --> 00:04:14,450
return

00:04:11,750 --> 00:04:16,100
iterator that are in order they are very

00:04:14,450 --> 00:04:17,510
good at finding matches but they are

00:04:16,100 --> 00:04:20,630
going to produce decade is out of order

00:04:17,510 --> 00:04:22,370
and so something like loosen needs to do

00:04:20,630 --> 00:04:24,650
in order to make them see the framework

00:04:22,370 --> 00:04:26,990
if you take all those matching de cádiz

00:04:24,650 --> 00:04:29,479
then solve them so that can produce an

00:04:26,990 --> 00:04:31,190
inorder iterator but the fact that it

00:04:29,479 --> 00:04:31,710
needs to take all the matching de cádiz

00:04:31,190 --> 00:04:34,320
and

00:04:31,710 --> 00:04:35,940
for them means that dark IDs that you do

00:04:34,320 --> 00:04:38,040
not care about because you're going to

00:04:35,940 --> 00:04:42,120
skip over them in any way you also have

00:04:38,040 --> 00:04:43,950
to pay the console in so it means you

00:04:42,120 --> 00:04:46,650
can't benefit from skipping on those

00:04:43,950 --> 00:04:48,750
queries and we see that for those two

00:04:46,650 --> 00:04:53,310
can score is we have way that we can

00:04:48,750 --> 00:04:56,400
make them perform better in the general

00:04:53,310 --> 00:04:58,230
case you've already you can speed the

00:04:56,400 --> 00:04:59,790
quiz up in your cases for instance if

00:04:58,230 --> 00:05:01,410
you get right queries there is a lot we

00:04:59,790 --> 00:05:03,570
alternate you need to do on the prowl

00:05:01,410 --> 00:05:05,250
document basis and that's it if you want

00:05:03,570 --> 00:05:06,480
to find all documents that match the

00:05:05,250 --> 00:05:08,550
phrase then you need to iterate over

00:05:06,480 --> 00:05:09,060
let's say you're searching for quick and

00:05:08,550 --> 00:05:10,680
Fox

00:05:09,060 --> 00:05:12,570
you need to sign all documents that

00:05:10,680 --> 00:05:14,760
contain both we consult and then for all

00:05:12,570 --> 00:05:16,380
those documents unity check deletions so

00:05:14,760 --> 00:05:19,140
there is not really thing you can do

00:05:16,380 --> 00:05:20,760
however in some case some cases we're

00:05:19,140 --> 00:05:22,590
going to see that especially when they

00:05:20,760 --> 00:05:25,260
are used in conjunctions we can make

00:05:22,590 --> 00:05:28,200
things better and in order to explain

00:05:25,260 --> 00:05:32,220
why I need to first explain to you how

00:05:28,200 --> 00:05:36,120
conjunction aware so like I said loosen

00:05:32,220 --> 00:05:38,310
is about producing 3m queries are about

00:05:36,120 --> 00:05:40,230
producing salty traitors the segment

00:05:38,310 --> 00:05:42,090
overall the matching blockages so in

00:05:40,230 --> 00:05:44,160
that case we have two terms quick and

00:05:42,090 --> 00:05:46,440
socks and we want to find all documents

00:05:44,160 --> 00:05:49,740
that contain both terms so both quick

00:05:46,440 --> 00:05:51,030
and Fox when you seen wants to run a

00:05:49,740 --> 00:05:53,340
conjunction the first thing we're going

00:05:51,030 --> 00:05:55,860
to do is to look at index tactics in a

00:05:53,340 --> 00:05:58,680
lot figure out which one of the closest

00:05:55,860 --> 00:06:01,170
has the least number of matches in that

00:05:58,680 --> 00:06:02,880
case it it's quick and that particular

00:06:01,170 --> 00:06:03,960
Clause is going to be used in order to

00:06:02,880 --> 00:06:06,060
read each iteration

00:06:03,960 --> 00:06:07,970
okay that's going to be helpful in order

00:06:06,060 --> 00:06:11,190
to do as little work as possible and

00:06:07,970 --> 00:06:13,440
basically the next step is to put a

00:06:11,190 --> 00:06:15,060
litter 800 versus posting list which

00:06:13,440 --> 00:06:17,400
will presented by the blue arrow that

00:06:15,060 --> 00:06:20,430
you can see there and then iteratively

00:06:17,400 --> 00:06:21,990
we are going to first we're going to

00:06:20,430 --> 00:06:24,450
start iterating using the clue that

00:06:21,990 --> 00:06:26,520
matches the least number of documents

00:06:24,450 --> 00:06:28,650
and then we are going to use both are

00:06:26,520 --> 00:06:29,970
closest as follow-up in order to check

00:06:28,650 --> 00:06:32,220
whether or not the match the same

00:06:29,970 --> 00:06:33,900
document so first we advanced the soft

00:06:32,220 --> 00:06:36,480
close to the first matching document

00:06:33,900 --> 00:06:38,810
request to and then we asked other

00:06:36,480 --> 00:06:41,230
closes in that case we only have one

00:06:38,810 --> 00:06:42,970
document that match box

00:06:41,230 --> 00:06:45,040
to move to the next document that

00:06:42,970 --> 00:06:48,010
greater than or equal to two that also

00:06:45,040 --> 00:06:49,300
contains flux and we moved to 3 3 is

00:06:48,010 --> 00:06:51,370
greater than 2 so we know we don't have

00:06:49,300 --> 00:06:53,050
a match in two so then we need to go

00:06:51,370 --> 00:06:55,660
back to the first person list and ask it

00:06:53,050 --> 00:06:57,610
what the third document you have said

00:06:55,660 --> 00:06:58,840
greater than or equal to three and that

00:06:57,610 --> 00:07:00,970
time we figured that we have a match

00:06:58,840 --> 00:07:03,070
because or postings are positioned on

00:07:00,970 --> 00:07:06,880
the same location we have a match and

00:07:03,070 --> 00:07:10,480
then we keep doing that until we find

00:07:06,880 --> 00:07:13,810
all the matches in that are contained by

00:07:10,480 --> 00:07:15,460
both person list and the best object

00:07:13,810 --> 00:07:17,020
that we use for conjunctions is very

00:07:15,460 --> 00:07:19,810
efficient because in spite of the fact

00:07:17,020 --> 00:07:21,130
that we had I counted that I don't

00:07:19,810 --> 00:07:23,920
remember exactly but we have something

00:07:21,130 --> 00:07:25,780
like 15 matching de cádiz in total we

00:07:23,920 --> 00:07:28,240
only needed to move the clubs or seven

00:07:25,780 --> 00:07:31,000
times okay for those costumes so that's

00:07:28,240 --> 00:07:33,100
what makes conjunctions efficient and

00:07:31,000 --> 00:07:35,140
you might be wondering how can this be

00:07:33,100 --> 00:07:36,340
efficient because in order to find the

00:07:35,140 --> 00:07:39,430
spell document for instance that

00:07:36,340 --> 00:07:41,230
president or equal to 50 we have to go

00:07:39,430 --> 00:07:43,270
over a lot of documents but posting

00:07:41,230 --> 00:07:45,430
lists the embed something that is called

00:07:43,270 --> 00:07:48,610
a skip list which can be used not to

00:07:45,430 --> 00:07:52,690
efficiently skip over documents that are

00:07:48,610 --> 00:07:55,000
not needy so the operations efficient in

00:07:52,690 --> 00:07:57,760
that algorithm which we just described

00:07:55,000 --> 00:07:59,140
is called default so you might already

00:07:57,760 --> 00:08:02,470
have read buta that we've seen

00:07:59,140 --> 00:08:04,270
conjunctions and so if you if you read

00:08:02,470 --> 00:08:06,760
about it progress that the recent

00:08:04,270 --> 00:08:12,010
algorithm which I just described which

00:08:06,760 --> 00:08:13,660
is result so that's hype graph in the

00:08:12,010 --> 00:08:15,760
best case okay we are an in conjunction

00:08:13,660 --> 00:08:18,190
over two fast queries which are

00:08:15,760 --> 00:08:20,550
tempering thumb coils which directly

00:08:18,190 --> 00:08:23,350
encode the result set in general index

00:08:20,550 --> 00:08:25,030
using postings but sometimes we have

00:08:23,350 --> 00:08:27,010
three iterators so like we said before

00:08:25,030 --> 00:08:29,650
things like read queries and script

00:08:27,010 --> 00:08:31,360
queries for instance let's imagine that

00:08:29,650 --> 00:08:33,669
you want to find all documents that

00:08:31,360 --> 00:08:35,650
contain two and B at Kentucky's position

00:08:33,669 --> 00:08:38,140
that were is going to be multiplied

00:08:35,650 --> 00:08:41,080
expensive due to the SAG that twin B 2

00:08:38,140 --> 00:08:42,010
and we can write activist found in many

00:08:41,080 --> 00:08:44,980
documents

00:08:42,010 --> 00:08:47,230
so there are many many times you have to

00:08:44,980 --> 00:08:48,940
read position not to check whether the

00:08:47,230 --> 00:08:50,980
documents that contain both two and B

00:08:48,940 --> 00:08:53,740
actually contain them at consecutive

00:08:50,980 --> 00:08:56,170
positions which means that if you want

00:08:53,740 --> 00:08:57,519
to prevent an iterator for that

00:08:56,170 --> 00:08:58,000
particular grade is going to be very

00:08:57,519 --> 00:08:59,920
expensive

00:08:58,000 --> 00:09:01,660
because a mini document is going to have

00:08:59,920 --> 00:09:03,970
to reposition in order to check whether

00:09:01,660 --> 00:09:07,120
or not the document you're looking at

00:09:03,970 --> 00:09:08,889
match it or not we said we are

00:09:07,120 --> 00:09:10,300
interested in conjunctions so in that

00:09:08,889 --> 00:09:12,730
particular case we are going I'm going

00:09:10,300 --> 00:09:15,339
to take an example where the user wants

00:09:12,730 --> 00:09:17,680
to find all documents that contain both

00:09:15,339 --> 00:09:19,209
Shakespeare and twin B as a phrase

00:09:17,680 --> 00:09:22,360
quarry meaning they should be found at

00:09:19,209 --> 00:09:24,250
consecutive positions so we have

00:09:22,360 --> 00:09:25,870
something like that where again we are

00:09:24,250 --> 00:09:28,230
going to use Samuel algorithm the

00:09:25,870 --> 00:09:31,779
leapfrog algorithm in odds I imagine

00:09:28,230 --> 00:09:34,120
first so we have Shakespeare which is

00:09:31,779 --> 00:09:36,339
which can be found in fewer documents so

00:09:34,120 --> 00:09:39,430
we are going to use it as a leader first

00:09:36,339 --> 00:09:41,260
we advance it we under control and then

00:09:39,430 --> 00:09:43,570
we ask to be to find the sales document

00:09:41,260 --> 00:09:46,149
that greater than or equal to one so

00:09:43,570 --> 00:09:48,880
first weapons to two but vary which

00:09:46,149 --> 00:09:51,100
contains both 20 but actually even

00:09:48,880 --> 00:09:52,839
though it contains both terms those two

00:09:51,100 --> 00:09:54,670
terms can be found at consecutive

00:09:52,839 --> 00:09:56,350
positions so we move to the next

00:09:54,670 --> 00:09:58,540
document that contain both terms and

00:09:56,350 --> 00:10:01,720
again it doesn't match until we reach

00:09:58,540 --> 00:10:03,940
five where the SU terms can be found at

00:10:01,720 --> 00:10:05,980
consecutive positions you might be

00:10:03,940 --> 00:10:08,560
thinking what pity that we checked

00:10:05,980 --> 00:10:10,240
positions on documents that did not end

00:10:08,560 --> 00:10:10,959
up matching but actually even for the

00:10:10,240 --> 00:10:12,639
Qin side

00:10:10,959 --> 00:10:14,889
it's a pity that we had to check

00:10:12,639 --> 00:10:17,139
positions because document size does not

00:10:14,889 --> 00:10:19,079
matter Shakespeare and it will be much

00:10:17,139 --> 00:10:21,430
cheaper if we are able to check that

00:10:19,079 --> 00:10:23,829
that particular document document side

00:10:21,430 --> 00:10:25,269
doesn't contain Shakespeare before we

00:10:23,829 --> 00:10:26,949
start taking positions which is

00:10:25,269 --> 00:10:31,510
something which is with wise conclusion

00:10:26,949 --> 00:10:32,860
and that the reason why in some 5.1 so

00:10:31,510 --> 00:10:34,269
about two years ago we introduced

00:10:32,860 --> 00:10:37,000
something which is called two-faced

00:10:34,269 --> 00:10:40,329
duration and two phase iteration allows

00:10:37,000 --> 00:10:42,519
the iterator over to be at the phrase to

00:10:40,329 --> 00:10:44,740
be fit into two components one of them

00:10:42,519 --> 00:10:46,540
is an approximation which matches a

00:10:44,740 --> 00:10:49,269
superset of the documents that would

00:10:46,540 --> 00:10:51,310
match the three phrase and that

00:10:49,269 --> 00:10:52,910
approximation indicated fresco is that

00:10:51,310 --> 00:10:55,070
also document

00:10:52,910 --> 00:10:57,110
moved to Mb and then we have

00:10:55,070 --> 00:10:59,270
confirmation step which is going to

00:10:57,110 --> 00:11:01,640
reposition in order to confirm whether

00:10:59,270 --> 00:11:05,270
or not a particular document contains

00:11:01,640 --> 00:11:07,610
both terms at consecutive positions just

00:11:05,270 --> 00:11:09,950
to be clear that the way that first

00:11:07,610 --> 00:11:11,960
queries have always worked but the

00:11:09,950 --> 00:11:14,390
things that we introduced in racine 5.1

00:11:11,960 --> 00:11:16,850
is the ability through a new you through

00:11:14,390 --> 00:11:21,440
a new API to execute the approximation

00:11:16,850 --> 00:11:23,270
and the confirmation sobriety and that

00:11:21,440 --> 00:11:25,070
new API can be very useful when you're

00:11:23,270 --> 00:11:27,350
in conjunction because that means that

00:11:25,070 --> 00:11:29,330
you can reach agreement between all

00:11:27,350 --> 00:11:31,310
approximations before you start

00:11:29,330 --> 00:11:34,550
executing the costly bits such as

00:11:31,310 --> 00:11:36,770
breeding positions running a script it's

00:11:34,550 --> 00:11:39,710
wrong any addition to that we have a

00:11:36,770 --> 00:11:42,950
magical API so that you can run the chip

00:11:39,710 --> 00:11:44,810
of its belt so let's think about an even

00:11:42,950 --> 00:11:46,790
more complicated query where you want to

00:11:44,810 --> 00:11:49,580
find all documents that both match a

00:11:46,790 --> 00:11:51,170
script and contain the phrase first we

00:11:49,580 --> 00:11:53,450
are going to assign all human that in

00:11:51,170 --> 00:11:54,890
veins to terms of the phrase and then we

00:11:53,450 --> 00:11:57,140
are going to look at the match cast API

00:11:54,890 --> 00:11:58,430
of both the script and the phrase and

00:11:57,140 --> 00:12:00,790
depending on which one is white

00:11:58,430 --> 00:12:05,320
offensive we are going to run the least

00:12:00,790 --> 00:12:08,870
expensive one cell so that's it folks

00:12:05,320 --> 00:12:11,150
for the first iteration so just to give

00:12:08,870 --> 00:12:13,250
a couple examples so we just talked

00:12:11,150 --> 00:12:14,690
about right grace which split the

00:12:13,250 --> 00:12:17,690
approximation in the confirmation into

00:12:14,690 --> 00:12:19,840
in conjunction and an additional step

00:12:17,690 --> 00:12:22,400
that checks position but that also

00:12:19,840 --> 00:12:24,050
generalizes well with crypt queries in

00:12:22,400 --> 00:12:25,970
the case of the pre pre the

00:12:24,050 --> 00:12:28,400
approximation would be simply equate

00:12:25,970 --> 00:12:29,900
that matches all documents and as a

00:12:28,400 --> 00:12:32,110
confirmation we are going to executor

00:12:29,900 --> 00:12:35,930
scripts to check whether or not the

00:12:32,110 --> 00:12:37,670
cream matches the script and then we

00:12:35,930 --> 00:12:40,340
have common queries like boolean queries

00:12:37,670 --> 00:12:42,110
constants of curries that propagates a

00:12:40,340 --> 00:12:44,510
trade off so that let's imagine that you

00:12:42,110 --> 00:12:47,510
have a very complex query at the deepest

00:12:44,510 --> 00:12:49,400
level you have a price query and at the

00:12:47,510 --> 00:12:51,050
top level you have a future which is a

00:12:49,400 --> 00:12:53,570
very fast desire

00:12:51,050 --> 00:12:54,890
if you don't return the fact that will

00:12:53,570 --> 00:12:57,800
increase in cost and conquer is

00:12:54,890 --> 00:12:59,450
propagated iterators means that you're

00:12:57,800 --> 00:13:01,400
only going to check whether the phrase

00:12:59,450 --> 00:13:03,920
matches on document that also match the

00:13:01,400 --> 00:13:05,870
double feature okay so that's

00:13:03,920 --> 00:13:06,320
optimization does not only apply to a

00:13:05,870 --> 00:13:10,610
single

00:13:06,320 --> 00:13:14,420
junction eater to propagate a let's face

00:13:10,610 --> 00:13:23,660
it traitor add to the top of the tree

00:13:14,420 --> 00:13:25,250
the criteria so that's it for the first

00:13:23,660 --> 00:13:28,490
iteration and now we are going to talk

00:13:25,250 --> 00:13:32,450
about the second-class Astro queries

00:13:28,490 --> 00:13:35,690
which are Korea that can't keep and I'm

00:13:32,450 --> 00:13:36,920
talking about that one I at the second

00:13:35,690 --> 00:13:39,550
step because that one actually

00:13:36,920 --> 00:13:43,160
increments on the improvements that we

00:13:39,550 --> 00:13:45,230
we made it with to face duration so that

00:13:43,160 --> 00:13:47,570
I need to explain why the queries are

00:13:45,230 --> 00:13:50,300
flew so if you get at three that's

00:13:47,570 --> 00:13:52,730
something that's very similar to because

00:13:50,300 --> 00:13:54,680
III a single dimension we carry three

00:13:52,730 --> 00:13:57,320
which is a data structure that we are

00:13:54,680 --> 00:13:59,570
using with point in electron range

00:13:57,320 --> 00:14:01,460
queries on the right field so basically

00:13:59,570 --> 00:14:04,250
you have a tree where underneath you

00:14:01,460 --> 00:14:07,340
have pair that consists of the dark ID

00:14:04,250 --> 00:14:09,830
and an adage identify of the document as

00:14:07,340 --> 00:14:12,620
well as the value that associated with

00:14:09,830 --> 00:14:15,140
the document and then the tree is going

00:14:12,620 --> 00:14:17,090
to be organized by value and on every

00:14:15,140 --> 00:14:19,040
inner node of the tree we are going to

00:14:17,090 --> 00:14:21,170
record the range of values that can be

00:14:19,040 --> 00:14:23,090
found on leaves and the other part our

00:14:21,170 --> 00:14:25,700
node so that one stems at the root level

00:14:23,090 --> 00:14:28,460
you can know that all values contained

00:14:25,700 --> 00:14:30,500
is at three are all within 10 and 40 on

00:14:28,460 --> 00:14:34,160
the left and the 3 all values are within

00:14:30,500 --> 00:14:35,990
10 and 20 on the right 20 40 etc so you

00:14:34,160 --> 00:14:38,390
can see how this data structure is very

00:14:35,990 --> 00:14:40,160
efficient at finding all documents at

00:14:38,390 --> 00:14:43,430
natural range because as you work down

00:14:40,160 --> 00:14:45,500
the tree you can quickly eliminate path

00:14:43,430 --> 00:14:46,820
of the trees that are never going to

00:14:45,500 --> 00:14:48,920
match because there is no intersection

00:14:46,820 --> 00:14:51,980
with the range of your correct okay so

00:14:48,920 --> 00:14:53,960
that the data structure that were using

00:14:51,980 --> 00:14:57,560
you know to exceed range queries we

00:14:53,960 --> 00:14:59,720
receive but because it's organized by

00:14:57,560 --> 00:15:01,190
value in the back of the Heidi let's

00:14:59,720 --> 00:15:02,660
imagine that you still have the data

00:15:01,190 --> 00:15:04,820
structure and you want to check whether

00:15:02,660 --> 00:15:07,760
or not document size for instance

00:15:04,820 --> 00:15:10,130
messages are occurring there is no way

00:15:07,760 --> 00:15:11,780
that you can know which branch of the

00:15:10,130 --> 00:15:14,030
tree you should follow in a design

00:15:11,780 --> 00:15:16,190
document size which means that Jesus a

00:15:14,030 --> 00:15:17,209
structure is very good at signing all

00:15:16,190 --> 00:15:19,279
documents the

00:15:17,209 --> 00:15:21,980
metrand which is very bad at verifying

00:15:19,279 --> 00:15:25,730
whether a very small set of documents

00:15:21,980 --> 00:15:27,679
matter range which means that if you are

00:15:25,730 --> 00:15:29,839
on a query that looks like that so you

00:15:27,679 --> 00:15:32,480
have a very restricted query such as

00:15:29,839 --> 00:15:35,089
occur in an ID field okay on the one

00:15:32,480 --> 00:15:37,610
hand and on the other hand you have a

00:15:35,089 --> 00:15:39,019
numeric range query on a very larger

00:15:37,610 --> 00:15:41,569
range which is likely to match many

00:15:39,019 --> 00:15:44,029
documents in spite of the fact that the

00:15:41,569 --> 00:15:46,069
left side of the equation matches only

00:15:44,029 --> 00:15:48,850
one document you're going to pay the

00:15:46,069 --> 00:15:51,350
price for collecting all the matches

00:15:48,850 --> 00:15:53,569
okay using the trick collect ultimate

00:15:51,350 --> 00:15:55,759
cheese for the wrench GUI before you can

00:15:53,569 --> 00:15:59,439
start running intersection between the

00:15:55,759 --> 00:16:01,910
stories and that's what makes it slow

00:15:59,439 --> 00:16:03,860
but there's another way that we can run

00:16:01,910 --> 00:16:05,059
range queries with the scene and in

00:16:03,860 --> 00:16:06,619
particular we have another data

00:16:05,059 --> 00:16:09,139
structure that we can encode in the

00:16:06,619 --> 00:16:10,189
index which is called dog values and if

00:16:09,139 --> 00:16:13,369
you are not familiar with the values

00:16:10,189 --> 00:16:15,829
that the sense name that just means that

00:16:13,369 --> 00:16:17,420
we have a way to store a columnar

00:16:15,829 --> 00:16:19,579
representation of your data in the index

00:16:17,420 --> 00:16:22,040
and that columnar presentation can be

00:16:19,579 --> 00:16:24,139
used to run your engine queries using to

00:16:22,040 --> 00:16:25,999
face iteration which we just talked

00:16:24,139 --> 00:16:28,249
about so other approximation we are

00:16:25,999 --> 00:16:30,350
going to use a query that matches

00:16:28,249 --> 00:16:32,540
everything a natural just like we did

00:16:30,350 --> 00:16:34,160
saw script and as a confirmation we are

00:16:32,540 --> 00:16:36,230
going to use our values in order to read

00:16:34,160 --> 00:16:38,350
the value so I'll touch the document and

00:16:36,230 --> 00:16:41,569
check whether or not it's in the range

00:16:38,350 --> 00:16:44,209
just to be clear using this kind of

00:16:41,569 --> 00:16:48,470
query based on the values to run ranges

00:16:44,209 --> 00:16:50,749
all the time is axis in a majority of

00:16:48,470 --> 00:16:52,939
cases bad ID because if you want to find

00:16:50,749 --> 00:16:54,529
all documents that match arranged you

00:16:52,939 --> 00:16:56,809
have no choice but to do a linear scan

00:16:54,529 --> 00:16:58,459
so we need every possible document in

00:16:56,809 --> 00:17:00,559
your index and check whether or not it's

00:16:58,459 --> 00:17:02,179
in the range okay which is something we

00:17:00,559 --> 00:17:04,399
need to avoid the previous data

00:17:02,179 --> 00:17:06,819
structure is a tree we just saw is much

00:17:04,399 --> 00:17:09,020
better at signing all the matches

00:17:06,819 --> 00:17:12,230
however things are will be different

00:17:09,020 --> 00:17:15,079
when you use a range in a conjunction in

00:17:12,230 --> 00:17:17,209
particular if use points so let's say

00:17:15,079 --> 00:17:20,029
that you have a very simple query that

00:17:17,209 --> 00:17:22,730
looks like a thumb query which is

00:17:20,029 --> 00:17:25,220
intersected to temporary and arranged

00:17:22,730 --> 00:17:28,279
goron what's going to be the cost of

00:17:25,220 --> 00:17:30,000
running that whole crane depending on

00:17:28,279 --> 00:17:32,250
how the range

00:17:30,000 --> 00:17:34,440
is implemented if you are using points

00:17:32,250 --> 00:17:36,770
basically the cost of that grade is

00:17:34,440 --> 00:17:40,170
going to be driven by the cost of

00:17:36,770 --> 00:17:41,580
signing all the matches or the range so

00:17:40,170 --> 00:17:43,170
basically the cost is going to get in

00:17:41,580 --> 00:17:45,930
there with the total number of documents

00:17:43,170 --> 00:17:48,090
that match drain the range on the other

00:17:45,930 --> 00:17:49,830
hand different if you use that values in

00:17:48,090 --> 00:17:51,600
order to implement the range what person

00:17:49,830 --> 00:17:53,250
is going to do with the iteration is

00:17:51,600 --> 00:17:55,380
that it's going to iterate over all the

00:17:53,250 --> 00:17:56,820
matches of the dum curry and check

00:17:55,380 --> 00:17:59,160
whether or not they match the range with

00:17:56,820 --> 00:18:01,050
the values so that time the cost is a

00:17:59,160 --> 00:18:02,990
number of check document which is a

00:18:01,050 --> 00:18:07,530
number of documents of zelda crews of

00:18:02,990 --> 00:18:10,500
the conjunction and as you can imagine

00:18:07,530 --> 00:18:11,760
there are cases when using points is

00:18:10,500 --> 00:18:14,460
going to be cheaper and there are cases

00:18:11,760 --> 00:18:18,600
when using duct values givenchy to be

00:18:14,460 --> 00:18:21,060
cheaper and so how can we decide which

00:18:18,600 --> 00:18:23,100
one to use an innocent side six point

00:18:21,060 --> 00:18:25,530
five story which has been released and

00:18:23,100 --> 00:18:27,720
earlier this year we added a new query

00:18:25,530 --> 00:18:28,470
which is used index order value screen

00:18:27,720 --> 00:18:32,670
oops

00:18:28,470 --> 00:18:34,140
there's a typo forego that which is

00:18:32,670 --> 00:18:36,840
going to look at indexed artistics

00:18:34,140 --> 00:18:38,580
in a lot of free art which strategy to

00:18:36,840 --> 00:18:42,390
introduce in order to executive range

00:18:38,580 --> 00:18:44,910
glory and essentially is going to use at

00:18:42,390 --> 00:18:47,190
the point gory which to which we added a

00:18:44,910 --> 00:18:48,840
new api that it can estimate how many

00:18:47,190 --> 00:18:50,640
documents are going to match just by

00:18:48,840 --> 00:18:53,010
looking at the tree which can be done

00:18:50,640 --> 00:18:54,840
cheaply and then it looks at all the

00:18:53,010 --> 00:18:57,210
components of the conjunction and

00:18:54,840 --> 00:18:58,800
basically if the range is going to be

00:18:57,210 --> 00:19:00,390
the clothes that has the least number of

00:18:58,800 --> 00:19:02,190
documents which means it's going to

00:19:00,390 --> 00:19:04,590
drive iteration then we are going to

00:19:02,190 --> 00:19:06,810
this point which are much better better

00:19:04,590 --> 00:19:09,360
data structure in oxide or the matches

00:19:06,810 --> 00:19:11,640
for modular quarry but on the other hand

00:19:09,360 --> 00:19:13,500
if the range GUI is not going to drive

00:19:11,640 --> 00:19:15,330
the direction and only going to be used

00:19:13,500 --> 00:19:17,910
to check whether the documents from

00:19:15,330 --> 00:19:22,320
other classes match the entire boolean

00:19:17,910 --> 00:19:25,140
cream then we should use the values so

00:19:22,320 --> 00:19:27,270
that works well theory which is still

00:19:25,140 --> 00:19:29,760
important to run a benchmark just to

00:19:27,270 --> 00:19:32,190
make sure it works as expected and so

00:19:29,760 --> 00:19:35,480
when we open that you we we run

00:19:32,190 --> 00:19:37,309
benchmark over a deal 310 million

00:19:35,480 --> 00:19:39,320
subsets

00:19:37,309 --> 00:19:41,360
of Wikipedia that hide in Pascal body

00:19:39,320 --> 00:19:45,289
field where you have the content of the

00:19:41,360 --> 00:19:48,409
article and they'd feel that the last 20

00:19:45,289 --> 00:19:49,850
caption date of the article and then

00:19:48,409 --> 00:19:52,909
I've been running crazy to correct that

00:19:49,850 --> 00:19:55,309
so a term query on the body intersected

00:19:52,909 --> 00:19:57,830
with arranged away on the last by

00:19:55,309 --> 00:19:59,389
decision date and I've been putting the

00:19:57,830 --> 00:20:02,210
latency of degree so the entire gwee

00:19:59,389 --> 00:20:04,039
enquiry hunkering end range query based

00:20:02,210 --> 00:20:07,159
on the total number of documents that

00:20:04,039 --> 00:20:08,330
the range matches so we're looking at

00:20:07,159 --> 00:20:10,820
next slide

00:20:08,330 --> 00:20:14,679
beware that it's using a logarithmic

00:20:10,820 --> 00:20:17,330
scale both on the x and y axis and

00:20:14,679 --> 00:20:20,059
here's what gave so that actually the

00:20:17,330 --> 00:20:21,080
first test which I ran and as you can

00:20:20,059 --> 00:20:23,539
see so here

00:20:21,080 --> 00:20:26,299
so let's start with a simple one to W

00:20:23,539 --> 00:20:28,159
line which is the Green Line so it's a

00:20:26,299 --> 00:20:31,369
bit hard to read but the real line is

00:20:28,159 --> 00:20:33,350
this one ok so we can see that the cost

00:20:31,369 --> 00:20:35,119
is always the same no matter how many

00:20:33,350 --> 00:20:36,889
documents match the range for you and

00:20:35,119 --> 00:20:39,230
that actually expected because like we

00:20:36,889 --> 00:20:41,149
said before we look back with our values

00:20:39,230 --> 00:20:43,639
the way that the rent go were with

00:20:41,149 --> 00:20:45,350
horizontal up we work with that we are

00:20:43,639 --> 00:20:47,330
going to iterate over all the matches

00:20:45,350 --> 00:20:49,100
for the jumper E and check the values

00:20:47,330 --> 00:20:51,289
range so the number of document that

00:20:49,100 --> 00:20:53,629
match the range doesn't actually matter

00:20:51,289 --> 00:20:57,259
which is confirmed by this metric much

00:20:53,629 --> 00:21:00,529
mark now if you get points which are the

00:20:57,259 --> 00:21:03,080
proper line so which is here then we

00:21:00,529 --> 00:21:05,539
said that the cost of the green curry is

00:21:03,080 --> 00:21:07,039
mostly dependent on the total number of

00:21:05,539 --> 00:21:08,210
document that matched the range and

00:21:07,039 --> 00:21:10,460
again

00:21:08,210 --> 00:21:12,740
expect here which I'm going to talk a

00:21:10,460 --> 00:21:14,389
bit about later we have indeed a

00:21:12,740 --> 00:21:16,129
relationship between the number of

00:21:14,389 --> 00:21:18,559
documents that match the range which is

00:21:16,129 --> 00:21:20,059
here expressed as a percentage of the

00:21:18,559 --> 00:21:24,879
total number of documents in the index

00:21:20,059 --> 00:21:29,720
and enter latency which is on the y-axis

00:21:24,879 --> 00:21:31,279
and we are perfect in that case that the

00:21:29,720 --> 00:21:33,080
new index of the values query that we

00:21:31,279 --> 00:21:34,639
worked on which is a blue line so it

00:21:33,080 --> 00:21:38,090
again how to read but that would be that

00:21:34,639 --> 00:21:40,369
line actually makes the perfect decision

00:21:38,090 --> 00:21:43,129
in loquacious and before that threshold

00:21:40,369 --> 00:21:44,960
which is the number of documents that

00:21:43,129 --> 00:21:47,570
match the term query is going to use

00:21:44,960 --> 00:21:49,460
points which are more efficient when it

00:21:47,570 --> 00:21:49,940
comes driving iteration of the

00:21:49,460 --> 00:21:51,890
conjunction

00:21:49,940 --> 00:21:53,990
but afterwards is going to use the

00:21:51,890 --> 00:21:56,000
values which that we saw are more

00:21:53,990 --> 00:21:57,890
efficient when it comes to only checking

00:21:56,000 --> 00:22:05,570
whether document that matter term for

00:21:57,890 --> 00:22:07,610
ultimate range and again it it brings

00:22:05,570 --> 00:22:11,270
some interesting speed ups so it's hard

00:22:07,610 --> 00:22:13,580
to to realize due to the regarding scale

00:22:11,270 --> 00:22:14,210
but here what we observe is actually a

00:22:13,580 --> 00:22:19,460
thirty times

00:22:14,210 --> 00:22:22,580
speeder which is significant and okay so

00:22:19,460 --> 00:22:25,030
that thing we see here is actually due

00:22:22,580 --> 00:22:29,000
to an optimization we have with points

00:22:25,030 --> 00:22:30,770
because when we match both the modern

00:22:29,000 --> 00:22:31,970
houses index we have an optimization so

00:22:30,770 --> 00:22:34,820
that we are going to compute all

00:22:31,970 --> 00:22:37,580
document I do not match another enjoy

00:22:34,820 --> 00:22:39,950
any of that and the optimization that

00:22:37,580 --> 00:22:43,520
index or W Square performs is not aware

00:22:39,950 --> 00:22:46,180
of that optimization but unfortunately

00:22:43,520 --> 00:22:48,890
things are not always at that good and

00:22:46,180 --> 00:22:50,750
this is a same benchmark stem data set

00:22:48,890 --> 00:22:53,330
the only thing which I changed here is

00:22:50,750 --> 00:22:55,150
that I replace the term from the

00:22:53,330 --> 00:22:57,680
temporary with another term which is

00:22:55,150 --> 00:22:59,660
previously it matched Jo point one

00:22:57,680 --> 00:23:01,460
percent of the index and this time is

00:22:59,660 --> 00:23:03,160
matching one percent of documents in the

00:23:01,460 --> 00:23:05,390
index and this time you can see that

00:23:03,160 --> 00:23:07,940
where are ways making the right decision

00:23:05,390 --> 00:23:11,000
okay so because we are switching at one

00:23:07,940 --> 00:23:12,470
percent between points in purple and the

00:23:11,000 --> 00:23:15,350
values here in spite of the fact that

00:23:12,470 --> 00:23:16,970
point after more efficient then the

00:23:15,350 --> 00:23:20,090
values up to something like eight

00:23:16,970 --> 00:23:22,040
percent of index and similarly due to

00:23:20,090 --> 00:23:25,250
the optimization we have for in jizan

00:23:22,040 --> 00:23:27,050
points points again become faster than

00:23:25,250 --> 00:23:34,270
the values when you have more than

00:23:27,050 --> 00:23:34,270
something like eighty percent matches so

00:23:35,230 --> 00:23:41,270
other confusional this optimization

00:23:39,140 --> 00:23:43,250
tends to be good on average but

00:23:41,270 --> 00:23:46,250
unfortunately it can make the wrong

00:23:43,250 --> 00:23:48,290
decision sometimes and that's something

00:23:46,250 --> 00:23:50,750
that I would personally like to see the

00:23:48,290 --> 00:23:53,060
it's hard okay we're working near sticks

00:23:50,750 --> 00:23:54,530
and we are trying to compare costs of

00:23:53,060 --> 00:23:57,260
different quarries even though they do

00:23:54,530 --> 00:23:59,750
very different operations which makes it

00:23:57,260 --> 00:24:01,310
very challenging

00:23:59,750 --> 00:24:03,260
I've been describing these optimizations

00:24:01,310 --> 00:24:05,090
orangeberries electorate we are exactly

00:24:03,260 --> 00:24:07,520
the same way for do queries in Tusculum

00:24:05,090 --> 00:24:10,490
bounding box queries and your distant

00:24:07,520 --> 00:24:12,980
queries which work exactly the same way

00:24:10,490 --> 00:24:14,540
as a range queries on one dimension

00:24:12,980 --> 00:24:17,480
they are just generalization from

00:24:14,540 --> 00:24:20,120
whisper dimension and there are still

00:24:17,480 --> 00:24:22,940
things to do so like I said the

00:24:20,120 --> 00:24:25,730
heuristic still needs improving because

00:24:22,940 --> 00:24:27,980
sometimes it make the wrong decision but

00:24:25,730 --> 00:24:29,870
she is a welcome if you have ideas how

00:24:27,980 --> 00:24:32,720
to speak that and there are some queries

00:24:29,870 --> 00:24:34,730
that we'd also like to fix so for

00:24:32,720 --> 00:24:36,440
instance prefix way card and regression

00:24:34,730 --> 00:24:39,350
based queries have the same issue that

00:24:36,440 --> 00:24:41,150
they can't keep efficiently they need to

00:24:39,350 --> 00:24:44,120
collect all the matches before you can

00:24:41,150 --> 00:24:47,570
start doing anywhere on the rkd set

00:24:44,120 --> 00:24:49,370
because wind sorting and we also don't

00:24:47,570 --> 00:24:50,840
have rent codes or range filled the

00:24:49,370 --> 00:24:52,100
ranks I'm not sure if you're familiar

00:24:50,840 --> 00:24:53,360
with the wrench fields that that's

00:24:52,100 --> 00:24:56,060
something that we introduced in loosing

00:24:53,360 --> 00:24:58,250
6.1 I think that's the ability to index

00:24:56,060 --> 00:25:00,320
range and then to sell for over a pure

00:24:58,250 --> 00:25:03,350
overlapping ranges so let's say that

00:25:00,320 --> 00:25:05,540
windex range which consists of 0 to 2 if

00:25:03,350 --> 00:25:07,310
you serve for 1 to 5 then this is going

00:25:05,540 --> 00:25:09,200
to intersect so there is a match if you

00:25:07,310 --> 00:25:13,120
sell for 10 to 12 not going to intersect

00:25:09,200 --> 00:25:15,500
so you're not going to have a match and

00:25:13,120 --> 00:25:17,210
the main reason why we haven't done that

00:25:15,500 --> 00:25:19,340
suffice that we do not have the greatest

00:25:17,210 --> 00:25:20,810
report for range fear so far which is

00:25:19,340 --> 00:25:24,770
again something that we could think

00:25:20,810 --> 00:25:27,620
about adding that's everything I wanted

00:25:24,770 --> 00:25:29,890
to say so if you have questions we'll go

00:25:27,620 --> 00:25:29,890
ahead

00:25:33,550 --> 00:25:41,290
[Applause]

00:25:38,760 --> 00:25:43,360
so again the last point thanks for the

00:25:41,290 --> 00:25:45,580
talking right and again the range

00:25:43,360 --> 00:25:46,990
queries and the range field so how do I

00:25:45,580 --> 00:25:49,450
thought that's the whole concept behind

00:25:46,990 --> 00:25:51,040
having range fields so if you don't if

00:25:49,450 --> 00:25:54,640
you cannot apply range queries on it so

00:25:51,040 --> 00:25:55,840
how do you use it so you can play range

00:25:54,640 --> 00:25:57,160
choice on them but we don't have the

00:25:55,840 --> 00:25:59,590
optimization to your dog values

00:25:57,160 --> 00:26:02,740
automatically when it's supposedly more

00:25:59,590 --> 00:26:04,900
efficient but at the same time range

00:26:02,740 --> 00:26:06,550
fields tend to be more selective query

00:26:04,900 --> 00:26:08,050
range queries and range fields tend to

00:26:06,550 --> 00:26:10,120
be most active queries so the

00:26:08,050 --> 00:26:12,370
optimization is not as much needed

00:26:10,120 --> 00:26:14,050
otherwise I would say but still it would

00:26:12,370 --> 00:26:21,790
be good to have very seen optimization

00:26:14,050 --> 00:26:24,610
thank you so just to finish on that one

00:26:21,790 --> 00:26:26,580
we do support growing range field with

00:26:24,610 --> 00:26:29,590
rent craze actually we support multiple

00:26:26,580 --> 00:26:33,730
kind of variations we've got intersects

00:26:29,590 --> 00:26:35,170
within contains and is joint so there is

00:26:33,730 --> 00:26:38,590
really evaluative query that you can run

00:26:35,170 --> 00:26:41,140
around clear then it works we just don't

00:26:38,590 --> 00:26:43,420
have the optimization yes ah does it

00:26:41,140 --> 00:26:45,310
ever make sense to run two strategies in

00:26:43,420 --> 00:26:47,890
parallel and whichever one finishes

00:26:45,310 --> 00:26:53,740
first you're done or is you know if the

00:26:47,890 --> 00:26:56,500
choice is too hard between I guess so

00:26:53,740 --> 00:26:58,270
that's a good question the other

00:26:56,500 --> 00:26:59,620
trade-off they depend whether what you

00:26:58,270 --> 00:27:01,510
want to improve this latency or

00:26:59,620 --> 00:27:03,580
throughput because that kind strategy

00:27:01,510 --> 00:27:05,590
would bring probably a better latency

00:27:03,580 --> 00:27:07,240
because you would get whichever returns

00:27:05,590 --> 00:27:09,370
first but at the same time at the same

00:27:07,240 --> 00:27:12,250
time you would have twice the cost so

00:27:09,370 --> 00:27:15,840
you could have well throughput that's

00:27:12,250 --> 00:27:18,520
something that you can certainly do on I

00:27:15,840 --> 00:27:19,870
mean it doesn't have to be implemented

00:27:18,520 --> 00:27:23,140
in you think that's something that can

00:27:19,870 --> 00:27:26,140
do by using lean API you can run so you

00:27:23,140 --> 00:27:28,270
can build two queries one we don't value

00:27:26,140 --> 00:27:29,620
not run the range and the other one with

00:27:28,270 --> 00:27:31,930
points in order to run the range and

00:27:29,620 --> 00:27:33,700
then bounce to thread which are going to

00:27:31,930 --> 00:27:35,770
run the coin parallel and get whichever

00:27:33,700 --> 00:27:40,020
result comes first that's something you

00:27:35,770 --> 00:27:40,020
could do with the API as it is today

00:27:46,560 --> 00:27:52,630
I think we good thank you my children

00:27:51,260 --> 00:27:59,749
there we go

00:27:52,630 --> 00:27:59,749

YouTube URL: https://www.youtube.com/watch?v=p51vIDWHWqk


