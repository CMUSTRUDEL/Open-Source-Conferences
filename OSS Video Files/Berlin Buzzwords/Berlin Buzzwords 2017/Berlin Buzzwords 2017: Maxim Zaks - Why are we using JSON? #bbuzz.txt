Title: Berlin Buzzwords 2017: Maxim Zaks - Why are we using JSON? #bbuzz
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	When I setup my iPhone to use HTTP proxy and pick on the traffic, I see lot's of JSON going cross the wire. In fact most of the traffic I intercept is encoded as JSON. I should not be surprised, JSON became a standard for data serialisation. But is it a good standard? In my talk I want to challenge your perception of JSON and outline the penalties we willing to accept while using JSON.

Read more:
https://2017.berlinbuzzwords.de/17/session/why-are-we-using-json

About Maxim Zaks:
https://2017.berlinbuzzwords.de/users/maxim-zaks

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,890 --> 00:00:12,920
all right thank you

00:00:08,600 --> 00:00:15,350
less technical talk of the conference I

00:00:12,920 --> 00:00:17,180
know you guys are exhausted but I would

00:00:15,350 --> 00:00:20,630
need a little bit more attention from

00:00:17,180 --> 00:00:23,660
you just for next 20 minutes and I would

00:00:20,630 --> 00:00:27,440
like to start with three questions first

00:00:23,660 --> 00:00:32,450
question raise your hand please if you

00:00:27,440 --> 00:00:35,770
know Jason okay all of you good then

00:00:32,450 --> 00:00:38,390
please raise your hand if you know math

00:00:35,770 --> 00:00:40,489
not scientific math just math simple

00:00:38,390 --> 00:00:43,790
math you know it's just like okay then

00:00:40,489 --> 00:00:48,559
third question in the next slide I will

00:00:43,790 --> 00:00:53,059
show you a J'son file which contains my

00:00:48,559 --> 00:00:56,839
name and my birthday and I would like

00:00:53,059 --> 00:00:58,070
you after I count to free to tell me how

00:00:56,839 --> 00:01:07,810
old I am

00:00:58,070 --> 00:01:16,130
okay make sense good so three two one

00:01:07,810 --> 00:01:19,360
nobody okay let me help you now three

00:01:16,130 --> 00:01:22,789
two one

00:01:19,360 --> 00:01:24,850
36 thank you very much all right so my

00:01:22,789 --> 00:01:27,700
name is Maxime Zak's I'm a recovering

00:01:24,850 --> 00:01:32,539
game developer and I would like to talk

00:01:27,700 --> 00:01:35,600
to you about Jason and why are we using

00:01:32,539 --> 00:01:39,679
Jason like those are the three buzz

00:01:35,600 --> 00:01:42,259
words which I will kind of talk about in

00:01:39,679 --> 00:01:46,850
my session its size efficiency and

00:01:42,259 --> 00:01:49,100
random value axis so this is a quite

00:01:46,850 --> 00:01:51,710
cheesy joke right so kind of like I

00:01:49,100 --> 00:01:54,020
showed you like a binary and expected

00:01:51,710 --> 00:01:58,689
that you can actually see and understand

00:01:54,020 --> 00:01:59,990
it but for me drive one point

00:01:58,689 --> 00:02:04,130
human-readable

00:01:59,990 --> 00:02:07,429
is a lie because what makes Jason human

00:02:04,130 --> 00:02:09,830
readable is the text editor and that's

00:02:07,429 --> 00:02:11,900
the thing every developer has a text

00:02:09,830 --> 00:02:14,810
editor every machine has a text editor

00:02:11,900 --> 00:02:16,790
so if we encode something in a textual

00:02:14,810 --> 00:02:18,560
representation then it's kind of human

00:02:16,790 --> 00:02:22,650
readable because we have the tools to

00:02:18,560 --> 00:02:25,409
make it human readable and writeable

00:02:22,650 --> 00:02:27,030
but in reality for the machine this is

00:02:25,409 --> 00:02:30,299
how it looks like this is the whole

00:02:27,030 --> 00:02:33,540
representation and this is completely

00:02:30,299 --> 00:02:37,709
non human readable and if you think

00:02:33,540 --> 00:02:39,900
about it also this text here not really

00:02:37,709 --> 00:02:43,590
human readable if human really readable

00:02:39,900 --> 00:02:46,010
because it is a very simple example but

00:02:43,590 --> 00:02:50,069
as you can see this one is not formatted

00:02:46,010 --> 00:02:53,120
this JSON is minified so if I will

00:02:50,069 --> 00:02:56,989
present you an example which is more a

00:02:53,120 --> 00:03:00,299
real-life example like for example here

00:02:56,989 --> 00:03:04,190
this is a result from word if you calm

00:03:00,299 --> 00:03:07,290
if I will ask for 25 training gifts and

00:03:04,190 --> 00:03:10,889
as you can see here scrolling wise is

00:03:07,290 --> 00:03:13,349
huge and this is not human readable

00:03:10,889 --> 00:03:15,569
anymore the funny fact is even Veloz to

00:03:13,349 --> 00:03:18,780
do code couldn't do a semantic

00:03:15,569 --> 00:03:23,310
highlighting here it just gave up even

00:03:18,780 --> 00:03:25,829
though it's understood it's J'son so to

00:03:23,310 --> 00:03:28,590
make this actually human readable we

00:03:25,829 --> 00:03:31,650
have to format it now it's much nicer

00:03:28,590 --> 00:03:33,180
right it's named birthday year month day

00:03:31,650 --> 00:03:35,730
everything is human readable we can

00:03:33,180 --> 00:03:39,930
actually understand it quite well but

00:03:35,730 --> 00:03:43,099
this means we just bloated up the binary

00:03:39,930 --> 00:03:46,109
representation we added lots of noise

00:03:43,099 --> 00:03:48,150
just to make it human readable but this

00:03:46,109 --> 00:03:51,569
is as well why we use JSON right because

00:03:48,150 --> 00:03:56,840
it's human readable in a way so here we

00:03:51,569 --> 00:04:00,989
are kind of in a clinch with ourselves

00:03:56,840 --> 00:04:03,840
so basically if we if you look at this

00:04:00,989 --> 00:04:09,500
with minified jason is 65 bytes and the

00:04:03,840 --> 00:04:12,479
formatted jason is 81 and if i present a

00:04:09,500 --> 00:04:14,699
real-life example this is in kilobytes

00:04:12,479 --> 00:04:17,099
so I have here hundred and thirteen

00:04:14,699 --> 00:04:19,489
kilobytes and the formatted would be

00:04:17,099 --> 00:04:24,990
almost hundred and eighty kilobytes so

00:04:19,489 --> 00:04:30,979
1.5 more data which we would get back if

00:04:24,990 --> 00:04:30,979
it would be really human readable now

00:04:31,250 --> 00:04:36,630
generally raise your hand if you can if

00:04:34,979 --> 00:04:38,640
you make sure that what

00:04:36,630 --> 00:04:40,920
data that communicates from your servers

00:04:38,640 --> 00:04:48,420
to server a server to client is always

00:04:40,920 --> 00:04:50,580
minified how do you ensure that there is

00:04:48,420 --> 00:04:52,680
no way to ensure it well only way how

00:04:50,580 --> 00:04:56,400
you could ensure it is to say like ok up

00:04:52,680 --> 00:04:58,380
to a certain size of the payload we

00:04:56,400 --> 00:05:01,860
won't accept it because I can send you

00:04:58,380 --> 00:05:04,650
this small object which contains name

00:05:01,860 --> 00:05:06,750
and birthday in gigabytes of data I will

00:05:04,650 --> 00:05:10,080
just fill it up with just basically

00:05:06,750 --> 00:05:12,990
empty space and it will be still a valid

00:05:10,080 --> 00:05:16,100
JSON your parser will parse it it will

00:05:12,990 --> 00:05:20,220
take forever but still it will parse it

00:05:16,100 --> 00:05:22,740
so can we do better and normally if you

00:05:20,220 --> 00:05:24,960
think about it like what is the worst

00:05:22,740 --> 00:05:29,010
thing that we try to communicate with

00:05:24,960 --> 00:05:34,380
this JSON this basically this date and

00:05:29,010 --> 00:05:38,670
the name date is 8 characters name is 10

00:05:34,380 --> 00:05:43,250
characters so 18 bytes in total if you

00:05:38,670 --> 00:05:43,250
see actually I didn't even introduce any

00:05:44,000 --> 00:05:48,420
delimiter here because I know if the

00:05:46,710 --> 00:05:51,140
dates are represented you can always

00:05:48,420 --> 00:05:54,090
represent a dating for eight characters

00:05:51,140 --> 00:05:56,850
therefore I know 8 characters is the

00:05:54,090 --> 00:05:59,670
date and then everything there will give

00:05:56,850 --> 00:06:03,240
a name so there is no need to actually

00:05:59,670 --> 00:06:06,990
kind of introduce a coma or empty space

00:06:03,240 --> 00:06:09,030
and so on and so forth and in this case

00:06:06,990 --> 00:06:14,760
you see like okay for me to JSON 81

00:06:09,030 --> 00:06:19,410
minifides 1865 and custom Texas 18 which

00:06:14,760 --> 00:06:22,650
is a huge difference right now can we do

00:06:19,410 --> 00:06:26,550
better what do you think yes

00:06:22,650 --> 00:06:29,730
and actually what we can do is just to

00:06:26,550 --> 00:06:32,400
say like okay 1981 is a number and we

00:06:29,730 --> 00:06:34,950
will represent as text as four

00:06:32,400 --> 00:06:38,430
characters but in reality as it is a

00:06:34,950 --> 00:06:41,820
number we can represent it as an end

00:06:38,430 --> 00:06:48,260
with two bytes and therefore we can go

00:06:41,820 --> 00:06:48,260
to 14 bytes right which is a 25% off

00:06:49,130 --> 00:06:55,440
which is interesting

00:06:52,069 --> 00:06:56,550
now custom binary civilization ain't

00:06:55,440 --> 00:06:58,620
nobody has time for that

00:06:56,550 --> 00:07:01,020
right so it's kind of like nobody does

00:06:58,620 --> 00:07:03,120
it like the only people I know like I

00:07:01,020 --> 00:07:05,819
haven't been to all the industries in

00:07:03,120 --> 00:07:09,000
computer science or maybe I missing

00:07:05,819 --> 00:07:12,210
something but one of those industries

00:07:09,000 --> 00:07:14,699
which still kind of used custom binary

00:07:12,210 --> 00:07:18,870
civilization is gaming industry and only

00:07:14,699 --> 00:07:21,030
if it's like real time with a massive

00:07:18,870 --> 00:07:23,220
multiplayer thinks then you need to have

00:07:21,030 --> 00:07:25,380
your packages really small and you need

00:07:23,220 --> 00:07:27,419
to use UDP and so on and so forth all

00:07:25,380 --> 00:07:29,940
the other people don't really use this

00:07:27,419 --> 00:07:32,220
kind of stuff because they don't have to

00:07:29,940 --> 00:07:34,770
because they are there are lots of

00:07:32,220 --> 00:07:37,550
problems which you can't get into if you

00:07:34,770 --> 00:07:37,550
use custom salinization

00:07:38,630 --> 00:07:46,220
stuff but if you google or go to

00:07:43,380 --> 00:07:48,360
Wikipedia and just search for

00:07:46,220 --> 00:07:50,520
Civilization formats you don't have to

00:07:48,360 --> 00:07:53,639
be able to read this I just wanted to

00:07:50,520 --> 00:07:57,720
feel like Wikipedia has like over 40

00:07:53,639 --> 00:08:00,389
different formats listed which make

00:07:57,720 --> 00:08:03,469
serialization possible JSON is also

00:08:00,389 --> 00:08:07,889
there but it's only one of over 40

00:08:03,469 --> 00:08:09,900
formats and but also a disclaimer I

00:08:07,889 --> 00:08:12,090
looked through the list and in some

00:08:09,900 --> 00:08:15,780
cases where information is not that

00:08:12,090 --> 00:08:19,080
accurate but at least you have a big

00:08:15,780 --> 00:08:23,210
list of everything that you can find and

00:08:19,080 --> 00:08:24,840
try to realize what kind of things could

00:08:23,210 --> 00:08:30,120
fit your needs

00:08:24,840 --> 00:08:36,779
actually so I have a different talk on

00:08:30,120 --> 00:08:39,750
where I explain in details how those two

00:08:36,779 --> 00:08:42,930
binary civilization works so if you'd

00:08:39,750 --> 00:08:47,850
like to follow up this is the link but

00:08:42,930 --> 00:08:51,709
here I just wanted to show that raise

00:08:47,850 --> 00:08:55,800
your hand please if you know flatbuffers

00:08:51,709 --> 00:08:59,130
okay just for people ready here hand if

00:08:55,800 --> 00:09:01,850
you know protobuf much more people sure

00:08:59,130 --> 00:09:05,100
anyone knows gopher

00:09:01,850 --> 00:09:07,259
nobody knows covered so so just

00:09:05,100 --> 00:09:09,899
basically like those are three

00:09:07,259 --> 00:09:12,930
civilization formats and comfor is based

00:09:09,899 --> 00:09:15,959
on protolith is just simplified and

00:09:12,930 --> 00:09:18,209
there were a few edges cut it so it's

00:09:15,959 --> 00:09:19,470
not as powerful as protobuf but it's

00:09:18,209 --> 00:09:21,300
much faster and wrote about in

00:09:19,470 --> 00:09:25,230
civilization this relation if you are

00:09:21,300 --> 00:09:29,220
interesting just google for it and you

00:09:25,230 --> 00:09:31,529
will find it or contact me but what I

00:09:29,220 --> 00:09:35,550
wanted to show is basically that if you

00:09:31,529 --> 00:09:38,389
do it in a binary format you can get

00:09:35,550 --> 00:09:41,130
close to what we saw with a custom

00:09:38,389 --> 00:09:45,980
representation and the good part is in

00:09:41,130 --> 00:09:49,380
this format we will keep the structure

00:09:45,980 --> 00:09:51,600
all these formats are a schema based and

00:09:49,380 --> 00:09:53,550
you define the schema so you tell that

00:09:51,600 --> 00:09:56,610
you have a name you have a birthday

00:09:53,550 --> 00:09:59,009
which is its own type and these types

00:09:56,610 --> 00:10:03,209
have a year month and day so it's not

00:09:59,009 --> 00:10:06,180
really custom or so proven to break

00:10:03,209 --> 00:10:08,760
rules really easily but it still gives

00:10:06,180 --> 00:10:13,560
you the possibility to reduce the size

00:10:08,760 --> 00:10:18,800
dramatically I mean now let's talk about

00:10:13,560 --> 00:10:21,630
performance Jason is a text-based format

00:10:18,800 --> 00:10:23,819
and to be honest I don't have problem

00:10:21,630 --> 00:10:27,480
with Jason I like Jason Jason has a

00:10:23,819 --> 00:10:28,920
representation is in my opinion pretty

00:10:27,480 --> 00:10:31,410
good I really like it

00:10:28,920 --> 00:10:33,630
specifically compared to a XML or

00:10:31,410 --> 00:10:39,540
whatever but the problem is basically

00:10:33,630 --> 00:10:41,699
text-based format right so text-based

00:10:39,540 --> 00:10:44,220
format would be very efficient if we

00:10:41,699 --> 00:10:47,370
have something like this so we have a

00:10:44,220 --> 00:10:50,339
person here which types text into a

00:10:47,370 --> 00:10:52,470
computer this computer will just send

00:10:50,339 --> 00:10:55,079
the text without understanding it to

00:10:52,470 --> 00:10:57,689
another computer this computer will just

00:10:55,079 --> 00:11:03,269
display the text to another person this

00:10:57,689 --> 00:11:05,839
person reads it replies to it and then

00:11:03,269 --> 00:11:08,339
it goes back without the computers need

00:11:05,839 --> 00:11:11,089
need to actually understand what's

00:11:08,339 --> 00:11:13,089
inside there is just blobs moving blobs

00:11:11,089 --> 00:11:16,540
perfectly fine

00:11:13,089 --> 00:11:18,399
but in reality we have this situation

00:11:16,540 --> 00:11:20,259
like a previous situation I think in the

00:11:18,399 --> 00:11:23,079
beginning of the internet it kind of was

00:11:20,259 --> 00:11:25,660
like this so people set on a terminal

00:11:23,079 --> 00:11:28,269
just punched in some text and just send

00:11:25,660 --> 00:11:30,160
it and some other actually read this now

00:11:28,269 --> 00:11:35,589
we have services talking to each other

00:11:30,160 --> 00:11:41,759
right no humans but what we actually do

00:11:35,589 --> 00:11:44,290
is still the application has its state

00:11:41,759 --> 00:11:44,860
encoded in 0 and once and so on and so

00:11:44,290 --> 00:11:47,499
forth

00:11:44,860 --> 00:11:50,740
so what we make it do to please

00:11:47,499 --> 00:11:52,449
transform it to human readable we will

00:11:50,740 --> 00:11:54,910
send this human readable over the

00:11:52,449 --> 00:11:56,410
Internet to another computer it will be

00:11:54,910 --> 00:11:58,449
still human readable this computer

00:11:56,410 --> 00:12:01,209
doesn't know how to read with human

00:11:58,449 --> 00:12:03,550
readable so it has to parse it and then

00:12:01,209 --> 00:12:06,569
it will actually get into again 0 and

00:12:03,550 --> 00:12:09,160
ones format which it can understand I

00:12:06,569 --> 00:12:13,120
don't know about you guys but if I see

00:12:09,160 --> 00:12:14,559
this I feel like this I actually just

00:12:13,120 --> 00:12:16,300
want to kick myself because it just

00:12:14,559 --> 00:12:21,309
doesn't make any sense

00:12:16,300 --> 00:12:23,499
in a way and well I'm exaggerating a

00:12:21,309 --> 00:12:24,970
little bit right because if you think

00:12:23,499 --> 00:12:28,929
about it you can have different

00:12:24,970 --> 00:12:30,759
platforms but binary on this side is can

00:12:28,929 --> 00:12:32,649
be different on this sides because you

00:12:30,759 --> 00:12:36,189
have different programming languages and

00:12:32,649 --> 00:12:39,759
so on and so forth but this is what the

00:12:36,189 --> 00:12:44,769
binary sedation formats are for they are

00:12:39,759 --> 00:12:47,379
here to make a platform independent

00:12:44,769 --> 00:12:51,339
binary representation which can be

00:12:47,379 --> 00:12:55,920
easily read by machines from machine to

00:12:51,339 --> 00:13:01,870
machine server service to service and

00:12:55,920 --> 00:13:04,600
what we actually just can do is this we

00:13:01,870 --> 00:13:07,839
can just say like ok and let's put a

00:13:04,600 --> 00:13:09,879
binary boundary here and to say when the

00:13:07,839 --> 00:13:12,189
service is talk to each other when the

00:13:09,879 --> 00:13:17,850
machines talk to each other it's in

00:13:12,189 --> 00:13:20,319
binary - binary if I as a human and

00:13:17,850 --> 00:13:23,019
generally I see the point of human

00:13:20,319 --> 00:13:24,879
readability and even right ability in

00:13:23,019 --> 00:13:26,769
the beginning it's even more important

00:13:24,879 --> 00:13:29,529
because I want to try out stuff

00:13:26,769 --> 00:13:31,839
I want to do something and it's much

00:13:29,529 --> 00:13:36,489
easier for me to write it in a way which

00:13:31,839 --> 00:13:39,399
I can just use the text editor for then

00:13:36,489 --> 00:13:43,199
to try to do it in binary right but then

00:13:39,399 --> 00:13:46,119
at some point I'm done debugging and

00:13:43,199 --> 00:13:48,759
most of the binary realization formats

00:13:46,119 --> 00:13:53,139
as well have a possibility to transform

00:13:48,759 --> 00:13:58,179
JSON into this binary / script and from

00:13:53,139 --> 00:14:01,029
binary into JSON again so we have still

00:13:58,179 --> 00:14:05,110
this way if we need to read this if we

00:14:01,029 --> 00:14:08,679
need to write there is a way but we were

00:14:05,110 --> 00:14:10,749
not enforcing the text format on two

00:14:08,679 --> 00:14:13,720
machines like to perform at that that

00:14:10,749 --> 00:14:18,329
they actually can't read to them to say

00:14:13,720 --> 00:14:21,629
like read this parse vez create this and

00:14:18,329 --> 00:14:26,110
if you don't do this it actually pays

00:14:21,629 --> 00:14:29,920
off quite a lot so as I said I'm a

00:14:26,110 --> 00:14:34,089
recovering game developer and in my last

00:14:29,920 --> 00:14:39,220
gaming project I we had a problem with

00:14:34,089 --> 00:14:44,079
JSON so we had a way for context start

00:14:39,220 --> 00:14:46,980
up where it took like 60 milliseconds

00:14:44,079 --> 00:14:51,129
for for switching context on the backend

00:14:46,980 --> 00:14:55,029
because most of the time was spent on

00:14:51,129 --> 00:14:56,860
parsing JSON when we switch from JSON to

00:14:55,029 --> 00:15:01,360
flatbuffers we went to two milliseconds

00:14:56,860 --> 00:15:03,459
so it was like 30x down and it was and

00:15:01,360 --> 00:15:05,799
we didn't measure just for parsing we

00:15:03,459 --> 00:15:07,660
actually measured like bringing it up

00:15:05,799 --> 00:15:10,649
for context removing the context

00:15:07,660 --> 00:15:13,689
switching from context to context i

00:15:10,649 --> 00:15:17,439
ported flatbuffers to swift and also

00:15:13,689 --> 00:15:22,410
flag flex buffers and this is what my

00:15:17,439 --> 00:15:22,410
micro benchmarks shows if you do like

00:15:22,739 --> 00:15:27,579
comparing jason's civilizations

00:15:25,169 --> 00:15:30,879
digitization to thread buffers and flex

00:15:27,579 --> 00:15:34,139
buffers so here we see that for example

00:15:30,879 --> 00:15:37,990
decoding here it's 3,000 milliseconds

00:15:34,139 --> 00:15:40,300
almost 4,000 so four seconds if you do

00:15:37,990 --> 00:15:44,020
it in flatbuffers

00:15:40,300 --> 00:15:47,290
it's 18 milliseconds so it's like 250x

00:15:44,020 --> 00:15:49,750
the funny thing is I can actually bring

00:15:47,290 --> 00:15:53,710
this number to four milliseconds if I

00:15:49,750 --> 00:15:56,500
remove some safety checks if I would use

00:15:53,710 --> 00:16:04,380
a C implementation of flatbuffers I

00:15:56,500 --> 00:16:09,190
would go to to making this 2,000 yet

00:16:04,380 --> 00:16:12,760
anyway okay one more less thing zero

00:16:09,190 --> 00:16:16,980
cost random value access this is a

00:16:12,760 --> 00:16:21,190
genuinely bad word and if you hear zero

00:16:16,980 --> 00:16:24,910
zero cost this can't be right because

00:16:21,190 --> 00:16:27,700
there is no zero cost anyways but what

00:16:24,910 --> 00:16:30,520
it means in cases of binary situation is

00:16:27,700 --> 00:16:33,490
basically that there are a few binary

00:16:30,520 --> 00:16:35,410
formats I know only this free

00:16:33,490 --> 00:16:40,780
flatbuffers lag buffers and captain

00:16:35,410 --> 00:16:46,260
proton which let you get values out of a

00:16:40,780 --> 00:16:49,570
binary without creating any kind of

00:16:46,260 --> 00:16:51,520
representation you basically kind of

00:16:49,570 --> 00:16:55,440
have something like jumping in the

00:16:51,520 --> 00:16:57,880
memory so get a few are doing some

00:16:55,440 --> 00:17:00,250
dereferencing and then you can read the

00:16:57,880 --> 00:17:02,170
value out because the format's are

00:17:00,250 --> 00:17:06,400
already designed in a way that it's

00:17:02,170 --> 00:17:12,520
memory aligned and basically everything

00:17:06,400 --> 00:17:15,370
is reference based so this lets me do

00:17:12,520 --> 00:17:18,250
following so I saw it on this conference

00:17:15,370 --> 00:17:21,910
there is lots of talks about search and

00:17:18,250 --> 00:17:24,550
I have also a search example made with

00:17:21,910 --> 00:17:30,010
sled buffers where I have a data set

00:17:24,550 --> 00:17:33,310
with all city names it's more than three

00:17:30,010 --> 00:17:36,250
million entries which is roughly 150

00:17:33,310 --> 00:17:38,770
megabytes s CSV I transform it to

00:17:36,250 --> 00:17:43,380
flatbuffers and then I can do offline

00:17:38,770 --> 00:17:48,790
search on my iPhone for country name and

00:17:43,380 --> 00:17:51,640
city name and this I can also do either

00:17:48,790 --> 00:17:52,660
if I load everything directly into

00:17:51,640 --> 00:17:56,260
memory

00:17:52,660 --> 00:17:58,450
or directly from file because what data

00:17:56,260 --> 00:18:01,540
is laid out already in the way that you

00:17:58,450 --> 00:18:04,540
can just seek inside of a file and read

00:18:01,540 --> 00:18:10,950
only portions of the data not all over

00:18:04,540 --> 00:18:13,510
150 megabytes so here's the demo so I

00:18:10,950 --> 00:18:15,700
can give the memory reader as you can

00:18:13,510 --> 00:18:18,610
see I have three million cities and I

00:18:15,700 --> 00:18:21,370
can scroll throughout any problem I will

00:18:18,610 --> 00:18:26,400
now search for cities in Germany so

00:18:21,370 --> 00:18:29,590
there are like 70,000 entrances receiver

00:18:26,400 --> 00:18:33,130
the speed of a query now I will search

00:18:29,590 --> 00:18:36,070
for the lens again the query speed is

00:18:33,130 --> 00:18:38,710
actually quite good right there was one

00:18:36,070 --> 00:18:40,150
point where it was like two milliseconds

00:18:38,710 --> 00:18:44,190
of four milliseconds or something like

00:18:40,150 --> 00:18:44,190
this everything else is actually beyond

00:18:44,370 --> 00:18:51,730
one millisecond and here I do the same

00:18:47,310 --> 00:18:55,240
directly from file again slower like 13

00:18:51,730 --> 00:18:59,740
milliseconds in worst case scenario but

00:18:55,240 --> 00:19:04,090
still very very fast and I'm able to do

00:18:59,740 --> 00:19:11,830
it because the format already represents

00:19:04,090 --> 00:19:14,350
the data in this zero cost random access

00:19:11,830 --> 00:19:18,640
way all right

00:19:14,350 --> 00:19:21,790
so general look out so please don't use

00:19:18,640 --> 00:19:24,310
JSON just because it's convenient or

00:19:21,790 --> 00:19:25,510
because everyone know everyone else uses

00:19:24,310 --> 00:19:28,240
it and so on and so forth

00:19:25,510 --> 00:19:30,400
please consider your use case there I

00:19:28,240 --> 00:19:32,980
use cases where it's totally fine to use

00:19:30,400 --> 00:19:36,040
JSON or even performant to use JSON I

00:19:32,980 --> 00:19:39,660
don't know maybe but what I normally see

00:19:36,040 --> 00:19:42,160
is basically it becomes like one thing

00:19:39,660 --> 00:19:44,740
it's all I can represent the stuff and

00:19:42,160 --> 00:19:48,300
isn't great let's represent it in JSON

00:19:44,740 --> 00:19:51,670
human readable is the manner of tooling

00:19:48,300 --> 00:19:55,570
as I showed in the beginning of a

00:19:51,670 --> 00:19:57,940
presentation text representation we

00:19:55,570 --> 00:20:00,460
already have all the to link we need if

00:19:57,940 --> 00:20:03,010
it's a little bit different then yeah

00:20:00,460 --> 00:20:04,960
that can be a tool or you would need to

00:20:03,010 --> 00:20:06,430
write it or something like this but

00:20:04,960 --> 00:20:09,970
still it's very

00:20:06,430 --> 00:20:12,430
easy if it's machine-readable it's you

00:20:09,970 --> 00:20:15,100
just need to have a tool which will make

00:20:12,430 --> 00:20:18,420
it human readable and normally it's not

00:20:15,100 --> 00:20:20,920
that hard to do these kind of things

00:20:18,420 --> 00:20:24,610
imagine how much more responses our

00:20:20,920 --> 00:20:28,210
service could deliver if it took 200 X

00:20:24,610 --> 00:20:29,950
less time to process a request because

00:20:28,210 --> 00:20:32,830
literally if you think about it for web

00:20:29,950 --> 00:20:37,090
servers most of the time what endpoint

00:20:32,830 --> 00:20:39,910
do they get requests the payload is JSON

00:20:37,090 --> 00:20:43,330
they parse them they identify what to do

00:20:39,910 --> 00:20:47,320
and then they start doing this and this

00:20:43,330 --> 00:20:49,960
is the main load which we have on our

00:20:47,320 --> 00:20:53,680
servers anyway if we could reduce this

00:20:49,960 --> 00:20:59,730
this is what we also did why we switch

00:20:53,680 --> 00:20:59,730
from JSON to flatbuffers in my previous

00:21:00,030 --> 00:21:08,770
project because the back-end developers

00:21:05,100 --> 00:21:12,910
told we would like to have hundred users

00:21:08,770 --> 00:21:16,360
per second per core if you wait 60

00:21:12,910 --> 00:21:21,670
milliseconds on parsing JSON we are

00:21:16,360 --> 00:21:28,870
already at 12 users per second per core

00:21:21,670 --> 00:21:31,050
doing nothing yeah and I'm actually open

00:21:28,870 --> 00:21:31,050
for questions

00:21:31,800 --> 00:21:35,940
all right listings Maxime

00:21:36,050 --> 00:21:42,200
[Music]

00:21:39,590 --> 00:21:45,530
there's one in the center yeah all right

00:21:42,200 --> 00:21:49,520
yeah so thank you for the talk very cool

00:21:45,530 --> 00:21:52,670
have you used baby other ones like April

00:21:49,520 --> 00:21:55,910
and prief another binary protocols and

00:21:52,670 --> 00:21:58,220
you can have any tips about it for sure

00:21:55,910 --> 00:22:00,320
ones have trade-offs between the others

00:21:58,220 --> 00:22:03,650
but maybe you have more more examples

00:22:00,320 --> 00:22:05,540
and tips well yeah so so again I have a

00:22:03,650 --> 00:22:07,370
very deep understanding of web buffers

00:22:05,540 --> 00:22:10,310
and select buffers because i ported them

00:22:07,370 --> 00:22:11,840
right I looked into Colfer and a little

00:22:10,310 --> 00:22:15,340
bit of a proto bus because I was

00:22:11,840 --> 00:22:19,940
interested because I saw there is a

00:22:15,340 --> 00:22:23,480
github repository which have a benchmark

00:22:19,940 --> 00:22:26,510
for different civilization formats on

00:22:23,480 --> 00:22:30,850
GBM and their code was the fastest even

00:22:26,510 --> 00:22:34,100
faster than Fred buffers in decoding

00:22:30,850 --> 00:22:36,080
which then I went through the test and

00:22:34,100 --> 00:22:41,990
actually test does something wrong

00:22:36,080 --> 00:22:45,140
because they didn't consider this random

00:22:41,990 --> 00:22:49,970
access because basically what we did

00:22:45,140 --> 00:22:51,920
they already kind of got a binary and

00:22:49,970 --> 00:22:55,520
still mapped

00:22:51,920 --> 00:23:00,080
everything from this representation into

00:22:55,520 --> 00:23:02,150
a Java object graph which you don't have

00:23:00,080 --> 00:23:05,360
to do anymore in flatbuffers and in

00:23:02,150 --> 00:23:08,210
captain proto as well rift for example

00:23:05,360 --> 00:23:08,900
by Facebook and also brought about by

00:23:08,210 --> 00:23:13,850
Google

00:23:08,900 --> 00:23:16,400
they are generally designed for machine

00:23:13,850 --> 00:23:19,400
to machine communication so for RPC

00:23:16,400 --> 00:23:24,470
sending messages therefore what they

00:23:19,400 --> 00:23:27,860
trying to do is to actually do bit

00:23:24,470 --> 00:23:31,190
packing flatbuffers is on contrary

00:23:27,860 --> 00:23:33,860
design to store data and be able to read

00:23:31,190 --> 00:23:39,640
this data so for example it also was

00:23:33,860 --> 00:23:42,710
done by Google in the game developer

00:23:39,640 --> 00:23:47,060
initiative and what you do there is you

00:23:42,710 --> 00:23:49,370
would like to store game state for

00:23:47,060 --> 00:23:52,850
example and then you would like to be

00:23:49,370 --> 00:23:59,120
very efficiently read data out of it

00:23:52,850 --> 00:24:03,380
this is why it's supports this zero zero

00:23:59,120 --> 00:24:06,440
cost random access values right so this

00:24:03,380 --> 00:24:11,600
is the trade of which you have to think

00:24:06,440 --> 00:24:15,409
about and see and like if you are only

00:24:11,600 --> 00:24:18,200
about sending messages to each other

00:24:15,409 --> 00:24:22,929
then I would look into a plot above

00:24:18,200 --> 00:24:26,840
frist there were a few more form

00:24:22,929 --> 00:24:30,559
displaying right but for example also in

00:24:26,840 --> 00:24:34,490
this gif example as you saw I only asked

00:24:30,559 --> 00:24:37,450
for 25 I knew just 25 URLs they send me

00:24:34,490 --> 00:24:40,970
hundred and cents 70 kilobytes of

00:24:37,450 --> 00:24:46,330
response because it has everything and

00:24:40,970 --> 00:24:49,820
there is actually nice to have this like

00:24:46,330 --> 00:24:51,980
zero cost random access because then I

00:24:49,820 --> 00:24:54,620
will just be able to just randomly

00:24:51,980 --> 00:24:59,960
access with write URLs which I need and

00:24:54,620 --> 00:25:01,850
I'm done I don't have to create objects

00:24:59,960 --> 00:25:07,970
of a whole payload and so on and so

00:25:01,850 --> 00:25:09,830
forth make sense okay so I like the

00:25:07,970 --> 00:25:11,389
topic because it's like it addresses the

00:25:09,830 --> 00:25:12,950
more of a fundamental level of the

00:25:11,389 --> 00:25:15,370
question why did we transfer the text

00:25:12,950 --> 00:25:18,950
o'er machine to machine communication

00:25:15,370 --> 00:25:22,039
and my question is more towards kind of

00:25:18,950 --> 00:25:24,740
discussion kind of topic not very

00:25:22,039 --> 00:25:28,399
specific like a question directed to you

00:25:24,740 --> 00:25:30,379
specifically but when basically when I

00:25:28,399 --> 00:25:32,450
was digging into the same question my

00:25:30,379 --> 00:25:36,139
machine to machine communication use

00:25:32,450 --> 00:25:38,720
text the I found answer basically an

00:25:36,139 --> 00:25:41,720
HTTP so HTTP was basically designed to

00:25:38,720 --> 00:25:42,980
have a hypertext Transfer Protocol right

00:25:41,720 --> 00:25:46,399
so it because of TechSoup

00:25:42,980 --> 00:25:48,919
when HTTP came into existence it

00:25:46,399 --> 00:25:50,990
basically was person will request the

00:25:48,919 --> 00:25:52,940
document to some computer and it way he

00:25:50,990 --> 00:25:55,539
will get the like website over there

00:25:52,940 --> 00:25:58,009
that's why a equals design and now

00:25:55,539 --> 00:25:59,539
when I see the things are evolving

00:25:58,009 --> 00:26:01,190
towards protobuf and machine to machine

00:25:59,539 --> 00:26:06,350
communication and everything is binary

00:26:01,190 --> 00:26:06,710
and so like my kind of question kind of

00:26:06,350 --> 00:26:08,990
thing

00:26:06,710 --> 00:26:10,340
like they think it's probably the time

00:26:08,990 --> 00:26:12,529
when basically when machine to machine

00:26:10,340 --> 00:26:14,179
communication is increasing it's time to

00:26:12,529 --> 00:26:15,380
move away from HTTP and have some kind

00:26:14,179 --> 00:26:17,419
of other kind of protocol which is

00:26:15,380 --> 00:26:19,250
machine to machine protocol and text

00:26:17,419 --> 00:26:21,130
Transfer Protocol is for text basically

00:26:19,250 --> 00:26:23,770
just one is for text because it's like

00:26:21,130 --> 00:26:26,330
getting transferred as text and it was

00:26:23,770 --> 00:26:29,510
for text in the beginning of that yeah

00:26:26,330 --> 00:26:32,720
so and you can see for example HTTP 2 is

00:26:29,510 --> 00:26:35,240
more of a binary protocol than a text

00:26:32,720 --> 00:26:38,330
protocol they already moving with HTTP 2

00:26:35,240 --> 00:26:41,330
into more binary space you also can see

00:26:38,330 --> 00:26:44,840
for example G RPC from Google which is

00:26:41,330 --> 00:26:48,529
like Google or PC stopped you is also

00:26:44,840 --> 00:26:50,690
more binary and it lets you the payload

00:26:48,529 --> 00:26:52,309
can be binary they don't care this is

00:26:50,690 --> 00:26:54,380
actually funny because if you think

00:26:52,309 --> 00:26:58,520
about it even with HTTP with the

00:26:54,380 --> 00:27:02,059
standard web stuff HTML is text right

00:26:58,520 --> 00:27:05,059
how many things in this text is actual

00:27:02,059 --> 00:27:06,860
text which humans will read and how many

00:27:05,059 --> 00:27:10,240
things in this text is actually for

00:27:06,860 --> 00:27:14,360
machines to read write for example CSS

00:27:10,240 --> 00:27:17,899
why isn't CSS pre-compile to binary and

00:27:14,360 --> 00:27:20,809
send over because it no human will read

00:27:17,899 --> 00:27:22,929
CSS right but it's still in test because

00:27:20,809 --> 00:27:25,370
it's easier just to just basically like

00:27:22,929 --> 00:27:27,200
send it over the only thing which we do

00:27:25,370 --> 00:27:31,340
is minifying stuff and sometimes

00:27:27,200 --> 00:27:33,500
gzipping stuff right and there but it's

00:27:31,340 --> 00:27:36,080
kind of like in my opinion is basically

00:27:33,500 --> 00:27:37,940
the patch one of wound where we say

00:27:36,080 --> 00:27:40,669
actually it shouldn't be text in the

00:27:37,940 --> 00:27:42,590
first place when we wouldn't need to

00:27:40,669 --> 00:27:47,679
encode it in the first place because

00:27:42,590 --> 00:27:47,679
encoding again it goes again efficiency

00:28:00,400 --> 00:28:06,040
[Music]

00:28:03,400 --> 00:28:08,930
yeah for exam

00:28:06,040 --> 00:28:10,710
all right let's whip up okay I think to

00:28:08,930 --> 00:28:16,799
speak again cigarette

00:28:10,710 --> 00:28:16,799

YouTube URL: https://www.youtube.com/watch?v=qF44UetsLsQ


