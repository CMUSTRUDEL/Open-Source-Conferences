Title: LPC2018 - ERSPAN Support  for Linux
Publication date: 2018-12-04
Playlist: LPC2018 - Networking Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/98/
speaker:  William Tu (VMware), Greg Rose (VMware)


Port mirroring is one of the most common network troubleshooting
techniques. SPAN (Switch Port Analyzer) allows a user to send a copy
of the monitored traffic to a local or remote device using a sniffer
or packet analyzer. RSPAN is similar, but sends and received traffic
on a VLAN. ERSPAN extends the port mirroring capability from Layer 2
to Layer 3, allowing the mirrored traffic to be encapsulated in an
extension of the GRE (Generic Routing Encapsulation) protocol and sent
through an IP network. In addition, ERSPAN carries configurable
metadatas (e.g., session ID, timestamps), so that the packet analyzer
has better understanding of the packets.

ERSPAN for IPv4 was added into Linux kernel in 4.14, and for IPv6 in
4.16. The implementation includes both transmission and reception and
is based on the existing ip_gre and ip6_gre kernel module. As a
result, Linux today can act as an ERSPAN traffic source sending the
ERSPAN mirrored traffic to the remote host, or an ERSPAN destination
which receives and parses the ERSPAN packets generated from Cisco or
other ERSPAN-capable switches.

We’ve added both the native tunnel support and metadata-mode tunnel
support. In this paper, we demonstrate three ways to use the ERSPAN
protocol. First, for Linux users, using iproute2 to create native
tunnel net device. Traffic sent to the net device will be
encapsulated with the protocol header accordingly and traffic matching
the protocol configuration will be received from the net device.
Second, for eBPF users, using iproute2 to create metadata-mode ERSPAN
tunnel. With eBPF TC hook and eBPF tunnel helper functions, users can
read/write ERSPAN protocol’s fields in finer granularity. Finally,
for Open vSwitch users, using the netlink interface to create a switch
and programmatically parse, lookup, and forward the ERSPAN packets
based on flows installed from the userspace.
Captions: 
	00:00:07,180 --> 00:00:12,110
hello everybody okay we're going to talk

00:00:11,110 --> 00:00:17,900
about

00:00:12,110 --> 00:00:21,650
encapsulated routable spanning so just a

00:00:17,900 --> 00:00:23,810
short review here and let's just talk

00:00:21,650 --> 00:00:25,820
about port mirroring first what is Port

00:00:23,810 --> 00:00:27,529
Mary it's one of the most common

00:00:25,820 --> 00:00:31,119
networking troubleshooting techniques is

00:00:27,529 --> 00:00:34,790
what the slide says what it is is a way

00:00:31,119 --> 00:00:37,700
since we made the switch to switch to

00:00:34,790 --> 00:00:41,300
Ethernet to get a copy of packets that

00:00:37,700 --> 00:00:44,030
appear on a switch port as I know as

00:00:41,300 --> 00:00:46,460
recently as 2005 I would have a problem

00:00:44,030 --> 00:00:49,090
trying to analyze a networking issue and

00:00:46,460 --> 00:00:52,220
I'd have to go grab one of the old hubs

00:00:49,090 --> 00:00:54,140
so that you could put a sniffer on there

00:00:52,220 --> 00:00:56,780
and see what's going on but with the

00:00:54,140 --> 00:00:59,030
port memory now you can tell the switch

00:00:56,780 --> 00:01:01,280
to send traffic that appears on one port

00:00:59,030 --> 00:01:05,649
and send it to another port so it can be

00:01:01,280 --> 00:01:08,720
sent there for further analysis by a

00:01:05,649 --> 00:01:10,399
device we call this sniffer I used to

00:01:08,720 --> 00:01:13,790
work for Network general back in the day

00:01:10,399 --> 00:01:18,799
and and they actually copyright it's

00:01:13,790 --> 00:01:20,810
never so those are pretty familiar to

00:01:18,799 --> 00:01:22,549
most people now Wireshark is fairly

00:01:20,810 --> 00:01:26,180
common out there so it's just a

00:01:22,549 --> 00:01:28,340
commodity product now so we have span

00:01:26,180 --> 00:01:31,040
that's just one that sends a copy of the

00:01:28,340 --> 00:01:35,170
monitor monitor traffic to a local

00:01:31,040 --> 00:01:38,210
device usually on the same switch okay

00:01:35,170 --> 00:01:41,590
remote switch port analyzer it just adds

00:01:38,210 --> 00:01:44,479
a VLAN tag and then that VLAN tag can be

00:01:41,590 --> 00:01:48,740
sent across whichever switches are on

00:01:44,479 --> 00:01:51,380
the common fabric there and a port that

00:01:48,740 --> 00:01:55,040
has the right VLAN configuration will

00:01:51,380 --> 00:01:57,820
pick up that packet with encapsulated

00:01:55,040 --> 00:02:00,950
remote span we've added the ability to

00:01:57,820 --> 00:02:03,799
take packets on a source port they can

00:02:00,950 --> 00:02:06,740
be ingress or egress take those packets

00:02:03,799 --> 00:02:10,310
and wrap them up into the generic

00:02:06,740 --> 00:02:12,140
routable encapsulation encapsulation a

00:02:10,310 --> 00:02:13,879
little redundant there to extend the

00:02:12,140 --> 00:02:16,849
basic port mirroring capability from

00:02:13,879 --> 00:02:19,970
layer 2 layer 3 so this is a huge

00:02:16,849 --> 00:02:22,040
feature here used to be if you wanted to

00:02:19,970 --> 00:02:24,170
do some sniffing on a network you'd have

00:02:22,040 --> 00:02:25,830
to be in somewhat proximity to it or

00:02:24,170 --> 00:02:28,950
have somebody in proximity to it

00:02:25,830 --> 00:02:31,830
do that with this capability now you can

00:02:28,950 --> 00:02:37,110
have a problem on a switch someplace in

00:02:31,830 --> 00:02:41,070
San Francisco and have this a capsulated

00:02:37,110 --> 00:02:43,800
remote span take that packet encapsulate

00:02:41,070 --> 00:02:45,870
it in GRE and send it to a sniffer up in

00:02:43,800 --> 00:02:48,720
Seattle or here at Vancouver or wherever

00:02:45,870 --> 00:02:51,600
in the world you want it to go that's a

00:02:48,720 --> 00:02:54,480
that's a pretty big thing for people who

00:02:51,600 --> 00:02:59,850
have to monitor and diagnose network

00:02:54,480 --> 00:03:03,510
problems so here's a port mirroring

00:02:59,850 --> 00:03:07,170
example of this is the old way of doing

00:03:03,510 --> 00:03:09,630
it here where you had a sniffer attached

00:03:07,170 --> 00:03:11,580
to a switch and you would tell that

00:03:09,630 --> 00:03:15,810
switch to say hey send a copy of

00:03:11,580 --> 00:03:19,080
everything on port a ingress and egress

00:03:15,810 --> 00:03:22,170
to a sniffer over on some other port on

00:03:19,080 --> 00:03:26,990
the switch our span just like I said

00:03:22,170 --> 00:03:30,090
added a VLAN tag to it but with ER span

00:03:26,990 --> 00:03:31,890
we now mirror traffic on source ports

00:03:30,090 --> 00:03:34,769
and delivers the marriage traffic to

00:03:31,890 --> 00:03:38,330
destination ports and it's a crowded

00:03:34,769 --> 00:03:42,330
will across a layer 3 network now so

00:03:38,330 --> 00:03:46,459
again with you know software-defined

00:03:42,330 --> 00:03:49,709
networking taking off global networks

00:03:46,459 --> 00:03:51,239
non co-located networks so many

00:03:49,709 --> 00:03:54,300
different networking configurations out

00:03:51,239 --> 00:03:59,489
there it's really a great feature to be

00:03:54,300 --> 00:04:01,739
able to get a look at data that appears

00:03:59,489 --> 00:04:04,950
on a problematic source port over on a

00:04:01,739 --> 00:04:08,160
switch someplace in the world and get a

00:04:04,950 --> 00:04:14,430
look at that traffic on your sniffer

00:04:08,160 --> 00:04:20,970
wherever you baby so your span was added

00:04:14,430 --> 00:04:23,310
to Linux let's see oh yeah 4.14 I think

00:04:20,970 --> 00:04:26,340
the full implementation went in 4.16

00:04:23,310 --> 00:04:28,200
4.15 was a little transitory we were

00:04:26,340 --> 00:04:31,380
able to do this because cisco released

00:04:28,200 --> 00:04:35,460
the specification in 2014 I have a

00:04:31,380 --> 00:04:38,850
pointer to that IETF document at the end

00:04:35,460 --> 00:04:39,630
of the slides and you should look at it

00:04:38,850 --> 00:04:41,280
if they're interested in

00:04:39,630 --> 00:04:42,570
working on this because there's still

00:04:41,280 --> 00:04:45,660
further things that could be done with

00:04:42,570 --> 00:04:48,780
this but it includes a retransmission

00:04:45,660 --> 00:04:53,360
reception based on the existing IP G

00:04:48,780 --> 00:04:55,320
area GRE and IP six GRE kernel modules

00:04:53,360 --> 00:04:57,270
building on top of those really

00:04:55,320 --> 00:04:59,790
simplified the implementation quite a

00:04:57,270 --> 00:05:02,970
bit I think rather than going off and

00:04:59,790 --> 00:05:05,070
building an entirely new driver and and

00:05:02,970 --> 00:05:07,290
taking that route I think it made real

00:05:05,070 --> 00:05:10,950
sense just put these into the IP GRE and

00:05:07,290 --> 00:05:12,780
IP 6 gr 8 modules and made it easier for

00:05:10,950 --> 00:05:16,680
me to back ported to out of tree kernel

00:05:12,780 --> 00:05:19,740
modules as well so this allows Linux to

00:05:16,680 --> 00:05:21,930
act as an ER span traffic source you can

00:05:19,740 --> 00:05:24,840
send the ER span packets you can receive

00:05:21,930 --> 00:05:28,470
ER span packets and one of the kind of

00:05:24,840 --> 00:05:31,380
nice features about this is these ER

00:05:28,470 --> 00:05:34,020
span packets if you have reception set

00:05:31,380 --> 00:05:36,600
up for it the kernel will strip off all

00:05:34,020 --> 00:05:40,770
the outer layer stuff and you will see a

00:05:36,600 --> 00:05:45,090
packet as presented to a user at some

00:05:40,770 --> 00:05:46,500
end point and so it also allows for odd

00:05:45,090 --> 00:05:48,990
things like you can set up in the air

00:05:46,500 --> 00:05:51,120
span tunnel when use it like a GRE

00:05:48,990 --> 00:05:52,470
tunnel with the extra overhead there's

00:05:51,120 --> 00:05:54,810
no reason to do that but it's an

00:05:52,470 --> 00:05:58,860
interesting sort of side feature about

00:05:54,810 --> 00:06:01,250
this and the ER span feature is

00:05:58,860 --> 00:06:04,110
available with native tunnel support and

00:06:01,250 --> 00:06:06,660
metadata mode tunnel support or or what

00:06:04,110 --> 00:06:09,210
some people call lightweight tunnels

00:06:06,660 --> 00:06:12,930
I prefer metadata mode myself I think

00:06:09,210 --> 00:06:15,390
it's more descriptive so there's some

00:06:12,930 --> 00:06:17,460
common ER span use cases you can debug

00:06:15,390 --> 00:06:22,620
Network issues by tracking the control

00:06:17,460 --> 00:06:25,350
and data front frames seeing us how GRE

00:06:22,620 --> 00:06:27,990
is used to encapsulate these packets

00:06:25,350 --> 00:06:30,630
that are appearing on a source port

00:06:27,990 --> 00:06:34,890
there's going to be some limitation in

00:06:30,630 --> 00:06:37,800
the amount of or the the speed at which

00:06:34,890 --> 00:06:41,150
you can capture and then take these

00:06:37,800 --> 00:06:45,240
frames and send them on over to another

00:06:41,150 --> 00:06:47,250
point on the network for analysis so I

00:06:45,240 --> 00:06:51,780
think you know it's probably more useful

00:06:47,250 --> 00:06:53,580
for debugging control issues you can as

00:06:51,780 --> 00:06:54,990
it mentions there's voice over IP

00:06:53,580 --> 00:06:57,720
the packets for delay and jitter

00:06:54,990 --> 00:07:02,580
analysis you can do some latency

00:06:57,720 --> 00:07:05,729
analysis most you know you've your usual

00:07:02,580 --> 00:07:07,979
round-trip times in the millisecond

00:07:05,729 --> 00:07:10,620
range you can do some fairly good

00:07:07,979 --> 00:07:13,009
latency analysis with those obviously if

00:07:10,620 --> 00:07:17,879
you start getting down into very small

00:07:13,009 --> 00:07:19,830
packet interframe gaps then the latency

00:07:17,879 --> 00:07:21,330
analysis might not work in those cases

00:07:19,830 --> 00:07:23,009
you'll have to be closer to the

00:07:21,330 --> 00:07:25,620
situation but you know if you're having

00:07:23,009 --> 00:07:27,419
problems with the 60 second nanosecond

00:07:25,620 --> 00:07:29,159
gaps you're probably gonna want to get

00:07:27,419 --> 00:07:31,229
closer to the source of the problem

00:07:29,159 --> 00:07:34,139
anyway with a piece of networking

00:07:31,229 --> 00:07:36,090
equipment and you can monitor your

00:07:34,139 --> 00:07:40,530
traffic network traffic for anomalies

00:07:36,090 --> 00:07:41,819
there's all sorts of you know artificial

00:07:40,530 --> 00:07:44,099
intelligence that you can apply to

00:07:41,819 --> 00:07:46,639
packet streams that you capture or this

00:07:44,099 --> 00:07:49,919
remote port sent back for analysis

00:07:46,639 --> 00:07:52,229
getting entire conversation and then do

00:07:49,919 --> 00:07:57,599
some analysis of what's going on on

00:07:52,229 --> 00:08:01,770
those traffic connections here's the ER

00:07:57,599 --> 00:08:06,379
spam packet example it only works on the

00:08:01,770 --> 00:08:09,240
Ethernet so far as I know I I think the

00:08:06,379 --> 00:08:13,589
specification allows for other types of

00:08:09,240 --> 00:08:17,460
frame types packet types but as of now

00:08:13,589 --> 00:08:20,099
only Ethernet is supported so you have

00:08:17,460 --> 00:08:22,529
your Ethernet IP header GRE generic

00:08:20,099 --> 00:08:24,800
routing encapsulation then your ER span

00:08:22,529 --> 00:08:24,800
header

00:08:40,340 --> 00:08:43,930
it doesn't work you can use this one

00:08:52,720 --> 00:08:58,790
okay so there's two types of ear span

00:08:56,660 --> 00:09:02,750
headers we'll get into those and then

00:08:58,790 --> 00:09:02,900
again it only encapsulate encapsulate

00:09:02,750 --> 00:09:05,420
s--

00:09:02,900 --> 00:09:08,300
ether type packets so that's why I show

00:09:05,420 --> 00:09:18,800
either it doesn't necessarily have to be

00:09:08,300 --> 00:09:24,410
IP here okay there we go sorry about

00:09:18,800 --> 00:09:28,160
that okay so and here's some ER spanned

00:09:24,410 --> 00:09:30,980
a tunnel setup examples you may have a

00:09:28,160 --> 00:09:34,130
bunch of physical machines on some you

00:09:30,980 --> 00:09:36,260
know network XY or z out there these

00:09:34,130 --> 00:09:36,860
links are all connected to a cisco

00:09:36,260 --> 00:09:42,950
switch

00:09:36,860 --> 00:09:46,100
it's a 10.1 1.0 network via 10.1.1.10

00:09:42,950 --> 00:09:49,700
it's connected to a cisco switch which

00:09:46,100 --> 00:09:53,530
then does some routing and and sends the

00:09:49,700 --> 00:09:56,330
ER span tunnel data to the sniffer

00:09:53,530 --> 00:09:58,760
another example this is one I'm most

00:09:56,330 --> 00:10:00,620
familiar with here is where you have a

00:09:58,760 --> 00:10:02,540
machine and that's running a bunch of

00:10:00,620 --> 00:10:05,300
virtual machines you know you have a

00:10:02,540 --> 00:10:07,670
bare-metal machine it's got k vm or some

00:10:05,300 --> 00:10:10,340
other type of hypervisor loaded it's got

00:10:07,670 --> 00:10:11,810
some virtual machines running on it they

00:10:10,340 --> 00:10:15,320
each have their own network addresses

00:10:11,810 --> 00:10:17,660
and their own capabilities but open V

00:10:15,320 --> 00:10:20,270
switch will allow you to set up an ear

00:10:17,660 --> 00:10:23,180
span tunnel and take traffic that

00:10:20,270 --> 00:10:25,490
appears on one of the ports on that

00:10:23,180 --> 00:10:30,320
Linux machine and again send it on over

00:10:25,490 --> 00:10:32,720
to a sniffer and then just just the

00:10:30,320 --> 00:10:33,910
Linux box it's not a network someplace

00:10:32,720 --> 00:10:36,440
out there in the world

00:10:33,910 --> 00:10:38,240
they've got Linux net devs they can set

00:10:36,440 --> 00:10:41,780
up an ER span native or lightweight

00:10:38,240 --> 00:10:44,600
tunnel and again get that traffic across

00:10:41,780 --> 00:10:48,140
a routable network over to a sniffer

00:10:44,600 --> 00:10:52,700
where issues can be analyzed and

00:10:48,140 --> 00:10:54,140
resolved hopefully all right so the

00:10:52,700 --> 00:10:57,200
Linux native tunnel versus

00:10:54,140 --> 00:10:59,030
meta-data mode tunnel there are two

00:10:57,200 --> 00:11:02,180
types of tunnel implementations of the

00:10:59,030 --> 00:11:05,450
Linux kernel there's native tunnel and

00:11:02,180 --> 00:11:07,370
the metadata mode lightweight tunnel for

00:11:05,450 --> 00:11:10,340
more information on lightweight tunnels

00:11:07,370 --> 00:11:12,260
if you're interested thomas graph wrote

00:11:10,340 --> 00:11:14,600
an article that was very useful to me to

00:11:12,260 --> 00:11:16,730
kind of figure out what's what the

00:11:14,600 --> 00:11:18,700
difference is there so I have a link

00:11:16,730 --> 00:11:22,190
there it's also at the end of the slides

00:11:18,700 --> 00:11:24,920
so first we have the native tunnel and

00:11:22,190 --> 00:11:27,050
that is created with a per ton of

00:11:24,920 --> 00:11:29,150
specific configuration in other words

00:11:27,050 --> 00:11:32,660
you're creating a network device this

00:11:29,150 --> 00:11:37,490
network device has specific tunnel

00:11:32,660 --> 00:11:41,780
configurations for key IP address any

00:11:37,490 --> 00:11:44,780
other types of encapsulations or options

00:11:41,780 --> 00:11:46,340
that are specific for that type of

00:11:44,780 --> 00:11:48,980
tunnel okay

00:11:46,340 --> 00:11:52,190
so we can create a gr there's an example

00:11:48,980 --> 00:11:54,140
they're done with a gr tunnel where you

00:11:52,190 --> 00:11:59,240
say hey we want to have sequence numbers

00:11:54,140 --> 00:12:02,780
here's the key the local IP and and you

00:11:59,240 --> 00:12:05,860
can just add that as a tunnel and it

00:12:02,780 --> 00:12:08,840
will work pretty pretty darn well but

00:12:05,860 --> 00:12:10,370
there's a result of that for each tunnel

00:12:08,840 --> 00:12:12,740
you have to create another DEATH device

00:12:10,370 --> 00:12:16,340
and so that does not scale well across

00:12:12,740 --> 00:12:21,580
large deployments which are very common

00:12:16,340 --> 00:12:24,410
these days with metadata mode tunnels

00:12:21,580 --> 00:12:29,810
this resolves a scaling issue you create

00:12:24,410 --> 00:12:32,660
one okay represents multiple tunnels and

00:12:29,810 --> 00:12:35,480
these multiple tunnels are represented

00:12:32,660 --> 00:12:38,150
through the metadata that is presented

00:12:35,480 --> 00:12:43,310
to the tunnel when you want to transmit

00:12:38,150 --> 00:12:46,430
and encapsulate a packet metadata mode

00:12:43,310 --> 00:12:48,680
that comes along will have there's quite

00:12:46,430 --> 00:12:49,910
a few different fields there you you'll

00:12:48,680 --> 00:12:51,200
just have to look at them see what's

00:12:49,910 --> 00:12:53,180
available to you there as far as

00:12:51,200 --> 00:12:55,430
metadata but it is a way of

00:12:53,180 --> 00:12:58,640
encapsulating all the data that was

00:12:55,430 --> 00:13:01,670
generally used for the native tunnel

00:12:58,640 --> 00:13:04,150
into that's now in this metadata mode

00:13:01,670 --> 00:13:06,130
structure which is passed in and that's

00:13:04,150 --> 00:13:10,000
used to create and encapsulate a packet

00:13:06,130 --> 00:13:12,220
at that level so open V switch uses

00:13:10,000 --> 00:13:16,860
lightweight tunnels I think they're

00:13:12,220 --> 00:13:21,550
they're far more useful for most things

00:13:16,860 --> 00:13:24,490
there's some uses there and in the Linux

00:13:21,550 --> 00:13:28,420
kernel you can see an example of a

00:13:24,490 --> 00:13:30,400
lightweight tunnel using EBP F my

00:13:28,420 --> 00:13:33,670
colleague William wrote a blood of that

00:13:30,400 --> 00:13:36,160
code I think and you can go look at that

00:13:33,670 --> 00:13:38,290
and see an example of lightweight tunnel

00:13:36,160 --> 00:13:40,960
with EBP F and how it works

00:13:38,290 --> 00:13:43,210
it's of course a trivial example and

00:13:40,960 --> 00:13:45,610
it's mostly of course self tests it's

00:13:43,210 --> 00:13:50,350
intended to just make sure that the

00:13:45,610 --> 00:13:53,260
basic kernel support is there it's not

00:13:50,350 --> 00:13:55,720
intended to be a complete tutorial of

00:13:53,260 --> 00:13:57,790
course but it's a helpful for somebody

00:13:55,720 --> 00:14:00,430
like me I've never worked with EPF like

00:13:57,790 --> 00:14:11,260
wake tunnels I come from a very device

00:14:00,430 --> 00:14:13,090
or a net background so so our ear span

00:14:11,260 --> 00:14:15,340
protocol headers let's talk about your

00:14:13,090 --> 00:14:18,760
span protocol headers alright again

00:14:15,340 --> 00:14:22,210
we've already seen this the outer packet

00:14:18,760 --> 00:14:24,400
header the ether IP GRE ER span we'll

00:14:22,210 --> 00:14:27,940
talk more about the types of year span

00:14:24,400 --> 00:14:29,920
headers as we come up here but the GRE

00:14:27,940 --> 00:14:35,380
is a fixed byte header with a sequence

00:14:29,920 --> 00:14:37,990
number GRE flags allow a number of

00:14:35,380 --> 00:14:42,580
different options for GRE but it's

00:14:37,990 --> 00:14:45,460
mandatory for year span to only specify

00:14:42,580 --> 00:14:49,900
the sequence number in the flags for the

00:14:45,460 --> 00:14:52,360
GRE header an interesting bug occurs if

00:14:49,900 --> 00:14:55,870
you try to well just doesn't work and it

00:14:52,360 --> 00:14:59,050
breaks horribly if you try to do just a

00:14:55,870 --> 00:15:01,510
sequence number only and that will work

00:14:59,050 --> 00:15:03,790
for you you can see there there are two

00:15:01,510 --> 00:15:06,280
types of ER span there's a year span

00:15:03,790 --> 00:15:09,430
type two year span type three you can

00:15:06,280 --> 00:15:14,950
look at the next protocol header type in

00:15:09,430 --> 00:15:16,880
the GRE header and that will tell you

00:15:14,950 --> 00:15:20,720
what type of ER span headers

00:15:16,880 --> 00:15:24,170
to follow so let's go off and look at

00:15:20,720 --> 00:15:26,450
the GRE header as you can see there I

00:15:24,170 --> 00:15:29,180
didn't call it out but in the flags you

00:15:26,450 --> 00:15:31,310
see that that one that bit set to one

00:15:29,180 --> 00:15:34,760
there that's the sequence number and all

00:15:31,310 --> 00:15:37,310
others should be zero okay and then you

00:15:34,760 --> 00:15:41,630
have a 16-bit protocol tie for ER span

00:15:37,310 --> 00:15:42,140
there again we call that out hex a b

00:15:41,630 --> 00:15:46,640
efore

00:15:42,140 --> 00:15:49,370
type 2 hex 2 to be e4 type 3 and these

00:15:46,640 --> 00:15:52,070
are assigned numbers and then their

00:15:49,370 --> 00:15:54,110
sequence number which is what really

00:15:52,070 --> 00:15:57,500
makes sense here for this type of

00:15:54,110 --> 00:15:59,960
situation allows you to see if well if

00:15:57,500 --> 00:16:02,180
GRE packet got lost in transmission on

00:15:59,960 --> 00:16:03,710
its way to you you can go and look at

00:16:02,180 --> 00:16:05,150
sequence numbers of the package you're

00:16:03,710 --> 00:16:07,910
receiving and see if there's any holes

00:16:05,150 --> 00:16:10,910
in the data that that's being presented

00:16:07,910 --> 00:16:13,940
to you from the source port that you're

00:16:10,910 --> 00:16:18,860
trying to monitor so that can be very

00:16:13,940 --> 00:16:21,620
helpful in debugging situations so

00:16:18,860 --> 00:16:26,600
here's our ER span header it's a version

00:16:21,620 --> 00:16:30,320
1 tied to don't ask me what happened to

00:16:26,600 --> 00:16:33,740
version 1 or version 0 type 1 I never

00:16:30,320 --> 00:16:36,650
saw it so presumably it died on the

00:16:33,740 --> 00:16:40,490
testing table but we have a year span

00:16:36,650 --> 00:16:43,430
header version 1 type 2 and this one you

00:16:40,490 --> 00:16:45,740
have a VLAN the that's the original VLAN

00:16:43,430 --> 00:16:47,840
that the packet the source packet that

00:16:45,740 --> 00:16:51,620
the source monitoring port was on a

00:16:47,840 --> 00:16:53,840
class of service that's derived from the

00:16:51,620 --> 00:16:56,930
package the VLAN and capsule ization

00:16:53,840 --> 00:17:01,400
type I think that would be there's like

00:16:56,930 --> 00:17:03,290
trunk or non trunk I think it's malade

00:17:01,400 --> 00:17:07,579
it to that type of whether it's a trunk

00:17:03,290 --> 00:17:09,470
VLAN or not the truncation well

00:17:07,579 --> 00:17:11,060
indicates if this packet had to be

00:17:09,470 --> 00:17:13,160
truncated in order to make it across the

00:17:11,060 --> 00:17:14,870
network to you obviously if you're

00:17:13,160 --> 00:17:17,360
adding headers and all these good things

00:17:14,870 --> 00:17:19,790
to a packet in order to send it across a

00:17:17,360 --> 00:17:21,829
roundel network to get to somebody for

00:17:19,790 --> 00:17:24,800
analysis somewhere else in the world

00:17:21,829 --> 00:17:27,760
that's going to add data to the packet

00:17:24,800 --> 00:17:28,820
and it may have to be truncated the

00:17:27,760 --> 00:17:30,320
encapsulated

00:17:28,820 --> 00:17:33,110
Paquette and they have to be truncated

00:17:30,320 --> 00:17:36,529
in order for it to reach you so that's

00:17:33,110 --> 00:17:43,250
an indication of that then there's a

00:17:36,529 --> 00:17:46,580
session ID okay the session ID is set

00:17:43,250 --> 00:17:50,330
when you configure the tunnel and then

00:17:46,580 --> 00:17:53,179
the index can be used for whatever any

00:17:50,330 --> 00:17:56,509
particular user wants it to be used for

00:17:53,179 --> 00:17:58,190
its platform dependent and I get the

00:17:56,509 --> 00:18:00,470
feeling that's just something that user

00:17:58,190 --> 00:18:03,200
space can use for their own purposes

00:18:00,470 --> 00:18:04,330
there I've not seen a lot of examples of

00:18:03,200 --> 00:18:09,679
that

00:18:04,330 --> 00:18:13,690
William yeah I haven't seen a lot of use

00:18:09,679 --> 00:18:13,690
of index for for for platform dependent

00:18:13,929 --> 00:18:19,970
uses at this point but as this

00:18:17,870 --> 00:18:22,519
technology matures people get more

00:18:19,970 --> 00:18:24,950
familiar with it I hope that people can

00:18:22,519 --> 00:18:26,899
make use of those fields so there are

00:18:24,950 --> 00:18:28,309
there are those two new IP route 2

00:18:26,899 --> 00:18:31,419
configurable fields and then that link

00:18:28,309 --> 00:18:34,970
API there's the session ID and the index

00:18:31,419 --> 00:18:37,879
and those are there for you to use as

00:18:34,970 --> 00:18:41,090
required for your purposes ER span

00:18:37,879 --> 00:18:44,509
doesn't use the GRE key so it repurposes

00:18:41,090 --> 00:18:46,549
the GRE key i keoki for the session ID

00:18:44,509 --> 00:18:48,649
okay and that's all just done via IP

00:18:46,549 --> 00:18:52,580
route 2 when you configure the ER span

00:18:48,649 --> 00:18:55,370
tunnel the index is also configurable

00:18:52,580 --> 00:18:56,720
via IP route 2 again that's just it's

00:18:55,370 --> 00:18:58,460
just passed through its for your

00:18:56,720 --> 00:19:01,340
application it's for you to keep track

00:18:58,460 --> 00:19:03,500
of sessions or well another session ID

00:19:01,340 --> 00:19:05,029
but it's for you to keep track of other

00:19:03,500 --> 00:19:07,720
things that you may want to know about

00:19:05,029 --> 00:19:11,389
that particular connection that that

00:19:07,720 --> 00:19:13,100
that monitoring port the class of

00:19:11,389 --> 00:19:15,710
service and VLAN are extracted from the

00:19:13,100 --> 00:19:18,679
original frame and then the truncate bit

00:19:15,710 --> 00:19:23,389
is set if any of these conditions here

00:19:18,679 --> 00:19:25,129
are met we look at all of those and any

00:19:23,389 --> 00:19:26,289
of them were set then the truncate bit

00:19:25,129 --> 00:19:32,269
is set

00:19:26,289 --> 00:19:36,529
so that's version 1 type 2 and here's

00:19:32,269 --> 00:19:38,809
version 2 type 3 okay and as you can see

00:19:36,529 --> 00:19:39,590
there's some additional information set

00:19:38,809 --> 00:19:41,299
into this rain

00:19:39,590 --> 00:19:44,960
which can be very useful for people who

00:19:41,299 --> 00:19:47,299
want to do the type of jitter analysis

00:19:44,960 --> 00:19:50,900
or latency analysis that we mentioned

00:19:47,299 --> 00:19:54,230
earlier again we still have the VLAN

00:19:50,900 --> 00:19:56,299
class service fields we there's an

00:19:54,230 --> 00:20:00,799
additional field now called bat short or

00:19:56,299 --> 00:20:04,460
oversized so that's a nice addition so

00:20:00,799 --> 00:20:07,039
if you have a NIC card or a source port

00:20:04,460 --> 00:20:10,100
configured to collect bad short or

00:20:07,039 --> 00:20:14,240
oversized frames then those can be

00:20:10,100 --> 00:20:17,390
checked and that can be indicated with

00:20:14,240 --> 00:20:19,429
the encapsulated packet you solve your

00:20:17,390 --> 00:20:22,309
truncation bit your session ID there's a

00:20:19,429 --> 00:20:24,890
32 bit time stamp added now that

00:20:22,309 --> 00:20:28,640
timestamp is just from the same time get

00:20:24,890 --> 00:20:30,919
real-time and I'm pretty sure that's a

00:20:28,640 --> 00:20:34,779
hundred micro second grand yyl era tea I

00:20:30,919 --> 00:20:38,750
think what I recall then there's a

00:20:34,779 --> 00:20:42,529
security group tag that is unused at

00:20:38,750 --> 00:20:44,570
this time I can imagine uses for that

00:20:42,529 --> 00:20:48,230
but there's no use for it right now so

00:20:44,570 --> 00:20:51,649
if somebody wants to make use of that

00:20:48,230 --> 00:20:53,899
sure patches are always welcome

00:20:51,649 --> 00:20:56,840
then there's the payload type and the

00:20:53,899 --> 00:20:59,570
frame type those are also unused at this

00:20:56,840 --> 00:21:02,809
time in Linux again I think there's some

00:20:59,570 --> 00:21:06,130
great opportunities there to expand the

00:21:02,809 --> 00:21:09,770
implementation of the air span and to

00:21:06,130 --> 00:21:11,260
get those to work one thing I can

00:21:09,770 --> 00:21:15,350
certainly think of is it'd be nice to

00:21:11,260 --> 00:21:17,990
get frame relay or PPP or some other

00:21:15,350 --> 00:21:19,669
types of frame type supported so that we

00:21:17,990 --> 00:21:21,970
can use these on not just Ethernet

00:21:19,669 --> 00:21:26,149
interfaces but land interfaces as well I

00:21:21,970 --> 00:21:28,940
think that's another useful improvement

00:21:26,149 --> 00:21:31,880
that could be made the hardware ID I'm

00:21:28,940 --> 00:21:33,289
not sure I've looked around I can't

00:21:31,880 --> 00:21:36,130
figure out what that's about but it's

00:21:33,289 --> 00:21:36,130
always has to be for

00:21:36,380 --> 00:21:41,980
[Laughter]

00:21:51,840 --> 00:21:56,890
alright then there's a moving along but

00:21:55,179 --> 00:22:00,070
there's a direction bit

00:21:56,890 --> 00:22:02,440
that's for ingress/egress there's a

00:22:00,070 --> 00:22:05,950
couple of bits for granularity there

00:22:02,440 --> 00:22:08,470
that will that's can be used to indicate

00:22:05,950 --> 00:22:10,780
the granularity of the time stamp I

00:22:08,470 --> 00:22:15,040
mentioned right now it's all hard-coded

00:22:10,780 --> 00:22:17,830
to the 100 microsecond a time stamp so

00:22:15,040 --> 00:22:19,750
that's another place where some useful

00:22:17,830 --> 00:22:21,490
work can be done to improve this and

00:22:19,750 --> 00:22:25,450
allow for other types of granule

00:22:21,490 --> 00:22:29,110
granularities with a hundred microsecond

00:22:25,450 --> 00:22:32,520
granularity that's gonna be tough to you

00:22:29,110 --> 00:22:35,620
help with some types of jitter and and

00:22:32,520 --> 00:22:37,210
latency I mean if your jitter and

00:22:35,620 --> 00:22:38,559
latency is long enough then that will

00:22:37,210 --> 00:22:41,800
help you out but there's going to be

00:22:38,559 --> 00:22:44,620
times when many times when it's just the

00:22:41,800 --> 00:22:46,720
granularity is not quite enough for us

00:22:44,620 --> 00:22:50,140
there so I would hope that we can have

00:22:46,720 --> 00:22:51,610
some sort of improvements made there I'm

00:22:50,140 --> 00:22:53,500
thinking about it

00:22:51,610 --> 00:22:57,390
then there's the optional platform sub

00:22:53,500 --> 00:22:57,390
header that is also unused at this time

00:22:58,290 --> 00:23:06,940
ok ok yeah so the tie to the version 2

00:23:04,780 --> 00:23:08,950
type 3 implementation and I stumble over

00:23:06,940 --> 00:23:11,620
that all the time I hated version 2 type

00:23:08,950 --> 00:23:13,690
3 anyway uh introduces another couple

00:23:11,620 --> 00:23:16,590
fields to the kernel through that blank

00:23:13,690 --> 00:23:19,000
API the hardware ID and the direction

00:23:16,590 --> 00:23:21,700
ingress or egress so you can specify

00:23:19,000 --> 00:23:26,920
whether you want to get ingress data

00:23:21,700 --> 00:23:28,660
only or egress data that's good because

00:23:26,920 --> 00:23:29,710
sometimes you don't care about what's

00:23:28,660 --> 00:23:31,210
happening in one direction you just

00:23:29,710 --> 00:23:34,510
won't see what's happening in another

00:23:31,210 --> 00:23:36,760
and especially in cases where there's a

00:23:34,510 --> 00:23:44,260
lot of bandwidth on the on the port can

00:23:36,760 --> 00:23:46,600
help you eliminate okay again the class

00:23:44,260 --> 00:23:48,160
service bad short oversize and

00:23:46,600 --> 00:23:51,130
truncation fields are

00:23:48,160 --> 00:23:52,870
inferred from the mirrored frame and

00:23:51,130 --> 00:23:54,580
this is where I've been talking about

00:23:52,870 --> 00:23:58,030
this the timestamp value is calculated

00:23:54,580 --> 00:24:00,700
by calling the K time get real kernel

00:23:58,030 --> 00:24:04,300
function and at this time only a hundred

00:24:00,700 --> 00:24:06,340
microseconds is supported the security

00:24:04,300 --> 00:24:10,390
group tag is hardly coordinates zero and

00:24:06,340 --> 00:24:13,510
I mentioned that packet ID frame type is

00:24:10,390 --> 00:24:15,490
always 0 and 1 and there's no

00:24:13,510 --> 00:24:22,030
implementation of sub headers yet either

00:24:15,490 --> 00:24:26,230
so here we have a Cisco here span

00:24:22,030 --> 00:24:29,320
example I take it that this works I have

00:24:26,230 --> 00:24:35,230
not had a chance I don't have a Cisco

00:24:29,320 --> 00:24:40,660
switch and William assures me that it

00:24:35,230 --> 00:24:42,400
works with ok so here we have an example

00:24:40,660 --> 00:24:45,760
with open V switch now this one's a

00:24:42,400 --> 00:24:50,190
little closer to my domain and I like

00:24:45,760 --> 00:24:52,300
this I I got it from the paper that

00:24:50,190 --> 00:24:55,420
William was working on and then

00:24:52,300 --> 00:24:56,590
mentioned Joe stringer was a guy who he

00:24:55,420 --> 00:24:58,600
wrote a paper that explained how you

00:24:56,590 --> 00:24:59,920
could do this or something anyway we got

00:24:58,600 --> 00:25:02,230
into it looked at it and here's the way

00:24:59,920 --> 00:25:04,960
you can use it you of course you have to

00:25:02,230 --> 00:25:07,720
have the user space executables for open

00:25:04,960 --> 00:25:10,480
V switch installed but the open V switch

00:25:07,720 --> 00:25:15,100
KL just comes with the 4.19 kernel and

00:25:10,480 --> 00:25:19,900
so you can just do your OBS DP q DB CTL

00:25:15,100 --> 00:25:22,780
you had a data path then you can go

00:25:19,900 --> 00:25:25,470
ahead if you have a namespace and a 0p r

00:25:22,780 --> 00:25:29,650
v f1 whatever you go ahead and add that

00:25:25,470 --> 00:25:33,670
virtual ethernet device to your to your

00:25:29,650 --> 00:25:37,180
data path then you can go ahead and now

00:25:33,670 --> 00:25:39,970
again OBS uses lightweight tunnels so

00:25:37,180 --> 00:25:41,830
you want to use the IP link command to

00:25:39,970 --> 00:25:45,280
create a lightweight tunnel it's the

00:25:41,830 --> 00:25:50,650
external keyword that does that and then

00:25:45,280 --> 00:25:54,430
you take your your span tunnel add it to

00:25:50,650 --> 00:25:56,290
your data path now you know open V

00:25:54,430 --> 00:25:58,419
switch is open flow so you have

00:25:56,290 --> 00:26:00,160
at a flow to make things happen you go

00:25:58,419 --> 00:26:02,610
ahead and have that flow this is an

00:26:00,160 --> 00:26:05,140
example one it's a trivial example but

00:26:02,610 --> 00:26:07,510
you substitute the right parameters and

00:26:05,140 --> 00:26:09,760
it'll all work for you and note that the

00:26:07,510 --> 00:26:13,000
open V switch daemon is not required in

00:26:09,760 --> 00:26:16,150
this case normally people are going to

00:26:13,000 --> 00:26:17,740
run open V switch demon or they're gonna

00:26:16,150 --> 00:26:21,190
run something else to manage the

00:26:17,740 --> 00:26:24,429
database so but in this case you can

00:26:21,190 --> 00:26:26,250
just do all this with native Linux well

00:26:24,429 --> 00:26:31,750
and of course using the open V switch

00:26:26,250 --> 00:26:35,890
user space tools there's a Linux native

00:26:31,750 --> 00:26:39,160
mode tunnel example note that I did this

00:26:35,890 --> 00:26:42,960
with the 4.19 - RC 6 + kernel and IP

00:26:39,160 --> 00:26:45,370
route 2 of that particular version

00:26:42,960 --> 00:26:48,040
things can move around a little bit on

00:26:45,370 --> 00:26:50,110
you with kernel versions and IP around -

00:26:48,040 --> 00:26:51,880
so I just wanted to call that out I

00:26:50,110 --> 00:26:54,549
think it should work with any just about

00:26:51,880 --> 00:26:56,500
any recent kernel but I just like to

00:26:54,549 --> 00:26:58,840
call that out so if there's any question

00:26:56,500 --> 00:27:00,730
or if somebody tries this and it doesn't

00:26:58,840 --> 00:27:03,640
work they'll know what I was working

00:27:00,730 --> 00:27:06,070
with - I get this to go so in this case

00:27:03,640 --> 00:27:08,110
you see the example for using just a

00:27:06,070 --> 00:27:10,630
native mode tunnel that creates a net

00:27:08,110 --> 00:27:13,380
device we call it my ier span in this

00:27:10,630 --> 00:27:17,860
case and there's the parameters for it

00:27:13,380 --> 00:27:21,610
you cannot start the filtering until you

00:27:17,860 --> 00:27:24,390
add a queue disk you know so I created a

00:27:21,610 --> 00:27:30,580
queue disk and then add the filter to it

00:27:24,390 --> 00:27:32,559
and it starts to go so here's a

00:27:30,580 --> 00:27:35,290
lightweight tunnel here span example

00:27:32,559 --> 00:27:38,440
with EBP F and this is again this is

00:27:35,290 --> 00:27:40,360
based on the self tests that are in the

00:27:38,440 --> 00:27:43,799
Linux kernel you can go look at the code

00:27:40,360 --> 00:27:47,470
yourself and see how that's all done

00:27:43,799 --> 00:27:49,390
it's it's basically just a little bit

00:27:47,470 --> 00:27:52,330
different but you see where we add the

00:27:49,390 --> 00:27:54,610
TC filter this is really the basic the

00:27:52,330 --> 00:27:58,410
big difference from the previous example

00:27:54,610 --> 00:28:02,640
is a TC filter to add the BPF kernel

00:27:58,410 --> 00:28:04,470
program test tunnel of current Oh

00:28:02,640 --> 00:28:05,880
that source code is also in the

00:28:04,470 --> 00:28:08,190
self-test directory so you can go look

00:28:05,880 --> 00:28:11,190
at it and you tell which section you

00:28:08,190 --> 00:28:19,140
want to use and then again you use TC to

00:28:11,190 --> 00:28:20,940
start the filter I don't know if I'm

00:28:19,140 --> 00:28:23,580
trying to hold this thing up here okay

00:28:20,940 --> 00:28:26,360
so in conclusion you know Mary

00:28:23,580 --> 00:28:30,120
a very common troubleshooting technique

00:28:26,360 --> 00:28:36,840
reminds me of I had to do this

00:28:30,120 --> 00:28:38,970
SNMP Armand type project on a router I

00:28:36,840 --> 00:28:40,890
worked on back in 1992 a long time ago

00:28:38,970 --> 00:28:42,990
and so I looked at this what I was

00:28:40,890 --> 00:28:47,270
looking at are spanis going this is like

00:28:42,990 --> 00:28:50,730
SNMP Arman but it doesn't use asm1 or

00:28:47,270 --> 00:28:52,560
SNMP at all and I think it's it's

00:28:50,730 --> 00:28:58,470
probably a little more close to our

00:28:52,560 --> 00:29:00,120
heart as people but it does the same

00:28:58,470 --> 00:29:02,190
sort of thing takes packets from remote

00:29:00,120 --> 00:29:04,550
sources ships them off to somebody so

00:29:02,190 --> 00:29:08,460
that they can look at them and do their

00:29:04,550 --> 00:29:10,890
network analysis and the three primary

00:29:08,460 --> 00:29:13,920
ways open V switch kernel module with

00:29:10,890 --> 00:29:15,900
the data path tool native Modi or span

00:29:13,920 --> 00:29:20,040
tunnels or lightweight tunnels with EPF

00:29:15,900 --> 00:29:23,030
byte codes there's some additional

00:29:20,040 --> 00:29:26,970
resources a couple things for to look at

00:29:23,030 --> 00:29:29,250
related here cisco actually has a number

00:29:26,970 --> 00:29:33,260
of other good articles on just look up

00:29:29,250 --> 00:29:33,260
cisco VAR span if you are really curious

00:29:39,950 --> 00:29:46,499
[Applause]

00:29:46,880 --> 00:29:55,620
hey in your len experimental example

00:29:50,480 --> 00:29:57,510
your your IP link add command specified

00:29:55,620 --> 00:30:00,390
an ER span device type which I assume

00:29:57,510 --> 00:30:03,900
implies a GRE encapsulation yes is it

00:30:00,390 --> 00:30:05,670
possible to specify a non GRE

00:30:03,900 --> 00:30:07,410
encapsulated version of that device so

00:30:05,670 --> 00:30:09,000
that you can specify the encapsulation

00:30:07,410 --> 00:30:12,210
is something else with the lower device

00:30:09,000 --> 00:30:14,520
ie IPSec or something like that I don't

00:30:12,210 --> 00:30:15,500
believe so I think at this point year

00:30:14,520 --> 00:30:19,750
span is

00:30:15,500 --> 00:30:19,750
ended up on GRE typing capsulation

00:30:26,230 --> 00:30:38,420
anyone else ready good catch yeah yeah

00:30:36,380 --> 00:30:42,200
so yeah it's it's a sports thing at a

00:30:38,420 --> 00:30:44,120
diplomacy conference so um I had a

00:30:42,200 --> 00:30:45,950
question about security for this is it

00:30:44,120 --> 00:30:47,360
possible that you're you know the the

00:30:45,950 --> 00:30:49,760
MIR stuff can be man in the middle

00:30:47,360 --> 00:30:52,730
really easily because there's just you

00:30:49,760 --> 00:30:55,490
know kind of the sequence numbers are

00:30:52,730 --> 00:30:57,470
not changing dramatically or being

00:30:55,490 --> 00:30:59,210
checked is I was there I was wondering

00:30:57,470 --> 00:31:01,010
if there's even basic kind of security

00:30:59,210 --> 00:31:03,560
concerns around this or is everything

00:31:01,010 --> 00:31:09,260
just gonna be on an internal network so

00:31:03,560 --> 00:31:13,730
there's just no problem ever yeah it was

00:31:09,260 --> 00:31:16,370
related that's a great question and what

00:31:13,730 --> 00:31:20,150
I would say is at this point it's a

00:31:16,370 --> 00:31:26,710
fairly new technology I would say how

00:31:20,150 --> 00:31:28,190
much do you trust just a GRE tunnel okay

00:31:26,710 --> 00:31:33,230
there's your answer

00:31:28,190 --> 00:31:34,970
he doesn't trust it there's probably

00:31:33,230 --> 00:31:36,920
room for a lot of enhancements and

00:31:34,970 --> 00:31:39,050
things we can do with this but it is

00:31:36,920 --> 00:31:41,000
based upon GRE and did you're gonna

00:31:39,050 --> 00:31:48,560
however much you trust it is how much

00:31:41,000 --> 00:31:50,660
you trust URI I just wondering was there

00:31:48,560 --> 00:31:54,620
a way to D capsulate year span before or

00:31:50,660 --> 00:31:56,900
to sniff it before this existed well

00:31:54,620 --> 00:31:59,750
it's a Cisco technology so Cisco had

00:31:56,900 --> 00:32:01,490
year span in their switches for yeah I

00:31:59,750 --> 00:32:03,680
remember using it like a decade ago but

00:32:01,490 --> 00:32:07,550
I was wondering how I would have read it

00:32:03,680 --> 00:32:08,840
then excuse me can you teach me dump it

00:32:07,550 --> 00:32:11,930
or Wireshark it and still have it work

00:32:08,840 --> 00:32:16,210
even without this can you receive it

00:32:11,930 --> 00:32:16,210
with Wireshark for example without this

00:32:16,330 --> 00:32:24,890
yeah so the mirroring activity you do

00:32:22,310 --> 00:32:26,720
not have to set up a receiver for it you

00:32:24,890 --> 00:32:28,450
can just set this up to just send

00:32:26,720 --> 00:32:29,980
packets in a direction

00:32:28,450 --> 00:32:31,960
and not worry about whether they're

00:32:29,980 --> 00:32:34,149
received at the other end or not at the

00:32:31,960 --> 00:32:35,919
other end if you have a wire shock shark

00:32:34,149 --> 00:32:41,230
that's sitting there it should see the

00:32:35,919 --> 00:32:43,210
ipv4 GRE zero your AV zero and then if

00:32:41,230 --> 00:32:46,629
it's capable if it's newer Wireshark it

00:32:43,210 --> 00:32:48,279
should decode that's okay so this is

00:32:46,629 --> 00:32:51,460
doing both encapsulation and

00:32:48,279 --> 00:32:54,820
decapsulation it we do have the D

00:32:51,460 --> 00:33:01,299
capsulation yes so you like I said you

00:32:54,820 --> 00:33:03,909
can set up in traffic dua perps and all

00:33:01,299 --> 00:33:06,639
kinds of neat stuff you don't want to do

00:33:03,909 --> 00:33:10,109
that because of the overhead but yes

00:33:06,639 --> 00:33:17,109
there are receives of both ends yeah

00:33:10,109 --> 00:33:20,109
anyone else this slide that is displayed

00:33:17,109 --> 00:33:26,369
is probably easier to do with the tunnel

00:33:20,109 --> 00:33:33,489
key TC action than the EBP F it may be

00:33:26,369 --> 00:33:39,789
canceled comment okay I'm really very

00:33:33,489 --> 00:33:45,530
new it's probably one of the good

00:33:39,789 --> 00:33:50,280
reasons to be cool all right thank you

00:33:45,530 --> 00:33:50,280
[Applause]

00:33:54,520 --> 00:33:56,580

YouTube URL: https://www.youtube.com/watch?v=DItjNsku9zY


