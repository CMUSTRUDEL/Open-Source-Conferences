Title: LPC2018 - Linux SCTP is Catching Up and Going Above!
Publication date: 2018-12-04
Playlist: LPC2018 - Networking Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/102/
speaker:  Marcelo RIcardo Leitner (Red Hat), Xin Long (Red Hat)


SCTP is a transport protocol, like TCP and UDP, originating from SIGTRAN
IETF Working Group in the early 2000's with the initial objective of
supporting the transport of PSTN signalling over IP networks. It featured
multi-homing and multi-stream from the beginning, and since then there
have been a number of improvements that help it serve other purposes too,
such as support for Partial Reliability and Stream Scheduling.

Linux SCTP arrived late and was stuck. It wasn't as up to date as the
released RFCs, while it was also far behind other systems such as BSD,
and also suffered from performance problems. In the past 2 years, we
were dedicated to ensuring that these features were addressed and
focused on making many improvements. Now all the features from released
RFCs have been fully supported in Linux, and some from draft RFCs are
already ongoing. Besides, we've seen an obvious improvement in performance
in various scenarios.

In this talk we will first do a quick review on SCTP basics, including:

Background: Why SCTP is used for PSTN Signalling Transport, why other
applications are using or will use SCTP.
Architecture: The general SCTP structures and procedures implemented in
Linux kernel.
VS TCP/UDP: An overview of functions and applicability of SCTP, TCP and
UDP.
Then go through the improvements that were made in the past 2 years,
including:

SCTP-related projects in Linux: Other than kernel part, there are also
lksctp-tools, sctp-tests, tahi-sctp, etc.
Features implemented lately: RFC ones like Stream Scheduling, Message
Interleaving, Stream Reconfig, Partially Reliable Policy, and many
CMSGs, SndInfos, Socket APIs.
Improvements made recently: Big patchsets like SCTP Offload, Transport
Hashtable, SCTP Diag and Full SELinux support.
VS BSD: We will take a look at the difference between Linux and BSD now
regarding SCTP. You will be surprised to see that we've gone further
than other systems.
We will finish by reviewing a list of what is on our radar as well as next
steps, like:

Ongoing features: SCTP NAT and SCTP CMT, two big important features are
ongoing and already taking form, and more Performance Improvements in
kernel have also been started.
Code refactor: New Congestion Framework will be introduced, which will
be more flexible for SCTP to extend more Congestion Algorithms.
Hardware support: HW CRC Checksum and GSO will definitely make performance
better, for which a new segment logic for both .segment and HW that works
for SCTP chunks is needed.
RFC docs improvements: We believe that more extensions and revisions will
make SCTP more widespread.
For its powerfulness and complexity, SCTP is destined to face many challenges
and threats, but we believe that we have already and will continue to make it
better than that on other systems, but also than other transport protocols.
Please join us, Linux SCTP needs your help too!
Captions: 
	00:00:07,130 --> 00:00:13,100
so so far we're talking about low-level

00:00:10,010 --> 00:00:14,120
stuff and really fast packets flowing as

00:00:13,100 --> 00:00:17,830
fast as we can

00:00:14,120 --> 00:00:17,830
and now we are going to flip the switch

00:00:18,160 --> 00:00:24,400
we are going to valley layers above that

00:00:21,170 --> 00:00:29,779
and some heavy stuff as you will see

00:00:24,400 --> 00:00:33,860
this is a general idea of the talk what

00:00:29,779 --> 00:00:36,920
and why is a CTP what we have done on it

00:00:33,860 --> 00:00:41,360
for the past two years and what we plan

00:00:36,920 --> 00:00:44,809
to do next so a quick recap on bar is a

00:00:41,360 --> 00:00:47,840
CTP it may not be protocol that

00:00:44,809 --> 00:00:53,539
everybody is familiar with it was

00:00:47,840 --> 00:00:56,960
conceived to transfer the ss7 signaling

00:00:53,539 --> 00:00:59,359
protocol over IP networks so it's a

00:00:56,960 --> 00:01:03,320
protocol designed to transfer signals

00:00:59,359 --> 00:01:08,210
and not dope payload like TCP originally

00:01:03,320 --> 00:01:11,630
was and when it was conceived it had

00:01:08,210 --> 00:01:14,570
requirements there was too much for TCP

00:01:11,630 --> 00:01:18,770
and for UDP and they decided to create a

00:01:14,570 --> 00:01:21,200
new protocol setp so it's like this

00:01:18,770 --> 00:01:23,270
giant thing on which the application

00:01:21,200 --> 00:01:27,170
creates a socket like on the other ones

00:01:23,270 --> 00:01:30,380
but on this circuit you have out of our

00:01:27,170 --> 00:01:36,290
of the box butyou haami which flexing

00:01:30,380 --> 00:01:39,350
you have chunking on your message a CT P

00:01:36,290 --> 00:01:41,869
will break it into chunks for you so

00:01:39,350 --> 00:01:49,009
they can fit an IP packets without rely

00:01:41,869 --> 00:01:51,590
on fragmentation yeah and to give an

00:01:49,009 --> 00:01:57,469
idea on how complex its implementation

00:01:51,590 --> 00:02:00,490
is these are the main structures so it's

00:01:57,469 --> 00:02:03,020
pretty easy to do Kashmir's in there

00:02:00,490 --> 00:02:06,880
it's something that we are not really

00:02:03,020 --> 00:02:06,880
worried about because it will happen

00:02:07,160 --> 00:02:14,170
[Laughter]

00:02:10,600 --> 00:02:14,170
this is another

00:02:14,720 --> 00:02:21,720
this is another slide to give an idea on

00:02:18,800 --> 00:02:25,050
how the implementation looks like it's

00:02:21,720 --> 00:02:27,540
not stream and implementation like on

00:02:25,050 --> 00:02:32,910
TCP you have an entry point and then you

00:02:27,540 --> 00:02:34,740
go on on functions and as you hit point

00:02:32,910 --> 00:02:37,020
of decisions you do it and you take

00:02:34,740 --> 00:02:42,050
action right on that spots we have a

00:02:37,020 --> 00:02:46,560
state machine so we get to a point on

00:02:42,050 --> 00:02:50,010
for example we want to send an sac after

00:02:46,560 --> 00:02:52,020
we process this okay so we schedule that

00:02:50,010 --> 00:02:54,240
on our state machine and we continue

00:02:52,020 --> 00:02:57,570
processing and then when we return to

00:02:54,240 --> 00:02:59,820
the main loop of that setp do SM oh we

00:02:57,570 --> 00:03:03,480
have just a nanosec so we get back to

00:02:59,820 --> 00:03:05,550
that and we send it another big source

00:03:03,480 --> 00:03:08,220
of cache miss and that's five we have

00:03:05,550 --> 00:03:13,140
really don't worry about this low

00:03:08,220 --> 00:03:16,560
performance stuff to have an idea of the

00:03:13,140 --> 00:03:18,450
features between SATP TCP and UDP and we

00:03:16,560 --> 00:03:22,470
probably should add another column to

00:03:18,450 --> 00:03:27,080
this table for quick recent news the

00:03:22,470 --> 00:03:27,080
next HTTP version will be based on quick

00:03:32,720 --> 00:03:43,500
yep non-performance know TCP this is for

00:03:39,240 --> 00:03:45,540
a kind of 414 running on the row for TCP

00:03:43,500 --> 00:03:51,840
on 10 gig we can saturate the card

00:03:45,540 --> 00:03:57,710
pretty easily but on setp this line here

00:03:51,840 --> 00:04:00,510
is on 3.5 gigabit and by here we are

00:03:57,710 --> 00:04:02,910
hitting one course and per a hundred

00:04:00,510 --> 00:04:07,410
percent and we don't scale more than

00:04:02,910 --> 00:04:09,960
that we can't scale to more than one

00:04:07,410 --> 00:04:12,150
core because it's one socket so that's

00:04:09,960 --> 00:04:14,850
what we get out of its if you want to

00:04:12,150 --> 00:04:18,390
Mart to have more to put you have to use

00:04:14,850 --> 00:04:22,160
more sockets and that probably you have

00:04:18,390 --> 00:04:22,160
to build an special application for that

00:04:23,840 --> 00:04:32,310
Jesse asked with hardware offload for

00:04:30,360 --> 00:04:34,380
her afloat that's a big problem for us

00:04:32,310 --> 00:04:37,700
because currently only a few cards

00:04:34,380 --> 00:04:40,530
support at least crc32 of floating and

00:04:37,700 --> 00:04:44,010
none of them supports like gso of

00:04:40,530 --> 00:04:48,080
floating so that's the only thing we we

00:04:44,010 --> 00:04:50,610
have in this card head crc32 a floating

00:04:48,080 --> 00:04:53,070
and if you turn that off

00:04:50,610 --> 00:04:59,400
you have a big impact concert c-32 is

00:04:53,070 --> 00:05:03,420
way heavier than the checksum so what we

00:04:59,400 --> 00:05:05,250
have done on linux so far this is the

00:05:03,420 --> 00:05:08,370
good old library that we have to support

00:05:05,250 --> 00:05:10,410
applications on the left we have the

00:05:08,370 --> 00:05:14,220
main structure of the libraries

00:05:10,410 --> 00:05:16,710
directors on the right side we have

00:05:14,220 --> 00:05:18,870
first block the test applications that

00:05:16,710 --> 00:05:21,630
we have so we can just kick some tests

00:05:18,870 --> 00:05:23,750
in there and see check it using mucha

00:05:21,630 --> 00:05:29,400
streaming which is harming and

00:05:23,750 --> 00:05:31,890
connecting to multiple destinations that

00:05:29,400 --> 00:05:33,510
are the same socket because unless ATP

00:05:31,890 --> 00:05:36,090
we have something that we call one too

00:05:33,510 --> 00:05:39,300
many and one to one you can have the two

00:05:36,090 --> 00:05:43,320
styles on different sockets but you can

00:05:39,300 --> 00:05:45,210
have one association on one socket which

00:05:43,320 --> 00:05:46,770
we call tcp style

00:05:45,210 --> 00:05:49,440
and you can have one socket with

00:05:46,770 --> 00:05:51,840
multiple associations inside it which is

00:05:49,440 --> 00:05:53,639
HDPE style in each Association it's

00:05:51,840 --> 00:05:55,770
completely independent of the other ones

00:05:53,639 --> 00:05:59,479
and then you can connect to many other

00:05:55,770 --> 00:05:59,479
holes using multi-homing

00:06:00,289 --> 00:06:05,970
these librarians contains unit tests but

00:06:03,060 --> 00:06:07,530
you test the library itself and then the

00:06:05,970 --> 00:06:09,360
helper functions that userspace

00:06:07,530 --> 00:06:12,720
applications are suppose that you use

00:06:09,360 --> 00:06:16,949
because CTP has six calls like SATP

00:06:12,720 --> 00:06:20,729
Connect X 2 or 3 versions define a known

00:06:16,949 --> 00:06:23,520
RFC and to avoid adding tons of Cisco

00:06:20,729 --> 00:06:27,300
should to the kernel it was decided to

00:06:23,520 --> 00:06:30,900
add them through socket option calls and

00:06:27,300 --> 00:06:35,699
then this library masks it into helper

00:06:30,900 --> 00:06:43,740
functions this project that was created

00:06:35,699 --> 00:06:45,630
for testing general generalize testing

00:06:43,740 --> 00:06:49,530
setp gets pretty complicated because of

00:06:45,630 --> 00:06:51,690
mucha humming so we have to create one

00:06:49,530 --> 00:06:54,630
two three four paths to the other host

00:06:51,690 --> 00:06:57,090
and sometimes we want to bring some

00:06:54,630 --> 00:06:59,970
paths down or change them dual weild the

00:06:57,090 --> 00:07:02,240
associations running and writing a

00:06:59,970 --> 00:07:07,669
single test case from scratch gets very

00:07:02,240 --> 00:07:09,990
cumbersome so on this block here we have

00:07:07,669 --> 00:07:14,849
the share screen defining the topology

00:07:09,990 --> 00:07:18,630
for testing using IPSec and just a

00:07:14,849 --> 00:07:21,780
client/server this block is a test case

00:07:18,630 --> 00:07:25,070
that is running just using meta Ness and

00:07:21,780 --> 00:07:29,099
client router and server topology and

00:07:25,070 --> 00:07:32,300
this library handles of this work to

00:07:29,099 --> 00:07:35,669
create of all this environment for us

00:07:32,300 --> 00:07:39,719
and we have we can focus only on the

00:07:35,669 --> 00:07:43,620
test itself on this one it was changing

00:07:39,719 --> 00:07:47,969
M - while dissociation was running and

00:07:43,620 --> 00:07:50,009
flowing traffic so we could test the

00:07:47,969 --> 00:07:53,669
feedback from my cmp fragmentation

00:07:50,009 --> 00:07:56,029
needed and OPA datum - and going to do

00:07:53,669 --> 00:07:56,029
from there

00:07:57,130 --> 00:08:06,620
this is a note confirm ensuite then it

00:08:04,070 --> 00:08:10,340
tests if the implementation that you

00:08:06,620 --> 00:08:14,120
have is in accordance to the RFC it

00:08:10,340 --> 00:08:17,750
tests all these features and provides a

00:08:14,120 --> 00:08:21,620
report similar to to that one that's how

00:08:17,750 --> 00:08:25,550
we know that the implementation is in

00:08:21,620 --> 00:08:28,340
conformance to the FCS and we have

00:08:25,550 --> 00:08:31,160
others we have this color code anomic on

00:08:28,340 --> 00:08:32,960
which our first tests this color

00:08:31,160 --> 00:08:36,410
everybody knows right and cut the

00:08:32,960 --> 00:08:39,260
nomicon does fuzzy but from network side

00:08:36,410 --> 00:08:42,470
so it injects weird packets and

00:08:39,260 --> 00:08:46,280
hopefully we don't crash with it like a

00:08:42,470 --> 00:08:49,730
trio and scrappy to generate packets and

00:08:46,280 --> 00:08:53,050
check the response from them probably we

00:08:49,730 --> 00:08:57,100
have more in there

00:08:53,050 --> 00:09:02,060
this is known as watching that we did

00:08:57,100 --> 00:09:04,910
because of these one-to-many style that

00:09:02,060 --> 00:09:07,160
we have we have one socket that may have

00:09:04,910 --> 00:09:10,340
like a thousand associations under it

00:09:07,160 --> 00:09:14,290
and previously the implementation was

00:09:10,340 --> 00:09:17,660
using just a hash of associations and

00:09:14,290 --> 00:09:21,530
using just the port numbers as the hash

00:09:17,660 --> 00:09:24,620
key so when a pact came in we hashed the

00:09:21,530 --> 00:09:28,280
parts kuraki and we had to traverse this

00:09:24,620 --> 00:09:30,650
entire list of 1,000 entries to find to

00:09:28,280 --> 00:09:33,950
which Association that packet was and

00:09:30,650 --> 00:09:38,030
that was very time-consuming and we

00:09:33,950 --> 00:09:41,570
fixed that by switching to our hash

00:09:38,030 --> 00:09:47,630
table and not hashing associations

00:09:41,570 --> 00:09:51,500
anymore but transports and on transports

00:09:47,630 --> 00:09:56,600
now we can hash the part numbers and

00:09:51,500 --> 00:09:59,150
also the remote IP address then with

00:09:56,600 --> 00:10:03,020
this extra key the hash got more

00:09:59,150 --> 00:10:05,650
distributed and we that the list is got

00:10:03,020 --> 00:10:05,650
way shorter

00:10:08,149 --> 00:10:16,199
the question is why did we not use like

00:10:13,079 --> 00:10:19,799
the fool for taboo for that including

00:10:16,199 --> 00:10:22,910
the local IP address because then we

00:10:19,799 --> 00:10:26,850
would have to add all combinations from

00:10:22,910 --> 00:10:28,470
addresses from both sides to the ash as

00:10:26,850 --> 00:10:30,179
if it doesn't negotiate all these

00:10:28,470 --> 00:10:31,769
address we'll talk to that address and

00:10:30,179 --> 00:10:34,350
these other address we'll talk to that

00:10:31,769 --> 00:10:36,269
other address let's decide it on the fly

00:10:34,350 --> 00:10:42,470
according the routes that both systems

00:10:36,269 --> 00:10:42,470
have so to not have to add em verses and

00:10:43,309 --> 00:10:48,410
combinations we can use just the

00:10:45,959 --> 00:10:50,790
destination address which is probably

00:10:48,410 --> 00:10:53,189
which is the one that changes if you

00:10:50,790 --> 00:10:56,670
consider like the local one is mostly

00:10:53,189 --> 00:10:58,559
always the same and then we Traverse on

00:10:56,670 --> 00:11:00,869
the list of few entries to find the

00:10:58,559 --> 00:11:02,249
correct transport and finding the

00:11:00,869 --> 00:11:04,799
transport we already have the

00:11:02,249 --> 00:11:09,989
Association just like that's just a

00:11:04,799 --> 00:11:11,399
pointer why not make the RH table per

00:11:09,989 --> 00:11:16,009
endpoint and socket

00:11:11,399 --> 00:11:18,929
that's the both hash tables are global

00:11:16,009 --> 00:11:20,910
we cannot make that very end point and

00:11:18,929 --> 00:11:25,110
pair sake because then you would have an

00:11:20,910 --> 00:11:27,029
ash table you would have too many rush

00:11:25,110 --> 00:11:29,309
tables and you have to have another

00:11:27,029 --> 00:11:36,509
index systems you know which socket to

00:11:29,309 --> 00:11:41,309
need to look it doesn't make sense we

00:11:36,509 --> 00:11:44,850
did gso for a CTP remember that a CTP is

00:11:41,309 --> 00:11:49,470
mainly used for signaling so book

00:11:44,850 --> 00:11:52,709
transfers are not its strongest but when

00:11:49,470 --> 00:11:54,959
you are on localhost you can take some

00:11:52,709 --> 00:11:58,919
benefit of it if you are having big

00:11:54,959 --> 00:12:01,619
messes and without gso we have on the

00:11:58,919 --> 00:12:03,829
left side and we GSO we have from the

00:12:01,619 --> 00:12:06,660
right side you can see the difference on

00:12:03,829 --> 00:12:09,540
having the packets which book packets

00:12:06,660 --> 00:12:12,169
going down the stack and having one big

00:12:09,540 --> 00:12:12,169
pack going

00:12:12,510 --> 00:12:19,019
and when we considered that local system

00:12:15,810 --> 00:12:26,399
is also receiving this we get this boost

00:12:19,019 --> 00:12:30,620
on received path also it's brutally not

00:12:26,399 --> 00:12:34,829
practical to do Giro for a CTP because

00:12:30,620 --> 00:12:37,829
whenever a chunk ends it means that the

00:12:34,829 --> 00:12:39,300
message is done and we shouldn't wait to

00:12:37,829 --> 00:12:41,699
deliver that to the application because

00:12:39,300 --> 00:12:46,380
that's additional latency that it's not

00:12:41,699 --> 00:12:48,510
wanted if you have a read large message

00:12:46,380 --> 00:12:50,430
that's being fragmented and you have you

00:12:48,510 --> 00:12:53,100
are receiving it and you'll notice that

00:12:50,430 --> 00:12:56,220
the chunk doesn't have the end bit set

00:12:53,100 --> 00:13:00,959
you could delay it but consider that the

00:12:56,220 --> 00:13:03,690
main use case is signaling and to have

00:13:00,959 --> 00:13:10,589
that happen over the Internet

00:13:03,690 --> 00:13:14,930
it's very low probability we had support

00:13:10,589 --> 00:13:18,449
for sadp judge Marx previously we had

00:13:14,930 --> 00:13:22,319
pretty not much information about the

00:13:18,449 --> 00:13:25,529
CTP sockets on user space you should you

00:13:22,319 --> 00:13:27,959
had to look into - Brock to have

00:13:25,529 --> 00:13:30,660
informations about which associations

00:13:27,959 --> 00:13:33,449
were up which transports were up and it

00:13:30,660 --> 00:13:36,899
was not the best way to have information

00:13:33,449 --> 00:13:39,930
specially for a system administrator so

00:13:36,899 --> 00:13:44,970
we tested be general now only using SS -

00:13:39,930 --> 00:13:47,180
you can have this pretty nice view this

00:13:44,970 --> 00:13:51,120
socket for example that is listening for

00:13:47,180 --> 00:13:55,279
new requests and it has all these

00:13:51,120 --> 00:13:55,279
associations established under it

00:13:59,410 --> 00:14:06,500
did you have an idea tribe you cannot

00:14:02,540 --> 00:14:09,529
read that how many foods that we are

00:14:06,500 --> 00:14:11,420
exporting through this API it's really

00:14:09,529 --> 00:14:12,740
pretty much everything that we know on

00:14:11,420 --> 00:14:20,839
the circuit on kind of it's being

00:14:12,740 --> 00:14:24,550
exported to that other fixes that we we

00:14:20,839 --> 00:14:27,440
did destination search address selection

00:14:24,550 --> 00:14:30,170
as I mentioned the CTP doesn't negotiate

00:14:27,440 --> 00:14:34,130
which address will talk to which other

00:14:30,170 --> 00:14:36,440
address and when we are deciding that

00:14:34,130 --> 00:14:40,750
okay we are going to talk to address two

00:14:36,440 --> 00:14:45,440
of our field but we don't know which

00:14:40,750 --> 00:14:47,899
source we are going to use so it has a

00:14:45,440 --> 00:14:53,149
special housing that is down in there

00:14:47,899 --> 00:14:55,160
and we had to force let's say that we

00:14:53,149 --> 00:14:57,170
are using an address that it actually

00:14:55,160 --> 00:14:59,209
belongs to interface that pact is going

00:14:57,170 --> 00:15:01,220
out

00:14:59,209 --> 00:15:03,500
we did some receive me no improvements

00:15:01,220 --> 00:15:08,660
and we have to do more hinder we're

00:15:03,500 --> 00:15:11,420
going to have a issue handling messages

00:15:08,660 --> 00:15:14,589
of different sizes because we have one

00:15:11,420 --> 00:15:17,720
receive buffer and Linux wants to

00:15:14,589 --> 00:15:22,540
account for both payload and overhead on

00:15:17,720 --> 00:15:27,470
our buffer and we we have some serious

00:15:22,540 --> 00:15:29,540
issues in there because we don't have an

00:15:27,470 --> 00:15:34,730
average message size to rely on that's

00:15:29,540 --> 00:15:37,400
depending on the application when we get

00:15:34,730 --> 00:15:40,580
lots of small messages the overhead gets

00:15:37,400 --> 00:15:42,860
very considerable and then the

00:15:40,580 --> 00:15:45,740
advertising window that we do doesn't

00:15:42,860 --> 00:15:50,089
reflect the reality of the amount of

00:15:45,740 --> 00:15:53,000
buffer that we have left marshal will

00:15:50,089 --> 00:15:56,630
build fix him to handling refactor we

00:15:53,000 --> 00:16:00,410
had several places in the stack doing m2

00:15:56,630 --> 00:16:02,990
handling trying to calculate how much we

00:16:00,410 --> 00:16:08,450
can put into a packet and that was

00:16:02,990 --> 00:16:13,269
conversion to more consolidated code we

00:16:08,450 --> 00:16:18,769
had critical fixes on path until that

00:16:13,269 --> 00:16:22,040
like I was saying on that test case when

00:16:18,769 --> 00:16:25,700
you have one too many sockets when too

00:16:22,040 --> 00:16:27,430
many socket style and you receive an SME

00:16:25,700 --> 00:16:31,700
P fragmentation needed

00:16:27,430 --> 00:16:34,990
we weren't fixing that information on

00:16:31,700 --> 00:16:41,209
the correct association that was a

00:16:34,990 --> 00:16:44,630
pretty bad bug we had support for crc32

00:16:41,209 --> 00:16:48,880
of loading on v2 interfaces which helped

00:16:44,630 --> 00:16:48,880
a lot communication inside the same host

00:16:49,420 --> 00:16:54,769
other big features that we add stream

00:16:52,940 --> 00:17:00,579
schedules and user master interleaving

00:16:54,769 --> 00:17:02,660
both are defined on that RFC 80 to 60

00:17:00,579 --> 00:17:05,959
additional policies for a partial

00:17:02,660 --> 00:17:10,250
reliable control because setp you can

00:17:05,959 --> 00:17:12,110
say for example that a given messaging

00:17:10,250 --> 00:17:14,780
shouldn't be retransmitted more than

00:17:12,110 --> 00:17:18,980
three times if it reaches that you just

00:17:14,780 --> 00:17:21,380
drop the message and move on so for some

00:17:18,980 --> 00:17:22,910
protocol like VoIP you don't want to

00:17:21,380 --> 00:17:24,470
keep returns meeting because it doesn't

00:17:22,910 --> 00:17:25,689
make sense anymore and you could set

00:17:24,470 --> 00:17:31,760
this choose you

00:17:25,689 --> 00:17:34,250
it just wouldn't we transmit a stream

00:17:31,760 --> 00:17:37,580
reconfiguration by when the association

00:17:34,250 --> 00:17:42,410
is established both peers they say hey I

00:17:37,580 --> 00:17:45,500
need five streams for output I can use

00:17:42,410 --> 00:17:46,940
up to eight input and the other one does

00:17:45,500 --> 00:17:49,429
something similar and they agree on

00:17:46,940 --> 00:17:51,820
handshake but if during the association

00:17:49,429 --> 00:17:54,830
they want that you add another stream

00:17:51,820 --> 00:17:56,800
they would have to tear down that that

00:17:54,830 --> 00:18:00,500
Association in started from scratch and

00:17:56,800 --> 00:18:01,640
with this new RFC we can just add

00:18:00,500 --> 00:18:04,720
another stream to our running

00:18:01,640 --> 00:18:08,900
Association without having to reboot it

00:18:04,720 --> 00:18:12,890
and there's also a feature in there that

00:18:08,900 --> 00:18:16,070
we can reach that a given stream so when

00:18:12,890 --> 00:18:18,550
it that string doesn't have any data key

00:18:16,070 --> 00:18:22,760
with anymore we are able to reset it

00:18:18,550 --> 00:18:25,690
it's SSN feud and then that string is

00:18:22,760 --> 00:18:28,010
consumed that it was never used it

00:18:25,690 --> 00:18:31,190
rebooted France question you can start

00:18:28,010 --> 00:18:33,320
using again some applications wanted to

00:18:31,190 --> 00:18:35,659
do that because it's pretty much like

00:18:33,320 --> 00:18:40,390
when you close at a connection and you

00:18:35,659 --> 00:18:40,390
open anyone and everything from scratch

00:18:43,600 --> 00:18:50,210
sockets api extensions is a new set of

00:18:46,299 --> 00:18:53,690
extensions that the applications user

00:18:50,210 --> 00:18:55,940
applications can use to make use of setp

00:18:53,690 --> 00:18:58,940
more efficiently we will see more

00:18:55,940 --> 00:19:01,460
details a bit and food waste linux

00:18:58,940 --> 00:19:06,370
support no you can have a silly nukes

00:19:01,460 --> 00:19:11,210
policies saying that a given user cannot

00:19:06,370 --> 00:19:12,559
accept cannot make the windows a

00:19:11,210 --> 00:19:16,450
replication cannot connect to a

00:19:12,559 --> 00:19:21,669
different port then the policy saying

00:19:16,450 --> 00:19:25,010
that transport was that stream schedules

00:19:21,669 --> 00:19:29,870
before RS it be working on first-come

00:19:25,010 --> 00:19:32,840
first-serve base so you have multiple

00:19:29,870 --> 00:19:34,610
streams you are multiplexing it but you

00:19:32,840 --> 00:19:37,130
they are all the same and if the

00:19:34,610 --> 00:19:39,380
application cubed a ton of that data on

00:19:37,130 --> 00:19:42,140
stream 0 and another one or swim one

00:19:39,380 --> 00:19:46,220
that's how it's going to be sent and

00:19:42,140 --> 00:19:48,710
with stream schedules now we we can

00:19:46,220 --> 00:19:51,409
choose the how these streams will be

00:19:48,710 --> 00:19:57,320
serve it there we couldn't have run

00:19:51,409 --> 00:19:59,659
robbing first-come first-serve which is

00:19:57,320 --> 00:20:03,500
the default and we have another priority

00:19:59,659 --> 00:20:06,049
also so you can say that stream one has

00:20:03,500 --> 00:20:08,690
higher priority and smooth zero and by

00:20:06,049 --> 00:20:11,480
when you queue disorder message in there

00:20:08,690 --> 00:20:13,760
even though we you had a red key with

00:20:11,480 --> 00:20:17,510
like 10 messages on stream 0 that one

00:20:13,760 --> 00:20:19,600
will be sent as soon as possible but

00:20:17,510 --> 00:20:23,570
just this you still have a problem

00:20:19,600 --> 00:20:25,520
because using the original data chunk

00:20:23,570 --> 00:20:28,340
format SATP cannot send more than one

00:20:25,520 --> 00:20:31,520
fragmented message at the same time so

00:20:28,340 --> 00:20:34,850
if one stream is using fragmented

00:20:31,520 --> 00:20:37,399
message and a stream with a higher

00:20:34,850 --> 00:20:38,690
priority comes in it has to wait that

00:20:37,399 --> 00:20:41,300
hole

00:20:38,690 --> 00:20:44,900
massive get done and then you can send

00:20:41,300 --> 00:20:48,830
it with the new data chunk from it I

00:20:44,900 --> 00:20:52,370
data it allows master interleaving so

00:20:48,830 --> 00:20:55,610
this other stream can preempt the other

00:20:52,370 --> 00:21:01,070
one and send its message before the

00:20:55,610 --> 00:21:04,520
other one completed and as you can maybe

00:21:01,070 --> 00:21:14,030
see we have more indirect calls in the

00:21:04,520 --> 00:21:17,780
code and spectrum the additional partial

00:21:14,030 --> 00:21:23,090
realized policies that we have time to

00:21:17,780 --> 00:21:25,910
leave you tell the stack that for a

00:21:23,090 --> 00:21:29,000
given association that those messages

00:21:25,910 --> 00:21:31,550
should expire after 100 milliseconds

00:21:29,000 --> 00:21:33,770
then you kill one message another

00:21:31,550 --> 00:21:37,430
message and other mesh as long as once

00:21:33,770 --> 00:21:39,980
but if something happens if there's some

00:21:37,430 --> 00:21:41,990
congestion packet drops or whatever if

00:21:39,980 --> 00:21:44,810
the message doesn't get delivered

00:21:41,990 --> 00:21:48,500
between before 100 milliseconds that

00:21:44,810 --> 00:21:51,950
message gets drop it and the next one if

00:21:48,500 --> 00:21:55,190
not expired also it will get sent and as

00:21:51,950 --> 00:21:56,810
it be handles this expiring for you the

00:21:55,190 --> 00:22:00,440
application doesn't have to do anything

00:21:56,810 --> 00:22:03,590
else just inform well expired and move

00:22:00,440 --> 00:22:05,870
on and that's pretty handy because then

00:22:03,590 --> 00:22:08,150
the application doesn't have to do that

00:22:05,870 --> 00:22:12,680
by itself like controlling how much of

00:22:08,150 --> 00:22:17,260
sank buffer you are queuing limited

00:22:12,680 --> 00:22:22,940
retransmission spoils a scribe just ago

00:22:17,260 --> 00:22:27,530
and priorities so priority is not

00:22:22,940 --> 00:22:31,150
related to the stream schedules they

00:22:27,530 --> 00:22:33,950
work on a different way but you can have

00:22:31,150 --> 00:22:37,010
another string which are a higher

00:22:33,950 --> 00:22:39,650
priority of often another one and if you

00:22:37,010 --> 00:22:41,390
have a full buffer and you are trying to

00:22:39,650 --> 00:22:43,610
kill something on this higher priority

00:22:41,390 --> 00:22:49,790
stream it will drop the message on the

00:22:43,610 --> 00:22:52,299
lower priority one it's a way to make

00:22:49,790 --> 00:22:58,749
more intelligent use

00:22:52,299 --> 00:23:01,359
the buffer for a stream reconfiguration

00:22:58,749 --> 00:23:03,459
yeah just also describing it

00:23:01,359 --> 00:23:08,700
you can add outgoing streams add

00:23:03,459 --> 00:23:08,700
incoming streams reset both streams

00:23:09,389 --> 00:23:17,739
it'll be that you the applications can

00:23:12,999 --> 00:23:22,629
have the association lasting longer for

00:23:17,739 --> 00:23:24,940
socket API s4 user API we had a city

00:23:22,629 --> 00:23:29,379
peace and V and as it P receive V

00:23:24,940 --> 00:23:37,059
functions these are implemented on llke

00:23:29,379 --> 00:23:39,789
SCTP tools library send info flags they

00:23:37,059 --> 00:23:42,399
sent all it's meant to send this message

00:23:39,789 --> 00:23:45,009
to all associations under the same

00:23:42,399 --> 00:23:47,440
socket so you don't have to repeat this

00:23:45,009 --> 00:23:50,589
call to send the same message to our

00:23:47,440 --> 00:23:53,109
associations message more you know

00:23:50,589 --> 00:23:55,179
already it's when you're telling the

00:23:53,109 --> 00:24:01,619
stack hey have more data at 10 don't

00:23:55,179 --> 00:24:04,779
don't flush it yet and additional

00:24:01,619 --> 00:24:08,229
control messages that we have like

00:24:04,779 --> 00:24:11,829
instead of setting on the socket the

00:24:08,229 --> 00:24:13,929
partial reliability information you can

00:24:11,829 --> 00:24:16,589
set that per message when you are

00:24:13,929 --> 00:24:19,539
sending it same applies to

00:24:16,589 --> 00:24:26,549
authentication and to the destination

00:24:19,539 --> 00:24:30,129
message comparison between Linux and BSD

00:24:26,549 --> 00:24:37,479
the beastie stack is maintained by HTTP

00:24:30,129 --> 00:24:39,969
RFC alters so it's quite late hours yeah

00:24:37,479 --> 00:24:43,959
we are catching up you know

00:24:39,969 --> 00:24:47,799
chunk formats we support pretty much

00:24:43,959 --> 00:24:52,299
everything that is interesting we don't

00:24:47,799 --> 00:24:55,029
have the laundry negeb all selective's

00:24:52,299 --> 00:24:57,369
arc which is part of the CMT

00:24:55,029 --> 00:25:02,379
implementation we don't have packet

00:24:57,369 --> 00:25:06,030
dropped in bad chunk and on the right

00:25:02,379 --> 00:25:09,090
side we have it's not really

00:25:06,030 --> 00:25:12,240
bad and good features is just to mention

00:25:09,090 --> 00:25:15,150
that one stack works this way and other

00:25:12,240 --> 00:25:19,830
works on that way we do have that state

00:25:15,150 --> 00:25:22,500
machine they don't they have what we

00:25:19,830 --> 00:25:25,230
want to have is like what we have for

00:25:22,500 --> 00:25:28,350
TCP today for construction control you

00:25:25,230 --> 00:25:30,660
have one defining API that you can

00:25:28,350 --> 00:25:32,700
implement several control algorithms and

00:25:30,660 --> 00:25:34,680
user can choose which one is best in

00:25:32,700 --> 00:25:37,530
that case as it's beyond our

00:25:34,680 --> 00:25:40,550
implementation today it's only one and

00:25:37,530 --> 00:25:40,550
that's all you have

00:25:41,090 --> 00:25:45,300
so what's next we won't read support for

00:25:44,640 --> 00:25:48,240
those jacks

00:25:45,300 --> 00:25:51,840
it guys sort options in notifications as

00:25:48,240 --> 00:25:55,890
they come by as they are the final new

00:25:51,840 --> 00:26:01,590
drafts in the FCS we are experimenting

00:25:55,890 --> 00:26:04,590
with NAT setp net and as in CMT net for

00:26:01,590 --> 00:26:09,780
a CTP is very complicated because you

00:26:04,590 --> 00:26:12,630
have AP addresses inside header and you

00:26:09,780 --> 00:26:16,050
have the V tag which is also which also

00:26:12,630 --> 00:26:18,750
needs translating you need cooperation

00:26:16,050 --> 00:26:25,920
from the Pharos in the middle of the

00:26:18,750 --> 00:26:28,200
network to make that happen we are doing

00:26:25,920 --> 00:26:30,450
performance improvements including send

00:26:28,200 --> 00:26:33,420
buffer auto tuning with this is in the

00:26:30,450 --> 00:26:39,360
oven it should be going out like in two

00:26:33,420 --> 00:26:41,880
or three weeks we want to add more and

00:26:39,360 --> 00:26:42,870
more test cases a TB test because we

00:26:41,880 --> 00:26:47,190
really need it

00:26:42,870 --> 00:26:50,820
we have 24 27 tests yet and we we need

00:26:47,190 --> 00:26:55,610
more I go what's wrong with this week we

00:26:50,820 --> 00:26:58,470
don't have a test for partial delivery

00:26:55,610 --> 00:27:03,270
partial deliveries when the application

00:26:58,470 --> 00:27:06,180
asks this tag to send a message to it

00:27:03,270 --> 00:27:08,310
even though it didn't receive the

00:27:06,180 --> 00:27:13,530
message entirely yet the message was

00:27:08,310 --> 00:27:15,720
fragmented and it has four fragments so

00:27:13,530 --> 00:27:18,600
it it's then complete and this

00:27:15,720 --> 00:27:19,620
application can ask know if it's more

00:27:18,600 --> 00:27:21,900
than one fragment

00:27:19,620 --> 00:27:25,049
please send me already and I'll do

00:27:21,900 --> 00:27:28,770
something with it this feature for

00:27:25,049 --> 00:27:32,789
example that though that sweet doesn't

00:27:28,770 --> 00:27:34,830
have any tests on it we need to do

00:27:32,789 --> 00:27:36,779
something called refactor because we

00:27:34,830 --> 00:27:38,610
have some huge in massive functions we

00:27:36,779 --> 00:27:42,270
had functions that they were pretty

00:27:38,610 --> 00:27:43,770
pretty long and it was hard to keep

00:27:42,270 --> 00:27:46,770
track of everything that was happening

00:27:43,770 --> 00:27:52,100
in there we need to rework the

00:27:46,770 --> 00:27:56,909
congestion control to make this API and

00:27:52,100 --> 00:28:00,299
maybe maybe maybe integrate some part of

00:27:56,909 --> 00:28:04,350
it with the TCP stack because they they

00:28:00,299 --> 00:28:12,539
were quite similarly and refactor lks

00:28:04,350 --> 00:28:16,649
ETP tools to be more to be more specific

00:28:12,539 --> 00:28:18,360
like we have test applications on it and

00:28:16,649 --> 00:28:21,870
we have the library that applications

00:28:18,360 --> 00:28:25,890
should rely on and at least those should

00:28:21,870 --> 00:28:27,929
actually be in different projects harder

00:28:25,890 --> 00:28:31,380
support is the first one is a big

00:28:27,929 --> 00:28:34,559
discussion gso for CDP was implemented

00:28:31,380 --> 00:28:39,000
using frag lists and that's pretty hard

00:28:34,559 --> 00:28:43,350
to offload to actual cards but that's

00:28:39,000 --> 00:28:47,010
how we found that we can overcome

00:28:43,350 --> 00:28:50,460
limitations that we would have we using

00:28:47,010 --> 00:28:54,240
frags using Franks we we are very

00:28:50,460 --> 00:28:58,950
limited to how much we can store on it

00:28:54,240 --> 00:29:01,940
while maintaining packet boundaries we

00:28:58,950 --> 00:29:06,120
couldn't get another way out of it yet

00:29:01,940 --> 00:29:10,020
checks an offloading it's unfortunate to

00:29:06,120 --> 00:29:12,980
see that Tony I think only for for yeah

00:29:10,020 --> 00:29:15,630
for cards support crc32 offloading and

00:29:12,980 --> 00:29:21,740
without that we can do any other

00:29:15,630 --> 00:29:27,679
floating so that was it

00:29:21,740 --> 00:29:30,500
thanks for juicing I'm curious if you've

00:29:27,679 --> 00:29:32,360
thought about integrating the tests into

00:29:30,500 --> 00:29:37,909
the self tests area of the kernel at

00:29:32,360 --> 00:29:42,230
some point no we didn't think okay cuz I

00:29:37,909 --> 00:29:44,000
mean if you see that the trend is that

00:29:42,230 --> 00:29:46,460
we can set up any network hierarchy with

00:29:44,000 --> 00:29:47,600
namespaces or whatever and we saw we

00:29:46,460 --> 00:29:49,669
could replicate whatever you're trying

00:29:47,600 --> 00:29:53,659
to do with setting up multihoming

00:29:49,669 --> 00:29:56,029
situations and whatever and for someone

00:29:53,659 --> 00:29:59,779
who wants to make a tree where I change

00:29:56,029 --> 00:30:01,610
like I am recently it's kind of it's

00:29:59,779 --> 00:30:03,649
difficult to touch the setp code and

00:30:01,610 --> 00:30:06,649
know that you've not broken anything yes

00:30:03,649 --> 00:30:08,270
so I think if at some point you do the

00:30:06,649 --> 00:30:09,770
work to move the tests into the self

00:30:08,270 --> 00:30:11,570
tests two things will happen

00:30:09,770 --> 00:30:14,299
people will be more confident to

00:30:11,570 --> 00:30:16,250
contribute to a CTP and secondarily all

00:30:14,299 --> 00:30:19,010
the robots will be automatically testing

00:30:16,250 --> 00:30:19,669
setp every single day that is something

00:30:19,010 --> 00:30:24,070
to consider

00:30:19,669 --> 00:30:24,070
I think okay yeah any questions

00:30:28,280 --> 00:30:30,900
this was interesting it's kind of a

00:30:30,270 --> 00:30:33,570
DejaVu

00:30:30,900 --> 00:30:35,820
I remember at in Ottawa 10 or 15 years

00:30:33,570 --> 00:30:38,430
ago an sctp presentation and sitting in

00:30:35,820 --> 00:30:44,310
the hallway prototyping as an app in

00:30:38,430 --> 00:30:45,840
this case a mount to Samba using SCTP so

00:30:44,310 --> 00:30:47,460
one of the things those curious is okay

00:30:45,840 --> 00:30:51,540
you got Network people here but what if

00:30:47,460 --> 00:30:53,400
you're an app you want to do FTP so what

00:30:51,540 --> 00:30:54,930
would it look like we know it goes over

00:30:53,400 --> 00:30:56,700
socket or maybe an easier example might

00:30:54,930 --> 00:30:59,910
be like SME client or some user space

00:30:56,700 --> 00:31:01,440
tool to Samba what does it look like

00:30:59,910 --> 00:31:03,720
different than a socket you call a

00:31:01,440 --> 00:31:05,370
socket today you open it okay what do

00:31:03,720 --> 00:31:07,650
you have to pass in that's different the

00:31:05,370 --> 00:31:10,290
address looks different so like where

00:31:07,650 --> 00:31:12,420
would i look let's say you wanted to

00:31:10,290 --> 00:31:15,240
enable some simple tool like Sambas ftp

00:31:12,420 --> 00:31:17,730
like tool-less and be client mm-hmm what

00:31:15,240 --> 00:31:20,520
would be different in the address that

00:31:17,730 --> 00:31:22,080
you specify what would be different you

00:31:20,520 --> 00:31:24,240
know you got an i/o vac you're gonna

00:31:22,080 --> 00:31:27,660
pass to a socket right what is what

00:31:24,240 --> 00:31:29,550
looks different or can you just use the

00:31:27,660 --> 00:31:30,840
socket API and just specify a little for

00:31:29,550 --> 00:31:33,170
the first pass obviously these other

00:31:30,840 --> 00:31:36,540
features are cool but to prove a concept

00:31:33,170 --> 00:31:40,320
what looks different on creating a

00:31:36,540 --> 00:31:42,960
socket and doing your vector right that

00:31:40,320 --> 00:31:45,000
would depend on how much of CTP you want

00:31:42,960 --> 00:31:47,190
to use on that

00:31:45,000 --> 00:31:50,730
llk SMTP tools package we have a library

00:31:47,190 --> 00:31:57,420
that you can LD preload with on your

00:31:50,730 --> 00:31:59,040
application but I think what he's trying

00:31:57,420 --> 00:32:01,590
to tell you is that they have a facility

00:31:59,040 --> 00:32:02,940
to get the TCP like situation right is

00:32:01,590 --> 00:32:07,410
that where you're going with this yes

00:32:02,940 --> 00:32:09,780
yes then with this library you can test

00:32:07,410 --> 00:32:11,460
the application with a CTP without

00:32:09,780 --> 00:32:13,830
having any single change on the

00:32:11,460 --> 00:32:18,780
application for applications that are

00:32:13,830 --> 00:32:21,210
tcp style so that would mean the socket

00:32:18,780 --> 00:32:23,850
call to create a socket is the literally

00:32:21,210 --> 00:32:26,310
the same the connect call is the same

00:32:23,850 --> 00:32:28,740
they receive the send functions are the

00:32:26,310 --> 00:32:31,770
same that you down is the same can be

00:32:28,740 --> 00:32:33,690
mapped into one another but if you want

00:32:31,770 --> 00:32:35,700
to use more advanced functions from my

00:32:33,690 --> 00:32:38,880
CDP like getting notifications that

00:32:35,700 --> 00:32:40,340
transport communication path between two

00:32:38,880 --> 00:32:43,640
addresses went down

00:32:40,340 --> 00:32:51,799
then you cannot use that you need to who

00:32:43,640 --> 00:32:53,630
more deeply in the stack you know there

00:32:51,799 --> 00:32:55,490
are some guys here I have one of these

00:32:53,630 --> 00:32:57,919
here there's some guys that work on our

00:32:55,490 --> 00:32:59,120
DMA so when they play with our DMA what

00:32:57,919 --> 00:33:00,980
they did was they said well well add an

00:32:59,120 --> 00:33:03,169
amount option for our DMA so if you want

00:33:00,980 --> 00:33:04,880
it instead of a socket to mount over us

00:33:03,169 --> 00:33:07,789
and be with our DMA you just say are do

00:33:04,880 --> 00:33:09,020
you made so that's the simple sort of

00:33:07,789 --> 00:33:14,870
first step were think about we mount

00:33:09,020 --> 00:33:17,149
SCTP so it sounds like the first phase

00:33:14,870 --> 00:33:19,190
all you'd have to do is you know take

00:33:17,149 --> 00:33:21,529
NFS or SMB or some userspace tools take

00:33:19,190 --> 00:33:23,510
some kernel driver and just you've got a

00:33:21,529 --> 00:33:25,010
socket underneath you so the only thing

00:33:23,510 --> 00:33:27,470
you're passing is one new mount parm

00:33:25,010 --> 00:33:30,799
to force it to use SCTP for that address

00:33:27,470 --> 00:33:32,659
instead of TCP for that address is it

00:33:30,799 --> 00:33:34,309
really that simple we just open a socket

00:33:32,659 --> 00:33:39,799
with a slightly different thing we're

00:33:34,309 --> 00:33:42,770
done for the first phase yes yes okay we

00:33:39,799 --> 00:33:44,659
have one CTP user in the kernel today

00:33:42,770 --> 00:33:49,240
which is the D element with a lock

00:33:44,659 --> 00:33:49,240
manger and they share most of the code

00:33:52,720 --> 00:34:00,549
Thank You Marcel

00:33:55,750 --> 00:34:00,549

YouTube URL: https://www.youtube.com/watch?v=TRXuM2EapL4


