Title: LPC2018 - P4C-XDP: Programming the Linux Kernel Forwarding Plane Using P4
Publication date: 2018-12-04
Playlist: LPC2018 - Networking Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/97/
speaker:   Fabian Ruffy (University of British Columbia),  Mihai Budiu (VMware),  William Tu (VMware)


The eXpress Data Path (XDP) is a new kernel-feature, intended to provide 
fast packet processing as close as possible to device hardware. XDP 
builds on top of the extended Berkely Packet Filter (eBPF) and allows 
users to write a C-like packet processing program, which can be attached 
to the device driver’s receiving queue. When the device observes an 
incoming packet, the user-defined XDP program is triggered to execute on 
the packet payload, making the decision as early as possible before 
handing the packet down the processing pipeline.

P4 is a domain-specific language describing how packets are processed by 
the data plane of a programmable network elements, including network 
interface cards, appliances, and virtual switches. It provides an 
abstraction that allows programmers to express existing and future 
protocol format without coupling it to any data plane specific 
knowledge. The language is explicitly designed to be protocol-agnostic. 
A P4 programmer can write their own protocols and load the P4 program 
into P4-capable network elements.
As high-level networking language, P4 supports a diverse set of compiler 
backends and also possesses the capability to express eBPF and XDP programs.

We present P4C-XDP, a new backend for the P4 compiler. P4C-XDP leverages 
XDP to aim for a high performance software data plane. The backend 
generates a eBPF-compliant C representation from a given P4 program 
which is passed to clang and llvm to produce the bytecode. Using 
conventional eBPF kernel hooks the program can then be loaded into the 
eBPF virtual machine in the device driver. The kernel verifier 
guarantees the safety of the generated code. Any packets 
received/transmitted from/to this device driver now trigger the 
execution of the loaded P4 program.

The P4C-XDP project is an open source project hosted at 
https://github.com/vmware/p4c-xdp/. We provide prove-of-concept sample 
code under the tests directory, which contains a couple of examples such 
as basic protocol parsing, checksum recalculation, multiple tables 
lookups, and tunnel protocol en-/decapsulation.
Captions: 
	00:00:05,940 --> 00:00:12,730
yeah so we're back to xep from DC TCP

00:00:09,280 --> 00:00:14,980
and multihoming and more specifically

00:00:12,730 --> 00:00:17,050
this is going to be about how we could

00:00:14,980 --> 00:00:18,810
technically compile p4 down to xep and

00:00:17,050 --> 00:00:22,930
how to do it from a user's perspective

00:00:18,810 --> 00:00:27,940
so this is more high-level user using

00:00:22,930 --> 00:00:30,040
xcp in some way on the other so the

00:00:27,940 --> 00:00:32,169
story's gonna be split in half first I'm

00:00:30,040 --> 00:00:36,610
gonna talk about for the next half about

00:00:32,169 --> 00:00:39,070
what p4 is what we have done like what

00:00:36,610 --> 00:00:41,999
we have built and how we actually test

00:00:39,070 --> 00:00:44,109
that the progress we generate work

00:00:41,999 --> 00:00:46,449
brilliant then we'll walk you through an

00:00:44,109 --> 00:00:49,899
example help you actually generate xep

00:00:46,449 --> 00:00:51,670
code from v4 and what the performance

00:00:49,899 --> 00:00:54,039
results are currently and what we

00:00:51,670 --> 00:00:56,409
currently have we also encountered a

00:00:54,039 --> 00:01:00,850
bunch of limitations fundamental ones

00:00:56,409 --> 00:01:02,260
and some technical limitations we're

00:01:00,850 --> 00:01:06,130
also going to get to discuss those at

00:01:02,260 --> 00:01:09,040
the end so in general what is p4

00:01:06,130 --> 00:01:11,530
actually before is basically a

00:01:09,040 --> 00:01:14,290
high-level programming language for

00:01:11,530 --> 00:01:16,120
network data planes which means that in

00:01:14,290 --> 00:01:19,120
p4 you can describe packet processing

00:01:16,120 --> 00:01:24,820
and parsing behavior independent of the

00:01:19,120 --> 00:01:26,920
protocols or any other well limit like

00:01:24,820 --> 00:01:28,750
stack limitation it's meant to be

00:01:26,920 --> 00:01:30,430
extremely flexible and allows you to

00:01:28,750 --> 00:01:32,940
define any kind of protocol you want and

00:01:30,430 --> 00:01:35,320
also you're supposed to be able to

00:01:32,940 --> 00:01:38,290
specify any type of parsing procedure

00:01:35,320 --> 00:01:40,450
you want to the way it used before is

00:01:38,290 --> 00:01:42,490
you compile a p4 program and it is

00:01:40,450 --> 00:01:44,860
loaded into a target platform target

00:01:42,490 --> 00:01:48,670
platform means it could be a switch an

00:01:44,860 --> 00:01:51,550
PU or any kind of networking device we

00:01:48,670 --> 00:01:54,240
had its open and standardized so it's

00:01:51,550 --> 00:01:56,770
try to be as open source as possible and

00:01:54,240 --> 00:02:00,070
anyone can use it for whatever purpose

00:01:56,770 --> 00:02:02,980
they want to the essentials of before

00:02:00,070 --> 00:02:06,250
basically people it's a Selig language

00:02:02,980 --> 00:02:09,159
it's strongly typed it's obviously a lot

00:02:06,250 --> 00:02:11,110
higher level than C but it's also type

00:02:09,159 --> 00:02:13,720
in memory safe so there's no pointers at

00:02:11,110 --> 00:02:15,580
all and we also want to bound execution

00:02:13,720 --> 00:02:18,760
because you don't want to have loops in

00:02:15,580 --> 00:02:20,770
your data processing bit

00:02:18,760 --> 00:02:22,959
it's statically allocated so there's no

00:02:20,770 --> 00:02:24,700
dynamic allocation at all

00:02:22,959 --> 00:02:26,980
we don't use any marking or any

00:02:24,700 --> 00:02:29,770
recursion in the same way we want to be

00:02:26,980 --> 00:02:32,410
safe in our programs there's a spec for

00:02:29,770 --> 00:02:35,500
p4 it's open source under P for line

00:02:32,410 --> 00:02:37,930
repo and we also have a reference

00:02:35,500 --> 00:02:39,670
compiler which is extensible and also

00:02:37,930 --> 00:02:42,760
open source under the Apache License and

00:02:39,670 --> 00:02:46,530
anyone can use it and I compile their

00:02:42,760 --> 00:02:50,080
own back-end so how do you actually use

00:02:46,530 --> 00:02:51,549
before if you want to use it the

00:02:50,080 --> 00:02:53,110
assumption is that you have some kind of

00:02:51,549 --> 00:02:59,830
architecture model which is basically a

00:02:53,110 --> 00:03:02,170
library of p4 functions it defines

00:02:59,830 --> 00:03:04,390
basically whatever you want to use in

00:03:02,170 --> 00:03:06,870
your program and you have a compiler

00:03:04,390 --> 00:03:09,069
that generates a binary for you so

00:03:06,870 --> 00:03:11,980
essentially a user would write their p4

00:03:09,069 --> 00:03:13,840
program which specifies the way you want

00:03:11,980 --> 00:03:18,400
to parse packets for example Ethernet

00:03:13,840 --> 00:03:20,200
header is by P headers MPLS and this

00:03:18,400 --> 00:03:23,739
program is then loaded into the compiler

00:03:20,200 --> 00:03:25,720
which generates a binary for you this

00:03:23,739 --> 00:03:27,790
binary then can be actually compiled

00:03:25,720 --> 00:03:30,130
into the target and generates the data

00:03:27,790 --> 00:03:32,470
plane for you the data in meaning it has

00:03:30,130 --> 00:03:35,200
all the tables it has all the objects

00:03:32,470 --> 00:03:38,230
you want to use and it forms your switch

00:03:35,200 --> 00:03:41,109
data plane and once that is actually

00:03:38,230 --> 00:03:42,910
done a user can also supply their own

00:03:41,109 --> 00:03:46,450
control plane which is it's completely

00:03:42,910 --> 00:03:48,040
flexible and open source so everyone can

00:03:46,450 --> 00:03:52,269
define their own control plane it's not

00:03:48,040 --> 00:03:54,940
proprietary or limited by vendors

00:03:52,269 --> 00:03:56,170
once that is done you have basically

00:03:54,940 --> 00:03:57,850
interaction between the data and control

00:03:56,170 --> 00:03:58,239
plane which is to find all the fine by

00:03:57,850 --> 00:04:02,170
the user

00:03:58,239 --> 00:04:06,850
and completely flexible to whatever

00:04:02,170 --> 00:04:08,859
process you want to use P for used to be

00:04:06,850 --> 00:04:11,680
just the switches and just meant to be

00:04:08,859 --> 00:04:15,790
for switches but recently a new standard

00:04:11,680 --> 00:04:17,620
was defined P for 16 which made thee for

00:04:15,790 --> 00:04:19,600
a lot more flexible and now we can

00:04:17,620 --> 00:04:22,389
actually generalize to all kinds of data

00:04:19,600 --> 00:04:26,260
planes or targets what that means is

00:04:22,389 --> 00:04:29,440
next to a switch we can also write p4

00:04:26,260 --> 00:04:32,020
code for network interface cards natural

00:04:29,440 --> 00:04:34,900
processing units or even software or

00:04:32,020 --> 00:04:38,470
systems and that's where we also come to

00:04:34,900 --> 00:04:42,280
xep itself so how do people and XDP work

00:04:38,470 --> 00:04:44,819
together well I'm pretty sure you're all

00:04:42,280 --> 00:04:48,789
familiar with a view here of XP by now

00:04:44,819 --> 00:04:52,870
the UPF is a virtual machine running in

00:04:48,789 --> 00:04:55,419
the kernel what it provides is a way for

00:04:52,870 --> 00:04:59,319
you to write C code restricted C code

00:04:55,419 --> 00:05:02,740
and run it in the kernel so that's

00:04:59,319 --> 00:05:05,050
actually quite nice and you can use it

00:05:02,740 --> 00:05:07,090
in a different set of points all of

00:05:05,050 --> 00:05:10,780
which define will give you different

00:05:07,090 --> 00:05:12,909
kinds of features so exci pvp FTC so

00:05:10,780 --> 00:05:13,990
wherever you want to insert it in the

00:05:12,909 --> 00:05:16,539
stack you have different kinds of

00:05:13,990 --> 00:05:20,650
methods you can use well it's extensible

00:05:16,539 --> 00:05:23,039
safe and fast and it's also an

00:05:20,650 --> 00:05:25,900
alternative to user space networking so

00:05:23,039 --> 00:05:28,469
yeah you're actually using the kernel

00:05:25,900 --> 00:05:30,759
not just DVD Kay and user space stacks

00:05:28,469 --> 00:05:32,199
but the most interesting part about it

00:05:30,759 --> 00:05:33,909
is actually it's a programmable date to

00:05:32,199 --> 00:05:35,440
play in the kernel by now because you

00:05:33,909 --> 00:05:37,750
can program your own programs and you

00:05:35,440 --> 00:05:40,000
can load it into your data path so it

00:05:37,750 --> 00:05:42,819
gives you a fast programmable data path

00:05:40,000 --> 00:05:47,139
you can use and it is exactly what p4 is

00:05:42,819 --> 00:05:50,860
also meant for so comparing the both the

00:05:47,139 --> 00:05:53,669
both languages these are the features

00:05:50,860 --> 00:05:56,919
both exhibit

00:05:53,669 --> 00:05:58,990
whereas if EPF and xep is low in terms

00:05:56,919 --> 00:06:02,469
of using the c language and being very

00:05:58,990 --> 00:06:04,810
specific p4 is meant as a specification

00:06:02,469 --> 00:06:06,909
language for a networked language for

00:06:04,810 --> 00:06:09,190
network parsing or processing so it's a

00:06:06,909 --> 00:06:13,569
more high-level approach and both are

00:06:09,190 --> 00:06:17,080
safe before by using a type system and

00:06:13,569 --> 00:06:20,740
if you have by using a verifier loops

00:06:17,080 --> 00:06:22,900
are not really possible unless you use

00:06:20,740 --> 00:06:26,620
roundabout ways for example using take

00:06:22,900 --> 00:06:28,389
holes or in p4 you could just use

00:06:26,620 --> 00:06:31,090
partial loops page just loop across

00:06:28,389 --> 00:06:33,099
headers in post packets in both

00:06:31,090 --> 00:06:38,099
languages you do use static allocation

00:06:33,099 --> 00:06:41,110
and you defined your policies in p4 or

00:06:38,099 --> 00:06:43,029
vpf you use your maps to define your

00:06:41,110 --> 00:06:45,600
policies or forwarding policies and in

00:06:43,029 --> 00:06:48,330
p4 you would also use tables so

00:06:45,600 --> 00:06:49,710
match action procedure we specify okay I

00:06:48,330 --> 00:06:54,030
have an incoming packet what is the

00:06:49,710 --> 00:06:57,900
action I operate on it well helpers

00:06:54,030 --> 00:06:59,520
functions in both languages they're

00:06:57,900 --> 00:07:02,160
pretty much depending on the target or

00:06:59,520 --> 00:07:05,940
the hook you use and they control a

00:07:02,160 --> 00:07:08,700
playing API in EB PF is pretty much the

00:07:05,940 --> 00:07:13,980
map series and mp4 it's generated but

00:07:08,700 --> 00:07:17,820
whatever target you use so based on this

00:07:13,980 --> 00:07:21,630
idea we have built two backends for EBP

00:07:17,820 --> 00:07:24,960
F on the open source compiler one it

00:07:21,630 --> 00:07:27,900
actually generates EBP F code and loads

00:07:24,960 --> 00:07:28,470
it for you using TC and another one that

00:07:27,900 --> 00:07:32,340
generates

00:07:28,470 --> 00:07:35,760
xtp for you both of them are extensions

00:07:32,340 --> 00:07:36,980
of the p4 compiler and they use much of

00:07:35,760 --> 00:07:39,330
the code

00:07:36,980 --> 00:07:40,830
it's obviously not production that yet

00:07:39,330 --> 00:07:43,650
there's lots of work left to do

00:07:40,830 --> 00:07:45,600
it's not fast and we have to make sure

00:07:43,650 --> 00:07:49,590
everything is correct but it's getting

00:07:45,600 --> 00:07:50,610
there and it's evolving quite nicely so

00:07:49,590 --> 00:07:54,780
how do we actually going to generate

00:07:50,610 --> 00:07:58,440
this XDP code so we have a specific

00:07:54,780 --> 00:08:00,840
pipeline and where we first insert a p4

00:07:58,440 --> 00:08:04,680
program and generate our X EPC code

00:08:00,840 --> 00:08:09,870
which is stylized C in the sense of it's

00:08:04,680 --> 00:08:12,150
a very specific pre-formatted CD and we

00:08:09,870 --> 00:08:13,650
don't use take holes at all right now it

00:08:12,150 --> 00:08:14,190
has a bunch of complexity involving

00:08:13,650 --> 00:08:16,140
tailcoats

00:08:14,190 --> 00:08:19,680
you're trying to get there but it takes

00:08:16,140 --> 00:08:21,840
a bit of time to flesh this out all data

00:08:19,680 --> 00:08:27,210
is currently on the stack so we generate

00:08:21,840 --> 00:08:28,860
a lot of variables so our control and

00:08:27,210 --> 00:08:30,570
data plane is solidly defined by these

00:08:28,860 --> 00:08:32,280
EDF tables which is quite nice

00:08:30,570 --> 00:08:35,599
all the communication happens over this

00:08:32,280 --> 00:08:36,780
interface and it's quite clean and

00:08:35,599 --> 00:08:39,590
well-defined

00:08:36,780 --> 00:08:42,390
right now we can do basic filtering

00:08:39,590 --> 00:08:46,350
basic forwarding and some encapsulation

00:08:42,390 --> 00:08:48,450
and we mostly use traffic controller TC

00:08:46,350 --> 00:08:51,410
for loading or forwarding packets right

00:08:48,450 --> 00:08:54,210
now we would like to use the PDF but

00:08:51,410 --> 00:08:56,810
it'd be just in the process of migrating

00:08:54,210 --> 00:08:56,810
there

00:08:56,980 --> 00:09:02,950
so the switching model in general is a

00:08:59,950 --> 00:09:04,630
parsing stage where you parse the packet

00:09:02,950 --> 00:09:07,930
you receive and you parse each other

00:09:04,630 --> 00:09:09,610
individually and store the values on

00:09:07,930 --> 00:09:11,310
after this passing stage to actually

00:09:09,610 --> 00:09:13,870
perform the action on the powers packet

00:09:11,310 --> 00:09:19,330
which is defined by your control plane

00:09:13,870 --> 00:09:22,930
which Bay which controls all the tables

00:09:19,330 --> 00:09:25,210
in your match action database once that

00:09:22,930 --> 00:09:26,950
is done you have to depart the packet

00:09:25,210 --> 00:09:29,380
which means is you put the headers spec

00:09:26,950 --> 00:09:33,820
based back on the stack and emit the

00:09:29,380 --> 00:09:36,580
packet the general flow is you have a p4

00:09:33,820 --> 00:09:38,860
program you load it into your xdp

00:09:36,580 --> 00:09:41,920
compiler it generates the C code for you

00:09:38,860 --> 00:09:45,970
and it also loads it into the kernel to

00:09:41,920 --> 00:09:49,360
the interface you specify in parallel it

00:09:45,970 --> 00:09:51,910
also generates an API for you so if you

00:09:49,360 --> 00:09:54,730
have tables and the calls you need to

00:09:51,910 --> 00:09:57,340
actually modify these tables and which

00:09:54,730 --> 00:10:00,430
you can compile with your C program or

00:09:57,340 --> 00:10:02,500
control panel C program so this allows

00:10:00,430 --> 00:10:06,390
you to modify the table and update the

00:10:02,500 --> 00:10:09,100
policies on your interface or data path

00:10:06,390 --> 00:10:11,260
but we wanna actually ensure that this

00:10:09,100 --> 00:10:13,060
code we generate is correct so if you

00:10:11,260 --> 00:10:15,750
also have a full end testing pipeline to

00:10:13,060 --> 00:10:17,520
verify that we do we don't do anything

00:10:15,750 --> 00:10:20,860
completely insane

00:10:17,520 --> 00:10:22,600
so we have to test frameworks one in

00:10:20,860 --> 00:10:23,620
userspace completely in userspace and

00:10:22,600 --> 00:10:26,080
one in the kernel space which is

00:10:23,620 --> 00:10:28,060
end-to-end testing we actually use user

00:10:26,080 --> 00:10:32,410
space to just isolate a specification of

00:10:28,060 --> 00:10:35,590
our program to make sure that the code

00:10:32,410 --> 00:10:38,680
we generate is functionally correct and

00:10:35,590 --> 00:10:41,560
us compile nicely it's mostly for us to

00:10:38,680 --> 00:10:44,310
verify that our code is correct and we

00:10:41,560 --> 00:10:47,680
want to isolate it from the kernel

00:10:44,310 --> 00:10:50,500
shenanigans not shenanigans but making

00:10:47,680 --> 00:10:52,890
sure that the kernel is not interfering

00:10:50,500 --> 00:10:56,080
with both what we want to do right now

00:10:52,890 --> 00:10:58,000
it's basically a copy of all the kernel

00:10:56,080 --> 00:11:00,700
code it's a user space wrapper and

00:10:58,000 --> 00:11:02,190
provides us with all the you have tables

00:11:00,700 --> 00:11:05,020
and API so you want to use and it's all

00:11:02,190 --> 00:11:08,520
quite simple the nice thing about this

00:11:05,020 --> 00:11:10,380
you can actually use simple tools like

00:11:08,520 --> 00:11:12,180
gdb to just

00:11:10,380 --> 00:11:13,800
step-by-step walkthrough your program

00:11:12,180 --> 00:11:17,610
and identify what's going wrong and what

00:11:13,800 --> 00:11:20,520
what is not working right we also do

00:11:17,610 --> 00:11:22,520
end-to-end testing in which we load the

00:11:20,520 --> 00:11:24,810
EVF program in turn kernel and test

00:11:22,520 --> 00:11:27,150
tested on custom packets we insert it

00:11:24,810 --> 00:11:30,960
what we do here is we create a virtual

00:11:27,150 --> 00:11:34,320
environment and attach interfaces to it

00:11:30,960 --> 00:11:37,050
and load load EBP effluence to all the

00:11:34,320 --> 00:11:38,250
interfaces we have and test if you can

00:11:37,050 --> 00:11:42,530
actually send packet through it and if

00:11:38,250 --> 00:11:46,320
they ports which are virtual interfaces

00:11:42,530 --> 00:11:48,420
forward the packets correctly we capture

00:11:46,320 --> 00:11:51,840
all of them our packets using TCP dump

00:11:48,420 --> 00:11:55,800
and then verify if there are products is

00:11:51,840 --> 00:11:58,320
what we expected so in general we have

00:11:55,800 --> 00:12:00,900
five testing stages we first provide a

00:11:58,320 --> 00:12:04,770
p4 program and then so-called STF file

00:12:00,900 --> 00:12:07,320
SDF files are more you can find out more

00:12:04,770 --> 00:12:08,760
in the papers they are mostly just test

00:12:07,320 --> 00:12:12,150
specification files which you know which

00:12:08,760 --> 00:12:13,830
say okay I want to insert these packets

00:12:12,150 --> 00:12:17,430
and I expect them on this output port

00:12:13,830 --> 00:12:20,190
and or on their gonna be jobs eventually

00:12:17,430 --> 00:12:23,940
so it's mostly a test specification in

00:12:20,190 --> 00:12:26,850
language so what we do is we compile our

00:12:23,940 --> 00:12:28,620
p4 for them we parse our SDF file from

00:12:26,850 --> 00:12:31,590
the SDF file we generate a bunch of

00:12:28,620 --> 00:12:35,640
import packets on each interface we

00:12:31,590 --> 00:12:38,070
wanna use and also a list of output

00:12:35,640 --> 00:12:40,260
packets we expect on our interfaces from

00:12:38,070 --> 00:12:42,680
the p4 preserve we compiled our runtime

00:12:40,260 --> 00:12:46,110
source code which is the C program and a

00:12:42,680 --> 00:12:48,650
general runtime library we use and then

00:12:46,110 --> 00:12:52,730
compile it into our actual data plane

00:12:48,650 --> 00:12:55,680
which basically gives us the executable

00:12:52,730 --> 00:12:57,600
we run this executable feed the packets

00:12:55,680 --> 00:12:58,860
into it in the kernel space this would

00:12:57,600 --> 00:13:04,320
be a virtual environment where you just

00:12:58,860 --> 00:13:06,150
use scar P or anything like that to just

00:13:04,320 --> 00:13:08,250
write the packets to the interfaces in

00:13:06,150 --> 00:13:09,290
user space this is just a simple program

00:13:08,250 --> 00:13:12,900
which feeds

00:13:09,290 --> 00:13:14,210
packets into its executable we run it

00:13:12,900 --> 00:13:16,470
and we get a bunch of output packets

00:13:14,210 --> 00:13:19,650
with that we actually check the results

00:13:16,470 --> 00:13:23,160
and see if our expectations match but we

00:13:19,650 --> 00:13:24,270
have gotten our results if that is the

00:13:23,160 --> 00:13:29,910
case we pass the program

00:13:24,270 --> 00:13:32,100
not behave and if that I gives a William

00:13:29,910 --> 00:13:41,790
who's gonna talk and guide you through a

00:13:32,100 --> 00:13:46,290
sample ap4 xtp program we generated

00:13:41,790 --> 00:13:48,930
before program so this is a very simple

00:13:46,290 --> 00:13:52,050
example so we want to write a people

00:13:48,930 --> 00:13:54,600
program that do basically parsing only

00:13:52,050 --> 00:13:57,930
the ethernet header and ipv4 header and

00:13:54,600 --> 00:14:00,330
then we look up a table using Ethernet

00:13:57,930 --> 00:14:03,780
destination MAC address

00:14:00,330 --> 00:14:06,390
and based on the table content in stop

00:14:03,780 --> 00:14:08,700
by the control plane application we can

00:14:06,390 --> 00:14:12,090
either drop the packet by returning the

00:14:08,700 --> 00:14:15,300
xtv drop or pass to the state by

00:14:12,090 --> 00:14:17,880
returning XTP Pass and remember we have

00:14:15,300 --> 00:14:21,000
three stage three pipeline three stage

00:14:17,880 --> 00:14:26,370
here parser match and cash match and

00:14:21,000 --> 00:14:28,860
action and then departure so users right

00:14:26,370 --> 00:14:31,680
people program by first specifying the

00:14:28,860 --> 00:14:34,140
protocol you are interesting so in our

00:14:31,680 --> 00:14:37,620
case it's only user name ipv4 headers

00:14:34,140 --> 00:14:39,780
and then the compiler the people's ext

00:14:37,620 --> 00:14:45,450
compiler will generate a C structure

00:14:39,780 --> 00:14:47,940
like this one and so the next stage for

00:14:45,450 --> 00:14:51,540
the parser is to write a state machine

00:14:47,940 --> 00:14:54,120
so from the state start we extract the

00:14:51,540 --> 00:14:56,940
ethernet header and then based on the

00:14:54,120 --> 00:14:59,280
value of the protocol number in this

00:14:56,940 --> 00:15:04,440
case it's ipv4 then it goes to the next

00:14:59,280 --> 00:15:07,910
stage which is ipv4 so we again can

00:15:04,440 --> 00:15:12,930
convert this people code into see like

00:15:07,910 --> 00:15:16,290
program so we have a stroke headers HD

00:15:12,930 --> 00:15:19,350
which has both Ethernet header and ipv4

00:15:16,290 --> 00:15:23,970
header and then we generally call C code

00:15:19,350 --> 00:15:26,760
like later on comparing to PPF so after

00:15:23,970 --> 00:15:30,150
the parsing stage then its next stage is

00:15:26,760 --> 00:15:32,910
match an action so the match in action

00:15:30,150 --> 00:15:36,600
the people call first we write a control

00:15:32,910 --> 00:15:38,160
loop and in the in this function the

00:15:36,600 --> 00:15:40,710
first in now is a

00:15:38,160 --> 00:15:44,340
headers the headers from the previous

00:15:40,710 --> 00:15:48,720
stage we parse and then there's a input

00:15:44,340 --> 00:15:50,700
may have data XDP input in this case

00:15:48,720 --> 00:15:53,460
user can define their own improvement

00:15:50,700 --> 00:15:58,650
our data or in our case it's AF index

00:15:53,460 --> 00:16:01,920
and I'll put out these returns the

00:15:58,650 --> 00:16:04,260
action to the to the packet and then we

00:16:01,920 --> 00:16:06,810
start by defining two actions Y is drop

00:16:04,260 --> 00:16:10,530
returning X DV truck the other is for

00:16:06,810 --> 00:16:13,110
back returning X DB pass then we have to

00:16:10,530 --> 00:16:16,440
define a table so this table will have a

00:16:13,110 --> 00:16:19,410
key as the destination MAC address and

00:16:16,440 --> 00:16:22,620
then it's an exact match and the very

00:16:19,410 --> 00:16:25,740
will be either for very action or drop

00:16:22,620 --> 00:16:28,050
action and also we have to specify the

00:16:25,740 --> 00:16:31,440
implementation here when we say hash

00:16:28,050 --> 00:16:34,380
table then we'll use the PPF hash map

00:16:31,440 --> 00:16:39,090
well later on compiler will use the e

00:16:34,380 --> 00:16:42,390
BDF hash map so based on users

00:16:39,090 --> 00:16:46,710
definition in p4 will again generate the

00:16:42,390 --> 00:16:49,950
struct struct by destroying the header

00:16:46,710 --> 00:16:52,320
file so we put all these struct

00:16:49,950 --> 00:16:56,370
definition in a header file in this case

00:16:52,320 --> 00:16:59,550
it's called XD b1h so that control plan

00:16:56,370 --> 00:17:02,060
api is control plane program can improve

00:16:59,550 --> 00:17:05,699
can just include this one and then you

00:17:02,060 --> 00:17:12,480
can either use a lip PPF or something to

00:17:05,699 --> 00:17:15,650
populate map so the last stage is the

00:17:12,480 --> 00:17:18,300
departure stage so departure is when

00:17:15,650 --> 00:17:21,720
when you want to update a package

00:17:18,300 --> 00:17:24,990
content for example if you update ipv4

00:17:21,720 --> 00:17:28,920
TTL then you want to indiana dester you

00:17:24,990 --> 00:17:31,080
want to update the packet data so again

00:17:28,920 --> 00:17:33,360
our compiler generate a code to do this

00:17:31,080 --> 00:17:36,270
so first we have to use this helper

00:17:33,360 --> 00:17:38,970
function called x DB at just head so

00:17:36,270 --> 00:17:41,580
this is in some case people want to pack

00:17:38,970 --> 00:17:44,600
it encapsulation or decapsulation so

00:17:41,580 --> 00:17:48,930
that we need to move the packet data

00:17:44,600 --> 00:17:50,210
point and then we just call a load by

00:17:48,930 --> 00:17:53,980
alright

00:17:50,210 --> 00:17:59,270
Lord why install by to dry the data back

00:17:53,980 --> 00:18:01,430
so after users rises three-stage the

00:17:59,270 --> 00:18:05,090
people call actually we generate one

00:18:01,430 --> 00:18:07,450
single EP PA program so this one single

00:18:05,090 --> 00:18:11,720
PPA program will have three parts so

00:18:07,450 --> 00:18:14,060
partial mesh connection and departure so

00:18:11,720 --> 00:18:16,640
parser is very simple just to check the

00:18:14,060 --> 00:18:19,550
packet SS boundary and walk through the

00:18:16,640 --> 00:18:23,660
protocol graph and then put the value in

00:18:19,550 --> 00:18:28,040
put the headers in straw headers then

00:18:23,660 --> 00:18:30,610
we'll generate the map lookup magnin's

00:18:28,040 --> 00:18:34,790
using the EBP of helper function maybe

00:18:30,610 --> 00:18:39,500
America Elmen and then in the departure

00:18:34,790 --> 00:18:41,930
stage we'll write the value back so we

00:18:39,500 --> 00:18:46,700
did some performance benchmark our

00:18:41,930 --> 00:18:48,740
generated p4x TP program we set up two

00:18:46,700 --> 00:18:50,690
machines on the left-hand side it's

00:18:48,740 --> 00:18:54,170
packet generator SodaStream machine

00:18:50,690 --> 00:18:57,110
connecticut are using tank in the car on

00:18:54,170 --> 00:18:59,300
the left hand side we generate UDP

00:18:57,110 --> 00:19:01,490
packet sending 14 million packet per

00:18:59,300 --> 00:19:07,340
second on the right hand side was wrong

00:19:01,490 --> 00:19:12,650
this p4c XD p co and then we measure the

00:19:07,340 --> 00:19:15,410
packet rate 2 packet drop rate so first

00:19:12,650 --> 00:19:18,830
we did a baseline measurements or just a

00:19:15,410 --> 00:19:21,740
simple program returning x TP drop so we

00:19:18,830 --> 00:19:24,770
call it singapore drop it shows 40

00:19:21,740 --> 00:19:28,160
million packet 14 - 4 million packet per

00:19:24,770 --> 00:19:30,290
second so basically no overhead then we

00:19:28,160 --> 00:19:34,850
have a couple of sample code for example

00:19:30,290 --> 00:19:38,660
x TV one we do Ethernet IP v4 parsing

00:19:34,850 --> 00:19:42,980
and then drop these drop the performance

00:19:38,660 --> 00:19:45,770
to a medium heavy per second then we do

00:19:42,980 --> 00:19:48,080
even more we do a extra mag table lookup

00:19:45,770 --> 00:19:48,590
man to look up the MAC address in the

00:19:48,080 --> 00:19:51,740
map

00:19:48,590 --> 00:19:57,160
this is XT v3 and so it drop a little

00:19:51,740 --> 00:20:01,130
bit then XT P 60 even more so it does a

00:19:57,160 --> 00:20:03,440
map table lookup and then get a new TTL

00:20:01,130 --> 00:20:05,720
value write it back to the IP

00:20:03,440 --> 00:20:09,559
and recalculate the check sound so then

00:20:05,720 --> 00:20:12,649
it drops to 2.5 the drop is pretty huge

00:20:09,559 --> 00:20:15,320
so we did some analysis and find out

00:20:12,649 --> 00:20:19,100
that Co we generate from this compiler

00:20:15,320 --> 00:20:21,830
actually has two overhead first is that

00:20:19,100 --> 00:20:25,909
with the people we expect before users

00:20:21,830 --> 00:20:27,919
to expenses the pie ordering is horse by

00:20:25,909 --> 00:20:31,070
ordering but then we have to convert it

00:20:27,919 --> 00:20:33,379
into narrow by order and then convert it

00:20:31,070 --> 00:20:36,559
back so they are multiple by order

00:20:33,379 --> 00:20:39,559
conversion there and also what we are

00:20:36,559 --> 00:20:41,690
doing packet D parsing right now we

00:20:39,559 --> 00:20:43,429
uncondition know you just write

00:20:41,690 --> 00:20:45,259
everything into the package so sometimes

00:20:43,429 --> 00:20:48,080
people user doesn't touch the package so

00:20:45,259 --> 00:20:51,860
we don't need to do that so right now if

00:20:48,080 --> 00:20:54,590
we manually remove this to overhead then

00:20:51,860 --> 00:20:58,909
we get a little bit better performance

00:20:54,590 --> 00:21:00,559
right 14:13 and to medium package but

00:20:58,909 --> 00:21:02,779
these shows that they are still some

00:21:00,559 --> 00:21:07,429
work to do in our compiler so right now

00:21:02,779 --> 00:21:10,730
it's more straightforward some

00:21:07,429 --> 00:21:16,669
limitations so I would say compare with

00:21:10,730 --> 00:21:18,830
2 P 4 and X TV so loops for the people

00:21:16,669 --> 00:21:23,269
loops only allowing parser X DB you can

00:21:18,830 --> 00:21:26,299
do tail call for the nested headers P

00:21:23,269 --> 00:21:30,139
for supported bounded tabs and also x TP

00:21:26,299 --> 00:21:33,470
and others like multicast packet

00:21:30,139 --> 00:21:35,990
segmentation package reassembly queue

00:21:33,470 --> 00:21:39,799
scheduling and linear scans are not

00:21:35,990 --> 00:21:42,860
supporting people and xdp for the state

00:21:39,799 --> 00:21:49,429
in the case of people is using register

00:21:42,860 --> 00:21:51,559
and X T XT is using a PDF map we hit

00:21:49,429 --> 00:21:54,019
some limitations here so first of all

00:21:51,559 --> 00:21:56,450
switch we want to do multicast and

00:21:54,019 --> 00:22:00,049
broadcast right now XD p doesn't support

00:21:56,450 --> 00:22:02,710
it also when we when you users define a

00:22:00,049 --> 00:22:06,080
very large protocol or many protocols

00:22:02,710 --> 00:22:11,059
the stack size is too small right now as

00:22:06,080 --> 00:22:13,610
the limit is 512 byte and in the case of

00:22:11,059 --> 00:22:16,120
testing framework we use a lot of nine

00:22:13,610 --> 00:22:19,630
spaces and generics TP and

00:22:16,120 --> 00:22:22,270
in traffic between then we we found out

00:22:19,630 --> 00:22:25,320
that I UDP and I see him he works but

00:22:22,270 --> 00:22:32,520
TCP somehow because of this skb clone

00:22:25,320 --> 00:22:36,160
TCP is not is ignoring this case and

00:22:32,520 --> 00:22:38,710
find out that under some case of we are

00:22:36,160 --> 00:22:41,440
using dense namespaces we have to put

00:22:38,710 --> 00:22:44,500
everything in one command line if we

00:22:41,440 --> 00:22:47,260
break and if you ping amoebans and break

00:22:44,500 --> 00:22:50,800
the coming into many different commands

00:22:47,260 --> 00:22:52,500
and so the map is it snappy it's come

00:22:50,800 --> 00:22:56,890
there

00:22:52,500 --> 00:22:59,500
so in conclusion so people is actually a

00:22:56,890 --> 00:23:02,200
very high level language for you to for

00:22:59,500 --> 00:23:05,020
users to specify that they have passed

00:23:02,200 --> 00:23:06,820
behavior so this language you can be

00:23:05,020 --> 00:23:09,550
generalized to different architecture

00:23:06,820 --> 00:23:17,200
and in this we are talking about the

00:23:09,550 --> 00:23:20,170
Linux kernel and X T P so XT can be so

00:23:17,200 --> 00:23:24,100
people can express X T P in a high level

00:23:20,170 --> 00:23:26,980
abstraction to C code and right now in

00:23:24,100 --> 00:23:31,180
this in these projects adrenal general

00:23:26,980 --> 00:23:32,920
Co is works okay performing but I I say

00:23:31,180 --> 00:23:37,060
there are still things to do and things

00:23:32,920 --> 00:23:49,360
to optimize okay that's all my talk

00:23:37,060 --> 00:23:50,500
thank you it's working Fabian I I don't

00:23:49,360 --> 00:23:52,420
blame you for when the shield yourself

00:23:50,500 --> 00:23:53,860
from kernel shenanigans I in fact

00:23:52,420 --> 00:23:56,620
encourage everyone to shield themselves

00:23:53,860 --> 00:23:58,180
from kernel shenanigans at all times do

00:23:56,620 --> 00:24:05,260
you have any questions for these fine

00:23:58,180 --> 00:24:05,560
folks at the upon the stage okay all

00:24:05,260 --> 00:24:08,800
right

00:24:05,560 --> 00:24:13,210
that work out a question you went from

00:24:08,800 --> 00:24:15,100
p4 to c2 BPF do you think that there's

00:24:13,210 --> 00:24:19,690
an advantage to go from p4 directly to b

00:24:15,100 --> 00:24:22,300
PF and skip the step from C into c yeah

00:24:19,690 --> 00:24:25,630
so the question is whether they make

00:24:22,300 --> 00:24:29,380
sense to directly transfer from p4 to a

00:24:25,630 --> 00:24:29,980
PPS right so right now we we don't have

00:24:29,380 --> 00:24:32,919
plan to do

00:24:29,980 --> 00:24:35,440
because it's hard to debug the benefit

00:24:32,919 --> 00:24:38,410
of transfer translating compared to see

00:24:35,440 --> 00:24:42,970
is that we can reduce all the tools who

00:24:38,410 --> 00:24:49,890
are building today so it's mostly about

00:24:42,970 --> 00:24:52,450
convenience because we have Olivia froth

00:24:49,890 --> 00:24:54,400
probably I think I love VM is a bit

00:24:52,450 --> 00:24:58,210
inefficient in its generation sometimes

00:24:54,400 --> 00:25:00,790
I think Mia I talked about this but

00:24:58,210 --> 00:25:02,110
that's not our domain I think one of the

00:25:00,790 --> 00:25:04,360
things you're you're running into is

00:25:02,110 --> 00:25:06,250
that you have this nice header structure

00:25:04,360 --> 00:25:10,330
and it's trying to accommodate basically

00:25:06,250 --> 00:25:11,650
anything p4 could try to just and if you

00:25:10,330 --> 00:25:13,390
get to the point where you can plane

00:25:11,650 --> 00:25:15,490
down what's in there based upon what

00:25:13,390 --> 00:25:18,910
features of p4 were actually used by the

00:25:15,490 --> 00:25:20,290
p4 program whatever gains you think

00:25:18,910 --> 00:25:22,030
you're gonna get by going directly to

00:25:20,290 --> 00:25:24,190
BPF you might get from this

00:25:22,030 --> 00:25:25,179
simplification optimization that you

00:25:24,190 --> 00:25:27,250
could perform during the translation

00:25:25,179 --> 00:25:28,630
stage I do agree with you that it's a

00:25:27,250 --> 00:25:30,160
lot easier to debug and it's a lot

00:25:28,630 --> 00:25:32,200
easier to insert this stuff into your

00:25:30,160 --> 00:25:33,880
debugging and testing framework just

00:25:32,200 --> 00:25:41,590
because there's that intermediate C

00:25:33,880 --> 00:25:44,559
stage yes anyone else so I'm curious the

00:25:41,590 --> 00:25:47,470
key parts the step where like one of the

00:25:44,559 --> 00:25:49,510
optimizations was if you can basically

00:25:47,470 --> 00:25:51,250
avoid writing the entire set of headers

00:25:49,510 --> 00:25:53,559
you know about back into the packet then

00:25:51,250 --> 00:25:56,200
you save a lot of performance do you see

00:25:53,559 --> 00:25:57,549
that as a limitation of p4 or it's like

00:25:56,200 --> 00:25:59,470
something you can do in the compiler

00:25:57,549 --> 00:26:01,900
like this was also exposed to the API

00:25:59,470 --> 00:26:04,660
right so like where's the the line of

00:26:01,900 --> 00:26:07,990
what the compiler can generate more

00:26:04,660 --> 00:26:10,690
sensible code there and yeah I think

00:26:07,990 --> 00:26:13,090
this is a something compiler can do so

00:26:10,690 --> 00:26:15,040
as a compiler we should take we should

00:26:13,090 --> 00:26:18,010
look at the mentioned action probably

00:26:15,040 --> 00:26:20,169
should scan users going in the match and

00:26:18,010 --> 00:26:23,200
action stage to see whether this

00:26:20,169 --> 00:26:25,870
protocol or these headers modify or not

00:26:23,200 --> 00:26:30,750
so if it is not modified then we can

00:26:25,870 --> 00:26:30,750
skip the departure stage

00:26:37,989 --> 00:26:43,489
do you have any plans to address the

00:26:41,149 --> 00:26:44,899
problem that some programs can be

00:26:43,489 --> 00:26:46,940
rejected by the corner for example

00:26:44,899 --> 00:26:48,889
because the features you need are not in

00:26:46,940 --> 00:26:53,509
the particular originals or the driver

00:26:48,889 --> 00:26:55,359
does not support XDP or so on but we had

00:26:53,509 --> 00:26:58,220
that as a persistent problem that the

00:26:55,359 --> 00:27:03,859
verifier rejects whatever program you

00:26:58,220 --> 00:27:06,409
generate right now and I'm although it's

00:27:03,859 --> 00:27:08,690
supposed to be safe by p4 standards but

00:27:06,409 --> 00:27:12,710
we have little control over over that

00:27:08,690 --> 00:27:14,720
right now and I'm not sure what you

00:27:12,710 --> 00:27:22,070
could do Jerry this is an evolving

00:27:14,720 --> 00:27:23,359
situation yeah so so we're kind of so we

00:27:22,070 --> 00:27:25,730
kind of had the chicken and egg problem

00:27:23,359 --> 00:27:28,580
if we don't have people like these great

00:27:25,730 --> 00:27:30,440
folks trying to do really serious things

00:27:28,580 --> 00:27:32,869
with XDP we're not gonna learn about the

00:27:30,440 --> 00:27:35,029
limitations and bugs in the verifier in

00:27:32,869 --> 00:27:36,409
xcp itself like that TCP cloning

00:27:35,029 --> 00:27:39,230
situation which unfortunately I've known

00:27:36,409 --> 00:27:41,359
about for quite some time we're not

00:27:39,230 --> 00:27:42,619
gonna know what we need to fix so I

00:27:41,359 --> 00:27:45,109
think we're just gonna have to go back

00:27:42,619 --> 00:27:46,820
and forth iterating like this and till

00:27:45,109 --> 00:27:48,679
we get everything working properly yeah

00:27:46,820 --> 00:27:50,840
so there's still a process where you

00:27:48,679 --> 00:27:53,869
have to manually did files to pass the

00:27:50,840 --> 00:27:56,179
verifier because our code is - we're

00:27:53,869 --> 00:27:59,659
both right now or there's some little

00:27:56,179 --> 00:28:01,639
problem in there so the interest user

00:27:59,659 --> 00:28:05,590
space testing is meant to check if the

00:28:01,639 --> 00:28:05,590
it passes to verify or not normally

00:28:08,769 --> 00:28:13,759
would it make sense to create some kind

00:28:11,629 --> 00:28:18,429
of database of programs that are failing

00:28:13,759 --> 00:28:18,429
by a fire that just those guys can fit I

00:28:19,179 --> 00:28:23,269
mean something that would be easy for

00:28:21,289 --> 00:28:24,710
those guys like if they have program

00:28:23,269 --> 00:28:26,210
that doesn't pass very far and they take

00:28:24,710 --> 00:28:30,700
the correct just put it somewhere

00:28:26,210 --> 00:28:30,700
without doing much effort on dayside

00:28:31,059 --> 00:28:36,379
it's not accepted by the verifier so

00:28:33,830 --> 00:28:37,590
that we know that we have to fix this is

00:28:36,379 --> 00:28:40,560
what you're saying

00:28:37,590 --> 00:28:43,110
I guess well we really want people to

00:28:40,560 --> 00:28:44,880
just post it on that dev or wherever BPF

00:28:43,110 --> 00:28:46,500
list discussion is taking place so that

00:28:44,880 --> 00:28:48,780
Daniel and Alexia and the other

00:28:46,500 --> 00:28:51,000
developers can look at it so if you want

00:28:48,780 --> 00:28:54,780
a formal way to have a place where not

00:28:51,000 --> 00:28:55,350
functioning programs can be sent to get

00:28:54,780 --> 00:28:57,780
looked at

00:28:55,350 --> 00:28:59,910
I don't know that's up to Dan you come

00:28:57,780 --> 00:29:01,380
to Thursday's vpf tract and talk to

00:28:59,910 --> 00:29:03,960
Daniel and Alexei about it it's my

00:29:01,380 --> 00:29:05,400
recommendation to you so so there is

00:29:03,960 --> 00:29:06,840
actually a group at the EMA research

00:29:05,400 --> 00:29:08,930
which is doing that right now that

00:29:06,840 --> 00:29:11,220
compiling all kinds of programs in

00:29:08,930 --> 00:29:13,350
building a database to identify what

00:29:11,220 --> 00:29:15,810
houses the worry if I um what doesn't

00:29:13,350 --> 00:29:18,930
I'm not sure what they're doing if it

00:29:15,810 --> 00:29:20,850
right now but they could be using that

00:29:18,930 --> 00:29:23,900
information for their various purposes

00:29:20,850 --> 00:29:23,900
[Laughter]

00:29:25,070 --> 00:29:28,950
Thanks so you mentioned you had a user

00:29:27,450 --> 00:29:30,240
space testing framework does that

00:29:28,950 --> 00:29:32,100
integrate with the verified any way you

00:29:30,240 --> 00:29:35,160
try to emulate the verifier limits or no

00:29:32,100 --> 00:29:36,270
so it's just because you want to have

00:29:35,160 --> 00:29:38,250
two stages we want to wait a fight

00:29:36,270 --> 00:29:40,710
that's people work there's our code

00:29:38,250 --> 00:29:41,460
compile and then the second stage is the

00:29:40,710 --> 00:29:43,800
end to interest

00:29:41,460 --> 00:29:46,380
coño test does it actually pass the fire

00:29:43,800 --> 00:29:47,760
fire so if it doesn't pass the first

00:29:46,380 --> 00:29:51,200
stage the user space testing we know

00:29:47,760 --> 00:29:51,200
okay we actually have to fix up before

00:29:51,290 --> 00:30:05,160
anyone else so I was wondering I'm not

00:30:01,910 --> 00:30:06,840
quite sure exactly how people would but

00:30:05,160 --> 00:30:09,120
there's like extensions to it as well

00:30:06,840 --> 00:30:11,370
right external so something called how

00:30:09,120 --> 00:30:17,490
much of that are you implementing is it

00:30:11,370 --> 00:30:20,070
just the base p4 language in this

00:30:17,490 --> 00:30:23,090
project so p4 so there's a base project

00:30:20,070 --> 00:30:26,850
or p4 C and we provide compiler base

00:30:23,090 --> 00:30:29,670
features and then p4 c xt p is an

00:30:26,850 --> 00:30:31,230
extension to this module and we reuse

00:30:29,670 --> 00:30:33,960
some of the stuff there and we also

00:30:31,230 --> 00:30:39,450
create our own architectural model which

00:30:33,960 --> 00:30:43,410
is which maps to the xdp model so so the

00:30:39,450 --> 00:30:45,840
extension in p 4e b PF or p4 x TP is

00:30:43,410 --> 00:30:47,760
pretty much just the helpers in eb PF

00:30:45,840 --> 00:30:50,290
it's all these helper functions

00:30:47,760 --> 00:30:53,049
TC helper functions for example TC for

00:30:50,290 --> 00:30:55,890
or something like that and they're

00:30:53,049 --> 00:30:58,299
defined in the p4 architecture model and

00:30:55,890 --> 00:31:00,669
if you compile this before architecture

00:30:58,299 --> 00:31:03,160
model these will be translated to p PF

00:31:00,669 --> 00:31:05,200
helper functions okay I'm from sort of a

00:31:03,160 --> 00:31:08,590
point of view of what you can do from

00:31:05,200 --> 00:31:13,030
the p4 language yeah you can use support

00:31:08,590 --> 00:31:18,070
as anything you don't support the

00:31:13,030 --> 00:31:20,410
depends I mean not support is pretty

00:31:18,070 --> 00:31:22,270
general and it depends all kinds of like

00:31:20,410 --> 00:31:24,429
whenever you're up to the cpu P for

00:31:22,270 --> 00:31:26,830
whatever you try to the CPU in a typical

00:31:24,429 --> 00:31:30,309
switch p4 can do it cannot deal with the

00:31:26,830 --> 00:31:31,840
scheduling or like like packet queuing

00:31:30,309 --> 00:31:34,120
decisions or anything like that in that

00:31:31,840 --> 00:31:36,429
sense right because I'm weather so like

00:31:34,120 --> 00:31:40,000
a traffic control traffic management

00:31:36,429 --> 00:31:43,660
extension in the work for P for yes into

00:31:40,000 --> 00:31:45,280
this it cannot do I don't a kind of

00:31:43,660 --> 00:31:47,440
counting right now I don't think it can

00:31:45,280 --> 00:31:51,549
do traffic shaping or traffic control in

00:31:47,440 --> 00:31:56,240
that sense okay it could be implemented

00:31:51,549 --> 00:32:01,559
I think all right thank you very much

00:31:56,240 --> 00:32:01,559

YouTube URL: https://www.youtube.com/watch?v=r_P5pKNFNHY


