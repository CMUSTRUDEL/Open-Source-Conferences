Title: LPC2018 - Whats Happened Network Junior C Nov 14
Publication date: 2018-12-04
Playlist: LPC2018 - Networking Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/108/
speaker:  Jesse Brandeburg (Intel), Anjali Singhai Jain (Intel)


Over the last 10 years the world has seen NICs go from single port,
single netdev devices, to multi-port, hardware switching, CPU/NFP
having, FPGA carrying, hundreds of attached netdev providing,
behemoths. This presentation will begin with an overview of the
current state of filtering and scheduling, and the evolution of the
kernel and networking hardware interfaces. (HINT: it’s a bit of a
jungle we’ve helped grow!) We’ll summarize the different kinds of
networking products available from different vendors, and show the
workflows of how a user can use the network hardware
offloads/accelerations available and where there are still gaps. Of
particular interest to us is how to have a useful, generic hardware
offload supporting infrastructure (with seamless software fallback!)
within the kernel, and we’ll explain the differences between deploying
an eBPF program that can run in software, and one that can be
offloaded by a programmable ASIC based NIC. We will discuss our
analysis of the cost of an offload, and when it may not be a great
idea to do so, as hardware offload is most useful when it achieves the
desired speed and requires no special software (kernel changes). Some
other topics we will touch on: the programmability exposed by smart
NICs is more than that of a data plane packet processing engine and
hence any packet processing programming language such as eBPF or P4
will require certain extensions to take advantage of the device
capabilities in a holistic way. We’ll provide a look into the future
and how we think our customers will use the interfaces we want to
provide both from our hardware, and from the kernel. We will also go
over the matrix of most important parameters that are shaping our HW
designs and why.
Captions: 
	00:00:05,660 --> 00:00:09,809
our next presenter is a Jessi

00:00:08,160 --> 00:00:12,059
Brandenburg from Intel Jessi's been

00:00:09,809 --> 00:00:14,330
contributing to the networking and

00:00:12,059 --> 00:00:16,439
kernel community for quite some time I

00:00:14,330 --> 00:00:19,680
distinctly remember walking through

00:00:16,439 --> 00:00:22,860
Toronto on a cold day with him talking

00:00:19,680 --> 00:00:24,930
about the busy polling and that's a

00:00:22,860 --> 00:00:25,980
feature we we have and you just tell me

00:00:24,930 --> 00:00:27,989
how great it was and what kind of

00:00:25,980 --> 00:00:34,620
performance he was getting and Jessi is

00:00:27,989 --> 00:00:36,270
also very in tune with what kind of

00:00:34,620 --> 00:00:38,250
problems people run into a driver

00:00:36,270 --> 00:00:40,320
development because from their

00:00:38,250 --> 00:00:42,120
perspective they've submitted a lot of

00:00:40,320 --> 00:00:43,410
drivers they've worked a lot upstream

00:00:42,120 --> 00:00:45,359
and they know what the pain points are

00:00:43,410 --> 00:00:47,609
so his perspective is extremely valuable

00:00:45,359 --> 00:00:50,070
and I appreciate that so without further

00:00:47,609 --> 00:00:54,030
ado Jessie thanks Dave for the nice

00:00:50,070 --> 00:00:55,500
introduction so we'll get started thanks

00:00:54,030 --> 00:00:57,570
for coming today I know everybody's got

00:00:55,500 --> 00:01:02,129
a nice full belly so it'll be nice and

00:00:57,570 --> 00:01:05,280
quiet right yeah I won't say anything if

00:01:02,129 --> 00:01:07,530
we hear snoring I promise so we're going

00:01:05,280 --> 00:01:09,540
to talk today about network offloads in

00:01:07,530 --> 00:01:12,480
particular networking hardware offloads

00:01:09,540 --> 00:01:14,130
and just a quick note all the photos in

00:01:12,480 --> 00:01:16,200
this presentation were Creative Commons

00:01:14,130 --> 00:01:19,170
licensed so go open-source kinda

00:01:16,200 --> 00:01:22,200
licenses today we're going to talk about

00:01:19,170 --> 00:01:25,080
a brief history of offloads the the

00:01:22,200 --> 00:01:26,670
hardware kind of that we have today some

00:01:25,080 --> 00:01:31,350
of the offloads and problems that we

00:01:26,670 --> 00:01:36,390
have seen coming and gone and a couple

00:01:31,350 --> 00:01:39,210
proposals for what I think can can

00:01:36,390 --> 00:01:41,760
happen going forward for the networking

00:01:39,210 --> 00:01:44,990
kernel and for device drivers in general

00:01:41,760 --> 00:01:44,990
for network cards

00:01:47,890 --> 00:01:55,390
so me I'm Jessie Brandenburg my

00:01:52,420 --> 00:01:58,150
co-speaker Anjali couldn't make it to

00:01:55,390 --> 00:02:00,310
the conference this year so it's just me

00:01:58,150 --> 00:02:02,770
you could enjoy me the whole time

00:02:00,310 --> 00:02:04,960
I'm a principal engineer at Intel I've

00:02:02,770 --> 00:02:07,780
been with until for 25 years working on

00:02:04,960 --> 00:02:09,369
future products and big open source

00:02:07,780 --> 00:02:15,040
proponent within our group in our

00:02:09,369 --> 00:02:17,640
company so let's start off with a little

00:02:15,040 --> 00:02:21,250
bit of history right

00:02:17,640 --> 00:02:23,290
we started with offloads way way back

00:02:21,250 --> 00:02:26,980
when do you guys remember when there was

00:02:23,290 --> 00:02:28,870
only one negative and one external port

00:02:26,980 --> 00:02:30,550
and maybe if you were lucky you save it

00:02:28,870 --> 00:02:32,770
if you CPU cycles by offloading your

00:02:30,550 --> 00:02:35,980
check sums and maybe TSO if you were

00:02:32,770 --> 00:02:37,060
lucky right so it it all began with a

00:02:35,980 --> 00:02:40,900
small set right

00:02:37,060 --> 00:02:45,520
what do offloads do they they help you

00:02:40,900 --> 00:02:47,170
save your cpu from doing work so back in

00:02:45,520 --> 00:02:48,790
the day we had a file called include

00:02:47,170 --> 00:02:51,010
Linux that device that H and it had

00:02:48,790 --> 00:02:52,959
support for just a couple basic offloads

00:02:51,010 --> 00:02:55,810
from particularly our cards but a lot of

00:02:52,959 --> 00:02:58,209
other people to scatter gather doing IP

00:02:55,810 --> 00:03:01,269
checksum offload and hardware checksum

00:02:58,209 --> 00:03:04,630
offload so kind of an interesting thing

00:03:01,269 --> 00:03:06,070
back then you would say I can do I can

00:03:04,630 --> 00:03:07,660
insert an IP checksum in the header

00:03:06,070 --> 00:03:09,010
that's great I could check sums are easy

00:03:07,660 --> 00:03:11,290
they're nice and short always pretty

00:03:09,010 --> 00:03:14,170
much the same Hardware checksum you the

00:03:11,290 --> 00:03:17,739
flag used to say I'll just advertise I

00:03:14,170 --> 00:03:19,690
can checksum anything there was no

00:03:17,739 --> 00:03:21,010
differentiation you just said it was an

00:03:19,690 --> 00:03:22,930
on-off flag I can check somewhere I

00:03:21,010 --> 00:03:26,410
can't in Hardware so it was an

00:03:22,930 --> 00:03:31,090
interesting start right but at the time

00:03:26,410 --> 00:03:32,260
it seemed perfect so as we go through

00:03:31,090 --> 00:03:33,820
here you might notice a little bit of a

00:03:32,260 --> 00:03:37,750
theme if you know me you know I like

00:03:33,820 --> 00:03:40,200
cars so we'll continue with the theme as

00:03:37,750 --> 00:03:40,200
we go through

00:03:42,760 --> 00:03:47,799
so history continues right good thing

00:03:45,489 --> 00:03:51,519
time moved on we had more offloads

00:03:47,799 --> 00:03:53,890
there was especially 802 1q VLAN insert

00:03:51,519 --> 00:03:55,269
and delete seemed like the great offload

00:03:53,890 --> 00:03:57,129
there's a whole nother module for it and

00:03:55,269 --> 00:03:59,260
we added transfer segmentation offload

00:03:57,129 --> 00:04:02,319
the initial implementations were spewed

00:03:59,260 --> 00:04:04,390
all over the kernel stack right from top

00:04:02,319 --> 00:04:07,750
to bottom every single element in the

00:04:04,390 --> 00:04:10,390
entire chain had to change these off

00:04:07,750 --> 00:04:13,870
loads as we went on and got more and

00:04:10,390 --> 00:04:15,940
more heavy weight and stock changes were

00:04:13,870 --> 00:04:18,160
necessary and they had big impacts to

00:04:15,940 --> 00:04:19,389
the stack I mean we had lots of TSO bugs

00:04:18,160 --> 00:04:22,870
and things that we went through at the

00:04:19,389 --> 00:04:28,510
very beginning it was not a great bunch

00:04:22,870 --> 00:04:30,460
of fun so the the TSO and it's been

00:04:28,510 --> 00:04:33,789
talked about in other context in this in

00:04:30,460 --> 00:04:37,210
this form already today big gain in

00:04:33,789 --> 00:04:38,500
speed in cpu the speed comes from the

00:04:37,210 --> 00:04:40,090
hardware doing most of the segmentation

00:04:38,500 --> 00:04:42,729
work so things only move through the

00:04:40,090 --> 00:04:44,380
stack one time the bigger gain is that

00:04:42,729 --> 00:04:47,410
you reduce your cpu right because the

00:04:44,380 --> 00:04:49,419
cpu isn't doing repeated trips up and

00:04:47,410 --> 00:04:51,660
down a big long instruction pipeline

00:04:49,419 --> 00:04:55,330
trying to get packets out on the wire

00:04:51,660 --> 00:04:58,510
however I have to say you know thanks to

00:04:55,330 --> 00:05:01,270
Erik for writing gso the final revision

00:04:58,510 --> 00:05:03,310
seems like of our TCP segmentation

00:05:01,270 --> 00:05:04,930
offload that supports both software and

00:05:03,310 --> 00:05:07,479
hardware offloads and it's much cleaner

00:05:04,930 --> 00:05:09,610
now right all the logic move down to the

00:05:07,479 --> 00:05:11,560
very top layer mostly just above the

00:05:09,610 --> 00:05:13,270
driver and the segmentation can happen

00:05:11,560 --> 00:05:16,450
there so for those of you who are

00:05:13,270 --> 00:05:18,639
familiar with it TSO you know does

00:05:16,450 --> 00:05:20,050
segmentation from a huge big long buffer

00:05:18,639 --> 00:05:21,639
with one header and a whole bunch of

00:05:20,050 --> 00:05:24,130
data and splits it up into a whole bunch

00:05:21,639 --> 00:05:26,020
of smaller pieces with of data with the

00:05:24,130 --> 00:05:29,440
same header replicated and updated as it

00:05:26,020 --> 00:05:32,110
goes out onto the wire so these um these

00:05:29,440 --> 00:05:34,510
offloads really help they're still super

00:05:32,110 --> 00:05:36,660
valuable today at any given speed

00:05:34,510 --> 00:05:40,210
because it saves you a bunch of cpu so

00:05:36,660 --> 00:05:42,550
you know it's a work reduction and in

00:05:40,210 --> 00:05:44,530
addition generally gives the network

00:05:42,550 --> 00:05:46,180
adapter cards the ability to transmit at

00:05:44,530 --> 00:05:47,560
wire speed because you can transmit

00:05:46,180 --> 00:05:48,820
these frames back-to-back because the

00:05:47,560 --> 00:05:53,919
whole all the data is prepared and

00:05:48,820 --> 00:05:56,130
waiting for the card so even more

00:05:53,919 --> 00:05:58,600
history

00:05:56,130 --> 00:06:00,340
quite a few more offloads were added

00:05:58,600 --> 00:06:03,520
right most of them are transmitted off

00:06:00,340 --> 00:06:10,330
loads we do all sorts of stuff along the

00:06:03,520 --> 00:06:12,340
line of tunnels and you know we're we're

00:06:10,330 --> 00:06:14,980
starting to see if we can offload the

00:06:12,340 --> 00:06:16,600
inner and the outer headers on tunnels

00:06:14,980 --> 00:06:19,870
we're trying to offload new protocol

00:06:16,600 --> 00:06:22,900
types there's we always want these basic

00:06:19,870 --> 00:06:25,300
off loads like checksum and TSO to be

00:06:22,900 --> 00:06:26,680
ready for any protocol type right we'd

00:06:25,300 --> 00:06:27,940
like that to work because the hardware's

00:06:26,680 --> 00:06:29,620
really good at these things and it makes

00:06:27,940 --> 00:06:31,450
sense to do them at the last minute it's

00:06:29,620 --> 00:06:34,480
interesting even today

00:06:31,450 --> 00:06:35,800
CPUs have gone you know tens or hundreds

00:06:34,480 --> 00:06:37,270
of orders of magnitude faster than they

00:06:35,800 --> 00:06:41,590
used to when I started working on the

00:06:37,270 --> 00:06:44,410
Linux but the the gain of doing check

00:06:41,590 --> 00:06:45,670
sums not in the CPU is still huge

00:06:44,410 --> 00:06:47,260
there's still a big difference because

00:06:45,670 --> 00:06:48,610
you'd have to touch every single byte in

00:06:47,260 --> 00:06:50,200
that frame door we compute that checksum

00:06:48,610 --> 00:06:53,640
so having our Hardware do it's a good

00:06:50,200 --> 00:06:56,800
thing the the receive offload space is

00:06:53,640 --> 00:06:57,760
definitely getting more now we're

00:06:56,800 --> 00:07:00,190
something to talk a lot more about

00:06:57,760 --> 00:07:01,780
receive off loads they change you know

00:07:00,190 --> 00:07:03,130
one of them is the obvious one which is

00:07:01,780 --> 00:07:06,820
large receive offload it's kind of the

00:07:03,130 --> 00:07:09,640
opposite of TSO right the kernel has

00:07:06,820 --> 00:07:12,040
this thing called gr oh now that allows

00:07:09,640 --> 00:07:13,990
the the stack to reassemble frames and

00:07:12,040 --> 00:07:16,360
software sometimes hardware can also do

00:07:13,990 --> 00:07:17,860
it to reassemble the frames and the

00:07:16,360 --> 00:07:20,500
hardware and take off the headers and

00:07:17,860 --> 00:07:22,150
make basically one small header and a

00:07:20,500 --> 00:07:23,950
whole bunch of data attached to it even

00:07:22,150 --> 00:07:27,160
though the MTU on the wire may be quite

00:07:23,950 --> 00:07:29,890
a bit smaller so what's happening with

00:07:27,160 --> 00:07:32,260
offloads now is they're getting a lot

00:07:29,890 --> 00:07:36,730
more complex right we're struggling with

00:07:32,260 --> 00:07:38,350
a lot more moving parts and I'll get to

00:07:36,730 --> 00:07:41,350
that in a minute on the next slide the

00:07:38,350 --> 00:07:43,450
the the the changes are no longer

00:07:41,350 --> 00:07:44,980
stateless right we're moving to these

00:07:43,450 --> 00:07:46,270
off loads that are trying to maintain

00:07:44,980 --> 00:07:48,010
state so you end up with more

00:07:46,270 --> 00:07:51,430
complicated firmware or you end up with

00:07:48,010 --> 00:07:53,650
really complicated Asics or you know you

00:07:51,430 --> 00:07:55,990
try and move work into CPUs that are

00:07:53,650 --> 00:07:57,810
existing on the NIC it goes on and on so

00:07:55,990 --> 00:08:02,530
the the other thing is happening is

00:07:57,810 --> 00:08:05,350
logical flows for are moving down into

00:08:02,530 --> 00:08:06,910
hardware like using EBP F programs so I

00:08:05,350 --> 00:08:08,350
had to mention it you know everybody

00:08:06,910 --> 00:08:10,860
does seems in this form

00:08:08,350 --> 00:08:12,759
[Laughter]

00:08:10,860 --> 00:08:13,960
rest assured that's the only time I

00:08:12,759 --> 00:08:16,449
mentioned BPF in the whole presentation

00:08:13,960 --> 00:08:19,030
okay so and we're also creating new

00:08:16,449 --> 00:08:20,949
paradigms like TC flower for visa which

00:08:19,030 --> 00:08:23,380
offload so the community is doing all

00:08:20,949 --> 00:08:25,240
sorts of things like trying to make sure

00:08:23,380 --> 00:08:26,830
that flows can be directed in the right

00:08:25,240 --> 00:08:28,900
place we're trying to push drop rules

00:08:26,830 --> 00:08:30,940
down into hardware we would like for

00:08:28,900 --> 00:08:32,770
that stuff to be available and exported

00:08:30,940 --> 00:08:38,440
easily to user space so that users can

00:08:32,770 --> 00:08:39,940
use it so what's happening now right the

00:08:38,440 --> 00:08:42,880
history is passed and now we're moving

00:08:39,940 --> 00:08:44,500
into present-day the you know the huge

00:08:42,880 --> 00:08:46,630
things are coming these these are no

00:08:44,500 --> 00:08:48,070
longer Nick's right I feel like they're

00:08:46,630 --> 00:08:50,230
a nick because I plugged them in to a

00:08:48,070 --> 00:08:52,720
machine but they're really SOC s or

00:08:50,230 --> 00:08:55,450
really complicated beasts there's FPGAs

00:08:52,720 --> 00:08:57,820
they have CPUs they have onboard RAM

00:08:55,450 --> 00:08:59,980
they they you know have tons of

00:08:57,820 --> 00:09:02,860
processing power they get really hot you

00:08:59,980 --> 00:09:05,440
know they need big huge connections to

00:09:02,860 --> 00:09:08,170
the to the main memory through the PCI

00:09:05,440 --> 00:09:10,420
Express bus we want PCI Express 4 so we

00:09:08,170 --> 00:09:14,110
can have the the wider connection the

00:09:10,420 --> 00:09:15,339
faster connections the the thing the

00:09:14,110 --> 00:09:18,459
other things that are coming you know

00:09:15,339 --> 00:09:20,110
the the cards of today are are shipping

00:09:18,459 --> 00:09:24,370
with virtualization support including

00:09:20,110 --> 00:09:26,320
SRA OB and scalable Iove there is you

00:09:24,370 --> 00:09:28,660
know like I said before tunnel offloads

00:09:26,320 --> 00:09:30,459
both for Tso and checksum and as well

00:09:28,660 --> 00:09:32,920
for doing encapsulation and

00:09:30,459 --> 00:09:34,900
decapsulation in hardware so imagine you

00:09:32,920 --> 00:09:36,160
want to communicate across the secure

00:09:34,900 --> 00:09:38,830
tunnel but you want to tell the user

00:09:36,160 --> 00:09:41,130
space that you're doing that so you can

00:09:38,830 --> 00:09:44,350
just transport every packet from that a

00:09:41,130 --> 00:09:47,470
network device to the other end and have

00:09:44,350 --> 00:09:50,320
it all be encrypted and in a nice little

00:09:47,470 --> 00:09:52,480
tunnel so that kind of offload has

00:09:50,320 --> 00:09:54,430
already made it into the kernel right

00:09:52,480 --> 00:09:56,800
there's there's vendors doing this today

00:09:54,430 --> 00:09:58,750
there's flow tracking we're trying to do

00:09:56,800 --> 00:10:02,230
millions of rules or even counters for

00:09:58,750 --> 00:10:07,510
flows these offloads are getting

00:10:02,230 --> 00:10:09,490
complicated there's a ton of hardware

00:10:07,510 --> 00:10:12,040
controls in like for instance our

00:10:09,490 --> 00:10:13,660
silicon there's all these knobs that we

00:10:12,040 --> 00:10:15,940
can twist and turn and it's getting

00:10:13,660 --> 00:10:17,740
really hard to figure out where we can

00:10:15,940 --> 00:10:19,779
control this or even how you can tell a

00:10:17,740 --> 00:10:21,010
user how to control it so that's one of

00:10:19,779 --> 00:10:22,240
the problems I think we're talking about

00:10:21,010 --> 00:10:26,050
today is that

00:10:22,240 --> 00:10:30,610
in general the the controls for the

00:10:26,050 --> 00:10:32,619
colonel are way too coarse so you know

00:10:30,610 --> 00:10:35,499
as another example like of these huge

00:10:32,619 --> 00:10:37,600
interfaces talking about counters how do

00:10:35,499 --> 00:10:39,699
you tell a driver to dump 1 million

00:10:37,600 --> 00:10:43,170
counters for the 1 million or 10 million

00:10:39,699 --> 00:10:45,759
flows or whatever you have every second

00:10:43,170 --> 00:10:48,550
you know I'm my brain just exploded

00:10:45,759 --> 00:10:50,110
because you know with let's transfer all

00:10:48,550 --> 00:10:51,399
these counters into netlink and dump

00:10:50,110 --> 00:10:52,809
them all and then where you gonna do

00:10:51,399 --> 00:10:55,209
with them how does the hardware move

00:10:52,809 --> 00:10:57,759
them from the hardware's storage into

00:10:55,209 --> 00:11:00,089
main memory etc etc etc it gets really

00:10:57,759 --> 00:11:02,619
hard to manage

00:11:00,089 --> 00:11:04,990
so these interfaces that we have today

00:11:02,619 --> 00:11:06,369
aren't scaling that's really the big

00:11:04,990 --> 00:11:08,230
thing I'm here to talk about right is

00:11:06,369 --> 00:11:10,149
that and and the other thing is that

00:11:08,230 --> 00:11:12,129
there's really small overlap between

00:11:10,149 --> 00:11:14,110
vendors as the offloads get bigger and

00:11:12,129 --> 00:11:17,230
bigger so we might say that we're doing

00:11:14,110 --> 00:11:18,850
one thing but it's not necessarily the

00:11:17,230 --> 00:11:21,309
same and it's catching users off-guard

00:11:18,850 --> 00:11:33,699
and it's not a great great place for us

00:11:21,309 --> 00:11:37,899
to be so you know it feels a little bit

00:11:33,699 --> 00:11:40,899
like we've gone the the bozo suco route

00:11:37,899 --> 00:11:42,970
with our offloads right so this is from

00:11:40,899 --> 00:11:45,309
the recent high for de driver with a

00:11:42,970 --> 00:11:47,019
kernel 4.18 and a recent eath tool and

00:11:45,309 --> 00:11:48,519
you know I know that it's a bit of an

00:11:47,019 --> 00:11:51,670
eye chart but it kind of gives you the

00:11:48,519 --> 00:11:54,819
idea of the offloads here listed are all

00:11:51,670 --> 00:11:56,860
over the place you know from features

00:11:54,819 --> 00:11:59,199
inside a scatter gather to whether or

00:11:56,860 --> 00:12:00,540
not we do TCS CTP segmentation you know

00:11:59,199 --> 00:12:05,379
connecting to a previous presentation

00:12:00,540 --> 00:12:07,029
UDP segmentation hardware TC offload

00:12:05,379 --> 00:12:10,569
right why is that one they're a neat

00:12:07,029 --> 00:12:14,889
tool so you kind of get the idea it's

00:12:10,569 --> 00:12:17,529
we're building this kind of crazy system

00:12:14,889 --> 00:12:19,449
and it started out simple and it made

00:12:17,529 --> 00:12:20,819
sense and then it got bigger and then we

00:12:19,449 --> 00:12:23,470
all kind of lost it and started building

00:12:20,819 --> 00:12:26,170
things with big exhaust pipes it stick

00:12:23,470 --> 00:12:27,610
out the back so you know we got to be

00:12:26,170 --> 00:12:28,839
careful about this right I think moving

00:12:27,610 --> 00:12:31,749
forward we need to be thinking a little

00:12:28,839 --> 00:12:33,639
bit ahead and whether or not we want to

00:12:31,749 --> 00:12:34,749
try and keep this up the status quo or

00:12:33,639 --> 00:12:37,079
where they want to try and invent

00:12:34,749 --> 00:12:37,079
something new

00:12:38,899 --> 00:12:47,790
so here we are in the case of option

00:12:42,029 --> 00:12:51,899
overload right we when you say eath tool

00:12:47,790 --> 00:12:54,810
hardware TC offload well what do you

00:12:51,899 --> 00:12:58,770
mean are you gonna support any action

00:12:54,810 --> 00:13:00,660
any match how many you can add a whole

00:12:58,770 --> 00:13:04,740
bunch of rules but then the thirteen

00:13:00,660 --> 00:13:10,290
thousand one fails how do you back out

00:13:04,740 --> 00:13:12,750
what happened it's getting a bit crazy

00:13:10,290 --> 00:13:15,529
as you start to scale up right so we

00:13:12,750 --> 00:13:17,970
need to try and figure out how to

00:13:15,529 --> 00:13:19,950
communicate these interfaces in a clean

00:13:17,970 --> 00:13:22,860
and concise way whether that be header

00:13:19,950 --> 00:13:24,750
files like eb PF is doing or or

00:13:22,860 --> 00:13:26,970
something along those lines

00:13:24,750 --> 00:13:28,260
the other thing that we've seen out in

00:13:26,970 --> 00:13:29,760
this space especially while doing

00:13:28,260 --> 00:13:32,339
research for this paper you end up with

00:13:29,760 --> 00:13:36,180
something like saying oh yeah i support

00:13:32,339 --> 00:13:38,940
feature x in the kernel and then each

00:13:36,180 --> 00:13:41,459
vendor writes 30 pages of documentation

00:13:38,940 --> 00:13:44,880
that describes how to use that feature x

00:13:41,459 --> 00:13:47,610
on their hardware and it doesn't apply

00:13:44,880 --> 00:13:49,500
really to anybody else's hardware it's

00:13:47,610 --> 00:13:51,360
very specific to that vendors hardware

00:13:49,500 --> 00:13:54,120
even though it's a kernel feature that

00:13:51,360 --> 00:13:59,430
supposedly generic and it's putting us

00:13:54,120 --> 00:14:03,420
in a bad spot both those vendors and as

00:13:59,430 --> 00:14:08,250
an open source community because we want

00:14:03,420 --> 00:14:09,810
our users to be happy right all of us so

00:14:08,250 --> 00:14:13,050
the other thing i wanted to mention here

00:14:09,810 --> 00:14:17,880
on this slide is the granularity problem

00:14:13,050 --> 00:14:19,709
right the the vendors have controls and

00:14:17,880 --> 00:14:21,600
the kernel has controls and they don't

00:14:19,709 --> 00:14:24,630
necessarily match in capability very

00:14:21,600 --> 00:14:26,579
well and there isn't a nice you know if

00:14:24,630 --> 00:14:28,079
if i had to add a feature to eath tool

00:14:26,579 --> 00:14:29,279
for every single hardware feature that

00:14:28,079 --> 00:14:31,079
our hardware supported they would just

00:14:29,279 --> 00:14:32,670
say no because it's all about our

00:14:31,079 --> 00:14:34,440
hardware right and we've heard this

00:14:32,670 --> 00:14:35,700
story repeatedly so we're trying to get

00:14:34,440 --> 00:14:36,899
into the space where we can find

00:14:35,700 --> 00:14:41,730
something that will help us describe

00:14:36,899 --> 00:14:43,500
what we can do and have a good hope of

00:14:41,730 --> 00:14:45,570
having a user be able to use it without

00:14:43,500 --> 00:14:47,959
having to call us and say huh what do i

00:14:45,570 --> 00:14:51,089
have to do now

00:14:47,959 --> 00:14:52,949
so how many of these overlap with each

00:14:51,089 --> 00:14:54,719
other and it's actually someone I think

00:14:52,949 --> 00:14:56,729
you mentioned earlier today and temple

00:14:54,719 --> 00:14:58,769
rules from a stool wait those are the

00:14:56,729 --> 00:14:59,309
same or are they different than the TC

00:14:58,769 --> 00:15:02,189
rules

00:14:59,309 --> 00:15:04,229
wait what about Dev link I'm confused

00:15:02,189 --> 00:15:07,199
what about you 32 you know it's this

00:15:04,229 --> 00:15:08,549
problem of how do i program my interface

00:15:07,199 --> 00:15:11,399
should I pick all of them should I

00:15:08,549 --> 00:15:13,049
support all of them as a vendor we

00:15:11,399 --> 00:15:14,819
what's happened also to the market is

00:15:13,049 --> 00:15:16,709
that we're seeing is that the market is

00:15:14,819 --> 00:15:19,589
by propagating badly right people want

00:15:16,709 --> 00:15:21,239
one thing over here and and customers

00:15:19,589 --> 00:15:22,979
want another thing over here and it's

00:15:21,239 --> 00:15:24,689
really hard as a vendor to try and

00:15:22,979 --> 00:15:26,909
figure out what you should do for

00:15:24,689 --> 00:15:30,719
defaults what you should support for

00:15:26,909 --> 00:15:32,009
interfaces because who knows what people

00:15:30,719 --> 00:15:35,459
are going to run the open source stacks

00:15:32,009 --> 00:15:38,159
are getting very tall as we've seen in

00:15:35,459 --> 00:15:39,809
some of the other presentations and like

00:15:38,159 --> 00:15:41,849
I asked earlier today in one of the BPF

00:15:39,809 --> 00:15:42,989
presentations what what do you do for a

00:15:41,849 --> 00:15:45,479
hardware offload if you want to get

00:15:42,989 --> 00:15:47,609
support for it into the kernel because

00:15:45,479 --> 00:15:50,669
maybe the kernel is able to save cycles

00:15:47,609 --> 00:15:52,189
by by pushing the work down into some

00:15:50,669 --> 00:15:54,299
dedicated piece of hardware and

00:15:52,189 --> 00:15:57,119
unfortunately as much as I'd like to say

00:15:54,299 --> 00:16:01,499
it the the world seems to have moved to

00:15:57,119 --> 00:16:03,929
offloads versus cpu work right no matter

00:16:01,499 --> 00:16:05,369
how fast we make the CPUs and no matter

00:16:03,929 --> 00:16:07,409
how many dedicate instructions we add

00:16:05,369 --> 00:16:08,579
for tasks there's always someone that

00:16:07,409 --> 00:16:11,129
comes up with an offload that's quicker

00:16:08,579 --> 00:16:14,669
or hardware that can do a dedicated task

00:16:11,129 --> 00:16:19,379
in a better way so one thing to mention

00:16:14,669 --> 00:16:21,449
here is right we should we just keep

00:16:19,379 --> 00:16:24,359
adding to these interfaces and all of

00:16:21,449 --> 00:16:27,119
them I don't know I don't think that's

00:16:24,359 --> 00:16:28,769
the right answer the you know so we've

00:16:27,119 --> 00:16:30,389
like I said that in the previous slides

00:16:28,769 --> 00:16:33,299
we've done the same thing over and over

00:16:30,389 --> 00:16:34,949
again I challenge the community to kind

00:16:33,299 --> 00:16:36,329
start coming up with something new let's

00:16:34,949 --> 00:16:37,889
look forward a little bit and see if we

00:16:36,329 --> 00:16:41,009
can figure out how to arrange this so

00:16:37,889 --> 00:16:42,719
that everybody benefits one thing that I

00:16:41,009 --> 00:16:44,849
did spot is that there's this new

00:16:42,719 --> 00:16:47,779
parameter option that came since I

00:16:44,849 --> 00:16:50,789
submitted this papers abstract this

00:16:47,779 --> 00:16:52,769
parameter dead link this is a possible

00:16:50,789 --> 00:16:54,329
way of moving forward but I'm not sure

00:16:52,769 --> 00:16:56,180
that it solves all of our problems I'll

00:16:54,329 --> 00:17:03,150
talk about that in a little bit

00:16:56,180 --> 00:17:04,740
see that's not us so one point it's a

00:17:03,150 --> 00:17:06,180
little bit out of the flow of the

00:17:04,740 --> 00:17:08,340
presentation but I wanted to point it

00:17:06,180 --> 00:17:11,640
out the net devs are no longer the

00:17:08,340 --> 00:17:14,640
external ports right it's kind of been

00:17:11,640 --> 00:17:16,170
this way for a long time but you know if

00:17:14,640 --> 00:17:19,320
you have VLANs or you have a stacked

00:17:16,170 --> 00:17:21,330
interface or you have containers you

00:17:19,320 --> 00:17:24,780
know you have all sorts of options that

00:17:21,330 --> 00:17:27,030
give you control over the network but

00:17:24,780 --> 00:17:30,210
they're not necessarily dedicated to the

00:17:27,030 --> 00:17:31,770
external ports anymore so we've

00:17:30,210 --> 00:17:33,900
graduated right we've gone from this

00:17:31,770 --> 00:17:35,880
place where we had a really simple

00:17:33,900 --> 00:17:38,820
interface and simple uploads and we've

00:17:35,880 --> 00:17:40,770
moved on into these great big behemoths

00:17:38,820 --> 00:17:42,330
with a bazillion interfaces and a

00:17:40,770 --> 00:17:43,710
bazillion controls and a bunch of

00:17:42,330 --> 00:17:52,070
hardware support that's all different

00:17:43,710 --> 00:17:56,190
from every vendor so the problem right

00:17:52,070 --> 00:17:58,170
we end up with Mad Max the the

00:17:56,190 --> 00:18:00,450
organically-grown solutions right that

00:17:58,170 --> 00:18:01,980
we've done worked well I think they're

00:18:00,450 --> 00:18:05,010
still working we're kind of just hanging

00:18:01,980 --> 00:18:06,810
on by this by the by the fingernails but

00:18:05,010 --> 00:18:10,080
are we designing what we really want to

00:18:06,810 --> 00:18:12,750
achieve so that's my question open to

00:18:10,080 --> 00:18:14,820
you right are we really going the place

00:18:12,750 --> 00:18:17,130
that we want to end up so if we aren't

00:18:14,820 --> 00:18:18,630
we should try and aim right it's not

00:18:17,130 --> 00:18:20,040
going to be perfect we readjust

00:18:18,630 --> 00:18:22,800
constantly but we should try and aim

00:18:20,040 --> 00:18:24,660
forward I think at least two or three

00:18:22,800 --> 00:18:26,100
years trying to figure out what's coming

00:18:24,660 --> 00:18:28,710
and try and figure out how the kernel

00:18:26,100 --> 00:18:35,130
interfaces will work to absorb these

00:18:28,710 --> 00:18:36,450
changes that are coming so we have a big

00:18:35,130 --> 00:18:40,110
challenge ahead of us right the old

00:18:36,450 --> 00:18:42,180
models don't fit we need to come up with

00:18:40,110 --> 00:18:45,600
a kernel method of expressing these

00:18:42,180 --> 00:18:47,940
things you know should we migrate all to

00:18:45,600 --> 00:18:50,010
the dev link dev parameters control

00:18:47,940 --> 00:18:51,720
stuff it's still too coarse even though

00:18:50,010 --> 00:18:54,300
it's brand-new and that lets you control

00:18:51,720 --> 00:18:57,030
some things about the hardware its main

00:18:54,300 --> 00:19:00,420
interface point is the PCI Express bus

00:18:57,030 --> 00:19:02,130
device and function so you're expressing

00:19:00,420 --> 00:19:03,540
I would like some control over this bus

00:19:02,130 --> 00:19:05,550
device and function to do things a

00:19:03,540 --> 00:19:07,920
specific way and pass some parameters to

00:19:05,550 --> 00:19:09,480
it but it's still not enough we have s

00:19:07,920 --> 00:19:12,360
our IV devices we have

00:19:09,480 --> 00:19:14,240
interfaces we have VLANs we have Mac

00:19:12,360 --> 00:19:16,980
VLANs we have you know bridges and

00:19:14,240 --> 00:19:20,309
they're all capable of being done in our

00:19:16,980 --> 00:19:22,019
hardware and we need to be able and

00:19:20,309 --> 00:19:27,419
especially coming there's things about

00:19:22,019 --> 00:19:28,919
parsers and and rules right that use

00:19:27,419 --> 00:19:30,779
those parsers that we can do in our

00:19:28,919 --> 00:19:33,269
hardware in future generations or

00:19:30,779 --> 00:19:43,950
current generations and we can't express

00:19:33,269 --> 00:19:45,840
that to users so here's my idea right we

00:19:43,950 --> 00:19:48,809
got to figure out a way to do generic

00:19:45,840 --> 00:19:51,419
offload expression you know how do you

00:19:48,809 --> 00:19:52,200
describe a car with spots in a generic

00:19:51,419 --> 00:19:54,779
way right

00:19:52,200 --> 00:19:56,100
you know it doesn't it's not something

00:19:54,779 --> 00:19:57,690
that you would typically have when

00:19:56,100 --> 00:19:59,370
you're describing a car same thing for

00:19:57,690 --> 00:20:01,649
our network cards right we have a car

00:19:59,370 --> 00:20:02,700
everybody's like you have a NIC but it's

00:20:01,649 --> 00:20:07,980
not really a NIC

00:20:02,700 --> 00:20:09,149
it's a NIC with spots so the one way of

00:20:07,980 --> 00:20:11,309
going forward with this is to do

00:20:09,149 --> 00:20:14,399
something like like we've talked about

00:20:11,309 --> 00:20:16,950
with btf or name value pairs the

00:20:14,399 --> 00:20:19,019
something that helps the hardware and

00:20:16,950 --> 00:20:20,940
the driver self described itself in a

00:20:19,019 --> 00:20:22,679
way that users can then query and find

00:20:20,940 --> 00:20:24,090
out about what the hardware can do so

00:20:22,679 --> 00:20:25,279
this is actually becoming a common theme

00:20:24,090 --> 00:20:27,929
after sitting here for a couple days

00:20:25,279 --> 00:20:29,340
I've started to see this idea right

00:20:27,929 --> 00:20:31,370
coming to fruition in several other

00:20:29,340 --> 00:20:34,500
forms so I'm wondering how we can help

00:20:31,370 --> 00:20:36,480
use those examples as ways that we can

00:20:34,500 --> 00:20:43,139
go forward in a generic way for offloads

00:20:36,480 --> 00:20:46,049
for networking cards I don't know we

00:20:43,139 --> 00:20:49,289
need an N my my slide got marked somehow

00:20:46,049 --> 00:20:52,679
so uh you know we need a new way of

00:20:49,289 --> 00:20:54,299
doing these things we need a you know

00:20:52,679 --> 00:20:55,860
maybe we can move all so once we get

00:20:54,299 --> 00:20:57,240
this infrastructure in place this is

00:20:55,860 --> 00:20:59,070
generic enough we can have a nice

00:20:57,240 --> 00:21:00,350
library and that link interface that

00:20:59,070 --> 00:21:03,149
gives you control over the whole thing

00:21:00,350 --> 00:21:05,269
so that if you are an advanced user for

00:21:03,149 --> 00:21:07,649
instance in a data center you can

00:21:05,269 --> 00:21:10,039
control your hardware in a way that

00:21:07,649 --> 00:21:10,039
makes sense

00:21:13,890 --> 00:21:19,360
so I pretty much told you what I think

00:21:17,230 --> 00:21:23,170
the offload infrastructure code is

00:21:19,360 --> 00:21:24,700
needed really badly we we've reached

00:21:23,170 --> 00:21:28,150
this point where we have these crazy

00:21:24,700 --> 00:21:31,210
complicated offloads and I think we can

00:21:28,150 --> 00:21:32,530
do better trying to express them you

00:21:31,210 --> 00:21:34,600
know the option that we have right now

00:21:32,530 --> 00:21:35,740
is kind of the way that we're defaulting

00:21:34,600 --> 00:21:38,290
to which is that we have no

00:21:35,740 --> 00:21:41,560
implementation or control at all right

00:21:38,290 --> 00:21:44,080
so maybe the vendor X upstreams

00:21:41,560 --> 00:21:46,060
a feature that they want that day for

00:21:44,080 --> 00:21:47,740
one customer and then you get an extra

00:21:46,060 --> 00:21:49,120
control at it to eath tool is this what

00:21:47,740 --> 00:21:50,860
we want to do if you times that by a

00:21:49,120 --> 00:21:55,110
thousand we're gonna end up with this

00:21:50,860 --> 00:21:57,250
weird scenario that won't result in a

00:21:55,110 --> 00:21:58,420
pleasing solution at the end and that's

00:21:57,250 --> 00:22:00,370
what we all want right is easy to

00:21:58,420 --> 00:22:13,870
maintain code easy interfaces for users

00:22:00,370 --> 00:22:17,620
so I bet dave has an opinion me you have

00:22:13,870 --> 00:22:20,170
to realize that we're in the situation

00:22:17,620 --> 00:22:22,990
we're in now because the kernel is

00:22:20,170 --> 00:22:26,710
constantly struggling to find this

00:22:22,990 --> 00:22:29,020
abstraction that does two things first

00:22:26,710 --> 00:22:31,210
it allows to express what a piece of

00:22:29,020 --> 00:22:33,750
hardware can do but is also trying to do

00:22:31,210 --> 00:22:38,620
so in a way that is useful for users

00:22:33,750 --> 00:22:40,510
right so we kind of try to predict how

00:22:38,620 --> 00:22:42,520
things are going to go we come up with

00:22:40,510 --> 00:22:46,210
an abstraction like TC flower or what

00:22:42,520 --> 00:22:47,920
have you as an example and then we

00:22:46,210 --> 00:22:55,210
implement it for one person or two

00:22:47,920 --> 00:22:56,770
drivers and then if I set a Wiggles a

00:22:55,210 --> 00:22:58,780
little bit this way and device set B

00:22:56,770 --> 00:23:00,610
Wiggles a little bit that way and then

00:22:58,780 --> 00:23:02,560
there's no full coverage from the

00:23:00,610 --> 00:23:04,540
original abstraction that we created so

00:23:02,560 --> 00:23:07,510
we're constantly in this fix up mode

00:23:04,540 --> 00:23:09,190
where we're like okay now we got to go

00:23:07,510 --> 00:23:14,170
through this process all over again and

00:23:09,190 --> 00:23:17,800
what-have-you but so we have this big

00:23:14,170 --> 00:23:20,170
complicated situation because things are

00:23:17,800 --> 00:23:22,240
implicitly complicated yes yeah we were

00:23:20,170 --> 00:23:23,560
growing a complicated ecosystem he's got

00:23:22,240 --> 00:23:24,560
it exactly you can do and there's

00:23:23,560 --> 00:23:26,810
different needs

00:23:24,560 --> 00:23:28,370
and it's never completely clear to what

00:23:26,810 --> 00:23:29,720
extent the colonel is assisting and

00:23:28,370 --> 00:23:31,760
providing the abstraction for those

00:23:29,720 --> 00:23:34,460
things he's always gonna be people would

00:23:31,760 --> 00:23:35,000
be like none of these abstractions work

00:23:34,460 --> 00:23:36,710
for me

00:23:35,000 --> 00:23:38,630
I want to program to tea camp from user

00:23:36,710 --> 00:23:40,520
space and get out of the friggin way of

00:23:38,630 --> 00:23:42,350
me mm-hmm right and then there's other

00:23:40,520 --> 00:23:43,580
people are like I really want to use

00:23:42,350 --> 00:23:44,870
something standardized because I don't

00:23:43,580 --> 00:23:48,350
wanna have to changes when I changed

00:23:44,870 --> 00:23:50,660
NICs next month right so there are all

00:23:48,350 --> 00:23:52,580
these competing issues and we can't

00:23:50,660 --> 00:23:55,790
ignore any of them at this point that's

00:23:52,580 --> 00:23:59,240
part of the problem I agree that things

00:23:55,790 --> 00:24:02,810
like that that slide you had with the e

00:23:59,240 --> 00:24:04,370
tool output if that doesn't convince you

00:24:02,810 --> 00:24:07,160
that there's an issue I don't know what

00:24:04,370 --> 00:24:09,890
will this also goes back to your

00:24:07,160 --> 00:24:11,390
favorite topic which is documentation

00:24:09,890 --> 00:24:13,070
for drivers of your bases

00:24:11,390 --> 00:24:14,870
yeah we can start there I think that can

00:24:13,070 --> 00:24:16,060
help like we don't like it extend you

00:24:14,870 --> 00:24:18,290
could say we don't even know what we got

00:24:16,060 --> 00:24:21,680
right yeah it's hard to tell what you've

00:24:18,290 --> 00:24:23,180
got and you know I encourage you to find

00:24:21,680 --> 00:24:24,560
me afterwards or send me an email if you

00:24:23,180 --> 00:24:26,810
have some good ideas in this space I

00:24:24,560 --> 00:24:29,180
would love to try and help drive drive

00:24:26,810 --> 00:24:30,080
some momentum in this space you wouldn't

00:24:29,180 --> 00:24:31,700
want to told me that I'd like to a

00:24:30,080 --> 00:24:33,320
certain extent we have a lot of kernel

00:24:31,700 --> 00:24:35,480
doc stuff that just isn't integrated

00:24:33,320 --> 00:24:38,120
properly yeah that's probably a good

00:24:35,480 --> 00:24:40,580
starting point yeah I hope that yeah we

00:24:38,120 --> 00:24:42,230
can move to documentation and more right

00:24:40,580 --> 00:24:46,610
I would really like for us to be able to

00:24:42,230 --> 00:24:49,130
get the panacea of having you know there

00:24:46,610 --> 00:24:51,940
was a talk earlier about p4 and how it

00:24:49,130 --> 00:24:55,070
works when it integrates into BPF but

00:24:51,940 --> 00:24:57,770
the one of the problems there is that p4

00:24:55,070 --> 00:24:59,720
can express parser pipelines in the

00:24:57,770 --> 00:25:01,820
language and I don't think that

00:24:59,720 --> 00:25:04,160
translates into BPF yet very well today

00:25:01,820 --> 00:25:07,550
it's so the same situation like a

00:25:04,160 --> 00:25:09,590
compiler translates a C program with

00:25:07,550 --> 00:25:11,450
loops and higher level constructs into

00:25:09,590 --> 00:25:14,930
an intermediate language which loses

00:25:11,450 --> 00:25:16,670
that information and you you can't you

00:25:14,930 --> 00:25:18,110
don't have the high level look of what

00:25:16,670 --> 00:25:21,140
everything was doing you exactly it's

00:25:18,110 --> 00:25:22,790
like it's like assembly code right we

00:25:21,140 --> 00:25:24,710
write that back to see yeah how do we

00:25:22,790 --> 00:25:26,780
integrate that to go from top to bottom

00:25:24,710 --> 00:25:29,660
right we're working hard on the top in

00:25:26,780 --> 00:25:31,130
the middle but there's a lot of stuff

00:25:29,660 --> 00:25:34,370
left on the table and I think

00:25:31,130 --> 00:25:36,890
performance too at this point so I I'd

00:25:34,370 --> 00:25:37,379
also also will reveal a secret for the

00:25:36,890 --> 00:25:40,830
whole

00:25:37,379 --> 00:25:44,320
just like testing patches that add tests

00:25:40,830 --> 00:25:47,649
patches that improve documentation may

00:25:44,320 --> 00:25:51,070
bypass certain filters in my mind from

00:25:47,649 --> 00:25:53,830
time to time so I want to make sure that

00:25:51,070 --> 00:25:55,720
there is no barrier to entry or

00:25:53,830 --> 00:25:58,059
roadblocks for getting documentation

00:25:55,720 --> 00:26:00,249
fixes in please submit them more test

00:25:58,059 --> 00:26:02,649
cases more documentation let's do it

00:26:00,249 --> 00:26:04,330
totally agree there absolutely so are

00:26:02,649 --> 00:26:08,309
there any other questions that Dave can

00:26:04,330 --> 00:26:08,309
throw a square ball at you can hand it

00:26:09,059 --> 00:26:14,980
down the line so a couple questions

00:26:12,549 --> 00:26:17,379
points or comments the first one you

00:26:14,980 --> 00:26:19,389
picked on the TC Hydra offload so so I

00:26:17,379 --> 00:26:22,210
did that but it also came with an entire

00:26:19,389 --> 00:26:24,279
user stack and loot user files in a

00:26:22,210 --> 00:26:25,659
library on top of it and so when you ask

00:26:24,279 --> 00:26:26,950
like how do you know how big the t cam

00:26:25,659 --> 00:26:29,379
was how do you know what it supported

00:26:26,950 --> 00:26:32,169
it's because we built the knowledge into

00:26:29,379 --> 00:26:36,369
the application above so at some point I

00:26:32,169 --> 00:26:38,320
question are we looking at this at the

00:26:36,369 --> 00:26:39,460
wrong wrong level as kernel developers

00:26:38,320 --> 00:26:41,200
you want to put everything in the kernel

00:26:39,460 --> 00:26:43,629
and yes we're exposing complex stuff but

00:26:41,200 --> 00:26:45,609
why don't we write better tools and the

00:26:43,629 --> 00:26:47,350
casein point would be TC right like we

00:26:45,609 --> 00:26:49,179
we know this tool is bad everyone's

00:26:47,350 --> 00:26:51,580
complained about it it's the options are

00:26:49,179 --> 00:26:53,109
only known by a hundred people but it's

00:26:51,580 --> 00:26:54,519
been 10 years of complaining and no

00:26:53,109 --> 00:26:56,139
one's decided oh let me write a better

00:26:54,519 --> 00:26:57,730
tool because the the actual netlink

00:26:56,139 --> 00:27:01,090
interface is not the problem the problem

00:26:57,730 --> 00:27:03,129
is that is the tooling so I I wonder if

00:27:01,090 --> 00:27:05,109
some of these offload problems and how

00:27:03,129 --> 00:27:06,249
we expose them are because as kernel

00:27:05,109 --> 00:27:08,409
developers we keep adding kernel

00:27:06,249 --> 00:27:10,239
features and we don't have any one on

00:27:08,409 --> 00:27:13,749
top trying to build the abstraction that

00:27:10,239 --> 00:27:15,429
says hey if I want to run in whatever

00:27:13,749 --> 00:27:17,440
you could do a very high-level thing and

00:27:15,429 --> 00:27:18,940
say is this is this a data center

00:27:17,440 --> 00:27:20,499
computer all right here's your handful

00:27:18,940 --> 00:27:21,789
of defaults for data centers is loose or

00:27:20,499 --> 00:27:23,889
whatever here's my handful of defaults

00:27:21,789 --> 00:27:25,570
you can do automatic tuning at the user

00:27:23,889 --> 00:27:28,869
space level with the offloads that we

00:27:25,570 --> 00:27:30,249
have and never show it in my opinion I

00:27:28,869 --> 00:27:31,710
think we sort of failed if a user is

00:27:30,249 --> 00:27:33,639
sitting at the CLI and running eath tool

00:27:31,710 --> 00:27:36,789
right there should be something better

00:27:33,639 --> 00:27:40,809
for the users I also think that from a

00:27:36,789 --> 00:27:43,989
certain perspective we designed the

00:27:40,809 --> 00:27:45,840
kernel bits with TC in mind like we're

00:27:43,989 --> 00:27:47,980
like oh I know how I can implement

00:27:45,840 --> 00:27:49,750
access to this feature from user space

00:27:47,980 --> 00:27:52,210
off by going

00:27:49,750 --> 00:27:53,410
it's a vicious cycle and I totally agree

00:27:52,210 --> 00:27:57,220
with you that our tooling is kind of

00:27:53,410 --> 00:27:59,440
stinky we're running into the same

00:27:57,220 --> 00:28:02,410
problem with BPF or always talking about

00:27:59,440 --> 00:28:04,330
how it's it's hard it's intractable for

00:28:02,410 --> 00:28:06,340
new developers right the same

00:28:04,330 --> 00:28:08,580
perspective configuring network devices

00:28:06,340 --> 00:28:11,230
with advanced offloading features is

00:28:08,580 --> 00:28:14,560
more difficult than it really needs to

00:28:11,230 --> 00:28:16,720
be and maybe it's as much a tooling

00:28:14,560 --> 00:28:19,720
issue as it is what what abstractions

00:28:16,720 --> 00:28:21,850
have we providing the kernel issue good

00:28:19,720 --> 00:28:26,770
boy there's a couple questions in the

00:28:21,850 --> 00:28:29,770
back thanks David

00:28:26,770 --> 00:28:32,230
you know I worked with you in the past

00:28:29,770 --> 00:28:34,930
on some of these offloads and it was fun

00:28:32,230 --> 00:28:36,940
I remember at the time one common

00:28:34,930 --> 00:28:39,850
problem and it's been suggested here is

00:28:36,940 --> 00:28:42,190
that there's so many options you can set

00:28:39,850 --> 00:28:45,190
up conflicting options and so many times

00:28:42,190 --> 00:28:47,590
we'd be in a support situation somebody

00:28:45,190 --> 00:28:50,440
has set up their hardware in some way

00:28:47,590 --> 00:28:52,150
with offloads that make no sense this

00:28:50,440 --> 00:28:55,720
just makes no sense to have this offload

00:28:52,150 --> 00:28:57,790
going along with this one and there's

00:28:55,720 --> 00:29:00,520
very few controls to prevent people from

00:28:57,790 --> 00:29:02,530
you know if we try I mean we're all I

00:29:00,520 --> 00:29:04,990
remember we were always adding warnings

00:29:02,530 --> 00:29:07,300
and you know returning failures doing

00:29:04,990 --> 00:29:10,090
what we can to keep people from you know

00:29:07,300 --> 00:29:12,430
messing up their configuration at the

00:29:10,090 --> 00:29:14,800
time though I still always like to look

00:29:12,430 --> 00:29:16,960
at things from a use case standpoint if

00:29:14,800 --> 00:29:19,990
we could just develop a tool where

00:29:16,960 --> 00:29:22,720
people could pick from a menu of common

00:29:19,990 --> 00:29:25,570
standard use cases for their particular

00:29:22,720 --> 00:29:28,150
type of networking situation and then

00:29:25,570 --> 00:29:30,670
just apply this profile a template and

00:29:28,150 --> 00:29:32,350
they can modify it and and do whatever

00:29:30,670 --> 00:29:34,480
they want they can have new templates of

00:29:32,350 --> 00:29:36,340
course and things like this but it's

00:29:34,480 --> 00:29:38,920
it's this situation you guys are talking

00:29:36,340 --> 00:29:41,920
about the tools are just I was trying to

00:29:38,920 --> 00:29:44,050
figure out TC here recently and yeah it

00:29:41,920 --> 00:29:46,270
was it was a challenge so I think

00:29:44,050 --> 00:29:48,760
something where you just you you you

00:29:46,270 --> 00:29:51,100
give hints and provide templates and

00:29:48,760 --> 00:29:53,020
profiles right yeah we so the direction

00:29:51,100 --> 00:29:55,660
the tools would we'd like to get them to

00:29:53,020 --> 00:29:58,070
go yeah they've big grand round unified

00:29:55,660 --> 00:30:01,310
networking tool grunt yeah

00:29:58,070 --> 00:30:03,470
so we're also have a lot of

00:30:01,310 --> 00:30:05,360
self-inflicted wounds because what do we

00:30:03,470 --> 00:30:07,910
tell a driver author who tries to add a

00:30:05,360 --> 00:30:10,970
custom way to configure crap on their

00:30:07,910 --> 00:30:13,250
device we say please don't do this make

00:30:10,970 --> 00:30:15,140
a generic facility well guess what we

00:30:13,250 --> 00:30:17,450
have a rainbow of generic facilities now

00:30:15,140 --> 00:30:19,820
as a result of that book I don't know

00:30:17,450 --> 00:30:22,970
debug FS no sis FS so is your hand if

00:30:19,820 --> 00:30:24,440
you heard that so we've invested a lot

00:30:22,970 --> 00:30:26,510
of effort in getting people to do the

00:30:24,440 --> 00:30:28,880
right thing and then we don't invest a

00:30:26,510 --> 00:30:30,320
lot of effort in making sure the thing

00:30:28,880 --> 00:30:32,150
they come up with is homogeneous with

00:30:30,320 --> 00:30:33,920
the other stuff we have already that is

00:30:32,150 --> 00:30:35,570
where were weak yeah and that's why we

00:30:33,920 --> 00:30:36,980
end up with a lot of stuff yeah that's

00:30:35,570 --> 00:30:38,780
kind of the looking forward thing that I

00:30:36,980 --> 00:30:41,570
was trying to like you know we should

00:30:38,780 --> 00:30:43,310
try and meet and think about or have a

00:30:41,570 --> 00:30:44,900
discussion on IRC or something where we

00:30:43,310 --> 00:30:46,670
think about what's coming a little bit

00:30:44,900 --> 00:30:48,170
and will it fit or where could it fit

00:30:46,670 --> 00:30:50,180
right because then you can help target

00:30:48,170 --> 00:30:51,920
people who have spare cycles to work on

00:30:50,180 --> 00:30:53,780
open source software if we can actually

00:30:51,920 --> 00:30:55,430
document what we have already then we

00:30:53,780 --> 00:30:57,140
can plan for the future that would be an

00:30:55,430 --> 00:31:00,160
excellent starting point as you said yes

00:30:57,140 --> 00:31:04,220
I agree anyone else it's fantastic

00:31:00,160 --> 00:31:05,510
standing-room-only crowd yeah thanks

00:31:04,220 --> 00:31:06,680
again for coming everyone appreciate

00:31:05,510 --> 00:31:10,130
those standing in the back I know it's

00:31:06,680 --> 00:31:13,010
hot and staining such a small comment so

00:31:10,130 --> 00:31:16,910
as you mentioned the hardware vendor

00:31:13,010 --> 00:31:20,030
it's also hard to decide what to do so

00:31:16,910 --> 00:31:22,970
if there's like documentation you know

00:31:20,030 --> 00:31:25,850
in in Linux that says these are the

00:31:22,970 --> 00:31:27,410
things that we think Hardware should do

00:31:25,850 --> 00:31:29,810
and these are the things that Linux

00:31:27,410 --> 00:31:34,580
really wants to use that would be really

00:31:29,810 --> 00:31:39,560
helpful as well right so my favorite one

00:31:34,580 --> 00:31:43,190
is please do not account transmit work

00:31:39,560 --> 00:31:44,600
in your nappy polling function where's

00:31:43,190 --> 00:31:47,330
the key where's a lot write that down

00:31:44,600 --> 00:31:49,640
yeah where's that document what and I

00:31:47,330 --> 00:31:51,470
say it every time I see a new driver

00:31:49,640 --> 00:31:54,920
that doesn't implement that properly so

00:31:51,470 --> 00:31:57,140
this is what yeah we recorded it for you

00:31:54,920 --> 00:31:58,700
it's permanent everyone who rides on the

00:31:57,140 --> 00:32:01,160
next driver has to like watch this

00:31:58,700 --> 00:32:02,090
presentation well yeah totally start

00:32:01,160 --> 00:32:03,350
with this if you're if you're writing

00:32:02,090 --> 00:32:11,560
off loads you've totally look at this

00:32:03,350 --> 00:32:14,690
talk Steve of the network flow

00:32:11,560 --> 00:32:16,520
the only thing I would observe from

00:32:14,690 --> 00:32:20,920
seeing the slide is eath tooless

00:32:16,520 --> 00:32:23,420
outgrown its britches by a long way yes

00:32:20,920 --> 00:32:27,850
maybe we should just attack the first

00:32:23,420 --> 00:32:31,070
one and you know figure out a way to

00:32:27,850 --> 00:32:33,530
extend it cuz you know you know we have

00:32:31,070 --> 00:32:35,660
all these options of things on the

00:32:33,530 --> 00:32:36,980
interfaces with that Lincoln tunnels and

00:32:35,660 --> 00:32:39,500
all these things and it doesn't seem

00:32:36,980 --> 00:32:40,910
anywhere near as painful because people

00:32:39,500 --> 00:32:43,940
only got on that rat hole when they

00:32:40,910 --> 00:32:45,350
would need to versus this one but the

00:32:43,940 --> 00:32:47,150
hardware offloads were kind of like

00:32:45,350 --> 00:32:49,510
exposing our drawers to everybody all

00:32:47,150 --> 00:32:53,000
the time right right

00:32:49,510 --> 00:32:54,680
like deferred down the hill the net

00:32:53,000 --> 00:32:56,180
Lincoln version of Eve tool and moving

00:32:54,680 --> 00:32:58,280
into Devlin or whatever we're gonna do

00:32:56,180 --> 00:32:59,690
with the existing functionality so it's

00:32:58,280 --> 00:33:03,320
been hard to move forward because

00:32:59,690 --> 00:33:05,510
people's like we haven't done the

00:33:03,320 --> 00:33:07,420
conversion but I need this new feature

00:33:05,510 --> 00:33:09,890
and etool seems like the way to go so

00:33:07,420 --> 00:33:11,720
we've kind of deadlocked people in a way

00:33:09,890 --> 00:33:13,730
that's kind of unfair to people trying

00:33:11,720 --> 00:33:20,780
to actually get work done and that's a

00:33:13,730 --> 00:33:21,860
failure on our part actually ayyy so

00:33:20,780 --> 00:33:23,870
thanks for highlighting the deviling

00:33:21,860 --> 00:33:25,100
params tough I think that was the first

00:33:23,870 --> 00:33:26,450
step down that direction

00:33:25,100 --> 00:33:29,600
I mean we've looked at it because we

00:33:26,450 --> 00:33:31,400
wanted to try to have a way to express

00:33:29,600 --> 00:33:33,410
the ability to not have a proprietary

00:33:31,400 --> 00:33:35,690
tool to do a certain amount of settings

00:33:33,410 --> 00:33:38,330
that were stored in NVRAM and so we went

00:33:35,690 --> 00:33:39,560
down that route and it was because hey

00:33:38,330 --> 00:33:40,850
we're not taking any more stuff to eath

00:33:39,560 --> 00:33:41,720
tool we're not gonna set any more params

00:33:40,850 --> 00:33:43,520
we're not gonna do any of this stuff

00:33:41,720 --> 00:33:45,590
because there was some rudimentary

00:33:43,520 --> 00:33:46,940
capabilities they weren't gonna grow so

00:33:45,590 --> 00:33:48,890
we're hopeful i mean i'm hopeful that

00:33:46,940 --> 00:33:50,150
that will be something that people will

00:33:48,890 --> 00:33:52,280
think about in the future and a way to

00:33:50,150 --> 00:33:53,870
go yeah that's actually it's it's a

00:33:52,280 --> 00:33:55,820
great new way of configuring stuff it's

00:33:53,870 --> 00:33:57,950
kind of more permanent but is associated

00:33:55,820 --> 00:33:59,630
at a pretty pretty coarse granularity

00:33:57,950 --> 00:34:00,980
like I said you know what the PCI

00:33:59,630 --> 00:34:03,290
Express device is about as deep as you

00:34:00,980 --> 00:34:07,310
can go to configure so if it's chip wide

00:34:03,290 --> 00:34:09,560
then great if it's per port and but yeah

00:34:07,310 --> 00:34:12,380
I actually see some use cases for us

00:34:09,560 --> 00:34:13,370
going forward to to use it so it's one

00:34:12,380 --> 00:34:15,820
of those things that snuck in when I

00:34:13,370 --> 00:34:15,820
wasn't looking

00:34:17,930 --> 00:34:21,219
all right thank you very much Jesse O's

00:34:20,340 --> 00:34:25,949
great person

00:34:21,219 --> 00:34:25,949

YouTube URL: https://www.youtube.com/watch?v=KfvsdbwCcT8


