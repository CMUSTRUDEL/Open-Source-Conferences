Title: LPC2018 - XDP Challenges & Future Work
Publication date: 2018-12-04
Playlist: LPC2018 - Networking Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/92/
url:  http://vger.kernel.org/lpc-networking.html
speaker:  Jesper Dangaard Brouer (Red Hat), Toke HÃ¸iland-JÃ¸rgensen (Karlstad University)


XDP already offers rich facilities for high performance packet processing, and has seen deployment in several production systems. However, this does not mean that XDP is a finished system; on the contrary, improvements are being added in every release of Linux, and rough edges are constantly being filed down. The purpose of this talk is to discuss some of these possibilities for future improvements, including how to address some of the known limitations of the system. We are especially interested in soliciting feedback and ideas from the community on the best way forward.

The issues we are planning to discuss include, but are not limited to:

User experience and debugging tools: How do we make it easier for people who are not familiar with the kernel or XDP to get to grips with the system and be productive when writing XDP programs?
Driver support: How do we get to full support for XDP in all drivers? Is this even a goal we should be striving for?
Performance: At high packet rates, every micro-optimisation counts. Things like inlining function calls in drivers are important, but also batching to amortise fixed costs such as DMA mapping. What are the known bottlenecks, and how do we address them?
QoS and rate transitions: How should we do QoS in XDP? In particular, rate transitions (where a faster link feeds into a slower) are currently hard to deal with from XDP, and would benefit from, e.g., Active Queue Management (AQM). Can we adapt some of the AQM and QoS facilities in the regular networking stack to work with XDP? Or should we do something different?
Accelerating other parts of the stack: Tom Herbert started the discussion on accelerating transport protocols with XDP back in 2016. How do we make progress on this? Or should we be doing something different? Are there other areas where we can extend XDPs processing model to provide useful accelerations?
Captions: 
	00:00:06,799 --> 00:00:15,420
yes hello we are going to talk a little

00:00:11,040 --> 00:00:18,660
bit about the future of of XDP so this

00:00:15,420 --> 00:00:20,100
came out of writing a paper on it so

00:00:18,660 --> 00:00:31,859
we're a little bit about that and then

00:00:20,100 --> 00:00:33,870
try to summarize some of the we're going

00:00:31,859 --> 00:00:36,150
to frame it a little bit with with the

00:00:33,870 --> 00:00:38,010
other talks and so this talk will also

00:00:36,150 --> 00:00:39,600
be the introduction we'll have an

00:00:38,010 --> 00:00:41,460
introduction to HTP by the short one but

00:00:39,600 --> 00:00:46,079
people are we are sort of expected

00:00:41,460 --> 00:00:48,180
people know about HTTPS and yeah I have

00:00:46,079 --> 00:00:51,269
another talk to begin but Andy we're

00:00:48,180 --> 00:01:02,579
here is the last last talk after the

00:00:51,269 --> 00:01:04,170
conference introduces HTTP to a more

00:01:02,579 --> 00:01:08,310
sort of an academic audience and tries

00:01:04,170 --> 00:01:10,829
to have sort of a full system level

00:01:08,310 --> 00:01:12,390
description of what HTTPS and try to get

00:01:10,829 --> 00:01:14,400
it out to the research community and

00:01:12,390 --> 00:01:18,210
other people outside the community and

00:01:14,400 --> 00:01:25,140
that's been my shepherd into next we'll

00:01:18,210 --> 00:01:26,490
be presenting it in a few weeks and here

00:01:25,140 --> 00:01:31,860
was sort of we took the existing

00:01:26,490 --> 00:01:45,810
framework to make a description of it

00:01:31,860 --> 00:01:47,670
and then did this talk is to take some

00:01:45,810 --> 00:01:54,869
of that and solicit some ideas some

00:01:47,670 --> 00:01:56,880
feedback we hope at least that the whole

00:01:54,869 --> 00:01:58,380
way track you'll catch us at if your

00:01:56,880 --> 00:02:04,350
interest in one of two subjects and say

00:01:58,380 --> 00:02:05,759
this is wrong all right yeah so what is

00:02:04,350 --> 00:02:07,649
this extra piece stuff so this is

00:02:05,759 --> 00:02:10,470
basically the one slide to get to

00:02:07,649 --> 00:02:12,660
introduction to xtp so it is basically a

00:02:10,470 --> 00:02:15,450
new layer network stack so before we

00:02:12,660 --> 00:02:17,879
allocate the skb and it works on the

00:02:15,450 --> 00:02:21,000
driver level and basically we do it just

00:02:17,879 --> 00:02:23,849
after the DMA synchronization to receive

00:02:21,000 --> 00:02:26,579
this means that we are we can compare

00:02:23,849 --> 00:02:29,909
apples tables which with DDK and a net

00:02:26,579 --> 00:02:32,609
map Prakash will work at the same level

00:02:29,909 --> 00:02:34,439
now and then that also means it is super

00:02:32,609 --> 00:02:36,450
fast because we take the action earlier

00:02:34,439 --> 00:02:38,609
and the whole point is that you can skip

00:02:36,450 --> 00:02:40,769
some of the network layers if that's

00:02:38,609 --> 00:02:42,840
some options you need but you can also

00:02:40,769 --> 00:02:45,959
cooperate with the normal network stack

00:02:42,840 --> 00:02:47,790
and we avoid doing any memory

00:02:45,959 --> 00:02:51,060
allocations which is also part of the

00:02:47,790 --> 00:02:53,370
the speed optimization so it's important

00:02:51,060 --> 00:02:54,810
to note that this is not kernel bypass

00:02:53,370 --> 00:02:57,299
and that's sort of why we're doing this

00:02:54,810 --> 00:02:59,069
right so it's the data plane and we keep

00:02:57,299 --> 00:03:01,470
it inside the kernel we have another

00:02:59,069 --> 00:03:03,329
talk with the AF xtp and we also going

00:03:01,470 --> 00:03:06,180
to mention that which way I should put

00:03:03,329 --> 00:03:07,769
the stuff into user space and the really

00:03:06,180 --> 00:03:11,370
interesting part for us is that we are

00:03:07,769 --> 00:03:12,840
using the EP PF which makes this the

00:03:11,370 --> 00:03:14,849
early part of the networks like one-time

00:03:12,840 --> 00:03:16,409
programmable there's also the TC hook

00:03:14,849 --> 00:03:18,480
where you can do one-time programmable

00:03:16,409 --> 00:03:52,079
bility but it's really a powerful

00:03:18,480 --> 00:03:58,949
feature that we get and it's been quite

00:03:52,079 --> 00:04:01,229
a networking conferences for while I

00:03:58,949 --> 00:04:07,079
think you just have to look at idle of a

00:04:01,229 --> 00:04:08,939
store to see what I mean so we'll try to

00:04:07,079 --> 00:04:11,639
go as we go through some of these things

00:04:08,939 --> 00:04:15,720
we try to frame some of the talks that

00:04:11,639 --> 00:04:18,470
are given and we'll try to avoid taking

00:04:15,720 --> 00:04:18,470
there

00:04:19,970 --> 00:04:23,690
talks we're just trying to sort of put

00:04:21,769 --> 00:04:26,240
them into a bigger picture what's going

00:04:23,690 --> 00:04:27,590
on to be yeah so so we have seen

00:04:26,240 --> 00:04:28,610
production news cases even though we're

00:04:27,590 --> 00:04:30,680
saying this is still very active

00:04:28,610 --> 00:04:32,720
development so cloud-free I say they are

00:04:30,680 --> 00:04:35,000
using this this for that DDoS protection

00:04:32,720 --> 00:04:37,370
you have Sarika set that has plug-in

00:04:35,000 --> 00:04:39,020
spikes EP now and Facebook have been a

00:04:37,370 --> 00:04:41,120
really a tap tap test and they've

00:04:39,020 --> 00:04:43,909
actually also released a Catrin load

00:04:41,120 --> 00:04:46,610
balancer it has open source and and

00:04:43,909 --> 00:04:48,680
there's two other talks from Facebook

00:04:46,610 --> 00:04:50,240
which shows that they actually using

00:04:48,680 --> 00:04:51,919
this in real life production and they've

00:04:50,240 --> 00:04:54,500
been very active also contributing to

00:04:51,919 --> 00:04:57,110
the most active contributors to this I

00:04:54,500 --> 00:05:10,280
think in the afternoon kernels so we are

00:04:57,110 --> 00:05:12,080
very very happy to see this performance

00:05:10,280 --> 00:05:17,060
if you want to read the detailed

00:05:12,080 --> 00:05:19,520
performance but we do show we will show

00:05:17,060 --> 00:05:22,430
you two graphs which show that we have

00:05:19,520 --> 00:05:24,259
narrowed the gap to DP DK quite a bit

00:05:22,430 --> 00:05:28,669
but there's still a little bit to go

00:05:24,259 --> 00:05:30,169
with and then because HTTP has different

00:05:28,669 --> 00:05:33,020
forwarding modes for some cases we do

00:05:30,169 --> 00:05:35,840
actually have perform at the parity so

00:05:33,020 --> 00:05:37,789
this is the first one which shows your

00:05:35,840 --> 00:05:40,250
packet rock performance as a number of

00:05:37,789 --> 00:05:42,889
of CPU calls so the single core

00:05:40,250 --> 00:05:45,500
performance of HTTP for just turning a

00:05:42,889 --> 00:05:47,870
packet and dropping it immediately going

00:05:45,500 --> 00:05:56,539
on to the next one is 26 million packets

00:05:47,870 --> 00:06:01,219
per second while that sounds like a lot

00:05:56,539 --> 00:06:04,880
it's actually about 50 nanoseconds per

00:06:01,219 --> 00:06:06,620
packet and difference that's what we are

00:06:04,880 --> 00:06:08,270
missing basically and I think if you

00:06:06,620 --> 00:06:09,889
ants talk is going to be in more details

00:06:08,270 --> 00:06:14,139
about all the small optimizations we can

00:06:09,889 --> 00:06:14,139
do to really bring it up to the

00:06:22,059 --> 00:06:28,539
function call is one-and-a-half

00:06:24,189 --> 00:06:30,209
nanoseconds so it's really fast so Neil

00:06:28,539 --> 00:06:35,139
has a question

00:06:30,209 --> 00:06:37,389
this is and it's not a mistake that we

00:06:35,139 --> 00:06:39,999
have a 100 million packets per second

00:06:37,389 --> 00:06:43,149
that's active since we operating turns

00:06:39,999 --> 00:06:46,019
out that processing lots of packets per

00:06:43,149 --> 00:06:58,809
second is what's challenging so you can

00:06:46,019 --> 00:07:01,479
100 I want to also point out that like

00:06:58,809 --> 00:07:02,799
the two lower lines is Linux and that we

00:07:01,479 --> 00:07:05,169
have this default wander people come

00:07:02,799 --> 00:07:07,779
contract in this very low performance

00:07:05,169 --> 00:07:09,759
and and enter their IP the Linux roars

00:07:07,779 --> 00:07:11,709
the drop dropping packets in the IP

00:07:09,759 --> 00:07:13,239
tables wrong target I also want to

00:07:11,709 --> 00:07:14,739
highlight how well we're doing like

00:07:13,239 --> 00:07:16,929
kleinereise killing actually it's a

00:07:14,739 --> 00:07:34,689
quite quite well that we are not you're

00:07:16,929 --> 00:07:36,129
not equating in any place so this graph

00:07:34,689 --> 00:07:38,829
is interesting also because we have to

00:07:36,129 --> 00:07:41,050
the HTTP same Nick that's the HT PTX

00:07:38,829 --> 00:07:43,719
color and we are and repeat DB DK here

00:07:41,050 --> 00:07:46,300
so then we were sort of happy but we

00:07:43,719 --> 00:07:48,099
also do a less work right because well

00:07:46,300 --> 00:07:52,139
we have we're just bouncing the frame

00:07:48,099 --> 00:07:52,139
down in this driver and XA

00:07:58,489 --> 00:08:03,629
so the question was it goes down a

00:08:01,919 --> 00:08:08,549
little bit from five to six cross do we

00:08:03,629 --> 00:08:11,219
know why so to let know we actually here

00:08:08,549 --> 00:08:12,419
we are like at seventy million packets

00:08:11,219 --> 00:08:16,499
per second we are hitting some kind of

00:08:12,419 --> 00:08:34,849
PCI bandwidth limit this is your card

00:08:16,499 --> 00:08:37,439
FML x5 so this is just also to show you

00:08:34,849 --> 00:08:39,749
obviously you also see the that the

00:08:37,439 --> 00:08:41,759
absolute magnitude of the numbers is a

00:08:39,749 --> 00:08:43,529
lot lower on this one then the other one

00:08:41,759 --> 00:08:47,100
because you do more work when you send

00:08:43,529 --> 00:08:49,379
the packets back out yeah and and we do

00:08:47,100 --> 00:08:51,449
want to bring bring ectopy there's a lot

00:08:49,379 --> 00:08:53,579
of smaller summations we can still do so

00:08:51,449 --> 00:09:09,180
the lower line is HTTP redirect and we

00:08:53,579 --> 00:09:11,639
need to optimize that more but the main

00:09:09,180 --> 00:09:15,190
point is the DVD K sorry HTTP has a lot

00:09:11,639 --> 00:09:18,469
of other architectural benefits that

00:09:15,190 --> 00:09:18,469
[Music]

00:09:19,670 --> 00:09:27,269
yeah yeah so so so how do we evolve this

00:09:25,139 --> 00:09:29,279
HTTP stuff because even though it's like

00:09:27,269 --> 00:09:30,689
a disruptive and innovative technology

00:09:29,279 --> 00:09:32,309
we actually have to follow how the

00:09:30,689 --> 00:09:34,350
kernel works and how we evolve the

00:09:32,309 --> 00:09:37,680
kernel and we've done that for less to

00:09:34,350 --> 00:09:39,240
three years now I think and that's

00:09:37,680 --> 00:09:42,990
that's that's actually pretty good so we

00:09:39,240 --> 00:09:45,360
do these small improvements in every

00:09:42,990 --> 00:09:47,069
kernel release and we benefit from all

00:09:45,360 --> 00:09:49,709
the cooperation with with the community

00:09:47,069 --> 00:09:52,079
and yes you actually have to like a qy

00:09:49,709 --> 00:09:54,149
you you need when you need a new use

00:09:52,079 --> 00:09:55,709
case in a new and that's that's good

00:09:54,149 --> 00:09:56,550
because we only add two use cases that

00:09:55,709 --> 00:09:58,379
make sense

00:09:56,550 --> 00:10:01,920
that's how to take the kernel kernel

00:09:58,379 --> 00:10:04,589
evolve so now we are in a evil evolving

00:10:01,920 --> 00:10:07,110
state before the XP was like now we

00:10:04,589 --> 00:10:09,150
going to like radical I start them but

00:10:07,110 --> 00:10:18,120
now we're in a evolving stage

00:10:09,150 --> 00:10:22,380
like that and it's useful okay this is

00:10:18,120 --> 00:10:23,910
my okay yeah so so XTP is all about

00:10:22,380 --> 00:10:25,590
performance like that's the whole reason

00:10:23,910 --> 00:10:28,500
why we put it in so we actually have to

00:10:25,590 --> 00:10:29,910
be really watch out for that we don't do

00:10:28,500 --> 00:10:31,380
feature creep when you add at this

00:10:29,910 --> 00:10:34,770
different kind of features we don't kill

00:10:31,380 --> 00:10:36,810
performance so I sort of a guiding

00:10:34,770 --> 00:10:38,970
principle when we add stuff is that you

00:10:36,810 --> 00:10:41,280
must not negatively affect the baseline

00:10:38,970 --> 00:10:42,780
performance and we actually have to be

00:10:41,280 --> 00:10:44,340
very careful about that

00:10:42,780 --> 00:10:45,930
so some off the run tight some of the

00:10:44,340 --> 00:10:47,970
tricks we do is like you push one time

00:10:45,930 --> 00:10:49,920
shakes to set up time and do a lot of

00:10:47,970 --> 00:10:53,670
stuff around that so that's all the

00:10:49,920 --> 00:10:56,070
optimization techniques one issue I do

00:10:53,670 --> 00:10:58,260
see is that who's monitoring xtp

00:10:56,070 --> 00:11:02,490
performance so I want some some kernel

00:10:58,260 --> 00:11:04,980
QE CI guys to actually start testing

00:11:02,490 --> 00:11:07,530
this because the the specs for meltdown

00:11:04,980 --> 00:11:10,380
stuff it's it cost performance to go

00:11:07,530 --> 00:11:12,390
half but I didn't notice because I had I

00:11:10,380 --> 00:11:15,030
didn't good run with a new newer new

00:11:12,390 --> 00:11:16,530
enough fake a compiler so I didn't

00:11:15,030 --> 00:11:17,990
notice this performance regression I

00:11:16,530 --> 00:11:20,850
don't really have liked to someone

00:11:17,990 --> 00:11:22,560
caught on to this before and actually

00:11:20,850 --> 00:11:24,480
because it should have been quite

00:11:22,560 --> 00:11:26,510
obvious that the performance was dropped

00:11:24,480 --> 00:11:29,990
to half when you enable the spectra

00:11:26,510 --> 00:11:32,580
mitigations so I really want someone to

00:11:29,990 --> 00:11:40,790
to go into this area I'm I'm trying to

00:11:32,580 --> 00:11:40,790
get redheads CIA guys to make sure that

00:12:05,900 --> 00:12:11,880
already

00:12:08,100 --> 00:12:15,810
so we did in the in the paper one of the

00:12:11,880 --> 00:12:18,690
examples we had was IP running and David

00:12:15,810 --> 00:12:23,280
has a talk about that later

00:12:18,690 --> 00:12:26,640
yes he's the next talk so you don't have

00:12:23,280 --> 00:12:28,440
to wait but the ideas yeah well we

00:12:26,640 --> 00:12:31,020
already have to hold an ecosystem about

00:12:28,440 --> 00:12:34,260
routing in Linux we have random demons

00:12:31,020 --> 00:12:35,160
we have v we have all these kinds of

00:12:34,260 --> 00:12:36,720
blood wrapped you can do neighbor

00:12:35,160 --> 00:12:38,940
resolution and so on and there's already

00:12:36,720 --> 00:12:40,590
exists in the kernel and if you go

00:12:38,940 --> 00:12:42,150
outside the kernel and try to do user

00:12:40,590 --> 00:12:45,030
space networking you would have two

00:12:42,150 --> 00:12:47,490
green plumbing office so whereas with

00:12:45,030 --> 00:12:51,060
HTTP what you can do is you can help us

00:12:47,490 --> 00:12:53,430
that to the kernel which can be taught

00:12:51,060 --> 00:12:56,520
directly from BPF with very little

00:12:53,430 --> 00:12:58,200
overhead and get out the data from the

00:12:56,520 --> 00:13:03,350
kernel that already exists there so in

00:12:58,200 --> 00:13:03,350
the example that that we used in the

00:13:05,300 --> 00:13:10,260
packet comes in you pass the header find

00:13:08,040 --> 00:13:11,730
the destination IP throw it up to the

00:13:10,260 --> 00:13:13,260
helper and that would come back and

00:13:11,730 --> 00:13:15,450
either told you I don't know what to do

00:13:13,260 --> 00:13:17,280
with this packet I will tell you it goes

00:13:15,450 --> 00:13:19,200
up this interface and this is the next

00:13:17,280 --> 00:13:20,820
up Mac for the attacker going forward

00:13:19,200 --> 00:13:22,590
and if you know that then great you can

00:13:20,820 --> 00:13:24,630
send it out straight away with very low

00:13:22,590 --> 00:13:26,490
overhead and if you don't know that

00:13:24,630 --> 00:13:29,310
instead what you can do is to do is you

00:13:26,490 --> 00:13:31,260
can pass the HTTP pass return code which

00:13:29,310 --> 00:13:33,230
will let the packet reverse off the

00:13:31,260 --> 00:13:36,300
networking stack which will do the

00:13:33,230 --> 00:13:38,130
neighbor resolution and so on for you

00:13:36,300 --> 00:13:40,320
and then when the next packet comes in

00:13:38,130 --> 00:13:42,600
you now have connect up and you can do

00:13:40,320 --> 00:13:46,020
Fast Pass processing and this kind of

00:13:42,600 --> 00:13:49,070
integration with the kernel is one of

00:13:46,020 --> 00:13:51,120
the main selling points about to be and

00:13:49,070 --> 00:13:53,220
this is why we're starting to see the

00:13:51,120 --> 00:13:54,450
benefit of actually being integrated

00:13:53,220 --> 00:13:57,240
part of the kernel that we're starting

00:13:54,450 --> 00:13:59,910
to get these these servers yeah and

00:13:57,240 --> 00:14:01,980
these helpers can be there's not that

00:13:59,910 --> 00:14:06,840
many of them now like rhubarb is failing

00:14:01,980 --> 00:14:08,850
you and it would make a lot of sense to

00:14:06,840 --> 00:14:11,070
sort of if you think about use cases you

00:14:08,850 --> 00:14:12,780
want to do with FTP think about do I

00:14:11,070 --> 00:14:15,480
want to leverage parts with the kernel

00:14:12,780 --> 00:14:17,130
and if there's not already a helper get

00:14:15,480 --> 00:14:18,280
on the mailing list try to find someone

00:14:17,130 --> 00:14:21,820
to help you implement

00:14:18,280 --> 00:14:23,500
even implemented yourself so as long as

00:14:21,820 --> 00:14:29,590
there's a use case it's quite possible

00:14:23,500 --> 00:14:31,330
to implement I saw that we just added or

00:14:29,590 --> 00:14:37,270
applied to the subject new go up from

00:14:31,330 --> 00:14:38,920
from from XTP so yeah so so what what

00:14:37,270 --> 00:14:41,260
what we really also want to point out is

00:14:38,920 --> 00:14:45,190
that we see HDPE as a building block so

00:14:41,260 --> 00:14:46,960
it's it's a core kernel layer building

00:14:45,190 --> 00:14:48,940
block that people should start to use so

00:14:46,960 --> 00:14:51,450
other open source projects are going to

00:14:48,940 --> 00:14:53,860
build and innovate on top of this and I

00:14:51,450 --> 00:14:55,420
I'm not the guy who's saying what you

00:14:53,860 --> 00:14:58,210
cannot innovate what you can and cannot

00:14:55,420 --> 00:14:59,590
innovate so this is I'm hoping that that

00:14:58,210 --> 00:15:01,270
people will pick this stuff up and

00:14:59,590 --> 00:15:04,660
actually use it for some really cool

00:15:01,270 --> 00:15:07,270
stuff that I couldn't imagine and so

00:15:04,660 --> 00:15:08,440
that's that's sort of one of the points

00:15:07,270 --> 00:15:11,080
is that this is a core infrastructure

00:15:08,440 --> 00:15:11,500
and you're hoping to see different stuff

00:15:11,080 --> 00:15:13,180
ro

00:15:11,500 --> 00:15:15,310
so some of the directions we hope to see

00:15:13,180 --> 00:15:19,240
is that we do faster packet delivery

00:15:15,310 --> 00:15:21,790
into guests guest OS s sort of already

00:15:19,240 --> 00:15:24,040
possible today you can do a redirect

00:15:21,790 --> 00:15:26,890
into a tune tap device which goes into a

00:15:24,040 --> 00:15:29,470
read I own it I'll do faster basic keys

00:15:26,890 --> 00:15:32,470
you skip the the the network stack but

00:15:29,470 --> 00:15:35,310
there's missing some integrations to KVM

00:15:32,470 --> 00:15:38,020
and qemu and how we do that so that's

00:15:35,310 --> 00:15:39,400
some plumbing around that how we

00:15:38,020 --> 00:15:41,710
actually integrate these features happy

00:15:39,400 --> 00:15:43,870
to be choose it there's also the AF xtp

00:15:41,710 --> 00:15:45,430
approach where which offers the

00:15:43,870 --> 00:15:46,900
opportunities that we could do serial

00:15:45,430 --> 00:15:50,530
copy we're still discussing how can this

00:15:46,900 --> 00:15:52,180
be possible or not by actually getting

00:15:50,530 --> 00:15:53,920
the guests to gift some memory to the

00:15:52,180 --> 00:15:56,200
host operating system that is mapped

00:15:53,920 --> 00:15:58,120
directly into the ring so there's a lot

00:15:56,200 --> 00:16:00,430
of opportunities we hope to hope to see

00:15:58,120 --> 00:16:04,080
in the future here that's very

00:16:00,430 --> 00:16:06,190
interesting area and that's also like I

00:16:04,080 --> 00:16:08,440
think people have the wrong attitude

00:16:06,190 --> 00:16:10,360
when they are talking about p4 that know

00:16:08,440 --> 00:16:13,210
why we want to p4 in the kernel well no

00:16:10,360 --> 00:16:15,339
you actually don't you have to p4 and

00:16:13,210 --> 00:16:17,800
you compile it down to p PF and then you

00:16:15,339 --> 00:16:20,560
can load it as you just have to have a

00:16:17,800 --> 00:16:21,940
target that is p PF and then you can

00:16:20,560 --> 00:16:24,250
have another target which is your switch

00:16:21,940 --> 00:16:26,560
architecture sure you still have the

00:16:24,250 --> 00:16:29,530
same p4 program but it's a user space

00:16:26,560 --> 00:16:30,610
tuning tuning problem that we're just

00:16:29,530 --> 00:16:33,010
providing the

00:16:30,610 --> 00:16:35,470
P hook and you compile down that's

00:16:33,010 --> 00:16:37,180
actually to talk about this later which

00:16:35,470 --> 00:16:43,209
I really like the approach and there's

00:16:37,180 --> 00:16:47,529
links here in the slide people who want

00:16:43,209 --> 00:16:49,990
to use befalls also it's a way to be

00:16:47,529 --> 00:16:57,209
able to express the rules in a different

00:16:49,990 --> 00:16:59,680
language implementation specific

00:16:57,209 --> 00:17:02,709
framework of hardware on this case

00:16:59,680 --> 00:17:05,620
because we saw that's also if you go and

00:17:02,709 --> 00:17:07,150
find the github repository for the paper

00:17:05,620 --> 00:17:09,669
you have all our notes about how we

00:17:07,150 --> 00:17:11,530
actually achieve this problem so there's

00:17:09,669 --> 00:17:13,360
a lot of tuning you still need to do to

00:17:11,530 --> 00:17:15,730
get the maximum performance and nice

00:17:13,360 --> 00:17:18,339
things about higher level tools like p4

00:17:15,730 --> 00:17:20,410
or open V switch all these things that

00:17:18,339 --> 00:17:24,179
can build upon it to be is you can sort

00:17:20,410 --> 00:17:26,410
of split out the way that you you

00:17:24,179 --> 00:17:28,840
express your business rules and language

00:17:26,410 --> 00:17:30,700
and then the compiler can try to

00:17:28,840 --> 00:17:33,730
introduce another atomization

00:17:30,700 --> 00:17:36,309
for you so you don't need to have the

00:17:33,730 --> 00:17:40,390
very deep technical knowledge about the

00:17:36,309 --> 00:17:48,100
exact optimization to do so HTTP is

00:17:40,390 --> 00:17:49,630
definitely something that yeah and then

00:17:48,100 --> 00:17:52,240
we have something quite interesting

00:17:49,630 --> 00:17:55,780
which is also a talk that I'm doing very

00:17:52,240 --> 00:17:58,110
much forward to yeah so so this is the

00:17:55,780 --> 00:18:02,290
AF HTTP and zero copy into user space

00:17:58,110 --> 00:18:04,540
sort of course a little bit against the

00:18:02,290 --> 00:18:06,280
the model of what x2p was because before

00:18:04,540 --> 00:18:08,440
I said HDPE is like at the internal

00:18:06,280 --> 00:18:11,350
stuff keep the packet in the kernel but

00:18:08,440 --> 00:18:15,970
now with AF xtp we can we can deliver

00:18:11,350 --> 00:18:18,610
raw packets into user space and to start

00:18:15,970 --> 00:18:20,650
with I think the AF HDPE stuffers

00:18:18,610 --> 00:18:24,070
express us like they wanted to hook into

00:18:20,650 --> 00:18:27,070
TCP dump but it's it's very unlike TCP

00:18:24,070 --> 00:18:28,960
dump because its own some sort of steals

00:18:27,070 --> 00:18:30,730
of packets instead of TCP don't take a

00:18:28,960 --> 00:18:32,950
copy and you will lose a lot of

00:18:30,730 --> 00:18:36,030
performance by hooking into this so we

00:18:32,950 --> 00:18:39,490
ended up or beyond ended up and

00:18:36,030 --> 00:18:42,280
implementing this as XP hook because we

00:18:39,490 --> 00:18:43,960
provide some flexibility and that's one

00:18:42,280 --> 00:18:44,620
of the one of the key features are like

00:18:43,960 --> 00:18:46,840
with the extra peat

00:18:44,620 --> 00:18:49,059
which don't steal the entire neck that

00:18:46,840 --> 00:18:51,250
de sÃ³ller have this flexibility so now

00:18:49,059 --> 00:18:54,100
we actually have you can have packet

00:18:51,250 --> 00:18:56,140
filtering to avoid these cases where

00:18:54,100 --> 00:18:57,760
you'd have Colonel bypass solutions that

00:18:56,140 --> 00:18:59,789
want to reject the good packets into the

00:18:57,760 --> 00:19:03,809
colonel instead you can filled out

00:18:59,789 --> 00:19:06,370
earlier on how you want to do this and

00:19:03,809 --> 00:19:09,730
the other advantage is all the drivers

00:19:06,370 --> 00:19:11,950
tests that implement HTTP redirect will

00:19:09,730 --> 00:19:13,179
actually automatically get sort of the

00:19:11,950 --> 00:19:16,390
fallback mode of this they just

00:19:13,179 --> 00:19:20,559
supported out out of the box by a single

00:19:16,390 --> 00:19:22,690
copy in some core code so if you want AF

00:19:20,559 --> 00:19:25,720
XTP we are seeing some some arm cast at

00:19:22,690 --> 00:19:27,669
once to have this and and the copy mode

00:19:25,720 --> 00:19:29,770
is okay for them so they just want to

00:19:27,669 --> 00:19:31,450
implement all of a sudden of these small

00:19:29,770 --> 00:19:33,520
arm boards want to implement

00:19:31,450 --> 00:19:37,870
HTP redirects to get get these features

00:19:33,520 --> 00:19:39,399
out there sort of interesting so so we

00:19:37,870 --> 00:19:41,049
have a full talk about this but some of

00:19:39,399 --> 00:19:42,730
the performance tricks is I mentioned a

00:19:41,049 --> 00:19:44,850
little bit that user space allocates a

00:19:42,730 --> 00:19:47,440
memory and give it to the kernel and

00:19:44,850 --> 00:19:49,210
another thing I really liked about this

00:19:47,440 --> 00:19:50,980
is that sort of this is sort of the

00:19:49,210 --> 00:19:53,279
event occurs from snit channels with a

00:19:50,980 --> 00:19:55,720
single producer single consumer model

00:19:53,279 --> 00:19:57,399
that that we actually have half in the

00:19:55,720 --> 00:20:29,110
kernel now this is more how many years

00:19:57,399 --> 00:20:31,630
take this off the crazy ideas I have

00:20:29,110 --> 00:20:40,539
what much more quick ideas so just to

00:20:31,630 --> 00:20:43,330
Lincoln so one of my so no no long-term

00:20:40,539 --> 00:20:45,399
ideas or goals this actually to remove

00:20:43,330 --> 00:20:48,100
the Skippy allocations completely from

00:20:45,399 --> 00:20:51,220
the drivers so this is like very

00:20:48,100 --> 00:20:52,419
long-term goal but we we can solve

00:20:51,220 --> 00:20:54,580
actually do it today

00:20:52,419 --> 00:20:58,190
we already implemented it that you can

00:20:54,580 --> 00:21:00,470
redirect these raw frames either into a

00:20:58,190 --> 00:21:02,360
you map so the allocation happens is

00:21:00,470 --> 00:21:06,110
kapiel cases happen on a remote CPU or

00:21:02,360 --> 00:21:07,759
inserted to that driver which which

00:21:06,110 --> 00:21:09,529
caused the sqp allocation to happen data

00:21:07,759 --> 00:21:13,129
if if it happens to see that it has to

00:21:09,529 --> 00:21:17,059
be has to do is keep your location so

00:21:13,129 --> 00:21:24,320
that's that's really sort of a long

00:21:17,059 --> 00:21:26,629
long-term goal and but it does work now

00:21:24,320 --> 00:21:28,190
but we are missing some of the driver or

00:21:26,629 --> 00:21:31,669
floats which are fairly important

00:21:28,190 --> 00:21:33,169
especially to check some info and also

00:21:31,669 --> 00:21:35,570
the receive hash we also need to

00:21:33,169 --> 00:21:38,480
transfer that we all of these also dahab

00:21:35,570 --> 00:21:40,940
remark if I have patches out there which

00:21:38,480 --> 00:21:43,009
as you does it but take it take out

00:21:40,940 --> 00:21:45,080
shutdown with good reason because we

00:21:43,009 --> 00:21:47,179
want to actually be able to express this

00:21:45,080 --> 00:21:50,120
in a more vendor mutual way in a more

00:21:47,179 --> 00:21:52,370
dynamic way and and I'm really looking

00:21:50,120 --> 00:21:54,350
forward for us to actually come up with

00:21:52,370 --> 00:21:56,059
a solution and and see it

00:21:54,350 --> 00:21:58,039
Sayyid also had a solution we also got

00:21:56,059 --> 00:22:01,429
shut down for this but I'm really hoping

00:21:58,039 --> 00:22:03,049
that we can find a winter neutral way to

00:22:01,429 --> 00:22:07,610
express to us and that's really high

00:22:03,049 --> 00:22:10,100
hopes for the btf the PPF type format

00:22:07,610 --> 00:22:12,019
and how to we can define a metre to HS

00:22:10,100 --> 00:22:14,509
structure around this and there's also

00:22:12,019 --> 00:22:17,750
talk about this later where they're

00:22:14,509 --> 00:22:21,230
going to investigate and some of the the

00:22:17,750 --> 00:22:24,649
possibilities in this area so I'm

00:22:21,230 --> 00:22:27,289
stalling a little bit on on some of the

00:22:24,649 --> 00:22:28,610
offload parts so it's going to be really

00:22:27,289 --> 00:22:42,350
interesting to see what's happening in

00:22:28,610 --> 00:22:47,240
this space a strange way that because

00:22:42,350 --> 00:22:50,059
when you need to do TX for an XP frame

00:22:47,240 --> 00:22:53,240
out of an interface you need to allocate

00:22:50,059 --> 00:22:55,399
certain hardware resources to that

00:22:53,240 --> 00:22:59,720
particular thing and the way it's done

00:22:55,399 --> 00:23:03,290
now is that drivers will allocate 1 th

00:22:59,720 --> 00:23:05,420
cube per CPU core to just to do it

00:23:03,290 --> 00:23:06,560
stuff which are they're not useful for

00:23:05,420 --> 00:23:07,940
anything else and of course this becomes

00:23:06,560 --> 00:23:10,700
a problem if you have a hundreds of

00:23:07,940 --> 00:23:13,240
yukos you may get to the point where you

00:23:10,700 --> 00:23:17,030
can't actually use FTTP

00:23:13,240 --> 00:23:20,510
at all because there's not enough

00:23:17,030 --> 00:23:22,040
received GHQ is unhappy and also this

00:23:20,510 --> 00:23:26,090
takes up a lot of resources so by

00:23:22,040 --> 00:23:27,710
default when you just turn on HTTP all

00:23:26,090 --> 00:23:32,030
right when you when you just turn on the

00:23:27,710 --> 00:23:33,890
hardware it's not being allocated and so

00:23:32,030 --> 00:23:36,040
we need a way to actually tell the

00:23:33,890 --> 00:23:38,900
hardware ok we're going to do HTTP

00:23:36,040 --> 00:23:40,640
transmit out of this interface and we

00:23:38,900 --> 00:23:43,730
don't have that currently so the current

00:23:40,640 --> 00:23:46,930
hack that's employed is when you attach

00:23:43,730 --> 00:23:49,730
an HTTP program to an interface on

00:23:46,930 --> 00:23:52,250
Eric's two-part process packets on Eric

00:23:49,730 --> 00:23:55,640
we also allocate all the resources for

00:23:52,250 --> 00:23:57,350
tiems even if this device only needs to

00:23:55,640 --> 00:24:01,400
process incoming traffic and never needs

00:23:57,350 --> 00:24:02,960
to teach anything else so that means

00:24:01,400 --> 00:24:04,490
that if you have the the case where you

00:24:02,960 --> 00:24:07,820
have too many CPU close be networking

00:24:04,490 --> 00:24:09,080
Hardware you can't perceive HTTP you

00:24:07,820 --> 00:24:11,180
can't run into the PM receive in this

00:24:09,080 --> 00:24:14,780
interface either and it also means that

00:24:11,180 --> 00:24:18,520
if you're doing redirect between two

00:24:14,780 --> 00:24:20,960
interfaces you need to load a dummy

00:24:18,520 --> 00:24:22,700
HTTP program on the interface that

00:24:20,960 --> 00:24:26,420
you're sending packets out of which has

00:24:22,700 --> 00:24:28,970
some it's not a very good UI and also

00:24:26,420 --> 00:24:30,470
you miss crashing the kernel when you

00:24:28,970 --> 00:24:32,150
when you receive this so that's there's

00:24:30,470 --> 00:24:34,910
some work to be done here to make this

00:24:32,150 --> 00:24:36,680
experience a lot better and our thought

00:24:34,910 --> 00:24:39,170
is that what you could do is you can

00:24:36,680 --> 00:24:44,360
have an H+ in API inside the kernel that

00:24:39,170 --> 00:24:46,070
tells the the egress driver - ok we're

00:24:44,360 --> 00:24:48,680
actually going to transmit stuff out of

00:24:46,070 --> 00:24:51,410
your hardware now please allocate some

00:24:48,680 --> 00:24:53,990
resources and so the natural way to do

00:24:51,410 --> 00:24:55,370
this is we have this Twitter where when

00:24:53,990 --> 00:24:57,620
you read a write package you can do it

00:24:55,370 --> 00:25:03,200
through a BPF map where you set up a map

00:24:57,620 --> 00:25:06,920
with the I face IDs of the of the egress

00:25:03,200 --> 00:25:08,690
interfaces and then you can just mind to

00:25:06,920 --> 00:25:10,790
that map internally because that's a

00:25:08,690 --> 00:25:12,740
special map type so you treat when an

00:25:10,790 --> 00:25:13,760
interface is added to this map you can

00:25:12,740 --> 00:25:16,310
just allocate the resource

00:25:13,760 --> 00:25:18,050
on this interface that's like pretty

00:25:16,310 --> 00:25:20,360
natural way to do it but the problem is

00:25:18,050 --> 00:25:22,760
that there's also a redirect variant

00:25:20,360 --> 00:25:27,170
where we don't use a map we just pass

00:25:22,760 --> 00:25:28,490
the interface ID as a permanent call so

00:25:27,170 --> 00:25:32,990
we have to figure out how we can handle

00:25:28,490 --> 00:25:40,040
this yeah so let's then we haven't

00:25:32,990 --> 00:25:57,620
really solved that what you're saying

00:25:40,040 --> 00:26:00,800
dropping which I don't like like I don't

00:25:57,620 --> 00:26:02,780
know sure if we can can remove a help

00:26:00,800 --> 00:26:05,630
again that's not really possible I think

00:26:02,780 --> 00:26:07,490
because it's helped us are like a gnome

00:26:05,630 --> 00:26:09,140
that is incremented I guess we have to

00:26:07,490 --> 00:26:12,140
like I think that's very controversial

00:26:09,140 --> 00:26:14,990
to remove remove it again but but I'm

00:26:12,140 --> 00:26:16,820
I'm like constantly having this this

00:26:14,990 --> 00:26:18,770
with on the mailing list I'm quite

00:26:16,820 --> 00:26:20,870
annoyed that they give me edit this this

00:26:18,770 --> 00:26:22,220
non-marriage a rake because all of the

00:26:20,870 --> 00:26:24,230
time on the mailing yes I have to tell

00:26:22,220 --> 00:26:26,240
people no don't use that we use the map

00:26:24,230 --> 00:26:29,650
reader rake it has the Tabu performance

00:26:26,240 --> 00:26:29,650
don't use this come on

00:26:31,150 --> 00:26:35,990
if we don't figure out a way to express

00:26:33,560 --> 00:26:37,850
the non map redirect in terms of map

00:26:35,990 --> 00:26:39,640
reader way by having some kind of hidden

00:26:37,850 --> 00:26:47,360
map hidden away somewhere

00:26:39,640 --> 00:26:50,350
extra special memory consider just

00:26:47,360 --> 00:26:57,380
having a default map which will

00:26:50,350 --> 00:27:02,630
automatically get created once but but

00:26:57,380 --> 00:27:04,370
so it's it's we we put a lot of energy

00:27:02,630 --> 00:27:07,280
into the dev map to make sure that I'm

00:27:04,370 --> 00:27:09,230
taking down and adding a disability to

00:27:07,280 --> 00:27:11,120
adding or removing stuff from the dev

00:27:09,230 --> 00:27:12,800
map it actually has has a lot of

00:27:11,120 --> 00:27:15,260
synchronization points because we are

00:27:12,800 --> 00:27:16,880
moving a lot of the checks to set up

00:27:15,260 --> 00:27:18,800
time instead of run time that's why we

00:27:16,880 --> 00:27:21,440
get some of the performance from so ruby

00:27:18,800 --> 00:27:22,730
actually had to do runtime we get a

00:27:21,440 --> 00:27:24,710
packet and all of sudden we create an

00:27:22,730 --> 00:27:27,320
entry in the map because the creating

00:27:24,710 --> 00:27:31,490
entry is fairly expensive and

00:27:27,320 --> 00:27:36,650
depending on going through the read copy

00:27:31,490 --> 00:27:39,200
update the asks you scheduling because

00:27:36,650 --> 00:27:43,700
we have to make sure that the memory

00:27:39,200 --> 00:27:46,250
resources are available right so another

00:27:43,700 --> 00:27:49,460
thing that is a bit of a challenge

00:27:46,250 --> 00:27:53,750
especially from also a UI perspective is

00:27:49,460 --> 00:27:56,450
that you can't know what subset of the

00:27:53,750 --> 00:27:58,340
HTTP features that are given driver

00:27:56,450 --> 00:28:01,000
supports so you can you can implement

00:27:58,340 --> 00:28:04,280
xtv support in a driver that only does

00:28:01,000 --> 00:28:06,740
drop-in CX example and not redirect but

00:28:04,280 --> 00:28:08,510
when you load an EPA program that then

00:28:06,740 --> 00:28:09,080
tries to read I write out this interface

00:28:08,510 --> 00:28:12,370
anyway

00:28:09,080 --> 00:28:14,990
the patch to do silently dropped

00:28:12,370 --> 00:28:16,490
completely scientist has a trace point

00:28:14,990 --> 00:28:23,810
you can hook into but but people know

00:28:16,490 --> 00:28:25,640
that this package just gone and and

00:28:23,810 --> 00:28:27,890
because this is a CPA will work before

00:28:25,640 --> 00:28:34,740
TCP dump that's like no way of debugging

00:28:27,890 --> 00:28:37,060
this so for example you have the ricotta

00:28:34,740 --> 00:28:41,080
[Music]

00:28:37,060 --> 00:28:44,270
using this I want to have a fallback so

00:28:41,080 --> 00:28:45,680
you can try could be direct but you

00:28:44,270 --> 00:28:49,340
can't really know if it work so it would

00:28:45,680 --> 00:28:52,940
be good for applications like this to

00:28:49,340 --> 00:28:58,340
have a way to either query feature bits

00:28:52,940 --> 00:29:00,140
which to express this program needs

00:28:58,340 --> 00:29:03,080
these particular features please reject

00:29:00,140 --> 00:29:04,940
it if it doesn't work so that you can

00:29:03,080 --> 00:29:06,830
okay you can try it and if it doesn't

00:29:04,940 --> 00:29:09,260
work and fall back to like a TC based

00:29:06,830 --> 00:29:10,550
solution or whatever this wants to for

00:29:09,260 --> 00:29:12,620
you stress yeah

00:29:10,550 --> 00:29:15,620
so that's that's why we want to be able

00:29:12,620 --> 00:29:17,090
to quiet it whether how we we express

00:29:15,620 --> 00:29:19,160
this now we solve it it's a little bit

00:29:17,090 --> 00:29:20,660
spin up several times on the mailing

00:29:19,160 --> 00:29:25,880
list and we're not quite sure how to

00:29:20,660 --> 00:29:27,590
express this is that from the beginning

00:29:25,880 --> 00:29:30,520
the goal has always been we want to

00:29:27,590 --> 00:29:37,550
support all features in all drivers

00:29:30,520 --> 00:29:39,890
now it's n years and okay so the reason

00:29:37,550 --> 00:29:40,220
we bring in an IPS also just to say is

00:29:39,890 --> 00:29:42,919
this

00:29:40,220 --> 00:29:44,780
a realistic goal should we try it should

00:29:42,919 --> 00:29:47,120
be cheap going to watch vs. should

00:29:44,780 --> 00:29:56,679
actually try to do some way for use of

00:29:47,120 --> 00:29:56,679
space to do discovery what too much

00:29:57,370 --> 00:30:04,520
we're happy to have someday we don't

00:30:02,059 --> 00:30:06,559
we're not hardcore about enforcing full

00:30:04,520 --> 00:30:08,299
trying to say yeah

00:30:06,559 --> 00:30:10,730
however sometimes people say I'm gonna

00:30:08,299 --> 00:30:13,250
do it I'm gonna do it that's okay and

00:30:10,730 --> 00:30:17,000
then that never comes to pass yes that

00:30:13,250 --> 00:30:20,990
is also a way to to fix it

00:30:17,000 --> 00:30:22,549
yeah and the way to look at this is for

00:30:20,990 --> 00:30:24,289
features that aren't supported should we

00:30:22,549 --> 00:30:26,150
have a slow path available that somehow

00:30:24,289 --> 00:30:28,039
kicks in when the driver doesn't fully

00:30:26,150 --> 00:30:29,950
support a particular feature and how

00:30:28,039 --> 00:30:33,020
feasible is that to begin with

00:30:29,950 --> 00:30:35,690
yes yeah does that's there's difficult

00:30:33,020 --> 00:30:36,890
to to have a fallback because some

00:30:35,690 --> 00:30:42,070
actually have to have an boundaries a

00:30:36,890 --> 00:30:42,070
driver and how does that work out

00:30:59,100 --> 00:31:05,220
so we have this today with the native

00:31:01,930 --> 00:31:09,010
mode versus skb mode I stopped here so

00:31:05,220 --> 00:31:10,840
there's a little bit I mean as you know

00:31:09,010 --> 00:31:11,950
as someone who has some responsibility

00:31:10,840 --> 00:31:14,500
for a driver that currently doesn't

00:31:11,950 --> 00:31:15,820
support redirect in the tree right we

00:31:14,500 --> 00:31:17,230
can we can still use it it's still

00:31:15,820 --> 00:31:19,600
usable just the performance isn't as

00:31:17,230 --> 00:31:21,430
good yeah actually with redirect we have

00:31:19,600 --> 00:31:22,780
a problem because it's not really some

00:31:21,430 --> 00:31:25,630
of the redirects are not supported in

00:31:22,780 --> 00:31:29,380
the generic XTP which sort of this is a

00:31:25,630 --> 00:31:31,060
fallback okay and that people also got

00:31:29,380 --> 00:31:33,490
surprised by that they wanted like I

00:31:31,060 --> 00:31:36,100
have to fix that it's my fault so like

00:31:33,490 --> 00:31:38,440
the system app redirects that it doesn't

00:31:36,100 --> 00:31:40,950
support the duration - if you do generic

00:31:38,440 --> 00:31:44,320
mode but the place you're sending to has

00:31:40,950 --> 00:31:46,840
support for Ti anyways yeah that's not

00:31:44,320 --> 00:31:50,640
that's a lot of fun with the generic

00:31:46,840 --> 00:31:50,640
mode that doesn't work exactly like me

00:31:54,740 --> 00:31:57,809
[Music]

00:31:57,870 --> 00:32:04,230
that's also fairly controversial idea I

00:32:00,490 --> 00:32:07,800
guess we'll see how actually came from

00:32:04,230 --> 00:32:12,120
we don't know if it's going to succeed

00:32:07,800 --> 00:32:15,040
problem so this can happen if the driver

00:32:12,120 --> 00:32:16,810
does not support me the red you get just

00:32:15,040 --> 00:32:19,480
drop packets but it also happens if the

00:32:16,810 --> 00:32:21,160
egress interface th when you spawn you

00:32:19,480 --> 00:32:22,780
also get the same okay the the

00:32:21,160 --> 00:32:25,660
rearranges doesn't succeed and you can't

00:32:22,780 --> 00:32:28,690
detect that from the incoming BBS

00:32:25,660 --> 00:32:30,960
program except for banking and trades

00:32:28,690 --> 00:32:35,770
points and so on and this is especially

00:32:30,960 --> 00:32:38,110
problematic if you have a fast to slow

00:32:35,770 --> 00:32:41,290
device like if you're trying to get a

00:32:38,110 --> 00:32:43,210
100 gigabit into device redirecting in

00:32:41,290 --> 00:32:46,000
to attend to your bit device you're

00:32:43,210 --> 00:32:47,710
going to have a bad time like that's you

00:32:46,000 --> 00:32:51,550
technically get an ATM but it's not a

00:32:47,710 --> 00:32:53,350
very good one so some way of detecting

00:32:51,550 --> 00:32:55,660
us in some way of doing - nothing and

00:32:53,350 --> 00:32:57,850
then we we came up with the idea of why

00:32:55,660 --> 00:32:59,740
don't we do this as an egoistic so that

00:32:57,850 --> 00:33:03,910
we are another place where you could run

00:32:59,740 --> 00:33:06,020
BBF code on egress from an interface

00:33:03,910 --> 00:33:09,559
just before the packets of contains

00:33:06,020 --> 00:33:13,130
but surgery if we do this we should have

00:33:09,559 --> 00:33:15,170
the current status of the TX the chick

00:33:13,130 --> 00:33:17,470
ring from hardware you can have that as

00:33:15,170 --> 00:33:20,390
the metadata field that BPM can react to

00:33:17,470 --> 00:33:25,280
and then through maps or some other

00:33:20,390 --> 00:33:27,080
mechanism you to signal the rx HTTP

00:33:25,280 --> 00:33:28,670
program to back offs and Patricks

00:33:27,080 --> 00:33:31,190
another way for some things you could

00:33:28,670 --> 00:33:33,850
also actually use this to implement QoS

00:33:31,190 --> 00:33:39,140
some kind of thing Poly's put policing

00:33:33,850 --> 00:33:41,330
hom something and it would also allow us

00:33:39,140 --> 00:33:50,210
somewhere to run vpf programs after the

00:33:41,330 --> 00:33:52,880
coup - yeah that's quite a lot different

00:33:50,210 --> 00:33:54,770
like use cases that we could use it for

00:33:52,880 --> 00:33:57,260
and this would be the most generic way

00:33:54,770 --> 00:34:00,230
to express it with have another thing

00:33:57,260 --> 00:34:02,030
like HTTP like hook maybe - if you can

00:34:00,230 --> 00:34:05,420
keep the program try it maybe it will be

00:34:02,030 --> 00:34:08,210
difficult but it would be preferable and

00:34:05,420 --> 00:34:10,909
and yeah so you as you say that's this

00:34:08,210 --> 00:34:12,919
quite a lot of interesting use cases

00:34:10,909 --> 00:34:25,580
around this but there's also a lot of

00:34:12,919 --> 00:34:28,190
openings okay so what about adding the

00:34:25,580 --> 00:34:39,530
ability for the DPF program that runs

00:34:28,190 --> 00:34:43,040
the checks to also do things then we

00:34:39,530 --> 00:34:44,359
really took over yeah exactly but yeah

00:34:43,040 --> 00:34:46,040
so that's that's one of the do really

00:34:44,359 --> 00:34:47,450
crazy ideas how how we actually limit

00:34:46,040 --> 00:34:49,790
this stuff but it could be quite

00:34:47,450 --> 00:34:51,230
interesting to before actually just

00:34:49,790 --> 00:34:53,270
reporting the packet was struck but

00:34:51,230 --> 00:34:54,560
actually saying well the packet we know

00:34:53,270 --> 00:34:56,890
the pack is going to be dropped but

00:34:54,560 --> 00:35:00,140
let's take a new retail rejection

00:34:56,890 --> 00:35:02,570
rhetoric now to another interface so

00:35:00,140 --> 00:35:05,570
there's a lot of possibilities or saying

00:35:02,570 --> 00:35:07,250
back we could reply back to that

00:35:05,570 --> 00:35:09,170
truncate the package so it's not so big

00:35:07,250 --> 00:35:15,260
and send it back to the to the to the

00:35:09,170 --> 00:35:17,270
sender and say this is some memory int

00:35:15,260 --> 00:35:19,369
and make stuff I think we're going to

00:35:17,270 --> 00:35:21,499
talk pretty fast about this

00:35:19,369 --> 00:35:26,599
descoteaux we don't have that much time

00:35:21,499 --> 00:35:30,200
so we recently added some summary models

00:35:26,599 --> 00:35:33,380
per receive queuing for the drivers this

00:35:30,200 --> 00:35:35,329
did acts a lot of flexibility and will

00:35:33,380 --> 00:35:40,160
make us able to sort of innovate in this

00:35:35,329 --> 00:35:42,289
area but we also want to take this

00:35:40,160 --> 00:35:44,299
opportunity and make and try to make

00:35:42,289 --> 00:35:46,130
some shared cope change drivers for how

00:35:44,299 --> 00:35:50,089
to do the memory allocation on receive

00:35:46,130 --> 00:35:52,880
and how these pages get cycled back so

00:35:50,089 --> 00:35:55,849
so I'm going to work together with which

00:35:52,880 --> 00:35:57,559
it's Mellanox and Eric and and and some

00:35:55,849 --> 00:35:59,809
of the dinero guys actually they also

00:35:57,559 --> 00:36:02,720
want to make this work on arm so we are

00:35:59,809 --> 00:36:05,119
going to see if we can generalize in

00:36:02,720 --> 00:36:08,180
occasion API that that the drivers could

00:36:05,119 --> 00:36:11,410
use for this to make it easier to to

00:36:08,180 --> 00:36:15,109
implement some education API for

00:36:11,410 --> 00:36:16,609
photographer code I'll stop your

00:36:15,109 --> 00:36:18,529
planning is that we want to extend the

00:36:16,609 --> 00:36:21,410
return frame Empire to do parking that's

00:36:18,529 --> 00:36:24,589
sort of obvious and then the other thing

00:36:21,410 --> 00:36:26,480
is to keep these pages DMA map which is

00:36:24,589 --> 00:36:31,730
also will be interesting to do some work

00:36:26,480 --> 00:36:35,180
on the arm to see how much matters there

00:36:31,730 --> 00:36:36,499
so the TM a mapping keeping those pages

00:36:35,180 --> 00:36:38,509
math has not yet gotten a lot of

00:36:36,499 --> 00:36:41,390
attention because it's really fast on

00:36:38,509 --> 00:36:42,920
insula CPUs so we have optimized a lot

00:36:41,390 --> 00:36:45,710
for Insel CPUs and all of a sudden this

00:36:42,920 --> 00:36:50,950
speculation to came and and all of the

00:36:45,710 --> 00:36:50,950
DMA calls just got really expensive so

00:37:08,739 --> 00:37:15,519
so there's a lot of talks

00:37:20,630 --> 00:37:28,070
go see those as well and then some of

00:37:24,530 --> 00:37:29,570
the directions some of the ideas we have

00:37:28,070 --> 00:37:31,700
for future directions for it to be

00:37:29,570 --> 00:37:35,180
moving their communication out the

00:37:31,700 --> 00:37:40,310
drivers resource allocation for the th

00:37:35,180 --> 00:37:41,810
part of HTTP HTTP feature discovery or

00:37:40,310 --> 00:37:45,590
some other mechanism to make sure that

00:37:41,810 --> 00:37:48,590
it always works and it was hook for HTTP

00:37:45,590 --> 00:37:53,570
and improving memory models and DMA

00:37:48,590 --> 00:37:55,490
mapping across the board yeah

00:37:53,570 --> 00:37:57,860
and that's that sort of it and we all

00:37:55,490 --> 00:37:59,480
sort of obvious that this many talk that

00:37:57,860 --> 00:38:02,060
there's a lot of contributors in this

00:37:59,480 --> 00:38:04,310
and add also in this room so we want to

00:38:02,060 --> 00:38:06,080
thank all of the contributors for this

00:38:04,310 --> 00:38:11,290
this is actually a combined effort of a

00:38:06,080 --> 00:38:11,290
lot of people so so thank you

00:38:15,750 --> 00:38:19,650
we have a couple minutes for questions

00:38:18,030 --> 00:38:27,840
anyone have any questions for aspirins

00:38:19,650 --> 00:38:31,980
okay so regarding the ATX location issue

00:38:27,840 --> 00:38:37,770
have you thought about allocating the

00:38:31,980 --> 00:38:40,340
dev map at a verification time yeah the

00:38:37,770 --> 00:38:43,670
problem is you can change the dev map

00:38:40,340 --> 00:38:48,080
from user space

00:38:43,670 --> 00:38:52,580
well idea will be adding let's say

00:38:48,080 --> 00:38:55,560
somewhat well-known the death bad name

00:38:52,580 --> 00:38:59,970
which user space should not use by

00:38:55,560 --> 00:39:05,700
default and looking up devices in that

00:38:59,970 --> 00:39:16,500
map but redirect time if you do not do

00:39:05,700 --> 00:39:19,500
not find the look at it so the idea is

00:39:16,500 --> 00:39:22,349
we create us we always create a map a

00:39:19,500 --> 00:39:24,990
tiff map type which is empty and then we

00:39:22,349 --> 00:39:27,660
say the user interfaces that if you

00:39:24,990 --> 00:39:28,950
wanted to redirect it just basic doesn't

00:39:27,660 --> 00:39:31,109
work to start with but you have to have

00:39:28,950 --> 00:39:33,750
this remember to take this map which

00:39:31,109 --> 00:39:36,270
with this name and it's always allocated

00:39:33,750 --> 00:39:37,440
you have to insert the die if in takes

00:39:36,270 --> 00:39:41,040
us into this that's what you're

00:39:37,440 --> 00:39:45,380
proposing yeah the could be created by

00:39:41,040 --> 00:39:50,240
the verifier is it fine that the EPA

00:39:45,380 --> 00:39:55,020
director is used by the program only oh

00:39:50,240 --> 00:39:57,089
oh okay so so we do our wait the way I

00:39:55,020 --> 00:40:00,330
understand it is you wait to create this

00:39:57,089 --> 00:40:02,040
this special map until the first program

00:40:00,330 --> 00:40:04,490
that gets loaded and it runs through the

00:40:02,040 --> 00:40:07,770
verifier and where if I say this is a

00:40:04,490 --> 00:40:16,349
HTTP redirect without a map but now okay

00:40:07,770 --> 00:40:17,640
I'm going to create a map yeah that I

00:40:16,349 --> 00:40:22,170
think that would actually work then we

00:40:17,640 --> 00:40:25,580
went to prepare at BPF loads Cisco time

00:40:22,170 --> 00:40:25,580
we create the map and then

00:40:26,060 --> 00:40:31,610
how do we reference the map we can't

00:40:29,270 --> 00:40:32,990
reference the map from from the the elf

00:40:31,610 --> 00:40:34,970
code but that should be okay

00:40:32,990 --> 00:40:51,500
we can still have user space pick it up

00:40:34,970 --> 00:40:54,050
afterwards is actually good and then

00:40:51,500 --> 00:40:56,180
yeah we as there's no API for it now we

00:40:54,050 --> 00:40:58,790
could define this API the people will

00:40:56,180 --> 00:41:00,840
have to populate this I don't know

00:40:58,790 --> 00:41:05,380
Daniel is like doesn't look too happy

00:41:00,840 --> 00:41:07,730
[Laughter]

00:41:05,380 --> 00:41:10,850
that's definitely an interesting idea

00:41:07,730 --> 00:41:18,730
okay thank you for that anyone else have

00:41:10,850 --> 00:41:22,190
a couple minutes I saw is there any

00:41:18,730 --> 00:41:26,480
motivation for trying to stack like

00:41:22,190 --> 00:41:28,970
multiple X TV programs just one user

00:41:26,480 --> 00:41:32,420
space to do the job combine them

00:41:28,970 --> 00:41:36,020
together in the next talk talk hang up I

00:41:32,420 --> 00:41:37,970
think David is going to talk about that

00:41:36,020 --> 00:41:40,340
it that we don't want to stack several

00:41:37,970 --> 00:41:42,140
HTTP programs on top of each other for

00:41:40,340 --> 00:41:44,390
performance reasons and we want to

00:41:42,140 --> 00:41:46,640
figure out a way that the the initial

00:41:44,390 --> 00:41:48,710
xtp program actually have have the

00:41:46,640 --> 00:41:51,530
information of for example stack net

00:41:48,710 --> 00:41:54,800
devices and VLAN and bonding and how he

00:41:51,530 --> 00:41:56,810
tries to solve this as continuing thread

00:41:54,800 --> 00:41:59,330
in all this is that the real power of

00:41:56,810 --> 00:42:00,710
having evpi programs do packet

00:41:59,330 --> 00:42:01,970
processing is that we can look at all

00:42:00,710 --> 00:42:04,460
the things you're trying to do and

00:42:01,970 --> 00:42:05,990
optimize and consolidate them into the

00:42:04,460 --> 00:42:08,120
most minimal set of instructions that

00:42:05,990 --> 00:42:10,310
will implement the policy or framework

00:42:08,120 --> 00:42:12,710
that you're trying to do and stacking

00:42:10,310 --> 00:42:15,080
and having layers and multiple programs

00:42:12,710 --> 00:42:16,850
running runs kind of away from that kind

00:42:15,080 --> 00:42:18,680
of goal those that sort of goals that we

00:42:16,850 --> 00:42:20,960
have so that's this also goes back to

00:42:18,680 --> 00:42:22,100
the point we had when we had new videos

00:42:20,960 --> 00:42:27,530
we have to make sure we don't kill

00:42:22,100 --> 00:42:28,940
performance exactly it would be a lot

00:42:27,530 --> 00:42:31,370
easier just to have it on every stack

00:42:28,940 --> 00:42:33,320
device for a hab running pph to people

00:42:31,370 --> 00:42:35,210
gram but it will actually it will hurt

00:42:33,320 --> 00:42:37,730
performance so we actually want to spend

00:42:35,210 --> 00:42:38,990
some like prettier ethically brainpower

00:42:37,730 --> 00:42:41,450
on how generates down

00:42:38,990 --> 00:42:43,730
to the existing network yes that's

00:42:41,450 --> 00:42:44,450
exactly exactly it city logical

00:42:43,730 --> 00:42:46,130
conclusion

00:42:44,450 --> 00:42:47,810
yeah and that's that's why I really want

00:42:46,130 --> 00:42:50,390
to put some brainpower into figuring out

00:42:47,810 --> 00:42:52,790
cat how can we solve this in another way

00:42:50,390 --> 00:42:55,250
that doesn't just decree it down to the

00:42:52,790 --> 00:42:56,840
same performance okay

00:42:55,250 --> 00:42:58,490
thank you very much thank you for your

00:42:56,840 --> 00:43:02,110
presentation and we'll get ready for

00:42:58,490 --> 00:43:02,110
David Ahern who's coming up next

00:43:03,500 --> 00:43:08,539

YouTube URL: https://www.youtube.com/watch?v=N75TqsNCEHE


