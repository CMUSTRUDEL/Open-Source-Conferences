Title: LPC2018 - Keynote: "This Talk Is Not About XDP: From Resource Limits to SKB Lists"
Publication date: 2018-12-04
Playlist: LPC2018 - Networking Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/110/
url:  http://vger.kernel.org/lpc-networking.html
speaker:  David Miller (Red Hat)
Captions: 
	00:00:05,610 --> 00:00:11,300
good I hope everyone's having a great

00:00:07,860 --> 00:00:11,300
time at the networking track

00:00:12,660 --> 00:00:15,840
that's what I like it so I guess your

00:00:14,070 --> 00:00:17,190
food coma for lunch is over and you can

00:00:15,840 --> 00:00:19,890
actually function and listen to what I'm

00:00:17,190 --> 00:00:24,270
have to say all right as the talk is

00:00:19,890 --> 00:00:26,790
advertising this is not about XDP we do

00:00:24,270 --> 00:00:28,320
have the rest of the kernel to deal with

00:00:26,790 --> 00:00:29,760
we have our traditional networking stack

00:00:28,320 --> 00:00:32,450
and it needs to be taken care of because

00:00:29,760 --> 00:00:34,379
we're still using it is very important

00:00:32,450 --> 00:00:37,550
so we're going to talk about two

00:00:34,379 --> 00:00:40,770
important issues from my perspective

00:00:37,550 --> 00:00:43,110
clean and maintainable code and this

00:00:40,770 --> 00:00:44,879
issue of isolation and network

00:00:43,110 --> 00:00:48,900
namespaces and stuff like that which I

00:00:44,879 --> 00:00:53,879
kind of like piqued my interest and it's

00:00:48,900 --> 00:00:55,979
kind of cool to talk about so I want to

00:00:53,879 --> 00:00:58,050
get into a topic which is one of these

00:00:55,979 --> 00:01:01,559
instances where we push something down

00:00:58,050 --> 00:01:03,239
the road over and over again and it's

00:01:01,559 --> 00:01:04,589
kind of like this snowball that's

00:01:03,239 --> 00:01:06,090
getting bigger and bigger and it's

00:01:04,589 --> 00:01:08,549
harder to stop the more related roll

00:01:06,090 --> 00:01:13,530
down the hill and this is skp less

00:01:08,549 --> 00:01:15,330
handling I tried a trick many years ago

00:01:13,530 --> 00:01:16,649
I tried to propose that we have this

00:01:15,330 --> 00:01:18,149
issue and I would hope someone else

00:01:16,649 --> 00:01:20,219
would jump on the task and no one has

00:01:18,149 --> 00:01:21,450
done so so after many years I kind of

00:01:20,219 --> 00:01:23,450
just sat down and started working on it

00:01:21,450 --> 00:01:26,850
myself

00:01:23,450 --> 00:01:28,859
SKB lists escapees are maintained on

00:01:26,850 --> 00:01:31,710
various kinds of data structures it's

00:01:28,859 --> 00:01:33,930
not just lists anymore actually but it

00:01:31,710 --> 00:01:36,509
the list handling itself is done by hand

00:01:33,930 --> 00:01:38,250
we don't use the generic kernel list

00:01:36,509 --> 00:01:42,740
handling facility therefore we don't

00:01:38,250 --> 00:01:45,689
benefit from the debugging and other

00:01:42,740 --> 00:01:48,810
nice aspects of the generic list handler

00:01:45,689 --> 00:01:49,679
that we've accumulated over time it's

00:01:48,810 --> 00:01:52,140
not even a straightforward

00:01:49,679 --> 00:01:56,640
implementation of by handless handling

00:01:52,140 --> 00:01:58,350
there's weird semantics like sometimes

00:01:56,640 --> 00:02:01,350
it's a singly linked list sometimes it's

00:01:58,350 --> 00:02:03,359
a doubly linked list with a head and not

00:02:01,350 --> 00:02:06,149
being on a list is indicated by a null

00:02:03,359 --> 00:02:07,590
pointer some pieces of code do weird

00:02:06,149 --> 00:02:09,390
things with the previous pointer to

00:02:07,590 --> 00:02:12,150
indicate some other piece of state I

00:02:09,390 --> 00:02:14,160
mean it's it's a mess and it's it

00:02:12,150 --> 00:02:15,270
there's no way to figure out how you

00:02:14,160 --> 00:02:17,760
can't just look at a piece of code

00:02:15,270 --> 00:02:19,410
operating on a skb on a list and figure

00:02:17,760 --> 00:02:21,720
out which of these semantics it's using

00:02:19,410 --> 00:02:24,610
you need to have more context and it

00:02:21,720 --> 00:02:30,349
takes a long time to understand

00:02:24,610 --> 00:02:32,090
did Giro engine which takes smaller MTU

00:02:30,349 --> 00:02:34,760
size packets and accumulates them into a

00:02:32,090 --> 00:02:37,579
Giro super frame was using a sling link

00:02:34,760 --> 00:02:40,760
list with the special previous pointer

00:02:37,579 --> 00:02:43,400
semantics then you have the cutest layer

00:02:40,760 --> 00:02:48,260
which has its own use of the skb lists

00:02:43,400 --> 00:02:50,900
to move the freeing of a bulk queue of

00:02:48,260 --> 00:02:55,700
packets outside of a lock this is code

00:02:50,900 --> 00:02:58,069
that Eric added some time ago and then

00:02:55,700 --> 00:03:02,269
if I'm going to try to do this and

00:02:58,069 --> 00:03:03,739
convert at least some aspect of SK BSB

00:03:02,269 --> 00:03:05,870
list handling to the generic list

00:03:03,739 --> 00:03:09,049
handling how do I figure out the scope

00:03:05,870 --> 00:03:11,239
of what I need to do so the cool thing

00:03:09,049 --> 00:03:13,220
to do I think is to remove the next

00:03:11,239 --> 00:03:14,840
improve pointers from skb and then try

00:03:13,220 --> 00:03:16,879
to make some one of the kernel objects

00:03:14,840 --> 00:03:18,769
in the tree and see what the out GCC

00:03:16,879 --> 00:03:24,409
output looks like it's kind of fun you

00:03:18,769 --> 00:03:26,659
should do it it would take up less space

00:03:24,409 --> 00:03:30,709
on the slide then Jessie slide about all

00:03:26,659 --> 00:03:34,819
the eath to offload options but yeah it

00:03:30,709 --> 00:03:38,120
would be a Mad Max kind of situation so

00:03:34,819 --> 00:03:40,400
I brought this up again last year

00:03:38,120 --> 00:03:44,690
earlier this year in Boston and Erik

00:03:40,400 --> 00:03:46,099
Dumas is like a we have this thing that

00:03:44,690 --> 00:03:48,169
I've always wanted to convert the Giro

00:03:46,099 --> 00:03:50,060
engine to hash tables because the list

00:03:48,169 --> 00:03:52,549
it uses doesn't scale if you have a lot

00:03:50,060 --> 00:03:53,980
of parallel flows at the same time

00:03:52,549 --> 00:03:56,480
coming into the system

00:03:53,980 --> 00:03:58,220
we don't accumulate as much as we

00:03:56,480 --> 00:04:00,019
potentially could and that's a serious

00:03:58,220 --> 00:04:02,120
problem I said oh okay so I'll start

00:04:00,019 --> 00:04:04,040
stage one work on a Giro stuff but it's

00:04:02,120 --> 00:04:06,470
kind of isolated it's a nice little test

00:04:04,040 --> 00:04:10,040
case to see how much work is involved in

00:04:06,470 --> 00:04:12,079
this conversion so I converted to Lists

00:04:10,040 --> 00:04:13,819
head and I just walked through all the

00:04:12,079 --> 00:04:18,799
methods and converted everything my

00:04:13,819 --> 00:04:21,530
hands just Grudge through it it turns

00:04:18,799 --> 00:04:22,909
out that the previous amantha --kx

00:04:21,530 --> 00:04:24,620
weren't even necessary it was a

00:04:22,909 --> 00:04:26,120
situation that actually could not occur

00:04:24,620 --> 00:04:27,500
anymore after some changes we made a

00:04:26,120 --> 00:04:29,360
couple years ago but the person making

00:04:27,500 --> 00:04:30,949
change didn't notice this side effect so

00:04:29,360 --> 00:04:33,620
I could just get rid of that and that

00:04:30,949 --> 00:04:35,320
simplified things a lot then I once we

00:04:33,620 --> 00:04:37,090
have list head and that's working

00:04:35,320 --> 00:04:41,320
converting to hash

00:04:37,090 --> 00:04:43,780
table was absolutely trivial then there

00:04:41,320 --> 00:04:45,310
is some bug so once you're done with gr

00:04:43,780 --> 00:04:46,960
o and you've made the super packet you

00:04:45,310 --> 00:04:49,540
pass it up into the networking stack and

00:04:46,960 --> 00:04:52,810
now you're living in the domain of SK

00:04:49,540 --> 00:04:55,180
b-list semantics with the by hand stuff

00:04:52,810 --> 00:04:56,710
had implemented so all the code you look

00:04:55,180 --> 00:04:58,870
at after this point forward is gonna

00:04:56,710 --> 00:05:00,010
check is the next point or no if it's

00:04:58,870 --> 00:05:03,070
not it's on the list

00:05:00,010 --> 00:05:04,690
so I left the next pointer from the list

00:05:03,070 --> 00:05:06,460
head on there and things would explode

00:05:04,690 --> 00:05:08,440
if you hit that code path so it were a

00:05:06,460 --> 00:05:10,090
lot of bugs involving making sure that

00:05:08,440 --> 00:05:14,200
we set the next pointer to know after we

00:05:10,090 --> 00:05:16,330
finish with the giro processing okay we

00:05:14,200 --> 00:05:18,700
did gr o so let's remove the next and

00:05:16,330 --> 00:05:24,070
previous from SK pup again and see boom

00:05:18,700 --> 00:05:25,600
right then you go into SK buff that age

00:05:24,070 --> 00:05:27,790
and you have all these queue handlers

00:05:25,600 --> 00:05:29,229
and all these things and then that's

00:05:27,790 --> 00:05:31,289
where I learned about the packet

00:05:29,229 --> 00:05:36,400
scheduler having its own special set of

00:05:31,289 --> 00:05:39,580
list semantics need a better top-level

00:05:36,400 --> 00:05:41,710
attack plan and that is we have to get

00:05:39,580 --> 00:05:43,720
to a situation where accesses to the

00:05:41,710 --> 00:05:45,160
next improve pointers of the SK be go

00:05:43,720 --> 00:05:46,960
through some kind of helpers and this

00:05:45,160 --> 00:05:49,600
means we have many families of helpers

00:05:46,960 --> 00:05:51,580
their set of helpers for that we can

00:05:49,600 --> 00:05:54,160
convert to list head where we're using a

00:05:51,580 --> 00:05:55,990
doubly-linked traditional linked list we

00:05:54,160 --> 00:05:58,330
have another set for people who want to

00:05:55,990 --> 00:06:01,360
use a singly linked list maybe even a

00:05:58,330 --> 00:06:03,310
separate situation set of helpers for

00:06:01,360 --> 00:06:05,590
the case where we're doing skb frag

00:06:03,310 --> 00:06:07,720
lists which are another case of a saline

00:06:05,590 --> 00:06:11,229
like list but have their own set of

00:06:07,720 --> 00:06:13,510
semantics going through this whole

00:06:11,229 --> 00:06:15,940
process through the tree the core and

00:06:13,510 --> 00:06:19,630
the protocols were pretty clean like

00:06:15,940 --> 00:06:21,729
most people use the interfaces some

00:06:19,630 --> 00:06:23,740
situations we were forced upon us so for

00:06:21,729 --> 00:06:28,120
example when Eric Doom is a Kurd added

00:06:23,740 --> 00:06:31,180
our BG our pRb trees for TCP we transmit

00:06:28,120 --> 00:06:32,950
queue maintenance we were forced to put

00:06:31,180 --> 00:06:34,180
everything behind the proper abstraction

00:06:32,950 --> 00:06:36,160
so he could replace them with the

00:06:34,180 --> 00:06:39,820
arbitrary equivalent so that helped a

00:06:36,160 --> 00:06:42,070
lot and then when we want to go to list

00:06:39,820 --> 00:06:43,180
head if we have all these we put

00:06:42,070 --> 00:06:44,620
everything behind a proper interface

00:06:43,180 --> 00:06:45,910
it's just a matter of changing the

00:06:44,620 --> 00:06:47,230
engine it's underneath and

00:06:45,910 --> 00:06:50,440
we're using this heads all of a sudden

00:06:47,230 --> 00:06:54,610
nobody notices I've made a lot of

00:06:50,440 --> 00:06:56,200
progress in this area the really trippin

00:06:54,610 --> 00:06:59,890
points for me and the time-consuming

00:06:56,200 --> 00:07:04,810
ones were Wireless drivers that are

00:06:59,890 --> 00:07:07,330
doing funny stuff the wireless driver

00:07:04,810 --> 00:07:08,830
gets a packet and it has certain

00:07:07,330 --> 00:07:10,450
fragments and a certain layout and

00:07:08,830 --> 00:07:12,520
scatter gather list and then the device

00:07:10,450 --> 00:07:14,590
has some limitations it's you have to

00:07:12,520 --> 00:07:16,240
align all the buffers on this many bytes

00:07:14,590 --> 00:07:17,770
and you can only have this many bytes in

00:07:16,240 --> 00:07:23,320
the segment and so it has to convert a

00:07:17,770 --> 00:07:25,810
to B and so it takes a list of SK B's

00:07:23,320 --> 00:07:28,210
from coming from the original packet and

00:07:25,810 --> 00:07:30,220
a destination that it's going to use to

00:07:28,210 --> 00:07:32,860
rearrange the buffers for the DMA

00:07:30,220 --> 00:07:36,070
limitations and it's just ugly code a

00:07:32,860 --> 00:07:38,260
lot of by handless handling I change it

00:07:36,070 --> 00:07:40,210
and then I'm like well who uses this

00:07:38,260 --> 00:07:41,950
device anymore who can test it and you

00:07:40,210 --> 00:07:44,650
can just imagine how this process goes I

00:07:41,950 --> 00:07:46,570
thought I was in the clear but then I

00:07:44,650 --> 00:07:49,240
started looking at how the setp chunk

00:07:46,570 --> 00:07:51,070
handling and the then packet creation

00:07:49,240 --> 00:07:55,180
works and that's a hellish mess as well

00:07:51,070 --> 00:08:00,250
yeah I I don't even have to ask who said

00:07:55,180 --> 00:08:01,990
sorry I know who said it but I would say

00:08:00,250 --> 00:08:04,030
in passing that that person who said

00:08:01,990 --> 00:08:05,410
sorry is helping me review the the

00:08:04,030 --> 00:08:07,000
changes I'm trying to make so it's

00:08:05,410 --> 00:08:11,020
helping me a lot

00:08:07,000 --> 00:08:13,300
but it's another situation where it was

00:08:11,020 --> 00:08:14,830
so much easier to just assume that the

00:08:13,300 --> 00:08:16,060
implementation of the list head was this

00:08:14,830 --> 00:08:20,190
way and then we can mess with the

00:08:16,060 --> 00:08:22,540
pointers directly and save some effort

00:08:20,190 --> 00:08:24,550
we'll get through that and then I have

00:08:22,540 --> 00:08:26,110
this patch rating in the wing I'm just

00:08:24,550 --> 00:08:28,180
so scared to apply it and actually test

00:08:26,110 --> 00:08:30,550
it that just flips the switch for skb

00:08:28,180 --> 00:08:36,580
Q's and goes to list head so that should

00:08:30,550 --> 00:08:38,740
be really exciting boom ah so at this

00:08:36,580 --> 00:08:41,500
last stage where I'm trying to find the

00:08:38,740 --> 00:08:43,599
stragglers that are a trip us up it's

00:08:41,500 --> 00:08:46,300
like not easy to find but there is a

00:08:43,599 --> 00:08:48,760
distinct signature for these bozos word

00:08:46,300 --> 00:08:52,150
directly accessing the next in freeport

00:08:48,760 --> 00:08:55,690
and it's this either a cast to SK buff

00:08:52,150 --> 00:08:59,890
pointer or a cast to our SK buff head if

00:08:55,690 --> 00:09:00,160
you see this run for the hills like this

00:08:59,890 --> 00:09:02,290
is

00:09:00,160 --> 00:09:05,259
beyond danger this is toxic this is

00:09:02,290 --> 00:09:06,490
nuclear get your asbestos suit on but

00:09:05,259 --> 00:09:09,940
this is the kind of code on an app I

00:09:06,490 --> 00:09:17,680
have to fix up at this point there were

00:09:09,940 --> 00:09:19,750
some in SCTP because the point is with

00:09:17,680 --> 00:09:21,430
our existing by hand list handling the

00:09:19,750 --> 00:09:24,490
next pointer points the beginning of the

00:09:21,430 --> 00:09:28,149
structure be it an sk buff head or an

00:09:24,490 --> 00:09:30,699
escape off whereas with list head that

00:09:28,149 --> 00:09:32,110
assumption no longer necessarily holds

00:09:30,699 --> 00:09:35,470
because it's just ringing around to the

00:09:32,110 --> 00:09:37,360
different list list node entries so

00:09:35,470 --> 00:09:42,459
that's just gonna explode the sub

00:09:37,360 --> 00:09:44,800
pointer everything tick crap so once we

00:09:42,459 --> 00:09:47,290
get past SCTP and any other things my

00:09:44,800 --> 00:09:50,230
phantom i funny grep finds will be ready

00:09:47,290 --> 00:09:52,899
to apply to conversion Springs to me to

00:09:50,230 --> 00:09:57,069
my next topic resource sharing across

00:09:52,899 --> 00:10:00,180
network namespaces this is cool so we

00:09:57,069 --> 00:10:02,410
have a bunch of tables in the kernel and

00:10:00,180 --> 00:10:04,899
some of them are controlled by external

00:10:02,410 --> 00:10:06,759
entities and one way or another so for

00:10:04,899 --> 00:10:08,410
example the best example in my is the

00:10:06,759 --> 00:10:11,139
neighbor table or the ARP table your

00:10:08,410 --> 00:10:13,540
resolution table someone tries to

00:10:11,139 --> 00:10:16,300
communicate with us we make an ARP entry

00:10:13,540 --> 00:10:18,100
and the table grows based upon how many

00:10:16,300 --> 00:10:20,170
entries we need to have there's a global

00:10:18,100 --> 00:10:24,660
limit and we start garbage collecting

00:10:20,170 --> 00:10:29,019
once we hit get past that limit however

00:10:24,660 --> 00:10:32,019
that limit is global which means that if

00:10:29,019 --> 00:10:34,300
you've got a hundred namespaces one of

00:10:32,019 --> 00:10:36,519
your dudes can take up most that limit

00:10:34,300 --> 00:10:41,769
to the detriment of every other

00:10:36,519 --> 00:10:44,079
namespace on your system so what do we

00:10:41,769 --> 00:10:45,819
do do we continue we try to make the

00:10:44,079 --> 00:10:48,040
global model work somehow do we go to

00:10:45,819 --> 00:10:52,149
segregated tables and some perennis

00:10:48,040 --> 00:10:53,439
level stuff so some other tables in the

00:10:52,149 --> 00:10:56,170
tree that have this kind of issue

00:10:53,439 --> 00:10:58,389
there's socket hashes is routing tables

00:10:56,170 --> 00:11:00,579
and caches this fragment queues there's

00:10:58,389 --> 00:11:04,540
network device lists all this other

00:11:00,579 --> 00:11:06,879
stuff so the global the global table

00:11:04,540 --> 00:11:09,370
with the namespace key is the simplest

00:11:06,879 --> 00:11:11,319
to implement and it's the cheapest you

00:11:09,370 --> 00:11:12,519
don't have to allocate a table when you

00:11:11,319 --> 00:11:13,980
create a namespace you don't have to

00:11:12,519 --> 00:11:16,510
delete and forgets

00:11:13,980 --> 00:11:18,250
deleted namespace and you also don't

00:11:16,510 --> 00:11:20,110
have there are CU synchronized with

00:11:18,250 --> 00:11:22,450
asynchronous accesses to that table when

00:11:20,110 --> 00:11:24,430
you destroy that namespace so people

00:11:22,450 --> 00:11:26,470
became very sensitive over the past

00:11:24,430 --> 00:11:28,779
couple years to net namespace creation

00:11:26,470 --> 00:11:30,900
and destruction cost so a lot of the

00:11:28,779 --> 00:11:34,990
thinking in this area is drive by those

00:11:30,900 --> 00:11:37,390
considerations but when you do a simple

00:11:34,990 --> 00:11:39,339
global table it means that one of the

00:11:37,390 --> 00:11:42,880
keys you have to compare in the hash

00:11:39,339 --> 00:11:46,000
lookup is the namespace key so this

00:11:42,880 --> 00:11:48,100
works as a first approximation but like

00:11:46,000 --> 00:11:51,520
I said in the previous slide it lacks

00:11:48,100 --> 00:11:54,730
the object pressure isolation so one guy

00:11:51,520 --> 00:11:57,730
can hurt the whole set of instances and

00:11:54,730 --> 00:12:00,130
you globally on your system now you do

00:11:57,730 --> 00:12:00,640
perennis tables this me this is more

00:12:00,130 --> 00:12:02,260
work

00:12:00,640 --> 00:12:03,490
you've got to allocate it you got a free

00:12:02,260 --> 00:12:06,040
it you got to synchronize when you

00:12:03,490 --> 00:12:07,360
destroy the NS is the key is implicit so

00:12:06,040 --> 00:12:08,650
it makes lookups faster you have less

00:12:07,360 --> 00:12:11,620
keys to compare and you don't have to

00:12:08,650 --> 00:12:13,089
store that NS key in the key in the

00:12:11,620 --> 00:12:20,170
object itself because the key is

00:12:13,089 --> 00:12:22,570
implicit limits and sizing now become an

00:12:20,170 --> 00:12:25,660
issue so it's easy to say okay if I have

00:12:22,570 --> 00:12:29,020
this much memory in my machine I'll set

00:12:25,660 --> 00:12:31,450
the ARP limits to x y&z what does this

00:12:29,020 --> 00:12:32,980
mean when I create 40 namespaces what

00:12:31,450 --> 00:12:34,660
does this mean when I create a thousand

00:12:32,980 --> 00:12:37,540
namespaces what kind of numbers can mean

00:12:34,660 --> 00:12:41,770
can we choose can we even enforce by

00:12:37,540 --> 00:12:43,300
default on the namespace basis like if

00:12:41,770 --> 00:12:44,710
you have a set up that's working now and

00:12:43,300 --> 00:12:46,720
every once in a while one of the guys

00:12:44,710 --> 00:12:49,330
goes over what you would use as this per

00:12:46,720 --> 00:12:51,400
namespace limit they may not function

00:12:49,330 --> 00:12:55,450
properly anymore so we could break

00:12:51,400 --> 00:12:56,680
things by going to / NS limits so like I

00:12:55,450 --> 00:12:59,380
said they're hard what's what's the

00:12:56,680 --> 00:13:03,100
metric can we do it by default probably

00:12:59,380 --> 00:13:05,650
not global limits satisfy system level

00:13:03,100 --> 00:13:07,660
constraints but they have this weakness

00:13:05,650 --> 00:13:14,890
that discussed earlier so maybe we need

00:13:07,660 --> 00:13:16,720
a combination of both we have this

00:13:14,890 --> 00:13:20,620
unbounded situation if we go with a per

00:13:16,720 --> 00:13:24,040
and s limit you're kind of saying like

00:13:20,620 --> 00:13:25,900
if each NS gets X and we have a thousand

00:13:24,040 --> 00:13:27,520
namespaces this means x times a thousand

00:13:25,900 --> 00:13:29,170
could be consumed by

00:13:27,520 --> 00:13:31,750
all the namespaces so you guys quickly

00:13:29,170 --> 00:13:33,100
have a combinatorial explosion problem

00:13:31,750 --> 00:13:35,200
with the resources that you're allowing

00:13:33,100 --> 00:13:35,680
various entities to use and that's no

00:13:35,200 --> 00:13:38,890
good

00:13:35,680 --> 00:13:41,980
like we keep saying the global limit has

00:13:38,890 --> 00:13:43,720
a path for abuse but it puts a really

00:13:41,980 --> 00:13:46,380
solid cap on what could be used globally

00:13:43,720 --> 00:13:49,510
on the system and allocated that way so

00:13:46,380 --> 00:13:52,150
maybe availability based policies so

00:13:49,510 --> 00:13:54,790
kind of like packet shaping you may say

00:13:52,150 --> 00:13:58,240
you know what I guarantee you at least

00:13:54,790 --> 00:14:00,010
20 megabit but if no one else is using a

00:13:58,240 --> 00:14:01,810
network you can go ahead and use all the

00:14:00,010 --> 00:14:03,400
resources that are available so that's

00:14:01,810 --> 00:14:06,640
one kind of model we could be thinking

00:14:03,400 --> 00:14:08,580
of so kind of squeezed people back to

00:14:06,640 --> 00:14:10,690
their limits when there is actual

00:14:08,580 --> 00:14:13,180
across-the-board usage that's fairly

00:14:10,690 --> 00:14:14,650
consistent but if an otherwise quiet

00:14:13,180 --> 00:14:16,990
system your one name status could use

00:14:14,650 --> 00:14:19,720
all the resources that could I means

00:14:16,990 --> 00:14:21,970
that we needed to do remote trimming so

00:14:19,720 --> 00:14:23,770
I'm the guy who's not really abusing

00:14:21,970 --> 00:14:28,030
your resources and I also didn't need to

00:14:23,770 --> 00:14:30,970
use something and we need to pin you

00:14:28,030 --> 00:14:32,380
down we have to go remotely into another

00:14:30,970 --> 00:14:33,670
namespace and take away some of their

00:14:32,380 --> 00:14:38,110
ARP entries and that could be a little

00:14:33,670 --> 00:14:40,660
bit complicated the implicit assumption

00:14:38,110 --> 00:14:42,760
in this suggestion is that everything in

00:14:40,660 --> 00:14:45,010
these tables can be reconstituted some

00:14:42,760 --> 00:14:46,360
way in the future so that's if you

00:14:45,010 --> 00:14:47,950
remember the routing cache we used to

00:14:46,360 --> 00:14:49,570
have we always had the routing table

00:14:47,950 --> 00:14:51,730
sitting behind it so if we needed to

00:14:49,570 --> 00:14:53,260
remake a routing cache entry in the

00:14:51,730 --> 00:14:56,380
future we always could construct a new

00:14:53,260 --> 00:14:58,330
one the ARP table is like that too so

00:14:56,380 --> 00:15:02,950
these are situations where we use this

00:14:58,330 --> 00:15:05,020
that you just kind of approach now you

00:15:02,950 --> 00:15:06,910
know what I control every aspect of this

00:15:05,020 --> 00:15:09,340
deployment I know what's going to run on

00:15:06,910 --> 00:15:13,210
all these namespaces I trust a

00:15:09,340 --> 00:15:15,430
namespaces just let them go up to the

00:15:13,210 --> 00:15:16,990
global limit it's fine they're gonna do

00:15:15,430 --> 00:15:18,460
everything like that but you if you're

00:15:16,990 --> 00:15:21,070
in a situation you have to make sure

00:15:18,460 --> 00:15:22,240
that you also trust the network that

00:15:21,070 --> 00:15:23,800
you're putting this you're deploying

00:15:22,240 --> 00:15:26,200
this thing on because anyone can pop you

00:15:23,800 --> 00:15:27,430
with traffic and trigger these probably

00:15:26,200 --> 00:15:29,140
these situations that we're considering

00:15:27,430 --> 00:15:32,110
so all these things need to be

00:15:29,140 --> 00:15:34,630
considered and what we decide to do in

00:15:32,110 --> 00:15:36,880
the end so it seems like in my opinion

00:15:34,630 --> 00:15:40,900
no single policy satisfies all these use

00:15:36,880 --> 00:15:41,230
cases so we have a set of solutions we

00:15:40,900 --> 00:15:44,920
could

00:15:41,230 --> 00:15:46,750
to reconstitute all tables and then we

00:15:44,920 --> 00:15:50,860
have non reconstitute all tables which

00:15:46,750 --> 00:15:52,510
may need other solutions this assume

00:15:50,860 --> 00:15:54,460
that you agree with me we need multiple

00:15:52,510 --> 00:15:56,230
policies for these situations like how

00:15:54,460 --> 00:15:58,570
to read how to provide this choice and

00:15:56,230 --> 00:15:59,830
what do we do by default and there needs

00:15:58,570 --> 00:16:01,930
to be some discussion there well we

00:15:59,830 --> 00:16:04,420
definitely we have an issue and we have

00:16:01,930 --> 00:16:05,980
to address it somehow and I'm really

00:16:04,420 --> 00:16:08,800
happy that people like David eight Hearn

00:16:05,980 --> 00:16:10,530
have been trying to invoke discussion on

00:16:08,800 --> 00:16:14,430
this issue

00:16:10,530 --> 00:16:17,800
so those are my thoughts on the matter

00:16:14,430 --> 00:16:20,740
does anyone have any questions or strong

00:16:17,800 --> 00:16:32,560
opinions on namespace resource limits

00:16:20,740 --> 00:16:34,360
just like last time you talked about the

00:16:32,560 --> 00:16:37,780
global table where you had a namespace

00:16:34,360 --> 00:16:39,040
key yes and while it took longer because

00:16:37,780 --> 00:16:40,120
you had to compare the name stays key in

00:16:39,040 --> 00:16:43,030
order to find it in the global table

00:16:40,120 --> 00:16:44,830
would a interim solution be have the

00:16:43,030 --> 00:16:47,230
global table with per namespace

00:16:44,830 --> 00:16:49,170
accounting so that each namespace were

00:16:47,230 --> 00:16:51,880
to be able to push from the global table

00:16:49,170 --> 00:16:53,710
yeah that's one way to do it but it

00:16:51,880 --> 00:16:56,260
seems like it kind of multiplies the

00:16:53,710 --> 00:17:00,580
amount of state you need to maintain so

00:16:56,260 --> 00:17:02,050
I would have to look more deeply into

00:17:00,580 --> 00:17:03,100
approaching things like that and see

00:17:02,050 --> 00:17:05,500
what the data structures would look if

00:17:03,100 --> 00:17:06,040
that's an interesting idea so it's

00:17:05,500 --> 00:17:09,790
around

00:17:06,040 --> 00:17:13,000
I'll see group memory accounting impacts

00:17:09,790 --> 00:17:15,010
all of this ah that's interesting so you

00:17:13,000 --> 00:17:17,740
could put a bunch of names theoretically

00:17:15,010 --> 00:17:19,720
put a bunch of namespaces into a c group

00:17:17,740 --> 00:17:21,760
and then say these guys can use this

00:17:19,720 --> 00:17:26,260
much resources or things like that

00:17:21,760 --> 00:17:29,110
so this kind of is parallel to the

00:17:26,260 --> 00:17:30,550
discussion of if the administrator knows

00:17:29,110 --> 00:17:31,870
what he's doing and he can set up all

00:17:30,550 --> 00:17:33,970
these limits ahead of time he doesn't

00:17:31,870 --> 00:17:35,680
need our help we're talking about what

00:17:33,970 --> 00:17:37,540
happens by default if you just spin

00:17:35,680 --> 00:17:40,510
namespaces up and you get the behavior

00:17:37,540 --> 00:17:41,830
that you've expected in the past so one

00:17:40,510 --> 00:17:43,180
set of problems is dealing with the

00:17:41,830 --> 00:17:44,650
default situation another set of

00:17:43,180 --> 00:17:47,620
problems is how what kind of mechanism

00:17:44,650 --> 00:17:49,360
like C groups could we use to formalize

00:17:47,620 --> 00:17:52,410
this kind of configuration and setting

00:17:49,360 --> 00:17:52,410
up these limits that's a good point

00:17:54,120 --> 00:18:06,850
even so my question is have you opened

00:18:03,730 --> 00:18:10,360
the channel discussion with the actual

00:18:06,850 --> 00:18:12,760
major users of the C group kind of world

00:18:10,360 --> 00:18:14,590
B or the container world because my

00:18:12,760 --> 00:18:17,110
impression is that their needs are not

00:18:14,590 --> 00:18:19,840
always as general as we might think they

00:18:17,110 --> 00:18:23,010
are and they're also tend to have a lot

00:18:19,840 --> 00:18:27,100
of static configurations like the open

00:18:23,010 --> 00:18:28,659
you know open stack etc and you know

00:18:27,100 --> 00:18:32,380
they're doing things like hard coding

00:18:28,659 --> 00:18:35,230
FTB entries in for the containers and

00:18:32,380 --> 00:18:37,570
I'm wondering if you know whatever we do

00:18:35,230 --> 00:18:39,820
we should be easy to integrate with that

00:18:37,570 --> 00:18:41,950
rather than you know make it life harder

00:18:39,820 --> 00:18:45,610
and have them to do a lot more scripting

00:18:41,950 --> 00:18:47,260
or some other I agree with you I haven't

00:18:45,610 --> 00:18:50,530
had any discussions with people who are

00:18:47,260 --> 00:18:52,600
sending up these things but I think the

00:18:50,530 --> 00:18:55,120
first thing to do is to understand what

00:18:52,600 --> 00:18:56,620
the scope of the problem is and like

00:18:55,120 --> 00:18:59,620
what what what do we have on our hands

00:18:56,620 --> 00:19:01,929
right now because clearly allowing one

00:18:59,620 --> 00:19:08,020
namespace to pop everyone else's ARP

00:19:01,929 --> 00:19:09,700
tables it doesn't we can't continue then

00:19:08,020 --> 00:19:11,140
we need to discuss with people how they

00:19:09,700 --> 00:19:12,520
actually use and configure this stuff

00:19:11,140 --> 00:19:14,950
and see if we can have a solution that

00:19:12,520 --> 00:19:16,750
actually matches their use of this stuff

00:19:14,950 --> 00:19:18,190
so that's that's definitely the case we

00:19:16,750 --> 00:19:20,580
have to communicate with people figure

00:19:18,190 --> 00:19:20,580
out what they're doing

00:19:23,280 --> 00:19:26,350
are you guys are easy thank you very

00:19:25,620 --> 00:19:33,350
much

00:19:26,350 --> 00:19:33,350

YouTube URL: https://www.youtube.com/watch?v=SeXMupW25WA


