Title: LPC2018 - Using eBPF as an Abstraction for Switching
Publication date: 2018-12-04
Playlist: LPC2018 - Networking Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/112/
speaker:  Nick Viljoen (Netronome)


eBPF (extended Berkeley Packet Filter) has been shown to be a flexible
kernel construct used for a variety of use cases, such as load balancing,
intrusion detection systems (IDS), tracing and many others. One such
emerging use case revolves around the proposal made by William Tu for
the use of eBPF as a data path for Open vSwitch. However, there are
broader switching use cases developing around the use of eBPF capable
hardware. This talk is designed to explore the bottlenecks that exist in
generalising the application of eBPF further to both container switching as
well as physical switching.

Topics that will be covered include proposals for container isolation through
the use of features such as programmable RSS, the viability of physical
switching using eBPF capable hardware as well as integrations with other
subsystems or additional helper functions which may improve the possible
functionality.
Captions: 
	00:00:06,300 --> 00:00:11,110
Nick and the metronome guys have been

00:00:09,040 --> 00:00:13,330
one of the earliest adopters and

00:00:11,110 --> 00:00:15,369
promoters of BPF of technology

00:00:13,330 --> 00:00:20,440
offloading it onto their cards and doing

00:00:15,369 --> 00:00:22,240
all kinds of amazing things and they

00:00:20,440 --> 00:00:23,380
didn't stop there they didn't just make

00:00:22,240 --> 00:00:25,570
sure that their hardware works really

00:00:23,380 --> 00:00:27,820
well at BPF the metronome guys worked

00:00:25,570 --> 00:00:29,289
actively on tooling and in particular BP

00:00:27,820 --> 00:00:32,259
of tool and things that provide

00:00:29,289 --> 00:00:33,820
introspection as well infrastructure for

00:00:32,259 --> 00:00:36,489
things like switch dev and improving

00:00:33,820 --> 00:00:38,140
support there and if you look upstream

00:00:36,489 --> 00:00:41,200
there are contributions all over the map

00:00:38,140 --> 00:00:45,370
so look forward to Nick's presentation

00:00:41,200 --> 00:00:47,050
hey guys yep that's working so I'm gonna

00:00:45,370 --> 00:00:48,400
talk about EBP effing and switch

00:00:47,050 --> 00:00:50,200
abstractions now obviously that's

00:00:48,400 --> 00:00:53,860
actually quite an abstract title but

00:00:50,200 --> 00:00:56,350
what I'm looking to do is basically move

00:00:53,860 --> 00:00:59,650
us towards proposing a path whereby we

00:00:56,350 --> 00:01:02,050
have a flexible EBP F defined data path

00:00:59,650 --> 00:01:03,550
for switching in the legs now

00:01:02,050 --> 00:01:06,070
this is very similar to things like what

00:01:03,550 --> 00:01:08,920
we'll was talking about but sort of

00:01:06,070 --> 00:01:10,240
wills focus was really on the x86 now

00:01:08,920 --> 00:01:13,299
we're actually going to be talking about

00:01:10,240 --> 00:01:15,280
more as heterogeneous processing so how

00:01:13,299 --> 00:01:17,439
you can use Linux to basically control

00:01:15,280 --> 00:01:19,420
other elements whether this be switch

00:01:17,439 --> 00:01:23,280
tips or an arc layer network processor

00:01:19,420 --> 00:01:25,600
on the NIC and basically use that to

00:01:23,280 --> 00:01:27,939
move things a little bit forward in that

00:01:25,600 --> 00:01:28,780
in that space so really what we're going

00:01:27,939 --> 00:01:32,950
to be doing is we're going to be

00:01:28,780 --> 00:01:35,590
combining CL sppf x DP q disk offload

00:01:32,950 --> 00:01:38,920
and switch them all at the same time to

00:01:35,590 --> 00:01:40,960
create this infrastructure and the first

00:01:38,920 --> 00:01:42,909
one I'm going to use as a as a as a

00:01:40,960 --> 00:01:44,409
demonstration is really the multi-ethnic

00:01:42,909 --> 00:01:48,459
but there's a bunch of other

00:01:44,409 --> 00:01:49,719
applications as well out there so the

00:01:48,459 --> 00:01:51,969
way we're going to run through this is

00:01:49,719 --> 00:01:54,219
I'm just gonna quickly first up give a

00:01:51,969 --> 00:01:55,929
bit of background most of you have seen

00:01:54,219 --> 00:01:57,729
this a few times already so I'll try and

00:01:55,929 --> 00:01:59,289
keep this very very brief but a

00:01:57,729 --> 00:02:01,389
background of how the hardware works

00:01:59,289 --> 00:02:03,729
because having that context is pretty

00:02:01,389 --> 00:02:05,709
important for all of this and then after

00:02:03,729 --> 00:02:07,209
that we're gonna just go through a quick

00:02:05,709 --> 00:02:09,970
overview of the abstraction of what

00:02:07,209 --> 00:02:11,200
we're looking to do and then we're going

00:02:09,970 --> 00:02:13,270
to run through what's currently up the

00:02:11,200 --> 00:02:15,280
stream as of about two weeks ago and

00:02:13,270 --> 00:02:16,659
then after that we're gonna go through

00:02:15,280 --> 00:02:18,010
next steps which are actually the stuff

00:02:16,659 --> 00:02:19,250
that just currently being upstream so I

00:02:18,010 --> 00:02:22,190
think kuba posted some party

00:02:19,250 --> 00:02:25,340
yesterday oh great they're already

00:02:22,190 --> 00:02:28,280
applied so that that's kind of what

00:02:25,340 --> 00:02:31,100
we're busy with right now and then the

00:02:28,280 --> 00:02:33,380
final bit is the future work and that's

00:02:31,100 --> 00:02:35,000
that's kind of when we get to get to

00:02:33,380 --> 00:02:37,610
what I've what I've just described which

00:02:35,000 --> 00:02:41,930
is actually having a fully flexible data

00:02:37,610 --> 00:02:44,060
path there so just to give you guys a

00:02:41,930 --> 00:02:45,950
quick overview of the of the hardware so

00:02:44,060 --> 00:02:47,330
what we have is we have basically a many

00:02:45,950 --> 00:02:50,270
cool fully programmable network

00:02:47,330 --> 00:02:52,730
processor which sits on a neck you've

00:02:50,270 --> 00:02:55,150
got hundreds up to 100 of programmable

00:02:52,730 --> 00:02:58,130
cause down there eight threads per core

00:02:55,150 --> 00:02:59,840
you've got up to four PCIe s and you've

00:02:58,130 --> 00:03:01,760
actually got up to bizarrely up to 40

00:02:59,840 --> 00:03:03,770
ports supported on one of the chips so

00:03:01,760 --> 00:03:05,000
you'll see that's that's relevant for

00:03:03,770 --> 00:03:07,360
something I'm going to be talking about

00:03:05,000 --> 00:03:11,870
a little bit later but it's basically a

00:03:07,360 --> 00:03:13,370
large mesh of small processing elements

00:03:11,870 --> 00:03:16,550
which all get put together in this sort

00:03:13,370 --> 00:03:18,920
of many core architecture the final bit

00:03:16,550 --> 00:03:20,900
is that we're also pretty low power so

00:03:18,920 --> 00:03:24,860
10 to 35 watts depending on the chip and

00:03:20,900 --> 00:03:28,190
the frequency so just to give you a

00:03:24,860 --> 00:03:30,080
quick background on the data path so the

00:03:28,190 --> 00:03:33,410
data path is pretty symmetric actually

00:03:30,080 --> 00:03:36,260
whether you are on the receive or on the

00:03:33,410 --> 00:03:38,810
transmit path whether you're coming from

00:03:36,260 --> 00:03:40,100
the file the PCI you basically the only

00:03:38,810 --> 00:03:41,750
but that's really aware of the

00:03:40,100 --> 00:03:43,790
difference is the flow processing cause

00:03:41,750 --> 00:03:44,570
the bit in the middle because obviously

00:03:43,790 --> 00:03:47,090
you're gonna have different

00:03:44,570 --> 00:03:49,310
functionality running dependent on where

00:03:47,090 --> 00:03:50,390
the packet is actually come from and

00:03:49,310 --> 00:03:53,180
obviously we've got a few other

00:03:50,390 --> 00:03:53,930
accelerators like crypto I had down the

00:03:53,180 --> 00:03:56,570
bottom as well

00:03:53,930 --> 00:03:58,280
and then because of the fact that we can

00:03:56,570 --> 00:04:00,049
handle things an out-of-order pipeline

00:03:58,280 --> 00:04:02,090
to be able to paralyze things and

00:04:00,049 --> 00:04:04,450
utilize our transactional memory as well

00:04:02,090 --> 00:04:08,269
as we can we also have a reorder block

00:04:04,450 --> 00:04:10,190
and this is the slide I'm sure many of

00:04:08,269 --> 00:04:12,860
you seen the slide about five times so I

00:04:10,190 --> 00:04:14,150
apologize to those of you who have this

00:04:12,860 --> 00:04:17,450
is just to give you a quick overview of

00:04:14,150 --> 00:04:18,620
that all flood architecture so basically

00:04:17,450 --> 00:04:20,269
I think it's about two and a bit years

00:04:18,620 --> 00:04:23,270
ago now that could be posted the first

00:04:20,269 --> 00:04:26,180
patches for this so this is what allowed

00:04:23,270 --> 00:04:27,890
us to actually offload BPF to the Nick

00:04:26,180 --> 00:04:31,550
so what we did is we basically upstream

00:04:27,890 --> 00:04:34,160
the NFP PPF chip into our driver so

00:04:31,550 --> 00:04:37,130
the JIT is basically used like any other

00:04:34,160 --> 00:04:39,890
architectures yet we compile the BPF

00:04:37,130 --> 00:04:41,690
bytecode to our NFP machine code and as

00:04:39,890 --> 00:04:43,520
dave eluded through things like PPF

00:04:41,690 --> 00:04:44,540
tools through some of the other

00:04:43,520 --> 00:04:46,400
infrastructure out there you can

00:04:44,540 --> 00:04:49,070
actually inspect the assembler code for

00:04:46,400 --> 00:04:54,470
generating and debug it and hand it like

00:04:49,070 --> 00:04:56,810
anything else so just a quick background

00:04:54,470 --> 00:04:58,520
quickly as Nick as a switch there are

00:04:56,810 --> 00:05:00,950
two kinds of use cases we're seeing at

00:04:58,520 --> 00:05:03,380
the moment for the Nick being used in

00:05:00,950 --> 00:05:05,420
this kind of manner that's the sort of

00:05:03,380 --> 00:05:06,410
multi host case and the other emerging

00:05:05,420 --> 00:05:08,840
one we're seeing is this quote-unquote

00:05:06,410 --> 00:05:11,600
multi-home case whereby you have a

00:05:08,840 --> 00:05:14,420
significantly large amount of ports way

00:05:11,600 --> 00:05:15,890
more ports relative to the actual PCIe

00:05:14,420 --> 00:05:18,440
of the host at the front of the neck

00:05:15,890 --> 00:05:22,000
this is effectively so people can start

00:05:18,440 --> 00:05:25,130
weaving the Nick into their cloths

00:05:22,000 --> 00:05:26,630
architecture of their switches so both

00:05:25,130 --> 00:05:28,670
of these cases lead to sort of an

00:05:26,630 --> 00:05:30,110
impedance mismatch whereby you could

00:05:28,670 --> 00:05:31,670
have more traffic coming in on the one

00:05:30,110 --> 00:05:33,650
side then you actually have being synced

00:05:31,670 --> 00:05:37,280
on the other side so that means you need

00:05:33,650 --> 00:05:38,780
to be able to handle things like a

00:05:37,280 --> 00:05:40,760
switch would normally do things like

00:05:38,780 --> 00:05:43,520
quality of service things like stats to

00:05:40,760 --> 00:05:45,650
be able to debug issues so that and

00:05:43,520 --> 00:05:46,940
obviously forwarding are there other key

00:05:45,650 --> 00:05:53,090
things that you need to be able to

00:05:46,940 --> 00:05:54,110
really define as a switch so just to

00:05:53,090 --> 00:05:56,180
give you a quick idea that other

00:05:54,110 --> 00:05:57,800
multi-ethnic today there's a bunch of

00:05:56,180 --> 00:05:59,180
advantages to doing things this way

00:05:57,800 --> 00:06:01,250
which is kind of the current way things

00:05:59,180 --> 00:06:03,710
are things are usually done

00:06:01,250 --> 00:06:05,330
it's the hosts are effectively unaware

00:06:03,710 --> 00:06:07,910
of the configuration so it means that

00:06:05,330 --> 00:06:10,730
it's easy to pour things you should use

00:06:07,910 --> 00:06:12,200
in other circumstances as well but there

00:06:10,730 --> 00:06:16,220
but there are a few issues you run into

00:06:12,200 --> 00:06:19,070
the first one is visibility so being

00:06:16,220 --> 00:06:20,450
able to understand what's going on on

00:06:19,070 --> 00:06:21,740
the other three hosts helps

00:06:20,450 --> 00:06:23,720
significantly when you're trying to work

00:06:21,740 --> 00:06:25,250
out you know for example why you've

00:06:23,720 --> 00:06:26,630
dropped a packet oh it's because of the

00:06:25,250 --> 00:06:27,650
fact that this other host over there is

00:06:26,630 --> 00:06:30,470
getting a huge amount of traffic right

00:06:27,650 --> 00:06:32,690
now so being able to have that

00:06:30,470 --> 00:06:35,810
visibility means that you can trust your

00:06:32,690 --> 00:06:39,470
programs and rely on the infrastructure

00:06:35,810 --> 00:06:41,420
you have in place second thing is there

00:06:39,470 --> 00:06:43,640
isn't really a way to offload lose

00:06:41,420 --> 00:06:44,690
control quality of service with this

00:06:43,640 --> 00:06:47,240
architecture

00:06:44,690 --> 00:06:49,580
really cause cue disks are on the egress

00:06:47,240 --> 00:06:53,960
side there is no represented to attach

00:06:49,580 --> 00:06:56,480
an egress acutest to here on the l2

00:06:53,960 --> 00:06:59,270
switch so there's no way to really

00:06:56,480 --> 00:07:00,590
handle that at that level and then the

00:06:59,270 --> 00:07:02,030
final thing is obviously there's no

00:07:00,590 --> 00:07:03,950
concept of where you are touching or

00:07:02,030 --> 00:07:05,690
float so if you're looking at things

00:07:03,950 --> 00:07:09,110
like X to be offered which is something

00:07:05,690 --> 00:07:12,260
we worry about a little bit you either

00:07:09,110 --> 00:07:15,440
have to have separate offloads for each

00:07:12,260 --> 00:07:17,780
one of the four hosts or you have to

00:07:15,440 --> 00:07:19,970
somehow try and work out how they can

00:07:17,780 --> 00:07:21,680
share programs so that means you're

00:07:19,970 --> 00:07:23,870
going to waste potentially code store in

00:07:21,680 --> 00:07:25,760
our case or they could potentially be

00:07:23,870 --> 00:07:27,710
carefully using things like food

00:07:25,760 --> 00:07:30,260
programmable gate arrays then you can be

00:07:27,710 --> 00:07:31,970
wasting gates wasting power these are

00:07:30,260 --> 00:07:35,210
the kinds of issues that people need to

00:07:31,970 --> 00:07:37,280
consider so oh sorry I skipped us like

00:07:35,210 --> 00:07:39,860
that so what we what we came up with was

00:07:37,280 --> 00:07:41,660
using switch dev to kind of build the

00:07:39,860 --> 00:07:44,270
frame so this is the first step of this

00:07:41,660 --> 00:07:46,850
of this processes we build up the frame

00:07:44,270 --> 00:07:49,100
and then once we've brought up the frame

00:07:46,850 --> 00:07:51,500
then we can start attaching things so

00:07:49,100 --> 00:07:54,440
once we have this frame with a egress

00:07:51,500 --> 00:07:56,030
representatives on on the l2 switch as

00:07:54,440 --> 00:08:01,460
well as an ingress representer on the

00:07:56,030 --> 00:08:03,680
actual file and then the four normal

00:08:01,460 --> 00:08:07,580
hosts representers then we have a setup

00:08:03,680 --> 00:08:10,490
whereby were able to attach cross or cue

00:08:07,580 --> 00:08:12,350
disks to this point over there and then

00:08:10,490 --> 00:08:16,720
also other offloads we can then attach

00:08:12,350 --> 00:08:19,880
to the correct points to attach them to

00:08:16,720 --> 00:08:21,740
so next bit is just to quickly go

00:08:19,880 --> 00:08:26,590
through actually what's been done

00:08:21,740 --> 00:08:29,660
already as of two weeks ago there are a

00:08:26,590 --> 00:08:32,240
couple of simple things we've done so it

00:08:29,660 --> 00:08:36,860
was really the first step was really

00:08:32,240 --> 00:08:39,289
having a simple set of single cue disks

00:08:36,860 --> 00:08:41,690
without a hierarchy attached to these

00:08:39,289 --> 00:08:43,660
representives so we added the this sort

00:08:41,690 --> 00:08:46,400
of architecture of the representers and

00:08:43,660 --> 00:08:50,210
with switch dev and then we added in

00:08:46,400 --> 00:08:52,070
single cue disks now this wasn't very

00:08:50,210 --> 00:08:53,260
fancy at this point in time all of the

00:08:52,070 --> 00:08:55,490
traffic would be handled by a single

00:08:53,260 --> 00:08:56,279
single Kudus because the single red

00:08:55,490 --> 00:08:58,230
cutis get this

00:08:56,279 --> 00:09:00,180
one so it could provide us with some

00:08:58,230 --> 00:09:02,180
features to help all the traffic when

00:09:00,180 --> 00:09:05,819
all the traffic was under the same

00:09:02,180 --> 00:09:07,879
basically priority for the host but that

00:09:05,819 --> 00:09:10,199
was about all it could do at this point

00:09:07,879 --> 00:09:11,730
however this is the sort of the first

00:09:10,199 --> 00:09:14,670
step of what we needed as the overall

00:09:11,730 --> 00:09:16,230
friend so to set this up there were

00:09:14,670 --> 00:09:17,910
three key steps in terms of the

00:09:16,230 --> 00:09:19,920
implementation first is the

00:09:17,910 --> 00:09:23,399
initialization which actually happens

00:09:19,920 --> 00:09:24,839
when the at boot time so that would

00:09:23,399 --> 00:09:26,220
involve two steps which is the app

00:09:24,839 --> 00:09:28,889
initialization and the Pheonix

00:09:26,220 --> 00:09:30,029
allocation and then we'd have the second

00:09:28,889 --> 00:09:31,889
step which would happen when we enter

00:09:30,029 --> 00:09:33,839
switch step mode and when we have the

00:09:31,889 --> 00:09:37,920
third step which is actually when we set

00:09:33,839 --> 00:09:39,240
up the cue disks so in terms of the

00:09:37,920 --> 00:09:41,910
first step which was the initialization

00:09:39,240 --> 00:09:43,559
that that split up into two bits first

00:09:41,910 --> 00:09:45,930
is the initialization of the app app

00:09:43,559 --> 00:09:48,559
what we call the app so this is a this

00:09:45,930 --> 00:09:51,629
is really actually our driver specific

00:09:48,559 --> 00:09:53,189
piece of infrastructure so we have this

00:09:51,629 --> 00:09:54,839
concept called the app abstraction which

00:09:53,189 --> 00:09:57,449
allows us to reuse a lot of our driver

00:09:54,839 --> 00:10:00,829
infrastructure for different projects

00:09:57,449 --> 00:10:04,500
and different data paths so for example

00:10:00,829 --> 00:10:05,610
we would have things like ndo setup TC

00:10:04,500 --> 00:10:07,040
would do something different in this

00:10:05,610 --> 00:10:10,620
case than it would if we were running

00:10:07,040 --> 00:10:12,000
OVS by RTC flour that that's the kind of

00:10:10,620 --> 00:10:13,470
thing we do so a lot of the

00:10:12,000 --> 00:10:15,660
infrastructure code will look the same

00:10:13,470 --> 00:10:17,850
around those two cases but the actual

00:10:15,660 --> 00:10:19,740
final function that get cold will be

00:10:17,850 --> 00:10:24,809
different so it just allows a lot more

00:10:19,740 --> 00:10:27,839
reuse and a lot more configurability

00:10:24,809 --> 00:10:30,680
so that gets set up first we need to set

00:10:27,839 --> 00:10:33,899
up the app app structure fool this

00:10:30,680 --> 00:10:36,019
actual use case and then the second

00:10:33,899 --> 00:10:39,480
thing we need to do is we also need to

00:10:36,019 --> 00:10:41,670
set up a structure called the NFP IBM

00:10:39,480 --> 00:10:43,110
link which is something which gets used

00:10:41,670 --> 00:10:45,179
for hooking a lot of the infrastructure

00:10:43,110 --> 00:10:48,059
and we'll see more of that over the next

00:10:45,179 --> 00:10:49,379
door while there's also a bunch of

00:10:48,059 --> 00:10:50,550
checks which are quite important to do

00:10:49,379 --> 00:10:52,620
at this point otherwise you're going to

00:10:50,550 --> 00:10:53,579
have some weird gotchas first thing is

00:10:52,620 --> 00:10:55,139
you need to make sure that you actually

00:10:53,579 --> 00:10:56,910
have enough MAC addresses assigned to

00:10:55,139 --> 00:10:58,800
this device because of the fact that

00:10:56,910 --> 00:11:00,809
you've got a bunch of you've got a bunch

00:10:58,800 --> 00:11:03,629
of different house you're attached to so

00:11:00,809 --> 00:11:04,679
you need to actually have enough max to

00:11:03,629 --> 00:11:07,259
be able to handle what you're meant to

00:11:04,679 --> 00:11:09,750
be doing second thing is how you need to

00:11:07,259 --> 00:11:10,860
ensure you start the NIC in legacy mode

00:11:09,750 --> 00:11:14,880
at the moment obviously there might be

00:11:10,860 --> 00:11:16,470
use cases where people are not yet able

00:11:14,880 --> 00:11:18,540
to use this type of switch dev

00:11:16,470 --> 00:11:20,430
abstraction so you want to start the

00:11:18,540 --> 00:11:23,040
nicking legacy mode you don't start it

00:11:20,430 --> 00:11:25,830
in this kind of mode and then break

00:11:23,040 --> 00:11:28,020
someone's Orchestrator and the third

00:11:25,830 --> 00:11:30,090
thing is you also need to make sure that

00:11:28,020 --> 00:11:33,780
the MAC state doesn't follow the port

00:11:30,090 --> 00:11:35,730
because if you put a poor down on one of

00:11:33,780 --> 00:11:37,680
the four hosts and that takes your Mac

00:11:35,730 --> 00:11:39,450
down then you've hosed the other three

00:11:37,680 --> 00:11:41,550
hosts so there's just a bunch of really

00:11:39,450 --> 00:11:45,420
simple checks but things you need to do

00:11:41,550 --> 00:11:48,860
at this point then the next step is

00:11:45,420 --> 00:11:51,630
actually entering switch step mode so

00:11:48,860 --> 00:11:55,830
this really revolves around the concept

00:11:51,630 --> 00:11:59,760
of spawning the representives so this

00:11:55,830 --> 00:12:02,280
involves actually creating the required

00:11:59,760 --> 00:12:03,360
net depths and then what are one of the

00:12:02,280 --> 00:12:04,890
important things to know at this point

00:12:03,360 --> 00:12:06,000
is that the actual physical port

00:12:04,890 --> 00:12:07,770
representer is only going to get a

00:12:06,000 --> 00:12:10,920
single queue because of the fact that

00:12:07,770 --> 00:12:12,720
you aren't hooked up to an actual end

00:12:10,920 --> 00:12:15,120
device so that's just an important

00:12:12,720 --> 00:12:16,500
gotcha there as well and then you're

00:12:15,120 --> 00:12:18,600
gonna link up those nets to the

00:12:16,500 --> 00:12:20,670
representers once you've linked them up

00:12:18,600 --> 00:12:24,900
to the representers you'll then attach

00:12:20,670 --> 00:12:26,610
them to this APM link structure and then

00:12:24,900 --> 00:12:29,040
once you've done that once you've got

00:12:26,610 --> 00:12:31,410
all of this set up within the driver you

00:12:29,040 --> 00:12:33,450
will then actually initialize the

00:12:31,410 --> 00:12:35,550
firmware and so then at this point you

00:12:33,450 --> 00:12:39,660
are now you've now basically set up your

00:12:35,550 --> 00:12:41,850
friend your NIC is ready your NIC is set

00:12:39,660 --> 00:12:44,220
up in the switch dev mode and it's ready

00:12:41,850 --> 00:12:46,560
to be able to be able to have cue disks

00:12:44,220 --> 00:12:48,960
attached to it and the final thing is

00:12:46,560 --> 00:12:52,100
just to to attach the cue disk now in

00:12:48,960 --> 00:12:54,900
this first case this was actually a

00:12:52,100 --> 00:12:57,330
pretty simple setup you just had a

00:12:54,900 --> 00:13:02,580
single read cutest creature would attach

00:12:57,330 --> 00:13:04,410
and it was pretty useful because of the

00:13:02,580 --> 00:13:07,260
fact that suddenly when you do this you

00:13:04,410 --> 00:13:09,180
have all of the TC stats available as

00:13:07,260 --> 00:13:13,110
well so it's super useful for doing

00:13:09,180 --> 00:13:18,089
things like microbursts or other issues

00:13:13,110 --> 00:13:19,980
within the within the data path so the

00:13:18,089 --> 00:13:21,959
next step we then had was actually now

00:13:19,980 --> 00:13:23,960
extending this a little bit further so

00:13:21,959 --> 00:13:25,360
what we want to do in

00:13:23,960 --> 00:13:27,380
this section is really look at

00:13:25,360 --> 00:13:29,090
generalizing the queue discovered which

00:13:27,380 --> 00:13:31,010
is again this is part of the patches

00:13:29,090 --> 00:13:33,980
that are going up up at the moment this

00:13:31,010 --> 00:13:36,800
allows this needs some structure changes

00:13:33,980 --> 00:13:38,780
in the NFB IBM link structure as well as

00:13:36,800 --> 00:13:42,860
generalizing the statistical structure

00:13:38,780 --> 00:13:45,220
now once we've done that then we have

00:13:42,860 --> 00:13:47,810
suddenly this motivation to add in

00:13:45,220 --> 00:13:49,610
basically classifiers and we'll talk

00:13:47,810 --> 00:13:51,680
about that and describe some of the

00:13:49,610 --> 00:13:54,110
simple stuff around adding in

00:13:51,680 --> 00:13:55,520
classifiers there and then just very

00:13:54,110 --> 00:14:01,100
quickly jump through sort of how that

00:13:55,520 --> 00:14:02,960
architecture hooks in so what we have is

00:14:01,100 --> 00:14:05,240
before we basically had this setup here

00:14:02,960 --> 00:14:06,770
so in your a vm link structure which is

00:14:05,240 --> 00:14:10,910
kind of the structure which controls all

00:14:06,770 --> 00:14:13,520
of this setup you would have this single

00:14:10,910 --> 00:14:14,630
structure for the red cue disks and in

00:14:13,520 --> 00:14:18,260
there you would just have a very simple

00:14:14,630 --> 00:14:20,690
handle and some stats so this obviously

00:14:18,260 --> 00:14:22,580
is not a scalable model at this point in

00:14:20,690 --> 00:14:24,170
time so what we've done is we've created

00:14:22,580 --> 00:14:26,540
something which is a bit more scalable

00:14:24,170 --> 00:14:30,800
so effectively you have a route cue disk

00:14:26,540 --> 00:14:32,720
and with that you have the or hierarchy

00:14:30,800 --> 00:14:34,880
of cue disks and you have multiple types

00:14:32,720 --> 00:14:37,340
of cute this is a dummy structure

00:14:34,880 --> 00:14:39,140
there's gonna be more and more you just

00:14:37,340 --> 00:14:41,120
added to this but this is just like as a

00:14:39,140 --> 00:14:43,190
start just to show how the how the

00:14:41,120 --> 00:14:44,600
structures would look and it's important

00:14:43,190 --> 00:14:46,520
to note obvious you now have children

00:14:44,600 --> 00:14:47,690
and a whole hierarchy and so you're

00:14:46,520 --> 00:14:50,210
keeping track of this whole hierarchy

00:14:47,690 --> 00:14:51,590
and by definition you then also have

00:14:50,210 --> 00:14:54,170
stacks of this whole hierarchy which is

00:14:51,590 --> 00:14:56,660
and actually already found itself to be

00:14:54,170 --> 00:15:00,040
incredibly useful in environments where

00:14:56,660 --> 00:15:05,060
we've been debugging burstiness issues

00:15:00,040 --> 00:15:08,750
so once we have that done we suddenly

00:15:05,060 --> 00:15:10,990
have this ability to have different cue

00:15:08,750 --> 00:15:13,160
disks for different types of traffic and

00:15:10,990 --> 00:15:15,950
that means we suddenly need to have a

00:15:13,160 --> 00:15:17,390
classifier so if we want to be able to

00:15:15,950 --> 00:15:19,190
use this the fullest we need to have a

00:15:17,390 --> 00:15:22,010
classifier attached to the front of

00:15:19,190 --> 00:15:24,800
those egress representers because having

00:15:22,010 --> 00:15:26,960
that classifier will then allow us to be

00:15:24,800 --> 00:15:32,720
able to steer traffic as we want it to

00:15:26,960 --> 00:15:36,170
be steered so what we what we what we

00:15:32,720 --> 00:15:38,420
did then was we just as a very simple

00:15:36,170 --> 00:15:40,190
first cases we just added a very simple

00:15:38,420 --> 00:15:43,100
you thirty-two classified this is just

00:15:40,190 --> 00:15:44,990
simply for a easy case where there's

00:15:43,100 --> 00:15:47,750
just using we're just using a DHCP map

00:15:44,990 --> 00:15:50,149
to be able to steer traffic with respect

00:15:47,750 --> 00:15:52,639
to the priority as been given but this

00:15:50,149 --> 00:15:54,920
is obviously a a very first step and

00:15:52,639 --> 00:15:56,269
really what we want to get to is what

00:15:54,920 --> 00:15:57,980
I'm now really looking to cover in the

00:15:56,269 --> 00:16:01,600
next section this is what we're now

00:15:57,980 --> 00:16:03,829
getting to so once we have all of this

00:16:01,600 --> 00:16:06,949
complete and upstream we really have the

00:16:03,829 --> 00:16:08,870
foundation that's kind of the baseline

00:16:06,949 --> 00:16:10,790
for actually building the stuff we want

00:16:08,870 --> 00:16:12,500
to have so then we have the framework

00:16:10,790 --> 00:16:16,970
and now we can start attaching things to

00:16:12,500 --> 00:16:18,649
it so what we need to do is there's a

00:16:16,970 --> 00:16:21,860
couple of minor changes we need to make

00:16:18,649 --> 00:16:24,139
within the PPF jet and within a sort of

00:16:21,860 --> 00:16:30,370
PPF infrastructure and then there's one

00:16:24,139 --> 00:16:33,380
slightly larger sort of driver basically

00:16:30,370 --> 00:16:34,670
architecture change so that's that's a

00:16:33,380 --> 00:16:36,470
bit more of a significant one but we

00:16:34,670 --> 00:16:39,019
have those three things to do really and

00:16:36,470 --> 00:16:41,720
then we are ready to roll in effect with

00:16:39,019 --> 00:16:45,829
making something which is getting much

00:16:41,720 --> 00:16:47,540
much more complex so in terms of the

00:16:45,829 --> 00:16:49,399
firmware in the jet at the moment the

00:16:47,540 --> 00:16:53,420
way our Argent works is we effectively

00:16:49,399 --> 00:16:56,209
have a point in the NFP in the code

00:16:53,420 --> 00:16:58,640
store where the programs get put so if

00:16:56,209 --> 00:17:00,800
you are writing a PPF program you write

00:16:58,640 --> 00:17:03,290
your PPF program gets compiled down into

00:17:00,800 --> 00:17:05,839
NFP assembler our driver then takes that

00:17:03,290 --> 00:17:08,809
NFP assembler and it puts it in a very

00:17:05,839 --> 00:17:10,640
specific location in the in the Nick and

00:17:08,809 --> 00:17:13,220
I've always started this at a specific

00:17:10,640 --> 00:17:15,980
offset now we're doing is we're adding

00:17:13,220 --> 00:17:18,260
in a much more flexible way of doing

00:17:15,980 --> 00:17:21,049
this so that you effectively have a very

00:17:18,260 --> 00:17:24,740
simple jump table which tells you which

00:17:21,049 --> 00:17:26,209
ports require which programs so you have

00:17:24,740 --> 00:17:28,130
a set of programs which sit there

00:17:26,209 --> 00:17:30,559
because of the fact that many programs

00:17:28,130 --> 00:17:32,000
could potentially be shared and the

00:17:30,559 --> 00:17:35,540
example we'll be looking at later will

00:17:32,000 --> 00:17:37,130
use a lot of shared code this will allow

00:17:35,540 --> 00:17:39,590
us to significantly save on code store

00:17:37,130 --> 00:17:42,710
and also by dynamically loading helpers

00:17:39,590 --> 00:17:45,710
we won't waste code store for help as we

00:17:42,710 --> 00:17:48,799
won't be using so by setting this all up

00:17:45,710 --> 00:17:50,010
we give ourselves the best chance to be

00:17:48,799 --> 00:17:53,040
able to offload as much as

00:17:50,010 --> 00:17:54,630
we can so we have about 16k worth of

00:17:53,040 --> 00:17:57,270
code store here which is available for

00:17:54,630 --> 00:18:00,540
this so that allows us to offload a

00:17:57,270 --> 00:18:02,040
pretty significant amount of code the

00:18:00,540 --> 00:18:03,720
final thing to note is also I've just

00:18:02,040 --> 00:18:04,980
put a little note here the pre

00:18:03,720 --> 00:18:07,770
classified which I haven't actually

00:18:04,980 --> 00:18:09,660
spoken about are a bunch of sort of

00:18:07,770 --> 00:18:11,880
small hardware classifiers which do a

00:18:09,660 --> 00:18:14,430
lot of the same jobs actually that Syed

00:18:11,880 --> 00:18:16,230
and PJ were talking about yesterday they

00:18:14,430 --> 00:18:17,670
kind of give us offsets in the pattern

00:18:16,230 --> 00:18:20,370
in terms of where the packet different

00:18:17,670 --> 00:18:21,870
headers start and and add a bunch of

00:18:20,370 --> 00:18:24,720
metadata and the other thing they also

00:18:21,870 --> 00:18:27,210
do is they load-balanced the packets

00:18:24,720 --> 00:18:28,620
across the flow processing course so

00:18:27,210 --> 00:18:31,320
that were able to actually load banners

00:18:28,620 --> 00:18:33,180
the packets at that level and what we

00:18:31,320 --> 00:18:35,880
can potentially do with these if we want

00:18:33,180 --> 00:18:38,010
to isolate specific flow processing

00:18:35,880 --> 00:18:40,290
course to specific hosts we can use

00:18:38,010 --> 00:18:41,700
these to basically partition the NIC if

00:18:40,290 --> 00:18:46,710
that becomes something which in the end

00:18:41,700 --> 00:18:48,360
of the day we decide is is useful and

00:18:46,710 --> 00:18:50,310
finally this then gives us all the

00:18:48,360 --> 00:18:53,310
infrastructure we need to start adding

00:18:50,310 --> 00:18:55,350
in a CL sppf apart from one thing

00:18:53,310 --> 00:18:57,090
the one thing we're missing is that at

00:18:55,350 --> 00:18:58,470
the moment the I remember the app

00:18:57,090 --> 00:19:02,100
abstraction thing I was describing

00:18:58,470 --> 00:19:05,310
earlier at the moment vpf is its own app

00:19:02,100 --> 00:19:07,320
abstraction so it is effectively one of

00:19:05,310 --> 00:19:09,750
these quote-unquote flavors we have

00:19:07,320 --> 00:19:13,410
within the NIC so you can be running BPF

00:19:09,750 --> 00:19:16,140
or you can be running OVS TC or you can

00:19:13,410 --> 00:19:18,240
be running the initial version of the

00:19:16,140 --> 00:19:19,620
switch dev offload with adapter buffer

00:19:18,240 --> 00:19:22,200
management we've been talking about here

00:19:19,620 --> 00:19:24,660
however and I think this is part of this

00:19:22,200 --> 00:19:26,400
sort of progress of VP efforts we're now

00:19:24,660 --> 00:19:28,320
kind of moving beyond vpf just being

00:19:26,400 --> 00:19:31,500
used for sort of load balancing or DDoS

00:19:28,320 --> 00:19:33,480
or these very simple but these very

00:19:31,500 --> 00:19:35,040
specific use cases well we're now

00:19:33,480 --> 00:19:37,020
starting to see is we're using this as a

00:19:35,040 --> 00:19:40,140
tool we're using this as a tool to

00:19:37,020 --> 00:19:43,410
implement other things to use things in

00:19:40,140 --> 00:19:45,030
a much wider basis so what we need to do

00:19:43,410 --> 00:19:48,090
is we need to and this is going to be a

00:19:45,030 --> 00:19:51,120
a pretty painful piece of work for some

00:19:48,090 --> 00:19:55,140
people I suspect is actually move the

00:19:51,120 --> 00:19:56,790
app abstraction layer out so that BPF is

00:19:55,140 --> 00:19:58,380
no longer part of the upper structure

00:19:56,790 --> 00:20:01,130
BPF is actually part of the core

00:19:58,380 --> 00:20:03,169
infrastructure we have within our driver

00:20:01,130 --> 00:20:05,030
so that it can then be reused for

00:20:03,169 --> 00:20:07,940
different things and especially as

00:20:05,030 --> 00:20:09,710
things like OVS move towards BPF place

00:20:07,940 --> 00:20:12,200
data part there will be all kinds of

00:20:09,710 --> 00:20:14,059
places where we're using this and if we

00:20:12,200 --> 00:20:16,100
really get to the final objective which

00:20:14,059 --> 00:20:18,890
we'll get to in a little bit of actually

00:20:16,100 --> 00:20:20,870
having this as a fully BPF to find sort

00:20:18,890 --> 00:20:23,240
of data path then we're going to get to

00:20:20,870 --> 00:20:30,380
the point of needing to use this many

00:20:23,240 --> 00:20:32,360
more places so the next so that gets us

00:20:30,380 --> 00:20:35,630
to the point of having multiple cue

00:20:32,360 --> 00:20:38,179
disks having CLS BPF there to access a

00:20:35,630 --> 00:20:40,580
classifier to decide which accuses to

00:20:38,179 --> 00:20:44,240
use for different traffic as it comes in

00:20:40,580 --> 00:20:46,159
we have the switch dev architecture set

00:20:44,240 --> 00:20:48,280
up so that we have different

00:20:46,159 --> 00:20:52,730
representatives for different logical

00:20:48,280 --> 00:20:54,890
ports within our neck and now we need to

00:20:52,730 --> 00:20:58,760
add in the last bit of this puzzle which

00:20:54,890 --> 00:21:00,789
is actually a starting to add in xtp so

00:20:58,760 --> 00:21:03,049
there are a couple of problems that are

00:21:00,789 --> 00:21:04,850
relatively they if these are not

00:21:03,049 --> 00:21:07,700
insurmountable problems for this use

00:21:04,850 --> 00:21:09,289
case and they're not insurmountable for

00:21:07,700 --> 00:21:11,690
the very specific reason that we now

00:21:09,289 --> 00:21:13,039
have all of these representers the first

00:21:11,690 --> 00:21:15,590
one of these is obviously that obviously

00:21:13,039 --> 00:21:18,620
XDP is an Rx exclusive hook you can't

00:21:15,590 --> 00:21:20,179
run XTP on TX right now that's not

00:21:18,620 --> 00:21:24,620
something and and there's good reasons

00:21:20,179 --> 00:21:26,270
for that so because of the fact that

00:21:24,620 --> 00:21:29,110
we've set up this architecture with all

00:21:26,270 --> 00:21:33,860
these points we can actually hook in now

00:21:29,110 --> 00:21:36,409
xdp on the receive side of our switch

00:21:33,860 --> 00:21:38,630
ports of our logical switch ports for

00:21:36,409 --> 00:21:41,780
each one of the modular snakes and by

00:21:38,630 --> 00:21:43,700
then using things like redirect that we

00:21:41,780 --> 00:21:45,799
suddenly have a forwarding plane to find

00:21:43,700 --> 00:21:50,450
so we're actually able to define our

00:21:45,799 --> 00:21:52,130
forwarding plane using xdp and so that's

00:21:50,450 --> 00:21:54,380
a pretty powerful thing to be able to do

00:21:52,130 --> 00:21:56,600
now the second challenge we have in this

00:21:54,380 --> 00:22:00,340
case is obviously now we have our

00:21:56,600 --> 00:22:02,600
support and we've got a sort of uniquely

00:22:00,340 --> 00:22:03,440
good architecture to be able to run this

00:22:02,600 --> 00:22:06,110
kind of thing right now

00:22:03,440 --> 00:22:08,090
but other heterogeneous architectures

00:22:06,110 --> 00:22:09,620
the support for this is nascent but this

00:22:08,090 --> 00:22:12,080
is something which people are working on

00:22:09,620 --> 00:22:14,010
so I mean like this stuff that I think

00:22:12,080 --> 00:22:15,930
PJ mentioned yesterday with more flex of

00:22:14,010 --> 00:22:18,780
or Nick's coming in which can

00:22:15,930 --> 00:22:21,270
potentially do some of this kind of work

00:22:18,780 --> 00:22:22,770
by having a simple jet which allows them

00:22:21,270 --> 00:22:27,030
to offload these types of programs could

00:22:22,770 --> 00:22:28,470
potentially be very powerful and having

00:22:27,030 --> 00:22:31,710
that heterogeneous support is always

00:22:28,470 --> 00:22:32,970
going to be great and the final thing I

00:22:31,710 --> 00:22:35,460
wanted to mention they're also a

00:22:32,970 --> 00:22:37,020
security now this ironically will no

00:22:35,460 --> 00:22:38,820
this won't be a problem for true

00:22:37,020 --> 00:22:40,740
switches for true switches you have your

00:22:38,820 --> 00:22:43,320
control CPU which sits there on the

00:22:40,740 --> 00:22:48,270
switch and that can be the thing running

00:22:43,320 --> 00:22:50,340
all of it but if you have a five port

00:22:48,270 --> 00:22:52,550
here and you're hooking xdp programs on

00:22:50,340 --> 00:22:55,500
to it you've got to trust the other

00:22:52,550 --> 00:22:59,010
three hosts that are sitting there with

00:22:55,500 --> 00:23:01,230
you because if you can't trust them and

00:22:59,010 --> 00:23:02,610
host from Judea zero decides that he's

00:23:01,230 --> 00:23:04,530
going to take all the traffic actually

00:23:02,610 --> 00:23:06,900
meant for his three then you obviously

00:23:04,530 --> 00:23:08,880
have some significant problems so this

00:23:06,900 --> 00:23:10,140
has to be in a trusted environment now

00:23:08,880 --> 00:23:11,760
there are a couple of ways around this

00:23:10,140 --> 00:23:15,420
the first one is the one which we

00:23:11,760 --> 00:23:17,550
described with actually I'm going to

00:23:15,420 --> 00:23:19,320
just keep it there with it being a real

00:23:17,550 --> 00:23:20,550
switch and the second one is obviously

00:23:19,320 --> 00:23:22,560
if you're using this with bare metal

00:23:20,550 --> 00:23:25,320
Nick's so bare metal Nick's have their

00:23:22,560 --> 00:23:27,450
own arm system sitting there and they

00:23:25,320 --> 00:23:28,860
can then control this but a lot of

00:23:27,450 --> 00:23:30,480
places in a lot of places we've seen

00:23:28,860 --> 00:23:32,160
this kind of architecture there is this

00:23:30,480 --> 00:23:33,900
trusted environment like everyone is

00:23:32,160 --> 00:23:36,480
able to trust everybody else involved

00:23:33,900 --> 00:23:39,690
here and if worse comes to worst you can

00:23:36,480 --> 00:23:41,370
always find some more find a different

00:23:39,690 --> 00:23:42,990
way to be able to add had that in there

00:23:41,370 --> 00:23:44,640
but that's not something we've really

00:23:42,990 --> 00:23:46,170
thought about far enough to be able to

00:23:44,640 --> 00:23:50,160
come up with a different proposal there

00:23:46,170 --> 00:23:51,810
at this point in time and also now being

00:23:50,160 --> 00:23:54,240
able to add and so I would think David

00:23:51,810 --> 00:23:56,310
spoke yesterday about things like fit

00:23:54,240 --> 00:23:58,050
able access being able to add that kind

00:23:56,310 --> 00:24:00,180
of stuff into this suddenly you have

00:23:58,050 --> 00:24:03,150
your whole switch architecture there you

00:24:00,180 --> 00:24:07,350
have everything to find you need so now

00:24:03,150 --> 00:24:08,760
you have a BPF defined data plane that's

00:24:07,350 --> 00:24:12,600
able to give you quality of service

00:24:08,760 --> 00:24:14,340
starts and you're able to read are right

00:24:12,600 --> 00:24:17,310
things and define the forwarding plane

00:24:14,340 --> 00:24:20,310
with PPF and that's that's that's really

00:24:17,310 --> 00:24:22,170
where we were trying to get to now we're

00:24:20,310 --> 00:24:23,490
about a third of the way there with that

00:24:22,170 --> 00:24:26,310
there's a lot of work to be done before

00:24:23,490 --> 00:24:27,809
we get there but it's something which I

00:24:26,310 --> 00:24:30,989
think we wanted to share

00:24:27,809 --> 00:24:32,609
and start moving forward at the

00:24:30,989 --> 00:24:35,159
community so everybody understands where

00:24:32,609 --> 00:24:36,269
we're trying to go with this stuff and I

00:24:35,159 --> 00:24:37,919
know if we see that then means that

00:24:36,269 --> 00:24:40,229
people will have more context when they

00:24:37,919 --> 00:24:43,639
start seeing stuff moving forward and I

00:24:40,229 --> 00:24:46,200
think that's that's kind of important so

00:24:43,639 --> 00:24:47,580
there's obviously going to be more stuff

00:24:46,200 --> 00:24:49,049
coming here and there's going to be a

00:24:47,580 --> 00:24:51,799
bunch of issues and a bunch of questions

00:24:49,049 --> 00:24:54,389
but that is just to give people an idea

00:24:51,799 --> 00:24:56,309
now who is going to talk I'm gonna give

00:24:54,389 --> 00:24:58,019
him a shameless plug for his chat

00:24:56,309 --> 00:24:59,999
tomorrow at micro conference where he's

00:24:58,019 --> 00:25:03,269
gonna be talking about hydrogenous

00:24:59,999 --> 00:25:05,669
architectures for BPF and trying to move

00:25:03,269 --> 00:25:08,249
this to more different types of

00:25:05,669 --> 00:25:09,839
architectures like switches and other

00:25:08,249 --> 00:25:11,789
other types of things that are out there

00:25:09,839 --> 00:25:14,460
so I think that's a really important

00:25:11,789 --> 00:25:15,839
thing to take further and finally I just

00:25:14,460 --> 00:25:18,479
want to give credit to the team these

00:25:15,839 --> 00:25:22,169
are the guys doing the real work I just

00:25:18,479 --> 00:25:24,299
get to talk and smile so oh and finally

00:25:22,169 --> 00:25:25,919
I wanted to also thank the conference

00:25:24,299 --> 00:25:37,320
stuff because they're the only reason I

00:25:25,919 --> 00:25:40,139
have a clean t-shirt today thank you so

00:25:37,320 --> 00:25:44,279
we pre classifier is a psychologic yes

00:25:40,139 --> 00:25:47,309
yes we have a set of 48 to 96 small

00:25:44,279 --> 00:25:49,979
Asics which basically sift as you come

00:25:47,309 --> 00:25:52,349
in right by the fire and spread packets

00:25:49,979 --> 00:25:53,609
around and they add a lot of the logic

00:25:52,349 --> 00:25:56,249
that like Sid was talking about

00:25:53,609 --> 00:25:58,169
yesterday where you have the basically

00:25:56,249 --> 00:26:01,649
the point is to the right places in the

00:25:58,169 --> 00:26:03,479
packet I see yeah he knows more trust

00:26:01,649 --> 00:26:05,339
and more just becomes relevant when you

00:26:03,479 --> 00:26:08,460
start talking about stuff like the xdp

00:26:05,339 --> 00:26:09,749
hints like the the metadata the Dupre

00:26:08,460 --> 00:26:13,259
classifier outputs

00:26:09,749 --> 00:26:15,210
it's it's in itself so compressed and

00:26:13,259 --> 00:26:17,309
hard to hard to use some former

00:26:15,210 --> 00:26:18,960
engineers actually reclassify the

00:26:17,309 --> 00:26:21,029
package themselves cause like just

00:26:18,960 --> 00:26:23,099
unpacking the structure is that the hint

00:26:21,029 --> 00:26:31,519
is so complicated in the zone was like

00:26:23,099 --> 00:26:31,519
yeah thanks any other questions for Nick

00:26:32,980 --> 00:26:42,769
okay okay oh man you almost escaped yeah

00:26:38,330 --> 00:26:44,450
I thought I got away if I got one of

00:26:42,769 --> 00:26:47,539
your first lights right didn't chip

00:26:44,450 --> 00:26:49,279
supports like 40 ports one of the chips

00:26:47,539 --> 00:26:51,820
has a huge amount of poor tonight yes

00:26:49,279 --> 00:26:54,559
and are you planning to support

00:26:51,820 --> 00:26:56,360
allocating them dynamically to the to

00:26:54,559 --> 00:26:59,090
each host like your examples had only

00:26:56,360 --> 00:27:00,679
one part allocated to them so so I apply

00:26:59,090 --> 00:27:03,440
this I'm in physical port so there's

00:27:00,679 --> 00:27:06,259
actually like you can have 40 input

00:27:03,440 --> 00:27:08,419
poles go okay like a switch tile type

00:27:06,259 --> 00:27:10,700
thing because there are there are use

00:27:08,419 --> 00:27:12,860
cases where we have applications which

00:27:10,700 --> 00:27:14,899
have a huge amount of very small input

00:27:12,860 --> 00:27:18,830
ports like we'll have 40 hundred make

00:27:14,899 --> 00:27:20,179
ports coming into the one chip but

00:27:18,830 --> 00:27:22,370
that's also relevant when we're talking

00:27:20,179 --> 00:27:25,940
about cases where suddenly we have four

00:27:22,370 --> 00:27:28,159
or or 825 big ports coming into one

00:27:25,940 --> 00:27:30,649
device because people are hooking their

00:27:28,159 --> 00:27:32,210
NICs into a huge amount of switches in

00:27:30,649 --> 00:27:34,159
next host network that's that's what's

00:27:32,210 --> 00:27:37,669
on that of that side where I was discard

00:27:34,159 --> 00:27:39,529
describing this and on the host side but

00:27:37,669 --> 00:27:41,059
do we have more parts because it seems

00:27:39,529 --> 00:27:43,549
it would be interesting to allocate

00:27:41,059 --> 00:27:45,559
these parts directly to our guests for

00:27:43,549 --> 00:27:46,940
example are you talking about you're

00:27:45,559 --> 00:27:48,740
talking about if you have a virtualized

00:27:46,940 --> 00:27:51,350
case yeah I'll serve you or something

00:27:48,740 --> 00:27:53,509
okay so I mean there are a bunch of vs

00:27:51,350 --> 00:27:55,730
there as well so at the moment I was

00:27:53,509 --> 00:27:57,830
only describing physical functions but

00:27:55,730 --> 00:28:00,740
you could potentially hook in SRV on top

00:27:57,830 --> 00:28:02,059
of this yes and then attach that to a

00:28:00,740 --> 00:28:09,259
bunch of yes there's no reason why you

00:28:02,059 --> 00:28:11,720
couldn't do that so why are you only

00:28:09,259 --> 00:28:14,990
supporting red as a tutor to offload we

00:28:11,720 --> 00:28:16,370
can do better than that now yeah yeah

00:28:14,990 --> 00:28:19,429
that's this is not this that's

00:28:16,370 --> 00:28:21,139
definitely not the end game we started

00:28:19,429 --> 00:28:22,759
off with red because there was some very

00:28:21,139 --> 00:28:24,769
specific application for which would be

00:28:22,759 --> 00:28:27,080
very useful what we're dealing with

00:28:24,769 --> 00:28:31,610
customers in fact multiple customers are

00:28:27,080 --> 00:28:34,429
using things related to red we also have

00:28:31,610 --> 00:28:37,789
cases like gee red where you've got

00:28:34,429 --> 00:28:38,929
multiple different basically queues

00:28:37,789 --> 00:28:41,240
which are all red but with different

00:28:38,929 --> 00:28:44,060
thresholds and different actions like

00:28:41,240 --> 00:28:46,280
drops or marks with ACN mark

00:28:44,060 --> 00:28:48,230
that kind of thing there's also other

00:28:46,280 --> 00:28:49,550
cue disk will definitely be looking at

00:28:48,230 --> 00:28:56,390
yeah as we're going forward into the

00:28:49,550 --> 00:28:58,760
future like token bucket type stuff so I

00:28:56,390 --> 00:29:01,490
have a question about those specialized

00:28:58,760 --> 00:29:04,280
classifiers that you mentioned so the

00:29:01,490 --> 00:29:06,950
data is produced out of those metadata

00:29:04,280 --> 00:29:10,820
the hints whatever we call it do we

00:29:06,950 --> 00:29:14,180
expose it to the the EBP F program is

00:29:10,820 --> 00:29:16,130
the DPF program aware of those not right

00:29:14,180 --> 00:29:18,140
now now okay no so we're not we're not

00:29:16,130 --> 00:29:19,850
actually using those and and that's why

00:29:18,140 --> 00:29:21,740
something like the XP and stuff which

00:29:19,850 --> 00:29:23,480
the guys are describing would also be

00:29:21,740 --> 00:29:26,210
useful for us even in the offloaded case

00:29:23,480 --> 00:29:27,530
because we could then actually use that

00:29:26,210 --> 00:29:30,320
infrastructure and all that stuff we

00:29:27,530 --> 00:29:32,360
have there and reuse it in this in this

00:29:30,320 --> 00:29:35,810
way which is something we don't really

00:29:32,360 --> 00:29:37,430
do today okay now we do and yeah there's

00:29:35,810 --> 00:29:39,740
you know there's some ways we maybe use

00:29:37,430 --> 00:29:41,540
it but it's not really used today now we

00:29:39,740 --> 00:29:44,170
could certainly do more with it okay

00:29:41,540 --> 00:29:44,170
thanks

00:29:46,660 --> 00:29:58,180
ready so what application manages this

00:29:54,640 --> 00:30:02,380
switch I say that again sorry which

00:29:58,180 --> 00:30:05,440
application are using to manage to so to

00:30:02,380 --> 00:30:06,910
orchestrate today or so today most of

00:30:05,440 --> 00:30:09,430
the multi-ethnic just work through a

00:30:06,910 --> 00:30:11,320
simple self-learning our to switch so

00:30:09,430 --> 00:30:13,330
effectively it's just a very simple math

00:30:11,320 --> 00:30:14,670
learning switch which just switches the

00:30:13,330 --> 00:30:18,310
packets that's what's happening today

00:30:14,670 --> 00:30:21,280
now over time the whole point would be

00:30:18,310 --> 00:30:23,290
to be able to use X DP as a forwarding

00:30:21,280 --> 00:30:24,700
plane and then to do that that would

00:30:23,290 --> 00:30:26,200
obviously be done water whatever the

00:30:24,700 --> 00:30:29,860
host is using to control the x DP

00:30:26,200 --> 00:30:32,770
programs so as of today it's a very

00:30:29,860 --> 00:30:34,810
simple l2 Maki learning switch just

00:30:32,770 --> 00:30:37,270
punch the packets according to the MAC

00:30:34,810 --> 00:30:38,740
address and then in the future that

00:30:37,270 --> 00:30:40,480
would be for our customers to decide

00:30:38,740 --> 00:30:41,950
that's not for us to decide the whole

00:30:40,480 --> 00:30:43,780
idea is we're providing this thing and

00:30:41,950 --> 00:30:45,010
it's software-defined so that our

00:30:43,780 --> 00:30:53,680
customers are able to write their

00:30:45,010 --> 00:30:54,740
software anyone else thank you very much

00:30:53,680 --> 00:31:00,319
Nick

00:30:54,740 --> 00:31:00,319

YouTube URL: https://www.youtube.com/watch?v=Xa8BQoZ67r4


