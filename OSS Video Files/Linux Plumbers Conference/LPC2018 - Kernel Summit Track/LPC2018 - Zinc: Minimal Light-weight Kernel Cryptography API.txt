Title: LPC2018 - Zinc: Minimal Light-weight Kernel Cryptography API
Publication date: 2018-12-04
Playlist: LPC2018 - Kernel Summit Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/254/
speaker:  Jason Donenfeld
Captions: 
	00:00:05,600 --> 00:00:14,580
okay so this is on zinc which is a new

00:00:09,900 --> 00:00:18,360
crypto API for Colonel that is less of

00:00:14,580 --> 00:00:25,829
an API and more of a collection of

00:00:18,360 --> 00:00:28,520
functions background I'm Jason my

00:00:25,829 --> 00:00:33,000
background is mostly in exploitation

00:00:28,520 --> 00:00:35,850
colonel bones crypto golds doing a lot

00:00:33,000 --> 00:00:38,340
of kernel related development cricket

00:00:35,850 --> 00:00:39,329
related development for a long time and

00:00:38,340 --> 00:00:41,640
the last couple years I've been working

00:00:39,329 --> 00:00:45,539
on wire guard there's a presentation on

00:00:41,640 --> 00:00:48,530
tomorrow which is an internal you get

00:00:45,539 --> 00:00:51,870
protocol that has motivated this API

00:00:48,530 --> 00:00:53,879
just quick overview before you jump into

00:00:51,870 --> 00:00:56,609
the zinc wire guard is supposed to be

00:00:53,879 --> 00:00:59,749
less than 4,000 line code easily

00:00:56,609 --> 00:01:02,460
implemented with basic data structures

00:00:59,749 --> 00:01:06,330
Marga itself is supposed to be easily

00:01:02,460 --> 00:01:09,210
implementable using obvious clear coding

00:01:06,330 --> 00:01:10,320
patterns we want minimal state we don't

00:01:09,210 --> 00:01:12,090
want to make any dynamic memory

00:01:10,320 --> 00:01:13,800
allocations

00:01:12,090 --> 00:01:15,960
it's supposed to be stealthy having been

00:01:13,800 --> 00:01:20,430
will attack surface and so the question

00:01:15,960 --> 00:01:23,880
for the crypto is can we achieve wire

00:01:20,430 --> 00:01:26,400
guards security objectives and and

00:01:23,880 --> 00:01:29,570
suppose the objectives using the current

00:01:26,400 --> 00:01:29,570
day crypto API

00:01:31,750 --> 00:01:37,690
and I found it was impossible which is

00:01:35,320 --> 00:01:41,350
why we have this so just to kind of show

00:01:37,690 --> 00:01:43,420
a case study of some problems ran into

00:01:41,350 --> 00:01:47,200
with Kirk crypto API before you look

00:01:43,420 --> 00:01:51,310
into how the new one works let's look at

00:01:47,200 --> 00:01:54,100
B key dot C so I was kind of randomly

00:01:51,310 --> 00:01:56,080
perusing the kernel a while ago and ran

00:01:54,100 --> 00:02:00,340
into this file vicky dusty and it had

00:01:56,080 --> 00:02:04,300
like a million bugs really no quality so

00:02:00,340 --> 00:02:08,890
that the basic idea is they're supposed

00:02:04,300 --> 00:02:12,550
to store a key in memory but then

00:02:08,890 --> 00:02:15,340
encrypt some data on disk using that so

00:02:12,550 --> 00:02:17,290
I guess it's if you want to store like

00:02:15,340 --> 00:02:18,970
really massive key in the kernels

00:02:17,290 --> 00:02:21,280
keyring but you don't want to fit that

00:02:18,970 --> 00:02:23,050
one Ram and so you could write out the

00:02:21,280 --> 00:02:26,140
cipher text to disk and then store

00:02:23,050 --> 00:02:29,800
encryption key somewhere around um not a

00:02:26,140 --> 00:02:31,180
very complicated idea but the original /

00:02:29,800 --> 00:02:37,930
- I was using was totally broken use

00:02:31,180 --> 00:02:40,300
like ECB mode so like there is encrypted

00:02:37,930 --> 00:02:42,520
using GP mode and it's still penguin

00:02:40,300 --> 00:02:44,260
obviously there wasn't any

00:02:42,520 --> 00:02:47,170
authentication so you could modify the

00:02:44,260 --> 00:02:50,320
contents it's the cipher text on disk

00:02:47,170 --> 00:02:52,270
and it would be undetectable it didn't

00:02:50,320 --> 00:02:56,350
use randomness and in the right way so

00:02:52,270 --> 00:02:58,989
keys were probably predictable - it

00:02:56,350 --> 00:03:01,930
reused keys across encryption unsafe way

00:02:58,989 --> 00:03:06,580
it didn't zero he's out I mean it was

00:03:01,930 --> 00:03:07,570
just like a bastard lots of CPUs and so

00:03:06,580 --> 00:03:10,000
I thought like ok great

00:03:07,570 --> 00:03:11,769
here's something that's really you know

00:03:10,000 --> 00:03:13,959
kind of messed up and now I can rewrite

00:03:11,769 --> 00:03:18,220
it using the old crypto API and then

00:03:13,959 --> 00:03:21,550
maybe I'll learn how that API works well

00:03:18,220 --> 00:03:25,020
enough that I can I can use it Margar so

00:03:21,550 --> 00:03:28,380
I did the best I could in

00:03:25,020 --> 00:03:29,630
I know so let's see what that looked

00:03:28,380 --> 00:03:31,830
like

00:03:29,630 --> 00:03:37,980
so the first thing we got to do is

00:03:31,830 --> 00:03:41,850
define the cipher so in this case we use

00:03:37,980 --> 00:03:45,210
a yes GCM and we have to allocate that

00:03:41,850 --> 00:03:47,220
and so you'll notice it's got this it's

00:03:45,210 --> 00:03:49,140
like crazy descriptor

00:03:47,220 --> 00:03:51,480
it's got like a domain-specific language

00:03:49,140 --> 00:03:53,970
for specifying which one you want and

00:03:51,480 --> 00:03:59,090
the liking construct it into arbitrary

00:03:53,970 --> 00:04:01,110
complexity just serious is a thing

00:03:59,090 --> 00:04:04,640
confusingly that's actually a flag that

00:04:01,110 --> 00:04:10,730
says we don't want it to be a sink

00:04:04,640 --> 00:04:13,850
it's a man sink it's been okay it's an

00:04:10,730 --> 00:04:15,870
authentication tag after we dock it

00:04:13,850 --> 00:04:18,630
okay so then when it comes time to

00:04:15,870 --> 00:04:22,350
actually encrypt we have to allocate

00:04:18,630 --> 00:04:30,480
another object for the actual friction

00:04:22,350 --> 00:04:32,040
request so this is not good for the wire

00:04:30,480 --> 00:04:36,450
because we don't want to be allocating

00:04:32,040 --> 00:04:38,760
memory ever in response to packets and

00:04:36,450 --> 00:04:41,120
in general I mean you know it's as slow

00:04:38,760 --> 00:04:41,120
as not

00:04:43,590 --> 00:04:50,550
it uses all scatter gather lists which

00:04:46,620 --> 00:04:52,110
means that we we can't encrypt things

00:04:50,550 --> 00:04:55,320
that are on the stack we can't encrypt

00:04:52,110 --> 00:05:01,290
via Malik the dresses which makes things

00:04:55,320 --> 00:05:02,730
really cumbersome so ok so we so yeah we

00:05:01,290 --> 00:05:04,620
allocate the thing that we can set up

00:05:02,730 --> 00:05:07,110
this gotta gather at Lisbon don't

00:05:04,620 --> 00:05:10,410
believe we could set Crick's where we

00:05:07,110 --> 00:05:12,420
passed this in and we tell it that the

00:05:10,410 --> 00:05:13,950
additional data has a length of 0 if

00:05:12,420 --> 00:05:16,170
this was positive that would mean the

00:05:13,950 --> 00:05:18,030
additional data is like part of what we

00:05:16,170 --> 00:05:22,220
tell it to which is also confusing

00:05:18,030 --> 00:05:24,480
and then it's all callback base so then

00:05:22,220 --> 00:05:27,170
usually we'd get the callback here but

00:05:24,480 --> 00:05:29,310
because we specified that it's not a

00:05:27,170 --> 00:05:31,140
synchronous earlier and we just a

00:05:29,310 --> 00:05:35,640
callback to null which is like further

00:05:31,140 --> 00:05:38,520
confusing so then this is the part that

00:05:35,640 --> 00:05:41,460
that really is a hinderance which is

00:05:38,520 --> 00:05:43,620
that the key is not attached to the

00:05:41,460 --> 00:05:45,510
request object we just allocated it's

00:05:43,620 --> 00:05:46,190
attached to the instance of the actual

00:05:45,510 --> 00:05:50,070
siker

00:05:46,190 --> 00:05:51,720
so that means if you only have one

00:05:50,070 --> 00:05:55,110
instance of the actual cipher we have to

00:05:51,720 --> 00:05:56,850
have a bomb around just using it it's

00:05:55,110 --> 00:06:00,300
like another thread wants to do it too

00:05:56,850 --> 00:06:03,270
or you have to have like per CPU pools

00:06:00,300 --> 00:06:06,840
of this or allocate a new one every time

00:06:03,270 --> 00:06:08,100
we wanted it and and so for something

00:06:06,840 --> 00:06:09,570
like yr Gargery we have like tons

00:06:08,100 --> 00:06:11,940
different keys happening from all over

00:06:09,570 --> 00:06:13,380
the place all the time there's a lot

00:06:11,940 --> 00:06:18,669
forward secrecy and that kind of thing

00:06:13,380 --> 00:06:23,580
this does not work well at all

00:06:18,669 --> 00:06:23,580
and you know it's just like more walking

00:06:24,719 --> 00:06:32,680
so okay this all worked pretty well

00:06:29,229 --> 00:06:37,389
there's a problem that big key likes to

00:06:32,680 --> 00:06:39,909
malloc around a megabyte work the work

00:06:37,389 --> 00:06:42,849
data and some systems you just can't now

00:06:39,909 --> 00:06:45,849
like a mega buddy usually the solution

00:06:42,849 --> 00:06:49,389
is if you need to that big of area use

00:06:45,849 --> 00:06:51,009
like a V yeah no doodle trying to came

00:06:49,389 --> 00:07:00,340
how off at the camp in an old Vienna

00:06:51,009 --> 00:07:04,810
Aachen you don't use the because you

00:07:00,340 --> 00:07:11,469
can't encrypt the Amalekites so they've

00:07:04,810 --> 00:07:16,930
held notice this and and and fixed it by

00:07:11,469 --> 00:07:18,819
writing a new allocator just for big

00:07:16,930 --> 00:07:24,009
heat at sea and like okay this is good

00:07:18,819 --> 00:07:26,710
code you know it's like really it does

00:07:24,009 --> 00:07:29,229
it the right way you know uh you can't

00:07:26,710 --> 00:07:30,969
do it better than this but like really I

00:07:29,229 --> 00:07:33,370
mean we're just trying to like encrypt a

00:07:30,969 --> 00:07:35,589
little buffer for some random like

00:07:33,370 --> 00:07:40,080
encrypted key tracker but yeah so if you

00:07:35,589 --> 00:07:43,839
know first yes to like came a lot like a

00:07:40,080 --> 00:07:45,909
buffer for the metadata and whatnot and

00:07:43,839 --> 00:07:46,150
then he can get the individual pages and

00:07:45,909 --> 00:07:54,580
then

00:07:46,150 --> 00:07:57,610
we map those this is crazy like it's

00:07:54,580 --> 00:07:59,410
really just all this trouble to encrypt

00:07:57,610 --> 00:08:02,560
a buffer with a post calm and

00:07:59,410 --> 00:08:04,570
authenticated encryption scheme yet we

00:08:02,560 --> 00:08:07,630
have to allocate you know once per

00:08:04,570 --> 00:08:09,490
decryption once key we can't use stack

00:08:07,630 --> 00:08:12,790
addresses via malloc the dresses there's

00:08:09,490 --> 00:08:16,030
this crazy string parsing thing to even

00:08:12,790 --> 00:08:19,230
specify what psycho rule one which kind

00:08:16,030 --> 00:08:22,300
of points toward infinite dangerous

00:08:19,230 --> 00:08:24,280
algorithm agility in general this is

00:08:22,300 --> 00:08:27,000
like a really crazy you know Enterprise

00:08:24,280 --> 00:08:29,410
API that's prone to failure in this use

00:08:27,000 --> 00:08:33,190
it kind of resembles the old-school

00:08:29,410 --> 00:08:35,140
win32 portunity I know I guess they came

00:08:33,190 --> 00:08:47,590
around the same area it seemed to craft

00:08:35,140 --> 00:08:49,720
and it it's hard to use so this III

00:08:47,590 --> 00:08:55,390
ported this to zinc and that the discus

00:08:49,720 --> 00:08:58,290
like this I I think the file is

00:08:55,390 --> 00:09:00,730
helpfully like 600 lines you know it's

00:08:58,290 --> 00:09:05,230
it really simplifies things because we

00:09:00,730 --> 00:09:11,440
don't have to do this crazy dance so the

00:09:05,230 --> 00:09:14,370
zinc solution is like a buffer where the

00:09:11,440 --> 00:09:14,370
data is gonna go

00:09:15,040 --> 00:09:20,600
he because I guess like the way the big

00:09:18,530 --> 00:09:26,260
Keys work is you attach these buffers to

00:09:20,600 --> 00:09:28,550
like I know again stuff we get the

00:09:26,260 --> 00:09:30,980
random key so this all here is like

00:09:28,550 --> 00:09:32,990
Nantes thing that Vicki wants to do

00:09:30,980 --> 00:09:34,850
there the one called a zinc is that line

00:09:32,990 --> 00:09:38,660
on the bottom or we just say encrypt BAM

00:09:34,850 --> 00:09:41,800
done and it does it because most

00:09:38,660 --> 00:09:44,720
cryptography is like pure C is just

00:09:41,800 --> 00:09:47,600
functions that you take some bytes in

00:09:44,720 --> 00:09:50,450
and you do a bunch of operations to it

00:09:47,600 --> 00:09:54,650
and then you put it in another buffer of

00:09:50,450 --> 00:09:57,410
bytes like it ohana crypto is not you

00:09:54,650 --> 00:09:59,270
know particularly currently code it's

00:09:57,410 --> 00:10:02,900
just kind of these pure transformations

00:09:59,270 --> 00:10:07,510
so actually called is actually simple we

00:10:02,900 --> 00:10:07,510
put the buffer we pass it you know data

00:10:07,570 --> 00:10:15,310
and it does it and so the zinc is is to

00:10:12,680 --> 00:10:18,020
be not really more complicated that's

00:10:15,310 --> 00:10:19,190
there's not a lot of innovation here

00:10:18,020 --> 00:10:22,190
it's like we have this really

00:10:19,190 --> 00:10:24,230
complicated amazing crypto API that

00:10:22,190 --> 00:10:27,290
there's a million things but what about

00:10:24,230 --> 00:10:32,120
just straightforward synchronous

00:10:27,290 --> 00:10:33,830
software based the current crypto API

00:10:32,120 --> 00:10:36,200
needs that you know it could do

00:10:33,830 --> 00:10:38,450
accelerators and all that crazy stuff

00:10:36,200 --> 00:10:40,160
but ultimately it needs the software

00:10:38,450 --> 00:10:42,620
implementations and so it'd be nice to

00:10:40,160 --> 00:10:44,690
have really accessible ones to the

00:10:42,620 --> 00:10:49,310
brazilian places in the kernel that just

00:10:44,690 --> 00:10:54,400
one simple software base crypto so zinc

00:10:49,310 --> 00:10:58,190
is functions it's it's that's all it is

00:10:54,400 --> 00:11:01,670
I mean the the innovation that realizing

00:10:58,190 --> 00:11:05,490
that crypto doesn't need to be more

00:11:01,670 --> 00:11:07,649
complicated just for the software aspect

00:11:05,490 --> 00:11:10,350
so to start with for the initial

00:11:07,649 --> 00:11:12,689
submission we have the primitives that

00:11:10,350 --> 00:11:14,309
wire guard uses and then after we're

00:11:12,689 --> 00:11:16,259
going to start expanding out to the

00:11:14,309 --> 00:11:18,629
other primitives that are used in a

00:11:16,259 --> 00:11:20,939
bunch of places in the kernel there are

00:11:18,629 --> 00:11:25,040
many parts of the kernel that that do

00:11:20,939 --> 00:11:27,389
use the crazy like infinitely agile

00:11:25,040 --> 00:11:29,610
serve algorithms you know like that

00:11:27,389 --> 00:11:34,499
IPSec and you can like compose it in

00:11:29,610 --> 00:11:36,300
crazy ways but they're probably more

00:11:34,499 --> 00:11:39,059
parts to kernel that are using crypto

00:11:36,300 --> 00:11:41,730
algorithms that set this like I don't

00:11:39,059 --> 00:11:43,259
want any sync flag and what things just

00:11:41,730 --> 00:11:47,399
to be in software and synchronous and

00:11:43,259 --> 00:11:48,809
then quick and and kind of boring and so

00:11:47,399 --> 00:11:50,339
I think I gradually will be going

00:11:48,809 --> 00:11:53,179
through and adding whatever those are

00:11:50,339 --> 00:11:57,839
using to zinc's so that they can

00:11:53,179 --> 00:12:00,889
so yeah the top 223 cipher and the point

00:11:57,839 --> 00:12:03,259
one three or five time Mac that you can

00:12:00,889 --> 00:12:07,350
compose these together to get the

00:12:03,259 --> 00:12:09,959
quality construction like to is a is

00:12:07,350 --> 00:12:12,569
really fast hash function that's that's

00:12:09,959 --> 00:12:15,529
works great a little hardware we have

00:12:12,569 --> 00:12:19,559
curved 18:40

00:12:15,529 --> 00:12:22,910
so it's it's I mean it's what are their

00:12:19,559 --> 00:12:26,429
uses but it's actually kind of a neat

00:12:22,910 --> 00:12:27,480
breadth to start with because it handles

00:12:26,429 --> 00:12:32,040
a lot of different things we have like

00:12:27,480 --> 00:12:34,230
you know encryption macking hashing

00:12:32,040 --> 00:12:36,240
- snacking we've got some public key

00:12:34,230 --> 00:12:40,649
crypto I mean it's a good sampling of

00:12:36,240 --> 00:12:42,449
how the API forward so okay here's a

00:12:40,649 --> 00:12:43,949
real-world example from the wire guard

00:12:42,449 --> 00:12:48,089
of what hashing looks like so you can do

00:12:43,949 --> 00:12:51,569
it in one shot where you just follow it

00:12:48,089 --> 00:12:54,209
with with the input buffer and alpha

00:12:51,569 --> 00:12:55,889
buffer or in classic fashion there's

00:12:54,209 --> 00:12:57,720
like the in it to get it started and

00:12:55,889 --> 00:13:00,480
then you update it as you feed data into

00:12:57,720 --> 00:13:03,959
the hash function and the final to get

00:13:00,480 --> 00:13:09,329
the actual hash out of it this pattern

00:13:03,959 --> 00:13:11,190
is not new nor innovative it's how hash

00:13:09,329 --> 00:13:20,610
functions work and basically every

00:13:11,190 --> 00:13:22,589
crypto library and finally people and so

00:13:20,610 --> 00:13:25,050
we're going for kind of well established

00:13:22,589 --> 00:13:27,269
conventions things people are used to

00:13:25,050 --> 00:13:35,339
that are easy to understand

00:13:27,269 --> 00:13:37,769
easy to read strings for the old crypto

00:13:35,339 --> 00:13:40,019
API it's like domain-specific language

00:13:37,769 --> 00:13:41,730
so like we're not gonna have this I mean

00:13:40,019 --> 00:13:43,350
if you want dynamic dispatch you can

00:13:41,730 --> 00:13:45,180
implement that or you can use the

00:13:43,350 --> 00:13:47,730
existing crypto API that can been call

00:13:45,180 --> 00:13:50,010
into zinc for a software based

00:13:47,730 --> 00:13:52,019
algorithms but like for the most part

00:13:50,010 --> 00:13:53,160
people won one specific algorithm

00:13:52,019 --> 00:13:56,040
because they're implementing a driver

00:13:53,160 --> 00:13:57,990
that does a particular thing it's we

00:13:56,040 --> 00:14:03,000
don't want to be parsing this in the

00:13:57,990 --> 00:14:04,650
the kernels we just have functions and

00:14:03,000 --> 00:14:07,110
so the initial patch that actually goes

00:14:04,650 --> 00:14:09,680
through for ChaCha and Pali which are in

00:14:07,110 --> 00:14:13,620
the current crypto API and it replaces

00:14:09,680 --> 00:14:20,280
their software implementations with just

00:14:13,620 --> 00:14:22,290
a call out to zinc and it was really

00:14:20,280 --> 00:14:23,700
simple to do at first in the past it's

00:14:22,290 --> 00:14:25,920
kind of hesitant because I didn't want

00:14:23,700 --> 00:14:28,230
the submission to blow up and get too

00:14:25,920 --> 00:14:29,820
big and then no no we really want to see

00:14:28,230 --> 00:14:32,160
what this looks like and so I did it and

00:14:29,820 --> 00:14:34,590
then that actually you know took 15

00:14:32,160 --> 00:14:37,560
minutes and threw away a bunch of code

00:14:34,590 --> 00:14:39,330
and then the crypto API was just calling

00:14:37,560 --> 00:14:43,860
one function to do the encryption tick

00:14:39,330 --> 00:14:46,980
so that was really there's also a lot of

00:14:43,860 --> 00:14:48,450
crypto code in lib like some hash

00:14:46,980 --> 00:14:52,740
functions even cha-cha 20 has

00:14:48,450 --> 00:14:57,390
implementation their MD for used to be

00:14:52,740 --> 00:14:59,580
there from like Shawn there so there's a

00:14:57,390 --> 00:15:01,740
bunch of stuff in live already because

00:14:59,580 --> 00:15:04,230
developers want to be using just

00:15:01,740 --> 00:15:06,390
functions to call crypto and so in this

00:15:04,230 --> 00:15:09,330
kind of willy-nilly half hazard way it's

00:15:06,390 --> 00:15:14,370
crept in there and it's not really well

00:15:09,330 --> 00:15:15,630
curated or or well organized and so with

00:15:14,370 --> 00:15:17,580
zinc we'll be moving the stuff that's

00:15:15,630 --> 00:15:20,640
just kind of spread out all over the

00:15:17,580 --> 00:15:23,250
place and live into lib slashes ink kind

00:15:20,640 --> 00:15:26,700
of centralizing and organizing the way

00:15:23,250 --> 00:15:29,910
we we approach that but it's clear that

00:15:26,700 --> 00:15:33,630
developers one just normal functions in

00:15:29,910 --> 00:15:36,420
a lot cases and so it's I imagine

00:15:33,630 --> 00:15:38,700
developers of thought like well should I

00:15:36,420 --> 00:15:39,960
mess around with the crypto API and

00:15:38,700 --> 00:15:42,000
figure out how that works or should I

00:15:39,960 --> 00:15:43,680
mess around with stealing this out and

00:15:42,000 --> 00:15:45,900
throwing it in the Lib like what will be

00:15:43,680 --> 00:15:47,310
the least amount of work and different

00:15:45,900 --> 00:15:48,480
developers have decided different things

00:15:47,310 --> 00:15:52,010
and now we have this kind of mess there

00:15:48,480 --> 00:15:52,010
so gonna be cleaning that up

00:15:53,800 --> 00:15:57,520
the the kur crypto API is also kind of

00:15:55,839 --> 00:15:59,830
like a museum the different primitives

00:15:57,520 --> 00:16:02,080
and implementation who wrote these are

00:15:59,830 --> 00:16:06,010
they good has it been verified what do

00:16:02,080 --> 00:16:08,080
they come from does anyone in the

00:16:06,010 --> 00:16:09,760
cryptographic community actually care

00:16:08,080 --> 00:16:12,190
about the kernel and you can deal with

00:16:09,760 --> 00:16:16,480
the kernel enough to even be auditing or

00:16:12,190 --> 00:16:18,100
stuff III I think there's reason first

00:16:16,480 --> 00:16:19,510
things we get doubt about the the

00:16:18,100 --> 00:16:23,350
strength of the implementations in the

00:16:19,510 --> 00:16:25,779
crypto API things are proposed to be

00:16:23,350 --> 00:16:30,250
added to it now and are are usually

00:16:25,779 --> 00:16:31,990
accepted without much review it's like a

00:16:30,250 --> 00:16:34,750
bunch of new stuff that just went in a

00:16:31,990 --> 00:16:36,610
flight like cutting-edge ciphers that I

00:16:34,750 --> 00:16:40,180
guess someone wanted in there and that

00:16:36,610 --> 00:16:42,130
filled with bugs and I mean there hasn't

00:16:40,180 --> 00:16:46,029
been a lot of scrutiny to the actual

00:16:42,130 --> 00:16:47,620
limitations which makes me nervous to do

00:16:46,029 --> 00:16:49,870
things approach for order of preferences

00:16:47,620 --> 00:16:52,480
in order we'd like formally verified

00:16:49,870 --> 00:16:55,240
code whatever that's available and we'll

00:16:52,480 --> 00:16:57,160
get into what that means is that if

00:16:55,240 --> 00:17:01,060
that's not available then usually we go

00:16:57,160 --> 00:17:03,339
for widespread usage code that's

00:17:01,060 --> 00:17:05,439
received a lot of scrutiny so the case

00:17:03,339 --> 00:17:08,829
of the the ciphers for wire them as

00:17:05,439 --> 00:17:11,890
earlier that's sandy poly cause

00:17:08,829 --> 00:17:14,230
implementation sandy Polyakov is this

00:17:11,890 --> 00:17:16,900
genius who writes optimizing

00:17:14,230 --> 00:17:19,360
computations for every architecture that

00:17:16,900 --> 00:17:21,250
makes them ready to open SSL and so they

00:17:19,360 --> 00:17:23,319
have tons of eyeballs trying to break

00:17:21,250 --> 00:17:24,939
these I mean it if you break his then

00:17:23,319 --> 00:17:28,209
that's kind of like the holy grail for

00:17:24,939 --> 00:17:29,590
being a secure researcher with crypto so

00:17:28,209 --> 00:17:34,120
they've received eyeballs and they're

00:17:29,590 --> 00:17:36,430
also the fastest for the most part and

00:17:34,120 --> 00:17:38,480
so thanks for me

00:17:36,430 --> 00:17:41,630
generally prefer and then if that's done

00:17:38,480 --> 00:17:43,610
available implementations that stem from

00:17:41,630 --> 00:17:45,470
the reference and location Eric and that

00:17:43,610 --> 00:17:51,860
are kind of obviously correct and

00:17:45,470 --> 00:17:54,910
nothing too fancy so for four types of

00:17:51,860 --> 00:18:00,350
twenty we have like all the Intel

00:17:54,910 --> 00:18:03,080
extensions to for the neon for that we

00:18:00,350 --> 00:18:05,180
have a mips32 are two extension of the

00:18:03,080 --> 00:18:08,870
implementation so that it's fast a

00:18:05,180 --> 00:18:10,190
little routers similar story for point

00:18:08,870 --> 00:18:13,190
one four or five except you also have to

00:18:10,190 --> 00:18:19,460
have 64 for that for Blake we've got the

00:18:13,190 --> 00:18:25,640
past Intel for curve to 5:19 we have our

00:18:19,460 --> 00:18:28,310
neon and using some extensions of Intel

00:18:25,640 --> 00:18:29,630
scalar instructions which cool in

00:18:28,310 --> 00:18:31,970
general the implications we've chosen

00:18:29,630 --> 00:18:34,150
our super high speed in in addition to

00:18:31,970 --> 00:18:36,860
being really well vetted

00:18:34,150 --> 00:18:43,700
they beat the current crypto API as ones

00:18:36,860 --> 00:18:46,330
by longshot and ok so what's the deal

00:18:43,700 --> 00:18:49,400
with formal verification there are two

00:18:46,330 --> 00:18:51,110
important projects for that one is

00:18:49,400 --> 00:18:55,730
called heckle star and what is called

00:18:51,110 --> 00:18:58,670
fiat crypto a star comes out of an RIA

00:18:55,730 --> 00:19:03,130
in France uses a language called F star

00:18:58,670 --> 00:19:06,970
and Fiat crypto comes out of MIT and

00:19:03,130 --> 00:19:10,010
uses like the original mathematical

00:19:06,970 --> 00:19:12,220
logic system called talk to relate this

00:19:10,010 --> 00:19:15,309
proof

00:19:12,220 --> 00:19:16,929
and the result is his machine Jared's

00:19:15,309 --> 00:19:18,549
seat that's actually readable that looks

00:19:16,929 --> 00:19:21,669
like the door will see that you can

00:19:18,549 --> 00:19:23,919
modify if you wanted it's not really a

00:19:21,669 --> 00:19:27,610
build artifact because it looks like see

00:19:23,919 --> 00:19:30,220
you might have written as the ferrule

00:19:27,610 --> 00:19:33,279
idea is you first define a model and in

00:19:30,220 --> 00:19:34,750
F star or just one of these systems the

00:19:33,279 --> 00:19:36,820
sense what the algorithm is supposed to

00:19:34,750 --> 00:19:38,860
do mathematically is to have a curve

00:19:36,820 --> 00:19:40,629
here's the structure of the curve and

00:19:38,860 --> 00:19:43,779
here's what a multiplication the curve

00:19:40,629 --> 00:19:46,750
is supposed to look like and then you

00:19:43,779 --> 00:19:49,029
make another model that gives kind of

00:19:46,750 --> 00:19:51,429
the implementation mechanics and then f

00:19:49,029 --> 00:19:52,990
star will prove that the mathematical

00:19:51,429 --> 00:19:55,960
model and the implementation mechanics

00:19:52,990 --> 00:19:59,139
model are equivalent and then it can

00:19:55,960 --> 00:20:03,009
lower down the implementation model into

00:19:59,139 --> 00:20:04,990
C or now even with with hacking star

00:20:03,009 --> 00:20:06,629
into into web assembly or I mean they

00:20:04,990 --> 00:20:09,309
can target a bunch of different things

00:20:06,629 --> 00:20:17,409
it's not so much a compiler as it is

00:20:09,309 --> 00:20:19,330
like a applies transforms and so we've

00:20:17,409 --> 00:20:22,090
been working with the the hack of star

00:20:19,330 --> 00:20:23,889
guys to generate code that looks pretty

00:20:22,090 --> 00:20:25,799
for the kernel well I guess they've got

00:20:23,889 --> 00:20:30,340
you know different styles and all that

00:20:25,799 --> 00:20:32,139
stuff of course formal verification is

00:20:30,340 --> 00:20:34,659
not the end all be all but it's much

00:20:32,139 --> 00:20:38,169
less likely to have big cryptic

00:20:34,659 --> 00:20:40,240
vulnerabilities especially if you're

00:20:38,169 --> 00:20:42,429
doing like a big integer arithmetic like

00:20:40,240 --> 00:20:45,759
the curves or pointing with your v

00:20:42,429 --> 00:20:48,250
example it could be certain that it's

00:20:45,759 --> 00:20:49,990
not missing any carry chains or

00:20:48,250 --> 00:20:54,360
overflows or things like that it has a

00:20:49,990 --> 00:20:54,360
very precise model of the C language

00:20:54,630 --> 00:20:59,169
it's from the same Institute that did

00:20:56,650 --> 00:21:04,720
concert for example the verified C

00:20:59,169 --> 00:21:07,059
compiler today I mean in general zinc's

00:21:04,720 --> 00:21:10,299
strives to have stronger relations with

00:21:07,059 --> 00:21:14,919
academia people who are designing these

00:21:10,299 --> 00:21:17,760
crypto primitives are really smart have

00:21:14,919 --> 00:21:20,080
a lot of implementation knowledge are

00:21:17,760 --> 00:21:22,419
incredible engineers in addition to

00:21:20,080 --> 00:21:23,799
being academics I mean some academics

00:21:22,419 --> 00:21:25,390
are up in the clouds and can't really

00:21:23,799 --> 00:21:27,850
write code or use computers well even

00:21:25,390 --> 00:21:31,720
though they're you know but others are

00:21:27,850 --> 00:21:34,270
really amazing implementers you know a

00:21:31,720 --> 00:21:36,520
guys like Dan Bernstein for example that

00:21:34,270 --> 00:21:42,340
uh you know put out good implementations

00:21:36,520 --> 00:21:43,840
in addition to coming up with but a lot

00:21:42,340 --> 00:21:45,669
of these guys don't really come near the

00:21:43,840 --> 00:21:47,650
kernel because we've got this weird

00:21:45,669 --> 00:21:50,590
esoteric approach and like hard to find

00:21:47,650 --> 00:21:52,299
things in the tree and the current API

00:21:50,590 --> 00:21:55,120
is they're unfriendly it's like not a

00:21:52,299 --> 00:21:58,049
place that's attracting the smart people

00:21:55,120 --> 00:22:01,870
who would otherwise want to work on this

00:21:58,049 --> 00:22:05,260
and so the goal is to make zinc and curl

00:22:01,870 --> 00:22:07,059
crypto actually attractive to the best

00:22:05,260 --> 00:22:10,090
minds out there so that we can have

00:22:07,059 --> 00:22:13,270
these you know hordes of postdocs eager

00:22:10,090 --> 00:22:15,130
to work on the kernel for us in fact

00:22:13,270 --> 00:22:20,320
several academics have already expressed

00:22:15,130 --> 00:22:23,020
interest and working on this the kernel

00:22:20,320 --> 00:22:25,030
has a high level of impact so just to

00:22:23,020 --> 00:22:27,070
being the kernel alone is appealing but

00:22:25,030 --> 00:22:30,000
then actually having a way in which they

00:22:27,070 --> 00:22:33,040
can contribute that isn't too insane

00:22:30,000 --> 00:22:36,010
makes it possible

00:22:33,040 --> 00:22:37,570
that said you know zinc is fundamentally

00:22:36,010 --> 00:22:39,970
an engineering project not an academic

00:22:37,570 --> 00:22:41,800
project but I think it's important to

00:22:39,970 --> 00:22:43,710
have the crossover to have the

00:22:41,800 --> 00:22:48,300
additional high balls and additional

00:22:43,710 --> 00:22:48,300
attention that academic photographers

00:22:49,050 --> 00:22:54,940
all implementations are also have we

00:22:51,790 --> 00:22:59,440
post and I like to think of this as kind

00:22:54,940 --> 00:23:01,660
of a requirement for for contributions

00:22:59,440 --> 00:23:05,220
in the tree where should be something

00:23:01,660 --> 00:23:05,220
you've got a fuzz it for a while

00:23:05,550 --> 00:23:09,460
buzzing doesn't find everything of

00:23:07,900 --> 00:23:11,500
course but it finds a lot of really

00:23:09,460 --> 00:23:15,700
obvious obvious things and it's so easy

00:23:11,500 --> 00:23:17,530
to make a buzzer with something like I

00:23:15,700 --> 00:23:20,560
love you Sookie if that's yours an

00:23:17,530 --> 00:23:23,590
example of how when we work you define

00:23:20,560 --> 00:23:26,650
this function LLVM puzzle test one input

00:23:23,590 --> 00:23:28,750
which gives you an input and a lane and

00:23:26,650 --> 00:23:31,210
so the goal here is to show that like

00:23:28,750 --> 00:23:32,650
these three functions are equivalent to

00:23:31,210 --> 00:23:36,280
each other or producing the same results

00:23:32,650 --> 00:23:39,100
and so first I thought the input buffers

00:23:36,280 --> 00:23:40,840
and I compute these functions and then I

00:23:39,100 --> 00:23:43,780
crash if it doesn't produce the same

00:23:40,840 --> 00:23:47,950
result really simple I throw this into

00:23:43,780 --> 00:23:50,260
to the buzzer stuff and then it tries a

00:23:47,950 --> 00:23:54,550
bunch of inputs tonight it'll do it in

00:23:50,260 --> 00:23:59,350
multiple cores so I'll put this on a big

00:23:54,550 --> 00:24:01,660
heavy box somewhere and if there's a

00:23:59,350 --> 00:24:02,980
really obvious bug it'll find it

00:24:01,660 --> 00:24:04,390
immediately if there's a more subtle one

00:24:02,980 --> 00:24:06,100
if you take a day or something but I

00:24:04,390 --> 00:24:08,470
mean it's so easy to write this kind of

00:24:06,100 --> 00:24:11,100
thing that there's really no reason not

00:24:08,470 --> 00:24:11,100
to for

00:24:13,610 --> 00:24:17,610
and in general by choosing

00:24:15,990 --> 00:24:21,000
implementations that are well known or

00:24:17,610 --> 00:24:22,770
broadly used we we benefit from the

00:24:21,000 --> 00:24:25,320
analysis that people are already doing

00:24:22,770 --> 00:24:30,900
so I mentioned probably cause cryptic

00:24:25,320 --> 00:24:34,020
and stuff that's used open so ok so the

00:24:30,900 --> 00:24:36,690
organization so this is gonna live in

00:24:34,020 --> 00:24:40,260
live slows Inc and then the name of the

00:24:36,690 --> 00:24:42,060
cypher so for ChaCha its and webzine

00:24:40,260 --> 00:24:46,470
ChaCha in the avenue of generic see one

00:24:42,060 --> 00:24:47,850
arm one x86 one and so forth and so when

00:24:46,470 --> 00:24:49,710
we group it by primitive that makes it

00:24:47,850 --> 00:24:51,480
really easy to come open it up and see

00:24:49,710 --> 00:24:54,840
what's there so it's not there see what

00:24:51,480 --> 00:24:58,290
could be added it's just a really

00:24:54,840 --> 00:24:59,880
friendly straightforward approach how

00:24:58,290 --> 00:25:01,350
does the colonel implement out 20 and

00:24:59,880 --> 00:25:07,320
then you just open up a notch a 20

00:25:01,350 --> 00:25:09,960
directory and you see it yeah it makes

00:25:07,320 --> 00:25:11,940
the whole thing a lot more manageable it

00:25:09,960 --> 00:25:16,410
also allows us to put the glue code

00:25:11,940 --> 00:25:19,020
right next to the implementations in a

00:25:16,410 --> 00:25:22,890
way that makes things really fast by

00:25:19,020 --> 00:25:24,360
compiler in lighting and so rather than

00:25:22,890 --> 00:25:26,040
using lots of function pointers and

00:25:24,360 --> 00:25:30,930
dynamic module loading for this kind of

00:25:26,040 --> 00:25:32,250
stuff we can use branches that could

00:25:30,930 --> 00:25:34,170
predict it out so I'll show you that in

00:25:32,250 --> 00:25:35,940
a second but the end result of this is

00:25:34,170 --> 00:25:40,800
we don't have any slowdowns because of

00:25:35,940 --> 00:25:43,830
Reptar line okay so compiler in align it

00:25:40,800 --> 00:25:46,080
here's an example for the poly 1 3 or 5

00:25:43,830 --> 00:25:47,670
omit function first we try with the arc

00:25:46,080 --> 00:25:51,540
function like if there's an optimized

00:25:47,670 --> 00:25:53,970
implementation and if there is the

00:25:51,540 --> 00:25:55,680
Mestral code otherwise it's a predefined

00:25:53,970 --> 00:25:57,500
stub that returns false and so that

00:25:55,680 --> 00:26:02,870
branch is compiled out

00:25:57,500 --> 00:26:05,389
and we only hit the generic one here's

00:26:02,870 --> 00:26:08,570
another example where in that arc

00:26:05,389 --> 00:26:11,330
function you know we have capabilities

00:26:08,570 --> 00:26:13,820
does the processor have neon or we're

00:26:11,330 --> 00:26:15,110
gonna use it you know this needs to be

00:26:13,820 --> 00:26:17,960
checked because it's part of the runtime

00:26:15,110 --> 00:26:20,240
logic but this is set pretty much at the

00:26:17,960 --> 00:26:24,799
model in a time it never changes but

00:26:20,240 --> 00:26:26,960
actually on on all architectures the

00:26:24,799 --> 00:26:29,000
branch predictor is super super good at

00:26:26,960 --> 00:26:32,720
this kind of stuff variable that set

00:26:29,000 --> 00:26:35,539
once never touched again it always

00:26:32,720 --> 00:26:36,919
predicts right in these cases and so it

00:26:35,539 --> 00:26:39,559
turns out rather than like crazy

00:26:36,919 --> 00:26:42,470
function pointer stuff and making

00:26:39,559 --> 00:26:44,539
everything really dynamic which is now

00:26:42,470 --> 00:26:47,480
you know slow because all the spectrum

00:26:44,539 --> 00:26:50,480
mitigation stuff the simple branch is

00:26:47,480 --> 00:26:55,370
both straightforward to read and lends

00:26:50,480 --> 00:26:58,490
up being really fast it also sets things

00:26:55,370 --> 00:27:00,500
up as you know nice future stuff that

00:26:58,490 --> 00:27:02,059
people do want to work on the dynamic

00:27:00,500 --> 00:27:05,750
patching and I think there's like a

00:27:02,059 --> 00:27:10,519
patch from Intel for work we touched

00:27:05,750 --> 00:27:12,529
branches but on every architecture I saw

00:27:10,519 --> 00:27:15,309
that things like this were predicted

00:27:12,529 --> 00:27:15,309
correctly every time

00:27:15,720 --> 00:27:21,540
there's we also do some optimizations to

00:27:19,330 --> 00:27:23,620
the the Cindy in our context so

00:27:21,540 --> 00:27:28,990
traditionally in the kernel when you do

00:27:23,620 --> 00:27:32,170
crypto you have to call this and that

00:27:28,990 --> 00:27:33,970
calls exhales so that if the user spaces

00:27:32,170 --> 00:27:36,430
using any of the F few registers well we

00:27:33,970 --> 00:27:39,790
doesn't trample on it if you forget to

00:27:36,430 --> 00:27:42,460
do this a random program in user space

00:27:39,790 --> 00:27:44,110
will probably crash it's using like a VX

00:27:42,460 --> 00:27:46,290
accelerating them copy or something kind

00:27:44,110 --> 00:27:48,520
of funny bug to play with so

00:27:46,290 --> 00:27:50,020
traditionally you have to call begin and

00:27:48,520 --> 00:27:51,340
end and then you do your stuff in the

00:27:50,020 --> 00:27:57,250
middle and you're supposed to keep these

00:27:51,340 --> 00:28:03,250
segments rather short and calling curl

00:27:57,250 --> 00:28:06,490
fu and is it's currently slow and you're

00:28:03,250 --> 00:28:08,470
calling X save back and forth and

00:28:06,490 --> 00:28:10,840
especially on the Intel enough there's

00:28:08,470 --> 00:28:12,700
avx-512 you have these registers that

00:28:10,840 --> 00:28:15,460
are massive and so yet this is a huge

00:28:12,700 --> 00:28:18,070
state that has to be x8 this one has

00:28:15,460 --> 00:28:20,620
have been really expensive so if you're

00:28:18,070 --> 00:28:22,690
encrypting things over and over like in

00:28:20,620 --> 00:28:26,770
you know worker thread we're just taking

00:28:22,690 --> 00:28:28,210
things off of Q and encrypting it find

00:28:26,770 --> 00:28:30,670
that a lot of the overhead is not the

00:28:28,210 --> 00:28:33,190
actual crypto which is usually expensive

00:28:30,670 --> 00:28:35,730
but just this stupid XA of extra storage

00:28:33,190 --> 00:28:35,730
situation

00:28:36,260 --> 00:28:43,440
so yeah so like for a loop like this if

00:28:39,570 --> 00:28:47,730
you have a loop then you're you know you

00:28:43,440 --> 00:28:50,550
do all this needless saving so the

00:28:47,730 --> 00:28:53,090
solution is to do back to where we can

00:28:50,550 --> 00:28:57,330
voice down to cindy context with

00:28:53,090 --> 00:28:59,070
variable we have this variable cindy

00:28:57,330 --> 00:29:04,770
context that we can get it we can put it

00:28:59,070 --> 00:29:07,560
and the get will will will be give me a

00:29:04,770 --> 00:29:12,270
few and the put will end it and then in

00:29:07,560 --> 00:29:14,820
the middle we can call relax on tamarka

00:29:12,270 --> 00:29:18,870
textures taking taking me a few means

00:29:14,820 --> 00:29:20,640
disabling preemption which is bad but we

00:29:18,870 --> 00:29:24,300
don't always want to read a belittling

00:29:20,640 --> 00:29:26,790
can be put so Cindy relax will do a get

00:29:24,300 --> 00:29:31,200
but only if necessary only if we've been

00:29:26,790 --> 00:29:34,340
going to Boland and it's a familiar get

00:29:31,200 --> 00:29:37,500
put paradigm makes the code very simple

00:29:34,340 --> 00:29:41,480
to kind of voiced that out and the

00:29:37,500 --> 00:29:41,480
performance increases very soon

00:29:47,430 --> 00:29:51,790
nah not quite it's still the something

00:29:50,440 --> 00:29:55,780
so there's a patch set now that's

00:29:51,790 --> 00:29:58,900
working on making end basically no op

00:29:55,780 --> 00:30:02,560
and having the actual restore happen at

00:29:58,900 --> 00:30:03,880
context switch time and if that lands

00:30:02,560 --> 00:30:06,090
it'll be great that we can get rid of

00:30:03,880 --> 00:30:06,090
this

00:30:12,440 --> 00:30:17,210
oh okay it might be possible other

00:30:14,810 --> 00:30:19,420
others are doing on x86 is not the case

00:30:17,210 --> 00:30:19,420
though

00:30:23,559 --> 00:30:30,280
so and if you use the what

00:30:35,789 --> 00:30:57,070
for curlers new you you do I mean the

00:30:54,039 --> 00:31:01,000
scheduler is switching between a user

00:30:57,070 --> 00:31:07,480
from that core and you're catering on

00:31:01,000 --> 00:31:09,400
that safe core yes no it doesn't that's

00:31:07,480 --> 00:31:12,370
that's the whole idea is that ex save is

00:31:09,400 --> 00:31:13,659
expensive and so if the colonel isn't

00:31:12,370 --> 00:31:17,640
going to use it there's no point in X

00:31:13,659 --> 00:31:17,640
saving so on contacts which it doesn't

00:31:35,919 --> 00:31:51,130
there's between a user

00:32:26,190 --> 00:32:31,360
I mean I don't think this is quite

00:32:29,200 --> 00:32:33,730
correct for two reasons empirically the

00:32:31,360 --> 00:32:36,400
speedups are like really obvious like

00:32:33,730 --> 00:32:38,529
hundreds of megabits and then on L KML

00:32:36,400 --> 00:32:42,460
there's currently a patch set to

00:32:38,529 --> 00:32:46,179
introduce it oh you're doing this oh so

00:32:42,460 --> 00:33:04,179
you're speaking about the future work Oh

00:32:46,179 --> 00:33:06,370
to fix it yeah yeah oh okay okay okay so

00:33:04,179 --> 00:33:10,620
yeah so I know you're once your patch

00:33:06,370 --> 00:33:10,620
set lands we can probably nuke this

00:33:17,799 --> 00:33:24,399
French nobody hit it over that's curious

00:33:22,119 --> 00:33:26,259
okay I'll give that another look my

00:33:24,399 --> 00:33:30,249
benchmarks totally disagree with that

00:33:26,259 --> 00:33:32,489
but Iran I have no idea we used to go

00:33:30,249 --> 00:33:37,409
into February because this is when the

00:33:32,489 --> 00:33:37,409
accumulation is broken right

00:33:47,479 --> 00:33:58,309
okay possibly forget that maybe it's

00:33:53,159 --> 00:34:01,919
useful but hopefully it won't be okay

00:33:58,309 --> 00:34:03,179
but we're this to be used in the

00:34:01,919 --> 00:34:04,769
encryption when you actually use the

00:34:03,179 --> 00:34:09,869
Cindy context let me just call some to

00:34:04,769 --> 00:34:12,690
use okay so just wrapping up there's

00:34:09,869 --> 00:34:17,690
been kind of like a lot of noise around

00:34:12,690 --> 00:34:21,629
this patch set for a couple reasons

00:34:17,690 --> 00:34:25,909
we're changing a bit of the direction in

00:34:21,629 --> 00:34:30,319
in kernel crypto development stronger

00:34:25,909 --> 00:34:33,119
criteria for inclusion for code quality

00:34:30,319 --> 00:34:34,589
which you know if you're working on this

00:34:33,119 --> 00:34:37,559
as part of your job it's kind of nice

00:34:34,589 --> 00:34:40,200
now you you know submit so you know

00:34:37,559 --> 00:34:42,809
assembly and it probably gets accepted

00:34:40,200 --> 00:34:45,990
no one's really you know looking at that

00:34:42,809 --> 00:34:48,000
much I can understand that you know I'd

00:34:45,990 --> 00:34:50,639
come along closing maintain with zinc

00:34:48,000 --> 00:34:54,480
and there are criteria now your job

00:34:50,639 --> 00:34:55,769
might get harder you know you know block

00:34:54,480 --> 00:34:58,039
that from happening then you can keep

00:34:55,769 --> 00:35:01,170
any good job yeah okay I gotta get that

00:34:58,039 --> 00:35:07,230
doesn't like it much different simpler

00:35:01,170 --> 00:35:08,490
approach to API design and you know

00:35:07,230 --> 00:35:11,490
that's that's a lot different than

00:35:08,490 --> 00:35:13,740
what's there now we're there now is you

00:35:11,490 --> 00:35:16,559
know invented mostly for IPSec and it's

00:35:13,740 --> 00:35:19,109
gonna grow and beyond that of course

00:35:16,559 --> 00:35:20,670
with with ever trying to do kind of a

00:35:19,109 --> 00:35:24,380
newer simpler thing you have like lots

00:35:20,670 --> 00:35:27,000
of opinions on how that should work out

00:35:24,380 --> 00:35:31,480
also you know

00:35:27,000 --> 00:35:33,280
the the commit message for zinc is kind

00:35:31,480 --> 00:35:37,090
of very pretentious you know it's like

00:35:33,280 --> 00:35:40,060
new kid on the block coming in this is

00:35:37,090 --> 00:35:44,640
like a bit of a disturbance I think

00:35:40,060 --> 00:35:44,640
there's been a lot of pushback from that

00:35:46,890 --> 00:35:53,110
from from these descriptive games code

00:35:50,580 --> 00:35:54,880
for many pony cogs we were just kind of

00:35:53,110 --> 00:35:57,130
included generating assembly rather than

00:35:54,880 --> 00:35:58,630
his generate tour but actually we're

00:35:57,130 --> 00:36:00,610
replacing that now with the with the

00:35:58,630 --> 00:36:08,110
generators make it more easily tweakable

00:36:00,610 --> 00:36:11,560
that was the initial patch set was like

00:36:08,110 --> 00:36:13,870
had all this together with wire guard

00:36:11,560 --> 00:36:17,920
and one monster patch that was like

00:36:13,870 --> 00:36:20,290
insane and so you know you just put this

00:36:17,920 --> 00:36:22,390
out now can a part of the process and

00:36:20,290 --> 00:36:24,100
there's been you know more more calls

00:36:22,390 --> 00:36:25,750
for increasing granularity in this

00:36:24,100 --> 00:36:27,520
direction or that direction so we've

00:36:25,750 --> 00:36:32,590
done and it's kind of trudging through

00:36:27,520 --> 00:36:34,720
the process of that it's new code in Lib

00:36:32,590 --> 00:36:37,180
slash sync and that entails we'll be

00:36:34,720 --> 00:36:38,610
maintaining this and there's always kind

00:36:37,180 --> 00:36:41,500
of a vacuum

00:36:38,610 --> 00:36:44,140
you know like a little vacuum when it

00:36:41,500 --> 00:36:45,610
comes to acting you maintain errs it's

00:36:44,140 --> 00:36:48,850
not as though I'm submitting this to an

00:36:45,610 --> 00:36:52,960
existing maintainer to be active this

00:36:48,850 --> 00:36:55,660
will be this will be a subdirectory with

00:36:52,960 --> 00:36:56,680
new maintainer and so you know given

00:36:55,660 --> 00:36:59,140
that there's a little bit of resistance

00:36:56,680 --> 00:37:04,480
and changing how things work currently

00:36:59,140 --> 00:37:06,730
and there's like a new maintainer there

00:37:04,480 --> 00:37:08,920
there hasn't been anyone you know in

00:37:06,730 --> 00:37:11,260
some position just steps for it and says

00:37:08,920 --> 00:37:14,140
like alright we're doing this it's in

00:37:11,260 --> 00:37:14,830
we'll clean things up as we go if

00:37:14,140 --> 00:37:16,390
necessary

00:37:14,830 --> 00:37:18,280
you're the maintainer yeah so that

00:37:16,390 --> 00:37:21,010
there's a vacuum and so a lot of people

00:37:18,280 --> 00:37:24,730
kind of come in make a lot of noise and

00:37:21,010 --> 00:37:27,520
vacuums there have been you know like a

00:37:24,730 --> 00:37:30,670
lot of good review aspects I think of e9

00:37:27,520 --> 00:37:33,760
that probably be out tomorrow the day

00:37:30,670 --> 00:37:38,020
after tomorrow should address the last

00:37:33,760 --> 00:37:40,540
of the technical myths and so I think

00:37:38,020 --> 00:37:42,850
mostly from here on out it's maybe a

00:37:40,540 --> 00:37:45,670
matter of organizational will to push it

00:37:42,850 --> 00:37:48,190
forward there's also this issue I found

00:37:45,670 --> 00:37:50,860
on the list of like why doesn't it also

00:37:48,190 --> 00:37:52,900
do X like what about my pet feature can

00:37:50,860 --> 00:37:54,640
it have this knob because there's this

00:37:52,900 --> 00:37:57,730
one thing I really wanted can't we have

00:37:54,640 --> 00:38:00,310
this or you know with all those there's

00:37:57,730 --> 00:38:02,650
you know probably two good ideas for it

00:38:00,310 --> 00:38:04,480
good justifications yeah we could do

00:38:02,650 --> 00:38:05,620
that should we do it now should do it

00:38:04,480 --> 00:38:07,210
later does it have to be the initial

00:38:05,620 --> 00:38:10,000
submission with yeah I really want it

00:38:07,210 --> 00:38:14,320
you know it's a bit that kind of thing

00:38:10,000 --> 00:38:15,820
can go on indefinitely and you know

00:38:14,320 --> 00:38:17,290
given there's a bit of a vacuum because

00:38:15,820 --> 00:38:20,230
it's something with a new maintainer

00:38:17,290 --> 00:38:21,970
there's not really an authority right

00:38:20,230 --> 00:38:25,270
now to you know put the foot down and

00:38:21,970 --> 00:38:27,130
say like no you know enough with the

00:38:25,270 --> 00:38:29,650
knobs or that you know the feature

00:38:27,130 --> 00:38:30,970
request let's get in before there's not

00:38:29,650 --> 00:38:33,100
that there's just this you know kind of

00:38:30,970 --> 00:38:34,720
consensus discussion so someone suggest

00:38:33,100 --> 00:38:38,110
something it's you know maybe a good

00:38:34,720 --> 00:38:41,080
idea and then it it keeps kind of

00:38:38,110 --> 00:38:45,010
pushing things back zing stands for as

00:38:41,080 --> 00:38:48,300
Inc as in crypto follows the naming

00:38:45,010 --> 00:38:52,000
scheme of popular libraries like sodium

00:38:48,300 --> 00:38:54,340
hydrogen and so forth it also gives us a

00:38:52,000 --> 00:38:56,770
distinct namespace from the existing

00:38:54,340 --> 00:38:58,350
crypto API event using zinc you know

00:38:56,770 --> 00:39:03,070
that you're getting that just the

00:38:58,350 --> 00:39:05,770
synchronous can raw crypto primitives as

00:39:03,070 --> 00:39:08,410
where as you're using include crypto /

00:39:05,770 --> 00:39:12,460
then you're getting the asynchronous API

00:39:08,410 --> 00:39:13,910
and all the enterprise stuff but you

00:39:12,460 --> 00:39:16,280
know

00:39:13,910 --> 00:39:18,710
this kind of steps on the toes of some

00:39:16,280 --> 00:39:20,660
people just like a new namespace thing

00:39:18,710 --> 00:39:24,170
and so that's because we're old problem

00:39:20,660 --> 00:39:28,670
I quit early on that Zig stood for zinc

00:39:24,170 --> 00:39:30,260
is not crypto slash but like this like

00:39:28,670 --> 00:39:33,650
don't try and make jokes on your net I

00:39:30,260 --> 00:39:38,690
guess if they're a light-hearted like

00:39:33,650 --> 00:39:44,599
people really do not like this zinc as

00:39:38,690 --> 00:39:45,380
encrypt over so I mean I guess it's a

00:39:44,599 --> 00:39:46,960
process

00:39:45,380 --> 00:39:50,589
hopefully Dean I and I'll you know

00:39:46,960 --> 00:39:53,319
probably get some some of the similar

00:39:50,589 --> 00:39:57,260
responses but hopefully it also be

00:39:53,319 --> 00:39:58,970
improvement from v8 and we'll see if

00:39:57,260 --> 00:40:02,559
someone steps for and says alright

00:39:58,970 --> 00:40:02,559
enough let's merge this and then we can

00:40:03,730 --> 00:40:09,490
all right all right we got great

00:40:06,490 --> 00:40:09,490
excellent

00:40:15,500 --> 00:40:20,570
hey so actually initially the zinc patch

00:40:19,310 --> 00:40:22,369
set didn't touch any the cryptic code

00:40:20,570 --> 00:40:24,200
because I didn't want to do that or like

00:40:22,369 --> 00:40:26,540
deal with that but then they kept

00:40:24,200 --> 00:40:29,180
hounding me like no we want to see you

00:40:26,540 --> 00:40:31,280
convert the existing stuff in the zing

00:40:29,180 --> 00:40:33,590
and and so I did that that's in there

00:40:31,280 --> 00:40:35,150
and I mean that's like really boring and

00:40:33,590 --> 00:40:36,410
straight for a night they leave the

00:40:35,150 --> 00:40:41,990
existing code and I have this like

00:40:36,410 --> 00:40:44,570
little stub that calls the function oh

00:40:41,990 --> 00:40:57,490
yeah so I have that and then I convert

00:40:44,570 --> 00:40:59,990
big keys to using it right and then that

00:40:57,490 --> 00:41:07,310
and then obviously wire guard is using

00:40:59,990 --> 00:41:08,840
this dave told me last night said why

00:41:07,310 --> 00:41:14,050
our guard looks good just get the script

00:41:08,840 --> 00:41:18,640
of stuff worked out at the end so Miller

00:41:14,050 --> 00:41:18,640
so I mean as a standalone

00:41:23,960 --> 00:41:32,090
right exactly yeah and then once it's in

00:41:30,080 --> 00:41:33,830
I can start moving the the mess from

00:41:32,090 --> 00:41:35,900
live into this and then cleaning up the

00:41:33,830 --> 00:41:55,370
million other places that are like

00:41:35,900 --> 00:42:06,530
there's a lot of stuff I want to do we

00:41:55,370 --> 00:42:08,990
want to see there were other people who

00:42:06,530 --> 00:42:11,570
were saying oh wait as soon as you do

00:42:08,990 --> 00:42:15,470
this you know we need to make sure that

00:42:11,570 --> 00:42:20,150
it is at full parity in terms of same

00:42:15,470 --> 00:42:32,060
performance right with crypto and that

00:42:20,150 --> 00:42:33,650
means yeah I mean yeah now there's a

00:42:32,060 --> 00:42:37,010
silly thing with like the cha-cha code

00:42:33,650 --> 00:42:38,270
where like Martin does have this cha-cha

00:42:37,010 --> 00:42:41,240
complementation that's in the crypto

00:42:38,270 --> 00:42:42,500
directory now and now he's improved it

00:42:41,240 --> 00:42:43,760
to make it a little bit faster you know

00:42:42,500 --> 00:42:45,620
it's like a little more competitive but

00:42:43,760 --> 00:42:47,330
it doesn't support it gates 5:12 it's

00:42:45,620 --> 00:42:51,340
over you know there's still the put like

00:42:47,330 --> 00:42:51,340
this this is it's a stupid and you know

00:43:01,460 --> 00:43:06,770
so that is just sink plus the big

00:43:04,520 --> 00:43:08,800
cleanup sure I would be funny with

00:43:06,770 --> 00:43:11,329
battles you know ripping you know

00:43:08,800 --> 00:43:13,220
cha-cha and lip crypto and using the one

00:43:11,329 --> 00:43:15,069
insane right there are multiple ways of

00:43:13,220 --> 00:43:17,440
playing it I'm not true there's any one

00:43:15,069 --> 00:43:19,520
way it's like which way actually

00:43:17,440 --> 00:43:24,890
everyone allows us to make forward

00:43:19,520 --> 00:43:26,480
progress right miss Schubert here I mean

00:43:24,890 --> 00:43:36,650
I would I would love to rip out those

00:43:26,480 --> 00:43:38,960
top patches and I yeah so I emailed Tim

00:43:36,650 --> 00:43:40,670
like a bunch like Herbert you know look

00:43:38,960 --> 00:43:42,680
at this we talk like you want to get on

00:43:40,670 --> 00:43:44,390
like Skype and we can actually you know

00:43:42,680 --> 00:43:47,510
face to face if that's easier he's like

00:43:44,390 --> 00:43:49,520
no I don't want to do that but maybe

00:43:47,510 --> 00:43:51,200
like over the holiday coming up we'll

00:43:49,520 --> 00:43:53,240
look at it and then there's like two

00:43:51,200 --> 00:44:14,809
questions that are answered so I mean

00:43:53,240 --> 00:44:23,059
he's kind of don't think so it's on

00:44:14,809 --> 00:44:26,980
cable just sort of oh sure that's the

00:44:23,059 --> 00:44:26,980
organizational will part assuming that

00:44:27,780 --> 00:44:37,680
right yeah yeah I mean that would be

00:44:30,880 --> 00:44:40,390
good way of doing it uh no actually I've

00:44:37,680 --> 00:44:50,800
tried to CC human on the discussion but

00:44:40,390 --> 00:44:54,220
I don't he's he's pretty reasonable when

00:44:50,800 --> 00:44:56,760
the that patch is pretty totally I would

00:44:54,220 --> 00:44:56,760
be surprised

00:45:12,150 --> 00:45:16,870
yeah so the cool thing about this is uh

00:45:14,410 --> 00:45:22,450
actually working with and the holy cow

00:45:16,870 --> 00:45:25,450
where originally I had like I had taken

00:45:22,450 --> 00:45:28,570
the output of his of his simply

00:45:25,450 --> 00:45:30,250
generator things pearl azzam stuff and a

00:45:28,570 --> 00:45:33,220
tweaked it for the kernel and I just

00:45:30,250 --> 00:45:34,570
committed that and this was not welcome

00:45:33,220 --> 00:45:38,710
because it was generating code even

00:45:34,570 --> 00:45:42,610
though I hadn't worked on manually so

00:45:38,710 --> 00:45:45,820
now Andy and I have actually been any

00:45:42,610 --> 00:45:49,830
Samuel and I had actually been changing

00:45:45,820 --> 00:45:51,970
the generator to make kernel code and so

00:45:49,830 --> 00:45:53,410
that's gonna be there's already like a

00:45:51,970 --> 00:45:55,780
github pull request that's gonna be up

00:45:53,410 --> 00:45:59,190
streaming and crypto Gans and open SSL

00:45:55,780 --> 00:46:01,890
we're actually

00:45:59,190 --> 00:46:03,869
it won't ever be real canonical nothing

00:46:01,890 --> 00:46:05,670
so the one thing that I stumbled over no

00:46:03,869 --> 00:46:09,390
but it will I spend the day trying to

00:46:05,670 --> 00:46:12,450
make used it corrects endianness

00:46:09,390 --> 00:46:13,650
conversion those I think in wire got

00:46:12,450 --> 00:46:16,020
like wouldn't when you call the wire

00:46:13,650 --> 00:46:17,400
when where I got calls into it there's

00:46:16,020 --> 00:46:23,630
something with any of us conversions

00:46:17,400 --> 00:46:23,630
John okay because I mean it's assembly

00:46:25,550 --> 00:46:33,660
oh that's like as pure and foreign code

00:46:30,900 --> 00:46:35,700
yet so with kind of style

00:46:33,660 --> 00:46:43,890
oh yeah so it's very it's very you

00:46:35,700 --> 00:46:45,570
obviousiy code yeah so with the with the

00:46:43,890 --> 00:46:47,820
style for that I'm working with those

00:46:45,570 --> 00:46:49,260
guys like I live in the same town and

00:46:47,820 --> 00:46:50,880
I'll go to their office and we'll sit

00:46:49,260 --> 00:46:52,530
down and I'll be like here is kernel

00:46:50,880 --> 00:46:56,220
code here's what you should you know so

00:46:52,530 --> 00:46:57,420
they're really receptive to that but

00:46:56,220 --> 00:46:59,310
you're right with things like the

00:46:57,420 --> 00:47:09,210
endianness if we want to use our helper

00:46:59,310 --> 00:47:12,660
just dead like an NSS the crypto library

00:47:09,210 --> 00:47:16,340
and Firefox uses it wholesale like they

00:47:12,660 --> 00:47:18,660
imported the whole crazy F star of camel

00:47:16,340 --> 00:47:20,880
generator in but like the kernel is not

00:47:18,660 --> 00:47:23,640
going to do that especially just for a

00:47:20,880 --> 00:47:26,070
little thing so yeah we get the cherry

00:47:23,640 --> 00:47:28,700
at C we clean it up and then it's it's

00:47:26,070 --> 00:47:28,700
pretty good

00:47:38,320 --> 00:47:41,490
I like to

00:47:44,049 --> 00:48:12,759
I mean I like it's it's it's still

00:48:09,670 --> 00:48:14,289
pretty good code to read and so I like

00:48:12,759 --> 00:48:15,819
to read so I like it to look good so I

00:48:14,289 --> 00:48:25,150
want to get it as close as popular I

00:48:15,819 --> 00:48:26,410
mean I do read it I think through it in

00:48:25,150 --> 00:48:29,109
the same way that like the chess world

00:48:26,410 --> 00:48:30,400
will analyze how the machines play like

00:48:29,109 --> 00:48:31,929
ooh that was a cool move the machine

00:48:30,400 --> 00:48:34,949
Jenner like it's cool look at the

00:48:31,929 --> 00:48:34,949
generated code

00:48:43,580 --> 00:48:49,400

YouTube URL: https://www.youtube.com/watch?v=BuQ5fQ1SJto


