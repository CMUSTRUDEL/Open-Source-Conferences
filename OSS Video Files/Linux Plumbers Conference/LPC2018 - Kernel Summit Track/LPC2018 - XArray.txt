Title: LPC2018 - XArray
Publication date: 2018-12-04
Playlist: LPC2018 - Kernel Summit Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/259/
speaker:  Matthew Wilcox


Now that the XArray is in, it's time to make use of it. I've got a git tree which converts every current user of the radix tree to the XArray as well as converting some users of the IDA to the XArray.

The XArray may also be a great replacement for a list_head in your data structure.

I can also talk about currently inappropriate uses for the XArray and what I might do in future to make the XArray useful for more users.
Captions: 
	00:00:07,720 --> 00:00:11,410
good afternoon everyone and

00:00:13,950 --> 00:00:21,840
an AP I've been working on and it's just

00:00:18,119 --> 00:00:25,320
landed in leanness is trading and so I

00:00:21,840 --> 00:00:27,660
thought this would be a great time to to

00:00:25,320 --> 00:00:33,420
explain to you why you want to start

00:00:27,660 --> 00:00:36,870
using my API and why why why things will

00:00:33,420 --> 00:00:39,860
improve if you don't so the X ray is an

00:00:36,870 --> 00:00:42,750
automatically resizing array of pointers

00:00:39,860 --> 00:00:45,629
it's indexed by not by an unsigned long

00:00:42,750 --> 00:00:47,309
I know this doesn't suit everybody there

00:00:45,629 --> 00:00:49,859
are file system people in particular who

00:00:47,309 --> 00:00:55,739
would like me to index it by au 64 so

00:00:49,859 --> 00:00:56,909
that they can store blocks in it that's

00:00:55,739 --> 00:00:57,239
an extension that might happen in the

00:00:56,909 --> 00:01:01,769
future

00:00:57,239 --> 00:01:04,589
it's it's not there today so the when

00:01:01,769 --> 00:01:10,080
you initialize an x-ray every pointer is

00:01:04,589 --> 00:01:11,700
null there are API is where people say

00:01:10,080 --> 00:01:13,290
oh well if you've never stored to it

00:01:11,700 --> 00:01:15,390
then you shouldn't load from it I've

00:01:13,290 --> 00:01:17,400
actually returned you Ian Val or

00:01:15,390 --> 00:01:19,290
something like that no if you've never

00:01:17,400 --> 00:01:20,850
sought to it as null it's just it's an

00:01:19,290 --> 00:01:23,580
infinitely large array full of null

00:01:20,850 --> 00:01:27,630
pointers it has a spin lock so it

00:01:23,580 --> 00:01:31,770
handles its own synchronization and it's

00:01:27,630 --> 00:01:33,690
RCU safe so if you if you do a load from

00:01:31,770 --> 00:01:36,540
it you can do that load without holding

00:01:33,690 --> 00:01:40,080
it won't take the lock in order to do a

00:01:36,540 --> 00:01:42,840
load you can choose to use the spin lock

00:01:40,080 --> 00:01:44,250
which is inside the x-ray in order to

00:01:42,840 --> 00:01:46,620
make sure that somebody else who's

00:01:44,250 --> 00:01:48,900
deleting it isn't going to step on your

00:01:46,620 --> 00:01:53,370
toes but that's that's not a necessary

00:01:48,900 --> 00:01:55,590
part of the API for you so how do you

00:01:53,370 --> 00:01:58,650
use it well fundamentally you can just

00:01:55,590 --> 00:02:03,950
do loads and stores because it's it's an

00:01:58,650 --> 00:02:07,200
array there's no difference between

00:02:03,950 --> 00:02:11,629
storing a null pointer and using the

00:02:07,200 --> 00:02:15,090
arrays call that is is this is the

00:02:11,629 --> 00:02:17,909
normal kind of array it's just a

00:02:15,090 --> 00:02:20,849
convenience function but you could pass

00:02:17,909 --> 00:02:23,370
nulls a third argument to X a store and

00:02:20,849 --> 00:02:24,930
0 was the GFP T or

00:02:23,370 --> 00:02:29,610
make up your own GFP flags whatever you

00:02:24,930 --> 00:02:33,030
like it won't use them erasing a null

00:02:29,610 --> 00:02:37,349
port storing a null in the x-ray does

00:02:33,030 --> 00:02:39,930
not require allocation so rather than

00:02:37,349 --> 00:02:42,239
just just to make it easier people I

00:02:39,930 --> 00:02:43,980
have XA arrays because for a lot of

00:02:42,239 --> 00:02:47,879
people that's what they actually want to

00:02:43,980 --> 00:02:50,730
do and since this is an infinitely large

00:02:47,879 --> 00:02:52,890
array it's somewhat inefficient to count

00:02:50,730 --> 00:02:56,340
from zero to you long max just to look

00:02:52,890 --> 00:03:01,470
for all of the elements in the array so

00:02:56,340 --> 00:03:04,200
we have XA for each which will which

00:03:01,470 --> 00:03:06,269
will find everything between index and

00:03:04,200 --> 00:03:09,209
Max and it will update index each time

00:03:06,269 --> 00:03:10,920
around the loop into the internet gets

00:03:09,209 --> 00:03:12,870
to max which time it will stop looking

00:03:10,920 --> 00:03:15,060
it will also of course stop looking if

00:03:12,870 --> 00:03:19,230
we run off the if we if there were only

00:03:15,060 --> 00:03:21,359
Noel's past past index so it's not that

00:03:19,230 --> 00:03:22,920
you need to keep track of way you know

00:03:21,359 --> 00:03:24,299
where your max is the highest number

00:03:22,920 --> 00:03:28,049
you've ever used you can just say you

00:03:24,299 --> 00:03:31,410
long max there and it will know to stop

00:03:28,049 --> 00:03:33,900
doing any work once once once there are

00:03:31,410 --> 00:03:37,919
no more entries left in the array you

00:03:33,900 --> 00:03:41,280
can see that final the final argument

00:03:37,919 --> 00:03:46,709
has a filter and you're saying probably

00:03:41,280 --> 00:03:49,290
so what is an XA mark T anyway you have

00:03:46,709 --> 00:03:51,510
three auxiliary bits per non null entry

00:03:49,290 --> 00:03:53,609
so you can't you can't set these bits on

00:03:51,510 --> 00:03:56,970
another entry it will it will

00:03:53,609 --> 00:03:59,609
respectfully decline to do that yeah you

00:03:56,970 --> 00:04:03,419
can set and clear marks and you can you

00:03:59,609 --> 00:04:05,280
can get the value of a mark so the the

00:04:03,419 --> 00:04:07,230
page cache uses a list it marks pages

00:04:05,280 --> 00:04:12,180
being dirty and then you can iterate

00:04:07,230 --> 00:04:15,650
over every dirty page there are other

00:04:12,180 --> 00:04:17,549
users who do other things with a

00:04:15,650 --> 00:04:19,289
choose-your-own-adventure there's some

00:04:17,549 --> 00:04:23,789
really really fun adventure fun things

00:04:19,289 --> 00:04:25,710
you can do with marks back in the radix

00:04:23,789 --> 00:04:26,940
tree days this replaces the radix tree

00:04:25,710 --> 00:04:28,740
by the way I forgot to mention that

00:04:26,940 --> 00:04:30,840
earlier this places the radix tree and

00:04:28,740 --> 00:04:32,610
so if you're looking at radix

00:04:30,840 --> 00:04:35,000
reconverted code it might well use the

00:04:32,610 --> 00:04:39,350
name tag

00:04:35,000 --> 00:04:41,210
that name conflicts with the traditional

00:04:39,350 --> 00:04:42,650
meaning of a tagged pointer which the

00:04:41,210 --> 00:04:46,070
point that has some of his lower bits

00:04:42,650 --> 00:04:49,640
usurped in order to indicate some amount

00:04:46,070 --> 00:04:51,860
of meaning and we had people who want to

00:04:49,640 --> 00:04:53,300
store tags pointers in the x-ray and

00:04:51,860 --> 00:04:55,640
they were getting quite confused between

00:04:53,300 --> 00:04:58,610
the different kinds of tags and I tried

00:04:55,640 --> 00:04:59,960
to document my way out of it I decided

00:04:58,610 --> 00:05:02,360
you know what it's easier just to change

00:04:59,960 --> 00:05:05,810
the name and I came with mark instead of

00:05:02,360 --> 00:05:08,740
tag either way it's three auxiliary bits

00:05:05,810 --> 00:05:12,169
and you can do useful things with them

00:05:08,740 --> 00:05:15,650
there are some less used parts of the

00:05:12,169 --> 00:05:18,560
normal API you can do an insert instead

00:05:15,650 --> 00:05:22,040
of a store and the the difference in

00:05:18,560 --> 00:05:25,940
semantics is that you will get back an

00:05:22,040 --> 00:05:28,040
error I think it's a exist if X a and

00:05:25,940 --> 00:05:32,470
surf if there is something that because

00:05:28,040 --> 00:05:34,610
non null you will get back any exists

00:05:32,470 --> 00:05:36,710
somewhat more useful even a little bit

00:05:34,610 --> 00:05:39,229
more tricky to use is XA compare and

00:05:36,710 --> 00:05:40,940
exchange and XA insert is actually

00:05:39,229 --> 00:05:43,030
implemented ref around comparing

00:05:40,940 --> 00:05:45,440
exchanges comparing exchanging with null

00:05:43,030 --> 00:05:47,990
but some people really want to use the

00:05:45,440 --> 00:05:49,220
insert okay I mean you know you look at

00:05:47,990 --> 00:05:50,840
the code it's like yeah this totally

00:05:49,220 --> 00:05:54,020
makes sense to use the the insert

00:05:50,840 --> 00:05:55,729
wrapper instead of a big compare

00:05:54,020 --> 00:05:57,140
exchange the big advantage of compare

00:05:55,729 --> 00:05:59,690
exchange is that you do get back the

00:05:57,140 --> 00:06:00,890
current value so that you can do

00:05:59,690 --> 00:06:06,650
different things depending on what you

00:06:00,890 --> 00:06:09,200
get back some some places like to look

00:06:06,650 --> 00:06:12,890
look in the tree see that there's

00:06:09,200 --> 00:06:15,680
nothing for a particular index allocate

00:06:12,890 --> 00:06:19,790
a new data structure and then try and

00:06:15,680 --> 00:06:21,260
insert it into the tree well if somebody

00:06:19,790 --> 00:06:22,820
else is running through that same bit of

00:06:21,260 --> 00:06:25,660
code then maybe somebody else beat you

00:06:22,820 --> 00:06:28,370
to it and inserted something first and

00:06:25,660 --> 00:06:30,770
then what you would want to do is free

00:06:28,370 --> 00:06:33,050
yours and return this this gives you the

00:06:30,770 --> 00:06:34,910
lookup so you in the radix tree code

00:06:33,050 --> 00:06:38,390
it's quite common to see and now I'm

00:06:34,910 --> 00:06:41,420
going to go off and look it up you don't

00:06:38,390 --> 00:06:44,860
need to do that you get back

00:06:41,420 --> 00:06:44,860
but the value that you're after

00:06:45,710 --> 00:06:55,550
xa find that starting at index look

00:06:52,460 --> 00:06:58,090
forward in the tree up up to max to find

00:06:55,550 --> 00:06:58,090
the next one

00:06:58,630 --> 00:07:02,600
there's also next a find after that I

00:07:00,920 --> 00:07:05,720
didn't bombers document which will look

00:07:02,600 --> 00:07:09,080
at index plus one will be the lowest

00:07:05,720 --> 00:07:13,040
value or return and then there's XA

00:07:09,080 --> 00:07:16,880
reserve which will reserve a spot for

00:07:13,040 --> 00:07:20,150
you in the tree but not out but it puts

00:07:16,880 --> 00:07:23,720
in a value which will cut which will

00:07:20,150 --> 00:07:26,090
look to be null by anybody else but you

00:07:23,720 --> 00:07:28,760
get two so you get to use this is

00:07:26,090 --> 00:07:31,160
basically saying I can allocate memory

00:07:28,760 --> 00:07:34,010
now but I'm about to take some

00:07:31,160 --> 00:07:35,660
complicated series of spin locks such

00:07:34,010 --> 00:07:38,600
that I won't be able to sleep to

00:07:35,660 --> 00:07:42,710
allocate space to put this in the array

00:07:38,600 --> 00:07:45,650
later I think we've got like three years

00:07:42,710 --> 00:07:47,300
of this I've been through I've been

00:07:45,650 --> 00:07:49,070
through the kernel we've got yeah we

00:07:47,300 --> 00:07:52,070
don't have very many users of XA reserve

00:07:49,070 --> 00:07:54,730
it's not something that most people have

00:07:52,070 --> 00:07:54,730
to care about

00:08:00,750 --> 00:08:06,419
the question was whether it expands the

00:08:02,790 --> 00:08:09,090
array up as far as index it ensures

00:08:06,419 --> 00:08:12,600
there is space in the array for that

00:08:09,090 --> 00:08:18,540
index such that a a subsequent store

00:08:12,600 --> 00:08:20,570
will not need to allocate memory I'm

00:08:18,540 --> 00:08:25,380
sorry

00:08:20,570 --> 00:08:28,979
yes insert will work on session correct

00:08:25,380 --> 00:08:34,289
yes ah I see I didn't understand your

00:08:28,979 --> 00:08:38,130
question yes it's not reserving it

00:08:34,289 --> 00:08:39,450
exclusively for your use because that

00:08:38,130 --> 00:08:40,890
would require having some way to

00:08:39,450 --> 00:08:42,599
determine what the difference was

00:08:40,890 --> 00:08:48,870
between you calling XD insert and that

00:08:42,599 --> 00:08:50,220
person over there calling XA insert we

00:08:48,870 --> 00:08:51,510
do can't mark another entries but there

00:08:50,220 --> 00:09:01,950
wasn't necessarily somewhere to store

00:08:51,510 --> 00:09:07,140
the mark I think I was like a concurrent

00:09:01,950 --> 00:09:11,100
arrays you need a lot well okay that

00:09:07,140 --> 00:09:18,959
depends on on your eraser side a lot of

00:09:11,100 --> 00:09:20,190
places don't call arrays will know that

00:09:18,959 --> 00:09:23,490
there is something there before they

00:09:20,190 --> 00:09:24,870
call arrays but you know it's up to your

00:09:23,490 --> 00:09:26,700
code to figure out this kind of thing

00:09:24,870 --> 00:09:28,740
for yourself I don't think it's on the

00:09:26,700 --> 00:09:31,250
x-ray to do that for you I saw a

00:09:28,740 --> 00:09:31,250
question here

00:09:44,139 --> 00:09:51,740
l okay Wi-Fi you have reserved then

00:09:48,170 --> 00:09:53,509
after that you may not have the next

00:09:51,740 --> 00:09:55,579
type of you want to use or something you

00:09:53,509 --> 00:09:57,499
may still need to call yeah I think it's

00:09:55,579 --> 00:10:00,230
the same point the boss is making that

00:09:57,499 --> 00:10:03,920
if somebody else erases it after you've

00:10:00,230 --> 00:10:06,800
called reserve and before you call store

00:10:03,920 --> 00:10:09,649
then you might not have memory available

00:10:06,800 --> 00:10:11,149
to you you you you should not use the

00:10:09,649 --> 00:10:12,559
raid extreme how you should not use the

00:10:11,149 --> 00:10:13,759
x-ray in that work yeah I mean you

00:10:12,559 --> 00:10:16,459
should make sure you should make sure

00:10:13,759 --> 00:10:19,040
you're not going to do that except most

00:10:16,459 --> 00:10:20,300
most places don't need to do that kind

00:10:19,040 --> 00:10:21,860
of thing that it just needs to be

00:10:20,300 --> 00:10:25,870
possible it doesn't need to be part of

00:10:21,860 --> 00:10:28,339
the regular API speaking of which

00:10:25,870 --> 00:10:32,660
actually so any more questions before it

00:10:28,339 --> 00:10:34,220
yeah what if you erase something the

00:10:32,660 --> 00:10:38,629
same chunk that is fine it does not

00:10:34,220 --> 00:10:42,350
matter it does not unreserve it what we

00:10:38,629 --> 00:10:45,110
actually do is is store a internal value

00:10:42,350 --> 00:10:47,389
there which means keep this occupied

00:10:45,110 --> 00:10:48,649
keep this sauce occupied now if somebody

00:10:47,389 --> 00:10:52,040
calls X a raise they will get rid of

00:10:48,649 --> 00:10:54,259
that but yeah it shouldn't be affected

00:10:52,040 --> 00:10:56,720
by any operations around it I should

00:10:54,259 --> 00:11:00,230
point out this internal value will never

00:10:56,720 --> 00:11:02,870
be returned by X a for each so if you

00:11:00,230 --> 00:11:07,399
iterate across it you it will appear to

00:11:02,870 --> 00:11:09,589
be null to you but if you use the

00:11:07,399 --> 00:11:11,600
advanced API you actually do get to see

00:11:09,589 --> 00:11:15,110
all of the internal entries and a whole

00:11:11,600 --> 00:11:16,939
bunch of other gunk that you should know

00:11:15,110 --> 00:11:19,040
about because you've you've decided to

00:11:16,939 --> 00:11:20,870
use the advanced API I'm not going to

00:11:19,040 --> 00:11:23,569
talk about the advanced API in this talk

00:11:20,870 --> 00:11:25,189
I have written kernel doc for that for

00:11:23,569 --> 00:11:31,089
all of the functions in it I have

00:11:25,189 --> 00:11:31,089
written an rst file please read it

00:11:39,410 --> 00:11:45,630
so you think can you saw any value in

00:11:42,480 --> 00:11:47,790
the x-ray yeah okay hmm what you can

00:11:45,630 --> 00:11:49,230
store in the x-ray today and what you

00:11:47,790 --> 00:11:51,600
can source more I'm going to be slightly

00:11:49,230 --> 00:11:55,009
different but what the documentation

00:11:51,600 --> 00:11:58,589
says at the moment is you can store any

00:11:55,009 --> 00:12:00,779
pointer returned from came a lock or get

00:11:58,589 --> 00:12:08,480
three pages or any of that kind of thing

00:12:00,779 --> 00:12:11,009
you can store you cannot necessarily

00:12:08,480 --> 00:12:13,230
okay you you you you have to avoid

00:12:11,009 --> 00:12:16,110
pointers which are which are only two

00:12:13,230 --> 00:12:18,000
byte aligned and not fall behind which

00:12:16,110 --> 00:12:24,180
is upset the motorola 68000 people

00:12:18,000 --> 00:12:25,380
somewhat because they want m6 tak is the

00:12:24,180 --> 00:12:26,940
gift that keeps on giving they they they

00:12:25,380 --> 00:12:28,410
have some they have they have some

00:12:26,940 --> 00:12:30,769
kernel pointers which are only two byte

00:12:28,410 --> 00:12:30,769
aligned

00:12:36,980 --> 00:12:43,730
yeah so from and you can't necessarily

00:12:39,990 --> 00:12:45,690
put a pointer into a data structure

00:12:43,730 --> 00:12:50,850
though you can put the base address from

00:12:45,690 --> 00:12:53,610
a came out you can't necessary put this

00:12:50,850 --> 00:12:56,390
this is this is something I think I'm

00:12:53,610 --> 00:12:59,070
probably going to end up fixing but

00:12:56,390 --> 00:13:03,480
we'll see we'll see what happens live it

00:12:59,070 --> 00:13:04,980
round yeah exactly yeah we so what one

00:13:03,480 --> 00:13:08,070
of the other things you can store in

00:13:04,980 --> 00:13:10,529
this is what I call I haven't put any of

00:13:08,070 --> 00:13:14,190
this in the slides is what I call X a

00:13:10,529 --> 00:13:17,270
values and this is particularly useful

00:13:14,190 --> 00:13:21,899
in the page cache we use it for storing

00:13:17,270 --> 00:13:24,959
shadow entries and Dax entries and swap

00:13:21,899 --> 00:13:28,200
entries or all kinds of things because

00:13:24,959 --> 00:13:31,620
the page cache overloads everything but

00:13:28,200 --> 00:13:33,810
there is one user it's the the raid five

00:13:31,620 --> 00:13:36,270
code the raid five code actually wants

00:13:33,810 --> 00:13:41,279
to store integers they were storing

00:13:36,270 --> 00:13:43,980
integers in the raid extreme and so you

00:13:41,279 --> 00:13:46,830
can see there's a facility for this you

00:13:43,980 --> 00:13:49,529
can store any integer between zero and

00:13:46,830 --> 00:13:51,990
long max you can't go you can't do a

00:13:49,529 --> 00:13:54,930
negative integers or anything good like

00:13:51,990 --> 00:13:57,540
between long max and you long max but

00:13:54,930 --> 00:14:00,000
zero to long max was enough for their

00:13:57,540 --> 00:14:05,250
purposes and it's nothing most people's

00:14:00,000 --> 00:14:09,089
purposes - okay so yeah this is the

00:14:05,250 --> 00:14:11,040
advanced API it does such a take I've

00:14:09,089 --> 00:14:13,320
given you helper functions takes care of

00:14:11,040 --> 00:14:15,180
doing shifts for you the radix tree for

00:14:13,320 --> 00:14:16,920
though for those who who haven't used

00:14:15,180 --> 00:14:19,279
the registry the registry made you do

00:14:16,920 --> 00:14:24,860
all kinds of encoding yourself

00:14:19,279 --> 00:14:28,170
that was poor API design I fixed it

00:14:24,860 --> 00:14:35,040
the types look right for how everything

00:14:28,170 --> 00:14:37,350
it works the right way so one of the

00:14:35,040 --> 00:14:40,560
things with the radix tree was it was

00:14:37,350 --> 00:14:42,860
really really hard to introduce new

00:14:40,560 --> 00:14:44,600
functionality

00:14:42,860 --> 00:14:46,640
and I'm all about introducing new

00:14:44,600 --> 00:14:49,820
functionality because I was very

00:14:46,640 --> 00:14:51,380
concerned with you know being able to do

00:14:49,820 --> 00:14:54,470
you know 2 megabyte pages in the page

00:14:51,380 --> 00:14:56,600
cache and this is how I got started the

00:14:54,470 --> 00:14:59,750
whole thing so what I ended up doing was

00:14:56,600 --> 00:15:01,970
writing the these these lower level

00:14:59,750 --> 00:15:03,290
functions which all start xa s and they

00:15:01,970 --> 00:15:06,500
take an X a state as their first

00:15:03,290 --> 00:15:09,920
parameter and you you can tie them

00:15:06,500 --> 00:15:12,800
together pretty effectively to create an

00:15:09,920 --> 00:15:14,660
arbitrarily complicated function this

00:15:12,800 --> 00:15:16,220
this this is comparing exchange which is

00:15:14,660 --> 00:15:20,780
you know it's a relatively complicated

00:15:16,220 --> 00:15:24,410
function but you could imagine for your

00:15:20,780 --> 00:15:26,810
own code if you're so inclined you could

00:15:24,410 --> 00:15:28,760
do any kind of comparisons with you know

00:15:26,810 --> 00:15:30,620
what what what is the value of current

00:15:28,760 --> 00:15:32,330
and you know is it less than this or

00:15:30,620 --> 00:15:38,600
greater than that or does it have these

00:15:32,330 --> 00:15:40,010
other bits set it's up to you but you

00:15:38,600 --> 00:15:42,560
don't have to come to me and say hey

00:15:40,010 --> 00:15:44,900
Kent can you add this function to the

00:15:42,560 --> 00:15:47,030
API you can just you can just embed

00:15:44,900 --> 00:15:49,880
something that looks like this in your

00:15:47,030 --> 00:15:52,250
own code again most people are just

00:15:49,880 --> 00:15:54,080
never gonna need this but the page cache

00:15:52,250 --> 00:15:56,420
does the page cache uses the advanced

00:15:54,080 --> 00:15:58,850
API throughout there's a couple of small

00:15:56,420 --> 00:16:01,780
places where it uses the normal API but

00:15:58,850 --> 00:16:04,250
because the page cache is doing so much

00:16:01,780 --> 00:16:05,900
fiddling with the internal guts of the X

00:16:04,250 --> 00:16:08,060
array it's just really appropriate to

00:16:05,900 --> 00:16:10,360
use the XA state throughout the page

00:16:08,060 --> 00:16:10,360
cache

00:16:12,050 --> 00:16:18,900
now one of the things that I added

00:16:15,270 --> 00:16:22,140
relatively late on is the the x-ray can

00:16:18,900 --> 00:16:25,950
actually do allocation so normally what

00:16:22,140 --> 00:16:30,900
you say to the x-ray is store this

00:16:25,950 --> 00:16:33,600
pointer at index number 5 and the

00:16:30,900 --> 00:16:35,250
allocation API says I have this pointer

00:16:33,600 --> 00:16:37,740
please store it somewhere that is

00:16:35,250 --> 00:16:38,450
currently null and tell me where you put

00:16:37,740 --> 00:16:40,710
it

00:16:38,450 --> 00:16:44,520
tell me that you put it as index number

00:16:40,710 --> 00:16:47,160
5 and so that's what these two do like

00:16:44,520 --> 00:16:50,820
if you're familiar with the IDR API

00:16:47,160 --> 00:16:55,890
that's where the cyclic comes from it

00:16:50,820 --> 00:17:01,200
will give you a value and index into the

00:16:55,890 --> 00:17:03,630
way between min and Max the in in in my

00:17:01,200 --> 00:17:05,189
guitry you'll see that the paid

00:17:03,630 --> 00:17:10,410
allocator actually uses this already

00:17:05,189 --> 00:17:14,520
which is kind of cool when you are using

00:17:10,410 --> 00:17:15,660
the x-ray 4 for allocation purposes you

00:17:14,520 --> 00:17:17,819
actually initialize it slightly

00:17:15,660 --> 00:17:19,620
difference you you you give it a couple

00:17:17,819 --> 00:17:21,260
of you give it an extra flag that says

00:17:19,620 --> 00:17:27,360
I'm going to use this for allocation and

00:17:21,260 --> 00:17:31,080
it uses one of the the the mark bits to

00:17:27,360 --> 00:17:33,059
track which entries are free and it also

00:17:31,080 --> 00:17:34,830
changes how storing a null pointer works

00:17:33,059 --> 00:17:36,960
if you if you store a null pointer to an

00:17:34,830 --> 00:17:40,730
allocating x-ray it doesn't actually

00:17:36,960 --> 00:17:45,240
free at all it distinguishes between a

00:17:40,730 --> 00:17:49,290
slot which is reserved so so if you call

00:17:45,240 --> 00:17:51,950
X a a lock with a null pointer that does

00:17:49,290 --> 00:17:51,950
allocate it

00:17:53,620 --> 00:17:57,610
and you won't be allocated to anybody

00:17:55,450 --> 00:18:03,059
else but if anyone iterates over it

00:17:57,610 --> 00:18:05,650
they'll see it as a null pointer sorry

00:18:03,059 --> 00:18:08,260
yeah you can also call exhale if you

00:18:05,650 --> 00:18:09,610
want to reserve a particular index you

00:18:08,260 --> 00:18:17,010
can call X a reserved

00:18:09,610 --> 00:18:22,500
yes uses the exact same mechanism so

00:18:17,010 --> 00:18:25,600
yeah so until a couple of weeks ago

00:18:22,500 --> 00:18:28,960
calling X a X a store with the null

00:18:25,600 --> 00:18:30,940
pointer did free it up and then I was

00:18:28,960 --> 00:18:33,850
going through converting the IDR users

00:18:30,940 --> 00:18:38,020
and I found that C groups actually wants

00:18:33,850 --> 00:18:40,899
to it was a two-stage freeing process so

00:18:38,020 --> 00:18:42,940
it once it wants the array they won't

00:18:40,899 --> 00:18:46,630
see the the array entry to appear as

00:18:42,940 --> 00:18:49,840
null but not to be allocatable

00:18:46,630 --> 00:18:52,000
and I didn't have a way in the API at

00:18:49,840 --> 00:18:55,110
the time to transition an entry back

00:18:52,000 --> 00:18:58,630
from being allocated to being

00:18:55,110 --> 00:19:02,169
unallocated ball but null and so I

00:18:58,630 --> 00:19:05,529
changed the semantics of X a store which

00:19:02,169 --> 00:19:11,549
like I I regret but every other solution

00:19:05,529 --> 00:19:11,549
I came up with was worse in my opinion

00:19:15,690 --> 00:19:23,429
so I've got a git tree here which has

00:19:20,249 --> 00:19:27,749
conversions of every single radix tree

00:19:23,429 --> 00:19:30,960
user over to use the x-ray it contains

00:19:27,749 --> 00:19:33,509
some of the IDR conversions there's

00:19:30,960 --> 00:19:36,600
something like 150 users of the IDR in

00:19:33,509 --> 00:19:39,110
the kernel I've tackled the hard ones oh

00:19:36,600 --> 00:19:42,149
I'm starting out tackling the hard ones

00:19:39,110 --> 00:19:45,809
because that's how you know whether your

00:19:42,149 --> 00:19:47,909
API works is does it does it work for

00:19:45,809 --> 00:19:50,669
all of the hard users cuz there's a

00:19:47,909 --> 00:19:52,830
whole bunch of drivers which just use it

00:19:50,669 --> 00:19:55,049
and it's really really easy and then

00:19:52,830 --> 00:19:57,899
there's places like C groups which are

00:19:55,049 --> 00:20:00,989
trying to do something really quite hard

00:19:57,899 --> 00:20:02,249
and you know you you you need you need

00:20:00,989 --> 00:20:03,749
you need to support those people you

00:20:02,249 --> 00:20:10,590
need to you have API that works for

00:20:03,749 --> 00:20:12,210
those people so once we finished

00:20:10,590 --> 00:20:15,749
converting the IDR we actually get to

00:20:12,210 --> 00:20:18,059
get rid of a whole bunch of nasty stuff

00:20:15,749 --> 00:20:19,980
nasty code from the kernel and I'm so

00:20:18,059 --> 00:20:21,859
that's that's why I'm really looking at

00:20:19,980 --> 00:20:27,509
it not because I have a fundamental

00:20:21,859 --> 00:20:31,950
hatred of IDR you the IDR API just just

00:20:27,509 --> 00:20:34,230
just one bit of it another important

00:20:31,950 --> 00:20:36,119
thing you can use this for is to replace

00:20:34,230 --> 00:20:37,499
custom implementations of resizing erase

00:20:36,119 --> 00:20:39,570
I've got a great example of this in a

00:20:37,499 --> 00:20:42,029
minute and one of the surprising things

00:20:39,570 --> 00:20:43,769
I haven't been thinking about until

00:20:42,029 --> 00:20:45,869
fairly recently was the realization is

00:20:43,769 --> 00:20:48,749
actually going to be more cache

00:20:45,869 --> 00:20:52,470
efficient to use an x-ray than a linked

00:20:48,749 --> 00:20:54,539
list which will be a monumental amount

00:20:52,470 --> 00:20:59,009
of changes I'm not volunteering to do in

00:20:54,539 --> 00:21:02,809
the slightest but maybe you should don't

00:20:59,009 --> 00:21:02,809
use it for any of these things right now

00:21:04,100 --> 00:21:12,210
the bottom ones funny the FDD table okay

00:21:06,989 --> 00:21:15,210
so first glance it looks obvious right

00:21:12,210 --> 00:21:17,580
the if when when when when you are

00:21:15,210 --> 00:21:20,620
trying to map file descriptors into a

00:21:17,580 --> 00:21:24,010
struct file pointer well that is a small

00:21:20,620 --> 00:21:26,160
integer being mapped into a pointer okay

00:21:24,010 --> 00:21:30,970
well this is exactly what the x-ray does

00:21:26,160 --> 00:21:34,030
and then I was all set to do this and

00:21:30,970 --> 00:21:37,690
then Google said to me um we have this

00:21:34,030 --> 00:21:41,080
process that has 200,000 file

00:21:37,690 --> 00:21:43,840
descriptors open and the cache misses

00:21:41,080 --> 00:21:47,500
that you are going to introduce by using

00:21:43,840 --> 00:21:52,780
a tree to store these pointers is going

00:21:47,500 --> 00:21:54,880
to drop performance by percent we really

00:21:52,780 --> 00:21:56,770
need to use a v-mail locked array the

00:21:54,880 --> 00:22:02,470
way that we currently are please keep

00:21:56,770 --> 00:22:08,230
your hands off the FD table I don't have

00:22:02,470 --> 00:22:09,820
a solution yet so yeah I'm just gonna

00:22:08,230 --> 00:22:16,990
leave that one alone and I'm not going

00:22:09,820 --> 00:22:22,030
to touch that one but okay well why not

00:22:16,990 --> 00:22:25,330
sparse arrays um the current data

00:22:22,030 --> 00:22:28,360
structure underlying the x-ray is the

00:22:25,330 --> 00:22:34,150
radix tree I haven't changed how it

00:22:28,360 --> 00:22:39,640
works yet the radix tree is not is is is

00:22:34,150 --> 00:22:41,320
not very efficient if you if if the

00:22:39,640 --> 00:22:44,679
indices you were using a widely spread

00:22:41,320 --> 00:22:46,530
out and there's big gaps the data

00:22:44,679 --> 00:22:49,960
structure blows up it looks absolutely

00:22:46,530 --> 00:22:51,670
horrid I mean I've done some experiments

00:22:49,960 --> 00:22:54,220
and say wow we are wasting a lot of

00:22:51,670 --> 00:22:58,780
memory here and it takes a very long

00:22:54,220 --> 00:23:00,400
time to access any entry in it I have a

00:22:58,780 --> 00:23:04,630
plan

00:23:00,400 --> 00:23:10,390
colleague Liam Howlett and I are working

00:23:04,630 --> 00:23:12,970
on an RC you safe B tree it is not ready

00:23:10,390 --> 00:23:15,790
for presentation yet we've white border

00:23:12,970 --> 00:23:17,860
dips we've started working on code it's

00:23:15,790 --> 00:23:21,010
not ready to be talked about in any

00:23:17,860 --> 00:23:23,770
detail yet there's fundamental decisions

00:23:21,010 --> 00:23:26,290
that we we are ready to remake at a

00:23:23,770 --> 00:23:28,080
moment's notice once we've got some idea

00:23:26,290 --> 00:23:32,009
of how it's going to

00:23:28,080 --> 00:23:35,759
so we fully intend to support the use

00:23:32,009 --> 00:23:39,590
sort of you sort of uses that sparse

00:23:35,759 --> 00:23:43,019
arrays hash tables ranges RB trees all

00:23:39,590 --> 00:23:44,490
encounter today but we're not ready yet

00:23:43,019 --> 00:23:48,929
so don't do it

00:23:44,490 --> 00:23:51,450
yet but you know next year I might be

00:23:48,929 --> 00:23:53,669
standing here saying hey these four data

00:23:51,450 --> 00:23:56,669
structures you can just stop using them

00:23:53,669 --> 00:24:02,999
and convert over to use the x-ray we'll

00:23:56,669 --> 00:24:04,710
see so this is the AIO code and I want

00:24:02,999 --> 00:24:06,779
to thank Dan carpenter for mentioning

00:24:04,710 --> 00:24:12,769
this earlier in the conference

00:24:06,779 --> 00:24:17,580
he has his s match code flagged this as

00:24:12,769 --> 00:24:20,129
a Spector allocation so for those who

00:24:17,580 --> 00:24:24,659
aren't familiar with Spector on the

00:24:20,129 --> 00:24:30,149
first line we we get the the ID from

00:24:24,659 --> 00:24:32,279
user space and then we we check ID

00:24:30,149 --> 00:24:34,409
greater than equal to table number okay

00:24:32,279 --> 00:24:36,509
so we're checking that we're not going

00:24:34,409 --> 00:24:38,909
to over on the bounds of it but with

00:24:36,509 --> 00:24:42,210
CPUs being speculatively executing it

00:24:38,909 --> 00:24:44,389
will it will because because there's no

00:24:42,210 --> 00:24:49,590
there's no guard on it the CPU will

00:24:44,389 --> 00:24:53,309
speculatively fetch doodle spec if you

00:24:49,590 --> 00:24:55,259
do that table arrow table ID so all

00:24:53,309 --> 00:24:57,480
spectra to effects from somewhere in

00:24:55,259 --> 00:25:01,230
memory anywhere in memory that's up to

00:24:57,480 --> 00:25:02,850
four billion bytes beyond four billion

00:25:01,230 --> 00:25:04,820
right because these are pointers so

00:25:02,850 --> 00:25:06,960
that's going to be 32 billion bytes

00:25:04,820 --> 00:25:10,919
beyond wherever table happens to be

00:25:06,960 --> 00:25:12,720
pointing and that's how you get and then

00:25:10,919 --> 00:25:14,249
the cache timing attacks blah blah blah

00:25:12,720 --> 00:25:16,309
you can read up on how Spector works if

00:25:14,249 --> 00:25:21,679
you do if you don't already know

00:25:16,309 --> 00:25:24,720
so this sparse was right oh this is a

00:25:21,679 --> 00:25:26,549
specter problem it's only respect a

00:25:24,720 --> 00:25:28,889
problem for tasks which are using a i/o

00:25:26,549 --> 00:25:31,470
but you know if you if you're if you're

00:25:28,889 --> 00:25:32,970
trying to exploit the kernel respect so

00:25:31,470 --> 00:25:35,269
that's not that's not a hard thing to

00:25:32,970 --> 00:25:35,269
find

00:25:35,350 --> 00:25:42,040
the the x-ray is invulnerable to Spectre

00:25:39,460 --> 00:25:44,470
because at each level that it indexes

00:25:42,040 --> 00:25:47,260
into the array it masks off the bits

00:25:44,470 --> 00:25:50,620
that it needs so there is no point at

00:25:47,260 --> 00:25:56,830
which the CPU will speculatively load

00:25:50,620 --> 00:25:59,680
from an address which is outside of the

00:25:56,830 --> 00:26:02,110
allocated space do I have this right

00:25:59,680 --> 00:26:10,860
Dave you look you looking a little

00:26:02,110 --> 00:26:10,860
specters escaped ok ok thank you

00:26:11,410 --> 00:26:17,530
so yeah this this is an example of code

00:26:15,490 --> 00:26:21,040
which in my opinion very much should be

00:26:17,530 --> 00:26:23,020
converted using the x-ray I haven't sent

00:26:21,040 --> 00:26:25,600
the patch out of you in fact I wrote it

00:26:23,020 --> 00:26:26,950
this morning's - because Dan carpenter

00:26:25,600 --> 00:26:30,250
reminded me that this was something you

00:26:26,950 --> 00:26:34,810
didn't need to do the complete diff for

00:26:30,250 --> 00:26:38,920
this is on the order of I think 126

00:26:34,810 --> 00:26:42,310
lines deleted 60 lines added so you know

00:26:38,920 --> 00:26:45,970
it's a significant simplification of the

00:26:42,310 --> 00:26:48,970
the code base to get rid of all of this

00:26:45,970 --> 00:26:52,390
code which attempts to implement its own

00:26:48,970 --> 00:26:54,640
resizing array of pointers use the one

00:26:52,390 --> 00:26:56,290
that I've provided for you in less your

00:26:54,640 --> 00:27:02,020
Google and you have two hundred thousand

00:26:56,290 --> 00:27:04,660
files in a single process so this is

00:27:02,020 --> 00:27:08,140
probably why you came and I've got what

00:27:04,660 --> 00:27:11,110
time I need you to finish until 45 what

00:27:08,140 --> 00:27:14,200
do I have until 30 and we keep going

00:27:11,110 --> 00:27:19,470
what Ted looks that up okay so what you

00:27:14,200 --> 00:27:23,620
can do is oh great there's a time great

00:27:19,470 --> 00:27:26,020
so if you just need to keep a list of

00:27:23,620 --> 00:27:27,430
objects and this right over them you can

00:27:26,020 --> 00:27:29,260
just delete the list head from your data

00:27:27,430 --> 00:27:32,140
structure you can you you can just say

00:27:29,260 --> 00:27:33,580
put this pointer into the x-ray put this

00:27:32,140 --> 00:27:36,190
pointer into the x-ray and then you use

00:27:33,580 --> 00:27:39,580
the X a for each that we saw earlier to

00:27:36,190 --> 00:27:41,350
just iterate over all the pointers this

00:27:39,580 --> 00:27:42,370
assumes you don't care about order this

00:27:41,350 --> 00:27:46,290
assumes

00:27:42,370 --> 00:27:51,550
you you know you you don't need to

00:27:46,290 --> 00:27:54,000
delete them from the middle if you need

00:27:51,550 --> 00:27:57,370
to delete the middle then you need to

00:27:54,000 --> 00:27:59,650
store which I okay to to two

00:27:57,370 --> 00:28:03,610
possibilities either you need to store

00:27:59,650 --> 00:28:05,170
the object ID in your object or you just

00:28:03,610 --> 00:28:06,670
take the performance hit of iterate over

00:28:05,170 --> 00:28:10,000
all of them until you get to the one

00:28:06,670 --> 00:28:12,070
which matches your pointer and there's

00:28:10,000 --> 00:28:14,980
nothing wrong with that I mean for you

00:28:12,070 --> 00:28:19,270
know for small N and O N squared

00:28:14,980 --> 00:28:20,710
algorithm isn't bad if you if you're

00:28:19,270 --> 00:28:23,230
fairly sure you're never going to have

00:28:20,710 --> 00:28:26,410
more than ten USB devices taking order

00:28:23,230 --> 00:28:30,220
of a hundred to delete your USB devices

00:28:26,410 --> 00:28:32,290
that's my big deal until somebody plugs

00:28:30,220 --> 00:28:35,590
in a thousand USB devices and and and

00:28:32,290 --> 00:28:38,200
then you were wrong maybe you should

00:28:35,590 --> 00:28:41,309
take the full byte the memory hit

00:28:38,200 --> 00:28:41,309
[Music]

00:28:48,309 --> 00:28:52,120
yeah yeah absolutely

00:28:59,399 --> 00:29:04,690
yeah exactly

00:29:01,599 --> 00:29:08,549
exactly right you right yes yes you are

00:29:04,690 --> 00:29:11,229
saving 12 bytes exactly all right but

00:29:08,549 --> 00:29:14,379
some some objects can be on one of

00:29:11,229 --> 00:29:16,989
several lists i I just saw a patch float

00:29:14,379 --> 00:29:18,940
by which has okay we've got a list of

00:29:16,989 --> 00:29:21,489
pages which were entirely full and we

00:29:18,940 --> 00:29:24,039
will a list of pages which are not

00:29:21,489 --> 00:29:26,769
entirely full and so at some point we'll

00:29:24,039 --> 00:29:30,549
move the page from one list to another

00:29:26,769 --> 00:29:33,009
list okay so in that case the object

00:29:30,549 --> 00:29:35,169
needs to remember which list it's part

00:29:33,009 --> 00:29:38,859
of and you can either do that with you

00:29:35,169 --> 00:29:41,200
know storing your own maybe have a small

00:29:38,859 --> 00:29:43,210
array of lists or maybe need actually to

00:29:41,200 --> 00:29:46,629
store a pointer to the list that it

00:29:43,210 --> 00:29:48,190
happens to be on that's up to you

00:29:46,629 --> 00:29:50,979
you're choosing to use the Oaks array

00:29:48,190 --> 00:29:52,059
you do what makes sense for you but in

00:29:50,979 --> 00:29:54,099
the worst case where you have to sort

00:29:52,059 --> 00:29:58,809
pointer well you're still up by 4 bytes

00:29:54,099 --> 00:30:00,429
you've still got a 4 by when the other

00:29:58,809 --> 00:30:03,429
possibility is that maybe you can avoid

00:30:00,429 --> 00:30:05,739
having multiple lists for the particular

00:30:03,429 --> 00:30:08,529
case that I just mentioned you could use

00:30:05,739 --> 00:30:10,749
one of the mark bits in order to say

00:30:08,529 --> 00:30:12,789
this page is full this page is not full

00:30:10,749 --> 00:30:14,950
and then you can iterate over the pages

00:30:12,789 --> 00:30:19,649
which are not full when you're looking

00:30:14,950 --> 00:30:19,649
to allocate from one of the pages yes

00:30:28,750 --> 00:30:32,960
okay great thank you thank you for

00:30:30,980 --> 00:30:34,130
asking that Ted I was going I was I was

00:30:32,960 --> 00:30:35,210
going to try and remember to bring that

00:30:34,130 --> 00:30:36,920
up but I hadn't actually put it on the

00:30:35,210 --> 00:30:39,290
slides so the question the question was

00:30:36,920 --> 00:30:40,880
um these three bits can I can I treat

00:30:39,290 --> 00:30:43,100
them as a number between zero and seven

00:30:40,880 --> 00:30:45,740
or should I treat them as independent

00:30:43,100 --> 00:30:48,500
bits we have one piece of code in the

00:30:45,740 --> 00:30:50,630
kernel which treats them as a number

00:30:48,500 --> 00:30:53,450
between zero and seven I have rewritten

00:30:50,630 --> 00:30:57,560
that code because this does not lead to

00:30:53,450 --> 00:31:00,410
good performance outcomes so no the the

00:30:57,560 --> 00:31:06,110
way this is implemented is that you want

00:31:00,410 --> 00:31:06,890
to you want okay the page catch treats

00:31:06,110 --> 00:31:08,450
on the separate bits

00:31:06,890 --> 00:31:11,870
therefore the C data structure is

00:31:08,450 --> 00:31:14,090
optimized for the page cache you can

00:31:11,870 --> 00:31:16,010
search for individual bits you can't

00:31:14,090 --> 00:31:18,170
search for all of bits you can't search

00:31:16,010 --> 00:31:19,370
for and of bits you have to say I want

00:31:18,170 --> 00:31:21,290
to have a bit zero I'll just look for a

00:31:19,370 --> 00:31:24,020
bit one I want to look for bit too and

00:31:21,290 --> 00:31:27,110
the way it's implemented is that when

00:31:24,020 --> 00:31:29,330
you set a bit on a particular entry this

00:31:27,110 --> 00:31:31,370
is implemented as a tree so it's a bit

00:31:29,330 --> 00:31:32,600
on that entry and then it goes up to the

00:31:31,370 --> 00:31:34,010
parenting so it's a bit on that entry

00:31:32,600 --> 00:31:36,950
and I gotta parents that's a bit on that

00:31:34,010 --> 00:31:38,450
entry so when you implement the when you

00:31:36,950 --> 00:31:41,090
say gonna shrink this is a number

00:31:38,450 --> 00:31:46,310
between 0 and 7 and the the number is

00:31:41,090 --> 00:31:48,530
incremented from 4 from 3 to 4 you clear

00:31:46,310 --> 00:31:51,020
you clear bit 0 it is right all that the

00:31:48,530 --> 00:31:52,670
tree if you clear bit 1 iterates all the

00:31:51,020 --> 00:31:55,700
tree that he said bit took a phrase

00:31:52,670 --> 00:31:58,300
although this does not lead to good

00:31:55,700 --> 00:32:01,010
performance outcomes so I changed the

00:31:58,300 --> 00:32:04,450
the offending piece of code for 2

00:32:01,010 --> 00:32:07,370
instead of counting how many times this

00:32:04,450 --> 00:32:09,380
thing as something had happened to

00:32:07,370 --> 00:32:11,630
actually just chain off consecutive

00:32:09,380 --> 00:32:15,320
entries it's all debug code nobody

00:32:11,630 --> 00:32:20,510
really cares about it but I saw it and I

00:32:15,320 --> 00:32:22,910
was kind of horrified the problem is

00:32:20,510 --> 00:32:24,680
that once code is in the kernel somebody

00:32:22,910 --> 00:32:27,919
else might copy it and put in a

00:32:24,680 --> 00:32:31,070
performance path and then we'll

00:32:27,919 --> 00:32:31,070
stuffed up

00:32:36,690 --> 00:32:42,049
I assume the reason why it's only three

00:32:39,539 --> 00:32:42,049
markets

00:32:42,210 --> 00:32:58,450
winters are sorted so you you you you

00:32:56,560 --> 00:33:01,450
you are correct that asking for more

00:32:58,450 --> 00:33:03,010
than three bits will cost a lot it's the

00:33:01,450 --> 00:33:05,440
implementation isn't quite the way that

00:33:03,010 --> 00:33:06,640
you imagined it to be but you are not

00:33:05,440 --> 00:33:08,470
the only person who has asked for this

00:33:06,640 --> 00:33:10,870
Dave Chinna has also asked for having

00:33:08,470 --> 00:33:12,910
more than three bits and I have promised

00:33:10,870 --> 00:33:16,350
him that I will do my best to get him

00:33:12,910 --> 00:33:16,350
more than three bits

00:33:22,230 --> 00:33:26,130
but that's a good question so Dave

00:33:24,630 --> 00:33:29,100
Dave's asking it wouldn't make more

00:33:26,130 --> 00:33:31,950
sense to have this as an enum rather

00:33:29,100 --> 00:33:33,480
than a bit field and just have a flag

00:33:31,950 --> 00:33:35,730
somewhere in the x-ray header that says

00:33:33,480 --> 00:33:42,559
we're using this as as a number between

00:33:35,730 --> 00:33:46,490
0 & 7 rather than as a bit field maybe

00:33:42,559 --> 00:33:49,110
that that's a solution which we might

00:33:46,490 --> 00:33:51,530
mmm you file system people you're all

00:33:49,110 --> 00:33:51,530
the same

00:33:53,240 --> 00:34:04,760
yes then the search is learning that

00:33:55,679 --> 00:34:04,760
that that would be the trick yeah

00:34:08,520 --> 00:34:12,810
yeah the boats making the point that

00:34:10,679 --> 00:34:14,669
this the search is is it's going to be

00:34:12,810 --> 00:34:18,800
efficient and if you try to use as mean

00:34:14,669 --> 00:34:21,659
on the search won't be efficient well

00:34:18,800 --> 00:34:23,070
let yeah so I'm this is why I'm not

00:34:21,659 --> 00:34:29,010
making any promises about what could be

00:34:23,070 --> 00:34:33,260
done I'm reserving judgment yes yes yes

00:34:29,010 --> 00:34:39,330
I have ten minutes okay

00:34:33,260 --> 00:34:42,869
so generally users like this don't care

00:34:39,330 --> 00:34:44,550
about the order that pointers are in the

00:34:42,869 --> 00:34:46,050
list if you do care about the order then

00:34:44,550 --> 00:34:49,129
you can use the cyclic allocator that I

00:34:46,050 --> 00:34:52,679
showed you on a slide a few slides back

00:34:49,129 --> 00:34:55,770
we don't yet have a cyclic iterator so

00:34:52,679 --> 00:34:57,450
if you wrap round at some point things

00:34:55,770 --> 00:34:59,670
are going to become out of order and if

00:34:57,450 --> 00:35:05,010
that matters to you then we can always

00:34:59,670 --> 00:35:08,310
introduce a cyclic iterator the order of

00:35:05,010 --> 00:35:10,350
the cycle is four billion entries you

00:35:08,310 --> 00:35:11,760
know is it is it's it's it's possible

00:35:10,350 --> 00:35:15,119
you might wrap round and then you'd

00:35:11,760 --> 00:35:16,050
start seeing things out of order you

00:35:15,119 --> 00:35:19,710
know if this kind of thing is going to

00:35:16,050 --> 00:35:22,410
matter for to you then you know don't

00:35:19,710 --> 00:35:24,810
convert your linked list yet let's talk

00:35:22,410 --> 00:35:28,200
about ways we might try and make that

00:35:24,810 --> 00:35:29,940
kind of thing happen but we don't really

00:35:28,200 --> 00:35:31,920
use us for that yet so I'm not planning

00:35:29,940 --> 00:35:38,910
on solutions for those users who don't

00:35:31,920 --> 00:35:44,460
necessarily and takes a very long time

00:35:38,910 --> 00:35:46,140
to happen if an event happens ten times

00:35:44,460 --> 00:35:48,450
a second it's going to take one point

00:35:46,140 --> 00:35:51,190
two years before you even notice this

00:35:48,450 --> 00:35:54,070
happened so

00:35:51,190 --> 00:35:55,570
I mean something-something in computers

00:35:54,070 --> 00:35:57,940
happened more than 10 times a second I'm

00:35:55,570 --> 00:36:01,330
told but you know if you're using 4 USB

00:35:57,940 --> 00:36:03,880
devices you're never going to notice if

00:36:01,330 --> 00:36:05,980
you're using it for network packets then

00:36:03,880 --> 00:36:13,630
yeah you're gonna notice and it's gonna

00:36:05,980 --> 00:36:15,160
happen really quickly not yet I do not

00:36:13,630 --> 00:36:17,560
yet have guidance when this is a win

00:36:15,160 --> 00:36:20,740
when this is not a win my suggestion is

00:36:17,560 --> 00:36:22,870
that you you you suck it and see give it

00:36:20,740 --> 00:36:26,140
a try see if you like it

00:36:22,870 --> 00:36:29,650
it should be much more cache efficient

00:36:26,140 --> 00:36:32,890
because removing something from the

00:36:29,650 --> 00:36:34,510
linked list involves dirtying three

00:36:32,890 --> 00:36:36,640
cache lines it's your you dirty your own

00:36:34,510 --> 00:36:40,300
cache line you dirty your next and you

00:36:36,640 --> 00:36:45,040
dirty your probe because you've got to

00:36:40,300 --> 00:36:47,110
update those two points to each other no

00:36:45,040 --> 00:36:48,880
no no you know well you think you touch

00:36:47,110 --> 00:36:51,160
the spin lock at the top and then you

00:36:48,880 --> 00:36:53,710
read all the way down to your leaf and

00:36:51,160 --> 00:36:56,340
then you touch that leaf so you're

00:36:53,710 --> 00:37:01,240
dirtying two cache lines not three

00:36:56,340 --> 00:37:03,810
sounds like a win to me yeah

00:37:01,240 --> 00:37:03,810
right right

00:37:08,869 --> 00:37:12,720
you're quite right my comparing exchange

00:37:11,160 --> 00:37:16,309
operator does not actually use compare

00:37:12,720 --> 00:37:16,309
and exchange using the spin lock yes

00:37:20,920 --> 00:37:23,820
could we

00:37:29,490 --> 00:37:36,460
maybe so the answer is a definite maybe

00:37:32,800 --> 00:37:37,810
on that there are I want I want I want

00:37:36,460 --> 00:37:39,250
to fix up the data structure to be the

00:37:37,810 --> 00:37:40,540
bee tree first and then we'll start

00:37:39,250 --> 00:37:42,310
looking at places where we could

00:37:40,540 --> 00:37:43,450
eliminate in the spin log I would like

00:37:42,310 --> 00:37:47,080
to be able to eliminate the spin log

00:37:43,450 --> 00:37:48,370
from the top but there may be other

00:37:47,080 --> 00:37:52,180
things which end up mattering water

00:37:48,370 --> 00:37:53,650
performance one of the places were we

00:37:52,180 --> 00:37:56,560
desperately need to start using the

00:37:53,650 --> 00:37:57,970
x-ray is for the swapping code because

00:37:56,560 --> 00:38:00,430
the swapping code totally doesn't scale

00:37:57,970 --> 00:38:00,880
right now and if we make the swapping

00:38:00,430 --> 00:38:03,010
codes

00:38:00,880 --> 00:38:04,650
well actually the swapping code to be

00:38:03,010 --> 00:38:11,860
made to scale by brute force we

00:38:04,650 --> 00:38:14,260
currently split up our swap devices into

00:38:11,860 --> 00:38:16,440
one megabyte size pieces so that we have

00:38:14,260 --> 00:38:19,180
so we scale the number of spinlock since

00:38:16,440 --> 00:38:20,710
it's dreadful absolutely dreadful we

00:38:19,180 --> 00:38:23,590
should all be ashamed of us warping code

00:38:20,710 --> 00:38:25,510
because it's terrible but of course

00:38:23,590 --> 00:38:27,130
nobody wants to fix the swapping code

00:38:25,510 --> 00:38:29,890
because it's is really hard and

00:38:27,130 --> 00:38:31,690
complicated and so inevitably I will end

00:38:29,890 --> 00:38:34,120
up fixing the swapping code in about two

00:38:31,690 --> 00:38:40,330
years given the state of my to-do list

00:38:34,120 --> 00:38:41,680
at this point anyway so I do actually

00:38:40,330 --> 00:38:43,180
have summon having said I don't have any

00:38:41,680 --> 00:38:46,030
advice for when you shouldn't shouldn't

00:38:43,180 --> 00:38:49,750
use I just tried to summarize some

00:38:46,030 --> 00:38:52,840
advice here don't try and convert any of

00:38:49,750 --> 00:38:54,460
the li use over to the x-ray yet once

00:38:52,840 --> 00:38:56,950
well the new data structure in place it

00:38:54,460 --> 00:39:02,470
might work well for the LRU or it might

00:38:56,950 --> 00:39:04,270
still fail to the LRU for your standard

00:39:02,470 --> 00:39:06,580
device drivers just trying to keep hack

00:39:04,270 --> 00:39:09,100
of keep track of its devices this is

00:39:06,580 --> 00:39:10,750
great it's better than great because we

00:39:09,100 --> 00:39:12,820
actually a fairly frequent anti-pattern

00:39:10,750 --> 00:39:15,850
in drivers where they will use the ID a

00:39:12,820 --> 00:39:17,920
to allocate the number of the device and

00:39:15,850 --> 00:39:20,860
then they saw the devices in the linked

00:39:17,920 --> 00:39:23,860
list so despite the fact the ID r has

00:39:20,860 --> 00:39:26,770
existed for longer than the ID a rather

00:39:23,860 --> 00:39:30,540
than just using the ID r they use the ID

00:39:26,770 --> 00:39:30,540
a and a linked list

00:39:31,920 --> 00:39:41,950
hmm III have opinions about device

00:39:35,680 --> 00:39:45,970
driver writers I'm not expressing those

00:39:41,950 --> 00:39:48,730
a III have once been a device

00:39:45,970 --> 00:39:53,500
driver in fact in fact I myself have

00:39:48,730 --> 00:39:57,850
done worse in in the nvm Express driver

00:39:53,500 --> 00:39:59,380
I did exactly this now in my defense at

00:39:57,850 --> 00:40:01,660
the time I didn't do the worst

00:39:59,380 --> 00:40:03,670
anti-pattern I did not search the linked

00:40:01,660 --> 00:40:10,090
list to find devices which had matching

00:40:03,670 --> 00:40:11,200
IDs but somebody else then did be

00:40:10,090 --> 00:40:15,130
smarter than me

00:40:11,200 --> 00:40:16,720
don't do this another good reason not to

00:40:15,130 --> 00:40:21,610
do this is if you can't allocate memory

00:40:16,720 --> 00:40:23,530
at list ad or list move time because you

00:40:21,610 --> 00:40:25,180
you you may need to allocate memory and

00:40:23,530 --> 00:40:30,610
all in order to store this this this

00:40:25,180 --> 00:40:33,010
pointer once we have some experience

00:40:30,610 --> 00:40:34,810
converting linked lists using anything

00:40:33,010 --> 00:40:36,880
the x-ray may will decide that there's

00:40:34,810 --> 00:40:39,640
there's actually a better API there's an

00:40:36,880 --> 00:40:41,560
easier API that we could have that would

00:40:39,640 --> 00:40:43,540
let people use the underlying x-ray data

00:40:41,560 --> 00:40:46,450
structure and not even knows it's the

00:40:43,540 --> 00:40:49,990
x-ray like it's just the array of

00:40:46,450 --> 00:40:54,760
pointers API or something I don't know

00:40:49,990 --> 00:40:56,620
something something with a catchy name I

00:40:54,760 --> 00:40:59,800
mean I'm bad at names which is how we

00:40:56,620 --> 00:41:04,270
ended up with x-ray but you know III

00:40:59,800 --> 00:41:06,070
have no particular attachment to we must

00:41:04,270 --> 00:41:08,200
use the x-ray API every way like if

00:41:06,070 --> 00:41:10,210
there's an API which speaks to device

00:41:08,200 --> 00:41:13,210
driver writers and recommends itself and

00:41:10,210 --> 00:41:13,690
says don't use a linked list use me

00:41:13,210 --> 00:41:16,450
instead

00:41:13,690 --> 00:41:18,430
then that's let's find that name let's

00:41:16,450 --> 00:41:21,850
make it as easy and as obvious for

00:41:18,430 --> 00:41:22,690
people to use this as possible so I

00:41:21,850 --> 00:41:26,020
thought I'd show you a linked list

00:41:22,690 --> 00:41:28,000
conversion and I I picked on something

00:41:26,020 --> 00:41:30,400
James Bottomly once did and in his

00:41:28,000 --> 00:41:30,970
defense he did this before the x-ray

00:41:30,400 --> 00:41:32,830
exists

00:41:30,970 --> 00:41:36,400
long before the x-ray existed I think

00:41:32,830 --> 00:41:38,110
even before the IDR existed but what I'm

00:41:36,400 --> 00:41:40,530
trying to get across in this in the

00:41:38,110 --> 00:41:44,350
sliders it's

00:41:40,530 --> 00:41:45,940
almost exactly the same amount of code

00:41:44,350 --> 00:41:48,700
there's about the same number of plus

00:41:45,940 --> 00:41:53,440
and minus lines here to use the linked

00:41:48,700 --> 00:41:58,240
list and to use the x-ray if you find

00:41:53,440 --> 00:42:00,790
this hard to read I I do have an X term

00:41:58,240 --> 00:42:04,360
blown up behind this presentation if

00:42:00,790 --> 00:42:06,220
you'd rather see that but III think I

00:42:04,360 --> 00:42:09,690
think my point is clear it's it's not

00:42:06,220 --> 00:42:09,690
that complicated

00:42:09,940 --> 00:42:14,230
this code well the the patch that this

00:42:12,670 --> 00:42:18,880
was culled from does actually compile I

00:42:14,230 --> 00:42:22,870
haven't tested it or anything yeah you

00:42:18,880 --> 00:42:25,210
can see it's it's pretty cool the one

00:42:22,870 --> 00:42:27,220
thing I regret is that there's a GFP

00:42:25,210 --> 00:42:30,580
atomic there I looked through the call

00:42:27,220 --> 00:42:32,890
path of where these things get added to

00:42:30,580 --> 00:42:34,570
you know the list I'd tail above it is

00:42:32,890 --> 00:42:36,910
what it replaces and I looked through

00:42:34,570 --> 00:42:41,140
the call path and the call path is

00:42:36,910 --> 00:42:43,510
allocating this ester the ester gets

00:42:41,140 --> 00:42:45,100
allocated GFP atomic so I don't know

00:42:43,510 --> 00:42:46,840
what code path leads just being called

00:42:45,100 --> 00:42:52,390
in a context where we have to use GFP

00:42:46,840 --> 00:42:54,850
atomic but I I don't care that's just

00:42:52,390 --> 00:42:56,440
this example yeah you know I mean

00:42:54,850 --> 00:42:57,880
somewhat someone needs to go through all

00:42:56,440 --> 00:43:00,790
the crafty orders this is the scuzzy

00:42:57,880 --> 00:43:07,090
core by the way but I mean it could be

00:43:00,790 --> 00:43:10,120
worse it could be GFP DMA I mean you

00:43:07,090 --> 00:43:12,520
know - are you allowed to say TTY given

00:43:10,120 --> 00:43:14,140
the code of conduct III think that's

00:43:12,520 --> 00:43:18,790
going to induce trauma for something

00:43:14,140 --> 00:43:21,270
called anyway that's that's all I have a

00:43:18,790 --> 00:43:24,280
one minute to spare any final questions

00:43:21,270 --> 00:43:25,330
I have a question about the linkage

00:43:24,280 --> 00:43:28,990
combustion

00:43:25,330 --> 00:43:30,940
well link this you don't need to call me

00:43:28,990 --> 00:43:33,370
a locator to look in memory but would

00:43:30,940 --> 00:43:37,080
accelerate you may have to call them a

00:43:33,370 --> 00:43:40,810
locator yes so that 10 inch until some

00:43:37,080 --> 00:43:42,790
unexpected consequence may be yeah

00:43:40,810 --> 00:43:45,250
absolutely it could induce some

00:43:42,790 --> 00:43:49,240
unexpected consequences so one of the

00:43:45,250 --> 00:43:51,160
things I haven't said is that the data

00:43:49,240 --> 00:43:53,170
structure is such that if you only have

00:43:51,160 --> 00:43:55,450
a single entry at

00:43:53,170 --> 00:43:57,579
zero we actually don't allocate anything

00:43:55,450 --> 00:43:58,990
at all and this is the common cake for

00:43:57,579 --> 00:44:01,329
this particular linked list that is the

00:43:58,990 --> 00:44:03,339
common case because your typical scuzzy

00:44:01,329 --> 00:44:03,700
target has a single device attached to

00:44:03,339 --> 00:44:06,579
it

00:44:03,700 --> 00:44:11,140
I mean that's not gonna be the case for

00:44:06,579 --> 00:44:12,849
everyone but yeah this is this this is

00:44:11,140 --> 00:44:20,559
this is a typical linked list with with

00:44:12,849 --> 00:44:23,950
with one or zero elements on it do i

00:44:20,559 --> 00:44:28,630
free or do I never feel free on demand

00:44:23,950 --> 00:44:31,420
as as a node gets to zero as a node gets

00:44:28,630 --> 00:44:34,780
to either zero users or one user the

00:44:31,420 --> 00:44:36,480
choice that is on the in in the left it

00:44:34,780 --> 00:44:40,260
will move up

00:44:36,480 --> 00:44:40,260
yes it's asking you freedom

00:44:45,160 --> 00:44:48,329
oh hush

00:44:59,150 --> 00:45:12,090
no they are the same I if I said that

00:45:11,010 --> 00:45:14,790
then I misspoke

00:45:12,090 --> 00:45:18,180
well the if you're using the XA for each

00:45:14,790 --> 00:45:19,770
iterator whether something was reserved

00:45:18,180 --> 00:45:22,980
with XA reserve or whether it was

00:45:19,770 --> 00:45:27,060
reserved with XA a lock of null it's the

00:45:22,980 --> 00:45:30,060
same thing that's the same it is not

00:45:27,060 --> 00:45:31,650
returned XA for each setting something

00:45:30,060 --> 00:45:36,900
to null is actually the termination

00:45:31,650 --> 00:45:38,250
condition so you never see s Stev in in

00:45:36,900 --> 00:45:41,010
this particular example you would you

00:45:38,250 --> 00:45:49,550
would never see as s dev sets to null

00:45:41,010 --> 00:45:49,550
within that loop oh good Hines

00:45:55,340 --> 00:45:59,540
the question is about our b-trees when

00:45:57,570 --> 00:46:02,340
when can we use it to replace an RB tree

00:45:59,540 --> 00:46:06,030
we have to do we have to finish writing

00:46:02,340 --> 00:46:09,240
the RC UB tree first and then we will

00:46:06,030 --> 00:46:11,070
test it and once once it seems good

00:46:09,240 --> 00:46:12,900
performance for us we will inflict it on

00:46:11,070 --> 00:46:37,470
the wider world and you can start

00:46:12,900 --> 00:46:39,150
replacing it might actually work so the

00:46:37,470 --> 00:46:41,640
question is other circumstances in which

00:46:39,150 --> 00:46:44,490
replacing an RB tree with with with this

00:46:41,640 --> 00:46:46,650
may actually make sense the fundamental

00:46:44,490 --> 00:46:49,890
problem is that the radix tree data

00:46:46,650 --> 00:46:52,500
structure is not good for having ranges

00:46:49,890 --> 00:46:54,420
and and the RB tree data structure is

00:46:52,500 --> 00:47:02,070
good with ranges as we use it for V mas

00:46:54,420 --> 00:47:04,110
we use it for all kinds of things not

00:47:02,070 --> 00:47:08,310
not suppose that it's assuming a zero

00:47:04,110 --> 00:47:10,440
base it is just it is bad at storing it

00:47:08,310 --> 00:47:13,830
is bad at representing the situation in

00:47:10,440 --> 00:47:17,130
which values a to be all map to the same

00:47:13,830 --> 00:47:21,060
pointer which is what you want from an

00:47:17,130 --> 00:47:22,950
RB tree or what

00:47:21,060 --> 00:47:25,140
all right you you're using a single

00:47:22,950 --> 00:47:27,480
value to a single pointer yeah it might

00:47:25,140 --> 00:47:31,470
work how great for you then I would just

00:47:27,480 --> 00:47:33,180
be hesitant to replace anything else but

00:47:31,470 --> 00:47:35,780
it'd be the VMA tree at this point not

00:47:33,180 --> 00:47:40,500
we're looking at the VMA tree as our

00:47:35,780 --> 00:47:42,920
target and it's just not ready yet but

00:47:40,500 --> 00:47:42,920
we do want

00:47:49,370 --> 00:47:55,710
do you mean a b-tree do I worry that a

00:47:53,340 --> 00:47:59,510
b-tree is going to lose some of the good

00:47:55,710 --> 00:47:59,510
cash lying behavior that we have today

00:47:59,750 --> 00:48:07,560
we think we have a good enough there

00:48:06,180 --> 00:48:09,420
were always going to be situations in

00:48:07,560 --> 00:48:13,260
which the radix tree will outperform and

00:48:09,420 --> 00:48:15,630
betray but the radix tree has a lot of

00:48:13,260 --> 00:48:17,340
glass jaws which I fear that we're

00:48:15,630 --> 00:48:20,670
hitting rather more often than we

00:48:17,340 --> 00:48:24,540
actually realized right now I'll give

00:48:20,670 --> 00:48:26,580
you an example if you are accessing if I

00:48:24,540 --> 00:48:33,870
use the whiteboard behind me because I

00:48:26,580 --> 00:48:35,910
can do that so if you are accessing it

00:48:33,870 --> 00:48:40,830
works really works really well if you're

00:48:35,910 --> 00:48:43,950
accessing you know the file from range

00:48:40,830 --> 00:48:47,250
naught to one megabyte that's great

00:48:43,950 --> 00:48:51,270
it all fits in just one but then you

00:48:47,250 --> 00:48:54,240
skip ahead you you decide to read off at

00:48:51,270 --> 00:48:57,650
one terabyte of that file what do we do

00:48:54,240 --> 00:48:57,650
it well we create

00:49:00,820 --> 00:49:09,910
right so that sort of 0 6 12 18 and then

00:49:07,270 --> 00:49:14,340
we come up one of these aside and we

00:49:09,910 --> 00:49:24,670
create another one all the way down and

00:49:14,340 --> 00:49:25,600
oh and then leave 64 so this the this is

00:49:24,670 --> 00:49:28,570
what it looks like when you access a

00:49:25,600 --> 00:49:31,030
zero and n terabytes whatever it's a

00:49:28,570 --> 00:49:38,070
whatever n works out to be please don't

00:49:31,030 --> 00:49:40,900
nitpick me so this sucks right I mean if

00:49:38,070 --> 00:49:43,240
you you've gone from being able to just

00:49:40,900 --> 00:49:46,390
you know to two hops to get to the page

00:49:43,240 --> 00:49:48,790
you want to being one two three four and

00:49:46,390 --> 00:49:50,320
all you've done is access something way

00:49:48,790 --> 00:49:54,040
way way up at the top of the file and

00:49:50,320 --> 00:49:58,990
also you know you've really so stuck a

00:49:54,040 --> 00:50:01,420
not be tree will instead have an

00:49:58,990 --> 00:50:10,690
intermediate node here and another mode

00:50:01,420 --> 00:50:14,290
down here with smart people been we've

00:50:10,690 --> 00:50:17,110
got a solution here so the answer is

00:50:14,290 --> 00:50:18,880
that we have we don't use one format for

00:50:17,110 --> 00:50:20,410
our nodes we've got a very dense node

00:50:18,880 --> 00:50:22,870
format and we've got a sparse node

00:50:20,410 --> 00:50:24,370
format essentially and we've talked

00:50:22,870 --> 00:50:26,800
about maybe adding a third sort of

00:50:24,370 --> 00:50:28,360
intermediate sparse ich den search kind

00:50:26,800 --> 00:50:31,300
of format we're gonna we're gonna do

00:50:28,360 --> 00:50:34,030
with two notes first see what happens we

00:50:31,300 --> 00:50:36,370
can always it's just code and now that

00:50:34,030 --> 00:50:37,870
we've got the x-ray API in and people

00:50:36,370 --> 00:50:40,660
aren't poking around at the until and

00:50:37,870 --> 00:50:41,530
also the radix tree anymore we can

00:50:40,660 --> 00:50:43,720
actually just change the implementation

00:50:41,530 --> 00:50:46,500
and nobody's going to know until things

00:50:43,720 --> 00:50:46,500
get faster for them

00:51:03,970 --> 00:51:08,990
people are over designing already we

00:51:06,650 --> 00:51:13,000
haven't even got code to do lookups yet

00:51:08,990 --> 00:51:15,410
and it's being over designed as we speak

00:51:13,000 --> 00:51:16,819
seriously I do think we actually going

00:51:15,410 --> 00:51:18,440
to end up with two maybe three different

00:51:16,819 --> 00:51:20,180
implementations I can see us having

00:51:18,440 --> 00:51:23,720
separate implementations for 32 and

00:51:20,180 --> 00:51:25,400
64-bit and I can also see us having a

00:51:23,720 --> 00:51:30,640
separate implementation for like config

00:51:25,400 --> 00:51:30,640
tiny or something we'll see we'll see

00:51:31,359 --> 00:51:36,360
yeah exactly yeah thank you so much for

00:51:35,329 --> 00:51:40,570
coming

00:51:36,360 --> 00:51:40,570

YouTube URL: https://www.youtube.com/watch?v=5EFh4v8vwoc


