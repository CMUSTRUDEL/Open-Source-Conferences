Title: LPC2018 - Building Stable Kernel Trees with Machine Learning
Publication date: 2018-12-04
Playlist: LPC2018 - Kernel Summit Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/250/
speaker:  Julia Lawall, Sasha Levin
Captions: 
	00:00:05,930 --> 00:00:13,740
so hi everyone welcome to the building

00:00:09,000 --> 00:00:15,930
stable to the machine learning talk this

00:00:13,740 --> 00:00:18,119
part is suspect I can quickly glass

00:00:15,930 --> 00:00:19,650
about since everyone here should be

00:00:18,119 --> 00:00:22,260
familiar with this water stable trees

00:00:19,650 --> 00:00:24,380
bug fixes device enablement no new

00:00:22,260 --> 00:00:27,240
features pretty straightforward

00:00:24,380 --> 00:00:29,460
how do stuff get in stable there are two

00:00:27,240 --> 00:00:32,579
main ways to get your Pesci to stable

00:00:29,460 --> 00:00:34,559
one is to ADCC stable tag which is

00:00:32,579 --> 00:00:36,989
almost people do it this way greg will

00:00:34,559 --> 00:00:39,630
later look at the patches use the

00:00:36,989 --> 00:00:42,329
scripts look at the patch and pick it up

00:00:39,630 --> 00:00:44,370
another way is to send the mail to the

00:00:42,329 --> 00:00:46,500
stable mailing list asking for the

00:00:44,370 --> 00:00:48,390
inclusion of a patch this is really only

00:00:46,500 --> 00:00:50,220
useful if the stable tag was originally

00:00:48,390 --> 00:00:52,020
missed and it's more like it it's more

00:00:50,220 --> 00:00:53,910
than the exception case in both cases

00:00:52,020 --> 00:00:56,640
we'll get to greg will evaluate the

00:00:53,910 --> 00:01:00,360
patches and merge it into the relevant

00:00:56,640 --> 00:01:04,019
stable trace if is stable material this

00:01:00,360 --> 00:01:08,520
leads us to this slide which is what

00:01:04,019 --> 00:01:10,139
exactly is a fix in the kernel world you

00:01:08,520 --> 00:01:12,389
would say that the fix is the patch it

00:01:10,139 --> 00:01:14,759
fixes a bug in the kernel but in reality

00:01:12,389 --> 00:01:17,009
a fix is a patch that was either tacked

00:01:14,759 --> 00:01:19,679
for stable or later someone asked it to

00:01:17,009 --> 00:01:23,990
be included into stable so really fix is

00:01:19,679 --> 00:01:23,990
a subset of all fixes that go upstream

00:01:24,049 --> 00:01:29,700
we don't want that we want to take every

00:01:26,880 --> 00:01:31,859
single fix into the stable trees we

00:01:29,700 --> 00:01:33,240
don't want to rely on authors of patches

00:01:31,859 --> 00:01:34,709
doing the right thing we don't want to

00:01:33,240 --> 00:01:37,799
rely on committers doing the right thing

00:01:34,709 --> 00:01:40,079
because we see that it often doesn't

00:01:37,799 --> 00:01:42,899
work we see a lot of mixed fixes that

00:01:40,079 --> 00:01:45,389
end up going upstream but not in stable

00:01:42,899 --> 00:01:47,310
trees this is really big thing while the

00:01:45,389 --> 00:01:50,969
recent security issues we've been seen a

00:01:47,310 --> 00:01:53,609
lot of fixes that go in the kernel have

00:01:50,969 --> 00:01:55,859
some security implication so missing

00:01:53,609 --> 00:01:58,139
patches that should have been there may

00:01:55,859 --> 00:02:03,270
cause security issues in the future and

00:01:58,139 --> 00:02:06,689
we wanted to avoid that stable tags are

00:02:03,270 --> 00:02:08,039
also not the best way I don't know if a

00:02:06,689 --> 00:02:11,130
better way but they're not really a good

00:02:08,039 --> 00:02:13,230
way to get patches into stable trees

00:02:11,130 --> 00:02:15,450
they have a few problems the first is

00:02:13,230 --> 00:02:17,340
that some authors don't know whether is

00:02:15,450 --> 00:02:19,350
it they should add a tag or not to begin

00:02:17,340 --> 00:02:21,120
with adding a tag my

00:02:19,350 --> 00:02:23,160
depend on the subsystem you send patches

00:02:21,120 --> 00:02:25,020
to so for example if you send patches to

00:02:23,160 --> 00:02:26,730
David Miller he might ask you not to

00:02:25,020 --> 00:02:28,860
text after stable because it will do it

00:02:26,730 --> 00:02:30,990
himself this leads to cases where people

00:02:28,860 --> 00:02:32,370
try and play it safe and not tag any

00:02:30,990 --> 00:02:34,860
patches for stable at all because they

00:02:32,370 --> 00:02:36,270
don't want to get yelled at this causes

00:02:34,860 --> 00:02:39,690
a lot of people just send fixes without

00:02:36,270 --> 00:02:42,150
stable tags another problem is that when

00:02:39,690 --> 00:02:45,030
author writes a patch that should be a

00:02:42,150 --> 00:02:47,730
stable material it might not be stable

00:02:45,030 --> 00:02:48,960
material at that time so for example if

00:02:47,730 --> 00:02:50,730
you introduce the bug in the merge

00:02:48,960 --> 00:02:53,430
window and you're trying to fix it

00:02:50,730 --> 00:02:54,990
around rc7 it's not stable material

00:02:53,430 --> 00:02:56,820
right it fixes something in that current

00:02:54,990 --> 00:02:58,500
release but what happens if the

00:02:56,820 --> 00:03:00,900
maintainer of the subsystem was on

00:02:58,500 --> 00:03:03,030
vacation taking a break and only saw

00:03:00,900 --> 00:03:04,500
your patch in the next merge window at

00:03:03,030 --> 00:03:06,540
that point it already became stable

00:03:04,500 --> 00:03:08,940
material but the patch itself isn't

00:03:06,540 --> 00:03:15,470
annotated that way it might make it to

00:03:08,940 --> 00:03:19,050
upstream without stable tags it's also

00:03:15,470 --> 00:03:20,970
different people say fix differently so

00:03:19,050 --> 00:03:22,770
some people who might see an issue and

00:03:20,970 --> 00:03:24,150
think oh I just saw it once it's not

00:03:22,770 --> 00:03:26,550
really a big deal maybe I shouldn't take

00:03:24,150 --> 00:03:28,680
it for stable so they end up not having

00:03:26,550 --> 00:03:31,260
a tag but in reality the kernel runs on

00:03:28,680 --> 00:03:33,720
so many machines the different bugs that

00:03:31,260 --> 00:03:37,200
happen once in a lifetime will still

00:03:33,720 --> 00:03:38,850
happen often enough and post to big

00:03:37,200 --> 00:03:41,130
companies cloud provider stuff like that

00:03:38,850 --> 00:03:43,290
people have large infrastructure so they

00:03:41,130 --> 00:03:52,080
will hit bugs that happen very very

00:03:43,290 --> 00:03:54,210
rarely so we might say yeah let's just

00:03:52,080 --> 00:03:56,040
start reviewing all the patches manually

00:03:54,210 --> 00:03:57,360
stable tags suck but to have this great

00:03:56,040 --> 00:03:59,790
guy who can review all the patches

00:03:57,360 --> 00:04:02,490
that's what he's getting paid for start

00:03:59,790 --> 00:04:04,680
to clean the whole kernel this is very

00:04:02,490 --> 00:04:06,150
very difficult I had to do some of this

00:04:04,680 --> 00:04:08,160
when I started working on machine

00:04:06,150 --> 00:04:10,440
learning stuff so I reviewed the whole

00:04:08,160 --> 00:04:12,150
bunch of patches manually to figure out

00:04:10,440 --> 00:04:14,610
if they should go into stable trees or

00:04:12,150 --> 00:04:16,650
not and I found it very difficult and

00:04:14,610 --> 00:04:18,390
very exhausting by the time you read the

00:04:16,650 --> 00:04:21,299
commit log you look at the patch you

00:04:18,390 --> 00:04:22,890
look at the relevant code in a stable

00:04:21,299 --> 00:04:25,500
tree and you have to do it for several

00:04:22,890 --> 00:04:27,900
stable trees you get very exhausted you

00:04:25,500 --> 00:04:29,400
have to become somewhat familiar with

00:04:27,900 --> 00:04:30,840
the subsystem we're trying to patch to

00:04:29,400 --> 00:04:32,100
understand if that patch makes any sense

00:04:30,840 --> 00:04:35,530
there

00:04:32,100 --> 00:04:38,050
trying to do all of this for the 40,000

00:04:35,530 --> 00:04:39,850
commits that go into each release cycle

00:04:38,050 --> 00:04:42,220
assuming it takes minute and a half

00:04:39,850 --> 00:04:44,320
which is really a good case scenario

00:04:42,220 --> 00:04:48,220
means that this is a full-time job this

00:04:44,320 --> 00:04:50,530
is eight hours a week for weeks entire

00:04:48,220 --> 00:04:52,930
month another timer the entire two and a

00:04:50,530 --> 00:04:54,940
half months during the twindom so

00:04:52,930 --> 00:04:56,590
basically we have to dedicate one person

00:04:54,940 --> 00:04:57,970
working on this constantly and the

00:04:56,590 --> 00:05:01,410
person will probably go insane after

00:04:57,970 --> 00:05:01,410
about a week trying to do this thing

00:05:02,070 --> 00:05:07,120
so I figured eh let's automate this was

00:05:05,170 --> 00:05:09,490
sort of my first try and trying to catch

00:05:07,120 --> 00:05:12,280
more of these commits so I started

00:05:09,490 --> 00:05:14,650
looking at stuff like if a patches the

00:05:12,280 --> 00:05:16,750
word fix then maybe it's a button maybe

00:05:14,650 --> 00:05:18,430
it's a box I shouldn't go to stable so I

00:05:16,750 --> 00:05:20,230
started doing it that way but then they

00:05:18,430 --> 00:05:23,470
start encountering a lot of issues

00:05:20,230 --> 00:05:26,230
because I found there's no single big

00:05:23,470 --> 00:05:28,630
identifier that says if a patch is a bug

00:05:26,230 --> 00:05:30,880
fix or not there's no this magical

00:05:28,630 --> 00:05:32,700
formula I can use it'll tell me if I

00:05:30,880 --> 00:05:35,140
should take that fix in this table

00:05:32,700 --> 00:05:37,390
instead of looking at a lot of different

00:05:35,140 --> 00:05:40,210
patches I started recognizing different

00:05:37,390 --> 00:05:42,040
constructs in the patch I started maybe

00:05:40,210 --> 00:05:44,500
several words in the commit message

00:05:42,040 --> 00:05:46,000
might indicate this is a bug fix maybe

00:05:44,500 --> 00:05:51,160
the way a code looks so if the code

00:05:46,000 --> 00:05:53,290
checks were actual examples so stuff

00:05:51,160 --> 00:05:56,080
like words in the commit message that

00:05:53,290 --> 00:05:57,760
might help us code construct so if you

00:05:56,080 --> 00:05:59,710
look at a patch and you see that the two

00:05:57,760 --> 00:06:02,590
lines it added was if some variable

00:05:59,710 --> 00:06:05,730
equals now return it's a good indicator

00:06:02,590 --> 00:06:08,110
stuff like that our stable material

00:06:05,730 --> 00:06:11,169
balance talking is a nice example if you

00:06:08,110 --> 00:06:14,860
see a patch that either introduced as a

00:06:11,169 --> 00:06:16,330
lock or remove or doesn't unblock which

00:06:14,860 --> 00:06:18,070
is unbalanced so if it has only like

00:06:16,330 --> 00:06:20,919
unlock if it also has for example screen

00:06:18,070 --> 00:06:22,510
unlock this patch usually ends up being

00:06:20,919 --> 00:06:24,010
stable material because it means that

00:06:22,510 --> 00:06:28,630
somewhere in the code there is

00:06:24,010 --> 00:06:31,240
unbalanced talk in case some authors

00:06:28,630 --> 00:06:33,610
stand writing more fixes than others

00:06:31,240 --> 00:06:35,710
folks like dan carpenter who does s

00:06:33,610 --> 00:06:38,169
match usually fixes bugs rather than

00:06:35,710 --> 00:06:41,380
choose new features a lot of people

00:06:38,169 --> 00:06:43,660
stuff like the cysts but so if a patches

00:06:41,380 --> 00:06:45,020
AC say since bought a reported by a

00:06:43,660 --> 00:06:46,430
scholar

00:06:45,020 --> 00:06:48,080
like that it's a good indicator that

00:06:46,430 --> 00:06:50,629
it's a real bug that was triggered from

00:06:48,080 --> 00:06:55,039
user space and it's an actual patch you

00:06:50,629 --> 00:06:57,770
wanna pour it back into stable it's also

00:06:55,039 --> 00:07:00,470
the case that some people will reveal a

00:06:57,770 --> 00:07:02,449
fix and not review new features a lot of

00:07:00,470 --> 00:07:03,650
subsystems as this division of which

00:07:02,449 --> 00:07:05,990
maintain who does what

00:07:03,650 --> 00:07:08,270
so some subsystems have folks who will

00:07:05,990 --> 00:07:10,819
do more new feature some folks will

00:07:08,270 --> 00:07:12,440
review all the features that we want to

00:07:10,819 --> 00:07:14,240
look exactly who are the involved

00:07:12,440 --> 00:07:18,380
parties who signed up for review do

00:07:14,240 --> 00:07:21,139
tested stuff like that so I end up with

00:07:18,380 --> 00:07:23,090
this massive array of inputs I have a

00:07:21,139 --> 00:07:25,490
lot of information I gather from each

00:07:23,090 --> 00:07:27,349
commit and I'm not sure how I'm gonna

00:07:25,490 --> 00:07:31,669
take that and represent it in a way that

00:07:27,349 --> 00:07:33,050
will help me identify fixes so Jude I

00:07:31,669 --> 00:07:37,639
suggested hey let's do a neural network

00:07:33,050 --> 00:07:40,690
I had no clue what it means but

00:07:37,639 --> 00:07:43,400
effectively I take all these inputs

00:07:40,690 --> 00:07:45,800
stuff that are most common words people

00:07:43,400 --> 00:07:48,080
use and commit message different code

00:07:45,800 --> 00:07:50,659
metrics the complexity of the code for

00:07:48,080 --> 00:07:52,250
the way that you exit points from the

00:07:50,659 --> 00:07:54,530
code a lot of information about the code

00:07:52,250 --> 00:07:56,240
some information about the authors some

00:07:54,530 --> 00:07:58,370
information about the people involved in

00:07:56,240 --> 00:08:01,340
the process you see it reviewed by etc

00:07:58,370 --> 00:08:04,130
and the files that we touched for the

00:08:01,340 --> 00:08:06,199
files we touched I found that subset

00:08:04,130 --> 00:08:09,050
some subsystems are more in the

00:08:06,199 --> 00:08:11,360
maintenance mode so some subsystem see

00:08:09,050 --> 00:08:13,759
more fixes some subsystems see more new

00:08:11,360 --> 00:08:15,949
features so if you identify which tarsem

00:08:13,759 --> 00:08:19,219
subsystem goes into we have a better

00:08:15,949 --> 00:08:22,729
guess at whether something is a bad fix

00:08:19,219 --> 00:08:25,159
or not so I did this for all the commits

00:08:22,729 --> 00:08:29,479
from 3 Delta for 16 which ended up being

00:08:25,159 --> 00:08:31,520
this humongous set and my true value was

00:08:29,479 --> 00:08:33,560
whether that commit is currently in a

00:08:31,520 --> 00:08:35,719
stable tree or not so that's how I

00:08:33,560 --> 00:08:40,700
thought the neural network about what a

00:08:35,719 --> 00:08:42,770
bug fixes this turned out to be a bit

00:08:40,700 --> 00:08:44,089
too much for my little laptop so I

00:08:42,770 --> 00:08:46,100
loaned the virtual machine that actually

00:08:44,089 --> 00:08:47,810
has a reasonable GPU to do this on and

00:08:46,100 --> 00:08:50,570
it still took a month to generate

00:08:47,810 --> 00:08:54,910
something that I couldn't work with it

00:08:50,570 --> 00:08:54,910
took a lot of we took a pretty junky GPO

00:08:55,640 --> 00:09:00,920
then they finished this in I ran it on a

00:08:57,860 --> 00:09:02,630
set I found out the results aren't

00:09:00,920 --> 00:09:05,290
always correct so sometimes it would

00:09:02,630 --> 00:09:08,060
indicate that they committed a bug fix

00:09:05,290 --> 00:09:10,520
but I looked at it and I figured it's

00:09:08,060 --> 00:09:13,460
not it does not even close and I try to

00:09:10,520 --> 00:09:18,380
figure out what's wrong with my process

00:09:13,460 --> 00:09:21,290
there are few issues here that that make

00:09:18,380 --> 00:09:24,290
it hard to train what a bug fixes or not

00:09:21,290 --> 00:09:26,840
the first is that not all bug fixes or

00:09:24,290 --> 00:09:29,570
stable material going back to my example

00:09:26,840 --> 00:09:31,310
previously if you fix something in rc7

00:09:29,570 --> 00:09:33,500
that was broken in that merged window

00:09:31,310 --> 00:09:35,450
this is a bug fix but it's not stable

00:09:33,500 --> 00:09:37,340
material and it's very hard to explain

00:09:35,450 --> 00:09:39,110
that to the neural network it's very

00:09:37,340 --> 00:09:42,140
hard to say hey this is a bug fix but we

00:09:39,110 --> 00:09:44,270
don't want that so my training set was

00:09:42,140 --> 00:09:46,340
skewed my training set did all the

00:09:44,270 --> 00:09:48,470
patches that are fixes but for what fix

00:09:46,340 --> 00:09:53,540
something in that merge window weren't

00:09:48,470 --> 00:09:56,120
included in a training set another thing

00:09:53,540 --> 00:09:58,640
is that not every fix got into the

00:09:56,120 --> 00:10:01,070
stable tree to begin with due to the

00:09:58,640 --> 00:10:03,200
first three slides I presented here

00:10:01,070 --> 00:10:05,930
not all fixes are Tector stable

00:10:03,200 --> 00:10:07,360
sometimes people miss them so my

00:10:05,930 --> 00:10:09,590
training set was even worse because

00:10:07,360 --> 00:10:11,420
actual patches that should be in stable

00:10:09,590 --> 00:10:14,150
were not in stable in my training set

00:10:11,420 --> 00:10:15,920
and it's also the case that different

00:10:14,150 --> 00:10:17,810
people see bugs differently so some

00:10:15,920 --> 00:10:19,100
things I will see as a bug people say

00:10:17,810 --> 00:10:20,960
hey this is not a bug don't even back

00:10:19,100 --> 00:10:23,570
board it so a lot of it also depends on

00:10:20,960 --> 00:10:26,090
the personal opinions of different

00:10:23,570 --> 00:10:30,050
subsystem maintainers so that also

00:10:26,090 --> 00:10:32,060
skills the training set a bit so I've

00:10:30,050 --> 00:10:37,010
been running this for about the past two

00:10:32,060 --> 00:10:42,440
years even depends on the type recently

00:10:37,010 --> 00:10:46,820
it's been finding even more things it

00:10:42,440 --> 00:10:49,940
found about 12,000 commits for vet for

00:10:46,820 --> 00:10:52,510
the various table trees overall I think

00:10:49,940 --> 00:10:57,020
Julia made pretty nice slides

00:10:52,510 --> 00:10:58,760
recently which shows four different

00:10:57,020 --> 00:11:01,660
committees how many of their commits end

00:10:58,760 --> 00:11:04,940
up going into stable so if you look at

00:11:01,660 --> 00:11:09,270
the past I mean it's weird thinking that

00:11:04,940 --> 00:11:11,670
in 2012 only 20% of patches were

00:11:09,270 --> 00:11:13,380
actually fixes given what we know about

00:11:11,670 --> 00:11:15,960
the statistic of a stable tree so that

00:11:13,380 --> 00:11:18,960
means something is wrong here and if you

00:11:15,960 --> 00:11:22,640
look at recent results 2016 and on we

00:11:18,960 --> 00:11:25,290
can see quite a few commits quite a few

00:11:22,640 --> 00:11:27,180
commanders have a significant percentage

00:11:25,290 --> 00:11:29,850
of patches going into stable trees which

00:11:27,180 --> 00:11:34,380
seem to make more sense I picked an easy

00:11:29,850 --> 00:11:36,090
case the x86 subsystem which is an

00:11:34,380 --> 00:11:39,120
interesting scenario here it's a pretty

00:11:36,090 --> 00:11:41,250
mature subsystem it sees mostly fixes

00:11:39,120 --> 00:11:43,830
but sometimes it sees new features so

00:11:41,250 --> 00:11:47,310
it's a good example here to show how the

00:11:43,830 --> 00:11:50,130
x86 subsystem was affected so the red

00:11:47,310 --> 00:11:52,650
chart is the percentage of commits from

00:11:50,130 --> 00:11:55,260
the subsystem that presents that is

00:11:52,650 --> 00:11:57,960
present in stable trees the green line

00:11:55,260 --> 00:12:00,210
is the percent of commits that are

00:11:57,960 --> 00:12:02,160
signed off by an NGO that is stacked for

00:12:00,210 --> 00:12:04,710
stable and we can sort of see it's been

00:12:02,160 --> 00:12:08,100
same thing Ingo tag Ingo tags only about

00:12:04,710 --> 00:12:11,700
5% of his batches to stable which sounds

00:12:08,100 --> 00:12:14,850
pretty low for 636 and the blue line is

00:12:11,700 --> 00:12:17,670
the percent of committin stable that

00:12:14,850 --> 00:12:19,740
actually have a stable tag so we can say

00:12:17,670 --> 00:12:24,150
that since about we started doing this

00:12:19,740 --> 00:12:25,860
work we put less commits that are

00:12:24,150 --> 00:12:27,720
attacked to stable actually go to stable

00:12:25,860 --> 00:12:30,120
more commits that are not talked not not

00:12:27,720 --> 00:12:32,490
tagged for stable going to stable this

00:12:30,120 --> 00:12:36,150
shows how the machine learning is

00:12:32,490 --> 00:12:38,220
working here we can see that looking at

00:12:36,150 --> 00:12:40,230
the red line we can see this increase in

00:12:38,220 --> 00:12:43,110
commits that end up going in stable for

00:12:40,230 --> 00:12:45,210
that person for Ingo now just to show

00:12:43,110 --> 00:12:47,220
that it's not specific to Inga but also

00:12:45,210 --> 00:12:50,700
but it's specific for the subsystem I

00:12:47,220 --> 00:12:53,010
have Thomas here and you can see very

00:12:50,700 --> 00:12:55,140
similar number Thomas also tags very few

00:12:53,010 --> 00:12:58,200
commits for stable but we can see that

00:12:55,140 --> 00:13:00,990
as time goes on we push more fixes into

00:12:58,200 --> 00:13:03,860
stable trees and more of the stuff that

00:13:00,990 --> 00:13:08,870
goes into stable trees has a stable tag

00:13:03,860 --> 00:13:08,870
now this'll give Judah the stage

00:13:19,230 --> 00:13:23,010
just to conclude on these numbers if

00:13:21,540 --> 00:13:24,330
anyone has questions about these numbers

00:13:23,010 --> 00:13:26,820
I've done them actually for all

00:13:24,330 --> 00:13:28,500
committers and all subsystems and so if

00:13:26,820 --> 00:13:30,870
you want to know what your statistics

00:13:28,500 --> 00:13:34,830
are then we can discuss that afterwards

00:13:30,870 --> 00:13:37,110
oh there are actually people who for

00:13:34,830 --> 00:13:38,670
whom these two lines are extremely close

00:13:37,110 --> 00:13:41,490
to each other and so those are people

00:13:38,670 --> 00:13:44,820
who are really being very careful about

00:13:41,490 --> 00:13:46,350
what they propagate this table they're

00:13:44,820 --> 00:13:48,420
sending everything disabled that should

00:13:46,350 --> 00:13:49,620
be going to scapel and then there are

00:13:48,420 --> 00:13:52,770
other people who are more like this

00:13:49,620 --> 00:13:54,780
we're not very much is being tagged but

00:13:52,770 --> 00:13:57,330
actually now more things are getting

00:13:54,780 --> 00:14:00,960
propagated okay

00:13:57,330 --> 00:14:03,060
so the purpose of my talk is to my part

00:14:00,960 --> 00:14:05,190
of the talk is to kind of explain or

00:14:03,060 --> 00:14:08,130
demystify the process behind what's

00:14:05,190 --> 00:14:09,600
going on I would start out by saying

00:14:08,130 --> 00:14:12,600
that I'm not an expert on machine

00:14:09,600 --> 00:14:15,330
learning so I'm just trying to express

00:14:12,600 --> 00:14:17,130
what I have learned about it recently I

00:14:15,330 --> 00:14:19,110
hope it will clarify things I'm sure if

00:14:17,130 --> 00:14:22,410
you want more detail you can find it in

00:14:19,110 --> 00:14:25,170
other places so first I'm going to step

00:14:22,410 --> 00:14:27,360
back a little bit and say if we're going

00:14:25,170 --> 00:14:29,130
back to this unfortunate human who was

00:14:27,360 --> 00:14:31,890
in the situation that Sasha described

00:14:29,130 --> 00:14:33,450
this person a poor person has to look at

00:14:31,890 --> 00:14:35,010
all of these patches and try to figure

00:14:33,450 --> 00:14:38,190
out which ones of them should go to

00:14:35,010 --> 00:14:42,450
stable so the person might have in mind

00:14:38,190 --> 00:14:45,000
some criteria like says pesasso chasis

00:14:42,450 --> 00:14:47,340
suggested maybe bug or fix and log

00:14:45,000 --> 00:14:49,740
message might be at least a hint that it

00:14:47,340 --> 00:14:52,580
should go to stable it's not necessarily

00:14:49,740 --> 00:14:56,250
a definite going to stable you could say

00:14:52,580 --> 00:14:57,930
fix the line width so that it doesn't go

00:14:56,250 --> 00:14:59,430
over 80 characters that's something you

00:14:57,930 --> 00:15:00,870
would not want to go to stable but at

00:14:59,430 --> 00:15:05,190
least it's a hint in the direction that

00:15:00,870 --> 00:15:06,660
it might be relevant another one is do

00:15:05,190 --> 00:15:08,670
you know the person who wrote the patch

00:15:06,660 --> 00:15:10,560
are they like a serious person do they

00:15:08,670 --> 00:15:13,700
mostly do good work we don't want to be

00:15:10,560 --> 00:15:15,930
sending bugs off to the stable kernels

00:15:13,700 --> 00:15:18,990
Association she suggested things like

00:15:15,930 --> 00:15:20,760
locking issues null tests these are

00:15:18,990 --> 00:15:22,640
often bug fixes so they might more

00:15:20,760 --> 00:15:24,690
likely want to go to the stable kernel

00:15:22,640 --> 00:15:27,330
another thing you might want to look at

00:15:24,690 --> 00:15:29,070
it does it add new functions okay so

00:15:27,330 --> 00:15:30,960
this is kind of a negative criteria if

00:15:29,070 --> 00:15:32,820
it's adding new functions it's probably

00:15:30,960 --> 00:15:33,030
doing new things functions are big and

00:15:32,820 --> 00:15:35,130
calm

00:15:33,030 --> 00:15:38,910
like headed it's probably not something

00:15:35,130 --> 00:15:39,960
that we want to go to stable so some of

00:15:38,910 --> 00:15:41,340
these features you can think of a number

00:15:39,960 --> 00:15:42,900
of futures some of them make them more

00:15:41,340 --> 00:15:45,390
likely for stable some of them make them

00:15:42,900 --> 00:15:49,080
less likely for stable so here we have

00:15:45,390 --> 00:15:50,490
an example here's a patch we can look at

00:15:49,080 --> 00:15:53,970
this patch or we can try to decide

00:15:50,490 --> 00:15:55,860
whether or not it should go to stable so

00:15:53,970 --> 00:16:00,510
we can look here it says has the word

00:15:55,860 --> 00:16:02,250
fix that seems good we can look at the

00:16:00,510 --> 00:16:04,410
name of the person okay so i've

00:16:02,250 --> 00:16:06,060
anonymized this patch but we can see

00:16:04,410 --> 00:16:07,770
that it comes this person has been

00:16:06,060 --> 00:16:10,710
organized enough to get an email address

00:16:07,770 --> 00:16:15,450
at kernel.org so maybe there's kind of a

00:16:10,710 --> 00:16:17,340
well established kernel developer then

00:16:15,450 --> 00:16:19,950
we can look at the code and most of this

00:16:17,340 --> 00:16:22,550
code changes involved with locking so

00:16:19,950 --> 00:16:24,540
maybe that's kind of bug fixed like

00:16:22,550 --> 00:16:26,340
locking doesn't really contribute

00:16:24,540 --> 00:16:27,960
anything to the functionality so you

00:16:26,340 --> 00:16:29,580
only want to do locking if it's

00:16:27,960 --> 00:16:32,700
something that's going to ensure

00:16:29,580 --> 00:16:35,850
correctness in some way and we see it

00:16:32,700 --> 00:16:38,100
doesn't add or remove any functions so

00:16:35,850 --> 00:16:39,720
based on our criteria this seems like a

00:16:38,100 --> 00:16:42,060
pretty good match for a stable kernel

00:16:39,720 --> 00:16:45,840
and this is indeed a patch that has been

00:16:42,060 --> 00:16:47,760
propagated to staple kernels okay so

00:16:45,840 --> 00:16:49,560
that was all kind of intuitive we had

00:16:47,760 --> 00:16:51,300
some ideas we looked at our patch we

00:16:49,560 --> 00:16:53,460
thought about our patch sure we decided

00:16:51,300 --> 00:16:55,110
what to do if we want to automate this

00:16:53,460 --> 00:16:57,150
then we need are going to need to

00:16:55,110 --> 00:16:58,710
construct some kind of formula and get

00:16:57,150 --> 00:17:00,060
some kind of numbers and then we'll have

00:16:58,710 --> 00:17:01,290
some kind of thresholds and we'll say

00:17:00,060 --> 00:17:03,510
things that are above the threshold

00:17:01,290 --> 00:17:05,430
according to this formula are going to

00:17:03,510 --> 00:17:08,190
go off to stable and the other ones are

00:17:05,430 --> 00:17:09,600
not so if we want to have some formula

00:17:08,190 --> 00:17:11,640
then we're going to have its work and

00:17:09,600 --> 00:17:13,470
have our features though features we

00:17:11,640 --> 00:17:15,690
identified and then we'll give them a

00:17:13,470 --> 00:17:18,030
bunch of variables and these variables

00:17:15,690 --> 00:17:20,400
are going to be the degree to which a

00:17:18,030 --> 00:17:23,970
given patch is going to satisfy that

00:17:20,400 --> 00:17:25,740
particular feature so for bug and fix

00:17:23,970 --> 00:17:27,750
it's kind of a yes or no question so it

00:17:25,740 --> 00:17:30,120
might just be either value 1 or value 0

00:17:27,750 --> 00:17:31,530
a well-known developer some people are

00:17:30,120 --> 00:17:32,910
more well-known some people are less

00:17:31,530 --> 00:17:36,390
well-known you might give it a point

00:17:32,910 --> 00:17:37,800
five point seven and so on and then we

00:17:36,390 --> 00:17:40,470
also have these features so these

00:17:37,800 --> 00:17:42,450
features are not all created equal

00:17:40,470 --> 00:17:44,730
perhaps being a well-known developer

00:17:42,450 --> 00:17:45,300
it's kind of useful but it's not that

00:17:44,730 --> 00:17:46,110
useful

00:17:45,300 --> 00:17:49,110
where

00:17:46,110 --> 00:17:51,780
as having locking that's a pretty strong

00:17:49,110 --> 00:17:53,370
indicator that it's a public bug-fix so

00:17:51,780 --> 00:17:55,320
we can give that a higher weight we can

00:17:53,370 --> 00:17:57,600
give this low a lower weight here I've

00:17:55,320 --> 00:17:59,429
put a minus one to indicate that it's a

00:17:57,600 --> 00:18:02,610
sort of counter indicator for being

00:17:59,429 --> 00:18:04,620
stable and so we have our variables

00:18:02,610 --> 00:18:07,140
which are describing our particular

00:18:04,620 --> 00:18:08,760
patch and we have our weights which are

00:18:07,140 --> 00:18:10,290
describing the value of each of these

00:18:08,760 --> 00:18:13,220
features with respect to making our

00:18:10,290 --> 00:18:16,890
decision and then we can make a formula

00:18:13,220 --> 00:18:20,820
so I'm just multiplying the weights by

00:18:16,890 --> 00:18:22,260
the variables adding everything up we

00:18:20,820 --> 00:18:24,750
can plug in some values for our

00:18:22,260 --> 00:18:26,460
particular patch it definitely contains

00:18:24,750 --> 00:18:30,090
the word bug-fix it's a pretty

00:18:26,460 --> 00:18:31,890
well-known developer it said does have

00:18:30,090 --> 00:18:33,929
locking it does not have any new

00:18:31,890 --> 00:18:36,240
functions and then we get a score so our

00:18:33,929 --> 00:18:37,500
patch is going to give us 0.96 and we

00:18:36,240 --> 00:18:39,840
say can say oh that's a pretty big

00:18:37,500 --> 00:18:42,770
number so we can send our patch off to

00:18:39,840 --> 00:18:45,600
stable kernels or more accurately we can

00:18:42,770 --> 00:18:47,070
send our patch off to humans who are

00:18:45,600 --> 00:18:52,860
going to check whether this should

00:18:47,070 --> 00:18:54,510
really go to a stable kernel or not okay

00:18:52,860 --> 00:18:56,190
but that's I mean it's kind of the idea

00:18:54,510 --> 00:18:57,780
but in practice it's not very

00:18:56,190 --> 00:19:01,799
satisfactory because we don't really

00:18:57,780 --> 00:19:05,370
know if bug or fix should be have value

00:19:01,799 --> 00:19:07,950
0.3 or if it's have zero value 0.28 or

00:19:05,370 --> 00:19:12,480
should have value 0.1 or what value it

00:19:07,950 --> 00:19:15,960
should actually have another issue is

00:19:12,480 --> 00:19:18,780
our well-known developer idea well-known

00:19:15,960 --> 00:19:20,309
developers maybe they're reliable but

00:19:18,780 --> 00:19:22,140
they also do many different things they

00:19:20,309 --> 00:19:24,240
might fix bugs they might add new

00:19:22,140 --> 00:19:26,309
features and so just having a well-known

00:19:24,240 --> 00:19:27,750
being a well-known developer by itself

00:19:26,309 --> 00:19:29,640
doesn't really tell us anything at all

00:19:27,750 --> 00:19:31,470
on the other hand if we have an

00:19:29,640 --> 00:19:33,630
well-known developer and if that person

00:19:31,470 --> 00:19:35,280
is has a fix in their commit message

00:19:33,630 --> 00:19:38,130
then maybe we would have more confidence

00:19:35,280 --> 00:19:39,690
that this is actually doing a bug fix

00:19:38,130 --> 00:19:42,840
that we would like to propagate to a

00:19:39,690 --> 00:19:45,150
stable kernel so what we need to do is

00:19:42,840 --> 00:19:46,679
we need to be able to optimize our

00:19:45,150 --> 00:19:48,540
weight assignments so we come out with

00:19:46,679 --> 00:19:51,299
exact perfect ones that are going to

00:19:48,540 --> 00:19:53,940
really indicate to us whether the patch

00:19:51,299 --> 00:19:56,370
is stable relevant or not and it's also

00:19:53,940 --> 00:19:58,110
desirable to be able to combine this

00:19:56,370 --> 00:20:00,440
information in different ways and not

00:19:58,110 --> 00:20:02,760
just the simple formula that I

00:20:00,440 --> 00:20:04,409
so for that we can use a neural network

00:20:02,760 --> 00:20:06,510
so this is the kind of neural network

00:20:04,409 --> 00:20:08,700
that Sasha has used the feed-forward

00:20:06,510 --> 00:20:12,049
neural network so the basic idea is just

00:20:08,700 --> 00:20:15,179
a random example stolen from Wikipedia

00:20:12,049 --> 00:20:17,639
the basic idea of a neural network is

00:20:15,179 --> 00:20:19,710
just a way of representing a formula the

00:20:17,639 --> 00:20:22,889
formula has some inputs we see the

00:20:19,710 --> 00:20:25,139
inputs at the top and then it has some

00:20:22,889 --> 00:20:27,120
outputs in our case we have actually

00:20:25,139 --> 00:20:28,980
only one output or one output is going

00:20:27,120 --> 00:20:31,950
to be that number is 0.96 which

00:20:28,980 --> 00:20:33,480
indicates to what degree of confidence

00:20:31,950 --> 00:20:36,090
we have that this patch should go to

00:20:33,480 --> 00:20:38,130
stable and what we have in between are a

00:20:36,090 --> 00:20:40,470
bunch of connections and basically

00:20:38,130 --> 00:20:42,840
information comes into the connection

00:20:40,470 --> 00:20:45,149
the information gets weighted and some

00:20:42,840 --> 00:20:47,909
result gets sent out and so it just gets

00:20:45,149 --> 00:20:49,649
propagated through the neural network

00:20:47,909 --> 00:20:51,389
just like my inputs were getting

00:20:49,649 --> 00:20:56,070
propagated through the formula that I

00:20:51,389 --> 00:20:59,880
wrote previously so that in itself is

00:20:56,070 --> 00:21:02,279
not very interesting the question then

00:20:59,880 --> 00:21:03,899
is where do these weights come from and

00:21:02,279 --> 00:21:05,639
that's the thing that we want to learn

00:21:03,899 --> 00:21:06,899
that's the whole machine learning idea

00:21:05,639 --> 00:21:09,000
it's going to learn what the weights

00:21:06,899 --> 00:21:11,309
should be and then once we figured out

00:21:09,000 --> 00:21:13,649
how much being a stay of well-known

00:21:11,309 --> 00:21:14,820
maintainer is really worth then we're

00:21:13,649 --> 00:21:18,899
going to be able to make an accurate

00:21:14,820 --> 00:21:20,940
prediction based on that information so

00:21:18,899 --> 00:21:24,960
the basic idea is you have some training

00:21:20,940 --> 00:21:27,330
data for your training data you have

00:21:24,960 --> 00:21:28,830
some the idea of training data is we

00:21:27,330 --> 00:21:31,409
have a whole bunch of inputs and for

00:21:28,830 --> 00:21:33,539
each input we have an expected result so

00:21:31,409 --> 00:21:34,919
we know for some patch we know for

00:21:33,539 --> 00:21:37,200
example whether it has already been

00:21:34,919 --> 00:21:40,289
propagated to stable or whether it has

00:21:37,200 --> 00:21:43,230
not been propagated to stable and then

00:21:40,289 --> 00:21:46,409
we drop our inputs into our neural

00:21:43,230 --> 00:21:48,389
network and it produces some outputs and

00:21:46,409 --> 00:21:52,080
then we see if our outputs are similar

00:21:48,389 --> 00:21:55,500
to our inputs so in this case we can see

00:21:52,080 --> 00:21:57,600
that our outputs are not the outputs are

00:21:55,500 --> 00:22:00,120
in for the sorry not the outputs the

00:21:57,600 --> 00:22:01,860
output she be similar to the expected

00:22:00,120 --> 00:22:04,080
results so we have our expected results

00:22:01,860 --> 00:22:07,710
here we can see that in this case there

00:22:04,080 --> 00:22:09,929
are actually not very good so the

00:22:07,710 --> 00:22:12,059
problem is going to be in this the

00:22:09,929 --> 00:22:14,640
construction here it seems we have

00:22:12,059 --> 00:22:17,730
inappropriate weights

00:22:14,640 --> 00:22:21,000
and so we need to adjust things in order

00:22:17,730 --> 00:22:24,059
to improve that so it's not good so the

00:22:21,000 --> 00:22:26,790
idea is now we are thinking of our

00:22:24,059 --> 00:22:28,799
weights as variables okay so it's a

00:22:26,790 --> 00:22:30,990
small shift of point of view because if

00:22:28,799 --> 00:22:32,549
you look back before I had the variables

00:22:30,990 --> 00:22:33,690
being the matching of the patches and

00:22:32,549 --> 00:22:35,490
the features and I had the weights as

00:22:33,690 --> 00:22:36,900
being constants now we think of the

00:22:35,490 --> 00:22:39,000
weights as variables those are the

00:22:36,900 --> 00:22:41,940
things we might change we see what we've

00:22:39,000 --> 00:22:44,549
got what results we get for a particular

00:22:41,940 --> 00:22:47,160
set of weights and that that is a

00:22:44,549 --> 00:22:48,960
function it's a function from the space

00:22:47,160 --> 00:22:51,900
of weights all the different weights in

00:22:48,960 --> 00:22:55,260
it into an error value so here we have a

00:22:51,900 --> 00:22:56,760
very high error if we move around a

00:22:55,260 --> 00:22:58,799
little bit in this function space then

00:22:56,760 --> 00:23:00,720
we might move to a lower error or we

00:22:58,799 --> 00:23:02,669
might move to a higher error obviously

00:23:00,720 --> 00:23:05,160
moving to a lower the error seems like a

00:23:02,669 --> 00:23:07,049
better thing so it's kind of a hill

00:23:05,160 --> 00:23:08,880
climbing sort of problem which is the

00:23:07,049 --> 00:23:11,220
local optimization where at some place

00:23:08,880 --> 00:23:14,540
we decide would we like to go down the

00:23:11,220 --> 00:23:17,280
hill or would we like to go up there and

00:23:14,540 --> 00:23:19,590
so if we decide we like to go down the

00:23:17,280 --> 00:23:21,570
hill then going a little bit down the

00:23:19,590 --> 00:23:23,520
hill will move us to some other inputs

00:23:21,570 --> 00:23:25,200
and then we can try again with our

00:23:23,520 --> 00:23:27,690
training set and we just iterate this

00:23:25,200 --> 00:23:31,020
over and over again until you get to an

00:23:27,690 --> 00:23:35,630
error value which is in general more

00:23:31,020 --> 00:23:38,940
acceptable so we can try this again on

00:23:35,630 --> 00:23:41,250
some other set of weights here chosen in

00:23:38,940 --> 00:23:43,200
kind of a reasonable way because we want

00:23:41,250 --> 00:23:45,870
our machine learning process to converge

00:23:43,200 --> 00:23:48,660
in a reasonable amount of time and this

00:23:45,870 --> 00:23:50,460
time maybe we have some results which

00:23:48,660 --> 00:23:53,309
are kind of closer to the things we

00:23:50,460 --> 00:23:55,380
expected and so eventually we'll decide

00:23:53,309 --> 00:23:59,580
everything's good enough we're going to

00:23:55,380 --> 00:24:01,559
use this model in order to actual run

00:23:59,580 --> 00:24:02,880
day to day on the patches that come in

00:24:01,559 --> 00:24:08,460
and decide whether they should go to

00:24:02,880 --> 00:24:10,559
stable kernels or not okay so that's

00:24:08,460 --> 00:24:14,250
that's the basic idea that's being used

00:24:10,559 --> 00:24:15,809
so far so the question is how can we

00:24:14,250 --> 00:24:18,380
improve on this so this is some work

00:24:15,809 --> 00:24:21,230
that I've been doing with a student in

00:24:18,380 --> 00:24:24,480
Singapore Management University

00:24:21,230 --> 00:24:26,040
basically the work that has gone on so

00:24:24,480 --> 00:24:27,510
far as to try to land the weights but

00:24:26,040 --> 00:24:29,330
maybe there's some other things that

00:24:27,510 --> 00:24:32,610
should be learning in particular

00:24:29,330 --> 00:24:34,800
basically we had features and we should

00:24:32,610 --> 00:24:36,450
give some weights to those features but

00:24:34,800 --> 00:24:39,660
then we can ask are those really the

00:24:36,450 --> 00:24:41,610
right features so is being a well-known

00:24:39,660 --> 00:24:44,070
developer really something we should be

00:24:41,610 --> 00:24:45,720
focusing on or should is this something

00:24:44,070 --> 00:24:47,970
we should just not pay any attention to

00:24:45,720 --> 00:24:51,660
it all or there's some other things that

00:24:47,970 --> 00:24:54,780
we should be focusing on instead and

00:24:51,660 --> 00:24:58,470
then another issue entirely is reasoning

00:24:54,780 --> 00:25:00,750
about code a lot of applications of

00:24:58,470 --> 00:25:04,110
machine learning are things like images

00:25:00,750 --> 00:25:10,920
or text a code is somehow something

00:25:04,110 --> 00:25:13,650
different so we had Sassa suggested some

00:25:10,920 --> 00:25:16,020
features like modifies locking I

00:25:13,650 --> 00:25:18,180
suggested adding new functions or not

00:25:16,020 --> 00:25:20,640
these are very coarse-grained sort of

00:25:18,180 --> 00:25:22,650
conceptual things but maybe there's some

00:25:20,640 --> 00:25:24,330
other more fine-grained features about

00:25:22,650 --> 00:25:28,050
the the code that we should be taking

00:25:24,330 --> 00:25:30,060
into account the problem is the more

00:25:28,050 --> 00:25:32,310
features that you add the higher the

00:25:30,060 --> 00:25:34,080
cost of your learning process remember

00:25:32,310 --> 00:25:36,210
we keep iterating and trying to get to

00:25:34,080 --> 00:25:38,820
the best values and so we have to

00:25:36,210 --> 00:25:42,270
somehow focus on the best features so

00:25:38,820 --> 00:25:43,710
what I'm going to talk about is an

00:25:42,270 --> 00:25:45,840
approach that allows you to somehow

00:25:43,710 --> 00:25:51,990
learn what the features are that you

00:25:45,840 --> 00:25:53,370
should focus on so the idea is to use

00:25:51,990 --> 00:25:55,080
what's called a convolutional neural

00:25:53,370 --> 00:25:58,730
network so this is something that has

00:25:55,080 --> 00:25:58,730
been used a lot in image processing

00:25:58,820 --> 00:26:04,430
now it's also used natural language

00:26:01,080 --> 00:26:06,960
processing and so the idea here is

00:26:04,430 --> 00:26:09,120
instead of taking high level features

00:26:06,960 --> 00:26:14,550
that have been identified based on

00:26:09,120 --> 00:26:16,140
intuition did somehow lower the level of

00:26:14,550 --> 00:26:19,350
features that can be taken into account

00:26:16,140 --> 00:26:20,850
but then isolate the ones that are

00:26:19,350 --> 00:26:22,080
somehow the most important the ones

00:26:20,850 --> 00:26:25,940
actually ones that actually make a

00:26:22,080 --> 00:26:25,940
contribution to the result

00:26:27,970 --> 00:26:31,840
so I'll give an example first in the

00:26:30,129 --> 00:26:33,549
image processing area so here's our

00:26:31,840 --> 00:26:36,429
image it's just a bunch of pixels of

00:26:33,549 --> 00:26:38,080
zeros and ones and so the idea is we

00:26:36,429 --> 00:26:39,820
make some little filters in the filters

00:26:38,080 --> 00:26:43,710
where the filters are going to do is

00:26:39,820 --> 00:26:46,659
find small patterns of image within our

00:26:43,710 --> 00:26:48,580
big image space so the idea is we're

00:26:46,659 --> 00:26:52,110
trying to identify an ostrich for

00:26:48,580 --> 00:26:55,779
example and someone has figured out that

00:26:52,110 --> 00:26:57,700
having a figure like a little space like

00:26:55,779 --> 00:26:59,740
this somewhere in the figure is a high

00:26:57,700 --> 00:27:01,870
indicator of being an ostrich maybe if

00:26:59,740 --> 00:27:03,759
you have this and you have this and you

00:27:01,870 --> 00:27:05,080
have this and I don't know what they

00:27:03,759 --> 00:27:06,909
have for the head like this

00:27:05,080 --> 00:27:09,039
maybe that's if you have all of those

00:27:06,909 --> 00:27:10,419
things then it's probably in Austria you

00:27:09,039 --> 00:27:12,129
don't have to actually look at all the

00:27:10,419 --> 00:27:13,629
pixels and all the feathers and

00:27:12,129 --> 00:27:18,070
everything like that just those things

00:27:13,629 --> 00:27:19,419
put together indicate ostrich nests so

00:27:18,070 --> 00:27:21,580
basically you have this filter this

00:27:19,419 --> 00:27:24,129
filter represents part the part of the

00:27:21,580 --> 00:27:26,320
ostrich that we're interested in we take

00:27:24,129 --> 00:27:29,200
our filter we move it over our data and

00:27:26,320 --> 00:27:31,330
at some point it we find a pretty good

00:27:29,200 --> 00:27:34,600
match and we say okay there's a pretty

00:27:31,330 --> 00:27:36,399
good chance of it being an ostrich okay

00:27:34,600 --> 00:27:38,889
so this is kind of just the same idea we

00:27:36,399 --> 00:27:41,679
had before before we said does it have

00:27:38,889 --> 00:27:43,570
some locking and so now we say does it

00:27:41,679 --> 00:27:45,519
have this filter here but the idea the

00:27:43,570 --> 00:27:47,559
the change of perspective is that when

00:27:45,519 --> 00:27:50,350
you say deficit have some locking that

00:27:47,559 --> 00:27:52,960
some worth something that's expressed in

00:27:50,350 --> 00:27:55,360
natural English text we can't do very

00:27:52,960 --> 00:27:57,789
much with it what's interesting about

00:27:55,360 --> 00:28:00,429
this is we have numbers and then we can

00:27:57,789 --> 00:28:03,580
apply our learning process to finding it

00:28:00,429 --> 00:28:05,379
figuring out these numbers so actually

00:28:03,580 --> 00:28:08,230
within learning process we don't have

00:28:05,379 --> 00:28:11,679
the preconceived notion that this is

00:28:08,230 --> 00:28:13,149
important over time we can start out

00:28:11,679 --> 00:28:15,159
with a filter that looks like this but

00:28:13,149 --> 00:28:16,990
then we can we can learn the elements of

00:28:15,159 --> 00:28:18,700
our filter and realize that it's not

00:28:16,990 --> 00:28:21,370
this that's important but it's actually

00:28:18,700 --> 00:28:25,149
finding this which is important to being

00:28:21,370 --> 00:28:27,340
an ostrich so the idea is we can observe

00:28:25,149 --> 00:28:29,019
in our case our image contains eight

00:28:27,340 --> 00:28:31,029
ninths of the filter that we were

00:28:29,019 --> 00:28:35,730
looking for it contains it somewhere

00:28:31,029 --> 00:28:39,100
this is something called max pooling and

00:28:35,730 --> 00:28:40,929
again we take our data we drop it in we

00:28:39,100 --> 00:28:41,470
figure out what our filters are and then

00:28:40,929 --> 00:28:43,720
we do

00:28:41,470 --> 00:28:45,400
a standard the feed-forward neural

00:28:43,720 --> 00:28:47,140
network kind of thing and then we get

00:28:45,400 --> 00:28:49,210
out some result and it's a good result

00:28:47,140 --> 00:28:50,950
it's a bad result if we don't like the

00:28:49,210 --> 00:28:52,750
result we can adjust our weights but now

00:28:50,950 --> 00:28:54,580
we can also adjust our filters and we

00:28:52,750 --> 00:28:58,750
can also we can now search for different

00:28:54,580 --> 00:29:00,760
elements in the image okay then the

00:28:58,750 --> 00:29:04,360
question is actually we're not working

00:29:00,760 --> 00:29:06,039
on images we're working on we're working

00:29:04,360 --> 00:29:10,510
on commit messages which are texts and

00:29:06,039 --> 00:29:13,510
we're working on DIF with our code so we

00:29:10,510 --> 00:29:15,220
it's useful to think about it how we can

00:29:13,510 --> 00:29:17,650
apply this to text because we have

00:29:15,220 --> 00:29:21,100
exactly text in the log message and code

00:29:17,650 --> 00:29:23,640
is at least a sort of textual format for

00:29:21,100 --> 00:29:25,390
text you might think of text as a

00:29:23,640 --> 00:29:27,789
one-dimensional thing and not as a

00:29:25,390 --> 00:29:29,740
matrix because it's a sequence of words

00:29:27,789 --> 00:29:32,530
just coming one after the other but each

00:29:29,740 --> 00:29:34,990
of these words has some meaning and so

00:29:32,530 --> 00:29:37,150
actually a text is a sequence of these

00:29:34,990 --> 00:29:38,890
meanings okay so I've represented the

00:29:37,150 --> 00:29:40,450
meanings as just the letters which are

00:29:38,890 --> 00:29:43,000
contained in the word which is of course

00:29:40,450 --> 00:29:45,880
kind of silly but it's kind of easy to

00:29:43,000 --> 00:29:47,710
represent on the screen and so now we

00:29:45,880 --> 00:29:49,780
actually do have a matrix so the

00:29:47,710 --> 00:29:51,880
vertical dimension is the meaning of the

00:29:49,780 --> 00:29:54,880
word the horizontal dimension is the

00:29:51,880 --> 00:29:57,520
number of words so now our filter is

00:29:54,880 --> 00:29:59,470
going to basically it's taking a window

00:29:57,520 --> 00:30:01,780
on the set of words and we want to see

00:29:59,470 --> 00:30:04,990
do we find a certain pattern of words in

00:30:01,780 --> 00:30:06,850
the message or do we actually do we find

00:30:04,990 --> 00:30:13,120
a certain pattern of meanings in the

00:30:06,850 --> 00:30:15,070
message so as I mentioned in our

00:30:13,120 --> 00:30:17,010
particular case we have the log message

00:30:15,070 --> 00:30:20,020
and we have the commitment code changes

00:30:17,010 --> 00:30:21,850
log message is purely natural language

00:30:20,020 --> 00:30:24,460
and so we can just use existing

00:30:21,850 --> 00:30:27,429
techniques from natural language the

00:30:24,460 --> 00:30:30,520
code on the other hand is going to pose

00:30:27,429 --> 00:30:33,070
some problems here if you think about if

00:30:30,520 --> 00:30:34,539
we just take the natural language idea

00:30:33,070 --> 00:30:36,520
and apply it directly to the code

00:30:34,539 --> 00:30:38,740
perhaps it's not going to work out very

00:30:36,520 --> 00:30:40,659
well because we'll maybe start out with

00:30:38,740 --> 00:30:43,419
well here we have a - we know that it's

00:30:40,659 --> 00:30:44,890
going to be some code that's removed but

00:30:43,419 --> 00:30:48,460
basically the idea is our filters are

00:30:44,890 --> 00:30:50,950
quite small and as we move the filter

00:30:48,460 --> 00:30:54,280
across the code here we're going to

00:30:50,950 --> 00:30:55,299
forget the - 'no sand then we'll run

00:30:54,280 --> 00:30:57,249
into a plus now

00:30:55,299 --> 00:31:00,100
he's added and they'll move our filter

00:30:57,249 --> 00:31:01,659
along and we forget the addition okay so

00:31:00,100 --> 00:31:03,429
then you could think we could we could

00:31:01,659 --> 00:31:06,100
put little minuses on all the different

00:31:03,429 --> 00:31:08,139
tokens so that would solve that problem

00:31:06,100 --> 00:31:13,539
but still it doesn't have the right

00:31:08,139 --> 00:31:15,279
perspective on the code somehow so then

00:31:13,539 --> 00:31:18,489
we can think about how actually should

00:31:15,279 --> 00:31:21,039
we represent code changes what's the

00:31:18,489 --> 00:31:22,840
important information what what things

00:31:21,039 --> 00:31:25,600
do we want to somehow put together with

00:31:22,840 --> 00:31:28,749
each other so you can think of the very

00:31:25,600 --> 00:31:31,269
minimal representation our change could

00:31:28,749 --> 00:31:34,090
be just replacing a equal sign by a less

00:31:31,269 --> 00:31:35,799
than okay so that's actually quite an

00:31:34,090 --> 00:31:38,109
important piece of information most the

00:31:35,799 --> 00:31:39,369
time when you want to replace the equals

00:31:38,109 --> 00:31:41,379
if that's the only thing you're doing

00:31:39,369 --> 00:31:42,789
that probably actually is a bug fix so

00:31:41,379 --> 00:31:46,210
maybe in this case that would be a good

00:31:42,789 --> 00:31:48,220
choice but we can have equals equals

00:31:46,210 --> 00:31:49,480
less than or equal to that's the entire

00:31:48,220 --> 00:31:51,820
token that gives a little more

00:31:49,480 --> 00:31:54,070
information the exact operator is

00:31:51,820 --> 00:31:57,100
changing we can do what I would call I

00:31:54,070 --> 00:32:00,340
call an atomic statement now we have a

00:31:57,100 --> 00:32:03,239
little bit more context if header a for

00:32:00,340 --> 00:32:06,179
header an assignment statement and so on

00:32:03,239 --> 00:32:08,919
it's sort of a nice compromise between

00:32:06,179 --> 00:32:10,899
just equals to less than which has

00:32:08,919 --> 00:32:13,419
somehow no context it could be used for

00:32:10,899 --> 00:32:15,159
many different things and actually this

00:32:13,419 --> 00:32:17,889
function is being replaced by this other

00:32:15,159 --> 00:32:22,389
function where we tend to get lost with

00:32:17,889 --> 00:32:24,340
the filters or we could take just go for

00:32:22,389 --> 00:32:27,220
a complete statements in one entire if

00:32:24,340 --> 00:32:29,139
another entire if so these are just a

00:32:27,220 --> 00:32:34,269
bunch of different options that we could

00:32:29,139 --> 00:32:37,119
take this is the one that I decided to

00:32:34,269 --> 00:32:41,950
use I think and if header is sort of a

00:32:37,119 --> 00:32:44,350
conceptual unit of meaning and so that

00:32:41,950 --> 00:32:46,239
kind of gives some context for what

00:32:44,350 --> 00:32:50,739
changes button perhaps not too much

00:32:46,239 --> 00:32:54,249
context once we've decided what is the

00:32:50,739 --> 00:32:56,169
code that we want to represent then we

00:32:54,249 --> 00:32:58,059
have can ask how much of that code we

00:32:56,169 --> 00:32:59,259
actually want to put into the machine

00:32:58,059 --> 00:33:01,629
learning representation if you're

00:32:59,259 --> 00:33:04,659
familiar with what's done in the natural

00:33:01,629 --> 00:33:08,049
language processing world often they do

00:33:04,659 --> 00:33:10,360
what's called dropping stop words which

00:33:08,049 --> 00:33:15,169
means like

00:33:10,360 --> 00:33:17,509
this is a test maybe a and is there not

00:33:15,169 --> 00:33:19,159
very even this it's not very important

00:33:17,509 --> 00:33:20,690
some words are not very important to

00:33:19,159 --> 00:33:23,419
give the meaning of a sentence some

00:33:20,690 --> 00:33:26,360
words are very important so we can think

00:33:23,419 --> 00:33:28,309
if it's probably very important once we

00:33:26,360 --> 00:33:30,019
have the if the less left parenthesis is

00:33:28,309 --> 00:33:34,250
not very important because it's always

00:33:30,019 --> 00:33:36,679
there after an if maybe this name is

00:33:34,250 --> 00:33:38,419
very important but maybe it's somehow

00:33:36,679 --> 00:33:39,740
too important into the sense that it

00:33:38,419 --> 00:33:41,480
might be the only occurrence of this

00:33:39,740 --> 00:33:42,620
name in the entire kernel and so we're

00:33:41,480 --> 00:33:45,500
not going to really be able to learn

00:33:42,620 --> 00:33:47,720
anything from it we could just record

00:33:45,500 --> 00:33:49,279
that it's an identifier and so on so we

00:33:47,720 --> 00:33:51,470
can look at the different words in the

00:33:49,279 --> 00:33:54,320
mess in the code as at different levels

00:33:51,470 --> 00:33:56,149
of abstraction and decide how we want to

00:33:54,320 --> 00:33:59,000
represent this in the learning process

00:33:56,149 --> 00:34:01,519
in a way that it can actually learn

00:33:59,000 --> 00:34:04,070
something that is see something and

00:34:01,519 --> 00:34:09,950
generalize that in to some kind of walls

00:34:04,070 --> 00:34:12,050
that it can use in other situations also

00:34:09,950 --> 00:34:13,940
in general a bigger vocabulary is going

00:34:12,050 --> 00:34:16,250
to increase the training time so we want

00:34:13,940 --> 00:34:20,000
to keep the information that's important

00:34:16,250 --> 00:34:22,030
but not too much information so actually

00:34:20,000 --> 00:34:25,730
I you keep quite a lot of information

00:34:22,030 --> 00:34:27,740
one thing that we there's no functions

00:34:25,730 --> 00:34:30,560
here one thing we found very important

00:34:27,740 --> 00:34:32,690
to keep track of was function names but

00:34:30,560 --> 00:34:36,710
other variable names we mostly just sort

00:34:32,690 --> 00:34:38,119
of throw away and then once we've

00:34:36,710 --> 00:34:39,679
figured out how to represent our data

00:34:38,119 --> 00:34:41,839
then we need to figure out how to

00:34:39,679 --> 00:34:43,159
somehow put it all together to represent

00:34:41,839 --> 00:34:44,810
the structure of the code there's many

00:34:43,159 --> 00:34:46,909
aspects of the structure of the code

00:34:44,810 --> 00:34:50,030
there's the removed lines the added

00:34:46,909 --> 00:34:52,250
lines then they're collected together

00:34:50,030 --> 00:34:53,869
into hunks and then for a different a

00:34:52,250 --> 00:34:57,380
given patch there might be it might be

00:34:53,869 --> 00:34:58,849
touching different files and so we use a

00:34:57,380 --> 00:35:01,780
bunch of different neural networks to

00:34:58,849 --> 00:35:06,050
keep track of these different levels so

00:35:01,780 --> 00:35:07,760
our results so we took our approach and

00:35:06,050 --> 00:35:09,560
we compared it to Sasha's approach so

00:35:07,760 --> 00:35:10,970
basically we have taken Sasha's approach

00:35:09,560 --> 00:35:14,050
and sort of extended it with a

00:35:10,970 --> 00:35:16,339
refinement in order to learn new

00:35:14,050 --> 00:35:18,410
features learn the set of features and

00:35:16,339 --> 00:35:20,000
not just the set of weights so the

00:35:18,410 --> 00:35:22,739
question is do we get a better result

00:35:20,000 --> 00:35:25,079
from doing more work

00:35:22,739 --> 00:35:29,430
we have a data set that we collected

00:35:25,079 --> 00:35:32,609
it's is 80,000 commits from about over

00:35:29,430 --> 00:35:35,160
about six years we we wanted to have a

00:35:32,609 --> 00:35:37,739
balanced data set so we have about

00:35:35,160 --> 00:35:41,039
40,000 stable commits and then we took

00:35:37,739 --> 00:35:43,799
about 40,000 commits that have not been

00:35:41,039 --> 00:35:46,380
designated for stable these commits are

00:35:43,799 --> 00:35:47,759
of similar size to the stable ones so

00:35:46,380 --> 00:35:49,529
the machine learning is not just going

00:35:47,759 --> 00:35:51,059
to learn that really big commits should

00:35:49,529 --> 00:35:54,359
never go to stable and really small

00:35:51,059 --> 00:35:56,039
commits should always go to stable we

00:35:54,359 --> 00:35:59,029
evaluate them in two ways we have

00:35:56,039 --> 00:36:01,859
precision in recall precision is the

00:35:59,029 --> 00:36:04,140
percentage of patches that the tool

00:36:01,859 --> 00:36:07,019
classifies as stable that are actually

00:36:04,140 --> 00:36:08,460
stable when we say you should do

00:36:07,019 --> 00:36:12,630
something are we telling you to do the

00:36:08,460 --> 00:36:14,609
right thing we call is the patches that

00:36:12,630 --> 00:36:16,410
should be that are actually being

00:36:14,609 --> 00:36:19,499
identified should be stable that are

00:36:16,410 --> 00:36:22,559
actually being identified as stable so

00:36:19,499 --> 00:36:24,450
and we compare this to we compare three

00:36:22,559 --> 00:36:27,809
approaches one of them is just finding

00:36:24,450 --> 00:36:29,579
bug and fix you can see these spars are

00:36:27,809 --> 00:36:32,880
quite low so that didn't work out

00:36:29,579 --> 00:36:34,859
terribly well people use especially the

00:36:32,880 --> 00:36:37,019
word fix for other things but lots of

00:36:34,859 --> 00:36:38,729
people express themselves in a different

00:36:37,019 --> 00:36:40,259
way and so they have a bug fix but they

00:36:38,729 --> 00:36:43,109
don't use either the word book or the

00:36:40,259 --> 00:36:44,670
word fix a result I think is quite

00:36:43,109 --> 00:36:49,200
interesting is that we both have the

00:36:44,670 --> 00:36:50,969
same precision a precision of a hundred

00:36:49,200 --> 00:36:52,739
percent would be a bad result because it

00:36:50,969 --> 00:36:54,210
would mean that we're not contributed

00:36:52,739 --> 00:36:56,519
that we have no potential to contribute

00:36:54,210 --> 00:36:58,769
anything other than what people have

00:36:56,519 --> 00:37:02,579
done already because our data set our

00:36:58,769 --> 00:37:05,390
training set is only from what was done

00:37:02,579 --> 00:37:08,819
already so at least there's at least

00:37:05,390 --> 00:37:10,559
potential in here for things that our

00:37:08,819 --> 00:37:12,349
tool is saying should be stable and

00:37:10,559 --> 00:37:15,329
actually should be stable but weren't

00:37:12,349 --> 00:37:18,059
marked in that way and our approach

00:37:15,329 --> 00:37:20,249
gives a greater recall than the Sascha's

00:37:18,059 --> 00:37:22,349
approach but there's still some

00:37:20,249 --> 00:37:24,059
potential for improvement here and still

00:37:22,349 --> 00:37:26,390
we're still thinking about what more we

00:37:24,059 --> 00:37:26,390
can do

00:37:27,229 --> 00:37:31,859
future work there's other problems in

00:37:30,059 --> 00:37:34,920
kernel development that maybe we could

00:37:31,859 --> 00:37:38,220
think about applying machine learning to

00:37:34,920 --> 00:37:39,839
first we could is there more information

00:37:38,220 --> 00:37:42,390
is there different ways we could

00:37:39,839 --> 00:37:43,980
represent the code could we use a

00:37:42,390 --> 00:37:46,020
different kind of neural network to

00:37:43,980 --> 00:37:48,809
remember more information or manage the

00:37:46,020 --> 00:37:50,700
information in a different way can we

00:37:48,809 --> 00:37:53,640
understand what the neural network has

00:37:50,700 --> 00:37:56,160
learned and try to either improve our

00:37:53,640 --> 00:37:57,569
understanding or improve the machine

00:37:56,160 --> 00:38:00,780
learning approach based on that

00:37:57,569 --> 00:38:03,390
information can we use machine learning

00:38:00,780 --> 00:38:06,270
to choose Tegel target stable versions

00:38:03,390 --> 00:38:09,480
or can we actually the best thing would

00:38:06,270 --> 00:38:11,339
be just to identify the bug introducing

00:38:09,480 --> 00:38:13,680
patches and then we don't have to bother

00:38:11,339 --> 00:38:26,329
with these stable versions anymore in

00:38:13,680 --> 00:38:26,329
the future questions

00:38:36,860 --> 00:38:42,840
so he was what one input a one hidden

00:38:40,770 --> 00:38:47,420
layer the same amount of neurons as the

00:38:42,840 --> 00:38:47,420
input and one urine on the output

00:38:53,910 --> 00:39:01,570
yeah yes the question is one of the

00:38:59,770 --> 00:39:05,170
things that occurred to me where you are

00:39:01,570 --> 00:39:07,600
presenting is that usually most of the

00:39:05,170 --> 00:39:11,200
bug fixes are patches that applied

00:39:07,600 --> 00:39:13,840
against the previous version did you try

00:39:11,200 --> 00:39:18,130
to use that as a feedback to the narrow

00:39:13,840 --> 00:39:23,800
network or considered somehow I haven't

00:39:18,130 --> 00:39:26,980
looked into that yeah I mean it's not a

00:39:23,800 --> 00:39:30,850
rule but it is a strong indication if I

00:39:26,980 --> 00:39:35,350
have one bug on this version and someone

00:39:30,850 --> 00:39:40,440
writes a fix it will likely be applied

00:39:35,350 --> 00:39:40,440
at least at the version plus a means one

00:39:50,260 --> 00:39:59,390
so I don't have a question but just some

00:39:54,560 --> 00:40:02,390
thoughts about the non developer as

00:39:59,390 --> 00:40:04,730
maintainer one of the common complaints

00:40:02,390 --> 00:40:07,700
is that oh you're applying double

00:40:04,730 --> 00:40:11,300
standards you it's easier for the old

00:40:07,700 --> 00:40:12,920
guys Club to get backs Murshid than the

00:40:11,300 --> 00:40:16,040
newcomers because you have biased

00:40:12,920 --> 00:40:19,250
opinions so I would just be careful

00:40:16,040 --> 00:40:21,980
though on how you implement this and

00:40:19,250 --> 00:40:23,960
maybe a suggestion is not used the non

00:40:21,980 --> 00:40:27,470
developers because non developers I'll

00:40:23,960 --> 00:40:29,930
swing through those bugs but may be used

00:40:27,470 --> 00:40:31,670
if because the fixes tag points to a

00:40:29,930 --> 00:40:34,099
patch that introduced at the bug and

00:40:31,670 --> 00:40:39,890
maybe count by the authors that

00:40:34,099 --> 00:40:41,570
introduced it bugs and somehow so the

00:40:39,890 --> 00:40:43,400
way I wanted to use this is not your

00:40:41,570 --> 00:40:46,640
sort of classify people as good or bad

00:40:43,400 --> 00:40:48,560
yeah but more to classify people who are

00:40:46,640 --> 00:40:51,080
more likely to submit the fix so if

00:40:48,560 --> 00:40:53,420
someone has for every ten fixes nine of

00:40:51,080 --> 00:40:55,310
them go to stable tree in the past then

00:40:53,420 --> 00:40:57,349
these eleventh patch is more likely to

00:40:55,310 --> 00:40:59,450
be a stable fix in someone who does the

00:40:57,349 --> 00:41:01,190
opposite so it's more of just figuring

00:40:59,450 --> 00:41:02,869
out who does more stable work and does

00:41:01,190 --> 00:41:05,060
last type of work and classifies people

00:41:02,869 --> 00:41:07,970
by that not by how good their coding

00:41:05,060 --> 00:41:09,890
skills are yes so I mean well-known

00:41:07,970 --> 00:41:11,300
developer was one of my criteria but I

00:41:09,890 --> 00:41:13,790
didn't mean to suggest that that was

00:41:11,300 --> 00:41:16,300
being used in that way I know you know I

00:41:13,790 --> 00:41:20,500
just wanted to give some kind of

00:41:16,300 --> 00:41:20,500
features that one could think about

00:41:49,670 --> 00:41:57,770
so the goal is to or the most immediate

00:41:53,750 --> 00:42:00,950
goal is to get more patches into staple

00:41:57,770 --> 00:42:02,180
kernels that should be there so I we

00:42:00,950 --> 00:42:04,760
looked in the beginning addict in the

00:42:02,180 --> 00:42:08,030
beginning and the propagation to stable

00:42:04,760 --> 00:42:09,820
kernels it's like this some people are

00:42:08,030 --> 00:42:15,790
very low and some people are very high

00:42:09,820 --> 00:42:18,589
and so it seems perhaps unlikely that I

00:42:15,790 --> 00:42:21,859
mean obviously it's not the case that

00:42:18,589 --> 00:42:24,589
across the entire kernel 20% of all

00:42:21,859 --> 00:42:27,200
patches should go to staple as sasha

00:42:24,589 --> 00:42:29,930
pointed out some some subsystems are

00:42:27,200 --> 00:42:33,410
more in development some are more in

00:42:29,930 --> 00:42:36,950
consolidation but still it seemed

00:42:33,410 --> 00:42:40,030
something this disparity suggested it

00:42:36,950 --> 00:42:40,030
would be something to look into

00:43:46,749 --> 00:43:51,619
so happens once and booth in your home

00:43:49,969 --> 00:43:53,660
group you're different than happening

00:43:51,619 --> 00:43:55,459
thousands in a massive data center I

00:43:53,660 --> 00:43:57,160
think we don't have a good way to judge

00:43:55,459 --> 00:44:12,739
how many people use a particular

00:43:57,160 --> 00:44:15,009
function depends on how fine you wanna

00:44:12,739 --> 00:44:15,009
go

00:44:28,900 --> 00:44:35,480
so the stable charge says that if you

00:44:31,339 --> 00:44:39,170
fix a bug it goes into stable trim he

00:44:35,480 --> 00:44:41,329
doesn't say how severe the bug is just

00:44:39,170 --> 00:44:50,380
says a bug that was discovered should be

00:44:41,329 --> 00:44:56,420
in stable or an actual this table chair

00:44:50,380 --> 00:44:59,619
man okay I have a couple of questions so

00:44:56,420 --> 00:45:03,259
could you go one slide back please

00:44:59,619 --> 00:45:08,089
yeah okay say do I understand correctly

00:45:03,259 --> 00:45:11,150
that you took a take a comment from that

00:45:08,089 --> 00:45:21,650
wrench and you used it as a training set

00:45:11,150 --> 00:45:25,099
or testing said oh yeah okay okay

00:45:21,650 --> 00:45:30,049
did you try because I saw that such a

00:45:25,099 --> 00:45:34,369
sound cover this big tight sets with

00:45:30,049 --> 00:45:37,240
outer cell did you get mmm feedback from

00:45:34,369 --> 00:45:40,339
maintainer say okay so the question is

00:45:37,240 --> 00:45:42,500
do you know was the real false positive

00:45:40,339 --> 00:45:45,200
on current kernels did you get a

00:45:42,500 --> 00:45:47,240
feedback from maintainer saying okay

00:45:45,200 --> 00:45:49,940
this comment is false positive because

00:45:47,240 --> 00:45:52,190
it doesn't it does not belong to two

00:45:49,940 --> 00:46:00,289
stable three because nothing so I don't

00:45:52,190 --> 00:46:02,480
know did you know for our results so

00:46:00,289 --> 00:46:04,819
it's really hard to get me tenors to

00:46:02,480 --> 00:46:06,349
look at this that's why spam everyone

00:46:04,819 --> 00:46:07,730
and maybe it's a good thing damn it's a

00:46:06,349 --> 00:46:09,829
bad thing but I don't think that the

00:46:07,730 --> 00:46:11,779
results I have our valid in any context

00:46:09,829 --> 00:46:13,309
I can measure how many patches I

00:46:11,779 --> 00:46:15,470
proposed but then got dropped later

00:46:13,309 --> 00:46:16,400
because of my tender comments but I

00:46:15,470 --> 00:46:18,260
don't think

00:46:16,400 --> 00:46:22,520
even the interaction level ahead with

00:46:18,260 --> 00:46:25,520
maintainers it's relevant if thanks and

00:46:22,520 --> 00:46:28,579
just last question this may be more

00:46:25,520 --> 00:46:31,640
practical to the future because the

00:46:28,579 --> 00:46:34,609
system is evolving all the time because

00:46:31,640 --> 00:46:39,289
maintain us are taught to be better in

00:46:34,609 --> 00:46:41,839
tagging patches for for stable say it

00:46:39,289 --> 00:46:44,180
will be in the future it would be nice

00:46:41,839 --> 00:46:45,920
to retrain all the time so to do

00:46:44,180 --> 00:46:48,230
something like online retraining but

00:46:45,920 --> 00:46:51,140
it's not that straightforward in this

00:46:48,230 --> 00:46:53,510
case because you don't want you don't

00:46:51,140 --> 00:46:55,940
have the real to value it's the true

00:46:53,510 --> 00:46:57,529
value is what what goes to stable tree

00:46:55,940 --> 00:46:59,480
and there are false positives and false

00:46:57,529 --> 00:47:03,500
negatives so it's not that

00:46:59,480 --> 00:47:06,529
straightforward say if you would refrain

00:47:03,500 --> 00:47:09,559
with what you what you get you you would

00:47:06,529 --> 00:47:11,150
get a bias with false positives say do

00:47:09,559 --> 00:47:17,839
you know how to how to deal with that

00:47:11,150 --> 00:47:21,520
there's no good story they do retrain or

00:47:17,839 --> 00:47:21,520
not okay thanks

00:47:38,830 --> 00:47:46,390
if you actually wanted to go to another

00:47:41,450 --> 00:47:49,400
session now would be a good time yeah so

00:47:46,390 --> 00:47:51,850
I'll be here from Julia you guys have

00:47:49,400 --> 00:47:51,850
any questions

00:47:53,590 --> 00:47:56,999

YouTube URL: https://www.youtube.com/watch?v=KWholDv6-Rw


