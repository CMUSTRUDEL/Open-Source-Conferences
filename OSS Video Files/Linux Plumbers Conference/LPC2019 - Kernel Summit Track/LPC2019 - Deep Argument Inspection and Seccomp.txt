Title: LPC2019 - Deep Argument Inspection and Seccomp
Publication date: 2019-11-18
Playlist: LPC2019 - Kernel Summit Track
Description: 
	Deep Argument Inspection and Seccomp

Speaker
 Christian Brauner
Captions: 
	00:00:00,130 --> 00:00:04,073
- [Instructor] So this is about, whoa, that got louder.

00:00:05,590 --> 00:00:09,203
A question about Deep Argument Inspection for Syscalls.

00:00:10,210 --> 00:00:15,210
That Christian had talked about and I had talked about.

00:00:15,423 --> 00:00:19,223
The first obvious thing is why do we want this at all?

00:00:20,810 --> 00:00:24,670
And the problem right now is doing Syscall filtering,

00:00:24,670 --> 00:00:27,500
you can only look at the numeric arguments

00:00:27,500 --> 00:00:28,333
that are coming in.

00:00:28,333 --> 00:00:29,700
So, you can see the pointer number,

00:00:29,700 --> 00:00:31,700
but if you attempt to de-reference that,

00:00:33,629 --> 00:00:34,900
you end up with a raised condition

00:00:34,900 --> 00:00:37,500
because some other thread might be able to change it

00:00:39,079 --> 00:00:39,912
out from under you before actually get into the Syscall.

00:00:39,912 --> 00:00:42,303
And I'll show you the details on what that looks like.

00:00:44,003 --> 00:00:46,353
But the reason to actually do that filtering is

00:00:47,387 --> 00:00:51,507
programs right now step their Syscall isolation, filtering,

00:00:51,507 --> 00:00:55,470
or whatever, they like to be able to do more than this

00:00:55,470 --> 00:00:57,470
and get to file system isolation

00:00:57,470 --> 00:00:59,990
to say I wanna be able open only these files,

00:00:59,990 --> 00:01:02,500
or not these special files or anything,

00:01:02,500 --> 00:01:04,170
but there's no way to do that.

00:01:05,217 --> 00:01:07,710
And probably the more pressing matter

00:01:07,710 --> 00:01:10,860
that Christian talked about is the newer syscall APIs

00:01:10,860 --> 00:01:13,240
and you can talk about that.

00:01:13,240 --> 00:01:15,670
- [Christian] Clone(3) And OpenAir 2, for example.

00:01:15,670 --> 00:01:19,840
So, basically, APIs that gain a lot

00:01:19,840 --> 00:01:22,928
of new features over time and, usually,

00:01:22,928 --> 00:01:25,080
they indicate new features with flagging on commands

00:01:25,080 --> 00:01:27,020
and traditionally, we have had some registered

00:01:27,020 --> 00:01:28,470
but, for example, with Clone,

00:01:29,572 --> 00:01:31,162
we have already run out of flags

00:01:31,162 --> 00:01:32,936
and so, at some point, it was like,

00:01:32,936 --> 00:01:35,554
why don't we make it a part of the start, for example,

00:01:35,554 --> 00:01:37,800
and have it a 64-bit flag argument

00:01:37,800 --> 00:01:40,880
and have it (audio cuts out) and so on.

00:01:40,880 --> 00:01:42,987
But the problem is Clone3, for example,

00:01:42,987 --> 00:01:44,500
for (audio cuts out) will gain a lot of new features,

00:01:44,500 --> 00:01:46,010
also security features that might

00:01:46,010 --> 00:01:48,460
be relevant for Chrome and so on.

00:01:48,460 --> 00:01:50,530
And so, you want to use them in those environments,

00:01:50,530 --> 00:01:53,367
but you also to filter out all of the things

00:01:54,904 --> 00:01:55,737
that you want the process not to do

00:01:55,737 --> 00:01:57,133
and you can't do this right now with Clone3,

00:01:58,206 --> 00:02:00,956
which means it's out of scope for, for example, Chrome.

00:02:01,891 --> 00:02:02,900
This was actually an example that Yun provided

00:02:03,790 --> 00:02:06,692
by (audio cuts out).

00:02:06,692 --> 00:02:08,502
- [Host] If you can't look into the structure

00:02:08,502 --> 00:02:10,850
that the pointer is pointing to, you can't filter it.

00:02:10,850 --> 00:02:13,910
And then there's also the case of passive monitoring,

00:02:13,910 --> 00:02:16,400
like, hey, let's just get a notification from seccomp

00:02:16,400 --> 00:02:19,290
that it's gonna do this open and just report it,

00:02:19,290 --> 00:02:22,100
but you have to go dig into the memory yourself,

00:02:22,100 --> 00:02:24,670
as the monitor, and you could get lied to

00:02:24,670 --> 00:02:26,413
because it might change out from under you

00:02:26,413 --> 00:02:28,850
and certainly for, sort of, active monitoring

00:02:30,225 --> 00:02:31,270
where you're gonna intercept it

00:02:32,883 --> 00:02:34,933
and then do something about it, you know,

00:02:36,557 --> 00:02:38,429
the cases for this, also you have to, like,

00:02:38,429 --> 00:02:41,930
right now, what's happening with containers

00:02:41,930 --> 00:02:44,660
is they'll get a notification, read the memory

00:02:44,660 --> 00:02:46,726
and say, oh I do want to intercept this one

00:02:46,726 --> 00:02:47,640
and do it on behalf of the process

00:02:47,640 --> 00:02:50,953
but then they have to also handle all the other ones

00:02:52,221 --> 00:02:54,109
that are barrelling through right now

00:02:54,109 --> 00:02:55,820
because there's no way to look in to see,

00:02:55,820 --> 00:02:59,270
do I want to handle this specific one.

00:02:59,270 --> 00:03:01,725
(audio cuts out)

00:03:01,725 --> 00:03:05,140
So, as a quick background on the iChart I made here,

00:03:05,140 --> 00:03:06,513
this is the Syscall flow.

00:03:09,039 --> 00:03:11,483
So, you enter the kernel as the first step,

00:03:12,627 --> 00:03:16,218
and then there's a bunch of trick entry hooks

00:03:16,218 --> 00:03:18,120
and those will block back up the users space

00:03:18,120 --> 00:03:21,970
and this, the result of coming back from these events,

00:03:21,970 --> 00:03:25,100
is the A-P bugger or whatever else is doing the

00:03:26,153 --> 00:03:28,161
(audio cuts out)

00:03:28,161 --> 00:03:30,278
might have changed anything.

00:03:30,278 --> 00:03:31,111
(audio cuts out)

00:03:31,111 --> 00:03:32,613
registers to the Syscall number itself,

00:03:34,362 --> 00:03:36,702
or it might request to skip the Syscall

00:03:36,702 --> 00:03:38,819
and do anything along those lines.

00:03:38,819 --> 00:03:41,075
After that, then the (audio cuts out).

00:03:41,075 --> 00:03:42,357
There's a whole bunch of different outcomes for Seccomp

00:03:43,702 --> 00:03:48,511
it might just kill the (audio cuts out)

00:03:48,511 --> 00:03:51,024
process (audio cuts out) log it, continue.

00:03:51,024 --> 00:03:52,799
It may send a signal back to user space

00:03:52,799 --> 00:03:53,863
and wait for that response.

00:03:55,280 --> 00:03:57,280
Similar to the user space notification

00:03:58,333 --> 00:04:01,306
on the file descriptor which is like (mumbles) only

00:04:01,306 --> 00:04:02,456
a little bit less slow.

00:04:03,300 --> 00:04:04,433
Those are blocking,

00:04:05,657 --> 00:04:07,823
and Seccomp also issues p-trace events.

00:04:09,657 --> 00:04:11,460
If that event happens and you come back

00:04:11,460 --> 00:04:13,638
any of those things may have changed again

00:04:13,638 --> 00:04:15,160
and you're actually have to restart the

00:04:15,160 --> 00:04:17,309
Syscall hook processing because you may have

00:04:17,309 --> 00:04:19,642
entered a different Syscall.

00:04:20,602 --> 00:04:22,703
This is a bit of a hack and

00:04:22,703 --> 00:04:24,088
you have to stop further recursion,

00:04:24,088 --> 00:04:25,273
otherwise you're just set up in a loop forever.

00:04:26,710 --> 00:04:29,863
Then you get into the actual Syscall, if allowed.

00:04:31,090 --> 00:04:34,160
In the Syscall, you're gonna copy user space memory N

00:04:34,160 --> 00:04:34,993
for (mumbles).

00:04:36,619 --> 00:04:37,480
You're gonna examine

00:04:38,820 --> 00:04:40,689
what you got out of user space,

00:04:40,689 --> 00:04:42,533
(audio cuts out)

00:04:42,533 --> 00:04:44,563
objects or whatever and (audio cuts out)

00:04:44,563 --> 00:04:49,563
which are looking specifically at kernel objects,

00:04:50,040 --> 00:04:53,090
and then actually do whatever work you were gonna do.

00:04:53,090 --> 00:04:55,360
Note here the L-S-M hooks right now

00:04:55,360 --> 00:04:58,480
are simply (audio cuts out)

00:05:00,923 --> 00:05:03,718
fine everything is cool, keep going,

00:05:03,718 --> 00:05:06,041
or they can issue an error (audio cuts out).

00:05:06,041 --> 00:05:08,260
Then you get the (mumbles) exit event,

00:05:08,260 --> 00:05:09,380
which is hey this is calls over.

00:05:09,380 --> 00:05:11,665
You can't really do anything about it,

00:05:11,665 --> 00:05:13,247
but here's the notification,

00:05:13,247 --> 00:05:14,213
then hit return to user space.

00:05:17,842 --> 00:05:19,631
So there's already this ugly loop in the middle

00:05:19,631 --> 00:05:21,933
between Seccomp and (mumbles).

00:05:21,933 --> 00:05:24,310
I call that out because we're gonna come back to that.

00:05:24,310 --> 00:05:26,680
The first observation is p-trace in the wrong place,

00:05:26,680 --> 00:05:30,447
to do deterministic analysis of the Syscall

00:05:32,378 --> 00:05:35,734
because the back-up, where p-trace events happen

00:05:35,734 --> 00:05:40,734
is well before that memory (audio cuts out)

00:05:41,367 --> 00:05:42,200
to user space.

00:05:44,593 --> 00:05:45,426
Who knows, your p-trace is gonna

00:05:47,430 --> 00:05:48,290
basically be lying to you if there is a thread competing

00:05:50,181 --> 00:05:51,014
against it, either as an attack or on accident.

00:05:55,447 --> 00:05:57,120
Similarly Seccomp is in the wrong place for this,

00:05:57,120 --> 00:05:58,273
because of the exact same problems.

00:06:01,920 --> 00:06:04,370
To get the L-S-M, L-S-M is not Syscall filtering,

00:06:06,145 --> 00:06:07,220
it's from a higher level of extraction than the

00:06:09,687 --> 00:06:10,783
L-S-M hooks tend to be.

00:06:10,783 --> 00:06:12,772
I want to work on file objects,

00:06:12,772 --> 00:06:15,780
not on open (audio cuts out)

00:06:15,780 --> 00:06:17,730
other things that work on file objects,

00:06:18,672 --> 00:06:21,000
it's a much higher granularity.

00:06:21,000 --> 00:06:24,384
However, we did recently grow an exception for this,

00:06:24,384 --> 00:06:25,650
(audio cuts out)

00:06:25,650 --> 00:06:28,454
which now contains the context from which

00:06:28,454 --> 00:06:31,070
it's hook got called.

00:06:31,070 --> 00:06:35,070
Was this from set U-I-D, from set D-I-D?

00:06:35,070 --> 00:06:35,903
Whatever.

00:06:37,030 --> 00:06:38,660
There's an argument that's been used that the L-S-M hooks

00:06:38,660 --> 00:06:41,870
are the right place for doing deep inspection,

00:06:41,870 --> 00:06:44,150
because now you're actually working on the (mumbles)

00:06:44,150 --> 00:06:46,333
objects you were hearing about.

00:06:46,333 --> 00:06:48,423
You're done, there's no races, nothing is happening.

00:06:50,515 --> 00:06:52,415
There's presently no (audio cuts out).

00:06:54,300 --> 00:06:58,146
There's no way to load policy, or filter, or whatever

00:06:58,146 --> 00:07:00,150
from user space as a program.

00:07:00,150 --> 00:07:02,830
Chrome is starting up, it says oh I wanna do

00:07:04,632 --> 00:07:05,720
these file name filters.

00:07:05,720 --> 00:07:07,470
There's no way to do an L-S-M,

00:07:07,470 --> 00:07:10,043
there's no way for any of that to work.

00:07:12,203 --> 00:07:15,390
Should deep inspection happen

00:07:15,390 --> 00:07:16,453
via Seccomp at all.

00:07:18,150 --> 00:07:22,673
Maybe it should be through the L-S-M, I don't know.

00:07:23,736 --> 00:07:26,563
The problem with doing it from Syscalls,

00:07:27,989 --> 00:07:31,280
is if you really do what a limit access to a file,

00:07:31,280 --> 00:07:32,113
or an I-P address,

00:07:32,113 --> 00:07:36,780
or some aspect that is arguably a state in the kernel

00:07:38,690 --> 00:07:40,616
you might miss

00:07:40,616 --> 00:07:42,323
a face for that to expose.

00:07:43,410 --> 00:07:45,560
Let's say our own (mumbles) filtering open,

00:07:46,987 --> 00:07:49,400
but (audio cuts out),

00:07:49,400 --> 00:07:52,770
but if you filtered from working on an object,

00:07:52,770 --> 00:07:56,300
on the L-S-M hook, it's not gonna get missed

00:07:57,157 --> 00:07:57,990
from Syscall.

00:08:01,340 --> 00:08:03,950
An earlier thing I tried to do

00:08:03,950 --> 00:08:07,558
was to create an association between the seccomp

00:08:07,558 --> 00:08:08,883
and the L-S-M layer.

00:08:12,471 --> 00:08:14,721
When you go through the seccomp hook it says,

00:08:16,454 --> 00:08:19,340
oh I actually want to deep inspection on this.

00:08:19,340 --> 00:08:23,457
Then later, once you've actually entered the Syscall,

00:08:23,457 --> 00:08:25,849
you're in the L-S-M and you say, "Oh now I'll do the

00:08:25,849 --> 00:08:29,547
seccomp, L-S-M policy and analyze these objects."

00:08:30,851 --> 00:08:32,810
The question is, then what?

00:08:32,810 --> 00:08:34,650
Because right now there is no

00:08:34,650 --> 00:08:39,350
L-S-M return value for giving back to seccomp,

00:08:39,350 --> 00:08:41,270
so we'd have to invent that,

00:08:41,270 --> 00:08:46,060
then add a seccomp exit path.

00:08:46,060 --> 00:08:48,783
If you, for example, change the

00:08:48,783 --> 00:08:52,070
Syscall that you wanted you have to

00:08:52,070 --> 00:08:55,153
start back over at the top.

00:08:57,349 --> 00:08:58,749
It was looking really scary,

00:08:59,684 --> 00:09:00,973
I don't know.

00:09:02,440 --> 00:09:04,610
Mainly it just seems overly complex,

00:09:04,610 --> 00:09:08,213
and a strong indication that there is a lot of layering

00:09:08,213 --> 00:09:10,963
(audio cuts out) and I didn't like it.

00:09:12,210 --> 00:09:14,494
That was one thought.

00:09:14,494 --> 00:09:16,333
The other thought was, well let's just (audio cuts out).

00:09:17,580 --> 00:09:19,877
Well we sort of can't based on how the A-B-I works.

00:09:19,877 --> 00:09:22,760
At the L-S-M layer it's too late to do a bunch the things

00:09:22,760 --> 00:09:24,300
the same reason we talked about.

00:09:24,300 --> 00:09:25,160
Where would we move it to?

00:09:25,160 --> 00:09:27,400
We'd move it to each Syscall.

00:09:27,400 --> 00:09:30,230
It'd basically be moved into where all the L-S-M hooks

00:09:30,230 --> 00:09:32,930
would be, but you'd have to remember to do it for each one.

00:09:32,930 --> 00:09:36,340
You want to do it on the Syscall basis,

00:09:36,340 --> 00:09:39,473
so no seccomp probably shouldn't be moved.

00:09:39,473 --> 00:09:42,270
The problem was initially,

00:09:42,270 --> 00:09:46,547
well can't we just cash a copy of the userspace memory,

00:09:46,547 --> 00:09:50,030
that way we don't end up with a race condition?

00:09:50,030 --> 00:09:51,870
Where if the seccomp filter is gonna filter it,

00:09:51,870 --> 00:09:54,980
we'll copy it early in the entry path.

00:09:54,980 --> 00:09:56,770
Then if seccomp says, "Yay, good!"

00:09:56,770 --> 00:09:59,760
It'll continue on in the Syscall,

00:09:59,760 --> 00:10:01,263
it'll use the cashed version.

00:10:02,517 --> 00:10:04,860
Except, you can't do that because

00:10:04,860 --> 00:10:07,650
what you're talking about may have changed,

00:10:07,650 --> 00:10:10,960
in the case of file names, and other stuff.

00:10:10,960 --> 00:10:13,942
It may resolve in the kernel through something else

00:10:13,942 --> 00:10:17,330
at one time before you actually get into the Syscall

00:10:17,330 --> 00:10:19,320
it may have changed what it's attached to.

00:10:19,320 --> 00:10:22,430
You're making a filtering decision about the wrong thing.

00:10:22,430 --> 00:10:24,370
So, still there is a raised condition.

00:10:24,370 --> 00:10:26,453
So what about moving argument parsing?

00:10:29,820 --> 00:10:32,711
If we define the argument types more completely,

00:10:32,711 --> 00:10:35,860
we might be able to copy it out and do

00:10:35,860 --> 00:10:38,120
parsing into an object.

00:10:38,120 --> 00:10:41,760
This is sometimes easy, then it's just destruct,

00:10:41,760 --> 00:10:44,340
like a lot of the Syscalls

00:10:44,340 --> 00:10:46,133
that were mentioned in the beginning.

00:10:47,810 --> 00:10:50,900
Some things are significantly complex,

00:10:50,900 --> 00:10:52,830
like doing file name resolution,

00:10:52,830 --> 00:10:55,327
is really ugly.

00:10:55,327 --> 00:10:59,240
Then there are some Syscalls that will walk lists of

00:10:59,240 --> 00:11:01,783
structures that are defined in userspace,

00:11:02,800 --> 00:11:07,360
so you have to analyze the logic for that is really

00:11:07,360 --> 00:11:10,098
terrible, if you talk to Demitri

00:11:10,098 --> 00:11:13,973
and how they had to process those very strange cases.

00:11:17,040 --> 00:11:19,963
You don't necessarily need 100% coverage.

00:11:21,550 --> 00:11:25,003
They don't all need to be deeply inspected like this.

00:11:28,900 --> 00:11:30,540
I have a couple other items on here.

00:11:30,540 --> 00:11:31,680
Is there a question like,

00:11:31,680 --> 00:11:33,950
if we move it earlier before some checks

00:11:33,950 --> 00:11:37,066
or are we going to introduce information links,

00:11:37,066 --> 00:11:41,463
I don't know, but we could still do this piece meal,

00:11:42,490 --> 00:11:43,840
like Christian said.

00:11:43,840 --> 00:11:47,603
- I guess, when we started discussing this,

00:11:49,540 --> 00:11:52,690
we very quickly came to the realization that doing it

00:11:52,690 --> 00:11:56,460
in a generic way for every Syscall is probably the wrong

00:11:56,460 --> 00:11:59,200
approach, especially for these kinds of reason.

00:11:59,200 --> 00:12:01,473
Like all of the crazy stuff we just outlined.

00:12:03,150 --> 00:12:05,240
Maybe not every Syscall needs it,

00:12:05,240 --> 00:12:06,120
only the ones

00:12:06,120 --> 00:12:08,880
a lot of userspace processes usually care about.

00:12:08,880 --> 00:12:10,930
Like clone three, they probably care a lot.

00:12:10,930 --> 00:12:13,460
Probably (mumbles) for security reasons they care

00:12:13,460 --> 00:12:14,943
about a lot.

00:12:14,943 --> 00:12:16,040
These usually just rely on

00:12:16,040 --> 00:12:19,250
structures that have just also well defined types.

00:12:19,250 --> 00:12:22,780
That's something we could probably do,

00:12:22,780 --> 00:12:24,960
unless somebody has a really good idea on how to do this

00:12:24,960 --> 00:12:27,423
generically while avoiding all of these issues.

00:12:29,990 --> 00:12:32,110
- This is sort of meant to be a discussion,

00:12:32,110 --> 00:12:36,060
or a starting to say, "Here's why we want to do it,

00:12:36,060 --> 00:12:38,706
and here are the ways it doesn't work."

00:12:38,706 --> 00:12:40,480
- Right, so the first question, oh sorry,

00:12:40,480 --> 00:12:43,420
the first question I think I would want to impose,

00:12:43,420 --> 00:12:47,910
if you people think making a peace meal for a specific

00:12:47,910 --> 00:12:51,721
Syscall one at a time, we thing that would be worth

00:12:51,721 --> 00:12:54,400
the userspace to do would make sense or not.

00:12:54,400 --> 00:12:56,773
Otherwise, I'd just run around with the mic.

00:12:58,120 --> 00:12:59,980
- I think it does make sense,

00:12:59,980 --> 00:13:03,840
but how would userspace be able to know what's supported?

00:13:03,840 --> 00:13:06,597
How would discover this piece (audio cuts out).

00:13:10,270 --> 00:13:13,068
(laughter)

00:13:13,068 --> 00:13:14,655
- Yes, yet another problem.

00:13:14,655 --> 00:13:16,509
- Is it doable?

00:13:16,509 --> 00:13:19,930
That's probably not enough second knowledge on my part.

00:13:19,930 --> 00:13:24,913
Is it doable when you try to register it in your filter?

00:13:27,519 --> 00:13:29,660
This was Andy's idea, right?

00:13:29,660 --> 00:13:32,452
You would have to mark a Syscall as filterable

00:13:32,452 --> 00:13:34,157
like a new macro or something.

00:13:35,179 --> 00:13:38,262
(mumbles from crowd)

00:13:39,790 --> 00:13:42,984
- Right and the kernel would have to parse your filter

00:13:42,984 --> 00:13:44,672
to decide what Syscall you're talking about

00:13:44,672 --> 00:13:45,550
and that's not a good idea.

00:13:45,550 --> 00:13:48,130
So we need some meta-data exposed in some fashion

00:13:48,130 --> 00:13:51,060
that says, "Here are all the Syscall on the system."

00:13:51,060 --> 00:13:53,990
- Well we should kernel (mumbles) so we can just say.

00:13:53,990 --> 00:13:55,240
- Just parse the headers.

00:14:00,174 --> 00:14:01,420
- I'm just remembering,

00:14:01,420 --> 00:14:03,120
awhile ago somebody was discussing

00:14:03,970 --> 00:14:07,373
to having (audio cuts out)

00:14:07,373 --> 00:14:09,480
is this filterable?

00:14:09,480 --> 00:14:11,830
- Yeah, it would be nice to have the meta-data.

00:14:16,230 --> 00:14:18,570
- [Speaker] So if we had B-P-F system

00:14:18,570 --> 00:14:20,550
call filtering through E-B-P-F

00:14:20,550 --> 00:14:23,260
and we had an E-B-P-F helper function

00:14:23,260 --> 00:14:26,680
that could take our (mumbles) argument which is a pointer

00:14:26,680 --> 00:14:29,160
and copy it into some extra memory

00:14:29,160 --> 00:14:32,070
and change that pointer into a pointer memory

00:14:32,070 --> 00:14:33,886
for the rest of that system call?

00:14:33,886 --> 00:14:37,000
- Doesn't end up changing our race condition situation,

00:14:37,000 --> 00:14:38,376
is the problem.

00:14:38,376 --> 00:14:39,610
- [Speaker] Wait, why?

00:14:39,610 --> 00:14:42,369
You copy it once, from that point forward you use

00:14:42,369 --> 00:14:44,126
that new pointer.

00:14:44,126 --> 00:14:46,293
(mumbles)

00:14:48,695 --> 00:14:50,320
- We can cash the memory copies,

00:14:50,320 --> 00:14:53,260
we can do that, but then we end up with objects that change

00:14:53,260 --> 00:14:55,260
what they're actually pointing to.

00:14:55,260 --> 00:14:56,730
Like a file name,

00:14:56,730 --> 00:14:58,570
between when the filter analyzes it and

00:14:58,570 --> 00:15:02,490
when the system call would then use that cashed version

00:15:02,490 --> 00:15:06,290
of the path name, that file may have been re-named.

00:15:06,290 --> 00:15:07,700
- [Speaker] That's exactly what I wanted to ask,

00:15:07,700 --> 00:15:10,390
that feels like you're doing the filtering in the wrong

00:15:10,390 --> 00:15:11,223
place.

00:15:11,223 --> 00:15:12,680
If you wanna filter on the object,

00:15:12,680 --> 00:15:15,910
and you want the object we've got L-S-M hooks for that.

00:15:15,910 --> 00:15:19,423
The L-S-M hooks get the final fully-parsed kernel object.

00:15:21,458 --> 00:15:24,690
I don't think that invalidates the plan, though.

00:15:24,690 --> 00:15:27,750
Because what you said is, "Let's fix Syscall filter,"

00:15:27,750 --> 00:15:30,750
and as a way to fix Syscall filtering, I think it does

00:15:30,750 --> 00:15:32,010
fix Syscall filter,

00:15:32,010 --> 00:15:35,500
but it doesn't say everything can be done

00:15:35,500 --> 00:15:37,182
with Syscall filtering.

00:15:37,182 --> 00:15:38,370
There's some things you should do with Syscall

00:15:38,370 --> 00:15:41,030
and some things you should do with L-S-M.

00:15:41,030 --> 00:15:43,680
If you want to do something about what file object

00:15:43,680 --> 00:15:44,530
you land on,

00:15:44,530 --> 00:15:47,388
that has to be done in L-S-M, that can't be done in

00:15:47,388 --> 00:15:48,221
syscall.

00:15:48,221 --> 00:15:49,054
- Right.

00:15:55,190 --> 00:15:57,030
- [Speaker] One point I wanted to raise,

00:15:57,030 --> 00:15:59,180
'cause this relates to something

00:15:59,180 --> 00:16:01,680
bunch of hacks I'll be talking about on Wednesday.

00:16:03,700 --> 00:16:06,120
Filtering syscalls through Syscall can be

00:16:06,120 --> 00:16:09,770
kind of exposes (mumbles) details that you can

00:16:09,770 --> 00:16:12,040
never get rid of from the A-P-I,

00:16:12,040 --> 00:16:13,090
after you've done it.

00:16:14,323 --> 00:16:17,340
I (mumbles) the point made just now,

00:16:17,340 --> 00:16:22,250
although filtering on the machine level Syscall arguments

00:16:22,250 --> 00:16:24,890
is generic that it fills,

00:16:24,890 --> 00:16:27,373
that means it's equally bad for any purpose.

00:16:30,508 --> 00:16:32,340
It adds to two things that you didn't foresee

00:16:32,340 --> 00:16:34,472
and couldn't do any other way.

00:16:34,472 --> 00:16:35,951
Some advantages.

00:16:35,951 --> 00:16:37,377
- One of the issues would be L-S-M.

00:16:37,377 --> 00:16:42,215
Trying to get an unprivileged L-S-M of any kind installed,

00:16:42,215 --> 00:16:44,700
there's another project working on that.

00:16:44,700 --> 00:16:47,723
Attached E-B-P-F to be that language.

00:16:50,532 --> 00:16:53,539
It ends up, at least in earlier versions,

00:16:53,539 --> 00:16:56,440
exposing the L-S-M internals.

00:16:56,440 --> 00:16:58,380
Right now, at least, the system call interface

00:16:58,380 --> 00:17:00,240
is an exposed A-B-I.

00:17:00,240 --> 00:17:02,773
We can't change the path of the arguments.

00:17:04,010 --> 00:17:06,700
We can't change the meaning of a path,

00:17:06,700 --> 00:17:09,530
the arguments are fixed what they're supposed to point to.

00:17:09,530 --> 00:17:12,910
It's a matter of our kernels processing of those

00:17:12,910 --> 00:17:14,690
as their coming in.

00:17:14,690 --> 00:17:15,730
I completely agree,

00:17:15,730 --> 00:17:17,830
filtering is happening in the wrong place.

00:17:20,903 --> 00:17:24,970
It's now you expose internals that are the L-S-M.

00:17:24,970 --> 00:17:27,450
You have to somehow teach

00:17:27,450 --> 00:17:28,440
the L-S-M hooks

00:17:29,423 --> 00:17:31,200
about where they're coming from,

00:17:31,200 --> 00:17:33,610
how their being hit, what Syscall they're coming in through,

00:17:33,610 --> 00:17:36,890
because we have to retain that A-B-I knowledge.

00:17:36,890 --> 00:17:40,070
Which, of course, violates the purpose of the L-S-M hooks

00:17:40,070 --> 00:17:44,203
which are designed to be (mumbles) of the exposed interface.

00:17:45,690 --> 00:17:47,070
- [Speaker] I guess another option, I don't know

00:17:47,070 --> 00:17:49,470
if this makes sense, you could

00:17:49,470 --> 00:17:52,061
define new events that can be

00:17:52,061 --> 00:17:54,230
(mumbles) using (mumbles) of purposed

00:17:54,230 --> 00:17:56,670
designed for that rather than piggy-backing on something

00:17:56,670 --> 00:17:57,753
that's already there.

00:18:03,450 --> 00:18:05,660
- I'm not sure I agree with the statement

00:18:05,660 --> 00:18:08,230
that seccomp is too early.

00:18:08,230 --> 00:18:12,400
I think seccomp is in the right spot for what it does.

00:18:12,400 --> 00:18:15,390
You can't do everything with seccomp,

00:18:15,390 --> 00:18:17,670
but the deeper in you do the filtering,

00:18:17,670 --> 00:18:21,720
the more surface area you expose to attack.

00:18:21,720 --> 00:18:24,910
Doing filtering at seccomp is desirable

00:18:24,910 --> 00:18:26,400
because it is so early.

00:18:26,400 --> 00:18:29,720
The fact that you can't do certain types of filtering

00:18:29,720 --> 00:18:32,543
with it is not really a problem, right?

00:18:35,836 --> 00:18:37,865
- Thank you very much.

00:18:37,865 --> 00:18:39,620
I think at least from my perspective

00:18:39,620 --> 00:18:41,300
thanks for taking over.

00:18:41,300 --> 00:18:42,700
At least from my perspective

00:18:43,942 --> 00:18:46,480
we don't need the path based filtering.

00:18:46,480 --> 00:18:50,520
Like in the open filtering and re-name filter,

00:18:50,520 --> 00:18:53,893
to seccomp feels wrong to me.

00:18:55,050 --> 00:18:57,750
Exactly for that reason, you're dealing with strings

00:18:57,750 --> 00:18:59,970
that at a way later time.

00:18:59,970 --> 00:19:02,210
It actually just become relevant when they turn into

00:19:02,210 --> 00:19:03,283
kernel objects.

00:19:04,575 --> 00:19:07,924
It really feels like a way better approach for stuff like

00:19:07,924 --> 00:19:12,730
filtering (mumbles) argument which are a part of (mumbles)

00:19:12,730 --> 00:19:15,823
which do not change into other kernel objects.

00:19:19,400 --> 00:19:22,190
- [Speaker] Aren't some of those file descriptors?

00:19:22,190 --> 00:19:23,673
You need to figure out what they're attached to.

00:19:24,790 --> 00:19:27,833
Anyway, that turns into an L-S-M question all over.

00:19:29,810 --> 00:19:32,031
- So going back to the discoverability thing

00:19:32,031 --> 00:19:33,328
that I was talking about earlier,

00:19:33,328 --> 00:19:35,780
I just remembered that I actually added a way

00:19:35,780 --> 00:19:38,230
for the seccomp Syscall to detect

00:19:38,230 --> 00:19:41,200
if a filter flag exists in the current kernel.

00:19:41,200 --> 00:19:43,900
So maybe that is something similar can be done where

00:19:43,900 --> 00:19:46,450
we extend the seccomp Syscall that or new operation

00:19:47,289 --> 00:19:49,030
that says, "Can we do deep arguments inspection

00:19:49,030 --> 00:19:50,777
on this specific Syscall?"

00:19:51,650 --> 00:19:53,530
We can also we can alter,

00:19:53,530 --> 00:19:55,480
quickly back to the F-D stuff,

00:19:55,480 --> 00:19:57,680
we can probably also skip

00:19:57,680 --> 00:20:00,171
Syscall with the F-D's at the beginning.

00:20:00,171 --> 00:20:02,338
(mumbles)

00:20:03,750 --> 00:20:06,890
because you can filter the flag document, it doesn't matter.

00:20:06,890 --> 00:20:08,623
F-D's we should skip, as well.

00:20:19,405 --> 00:20:22,485
- [Speaker] I think the comment of us made

00:20:22,485 --> 00:20:24,485
seccomp (mumbles) where is should be and

00:20:26,660 --> 00:20:30,293
doing the used (mumbles) might actually be reasonable.

00:20:33,688 --> 00:20:36,000
As long as you don't expect to actually go and look

00:20:37,008 --> 00:20:38,872
at the object at that point.

00:20:38,872 --> 00:20:40,824
We will do some amount of stream compare, and what not

00:20:40,824 --> 00:20:41,657
on those paths maybe.

00:20:41,657 --> 00:20:43,531
It might just be a trivial (mumbles)

00:20:43,531 --> 00:20:45,980
it must have that suffix or that prefix, or something.

00:20:45,980 --> 00:20:47,593
That you could do safely.

00:20:48,650 --> 00:20:50,150
What the final (mumbles) is gonna be,

00:20:50,150 --> 00:20:53,252
that's left for the D-S-M's to figure out.

00:20:53,252 --> 00:20:55,443
That would still give us the ability to

00:20:55,443 --> 00:20:58,710
do string compares like the

00:20:59,860 --> 00:21:02,900
mount fire system name and some other stuff.

00:21:02,900 --> 00:21:05,060
Do some basic string repair on some paths

00:21:05,060 --> 00:21:07,380
if we really want them for a prefix or suffix

00:21:07,380 --> 00:21:08,230
or something like that.

00:21:08,230 --> 00:21:11,790
It would let us do the checks against the tracks.

00:21:11,790 --> 00:21:14,490
For anything where you actually (mumbles)

00:21:14,490 --> 00:21:16,603
then that should be it's entire tray.

00:21:16,603 --> 00:21:19,186
- We have somebody in the back.

00:21:22,280 --> 00:21:24,050
- [Speaker] I think, not only is that still racing

00:21:24,050 --> 00:21:26,130
the problem is the dreadful races you're talking about

00:21:26,130 --> 00:21:27,520
already exists.

00:21:27,520 --> 00:21:30,594
A classic one is a recent subject of a bunch of (mumbles).

00:21:30,594 --> 00:21:33,303
(mumbles)

00:21:33,303 --> 00:21:35,950
which is obviously (mumbles) 'cause the (mumbles)

00:21:35,950 --> 00:21:38,120
can be recycled between the check.

00:21:38,120 --> 00:21:41,010
I was thinking, that's not a problem,

00:21:41,010 --> 00:21:43,670
you can use P-D-F's but you just proved you can't use the

00:21:43,670 --> 00:21:44,600
F-D either.

00:21:44,600 --> 00:21:47,165
I'm just wondering, what other (mumbles) are there left

00:21:47,165 --> 00:21:49,090
that you can safely check which are actually in use.

00:21:49,090 --> 00:21:51,760
If it's nothing which can correspond to a kernel can

00:21:51,760 --> 00:21:54,083
be checked, is there actually anything you can check,

00:21:54,083 --> 00:21:56,333
other than the length of what you're reading?

00:21:57,372 --> 00:21:58,460
(laughter)

00:21:58,460 --> 00:22:00,162
- That's a good question.

00:22:00,162 --> 00:22:00,995
(laughter)

00:22:00,995 --> 00:22:03,070
This is why the L-S-M is where it is

00:22:03,070 --> 00:22:05,610
because you can attach policy

00:22:05,610 --> 00:22:07,310
to the kernel objects effectively.

00:22:08,400 --> 00:22:09,560
- [Speaker] This may already have been covered

00:22:09,560 --> 00:22:14,053
a couple times, but why is L-S-M plus B-P-F not the answer?

00:22:17,860 --> 00:22:21,563
- Right now there isn't an un-privileged way to do either.

00:22:22,692 --> 00:22:25,650
- [Speaker] L-S-M plus B-P-F plus un-privileged B-P-F then.

00:22:25,650 --> 00:22:29,270
- Un-privileged E-B-P-F sort of doesn't exist

00:22:29,270 --> 00:22:30,140
because it needs

00:22:31,410 --> 00:22:34,362
there is not, right now, a privileged policy

00:22:34,362 --> 00:22:36,140
of how it should work.

00:22:36,140 --> 00:22:38,355
It's sort of being argued about right now.

00:22:38,355 --> 00:22:40,501
- [Speaker] Right, exactly so it's one theoretical answer.

00:22:40,501 --> 00:22:41,930
- It's one path.

00:22:41,930 --> 00:22:44,920
Right now, that was going to be the solution to

00:22:44,920 --> 00:22:47,760
how do we do a un-privileged L-S-M.

00:22:47,760 --> 00:22:50,820
Oh we can just load B=P-M into the L-S-M hooks and off we go

00:22:50,820 --> 00:22:53,010
which was sort of my hope for

00:22:53,010 --> 00:22:55,180
oh great, we can do deep inspection and it's not

00:22:55,180 --> 00:22:58,217
seccomp's problem, that would be awesome for me, thank you.

00:23:00,090 --> 00:23:02,192
There's a lot of

00:23:02,192 --> 00:23:06,030
conversation in and around how to do that correctly.

00:23:06,030 --> 00:23:10,090
It does seem like doing the deep argument inspection

00:23:10,090 --> 00:23:13,380
needs to happen at effectively that layer,

00:23:13,380 --> 00:23:16,921
but does it need to be seccomp and then we come back out

00:23:16,921 --> 00:23:20,500
and do crazy things, or is it entirely on the L-S-M side?

00:23:20,500 --> 00:23:21,633
Still unclear.

00:23:22,890 --> 00:23:24,930
- [Speaker] So, just to add to what Case was saying,

00:23:24,930 --> 00:23:27,458
you already said it a little bit before,

00:23:27,458 --> 00:23:30,780
having it be B-P-F in the L-S-M also means

00:23:30,780 --> 00:23:34,410
we having to expose gadgets at the L-S-M layer

00:23:34,410 --> 00:23:39,410
and the A-B-I userspace for E-B-P-F to use.

00:23:41,098 --> 00:23:43,410
That can leak information

00:23:43,410 --> 00:23:46,260
through sidechannel attacks from deeper in the kernel.

00:23:46,260 --> 00:23:48,730
Not only from Syscall return values,

00:23:48,730 --> 00:23:52,150
but you can make filters to do timing based attacks

00:23:52,150 --> 00:23:54,268
to read internal data

00:23:54,268 --> 00:23:55,930
from those gadgets.

00:23:55,930 --> 00:23:58,640
It becomes a real concern for the security modules,

00:23:58,640 --> 00:24:00,782
that there is this E-B-P-F module in there

00:24:00,782 --> 00:24:05,650
that could potentially expose some of their state as well.

00:24:05,650 --> 00:24:07,717
Just their own stuff to userspace.

00:24:13,720 --> 00:24:14,820
- At least no one is going,

00:24:14,820 --> 00:24:18,316
obviously you forgot about this perfectly good solution.

00:24:18,316 --> 00:24:19,488
(laughter)

00:24:19,488 --> 00:24:22,738
(crowd member mumbles)

00:24:30,357 --> 00:24:33,190
(speaker mumbles)

00:24:46,782 --> 00:24:48,970
- Right, those are classic examples of where

00:24:48,970 --> 00:24:51,590
everything's available in the integer that's passed in

00:24:51,590 --> 00:24:53,433
as a pointer to it, right?

00:24:54,400 --> 00:24:57,280
There's no reason why you couldn't filter those with seccomp

00:24:57,280 --> 00:24:59,430
except for the fact that you get a pointer.

00:25:00,580 --> 00:25:02,320
There's tons of those.

00:25:02,320 --> 00:25:06,843
- That matches the new mount A-P-I and other stuff.

00:25:08,530 --> 00:25:11,480
- [Speaker] Were you looking to use the user notification

00:25:11,480 --> 00:25:15,070
feature to do your filtering to dig into these pointers,

00:25:15,070 --> 00:25:17,050
or were you looking to actually go into the B-P-F

00:25:17,050 --> 00:25:19,310
and actually de-reference the pointer

00:25:19,310 --> 00:25:22,923
and look at it into the bowels of C-B-P-F.

00:25:26,835 --> 00:25:29,550
- The question being if we want to do it in kernel?

00:25:29,550 --> 00:25:34,104
Yes, one of the example I always give is,

00:25:34,104 --> 00:25:39,104
we intercepting these (mumbles) call for example.

00:25:39,180 --> 00:25:43,200
Well, anything that has a (mumbles) on it,

00:25:43,200 --> 00:25:46,380
that you can't really filter but you're still interested

00:25:46,380 --> 00:25:47,823
in some parts.

00:25:48,947 --> 00:25:52,950
You can tell on the information whether or not you want to

00:25:52,950 --> 00:25:57,396
do the Syscall in loo of whatever is calling out to you.

00:25:57,396 --> 00:26:01,290
You have to intercept all of them, though.

00:26:01,290 --> 00:26:03,940
So you have to do all of the work,

00:26:03,940 --> 00:26:06,150
and that's for the container for example,

00:26:06,150 --> 00:26:07,963
that's really annoying.

00:26:10,130 --> 00:26:12,200
For (mumbles) for example, where you have

00:26:12,200 --> 00:26:14,690
a (mumbles) argument that you can easily inspect.

00:26:14,690 --> 00:26:16,742
You have a bunch of others, though.

00:26:16,742 --> 00:26:17,880
You can register a filter where you basically can filter

00:26:17,880 --> 00:26:19,617
anything out that you're not interested in

00:26:19,617 --> 00:26:22,835
and you get only notifications for the very specific

00:26:22,835 --> 00:26:26,410
(mumbles) that you want to perform in loo of the container.

00:26:26,410 --> 00:26:28,680
Intercepting anything that has pointers,

00:26:28,680 --> 00:26:31,020
means you need to do all of the syscalls that would

00:26:31,020 --> 00:26:32,830
otherwise work

00:26:32,830 --> 00:26:34,630
also for the container, which is really annoying

00:26:34,630 --> 00:26:37,080
because you have to assume credentials and so on.

00:26:39,320 --> 00:26:41,768
That's why we needed to have a kernel.

00:26:41,768 --> 00:26:43,150
- [Speaker] That's what I thought, just making sure.

00:26:43,150 --> 00:26:44,440
- I know what you're getting at though,

00:26:44,440 --> 00:26:47,590
which is okay so now I have another thing I need to examine,

00:26:47,590 --> 00:26:49,870
how do I examine it, what's the path?

00:26:49,870 --> 00:26:52,550
Right now I'm kind of going, we can't even design

00:26:52,550 --> 00:26:55,020
where it should be, I don't know how we're gonna do it.

00:26:55,020 --> 00:26:59,400
When I looked at it, initially I thought, "Oh this is easy,

00:26:59,400 --> 00:27:01,506
we have a structure now."

00:27:01,506 --> 00:27:04,400
Packet data, again, it's basically the same thing.

00:27:04,400 --> 00:27:06,840
We can just say, "Attach this filter

00:27:06,840 --> 00:27:10,347
to that deep inspection of this structure."

00:27:11,470 --> 00:27:14,640
Okay, specifying that might start getting painful,

00:27:14,640 --> 00:27:19,287
if only there were an extended B-P-F I could use to do that.

00:27:19,287 --> 00:27:21,160
(laughter)

00:27:21,160 --> 00:27:22,680
- [Speaker] I'm dreading the (mumbles)

00:27:22,680 --> 00:27:23,840
side of things, as well.

00:27:23,840 --> 00:27:25,820
That seems really hard to write.

00:27:25,820 --> 00:27:27,810
- Yeah, which the other part is like,

00:27:27,810 --> 00:27:29,480
well (mumbles) already specifies

00:27:29,480 --> 00:27:34,480
what it can inspect, which is the detail on the Syscall.

00:27:36,660 --> 00:27:38,617
So if I mark it for deep inspection do I

00:27:38,617 --> 00:27:43,480
append series of structures on that one,

00:27:43,480 --> 00:27:45,500
and now make it a dynamic size,

00:27:45,500 --> 00:27:46,950
or do I?

00:27:46,950 --> 00:27:48,630
The actual implementation of that is

00:27:48,630 --> 00:27:50,440
still totally unknown to me.

00:27:50,440 --> 00:27:53,989
I had these thoughts, but where do I put it first?

00:27:53,989 --> 00:27:56,350
(laughter)

00:27:56,350 --> 00:27:57,200
- So one more thing,

00:27:57,200 --> 00:28:00,962
because it keeps popping up the L-S-M, E-B-P-F stuff.

00:28:00,962 --> 00:28:03,220
One of the other reasons why it's really difficult

00:28:03,220 --> 00:28:05,790
is just from a pure up streaming perspective, right?

00:28:05,790 --> 00:28:07,410
You have the E-B-P-F maintainers,

00:28:07,410 --> 00:28:10,170
who are not sure they agree with a bunch of other people

00:28:10,170 --> 00:28:12,330
that unprivileged E-B-P-F have saved.

00:28:12,330 --> 00:28:13,980
Then you have the L-S-M guys,

00:28:13,980 --> 00:28:15,950
which is in their right to do,

00:28:15,950 --> 00:28:19,090
their saying you're exposing internals that you may not

00:28:19,090 --> 00:28:21,790
want to expose, and we had that exact same discussion

00:28:21,790 --> 00:28:23,960
at L-S-A a couple of

00:28:23,960 --> 00:28:24,793
weeks ago.

00:28:24,793 --> 00:28:26,699
The exact same issues were raised.

00:28:26,699 --> 00:28:30,256
Whenever this is going to happen,

00:28:30,256 --> 00:28:34,070
if it is going to happen is the question.

00:28:34,070 --> 00:28:36,360
There's not even sure, I think, that some people are

00:28:36,360 --> 00:28:38,000
afraid there's only going to be one

00:28:38,000 --> 00:28:41,250
E-B-P-F L-S-M, 'cause people don't want to

00:28:41,250 --> 00:28:42,280
maintain multiple.

00:28:42,280 --> 00:28:44,706
That was raised as an issues, as well.

00:28:44,706 --> 00:28:48,100
There may be another E-B-P-F L-S-M coming up.

00:28:56,443 --> 00:28:59,693
(crowd member mumbles)

00:29:01,438 --> 00:29:02,271
- [Speaker] I was gonna say stacking,

00:29:03,237 --> 00:29:04,070
but it looks like she solved for micro L-S-M's.

00:29:05,356 --> 00:29:06,730
- Solved for micro, solved for medium,

00:29:06,730 --> 00:29:09,630
everything except start doing weird things with (mumbles).

00:29:11,293 --> 00:29:13,543
(laughter)

00:29:17,420 --> 00:29:19,020
- [Speaker] Any other questions?

00:29:22,265 --> 00:29:24,073
Or suggestions?

00:29:26,795 --> 00:29:28,600
- [Speaker] I have one.

00:29:28,600 --> 00:29:29,433
- Yeah.

00:29:30,840 --> 00:29:32,430
- [Speaker] So you mentioned that it's possible

00:29:32,430 --> 00:29:35,240
to change the system call, skip the system call, etc.

00:29:35,240 --> 00:29:36,800
Re-enter the system call.

00:29:36,800 --> 00:29:40,140
Can you change one system call into multiple system calls?

00:29:40,140 --> 00:29:40,973
- Not right now,

00:29:42,178 --> 00:29:43,540
but I love this idea.

00:29:43,540 --> 00:29:45,750
That's totally insane.

00:29:45,750 --> 00:29:48,000
(laughter)

00:29:49,654 --> 00:29:51,740
(crowd member mumbles)

00:29:51,740 --> 00:29:53,093
- Well, yeah I suppose,

00:29:55,310 --> 00:29:58,267
because what do you return to userspace?

00:30:00,827 --> 00:30:02,750
That's actually one of the issues is that

00:30:02,750 --> 00:30:05,180
sometimes with one of the filters you wanna say

00:30:05,180 --> 00:30:06,830
this got handled for you,

00:30:06,830 --> 00:30:08,790
so pretend that everything is fine,

00:30:08,790 --> 00:30:10,370
but don't actually run the Syscall

00:30:10,370 --> 00:30:12,520
because we've already done the kernel state change

00:30:12,520 --> 00:30:14,050
that you wanted.

00:30:14,050 --> 00:30:18,560
Right now we just have to invent that

00:30:18,560 --> 00:30:21,410
if it is at the L-S-M layer,

00:30:21,410 --> 00:30:24,070
we have to say effectively skip,

00:30:24,070 --> 00:30:25,363
but pretend it was fine.

00:30:27,040 --> 00:30:28,869
- [Speaker] For what it's worth,

00:30:28,869 --> 00:30:29,920
I am probably many other people who've done

00:30:29,920 --> 00:30:31,527
this sort of thing with (mumbles),

00:30:32,548 --> 00:30:34,133
really it's the same problem was,

00:30:34,133 --> 00:30:36,860
what on Earth do you return if you decided not to run

00:30:36,860 --> 00:30:37,960
the Syscall at all?

00:30:37,960 --> 00:30:41,090
You often just use the same technique as a shell pipeline

00:30:42,266 --> 00:30:44,683
would, and you return success of at least one of the

00:30:45,847 --> 00:30:47,447
(mumbles).

00:30:47,447 --> 00:30:50,182
You just return whatever the error codes was,

00:30:50,182 --> 00:30:51,714
and hope one of them works.

00:30:51,714 --> 00:30:53,997
Usually the caller worked, but if the caller doesn't work

00:30:53,997 --> 00:30:55,047
you can just blame the caller, it was an error.

00:30:55,047 --> 00:30:55,880
(laughter)

00:30:55,880 --> 00:30:59,440
- At least in L-S-M there isn't a stop without an error

00:30:59,440 --> 00:31:00,300
code right now.

00:31:00,300 --> 00:31:02,540
You can say (mumbles) access and everything fails

00:31:02,540 --> 00:31:04,204
all the way out.

00:31:04,204 --> 00:31:06,100
Userspace is like, "Oh I guess I didn't get that mount."

00:31:06,100 --> 00:31:07,650
And you're like, "No, no I did!

00:31:08,744 --> 00:31:10,844
We did it for you in the process monitor."

00:31:17,410 --> 00:31:19,800
- You could at least get a long way

00:31:21,720 --> 00:31:23,913
for the case where you want to,

00:31:25,100 --> 00:31:27,840
you could do some space user section right?

00:31:27,840 --> 00:31:30,797
If you use the second notifier F-D and you get the resume

00:31:30,797 --> 00:31:32,263
feature,

00:31:35,267 --> 00:31:37,100
that would be for Chrome, for example,

00:31:37,100 --> 00:31:40,280
a process that watches the syscalls being performed

00:31:40,280 --> 00:31:43,420
and then looks at the clone Syscall being performed,

00:31:43,420 --> 00:31:44,683
then looks at the flag argument,

00:31:44,683 --> 00:31:47,210
then looks at the flags in whether it's in some predefined

00:31:47,210 --> 00:31:49,910
list, but the you're putting all the burden of security

00:31:49,910 --> 00:31:51,762
out to userspace and probably

00:31:51,762 --> 00:31:56,120
Google doesn't want to add a watcher system for Chrome,

00:31:56,120 --> 00:31:57,693
it just watches Syscalls.

00:31:58,639 --> 00:32:00,676
Then you tell it to resume.

00:32:00,676 --> 00:32:04,440
(crown member mumbles)

00:32:04,440 --> 00:32:05,590
- You can only deny it.

00:32:08,318 --> 00:32:09,930
Oh, so you have the same problem userspace,

00:32:09,930 --> 00:32:10,830
isn't that pretty.

00:32:12,340 --> 00:32:14,693
- And you're (mumbles) it again,

00:32:14,693 --> 00:32:16,464
which is wat the kernel is supposed to do for you.

00:32:16,464 --> 00:32:17,297
It keeps coming down to,

00:32:17,297 --> 00:32:18,410
this really needs to be the L-S-M layer,

00:32:18,410 --> 00:32:22,545
but we don't expose the Syscall

00:32:22,545 --> 00:32:26,870
A-B-I to the L-S-M enough to make decisions at the L-S-M

00:32:26,870 --> 00:32:29,169
layer about where it came from.

00:32:29,169 --> 00:32:30,300
Which we have actually started to do.

00:32:30,300 --> 00:32:34,360
Maybe that is the path to solve that particular problem.

00:32:34,360 --> 00:32:36,742
Then figure out how to parse it.

00:32:36,742 --> 00:32:39,992
(crowd member mumbles)

00:32:41,079 --> 00:32:43,110
- An example I had, for examples,

00:32:43,110 --> 00:32:45,380
you want to create a socket and set up some socket options

00:32:45,380 --> 00:32:46,260
in it by default.

00:32:46,260 --> 00:32:49,210
That's the case where one system call changes into a dozen.

00:32:50,130 --> 00:32:53,053
It doesn't seem like L-S-M is the right answer.

00:32:55,850 --> 00:32:57,890
- I mean, it's a single system call,

00:32:57,890 --> 00:33:02,560
it just has multiple side affects, right now.

00:33:02,560 --> 00:33:05,222
The said (mumbles) stuff,

00:33:05,222 --> 00:33:07,610
the (mumbles) that happens in the one,

00:33:07,610 --> 00:33:09,680
is that 32 bit compad, or something,

00:33:09,680 --> 00:33:11,330
I don't remember which one it is.

00:33:15,272 --> 00:33:17,250
It didn't seem to me like that was particularly

00:33:17,250 --> 00:33:21,973
different from the new style of structure passing ones.

00:33:26,060 --> 00:33:27,460
- [Speaker] So, are we done?

00:33:29,344 --> 00:33:31,142
- I think so.

00:33:31,142 --> 00:33:33,961
- [Speaker] I think we've reached the same level of success

00:33:33,961 --> 00:33:35,104
as the L-stream graphics talk.

00:33:35,104 --> 00:33:37,354
(laughter)

00:33:39,330 --> 00:33:41,409
Okay, thank you!

00:33:41,409 --> 00:33:43,659

YouTube URL: https://www.youtube.com/watch?v=PnOSPsRzVYM


