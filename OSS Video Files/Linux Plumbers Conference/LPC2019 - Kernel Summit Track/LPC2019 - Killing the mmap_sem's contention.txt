Title: LPC2019 - Killing the mmap_sem's contention
Publication date: 2019-11-18
Playlist: LPC2019 - Kernel Summit Track
Description: 
	Big systems are becoming more common these days. Having thousands of CPUs is
no more a dream and some applications are attempting to spread over all
these CPUs by creating threads.
This leads to contention on the mm-mmap_sem which is protecting the memory
layout shared by these threads.
There were multiple attempts to get rid of the mmap_sem's contention or the
mmap_sem itself, Speculative Page Fault, RangeLock, Scalable Address Spaces
Using RCU Balanced Trees...
Unfortunately, these attempts didn't last enough to reach the upstream
state. One the reason could be the major impact they are implying on the MM
code or that they are only addressing part of the overall picture (SPF).
Last discussions at the LSF/MM summit were not leading to an agreement on a
solution (see LWN coverage).
This topic is presenting one of emerging solution which didn't get the time
to be proposed at the last LSF/MM. It is based on discussion some folks had
at the end of the summit, trying to brainstorm a way to move to a split lock
mechanism, as it was done for the PTE locking, removing the
mm-page_table_lock.
Currently, this work is still in progress and some deviations on the original
design are expected to happen, so kind of split lock is the current option
but this may change in the meantime.
This topic is linked to the use of a Maple Tree to replace both the VMA RB
tree and the VMA double linked list. Matthew Wilcox and Liam R. Howlett are
working on.

Mr Jérôme Glisse
Mr Laurent Dufour
Captions: 
	00:00:00,030 --> 00:00:07,200
I'm pleased I'm working for roulette

00:00:02,220 --> 00:00:12,570
same company yes hey so you know you're

00:00:07,200 --> 00:00:14,370
a VM so we are talking about the killing

00:00:12,570 --> 00:00:16,970
the elapsed and contention that's quite

00:00:14,370 --> 00:00:19,500
a follow up of what's Michele presented

00:00:16,970 --> 00:00:21,630
previously that just a different

00:00:19,500 --> 00:00:22,859
approach to access to address the

00:00:21,630 --> 00:00:33,690
problem

00:00:22,859 --> 00:00:39,270
Moin of the common issue okay so we can

00:00:33,690 --> 00:00:42,450
exceed so that's the same I will not

00:00:39,270 --> 00:00:45,780
talk a lot about the enough some

00:00:42,450 --> 00:00:49,620
contention Michele made a great show

00:00:45,780 --> 00:00:52,770
about that so nothing more to to mention

00:00:49,620 --> 00:00:56,750
there just to mention that there is also

00:00:52,770 --> 00:01:06,479
the yellow blocks that's somehow is also

00:00:56,750 --> 00:01:15,780
making trouble now on some systems and

00:01:06,479 --> 00:01:18,659
Jerome is paying with his wonderful so I

00:01:15,780 --> 00:01:20,130
will good show very quickly on there on

00:01:18,659 --> 00:01:24,390
these slides because we shall already

00:01:20,130 --> 00:01:27,210
told everything about that so one of the

00:01:24,390 --> 00:01:31,130
biggest problem with the maps and today

00:01:27,210 --> 00:01:34,430
is that this double order link list that

00:01:31,130 --> 00:01:36,000
is not very cache efficient from what

00:01:34,430 --> 00:01:38,729
I'm being told

00:01:36,000 --> 00:01:40,200
and the Augmented are which we are so is

00:01:38,729 --> 00:01:42,979
touring information is not some new

00:01:40,200 --> 00:01:45,240
Abbott resource or far out find the gap

00:01:42,979 --> 00:01:48,600
when you are looking for a free area

00:01:45,240 --> 00:01:50,909
that's a very fast process using

00:01:48,600 --> 00:01:53,070
segmented arbitrary because there is a

00:01:50,909 --> 00:01:54,750
gap stored inside so this is very

00:01:53,070 --> 00:01:59,820
important to keep that in mind because

00:01:54,750 --> 00:02:03,659
finding a gap free gap is very that

00:01:59,820 --> 00:02:07,220
needs to be very fast and also we have

00:02:03,659 --> 00:02:10,619
the locked locking on the page tables

00:02:07,220 --> 00:02:12,510
that's also one way to address the

00:02:10,619 --> 00:02:13,500
problem because we can rely on these

00:02:12,510 --> 00:02:17,790
locks

00:02:13,500 --> 00:02:21,450
to do some VMA operation because as

00:02:17,790 --> 00:02:22,920
assuming that once we get the PTL we

00:02:21,450 --> 00:02:31,890
know that nothing will happen in this

00:02:22,920 --> 00:02:36,540
area so that's some some some topic true

00:02:31,890 --> 00:02:41,040
to to keep in mind so by the gravy yes

00:02:36,540 --> 00:02:43,710
Michel already explains that a lot of

00:02:41,040 --> 00:02:47,280
stuff is done using the dionneb Sam but

00:02:43,710 --> 00:02:48,840
also there is one workaround that we

00:02:47,280 --> 00:02:51,000
should the notion that start growing

00:02:48,840 --> 00:02:52,860
that something that's dawn without

00:02:51,000 --> 00:02:56,270
checking India map saying the right mode

00:02:52,860 --> 00:02:59,070
because that's will be too much a

00:02:56,270 --> 00:03:01,020
contention so this is one workaround one

00:02:59,070 --> 00:03:03,150
mitigation that's has been put in place

00:03:01,020 --> 00:03:04,500
and that's something that needs to be

00:03:03,150 --> 00:03:06,870
keep in mind also because that's

00:03:04,500 --> 00:03:11,310
changing the layout of the virtual

00:03:06,870 --> 00:03:13,020
memory and so there is a downgrade

00:03:11,310 --> 00:03:21,200
that's you share already talked about

00:03:13,020 --> 00:03:26,010
that so my idea is to put the VM a Loki

00:03:21,200 --> 00:03:28,500
inside or near by the VMS data I I think

00:03:26,010 --> 00:03:30,530
that's the the locking is more efficient

00:03:28,500 --> 00:03:36,080
if it is nearby the data is protecting

00:03:30,530 --> 00:03:39,450
so my ID is to protect the the range

00:03:36,080 --> 00:03:41,910
that we will address but to put that

00:03:39,450 --> 00:03:44,010
locking information inside the VM a

00:03:41,910 --> 00:03:46,200
instead of putting that in a separate

00:03:44,010 --> 00:03:50,190
tree that's the main difference between

00:03:46,200 --> 00:03:52,800
the initial approach and ours won't so

00:03:50,190 --> 00:03:55,620
but it's it's always a trade-off there

00:03:52,800 --> 00:03:57,060
is no today is difficult to say that

00:03:55,620 --> 00:04:01,800
there is one option that's a bit better

00:03:57,060 --> 00:04:04,290
than the other one so and putting the

00:04:01,800 --> 00:04:07,140
the lock inside the VM a also makes

00:04:04,290 --> 00:04:10,080
sense because we have to lock all the

00:04:07,140 --> 00:04:12,720
VMS range because we want to prevent the

00:04:10,080 --> 00:04:14,880
VM a to be to be split because that's

00:04:12,720 --> 00:04:17,100
making trouble when we are trying to

00:04:14,880 --> 00:04:20,520
address to access the the VM a structure

00:04:17,100 --> 00:04:23,880
while someone is splitted in in our back

00:04:20,520 --> 00:04:26,940
or merging it in our back so magic

00:04:23,880 --> 00:04:30,570
looking on the VM a boundaries

00:04:26,940 --> 00:04:33,570
to be the lock grain that we should use

00:04:30,570 --> 00:04:35,460
so using the lock inside the VM Amy

00:04:33,570 --> 00:04:40,310
makes this easier because we know

00:04:35,460 --> 00:04:44,310
exactly the boundaries at this time so

00:04:40,310 --> 00:04:47,460
that's why I think that's putting the

00:04:44,310 --> 00:04:52,500
the range inside the VMAs it's the it's

00:04:47,460 --> 00:04:54,810
me the best way for me there is a

00:04:52,500 --> 00:04:59,130
program when taking the range lock is

00:04:54,810 --> 00:05:02,940
that we have the risk of that lock if

00:04:59,130 --> 00:05:07,380
one thread want to lock range and other

00:05:02,940 --> 00:05:09,900
threads look you parent and then these

00:05:07,380 --> 00:05:11,760
sort of threads want to lock this range

00:05:09,900 --> 00:05:14,130
right those are one one to lock this one

00:05:11,760 --> 00:05:14,880
that's a deadlock situation so one of

00:05:14,130 --> 00:05:19,500
the rule

00:05:14,880 --> 00:05:21,330
III assuming that the lock is always

00:05:19,500 --> 00:05:24,030
done from the lowest address to the

00:05:21,330 --> 00:05:26,070
highest arrest see if we need to lock to

00:05:24,030 --> 00:05:31,290
area we will first lock the lowest one

00:05:26,070 --> 00:05:34,560
and then the i/o one never the rivers so

00:05:31,290 --> 00:05:38,460
that this is a convention III try to to

00:05:34,560 --> 00:05:40,470
put in place in the code so there is

00:05:38,460 --> 00:05:44,730
some drawback for that in the case of

00:05:40,470 --> 00:05:47,880
the EM remap flow we may want to remap

00:05:44,730 --> 00:05:49,919
one area to somewhere we don't know

00:05:47,880 --> 00:05:52,950
where at the time so we need to fetch

00:05:49,919 --> 00:05:55,050
some free area to remap this one to a

00:05:52,950 --> 00:05:58,530
larger one for instance and if we do

00:05:55,050 --> 00:06:01,710
that maybe the the range we will found

00:05:58,530 --> 00:06:05,280
once we have locked that's part we want

00:06:01,710 --> 00:06:07,980
to remap maybe lower so that's break the

00:06:05,280 --> 00:06:10,830
rule so we need to relax

00:06:07,980 --> 00:06:14,220
this one locks the free area and try to

00:06:10,830 --> 00:06:19,260
real lock the area we want to rot so

00:06:14,220 --> 00:06:20,790
that's kind of ugly situation that needs

00:06:19,260 --> 00:06:23,040
to be addressed in that case I don't

00:06:20,790 --> 00:06:25,200
know if the if you think about that in

00:06:23,040 --> 00:06:27,620
the range lock you want to put in place

00:06:25,200 --> 00:06:27,620
Michelle

00:06:32,410 --> 00:06:40,940
okay most of the time I only have one

00:06:38,110 --> 00:06:43,790
locked one other game and so that's

00:06:40,940 --> 00:06:45,860
really easy but in our apps is quite

00:06:43,790 --> 00:06:47,770
painful in in especially when you don't

00:06:45,860 --> 00:06:52,060
know where you want to remap right

00:06:47,770 --> 00:06:56,390
that's like man I agree we would want to

00:06:52,060 --> 00:06:58,490
make some order based on the based on

00:06:56,390 --> 00:07:10,700
the addresses that's the simplest way

00:06:58,490 --> 00:07:14,000
yeah so everybody can read that so

00:07:10,700 --> 00:07:19,540
that's the the following on the VMA

00:07:14,000 --> 00:07:23,720
rules so we locked on the VMA boundaries

00:07:19,540 --> 00:07:25,610
but if the lock they are we all want to

00:07:23,720 --> 00:07:28,420
lock is covering multiple way mean we

00:07:25,610 --> 00:07:32,110
have to lock all the VMI's of course and

00:07:28,420 --> 00:07:34,700
we may have to locked area that's bid

00:07:32,110 --> 00:07:36,380
which are between two vme in the case of

00:07:34,700 --> 00:07:38,420
em and math you can amend map we

00:07:36,380 --> 00:07:40,490
launched our wrong range and that range

00:07:38,420 --> 00:07:43,220
is covered multiple VMA with gap between

00:07:40,490 --> 00:07:45,950
south VMA so in that case we have to

00:07:43,220 --> 00:07:47,810
also lock the range between those vme

00:07:45,950 --> 00:07:49,940
because we don't want someone to do an a

00:07:47,810 --> 00:07:55,400
map you know back in this area we learn

00:07:49,940 --> 00:07:58,730
map and also we may have to lock area

00:07:55,400 --> 00:08:03,830
before just before a vm a and just after

00:07:58,730 --> 00:08:06,470
a vm a that's quite a use case for the

00:08:03,830 --> 00:08:09,110
growing area or when you want to be a

00:08:06,470 --> 00:08:11,780
Lipsy allocate or is usually a map and a

00:08:09,110 --> 00:08:15,080
map in 60-seconds range so we need to

00:08:11,780 --> 00:08:17,480
log this area so in that case we have to

00:08:15,080 --> 00:08:18,560
lock the range just after the VMA or

00:08:17,480 --> 00:08:21,200
just before the VA

00:08:18,560 --> 00:08:23,720
the previous GME and that will be done

00:08:21,200 --> 00:08:30,080
by extending the lock we applied to the

00:08:23,720 --> 00:08:33,919
VMA there is also the common cases where

00:08:30,080 --> 00:08:36,290
there is no nothing and we want to a map

00:08:33,919 --> 00:08:38,840
in area where there is nothing already

00:08:36,290 --> 00:08:42,200
yet mat so in that case we don't have a

00:08:38,840 --> 00:08:44,089
vm e to all the lock and that's a real

00:08:42,200 --> 00:08:46,730
problem and in that case we need to

00:08:44,089 --> 00:08:48,829
we'll use some dummy vme the time we are

00:08:46,730 --> 00:08:50,749
creating the end map just to order log

00:08:48,829 --> 00:08:52,550
and that the me via mail later would be

00:08:50,749 --> 00:08:55,129
converted into DMA but that's just

00:08:52,550 --> 00:08:56,959
filling the fields inside DMA and then

00:08:55,129 --> 00:09:00,589
it's already in the in the tree so

00:08:56,959 --> 00:09:03,350
that's fine and there is also another

00:09:00,589 --> 00:09:06,379
corner case sorry I didn't put in the

00:09:03,350 --> 00:09:11,089
flight well yeah but the case where we

00:09:06,379 --> 00:09:14,269
are on mapping VMAs while doing the

00:09:11,089 --> 00:09:16,309
peachy-keen up we need to prevent any

00:09:14,269 --> 00:09:20,480
other threads who nmap in this area so

00:09:16,309 --> 00:09:23,360
we need some VMAs to be there too all

00:09:20,480 --> 00:09:25,279
the log that will be covering the part

00:09:23,360 --> 00:09:28,749
we are actually cleaning just to be sure

00:09:25,279 --> 00:09:31,519
someone is not making you know back so

00:09:28,749 --> 00:09:35,379
that's some kind of act situation we

00:09:31,519 --> 00:09:38,329
have to address and now the VMA locks

00:09:35,379 --> 00:09:42,709
contagions that's the case when we are

00:09:38,329 --> 00:09:48,439
looking an area that's just bordering is

00:09:42,709 --> 00:09:49,879
just no bellowing I see that just at the

00:09:48,439 --> 00:09:53,509
border of the next VME

00:09:49,879 --> 00:09:56,689
so there is a risk that the two VMAs

00:09:53,509 --> 00:10:01,749
will be merged so we need to lock that

00:09:56,689 --> 00:10:05,600
via me and the subsequent want so that's

00:10:01,749 --> 00:10:13,610
the contention I have some slide that

00:10:05,600 --> 00:10:15,980
will presume that the end map later so

00:10:13,610 --> 00:10:17,959
that's what I just said earlier that we

00:10:15,980 --> 00:10:20,509
need to introduce the Demi VMA when we

00:10:17,959 --> 00:10:22,970
are on mapping area and that we want to

00:10:20,509 --> 00:10:24,529
be sure that's why when the VMA has been

00:10:22,970 --> 00:10:26,509
detached from the tree we want to be

00:10:24,529 --> 00:10:28,759
sure that there is no one putting a new

00:10:26,509 --> 00:10:35,470
vm in this area so we need to put some

00:10:28,759 --> 00:10:41,360
media images toward the lock so that's

00:10:35,470 --> 00:10:44,360
the size so in black is the area we want

00:10:41,360 --> 00:10:50,179
to lock in red is the area we will

00:10:44,360 --> 00:10:52,160
effectively not so interesting case so

00:10:50,179 --> 00:10:53,750
the first case is quite easy to

00:10:52,160 --> 00:10:56,929
understand we are looking some part of

00:10:53,750 --> 00:10:57,590
the VM a1 and so we will extend the log

00:10:56,929 --> 00:10:59,480
to the

00:10:57,590 --> 00:11:00,830
all part of the VMA one because we want

00:10:59,480 --> 00:11:05,860
to be sure that that DNA will not be

00:11:00,830 --> 00:11:08,510
split or whatever and the case too is

00:11:05,860 --> 00:11:10,490
explaining what I was seeing about an

00:11:08,510 --> 00:11:12,620
address that's covering the bordering of

00:11:10,490 --> 00:11:14,810
the next VMA so in that case we are

00:11:12,620 --> 00:11:16,370
looking via me one nvme too because we

00:11:14,810 --> 00:11:18,470
don't want the VNA want to be merged

00:11:16,370 --> 00:11:20,660
with the via me too for example that can

00:11:18,470 --> 00:11:23,690
happen if we're changing the protection

00:11:20,660 --> 00:11:25,550
of the VMA so the VMA one as a redundant

00:11:23,690 --> 00:11:27,800
protection the VMA to have readwrite

00:11:25,550 --> 00:11:29,660
protection so this is an animal's vme

00:11:27,800 --> 00:11:32,930
and so we are changing the part of the V

00:11:29,660 --> 00:11:34,610
I may want to become read white VMI's so

00:11:32,930 --> 00:11:36,920
that's mean that the V me one will split

00:11:34,610 --> 00:11:43,090
in two and it will merge with the via me

00:11:36,920 --> 00:11:45,740
to add V me to will be extended don't in

00:11:43,090 --> 00:11:48,290
to cover the part that V anyone has been

00:11:45,740 --> 00:11:51,440
changed so there is this kind of changes

00:11:48,290 --> 00:11:56,270
that makes the VNA looking very ugly

00:11:51,440 --> 00:11:59,090
sometimes case three is straight for

00:11:56,270 --> 00:12:01,650
what so I will not explain all of them

00:11:59,090 --> 00:12:05,930
so if you have

00:12:01,650 --> 00:12:10,730
any questions I made a mistake the

00:12:05,930 --> 00:12:15,360
number 8 is not correct in that case the

00:12:10,730 --> 00:12:19,310
the the locked area will be there I'm

00:12:15,360 --> 00:12:19,310
gonna give a stake for this one sorry

00:12:22,700 --> 00:12:37,080
any question yeah so this happened in

00:12:34,490 --> 00:12:40,110
some particular case so you have some

00:12:37,080 --> 00:12:42,990
already mapped VMA and you do an EM map

00:12:40,110 --> 00:12:44,910
that's override one part of the vme and

00:12:42,990 --> 00:12:48,000
extending the part of there is that vme

00:12:44,910 --> 00:12:49,920
in that case we lock the wall VMA one

00:12:48,000 --> 00:12:51,390
plus the pot beyond that because we

00:12:49,920 --> 00:12:53,940
don't want someone to put in those of

00:12:51,390 --> 00:12:59,550
yummy in that place so that's why we're

00:12:53,940 --> 00:13:01,800
i standing the locked here so basically

00:12:59,550 --> 00:13:04,560
like the locks will be still in the VMF

00:13:01,800 --> 00:13:06,150
one you will be increasing the range

00:13:04,560 --> 00:13:08,820
yeah yeah absolutely

00:13:06,150 --> 00:13:11,730
we will see that later yeah that's the

00:13:08,820 --> 00:13:14,010
way it's done yeah so that's kind of

00:13:11,730 --> 00:13:15,960
looking is only occurring for the right

00:13:14,010 --> 00:13:18,390
locking on the rear locking you cannot

00:13:15,960 --> 00:13:27,770
lock outside of the VMA boundary because

00:13:18,390 --> 00:13:31,710
that doesn't make sense yeah yeah yeah

00:13:27,770 --> 00:13:34,680
absolutely so that that that's

00:13:31,710 --> 00:13:37,260
completely independent on the way the

00:13:34,680 --> 00:13:39,180
VMA are stored and fetched so we can

00:13:37,260 --> 00:13:44,490
imagine the future that you can rely on

00:13:39,180 --> 00:13:46,920
the maple tree that could provide a lot

00:13:44,490 --> 00:13:48,240
less access to the VME and yum provided

00:13:46,920 --> 00:13:59,820
with you and good protection for that

00:13:48,240 --> 00:14:04,700
yesterday then and locate all these VMs

00:13:59,820 --> 00:14:09,450
unlock them do you believe are between

00:14:04,700 --> 00:14:12,180
look while you look any individual now

00:14:09,450 --> 00:14:14,670
the idea if using the current

00:14:12,180 --> 00:14:15,240
implementation with the Abbey tree and

00:14:14,670 --> 00:14:19,080
the doubling

00:14:15,240 --> 00:14:21,000
list and we rely on the MSM or I can

00:14:19,080 --> 00:14:23,220
introduce a separate lock just to

00:14:21,000 --> 00:14:25,410
protect this VM a arbitrary and this

00:14:23,220 --> 00:14:27,120
list because there is no way to date we

00:14:25,410 --> 00:14:31,200
access this list without taking a lock

00:14:27,120 --> 00:14:33,360
right so but once I fetch all the VMA

00:14:31,200 --> 00:14:34,920
and put the Mach to say that okay this

00:14:33,360 --> 00:14:36,839
VM is locked this game is like whatever

00:14:34,920 --> 00:14:40,740
I can realize this lock and no more it

00:14:36,839 --> 00:14:43,490
because the VM a lot so I don't need

00:14:40,740 --> 00:14:43,490
that lock anymore

00:14:51,320 --> 00:14:57,810
so this is the case where there is no

00:14:53,670 --> 00:14:59,730
thing at the at the time we want to map

00:14:57,810 --> 00:15:01,590
in this area there is no

00:14:59,730 --> 00:15:04,560
already-existing VMA so we will need the

00:15:01,590 --> 00:15:07,110
Jew medium adjust to all the lock by the

00:15:04,560 --> 00:15:09,240
time we will do the processing and once

00:15:07,110 --> 00:15:12,300
the processing is done this GB VMA will

00:15:09,240 --> 00:15:16,500
be converted into the VM III yeah and it

00:15:12,300 --> 00:15:18,870
is just the the demi VM a structure

00:15:16,500 --> 00:15:19,860
itself is used to populate the fields

00:15:18,870 --> 00:15:23,270
correctly and that's all

00:15:19,860 --> 00:15:30,450
so that's straightforward for that place

00:15:23,270 --> 00:15:33,210
and and mapping is painful because that

00:15:30,450 --> 00:15:35,730
in this case it's very simplified there

00:15:33,210 --> 00:15:39,600
is only one VM a covering the mapped

00:15:35,730 --> 00:15:41,190
area so that's quite easy because the we

00:15:39,600 --> 00:15:42,780
can think that the VM e 2 will be

00:15:41,190 --> 00:15:45,030
converted into the media maybe that's

00:15:42,780 --> 00:15:51,480
the case let's imagine that instead of

00:15:45,030 --> 00:15:54,690
having one VM a at in this area we have

00:15:51,480 --> 00:15:57,390
I don't know hundreds of VMAs covering

00:15:54,690 --> 00:16:00,360
the area so when we will do the UM map

00:15:57,390 --> 00:16:04,710
the DNA will be detached from the VM III

00:16:00,360 --> 00:16:06,630
but at the time we are detaching the VM

00:16:04,710 --> 00:16:08,760
a we are inserting a de medium adjust to

00:16:06,630 --> 00:16:10,290
all the log so that's the other threads

00:16:08,760 --> 00:16:13,110
will know that this are realized lot

00:16:10,290 --> 00:16:18,230
during this time so we can do the

00:16:13,110 --> 00:16:18,230
cleanup with the are we are still locked

00:16:25,420 --> 00:16:32,480
when you say you need to lock the wind

00:16:29,120 --> 00:16:34,580
beyond what VMA is covered do you mean

00:16:32,480 --> 00:16:37,940
that you have to actually change the BMA

00:16:34,580 --> 00:16:40,490
to extend the southern address or extend

00:16:37,940 --> 00:16:44,600
the length to cover the whole area doing

00:16:40,490 --> 00:16:46,760
that time so you're doing courtesy well

00:16:44,600 --> 00:16:50,210
the vmh to specify the starting and

00:16:46,760 --> 00:16:52,640
ending address of the wings and when you

00:16:50,210 --> 00:16:54,980
say you have to extend beyond that so

00:16:52,640 --> 00:16:58,000
you actually need to change the southern

00:16:54,980 --> 00:17:02,060
address or the link to extend a way away

00:16:58,000 --> 00:17:04,490
yeah but and then at the end when you

00:17:02,060 --> 00:17:07,300
find out that you don't need you have to

00:17:04,490 --> 00:17:09,620
string it right string it back to

00:17:07,300 --> 00:17:12,850
shrinking shrieking will be the same

00:17:09,620 --> 00:17:15,770
case so we will logged the wall boundary

00:17:12,850 --> 00:17:17,870
the VMA so from the started eyes to the

00:17:15,770 --> 00:17:20,660
NRS of the VNA and women will be shrink

00:17:17,870 --> 00:17:22,880
so the locked pot will remain the same

00:17:20,660 --> 00:17:26,060
we are shrinking the VMA and then we

00:17:22,880 --> 00:17:27,709
unlock the pot I see because when

00:17:26,060 --> 00:17:30,290
shrinking you you will probably and map

00:17:27,709 --> 00:17:33,560
some Peachy in that area that has been

00:17:30,290 --> 00:17:36,350
removed so we don't want another thread

00:17:33,560 --> 00:17:38,450
to map there because we can unmapped the

00:17:36,350 --> 00:17:40,550
B key what just put in place so that's

00:17:38,450 --> 00:17:43,010
some kind of so in the common case do

00:17:40,550 --> 00:17:46,880
you actually string it at the end or

00:17:43,010 --> 00:17:49,130
just leave it is dependent okay

00:17:46,880 --> 00:17:51,620
it's depend of what the operation is

00:17:49,130 --> 00:17:53,660
doing now sometimes the VMA can grow

00:17:51,620 --> 00:17:56,090
some time you can shrink there's a lot

00:17:53,660 --> 00:18:02,020
of VMI operation Don when you are doing

00:17:56,090 --> 00:18:02,020
a map okay thanks

00:18:05,330 --> 00:18:12,200
so this is how the VM airlock structure

00:18:09,139 --> 00:18:14,840
will be put in place this is very high

00:18:12,200 --> 00:18:17,869
level dragon diagram so the idea is not

00:18:14,840 --> 00:18:20,289
to put the lot inside the VM itself but

00:18:17,869 --> 00:18:24,320
should point from the VMA to the lot and

00:18:20,289 --> 00:18:27,259
having only one lock covering multiple

00:18:24,320 --> 00:18:29,450
VMA in that case we have the VM a lock

00:18:27,259 --> 00:18:31,639
one that's covering VME two three and

00:18:29,450 --> 00:18:37,100
four and the VM a lock itself is

00:18:31,639 --> 00:18:40,190
specifying the size of the lot area so

00:18:37,100 --> 00:18:42,109
we need to have the VM a lot separated

00:18:40,190 --> 00:18:43,759
from the VM itself because in the case

00:18:42,109 --> 00:18:46,609
we are splitting the VM a in the case

00:18:43,759 --> 00:18:48,619
were merging the VM a the operation is

00:18:46,609 --> 00:18:50,600
is straightforward the pointer will

00:18:48,619 --> 00:18:52,340
remain the same with fitting a VM a we

00:18:50,600 --> 00:18:59,899
are just duplicating the VM a the VM a

00:18:52,340 --> 00:19:03,409
pointer of the locks remain the same it

00:18:59,899 --> 00:19:06,889
looks within the same VM a so for the

00:19:03,409 --> 00:19:12,379
read locks what I am doing the read

00:19:06,889 --> 00:19:16,309
locks is always covering one VM a I do

00:19:12,379 --> 00:19:17,749
not support the case where we are red

00:19:16,309 --> 00:19:20,450
locking multiple gave me because I

00:19:17,749 --> 00:19:23,570
didn't find a situation where this will

00:19:20,450 --> 00:19:26,899
be useful maybe I maybe I'm missing

00:19:23,570 --> 00:19:28,149
something but recharge page for

00:19:26,899 --> 00:19:31,009
discovering one V V

00:19:28,149 --> 00:19:33,649
yeah but you can have multiple page hold

00:19:31,009 --> 00:19:36,649
multiple switch 14 pages in the same big

00:19:33,649 --> 00:19:38,840
absolutely yeah so in that case what I

00:19:36,649 --> 00:19:40,730
am doing so there is one thing that is

00:19:38,840 --> 00:19:45,470
part of the VM switcher is a number of

00:19:40,730 --> 00:19:47,299
reader that's are looking that VM a so

00:19:45,470 --> 00:19:49,999
inside the VMS structure there is a one

00:19:47,299 --> 00:19:52,100
at emit pointer anatomic value that is

00:19:49,999 --> 00:19:55,970
used to store the number of readers that

00:19:52,100 --> 00:19:58,730
are looking that beaming and when the

00:19:55,970 --> 00:20:01,519
reader is greater than 1 is greater than

00:19:58,730 --> 00:20:04,609
0 sorry that mean that's right I cannot

00:20:01,519 --> 00:20:06,379
lock it so you just keep the same lock

00:20:04,609 --> 00:20:09,590
shook to off for multiple videos in that

00:20:06,379 --> 00:20:12,499
case in that case there is no lock

00:20:09,590 --> 00:20:14,990
structure for the readers because there

00:20:12,499 --> 00:20:16,609
is there is no need for that if there is

00:20:14,990 --> 00:20:18,770
a reader it's just incrementing the

00:20:16,609 --> 00:20:21,380
reader point the reader counter for the

00:20:18,770 --> 00:20:23,320
vieni so there is no lock needed just

00:20:21,380 --> 00:20:27,050
increment in this network atomic values

00:20:23,320 --> 00:20:28,760
that's okay he's now a writer want to

00:20:27,050 --> 00:20:31,100
lock that VMA where there is already

00:20:28,760 --> 00:20:35,480
readers it would create the VMA lock

00:20:31,100 --> 00:20:36,680
operation and it will wait wait.you that

00:20:35,480 --> 00:20:40,040
is part of this Via Media Corporation

00:20:36,680 --> 00:20:42,230
for all the readers to reads it and once

00:20:40,040 --> 00:20:44,090
the last reader exit it will wake up the

00:20:42,230 --> 00:20:47,600
writer if there is out of the reader

00:20:44,090 --> 00:20:50,000
that come at the time it will increase

00:20:47,600 --> 00:20:53,720
and it will wake on the reader wake you

00:20:50,000 --> 00:20:55,160
on the VMA lock so the next video will

00:20:53,720 --> 00:20:57,650
wait for the writer to appear right

00:20:55,160 --> 00:21:00,410
before going forward and once they were

00:20:57,650 --> 00:21:03,050
there they would walk up since the

00:21:00,410 --> 00:21:06,410
writer may have been clean the VMA near

00:21:03,050 --> 00:21:12,800
back you have to refresh the VMA from

00:21:06,410 --> 00:21:16,910
the beginning the ad so what about in

00:21:12,800 --> 00:21:19,490
the proc Pierre mmm mmm file with the

00:21:16,910 --> 00:21:22,910
the locking just sequentially walk

00:21:19,490 --> 00:21:25,070
through every VMA then take yeah that's

00:21:22,910 --> 00:21:27,740
the problem when you when we are working

00:21:25,070 --> 00:21:30,950
the VM III that's what you mean yes my

00:21:27,740 --> 00:21:33,650
point here is that we are right read

00:21:30,950 --> 00:21:36,110
looking one via me and then we need to

00:21:33,650 --> 00:21:38,900
restart fetching the next VM a from the

00:21:36,110 --> 00:21:41,030
end of the last vm e address because we

00:21:38,900 --> 00:21:43,250
don't know is that vm a once we will

00:21:41,030 --> 00:21:45,110
release that lock we don't know is that

00:21:43,250 --> 00:21:49,640
the Army is still there so with the next

00:21:45,110 --> 00:21:51,530
maybe garbage so the thing that we have

00:21:49,640 --> 00:21:54,290
the and address of the last vm a who

00:21:51,530 --> 00:21:57,470
have processing so we can we fetch from

00:21:54,290 --> 00:22:00,110
the and to fetch the next viene yeah

00:21:57,470 --> 00:22:03,980
from the tree okay but then you might

00:22:00,110 --> 00:22:05,690
actually land in the middle of a VM a no

00:22:03,980 --> 00:22:08,300
because you are looking the VM e itself

00:22:05,690 --> 00:22:09,680
but you've locked it you remove the lock

00:22:08,300 --> 00:22:11,660
you start from the beginning from the

00:22:09,680 --> 00:22:13,190
end yeah when you start from the

00:22:11,660 --> 00:22:15,740
beginning you're looking for the next VM

00:22:13,190 --> 00:22:17,750
a if you when you remove your real I do

00:22:15,740 --> 00:22:19,220
it right or me every mess yes that may

00:22:17,750 --> 00:22:21,440
be incorrect okay

00:22:19,220 --> 00:22:23,360
that's a problem you're right yeah but

00:22:21,440 --> 00:22:27,530
probably that's working the VM in the

00:22:23,360 --> 00:22:30,919
read mode I'm assuming that's this base

00:22:27,530 --> 00:22:34,340
default who have to provide there so

00:22:30,919 --> 00:22:36,679
that's IIIi don't find I don't know part

00:22:34,340 --> 00:22:38,840
of the codes that needs to work the tree

00:22:36,679 --> 00:22:41,899
and to be sure that we have all the

00:22:38,840 --> 00:22:43,909
values of the trees even today the proc

00:22:41,899 --> 00:22:44,739
VMware Maps can provide wrong

00:22:43,909 --> 00:22:47,509
information

00:22:44,739 --> 00:22:51,460
well it's but it's complete wrong

00:22:47,509 --> 00:22:51,460
information right it's either old or new

00:22:52,029 --> 00:23:00,049
no I don't think so because I think that

00:22:56,450 --> 00:23:02,389
when writing to the such needs to be

00:23:00,049 --> 00:23:03,859
double checked but I see that's when we

00:23:02,389 --> 00:23:06,950
are writing to the proc file we are

00:23:03,859 --> 00:23:13,999
always in the MSM okay

00:23:06,950 --> 00:23:15,559
I think so okay I'm not sure of that so

00:23:13,999 --> 00:23:17,600
that is to be double shades I know to be

00:23:15,559 --> 00:23:19,429
honest but that's who that can be that

00:23:17,600 --> 00:23:23,029
can be an issue so maybe in that case

00:23:19,429 --> 00:23:25,639
having the growingdeer locked from the

00:23:23,029 --> 00:23:27,859
complete three will help but that's not

00:23:25,639 --> 00:23:31,549
something I do like yeah no me neither

00:23:27,859 --> 00:23:33,919
so I to be III don't have a kiss

00:23:31,549 --> 00:23:37,549
answer for that maybe one option could

00:23:33,919 --> 00:23:39,440
be to write log do you miss that's a

00:23:37,549 --> 00:23:42,649
nightmare - yeah take the right lock

00:23:39,440 --> 00:23:50,590
just walked into your back to the same

00:23:42,649 --> 00:23:54,759
room okay let's quit that good point

00:23:50,590 --> 00:23:57,909
yeah I need to work more on that yeah

00:23:54,759 --> 00:24:01,909
but I put that limitation to have a new

00:23:57,909 --> 00:24:07,149
one va mean we look for thread because

00:24:01,909 --> 00:24:07,149
that's simplifying a lot the operation

00:24:07,779 --> 00:24:18,739
are speaking about reference countin do

00:24:14,149 --> 00:24:22,369
you can you comprehend how hot can it be

00:24:18,739 --> 00:24:27,830
because you know I know software that

00:24:22,369 --> 00:24:31,549
does a lot of memory attribute changing

00:24:27,830 --> 00:24:36,770
from many threads and in in in past it

00:24:31,549 --> 00:24:39,320
was very efficient because how Linux

00:24:36,770 --> 00:24:42,400
memory management was implemented so I

00:24:39,320 --> 00:24:45,290
just want to mention that if this

00:24:42,400 --> 00:24:48,890
referring reference counter will be very

00:24:45,290 --> 00:24:50,660
hot like we'll see a lot of performance

00:24:48,890 --> 00:24:55,070
degradation on a watch system especially

00:24:50,660 --> 00:24:58,190
Numa ones so you say that's today with

00:24:55,070 --> 00:25:01,910
DMF sam changing a lot of vme attributes

00:24:58,190 --> 00:25:03,710
is something that's going faster yeah so

00:25:01,910 --> 00:25:07,610
I'm speaking specifically about still

00:25:03,710 --> 00:25:09,770
burn Common Lisp so it they implemented

00:25:07,610 --> 00:25:11,690
garbage collector in a very special way

00:25:09,770 --> 00:25:14,260
because a linux memory management

00:25:11,690 --> 00:25:18,080
allowed them to change change which

00:25:14,260 --> 00:25:20,660
attribute like in fifteen hundred

00:25:18,080 --> 00:25:27,280
microseconds which is you know very fast

00:25:20,660 --> 00:25:29,630
for such thing and I think that if we do

00:25:27,280 --> 00:25:33,380
changes like reference count and we may

00:25:29,630 --> 00:25:36,620
regress such situations the reference

00:25:33,380 --> 00:25:38,300
culture I mean I mean by introducing

00:25:36,620 --> 00:25:41,120
reference counter which is atomic

00:25:38,300 --> 00:25:44,150
operation if you bound in same

00:25:41,120 --> 00:25:46,820
VM way from mini-course which sit across

00:25:44,150 --> 00:25:50,720
normal boundaries you'll be saturating

00:25:46,820 --> 00:25:55,010
qpi link so this needs to be checked

00:25:50,720 --> 00:25:57,890
carefully yeah some cases that will not

00:25:55,010 --> 00:25:59,570
be so efficient probably yeah but in

00:25:57,890 --> 00:26:01,640
that particular case I think that's

00:25:59,570 --> 00:26:03,920
today when you are changing and VM and

00:26:01,640 --> 00:26:08,320
from which you have to grab the MSM yeah

00:26:03,920 --> 00:26:13,160
there is a lot of contention when couple

00:26:08,320 --> 00:26:17,150
yes so that's that's all surprised today

00:26:13,160 --> 00:26:20,360
it got much worse and previous couple of

00:26:17,150 --> 00:26:23,300
years we know why but before that it was

00:26:20,360 --> 00:26:25,310
very efficient I was amazed I cannot see

00:26:23,300 --> 00:26:27,350
how it can be efficient today to be

00:26:25,310 --> 00:26:30,890
honest if you have thousands of threads

00:26:27,350 --> 00:26:33,050
that changing is some VM a attributes in

00:26:30,890 --> 00:26:37,660
parallel they are authorized

00:26:33,050 --> 00:26:39,900
today yeah because of that map same yeah

00:26:37,660 --> 00:26:43,820
so that that's

00:26:39,900 --> 00:26:46,020
it's always a trade-off that's

00:26:43,820 --> 00:26:51,240
unfortunately that's it's very difficult

00:26:46,020 --> 00:26:58,790
to add to all the the cases we can see

00:26:51,240 --> 00:27:01,320
that's crazy so maybe there is some I

00:26:58,790 --> 00:27:03,960
especially sings about the mono studied

00:27:01,320 --> 00:27:06,090
processes well the impact should be

00:27:03,960 --> 00:27:09,270
lower than the maximum but from which is

00:27:06,090 --> 00:27:11,940
read process if you have this kind of

00:27:09,270 --> 00:27:14,970
lock range lock whatever it is

00:27:11,940 --> 00:27:26,510
implementation that should be faster

00:27:14,970 --> 00:27:26,510
than today but we have to see of course

00:27:29,390 --> 00:27:33,900
so my opinion switching VMA already

00:27:31,950 --> 00:27:35,670
talked about that it's straightforward

00:27:33,900 --> 00:27:40,010
in that case because the pointer that

00:27:35,670 --> 00:27:42,690
went into the lot is it's just

00:27:40,010 --> 00:27:47,910
duplicated so there is nothing else to

00:27:42,690 --> 00:27:50,070
introduce and AVMA that is read lot

00:27:47,910 --> 00:27:58,620
cannot be managed or split so it's never

00:27:50,070 --> 00:28:01,590
happened and so losing a special to

00:27:58,620 --> 00:28:04,530
report and the match should only happen

00:28:01,590 --> 00:28:13,890
on VMI's that allowed by the same thread

00:28:04,530 --> 00:28:19,080
otherwise is cameo by the gate and map

00:28:13,890 --> 00:28:20,940
area that's an interesting case I told

00:28:19,080 --> 00:28:22,740
you the 'introduction that this is

00:28:20,940 --> 00:28:25,370
something that needs to be fast and

00:28:22,740 --> 00:28:30,240
efficient so we need to find a gap very

00:28:25,370 --> 00:28:34,800
easily and today the implementation I

00:28:30,240 --> 00:28:37,770
made is able to find a gap so it's using

00:28:34,800 --> 00:28:41,520
the usual way were using today that's in

00:28:37,770 --> 00:28:43,830
their arbitrary finding gap and when we

00:28:41,520 --> 00:28:48,120
are finding a gap we have the previously

00:28:43,830 --> 00:28:50,640
I mean the names VMA if there is and in

00:28:48,120 --> 00:28:53,430
that case we can just simply check if

00:28:50,640 --> 00:28:55,350
that get me is all via me a lot

00:28:53,430 --> 00:28:58,680
and remove the locked area from the

00:28:55,350 --> 00:29:01,710
available gap if it is not large enough

00:28:58,680 --> 00:29:04,500
we can go forward just remember this one

00:29:01,710 --> 00:29:07,650
because it would be a fullback situation

00:29:04,500 --> 00:29:11,130
and we can use that so there is no

00:29:07,650 --> 00:29:14,340
change in the existing geometry there is

00:29:11,130 --> 00:29:17,550
just fetching two pointer in addition

00:29:14,340 --> 00:29:19,170
just to verify that the lot area so it's

00:29:17,550 --> 00:29:21,600
still efficient and he's already done

00:29:19,170 --> 00:29:23,910
today because there is the VMI's gap

00:29:21,600 --> 00:29:30,600
that ticking in mind especially if this

00:29:23,910 --> 00:29:33,360
is for the VMA for the stack or VMA can

00:29:30,600 --> 00:29:35,760
go in growing you / or don't on world

00:29:33,360 --> 00:29:38,460
and there is the VMI's gap that's

00:29:35,760 --> 00:29:41,910
already taken account in the process to

00:29:38,460 --> 00:29:45,300
ensure that the freer we are will be

00:29:41,910 --> 00:29:51,360
large enough but not change to the air

00:29:45,300 --> 00:29:57,150
to these spots and in the case the there

00:29:51,360 --> 00:29:59,940
is no anus area free area available the

00:29:57,150 --> 00:30:04,170
option is to reach an the largest gap we

00:29:59,940 --> 00:30:05,760
was found but we which was lot by some

00:30:04,170 --> 00:30:09,090
of those threads and in that case the

00:30:05,760 --> 00:30:12,270
Kuro in the process will wait for this

00:30:09,090 --> 00:30:15,420
area to be come freed to going forward

00:30:12,270 --> 00:30:18,330
and maybe reef etched the new area if

00:30:15,420 --> 00:30:21,570
this area has been allocated by its

00:30:18,330 --> 00:30:23,280
readiness back so that's the same

00:30:21,570 --> 00:30:26,330
situation you are covering Michelle

00:30:23,280 --> 00:30:30,810
except that you have to fetch with the

00:30:26,330 --> 00:30:34,730
VMA trees lot to find the boundaries of

00:30:30,810 --> 00:30:34,730
the gap available gap

00:30:35,620 --> 00:30:43,029
Oh where is the microphone sorry yeah

00:30:40,870 --> 00:30:47,460
you were to ask a question sorry I miss

00:30:43,029 --> 00:30:51,370
you if I find the community space I add

00:30:47,460 --> 00:30:55,620
dummy VMA in there so that I it won't

00:30:51,370 --> 00:31:00,039
get the space I want it won't get

00:30:55,620 --> 00:31:11,860
allocated what I'm waiting to get my so

00:31:00,039 --> 00:31:14,169
introduced Jimmy VMA for that yes so you

00:31:11,860 --> 00:31:16,899
actually had to lay over locking you

00:31:14,169 --> 00:31:18,850
have a lock for the ugly tree to make

00:31:16,899 --> 00:31:22,510
sure that it stay consistent and then

00:31:18,850 --> 00:31:24,190
each of the VMA you have a law so there

00:31:22,510 --> 00:31:28,419
will be very situation that you have to

00:31:24,190 --> 00:31:31,120
take to lock together and then release

00:31:28,419 --> 00:31:32,890
one knot and keep the other one have you

00:31:31,120 --> 00:31:35,710
met all the different cases to make sure

00:31:32,890 --> 00:31:38,260
that there is no teller not fight for

00:31:35,710 --> 00:31:41,370
that but the idea is that if I example

00:31:38,260 --> 00:31:44,110
when you're cutting to get on map area

00:31:41,370 --> 00:31:46,270
clearly to get on map area needs to walk

00:31:44,110 --> 00:31:49,559
the tree so I need to grab the log for

00:31:46,270 --> 00:31:52,870
the tree but once you find the area and

00:31:49,559 --> 00:31:56,529
that area has been loved there is no

00:31:52,870 --> 00:31:58,090
more need for the geometry locked yes

00:31:56,529 --> 00:32:02,380
but then when we need to make

00:31:58,090 --> 00:32:11,830
modification you have to wait lock the

00:32:02,380 --> 00:32:15,610
up each field sure again and so certain

00:32:11,830 --> 00:32:19,659
case it may be to tell ox oh you're

00:32:15,610 --> 00:32:21,539
right that's needs to be taken so I just

00:32:19,659 --> 00:32:24,130
want to make sure that you email all the

00:32:21,539 --> 00:32:27,100
possible locking sequences to make sure

00:32:24,130 --> 00:32:28,299
that you you won't cause any tell oh

00:32:27,100 --> 00:32:35,169
yeah you're right

00:32:28,299 --> 00:32:37,899
that's this to be sorry that that's

00:32:35,169 --> 00:32:40,679
that's pain and but that's depending on

00:32:37,899 --> 00:32:43,210
the way the be trees protected if it is

00:32:40,679 --> 00:32:46,240
there is some low class operation that

00:32:43,210 --> 00:32:49,679
can be done there that will be can you

00:32:46,240 --> 00:32:53,230
go back to slides to before the one one

00:32:49,679 --> 00:32:56,770
you help me yeah yeah somewhere in here

00:32:53,230 --> 00:32:58,000
so it seems to me I might not understand

00:32:56,770 --> 00:33:00,580
this exactly right but it seems to me

00:32:58,000 --> 00:33:02,700
that you are synthesizing a lock on the

00:33:00,580 --> 00:33:06,280
fly is it right

00:33:02,700 --> 00:33:08,169
via a female one is a new lock that

00:33:06,280 --> 00:33:10,720
wasn't there before you decided to do

00:33:08,169 --> 00:33:14,530
this particular operation right yeah

00:33:10,720 --> 00:33:16,929
okay so in that case you've got to in

00:33:14,530 --> 00:33:19,240
you've got to modify the lock pointer in

00:33:16,929 --> 00:33:19,780
three VMAs you may to view may 3 view me

00:33:19,240 --> 00:33:22,240
yeah right

00:33:19,780 --> 00:33:25,120
which means in order to do that you have

00:33:22,240 --> 00:33:27,580
to do something that is multi thread

00:33:25,120 --> 00:33:29,290
safe yeah right so it seems that you've

00:33:27,580 --> 00:33:32,740
moved the locking problem out so now you

00:33:29,290 --> 00:33:36,940
need a lock to protect the fact that

00:33:32,740 --> 00:33:37,360
you're inserting a lock pointer yes yes

00:33:36,940 --> 00:33:40,210
I know

00:33:37,360 --> 00:33:43,150
indeed what what I'm doing first I will

00:33:40,210 --> 00:33:46,390
lock the via me to because the first VMA

00:33:43,150 --> 00:33:48,390
I will fetch is via me too because it's

00:33:46,390 --> 00:33:52,090
close all the boundaries is via me too

00:33:48,390 --> 00:33:55,960
okay so I got the VM they are we

00:33:52,090 --> 00:33:58,330
lock to do that or if there is some low

00:33:55,960 --> 00:33:59,860
class operation to fetch the VNA that

00:33:58,330 --> 00:34:04,150
would be fine but not today

00:33:59,860 --> 00:34:07,780
so fetching the VM a to allocating the

00:34:04,150 --> 00:34:09,909
VNA locked and pointing the VM a log to

00:34:07,780 --> 00:34:12,879
the VM e to that's something that's we

00:34:09,909 --> 00:34:14,710
needs to be one atomy corporation which

00:34:12,879 --> 00:34:16,000
means it needs to be protected by a lock

00:34:14,710 --> 00:34:18,790
because you have to do all those things

00:34:16,000 --> 00:34:21,040
and then switching the VM is which lets

00:34:18,790 --> 00:34:23,200
retains that operation sorry which lock

00:34:21,040 --> 00:34:24,190
protects that operation yeah

00:34:23,200 --> 00:34:26,590
reopen yeah

00:34:24,190 --> 00:34:31,899
there is the rb3 but I introduced one

00:34:26,590 --> 00:34:34,240
lock just for creating the linked from

00:34:31,899 --> 00:34:36,369
the VM a to the VM a lock okay I use

00:34:34,240 --> 00:34:37,690
that but that only the writer that's it

00:34:36,369 --> 00:34:39,909
does feel a little like we've just kind

00:34:37,690 --> 00:34:42,310
of shoved the locking problem further

00:34:39,909 --> 00:34:44,980
yeah you're right you right

00:34:42,310 --> 00:34:47,710
yeah but yes that's that's needed but I

00:34:44,980 --> 00:34:50,200
think that also can be done on there

00:34:47,710 --> 00:34:52,960
some seu protection because it's just

00:34:50,200 --> 00:34:55,810
the companions and copia and and and

00:34:52,960 --> 00:34:59,190
load operation copy and write operation

00:34:55,810 --> 00:35:02,190
that's not something that's needs to be

00:34:59,190 --> 00:35:04,289
a real lock indeed because we can fetch

00:35:02,190 --> 00:35:06,059
the VMA and just if if there is the

00:35:04,289 --> 00:35:08,970
pointer to the VM ellic operation is new

00:35:06,059 --> 00:35:11,970
that means there is no writer so just a

00:35:08,970 --> 00:35:23,099
compare and store operation is too meek

00:35:11,970 --> 00:35:24,930
that's enough for doing that no but

00:35:23,099 --> 00:35:30,089
that's the implementation details any

00:35:24,930 --> 00:35:34,319
rights that needs to be group or IDs for

00:35:30,089 --> 00:35:37,769
me is to go in straight put some lock to

00:35:34,319 --> 00:35:40,380
protect that but later I'm pretty sure I

00:35:37,769 --> 00:35:46,549
can remove that lock and do something

00:35:40,380 --> 00:35:49,549
that's more like luckless Lee to do that

00:35:46,549 --> 00:35:49,549
that's

00:35:55,760 --> 00:36:02,360
the full and the full solution to to not

00:35:59,990 --> 00:36:04,730
having that lock is probably actually

00:36:02,360 --> 00:36:07,790
the data structure that holds all the

00:36:04,730 --> 00:36:10,550
VMAs in its of itself if if you have

00:36:07,790 --> 00:36:13,430
each node if you're considering VMA one

00:36:10,550 --> 00:36:16,460
two two three and four as independent

00:36:13,430 --> 00:36:17,720
and you have to lock each one to add the

00:36:16,460 --> 00:36:19,910
portions then yes you would need

00:36:17,720 --> 00:36:23,240
multiple locks but if there is something

00:36:19,910 --> 00:36:25,460
above that that to get to these VMAs you

00:36:23,240 --> 00:36:27,940
would need and you and you lock that

00:36:25,460 --> 00:36:34,940
then that lock already exists and you

00:36:27,940 --> 00:36:36,320
remove a problem yeah that's it's

00:36:34,940 --> 00:37:03,710
because this is a layout of the VMAs

00:36:36,320 --> 00:37:05,900
yeah so just couple words about the kind

00:37:03,710 --> 00:37:08,270
of hazards we have to face I mean is the

00:37:05,900 --> 00:37:10,370
same for for Michelle varies a lot of

00:37:08,270 --> 00:37:12,950
places in the kernel that have implicit

00:37:10,370 --> 00:37:15,050
dependency on the mmm you know they

00:37:12,950 --> 00:37:16,160
don't and if you don't necessarily Val

00:37:15,050 --> 00:37:17,900
have a comment about it you know

00:37:16,160 --> 00:37:20,570
sometimes it's somebody that say oh

00:37:17,900 --> 00:37:22,460
actually this race cares won't happen

00:37:20,570 --> 00:37:25,310
because I'm holding the maps I mean read

00:37:22,460 --> 00:37:27,260
more or PM f7 is L in write mode and and

00:37:25,310 --> 00:37:29,300
so it depend on the fact that the map

00:37:27,260 --> 00:37:34,070
semaphore is actually held in some way

00:37:29,300 --> 00:37:37,040
or the others and yeah so the sad state

00:37:34,070 --> 00:37:39,440
of affairs really that we have to audit

00:37:37,040 --> 00:37:41,000
every device driver in every file system

00:37:39,440 --> 00:37:42,500
also file system have been clean up

00:37:41,000 --> 00:37:44,720
mostly so I think at this point in time

00:37:42,500 --> 00:37:48,170
really it should be safe but you know

00:37:44,720 --> 00:37:51,230
it's better to take another deep look

00:37:48,170 --> 00:37:54,080
into it to make sure that you know there

00:37:51,230 --> 00:37:57,110
is no no no implicit dependence East so

00:37:54,080 --> 00:37:59,660
creeping inside them there might also be

00:37:57,110 --> 00:38:02,510
bug years of space application that a

00:37:59,660 --> 00:38:04,670
lot of Sherlock works because of the map

00:38:02,510 --> 00:38:05,790
semaphore you know some application

00:38:04,670 --> 00:38:07,650
doing em on

00:38:05,790 --> 00:38:08,910
or a map and I think multiple tried

00:38:07,650 --> 00:38:11,730
running the same time and it's just

00:38:08,910 --> 00:38:14,880
working because thanks to the exclusion

00:38:11,730 --> 00:38:18,450
of memory semaphore there is no issue

00:38:14,880 --> 00:38:20,070
between two threads you know this kind

00:38:18,450 --> 00:38:22,440
of application is obviously buggy from

00:38:20,070 --> 00:38:23,970
you know they were because the way the

00:38:22,440 --> 00:38:26,190
new scanner works today so it's an

00:38:23,970 --> 00:38:27,690
artifact for them to be working so I

00:38:26,190 --> 00:38:29,520
don't know if we should be worrying

00:38:27,690 --> 00:38:31,980
about them and like you know trying to

00:38:29,520 --> 00:38:35,190
make sure we don't break them or if we

00:38:31,980 --> 00:38:39,750
should you know go ahead and and have

00:38:35,190 --> 00:38:41,580
them take photo seek bus and then you

00:38:39,750 --> 00:38:44,400
know we can see why they actually doing

00:38:41,580 --> 00:38:47,760
something buggy and then various bunch

00:38:44,400 --> 00:38:50,700
also of kernel specific particular code

00:38:47,760 --> 00:38:52,590
or puke pages so some are stick you are

00:38:50,700 --> 00:38:55,350
doing stuff for instance when you have

00:38:52,590 --> 00:38:57,180
data cage and instruction gates are

00:38:55,350 --> 00:39:00,990
different beyond some CPU architecture

00:38:57,180 --> 00:39:02,880
or poor PC that is doing things with

00:39:00,990 --> 00:39:05,940
segment size and all that cough stuff

00:39:02,880 --> 00:39:08,160
we're talking today so you know there is

00:39:05,940 --> 00:39:10,380
many places we need to look into deeply

00:39:08,160 --> 00:39:12,900
to make sure that we are not gonna break

00:39:10,380 --> 00:39:14,310
them and that we can move like the best

00:39:12,900 --> 00:39:16,080
thing we want to do really is to move

00:39:14,310 --> 00:39:18,360
them away from depending on their Maps

00:39:16,080 --> 00:39:20,010
em and move them to their own locking

00:39:18,360 --> 00:39:21,660
because you know when it's the device

00:39:20,010 --> 00:39:24,030
wherever the writer should be relying on

00:39:21,660 --> 00:39:26,340
its own data structure and its own

00:39:24,030 --> 00:39:29,430
locking instead of rolling implicitly on

00:39:26,340 --> 00:39:31,200
a map semaphore and same thing for

00:39:29,430 --> 00:39:34,620
architecture Quebec you want to move

00:39:31,200 --> 00:39:39,510
them away as much as possible from be a

00:39:34,620 --> 00:39:41,730
map semaphore and sample file system so

00:39:39,510 --> 00:39:44,550
the plan really you know the battle plan

00:39:41,730 --> 00:39:46,920
is kind of a first keep em up semaphore

00:39:44,550 --> 00:39:50,010
as is you know as a patch edges

00:39:46,920 --> 00:39:52,020
constricted basically then intrusive in

00:39:50,010 --> 00:39:53,610
you locking mechanism inside the core

00:39:52,020 --> 00:39:56,160
mmm code basically so you know you do

00:39:53,610 --> 00:39:59,070
all the modification for the old the

00:39:56,160 --> 00:40:00,480
core kernel memory management and at

00:39:59,070 --> 00:40:01,710
this time you don't have any kind of

00:40:00,480 --> 00:40:03,330
concurrency because you're still holding

00:40:01,710 --> 00:40:04,860
the a map semaphore exactly as it is

00:40:03,330 --> 00:40:06,960
today so you know everything works as it

00:40:04,860 --> 00:40:09,180
today it's just that a structure inside

00:40:06,960 --> 00:40:13,590
the government are being modified and

00:40:09,180 --> 00:40:17,460
updated owns we got the core mm cut done

00:40:13,590 --> 00:40:18,599
we can then use it we can start testing

00:40:17,460 --> 00:40:20,489
things

00:40:18,599 --> 00:40:23,099
simply you know saying well for that

00:40:20,489 --> 00:40:25,140
process I won't actually to no longer

00:40:23,099 --> 00:40:27,239
use VM apps em and being voted as the

00:40:25,140 --> 00:40:28,950
concurrency and see if my quad-core mm

00:40:27,239 --> 00:40:32,789
code works and you know you can isolate

00:40:28,950 --> 00:40:34,650
a process that also use or don't evilly

00:40:32,789 --> 00:40:35,849
rely on file system were specific device

00:40:34,650 --> 00:40:37,979
driver so you know I have you know the

00:40:35,849 --> 00:40:42,150
as out of device driver and file system

00:40:37,979 --> 00:40:45,660
being maybe being buggy and introducing

00:40:42,150 --> 00:40:47,819
bug so that would be the first part and

00:40:45,660 --> 00:40:50,549
obviously then the next part is to

00:40:47,819 --> 00:40:52,529
convert every particular code every file

00:40:50,549 --> 00:40:56,039
system every device driver and make sure

00:40:52,529 --> 00:40:58,229
that all the core code inside a canal is

00:40:56,039 --> 00:41:00,930
well aware about the change is happening

00:40:58,229 --> 00:41:02,519
and that isn't very long no longer any

00:41:00,930 --> 00:41:04,019
kind of implicit dependency on the IMAP

00:41:02,519 --> 00:41:08,339
semaphore and everything is explicit

00:41:04,019 --> 00:41:11,369
everywhere and finally you know remove

00:41:08,339 --> 00:41:16,470
via map semaphore and that would be

00:41:11,369 --> 00:41:19,680
really a step so that's that's what we

00:41:16,470 --> 00:41:21,680
have early I don't know if people have

00:41:19,680 --> 00:41:25,200
more questions

00:41:21,680 --> 00:41:28,440
not a question more come out like so you

00:41:25,200 --> 00:41:30,509
have that plan I have a plan we have two

00:41:28,440 --> 00:41:32,069
plans like we haven't really converted I

00:41:30,509 --> 00:41:34,319
just want to be explicit about that

00:41:32,069 --> 00:41:36,269
because maybe it's not clear to everyone

00:41:34,319 --> 00:41:45,930
and when I say I don't have an answer to

00:41:36,269 --> 00:41:49,049
it yet but I just so I think you know I

00:41:45,930 --> 00:41:51,119
think the so this year I think we never

00:41:49,049 --> 00:41:52,619
convinced that or approaches better as

00:41:51,119 --> 00:41:55,650
initial or Mishler process better than

00:41:52,619 --> 00:41:57,059
us and I think the good thing here is

00:41:55,650 --> 00:41:58,650
that you know you you can have a bad

00:41:57,059 --> 00:42:00,119
Chet we can have a patch set and then

00:41:58,650 --> 00:42:02,489
people can start looking at the patches

00:42:00,119 --> 00:42:04,140
and see what will they like more so you

00:42:02,489 --> 00:42:05,430
know they can look at for me i level

00:42:04,140 --> 00:42:06,599
point of view you know because if you

00:42:05,430 --> 00:42:07,859
approach from my level point of view is

00:42:06,599 --> 00:42:10,410
different between what we do and what

00:42:07,859 --> 00:42:11,579
you do so people can judge on the high

00:42:10,410 --> 00:42:14,849
level point of view and then we can also

00:42:11,579 --> 00:42:17,999
judge on what the implementation on that

00:42:14,849 --> 00:42:19,799
to look like and I believe you know it's

00:42:17,999 --> 00:42:21,960
something that we'll need to have enough

00:42:19,799 --> 00:42:23,700
consensus inside the kernel community to

00:42:21,960 --> 00:42:25,920
be able to move forward because this is

00:42:23,700 --> 00:42:27,749
a really daunting task and it's also

00:42:25,920 --> 00:42:29,430
really you know scary to change

00:42:27,749 --> 00:42:31,140
something because it's it's like the a

00:42:29,430 --> 00:42:32,579
map simmer for screwing

00:42:31,140 --> 00:42:34,529
basically means you're gonna screw the

00:42:32,579 --> 00:42:50,549
whole caramel everybody like nothing

00:42:34,529 --> 00:42:52,469
will work again yeah yeah very much we

00:42:50,549 --> 00:42:55,950
can do together like no driver file

00:42:52,469 --> 00:42:57,959
system or eating older and converting

00:42:55,950 --> 00:42:59,700
all the play set to take the mmm - oh

00:42:57,959 --> 00:43:01,319
come on a helper function no like you

00:42:59,700 --> 00:43:03,479
know various things we can share Diwali

00:43:01,319 --> 00:43:04,979
and we can even just probably start to

00:43:03,479 --> 00:43:07,349
push upstream because we are clean up

00:43:04,979 --> 00:43:08,519
mostly and adding commands in and you

00:43:07,349 --> 00:43:10,469
know saying all this driver is

00:43:08,519 --> 00:43:11,910
implicitly depending on VM apps and so

00:43:10,469 --> 00:43:15,269
on and so forth over each thing we can

00:43:11,910 --> 00:43:18,630
work on on there are like that we agreed

00:43:15,269 --> 00:43:31,069
if we need to happen and share the code

00:43:18,630 --> 00:43:33,359
for that situation for that one of the

00:43:31,069 --> 00:43:35,009
little advantage for this solution is

00:43:33,359 --> 00:43:37,920
that during the page full pass there is

00:43:35,009 --> 00:43:39,839
no need to grab a rock because if we

00:43:37,920 --> 00:43:41,640
have some way to fetch the VM a lock

00:43:39,839 --> 00:43:44,219
Leslie thanks to the maple tree for

00:43:41,640 --> 00:43:48,209
instance then we just need to increment

00:43:44,219 --> 00:43:52,440
a controller to grab the red lock for

00:43:48,209 --> 00:43:54,410
the DNA and that's enough and at the

00:43:52,440 --> 00:43:58,400
time the VM is locked so there is no

00:43:54,410 --> 00:43:58,400
contention during the page fault

00:44:01,040 --> 00:44:06,630
that still you look we seen that VMA

00:44:03,720 --> 00:44:08,130
structure but that's not inside the VM a

00:44:06,630 --> 00:44:12,990
structure for the readers that just are

00:44:08,130 --> 00:44:18,840
contrary increment to increment in an

00:44:12,990 --> 00:44:20,910
atomic way I could add look sure yeah

00:44:18,840 --> 00:44:24,150
that's an atomic so that's that there is

00:44:20,910 --> 00:44:26,910
some some synchronization caching

00:44:24,150 --> 00:44:29,700
transition to be done I wish but in the

00:44:26,910 --> 00:44:34,800
K is the same vmas used by separate

00:44:29,700 --> 00:44:38,490
threads but that's that's not not not

00:44:34,800 --> 00:44:41,220
this is only the case so what kind know

00:44:38,490 --> 00:44:48,320
are you implement are you put inside the

00:44:41,220 --> 00:44:48,320
VM VMA is what kind of lock nothing this

00:44:48,380 --> 00:44:53,940
but for the VM a inside the VM itself

00:44:50,849 --> 00:44:57,150
yeah there is no lock it just reference

00:44:53,940 --> 00:45:00,060
an atomic values for the readers a new

00:44:57,150 --> 00:45:01,890
pointer up to the VM a lock okay you

00:45:00,060 --> 00:45:03,840
said that you can just build up I

00:45:01,890 --> 00:45:06,300
increment in counter because when you

00:45:03,840 --> 00:45:07,890
are when you are taking the read lock we

00:45:06,300 --> 00:45:10,320
just need to increment the number of

00:45:07,890 --> 00:45:12,690
reader for that vm e yes but then to

00:45:10,320 --> 00:45:15,060
unity hold the whitlock for the whole

00:45:12,690 --> 00:45:17,820
tree that's a different story that will

00:45:15,060 --> 00:45:21,330
depend out the vm e trees is implemented

00:45:17,820 --> 00:45:23,220
the vm in lock i am proposing air is not

00:45:21,330 --> 00:45:27,780
dependent on the way the VMA trees

00:45:23,220 --> 00:45:30,720
implemented it can be as today from the

00:45:27,780 --> 00:45:34,290
form of the v3 and double link via mail

00:45:30,720 --> 00:45:37,230
is protected by a lock oh this can be

00:45:34,290 --> 00:45:39,560
I hope in the future something that yam

00:45:37,230 --> 00:45:43,740
is working on that is the maple tree and

00:45:39,560 --> 00:45:50,660
that maple tree allows lot less access

00:45:43,740 --> 00:45:50,660
to a see you protection right I see okay

00:45:52,859 --> 00:46:02,680
any other question so when you increment

00:46:00,280 --> 00:46:04,390
the counter to say hey I'm a reader do

00:46:02,680 --> 00:46:06,609
you not then also need to check to see

00:46:04,390 --> 00:46:09,040
if a writer came in right so that's

00:46:06,609 --> 00:46:11,200
gonna need a heavy offense I suppose

00:46:09,040 --> 00:46:12,280
yeah it's quite something you can just

00:46:11,200 --> 00:46:14,619
in cream under it

00:46:12,280 --> 00:46:17,079
there we go to the reader mm-hmm okay so

00:46:14,619 --> 00:46:18,730
now you're but then you go check out

00:46:17,079 --> 00:46:19,960
potential reader take the pointer there

00:46:18,730 --> 00:46:20,980
is a pointer the cream on the reader and

00:46:19,960 --> 00:46:22,450
wait on the wait you okay

00:46:20,980 --> 00:46:25,359
but you still got some extra fences in

00:46:22,450 --> 00:46:28,030
there yeah but that's that's not a

00:46:25,359 --> 00:46:29,440
contention operation mm-hmm it's

00:46:28,030 --> 00:46:48,970
definitely better than mmm I just

00:46:29,440 --> 00:46:50,050
assumed Table two I think we're on just

00:46:48,970 --> 00:46:52,750
as a reminder if you've made

00:46:50,050 --> 00:46:55,480
presentations today please upload it to

00:46:52,750 --> 00:46:57,940
the links plumbers site if you're not

00:46:55,480 --> 00:47:00,310
able to send it to me and I'll make sure

00:46:57,940 --> 00:47:02,530
it gets uploaded so we can make sure

00:47:00,310 --> 00:47:09,609
that these slide sets are available to

00:47:02,530 --> 00:47:12,180
everyone thank you thank you thank you

00:47:09,609 --> 00:47:12,180

YouTube URL: https://www.youtube.com/watch?v=wg6VLyQxjZQ


