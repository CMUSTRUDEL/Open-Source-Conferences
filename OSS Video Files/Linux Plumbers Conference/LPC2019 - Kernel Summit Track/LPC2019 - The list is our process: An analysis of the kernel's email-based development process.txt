Title: LPC2019 - The list is our process: An analysis of the kernel's email-based development process
Publication date: 2019-11-18
Playlist: LPC2019 - Kernel Summit Track
Description: 
	The list is our process: An analysis of the kernel's email-based development process

Speakers
Mr Ralf Ramsauer (OTH Regensburg)
Prof. Wolfgang Mauerer (OTH Regensburg)
Lukas Bulwahn (BMW AG)

Description
Implementing safety-critical systems usually requires adhering to meticulously defined development processes that specify how code is supposed to be developed, integrated and reviewed, driven by the assumption that a disciplined approach leads to reliably high quality. While known to produce code that can satisfy the highest quality standards, Linux kernel development does not follow such strict patterns, although it is certainly far from a random process. But how can we ensure the quality of a mostly informal approach?

Our work aims at identifying core properties, strengths and weaknesses in the development process by tracking the evolution of components from initial submissions on mailing lists to the final merged contributions.

This talk will:

introduce heuristics to identify the evolution of patches on the mailing list and match patch emails against their included git commit counterparts.

present our publicly available data set of kernel-related email available, curated large-scale data set from more than 200 kernel-related mailing lists

We discuss observations and insights and we draw, ranging form simpler questions like how long the average time from the first version of a patch submission to its final inclusion is, down to a categorisation and analysis of off-list patches and ignored patches.

We particularly seek interaction with experts from the community to discuss benefits and limitations of our approach. We will show how we would like to make this information available in the patchwork tool, and present prototypes of tools and development process analyses that that we would like to refine so that they are useful to Linux kernel developers and maintainers in their every day work. We hope this work can contribute to a future kernel maintainers handbook.
Captions: 
	00:00:00,488 --> 00:00:01,609
- Thank you very much.

00:00:01,609 --> 00:00:03,937
So it's maybe a bit of an unusual talk

00:00:03,937 --> 00:00:07,853
with four authors, three of them have made it here on stage.

00:00:07,853 --> 00:00:11,009
My job is very simple, I'm just hear to introduce everyone

00:00:11,009 --> 00:00:11,983
who did the work.

00:00:11,983 --> 00:00:14,154
So it originates from my research group

00:00:14,154 --> 00:00:17,392
at the Technical University in Regensburg.

00:00:17,392 --> 00:00:19,986
It's also partly related to work done

00:00:19,986 --> 00:00:22,306
at Siemens Corporate Research.

00:00:22,306 --> 00:00:23,378
Many of you may know, we have

00:00:23,378 --> 00:00:25,991
a dedicated embedded Linux team there.

00:00:25,991 --> 00:00:28,643
Most of the work was done by Ralf Ramsauer

00:00:28,643 --> 00:00:30,513
as part of his PhD thesis.

00:00:30,513 --> 00:00:33,357
In Regensburg, Lukas Bulwahn,

00:00:33,357 --> 00:00:36,509
who works for a car manufacturing company

00:00:36,509 --> 00:00:39,442
but is not representing this car manufacturing company

00:00:39,442 --> 00:00:41,655
but is here as a hobbyist.

00:00:41,655 --> 00:00:43,236
We'll explain here some of the results

00:00:43,236 --> 00:00:46,286
that we've got, but what we're mostly here for

00:00:46,286 --> 00:00:49,480
is to hear your opinion on how the community,

00:00:49,480 --> 00:00:52,338
how you can use our results to improve

00:00:52,338 --> 00:00:54,472
the Linux kernel development process.

00:00:54,472 --> 00:00:56,743
To quantify the kernel development process

00:00:56,743 --> 00:00:59,867
is a topic that has gained more and more attention

00:00:59,867 --> 00:01:01,524
and traction in the last couple of years,

00:01:01,524 --> 00:01:06,103
especially for a safety certifications of Linux systems.

00:01:06,103 --> 00:01:09,933
But with that, let me hand over to Lukas.

00:01:09,933 --> 00:01:13,184
- So thanks for the introduction.

00:01:13,184 --> 00:01:14,860
I'm happy to be here in Lisbon.

00:01:14,860 --> 00:01:16,360
Actually because of two reasons.

00:01:16,360 --> 00:01:17,865
Reason number one, I've actually married

00:01:17,865 --> 00:01:20,751
less than a week ago here in Lisbon.

00:01:20,751 --> 00:01:24,568
And my wife, my newly wed wife,

00:01:24,568 --> 00:01:26,323
allowed me to come to this conference

00:01:26,323 --> 00:01:30,373
and shift the honeymoon to then, actually, different date.

00:01:30,373 --> 00:01:31,638
So I'm happy to be here.

00:01:31,638 --> 00:01:34,275
Second reason, being here actually talking

00:01:34,275 --> 00:01:36,884
to this audience here because it's actually

00:01:36,884 --> 00:01:40,587
the best audience to understand

00:01:40,587 --> 00:01:43,280
and actually improve the process,

00:01:43,280 --> 00:01:46,634
based on the results that we have.

00:01:46,634 --> 00:01:47,801
Okay, so.

00:01:49,904 --> 00:01:52,408
The list is our process.

00:01:52,408 --> 00:01:54,542
That's actually the answer.

00:01:54,542 --> 00:01:57,240
That's the answer to the question,

00:01:57,240 --> 00:02:00,114
how does Linux kernel development work?

00:02:00,114 --> 00:02:02,766
And if you ask around the short answer is,

00:02:02,766 --> 00:02:05,433
"Well, the list is our process."

00:02:06,608 --> 00:02:08,746
But we wanna understand this a little bit more.

00:02:08,746 --> 00:02:10,337
We wanna understand this in more detail.

00:02:10,337 --> 00:02:12,412
And this means actually formalizing

00:02:12,412 --> 00:02:15,728
and assessing the Linux kernel development process.

00:02:15,728 --> 00:02:18,940
So before you're afraid, formalizing sounds like a big word,

00:02:18,940 --> 00:02:22,959
you're gonna see later on, it's not that complicated.

00:02:22,959 --> 00:02:25,568
There're actually two motivations for that.

00:02:25,568 --> 00:02:28,556
There's one motivation that's comes from the outside.

00:02:28,556 --> 00:02:31,458
So outside of the Linux Kernel community,

00:02:31,458 --> 00:02:33,198
and then there is further motivation

00:02:33,198 --> 00:02:35,025
that's actually from the inside

00:02:35,025 --> 00:02:36,557
of the Linux Kernel community.

00:02:36,557 --> 00:02:38,900
We're gonna go look into this in a bit detail.

00:02:38,900 --> 00:02:42,809
So from the outside perspective

00:02:42,809 --> 00:02:45,678
there're more or less two stakeholders.

00:02:45,678 --> 00:02:48,112
The first one being academic research.

00:02:48,112 --> 00:02:51,071
Showing that they can apply statistical methods

00:02:51,071 --> 00:02:55,054
or big data methods, machine learning methods

00:02:55,054 --> 00:02:58,666
on software engineering and they can show

00:02:58,666 --> 00:03:00,652
how to improve the process.

00:03:00,652 --> 00:03:02,685
The Linux kernel is their prime example

00:03:02,685 --> 00:03:05,807
for their evaluation to show that the methods work.

00:03:05,807 --> 00:03:07,251
So that's the.

00:03:07,251 --> 00:03:09,713
Ralf Ramsauer and Wolfgang Mauerer

00:03:09,713 --> 00:03:12,896
being the representatives of that group.

00:03:12,896 --> 00:03:15,891
There's a second group, the commercial users.

00:03:15,891 --> 00:03:18,483
I'm, more or less, a representative of that.

00:03:18,483 --> 00:03:22,180
Where commercial users are interested in using Linux,

00:03:22,180 --> 00:03:23,935
the Linux kernel, but they're not involved

00:03:23,935 --> 00:03:26,632
in the development and they want to know

00:03:26,632 --> 00:03:30,965
that the Linux kernel development is sound, is good.

00:03:31,851 --> 00:03:36,434
And especially important, this is in,

00:03:37,322 --> 00:03:40,857
let's call them certification requirements,

00:03:40,857 --> 00:03:43,403
so you can see that in regulated environments.

00:03:43,403 --> 00:03:45,731
So security of related systems.

00:03:45,731 --> 00:03:47,707
So safety related systems.

00:03:47,707 --> 00:03:51,207
And these standards say, very extensively,

00:03:52,156 --> 00:03:54,853
actually two things, first of all,

00:03:54,853 --> 00:03:57,976
you must be able to describer your process.

00:03:57,976 --> 00:04:00,741
And secondly, you have to show evidences

00:04:00,741 --> 00:04:02,201
that that what you describe

00:04:02,201 --> 00:04:05,034
is actually that what you execute.

00:04:07,746 --> 00:04:09,307
And then we come to the interest

00:04:09,307 --> 00:04:12,140
within the Linux kernel community.

00:04:13,233 --> 00:04:15,602
And there is actually two prime examples

00:04:15,602 --> 00:04:19,154
that we can see in the recent time.

00:04:19,154 --> 00:04:24,006
There is the presentation from Dan Williams

00:04:24,006 --> 00:04:26,346
towards the Linux kernel maintainer handbook

00:04:26,346 --> 00:04:27,596
from last year.

00:04:28,555 --> 00:04:33,305
And there's another thread, or email discussion

00:04:34,581 --> 00:04:37,306
in LWN article, where there was the interest

00:04:37,306 --> 00:04:40,797
to create change IDs for kernel patches.

00:04:40,797 --> 00:04:45,145
So you might have followed that discussion as well.

00:04:45,145 --> 00:04:48,928
So what did Dan Williams present last year?

00:04:48,928 --> 00:04:51,761
So here's just a copy of one slide

00:04:53,541 --> 00:04:56,617
as a take-away from his suggestion.

00:04:56,617 --> 00:05:00,228
And he asked for creating subsystem profiles

00:05:00,228 --> 00:05:03,336
for the different subsystems.

00:05:03,336 --> 00:05:08,336
And he, more or less, asked for obtaining all this data

00:05:09,873 --> 00:05:11,878
for the different subsystems.

00:05:11,878 --> 00:05:14,029
And now, of course, now the question comes up,

00:05:14,029 --> 00:05:15,708
"Why do we have to ask, actually,

00:05:15,708 --> 00:05:18,947
"hundred of maintainers to provide this information?

00:05:18,947 --> 00:05:22,793
"Couldn't we just get this information by observation,

00:05:22,793 --> 00:05:26,099
"if that information is publicly available anyway?"

00:05:26,099 --> 00:05:28,484
Of course, there's value to both.

00:05:28,484 --> 00:05:31,430
And we're gonna consider, is it possible

00:05:31,430 --> 00:05:35,513
to actually get this information by observation?

00:05:37,662 --> 00:05:39,833
So that's the motivation.

00:05:39,833 --> 00:05:43,028
Now, the first step to do that

00:05:43,028 --> 00:05:44,206
is that we have to, more or less,

00:05:44,206 --> 00:05:46,827
formalize the development process.

00:05:46,827 --> 00:05:49,879
And this is already the formal model that we're gonna use.

00:05:49,879 --> 00:05:51,571
It's quite simple.

00:05:51,571 --> 00:05:54,210
Patch is created, it's submitted.

00:05:54,210 --> 00:05:56,403
The path is on the mailing list.

00:05:56,403 --> 00:05:59,838
It's discussed and then it continues

00:05:59,838 --> 00:06:04,365
usually with the task to rework the patch in some way.

00:06:04,365 --> 00:06:08,943
This happens iteratively

00:06:08,943 --> 00:06:12,391
n times, until at some point reaches the point

00:06:12,391 --> 00:06:15,055
that there's no further discussion.

00:06:15,055 --> 00:06:17,854
And the path from the mailing list is integrated

00:06:17,854 --> 00:06:22,854
into one git repository, eventually the list git repository.

00:06:24,282 --> 00:06:25,861
The important thing here to note

00:06:25,861 --> 00:06:30,410
is that, of course, everything below this dotted line

00:06:30,410 --> 00:06:33,827
is publicly visible but this relationship

00:06:34,731 --> 00:06:39,064
is somehow lost through the private activities.

00:06:40,035 --> 00:06:43,129
And what is now the tasks

00:06:43,129 --> 00:06:46,778
that has to be determined to actually

00:06:46,778 --> 00:06:49,752
recreate this computer's trays

00:06:49,752 --> 00:06:52,987
is to determine the patch evolution relation

00:06:52,987 --> 00:06:55,070
that is publicly visible.

00:06:56,938 --> 00:07:01,021
With that now seemingly simple task,

00:07:03,422 --> 00:07:06,019
we kind of handed this off to academia

00:07:06,019 --> 00:07:08,477
and they try to solve this.

00:07:08,477 --> 00:07:12,894
And that's the task that Ralf will go into in detail.

00:07:14,425 --> 00:07:15,925
- So first of all.

00:07:17,576 --> 00:07:21,326
(speaks in foreign language)

00:07:22,389 --> 00:07:24,556
- We would need to have a.

00:07:27,540 --> 00:07:28,612
- Hello.

00:07:28,612 --> 00:07:30,194
- [Staff] You have to speak into the microphone.

00:07:30,194 --> 00:07:31,852
- Yes, I do speak in the microphone.

00:07:31,852 --> 00:07:33,910
- Okay, yeah, now it's-- - Now it's working.

00:07:33,910 --> 00:07:36,496
So first of all, let's recall how the Linux kernel

00:07:36,496 --> 00:07:39,129
development process works, in case you're.

00:07:39,129 --> 00:07:42,046
All of you probably know that, but.

00:07:43,453 --> 00:07:45,874
So on the one side we have the mail list on mailing lists

00:07:45,874 --> 00:07:48,262
that developers send to the mailing lists.

00:07:48,262 --> 00:07:51,082
And on the other side there is the git repository

00:07:51,082 --> 00:07:54,202
where we have all the commits.

00:07:54,202 --> 00:07:55,972
So mail on the mailing list is identified

00:07:55,972 --> 00:07:58,991
by a message ID and, of course, a commit in the repository

00:07:58,991 --> 00:08:02,158
is identified by a unique commit hash.

00:08:03,932 --> 00:08:08,932
During the development there are maybe more than one patch

00:08:09,553 --> 00:08:11,670
because there is the revision one,

00:08:11,670 --> 00:08:13,180
revision two, revision three of a patch.

00:08:13,180 --> 00:08:15,920
So it's an iterative process.

00:08:15,920 --> 00:08:17,786
And there might even be, for the same patch,

00:08:17,786 --> 00:08:19,493
there may even be more than one commit hash

00:08:19,493 --> 00:08:21,444
in the repository as, for example,

00:08:21,444 --> 00:08:25,057
different maintainers may pick up the same patch

00:08:25,057 --> 00:08:28,457
and apply to their trees and later when the trees got merged

00:08:28,457 --> 00:08:31,170
and you have the same patch occurring twice

00:08:31,170 --> 00:08:33,253
in the repository.

00:08:34,294 --> 00:08:35,248
The problem that you're now facing

00:08:35,248 --> 00:08:37,304
is that the connection between emails

00:08:37,304 --> 00:08:39,895
and the connection between the email and the commit hash

00:08:39,895 --> 00:08:44,812
is lost during this manual pick up process of the patch.

00:08:47,158 --> 00:08:51,724
So in the repository, we actually only have the result

00:08:51,724 --> 00:08:53,339
of the development process

00:08:53,339 --> 00:08:55,672
that happened before on the mailing list.

00:08:55,672 --> 00:08:58,287
So some authors may, some maintainers

00:08:58,287 --> 00:09:01,454
may add the link tags to their commits

00:09:02,537 --> 00:09:04,732
that points to the last message

00:09:04,732 --> 00:09:07,649
in a series but all the other steps

00:09:08,583 --> 00:09:11,813
are lost during the process.

00:09:11,813 --> 00:09:13,338
So somehow for any analysis

00:09:13,338 --> 00:09:16,005
that we would like to do we need

00:09:18,106 --> 00:09:20,957
to get this mapping of different mails

00:09:20,957 --> 00:09:25,081
to commit hashes and we have a tool for that.

00:09:25,081 --> 00:09:27,763
Our tool is called is PaStA, the patch stack analysis.

00:09:27,763 --> 00:09:31,433
And, initially, it was designed to detect similar patches

00:09:31,433 --> 00:09:35,211
that are applied to different branches in a repository.

00:09:35,211 --> 00:09:36,712
We use that tool to, for example,

00:09:36,712 --> 00:09:38,942
quantify mainlining efforts

00:09:38,942 --> 00:09:42,039
of large, out-of-tree developments

00:09:42,039 --> 00:09:44,934
such as the Preempt_RT patch sticks,

00:09:44,934 --> 00:09:48,278
in order to know how many patches of this patch stick

00:09:48,278 --> 00:09:51,195
are being mainlined over time.

00:09:52,238 --> 00:09:56,821
And we added support for a mailing list to these tools.

00:09:58,096 --> 00:09:59,515
Because from a structural point of view,

00:09:59,515 --> 00:10:01,199
a mailer on the mailing list is nothing else

00:10:01,199 --> 00:10:03,782
than a commit in a repository.

00:10:04,694 --> 00:10:06,674
So what do similar patches actually look like?

00:10:06,674 --> 00:10:09,966
Here I have an example of two similar patches.

00:10:09,966 --> 00:10:12,307
On the left side you can see a patch that first occurred

00:10:12,307 --> 00:10:14,465
on the Preempt_RT patch.

00:10:14,465 --> 00:10:17,034
This could also be an email on the mailing list.

00:10:17,034 --> 00:10:18,785
And on the right side you can see

00:10:18,785 --> 00:10:21,606
the commit as it appeared upstream.

00:10:21,606 --> 00:10:24,178
So from the first point of view

00:10:24,178 --> 00:10:27,012
these patches might look pretty dissimilar.

00:10:27,012 --> 00:10:31,260
They have a completely different commit message.

00:10:31,260 --> 00:10:33,958
Also the diff looks quite dissimilar

00:10:33,958 --> 00:10:36,625
but if you have a closer look at

00:10:37,931 --> 00:10:41,479
the diff we can see that both patches patch the same file.

00:10:41,479 --> 00:10:44,314
Inside this file they patch the same hunk,

00:10:44,314 --> 00:10:45,986
they remove the same line.

00:10:45,986 --> 00:10:48,154
And if you look at the inserted lines

00:10:48,154 --> 00:10:50,237
then we can see that

00:10:52,953 --> 00:10:54,064
from a functional point of view

00:10:54,064 --> 00:10:56,184
they introduce the same change.

00:10:56,184 --> 00:10:58,530
And they pretty much use the same keywords.

00:10:58,530 --> 00:11:02,112
So if we group those and search this by keywords

00:11:02,112 --> 00:11:05,195
then we can see a quite huge overlap.

00:11:06,710 --> 00:11:09,713
And then we can use simple Levenstein's swing distances

00:11:09,713 --> 00:11:13,689
for pairwise comparison of those keywords

00:11:13,689 --> 00:11:15,381
and see that this patch, for instance,

00:11:15,381 --> 00:11:18,789
has a diff similarity of 87.5%.

00:11:18,789 --> 00:11:23,122
And this is how we can map or track similar patches.

00:11:26,782 --> 00:11:29,925
Now, if you would like to apply this technique

00:11:29,925 --> 00:11:32,290
to mailing lists, we would have to compare

00:11:32,290 --> 00:11:33,752
any patch on the mailing lists

00:11:33,752 --> 00:11:35,335
to all commits in the repository

00:11:35,335 --> 00:11:38,323
or against all other emails on the mailing list.

00:11:38,323 --> 00:11:41,975
Which would lead to a commitetorial explosion, of course.

00:11:41,975 --> 00:11:45,196
So we have some prevention techniques to reduce

00:11:45,196 --> 00:11:47,279
the overall search space.

00:11:48,476 --> 00:11:51,674
And in the left graph, the green dots

00:11:51,674 --> 00:11:53,785
are patches of mailing lists, the orange dots

00:11:53,785 --> 00:11:55,169
are commits in the repositories.

00:11:55,169 --> 00:11:57,072
And the edges between those nodes

00:11:57,072 --> 00:12:01,155
are rated by the similarity of the patches.

00:12:03,320 --> 00:12:07,313
The solid lines are patches

00:12:07,313 --> 00:12:09,303
where the similarity exceeds

00:12:09,303 --> 00:12:12,802
a certain threshold and dashed lines are similarities

00:12:12,802 --> 00:12:15,559
that are below a certain threshold.

00:12:15,559 --> 00:12:18,285
If we remove the dashed lines we get partitions

00:12:18,285 --> 00:12:19,868
of similar patches.

00:12:21,417 --> 00:12:23,824
And this is nothing else than a clustering.

00:12:23,824 --> 00:12:27,077
So this, from a machine learning perspective,

00:12:27,077 --> 00:12:28,786
this is nothing else than a clustering problem.

00:12:28,786 --> 00:12:30,137
And we can apply all the techniques

00:12:30,137 --> 00:12:32,894
that come from that field.

00:12:32,894 --> 00:12:34,809
So I don't want to fall into details.

00:12:34,809 --> 00:12:38,861
If you're interested in how this technique works in detail,

00:12:38,861 --> 00:12:42,884
you can have a look at two of our papers.

00:12:42,884 --> 00:12:45,814
Everything is written down there.

00:12:45,814 --> 00:12:48,331
So the next step is data acquisition,

00:12:48,331 --> 00:12:51,248
where do we get our data from?

00:12:51,248 --> 00:12:53,256
So at the beginning there was gmane.org.

00:12:53,256 --> 00:12:56,625
(audience laughs)

00:12:56,625 --> 00:12:59,458
All archives over almost all lists

00:13:00,980 --> 00:13:05,723
could be found there but they shut down a few years ago.

00:13:05,723 --> 00:13:08,048
So those archives aren't available any longer.

00:13:08,048 --> 00:13:10,194
It was pretty nice because they used the LNTP protocol

00:13:10,194 --> 00:13:14,659
it was pretty simple to retrieve all those archives.

00:13:14,659 --> 00:13:19,492
Now, there are the lore.kernel.org public inboxes.

00:13:21,141 --> 00:13:22,938
There some lists are archived,

00:13:22,938 --> 00:13:24,617
not all lists are archived

00:13:24,617 --> 00:13:27,210
but those lists contain prehistoric data

00:13:27,210 --> 00:13:32,127
so you can find pictures from 1990 something on that lists.

00:13:33,026 --> 00:13:36,501
Eventually we created our own mailing list archive

00:13:36,501 --> 00:13:39,436
that covers about 200 mailing lists

00:13:39,436 --> 00:13:41,498
that are mentioned in the maintainers' file

00:13:41,498 --> 00:13:43,797
of the Linux kernel and you can find those lists also

00:13:43,797 --> 00:13:47,130
as public inboxes here on that link.

00:13:49,528 --> 00:13:52,195
So for our analysis that we are,

00:13:54,199 --> 00:13:56,395
that we are doing in this talk,

00:13:56,395 --> 00:13:57,228
we only

00:13:59,697 --> 00:14:02,614
consider the archives on kernel.org

00:14:03,913 --> 00:14:06,496
as they reach long in the past.

00:14:09,022 --> 00:14:11,336
So the data is there, let's get started.

00:14:11,336 --> 00:14:15,836
Turns out that working on mail lists is not that easy.

00:14:16,895 --> 00:14:20,765
Headers say that the email is encoded in UTF-8

00:14:20,765 --> 00:14:24,833
but, in fact, the mail list is encoded in ISO8859.

00:14:24,833 --> 00:14:27,428
But only the half of the mail list encoded in that way.

00:14:27,428 --> 00:14:30,595
So you can find all fancy stuff there.

00:14:31,524 --> 00:14:36,524
So we somehow had, first of all, to normalize all this data.

00:14:37,453 --> 00:14:39,574
You can, for instance, find headers like this.

00:14:39,574 --> 00:14:42,157
This is a message ID, it begins

00:14:43,787 --> 00:14:48,024
pretty okay but it ends with a time

00:14:48,024 --> 00:14:50,441
of the date from the future.

00:14:51,992 --> 00:14:54,552
You can find other headers like this.

00:14:54,552 --> 00:14:55,955
Looks like the author is not sure

00:14:55,955 --> 00:14:59,455
in which time zone he or she currently is.

00:15:00,328 --> 00:15:01,650
You can find mails like this,

00:15:01,650 --> 00:15:06,481
so every date parser will refuse to parse this kind of email

00:15:06,481 --> 00:15:09,898
so maybe that's the reason, I don't know.

00:15:13,346 --> 00:15:15,383
So the data that we analyze reaches

00:15:15,383 --> 00:15:19,466
from 2011 to 2018.

00:15:22,761 --> 00:15:24,910
We analyze about three million emails

00:15:24,910 --> 00:15:27,641
and try to map those emails against the repository,

00:15:27,641 --> 00:15:30,747
we take the last 2.6 release of the Linux kernel

00:15:30,747 --> 00:15:34,552
compare it up to Linus' master tree.

00:15:34,552 --> 00:15:37,788
And we take all lists that we can find on lore.kernel.org.

00:15:37,788 --> 00:15:41,981
Those are, those lists, especially this includes

00:15:41,981 --> 00:15:44,560
lists with high patch or mail frequency

00:15:44,560 --> 00:15:45,834
such as linux-arm-kernel,

00:15:45,834 --> 00:15:49,078
the linux-kernel mailing list linux-next, netdev.

00:15:49,078 --> 00:15:53,161
So those are the lists with many patches per day.

00:15:54,890 --> 00:15:56,690
So we have three million mails

00:15:56,690 --> 00:15:59,654
but only about 1/3 of all emails on those lists

00:15:59,654 --> 00:16:02,228
contain actual patches.

00:16:02,228 --> 00:16:04,648
So we are only interested in the green part.

00:16:04,648 --> 00:16:07,192
But even if you have a closer look at the green part,

00:16:07,192 --> 00:16:10,628
we can see that we can divide those one million patches

00:16:10,628 --> 00:16:14,635
to patches that actually patch Linux and other patches.

00:16:14,635 --> 00:16:16,695
So patches that patch users' base tools.

00:16:16,695 --> 00:16:18,713
If you look at all 200 mailing lists

00:16:18,713 --> 00:16:22,174
of the Linux kernel we can see at about 14% of patches

00:16:22,174 --> 00:16:24,632
on all lists do not affect Linux at all.

00:16:24,632 --> 00:16:29,299
So 14% of all patches are users-based tool patches.

00:16:30,788 --> 00:16:33,060
Across those Linux kernel patches

00:16:33,060 --> 00:16:36,314
we have to filter for actual patches.

00:16:36,314 --> 00:16:39,098
So we are not interested in stable review patches,

00:16:39,098 --> 00:16:41,589
in git pull requests, in mails

00:16:41,589 --> 00:16:43,169
that are being sentfrom bots,

00:16:43,169 --> 00:16:44,612
there are many bots that send patches

00:16:44,612 --> 00:16:46,616
or that include patches so we have to filter

00:16:46,616 --> 00:16:49,902
for actual patches, and even for actual patches

00:16:49,902 --> 00:16:53,576
that are not from any automated systems.

00:16:53,576 --> 00:16:56,917
We are only interested in those patches

00:16:56,917 --> 00:16:59,005
that are the root of a thread,

00:16:59,005 --> 00:17:00,922
so that are the initial patch of a thread

00:17:00,922 --> 00:17:04,859
and not patches that are inside responses to a thread.

00:17:04,859 --> 00:17:09,055
Then they remain only about 800,000 patches.

00:17:09,055 --> 00:17:13,710
And these are the patches that we consider in our analysis

00:17:13,710 --> 00:17:17,607
that Lucas is going to present

00:17:17,607 --> 00:17:20,607
in the next part of the talk.

00:17:23,656 --> 00:17:26,000
- So now we have the raw data.

00:17:26,000 --> 00:17:29,000
And we're gonna do data aggregation.

00:17:31,150 --> 00:17:34,424
We wanna look at certain defined properties.

00:17:34,424 --> 00:17:35,955
I'm gonna give a definition for a property

00:17:35,955 --> 00:17:40,581
and then extract that property from the raw data.

00:17:40,581 --> 00:17:43,998
The next step will then be to interpret this behavior

00:17:43,998 --> 00:17:47,331
and to say what does that actually mean?

00:17:48,577 --> 00:17:52,494
What can we observe in this data?

00:17:53,560 --> 00:17:56,588
And the last step, of course, would be to judge

00:17:56,588 --> 00:17:58,179
if this is good behavior

00:17:58,179 --> 00:18:01,610
or if this is actually considered bad behavior.

00:18:01,610 --> 00:18:04,324
If this is good for the community,

00:18:04,324 --> 00:18:06,648
if this is good for the product

00:18:06,648 --> 00:18:09,892
or if this is actually something bad for the community,

00:18:09,892 --> 00:18:11,525
bad for the product.

00:18:11,525 --> 00:18:16,525
And, as it happens, the uncertainty increases

00:18:16,944 --> 00:18:20,184
as you go down these levels from data analytics.

00:18:20,184 --> 00:18:22,983
And especially if there is an increasing need

00:18:22,983 --> 00:18:26,325
that you actually have kernel community knowledge

00:18:26,325 --> 00:18:31,294
when you go down into these deeper levels.

00:18:31,294 --> 00:18:33,943
And as we are outsiders, we're really just focusing

00:18:33,943 --> 00:18:35,752
on the first two steps.

00:18:35,752 --> 00:18:40,695
We're trying to extract reasonable properties

00:18:40,695 --> 00:18:43,818
of the raw data and we're trying to show

00:18:43,818 --> 00:18:46,707
how this can be interpreted,

00:18:46,707 --> 00:18:49,759
which kind of behaviors we observe.

00:18:49,759 --> 00:18:52,689
We're not trying and we're not intending

00:18:52,689 --> 00:18:54,647
to actually judge this behavior.

00:18:54,647 --> 00:18:56,447
This is something that probably the community

00:18:56,447 --> 00:18:59,569
as a whole can do and can discuss.

00:18:59,569 --> 00:19:03,925
But on a statistical level

00:19:03,925 --> 00:19:08,508
this is very difficult to actually provide

00:19:08,508 --> 00:19:11,532
sound reasons there's probably always inter-weaved

00:19:11,532 --> 00:19:13,428
with some expert judgment.

00:19:13,428 --> 00:19:16,728
And we're not the experts in this community.

00:19:16,728 --> 00:19:18,978
So we're gonna look at one.

00:19:19,882 --> 00:19:21,132
First property.

00:19:22,206 --> 00:19:24,848
If you recall the formal model

00:19:24,848 --> 00:19:28,674
that I described, we said, well, it's kind of passing

00:19:28,674 --> 00:19:32,007
through the mailing lists until it lands

00:19:32,973 --> 00:19:35,033
in the git repository.

00:19:35,033 --> 00:19:40,033
And the question is, does every patch go through this trace?

00:19:40,444 --> 00:19:45,142
Or are there actually other side channels?

00:19:45,142 --> 00:19:46,781
First side channel you could think of

00:19:46,781 --> 00:19:48,631
is, well, actually, a patch

00:19:48,631 --> 00:19:50,485
is somehow sent to the mailing list

00:19:50,485 --> 00:19:53,767
but they eventually just get stuck there.

00:19:53,767 --> 00:19:58,767
Nobody responds, there's no further action from the author.

00:19:58,966 --> 00:20:01,766
And this is what we call ignored, right.

00:20:01,766 --> 00:20:04,182
That's the formal definition that I'm giving here

00:20:04,182 --> 00:20:07,189
called the patch ignored if the thread of the patch

00:20:07,189 --> 00:20:10,222
has no responses from persons other than the author,

00:20:10,222 --> 00:20:13,034
the patch was not accepted upstream so its not

00:20:13,034 --> 00:20:16,688
in the git repository and, actually, all related patches

00:20:16,688 --> 00:20:18,940
were ignored as well.

00:20:18,940 --> 00:20:20,690
Recall that we have

00:20:22,314 --> 00:20:24,519
kind of a relationship that we're checking.

00:20:24,519 --> 00:20:26,792
And this is a recursive definition.

00:20:26,792 --> 00:20:29,973
But, this is nothing that we have to be afraid of.

00:20:29,973 --> 00:20:32,520
It's well-defined, logically, we're talking

00:20:32,520 --> 00:20:37,272
about a finite set and you can actually come

00:20:37,272 --> 00:20:40,189
to a consistent definition of that.

00:20:42,328 --> 00:20:44,966
Assume we're using the word "ignored".

00:20:44,966 --> 00:20:46,743
It has some kind of connotation

00:20:46,743 --> 00:20:48,885
when we talk about it in natural language.

00:20:48,885 --> 00:20:53,135
Kind of ignore that for this word now.

00:20:56,002 --> 00:20:58,666
It's just a property that we're calling that way.

00:20:58,666 --> 00:20:59,499
It could be good.

00:20:59,499 --> 00:21:00,332
It could be bad.

00:21:00,332 --> 00:21:01,906
We actually don't know anything about this word,

00:21:01,906 --> 00:21:03,249
just the definition.

00:21:03,249 --> 00:21:05,857
And now we're interested in specific characteristics

00:21:05,857 --> 00:21:08,902
of this ignored patches.

00:21:08,902 --> 00:21:10,230
And that's actually three questions

00:21:10,230 --> 00:21:11,622
that we're gonna answer in this.

00:21:11,622 --> 00:21:13,730
Three questions that we're first gonna raise

00:21:13,730 --> 00:21:17,278
and, hopefully, gonna answer in this talk.

00:21:17,278 --> 00:21:19,028
The first question is

00:21:23,374 --> 00:21:26,399
has the number and the rate of ignored patches changed

00:21:26,399 --> 00:21:30,732
over the last seven years, from 2011 to 2018?

00:21:32,289 --> 00:21:33,372
The second is

00:21:35,906 --> 00:21:38,777
does this property of ignored patches

00:21:38,777 --> 00:21:41,163
depend on the development cycle?

00:21:41,163 --> 00:21:43,067
Does it make a difference if I sent if I send something

00:21:43,067 --> 00:21:44,880
at RC-4 or does it make a difference

00:21:44,880 --> 00:21:49,271
if I send something at RC-8 or at some other point in time?

00:21:49,271 --> 00:21:53,501
And the third question is does this ignored,

00:21:53,501 --> 00:21:55,512
these characteristics of ignored patches,

00:21:55,512 --> 00:21:59,345
is that related to the authors that sent that?

00:22:01,775 --> 00:22:06,559
So maybe a short round into the audience,

00:22:06,559 --> 00:22:08,309
what are the guesses?

00:22:09,224 --> 00:22:10,057
Anyone.

00:22:10,057 --> 00:22:12,913
Yeah, okay, so what, yes.

00:22:12,913 --> 00:22:15,091
- [Audience Member] Yes, for the last one.

00:22:15,091 --> 00:22:17,833
- Yes for the last one, okay.

00:22:17,833 --> 00:22:21,083
How about over time, what did change?

00:22:25,335 --> 00:22:26,252
More, less?

00:22:28,406 --> 00:22:29,368
- [Audience Member] More over time.

00:22:29,368 --> 00:22:30,785
- More over time.

00:22:31,971 --> 00:22:33,417
Okay.

00:22:33,417 --> 00:22:34,583
Let's look at the data.

00:22:34,583 --> 00:22:38,072
I mean this is, you doing educated guessing.

00:22:38,072 --> 00:22:40,193
And we're trying to then either prove

00:22:40,193 --> 00:22:44,806
or disprove your statements with the data that we can see.

00:22:44,806 --> 00:22:47,223
So if we look at the numbers,

00:22:48,151 --> 00:22:51,256
lore.kernel.org, 2011 to 2018,

00:22:51,256 --> 00:22:55,314
this property is around 2.5%.

00:22:55,314 --> 00:22:56,903
You can say this is a large number.

00:22:56,903 --> 00:22:59,635
You can see this is a low number.

00:22:59,635 --> 00:23:00,589
I actually don't care.

00:23:00,589 --> 00:23:02,422
It's the number.

00:23:04,089 --> 00:23:07,750
You can see 2011 it was roughly 3.9,

00:23:07,750 --> 00:23:10,062
in 2018 it's 1.6.

00:23:10,062 --> 00:23:11,201
If we look at all the mailing lists

00:23:11,201 --> 00:23:13,263
that we're collecting at the moment,

00:23:13,263 --> 00:23:16,519
we're at 3.3 but keep in mind

00:23:16,519 --> 00:23:20,042
we're talking about the recent development,

00:23:20,042 --> 00:23:21,306
actually deciding if something

00:23:21,306 --> 00:23:24,183
is already accepted upstream or not.

00:23:24,183 --> 00:23:28,850
It's difficult to judge given we started in May.

00:23:30,042 --> 00:23:33,542
So let's look at this data in more detail.

00:23:34,465 --> 00:23:38,382
So you see here the absolute number of patches.

00:23:39,443 --> 00:23:40,911
In red you see the ignored patches

00:23:40,911 --> 00:23:44,900
and in blue you see the total number of patches

00:23:44,900 --> 00:23:47,582
and on the mailing lists.

00:23:47,582 --> 00:23:51,235
And, as you can see, the number of total patches

00:23:51,235 --> 00:23:54,207
is increasing, that's not a surprise.

00:23:54,207 --> 00:23:55,290
We know that.

00:23:56,231 --> 00:23:59,778
In fact, the number of ignored patches

00:23:59,778 --> 00:24:03,695
is slightly decreasing over time.

00:24:05,315 --> 00:24:07,435
Now we can look into the data.

00:24:07,435 --> 00:24:08,268
Yes.

00:24:08,268 --> 00:24:09,101
Yeah.

00:24:14,810 --> 00:24:16,666
- Just a quick question.

00:24:16,666 --> 00:24:18,109
There's quite a few bots on the list now

00:24:18,109 --> 00:24:19,910
that sort of reply say this doesn't compile,

00:24:19,910 --> 00:24:21,294
do you count that as a response,

00:24:21,294 --> 00:24:24,405
or will it still be ignored if you got a reply from a bot?

00:24:24,405 --> 00:24:26,379
- We would consider that a response.

00:24:26,379 --> 00:24:27,212
- [Audience Member] Okay.

00:24:27,212 --> 00:24:28,045
- Yes.

00:24:29,443 --> 00:24:33,168
So what we can see if we look at this in detail,

00:24:33,168 --> 00:24:35,265
we can look at the, really, the first easy thing

00:24:35,265 --> 00:24:37,680
that we can see is if we look at the blue line,

00:24:37,680 --> 00:24:40,256
you see these kind of spikes going down.

00:24:40,256 --> 00:24:44,134
Sophistically, it's kind of a regularity,

00:24:44,134 --> 00:24:46,174
yearly happening event,

00:24:46,174 --> 00:24:48,236
that's what the statistician would call it.

00:24:48,236 --> 00:24:50,845
The non-statistician would just call it Christmas break.

00:24:50,845 --> 00:24:52,126
Right, that's what's happening.

00:24:52,126 --> 00:24:54,061
(audience laughs)

00:24:54,061 --> 00:24:56,787
The other thing that you can see on the red plot

00:24:56,787 --> 00:25:00,454
is that there is a spike around mid of 2016.

00:25:02,604 --> 00:25:04,854
Quite impressive one there.

00:25:05,753 --> 00:25:07,659
We looked into that in detail

00:25:07,659 --> 00:25:10,323
and it's actually a combination of a technical issue

00:25:10,323 --> 00:25:13,534
and a human error that happened at that point

00:25:13,534 --> 00:25:15,367
that led to this

00:25:16,329 --> 00:25:20,412
huge spike of ignored patches.

00:25:21,892 --> 00:25:24,438
After we had a look at that, we said, okay,

00:25:24,438 --> 00:25:27,489
this might just mess up for the analytics

00:25:27,489 --> 00:25:29,822
that we're doing, so we just

00:25:31,727 --> 00:25:32,742
ignoring that week.

00:25:32,742 --> 00:25:33,575
Yes?

00:25:33,575 --> 00:25:35,729
- [Audience Member] What kind of human error?

00:25:35,729 --> 00:25:36,922
- We're not saying any.

00:25:36,922 --> 00:25:37,755
So we're not gonna--

00:25:37,755 --> 00:25:38,588
(crosstalk drowns out speaker)

00:25:38,588 --> 00:25:39,421
Yes.

00:25:39,421 --> 00:25:40,544
We're not gonna say who it was,

00:25:40,544 --> 00:25:42,211
we're not gonna say

00:25:43,801 --> 00:25:45,145
what kind of error it was.

00:25:45,145 --> 00:25:47,623
It was just someone who didn't understand

00:25:47,623 --> 00:25:50,893
the process properly at that point.

00:25:50,893 --> 00:25:51,726
- [Audience Member] You may want to look into

00:25:51,726 --> 00:25:53,978
(background noise drowns out speaker).

00:25:53,978 --> 00:25:54,811
- Yeah.

00:25:54,811 --> 00:25:56,170
So if you're long enough in the development

00:25:56,170 --> 00:25:59,170
you know what happened in that week.

00:26:00,831 --> 00:26:04,713
Okay, so we're gonna look into this in more detail.

00:26:04,713 --> 00:26:06,761
So here are the number of ignored patches

00:26:06,761 --> 00:26:11,511
and we can actually see if we put a general model on this

00:26:12,699 --> 00:26:14,422
we see that it's fluctuating little bit

00:26:14,422 --> 00:26:17,617
but generally doing a linear regression on this

00:26:17,617 --> 00:26:21,867
is sound and stable because there're not too many,

00:26:24,739 --> 00:26:28,239
too much freedom, actually, in this curve.

00:26:30,249 --> 00:26:32,683
If we now look into the ratio

00:26:32,683 --> 00:26:36,262
comparing the percentage of ignored patches,

00:26:36,262 --> 00:26:39,135
we do see that it's not just a slight decrease

00:26:39,135 --> 00:26:41,306
it's actually a significant decrease

00:26:41,306 --> 00:26:44,959
comparing to the fact that the number of patches

00:26:44,959 --> 00:26:46,975
is significantly increasing.

00:26:46,975 --> 00:26:49,774
So we do see that it's actually getting lower

00:26:49,774 --> 00:26:54,774
from 3% to around 2% over the last 6 years.

00:26:58,634 --> 00:27:00,665
The second thing that we could look into

00:27:00,665 --> 00:27:05,540
is how is this related to the release candidate

00:27:05,540 --> 00:27:07,623
to the development stage?

00:27:08,987 --> 00:27:11,374
What if the patch is sent in the merge window,

00:27:11,374 --> 00:27:13,819
what happens if it's sent at a certain point

00:27:13,819 --> 00:27:16,736
during a certain release candidate.

00:27:17,580 --> 00:27:19,937
The graphics here is a bit complicated

00:27:19,937 --> 00:27:24,482
because we're actually aggregating over 40 release cycles.

00:27:24,482 --> 00:27:29,482
And every one of them is actually a distribution of data.

00:27:30,851 --> 00:27:33,698
But what you can see from this data is

00:27:33,698 --> 00:27:37,765
for the merge window it is slightly higher.

00:27:37,765 --> 00:27:42,765
The likelihood that you would actually get ignored and

00:27:42,811 --> 00:27:47,268
between release candidate one to the final release

00:27:47,268 --> 00:27:49,214
it's actually quite stable

00:27:49,214 --> 00:27:52,214
or actually has a very similar rate.

00:27:56,330 --> 00:27:57,163
Yeah.

00:28:03,798 --> 00:28:04,829
- [Audience Member] I guess the question I have

00:28:04,829 --> 00:28:09,329
with respect to why we're checking ignored patches is,

00:28:10,447 --> 00:28:13,510
what does that do for the confidence of the patches

00:28:13,510 --> 00:28:14,807
that are in the kernel?

00:28:14,807 --> 00:28:16,165
Because an ignored patch is,

00:28:16,165 --> 00:28:18,915
by definition, not in the kernel.

00:28:19,812 --> 00:28:22,177
(crosstalk drowns out speaker) - Yes, yes.

00:28:22,177 --> 00:28:25,510
It tells us something about the process.

00:28:27,640 --> 00:28:29,833
If everyone is following the process

00:28:29,833 --> 00:28:31,647
or the community as a large

00:28:31,647 --> 00:28:34,900
is following the process of giving feedback

00:28:34,900 --> 00:28:37,067
until it is in the kernel.

00:28:38,200 --> 00:28:39,690
And that's something that you need

00:28:39,690 --> 00:28:43,607
because that's the core essence of the process.

00:28:44,767 --> 00:28:46,234
- And that is actually the question

00:28:46,234 --> 00:28:48,084
we have for you guys in the discussion.

00:28:48,084 --> 00:28:49,588
What do these numbers tell us?

00:28:49,588 --> 00:28:50,421
Is that good?

00:28:50,421 --> 00:28:51,254
Is that bad?

00:28:51,254 --> 00:28:53,336
So we don't have any interpretation of that,

00:28:53,336 --> 00:28:55,169
we just have the data.

00:28:59,750 --> 00:29:00,797
- So maybe that's something

00:29:00,797 --> 00:29:03,801
for the discussion later on, yes.

00:29:03,801 --> 00:29:05,950
What we also looked at is.

00:29:05,950 --> 00:29:10,159
We're now looking at, is this related to the developer?

00:29:10,159 --> 00:29:11,205
So we're looking at the number

00:29:11,205 --> 00:29:13,926
of ignored patches by author.

00:29:13,926 --> 00:29:15,801
And every dot represents one person

00:29:15,801 --> 00:29:17,482
in the kernel development,

00:29:17,482 --> 00:29:21,799
or one identity in the kernel development.

00:29:21,799 --> 00:29:26,799
And, as you can see, there's quite a lot of people involved.

00:29:27,161 --> 00:29:30,002
The most important thing that we really wanna point out is

00:29:30,002 --> 00:29:34,502
that for most people you never reach

00:29:36,210 --> 00:29:38,509
more than 50 ignored patches

00:29:38,509 --> 00:29:42,842
over your kernel development career.

00:29:44,666 --> 00:29:49,246
Only very, very few have more than 100 ignored patches.

00:29:49,246 --> 00:29:53,419
As you can also see, yes, at the beginning

00:29:53,419 --> 00:29:56,964
the curve is a bit kind of steeper

00:29:56,964 --> 00:29:59,179
and afterwards it's kind of

00:29:59,179 --> 00:30:02,577
in this wavy getting constant shape.

00:30:02,577 --> 00:30:05,641
But, you shouldn't interpret too much

00:30:05,641 --> 00:30:09,379
into these details because that's just statistics

00:30:09,379 --> 00:30:12,875
based on the data that we have here.

00:30:12,875 --> 00:30:17,588
Important is most people are not ignored,

00:30:17,588 --> 00:30:21,255
most people are actually facing that problem

00:30:22,475 --> 00:30:25,117
a constant number of times and then it actually stops.

00:30:25,117 --> 00:30:28,918
Independent of how long you're in the kernel community.

00:30:28,918 --> 00:30:32,911
So now back to another question.

00:30:32,911 --> 00:30:34,413
Is that actually the only way

00:30:34,413 --> 00:30:37,663
to get your commit into the repository?

00:30:37,663 --> 00:30:39,139
Do I have to go through the mailing list

00:30:39,139 --> 00:30:41,306
and is it then integrated?

00:30:43,046 --> 00:30:44,829
Or is it actually a side channel?

00:30:44,829 --> 00:30:47,067
And that's what we call a off-list patch.

00:30:47,067 --> 00:30:48,808
So an off-list patch is a patch

00:30:48,808 --> 00:30:51,859
that is been included into Linux git repository

00:30:51,859 --> 00:30:55,590
but has actually never been sent to any public mailing list.

00:30:55,590 --> 00:30:57,708
That requires that you have access

00:30:57,708 --> 00:30:59,360
to all public mailings lists

00:30:59,360 --> 00:31:04,360
where patches are sent to and that you follow them.

00:31:04,772 --> 00:31:08,363
So that's why we following these mailing lists

00:31:08,363 --> 00:31:10,363
more extensively lately.

00:31:11,260 --> 00:31:13,871
This is very early work.

00:31:13,871 --> 00:31:18,160
And we actually use the heuristics to identify

00:31:18,160 --> 00:31:22,010
80 commits out of one stabilization phase

00:31:22,010 --> 00:31:27,010
from 5.1-rc1 to 5.1, it's about 1,800 commits.

00:31:27,630 --> 00:31:31,169
Then we had to go through these 80 commits manually

00:31:31,169 --> 00:31:33,331
because it's prone to error

00:31:33,331 --> 00:31:35,748
and it's, of course,

00:31:37,614 --> 00:31:40,029
prone to the fact that we don't know if

00:31:40,029 --> 00:31:42,740
we actually have all mailing lists.

00:31:42,740 --> 00:31:45,673
In the end we did this, went through 60 commits

00:31:45,673 --> 00:31:50,139
we could actually identify 24 off-list commits.

00:31:50,139 --> 00:31:55,139
We can't derive much knowledge from CU24 off-list commits.

00:31:55,674 --> 00:31:57,837
So there is not any statistics

00:31:57,837 --> 00:31:59,062
that we're creating there.

00:31:59,062 --> 00:32:02,521
I can just say the kind of obvious things is

00:32:02,521 --> 00:32:06,264
reverting patches is often discussed on the mailing list.

00:32:06,264 --> 00:32:08,797
Of course, the reverting patch itself

00:32:08,797 --> 00:32:11,269
might not end on the mailing list.

00:32:11,269 --> 00:32:14,592
Another obvious thing is that we found out

00:32:14,592 --> 00:32:17,656
by the numbers that actually very few patches

00:32:17,656 --> 00:32:20,573
from maintainers are sent off-list.

00:32:22,270 --> 00:32:26,857
For most maintainers they are somehow on the list.

00:32:26,857 --> 00:32:30,326
The more or less obvious things that we found out is

00:32:30,326 --> 00:32:31,874
that some of those off-list patches

00:32:31,874 --> 00:32:36,503
seem to be security related if you follow up on them.

00:32:36,503 --> 00:32:41,503
And also the patches that are off-list,

00:32:41,570 --> 00:32:43,619
they're not evenly distributed

00:32:43,619 --> 00:32:47,125
over all maintainers but they're actually specific

00:32:47,125 --> 00:32:50,277
to some subsystem maintainers.

00:32:50,277 --> 00:32:53,209
So let's look at one of those examples.

00:32:53,209 --> 00:32:55,269
So here's one of those examples

00:32:55,269 --> 00:32:58,186
that we found as an off-list patch.

00:32:59,613 --> 00:33:03,655
From Greg, tty, mark Siemnens R3964

00:33:03,655 --> 00:33:08,238
line discipline is broken was included,

00:33:10,337 --> 00:33:14,254
I think, in the 5.0 kernel if I'm not mistaken.

00:33:17,826 --> 00:33:20,059
You'll look on the mailing list and you try to find it.

00:33:20,059 --> 00:33:21,708
If you Google now for it, you're gonna find

00:33:21,708 --> 00:33:25,350
that there's some back ports to it, some other trees.

00:33:25,350 --> 00:33:26,538
But you're not gonna find some

00:33:26,538 --> 00:33:29,760
initial discussion on this patch.

00:33:29,760 --> 00:33:32,188
And it does say some things down there like,

00:33:32,188 --> 00:33:34,195
"Many thanks Jann and Linus

00:33:34,195 --> 00:33:35,503
"for pointing out the initial problems."

00:33:35,503 --> 00:33:38,889
So there must be some kind of secret channel going on

00:33:38,889 --> 00:33:41,306
that we're not aware of.

00:33:44,902 --> 00:33:45,923
If you wanna know the details on that,

00:33:45,923 --> 00:33:50,578
I guess you have to ask the authors personally.

00:33:50,578 --> 00:33:53,411
Yes, and with that we'll conclude.

00:33:54,658 --> 00:33:56,791
- Thanks for the interest so far.

00:33:56,791 --> 00:33:59,167
Just to reiterate what we said is.

00:33:59,167 --> 00:34:01,714
We presented some examples but these examples

00:34:01,714 --> 00:34:05,065
for our analysis are not what's really the interesting point

00:34:05,065 --> 00:34:08,516
or the interesting thing now, from our point of view.

00:34:08,516 --> 00:34:12,002
It's more now that we do have mechanisms available

00:34:12,002 --> 00:34:14,873
that can, basically, reconstruct many properties

00:34:14,873 --> 00:34:16,359
that are really implicitly,

00:34:16,359 --> 00:34:18,293
or have only been implicitly available

00:34:18,293 --> 00:34:20,355
in the Linux kernel development process.

00:34:20,355 --> 00:34:23,258
And that, of course, raises the question,

00:34:23,258 --> 00:34:25,368
especially considering the case,

00:34:25,368 --> 00:34:27,943
some needs preparation discussion

00:34:27,943 --> 00:34:32,314
about tracking the kernel development process.

00:34:32,314 --> 00:34:35,016
What you as kernel development community

00:34:35,016 --> 00:34:38,595
would find interesting are questions to answer

00:34:38,595 --> 00:34:41,428
given this kind of magic mechanism

00:34:42,419 --> 00:34:44,128
that can provide such answers.

00:34:44,128 --> 00:34:46,688
What we've learned in the last couple of years

00:34:46,688 --> 00:34:49,874
doing this research is that the typical gut feeling,

00:34:49,874 --> 00:34:52,038
the typical intuition from developers

00:34:52,038 --> 00:34:56,274
about kernel development is usually not quite accurate

00:34:56,274 --> 00:34:59,147
as is, have also seen when you ask the questions

00:34:59,147 --> 00:35:02,897
during the talk and gave data-driven answers.

00:35:03,799 --> 00:35:05,414
Let's start a discussion with,

00:35:05,414 --> 00:35:07,839
given that these mechanisms are available,

00:35:07,839 --> 00:35:11,997
what are questions that we could help you answer?

00:35:11,997 --> 00:35:14,544
That we could provide benefits

00:35:14,544 --> 00:35:17,544
to the kernel development community.

00:35:22,620 --> 00:35:24,004
- So I'll make the observation

00:35:24,004 --> 00:35:26,290
that the old management mantra of,

00:35:26,290 --> 00:35:30,252
"You get what you measure" is very often true.

00:35:30,252 --> 00:35:33,903
One of the ways in which linux-next is actually

00:35:33,903 --> 00:35:36,556
captures the vast majority of patches

00:35:36,556 --> 00:35:40,622
before the merge window is because Stephen Rothwell

00:35:40,622 --> 00:35:43,426
published his statistics of how many patches

00:35:43,426 --> 00:35:48,333
are in linux-next before the final release is put out.

00:35:48,333 --> 00:35:50,771
And then at the end of the merge window

00:35:50,771 --> 00:35:53,866
how many patches were not in linux-next,

00:35:53,866 --> 00:35:57,858
bypass linux-next and who were the top 10

00:35:57,858 --> 00:36:02,001
subsystem maintainers who were responsible for that.

00:36:02,001 --> 00:36:04,370
So that there was sort of just.

00:36:04,370 --> 00:36:07,235
No judgment was made but people saw that

00:36:07,235 --> 00:36:10,788
and they adjusted their behavior accordingly

00:36:10,788 --> 00:36:12,582
and now the vast majority of patches

00:36:12,582 --> 00:36:14,415
go through linux-next.

00:36:15,249 --> 00:36:17,623
One observation I would make is that

00:36:17,623 --> 00:36:19,833
if we wanted to do something similar,

00:36:19,833 --> 00:36:24,833
assuming we all believe that mailing lists review good

00:36:24,971 --> 00:36:26,994
would be a regular mechanism

00:36:26,994 --> 00:36:29,555
by which we could do something similar,

00:36:29,555 --> 00:36:31,767
where at the close of each merge window,

00:36:31,767 --> 00:36:34,508
what percentage of patches

00:36:34,508 --> 00:36:39,368
actually went through the mailing list.

00:36:39,368 --> 00:36:44,041
And Sasha recently made a comment about how a patch

00:36:44,041 --> 00:36:48,958
that landed in, I think, RC7 or RC6 had some nasty effects.

00:36:49,864 --> 00:36:52,676
And obviously didn't get as enough testing.

00:36:52,676 --> 00:36:55,051
And, again, if we were to measure

00:36:55,051 --> 00:36:59,259
how many patches went through the mailing list process

00:36:59,259 --> 00:37:01,910
versus those that didn't and at what time

00:37:01,910 --> 00:37:05,798
did they enter the process, it would probably start

00:37:05,798 --> 00:37:09,224
to put pressure on the community without, necessarily,

00:37:09,224 --> 00:37:11,391
having to call anyone out.

00:37:13,596 --> 00:37:15,488
- Thanks, that's a thing, surely, to consider.

00:37:15,488 --> 00:37:17,695
Any comments from you guys?

00:37:17,695 --> 00:37:18,528
No.

00:37:19,813 --> 00:37:21,809
Anymore ideas, wishes?

00:37:21,809 --> 00:37:25,166
Wait, so here (murmurs).

00:37:25,166 --> 00:37:28,854
- I'd be curious to know if you have any numbers

00:37:28,854 --> 00:37:31,384
on the number of mal-form patches

00:37:31,384 --> 00:37:33,103
submitted to the mailing lists.

00:37:33,103 --> 00:37:36,084
So tooling errors that are common

00:37:36,084 --> 00:37:39,334
in terms of complying with the process.

00:37:44,038 --> 00:37:45,793
- So I don't have this data right now

00:37:45,793 --> 00:37:47,378
but I could calculate them.

00:37:47,378 --> 00:37:51,138
For example, simply by looking at patches that are.

00:37:51,138 --> 00:37:52,462
By simply looking at emails

00:37:52,462 --> 00:37:54,012
that were not detected as patches but contain,

00:37:54,012 --> 00:37:56,269
for instance, patch in their subject.

00:37:56,269 --> 00:37:59,739
This would probably be mal-form patches.

00:37:59,739 --> 00:38:01,427
- That'd be interesting.

00:38:01,427 --> 00:38:02,260
- There was someone-- - And there will

00:38:02,260 --> 00:38:03,846
be quite some.

00:38:03,846 --> 00:38:06,679
(audience laughs)

00:38:10,984 --> 00:38:14,093
- [Staff] This is always going on for whatever reason.

00:38:14,093 --> 00:38:16,510
- So this is sort of related.

00:38:18,005 --> 00:38:21,646
Your diff or patch similarity thing,

00:38:21,646 --> 00:38:25,666
you could also apply that to the stable trees.

00:38:25,666 --> 00:38:30,666
And then you could say this mail became this commit upstream

00:38:30,967 --> 00:38:33,466
and this commit in all the stable trees.

00:38:33,466 --> 00:38:37,552
And that would be really, really helpful for me.

00:38:37,552 --> 00:38:40,135
And probably some other people.

00:38:42,672 --> 00:38:44,895
- I don't know if I got it correctly

00:38:44,895 --> 00:38:47,739
but if you have (background noise drowns out speaker) tree

00:38:47,739 --> 00:38:48,613
then you won't really know

00:38:48,613 --> 00:38:51,621
(background noise drowns out speaker).

00:38:51,621 --> 00:38:53,557
- [Audience Member] Usually, but more or less.

00:38:53,557 --> 00:38:57,366
And actually time that all together.

00:38:57,366 --> 00:39:00,771
In automated line, it'd be really helpful.

00:39:00,771 --> 00:39:05,346
(background noise drowns out speaker)

00:39:05,346 --> 00:39:08,543
- The answer that Ralf is trying to say is also,

00:39:08,543 --> 00:39:11,210
we're using a heuristics, right?

00:39:12,515 --> 00:39:16,941
I would prefer to, of course, rely on data

00:39:16,941 --> 00:39:20,021
that has actually been added in the process.

00:39:20,021 --> 00:39:22,382
And if that happens with Greg's script,

00:39:22,382 --> 00:39:25,233
saying, okay, that was the upstream commit

00:39:25,233 --> 00:39:27,854
and that's the hash, then I would try

00:39:27,854 --> 00:39:29,954
to rely on that data not--

00:39:29,954 --> 00:39:30,787
- [Audience Member] Yeah, but you--

00:39:30,787 --> 00:39:33,440
- So as a fall back, you can always use our methods, yes.

00:39:33,440 --> 00:39:34,273
- [Audience Member] Yeah, that's

00:39:34,273 --> 00:39:36,617
(background noise drowns out speaker).

00:39:36,617 --> 00:39:38,646
- I'd be much interested in the latency.

00:39:38,646 --> 00:39:42,388
How long does it take, someone submits the patch,

00:39:42,388 --> 00:39:44,661
to get a first reaction?

00:39:44,661 --> 00:39:46,654
If there is a reaction.

00:39:46,654 --> 00:39:51,274
So do people need to wait one week or one month or whatever?

00:39:51,274 --> 00:39:55,375
And how that latency develops over time.

00:39:55,375 --> 00:39:57,875
I would be interested in that.

00:40:02,696 --> 00:40:04,786
- Have you tried measure also the number of iterations

00:40:04,786 --> 00:40:08,673
a patch takes to get in and how that should differ

00:40:08,673 --> 00:40:10,723
between different subsystems?

00:40:10,723 --> 00:40:13,696
And also measuring how many people is involved

00:40:13,696 --> 00:40:17,308
in the review process depending on the different subsystems.

00:40:17,308 --> 00:40:21,374
Do you think it's possible with your system?

00:40:21,374 --> 00:40:23,568
- So the two questions that you raised,

00:40:23,568 --> 00:40:26,354
that has been, actually, very well researched

00:40:26,354 --> 00:40:28,090
outside the Linux kernel community.

00:40:28,090 --> 00:40:31,886
So there's quite some academic work that I can point you to.

00:40:31,886 --> 00:40:36,553
But we could also extract these facts from our database.

00:40:43,676 --> 00:40:44,990
- In a similar vein, I'd be curious

00:40:44,990 --> 00:40:48,157
to see what the acceptance

00:40:50,879 --> 00:40:51,803
percentage was.

00:40:51,803 --> 00:40:54,443
Like these patches got replied to,

00:40:54,443 --> 00:40:56,862
so they weren't ignored but they never made it

00:40:56,862 --> 00:40:57,949
into the git tree.

00:40:57,949 --> 00:41:01,668
So what is the frequency of things actually landing?

00:41:01,668 --> 00:41:04,515
Which, again, has been studied but this.

00:41:04,515 --> 00:41:09,098
You look like you have a larger, more complete dataset.

00:41:11,410 --> 00:41:13,778
- I think we actually looked into that as well

00:41:13,778 --> 00:41:16,179
but we just didn't include that in the presentation.

00:41:16,179 --> 00:41:19,123
Again, you have to look at the details.

00:41:19,123 --> 00:41:21,816
So they're not just from a first plot

00:41:21,816 --> 00:41:23,886
just come to a certain conclusion.

00:41:23,886 --> 00:41:27,439
But, yes, we were interested in that as well.

00:41:27,439 --> 00:41:30,791
- And we will follow up with the answers to these questions.

00:41:30,791 --> 00:41:34,541
Probably in the slide tech or some other way.

00:41:41,833 --> 00:41:44,315
- I would imagine that one really tricky thing

00:41:44,315 --> 00:41:46,936
is you're using patch similarity

00:41:46,936 --> 00:41:49,025
but very often what can happen

00:41:49,025 --> 00:41:52,646
is that a request is made

00:41:52,646 --> 00:41:55,502
to accomplish the same goal

00:41:55,502 --> 00:41:58,166
as the patch but in a very different way.

00:41:58,166 --> 00:41:59,646
And so therefore, the patch similarity

00:41:59,646 --> 00:42:01,244
is very, very different.

00:42:01,244 --> 00:42:03,713
And so just simply being able to chain

00:42:03,713 --> 00:42:07,357
between version two and version three of a patch set

00:42:07,357 --> 00:42:11,306
in the absence of metadata to make it obvious

00:42:11,306 --> 00:42:15,890
is probably gonna be challenging for a heuristic tool.

00:42:15,890 --> 00:42:16,723
- Yeah, it is.

00:42:16,723 --> 00:42:19,224
That's actually why this work is at the forefront

00:42:19,224 --> 00:42:21,916
of academic software engineering research.

00:42:21,916 --> 00:42:25,895
It was a result that actually surprised us quite a lot.

00:42:25,895 --> 00:42:29,568
That when this seemingly simple textual comparisons

00:42:29,568 --> 00:42:33,059
without having any abstract syntax tree

00:42:33,059 --> 00:42:35,008
of what not does work really well.

00:42:35,008 --> 00:42:38,485
But it turns out if you look into the proper paper

00:42:38,485 --> 00:42:40,360
that the quality of the clustering

00:42:40,360 --> 00:42:43,125
we can come up with is quite high.

00:42:43,125 --> 00:42:45,864
Maybe Ralf, who has suffered quite a lot

00:42:45,864 --> 00:42:50,587
to do a manual evaluation wants to comment on that.

00:42:50,587 --> 00:42:52,485
- So for most cases it works.

00:42:52,485 --> 00:42:55,546
But, of course, there are some limitations.

00:42:55,546 --> 00:42:59,408
And it will be pretty hard to overcome these limitations.

00:42:59,408 --> 00:43:02,415
And even for a human it's hard to identify

00:43:02,415 --> 00:43:04,248
these kind of patches.

00:43:05,186 --> 00:43:08,986
- But we did a very large scale manual evaluation.

00:43:08,986 --> 00:43:12,187
Ralf looking at patches and emails and patches and emails

00:43:12,187 --> 00:43:13,795
and patches and emails.

00:43:13,795 --> 00:43:15,156
So that when somehow proves that

00:43:15,156 --> 00:43:18,390
he could compare and optimize our methods against.

00:43:18,390 --> 00:43:22,390
And even if it works (murmurs).

00:43:30,354 --> 00:43:32,744
- One of the things that has been under discussion

00:43:32,744 --> 00:43:35,669
which you may or may not be aware is

00:43:35,669 --> 00:43:38,978
there has been discussion about trying

00:43:38,978 --> 00:43:42,252
to find automatic ways of matching, actually,

00:43:42,252 --> 00:43:45,940
inserting message IDs into commit messages.

00:43:45,940 --> 00:43:48,060
That's actually relatively easy.

00:43:48,060 --> 00:43:50,207
The thing for which I don't believe

00:43:50,207 --> 00:43:52,794
there's been any consensus is,

00:43:52,794 --> 00:43:56,302
what is the best way to insert metadata so that, in fact,

00:43:56,302 --> 00:44:01,302
you can match different versions of a patch set

00:44:01,657 --> 00:44:05,740
through version one to, in some cases, version 50

00:44:06,724 --> 00:44:08,074
of a patch series?

00:44:08,074 --> 00:44:12,013
How do you actually chain the revision history?

00:44:12,013 --> 00:44:13,325
And I don't know.

00:44:13,325 --> 00:44:15,397
People are experimenting with different mechanisms

00:44:15,397 --> 00:44:19,085
but it may be that in the future you will have some metadata

00:44:19,085 --> 00:44:22,543
to assist in your work.

00:44:22,543 --> 00:44:24,667
And that may allow you to do much more richer,

00:44:24,667 --> 00:44:27,553
much more interesting answers

00:44:27,553 --> 00:44:31,608
to some of the questions people have posed.

00:44:31,608 --> 00:44:33,326
So we are aware of this discussion.

00:44:33,326 --> 00:44:35,936
And, of course, it would be great to have such a mechanism

00:44:35,936 --> 00:44:37,836
installed in the kernel development process.

00:44:37,836 --> 00:44:40,700
But then it's not just a Linux kernel we're interested in.

00:44:40,700 --> 00:44:44,248
A typical system, you may be aware of that or not,

00:44:44,248 --> 00:44:46,694
consists of more than the Linux kernel

00:44:46,694 --> 00:44:49,694
and we also need to take these components into account.

00:44:49,694 --> 00:44:54,694
And changing the behavior of the Linux kernel community

00:44:54,913 --> 00:44:58,410
that's larger than 50 people is also a challenging thing

00:44:58,410 --> 00:44:59,487
as the past has shown.

00:44:59,487 --> 00:45:00,320
So if there will be a need

00:45:00,320 --> 00:45:03,737
for such intermediate solutions, I guess.

00:45:05,719 --> 00:45:07,469
So one more question.

00:45:09,963 --> 00:45:13,380
- Not so much a question as a suggestion.

00:45:14,419 --> 00:45:18,519
When we started doing link tags or we thought it was

00:45:18,519 --> 00:45:21,209
a message ID tags

00:45:21,209 --> 00:45:24,390
but then it was modified into link tags

00:45:24,390 --> 00:45:27,479
that are really just same information just automated.

00:45:27,479 --> 00:45:30,984
So we could click on them you get to see them.

00:45:30,984 --> 00:45:33,151
But we could do that with.

00:45:34,536 --> 00:45:38,298
Right now they're done as an automatic commit.

00:45:38,298 --> 00:45:41,812
But, you can do that

00:45:41,812 --> 00:45:45,254
with patch revisions too.

00:45:45,254 --> 00:45:49,399
And have back links to the previous versions.

00:45:49,399 --> 00:45:53,731
And that way you actually would get an entire chain

00:45:53,731 --> 00:45:58,677
of patch revisions that you can just click through.

00:45:58,677 --> 00:46:02,016
And it would also solve some of your problems.

00:46:02,016 --> 00:46:05,349
Other comment is that the one-day people

00:46:08,093 --> 00:46:10,788
or zero-day people, testing people

00:46:10,788 --> 00:46:13,866
have done some of this work as well

00:46:13,866 --> 00:46:17,949
that you may be able to share some of the effort.

00:46:27,770 --> 00:46:30,853
- I think we already ran out of time.

00:46:32,505 --> 00:46:33,887
Thank you, thank you very much

00:46:33,887 --> 00:46:35,921
for this already very, very helpful input

00:46:35,921 --> 00:46:37,822
that we will consider in future work

00:46:37,822 --> 00:46:40,919
and we will be around if you have more ideas,

00:46:40,919 --> 00:46:43,035
questions, things to tell us.

00:46:43,035 --> 00:46:44,270

YouTube URL: https://www.youtube.com/watch?v=QG1YDQ1HOKE


