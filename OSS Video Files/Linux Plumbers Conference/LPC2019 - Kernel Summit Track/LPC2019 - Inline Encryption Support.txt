Title: LPC2019 - Inline Encryption Support
Publication date: 2019-11-18
Playlist: LPC2019 - Kernel Summit Track
Description: 
	Inline Encryption Support

Speaker
 Satya Tangirala

Description
Storage hardware with built-in “inline” encryption support is becoming increasingly common, especially on mobile SoCs running Android; it's also now part of the UFS and eMMC standards. These devices en/decrypt data between the application processor and disk without generating disk latency or cpu overhead. Inline encryption hardware can be programmed to hold multiple encryption keys simultaneously and can be dynamically reprogrammed to use any of these programmed encryption keys to en/decrypt a particular request. This makes this new class of storage ideal for supporting fscrypt (file-based encryption). Unfortunately, there isn’t currently a unified approach for supporting inline encryption hardware in the Linux kernel.

We’ve sent out an RFC patchset to add support for inline encryption to the block subsystem, UFS driver, f2fs, and fscrypt
(https://www.spinics.net/lists/linux-block/msg40330.html).
We’ll discuss our approach including:

How the filesystem communicates an encryption key to inline
encryption hardware for each struct bio it submits.
How to add support for inline encryption to storage drivers.
Support for layered devices like device mapper.
A software crypto fallback.
How this work can make future encryption tasks cleaner - like
metadata encryption, file-based encryption on removable storage and
the possibility of unifying how fscrypt, dm-crypt, and eCryptfs
implement encryption.
Captions: 
	00:00:00,250 --> 00:00:02,420
- Hi guys, I'm Satya, I work at Google

00:00:02,420 --> 00:00:04,450
on the platform security team

00:00:04,450 --> 00:00:07,700
and I've been working on adding inline encryption support

00:00:07,700 --> 00:00:08,563
to the kernel.

00:00:09,470 --> 00:00:13,618
So, motivation, why do you want to do inline encryption?

00:00:13,618 --> 00:00:16,374
Why do we want inline encryption support in the kernel?

00:00:16,374 --> 00:00:18,015
Well actually let's start at,

00:00:18,015 --> 00:00:19,965
why do we want to do encryption at all?

00:00:21,430 --> 00:00:23,510
'Cause it turns out, our users want their data

00:00:23,510 --> 00:00:24,940
to be secure and private.

00:00:24,940 --> 00:00:27,240
I would hope that's not a surprise to anybody.

00:00:28,540 --> 00:00:30,670
We want to make sure that if you lose the phone

00:00:30,670 --> 00:00:33,605
or it's stolen, someone else can't just go through

00:00:33,605 --> 00:00:35,900
all the bank passwords and your large secret collection

00:00:35,900 --> 00:00:39,060
of cat videos, so one way that we protect our user's data

00:00:39,060 --> 00:00:42,263
on Android is by encrypting the data before storing it.

00:00:43,991 --> 00:00:46,215
And inline encryption, which I'll go into

00:00:46,215 --> 00:00:47,460
a lot more detail about, is a way

00:00:47,460 --> 00:00:49,053
of speeding up this encryption.

00:00:50,530 --> 00:00:52,350
Many vendors make inline encryption hardware

00:00:52,350 --> 00:00:54,900
and each of them has had their own set of patches

00:00:54,900 --> 00:00:57,170
that support inline encryption,

00:00:57,170 --> 00:00:58,980
but none of them have been upstream so far.

00:00:58,980 --> 00:01:02,156
So every year, these vendors and also as does Google,

00:01:02,156 --> 00:01:04,700
because we ship phones with such inline encryption hardware

00:01:04,700 --> 00:01:08,191
have to maintain and rebase these inline encryption patches.

00:01:08,191 --> 00:01:10,610
So we'd really like to have an upstream solution

00:01:10,610 --> 00:01:14,010
that's designed in a way to reduce the total overall burden

00:01:14,010 --> 00:01:14,863
on everyone.

00:01:16,170 --> 00:01:18,560
Either with our upstream solution, inline encryption vendors

00:01:18,560 --> 00:01:21,350
will need to maintain, at most, a small part

00:01:21,350 --> 00:01:25,450
of the storage driver, rather than their entire

00:01:25,450 --> 00:01:29,170
inline encryption pass sets which most parts

00:01:29,170 --> 00:01:30,733
of the storage stack today.

00:01:32,540 --> 00:01:35,460
Another reason for a unified approach to inline encryption

00:01:35,460 --> 00:01:38,100
is the generic kernel image or GKI project

00:01:38,100 --> 00:01:40,220
and what it's pursuing.

00:01:40,220 --> 00:01:43,235
GKI essentially requires Android phone to boot up

00:01:43,235 --> 00:01:46,386
and be completely usable with just the GKI.

00:01:46,386 --> 00:01:48,950
A generic system image built on top of GKI

00:01:48,950 --> 00:01:52,083
and some specific kernel modules.

00:01:52,083 --> 00:01:55,930
In particular, inline encryption hardware must also

00:01:55,930 --> 00:02:00,150
be supported by GKI and since inline encryption requires

00:02:00,150 --> 00:02:02,750
changes to the base kernel, it can't be done purely

00:02:02,750 --> 00:02:05,560
with some vendor-specific modules.

00:02:05,560 --> 00:02:08,993
Again, we need this unified approach to inline encryption.

00:02:12,070 --> 00:02:16,420
Onto FDE, FBE and fscrypt, that's a lot of acronyms.

00:02:16,420 --> 00:02:19,250
So on Android, we used to require support for

00:02:19,250 --> 00:02:22,410
full disk encryption, FDE awhile back.

00:02:22,410 --> 00:02:24,990
All data on the disc was encrypted with the same key.

00:02:24,990 --> 00:02:27,410
So you just had to provide the key at boot-time

00:02:27,410 --> 00:02:29,840
and before this key was provided, the system couldn't

00:02:29,840 --> 00:02:33,606
do things like receive texts or alarms, et-cetera.

00:02:33,606 --> 00:02:36,600
So we're talking about a lot more flexible than this.

00:02:36,600 --> 00:02:38,910
Something that will let us boot into user space

00:02:38,910 --> 00:02:41,820
and ring alarms, for example, even before a user

00:02:41,820 --> 00:02:43,450
has provided their password.

00:02:43,450 --> 00:02:45,980
And to that end, we wanted to be able to encrypt

00:02:45,980 --> 00:02:48,680
different parts of the filesystem with different keys.

00:02:49,520 --> 00:02:52,630
So this leads us to the current encryption solution

00:02:52,630 --> 00:02:55,817
we have on the on Android, which is file-based encryption

00:02:55,817 --> 00:03:00,220
FBE, the added effect is to have per-file encryption keys

00:03:00,220 --> 00:03:03,140
well, really encryption context that contains all

00:03:03,140 --> 00:03:06,730
the information you need to encrypt or decrypt the key,

00:03:06,730 --> 00:03:08,570
the crypto algorithm you're using,

00:03:08,570 --> 00:03:10,170
the data unit number, and so on.

00:03:11,622 --> 00:03:15,300
This approach was taken to EXT4 about four years ago

00:03:15,300 --> 00:03:17,690
and sometime later, F2FS began to support it

00:03:17,690 --> 00:03:21,080
and the common crypto code between EXT4 and F2FS

00:03:21,080 --> 00:03:23,050
was factored out into fscrypt.

00:03:23,050 --> 00:03:26,910
And filesystems like EXT4, F2FS and UBFS

00:03:26,910 --> 00:03:29,780
call into fscrypt to perform crypto operations

00:03:30,667 --> 00:03:32,640
whenever they need to and they maintain information

00:03:32,640 --> 00:03:35,600
about the encryption context for each file

00:03:35,600 --> 00:03:39,063
and this is how FBE with fscrypt works.

00:03:40,370 --> 00:03:43,850
So in the Linux storage stack, struct bios are basically

00:03:43,850 --> 00:03:46,420
the front data transfer and they essentially

00:03:47,399 --> 00:03:50,120
describe the location in memory to read from

00:03:50,120 --> 00:03:52,400
or write to, a location on the block device

00:03:52,400 --> 00:03:56,210
to write to or read from, a size, and the type of operation

00:03:56,210 --> 00:03:58,200
for example, a read or a write.

00:03:58,200 --> 00:04:00,660
So when filesystems want to write an encrypted file

00:04:00,660 --> 00:04:03,090
they construct one of many such struct bios

00:04:03,090 --> 00:04:05,770
and encrypt the data in these bios by calling fscrypt

00:04:05,770 --> 00:04:08,970
the encryption context and submit the bios

00:04:08,970 --> 00:04:10,000
to the block there.

00:04:10,000 --> 00:04:13,560
The bio goes down the stack and data will eventually

00:04:13,560 --> 00:04:17,003
be written to the storage drivers and the storage hardware.

00:04:17,950 --> 00:04:20,210
When filesystems want to read an encrypted file

00:04:20,210 --> 00:04:22,450
they construct the same struct bios and submit them

00:04:22,450 --> 00:04:25,340
to the block there first and when the read is completed

00:04:25,340 --> 00:04:28,050
and the bio comes back to the filesystem, the filesystem

00:04:28,050 --> 00:04:30,470
then calls in fscrypt with the encryption context

00:04:30,470 --> 00:04:33,338
to decrypt the data in those bios.

00:04:33,338 --> 00:04:35,940
In other case, note that the encryption context

00:04:35,940 --> 00:04:38,470
is only needed above this redline, only fscrypt needs

00:04:38,470 --> 00:04:40,449
to know what the encryption context is

00:04:40,449 --> 00:04:43,673
for the data on a particular bio.

00:04:44,597 --> 00:04:46,720
Now onto inline encryption.

00:04:46,720 --> 00:04:50,076
So, on Android, we make use of fscrypt to support

00:04:50,076 --> 00:04:55,076
file based encryption and inline encryption hardware

00:04:55,640 --> 00:04:57,773
is the way to speed up encryption with FB.

00:05:02,165 --> 00:05:04,580
All right, so with inline encryption hardware

00:05:04,580 --> 00:05:07,786
in the picture, this is what the storage stack looks like.

00:05:07,786 --> 00:05:10,140
Inline encryption hardware sits right before

00:05:10,140 --> 00:05:13,740
the storage hardware in red and it can encrypt

00:05:13,740 --> 00:05:15,673
or decrypt data going through it.

00:05:17,410 --> 00:05:19,970
So inline encryption hardware has a small number

00:05:19,970 --> 00:05:22,760
of programmable keyslots and each keyslot can be programmed

00:05:22,760 --> 00:05:25,257
to hold an encryption context on the fly

00:05:25,257 --> 00:05:27,770
and any data request that flows through

00:05:27,770 --> 00:05:30,789
inline encryption hardware, can be tagged with a keyslot

00:05:30,789 --> 00:05:33,240
and the inline encryption hardware will encrypt

00:05:33,240 --> 00:05:35,200
or decrypt the data with the encryption context

00:05:35,200 --> 00:05:37,240
that's currently programmed into the keyslot.

00:05:37,240 --> 00:05:39,610
So this makes inline encryption hardware well-suited

00:05:39,610 --> 00:05:42,490
to accelerated FBE and offload FBE related work

00:05:42,490 --> 00:05:43,430
from the CPU.

00:05:45,360 --> 00:05:48,140
Note that inline encryption hardware is distinct

00:05:48,140 --> 00:05:50,930
from self-encrypting drives and OPAL, which have existed

00:05:50,930 --> 00:05:52,560
for quite awhile now.

00:05:52,560 --> 00:05:54,720
These technologies also encrypt and decrypt data

00:05:54,720 --> 00:05:57,080
as it flows from memory into the disk.

00:05:57,080 --> 00:06:00,950
So the data flow diagram will look similar

00:06:00,950 --> 00:06:03,310
but these technologies essentially have a single key

00:06:03,310 --> 00:06:05,620
for all the data on the disk so all data going into

00:06:05,620 --> 00:06:07,610
the disk is encrypted with essentially the same key.

00:06:07,610 --> 00:06:10,600
This is a stark contrast to capabilities

00:06:10,600 --> 00:06:12,170
that inline encryption hardware provides,

00:06:12,170 --> 00:06:15,023
where data in the individual struct bio

00:06:15,023 --> 00:06:17,683
can be encrypted with a different key.

00:06:18,656 --> 00:06:21,150
And whereas for self-encrypting drives,

00:06:21,150 --> 00:06:23,910
software simply provides a password that allows access

00:06:23,910 --> 00:06:26,810
to the disk encryption key, for inline encryption hardware

00:06:26,810 --> 00:06:29,701
software provides the raw key itself that will be used

00:06:29,701 --> 00:06:31,473
for the data encryption.

00:06:33,807 --> 00:06:35,050
And so here's the context of the problem

00:06:35,050 --> 00:06:36,153
that we're addressing.

00:06:37,499 --> 00:06:40,715
Linux doesn't currently have support for inline encryption

00:06:40,715 --> 00:06:43,440
and a need for vendors with inline encryption hardware

00:06:43,440 --> 00:06:46,163
have different patches to support their hardware.

00:06:47,260 --> 00:06:49,150
There have been a number of approaches our partners use

00:06:49,150 --> 00:06:51,940
and some of them try to upstream their patches

00:06:51,940 --> 00:06:54,690
but none of them were well-received by upstream so far.

00:06:55,719 --> 00:06:58,550
We already have fscrypt, which uses the ability

00:06:58,550 --> 00:07:00,960
to associate a file with an encryption context

00:07:00,960 --> 00:07:03,350
which is something you can continue to use.

00:07:03,350 --> 00:07:05,150
But now, most of the storage stack

00:07:05,150 --> 00:07:07,450
needs to be of inline encryption.

00:07:07,450 --> 00:07:09,960
For example, the request layer which merges to bios

00:07:09,960 --> 00:07:12,461
that read or write from recent locations on disk

00:07:12,461 --> 00:07:16,130
needs to now also ensure that the two bios

00:07:16,130 --> 00:07:18,980
that it's going to merge have the same encryption context.

00:07:18,980 --> 00:07:21,380
For the encryption context for a struct bio,

00:07:21,380 --> 00:07:22,990
someone needs to be communicated

00:07:22,990 --> 00:07:25,620
to the inline encryption hardware down in the stack

00:07:25,620 --> 00:07:27,727
so that it knows how to actually encrypt,

00:07:27,727 --> 00:07:30,383
what key to use to encrypt the bio.

00:07:32,040 --> 00:07:33,780
And as I mentioned, there have already

00:07:33,780 --> 00:07:36,280
been many past attempts to solve the problem.

00:07:36,280 --> 00:07:38,380
One main issue with some of the past attempts

00:07:38,380 --> 00:07:40,460
were layering validations.

00:07:40,460 --> 00:07:43,320
They also made some non-generic assumptions

00:07:43,320 --> 00:07:46,130
like assuming the number of keyslots present in the

00:07:47,410 --> 00:07:49,247
present hardware was at least the size

00:07:49,247 --> 00:07:51,800
of the SCSI queue length for the UFS device,

00:07:51,800 --> 00:07:55,500
and this was true of the hardware the patch was targeting

00:07:55,500 --> 00:07:58,333
but no such guarantee exists for other hardware.

00:07:59,870 --> 00:08:02,210
And it had some other hardware-specific code.

00:08:02,210 --> 00:08:03,790
Some other approaches involved

00:08:03,790 --> 00:08:06,080
representing inline encryption as a kernel crypto

00:08:06,080 --> 00:08:07,290
API algorithm.

00:08:07,290 --> 00:08:10,490
We think that the kernel crypto API algorithms

00:08:10,490 --> 00:08:12,980
are fundamentally different from inline encryption

00:08:12,980 --> 00:08:15,290
because the kernel crypto API does transformations

00:08:15,290 --> 00:08:17,855
from memory to memory while inline encryption

00:08:17,855 --> 00:08:20,170
does transformations from memory to disk

00:08:20,170 --> 00:08:21,870
and specifically only to the disk

00:08:21,870 --> 00:08:23,713
that the hardware is hardwired to.

00:08:25,250 --> 00:08:28,320
All right, so moving on to high level objectives.

00:08:28,320 --> 00:08:31,070
Our main design objective was to make our approach useful

00:08:31,070 --> 00:08:33,840
to any inline encryption hardware, rather than just

00:08:33,840 --> 00:08:37,100
for some particular storage drivers or some particular

00:08:37,100 --> 00:08:39,380
inline encryption hardware.

00:08:39,380 --> 00:08:41,730
This means that we want it to be possible and hopefully

00:08:41,730 --> 00:08:44,380
also easy to add support for our approach

00:08:44,380 --> 00:08:47,939
to inline encryption to any storage driver.

00:08:47,939 --> 00:08:50,490
One of the considerations here is that we'll need

00:08:50,490 --> 00:08:52,920
to be able to handle the case where we have more

00:08:52,920 --> 00:08:55,110
encryption contexts in-flight than we have keyslots

00:08:55,110 --> 00:08:56,830
for the hardware.

00:08:56,830 --> 00:08:58,700
One issue is that programming a keyslot

00:08:58,700 --> 00:09:00,940
with encryption contexts might be expensive

00:09:00,940 --> 00:09:03,970
on certain hardware and further bios are serviced

00:09:03,970 --> 00:09:06,200
by storage drivers asynchronously, so it's possible

00:09:06,200 --> 00:09:08,930
for filesystems to submit say, a hundred bios

00:09:08,930 --> 00:09:11,386
with 50 unique encryption contexts in total

00:09:11,386 --> 00:09:13,930
at pretty much the same time and if our inline encryption

00:09:13,930 --> 00:09:16,180
hardware only supports 30 new keyslots,

00:09:16,180 --> 00:09:20,430
then we'll need a way to make 50 unique encryption contexts

00:09:20,430 --> 00:09:23,039
share those 30 new keyslots

00:09:23,039 --> 00:09:25,583
while also making sure that any two bios

00:09:25,583 --> 00:09:29,160
with the same encryption context share the same keyslot

00:09:29,160 --> 00:09:31,150
instead of duplicating the same encryption context

00:09:31,150 --> 00:09:32,853
across multiple keyslots.

00:09:34,350 --> 00:09:37,950
Also even within devices using the same storage driver

00:09:37,950 --> 00:09:40,900
for example, UFS, inline encryption hardware

00:09:40,900 --> 00:09:43,160
from one vendor may work differently

00:09:43,160 --> 00:09:45,050
from those of other vendors.

00:09:45,050 --> 00:09:46,940
So we want to make it easy for vendors

00:09:46,940 --> 00:09:49,290
to extend support for their own particular hardware

00:09:49,290 --> 00:09:52,190
such extensions are necessary if their hardware

00:09:52,190 --> 00:09:53,390
has certain quirks, say.

00:09:54,510 --> 00:09:57,250
We also want to make it easy for any filesystem

00:09:58,654 --> 00:10:01,420
to make use of an encryption hardware, when it's available.

00:10:01,420 --> 00:10:04,430
Obviously, it would be bad to require users to use

00:10:04,430 --> 00:10:08,160
a particular filesystem if they want

00:10:08,160 --> 00:10:09,410
to use inline encryption.

00:10:10,470 --> 00:10:12,800
And one more thing that we want to have is a fallback

00:10:12,800 --> 00:10:16,190
to the kernel crypto API in case inline encryption hardware

00:10:16,190 --> 00:10:17,590
isn't available on a system.

00:10:19,560 --> 00:10:22,283
Onto the changes that the patches introduce.

00:10:23,180 --> 00:10:25,410
So as I mentioned before, most of the storage stack

00:10:25,410 --> 00:10:27,370
now needs to be encryption-aware

00:10:27,370 --> 00:10:30,070
and needs to know what the encryption context is

00:10:30,070 --> 00:10:33,420
for any given bio, so we'll add a field to struct bio

00:10:33,420 --> 00:10:36,910
a struct bio-crypt-ctx that can present

00:10:36,910 --> 00:10:39,210
an encryption context so that we can pass

00:10:39,210 --> 00:10:40,830
the encryption context down the stack

00:10:40,830 --> 00:10:41,780
along with the bio.

00:10:43,030 --> 00:10:45,460
We'll also introduce a keyslot manager to solve

00:10:45,460 --> 00:10:47,230
all the issues of sharing keyslots

00:10:47,230 --> 00:10:49,030
between encryption contexts.

00:10:49,030 --> 00:10:51,620
It'll ensure that each unique encryption context

00:10:51,620 --> 00:10:53,860
is programmed into only a single keyslot

00:10:53,860 --> 00:10:56,840
and will maintain refcounts for the keyslots.

00:10:56,840 --> 00:10:59,820
It'll also evict unused keyslots if there are no empty

00:10:59,820 --> 00:11:02,750
keyslots to program a new encryption context into.

00:11:02,750 --> 00:11:04,310
And if all the keyslots are busy,

00:11:04,310 --> 00:11:06,380
then it'll make the threads key until the keyslot

00:11:06,380 --> 00:11:07,603
does become available.

00:11:08,850 --> 00:11:11,300
So we add a new field, a struct keyslot manager

00:11:11,300 --> 00:11:14,025
to the request queue of each device.

00:11:14,025 --> 00:11:17,060
So the keyslot manager will also act as the interface

00:11:17,060 --> 00:11:20,033
between the inline encryption hardware and the block layer.

00:11:21,490 --> 00:11:24,130
So for each bio, we'll program it's encryption context

00:11:24,130 --> 00:11:26,987
into a keyslot when it's submitted to the block layer.

00:11:26,987 --> 00:11:29,920
The block layer will call, get_keyslot on a keyslot manager

00:11:29,920 --> 00:11:32,280
and pass it an encryption context.

00:11:32,280 --> 00:11:35,110
The keyslot manager will eventually return a keyslot

00:11:35,110 --> 00:11:36,600
that has been programmed with the specified

00:11:36,600 --> 00:11:38,570
encryption context and increment a refcount

00:11:38,570 --> 00:11:39,420
for that keyslot.

00:11:40,787 --> 00:11:43,640
And of course, the keyslot manager also needs to somehow

00:11:43,640 --> 00:11:45,880
know how to program and evict keyslots

00:11:45,880 --> 00:11:48,780
on the actual hardware it's associated with.

00:11:48,780 --> 00:11:50,930
So it's the storage driver's responsibility

00:11:52,031 --> 00:11:55,240
to set up the keyslot manager in its request queue

00:11:55,240 --> 00:11:57,470
and pass it a bunch of function pointers

00:11:57,470 --> 00:11:59,850
that will allow the keyslot manager to do things like

00:11:59,850 --> 00:12:02,953
program and affect encryption contexts.

00:12:04,700 --> 00:12:07,290
So to truly make the changes to the block layer

00:12:07,290 --> 00:12:11,300
and make it program encryption contexts into keyslots

00:12:11,300 --> 00:12:13,390
as well as to achieve a few more goals,

00:12:13,390 --> 00:12:16,850
we introduce blk-crypto which logically sits

00:12:16,850 --> 00:12:19,504
between the block layer and the request layer

00:12:19,504 --> 00:12:23,934
and given a bio, it will call the keyslot manager

00:12:23,934 --> 00:12:26,880
in the request queue that the bio has just in for

00:12:26,880 --> 00:12:29,683
and gets a keyslot for the bio's encryption context.

00:12:31,760 --> 00:12:35,630
So blk-crypto also contains a kernel crypto API fallback

00:12:35,630 --> 00:12:38,897
for when inline encryption is not available.

00:12:38,897 --> 00:12:40,920
The fallback to this vendor request queue

00:12:40,920 --> 00:12:43,407
does not have a keyslot manager setup,

00:12:43,407 --> 00:12:45,900
or if we fail to program an encryption context

00:12:45,900 --> 00:12:47,670
into a keyslot manager.

00:12:47,670 --> 00:12:51,100
This fallback lets us present a single unified way

00:12:51,100 --> 00:12:53,150
of doing data encryption to filesystems

00:12:53,150 --> 00:12:55,144
so that filesystems don't have to worry about

00:12:55,144 --> 00:12:59,540
whether the underlying device has inline encryption hardware

00:12:59,540 --> 00:13:01,830
or not and it can always rely

00:13:01,830 --> 00:13:04,823
on the block layer for data encryption.

00:13:06,610 --> 00:13:09,020
So blk-crypto can also handle stacked devices

00:13:09,020 --> 00:13:13,150
for example, when they target device for a bio

00:13:13,150 --> 00:13:16,410
is a DM device that maps over multiple devices,

00:13:16,410 --> 00:13:18,800
each of which it may have possibly

00:13:18,800 --> 00:13:20,960
varying inline encryption capabilities

00:13:20,960 --> 00:13:24,160
as long as the DM device itself sets up a keyslot manager

00:13:24,160 --> 00:13:25,223
in its request queue.

00:13:26,160 --> 00:13:29,120
So when the bio is first submitted from the filesystem

00:13:29,120 --> 00:13:31,620
blk-crypto will program the encryption context

00:13:31,620 --> 00:13:34,744
into the DM device's keyslot manager

00:13:34,744 --> 00:13:38,400
and when the DM device gets the bio and passes it back

00:13:38,400 --> 00:13:40,790
to the block layer, blk-crypto will release

00:13:40,790 --> 00:13:43,880
that keyslot in the DM's keyslot manager

00:13:43,880 --> 00:13:47,240
and program that encryption context into the keyslot manager

00:13:47,240 --> 00:13:49,320
of the underlying device.

00:13:49,320 --> 00:13:51,773
And further cloning a bio with an encryption context

00:13:51,773 --> 00:13:53,820
will also clone the encryption context

00:13:53,820 --> 00:13:55,370
and if the source bio has the keyslot

00:13:55,370 --> 00:13:58,620
for its encryption context already, then the clone will also

00:13:58,620 --> 00:14:01,310
take its own ref count to the same keyslot.

00:14:01,310 --> 00:14:02,990
So even if the DM device clones the bio

00:14:02,990 --> 00:14:04,984
instead of just resubmitting the original bio,

00:14:04,984 --> 00:14:07,163
things will still work out fine.

00:14:08,440 --> 00:14:11,060
Now because blk-crypto has a kernel crypto fallback

00:14:11,060 --> 00:14:14,240
it can also handle strange cases like, a DM device

00:14:14,240 --> 00:14:16,710
that maps over two devices, one of which

00:14:16,710 --> 00:14:18,420
has inline encryption hardware,

00:14:18,420 --> 00:14:20,260
while the other one does not.

00:14:20,260 --> 00:14:22,420
Now there's still the issue that we will be allocating

00:14:22,420 --> 00:14:25,800
essentially a dummy keyslot manager with some sufficiently

00:14:25,800 --> 00:14:28,000
large number of keyslots which will waste memory,

00:14:28,000 --> 00:14:29,763
but we will fix that problem too.

00:14:30,620 --> 00:14:32,490
So to fix that problem, we'll introduce

00:14:32,490 --> 00:14:35,060
the passthrough keyslot manager

00:14:35,060 --> 00:14:37,690
which does not actually manage any keyslots

00:14:39,690 --> 00:14:41,303
and so doesn't use much memory.

00:14:43,170 --> 00:14:46,150
It also does not need any function pointers to manipulate

00:14:46,150 --> 00:14:48,570
inline encryption hardware, like a function to program

00:14:48,570 --> 00:14:50,540
keys into keyslots, for example.

00:14:50,540 --> 00:14:52,680
It still needs a function pointer that allows

00:14:52,680 --> 00:14:55,190
the upper layers to query which algorithm

00:14:55,190 --> 00:14:57,930
the inline encryption hardware supports.

00:14:57,930 --> 00:15:00,593
So blk-crypto will simply do nothing if it sees

00:15:00,593 --> 00:15:02,580
that a request queue's keyslot manager

00:15:02,580 --> 00:15:05,170
is actually a passthrough keyslot manager.

00:15:05,170 --> 00:15:07,880
So it won't try to program a struct bios encryption key

00:15:07,880 --> 00:15:09,640
into any keyslot, anywhere,

00:15:09,640 --> 00:15:12,740
and it'll just let the struct bio go down the stack.

00:15:12,740 --> 00:15:14,780
It's up to whoever is processing that bio

00:15:14,780 --> 00:15:17,630
to handle the encryption key in the bio, if it's present.

00:15:18,680 --> 00:15:21,400
So in the case of a device mapper, a DM device

00:15:21,400 --> 00:15:23,470
can set up a passthrough keyslot manager instead

00:15:23,470 --> 00:15:26,730
of a regular one with a large enough number of keyslots

00:15:26,730 --> 00:15:28,470
which will save a lot of memory.

00:15:28,470 --> 00:15:30,860
The encryption context will simply go unmodified

00:15:30,860 --> 00:15:34,170
to the DM device and will be resubmitted to blk-crypto

00:15:34,170 --> 00:15:37,320
and the bio will be resubmitted to blk-crypto

00:15:37,320 --> 00:15:39,100
with the same encryption context again

00:15:39,100 --> 00:15:41,790
and this encryption context will eventually get programmed

00:15:41,790 --> 00:15:45,370
into real inline encryption hardware as in this example,

00:15:45,370 --> 00:15:48,920
or maybe even fallback to the kernel crypto API

00:15:48,920 --> 00:15:50,263
if ultimately necessary.

00:15:52,090 --> 00:15:54,530
Also, so far, I've talked about inline encryption hardware

00:15:54,530 --> 00:15:56,600
that have a limited number of keyslots

00:15:56,600 --> 00:15:59,380
and data requests are tagged with a keyslot

00:15:59,380 --> 00:16:02,350
to perform encryption, but some inline encryption hardware

00:16:02,350 --> 00:16:04,960
actually allow data to be tagged with the key itself.

00:16:04,960 --> 00:16:08,040
So keys don't ever need to be programmed into keyslots

00:16:08,040 --> 00:16:10,510
for such hardware, so the passthrough keyslot manager

00:16:10,510 --> 00:16:13,990
is also useful for these types of inline encryption hardware

00:16:13,990 --> 00:16:16,450
that don't only have a limited number of keyslots

00:16:16,450 --> 00:16:17,900
and would benefit from being able

00:16:17,900 --> 00:16:19,450
to work directly with the keys.

00:16:21,100 --> 00:16:23,300
So because of what blk-crypto does for us,

00:16:23,300 --> 00:16:26,880
the interface that we can present to filesystems

00:16:26,880 --> 00:16:29,420
becomes a lot simpler, as filesystems don't need to worry

00:16:29,420 --> 00:16:31,532
about keyslots, so here's the interface

00:16:31,532 --> 00:16:35,095
to inline encryption that we present to filesystems.

00:16:35,095 --> 00:16:37,830
A filesystem only needs to do the following three things.

00:16:37,830 --> 00:16:39,640
First thing it needs to do is for each bio

00:16:39,640 --> 00:16:42,970
it submits that it wants to use inline encryption for

00:16:42,970 --> 00:16:45,630
it should set up a bio_crypt_ctx for the bio

00:16:45,630 --> 00:16:49,160
by calling bio_crypt_set_context on the bio

00:16:49,160 --> 00:16:51,290
with the key, the algorithm, and all the other things

00:16:51,290 --> 00:16:54,260
it needs to actually do encryption.

00:16:54,260 --> 00:16:55,640
And this function will allocate memory

00:16:55,640 --> 00:16:57,110
for a bio_crypt_context using

00:16:57,110 --> 00:16:59,133
a mempool associated with the bio.

00:17:00,430 --> 00:17:02,980
The second thing it needs to do is, at some point,

00:17:02,980 --> 00:17:06,250
not from the datapath, before a bios constructors

00:17:06,250 --> 00:17:08,120
from the pages of an inode and submitted,

00:17:08,120 --> 00:17:11,650
the filesystem should call blk_crypto_start_using_mode

00:17:11,650 --> 00:17:14,490
on the algorithm and the request queue

00:17:14,490 --> 00:17:16,753
where algorithm is the crypto algorithm that the inode

00:17:16,753 --> 00:17:19,810
is going to be encrypted with and the request queue

00:17:19,810 --> 00:17:22,720
is the request queue that the bio will be submitted to.

00:17:22,720 --> 00:17:26,308
So this function will set up the kernel crypto API fallback

00:17:26,308 --> 00:17:29,336
if it might ultimately become necessary.

00:17:29,336 --> 00:17:32,483
If the request queue doesn't actually support the algorithm.

00:17:33,710 --> 00:17:36,190
And the last thing it needs to do is tear down

00:17:36,190 --> 00:17:39,260
the bio crypt context for a bio after the bio has ended

00:17:39,260 --> 00:17:41,603
by calling bio_crypt_free_context on the bio.

00:17:42,592 --> 00:17:45,210
Now here's what storage drivers on the other end

00:17:45,210 --> 00:17:47,520
of the chain need to do

00:17:47,520 --> 00:17:50,020
to make use of our design of inline encryption.

00:17:50,020 --> 00:17:52,410
Firstly, they'll need to setup a keyslot manager

00:17:52,410 --> 00:17:54,130
in their device's request queue

00:17:54,130 --> 00:17:57,080
by calling keyslot_manager_create with the number

00:17:57,080 --> 00:17:58,860
of keyslots that the hardware supports

00:18:00,614 --> 00:18:03,910
and a bunch of function pointers that let the keyslot manger

00:18:03,910 --> 00:18:07,300
actually program an encryption context into any arbitrary

00:18:07,300 --> 00:18:10,922
keyslot in the hardware also a way to evict slots

00:18:10,922 --> 00:18:15,030
and find program encryption contexts and so on

00:18:15,030 --> 00:18:16,823
and also a pointer to any arbitrary private data

00:18:16,823 --> 00:18:18,603
that the driver wants.

00:18:19,730 --> 00:18:22,620
Then whenever they process a request, they can retrieve

00:18:22,620 --> 00:18:25,870
the keyslot that blk-crypto programmed the bios encryption

00:18:25,870 --> 00:18:28,190
context into, by calling bio_crypt_get_keyslot

00:18:28,190 --> 00:18:30,880
on the first bio in the request.

00:18:30,880 --> 00:18:33,740
Alternatively, they can set up a passthrough keyslot manager

00:18:33,740 --> 00:18:35,200
and whenever they process a request,

00:18:35,200 --> 00:18:37,040
they can directly retrieve the encryption context

00:18:37,040 --> 00:18:39,843
of a bio from its struct bio_crypt_ctx.

00:18:41,280 --> 00:18:43,880
All right, so as part of the patch series

00:18:43,880 --> 00:18:46,610
and as proof of concept of the rest of the design,

00:18:46,610 --> 00:18:49,131
we add support for inline encryption

00:18:49,131 --> 00:18:51,290
through the UFS storage driver

00:18:51,290 --> 00:18:54,690
and we followed the UFSHCD v2.1 spec

00:18:54,690 --> 00:18:57,383
which introduced inline encryption to UFS.

00:18:58,360 --> 00:19:01,830
So the UFS driver in Linux is organized as follows.

00:19:01,830 --> 00:19:04,810
There is a base UFS code, that contains a lot of the common

00:19:04,810 --> 00:19:07,630
functionality and there are vendor-specific drivers

00:19:07,630 --> 00:19:10,530
that call into the base code and we added

00:19:10,530 --> 00:19:12,760
the inline encryption support following

00:19:12,760 --> 00:19:15,360
the aforementioned UFSHCD specification

00:19:15,360 --> 00:19:16,560
to the base code itself.

00:19:17,520 --> 00:19:22,090
We also introduce what we call the crypto variant operations

00:19:22,090 --> 00:19:24,530
which are essentially functions that a vendor specific

00:19:24,530 --> 00:19:27,760
driver can register ahead of time with the base code,

00:19:27,760 --> 00:19:30,380
that the base code will call instead of the implementation

00:19:30,380 --> 00:19:32,950
that follows a specification that we added.

00:19:32,950 --> 00:19:35,490
So vendors can easily override or extend how their hardware

00:19:35,490 --> 00:19:38,083
is manipulated if their hardware has some quirks.

00:19:40,010 --> 00:19:42,570
Then we also add support for our design of inline encryption

00:19:42,570 --> 00:19:44,955
to fscrypt and to F2FS so that we have

00:19:44,955 --> 00:19:48,233
a complete stack that is inline encryption capable.

00:19:49,280 --> 00:19:51,660
We add a new policy to fscrypt that defines

00:19:51,660 --> 00:19:55,264
a new on-disk format to optimize

00:19:55,264 --> 00:19:56,920
the way inline encryption works

00:19:56,920 --> 00:19:58,780
and how keys are managed with it.

00:19:58,780 --> 00:20:03,440
And we also throw in the changes to the DM layer

00:20:03,440 --> 00:20:06,730
that let them use inline encryption as a context

00:20:06,730 --> 00:20:08,530
for the passthrough keyslot manager.

00:20:10,310 --> 00:20:12,860
So on to testing and status of our partners

00:20:12,860 --> 00:20:14,900
with respect to our approach.

00:20:14,900 --> 00:20:17,830
So we have Qualcomm and Mediatek who are onboard

00:20:17,830 --> 00:20:21,594
with our approach, variant operations

00:20:21,594 --> 00:20:24,790
have been very useful, especially where

00:20:24,790 --> 00:20:28,060
the UFS crypto specifications have been incomplete,

00:20:28,060 --> 00:20:30,520
especially with regards to power management.

00:20:30,520 --> 00:20:33,940
Both of these partners are currently testing our patches

00:20:33,940 --> 00:20:36,740
and we've also been testing the patches using XFS tests,

00:20:36,740 --> 00:20:38,090
by running all inline encryption

00:20:38,090 --> 00:20:40,680
through the kernel crypto API fallback

00:20:40,680 --> 00:20:42,490
and they've also been tested by backporting them

00:20:42,490 --> 00:20:45,480
to the Pixel 3 and using the inline encryption hardware

00:20:45,480 --> 00:20:47,923
that the UFS card on the device has.

00:20:49,240 --> 00:20:52,360
So future work, we still need to add support

00:20:52,360 --> 00:20:55,810
to the eMMC and other storage drivers.

00:20:55,810 --> 00:20:58,830
We'd also like to add support to other filesystems

00:20:58,830 --> 00:20:59,883
like EXT4.

00:21:00,940 --> 00:21:05,333
And thank you, any questions or comments?

00:21:06,250 --> 00:21:07,083
Yes?

00:21:09,820 --> 00:21:12,530
- [Audience Member] In 2018 there was a bug

00:21:12,530 --> 00:21:14,940
in Microsoft's bookkeeper that they were relying

00:21:14,940 --> 00:21:18,140
on hardware encryption, inline hardware encryption

00:21:18,140 --> 00:21:20,490
to encrypt a device, however the devices

00:21:20,490 --> 00:21:22,150
were doing absolutely nothing.

00:21:22,150 --> 00:21:25,040
Is there a way to, thank you.

00:21:25,040 --> 00:21:30,040
Is there a way to use your, you had some sort of

00:21:30,720 --> 00:21:32,820
back a few slides you had a...

00:21:33,960 --> 00:21:38,141
There, the quirk, hardware quirks to disable entire support

00:21:38,141 --> 00:21:42,180
for encryption, if such devices still exist?

00:21:42,180 --> 00:21:43,380
Which, they probably do?

00:21:49,406 --> 00:21:52,660
- Right, I mean, it's certainly possible to do it.

00:21:52,660 --> 00:21:55,850
I mean you can pretty much say, when you're trying to,

00:21:55,850 --> 00:21:58,150
one of the things that the crypto variant operations

00:21:58,150 --> 00:22:01,359
does let you override, is during the setup of the

00:22:01,359 --> 00:22:03,490
entire structures of the thing.

00:22:03,490 --> 00:22:07,200
So you can at least just say you don't support it at all.

00:22:07,200 --> 00:22:11,870
But more to the point of actually testing whether or not

00:22:13,290 --> 00:22:15,680
the hardware is actually doing the encryption,

00:22:15,680 --> 00:22:18,070
you can directly test that with this framework

00:22:18,070 --> 00:22:19,750
because you can just write something

00:22:19,750 --> 00:22:24,300
with a particular key and read it back without decrypting it

00:22:24,300 --> 00:22:26,570
and decrypt it in software or something to test

00:22:26,570 --> 00:22:29,660
whether it's doing the encryption as you expect it to.

00:22:29,660 --> 00:22:31,300
- [Audience Member] So on format, can we add a test

00:22:31,300 --> 00:22:32,310
to do that?

00:22:32,310 --> 00:22:33,143
- Sorry, on what?

00:22:33,143 --> 00:22:34,980
- [Audience Member] On format, on the first write

00:22:34,980 --> 00:22:38,260
to the disk, would it be viable to do something like that

00:22:38,260 --> 00:22:42,053
so it's tested at runtime?

00:22:43,060 --> 00:22:46,470
- Yes, so one thing we're considering is adding

00:22:46,470 --> 00:22:49,533
some sort of self-test module somewhere to actually do that.

00:22:50,500 --> 00:22:52,323
That's also future work.

00:22:56,190 --> 00:22:58,273
- [Audience Member] What's the user interface?

00:22:58,273 --> 00:23:01,260
- Okay so the user interface to this

00:23:01,260 --> 00:23:03,600
is essentially just the single policy flag

00:23:03,600 --> 00:23:06,250
that we've added to fscrypt.

00:23:06,250 --> 00:23:08,170
So if a user...

00:23:09,350 --> 00:23:12,323
Sorry, if user space wants to write a file

00:23:13,630 --> 00:23:16,630
and make use of inline encryption, they will simply

00:23:16,630 --> 00:23:20,040
need to create the file and set an fscrypt policy

00:23:20,040 --> 00:23:23,123
with the flag that says use inline encryption.

00:23:25,970 --> 00:23:27,840
- [Audience Member] Two questions, first one is

00:23:27,840 --> 00:23:29,152
roughly how many keyslots

00:23:29,152 --> 00:23:31,633
does this hardware typically support?

00:23:33,288 --> 00:23:34,410
- So about 32.

00:23:34,410 --> 00:23:36,390
- [Audience Member] Okay, interesting.

00:23:36,390 --> 00:23:37,870
The other question--

00:23:37,870 --> 00:23:39,580
- It does vary quite a bit. - Sure.

00:23:39,580 --> 00:23:41,120
- There exists some that have a single keyslot.

00:23:41,120 --> 00:23:45,510
It's a bit weird, but I think in general, 32 is normal.

00:23:45,510 --> 00:23:48,079
- [Audience Member] Okay, what about cipher modes?

00:23:48,079 --> 00:23:52,070
Does this hardware typically support say, cipher modes.

00:23:52,070 --> 00:23:54,492
Is it easy enough to have a software fallback

00:23:54,492 --> 00:23:59,441
that can result in the same file that you would

00:23:59,441 --> 00:24:01,810
if you're not using inline encryption?

00:24:01,810 --> 00:24:04,340
- Right so currently, you mean things support

00:24:04,340 --> 00:24:07,500
things like XTS, which is also supported

00:24:07,500 --> 00:24:12,500
by our kernel crypto API and they have CBC, I believe.

00:24:12,920 --> 00:24:14,580
It of course varies based on-- - It's pretty common.

00:24:14,580 --> 00:24:18,190
So if you're on a system that does support inline encryption

00:24:18,190 --> 00:24:21,930
and you use that for a couple years, can you move

00:24:21,930 --> 00:24:24,180
those files reliably to another system that maybe

00:24:24,180 --> 00:24:26,160
doesn't have the same inline encryption support

00:24:26,160 --> 00:24:27,490
and still use those?

00:24:27,490 --> 00:24:28,499
- The idea is, yes.

00:24:28,499 --> 00:24:30,641
You should be able to do it, because we have

00:24:30,641 --> 00:24:32,491
that kernel crypto fallback in place.

00:24:34,390 --> 00:24:35,480
- [Co-Presenter] Yeah I mean, in theory,

00:24:35,480 --> 00:24:38,497
one imagines some interface where you could force

00:24:38,497 --> 00:24:42,460
the use of the software crypto as opposed

00:24:42,460 --> 00:24:45,067
to the inline crypto, just to verify the hardware

00:24:45,067 --> 00:24:47,960
whether or not that's something that you do

00:24:47,960 --> 00:24:51,289
at development time or...

00:24:51,289 --> 00:24:52,550
- At runtime.

00:24:52,550 --> 00:24:54,500
- [Co-Presenter] Yeah on runtime on every single boot

00:24:54,500 --> 00:24:56,820
is I think a different question and I don't know

00:24:56,820 --> 00:24:59,780
that an interface has been defined to make that easy.

00:24:59,780 --> 00:25:02,019
I understand you did that for testing purposes, but.

00:25:02,019 --> 00:25:02,852
- Yeah.

00:25:08,410 --> 00:25:10,090
- [Audience Member] Apologies if I'm not fully

00:25:10,090 --> 00:25:13,280
understanding it but you mentioned much earlier

00:25:14,640 --> 00:25:17,190
the request queue and the extent to which

00:25:18,860 --> 00:25:21,700
having one block encrypted, one context versus another

00:25:21,700 --> 00:25:24,490
affects request merging and stuff.

00:25:24,490 --> 00:25:27,370
What changes were necessary for the request layer?

00:25:27,370 --> 00:25:29,782
Or maybe that's just completely transparent to it?

00:25:29,782 --> 00:25:32,710
What are the performance consequences for...

00:25:32,710 --> 00:25:35,560
- So the changes to the request layer is it now

00:25:35,560 --> 00:25:38,277
it needs to check whether they're both the same context

00:25:38,277 --> 00:25:40,060
and if not, don't merge it, right?

00:25:40,060 --> 00:25:41,160
That's about it, yeah.

00:25:42,900 --> 00:25:43,850
- [Co-Presenter] Yeah I think the bigger deal

00:25:43,850 --> 00:25:46,691
was the increase in the size of the struct bio

00:25:46,691 --> 00:25:49,800
and getting Jens to sign off on the acceptability

00:25:49,800 --> 00:25:50,633
of the same.

00:25:56,420 --> 00:25:58,920
- [Audience Member] Does this have any restriction

00:25:58,920 --> 00:26:00,863
on block size, writes?

00:26:02,597 --> 00:26:04,233
Or reads, I guess, as well.

00:26:05,220 --> 00:26:08,275
- As in restrictions--

00:26:08,275 --> 00:26:10,500
- [Audience Member] Do you require 4k block size for this?

00:26:10,500 --> 00:26:12,320
- No, it's not a requirement.

00:26:12,320 --> 00:26:15,870
Inline encryption doesn't mandate that you use

00:26:15,870 --> 00:26:18,320
4k block sizes, certain filesystems do.

00:26:18,320 --> 00:26:21,060
So F2FS, I think uses 4k block sizes.

00:26:21,060 --> 00:26:23,260
So that's what you'll have to use for F2FS.

00:26:23,260 --> 00:26:27,140
But otherwise there is no inherent restriction

00:26:27,140 --> 00:26:28,153
on block sizes.

00:26:30,330 --> 00:26:32,567
- [Co-Presenter] I think the current fscrypt helper layer

00:26:32,567 --> 00:26:36,080
has a restriction that block size and page size

00:26:36,080 --> 00:26:37,230
have to be the same.

00:26:37,230 --> 00:26:40,561
There is helper from IBM which has patches

00:26:40,561 --> 00:26:44,440
to relax that, and it actually has nothing to do

00:26:44,440 --> 00:26:47,050
with inline crypto, it's just he was interested

00:26:47,050 --> 00:26:50,500
in being able to support 4k filesystems with fscrypt

00:26:50,500 --> 00:26:53,300
on power, so those patches exist.

00:26:53,300 --> 00:26:54,850
They haven't been merged yet

00:26:54,850 --> 00:26:56,900
and that's largely Eric and my fault

00:26:56,900 --> 00:27:00,013
'cause we've been too busy with other things like that.

00:27:05,150 --> 00:27:08,367
- [Audience Member] So you compared it a little bit to

00:27:08,367 --> 00:27:12,330
SED and OPAL disks, do you have any idea

00:27:12,330 --> 00:27:14,950
early on for performance comparisons to those?

00:27:14,950 --> 00:27:17,450
Are you able to reach similar performance numbers?

00:27:18,950 --> 00:27:22,280
- So I haven't done any performance tests against that,

00:27:22,280 --> 00:27:25,430
but again I think these two things

00:27:25,430 --> 00:27:27,480
try to solve different needs, right?

00:27:27,480 --> 00:27:28,840
- [Audience Member] Definitely, yeah.

00:27:28,840 --> 00:27:30,264
- So SED is mostly about full disk encryption

00:27:30,264 --> 00:27:33,130
inline encryption hardware is really trying to optimize FBE.

00:27:33,130 --> 00:27:36,298
And I'm not sure if there is really comparable hardware.

00:27:36,298 --> 00:27:41,298
Mostly, inline encryption currently exists on phone SOCs,

00:27:41,330 --> 00:27:44,011
- [Audience Member] Right yeah, that makes sense.

00:27:44,011 --> 00:27:44,923
- A bit hard to really compare.

00:27:49,410 --> 00:27:51,047
- [Co-Presenter] Other questions?

00:27:55,480 --> 00:27:57,310
- [Audience Member] So when you're doing crypto

00:27:57,310 --> 00:28:02,130
you're normally chaining some aspect of the I/O blocks

00:28:02,130 --> 00:28:05,797
together so you don't have a dictionary attack on them.

00:28:05,797 --> 00:28:08,050
- Sorry, chaining what?

00:28:08,050 --> 00:28:11,390
- [Audience Member] So you normally got like a counter

00:28:11,390 --> 00:28:14,420
through, from one block to the next?

00:28:14,420 --> 00:28:15,253
- Uh huh.

00:28:15,253 --> 00:28:16,980
- [Audience Member] Is that still the case?

00:28:18,042 --> 00:28:19,217
- Sorry, I don't think I understood your question.

00:28:19,217 --> 00:28:23,330
- [Audience Member] Sorry, is the crypto key

00:28:23,330 --> 00:28:27,922
kind of seeded with a block counter or chaining.

00:28:27,922 --> 00:28:30,500
- [Co-Presenter] So are you asking about a CDC mode versus--

00:28:31,750 --> 00:28:32,743
- [Audience Member] Yeah.

00:28:33,960 --> 00:28:36,550
- Sorry, you're asking about crypto--

00:28:36,550 --> 00:28:39,580
- [Audience Member] Are you doing like cipher block chaining

00:28:39,580 --> 00:28:43,120
between one I/O block and the next?

00:28:43,120 --> 00:28:44,253
Or a counter mode?

00:28:47,521 --> 00:28:48,713
- [Co-Presenter] I believe it's XTS.

00:28:48,713 --> 00:28:51,260
- Yeah it's almost XTS, yes.

00:28:51,260 --> 00:28:52,260
So...

00:28:54,795 --> 00:28:56,650
- [Audience Member] Yeah so the reliability

00:28:56,650 --> 00:29:01,650
of the entire file is inherently on the block before it.

00:29:03,440 --> 00:29:06,503
And can you support seek modes?

00:29:06,503 --> 00:29:07,950
- Can you support?

00:29:07,950 --> 00:29:09,920
- [Audience Member] Can you seek to a position

00:29:09,920 --> 00:29:14,727
in the file without actually reading the entire file

00:29:15,600 --> 00:29:19,243
up until that point and still decrypt it?

00:29:20,405 --> 00:29:23,813
- I think so yes, I don't see why not.

00:29:26,614 --> 00:29:27,447
- [Co-Presenter] I think the question you're asking

00:29:27,447 --> 00:29:30,442
has to do with the initialization vector.

00:29:30,442 --> 00:29:34,930
And there is an initialization vector that is calculated

00:29:34,930 --> 00:29:39,930
for each block, so it's not a stream cipher.

00:29:45,090 --> 00:29:46,170
- [Audience Member] So I guess this work

00:29:46,170 --> 00:29:47,833
is based on block and queue?

00:29:50,534 --> 00:29:52,560
- Yes I believe it is.

00:29:52,560 --> 00:29:53,949
- [Audience Member] So is it like

00:29:53,949 --> 00:29:55,770
a very bad serialization point?

00:29:55,770 --> 00:29:56,820
- Sorry is it a what?

00:29:57,727 --> 00:29:59,900
Is it a serialization point?

00:29:59,900 --> 00:30:01,310
- [Audience Member] Like is it gone through the same,

00:30:01,310 --> 00:30:02,983
I don't know, lock?

00:30:03,860 --> 00:30:08,050
Because it will just kill the purpose of block and queue.

00:30:08,050 --> 00:30:10,650
- Okay so when I say it's based off block and queue.

00:30:13,062 --> 00:30:16,783
Actually the crypto stuff that blk-crypto does

00:30:17,690 --> 00:30:21,379
happens before it even goes into the make request function

00:30:21,379 --> 00:30:24,740
of request queue, so it's not really...

00:30:26,490 --> 00:30:27,870
- [Audience Member] The performance of block and queue

00:30:27,870 --> 00:30:30,757
you should not have any common locks.

00:30:30,757 --> 00:30:34,010
So if you add something to block and queue

00:30:34,010 --> 00:30:35,690
because you add something to block and queue

00:30:35,690 --> 00:30:37,610
you need to build it in such a way

00:30:37,610 --> 00:30:40,653
so it does not use basically shared locks.

00:30:44,144 --> 00:30:46,910
- [Co-Presenter] Different layer, the encryption is actually

00:30:46,910 --> 00:30:49,279
being done by the hardware, so we're just simply passing

00:30:49,279 --> 00:30:52,343
the information along to the hardware.

00:30:54,320 --> 00:30:56,681
Yes, and that's actually happening in the filesystem

00:30:56,681 --> 00:30:59,910
with read page or write page,

00:30:59,910 --> 00:31:04,910
which is already a serialization point on a per inode basis.

00:31:05,014 --> 00:31:09,340
If you have multiple processes using multiple writes

00:31:09,340 --> 00:31:14,280
to different files, those will be handled in parallel.

00:31:14,280 --> 00:31:18,420
But both EXT4 and F2FS serialize

00:31:18,420 --> 00:31:22,763
files reads and writes anyway, so that's, yeah.

00:31:24,420 --> 00:31:26,994
- [Audience Member] Is it possible to use this encryption

00:31:26,994 --> 00:31:28,055
where like--

00:31:28,055 --> 00:31:29,790
- [Co-Presenter] The encryption layer is actually being done

00:31:29,790 --> 00:31:31,390
in hardware, right?

00:31:31,390 --> 00:31:34,530
So the only thing the filesystem needs to do, right,

00:31:34,530 --> 00:31:38,960
is number one, translate logical block to physical block

00:31:38,960 --> 00:31:42,410
and that's serialized already and we also pass along

00:31:42,410 --> 00:31:45,500
what encryption key to be used, right?

00:31:45,500 --> 00:31:48,950
So there are filesystems that actually will do parallelized

00:31:48,950 --> 00:31:50,813
reads and writes, like XFS.

00:31:52,117 --> 00:31:55,783
We're not targeting those filesystems, XFS is not used

00:31:55,783 --> 00:32:00,450
on these sorts of devices that we're initially targeting.

00:32:00,450 --> 00:32:01,950
- [Audience Member] Yeah so the question is

00:32:01,950 --> 00:32:05,577
can you use this without filesystem?

00:32:05,577 --> 00:32:09,997
In my impression, sorry, with inline encryption probably--

00:32:09,997 --> 00:32:12,340
- [Co-Presenter] So, you can, it's just something

00:32:12,340 --> 00:32:15,013
has to decide what key to use, right?

00:32:16,091 --> 00:32:18,070
And right now, all of the interfaces

00:32:18,070 --> 00:32:19,970
are actually designed for filesystems.

00:32:29,747 --> 00:32:30,914
Any questions?

00:32:33,690 --> 00:32:35,100
- [Audience Member] Sorry, maybe this is an obvious one.

00:32:35,100 --> 00:32:36,400
Where are the keys stored?

00:32:37,720 --> 00:32:40,623
Where do you initially get them on boot?

00:32:42,000 --> 00:32:42,950
- Okay so...

00:32:45,000 --> 00:32:47,463
So inline encryption doesn't actually change

00:32:47,463 --> 00:32:50,300
where the keys are, where you get the keys

00:32:50,300 --> 00:32:54,880
and everything from, fscrypt pretty much works as-is

00:32:54,880 --> 00:32:56,483
as it used to.

00:32:58,440 --> 00:33:02,490
It maintains track of which files have what keys and so on.

00:33:02,490 --> 00:33:06,780
But for more detailed explanation of how

00:33:06,780 --> 00:33:11,470
the user's key goes into, right...

00:33:11,470 --> 00:33:13,493
So at least on Android, what we do is,

00:33:14,970 --> 00:33:17,670
when the user is created, we create keys for a user

00:33:17,670 --> 00:33:21,170
that's going to be essentially the key that we use

00:33:21,170 --> 00:33:24,963
to encrypt data for a particular user.

00:33:26,181 --> 00:33:31,181
What fscrypt does is that key will,

00:33:31,580 --> 00:33:35,132
you run some sort of key derivation function on that key

00:33:35,132 --> 00:33:36,260
and come up with the profile key

00:33:36,260 --> 00:33:38,260
and that's the key that's going to be used eventually

00:33:38,260 --> 00:33:42,530
by fscrypt to encrypt and decrypt a particular file's data.

00:33:42,530 --> 00:33:47,113
And the user's key comes in earlier on in the process.

00:33:48,370 --> 00:33:52,660
The user's key is used to decrypt the actual key

00:33:52,660 --> 00:33:56,450
that we're going to use for the file data encryption

00:33:56,450 --> 00:33:57,283
and decryption.

00:33:57,283 --> 00:34:00,560
- [Audience Member] Okay and so if you break that key

00:34:00,560 --> 00:34:04,335
basically, you can't get your data back, is that the idea?

00:34:04,335 --> 00:34:05,610
- Yes, that's the idea.

00:34:05,610 --> 00:34:07,980
Without the user's password, you shouldn't be able to read

00:34:07,980 --> 00:34:10,976
data encrypted with, yeah.

00:34:10,976 --> 00:34:12,213
- [Audience Member] Okay, thanks.

00:34:15,980 --> 00:34:17,463
- [Co-Presenter] Other questions?

00:34:20,999 --> 00:34:21,844
All right.

00:34:21,844 --> 00:34:23,470
Thank Satya.

00:34:23,470 --> 00:34:24,365
- Thank you.

00:34:24,365 --> 00:34:25,411

YouTube URL: https://www.youtube.com/watch?v=MvDrsow0h4M


