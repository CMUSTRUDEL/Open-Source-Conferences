Title: LPC2019 - Memory management bits in arch *
Publication date: 2019-11-18
Playlist: LPC2019 - Kernel Summit Track
Description: 
	There is a lot of similar and duplicated code in architecture specific
bits of memory management.

For instance, most architectures have

#define PGALLOC_GFP (GFP_KERNEL | __GFP_ZERO)
for allocating page table pages and many of them use similar, if not
identical, implementation of pte_alloc_one*().

But that's only the tip of the iceberg.

There are several early_alloc() or similarily called routines that do

if (slab_is_available())
    return kzalloc();
else
    return memblock_alloc();
Some other trivial examples are free_initmem(), free_initrd_mem()
which were nearly identical accross many architectures until very
recently.

More complex cases are per-cpu initialization, passing of memory topology
to the generic MM, reservation of crash kernel, mmap of vdso etc. They
are not really duplicated, but still are very similar in at least
several architectures.

While factoring out the common code is an obvious step to take, I
believe there is also room for refining arch - mm interface to avoid
adding extra HAVE_ARCH_NO_BOOTMEM^w^wWHAT_NOT and then searching for the
ways to get rid of them.

Mike Rapoport (IBM)
Captions: 
	00:00:00,030 --> 00:00:02,939
to introduce Mike Rapoport who's going

00:00:01,920 --> 00:00:11,580
to be talking about memory management

00:00:02,939 --> 00:00:13,740
that's in arch Thanks so it's not about

00:00:11,580 --> 00:00:16,379
new features or some great and shiny

00:00:13,740 --> 00:00:19,820
functionality or performance improvement

00:00:16,379 --> 00:00:24,990
it's more about lots of code duplication

00:00:19,820 --> 00:00:27,769
all around the arch am and whatever it's

00:00:24,990 --> 00:00:30,179
also about these things that

00:00:27,769 --> 00:00:31,590
architectural developers implement for

00:00:30,179 --> 00:00:34,739
their own architecture and don'tshare

00:00:31,590 --> 00:00:36,719
with other architectures it kind of

00:00:34,739 --> 00:00:39,000
happens quite a lot and there's some

00:00:36,719 --> 00:00:42,780
code that could be made generic ends up

00:00:39,000 --> 00:00:45,239
in architecture depended parts and they

00:00:42,780 --> 00:00:49,820
never makes it to generic parts of the

00:00:45,239 --> 00:00:52,469
kernel and in some sense it's about

00:00:49,820 --> 00:00:55,530
architecture and memory management

00:00:52,469 --> 00:00:57,660
interface and what's in between them so

00:00:55,530 --> 00:00:59,100
the architecture memory is the interface

00:00:57,660 --> 00:01:01,649
between architectures and memory

00:00:59,100 --> 00:01:04,530
management it can be see there are

00:01:01,649 --> 00:01:07,140
several parts to it first is a page

00:01:04,530 --> 00:01:09,119
table manipulation primitives that every

00:01:07,140 --> 00:01:12,750
architecture implements and the generic

00:01:09,119 --> 00:01:15,450
memory management code the user said the

00:01:12,750 --> 00:01:19,130
memory management initialization is

00:01:15,450 --> 00:01:23,460
mostly done in architecture specific

00:01:19,130 --> 00:01:25,799
parts of the code and there is one thing

00:01:23,460 --> 00:01:28,909
also that is defined by the architecture

00:01:25,799 --> 00:01:31,860
is the memory models and their

00:01:28,909 --> 00:01:36,840
insulation like flat MEMS parts and

00:01:31,860 --> 00:01:39,030
still discontinuous mem for some of some

00:01:36,840 --> 00:01:41,850
of the architectures and there is also

00:01:39,030 --> 00:01:44,189
memory hot-plug but frankly I don't know

00:01:41,850 --> 00:01:48,689
nothing about it and they so I won't be

00:01:44,189 --> 00:01:53,990
talking about it so let's start with a

00:01:48,689 --> 00:02:02,250
short quiz we have 25 architectures in

00:01:53,990 --> 00:02:06,500
kernel oops a and M and we have a simple

00:02:02,250 --> 00:02:10,410
macro static inline a PGD offset that

00:02:06,500 --> 00:02:13,380
converts an address to index to the top

00:02:10,410 --> 00:02:20,130
level of page directory so

00:02:13,380 --> 00:02:25,050
how many definitions do we have no five

00:02:20,130 --> 00:02:29,540
no no and there are another question how

00:02:25,050 --> 00:02:29,540
hurry how much do we really need a

00:02:31,580 --> 00:02:38,000
thirty one

00:02:33,860 --> 00:02:42,990
please don't grip it's not fair Hey

00:02:38,000 --> 00:02:47,040
and the 28 of them mostly identical just

00:02:42,990 --> 00:02:49,020
like it plus/minus spaces here and there

00:02:47,040 --> 00:02:53,250
because old God never gets spaces around

00:02:49,020 --> 00:02:56,430
pluses and x86 and arm sixty-four have

00:02:53,250 --> 00:02:58,590
another helper on the ways it gets PGD

00:02:56,430 --> 00:03:01,770
of the amendments and converts it and

00:02:58,590 --> 00:03:06,450
then they calculate the offset into it

00:03:01,770 --> 00:03:08,730
and a 319 they do some completely

00:03:06,450 --> 00:03:13,680
different stuff so they are really

00:03:08,730 --> 00:03:16,920
different now it's not only that those

00:03:13,680 --> 00:03:21,300
are guys like Big B Samson index piece

00:03:16,920 --> 00:03:23,070
I'm singing offset pretty much the same

00:03:21,300 --> 00:03:27,590
for every architectures that implements

00:03:23,070 --> 00:03:31,530
those levels as it have the same helpers

00:03:27,590 --> 00:03:35,370
many architecture have some helper for

00:03:31,530 --> 00:03:37,710
earlier location when that says okay if

00:03:35,370 --> 00:03:39,660
we got slab already initialized we do

00:03:37,710 --> 00:03:42,380
page analog otherwise we are going to

00:03:39,660 --> 00:03:47,910
demand block Alec quite a few of them

00:03:42,380 --> 00:03:49,820
and another quite interesting there are

00:03:47,910 --> 00:03:53,640
like five or six identical

00:03:49,820 --> 00:03:57,450
implementation of mapping of the VD so

00:03:53,640 --> 00:04:00,180
that grabs him up same and finds the

00:03:57,450 --> 00:04:03,900
pages gets a and mapped area from V

00:04:00,180 --> 00:04:07,610
malloc and calls install special area

00:04:03,900 --> 00:04:11,400
and then releases the semaphore

00:04:07,610 --> 00:04:14,970
the rhyme several key textures have more

00:04:11,400 --> 00:04:18,120
around it and probably they use even

00:04:14,970 --> 00:04:19,890
better versions but again it called it's

00:04:18,120 --> 00:04:22,260
the code that ended up being completely

00:04:19,890 --> 00:04:25,470
architecture dependent and they never

00:04:22,260 --> 00:04:27,710
got into let's say mmm we do so don't

00:04:25,470 --> 00:04:27,710
see

00:04:28,949 --> 00:04:39,160
so it's been some ongoing work on the

00:04:34,810 --> 00:04:41,319
cleanups increased of shalwick send a

00:04:39,160 --> 00:04:45,580
perimeter demand my cleanups

00:04:41,319 --> 00:04:50,699
so we now have six instead of 26 I did

00:04:45,580 --> 00:04:54,039
some other yes and we could reduce it by

00:04:50,699 --> 00:04:59,800
well substantial amount there is still

00:04:54,039 --> 00:05:02,139
more left to do but sometimes sometimes

00:04:59,800 --> 00:05:05,199
you really can't do anything much about

00:05:02,139 --> 00:05:06,370
the it has to remain different for

00:05:05,199 --> 00:05:08,080
different architectures because

00:05:06,370 --> 00:05:10,630
sometimes architectures do different

00:05:08,080 --> 00:05:14,169
things in the apparently simple macro

00:05:10,630 --> 00:05:17,380
zone helpers like arm likes to play with

00:05:14,169 --> 00:05:21,250
its caches when it does allocation of

00:05:17,380 --> 00:05:23,530
vegetable pages several architectures

00:05:21,250 --> 00:05:25,720
have their own logic for managing page

00:05:23,530 --> 00:05:31,199
tables that completely different from

00:05:25,720 --> 00:05:35,289
others now if if I'm trying to do some

00:05:31,199 --> 00:05:39,639
change that is not really trivial and

00:05:35,289 --> 00:05:42,759
it's a bit scary because I really have

00:05:39,639 --> 00:05:45,759
no way to test it and sometimes when you

00:05:42,759 --> 00:05:49,900
send patched Linux alpha you don't get

00:05:45,759 --> 00:05:55,569
any response out of there nobody really

00:05:49,900 --> 00:05:57,940
looks at these patches and they some

00:05:55,569 --> 00:06:01,060
memory management related functions in

00:05:57,940 --> 00:06:03,069
the architecture code they do things

00:06:01,060 --> 00:06:05,830
that are not strictly related to memory

00:06:03,069 --> 00:06:10,900
management like changing that state of

00:06:05,830 --> 00:06:13,300
the chasis or sometimes it is related to

00:06:10,900 --> 00:06:16,500
memory management but it's unique to an

00:06:13,300 --> 00:06:22,389
architecture that updates protection of

00:06:16,500 --> 00:06:28,870
memory a for instance of init memory at

00:06:22,389 --> 00:06:31,080
free anytime a free init memory time and

00:06:28,870 --> 00:06:34,800
now

00:06:31,080 --> 00:06:38,710
that's what we have so where shall we go

00:06:34,800 --> 00:06:41,320
the page management apparently is going

00:06:38,710 --> 00:06:45,460
to stay the way it is there was an

00:06:41,320 --> 00:06:48,760
attempt by curioso team of once I think

00:06:45,460 --> 00:06:52,690
two years ago he was working on five

00:06:48,760 --> 00:06:57,070
levels for x86 it never gone beyond the

00:06:52,690 --> 00:07:01,570
RFC here I think only single version was

00:06:57,070 --> 00:07:04,930
posted and this work doesn't seem to

00:07:01,570 --> 00:07:07,300
continuous so the best we can do is to

00:07:04,930 --> 00:07:12,120
start extracting common functionality

00:07:07,300 --> 00:07:12,120
and move it to a common places and

00:07:13,140 --> 00:07:20,470
remove duplicated code and in the

00:07:16,390 --> 00:07:24,930
architectures and do the best we have as

00:07:20,470 --> 00:07:29,680
few identical functions as possible

00:07:24,930 --> 00:07:31,540
they beat saying about different

00:07:29,680 --> 00:07:34,870
functionality parts that implemented

00:07:31,540 --> 00:07:37,060
this the same semantics a implemented in

00:07:34,870 --> 00:07:39,280
different ways it require a bit more

00:07:37,060 --> 00:07:42,040
work but still it's something like a

00:07:39,280 --> 00:07:43,800
memory disordered see make sense that

00:07:42,040 --> 00:07:46,300
will do all the mapping with the

00:07:43,800 --> 00:07:51,190
architecture provided images for videos

00:07:46,300 --> 00:07:56,919
or blobs and the memory Neitzel is asian

00:07:51,190 --> 00:08:00,160
well it's a bit of pain because it

00:07:56,919 --> 00:08:05,260
evolved it and as it evolved and it does

00:08:00,160 --> 00:08:08,500
were really interesting things and as a

00:08:05,260 --> 00:08:10,590
site topic a bit it's also in a way

00:08:08,500 --> 00:08:14,130
related to the memory management

00:08:10,590 --> 00:08:17,140
installation we have three memory models

00:08:14,130 --> 00:08:19,930
we have flat MEMS the simplest and a the

00:08:17,140 --> 00:08:22,810
most efficient one we have the sparse

00:08:19,930 --> 00:08:25,210
MEMS that is most widely widely used by

00:08:22,810 --> 00:08:28,570
most active architectures and we still

00:08:25,210 --> 00:08:34,659
have couples that depend on

00:08:28,570 --> 00:08:38,440
discontinuous memory and although it

00:08:34,659 --> 00:08:44,290
seemed not that difficult to switch most

00:08:38,440 --> 00:08:51,110
of them to sparse still there are semi

00:08:44,290 --> 00:08:53,660
for instance ia 64 for some reason

00:08:51,110 --> 00:08:57,050
requires discontinuous memory to enable

00:08:53,660 --> 00:09:01,400
sparse mam or in order to use their own

00:08:57,050 --> 00:09:03,710
version of female map I didn't dig

00:09:01,400 --> 00:09:05,330
enough to understand what is going on

00:09:03,710 --> 00:09:08,690
there but there are a lot of

00:09:05,330 --> 00:09:11,390
dependencies of different pieces of node

00:09:08,690 --> 00:09:16,340
allocation and the memory map allocation

00:09:11,390 --> 00:09:17,720
inside buried deep inside is 64 so it

00:09:16,340 --> 00:09:26,500
won't be easy one

00:09:17,720 --> 00:09:28,760
well alpha again in nobody cares Ark

00:09:26,500 --> 00:09:31,640
actually the most interesting one they

00:09:28,760 --> 00:09:35,260
use a discontinuous mem to have high

00:09:31,640 --> 00:09:39,710
memory below the low memory they define

00:09:35,260 --> 00:09:42,020
they have a node with low memories it

00:09:39,710 --> 00:09:45,020
sits and high physical addresses and

00:09:42,020 --> 00:09:48,380
another node with the high memories it

00:09:45,020 --> 00:09:50,960
sits at low physical addresses and since

00:09:48,380 --> 00:09:53,570
the low memory addresses node is

00:09:50,960 --> 00:09:57,080
optional that's what they use and that

00:09:53,570 --> 00:09:59,030
what they have to use in a way and there

00:09:57,080 --> 00:10:00,860
is some comment in the code that says

00:09:59,030 --> 00:10:03,670
sparse is not as efficient as

00:10:00,860 --> 00:10:06,620
discontinuous so we stick with that and

00:10:03,670 --> 00:10:12,260
I've tried to send the patch to their

00:10:06,620 --> 00:10:15,470
mailing list and nobody cares now he

00:10:12,260 --> 00:10:19,100
makes actually there is some progress

00:10:15,470 --> 00:10:22,720
here this continuous memory is used only

00:10:19,100 --> 00:10:25,760
on SGI origin machines anybody have one

00:10:22,720 --> 00:10:27,790
and I actually found a guy who does have

00:10:25,760 --> 00:10:30,500
one such machinist so we are getting

00:10:27,790 --> 00:10:33,710
general kernel panics and trying to

00:10:30,500 --> 00:10:39,350
debug it so probably we will do will do

00:10:33,710 --> 00:10:42,589
it pretty soon now for m-68 it's quite

00:10:39,350 --> 00:10:44,240
the opposite of the Alpha because the

00:10:42,589 --> 00:10:47,240
list is really responsive and they I

00:10:44,240 --> 00:10:49,550
even get okay I have tested in I tested

00:10:47,240 --> 00:10:52,909
the your patches on my Amiga real

00:10:49,550 --> 00:10:57,959
hardware but it doesn't work and

00:10:52,909 --> 00:11:01,229
the problem with m62 8a it is not

00:10:57,959 --> 00:11:06,509
difficult to implement sparse but the

00:11:01,229 --> 00:11:08,849
trouble is I have no enough definitions

00:11:06,509 --> 00:11:12,899
of the existing hardware to understand

00:11:08,849 --> 00:11:18,539
what the section size must be because

00:11:12,899 --> 00:11:21,929
it's hard it's it's static defined and

00:11:18,539 --> 00:11:24,539
then if I do section that is too large I

00:11:21,929 --> 00:11:27,029
will get a huge hole in the memory map

00:11:24,539 --> 00:11:29,419
and if I do sections that is too small I

00:11:27,029 --> 00:11:31,769
don't have enough place in the page flux

00:11:29,419 --> 00:11:33,569
so we are working on it

00:11:31,769 --> 00:11:39,559
I hoped actually that gift will be here

00:11:33,569 --> 00:11:43,609
but he didn't see him now the actually

00:11:39,559 --> 00:11:47,759
insulation of the memory management

00:11:43,609 --> 00:11:49,349
most of the non generic code is split

00:11:47,759 --> 00:11:53,249
between these two functions for

00:11:49,349 --> 00:11:56,269
functions set apart does most of the

00:11:53,249 --> 00:12:02,149
heavy lifting it could be like 200

00:11:56,269 --> 00:12:05,519
whines totals for hexagon or Neos - and

00:12:02,149 --> 00:12:07,739
if you look at ticks 86 of power it's

00:12:05,519 --> 00:12:14,519
quite a lot of codes it's going on there

00:12:07,739 --> 00:12:18,569
and it does many things I'll talk about

00:12:14,519 --> 00:12:21,899
it a bit later next call back from the

00:12:18,569 --> 00:12:24,149
main start kernel function into the

00:12:21,899 --> 00:12:26,129
architecture as it is related to memory

00:12:24,149 --> 00:12:30,179
management in civilization is named in

00:12:26,129 --> 00:12:33,019
it that the only initialization it does

00:12:30,179 --> 00:12:35,819
it actually starts up the page a locator

00:12:33,019 --> 00:12:38,659
it gets all the pages that were

00:12:35,819 --> 00:12:42,509
previously registered with man block and

00:12:38,659 --> 00:12:46,859
put them on the free lists so there is a

00:12:42,509 --> 00:12:49,769
call to a mind block free all and they

00:12:46,859 --> 00:12:51,649
some surrounding functionalities it

00:12:49,769 --> 00:12:54,629
might not be necessary related a

00:12:51,649 --> 00:12:56,520
friendly free knitter DMM is simple it

00:12:54,629 --> 00:12:58,770
freezing 30 memory

00:12:56,520 --> 00:13:02,490
and they free in Italy may freeze the

00:12:58,770 --> 00:13:06,390
memory in its sections so now we're

00:13:02,490 --> 00:13:08,760
going through the details and free

00:13:06,390 --> 00:13:11,490
knitted mm is the easiest one we have

00:13:08,760 --> 00:13:15,000
only six of them left in the mm tree so

00:13:11,490 --> 00:13:20,780
in the five four there will be six of

00:13:15,000 --> 00:13:23,280
them is the differences between existing

00:13:20,780 --> 00:13:31,050
implementations and the generic one is

00:13:23,280 --> 00:13:34,860
for arm and x86 arm have its arm has its

00:13:31,050 --> 00:13:38,220
own magic for alignment of inator the

00:13:34,860 --> 00:13:40,560
areas for some reason and it is

00:13:38,220 --> 00:13:43,440
different from other architectures and

00:13:40,560 --> 00:13:46,770
if we change it will probably break some

00:13:43,440 --> 00:13:47,250
platforms so it is going to remain this

00:13:46,770 --> 00:13:51,330
way

00:13:47,250 --> 00:13:53,550
now I'm sixty-four calls man block free

00:13:51,330 --> 00:13:56,460
for the whole memo for the whole in it

00:13:53,550 --> 00:13:58,290
er D area and it's the only architecture

00:13:56,460 --> 00:14:00,480
that does it although there are other

00:13:58,290 --> 00:14:02,730
architectures that retain main block for

00:14:00,480 --> 00:14:05,730
the runtime but still they don't care so

00:14:02,730 --> 00:14:10,890
I'm not sure easy is it bug in arm 64 is

00:14:05,730 --> 00:14:13,800
it back in powers it doesn't call it if

00:14:10,890 --> 00:14:17,340
if anybody can say why arm 64 does

00:14:13,800 --> 00:14:21,330
called main block free in in free in

00:14:17,340 --> 00:14:24,300
Italy I appreciate the feedback but I

00:14:21,330 --> 00:14:26,790
tried to track through the code to see

00:14:24,300 --> 00:14:30,420
if member lock reserved areas released

00:14:26,790 --> 00:14:32,460
used anywhere in in runtime and I

00:14:30,420 --> 00:14:39,540
couldn't find it couldn't find anything

00:14:32,460 --> 00:14:41,220
and x86 has its own way to deal with

00:14:39,540 --> 00:14:48,810
memory protections because of security

00:14:41,220 --> 00:14:51,630
and everything so it does some calls to

00:14:48,810 --> 00:14:57,720
internal x86 generic implementation of

00:14:51,630 --> 00:15:04,290
memory protection changes the free in it

00:14:57,720 --> 00:15:08,460
ma'am a has a lot of things that are not

00:15:04,290 --> 00:15:10,259
strictly necessary to free in it memory

00:15:08,460 --> 00:15:12,839
but since its

00:15:10,259 --> 00:15:17,299
last point that generic start colonel

00:15:12,839 --> 00:15:21,479
calls to the architecture court the all

00:15:17,299 --> 00:15:24,059
almost in every remaining placed they

00:15:21,479 --> 00:15:29,699
are used to do some final initialization

00:15:24,059 --> 00:15:34,529
things like lady or memory protection or

00:15:29,699 --> 00:15:36,449
change some variables that says okay

00:15:34,529 --> 00:15:46,289
from ours perspective we've done the

00:15:36,449 --> 00:15:47,459
boot is so probably it could be

00:15:46,289 --> 00:15:53,549
something like that

00:15:47,459 --> 00:15:57,089
within your Kotecha specific hook as it

00:15:53,549 --> 00:16:01,589
actually says okay we've done we've done

00:15:57,089 --> 00:16:06,079
the boot let's say let's do whatever we

00:16:01,589 --> 00:16:10,160
need for for this part and actually the

00:16:06,079 --> 00:16:12,989
this one could be pushed into this one

00:16:10,160 --> 00:16:19,739
because there is only one architectures

00:16:12,989 --> 00:16:21,600
it implements PTI finalized and even sub

00:16:19,739 --> 00:16:30,509
architecture is it implements bit -

00:16:21,600 --> 00:16:35,539
noise I think I mix sounds okay and now

00:16:30,509 --> 00:16:40,230
set apart does most of the heavy lifting

00:16:35,539 --> 00:16:44,509
first it reserves in the areas used by

00:16:40,230 --> 00:16:48,149
Colonel in it erdene funeral some

00:16:44,509 --> 00:16:53,519
physical regions that are known to be

00:16:48,149 --> 00:16:56,579
not usable as normal system ROM then and

00:16:53,519 --> 00:16:58,889
it's the first two are quite intermixed

00:16:56,579 --> 00:17:00,749
it reserves the text the text reserves

00:16:58,889 --> 00:17:02,909
depending on the architecture it could

00:17:00,749 --> 00:17:05,579
be really weird sequence of reserve

00:17:02,909 --> 00:17:08,429
reserve detect okay reserved against and

00:17:05,579 --> 00:17:10,769
unreserved and okay we have much a bit

00:17:08,429 --> 00:17:15,569
more memory we are going to see where it

00:17:10,769 --> 00:17:17,110
is going and in the end of detection and

00:17:15,569 --> 00:17:20,740
reservation we

00:17:17,110 --> 00:17:24,490
at a newmont apology we get a man block

00:17:20,740 --> 00:17:27,970
memory filled with the memory banks to

00:17:24,490 --> 00:17:29,950
some extent and they we have Mamluk

00:17:27,970 --> 00:17:31,920
reserved for the areas that should not

00:17:29,950 --> 00:17:35,799
be touched by a colonel

00:17:31,920 --> 00:17:36,730
next thing what's done during the set up

00:17:35,799 --> 00:17:43,630
arch time

00:17:36,730 --> 00:17:51,070
what was once paging in it along 2.0 I

00:17:43,630 --> 00:17:55,179
think it it creates the colonel page

00:17:51,070 --> 00:17:57,820
tables for the linear map pretty much

00:17:55,179 --> 00:18:00,100
the same in every architecture of course

00:17:57,820 --> 00:18:01,870
it's done differently because every

00:18:00,100 --> 00:18:04,570
architecture has its own going to define

00:18:01,870 --> 00:18:09,179
for each tables and they some has weird

00:18:04,570 --> 00:18:11,650
day with weird games with sketches and

00:18:09,179 --> 00:18:14,740
kind it's things like that

00:18:11,650 --> 00:18:19,290
but in the end by the time set apart

00:18:14,740 --> 00:18:24,250
finishes the direct map is ready for use

00:18:19,290 --> 00:18:27,240
and also during set up arch we

00:18:24,250 --> 00:18:29,280
initialize a memory map and struct page

00:18:27,240 --> 00:18:35,140
arrays

00:18:29,280 --> 00:18:40,740
it's also done it's also usually spread

00:18:35,140 --> 00:18:43,299
around the whole set of calls to memory

00:18:40,740 --> 00:18:46,660
in the whole set of calls inside set

00:18:43,299 --> 00:18:48,520
apart like no detection comes before

00:18:46,660 --> 00:18:51,880
memory detection or after memory

00:18:48,520 --> 00:18:54,040
detection and then we do some okay we

00:18:51,880 --> 00:18:58,030
know this is memory but we don't know

00:18:54,040 --> 00:19:02,260
yet what node it belongs to I probably

00:18:58,030 --> 00:19:04,960
we do yeah so let's change it and did

00:19:02,260 --> 00:19:10,360
goats with some rounds in there but in

00:19:04,960 --> 00:19:15,280
the end the nodes and day and the memory

00:19:10,360 --> 00:19:18,400
maps initialized and and other things

00:19:15,280 --> 00:19:21,669
it's done is calculation of zone limits

00:19:18,400 --> 00:19:25,360
and passing these own limits to the

00:19:21,669 --> 00:19:28,630
generic memory management so that it

00:19:25,360 --> 00:19:31,290
will able we will be able to bootstrap

00:19:28,630 --> 00:19:31,290
educator

00:19:32,650 --> 00:19:41,480
and they another piece of memory

00:19:36,590 --> 00:19:44,180
initialization is a minute so for the

00:19:41,480 --> 00:19:46,220
most parts it gives page to Rachel and

00:19:44,180 --> 00:19:48,950
give pages to the Becca and page over

00:19:46,220 --> 00:19:53,030
cattle and after it's finished actually

00:19:48,950 --> 00:19:57,230
can you can do out page and set up came

00:19:53,030 --> 00:20:02,930
out and everything some architectures

00:19:57,230 --> 00:20:09,080
set the maximal vfn of mapped mariya and

00:20:02,930 --> 00:20:11,450
the minimal - of high memory all of them

00:20:09,080 --> 00:20:15,190
do print like we have that much of

00:20:11,450 --> 00:20:19,160
memory and say that's how it's used and

00:20:15,190 --> 00:20:21,050
since again it's say last time hook for

00:20:19,160 --> 00:20:25,490
the architecture-specific call from the

00:20:21,050 --> 00:20:30,250
generics start kernel different

00:20:25,490 --> 00:20:30,250
architectures do different things yeah

00:20:30,550 --> 00:20:35,930
and they were the largest the

00:20:34,370 --> 00:20:43,850
architecture is and more things they

00:20:35,930 --> 00:20:47,990
usually do so it's a big big bit larger

00:20:43,850 --> 00:20:51,740
context how this all happens and we have

00:20:47,990 --> 00:20:55,400
the printing of the nice linux version

00:20:51,740 --> 00:20:57,280
and so on then it goes through set apart

00:20:55,400 --> 00:21:01,130
to set up whatever set apart does

00:20:57,280 --> 00:21:04,490
including of course in memory parts a by

00:21:01,130 --> 00:21:07,820
the time set apart finishes they can no

00:21:04,490 --> 00:21:11,330
presumes that all new Matt apology is

00:21:07,820 --> 00:21:15,280
detected and it is a very very new Matt

00:21:11,330 --> 00:21:18,170
apology to properly built as a zone list

00:21:15,280 --> 00:21:20,840
then it calls to this function which is

00:21:18,170 --> 00:21:28,190
called a jog in it what do you think it

00:21:20,840 --> 00:21:31,270
does nobody well probably you sort it on

00:21:28,190 --> 00:21:37,040
angel eyes the spatial locator but no

00:21:31,270 --> 00:21:41,300
it's a initialization of CPU code block

00:21:37,040 --> 00:21:43,380
callbacks of pager locator and anyway in

00:21:41,300 --> 00:21:45,210
the after some

00:21:43,380 --> 00:21:47,370
additional calls that are not strictly

00:21:45,210 --> 00:21:50,850
related to memory management we call a

00:21:47,370 --> 00:21:54,539
memory needs it calls inside it they may

00:21:50,850 --> 00:21:56,130
mean it of the architecture actually I

00:21:54,539 --> 00:21:57,900
don't know why I'm I mean it's still

00:21:56,130 --> 00:22:03,660
called name in it because it doesn't do

00:21:57,900 --> 00:22:06,720
maybe need but whatever so for my future

00:22:03,660 --> 00:22:12,030
work on this topic I had several

00:22:06,720 --> 00:22:14,850
assumptions that are pretty much

00:22:12,030 --> 00:22:18,179
necessary and if something of it doesn't

00:22:14,850 --> 00:22:22,110
really hold say the refactoring I'm

00:22:18,179 --> 00:22:25,020
planing won't go but as far as I could

00:22:22,110 --> 00:22:27,630
tell from looking at all of 25

00:22:25,020 --> 00:22:39,559
architectures and what are they doing it

00:22:27,630 --> 00:22:43,230
seems to be the case so we what what we

00:22:39,559 --> 00:22:46,860
what we are doing here is that we need

00:22:43,230 --> 00:22:49,799
to make sure that memory detection for

00:22:46,860 --> 00:22:54,710
the for every architecture pretty much

00:22:49,799 --> 00:22:58,950
is about conversion of its internal and

00:22:54,710 --> 00:23:01,950
of the memory bank informations the

00:22:58,950 --> 00:23:06,179
framework passes to the kernel into main

00:23:01,950 --> 00:23:09,390
block memory erase and if there are too

00:23:06,179 --> 00:23:13,260
many banks we have knobs to increase

00:23:09,390 --> 00:23:16,770
these arrays so the static memories

00:23:13,260 --> 00:23:18,780
won't have so the nobody would need to

00:23:16,770 --> 00:23:24,600
do allocation when you do mem block head

00:23:18,780 --> 00:23:27,210
for your memory and that in it is

00:23:24,600 --> 00:23:30,450
possible to detect no more topology

00:23:27,210 --> 00:23:33,360
really early and it doesn't depend on

00:23:30,450 --> 00:23:39,260
many things that going on and happen in

00:23:33,360 --> 00:23:40,740
a during setup arc and the last one I

00:23:39,260 --> 00:23:44,700
don't

00:23:40,740 --> 00:23:46,799
I wasn't being able to verifies it for

00:23:44,700 --> 00:23:49,140
you but it seems to be the case that

00:23:46,799 --> 00:23:51,990
nobody uses struck page before pager

00:23:49,140 --> 00:23:56,220
locator is really up and running like

00:23:51,990 --> 00:23:57,990
before main block free all and then you

00:23:56,220 --> 00:24:03,420
have

00:23:57,990 --> 00:24:05,570
I don't know yet we are going to find

00:24:03,420 --> 00:24:12,480
out

00:24:05,570 --> 00:24:14,490
oops it's so what I was thinking to do I

00:24:12,480 --> 00:24:17,240
really hope to have something done by

00:24:14,490 --> 00:24:20,070
now but it didn't work out in the end eh

00:24:17,240 --> 00:24:22,500
my idea was to move with the memory

00:24:20,070 --> 00:24:25,340
detection and the Numa topology

00:24:22,500 --> 00:24:27,780
detection before set apart to explicit

00:24:25,340 --> 00:24:29,850
callback so that every architecture will

00:24:27,780 --> 00:24:32,520
have to explicitly implement them and

00:24:29,850 --> 00:24:37,260
not to have them as a part of setup arch

00:24:32,520 --> 00:24:40,800
so it will be clearer and clearer and if

00:24:37,260 --> 00:24:44,940
they make set-apart more clear and it

00:24:40,800 --> 00:24:48,660
makes memory detection more clear now if

00:24:44,940 --> 00:24:51,900
an architecture can have way many memory

00:24:48,660 --> 00:24:56,220
banks that cannot fit in a statically

00:24:51,900 --> 00:24:59,400
allocated memory array we already have

00:24:56,220 --> 00:25:02,130
an architecture knob to increase this

00:24:59,400 --> 00:25:10,800
like a config knob to increase this

00:25:02,130 --> 00:25:13,200
erasing stored the main block size can

00:25:10,800 --> 00:25:15,090
be defined by architecture than name we

00:25:13,200 --> 00:25:16,920
can do the same for memory pretty much

00:25:15,090 --> 00:25:24,330
like we do now for the reserve there is

00:25:16,920 --> 00:25:29,220
and the memory map initialization can be

00:25:24,330 --> 00:25:32,100
moved completely to a generic code for

00:25:29,220 --> 00:25:34,710
at least for the architectures that have

00:25:32,100 --> 00:25:39,000
member lock node mappings at the moment

00:25:34,710 --> 00:25:40,320
but my idea was to make all the team all

00:25:39,000 --> 00:25:43,530
of these code available for

00:25:40,320 --> 00:25:46,380
architectures that don't have a second

00:25:43,530 --> 00:25:48,300
node like any known new market textured

00:25:46,380 --> 00:25:51,450
doesn't have member lock node mapping

00:25:48,300 --> 00:25:55,770
defined but they have on the block node

00:25:51,450 --> 00:25:59,850
0 so it shouldn't be a problem and they

00:25:55,770 --> 00:26:02,880
things like sparse in it could be again

00:25:59,850 --> 00:26:06,900
fold inside the generic initialization

00:26:02,880 --> 00:26:09,570
of memory Maps now the part when the

00:26:06,900 --> 00:26:17,220
architecture calculates its own limit

00:26:09,570 --> 00:26:21,120
it's need to remain in some way but the

00:26:17,220 --> 00:26:24,720
code that the code that is called from

00:26:21,120 --> 00:26:28,980
free RIA free area in it nodes it takes

00:26:24,720 --> 00:26:31,380
into consideration the highest PF n for

00:26:28,980 --> 00:26:35,460
highest possible PF n for each node and

00:26:31,380 --> 00:26:41,880
actual action LP offense for that node

00:26:35,460 --> 00:26:44,040
in the main block so it can call back

00:26:41,880 --> 00:26:46,560
into the architecture to ask what is the

00:26:44,040 --> 00:26:48,540
highest possible PF n for each zone and

00:26:46,560 --> 00:26:50,700
it's pretty much Hardware constrained a

00:26:48,540 --> 00:26:52,950
because architecture doesn't know about

00:26:50,700 --> 00:26:55,740
moveable and everyone and device and

00:26:52,950 --> 00:26:58,980
everything so okay we know the Maison

00:26:55,740 --> 00:27:01,370
stands here and it's always ends here my

00:26:58,980 --> 00:27:04,440
it has to be the last defend in DMA

00:27:01,370 --> 00:27:07,950
whatever happens they may 32 is the same

00:27:04,440 --> 00:27:10,380
all the rest except high memory goes to

00:27:07,950 --> 00:27:12,510
normal and doing high memories I memory

00:27:10,380 --> 00:27:14,580
again its architectural a limit for the

00:27:12,510 --> 00:27:17,220
physical address that can be mapped in

00:27:14,580 --> 00:27:25,130
the direct map server there is no need

00:27:17,220 --> 00:27:28,140
to calculate a zone limits 25 times and

00:27:25,130 --> 00:27:30,540
to do the things architectures do in the

00:27:28,140 --> 00:27:32,370
memory in it that are not really a

00:27:30,540 --> 00:27:33,830
memory in it we can add the explicit

00:27:32,370 --> 00:27:38,160
call back again

00:27:33,830 --> 00:27:40,740
so for the first part it would be

00:27:38,160 --> 00:27:42,510
something like that we can start by

00:27:40,740 --> 00:27:46,830
shading on the names but probably we

00:27:42,510 --> 00:27:48,810
postpone it until later and early

00:27:46,830 --> 00:27:51,510
reserved memory should come before the

00:27:48,810 --> 00:27:54,450
TEC memory because the TEC memory might

00:27:51,510 --> 00:27:59,400
start allocating man block and then you

00:27:54,450 --> 00:28:02,400
can step on the reserved areas detect

00:27:59,400 --> 00:28:04,830
memory does conversion from actually

00:28:02,400 --> 00:28:08,070
this is pretty much what happens already

00:28:04,830 --> 00:28:10,860
on a dt architectures especially those

00:28:08,070 --> 00:28:13,650
that call a f dt in it from their

00:28:10,860 --> 00:28:17,310
assembly code so by the time set apart

00:28:13,650 --> 00:28:19,380
starts the memory knows of device tree

00:28:17,310 --> 00:28:23,270
all the parts and demand blocks is

00:28:19,380 --> 00:28:23,270
already initially set up

00:28:27,360 --> 00:28:39,370
and the M in it can have arch Bremen in

00:28:34,870 --> 00:28:41,860
it too to do this things architecture

00:28:39,370 --> 00:28:44,169
must do before actually transferring

00:28:41,860 --> 00:28:50,950
pages from member look to page allocator

00:28:44,169 --> 00:28:53,380
and then map in it instead of naming it

00:28:50,950 --> 00:28:56,049
that will initialize the note structures

00:28:53,380 --> 00:29:03,730
and the memory maps for the selected

00:28:56,049 --> 00:29:06,909
memory model and then we can printing

00:29:03,730 --> 00:29:09,490
how many memory behave from main it's

00:29:06,909 --> 00:29:14,820
not really necessary to be 25 times

00:29:09,490 --> 00:29:21,610
repeated in every architecture and they

00:29:14,820 --> 00:29:24,669
and just before the K memcache in it we

00:29:21,610 --> 00:29:27,150
have to initialize a page a locator so

00:29:24,669 --> 00:29:31,210
these are pretty much these two guys

00:29:27,150 --> 00:29:34,419
that only they exist mostly this one

00:29:31,210 --> 00:29:40,179
exists several times this one is only

00:29:34,419 --> 00:29:41,919
one but everybody calls it so again here

00:29:40,179 --> 00:29:43,929
we print something about memory

00:29:41,919 --> 00:29:45,760
initialization will be zero to not zero

00:29:43,929 --> 00:29:47,770
town free on our consider etcetera we

00:29:45,760 --> 00:29:50,130
can printing amount of memory at the

00:29:47,770 --> 00:29:53,940
same place it's not really a problem and

00:29:50,130 --> 00:29:57,250
in the end of the whole thing we can do

00:29:53,940 --> 00:29:59,020
post em a minute hook for key textures

00:29:57,250 --> 00:30:01,659
to do something that wish to do when a

00:29:59,020 --> 00:30:04,809
as you see that memory management is in

00:30:01,659 --> 00:30:07,299
it like change protections or enable

00:30:04,809 --> 00:30:11,890
caches or whatever they want to they

00:30:07,299 --> 00:30:14,890
need to have and again PTI in it can go

00:30:11,890 --> 00:30:18,280
on there I I think even both these guys

00:30:14,890 --> 00:30:20,669
are not really available on 24 key

00:30:18,280 --> 00:30:20,669
textures

00:30:23,990 --> 00:30:29,060
so thats more or less covers everything

00:30:28,250 --> 00:30:31,010
ahead

00:30:29,060 --> 00:30:34,040
as I said I don't know much about

00:30:31,010 --> 00:30:36,860
hot-plug so it's a bit out of my scope

00:30:34,040 --> 00:30:40,150
and I've seen people are working hard to

00:30:36,860 --> 00:30:43,760
make it better there are a couple of

00:30:40,150 --> 00:30:46,760
Suzy and reddit guys doing a hot plug

00:30:43,760 --> 00:30:53,030
work and this one I'd again nobody cares

00:30:46,760 --> 00:30:56,710
anyway the there are some things that

00:30:53,030 --> 00:31:01,760
make the whole process a bit difficult

00:30:56,710 --> 00:31:04,610
so as I said if I send them rft RFC two

00:31:01,760 --> 00:31:06,080
or less active architectures I don't

00:31:04,610 --> 00:31:08,720
know what's actually going to happen

00:31:06,080 --> 00:31:10,070
with these patches and there is no way

00:31:08,720 --> 00:31:12,680
the patches could go through

00:31:10,070 --> 00:31:15,940
architecture trees so it's all and will

00:31:12,680 --> 00:31:21,410
end up in Andrews inbox

00:31:15,940 --> 00:31:23,270
apparently the changes for the

00:31:21,410 --> 00:31:25,910
non-trivial changes are really scary

00:31:23,270 --> 00:31:28,040
because even if I think I understand

00:31:25,910 --> 00:31:33,130
what's going on there I have no way to

00:31:28,040 --> 00:31:37,090
verify anything beyond cross-compilation

00:31:33,130 --> 00:31:41,000
it with all due respect to Kim you and

00:31:37,090 --> 00:31:43,340
TCG there are things that it doesn't do

00:31:41,000 --> 00:31:46,190
and there are things that I cannot check

00:31:43,340 --> 00:31:48,280
with the existing QM you and I won't be

00:31:46,190 --> 00:31:52,880
having enough time to implement

00:31:48,280 --> 00:31:59,210
pneumophila or at the arc architecture

00:31:52,880 --> 00:32:01,970
2km you support so unless as there are

00:31:59,210 --> 00:32:03,950
people called didn't willing to test and

00:32:01,970 --> 00:32:06,440
verify the changes are okay for their

00:32:03,950 --> 00:32:11,750
architecture and I can make a progress

00:32:06,440 --> 00:32:14,960
there and the case of architecture

00:32:11,750 --> 00:32:17,980
developers pushing into their own arch

00:32:14,960 --> 00:32:21,220
code because it's sometimes easier

00:32:17,980 --> 00:32:24,250
and do not trying to seem or maybe these

00:32:21,220 --> 00:32:27,970
guys also do the same thing it still

00:32:24,250 --> 00:32:35,290
remains it still remains the

00:32:27,970 --> 00:32:37,900
consideration and probably these things

00:32:35,290 --> 00:32:40,000
will evolve from they from there things

00:32:37,900 --> 00:32:43,230
will work fastest and I will be able to

00:32:40,000 --> 00:32:48,160
do the cleanups so it could be a bit of

00:32:43,230 --> 00:32:55,510
difficulty here and that's pretty much

00:32:48,160 --> 00:32:59,250
all I had yeah I'll please send up and

00:32:55,510 --> 00:33:04,299
identify yourself if you would okay

00:32:59,250 --> 00:33:06,990
Pasha so Mike I have actually a couple

00:33:04,299 --> 00:33:12,940
question to you so how do you identify

00:33:06,990 --> 00:33:18,250
about memory models you think like it's

00:33:12,940 --> 00:33:19,530
going to be easiest to move and it is

00:33:18,250 --> 00:33:25,059
that actually doable

00:33:19,530 --> 00:33:27,610
what Marcin is the most widely used so

00:33:25,059 --> 00:33:29,350
no way we could remove it well yes

00:33:27,610 --> 00:33:32,919
that's the default one that's the one

00:33:29,350 --> 00:33:35,140
that we should you know flat mem is I

00:33:32,919 --> 00:33:37,590
suppose it's here to stay because of the

00:33:35,140 --> 00:33:40,929
smaller architectures that don't need

00:33:37,590 --> 00:33:44,140
nothing complex and they sophisticated

00:33:40,929 --> 00:33:47,530
just flat memory map the only thing

00:33:44,140 --> 00:33:50,530
about flat memory is probably moving arm

00:33:47,530 --> 00:33:53,290
specific parts that freeze a hole in

00:33:50,530 --> 00:33:56,350
memory map to a generic codes so it can

00:33:53,290 --> 00:33:59,320
be used for instance by M 868 or some

00:33:56,350 --> 00:34:01,799
other smaller architectures and this

00:33:59,320 --> 00:34:05,169
continuous memory

00:34:01,799 --> 00:34:09,970
shouldn't be too hard to remove except

00:34:05,169 --> 00:34:14,980
probably ia 64 but it's really hard to

00:34:09,970 --> 00:34:17,050
find a way to test it another thing that

00:34:14,980 --> 00:34:19,419
I wanted to ask you is have you looked

00:34:17,050 --> 00:34:21,490
into a PF and wallet

00:34:19,419 --> 00:34:23,379
it's another hook which is assumed to be

00:34:21,490 --> 00:34:25,210
fast but it's slow in some architectures

00:34:23,379 --> 00:34:27,580
and it's not implemented by every single

00:34:25,210 --> 00:34:30,129
not really I presume architecture know

00:34:27,580 --> 00:34:31,090
what it does but a you mean arm 64 is

00:34:30,129 --> 00:34:34,600
slow because of

00:34:31,090 --> 00:34:37,480
yeah well some architectures presumes

00:34:34,600 --> 00:34:40,600
that the most memory between start and

00:34:37,480 --> 00:34:43,810
then PFN is valid for arm it's not

00:34:40,600 --> 00:34:46,990
really the case so they have to do their

00:34:43,810 --> 00:34:49,560
own magic because not the entire DRM is

00:34:46,990 --> 00:34:51,970
valid memory from Kerala perspective and

00:34:49,560 --> 00:34:55,090
they probably should talk to young

00:34:51,970 --> 00:34:58,990
people how to make this faster okay

00:34:55,090 --> 00:35:01,240
another thing is that so we have two

00:34:58,990 --> 00:35:03,640
different ways to initialize memory map

00:35:01,240 --> 00:35:06,060
during boot it's we either do it earlier

00:35:03,640 --> 00:35:11,770
we do it with the deferred

00:35:06,060 --> 00:35:13,570
initialization and I think we eventually

00:35:11,770 --> 00:35:16,000
we could enable defer to be the default

00:35:13,570 --> 00:35:17,980
because there is no reason to have it in

00:35:16,000 --> 00:35:19,900
two like in two different places

00:35:17,980 --> 00:35:22,930
there is no drawbacks and doing it

00:35:19,900 --> 00:35:26,980
always later except that it's less

00:35:22,930 --> 00:35:29,500
stable and we could I remember there was

00:35:26,980 --> 00:35:33,580
some problems on other architectures in

00:35:29,500 --> 00:35:35,800
x86 probably they all got fixed I think

00:35:33,580 --> 00:35:38,320
our more power had to issues visited

00:35:35,800 --> 00:35:44,290
some time ago we probably evolved the

00:35:38,320 --> 00:35:47,980
fixed I don't remember we first of all

00:35:44,290 --> 00:35:52,500
first of all we need to make sparse

00:35:47,980 --> 00:35:55,900
available for everybody and it's kind of

00:35:52,500 --> 00:35:57,460
unrelated if other architectures would

00:35:55,900 --> 00:36:00,400
like differed the one wouldn't like

00:35:57,460 --> 00:36:02,830
differed and probably for smaller

00:36:00,400 --> 00:36:05,230
machines deferred memory management in

00:36:02,830 --> 00:36:12,430
cell is a paging initialization doesn't

00:36:05,230 --> 00:36:18,160
make a lot of sense Ted will take it

00:36:12,430 --> 00:36:21,130
offline like my mother and the initially

00:36:18,160 --> 00:36:22,210
thing as far as I'm aware from my

00:36:21,130 --> 00:36:24,880
knowledge and having looked at the

00:36:22,210 --> 00:36:26,680
coaches now we reserved the unit of the

00:36:24,880 --> 00:36:28,270
area man block reserved dynamically and

00:36:26,680 --> 00:36:29,650
we free it later on to make sure it can

00:36:28,270 --> 00:36:31,150
be reallocated it gets removed off the

00:36:29,650 --> 00:36:33,550
men block reserve list so it's wrong

00:36:31,150 --> 00:36:34,690
somewhere that's correct so if you're

00:36:33,550 --> 00:36:37,360
missing that power it's probably just

00:36:34,690 --> 00:36:38,740
remaining reserved and not being given

00:36:37,360 --> 00:36:39,869
to them while spider

00:36:38,740 --> 00:36:43,259
I'll ask Michael

00:36:39,869 --> 00:36:44,579
yeah a couple of things you're I do

00:36:43,259 --> 00:36:47,940
removing some stuff before setup arch

00:36:44,579 --> 00:36:50,670
you'll need hoops before that to be able

00:36:47,940 --> 00:36:53,640
to detect memory because I'm 64 we have

00:36:50,670 --> 00:36:55,619
to go through finding the DT mapping

00:36:53,640 --> 00:36:56,609
that which for that to be able to for us

00:36:55,619 --> 00:36:59,160
to be able to do that we need to be able

00:36:56,609 --> 00:37:00,809
to have fixed map up and running so you

00:36:59,160 --> 00:37:03,420
need to go and create all are fixed map

00:37:00,809 --> 00:37:05,309
page tables once we got to the DT we

00:37:03,420 --> 00:37:07,140
might be using memory map from DT we

00:37:05,309 --> 00:37:08,970
might be using memory map from efi so

00:37:07,140 --> 00:37:10,230
you might have to go in map all the FI

00:37:08,970 --> 00:37:12,210
data structures and go through all of

00:37:10,230 --> 00:37:13,769
that and we might need to pass them on

00:37:12,210 --> 00:37:15,119
on options to do mem what limiting and

00:37:13,769 --> 00:37:16,440
other things to go through that there's

00:37:15,119 --> 00:37:18,329
a huge amount of work we have to do

00:37:16,440 --> 00:37:20,430
before we even know where memory is so I

00:37:18,329 --> 00:37:21,839
suspect that a better thing would be to

00:37:20,430 --> 00:37:24,710
split set up arch into a number of

00:37:21,839 --> 00:37:27,630
distinct phases rather than just having

00:37:24,710 --> 00:37:29,160
doo-doo page tail all set up here do

00:37:27,630 --> 00:37:31,380
memory notes up here there's a lot of

00:37:29,160 --> 00:37:46,589
pre-work they've got its architecture

00:37:31,380 --> 00:37:48,690
specific probably can't you do the

00:37:46,589 --> 00:37:51,029
reserve it's really only reservations

00:37:48,690 --> 00:37:52,380
before anything else is running there is

00:37:51,029 --> 00:37:53,970
some stuff we can do early but some of

00:37:52,380 --> 00:37:56,039
the stuff you suggested doing there we

00:37:53,970 --> 00:37:58,019
wouldn't know until we've done right the

00:37:56,039 --> 00:38:00,299
other guys were fixed up yeah until we

00:37:58,019 --> 00:38:01,829
hope the memory map which we don't know

00:38:00,299 --> 00:38:03,900
until we've discovered if we're using no

00:38:01,829 --> 00:38:05,519
probably your women was your set of Park

00:38:03,900 --> 00:38:09,839
and then you won't be implementing those

00:38:05,519 --> 00:38:12,480
oh yeah but again it's clearly set apart

00:38:09,839 --> 00:38:17,640
for four different pieces is way to

00:38:12,480 --> 00:38:20,039
architecture specific I couldn't say I

00:38:17,640 --> 00:38:22,680
sees a common pattern of doing things

00:38:20,039 --> 00:38:23,809
like okay you don't do you segment 686

00:38:22,680 --> 00:38:26,910
and special segments

00:38:23,809 --> 00:38:29,160
Barba's Park and some other Hardware

00:38:26,910 --> 00:38:30,420
pieces that they going to and I don't

00:38:29,160 --> 00:38:33,150
really know how they're related to

00:38:30,420 --> 00:38:35,999
memory but but splitting set apart

00:38:33,150 --> 00:38:37,950
doesn't seem like it some things are

00:38:35,999 --> 00:38:40,019
going to apply but that might be one of

00:38:37,950 --> 00:38:41,759
my discussions not every architecture

00:38:40,019 --> 00:38:44,999
has to implement exact call books but if

00:38:41,759 --> 00:38:47,190
we have like 20 out of 25 doing the

00:38:44,999 --> 00:38:49,980
these instead of what we have now is

00:38:47,190 --> 00:38:52,450
still being but yeah and one last thing

00:38:49,980 --> 00:38:54,490
and so furnishing

00:38:52,450 --> 00:38:55,930
linear map or the direct map or whatever

00:38:54,490 --> 00:38:57,220
recall because we don't have a generic

00:38:55,930 --> 00:39:00,640
term for that which is also another

00:38:57,220 --> 00:39:02,530
problem we should figure out 164 we do

00:39:00,640 --> 00:39:04,000
this thing we'll use the fixed map to go

00:39:02,530 --> 00:39:05,140
and create all our paper we use fixed

00:39:04,000 --> 00:39:08,020
map slots to go and create web page

00:39:05,140 --> 00:39:09,580
tables which means that we go create set

00:39:08,020 --> 00:39:11,080
of page tables that are not active at

00:39:09,580 --> 00:39:12,820
that point in time and then flip over to

00:39:11,080 --> 00:39:16,090
them and then suddenly everything is

00:39:12,820 --> 00:39:19,360
mapped everything's nice and when do you

00:39:16,090 --> 00:39:23,500
use a flip or so in said about when we

00:39:19,360 --> 00:39:24,850
go go through us in it mmm I think we

00:39:23,500 --> 00:39:26,320
all think when we go and map all memory

00:39:24,850 --> 00:39:27,670
into this new set of page tables you map

00:39:26,320 --> 00:39:29,650
the kernel is that new set of pages I

00:39:27,670 --> 00:39:31,360
think is paging it sorry yes under

00:39:29,650 --> 00:39:32,830
pigeon it we go and do love that it's

00:39:31,360 --> 00:39:35,620
all fine grade all set up so that we can

00:39:32,830 --> 00:39:39,120
go flip permissions later on for you

00:39:35,620 --> 00:39:42,850
know the all of that is basically

00:39:39,120 --> 00:39:44,290
potentially generic because it's not

00:39:42,850 --> 00:39:46,660
very architecture specific at all I

00:39:44,290 --> 00:39:49,480
noticed that the risk by folk have done

00:39:46,660 --> 00:39:53,140
copied parts of that conceptually but

00:39:49,480 --> 00:39:56,560
not all of it mimic actually the direct

00:39:53,140 --> 00:40:00,730
map part is mostly architecture specific

00:39:56,560 --> 00:40:04,600
in many ways like well it will be harder

00:40:00,730 --> 00:40:08,230
to extract anyway I take a look at x86

00:40:04,600 --> 00:40:10,660
or power so what what I was thinking

00:40:08,230 --> 00:40:14,950
that page in unit remains is it at least

00:40:10,660 --> 00:40:16,300
10 for the time being and I strongly

00:40:14,950 --> 00:40:17,410
suspect there is a large amount of

00:40:16,300 --> 00:40:19,600
character that we could reuse across

00:40:17,410 --> 00:40:23,110
architectures even if there ain't

00:40:19,600 --> 00:40:25,000
constraints the very yes but it will be

00:40:23,110 --> 00:40:27,810
much harder than pulling doing most

00:40:25,000 --> 00:40:27,810
obvious parts

00:40:40,450 --> 00:40:49,460
I've been current with unpublish at

00:40:45,860 --> 00:40:51,740
least but sweet water of what you

00:40:49,460 --> 00:40:57,620
describe into the park we do before we

00:40:51,740 --> 00:41:00,650
even course.com for bunch of / PC

00:40:57,620 --> 00:41:02,240
platforms for example we pretty much

00:41:00,650 --> 00:41:04,580
have to set up the MMU just to be able

00:41:02,240 --> 00:41:08,000
to call start kernel we have to

00:41:04,580 --> 00:41:11,510
basically create a linear mapping and so

00:41:08,000 --> 00:41:16,120
puppy 64 has this thing called early in

00:41:11,510 --> 00:41:18,800
it which is called from the assembly and

00:41:16,120 --> 00:41:24,470
bucket load of what you described before

00:41:18,800 --> 00:41:31,850
we even had impressions a small part of

00:41:24,470 --> 00:41:34,790
it is going and then it splits

00:41:31,850 --> 00:41:36,980
I think and it's different on 32 and 64

00:41:34,790 --> 00:41:42,260
and it's different between families as

00:41:36,980 --> 00:41:45,620
well but yeah the hash table for example

00:41:42,260 --> 00:41:48,410
on hash based is to be set up before we

00:41:45,620 --> 00:41:51,530
even called you know maybe so like I

00:41:48,410 --> 00:41:53,840
said to mark if there are constraints

00:41:51,530 --> 00:41:55,610
there are constraints and if it can be

00:41:53,840 --> 00:41:57,620
moved to generic also it can be moved to

00:41:55,610 --> 00:42:01,340
generic words now question about this

00:41:57,620 --> 00:42:03,110
block thing what we know by the time

00:42:01,340 --> 00:42:04,640
with free in Atari we've stopped using

00:42:03,110 --> 00:42:05,930
main block allocations now we've

00:42:04,640 --> 00:42:08,240
provided everything into the page

00:42:05,930 --> 00:42:10,250
rotator I don't know about PowerPC keeps

00:42:08,240 --> 00:42:12,740
main block yeah yeah well you keep we

00:42:10,250 --> 00:42:14,480
keep it only to have a look at where the

00:42:12,740 --> 00:42:17,450
physical memories we don't use it as an

00:42:14,480 --> 00:42:20,000
alligator anymore because it's out of

00:42:17,450 --> 00:42:22,810
date it's no longer representative after

00:42:20,000 --> 00:42:26,710
we switch to the pager lock isn't it

00:42:22,810 --> 00:42:26,710
am I missing something here

00:42:28,289 --> 00:42:32,049
I'll have to double-check but as far as

00:42:30,640 --> 00:42:33,759
those aware we were freeing that before

00:42:32,049 --> 00:42:35,049
we'd hand it over to the page.i locator

00:42:33,759 --> 00:42:38,949
I think we remember lot free all

00:42:35,049 --> 00:42:41,769
slightly after that but so what it seems

00:42:38,949 --> 00:42:46,199
to be that power has the area of in it

00:42:41,769 --> 00:42:46,199
are the results for the entire lifetime

00:42:47,039 --> 00:43:03,880
apparently I'm not hundred percent sure

00:42:49,509 --> 00:43:06,009
but it what it seems I think maybe there

00:43:03,880 --> 00:43:10,059
are it there is some difference between

00:43:06,009 --> 00:43:13,059
the 32 32 and 64 today to have some high

00:43:10,059 --> 00:43:18,999
memory and maybe that's a simpler for

00:43:13,059 --> 00:43:24,630
the 64 64 to memory blocking it the pen

00:43:18,999 --> 00:43:29,039
the keep in I I deal with 32 system and

00:43:24,630 --> 00:43:32,699
see sky architecture and and you know

00:43:29,039 --> 00:43:37,239
some use some customers want to want to

00:43:32,699 --> 00:43:40,359
use some memory it's parsed and they

00:43:37,239 --> 00:43:43,419
want physical a lot of horse in there

00:43:40,359 --> 00:43:46,390
and then my young man per member per la

00:43:43,419 --> 00:43:49,569
comida you yeah you you are deal with

00:43:46,390 --> 00:43:51,729
the a lot of a lot of horse and in

00:43:49,569 --> 00:43:54,069
addition to the high memory and you

00:43:51,729 --> 00:44:00,909
needed to cross the difference room

00:43:54,069 --> 00:44:01,599
that's one my one my very few pen keep

00:44:00,909 --> 00:44:03,789
hearing things

00:44:01,599 --> 00:44:07,359
yeah what this one and a second is about

00:44:03,789 --> 00:44:09,339
the fixed mem the fixed member in fact I

00:44:07,359 --> 00:44:13,809
singer is only used to for some the key

00:44:09,339 --> 00:44:15,939
high memory high memory atomic atomic

00:44:13,809 --> 00:44:18,009
mapping of things does does is enough

00:44:15,939 --> 00:44:21,369
but I think a lot but I saw a lot of

00:44:18,009 --> 00:44:25,959
architecture use it to is to some

00:44:21,369 --> 00:44:30,039
special ones and put some PCI mappings

00:44:25,959 --> 00:44:33,929
or wear a lead agency seems on the fixed

00:44:30,039 --> 00:44:38,380
mapping to deal with but so I think

00:44:33,929 --> 00:44:39,599
there seems a lot of stores issues to do

00:44:38,380 --> 00:44:42,869
is and

00:44:39,599 --> 00:44:45,209
but I agree to make this mixings too

00:44:42,869 --> 00:44:49,549
easy to unify together in because this

00:44:45,209 --> 00:44:54,619
guy is the new one and and and we feel

00:44:49,549 --> 00:44:56,749
generic is best okay thanks

00:44:54,619 --> 00:44:59,729
all right

00:44:56,749 --> 00:45:01,589
final comments or shall we and she'll be

00:44:59,729 --> 00:45:12,259
on Rochelle yeah all right okay

00:45:01,589 --> 00:45:12,259
let's thank Mike again thank you

00:45:23,940 --> 00:45:27,480
let me get your mic

00:45:48,540 --> 00:45:52,460
[Laughter]

00:45:53,600 --> 00:45:57,140
yeah thank you

00:46:07,170 --> 00:46:18,630
all right could someone close the door

00:46:12,160 --> 00:46:18,630

YouTube URL: https://www.youtube.com/watch?v=KGaEiTBvJOA


