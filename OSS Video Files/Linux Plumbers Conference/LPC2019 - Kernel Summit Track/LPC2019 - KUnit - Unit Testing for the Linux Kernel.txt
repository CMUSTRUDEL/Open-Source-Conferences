Title: LPC2019 - KUnit - Unit Testing for the Linux Kernel
Publication date: 2019-11-18
Playlist: LPC2019 - Kernel Summit Track
Description: 
	KUnit is a new lightweight unit testing and mocking framework for the Linux kernel. Unlike Autotest and kselftest, KUnit is a true unit testing framework; it does not require installing the kernel on a test machine or in a VM (however, KUnit still allows you to run tests on test machines or in VMs if you want) and does not require tests to be written in userspace running on a host kernel. You can read more about KUnit in this LWN article.

In the first half of the talk we will provide background on what unit testing is, why we think it is important for the Linux kernel, how KUnit provides a viable unit testing library implementation, and offer a brief demonstration of how it might be used.

In the second half of the talk we will talk about the future. We will talk about KUnit's roadmap, the challenges that KUnit is facing, how to structure the Linux kernel testing paradigm, and how KUnit fits into it.


Brendan Higgins (Google LLC)
Captions: 
	00:00:00,030 --> 00:00:09,589
all right next up is Brendan Higgins

00:00:04,589 --> 00:00:09,589
who's gonna be talking about K unit yep

00:00:11,780 --> 00:00:17,220
yeah so as Ted said my name is Brendan I

00:00:15,210 --> 00:00:19,770
work at Google I used to work on server

00:00:17,220 --> 00:00:21,570
bring up at Google and I also used to

00:00:19,770 --> 00:00:23,970
work on open BMC if anybody knows what

00:00:21,570 --> 00:00:26,730
that is right now I'm spending all my

00:00:23,970 --> 00:00:28,710
time working on K unit because it

00:00:26,730 --> 00:00:32,510
actually turns out it took singing a lot

00:00:28,710 --> 00:00:32,510
more effort than I thought it would so

00:00:33,020 --> 00:00:39,120
yeah so first off I want to make sure I

00:00:37,110 --> 00:00:42,180
remembered to say those please interrupt

00:00:39,120 --> 00:00:46,410
me this talk is for you I you know I

00:00:42,180 --> 00:00:48,809
already know what it like about K unit

00:00:46,410 --> 00:00:50,340
and stuff so I would much rather talk

00:00:48,809 --> 00:00:52,890
about what the audience wants to talk

00:00:50,340 --> 00:00:56,579
about rather than what I think that you

00:00:52,890 --> 00:00:58,350
want to talk about so I also really

00:00:56,579 --> 00:01:01,140
really hate slide decks like I hate the

00:00:58,350 --> 00:01:03,180
concept of slide decks so by definition

00:01:01,140 --> 00:01:05,760
I think my slide decks aren't very good

00:01:03,180 --> 00:01:09,479
because I don't think you can make it

00:01:05,760 --> 00:01:15,570
slide decks so anyway don't don't read

00:01:09,479 --> 00:01:19,650
into that too far so yeah so so why unit

00:01:15,570 --> 00:01:20,939
testing YK unit so I think it's demo

00:01:19,650 --> 00:01:24,689
time because I think it's supposed to

00:01:20,939 --> 00:01:27,180
just let it speak for itself so oh this

00:01:24,689 --> 00:01:28,979
is funny I just realized so I I can't

00:01:27,180 --> 00:01:37,310
for some reason mirror my display so I'm

00:01:28,979 --> 00:01:37,310
going to have to put let's see okay

00:01:39,090 --> 00:01:47,250
okay there we go cool so I'm going to

00:01:42,509 --> 00:01:49,880
have to look at where my mouse go there

00:01:47,250 --> 00:01:53,600
we go I'm gonna have to look at the

00:01:49,880 --> 00:01:54,869
monitor on here so that's gonna be fun

00:01:53,600 --> 00:02:02,240
okay

00:01:54,869 --> 00:02:07,799
so so all this is I checked out she was

00:02:02,240 --> 00:02:09,060
for next branch so the this the the code

00:02:07,799 --> 00:02:12,720
that's here is going to be available

00:02:09,060 --> 00:02:20,160
like upstream whenever she was branch

00:02:12,720 --> 00:02:27,720
gets pulled into Lennox mainline oh yeah

00:02:20,160 --> 00:02:32,489
let's see is this good

00:02:27,720 --> 00:02:34,709
can everyone read this yes more you want

00:02:32,489 --> 00:02:37,290
to be bigger okay cool

00:02:34,709 --> 00:02:38,760
so the only modification I did is I

00:02:37,290 --> 00:02:40,049
intentionally went and broke some code

00:02:38,760 --> 00:02:41,160
so that way you can see what a test

00:02:40,049 --> 00:02:43,170
failure looks like but other than that

00:02:41,160 --> 00:02:47,640
this is just what's in the shoe is Linux

00:02:43,170 --> 00:02:51,000
next so you can run cane it like this I

00:02:47,640 --> 00:02:53,160
added some extra parameters for setting

00:02:51,000 --> 00:02:58,650
a timeout and for making it oops

00:02:53,160 --> 00:03:00,720
oh I unbroke the test oh wow

00:02:58,650 --> 00:03:04,760
so I ran through this ahead of time and

00:03:00,720 --> 00:03:06,590
you know I wanted to make sure that I

00:03:04,760 --> 00:03:11,569
did this problem

00:03:06,590 --> 00:03:15,450
okay I'm gonna break it on my side so

00:03:11,569 --> 00:03:17,430
yeah I didn't actually save and go so

00:03:15,450 --> 00:03:19,410
I'm just gonna break it you won't be

00:03:17,430 --> 00:03:24,829
able to see me break it and it'll just

00:03:19,410 --> 00:03:24,829
have to trust that okay

00:03:26,430 --> 00:03:34,610
so I guess this is this is what happens

00:03:29,459 --> 00:03:44,280
when I kind of asked for this yeah yeah

00:03:34,610 --> 00:03:49,530
okay so this should fail now yes fails

00:03:44,280 --> 00:03:52,200
okay cool and so okay I can't there we

00:03:49,530 --> 00:03:53,340
go we can scroll okay so this is what a

00:03:52,200 --> 00:03:55,319
failure looks like you have an

00:03:53,340 --> 00:03:59,849
expectation failed at this for this line

00:03:55,319 --> 00:04:03,239
so I'm going to open up this file oh wow

00:03:59,849 --> 00:04:13,790
dexterity trying to do on looking

00:04:03,239 --> 00:04:13,790
sideways okay - Pete

00:04:16,699 --> 00:04:24,300
so naming convention I've been trying to

00:04:20,579 --> 00:04:25,620
promote is it tests a thing so if you

00:04:24,300 --> 00:04:27,780
have a unit test profile then it's going

00:04:25,620 --> 00:04:31,919
to test that thing and then the unit

00:04:27,780 --> 00:04:34,260
test will be that name - test so this so

00:04:31,919 --> 00:04:40,280
in this case the Tethys is called test

00:04:34,260 --> 00:04:40,280
tests this is control

00:04:41,180 --> 00:04:52,080
just CTL there you go cool

00:04:47,720 --> 00:04:55,830
so if so if we went back there it tests

00:04:52,080 --> 00:05:00,960
in line I think what was a 363 through

00:04:55,830 --> 00:05:03,680
68 yeah so we see that there's an

00:05:00,960 --> 00:05:06,720
expectation here it calls this function

00:05:03,680 --> 00:05:09,479
praÃ§a do int Veck and expects us to

00:05:06,720 --> 00:05:15,570
return an e and fell so we know that

00:05:09,479 --> 00:05:16,860
we're looking for a an air no to be

00:05:15,570 --> 00:05:18,090
returned by this and it's returning the

00:05:16,860 --> 00:05:22,050
long one

00:05:18,090 --> 00:05:23,370
if we go back to the example we saw that

00:05:22,050 --> 00:05:26,099
the number that was printing it out

00:05:23,370 --> 00:05:29,370
corresponds to e range so we can just

00:05:26,099 --> 00:05:30,419
look for a range here and I had already

00:05:29,370 --> 00:05:33,260
opened it to that line because I

00:05:30,419 --> 00:05:33,260
intentionally broke up

00:05:34,940 --> 00:05:47,060
so to be well okay

00:05:43,130 --> 00:05:54,250
and if I run the test again should pass

00:05:47,060 --> 00:05:59,480
now yeah cool so that that worked out

00:05:54,250 --> 00:06:08,240
you know I need to get rid of this let's

00:05:59,480 --> 00:06:09,860
go okay this suite okay so I did also

00:06:08,240 --> 00:06:12,290
record a video just in case my demo

00:06:09,860 --> 00:06:13,940
didn't work but I just do basically the

00:06:12,290 --> 00:06:16,550
same thing except in a slightly more

00:06:13,940 --> 00:06:19,910
organized fashion with that as much

00:06:16,550 --> 00:06:21,800
mumbling so so how's it different from

00:06:19,910 --> 00:06:24,200
the testing we already have I think the

00:06:21,800 --> 00:06:26,720
first thing is it's pretty fast unlike

00:06:24,200 --> 00:06:28,430
my demo the the test run pretty fast all

00:06:26,720 --> 00:06:30,050
you have like right now they're pretty

00:06:28,430 --> 00:06:32,780
much bound by how fast you can build the

00:06:30,050 --> 00:06:34,750
kernel it doesn't depend on user land I

00:06:32,780 --> 00:06:37,760
think that was that was pretty obvious

00:06:34,750 --> 00:06:39,230
hopefully sort of obvious and it doesn't

00:06:37,760 --> 00:06:41,060
have any external dependencies and

00:06:39,230 --> 00:06:43,040
writing a test is no different than

00:06:41,060 --> 00:06:44,870
writing any regular kernel cookus that

00:06:43,040 --> 00:06:47,540
the actual test links against the code

00:06:44,870 --> 00:06:49,460
that's under test so I think that that

00:06:47,540 --> 00:06:50,750
makes it pretty convenient it means that

00:06:49,460 --> 00:06:55,040
you can just test like arbitrary

00:06:50,750 --> 00:07:00,380
functions in the kernel so in other

00:06:55,040 --> 00:07:02,000
words it's unit testing so I I debated

00:07:00,380 --> 00:07:03,080
on including the next section because I

00:07:02,000 --> 00:07:05,540
don't really want to get up here and

00:07:03,080 --> 00:07:07,130
preach about like unit testing and like

00:07:05,540 --> 00:07:11,360
how unit testing is different from other

00:07:07,130 --> 00:07:13,460
things I think that if like people want

00:07:11,360 --> 00:07:15,740
to understand like the the reasoning we

00:07:13,460 --> 00:07:17,120
fought behind like why I made some of

00:07:15,740 --> 00:07:20,480
the decisions that I did it's probably

00:07:17,120 --> 00:07:21,500
understand important to understand you

00:07:20,480 --> 00:07:25,400
know there's there's different

00:07:21,500 --> 00:07:27,080
philosophies for testing but it would be

00:07:25,400 --> 00:07:29,720
important to sort of to understand my

00:07:27,080 --> 00:07:32,210
philosophy of testing of what unit tests

00:07:29,720 --> 00:07:33,830
are so do people want to hear about that

00:07:32,210 --> 00:07:37,630
or do we want to move on to something

00:07:33,830 --> 00:07:41,330
else here about it okay we'll talk about

00:07:37,630 --> 00:07:43,130
yeah so I think so the way I like to

00:07:41,330 --> 00:07:44,870
break down testing and there's a lot of

00:07:43,130 --> 00:07:45,800
tests that fit outside of this testing

00:07:44,870 --> 00:07:49,190
category just

00:07:45,800 --> 00:07:50,810
rÃ©gime whatever but I'm just gonna say

00:07:49,190 --> 00:07:51,229
tests can be broken down into other unit

00:07:50,810 --> 00:07:53,690
toughs

00:07:51,229 --> 00:07:55,310
integration tests are into n test so I'm

00:07:53,690 --> 00:07:58,460
going to start off with do people

00:07:55,310 --> 00:07:59,870
already feel like they're got like how

00:07:58,460 --> 00:08:01,669
many people here feel like you know the

00:07:59,870 --> 00:08:03,650
difference between a unit tests and

00:08:01,669 --> 00:08:05,840
integration doesn't matter to us can you

00:08:03,650 --> 00:08:10,580
raise your hand okay that's the most

00:08:05,840 --> 00:08:12,440
people so I get huh yeah yeah so maybe

00:08:10,580 --> 00:08:15,710
we should just move on so I'll just run

00:08:12,440 --> 00:08:17,120
through it really quick then so an

00:08:15,710 --> 00:08:18,620
end-to-end test the point is you're

00:08:17,120 --> 00:08:20,569
supposed to test the entire system under

00:08:18,620 --> 00:08:21,919
test from the standpoint of the kernel I

00:08:20,569 --> 00:08:23,449
don't think this necessarily means like

00:08:21,919 --> 00:08:25,729
you could argue that would be just in

00:08:23,449 --> 00:08:27,800
testing like an entire application that

00:08:25,729 --> 00:08:29,569
you have I think from the standpoint of

00:08:27,800 --> 00:08:31,310
the kernel this means you actually boot

00:08:29,569 --> 00:08:32,930
a real kernel on a real machine you have

00:08:31,310 --> 00:08:35,180
some user land programs let's directly

00:08:32,930 --> 00:08:39,289
interact with the kernel and then you

00:08:35,180 --> 00:08:41,240
tested that way you're supposed to be

00:08:39,289 --> 00:08:46,370
trying to emulate what it would look

00:08:41,240 --> 00:08:48,140
like for a user of your system so I have

00:08:46,370 --> 00:08:50,329
an example here of you might be you

00:08:48,140 --> 00:08:51,920
might want to do this by like I said

00:08:50,329 --> 00:08:54,290
just running on production hardware and

00:08:51,920 --> 00:08:55,820
then trying to exercise some behavior

00:08:54,290 --> 00:08:57,560
that depends on the hardware the kernel

00:08:55,820 --> 00:08:59,720
and then like the fiscal interface you

00:08:57,560 --> 00:09:01,490
provide the idea is you're trying to

00:08:59,720 --> 00:09:06,050
keep it as close to the production like

00:09:01,490 --> 00:09:09,100
environment as possible a unit test is

00:09:06,050 --> 00:09:12,290
supposed to test things in isolation so

00:09:09,100 --> 00:09:15,800
that the idea is you're you're you're

00:09:12,290 --> 00:09:18,560
exchanging the realism for determinism

00:09:15,800 --> 00:09:20,420
and hermiticity so your test should be a

00:09:18,560 --> 00:09:22,550
lot more predictable they should be a

00:09:20,420 --> 00:09:24,260
lot faster and easier to understand and

00:09:22,550 --> 00:09:26,329
it's a lot easier to write them and

00:09:24,260 --> 00:09:28,760
maintain them they should be very very

00:09:26,329 --> 00:09:31,040
fast and they shouldn't require any kind

00:09:28,760 --> 00:09:33,890
of setup like when I say fast I mean

00:09:31,040 --> 00:09:39,560
your test should run on the orders of

00:09:33,890 --> 00:09:40,820
milliseconds so yeah and an integration

00:09:39,560 --> 00:09:43,190
test the way I think of it as it's just

00:09:40,820 --> 00:09:46,579
something that's in between a unit test

00:09:43,190 --> 00:09:48,019
and an end-to-end test it does to test

00:09:46,579 --> 00:09:50,000
the interaction between things under

00:09:48,019 --> 00:09:52,490
certain circumstances you could write a

00:09:50,000 --> 00:09:54,170
hardware integration test that just

00:09:52,490 --> 00:09:58,579
tests how a driver interacts with its

00:09:54,170 --> 00:09:59,750
hardware but at the same time you're

00:09:58,579 --> 00:10:00,170
still trying to keep it as simple as

00:09:59,750 --> 00:10:02,389
possible

00:10:00,170 --> 00:10:08,510
of all it's not necessarily going to be

00:10:02,389 --> 00:10:11,779
a realistic environment etc etc so I

00:10:08,510 --> 00:10:13,670
have a little punnett square thing here

00:10:11,779 --> 00:10:16,490
that compares the different things so

00:10:13,670 --> 00:10:20,839
basically unit tests and an tester just

00:10:16,490 --> 00:10:22,910
kind of opposite the scope for units

00:10:20,839 --> 00:10:25,100
house is very small which means that in

00:10:22,910 --> 00:10:26,449
terms of overall coverage I should have

00:10:25,100 --> 00:10:27,889
probably specified that the overall

00:10:26,449 --> 00:10:29,870
coverage you can achieve with all of

00:10:27,889 --> 00:10:35,029
your units house is quite high because

00:10:29,870 --> 00:10:37,370
you can test functions directly but the

00:10:35,029 --> 00:10:38,810
amount of coverage for an individual

00:10:37,370 --> 00:10:40,070
unit test is going to be quite low

00:10:38,810 --> 00:10:43,310
because you're just testing a little

00:10:40,070 --> 00:10:45,620
single unit they're gonna be really fast

00:10:43,310 --> 00:10:47,240
you should have a really kind confidence

00:10:45,620 --> 00:10:49,160
in the individual thing that you're

00:10:47,240 --> 00:10:51,380
testing but that also means that you

00:10:49,160 --> 00:10:53,630
have very low confidence in like the

00:10:51,380 --> 00:10:55,760
overall system and then tests are the

00:10:53,630 --> 00:11:00,709
opposite in an integration test was just

00:10:55,760 --> 00:11:03,139
a trade off so keen it's not a new idea

00:11:00,709 --> 00:11:04,370
lots of other people already use you

00:11:03,139 --> 00:11:06,079
know testing there's lots of other

00:11:04,370 --> 00:11:08,690
really really good examples of unit

00:11:06,079 --> 00:11:13,310
testing libraries out there in what I've

00:11:08,690 --> 00:11:15,680
put and what is staged and Linux next

00:11:13,310 --> 00:11:18,140
there really aren't any super new

00:11:15,680 --> 00:11:23,060
original ideas out there it's all stuff

00:11:18,140 --> 00:11:26,510
that exists so I I don't think I should

00:11:23,060 --> 00:11:29,300
be awarded for any kind of cleverness in

00:11:26,510 --> 00:11:30,649
Kim Yuna it's really just about if I

00:11:29,300 --> 00:11:33,920
deserve any praise for anything it's

00:11:30,649 --> 00:11:39,199
just because of the will that's taken to

00:11:33,920 --> 00:11:40,579
do it yeah so I don't really want to

00:11:39,199 --> 00:11:42,649
talking about the X unit stuff we really

00:11:40,579 --> 00:11:45,230
look at an example if you want to learn

00:11:42,649 --> 00:11:47,769
more about X unit stuff there's this

00:11:45,230 --> 00:11:51,380
really good Martin Fowler article on it

00:11:47,769 --> 00:11:52,910
I guess I didn't actually use the define

00:11:51,380 --> 00:11:56,600
the term X you know do people feel like

00:11:52,910 --> 00:11:59,810
they know what X unit is yes raise your

00:11:56,600 --> 00:12:02,269
hand okay so that's actually know so

00:11:59,810 --> 00:12:05,680
actually and it is is basically just the

00:12:02,269 --> 00:12:08,149
it's it's a really popular style a

00:12:05,680 --> 00:12:10,310
framework for writing unit tests

00:12:08,149 --> 00:12:11,779
basically you have like some setup code

00:12:10,310 --> 00:12:13,520
that runs before every single test case

00:12:11,779 --> 00:12:16,250
you have a collection of test case

00:12:13,520 --> 00:12:17,300
and then after every taste test case you

00:12:16,250 --> 00:12:20,450
have some cleanup code that you would

00:12:17,300 --> 00:12:22,400
like to run after every single test case

00:12:20,450 --> 00:12:25,700
and it just makes it easier for you to

00:12:22,400 --> 00:12:29,000
do that that's the kind of pattern that

00:12:25,700 --> 00:12:31,130
I followed with Keita I have a better I

00:12:29,000 --> 00:12:34,460
have an example of that we can look at

00:12:31,130 --> 00:12:36,310
if anyone wants to see it but I think

00:12:34,460 --> 00:12:41,180
it's pretty employee explanatory

00:12:36,310 --> 00:12:43,370
so where's king unit today

00:12:41,180 --> 00:12:47,810
the initial patch set which includes the

00:12:43,370 --> 00:12:50,420
ability to define unit tests along with

00:12:47,810 --> 00:12:51,410
individual test cases and like I

00:12:50,420 --> 00:12:55,160
mentioned this is setup and teardown

00:12:51,410 --> 00:12:57,110
logic expectations and assertions which

00:12:55,160 --> 00:12:59,060
give you the ability to actually like

00:12:57,110 --> 00:13:02,110
define the behavior that you would like

00:12:59,060 --> 00:13:04,280
the code under test to exhibit

00:13:02,110 --> 00:13:06,590
assertions are just an expectation that

00:13:04,280 --> 00:13:09,020
allows you to bail out a test quickly

00:13:06,590 --> 00:13:13,190
and easily there's a resource management

00:13:09,020 --> 00:13:14,870
API so basically if you're you know if

00:13:13,190 --> 00:13:16,280
you're if you're writing if you want a

00:13:14,870 --> 00:13:22,790
unit test some code you're probably

00:13:16,280 --> 00:13:25,310
going to want to use resources from

00:13:22,790 --> 00:13:27,520
other parts of the kernel in your part

00:13:25,310 --> 00:13:30,050
of your test so it makes really easy to

00:13:27,520 --> 00:13:31,730
use resources and not have to care about

00:13:30,050 --> 00:13:35,750
it the test case will just clean it up

00:13:31,730 --> 00:13:38,360
for you and there's also some tests so

00:13:35,750 --> 00:13:40,580
oh yeah and also I think the thing that

00:13:38,360 --> 00:13:43,610
I showed in the example the really

00:13:40,580 --> 00:13:45,140
pretty light colors there's a there's a

00:13:43,610 --> 00:13:47,420
test that extracts the key and it

00:13:45,140 --> 00:13:50,290
results from the kernel that the results

00:13:47,420 --> 00:13:54,890
are kernel readable are human readable

00:13:50,290 --> 00:13:57,050
in the D message log and there's a tool

00:13:54,890 --> 00:13:58,460
that makes it really easy to like it

00:13:57,050 --> 00:13:59,120
parses the mount and then displays them

00:13:58,460 --> 00:14:03,460
in pretty colors

00:13:59,120 --> 00:14:03,460
so that's that's what's up there today

00:14:03,850 --> 00:14:07,970
there's a bunch of other things I'm

00:14:05,840 --> 00:14:12,260
planning on doing but I don't get to

00:14:07,970 --> 00:14:15,620
that later challenges I faced and trying

00:14:12,260 --> 00:14:17,000
to do this the main challenge is

00:14:15,620 --> 00:14:19,220
probably kind of obvious Linux kernel

00:14:17,000 --> 00:14:22,880
wasn't written intending to be unit

00:14:19,220 --> 00:14:25,060
tested actually the code was pretty good

00:14:22,880 --> 00:14:26,830
for the most part I've not found

00:14:25,060 --> 00:14:28,510
that many instances like I feel like

00:14:26,830 --> 00:14:31,620
most of the code in the kernel actually

00:14:28,510 --> 00:14:34,840
lends itself to unit testing pretty well

00:14:31,620 --> 00:14:36,790
the the links like the Linux kernel code

00:14:34,840 --> 00:14:38,830
actually exhibits a pretty high degree

00:14:36,790 --> 00:14:41,170
of encapsulation code sharing and

00:14:38,830 --> 00:14:42,700
modularity and it's pretty actually

00:14:41,170 --> 00:14:45,130
object-oriented especially in a lot of

00:14:42,700 --> 00:14:47,710
parts of like the driver stuff so it

00:14:45,130 --> 00:14:49,780
it's it's actually pretty easy for the

00:14:47,710 --> 00:14:53,200
most part to find lots of parts of the

00:14:49,780 --> 00:14:54,550
kernel that are already written well for

00:14:53,200 --> 00:14:58,870
the from the standpoint of making it

00:14:54,550 --> 00:15:01,480
unit testable the the biggest problem is

00:14:58,870 --> 00:15:04,570
that dependencies are poorly defined

00:15:01,480 --> 00:15:06,550
between different code modules so if you

00:15:04,570 --> 00:15:09,460
want to take a piece of code and unit

00:15:06,550 --> 00:15:11,380
test it you want to you still want to be

00:15:09,460 --> 00:15:14,260
able to take all the things that it

00:15:11,380 --> 00:15:17,410
depends on but not include every single

00:15:14,260 --> 00:15:19,570
thing else and so right now that means

00:15:17,410 --> 00:15:21,220
that I have to still build the can unit

00:15:19,570 --> 00:15:22,870
test into a kernel to provide all the

00:15:21,220 --> 00:15:25,690
resources that an individual test

00:15:22,870 --> 00:15:28,210
actually needs to run it'd be a lot

00:15:25,690 --> 00:15:31,000
easier if it was a lot easier and a lot

00:15:28,210 --> 00:15:32,920
nicer a lot more hermetic if we were

00:15:31,000 --> 00:15:34,570
able to just take the things that we

00:15:32,920 --> 00:15:37,960
need to run the tests that the test

00:15:34,570 --> 00:15:41,170
actually depends on the main problem I

00:15:37,960 --> 00:15:42,880
found with this is that cable represents

00:15:41,170 --> 00:15:44,590
dependencies in terms of features and

00:15:42,880 --> 00:15:47,110
not actual code dependencies like it's

00:15:44,590 --> 00:15:49,180
hard to look at a piece of code and say

00:15:47,110 --> 00:15:50,680
this piece of code defendant depends on

00:15:49,180 --> 00:15:54,610
these functions which are defined in

00:15:50,680 --> 00:15:56,710
these files if you look at the cable or

00:15:54,610 --> 00:15:59,020
the the Associated K convict's which is

00:15:56,710 --> 00:16:01,150
where the dependencies are defined you

00:15:59,020 --> 00:16:03,490
see that some feature depends on some

00:16:01,150 --> 00:16:05,890
feature it's not really and there's not

00:16:03,490 --> 00:16:10,890
really an easy way to map those things

00:16:05,890 --> 00:16:10,890
that does does that make sense yeah so

00:16:11,850 --> 00:16:19,110
so as first where we fit in the test

00:16:15,610 --> 00:16:19,110
paradigm this is probably pretty obvious

00:16:19,830 --> 00:16:29,140
there we already have lots of examples

00:16:23,740 --> 00:16:33,430
of different types of end-to-end tests

00:16:29,140 --> 00:16:36,100
and I I don't want to get like too into

00:16:33,430 --> 00:16:37,730
this I a lot of a lot of the traditional

00:16:36,100 --> 00:16:40,369
definitions of an end-to-end

00:16:37,730 --> 00:16:42,919
or of a unit test integration doesn't

00:16:40,369 --> 00:16:46,759
understand tests they are based on how

00:16:42,919 --> 00:16:48,470
much the code knows about the code

00:16:46,759 --> 00:16:50,299
that's under test and from this

00:16:48,470 --> 00:16:52,459
standpoint you could actually argue that

00:16:50,299 --> 00:16:54,259
some of these testing frameworks aren't

00:16:52,459 --> 00:16:56,660
don't us like aren't strictly end-to-end

00:16:54,259 --> 00:16:59,869
tests I don't want to debate that too

00:16:56,660 --> 00:17:02,569
much I think that based on the the

00:16:59,869 --> 00:17:04,789
criteria I defined here they look a lot

00:17:02,569 --> 00:17:06,139
more like end-to-end tests for the most

00:17:04,789 --> 00:17:09,919
part you do have to be too kernel

00:17:06,139 --> 00:17:11,480
somewhere you are mostly interacting

00:17:09,919 --> 00:17:15,679
with the code through a sis call

00:17:11,480 --> 00:17:17,600
interface I mean I think if we're going

00:17:15,679 --> 00:17:19,069
to try to like stick it in one of these

00:17:17,600 --> 00:17:22,899
three categories we'd say most of the

00:17:19,069 --> 00:17:26,480
things that are there and untouched s' I

00:17:22,899 --> 00:17:28,490
think that Kaena does a pretty good job

00:17:26,480 --> 00:17:31,159
of fitting the definition of a unit

00:17:28,490 --> 00:17:33,380
tests and even though there's definitely

00:17:31,159 --> 00:17:36,440
some overlap between what cane it can do

00:17:33,380 --> 00:17:38,570
what things like hey self kiss tests can

00:17:36,440 --> 00:17:40,370
do and the area of integration to us I

00:17:38,570 --> 00:17:43,190
don't think there's really like a clear

00:17:40,370 --> 00:17:44,840
thing that currently exists for doing

00:17:43,190 --> 00:17:46,429
the integration testing part so that I

00:17:44,840 --> 00:17:50,630
think that's that's something that

00:17:46,429 --> 00:17:59,750
probably needs further thought please

00:17:50,630 --> 00:18:01,789
feel free to disagree yeah yeah I'm not

00:17:59,750 --> 00:18:04,519
disagreeing but I'm just adding to it

00:18:01,789 --> 00:18:06,889
okay self-test kind of will fall into

00:18:04,519 --> 00:18:10,700
because of because of the way there are

00:18:06,889 --> 00:18:13,639
some modules you can load and trigger

00:18:10,700 --> 00:18:16,460
tests so it's a bunch of binaries and

00:18:13,639 --> 00:18:19,970
shell scripts we I would classify that

00:18:16,460 --> 00:18:22,190
as a combination of black box and whites

00:18:19,970 --> 00:18:25,250
box right there is some unit tests in

00:18:22,190 --> 00:18:28,279
there there are some end-to-end us and

00:18:25,250 --> 00:18:30,889
like triggering going and exercising

00:18:28,279 --> 00:18:34,690
various Cisco options for example so

00:18:30,889 --> 00:18:36,980
those kind of fall into the category of

00:18:34,690 --> 00:18:39,799
blackbox test that's written by

00:18:36,980 --> 00:18:42,100
developers right so you kind of have to

00:18:39,799 --> 00:18:44,419
do that distance so they they have that

00:18:42,100 --> 00:18:47,510
they know what they are testing they

00:18:44,419 --> 00:18:51,679
want to test and it in that respect it's

00:18:47,510 --> 00:18:54,770
not strictly back black box because the

00:18:51,679 --> 00:18:57,260
well what is test Arthur knows the cord

00:18:54,770 --> 00:19:01,549
so in that respect it's not strictly

00:18:57,260 --> 00:19:03,950
black box in my opinion but um black box

00:19:01,549 --> 00:19:05,929
with knowledge of the internals after

00:19:03,950 --> 00:19:08,480
how the how the actual core testing so

00:19:05,929 --> 00:19:11,480
it falls into that category laughs right

00:19:08,480 --> 00:19:13,910
so anyway just a clarification that yeah

00:19:11,480 --> 00:19:15,410
yeah it falls into that yeah so we do

00:19:13,910 --> 00:19:17,690
need to you're right we do need to

00:19:15,410 --> 00:19:20,090
figure out with the K unit in there we

00:19:17,690 --> 00:19:23,059
need to kind of figure out - to have a

00:19:20,090 --> 00:19:27,350
better story how do we how we can

00:19:23,059 --> 00:19:31,160
increase coverage using both yeah that's

00:19:27,350 --> 00:19:32,929
a good point and so that that's like why

00:19:31,160 --> 00:19:35,179
part of why I actually didn't include

00:19:32,929 --> 00:19:36,950
that in my definitions of what a unit

00:19:35,179 --> 00:19:38,690
tests and integration test an end-to-end

00:19:36,950 --> 00:19:41,059
test was because I didn't want to get

00:19:38,690 --> 00:19:44,390
hung up on like the white box black box

00:19:41,059 --> 00:19:46,730
part but I think that's true so I think

00:19:44,390 --> 00:19:48,890
there's definitely there's definitely

00:19:46,730 --> 00:19:50,840
cases where you will you will find

00:19:48,890 --> 00:19:53,690
appropriate integration testing coverage

00:19:50,840 --> 00:19:56,570
provided by either Kay self test or k

00:19:53,690 --> 00:20:00,320
unit I mean for example can unit can run

00:19:56,570 --> 00:20:02,240
on it should be able to run on all

00:20:00,320 --> 00:20:05,150
architectures I've tested it on arm and

00:20:02,240 --> 00:20:07,040
x86 and of course UML so it should run

00:20:05,150 --> 00:20:09,020
on all architectures which means you

00:20:07,040 --> 00:20:10,880
should be able to use it for hardware

00:20:09,020 --> 00:20:12,860
integration testing nevertheless

00:20:10,880 --> 00:20:15,440
candidate is not currently capable of

00:20:12,860 --> 00:20:18,290
doing user space integration testing and

00:20:15,440 --> 00:20:20,059
so like yeah like there's there's

00:20:18,290 --> 00:20:21,860
elements of integration testing in both

00:20:20,059 --> 00:20:23,419
of them and I think that's partly just

00:20:21,860 --> 00:20:26,480
due to the nature of integration tests

00:20:23,419 --> 00:20:28,190
are kind of in between things but I

00:20:26,480 --> 00:20:31,790
don't think there is a well-defined

00:20:28,190 --> 00:20:33,380
story for what or if you want to be

00:20:31,790 --> 00:20:35,419
doing that kind of testing like what

00:20:33,380 --> 00:20:36,590
what the procedure should be so I think

00:20:35,419 --> 00:20:41,570
that's probably something that needs

00:20:36,590 --> 00:20:46,340
more thought we're we're planning to do

00:20:41,570 --> 00:20:49,100
on the future so a new improved

00:20:46,340 --> 00:20:51,980
documentation I think what I have there

00:20:49,100 --> 00:20:53,780
is pretty good but it's also clear to me

00:20:51,980 --> 00:20:56,270
based on some people who have used I've

00:20:53,780 --> 00:21:02,210
talked to them I need more documentation

00:20:56,270 --> 00:21:03,890
so I also have in the in the original I

00:21:02,210 --> 00:21:06,980
think it was the first version of the

00:21:03,890 --> 00:21:08,840
RFC I had some mocking and faking stuff

00:21:06,980 --> 00:21:10,520
so that way you could like fake out

00:21:08,840 --> 00:21:14,810
hardware or mock arbitrary like

00:21:10,520 --> 00:21:16,430
functions or like driver classes I'm

00:21:14,810 --> 00:21:18,680
planning on getting those out at some

00:21:16,430 --> 00:21:21,050
point I've not really decided how to

00:21:18,680 --> 00:21:23,300
prioritize that that's partly why I'm

00:21:21,050 --> 00:21:24,590
talking to you now as I'm hoping I want

00:21:23,300 --> 00:21:26,300
to I want to see what people are

00:21:24,590 --> 00:21:31,610
interested in how I should prioritize

00:21:26,300 --> 00:21:34,060
things I also it's pretty clear that I

00:21:31,610 --> 00:21:39,830
need to work on the test result parsing

00:21:34,060 --> 00:21:41,060
there are still some certain cases of D

00:21:39,830 --> 00:21:42,860
message logs from the kernel that it

00:21:41,060 --> 00:21:44,240
doesn't parse it's pretty

00:21:42,860 --> 00:21:48,440
straightforward to fix but the main

00:21:44,240 --> 00:21:50,750
thing is right now the the scripts I

00:21:48,440 --> 00:21:56,060
provided assume that you're building and

00:21:50,750 --> 00:21:57,710
running the colonel with UML it would it

00:21:56,060 --> 00:21:59,840
should I know a lot of people out there

00:21:57,710 --> 00:22:02,330
want to build and run all their tests on

00:21:59,840 --> 00:22:04,700
QEMU and some people have to use them on

00:22:02,330 --> 00:22:06,230
hardware for various reasons so I would

00:22:04,700 --> 00:22:07,670
like to split out the parser so that way

00:22:06,230 --> 00:22:10,010
you could take your own D message log

00:22:07,670 --> 00:22:13,930
from wherever you get it and parse that

00:22:10,010 --> 00:22:13,930
and get like nice test results for it

00:22:14,680 --> 00:22:24,830
see I also we need to figure out C ICD

00:22:19,250 --> 00:22:28,040
for Cana yeah I think that's mostly

00:22:24,830 --> 00:22:30,260
self-explanatory things I'm planning on

00:22:28,040 --> 00:22:32,590
focusing in the near term if nobody

00:22:30,260 --> 00:22:39,410
gives me any additional input yes Tim

00:22:32,590 --> 00:22:42,890
yeah is there any plan I thought the

00:22:39,410 --> 00:22:46,780
first versions of this emitted ktab yes

00:22:42,890 --> 00:22:53,780
so it didn't look like a tap what oh

00:22:46,780 --> 00:23:00,260
right yeah so okay I'll move my terminal

00:22:53,780 --> 00:23:02,740
over and okay this is the wrong

00:23:00,260 --> 00:23:02,740
directory

00:23:02,880 --> 00:23:11,570
oh yeah

00:23:14,590 --> 00:23:17,429
good

00:23:22,970 --> 00:23:27,340
okay so if we just around the kernel by

00:23:24,980 --> 00:23:27,340
itself

00:23:38,810 --> 00:23:45,530
yeah this is what it actually prints out

00:23:41,570 --> 00:23:47,960
into the D message log yeah so yeah it

00:23:45,530 --> 00:23:50,440
does support tap so there are some minor

00:23:47,960 --> 00:23:52,790
things that aren't really tap conformant

00:23:50,440 --> 00:23:55,780
well you can't see it here because if

00:23:52,790 --> 00:23:59,510
all the tests pass it actually is

00:23:55,780 --> 00:24:02,030
expectations our multi-line and it

00:23:59,510 --> 00:24:06,470
doesn't so if you see like the directive

00:24:02,030 --> 00:24:08,390
thing any anything that is a like

00:24:06,470 --> 00:24:12,710
message coming from the test is supposed

00:24:08,390 --> 00:24:15,950
to be prefixed with that with the pound

00:24:12,710 --> 00:24:21,680
sign the subsequent lines of the

00:24:15,950 --> 00:24:24,080
expectation don't have that technically

00:24:21,680 --> 00:24:28,820
looking at the tap standard if I wanted

00:24:24,080 --> 00:24:32,150
to put the according to the tap

00:24:28,820 --> 00:24:34,220
specification the expectation results

00:24:32,150 --> 00:24:39,260
should actually be added as a JSON

00:24:34,220 --> 00:24:40,700
payload I'm yeah well my yeah my opinion

00:24:39,260 --> 00:24:43,100
is shifted on that I think we had to

00:24:40,700 --> 00:24:44,930
ignore the tap specification and okay I

00:24:43,100 --> 00:24:47,450
even I don't know if you notice but I

00:24:44,930 --> 00:24:50,120
called it K tap because I think we

00:24:47,450 --> 00:24:52,820
should just come up with a output format

00:24:50,120 --> 00:24:55,190
that works for us and and do whatever is

00:24:52,820 --> 00:24:56,750
handy for our own CI systems okay well

00:24:55,190 --> 00:24:58,400
well then we need to decide how to

00:24:56,750 --> 00:24:59,750
represent something like right right but

00:24:58,400 --> 00:25:01,490
we need to have those discussions

00:24:59,750 --> 00:25:03,410
yeah because otherwise I need to add a

00:25:01,490 --> 00:25:13,340
JSON serialize for the Linux girl yeah

00:25:03,410 --> 00:25:15,380
yeah so Tim buddy saying we wanted to

00:25:13,340 --> 00:25:30,320
rip out all the tap stuff that you made

00:25:15,380 --> 00:25:33,290
me add to KL dust okay yeah yeah so it

00:25:30,320 --> 00:25:35,660
sorry yeah yeah I have a couple of

00:25:33,290 --> 00:25:39,710
feature requests actually so we might

00:25:35,660 --> 00:25:44,030
make use of K unit for dynamic tools

00:25:39,710 --> 00:25:46,910
like kam San for that we probably need

00:25:44,030 --> 00:25:49,670
to somehow capture the damask output

00:25:46,910 --> 00:25:51,020
because the tools are printing error

00:25:49,670 --> 00:25:56,210
reports and we

00:25:51,020 --> 00:25:58,929
once for example to check that the they

00:25:56,210 --> 00:26:02,210
are printing good to good reports it's

00:25:58,929 --> 00:26:05,690
everything is contended that we detect

00:26:02,210 --> 00:26:08,360
the errors etc so this would be handy

00:26:05,690 --> 00:26:10,700
and the other thing

00:26:08,360 --> 00:26:15,260
duska unit support anything like death

00:26:10,700 --> 00:26:17,929
tests in G test so that that's that's a

00:26:15,260 --> 00:26:21,740
feature I have on the way it's not fully

00:26:17,929 --> 00:26:26,870
implemented but it's able to handle seg

00:26:21,740 --> 00:26:28,880
faults but I would I it looks like it

00:26:26,870 --> 00:26:30,890
should be extensible under UML to also

00:26:28,880 --> 00:26:34,460
handle panics which is probably the more

00:26:30,890 --> 00:26:36,290
interesting use case trying to do that

00:26:34,460 --> 00:26:42,679
on arbitrary architectures would be

00:26:36,290 --> 00:26:44,480
harder but anyway so so yes sort of it's

00:26:42,679 --> 00:26:45,410
it's not it's not currently in there but

00:26:44,480 --> 00:26:49,370
it's something I'm going to be working

00:26:45,410 --> 00:26:51,050
on I see okay and sometimes our tests

00:26:49,370 --> 00:26:55,250
then to corrupt the memory for example

00:26:51,050 --> 00:26:58,670
which is why we're testing it but it

00:26:55,250 --> 00:27:04,730
could be nice to somehow fall back to

00:26:58,670 --> 00:27:06,470
the to the good state yeah so this is

00:27:04,730 --> 00:27:11,210
kind of gets back into what I was saying

00:27:06,470 --> 00:27:12,950
about like K builds and K config it

00:27:11,210 --> 00:27:14,390
would be nice to just include the things

00:27:12,950 --> 00:27:16,070
that you need which I don't know maybe

00:27:14,390 --> 00:27:20,090
from your perspective it that may not be

00:27:16,070 --> 00:27:23,960
true but if you can run if you depend on

00:27:20,090 --> 00:27:25,790
left code less non test code then that

00:27:23,960 --> 00:27:28,040
means it's a more hermetic test because

00:27:25,790 --> 00:27:29,270
there's fewer things that can go wrong I

00:27:28,040 --> 00:27:33,020
mean you could I guess you could argue

00:27:29,270 --> 00:27:34,190
that with those other things that if

00:27:33,020 --> 00:27:37,280
they're not actually being used in the

00:27:34,190 --> 00:27:40,010
test and they don't matter but in any

00:27:37,280 --> 00:27:42,650
case for the short term I'm planning on

00:27:40,010 --> 00:27:46,630
adding a feature to the script that that

00:27:42,650 --> 00:27:49,340
test running script that allows you to

00:27:46,630 --> 00:27:53,720
boot the same kernel containing multiple

00:27:49,340 --> 00:27:55,580
tests multiple times and each time run a

00:27:53,720 --> 00:27:58,190
different selection of tests which

00:27:55,580 --> 00:28:01,280
should create a higher degree from

00:27:58,190 --> 00:28:02,870
hermiticity so at least one failing test

00:28:01,280 --> 00:28:04,540
suite should not affect another failing

00:28:02,870 --> 00:28:06,880
test suite

00:28:04,540 --> 00:28:08,200
does that does that sound kind of what

00:28:06,880 --> 00:28:11,440
you want yeah probably

00:28:08,200 --> 00:28:21,250
okay cool thanks yeah

00:28:11,440 --> 00:28:23,530
anyone else yes so many of these

00:28:21,250 --> 00:28:25,420
features and issues are already solved

00:28:23,530 --> 00:28:28,660
another unit test frameworks so why not

00:28:25,420 --> 00:28:31,240
work on it tap ting an existing SI unit

00:28:28,660 --> 00:28:33,520
test framework instead of okay unit yeah

00:28:31,240 --> 00:28:34,810
I thought about that that was we all

00:28:33,520 --> 00:28:37,570
think the problems were solving are

00:28:34,810 --> 00:28:40,540
unique but they rarely are yeah no the

00:28:37,570 --> 00:28:43,210
problems really aren't that unique so

00:28:40,540 --> 00:28:45,340
the main reason is so I looked at

00:28:43,210 --> 00:28:46,870
something like I looked at some of the

00:28:45,340 --> 00:28:50,080
other the testing frameworks that are

00:28:46,870 --> 00:28:52,060
out there and the rather large and are

00:28:50,080 --> 00:28:53,260
rather unconcerned with the kinds of

00:28:52,060 --> 00:28:55,120
things that the Linux kernel is doing

00:28:53,260 --> 00:28:58,930
now from the standpoint of just testing

00:28:55,120 --> 00:29:02,620
arbitrary code but like kernel standards

00:28:58,930 --> 00:29:04,470
and such I felt that if so one of the

00:29:02,620 --> 00:29:07,360
things I thought was really important is

00:29:04,470 --> 00:29:09,070
making all the test should be written in

00:29:07,360 --> 00:29:11,170
kernel seeing that compiles against the

00:29:09,070 --> 00:29:14,230
kernel and the test should be in a

00:29:11,170 --> 00:29:15,580
visible location like I I think that

00:29:14,230 --> 00:29:18,640
this house should live alongside of the

00:29:15,580 --> 00:29:20,800
code that they do test and I imagine it

00:29:18,640 --> 00:29:24,340
would I figured it would be a lot more

00:29:20,800 --> 00:29:26,530
difficult to try to just convince people

00:29:24,340 --> 00:29:28,300
to start following like conventions from

00:29:26,530 --> 00:29:29,830
another testing framework rather than

00:29:28,300 --> 00:29:34,090
have something that the Linux kernel

00:29:29,830 --> 00:29:37,240
community can have um put on for example

00:29:34,090 --> 00:29:38,980
a lot of other unit testing frameworks

00:29:37,240 --> 00:29:42,340
assume that they have their own like

00:29:38,980 --> 00:29:43,630
they get to define like expect EQ and

00:29:42,340 --> 00:29:45,130
things like that and they you know they

00:29:43,630 --> 00:29:46,510
assume that like everyone's just going

00:29:45,130 --> 00:29:49,510
to respect the fact that they get to run

00:29:46,510 --> 00:29:50,890
in the global namespace and that was

00:29:49,510 --> 00:29:53,200
pretty much the first thing that

00:29:50,890 --> 00:29:56,140
everyone's like no everything needs to

00:29:53,200 --> 00:29:57,340
be like properly namespace so it it just

00:29:56,140 --> 00:30:01,840
seemed as though it would be a lot

00:29:57,340 --> 00:30:04,600
easier to engineer around the problem of

00:30:01,840 --> 00:30:06,460
getting people to buy into changing

00:30:04,600 --> 00:30:08,920
conventions and stuff does that answer

00:30:06,460 --> 00:30:09,820
your question yeah I think so just seems

00:30:08,920 --> 00:30:12,220
like there should be some kind of

00:30:09,820 --> 00:30:13,600
partnership or reuse with someone who

00:30:12,220 --> 00:30:15,190
solved some of these problems already

00:30:13,600 --> 00:30:16,130
even if it's not just adapt their whole

00:30:15,190 --> 00:30:23,720
framework

00:30:16,130 --> 00:30:26,970
yeah yeah that seemed a lot harder so

00:30:23,720 --> 00:30:34,370
but I mean if you want to do it I won't

00:30:26,970 --> 00:30:34,370
be accepting pull requests yeah yeah so

00:30:35,660 --> 00:30:40,920
yeah so in the near term things I'm

00:30:39,090 --> 00:30:42,650
planning I'm working on hopefully

00:30:40,920 --> 00:30:45,050
getting more people to write tests

00:30:42,650 --> 00:30:47,280
improving documentation as I mentioned

00:30:45,050 --> 00:30:49,800
making the things that are already there

00:30:47,280 --> 00:30:51,690
easier to use a couple of people have

00:30:49,800 --> 00:30:56,270
pointed out things about like the potage

00:30:51,690 --> 00:30:58,380
script that I have that are not perfect

00:30:56,270 --> 00:31:01,230
adding tests getting people to write

00:30:58,380 --> 00:31:04,020
more tests and I'm thinking for in terms

00:31:01,230 --> 00:31:06,090
of large features too maybe big areas

00:31:04,020 --> 00:31:09,450
are working on this mattress API which

00:31:06,090 --> 00:31:11,130
is basically something that's there like

00:31:09,450 --> 00:31:14,030
these composable matchers they has

00:31:11,130 --> 00:31:17,580
anyone used what is it called

00:31:14,030 --> 00:31:19,830
expect that it's it's I think it's now

00:31:17,580 --> 00:31:20,490
in J unit but it was originally part of

00:31:19,830 --> 00:31:22,740
something else

00:31:20,490 --> 00:31:23,790
does anyone familiar with that okay

00:31:22,740 --> 00:31:25,290
whatever

00:31:23,790 --> 00:31:27,300
the the main thing was originally

00:31:25,290 --> 00:31:31,080
written for was per parameter matching

00:31:27,300 --> 00:31:32,520
for if you have like a mock stub and you

00:31:31,080 --> 00:31:34,140
would like to set an expectation of how

00:31:32,520 --> 00:31:36,750
the mock stub is used you can use these

00:31:34,140 --> 00:31:39,150
like matchers in place of parameters to

00:31:36,750 --> 00:31:42,540
make assertions about how the parameters

00:31:39,150 --> 00:31:44,040
are passed into this function after

00:31:42,540 --> 00:31:46,410
looking at a test that was written

00:31:44,040 --> 00:31:48,060
recently it seems as though it might

00:31:46,410 --> 00:31:49,860
make sense to have it as a standalone

00:31:48,060 --> 00:31:53,130
thing and not be strictly used just for

00:31:49,860 --> 00:31:58,710
parameter matching so maybe that may be

00:31:53,130 --> 00:32:00,510
just mocking but I really I mean it's

00:31:58,710 --> 00:32:06,030
it's what people think is most

00:32:00,510 --> 00:32:08,490
interesting yeah I still have a thing a

00:32:06,030 --> 00:32:11,580
decent amount of time another wait at 15

00:32:08,490 --> 00:32:13,680
minutes okay so I had some input on the

00:32:11,580 --> 00:32:15,960
cabled independencia thingy yeah at

00:32:13,680 --> 00:32:18,000
least in the DRM subsystem we are moving

00:32:15,960 --> 00:32:19,740
more and more to helper libraries okay

00:32:18,000 --> 00:32:21,690
and these helper libraries we we

00:32:19,740 --> 00:32:23,340
expressed them with a hidden key context

00:32:21,690 --> 00:32:25,140
option basically and everything which

00:32:23,340 --> 00:32:28,620
needs that Kay coughing option selects

00:32:25,140 --> 00:32:29,700
it instead of depends on yeah and I

00:32:28,620 --> 00:32:31,470
think that if you were to

00:32:29,700 --> 00:32:33,450
for more stuff which you want to units

00:32:31,470 --> 00:32:35,580
test so if all the base things were sort

00:32:33,450 --> 00:32:37,320
of becoming libraries at a config level

00:32:35,580 --> 00:32:39,720
which you would select when you need it

00:32:37,320 --> 00:32:41,700
yeah then you you are more expressing

00:32:39,720 --> 00:32:43,409
what you want basically I mean in

00:32:41,700 --> 00:32:45,149
general this solves a lot of things like

00:32:43,409 --> 00:32:47,220
dependency cycles and stuff so this

00:32:45,149 --> 00:32:49,049
would be something work which would be

00:32:47,220 --> 00:32:51,659
more not only beneficial for a unit

00:32:49,049 --> 00:32:53,299
testing but also ok that that sounds

00:32:51,659 --> 00:32:55,409
interesting

00:32:53,299 --> 00:32:59,580
yeah what's your name

00:32:55,409 --> 00:33:01,409
home student house well yes could we

00:32:59,580 --> 00:33:10,019
maybe talk afterwards that sounds

00:33:01,409 --> 00:33:11,880
interesting I mean yeah sure yeah that

00:33:10,019 --> 00:33:15,000
flows in I was going to point out that

00:33:11,880 --> 00:33:17,279
config option dependencies that on your

00:33:15,000 --> 00:33:21,120
next slide next steps if you can go to

00:33:17,279 --> 00:33:25,940
the next next one yeah on that I would

00:33:21,120 --> 00:33:29,700
add reporting and then config report

00:33:25,940 --> 00:33:33,960
report reporting test results like like

00:33:29,700 --> 00:33:37,139
CI CD right yeah and then also also the

00:33:33,960 --> 00:33:39,269
config dependencies and then so that's

00:33:37,139 --> 00:33:40,980
probably where we'll be spending a lot

00:33:39,269 --> 00:33:43,830
of time based on my experience with Doc

00:33:40,980 --> 00:33:46,649
a self test getting it to be usable in

00:33:43,830 --> 00:33:48,330
CI environment I don't know that if this

00:33:46,649 --> 00:33:52,169
will be used but something to keep

00:33:48,330 --> 00:33:57,179
thinking about we might need a a unified

00:33:52,169 --> 00:33:59,010
approach distros want to run some some

00:33:57,179 --> 00:34:02,429
of the tests they're asking coming and

00:33:59,010 --> 00:34:04,649
saying which tests should be run in for

00:34:02,429 --> 00:34:07,740
district coalification so we might have

00:34:04,649 --> 00:34:10,550
to approach this as a unified thing to

00:34:07,740 --> 00:34:13,020
to come up with a you know so we're not

00:34:10,550 --> 00:34:16,139
they we don't have like multiple

00:34:13,020 --> 00:34:20,790
different ways for which each so

00:34:16,139 --> 00:34:22,710
something that yeah I I think that okay

00:34:20,790 --> 00:34:25,129
they like doing something along the

00:34:22,710 --> 00:34:29,089
lines of case self-test fragments it's

00:34:25,129 --> 00:34:29,089
unfortunately it seems like some of the

00:34:29,659 --> 00:34:38,639
yeah yeah sure sure yeah okay okay sure

00:34:35,159 --> 00:34:40,950
yep yeah this might be related do you

00:34:38,639 --> 00:34:42,480
have a way like say I want to write a

00:34:40,950 --> 00:34:44,490
test I don't

00:34:42,480 --> 00:34:48,899
test it with beginning and little Indian

00:34:44,490 --> 00:34:52,350
or young I assume at the moment you just

00:34:48,899 --> 00:34:54,240
build one config so you can you're free

00:34:52,350 --> 00:34:56,550
to build the test with different configs

00:34:54,240 --> 00:34:57,900
that's sort of external yeah that's

00:34:56,550 --> 00:34:59,609
external that's something you have to do

00:34:57,900 --> 00:35:01,740
it would be cool if you could sort of

00:34:59,609 --> 00:35:04,260
have that next to the test like yeah

00:35:01,740 --> 00:35:06,780
yeah there's some other things like that

00:35:04,260 --> 00:35:08,040
like super hot yeah yeah there's some

00:35:06,780 --> 00:35:09,770
other things like that like it would

00:35:08,040 --> 00:35:15,840
also be really nice if you could specify

00:35:09,770 --> 00:35:17,670
a so so I for like I the original use

00:35:15,840 --> 00:35:19,109
case was for this was for driver testing

00:35:17,670 --> 00:35:24,420
because I used to primarily work on on

00:35:19,109 --> 00:35:26,940
drivers and it would be really nice to

00:35:24,420 --> 00:35:28,140
be able to specify like when you're when

00:35:26,940 --> 00:35:29,820
you're prepping a driver you want to

00:35:28,140 --> 00:35:32,580
probe a driver in a particular way if

00:35:29,820 --> 00:35:34,020
you could just specify a set like you

00:35:32,580 --> 00:35:35,790
know write the basically a device tree

00:35:34,020 --> 00:35:37,260
fragment and say I would like to probe

00:35:35,790 --> 00:35:38,880
with this device tree fragment it'd be

00:35:37,260 --> 00:35:41,210
nice if you could do that in a test I

00:35:38,880 --> 00:35:45,420
think that's a similar kind of thing

00:35:41,210 --> 00:35:48,480
yeah I mean it's kind of test Davos yeah

00:35:45,420 --> 00:35:49,890
yeah so but because of the way it's done

00:35:48,480 --> 00:35:52,410
it you have to actually do it at Build

00:35:49,890 --> 00:35:54,359
time like Rayo the config stuff yeah

00:35:52,410 --> 00:35:56,609
which is difficult because you need to

00:35:54,359 --> 00:35:58,470
know about the test which happens after

00:35:56,609 --> 00:36:00,390
config time and then use that to

00:35:58,470 --> 00:36:03,000
configure things so yeah that's yeah

00:36:00,390 --> 00:36:04,500
that's you it's even harder yeah I mean

00:36:03,000 --> 00:36:07,440
you could you could sort of have the

00:36:04,500 --> 00:36:10,170
configs the test cares about somehow and

00:36:07,440 --> 00:36:12,810
suck them out and build multiple kernels

00:36:10,170 --> 00:36:15,600
with those toggled mmm and come up with

00:36:12,810 --> 00:36:21,630
a like doo-doo-doo like multiple passes

00:36:15,600 --> 00:36:27,510
on the bill yeah yeah yeah extension

00:36:21,630 --> 00:36:30,930
program yeah I was gonna add that one of

00:36:27,510 --> 00:36:34,650
the things that we did with XFS tests

00:36:30,930 --> 00:36:36,900
was we would actually after we were done

00:36:34,650 --> 00:36:38,070
running the test suite create a test

00:36:36,900 --> 00:36:41,580
artifact

00:36:38,070 --> 00:36:44,369
tar.gz that would have the k config all

00:36:41,580 --> 00:36:47,609
of the test artifacts you know including

00:36:44,369 --> 00:36:49,830
d message output so that after you could

00:36:47,609 --> 00:36:52,109
review the pass/fail thing which might

00:36:49,830 --> 00:36:54,869
be running you know somewhere far away

00:36:52,109 --> 00:36:55,960
from your development system you could

00:36:54,869 --> 00:36:58,390
fetch that

00:36:55,960 --> 00:37:02,980
artifact and do the in-depth debugging

00:36:58,390 --> 00:37:06,490
and I suspect that having something like

00:37:02,980 --> 00:37:08,890
that which was standardized across all

00:37:06,490 --> 00:37:11,980
the various test infrastructures yeah

00:37:08,890 --> 00:37:13,570
might be kind of handy and that sort of

00:37:11,980 --> 00:37:15,640
related to that is one of my dreams

00:37:13,570 --> 00:37:18,580
which is at the moment we kind of

00:37:15,640 --> 00:37:21,750
assumed the CICU the CI tool actually

00:37:18,580 --> 00:37:25,000
handles collecting all the test results

00:37:21,750 --> 00:37:26,619
and listing them all and the problem

00:37:25,000 --> 00:37:30,099
with that is that assumes that all the

00:37:26,619 --> 00:37:33,700
tests are running inside the one true CI

00:37:30,099 --> 00:37:35,650
system and if you have lots of people

00:37:33,700 --> 00:37:37,990
running your test Suites in their own

00:37:35,650 --> 00:37:41,950
system some sort of way of collecting

00:37:37,990 --> 00:37:44,530
that all and maybe even from desperate

00:37:41,950 --> 00:37:48,099
test systems and then being able to

00:37:44,530 --> 00:37:50,589
collect it in some standard format might

00:37:48,099 --> 00:37:53,320
be really useful right I mean I actually

00:37:50,589 --> 00:37:55,510
have my stuff going out in j-unit XML

00:37:53,320 --> 00:37:58,060
format so in theory that could get

00:37:55,510 --> 00:37:59,680
consumed by some central system with a

00:37:58,060 --> 00:38:02,920
back pointer to where you could actually

00:37:59,680 --> 00:38:05,980
download the test artifact if you

00:38:02,920 --> 00:38:07,750
actually cared and you know I think

00:38:05,980 --> 00:38:09,640
that's maybe one of those interesting

00:38:07,750 --> 00:38:12,160
things that's not a que unit specific

00:38:09,640 --> 00:38:15,040
thing but just how do we integrate all

00:38:12,160 --> 00:38:17,920
of our various testing systems in some

00:38:15,040 --> 00:38:20,890
bigger you know way of detecting flakes

00:38:17,920 --> 00:38:23,950
and test failures and whatnot yeah I

00:38:20,890 --> 00:38:26,470
think Tim Mosley comments so I I think

00:38:23,950 --> 00:38:31,750
we actually talked about this the other

00:38:26,470 --> 00:38:34,000
night were you at the CI BA it was like

00:38:31,750 --> 00:38:35,830
we talked about kernel CI in KCI so I

00:38:34,000 --> 00:38:39,460
think I think we talked about this there

00:38:35,830 --> 00:38:41,500
and I think we all agree that that that

00:38:39,460 --> 00:38:43,900
would be a nice thing to do but I think

00:38:41,500 --> 00:38:48,700
the the TLDR is that's also really hard

00:38:43,900 --> 00:38:50,080
yeah where work has begun work has begun

00:38:48,700 --> 00:38:52,270
on that in fact I have a presentation

00:38:50,080 --> 00:38:55,930
I'm giving it the CK a 1/2 X tomorrow

00:38:52,270 --> 00:38:59,050
about consolidation of test definitions

00:38:55,930 --> 00:39:02,770
and I have a couple of slides because

00:38:59,050 --> 00:39:05,609
I'm that's I have things ahead of it but

00:39:02,770 --> 00:39:06,760
a couple of slides on results formats

00:39:05,609 --> 00:39:11,230
Stan

00:39:06,760 --> 00:39:14,320
and and in other presentations I've

00:39:11,230 --> 00:39:17,140
given at other events also the notion of

00:39:14,320 --> 00:39:18,850
packaging results and we had a

00:39:17,140 --> 00:39:20,800
discussion yesterday in the bath about a

00:39:18,850 --> 00:39:23,320
centralized location for storing

00:39:20,800 --> 00:39:26,020
artifacts so stuff is happening but it's

00:39:23,320 --> 00:39:29,310
happening relatively slowly but

00:39:26,020 --> 00:39:29,310
hopefully we'll make some progress

00:39:30,570 --> 00:39:35,380
frankly I've moved on to my tester now

00:39:33,640 --> 00:39:39,609
end-to-end tests now that I see your

00:39:35,380 --> 00:39:43,020
definitions more to the point we talked

00:39:39,609 --> 00:39:45,520
many months ago about dependency on the

00:39:43,020 --> 00:39:48,700
scripts that you have to run the test

00:39:45,520 --> 00:39:53,350
and when I run on real hardware supposed

00:39:48,700 --> 00:39:56,020
to UML my real hardware is scripted in

00:39:53,350 --> 00:39:57,880
my systems each different piece of

00:39:56,020 --> 00:40:01,150
hardware has different boot methods

00:39:57,880 --> 00:40:05,260
loading kernels etc so it's important to

00:40:01,150 --> 00:40:09,070
keep the booting a system running the

00:40:05,260 --> 00:40:11,650
tests separate from or pull able to pull

00:40:09,070 --> 00:40:14,619
it out from your your generic script so

00:40:11,650 --> 00:40:16,390
your script includes creating the system

00:40:14,619 --> 00:40:17,980
booting the system getting the result

00:40:16,390 --> 00:40:20,320
analyzing yourself it'd be real nice if

00:40:17,980 --> 00:40:23,080
the analyzing the result is also

00:40:20,320 --> 00:40:25,060
available in a stand alone form yep so

00:40:23,080 --> 00:40:27,359
when I in my infrastructure I'll have a

00:40:25,060 --> 00:40:31,240
log which I can run through that same

00:40:27,359 --> 00:40:33,940
nice formatting out system yeah that's

00:40:31,240 --> 00:40:37,030
that's one of my to dues yarn also

00:40:33,940 --> 00:40:39,820
wanted something similar because yeah

00:40:37,030 --> 00:40:42,609
it's this is this doesn't really work if

00:40:39,820 --> 00:40:45,490
you need to run in QEMU or unreal

00:40:42,609 --> 00:40:47,859
hardware so it's it's definitely nice to

00:40:45,490 --> 00:40:52,180
do that's what I meant by splitting out

00:40:47,859 --> 00:40:58,810
the parser thing yeah something anything

00:40:52,180 --> 00:41:02,320
else other questions yes my pitch again

00:40:58,810 --> 00:41:04,660
on industry standards but if the comment

00:41:02,320 --> 00:41:06,430
about some of the common results and

00:41:04,660 --> 00:41:09,250
like the j-unit xml is kind of

00:41:06,430 --> 00:41:11,410
interesting because if if you know the

00:41:09,250 --> 00:41:13,869
parser is an option to spew it out in

00:41:11,410 --> 00:41:15,670
some format that other frameworks are

00:41:13,869 --> 00:41:16,900
commonly using in totally different

00:41:15,670 --> 00:41:17,560
communities and we could take advantage

00:41:16,900 --> 00:41:19,630
of

00:41:17,560 --> 00:41:21,850
our tools for generating analysis and

00:41:19,630 --> 00:41:24,040
whatever other types of things other

00:41:21,850 --> 00:41:25,780
people are doing - because it seems like

00:41:24,040 --> 00:41:28,420
the people in this community should be

00:41:25,780 --> 00:41:30,580
focused on solving the problems here not

00:41:28,420 --> 00:41:33,940
repeating the prompts that everyone else

00:41:30,580 --> 00:41:41,470
has ever solved yeah that's probably

00:41:33,940 --> 00:41:42,820
true okay any last questions we're just

00:41:41,470 --> 00:41:45,630
about out of time but we I think we have

00:41:42,820 --> 00:41:45,630
time for one last question

00:41:47,760 --> 00:41:55,849
right okay let's thank

00:41:50,910 --> 00:41:55,849

YouTube URL: https://www.youtube.com/watch?v=507n-t0sfcU


