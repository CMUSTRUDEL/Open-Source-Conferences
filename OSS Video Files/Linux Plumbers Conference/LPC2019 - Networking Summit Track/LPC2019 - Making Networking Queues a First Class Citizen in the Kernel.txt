Title: LPC2019 - Making Networking Queues a First Class Citizen in the Kernel
Publication date: 2019-11-18
Playlist: LPC2019 - Networking Summit Track
Description: 
	Making Networking Queues a First Class Citizen in the Kernel

Speakers
 Magnus Karlsson (Intel)
 Björn Töpel (Intel)
 Jesper Dangaard Brouer (RedHat)
 Toke Höiland-Jörgensen (RedHat)
 Jakub Kicinski (Netronome)
 Maxim Mikityanskiy (Mellanox)

Description
XDP (the eXpress Data Path) is a new method in Linux to process
packets at L2 and L3 with really high performance. XDP has already
been deployed for use cases involving ingress packet filtering, or
transmission back through the ingress interface, are already well
supported today. However, as we expand the use cases that involve the
XDP_REDIRECT action, e.g., to send packets to other devices, or
zero-copy them to userspace sockets, it becomes challenging to retain
the high performance of the simpler operating modes.

One of the keys to get good performance for these advanced use cases,
is effective use of dedicated hardware queues (on both Rx and Tx), as
this makes it possible to split traffic over multiple CPUs, with no
synchronization overhead in the fast path. The problem with using
hardware queues like this is that they are a constrained resource, but
are hidden from the rest of the kernel: Currently, each driver
allocates queues according to its own whims, and users have little or
no control over how the queues are used or configured.

In this presentation we discuss an abstraction that makes it possible
to keep track of queues in a vendor-neutral way: We implement a new
submodule in the Linux networking core that drivers can register their
queues to. Other pieces of code can then allocate and free individual
queues (or sets of them) satisfying certain properties (e.g., "a Tx/Rx
pair", or "one queue per core"). This submodule also makes sure that
the queues get IDs that are hardware independent, so that they can
easily be used by other components. We show how this could be exposed
to userspace, and how it can interact with the existing REDIRECT
primitives, such as device maps.

Finally if there is time, we would like to discuss a related problem:
often a userspace program wants to express its configuration not in
terms of queue IDs, but in terms of a set of packets it wants to
process (e.g., by specifying an IP address). So how do we change user
space APIs that use queue IDs to be able to use something more
meaningful such as properties of the packet flow that a user wants? To
solve this second problem, we propose to introduce a new bind option
in AF_XDP that takes a simple description of the traffic that is
desired (e.g. "VLAN ID 2", "IP address fc00:dead:cafe::1", or "all
traffic on a netdev"). This hides queue IDs from userspace, but will
use the new queue logic internally to allocate and configure an
appropriate queue.
Captions: 
	00:00:00,600 --> 00:00:02,313
- Okay, without further ado,

00:00:03,290 --> 00:00:08,290
one clearly substandard area, if you will,

00:00:09,190 --> 00:00:11,340
of the Linux networking architecture,

00:00:11,340 --> 00:00:14,270
is that we really don't handle queues in a nice way.

00:00:14,270 --> 00:00:15,880
It's been, basically,

00:00:15,880 --> 00:00:17,950
people have been implementing things as needed

00:00:17,950 --> 00:00:20,010
inside the drivers with minimal,

00:00:20,010 --> 00:00:24,363
true abstractions in the core kernel for this purpose.

00:00:25,360 --> 00:00:28,180
So, Magnus and company are gonna try to help

00:00:28,180 --> 00:00:30,810
spur an effort to fix this problem,

00:00:30,810 --> 00:00:33,390
and I'm very much looking forward

00:00:33,390 --> 00:00:34,990
to seeing what they have to say.

00:00:37,060 --> 00:00:37,893
- Thank you, Dave.

00:00:37,893 --> 00:00:38,770
So, I'm Magnus Karlsson,

00:00:38,770 --> 00:00:41,020
I'm gonna talk about a new proposal here

00:00:41,020 --> 00:00:46,020
for exposing networking queues to user space in a new API.

00:00:46,740 --> 00:00:48,900
And if only Bjorn and I from Intel

00:00:48,900 --> 00:00:50,910
would have been presenting this,

00:00:50,910 --> 00:00:52,650
the probability of this getting accepted

00:00:52,650 --> 00:00:54,560
by other vendors and the community

00:00:54,560 --> 00:00:56,460
is probably very close to zero.

00:00:56,460 --> 00:00:58,080
So I'm really happy that there are actually

00:00:58,080 --> 00:01:00,930
three other networking vendors cooperating with this.

00:01:00,930 --> 00:01:04,020
So their representatives are Jacob from Metronome,

00:01:04,020 --> 00:01:06,130
and we have Max in there from Mellanox,

00:01:06,130 --> 00:01:08,550
and I don't know if Andy actually left the room, or,

00:01:08,550 --> 00:01:10,780
no, he's there, good, he's in the front row,

00:01:10,780 --> 00:01:13,390
so that's very, you know, that's good.

00:01:13,390 --> 00:01:15,860
And also, to round it off and to make our,

00:01:15,860 --> 00:01:19,090
to get us stop fighting and yes,

00:01:19,090 --> 00:01:20,220
sanity-checking our stuff,

00:01:20,220 --> 00:01:24,113
we also have two Danes here, in red hats, Toke and Jesper.

00:01:26,410 --> 00:01:29,147
Okay, so just, first, this is really work in progress.

00:01:29,147 --> 00:01:31,570
What we're gonna hear now is just a snapshot,

00:01:31,570 --> 00:01:33,730
a dump of where we are now,

00:01:33,730 --> 00:01:35,820
so you hear about the things we agree on,

00:01:35,820 --> 00:01:38,770
you also hear about things we do not agree on,

00:01:38,770 --> 00:01:40,690
and, you know, problems that we haven't solved.

00:01:40,690 --> 00:01:42,520
So it will be just a dump of where we are.

00:01:42,520 --> 00:01:45,400
It's definitely not finished in any way.

00:01:45,400 --> 00:01:49,010
And no, that guy is not shoveling garbage, so.

00:01:49,010 --> 00:01:50,360
Somebody asked that before.

00:01:52,423 --> 00:01:53,773
Okay, so you all know this.

00:01:55,309 --> 00:01:57,274
A NIC has a couple of ports.

00:01:57,274 --> 00:01:58,990
You have in an optical line or something that goes in there,

00:01:58,990 --> 00:02:02,820
and all your traffic goes in and out of those ports.

00:02:02,820 --> 00:02:07,510
And then afterwards, the driver, the software interface,

00:02:07,510 --> 00:02:10,200
and NIC provides usually queues.

00:02:10,200 --> 00:02:12,970
And these are receive queues for receiving traffic,

00:02:12,970 --> 00:02:15,710
and your transmit queues for transmitting traffic

00:02:15,710 --> 00:02:17,563
out to these ports.

00:02:18,720 --> 00:02:21,590
And there are one or more queues that are used,

00:02:21,590 --> 00:02:23,550
and who are the users of this in the kernel?

00:02:23,550 --> 00:02:27,590
Well, the foremost obvious user is the Linux stack itself,

00:02:27,590 --> 00:02:30,090
and if you look at most drivers, they seem to be

00:02:31,360 --> 00:02:35,290
allocating one Rx and one Tx queue power core

00:02:35,290 --> 00:02:37,510
that you have in your system for scalability reasons.

00:02:37,510 --> 00:02:38,930
This probably not true for all drivers,

00:02:38,930 --> 00:02:41,963
but if I look at the new ones, that seems to be the case.

00:02:42,890 --> 00:02:45,030
And this can be seen in user space.

00:02:45,030 --> 00:02:47,580
There says sysfs file system theme for this

00:02:47,580 --> 00:02:50,370
and also if two can manipulate them,

00:02:50,370 --> 00:02:53,140
but there are also a lot of you searching the kernel that

00:02:53,140 --> 00:02:55,640
you don't see from user space.

00:02:55,640 --> 00:03:00,640
For example, XDP Tx and XDP_REDIRECT uses extra queues,

00:03:01,720 --> 00:03:04,010
extra Tx queues in this case.

00:03:04,010 --> 00:03:05,760
You don't see that from user space.

00:03:06,740 --> 00:03:09,740
It's also that AF_XDP can use extract use,

00:03:09,740 --> 00:03:11,730
depending on the implementation.

00:03:11,730 --> 00:03:13,410
For example in the Intel implementation,

00:03:13,410 --> 00:03:16,900
we actually reuse the ones from XDP Tx and the ones,

00:03:16,900 --> 00:03:18,780
but Mellanox is another implementation,

00:03:18,780 --> 00:03:21,380
and it's just up to you whatever you want to do.

00:03:21,380 --> 00:03:22,783
So this can be hidden too,

00:03:23,620 --> 00:03:27,630
and queue disk with Hardware floats might be new ones

00:03:27,630 --> 00:03:29,580
and there's probably a number of other uses

00:03:29,580 --> 00:03:31,850
that I don't know of and have forgotten here

00:03:31,850 --> 00:03:34,760
that might use queues, networking queues,

00:03:34,760 --> 00:03:38,510
and do not expose this to users base in any way.

00:03:38,510 --> 00:03:41,290
So having hidden queues is perfectly fine.

00:03:41,290 --> 00:03:44,950
Its operating system is about abstracting hardware things.

00:03:44,950 --> 00:03:48,750
Unfortunately, there are user space tools and APIs

00:03:48,750 --> 00:03:50,970
that want to use queues

00:03:50,970 --> 00:03:53,090
and that's where the problem comes in.

00:03:53,090 --> 00:03:56,570
For example, first perpetrator here is AF_XDP.

00:03:56,570 --> 00:03:57,820
In the AFX_DP bind call,

00:03:57,820 --> 00:04:00,670
you bind into a neft or an interface

00:04:00,670 --> 00:04:02,330
and a specific queue.

00:04:02,330 --> 00:04:04,090
The queue you want to get the traffic from

00:04:04,090 --> 00:04:05,840
or send the traffic to.

00:04:05,840 --> 00:04:08,843
So it really needs a specific qid.

00:04:09,770 --> 00:04:11,980
So what queue should you should use?

00:04:11,980 --> 00:04:14,000
Well, in order to know that,

00:04:14,000 --> 00:04:16,600
you have to know what driver you're using,

00:04:16,600 --> 00:04:18,070
read the driver,

00:04:18,070 --> 00:04:20,410
and then you have to input this in some formula.

00:04:20,410 --> 00:04:23,490
That means you know how many cores do you have?

00:04:23,490 --> 00:04:25,573
What other options in my system am I doing

00:04:25,573 --> 00:04:28,710
that I'm doing AF_XDP Tx at the same time?

00:04:28,710 --> 00:04:30,730
Do I have any queue disk hardware flow?

00:04:30,730 --> 00:04:31,830
Blah blah blah.

00:04:31,830 --> 00:04:35,100
And you get a formula and that's a not very nice use

00:04:35,100 --> 00:04:35,933
of interface.

00:04:35,933 --> 00:04:39,360
So this also might depend on the version of the driver

00:04:39,360 --> 00:04:42,130
you're using and so on and so forth, so.

00:04:42,130 --> 00:04:42,963
Not very good.

00:04:42,963 --> 00:04:43,820
Most have these two.

00:04:43,820 --> 00:04:45,100
These two as a user,

00:04:45,100 --> 00:04:49,283
has a number of different ways of using queues.

00:04:51,080 --> 00:04:53,090
And also, of course, in sysfs,

00:04:53,090 --> 00:04:58,090
you have these sysclossnet, your device name, queues,

00:04:58,540 --> 00:05:01,590
Rx, Tx, and you can see the queues

00:05:01,590 --> 00:05:02,890
used by the Linux back there,

00:05:02,890 --> 00:05:05,800
and you can get some statistics from them, and so on,

00:05:05,800 --> 00:05:08,703
but it's only the ones from the Linux networking stack.

00:05:10,290 --> 00:05:11,770
So the problem here then is stacked.

00:05:11,770 --> 00:05:15,350
Okay, what qid should I actually provide here?

00:05:15,350 --> 00:05:17,060
What queues should I manipulate?

00:05:17,060 --> 00:05:19,120
Let's say I have a new queue here,

00:05:19,120 --> 00:05:22,030
that was created under the hood of me

00:05:22,030 --> 00:05:23,720
and I will do something with these two.

00:05:23,720 --> 00:05:24,950
What qid does it have?

00:05:24,950 --> 00:05:27,630
I dunno, unless I study the driver.

00:05:27,630 --> 00:05:28,560
So that's the problem.

00:05:28,560 --> 00:05:33,020
We want some way of actually knowing what queues are in use,

00:05:33,020 --> 00:05:34,343
getting an ID of them,

00:05:35,350 --> 00:05:37,530
so I can input that into Tools,

00:05:37,530 --> 00:05:40,290
and also be able to allocate free queues,

00:05:40,290 --> 00:05:44,020
because especially AF_XDP needs new queues

00:05:44,020 --> 00:05:45,530
that you can route your traffic through,

00:05:45,530 --> 00:05:47,940
so it doesn't disturb the Linux networking stack

00:05:47,940 --> 00:05:50,690
or anything else that happens to be using these queues.

00:05:54,000 --> 00:05:55,213
Okay, so the outline here then.

00:05:55,213 --> 00:05:58,100
Just start with the problem scoping

00:05:58,100 --> 00:06:00,360
and then I'm gonna define what we say is a queue

00:06:00,360 --> 00:06:01,780
in this interface.

00:06:01,780 --> 00:06:04,120
And then, propose an interface,

00:06:04,120 --> 00:06:07,070
and then go through some usage examples,

00:06:07,070 --> 00:06:09,680
and then a design proposal and implementation plan,

00:06:09,680 --> 00:06:13,340
'cause this will not be implemented in one patch.

00:06:13,340 --> 00:06:15,170
There will be a number of steps,

00:06:15,170 --> 00:06:17,720
and then challenges and open questions, at the end.

00:06:20,210 --> 00:06:23,210
Okay, so first, just to be able to frame the problems.

00:06:23,210 --> 00:06:25,620
So we're talking about exactly the same thing.

00:06:25,620 --> 00:06:28,400
Here's some very basic queue hardware basics

00:06:28,400 --> 00:06:30,700
and of course, every single NIC doesn't do it

00:06:30,700 --> 00:06:31,533
in the same way,

00:06:31,533 --> 00:06:34,400
but you start off with having a number of queues,

00:06:34,400 --> 00:06:36,550
a number of PFs, a number of EFs,

00:06:36,550 --> 00:06:39,380
and then there's some partitioning magic happening.

00:06:39,380 --> 00:06:40,740
Could be static, could be dynamic,

00:06:40,740 --> 00:06:42,100
depending on your NIC.

00:06:42,100 --> 00:06:43,670
You end up with some configuration.

00:06:43,670 --> 00:06:46,450
In this case, you have a PF with 64 queues

00:06:46,450 --> 00:06:48,910
and two VFs with 16 queues each,

00:06:48,910 --> 00:06:50,540
but you can also have other configurations,

00:06:50,540 --> 00:06:53,570
like you can have a PF that has VFs in itself.

00:06:53,570 --> 00:06:54,803
So in this case,

00:06:55,690 --> 00:06:59,820
it took that 64 queue PF and you gave 16 of those queues

00:06:59,820 --> 00:07:00,937
to the VF,

00:07:00,937 --> 00:07:03,063
and the PF still has 48 queues.

00:07:04,140 --> 00:07:07,470
If we just look at that 48 queues in the PF,

00:07:07,470 --> 00:07:08,470
once you decide that, okay,

00:07:08,470 --> 00:07:10,840
this is something I wanna use in Linux,

00:07:10,840 --> 00:07:12,286
you create a netdev,

00:07:12,286 --> 00:07:14,390
where you get in the netdev abstraction of this PF,

00:07:14,390 --> 00:07:17,700
and that netdev then has 48 queues allocated to it,

00:07:17,700 --> 00:07:20,070
and then, you can use these queues for various things.

00:07:20,070 --> 00:07:21,970
In this example, it's used for the Linux stack,

00:07:21,970 --> 00:07:23,400
it's used for an XDP app,

00:07:23,400 --> 00:07:25,890
because it uses XDP_REDIRECT, for example,

00:07:25,890 --> 00:07:28,090
and maybe an AF_XDP app.

00:07:28,090 --> 00:07:30,280
And there really are two problems here.

00:07:30,280 --> 00:07:32,010
The first problem, on the top row,

00:07:32,010 --> 00:07:36,140
is splitting up queues between PFs and VFs in the device.

00:07:36,140 --> 00:07:38,870
And the second problem is basically the second row

00:07:38,870 --> 00:07:41,823
is allocating and freeing queues within a netdev.

00:07:42,730 --> 00:07:46,070
So we're only gonna look at the second problem.

00:07:46,070 --> 00:07:50,140
So given a netdev and a set of queues,

00:07:50,140 --> 00:07:53,140
how do I do reset management of those queues in that netdev?

00:07:54,230 --> 00:07:56,800
The first problem is very interesting, too,

00:07:56,800 --> 00:08:01,040
and it seems to be something on the devlink level,

00:08:01,040 --> 00:08:03,290
but they think that all NIC vendors are doing this

00:08:03,290 --> 00:08:04,250
in a very different way,

00:08:04,250 --> 00:08:06,620
so just to make the problem tractable

00:08:06,620 --> 00:08:08,660
and to make forward progress,

00:08:08,660 --> 00:08:12,270
we're just focused on the latter problem here,

00:08:12,270 --> 00:08:14,810
because that also solves some of our problems.

00:08:14,810 --> 00:08:16,110
Not all of them, but some.

00:08:20,100 --> 00:08:23,210
Okay, so what's a queue in our definition?'

00:08:23,210 --> 00:08:25,030
So it's uni-directional.

00:08:25,030 --> 00:08:29,393
It's either Rx or Tx, but not both at the same time.

00:08:31,580 --> 00:08:32,960
It's tied to a hardware device,

00:08:32,960 --> 00:08:36,180
or more specifically, it's tied to a netdev,

00:08:36,180 --> 00:08:39,640
because there are virtual devices, too, so.

00:08:39,640 --> 00:08:42,260
But really, it's tied to one netdev.

00:08:42,260 --> 00:08:47,260
And it's referenced by ifindex and qid, that tuple,

00:08:48,110 --> 00:08:51,110
and the qid will be unique within a device.

00:08:51,110 --> 00:08:52,910
There's no two queues within a netdev

00:08:52,910 --> 00:08:53,973
that has the same ID,

00:08:54,820 --> 00:08:56,710
but between netdevs, it might have same ID,

00:08:56,710 --> 00:08:59,003
but it's always this tuple that refers to it.

00:09:00,290 --> 00:09:03,337
A queue belongs to a single netdev

00:09:03,337 --> 00:09:05,540
and because a netdev belongs to a single namespace,

00:09:05,540 --> 00:09:07,690
a queue belongs to a single namespace, too.

00:09:09,280 --> 00:09:12,563
And we always refer to a real hardware queue,

00:09:13,951 --> 00:09:17,300
of course, if it's a hardware device, or physical device.

00:09:17,300 --> 00:09:20,080
If it's a virtual device, we do not have a magical wand

00:09:20,080 --> 00:09:21,687
that with a virtual queue sent to hardware queues,

00:09:21,687 --> 00:09:23,010
and of course, they are virtual,

00:09:23,010 --> 00:09:25,560
but for hardware device, the queues should be real.

00:09:25,560 --> 00:09:27,110
They should be hardware queues,

00:09:28,100 --> 00:09:32,380
and the qid is completely opaque in userspace.

00:09:32,380 --> 00:09:35,730
You cannot make any assumption of the qids, should be,

00:09:35,730 --> 00:09:37,970
and we'll actually have one violation of this rule

00:09:37,970 --> 00:09:39,330
for compatibility reasons,

00:09:39,330 --> 00:09:40,610
but we'll get to that later,

00:09:40,610 --> 00:09:45,610
but any new user of this should think that qid, opaque.

00:09:45,830 --> 00:09:48,130
Don't make any assumptions, could be anything.

00:09:52,570 --> 00:09:54,550
So just to go through the interface process

00:09:54,550 --> 00:09:55,410
on a very high level.

00:09:55,410 --> 00:09:58,110
We'll go into some more details later.

00:09:58,110 --> 00:10:00,060
We propose to make a netlink interface

00:10:00,060 --> 00:10:03,520
and the five primary operations here is gonna be,

00:10:03,520 --> 00:10:07,010
first of all, a command to be able to list all queues

00:10:07,010 --> 00:10:09,770
for a specific interface.

00:10:09,770 --> 00:10:11,810
So get a list of everything that's being used

00:10:11,810 --> 00:10:13,674
at this point in time.

00:10:13,674 --> 00:10:15,750
We'll go into some more details about this.

00:10:15,750 --> 00:10:20,170
Then this'll be one command for allocating a queue.

00:10:20,170 --> 00:10:21,980
So give me a new queue.

00:10:21,980 --> 00:10:24,150
Something that's not been used before

00:10:24,150 --> 00:10:25,510
and you get an identifier.

00:10:25,510 --> 00:10:27,750
We'll look into more details about that.

00:10:27,750 --> 00:10:30,930
And then you can be able to get attributes of this queue

00:10:30,930 --> 00:10:33,020
and to be able to set some attributes of this queue.

00:10:33,020 --> 00:10:34,920
Not all of them, but some of them,

00:10:34,920 --> 00:10:37,340
and of course, at the end, you can also free your queue

00:10:37,340 --> 00:10:38,630
to give it back to the netdev,

00:10:38,630 --> 00:10:40,130
so somebody else could get it.

00:10:43,040 --> 00:10:44,720
And if we look a little bit more detail now

00:10:44,720 --> 00:10:46,640
in the various module.

00:10:46,640 --> 00:10:48,990
What does an allocation look like?

00:10:48,990 --> 00:10:51,020
So what can I actually allocate?

00:10:51,020 --> 00:10:53,350
So a W in front of the parameter

00:10:53,350 --> 00:10:55,460
means that it's data that's written,

00:10:55,460 --> 00:10:56,470
so it's input data,

00:10:56,470 --> 00:10:59,133
something I write from the user's base, goes in,

00:11:00,090 --> 00:11:02,350
or it means it's read, it's output data.

00:11:02,350 --> 00:11:05,163
And if it's RW, it's both input and output data.

00:11:06,830 --> 00:11:08,300
So the first thing I need to give this

00:11:08,300 --> 00:11:10,210
is an interface index.

00:11:10,210 --> 00:11:13,010
So interface this queue should be allocated from.

00:11:13,010 --> 00:11:14,200
That's the first thing.

00:11:14,200 --> 00:11:16,310
And then, it's an optional name for this queue,

00:11:16,310 --> 00:11:17,870
which could be good to have names for them,

00:11:17,870 --> 00:11:19,570
so you know what they're used for.

00:11:21,300 --> 00:11:25,430
And then I have another field called interrupt or irq.

00:11:25,430 --> 00:11:28,720
If you don't provide anything here, so you leave it blank,

00:11:28,720 --> 00:11:31,400
you will associate this queue with an unused irq,

00:11:31,400 --> 00:11:35,200
if possible, and return the irq number in the same field,

00:11:35,200 --> 00:11:38,070
so you get exactly, okay, I tied it to this irq,

00:11:38,070 --> 00:11:39,670
and it was not used,

00:11:39,670 --> 00:11:42,000
but if you provide an entry here,

00:11:42,000 --> 00:11:46,673
you will associate this queue with this interrupt,

00:11:47,570 --> 00:11:50,130
so will be triggered by this interrupt.

00:11:50,130 --> 00:11:54,050
And the fourth parameter is type,

00:11:54,050 --> 00:11:56,720
so you have to specify should it be a Tx queue

00:11:56,720 --> 00:11:59,643
or an Rx queue, not both, just one of them.

00:12:00,770 --> 00:12:03,480
And this function returns a qid,

00:12:03,480 --> 00:12:07,600
this opaque entity that you can use in your user space then,

00:12:07,600 --> 00:12:09,500
and of course, there's an error field, too,

00:12:09,500 --> 00:12:11,200
when you can't allocate something.

00:12:14,530 --> 00:12:17,440
If you look at the list command, same here,

00:12:17,440 --> 00:12:19,990
you provide an interface index again,

00:12:19,990 --> 00:12:22,790
saying that I'm interested in the queues of this netdev,

00:12:23,640 --> 00:12:26,750
and then you have another variable.

00:12:26,750 --> 00:12:31,259
It's either that you have to input inside the name,

00:12:31,259 --> 00:12:36,259
qid, or search by name, or a qid,

00:12:36,350 --> 00:12:38,630
or a specific interrupt,

00:12:38,630 --> 00:12:41,670
or if you have it blank, you won't show any queue

00:12:41,670 --> 00:12:43,560
that's been allocated on the device,

00:12:43,560 --> 00:12:45,640
or used on the device,

00:12:45,640 --> 00:12:48,620
and then it returns on the name, the qid, the irqs,

00:12:48,620 --> 00:12:50,427
all the attributes of a queue,

00:12:50,427 --> 00:12:52,210
and of all the queues that you actually match

00:12:52,210 --> 00:12:53,310
your search criteria.

00:12:53,310 --> 00:12:55,060
That's the whole point.

00:12:55,060 --> 00:12:58,410
So here you can get to know what you're actually using

00:12:58,410 --> 00:13:00,820
on the device and gets on filtering, too,

00:13:00,820 --> 00:13:03,410
'cause it might be, as it sees little bit later,

00:13:03,410 --> 00:13:04,840
it's good to know, for example,

00:13:04,840 --> 00:13:06,960
all queues tied to a specific irq,

00:13:06,960 --> 00:13:10,053
so you know which one will trigger at the same time, so.

00:13:12,690 --> 00:13:14,340
So just get you through some examples.

00:13:14,340 --> 00:13:17,427
So how could this possibly be used from userspace?

00:13:18,980 --> 00:13:20,780
So let's say you have AF_XDP first.

00:13:20,780 --> 00:13:23,610
We'll go through three different examples.

00:13:23,610 --> 00:13:25,550
What if I want to allocate a queue pair?

00:13:25,550 --> 00:13:28,250
And it should be a thing that ties to a specific core

00:13:28,250 --> 00:13:31,750
and then I want to bind an AF_XDP to this queue.

00:13:31,750 --> 00:13:32,583
So what would I do then?

00:13:32,583 --> 00:13:36,300
And this is just very simplified pseudo-code, of course.

00:13:36,300 --> 00:13:41,300
I would first allocate a queue on interface index one,

00:13:41,410 --> 00:13:43,620
and give it the name of the Rx queue,

00:13:43,620 --> 00:13:48,153
and it will return a qid and an interrupt to me, so.

00:13:49,481 --> 00:13:51,470
The qid is this opaque entity.

00:13:51,470 --> 00:13:54,200
I can refer to the handle and it say me, okay,

00:13:54,200 --> 00:13:55,690
I found this irq channel.

00:13:55,690 --> 00:13:57,570
It was not used by anything else here.

00:13:57,570 --> 00:13:59,230
This is the irq.

00:13:59,230 --> 00:14:00,970
And then I do another allocation

00:14:00,970 --> 00:14:01,940
and with this allocation,

00:14:01,940 --> 00:14:03,833
I feed in the same interface index,

00:14:05,650 --> 00:14:08,220
the name of it, whatever I wanna call it,

00:14:08,220 --> 00:14:11,200
and then I say this is a Tx queue

00:14:11,200 --> 00:14:14,880
and I give it also the irq that I got back

00:14:14,880 --> 00:14:16,400
from the first allocation.

00:14:16,400 --> 00:14:18,900
So I tie this Rx and Tx to the same irq.

00:14:18,900 --> 00:14:20,160
Yes, if you pass,

00:14:20,160 --> 00:14:21,760
Can somebody pass the mic there?

00:14:25,290 --> 00:14:29,180
- So it seems like that's too late to get NUMA allocation

00:14:29,180 --> 00:14:31,313
of memory for the received queue, correct?

00:14:33,420 --> 00:14:34,750
- That's a good question.

00:14:34,750 --> 00:14:38,652
So, that's a really good question.

00:14:38,652 --> 00:14:40,510
You wanna know exactly when,

00:14:40,510 --> 00:14:43,800
You don't wanna be able to have it allocated in same node.

00:14:43,800 --> 00:14:44,633
Yeah, that's a good point.

00:14:44,633 --> 00:14:46,610
- I mean, it seems like when you allocate the queue,

00:14:46,610 --> 00:14:48,300
you need to know what node you're doing it on,

00:14:48,300 --> 00:14:52,075
so either that should be a parameter to the allocation, or,

00:14:52,075 --> 00:14:53,993
- Yeah, that's good, that's great.

00:14:58,470 --> 00:15:00,750
And then, you would, for example, to do the finity,

00:15:00,750 --> 00:15:03,090
you would take the interrupt that you got back

00:15:03,090 --> 00:15:05,407
and feed it into their proc filesystem,

00:15:05,407 --> 00:15:08,910
infinitize that interrupt at some point,

00:15:08,910 --> 00:15:09,890
and then you bind it,

00:15:09,890 --> 00:15:13,308
and of course, this bind option doesn't exist at this point.

00:15:13,308 --> 00:15:16,407
At this point, you get bind AF_DPX.

00:15:16,407 --> 00:15:20,250
A file scripter, an interface, and a qid,

00:15:20,250 --> 00:15:23,760
and it's actually the qid of the Rx queue

00:15:23,760 --> 00:15:26,120
and in this case, if you actually had a qid of the Rx

00:15:26,120 --> 00:15:27,230
and a qid of the Tx,

00:15:27,230 --> 00:15:28,810
you would also have the second option there,

00:15:28,810 --> 00:15:30,603
to provide the qid of the Tx,

00:15:31,940 --> 00:15:35,520
and of course, the previous option of just giving the qid

00:15:35,520 --> 00:15:36,780
of Rx would still work.

00:15:36,780 --> 00:15:39,370
It would just be like today,

00:15:39,370 --> 00:15:41,233
you will get a Tx queue picked.

00:15:42,351 --> 00:15:45,487
It would just pick a qid from you, that's it, so.

00:15:46,990 --> 00:15:48,453
Or pick a Tx queue for you.

00:15:49,370 --> 00:15:52,730
But if you want to specify both Rx and Tx queue,

00:15:52,730 --> 00:15:54,980
the interface today needs a big standard, so.

00:15:58,805 --> 00:16:00,060
And if we look at Ethtool.

00:16:00,060 --> 00:16:02,177
Ethtool today uses a queue in various ways.

00:16:02,177 --> 00:16:04,340
Has this concept called channels.

00:16:04,340 --> 00:16:07,750
And so all queues tied to the same interrupt

00:16:07,750 --> 00:16:09,180
is forming a channel,

00:16:09,180 --> 00:16:12,030
according to these two definition,

00:16:12,030 --> 00:16:14,510
and they're numbered zero to the real number

00:16:14,510 --> 00:16:17,400
of the Rx or Tx use minus one that you have,

00:16:17,400 --> 00:16:20,100
so they have a specific numbering, too.

00:16:20,100 --> 00:16:21,667
But the problem here is that, okay,

00:16:21,667 --> 00:16:25,703
this API produces two qids that are opaque.

00:16:26,550 --> 00:16:28,450
So how can we actually deal with this?

00:16:29,300 --> 00:16:32,740
So maybe we should violate this opaqueness a little bit here

00:16:32,740 --> 00:16:37,180
and say, okay, can we give the Linux stack Rx queues

00:16:37,180 --> 00:16:41,703
always have a qid zero to real number qids minus one?

00:16:43,230 --> 00:16:44,500
So they always have that.

00:16:44,500 --> 00:16:47,570
So somebody has a program saying that, okay,

00:16:47,570 --> 00:16:52,570
I'm gonna set some parameter of qid number zero

00:16:52,980 --> 00:16:56,690
and these two hard-coded zero.

00:16:56,690 --> 00:16:59,430
It always will mean the same thing, even in this case.

00:16:59,430 --> 00:17:01,730
If these two would use an interface like this.

00:17:04,310 --> 00:17:06,490
And how will this look inside ethtool?

00:17:06,490 --> 00:17:10,083
Well, ethtool would look at the irq of the supplied qid

00:17:11,650 --> 00:17:14,430
and then list all queues using that irq,

00:17:14,430 --> 00:17:18,060
and then you get all the queues using that irq

00:17:18,060 --> 00:17:20,160
and you can form a channel of that.

00:17:20,160 --> 00:17:21,890
So if you get one Rx queue, one Tx queue,

00:17:21,890 --> 00:17:23,940
okay, that's a combined channel.

00:17:23,940 --> 00:17:25,050
Tick.

00:17:25,050 --> 00:17:27,270
And if you get one Rx queue back.

00:17:27,270 --> 00:17:28,880
Oh, it's an Rx channel.

00:17:28,880 --> 00:17:30,870
And then it can count things like that.

00:17:30,870 --> 00:17:34,910
Of course, that interface, internally, will be more

00:17:36,070 --> 00:17:38,360
convoluted because they have to do two calls.

00:17:38,360 --> 00:17:41,320
I guess I don't know the optimal interface of these two,

00:17:41,320 --> 00:17:42,507
but I guess it's one call,

00:17:42,507 --> 00:17:45,338
but now it will be a little bit more complicated.

00:17:45,338 --> 00:17:47,193
But of course, I don't know about,

00:17:49,310 --> 00:17:51,460
These two I've proposed using a netlink interface,

00:17:51,460 --> 00:17:53,470
does it have an interface today of this?

00:17:53,470 --> 00:17:54,550
- Not yet. - Not yet.

00:17:54,550 --> 00:17:56,140
- I don't want to add new things to ethtool

00:17:56,140 --> 00:17:59,523
until the netlink thing conversion is complete.

00:17:59,523 --> 00:18:00,530
- All right.

00:18:00,530 --> 00:18:02,410
Yeah, 'cause you don't want to have the netlink interface

00:18:02,410 --> 00:18:03,774
proposed for this,

00:18:03,774 --> 00:18:06,163
when you could also look in under using NF of course, so.

00:18:07,320 --> 00:18:08,870
There's one problem here, also.

00:18:09,730 --> 00:18:12,410
What do you do if you have a Tx only channel?

00:18:12,410 --> 00:18:15,120
I'm saying that only the Rx qid should be zero

00:18:15,120 --> 00:18:17,040
to number of Rx queues minus one,

00:18:17,040 --> 00:18:18,990
but what if you have a Tx only channel?

00:18:20,010 --> 00:18:20,880
How do you look it up?

00:18:20,880 --> 00:18:23,000
I don't have a good solution left.

00:18:23,000 --> 00:18:25,330
And I don't know if Tx only channels exist

00:18:25,330 --> 00:18:29,220
for the stuff that these two ethtool managers?

00:18:32,770 --> 00:18:33,603
I dunno.

00:18:33,603 --> 00:18:35,400
If anybody knows, please let me know.

00:18:35,400 --> 00:18:38,100
I haven't seen those, but I only have a few cards, so.

00:18:43,000 --> 00:18:45,504
Okay, so Toke, want to take this one?

00:18:45,504 --> 00:18:46,337
- Yes.

00:18:49,401 --> 00:18:52,068
So a little bit of history here.

00:18:53,500 --> 00:18:55,360
When we started discussing this,

00:18:55,360 --> 00:18:58,630
you guys started out with AF_XDP

00:18:58,630 --> 00:19:03,000
and trying to solve the interface for that,

00:19:03,000 --> 00:19:04,760
and then Jesper and I were like, wait a minute,

00:19:04,760 --> 00:19:07,380
we have another problem why we have a really bad interface

00:19:07,380 --> 00:19:09,533
to queues and that's XDP_REDIRECT.

00:19:09,533 --> 00:19:10,366
- Your microphone's off.

00:19:10,366 --> 00:19:11,514
Use this one.

00:19:11,514 --> 00:19:12,347
- Is it off?

00:19:12,347 --> 00:19:13,540
- It's on the soundboard.

00:19:13,540 --> 00:19:14,373
It's not on.

00:19:14,373 --> 00:19:15,310
- Oh, the guy left?

00:19:15,310 --> 00:19:16,350
Hello, can you hear me now?

00:19:16,350 --> 00:19:17,460
- Yeah, there you go.

00:19:17,460 --> 00:19:18,293
- All right.

00:19:21,098 --> 00:19:22,020
Okay, I'll try again.

00:19:22,020 --> 00:19:27,020
So we started discussing this in the context of AF_XDP.

00:19:29,080 --> 00:19:29,913
Now it's on.

00:19:31,280 --> 00:19:32,740
Thank you.

00:19:32,740 --> 00:19:36,620
And then Jesper and I realized, oh, we have another issue

00:19:36,620 --> 00:19:38,810
where, when you do XDP_REDIRECT.

00:19:38,810 --> 00:19:41,110
How many of you have tried doing XDP_REDIRECT

00:19:41,110 --> 00:19:43,910
and the packets just magically disappear into the ether?

00:19:46,010 --> 00:19:50,520
Yeah, so part of this is because we don't have an interface

00:19:50,520 --> 00:19:55,520
to allocate resources for XDP_REDIRECT on the egress side,

00:19:55,570 --> 00:19:57,230
and so drivers just do random things.

00:19:57,230 --> 00:19:59,360
So for example, info drivers will,

00:19:59,360 --> 00:20:04,360
when you load an Rx interface, Rx XDP program,

00:20:04,440 --> 00:20:05,273
onto an interface,

00:20:05,273 --> 00:20:08,320
it will also allocate Tx queues.

00:20:08,320 --> 00:20:11,040
So, that means that if you look at the example program

00:20:11,040 --> 00:20:13,100
for XDP_REDIRECT in the kernel source,

00:20:13,100 --> 00:20:15,440
it will load an empty XDP program

00:20:15,440 --> 00:20:17,820
on the target interface that you redirect into

00:20:17,820 --> 00:20:19,580
because otherwise, there will be no Tx queues

00:20:19,580 --> 00:20:20,440
in that interface

00:20:20,440 --> 00:20:22,230
and your packets are just getting got.

00:20:22,230 --> 00:20:24,200
Mellanox cuts through something different

00:20:24,200 --> 00:20:26,200
and it's also tied to the number of CPUs.

00:20:26,200 --> 00:20:29,000
If you have more CPUs than you have hardware queues

00:20:29,000 --> 00:20:29,833
in your device,

00:20:29,833 --> 00:20:32,140
you're just not gonna get packets,

00:20:32,140 --> 00:20:34,390
and so obviously, that's not a good situation

00:20:34,390 --> 00:20:35,940
for XDP_REDIRECT,

00:20:35,940 --> 00:20:38,980
and so now if we are defining this

00:20:38,980 --> 00:20:40,780
and as you can see from this slide,

00:20:40,780 --> 00:20:43,540
the details that we grind out, work in progress,

00:20:43,540 --> 00:20:45,100
we should have more of the little guys

00:20:45,100 --> 00:20:46,920
that are digging on this,

00:20:46,920 --> 00:20:50,100
but if we have the interface now to define queues,

00:20:50,100 --> 00:20:51,900
we could also use this for redirect,

00:20:53,260 --> 00:20:55,650
because then you can actually go and allocate.

00:20:55,650 --> 00:20:58,090
Okay, I want to redirect out of this interface,

00:20:58,090 --> 00:21:00,850
and now we have a netlink interface to say,

00:21:00,850 --> 00:21:02,790
I would like to have allocated some queues

00:21:02,790 --> 00:21:04,590
that I can use for redirect targets,

00:21:05,700 --> 00:21:08,410
but we also need to figure out how do we then

00:21:08,410 --> 00:21:09,900
define this redirect target,

00:21:09,900 --> 00:21:13,760
so I think we discussed two ways to do it.

00:21:13,760 --> 00:21:18,760
One is this becomes a global property of the interface,

00:21:19,910 --> 00:21:21,660
that says that if this, right now,

00:21:21,660 --> 00:21:23,760
would you redirect the target of the redirect

00:21:23,760 --> 00:21:25,190
as an interface name?

00:21:25,190 --> 00:21:26,620
All right, I have index.

00:21:26,620 --> 00:21:27,700
And so, either we could say,

00:21:27,700 --> 00:21:30,610
okay, we have a global property,

00:21:30,610 --> 00:21:33,790
new configuration interface to configure this interface,

00:21:33,790 --> 00:21:35,420
how do you want to do your queues,

00:21:35,420 --> 00:21:38,760
or, and this is what is on this slide.

00:21:38,760 --> 00:21:41,940
We have the netlink command queue unlocked,

00:21:41,940 --> 00:21:44,300
we get a new Tx queue

00:21:45,240 --> 00:21:48,333
and then we define a new map type.

00:21:49,600 --> 00:21:52,810
Instead of a devmap, we now have a queuemap,

00:21:52,810 --> 00:21:55,040
and so we define this struck queue target

00:21:55,040 --> 00:21:58,728
where you put in one or you can see that's an array.

00:21:58,728 --> 00:22:01,250
This does not compile.

00:22:01,250 --> 00:22:02,440
It's pseudo-code.

00:22:02,440 --> 00:22:04,300
(laughing)

00:22:04,300 --> 00:22:06,930
But you put in one or more queues in the start,

00:22:06,930 --> 00:22:07,890
and you put in a mode.

00:22:07,890 --> 00:22:10,180
So this site case, we just putting in one queue

00:22:10,180 --> 00:22:11,980
and say it's a single queue thing,

00:22:11,980 --> 00:22:13,450
so we only want to use one queue,

00:22:13,450 --> 00:22:16,700
because we're using all the others for our AF_XDP target,

00:22:16,700 --> 00:22:18,630
but we want to be able to redirect out of it,

00:22:18,630 --> 00:22:20,010
and we're not going to do so much,

00:22:20,010 --> 00:22:21,950
so it's a single queue, okay,

00:22:21,950 --> 00:22:23,670
so it's probably a lock for somewhere

00:22:23,670 --> 00:22:25,520
because it's coming from all different CPUs

00:22:25,520 --> 00:22:27,780
and we want to use the same queue.

00:22:27,780 --> 00:22:32,780
Or you could do mode is queue mot subu number,

00:22:33,640 --> 00:22:35,337
so you just do round robin to the number,

00:22:35,337 --> 00:22:36,670
or you can do queue hash,

00:22:36,670 --> 00:22:37,503
or you can do what we have today,

00:22:37,503 --> 00:22:40,510
which is just mode CPUID.

00:22:40,510 --> 00:22:43,490
Why do you assume that you only ever are going to see

00:22:43,490 --> 00:22:44,810
the packet on the CPU?

00:22:44,810 --> 00:22:48,060
And that would be the nice, fast lock-less version.

00:22:48,060 --> 00:22:53,060
And so we use the device map, which is now a queuemap

00:22:53,580 --> 00:22:55,230
as the configuration interface for this.

00:22:55,230 --> 00:22:57,940
So depending on what you put into that,

00:22:57,940 --> 00:23:01,870
you can then have each entry in the map,

00:23:01,870 --> 00:23:05,870
which becomes the target of your BPF redirect map call,

00:23:05,870 --> 00:23:06,703
down here,

00:23:08,630 --> 00:23:11,810
then implicitly contains the queue configuration.

00:23:11,810 --> 00:23:14,710
That also means you can have a fast path and a slow path,

00:23:14,710 --> 00:23:17,210
so your BPF program could figure out,

00:23:17,210 --> 00:23:20,110
am I on a CPU that configured for fast transmit,

00:23:20,110 --> 00:23:21,420
because that's the normal case?

00:23:21,420 --> 00:23:24,370
Cool, I just do the lock-less thing.

00:23:24,370 --> 00:23:26,890
Oh, no, I'm on the slow fall back,

00:23:26,890 --> 00:23:31,250
because this came in on the other CPU or whatever.

00:23:31,250 --> 00:23:33,448
Okay, I have another interface that's the same

00:23:33,448 --> 00:23:37,660
I have indexed, but it's a different queue configurations.

00:23:37,660 --> 00:23:39,570
So we'll take a lock and it'll be a bit slower.

00:23:39,570 --> 00:23:40,779
You can do all this kinds of stuff

00:23:40,779 --> 00:23:42,380
because you have the map structure to use

00:23:42,380 --> 00:23:44,050
and there's a bit of precedence for this,

00:23:44,050 --> 00:23:46,450
'cause we already do all these weird tricks

00:23:46,450 --> 00:23:49,890
in the redirect map that Jesper put in the bulking

00:23:49,890 --> 00:23:50,723
and so on,

00:23:50,723 --> 00:23:53,230
which is also the reason why the redirect map help

00:23:53,230 --> 00:23:55,310
is way faster than the redirect.

00:23:55,310 --> 00:23:56,810
Don't use XDP_REDIRECT.

00:23:56,810 --> 00:23:59,320
Always use XDP_REDIRECT map.

00:23:59,320 --> 00:24:00,153
It's faster.

00:24:01,180 --> 00:24:05,180
So we already using this map structure to do all

00:24:05,180 --> 00:24:06,180
kinds of weird stuff.

00:24:06,180 --> 00:24:07,940
So if we just go on this

00:24:07,940 --> 00:24:11,080
and so once we go further down,

00:24:11,080 --> 00:24:14,560
we can also put a packet queue in here

00:24:14,560 --> 00:24:16,730
and we can do all these kinds of configuration

00:24:16,730 --> 00:24:20,290
if we actually want to extend the capabilities

00:24:20,290 --> 00:24:22,060
of XDP_REDIRECT to be redirect.

00:24:22,060 --> 00:24:24,320
So that's also part of this

00:24:24,320 --> 00:24:27,600
and we'll figure out the details once we've gone on.

00:24:27,600 --> 00:24:28,433
Questions?

00:24:29,320 --> 00:24:30,730
- You get the questions afterwards.

00:24:30,730 --> 00:24:32,392
Otherwise, I'm not going to be able to finish.

00:24:32,392 --> 00:24:34,440
(laughing)

00:24:34,440 --> 00:24:35,320
Okay.

00:24:35,320 --> 00:24:36,849
You hear me now?

00:24:36,849 --> 00:24:39,270
So just a short kernel design overview.

00:24:39,270 --> 00:24:40,780
You'll get into an implementation plan

00:24:40,780 --> 00:24:44,160
just after this how to break this down in chunks

00:24:44,160 --> 00:24:47,820
that seem to be tractable at this point in time, at least.

00:24:47,820 --> 00:24:51,640
So we're gonna implement some kinda queue manager.

00:24:51,640 --> 00:24:55,880
This is a word we don't really like, queue manager,

00:24:55,880 --> 00:24:57,300
but that's the best one we can come up with.

00:24:57,300 --> 00:25:00,660
If you have a better name of this, please let me know,

00:25:00,660 --> 00:25:01,950
but it's an entity,

00:25:01,950 --> 00:25:04,840
a new entity in the system that can allocate

00:25:04,840 --> 00:25:09,840
the free queues and keep track of the queues

00:25:10,191 --> 00:25:12,090
as a resource.

00:25:12,090 --> 00:25:14,170
So there's a number of uses of this.

00:25:14,170 --> 00:25:17,630
There will be a number of uses of this inside the kernel.

00:25:17,630 --> 00:25:20,288
For example, the Linux stack or XDP that can ask,

00:25:20,288 --> 00:25:21,658
at some point in time, ask this to allocate a queue

00:25:21,658 --> 00:25:23,386
or RDOS or something,

00:25:23,386 --> 00:25:28,386
and it also, of course, uses space to its netlink interface,

00:25:28,460 --> 00:25:30,113
so if it uses space to allocate a queue,

00:25:30,113 --> 00:25:31,770
it will go down with this queue method,

00:25:31,770 --> 00:25:34,780
but the actual allocation, of course, of the queue,

00:25:34,780 --> 00:25:36,100
will be done by the device driver,

00:25:36,100 --> 00:25:39,020
so there will be a new interface between the device driver

00:25:39,020 --> 00:25:43,073
and the queue manager where you can allocate the free queue.

00:25:45,120 --> 00:25:48,760
But as you'll see, it's really not possible

00:25:48,760 --> 00:25:50,170
to implement this straightaway,

00:25:50,170 --> 00:25:51,003
so what we'll do,

00:25:51,003 --> 00:25:52,960
we can't take every single device and just change them.

00:25:52,960 --> 00:25:56,170
It doesn't work, so we'll have to do this in another way.

00:25:56,170 --> 00:25:59,110
We have to plug it in very very incrementally

00:25:59,110 --> 00:26:01,810
without any modifications to the device driver

00:26:01,810 --> 00:26:04,803
and let me see here.

00:26:06,260 --> 00:26:09,160
So implementation plan is we do something like this.

00:26:09,160 --> 00:26:10,760
We start with a netlink interface

00:26:10,760 --> 00:26:14,820
and then say (sysfs), we'll get to that in the next slide.

00:26:14,820 --> 00:26:16,743
Somebody wants this, but let's start with

00:26:16,743 --> 00:26:19,690
a netlink interface and implement this queue manage module

00:26:19,690 --> 00:26:20,930
in the kernel that keeps track

00:26:20,930 --> 00:26:24,190
of these queues and allocations and the allocations,

00:26:24,190 --> 00:26:26,750
and the first goal should just be to be able to show

00:26:26,750 --> 00:26:29,990
Linux stack queues in this netlink interface,

00:26:29,990 --> 00:26:31,820
and the way we'll do that is that we'll just plug

00:26:31,820 --> 00:26:35,710
ourself into the alloc_netdev queues and alloc_rf_queues

00:26:35,710 --> 00:26:38,230
because the driver will tell us how many we have

00:26:38,230 --> 00:26:39,220
and we'll just plug us in there

00:26:39,220 --> 00:26:42,380
and we don't need to modify the drivers.

00:26:42,380 --> 00:26:43,890
So when we get to that point,

00:26:43,890 --> 00:26:46,360
we can say, oh, we can show exactly the same thing

00:26:46,360 --> 00:26:47,710
as you can see today,

00:26:47,710 --> 00:26:50,370
but I think that's some progress,

00:26:50,370 --> 00:26:53,020
and then we add this Tx queues

00:26:53,020 --> 00:26:56,030
and we populate them, too, so you can actually see them

00:26:58,410 --> 00:27:00,990
and maybe other things like queue disk

00:27:00,990 --> 00:27:02,760
and hardware flow queues.

00:27:02,760 --> 00:27:03,840
I dunno.

00:27:03,840 --> 00:27:04,673
We'll see if we get to that,

00:27:04,673 --> 00:27:06,771
but we can get all the queues

00:27:06,771 --> 00:27:07,850
and you can just see things.

00:27:07,850 --> 00:27:09,600
You cannot allocate the free anything.

00:27:09,600 --> 00:27:11,900
You can just see what's used.

00:27:11,900 --> 00:27:13,710
That's the first goal.

00:27:13,710 --> 00:27:15,520
And then comes the more complicated things

00:27:15,520 --> 00:27:17,260
and then we actually need to start allocating

00:27:17,260 --> 00:27:18,580
and freeing queues and that means

00:27:18,580 --> 00:27:22,310
we actually have to implement new NDOS in the drivers

00:27:22,310 --> 00:27:25,913
and drivers today, maybe there are drivers

00:27:25,913 --> 00:27:26,840
that I have written with,

00:27:26,840 --> 00:27:29,250
that can allocate some free queues on demand,

00:27:29,250 --> 00:27:30,083
very dynamically,

00:27:30,083 --> 00:27:33,470
but most of the drivers are not written like that today.

00:27:33,470 --> 00:27:36,350
It's more like, if you want to add something,

00:27:36,350 --> 00:27:41,350
you just reset it, rebuild everything, and go to that.

00:27:41,370 --> 00:27:43,517
- You could start with netdevs, and,

00:27:43,517 --> 00:27:45,033
- Yep. (laughing)

00:27:45,033 --> 00:27:48,430
So, that's gonna be a lot of where we'll start,

00:27:48,430 --> 00:27:50,530
just, yeah, the single driver and start with that,

00:27:50,530 --> 00:27:52,970
and we need, at least for AF_XDP,

00:27:52,970 --> 00:27:56,050
we need little bit of helper for creating a new socket

00:27:56,050 --> 00:28:00,560
and tie it to a new dedicated AF_XDP, and yeah.

00:28:00,560 --> 00:28:02,010
Allocating the memory to the right NUMA mode

00:28:02,010 --> 00:28:03,190
and everything that we need to do

00:28:03,190 --> 00:28:04,700
in order for this to work

00:28:04,700 --> 00:28:07,823
and make it simple for people to use.

00:28:07,823 --> 00:28:08,660
I need to do that,

00:28:08,660 --> 00:28:12,490
and then also update the XDPsock app to use this,

00:28:12,490 --> 00:28:13,323
as an example.

00:28:14,334 --> 00:28:16,810
We also need iproute2 support for queue manipulation.

00:28:16,810 --> 00:28:18,580
You probably need common life support

00:28:18,580 --> 00:28:21,783
to be able to allocate the free and list queues there,

00:28:22,970 --> 00:28:25,230
and then get to the point where we update

00:28:25,230 --> 00:28:28,090
all three drivers currently supporting AF_XDP zero copy

00:28:28,090 --> 00:28:30,913
and say, okay, at least these three drivers can be using

00:28:30,913 --> 00:28:32,293
this new NDOS.

00:28:33,170 --> 00:28:35,970
And then there's some pipe dreams at the end.

00:28:35,970 --> 00:28:39,893
That's why, actually, at least the two last ones there,

00:28:41,200 --> 00:28:44,060
it seemed to be a nice thing to be able to move queue

00:28:44,060 --> 00:28:45,850
creation policy out so that driver now,

00:28:45,850 --> 00:28:48,810
all queue creation policies are inside the driver,

00:28:48,810 --> 00:28:51,200
and I have not checked every single driver,

00:28:51,200 --> 00:28:52,760
so I'm probably completely wrong,

00:28:52,760 --> 00:28:54,540
but it seems like the XDP Tx,

00:28:54,540 --> 00:28:58,010
most people allocate extra Tx queues

00:28:58,010 --> 00:29:00,930
and at least for modern devices,

00:29:00,930 --> 00:29:05,800
it seems that most of them allocate an Rx and a Tx queue

00:29:05,800 --> 00:29:08,050
per core for the Linux network stack,

00:29:08,050 --> 00:29:11,143
but there's probably exceptions to that rule, for sure,

00:29:13,570 --> 00:29:17,040
but it would be nice to get the policy outside,

00:29:17,040 --> 00:29:19,000
but it might be pipe dream, as I say,

00:29:19,000 --> 00:29:20,760
we might never get there.

00:29:20,760 --> 00:29:22,043
- [Toke] Adjust somewhere in the middle there

00:29:22,043 --> 00:29:23,830
a new map type for redirect.

00:29:23,830 --> 00:29:25,913
- Yeah. - Probably halfway.

00:29:30,756 --> 00:29:31,589
- Yes.

00:29:31,589 --> 00:29:33,510
Challenges, open questions.

00:29:33,510 --> 00:29:35,840
Well, one challenge was really good was the NUMA one.

00:29:35,840 --> 00:29:37,840
We need to specifically consider that.

00:29:37,840 --> 00:29:39,950
We forgot about that, so that's a great feedback,

00:29:39,950 --> 00:29:40,820
and that's why we're here.

00:29:40,820 --> 00:29:44,150
We wanna see where does it break,

00:29:44,150 --> 00:29:46,613
what have we forgotten, so that's a great comment.

00:29:47,823 --> 00:29:49,660
We have interactions with changing number of queues.

00:29:49,660 --> 00:29:53,017
In these two, for example, how do we deal with that?

00:29:53,017 --> 00:29:55,170
Do we say that this space real number of Tx Rx queues

00:29:55,170 --> 00:29:57,250
are like a research space?

00:29:57,250 --> 00:29:59,470
We never allocate anything from them

00:29:59,470 --> 00:30:01,010
and ethtool just works as before.

00:30:01,010 --> 00:30:03,020
You can scale it up and down, for example.

00:30:03,020 --> 00:30:05,610
- Since we have a 32-bit value, we have a large space

00:30:05,610 --> 00:30:07,180
to carve something like that out.

00:30:07,180 --> 00:30:08,403
- Yeah, yeah, exactly,

00:30:09,490 --> 00:30:11,890
and that's actually something that I forgot to tell.

00:30:11,890 --> 00:30:14,750
The qid spacing internally inside the kernel,

00:30:14,750 --> 00:30:15,880
we gonna have types,

00:30:15,880 --> 00:30:19,920
we're gonna carve out that entity into different types

00:30:19,920 --> 00:30:20,990
of queues, so.

00:30:20,990 --> 00:30:22,640
- Maybe you should use a u64.

00:30:22,640 --> 00:30:24,587
- Yes, we're gonna use 64.

00:30:24,587 --> 00:30:28,020
- But we don't wanna make it UAPI as the type thing.

00:30:28,020 --> 00:30:28,983
- Yeah. - I see.

00:30:30,060 --> 00:30:33,340
- No, so from the user space point of view, it's opaque,

00:30:33,340 --> 00:30:36,360
but internally, to make implementations in the drivers

00:30:36,360 --> 00:30:37,783
easier, we can code, you know?

00:30:37,783 --> 00:30:39,730
XDPX being certain types.

00:30:39,730 --> 00:30:41,920
You know what kind of setup you should have

00:30:41,920 --> 00:30:44,360
on the left queue and so on and so forth,

00:30:44,360 --> 00:30:46,760
but from user space, it should always be opaque.

00:30:47,630 --> 00:30:50,543
So we can experiment and change things inside Chrome.

00:30:52,560 --> 00:30:55,320
Second question is can ethtool use this interface?

00:30:55,320 --> 00:30:56,910
You know?

00:30:56,910 --> 00:30:57,900
Is that something that we add to ethtool

00:30:57,900 --> 00:30:59,883
that can use it or do we use ethtool

00:30:59,883 --> 00:31:01,930
when we said there's none so far,

00:31:01,930 --> 00:31:04,823
but we regret if we just use one instead of two.

00:31:07,060 --> 00:31:09,090
And there was sysfs interface.

00:31:09,090 --> 00:31:12,140
Some people say, yeah, we need a sysfs interface.

00:31:12,140 --> 00:31:13,070
Like, we have one.

00:31:13,070 --> 00:31:16,810
Sys/class netdev queues and rxmtm.

00:31:16,810 --> 00:31:18,670
There's some information there.

00:31:18,670 --> 00:31:20,920
Do we expose just read-only information

00:31:20,920 --> 00:31:22,340
in sysfs interface?

00:31:22,340 --> 00:31:23,470
You can see the queues there,

00:31:23,470 --> 00:31:24,760
but you can't manipulate them.

00:31:24,760 --> 00:31:27,460
To manipulate them, you go to netlink.

00:31:27,460 --> 00:31:30,000
- I think we should stay in netlink for the changes.

00:31:30,000 --> 00:31:30,833
- Sorry?

00:31:30,833 --> 00:31:32,310
- I think we should stick to netlink for changes.

00:31:32,310 --> 00:31:34,663
- Okay, yeah, yeah, yeah, yeah.

00:31:34,663 --> 00:31:36,150
- [Attendee] Yeah, I have a question in unlocking

00:31:36,150 --> 00:31:36,983
a ton of problems.

00:31:36,983 --> 00:31:39,683
- [Moderator] Ay, ay, please stand up.

00:31:40,884 --> 00:31:44,140
- [Attendee] Yeah, the problem with sysfs is that

00:31:44,140 --> 00:31:46,462
you can't really do multi-part operations.

00:31:46,462 --> 00:31:47,817
- [Magnus] Yes, exactly.

00:31:47,817 --> 00:31:49,150
- [Attendee] Unless from user space.

00:31:49,150 --> 00:31:50,590
- [Magnus] Maybe just for reading stuff.

00:31:50,590 --> 00:31:52,563
- [Attendee] For reading stuff, it's handy, yes.

00:31:55,390 --> 00:31:57,220
- And then another thing that we haven't gone into

00:31:57,220 --> 00:31:59,830
is what queue properties should be exposed.

00:31:59,830 --> 00:32:02,470
I mean, do you want to be able to get and set

00:32:02,470 --> 00:32:06,580
the number of hardware descriptors for a queue, for example?

00:32:06,580 --> 00:32:08,520
Is that something we want to expose?

00:32:08,520 --> 00:32:10,340
- Yes. - I think we already have

00:32:10,340 --> 00:32:11,490
ethtool stuff for that.

00:32:12,960 --> 00:32:14,703
- [Attendee] If we don't, we want it.

00:32:14,703 --> 00:32:17,453
(light laughing)

00:32:19,220 --> 00:32:21,375
- Some idea that Jacob had.

00:32:21,375 --> 00:32:24,843
He said he wants nocbeat in the interface as well.

00:32:26,230 --> 00:32:27,097
He didn't manage to convince me,

00:32:27,097 --> 00:32:29,190
but that's probably because I'm pig-headed,

00:32:29,190 --> 00:32:33,550
but I don't see it being used anywhere else,

00:32:33,550 --> 00:32:37,020
but he wanted specifically nocbeat in our queue

00:32:37,020 --> 00:32:38,650
and we'll see where that goes,

00:32:38,650 --> 00:32:42,173
but the proposal so far is just RA queue and nothing else.

00:32:44,420 --> 00:32:47,120
Do we, at some later stage, support virtual queues?

00:32:47,120 --> 00:32:49,400
Because if you create a program

00:32:49,400 --> 00:32:52,740
that is going to cost you 256 queues and allocate that,

00:32:52,740 --> 00:32:54,440
you want it to be able to run on any hardware,

00:32:54,440 --> 00:32:58,597
even if the hardware only has 32 queues, I guess,

00:32:58,597 --> 00:33:00,420
'cause otherwise it doesn't abstract as well, but,

00:33:00,420 --> 00:33:03,200
or you can build this in user space of course, right?

00:33:03,200 --> 00:33:04,300
That's another option,

00:33:06,030 --> 00:33:07,950
and yeah, what to call the queue manager.

00:33:07,950 --> 00:33:09,507
That's a good question.

00:33:09,507 --> 00:33:10,800
= It's the most important one.

00:33:10,800 --> 00:33:11,633
- Sorry?

00:33:11,633 --> 00:33:12,466
Yeah, exactly.

00:33:14,870 --> 00:33:15,870
So, next steps.

00:33:15,870 --> 00:33:17,020
This is the, okay.

00:33:17,020 --> 00:33:18,430
We'll go there.

00:33:18,430 --> 00:33:22,053
- I'm a little bit confused with the term queue, because,

00:33:23,360 --> 00:33:24,570
- [Magnus] That's why we don't want it called

00:33:24,570 --> 00:33:25,403
queue manager.

00:33:25,403 --> 00:33:29,370
- Yeah, and we have various types of queue inside,

00:33:29,370 --> 00:33:31,040
the software, the hardware,

00:33:31,040 --> 00:33:31,873
- [Magnus] Yeah, exactly.

00:33:31,873 --> 00:33:33,270
- I was thinking about shapers

00:33:33,270 --> 00:33:35,040
and we have shapers in queuedisc

00:33:35,040 --> 00:33:39,210
and we have dole shaper and how do we provide the full image

00:33:39,210 --> 00:33:40,160
to the customer?

00:33:40,160 --> 00:33:42,180
It's becoming quite complicated.

00:33:42,180 --> 00:33:43,230
- [Magnus] Yes, yeah.

00:33:50,300 --> 00:33:53,790
- So for the script or account case,

00:33:53,790 --> 00:33:56,200
I think it makes sense because

00:33:58,160 --> 00:34:00,160
you might have a situation where

00:34:01,810 --> 00:34:06,693
the hardware receiving might get,

00:34:08,930 --> 00:34:12,310
might be, for example, bigger than the field rink

00:34:13,530 --> 00:34:15,440
from the AF_XDP,

00:34:15,440 --> 00:34:20,440
so that you won't ever fill the hardware receiving

00:34:21,330 --> 00:34:24,440
and it would be constantly scheduling napi

00:34:24,440 --> 00:34:29,440
just to fulfill the receive hardware rink.

00:34:30,350 --> 00:34:35,350
So, when you are doing the allocation for the AF_XDP queues,

00:34:38,890 --> 00:34:43,890
they should be the same as AF_XDP field rink size.

00:34:46,440 --> 00:34:48,200
- [Magnus] Oh, okay, got it.

00:34:48,200 --> 00:34:53,200
- Because we had that situation where we changed

00:34:53,660 --> 00:34:58,140
in the ice driver the count of the receive queue

00:35:00,810 --> 00:35:05,810
and it was longer than the field rink,

00:35:06,160 --> 00:35:09,673
so the napi was constantly scheduled.

00:35:12,010 --> 00:35:14,600
- The question stands is that true that you say

00:35:14,600 --> 00:35:17,200
that the ethtool interface that will do a new netlink

00:35:17,200 --> 00:35:18,910
interface place or is it through this?

00:35:18,910 --> 00:35:19,833
I don't know.

00:35:23,720 --> 00:35:26,190
- Can you elaborate about the macvlan case

00:35:26,190 --> 00:35:27,721
on your previous slide?

00:35:27,721 --> 00:35:28,680
(laughing)

00:35:28,680 --> 00:35:31,990
- No, I can't.

00:35:31,990 --> 00:35:34,480
There's this macvlan where you can actually

00:35:34,480 --> 00:35:37,050
get a real queue exported to the macvlan,

00:35:37,050 --> 00:35:38,410
a real hardware queue

00:35:38,410 --> 00:35:40,770
and could we tie this into that to actually allocate

00:35:40,770 --> 00:35:42,340
that queue on demand?

00:35:42,340 --> 00:35:44,050
I think, is John here?

00:35:45,009 --> 00:35:45,842
Yeah, you're here.

00:35:45,842 --> 00:35:47,110
Didn't you do that?

00:35:47,110 --> 00:35:50,460
- But then, if you do that, maybe you want multiple queues

00:35:50,460 --> 00:35:53,160
to have a recent site or scaling.

00:35:53,160 --> 00:35:54,693
So, how you did it with that?

00:36:00,253 --> 00:36:02,590
- I also have one more comment.

00:36:04,390 --> 00:36:09,060
So the current API for queues is very limited.

00:36:09,060 --> 00:36:13,120
That's why we are doing all of those stuff

00:36:13,120 --> 00:36:18,100
and we probably will not be able to keep

00:36:18,100 --> 00:36:20,863
backwards compatibility in some places.

00:36:22,140 --> 00:36:27,070
Even if we try, there might be some cases

00:36:27,070 --> 00:36:32,070
where we are just unable to preserve the old interfaces,

00:36:33,740 --> 00:36:37,210
because they won't do the new stuff we need.

00:36:37,210 --> 00:36:42,210
One of the examples I saw in the slides is,

00:36:42,450 --> 00:36:45,273
for example, the AF_XDP bind API.

00:36:48,770 --> 00:36:53,177
If we try to support the bind call with a single qid,

00:36:54,950 --> 00:36:59,070
Magnus suggests to pick the correspondent Tx queue

00:36:59,070 --> 00:37:01,900
according to the irq number,

00:37:01,900 --> 00:37:05,740
but that's actually also challenging

00:37:05,740 --> 00:37:10,420
because we can have many of them, yes?

00:37:10,420 --> 00:37:12,154
- [Magnus] So, what we're doing today now,

00:37:12,154 --> 00:37:12,987
- [Dave] That's true already today.

00:37:12,987 --> 00:37:14,390
We have many of them and we,

00:37:14,390 --> 00:37:17,470
- Yeah, how we deal with it today

00:37:17,470 --> 00:37:21,820
is we have only one of them that has AF_XDP Tx queue

00:37:23,410 --> 00:37:24,560
in the channel,

00:37:24,560 --> 00:37:28,480
and if we just switch to some generic queue manager

00:37:28,480 --> 00:37:32,853
framework that creates five Tx queues,

00:37:34,100 --> 00:37:39,100
we cannot just pick some of them as AF_XDP queues.

00:37:40,970 --> 00:37:45,970
So why I'm talking about this is the main question.

00:37:49,220 --> 00:37:54,187
If it's acceptable to break such an APIs

00:37:55,430 --> 00:37:58,373
in order to move further,

00:38:00,420 --> 00:38:05,420
because I think if you don't do it in several places,

00:38:09,830 --> 00:38:14,450
then we will be stuck forever with old dinosaur interfaces

00:38:14,450 --> 00:38:17,763
that will not allow us to move further.

00:38:20,770 --> 00:38:24,660
- Wouldn't you need to use the new netlink alloc interfaces

00:38:24,660 --> 00:38:26,503
to even get into that situation?

00:38:28,450 --> 00:38:33,450
- I may, for example, use the netlink interface

00:38:34,180 --> 00:38:39,180
and then someone goes to duplicate the sysfs

00:38:39,220 --> 00:38:42,880
and tries to change something there,

00:38:42,880 --> 00:38:45,530
- Two applications that use two different interfaces.

00:38:46,750 --> 00:38:48,740
I think that's why it's so urgent that we fix this

00:38:48,740 --> 00:38:52,040
as fast as possible so there is less of those situations.

00:38:52,040 --> 00:38:54,410
I think we have to just say that

00:38:54,410 --> 00:38:56,783
if you start using the netlink queue alloc,

00:38:56,783 --> 00:38:58,190
then you're in this new world

00:38:58,190 --> 00:39:02,450
and that's the only kinda queue semantic we support.

00:39:02,450 --> 00:39:04,943
I think we have to put the line somewhere.

00:39:06,350 --> 00:39:07,860
- [Attendee] Isn't it also a case of if

00:39:07,860 --> 00:39:10,400
we can support the old one without,

00:39:10,400 --> 00:39:11,850
- That would be preferred,

00:39:11,850 --> 00:39:15,110
but if we can't, this is the demarcation line.

00:39:15,110 --> 00:39:16,010
That's my opinion.

00:39:17,543 --> 00:39:19,613
- I don't see the line for AF_XDP, for example.

00:39:19,613 --> 00:39:21,840
We already have some interface

00:39:23,650 --> 00:39:26,173
with a single queue bind.

00:39:29,170 --> 00:39:30,807
If introduced, the queue manager,

00:39:30,807 --> 00:39:33,710
and for example, some driver that supports it,

00:39:33,710 --> 00:39:36,880
does it mean that this driver will not support

00:39:36,880 --> 00:39:38,873
single parameter bind anymore?

00:39:40,510 --> 00:39:43,210
- The configuration of the queues by the driver

00:39:43,210 --> 00:39:45,190
without using any of the netlink interfaces

00:39:45,190 --> 00:39:47,960
should be identical to what you get right now

00:39:47,960 --> 00:39:50,400
and you would have to explicitly turn this queue manager

00:39:50,400 --> 00:39:52,410
thing on to allocate queues in a different way,

00:39:52,410 --> 00:39:55,853
I would suppose, if you wanted to do something like that.

00:39:57,082 --> 00:39:58,380
- [Attendee] If you keep the defaults.

00:39:58,380 --> 00:40:00,163
- Something like that, yeah.

00:40:03,980 --> 00:40:05,040
There are a lot of dependencies.

00:40:05,040 --> 00:40:09,000
So is the queue manager enabled?

00:40:09,000 --> 00:40:11,720
Does the device support the new queue allocation schemes?

00:40:11,720 --> 00:40:13,390
Therefore the queue manager would use it,

00:40:13,390 --> 00:40:15,640
and do we have applications that use loaded queue

00:40:15,640 --> 00:40:17,750
selection mechanism for AF_XDP.

00:40:17,750 --> 00:40:19,150
They're all inter-connected.

00:40:20,080 --> 00:40:21,930
- It looks like we are trying to preserve

00:40:21,930 --> 00:40:22,973
all the possible APIs

00:40:22,973 --> 00:40:26,200
and we will have an over-engineered system.

00:40:26,200 --> 00:40:29,120
- I think so and we'll have IPP6.

00:40:29,120 --> 00:40:31,370
(laughing)

00:40:32,480 --> 00:40:33,313
Sorry.

00:40:33,313 --> 00:40:34,470
Okay, it's definitely something we should take

00:40:34,470 --> 00:40:35,463
into consideration.

00:40:37,000 --> 00:40:38,970
I think we have time for one more question.

00:40:38,970 --> 00:40:40,900
- Yeah, I had one more slide but that doesn't matter.

00:40:40,900 --> 00:40:42,513
One more question is better, so.

00:40:43,810 --> 00:40:45,628
- He says one more question is better.

00:40:45,628 --> 00:40:47,878
(laughing)

00:40:49,410 --> 00:40:53,490
- My take on this, like first observation.

00:40:53,490 --> 00:40:55,250
When you've been talking that these two

00:40:55,250 --> 00:40:56,670
can change the queues,

00:40:56,670 --> 00:40:58,560
it's not only changing the queues,

00:40:58,560 --> 00:41:00,710
it's changing their assess,

00:41:00,710 --> 00:41:03,280
so whereas in the new API, you're saying,

00:41:03,280 --> 00:41:04,580
well, I'll allocate in the queue,

00:41:04,580 --> 00:41:06,497
but you say nothing about RSS.

00:41:07,970 --> 00:41:12,260
So I think to me this new API for allocation,

00:41:12,260 --> 00:41:15,810
allocation queues, need to come with, well,

00:41:15,810 --> 00:41:17,650
caress point in RSS,

00:41:17,650 --> 00:41:19,160
configuration in everything else

00:41:19,160 --> 00:41:24,160
because especially at least to address current limitations

00:41:24,220 --> 00:41:26,520
we have for reddit in that RSS

00:41:26,520 --> 00:41:28,200
where there is only one spring,

00:41:28,200 --> 00:41:31,920
whereas hardware actually supports multi-spring stuff

00:41:31,920 --> 00:41:35,010
where we can match and then spray to multiple queues,

00:41:35,010 --> 00:41:38,320
and if it's part of this API,

00:41:38,320 --> 00:41:40,437
somehow you didn't mention in the slides.

00:41:40,437 --> 00:41:43,150
- No, actually, that was one of the things to say,

00:41:43,150 --> 00:41:44,853
let's make it simple, not to consider that

00:41:44,853 --> 00:41:46,000
at this point in time,

00:41:46,000 --> 00:41:47,281
but you're right,

00:41:47,281 --> 00:41:49,097
(attendee laughing)

00:41:49,097 --> 00:41:51,947
- [Dave] But, yeah, we also want to, yeah, improve on RSS

00:41:54,360 --> 00:41:57,060
with this interface to sort of get better programmability

00:41:57,060 --> 00:41:59,180
of steering.

00:41:59,180 --> 00:42:02,960
- So, if RSS, then what about in tuple filtering

00:42:02,960 --> 00:42:05,200
and other queue selection mechanisms that we have.

00:42:05,200 --> 00:42:07,260
- Yeah, exactly, we want it all.

00:42:07,260 --> 00:42:09,140
We need the in tuple stuff to work, right?

00:42:09,140 --> 00:42:11,060
Because we want to be able to direct traffic.

00:42:11,060 --> 00:42:13,890
We're using hardware filters and stuff like that,

00:42:13,890 --> 00:42:15,800
so that's something else to take into consideration.

00:42:15,800 --> 00:42:17,517
- Yeah, of course.

00:42:17,517 --> 00:42:19,363
It just becomes really big.

00:42:20,883 --> 00:42:23,190
- [Dave] But once we have an interface to refer to

00:42:23,190 --> 00:42:24,023
this is a queue,

00:42:24,023 --> 00:42:25,270
we can then use that,

00:42:25,270 --> 00:42:28,910
identify it to program the hardware steering packet

00:42:28,910 --> 00:42:32,360
into that queue once we can identify it and refer to it.

00:42:32,360 --> 00:42:33,780
- [Dave] Okay, let's stop while we're ahead

00:42:33,780 --> 00:42:36,070
before new problems get this aborted.

00:42:36,070 --> 00:42:37,375
Thank you, Magnus, very much.

00:42:37,375 --> 00:42:38,208

YouTube URL: https://www.youtube.com/watch?v=k6cZHU-J46E


