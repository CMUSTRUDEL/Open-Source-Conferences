Title: LPC2019 - BPF packet capture helpers, libbpf interfaces
Publication date: 2019-11-18
Playlist: LPC2019 - Networking Summit Track
Description: 
	BPF packet capture helpers, libbpf interfaces

Packet capture is useful from a general debugging standpoint, and is useful in particular in debugging BPF programs that do packet processing. For general debugging, being able to initiate arbitrary packet capture from kprobes and tracepoints is highly valuable (e.g. what do the packets that reach kfree_skb() - representing error codepaths - look like?). Arbitrary packet capture is distinct from the traditional concept of pre-defined hooks, and gives much more flexibility in probing system behaviour. For packet-processing BPF programs, packet capture can be useful for doing things such as debugging checksum errors. The intent of this proposal is to help drive discussion around how to ease use of such features in BPF programs, namely:

should additional BPF helper(s) be provided to format packet data suitable for libpcap interpretation?
should libbpf provide interfaces for retrieving packet capture data?
should interfaces be provided for pushing filters?
Note that while there has been some work in this area already, such as

https://new.blog.cloudflare.com/xdpcap/

...it seems like such efforts would be made much simpler if APIs were provided.
Captions: 
	00:00:00,760 --> 00:00:04,060
- The next talk is an area that I'm kinda actually

00:00:04,060 --> 00:00:05,453
very concerned with.

00:00:06,530 --> 00:00:09,563
As we have multiple pieces of technology,

00:00:10,700 --> 00:00:14,690
not just a normal networking data path process packets,

00:00:14,690 --> 00:00:17,440
it's important that we have well-documented

00:00:17,440 --> 00:00:21,420
and easy-to-use ways to capture packets.

00:00:21,420 --> 00:00:23,980
This includes normal networking path,

00:00:23,980 --> 00:00:27,330
BPF-based technologies like XTP and hardware offloading

00:00:27,330 --> 00:00:29,150
like switches and stuff like that.

00:00:29,150 --> 00:00:32,650
So I hope that as we develop

00:00:32,650 --> 00:00:33,970
different pieces of infrastructure

00:00:33,970 --> 00:00:36,010
we can solve this problem in a reasonable way.

00:00:36,010 --> 00:00:39,140
And I'd like the microphone to Alan Maguire,

00:00:39,140 --> 00:00:41,090
who's working on BPF packet capture

00:00:41,090 --> 00:00:42,210
and infrastructure for that.

00:00:42,210 --> 00:00:44,500
So please give a round of applause for Alan.

00:00:44,500 --> 00:00:47,667
(audience applauding)

00:00:48,700 --> 00:00:50,720
- Okay, can you hear me okay guys?

00:00:50,720 --> 00:00:51,553
- Yeah. - Yeah?

00:00:51,553 --> 00:00:53,350
So what we're gonna be doing is sprinkling a bit

00:00:53,350 --> 00:00:56,510
of BPF magic on the process of tapping packets

00:00:56,510 --> 00:00:58,523
for observability, so that's the plan.

00:00:59,940 --> 00:01:02,170
So first of all we'll talk a little bit

00:01:02,170 --> 00:01:04,540
about the roots of BPF, which I think have often

00:01:04,540 --> 00:01:05,973
been covered before.

00:01:06,880 --> 00:01:09,110
So BPFV was kind of born in a time of crisis.

00:01:09,110 --> 00:01:11,720
So the founding of this work

00:01:11,720 --> 00:01:14,270
was at the Lawrence Berkeley National Labs team.

00:01:14,270 --> 00:01:16,080
The network research Group there were diagnosing

00:01:16,080 --> 00:01:19,190
and fixing the congestion collapse of the ARPAnet

00:01:19,190 --> 00:01:21,420
and the tools of the day weren't really up to scratch

00:01:21,420 --> 00:01:23,170
and they didn't do much in the way of protocol,

00:01:23,170 --> 00:01:24,343
decoding or filtering.

00:01:25,250 --> 00:01:26,083
So some of the tools they built,

00:01:26,083 --> 00:01:29,300
there's a great presentation by Steve McCann,

00:01:29,300 --> 00:01:32,110
who's one of the co-authors on the original BPF paper

00:01:32,110 --> 00:01:34,590
and there's one slide in that which is kind of stunning.

00:01:34,590 --> 00:01:37,850
It's a list of all the different technologies they worked on

00:01:37,850 --> 00:01:39,430
and all the tools they built.

00:01:39,430 --> 00:01:40,790
Some of the examples are TCPDUMP/LIBPCAP

00:01:40,790 --> 00:01:42,233
traceroute and path chart.

00:01:43,750 --> 00:01:45,380
A lot of these tools dated from the late '80s

00:01:45,380 --> 00:01:47,290
and whenever technology endures it's impressive,

00:01:47,290 --> 00:01:48,860
but the amount of technology that they built

00:01:48,860 --> 00:01:50,493
is really stunning.

00:01:52,220 --> 00:01:54,820
It's worth mentioning actually in a sort of sad note

00:01:55,741 --> 00:01:58,430
about that team, that Sally Floyd passed away.

00:01:58,430 --> 00:02:00,410
She was one of the pioneers in that team.

00:02:00,410 --> 00:02:03,930
She invented the RED detection algorithm.

00:02:03,930 --> 00:02:07,050
And one paper of hers I think is fantastic,

00:02:07,050 --> 00:02:07,883
it's really worth a read

00:02:07,883 --> 00:02:10,010
and it's real model of communication,

00:02:10,010 --> 00:02:12,500
which is always difficult in our field,

00:02:12,500 --> 00:02:14,463
is, what's the paper called now?

00:02:15,640 --> 00:02:19,133
I think it's called Why Simulating the Internet is Hard.

00:02:20,050 --> 00:02:23,250
When you look through that paper, the introduction,

00:02:23,250 --> 00:02:24,980
you could give that to someone who knew nothing

00:02:24,980 --> 00:02:26,690
about internet technology and within five minutes

00:02:26,690 --> 00:02:29,840
they'd understand a lot of the core ideas in our field.

00:02:29,840 --> 00:02:32,890
I think it's a real tribute to her ability as a teacher.

00:02:32,890 --> 00:02:35,610
So what we're gonna be talking about a bit more today though

00:02:35,610 --> 00:02:37,920
is the paper by McCann and Jacobson,

00:02:37,920 --> 00:02:39,993
which is the origins of the BPF work.

00:02:40,890 --> 00:02:43,870
Obviously one of the challenges they faced

00:02:43,870 --> 00:02:45,608
was they wanted to observe traffic,

00:02:45,608 --> 00:02:47,240
but they didn't want to look at all of it,

00:02:47,240 --> 00:02:49,470
so in that case you wanna filter traffic.

00:02:49,470 --> 00:02:50,640
You wanna do that in the kernel though

00:02:50,640 --> 00:02:53,910
because you don't want that overhead of user space copy.

00:02:53,910 --> 00:02:55,380
So we wanted to have a flexible way

00:02:55,380 --> 00:02:57,580
of describing that filtering process

00:02:57,580 --> 00:03:00,380
and we wanted to inject that description into the kernel.

00:03:00,380 --> 00:03:01,900
So that's called classic BPF

00:03:01,900 --> 00:03:04,300
and this is one of the things that happens when you get old.

00:03:04,300 --> 00:03:06,610
People start calling things classic and retro.

00:03:06,610 --> 00:03:08,790
We even get vintage in some of the stuff

00:03:08,790 --> 00:03:10,810
that I just think of as the thing.

00:03:10,810 --> 00:03:13,250
It's like all these adjectives are popping up all the time.

00:03:13,250 --> 00:03:14,480
It's kinda frightening.

00:03:14,480 --> 00:03:17,550
So yeah, the idea is once these filters are injected

00:03:17,550 --> 00:03:20,017
a simple virtual machine will run the instructions in-kernel

00:03:20,017 --> 00:03:21,580
and the key thing is safety.

00:03:21,580 --> 00:03:23,400
So all programs must complete in bounded time,

00:03:23,400 --> 00:03:27,080
so there's no loops, no backward branching.

00:03:27,080 --> 00:03:31,210
So you can see classic BPF today if you run tcpdump

00:03:31,210 --> 00:03:33,230
with a d option to dump out the information

00:03:33,230 --> 00:03:35,220
and you can see how all of that looks.

00:03:35,220 --> 00:03:36,930
For just a simple filter like tcp, there's a couple

00:03:36,930 --> 00:03:39,670
of different cases here, like IPv4 and IPv6.

00:03:39,670 --> 00:03:41,290
And you'll notice some of the magic numbers there

00:03:41,290 --> 00:03:43,423
that'll probably help orient you to that.

00:03:44,310 --> 00:03:45,500
But of course we need something to filter.

00:03:45,500 --> 00:03:46,993
So in the original BPF paper,

00:03:47,950 --> 00:03:50,390
Jackson and McCann talk about the tap and the filter.

00:03:50,390 --> 00:03:53,080
So the tap is the source of the packets.

00:03:53,080 --> 00:03:55,740
Now we've had this eBPF revolution in the last

00:03:55,740 --> 00:03:56,930
couple of years which was a little bit

00:03:56,930 --> 00:03:58,440
taking that filtering language,

00:03:58,440 --> 00:03:59,840
extending it and expanding it

00:03:59,840 --> 00:04:01,100
to all these different use cases

00:04:01,100 --> 00:04:04,520
like XDP for fast pocket processing,

00:04:04,520 --> 00:04:07,070
tracing for kprobes and so much more.

00:04:07,070 --> 00:04:08,830
So similarly, here we're gonna be going back

00:04:08,830 --> 00:04:10,360
to that original paper and try to extend

00:04:10,360 --> 00:04:12,700
that concept of a tap from a fixed point in the kernel

00:04:12,700 --> 00:04:13,770
to something a bit more dynamic,

00:04:13,770 --> 00:04:16,260
using BPF as the means to do so.

00:04:16,260 --> 00:04:18,050
So I'll just give a quick rundown

00:04:18,050 --> 00:04:19,700
on how the tap works today.

00:04:19,700 --> 00:04:23,240
So this is, if we look at the libpcap code,

00:04:23,240 --> 00:04:24,967
you can see some of this code there

00:04:24,967 --> 00:04:26,280
and the kernel size described

00:04:26,280 --> 00:04:29,040
in the packet MMAP documentation.

00:04:29,040 --> 00:04:31,990
So we open a PF packet/raw socket bind

00:04:31,990 --> 00:04:33,740
using a link-layer address socket

00:04:33,740 --> 00:04:35,790
with the interface index and the interface

00:04:35,790 --> 00:04:37,170
we're trying to snoop on.

00:04:37,170 --> 00:04:41,830
And from there, the kernel will actually

00:04:41,830 --> 00:04:44,720
register some callbacks for when we send and receive traffic

00:04:44,720 --> 00:04:47,360
and that's how our traffic gets up

00:04:47,360 --> 00:04:49,920
to our socket that we're observing on.

00:04:49,920 --> 00:04:53,320
On the userspace side, we build a packet MMAP

00:04:53,320 --> 00:04:55,960
which is a shared kernel/userspace buffer.

00:04:55,960 --> 00:04:58,470
And the big thing about this is that we don't wanna

00:04:58,470 --> 00:05:00,560
generate a system call every time you wanna read a packet.

00:05:00,560 --> 00:05:04,070
So when we have the shared buffer we can poll on that buffer

00:05:04,070 --> 00:05:06,600
and then read multiple packets at the same time.

00:05:06,600 --> 00:05:09,100
So I've given a couple of references there to the code

00:05:09,100 --> 00:05:11,013
so you can see how that's done for libpcap.

00:05:12,589 --> 00:05:14,680
So the problem is that these days

00:05:14,680 --> 00:05:17,130
there's a lot of things going on in the networking stack.

00:05:17,130 --> 00:05:18,770
We have generic segmentation offload

00:05:18,770 --> 00:05:21,330
where we take a mega packet, pass it to the stack,

00:05:21,330 --> 00:05:23,403
and then chop it off at the last minute

00:05:23,403 --> 00:05:25,370
to minimize overheads.

00:05:25,370 --> 00:05:27,240
And then GRO generic receive offload

00:05:27,240 --> 00:05:29,800
where we do the opposite, we put it back together.

00:05:29,800 --> 00:05:30,730
There's also BPF.

00:05:30,730 --> 00:05:33,530
Obviously we're modifying packets in BPF these days too.

00:05:34,420 --> 00:05:35,253
And when we're dropping traffic,

00:05:35,253 --> 00:05:36,440
the packet may not even reach the tap,

00:05:36,440 --> 00:05:38,510
so if we're dropping on the outband path.

00:05:38,510 --> 00:05:41,700
So what that all kind of adds up to is when we're debugging

00:05:41,700 --> 00:05:43,430
there's no one right answer to the question:

00:05:43,430 --> 00:05:45,660
where is the best place to observe packets?

00:05:45,660 --> 00:05:48,255
So some people wanna see the drops at kfree skb

00:05:48,255 --> 00:05:50,370
and the error code path drops.

00:05:50,370 --> 00:05:52,490
Some people are gonna wanna see packets before

00:05:52,490 --> 00:05:55,120
GSO segmentations, some wanna see them after,

00:05:55,120 --> 00:05:58,193
and some wanna see them before or after GRO reassembly too.

00:05:59,100 --> 00:06:04,100
So what I'm suggesting is, yeah, so just a bit of general

00:06:05,190 --> 00:06:06,930
information on how BPF does things.

00:06:06,930 --> 00:06:09,943
So it uses helper functions to carry out tasks.

00:06:10,780 --> 00:06:12,340
Particularly in communication userspace

00:06:12,340 --> 00:06:15,280
we've got a bpf trace printk, which is essentially

00:06:15,280 --> 00:06:16,950
printk for BPF programs.

00:06:16,950 --> 00:06:19,030
We've got maps which are a way for user space

00:06:19,030 --> 00:06:21,740
and the kernel to communicate, share configuration.

00:06:21,740 --> 00:06:24,420
We can take stats, we can record stats in those maps.

00:06:24,420 --> 00:06:26,280
And then we got, for our purposes, the interesting one,

00:06:26,280 --> 00:06:27,770
which is bpf perf event output.

00:06:27,770 --> 00:06:30,710
So that allows us to record metadata and information

00:06:30,710 --> 00:06:32,233
in BPF programs.

00:06:33,485 --> 00:06:37,206
And that particular helper works for skb programs,

00:06:37,206 --> 00:06:39,623
so like tc, the tc subsystem,

00:06:40,636 --> 00:06:43,140
xdp programs and tracing problems as well.

00:06:43,140 --> 00:06:48,140
And in fact, xdpcap uses perf events to capture from xdp.

00:06:48,260 --> 00:06:50,383
So you can do a little bit of that already.

00:06:51,690 --> 00:06:55,000
So similarly, to the case with the packet MMAP,

00:06:55,000 --> 00:06:56,010
these perf events are written

00:06:56,010 --> 00:06:58,207
to an MMAP'ed shared buffer with userspace.

00:06:59,268 --> 00:07:00,330
And we can poll for updates

00:07:00,330 --> 00:07:02,090
and read multiple events simultaneously

00:07:02,090 --> 00:07:04,790
in a similar way without invoking all those overheads.

00:07:06,058 --> 00:07:08,470
So what I'm suggesting is we use the same mechanism

00:07:08,470 --> 00:07:10,200
for the bpf pcap helper.

00:07:10,200 --> 00:07:13,160
So a helper to be specific to do in packet capture.

00:07:13,160 --> 00:07:15,700
In this case, rather than letting the user specify

00:07:15,700 --> 00:07:18,150
the metadata will specify theirselves

00:07:18,150 --> 00:07:19,580
and will specify the information you need

00:07:19,580 --> 00:07:21,160
to actually capture that data.

00:07:21,160 --> 00:07:24,270
So it's the protocol type, the packet length

00:07:24,270 --> 00:07:25,990
and the capture length, and the capture time.

00:07:25,990 --> 00:07:28,280
And then the data is the packet itself.

00:07:28,280 --> 00:07:31,060
And as is the case for the bpf perf event output helper,

00:07:31,060 --> 00:07:34,670
I'd suggest we support for xdp, skb, and tracing programs.

00:07:34,670 --> 00:07:36,360
But the tracing case is the real interesting case

00:07:36,360 --> 00:07:39,163
because that's the one we can't do as well today.

00:07:40,180 --> 00:07:43,230
So that's the sort of function signature I'm suggesting.

00:07:43,230 --> 00:07:46,030
So the first argument is the context of the program

00:07:46,030 --> 00:07:47,910
in the case of skb and xdp program,

00:07:47,910 --> 00:07:52,560
so that's our struct sk buff or our xdp metadata.

00:07:52,560 --> 00:07:54,710
For the tracing programs, it's gonna be a pointer

00:07:54,710 --> 00:07:58,310
to an sk buff that would be derived from the kprobe context.

00:07:58,310 --> 00:07:59,530
So that would be the arguments

00:07:59,530 --> 00:08:01,520
to whatever kernel function it is

00:08:01,520 --> 00:08:03,373
or the raw tracepoint arguments.

00:08:04,750 --> 00:08:09,620
So, for example, if we code bpf pcap with the PT REGS PARM1,

00:08:09,620 --> 00:08:12,680
that gives us the skb data pointed to by the first argument

00:08:12,680 --> 00:08:14,360
to the function we're kprobe-ing.

00:08:15,650 --> 00:08:17,680
So then the second argument is the maximum length.

00:08:17,680 --> 00:08:19,100
So one of the things you have to do with libpcap

00:08:19,100 --> 00:08:20,690
is when you're opening a captured file

00:08:20,690 --> 00:08:22,730
you have to specific what the maximum length

00:08:22,730 --> 00:08:26,280
of the captured packet is gonna be.

00:08:26,280 --> 00:08:29,440
So this allows us to limit the amount of data we capture.

00:08:29,440 --> 00:08:31,840
The third argument is the map which is the perf event map

00:08:31,840 --> 00:08:34,670
that we set up in userspace with a bunch of MMAP buffers

00:08:34,670 --> 00:08:36,650
and that's what allows us to communicate,

00:08:36,650 --> 00:08:38,930
send our packet to the right place.

00:08:38,930 --> 00:08:41,560
And then protocol is important because

00:08:41,560 --> 00:08:44,230
if we're moving to this more dynamic model,

00:08:44,230 --> 00:08:47,380
we need to tell libpcap what the starting protocol

00:08:47,380 --> 00:08:48,570
we're dealing with is.

00:08:48,570 --> 00:08:50,810
So if we're going to enter the networking stack,

00:08:50,810 --> 00:08:52,750
we may not have appended a Layer-2 header yet

00:08:52,750 --> 00:08:55,450
so we need to tell it we're capturing at the IP layer.

00:08:56,910 --> 00:08:58,500
So that starting protocol is very important.

00:08:58,500 --> 00:09:00,680
So the values for that are the same values

00:09:00,680 --> 00:09:02,437
that are used on the pcap.

00:09:02,437 --> 00:09:05,620
And I think there's a pcap-linktype manual page

00:09:05,620 --> 00:09:06,950
you can look up to see what those are.

00:09:06,950 --> 00:09:10,050
But we have, there's values for layer too for Ethernet,

00:09:10,050 --> 00:09:11,380
there's values for raw IP which can be

00:09:11,380 --> 00:09:13,793
IPv4 and IPv6, et cetera.

00:09:14,650 --> 00:09:16,170
And then flags is the final argument.

00:09:16,170 --> 00:09:18,550
So one of the things I'm suggesting here is that

00:09:18,550 --> 00:09:21,520
we reserve about 48 bits of the flags for an identifier,

00:09:21,520 --> 00:09:24,070
which, and the point of that is that

00:09:24,070 --> 00:09:26,330
it would allow us to associate other tracing data

00:09:26,330 --> 00:09:28,420
with the captured packet in userspace if needed.

00:09:28,420 --> 00:09:30,520
So that could be a network namespace ID,

00:09:30,520 --> 00:09:33,260
a process ID, or an index into a stackmap.

00:09:33,260 --> 00:09:36,000
So the stackmaps allow us to capture stack traces

00:09:36,000 --> 00:09:37,730
in an efficient manner.

00:09:37,730 --> 00:09:40,250
And we can use other bits then to identify

00:09:40,250 --> 00:09:42,777
what that identifier is effectively as well.

00:09:42,777 --> 00:09:44,320
You don't wanna take the process too far.

00:09:44,320 --> 00:09:47,150
Obviously, you wanna give people a way to use that

00:09:47,150 --> 00:09:49,830
identifier in a freeform manner as well.

00:09:49,830 --> 00:09:53,560
But having a couple of particular identifier flags

00:09:53,560 --> 00:09:54,393
would be useful.

00:09:54,393 --> 00:09:55,660
So, for example, another case would be

00:09:55,660 --> 00:09:57,560
if we're capturing from function entry

00:09:57,560 --> 00:09:59,750
or return or from trace points,

00:09:59,750 --> 00:10:02,610
we don't have a network interface associated with that

00:10:02,610 --> 00:10:05,330
in the same ways we do when we capture on a specific device.

00:10:05,330 --> 00:10:08,420
So one option there would be to specify

00:10:08,420 --> 00:10:11,120
an interface index that we carry by capturing from

00:10:11,120 --> 00:10:12,350
and then the capture wouldn't happen

00:10:12,350 --> 00:10:16,130
if it didn't match that index.

00:10:16,130 --> 00:10:18,600
So another thing you can do with that pcap header,

00:10:18,600 --> 00:10:21,160
which is what we use as the metadata for the perf event,

00:10:21,160 --> 00:10:24,380
is use it for, oh sorry, I should first say,

00:10:24,380 --> 00:10:25,213
yeah, what that is.

00:10:25,213 --> 00:10:29,560
So the pcap header contain a magic number which allows us,

00:10:29,560 --> 00:10:31,730
when we're handling those perf events and userspace

00:10:31,730 --> 00:10:33,090
we wanna be able to identify

00:10:33,090 --> 00:10:35,090
that it is actually a pcap event.

00:10:35,090 --> 00:10:36,540
So that magic number does that.

00:10:36,540 --> 00:10:39,000
And then we have our starting protocol,

00:10:39,000 --> 00:10:40,880
the ID value, which is from the flags value

00:10:40,880 --> 00:10:42,980
which we specified within the BPF program,

00:10:44,250 --> 00:10:45,300
and then we have the packet length

00:10:45,300 --> 00:10:46,290
and the amount of data captured,

00:10:46,290 --> 00:10:48,510
and the time of capture as well.

00:10:50,210 --> 00:10:52,300
And that header can also be used in BPF programs

00:10:52,300 --> 00:10:53,470
to specify configurations.

00:10:53,470 --> 00:10:55,330
So you can imagine a case where you wouldn't

00:10:55,330 --> 00:10:56,650
wanna hardcode all the information

00:10:56,650 --> 00:10:57,930
about what protocols you're dealing with.

00:10:57,930 --> 00:11:02,580
So, for example, if you're tracing kfree skb,

00:11:02,580 --> 00:11:04,650
you can be freeing at different levels of the stack.

00:11:04,650 --> 00:11:06,290
So the starting protocol,

00:11:06,290 --> 00:11:08,730
which is what the skb data points to,

00:11:08,730 --> 00:11:11,130
could be IP or could be Layer-2.

00:11:11,130 --> 00:11:13,100
So if you wanted to configure that

00:11:13,100 --> 00:11:14,670
dynamically with your BPF program,

00:11:14,670 --> 00:11:18,440
you could use an array map with a BPF header,

00:11:18,440 --> 00:11:21,820
with this bpf pcap hdr and you could specify all that stuff.

00:11:21,820 --> 00:11:23,860
So you could specify, I care about IP in this case

00:11:23,860 --> 00:11:27,313
and I care about having packets up to this length.

00:11:28,310 --> 00:11:29,620
So it contains all the information

00:11:29,620 --> 00:11:30,970
we need to do that specification

00:11:30,970 --> 00:11:33,990
so it can be reused as a configuration

00:11:33,990 --> 00:11:37,270
that we push in to into our filters as well.

00:11:37,270 --> 00:11:38,480
So here's a code example.

00:11:38,480 --> 00:11:41,080
So I've omitted the headers, but otherwise

00:11:41,080 --> 00:11:43,190
this is a full BPF program.

00:11:43,190 --> 00:11:47,560
So we're trying to capture from a kprobe,

00:11:47,560 --> 00:11:50,010
we're capturing the first argument to that function

00:11:50,010 --> 00:11:52,670
and we're using that perf event map there,

00:11:52,670 --> 00:11:55,123
we're allocating a perf event map for,

00:11:55,123 --> 00:11:57,330
and that's gonna be populated in userspace

00:11:57,330 --> 00:12:01,070
with all of the descriptors for the MMAP areas.

00:12:01,070 --> 00:12:04,350
And we're capturing at the IP layer as well.

00:12:04,350 --> 00:12:06,947
So that's pretty straightforward, so.

00:12:06,947 --> 00:12:08,480
But the other part of this is of course

00:12:08,480 --> 00:12:10,870
if we're capturing all this, we've gotta actually,

00:12:10,870 --> 00:12:11,703
we've gotta catch it in userspace.

00:12:11,703 --> 00:12:14,610
So we've gotta deal with that side of things too.

00:12:14,610 --> 00:12:18,480
So to that end, I've been trying to think of ways

00:12:18,480 --> 00:12:20,130
to simplify that process as well,

00:12:20,130 --> 00:12:22,440
so I'm suggesting one way to that

00:12:22,440 --> 00:12:25,690
might be to actually do that within bpftool itself.

00:12:25,690 --> 00:12:27,340
So bpftool describes itself as a tool

00:12:27,340 --> 00:12:30,393
for inspecting and manipulating eBPF programs and maps.

00:12:31,446 --> 00:12:32,840
And the focus is being able to help

00:12:32,840 --> 00:12:34,240
and help debug your programs.

00:12:34,240 --> 00:12:36,113
So packet capture can help with that.

00:12:37,000 --> 00:12:39,640
One of the areas that I've used this quite a bit for

00:12:39,640 --> 00:12:43,660
is tracing checksum errors in BPF programs.

00:12:43,660 --> 00:12:47,540
So if you do any BPF work with packet manipulation,

00:12:47,540 --> 00:12:49,620
you often end-use checksum errors.

00:12:49,620 --> 00:12:50,640
So one of the things you can do

00:12:50,640 --> 00:12:52,950
if you have a packet capture is you can run

00:12:54,168 --> 00:12:57,840
tcpdump or you can run Wireshark in checksum mode.

00:12:58,780 --> 00:13:00,620
So it will actually tell you what the checksum was

00:13:00,620 --> 00:13:01,453
and what it should've been.

00:13:01,453 --> 00:13:03,750
So it's a good way to debug things.

00:13:03,750 --> 00:13:05,580
So what I'm suggesting is we add a new subcommand

00:13:05,580 --> 00:13:06,613
to pcap to bpftool.

00:13:08,967 --> 00:13:11,370
But that would require libpcap and headers.

00:13:11,370 --> 00:13:14,610
So I think that we need an additional feature test

00:13:14,610 --> 00:13:16,590
for that as well to ensure that they're there.

00:13:16,590 --> 00:13:18,760
So if those features are there,

00:13:18,760 --> 00:13:20,260
we can compile all that stuff in.

00:13:20,260 --> 00:13:22,903
If not, then we're stuck.

00:13:23,908 --> 00:13:25,500
So those two modes that I'm suggesting,

00:13:25,500 --> 00:13:28,392
that this pcap program could work,

00:13:28,392 --> 00:13:30,150
this pcap subcommand could work in,

00:13:30,150 --> 00:13:32,240
so one would be to actually give it a program

00:13:32,240 --> 00:13:36,640
to capture from and then protocols specified in length.

00:13:36,640 --> 00:13:38,980
So it would scan that program for the perf event map

00:13:38,980 --> 00:13:42,290
and create all-around maps and populate that perf event map.

00:13:42,290 --> 00:13:44,297
If there's a map contain configurations,

00:13:44,297 --> 00:13:46,880
remember, I said that we have an array map

00:13:46,880 --> 00:13:48,025
with one of those pcap headers

00:13:48,025 --> 00:13:49,590
and where we can tell which protocols we care about

00:13:49,590 --> 00:13:52,240
and that can populate that too,

00:13:52,240 --> 00:13:53,430
then it opens up the pcapdump

00:13:53,430 --> 00:13:56,650
and then polls for perf events and dumps packets.

00:13:56,650 --> 00:13:58,780
So similarly, we can do the same thing

00:13:58,780 --> 00:14:00,483
for tracing programs as well.

00:14:01,830 --> 00:14:04,320
So the idea here is that we actually

00:14:04,320 --> 00:14:05,990
rather than dealing with an existing program

00:14:05,990 --> 00:14:09,270
that's already loaded, we load and attach probes

00:14:09,270 --> 00:14:10,640
for this particular program.

00:14:10,640 --> 00:14:13,110
So you can specify an object yourself

00:14:13,110 --> 00:14:14,290
and the tracing program yourself

00:14:14,290 --> 00:14:16,070
and then specify if you care about kprobes

00:14:16,070 --> 00:14:18,420
or trace points, which probes you're interested in

00:14:18,420 --> 00:14:20,240
and which arguments you wanna capture.

00:14:20,240 --> 00:14:23,830
And then all the usual stuff about protocols and devices.

00:14:23,830 --> 00:14:26,710
So one additional thing I'm suggesting here

00:14:26,710 --> 00:14:31,530
is that we supply a kprobe and a trace point object as well.

00:14:31,530 --> 00:14:33,240
And the idea behind that is that you get

00:14:33,240 --> 00:14:34,410
some out-of-the-box functionality.

00:14:34,410 --> 00:14:38,670
So rather than actually specify an object in this case,

00:14:38,670 --> 00:14:41,950
we use that functionality out-of-the-box

00:14:41,950 --> 00:14:43,440
to actually capture packets.

00:14:43,440 --> 00:14:44,990
So there's an example out here.

00:14:45,940 --> 00:14:47,510
So in this case, we're tracing packets

00:14:47,510 --> 00:14:49,920
that are dropped at kfree skb.

00:14:49,920 --> 00:14:51,900
We just induce an iptables DROP rule

00:14:51,900 --> 00:14:53,260
and then we're just gonna trigger to see them.

00:14:53,260 --> 00:14:56,440
So you can see here we haven't specified a BPF object here,

00:14:56,440 --> 00:14:59,580
so our default object kicks in.

00:14:59,580 --> 00:15:02,980
We attach our program to the probe point that we specified

00:15:02,980 --> 00:15:04,990
and then we can capture to the capture file

00:15:04,990 --> 00:15:08,482
and then we can look at that with wireshark as well.

00:15:08,482 --> 00:15:11,550
And the other option is we can actually just pipe,

00:15:11,550 --> 00:15:13,070
by default, it sends output to (mumbles),

00:15:13,070 --> 00:15:16,030
so we can just pipe the output to tcpdump as well.

00:15:16,030 --> 00:15:18,762
So that's an example of tracing a kprobe,

00:15:18,762 --> 00:15:21,480
at one of the WiFi scan functions

00:15:21,480 --> 00:15:24,130
so we can see the scan information coming back there.

00:15:25,790 --> 00:15:29,730
So that's a sort of suggestion how we can approach this.

00:15:29,730 --> 00:15:33,980
So future work built on that would be to add this packet

00:15:33,980 --> 00:15:36,370
capture support to BPF tracing programs.

00:15:36,370 --> 00:15:39,250
I mean, what this gives you is the what.

00:15:39,250 --> 00:15:40,650
So this tells you what the packet looks like.

00:15:40,650 --> 00:15:42,110
But you also need the why.

00:15:42,110 --> 00:15:43,830
So if you have stack traces,

00:15:43,830 --> 00:15:45,170
if you have other information,

00:15:45,170 --> 00:15:47,720
you can marry those two pieces of information together

00:15:47,720 --> 00:15:49,003
and that can be useful.

00:15:50,080 --> 00:15:52,950
One other area that would be worth looking at

00:15:52,950 --> 00:15:54,810
is adding pcap-ng support.

00:15:54,810 --> 00:15:57,560
So pcap-ng is a packet capture format

00:15:57,560 --> 00:15:59,300
that's been around for a little while now.

00:15:59,300 --> 00:16:01,330
And one of the nice things about that format

00:16:01,330 --> 00:16:03,090
is it allows the mixing of protocol types.

00:16:03,090 --> 00:16:06,110
So the lpcap format you're stuck with one protocol type

00:16:06,110 --> 00:16:07,640
for the whole file.

00:16:07,640 --> 00:16:09,020
Whereas, if you imagine, if we're tracing

00:16:09,020 --> 00:16:11,850
at kfree skb, for example, we're gonna get packets

00:16:11,850 --> 00:16:13,140
at different levels of the stack.

00:16:13,140 --> 00:16:16,080
So having that mixing of protocol types is useful there.

00:16:16,080 --> 00:16:19,070
And the other thing that pcap-ng allows

00:16:19,070 --> 00:16:21,200
is it allows you to add annotations and comments.

00:16:21,200 --> 00:16:23,260
So you could imagine creating a capture file

00:16:23,260 --> 00:16:26,060
with stack traces or other information as well.

00:16:26,060 --> 00:16:27,740
So marrying those two pieces of information together

00:16:27,740 --> 00:16:29,540
in the capture file would be useful.

00:16:30,980 --> 00:16:32,480
So filtering is the other piece of this.

00:16:32,480 --> 00:16:34,420
Obviously, we have our tap but we don't have our filter

00:16:34,420 --> 00:16:35,480
in this environment.

00:16:35,480 --> 00:16:38,733
So that's something we need to think about moving forward.

00:16:39,570 --> 00:16:42,350
So it would be useful to have a mechanism

00:16:42,350 --> 00:16:44,307
to enable filters, to be able to specify filters

00:16:44,307 --> 00:16:45,993
for our program before capturing.

00:16:47,110 --> 00:16:48,450
It might be worth investing in if we can use

00:16:48,450 --> 00:16:51,830
bpf2bpf calls or have a helper program function

00:16:51,830 --> 00:16:54,220
that we can evaluate the results of a filter

00:16:54,220 --> 00:16:56,360
and filter appropriately.

00:16:56,360 --> 00:16:59,010
And then finally another area to think about would be,

00:16:59,010 --> 00:17:01,140
so this is all SKB-based.

00:17:01,140 --> 00:17:03,890
So are there other data structures

00:17:03,890 --> 00:17:05,010
that would be useful to trace?

00:17:05,010 --> 00:17:07,660
So the RDMA stack might be something good to look at.

00:17:09,490 --> 00:17:10,840
The scatter-gather list that are used

00:17:10,840 --> 00:17:14,530
to specify RDMA data could be perhaps benefit

00:17:14,530 --> 00:17:15,840
from having a bit more observability,

00:17:15,840 --> 00:17:17,720
so this might be one way to get that.

00:17:17,720 --> 00:17:18,893
And possibly the USB subsystem as well.

00:17:18,893 --> 00:17:20,570
And one of the things about Wireshark

00:17:20,570 --> 00:17:23,700
is we've got dissectors for so many protocols.

00:17:23,700 --> 00:17:26,307
So if we had ways of interpreting other things

00:17:26,307 --> 00:17:29,193
within skbuffs, we can make use of that in other places too.

00:17:30,360 --> 00:17:32,880
So here's some references.

00:17:32,880 --> 00:17:34,450
And with that, I think I'm done.

00:17:34,450 --> 00:17:35,940
So if anyone has any questions or comments,

00:17:35,940 --> 00:17:37,190
I'd really appreciate it.

00:17:38,090 --> 00:17:40,640
- I'll ask the first question, okay?

00:17:40,640 --> 00:17:41,510
So this is really great.

00:17:41,510 --> 00:17:45,050
I like the fact that you can inspect the skb state

00:17:45,050 --> 00:17:46,410
in arbitrary points in time in the kernel

00:17:46,410 --> 00:17:48,380
with the tracing, that's really useful

00:17:48,380 --> 00:17:49,900
for debugging especially.

00:17:49,900 --> 00:17:54,010
But I wonder how we can integrate this

00:17:55,260 --> 00:17:58,650
in such a way that we can capture packets

00:17:58,650 --> 00:18:01,973
no matter what thing process them.

00:18:03,040 --> 00:18:06,410
So like would you think about applying your infrastructure

00:18:06,410 --> 00:18:09,790
to xdp-based traffic that didn't get xdp-passed

00:18:09,790 --> 00:18:12,190
into the networking stack, for example,

00:18:12,190 --> 00:18:14,660
to pass it into your infrastructure?

00:18:14,660 --> 00:18:15,510
- So you can actually start,

00:18:15,510 --> 00:18:17,060
one thing I should've been clearer about

00:18:17,060 --> 00:18:19,390
is I kinda focus on the tracing side of things here

00:18:19,390 --> 00:18:22,500
but you can actually capture in xdp programs as well.

00:18:22,500 --> 00:18:23,360
- Right, that's great.

00:18:23,360 --> 00:18:26,720
So maybe at some point we consolidate all this stuff

00:18:26,720 --> 00:18:29,290
such as if someone says tcpdump interface zero,

00:18:29,290 --> 00:18:32,100
they get the xdp packets as well as the--

00:18:32,100 --> 00:18:34,370
- Oh, okay, so consolidated into the high level too as well.

00:18:34,370 --> 00:18:36,370
- Yeah, so a user, gets into a machine.

00:18:36,370 --> 00:18:38,090
They don't have to know a special tool

00:18:38,090 --> 00:18:40,260
to look in xdp traffic versus other traffic.

00:18:40,260 --> 00:18:42,400
I think that would be a really good direction to go in.

00:18:42,400 --> 00:18:43,233
- Yeah, yeah.

00:18:43,233 --> 00:18:44,450
And you could imagine in the long-term

00:18:44,450 --> 00:18:46,430
integrating support for specifying functions

00:18:46,430 --> 00:18:48,610
into the high level tools like tcpdump as well

00:18:48,610 --> 00:18:49,993
so you could specify kernel function as well.

00:18:49,993 --> 00:18:52,000
I mean, to be honest, that stuff is probably

00:18:52,000 --> 00:18:54,110
only gonna be used by people like us kernel developers

00:18:54,110 --> 00:18:55,870
and people who know what state packets

00:18:55,870 --> 00:18:56,820
are in at certain points.

00:18:56,820 --> 00:18:59,140
But having sort of high level support for that

00:18:59,140 --> 00:19:00,060
might be something worth looking at.

00:19:00,060 --> 00:19:01,220
- I think so too.

00:19:01,220 --> 00:19:02,053
Okay, great.

00:19:02,053 --> 00:19:03,073
Where's the box?

00:19:06,490 --> 00:19:09,820
- Yeah, this is, I like the facility as well.

00:19:09,820 --> 00:19:12,480
And we've been thinking about something similar

00:19:12,480 --> 00:19:17,480
to ship something like xdpcap or xdpdump or whatever.

00:19:18,262 --> 00:19:19,200
(faint voice talking)

00:19:19,200 --> 00:19:23,000
Yeah, like tools specifically for xdp for capturing packets.

00:19:23,000 --> 00:19:25,050
And obviously this helper would be a way.

00:19:25,950 --> 00:19:28,300
But that I think in terms of integrating with other features

00:19:28,300 --> 00:19:29,530
there's something coming up

00:19:29,530 --> 00:19:32,970
like in the process the drop monitor,

00:19:32,970 --> 00:19:37,633
which can also point packets to userspace

00:19:38,610 --> 00:19:42,280
but with a different mechanism and a different format.

00:19:42,280 --> 00:19:44,620
So we might want to think about sort of consolidating this,

00:19:44,620 --> 00:19:47,340
not show about it, putting pcap in the kernel,

00:19:47,340 --> 00:19:48,550
I think you're doing, right?

00:19:48,550 --> 00:19:51,980
I guess some elements of this that puts

00:19:51,980 --> 00:19:54,180
the actual capture format in the kernel?

00:19:54,180 --> 00:19:55,760
- Well, the nice thing about this is that,

00:19:55,760 --> 00:19:57,210
well, actually all we really do is capture

00:19:57,210 --> 00:19:59,780
continuous range of data from the packet.

00:19:59,780 --> 00:20:01,360
So it's the userspace that takes that

00:20:01,360 --> 00:20:02,940
and actually dumps it to the capture file.

00:20:02,940 --> 00:20:04,548
So there's no-- - Right, considering.

00:20:04,548 --> 00:20:05,381
- Yeah, okay. - Yeah.

00:20:05,381 --> 00:20:10,381
- But in terms of the userspace tool,

00:20:10,530 --> 00:20:13,380
I don't think we should be overloading this into bpftool.

00:20:14,550 --> 00:20:15,870
I would much prefer to have

00:20:15,870 --> 00:20:19,320
sort of a add on xdpdump on bpfdump.

00:20:19,320 --> 00:20:23,270
I'll just put it into tcpdump as yours is at.

00:20:23,270 --> 00:20:26,710
Because we're already turning bpftool

00:20:26,710 --> 00:20:29,070
into a catch-all tool for this stuff

00:20:29,070 --> 00:20:31,100
and can be very, very useful

00:20:31,100 --> 00:20:33,750
outside of sort of the bpf ecosystem.

00:20:33,750 --> 00:20:36,310
This is something we need to have if we're gonna

00:20:36,310 --> 00:20:39,600
sort of have xdp and all these things to support it.

00:20:39,600 --> 00:20:42,050
I think we really need a way to see what's going on.

00:20:42,050 --> 00:20:43,054
- [Alan] Yeah.

00:20:43,054 --> 00:20:44,540
(faint voice talking)

00:20:44,540 --> 00:20:48,300
- Regarding the pcap format, so like the bpf pcap helper

00:20:48,300 --> 00:20:51,740
that you're suggesting so that would basically

00:20:51,740 --> 00:20:54,690
add the pcap header, like for every packet

00:20:54,690 --> 00:20:56,520
and then the actual packet data, right?

00:20:56,520 --> 00:20:57,830
- [Alan] Yeah.

00:20:57,830 --> 00:20:58,663
- I think it would be good to have

00:20:58,663 --> 00:20:59,850
that's actually programmable.

00:20:59,850 --> 00:21:04,250
I don't think you wouldn't need to have it as a extra helper

00:21:04,250 --> 00:21:08,090
because oftentimes maybe people want to customize

00:21:08,090 --> 00:21:11,700
what they want to explore in terms of metadata.

00:21:11,700 --> 00:21:16,240
Even like with the old BPF metadata,

00:21:16,240 --> 00:21:19,390
in front of the packet there were even multiple formats

00:21:19,390 --> 00:21:21,540
that a couple of people defined.

00:21:21,540 --> 00:21:24,000
And I think the original one, for example,

00:21:24,000 --> 00:21:27,400
didn't even include the if index on that system

00:21:27,400 --> 00:21:29,500
and this was like quite some limitation

00:21:29,500 --> 00:21:33,483
and I think back then Alexei Gudnatsov

00:21:33,483 --> 00:21:36,280
had his own format which included that.

00:21:36,280 --> 00:21:39,520
And so I think it would have to be programmable.

00:21:39,520 --> 00:21:41,860
It wouldn't make it as a helper itself.

00:21:41,860 --> 00:21:42,693
- [Alan] Yeah.

00:21:42,693 --> 00:21:46,660
- And if you push the rest into the perf ring buffer anyway,

00:21:46,660 --> 00:21:49,110
so that's already there, right?

00:21:49,110 --> 00:21:53,680
So that would be good to have it flexible in the sense.

00:21:53,680 --> 00:21:55,670
- Yeah, I think one of the things,

00:21:55,670 --> 00:21:57,310
I think it came up actually.

00:21:57,310 --> 00:22:00,060
I think (mumbles) made this point that

00:22:00,060 --> 00:22:03,060
you can do a lot of this stuff with perf events already.

00:22:03,060 --> 00:22:05,790
So do you need a specific helper to do this?

00:22:05,790 --> 00:22:07,710
So the only bit you can't really do

00:22:07,710 --> 00:22:10,170
I think is on the tracing side where you get,

00:22:10,170 --> 00:22:12,780
where you have fragments on the skb.

00:22:12,780 --> 00:22:16,100
So it's easy to do a BPF probe read

00:22:16,100 --> 00:22:19,060
and get the head information.

00:22:19,060 --> 00:22:21,830
But then when this fragments as well, you're in trouble.

00:22:21,830 --> 00:22:25,350
So definitely I think keeping things generic

00:22:25,350 --> 00:22:26,183
I kinda struggled with that.

00:22:26,183 --> 00:22:27,757
I was trying to think, "Should we package this up

00:22:27,757 --> 00:22:31,840
"and have something where there isn't that flexibility?"

00:22:31,840 --> 00:22:33,670
Because with perf events you get to choose

00:22:33,670 --> 00:22:35,470
your own metadata, so in this case you don't.

00:22:35,470 --> 00:22:38,470
So, yeah, I think it would be worth looking at again

00:22:38,470 --> 00:22:41,420
and saying, "Maybe we should keep this a bit more generic."

00:22:43,660 --> 00:22:45,590
- Well, you talked about kprobes at one point.

00:22:45,590 --> 00:22:49,120
You said this is going to point you back to the skb.

00:22:49,120 --> 00:22:51,110
Is it an skb always involved?

00:22:51,110 --> 00:22:53,410
Or for particular performance events,

00:22:53,410 --> 00:22:55,830
is there an ability to go straight from the event

00:22:55,830 --> 00:22:57,850
into the MMAP-ed buffer representation

00:22:57,850 --> 00:22:59,820
and eliminate the skb?

00:22:59,820 --> 00:23:03,300
- So the way it works currently is when the kprobe

00:23:03,300 --> 00:23:06,010
gets triggered and the BPF helper is called,

00:23:06,010 --> 00:23:08,750
you're giving that a pointer and that pointer is assumed

00:23:08,750 --> 00:23:10,960
at the moment to point at an skb.

00:23:10,960 --> 00:23:13,260
But one thing I suggest for future work

00:23:13,260 --> 00:23:15,160
is it wouldn't necessarily have to be an skb.

00:23:15,160 --> 00:23:17,860
So if you want to look in the RDMA subsystem

00:23:17,860 --> 00:23:20,210
and you wanna take one of their scatter-gather lists,

00:23:20,210 --> 00:23:22,340
you could give it a parser for that effectively as well.

00:23:22,340 --> 00:23:24,770
So it could support other types of--

00:23:24,770 --> 00:23:26,470
- And then translate that directly

00:23:26,470 --> 00:23:28,040
into the pcap format to MMAP?

00:23:28,040 --> 00:23:29,790
- [Alan] Yeah, exactly.

00:23:29,790 --> 00:23:33,550
- So one extension that would be good,

00:23:33,550 --> 00:23:36,643
maybe if you know that you're tracing a function

00:23:36,643 --> 00:23:38,590
that has an skb as an argument anyway,

00:23:38,590 --> 00:23:41,870
you could inspect that via BTF

00:23:41,870 --> 00:23:44,530
and then you can actually maybe call the actual skb helpers

00:23:44,530 --> 00:23:45,670
to extract the data.

00:23:45,670 --> 00:23:47,439
Because you know the kernel is running this

00:23:47,439 --> 00:23:51,150
so you don't have to do the BPF probe read stuff.

00:23:51,150 --> 00:23:51,983
- [Alan] Oh, really?

00:23:51,983 --> 00:23:53,090
Yeah, so you know it is.

00:23:53,090 --> 00:23:54,183
So, yeah, it's safe, yeah.

00:23:54,183 --> 00:23:56,780
- At that point you would know

00:23:56,780 --> 00:23:58,210
that you don't trust the kernel

00:23:58,210 --> 00:24:01,290
if you attach to this specific function, right?

00:24:01,290 --> 00:24:02,170
- Yeah, that's true.

00:24:02,170 --> 00:24:04,360
'Cause at the moment there's a lot of logic in the code

00:24:04,360 --> 00:24:06,130
that has to check that it actually does look like an skb

00:24:06,130 --> 00:24:07,790
and then the data is valid.

00:24:07,790 --> 00:24:10,860
But, yeah, if you could use BTF, we can avoid that.

00:24:10,860 --> 00:24:11,693
That's true.

00:24:13,628 --> 00:24:14,461
Okay.

00:24:16,010 --> 00:24:17,210
- Hi, I'm Michael Richardson.

00:24:17,210 --> 00:24:19,293
I'm actually the tcpdump maintainer.

00:24:20,470 --> 00:24:24,810
We don't currently in libpcap have a really a output

00:24:24,810 --> 00:24:27,380
pcap-ng mechanism.

00:24:27,380 --> 00:24:28,910
That's a bug that's probably gonna get fixed

00:24:28,910 --> 00:24:30,010
in the next year.

00:24:30,010 --> 00:24:31,800
One of the reasons we don't really have a thing

00:24:31,800 --> 00:24:34,060
is that we don't really have a lot of good use cases

00:24:34,060 --> 00:24:35,840
for when we would need to dump new stuff

00:24:35,840 --> 00:24:40,840
because we don't have a huge amount of meta information

00:24:41,780 --> 00:24:45,240
from the kernel captures that we don't have some,

00:24:45,240 --> 00:24:47,420
whereas we've already hacked it into badly

00:24:47,420 --> 00:24:48,253
into another place.

00:24:48,253 --> 00:24:51,490
So for instance, directions in and out.

00:24:51,490 --> 00:24:54,200
It would be so nice to know this packet was dropped.

00:24:54,200 --> 00:24:56,957
That would be such a beautiful thing to be able to say.

00:24:56,957 --> 00:24:57,947
"Yes, it was received.

00:24:57,947 --> 00:24:58,940
"Yes, it went through.

00:24:58,940 --> 00:25:00,380
"Yes, it was dropped,"

00:25:00,380 --> 00:25:02,487
or, "This is the unencrypted version

00:25:02,487 --> 00:25:04,697
*of this encrypted packet and we got it twice,

00:25:04,697 --> 00:25:06,240
*because it went through twice."

00:25:06,240 --> 00:25:09,790
So I would love to spend some time

00:25:09,790 --> 00:25:12,260
to figure out what the metadata that you have,

00:25:12,260 --> 00:25:13,740
stack traces, all of that stuff

00:25:13,740 --> 00:25:15,400
would be absolutely wonderful.

00:25:15,400 --> 00:25:18,440
And I think it just is exactly what we were thinking about

00:25:18,440 --> 00:25:20,230
when the pcap-ng format was created.

00:25:20,230 --> 00:25:21,760
It's like there's stuff that people want,

00:25:21,760 --> 00:25:23,710
but we don't know yet what it is.

00:25:23,710 --> 00:25:25,730
- [Man] I think that drop idea is excellent.

00:25:25,730 --> 00:25:27,810
I just couldn't be clear on semantics.

00:25:27,810 --> 00:25:28,643
- Absolutely.

00:25:28,643 --> 00:25:29,476
Where was it dropped?

00:25:29,476 --> 00:25:30,309
Why was it dropped?

00:25:30,309 --> 00:25:31,142
Who dropped it?

00:25:31,142 --> 00:25:33,830
- [Man] But what does except mean?

00:25:33,830 --> 00:25:34,780
- Yes.

00:25:34,780 --> 00:25:37,310
- It made it to the socket and it went to userspace.

00:25:37,310 --> 00:25:38,230
Okay, I understand.

00:25:38,230 --> 00:25:39,830
That's unambiguously except.

00:25:39,830 --> 00:25:42,700
- So one of the things that users regularly want to know

00:25:42,700 --> 00:25:46,487
is, "I want to trace this socket as traffic

00:25:46,487 --> 00:25:48,050
"that came to this socket."

00:25:48,050 --> 00:25:49,940
I know the system received it,

00:25:49,940 --> 00:25:51,230
but I can see that it didn't get,

00:25:51,230 --> 00:25:53,473
the application didn't get it, the where, the why.

00:25:53,473 --> 00:25:54,850
- So that's the kind of drops that people--

00:25:54,850 --> 00:25:55,683
- That's exactly.

00:25:55,683 --> 00:25:57,747
They wanna know like, "Well, I screwed something up.

00:25:57,747 --> 00:26:02,190
"'Cause I see the traffic coming in and now what?"

00:26:02,190 --> 00:26:03,023
- Yeah.

00:26:06,180 --> 00:26:08,093
Let's get some other people here, John.

00:26:09,800 --> 00:26:11,890
- I just want to also add like,

00:26:11,890 --> 00:26:13,780
if you could tell me like where the kfree happened

00:26:13,780 --> 00:26:15,260
on the individual packet, this would be huge.

00:26:15,260 --> 00:26:18,080
'Cause there's so many times where I've done something wrong

00:26:18,080 --> 00:26:19,330
and I'm trying to figure out exactly

00:26:19,330 --> 00:26:20,730
where the packets dropped.

00:26:20,730 --> 00:26:21,563
If you had like--

00:26:21,563 --> 00:26:23,830
- [Man] Drop monitor is supposed to fill that gap.

00:26:23,830 --> 00:26:26,470
- But can you filter on like I want this tcp packet

00:26:26,470 --> 00:26:27,898
with these push flags at, right?

00:26:27,898 --> 00:26:29,100
- [Man] You have to do that manually.

00:26:29,100 --> 00:26:30,170
- Yeah, right?

00:26:30,170 --> 00:26:31,510
But like a single command line?

00:26:31,510 --> 00:26:32,450
I mean I can do it today.

00:26:32,450 --> 00:26:33,484
It's painful, but--

00:26:33,484 --> 00:26:34,930
- You want something like that?

00:26:34,930 --> 00:26:35,763
- Yeah.

00:26:40,350 --> 00:26:43,260
- Hey, so you mentioned something about

00:26:43,260 --> 00:26:45,900
like filtering packets.

00:26:45,900 --> 00:26:48,860
My question to you is like digging

00:26:48,860 --> 00:26:51,730
a little into that specifically.

00:26:51,730 --> 00:26:55,150
At 40 gig, just putting bytes into a perf pipe,

00:26:55,150 --> 00:26:57,530
pretty soon your userspace is not gonna

00:26:57,530 --> 00:26:58,790
keep up just filtering.

00:26:58,790 --> 00:27:02,450
So what thoughts do you have about like runtime,

00:27:02,450 --> 00:27:04,790
like specifying filters especially for something

00:27:04,790 --> 00:27:06,073
like in the xdp mode?

00:27:07,010 --> 00:27:09,840
- Yeah, we need a way to push a filter into the BPF program

00:27:09,840 --> 00:27:11,810
that's doing the capture.

00:27:11,810 --> 00:27:13,120
XDP captured this.

00:27:13,120 --> 00:27:15,680
So I think the way they did that was interesting.

00:27:15,680 --> 00:27:18,150
They had a way of translating filters

00:27:18,150 --> 00:27:23,150
from classic BPF to eBPF so they could do the translation.

00:27:23,600 --> 00:27:24,570
So they'd have their filter

00:27:24,570 --> 00:27:26,670
and then their packet capture action.

00:27:26,670 --> 00:27:28,010
So that's one way of doing it.

00:27:28,010 --> 00:27:30,650
So one approach I was thinking about,

00:27:30,650 --> 00:27:31,970
and I don't even know if this is feasible,

00:27:31,970 --> 00:27:34,600
would be to have a BPF helper

00:27:34,600 --> 00:27:36,720
that you could call within your program.

00:27:36,720 --> 00:27:39,860
At the moment, we have this way of doing BPF tail calls.

00:27:39,860 --> 00:27:42,130
So you have a map populated with BPF programs

00:27:42,130 --> 00:27:45,770
and you can tail call one of them based on your needs.

00:27:45,770 --> 00:27:48,170
So if you populated a map like that

00:27:48,170 --> 00:27:51,060
with BPF filter programs, maybe we could add a helper

00:27:51,060 --> 00:27:53,740
that could call into one of those filter programs.

00:27:53,740 --> 00:27:55,797
But I'm not sure what the logistics of that are.

00:27:55,797 --> 00:27:58,283
And you'd have to worry about recursion then obviously.

00:27:59,340 --> 00:28:01,830
- [Man] Like the tool that you run in userspace

00:28:01,830 --> 00:28:04,490
to activate this is loading a BPF program, right?

00:28:04,490 --> 00:28:05,390
- [Alan] Yeah.

00:28:05,390 --> 00:28:08,787
- And we already have code to translate filters into eBPF

00:28:08,787 --> 00:28:12,340
so you can just like put it into the BPF program

00:28:12,340 --> 00:28:13,383
before you load it.

00:28:14,580 --> 00:28:15,413
- [Alan] Yeah.

00:28:15,413 --> 00:28:16,246
(faint voice talking)

00:28:16,246 --> 00:28:17,079
Yeah, it's true.

00:28:17,079 --> 00:28:18,527
- So you just like, and you can,

00:28:18,527 --> 00:28:20,520
I literally just rewrite the program

00:28:20,520 --> 00:28:23,030
and like sort of stuff some instructions in there

00:28:23,030 --> 00:28:24,050
to do the filtering.

00:28:24,050 --> 00:28:28,050
Or you can have like BPF normal function calls now

00:28:28,050 --> 00:28:31,140
that you sort of populate a filter function dynamically

00:28:31,140 --> 00:28:32,430
when you load the program?

00:28:32,430 --> 00:28:34,200
I think that should be doable, right?

00:28:34,200 --> 00:28:35,257
Looking at (mumbles).

00:28:39,530 --> 00:28:40,363
- I'm kinda biased.

00:28:40,363 --> 00:28:42,870
I'm the original author of XDP at Cloudflare.

00:28:42,870 --> 00:28:44,710
I think one of the key things we found

00:28:44,710 --> 00:28:47,620
is that having extra metadata is really important for us.

00:28:47,620 --> 00:28:49,190
So we pretty much only use an XDP,

00:28:49,190 --> 00:28:51,770
but knowing what action we took on that packet

00:28:51,770 --> 00:28:52,603
is really important.

00:28:52,603 --> 00:28:53,570
If we just capture a packet

00:28:53,570 --> 00:28:55,173
and don't know what we actually did with it,

00:28:55,173 --> 00:28:56,820
it's mostly useless to us.

00:28:56,820 --> 00:28:58,560
Because we know, we've seen the packet,

00:28:58,560 --> 00:29:02,053
then Nick got it and then who knows what happened to it.

00:29:02,053 --> 00:29:04,290
And on that line, in XDP, it's nice to be able

00:29:04,290 --> 00:29:05,840
to capture the packet multiple times

00:29:05,840 --> 00:29:07,610
'cause sometimes you get the original input packet,

00:29:07,610 --> 00:29:09,010
then you modify the packet.

00:29:09,010 --> 00:29:11,260
It could end up completely different.

00:29:11,260 --> 00:29:13,460
And so one thing we've not quite figured how to do yet

00:29:13,460 --> 00:29:15,270
is how to capture a packet several times

00:29:15,270 --> 00:29:17,330
and associate that it is the same packet

00:29:17,330 --> 00:29:18,540
and that we've captured it once here

00:29:18,540 --> 00:29:19,940
in its unencapsulated form

00:29:19,940 --> 00:29:22,300
and then maybe encapsulated it in a UDP packet

00:29:22,300 --> 00:29:23,930
or something to load balance it

00:29:23,930 --> 00:29:25,420
and being able to associate those two captures

00:29:25,420 --> 00:29:28,530
so we could search on one and find both at the same time.

00:29:28,530 --> 00:29:30,300
If that makes sense. - Yeah, yeah, yeah.

00:29:30,300 --> 00:29:32,180
Because I think one of the things it says,

00:29:32,180 --> 00:29:35,940
you capture the packet as it comes in to the program

00:29:35,940 --> 00:29:36,830
or before it's modified?

00:29:36,830 --> 00:29:37,663
I think you have to choose one or the other.

00:29:37,663 --> 00:29:38,530
- So, yeah, right.

00:29:38,530 --> 00:29:39,780
No, in XDP I think you only capture it

00:29:39,780 --> 00:29:42,790
in one place really once, 'cause we have to run them.

00:29:42,790 --> 00:29:45,640
Then we tail call into the converted CDPF filter program.

00:29:46,640 --> 00:29:47,473
- [Alan] Yeah.

00:29:48,544 --> 00:29:50,480
- I just wanna make a comment on that.

00:29:50,480 --> 00:29:52,270
It almost seems to suggest if we wanna do

00:29:52,270 --> 00:29:54,040
the multiple capture thing in XDP

00:29:54,040 --> 00:29:56,520
that we really would need a helper in the end

00:29:56,520 --> 00:29:58,443
to have a trigger point.

00:29:59,450 --> 00:30:00,550
- [Man] Or just an ID.

00:30:01,930 --> 00:30:02,763
- That's another way to do it.

00:30:02,763 --> 00:30:04,800
- Yeah, I just wanted to say that I think it'll be very

00:30:04,800 --> 00:30:07,490
useful if in the BPF program that you're loading

00:30:07,490 --> 00:30:09,490
you could specify implicit spots

00:30:09,490 --> 00:30:12,480
where you would be able to attach tcpdump style

00:30:14,040 --> 00:30:17,110
like hooks, right, like, "I want to dump here."

00:30:17,110 --> 00:30:18,020
(faint voice talking)

00:30:18,020 --> 00:30:20,750
And then you could so something like tcpdump-i

00:30:20,750 --> 00:30:23,730
if 0% XDP or something like that.

00:30:23,730 --> 00:30:24,563
- Yeah.

00:30:25,640 --> 00:30:28,210
One thing you can do, I've been using,

00:30:28,210 --> 00:30:29,890
so in Arch Linux we have DTrace,

00:30:29,890 --> 00:30:31,990
so it's like a separate tracing framework.

00:30:33,490 --> 00:30:35,210
DTrace has had packet capture for a while so,

00:30:35,210 --> 00:30:36,970
and that's how I came in contact with this subject.

00:30:36,970 --> 00:30:38,610
I added packet capture to that a while back.

00:30:38,610 --> 00:30:41,060
So one thing you can do is helper functions

00:30:41,060 --> 00:30:42,840
are kernel functions as well.

00:30:42,840 --> 00:30:44,210
So although it kinda makes your head spin,

00:30:44,210 --> 00:30:47,420
you can actually trace helper function

00:30:47,420 --> 00:30:48,730
within a BPF program as well.

00:30:48,730 --> 00:30:51,520
The same as with any kernel function.

00:30:51,520 --> 00:30:53,610
So that's one way you can actually track stuff.

00:30:53,610 --> 00:30:55,320
And I don't know if you could do that with BPF itself.

00:30:55,320 --> 00:30:58,170
There may be some limitations on running a tracing program

00:30:58,170 --> 00:30:59,570
on a BPF program itself.

00:30:59,570 --> 00:31:03,450
But certainly I guess it's theoretically possible, maybe.

00:31:03,450 --> 00:31:04,283
I'm not sure.

00:31:06,360 --> 00:31:07,230
- [Man] Here you go.

00:31:07,230 --> 00:31:09,270
- So one more comment on the filtering,

00:31:09,270 --> 00:31:11,590
to add to what John was mentioning before.

00:31:11,590 --> 00:31:13,320
I think it would be super useful

00:31:14,330 --> 00:31:17,960
if I'm monitoring kfree skb, for example,

00:31:17,960 --> 00:31:20,440
I want to know exactly, so I roughly know, okay,

00:31:20,440 --> 00:31:23,210
my skb goes through this path in the kernel

00:31:23,210 --> 00:31:27,450
but I want to filter on specific packet.

00:31:27,450 --> 00:31:31,780
So for example, I don't know, some protocol

00:31:31,780 --> 00:31:36,780
or I would like to attach maybe two kprobes in the system.

00:31:37,690 --> 00:31:39,670
I know the skb is passing through it,

00:31:39,670 --> 00:31:41,660
but it's dropped somewhere in between.

00:31:41,660 --> 00:31:44,930
And then, for example, I could do skb mark

00:31:44,930 --> 00:31:47,710
on the skb that I want to filter

00:31:47,710 --> 00:31:50,010
and maybe later on unmark it again

00:31:50,010 --> 00:31:51,830
so I don't get the rest of the noise

00:31:51,830 --> 00:31:55,120
that kfree skb is oftentimes generating.

00:31:55,120 --> 00:31:57,140
Something like this would be super useful I think

00:31:57,140 --> 00:31:58,810
for the backend production.

00:31:58,810 --> 00:31:59,643
- Yeah.

00:31:59,643 --> 00:32:00,920
Yeah, I think the concept is called,

00:32:00,920 --> 00:32:02,430
in DTrace it's called speculative tracing.

00:32:02,430 --> 00:32:05,840
So the idea is that an event may happen in the future,

00:32:05,840 --> 00:32:08,780
so you have a buffer, a special buffer set aside for that,

00:32:08,780 --> 00:32:11,010
and then you commit that buffer if the event happens

00:32:11,010 --> 00:32:12,220
and then you discard it if it doesn't.

00:32:12,220 --> 00:32:14,120
But, yeah, I think you could do the same thing with maps

00:32:14,120 --> 00:32:15,670
so quite easily as I'd imagine.

00:32:18,210 --> 00:32:21,220
- Yeah, I mean we would have to have some possibility

00:32:21,220 --> 00:32:25,770
to maybe write into the skb or like to mark it somehow

00:32:25,770 --> 00:32:28,230
that we want this specific one and not the rest, right?

00:32:28,230 --> 00:32:29,233
- [Alan] Yeah, yeah.

00:32:34,610 --> 00:32:36,640
- Yeah, I like the idea presented here

00:32:36,640 --> 00:32:40,190
about multiple capturing points and collecting packets.

00:32:40,190 --> 00:32:43,320
One thing that seems missing in what you presented

00:32:43,320 --> 00:32:46,100
is that users are quite often interested

00:32:46,100 --> 00:32:48,670
in packets flowing in both directions.

00:32:48,670 --> 00:32:53,283
So in your examples you can filter only on one point,

00:32:54,230 --> 00:32:58,563
yeah, one tracepoint so you get like incoming packets only.

00:32:59,445 --> 00:33:01,290
I think what shouldn't be forgotten

00:33:01,290 --> 00:33:03,160
when we implement something like that

00:33:03,160 --> 00:33:05,570
is that we really want both,

00:33:05,570 --> 00:33:07,320
we want incoming and outgoing packets

00:33:07,320 --> 00:33:10,170
and both included in the same pickup file.

00:33:10,170 --> 00:33:11,940
- Yeah, yeah, makes sense.

00:33:11,940 --> 00:33:13,220
- Oh, and by the way there's,

00:33:13,220 --> 00:33:14,467
I think there's limitation of tcpdump

00:33:14,467 --> 00:33:17,470
but it cannot really start a direction.

00:33:17,470 --> 00:33:20,630
So you cannot find out whether a packet is going in or out.

00:33:20,630 --> 00:33:22,500
So this is something that should be probably stored

00:33:22,500 --> 00:33:23,600
in the metadata as well.

00:33:23,600 --> 00:33:24,763
- [Alan] Yeah, sure.

00:33:29,460 --> 00:33:31,000
- Just another thought.

00:33:31,890 --> 00:33:34,560
It would be fairly interesting

00:33:34,560 --> 00:33:38,630
if instead of simply installing a kprobe

00:33:38,630 --> 00:33:41,020
that it would just points you to filtering,

00:33:41,020 --> 00:33:44,110
if I could define something like a path

00:33:44,110 --> 00:33:45,707
going through the kernel and saying,

00:33:45,707 --> 00:33:49,010
"I want to see our packets that went through GFO,

00:33:49,010 --> 00:33:50,927
"that are going through this socket

00:33:50,927 --> 00:33:52,700
"that ended up being dropped."

00:33:52,700 --> 00:33:54,100
- [Alan] Yeah, okay.

00:33:54,100 --> 00:33:56,968
- So, or if I'm doing something outward,

00:33:56,968 --> 00:33:59,200
I want to see our packets from this socket

00:33:59,200 --> 00:34:02,550
that went outbound that ended up on (mumbles)

00:34:02,550 --> 00:34:03,827
queue number x.

00:34:03,827 --> 00:34:04,689
- [Alan] Yeah, yeah.

00:34:04,689 --> 00:34:07,300
- So it'd be interesting if we can extend it that way.

00:34:07,300 --> 00:34:09,760
- Yeah, I think that's where integration with them

00:34:09,760 --> 00:34:11,540
and actually a tracing tool is really useful

00:34:11,540 --> 00:34:13,690
because you can specify that at a much higher level.

00:34:13,690 --> 00:34:16,000
And I think that gives you the ability to sort of express

00:34:16,000 --> 00:34:18,320
some of those concepts a bit more clearly.

00:34:18,320 --> 00:34:21,910
- [Man] I think what we're learning over time is that

00:34:21,910 --> 00:34:26,290
the art of using these technologies is

00:34:26,290 --> 00:34:28,290
finding the appropriate tracepoint

00:34:28,290 --> 00:34:30,010
and then using the programmability

00:34:30,010 --> 00:34:31,830
that's implicit in the technology

00:34:31,830 --> 00:34:34,560
to get what you want when you want.

00:34:34,560 --> 00:34:36,330
And so all these little awesome ideas,

00:34:36,330 --> 00:34:38,240
like what John just described,

00:34:38,240 --> 00:34:40,730
are going to be a matter of finding what those pieces are

00:34:40,730 --> 00:34:42,630
to put together to solve that problem.

00:34:45,080 --> 00:34:47,023
Any other questions or comments?

00:34:48,666 --> 00:34:49,499
Okay.

00:34:49,499 --> 00:34:50,332
(faint voice talking)

00:34:50,332 --> 00:34:52,090
Okay, you may promote your thing.

00:34:52,090 --> 00:34:56,680
- On the topic of like xdp and xdpdump in different places

00:34:56,680 --> 00:34:58,720
in the xdp program, you should all come to our talk

00:34:58,720 --> 00:35:01,540
tomorrow morning about how we're going to do

00:35:01,540 --> 00:35:05,730
multiple xdp programs on one interface in sequence.

00:35:05,730 --> 00:35:06,630
- [Man] Okay, so if you're interested,

00:35:06,630 --> 00:35:08,180
come see that tomorrow morning.

00:35:09,570 --> 00:35:11,240
Oh, one more.

00:35:11,240 --> 00:35:12,830
- One more thought.

00:35:12,830 --> 00:35:17,550
So if you build tools that are basically using

00:35:17,550 --> 00:35:20,880
different tracepoints to capture packets

00:35:22,170 --> 00:35:25,730
and then later the kernel is changed so those,

00:35:25,730 --> 00:35:28,090
I mean you can use either the tracepoints

00:35:28,090 --> 00:35:29,970
or just like use kprobes?

00:35:29,970 --> 00:35:31,640
- [Alan] Kprobes and tracepoints.

00:35:31,640 --> 00:35:32,473
- Yeah. - Yeah.

00:35:32,473 --> 00:35:35,980
- So if you use just arbitrary probes,

00:35:35,980 --> 00:35:38,340
then we probably don't have guarantee

00:35:38,340 --> 00:35:41,110
that the packet capturing tool

00:35:41,110 --> 00:35:43,220
will work with future kernels,

00:35:43,220 --> 00:35:45,620
which is something that probably is not acceptable

00:35:45,620 --> 00:35:47,040
to your users I think.

00:35:47,040 --> 00:35:48,500
- [Alan] Yeah.

00:35:48,500 --> 00:35:50,273
- So it might not be that easy, I'm afraid.

00:35:50,273 --> 00:35:51,298
- [Alan] Yeah, yeah.

00:35:51,298 --> 00:35:54,523
(faint voice talking)

00:35:54,523 --> 00:35:56,790
(audience chuckles)

00:35:56,790 --> 00:35:58,950
- [Man] Okay, thank you very much, Alan.

00:35:58,950 --> 00:35:59,783
- Thank you.

00:35:59,783 --> 00:36:02,829

YouTube URL: https://www.youtube.com/watch?v=41KpCahETVI


