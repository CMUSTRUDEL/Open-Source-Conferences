Title: LPC2018 - Clang+Linux
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/256/
speaker:  Nick Desaulniers (Google)
Captions: 
	00:00:05,880 --> 00:00:11,290
hi everyone my name is Nikki Sonier I'm

00:00:08,850 --> 00:00:14,799
working on LOV M at Google

00:00:11,290 --> 00:00:17,050
and I'm Greg Hackman I'm on the Android

00:00:14,799 --> 00:00:18,400
kernel team and I've also been working

00:00:17,050 --> 00:00:22,000
on getting the kernel building with

00:00:18,400 --> 00:00:24,789
hello p.m. and we're here today we were

00:00:22,000 --> 00:00:27,999
here last year talking about kind of the

00:00:24,789 --> 00:00:29,410
work the initial work we got focused on

00:00:27,999 --> 00:00:30,910
compiling the Linux kernel with climbing

00:00:29,410 --> 00:00:34,290
and this is pretty much a status update

00:00:30,910 --> 00:00:39,040
of you know where if we come from since

00:00:34,290 --> 00:00:40,900
about a year ago so just as a quick kind

00:00:39,040 --> 00:00:42,910
of background of like what even is clang

00:00:40,900 --> 00:00:45,550
what is LOV M why do people even care

00:00:42,910 --> 00:00:47,290
about it kind of thing I would say this

00:00:45,550 --> 00:00:50,200
is kind of the overall like very high

00:00:47,290 --> 00:00:52,330
level architecture diagram of LLVM

00:00:50,200 --> 00:00:54,070
itself we're kind of the whole reason

00:00:52,330 --> 00:00:58,720
for it to me is to kind of separate out

00:00:54,070 --> 00:01:01,240
the compilation pipeline into various

00:00:58,720 --> 00:01:03,310
kind of well-defined stages where the

00:01:01,240 --> 00:01:06,460
idea being is you have some kind of

00:01:03,310 --> 00:01:08,439
intermediary representation where a lot

00:01:06,460 --> 00:01:10,479
of your core traditional compiler

00:01:08,439 --> 00:01:12,939
optimizations live in this middle and

00:01:10,479 --> 00:01:14,590
optimizer you have separate backends and

00:01:12,939 --> 00:01:16,420
there's multiple different ones

00:01:14,590 --> 00:01:18,399
I started adjusting this to put all the

00:01:16,420 --> 00:01:20,890
backends in there and then came this big

00:01:18,399 --> 00:01:24,159
massive thing so I said whatever we'll

00:01:20,890 --> 00:01:25,600
just put a couple there and then you

00:01:24,159 --> 00:01:27,670
want to end up having a couple different

00:01:25,600 --> 00:01:30,159
front ends for various languages so if

00:01:27,670 --> 00:01:31,899
you've heard of clang clang actually has

00:01:30,159 --> 00:01:33,670
multiple kind of source languages that

00:01:31,899 --> 00:01:37,299
it supports and then there's kind of

00:01:33,670 --> 00:01:39,310
external projects across and Swift and

00:01:37,299 --> 00:01:41,289
there's front ends for languages like D

00:01:39,310 --> 00:01:43,869
I think there's a ruby one there's a big

00:01:41,289 --> 00:01:44,920
list online you can go look at him but I

00:01:43,869 --> 00:01:46,689
think one of the things that's that's

00:01:44,920 --> 00:01:50,679
really really cool about the LLVM

00:01:46,689 --> 00:01:52,780
ecosystem is that fixes to these parts

00:01:50,679 --> 00:01:54,399
in the blue end up benefiting kind of

00:01:52,780 --> 00:01:56,409
all these different front ends and so

00:01:54,399 --> 00:01:57,759
what's really nice is as we get more

00:01:56,409 --> 00:02:00,100
people interested in language

00:01:57,759 --> 00:02:02,529
development when they choose to target

00:02:00,100 --> 00:02:04,950
LLVM and they choose to add

00:02:02,529 --> 00:02:06,810
optimizations to LLVM that can

00:02:04,950 --> 00:02:08,880
indirectly improve the performance of

00:02:06,810 --> 00:02:10,920
LOV I'm from compiling C and C both

00:02:08,880 --> 00:02:12,420
Bluffs that are you know other languages

00:02:10,920 --> 00:02:16,350
that other projects might might care

00:02:12,420 --> 00:02:18,480
about and LOV M itself is actually now

00:02:16,350 --> 00:02:21,510
more than just kind of this one compiler

00:02:18,480 --> 00:02:23,250
tool chain the whole the whole project

00:02:21,510 --> 00:02:26,190
itself is a collection of compiler

00:02:23,250 --> 00:02:28,380
utilities so for instance and they're

00:02:26,190 --> 00:02:30,240
meant to be broken apart so for instance

00:02:28,380 --> 00:02:33,150
let's say you have some project and you

00:02:30,240 --> 00:02:36,900
need to parse C++ code you could write

00:02:33,150 --> 00:02:39,480
your own C++ parser good luck it's not a

00:02:36,900 --> 00:02:41,640
lot of fun or you could link against Lib

00:02:39,480 --> 00:02:43,680
clang and you're not getting all of this

00:02:41,640 --> 00:02:46,110
back-end part you're just getting the

00:02:43,680 --> 00:02:48,900
lexing parsing and semantic analysis if

00:02:46,110 --> 00:02:51,570
you really want it kind of thing so kind

00:02:48,900 --> 00:02:53,670
of having this modular design is neat it

00:02:51,570 --> 00:02:55,410
makes development local development on

00:02:53,670 --> 00:02:56,880
LLVM a little bit faster and then you

00:02:55,410 --> 00:03:04,170
can link it all into one big monolith

00:02:56,880 --> 00:03:06,540
for like a release build so there's a

00:03:04,170 --> 00:03:09,780
couple different parts within LLVM that

00:03:06,540 --> 00:03:12,840
are I would say analogs or substitutes

00:03:09,780 --> 00:03:14,910
to various parts of GCC and VIN utils so

00:03:12,840 --> 00:03:17,780
just like you might invoke GCC or gmos

00:03:14,910 --> 00:03:22,260
plus there's flying and clang plus plus

00:03:17,780 --> 00:03:24,390
then I would say the the alternatives to

00:03:22,260 --> 00:03:26,130
say the canoe assembler is clanging

00:03:24,390 --> 00:03:28,560
itself has what's called an integrated

00:03:26,130 --> 00:03:30,180
assembler today for the kernel we

00:03:28,560 --> 00:03:33,000
actually turn it off because there's a

00:03:30,180 --> 00:03:34,680
fair amount of assembly that the Kleins

00:03:33,000 --> 00:03:37,940
integrated assembler doesn't support

00:03:34,680 --> 00:03:40,980
just yet and I think there's still a

00:03:37,940 --> 00:03:45,030
long tail of things to have there but

00:03:40,980 --> 00:03:47,510
work in progress the new AES is part of

00:03:45,030 --> 00:03:49,860
Ben utils so a bunch of these things

00:03:47,510 --> 00:03:51,209
like the the linkers themselves are in

00:03:49,860 --> 00:03:55,019
bin utils and there's actually two

00:03:51,209 --> 00:03:57,300
there's BFD and gold most systems will

00:03:55,019 --> 00:04:00,570
have an LDS and linked to the FD it's

00:03:57,300 --> 00:04:03,330
kind of the default LLVM has it has an

00:04:00,570 --> 00:04:06,739
alternative linker that exists called an

00:04:03,330 --> 00:04:09,470
LD it's heavily multi-threaded

00:04:06,739 --> 00:04:12,290
it's it's tries to be performance

00:04:09,470 --> 00:04:13,269
oriented from from day one further

00:04:12,290 --> 00:04:15,470
binutils

00:04:13,269 --> 00:04:17,930
utilities like ops dump option copy

00:04:15,470 --> 00:04:21,320
strip read a whole bunch of them there

00:04:17,930 --> 00:04:23,479
are LLVM based implementations that can

00:04:21,320 --> 00:04:26,389
actually share a lot of code right from

00:04:23,479 --> 00:04:28,160
being part of the LLVM project so

00:04:26,389 --> 00:04:31,039
there's kind of the equivalent so I'll

00:04:28,160 --> 00:04:33,560
have this LOM - prefix on them then

00:04:31,039 --> 00:04:37,220
you'll have various system libraries so

00:04:33,560 --> 00:04:38,780
live GCC will typically have various

00:04:37,220 --> 00:04:41,570
parts of the runtime that don't come

00:04:38,780 --> 00:04:43,430
from the C library so you for instance a

00:04:41,570 --> 00:04:45,770
lot of your compiler built-ins kind of

00:04:43,430 --> 00:04:46,789
get linked in from some of your compiler

00:04:45,770 --> 00:04:49,750
built-ins will be linked in from this

00:04:46,789 --> 00:04:54,639
library some of the sanitizers and stuff

00:04:49,750 --> 00:04:56,870
LLVM has one called compiler RT and then

00:04:54,639 --> 00:05:03,260
for instance there's an alternative or

00:04:56,870 --> 00:05:06,440
LLVM based c++ library implementation if

00:05:03,260 --> 00:05:08,660
you ever see that floating around so

00:05:06,440 --> 00:05:11,800
these are everything on the left here is

00:05:08,660 --> 00:05:15,349
kind of exists within the LLVM project

00:05:11,800 --> 00:05:18,770
and they exist as kind of alternatives

00:05:15,349 --> 00:05:24,889
to what you would get with GCC and bin

00:05:18,770 --> 00:05:26,330
details all right so I get this question

00:05:24,889 --> 00:05:27,409
a lot why do people in the curl

00:05:26,330 --> 00:05:29,870
community why should they care about

00:05:27,409 --> 00:05:33,229
client and the short answer is

00:05:29,870 --> 00:05:35,330
competition's good having two compilers

00:05:33,229 --> 00:05:36,080
means that they are both going to keep

00:05:35,330 --> 00:05:37,550
evolving

00:05:36,080 --> 00:05:41,240
there's even discussion yesterday about

00:05:37,550 --> 00:05:44,090
how GCC's compilation is significantly

00:05:41,240 --> 00:05:46,370
sped up probably largely as a response

00:05:44,090 --> 00:05:48,949
to claim because one of claims early

00:05:46,370 --> 00:05:51,289
advantages was it was very fast but

00:05:48,949 --> 00:05:53,330
apart from just things like speed

00:05:51,289 --> 00:05:54,979
there's a lot of interesting new

00:05:53,330 --> 00:05:58,310
compiler technology and it's developed

00:05:54,979 --> 00:06:02,030
on clang first and either is eventually

00:05:58,310 --> 00:06:05,570
taken into GCC or you know just stays in

00:06:02,030 --> 00:06:09,460
client things like Auto FDO is a Google

00:06:05,570 --> 00:06:11,979
developed technology for collecting

00:06:09,460 --> 00:06:13,539
runtime

00:06:11,979 --> 00:06:16,270
performance data without modifying

00:06:13,539 --> 00:06:18,849
binaries there's some good control flow

00:06:16,270 --> 00:06:24,190
integrity stuff to protect against

00:06:18,849 --> 00:06:26,289
return-oriented programming SCS shower

00:06:24,190 --> 00:06:28,569
call stack is another piece of that they

00:06:26,289 --> 00:06:31,449
ripped protects against return oriented

00:06:28,569 --> 00:06:32,770
programming bolt is some additional link

00:06:31,449 --> 00:06:36,940
time optimization that was contributed

00:06:32,770 --> 00:06:38,229
by Facebook climb D is an interesting

00:06:36,940 --> 00:06:41,440
project like Nick described where you

00:06:38,229 --> 00:06:44,500
can actually take the C++ parser and use

00:06:41,440 --> 00:06:46,449
it as a back-end for an editor which is

00:06:44,500 --> 00:06:48,849
led to be doing interesting things I

00:06:46,449 --> 00:06:51,009
actually use climb D + Visual Studio

00:06:48,849 --> 00:06:53,080
code on Linux to compile the Linux

00:06:51,009 --> 00:06:54,880
kernel which if you sent that statement

00:06:53,080 --> 00:06:57,389
back in time ten years people would

00:06:54,880 --> 00:06:57,389
think I was crazy

00:06:57,490 --> 00:07:04,870
and then there's LD the linker on top of

00:07:02,020 --> 00:07:06,610
that a lot of people have because LLVM

00:07:04,870 --> 00:07:09,310
is relatively easy to code on compared

00:07:06,610 --> 00:07:11,289
to GCC in many people's opinion a lot of

00:07:09,310 --> 00:07:13,930
interesting and aesthetic analyzers and

00:07:11,289 --> 00:07:16,539
dynamic analyzers have come to clang and

00:07:13,930 --> 00:07:21,699
either stating clang or later gotten

00:07:16,539 --> 00:07:23,169
taken to GCC things like case and kate

00:07:21,699 --> 00:07:26,830
UVC and i believe we're both developed

00:07:23,169 --> 00:07:28,599
in clang first there's some interesting

00:07:26,830 --> 00:07:30,690
thread safety analysis features

00:07:28,599 --> 00:07:33,610
basically if you're familiar with the

00:07:30,690 --> 00:07:36,009
thread annotation features that are in

00:07:33,610 --> 00:07:38,229
some of the compiler headers in linux

00:07:36,009 --> 00:07:42,580
that you can use to use external tools

00:07:38,229 --> 00:07:44,349
to check the basically that locks for

00:07:42,580 --> 00:07:46,300
instance are being used as documented

00:07:44,349 --> 00:07:47,979
clang actually has features like this

00:07:46,300 --> 00:07:50,349
built-in you can just put in a compiler

00:07:47,979 --> 00:07:53,289
pass there's an external static analyzer

00:07:50,349 --> 00:07:57,009
they can find a lot of low-hanging fruit

00:07:53,289 --> 00:07:58,509
but there's also just the advantages of

00:07:57,009 --> 00:08:00,699
just feeding your code into two

00:07:58,509 --> 00:08:02,710
compilers you get warnings from both

00:08:00,699 --> 00:08:05,020
compilers so you can shakeout undefined

00:08:02,710 --> 00:08:06,430
behavior or a bad behavior then maybe

00:08:05,020 --> 00:08:10,599
GCC or client would have missed an

00:08:06,430 --> 00:08:14,680
isolation it's also mutually beneficial

00:08:10,599 --> 00:08:17,380
for LLVM linux is a very large project a

00:08:14,680 --> 00:08:18,889
very complex project and so having as a

00:08:17,380 --> 00:08:21,440
test case

00:08:18,889 --> 00:08:22,870
throwing LLVM has benefited both

00:08:21,440 --> 00:08:26,270
codebases

00:08:22,870 --> 00:08:29,090
one sort of fringe benefit if you work

00:08:26,270 --> 00:08:32,870
with a lot of different architectures is

00:08:29,090 --> 00:08:34,820
that clang unlike GCC is a single you

00:08:32,870 --> 00:08:36,649
could configure it to basically be multi

00:08:34,820 --> 00:08:38,300
targeted so you have a single binary

00:08:36,649 --> 00:08:41,270
that targets every single architecture

00:08:38,300 --> 00:08:42,409
you care about so if you work on several

00:08:41,270 --> 00:08:43,760
different architectures you don't have

00:08:42,409 --> 00:08:49,910
to have hundreds of megabytes of tool

00:08:43,760 --> 00:08:51,910
change you just need the one so the

00:08:49,910 --> 00:08:54,980
priorities we've been looking at for

00:08:51,910 --> 00:08:58,250
getting a Linux kernel running with with

00:08:54,980 --> 00:09:01,010
LLVM basically three different

00:08:58,250 --> 00:09:02,360
categories basically what's what step

00:09:01,010 --> 00:09:04,839
it's at what architectures were looking

00:09:02,360 --> 00:09:08,480
at and what actual tools were deploying

00:09:04,839 --> 00:09:10,040
so we've we've gotten to the point where

00:09:08,480 --> 00:09:11,870
it's building and smoothing and it's

00:09:10,040 --> 00:09:14,899
actually shipping on some architectures

00:09:11,870 --> 00:09:17,329
on some devices in production we

00:09:14,899 --> 00:09:17,510
recognize a lot of people want more than

00:09:17,329 --> 00:09:20,300
that

00:09:17,510 --> 00:09:23,480
so we are actively working as we'll

00:09:20,300 --> 00:09:24,980
discuss in a future slide to the bit I'm

00:09:23,480 --> 00:09:27,950
doing continuous integration to make

00:09:24,980 --> 00:09:29,920
sure for instance that client changes

00:09:27,950 --> 00:09:32,029
don't break the kernel or vice versa

00:09:29,920 --> 00:09:35,450
similar to that they already have there

00:09:32,029 --> 00:09:36,890
are exists for TCC a lot of people for

00:09:35,450 --> 00:09:39,500
good reasons are concerned about

00:09:36,890 --> 00:09:41,810
building the kernel morning free right

00:09:39,500 --> 00:09:43,550
now that isn't possible with playing

00:09:41,810 --> 00:09:46,010
because clang is somewhat picky about

00:09:43,550 --> 00:09:49,459
some things the kernel does and there

00:09:46,010 --> 00:09:51,829
are working on that and then there's the

00:09:49,459 --> 00:09:54,350
basic polish and then once once we get

00:09:51,829 --> 00:09:55,579
to that stage and I think the hopefully

00:09:54,350 --> 00:09:57,860
the kernel community will be more

00:09:55,579 --> 00:09:59,540
comfortable with clang we could start to

00:09:57,860 --> 00:10:02,209
get out well what kind of features can

00:09:59,540 --> 00:10:05,570
we add to the kernel that maybe haven't

00:10:02,209 --> 00:10:06,860
landed in GCC yet so things like some of

00:10:05,570 --> 00:10:09,720
these analyzers they have not reported

00:10:06,860 --> 00:10:13,980
GCC like could we start feature

00:10:09,720 --> 00:10:16,200
if you use clam likewise have been

00:10:13,980 --> 00:10:18,060
mostly prior at least within Google

00:10:16,200 --> 00:10:22,340
we've been mostly prioritizing arm and

00:10:18,060 --> 00:10:25,410
x86 64 there's been some interest in

00:10:22,340 --> 00:10:28,500
both PowerPC and risk 5 I believe risk 5

00:10:25,410 --> 00:10:30,750
is mostly from the hobbyist community I

00:10:28,500 --> 00:10:35,070
don't believe we're working on that but

00:10:30,750 --> 00:10:37,110
we will link to github page later where

00:10:35,070 --> 00:10:39,690
we basically show where we're basically

00:10:37,110 --> 00:10:41,130
tracking this development and where

00:10:39,690 --> 00:10:42,780
we're accepting certain external

00:10:41,130 --> 00:10:46,350
contributions since we're stuff like

00:10:42,780 --> 00:10:47,790
risk 5 comes in and again most of our

00:10:46,350 --> 00:10:49,230
work is focused on actually compiling

00:10:47,790 --> 00:10:51,840
the kernel with clay we're still using

00:10:49,230 --> 00:10:53,580
VIN utils to link it assemblers we're

00:10:51,840 --> 00:10:55,230
getting fairly close at least on some

00:10:53,580 --> 00:10:57,030
architectures being able to link the

00:10:55,230 --> 00:10:58,530
kernel with with LOD which is nice

00:10:57,030 --> 00:11:02,310
because it's significantly faster than

00:10:58,530 --> 00:11:03,720
the new tools in my experience the linux

00:11:02,310 --> 00:11:06,360
kernel has very complicated build

00:11:03,720 --> 00:11:08,630
scripts so link scripts so this is still

00:11:06,360 --> 00:11:11,640
work in progress but we have like gotten

00:11:08,630 --> 00:11:14,430
we have experimental II gotten LD link

00:11:11,640 --> 00:11:16,530
URLs booting on arm 64 Davenport's then

00:11:14,430 --> 00:11:17,610
finally as Nick mentioned we do want to

00:11:16,530 --> 00:11:19,140
assemble the kernel with clang but

00:11:17,610 --> 00:11:21,410
that's kind of a longer-term project

00:11:19,140 --> 00:11:23,640
because claims need a great assembler

00:11:21,410 --> 00:11:27,870
does not accept all the constructs the

00:11:23,640 --> 00:11:30,660
kernel uses I know one of the issues

00:11:27,870 --> 00:11:33,720
people have had with the past in the

00:11:30,660 --> 00:11:35,760
community with clang is communication

00:11:33,720 --> 00:11:37,650
with LLVM kamini wasn't necessarily

00:11:35,760 --> 00:11:39,540
great and so there were a lot of

00:11:37,650 --> 00:11:41,820
specific compiler features that people

00:11:39,540 --> 00:11:45,180
really wanted in LLVM the LLVM did not

00:11:41,820 --> 00:11:48,810
support and this has been changing a lot

00:11:45,180 --> 00:11:50,310
recently so for instance people have for

00:11:48,810 --> 00:11:52,140
a very long time what it claimed to

00:11:50,310 --> 00:11:54,120
respect the f no delete null pointers

00:11:52,140 --> 00:11:57,090
check flag that is actually now shipping

00:11:54,120 --> 00:11:58,320
in clang 7 as a result of concerns

00:11:57,090 --> 00:12:02,340
within the kernel community that this is

00:11:58,320 --> 00:12:04,200
an important flag likewise a couple

00:12:02,340 --> 00:12:07,050
features that broke defconn fates on arm

00:12:04,200 --> 00:12:08,820
64 one involving the way that you name

00:12:07,050 --> 00:12:12,960
registers in inline assembly clobbers

00:12:08,820 --> 00:12:15,480
was fixed in clang 7 support for LSD

00:12:12,960 --> 00:12:17,370
Atomics required some very specific code

00:12:15,480 --> 00:12:20,160
generation flags and those are now

00:12:17,370 --> 00:12:22,709
supported in nightly client 8 builds

00:12:20,160 --> 00:12:25,560
one issue that's been a concern for a

00:12:22,709 --> 00:12:27,720
lot of people has been Azzam go to that

00:12:25,560 --> 00:12:29,160
is because not landed yet there is a

00:12:27,720 --> 00:12:31,649
prototype patch it has been contributed

00:12:29,160 --> 00:12:33,089
by Intel and this is I'm just sampling a

00:12:31,649 --> 00:12:34,529
handful these because these are the ones

00:12:33,089 --> 00:12:36,839
that I know people specifically called

00:12:34,529 --> 00:12:39,589
out as the LLVM DS to support this

00:12:36,839 --> 00:12:41,820
before we take it seriously but we

00:12:39,589 --> 00:12:43,019
there's a link here basically if you

00:12:41,820 --> 00:12:45,000
look hard to get hep tracker you can see

00:12:43,019 --> 00:12:48,139
there's a lot of also smart issues that

00:12:45,000 --> 00:12:50,610
have been fixed in LLVM as a result of

00:12:48,139 --> 00:12:53,730
increased interest specifically in the

00:12:50,610 --> 00:12:56,010
linux kernel if you want to try it

00:12:53,730 --> 00:12:57,060
it's fairly straightforward you if

00:12:56,010 --> 00:12:58,440
you're building for the same

00:12:57,060 --> 00:13:00,449
architectures your hosts you just say

00:12:58,440 --> 00:13:02,550
make C C equals clang you can also

00:13:00,449 --> 00:13:04,470
optionally say host C C equals clang to

00:13:02,550 --> 00:13:06,980
build the host tools with clang you

00:13:04,470 --> 00:13:09,120
don't have to but you can if you want

00:13:06,980 --> 00:13:10,410
likewise if you want across compile it's

00:13:09,120 --> 00:13:12,750
the same way as cross-compiling any

00:13:10,410 --> 00:13:14,970
other kernel you just set the arch of

00:13:12,750 --> 00:13:16,920
cross-compiled flags no you don't have

00:13:14,970 --> 00:13:17,430
to set the you don't report to a

00:13:16,920 --> 00:13:19,380
difference

00:13:17,430 --> 00:13:21,149
clang tool chain like it's the same

00:13:19,380 --> 00:13:22,470
binary that's like I said it's what the

00:13:21,149 --> 00:13:24,149
advantages of client is it is multi

00:13:22,470 --> 00:13:25,829
targeted and if you do want to

00:13:24,149 --> 00:13:29,910
experiment with with using an Aldi you

00:13:25,829 --> 00:13:32,550
can pass data LT as a linker and see how

00:13:29,910 --> 00:13:33,990
it works the caveat I will give you

00:13:32,550 --> 00:13:36,420
other than please don't ship penalty

00:13:33,990 --> 00:13:38,910
link curls in production right now is

00:13:36,420 --> 00:13:40,380
LVM moves very quickly so if you're just

00:13:38,910 --> 00:13:42,060
using the clang issues with your distro

00:13:40,380 --> 00:13:44,010
there's a reasonably good chance that is

00:13:42,060 --> 00:13:46,500
missing fixes that have landed they're

00:13:44,010 --> 00:13:50,690
important for the kernel and so you can

00:13:46,500 --> 00:13:53,730
either grab rebuilds from the elleven

00:13:50,690 --> 00:13:56,339
themselves it releases i LLVM org or

00:13:53,730 --> 00:13:58,890
google rolls some pre-built with

00:13:56,339 --> 00:14:01,170
cherry-picked fixes for things that are

00:13:58,890 --> 00:14:04,100
important for android and we distribute

00:14:01,170 --> 00:14:04,100
that those in a LSP

00:14:06,740 --> 00:14:12,570
are those on I think those are linked by

00:14:10,350 --> 00:14:22,290
releases to llvm or do you mean they

00:14:12,570 --> 00:14:23,490
were they have their own well we had

00:14:22,290 --> 00:14:24,959
concerns yesterday people want the

00:14:23,490 --> 00:14:27,240
opposite they'd wanted to not have a

00:14:24,959 --> 00:14:28,830
dead identity group Asura they went just

00:14:27,240 --> 00:14:35,180
hard balls so if you went to star balls

00:14:28,830 --> 00:14:37,589
that's where you anyway like I said we

00:14:35,180 --> 00:14:40,410
we are actually Google is shipping

00:14:37,589 --> 00:14:42,420
client'll kernels in production we

00:14:40,410 --> 00:14:44,279
couldn't afford to tell people last year

00:14:42,420 --> 00:14:46,709
because a bad time it actually both dick

00:14:44,279 --> 00:14:50,430
and I were carrying phones running clang

00:14:46,709 --> 00:14:51,779
bell kernels to to linux plumbers so if

00:14:50,430 --> 00:14:53,100
you have a pixel two or a pixel three

00:14:51,779 --> 00:14:55,110
you are using a claimed built colonel

00:14:53,100 --> 00:14:56,730
and in addition with pixel three we have

00:14:55,110 --> 00:14:59,160
turned on and are using in production

00:14:56,730 --> 00:15:03,029
link time optimization and control flow

00:14:59,160 --> 00:15:04,920
integrity checks and can't really say

00:15:03,029 --> 00:15:06,480
too many specifics at this point but you

00:15:04,920 --> 00:15:09,360
should expect to see a lot more of these

00:15:06,480 --> 00:15:10,829
coming soon on the android side also on

00:15:09,360 --> 00:15:12,570
the crumb left side they have recently

00:15:10,829 --> 00:15:15,300
flipped the switch so that there are new

00:15:12,570 --> 00:15:19,130
devices that are based on for 19 for 14

00:15:15,300 --> 00:15:19,130
and 4 for are now but with

00:15:21,619 --> 00:15:25,600
so one of the things that we're doing is

00:15:23,569 --> 00:15:29,720
we're trying to work with an existing

00:15:25,600 --> 00:15:35,179
continuous integration folks focused on

00:15:29,720 --> 00:15:37,670
on testing out kernels so Kirkland our

00:15:35,179 --> 00:15:40,189
O's kernel CI team is ramping up support

00:15:37,670 --> 00:15:43,220
for clang as part of testing various

00:15:40,189 --> 00:15:44,449
versions of different compilers one of

00:15:43,220 --> 00:15:47,329
the things that that were with that

00:15:44,449 --> 00:15:49,579
we're trying to do to help make their

00:15:47,329 --> 00:15:51,740
their builds a little less noisy is

00:15:49,579 --> 00:15:54,290
drive the warning countdown to zero that

00:15:51,740 --> 00:15:56,779
way it's easier to tell when a new patch

00:15:54,290 --> 00:15:59,170
introduces a new warning having a clean

00:15:56,779 --> 00:16:00,829
starting point helps a lot with that

00:15:59,170 --> 00:16:04,970
some of the things that are a little

00:16:00,829 --> 00:16:06,249
tricky to work out is being able to test

00:16:04,970 --> 00:16:08,839
all the different configurations

00:16:06,249 --> 00:16:10,809
possible configurations in the kernel to

00:16:08,839 --> 00:16:13,369
guarantee that they work with clang

00:16:10,809 --> 00:16:15,439
one of the things that's tricky is you

00:16:13,369 --> 00:16:18,110
can compile and all yes config and still

00:16:15,439 --> 00:16:19,999
not get all of the code in the kernel so

00:16:18,110 --> 00:16:22,790
the name is a little naming is a little

00:16:19,999 --> 00:16:25,160
tricky on that that make target because

00:16:22,790 --> 00:16:26,839
you do have either alternate alternate

00:16:25,160 --> 00:16:30,259
implementations or mutually exclusive

00:16:26,839 --> 00:16:31,879
configuration options so you know yeah

00:16:30,259 --> 00:16:33,589
just because an old yes config builds

00:16:31,879 --> 00:16:34,790
with climb doesn't mean all of the code

00:16:33,589 --> 00:16:38,089
in the kernel come on Elizabeth

00:16:34,790 --> 00:16:40,579
with clang I think some of the testing

00:16:38,089 --> 00:16:42,170
infrastructures do Rand configs which I

00:16:40,579 --> 00:16:44,379
think helps a lot but it's also random

00:16:42,170 --> 00:16:44,379
coins

00:16:45,130 --> 00:16:51,330
okay I think I think like we've heard

00:16:49,210 --> 00:16:53,380
ran config proposed as spare solutions

00:16:51,330 --> 00:16:54,850
and I think the tricky thing with that

00:16:53,380 --> 00:16:58,690
is just uncovering all the possible

00:16:54,850 --> 00:17:00,280
combinations so but then we try to see

00:16:58,690 --> 00:17:01,780
like are there some configurations that

00:17:00,280 --> 00:17:03,850
we want to guarantee our never broken

00:17:01,780 --> 00:17:05,170
and that gets into tricky territory

00:17:03,850 --> 00:17:07,660
between like you don't want to bless

00:17:05,170 --> 00:17:09,400
anyone given configuration other than I

00:17:07,660 --> 00:17:12,610
think the def config is the one that

00:17:09,400 --> 00:17:15,070
people all kind of agree on at least for

00:17:12,610 --> 00:17:17,670
having that as a but then ones on top of

00:17:15,070 --> 00:17:19,990
that it's always a question and then

00:17:17,670 --> 00:17:22,150
questions around which do we prioritize

00:17:19,990 --> 00:17:25,930
to be prioritize main line to prioritize

00:17:22,150 --> 00:17:28,090
next versus LTS branches I think when we

00:17:25,930 --> 00:17:29,950
started out we were focused on me main

00:17:28,090 --> 00:17:31,840
line and then every time the merge

00:17:29,950 --> 00:17:33,100
window would open next would bring down

00:17:31,840 --> 00:17:35,140
a bunch of patches and we'd wind up

00:17:33,100 --> 00:17:38,380
broken again so now we're focused on

00:17:35,140 --> 00:17:40,840
next properly and then trying to keep

00:17:38,380 --> 00:17:43,960
track of when fixes land fixes on the

00:17:40,840 --> 00:17:45,430
kernel side that we need making sure

00:17:43,960 --> 00:17:47,670
that we do the work to back port those

00:17:45,430 --> 00:17:49,990
and get those into the LTS branches

00:17:47,670 --> 00:17:53,080
we're in communication with Intel

00:17:49,990 --> 00:17:55,870
zero-day POC team I think some of the

00:17:53,080 --> 00:17:58,810
yasm go-to stuff on x86 the rail back

00:17:55,870 --> 00:18:00,700
conversation a little bit but I think

00:17:58,810 --> 00:18:03,280
once once we have that feature

00:18:00,700 --> 00:18:05,890
implemented in LLVM we'll try to start

00:18:03,280 --> 00:18:07,660
up those talks again and then I want to

00:18:05,890 --> 00:18:09,700
show off a little bit of some of the

00:18:07,660 --> 00:18:12,730
external testing that we've been setting

00:18:09,700 --> 00:18:17,020
up just on kind of github and Travis CI

00:18:12,730 --> 00:18:20,230
kind of some external stuff and the idea

00:18:17,020 --> 00:18:22,360
is is we want to grab this kind of as a

00:18:20,230 --> 00:18:27,130
newly snapshot of various branches as

00:18:22,360 --> 00:18:28,780
possible build them with as as recent a

00:18:27,130 --> 00:18:30,470
build of clang as we can and then boot

00:18:28,780 --> 00:18:32,779
tested in queue email

00:18:30,470 --> 00:18:34,429
the boot testing and qumu stuff is very

00:18:32,779 --> 00:18:38,600
nice because we can scale that very very

00:18:34,429 --> 00:18:40,490
wide on virtual machines versus with an

00:18:38,600 --> 00:18:42,649
Android land we have very expensive

00:18:40,490 --> 00:18:45,909
devices device labs that have many

00:18:42,649 --> 00:18:48,740
devices hooked up to host machines and

00:18:45,909 --> 00:18:51,429
we can't quite scale the testing as

00:18:48,740 --> 00:18:51,429
rapidly as we can

00:18:58,350 --> 00:19:05,039
so this is something that was set up

00:19:00,720 --> 00:19:06,870
fairly recently but let's pull up a

00:19:05,039 --> 00:19:08,940
build here I've been like fingers

00:19:06,870 --> 00:19:09,539
crossed that the build stays green for

00:19:08,940 --> 00:19:15,990
the talk

00:19:09,539 --> 00:19:18,149
oh look at that it's red okay yeah so we

00:19:15,990 --> 00:19:20,700
can see here like some of the some of

00:19:18,149 --> 00:19:23,820
the bill targets we have is we're

00:19:20,700 --> 00:19:27,389
building we have an arm def config I

00:19:23,820 --> 00:19:29,389
guess it's multi uv7 def config that

00:19:27,389 --> 00:19:32,940
that's building continuously with clang

00:19:29,389 --> 00:19:36,269
we have armed 64 def config build that's

00:19:32,940 --> 00:19:40,100
additionally being linked with LD we

00:19:36,269 --> 00:19:43,230
have a PowerPC little-endian build and

00:19:40,100 --> 00:19:45,899
we have some x86 stuff I think I know

00:19:43,230 --> 00:19:48,389
what's broken with this but I think the

00:19:45,899 --> 00:19:51,539
issue is probably related to some some

00:19:48,389 --> 00:19:53,120
some patch files that we have to help

00:19:51,539 --> 00:19:54,899
test some things in the meantime but

00:19:53,120 --> 00:19:57,840
essentially what what ends up happening

00:19:54,899 --> 00:20:00,690
is is this is a cron job that runs on

00:19:57,840 --> 00:20:02,909
Travis CI a daily it's not not quite

00:20:00,690 --> 00:20:06,629
every commit so maybe not as continuous

00:20:02,909 --> 00:20:10,200
as we would like but it pulls down a

00:20:06,629 --> 00:20:14,809
docker image essentially installs are

00:20:10,200 --> 00:20:14,809
kind of cross finis tools that we need

00:20:16,620 --> 00:20:24,929
pull down qumu fetch our LLVM tool chain

00:20:22,649 --> 00:20:27,690
from the the Debian that happy m dot org

00:20:24,929 --> 00:20:30,629
which should have builds in it getting

00:20:27,690 --> 00:20:32,820
climbing an LD from it we're using C

00:20:30,629 --> 00:20:34,289
cache quite successfully I would say if

00:20:32,820 --> 00:20:36,090
you're not using C cache one of the big

00:20:34,289 --> 00:20:38,759
issues with building the colonel with

00:20:36,090 --> 00:20:41,519
clang with the C cash in particular is

00:20:38,759 --> 00:20:43,919
you get lots of almost 100% cache misses

00:20:41,519 --> 00:20:46,529
from including the build timestamp and

00:20:43,919 --> 00:20:48,539
headers that get included everywhere so

00:20:46,529 --> 00:20:50,129
that tends to thrash the see cache but

00:20:48,539 --> 00:20:51,720
luckily there's some environmental

00:20:50,129 --> 00:20:54,059
variable heard I guess there's some K

00:20:51,720 --> 00:20:55,259
build variables that you can set so we

00:20:54,059 --> 00:20:57,210
don't really care about the building

00:20:55,259 --> 00:20:59,220
timestamp so we set those out and then

00:20:57,210 --> 00:20:59,910
I'll show you later the stats we print

00:20:59,220 --> 00:21:02,040
we get

00:20:59,910 --> 00:21:05,490
cache it and that cuts our build time

00:21:02,040 --> 00:21:07,950
down to a tenth of otherwise not using C

00:21:05,490 --> 00:21:10,530
cache and travis has some interesting

00:21:07,950 --> 00:21:12,780
set up to be able to store those cache

00:21:10,530 --> 00:21:16,230
files and pull them back down again

00:21:12,780 --> 00:21:18,120
so let's see what do we do export some

00:21:16,230 --> 00:21:21,180
variables check that we have all of our

00:21:18,120 --> 00:21:23,460
stuff that we need so here we print out

00:21:21,180 --> 00:21:26,700
here's the latest commit that we were

00:21:23,460 --> 00:21:28,890
able to fetch here from some stable to a

00:21:26,700 --> 00:21:35,070
def config and I start doing a full

00:21:28,890 --> 00:21:39,510
build have some warnings there and I

00:21:35,070 --> 00:21:42,750
need to go clean up and then right

00:21:39,510 --> 00:21:43,380
around here okay so here we got a build

00:21:42,750 --> 00:21:45,090
done in a minute

00:21:43,380 --> 00:21:48,630
on a two core machine thanks to see

00:21:45,090 --> 00:21:50,100
cache and then we need to boot test in

00:21:48,630 --> 00:21:52,920
queueing though so we've been working

00:21:50,100 --> 00:21:54,050
with Gunther baroque on Chrome OS side

00:21:52,920 --> 00:21:56,430
of things to figure out

00:21:54,050 --> 00:22:00,000
what are some of the best ways that we

00:21:56,430 --> 00:22:02,040
can boot these kernel images so you give

00:22:00,000 --> 00:22:04,110
Q EMU basically the kernel image that

00:22:02,040 --> 00:22:06,090
you just built and then you kind of need

00:22:04,110 --> 00:22:08,370
a root filesystem otherwise we get a

00:22:06,090 --> 00:22:12,810
panic early on trying to mount some root

00:22:08,370 --> 00:22:16,020
filesystem to get it in it so we have it

00:22:12,810 --> 00:22:18,240
basic overlay we're using build root

00:22:16,020 --> 00:22:20,760
successfully to build a very small users

00:22:18,240 --> 00:22:23,820
base we have a bunch of all the the

00:22:20,760 --> 00:22:28,860
kernel self tests are configured on so

00:22:23,820 --> 00:22:31,200
we we run through all those that we pass

00:22:28,860 --> 00:22:33,030
and then assuming that this all looks

00:22:31,200 --> 00:22:35,190
good we just have an init script that

00:22:33,030 --> 00:22:37,230
prints the version string and then shuts

00:22:35,190 --> 00:22:38,850
the Machine down which exits cleanly

00:22:37,230 --> 00:22:41,040
this helps a lot for automated testing

00:22:38,850 --> 00:22:43,140
to see did we boot successfully or not

00:22:41,040 --> 00:22:44,520
and typically what will happen is if

00:22:43,140 --> 00:22:46,770
there's some regression or something

00:22:44,520 --> 00:22:49,050
there may be a panic that will hang the

00:22:46,770 --> 00:22:52,080
Machine QA mu doesn't exit we use

00:22:49,050 --> 00:22:54,480
timeout utility that just sets a return

00:22:52,080 --> 00:22:55,740
code saying don't list it at work so you

00:22:54,480 --> 00:22:57,840
cache those oh look you got a hundred

00:22:55,740 --> 00:22:59,730
percent cache hit good job and then

00:22:57,840 --> 00:23:01,090
Travis goes in banks all that stuff up

00:22:59,730 --> 00:23:02,620
so

00:23:01,090 --> 00:23:05,800
let me see if I can find a build real

00:23:02,620 --> 00:23:07,930
quick that just has more information one

00:23:05,800 --> 00:23:09,430
of the cron job so we can see we try to

00:23:07,930 --> 00:23:13,000
split things up between like pre submit

00:23:09,430 --> 00:23:15,130
and post submit ok so here's one of the

00:23:13,000 --> 00:23:18,400
cron jobs that was great

00:23:15,130 --> 00:23:19,960
last night so you can see here just some

00:23:18,400 --> 00:23:24,160
of the variants that that we built for

00:23:19,960 --> 00:23:26,410
so this this build this target and all

00:23:24,160 --> 00:23:27,940
the ones above our main line then we

00:23:26,410 --> 00:23:31,300
have a bunch of builds of Linux next

00:23:27,940 --> 00:23:34,210
running and then work in progress I'm

00:23:31,300 --> 00:23:36,310
trying to add all the LTS branches for

00:23:34,210 --> 00:23:38,700
these things but I need to send grant

00:23:36,310 --> 00:23:38,700
more patches

00:23:45,150 --> 00:23:50,730
so if you're interested how how can you

00:23:47,520 --> 00:23:51,960
get involved we'd love to take any kind

00:23:50,730 --> 00:23:54,750
of bug reports of people who try this

00:23:51,960 --> 00:23:56,670
out so Greg had the instructions on an

00:23:54,750 --> 00:23:59,430
earlier slide of how how you can try to

00:23:56,670 --> 00:24:03,270
build your kernel with your configs so

00:23:59,430 --> 00:24:05,010
we have a public issue tracker lob I'm

00:24:03,270 --> 00:24:06,960
also has an issue tracker I find it hard

00:24:05,010 --> 00:24:08,130
to work with and people tend to file

00:24:06,960 --> 00:24:10,260
bugs there and then knocks you see

00:24:08,130 --> 00:24:11,520
anyone so it's almost like sending them

00:24:10,260 --> 00:24:13,440
into the void a little bit because

00:24:11,520 --> 00:24:14,610
people aren't necessarily going through

00:24:13,440 --> 00:24:17,880
the bug tracker and kind of finding

00:24:14,610 --> 00:24:20,040
these but I find it very easy just to

00:24:17,880 --> 00:24:22,590
work with github as far as like being

00:24:20,040 --> 00:24:25,200
able to add labels and sort things based

00:24:22,590 --> 00:24:27,270
on how many patches we have so we've

00:24:25,200 --> 00:24:30,300
done a fair amount of work kind of

00:24:27,270 --> 00:24:33,330
fixing a lot of a lot of issues on both

00:24:30,300 --> 00:24:36,390
the compiler side and the kernel side

00:24:33,330 --> 00:24:38,670
and I'd say we have fair amount of open

00:24:36,390 --> 00:24:39,840
issues right now but I would say I feel

00:24:38,670 --> 00:24:41,010
pretty confident because most of these

00:24:39,840 --> 00:24:43,200
we have patches that are already

00:24:41,010 --> 00:24:45,330
submitted or accepted it just takes time

00:24:43,200 --> 00:24:47,100
for them to actually bubble up and land

00:24:45,330 --> 00:24:49,290
in stable or maybe then you just soak in

00:24:47,100 --> 00:24:50,700
next and then once they make it to

00:24:49,290 --> 00:24:52,530
mainline then we can start back

00:24:50,700 --> 00:24:54,179
reporting them two-bit branches and

00:24:52,530 --> 00:24:55,590
stuff but it's not all there's not a

00:24:54,179 --> 00:24:58,410
whole lot that I'm too worried about

00:24:55,590 --> 00:24:59,910
these days one of the things that that

00:24:58,410 --> 00:25:03,330
I've seen from other projects that works

00:24:59,910 --> 00:25:06,809
really well is I think if you take the

00:25:03,330 --> 00:25:09,210
time when triaging a bug to say this is

00:25:06,809 --> 00:25:10,410
low-hanging fruit that I think if

00:25:09,210 --> 00:25:12,510
someone's interested in getting started

00:25:10,410 --> 00:25:14,790
contributing either to the Linux kernel

00:25:12,510 --> 00:25:17,340
or to LLVM if you tagged it

00:25:14,790 --> 00:25:19,590
appropriately and and leave it unfixed

00:25:17,340 --> 00:25:21,750
for a little bit longer that's a really

00:25:19,590 --> 00:25:23,070
great way to encourage external

00:25:21,750 --> 00:25:25,110
contributors to get started with the

00:25:23,070 --> 00:25:27,990
project because there's there's many

00:25:25,110 --> 00:25:30,390
people who aren't in the room today who

00:25:27,990 --> 00:25:32,730
probably would like to be and I think if

00:25:30,390 --> 00:25:35,730
we expend a little bit extra effort we

00:25:32,730 --> 00:25:39,059
can help enable them to be successful

00:25:35,730 --> 00:25:41,429
open-source contributors so so we have

00:25:39,059 --> 00:25:43,559
some bugs tagged as as good beginner

00:25:41,429 --> 00:25:45,150
bugs if you're interested in trying to

00:25:43,559 --> 00:25:46,470
help out trying to fix one of these I

00:25:45,150 --> 00:25:47,400
think biggest thing is just getting

00:25:46,470 --> 00:25:51,090
getting

00:25:47,400 --> 00:25:52,710
the reports is a big one because we run

00:25:51,090 --> 00:25:54,360
into someone and someone say oh I tried

00:25:52,710 --> 00:25:57,600
it and it didn't work I said Oh where's

00:25:54,360 --> 00:25:59,310
the bug report no so so we like we need

00:25:57,600 --> 00:26:00,540
to be people need to be sending us the

00:25:59,310 --> 00:26:02,580
bug reports like we need to be aware of

00:26:00,540 --> 00:26:04,350
them kind of thing and then we're trying

00:26:02,580 --> 00:26:07,440
to help enable people to be successful

00:26:04,350 --> 00:26:10,830
if they're if they're create just enough

00:26:07,440 --> 00:26:12,330
to try to also fix them as well if you

00:26:10,830 --> 00:26:14,520
want to use our Williams is your tracker

00:26:12,330 --> 00:26:18,840
most important thing please see see me

00:26:14,520 --> 00:26:21,120
or someone on it kind of thing there's a

00:26:18,840 --> 00:26:24,810
some of the things that helps us a lot

00:26:21,120 --> 00:26:28,470
is God Bolt org is this amazing utility

00:26:24,810 --> 00:26:33,960
if you haven't seen this it's an easy

00:26:28,470 --> 00:26:36,240
way to share links of of a disassembly

00:26:33,960 --> 00:26:38,790
so you have like this multi paint set up

00:26:36,240 --> 00:26:41,280
on the left you can put some some C code

00:26:38,790 --> 00:26:43,020
or C++ or various languages and then you

00:26:41,280 --> 00:26:48,870
can create multiple additional windows

00:26:43,020 --> 00:26:50,970
so you can here's a a trunk build of

00:26:48,870 --> 00:26:53,490
clang in a trunk build of GCC

00:26:50,970 --> 00:26:55,710
here's the disassembly you can put the

00:26:53,490 --> 00:26:57,200
compiler flags in here and then what's

00:26:55,710 --> 00:26:59,280
super nice is you can click share and

00:26:57,200 --> 00:27:01,830
like these links are awesome

00:26:59,280 --> 00:27:03,870
because someone can say hey LOV M is

00:27:01,830 --> 00:27:05,220
broken in this regard or you know

00:27:03,870 --> 00:27:06,900
there's a regression between these

00:27:05,220 --> 00:27:08,930
versions of LLVM and the disassembly

00:27:06,900 --> 00:27:12,720
kind of thing and this is super helpful

00:27:08,930 --> 00:27:15,660
for compiler folks to kind of see this

00:27:12,720 --> 00:27:16,860
and having that link that exists is

00:27:15,660 --> 00:27:19,560
something that you can reference and

00:27:16,860 --> 00:27:21,180
commit messages and it's just like super

00:27:19,560 --> 00:27:23,910
valuable to see exactly what the problem

00:27:21,180 --> 00:27:28,410
is what's going wrong other than like it

00:27:23,910 --> 00:27:29,910
doesn't work some other tools that I've

00:27:28,410 --> 00:27:32,340
had great success with there's a really

00:27:29,910 --> 00:27:34,110
nice program called C reduce so let's

00:27:32,340 --> 00:27:36,120
say you have a you know some some

00:27:34,110 --> 00:27:39,060
translation unit is failing to compile

00:27:36,120 --> 00:27:42,990
with hello VM C reduces this really neat

00:27:39,060 --> 00:27:46,320
utility that that tries to take an input

00:27:42,990 --> 00:27:48,900
test file and a separate shell script

00:27:46,320 --> 00:27:51,780
that that just returns whether or not it

00:27:48,900 --> 00:27:52,980
should proceed or not and it mutates the

00:27:51,780 --> 00:27:56,700
input and tries to pare it down

00:27:52,980 --> 00:27:58,710
until you have a very small test case

00:27:56,700 --> 00:28:03,870
I been trying to help test some of the

00:27:58,710 --> 00:28:07,140
opium Azzam go to implementation patches

00:28:03,870 --> 00:28:09,390
and I was hitting some issues linking

00:28:07,140 --> 00:28:12,660
the final kernel image and I was able to

00:28:09,390 --> 00:28:14,850
end up using C reduce pair down exactly

00:28:12,660 --> 00:28:17,490
which source file from the kernel was

00:28:14,850 --> 00:28:19,560
causing this miss compile and send this

00:28:17,490 --> 00:28:22,260
to the patch developers and say here's

00:28:19,560 --> 00:28:23,040
an exact like real-life code that exists

00:28:22,260 --> 00:28:24,960
in the wild

00:28:23,040 --> 00:28:27,210
I mean it's been obviated a little bit

00:28:24,960 --> 00:28:30,150
through C reduce but it's significantly

00:28:27,210 --> 00:28:31,380
smaller and this is a case that we need

00:28:30,150 --> 00:28:35,040
to make sure that we handled correctly

00:28:31,380 --> 00:28:37,590
because today we may not be so that's a

00:28:35,040 --> 00:28:39,630
neat utility that you can kind of let it

00:28:37,590 --> 00:28:42,330
run for a little bit and it will kind of

00:28:39,630 --> 00:28:43,880
make things a little bit simpler one of

00:28:42,330 --> 00:28:46,500
the things that's super useful as well

00:28:43,880 --> 00:28:48,630
for kind of filing bug reports to

00:28:46,500 --> 00:28:51,540
compiler developers is knowing which

00:28:48,630 --> 00:28:54,870
flags are used exactly for a translation

00:28:51,540 --> 00:28:56,730
unit so both I would say kind of

00:28:54,870 --> 00:28:59,670
pre-processing your source files before

00:28:56,730 --> 00:29:01,950
sending them is important because where

00:28:59,670 --> 00:29:04,680
you go and fetch your headers from may

00:29:01,950 --> 00:29:07,740
be difficult to reproduce that but then

00:29:04,680 --> 00:29:11,370
also certain certain flags tend to

00:29:07,740 --> 00:29:13,320
change radically code generation and so

00:29:11,370 --> 00:29:14,910
if you say hey to see the C file will

00:29:13,320 --> 00:29:16,560
work that doesn't work for me then you

00:29:14,910 --> 00:29:18,630
don't include the compiler flags which

00:29:16,560 --> 00:29:20,190
may be kind of tickling that bug it

00:29:18,630 --> 00:29:22,920
could be very difficult for the compiler

00:29:20,190 --> 00:29:24,900
vendor to reproduce so two tools that

00:29:22,920 --> 00:29:27,090
work really well there's this open

00:29:24,900 --> 00:29:32,490
source utility called bear that hooks

00:29:27,090 --> 00:29:33,990
make so you can say yeah you basically

00:29:32,490 --> 00:29:36,930
when you're building the kernel you say

00:29:33,990 --> 00:29:38,910
bear and then your build command for

00:29:36,930 --> 00:29:40,800
building the kernel it dumps a JSON file

00:29:38,910 --> 00:29:42,540
that just has these triples of what's

00:29:40,800 --> 00:29:44,520
the translation unit what's the exact

00:29:42,540 --> 00:29:48,379
flags that were passed to the compiler

00:29:44,520 --> 00:29:51,179
and what's the output file if you want

00:29:48,379 --> 00:29:52,289
kind of thing but the colonel if you

00:29:51,179 --> 00:29:54,539
don't want to use bear the colonel

00:29:52,289 --> 00:29:57,960
already today generates these dot

00:29:54,539 --> 00:30:01,019
translation unit like file name dot CMD

00:29:57,960 --> 00:30:02,730
files wherever your your output is so

00:30:01,019 --> 00:30:04,529
wherever your dot o files are you'll

00:30:02,730 --> 00:30:05,879
have these kind of hidden dot command

00:30:04,529 --> 00:30:08,039
files and if you actually open those up

00:30:05,879 --> 00:30:12,179
and take a look the colonel does record

00:30:08,039 --> 00:30:14,190
the exact compiler Flags passed to the

00:30:12,179 --> 00:30:18,509
compiler and those are super super

00:30:14,190 --> 00:30:20,190
helpful and important as well some code

00:30:18,509 --> 00:30:23,970
that we've seen that's been problematic

00:30:20,190 --> 00:30:26,970
in the past for clang in particular was

00:30:23,970 --> 00:30:29,460
variable a variable length of rays but

00:30:26,970 --> 00:30:33,059
more so when they were used within the

00:30:29,460 --> 00:30:34,679
definition of a structure so luckily

00:30:33,059 --> 00:30:37,409
they're all gone entirely out of the

00:30:34,679 --> 00:30:39,450
kernel case and many other folks have

00:30:37,409 --> 00:30:41,970
been working on eliminating them

00:30:39,450 --> 00:30:46,669
entirely and now we actually warned if

00:30:41,970 --> 00:30:48,840
we see them so to clarify

00:30:46,669 --> 00:30:50,159
variable-length arrays you can have at

00:30:48,840 --> 00:30:52,529
the end of a structure according to

00:30:50,159 --> 00:30:54,389
standard c GCC has an extension or you

00:30:52,529 --> 00:30:57,379
can actually have a verbal length array

00:30:54,389 --> 00:31:00,570
in the middle of a structure and that is

00:30:57,379 --> 00:31:02,009
I know that there's an L KML post from

00:31:00,570 --> 00:31:04,169
Lunas about how much he just likes it

00:31:02,009 --> 00:31:05,370
but apparently this is saying clang will

00:31:04,169 --> 00:31:06,210
never support because it's super

00:31:05,370 --> 00:31:07,620
complicated

00:31:06,210 --> 00:31:09,210
and according to case the code it

00:31:07,620 --> 00:31:11,610
generates happens to be really really

00:31:09,210 --> 00:31:15,000
awful as well so everyone wins from

00:31:11,610 --> 00:31:16,919
having this removed claim doesn't

00:31:15,000 --> 00:31:18,120
support nested functions not using the

00:31:16,919 --> 00:31:20,669
kernel it's not a big deal

00:31:18,120 --> 00:31:23,669
super easy fix anyways external market

00:31:20,669 --> 00:31:26,700
static done ----builtin constant P was

00:31:23,669 --> 00:31:28,019
something that's more of a polish and a

00:31:26,700 --> 00:31:30,960
bug when we go back to our priorities

00:31:28,019 --> 00:31:35,970
where we identified some differences

00:31:30,960 --> 00:31:38,340
between clang and GCC as far as wildly

00:31:35,970 --> 00:31:40,139
different edge cases where they differ

00:31:38,340 --> 00:31:42,720
in whether or not an integer constant

00:31:40,139 --> 00:31:45,059
expression is constant or not and very

00:31:42,720 --> 00:31:48,809
interesting use cases in the kernel I

00:31:45,059 --> 00:31:51,210
think we have a set of patches that that

00:31:48,809 --> 00:31:54,120
fixes the last incompatibilities here

00:31:51,210 --> 00:31:56,350
but that's been one that's been pretty

00:31:54,120 --> 00:31:59,700
tricky giving us a hard time

00:31:56,350 --> 00:32:01,900
Azzam go to today is not supported in

00:31:59,700 --> 00:32:04,120
LLVM but we're trying to help out with

00:32:01,900 --> 00:32:05,890
code review and get that feature landed

00:32:04,120 --> 00:32:08,140
as soon as possible

00:32:05,890 --> 00:32:10,360
we identified a few false false

00:32:08,140 --> 00:32:13,120
negatives like warnings that that don't

00:32:10,360 --> 00:32:15,610
look correct when when things aren't on

00:32:13,120 --> 00:32:18,700
fire I try to fix these up kind of thing

00:32:15,610 --> 00:32:20,830
on the Klang side but we have a pretty

00:32:18,700 --> 00:32:22,120
good knowledge of kind of what's missing

00:32:20,830 --> 00:32:24,400
or what's lacking there and climb them

00:32:22,120 --> 00:32:27,340
and can fix up and then when I was

00:32:24,400 --> 00:32:29,560
testing the yasm go-to patches in LLVM

00:32:27,340 --> 00:32:31,270
one of the I found this like curiously

00:32:29,560 --> 00:32:33,280
recurring pattern that was a little

00:32:31,270 --> 00:32:37,030
tricky where the kernel in a couple of

00:32:33,280 --> 00:32:39,430
places has these static functions that

00:32:37,030 --> 00:32:42,340
are marked always in line and they

00:32:39,430 --> 00:32:46,380
contain inline assembly code and the

00:32:42,340 --> 00:32:48,940
inline assembly has some constraints on

00:32:46,380 --> 00:32:53,440
the parameters going to the azan block

00:32:48,940 --> 00:32:56,410
and it turns out that when you compile

00:32:53,440 --> 00:32:59,080
this code with GCC 802 it's there's no

00:32:56,410 --> 00:33:02,320
issue if you compile it with GCC at zero

00:32:59,080 --> 00:33:04,420
it says this is semantically incorrect

00:33:02,320 --> 00:33:06,940
and it's a build error so there's places

00:33:04,420 --> 00:33:11,860
in the kernel that only can compile in

00:33:06,940 --> 00:33:14,410
GCC at o2 and the issue there is this is

00:33:11,860 --> 00:33:15,760
an issue for clang because clang when I

00:33:14,410 --> 00:33:17,590
talk about that pre-staged pipeline in

00:33:15,760 --> 00:33:20,320
the beginning semantic analysis is

00:33:17,590 --> 00:33:22,570
handled early on in the in the the front

00:33:20,320 --> 00:33:25,570
end of the compiler inlining is part of

00:33:22,570 --> 00:33:27,460
the optimizer and so if you require code

00:33:25,570 --> 00:33:29,890
to be inlined first for it to be

00:33:27,460 --> 00:33:32,280
semantically correct that's a problem

00:33:29,890 --> 00:33:32,280
for flying

00:33:58,410 --> 00:34:09,480
right right right yes so so I don't know

00:34:07,050 --> 00:34:12,630
the the the questions are on built-in

00:34:09,480 --> 00:34:16,590
constant P and one of the many education

00:34:12,630 --> 00:34:18,179
so my understanding is that we've kind

00:34:16,590 --> 00:34:20,820
of identified these problematic use

00:34:18,179 --> 00:34:23,550
cases today in the kernel in like the

00:34:20,820 --> 00:34:26,030
test suite for this these set of changes

00:34:23,550 --> 00:34:28,530
going into clang and LLVM right now

00:34:26,030 --> 00:34:32,040
actually use these instances from the

00:34:28,530 --> 00:34:34,020
kernel as their test cases and I believe

00:34:32,040 --> 00:34:41,429
that they're all being addressed in the

00:34:34,020 --> 00:34:43,500
in the current patch side there were

00:34:41,429 --> 00:34:47,940
there were many moving pieces in the

00:34:43,500 --> 00:34:50,190
patch set as far as when exactly we

00:34:47,940 --> 00:34:52,290
evaluate whether something is considered

00:34:50,190 --> 00:34:55,280
constant or not but it did require

00:34:52,290 --> 00:34:58,140
adding various intrinsics to the

00:34:55,280 --> 00:35:00,120
intermediary representation to kind of

00:34:58,140 --> 00:35:03,360
support this notion better and it

00:35:00,120 --> 00:35:04,320
actually served dual purposes because my

00:35:03,360 --> 00:35:07,650
understanding is through slimming

00:35:04,320 --> 00:35:11,450
changes coming in C++ xx that can build

00:35:07,650 --> 00:35:14,750
off of this work related to con sex work

00:35:11,450 --> 00:35:14,750
that's my

00:35:17,480 --> 00:35:21,740
and I just wanted to say thanks for

00:35:20,030 --> 00:35:26,059
everyone who's been helping us out with

00:35:21,740 --> 00:35:28,160
this on our github we have an

00:35:26,059 --> 00:35:29,900
organization and I try to invite as many

00:35:28,160 --> 00:35:32,210
people to it that have you know helped

00:35:29,900 --> 00:35:34,069
out in some way or another and it's too

00:35:32,210 --> 00:35:36,109
bad by default it's private because we

00:35:34,069 --> 00:35:39,200
have over 40 people kind of helping out

00:35:36,109 --> 00:35:40,910
kind of thing so you know we're super

00:35:39,200 --> 00:35:42,260
lucky to be here talking about all this

00:35:40,910 --> 00:35:43,970
work but it's been a lot of work by a

00:35:42,260 --> 00:35:45,710
lot of different people

00:35:43,970 --> 00:35:47,390
I'm just curious show of hands cuz

00:35:45,710 --> 00:35:51,890
anyone here tried to build their kernel

00:35:47,390 --> 00:35:57,799
with Cline ok I think I think that's I

00:35:51,890 --> 00:35:58,880
I'm overjoyed to see that I think one of

00:35:57,799 --> 00:36:00,230
the things that that always breaks my

00:35:58,880 --> 00:36:01,970
heart is when we send a patch to a

00:36:00,230 --> 00:36:04,940
maintainer they say I don't care about

00:36:01,970 --> 00:36:08,410
climb well I think we can kind of say

00:36:04,940 --> 00:36:08,410
well a lot of other people do

00:36:09,270 --> 00:36:16,710
[Applause]

00:36:32,140 --> 00:36:37,130
the question was how how often do you

00:36:34,729 --> 00:36:39,499
actually update the toolchain for AOSP

00:36:37,130 --> 00:36:42,349
for LOV M if I'm going to look to use

00:36:39,499 --> 00:36:44,329
that for building yeah so I think we're

00:36:42,349 --> 00:36:47,390
looking to get to improve the process

00:36:44,329 --> 00:36:51,259
around the release cycle for the LOV M

00:36:47,390 --> 00:36:54,769
pre-built in AOSP I would like to get to

00:36:51,259 --> 00:36:56,900
a maybe six-week cadence kind of thing

00:36:54,769 --> 00:36:59,329
and then it's even important for us to

00:36:56,900 --> 00:37:01,489
kind of provide this information to the

00:36:59,329 --> 00:37:04,519
various vendors in the Android ecosystem

00:37:01,489 --> 00:37:06,289
saying hey this new tool chain like

00:37:04,519 --> 00:37:08,630
we've done significant testing on it

00:37:06,289 --> 00:37:11,630
with our device kernels and internally

00:37:08,630 --> 00:37:14,299
in AOSP common and we we believe this to

00:37:11,630 --> 00:37:16,549
be a high-quality tool chain release we

00:37:14,299 --> 00:37:18,829
would like you to go out and test it and

00:37:16,549 --> 00:37:21,709
we're reporting bugs so we're looking to

00:37:18,829 --> 00:37:23,589
start doing a six-week release cadence

00:37:21,709 --> 00:37:27,440
we've done a lot of work to catch

00:37:23,589 --> 00:37:29,329
androids LVM up to near top of tree

00:37:27,440 --> 00:37:31,459
hello VM and there's still more work

00:37:29,329 --> 00:37:33,380
we're gonna do there I would say the big

00:37:31,459 --> 00:37:36,019
thing with the the Android prebuilt s--

00:37:33,380 --> 00:37:37,910
the whole reason why they exist is just

00:37:36,019 --> 00:37:40,430
to have a different release schedule

00:37:37,910 --> 00:37:42,619
than the upstream LLVM you don't try to

00:37:40,430 --> 00:37:45,799
put proprietary stuff in the compiler

00:37:42,619 --> 00:37:47,539
ever instead when we need a feature for

00:37:45,799 --> 00:37:49,849
the kernel or for some other part of the

00:37:47,539 --> 00:37:54,009
platform we want to put a binary out

00:37:49,849 --> 00:37:54,009
there so people can go forth and test

00:38:06,770 --> 00:38:11,400
from a learning perspective is there a

00:38:09,270 --> 00:38:13,980
library of examples I can look up off

00:38:11,400 --> 00:38:21,920
you know this case works well on GCC but

00:38:13,980 --> 00:38:24,450
throws a warning in clang I would say so

00:38:21,920 --> 00:38:26,160
when we talked earlier about like the

00:38:24,450 --> 00:38:27,750
additional warning coverage my kind of

00:38:26,160 --> 00:38:30,810
link in my head I picture warning

00:38:27,750 --> 00:38:34,320
coverage as like a Venn diagram of you

00:38:30,810 --> 00:38:36,780
know there's the all the different kinds

00:38:34,320 --> 00:38:40,200
of warnings like explicitly named flags

00:38:36,780 --> 00:38:43,350
that are - W flags and I think there's a

00:38:40,200 --> 00:38:45,870
very large overlap between warnings that

00:38:43,350 --> 00:38:50,220
are implemented both in GCC and in clang

00:38:45,870 --> 00:38:52,170
I would say there's then separate or

00:38:50,220 --> 00:38:55,620
unique parts of those those those two

00:38:52,170 --> 00:38:57,540
overlap those two circles where you have

00:38:55,620 --> 00:39:00,930
flags that are unique to GCC and flags

00:38:57,540 --> 00:39:04,320
that are unique to climb so from like a

00:39:00,930 --> 00:39:06,780
warning perspective best thing that I've

00:39:04,320 --> 00:39:09,090
seen so far is I think somebody has a a

00:39:06,780 --> 00:39:10,470
github page where they keep track of you

00:39:09,090 --> 00:39:13,440
know which flags are unique to which

00:39:10,470 --> 00:39:15,900
compiler kind of thing as far as code

00:39:13,440 --> 00:39:18,030
gen goes if people can find them like

00:39:15,900 --> 00:39:19,680
let us know cuz that's a bug on our on

00:39:18,030 --> 00:39:22,040
our side in LOV on that we should be

00:39:19,680 --> 00:39:22,040
fixing

00:39:27,670 --> 00:39:32,650
you should a list of architectures that

00:39:29,559 --> 00:39:34,630
you plan to build regularly one of them

00:39:32,650 --> 00:39:39,460
that I'd really like to see there would

00:39:34,630 --> 00:39:41,170
be hexagon which is not nobody not a lot

00:39:39,460 --> 00:39:42,970
of people use it but it's the one

00:39:41,170 --> 00:39:45,130
architecture that does have a clang

00:39:42,970 --> 00:39:47,950
support upstream but no GCC support in

00:39:45,130 --> 00:39:51,220
mainland okay yeah I think I think

00:39:47,950 --> 00:39:52,660
there's like we we posted the list of

00:39:51,220 --> 00:39:55,420
the kind of architectures that we're

00:39:52,660 --> 00:39:57,549
focused on but we in no way we don't

00:39:55,420 --> 00:39:59,500
mean to discourage any of the other

00:39:57,549 --> 00:40:01,960
architectures and in fact I'm trying to

00:39:59,500 --> 00:40:03,760
help enable external contributors who

00:40:01,960 --> 00:40:05,619
have more resources to work on these

00:40:03,760 --> 00:40:07,119
various architectures to help enable

00:40:05,619 --> 00:40:09,849
them be successful in compiling their

00:40:07,119 --> 00:40:12,579
kernels with clang so if someone has any

00:40:09,849 --> 00:40:13,630
architecture that's not on that list one

00:40:12,579 --> 00:40:17,020
of the ways that you could really help

00:40:13,630 --> 00:40:19,119
out is is helping us let us know what

00:40:17,020 --> 00:40:19,540
we're missing today or if we're good to

00:40:19,119 --> 00:40:21,369
go

00:40:19,540 --> 00:40:24,839
helping us wire that up into the

00:40:21,369 --> 00:40:24,839
continuous integrations and systems

00:40:32,210 --> 00:40:34,240
Oh

00:40:38,510 --> 00:40:42,900
we're starting to get a few kernel

00:40:40,829 --> 00:40:45,359
options that depend on GCC plugins

00:40:42,900 --> 00:40:50,190
what's the clang solution for those

00:40:45,359 --> 00:40:53,309
gonna be yeah I think I don't have a

00:40:50,190 --> 00:40:56,700
solution for that today I I think some

00:40:53,309 --> 00:41:00,480
of the GCC plugins are are tricky I

00:40:56,700 --> 00:41:03,539
think it's it's good to think about what

00:41:00,480 --> 00:41:05,460
the plugin is trying to do like is this

00:41:03,539 --> 00:41:07,410
something that is better implemented as

00:41:05,460 --> 00:41:09,270
a compiler flag if possible because some

00:41:07,410 --> 00:41:11,880
people use the plug-in system as a way

00:41:09,270 --> 00:41:15,210
of kind of prototyping a new option on

00:41:11,880 --> 00:41:16,770
top of of the compiler rather than like

00:41:15,210 --> 00:41:18,930
forking the source and trying to build

00:41:16,770 --> 00:41:20,970
something into a source like that

00:41:18,930 --> 00:41:24,329
I think GCC plugins are gonna be

00:41:20,970 --> 00:41:26,039
problematic for people as far as even

00:41:24,329 --> 00:41:27,420
like which version of GCC they're using

00:41:26,039 --> 00:41:29,640
they're gonna need to heavily plug-in

00:41:27,420 --> 00:41:32,640
binary compatibility between those but

00:41:29,640 --> 00:41:34,530
there's like GCC plugins are the

00:41:32,640 --> 00:41:36,859
ultimate non portable solution to

00:41:34,530 --> 00:41:36,859
problems

00:41:41,240 --> 00:41:48,080
because just a further thing does LLVM

00:41:43,860 --> 00:41:48,080
have a plug-in system comparable yes

00:42:04,280 --> 00:42:09,480
something I had last tried building with

00:42:07,530 --> 00:42:11,310
clang doing all her n config dolls and

00:42:09,480 --> 00:42:14,070
fixing the things I found a couple of

00:42:11,310 --> 00:42:15,330
months ago and there was still thousands

00:42:14,070 --> 00:42:17,700
of warning so whatever you've done in

00:42:15,330 --> 00:42:21,260
the last two or three months it has been

00:42:17,700 --> 00:42:21,260
amazing because I've just done it again

00:42:24,110 --> 00:42:30,330
no but even last week I tried it again

00:42:26,580 --> 00:42:32,400
and it didn't build today's release I

00:42:30,330 --> 00:42:42,050
get like two pages of warnings and

00:42:32,400 --> 00:42:42,050
they're all bugs in the kernel yeah

00:42:43,610 --> 00:42:52,500
tests like clang analyzer has a lot of

00:42:49,830 --> 00:42:57,480
interesting things for resource leaks

00:42:52,500 --> 00:43:00,510
with you know Lipsy file and whatnot you

00:42:57,480 --> 00:43:03,210
guys consider adding that for kernel

00:43:00,510 --> 00:43:04,710
locking semantics for example yeah so so

00:43:03,210 --> 00:43:06,450
the the kernel blocking semantics stuff

00:43:04,710 --> 00:43:09,330
is super interesting because that's

00:43:06,450 --> 00:43:11,670
actually like static annotations so in

00:43:09,330 --> 00:43:13,740
your source code you can say like you

00:43:11,670 --> 00:43:16,650
must acquire this mutex to touch these

00:43:13,740 --> 00:43:19,500
members of this struct and we use it

00:43:16,650 --> 00:43:21,360
internally in Google 3 C++ code very

00:43:19,500 --> 00:43:23,460
very successfully and it works very very

00:43:21,360 --> 00:43:26,190
well and that's orthogonal to the static

00:43:23,460 --> 00:43:29,760
analyzer so the the lock checking stuff

00:43:26,190 --> 00:43:31,200
I think will be super important in order

00:43:29,760 --> 00:43:33,510
to help prevent some of the concurrency

00:43:31,200 --> 00:43:35,730
bugs that we get bit by especially in

00:43:33,510 --> 00:43:38,250
out of treat code kind of again and

00:43:35,730 --> 00:43:39,570
again and again and again and again I'm

00:43:38,250 --> 00:43:41,820
trying to get an intern right now to

00:43:39,570 --> 00:43:43,830
help test this out and see is this

00:43:41,820 --> 00:43:45,809
something that will work as a solution

00:43:43,830 --> 00:43:47,609
or not

00:43:45,809 --> 00:43:51,059
if anyone's interested reach out to me

00:43:47,609 --> 00:43:53,009
let me know so I actually did look at a

00:43:51,059 --> 00:43:55,319
very simple invitation that's basically

00:43:53,009 --> 00:43:57,449
having the Clank of Pilar headers

00:43:55,319 --> 00:44:01,349
redefined like underscore underscore

00:43:57,449 --> 00:44:04,829
requires to use the clang annotations

00:44:01,349 --> 00:44:06,630
the challenge I had is that clang get to

00:44:04,829 --> 00:44:08,400
say this this thing is what's called a

00:44:06,630 --> 00:44:09,779
mutex class and so forth and I'm gonna

00:44:08,400 --> 00:44:12,619
be a little fuzzy here cuz I had tried

00:44:09,779 --> 00:44:15,509
this a couple years ago um it needs very

00:44:12,619 --> 00:44:19,400
precise semantics about what a mutex is

00:44:15,509 --> 00:44:21,359
and what you lock and the Linux kernel

00:44:19,400 --> 00:44:23,910
annotations are a little bit looser than

00:44:21,359 --> 00:44:27,479
what clang is looking for so a drop in

00:44:23,910 --> 00:44:29,489
just header did not work but I think

00:44:27,479 --> 00:44:31,229
it's an interesting idea that I'm glad

00:44:29,489 --> 00:44:34,170
he has an intern that's looking to carry

00:44:31,229 --> 00:44:35,759
it forward or is looking for one so so

00:44:34,170 --> 00:44:38,249
just to talk a little bit more about the

00:44:35,759 --> 00:44:39,239
lock the static lock annotations like in

00:44:38,249 --> 00:44:41,849
Google 3 if you're writing

00:44:39,239 --> 00:44:43,920
multi-threaded C++ and you you have

00:44:41,849 --> 00:44:46,109
these start adding these annotations and

00:44:43,920 --> 00:44:48,989
you maybe had some code that's slightly

00:44:46,109 --> 00:44:51,390
incorrect you'll get a compile time

00:44:48,989 --> 00:44:53,369
error saying you should have acquired

00:44:51,390 --> 00:44:55,109
this lock or hey you acquired these

00:44:53,369 --> 00:44:56,999
locks in different orders and this will

00:44:55,109 --> 00:44:59,069
lead to a deadlock I want that in the

00:44:56,999 --> 00:45:00,749
kernel right you should figure out how

00:44:59,069 --> 00:45:03,439
to adapt this to work well on C code in

00:45:00,749 --> 00:45:05,519
the kernel and have build time errors

00:45:03,439 --> 00:45:07,769
the other part of that it's a static

00:45:05,519 --> 00:45:09,989
analyzer the whole reason I got involved

00:45:07,769 --> 00:45:11,939
in it in any of this was I just wanted

00:45:09,989 --> 00:45:13,829
to run the static analyzer on the Linux

00:45:11,939 --> 00:45:16,380
kernel to find bugs to fix the start

00:45:13,829 --> 00:45:18,359
contributing and eventually I went down

00:45:16,380 --> 00:45:20,130
this rabbit hole of my god we just need

00:45:18,359 --> 00:45:21,359
to get it building because all this like

00:45:20,130 --> 00:45:23,099
as I started talking with more and more

00:45:21,359 --> 00:45:26,640
people that were looking to do all these

00:45:23,099 --> 00:45:27,929
cool additional compiler features all of

00:45:26,640 --> 00:45:30,029
this was predicated on building the

00:45:27,929 --> 00:45:31,650
kernel with client that's why I say ok

00:45:30,029 --> 00:45:33,509
we'll put the static analysis stuff I

00:45:31,650 --> 00:45:35,969
want to do on the shelf for another day

00:45:33,509 --> 00:45:37,849
and let's focus on getting it compiling

00:45:35,969 --> 00:45:40,199
and running well and working for people

00:45:37,849 --> 00:45:45,269
so I think that that's a big thing for

00:45:40,199 --> 00:45:47,330
us is getting people the option to be

00:45:45,269 --> 00:45:52,270
able to rapidly change between

00:45:47,330 --> 00:45:52,270
for chains for solving problems

00:45:57,630 --> 00:46:00,390
all right I think we're at time so thank

00:45:59,430 --> 00:46:06,230
you very much

00:46:00,390 --> 00:46:06,230

YouTube URL: https://www.youtube.com/watch?v=SSWUrWqnSz0


