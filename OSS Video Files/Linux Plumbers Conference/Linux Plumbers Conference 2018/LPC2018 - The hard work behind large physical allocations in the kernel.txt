Title: LPC2018 - The hard work behind large physical allocations in the kernel
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/65/
speaker:  Vlastimil Babka (SUSE)


The physical memory management in the Linux kernel is mostly based on single page allocations, but there are many situations where a larger physically continuous memory needs to be allocated. Some are for the benefit of userspace (e.g. huge pages), others for better performance in the kernel (SLAB/SLUB, networking, and others).

Making sure that contiguous physical memory is available for allocation is far from trivial, as pages are reclaimed for reuse roughly in last-recently-used (LRU) order, which is typically different from their physical placement. The freed memory is thus fragmented. The kernel has two complementary mechanisms to defragment the free memory. One is memory compaction, which migrates used pages to make the free pages contiguous. The other is page grouping by mobility, which tries to make sure that pages that cannot be migrated are grouped together, so the rest of pages can be effectively compacted. Both mechanisms employ various heuristics to balance the success of large allocations, and their overhead in terms of latencies due to processor and lock usage.

The talk will discuss the two mechanisms, focusing on the known problems and their possible solutions, that have been proposed by several memory management developers.
Captions: 
	00:00:06,380 --> 00:00:15,500
my name is rusty mill Bobkov I work in

00:00:10,010 --> 00:00:20,649
prog forces elapse memory management

00:00:15,500 --> 00:00:24,610
topics and yeah this is kind of my

00:00:20,649 --> 00:00:28,700
favorite topic in the memory management

00:00:24,610 --> 00:00:31,610
for the past several years now when I'm

00:00:28,700 --> 00:00:37,130
not working on meltdown and specter back

00:00:31,610 --> 00:00:39,670
ports and stuff like that so mmm some of

00:00:37,130 --> 00:00:43,070
you might be might have been yesterday

00:00:39,670 --> 00:00:47,570
on the station promoting huge page

00:00:43,070 --> 00:00:51,440
usages so this session kind of

00:00:47,570 --> 00:00:56,000
complements it with enabling huge page

00:00:51,440 --> 00:00:58,910
news pages I will explain what we do in

00:00:56,000 --> 00:01:02,780
the kernel to make the huge pages

00:00:58,910 --> 00:01:06,500
available why is it not easy what are

00:01:02,780 --> 00:01:14,920
the open issues and possible solutions

00:01:06,500 --> 00:01:18,170
to those open issues so start with how

00:01:14,920 --> 00:01:24,140
physical memory pages are allocated in

00:01:18,170 --> 00:01:27,049
the Linux kernel at first level we have

00:01:24,140 --> 00:01:30,200
Numa notes then those could be divided

00:01:27,049 --> 00:01:33,409
to several zones or just a single zone

00:01:30,200 --> 00:01:37,700
and each zone has something called

00:01:33,409 --> 00:01:43,040
binary body a locator which is managing

00:01:37,700 --> 00:01:47,780
all almost all pages except some special

00:01:43,040 --> 00:01:52,430
ones and gives them out in response to a

00:01:47,780 --> 00:01:57,130
lock pages calls and then freeze them in

00:01:52,430 --> 00:01:57,130
response to three pages calls and

00:01:57,490 --> 00:02:06,920
internally it manages the pages in a way

00:02:02,240 --> 00:02:11,090
that that when it's possible larger

00:02:06,920 --> 00:02:13,969
pages are callers to the grader from

00:02:11,090 --> 00:02:18,790
smaller pages so they can be immediately

00:02:13,969 --> 00:02:22,760
available up to four megabyte size

00:02:18,790 --> 00:02:27,500
so if we didn't care what we could have

00:02:22,760 --> 00:02:31,790
is just a free list that would link

00:02:27,500 --> 00:02:36,709
together the individual based pages of

00:02:31,790 --> 00:02:40,250
four kilobyte but because we do care in

00:02:36,709 --> 00:02:45,290
fact we have multiple free lists the

00:02:40,250 --> 00:02:49,670
free list in index zero is as a linked

00:02:45,290 --> 00:02:54,380
list of order zero pages just the four

00:02:49,670 --> 00:02:58,310
kilobyte free list one has double the

00:02:54,380 --> 00:03:02,260
size release to us again double size and

00:02:58,310 --> 00:03:06,940
so on and because alignment also matters

00:03:02,260 --> 00:03:11,030
these these two pages are contiguous but

00:03:06,940 --> 00:03:16,660
not aligned to eight kilobytes so they

00:03:11,030 --> 00:03:23,150
remain as order zero four kilobyte pages

00:03:16,660 --> 00:03:26,720
and yeah the reason we do this is that

00:03:23,150 --> 00:03:30,260
if we need a larger page we can

00:03:26,720 --> 00:03:34,160
immediately go to the proper sized list

00:03:30,260 --> 00:03:42,260
and get it instantly no searching in

00:03:34,160 --> 00:03:46,190
bitmaps or whatever and of course it's

00:03:42,260 --> 00:03:49,820
not so easy because sometimes the high

00:03:46,190 --> 00:03:52,609
order pages won't want to appear on the

00:03:49,820 --> 00:03:55,420
lists because the free memory is

00:03:52,609 --> 00:03:59,799
fragmented between lots of smaller pages

00:03:55,420 --> 00:04:03,380
so in this case we have nine pages free

00:03:59,799 --> 00:04:08,989
but no order three page which would be

00:04:03,380 --> 00:04:12,500
eight pages 16 kilobyte I think cannot

00:04:08,989 --> 00:04:17,049
be allocated even though there's more

00:04:12,500 --> 00:04:19,639
free memory why do actually need this

00:04:17,049 --> 00:04:22,729
so-called high order allocation which

00:04:19,639 --> 00:04:26,539
means more than the four kilobyte order

00:04:22,729 --> 00:04:31,160
zero yeah we had the discussion about

00:04:26,539 --> 00:04:35,390
each pages yesterday user space one

00:04:31,160 --> 00:04:43,130
huge pages transparent huge pages or

00:04:35,390 --> 00:04:45,980
huge TLB FS in the case of x86 the huge

00:04:43,130 --> 00:04:49,940
page size is 2 megabytes which is order

00:04:45,980 --> 00:04:54,160
9 in this scheme 1 gigabyte would be

00:04:49,940 --> 00:04:59,030
order 18 but the maximum we support is

00:04:54,160 --> 00:05:02,090
order 10 so these gigantic huge pages

00:04:59,030 --> 00:05:05,390
have to be allocated with something

00:05:02,090 --> 00:05:08,450
similar to CMA which was already a to

00:05:05,390 --> 00:05:12,920
pick here and I won't go into detail

00:05:08,450 --> 00:05:15,860
about that but you see ma is similar to

00:05:12,920 --> 00:05:20,950
compaction as and has many of the

00:05:15,860 --> 00:05:24,470
problems I will explain later as well

00:05:20,950 --> 00:05:28,820
which pages are one thing then we might

00:05:24,470 --> 00:05:31,630
need like physically contiguous areas of

00:05:28,820 --> 00:05:35,960
memory in the kernel for other reasons

00:05:31,630 --> 00:05:40,000
because hardware that doesn't support

00:05:35,960 --> 00:05:44,540
skater Gator needs physically Alek use

00:05:40,000 --> 00:05:50,000
continues areas to work sometimes there

00:05:44,540 --> 00:05:54,290
are discussions about increasing the

00:05:50,000 --> 00:05:57,590
page cache based size - for example 64

00:05:54,290 --> 00:06:01,570
kilobytes because the new drives would

00:05:57,590 --> 00:06:05,170
benefit from that more and that would be

00:06:01,570 --> 00:06:10,130
another case of larger order allocation

00:06:05,170 --> 00:06:13,040
sometimes we just care about the the

00:06:10,130 --> 00:06:16,340
pages the memory being virtually

00:06:13,040 --> 00:06:20,240
contiguous not physically contiguous but

00:06:16,340 --> 00:06:24,050
it's simpler to just allocate large

00:06:20,240 --> 00:06:27,110
physically continuous page because that

00:06:24,050 --> 00:06:32,440
implies it's also virtually contiguous

00:06:27,110 --> 00:06:35,870
into direct mapping the kernel uses and

00:06:32,440 --> 00:06:38,360
examples were the kernel stacks until

00:06:35,870 --> 00:06:43,389
they have been recently converted to the

00:06:38,360 --> 00:06:48,580
analog slop especially to

00:06:43,389 --> 00:06:52,599
we do you like to use larger pages for

00:06:48,580 --> 00:06:57,789
performance reasons because overhead of

00:06:52,599 --> 00:07:01,360
allocation is spread over more objects

00:06:57,789 --> 00:07:06,340
and that improves the performance but if

00:07:01,360 --> 00:07:09,729
it cannot get a large pages it will fall

00:07:06,340 --> 00:07:15,759
back to smaller ones which is generally

00:07:09,729 --> 00:07:19,779
advisable we cannot still guarantee all

00:07:15,759 --> 00:07:24,370
the alligators in the kernel that they

00:07:19,779 --> 00:07:31,900
will always be available or able to get

00:07:24,370 --> 00:07:34,360
a high order page and yeah for the if if

00:07:31,900 --> 00:07:38,199
we only want the truly contiguous memory

00:07:34,360 --> 00:07:42,330
the alternative is to use VM a lock like

00:07:38,199 --> 00:07:47,560
the kernels text already started to do

00:07:42,330 --> 00:07:49,960
which also isn't for free that's why we

00:07:47,560 --> 00:07:54,550
don't use it everywhere because the

00:07:49,960 --> 00:07:57,789
emilich means that special reserved

00:07:54,550 --> 00:08:01,360
virtual area has to be populated with

00:07:57,789 --> 00:08:05,580
page tables in a way so that it looks

00:08:01,360 --> 00:08:09,190
virtually contiguous but it's made of

00:08:05,580 --> 00:08:11,650
separated by spaces so that's overhead

00:08:09,190 --> 00:08:15,930
in there and we also lose the

00:08:11,650 --> 00:08:15,930
performance of the direct mapping which

00:08:16,050 --> 00:08:26,740
internally we will use huge kind of huge

00:08:21,819 --> 00:08:30,039
pages itself like only fewer levels of

00:08:26,740 --> 00:08:34,620
page tables and with VM alaq we are down

00:08:30,039 --> 00:08:40,000
to all the five page levels these days

00:08:34,620 --> 00:08:43,839
so it's somewhat discouraged just to use

00:08:40,000 --> 00:08:48,149
it and forget out the issue it's better

00:08:43,839 --> 00:08:52,110
if if you are able to avoid needing

00:08:48,149 --> 00:08:55,570
large contiguous area of memory at all

00:08:52,110 --> 00:08:59,769
but if you need it we

00:08:55,570 --> 00:09:02,110
also now have a new kv malik helper that

00:08:59,769 --> 00:09:05,730
will first try the higher order

00:09:02,110 --> 00:09:10,540
allocation and if it fails it falls down

00:09:05,730 --> 00:09:13,899
to the vm Alok and the solder GFP flock

00:09:10,540 --> 00:09:19,329
if likes magic for you so you don't have

00:09:13,899 --> 00:09:23,880
get spurious warnings and so on yeah

00:09:19,329 --> 00:09:28,600
this is an example of what happens if a

00:09:23,880 --> 00:09:32,649
driver is not able to deal with failed

00:09:28,600 --> 00:09:36,269
high order allocation so that was Chrome

00:09:32,649 --> 00:09:41,680
browser trying to do order for

00:09:36,269 --> 00:09:47,079
allocation and yeah we could see that

00:09:41,680 --> 00:09:52,029
there's plenty of free memory like 100

00:09:47,079 --> 00:09:56,110
of for 250 megabytes but we could not

00:09:52,029 --> 00:09:58,660
allocate I think 64 kilobytes because of

00:09:56,110 --> 00:10:04,230
the fragmentation and in the list we

00:09:58,660 --> 00:10:09,250
also see that on the lists of the orders

00:10:04,230 --> 00:10:15,579
for 64 kilobyte and more there will be

00:10:09,250 --> 00:10:18,130
only 1 or 0 available pages and there's

00:10:15,579 --> 00:10:20,860
also some kind of watermark protection

00:10:18,130 --> 00:10:22,959
that cannot allow the process to

00:10:20,860 --> 00:10:27,040
actually deplete them so even if there's

00:10:22,959 --> 00:10:31,660
one it could not be allocated and the

00:10:27,040 --> 00:10:35,529
result was that the Radeon driver wasn't

00:10:31,660 --> 00:10:39,959
happy and I think he did a chrome or or

00:10:35,529 --> 00:10:46,870
the wholly crashed as the result of this

00:10:39,959 --> 00:10:48,990
so so that's that's something we don't

00:10:46,870 --> 00:10:48,990
like

00:10:55,480 --> 00:11:04,130
so here speech allocated does like

00:11:01,300 --> 00:11:08,780
changes behavior on the order three less

00:11:04,130 --> 00:11:13,790
is there any like logic behind that or

00:11:08,780 --> 00:11:16,100
it's just historical it was for order

00:11:13,790 --> 00:11:20,060
for is like the cost a order

00:11:16,100 --> 00:11:24,550
yeah the costly order is lesson if it's

00:11:20,060 --> 00:11:28,870
less than 3 then 4 then we actually

00:11:24,550 --> 00:11:32,960
guarantee that there will be no failure

00:11:28,870 --> 00:11:37,690
except some special cases so that's not

00:11:32,960 --> 00:11:40,990
a real guarantee but in practice we had

00:11:37,690 --> 00:11:44,140
the authors of the code won't notice

00:11:40,990 --> 00:11:47,030
that they don't have a good fallback

00:11:44,140 --> 00:11:49,790
until the special conditions happen and

00:11:47,030 --> 00:11:53,770
they get a null pointer is there any

00:11:49,790 --> 00:11:56,900
like reasoning behind order tree or just

00:11:53,770 --> 00:12:00,560
historical thing like this is small

00:11:56,900 --> 00:12:03,860
enough so if you free the memory it will

00:12:00,560 --> 00:12:05,980
always you will be always lucky and some

00:12:03,860 --> 00:12:08,660
of the pages will appear there or if you

00:12:05,980 --> 00:12:13,040
continue reclaiming more they will

00:12:08,660 --> 00:12:16,690
appear sooner or later and it's hard to

00:12:13,040 --> 00:12:20,900
change it once once it becomes

00:12:16,690 --> 00:12:26,030
historical thing in sessions at Ellis

00:12:20,900 --> 00:12:29,990
mmm multiple ones about these non

00:12:26,030 --> 00:12:34,210
failing allocations and the result is

00:12:29,990 --> 00:12:34,210
that it's too late to change it

00:12:36,350 --> 00:12:46,380
so what can we do to to have higher

00:12:43,410 --> 00:12:50,700
chance of these high order allocations

00:12:46,380 --> 00:12:52,589
succeeding we can the problem as I said

00:12:50,700 --> 00:12:56,520
was that the free memory becomes

00:12:52,589 --> 00:13:00,390
fragmented between large array audit

00:12:56,520 --> 00:13:03,630
that not contiguously free so we could

00:13:00,390 --> 00:13:06,029
try to avoid it which the body allocator

00:13:03,630 --> 00:13:11,190
in fact death does to some extent

00:13:06,029 --> 00:13:13,950
because when you ask for a small page it

00:13:11,190 --> 00:13:17,610
and it has the small page available it

00:13:13,950 --> 00:13:21,300
will give you a small page and if it has

00:13:17,610 --> 00:13:24,959
only larger pages like after the boot it

00:13:21,300 --> 00:13:27,690
will split the smallest available one so

00:13:24,959 --> 00:13:32,310
it doesn't fragment more than it's

00:13:27,690 --> 00:13:35,010
needed which is enough until the memory

00:13:32,310 --> 00:13:38,279
becomes full which however is something

00:13:35,010 --> 00:13:44,700
we want because unused memory is a state

00:13:38,279 --> 00:13:47,750
memory so so for most workloads most

00:13:44,700 --> 00:13:51,300
workloads you eventually end up with

00:13:47,750 --> 00:13:55,230
memory filled with page cache or slab

00:13:51,300 --> 00:13:58,170
caches and and then the body allocated

00:13:55,230 --> 00:14:04,290
design cannot help this anymore

00:13:58,170 --> 00:14:08,130
on its own and memory becomes full we

00:14:04,290 --> 00:14:12,930
reclaim it which is for the page cache

00:14:08,130 --> 00:14:15,779
based on LRU algorithm so we reclaim the

00:14:12,930 --> 00:14:20,579
pages that were not used by the

00:14:15,779 --> 00:14:26,010
processes for a long time which which

00:14:20,579 --> 00:14:29,670
means that from the point of the layout

00:14:26,010 --> 00:14:33,270
into memory we reclaim like random this

00:14:29,670 --> 00:14:36,149
page this page because the age of usage

00:14:33,270 --> 00:14:39,149
doesn't typically correspond to where

00:14:36,149 --> 00:14:42,480
they are located so we end up with three

00:14:39,149 --> 00:14:45,000
pages from all over the memory at some

00:14:42,480 --> 00:14:49,260
point something called lumpy reclaim

00:14:45,000 --> 00:14:52,640
existed that really said I'm reclaiming

00:14:49,260 --> 00:14:56,940
from this to there and that's a free

00:14:52,640 --> 00:15:01,020
contiguous area but because it went

00:14:56,940 --> 00:15:07,560
against the idea of the aging by least

00:15:01,020 --> 00:15:11,370
recent usage it was discarded in favor

00:15:07,560 --> 00:15:15,000
for the next thing which is memory

00:15:11,370 --> 00:15:16,890
compaction so the idea is that we have

00:15:15,000 --> 00:15:22,970
these scattered free pages everywhere

00:15:16,890 --> 00:15:30,120
and we migrate other pages around to

00:15:22,970 --> 00:15:35,370
make contiguous free areas so how memory

00:15:30,120 --> 00:15:39,300
compaction work is I think best seen on

00:15:35,370 --> 00:15:43,830
an example so we have to page scanners

00:15:39,300 --> 00:15:46,860
which go to the to the array of struct

00:15:43,830 --> 00:15:51,810
pages basically that represent the

00:15:46,860 --> 00:15:55,770
individual physical pages pfn meets

00:15:51,810 --> 00:15:59,130
means page frame number so that's like

00:15:55,770 --> 00:16:03,750
the physical number of the page and one

00:15:59,130 --> 00:16:07,170
scanner starts looking starts at the

00:16:03,750 --> 00:16:10,560
beginning of the zone and others scanner

00:16:07,170 --> 00:16:13,790
starts at the end of the zone and the

00:16:10,560 --> 00:16:19,770
free the my Great Migration scanner

00:16:13,790 --> 00:16:23,310
looks for pages to to migrate and the

00:16:19,770 --> 00:16:25,620
first page is see is a free page so it

00:16:23,310 --> 00:16:30,560
doesn't care about that there's nothing

00:16:25,620 --> 00:16:33,240
to migrate then it finds occupied page

00:16:30,560 --> 00:16:37,110
which belongs for example to the page

00:16:33,240 --> 00:16:42,830
cache so it can isolate it from the Ru

00:16:37,110 --> 00:16:46,050
list the private list and then it will

00:16:42,830 --> 00:16:48,630
isolate also lease to and skip the

00:16:46,050 --> 00:16:50,940
remaining three pages then it may

00:16:48,630 --> 00:16:55,250
encounter a page that cannot be isolated

00:16:50,940 --> 00:16:59,910
because it belongs to a slop for example

00:16:55,250 --> 00:17:03,100
so it can only skip it then it isolates

00:16:59,910 --> 00:17:05,330
the fourth page we

00:17:03,100 --> 00:17:08,480
let's say in this case that's the

00:17:05,330 --> 00:17:12,650
maximum so it switches to the free

00:17:08,480 --> 00:17:17,830
scanner which finds this this block of

00:17:12,650 --> 00:17:22,760
four free pages in this case and

00:17:17,830 --> 00:17:25,910
isolates them and because we have four

00:17:22,760 --> 00:17:30,440
to migrate and for free pages to migrate

00:17:25,910 --> 00:17:33,950
to we can do the migration so the data

00:17:30,440 --> 00:17:37,640
that was in this page is copied to this

00:17:33,950 --> 00:17:41,830
page and all the page tables of the

00:17:37,640 --> 00:17:47,450
processes that were using it are updated

00:17:41,830 --> 00:17:52,300
and yes so now we have four pages here

00:17:47,450 --> 00:17:56,000
contiguous and when we migrate the rest

00:17:52,300 --> 00:17:59,420
we now have eight pages so that's more

00:17:56,000 --> 00:18:03,460
than than the four that was here in the

00:17:59,420 --> 00:18:08,260
beginning so that's kind of success and

00:18:03,460 --> 00:18:11,540
we continue with the migration scanner

00:18:08,260 --> 00:18:15,620
isolate these two pages but soon run

00:18:11,540 --> 00:18:18,020
into the free scanner which means we

00:18:15,620 --> 00:18:21,050
know that we could not get any more free

00:18:18,020 --> 00:18:23,690
pages to migrate to because the free

00:18:21,050 --> 00:18:26,750
scanner already went through this part

00:18:23,690 --> 00:18:32,960
and that's when the compaction

00:18:26,750 --> 00:18:36,740
terminates so that's one reason where it

00:18:32,960 --> 00:18:42,140
can terminate another reason it's if we

00:18:36,740 --> 00:18:45,530
called compaction for an allocation that

00:18:42,140 --> 00:18:48,530
wanted these eight three three pages

00:18:45,530 --> 00:18:51,620
contiguous then we would have already

00:18:48,530 --> 00:18:56,560
stopped after creating it and the

00:18:51,620 --> 00:19:01,460
allocation would succeed or it can

00:18:56,560 --> 00:19:05,240
terminate for different reasons like low

00:19:01,460 --> 00:19:12,460
contention on the zone LRU and zone

00:19:05,240 --> 00:19:12,460
locks but fatal signal pending and so on

00:19:13,330 --> 00:19:24,080
so yeah that's the main mechanism in the

00:19:19,520 --> 00:19:27,610
kernel for helping to higher order

00:19:24,080 --> 00:19:31,730
allocation of course it has some

00:19:27,610 --> 00:19:34,970
limitation as as I've seen as I've shown

00:19:31,730 --> 00:19:37,420
in the example one of the pages could

00:19:34,970 --> 00:19:43,700
not be isolated because it belonged to

00:19:37,420 --> 00:19:46,940
slop a locator so in general only subset

00:19:43,700 --> 00:19:51,830
of the allocated pages can be isolated

00:19:46,940 --> 00:19:55,130
and migrated like this which is mostly

00:19:51,830 --> 00:19:58,700
the user space pages because there we

00:19:55,130 --> 00:20:02,770
have the full control of who can access

00:19:58,700 --> 00:20:06,680
them at any point of time so if we

00:20:02,770 --> 00:20:11,630
rewrite the the page tables of the

00:20:06,680 --> 00:20:15,830
processes we can prevent the accesses

00:20:11,630 --> 00:20:19,370
and that means we can move the pages

00:20:15,830 --> 00:20:23,330
around for kernel pages in general it's

00:20:19,370 --> 00:20:26,270
not as easy because anyone can have some

00:20:23,330 --> 00:20:28,540
pointer to an object from slop and we

00:20:26,270 --> 00:20:34,670
don't know how many of them there are

00:20:28,540 --> 00:20:37,670
there are some classes of pages even in

00:20:34,670 --> 00:20:40,970
the kernel that support this because

00:20:37,670 --> 00:20:44,560
they are special enough that they don't

00:20:40,970 --> 00:20:48,050
give out pointers to them to anybody and

00:20:44,560 --> 00:20:52,670
that means we can recognize them by

00:20:48,050 --> 00:20:55,090
having some kind of page movable not

00:20:52,670 --> 00:20:59,290
really a page flag but something similar

00:20:55,090 --> 00:21:05,120
I think this was introduced by mention

00:20:59,290 --> 00:21:09,790
in maturity here today and yeah

00:21:05,120 --> 00:21:12,130
currently it's for that's what

00:21:09,790 --> 00:21:16,690
compressed

00:21:12,130 --> 00:21:23,169
swap functionality that can move pages

00:21:16,690 --> 00:21:26,830
like this and virtualization memory

00:21:23,169 --> 00:21:30,039
balloon from the tio can also do that

00:21:26,830 --> 00:21:33,570
because the balloon pages are there just

00:21:30,039 --> 00:21:38,740
to just to create a memory pressure and

00:21:33,570 --> 00:21:41,440
nobody releases them for anything so we

00:21:38,740 --> 00:21:45,400
had a pages that can be migrated have to

00:21:41,440 --> 00:21:50,650
be kind of special like that also if

00:21:45,400 --> 00:21:54,789
there's any page reference to for

00:21:50,650 --> 00:21:57,360
example the user space page except from

00:21:54,789 --> 00:22:01,120
the page tables that are mapping them

00:21:57,360 --> 00:22:04,409
because I don't know the page might be

00:22:01,120 --> 00:22:09,280
under IO or whatever then then we cannot

00:22:04,409 --> 00:22:12,120
isolate them at that moment for it and

00:22:09,280 --> 00:22:15,309
for example some file systems only allow

00:22:12,120 --> 00:22:18,940
their pages to be migrated if they are

00:22:15,309 --> 00:22:24,460
clean not dirty which is another

00:22:18,940 --> 00:22:28,929
limitation and in the end the result is

00:22:24,460 --> 00:22:32,909
that if we want to allocate a huge page

00:22:28,929 --> 00:22:37,030
which is order nine which is 512 pages

00:22:32,909 --> 00:22:40,559
it takes just a single one in there that

00:22:37,030 --> 00:22:43,059
cannot be migrated and we lose and

00:22:40,559 --> 00:22:49,720
anything migrate all the rest it doesn't

00:22:43,059 --> 00:22:55,179
know what about the v-mail okay are they

00:22:49,720 --> 00:22:58,360
migrated VM Alok no not now but I think

00:22:55,179 --> 00:23:01,530
it's one of the candidates that could be

00:22:58,360 --> 00:23:04,530
looked at I will mention them later

00:23:01,530 --> 00:23:04,530
actually

00:23:05,310 --> 00:23:19,110
so yeah one page to prevent each page

00:23:15,930 --> 00:23:25,650
collocation sounds bad so what we can do

00:23:19,110 --> 00:23:28,320
about that we can try to keep such pages

00:23:25,650 --> 00:23:30,690
as close together as possible so they

00:23:28,320 --> 00:23:34,050
don't spread out all over the memory

00:23:30,690 --> 00:23:36,960
which is exactly the point of the second

00:23:34,050 --> 00:23:39,320
mechanism that complements memory

00:23:36,960 --> 00:23:45,980
compaction and that's called page

00:23:39,320 --> 00:23:50,070
grouping by mobility which works like

00:23:45,980 --> 00:23:54,870
biologically dividing this zone into

00:23:50,070 --> 00:23:59,160
page blocks which is which are the same

00:23:54,870 --> 00:24:03,990
size as a huge page and for each of the

00:23:59,160 --> 00:24:06,630
page book it tracks whether it's used

00:24:03,990 --> 00:24:10,110
for movable allocations that can be

00:24:06,630 --> 00:24:13,620
migrated on moveable vans which cannot

00:24:10,110 --> 00:24:18,630
and reclaim a ball also also cannot be

00:24:13,620 --> 00:24:21,960
migrated but at least can be they belong

00:24:18,630 --> 00:24:25,800
to slopes that have a shrinker and can

00:24:21,960 --> 00:24:31,440
at least reclaim itself on the memory

00:24:25,800 --> 00:24:35,670
pressure and yeah the page books are

00:24:31,440 --> 00:24:38,960
marked and the free list for each for

00:24:35,670 --> 00:24:43,680
each order are also split into these

00:24:38,960 --> 00:24:48,420
these three types so we can give out

00:24:43,680 --> 00:24:53,430
pages moveable pages to use of space

00:24:48,420 --> 00:24:55,620
allocations and so on and yeah the

00:24:53,430 --> 00:24:58,380
allocation is distinguished by one of

00:24:55,620 --> 00:25:02,880
those GFP flex so GFP kernel is

00:24:58,380 --> 00:25:07,790
unmovable but high user movable will be

00:25:02,880 --> 00:25:11,880
moveable as the name says and again this

00:25:07,790 --> 00:25:15,870
works nicely until the memory gets full

00:25:11,880 --> 00:25:17,690
and suddenly you want to do some

00:25:15,870 --> 00:25:21,740
unmovable allocation but all

00:25:17,690 --> 00:25:25,760
unmovable page blocks are depleted and

00:25:21,740 --> 00:25:28,630
that's when the fun starts so in this

00:25:25,760 --> 00:25:34,400
example I have moveable page block and

00:25:28,630 --> 00:25:37,250
some pages are on the movable list these

00:25:34,400 --> 00:25:40,940
there's an unmovable page block which is

00:25:37,250 --> 00:25:45,860
the only remaining free page unmovable

00:25:40,940 --> 00:25:50,090
list and what can happen as i said the

00:25:45,860 --> 00:25:54,440
last allocation fills up to unmovable

00:25:50,090 --> 00:25:57,650
page block and we are unlucky so there's

00:25:54,440 --> 00:26:01,190
another unmovable allocation and it

00:25:57,650 --> 00:26:05,720
cannot be satisfied from this so now the

00:26:01,190 --> 00:26:10,430
heaviest xscape in and try to contain

00:26:05,720 --> 00:26:13,190
the damage as much as possible so one

00:26:10,430 --> 00:26:15,770
thing is that when we are falling back

00:26:13,190 --> 00:26:20,230
to another migration type like the

00:26:15,770 --> 00:26:25,670
movable one here we first try to find

00:26:20,230 --> 00:26:29,420
the largest free page so that if we are

00:26:25,670 --> 00:26:31,790
stealing from another movability type

00:26:29,420 --> 00:26:34,940
it's better to steal as much as possible

00:26:31,790 --> 00:26:37,910
because then if there are more unmovable

00:26:34,940 --> 00:26:40,370
our locations they will all go to this

00:26:37,910 --> 00:26:45,890
page block and we won't pollute more of

00:26:40,370 --> 00:26:48,800
them so we steal everything from this

00:26:45,890 --> 00:26:54,020
page block and put it on the unmovable

00:26:48,800 --> 00:26:58,640
free list and if it was more than half

00:26:54,020 --> 00:27:02,930
of the pages in this block we would also

00:26:58,640 --> 00:27:06,170
change it to unmovable so that it would

00:27:02,930 --> 00:27:08,660
remain unmovable even in the future but

00:27:06,170 --> 00:27:13,040
in this case it's just three pages out

00:27:08,660 --> 00:27:16,630
of eight so that didn't happen so we

00:27:13,040 --> 00:27:20,750
started by finding the largest page but

00:27:16,630 --> 00:27:24,860
since we allocate just a single page we

00:27:20,750 --> 00:27:29,470
Indians give the allocation to this page

00:27:24,860 --> 00:27:29,470
so we are not splitting uselessly

00:27:33,389 --> 00:27:39,700
yeah so can you hear me yeah so since

00:27:37,960 --> 00:27:41,980
those are moveable pages at this

00:27:39,700 --> 00:27:46,120
juncture you might consider compressing

00:27:41,980 --> 00:27:47,980
them sorry when you need to allocate an

00:27:46,120 --> 00:27:49,809
unmovable page from the moveable block

00:27:47,980 --> 00:27:51,279
you might actually slide the move close

00:27:49,809 --> 00:27:54,159
together you might defragment them

00:27:51,279 --> 00:28:01,019
before giving out a larger error you've

00:27:54,159 --> 00:28:04,029
created to the unmovable block yeah you

00:28:01,019 --> 00:28:06,220
create create a larger contiguous region

00:28:04,029 --> 00:28:08,350
of moveable pages again to guarantee

00:28:06,220 --> 00:28:13,500
they continue to be contiguous yeah

00:28:08,350 --> 00:28:13,500
that's one of the possibilities future

00:28:14,669 --> 00:28:25,539
and some pages then can be freed in the

00:28:21,190 --> 00:28:29,919
unmovable page block so they appear on

00:28:25,539 --> 00:28:32,139
unmovable free lists and that what can

00:28:29,919 --> 00:28:36,340
happen there is a moveable allocation

00:28:32,139 --> 00:28:41,379
and we are unlucky and it picks this

00:28:36,340 --> 00:28:44,590
block instead of that block so now we

00:28:41,379 --> 00:28:49,450
have multiple page blocks that are

00:28:44,590 --> 00:28:53,049
mixing moveable and immoveable pages and

00:28:49,450 --> 00:28:57,940
if the allocation is temporarily and

00:28:53,049 --> 00:28:59,980
immediately freed the free page because

00:28:57,940 --> 00:29:02,580
the page block is still Marcos and

00:28:59,980 --> 00:29:06,909
moveable the free page becomes also

00:29:02,580 --> 00:29:10,690
unmovable and even merges with the other

00:29:06,909 --> 00:29:16,779
movable one because merging doesn't care

00:29:10,690 --> 00:29:22,120
about the color yeah and in the end this

00:29:16,779 --> 00:29:25,960
page would have fit here if we knew the

00:29:22,120 --> 00:29:30,100
future before and prepared for it but we

00:29:25,960 --> 00:29:34,990
could not so we are fragmented so yeah

00:29:30,100 --> 00:29:41,140
that just summarizes the heuristics I've

00:29:34,990 --> 00:29:44,100
shown in the example so we have to

00:29:41,140 --> 00:29:47,770
be as careful as possible but we cannot

00:29:44,100 --> 00:29:51,550
also be too excessively careful like

00:29:47,770 --> 00:29:55,360
scanning all of the blocks and finding

00:29:51,550 --> 00:30:00,310
really the best best fallback page

00:29:55,360 --> 00:30:05,860
because that will be prohibitive so open

00:30:00,310 --> 00:30:10,710
issues of the of the mechanisms I just

00:30:05,860 --> 00:30:14,190
introduced so compaction is often

00:30:10,710 --> 00:30:18,580
reported to have a large overhead

00:30:14,190 --> 00:30:26,050
especially in all all the kernels on

00:30:18,580 --> 00:30:29,830
various forums and documentation for

00:30:26,050 --> 00:30:33,000
databases you can find recommendations

00:30:29,830 --> 00:30:37,540
to disable transparent image pages

00:30:33,000 --> 00:30:40,270
because of this high overhead in fact

00:30:37,540 --> 00:30:42,930
the defaults in the kernel have changed

00:30:40,270 --> 00:30:47,260
that transparent image page is no longer

00:30:42,930 --> 00:30:51,270
called compaction when during to page

00:30:47,260 --> 00:30:54,280
fault of transparent image page so that

00:30:51,270 --> 00:31:00,160
that overhead should be mostly gone by

00:30:54,280 --> 00:31:03,310
now but still we could differ more work

00:31:00,160 --> 00:31:06,690
to background threats we have the que

00:31:03,310 --> 00:31:11,980
compacted threat in several versions now

00:31:06,690 --> 00:31:15,330
which is now satisfying only just one

00:31:11,980 --> 00:31:18,940
allocation that both walked it up and

00:31:15,330 --> 00:31:22,180
creates one pages of the highest order

00:31:18,940 --> 00:31:27,820
it was called for and it could be more

00:31:22,180 --> 00:31:31,360
proactive and create more free pages

00:31:27,820 --> 00:31:34,870
once it's woken up in the extreme it

00:31:31,360 --> 00:31:37,830
would just try to consolidate all all

00:31:34,870 --> 00:31:41,050
pages that have been freed by the by the

00:31:37,830 --> 00:31:46,320
case what do you reclaim before it woken

00:31:41,050 --> 00:31:48,010
up cake integrity another issue with

00:31:46,320 --> 00:31:50,800
compaction

00:31:48,010 --> 00:31:54,040
is that the way it works and the

00:31:50,800 --> 00:31:57,430
scanners meet somewhere around the

00:31:54,040 --> 00:32:01,980
middle it means the other half of the

00:31:57,430 --> 00:32:05,970
zone is often not scanned at all because

00:32:01,980 --> 00:32:10,330
the free scanner was scanning it and

00:32:05,970 --> 00:32:14,710
then we can end up like here when

00:32:10,330 --> 00:32:16,930
compaction will always should be scanned

00:32:14,710 --> 00:32:18,640
these two page blocks which cannot be

00:32:16,930 --> 00:32:22,210
helped any more because there are

00:32:18,640 --> 00:32:24,700
moveable pages and the scanner cannot

00:32:22,210 --> 00:32:29,350
see these blocks were it could actually

00:32:24,700 --> 00:32:33,310
migrate stuff away and create each three

00:32:29,350 --> 00:32:34,840
pages so there are several ideas how

00:32:33,310 --> 00:32:38,020
this can be helped

00:32:34,840 --> 00:32:41,290
like not starting Kovas from the

00:32:38,020 --> 00:32:43,450
beginning and end of the zone but from

00:32:41,290 --> 00:32:46,360
the middle that my correction scanner

00:32:43,450 --> 00:32:49,150
could go from the middle this direction

00:32:46,360 --> 00:32:53,260
and the free scanner from the middle to

00:32:49,150 --> 00:32:55,990
that direction or John sue Kim proposed

00:32:53,260 --> 00:33:00,340
at some point that that would both move

00:32:55,990 --> 00:33:05,280
in the same direction and space between

00:33:00,340 --> 00:33:08,970
them would be the three pages or my idea

00:33:05,280 --> 00:33:11,800
is to replace the free scanner

00:33:08,970 --> 00:33:17,080
completely and just allocate pages from

00:33:11,800 --> 00:33:20,020
the free lists because it removes lots

00:33:17,080 --> 00:33:23,440
of free scanner overhead I can easily

00:33:20,020 --> 00:33:25,270
see that free scanner has to scan 30

00:33:23,440 --> 00:33:28,000
times more than the migration scanner

00:33:25,270 --> 00:33:33,610
because the free pages are relatively

00:33:28,000 --> 00:33:37,920
rare on a full memory system but each of

00:33:33,610 --> 00:33:43,530
these proportions prepositions have some

00:33:37,920 --> 00:33:46,000
some dangers of resulting to migrate

00:33:43,530 --> 00:33:51,810
pages around too much back and forth

00:33:46,000 --> 00:33:56,500
because there's no there's no longer the

00:33:51,810 --> 00:33:58,480
the state that that compaction will

00:33:56,500 --> 00:34:02,860
always converge to

00:33:58,480 --> 00:34:06,940
which is this one because suddenly on

00:34:02,860 --> 00:34:09,669
you call it and it can migrate that way

00:34:06,940 --> 00:34:12,450
and call it again migrate the other way

00:34:09,669 --> 00:34:15,250
and also if there are multiple

00:34:12,450 --> 00:34:18,730
compactions in parallel they can like

00:34:15,250 --> 00:34:24,490
undo each other's work like one one

00:34:18,730 --> 00:34:28,060
would be trying to free dispatch block

00:34:24,490 --> 00:34:30,190
and the other one would steal pages free

00:34:28,060 --> 00:34:33,760
pages from the same page block so that

00:34:30,190 --> 00:34:39,940
would have to be soft because before

00:34:33,760 --> 00:34:44,230
this is possible and for the mobility

00:34:39,940 --> 00:34:49,270
grouping there are also open issues like

00:34:44,230 --> 00:34:52,200
I've said it has some corner cases

00:34:49,270 --> 00:34:58,240
because the heuristics cannot be perfect

00:34:52,200 --> 00:35:02,080
so yeah like in this case we are again

00:34:58,240 --> 00:35:04,869
out of pages in unmovable block and it

00:35:02,080 --> 00:35:08,980
can happen that the next allocation will

00:35:04,869 --> 00:35:11,560
pollute this this moveable page block

00:35:08,980 --> 00:35:15,369
instead of adding to the already

00:35:11,560 --> 00:35:18,369
polluted page block because because it

00:35:15,369 --> 00:35:27,250
cannot distinguish these two just from

00:35:18,369 --> 00:35:33,040
the free lists and the possible

00:35:27,250 --> 00:35:36,310
solutions here are again several options

00:35:33,040 --> 00:35:41,410
that have been tried at some point but

00:35:36,310 --> 00:35:45,460
not finalized yet so yeah like was

00:35:41,410 --> 00:35:48,910
already said it's possible to migrate or

00:35:45,460 --> 00:35:55,000
the remaining pages away from from the

00:35:48,910 --> 00:35:59,100
block that we are falling back to by

00:35:55,000 --> 00:36:02,619
waking up for example 2k compact D

00:35:59,100 --> 00:36:07,359
directly until it now compact this block

00:36:02,619 --> 00:36:08,750
I think lost one who tried it was no

00:36:07,359 --> 00:36:14,930
government last week

00:36:08,750 --> 00:36:22,280
and in the end he also postponed is it

00:36:14,930 --> 00:36:29,359
to future work and another possibility

00:36:22,280 --> 00:36:32,690
is to be more strict in in keeping track

00:36:29,359 --> 00:36:35,420
of which page blocks are polluted so

00:36:32,690 --> 00:36:38,359
even if there's single and moveable page

00:36:35,420 --> 00:36:42,680
we would not call the page block as

00:36:38,359 --> 00:36:46,550
movable but for example mixed and prefer

00:36:42,680 --> 00:36:50,150
it before polluting more and movable for

00:36:46,550 --> 00:36:55,099
moveable page blocks and this was even

00:36:50,150 --> 00:36:57,830
explored in a recent academic paper as

00:36:55,099 --> 00:37:02,270
plus this year and looks like it might

00:36:57,830 --> 00:37:07,119
help so that's what I've also tried this

00:37:02,270 --> 00:37:11,990
already before and yeah but I didn't do

00:37:07,119 --> 00:37:17,480
such large evaluation but it's certainly

00:37:11,990 --> 00:37:20,450
something to try or in general we can

00:37:17,480 --> 00:37:23,000
strive to have less fewer fallback

00:37:20,450 --> 00:37:27,470
events because it means fewer

00:37:23,000 --> 00:37:33,500
opportunities to mix movable and movable

00:37:27,470 --> 00:37:36,650
pages together and in this area in this

00:37:33,500 --> 00:37:43,280
direction mal Gorman did the series last

00:37:36,650 --> 00:37:45,680
week that one one big advantage of this

00:37:43,280 --> 00:37:49,780
is that he defined a new test case

00:37:45,680 --> 00:37:55,869
because until now we were using very

00:37:49,780 --> 00:37:59,380
very artificial workload that combined

00:37:55,869 --> 00:38:03,560
parallel Colonel belts and some

00:37:59,380 --> 00:38:07,250
artificial allocator of each pages or

00:38:03,560 --> 00:38:13,580
pages of whatever size and Mel now

00:38:07,250 --> 00:38:17,359
defined more real workload based on fire

00:38:13,580 --> 00:38:19,730
which is file system benchmark and doing

00:38:17,359 --> 00:38:20,710
the HP allocations and the point is to

00:38:19,730 --> 00:38:23,390
make

00:38:20,710 --> 00:38:28,720
makes the movable and unmovable a

00:38:23,390 --> 00:38:33,760
location so they stress the heuristics

00:38:28,720 --> 00:38:39,080
and he tried several improvements that

00:38:33,760 --> 00:38:41,800
seem to result in ninety five less

00:38:39,080 --> 00:38:46,010
percent less fragmenting event so that

00:38:41,800 --> 00:38:51,560
looks very promising I will try to

00:38:46,010 --> 00:38:56,450
review it soon as possible last thing is

00:38:51,560 --> 00:38:59,450
that even if we are perfect there are

00:38:56,450 --> 00:39:06,740
some adverse workloads that will always

00:38:59,450 --> 00:39:09,320
defeat any heuristic because if the the

00:39:06,740 --> 00:39:12,800
slop caches suddenly grow to almost

00:39:09,320 --> 00:39:17,120
whole memory and then start slowly

00:39:12,800 --> 00:39:19,520
shrinking they will keep even in the end

00:39:17,120 --> 00:39:23,180
they won't occupy many pages but it will

00:39:19,520 --> 00:39:26,870
be spread everywhere and we cannot do

00:39:23,180 --> 00:39:28,610
anything about it right now and in fact

00:39:26,870 --> 00:39:31,160
it system of the theoretical conserve

00:39:28,610 --> 00:39:35,570
because one user is reporting this

00:39:31,160 --> 00:39:41,410
upstream during the last few months I

00:39:35,570 --> 00:39:45,220
have to skip this okay I five minutes so

00:39:41,410 --> 00:39:48,550
yes so this is how it looks like when I

00:39:45,220 --> 00:39:54,530
processed the reports from that user

00:39:48,550 --> 00:39:58,970
where he was doing a vmstat snapshot

00:39:54,530 --> 00:40:02,090
each five seconds and we can see that on

00:39:58,970 --> 00:40:06,350
a freshly booted system the page cache

00:40:02,090 --> 00:40:11,450
which is green slowly Gross's files are

00:40:06,350 --> 00:40:15,560
being create the free memory becoming

00:40:11,450 --> 00:40:19,210
occupied slop grows a bit but that's all

00:40:15,560 --> 00:40:23,480
fine and then he has some overnight

00:40:19,210 --> 00:40:27,890
maintenance tasks which is like opening

00:40:23,480 --> 00:40:31,460
of studying all files with find and that

00:40:27,890 --> 00:40:36,200
means lots of metadata activity so slop

00:40:31,460 --> 00:40:40,250
until 40 gigabytes page caches evicted

00:40:36,200 --> 00:40:43,880
of course and then the maintenance ants

00:40:40,250 --> 00:40:47,750
and slowly slop is being slowly

00:40:43,880 --> 00:40:51,230
reclaimed but since it's fragmenting

00:40:47,750 --> 00:40:54,619
memory suddenly some high order

00:40:51,230 --> 00:40:56,829
allocations probably are trying to

00:40:54,619 --> 00:41:01,309
reclaim and compact and Sussex

00:40:56,829 --> 00:41:03,349
unsuccessfully which means they start to

00:41:01,309 --> 00:41:06,130
reclaim even the page cache even though

00:41:03,349 --> 00:41:09,859
it cannot help and the performance is

00:41:06,130 --> 00:41:13,460
guilt and if he manually drops the slab

00:41:09,859 --> 00:41:17,210
caches everything is okay so we have

00:41:13,460 --> 00:41:19,430
this very bad scenario and also some

00:41:17,210 --> 00:41:25,160
very bad reaction to it which is not yet

00:41:19,430 --> 00:41:31,069
clear what why that happens and I think

00:41:25,160 --> 00:41:33,440
the only solution to this is general for

00:41:31,069 --> 00:41:37,369
the anti fragmentation and compaction is

00:41:33,440 --> 00:41:39,530
to make more classes of pages movable as

00:41:37,369 --> 00:41:43,760
we heard already VM elope would be one

00:41:39,530 --> 00:41:47,660
possibility because we can we can trap

00:41:43,760 --> 00:41:50,450
whoever accesses the AVMA log by page

00:41:47,660 --> 00:41:52,819
table operations we could probably make

00:41:50,450 --> 00:41:56,359
at least some levels of pages migrate

00:41:52,819 --> 00:42:00,010
able Christopher lammeter was proposing

00:41:56,359 --> 00:42:04,809
for many years to make sloppy objects

00:42:00,010 --> 00:42:08,960
movable but even he yesterday

00:42:04,809 --> 00:42:14,809
admitted that it's very hard and hasn't

00:42:08,960 --> 00:42:19,790
happened in 10 years still we could try

00:42:14,809 --> 00:42:23,809
maybe reclaiming slop in the lumpy

00:42:19,790 --> 00:42:26,960
reclaim way that would work but would

00:42:23,809 --> 00:42:29,270
have probably the same disadvantages or

00:42:26,960 --> 00:42:32,210
we can just try to prevent the slobs

00:42:29,270 --> 00:42:35,000
growing so much there's been some

00:42:32,210 --> 00:42:39,109
efforts for negative 10 trees for that

00:42:35,000 --> 00:42:43,400
already but it might help this case but

00:42:39,109 --> 00:42:44,760
maybe not in general so yeah the

00:42:43,400 --> 00:42:47,640
conclusion is that

00:42:44,760 --> 00:42:54,930
there's still of a lots of work to do so

00:42:47,640 --> 00:42:56,700
thanks any questions mm-hmm you talked

00:42:54,930 --> 00:42:58,020
about being able to reclaim slab objects

00:42:56,700 --> 00:43:00,300
and you need to be able to record the

00:42:58,020 --> 00:43:03,750
pointers would it be easier to record a

00:43:00,300 --> 00:43:05,700
callback so for instance 4d entries have

00:43:03,750 --> 00:43:07,530
a call back into the file system to say

00:43:05,700 --> 00:43:09,300
I'd like you to free this D entry I'd

00:43:07,530 --> 00:43:11,579
like you to free this D entry so that

00:43:09,300 --> 00:43:14,970
you could try to reclaim slab pages yeah

00:43:11,579 --> 00:43:18,329
I think yeah that was the idea behind

00:43:14,970 --> 00:43:21,300
making them movable are there particular

00:43:18,329 --> 00:43:25,800
slabs that are more often the problem

00:43:21,300 --> 00:43:30,570
than others yeah it seems to be mostly

00:43:25,800 --> 00:43:35,510
than trees and I know because there can

00:43:30,570 --> 00:43:35,510
be easily filled by filesystem activity

00:43:41,980 --> 00:43:48,149
if not so let's thank our speaker

00:43:45,050 --> 00:43:48,149

YouTube URL: https://www.youtube.com/watch?v=mzT4QnCpef8


