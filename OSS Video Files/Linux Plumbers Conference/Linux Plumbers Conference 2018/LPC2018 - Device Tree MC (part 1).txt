Title: LPC2018 - Device Tree MC (part 1)
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	https://linuxplumbersconf.org/event/2/sessions/36/#20181114


Topics
Binding and Devicetree Source/DTB Validation: update and next steps
Binding specification format
Validation Process and Process
How to validate overlays
Devicetree Specification: update and next steps

Reducing devicetree memory and storage size

Overlays

Bootloader and Linux kernel implementation update
Remaining blockers and issues
Use cases
Devicetree compiler (dtc)

Next version of DTB/FDT format
Motivated by desire to replace metadata being encoded as normal data (metadata for overlays)
Other desired changes should be considered
Boot and Run-time Configuration
Pain points and needs
Multi-bus devices

Feedback from the trenches

how DTOs are used in embedded devices in practice
in U-Boot and Linux
in systems with FPGAs
Use of devicetrees in small code/data space (e.g. U-Boot SPL)

Connector node bindings

FPGA issues
Captions: 
	00:00:06,110 --> 00:00:10,760
good evening good night it's been a good

00:00:08,550 --> 00:00:10,760
session

00:00:15,410 --> 00:00:20,220
welcome to the device tree track

00:00:17,789 --> 00:00:25,530
I'm Frank Rowland I'm one of the device

00:00:20,220 --> 00:00:28,260
containers Rob is hiding right in front

00:00:25,530 --> 00:00:32,070
of another maintainer Rob was also a

00:00:28,260 --> 00:00:33,629
binding maintainer Yosi Europe I got to

00:00:32,070 --> 00:00:35,010
dodge a lot of questions cuz I could

00:00:33,629 --> 00:00:37,650
just say oh that's a bindings question

00:00:35,010 --> 00:00:40,890
talk to the bindings maintainer here

00:00:37,650 --> 00:00:43,560
today grant like the device can maintain

00:00:40,890 --> 00:00:45,120
their merits this year lots of other

00:00:43,560 --> 00:00:49,680
maintained errs who can answer questions

00:00:45,120 --> 00:00:52,730
are here we're really well first of all

00:00:49,680 --> 00:00:55,410
we're taking notes on a etherpad so

00:00:52,730 --> 00:00:57,840
anyone in the audience can take notes

00:00:55,410 --> 00:01:00,870
and contribute it it's a point-and-click

00:00:57,840 --> 00:01:02,460
what use type is what you see I'd

00:01:00,870 --> 00:01:06,450
encourage you to actually start taking

00:01:02,460 --> 00:01:08,729
notes on etherpad and if we can find a

00:01:06,450 --> 00:01:10,229
volunteer to especially pay attention to

00:01:08,729 --> 00:01:14,909
that would would like to seek one of

00:01:10,229 --> 00:01:17,070
those out Shawn is the co-coordinator of

00:01:14,909 --> 00:01:20,060
this track he's put a lot of work into

00:01:17,070 --> 00:01:25,140
making this go hopefully smoothly today

00:01:20,060 --> 00:01:28,369
notes after the fact will be hopefully

00:01:25,140 --> 00:01:31,320
on the plumbers website but I don't know

00:01:28,369 --> 00:01:32,340
the coordinator says yes they'll also be

00:01:31,320 --> 00:01:35,909
on the olynyk's

00:01:32,340 --> 00:01:38,939
org wiki which the embedded Linux group

00:01:35,909 --> 00:01:42,390
the CEO P project of the Linux

00:01:38,939 --> 00:01:45,049
Foundation maintains and I'll put these

00:01:42,390 --> 00:01:46,950
URLs up several times later in the event

00:01:45,049 --> 00:01:49,200
here's the schedule it's gotta be a

00:01:46,950 --> 00:01:51,960
little bit flexible the timing is really

00:01:49,200 --> 00:01:54,270
tight we tried to cram too much in so

00:01:51,960 --> 00:01:56,159
what we're gonna do is if any session

00:01:54,270 --> 00:01:58,140
ends a little bit early we're not just

00:01:56,159 --> 00:01:59,909
gonna hang our out and go take a break

00:01:58,140 --> 00:02:02,070
we'll just jump into the next session

00:01:59,909 --> 00:02:05,400
and try and get try and recover as much

00:02:02,070 --> 00:02:07,799
time as we can as we're going I'm not

00:02:05,400 --> 00:02:11,879
gonna go through the agenda in detail

00:02:07,799 --> 00:02:14,330
you've all seen the schedule so just

00:02:11,879 --> 00:02:17,130
jump right into our very first session

00:02:14,330 --> 00:02:18,660
before we do that yeah so a couple of

00:02:17,130 --> 00:02:20,850
administrative things

00:02:18,660 --> 00:02:22,920
of course if you've been here you've

00:02:20,850 --> 00:02:24,990
seen these we need to make sure that we

00:02:22,920 --> 00:02:26,970
use mics for questions and discussion or

00:02:24,990 --> 00:02:29,910
else the recordings are going to have it

00:02:26,970 --> 00:02:31,800
I'm gonna be trying to take notes but I

00:02:29,910 --> 00:02:36,000
need a volunteer because I'm little

00:02:31,800 --> 00:02:38,490
constrained Moritz thank you very much

00:02:36,000 --> 00:02:42,260
as far as running mics and also if I can

00:02:38,490 --> 00:02:44,460
get somebody who's going to be actively

00:02:42,260 --> 00:02:45,930
adding notes to etherpad that would be

00:02:44,460 --> 00:02:50,130
very much appreciated but take care that

00:02:45,930 --> 00:02:52,380
it will okay thank you we have a few we

00:02:50,130 --> 00:02:55,920
didn't talk about this but yeah we we

00:02:52,380 --> 00:02:57,720
have a few speaker items that I think we

00:02:55,920 --> 00:03:00,450
said we were gonna do one for best

00:02:57,720 --> 00:03:02,370
question is that right yeah we can up as

00:03:00,450 --> 00:03:03,510
we go sure we can change liro last week

00:03:02,370 --> 00:03:11,040
we can change the rules because that's

00:03:03,510 --> 00:03:12,720
part of being the organizer anyway all

00:03:11,040 --> 00:03:14,130
right so I just wanted to do that so if

00:03:12,720 --> 00:03:15,900
I start giving you a signal if you're up

00:03:14,130 --> 00:03:17,340
here or if I start doing this to people

00:03:15,900 --> 00:03:18,810
with questions and we want them to go on

00:03:17,340 --> 00:03:22,080
because we do want to try and make sure

00:03:18,810 --> 00:03:26,880
that the recording is is keeping up with

00:03:22,080 --> 00:03:29,280
those scheduled speakers oh yeah one

00:03:26,880 --> 00:03:31,230
other logistical thing for the recording

00:03:29,280 --> 00:03:36,930
speakers we need to kind of try and stay

00:03:31,230 --> 00:03:41,120
on this side apparently it's cool thank

00:03:36,930 --> 00:03:41,120
you here we are questions and answers

00:03:41,600 --> 00:03:47,250
again if if we don't use the whole

00:03:45,360 --> 00:03:48,540
session we'll just recover this time and

00:03:47,250 --> 00:03:51,270
we can do more questions and answers

00:03:48,540 --> 00:03:52,980
later this was just trying to sweep up

00:03:51,270 --> 00:03:54,570
some questions early in the event and

00:03:52,980 --> 00:03:56,670
I'm guessing that they're going to be

00:03:54,570 --> 00:03:59,190
questions that evolve is we start having

00:03:56,670 --> 00:04:00,450
sessions and when a session ends and we

00:03:59,190 --> 00:04:02,250
haven't answer all the questions we can

00:04:00,450 --> 00:04:06,020
push those questions there's no other

00:04:02,250 --> 00:04:06,020
question in the answer session later

00:04:07,910 --> 00:04:12,360
questions anybody have any burning

00:04:10,020 --> 00:04:14,720
questions they brought to the conference

00:04:12,360 --> 00:04:14,720
this week

00:04:16,100 --> 00:04:22,350
you can make this a really short session

00:04:19,880 --> 00:04:29,820
we have much longer questioning answers

00:04:22,350 --> 00:04:31,830
later if that happens nobody wow you

00:04:29,820 --> 00:04:38,280
guys have just made the schedule so much

00:04:31,830 --> 00:04:42,510
better move on to the next session which

00:04:38,280 --> 00:04:45,930
is Rob and he gave me his slides and I

00:04:42,510 --> 00:04:48,960
haven't uploaded them yet so Frank's

00:04:45,930 --> 00:04:51,480
doing that again the more you guys add

00:04:48,960 --> 00:04:53,460
into this process the more you're going

00:04:51,480 --> 00:04:55,020
to take away from it so if you have any

00:04:53,460 --> 00:04:57,210
questions that occur to you

00:04:55,020 --> 00:04:59,700
later on we are gonna have another Q&A

00:04:57,210 --> 00:05:02,130
session which apparently just got quite

00:04:59,700 --> 00:05:04,080
a bit longer because this one we had

00:05:02,130 --> 00:05:07,230
left time to cover topic so if there's

00:05:04,080 --> 00:05:09,660
something that is of interest to you the

00:05:07,230 --> 00:05:12,060
focus on these isn't for us to give you

00:05:09,660 --> 00:05:12,660
presentations it's for discussion so

00:05:12,060 --> 00:05:14,820
please

00:05:12,660 --> 00:05:17,160
I know it's first thing in the morning

00:05:14,820 --> 00:05:21,169
and a lot of us are tired but let's

00:05:17,160 --> 00:05:21,169
let's try and throw input in place

00:05:27,520 --> 00:05:32,840
you know are people awake yet is that

00:05:30,470 --> 00:05:38,080
the should we start with calisthenics

00:05:32,840 --> 00:05:38,080
yeah that's probably a good idea

00:05:46,800 --> 00:05:50,230
thank you

00:05:48,190 --> 00:05:51,669
is it possible to do a quick recap of

00:05:50,230 --> 00:05:54,870
the state of everything because make

00:05:51,669 --> 00:05:54,870
sure everyone's on the same level set

00:05:54,960 --> 00:06:20,470
given that there's no questions coming

00:05:56,980 --> 00:06:23,190
up I figure yeah so there's the schema

00:06:20,470 --> 00:06:26,139
that I'm going to talk about next and

00:06:23,190 --> 00:06:28,510
originally we had device Street org

00:06:26,139 --> 00:06:33,120
update that I was going to talk about

00:06:28,510 --> 00:06:36,310
when we took that out so briefly on that

00:06:33,120 --> 00:06:40,780
there's a small trickle of patches that

00:06:36,310 --> 00:06:46,620
go in there's been some prep work for a

00:06:40,780 --> 00:06:49,660
connector binding basically a GPIO map

00:06:46,620 --> 00:06:52,330
binding which allows you to remount GPIO

00:06:49,660 --> 00:06:57,900
no numberings from connector numbering

00:06:52,330 --> 00:07:02,800
to sure

00:06:57,900 --> 00:07:07,600
so GPIO map lets you remap connector

00:07:02,800 --> 00:07:12,850
GPIO numbering to the base board or one

00:07:07,600 --> 00:07:14,919
level back numbering of GPIO is probably

00:07:12,850 --> 00:07:16,930
gonna do another spec release at the end

00:07:14,919 --> 00:07:21,000
of this year just to have a yearly

00:07:16,930 --> 00:07:27,120
cadence of releases but that's kind of

00:07:21,000 --> 00:07:27,120
what's happening on the spec front

00:07:30,139 --> 00:07:34,069
what else you want to update on

00:07:38,050 --> 00:07:47,230
reviewing bindings converting bindings

00:07:44,230 --> 00:07:47,230
schema

00:08:03,499 --> 00:08:10,089
I'll probably remember control-shift P

00:08:06,860 --> 00:08:10,089
at the very end of the day

00:09:04,270 --> 00:09:06,960
just

00:09:09,670 --> 00:09:16,170
can I get this slides up there okay do

00:09:13,720 --> 00:09:16,170
it from the podium

00:09:23,990 --> 00:09:31,450
that's fine all right

00:09:27,410 --> 00:09:34,210
today I'm talking about JSON schema for

00:09:31,450 --> 00:09:38,270
device free bindings

00:09:34,210 --> 00:09:39,560
this is what I work on when I'm not

00:09:38,270 --> 00:09:44,690
reviewing your bindings that you're

00:09:39,560 --> 00:09:50,630
submitting so who here has never been to

00:09:44,690 --> 00:09:54,710
a session on schema for device tree only

00:09:50,630 --> 00:09:57,700
a few good so this is kind of a

00:09:54,710 --> 00:09:57,700
perennial topic

00:10:02,760 --> 00:10:10,440
so what's the problem it's too easy to

00:10:05,880 --> 00:10:13,680
get device tree wrong the data must be

00:10:10,440 --> 00:10:18,269
encoded in specific ways like you have P

00:10:13,680 --> 00:10:20,699
handles plus cells were you and that

00:10:18,269 --> 00:10:24,870
depends on the other property it's kind

00:10:20,699 --> 00:10:27,320
of strange property of device trees the

00:10:24,870 --> 00:10:30,329
tool chain provides little validation

00:10:27,320 --> 00:10:34,100
that's kind of been changing over time

00:10:30,329 --> 00:10:39,000
there's a lot more checks within DTC now

00:10:34,100 --> 00:10:42,360
but it's limited to common bindings that

00:10:39,000 --> 00:10:46,290
don't require binding finding specific

00:10:42,360 --> 00:10:56,970
information or or specific information

00:10:46,290 --> 00:10:58,860
for a given device there are no checks

00:10:56,970 --> 00:11:03,029
against the documented schema so it's

00:10:58,860 --> 00:11:04,680
free form text what you write in the

00:11:03,029 --> 00:11:09,630
binding document may or may not match

00:11:04,680 --> 00:11:12,860
what's ends up in the DTS and it's not

00:11:09,630 --> 00:11:16,410
always clear what the constraints are

00:11:12,860 --> 00:11:20,100
from the binding document relative to

00:11:16,410 --> 00:11:25,319
checking a DTS file and it's too much

00:11:20,100 --> 00:11:28,410
manual review since it's freeform text

00:11:25,319 --> 00:11:32,579
did always varies and there are small

00:11:28,410 --> 00:11:34,019
ways and you have a lot more of this

00:11:32,579 --> 00:11:37,649
could be automated if we had something

00:11:34,019 --> 00:11:42,540
machining possible and it's a steep

00:11:37,649 --> 00:11:45,839
learning curve learning device tree had

00:11:42,540 --> 00:11:47,910
a dime for every time I said bindings

00:11:45,839 --> 00:11:53,970
described the hardware I could maybe

00:11:47,910 --> 00:11:56,730
retire though on the last one I'm not

00:11:53,970 --> 00:11:58,500
sure that JSON schema is gonna solve

00:11:56,730 --> 00:12:03,510
that problem because that's yet another

00:11:58,500 --> 00:12:08,060
learning curve so I did a little

00:12:03,510 --> 00:12:10,290
archaeology and I think some of the past

00:12:08,060 --> 00:12:11,939
schema presentations have also done

00:12:10,290 --> 00:12:15,710
archaeology of all the past scheme

00:12:11,939 --> 00:12:21,260
attempts so starting back in

00:12:15,710 --> 00:12:24,800
2013 I think was probably one of the

00:12:21,260 --> 00:12:30,470
first attempts and it was doing sea bass

00:12:24,800 --> 00:12:35,150
checks in DTC that never went upstream

00:12:30,470 --> 00:12:38,080
but a lot of what it was doing this has

00:12:35,150 --> 00:12:41,150
gone upstream and in form of checks and

00:12:38,080 --> 00:12:43,820
if you've noticed you can now get

00:12:41,150 --> 00:12:51,020
thousands of warnings if you build with

00:12:43,820 --> 00:12:54,640
warnings turned on for DTS files but

00:12:51,020 --> 00:13:03,400
that also handled binding specific

00:12:54,640 --> 00:13:03,400
checks which DTC is does not support and

00:13:04,090 --> 00:13:08,300
probably never really will and see cuz

00:13:06,980 --> 00:13:13,940
we need something that's easily

00:13:08,300 --> 00:13:18,560
expandable to there's about 3,000

00:13:13,940 --> 00:13:23,180
binding documents currently then there

00:13:18,560 --> 00:13:29,720
were a couple of attempts to use DTS

00:13:23,180 --> 00:13:32,780
itself as a schema language from Benoit

00:13:29,720 --> 00:13:37,250
and Fabian and then I think Tomas took

00:13:32,780 --> 00:13:43,070
that and evolved that and then there was

00:13:37,250 --> 00:13:45,610
a bit of a break in efforts and we had

00:13:43,070 --> 00:13:49,160
the first attempt at using the amel as a

00:13:45,610 --> 00:13:53,570
schema language that was kind of a

00:13:49,160 --> 00:13:55,600
custom syntax and it didn't really

00:13:53,570 --> 00:14:02,230
address how how we deal with construed

00:13:55,600 --> 00:14:05,800
constraints and Matt Porter did that

00:14:02,230 --> 00:14:05,800
three years ago now

00:14:05,980 --> 00:14:13,030
then a year later grant took that and

00:14:10,090 --> 00:14:15,400
and evolved that into something that I

00:14:13,030 --> 00:14:21,850
think did add some constraints checking

00:14:15,400 --> 00:14:23,860
it was still custom language and last

00:14:21,850 --> 00:14:28,570
year there were kind of two parallel

00:14:23,860 --> 00:14:33,910
attempts further evolving what Matt

00:14:28,570 --> 00:14:39,580
originally did one was using EBP F for

00:14:33,910 --> 00:14:44,560
the constraint language don't ask me to

00:14:39,580 --> 00:14:49,660
explain that one and then grant had

00:14:44,560 --> 00:14:53,440
started looking at JSON schema as an

00:14:49,660 --> 00:14:55,870
option and at that point it was like I

00:14:53,440 --> 00:15:02,290
was not there but more of an idea and

00:14:55,870 --> 00:15:05,020
not really to a working state as far as

00:15:02,290 --> 00:15:07,000
I know a grant came up with that pretty

00:15:05,020 --> 00:15:10,630
much on his own but then in my research

00:15:07,000 --> 00:15:14,890
I found a mention of using JSON which is

00:15:10,630 --> 00:15:16,870
not JSON schema exactly but does mention

00:15:14,890 --> 00:15:21,270
that there's parsers and validators in

00:15:16,870 --> 00:15:27,880
schema for JSON and that was back in

00:15:21,270 --> 00:15:31,410
2013 I think probably around the time of

00:15:27,880 --> 00:15:35,580
the second one I think was the thread

00:15:31,410 --> 00:15:35,580
and that's thanks Alison

00:15:37,530 --> 00:15:43,750
so what are the goals here and that

00:15:41,550 --> 00:15:45,820
before I go any further if anyone has

00:15:43,750 --> 00:15:48,400
questions if I just go through the

00:15:45,820 --> 00:15:53,010
slides we'll be even farther ahead of

00:15:48,400 --> 00:15:53,010
schedule so please ask questions

00:15:53,610 --> 00:16:10,300
relative to the slides anybody does

00:16:09,130 --> 00:16:12,670
anybody have a question about why this

00:16:10,300 --> 00:16:17,710
is necessary you just discussed it in

00:16:12,670 --> 00:16:19,150
the first slide but I'm gonna keep

00:16:17,710 --> 00:16:21,100
poking at people until they start asking

00:16:19,150 --> 00:16:24,460
questions does everyone agree it's

00:16:21,100 --> 00:16:26,740
necessary silence means agreement does

00:16:24,460 --> 00:16:30,420
does this mean you want new bindings to

00:16:26,740 --> 00:16:33,940
be in this format rather than converting

00:16:30,420 --> 00:16:36,190
we want everything so you want

00:16:33,940 --> 00:16:38,020
everything converted yeah but I've got

00:16:36,190 --> 00:16:40,330
the list of the moment which are just

00:16:38,020 --> 00:16:42,220
free standard free form text if you're

00:16:40,330 --> 00:16:49,060
on v10 I'm sorry you're gonna have to

00:16:42,220 --> 00:16:52,720
convert it now No so I want to I'm gonna

00:16:49,060 --> 00:16:54,880
get into that but I want to get the

00:16:52,720 --> 00:16:57,850
infrastructure in place start converting

00:16:54,880 --> 00:17:01,120
stuff not require new stuff quite yet it

00:16:57,850 --> 00:17:04,170
has to be JSON schema and then start

00:17:01,120 --> 00:17:04,170
requiring it at some point

00:17:06,390 --> 00:17:12,400
No

00:17:09,280 --> 00:17:18,880
I'll be less grumpy if I get json schema

00:17:12,400 --> 00:17:21,189
bindings i hope if if you are writing

00:17:18,880 --> 00:17:24,100
stuff and you go ahead and deduce the

00:17:21,189 --> 00:17:25,329
json schema format i mean it's it just

00:17:24,100 --> 00:17:28,299
makes things nice because even if you

00:17:25,329 --> 00:17:30,010
get it wrong it's easier to parse what

00:17:28,299 --> 00:17:32,679
it's what's in there and use some

00:17:30,010 --> 00:17:34,390
scripts to fix it up then if it's just

00:17:32,679 --> 00:17:36,549
the plain text prose that it is right

00:17:34,390 --> 00:17:40,240
now so if you're writing stuff now do

00:17:36,549 --> 00:17:42,630
your best to try to match this and then

00:17:40,240 --> 00:17:44,650
we'll fix it when it's wrong yeah well

00:17:42,630 --> 00:17:47,830
someone else will fix it because i tend

00:17:44,650 --> 00:17:49,690
not to do anything anymore I mean you're

00:17:47,830 --> 00:17:52,659
touching on the practicality right which

00:17:49,690 --> 00:17:55,780
is that while this is in transition it's

00:17:52,659 --> 00:17:57,520
gonna be a little bit messy but the

00:17:55,780 --> 00:17:59,470
closer you get to what we're we're

00:17:57,520 --> 00:18:01,990
trying to get to the less working lab

00:17:59,470 --> 00:18:03,850
later and I've tried to work through

00:18:01,990 --> 00:18:06,610
some corner cases that I'm sure I have

00:18:03,850 --> 00:18:09,520
not worked through all of them and in

00:18:06,610 --> 00:18:12,730
some cases we made to start with well

00:18:09,520 --> 00:18:15,159
for this this binding property our

00:18:12,730 --> 00:18:17,140
constraint is the freeform text that we

00:18:15,159 --> 00:18:21,100
had already because we haven't figured

00:18:17,140 --> 00:18:23,470
out how to improve that but as long as

00:18:21,100 --> 00:18:29,700
overall document structure is following

00:18:23,470 --> 00:18:34,809
it that's an improvement on its own so I

00:18:29,700 --> 00:18:38,200
had a comment about the something he

00:18:34,809 --> 00:18:42,220
said earlier about device priests are

00:18:38,200 --> 00:18:44,080
hard essentially and and you keep having

00:18:42,220 --> 00:18:49,360
to mention that you know it describes

00:18:44,080 --> 00:18:51,789
the hardware and so on and so forth I'm

00:18:49,360 --> 00:18:53,409
wondering if ask Emma actually solves

00:18:51,789 --> 00:18:55,150
that particular issue and I apologize

00:18:53,409 --> 00:18:57,789
them I'm sure poking the bear here but

00:18:55,150 --> 00:18:59,650
in fact the matter is a lot of Linux

00:18:57,789 --> 00:19:03,429
people trying to dick around with the

00:18:59,650 --> 00:19:05,890
device trees don't actually understand

00:19:03,429 --> 00:19:08,950
hardware or can't get the documentation

00:19:05,890 --> 00:19:11,110
and that's what's hard is understanding

00:19:08,950 --> 00:19:14,830
how it works and putting it together I

00:19:11,110 --> 00:19:17,590
think as opposed to you know trying to

00:19:14,830 --> 00:19:21,250
actually put it in you know if you will

00:19:17,590 --> 00:19:21,790
on paper yeah no it won't it doesn't

00:19:21,250 --> 00:19:25,840
help

00:19:21,790 --> 00:19:29,230
aspect at all what I've been thinking of

00:19:25,840 --> 00:19:40,240
recently is a do and don't list of

00:19:29,230 --> 00:19:41,560
writing bindings guide so yeah DTS is

00:19:40,240 --> 00:19:43,240
interesting right it's it's an

00:19:41,560 --> 00:19:45,300
interesting language it's it's pretty

00:19:43,240 --> 00:19:47,950
much string parsing into a binary format

00:19:45,300 --> 00:19:51,220
it's completely untyped everything is

00:19:47,950 --> 00:19:53,260
freeform and where instead of adding

00:19:51,220 --> 00:19:55,270
typing we're choosing to document the

00:19:53,260 --> 00:19:57,670
types and and running checkers based on

00:19:55,270 --> 00:20:00,280
that which is a large step forward and I

00:19:57,670 --> 00:20:01,870
know that it has alerting it to a type

00:20:00,280 --> 00:20:04,210
language or something like that is gonna

00:20:01,870 --> 00:20:06,420
be a much steeper hill to climb so this

00:20:04,210 --> 00:20:11,430
is definitely an improvement yeah

00:20:06,420 --> 00:20:11,430
DTS has typing dtb does not

00:20:19,500 --> 00:20:24,450
purely rhetorical question but I've been

00:20:22,200 --> 00:20:29,580
waiting to ask for five years will there

00:20:24,450 --> 00:20:32,879
be an automatic translator to ACPI I'm

00:20:29,580 --> 00:20:35,539
sorry what is a CPI you forgot to attach

00:20:32,879 --> 00:20:35,539
a punch

00:20:38,269 --> 00:20:46,879
alright other questions so moving on so

00:20:44,190 --> 00:20:49,649
kind of what are the goals of using

00:20:46,879 --> 00:20:54,389
schema and using JSON schema in

00:20:49,649 --> 00:20:58,259
particular so we want to define a DT

00:20:54,389 --> 00:21:02,029
schema language that's human readable

00:20:58,259 --> 00:21:06,440
you man friendly machine readable and

00:21:02,029 --> 00:21:06,440
includes all the binding documentation

00:21:07,789 --> 00:21:16,950
better tooling to validate DTS files at

00:21:12,690 --> 00:21:24,929
build time not it's not the kernels job

00:21:16,950 --> 00:21:26,399
to validate your DT question what type

00:21:24,929 --> 00:21:27,929
of validation are you gonna be using on

00:21:26,399 --> 00:21:30,570
the schema have you been thinking about

00:21:27,929 --> 00:21:35,399
that already or not what for validating

00:21:30,570 --> 00:21:44,070
the schema so schema has I'll get into

00:21:35,399 --> 00:21:49,860
that on the next slide I think okay it's

00:21:44,070 --> 00:21:54,090
schema all the way down and we want to

00:21:49,860 --> 00:21:56,690
leverage existing technology I don't

00:21:54,090 --> 00:21:59,429
want to write a schema language and

00:21:56,690 --> 00:22:01,320
write a long document describing that

00:21:59,429 --> 00:22:04,320
schema language I want to use something

00:22:01,320 --> 00:22:07,460
that's already there and I'm lazy I

00:22:04,320 --> 00:22:07,460
don't want to write a lot of code either

00:22:07,909 --> 00:22:14,940
and then finally there's some there's a

00:22:12,840 --> 00:22:17,039
desire to also be able to generate the

00:22:14,940 --> 00:22:21,929
specification documentation from the

00:22:17,039 --> 00:22:23,280
schema Docs that's grants wish so grants

00:22:21,929 --> 00:22:28,550
gonna do that part

00:22:23,280 --> 00:22:28,550
[Laughter]

00:22:29,179 --> 00:22:37,169
I'm on my wish list in the tooling when

00:22:33,929 --> 00:22:40,889
the device resource has been validated

00:22:37,169 --> 00:22:43,999
by the validation subsystem I'd like in

00:22:40,889 --> 00:22:45,989
our brand-new FD T format have

00:22:43,999 --> 00:22:48,570
confirmation that that actually was

00:22:45,989 --> 00:22:50,940
confirmed and then the kernel could

00:22:48,570 --> 00:22:53,580
choose to refuse to load it without that

00:22:50,940 --> 00:22:55,409
or it might be a little bit more

00:22:53,580 --> 00:22:57,059
friendly and just warn you that you

00:22:55,409 --> 00:22:58,919
weren't validated currently if the

00:22:57,059 --> 00:23:01,889
kernel doesn't build the C compiler

00:22:58,919 --> 00:23:03,480
fails you can't load that kernel so it's

00:23:01,889 --> 00:23:05,399
kind of that same concept I want to try

00:23:03,480 --> 00:23:09,059
and push toward to the device tree as

00:23:05,399 --> 00:23:11,100
well practically speaking people are

00:23:09,059 --> 00:23:12,480
just gonna hack the DCP to set that flag

00:23:11,100 --> 00:23:14,009
and it becomes useless if we're gonna do

00:23:12,480 --> 00:23:20,340
that we have to do runtime validation

00:23:14,009 --> 00:23:22,499
the only way to attack the elf files - I

00:23:20,340 --> 00:23:25,559
mean I'm not too concerned if people do

00:23:22,499 --> 00:23:28,679
that that's their problem and they're on

00:23:25,559 --> 00:23:30,450
their own so what I didn't see I'm not

00:23:28,679 --> 00:23:31,499
looking to know about Eligius actors

00:23:30,450 --> 00:23:33,989
yeah sure if you're gonna fail the

00:23:31,499 --> 00:23:35,820
validation until time just don't don't

00:23:33,989 --> 00:23:36,989
allow the DTV to be built rather than

00:23:35,820 --> 00:23:38,970
second if there's no point having the

00:23:36,989 --> 00:23:43,820
flag the there is no one that that

00:23:38,970 --> 00:23:43,820
benefits do it w earth

00:23:48,110 --> 00:23:53,899
how about overlays how about how about

00:23:51,320 --> 00:23:55,820
changing things dynamically how can we

00:23:53,899 --> 00:23:58,760
validate those without having runtime

00:23:55,820 --> 00:24:04,450
validation that's actually a really

00:23:58,760 --> 00:24:07,850
naughty question k and OTT why there

00:24:04,450 --> 00:24:10,539
there are a few approaches to it one is

00:24:07,850 --> 00:24:13,250
that you would actually have the base

00:24:10,539 --> 00:24:16,010
source and the overlay source and

00:24:13,250 --> 00:24:18,789
validate them as a whole and that runs

00:24:16,010 --> 00:24:21,440
into all kinds of problems with the

00:24:18,789 --> 00:24:24,950
number of possible permutations how the

00:24:21,440 --> 00:24:27,019
heck do you do that one solutions that's

00:24:24,950 --> 00:24:30,590
been suggested is to do runtime

00:24:27,019 --> 00:24:32,750
validation in the kernel which I think

00:24:30,590 --> 00:24:35,210
has a whole nother set of complexities

00:24:32,750 --> 00:24:37,039
and issues but yeah that's a real

00:24:35,210 --> 00:24:39,409
interesting question that we really need

00:24:37,039 --> 00:24:42,409
to deal with with with the overlays when

00:24:39,409 --> 00:24:44,740
we get further into overlays just make

00:24:42,409 --> 00:24:46,730
sure that we don't preclude I'm hearing

00:24:44,740 --> 00:24:48,769
you know that we don't want to do

00:24:46,730 --> 00:24:50,120
runtime validation but I think rent and

00:24:48,769 --> 00:24:52,730
validation is going to be required in

00:24:50,120 --> 00:24:55,519
that situation it may end up being

00:24:52,730 --> 00:24:57,710
required I I really really hope it's not

00:24:55,519 --> 00:24:59,419
just because the extra complex's but but

00:24:57,710 --> 00:25:01,669
if it if it is it is you know it's

00:24:59,419 --> 00:25:03,889
whatever reality is if you're watching

00:25:01,669 --> 00:25:06,950
user space applying overlays then you

00:25:03,889 --> 00:25:13,730
can do all that in user space yeah

00:25:06,950 --> 00:25:16,490
potentially a good point um to some

00:25:13,730 --> 00:25:19,130
extent very limited not just kemar based

00:25:16,490 --> 00:25:21,169
we already played with FPGA manager look

00:25:19,130 --> 00:25:23,389
at the properties of overlays that come

00:25:21,169 --> 00:25:25,760
in with into notifier I'll talk a bit

00:25:23,389 --> 00:25:27,200
about that later but so that would be a

00:25:25,760 --> 00:25:29,480
way where he could plug a runtime

00:25:27,200 --> 00:25:31,130
validator and then just reject the

00:25:29,480 --> 00:25:34,179
overlay if it doesn't pass whatever

00:25:31,130 --> 00:25:34,179
tests we put there

00:25:37,860 --> 00:25:45,120
so going back to Mark's point I think it

00:25:42,419 --> 00:25:47,760
was so one problem with this error now

00:25:45,120 --> 00:25:51,870
is that there's thousands of warnings

00:25:47,760 --> 00:25:53,700
and a lot of it's not critical right and

00:25:51,870 --> 00:25:59,309
we could split it between errors and

00:25:53,700 --> 00:26:03,600
warnings but most of it is just defining

00:25:59,309 --> 00:26:05,490
more rules around what what findings

00:26:03,600 --> 00:26:09,120
should look like and what the overall

00:26:05,490 --> 00:26:10,769
tree structure should look like and my

00:26:09,120 --> 00:26:14,220
suggestion that the kernel might not

00:26:10,769 --> 00:26:15,570
choose to load a interval a with errors

00:26:14,220 --> 00:26:17,010
when you're developing you actually

00:26:15,570 --> 00:26:19,110
might want to you might have you know

00:26:17,010 --> 00:26:20,940
really that's partially good and all the

00:26:19,110 --> 00:26:22,409
sections that you care about for your

00:26:20,940 --> 00:26:24,240
current development tasks are good

00:26:22,409 --> 00:26:26,820
enough so we definitely would need an

00:26:24,240 --> 00:26:29,600
override if the kernel was was being

00:26:26,820 --> 00:26:29,600
prescriptive

00:26:34,090 --> 00:26:44,340
all right so current status of where I'm

00:26:37,660 --> 00:26:49,000
at on on this so we're using JSON schema

00:26:44,340 --> 00:26:51,100
draft six there's they're up to I think

00:26:49,000 --> 00:26:58,240
draft seven is out and working on draft

00:26:51,100 --> 00:27:01,630
ate already schema Doc's are in the amel

00:26:58,240 --> 00:27:06,330
format so they're not actually JSON but

00:27:01,630 --> 00:27:10,150
it's a JSON compatible subset ymo

00:27:06,330 --> 00:27:13,920
comments is one big one and it's

00:27:10,150 --> 00:27:13,920
generally deemed more human readable

00:27:14,220 --> 00:27:25,030
it's also we have one schema for a file

00:27:18,540 --> 00:27:27,640
this is this has come up that we animal

00:27:25,030 --> 00:27:31,900
could support multiple schemas in one

00:27:27,640 --> 00:27:34,990
file but JSON generally does not and

00:27:31,900 --> 00:27:41,620
that breaks this schema ID it's a file

00:27:34,990 --> 00:27:46,090
name mapping dtc already now supports

00:27:41,620 --> 00:27:54,040
yellow output that went in about a month

00:27:46,090 --> 00:27:58,870
or two ago now it's a completely

00:27:54,040 --> 00:28:02,670
undocumented subject to change don't use

00:27:58,870 --> 00:28:02,670
it as a fixed format

00:28:06,550 --> 00:28:14,680
so the tools are written in Python 3

00:28:09,300 --> 00:28:18,480
using the ML parser and JSON schema

00:28:14,680 --> 00:28:22,360
modules and that's the link to the repo

00:28:18,480 --> 00:28:27,790
that has the meta schema which is what

00:28:22,360 --> 00:28:31,780
validates the schema it has some core

00:28:27,790 --> 00:28:36,660
schema in there as well and some some

00:28:31,780 --> 00:28:36,660
test cases

00:28:45,100 --> 00:28:52,870
so you can install this with pip this is

00:28:48,850 --> 00:29:03,870
one step it's been tested but as far as

00:28:52,870 --> 00:29:03,870
I know by me and then repeating

00:29:05,880 --> 00:29:11,070
so I've also been working on integrating

00:29:08,220 --> 00:29:14,610
this into the kernel build so it can

00:29:11,070 --> 00:29:18,240
validate the docks and it can also do

00:29:14,610 --> 00:29:20,760
DTS validation with the schema I've

00:29:18,240 --> 00:29:22,940
converted some of the schema well

00:29:20,760 --> 00:29:26,370
there's the core schema in the animal

00:29:22,940 --> 00:29:31,559
bindings project and I did a bunch of

00:29:26,370 --> 00:29:35,100
our board level bindings and then a few

00:29:31,559 --> 00:29:39,750
other cases and I have a tool that kind

00:29:35,100 --> 00:29:44,520
of can extract the binding document and

00:29:39,750 --> 00:29:51,690
build the initial schema doc it's not

00:29:44,520 --> 00:29:55,470
perfect but it's more than nothing we

00:29:51,690 --> 00:29:59,190
can validate support for size properties

00:29:55,470 --> 00:30:04,020
and P handles that required a few

00:29:59,190 --> 00:30:06,000
extensions to the schema language but

00:30:04,020 --> 00:30:13,169
that's really the only place we've

00:30:06,000 --> 00:30:14,700
defined our own schema keywords and I've

00:30:13,169 --> 00:30:22,100
also had to do a lot of work to get the

00:30:14,700 --> 00:30:22,100
build time to be reasonable so it it's

00:30:23,090 --> 00:30:32,730
it's not fast but it's not terribly slow

00:30:26,700 --> 00:30:36,679
now and but we also have like I don't

00:30:32,730 --> 00:30:44,720
know 50 schema that are applied and not

00:30:36,679 --> 00:30:48,150
3000i rum have we considered taking the

00:30:44,720 --> 00:30:50,159
an alternate build path for validation

00:30:48,150 --> 00:30:51,990
in the schema so that the the normal

00:30:50,159 --> 00:30:57,320
build for the kernel doesn't actually do

00:30:51,990 --> 00:30:57,320
the schema validation so

00:30:58,890 --> 00:31:07,500
it's a good question cuz yes so did this

00:31:04,110 --> 00:31:10,480
this is the build flow currently it is

00:31:07,500 --> 00:31:15,280
completely to the side of the normal

00:31:10,480 --> 00:31:18,910
build because for two reasons it slows

00:31:15,280 --> 00:31:23,470
it down and and secondly it adds lots of

00:31:18,910 --> 00:31:25,690
warnings in dtc does the same thing

00:31:23,470 --> 00:31:30,429
adding warnings but we turn those on by

00:31:25,690 --> 00:31:37,539
default and I have I didn't really want

00:31:30,429 --> 00:31:40,150
to do that here so kind of the first

00:31:37,539 --> 00:31:42,940
dependency is that all the schema or

00:31:40,150 --> 00:31:47,559
files or binding docs which can be both

00:31:42,940 --> 00:31:51,750
from the green that's in the the kernel

00:31:47,559 --> 00:31:56,110
or the core schema that are in the

00:31:51,750 --> 00:31:58,419
yellowish those are all validated

00:31:56,110 --> 00:32:03,039
against the metaschema the metaschema

00:31:58,419 --> 00:32:07,240
kind of limits what is what we allow for

00:32:03,039 --> 00:32:10,030
within the schema documents which is a

00:32:07,240 --> 00:32:15,780
subset and hopefully constrain stuff

00:32:10,030 --> 00:32:18,669
enough that you can only write valid

00:32:15,780 --> 00:32:22,809
JSON schema because it's kind of easy to

00:32:18,669 --> 00:32:27,640
write stuff that's not valid and a

00:32:22,809 --> 00:32:28,990
feature of JSON schema is that it if it

00:32:27,640 --> 00:32:33,909
doesn't understand the keyword it

00:32:28,990 --> 00:32:39,850
ignores it and it's also a case

00:32:33,909 --> 00:32:43,419
sensitive so you run make DT binding

00:32:39,850 --> 00:32:48,549
check that builds checks all the schema

00:32:43,419 --> 00:32:51,700
Docs and builds a process schema so

00:32:48,549 --> 00:32:54,270
that's for two reasons one is we do a

00:32:51,700 --> 00:32:57,280
bit of post-processing on the schema two

00:32:54,270 --> 00:33:03,580
to add some additional properties in

00:32:57,280 --> 00:33:06,610
that are not to default for JSON schema

00:33:03,580 --> 00:33:08,970
but we generally want to be the default

00:33:06,610 --> 00:33:08,970
on

00:33:09,140 --> 00:33:15,180
four bindings and that's basically array

00:33:12,630 --> 00:33:19,560
sizes how many how many elements you

00:33:15,180 --> 00:33:22,710
have the default is you can add more and

00:33:19,560 --> 00:33:28,620
it's still valid we want it to be fixed

00:33:22,710 --> 00:33:33,930
and so we fix that up and also the yeah

00:33:28,620 --> 00:33:38,970
mol encoding is which I think's in the

00:33:33,930 --> 00:33:44,060
next slide always like encodes even a

00:33:38,970 --> 00:33:47,610
single int as a matrix a 1 by 1 matrix

00:33:44,060 --> 00:33:53,790
and so we fix that up so it's the

00:33:47,610 --> 00:33:59,130
binding doc just defines an int and we

00:33:53,790 --> 00:34:01,530
fix it up to be 1 by 1 matrix so then

00:33:59,130 --> 00:34:08,669
the process schema file is generated

00:34:01,530 --> 00:34:14,909
then you can run make DT B's check which

00:34:08,669 --> 00:34:17,600
runs DTC and generates from DT dot DT ya

00:34:14,909 --> 00:34:24,560
mol file which is the Gamal encoding the

00:34:17,600 --> 00:34:30,090
DTS built DTS then runs that through the

00:34:24,560 --> 00:34:32,390
validation tool and dumps out a bunch of

00:34:30,090 --> 00:34:32,390
warnings

00:34:36,820 --> 00:34:45,340
so what does the camel encoding look

00:34:39,220 --> 00:34:48,550
like so it's as I mentioned it's

00:34:45,340 --> 00:34:55,360
supported in DTC it's it's kind of an

00:34:48,550 --> 00:34:57,970
intermediate format so the kind of

00:34:55,360 --> 00:35:01,510
unusual things or strings are always an

00:34:57,970 --> 00:35:08,110
array or lists and scalars are always a

00:35:01,510 --> 00:35:12,460
matrix and then the DTS bracketing is

00:35:08,110 --> 00:35:17,860
also maintained through the through the

00:35:12,460 --> 00:35:21,180
tool chain and that's probably going to

00:35:17,860 --> 00:35:27,420
require DTS changes to make those

00:35:21,180 --> 00:35:31,080
correct if we want to tighten that up

00:35:27,420 --> 00:35:31,080
and I think there's

00:35:31,240 --> 00:35:40,480
and then it also outputs the type tags

00:35:35,230 --> 00:35:47,880
like you see the last property is a P

00:35:40,480 --> 00:35:50,980
handle with cells or without cells it

00:35:47,880 --> 00:36:01,230
and then for size properties you have

00:35:50,980 --> 00:36:05,020
the bang you a are you 64 question I

00:36:01,230 --> 00:36:08,770
noticed in the example that the scalar

00:36:05,020 --> 00:36:10,839
matrices have groupings that kind of

00:36:08,770 --> 00:36:14,800
encompass the type is does that grouping

00:36:10,839 --> 00:36:17,099
come from the schema file or how does it

00:36:14,800 --> 00:36:22,300
infer how to group things in the arrays

00:36:17,099 --> 00:36:23,980
so see in your universe is example word

00:36:22,300 --> 00:36:27,089
has one member and then a centenario

00:36:23,980 --> 00:36:31,270
that members so DTS only allows

00:36:27,089 --> 00:36:34,150
basically in that form case you can only

00:36:31,270 --> 00:36:37,050
have us the ya mol format could support

00:36:34,150 --> 00:36:41,290
different size types within a property

00:36:37,050 --> 00:36:44,609
but we in DTS we only support a single

00:36:41,290 --> 00:36:44,609
size for a property

00:36:48,310 --> 00:36:54,070
okay

00:36:50,350 --> 00:36:56,330
so that that's the example of the of the

00:36:54,070 --> 00:37:01,040
greater-than less-than brackets being

00:36:56,330 --> 00:37:03,980
maintained so in that case the first

00:37:01,040 --> 00:37:05,960
interrupt has one interrupt cell and the

00:37:03,980 --> 00:37:09,020
second interrupt has three ended up

00:37:05,960 --> 00:37:10,850
cells so so this is this is a case where

00:37:09,020 --> 00:37:13,040
we would like to have a bunch of type

00:37:10,850 --> 00:37:15,110
information from DTS but if the

00:37:13,040 --> 00:37:19,610
information is just not there right as

00:37:15,110 --> 00:37:22,930
we always we adopted years back just

00:37:19,610 --> 00:37:26,090
straight out DT and the byte encoding

00:37:22,930 --> 00:37:28,190
that followed through two DTS and DTS is

00:37:26,090 --> 00:37:31,040
missing the information that we need so

00:37:28,190 --> 00:37:32,780
for example interrupts cells it would

00:37:31,040 --> 00:37:35,330
make sense it may be missing an

00:37:32,780 --> 00:37:38,740
information the some of them for me may

00:37:35,330 --> 00:37:41,180
be missing that information you're right

00:37:38,740 --> 00:37:42,710
some of that we have so like interrupts

00:37:41,180 --> 00:37:44,600
cells it would make sense for interrupts

00:37:42,710 --> 00:37:47,420
with cond interrupt cells to be just a

00:37:44,600 --> 00:37:49,940
bear - right but we don't have that

00:37:47,420 --> 00:37:51,500
information in the DTS without encoding

00:37:49,940 --> 00:37:53,960
what the actual value is it would be

00:37:51,500 --> 00:37:57,530
nice to move to that but we don't have

00:37:53,960 --> 00:37:59,330
that information now interrupts like

00:37:57,530 --> 00:38:02,150
with the ten and then the three cell 11

00:37:59,330 --> 00:38:03,500
1-0 we've got that information in DTS

00:38:02,150 --> 00:38:05,510
because they're grouped with the angle

00:38:03,500 --> 00:38:07,190
brackets there's nothing enforcing that

00:38:05,510 --> 00:38:09,470
but it is there so let's use that

00:38:07,190 --> 00:38:12,320
information and then make the schemas

00:38:09,470 --> 00:38:13,790
depend on that this is actually a place

00:38:12,320 --> 00:38:16,520
where we can start getting more type

00:38:13,790 --> 00:38:19,760
information into GTS once the schemas

00:38:16,520 --> 00:38:21,920
are there because we can potentially go

00:38:19,760 --> 00:38:24,500
backwards and go through if we define

00:38:21,920 --> 00:38:27,200
new syntax and DTS to define the

00:38:24,500 --> 00:38:29,270
Taipings to find the groupings put it

00:38:27,200 --> 00:38:32,150
into the schema and then use the schema

00:38:29,270 --> 00:38:34,850
to reinterpret the DTS and put that

00:38:32,150 --> 00:38:36,770
information back in but it does require

00:38:34,850 --> 00:38:38,120
DTS changes to get the kind of type

00:38:36,770 --> 00:38:41,060
information that we really would like to

00:38:38,120 --> 00:38:45,500
have and I actually have a patch for DTC

00:38:41,060 --> 00:38:49,250
that will give you warnings if if the

00:38:45,500 --> 00:38:51,410
bracketing is wrong in the cases that

00:38:49,250 --> 00:38:52,870
can detect which are like dinner up

00:38:51,410 --> 00:38:57,340
cells that can

00:38:52,870 --> 00:38:59,990
see if those bracketing line up

00:38:57,340 --> 00:39:02,000
it's also why some of the Djamel

00:38:59,990 --> 00:39:05,090
encoding is kind of ugly

00:39:02,000 --> 00:39:07,270
for example interrupt cells being nested

00:39:05,090 --> 00:39:10,340
into arrays or

00:39:07,270 --> 00:39:12,650
like strings are always in a in a list

00:39:10,340 --> 00:39:14,390
when sometimes a property just wants a

00:39:12,650 --> 00:39:15,530
string there's no there's never going to

00:39:14,390 --> 00:39:17,540
be a list there and it would be nice to

00:39:15,530 --> 00:39:20,540
differentiate between the two right

00:39:17,540 --> 00:39:22,700
compatible will always be a list but a

00:39:20,540 --> 00:39:24,970
model should only always be just a

00:39:22,700 --> 00:39:24,970
string

00:39:34,970 --> 00:39:44,810
okay so what is the schema doc look like

00:39:38,030 --> 00:39:48,520
this this is the the top level keys and

00:39:44,810 --> 00:39:52,460
what's in the schema doc and all but the

00:39:48,520 --> 00:39:56,869
ones with asterisks are standard JSON

00:39:52,460 --> 00:40:05,990
schema vocabulary words so we've we've

00:39:56,869 --> 00:40:09,980
added maintain errs and select so kind

00:40:05,990 --> 00:40:11,000
of the first the first - well the ID is

00:40:09,980 --> 00:40:16,869
URI

00:40:11,000 --> 00:40:16,869
- it's basically a unique identifier

00:40:17,440 --> 00:40:27,800
right now it's HTTP colon slash slash

00:40:23,869 --> 00:40:30,950
device treat org slash schemas slash

00:40:27,800 --> 00:40:33,140
something there's not if you go that URL

00:40:30,950 --> 00:40:37,250
there's nothing there it's just kind of

00:40:33,140 --> 00:40:42,950
convention some people I think use just

00:40:37,250 --> 00:40:46,720
file colon slash slash but it's it can't

00:40:42,950 --> 00:40:50,329
the validators can do lookups based on

00:40:46,720 --> 00:40:52,910
actual URLs but we're not using that in

00:40:50,329 --> 00:40:56,089
the tool basically rewrites the path

00:40:52,910 --> 00:41:02,839
when it does referencing to other schema

00:40:56,089 --> 00:41:11,780
dogs schema is just what metaschema this

00:41:02,839 --> 00:41:15,010
the schema hairs - so this is this

00:41:11,780 --> 00:41:21,140
points back to the metaschema and the

00:41:15,010 --> 00:41:24,470
for the animal bindings project and tied

00:41:21,140 --> 00:41:30,859
all description generally my tool that

00:41:24,470 --> 00:41:36,400
extracts from from the binding documents

00:41:30,859 --> 00:41:39,230
can extract these out as well as does

00:41:36,400 --> 00:41:42,710
some finding they'll maintain errs not

00:41:39,230 --> 00:41:47,859
very well though and can extract the

00:41:42,710 --> 00:41:47,859
examples out usually and that's about it

00:41:51,800 --> 00:41:58,970
the meat of it is the properties and

00:41:55,550 --> 00:42:01,100
pattern properties optionally which is

00:41:58,970 --> 00:42:05,869
the kind of the list of all the

00:42:01,100 --> 00:42:08,420
properties for a binding so within the

00:42:05,869 --> 00:42:10,780
property schema the next level is you

00:42:08,420 --> 00:42:15,140
have the list of all the property names

00:42:10,780 --> 00:42:17,770
this is the primary part of what's used

00:42:15,140 --> 00:42:17,770
for validation

00:42:20,630 --> 00:42:27,440
you can also recur stone in more levels

00:42:24,350 --> 00:42:30,410
and you can have child nodes a child

00:42:27,440 --> 00:42:36,320
node defined by its name and it's just a

00:42:30,410 --> 00:42:38,930
property or it could be a it can also be

00:42:36,320 --> 00:42:44,210
a pattern property if it's has a unit

00:42:38,930 --> 00:42:47,030
address for example then you define

00:42:44,210 --> 00:42:55,640
properties again under that for child

00:42:47,030 --> 00:42:58,369
node properties so what's required and

00:42:55,640 --> 00:43:01,220
each property depends on what class of

00:42:58,369 --> 00:43:05,180
property is is it a common property like

00:43:01,220 --> 00:43:10,190
reg or interrupts or is it a binding

00:43:05,180 --> 00:43:13,609
specific property then it then it looks

00:43:10,190 --> 00:43:16,880
a little different and generally it

00:43:13,609 --> 00:43:19,250
requires a reference to back to the core

00:43:16,880 --> 00:43:22,480
schema and we have types to find there

00:43:19,250 --> 00:43:22,480
for for that

00:43:28,260 --> 00:43:35,450
so here's two examples of what some

00:43:31,730 --> 00:43:41,040
common property examples would look like

00:43:35,450 --> 00:43:45,359
so clock frequency is what this kind of

00:43:41,040 --> 00:43:47,940
older binding for clocks and here we're

00:43:45,359 --> 00:43:52,680
just defining this between a hundred and

00:43:47,940 --> 00:43:57,390
two hundred Hertz we don't need to say

00:43:52,680 --> 00:44:03,270
that it's a a integer because the core

00:43:57,390 --> 00:44:08,670
schema does that for you and then with

00:44:03,270 --> 00:44:15,930
reg so in this case we have to register

00:44:08,670 --> 00:44:17,190
ranges and it's a list of items and the

00:44:15,930 --> 00:44:19,740
main thing we need to know here is that

00:44:17,190 --> 00:44:24,119
it's two items and what they are in

00:44:19,740 --> 00:44:26,700
order so it the the numbers kind of

00:44:24,119 --> 00:44:30,210
implied from how many items are in your

00:44:26,700 --> 00:44:34,380
list and then the the post-processing

00:44:30,210 --> 00:44:39,000
adds min items and Max items if there's

00:44:34,380 --> 00:44:41,160
not a minute UM's for max items and if

00:44:39,000 --> 00:44:43,650
you need of if you have cases where it

00:44:41,160 --> 00:44:47,900
needs to be variable then you put those

00:44:43,650 --> 00:44:47,900
in and give the range of how many items

00:44:51,180 --> 00:45:03,530
and for a vendor property so these

00:44:58,800 --> 00:45:08,340
typically are done in a way where your

00:45:03,530 --> 00:45:12,210
sub classing the base class and the way

00:45:08,340 --> 00:45:17,130
you do that in json schema is using the

00:45:12,210 --> 00:45:20,070
olive keyword and that's the list of

00:45:17,130 --> 00:45:25,470
schemas under it and one is a reference

00:45:20,070 --> 00:45:31,400
to the base type and then the next one

00:45:25,470 --> 00:45:37,080
is the binding specific constraints and

00:45:31,400 --> 00:45:40,140
then metaschema requires that vendor

00:45:37,080 --> 00:45:46,950
properties have descriptions so we have

00:45:40,140 --> 00:45:50,360
a description here and then a string

00:45:46,950 --> 00:45:50,360
property is very similar

00:45:53,650 --> 00:46:03,730
there's many more examples in the both

00:45:57,400 --> 00:46:09,210
the kernel schema that I've converted

00:46:03,730 --> 00:46:09,210
and in the in the camel bindings project

00:46:10,950 --> 00:46:14,220
questions on this

00:46:17,650 --> 00:46:22,680
this is the guts of what people have the

00:46:20,470 --> 00:46:22,680
right

00:46:32,130 --> 00:46:40,440
so some some gotchas of what I've

00:46:34,860 --> 00:46:47,760
learned in my months of learning JSON

00:46:40,440 --> 00:46:49,830
schema and Python - so yeah mole is that

00:46:47,760 --> 00:46:52,650
will kind of one downside I've found is

00:46:49,830 --> 00:46:55,470
it's indentation sensitive and doesn't

00:46:52,650 --> 00:46:59,390
like tabs so it's kind of like make

00:46:55,470 --> 00:46:59,390
files in Python combined

00:47:05,360 --> 00:47:10,820
is there a linter that should be used

00:47:07,130 --> 00:47:13,280
here I don't think there is one

00:47:10,820 --> 00:47:21,230
I've written a tool called yeah mol

00:47:13,280 --> 00:47:27,760
format that does some of that that's in

00:47:21,230 --> 00:47:27,760
the mo bindings project and

00:47:31,230 --> 00:47:35,790
so the other things JSON schema keywords

00:47:33,869 --> 00:47:38,730
are case-sensitive and then combined

00:47:35,790 --> 00:47:40,829
with that the validator handling of

00:47:38,730 --> 00:47:45,780
unknown json schema keywords is to

00:47:40,829 --> 00:47:49,079
ignore them if you you get the case

00:47:45,780 --> 00:47:53,640
wrong on all of it will silently ignore

00:47:49,079 --> 00:47:59,130
it normally that should get caught by

00:47:53,640 --> 00:48:02,130
the metaschema and some validators can

00:47:59,130 --> 00:48:09,690
have modes to warn you on that but

00:48:02,130 --> 00:48:11,849
unfortunately the Python one is not I

00:48:09,690 --> 00:48:14,310
was just wondering if we're if we can

00:48:11,849 --> 00:48:16,530
get the ruh Amal one to start behaving

00:48:14,310 --> 00:48:26,250
that way but you just answer that

00:48:16,530 --> 00:48:29,190
questions and then one question that's

00:48:26,250 --> 00:48:32,579
come up on the reviews of what I've sent

00:48:29,190 --> 00:48:34,740
out is like for reg and reg names can we

00:48:32,579 --> 00:48:40,069
how do we say that they have to be the

00:48:34,740 --> 00:48:40,069
same size that's not easily expressed

00:48:40,490 --> 00:48:49,460
generally data is not dependent on other

00:48:43,410 --> 00:48:52,800
data in JSON schema there's some work

00:48:49,460 --> 00:48:57,960
upstream in the specification to address

00:48:52,800 --> 00:48:59,839
that next slide and next slide I have

00:48:57,960 --> 00:49:04,740
how it would look if you wanted to do it

00:48:59,839 --> 00:49:09,140
and it's not very pretty the other thing

00:49:04,740 --> 00:49:14,369
is using the all of one of any of

00:49:09,140 --> 00:49:18,960
operators results in vague error

00:49:14,369 --> 00:49:21,980
messages and we're kind of using those

00:49:18,960 --> 00:49:21,980
in a lot of places

00:49:24,560 --> 00:49:29,910
and it's only one binding per dock so

00:49:28,440 --> 00:49:36,390
some of the docs will probably have to

00:49:29,910 --> 00:49:39,930
be reorganized this come up before my

00:49:36,390 --> 00:49:41,790
talk at connect on this so we could

00:49:39,930 --> 00:49:44,910
support more in the amyl because you can

00:49:41,790 --> 00:49:47,580
do multiple gamal docks in in a single

00:49:44,910 --> 00:49:51,090
document but then that would break how

00:49:47,580 --> 00:49:54,810
the reference handling works were it it

00:49:51,090 --> 00:49:57,600
looks at the ID to to get the path to

00:49:54,810 --> 00:50:01,550
the to your reference if it's not a full

00:49:57,600 --> 00:50:10,590
path so what's the relationship between

00:50:01,550 --> 00:50:19,170
Jason and Amal the Amal is a superset of

00:50:10,590 --> 00:50:24,330
JSON and all the tags that you saw in in

00:50:19,170 --> 00:50:27,480
the DTE animal output there is one

00:50:24,330 --> 00:50:29,840
example of what Gamal can do that JSON

00:50:27,480 --> 00:50:29,840
cannot

00:50:33,250 --> 00:50:38,890
and then JSON schema is really no

00:50:36,690 --> 00:50:43,720
relationship to JSON other than you

00:50:38,890 --> 00:50:45,640
typically write it in JSON but it

00:50:43,720 --> 00:50:47,830
doesn't have to be and that there's

00:50:45,640 --> 00:50:53,830
other people out there using animal as

00:50:47,830 --> 00:50:54,550
the document format you think the ads

00:50:53,830 --> 00:50:59,290
are great

00:50:54,550 --> 00:51:03,369
so both JSON and Y Amal encode or map

00:50:59,290 --> 00:51:06,280
quite nicely from the text format and

00:51:03,369 --> 00:51:07,780
the the runtime format in memory when

00:51:06,280 --> 00:51:10,240
you're in python or another other

00:51:07,780 --> 00:51:12,640
languages a JSON file it can always be

00:51:10,240 --> 00:51:13,599
read by a Mel parser the other the

00:51:12,640 --> 00:51:17,109
converse is not true

00:51:13,599 --> 00:51:20,619
when we're using JSON schema it doesn't

00:51:17,109 --> 00:51:23,230
actually operate on JSON it's specified

00:51:20,619 --> 00:51:27,599
with the JSON format but all the parsers

00:51:23,230 --> 00:51:29,680
you loaded in you get the runtime and

00:51:27,599 --> 00:51:35,710
you get the runtime encoding or the

00:51:29,680 --> 00:51:38,830
runtime version of the data and then you

00:51:35,710 --> 00:51:42,250
run the JSON schema parser with the

00:51:38,830 --> 00:51:44,020
preloaded data that you're checking and

00:51:42,250 --> 00:51:45,400
the preloaded schemas so it doesn't

00:51:44,020 --> 00:51:47,290
matter if you're loading it from JSON or

00:51:45,400 --> 00:51:48,730
if you're loading it from llamó as far

00:51:47,290 --> 00:51:53,080
as JSON schema is concerned it's the

00:51:48,730 --> 00:51:55,359
same but yes as Rob said yamo gives us

00:51:53,080 --> 00:51:59,109
things that are really nice for

00:51:55,359 --> 00:52:03,670
maintaining these files that Jason

00:51:59,109 --> 00:52:05,440
doesn't comments is one of them a little

00:52:03,670 --> 00:52:09,700
bit easier to work with the structure

00:52:05,440 --> 00:52:12,520
and the addition of type tags is very

00:52:09,700 --> 00:52:18,160
valuable so that's why we chose you yamo

00:52:12,520 --> 00:52:21,609
instead of just going with JSON JSON was

00:52:18,160 --> 00:52:21,940
designed for basically compiler to use

00:52:21,609 --> 00:52:23,890
it

00:52:21,940 --> 00:52:25,270
it wasn't intended to be used by humans

00:52:23,890 --> 00:52:27,339
it was interchange format it was

00:52:25,270 --> 00:52:29,410
literally output input over the web kind

00:52:27,339 --> 00:52:32,589
of thing Yama was designed as a human

00:52:29,410 --> 00:52:33,670
writable file as well so yeah backwards

00:52:32,589 --> 00:52:35,770
compatibility of course was always the

00:52:33,670 --> 00:52:38,160
thing so it's it's the right choice

00:52:35,770 --> 00:52:38,160
basically

00:52:40,970 --> 00:52:46,280
yeah one of the things as as a

00:52:44,750 --> 00:52:48,020
contributor and and we've seen it in

00:52:46,280 --> 00:52:49,940
many areas we see it in drivers with

00:52:48,020 --> 00:52:53,180
Union DT bindings and things like this

00:52:49,940 --> 00:52:55,160
where somebody will start doing this the

00:52:53,180 --> 00:52:57,410
first thing I do at least is I look at I

00:52:55,160 --> 00:52:59,150
try to look at what somebody else did i

00:52:57,410 --> 00:53:01,940
mimic that for whatever I'm looking at

00:52:59,150 --> 00:53:04,520
doing and when things are in flight like

00:53:01,940 --> 00:53:06,410
this it's pretty common that people pick

00:53:04,520 --> 00:53:08,119
the wrong example and implement it based

00:53:06,410 --> 00:53:10,099
on something that was good

00:53:08,119 --> 00:53:13,640
a while back but we have a good sort of

00:53:10,099 --> 00:53:16,359
golden standard now it would be a good

00:53:13,640 --> 00:53:18,410
opportunity to figure out how to

00:53:16,359 --> 00:53:19,760
communicate that a little better like

00:53:18,410 --> 00:53:22,160
hey you're coming here you're looking at

00:53:19,760 --> 00:53:24,349
at implementing something for your

00:53:22,160 --> 00:53:26,300
binding take a look at this binding

00:53:24,349 --> 00:53:28,099
instead of that finding because that

00:53:26,300 --> 00:53:32,020
binding is old we haven't updated yet

00:53:28,099 --> 00:53:34,790
it's not having a having a good sort of

00:53:32,020 --> 00:53:36,890
fresh real time way of discovering that

00:53:34,790 --> 00:53:38,930
would be useful before you ride the

00:53:36,890 --> 00:53:40,670
patch this came up before where we

00:53:38,930 --> 00:53:45,290
talked about maybe potentially embedding

00:53:40,670 --> 00:53:46,970
versioning into into the schema or into

00:53:45,290 --> 00:53:48,980
the bindings so that it would be

00:53:46,970 --> 00:53:50,750
something that could be checked is that

00:53:48,980 --> 00:53:57,740
something that you've looked at recently

00:53:50,750 --> 00:53:58,730
right well so the the the schema he says

00:53:57,740 --> 00:54:01,490
what metaschema

00:53:58,730 --> 00:54:04,490
you you're validating against so if we

00:54:01,490 --> 00:54:06,890
get to the point that we need a v2 we

00:54:04,490 --> 00:54:09,410
would just use the new meta schema and

00:54:06,890 --> 00:54:11,000
and we could yeah but that's the

00:54:09,410 --> 00:54:12,920
mechanics of it it's more like as a

00:54:11,000 --> 00:54:14,660
maintainer what do you prefer how do you

00:54:12,920 --> 00:54:18,710
prefer to look what's your preference

00:54:14,660 --> 00:54:22,609
right it's harder to enumerate and give

00:54:18,710 --> 00:54:25,960
that versions I'll get back to you after

00:54:22,609 --> 00:54:28,400
we've converted hundreds of bindings

00:54:25,960 --> 00:54:30,859
that's a I think we don't know yet right

00:54:28,400 --> 00:54:32,839
no no of course and and that's why it's

00:54:30,859 --> 00:54:34,670
important to communicate as you discover

00:54:32,839 --> 00:54:36,560
hey I really like this way of doing it

00:54:34,670 --> 00:54:38,810
if you're doing a new interrupt

00:54:36,560 --> 00:54:42,160
controller whatever think about it this

00:54:38,810 --> 00:54:42,160
way instead yeah

00:54:48,450 --> 00:54:55,830
okay so going back to how you do cross

00:54:51,030 --> 00:54:59,160
property dependencies this is what it

00:54:55,830 --> 00:55:00,510
would look like if and how you would

00:54:59,160 --> 00:55:06,680
have to do it and this would be the top

00:55:00,510 --> 00:55:09,870
level and it's using if-then-else

00:55:06,680 --> 00:55:13,440
schema which was introduced in draft 7

00:55:09,870 --> 00:55:16,020
which the Python JSON schema doesn't

00:55:13,440 --> 00:55:18,200
quite support yet but I think they're

00:55:16,020 --> 00:55:18,200
close

00:55:19,820 --> 00:55:28,040
so this says if you have if if and that

00:55:23,720 --> 00:55:30,570
schema is true that properties contains

00:55:28,040 --> 00:55:35,280
the property compatible contains a

00:55:30,570 --> 00:55:37,080
compatible string then apply the then

00:55:35,280 --> 00:55:42,800
schema else

00:55:37,080 --> 00:55:42,800
apply the else schema and

00:55:48,160 --> 00:55:53,470
so this there's a lot of cases in in

00:55:50,950 --> 00:55:56,080
bindings where where we have properties

00:55:53,470 --> 00:55:58,360
that are if it's this compatible we have

00:55:56,080 --> 00:56:01,560
three clocks and if it's the seller

00:55:58,360 --> 00:56:05,680
compatible we can only have two clocks

00:56:01,560 --> 00:56:11,620
so in those cases we may have to just

00:56:05,680 --> 00:56:14,050
split it out or or it the other way to

00:56:11,620 --> 00:56:18,310
do it is to use any of under the

00:56:14,050 --> 00:56:21,070
property but then either case would be

00:56:18,310 --> 00:56:24,690
true for either compatible so it's at

00:56:21,070 --> 00:56:26,920
least matching one of them but it's not

00:56:24,690 --> 00:56:30,480
validating that it matches the exact

00:56:26,920 --> 00:56:30,480
compatible to constraint is

00:56:34,510 --> 00:56:50,290
another ACPI question might allah so so

00:56:46,839 --> 00:56:53,500
is the if-then-else part of the schema

00:56:50,290 --> 00:56:56,650
actually embedded in the runtime version

00:56:53,500 --> 00:56:58,900
of the DTB is it just in the just in the

00:56:56,650 --> 00:57:02,349
system this would be a justin document

00:56:58,900 --> 00:57:08,800
okay and i'm not recommending that we do

00:57:02,349 --> 00:57:10,210
this no because then what if you have

00:57:08,800 --> 00:57:14,079
two conditions and you need to

00:57:10,210 --> 00:57:22,210
if-then-else you need a you need a all

00:57:14,079 --> 00:57:23,920
of above that and this is way into

00:57:22,210 --> 00:57:25,570
speculation territory but if we were

00:57:23,920 --> 00:57:27,339
looking to at some point do a runtime

00:57:25,570 --> 00:57:30,609
verifier when we load fragments and

00:57:27,339 --> 00:57:32,890
stuff like that it would sort of be need

00:57:30,609 --> 00:57:34,660
not to embed a yama parser in the kernel

00:57:32,890 --> 00:57:38,470
and then instead generate some code that

00:57:34,660 --> 00:57:39,790
will do it in C but I think we're far

00:57:38,470 --> 00:57:45,150
away from really worrying about that

00:57:39,790 --> 00:57:49,300
well you can do JSON schema and see I

00:57:45,150 --> 00:57:51,520
wouldn't recommend it because well it

00:57:49,300 --> 00:57:54,069
Maps well to Python because everything's

00:57:51,520 --> 00:57:55,630
a list or a dictionary yeah but at the

00:57:54,069 --> 00:57:57,430
point where we have the schema we might

00:57:55,630 --> 00:57:58,810
as well build a code in the kernel we

00:57:57,430 --> 00:58:00,880
don't need to keep the schema around

00:57:58,810 --> 00:58:03,010
once we can verify it there's also been

00:58:00,880 --> 00:58:05,410
talked 30 years about okay so you have

00:58:03,010 --> 00:58:07,210
the binding we should just be able to

00:58:05,410 --> 00:58:12,250
spit out a template for a driver out of

00:58:07,210 --> 00:58:14,710
this you know are probing peacing I'm a

00:58:12,250 --> 00:58:19,359
driver I'm gonna let someone else solve

00:58:14,710 --> 00:58:21,280
that one yeah was on that previous slide

00:58:19,359 --> 00:58:24,579
I was gonna say if we got like a list of

00:58:21,280 --> 00:58:26,170
say eight compatible strings and they

00:58:24,579 --> 00:58:28,060
each got their own specific property can

00:58:26,170 --> 00:58:30,069
that not be a dictionary in some form in

00:58:28,060 --> 00:58:32,460
that in a list or is that hard to

00:58:30,069 --> 00:58:32,460
Express

00:58:34,380 --> 00:58:43,060
that's why if we've got a list of eight

00:58:39,550 --> 00:58:48,520
compatibles for eight subs socks or

00:58:43,060 --> 00:58:50,650
whatever that's gonna grow horribly but

00:58:48,520 --> 00:58:55,800
what we actually what it needs is just a

00:58:50,650 --> 00:58:55,800
dictionary key mapping is that possible

00:58:58,140 --> 00:59:02,980
yeah so that this is not the only way to

00:59:00,610 --> 00:59:04,510
do these kind of tests this is this is

00:59:02,980 --> 00:59:05,770
an example of what the f F then else

00:59:04,510 --> 00:59:08,470
looks like in there's places where you

00:59:05,770 --> 00:59:10,960
might want to do that but if you have a

00:59:08,470 --> 00:59:15,250
large number of compatibles you would

00:59:10,960 --> 00:59:17,950
probably set up for this specific

00:59:15,250 --> 00:59:19,570
compatible here's the schema of that it

00:59:17,950 --> 00:59:21,850
contains all within F so the compatible

00:59:19,570 --> 00:59:23,500
contains a code the string and then

00:59:21,850 --> 00:59:25,270
right below that you'd have the other

00:59:23,500 --> 00:59:28,870
things that are characteristic on that

00:59:25,270 --> 00:59:29,440
particular version and then you can have

00:59:28,870 --> 00:59:32,200
a rollup

00:59:29,440 --> 00:59:35,140
of here's all the compatibles and the

00:59:32,200 --> 00:59:36,760
ones that it matches it'll do take all

00:59:35,140 --> 00:59:42,060
of them so you don't have to have this

00:59:36,760 --> 00:59:44,680
if-then-else structure in that case so

00:59:42,060 --> 00:59:46,900
for variations of what compatibles you

00:59:44,680 --> 00:59:50,770
can have it's what that's all within a

00:59:46,900 --> 00:59:54,990
property so that's easy to do and it's

00:59:50,770 --> 00:59:54,990
contained under properties compatible

00:59:59,550 --> 01:00:08,500
yeah and it does and the cases where it

01:00:04,030 --> 01:00:11,250
grows is where their platforms have two

01:00:08,500 --> 01:00:15,420
or three or four compatibles and

01:00:11,250 --> 01:00:17,710
different combinations of that and

01:00:15,420 --> 01:00:22,210
there's examples that i've converted

01:00:17,710 --> 01:00:25,480
already if i send this out guess about a

01:00:22,210 --> 01:00:27,250
month ago now the initial internal

01:00:25,480 --> 01:00:30,640
support and converting a bunch of word

01:00:27,250 --> 01:00:33,460
level findings so there's examples of

01:00:30,640 --> 01:00:36,280
that in there the the whole compatible

01:00:33,460 --> 01:00:38,230
handling is painful enough that it

01:00:36,280 --> 01:00:41,200
probably makes sense defining our own

01:00:38,230 --> 01:00:44,320
keyword for dealing with the

01:00:41,200 --> 01:00:46,240
combinations of okay what order can

01:00:44,320 --> 01:00:49,119
compatible values be in

01:00:46,240 --> 01:00:51,670
and are you is it is it strictly doing

01:00:49,119 --> 01:00:55,000
that right because without some of the

01:00:51,670 --> 01:01:00,760
prototype steps you put together we're

01:00:55,000 --> 01:01:02,260
just painful well yeah so right to be

01:01:00,760 --> 01:01:03,970
able to have a list to say it must

01:01:02,260 --> 01:01:06,400
contain these ones but it must also be

01:01:03,970 --> 01:01:09,700
in in the right order which JSON schema

01:01:06,400 --> 01:01:12,490
doesn't currently it does handle that

01:01:09,700 --> 01:01:16,330
now okay so I thought we had problems

01:01:12,490 --> 01:01:19,210
with questions if there's something the

01:01:16,330 --> 01:01:22,600
items new word can either be a schema or

01:01:19,210 --> 01:01:27,640
a list if it's a schema it applies to

01:01:22,600 --> 01:01:33,580
all the items and like if you do a new

01:01:27,640 --> 01:01:35,500
as a schema all those items you can just

01:01:33,580 --> 01:01:37,180
have to match any of the item yeah but I

01:01:35,500 --> 01:01:39,270
thought we had the problem though

01:01:37,180 --> 01:01:45,130
there's the problem of if you have

01:01:39,270 --> 01:01:49,240
something that is extending that binding

01:01:45,130 --> 01:01:50,560
so you guys so an NS 16 550 binding if

01:01:49,240 --> 01:01:52,810
you were to have another binding that

01:01:50,560 --> 01:01:56,410
was compatible that 6550 and you had

01:01:52,810 --> 01:01:57,940
done that in the NS 16 550 that would no

01:01:56,410 --> 01:01:59,320
longer work that would no longer match

01:01:57,940 --> 01:02:01,450
because you've got additional stuff in

01:01:59,320 --> 01:02:07,630
there and the list items don't line up

01:02:01,450 --> 01:02:11,170
anymore it sounds like an offline

01:02:07,630 --> 01:02:15,460
question I think we're fine there cuz I

01:02:11,170 --> 01:02:18,550
think we just the constraint there would

01:02:15,460 --> 01:02:22,660
be that you just have it contains 416

01:02:18,550 --> 01:02:29,290
550 and 16 550 binding and then in your

01:02:22,660 --> 01:02:34,080
more specific case you say it's it's ti

01:02:29,290 --> 01:02:34,080
you art and then it's a 16 550

01:02:38,780 --> 01:02:50,090
so how do you run all this so you can

01:02:45,590 --> 01:02:52,970
install from tip as I mentioned the

01:02:50,090 --> 01:02:54,680
kernel T of DTC also has the it's been

01:02:52,970 --> 01:02:57,620
updated with the animal support you just

01:02:54,680 --> 01:03:00,290
need lib yeah mo and then the headers

01:02:57,620 --> 01:03:05,960
for it too for that to get turned on

01:03:00,290 --> 01:03:10,880
when it builds make all mod config will

01:03:05,960 --> 01:03:13,490
turn on building all DTS files and then

01:03:10,880 --> 01:03:18,020
make binding check or you can skip that

01:03:13,490 --> 01:03:19,520
and this run make DT beasts check and

01:03:18,020 --> 01:03:22,130
since it does produce so many warnings

01:03:19,520 --> 01:03:27,800
I've worked on being able to split what

01:03:22,130 --> 01:03:30,740
schema you run and so you can run only

01:03:27,800 --> 01:03:37,010
core schema only kernel schema only a

01:03:30,740 --> 01:03:41,420
specific user specified schema that

01:03:37,010 --> 01:03:43,750
makes it easier to sort out errors one

01:03:41,420 --> 01:03:43,750
by one

01:03:51,440 --> 01:03:59,690
so kind of next step please go review

01:03:55,579 --> 01:04:04,849
the my patch series and I'm gonna send

01:03:59,690 --> 01:04:08,510
out another version hopefully soon I'd

01:04:04,849 --> 01:04:13,930
like to add this to build support at

01:04:08,510 --> 01:04:17,089
least and 421 it's all of about 70 lines

01:04:13,930 --> 01:04:22,250
and it's outside of the normal build

01:04:17,089 --> 01:04:27,740
flow I've converted some bindings not a

01:04:22,250 --> 01:04:29,990
whole lot of feedback on them mostly

01:04:27,740 --> 01:04:35,900
people complaining I'd drop some

01:04:29,990 --> 01:04:39,500
comments and there's not yet a

01:04:35,900 --> 01:04:45,230
requirement to submit bindings in JSON

01:04:39,500 --> 01:04:54,200
schema and there's already thousands of

01:04:45,230 --> 01:04:57,200
warnings generated the problem the

01:04:54,200 --> 01:05:03,710
problem is also faces in DTC is kind of

01:04:57,200 --> 01:05:08,720
how you build DT B's is you know you

01:05:03,710 --> 01:05:11,150
include a base DTS base SOC DTS I file

01:05:08,720 --> 01:05:14,089
and that file probably has the warning

01:05:11,150 --> 01:05:17,900
in it or the source of the warning and

01:05:14,089 --> 01:05:24,440
then you include that in say 10 board

01:05:17,900 --> 01:05:30,109
files but the error output prints out

01:05:24,440 --> 01:05:33,079
the dtb name or in this case the DTE ml

01:05:30,109 --> 01:05:35,839
name so you have to trace it back into

01:05:33,079 --> 01:05:39,440
the where the source file is this is

01:05:35,839 --> 01:05:42,230
soon gonna be fixed in dtc but it the

01:05:39,440 --> 01:05:44,589
result is it generates lots of duplicate

01:05:42,230 --> 01:05:44,589
warnings

01:05:46,450 --> 01:05:55,220
so one thing I was singing there is we

01:05:48,770 --> 01:05:59,210
need a build of option to dis build SOC

01:05:55,220 --> 01:06:03,140
DTS files without the top-level board

01:05:59,210 --> 01:06:05,060
all all the top-level board ones so we

01:06:03,140 --> 01:06:08,990
can kind of reduce the number of

01:06:05,060 --> 01:06:12,980
warnings okay once you're ready to

01:06:08,990 --> 01:06:14,930
actually start the conversion have you

01:06:12,980 --> 01:06:16,790
started in terms of actually this is got

01:06:14,930 --> 01:06:18,800
to be a divide and conquer type of story

01:06:16,790 --> 01:06:21,170
here so have you been putting some

01:06:18,800 --> 01:06:24,380
thought into putting some orientation

01:06:21,170 --> 01:06:26,270
information and how to's in place so

01:06:24,380 --> 01:06:28,370
that you can then push that to people

01:06:26,270 --> 01:06:30,080
who own the files that have to be

01:06:28,370 --> 01:06:35,960
converted and then try to get them

01:06:30,080 --> 01:06:37,760
engaged effectively I'm guessing a lot

01:06:35,960 --> 01:06:40,010
of the bindings are somewhat abandoned

01:06:37,760 --> 01:06:42,290
that's probably the case but I think

01:06:40,010 --> 01:06:43,850
asking the people who've put them in the

01:06:42,290 --> 01:06:46,340
first place as a first step

01:06:43,850 --> 01:06:47,690
seems to me to be a logical place and we

01:06:46,340 --> 01:06:51,020
can get that information pretty easily

01:06:47,690 --> 01:06:53,420
by mining get now these days my plan of

01:06:51,020 --> 01:06:59,230
what I'll work on is more of the core

01:06:53,420 --> 01:07:03,020
side of the bindings GPIO and right I'm

01:06:59,230 --> 01:07:07,930
shifting just a how to write the schema

01:07:03,020 --> 01:07:07,930
doc in the series right

01:07:09,700 --> 01:07:14,380
I could say I'm just you know so this

01:07:12,640 --> 01:07:16,000
doesn't just be another falter like

01:07:14,380 --> 01:07:18,100
effort partially and then another thing

01:07:16,000 --> 01:07:19,660
subsequent sit as we've been going

01:07:18,100 --> 01:07:22,840
through can we come up with an actual

01:07:19,660 --> 01:07:24,280
transition plan and then evangelize it

01:07:22,840 --> 01:07:29,110
and make sure that the right material is

01:07:24,280 --> 01:07:32,440
there that's what I asked I'm hopeful

01:07:29,110 --> 01:07:34,390
that it's the metaschema restrict stuff

01:07:32,440 --> 01:07:37,630
enough and it's distilled down enough

01:07:34,390 --> 01:07:40,210
that it's not a huge learning curve to

01:07:37,630 --> 01:07:46,660
learn json schema but that is one of my

01:07:40,210 --> 01:07:49,600
concerns and i just need people to start

01:07:46,660 --> 01:07:55,780
trying it and get feedback to how we can

01:07:49,600 --> 01:07:57,220
document it better and such once we

01:07:55,780 --> 01:08:00,580
convert everything it's gonna be slow so

01:07:57,220 --> 01:08:04,780
we'll have to worry about that when we

01:08:00,580 --> 01:08:08,230
get there I guess but it's you're

01:08:04,780 --> 01:08:10,540
iterating over each node of each DT and

01:08:08,230 --> 01:08:14,020
deciding which schema to apply so I

01:08:10,540 --> 01:08:15,910
don't not sure how you go faster how do

01:08:14,020 --> 01:08:18,190
we sneak it in so that Linda's doesn't

01:08:15,910 --> 01:08:22,630
think there's any churn happening how do

01:08:18,190 --> 01:08:24,550
we camouflage it it's all under

01:08:22,630 --> 01:08:27,120
documentation and he doesn't care I

01:08:24,550 --> 01:08:27,120
don't know

01:08:34,329 --> 01:08:39,250
so kind of open questions that I have

01:08:37,150 --> 01:08:42,880
what to do with the animal bindings

01:08:39,250 --> 01:08:44,440
project I think the options are keep it

01:08:42,880 --> 01:08:47,230
separate

01:08:44,440 --> 01:08:52,179
I know grants in favor of integrating to

01:08:47,230 --> 01:08:57,819
DTC or integrate a subset of it into the

01:08:52,179 --> 01:09:00,279
kernel directly I'm tending to leaning

01:08:57,819 --> 01:09:07,989
toward keeping it separate for now so it

01:09:00,279 --> 01:09:10,449
can be iterated on more quickly I go

01:09:07,989 --> 01:09:13,199
back and forth kind of on the model for

01:09:10,449 --> 01:09:17,619
to make targets whether we should have

01:09:13,199 --> 01:09:20,559
separate targets like I do now or do

01:09:17,619 --> 01:09:26,589
something more like when you build

01:09:20,559 --> 01:09:32,079
sparse not sure so any input there would

01:09:26,589 --> 01:09:36,690
be useful another question that's come

01:09:32,079 --> 01:09:39,699
up is how to define class of devices I

01:09:36,690 --> 01:09:42,489
had a couple options I've basically

01:09:39,699 --> 01:09:45,099
decided that this is the only good

01:09:42,489 --> 01:09:50,199
option the others were like using path

01:09:45,099 --> 01:09:52,690
or coming up with some list of keywords

01:09:50,199 --> 01:09:56,320
that then get mapped back to a schema

01:09:52,690 --> 01:09:58,719
doc but I think the easiest most

01:09:56,320 --> 01:10:04,179
flexible is at top level you can have an

01:09:58,719 --> 01:10:06,219
all of key and just include what of what

01:10:04,179 --> 01:10:08,639
whatever other schema you want to

01:10:06,219 --> 01:10:08,639
include

01:10:11,139 --> 01:10:19,239
and I don't think we need this son all

01:10:16,389 --> 01:10:22,840
the common bindings like GPIO and clocks

01:10:19,239 --> 01:10:28,060
I think that that RA gets covered and

01:10:22,840 --> 01:10:30,250
applied without doing this and another

01:10:28,060 --> 01:10:32,770
question is licensing so all these

01:10:30,250 --> 01:10:35,580
binding Doc's we have have no license so

01:10:32,770 --> 01:10:35,580
they're GPL too

01:10:36,150 --> 01:10:40,440
what do we do at that if anything

01:10:40,560 --> 01:10:45,659
personally I'd like to be able to do a

01:10:42,699 --> 01:10:54,310
license them but I also don't want to go

01:10:45,659 --> 01:10:55,810
get permission on everyone can we

01:10:54,310 --> 01:10:57,310
basically as part of figuring out the

01:10:55,810 --> 01:10:58,630
transition plan can we figure out the

01:10:57,310 --> 01:10:59,650
licensing and get the same things

01:10:58,630 --> 01:11:02,110
happening at the same time

01:10:59,650 --> 01:11:03,520
and then anyone who doesn't want to deal

01:11:02,110 --> 01:11:04,690
with something we just drop it and make

01:11:03,520 --> 01:11:07,469
someone feel some pain

01:11:04,690 --> 01:11:07,469
and fix it then

01:11:11,150 --> 01:11:15,269
definitely I mean if we're talking about

01:11:12,960 --> 01:11:16,710
embedding verifiers in the kernel we

01:11:15,269 --> 01:11:20,010
want to allow others to do it without

01:11:16,710 --> 01:11:23,960
obtaining yeah dual license is gonna be

01:11:20,010 --> 01:11:23,960
really important here I think so

01:11:34,789 --> 01:11:42,960
the question was which I am I leaning

01:11:37,139 --> 01:11:47,880
for licensing I think it was to leave it

01:11:42,960 --> 01:11:52,889
as GPL for now but the ammo bindings

01:11:47,880 --> 01:11:55,860
part is is BSD to clause we can easily

01:11:52,889 --> 01:12:00,289
change that because it's armed and

01:11:55,860 --> 01:12:00,289
Lennar oh it's copyright apparently I

01:12:01,159 --> 01:12:05,369
don't think we're too worried about

01:12:03,510 --> 01:12:08,519
people working and making proprietary

01:12:05,369 --> 01:12:12,590
versions of any of this so whatever gets

01:12:08,519 --> 01:12:12,590
most people to the table I'm open for it

01:12:13,579 --> 01:12:21,269
in some cases I've instead of converting

01:12:18,380 --> 01:12:26,610
some common bindings entry I've done

01:12:21,269 --> 01:12:28,469
them moved them into the demo projects

01:12:26,610 --> 01:12:36,300
and I've gotten permission to relicense

01:12:28,469 --> 01:12:38,659
those but that's like two files I think

01:12:36,300 --> 01:12:38,659
that's it

01:12:39,950 --> 01:12:51,730
there's links to the schema and tools

01:12:43,880 --> 01:12:51,730
repo and the colonel branch DT schema a

01:12:52,750 --> 01:12:56,140
more time for questions

01:13:01,820 --> 01:13:11,239
Thanks

01:13:03,830 --> 01:13:11,239
[Applause]

01:13:49,360 --> 01:13:53,140
I just like to remind everyone that if

01:13:51,730 --> 01:13:57,600
you're not adding those two etherpad

01:13:53,140 --> 01:14:00,940
here's the URL feel free to contribute

01:13:57,600 --> 01:14:01,930
these notes will be valuable six months

01:14:00,940 --> 01:14:06,600
from now when we're trying to remember

01:14:01,930 --> 01:14:06,600
what the heck we talked about this week

01:14:07,410 --> 01:14:12,970
does anybody grabbing the URL or try get

01:14:10,480 --> 01:14:20,830
rid of the slide now anyone would want

01:14:12,970 --> 01:14:23,560
it to hold up okay site is gone the next

01:14:20,830 --> 01:14:28,470
session is a joint one between Simon

01:14:23,560 --> 01:14:31,240
glass and myself I'm gonna be talking a

01:14:28,470 --> 01:14:36,280
bit about what's happened in the kernel

01:14:31,240 --> 01:14:41,350
in terms of size of device trees

01:14:36,280 --> 01:14:45,270
Simon's focusing more on you booed

01:14:41,350 --> 01:14:45,270
and/or flattened device tree

01:14:50,099 --> 01:14:57,810
so we'll start with my slides and I'm

01:14:55,800 --> 01:15:00,300
going to try to jump through a lot of my

01:14:57,810 --> 01:15:03,690
slides they'll be there for reference

01:15:00,300 --> 01:15:06,179
but if I actually talked them through I

01:15:03,690 --> 01:15:08,630
would actually spend a lot of time

01:15:06,179 --> 01:15:11,630
talking myself instead of you guys

01:15:08,630 --> 01:15:11,630
talking

01:15:15,989 --> 01:15:24,550
okay funny games yeah they're never just

01:15:22,380 --> 01:15:26,939
have to get in the right workspace and

01:15:24,550 --> 01:15:26,939
I'll be fine

01:15:30,630 --> 01:15:36,059
nothing like a sliding Mouse jumping you

01:15:45,570 --> 01:15:50,210
Area C put mouse

01:15:54,510 --> 01:15:58,949
so start with some work that Rob did

01:15:56,760 --> 01:16:01,289
this is just a reference of where to

01:15:58,949 --> 01:16:03,869
find some of his patches he is focusing

01:16:01,289 --> 01:16:06,499
on reducing the size of the device tree

01:16:03,869 --> 01:16:10,050
data structures in the kernel

01:16:06,499 --> 01:16:14,429
specifically property structures and

01:16:10,050 --> 01:16:17,579
node structures one thing that's

01:16:14,429 --> 01:16:20,429
important to notice is that if config

01:16:17,579 --> 01:16:23,039
dynamic is selected then the size

01:16:20,429 --> 01:16:25,379
reductions do not take place if you're

01:16:23,039 --> 01:16:27,539
doing overlays config dynamic is

01:16:25,379 --> 01:16:33,539
selected so overlays do not gain the

01:16:27,539 --> 01:16:36,629
benefit of these size reductions so once

01:16:33,539 --> 01:16:39,929
he put these patches in place Nicolas

01:16:36,629 --> 01:16:42,419
Peter did some he's doing some attempts

01:16:39,929 --> 01:16:44,639
to tie in a fight tiny a fight the

01:16:42,419 --> 01:16:46,409
kernel feel free to jump in on this Rob

01:16:44,639 --> 01:16:49,979
at any point cuz I'm talking about your

01:16:46,409 --> 01:16:51,780
stuff so Nicolas reported some results

01:16:49,979 --> 01:16:55,530
and he had a test system where he went

01:16:51,780 --> 01:16:58,349
from 120 thousand bytes down to just

01:16:55,530 --> 01:17:00,090
over 20,000 bytes that's a significant

01:16:58,349 --> 01:17:02,669
size reduction for memory constrained

01:17:00,090 --> 01:17:07,590
system and he's talking in very very

01:17:02,669 --> 01:17:09,239
constrained systems there's a second

01:17:07,590 --> 01:17:11,999
feature in the device tree compiler

01:17:09,239 --> 01:17:14,999
that's out there now you can add a

01:17:11,999 --> 01:17:17,639
notation in your source that tells the

01:17:14,999 --> 01:17:19,590
compiler if this node is not referenced

01:17:17,639 --> 01:17:21,809
by any other node it's ap handle

01:17:19,590 --> 01:17:25,050
reference omit this node from the

01:17:21,809 --> 01:17:26,909
resulting compiled device tree and then

01:17:25,050 --> 01:17:29,849
there's an interesting example just for

01:17:26,909 --> 01:17:33,559
reference and then Rob added another

01:17:29,849 --> 01:17:38,189
feature to shrink the size of the node

01:17:33,559 --> 01:17:42,030
data structure by removing the path from

01:17:38,189 --> 01:17:44,249
the full name but now if you want to

01:17:42,030 --> 01:17:47,099
access that information use percent p

01:17:44,249 --> 01:17:49,050
of' typically this is used in error in

01:17:47,099 --> 01:17:51,479
warning messages so if you're creating

01:17:49,050 --> 01:17:53,369
new messages this is what you want to

01:17:51,479 --> 01:17:55,559
use you don't want to use no node full

01:17:53,369 --> 01:18:02,579
name so Nikolas added these two next

01:17:55,559 --> 01:18:05,969
features and he got down to just under

01:18:02,579 --> 01:18:07,090
12,000 bytes to went from roughly 22,000

01:18:05,969 --> 01:18:09,730
down to 12

01:18:07,090 --> 01:18:12,610
with this next step so an incredible

01:18:09,730 --> 01:18:17,170
reduction from Rob's memory sizing stuff

01:18:12,610 --> 01:18:21,400
on the other hand we've increased memory

01:18:17,170 --> 01:18:24,969
use in a few fashions one is making

01:18:21,400 --> 01:18:29,170
nodes K objects and and that's a lot to

01:18:24,969 --> 01:18:31,320
do with tracking and freeing memory and

01:18:29,170 --> 01:18:33,760
then ends up using a lot of space

01:18:31,320 --> 01:18:36,239
unfortunately yeah Rob you know that was

01:18:33,760 --> 01:18:39,750
the main thing that got that rid

01:18:36,239 --> 01:18:42,210
reduction was making that optional again

01:18:39,750 --> 01:18:46,570
right because that's just used for

01:18:42,210 --> 01:18:50,250
sisyphus representation which is linked

01:18:46,570 --> 01:18:53,199
to or proc devote device tree links -

01:18:50,250 --> 01:18:55,360
right right this FS is the other half of

01:18:53,199 --> 01:18:59,889
what you gain from K objects which is

01:18:55,360 --> 01:19:03,639
really nice so that would be if you're

01:18:59,889 --> 01:19:05,530
used to slash proc / device tree showing

01:19:03,639 --> 01:19:08,050
the representation of what the device

01:19:05,530 --> 01:19:11,920
tree contains that's what's now in sis

01:19:08,050 --> 01:19:13,300
FST's it's now a link in just this FS so

01:19:11,920 --> 01:19:16,119
if you want that again you're not going

01:19:13,300 --> 01:19:17,619
to get the size direction so it's useful

01:19:16,119 --> 01:19:20,290
and constrained systems but you lose

01:19:17,619 --> 01:19:25,389
some features use overlays you lose proc

01:19:20,290 --> 01:19:27,699
device tree P handle cache we added a

01:19:25,389 --> 01:19:29,860
cache some people were complaining about

01:19:27,699 --> 01:19:32,080
the performance overhead of accessing

01:19:29,860 --> 01:19:32,590
large numbers of P Andals in doing the

01:19:32,080 --> 01:19:35,020
lookups

01:19:32,590 --> 01:19:36,580
and so we added in the feature they're

01:19:35,020 --> 01:19:38,800
actually been several requests for this

01:19:36,580 --> 01:19:40,540
and finally we said okay we've had

01:19:38,800 --> 01:19:42,460
enough requests for this it really is a

01:19:40,540 --> 01:19:45,909
demonstrated need but that adds some

01:19:42,460 --> 01:19:47,409
more space and it's not too bad if you

01:19:45,909 --> 01:19:49,300
don't have too many P Andals it's based

01:19:47,409 --> 01:19:51,550
on how many gain handles exist in the

01:19:49,300 --> 01:19:53,909
tree and there's the formula Prowler

01:19:51,550 --> 01:19:53,909
Judas

01:19:54,960 --> 01:19:59,080
I'm not gonna talk about this slide

01:19:57,190 --> 01:20:00,790
unless we have time left over we can

01:19:59,080 --> 01:20:03,100
bring it up in QA but there are other

01:20:00,790 --> 01:20:06,730
opportunities thinking forward we can

01:20:03,100 --> 01:20:09,970
try and shrink size one big area that

01:20:06,730 --> 01:20:12,280
I'm concerned about is when overlays are

01:20:09,970 --> 01:20:14,650
used in the kernel the base device tree

01:20:12,280 --> 01:20:16,900
has to have symbolic information that's

01:20:14,650 --> 01:20:18,610
used when you load the overlay and it

01:20:16,900 --> 01:20:21,250
turns out that that adds a lot of size

01:20:18,610 --> 01:20:26,770
to the the flattened device tree and to

01:20:21,250 --> 01:20:29,050
the in kernel memory usage so I did a

01:20:26,770 --> 01:20:31,210
bit of prototyping to shrink that that

01:20:29,050 --> 01:20:34,090
memory size and I have second motivation

01:20:31,210 --> 01:20:36,640
I really don't like that the meta data

01:20:34,090 --> 01:20:38,980
is sitting in the namespace that all the

01:20:36,640 --> 01:20:41,050
other nodes and properties are in that

01:20:38,980 --> 01:20:45,010
metadata it just looks like it's a node

01:20:41,050 --> 01:20:50,950
or a set of notes which they're issues

01:20:45,010 --> 01:20:52,960
with that the side effect is we need a

01:20:50,950 --> 01:20:55,300
new flattened device tree format if I

01:20:52,960 --> 01:20:56,890
make these changes just looking at this

01:20:55,300 --> 01:21:02,650
is a really busy slide just looking at

01:20:56,890 --> 01:21:05,550
this top box this is the worst device

01:21:02,650 --> 01:21:08,920
tree in the Linux kernel in the arm

01:21:05,550 --> 01:21:12,880
subtree right now in terms of added

01:21:08,920 --> 01:21:15,940
overhead for that base device tree for

01:21:12,880 --> 01:21:18,820
the symbols so currently if you compile

01:21:15,940 --> 01:21:22,300
with symbols you go from ninety thousand

01:21:18,820 --> 01:21:26,050
bytes you add 42,000 more bytes just for

01:21:22,300 --> 01:21:28,990
the symbols my prototyping I got it down

01:21:26,050 --> 01:21:31,120
to only fifteen thousand eight sixteen

01:21:28,990 --> 01:21:33,250
thousand digital bytes so saving almost

01:21:31,120 --> 01:21:34,840
twenty seven thousand bytes so there's

01:21:33,250 --> 01:21:36,730
significant potential to go to a

01:21:34,840 --> 01:21:39,220
different format and reduce the overhead

01:21:36,730 --> 01:21:43,090
of these symbols and this is just a

01:21:39,220 --> 01:21:46,000
graph I looked at every single device

01:21:43,090 --> 01:21:48,220
tree in the arm subtree so every point

01:21:46,000 --> 01:21:51,370
on the horizontal access is one of the

01:21:48,220 --> 01:21:53,920
device resources compiled what is the

01:21:51,370 --> 01:21:55,600
the two lines are one is what is the

01:21:53,920 --> 01:21:57,910
overhead with the current methodology

01:21:55,600 --> 01:22:01,930
that's the top green line the bottom

01:21:57,910 --> 01:22:03,420
line is my prototype reduced size how

01:22:01,930 --> 01:22:06,460
much memory is used for the extra

01:22:03,420 --> 01:22:08,440
symbols metadata and you can see there's

01:22:06,460 --> 01:22:13,000
really not too big a problem in

01:22:08,440 --> 01:22:15,310
to get out to about 800 plus device

01:22:13,000 --> 01:22:17,680
trees so that they're about 800 device

01:22:15,310 --> 01:22:21,250
trees where the symbols are not a huge

01:22:17,680 --> 01:22:23,890
overhead they're only up to say 1500

01:22:21,250 --> 01:22:25,840
bytes 2,000 bytes which isn't horrendous

01:22:23,890 --> 01:22:27,969
unless you're really really constrained

01:22:25,840 --> 01:22:31,750
but all of a sudden that last hundred

01:22:27,969 --> 01:22:34,570
150 it mushrooms so there are a handful

01:22:31,750 --> 01:22:37,750
of device trees that are really

01:22:34,570 --> 01:22:40,360
problematic such that I'm not willing to

01:22:37,750 --> 01:22:42,840
just turn on symbol information for all

01:22:40,360 --> 01:22:45,850
compiles of all device trees blindly

01:22:42,840 --> 01:22:47,620
because there are other problem ones and

01:22:45,850 --> 01:22:56,800
we just don't want to incur that

01:22:47,620 --> 01:23:00,180
overhead yeah of those ones on the graph

01:22:56,800 --> 01:23:03,520
there are the architectures that are

01:23:00,180 --> 01:23:08,230
very constrained the ones that have that

01:23:03,520 --> 01:23:10,270
robot I would assume not because if

01:23:08,230 --> 01:23:13,150
they're constrained they don't likely

01:23:10,270 --> 01:23:14,620
have many devices yeah I also wonder to

01:23:13,150 --> 01:23:15,910
what extent some of that blows coming

01:23:14,620 --> 01:23:20,110
from ones that are not maintained

01:23:15,910 --> 01:23:23,410
anymore right I don't know I in my email

01:23:20,110 --> 01:23:25,930
thread I actually sent out a list by

01:23:23,410 --> 01:23:28,540
device tree what the sizes were so

01:23:25,930 --> 01:23:31,260
that's out there on the mail list if you

01:23:28,540 --> 01:23:33,910
want to look at specific device trees

01:23:31,260 --> 01:23:35,980
and this was just a prototype in actual

01:23:33,910 --> 01:23:38,739
implementation depending on how we end

01:23:35,980 --> 01:23:40,270
up will have different numbers but this

01:23:38,739 --> 01:23:44,190
gives a really good sense I think of

01:23:40,270 --> 01:23:44,190
what is achievable and what's reasonable

01:23:45,480 --> 01:23:54,460
just some more stuff ok questions I'm

01:23:53,110 --> 01:23:58,500
trying to be really brief on this and

01:23:54,460 --> 01:24:02,100
not spend too much time no questions if

01:23:58,500 --> 01:24:02,100
Simon if you want to come up

01:24:04,909 --> 01:24:09,469
are ya

01:24:12,980 --> 01:24:18,220
I mean if we're talking about a new

01:24:15,530 --> 01:24:20,210
device tree format and it's come up

01:24:18,220 --> 01:24:23,420
occasionally over the last number of

01:24:20,210 --> 01:24:26,750
years the encoding as it is right now is

01:24:23,420 --> 01:24:29,060
really naive and so there's a lot of

01:24:26,750 --> 01:24:33,170
wasted space already so if we're looking

01:24:29,060 --> 01:24:35,270
at a new device tree binary format it

01:24:33,170 --> 01:24:36,650
can really reduce the size of there's

01:24:35,270 --> 01:24:56,960
other places we can reduce the size as

01:24:36,650 --> 01:24:59,770
well I don't think Frank's listening we

01:24:56,960 --> 01:24:59,770
said fire Frank

01:25:16,190 --> 01:25:21,510
I'm sorry what was the question

01:25:18,270 --> 01:25:24,360
I got distracted

01:25:21,510 --> 01:25:26,310
I had just commented that there's a lot

01:25:24,360 --> 01:25:29,190
of other opportunities for reducing the

01:25:26,310 --> 01:25:31,410
size of the DTB files but then I saw the

01:25:29,190 --> 01:25:34,050
title of Simon's slide so I want to see

01:25:31,410 --> 01:25:36,570
what this is yeah yeah and he actually

01:25:34,050 --> 01:25:39,840
has some some interesting ideas and when

01:25:36,570 --> 01:25:42,690
we get to the DT B format session later

01:25:39,840 --> 01:25:51,480
in the track will be talking also in in

01:25:42,690 --> 01:25:54,510
more detail hi so I'm just gonna talk

01:25:51,480 --> 01:25:56,550
about a I mean if we do change the

01:25:54,510 --> 01:25:58,530
format we will want to do it once and

01:25:56,550 --> 01:26:00,510
get everything done at once right

01:25:58,530 --> 01:26:04,410
because it's a huge job I'm not too sure

01:26:00,510 --> 01:26:05,760
if it's feasible but I just basically

01:26:04,410 --> 01:26:09,390
wanted to throw out some ideas about

01:26:05,760 --> 01:26:11,130
things we could do based on things my

01:26:09,390 --> 01:26:17,600
experience with it and some of the pain

01:26:11,130 --> 01:26:17,600
that I've had so here's my wish list

01:26:22,740 --> 01:26:29,200
so is that ambitious enough I figured

01:26:26,980 --> 01:26:31,450
there's more things that could go on it

01:26:29,200 --> 01:26:33,120
and some of these are easy and some of

01:26:31,450 --> 01:26:41,380
them are hard

01:26:33,120 --> 01:26:43,420
that's a pointer or not cool okay some

01:26:41,380 --> 01:26:46,300
of some of these you may not have seen

01:26:43,420 --> 01:26:48,190
this is the ability to pull the stuff

01:26:46,300 --> 01:26:49,300
out of another node into this current

01:26:48,190 --> 01:26:55,060
one I think yam would have something

01:26:49,300 --> 01:26:57,310
similar to that this is being able to

01:26:55,060 --> 01:26:59,800
reference data outside the DT because

01:26:57,310 --> 01:27:01,920
for example the FET format if you're

01:26:59,800 --> 01:27:04,300
familiar with that that you boot users

01:27:01,920 --> 01:27:05,680
you end up with this massive device tree

01:27:04,300 --> 01:27:07,750
you really want the metadata at the

01:27:05,680 --> 01:27:10,030
front and the files outside somewhere

01:27:07,750 --> 01:27:12,600
else it's actually implemented a new

01:27:10,030 --> 01:27:15,160
boot but we could put it in the system

01:27:12,600 --> 01:27:19,480
this would be cool for speed I don't

01:27:15,160 --> 01:27:21,070
know anyway that's my list so I think be

01:27:19,480 --> 01:27:22,570
good to keep the basic structure and

01:27:21,070 --> 01:27:24,970
make it efficient to directly walk

01:27:22,570 --> 01:27:26,710
through so we don't have to we won't

01:27:24,970 --> 01:27:29,710
have to go to having to use a live tree

01:27:26,710 --> 01:27:32,340
to do anything with it and ideally not

01:27:29,710 --> 01:27:34,900
too much coqui per tools the same and

01:27:32,340 --> 01:27:38,110
can we just take a couple of files and

01:27:34,900 --> 01:27:40,420
maybe get somewhere so this is what I

01:27:38,110 --> 01:27:42,490
came out with just tell me when to stop

01:27:40,420 --> 01:27:48,820
we can continue after the break or

01:27:42,490 --> 01:27:50,470
whatever so yeah okay yeah if I if I

01:27:48,820 --> 01:27:54,250
probably probably ran out of slides by

01:27:50,470 --> 01:27:55,900
then I'll try and be quick so yeah the

01:27:54,250 --> 01:27:57,940
the take cells are wasteful because

01:27:55,900 --> 01:28:00,670
they're 32 bits and we only have only

01:27:57,940 --> 01:28:02,500
really use a few of those bits so I

01:28:00,670 --> 01:28:05,710
thought well maybe we can reuse them for

01:28:02,500 --> 01:28:09,840
something else so what I came up with

01:28:05,710 --> 01:28:12,220
was two types of tags basically a

01:28:09,840 --> 01:28:16,060
property one and then one for everything

01:28:12,220 --> 01:28:19,780
else the property ones were all the

01:28:16,060 --> 01:28:22,180
action is but we subdivide them that way

01:28:19,780 --> 01:28:25,120
in order to get the maximum number of

01:28:22,180 --> 01:28:27,490
bits and then try to include everything

01:28:25,120 --> 01:28:29,680
in that single cell all the metadata

01:28:27,490 --> 01:28:32,570
that we have at the moment so you think

01:28:29,680 --> 01:28:37,550
about the prop struct it

01:28:32,570 --> 01:28:41,300
got a tag it's got a name pointer her

01:28:37,550 --> 01:28:43,250
name integer it's got a length and in

01:28:41,300 --> 01:28:47,989
the data starts so try and get those

01:28:43,250 --> 01:28:49,550
three cells down to one I thought this

01:28:47,989 --> 01:28:52,850
will be nice get rid of the compatible

01:28:49,550 --> 01:28:54,140
strings they're really slow and big are

01:28:52,850 --> 01:28:56,450
they and then leave everything else

01:28:54,140 --> 01:28:59,630
alone in other words this only affects

01:28:56,450 --> 01:29:02,390
the struct portion of the device tree so

01:28:59,630 --> 01:29:03,890
this is just I thought well this is all

01:29:02,390 --> 01:29:07,130
very well to talk about this but in this

01:29:03,890 --> 01:29:08,870
that's a bit more real there's you know

01:29:07,130 --> 01:29:10,219
it's all but pie in the sky so I

01:29:08,870 --> 01:29:13,239
actually tried to come up with what that

01:29:10,219 --> 01:29:16,969
format might be this is this is just

01:29:13,239 --> 01:29:18,530
some ideas this is the bit that tells

01:29:16,969 --> 01:29:23,180
you whether it's a property or not and

01:29:18,530 --> 01:29:26,060
then we've got a type here we've got

01:29:23,180 --> 01:29:27,410
scalars and lists so we just support so

01:29:26,060 --> 01:29:32,000
we can tell whether it's a list or not

01:29:27,410 --> 01:29:34,489
signed unsigned the external business we

01:29:32,000 --> 01:29:36,830
can encode a single byte and the in the

01:29:34,489 --> 01:29:38,860
same thing if it's a single byte it

01:29:36,830 --> 01:29:40,969
seems to say there little bit of space

01:29:38,860 --> 01:29:47,360
some of these are more useful than

01:29:40,969 --> 01:29:48,800
others text comment I think that if

01:29:47,360 --> 01:29:50,780
you're trying to get exactly the source

01:29:48,800 --> 01:29:52,219
that you put in it would what would be

01:29:50,780 --> 01:29:55,219
one way to do it I don't know how useful

01:29:52,219 --> 01:29:57,200
that is it's and decimal lengths of the

01:29:55,219 --> 01:30:00,350
property and then a string table so

01:29:57,200 --> 01:30:02,719
these are these big fields over here so

01:30:00,350 --> 01:30:05,860
basically with that single cell you can

01:30:02,719 --> 01:30:11,989
encode all the metadata for property

01:30:05,860 --> 01:30:15,140
that's crazy enough yet and then the non

01:30:11,989 --> 01:30:17,450
property tag along the same lines as

01:30:15,140 --> 01:30:18,890
it's a zero meaning non property we have

01:30:17,450 --> 01:30:21,290
these different tag types including

01:30:18,890 --> 01:30:24,739
things like delete node and merge node

01:30:21,290 --> 01:30:27,920
and so on and we also have the ability

01:30:24,739 --> 01:30:30,410
to specify the offset to the next node

01:30:27,920 --> 01:30:33,050
at the same level or previous notice at

01:30:30,410 --> 01:30:35,150
the same level begin and end the at

01:30:33,050 --> 01:30:37,520
least you traverse the tree quickly at

01:30:35,150 --> 01:30:39,650
the moment as a pathological case we try

01:30:37,520 --> 01:30:41,090
and find the parent of a node in a flat

01:30:39,650 --> 01:30:42,500
tree and it takes forever because you've

01:30:41,090 --> 01:30:44,570
got to go and scan from the beginning of

01:30:42,500 --> 01:30:54,440
the tree every time

01:30:44,570 --> 01:30:56,630
they would fix that and the I thought

01:30:54,440 --> 01:30:58,940
well okay let's see let's see how big

01:30:56,630 --> 01:31:02,870
this would be what how would we you know

01:30:58,940 --> 01:31:08,300
evaluate this so I used the Linux device

01:31:02,870 --> 01:31:10,910
trees about 32 megabytes of data from 8k

01:31:08,300 --> 01:31:12,170
to 83 K and so it comes down to about if

01:31:10,910 --> 01:31:14,990
you compress them just with this

01:31:12,170 --> 01:31:16,880
compression tool comes down to five

01:31:14,990 --> 01:31:18,830
about five megabytes which gives you an

01:31:16,880 --> 01:31:21,230
idea of the entropy if you know what I

01:31:18,830 --> 01:31:22,910
mean like you know it gives you some

01:31:21,230 --> 01:31:24,170
sort of thing and another another taste

01:31:22,910 --> 01:31:26,090
of that is that the source files

01:31:24,170 --> 01:31:27,950
compressed down to a similar size right

01:31:26,090 --> 01:31:29,570
so that sort of gives you you know

01:31:27,950 --> 01:31:32,720
there's some amount of actual

01:31:29,570 --> 01:31:36,320
information there but I'm nowhere near

01:31:32,720 --> 01:31:38,030
that with my with my tests basically I

01:31:36,320 --> 01:31:41,090
can get something like a forty percent

01:31:38,030 --> 01:31:44,450
size saving on the flattery with the

01:31:41,090 --> 01:31:46,760
things that I've done it's about so

01:31:44,450 --> 01:31:50,020
there's a good time to stop if if we

01:31:46,760 --> 01:31:50,020
want to we want to start

01:31:58,820 --> 01:32:07,440
ma'am maybe I'm missing something

01:32:01,140 --> 01:32:12,470
fundamental here but in load X we

01:32:07,440 --> 01:32:15,020
compress based on based on compression

01:32:12,470 --> 01:32:18,930
ability why why are we not just

01:32:15,020 --> 01:32:21,510
switching over to supporting loading of

01:32:18,930 --> 01:32:24,330
compressed DT B's instead if it buys us

01:32:21,510 --> 01:32:26,490
more oh we should device the the thing

01:32:24,330 --> 01:32:28,980
is this is to reduce the actual size and

01:32:26,490 --> 01:32:34,050
memory of the actual runtime out your

01:32:28,980 --> 01:32:38,100
intent I mean at least in SPL it's you

01:32:34,050 --> 01:32:40,230
know pretty I think it's it's a big

01:32:38,100 --> 01:32:42,180
problem to have it you know too big and

01:32:40,230 --> 01:32:44,160
we're already trying to avoid you know

01:32:42,180 --> 01:32:57,000
things like the append control stuff to

01:32:44,160 --> 01:33:00,090
save space as for you as for using a

01:32:57,000 --> 01:33:01,320
compressed TTP directly we really don't

01:33:00,090 --> 01:33:03,210
want to have to do it in really early

01:33:01,320 --> 01:33:04,860
boot code because you don't have enough

01:33:03,210 --> 01:33:06,120
space to decompress because you need to

01:33:04,860 --> 01:33:07,980
read the DT to figure out where your

01:33:06,120 --> 01:33:09,870
memory is to find the buffer the app so

01:33:07,980 --> 01:33:20,010
we wanted to be directly readable from

01:33:09,870 --> 01:33:21,420
the outset in the kernel if you're

01:33:20,010 --> 01:33:23,820
actually building a product having a

01:33:21,420 --> 01:33:25,110
boot loader decompress it to launch the

01:33:23,820 --> 01:33:26,580
kernel but yeah it doesn't solve it for

01:33:25,110 --> 01:33:28,500
hourly booty I mean you could do that

01:33:26,580 --> 01:33:30,710
today yeah exactly that's what I was

01:33:28,500 --> 01:33:30,710
saying

01:33:33,160 --> 01:33:40,210
yeah so the only other comment I make is

01:33:35,920 --> 01:33:44,110
that it's kind of annoying amount of

01:33:40,210 --> 01:33:46,180
work I think the code changes day to get

01:33:44,110 --> 01:33:55,300
this far see where I've got it to us

01:33:46,180 --> 01:33:58,840
sorry sorry alright so we're gonna come

01:33:55,300 --> 01:34:00,130
back and pick up with Simon in 10

01:33:58,840 --> 01:34:02,470
minutes 15 minutes

01:34:00,130 --> 01:34:03,280
I forgot so try and come back in about

01:34:02,470 --> 01:34:05,020
10 minutes

01:34:03,280 --> 01:34:08,530
and we're gonna take a break and come

01:34:05,020 --> 01:34:11,310
back in they should have 15 minutes okay

01:34:08,530 --> 01:34:11,310
thank you

01:34:13,440 --> 01:34:20,789
okay so I think I was basically finished

01:34:17,489 --> 01:34:20,789
check one two

01:34:25,909 --> 01:34:31,880
I just wanted to show this table this is

01:34:28,300 --> 01:34:37,460
from my experiments for thing how much

01:34:31,880 --> 01:34:41,090
impact these each of these things has so

01:34:37,460 --> 01:34:43,489
you can see the saving column they're

01:34:41,090 --> 01:34:47,570
having a single-cell property for

01:34:43,489 --> 01:34:51,139
metadata saves quite a lot and replacing

01:34:47,570 --> 01:34:55,820
compatible strings that's quite a bit

01:34:51,139 --> 01:34:58,520
and that's I get to the 40% by adding up

01:34:55,820 --> 01:35:03,800
B D and G so that's the single cell

01:34:58,520 --> 01:35:07,010
properties the in-place bite and the

01:35:03,800 --> 01:35:09,320
compatible spots so I wouldn't ask how

01:35:07,010 --> 01:35:13,489
annoying would it be to use a how

01:35:09,320 --> 01:35:15,739
feasible would it be to use Product ID

01:35:13,489 --> 01:35:18,469
vendor ID instead of a compatible string

01:35:15,739 --> 01:35:27,429
a little bit like has done with PCI or

01:35:18,469 --> 01:35:29,719
something anyone want to comment on this

01:35:27,429 --> 01:35:37,429
on the surface it sounds like a big

01:35:29,719 --> 01:35:40,940
change but if we're doing an F DT format

01:35:37,429 --> 01:35:42,500
changeover then every single device

01:35:40,940 --> 01:35:48,949
trees gotta need to get recompiled

01:35:42,500 --> 01:35:51,080
anyway and it seems like we could fairly

01:35:48,949 --> 01:35:53,900
well automate the compatible conversion

01:35:51,080 --> 01:35:54,590
does that sound reasonable yeah I think

01:35:53,900 --> 01:35:58,420
so

01:35:54,590 --> 01:35:58,420
I mean you've got the vendor comma

01:35:59,400 --> 01:36:05,190
how would we assign ids to manufacturers

01:36:02,909 --> 01:36:11,190
who maybe haven't paid their money to

01:36:05,190 --> 01:36:15,090
the PCI people you get to answer the

01:36:11,190 --> 01:36:17,100
question so I I wasn't saying it has to

01:36:15,090 --> 01:36:20,100
use the same as PCI but it's the obvious

01:36:17,100 --> 01:36:21,870
thing to use but but it doesn't have to

01:36:20,100 --> 01:36:24,270
be there you could just do it with

01:36:21,870 --> 01:36:27,780
patches to the kernel line yeah there is

01:36:24,270 --> 01:36:30,500
the option that everybody uses for octi

01:36:27,780 --> 01:36:32,760
which is to use Intel's vendor ID

01:36:30,500 --> 01:36:34,890
because when Intel puts something on a

01:36:32,760 --> 01:36:37,190
reference board they assign one of their

01:36:34,890 --> 01:36:39,630
own IDs to even come from another money

01:36:37,190 --> 01:36:42,030
even if it comes to another manufacturer

01:36:39,630 --> 01:36:43,590
and then every each one using those so

01:36:42,030 --> 01:36:45,810
there's something there's options like

01:36:43,590 --> 01:36:49,230
that where we just get a generic ID of

01:36:45,810 --> 01:36:51,540
our own and from somewhere like balloons

01:36:49,230 --> 01:36:54,510
Foundation and then sort of signing

01:36:51,540 --> 01:36:56,520
numbers in there I'm a big fan of first

01:36:54,510 --> 01:36:59,190
and gets the first number and then just

01:36:56,520 --> 01:37:03,469
cup from there then there's no you know

01:36:59,190 --> 01:37:07,170
baggage for somebody else's number and

01:37:03,469 --> 01:37:09,560
yeah yeah but that makes merge issues

01:37:07,170 --> 01:37:11,489
and people doing stuff out of tree you

01:37:09,560 --> 01:37:13,230
know you've not up streamed your driver

01:37:11,489 --> 01:37:15,390
you need to sign an ID you assign the

01:37:13,230 --> 01:37:18,960
next number so does your competitor and

01:37:15,390 --> 01:37:21,120
your competitor and it is a good point

01:37:18,960 --> 01:37:23,880
then we end up having to arbitrate IP

01:37:21,120 --> 01:37:26,850
number fights yeah and I was gonna say

01:37:23,880 --> 01:37:31,170
that the issue of out of tree out of

01:37:26,850 --> 01:37:34,980
Linux tree device trees there are so

01:37:31,170 --> 01:37:36,600
many of them out there I mean one

01:37:34,980 --> 01:37:38,489
doesn't look like the size savings is

01:37:36,600 --> 01:37:41,460
really that great so what are we trying

01:37:38,489 --> 01:37:43,080
to do yeah I mean the thing like the

01:37:41,460 --> 01:37:46,290
reason I'm interested in this as well as

01:37:43,080 --> 01:37:48,300
for efficiency you know in SPL comparing

01:37:46,290 --> 01:37:51,830
strings is just it's just pretty it's

01:37:48,300 --> 01:37:54,600
kind of dumb to be doing it arguably

01:37:51,830 --> 01:37:57,540
well any one one thing we'd also need is

01:37:54,600 --> 01:38:01,469
not just gender and product but we need

01:37:57,540 --> 01:38:03,659
like sub product or sub device because

01:38:01,469 --> 01:38:07,650
you know we get away with it with PCI

01:38:03,659 --> 01:38:10,990
and USB right well you're looking at you

01:38:07,650 --> 01:38:16,420
have one top-level ID there

01:38:10,990 --> 01:38:21,790
but we need we have top-level IDs for

01:38:16,420 --> 01:38:25,210
board associ and then the block IDs for

01:38:21,790 --> 01:38:28,150
every single block on the chip yeah yeah

01:38:25,210 --> 01:38:30,700
that's right there are a lot is it just

01:38:28,150 --> 01:38:33,100
a case of matching the strings is hard

01:38:30,700 --> 01:38:36,300
or expensive can they be patched in any

01:38:33,100 --> 01:38:39,490
way is it it's all been server slow it's

01:38:36,300 --> 01:38:40,330
kind of very human friendly but we

01:38:39,490 --> 01:38:42,610
wouldn't do it

01:38:40,330 --> 01:38:47,380
PC I didn't do it that way I don't know

01:38:42,610 --> 01:38:49,540
I guess one other she was for the Linux

01:38:47,380 --> 01:38:51,370
kernel we have our compatible strings

01:38:49,540 --> 01:38:53,830
all over the source code as well not

01:38:51,370 --> 01:38:56,920
just in the device resources so that

01:38:53,830 --> 01:38:58,210
would be a real big churn there and to

01:38:56,920 --> 01:39:01,120
maintain compatibility with two

01:38:58,210 --> 01:39:03,010
different versions of the the device

01:39:01,120 --> 01:39:08,470
tree spec would be real difficult in the

01:39:03,010 --> 01:39:11,770
drivers yeah I guess I guess ultimately

01:39:08,470 --> 01:39:13,750
there's a conversion table right so the

01:39:11,770 --> 01:39:15,700
kernel could have that and then you'd

01:39:13,750 --> 01:39:18,460
have to have new API functions I think

01:39:15,700 --> 01:39:22,960
it took to deal with the case or a new a

01:39:18,460 --> 01:39:25,360
new table format so yeah um how would

01:39:22,960 --> 01:39:29,140
you deal with companies that can't get

01:39:25,360 --> 01:39:31,570
PC IDs well we talked about that but

01:39:29,140 --> 01:39:33,850
before I think we just we could allocate

01:39:31,570 --> 01:39:36,460
our own like just ever have a table in

01:39:33,850 --> 01:39:38,050
the kernel okay I mean this sounds

01:39:36,460 --> 01:39:44,380
pretty controversial we probably should

01:39:38,050 --> 01:39:46,420
start talking about but it's it's yeah I

01:39:44,380 --> 01:39:48,820
actually have a question I wanted to ask

01:39:46,420 --> 01:39:51,460
people was are there any other ideas or

01:39:48,820 --> 01:39:52,810
making it smaller I mean I guess a lot

01:39:51,460 --> 01:39:57,510
of kernel people don't really care about

01:39:52,810 --> 01:40:00,110
making it smaller anyway is that true

01:39:57,510 --> 01:40:02,300
the flat tree

01:40:00,110 --> 01:40:05,840
because you just compress that or get a

01:40:02,300 --> 01:40:08,540
bit lighter to decompress that one thing

01:40:05,840 --> 01:40:10,880
that we could do is start dropping nodes

01:40:08,540 --> 01:40:12,260
that are disabled with status disabled

01:40:10,880 --> 01:40:14,240
but right

01:40:12,260 --> 01:40:18,560
sometimes the bootloader is what turns

01:40:14,240 --> 01:40:22,030
us on and right yeah see you nodes are a

01:40:18,560 --> 01:40:24,260
little different in how they work yeah

01:40:22,030 --> 01:40:25,910
this seems like an obvious thing to do

01:40:24,260 --> 01:40:31,100
so long as you don't then and need to

01:40:25,910 --> 01:40:36,230
enable them later that's actually what

01:40:31,100 --> 01:40:38,690
we do in the kernel it's it's hidden

01:40:36,230 --> 01:40:42,110
behind an option I'd forget I think the

01:40:38,690 --> 01:40:46,070
of' dynamic option that if the nodes

01:40:42,110 --> 01:40:47,780
disabled we don't unflagging it right so

01:40:46,070 --> 01:40:49,580
why the kernel may not be as quite as

01:40:47,780 --> 01:40:51,410
sensitive to it as effort is going to be

01:40:49,580 --> 01:40:53,840
very sensitive to it we're using device

01:40:51,410 --> 01:40:55,160
tree and zephyr and so we'll probably

01:40:53,840 --> 01:40:56,960
want to make sure we can keep these

01:40:55,160 --> 01:40:59,870
things as small as possible but the

01:40:56,960 --> 01:41:07,010
device tree is not on in the image it's

01:40:59,870 --> 01:41:09,320
it's it's used to generate the headers

01:41:07,010 --> 01:41:13,070
and and such out of the device tree it's

01:41:09,320 --> 01:41:22,460
not on the device binary unless it's

01:41:13,070 --> 01:41:24,290
changed yeah yes as soon as what was he

01:41:22,460 --> 01:41:27,170
talking Zephyr specifically perhaps said

01:41:24,290 --> 01:41:29,000
yes I was gonna make a comment earlier

01:41:27,170 --> 01:41:31,130
and just skipped but I guess now I

01:41:29,000 --> 01:41:33,590
should mention that really are a lot of

01:41:31,130 --> 01:41:37,240
communities involved here we're sitting

01:41:33,590 --> 01:41:39,020
here in a Linux room but we have a

01:41:37,240 --> 01:41:42,380
project which is the device tree

01:41:39,020 --> 01:41:44,510
compiler itself David Gibson and John I

01:41:42,380 --> 01:41:47,240
never know how to say lowly Girt la

01:41:44,510 --> 01:41:49,220
lager there the various boot loaders

01:41:47,240 --> 01:41:52,420
that use it

01:41:49,220 --> 01:41:55,850
there's Zephir as Kate just mentioned

01:41:52,420 --> 01:41:57,380
there's some bsds using it I wouldn't be

01:41:55,850 --> 01:41:59,810
surprised if there aren't other people

01:41:57,380 --> 01:42:05,080
and anyone else nope other projects

01:41:59,810 --> 01:42:07,700
using it yeah boot loaders to the core I

01:42:05,080 --> 01:42:10,280
think those are the main ones that I

01:42:07,700 --> 01:42:12,110
know of yeah so that's a bit of a

01:42:10,280 --> 01:42:14,090
challenge it's hard to reach out to all

01:42:12,110 --> 01:42:16,580
those groups because they don't come to

01:42:14,090 --> 01:42:19,340
a Linux conference and I don't know of

01:42:16,580 --> 01:42:21,230
any good venue what was ever does but

01:42:19,340 --> 01:42:29,360
but the others in well you boot people

01:42:21,230 --> 01:42:31,250
do yeah yeah I think I think the best

01:42:29,360 --> 01:42:37,340
bet for those are probably the ELC s and

01:42:31,250 --> 01:42:40,160
the EOC Europe's so far so one thing

01:42:37,340 --> 01:42:41,690
I'll say is that some of these can be

01:42:40,160 --> 01:42:44,180
done some of these changes can be done

01:42:41,690 --> 01:42:46,040
with just Liberty T updates and some do

01:42:44,180 --> 01:42:48,040
actually need API change and a new

01:42:46,040 --> 01:42:50,690
function or something the one

01:42:48,040 --> 01:42:53,090
compressing putting a single cell mate

01:42:50,690 --> 01:42:56,450
property metadata once you do that you

01:42:53,090 --> 01:42:58,820
actually can't use things like you know

01:42:56,450 --> 01:43:00,800
the get property function that returns a

01:42:58,820 --> 01:43:04,460
struct you have to have one that

01:43:00,800 --> 01:43:06,650
pretends separate things which I

01:43:04,460 --> 01:43:08,660
actually think is a better API anyway I

01:43:06,650 --> 01:43:10,610
think the current one we have to you

01:43:08,660 --> 01:43:13,790
know to change the Indian s and so on as

01:43:10,610 --> 01:43:17,060
kind of dumb but it does allow get prop

01:43:13,790 --> 01:43:18,830
to work so most of the API stays the

01:43:17,060 --> 01:43:20,870
same and so things like u-boot for

01:43:18,830 --> 01:43:23,240
example wouldn't care too much they

01:43:20,870 --> 01:43:25,190
would would just continue to work yeah

01:43:23,240 --> 01:43:28,250
if I can weigh in on the API that

01:43:25,190 --> 01:43:30,800
returns pointers to our data structures

01:43:28,250 --> 01:43:32,930
and by our data structures I mean device

01:43:30,800 --> 01:43:34,120
tree core internal data structures the

01:43:32,930 --> 01:43:35,650
device tree

01:43:34,120 --> 01:43:37,720
I think does create a lot of problems

01:43:35,650 --> 01:43:41,860
and the one that I've really been

01:43:37,720 --> 01:43:45,280
running against is for overlays once

01:43:41,860 --> 01:43:47,620
somebody has a pointer into an internal

01:43:45,280 --> 01:43:49,510
data structure I have no idea where the

01:43:47,620 --> 01:43:51,970
pointer remains live when someone goes

01:43:49,510 --> 01:43:54,580
to release the overlay so use after free

01:43:51,970 --> 01:43:56,140
becomes a real concern for me and if we

01:43:54,580 --> 01:43:58,180
could get rid of all the api's that

01:43:56,140 --> 01:43:59,440
return pointers to our internal

01:43:58,180 --> 01:44:02,950
structures we could solve that but

01:43:59,440 --> 01:44:10,780
that's a major change impacting drivers

01:44:02,950 --> 01:44:12,370
in court code yeah but I totally agree I

01:44:10,780 --> 01:44:14,590
think there's the needs to be more

01:44:12,370 --> 01:44:16,600
separation between oh I can see how it

01:44:14,590 --> 01:44:19,510
ended up that way for efficiency reasons

01:44:16,600 --> 01:44:21,390
maybe yeah plus it might actually use

01:44:19,510 --> 01:44:23,770
more memory because you end up copying

01:44:21,390 --> 01:44:25,630
data and returning the copy to the

01:44:23,770 --> 01:44:31,090
caller who wants to see that the value

01:44:25,630 --> 01:44:32,320
so there's the downside in addition to

01:44:31,090 --> 01:44:34,810
the memory overhead there's also going

01:44:32,320 --> 01:44:37,210
to be an additional CPU overhead as well

01:44:34,810 --> 01:44:43,300
so there's performance hit on both of

01:44:37,210 --> 01:44:50,590
those sure I the comment was only on

01:44:43,300 --> 01:44:53,430
read which is true okay anything else

01:44:50,590 --> 01:44:53,430
people want to say

01:44:56,540 --> 01:45:02,239
other than here where else have you

01:44:58,800 --> 01:45:08,250
published us the this proposal published

01:45:02,239 --> 01:45:09,480
yeah okay I mean this is just I I've

01:45:08,250 --> 01:45:11,360
been playing around doing some

01:45:09,480 --> 01:45:14,010
experiments the last few weeks I

01:45:11,360 --> 01:45:15,690
actually before I dropped off the

01:45:14,010 --> 01:45:18,360
mailing list because somehow the ping

01:45:15,690 --> 01:45:21,000
who told me I was bouncing or something

01:45:18,360 --> 01:45:22,290
so I actually did a bit of reading and

01:45:21,000 --> 01:45:23,540
found that some people have done some

01:45:22,290 --> 01:45:27,750
things already

01:45:23,540 --> 01:45:29,040
thanks so so yeah not having published

01:45:27,750 --> 01:45:31,770
it anywhere I mean I know it's a little

01:45:29,040 --> 01:45:35,250
bit crazy but I just thought we just

01:45:31,770 --> 01:45:39,179
sort of start the you know start with

01:45:35,250 --> 01:45:40,770
everything and see how it goes certainly

01:45:39,179 --> 01:45:43,739
it's a good conversation starter and it

01:45:40,770 --> 01:45:45,960
would be useful to to begin to at least

01:45:43,739 --> 01:45:47,820
socialize it a little bit get comments I

01:45:45,960 --> 01:45:49,440
mean the impact on something like get

01:45:47,820 --> 01:45:52,110
property in terms of the drawer how wide

01:45:49,440 --> 01:45:54,900
that is the the potential impact of

01:45:52,110 --> 01:45:57,810
moving away from compatible strings as

01:45:54,900 --> 01:46:01,469
well I'm pretty sure that will we will

01:45:57,810 --> 01:46:02,880
hear plenty of comment so we should

01:46:01,469 --> 01:46:04,640
probably at least start throwing it out

01:46:02,880 --> 01:46:07,320
there and get some other thoughts

01:46:04,640 --> 01:46:10,590
now the other one that comes to mind

01:46:07,320 --> 01:46:12,929
just all of a sudden is things like for

01:46:10,590 --> 01:46:16,890
the the DMA bindings transmit/receive

01:46:12,929 --> 01:46:18,600
which which DMA is being used in which

01:46:16,890 --> 01:46:20,400
directions so there are strings being

01:46:18,600 --> 01:46:24,719
used there which again probably are

01:46:20,400 --> 01:46:27,210
overkill yes that's a good point and

01:46:24,719 --> 01:46:27,719
it's a separate property altogether too

01:46:27,210 --> 01:46:31,199
so

01:46:27,719 --> 01:46:33,150
right yeah I think the I I actually got

01:46:31,199 --> 01:46:36,239
all excited and thought pen control was

01:46:33,150 --> 01:46:38,280
gonna be a big saving but most of the

01:46:36,239 --> 01:46:41,489
Association on the UM side don't

01:46:38,280 --> 01:46:44,760
actually use strings for that was a lot

01:46:41,489 --> 01:46:49,679
of strings but I think Samsung does and

01:46:44,760 --> 01:46:54,090
I actually did I do that maybe I don't

01:46:49,679 --> 01:46:55,679
know whether it was on there but the I

01:46:54,090 --> 01:46:57,480
did actually look at it it didn't make

01:46:55,679 --> 01:46:59,850
that much difference even for Samsung

01:46:57,480 --> 01:47:03,060
for the ultimate size so I thought oh

01:46:59,850 --> 01:47:04,800
well I'm just thinking that that there's

01:47:03,060 --> 01:47:06,690
there's probably bindings with that

01:47:04,800 --> 01:47:09,000
could be tightened up for next gen

01:47:06,690 --> 01:47:10,230
versions that that would even

01:47:09,000 --> 01:47:12,600
two properties altogether and just to

01:47:10,230 --> 01:47:16,640
add directionality into the the tuple

01:47:12,600 --> 01:47:16,640
itself yeah exactly yeah

01:47:22,630 --> 01:47:27,760
oh and I was waiting for that I didn't

01:47:25,390 --> 01:47:31,710
want to say I did present something a

01:47:27,760 --> 01:47:34,870
year ago about you boo SPL and this was

01:47:31,710 --> 01:47:37,450
if did he grip a thing that got rid of a

01:47:34,870 --> 01:47:39,580
lot of nodes that weren't used didn't

01:47:37,450 --> 01:47:41,230
need wouldn't need for SPL and so on so

01:47:39,580 --> 01:47:44,160
for the zipper people if you want it

01:47:41,230 --> 01:47:47,020
that's useful I don't know it gets the

01:47:44,160 --> 01:47:49,420
device tree down to you know three K for

01:47:47,020 --> 01:47:50,980
a rupture thing for example from about

01:47:49,420 --> 01:47:53,080
forty eight K because we just throw away

01:47:50,980 --> 01:47:59,680
stuff we know we don't need for the

01:47:53,080 --> 01:48:01,830
devices we have an SPL alright thank you

01:47:59,680 --> 01:48:01,830
everyone

01:48:05,340 --> 01:48:09,820
strangely enough we are right back on

01:48:08,260 --> 01:48:14,380
schedule if you consider that to have

01:48:09,820 --> 01:48:17,200
been Q&A number two so we can be

01:48:14,380 --> 01:48:19,480
flexible in our interpretations I'm

01:48:17,200 --> 01:48:21,010
gonna jump through more than three

01:48:19,480 --> 01:48:23,110
slides so some of these thing I might

01:48:21,010 --> 01:48:24,790
jump through pretty quickly so I don't

01:48:23,110 --> 01:48:27,430
take a lot of time on them leave more

01:48:24,790 --> 01:48:30,130
time for everything else but they are

01:48:27,430 --> 01:48:32,020
there for reference just a pointer to

01:48:30,130 --> 01:48:35,140
where I first started this discussion on

01:48:32,020 --> 01:48:37,060
the mail list back about a year ago the

01:48:35,140 --> 01:48:39,010
big thing I learned was and I showed

01:48:37,060 --> 01:48:40,840
previously in the graph there is a

01:48:39,010 --> 01:48:43,060
significant space used by the overlay

01:48:40,840 --> 01:48:45,460
metadata for the symbol information

01:48:43,060 --> 01:48:51,670
there is opportunity to save space we

01:48:45,460 --> 01:48:55,450
saw the graph compatibility is real

01:48:51,670 --> 01:48:59,320
important in the past we've tried to be

01:48:55,450 --> 01:49:01,840
able to have compatibility between all

01:48:59,320 --> 01:49:04,450
versions of of the flattened device

01:49:01,840 --> 01:49:06,130
trees and the code you know back and

01:49:04,450 --> 01:49:08,140
forth depending on which is switching

01:49:06,130 --> 01:49:11,290
the code or the the flattened device

01:49:08,140 --> 01:49:14,470
tree this is a point where given Simon's

01:49:11,290 --> 01:49:16,530
proposals and my proposals I think this

01:49:14,470 --> 01:49:19,870
is going to be one of those breaks where

01:49:16,530 --> 01:49:21,600
there's not gonna be compatibility you

01:49:19,870 --> 01:49:23,890
have to have a very clear distinction of

01:49:21,600 --> 01:49:26,710
which version of software and which

01:49:23,890 --> 01:49:28,360
version of device tree you're using we

01:49:26,710 --> 01:49:30,190
can try and maintain the compatibility

01:49:28,360 --> 01:49:34,260
if we do that we don't get as big to

01:49:30,190 --> 01:49:37,000
gain we don't gain some of the features

01:49:34,260 --> 01:49:39,160
Simon mentioned the idea for instance of

01:49:37,000 --> 01:49:43,240
being able to delete a node that's gonna

01:49:39,160 --> 01:49:44,350
require a compatibility break and just I

01:49:43,240 --> 01:49:46,870
think there's gonna be a lot of value to

01:49:44,350 --> 01:49:50,260
it we can make that decision in the

01:49:46,870 --> 01:49:51,700
discussion when we're actually trying to

01:49:50,260 --> 01:49:55,840
change it but I'm hoping that people

01:49:51,700 --> 01:49:57,220
will go with the the big heartbreak and

01:49:55,840 --> 01:49:58,870
as I mentioned before there are a lot of

01:49:57,220 --> 01:50:01,540
different projects involved we need to

01:49:58,870 --> 01:50:03,370
keep them all in the loop just a real

01:50:01,540 --> 01:50:04,960
quick for people who don't know the

01:50:03,370 --> 01:50:07,840
actual internals of device tree just

01:50:04,960 --> 01:50:09,010
enough to understand some of the context

01:50:07,840 --> 01:50:11,890
of what we've been saying and what we're

01:50:09,010 --> 01:50:15,160
about to say the device tree has a

01:50:11,890 --> 01:50:17,350
header block which has pointers in two

01:50:15,160 --> 01:50:20,820
sub blocks within the flattened device

01:50:17,350 --> 01:50:23,770
tree and a bunch of other things of

01:50:20,820 --> 01:50:26,790
various interest so the structure block

01:50:23,770 --> 01:50:30,130
is where the actual nodes and properties

01:50:26,790 --> 01:50:31,930
tree structure lives and is described

01:50:30,130 --> 01:50:33,880
and that'll be important on the next

01:50:31,930 --> 01:50:35,470
slide and that covers a lot of what

01:50:33,880 --> 01:50:38,350
Simon's been talking about this thing's

01:50:35,470 --> 01:50:41,940
in the structure block the strings block

01:50:38,350 --> 01:50:44,350
is just a storage area for strings

01:50:41,940 --> 01:50:46,120
reference from elsewhere in the

01:50:44,350 --> 01:50:50,590
flattened device tree it's just a table

01:50:46,120 --> 01:50:53,380
of strings one attribute of it is a

01:50:50,590 --> 01:50:57,490
despite aligned instead of four byte

01:50:53,380 --> 01:51:00,480
aligned and there's some string reuse if

01:50:57,490 --> 01:51:03,280
a substring is part of a larger string

01:51:00,480 --> 01:51:04,930
then a reference can point into that

01:51:03,280 --> 01:51:07,180
substring instead of having to

01:51:04,930 --> 01:51:08,410
reallocate space to to have that

01:51:07,180 --> 01:51:11,530
substring and two different places in

01:51:08,410 --> 01:51:13,090
the table and finally memory reserve map

01:51:11,530 --> 01:51:18,310
is another block these get pointed to

01:51:13,090 --> 01:51:21,250
you this is just a trivial source device

01:51:18,310 --> 01:51:23,230
tree and then taking a tokenized

01:51:21,250 --> 01:51:25,690
version just conceptually what does that

01:51:23,230 --> 01:51:28,170
turn into when it's compiled and then

01:51:25,690 --> 01:51:31,090
finally what does it actually look like

01:51:28,170 --> 01:51:32,710
kind of it's not hex or binary but the

01:51:31,090 --> 01:51:34,780
equivalent of that and I'm just going to

01:51:32,710 --> 01:51:35,920
look at a couple lines but but you can

01:51:34,780 --> 01:51:40,360
look at this later at home if you're

01:51:35,920 --> 01:51:41,770
curious root node we have a key at the

01:51:40,360 --> 01:51:42,780
bottom which says what my little tokens

01:51:41,770 --> 01:51:45,360
are begin node and

01:51:42,780 --> 01:51:46,920
begin property and block and Simon

01:51:45,360 --> 01:51:50,220
referenced these tags and hit when he

01:51:46,920 --> 01:51:53,400
was talking so for the first note route

01:51:50,220 --> 01:51:55,320
is special it is begin node it doesn't

01:51:53,400 --> 01:51:58,470
encode the name listen ignore that we

01:51:55,320 --> 01:52:02,340
come to our next node its name is whoops

01:51:58,470 --> 01:52:05,070
I have a typo and X so we have a begin

01:52:02,340 --> 01:52:08,400
node token that's a each of these items

01:52:05,070 --> 01:52:12,900
here are a four byte or multiple of four

01:52:08,400 --> 01:52:16,350
byte item a cell so we have a tag taking

01:52:12,900 --> 01:52:18,630
four bytes a string which should be NX

01:52:16,350 --> 01:52:21,510
they're taking four bytes and when we

01:52:18,630 --> 01:52:25,470
look at the actual dump would see one

01:52:21,510 --> 01:52:30,300
which is begin node would see an N a ye

01:52:25,470 --> 01:52:32,190
and a string terminating 0 and a

01:52:30,300 --> 01:52:33,750
padding:0 because we had we have that

01:52:32,190 --> 01:52:36,630
four byte of life you have four byte

01:52:33,750 --> 01:52:39,450
alignment property let's jump down to

01:52:36,630 --> 01:52:42,600
property - we have our tag saying begin

01:52:39,450 --> 01:52:44,640
property an assignment said we have a

01:52:42,600 --> 01:52:48,630
field which tells us how long is the

01:52:44,640 --> 01:52:51,450
actual value held in that property then

01:52:48,630 --> 01:52:53,580
our name offset that tells us where to

01:52:51,450 --> 01:52:55,680
go look in that strings block to find

01:52:53,580 --> 01:52:58,980
the actual name and that gives us some

01:52:55,680 --> 01:53:01,260
deduplication it gives us some space

01:52:58,980 --> 01:53:04,080
saving there and then we actually have

01:53:01,260 --> 01:53:06,720
the value encoded in the property so in

01:53:04,080 --> 01:53:09,660
this example of property 2 we have our

01:53:06,720 --> 01:53:12,300
our tag begin property is 3 our length

01:53:09,660 --> 01:53:14,670
is 8 bytes of data and then we have some

01:53:12,300 --> 01:53:17,400
magic offset into the string into the

01:53:14,670 --> 01:53:19,910
strings block then we actually have our

01:53:17,400 --> 01:53:23,430
values 2 is a full 4 bytes

01:53:19,910 --> 01:53:26,550
99 is a full 4 bytes so the reason I'm

01:53:23,430 --> 01:53:27,620
showing you this is to understand what

01:53:26,550 --> 01:53:30,150
you have to do when you're parsing

01:53:27,620 --> 01:53:32,010
whether you're a bootloader whether the

01:53:30,150 --> 01:53:34,170
kernel you actually have to scan

01:53:32,010 --> 01:53:36,990
serially through the stream and each

01:53:34,170 --> 01:53:39,330
time you hit an entry you find out how

01:53:36,990 --> 01:53:41,040
big that entry is so then you can look

01:53:39,330 --> 01:53:43,290
beyond that entry to find the next entry

01:53:41,040 --> 01:53:45,600
and once you hit that entry you decide

01:53:43,290 --> 01:53:49,050
how long that is if we add a new type of

01:53:45,600 --> 01:53:52,080
entry a new tag type then existing code

01:53:49,050 --> 01:53:54,420
doesn't know how to skip over that entry

01:53:52,080 --> 01:53:55,469
and get to the next entry so there's no

01:53:54,420 --> 01:53:57,449
way to maintain

01:53:55,469 --> 01:53:59,880
compatibility at the binary level when

01:53:57,449 --> 01:54:01,650
we start playing with tags and these

01:53:59,880 --> 01:54:03,300
proposals they're really gonna save a

01:54:01,650 --> 01:54:05,940
space to give us functionality or

01:54:03,300 --> 01:54:08,070
impacting our tags adding tags or

01:54:05,940 --> 01:54:10,380
modifying the Simon's proposing the

01:54:08,070 --> 01:54:13,050
format of those tags and he's adding a

01:54:10,380 --> 01:54:17,159
lot of contact get context into a single

01:54:13,050 --> 01:54:20,999
four byte tag so that's a lot of what's

01:54:17,159 --> 01:54:24,059
driving the incompatibility that I think

01:54:20,999 --> 01:54:26,099
where I have to hit this is just real

01:54:24,059 --> 01:54:28,229
quick saying when you actually have an

01:54:26,099 --> 01:54:30,869
overlay it has metadata is currently

01:54:28,229 --> 01:54:32,940
sitting in three special types of nodes

01:54:30,869 --> 01:54:35,249
it's very verbose it has a lot of string

01:54:32,940 --> 01:54:37,400
data in there it takes a lot of space to

01:54:35,249 --> 01:54:37,400
do that

01:54:38,150 --> 01:54:43,860
my proposal prototype back in the

01:54:41,610 --> 01:54:45,599
beginning of the year converted each of

01:54:43,860 --> 01:54:48,119
these entries into a very very small

01:54:45,599 --> 01:54:49,979
amount of space so for the symbols node

01:54:48,119 --> 01:54:54,059
instead of having a long string it was

01:54:49,979 --> 01:54:56,039
just two 32-bit values which were

01:54:54,059 --> 01:54:58,889
essentially offsets into some of those

01:54:56,039 --> 01:55:01,769
other structures for fix-ups again it

01:54:58,889 --> 01:55:03,780
was just two 32-bit values again

01:55:01,769 --> 01:55:05,820
pointing somewhere else in the in the

01:55:03,780 --> 01:55:08,309
flattened device tree for the local

01:55:05,820 --> 01:55:10,949
fix-ups it was just a single value so

01:55:08,309 --> 01:55:13,949
you can see the amount of space savings

01:55:10,949 --> 01:55:16,469
potentially errors is pretty large this

01:55:13,949 --> 01:55:19,019
I did not actually measure unlike the

01:55:16,469 --> 01:55:21,659
the previous case where I showed where

01:55:19,019 --> 01:55:24,179
these symbols information overhead byte

01:55:21,659 --> 01:55:26,969
size so I don't know the actual savings

01:55:24,179 --> 01:55:30,300
of this these changes so I put this on

01:55:26,969 --> 01:55:34,409
the mail list David came back with a

01:55:30,300 --> 01:55:36,829
good suggestion which was let me jump up

01:55:34,409 --> 01:55:40,920
there but here we go

01:55:36,829 --> 01:55:43,710
putting additional new tags after a

01:55:40,920 --> 01:55:45,300
property that contained a pea handle so

01:55:43,710 --> 01:55:47,340
this new tag would kind of back

01:55:45,300 --> 01:55:50,429
reference to the previous property and

01:55:47,340 --> 01:55:55,530
saying what fields on this property bar

01:55:50,429 --> 01:55:58,110
P handles so again it's adding a new tag

01:55:55,530 --> 01:56:01,949
we broken our format this gives us

01:55:58,110 --> 01:56:04,229
really nice advantages when the

01:56:01,949 --> 01:56:06,420
bootloader wants to modify the struct

01:56:04,229 --> 01:56:07,979
block add nodes delete nodes Adderley

01:56:06,420 --> 01:56:09,020
properties it can handle these very

01:56:07,979 --> 01:56:11,450
easily

01:56:09,020 --> 01:56:13,340
and my initial proposal it'd be very

01:56:11,450 --> 01:56:15,890
hard for the boot loaders to be making

01:56:13,340 --> 01:56:18,560
those modifications because I have

01:56:15,890 --> 01:56:20,450
references from other blocks outside of

01:56:18,560 --> 01:56:22,760
the strike block pointing into it so

01:56:20,450 --> 01:56:25,640
this is a really good idea this also

01:56:22,760 --> 01:56:30,350
gives us the ability to decompile an F

01:56:25,640 --> 01:56:33,710
DT and recover what is a P handle

01:56:30,350 --> 01:56:36,470
reference as data and we can then

01:56:33,710 --> 01:56:41,030
recreate the actual symbolic the symbol

01:56:36,470 --> 01:56:42,880
on the node and the P handled name which

01:56:41,030 --> 01:56:45,260
may end up being an arbitrary panel name

01:56:42,880 --> 01:56:49,850
pointing back to that now it actually be

01:56:45,260 --> 01:56:51,410
the correct P ambled name reference so

01:56:49,850 --> 01:56:54,800
that's one item right now when we

01:56:51,410 --> 01:56:56,540
decompile we lose those P handled name

01:56:54,800 --> 01:56:58,250
references this would give us that that

01:56:56,540 --> 01:57:00,520
ability which would be really nice to

01:56:58,250 --> 01:57:00,520
have

01:57:13,360 --> 01:57:18,270
okay questions how am I on time Shawn

01:57:25,010 --> 01:57:30,690
so if we're gonna change the tags can we

01:57:28,800 --> 01:57:32,370
do it in a way that we change them where

01:57:30,690 --> 01:57:36,540
we can add new ones later without

01:57:32,370 --> 01:57:41,360
breaking compatibility like I mean if we

01:57:36,540 --> 01:57:43,920
had masked out most of the bits in

01:57:41,360 --> 01:57:48,210
existing software than if we added new

01:57:43,920 --> 01:57:51,150
bits then we could support that without

01:57:48,210 --> 01:57:54,180
breaking compatibility I think I I think

01:57:51,150 --> 01:57:56,940
so I like the idea Simon I didn't look

01:57:54,180 --> 01:57:59,520
at your proposed tag formats thinking

01:57:56,940 --> 01:58:02,190
about this but I think the idea that you

01:57:59,520 --> 01:58:06,720
have of adding a lot of complexity into

01:58:02,190 --> 01:58:09,630
what a tag can be actually I think

01:58:06,720 --> 01:58:11,490
there's a way to achieve Rob's goal so

01:58:09,630 --> 01:58:15,930
you might don't have a flag which says

01:58:11,490 --> 01:58:17,640
this is a fixed size tag and we'd have

01:58:15,930 --> 01:58:22,440
maybe convention that the size of the

01:58:17,640 --> 01:58:24,540
tag is the very first field after we

01:58:22,440 --> 01:58:27,270
don't want to add a length field into

01:58:24,540 --> 01:58:30,060
every entry if the link is not variable

01:58:27,270 --> 01:58:32,010
because that's just overhead for

01:58:30,060 --> 01:58:33,870
variable length fields maybe we can't

01:58:32,010 --> 01:58:37,230
have a convention maybe the next field

01:58:33,870 --> 01:58:40,500
is like there we believe it's achievable

01:58:37,230 --> 01:58:45,900
somehow I think that's something that's

01:58:40,500 --> 01:58:47,280
a goal that we should put in there I'd

01:58:45,900 --> 01:58:49,680
concept with headers I think those

01:58:47,280 --> 01:58:51,510
should be more easily extensible without

01:58:49,680 --> 01:58:54,650
breaking compatibility yeah quit I I

01:58:51,510 --> 01:58:58,250
didn't actually mention it but in the

01:58:54,650 --> 01:59:01,440
slides or no in the doc actually that

01:58:58,250 --> 01:59:02,820
yeah I'd if if you can't represent the

01:59:01,440 --> 01:59:04,800
length and the bits that you have you

01:59:02,820 --> 01:59:07,800
just put it in the cell afterwards and

01:59:04,800 --> 01:59:13,290
my my size numbers sort of reflect there

01:59:07,800 --> 01:59:15,570
and saying with the string saying but I

01:59:13,290 --> 01:59:17,790
I think I know

01:59:15,570 --> 01:59:20,190
backwards compatibility says very useful

01:59:17,790 --> 01:59:24,690
but one problem is if as soon as you use

01:59:20,190 --> 01:59:27,810
a tag and your new thing they don't know

01:59:24,690 --> 01:59:29,910
what to do with it right so I guess

01:59:27,810 --> 01:59:32,750
you're saying put the length of the tag

01:59:29,910 --> 01:59:39,360
in there and that way you can skip it

01:59:32,750 --> 01:59:44,520
yeah okay that's kind of annoying but

01:59:39,360 --> 01:59:48,150
yeah yeah obviously it can only be

01:59:44,520 --> 01:59:49,889
things that can be optional right and

01:59:48,150 --> 01:59:53,550
we'll probably still have to break stuff

01:59:49,889 --> 01:59:57,719
but right now we do in any unknown tag I

01:59:53,550 --> 02:00:02,119
think just blows up seems like we could

01:59:57,719 --> 02:00:02,119
do better there yeah yeah

02:00:11,170 --> 02:00:20,929
I was about to say grants amazingly

02:00:14,809 --> 02:00:24,500
quiet yeah that's a challenge I mean

02:00:20,929 --> 02:00:25,960
it's we're yeah just the way that we're

02:00:24,500 --> 02:00:27,770
handling the tags

02:00:25,960 --> 02:00:32,420
anything we do is going to be a

02:00:27,770 --> 02:00:33,530
compatibility break I was intrigued by

02:00:32,420 --> 02:00:37,099
what you were talking about earlier

02:00:33,530 --> 02:00:42,349
Simon with the ABI or the API changes

02:00:37,099 --> 02:00:43,760
that are required because I'm mostly

02:00:42,349 --> 02:00:45,110
thinking of regardless of what we do

02:00:43,760 --> 02:00:47,389
we're going to have an AV

02:00:45,110 --> 02:00:50,300
ABI breakage which means we need a

02:00:47,389 --> 02:00:53,119
transition period which means we need

02:00:50,300 --> 02:00:55,309
the library to support both and we can't

02:00:53,119 --> 02:00:59,000
support both until we've got the API

02:00:55,309 --> 02:01:01,460
changes so that would be priority to me

02:00:59,000 --> 02:01:05,270
is figure out what is wrong with the

02:01:01,460 --> 02:01:07,840
current Lib fdt API that needs to be

02:01:05,270 --> 02:01:10,670
changed so that we can still do flat

02:01:07,840 --> 02:01:16,789
parsing of the tree in place parsing of

02:01:10,670 --> 02:01:18,619
the tree and with an API that works both

02:01:16,789 --> 02:01:22,070
with the old format and whatever new

02:01:18,619 --> 02:01:24,949
format we come up with because once we

02:01:22,070 --> 02:01:26,869
do that then I think there's there can

02:01:24,949 --> 02:01:30,139
be that an iterative point in time of

02:01:26,869 --> 02:01:33,440
experimenting with what is the best way

02:01:30,139 --> 02:01:34,699
to do this I think don't some of the

02:01:33,440 --> 02:01:37,429
little things that are being talked

02:01:34,699 --> 02:01:40,039
about like for doing the P handle tag

02:01:37,429 --> 02:01:44,360
and stuff like that it's going to be

02:01:40,039 --> 02:01:48,170
painful and get us very little actual

02:01:44,360 --> 02:01:50,780
actual benefit it might be a little bit

02:01:48,170 --> 02:01:53,119
like a band-aid and we've got to rip it

02:01:50,780 --> 02:01:55,070
off to do the API changes on the library

02:01:53,119 --> 02:01:57,949
and figure out how to get those into the

02:01:55,070 --> 02:01:59,900
projects that need it and then at the

02:01:57,949 --> 02:02:02,389
same time be experimenting forth format

02:01:59,900 --> 02:02:04,130
once the format is set there's going to

02:02:02,389 --> 02:02:08,570
be years where we're handling both

02:02:04,130 --> 02:02:12,020
actually it'll be indefinite where we're

02:02:08,570 --> 02:02:13,570
handling both the old and new format so

02:02:12,020 --> 02:02:17,389
if we're going to have multiple formats

02:02:13,570 --> 02:02:20,630
maybe this the priority needs to be

02:02:17,389 --> 02:02:24,790
figure out what it is that is actually

02:02:20,630 --> 02:02:29,120
needed instead of band-aid fast fixes

02:02:24,790 --> 02:02:32,090
yeah I I definitely agree with starting

02:02:29,120 --> 02:02:34,580
with the API the good thing is that the

02:02:32,090 --> 02:02:35,960
the problem edit functions are not very

02:02:34,580 --> 02:02:37,970
there's not very many there's that one I

02:02:35,960 --> 02:02:39,620
mentioned that returns a property struct

02:02:37,970 --> 02:02:42,890
which I hate anyway I think it's I think

02:02:39,620 --> 02:02:45,890
it's not a good API there's not very

02:02:42,890 --> 02:02:48,290
many actually so long as get prop still

02:02:45,890 --> 02:02:50,230
works I made sure that the type of

02:02:48,290 --> 02:02:54,080
information didn't spill out into the

02:02:50,230 --> 02:02:58,910
value so yeah I think that's a really

02:02:54,080 --> 02:03:01,910
good approach so I was gonna say that it

02:02:58,910 --> 02:03:03,860
seems like the the get prop when would

02:03:01,910 --> 02:03:06,950
could preserve the existing

02:03:03,860 --> 02:03:08,990
functionality with the new encoding so

02:03:06,950 --> 02:03:10,820
we wouldn't have to change anything for

02:03:08,990 --> 02:03:14,690
for existing drivers and then if we add

02:03:10,820 --> 02:03:16,940
the additional api's to get a specific

02:03:14,690 --> 02:03:18,980
field out which would give us kind of a

02:03:16,940 --> 02:03:20,480
good way to support moving forward and

02:03:18,980 --> 02:03:42,020
do you see any complication when trying

02:03:20,480 --> 02:03:42,530
to support that throw it again for a

02:03:42,020 --> 02:03:45,110
different reason

02:03:42,530 --> 02:03:47,210
no I'm saying that I mean if the idea is

02:03:45,110 --> 02:03:49,390
that get property right now returns the

02:03:47,210 --> 02:03:52,370
struct and that's kind of obnoxious but

02:03:49,390 --> 02:03:54,890
if we change the semantics of that

02:03:52,370 --> 02:03:56,720
function that's gonna force changes in

02:03:54,890 --> 02:03:59,360
the code but if we preserve that with

02:03:56,720 --> 02:04:00,440
the new encoding behind it then we don't

02:03:59,360 --> 02:04:02,390
have to change all those drivers that

02:04:00,440 --> 02:04:04,370
are looking at thirties or other slices

02:04:02,390 --> 02:04:06,530
are looking at properties and then we

02:04:04,370 --> 02:04:08,450
can add as we need them functions that

02:04:06,530 --> 02:04:10,040
decode that new structure and it was

02:04:08,450 --> 02:04:11,660
asking if you've you saw any problems

02:04:10,040 --> 02:04:13,520
with that approach are you saying having

02:04:11,660 --> 02:04:16,130
static data in the function that it

02:04:13,520 --> 02:04:20,600
fills in and returns yeah okay we could

02:04:16,130 --> 02:04:22,520
do that yeah we've got scope problems by

02:04:20,600 --> 02:04:25,280
just got scoping problems that need to

02:04:22,520 --> 02:04:29,150
be solved yeah because live f TT has

02:04:25,280 --> 02:04:32,480
knows context context to work with it

02:04:29,150 --> 02:04:35,600
all so where do we how do we actually

02:04:32,480 --> 02:04:38,100
allocate that space to put to store that

02:04:35,600 --> 02:04:39,720
generated struct and we don't have a

02:04:38,100 --> 02:04:41,820
to do that without changing the model of

02:04:39,720 --> 02:04:43,410
live FTT i just want to point out the

02:04:41,820 --> 02:04:46,380
the comment that there aren't very many

02:04:43,410 --> 02:04:48,150
places to do that that we know of in the

02:04:46,380 --> 02:04:49,560
entry certainly but out of tree I'm not

02:04:48,150 --> 02:04:50,970
sure that we actually know the answer to

02:04:49,560 --> 02:04:52,980
that question

02:04:50,970 --> 02:04:55,530
okay well I'm I'm just making vendor

02:04:52,980 --> 02:04:58,830
kernels I mean from my experience and

02:04:55,530 --> 02:05:01,170
you vote getting that that get property

02:04:58,830 --> 02:05:02,370
thing is used for before when you have

02:05:01,170 --> 02:05:04,110
an offset and you're trying to iterate

02:05:02,370 --> 02:05:06,390
through the properties it's not a common

02:05:04,110 --> 02:05:08,880
thing that's normally in a few places it

02:05:06,390 --> 02:05:10,380
may be using entries that that we

02:05:08,880 --> 02:05:12,780
haven't looked at yet is all I'm saying

02:05:10,380 --> 02:05:14,700
it may be a much bigger problem than we

02:05:12,780 --> 02:05:18,510
think you mean out of tray I mean in

02:05:14,700 --> 02:05:21,990
other vendor trees okay yeah do they

02:05:18,510 --> 02:05:24,240
exist I was I'm saying good that it may

02:05:21,990 --> 02:05:25,620
be a bigger problem one other point I

02:05:24,240 --> 02:05:27,450
should make is that particular function

02:05:25,620 --> 02:05:29,100
there's already code in there that says

02:05:27,450 --> 02:05:30,870
if it's an old version I can tree what

02:05:29,100 --> 02:05:34,320
vision my vision 12 or something return

02:05:30,870 --> 02:05:37,640
null so I thought well does return null

02:05:34,320 --> 02:05:37,640
you know

02:05:43,070 --> 02:05:50,810
okay let me jump into overlays we can

02:05:45,540 --> 02:05:55,920
come back and talk more about format

02:05:50,810 --> 02:05:58,080
especially over lunch there's been

02:05:55,920 --> 02:06:00,090
recent support added to the device tree

02:05:58,080 --> 02:06:01,889
compiler to make overlays easier to deal

02:06:00,090 --> 02:06:04,560
with and the past people have had to

02:06:01,889 --> 02:06:05,580
hand code all that metadata things that

02:06:04,560 --> 02:06:08,699
people shouldn't have to worry about

02:06:05,580 --> 02:06:11,280
it's not it's not part of what what's

02:06:08,699 --> 02:06:14,040
your purview generally is creating the

02:06:11,280 --> 02:06:17,610
information so that helps solve some

02:06:14,040 --> 02:06:21,030
problems another recent change in that

02:06:17,610 --> 02:06:21,540
of in that tool tree is a new tool

02:06:21,030 --> 02:06:23,940
called

02:06:21,540 --> 02:06:26,190
fdt overlay written by ten tile Pantelis

02:06:23,940 --> 02:06:30,300
I've not looked at it I've not reviewed

02:06:26,190 --> 02:06:31,800
it we do not yet pull that into the

02:06:30,300 --> 02:06:34,770
kernel and compile it and build it in

02:06:31,800 --> 02:06:37,520
the kernel likely is gonna need some

02:06:34,770 --> 02:06:39,989
good review and and some thought about

02:06:37,520 --> 02:06:42,929
how can you apply you know how can you

02:06:39,989 --> 02:06:45,420
apply an overlay to a base device tree

02:06:42,929 --> 02:06:48,239
in the raw blob form before the

02:06:45,420 --> 02:06:51,060
bootloader sees it or the kernel sees it

02:06:48,239 --> 02:06:53,070
versus how do you apply an overlay in a

02:06:51,060 --> 02:06:55,139
bootloader versus how do you apply an

02:06:53,070 --> 02:06:57,300
overlay in a live device tree on a

02:06:55,139 --> 02:06:58,590
running kernel because the most

02:06:57,300 --> 02:07:00,780
restrictive environment is the live

02:06:58,590 --> 02:07:02,310
kernel environment they're just it just

02:07:00,780 --> 02:07:04,679
gets much more complex and much more

02:07:02,310 --> 02:07:07,530
difficult so it may be that the rules

02:07:04,679 --> 02:07:09,510
that this tool cannot can use are

02:07:07,530 --> 02:07:11,610
different than the rules in the kernel

02:07:09,510 --> 02:07:13,650
and we should be very clear about how to

02:07:11,610 --> 02:07:16,230
build your overlays free to use

02:07:13,650 --> 02:07:17,880
environment so it will work and if you

02:07:16,230 --> 02:07:22,199
want compatible through all three what

02:07:17,880 --> 02:07:26,940
are the rules for that you boot has the

02:07:22,199 --> 02:07:29,280
ability to apply overlays or load

02:07:26,940 --> 02:07:32,610
overlays now that's been around for a

02:07:29,280 --> 02:07:34,080
wild order to Simon how well does that

02:07:32,610 --> 02:07:40,050
work is it well supported it is a

02:07:34,080 --> 02:07:41,369
fantastic thump - thumbs up good this

02:07:40,050 --> 02:07:42,960
solves a lot of problems that I have

02:07:41,369 --> 02:07:45,150
with overlays rob has a good comment I

02:07:42,960 --> 02:07:48,840
think there's been an issue reported

02:07:45,150 --> 02:07:50,190
that you run out of space I'm not sure

02:07:48,840 --> 02:07:52,740
if that's just because you need to

02:07:50,190 --> 02:07:55,440
reserve more space in your

02:07:52,740 --> 02:07:58,050
basse DT or what the problem is there

02:07:55,440 --> 02:08:04,130
but some people are having problems with

02:07:58,050 --> 02:08:08,250
it okay and there's a test case at patch

02:08:04,130 --> 02:08:12,420
for DTC that's been posted from the st

02:08:08,250 --> 02:08:18,180
folks that have the problem that I was

02:08:12,420 --> 02:08:19,620
going to go look at okay I really like

02:08:18,180 --> 02:08:22,200
this approach because it solves a lot of

02:08:19,620 --> 02:08:23,550
the issues with run time if drivers are

02:08:22,200 --> 02:08:24,920
already loaded you're going to modify

02:08:23,550 --> 02:08:29,720
their data how do you deal with that

02:08:24,920 --> 02:08:31,950
what are the interactions if a subsystem

02:08:29,720 --> 02:08:33,360
looks at the device tree before you add

02:08:31,950 --> 02:08:37,680
the overlay then you add the overlay and

02:08:33,360 --> 02:08:39,390
later does the how well does the

02:08:37,680 --> 02:08:40,800
subsystem deal with that change in the

02:08:39,390 --> 02:08:42,870
data it's just a much more complex

02:08:40,800 --> 02:08:44,100
environment and those are things who

02:08:42,870 --> 02:08:46,290
have to deal with some type of updates

02:08:44,100 --> 02:08:51,150
but this avoids those and thinks a lot

02:08:46,290 --> 02:08:53,850
less fragile than live updates I accept

02:08:51,150 --> 02:08:55,770
a patch in about a almost release ago

02:08:53,850 --> 02:08:58,800
and it's been going through a whole

02:08:55,770 --> 02:08:59,940
bunch of testing and comments and

02:08:58,800 --> 02:09:02,910
reviews and it's gotten a lot better

02:08:59,940 --> 02:09:08,670
thanks to all those reviews and rob has

02:09:02,910 --> 02:09:10,860
done a pull on it for for 4.21 or 5.0

02:09:08,670 --> 02:09:12,390
whatever it turns out to be assuming it

02:09:10,860 --> 02:09:12,870
goes through next and people are happy

02:09:12,390 --> 02:09:16,380
with it

02:09:12,870 --> 02:09:19,020
FPGA people have been testing it IBM has

02:09:16,380 --> 02:09:23,820
tested it so hopefully we've got mostly

02:09:19,020 --> 02:09:26,610
issues dealt with the the moment the

02:09:23,820 --> 02:09:27,960
reason I behind this patch was avoiding

02:09:26,610 --> 02:09:31,310
memory leaks which has been one of my

02:09:27,960 --> 02:09:34,980
bug booths with overlays and secondly

02:09:31,310 --> 02:09:37,590
dump to a Kay free before you actually

02:09:34,980 --> 02:09:40,980
have removed an overlay so you're not

02:09:37,590 --> 02:09:42,990
getting the use after free issues and

02:09:40,980 --> 02:09:45,540
this doesn't entirely solve use after

02:09:42,990 --> 02:09:47,330
free there's still may be cases where

02:09:45,540 --> 02:09:50,310
you removing overlay and a driver still

02:09:47,330 --> 02:09:51,420
thinks it has a valid pointer but but

02:09:50,310 --> 02:09:53,850
this is helping to catch some of those

02:09:51,420 --> 02:09:55,620
issues and it ends up being code spread

02:09:53,850 --> 02:09:58,250
throughout various parts of the kernel

02:09:55,620 --> 02:09:58,250
to deal with it

02:09:59,540 --> 02:10:04,830
the intent right now is to not break

02:10:02,790 --> 02:10:07,440
existing overlays if you can load an

02:10:04,830 --> 02:10:09,630
overlay in the existing kernel it'll

02:10:07,440 --> 02:10:12,120
still work even with these checks it

02:10:09,630 --> 02:10:15,470
will give you warnings so you can start

02:10:12,120 --> 02:10:18,510
dealing with those issues but it will

02:10:15,470 --> 02:10:21,750
find a few cases where the current

02:10:18,510 --> 02:10:24,450
device tree might be not actually a

02:10:21,750 --> 02:10:27,270
valid device tree once you've loaded the

02:10:24,450 --> 02:10:29,820
overlay the classic example is somehow

02:10:27,270 --> 02:10:34,410
you end up with two instances of adding

02:10:29,820 --> 02:10:36,180
the same node and when the apply code

02:10:34,410 --> 02:10:38,670
tries to add the second instance it sees

02:10:36,180 --> 02:10:39,570
the same collision and it renames it so

02:10:38,670 --> 02:10:41,340
now all of a sudden you have an

02:10:39,570 --> 02:10:43,110
unexpected name with node with a new

02:10:41,340 --> 02:10:45,360
name the same with properties that same

02:10:43,110 --> 02:10:48,480
result can happen and that's been a

02:10:45,360 --> 02:10:50,100
silent problem and you would only see

02:10:48,480 --> 02:10:52,290
that if you tried to access that data

02:10:50,100 --> 02:10:54,300
and got the wrong value yeah where's the

02:10:52,290 --> 02:10:58,080
hesitation and just making it fail to

02:10:54,300 --> 02:10:59,940
apply it is I mean it seems to mean like

02:10:58,080 --> 02:11:04,080
my only time it would fail to apply it's

02:10:59,940 --> 02:11:05,730
gonna be toxic right the issues the

02:11:04,080 --> 02:11:09,270
warnings are warning of two things one

02:11:05,730 --> 02:11:11,280
is warning that it's going to apply

02:11:09,270 --> 02:11:13,560
successfully and there's no problem

02:11:11,280 --> 02:11:17,100
right now when you go and remove it

02:11:13,560 --> 02:11:19,260
there's gonna be a memory leak so if

02:11:17,100 --> 02:11:21,240
you're applying and moving applying

02:11:19,260 --> 02:11:23,490
removing applying removing millions of

02:11:21,240 --> 02:11:25,170
times that becomes an issue for you

02:11:23,490 --> 02:11:26,310
that's an issue right now and the

02:11:25,170 --> 02:11:28,880
current kernel is used on what was

02:11:26,310 --> 02:11:31,950
happening so this is giving you time to

02:11:28,880 --> 02:11:35,610
not break your existing systems but

02:11:31,950 --> 02:11:41,070
correct your problems the other problem

02:11:35,610 --> 02:11:43,170
would be if you don't actually bring

02:11:41,070 --> 02:11:45,810
your reference counts low enough to 2k

02:11:43,170 --> 02:11:48,480
for you and again in that you'll find

02:11:45,810 --> 02:11:50,130
out when you're you're releasing the

02:11:48,480 --> 02:11:51,600
overlay you won't know that when you're

02:11:50,130 --> 02:11:53,490
applying it so again you have a memory

02:11:51,600 --> 02:11:55,820
leak to use in memory so maybe I'm a

02:11:53,490 --> 02:11:59,220
little naive in this but if you allow a

02:11:55,820 --> 02:12:01,230
potential memory leak you're creating an

02:11:59,220 --> 02:12:03,780
opportunity for very subtle bugs as

02:12:01,230 --> 02:12:07,530
opposed to forcing a development with

02:12:03,780 --> 02:12:09,219
this with a failure case it's a denial

02:12:07,530 --> 02:12:14,410
of service attack potentially

02:12:09,219 --> 02:12:16,750
what sort of okay yeah so long I don't

02:12:14,410 --> 02:12:19,510
want that to remain too long but the

02:12:16,750 --> 02:12:22,449
idea is to give people time to realize

02:12:19,510 --> 02:12:24,460
they have an issue and start coding for

02:12:22,449 --> 02:12:26,140
it and this is gonna evolved it got me

02:12:24,460 --> 02:12:28,239
more issues coming up I think we just

02:12:26,140 --> 02:12:30,520
learn more yeah yeah I mean often also

02:12:28,239 --> 02:12:33,000
the actual issues and like random driver

02:12:30,520 --> 02:12:36,310
code I wasn't aware of full release so

02:12:33,000 --> 02:12:38,199
it will take some time to sort of find

02:12:36,310 --> 02:12:40,239
all the all of them and fix them so I

02:12:38,199 --> 02:12:42,940
think it's a good approach you sort of

02:12:40,239 --> 02:12:44,110
warn and then and then yeah yeah yeah it

02:12:42,940 --> 02:12:46,330
might not be in the code that you own

02:12:44,110 --> 02:12:51,180
like the example found was in the clock

02:12:46,330 --> 02:12:51,180
code so it's - may have to fix that

02:12:55,320 --> 02:12:59,840
unit-tests has a whole lot of warnings

02:12:57,360 --> 02:13:01,980
and errors now just be expecting those

02:12:59,840 --> 02:13:03,870
since I'm running short I'm not kind of

02:13:01,980 --> 02:13:06,030
going through in details of these but if

02:13:03,870 --> 02:13:08,910
anyone wants to understand what causes

02:13:06,030 --> 02:13:11,580
these two these messages I'm willing to

02:13:08,910 --> 02:13:13,590
sit down and if we could grab in another

02:13:11,580 --> 02:13:16,560
room at some point this week and walk

02:13:13,590 --> 02:13:18,450
through these or if at the end of the

02:13:16,560 --> 02:13:22,700
the entire track if we still have time

02:13:18,450 --> 02:13:29,310
left I can come back to this yeah okay

02:13:22,700 --> 02:13:31,739
they're there said of applying accessing

02:13:29,310 --> 02:13:34,050
and removing messages and I do listen to

02:13:31,739 --> 02:13:36,870
cos here hopefully it's not too cryptic

02:13:34,050 --> 02:13:39,690
if you read the slides this is the

02:13:36,870 --> 02:13:41,550
example where I said you have an overlay

02:13:39,690 --> 02:13:42,870
that you think is valid when you go to

02:13:41,550 --> 02:13:44,430
apply it you're getting this problem

02:13:42,870 --> 02:13:48,570
where you have a name collision and

02:13:44,430 --> 02:13:49,980
corruption and that's been pretty much

02:13:48,570 --> 02:13:52,620
invisible unless you actually looked at

02:13:49,980 --> 02:13:55,380
the underlying data or looked at what

02:13:52,620 --> 02:13:57,870
nodes existed in /proc slash device tree

02:13:55,380 --> 02:14:00,239
and property names there was a warning

02:13:57,870 --> 02:14:01,770
message on the console I don't know how

02:14:00,239 --> 02:14:06,350
many people look at their consoles for

02:14:01,770 --> 02:14:06,350
warning messages when loading overlays

02:14:07,100 --> 02:14:13,739
these are the unit test device resources

02:14:11,760 --> 02:14:15,270
that were used to create some of those

02:14:13,739 --> 02:14:18,060
warnings and errors so you can see

02:14:15,270 --> 02:14:20,070
examples of how to what the bad patterns

02:14:18,060 --> 02:14:22,230
are that will cause those problems again

02:14:20,070 --> 02:14:24,750
these are for reference and then there's

02:14:22,230 --> 02:14:26,310
one more class of errors these are we

02:14:24,750 --> 02:14:29,070
did something wrong in our internal

02:14:26,310 --> 02:14:31,260
coding in the court of ice tree and one

02:14:29,070 --> 02:14:32,700
who went to remove things the data

02:14:31,260 --> 02:14:35,760
structure didn't look like what we

02:14:32,700 --> 02:14:37,800
expected so that means that internally

02:14:35,760 --> 02:14:39,900
in our overlay overlay apply and remove

02:14:37,800 --> 02:14:42,030
code we've got a bug somewhere so it's

02:14:39,900 --> 02:14:44,930
not a problem with your overlay that's

02:14:42,030 --> 02:14:44,930
this message

02:14:49,320 --> 02:14:54,720
okay we've talked about this before this

02:14:51,270 --> 02:14:56,820
the size issues one thing I keep seeing

02:14:54,720 --> 02:14:59,040
slides in presentations and current

02:14:56,820 --> 02:15:02,790
conferences which are showing people how

02:14:59,040 --> 02:15:05,280
to hand code device resource files with

02:15:02,790 --> 02:15:08,970
the metadata hand coded the overlays the

02:15:05,280 --> 02:15:11,250
fragments usually not to fix ups local

02:15:08,970 --> 02:15:12,600
fix ups and symbols they usually don't

02:15:11,250 --> 02:15:13,620
hand code those but there's still some

02:15:12,600 --> 02:15:15,210
examples of that

02:15:13,620 --> 02:15:18,180
so I'm really trying to get the message

02:15:15,210 --> 02:15:20,040
out don't hand code those things just

02:15:18,180 --> 02:15:22,980
start using so this example of hand

02:15:20,040 --> 02:15:26,040
coded fragment all those colored stuff

02:15:22,980 --> 02:15:27,630
is essentially metadata which we used to

02:15:26,040 --> 02:15:29,430
have to hand code before the compiler

02:15:27,630 --> 02:15:32,100
knew how to deal with automatically

02:15:29,430 --> 02:15:36,990
creating it so all that color stuff gets

02:15:32,100 --> 02:15:39,900
replaced with a simple P handle

02:15:36,990 --> 02:15:41,880
reference and the device tree compiler

02:15:39,900 --> 02:15:44,910
now creates all that extra metadata

02:15:41,880 --> 02:15:47,100
stuff for you so please get the word out

02:15:44,910 --> 02:15:53,040
to people quit hand coding that stuff

02:15:47,100 --> 02:15:56,690
just use the magic and these are just

02:15:53,040 --> 02:16:00,300
more details about that issues issues I

02:15:56,690 --> 02:16:02,640
think we can skip all this yeah okay

02:16:00,300 --> 02:16:11,280
back to questions more questions on this

02:16:02,640 --> 02:16:13,500
I think I have three minutes on the the

02:16:11,280 --> 02:16:14,850
class of metadata that you're trying to

02:16:13,500 --> 02:16:21,680
get the word out have we considered

02:16:14,850 --> 02:16:26,190
adding warnings to DTC

02:16:21,680 --> 02:16:28,680
what I would like to do is to add a

02:16:26,190 --> 02:16:30,180
command line flag to DTC it's gotta be

02:16:28,680 --> 02:16:33,599
one of two possible ways of approaching

02:16:30,180 --> 02:16:35,490
it one is saying I will not compile I

02:16:33,599 --> 02:16:39,630
will not consider this valid source

02:16:35,490 --> 02:16:42,570
format unless you apply this flag so

02:16:39,630 --> 02:16:44,520
it's a flag saying I'm going to build a

02:16:42,570 --> 02:16:45,059
lot but otherwise being invalid DTC or

02:16:44,520 --> 02:16:48,870
DTS

02:16:45,059 --> 02:16:51,760
the opposite approach would be the

02:16:48,870 --> 02:16:55,220
opposite of that what did I just say

02:16:51,760 --> 02:16:56,750
either saying like that either allowing

02:16:55,220 --> 02:16:58,131
or prohibiting right way or the other

02:16:56,750 --> 02:17:01,250
and the default would be the opposite of

02:16:58,131 --> 02:17:03,171
what the flag would do the the nice

02:17:01,250 --> 02:17:06,260
thing about having the default being

02:17:03,171 --> 02:17:08,990
prohibiting this is valid source is that

02:17:06,260 --> 02:17:11,150
you warn a whole lot of people who know

02:17:08,990 --> 02:17:12,591
nothing about this they go and use the

02:17:11,150 --> 02:17:14,780
next version the tool all of a sudden

02:17:12,591 --> 02:17:16,700
they have this warning spewed and

02:17:14,780 --> 02:17:18,921
hopefully the warning says oh by the way

02:17:16,700 --> 02:17:21,171
you can temporarily use this compile

02:17:18,921 --> 02:17:24,080
flag take a per year old device tree but

02:17:21,171 --> 02:17:25,640
convert it to the new format that's kind

02:17:24,080 --> 02:17:29,020
of probably upset a whole lot of people

02:17:25,640 --> 02:17:30,950
so I don't know what the overall

02:17:29,020 --> 02:17:33,680
decision-makers who decide which way to

02:17:30,950 --> 02:17:36,110
do the flags will decide but I think

02:17:33,680 --> 02:17:37,131
that would be the way to approach it the

02:17:36,110 --> 02:17:39,560
obvious questions here the

02:17:37,131 --> 02:17:43,490
decision-makers david gives us the

02:17:39,560 --> 02:17:46,310
decision maker on this so we need to buy

02:17:43,490 --> 02:17:47,841
him beers yeah yeah and David's in

02:17:46,310 --> 02:17:52,341
Australia this week he's not here he was

02:17:47,841 --> 02:17:53,990
unable to make it yeah I think from your

02:17:52,341 --> 02:17:56,841
slides earlier I've just discovered a

02:17:53,990 --> 02:17:58,131
tool called fdt overlay is that correct

02:17:56,841 --> 02:17:59,720
what's the current state of being able

02:17:58,131 --> 02:18:03,500
to apply overlays from a use running

02:17:59,720 --> 02:18:05,570
kernel yeah I think so yeah do we have

02:18:03,500 --> 02:18:09,410
do I have a current means to apply

02:18:05,570 --> 02:18:11,360
overlays overlays from user space for a

02:18:09,410 --> 02:18:15,890
running kernel right from a running

02:18:11,360 --> 02:18:17,870
kernel no that's fine as long as you've

02:18:15,890 --> 02:18:20,870
got medicine there's there's an issue

02:18:17,870 --> 02:18:23,750
there and if you look at my slides I

02:18:20,870 --> 02:18:26,870
actually have a page on the e Linux wiki

02:18:23,750 --> 02:18:29,091
saying kind of my observations on what

02:18:26,870 --> 02:18:30,830
we need to resolve to get to the point

02:18:29,091 --> 02:18:33,051
where we can do that and I think we can

02:18:30,830 --> 02:18:36,320
face it in so for instance we might be

02:18:33,051 --> 02:18:38,180
able to do applies and if you do it only

02:18:36,320 --> 02:18:40,100
applies and no removes you can ignore

02:18:38,180 --> 02:18:42,200
all the memory leak issues because

02:18:40,100 --> 02:18:43,490
memory leak issues coming you remove so

02:18:42,200 --> 02:18:46,341
there might be stages we're gonna start

02:18:43,490 --> 02:18:48,440
phasing in more and more support but

02:18:46,341 --> 02:18:51,110
there's that there's locking is a really

02:18:48,440 --> 02:18:53,150
big issue use after free and those are

02:18:51,110 --> 02:18:56,421
things that I want to deal with before

02:18:53,150 --> 02:18:58,070
we get widespread use of overlays fbas

02:18:56,421 --> 02:19:00,810
are using I mean there's patches and

02:18:58,070 --> 02:19:04,020
trees that people are using and

02:19:00,810 --> 02:19:07,591
no one's submit some upstream and they

02:19:04,020 --> 02:19:09,841
were at one point and we can keep

02:19:07,591 --> 02:19:11,760
changing the kernel api's and keep

02:19:09,841 --> 02:19:14,461
breaking them and maybe it'll get

02:19:11,760 --> 02:19:17,100
annoyed enough to upstream it yeah but

02:19:14,461 --> 02:19:20,220
but I don't want to accept the overlay

02:19:17,100 --> 02:19:22,410
application code until we have a valid

02:19:20,220 --> 02:19:24,510
foundation that it can work on it worked

02:19:22,410 --> 02:19:26,190
great for single use cases their

02:19:24,510 --> 02:19:28,591
communities have single boards the

02:19:26,190 --> 02:19:30,780
overlays work on those boards but they

02:19:28,591 --> 02:19:33,180
don't handle the general cases they open

02:19:30,780 --> 02:19:35,370
all these windows or problems I want to

02:19:33,180 --> 02:19:38,400
get rid of as many of those problems as

02:19:35,370 --> 02:19:40,381
we can and it becomes a risk-benefit

02:19:38,400 --> 02:19:43,860
point where the problems are small

02:19:40,381 --> 02:19:45,900
enough you can accept the risk of adding

02:19:43,860 --> 02:19:48,030
that functionality so we'll be walking

02:19:45,900 --> 02:19:50,251
into that a bit at a time I think the

02:19:48,030 --> 02:19:52,891
other question back at you is what's

02:19:50,251 --> 02:19:55,080
your use case that can't be solved by

02:19:52,891 --> 02:19:59,490
applying it in the bootloader cuz that

02:19:55,080 --> 02:20:01,200
solves a lot of them yes thank you

02:19:59,490 --> 02:20:06,030
bootloader people very much for that

02:20:01,200 --> 02:20:07,051
we've got a multi-camera system and one

02:20:06,030 --> 02:20:08,730
of the things we're looking at is fault

02:20:07,051 --> 02:20:10,620
tolerance of how when one of those

02:20:08,730 --> 02:20:13,051
devices breaks or you can detect this

02:20:10,620 --> 02:20:15,391
fit broken oh you might want to change

02:20:13,051 --> 02:20:17,761
what physical device it's got a cable so

02:20:15,391 --> 02:20:21,690
you might be able to unplug it we want

02:20:17,761 --> 02:20:26,160
oh I am envisaging how do i at runtime

02:20:21,690 --> 02:20:27,780
say I now have an RDA ACM 20 connected

02:20:26,160 --> 02:20:30,330
and altima pile overlay that says that's

02:20:27,780 --> 02:20:33,541
physically connected or it's a 21 or 22

02:20:30,330 --> 02:20:35,041
I need to describe that at runtime and

02:20:33,541 --> 02:20:38,211
then overlay would do that but I don't

02:20:35,041 --> 02:20:41,251
have a means of doing it and say all

02:20:38,211 --> 02:20:43,801
right I think we're gonna maybe come

02:20:41,251 --> 02:20:51,591
back to that topic Marissa is going to

02:20:43,801 --> 02:20:51,591
talk about FPGA device tree okay

02:20:52,440 --> 02:21:06,410
I I know I'd test good

02:21:08,240 --> 02:21:21,920
all right well no Thurman all right

02:21:16,700 --> 02:21:25,670
better I'll make this weird might look a

02:21:21,920 --> 02:21:28,880
bit funny an idea but I'll just hold it

02:21:25,670 --> 02:21:30,710
so yeah my name is Morris Fisher I work

02:21:28,880 --> 02:21:32,570
for National Instruments the other

02:21:30,710 --> 02:21:35,590
co-presenter that unfortunately couldn't

02:21:32,570 --> 02:21:38,420
be here is Alan tell works at int'l and

02:21:35,590 --> 02:21:41,930
together we maintained if PJ managers

02:21:38,420 --> 02:21:44,630
framework probably most of the people

02:21:41,930 --> 02:21:46,190
have heard already a bit about FPGAs I

02:21:44,630 --> 02:21:48,170
just want to you know give a brief

02:21:46,190 --> 02:21:50,540
overview of the problem statement that

02:21:48,170 --> 02:21:53,479
we set out to solve Becky back in the

02:21:50,540 --> 02:21:55,550
days if PJ's are basically hardware that

02:21:53,479 --> 02:21:58,250
can be reconfigured at runtime to be

02:21:55,550 --> 02:22:01,250
whatever your RTL skills allow you to do

02:21:58,250 --> 02:22:03,290
and they're little to no restrictions to

02:22:01,250 --> 02:22:06,920
what can be implemented inside of the

02:22:03,290 --> 02:22:08,600
FPGA depending on your setup you either

02:22:06,920 --> 02:22:10,970
want to you know reconfigure the full

02:22:08,600 --> 02:22:13,040
FPGA which is what we call full

02:22:10,970 --> 02:22:14,660
reconfiguration or just a part which is

02:22:13,040 --> 02:22:16,400
you know if you have a bus attached like

02:22:14,660 --> 02:22:18,380
PCI Express you want to keep the link up

02:22:16,400 --> 02:22:20,390
you only want to reprogram things that

02:22:18,380 --> 02:22:23,630
are behind that bus it's just like an

02:22:20,390 --> 02:22:25,420
intro to what's gonna come in and

02:22:23,630 --> 02:22:29,690
exlights

02:22:25,420 --> 02:22:31,580
yeah basically when you program that

02:22:29,690 --> 02:22:34,490
FPGA you'll end up with a lot of new

02:22:31,580 --> 02:22:37,180
devices that show up or you know if your

02:22:34,490 --> 02:22:40,010
runtime reprogram it might go away and

02:22:37,180 --> 02:22:42,260
you know FPGA manager sort of gives you

02:22:40,010 --> 02:22:44,930
a framework at several levels of

02:22:42,260 --> 02:22:48,740
abstraction to deal with this and the

02:22:44,930 --> 02:22:50,330
actors we have there is basically we

02:22:48,740 --> 02:22:51,860
have an FPGA manager which is the

02:22:50,330 --> 02:22:55,820
low-level driver that deals with

02:22:51,860 --> 02:22:58,160
actually programming the FPGA they would

02:22:55,820 --> 02:23:02,570
have a region that represents a part of

02:22:58,160 --> 02:23:05,960
it of an FPGA or a full FPGA if you do a

02:23:02,570 --> 02:23:07,790
full reconfiguration and FPGA regions

02:23:05,960 --> 02:23:10,910
sometimes you know need to be isolated

02:23:07,790 --> 02:23:12,229
when you reprogram stuff and you know

02:23:10,910 --> 02:23:15,320
I'm doing all this sort of as a

02:23:12,229 --> 02:23:16,891
reference we'll talk about open problems

02:23:15,320 --> 02:23:19,160
a bit later in India

02:23:16,891 --> 02:23:21,591
they have like 10 slides so not too many

02:23:19,160 --> 02:23:24,511
there's a bunch of info on those links

02:23:21,591 --> 02:23:27,660
letter one is our current driver API in

02:23:24,511 --> 02:23:29,880
the upstream kernel and then there's

02:23:27,660 --> 02:23:33,271
Alan's talk that introduces the whole

02:23:29,880 --> 02:23:38,311
thing in a bit more detail well so how

02:23:33,271 --> 02:23:41,160
does DT fit in there well most FPGA

02:23:38,311 --> 02:23:44,280
designs use some sort of fundamentally

02:23:41,160 --> 02:23:47,880
non disco robust like spy I squid see or

02:23:44,280 --> 02:23:50,221
just plain memory mapped i/o DT is made

02:23:47,880 --> 02:23:53,521
to describe non discoverable hardware

02:23:50,221 --> 02:23:57,660
and DT code largely assumes a static

02:23:53,521 --> 02:24:00,021
device tree you know DT overlays were

02:23:57,660 --> 02:24:02,670
introduced to allow runtime changes and

02:24:00,021 --> 02:24:05,221
when we first started out with FPGA

02:24:02,670 --> 02:24:08,160
manager we thought that's you know a

02:24:05,221 --> 02:24:10,530
real good fit for the use case we have

02:24:08,160 --> 02:24:12,330
where hardware changes runtime the

02:24:10,530 --> 02:24:16,290
hardware is not discoverable so we're

02:24:12,330 --> 02:24:19,261
gonna use device tree overlays the

02:24:16,290 --> 02:24:22,920
problem most DT code in the kernel

02:24:19,261 --> 02:24:26,610
predates overlays and not all places

02:24:22,920 --> 02:24:28,471
where you could apply an overlay you

02:24:26,610 --> 02:24:32,070
know not all of them deal well with it

02:24:28,471 --> 02:24:36,120
as we discussed in Frank's talk just

02:24:32,070 --> 02:24:38,460
before as a result of that as of 419 420

02:24:36,120 --> 02:24:41,181
- we don't really have a workable user

02:24:38,460 --> 02:24:44,610
space interface for DT based systems or

02:24:41,181 --> 02:24:48,360
PCI Express we sort of figured it out or

02:24:44,610 --> 02:24:51,440
Intel did for us for device tree based

02:24:48,360 --> 02:24:55,521
systems we don't really have a way to to

02:24:51,440 --> 02:24:58,261
using upstream code to deal with FPGAs

02:24:55,521 --> 02:25:00,780
here's an example and totally guilty I

02:24:58,261 --> 02:25:03,511
think with the overlay no actually not

02:25:00,780 --> 02:25:06,290
oh not guilty of what friend said about

02:25:03,511 --> 02:25:06,290
the syntax

02:25:07,230 --> 02:25:11,711
basically again what I said before

02:25:09,851 --> 02:25:13,450
usually your system looks somewhat lay

02:25:11,711 --> 02:25:15,160
you have an FBI manager that's in charge

02:25:13,450 --> 02:25:17,290
of reprogramming things you have the

02:25:15,160 --> 02:25:22,391
bridge that isolates your region you

02:25:17,290 --> 02:25:24,341
have a point you have a region and that

02:25:22,391 --> 02:25:26,771
region might have a list of bridges that

02:25:24,341 --> 02:25:28,841
you need to use to isolate your region

02:25:26,771 --> 02:25:32,021
during reprogramming you play the

02:25:28,841 --> 02:25:34,750
overlay you know you specify a firmware

02:25:32,021 --> 02:25:38,551
name which will basically contain your

02:25:34,750 --> 02:25:40,780
bit stream we use the Linux internal

02:25:38,551 --> 02:25:43,150
firmware subsystem to load stuff from

02:25:40,780 --> 02:25:46,000
look firmware and then your new notes

02:25:43,150 --> 02:25:48,280
show up and we do know if populates I'll

02:25:46,000 --> 02:25:50,620
go into details on the next slide a bit

02:25:48,280 --> 02:25:53,051
further one thing to note is we also

02:25:50,620 --> 02:25:55,061
have certain properties like for a more

02:25:53,051 --> 02:25:57,070
named that RFP day manager specific that

02:25:55,061 --> 02:26:00,400
we parse on application so there might

02:25:57,070 --> 02:26:01,990
be stuff like encryption compression and

02:26:00,400 --> 02:26:04,330
those kind of things that would also be

02:26:01,990 --> 02:26:10,301
there and we parse those out when we're

02:26:04,330 --> 02:26:12,610
notified of reconfiguration yeah so a

02:26:10,301 --> 02:26:16,091
bit more detail what happens if you call

02:26:12,610 --> 02:26:19,690
the o of overlay apply that calls over

02:26:16,091 --> 02:26:22,721
line notify which then you know has a

02:26:19,690 --> 02:26:26,440
notifier blocking notifier eventually

02:26:22,721 --> 02:26:28,601
that gets to your FPGA region at that

02:26:26,440 --> 02:26:30,580
point we look at what's in the overlay

02:26:28,601 --> 02:26:34,480
that's being presented to us like the

02:26:30,580 --> 02:26:36,820
firmware name or other properties as I

02:26:34,480 --> 02:26:40,211
mentioned like encryption things like

02:26:36,820 --> 02:26:42,551
that we program the FPGA if then the

02:26:40,211 --> 02:26:44,290
low-level driver says yep your FPGA is

02:26:42,551 --> 02:26:47,110
up and running again and that all worked

02:26:44,290 --> 02:26:50,320
out then the overlay goes into the life

02:26:47,110 --> 02:26:52,870
tree there's more information about the

02:26:50,320 --> 02:26:54,971
binding you can find it here and this

02:26:52,870 --> 02:26:57,671
was sort of our original plan right I

02:26:54,971 --> 02:27:00,250
had sounds all very clean and nice

02:26:57,671 --> 02:27:04,480
because you know it seemed like the

02:27:00,250 --> 02:27:06,580
match made in heaven but I skipped over

02:27:04,480 --> 02:27:09,221
the part of how does the DT overlay get

02:27:06,580 --> 02:27:11,100
into the kernel in the first place so a

02:27:09,221 --> 02:27:13,500
lot of people told me just

02:27:11,100 --> 02:27:16,680
this basically you know make your

02:27:13,500 --> 02:27:19,409
hardware discoverable that has two

02:27:16,680 --> 02:27:22,409
drawbacks block RAM is usually a scarce

02:27:19,409 --> 02:27:24,750
resource in an FPGA that would be where

02:27:22,409 --> 02:27:27,960
after synthesizing the hardware your

02:27:24,750 --> 02:27:30,420
stuff ends up in FPGA block RAM so that

02:27:27,960 --> 02:27:33,210
didn't really work out and also doesn't

02:27:30,420 --> 02:27:35,220
work for all their pj designs there's a

02:27:33,210 --> 02:27:39,000
lot of people that just have systems out

02:27:35,220 --> 02:27:41,069
there and kind of saying that it's like

02:27:39,000 --> 02:27:43,189
telling people that have a spy device Oh

02:27:41,069 --> 02:27:46,290
too bad you should have made it USB no

02:27:43,189 --> 02:27:49,229
and then it will just work so that

02:27:46,290 --> 02:27:51,510
really didn't work for us Aunt Alice had

02:27:49,229 --> 02:27:54,350
an idea with the config FS interface

02:27:51,510 --> 02:27:57,060
that went through seven revisions but

02:27:54,350 --> 02:27:59,270
that was a generic solution that was not

02:27:57,060 --> 02:28:01,770
just for SDK manager

02:27:59,270 --> 02:28:03,390
Garrett somewhat maintains that in

02:28:01,770 --> 02:28:08,040
history I have to link there just for

02:28:03,390 --> 02:28:10,979
people in case they needed it's widely

02:28:08,040 --> 02:28:13,020
used actually so widely that our

02:28:10,979 --> 02:28:15,180
products and that we ship also used that

02:28:13,020 --> 02:28:18,090
because I needed something quick on it

02:28:15,180 --> 02:28:20,699
whenever I do things to break this

02:28:18,090 --> 02:28:22,890
interface I make sure that geertz see

02:28:20,699 --> 02:28:26,609
seed on the patch and make sure that he

02:28:22,890 --> 02:28:30,720
tests it so he definitely he will gate

02:28:26,609 --> 02:28:32,489
me if I do something to break this it's

02:28:30,720 --> 02:28:34,619
widely used so widely that basically

02:28:32,489 --> 02:28:36,449
last time I updated our kernel for our

02:28:34,619 --> 02:28:38,609
production systems basically my patch

02:28:36,449 --> 02:28:40,880
didn't apply and I realized that the

02:28:38,609 --> 02:28:44,790
Yocto kernel already applied that patch

02:28:40,880 --> 02:28:46,470
in their kernel tree there's discussion

02:28:44,790 --> 02:28:48,569
around why that's not a good idea and

02:28:46,470 --> 02:28:49,819
Frank pointed out a bunch of those

02:28:48,569 --> 02:28:53,580
before

02:28:49,819 --> 02:28:55,439
there's also references down here fir

02:28:53,580 --> 02:28:58,590
goes that want to go back in history and

02:28:55,439 --> 02:29:00,300
look at white I wasn't a good idea it

02:28:58,590 --> 02:29:02,640
boils down to as Frank said a lot of

02:29:00,300 --> 02:29:06,449
things break miserably if you buy

02:29:02,640 --> 02:29:11,970
overlays to them and you know that just

02:29:06,449 --> 02:29:14,189
doesn't work so then we had ideas you

02:29:11,970 --> 02:29:16,330
know we discovered we can't just apply

02:29:14,189 --> 02:29:19,960
things anywhere and things

02:29:16,330 --> 02:29:23,170
we'll work so what if we lock down where

02:29:19,960 --> 02:29:27,130
we apply overlays and allow only in

02:29:23,170 --> 02:29:30,250
certain areas as pointed out Allen had

02:29:27,130 --> 02:29:32,319
an RFC where he basically implemented

02:29:30,250 --> 02:29:33,970
the whitelist and the D key core where

02:29:32,319 --> 02:29:38,530
the driver would say hey can deal with

02:29:33,970 --> 02:29:40,840
overlays feedback we got from Robin

02:29:38,530 --> 02:29:44,890
Frank was mostly around the actual

02:29:40,840 --> 02:29:47,560
implementation Ellen had used a link

02:29:44,890 --> 02:29:49,270
list then it was proposed to actually

02:29:47,560 --> 02:29:51,760
use a flag in your node as opposed to

02:29:49,270 --> 02:29:55,569
you know actually having a list which

02:29:51,760 --> 02:29:57,340
would be more efficient and Frank

02:29:55,569 --> 02:30:01,359
finally said we'll just use DT

02:29:57,340 --> 02:30:03,640
connectors and there's an RFC I have the

02:30:01,359 --> 02:30:05,710
links down there there were a bunch of

02:30:03,640 --> 02:30:06,910
presentations so I sort of collected a

02:30:05,710 --> 02:30:09,970
lot of things for people that are

02:30:06,910 --> 02:30:13,420
interested later to see where we were at

02:30:09,970 --> 02:30:14,979
at this point in time the there's emails

02:30:13,420 --> 02:30:18,370
from Frank that sort of state the

02:30:14,979 --> 02:30:21,310
general problem of device tree

02:30:18,370 --> 02:30:24,370
connectors at this point I'm not

02:30:21,310 --> 02:30:26,260
entirely sure neither allenbury could

02:30:24,370 --> 02:30:29,069
figure out like where we're at exactly

02:30:26,260 --> 02:30:31,450
with device tree connectors right now

02:30:29,069 --> 02:30:33,040
most discussions I found on the list

02:30:31,450 --> 02:30:35,470
were around the actual implementation

02:30:33,040 --> 02:30:38,950
and how you know tooling device tree

02:30:35,470 --> 02:30:42,250
compiler and yeah it seemed very

02:30:38,950 --> 02:30:44,510
conceptual at this stage am I

02:30:42,250 --> 02:30:48,700
you're right it's been discussed but

02:30:44,510 --> 02:30:48,700
nowhere near a solid implementation yet

02:30:49,090 --> 02:30:56,000
things I would like to discuss basically

02:30:52,700 --> 02:30:58,490
the first one is white listing for DT

02:30:56,000 --> 02:31:01,490
overlays said something we could maybe

02:30:58,490 --> 02:31:04,580
as an intermediate term solution

02:31:01,490 --> 02:31:10,100
look at assuming we fix up the

02:31:04,580 --> 02:31:15,530
implementation can we salvage the RFC

02:31:10,100 --> 02:31:17,960
that I would add some what that would

02:31:15,530 --> 02:31:19,970
basically boiled down to drivers saying

02:31:17,960 --> 02:31:24,650
or subsystems saying I can deal with

02:31:19,970 --> 02:31:28,490
overlays or the other option would be

02:31:24,650 --> 02:31:32,560
now looking at connectors for FPGAs and

02:31:28,490 --> 02:31:35,330
that I discussed a bit with Alan on debt

02:31:32,560 --> 02:31:37,940
in general it seemed like there's some

02:31:35,330 --> 02:31:41,840
progress on the GPIO side with the GPIO

02:31:37,940 --> 02:31:43,370
Nexus bindings moving forward but other

02:31:41,840 --> 02:31:46,360
than that were weren't clear and who's

02:31:43,370 --> 02:31:48,890
working on that it seemed like

02:31:46,360 --> 02:31:53,360
conceptually it would work for FPGA

02:31:48,890 --> 02:31:55,130
manager but it also seems from our point

02:31:53,360 --> 02:31:57,320
of view that since you can have

02:31:55,130 --> 02:32:00,800
arbitrary buses with almost anything in

02:31:57,320 --> 02:32:04,310
it okay it's some somehow like the least

02:32:00,800 --> 02:32:06,890
beneficial like FPGAs would be the least

02:32:04,310 --> 02:32:10,630
beneficial user of connectors because

02:32:06,890 --> 02:32:14,780
we'd have to sort of fix all possible

02:32:10,630 --> 02:32:18,740
connector rights plugins before we can

02:32:14,780 --> 02:32:22,180
start using it and yeah so I was

02:32:18,740 --> 02:32:22,180
wondering if people have ideas on that

02:32:29,710 --> 02:32:36,939
so I've probably historically been the

02:32:34,330 --> 02:32:38,859
most vocally against the generic dry

02:32:36,939 --> 02:32:43,120
dryer for the things that you put up on

02:32:38,859 --> 02:32:48,399
that on the slide given how widely it's

02:32:43,120 --> 02:32:54,790
used first of all am I wrong and should

02:32:48,399 --> 02:32:56,949
we just merge my position has been

02:32:54,790 --> 02:33:00,689
against the generic driver for applying

02:32:56,949 --> 02:33:03,790
overlays right because because I've been

02:33:00,689 --> 02:33:14,729
so against the against bent Ellis's

02:33:03,790 --> 02:33:18,189
right okay driver it's widely used its

02:33:14,729 --> 02:33:20,949
meanness in Yocto is the raspberry pi a

02:33:18,189 --> 02:33:22,899
fuel exhaust for a lot there hasn't

02:33:20,949 --> 02:33:28,899
really been significant forward progress

02:33:22,899 --> 02:33:32,739
on anything else am I wrong

02:33:28,899 --> 02:33:35,680
should this actually be merged then we

02:33:32,739 --> 02:33:40,050
treat problems as security bugs and fix

02:33:35,680 --> 02:33:43,689
up from there I thought you guys had a

02:33:40,050 --> 02:33:46,120
interface to load the overlay yeah

02:33:43,689 --> 02:33:49,029
basically we're using the config FS

02:33:46,120 --> 02:33:50,620
thing or then vendor-specific

02:33:49,029 --> 02:33:53,220
you know you have a character device

02:33:50,620 --> 02:33:56,350
that takes an i octal with an overlay

02:33:53,220 --> 02:33:58,479
but at this point we don't have any

02:33:56,350 --> 02:34:02,340
other way of putting it in the kernel

02:33:58,479 --> 02:34:05,140
which maybe maybe the PG a manager

02:34:02,340 --> 02:34:07,390
subsystem has should have its own way to

02:34:05,140 --> 02:34:11,350
do it you know all the infrastructure

02:34:07,390 --> 02:34:14,380
should be there to do two to load the

02:34:11,350 --> 02:34:18,699
overlay from within the the FPGA device

02:34:14,380 --> 02:34:21,760
manager so so you're saying I mean

02:34:18,699 --> 02:34:24,100
basically as I talked about we already

02:34:21,760 --> 02:34:26,229
inspect the overlay right so you're

02:34:24,100 --> 02:34:28,630
saying if at that point we make sure we

02:34:26,229 --> 02:34:31,239
don't target things outside of of the

02:34:28,630 --> 02:34:33,279
FPGA region why an internal whitelist

02:34:31,239 --> 02:34:35,920
that we keep that would be okay it's

02:34:33,279 --> 02:34:37,630
your driver yep how do you

02:34:35,920 --> 02:34:41,200
load your bid stream now or how do you

02:34:37,630 --> 02:34:42,189
acquire the bitstream - because it seems

02:34:41,200 --> 02:34:44,320
like you have the same problem you need

02:34:42,189 --> 02:34:47,140
to get a bit stream from somewhere for

02:34:44,320 --> 02:34:50,530
the FPGA and you need the Associated FTT

02:34:47,140 --> 02:34:56,170
says sort of like one conceptual package

02:34:50,530 --> 02:34:57,520
so if we go back here there is a we

02:34:56,170 --> 02:35:00,040
haven't liked this firmware name that

02:34:57,520 --> 02:35:01,930
comes as part of the overlay and the

02:35:00,040 --> 02:35:04,510
overlay gets into their kernel for most

02:35:01,930 --> 02:35:06,220
people through it the coin forgive us so

02:35:04,510 --> 02:35:08,500
the bit stream itself how do you load

02:35:06,220 --> 02:35:14,260
that from user space using a firmware

02:35:08,500 --> 02:35:16,210
interface okay so I mean we we could

02:35:14,260 --> 02:35:18,280
come up with a way worried we kept them

02:35:16,210 --> 02:35:21,490
together into a file make it a header or

02:35:18,280 --> 02:35:23,979
something you know would be there but

02:35:21,490 --> 02:35:27,000
our understanding so far was that all

02:35:23,979 --> 02:35:30,670
our attempts or yeah go anywhere because

02:35:27,000 --> 02:35:33,430
there's no way to lock down what I can

02:35:30,670 --> 02:35:35,920
overlay part of the problem with the

02:35:33,430 --> 02:35:38,610
generic interfaces no one's submitting

02:35:35,920 --> 02:35:41,380
it up string I mean we can't really

02:35:38,610 --> 02:35:47,950
we've outlined what issues should be

02:35:41,380 --> 02:35:50,170
fixed in it and for me the bit I think

02:35:47,950 --> 02:35:53,470
one of the biggest issue is just not

02:35:50,170 --> 02:35:57,820
allowing any random change to the base

02:35:53,470 --> 02:36:01,439
DT so you can only add nodes below a

02:35:57,820 --> 02:36:05,680
certain level or you can't go add a

02:36:01,439 --> 02:36:08,110
property at any node in the tree yeah an

02:36:05,680 --> 02:36:10,900
example of my checks that are checking

02:36:08,110 --> 02:36:12,880
for memory leaks etc some of the memory

02:36:10,900 --> 02:36:16,300
leaks are because you're modifying or

02:36:12,880 --> 02:36:21,040
adding a property in an existing node so

02:36:16,300 --> 02:36:22,870
if we could list more clearly what are

02:36:21,040 --> 02:36:26,979
acceptable practice like Rob was saying

02:36:22,870 --> 02:36:29,320
of only add new nodes sir and things in

02:36:26,979 --> 02:36:31,300
that node and below don't modify

02:36:29,320 --> 02:36:32,770
existing nodes one problem is that one

02:36:31,300 --> 02:36:36,040
of the current practices of using

02:36:32,770 --> 02:36:38,979
overlays is to modify the status of the

02:36:36,040 --> 02:36:40,330
node and enable it so this would say

02:36:38,979 --> 02:36:42,850
we're not going to support that at this

02:36:40,330 --> 02:36:45,250
point that'd be one of the non-supported

02:36:42,850 --> 02:36:47,710
uses and that one's kind of a easy one

02:36:45,250 --> 02:36:49,080
to support and I agree that we should

02:36:47,710 --> 02:36:52,730
could not

02:36:49,080 --> 02:36:54,870
at first and then add that but right I

02:36:52,730 --> 02:36:58,440
mean you could apply an overlay that

02:36:54,870 --> 02:37:04,080
goes and changes your memory size what

02:36:58,440 --> 02:37:07,050
do we do with that so if we basically

02:37:04,080 --> 02:37:10,890
say each FPGA region gets a Sisyphus

02:37:07,050 --> 02:37:13,410
entry that is called overlay that allows

02:37:10,890 --> 02:37:15,570
me to load an overlay and then in my

02:37:13,410 --> 02:37:18,390
FPGA manager framework look at that and

02:37:15,570 --> 02:37:21,540
make sure all the possible targets the

02:37:18,390 --> 02:37:23,330
overlay has would be an FPGA region then

02:37:21,540 --> 02:37:28,200
you'd be okay with that

02:37:23,330 --> 02:37:30,570
yeah the overlay apply code should be

02:37:28,200 --> 02:37:32,790
doing those checks are our internal code

02:37:30,570 --> 02:37:35,910
yeah it solar invalidation you shouldn't

02:37:32,790 --> 02:37:37,860
have to do it out outside we but one

02:37:35,910 --> 02:37:46,860
quick compact this slide you were just

02:37:37,860 --> 02:37:49,380
on the notified pre apply one of my

02:37:46,860 --> 02:37:51,061
concerns has always been used after free

02:37:49,380 --> 02:37:55,830
you know passing out reference this is a

02:37:51,061 --> 02:37:58,650
by-street that pre notify code has full

02:37:55,830 --> 02:38:05,150
access to the tree and can take

02:37:58,650 --> 02:38:08,870
references and allowing them to do this

02:38:05,150 --> 02:38:11,730
Department compromise was that I've

02:38:08,870 --> 02:38:14,880
added to the maintainer x' file a file

02:38:11,730 --> 02:38:18,540
entry or a a function terrific of it

02:38:14,880 --> 02:38:23,280
it's called anybody who wants to have

02:38:18,540 --> 02:38:26,521
one of these pre apply functions that's

02:38:23,280 --> 02:38:29,790
gonna come to me for review because the

02:38:26,521 --> 02:38:31,590
maintainer is file hopefully and those

02:38:29,790 --> 02:38:33,900
are very narrow use of the device trees

02:38:31,590 --> 02:38:35,040
it's very easy to audit them so so far

02:38:33,900 --> 02:38:38,340
I'm comfortable with that

02:38:35,040 --> 02:38:40,380
they're not flying all over the tree and

02:38:38,340 --> 02:38:42,480
modifying stuff they're just looking at

02:38:40,380 --> 02:38:44,820
a very small segment and not modifying

02:38:42,480 --> 02:38:48,900
anything so at this point I'm happy with

02:38:44,820 --> 02:38:50,460
that I just want to comment on something

02:38:48,900 --> 02:38:51,750
who's just said there Rob was saying for

02:38:50,460 --> 02:38:53,610
instance you shouldn't be able to change

02:38:51,750 --> 02:38:56,120
the amount of memory that you have I

02:38:53,610 --> 02:39:00,230
would say currently that's probably a

02:38:56,120 --> 02:39:02,640
valid situation but is that a long-term

02:39:00,230 --> 02:39:04,560
likely kind of thing plug

02:39:02,640 --> 02:39:07,109
memory is is something that could in

02:39:04,560 --> 02:39:09,630
fact come along I keep on coming back to

02:39:07,109 --> 02:39:12,540
the idea of policy and mechanism and I'm

02:39:09,630 --> 02:39:15,569
concerned that we're baking policy into

02:39:12,540 --> 02:39:16,590
the kernel with all these comments a lot

02:39:15,569 --> 02:39:18,779
of these things that people are saying

02:39:16,590 --> 02:39:20,850
well we shouldn't be able to do that is

02:39:18,779 --> 02:39:22,979
that true because maybe that's true

02:39:20,850 --> 02:39:24,930
yesterday and maybe today but it's not

02:39:22,979 --> 02:39:28,170
true tomorrow because we keep on coming

02:39:24,930 --> 02:39:29,909
up people keep coming up with new ways

02:39:28,170 --> 02:39:31,590
of looking at the world you know Harbor

02:39:29,909 --> 02:39:34,080
can't change well actually can because

02:39:31,590 --> 02:39:35,580
of us PGA's like yeah what I'm trying to

02:39:34,080 --> 02:39:37,640
say is is I think we've got to be really

02:39:35,580 --> 02:39:40,199
careful about about mandating policy

02:39:37,640 --> 02:39:42,600
saying that I cannot at this time

02:39:40,199 --> 02:39:44,460
imagine that we should be able to do

02:39:42,600 --> 02:39:45,899
this going forward now I realize that

02:39:44,460 --> 02:39:47,790
there's security concerns and everything

02:39:45,899 --> 02:39:48,930
else I get that but what I'm saying is

02:39:47,790 --> 02:39:50,550
is that I don't think we should be

02:39:48,930 --> 02:39:52,350
making blanket statements that memory

02:39:50,550 --> 02:39:54,090
sizes will never change because I can

02:39:52,350 --> 02:39:57,390
think of situations where that could

02:39:54,090 --> 02:39:59,370
happen yeah no I'm just using an example

02:39:57,390 --> 02:40:01,319
it's actually a good example yeah it is

02:39:59,370 --> 02:40:03,630
we're not precluding it from ever being

02:40:01,319 --> 02:40:06,090
supported what we're saying right now is

02:40:03,630 --> 02:40:07,979
that if you try and change that the

02:40:06,090 --> 02:40:09,659
underlying code that has to be able to

02:40:07,979 --> 02:40:11,580
deal with the memory change the hot

02:40:09,659 --> 02:40:13,290
plugging right that's not integrated

02:40:11,580 --> 02:40:15,000
into this framework it isn't that so

02:40:13,290 --> 02:40:16,920
it's correct so given that there's not

02:40:15,000 --> 02:40:19,020
the underlying support we can right now

02:40:16,920 --> 02:40:21,779
prohibit it but if that underlying

02:40:19,020 --> 02:40:23,670
support became added then we could

02:40:21,779 --> 02:40:26,220
remove the restriction that's it so it's

02:40:23,670 --> 02:40:27,600
we're not architecting a way that we

02:40:26,220 --> 02:40:29,250
won't be able to add it in the future I

02:40:27,600 --> 02:40:30,630
guess what I'm trying to say is is the

02:40:29,250 --> 02:40:32,310
best way to do that be a stub that

02:40:30,630 --> 02:40:34,080
basically said you know not implemented

02:40:32,310 --> 02:40:35,970
at this time as opposed to just saying

02:40:34,080 --> 02:40:37,290
no you can't change memory because that

02:40:35,970 --> 02:40:38,819
sends a different signal to people when

02:40:37,290 --> 02:40:41,010
they read the they read the code you see

02:40:38,819 --> 02:40:44,699
what I'm saying so so what I'm trying to

02:40:41,010 --> 02:40:47,880
say is is it's important that whatever

02:40:44,699 --> 02:40:49,170
however this is done is done in such a

02:40:47,880 --> 02:40:50,729
way that people can't change things if

02:40:49,170 --> 02:40:53,069
we say things can't be changed under a

02:40:50,729 --> 02:40:55,109
certain level that precludes any changes

02:40:53,069 --> 02:40:56,850
to things at the base level and I can

02:40:55,109 --> 02:40:58,109
again I can imagine situations in the

02:40:56,850 --> 02:41:00,120
future where we will want to change

02:40:58,109 --> 02:41:01,710
things in the Bay Street I'm thinking

02:41:00,120 --> 02:41:03,779
it's more like we're saying we will

02:41:01,710 --> 02:41:05,699
allow you to do this subset of the

02:41:03,779 --> 02:41:07,890
functionality we will allow you to do

02:41:05,699 --> 02:41:10,140
that subset it so it's kind of the

02:41:07,890 --> 02:41:12,720
positive as opposed of negative does

02:41:10,140 --> 02:41:14,210
that make sense it does I still feel

02:41:12,720 --> 02:41:18,460
we're going too far

02:41:14,210 --> 02:41:21,260
yeah we're baking policy in here

02:41:18,460 --> 02:41:22,670
well the flipside is we can't just leave

02:41:21,260 --> 02:41:25,370
it wide open and then tighten it down

02:41:22,670 --> 02:41:29,359
later so we're trying to suggesting that

02:41:25,370 --> 02:41:32,290
we should design the API that the that

02:41:29,359 --> 02:41:34,819
is a lot does allow anything to happen

02:41:32,290 --> 02:41:38,060
but then whitelist what we actually

02:41:34,819 --> 02:41:42,080
allow from the start I'm just saying and

02:41:38,060 --> 02:41:43,399
then add to that over time well and the

02:41:42,080 --> 02:41:46,250
reality is this has been sitting out

02:41:43,399 --> 02:41:48,410
there for a while and as as Rob was

02:41:46,250 --> 02:41:51,020
saying with comments and so it hasn't

02:41:48,410 --> 02:41:53,779
been resubmitted so maybe by focusing it

02:41:51,020 --> 02:41:55,939
in on the specific domain of FPGA and

02:41:53,779 --> 02:41:57,560
limiting what can change there it

02:41:55,939 --> 02:41:58,790
doesn't really necessarily say anything

02:41:57,560 --> 02:42:01,670
about what else could change in the

02:41:58,790 --> 02:42:04,180
future but it kind of focuses the the

02:42:01,670 --> 02:42:06,830
set of changes to kind of be the

02:42:04,180 --> 02:42:09,590
forerunner right that says this is

02:42:06,830 --> 02:42:12,529
actually a good way to do things that's

02:42:09,590 --> 02:42:14,060
my two cents all I know is if we say in

02:42:12,529 --> 02:42:15,979
this meeting today and it's published

02:42:14,060 --> 02:42:19,970
that you cannot change your memory going

02:42:15,979 --> 02:42:23,060
forward that is Wheatley I know I I just

02:42:19,970 --> 02:42:25,040
said the word if I said I said if we say

02:42:23,060 --> 02:42:26,390
that then that's gonna be the

02:42:25,040 --> 02:42:28,310
pronouncement that people read and

02:42:26,390 --> 02:42:29,750
follow so Ottawa and I'm not saying you

02:42:28,310 --> 02:42:31,040
said that what I'm saying is is we have

02:42:29,750 --> 02:42:33,140
to be careful about those kinds of

02:42:31,040 --> 02:42:36,470
pronouncements because the reality is is

02:42:33,140 --> 02:42:37,340
that we may again that that I agree with

02:42:36,470 --> 02:42:39,529
you that doesn't make sense

02:42:37,340 --> 02:42:41,449
today but I can imagine a situation

02:42:39,529 --> 02:42:42,979
where that you know you implemented in

02:42:41,449 --> 02:42:46,100
an FPGA for instance which I realize is

02:42:42,979 --> 02:42:48,560
insane but but it can be done and so

02:42:46,100 --> 02:42:51,050
extending memory is conceivable at this

02:42:48,560 --> 02:42:53,540
point again just as an example so it's

02:42:51,050 --> 02:42:56,319
it's already supported with device tree

02:42:53,540 --> 02:43:00,560
I think because I think PowerPC systems

02:42:56,319 --> 02:43:04,220
can plug I know I know

02:43:00,560 --> 02:43:06,850
CPU wise they do that that does not come

02:43:04,220 --> 02:43:10,180
from user space that's comes from

02:43:06,850 --> 02:43:12,800
probably the service processor or they

02:43:10,180 --> 02:43:14,899
come through over lazy it comes from

02:43:12,800 --> 02:43:17,380
them calling dynamic device tree code

02:43:14,899 --> 02:43:17,380
directly

02:43:18,850 --> 02:43:24,770
all right so would it be a fair

02:43:21,260 --> 02:43:26,600
statement to say if we were to you know

02:43:24,770 --> 02:43:28,939
take another look at that first

02:43:26,600 --> 02:43:31,550
RFC address the comments you guys made

02:43:28,939 --> 02:43:33,470
and then figure out the way to load

02:43:31,550 --> 02:43:38,359
something through the FPGA manager

02:43:33,470 --> 02:43:46,249
framework that would be a valid way

02:43:38,359 --> 02:43:48,770
forward so you have two bullet points

02:43:46,249 --> 02:43:52,189
there the first one is the whitelist

02:43:48,770 --> 02:43:55,369
concept or some version some

02:43:52,189 --> 02:43:58,189
conceptually equivalent so that part

02:43:55,369 --> 02:43:59,449
seems fine and I think we could accept

02:43:58,189 --> 02:44:06,079
that without a problem it seems like a

02:43:59,449 --> 02:44:07,489
good idea right yeah and I'm trying to

02:44:06,079 --> 02:44:11,510
remember there was something Alan had

02:44:07,489 --> 02:44:13,220
that I said it looked fine and but he

02:44:11,510 --> 02:44:15,289
had no user yet I can't remember what

02:44:13,220 --> 02:44:17,390
that was okay yeah I don't remember why

02:44:15,289 --> 02:44:18,920
it got hung up at that point but

02:44:17,390 --> 02:44:22,460
conceptually it seems like a good idea

02:44:18,920 --> 02:44:27,170
to me okay the I mean the DT connector

02:44:22,460 --> 02:44:31,579
from Penn tell us I think was I don't

02:44:27,170 --> 02:44:33,489
think that's going to anywhere it just

02:44:31,579 --> 02:44:35,510
lost momentum people weren't actively

02:44:33,489 --> 02:44:37,340
working on it people have to think

02:44:35,510 --> 02:44:39,079
through the issues think through the

02:44:37,340 --> 02:44:41,300
alternatives consider what's the best

02:44:39,079 --> 02:44:45,229
way to implement it and I just died

02:44:41,300 --> 02:44:47,659
nobody put the time into it I I think

02:44:45,229 --> 02:44:50,569
they're on the connector stuff we're

02:44:47,659 --> 02:44:52,220
gonna have to go binding by binding and

02:44:50,569 --> 02:44:55,340
figure out how that works

02:44:52,220 --> 02:45:01,420
and we've done GPIO so we need to figure

02:44:55,340 --> 02:45:01,420
out I to see spy and I don't

02:45:01,600 --> 02:45:07,239
I don't think you have to use that here

02:45:04,470 --> 02:45:11,949
yeah if you think conceptually about

02:45:07,239 --> 02:45:13,739
what the connector idea was on boards

02:45:11,949 --> 02:45:16,300
there physically is a connector

02:45:13,739 --> 02:45:18,340
classical either say the PCI connector

02:45:16,300 --> 02:45:20,800
you can have a physical connector that

02:45:18,340 --> 02:45:23,649
is just a spy bus or just a nice cord

02:45:20,800 --> 02:45:26,649
see bus those are really simple examples

02:45:23,649 --> 02:45:29,260
to create a a description of what does

02:45:26,649 --> 02:45:33,790
that connector look like when you get

02:45:29,260 --> 02:45:36,609
into boards that essentially expose for

02:45:33,790 --> 02:45:40,390
all practical purpose the entire pin set

02:45:36,609 --> 02:45:43,659
of the processor of the SOC and those

02:45:40,390 --> 02:45:46,000
are highly multiplexed that's where the

02:45:43,659 --> 02:45:48,580
complexity comes in and that's part of

02:45:46,000 --> 02:45:50,080
why I think connector stalled trying to

02:45:48,580 --> 02:45:53,050
conceptually figure out how to deal with

02:45:50,080 --> 02:45:54,729
that and maybe connectors is the wrong

02:45:53,050 --> 02:45:56,770
idea for that I I really don't know how

02:45:54,729 --> 02:45:58,569
to deal with is there a problem to solve

02:45:56,770 --> 02:46:01,689
there because it's highly tied to the

02:45:58,569 --> 02:46:08,050
SOC so why you need to describe the

02:46:01,689 --> 02:46:09,640
connector because you get connectors

02:46:08,050 --> 02:46:11,979
that appear on boards which have can

02:46:09,640 --> 02:46:18,720
have or many different boards with many

02:46:11,979 --> 02:46:22,840
different SOC s yes or the BeagleBone

02:46:18,720 --> 02:46:24,640
connectors or the Raspberry Pi that they

02:46:22,840 --> 02:46:28,659
all they all have a standard connector

02:46:24,640 --> 02:46:32,590
that appears on multiple boards right

02:46:28,659 --> 02:46:36,479
but those cases the they're tied to the

02:46:32,590 --> 02:46:36,479
the SOC because of the pin muxing

02:46:38,780 --> 02:46:45,561
so IIIi make my mega wonderful audio

02:46:41,870 --> 02:46:48,440
card for 96 boards or a Raspberry Pi or

02:46:45,561 --> 02:46:49,880
whatever and I want to write one overlay

02:46:48,440 --> 02:46:51,620
that describes what's on the book on

02:46:49,880 --> 02:46:53,420
that card because it's a physical object

02:46:51,620 --> 02:46:55,160
and I can't describe it I don't want to

02:46:53,420 --> 02:46:57,160
have to describe it for every possible

02:46:55,160 --> 02:46:59,811
base board it could be plugged into

02:46:57,160 --> 02:47:03,561
right but you're in that case that board

02:46:59,811 --> 02:47:04,880
works for a certain pin muxing right and

02:47:03,561 --> 02:47:08,830
if the pin muxing is different it

02:47:04,880 --> 02:47:08,830
wouldn't work on a different base board

02:47:08,920 --> 02:47:12,730
these connectors all have standard

02:47:11,210 --> 02:47:15,800
things are brought out from the

02:47:12,730 --> 02:47:18,261
particular way you you do the thanks

02:47:15,800 --> 02:47:22,761
John so the particular way you do the

02:47:18,261 --> 02:47:25,070
pin muxing is not standard yeah so but

02:47:22,761 --> 02:47:27,110
the thing you can get through things you

02:47:25,070 --> 02:47:31,011
can get through doing the pin muxing are

02:47:27,110 --> 02:47:35,900
standard and some of those are it's not

02:47:31,011 --> 02:47:37,190
just this one thing is always brought up

02:47:35,900 --> 02:47:39,351
on this signal some of them have some

02:47:37,190 --> 02:47:43,790
flexibility there yeah so I think the

02:47:39,351 --> 02:47:45,650
connector description is tied to the SOC

02:47:43,790 --> 02:47:47,660
not to the board so you know multiple

02:47:45,650 --> 02:47:50,690
boards using the same SOC using the same

02:47:47,660 --> 02:47:55,820
standard connector if that conceptually

02:47:50,690 --> 02:47:59,650
helps think about it yeah in cases where

02:47:55,820 --> 02:48:03,230
you have standard pin outs 96 boards

02:47:59,650 --> 02:48:06,980
doesn't allow pin muxing at least by the

02:48:03,230 --> 02:48:08,480
spec but I'm imagine well imagine that

02:48:06,980 --> 02:48:12,200
there are cases where that's not

02:48:08,480 --> 02:48:14,210
followed right whereas pi but in the

02:48:12,200 --> 02:48:16,990
cases where it is followed sure you need

02:48:14,210 --> 02:48:19,340
to connect her and where do you follow

02:48:16,990 --> 02:48:22,340
you have the standard pin out for

02:48:19,340 --> 02:48:24,860
Raspberry Pi and follow that then yes

02:48:22,340 --> 02:48:28,610
you need a connector it was more of the

02:48:24,860 --> 02:48:30,950
cases where it's purely aware of the

02:48:28,610 --> 02:48:33,050
base board because it knows the pin

02:48:30,950 --> 02:48:35,800
muxing and then maybe you don't need a

02:48:33,050 --> 02:48:35,800
connector I don't

02:48:38,190 --> 02:48:46,150
alright that was all they get that's

02:48:42,030 --> 02:48:49,061
good news so we'll clean up the stuff

02:48:46,150 --> 02:49:04,570
resubmit and hopefully not talk about it

02:48:49,061 --> 02:49:08,650
again and this is where Kate holds me to

02:49:04,570 --> 02:49:10,091
the grindstone for some reason the

02:49:08,650 --> 02:49:14,141
plumbers conference likes it if we

02:49:10,091 --> 02:49:15,820
summarize what happened and in the

02:49:14,141 --> 02:49:18,761
closing session they want us to stand up

02:49:15,820 --> 02:49:30,070
and give it two minute presentation no

02:49:18,761 --> 02:49:31,391
presentations yeah he's gonna say

02:49:30,070 --> 02:49:35,471
actions was the second half of that

02:49:31,391 --> 02:49:40,631
that's a separate one sean has been

02:49:35,471 --> 02:49:42,400
taking really good notes I should have

02:49:40,631 --> 02:49:44,771
asked you to like Kylie what's an action

02:49:42,400 --> 02:49:50,381
item and what's not I only caught a few

02:49:44,771 --> 02:49:52,240
in a few sessions oh good yeah I don't

02:49:50,381 --> 02:49:54,070
know how productive it is to stand here

02:49:52,240 --> 02:50:01,030
and do a real-time but I think you do a

02:49:54,070 --> 02:50:02,860
little bit of that and yeah we're

02:50:01,030 --> 02:50:05,921
herding cats well you have things like

02:50:02,860 --> 02:50:08,230
the connectors I mean you have a group

02:50:05,921 --> 02:50:11,860
of people who have to work in the on the

02:50:08,230 --> 02:50:13,990
mailing list so the ones I noted real

02:50:11,860 --> 02:50:16,030
quickly in Robb Stark

02:50:13,990 --> 02:50:18,881
Kate suggested having a transition plan

02:50:16,030 --> 02:50:21,160
and having documentation so that binding

02:50:18,881 --> 02:50:24,671
owners will be able to effectively do

02:50:21,160 --> 02:50:25,841
that Rob had a whole open question slide

02:50:24,671 --> 02:50:30,400
which had a whole bunch of stuff on it

02:50:25,841 --> 02:50:33,070
so that was a goldmine from the FPGAs at

02:50:30,400 --> 02:50:35,110
the very last night was the some

02:50:33,070 --> 02:50:38,200
conceptually way to whitelist drivers

02:50:35,110 --> 02:50:40,211
bringing that forward and moving forward

02:50:38,200 --> 02:50:42,190
on the the concept of connectors and

02:50:40,211 --> 02:50:43,870
implementation of that so I have a very

02:50:42,190 --> 02:50:46,200
meager list at this point for action

02:50:43,870 --> 02:50:46,200
items

02:50:46,720 --> 02:50:51,380
people who want to do the thing so white

02:50:49,489 --> 02:50:54,619
list I'm guessing out will probably take

02:50:51,380 --> 02:50:55,999
that on yeah I mean someone with Sunda

02:50:54,619 --> 02:50:56,770
patch in when when they're ready to do

02:50:55,999 --> 02:50:59,420
that

02:50:56,770 --> 02:51:01,789
connectors that's been sitting still for

02:50:59,420 --> 02:51:04,939
a long time I don't see people jumping

02:51:01,789 --> 02:51:07,430
up and doing that anytime soon it's not

02:51:04,939 --> 02:51:08,569
on my to do this for for the near future

02:51:07,430 --> 02:51:10,699
because I'm more focused on that

02:51:08,569 --> 02:51:11,960
foundational stuff I want to clean up

02:51:10,699 --> 02:51:16,000
the underlying issues yeah

02:51:11,960 --> 02:51:18,310
yes Salinas Valley is looking at the

02:51:16,000 --> 02:51:20,539
[Music]

02:51:18,310 --> 02:51:24,590
doing the subset of stuff that he was

02:51:20,539 --> 02:51:26,689
supposed to describe variety compatible

02:51:24,590 --> 02:51:30,520
string for the four beastly loading a

02:51:26,689 --> 02:51:33,890
board file for the module you plug in

02:51:30,520 --> 02:51:37,130
that's all to say that again so Lina's

02:51:33,890 --> 02:51:40,069
filly is work it's not connectors but

02:51:37,130 --> 02:51:43,159
it's intended for the at least the sort

02:51:40,069 --> 02:51:46,159
of plug-in module using API versus

02:51:43,159 --> 02:51:48,920
device tree etc etc so yes it was up to

02:51:46,159 --> 02:51:53,749
like version four yes a review of that

02:51:48,920 --> 02:51:56,210
yeah so he's essentially boils down to

02:51:53,749 --> 02:51:58,789
loading a board file for the plug-in

02:51:56,210 --> 02:52:03,920
module based on some identifying

02:51:58,789 --> 02:52:06,140
information yeah I think I'm a review of

02:52:03,920 --> 02:52:08,770
of all the versions through that because

02:52:06,140 --> 02:52:12,350
just looking at the most recent version

02:52:08,770 --> 02:52:17,420
conceptually doesn't address because he

02:52:12,350 --> 02:52:19,430
keeps it's evolving over time and I have

02:52:17,420 --> 02:52:21,920
to think of it as a whole is it yeah at

02:52:19,430 --> 02:52:24,590
all so that's on my plate I know Rob has

02:52:21,920 --> 02:52:25,789
done some reviews on it and I've have

02:52:24,590 --> 02:52:27,890
made some comments but they've been very

02:52:25,789 --> 02:52:29,689
shallow comments along the way but

02:52:27,890 --> 02:52:35,060
here's an action item we can certainly

02:52:29,689 --> 02:52:36,289
capture it to yeah it wasn't presented

02:52:35,060 --> 02:52:38,689
here so I don't think we need to make an

02:52:36,289 --> 02:52:41,329
action item but I'm sure then it's we'll

02:52:38,689 --> 02:52:42,739
carry it for Rafi yeah yeah I mean he's

02:52:41,329 --> 02:52:44,090
it's getting a bit discouraged by the

02:52:42,739 --> 02:52:46,399
whole difficult thing getting anything

02:52:44,090 --> 02:52:51,319
reviewed in this piece that's already a

02:52:46,399 --> 02:52:55,310
massive Dscoop yeah but it may mean that

02:52:51,319 --> 02:52:56,630
it mean if it may be enough to mean that

02:52:55,310 --> 02:52:57,979
the connectors thing isn't actually a

02:52:56,630 --> 02:53:00,560
big issue anymore

02:52:57,979 --> 02:53:08,199
they may be good enough for what people

02:53:00,560 --> 02:53:08,199
need to temporarily at least address it

02:53:14,710 --> 02:53:18,560
we're not we're not we're not we're not

02:53:16,460 --> 02:53:19,939
gonna solve it here but it's a it's a

02:53:18,560 --> 02:53:22,340
possible way forward on the connectors

02:53:19,939 --> 02:53:25,220
thing yeah so my recording puzzle is

02:53:22,340 --> 02:53:27,800
just to I mean we know we need a node to

02:53:25,220 --> 02:53:30,859
describe a connector we can do that much

02:53:27,800 --> 02:53:33,079
and just don't deviate from kind of what

02:53:30,859 --> 02:53:35,869
we've already defined or where we think

02:53:33,079 --> 02:53:39,199
we're going with the definitions he's

02:53:35,869 --> 02:53:40,699
like the last version I think had GPIO s

02:53:39,199 --> 02:53:43,850
in there and use something different

02:53:40,699 --> 02:53:47,749
than GPIO map which is what we want to

02:53:43,850 --> 02:53:51,140
use for mapping connect GPIO s through

02:53:47,749 --> 02:53:54,020
connectors so one other thing that I

02:53:51,140 --> 02:53:56,779
captured and I'm gonna kind of just take

02:53:54,020 --> 02:53:58,819
what you said and then move on the one

02:53:56,779 --> 02:54:01,310
of the other things Simon I asked you to

02:53:58,819 --> 02:54:05,060
maybe start socializing your your

02:54:01,310 --> 02:54:06,140
proposals around size improvements so

02:54:05,060 --> 02:54:09,560
that we have a little bit of more

02:54:06,140 --> 02:54:12,949
discussion about that also we it seems

02:54:09,560 --> 02:54:15,220
like from my perspective we've had quite

02:54:12,949 --> 02:54:18,729
a few different RFC's and and

02:54:15,220 --> 02:54:21,649
considering there are proposals for

02:54:18,729 --> 02:54:24,319
sizing and it would be very useful to

02:54:21,649 --> 02:54:27,470
start trying to actually make that

02:54:24,319 --> 02:54:31,220
change mature into something that goes

02:54:27,470 --> 02:54:33,470
in so as a something we want it we might

02:54:31,220 --> 02:54:36,050
want to capture yes that really comes

02:54:33,470 --> 02:54:39,079
down to the the flattened device tree

02:54:36,050 --> 02:54:40,850
format yes getting that that discussion

02:54:39,079 --> 02:54:43,520
to start moving forward again and again

02:54:40,850 --> 02:54:46,189
that's it stalled on the mail lists back

02:54:43,520 --> 02:54:48,079
in January so unless we start getting

02:54:46,189 --> 02:54:50,239
people interested and people are going

02:54:48,079 --> 02:54:52,760
to contribute code because it can take

02:54:50,239 --> 02:54:56,300
code and the compiler associated tools

02:54:52,760 --> 02:54:57,949
in the kernel and people interested in

02:54:56,300 --> 02:55:01,520
in the various projects how they're

02:54:57,949 --> 02:55:04,850
impacted and assignment said when we do

02:55:01,520 --> 02:55:06,739
this we wanted to to capture all the

02:55:04,850 --> 02:55:08,100
changes we anticipate over the next few

02:55:06,739 --> 02:55:11,220
years we don't want to do one

02:55:08,100 --> 02:55:13,739
now and do it again in a year so we want

02:55:11,220 --> 02:55:17,489
to try and capture as many ideas as we

02:55:13,739 --> 02:55:18,779
can now so people can encourage everyone

02:55:17,489 --> 02:55:20,640
to think about that what do they need

02:55:18,779 --> 02:55:23,010
what do they think can get at it that

02:55:20,640 --> 02:55:25,290
will help them in the format how do they

02:55:23,010 --> 02:55:27,229
think it needs to change and and sort of

02:55:25,290 --> 02:55:29,760
one of the implied things there too was

02:55:27,229 --> 02:55:32,970
to try and engage with some of the

02:55:29,760 --> 02:55:34,500
communities that aren't really here so I

02:55:32,970 --> 02:55:37,050
mean we obviously have you boot and we

02:55:34,500 --> 02:55:38,399
have Linux and we had zephyr but you

02:55:37,050 --> 02:55:42,060
know bsd folks i don't know if there's

02:55:38,399 --> 02:55:43,770
anybody with connections to bsd i'm not

02:55:42,060 --> 02:55:45,060
saying anybody jump up and down but we

02:55:43,770 --> 02:55:48,330
want to make sure that whatever we're

02:55:45,060 --> 02:55:52,050
talking about doesn't create you know

02:55:48,330 --> 02:55:54,210
some sort of a island the thing they end

02:55:52,050 --> 02:55:57,529
up on unfortunately do see it some bsd

02:55:54,210 --> 02:56:01,460
participation on the lists that helps

02:55:57,529 --> 02:56:01,460
did we miss anything

02:56:04,919 --> 02:56:10,470
so can we just talk about the ordering

02:56:07,709 --> 02:56:17,579
so the idea of doing live ftt changes

02:56:10,470 --> 02:56:22,039
first so the API API changes so grant

02:56:17,579 --> 02:56:25,079
was saying let's talk about that first

02:56:22,039 --> 02:56:34,319
because that's the thing that needs a

02:56:25,079 --> 02:56:36,270
transition plan I had the time wrong I

02:56:34,319 --> 02:56:42,149
thought that we were ending in 12 29 30

02:56:36,270 --> 02:56:44,879
so hey cool we got Tim we're gonna so I

02:56:42,149 --> 02:56:49,020
just wanted to get the ordering straight

02:56:44,879 --> 02:56:51,899
so if we do the Liberty T API changes

02:56:49,020 --> 02:56:53,369
first like getting rid of you know get

02:56:51,899 --> 02:56:55,140
property if did you get property you're

02:56:53,369 --> 02:56:57,479
making it return null or something and

02:56:55,140 --> 02:57:00,810
you know talking to David about that

02:56:57,479 --> 02:57:05,069
then we have more freedom right to

02:57:00,810 --> 02:57:08,100
actually change the format before that

02:57:05,069 --> 02:57:10,529
though from the kernel perspective we

02:57:08,100 --> 02:57:13,289
have driver after driver after driver

02:57:10,529 --> 02:57:15,720
that's getting back pointers to those

02:57:13,289 --> 02:57:18,390
nodes and in accessing those structures

02:57:15,720 --> 02:57:20,390
directly so from the kernel perspective

02:57:18,390 --> 02:57:24,839
we need to solve that before we change

02:57:20,390 --> 02:57:29,760
the format if we if we change the the

02:57:24,839 --> 02:57:31,829
node format so the kernel is we format

02:57:29,760 --> 02:57:33,689
either this the kernel is using the

02:57:31,829 --> 02:57:37,049
struct property thing all over the place

02:57:33,689 --> 02:57:39,180
yeah okay then I think for the kernel

02:57:37,049 --> 02:57:42,089
one solution would see somebody to

02:57:39,180 --> 02:57:43,499
allocate memory and return some stable

02:57:42,089 --> 02:57:47,189
stuff yes exactly

02:57:43,499 --> 02:57:48,419
yeah it's and that's to me controversial

02:57:47,189 --> 02:57:50,310
even though I think it's a good idea

02:57:48,419 --> 02:57:52,890
because it's gonna use more memory

02:57:50,310 --> 02:57:55,439
it means the driver who gets that object

02:57:52,890 --> 02:57:58,079
now has is there something responsible

02:57:55,439 --> 02:58:01,169
for freeing it well it would be the

02:57:58,079 --> 02:58:08,039
realistically kernel uses the strings

02:58:01,169 --> 02:58:09,479
and values I think yeah get property

02:58:08,039 --> 02:58:14,100
once you've given the property pointer

02:58:09,479 --> 02:58:15,629
out well the property there's only a

02:58:14,100 --> 02:58:20,039
limited number of cases where we go

02:58:15,629 --> 02:58:23,640
parse flat properties and use them but I

02:58:20,039 --> 02:58:27,569
think I would think that those are

02:58:23,640 --> 02:58:29,339
mostly we could audit those it's

02:58:27,569 --> 02:58:30,569
probably I guess that's yet your first

02:58:29,339 --> 02:58:32,819
step is go and look and see how

02:58:30,569 --> 02:58:34,770
widespread this is maybe it's worse than

02:58:32,819 --> 02:58:37,680
we think but once it's done once it Sun

02:58:34,770 --> 02:58:41,060
flattens we're only using I mean the

02:58:37,680 --> 02:58:45,869
unflagging copy is not using the struct

02:58:41,060 --> 02:58:49,079
property true correct correct so we're

02:58:45,869 --> 02:58:51,959
we're returning our internal property

02:58:49,079 --> 02:58:53,629
structure not the flatten structure and

02:58:51,959 --> 02:58:57,180
all of our pointers back to the

02:58:53,629 --> 02:58:58,919
flattened tree are two values not two

02:58:57,180 --> 02:58:59,249
actual structure you're right you're

02:58:58,919 --> 02:59:02,310
right

02:58:59,249 --> 02:59:04,159
thank you I was wrong so that that's not

02:59:02,310 --> 02:59:07,470
a barrier to the kernel

02:59:04,159 --> 02:59:15,839
good point Thanks well if we change it

02:59:07,470 --> 02:59:18,299
to so the point is it's Simon's level

02:59:15,839 --> 02:59:20,399
he's giving pointers out to the actual

02:59:18,299 --> 02:59:22,890
flattened device tree structure in the

02:59:20,399 --> 02:59:24,720
kernel we unflattering the tree we

02:59:22,890 --> 02:59:27,539
create an internal data structure

02:59:24,720 --> 02:59:29,970
containing the properties and that

02:59:27,539 --> 02:59:32,999
struct property in the kernel does not

02:59:29,970 --> 02:59:34,409
have to look like what the property

02:59:32,999 --> 02:59:37,109
entry and the flattened tree looks like

02:59:34,409 --> 02:59:38,760
we actually unpack that and put it into

02:59:37,109 --> 02:59:40,260
an internal so we don't have to worry

02:59:38,760 --> 02:59:42,749
about what that flattened structure

02:59:40,260 --> 02:59:45,390
looks like for driver access they're

02:59:42,749 --> 02:59:48,479
only looking at what's been unpacked so

02:59:45,390 --> 02:59:51,239
that's Rob's point okay that's good that

02:59:48,479 --> 02:59:52,379
what I was gonna try to get it as does

02:59:51,239 --> 02:59:56,999
the source format

02:59:52,379 --> 02:59:59,749
need to change the source format will

02:59:56,999 --> 02:59:59,749
need to

03:00:01,189 --> 03:00:05,510
as guys it'll need to change to delete a

03:00:03,949 --> 03:00:07,249
property and a note but I think we

03:00:05,510 --> 03:00:08,539
already have that in the source it's

03:00:07,249 --> 03:00:10,340
just that we have no way of getting that

03:00:08,539 --> 03:00:13,420
into the flattened device tree format

03:00:10,340 --> 03:00:16,279
it's only available the source level

03:00:13,420 --> 03:00:19,899
there probably will be a few extra

03:00:16,279 --> 03:00:22,970
things that need to get add I don't know

03:00:19,899 --> 03:00:28,039
it wouldn't surprise me nothing jumps

03:00:22,970 --> 03:00:29,119
out specifically but yeah but to go back

03:00:28,039 --> 03:00:32,119
to your original question yeah I think

03:00:29,119 --> 03:00:38,359
if we start with API then and then start

03:00:32,119 --> 03:00:40,609
seeing what the ripple is out yeah I

03:00:38,359 --> 03:00:45,350
another comment I'd make is that I worry

03:00:40,609 --> 03:00:47,689
that if we send David a huge you know

03:00:45,350 --> 03:00:49,880
here's the news and proposed new format

03:00:47,689 --> 03:00:51,470
it might take forever because he you

03:00:49,880 --> 03:00:54,470
know obviously he's got to consider each

03:00:51,470 --> 03:00:56,390
point I just don't know how we do this I

03:00:54,470 --> 03:01:00,729
actually don't understand what the

03:00:56,390 --> 03:01:00,729
process is for a completely new format

03:01:00,970 --> 03:01:06,770
discussion on the mail list he was the

03:01:05,449 --> 03:01:09,920
actor he was participating when I

03:01:06,770 --> 03:01:12,550
started to thread it so I didn't see him

03:01:09,920 --> 03:01:14,959
as a bottlenecked what I was proposing I

03:01:12,550 --> 03:01:18,680
think to me the bottleneck in a new

03:01:14,959 --> 03:01:20,180
format is seeking out anybody's needs in

03:01:18,680 --> 03:01:23,569
the ways they want to change it or wait

03:01:20,180 --> 03:01:27,499
and you have some ideas and I had some

03:01:23,569 --> 03:01:29,810
ideas maybe that's 80% of what's needed

03:01:27,499 --> 03:01:31,699
maybe somebody else has some brilliant

03:01:29,810 --> 03:01:33,829
idea that we have no concept there's a

03:01:31,699 --> 03:01:37,369
need how do we find those people how do

03:01:33,829 --> 03:01:40,220
we encourage them to come forward and

03:01:37,369 --> 03:01:45,439
give us ideas I think that that

03:01:40,220 --> 03:01:46,640
evangelism is is pretty important that's

03:01:45,439 --> 03:01:48,470
part of the reason why I'm asking you to

03:01:46,640 --> 03:01:50,329
start socializing some of the other

03:01:48,470 --> 03:01:52,310
things because hopefully that'll start

03:01:50,329 --> 03:01:54,439
bringing people out otherwise you these

03:01:52,310 --> 03:01:56,270
changes will go in and then you know

03:01:54,439 --> 03:01:58,399
that's when everybody will start to

03:01:56,270 --> 03:02:00,829
notice and then old a wait wait no you

03:01:58,399 --> 03:02:02,600
burp me well you know we tried to get

03:02:00,829 --> 03:02:05,149
you to give us input sooner

03:02:02,600 --> 03:02:07,459
well I I can send Annie my can write an

03:02:05,149 --> 03:02:09,949
email that says hey if we change the

03:02:07,459 --> 03:02:13,039
format this this is this would this

03:02:09,949 --> 03:02:14,810
these parts of the API would break so

03:02:13,039 --> 03:02:17,060
this is why we want to turn these

03:02:14,810 --> 03:02:18,859
functions down and and it would start

03:02:17,060 --> 03:02:20,089
something that's yes and I think

03:02:18,859 --> 03:02:22,180
bringing forward the ideas that you

03:02:20,089 --> 03:02:25,510
presented today and you've written up

03:02:22,180 --> 03:02:28,939
those are really interesting ideas and

03:02:25,510 --> 03:02:31,850
some of them I think Rob was making a

03:02:28,939 --> 03:02:35,390
point of for this specific line item

03:02:31,850 --> 03:02:38,180
maybe there's not a big gain but there's

03:02:35,390 --> 03:02:39,800
a big cost so going through and trying

03:02:38,180 --> 03:02:43,879
to do that balance of which items are

03:02:39,800 --> 03:02:45,560
worth doing which are if there is a pain

03:02:43,879 --> 03:02:48,529
which ones are worth the pain if they're

03:02:45,560 --> 03:02:49,669
ones where there is no pain we just get

03:02:48,529 --> 03:02:52,369
gained that's a good thing and just

03:02:49,669 --> 03:02:53,770
select which ones we need to do and that

03:02:52,369 --> 03:02:56,239
that discussion will happen on the list

03:02:53,770 --> 03:02:58,879
but your proposal I think is a major

03:02:56,239 --> 03:03:00,919
step forward in making that visible and

03:02:58,879 --> 03:03:03,770
what can happen and getting people into

03:03:00,919 --> 03:03:05,779
thinking creatively good say maybe even

03:03:03,770 --> 03:03:07,459
narrowing it down to that the top one

03:03:05,779 --> 03:03:09,350
which was that 27% which was the

03:03:07,459 --> 03:03:11,209
property encoding one and and then

03:03:09,350 --> 03:03:15,319
that's it's not too much for people to

03:03:11,209 --> 03:03:17,689
consider yeah in Rob's point about being

03:03:15,319 --> 03:03:21,079
able to move forward adding other

03:03:17,689 --> 03:03:25,129
changes to this to tags in a compatible

03:03:21,079 --> 03:03:28,600
way without breaking existing so folding

03:03:25,129 --> 03:03:28,600
that in I think is important

03:03:32,331 --> 03:03:36,271
so trying to make sure that we're we're

03:03:34,621 --> 03:03:38,761
summarizing this well because again the

03:03:36,271 --> 03:03:43,051
idea is that this added value in terms

03:03:38,761 --> 03:03:45,320
of not just discussion but actually call

03:03:43,051 --> 03:03:47,730
to arms so is there anything else that

03:03:45,320 --> 03:03:52,740
folks want to make sure that we capture

03:03:47,730 --> 03:03:54,660
or isn't an eager pet did you get names

03:03:52,740 --> 03:04:13,141
for who's gonna write some JSON schema

03:03:54,660 --> 03:04:15,381
ducks Kate's gonna write some I'd like

03:04:13,141 --> 03:04:18,450
all of you to volunteer for something

03:04:15,381 --> 03:04:21,570
every last one of you do you actually go

03:04:18,450 --> 03:04:23,041
and read the notes at some point whether

03:04:21,570 --> 03:04:23,940
it's a week in the future two weeks

03:04:23,041 --> 03:04:27,601
whether it's tomorrow

03:04:23,940 --> 03:04:33,511
once they're posted on a Linux org and

03:04:27,601 --> 03:04:35,881
or even the ether pad if past history is

03:04:33,511 --> 03:04:39,001
an indication ether pad will remain open

03:04:35,881 --> 03:04:41,131
for some amount of time after today and

03:04:39,001 --> 03:04:44,070
you can go in and add it edit and add

03:04:41,131 --> 03:04:46,081
things in make sure that that what is in

03:04:44,070 --> 03:04:48,811
there was correctly capturing anything

03:04:46,081 --> 03:04:52,561
you might have said and even if it does

03:04:48,811 --> 03:04:54,860
get closed on the ether pad I will have

03:04:52,561 --> 03:04:57,301
a copy that on Elance org and we can add

03:04:54,860 --> 03:05:00,150
comments notes there or even separate

03:04:57,301 --> 03:05:02,971
handwritten notes totally independent of

03:05:00,150 --> 03:05:05,221
ether pad so anything you want to add to

03:05:02,971 --> 03:05:08,280
this for the documentation over time

03:05:05,221 --> 03:05:10,971
just email me and be glad to to include

03:05:08,280 --> 03:05:10,971
that in the record

03:05:20,460 --> 03:05:26,850
thanks for coming we appreciate it and

03:05:23,610 --> 03:05:29,100
we'll be here all week come back to us

03:05:26,850 --> 03:05:30,750
anywhere despite the lack of green

03:05:29,100 --> 03:05:35,300
stickers on my tag despite Shawn's

03:05:30,750 --> 03:05:35,300

YouTube URL: https://www.youtube.com/watch?v=s7Eb4cNffoQ


