Title: LPC2018 - Formal Methods for Kernel Hackers
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/60/
speaker:   Catalin Marinas


Formal methods have a reputation of being difficult, accessible mostly to academics and of little use to the typical kernel hacker. This talk aims to show how, without "formal" training, one can use such tools for the benefit of the Linux kernel. It will introduce a few formal models that helped find actual bugs in the Linux kernel and start a discussion around future uses from modelling existing kernel implementation (e.g. cpu hotplug, page cache states, mm_user/mm_count) to formally specifying new design choices. The introductory examples are written in PlusCal (an algorithm language based on TLA+) but no prior knowledge is required.
Captions: 
	00:00:06,029 --> 00:00:13,809
I'm Katalin marinas container of the on

00:00:10,389 --> 00:00:15,760
64 channel port and now this

00:00:13,809 --> 00:00:18,340
presentation is a slight change from

00:00:15,760 --> 00:00:21,310
what I'm normally doing like writing see

00:00:18,340 --> 00:00:24,039
and assembly it's actually trying to be

00:00:21,310 --> 00:00:25,900
more thorough in verifying that the

00:00:24,039 --> 00:00:28,660
algorithm algorithms will put in the

00:00:25,900 --> 00:00:36,520
kernel actually guarantee or some

00:00:28,660 --> 00:00:41,230
properties so yeah I'll go through some

00:00:36,520 --> 00:00:46,870
of the work I've been doing in using TL

00:00:41,230 --> 00:00:51,070
applause and it gives some some examples

00:00:46,870 --> 00:00:53,830
hopefully it gets gets a picture of what

00:00:51,070 --> 00:00:59,530
this is about how it could be used for

00:00:53,830 --> 00:01:10,890
other algorithms and so why use formal

00:00:59,530 --> 00:01:10,890
methods it it allows one to reason yeah

00:01:11,549 --> 00:01:20,399
yeah about that so yeah maybe I

00:01:16,270 --> 00:01:20,399
shouldn't look at the big screen

00:01:42,720 --> 00:01:49,300
yeah thank you Oh is it any better no

00:01:48,120 --> 00:01:53,220
okay

00:01:49,300 --> 00:01:55,810
so why use formal methods it's not

00:01:53,220 --> 00:01:59,440
usually I think it's it's funnier to

00:01:55,810 --> 00:02:03,880
just write the C code rather than verify

00:01:59,440 --> 00:02:06,040
it but going for some formal formal

00:02:03,880 --> 00:02:09,399
model of your algorithms helps you think

00:02:06,040 --> 00:02:11,350
through the problem and actually even

00:02:09,399 --> 00:02:13,120
probably sometimes it gets harder to

00:02:11,350 --> 00:02:15,370
actually figure out what properties you

00:02:13,120 --> 00:02:20,080
and to show about about your algorithm

00:02:15,370 --> 00:02:22,270
and there are different what there are

00:02:20,080 --> 00:02:25,360
too many things here is the either you

00:02:22,270 --> 00:02:30,400
have your algorithm specified in a

00:02:25,360 --> 00:02:32,920
formal way you you can either come up

00:02:30,400 --> 00:02:35,380
with a formal proof of your properties

00:02:32,920 --> 00:02:38,410
and that's usually pretty time-consuming

00:02:35,380 --> 00:02:41,739
and unless you do this for a living I

00:02:38,410 --> 00:02:43,720
wouldn't recommend it and the other

00:02:41,739 --> 00:02:48,280
simpler option was computing in passive

00:02:43,720 --> 00:02:51,160
is to use model checking and yeah it

00:02:48,280 --> 00:02:54,160
helps you spot bugs it's not you know

00:02:51,160 --> 00:02:55,840
complete guarantee and absolute proof

00:02:54,160 --> 00:02:57,640
that your algorithm is correct because

00:02:55,840 --> 00:02:59,980
you have lots of assumptions when

00:02:57,640 --> 00:03:03,239
modeling for example you may not fully

00:02:59,980 --> 00:03:07,050
model your memory system memory ordering

00:03:03,239 --> 00:03:11,140
and you usually make simplifications but

00:03:07,050 --> 00:03:14,350
so I started with this I had to give it

00:03:11,140 --> 00:03:19,660
the go on some of the arm 64 algorithms

00:03:14,350 --> 00:03:22,450
to use in the camera and also initially

00:03:19,660 --> 00:03:24,670
surprised just to find bugs in in couple

00:03:22,450 --> 00:03:26,680
of them was the a seed a locator that's

00:03:24,670 --> 00:03:29,320
the a seed is used to tag the tlbs

00:03:26,680 --> 00:03:32,709
to avoid invalidating the TLB set

00:03:29,320 --> 00:03:35,500
context switch and to my surprise it

00:03:32,709 --> 00:03:38,920
found a bug in the rollover logic and

00:03:35,500 --> 00:03:41,859
it's very hard to trigger in in practice

00:03:38,920 --> 00:03:44,970
but if you know how to maybe is not

00:03:41,859 --> 00:03:44,970
impossible and

00:03:45,400 --> 00:03:50,500
went through some other models can see

00:03:47,140 --> 00:03:55,030
in here on on 64 I think notable one is

00:03:50,500 --> 00:03:57,819
the KVM handling of the V geek the

00:03:55,030 --> 00:03:59,530
interrupt controller virtual interrupt

00:03:57,819 --> 00:04:03,879
controller that was done by Valentin

00:03:59,530 --> 00:04:05,650
Schneider in arm what difference is

00:04:03,879 --> 00:04:09,069
actually it was different here is that

00:04:05,650 --> 00:04:11,170
it it has a model an abstract model of

00:04:09,069 --> 00:04:13,510
the interrupt controller and of the

00:04:11,170 --> 00:04:16,479
hypervisor handling of such interrupts

00:04:13,510 --> 00:04:19,389
so can show different properties and

00:04:16,479 --> 00:04:21,639
while he didn't find the body confirm

00:04:19,389 --> 00:04:27,669
the bug it was actually fixed before the

00:04:21,639 --> 00:04:31,150
model was finished so what's T le plus

00:04:27,669 --> 00:04:32,860
and the T le plus started at the formal

00:04:31,150 --> 00:04:33,789
specification language developed by

00:04:32,860 --> 00:04:36,370
Leslie Lamport

00:04:33,789 --> 00:04:41,260
and his aim was originally just to

00:04:36,370 --> 00:04:46,150
specify using temporal logic and that

00:04:41,260 --> 00:04:49,690
I've set theory just to specify behavior

00:04:46,150 --> 00:04:52,020
system behavior someone else you are

00:04:49,690 --> 00:04:55,900
used figure out that actually you can

00:04:52,020 --> 00:04:59,639
model check the full specification so he

00:04:55,900 --> 00:05:05,349
came up with a PLC PLA model checker

00:04:59,639 --> 00:05:07,389
could also be used for to have proper

00:05:05,349 --> 00:05:08,919
machine checked proofs and it requires a

00:05:07,389 --> 00:05:10,780
back-end but as I said this is pretty

00:05:08,919 --> 00:05:14,010
time-consuming to write your like a

00:05:10,780 --> 00:05:16,720
hierarchical proof of your algorithm

00:05:14,010 --> 00:05:19,120
last call I think this one came from

00:05:16,720 --> 00:05:22,900
Lauria Institute in France is actually a

00:05:19,120 --> 00:05:25,750
pseudo code like language much closer to

00:05:22,900 --> 00:05:27,940
what programmers are used to and it

00:05:25,750 --> 00:05:30,639
translates into T la plus and then you

00:05:27,940 --> 00:05:33,220
can apply the T le plus model checker on

00:05:30,639 --> 00:05:38,260
top and it has a simple way to describe

00:05:33,220 --> 00:05:40,990
concurrency and yet T le plus has been

00:05:38,260 --> 00:05:42,539
used over the years and some some

00:05:40,990 --> 00:05:45,400
examples here

00:05:42,539 --> 00:05:48,370
now I'll go for I'll go for simple

00:05:45,400 --> 00:05:51,099
example what what T la plus so the

00:05:48,370 --> 00:05:53,080
syntax may look scary but I think if you

00:05:51,099 --> 00:05:54,940
look there at this for some time here

00:05:53,080 --> 00:05:59,080
actually get used to it

00:05:54,940 --> 00:06:01,090
but let's DL a plus so SPO t la

00:05:59,080 --> 00:06:04,120
lascall so that's basically what you

00:06:01,090 --> 00:06:07,900
have in here is a way of describing a

00:06:04,120 --> 00:06:11,470
system behavior and you can say at the

00:06:07,900 --> 00:06:13,449
end last line is the specification which

00:06:11,470 --> 00:06:16,780
means that your behave but behavior is a

00:06:13,449 --> 00:06:18,970
sequence of states so what you say at

00:06:16,780 --> 00:06:20,860
the end by the specification is that my

00:06:18,970 --> 00:06:25,870
sequence of states describe what's

00:06:20,860 --> 00:06:29,409
allowed in the system should go and it

00:06:25,870 --> 00:06:31,539
should match the initial state so should

00:06:29,409 --> 00:06:33,729
start from a tick and count 0 this is a

00:06:31,539 --> 00:06:36,729
simple example if let's say you have one

00:06:33,729 --> 00:06:39,400
part of the ticks it changes to take

00:06:36,729 --> 00:06:41,379
variable from 0 to 1 and we have some

00:06:39,400 --> 00:06:42,219
other part in the system that comes

00:06:41,379 --> 00:06:49,930
number of ticks

00:06:42,219 --> 00:06:52,780
and what's this temporal temporal logic

00:06:49,930 --> 00:06:55,180
does here is that for example tick is an

00:06:52,780 --> 00:06:57,400
action and it describes a relation

00:06:55,180 --> 00:07:00,219
between two successive states so in it

00:06:57,400 --> 00:07:02,440
is the initial state initialized to 0

00:07:00,219 --> 00:07:06,400
tick prime is actually the variable in

00:07:02,440 --> 00:07:08,860
the next state comment is something that

00:07:06,400 --> 00:07:11,139
counts the number of ticks and the next

00:07:08,860 --> 00:07:14,289
step for your system the behavior is

00:07:11,139 --> 00:07:17,620
actually either tick or count so this

00:07:14,289 --> 00:07:19,870
allows want to generate sequence of

00:07:17,620 --> 00:07:24,130
states increasingly that's not

00:07:19,870 --> 00:07:26,380
sufficient to this what actually may not

00:07:24,130 --> 00:07:30,129
do what we expect so you came it allows

00:07:26,380 --> 00:07:33,279
behaviors of this type where you can get

00:07:30,129 --> 00:07:35,830
only the count action taking place or

00:07:33,279 --> 00:07:38,139
only the tick action Pigface and ele

00:07:35,830 --> 00:07:41,259
plus also allows for infinite stuttering

00:07:38,139 --> 00:07:44,740
steps where nothing changes so go

00:07:41,259 --> 00:07:46,560
quickly through these now as you know a

00:07:44,740 --> 00:07:48,400
better spec would be to us add another

00:07:46,560 --> 00:07:50,020
variable in here to have some

00:07:48,400 --> 00:07:52,690
synchronization between peek and count

00:07:50,020 --> 00:07:57,279
know i only introduced this briefly i

00:07:52,690 --> 00:08:01,090
think i'll go to some say more software

00:07:57,279 --> 00:08:03,819
related examples so i'll go for a spin

00:08:01,090 --> 00:08:08,320
lock model or spin lock implementation

00:08:03,819 --> 00:08:10,960
in pascal using typical spin lock using

00:08:08,320 --> 00:08:12,889
load-linked store conditional on arm

00:08:10,960 --> 00:08:15,319
those are load exclusive story

00:08:12,889 --> 00:08:18,499
instructions basically if you are not

00:08:15,319 --> 00:08:20,900
familiar with those you have a load from

00:08:18,499 --> 00:08:23,719
an address and the subsequent store to

00:08:20,900 --> 00:08:26,060
that address or store conditional only

00:08:23,719 --> 00:08:30,139
succeeds if there was no other update of

00:08:26,060 --> 00:08:33,560
the memory location in the meantime on

00:08:30,139 --> 00:08:35,329
our the hardware implementation on our

00:08:33,560 --> 00:08:39,919
muses and exclusive monitor or maybe

00:08:35,329 --> 00:08:44,029
multiple explicit monitors and I'm going

00:08:39,919 --> 00:08:46,820
to model this very simple abstract model

00:08:44,029 --> 00:08:50,630
of the explicit monitor in ela plus our

00:08:46,820 --> 00:08:54,800
musing plus call here which is like

00:08:50,630 --> 00:08:56,420
pseudocode like language well some

00:08:54,800 --> 00:08:58,070
boilerplate extending some of the

00:08:56,420 --> 00:09:00,890
modules in there you can declare

00:08:58,070 --> 00:09:05,560
constants which are actually that's how

00:09:00,890 --> 00:09:08,510
you define the configuration of your

00:09:05,560 --> 00:09:10,430
specification we have CPUs and we have

00:09:08,510 --> 00:09:13,160
addresses CPUs can be some abstract

00:09:10,430 --> 00:09:14,930
values we call them p1 and p2 and the

00:09:13,160 --> 00:09:18,050
brackets in here that means they are set

00:09:14,930 --> 00:09:21,709
sub X let star is the comment in in plus

00:09:18,050 --> 00:09:23,660
call so our configuration consists of

00:09:21,709 --> 00:09:27,140
CPUs and the set of addresses we don't

00:09:23,660 --> 00:09:30,920
care what what they are and the plastic

00:09:27,140 --> 00:09:32,990
a logarithm so are usually the plus code

00:09:30,920 --> 00:09:35,060
what normal plus call code is written

00:09:32,990 --> 00:09:37,160
inside the t le plus comment just

00:09:35,060 --> 00:09:39,050
because it expands it inline can

00:09:37,160 --> 00:09:43,360
probably expand it out of line but in a

00:09:39,050 --> 00:09:47,930
different file I haven't tried anyway

00:09:43,360 --> 00:09:49,970
you declare the variables so for our

00:09:47,930 --> 00:09:53,720
simple spinlock implementation we have a

00:09:49,970 --> 00:09:59,720
memory array the erase and data

00:09:53,720 --> 00:10:02,149
structure is empty le plus r are just

00:09:59,720 --> 00:10:04,190
functions defined on the for example

00:10:02,149 --> 00:10:07,640
memory here is defined on the domain of

00:10:04,190 --> 00:10:13,070
addresses our values in natural numbers

00:10:07,640 --> 00:10:15,970
so we have a memory array indexed by by

00:10:13,070 --> 00:10:19,220
our addresses and initialized to 0

00:10:15,970 --> 00:10:20,930
we pick a lock address so choose an

00:10:19,220 --> 00:10:22,819
address that satisfies the condition

00:10:20,930 --> 00:10:26,570
true so it's basically just a random

00:10:22,819 --> 00:10:31,300
address in where we store our

00:10:26,570 --> 00:10:34,700
or spinlock and the exclusive monitor

00:10:31,300 --> 00:10:37,340
that's the specific implementation of a

00:10:34,700 --> 00:10:40,160
load-linked store conditional it's

00:10:37,340 --> 00:10:43,460
another array index by the number of

00:10:40,160 --> 00:10:47,000
CPUs it's initially open and this

00:10:43,460 --> 00:10:49,010
exclusive monitor can store I can either

00:10:47,000 --> 00:10:51,950
be open you know past eight or a closed

00:10:49,010 --> 00:11:01,710
State and it remembers the address that

00:10:51,950 --> 00:11:03,160
load link loaded from and some macros in

00:11:01,710 --> 00:11:06,560
[Music]

00:11:03,160 --> 00:11:08,120
implants call to declare our what to

00:11:06,560 --> 00:11:10,610
define our accesses to the exclusive

00:11:08,120 --> 00:11:14,630
monitor the macros are modeled

00:11:10,610 --> 00:11:16,310
atomically in DL a plus C you don't need

00:11:14,630 --> 00:11:20,900
to worry about internally being whatever

00:11:16,310 --> 00:11:22,490
you put in a macro we have the so

00:11:20,900 --> 00:11:24,530
setting the exclusive monitor that would

00:11:22,490 --> 00:11:26,870
be done by a load link or lo the

00:11:24,530 --> 00:11:29,080
exclusive instruction just sets the

00:11:26,870 --> 00:11:31,370
exclusive monitor to an address and

00:11:29,080 --> 00:11:34,970
clearly the explicit monitor that would

00:11:31,370 --> 00:11:38,060
be done by a store actually we built the

00:11:34,970 --> 00:11:40,040
the exclusive monitor status for all the

00:11:38,060 --> 00:11:41,600
CPUs so that's our abstract model of the

00:11:40,040 --> 00:11:43,490
explicit monitor the hardware

00:11:41,600 --> 00:11:46,270
implementation was probably done

00:11:43,490 --> 00:11:50,300
differently they may use the cache line

00:11:46,270 --> 00:11:53,300
state like exclusive state but for for

00:11:50,300 --> 00:11:55,450
our example that was just high-level

00:11:53,300 --> 00:11:57,920
abstract view of the exclusive monitor

00:11:55,450 --> 00:11:59,300
now we have the instructions so it

00:11:57,920 --> 00:12:01,520
defined some instructions so I clothed

00:11:59,300 --> 00:12:03,110
exclusive there's the load link on arm

00:12:01,520 --> 00:12:07,310
it says the exclusive monitor for the

00:12:03,110 --> 00:12:10,790
address and it loads it it says the

00:12:07,310 --> 00:12:14,150
register to whatever was at that memory

00:12:10,790 --> 00:12:16,310
location a store exclusive it succeeds

00:12:14,150 --> 00:12:20,120
only if the exclusive monitor for the

00:12:16,310 --> 00:12:23,140
current CPU that's a courtesy PU it uses

00:12:20,120 --> 00:12:27,410
the self by default it generates the

00:12:23,140 --> 00:12:29,240
variable so it's only if the currency

00:12:27,410 --> 00:12:33,560
the exclusive monitor for the current

00:12:29,240 --> 00:12:36,140
CPU was set to the address it succeeds

00:12:33,560 --> 00:12:39,440
in storing and also clears the exclusive

00:12:36,140 --> 00:12:40,400
monitor for all the other CPUs in case

00:12:39,440 --> 00:12:44,930
of failing

00:12:40,400 --> 00:12:46,910
returns the status one for completeness

00:12:44,930 --> 00:12:52,100
added a load instruction is not going to

00:12:46,910 --> 00:12:55,130
be used in this example and store

00:12:52,100 --> 00:12:57,260
instruction always succeeds in in

00:12:55,130 --> 00:12:59,480
updating the memory location but clears

00:12:57,260 --> 00:13:02,930
the exclusive monitor for all the CPUs

00:12:59,480 --> 00:13:07,700
so how would our locking implementation

00:13:02,930 --> 00:13:11,560
look like spin lock procedure that makes

00:13:07,700 --> 00:13:14,780
use of the macros previously defined so

00:13:11,560 --> 00:13:19,220
one thing to remember is that in plus

00:13:14,780 --> 00:13:26,330
call when it's translated to TLA + so

00:13:19,220 --> 00:13:28,580
the atomicity each each step that it

00:13:26,330 --> 00:13:31,340
motors is actually needs to be

00:13:28,580 --> 00:13:33,380
represented by a label so we can

00:13:31,340 --> 00:13:35,750
generate labels for you but there are

00:13:33,380 --> 00:13:37,820
the much course of grain so if you want

00:13:35,750 --> 00:13:41,630
final granularity in modeling the

00:13:37,820 --> 00:13:45,740
interleaving of different CPUs executing

00:13:41,630 --> 00:13:49,130
you add yeah you have to add additional

00:13:45,740 --> 00:13:51,170
labels if you are too many labels that's

00:13:49,130 --> 00:13:54,410
another problem because your state space

00:13:51,170 --> 00:13:58,610
may explode and it takes a long time to

00:13:54,410 --> 00:14:01,940
it to model so spin lock implementation

00:13:58,610 --> 00:14:03,560
using load-linked store conditional you

00:14:01,940 --> 00:14:07,610
do a load from an address if the lock

00:14:03,560 --> 00:14:09,440
valve is it's not zero it means that the

00:14:07,610 --> 00:14:12,260
lock is taken so you go again and read

00:14:09,440 --> 00:14:16,190
that's a pretty funny implementation now

00:14:12,260 --> 00:14:19,280
if you succeeded in if the lock value is

00:14:16,190 --> 00:14:21,830
0 means the lock is not taken the store

00:14:19,280 --> 00:14:25,160
exclusive tries to store one to this so

00:14:21,830 --> 00:14:28,910
take the lock and again if it succeeds

00:14:25,160 --> 00:14:30,440
it returns if you know if not status is

00:14:28,910 --> 00:14:31,880
one it means the store exclusive didn't

00:14:30,440 --> 00:14:35,150
succeed because there was another store

00:14:31,880 --> 00:14:38,500
to that location it goes back again and

00:14:35,150 --> 00:14:40,820
tries to load the lock or spin forever

00:14:38,500 --> 00:14:45,560
the unlocking is simple is just the

00:14:40,820 --> 00:14:47,210
store to that memory location now I will

00:14:45,560 --> 00:14:49,250
describe what to actually want to model

00:14:47,210 --> 00:14:53,120
so we define the spin lock now we want

00:14:49,250 --> 00:14:53,620
to actually model put some action in

00:14:53,120 --> 00:14:55,390
this

00:14:53,620 --> 00:14:59,410
having just the procedure so the way we

00:14:55,390 --> 00:15:02,350
model this we have we define one process

00:14:59,410 --> 00:15:05,140
per CPU that tries to acquire the lock

00:15:02,350 --> 00:15:07,990
and release the lock in an infinite loop

00:15:05,140 --> 00:15:10,450
so against it spin lock spin down lock

00:15:07,990 --> 00:15:12,130
and we have a critical section it's a no

00:15:10,450 --> 00:15:14,380
op we just put the Skip is we are going

00:15:12,130 --> 00:15:19,380
to use this label later but it doesn't

00:15:14,380 --> 00:15:22,240
actually have any effect no properties

00:15:19,380 --> 00:15:24,370
so we specify the algorithm now we want

00:15:22,240 --> 00:15:28,360
to go on to what properties we want to

00:15:24,370 --> 00:15:31,900
verify about this algorithm TLA plus is

00:15:28,360 --> 00:15:33,970
on typed for some reason you can read

00:15:31,900 --> 00:15:40,180
some of lamport's lectures on why he

00:15:33,970 --> 00:15:42,280
thinks on typing is better but well for

00:15:40,180 --> 00:15:44,410
to make sure you don't actually have any

00:15:42,280 --> 00:15:46,630
bugs in your studio code it's

00:15:44,410 --> 00:15:51,850
recommended to have a type invariant

00:15:46,630 --> 00:15:54,430
that describes what your what your

00:15:51,850 --> 00:15:58,840
variables are so basically here memories

00:15:54,430 --> 00:16:00,490
an array on the index by addresses with

00:15:58,840 --> 00:16:04,390
the Berenstain natural number exclusive

00:16:00,490 --> 00:16:08,680
monitored is can an array index by the

00:16:04,390 --> 00:16:13,990
CPU with values in addresses or open so

00:16:08,680 --> 00:16:15,970
I have this Union now in terms of

00:16:13,990 --> 00:16:18,970
properties we want to show about

00:16:15,970 --> 00:16:22,600
algorithms so one of the the invariant

00:16:18,970 --> 00:16:26,700
or safety properties here is the

00:16:22,600 --> 00:16:29,140
exclusiveness so we don't want to CPUs

00:16:26,700 --> 00:16:31,980
contending to different CPUs contending

00:16:29,140 --> 00:16:36,010
on the lock to be in the critical

00:16:31,980 --> 00:16:38,080
section at the same time so we write our

00:16:36,010 --> 00:16:40,000
exclusive invariant here so the

00:16:38,080 --> 00:16:43,600
invariants or safety properties or

00:16:40,000 --> 00:16:47,560
properties that should never happen in

00:16:43,600 --> 00:16:51,070
your execution we define the what

00:16:47,560 --> 00:16:53,290
theorem things here they are just purely

00:16:51,070 --> 00:16:57,880
for documentation you usually add your

00:16:53,290 --> 00:17:00,190
invariance to a configuration file so we

00:16:57,880 --> 00:17:02,500
have a configuration file for our model

00:17:00,190 --> 00:17:04,610
where we define the number of CPUs I put

00:17:02,500 --> 00:17:06,470
two CPUs in here I put only one address

00:17:04,610 --> 00:17:10,429
because you don't need more than that

00:17:06,470 --> 00:17:12,410
for our look and the invariants or the

00:17:10,429 --> 00:17:15,049
safety properties is typing variant and

00:17:12,410 --> 00:17:18,829
the exclusive invariant so all is fine

00:17:15,049 --> 00:17:23,089
you can prove those things now we go

00:17:18,829 --> 00:17:24,650
into lightness so as I said safety

00:17:23,089 --> 00:17:26,750
properties are properties they should

00:17:24,650 --> 00:17:29,780
never happen during execution liveness

00:17:26,750 --> 00:17:32,420
on the other hand are properties that

00:17:29,780 --> 00:17:36,740
should eventually happen during the

00:17:32,420 --> 00:17:43,429
execution and we want to show that

00:17:36,740 --> 00:17:45,710
actually because this spec in here it

00:17:43,429 --> 00:17:48,470
can be true or those exclusive invariant

00:17:45,710 --> 00:17:50,799
it can be true if actually the CPUs

00:17:48,470 --> 00:17:52,820
don't make any progress whatsoever so

00:17:50,799 --> 00:17:55,940
you never get them into the critical

00:17:52,820 --> 00:17:58,610
section so now we want to show that we

00:17:55,940 --> 00:18:01,700
want to verify that we actually get into

00:17:58,610 --> 00:18:05,410
the critical section with someone well

00:18:01,700 --> 00:18:08,330
at least some of this one of the CPUs

00:18:05,410 --> 00:18:10,309
because tle plus the lost infinite

00:18:08,330 --> 00:18:11,870
stuttering that means that for any state

00:18:10,309 --> 00:18:16,120
it can be an infinite state nothing

00:18:11,870 --> 00:18:19,250
could be changed from there we have to

00:18:16,120 --> 00:18:22,700
require that our specification is fair

00:18:19,250 --> 00:18:25,340
has some at least weak fairness in that

00:18:22,700 --> 00:18:27,500
it eventually makes progress so you

00:18:25,340 --> 00:18:30,740
expect your CPUs not to be stuck forever

00:18:27,500 --> 00:18:32,480
like power power tone you expect them to

00:18:30,740 --> 00:18:35,390
make progress and execute instructions

00:18:32,480 --> 00:18:37,910
so we do this by declaring putting the

00:18:35,390 --> 00:18:40,179
fair run notation in front of all

00:18:37,910 --> 00:18:43,040
process

00:18:40,179 --> 00:18:46,370
declaration that and what it actually

00:18:43,040 --> 00:18:48,230
does it extends our specification as

00:18:46,370 --> 00:18:51,100
I've seen as you can see above that

00:18:48,230 --> 00:18:55,130
aspect now games with fairness

00:18:51,100 --> 00:18:56,809
requirement so that the CPUs actually

00:18:55,130 --> 00:19:01,309
make progress all the CPUs make some

00:18:56,809 --> 00:19:04,700
progress and we want to show our

00:19:01,309 --> 00:19:07,460
likeness properties so one first

00:19:04,700 --> 00:19:11,090
property we'll check is there is at

00:19:07,460 --> 00:19:12,770
least in our implementation that makes

00:19:11,090 --> 00:19:15,169
progress that enters the critical

00:19:12,770 --> 00:19:17,320
section so PC is the variable that's

00:19:15,169 --> 00:19:19,740
generated by plus call they have a

00:19:17,320 --> 00:19:23,740
PC and the stack in the used for

00:19:19,740 --> 00:19:25,600
modeling execution so we're going to

00:19:23,740 --> 00:19:30,399
show that if the program counter for a

00:19:25,600 --> 00:19:33,700
CPU hits the start can see in here if it

00:19:30,399 --> 00:19:35,289
if it which is the start point then it

00:19:33,700 --> 00:19:38,919
eventually gets into the critical

00:19:35,289 --> 00:19:41,259
section so life lesson is that we have

00:19:38,919 --> 00:19:44,019
at least one CPU there is this the CPU

00:19:41,259 --> 00:19:47,620
aliveness all is the more stronger

00:19:44,019 --> 00:19:52,840
liveness property is that all CPUs enter

00:19:47,620 --> 00:19:55,299
the the critical section eventually now

00:19:52,840 --> 00:19:58,269
our simple spin lock implementation

00:19:55,299 --> 00:20:00,370
doesn't guarantee lightness because you

00:19:58,269 --> 00:20:03,129
can have one CPU starving the other so

00:20:00,370 --> 00:20:04,809
if you try to emulate this may notice a

00:20:03,129 --> 00:20:06,669
life in a stall if you can prove

00:20:04,809 --> 00:20:08,919
lightness all it implies lightness any

00:20:06,669 --> 00:20:11,350
in this case but yeah we try to show

00:20:08,919 --> 00:20:14,320
both with both properties in there and

00:20:11,350 --> 00:20:17,320
see which one fails liveness any passes

00:20:14,320 --> 00:20:20,409
the test likeness all doesn't so when

00:20:17,320 --> 00:20:23,590
you run this think it the TLA model

00:20:20,409 --> 00:20:27,340
checker comes up with this output as a

00:20:23,590 --> 00:20:29,350
temporal properties were violated and it

00:20:27,340 --> 00:20:33,730
gives us a counter example of what

00:20:29,350 --> 00:20:36,490
happens so it tells us where the PC is

00:20:33,730 --> 00:20:37,750
so just going briefly back here you can

00:20:36,490 --> 00:20:41,230
see in this in our spin lock

00:20:37,750 --> 00:20:44,289
implementation the l3 so labels we we

00:20:41,230 --> 00:20:46,960
have the store exclusive labor for is

00:20:44,289 --> 00:20:49,600
our check on what happened with the

00:20:46,960 --> 00:20:52,389
store exclusive so in this

00:20:49,600 --> 00:20:54,309
implementation heaters are that state 11

00:20:52,389 --> 00:20:56,799
so it gives us a trace of the execution

00:20:54,309 --> 00:21:01,570
so it tells us that at state 11 program

00:20:56,799 --> 00:21:04,990
counter was l4 on both cpu so both CPUs

00:21:01,570 --> 00:21:06,850
executed the store exclusive and if you

00:21:04,990 --> 00:21:09,610
check the status on the next line it

00:21:06,850 --> 00:21:11,200
means that P 2 failed because tourists

00:21:09,610 --> 00:21:15,519
close to the third one the status was

00:21:11,200 --> 00:21:18,909
set to 1 and P 1 is 0 means that P 1

00:21:15,519 --> 00:21:21,909
succeeded in in storing in taking the

00:21:18,909 --> 00:21:26,320
lock and the memory was updated so we

00:21:21,909 --> 00:21:29,500
have the address the value at address a1

00:21:26,320 --> 00:21:30,960
is 1 and the exclusive monitor is open

00:21:29,500 --> 00:21:34,140
on both CPUs so

00:21:30,960 --> 00:21:37,470
this stage in state 11 we have CPU one

00:21:34,140 --> 00:21:40,409
CPU p1 succeeding in taking the lock CPU

00:21:37,470 --> 00:21:41,940
to failed they both executed the store

00:21:40,409 --> 00:21:44,309
exclusive at the same time only one of

00:21:41,940 --> 00:21:48,450
them took the log now further down in

00:21:44,309 --> 00:21:53,279
the stack in the execution trace the

00:21:48,450 --> 00:21:59,669
behavior sequence we have state 25 where

00:21:53,279 --> 00:22:02,640
again we have p1 at position l4 it means

00:21:59,669 --> 00:22:04,320
that executed the store exclusive p2 is

00:22:02,640 --> 00:22:06,480
about to execute the store exclusive

00:22:04,320 --> 00:22:09,000
however it will fail because the

00:22:06,480 --> 00:22:10,799
exclusive monitor was cleared by the p1

00:22:09,000 --> 00:22:13,409
execution successful execution of the

00:22:10,799 --> 00:22:16,500
store exclusive so it tells us that now

00:22:13,409 --> 00:22:18,779
we go back to state 11 so in our

00:22:16,500 --> 00:22:21,870
execution trace we have a loop in this

00:22:18,779 --> 00:22:24,240
behavior graph we have a loop from state

00:22:21,870 --> 00:22:26,549
11 to stay 25 and then we never go to

00:22:24,240 --> 00:22:30,539
state 26 because it goes back to state

00:22:26,549 --> 00:22:31,620
11 so it found a loop where p2 never

00:22:30,539 --> 00:22:34,649
managed to get the lock

00:22:31,620 --> 00:22:39,149
so our life nests all property here that

00:22:34,649 --> 00:22:46,500
all CPUs eventually reach the critical

00:22:39,149 --> 00:22:51,419
section is violated so now we have a

00:22:46,500 --> 00:22:56,130
cute spin lock model which is aimed to

00:22:51,419 --> 00:22:58,590
guarantee liveness for all the CPUs also

00:22:56,130 --> 00:23:01,289
more scale scales better because all

00:22:58,590 --> 00:23:03,470
CPUs they they spin on their own data

00:23:01,289 --> 00:23:09,210
structure rather than having a common

00:23:03,470 --> 00:23:11,070
shared memory location to spin on one

00:23:09,210 --> 00:23:12,929
trig quiz or the cute spin lock

00:23:11,070 --> 00:23:17,730
implementation in Linux it's fairly

00:23:12,929 --> 00:23:23,850
complex because they spin it CPU spins

00:23:17,730 --> 00:23:27,029
on on MCS lock you can't have just one

00:23:23,850 --> 00:23:28,529
MCS lock per CPU because you have

00:23:27,029 --> 00:23:30,600
different nesting contexts for example

00:23:28,529 --> 00:23:34,080
you get an interrupt that may take a

00:23:30,600 --> 00:23:41,130
completely different lock so you need

00:23:34,080 --> 00:23:43,470
multiple MCS logs per CPU and Jelena

00:23:41,130 --> 00:23:49,919
suite called those nodes have the

00:23:43,470 --> 00:23:54,720
number of nodes in there per CPU well

00:23:49,919 --> 00:23:58,139
the way to model this so because we want

00:23:54,720 --> 00:24:00,330
to test all the combinations let us take

00:23:58,139 --> 00:24:03,169
take multiple nesting context in there

00:24:00,330 --> 00:24:05,580
and see whether our implementation

00:24:03,169 --> 00:24:08,490
well we spot any any issues with the

00:24:05,580 --> 00:24:12,840
implementation the way we model is know

00:24:08,490 --> 00:24:16,240
is not just with one thread per CPU

00:24:12,840 --> 00:24:17,480
actually one thread per CPU note and

00:24:16,240 --> 00:24:20,850
[Music]

00:24:17,480 --> 00:24:23,549
give some ASCII art in here so we have

00:24:20,850 --> 00:24:28,679
for each CPU we have multiple threads as

00:24:23,549 --> 00:24:31,860
a couple of p1 well the top of the node

00:24:28,679 --> 00:24:36,210
and the CPU and we model it has multiple

00:24:31,860 --> 00:24:41,399
spin locks so each node or say nesting

00:24:36,210 --> 00:24:43,830
context it's they they content on on the

00:24:41,399 --> 00:24:47,129
same queue spin lock so now we have a

00:24:43,830 --> 00:24:54,350
model this as you know multiple spin

00:24:47,129 --> 00:25:00,600
locks being taken by multiple threads so

00:24:54,350 --> 00:25:03,419
in the in the configuration file we have

00:25:00,600 --> 00:25:06,570
as we've seen with the simple spin lock

00:25:03,419 --> 00:25:08,429
implementation the same the set of CPUs

00:25:06,570 --> 00:25:12,210
I didn't bother with a memory here

00:25:08,429 --> 00:25:15,240
because the memory is not relevant in

00:25:12,210 --> 00:25:18,840
this case we don't have a load store

00:25:15,240 --> 00:25:20,940
exclusive to emulate have a maximum max

00:25:18,840 --> 00:25:22,740
nodes and pending loops is something in

00:25:20,940 --> 00:25:25,049
the in the queue spin lock

00:25:22,740 --> 00:25:31,470
implementation in Linux just to some

00:25:25,049 --> 00:25:34,620
optimization also define some of for

00:25:31,470 --> 00:25:36,389
example now CPU is a way to defy the CPU

00:25:34,620 --> 00:25:39,629
like I mean they don't have a CPU

00:25:36,389 --> 00:25:42,059
assigned some some extra values and here

00:25:39,629 --> 00:25:47,009
they help with converting the algorithm

00:25:42,059 --> 00:25:49,590
from C into a into Pascal it's not a

00:25:47,009 --> 00:25:52,559
straightforward translation but it's

00:25:49,590 --> 00:25:53,549
fairly close now I don't have time to go

00:25:52,559 --> 00:25:56,429
through all the queue spinlock

00:25:53,549 --> 00:25:57,180
implementation here threads as I said

00:25:56,429 --> 00:26:02,220
there

00:25:57,180 --> 00:26:04,770
they're modeled as we have we have one

00:26:02,220 --> 00:26:06,809
thread per CPU per node so we just

00:26:04,770 --> 00:26:09,870
declare the thread as a continuum

00:26:06,809 --> 00:26:17,190
product between the CPUs and the number

00:26:09,870 --> 00:26:20,730
of nodes and the types introduced in

00:26:17,190 --> 00:26:25,350
plus car they match fairly closely if

00:26:20,730 --> 00:26:26,730
you other way see on the right in the

00:26:25,350 --> 00:26:30,480
comment on the right hand side you can

00:26:26,730 --> 00:26:32,280
see the actual C implementation see data

00:26:30,480 --> 00:26:37,110
structure that we have forked spinlock

00:26:32,280 --> 00:26:41,190
in Linux it's a union in plus call you

00:26:37,110 --> 00:26:45,000
just use the the set theory that helps

00:26:41,190 --> 00:26:48,360
here defining the structure again kill

00:26:45,000 --> 00:26:51,090
load type is just like a set on the

00:26:48,360 --> 00:26:55,650
domain representing the log pending tail

00:26:51,090 --> 00:26:57,690
index tell CPUs so that's how you define

00:26:55,650 --> 00:27:03,990
the types for your data structure locked

00:26:57,690 --> 00:27:05,970
is a boolean tail index we don't have

00:27:03,990 --> 00:27:08,100
like a 16-bit we have in this

00:27:05,970 --> 00:27:11,850
implementation here I added this as two

00:27:08,100 --> 00:27:17,190
separate items for the index and and the

00:27:11,850 --> 00:27:20,730
CPU and the MCS log type that's

00:27:17,190 --> 00:27:23,130
something it that's that variable its

00:27:20,730 --> 00:27:30,120
CPU spins on while we're waiting on a

00:27:23,130 --> 00:27:33,450
cue adding some constructors again for

00:27:30,120 --> 00:27:38,990
initializing some of the variables in

00:27:33,450 --> 00:27:42,590
Linux I'm going to go over them and

00:27:38,990 --> 00:27:46,040
that's where what we have so that's

00:27:42,590 --> 00:27:49,740
those are the variables that we use for

00:27:46,040 --> 00:27:51,540
for our simulation here we have the cue

00:27:49,740 --> 00:27:56,040
spin loop we have one two spin loop that

00:27:51,540 --> 00:27:59,309
node initialize to unlock and we have

00:27:56,040 --> 00:28:03,390
one MCS lock per thread which means per

00:27:59,309 --> 00:28:05,190
CPU per node and that's it's a way

00:28:03,390 --> 00:28:08,130
there's a way to initialize variables in

00:28:05,190 --> 00:28:10,590
plus call and some access source that

00:28:08,130 --> 00:28:13,919
you throw the algorithm now

00:28:10,590 --> 00:28:20,299
see the full implementation is on my

00:28:13,919 --> 00:28:24,690
camel TL a git repository in terms of

00:28:20,299 --> 00:28:27,990
invariants and we are safety properties

00:28:24,690 --> 00:28:30,240
here is usually the type invariant we

00:28:27,990 --> 00:28:33,179
want to make sure we don't mess up

00:28:30,240 --> 00:28:36,659
something in the algorithm I have the

00:28:33,179 --> 00:28:41,190
typing and for the exclusive invariant

00:28:36,659 --> 00:28:43,110
we own that any threads contending on on

00:28:41,190 --> 00:28:45,840
the same lock they can be in the

00:28:43,110 --> 00:28:51,120
critical section at the same time so as

00:28:45,840 --> 00:28:53,309
I shown in here we have we actually have

00:28:51,120 --> 00:28:57,929
multiple Q spin locks and multiple

00:28:53,309 --> 00:28:59,760
threads and yeah we allow the p11 thread

00:28:57,929 --> 00:29:04,250
to be in the critical section at the

00:28:59,760 --> 00:29:07,380
same time with a p21 no two threads so

00:29:04,250 --> 00:29:10,230
it doesn't this is the log we just don't

00:29:07,380 --> 00:29:12,029
want the same the two CPUs contending on

00:29:10,230 --> 00:29:18,510
the same lock on keys to spin lock one

00:29:12,029 --> 00:29:20,190
to be in the critical section so yeah

00:29:18,510 --> 00:29:22,049
the way you write an exclusive

00:29:20,190 --> 00:29:23,490
invariants here say for any different

00:29:22,049 --> 00:29:25,730
any two threads running on different

00:29:23,490 --> 00:29:28,260
CPUs and contending on the same lock

00:29:25,730 --> 00:29:33,809
they can't be in the critical section at

00:29:28,260 --> 00:29:39,929
the same time in terms of lightness so

00:29:33,809 --> 00:29:42,570
liveness any that that's verified just

00:29:39,929 --> 00:29:46,020
fine is there is at least one thread

00:29:42,570 --> 00:29:47,250
that once started it enters the critical

00:29:46,020 --> 00:29:50,820
eventually and there's the critical

00:29:47,250 --> 00:29:53,549
section for the lightness all we want

00:29:50,820 --> 00:29:56,970
actually we can't guarantee that over

00:29:53,549 --> 00:29:59,460
the CPUs enter while all the threads

00:29:56,970 --> 00:30:02,130
enter the critical section what we want

00:29:59,460 --> 00:30:04,169
to show here that all CPUs actually

00:30:02,130 --> 00:30:07,710
enter a critical section at some nesting

00:30:04,169 --> 00:30:10,919
context so in this case here we have the

00:30:07,710 --> 00:30:14,340
one node one we have that let's say we

00:30:10,919 --> 00:30:16,409
have the task in the past context

00:30:14,340 --> 00:30:18,090
innings in the process context they try

00:30:16,409 --> 00:30:20,370
to acquire the cue spin lock you can get

00:30:18,090 --> 00:30:23,850
an interrupt it tries to acquire another

00:30:20,370 --> 00:30:25,920
spin lock now because we

00:30:23,850 --> 00:30:27,690
can't guarantee that we can get a

00:30:25,920 --> 00:30:31,980
continuous interrupt so you can't always

00:30:27,690 --> 00:30:35,340
guarantee that the task process thread

00:30:31,980 --> 00:30:36,720
actually enters the critical section if

00:30:35,340 --> 00:30:38,910
you get an interrupt the continuous

00:30:36,720 --> 00:30:43,470
interrupt so the way we specify this is

00:30:38,910 --> 00:30:46,920
that on one CPU so on all CPU CPUs we

00:30:43,470 --> 00:30:54,840
have at least one nesting context that

00:30:46,920 --> 00:30:57,120
enters the critical section so here yeah

00:30:54,840 --> 00:31:01,200
so that's the liveness also for all CPUs

00:30:57,120 --> 00:31:04,260
there exist a node for which the program

00:31:01,200 --> 00:31:06,750
counter as I said the threads are

00:31:04,260 --> 00:31:12,000
represented as topples of processor and

00:31:06,750 --> 00:31:13,980
node so we have at least one thread on

00:31:12,000 --> 00:31:21,150
that CPU that enters the critical

00:31:13,980 --> 00:31:24,120
section now findings so when I run on

00:31:21,150 --> 00:31:26,190
the first model we yeah it didn't make

00:31:24,120 --> 00:31:29,070
progress there were some infinite loops

00:31:26,190 --> 00:31:32,220
in the queue spinlock implementation

00:31:29,070 --> 00:31:35,160
that we're not making any progress in

00:31:32,220 --> 00:31:36,900
there so I guess looking at that after I

00:31:35,160 --> 00:31:38,340
model did no it's pretty obvious that

00:31:36,900 --> 00:31:40,800
those infinite loops may not actually

00:31:38,340 --> 00:31:43,890
make progress so there are some weird

00:31:40,800 --> 00:31:45,450
scenarios so the two CPUs one was

00:31:43,890 --> 00:31:49,320
probably easier to reason about there

00:31:45,450 --> 00:31:53,520
was a three CPU scenario where the two

00:31:49,320 --> 00:31:57,240
spinlock did not make any progress so

00:31:53,520 --> 00:32:01,020
the first two commits from from where

00:31:57,240 --> 00:32:06,440
Deacon he actually are all the loops

00:32:01,020 --> 00:32:10,200
remove them so they fixed the liveness

00:32:06,440 --> 00:32:12,270
properties for forearm 64 with LSD

00:32:10,200 --> 00:32:16,440
atomic so elysia Thomas is an addition

00:32:12,270 --> 00:32:18,960
to arm B 8.1 architecture the current e

00:32:16,440 --> 00:32:20,670
has some progress versus the store load

00:32:18,960 --> 00:32:25,200
store exclusive that don't have such

00:32:20,670 --> 00:32:28,890
guarantees so in this I think in the

00:32:25,200 --> 00:32:32,940
last merging window bit resistor also

00:32:28,890 --> 00:32:36,450
sent a patch merge the patch to fix the

00:32:32,940 --> 00:32:37,200
comp exchange loop on x86 that again was

00:32:36,450 --> 00:32:41,309
not

00:32:37,200 --> 00:32:43,440
giving us the liveness guarantees so

00:32:41,309 --> 00:32:46,740
with those changes the model also also

00:32:43,440 --> 00:32:51,769
verifies the liveness all property now

00:32:46,740 --> 00:32:55,559
some some drawbacks here this model is

00:32:51,769 --> 00:32:57,510
what doesn't doesn't model the memory

00:32:55,559 --> 00:33:01,769
ordering semantics so it's sequential

00:32:57,510 --> 00:33:03,870
consistency only one could build an

00:33:01,769 --> 00:33:05,210
operational model on top of this and

00:33:03,870 --> 00:33:11,820
[Music]

00:33:05,210 --> 00:33:14,610
model it but it's the you get the state

00:33:11,820 --> 00:33:19,710
space growth grows significantly so may

00:33:14,610 --> 00:33:22,440
not finish in your lifetime so it's a

00:33:19,710 --> 00:33:24,360
complex algorithm as well and yeah so

00:33:22,440 --> 00:33:26,669
for example I finished checking is for

00:33:24,360 --> 00:33:29,429
two threads is under one minute a few

00:33:26,669 --> 00:33:31,590
hours for three threads and days for

00:33:29,429 --> 00:33:34,610
four threads and I think I try some more

00:33:31,590 --> 00:33:34,610
but it ran out of memory

00:33:35,870 --> 00:33:40,669
yeah invariant checking so if you want

00:33:38,730 --> 00:33:46,740
just to check the safety properties

00:33:40,669 --> 00:33:50,330
that's a significantly faster and it has

00:33:46,740 --> 00:33:54,690
a way to add some symmetry optimization

00:33:50,330 --> 00:33:56,039
it tries to so Tilly plus can check so

00:33:54,690 --> 00:33:57,929
your program doesn't need to terminate

00:33:56,039 --> 00:34:01,049
you can have infinite loops in your in

00:33:57,929 --> 00:34:04,320
your model you just need to have a

00:34:01,049 --> 00:34:06,690
finite set of states now if you had the

00:34:04,320 --> 00:34:08,369
symmetry optimizations you tell it you

00:34:06,690 --> 00:34:10,409
have some permutations in there you

00:34:08,369 --> 00:34:12,000
don't care whether it's p1 or p2 the

00:34:10,409 --> 00:34:13,560
name in which order you tell them this

00:34:12,000 --> 00:34:16,679
is the same CPU the algorithm is

00:34:13,560 --> 00:34:20,879
symmetric on p1 and p2 and in that case

00:34:16,679 --> 00:34:23,310
it can squash the I can squash the state

00:34:20,879 --> 00:34:26,220
space so it's much faster if you only do

00:34:23,310 --> 00:34:28,230
invariant checking life nest checking

00:34:26,220 --> 00:34:31,379
cannot be done with symmetry

00:34:28,230 --> 00:34:34,800
optimizations because it may wrongly

00:34:31,379 --> 00:34:38,159
detect some loops in your execution

00:34:34,800 --> 00:34:41,099
trace and wrongly tell you that your

00:34:38,159 --> 00:34:45,780
lightness property spare also it has a

00:34:41,099 --> 00:34:48,510
simulate mode so that just checks random

00:34:45,780 --> 00:34:50,020
behaviors is like a depth-first search

00:34:48,510 --> 00:34:54,040
up to a max

00:34:50,020 --> 00:34:56,860
in depth and quietly for example the

00:34:54,040 --> 00:34:59,680
armed 64 the a seed allocation algorithm

00:34:56,860 --> 00:35:04,300
it was taking about a day and a half

00:34:59,680 --> 00:35:06,160
from six were emulating six CPUs taken

00:35:04,300 --> 00:35:08,110
like a day and a half to to hit the bug

00:35:06,160 --> 00:35:11,230
and was taken like five minutes is

00:35:08,110 --> 00:35:13,210
simulated not the downside that the

00:35:11,230 --> 00:35:15,670
simulation is that it's not always the

00:35:13,210 --> 00:35:19,330
shortest path to get there so you get

00:35:15,670 --> 00:35:22,810
like something 185 execution steps and

00:35:19,330 --> 00:35:29,680
then it just is pretty hard to actually

00:35:22,810 --> 00:35:33,580
figure out where things went wrong so

00:35:29,680 --> 00:35:37,660
ideas for future models if people are

00:35:33,580 --> 00:35:41,200
interested I I managed to trick one guy

00:35:37,660 --> 00:35:44,080
in my what joined our team as a graduate

00:35:41,200 --> 00:35:47,470
on rotation so wanted to do camera work

00:35:44,080 --> 00:35:51,040
so I tricked him into doing this he did

00:35:47,470 --> 00:35:57,310
the KVM and we geek model so it's pretty

00:35:51,040 --> 00:36:00,130
cool but and yeah there are lots of

00:35:57,310 --> 00:36:01,570
things the model if one has time may

00:36:00,130 --> 00:36:05,100
look at some of them there are

00:36:01,570 --> 00:36:07,420
interesting properties to to prove and

00:36:05,100 --> 00:36:14,790
of course there are other tools out

00:36:07,420 --> 00:36:17,950
there reason I I used TL A+ was many was

00:36:14,790 --> 00:36:21,160
relatively easy to define what to

00:36:17,950 --> 00:36:22,480
specify liveness properties most of the

00:36:21,160 --> 00:36:24,900
tools I've seen they don't handle

00:36:22,480 --> 00:36:27,790
lightness you have to figure out how to

00:36:24,900 --> 00:36:31,540
check lightness in your algorithm but

00:36:27,790 --> 00:36:34,570
let's say for example adding your own

00:36:31,540 --> 00:36:37,600
assets in there that you don't have some

00:36:34,570 --> 00:36:40,300
loops in your algorithm with ta+ it kind

00:36:37,600 --> 00:36:45,450
of keep keep your properties separate

00:36:40,300 --> 00:36:47,950
from your specification so that's why I

00:36:45,450 --> 00:36:52,770
used it so far but yeah there are other

00:36:47,950 --> 00:36:52,770
tools out there and I think this state

00:36:59,049 --> 00:37:06,079
okay I'm on the rebound on the RC left a

00:37:02,689 --> 00:37:07,939
model yes there are they configured

00:37:06,079 --> 00:37:10,579
things down to the bare minimum to make

00:37:07,939 --> 00:37:12,890
it fit in their tool so they didn't they

00:37:10,579 --> 00:37:14,569
didn't model Priam trampled are see you

00:37:12,890 --> 00:37:15,979
they didn't Ronald priority boosting

00:37:14,569 --> 00:37:17,949
they didn't model the energy efficiency

00:37:15,979 --> 00:37:22,579
they didn't model a relationship to Idol

00:37:17,949 --> 00:37:23,089
and so yeah but if they did the easy

00:37:22,579 --> 00:37:26,329
part

00:37:23,089 --> 00:37:31,939
yeah I think still hard and stressed

00:37:26,329 --> 00:37:35,209
their tool yeah so even we had for

00:37:31,939 --> 00:37:41,839
example in some of the my examples here

00:37:35,209 --> 00:37:43,400
they verified the I think the kpti we

00:37:41,839 --> 00:37:45,769
have software panas privileged access

00:37:43,400 --> 00:37:50,569
neighbor and kpti is this thing where we

00:37:45,769 --> 00:37:52,579
was security feature we disable well we

00:37:50,569 --> 00:37:54,289
disable the the access to the camel

00:37:52,579 --> 00:37:56,749
pasted page tables we're in userspace

00:37:54,289 --> 00:37:58,910
that's a meltdown mitigation and we

00:37:56,749 --> 00:38:00,589
actually had the box they're modeling

00:37:58,910 --> 00:38:02,689
they said to add a lot of the preemption

00:38:00,589 --> 00:38:05,209
stuff is not even built into plus call

00:38:02,689 --> 00:38:11,420
so you have to hack some TLA plus on top

00:38:05,209 --> 00:38:14,900
of Pascal to simulate preemption and but

00:38:11,420 --> 00:38:20,019
it's once you understand it gets quite

00:38:14,900 --> 00:38:20,019
easy so questions

00:38:27,840 --> 00:38:36,150
doesn't work is there any connection to

00:38:31,870 --> 00:38:36,150
the code that actually runs sorry

00:38:41,550 --> 00:38:53,230
that's what race there is a connection

00:38:49,420 --> 00:38:56,380
so this mainly is the aim is to verify

00:38:53,230 --> 00:38:58,240
the algorithm so it swamp or to say the

00:38:56,380 --> 00:39:04,810
algorithms are verified the programs are

00:38:58,240 --> 00:39:08,410
executed so so that's modeling

00:39:04,810 --> 00:39:13,090
high-level algorithms and there is no

00:39:08,410 --> 00:39:15,610
word direct connection from from the

00:39:13,090 --> 00:39:17,610
Pascal model to like have some kind

00:39:15,610 --> 00:39:19,930
of--the ommited conversion there was a

00:39:17,610 --> 00:39:24,700
someone there was a PhD thesis on

00:39:19,930 --> 00:39:26,740
converting C to TL a-plus but they

00:39:24,700 --> 00:39:29,410
didn't go very far I think they just was

00:39:26,740 --> 00:39:34,120
a proof of concept and I haven't heard

00:39:29,410 --> 00:39:35,620
anything since and yeah the the actual

00:39:34,120 --> 00:39:38,070
thing is that the algorithm is the

00:39:35,620 --> 00:39:38,070
connection

00:39:44,670 --> 00:39:50,440
you mentioned it only verifies

00:39:47,470 --> 00:39:52,390
sequential consistency what sorts of

00:39:50,440 --> 00:39:55,420
things would you need to do for a week

00:39:52,390 --> 00:39:58,599
in memory model how would you even go

00:39:55,420 --> 00:40:01,569
about describing that to something like

00:39:58,599 --> 00:40:04,210
a plus or plus count well you'd have to

00:40:01,569 --> 00:40:06,309
describe so the simplest would be to go

00:40:04,210 --> 00:40:08,769
for an operational model let's say you

00:40:06,309 --> 00:40:11,019
model the right buffer and instead of

00:40:08,769 --> 00:40:13,420
updating a variable you send something

00:40:11,019 --> 00:40:15,609
to the right buffer and then you

00:40:13,420 --> 00:40:19,329
describe all the behaviors of that right

00:40:15,609 --> 00:40:22,990
buffer it can reorder stuff and yeah it

00:40:19,329 --> 00:40:26,069
increases your state space quite a bit

00:40:22,990 --> 00:40:28,960
but it's doable I mean up when

00:40:26,069 --> 00:40:30,789
poor-man's approaches - okay I update

00:40:28,960 --> 00:40:32,769
this variable and this variable what

00:40:30,789 --> 00:40:34,809
happens if they are seen in a different

00:40:32,769 --> 00:40:36,579
order you just swap them as yeah and it

00:40:34,809 --> 00:40:41,109
doesn't work but that's like a poor

00:40:36,579 --> 00:40:42,700
man's hack so I think for if you are

00:40:41,109 --> 00:40:46,660
interested in memory model in there are

00:40:42,700 --> 00:40:48,369
other tools out there and it's not the

00:40:46,660 --> 00:40:50,140
ball I mean it used locks in here but as

00:40:48,369 --> 00:40:53,230
you can see from from those examples

00:40:50,140 --> 00:40:56,009
it's not about locks it's about modeling

00:40:53,230 --> 00:40:56,009
other algorithms

00:41:01,320 --> 00:41:06,370
so how long does it take you to write

00:41:03,790 --> 00:41:08,400
these models you start with the code and

00:41:06,370 --> 00:41:12,400
then write the model

00:41:08,400 --> 00:41:13,660
well actually while it initially took me

00:41:12,400 --> 00:41:17,290
some time because I had to read the

00:41:13,660 --> 00:41:21,700
documentation but I think for the cute

00:41:17,290 --> 00:41:24,130
spinlock it took me like two three days

00:41:21,700 --> 00:41:26,290
to translate the cute spinlock

00:41:24,130 --> 00:41:28,540
implementation from linux 2 plus call

00:41:26,290 --> 00:41:34,420
and I have to admit I didn't even fully

00:41:28,540 --> 00:41:36,280
understand it so it's like you can do a

00:41:34,420 --> 00:41:39,070
mechanical translation well then then I

00:41:36,280 --> 00:41:43,780
actually try to understand it some more

00:41:39,070 --> 00:41:45,640
but what the corner case is in there so

00:41:43,780 --> 00:41:48,430
it doesn't take too long you can see

00:41:45,640 --> 00:41:51,730
here I have a is not the best example

00:41:48,430 --> 00:41:55,570
here well it emulates instructions but

00:41:51,730 --> 00:41:57,430
it's pretty close to C so apart from

00:41:55,570 --> 00:42:00,850
someone knowing stuff or where you need

00:41:57,430 --> 00:42:05,980
to put semi colors but otherwise it's

00:42:00,850 --> 00:42:08,920
it's not that far and it's quite

00:42:05,980 --> 00:42:12,610
flexible in terms of the because it

00:42:08,920 --> 00:42:14,020
handles the set theory quite well so

00:42:12,610 --> 00:42:15,850
it's quite flexible on how you define

00:42:14,020 --> 00:42:17,880
your data structures you don't need to

00:42:15,850 --> 00:42:22,270
think of how you pack stuff into bits

00:42:17,880 --> 00:42:25,360
you just for example you just define

00:42:22,270 --> 00:42:26,950
okay I have this data layout in that and

00:42:25,360 --> 00:42:28,660
just describe I don't care about the bit

00:42:26,950 --> 00:42:30,720
layout as you can see on the C

00:42:28,660 --> 00:42:30,720
implementation

00:42:46,610 --> 00:42:56,820
so in theory could could you use the key

00:42:52,370 --> 00:42:59,940
that looks yes so that looks is more

00:42:56,820 --> 00:43:02,880
like a lightness condition so it detects

00:42:59,940 --> 00:43:05,910
two types of deadlocks TLA plus so it

00:43:02,880 --> 00:43:10,560
has one it really spots it when for

00:43:05,910 --> 00:43:12,450
example you have this was it so plus

00:43:10,560 --> 00:43:15,120
called translates into something like

00:43:12,450 --> 00:43:18,660
this for example and it needs that an

00:43:15,120 --> 00:43:21,360
action like tick or current only takes

00:43:18,660 --> 00:43:23,490
place if the condition is true so if it

00:43:21,360 --> 00:43:27,770
is enabled like T equal a stick in there

00:43:23,490 --> 00:43:30,120
so if your model if all your actions are

00:43:27,770 --> 00:43:33,030
disabled there is no condition that girl

00:43:30,120 --> 00:43:35,520
then lost next to make a progress it

00:43:33,030 --> 00:43:37,500
tells you deadlock you can have some

00:43:35,520 --> 00:43:38,370
other types of like Ally flow for

00:43:37,500 --> 00:43:41,030
example you have a spin lock

00:43:38,370 --> 00:43:46,680
implementation that keeps spinning

00:43:41,030 --> 00:43:48,810
that's a deadlock for example but T le

00:43:46,680 --> 00:43:49,980
plus still seeing some action so we want

00:43:48,810 --> 00:43:53,910
to report it you have to add the

00:43:49,980 --> 00:43:55,470
liveness property in the I can push

00:43:53,910 --> 00:43:57,260
termination as well but it wasn't the

00:43:55,470 --> 00:44:01,640
case here because we had infinite loops

00:43:57,260 --> 00:44:01,640
so it's another liveness condition

00:44:08,530 --> 00:44:16,489
okay thank you

00:44:10,850 --> 00:44:16,489

YouTube URL: https://www.youtube.com/watch?v=qeUHlXOBXmg


