Title: LPC2018 - Filename encoding and case-insensitive filesystems
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/242/
speaker:  Gabriel Krisman Bertazi (Collabora)

Case-insensitive file name lookups is a recurrent topic on Linux filesystems, but its stalled development has regained traction in the past few years, thanks to its applications in platforms like Valve's SteamOS and Android. Despite aiming at simplifying the file lookup operation from a user point of view, since human languages don't directly correlate to arbitrary case folding and encoding composition premises, the actual implementation of encoding and case-insensitive awareness carry an outstanding number of issues and corner cases, which require a clear behavioral definition from the file system layer in order to get it right. File systems developers are invited to come discuss such premises and what is expected from an in-kernel common encoding and case-insensitive abstraction for file systems.
Captions: 
	00:00:06,690 --> 00:00:13,300
I've been working on this feature of fun

00:00:10,300 --> 00:00:16,090
and encoding with going to implement

00:00:13,300 --> 00:00:18,700
support for case insensitive Ness on

00:00:16,090 --> 00:00:22,150
some file systems my first effort has

00:00:18,700 --> 00:00:25,329
been on ext4 and this is a feature that

00:00:22,150 --> 00:00:26,800
has been requested many many times there

00:00:25,329 --> 00:00:30,000
has been discussions on this for a long

00:00:26,800 --> 00:00:31,270
time I believe that right before me in

00:00:30,000 --> 00:00:34,300
00:00:31,270 --> 00:00:38,560
Ted made a proposal to implement this on

00:00:34,300 --> 00:00:41,710
ext4 before that we have some proposal

00:00:38,560 --> 00:00:44,940
to implement it on it EXIF as in 2014

00:00:41,710 --> 00:00:48,700
I've seen discussions of this in 2008

00:00:44,940 --> 00:00:52,360
the oldest discussion I saw was in 2002

00:00:48,700 --> 00:00:54,220
I think but I'm pretty sure people were

00:00:52,360 --> 00:00:58,000
discussing about this way before that

00:00:54,220 --> 00:01:02,140
and the reason why it hasn't moved it

00:00:58,000 --> 00:01:03,850
forward is one it's a bit tricky to get

00:01:02,140 --> 00:01:07,659
it right there are many many corners

00:01:03,850 --> 00:01:11,700
corner places but I believe we have come

00:01:07,659 --> 00:01:16,560
to to an implementation that is close to

00:01:11,700 --> 00:01:16,560
so most of these corner cases now

00:01:21,500 --> 00:01:30,750
yes yes sorry in XFS you have you have

00:01:26,550 --> 00:01:32,850
an implementation that a panic and kfs

00:01:30,750 --> 00:01:35,010
time you were able to select if you want

00:01:32,850 --> 00:01:38,190
your disk to be case insensitive or not

00:01:35,010 --> 00:01:40,650
this is going to apply this white and I

00:01:38,190 --> 00:01:42,060
believe it song is asking only right you

00:01:40,650 --> 00:01:46,110
don't have support for other encodings

00:01:42,060 --> 00:01:48,540
if I'm correct the proposal I mentioned

00:01:46,110 --> 00:01:51,660
in 2014 and sorry it was a proposal to

00:01:48,540 --> 00:01:55,950
implement through utf-8 normalization

00:01:51,660 --> 00:01:57,990
and case folding supports so why am

00:01:55,950 --> 00:01:59,940
encoding a where file system well

00:01:57,990 --> 00:02:03,540
traditional unix file systems have

00:01:59,940 --> 00:02:06,090
always relied on the on the assumption

00:02:03,540 --> 00:02:09,570
that filenames are backed by sequences

00:02:06,090 --> 00:02:13,770
or they are simply car strings new

00:02:09,570 --> 00:02:15,989
terminated any file any set of

00:02:13,770 --> 00:02:17,970
characters is a valid file name if you

00:02:15,989 --> 00:02:21,930
don't have a slash or if it's not the

00:02:17,970 --> 00:02:24,630
new directory in the middle but but why

00:02:21,930 --> 00:02:26,670
do we are gonna do this now because

00:02:24,630 --> 00:02:28,350
other people have are doing this and

00:02:26,670 --> 00:02:30,690
have been doing this for for a very long

00:02:28,350 --> 00:02:32,370
time Windows has it Apple had it on

00:02:30,690 --> 00:02:34,470
their previous file system and now only

00:02:32,370 --> 00:02:36,209
there a key F a file system they also

00:02:34,470 --> 00:02:39,000
support it and because there are

00:02:36,209 --> 00:02:40,830
real-world use cases for this mainly

00:02:39,000 --> 00:02:45,840
porting stuff bringing stuff from the

00:02:40,830 --> 00:02:52,019
windows world Android also exposes some

00:02:45,840 --> 00:02:54,120
casing sensitive interface and as a

00:02:52,019 --> 00:02:56,310
result of this work we can also offer a

00:02:54,120 --> 00:02:57,720
way better support for exported file

00:02:56,310 --> 00:03:01,350
systems that are coming from those

00:02:57,720 --> 00:03:03,660
worlds and at least I believe in the

00:03:01,350 --> 00:03:08,070
Android case they work with a user space

00:03:03,660 --> 00:03:09,840
hack I'm not sure if it's fuse but there

00:03:08,070 --> 00:03:11,610
there are always problems with the user

00:03:09,840 --> 00:03:13,950
space hacks in this approach they are

00:03:11,610 --> 00:03:17,280
usually slow they have a severe

00:03:13,950 --> 00:03:24,090
performance hit and they have to deal

00:03:17,280 --> 00:03:26,940
with many many race conditions what the

00:03:24,090 --> 00:03:29,400
best example that interests me on why we

00:03:26,940 --> 00:03:31,670
should be doing encoding file systems is

00:03:29,400 --> 00:03:34,970
that it's it's it's

00:03:31,670 --> 00:03:37,130
better way to expose this to users we

00:03:34,970 --> 00:03:40,490
have an understanding that file file

00:03:37,130 --> 00:03:43,640
names are unique and they are inside the

00:03:40,490 --> 00:03:45,410
same directory but the uniqueness we are

00:03:43,640 --> 00:03:48,290
talking about does not translate well to

00:03:45,410 --> 00:03:51,459
real-world languages so despite all

00:03:48,290 --> 00:03:55,550
these four files being unique in a byte

00:03:51,459 --> 00:04:00,260
sense when they when it gets rendered

00:03:55,550 --> 00:04:02,209
into any program to display files you

00:04:00,260 --> 00:04:04,459
can actually see you cannot actually see

00:04:02,209 --> 00:04:06,890
any difference between them if you look

00:04:04,459 --> 00:04:09,800
at the inode numbers you can verify that

00:04:06,890 --> 00:04:11,360
those are different files but they show

00:04:09,800 --> 00:04:13,220
they all have the same name when

00:04:11,360 --> 00:04:15,290
rendered and the reason for that is that

00:04:13,220 --> 00:04:18,079
each of these files were created with a

00:04:15,290 --> 00:04:22,900
slightly different equivalent version of

00:04:18,079 --> 00:04:25,100
the same string using a utf-8

00:04:22,900 --> 00:04:28,160
decomposition and Composition techniques

00:04:25,100 --> 00:04:31,669
so in a file system that is encoding

00:04:28,160 --> 00:04:36,169
aware we should be able to consider

00:04:31,669 --> 00:04:41,090
those all the same files which is clear

00:04:36,169 --> 00:04:44,000
for the user it's more obvious give the

00:04:41,090 --> 00:04:47,780
user an easy way to to figure out which

00:04:44,000 --> 00:04:49,790
file he's looking for this is

00:04:47,780 --> 00:04:54,020
particularly true when you're talking

00:04:49,790 --> 00:04:58,000
about non-english speakers because for

00:04:54,020 --> 00:05:00,320
the English language you don't have any

00:04:58,000 --> 00:05:02,180
normalization issues that I can think of

00:05:00,320 --> 00:05:04,390
that are gonna result in this situation

00:05:02,180 --> 00:05:08,600
if you think of the lower ASCII

00:05:04,390 --> 00:05:10,370
character set but we are working with

00:05:08,600 --> 00:05:11,840
people from all around the world so it's

00:05:10,370 --> 00:05:15,710
more than fair that we have a good

00:05:11,840 --> 00:05:19,850
support for everyone and another reason

00:05:15,710 --> 00:05:22,310
of why I want to do encoding inside the

00:05:19,850 --> 00:05:24,320
file system is that I'm really

00:05:22,310 --> 00:05:26,020
interested in case in sensitiveness in

00:05:24,320 --> 00:05:30,080
the ability to look for a file

00:05:26,020 --> 00:05:33,410
regardless of the case and I have a real

00:05:30,080 --> 00:05:35,870
hard time defining what case is if you

00:05:33,410 --> 00:05:37,669
don't have an encoding so if you are

00:05:35,870 --> 00:05:40,340
consider you simply abide sequence what

00:05:37,669 --> 00:05:41,000
is upper case and lower case that that's

00:05:40,340 --> 00:05:44,580
meaningless

00:05:41,000 --> 00:05:46,379
so for all string case compare up

00:05:44,580 --> 00:05:50,009
you need to have a definition of what

00:05:46,379 --> 00:05:53,030
that might sequence is and that's why I

00:05:50,009 --> 00:05:56,780
won't implement encoding before putting

00:05:53,030 --> 00:05:59,960
case-insensitive mr. so there is already

00:05:56,780 --> 00:06:02,969
an effort in the kernel to handle

00:05:59,960 --> 00:06:05,490
character encoding it's the MLS native

00:06:02,969 --> 00:06:07,949
language support lies it exists inside

00:06:05,490 --> 00:06:12,419
the file system directly in the kernel

00:06:07,949 --> 00:06:14,310
but uh it's a bit limited when it comes

00:06:12,419 --> 00:06:16,560
short when you're doing doing anything

00:06:14,310 --> 00:06:20,009
more complex with encodings or when

00:06:16,560 --> 00:06:21,569
you're supporting different cases it has

00:06:20,009 --> 00:06:23,460
trouble with dealing with invalid

00:06:21,569 --> 00:06:28,099
character sequences so what happens when

00:06:23,460 --> 00:06:33,379
you ask the nls to convert a character

00:06:28,099 --> 00:06:35,969
that's not mapped in that in that

00:06:33,379 --> 00:06:39,569
character set well primarily it will

00:06:35,969 --> 00:06:41,550
just return 0 on some cases on other it

00:06:39,569 --> 00:06:44,219
won't so you have an inconsistent

00:06:41,550 --> 00:06:47,039
behavior there it's also completely

00:06:44,219 --> 00:06:51,389
incapable of dealing with multibyte

00:06:47,039 --> 00:06:53,520
character sequences which is the biggest

00:06:51,389 --> 00:06:58,379
the largest part of the utf-8

00:06:53,520 --> 00:07:00,810
specification so if you try to use the

00:06:58,379 --> 00:07:04,919
two upper function to return the upper

00:07:00,810 --> 00:07:06,839
case of of a character if it if the

00:07:04,919 --> 00:07:10,159
uppercase version is has more than one

00:07:06,839 --> 00:07:13,319
byte it's not going to work

00:07:10,159 --> 00:07:14,729
it also has trouble dealing with it has

00:07:13,319 --> 00:07:18,870
no support at all for dealing with

00:07:14,729 --> 00:07:21,900
encoding evolution over time it's not a

00:07:18,870 --> 00:07:23,849
big problem for utf-8 in a sense that

00:07:21,900 --> 00:07:26,219
you see f8 promises that's going to be

00:07:23,849 --> 00:07:27,870
stable the transformations both

00:07:26,219 --> 00:07:30,150
normalization in case folding is going

00:07:27,870 --> 00:07:32,159
to be stable over time but it's not

00:07:30,150 --> 00:07:34,740
stable when you're talking about nmap it

00:07:32,159 --> 00:07:38,610
code points so if in a specific release

00:07:34,740 --> 00:07:42,000
of Unicode you have a code point that is

00:07:38,610 --> 00:07:44,639
not defined and then you have the file

00:07:42,000 --> 00:07:46,740
system assuming that it only normalizes

00:07:44,639 --> 00:07:51,000
and decompose it only decomposes and

00:07:46,740 --> 00:07:53,430
folds to itself in a third in the next

00:07:51,000 --> 00:07:55,169
and in the next version of Unicode it it

00:07:53,430 --> 00:07:56,370
actually gets assigned and it starts you

00:07:55,169 --> 00:07:57,930
keep folding then you have

00:07:56,370 --> 00:08:00,479
changing behavior and this is not

00:07:57,930 --> 00:08:02,699
acceptable for us so we need a mechanism

00:08:00,479 --> 00:08:05,250
we need analyzed to be able to deal with

00:08:02,699 --> 00:08:08,660
not only within CODIS but with cific

00:08:05,250 --> 00:08:13,250
encoding versions of each character set

00:08:08,660 --> 00:08:16,169
it's also missing normalization support

00:08:13,250 --> 00:08:18,780
for everything there is no normalization

00:08:16,169 --> 00:08:21,060
support and this partially it has

00:08:18,780 --> 00:08:22,830
partially implemented case folding so

00:08:21,060 --> 00:08:25,110
what we have now is basically case

00:08:22,830 --> 00:08:27,889
folding for ASCII and if you look at the

00:08:25,110 --> 00:08:32,729
other character tables it doesn't do

00:08:27,889 --> 00:08:34,740
case folding at all so the improvements

00:08:32,729 --> 00:08:36,539
I'm proposing and they are all already

00:08:34,740 --> 00:08:38,700
in the mailing lists there is a previous

00:08:36,539 --> 00:08:41,010
version that went to a festival and now

00:08:38,700 --> 00:08:44,219
I'm working on this more on Linux ext4

00:08:41,010 --> 00:08:47,460
mailing lists I'm proposing an interface

00:08:44,219 --> 00:08:50,010
where we can where the user can request

00:08:47,460 --> 00:08:51,720
a specific version of the encoding for

00:08:50,010 --> 00:08:57,900
instance I want to request you to f8

00:08:51,720 --> 00:09:00,930
version 10.0 the exact table that matter

00:08:57,900 --> 00:09:02,820
for us with the young rabbit code points

00:09:00,930 --> 00:09:06,779
and then we have stability among

00:09:02,820 --> 00:09:10,260
different versions we also want the file

00:09:06,779 --> 00:09:12,870
system to specify some behavior of the

00:09:10,260 --> 00:09:16,709
NLS in particular it wants to be able to

00:09:12,870 --> 00:09:20,209
declare I want a specific type of

00:09:16,709 --> 00:09:23,220
normalization like I want and f.k.d

00:09:20,209 --> 00:09:27,240
it has to be able to request one type of

00:09:23,220 --> 00:09:31,170
case folding and this is particularly

00:09:27,240 --> 00:09:33,660
important for file systems because we

00:09:31,170 --> 00:09:36,870
want to make sure that we that we always

00:09:33,660 --> 00:09:38,880
store in the superblock what exactly has

00:09:36,870 --> 00:09:41,190
been used to create hashes inside the

00:09:38,880 --> 00:09:42,750
file system what is the exact version we

00:09:41,190 --> 00:09:46,440
use so we can retrieve the information

00:09:42,750 --> 00:09:48,959
later during lookups we also we also

00:09:46,440 --> 00:09:52,800
implemented a mechanism in analyst you

00:09:48,959 --> 00:09:54,450
validate sequences and correctly handle

00:09:52,800 --> 00:09:56,760
them when they are invalid and allow the

00:09:54,450 --> 00:09:58,620
file system to specify what it wants

00:09:56,760 --> 00:10:02,700
from the NLS whether it should be

00:09:58,620 --> 00:10:04,910
rejecting the the string an invalid

00:10:02,700 --> 00:10:08,660
string whether it should try to

00:10:04,910 --> 00:10:10,490
normalize do a best effort to normal

00:10:08,660 --> 00:10:14,680
the string or whether it should just

00:10:10,490 --> 00:10:17,839
return the plain string that is invalid

00:10:14,680 --> 00:10:20,480
the extension to the API also starts to

00:10:17,839 --> 00:10:22,940
consider mutti bytecode points so we

00:10:20,480 --> 00:10:25,569
have a new API for comparison which

00:10:22,940 --> 00:10:28,670
requires for instance ability to handle

00:10:25,569 --> 00:10:30,920
two different length strings that

00:10:28,670 --> 00:10:35,740
actually are equivalent strings so they

00:10:30,920 --> 00:10:38,959
should compare to the same stuff it also

00:10:35,740 --> 00:10:41,149
implements feature for now it also Allah

00:10:38,959 --> 00:10:44,540
provides interfaces for normalization

00:10:41,149 --> 00:10:45,949
and case folding directly to the to the

00:10:44,540 --> 00:10:49,339
file system because it's going to have

00:10:45,949 --> 00:10:52,370
to use that for hashing this

00:10:49,339 --> 00:10:56,949
implementation the patches I'm proposing

00:10:52,370 --> 00:10:59,209
also include full utf-8 and fkd

00:10:56,949 --> 00:11:01,670
normalization algorithm it doesn't use

00:10:59,209 --> 00:11:05,540
tables it creates is based on the an

00:11:01,670 --> 00:11:10,009
implementation from the SGI in 2014 it

00:11:05,540 --> 00:11:16,880
creates a digital tree of the utf-8

00:11:10,009 --> 00:11:19,040
specification based on the UCD files

00:11:16,880 --> 00:11:21,050
provided by the unicode specification

00:11:19,040 --> 00:11:25,939
and we add a script inside the kernel to

00:11:21,050 --> 00:11:29,420
generate the the tree in a header file

00:11:25,939 --> 00:11:31,790
and add that to the tree and compile it

00:11:29,420 --> 00:11:34,639
during the kernel build time the tree

00:11:31,790 --> 00:11:39,019
itself is quite large and I think it it

00:11:34,639 --> 00:11:41,240
gets to around 90 kilobytes now but this

00:11:39,019 --> 00:11:43,939
goes inside a module that is only loaded

00:11:41,240 --> 00:11:47,480
on demand we make sure to provide utf-8

00:11:43,939 --> 00:11:52,040
without normalization under the load and

00:11:47,480 --> 00:11:53,509
less flags if you request utf-8 without

00:11:52,040 --> 00:11:56,920
normalization you don't need to even

00:11:53,509 --> 00:11:59,180
load the digital tree into the kernel

00:11:56,920 --> 00:12:01,939
this is also extendable for other

00:11:59,180 --> 00:12:04,009
normalization types we are using n fkd

00:12:01,939 --> 00:12:05,809
because that implementation was

00:12:04,009 --> 00:12:09,139
available already because of the word

00:12:05,809 --> 00:12:11,839
from the SGI guys in 2014 but if we

00:12:09,139 --> 00:12:14,059
decide to one day support a file system

00:12:11,839 --> 00:12:17,930
like a PFS the apple file system in the

00:12:14,059 --> 00:12:19,990
linux kernel which I believe uses NFD if

00:12:17,930 --> 00:12:22,810
I'm not mistaken

00:12:19,990 --> 00:12:25,570
then we can simply extend the utf8 to

00:12:22,810 --> 00:12:28,720
support that in a separated module I

00:12:25,570 --> 00:12:30,850
also made sure to to make all these

00:12:28,720 --> 00:12:33,370
transformations to the analyze API to be

00:12:30,850 --> 00:12:36,670
kept backwards compatible with all the

00:12:33,370 --> 00:12:38,470
existing codes all the existing short

00:12:36,670 --> 00:12:39,880
sets in the in analyst and not

00:12:38,470 --> 00:12:43,990
implementing normalization in codes

00:12:39,880 --> 00:12:45,730
footing for them I hope but still the

00:12:43,990 --> 00:12:48,850
OTP is still there and still compatible

00:12:45,730 --> 00:12:50,740
and all the users that need it still got

00:12:48,850 --> 00:12:54,670
in there so the API looks a bit like

00:12:50,740 --> 00:12:57,300
this you have it's a very very high

00:12:54,670 --> 00:12:59,290
level API and providing string

00:12:57,300 --> 00:13:00,700
comparison and string case comparison

00:12:59,290 --> 00:13:03,550
instead of two upper and two lower

00:13:00,700 --> 00:13:05,880
because we need because this can

00:13:03,550 --> 00:13:11,080
abstract all the movie byte handling

00:13:05,880 --> 00:13:14,280
stuff we also need to make an adjustable

00:13:11,080 --> 00:13:17,560
date it in case that we want to reject

00:13:14,280 --> 00:13:21,670
strings that at file creation time

00:13:17,560 --> 00:13:23,440
inside the file system and like I

00:13:21,670 --> 00:13:25,360
mentioned the normalization and the case

00:13:23,440 --> 00:13:27,750
fold interfaces they are important

00:13:25,360 --> 00:13:30,010
because they are going to be used for

00:13:27,750 --> 00:13:32,890
they're going to be directly used for

00:13:30,010 --> 00:13:37,020
hashing both in the dentary cache and in

00:13:32,890 --> 00:13:37,020
the and in the filesystem

00:13:37,230 --> 00:13:45,310
so using this interface I just I just

00:13:41,970 --> 00:13:47,560
mentioned there there is also an

00:13:45,310 --> 00:13:50,800
implementation to make ext4 encoding

00:13:47,560 --> 00:13:53,110
aware and case and aware and the patches

00:13:50,800 --> 00:13:55,990
for both for all the corner we - FS

00:13:53,110 --> 00:13:58,450
Prague's and XFS tests they are under

00:13:55,990 --> 00:14:00,280
reveal now on the mailing list I think I

00:13:58,450 --> 00:14:04,540
haven't submitted the XFS test but I

00:14:00,280 --> 00:14:06,940
linked it the branch there this has gone

00:14:04,540 --> 00:14:09,040
through a few iterations if you guys

00:14:06,940 --> 00:14:11,589
were at LSF and you understand that this

00:14:09,040 --> 00:14:13,839
is a very different proposal from what I

00:14:11,589 --> 00:14:16,060
did there and it's way closer to I

00:14:13,839 --> 00:14:24,190
believe your test proposed I mean from

00:14:16,060 --> 00:14:27,730
2015 so I have a question you haven't

00:14:24,190 --> 00:14:31,320
mentioned but is it the implementation

00:14:27,730 --> 00:14:35,610
in xt4 is it case preserving

00:14:31,320 --> 00:14:38,220
yes like NTFS or is it yes it's case

00:14:35,610 --> 00:14:40,560
insensitive like fat no its case

00:14:38,220 --> 00:14:42,449
preserving preserving we always preserve

00:14:40,560 --> 00:14:48,269
what gets written in the disk its name

00:14:42,449 --> 00:14:49,740
preserving so does implement this is

00:14:48,269 --> 00:14:52,019
implemented as incompatible feature

00:14:49,740 --> 00:14:56,940
because we have two changes hashes in

00:14:52,019 --> 00:14:59,759
the disk so once your disk girls goes in

00:14:56,940 --> 00:15:01,649
coding aware it has it cannot go in

00:14:59,759 --> 00:15:03,690
coding unaware and then my fashion we

00:15:01,649 --> 00:15:07,220
have what I am proposing now is to do

00:15:03,690 --> 00:15:10,649
this at file system creation time and

00:15:07,220 --> 00:15:12,569
apply it this wise we store the encoding

00:15:10,649 --> 00:15:16,019
information the flags information in the

00:15:12,569 --> 00:15:17,970
super block and keep it there so just

00:15:16,019 --> 00:15:19,560
done I might have missed this but how do

00:15:17,970 --> 00:15:21,329
we ensure the coding that the users

00:15:19,560 --> 00:15:22,889
using matches the encoding with the file

00:15:21,329 --> 00:15:25,470
systems using because that's where we're

00:15:22,889 --> 00:15:28,290
gonna get all of the problems like we

00:15:25,470 --> 00:15:30,300
share one xt4 filesystem among a lot of

00:15:28,290 --> 00:15:31,949
containers but the containers are free

00:15:30,300 --> 00:15:37,350
to set their encoding to anything they

00:15:31,949 --> 00:15:39,660
want this is actually one of the points

00:15:37,350 --> 00:15:41,339
I'm reading at the end of questions how

00:15:39,660 --> 00:15:44,250
do we handle with it no sorry how do we

00:15:41,339 --> 00:15:48,269
handle to it with user space breakage so

00:15:44,250 --> 00:15:50,069
my my goal with this is to support a

00:15:48,269 --> 00:15:52,980
specific set of programs that are

00:15:50,069 --> 00:15:55,019
interested in the casing sensitiveness

00:15:52,980 --> 00:15:57,959
so the way I see this feature being

00:15:55,019 --> 00:16:01,310
applied is in a separated file system

00:15:57,959 --> 00:16:04,589
that actually needs this I don't think

00:16:01,310 --> 00:16:08,899
we will see this apply this entire route

00:16:04,589 --> 00:16:11,579
root of s being using in a root offense

00:16:08,899 --> 00:16:13,500
so this should be use it for people who

00:16:11,579 --> 00:16:15,269
actually have a need for this feature

00:16:13,500 --> 00:16:18,410
okay but basically we won't know what

00:16:15,269 --> 00:16:18,410
breaks until people try it

00:16:20,530 --> 00:16:24,410
so let's try and think like what would

00:16:22,730 --> 00:16:26,360
be the most common cases apply in

00:16:24,410 --> 00:16:28,340
Android case that you're thinking of but

00:16:26,360 --> 00:16:30,380
the you know the most common case is you

00:16:28,340 --> 00:16:32,660
know I got my backpack you know a USB

00:16:30,380 --> 00:16:34,220
stick that's fat and anything that can

00:16:32,660 --> 00:16:38,030
be done that's the most common probably

00:16:34,220 --> 00:16:39,680
case case in case in sensitive case the

00:16:38,030 --> 00:16:41,270
second most common is probably all the

00:16:39,680 --> 00:16:45,110
Mac users and Windows users coming

00:16:41,270 --> 00:16:46,610
through samba so you know all those guys

00:16:45,110 --> 00:16:48,200
that are accessing their little

00:16:46,610 --> 00:16:50,090
appliances at home those little Nats

00:16:48,200 --> 00:16:51,650
that are including some downloading

00:16:50,090 --> 00:16:53,840
drivers whatever so in that case they'd

00:16:51,650 --> 00:16:57,860
have to format so the appliance just

00:16:53,840 --> 00:16:59,180
formats it the xj4 and you know samba

00:16:57,860 --> 00:17:02,450
gets to turn off some really really

00:16:59,180 --> 00:17:04,839
expensive user space code okay my my

00:17:02,450 --> 00:17:07,640
main use case for this is on steamos

00:17:04,839 --> 00:17:10,910
we need we want to provide a better

00:17:07,640 --> 00:17:12,740
interface for a better environments for

00:17:10,910 --> 00:17:16,280
game producers bringing games from

00:17:12,740 --> 00:17:18,020
windows so what we are doing there we

00:17:16,280 --> 00:17:20,540
are probably creating a separate

00:17:18,020 --> 00:17:22,370
partition to keep games on to keep the

00:17:20,540 --> 00:17:27,860
game data on and that partition is going

00:17:22,370 --> 00:17:29,210
to be including aware and specific

00:17:27,860 --> 00:17:30,590
directories yeah I mean that's probably

00:17:29,210 --> 00:17:32,630
very similar case to what we're talking

00:17:30,590 --> 00:17:35,990
about right is that you've got a root

00:17:32,630 --> 00:17:38,690
file system on some NAT or some

00:17:35,990 --> 00:17:41,780
appliance and you're exporting to your

00:17:38,690 --> 00:17:44,030
Macs in your Windows some other ext4

00:17:41,780 --> 00:17:49,310
partition and now you get to turn off

00:17:44,030 --> 00:17:51,590
all this really ugly code yeah yeah I

00:17:49,310 --> 00:17:53,000
mean I think it's fair to say that at

00:17:51,590 --> 00:17:56,300
this point we're making a couple

00:17:53,000 --> 00:17:58,790
assumptions here one of the primary

00:17:56,300 --> 00:18:01,550
assumptions is that the primary users

00:17:58,790 --> 00:18:05,480
will be either things like the game use

00:18:01,550 --> 00:18:08,200
case or the file server use case where

00:18:05,480 --> 00:18:10,550
you're trying to support samba Sif's

00:18:08,200 --> 00:18:13,370
nfsv4 or something like that

00:18:10,550 --> 00:18:16,550
another key assumption that's being made

00:18:13,370 --> 00:18:20,630
with all of this is all the world is

00:18:16,550 --> 00:18:24,140
utf-8 there is zero interest as far as I

00:18:20,630 --> 00:18:26,930
know of anyone who wants to have you

00:18:24,140 --> 00:18:29,780
know one person's home directory using

00:18:26,930 --> 00:18:32,030
you know CP 1 3 3 7 and another one

00:18:29,780 --> 00:18:36,770
using some other random

00:18:32,030 --> 00:18:41,270
windows code set and doing anything else

00:18:36,770 --> 00:18:43,040
would be hugely complicated and you know

00:18:41,270 --> 00:18:46,040
anyone who's really interested is

00:18:43,040 --> 00:18:48,560
invited to send patches but that's not I

00:18:46,040 --> 00:18:51,770
think the focus of any of the interests

00:18:48,560 --> 00:18:54,260
that I've certainly seen and if I'm

00:18:51,770 --> 00:19:01,790
wrong in that assumption you know I I

00:18:54,260 --> 00:19:03,230
invite to be corrected you could do it I

00:19:01,790 --> 00:19:06,850
mean you could go through another

00:19:03,230 --> 00:19:12,140
translation which says I'm storing an 80

00:19:06,850 --> 00:19:14,840
utf-8 of this version and this is on

00:19:12,140 --> 00:19:15,740
disk and then whatever interface you

00:19:14,840 --> 00:19:17,900
want from me

00:19:15,740 --> 00:19:40,670
you go through the tables to translate

00:19:17,900 --> 00:19:43,130
them but one of the problems with this

00:19:40,670 --> 00:19:44,960
is how have we communicated to all the

00:19:43,130 --> 00:19:47,900
user space people that which using utf-8

00:19:44,960 --> 00:19:49,370
is our canonical representation because

00:19:47,900 --> 00:19:51,470
right at the moment a lot of European

00:19:49,370 --> 00:19:53,870
distributions like that izo single

00:19:51,470 --> 00:19:56,150
character format for that so there is

00:19:53,870 --> 00:19:57,080
still not a lot of agreement that utf-8

00:19:56,150 --> 00:19:59,090
is the way to go

00:19:57,080 --> 00:20:01,130
the Chinese particularly hate it because

00:19:59,090 --> 00:20:03,590
it's all four characters for instead of

00:20:01,130 --> 00:20:05,990
two for their representations so what

00:20:03,590 --> 00:20:15,470
steps are we making to ensure that

00:20:05,990 --> 00:20:17,540
reality matches our choice as I said I

00:20:15,470 --> 00:20:20,410
think right now the primary use case

00:20:17,540 --> 00:20:23,210
that has been imagined has been fairly

00:20:20,410 --> 00:20:25,930
you know almost more like appliance

00:20:23,210 --> 00:20:31,670
style use cases where you have a tuned

00:20:25,930 --> 00:20:34,460
user space I think to date like many

00:20:31,670 --> 00:20:36,980
other kernel features there's been a

00:20:34,460 --> 00:20:39,410
very strong somebody else's problem feel

00:20:36,980 --> 00:20:43,190
directed and it's like we're throwing

00:20:39,410 --> 00:20:45,640
that problem to the distros hope you

00:20:43,190 --> 00:20:48,140
honest that's where we are right now

00:20:45,640 --> 00:20:50,150
yeah unfortunately part of the problem

00:20:48,140 --> 00:20:53,630
is POSIX doesn't have a good way for the

00:20:50,150 --> 00:20:56,000
file system to communicate or some way

00:20:53,630 --> 00:20:58,160
of you know making it G ellipses problem

00:20:56,000 --> 00:21:00,740
right so we could easily say you know

00:20:58,160 --> 00:21:02,780
the file system encoding is utf-8 we'll

00:21:00,740 --> 00:21:06,170
make it G ellipses problem or you know

00:21:02,780 --> 00:21:09,170
some libraries problem to transcode from

00:21:06,170 --> 00:21:11,420
you know some character set into the

00:21:09,170 --> 00:21:14,150
native character set of that file system

00:21:11,420 --> 00:21:16,880
I think that's a fascinating research

00:21:14,150 --> 00:21:19,130
problem I don't have time to try to

00:21:16,880 --> 00:21:24,290
address it but yeah we don't have a good

00:21:19,130 --> 00:21:27,410
solution right now did you at least

00:21:24,290 --> 00:21:33,730
address that that the kernel the file

00:21:27,410 --> 00:21:37,310
system has a standard way to to expose

00:21:33,730 --> 00:21:40,850
this is my whatever you go through me

00:21:37,310 --> 00:21:44,060
this is the format and in the case in

00:21:40,850 --> 00:21:48,260
sensitives and the at least some kind of

00:21:44,060 --> 00:21:53,900
way of say of exporting you do whatever

00:21:48,260 --> 00:21:55,970
we want but an application a smart

00:21:53,900 --> 00:21:59,450
application can go and say okay did you

00:21:55,970 --> 00:22:02,210
actually format with the write from bits

00:21:59,450 --> 00:22:05,810
and can I rely on this and this and that

00:22:02,210 --> 00:22:11,000
so just a simple table IO control

00:22:05,810 --> 00:22:13,070
I don't know how Sisyphus that says it

00:22:11,000 --> 00:22:15,680
doesn't matter which is the file system

00:22:13,070 --> 00:22:17,300
implemented but this is the encoding you

00:22:15,680 --> 00:22:23,480
get from me and the compare and the

00:22:17,300 --> 00:22:25,520
string compare you get from me so I

00:22:23,480 --> 00:22:27,260
think the answer is right now know there

00:22:25,520 --> 00:22:30,620
is a super block flag because the file

00:22:27,260 --> 00:22:33,010
system needs to know I would think the

00:22:30,620 --> 00:22:35,590
right place to put that would be

00:22:33,010 --> 00:22:37,640
something that shows up in Stata FS

00:22:35,590 --> 00:22:40,280
because that would actually be a much

00:22:37,640 --> 00:22:42,440
more sane place to put it we could very

00:22:40,280 --> 00:22:45,650
easily implement an AI octal or a

00:22:42,440 --> 00:22:47,720
Sisyphus field there maybe it's this

00:22:45,650 --> 00:22:49,430
field I can't remember but you know we

00:22:47,720 --> 00:22:51,440
could very easily do that that's not a

00:22:49,430 --> 00:22:54,530
very friendly way of exporting the

00:22:51,440 --> 00:22:56,030
information doing something in Stata FS

00:22:54,530 --> 00:22:59,299
will require a more extended

00:22:56,030 --> 00:23:03,049
conversation with FS devel

00:22:59,299 --> 00:23:06,080
API to try to find space in an existing

00:23:03,049 --> 00:23:10,460
interface to make that available but

00:23:06,080 --> 00:23:17,389
it's an interesting idea so other

00:23:10,460 --> 00:23:21,169
questions I think about the ax FS case

00:23:17,389 --> 00:23:24,009
where they they expose the entire file

00:23:21,169 --> 00:23:27,739
system as case insensitive and assumes

00:23:24,009 --> 00:23:30,830
some ASCII conversion is it exposed

00:23:27,739 --> 00:23:33,909
anywhere is there any excess how do they

00:23:30,830 --> 00:23:33,909
handle this this might be

00:23:49,820 --> 00:23:57,330
so let me just move forward and then we

00:23:52,980 --> 00:24:00,060
can continue this implementation occurs

00:23:57,330 --> 00:24:03,650
sorry the this conversion occurs at the

00:24:00,060 --> 00:24:06,240
moment only at file creation time

00:24:03,650 --> 00:24:08,250
because it would require rebuilding the

00:24:06,240 --> 00:24:10,700
eh three hashes in the disk this is an

00:24:08,250 --> 00:24:12,750
aim preserving implementation and we are

00:24:10,700 --> 00:24:16,110
this is being done at the moment

00:24:12,750 --> 00:24:20,610
entirely inside the X before we are not

00:24:16,110 --> 00:24:22,080
touching anything at the VFS the way we

00:24:20,610 --> 00:24:25,170
are we are trying to make good use of

00:24:22,080 --> 00:24:27,570
the dentary cache so we we are caching

00:24:25,170 --> 00:24:29,460
positive entries there we make sure

00:24:27,570 --> 00:24:34,350
there is only one entry that that gets

00:24:29,460 --> 00:24:39,030
yes cache it per file entry the actual

00:24:34,350 --> 00:24:40,890
name that gets cached it I can tell that

00:24:39,030 --> 00:24:42,930
it doesn't really matter at the moment

00:24:40,890 --> 00:24:45,240
it's going to be the the first access by

00:24:42,930 --> 00:24:49,980
the user but since we have the hash Andy

00:24:45,240 --> 00:24:56,190
compared encoding away our case

00:24:49,980 --> 00:24:58,320
insensitive fashion negative entries at

00:24:56,190 --> 00:25:01,530
the moment because it would it will

00:24:58,320 --> 00:25:05,040
require some careful invalidation so you

00:25:01,530 --> 00:25:09,120
don't leak the previous negative name

00:25:05,040 --> 00:25:10,560
into into the new positive the entry in

00:25:09,120 --> 00:25:11,880
case they have different casing and

00:25:10,560 --> 00:25:16,050
stuff because we want to be named

00:25:11,880 --> 00:25:17,640
preserving so for the case insensitive

00:25:16,050 --> 00:25:22,440
support we're really interested in

00:25:17,640 --> 00:25:24,270
having a more fine-grained control so it

00:25:22,440 --> 00:25:26,600
obviously require encoding support

00:25:24,270 --> 00:25:29,460
because otherwise what is the case for

00:25:26,600 --> 00:25:31,380
operation we are doing it as a per

00:25:29,460 --> 00:25:33,570
directory per directory I know that

00:25:31,380 --> 00:25:35,220
reboot you can only configure it on

00:25:33,570 --> 00:25:37,800
empty directories so you don't have to

00:25:35,220 --> 00:25:41,100
rehash things and you avoid name

00:25:37,800 --> 00:25:43,710
collisions name collisions would be two

00:25:41,100 --> 00:25:45,900
files two different files that are

00:25:43,710 --> 00:25:48,270
equivalent only in a case insensitive

00:25:45,900 --> 00:25:51,210
fashion which means they only differ by

00:25:48,270 --> 00:25:54,420
casing and we believe that this finer

00:25:51,210 --> 00:25:56,320
grained control of doing it per director

00:25:54,420 --> 00:26:00,399
is more suitable for users

00:25:56,320 --> 00:26:03,130
is a very used case and this becomes

00:26:00,399 --> 00:26:04,630
quite super trivial to implement the

00:26:03,130 --> 00:26:06,340
case insensitive support becomes trivial

00:26:04,630 --> 00:26:09,370
to implement once you have encoding

00:26:06,340 --> 00:26:13,120
support because it can be seen as just a

00:26:09,370 --> 00:26:15,639
special case of encoding it's like okay

00:26:13,120 --> 00:26:19,600
now I have a larger set of equivalent

00:26:15,639 --> 00:26:24,970
sequences I have to mention that if you

00:26:19,600 --> 00:26:28,929
could if you would create an ASCII file

00:26:24,970 --> 00:26:31,960
system Satya said the encoding to ask

00:26:28,929 --> 00:26:35,620
instead of not setting at all don't

00:26:31,960 --> 00:26:37,659
enable strict mode you can make use of

00:26:35,620 --> 00:26:39,039
the case fold feature you're not going

00:26:37,659 --> 00:26:41,080
to have normalization so you don't need

00:26:39,039 --> 00:26:43,539
to care about that there's not going to

00:26:41,080 --> 00:26:46,330
be any collisions you can make use of

00:26:43,539 --> 00:26:49,000
the case insensitive support per

00:26:46,330 --> 00:26:51,009
directory and not even though you apply

00:26:49,000 --> 00:26:53,350
it in coding aware for your route of s

00:26:51,009 --> 00:26:55,330
you can make use of just this feature

00:26:53,350 --> 00:26:57,730
the result is going to be the same and

00:26:55,330 --> 00:27:04,389
the amount of code that gets added is

00:26:57,730 --> 00:27:05,379
this almost nothing there are few

00:27:04,389 --> 00:27:07,029
limitations in the current

00:27:05,379 --> 00:27:09,970
implementation the first one I mention

00:27:07,029 --> 00:27:12,789
is the negative dangerous I'm still not

00:27:09,970 --> 00:27:14,860
supporting directory encryption as I

00:27:12,789 --> 00:27:17,080
script because the lookup is based on

00:27:14,860 --> 00:27:19,929
the hash of the name which is created

00:27:17,080 --> 00:27:22,179
based on the name that was that was

00:27:19,929 --> 00:27:23,889
first used to access and is impossible

00:27:22,179 --> 00:27:25,840
to recalculate that hash using an

00:27:23,889 --> 00:27:28,899
equivalent sequence so what I'm

00:27:25,840 --> 00:27:31,090
proposing is that we change the hash

00:27:28,899 --> 00:27:32,679
that we write the the hash of the

00:27:31,090 --> 00:27:35,320
filename that we store unencrypted

00:27:32,679 --> 00:27:37,179
volumes to use the normalization version

00:27:35,320 --> 00:27:40,029
to calculate the hash my question is

00:27:37,179 --> 00:27:42,570
does it work is there does anyone see a

00:27:40,029 --> 00:27:42,570
problem with that

00:27:48,630 --> 00:27:53,200
now there is more details like if I

00:27:51,100 --> 00:27:59,920
script and it's the entry offs but this

00:27:53,200 --> 00:28:02,500
is just a code leveraging my question is

00:27:59,920 --> 00:28:07,240
also regarding how to deal with invalid

00:28:02,500 --> 00:28:09,250
sequences this is an ext for policy what

00:28:07,240 --> 00:28:11,320
do we do when the file system faces an

00:28:09,250 --> 00:28:13,120
invalid character sequence my

00:28:11,320 --> 00:28:15,190
understanding me is that we should make

00:28:13,120 --> 00:28:17,080
it permissive so we accept invalid

00:28:15,190 --> 00:28:20,920
sequences in written as a pod byte

00:28:17,080 --> 00:28:25,230
sequences which would basically mean we

00:28:20,920 --> 00:28:27,910
fall back to the previous behavior and

00:28:25,230 --> 00:28:29,740
in this agreement we may live it we make

00:28:27,910 --> 00:28:32,520
available in strict mode but I don't see

00:28:29,740 --> 00:28:36,790
why you'd want to to enable that ever

00:28:32,520 --> 00:28:39,610
and finally the topic we touched the

00:28:36,790 --> 00:28:41,710
userspace breakage and I think that in

00:28:39,610 --> 00:28:45,220
case you only care about ASCII and you

00:28:41,710 --> 00:28:47,920
only care about having some directory

00:28:45,220 --> 00:28:49,480
case insensitive because you actually

00:28:47,920 --> 00:28:53,940
need this feature for a specific program

00:28:49,480 --> 00:28:59,200
you could have an ASCII file system

00:28:53,940 --> 00:29:01,420
without strict mode in n LS and only

00:28:59,200 --> 00:29:03,100
make that directory case insensitive is

00:29:01,420 --> 00:29:06,270
there any other issues I think the

00:29:03,100 --> 00:29:06,270
patches are not in the mailing list

00:29:11,510 --> 00:29:17,780
so the current implementation is ext4

00:29:14,530 --> 00:29:21,800
but the main part of it is ghee and the

00:29:17,780 --> 00:29:23,270
last changes so I believe we are one of

00:29:21,800 --> 00:29:24,590
the contributions of this work is that

00:29:23,270 --> 00:29:26,180
we are giving a road map to be

00:29:24,590 --> 00:29:28,400
implemented in under fire systems and

00:29:26,180 --> 00:29:32,540
the first thing I think we could do is

00:29:28,400 --> 00:29:34,160
extend the XFS support to make it poor

00:29:32,540 --> 00:29:37,130
directory and eventually support other

00:29:34,160 --> 00:29:39,970
encodings yeah the other thing I'll add

00:29:37,130 --> 00:29:44,210
here is that the current implementation

00:29:39,970 --> 00:29:48,230
only supports changing the character set

00:29:44,210 --> 00:29:52,160
encoding at make efest time historically

00:29:48,230 --> 00:29:56,320
we've actually added support to ext

00:29:52,160 --> 00:30:00,740
various ext4 features so that tune 2fs

00:29:56,320 --> 00:30:03,740
would be able to sweep the file system

00:30:00,740 --> 00:30:05,870
and then update the encoding z' there

00:30:03,740 --> 00:30:08,750
might be some interesting questions what

00:30:05,870 --> 00:30:11,330
what one might do if you started with a

00:30:08,750 --> 00:30:14,420
utf-8 file system and converted it to

00:30:11,330 --> 00:30:17,870
ASCII and what do you do with all of the

00:30:14,420 --> 00:30:21,380
invalid characters and so maybe two FS

00:30:17,870 --> 00:30:24,920
won't support that also even though ext4

00:30:21,380 --> 00:30:28,100
has sometimes supported creation after

00:30:24,920 --> 00:30:30,740
the fact you know modification of a file

00:30:28,100 --> 00:30:34,190
system after the fact to add some new

00:30:30,740 --> 00:30:36,970
file system features not all enterprise

00:30:34,190 --> 00:30:39,470
distros have supported that flexibility

00:30:36,970 --> 00:30:46,820
mainly because their support desks don't

00:30:39,470 --> 00:30:48,260
want to deal with it but the other way

00:30:46,820 --> 00:30:56,780
around you you risk

00:30:48,260 --> 00:30:58,010
dozens of name collisions and yes some

00:30:56,780 --> 00:31:00,290
of the kernel source code and as

00:30:58,010 --> 00:31:00,680
interesting might be worth pinging Jeff

00:31:00,290 --> 00:31:02,840
Leighton

00:31:00,680 --> 00:31:06,050
I didn't realize Jeff had attacked this

00:31:02,840 --> 00:31:07,910
too so he created a win you case file

00:31:06,050 --> 00:31:11,090
precisely because he was missing these

00:31:07,910 --> 00:31:13,910
functions and he also there's comments

00:31:11,090 --> 00:31:15,350
from another developer about so the

00:31:13,910 --> 00:31:17,690
logical thing to do is if you had to

00:31:15,350 --> 00:31:20,270
deal with other code pages like Unicode

00:31:17,690 --> 00:31:22,160
right you're in NTFS RS and B whatever

00:31:20,270 --> 00:31:23,840
you're doing with Unicode yeah so you

00:31:22,160 --> 00:31:25,580
you've got a W care so you walk

00:31:23,840 --> 00:31:27,740
the string and the logical thing would

00:31:25,580 --> 00:31:30,919
be to convert it to utf-8 uppercase then

00:31:27,740 --> 00:31:33,169
convert it back for some of these hashes

00:31:30,919 --> 00:31:34,279
right so and but he describes why

00:31:33,169 --> 00:31:37,220
doesn't do it because he's missing these

00:31:34,279 --> 00:31:38,510
functions so when you case dot C in the

00:31:37,220 --> 00:31:41,240
kernel code might be an interesting

00:31:38,510 --> 00:31:43,370
example but it's interesting the most

00:31:41,240 --> 00:31:45,950
ugly code I was looking at I think this

00:31:43,370 --> 00:31:47,990
helps with is that the dentary

00:31:45,950 --> 00:31:50,059
revalidation stuff were where you're

00:31:47,990 --> 00:31:52,220
having to walk through and we've got our

00:31:50,059 --> 00:31:53,570
own table which is error-prone right you

00:31:52,220 --> 00:31:56,049
shouldn't have any less code inside a

00:31:53,570 --> 00:31:57,880
file system you should have it these

00:31:56,049 --> 00:32:01,220
internationalization routines elsewhere

00:31:57,880 --> 00:32:04,250
so you're converting one at a time it's

00:32:01,220 --> 00:32:05,809
it's this will be a lot better if it's

00:32:04,250 --> 00:32:07,490
possible but when you case that's see

00:32:05,809 --> 00:32:13,039
you I hadn't realized Jeff had attacked

00:32:07,490 --> 00:32:15,559
this three or four years ago so I think

00:32:13,039 --> 00:32:19,130
there's a related issue here which is as

00:32:15,559 --> 00:32:21,649
near as I can tell F s NL s has no

00:32:19,130 --> 00:32:25,070
maintainer at the moment or certainly no

00:32:21,649 --> 00:32:26,960
upstream maintainer that's active and so

00:32:25,070 --> 00:32:29,990
the NL s changes are going to be going

00:32:26,960 --> 00:32:31,820
through the ext4 tree one of the things

00:32:29,990 --> 00:32:35,480
that I will certainly do is try to make

00:32:31,820 --> 00:32:39,020
a good-faith effort to test other NL s

00:32:35,480 --> 00:32:41,840
users that might possibly be impacted to

00:32:39,020 --> 00:32:43,690
make sure that nothing breaks but it may

00:32:41,840 --> 00:32:46,610
very well be that there are some

00:32:43,690 --> 00:32:49,120
interesting additions that might want to

00:32:46,610 --> 00:32:52,940
be added to the NL s code to for example

00:32:49,120 --> 00:32:55,880
support wide encoding or whatnot which

00:32:52,940 --> 00:32:58,460
is you know not currently there because

00:32:55,880 --> 00:33:00,309
you know Gabriel just did what he needed

00:32:58,460 --> 00:33:03,740
for his patch which is perfectly fair

00:33:00,309 --> 00:33:07,159
but yeah it should be noted that you

00:33:03,740 --> 00:33:10,669
know we don't have anyone who is the NL

00:33:07,159 --> 00:33:14,620
s maintainer and I am NOT volunteering

00:33:10,669 --> 00:33:14,620
to be maintainer

00:33:18,950 --> 00:33:25,470
did you have any more slides or just

00:33:23,790 --> 00:33:27,090
linking to the code this is also in the

00:33:25,470 --> 00:33:30,900
cover letter so you can look at the

00:33:27,090 --> 00:33:33,030
patches only got to thank a lot of

00:33:30,900 --> 00:33:35,520
people for this so very quickly the SGI

00:33:33,030 --> 00:33:37,860
guys who did this effort in the first

00:33:35,520 --> 00:33:40,830
place and all the utf-8 implementation

00:33:37,860 --> 00:33:43,020
was hard heavy lifted by those guys

00:33:40,830 --> 00:33:47,490
thank you for the guys at Ellis FM and

00:33:43,020 --> 00:33:50,640
mainly list for contributing and kelabra

00:33:47,490 --> 00:34:05,940
and evolved for sponsoring the work so

00:33:50,640 --> 00:34:08,460
thank you my question mainly just is how

00:34:05,940 --> 00:34:12,330
to imagine this going forward once this

00:34:08,460 --> 00:34:15,090
these routines ran I think what I do is

00:34:12,330 --> 00:34:17,490
I throw away when you KSC which has its

00:34:15,090 --> 00:34:20,940
own mapping table for white characters

00:34:17,490 --> 00:34:23,610
so basically Jeff created cut and paste

00:34:20,940 --> 00:34:26,610
right all of the white character

00:34:23,610 --> 00:34:29,550
uppercase lowercase mappings so you've

00:34:26,610 --> 00:34:33,060
got two big arrays in this thing and and

00:34:29,550 --> 00:34:35,610
then he tends to walk through character

00:34:33,060 --> 00:34:39,899
by character converting the dentary from

00:34:35,610 --> 00:34:41,159
utf-8 to a wide character upper casing

00:34:39,899 --> 00:34:43,710
it from the table then converting it

00:34:41,159 --> 00:34:49,800
back so I think all that code can kind

00:34:43,710 --> 00:34:51,750
of go away well I mean that's that's

00:34:49,800 --> 00:34:55,020
true but at the same time it's gonna be

00:34:51,750 --> 00:34:56,820
the same thing that that NTFS and so

00:34:55,020 --> 00:34:59,460
anybody that uses Unicode it's gonna be

00:34:56,820 --> 00:35:01,650
because Microsoft right UCS to that

00:34:59,460 --> 00:35:07,320
encoding I mean yes the version matters

00:35:01,650 --> 00:35:10,680
and so we should pay attention we have

00:35:07,320 --> 00:35:14,190
the lastest 110 we actually have seven

00:35:10,680 --> 00:35:15,660
eight nine ten so my theory is that if

00:35:14,190 --> 00:35:19,980
you're broken because you're using

00:35:15,660 --> 00:35:21,240
Windows Vista or a Mac from seven six

00:35:19,980 --> 00:35:23,910
years ago instead of a Mac from two

00:35:21,240 --> 00:35:25,140
years ago oh well I mean it's a heck of

00:35:23,910 --> 00:35:28,040
a lot better than right now because the

00:35:25,140 --> 00:35:28,040
mapping table has just

00:35:28,500 --> 00:35:36,850
yeah I agree my my theory is he can't

00:35:35,020 --> 00:35:45,490
pull dit out of a standard spec yeah my

00:35:36,850 --> 00:35:48,640
theory the actual version of Windows the

00:35:45,490 --> 00:35:50,650
NTFS file system supports any any byte

00:35:48,640 --> 00:35:54,490
sequence which can be expressed in

00:35:50,650 --> 00:35:57,430
utf-16 so you can have an old NT for

00:35:54,490 --> 00:36:01,260
file system and it will support in a way

00:35:57,430 --> 00:36:04,090
the latest UTF the latest eunuch 8

00:36:01,260 --> 00:36:07,120
character set because it doesn't matter

00:36:04,090 --> 00:36:10,420
so that's the point I didn't quite

00:36:07,120 --> 00:36:12,550
understand now is it really does it

00:36:10,420 --> 00:36:14,380
really make sense to normalize on the

00:36:12,550 --> 00:36:18,070
file system or shouldn't the file system

00:36:14,380 --> 00:36:22,390
rather also be like the NTFS file system

00:36:18,070 --> 00:36:28,750
just be your you know allow any utf-8

00:36:22,390 --> 00:36:31,660
sequence which is valid anyone and you

00:36:28,750 --> 00:36:35,350
only need to normalize at the point

00:36:31,660 --> 00:36:40,180
where you really have to compare file

00:36:35,350 --> 00:36:43,420
names and even NTFS allows any Unicode

00:36:40,180 --> 00:36:45,610
sequence so whatever normalization

00:36:43,420 --> 00:36:47,680
you're using both can be expressed and

00:36:45,610 --> 00:36:50,130
so you even have to file names which

00:36:47,680 --> 00:36:52,690
look the same from the user perspective

00:36:50,130 --> 00:36:55,510
is correct we only need to do

00:36:52,690 --> 00:36:58,450
normalization for when we are looking

00:36:55,510 --> 00:37:00,160
and comparing so we only do it for

00:36:58,450 --> 00:37:02,320
storing hashes in the disk and the name

00:37:00,160 --> 00:37:05,850
is actually case preserving so we can

00:37:02,320 --> 00:37:11,170
enter reacts in theory Excel accept any

00:37:05,850 --> 00:37:14,350
sequence what I am Not sure is whether

00:37:11,170 --> 00:37:18,930
all the matching is off that we all the

00:37:14,350 --> 00:37:23,860
equivalent sequences in an FD fashion

00:37:18,930 --> 00:37:26,950
are all with also matching and f.k.d I

00:37:23,860 --> 00:37:29,610
think Apple had problems with that so

00:37:26,950 --> 00:37:32,170
you might need to actually specify which

00:37:29,610 --> 00:37:33,970
normalization in which type of case fold

00:37:32,170 --> 00:37:35,860
you do and store it in a super block so

00:37:33,970 --> 00:37:38,940
you can make sure you're always looking

00:37:35,860 --> 00:37:38,940
for it in the same fashion

00:37:48,280 --> 00:37:54,950
no it's not preserving we always we only

00:37:51,920 --> 00:37:57,740
use normalization for comparison in the

00:37:54,950 --> 00:38:05,840
disk it's what the user created an first

00:37:57,740 --> 00:38:08,600
time ok like it seems like 99.9% of it

00:38:05,840 --> 00:38:10,040
is the the dentary revalidation stuff so

00:38:08,600 --> 00:38:11,960
you'd like a rename so you don't rename

00:38:10,040 --> 00:38:12,950
a file on top of itself what you did you

00:38:11,960 --> 00:38:14,720
thought was supposed to be a new file

00:38:12,950 --> 00:38:18,260
but it ended up renaming on top of

00:38:14,720 --> 00:38:20,630
itself or on unlinking making sure

00:38:18,260 --> 00:38:22,160
you're unlocking the file that you're

00:38:20,630 --> 00:38:23,960
supposed to be but so that the dentary

00:38:22,160 --> 00:38:25,220
related routines with 99% of it but

00:38:23,960 --> 00:38:26,450
there wasn't one other case I was

00:38:25,220 --> 00:38:29,150
looking through my code there's some

00:38:26,450 --> 00:38:33,140
places mostly older security code where

00:38:29,150 --> 00:38:35,630
they they have to uppercase the username

00:38:33,140 --> 00:38:38,060
or password now those are old security

00:38:35,630 --> 00:38:46,820
mechanisms but that was the only other

00:38:38,060 --> 00:38:48,260
case I found that we care so there was a

00:38:46,820 --> 00:38:52,010
couple of months ago there was a

00:38:48,260 --> 00:38:55,610
discussion that leanest explained that

00:38:52,010 --> 00:38:59,570
actually negative the entries are kind

00:38:55,610 --> 00:39:03,380
of important also in the life cycle of

00:38:59,570 --> 00:39:07,090
an eye of an item in the cache and but

00:39:03,380 --> 00:39:12,290
also for performance and so do you have

00:39:07,090 --> 00:39:18,560
any thoughts about returning did-

00:39:12,290 --> 00:39:19,940
the entries yes yes when you are looking

00:39:18,560 --> 00:39:23,540
for a file that you don't don't know the

00:39:19,940 --> 00:39:25,820
name so you keep looking and getting

00:39:23,540 --> 00:39:28,180
fired not found all the time and there

00:39:25,820 --> 00:39:31,400
is essential for performance

00:39:28,180 --> 00:39:34,280
what other file systems that implement

00:39:31,400 --> 00:39:37,520
this they have two common approaches the

00:39:34,280 --> 00:39:40,930
first one is don't add the entry at all

00:39:37,520 --> 00:39:44,090
I believe this is the XFS approach and

00:39:40,930 --> 00:39:46,310
they can do it because they go when they

00:39:44,090 --> 00:39:47,960
go to inside the file system they are

00:39:46,310 --> 00:39:50,270
catching some information there so it's

00:39:47,960 --> 00:39:52,190
quickly retrieved and the other approach

00:39:50,270 --> 00:39:55,220
is

00:39:52,190 --> 00:39:57,020
just invalidate it later

00:39:55,220 --> 00:40:00,530
the problem with this approach is that

00:39:57,020 --> 00:40:03,590
you have to be careful and rename paths

00:40:00,530 --> 00:40:05,420
you have to be careful and when you were

00:40:03,590 --> 00:40:08,240
transforming it into a positive the

00:40:05,420 --> 00:40:10,820
entry it's completely doable and I am

00:40:08,240 --> 00:40:13,340
currently working on that I have patches

00:40:10,820 --> 00:40:15,770
I know that they work what I believe

00:40:13,340 --> 00:40:18,200
they still I'm waiting for this stuff to

00:40:15,770 --> 00:40:20,840
go in and then I can be pushing more but

00:40:18,200 --> 00:40:22,880
I completely and believe that is totally

00:40:20,840 --> 00:40:25,340
doable to have negative dangerous I had

00:40:22,880 --> 00:40:26,930
a previous proposal for negative danger

00:40:25,340 --> 00:40:28,730
is where you would store a different

00:40:26,930 --> 00:40:32,420
kind of negative danger that indicates

00:40:28,730 --> 00:40:36,320
that there is absolutely no file that

00:40:32,420 --> 00:40:38,120
would there is no there is absolutely no

00:40:36,320 --> 00:40:40,370
equivalent sequence to that file so it

00:40:38,120 --> 00:40:42,620
would be a harder stronger type of

00:40:40,370 --> 00:40:44,210
negative daintree but for this

00:40:42,620 --> 00:40:53,870
implementation I believe it's no longer

00:40:44,210 --> 00:40:55,400
needed so I'm dropping that why can't we

00:40:53,870 --> 00:40:57,770
just treat them like positive entries

00:40:55,400 --> 00:40:59,150
positive entries the first encoding is

00:40:57,770 --> 00:41:00,710
the one you take on the file format

00:40:59,150 --> 00:41:02,870
nobody can really alter the encoding

00:41:00,710 --> 00:41:05,360
after that why does it matter that we

00:41:02,870 --> 00:41:06,920
won't change the entry from negative to

00:41:05,360 --> 00:41:08,330
positive it's actually the coding that

00:41:06,920 --> 00:41:10,640
was in the negative two entry that we

00:41:08,330 --> 00:41:13,760
take so assume you searched a file that

00:41:10,640 --> 00:41:15,680
is uppercase foo and then you are gonna

00:41:13,760 --> 00:41:18,470
create a negative daintree that is

00:41:15,680 --> 00:41:20,270
uppercase foo and then you create a file

00:41:18,470 --> 00:41:23,210
and then you actually create a file that

00:41:20,270 --> 00:41:25,340
is lowercase foo you're gonna find the

00:41:23,210 --> 00:41:27,110
negative the entry which is uppercase

00:41:25,340 --> 00:41:28,970
foo but what you need to store is full

00:41:27,110 --> 00:41:30,260
lowercase so we need to invalidate that

00:41:28,970 --> 00:41:32,720
thanks we can create another one or

00:41:30,260 --> 00:41:34,910
transform right but if you if you create

00:41:32,720 --> 00:41:36,890
a file on the file system uppercase foo

00:41:34,910 --> 00:41:38,900
and then you try and use it as lowercase

00:41:36,890 --> 00:41:40,730
foo and you try and write to it

00:41:38,900 --> 00:41:44,240
everything works but it's always a it's

00:41:40,730 --> 00:41:48,040
always stays as uppercase foo so there's

00:41:44,240 --> 00:41:48,040
I don't see a particular

00:41:54,790 --> 00:42:10,130
if you actually so you combine napkins

00:41:59,359 --> 00:42:16,480
so were you telling me his first

00:42:10,130 --> 00:42:16,480
positive name is hard requirement okay

00:42:22,839 --> 00:42:27,130

YouTube URL: https://www.youtube.com/watch?v=9xieEWFDEtU


