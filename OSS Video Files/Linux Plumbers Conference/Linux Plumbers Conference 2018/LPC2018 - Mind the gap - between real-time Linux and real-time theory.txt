Title: LPC2018 - Mind the gap - between real-time Linux and real-time theory
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/75/
speaker:  Daniel Bristot de Oliveira (Red Hat)


It is common to see Linux being used on real-time research projects. However, the assumptions made in papers are very often unrealistic. In contrast, researchers argue that the main metric used on PREEMPT RT, although useful, is an oversimplification of the problem.

It is a consensus that the academic research helps to improve Linuxâ€™s state-of-art, and vice-versa. So how can we reduce the gap between these task forces? The real-time researchers start papers with a clear definition of the task model. But we do not have a task model for Linux: this is where the gap is.

This talk presents effort on establishing the task model for the PREEMPT RT Linux. Starting with the description of the operations that influence the timing behavior of tasks, passing by the definition of the relationships of the operations. Finally, the outcomes for Linux, like new metrics for the PREEMPT RT and a model validator (a lockdep like verificator, but for preemption) for the kernel, are discussed.
Captions: 
	00:00:05,950 --> 00:00:10,310
before I start I would say that this is

00:00:08,410 --> 00:00:11,780
one of the most boring

00:00:10,310 --> 00:00:16,970
sensations you guy will see on your

00:00:11,780 --> 00:00:19,280
lives because we are touching the part

00:00:16,970 --> 00:00:22,850
where the real time makes different

00:00:19,280 --> 00:00:26,660
difference and where we need some math

00:00:22,850 --> 00:00:29,930
background and these math is boring by

00:00:26,660 --> 00:00:33,050
its nature but we are I'm trying to find

00:00:29,930 --> 00:00:37,190
a way to explain things in a more I'd

00:00:33,050 --> 00:00:41,090
say reasonable way and I hope I can do

00:00:37,190 --> 00:00:42,740
it so minor gap between real time and

00:00:41,090 --> 00:00:45,670
theory I'm Daniel

00:00:42,740 --> 00:00:50,990
I work for Red Hat in the real time team

00:00:45,670 --> 00:00:54,410
on the Clarkes gang but I am also a PhD

00:00:50,990 --> 00:00:57,860
student at scuola superiores Santana in

00:00:54,410 --> 00:01:02,570
Pisa Italy and universidad fin de Raadt

00:00:57,860 --> 00:01:06,650
santa catarina in brazil so I live

00:01:02,570 --> 00:01:11,930
between the war of practical real time

00:01:06,650 --> 00:01:16,549
in theoretical real time but let's start

00:01:11,930 --> 00:01:18,979
explaining the things let's say that at

00:01:16,549 --> 00:01:21,320
the beginning the computers have the

00:01:18,979 --> 00:01:24,710
software in the logical sequence that it

00:01:21,320 --> 00:01:27,049
needs to follow and the correctness of

00:01:24,710 --> 00:01:30,859
the software was about the correctness

00:01:27,049 --> 00:01:32,600
of the logical sequence of things but

00:01:30,859 --> 00:01:37,399
then someone said ok we cannot wait

00:01:32,600 --> 00:01:41,179
forever we have to finish this before a

00:01:37,399 --> 00:01:43,369
deadline and then we have the theory of

00:01:41,179 --> 00:01:45,409
the real-time systems in which the

00:01:43,369 --> 00:01:48,409
correctness of the system does not

00:01:45,409 --> 00:01:51,289
depend only in the logical correctness

00:01:48,409 --> 00:01:53,659
of the software but also in the timing

00:01:51,289 --> 00:02:01,639
behavior of the system in the response

00:01:53,659 --> 00:02:03,889
time of a real-time task so this we have

00:02:01,639 --> 00:02:06,469
ok in one side like on my redhead side

00:02:03,889 --> 00:02:09,800
I'm a kernel developer and I deal with

00:02:06,469 --> 00:02:13,190
code and tasks and the scheduler and

00:02:09,800 --> 00:02:16,280
Linux problems but on the other side in

00:02:13,190 --> 00:02:19,010
the theory they don't have this kind of

00:02:16,280 --> 00:02:20,930
abstraction and they don't work on the

00:02:19,010 --> 00:02:23,360
operating system kernel level of

00:02:20,930 --> 00:02:26,450
abstraction they work in the

00:02:23,360 --> 00:02:29,360
F domain where things are defined as

00:02:26,450 --> 00:02:31,850
variables like the system is not

00:02:29,360 --> 00:02:34,400
composed of a process the system is

00:02:31,850 --> 00:02:37,790
composed of tasks and each task doesn't

00:02:34,400 --> 00:02:41,300
have actually a code it has some timing

00:02:37,790 --> 00:02:46,040
properties for example a system is

00:02:41,300 --> 00:02:48,790
composed of a set of tasks each task is

00:02:46,040 --> 00:02:52,340
composed of a set of timing

00:02:48,790 --> 00:02:53,990
characteristics like a task has a period

00:02:52,340 --> 00:02:58,750
like we have been scattered like I have

00:02:53,990 --> 00:03:02,060
to set a worst case execution time and

00:02:58,750 --> 00:03:04,520
one time that it blocks on some shared

00:03:02,060 --> 00:03:06,560
resources like a mutex or spin locks on

00:03:04,520 --> 00:03:08,480
our domain but on their domain is just a

00:03:06,560 --> 00:03:11,600
variable saying okay I can block this

00:03:08,480 --> 00:03:15,920
amount of time and we can have some kind

00:03:11,600 --> 00:03:18,470
of jitter and using just the variables

00:03:15,920 --> 00:03:22,670
abstract in the code they try to define

00:03:18,470 --> 00:03:25,420
or develop a scheduler in situated for

00:03:22,670 --> 00:03:28,370
all tasks the deadline of task is

00:03:25,420 --> 00:03:34,330
shorter or earlier than the deadline of

00:03:28,370 --> 00:03:39,860
the task so for example in the real-time

00:03:34,330 --> 00:03:41,510
theory a very well known scheduler is

00:03:39,860 --> 00:03:43,310
the fixed priority scheduler which is

00:03:41,510 --> 00:03:46,130
somehow similar to the FIFO scheduler

00:03:43,310 --> 00:03:48,709
and we have a task with a priority and

00:03:46,130 --> 00:03:51,650
for this kind of a scheduler they have

00:03:48,709 --> 00:03:53,870
one formula that says that the

00:03:51,650 --> 00:03:55,700
worst-case response time of my task is

00:03:53,870 --> 00:03:58,780
the busy window of the task

00:03:55,700 --> 00:04:01,670
plus the release jitter of the task and

00:03:58,780 --> 00:04:03,920
the busy window is composed of the

00:04:01,670 --> 00:04:06,320
execution time of the task plus the

00:04:03,920 --> 00:04:08,630
blocking time in which it's blocked

00:04:06,320 --> 00:04:11,330
waiting for a resource plus the

00:04:08,630 --> 00:04:16,459
execution time or the interference of

00:04:11,330 --> 00:04:19,160
tasks of higher priority and if they get

00:04:16,459 --> 00:04:22,310
a set of tasks and do discount and say

00:04:19,160 --> 00:04:24,680
that okay if for all tasks in my task

00:04:22,310 --> 00:04:27,020
set if you for all the tasks the

00:04:24,680 --> 00:04:29,570
response time is before the deadline I

00:04:27,020 --> 00:04:31,130
say that the system is schedulable and I

00:04:29,570 --> 00:04:35,690
can provide guarantee using this

00:04:31,130 --> 00:04:37,940
scheduler and so they think on this

00:04:35,690 --> 00:04:40,700
level

00:04:37,940 --> 00:04:45,890
another there are some simpler models

00:04:40,700 --> 00:04:50,900
like the 40 scattered line the okay

00:04:45,890 --> 00:04:52,700
setback so when they developed a

00:04:50,900 --> 00:04:55,280
scheduler they try to make such a

00:04:52,700 --> 00:04:58,700
formula to guarantee this that that's

00:04:55,280 --> 00:05:02,180
their goal for example a deadline we

00:04:58,700 --> 00:05:04,130
have that formula is simplified or for

00:05:02,180 --> 00:05:06,080
our EDF schedule and they say that the

00:05:04,130 --> 00:05:10,550
utilization of the system should be

00:05:06,080 --> 00:05:12,590
lower than 100 percent that is the run

00:05:10,550 --> 00:05:16,520
time over the period of the task this

00:05:12,590 --> 00:05:19,070
sum if it's lower than 1 or 100 percent

00:05:16,520 --> 00:05:21,500
of time this system is scalable and they

00:05:19,070 --> 00:05:27,550
prove this guarantees using math theorem

00:05:21,500 --> 00:05:30,860
and lamps and so on so ok

00:05:27,550 --> 00:05:34,100
the development of a real-time scheduler

00:05:30,860 --> 00:05:38,660
in theory it's not done in the basis of

00:05:34,100 --> 00:05:44,170
code reasoning but on math reasoning for

00:05:38,660 --> 00:05:48,800
example this is how it looks like a

00:05:44,170 --> 00:05:50,720
diplomate a ssin of a scheduler which is

00:05:48,800 --> 00:05:53,600
we will talk a little bit about this in

00:05:50,720 --> 00:05:56,750
the other representation and you see

00:05:53,600 --> 00:06:00,650
here we don't see code we see just

00:05:56,750 --> 00:06:03,220
graphs and formulas formulas formulas

00:06:00,650 --> 00:06:03,220
formulas

00:06:06,889 --> 00:06:11,830
so

00:06:08,889 --> 00:06:18,189
but generally when they developed such

00:06:11,830 --> 00:06:23,560
schedulers they reduce the complexity of

00:06:18,189 --> 00:06:27,030
the system and assume things that things

00:06:23,560 --> 00:06:29,469
like okay this system is fully primitive

00:06:27,030 --> 00:06:32,050
okay the tasks are completely

00:06:29,469 --> 00:06:34,629
independent all the operations are

00:06:32,050 --> 00:06:37,240
atomic like the arrival of a task and

00:06:34,629 --> 00:06:40,080
the scheduling of the task takes

00:06:37,240 --> 00:06:43,360
atomically in the same a moment and

00:06:40,080 --> 00:06:49,020
there is no overhead of operations for

00:06:43,360 --> 00:06:52,599
example and well these operations

00:06:49,020 --> 00:06:55,960
doesn't exactly fit on the systems that

00:06:52,599 --> 00:06:58,360
we have for example on linux even on the

00:06:55,960 --> 00:07:00,370
prematurity the operating system is not

00:06:58,360 --> 00:07:03,849
fully preemptive because we can disable

00:07:00,370 --> 00:07:06,669
preemption the tasks are not complete

00:07:03,849 --> 00:07:09,129
independent because when scheduling we

00:07:06,669 --> 00:07:11,770
have locks protecting the scheduler so

00:07:09,129 --> 00:07:13,919
one text test came facing the operation

00:07:11,770 --> 00:07:17,560
of orders operations are not atomic

00:07:13,919 --> 00:07:20,680
because when one test is awakened we

00:07:17,560 --> 00:07:22,659
need to include it in the scheduler we

00:07:20,680 --> 00:07:24,669
need to check if we need to rescan and

00:07:22,659 --> 00:07:26,819
we need to decide to call the scheduler

00:07:24,669 --> 00:07:32,589
code scanner account the context switch

00:07:26,819 --> 00:07:35,229
so we tend to say that that reality is

00:07:32,589 --> 00:07:38,349
not a reality and that's a war between

00:07:35,229 --> 00:07:40,240
cracks and the theory and we have like

00:07:38,349 --> 00:07:45,000
articles from Thomas collector for

00:07:40,240 --> 00:07:49,330
example criticizing this and ok that

00:07:45,000 --> 00:07:52,330
this is not that is not a reality ok

00:07:49,330 --> 00:07:54,550
that we cannot say we cannot beat on

00:07:52,330 --> 00:07:56,529
them saying that these are not realistic

00:07:54,550 --> 00:07:59,520
because there are very simple operating

00:07:56,529 --> 00:08:02,710
systems in which those things are real

00:07:59,520 --> 00:08:04,779
but they are mostly very simple system

00:08:02,710 --> 00:08:07,680
where the scheduling is done offline on

00:08:04,779 --> 00:08:11,139
beforehand they know the number of tests

00:08:07,680 --> 00:08:15,279
so the problem is not that they don't

00:08:11,139 --> 00:08:19,870
use realistic assumptions the problem is

00:08:15,279 --> 00:08:22,240
that our reality is not that reality but

00:08:19,870 --> 00:08:26,470
what is your reality what

00:08:22,240 --> 00:08:28,840
our aura constraints okay so as I was

00:08:26,470 --> 00:08:30,250
saying okay our system is not fully

00:08:28,840 --> 00:08:32,770
preemptive because we can disable

00:08:30,250 --> 00:08:34,479
preemption tasks are not completely

00:08:32,770 --> 00:08:36,190
independent because we have spin locks

00:08:34,479 --> 00:08:38,830
protecting the scheduler and so this

00:08:36,190 --> 00:08:41,110
scheduling is mean not neither atomic

00:08:38,830 --> 00:08:43,390
and not independent and we have overhead

00:08:41,110 --> 00:08:49,600
we are we are in a more complex

00:08:43,390 --> 00:08:53,410
environment okay and so we can tell them

00:08:49,600 --> 00:08:58,420
yeah boys or reality is not that you

00:08:53,410 --> 00:09:00,550
guys are wrong and say that okay the

00:08:58,420 --> 00:09:02,890
math side okay my math side talking to

00:09:00,550 --> 00:09:06,459
my developer side by my side I would say

00:09:02,890 --> 00:09:10,600
okay developer talk is shape and then my

00:09:06,459 --> 00:09:14,350
left side okay hey math side the code is

00:09:10,600 --> 00:09:16,540
a computer it's math you know the code

00:09:14,350 --> 00:09:20,230
is there you can just read the code and

00:09:16,540 --> 00:09:21,910
understand stuff and then my math side

00:09:20,230 --> 00:09:25,650
would say okay talk is cheap

00:09:21,910 --> 00:09:27,910
show me the math behind the story like

00:09:25,650 --> 00:09:30,190
it's easy to tell

00:09:27,910 --> 00:09:32,320
okay read the code but generally the

00:09:30,190 --> 00:09:34,690
guys that are developing a scheduler in

00:09:32,320 --> 00:09:37,570
the academic side they are not Linux

00:09:34,690 --> 00:09:41,529
kernel developers they are PhD students

00:09:37,570 --> 00:09:44,110
like in the between 20 and 30 years old

00:09:41,529 --> 00:09:45,730
we know that takes a lot of time to

00:09:44,110 --> 00:09:51,130
understand Linux kernel and how things

00:09:45,730 --> 00:09:54,130
works so we need to show the math behind

00:09:51,130 --> 00:09:57,880
Linux kernel to them so them can use and

00:09:54,130 --> 00:10:02,560
they can base their development in the

00:09:57,880 --> 00:10:04,380
math that we have in kernel so inside

00:10:02,560 --> 00:10:10,240
our mind the mind of a real-time

00:10:04,380 --> 00:10:12,310
developer we know that we have we can

00:10:10,240 --> 00:10:15,180
disable preemption and disable

00:10:12,310 --> 00:10:18,730
preemption we can cause latency we know

00:10:15,180 --> 00:10:20,760
that we have different kinds of logs we

00:10:18,730 --> 00:10:22,480
know the difference between a mutex and

00:10:20,760 --> 00:10:26,800
a spin lock

00:10:22,480 --> 00:10:31,690
we know we have interrupts and we try to

00:10:26,800 --> 00:10:34,600
explain this like many times but when we

00:10:31,690 --> 00:10:35,980
try to explain things using natural

00:10:34,600 --> 00:10:40,720
language like I'm doing

00:10:35,980 --> 00:10:43,450
things are ambiguous for example is

00:10:40,720 --> 00:10:48,640
preemption disabled bad are good for

00:10:43,450 --> 00:10:50,590
latency we tend to say it's bad but

00:10:48,640 --> 00:10:53,170
actually when we are scheduling we are

00:10:50,590 --> 00:10:56,020
with branch and disabled and if we have

00:10:53,170 --> 00:10:58,030
the arrival of a task right before this

00:10:56,020 --> 00:11:02,950
scheduler we will have the best case

00:10:58,030 --> 00:11:07,110
latency so just explain things on

00:11:02,950 --> 00:11:10,270
language give us this ambiguity that

00:11:07,110 --> 00:11:19,330
turns things confuse for a mathematician

00:11:10,270 --> 00:11:22,750
right so we need okay I think we need to

00:11:19,330 --> 00:11:24,790
rather than explain a explicity model

00:11:22,750 --> 00:11:27,090
that we have inside our implicit model

00:11:24,790 --> 00:11:30,460
that we have inside our mind right a

00:11:27,090 --> 00:11:35,550
explicit model explaining all this

00:11:30,460 --> 00:11:39,880
behavior in not using a natural language

00:11:35,550 --> 00:11:44,290
but using a formal method a mathematical

00:11:39,880 --> 00:11:49,000
language we also need to abstract the

00:11:44,290 --> 00:11:51,580
code like rather than explaining all the

00:11:49,000 --> 00:11:54,850
code we have explained things that can

00:11:51,580 --> 00:11:56,650
cause in that can interfere in the

00:11:54,850 --> 00:12:00,550
response time of a task but without

00:11:56,650 --> 00:12:04,300
showing code working on their domain not

00:12:00,550 --> 00:12:08,380
on order me but we need to do this

00:12:04,300 --> 00:12:10,960
without losing contact or with what we

00:12:08,380 --> 00:12:13,540
have in practice we need to explain

00:12:10,960 --> 00:12:15,670
kernel using a mathematical language a

00:12:13,540 --> 00:12:18,010
mathematical model but without losing

00:12:15,670 --> 00:12:20,430
contact with the way that we understand

00:12:18,010 --> 00:12:20,430
the kernel

00:12:24,269 --> 00:12:32,529
so how do we observe the parameter T

00:12:29,170 --> 00:12:36,519
which kind of things we use we mostly

00:12:32,529 --> 00:12:38,950
use trace we get a latency we trace the

00:12:36,519 --> 00:12:41,190
system we see the events the chain of

00:12:38,950 --> 00:12:44,350
events and try to explain things

00:12:41,190 --> 00:12:47,470
okay this latency was caused because I

00:12:44,350 --> 00:12:50,529
had a series of interrupts or this case

00:12:47,470 --> 00:12:52,390
were these latency was caused because I

00:12:50,529 --> 00:12:56,440
have this new code that disable

00:12:52,390 --> 00:12:59,760
preemption for a long time or and so on

00:12:56,440 --> 00:13:03,100
so inside our mind we think on trace

00:12:59,760 --> 00:13:10,200
events and states in which we call

00:13:03,100 --> 00:13:14,350
latency for example and this this set of

00:13:10,200 --> 00:13:16,360
events trace and States is in common

00:13:14,350 --> 00:13:20,740
with the theory of discrete event

00:13:16,360 --> 00:13:22,990
systems and discrete event systems they

00:13:20,740 --> 00:13:26,800
also have the idea of events that cause

00:13:22,990 --> 00:13:32,560
a state change and we form trace of

00:13:26,800 --> 00:13:35,380
events and so in my thesis of my PhD is

00:13:32,560 --> 00:13:39,820
that it's possible to explain Linux

00:13:35,380 --> 00:13:43,600
using discrete event systems theory so

00:13:39,820 --> 00:13:46,480
why not try to describe Linux using this

00:13:43,600 --> 00:13:49,390
formal method why not we know a Linux

00:13:46,480 --> 00:13:54,750
runs inside our mind we know how the

00:13:49,390 --> 00:14:00,029
dynamic works why not try to explain so

00:13:54,750 --> 00:14:05,020
in the discrete event systems its from

00:14:00,029 --> 00:14:07,959
control theory we have some methods to

00:14:05,020 --> 00:14:10,750
explain systems like Petri net works who

00:14:07,959 --> 00:14:15,990
here stood battery networks in the

00:14:10,750 --> 00:14:19,360
academic side okay good and automata

00:14:15,990 --> 00:14:21,490
yeah that's formal methods it's it's a

00:14:19,360 --> 00:14:24,940
very boring class when you're in the

00:14:21,490 --> 00:14:26,860
undergrad because it cache us it's hard

00:14:24,940 --> 00:14:29,260
to define a system and get in all the

00:14:26,860 --> 00:14:31,449
possible states and prove it's working

00:14:29,260 --> 00:14:33,500
and that's the idea behind of this

00:14:31,449 --> 00:14:38,010
current event system

00:14:33,500 --> 00:14:40,880
so formally in among these methods like

00:14:38,010 --> 00:14:42,089
battery networks stochastic systems in

00:14:40,880 --> 00:14:45,180
automata

00:14:42,089 --> 00:14:47,670
we have automata which it was the

00:14:45,180 --> 00:14:51,000
language I could express me better

00:14:47,670 --> 00:14:53,820
the Daniel developer could express his

00:14:51,000 --> 00:14:57,930
model inside his mind using the

00:14:53,820 --> 00:15:04,220
mathematical model so one automata is a

00:14:57,930 --> 00:15:07,290
set of states a finite set of events a

00:15:04,220 --> 00:15:09,360
set of functions that say okay if I am

00:15:07,290 --> 00:15:12,180
on this state and I receive this event

00:15:09,360 --> 00:15:16,440
I'm going to this state for example I'm

00:15:12,180 --> 00:15:19,320
running with preemption enabled so I'm

00:15:16,440 --> 00:15:21,120
in the preemption enable state the event

00:15:19,320 --> 00:15:22,589
of disabling preemption bring me to the

00:15:21,120 --> 00:15:24,779
state in which I am with preemption

00:15:22,589 --> 00:15:27,709
disabled I will return to the initial

00:15:24,779 --> 00:15:30,240
state if I receive a preemption enabled

00:15:27,709 --> 00:15:32,670
so I have one initial state of the

00:15:30,240 --> 00:15:36,060
systems and a set of final states of the

00:15:32,670 --> 00:15:39,360
system and then we say that when we have

00:15:36,060 --> 00:15:41,670
a trace a set of events that is

00:15:39,360 --> 00:15:44,670
recognized by this automata and is

00:15:41,670 --> 00:15:50,699
generated by the automata we have the

00:15:44,670 --> 00:15:54,120
language that this system is specs so we

00:15:50,699 --> 00:15:56,459
want to using this method is pick the

00:15:54,120 --> 00:15:58,170
language that the kernel respects like

00:15:56,459 --> 00:16:00,360
on these terms of disable preemption

00:15:58,170 --> 00:16:04,380
neighbor preemption called scheduler and

00:16:00,360 --> 00:16:07,620
so on okay this seems to be very hard at

00:16:04,380 --> 00:16:11,399
doing these things in in sets and

00:16:07,620 --> 00:16:14,399
functions yeah it's hard but automata

00:16:11,399 --> 00:16:18,060
has a graphical format that turns all

00:16:14,399 --> 00:16:20,640
these things easier in a graph format we

00:16:18,060 --> 00:16:22,800
have an initial state and the event

00:16:20,640 --> 00:16:26,579
cause effects transitions like the from

00:16:22,800 --> 00:16:30,300
state acts even G I'm going to state C

00:16:26,579 --> 00:16:32,940
and this is a final state so this graph

00:16:30,300 --> 00:16:35,820
format helps me or helps the developer

00:16:32,940 --> 00:16:38,070
to explain things on a graphic format

00:16:35,820 --> 00:16:39,870
which is way more intuitive I know it's

00:16:38,070 --> 00:16:42,740
boring but into more intuitive and

00:16:39,870 --> 00:16:47,440
working it set in regular expressions

00:16:42,740 --> 00:16:51,650
and this helped it to in the development

00:16:47,440 --> 00:16:55,130
so then one might think that I would

00:16:51,650 --> 00:16:58,720
have to explain all the Linux stuff

00:16:55,130 --> 00:17:02,030
using drawing this drawing these

00:16:58,720 --> 00:17:03,860
automaton and we can think that okay the

00:17:02,030 --> 00:17:07,520
number of states on Linux is way higher

00:17:03,860 --> 00:17:11,180
than tree right and it'd be very hard to

00:17:07,520 --> 00:17:13,850
draw a even one system draw it out

00:17:11,180 --> 00:17:16,610
Tomita is specified Mahomet of a system

00:17:13,850 --> 00:17:18,380
like Linux that for example in the end

00:17:16,610 --> 00:17:21,890
we will see that for the single core we

00:17:18,380 --> 00:17:25,130
have more than 10,000 States it would be

00:17:21,890 --> 00:17:27,680
it's not possible by human to draw off

00:17:25,130 --> 00:17:31,910
the states it's it's the boring of the

00:17:27,680 --> 00:17:36,230
boring so but there is one modeling

00:17:31,910 --> 00:17:40,280
approach from the theoretical control

00:17:36,230 --> 00:17:43,490
engineering in which we design the

00:17:40,280 --> 00:17:47,150
system using models is more pieces of

00:17:43,490 --> 00:17:50,210
the model a modular approach and I'll

00:17:47,150 --> 00:17:53,180
explain a little bit in the single core

00:17:50,210 --> 00:17:56,270
what I did before but general case what

00:17:53,180 --> 00:17:59,720
we do we construct models of the

00:17:56,270 --> 00:18:01,880
generators of events independently for

00:17:59,720 --> 00:18:03,740
example I can disable preemption and

00:18:01,880 --> 00:18:05,540
enable preemption I can save our queue

00:18:03,740 --> 00:18:07,730
and a neighbor you I can call this

00:18:05,540 --> 00:18:10,340
character and return the schedule each

00:18:07,730 --> 00:18:12,290
one of these is one model and then we

00:18:10,340 --> 00:18:14,690
are saying with all this model using a

00:18:12,290 --> 00:18:16,640
mathematical operation of automata and

00:18:14,690 --> 00:18:19,130
we have all the possible chains of

00:18:16,640 --> 00:18:21,560
events those that are possible and that

00:18:19,130 --> 00:18:23,960
are not possible then we designed the

00:18:21,560 --> 00:18:26,510
control rules that saying what is

00:18:23,960 --> 00:18:28,850
possible or not possible using our

00:18:26,510 --> 00:18:31,490
automata but using specifications and

00:18:28,850 --> 00:18:35,840
then when we assembly everything we have

00:18:31,490 --> 00:18:39,890
a complete model of the system using the

00:18:35,840 --> 00:18:42,340
formal language okay it will be easier

00:18:39,890 --> 00:18:47,450
explaining things step by step so

00:18:42,340 --> 00:18:51,830
example of models we can have a task

00:18:47,450 --> 00:18:55,280
initially a task is asleep abbu and when

00:18:51,830 --> 00:18:56,480
we have like scared waking it becomes

00:18:55,280 --> 00:18:59,180
runnable

00:18:56,480 --> 00:19:01,460
and then when we return for example to

00:18:59,180 --> 00:19:03,800
sleepable state setting set current

00:19:01,460 --> 00:19:05,450
state to interrupt able or

00:19:03,800 --> 00:19:11,060
uninterruptible the task becomes

00:19:05,450 --> 00:19:15,040
sleepable again ok but waking the task

00:19:11,060 --> 00:19:18,560
in turn tis sleepable doesn't actually

00:19:15,040 --> 00:19:20,900
puts the task in the scheduler or make

00:19:18,560 --> 00:19:24,530
it run or we remove it from the

00:19:20,900 --> 00:19:28,010
scheduler one task start running after

00:19:24,530 --> 00:19:30,560
we do the contact switch for it the

00:19:28,010 --> 00:19:34,780
context switch like from task 1 task B

00:19:30,560 --> 00:19:40,130
and it starts running then it runs and

00:19:34,780 --> 00:19:42,170
if if it is Pascal for example suspends

00:19:40,130 --> 00:19:44,600
its execution or is preempted by a

00:19:42,170 --> 00:19:47,480
higher priority task it will suffer the

00:19:44,600 --> 00:19:49,280
contact switch back returning from the

00:19:47,480 --> 00:19:51,710
running so the task is not runny

00:19:49,280 --> 00:19:54,490
contacts which it's really contact

00:19:51,710 --> 00:19:57,170
switch out it's not running back again

00:19:54,490 --> 00:19:59,450
we can call this cat we can have a

00:19:57,170 --> 00:20:01,930
thread running we can call this

00:19:59,450 --> 00:20:05,630
scheduler and return from the scheduler

00:20:01,930 --> 00:20:08,750
we can also set the need risk at which

00:20:05,630 --> 00:20:13,820
is itself just a model else as simple as

00:20:08,750 --> 00:20:15,770
this we can like in the initial state we

00:20:13,820 --> 00:20:20,150
say that the system is with a preemption

00:20:15,770 --> 00:20:23,570
enabled then we can call we can disable

00:20:20,150 --> 00:20:26,450
preemption to the lady scheduler and

00:20:23,570 --> 00:20:28,880
enable it back or we can disable

00:20:26,450 --> 00:20:30,770
preemption to call the scheduler because

00:20:28,880 --> 00:20:32,690
the main scheduler function the - -

00:20:30,770 --> 00:20:36,770
schedule is always called with

00:20:32,690 --> 00:20:39,620
preemption disabled and then after run

00:20:36,770 --> 00:20:42,170
this gallery can enable it back again we

00:20:39,620 --> 00:20:46,190
can disable interrupts and enable auto

00:20:42,170 --> 00:20:48,740
interrupt before handling one req the

00:20:46,190 --> 00:20:52,070
processor itself mask interrupts and

00:20:48,740 --> 00:20:54,680
then deal with handle the our queue and

00:20:52,070 --> 00:21:02,050
then in the return it enables back to

00:20:54,680 --> 00:21:02,050
interrupt yeah I told this is boring

00:21:04,530 --> 00:21:13,990
but that's how things are and that's the

00:21:11,260 --> 00:21:18,150
complexity of Linux and that's the

00:21:13,990 --> 00:21:21,250
complexity we have inside our minds and

00:21:18,150 --> 00:21:24,310
we so far had not find a way to explain

00:21:21,250 --> 00:21:27,660
for mathematicians but here we are

00:21:24,310 --> 00:21:30,070
talking like using terms that we know

00:21:27,660 --> 00:21:31,720
enable preemption zero preemption call

00:21:30,070 --> 00:21:34,810
the scheduler return from the scheduler

00:21:31,720 --> 00:21:38,290
it's or language as well but I'm

00:21:34,810 --> 00:21:42,640
expressing these using a mathematical

00:21:38,290 --> 00:21:46,410
language and that's the gap between the

00:21:42,640 --> 00:21:53,530
reality and the theoretical real time

00:21:46,410 --> 00:21:56,740
for Linux so there I was explaining the

00:21:53,530 --> 00:21:58,830
events independently and that's audition

00:21:56,740 --> 00:22:01,720
and when I synchronize all these

00:21:58,830 --> 00:22:04,420
automatons I have a huge automata with

00:22:01,720 --> 00:22:07,060
all possible chain of events I'm not

00:22:04,420 --> 00:22:10,930
forgetting any chain that could happen

00:22:07,060 --> 00:22:13,330
but this this chain of events might not

00:22:10,930 --> 00:22:19,060
happen in the reality because one event

00:22:13,330 --> 00:22:20,800
blocks the other for example okay they

00:22:19,060 --> 00:22:23,350
need we're scared and scared waking

00:22:20,800 --> 00:22:27,360
events like set need risk and schedule a

00:22:23,350 --> 00:22:31,530
cup of a task they cannot take place

00:22:27,360 --> 00:22:34,750
with preemption and I are accuse enabled

00:22:31,530 --> 00:22:37,390
so how do i model this how do i suppress

00:22:34,750 --> 00:22:40,780
this in an unambiguous way using

00:22:37,390 --> 00:22:43,780
automata I say that in my initial state

00:22:40,780 --> 00:22:46,290
we are with preemption enabled on the

00:22:43,780 --> 00:22:49,930
parameter T and then we can have either

00:22:46,290 --> 00:22:53,530
preemption or interrupt disabled and

00:22:49,930 --> 00:22:55,780
then when we disable the order we can

00:22:53,530 --> 00:22:58,300
have both disabled and only in this

00:22:55,780 --> 00:23:03,970
situation we set need risk add and cows

00:22:58,300 --> 00:23:08,350
cat waking so in mathematical terms we

00:23:03,970 --> 00:23:11,350
say that the having preemption and Erick

00:23:08,350 --> 00:23:14,740
use disabled are sufficient conditions

00:23:11,350 --> 00:23:16,060
to wake up a task and those theoretical

00:23:14,740 --> 00:23:19,540
guys in

00:23:16,060 --> 00:23:22,360
understand that okay what my say that

00:23:19,540 --> 00:23:25,960
okay I can disable preemption here with

00:23:22,360 --> 00:23:27,160
a pram to disable like here the events

00:23:25,960 --> 00:23:29,250
are on the top of the edge like

00:23:27,160 --> 00:23:31,570
preempted disabled would cosmides and

00:23:29,250 --> 00:23:35,620
preempted prompted is able to cows

00:23:31,570 --> 00:23:39,430
casual would also bring me here so okay

00:23:35,620 --> 00:23:42,280
I can skip the local req disabled so oh

00:23:39,430 --> 00:23:47,610
no that's just part of the model we have

00:23:42,280 --> 00:23:50,500
a lot of these is Mall rules of

00:23:47,610 --> 00:23:55,960
sufficiency and necessary conditions for

00:23:50,500 --> 00:23:58,210
the occurrence of the event and for

00:23:55,960 --> 00:24:00,100
example I cannot call preempted disabled

00:23:58,210 --> 00:24:02,830
and then disable preemption took out the

00:24:00,100 --> 00:24:05,620
scheduler because the model here blocks

00:24:02,830 --> 00:24:07,720
it they are Muto exclusive in this state

00:24:05,620 --> 00:24:10,990
I cannot call this it okay the prompt

00:24:07,720 --> 00:24:12,910
say boys cat is present on this state

00:24:10,990 --> 00:24:14,790
but it's not present on this so it

00:24:12,910 --> 00:24:18,130
cannot happen here

00:24:14,790 --> 00:24:21,010
that's why these guards me that here I

00:24:18,130 --> 00:24:23,110
would have to take either prime to

00:24:21,010 --> 00:24:26,440
disabled and Eric use a bow or Eric you

00:24:23,110 --> 00:24:31,540
disable and Prem disabled - caused in

00:24:26,440 --> 00:24:34,240
the conditions this scheduler is only

00:24:31,540 --> 00:24:39,010
called with preemption disabled to call

00:24:34,240 --> 00:24:41,470
the scheduler the scheduler call never

00:24:39,010 --> 00:24:47,080
takes place with irqs

00:24:41,470 --> 00:24:50,110
disabled the contacts which always take

00:24:47,080 --> 00:24:54,420
place after entering in the scheduler

00:24:50,110 --> 00:24:54,420
but before returning for the scheduler

00:24:54,600 --> 00:25:01,450
so the context switch always take place

00:24:58,630 --> 00:25:04,990
with preempted disable to call the

00:25:01,450 --> 00:25:07,120
scheduler and look how Eric you disable

00:25:04,990 --> 00:25:10,210
or locally disabled and preempted is

00:25:07,120 --> 00:25:12,010
able to call the scheduler these are

00:25:10,210 --> 00:25:16,510
sufficient conditions to call the

00:25:12,010 --> 00:25:19,960
contact switch and ok there I was

00:25:16,510 --> 00:25:24,300
talking about can you guys read this no

00:25:19,960 --> 00:25:24,300
he doesn't know ok so I will switch it

00:25:28,580 --> 00:25:38,070
okay now easy right there I was talking

00:25:35,790 --> 00:25:40,770
about sufficient condition a sufficient

00:25:38,070 --> 00:25:43,470
condition says that something can or

00:25:40,770 --> 00:25:45,990
cannot happen but if it's possible it

00:25:43,470 --> 00:25:48,660
can a necessary condition it says that

00:25:45,990 --> 00:25:50,640
okay if we have all sufficient

00:25:48,660 --> 00:25:53,310
conditions in the necessary condition

00:25:50,640 --> 00:26:01,350
the next day a thing will happen for

00:25:53,310 --> 00:26:05,850
sure so here is the Midd risk ad model

00:26:01,350 --> 00:26:08,490
that the models the necessary conditions

00:26:05,850 --> 00:26:13,080
for the need risk ad to call the

00:26:08,490 --> 00:26:15,930
scheduler to contact switch so when i

00:26:13,080 --> 00:26:18,300
have in the initial stage we have all

00:26:15,930 --> 00:26:21,660
become like I can take no text I can

00:26:18,300 --> 00:26:25,200
take a read and write semaphore read and

00:26:21,660 --> 00:26:29,040
write locks and I can do all the events

00:26:25,200 --> 00:26:32,400
of the system right but if at any time I

00:26:29,040 --> 00:26:37,200
have a need risk at I enter in this

00:26:32,400 --> 00:26:41,580
model that will only brings me to the

00:26:37,200 --> 00:26:43,770
initial state after a contact switch it

00:26:41,580 --> 00:26:48,180
means that okay I have the context I

00:26:43,770 --> 00:26:51,390
have need risk ad who takes place inside

00:26:48,180 --> 00:26:53,880
the scheduler right before contact

00:26:51,390 --> 00:26:55,770
switch the contacts which will be

00:26:53,880 --> 00:26:57,480
already ready to be done all the

00:26:55,770 --> 00:26:59,490
sufficient conditions for scats which

00:26:57,480 --> 00:27:02,010
will be present and the necessary

00:26:59,490 --> 00:27:04,170
condition takes place so I have the

00:27:02,010 --> 00:27:06,330
context switch this is the case in which

00:27:04,170 --> 00:27:09,210
they need risk at takes place with

00:27:06,330 --> 00:27:12,150
preemption disabled low and low Kerik

00:27:09,210 --> 00:27:15,470
you disabled inside the scheduler and so

00:27:12,150 --> 00:27:19,770
be ready to schedule I'll be on schedule

00:27:15,470 --> 00:27:24,450
okay this is this is one very specific

00:27:19,770 --> 00:27:28,560
case but generally this will not take

00:27:24,450 --> 00:27:30,660
place that's not the common path so as I

00:27:28,560 --> 00:27:32,910
said before the need risk EDD only takes

00:27:30,660 --> 00:27:37,260
place with preemption and I are accused

00:27:32,910 --> 00:27:38,970
disabled so I will only arrive in this

00:27:37,260 --> 00:27:42,570
state with both Prime

00:27:38,970 --> 00:27:45,690
and I recuse disabled I can enable I can

00:27:42,570 --> 00:27:48,270
enable preemption and then I will have a

00:27:45,690 --> 00:27:51,330
preemption enable but I can disable it

00:27:48,270 --> 00:27:53,910
back in ping-pong here I can enable our

00:27:51,330 --> 00:27:56,820
queue and disable it and while for

00:27:53,910 --> 00:27:59,460
example if I am with Florrick you

00:27:56,820 --> 00:28:03,690
disabled because of the wake not because

00:27:59,460 --> 00:28:06,660
I'm on I req then I enable I are accused

00:28:03,690 --> 00:28:09,620
back in this case I can disable Erik you

00:28:06,660 --> 00:28:13,950
again because of the occurrence of a

00:28:09,620 --> 00:28:18,990
interrupts and I can ping pong here so

00:28:13,950 --> 00:28:24,990
but as the system makes progress we

00:28:18,990 --> 00:28:29,220
might enable like enable irq then enable

00:28:24,990 --> 00:28:33,470
preemption and when these and when we

00:28:29,220 --> 00:28:37,230
have like enable preemption in enable

00:28:33,470 --> 00:28:39,600
irq I will reach to the state in which I

00:28:37,230 --> 00:28:41,930
will for sure call the scheduler because

00:28:39,600 --> 00:28:46,470
that's the only allowed operation and

00:28:41,930 --> 00:28:48,270
when I okay I will either disable

00:28:46,470 --> 00:28:51,270
preemption took out the scheduler if I

00:28:48,270 --> 00:28:53,610
am not calling the scheduler or I will

00:28:51,270 --> 00:28:56,820
call the scheduler if I am already in

00:28:53,610 --> 00:28:59,790
this very part image I for example I

00:28:56,820 --> 00:29:01,950
might try this running it's about to

00:28:59,790 --> 00:29:04,980
call the scheduler it disables

00:29:01,950 --> 00:29:08,340
preemption to call this scheduler I have

00:29:04,980 --> 00:29:12,210
interrupts that wakes up a task I don't

00:29:08,340 --> 00:29:14,310
need to disable and enable preemption

00:29:12,210 --> 00:29:18,330
again because I'm already on the way to

00:29:14,310 --> 00:29:21,270
call the scheduler so I don't have much

00:29:18,330 --> 00:29:24,750
time to to show all the cases here but

00:29:21,270 --> 00:29:27,240
these automata shows that some day

00:29:24,750 --> 00:29:29,700
sometime in the future we arrive to this

00:29:27,240 --> 00:29:32,850
condition in which the only thing I can

00:29:29,700 --> 00:29:38,280
do is to cause the contact switch and

00:29:32,850 --> 00:29:43,470
then return back ok this automaton

00:29:38,280 --> 00:29:48,140
explain part of the latency in the terms

00:29:43,470 --> 00:29:50,910
that ok when I have to wake up until the

00:29:48,140 --> 00:29:52,380
diskette switch of the task this is the

00:29:50,910 --> 00:29:55,890
main part of the

00:29:52,380 --> 00:29:59,340
latency that we study but I'm explaining

00:29:55,890 --> 00:30:00,960
these not using the terms of that you

00:29:59,340 --> 00:30:03,810
use in the scheduler but using a

00:30:00,960 --> 00:30:05,810
language a formal language and this is

00:30:03,810 --> 00:30:10,740
the model that explains the latency

00:30:05,810 --> 00:30:13,820
we're using their terms and so here they

00:30:10,740 --> 00:30:18,480
can extract the information like what

00:30:13,820 --> 00:30:21,450
what how how is the latest composed the

00:30:18,480 --> 00:30:27,570
latency is composed of the time I spend

00:30:21,450 --> 00:30:30,780
until enable enable preemption and I or

00:30:27,570 --> 00:30:36,510
accuse and then the time to call this

00:30:30,780 --> 00:30:39,330
scheduler like enable IARC use enable

00:30:36,510 --> 00:30:41,310
preemption I disable the preemption to

00:30:39,330 --> 00:30:45,900
call the scheduler called the scheduler

00:30:41,310 --> 00:30:49,200
and return to the initial state and I am

00:30:45,900 --> 00:30:59,580
in the method explaining that I am not

00:30:49,200 --> 00:31:00,450
missing any any event so by

00:30:59,580 --> 00:31:03,180
synchronizing

00:31:00,450 --> 00:31:06,900
all these models I have a model of how

00:31:03,180 --> 00:31:09,600
Linux works using automata for the

00:31:06,900 --> 00:31:12,090
single core case the model is composed

00:31:09,600 --> 00:31:16,440
of twelve generators and 33

00:31:12,090 --> 00:31:19,940
specifications or control rules I have I

00:31:16,440 --> 00:31:24,290
explained things using just 34 events

00:31:19,940 --> 00:31:28,680
which is a limited amount of events and

00:31:24,290 --> 00:31:33,660
the the system has a little bit more

00:31:28,680 --> 00:31:36,450
than 10,000 states and I will ask Paul

00:31:33,660 --> 00:31:39,180
McCain is help rehear because I would

00:31:36,450 --> 00:31:43,050
say that okay it seems that 10,000

00:31:39,180 --> 00:31:46,310
states is a huge state space but do you

00:31:43,050 --> 00:31:46,310
think it's huge bikini

00:31:51,290 --> 00:31:54,620
academics I tell them that their stuff

00:31:53,480 --> 00:32:00,140
isn't a semi language and they need

00:31:54,620 --> 00:32:01,820
compile the latest kernel to it yes in

00:32:00,140 --> 00:32:03,470
the other presentation he said that he

00:32:01,820 --> 00:32:06,020
has a case in which he I think he's very

00:32:03,470 --> 00:32:20,420
if arts you that or memory model which

00:32:06,020 --> 00:32:23,060
there are millions of states so ten

00:32:20,420 --> 00:32:27,560
thousand states is a reasonably low

00:32:23,060 --> 00:32:29,990
number of states and okay and the

00:32:27,560 --> 00:32:32,180
benefits okay let me see the next slide

00:32:29,990 --> 00:32:34,340
okay but nice but what do we okay now

00:32:32,180 --> 00:32:38,900
she explained things congratulations but

00:32:34,340 --> 00:32:41,120
how can we use this in practice so from

00:32:38,900 --> 00:32:44,870
the academic side understanding internal

00:32:41,120 --> 00:32:48,830
dynamics using dirt language will allow

00:32:44,870 --> 00:32:51,560
a PhD student that has just three years

00:32:48,830 --> 00:32:53,840
to finish the PhD to understand the

00:32:51,560 --> 00:32:58,490
kernel dynamics without reading the code

00:32:53,840 --> 00:33:05,330
and that's good because generally the

00:32:58,490 --> 00:33:08,690
guy that does this kind of stuff it's a

00:33:05,330 --> 00:33:13,370
brilliant mathematician and a brilliant

00:33:08,690 --> 00:33:14,930
mathematician like he it's hard to have

00:33:13,370 --> 00:33:16,610
one guy which is a brilliant

00:33:14,930 --> 00:33:18,530
mathematician in a kernel developer at

00:33:16,610 --> 00:33:20,930
the same time because these are two very

00:33:18,530 --> 00:33:25,690
complicated stuff and we are generally

00:33:20,930 --> 00:33:30,830
thinking of personally for 25 years so

00:33:25,690 --> 00:33:33,950
for example DS this paper here was was

00:33:30,830 --> 00:33:36,350
written by a colleague mine and Alessio

00:33:33,950 --> 00:33:39,110
colleague which is Daniel Cassini his

00:33:36,350 --> 00:33:41,120
brilliant mathematician but he would not

00:33:39,110 --> 00:33:41,780
have time to learn the kernel and do

00:33:41,120 --> 00:33:45,710
this stuff

00:33:41,780 --> 00:33:48,860
during his PhD even though he thought he

00:33:45,710 --> 00:33:55,250
I'm sure he can but you not have enough

00:33:48,860 --> 00:33:57,200
time so the first robux that the first

00:33:55,250 --> 00:33:59,510
outputs that we can explain the kernel

00:33:57,200 --> 00:34:01,220
dynamics using more mathematical ways

00:33:59,510 --> 00:34:03,050
for the math mathematicians to

00:34:01,220 --> 00:34:05,540
understand the kernel without on

00:34:03,050 --> 00:34:09,169
without reading the code which is not on

00:34:05,540 --> 00:34:12,409
their domain and we can start developing

00:34:09,169 --> 00:34:14,540
new theoretical system a new we can

00:34:12,409 --> 00:34:18,140
develop a new theoretical model that

00:34:14,540 --> 00:34:21,409
fits on Linux and we can rework already

00:34:18,140 --> 00:34:23,000
developed algorithms to actually fit in

00:34:21,409 --> 00:34:27,169
the restrictions that we have on Linux

00:34:23,000 --> 00:34:30,679
and so we avoid problems in which okay I

00:34:27,169 --> 00:34:33,440
in the scheduler I didn't consider that

00:34:30,679 --> 00:34:35,899
I test can suspend and then I

00:34:33,440 --> 00:34:38,110
implemented the scheduler ignoring this

00:34:35,899 --> 00:34:43,490
and then we end up finding problems as

00:34:38,110 --> 00:34:46,040
we end up finding already so from the

00:34:43,490 --> 00:34:50,360
development side from our side they

00:34:46,040 --> 00:34:54,140
think that matters here what what can we

00:34:50,360 --> 00:34:56,720
do okay the first thing that we can have

00:34:54,140 --> 00:35:02,090
is that ok we have a model that explains

00:34:56,720 --> 00:35:04,580
the kernel as it should work but it can

00:35:02,090 --> 00:35:07,270
be the case that because of a bug the

00:35:04,580 --> 00:35:10,010
curve is not behaving as we model and

00:35:07,270 --> 00:35:13,250
the first during the development of the

00:35:10,010 --> 00:35:15,290
model the problems were generally in the

00:35:13,250 --> 00:35:20,840
model the model was not representing the

00:35:15,290 --> 00:35:23,120
kernel but as I I made progress we end

00:35:20,840 --> 00:35:25,700
up finding cases in which the kernel was

00:35:23,120 --> 00:35:28,550
not being as efficient as it could be

00:35:25,700 --> 00:35:30,100
because the model told that we have

00:35:28,550 --> 00:35:35,930
inefficiency

00:35:30,100 --> 00:35:39,530
for example this this suggestion of

00:35:35,930 --> 00:35:41,660
patch which is part of the ERT ok I

00:35:39,530 --> 00:35:43,490
catch one case while developing the

00:35:41,660 --> 00:35:45,890
model I catch one case in the parameter

00:35:43,490 --> 00:35:49,520
T in which the scheduler was being

00:35:45,890 --> 00:35:52,460
called in vain so we were missing a

00:35:49,520 --> 00:35:55,430
little bit it was like two microseconds

00:35:52,460 --> 00:35:57,860
three microseconds it's very small but

00:35:55,430 --> 00:35:59,900
if we think on the theoretical side it

00:35:57,860 --> 00:36:02,150
could say that the worst case is

00:35:59,900 --> 00:36:04,820
scheduling overhead of Linux was two

00:36:02,150 --> 00:36:08,660
times the scheduling overhead it's not a

00:36:04,820 --> 00:36:11,290
beautiful statement but still we can use

00:36:08,660 --> 00:36:14,450
these to catch bugs on the parameter T

00:36:11,290 --> 00:36:16,820
when we do when we misbehave in the code

00:36:14,450 --> 00:36:19,700
and that's something we

00:36:16,820 --> 00:36:24,730
discussing their micro conference and

00:36:19,700 --> 00:36:27,620
this afternoon but we can also set a new

00:36:24,730 --> 00:36:30,920
and we can also do a new set of metrics

00:36:27,620 --> 00:36:34,040
for the parameter T because when we deal

00:36:30,920 --> 00:36:36,590
with latency we are actually analyzing

00:36:34,040 --> 00:36:39,460
the delays between these events seeing

00:36:36,590 --> 00:36:42,320
the kernel as a black back black box

00:36:39,460 --> 00:36:45,410
we're not observing these events and

00:36:42,320 --> 00:36:49,610
there's a very low probability of

00:36:45,410 --> 00:36:51,620
catching all the worst cases inside a

00:36:49,610 --> 00:36:54,470
execution for example what is the worst

00:36:51,620 --> 00:36:56,060
case ik is scheduling overhead with the

00:36:54,470 --> 00:36:58,970
worst case scheduling overhead takes

00:36:56,060 --> 00:37:01,690
place with the worst case scared scared

00:36:58,970 --> 00:37:05,360
disabled latency it will probably not

00:37:01,690 --> 00:37:07,330
will this happen at the same time in

00:37:05,360 --> 00:37:09,500
which we have the worst case

00:37:07,330 --> 00:37:13,730
interference from interrupts in the

00:37:09,500 --> 00:37:16,370
latency probably not so we have we by

00:37:13,730 --> 00:37:19,100
analyzing piece by piece and assembling

00:37:16,370 --> 00:37:21,230
piece by piece getting the worst case we

00:37:19,100 --> 00:37:24,110
might find that there is the possibility

00:37:21,230 --> 00:37:29,230
of having a higher lattice that we will

00:37:24,110 --> 00:37:32,570
probably hardly catch with with the

00:37:29,230 --> 00:37:35,980
cyclic test for example and the other

00:37:32,570 --> 00:37:39,790
point is that to use theoretical

00:37:35,980 --> 00:37:42,980
worst-case occasion time methods

00:37:39,790 --> 00:37:45,650
probabilistic methods like extreme value

00:37:42,980 --> 00:37:47,270
analysis we have been doing research ok

00:37:45,650 --> 00:37:49,310
extreme value analysis is a way to

00:37:47,270 --> 00:37:52,220
probabilistic define the worst case

00:37:49,310 --> 00:37:56,750
accretion time of a task to be able to

00:37:52,220 --> 00:37:59,000
use it we try to use it on the latency

00:37:56,750 --> 00:38:01,820
and it's not possible because it doesn't

00:37:59,000 --> 00:38:04,730
fit on the needs of the method because

00:38:01,820 --> 00:38:07,060
it's very on very different ways because

00:38:04,730 --> 00:38:09,200
it depends on very different variables

00:38:07,060 --> 00:38:11,390
irq overhead the scheduling overhead

00:38:09,200 --> 00:38:14,350
preemption disable overhead so we could

00:38:11,390 --> 00:38:17,320
not use that method but if we analyze

00:38:14,350 --> 00:38:20,990
metric by metric we end up having more

00:38:17,320 --> 00:38:22,730
consistent variables data and we can

00:38:20,990 --> 00:38:25,280
start using these probabilistic methods

00:38:22,730 --> 00:38:27,350
for example to define worst-case action

00:38:25,280 --> 00:38:29,360
time of tasks or worst case execution

00:38:27,350 --> 00:38:30,380
time of interrupts or worst case

00:38:29,360 --> 00:38:32,570
equation time

00:38:30,380 --> 00:38:35,000
the section that disables preemption and

00:38:32,570 --> 00:38:45,550
then we can analyze the kernel piece by

00:38:35,000 --> 00:38:49,340
piece and uh first here and at the

00:38:45,550 --> 00:38:53,090
real-time micro conference julia lava

00:38:49,340 --> 00:38:56,510
also said that Julia Julia time Julia

00:38:53,090 --> 00:38:59,000
say that we can also use those rules to

00:38:56,510 --> 00:39:01,880
make static code analysis in the kernel

00:38:59,000 --> 00:39:05,920
to catch problems by the code and not by

00:39:01,880 --> 00:39:08,870
the execution of the system so the model

00:39:05,920 --> 00:39:16,070
brings us new opportunities to improve

00:39:08,870 --> 00:39:17,810
the practical side as well and okay we

00:39:16,070 --> 00:39:20,840
will discuss this idea of new metrics

00:39:17,810 --> 00:39:22,970
and how we can use this to catch a

00:39:20,840 --> 00:39:24,530
problem from the parameter T on the

00:39:22,970 --> 00:39:27,230
real-time micro conference that we have

00:39:24,530 --> 00:39:29,420
these after him and I'm sorry I know

00:39:27,230 --> 00:39:34,660
it's boring but someone needs to down

00:39:29,420 --> 00:39:34,660
this work and so questions

00:39:46,530 --> 00:39:53,650
good know that that's good pressure okay

00:39:51,160 --> 00:39:56,890
I'm dealing in terms of the preemption

00:39:53,650 --> 00:39:58,839
model and the prime clarity model is

00:39:56,890 --> 00:40:01,300
there for a decade more than a decade

00:39:58,839 --> 00:40:06,400
now right and these kind of events

00:40:01,300 --> 00:40:08,710
didn't change in this last decade this

00:40:06,400 --> 00:40:10,839
model is still for single core it will

00:40:08,710 --> 00:40:12,900
change a little bit for moot core but

00:40:10,839 --> 00:40:17,079
these restrictions for moot core

00:40:12,900 --> 00:40:18,640
enabling spin locks they are there for a

00:40:17,079 --> 00:40:21,460
long time and they have more or less the

00:40:18,640 --> 00:40:24,099
same behavior in the terms I use here

00:40:21,460 --> 00:40:26,170
like disabling labeling preemption you

00:40:24,099 --> 00:40:28,839
disable preemption before blocking so

00:40:26,170 --> 00:40:31,359
this thing it's on the kernel for more

00:40:28,839 --> 00:40:32,200
than a decade the SME P is there for

00:40:31,359 --> 00:40:37,089
more than a decade

00:40:32,200 --> 00:40:41,260
so this the the level of abstraction I'm

00:40:37,089 --> 00:40:43,750
using is on kernel for more or less a

00:40:41,260 --> 00:40:48,220
decade and will change when we change

00:40:43,750 --> 00:40:50,520
the model when we will change the model

00:40:48,220 --> 00:40:54,569
again

00:40:50,520 --> 00:40:54,569
Quantic computers I don't know

00:40:55,030 --> 00:41:05,290
sorry yeah yeah but these these these

00:41:01,990 --> 00:41:11,859
things this change let's say this change

00:41:05,290 --> 00:41:14,400
take place all every many years that's a

00:41:11,859 --> 00:41:14,400
good question

00:41:20,240 --> 00:41:28,200
so you have

00:41:22,950 --> 00:41:31,710
so you have the bridge to the reticle

00:41:28,200 --> 00:41:34,079
side and I was everything is performed

00:41:31,710 --> 00:41:46,920
by hand I was wondering if from one

00:41:34,079 --> 00:41:49,890
direction you can have some okay okay to

00:41:46,920 --> 00:41:52,520
to have it okay the idea is okay can I

00:41:49,890 --> 00:41:57,180
have in the code generate a model

00:41:52,520 --> 00:42:01,440
automatically it's hard because the code

00:41:57,180 --> 00:42:06,270
always developed forward it doesn't go

00:42:01,440 --> 00:42:09,390
backward so I can is extract a dag from

00:42:06,270 --> 00:42:13,250
the kernel but it's very hard to

00:42:09,390 --> 00:42:16,109
transform a dag back in an automata but

00:42:13,250 --> 00:42:19,920
inside the automata I have all the

00:42:16,109 --> 00:42:24,990
infinite possible legs in a finite state

00:42:19,920 --> 00:42:28,230
space so from the automata I can from

00:42:24,990 --> 00:42:29,190
the model I can have all the DAGs but

00:42:28,230 --> 00:42:31,319
from the Dex

00:42:29,190 --> 00:42:33,930
I cannot have all the model I'm not sure

00:42:31,319 --> 00:42:36,569
if I have other model so the kernel can

00:42:33,930 --> 00:42:40,829
generate a dag of events but I will

00:42:36,569 --> 00:42:46,140
hardly have get back a automata because

00:42:40,829 --> 00:42:48,990
the automata is supersedes the and then

00:42:46,140 --> 00:42:51,089
you have the model and then we go back

00:42:48,990 --> 00:42:53,369
to the situation yeah you need to

00:42:51,089 --> 00:42:56,819
analyze the code and then you will try

00:42:53,369 --> 00:42:59,130
to transform the deck into a automata

00:42:56,819 --> 00:43:01,170
back and that's more or less what I end

00:42:59,130 --> 00:43:03,000
up doing like we analyzed the kernel

00:43:01,170 --> 00:43:05,250
going forward and then we try to make it

00:43:03,000 --> 00:43:08,220
go back to make the model but yeah

00:43:05,250 --> 00:43:11,640
that's it we can have a day out legs out

00:43:08,220 --> 00:43:15,210
infinite tags or the infinity of legs

00:43:11,640 --> 00:43:18,359
inside the automata so I can explain all

00:43:15,210 --> 00:43:20,790
the infinities they our infinity chain

00:43:18,359 --> 00:43:23,040
of event in a finite state space and

00:43:20,790 --> 00:43:25,079
that's a nice mathematical property and

00:43:23,040 --> 00:43:27,410
my math professor will be proud of me

00:43:25,079 --> 00:43:27,410
now

00:43:31,550 --> 00:43:36,270
you hear me

00:43:33,050 --> 00:43:37,950
all right now you can't great okay so I

00:43:36,270 --> 00:43:39,420
understand you you analyze the kernel

00:43:37,950 --> 00:43:42,960
space so what about the driver's face

00:43:39,420 --> 00:43:46,619
like all the yeah good good question so

00:43:42,960 --> 00:43:49,020
I'm analyzing the kernel core things how

00:43:46,619 --> 00:43:53,010
about the drivers those drivers change

00:43:49,020 --> 00:43:54,750
it is this model they are supposed not

00:43:53,010 --> 00:43:58,800
to change and if they change they are

00:43:54,750 --> 00:44:00,839
breaking the parameter T model so in the

00:43:58,800 --> 00:44:03,660
driver we can disable preemption we can

00:44:00,839 --> 00:44:06,300
enable preemption we can disable

00:44:03,660 --> 00:44:09,660
interrupt and enable interrupts so I'm

00:44:06,300 --> 00:44:13,800
using here the vocabulary of things that

00:44:09,660 --> 00:44:15,829
driver developer also use proof that

00:44:13,800 --> 00:44:18,359
this is more or less correct is that

00:44:15,829 --> 00:44:21,210
when we move from the non primitive

00:44:18,359 --> 00:44:22,680
model which is the regular kernel to the

00:44:21,210 --> 00:44:24,150
parameter T model which is the

00:44:22,680 --> 00:44:31,170
pre-emptive kernel we don't need to

00:44:24,150 --> 00:44:33,780
adapt drivers mostly so the frame yeah

00:44:31,170 --> 00:44:36,210
we might need to rework it to have a

00:44:33,780 --> 00:44:40,640
shorter preemption but still we are

00:44:36,210 --> 00:44:43,800
still using the same vocabulary so I

00:44:40,640 --> 00:44:49,109
mean I'm including the things that that

00:44:43,800 --> 00:44:51,329
driver needs and yeah and the driver

00:44:49,109 --> 00:44:52,920
needs to follow the the kernel and it

00:44:51,329 --> 00:44:55,430
already follows because that's how brain

00:44:52,920 --> 00:44:55,430
30 works

00:45:14,900 --> 00:45:26,100
the box no hold the box into microphone

00:45:19,350 --> 00:45:33,660
it's a microphone we're doing this tiny

00:45:26,100 --> 00:45:41,030
analysis or something in between and it

00:45:33,660 --> 00:45:41,030
is very hard to bound good session okay

00:45:41,060 --> 00:45:46,320
okay

00:45:42,710 --> 00:45:48,450
so when we have debts that also applies

00:45:46,320 --> 00:45:51,810
for the execution time of tasks like

00:45:48,450 --> 00:45:55,290
okay I have the blocking of a task in a

00:45:51,810 --> 00:45:57,540
mutex it's very hard to define how long

00:45:55,290 --> 00:46:01,610
will the task be blocking on that mutex

00:45:57,540 --> 00:46:05,340
right that's the idea okay I am NOT here

00:46:01,610 --> 00:46:08,550
expressing the timing behavior of the

00:46:05,340 --> 00:46:10,950
state I'm not saying I'm not trying to

00:46:08,550 --> 00:46:14,400
simulate the system and say that I can

00:46:10,950 --> 00:46:20,100
block this for this long and I'm not

00:46:14,400 --> 00:46:22,850
trying to define the time in here what

00:46:20,100 --> 00:46:25,590
I'm trying to say are how one event

00:46:22,850 --> 00:46:28,580
influences on the task timeline I can

00:46:25,590 --> 00:46:31,200
have a task trying to catch the

00:46:28,580 --> 00:46:34,200
real-time mutex inside the real time

00:46:31,200 --> 00:46:36,470
mutex I will have if it's not if it's

00:46:34,200 --> 00:46:40,140
already taken I will have to take the

00:46:36,470 --> 00:46:44,070
the spin lock that we have inside it and

00:46:40,140 --> 00:46:47,160
then after editing me in the wait in the

00:46:44,070 --> 00:46:50,100
queue of tasks waiting I will run the

00:46:47,160 --> 00:46:52,560
code for the priority inheritance I will

00:46:50,100 --> 00:46:54,240
call the scheduler and now we'll go out

00:46:52,560 --> 00:46:56,430
for example I'm only in this state but

00:46:54,240 --> 00:47:02,070
I'm not trying to say how long will you

00:46:56,430 --> 00:47:05,430
state on this so my model doesn't

00:47:02,070 --> 00:47:08,310
doesn't actually work to simulate the

00:47:05,430 --> 00:47:11,190
system in to define but it defines all

00:47:08,310 --> 00:47:13,800
the states and we can observe these and

00:47:11,190 --> 00:47:15,900
then use other analysis to make the

00:47:13,800 --> 00:47:17,539
DNR's of the bakken time this will

00:47:15,900 --> 00:47:21,269
clarify

00:47:17,539 --> 00:47:24,539
yeah but I'm not but I'm not telling how

00:47:21,269 --> 00:47:26,190
bounded it is however I'm sorry we

00:47:24,539 --> 00:47:29,809
should probably stop at this point and

00:47:26,190 --> 00:47:36,769
let Yuri have a good question maybe

00:47:29,809 --> 00:47:36,769
yeah but yeah that's okay

00:47:37,080 --> 00:47:40,730

YouTube URL: https://www.youtube.com/watch?v=ke77kEav-Ug


