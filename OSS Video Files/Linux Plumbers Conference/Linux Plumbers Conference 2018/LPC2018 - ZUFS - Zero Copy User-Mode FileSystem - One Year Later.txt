Title: LPC2018 - ZUFS - Zero Copy User-Mode FileSystem - One Year Later
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/261/
speaker:  Boaz Harrosh


One year after its inception there are real hardened FSs. 
Many innovative fixtures. But is it ready for upstream?

Few highlights:

ALL VFS api working including dax, mmap IOCTL xattrs ACLs ....
(Missing quota)
IO API changed (From last year)
Support for ASYNC operations
Support for both pmem and regular block devices
Support for private memory pools
ZTs multy-channel and dynamic channel allocation
And many more ...
In the talk I will give a short architectural and functional overview. Then will go over some of the leftover challenges.

And finally hope to engage in an open discussion of how this project should move forward to be accepted into the Kernel, gain more users and FS implementations.
Captions: 
	00:00:05,710 --> 00:00:11,870
okay I'm gonna start I understand that

00:00:08,780 --> 00:00:16,849
this was completely out of schedule so

00:00:11,870 --> 00:00:19,630
there is not many people so I guess half

00:00:16,849 --> 00:00:23,029
of the people already saw the previous

00:00:19,630 --> 00:00:29,029
presentations so I'm not gonna try and

00:00:23,029 --> 00:00:35,630
repeat myself a lot so there is this

00:00:29,029 --> 00:00:41,240
project oops there's this project pushed

00:00:35,630 --> 00:00:46,100
by a net up I work for net up that they

00:00:41,240 --> 00:00:48,140
want a file system in user mode so a

00:00:46,100 --> 00:00:54,230
user mode server that gives you a file

00:00:48,140 --> 00:00:56,570
system because the language is that it

00:00:54,230 --> 00:00:59,930
is written in and the libraries that

00:00:56,570 --> 00:01:02,900
it's using and the licensing and all

00:00:59,930 --> 00:01:06,380
those stuff are do not permit it to

00:01:02,900 --> 00:01:11,260
running inside the kernel it's a very

00:01:06,380 --> 00:01:14,510
big file system but on the other hand

00:01:11,260 --> 00:01:18,290
they don't we don't want to it's a

00:01:14,510 --> 00:01:21,140
persistent memory based and so we don't

00:01:18,290 --> 00:01:24,020
want to pay the penalty of of the user

00:01:21,140 --> 00:01:28,700
mode the user mode interfaces that we

00:01:24,020 --> 00:01:36,350
currently know specifically fuse and any

00:01:28,700 --> 00:01:40,640
other IPC are too slow and to copy happy

00:01:36,350 --> 00:01:43,390
so therefore zero copy user mode

00:01:40,640 --> 00:01:43,390
filesystem

00:01:46,899 --> 00:01:54,250
so the the good news the good news and

00:01:50,590 --> 00:01:57,549
the bad news so the good news that it

00:01:54,250 --> 00:02:02,740
actually works it's it's been released

00:01:57,549 --> 00:02:09,429
to clients as a - better clients last

00:02:02,740 --> 00:02:14,650
week and it actually survives they're

00:02:09,429 --> 00:02:21,099
all suit of XFS tests and they're all

00:02:14,650 --> 00:02:24,340
suit of NFS torture met up torture tests

00:02:21,099 --> 00:02:30,450
that they have developed for the last 20

00:02:24,340 --> 00:02:34,720
years and it's a pretty steady pretty

00:02:30,450 --> 00:02:38,470
hard system by now

00:02:34,720 --> 00:02:44,079
there is not a lot of missing features

00:02:38,470 --> 00:02:48,610
and including corporate features like

00:02:44,079 --> 00:02:52,150
snapshots and and mirroring on another

00:02:48,610 --> 00:02:55,510
now and all kind of global namespace

00:02:52,150 --> 00:02:58,510
it's a bit one big product and it's all

00:02:55,510 --> 00:03:04,209
run under this project that I'm

00:02:58,510 --> 00:03:07,480
presenting here so we are negotiating

00:03:04,209 --> 00:03:11,200
with with red hats to actually include

00:03:07,480 --> 00:03:19,359
the the models the open source modules

00:03:11,200 --> 00:03:21,579
with Red Hat and all the source code and

00:03:19,359 --> 00:03:23,709
all the stuff that I'm gonna present is

00:03:21,579 --> 00:03:26,769
all open source you can go download it

00:03:23,709 --> 00:03:33,639
hack it whatever you want the bad news

00:03:26,769 --> 00:03:38,430
is that we want it upstream and compared

00:03:33,639 --> 00:03:38,430
to any all that any of the talks that I

00:03:38,730 --> 00:03:47,680
saw in here in plumber's this is a very

00:03:44,889 --> 00:03:51,849
big it's a much much bigger piece of

00:03:47,680 --> 00:03:54,969
code it's it's a complex code there is a

00:03:51,849 --> 00:03:59,379
lot of systems there's a lot of you know

00:03:54,969 --> 00:04:00,640
like internals that are being done and

00:03:59,379 --> 00:04:04,600
tricks

00:04:00,640 --> 00:04:07,930
so to actually get it ready for upstream

00:04:04,600 --> 00:04:13,030
and have everyone approve and not step

00:04:07,930 --> 00:04:15,160
on anybody's toes and I hope when we

00:04:13,030 --> 00:04:19,420
step on their toes today they yell so I

00:04:15,160 --> 00:04:26,200
know and so this is the bad news you

00:04:19,420 --> 00:04:29,800
know how you know how we check the

00:04:26,200 --> 00:04:38,040
diversions match between the components

00:04:29,800 --> 00:04:41,230
how we package the dependencies so so

00:04:38,040 --> 00:04:45,190
I'm gonna go I've try to go very quickly

00:04:41,230 --> 00:04:47,350
on the architecture and but if you want

00:04:45,190 --> 00:04:51,150
more than tell me if you have any

00:04:47,350 --> 00:04:54,910
question just raise your hand and ask

00:04:51,150 --> 00:04:58,720
don't let it run away in the principle

00:04:54,910 --> 00:05:03,700
we see a kernel so the zoo FS is built

00:04:58,720 --> 00:05:07,300
from a zoo component which is a zero

00:05:03,700 --> 00:05:10,479
copy user mode feeder this is the kernel

00:05:07,300 --> 00:05:14,680
component and then and then in the in

00:05:10,479 --> 00:05:20,740
user node it it has a sous zero copy

00:05:14,680 --> 00:05:25,260
user mode server component and this Zeus

00:05:20,740 --> 00:05:30,550
server is is presented under a system D

00:05:25,260 --> 00:05:35,050
Zeus T so it's a system T load on boot

00:05:30,550 --> 00:05:38,520
up service and so all these are open

00:05:35,050 --> 00:05:42,910
source that the squares at the bottom

00:05:38,520 --> 00:05:48,070
these are vendor components that plug in

00:05:42,910 --> 00:05:50,680
and these these components are loadable

00:05:48,070 --> 00:05:54,550
libraries and there is a register a very

00:05:50,680 --> 00:05:58,150
simple registry where you say what which

00:05:54,550 --> 00:06:02,140
file system types joy support now each

00:05:58,150 --> 00:06:07,180
plug-in can actually export as many file

00:06:02,140 --> 00:06:10,110
types that he wants so - T food - D bar

00:06:07,180 --> 00:06:10,110
- t

00:06:10,270 --> 00:06:18,309
you know any files filesystem types and

00:06:14,669 --> 00:06:20,649
so and this so this immediately

00:06:18,309 --> 00:06:23,169
everything that the way it is built it

00:06:20,649 --> 00:06:26,529
everything is mirrored so any object

00:06:23,169 --> 00:06:32,289
that you have in the kernel is you have

00:06:26,529 --> 00:06:34,089
actually an object in user space so so

00:06:32,289 --> 00:06:37,240
the first thing that happens is that the

00:06:34,089 --> 00:06:39,999
the zoo fruit loads zoo fruit is is a

00:06:37,240 --> 00:06:43,869
very meaningful minimum file system that

00:06:39,999 --> 00:06:46,899
you can open files against and and do

00:06:43,869 --> 00:06:49,599
special i/o controls so it's just and

00:06:46,899 --> 00:06:51,249
the file system there is not a real fan

00:06:49,599 --> 00:06:54,789
system it doesn't serve any files it's

00:06:51,249 --> 00:06:58,259
just an interface to to the core of the

00:06:54,789 --> 00:07:04,990
server of the core of the files of the

00:06:58,259 --> 00:07:08,589
operation the the the demon now all this

00:07:04,990 --> 00:07:11,259
system can repeat so it for efficiency

00:07:08,589 --> 00:07:13,269
we want one of these in the system but

00:07:11,259 --> 00:07:16,869
let's say I have a plug-in that is not

00:07:13,269 --> 00:07:21,550
ready it's not hardened I don't want

00:07:16,869 --> 00:07:25,269
safe bugs to to interfere with with you

00:07:21,550 --> 00:07:28,740
know with with the solid XFS files not

00:07:25,269 --> 00:07:32,319
an exercise in kernel but some other

00:07:28,740 --> 00:07:35,289
hard and fast system then I can and they

00:07:32,319 --> 00:07:38,259
and they all run in the same address

00:07:35,289 --> 00:07:40,839
space so I can actually duplicate the

00:07:38,259 --> 00:07:44,949
demons all I have to do is give the

00:07:40,839 --> 00:07:49,209
demon on the command line where is my

00:07:44,949 --> 00:07:56,019
root so the default route loads on /li

00:07:49,209 --> 00:07:58,749
/fs /zu but then you if you mount a root

00:07:56,019 --> 00:08:01,749
on another map on another path and just

00:07:58,749 --> 00:08:04,869
give that demon on another path you have

00:08:01,749 --> 00:08:07,229
the old system duplicated so you it's

00:08:04,869 --> 00:08:12,269
it's it's it's less good for performance

00:08:07,229 --> 00:08:12,269
but it's better for isolation

00:08:12,310 --> 00:08:20,080
and so so once you he wants you

00:08:16,420 --> 00:08:21,730
establish a communication there is a the

00:08:20,080 --> 00:08:25,150
first thing that happens is just there

00:08:21,730 --> 00:08:27,160
is a mount thread that went that goes

00:08:25,150 --> 00:08:30,639
into the kernel sleeps into the kernel

00:08:27,160 --> 00:08:35,080
and waits for a mount commander the

00:08:30,639 --> 00:08:37,060
regular mount command comes in and the

00:08:35,080 --> 00:08:40,990
mount thread goes into the filesystem

00:08:37,060 --> 00:08:44,920
type into the plug-in that registered

00:08:40,990 --> 00:08:48,130
that filesystem and tells it okay let's

00:08:44,920 --> 00:08:51,640
mount and so now the superblock is

00:08:48,130 --> 00:08:59,140
created these parts we'll see how you

00:08:51,640 --> 00:09:02,680
access your data and every super block

00:08:59,140 --> 00:09:05,860
is belongs to a root so if a super block

00:09:02,680 --> 00:09:08,730
wants to talk to its component in user

00:09:05,860 --> 00:09:12,010
mode it goes through the route it got it

00:09:08,730 --> 00:09:16,210
it takes a communication channel and and

00:09:12,010 --> 00:09:18,190
then it's dispatched in user in in

00:09:16,210 --> 00:09:22,750
application land its dispatched to the

00:09:18,190 --> 00:09:25,540
correct vector of operation now the

00:09:22,750 --> 00:09:30,210
novelty of the whole project is these

00:09:25,540 --> 00:09:35,770
City threads this zu threads cities

00:09:30,210 --> 00:09:40,810
cities and so the the what happens is

00:09:35,770 --> 00:09:44,640
that when a file system call let's zoom

00:09:40,810 --> 00:09:44,640
in zoom in on this

00:09:52,720 --> 00:09:59,890
at the use case so I thought I'd say I

00:09:57,310 --> 00:10:02,650
thought I'd touch that but so the use

00:09:59,890 --> 00:10:06,460
case is that we have a very big fan

00:10:02,650 --> 00:10:11,290
system that cannot run in the kernel but

00:10:06,460 --> 00:10:15,670
we still want to interface it in the in

00:10:11,290 --> 00:10:18,130
the complete POSIX regular way and it's

00:10:15,670 --> 00:10:22,720
actually like fuse it's a same use case

00:10:18,130 --> 00:10:28,780
as fuse but but without paying the

00:10:22,720 --> 00:10:31,480
penalty of copying and and in latency

00:10:28,780 --> 00:10:33,400
and the bad communicate bad user mode

00:10:31,480 --> 00:10:38,350
kernel communication channels that

00:10:33,400 --> 00:10:41,710
exists today so for instance the fuse

00:10:38,350 --> 00:10:43,900
uses pipes which are an order of a

00:10:41,710 --> 00:10:45,960
magnitude slower than the the

00:10:43,900 --> 00:10:49,660
communication path that we've created

00:10:45,960 --> 00:10:52,630
okay so the the the use case is just

00:10:49,660 --> 00:10:57,820
speed speed speed speed performance and

00:10:52,630 --> 00:11:03,130
also so I wouldn't care about Speidel a

00:10:57,820 --> 00:11:05,800
lot if all these user mode interfaces

00:11:03,130 --> 00:11:08,860
would scale but what happens today is

00:11:05,800 --> 00:11:14,170
that they just don't scale if I have 80

00:11:08,860 --> 00:11:18,400
cores 128 cores v 512 cores you see that

00:11:14,170 --> 00:11:21,520
after four or five threads you don't get

00:11:18,400 --> 00:11:23,650
more performance with this system you

00:11:21,520 --> 00:11:26,830
completely scale up to the number of

00:11:23,650 --> 00:11:32,620
CPUs you have on this in the system okay

00:11:26,830 --> 00:11:37,060
so here you see that the kernels oof is

00:11:32,620 --> 00:11:40,720
a model is a VFS model and the Zeus has

00:11:37,060 --> 00:11:43,150
its its libraries its loadable libraries

00:11:40,720 --> 00:11:45,510
that are actually implementing the file

00:11:43,150 --> 00:11:45,510
system

00:11:47,899 --> 00:11:54,120
so they're so the novelty here is the

00:11:51,810 --> 00:11:57,240
pair CPU communication and the person

00:11:54,120 --> 00:12:00,410
pew communication enables us to do to be

00:11:57,240 --> 00:12:05,699
completely completely lock less

00:12:00,410 --> 00:12:08,759
completely mere memory barrier less the

00:12:05,699 --> 00:12:16,220
there is one memory barrier that is done

00:12:08,759 --> 00:12:18,689
in the scheduler but that's pretty

00:12:16,220 --> 00:12:23,040
that's pretty good that's pretty good

00:12:18,689 --> 00:12:28,559
that's not that bad it's it's a very

00:12:23,040 --> 00:12:32,569
narrow memory barrier and so the way it

00:12:28,559 --> 00:12:39,180
works is that the when they when the

00:12:32,569 --> 00:12:45,509
demon is created it creates a a number n

00:12:39,180 --> 00:12:51,480
number of channels per CPU so currently

00:12:45,509 --> 00:12:55,579
it's three and those if an application

00:12:51,480 --> 00:12:59,250
comes on some CPU go through the VFS

00:12:55,579 --> 00:13:05,699
core and arrives at the file system at

00:12:59,250 --> 00:13:08,879
some CPU in the kernel it will pick up

00:13:05,699 --> 00:13:15,750
the channel the available channel of

00:13:08,879 --> 00:13:22,519
that CPU and dispatch that on that CPU

00:13:15,750 --> 00:13:26,189
on on this thread it allocated into the

00:13:22,519 --> 00:13:30,620
into the into the user mode server so in

00:13:26,189 --> 00:13:35,459
so because it's a pair CPUs the actual

00:13:30,620 --> 00:13:40,559
ZT array the thread the the ZT array in

00:13:35,459 --> 00:13:42,540
zou is actually a per CPU variable it's

00:13:40,559 --> 00:13:44,459
it's very simple coding I mean the

00:13:42,540 --> 00:13:47,670
kernel gives us all these facilities and

00:13:44,459 --> 00:13:50,300
so when you access you do a get CPU and

00:13:47,670 --> 00:13:53,999
you access your purse if you variable

00:13:50,300 --> 00:13:56,519
there is no locks there is no you do is

00:13:53,999 --> 00:13:58,510
simple if you know there is no

00:13:56,519 --> 00:14:00,790
synchronization

00:13:58,510 --> 00:14:05,140
nothing in all the locality the CPU

00:14:00,790 --> 00:14:07,510
locality are there you go into the

00:14:05,140 --> 00:14:11,080
server you you dispatch the vector that

00:14:07,510 --> 00:14:13,750
you wanted and you return with the

00:14:11,080 --> 00:14:14,890
results you wake up the application and

00:14:13,750 --> 00:14:18,130
you return the results to the

00:14:14,890 --> 00:14:23,890
application all this is done on the same

00:14:18,130 --> 00:14:31,120
CPU and so in in in in parallel you can

00:14:23,890 --> 00:14:37,440
do all CPUs in together now why three

00:14:31,120 --> 00:14:40,180
channels so if we only had one channel

00:14:37,440 --> 00:14:43,840
then the rule would be and that was the

00:14:40,180 --> 00:14:48,070
original thought the rule would be that

00:14:43,840 --> 00:14:50,560
you cannot sleep on a ZT because if you

00:14:48,070 --> 00:14:54,580
sleep that channel is taken and you and

00:14:50,560 --> 00:15:00,150
it's there is no you're losing you're

00:14:54,580 --> 00:15:02,740
blocking that CPU for for your use and

00:15:00,150 --> 00:15:05,620
so you're not allowed to sleep but not

00:15:02,740 --> 00:15:06,430
sleeping is hard we don't know how to

00:15:05,620 --> 00:15:10,180
non sleep

00:15:06,430 --> 00:15:11,860
there is not such coding paradigm of how

00:15:10,180 --> 00:15:14,170
do you not sleep you know it's very

00:15:11,860 --> 00:15:17,130
simple spin lock is asleep you know or

00:15:14,170 --> 00:15:19,960
in allocating memory and everything so

00:15:17,130 --> 00:15:23,470
what we have is we have multiple

00:15:19,960 --> 00:15:26,110
channels so and also there currently

00:15:23,470 --> 00:15:28,000
there there is a mechanism but but I

00:15:26,110 --> 00:15:30,430
have disabled it for now because it's

00:15:28,000 --> 00:15:32,790
just I found that it doesn't I don't

00:15:30,430 --> 00:15:36,160
need it it doesn't give me any benefits

00:15:32,790 --> 00:15:38,950
that I can actually add more channels if

00:15:36,160 --> 00:15:43,600
the system if there is 10,000 threads

00:15:38,950 --> 00:15:46,030
but bombarding my file system then I can

00:15:43,600 --> 00:15:49,150
add more channels and and I and my

00:15:46,030 --> 00:15:51,460
fascism is actually sleeping then I can

00:15:49,150 --> 00:15:54,550
actually add more channels but that

00:15:51,460 --> 00:15:56,440
didn't give me in the benchmarks in the

00:15:54,550 --> 00:15:58,930
synthetic bed works that I've done it

00:15:56,440 --> 00:16:01,960
didn't give me any results so the three

00:15:58,930 --> 00:16:04,720
was a good compromise where I'm not

00:16:01,960 --> 00:16:08,910
stuck without threads because we imagine

00:16:04,720 --> 00:16:08,910
that the imagine that there is

00:16:09,050 --> 00:16:13,910
one thousand three there is just like

00:16:11,209 --> 00:16:16,970
that in in XFS test there are 1000

00:16:13,910 --> 00:16:21,620
threads read the same block and the and

00:16:16,970 --> 00:16:24,080
now the block is waiting for to be read

00:16:21,620 --> 00:16:28,899
from hard disk so it's sleeping waiting

00:16:24,080 --> 00:16:33,770
for the hardest then there can be a

00:16:28,899 --> 00:16:38,750
problem where when the the i/o done path

00:16:33,770 --> 00:16:41,060
doesn't find an available ZT because all

00:16:38,750 --> 00:16:44,709
the Zetas are inside the server waiting

00:16:41,060 --> 00:16:52,730
on the lock of the block to be returned

00:16:44,709 --> 00:16:57,110
so so so what I did what we did in this

00:16:52,730 --> 00:17:00,260
case is that if if an i/o operation

00:16:57,110 --> 00:17:02,300
starts and it needs to communicate with

00:17:00,260 --> 00:17:05,770
the with the kernel to actually do

00:17:02,300 --> 00:17:10,069
things like read from hard disk then

00:17:05,770 --> 00:17:13,160
that channel is only of is locked for

00:17:10,069 --> 00:17:14,540
the completion of the i/o so there is o

00:17:13,160 --> 00:17:17,800
you're guaranteed you're always

00:17:14,540 --> 00:17:20,030
guaranteed to have a forward progress of

00:17:17,800 --> 00:17:24,290
once you started the i/o you have a

00:17:20,030 --> 00:17:27,530
forward progress of your i/o and this is

00:17:24,290 --> 00:17:29,420
this is kind of advanced stuff but the

00:17:27,530 --> 00:17:36,620
main thing here is that it's completely

00:17:29,420 --> 00:17:38,900
lock less completely memory barrier less

00:17:36,620 --> 00:17:42,100
and that there is multiple channels

00:17:38,900 --> 00:17:45,020
exactly for the for the reason that I

00:17:42,100 --> 00:17:47,720
want to reserve once I start an

00:17:45,020 --> 00:17:51,250
operation I want to reserve that channel

00:17:47,720 --> 00:17:51,250
for the completion of the

00:17:58,050 --> 00:18:01,570
okay now another thing that is

00:18:01,090 --> 00:18:03,910
interesting

00:18:01,570 --> 00:18:05,730
there's it's a big project it's a really

00:18:03,910 --> 00:18:09,970
proud project there's a lot of

00:18:05,730 --> 00:18:13,630
components in this project that are by

00:18:09,970 --> 00:18:16,090
themselves a project in the kernel for

00:18:13,630 --> 00:18:22,120
what for example one thing is a device

00:18:16,090 --> 00:18:26,980
table so on the mount command you you

00:18:22,120 --> 00:18:35,980
say these files this file system type -

00:18:26,980 --> 00:18:41,500
T foo FS of this device on this

00:18:35,980 --> 00:18:44,560
directory what we actually do is as part

00:18:41,500 --> 00:18:49,720
of the registration as part of the user

00:18:44,560 --> 00:18:53,830
mode filesystem type information we

00:18:49,720 --> 00:18:57,640
which we tell the colonel we're on the

00:18:53,830 --> 00:19:01,170
disk if you get a disk on at what offset

00:18:57,640 --> 00:19:08,590
of the disk you will find a device table

00:19:01,170 --> 00:19:11,110
and in the device table it's the device

00:19:08,590 --> 00:19:14,110
that was just a table as flat table but

00:19:11,110 --> 00:19:18,100
that lists all the devices that belong

00:19:14,110 --> 00:19:21,250
to this file system and we see two types

00:19:18,100 --> 00:19:24,820
of devices we see t1 devices with

00:19:21,250 --> 00:19:28,090
meaning persistent memory devices or

00:19:24,820 --> 00:19:32,770
direct access devices which which I know

00:19:28,090 --> 00:19:35,620
that our memory in the code and then I

00:19:32,770 --> 00:19:42,160
have regular other regular block devices

00:19:35,620 --> 00:19:45,070
so nvme I scuzzy whatever other t2

00:19:42,160 --> 00:19:50,020
devices that are they do not have direct

00:19:45,070 --> 00:19:52,720
access and each device is also Numa

00:19:50,020 --> 00:19:54,520
aware is especially in memory in pmm I

00:19:52,720 --> 00:19:58,480
want to give the the filesystem and

00:19:54,520 --> 00:20:01,870
information on which Numa I'm working

00:19:58,480 --> 00:20:04,780
and what is the closest to you also t2

00:20:01,870 --> 00:20:05,710
devices in imagine ice Kazi which are

00:20:04,780 --> 00:20:09,190
over a NIC

00:20:05,710 --> 00:20:09,610
so I actually if I come if I configure

00:20:09,190 --> 00:20:16,210
my C

00:20:09,610 --> 00:20:19,120
correctly I I empty I empty my memory to

00:20:16,210 --> 00:20:26,650
the nearest device instead of going

00:20:19,120 --> 00:20:28,870
cross Numa also on TV and so also the

00:20:26,650 --> 00:20:31,210
kernel completely owns all the devices

00:20:28,870 --> 00:20:33,040
so so when you do an LS block you and

00:20:31,210 --> 00:20:35,200
you do a mount of a fascism and you do

00:20:33,040 --> 00:20:37,450
an LS block the HELOCs block will show

00:20:35,200 --> 00:20:39,309
you okayed all these devices like it's

00:20:37,450 --> 00:20:43,179
like in butter of s all these devices

00:20:39,309 --> 00:20:47,169
belong to this mount so this is a very

00:20:43,179 --> 00:20:49,600
nice feature in users user mode that

00:20:47,169 --> 00:20:52,120
mean that it can actually see and and

00:20:49,600 --> 00:20:53,679
also another big thing with with this

00:20:52,120 --> 00:20:57,580
device table is that it doesn't matter

00:20:53,679 --> 00:21:00,040
which device you can give any premium

00:20:57,580 --> 00:21:02,440
device that you have is there is up to

00:21:00,040 --> 00:21:06,010
64 devices that you can put in a system

00:21:02,440 --> 00:21:09,630
you know you know in one super block any

00:21:06,010 --> 00:21:13,480
device that you give it will always

00:21:09,630 --> 00:21:16,480
mount the same way and if that device if

00:21:13,480 --> 00:21:21,790
that super block is already mounted and

00:21:16,480 --> 00:21:24,370
it already has a directory then it will

00:21:21,790 --> 00:21:26,830
automatically bind mount this is this

00:21:24,370 --> 00:21:31,059
the background is is done automatically

00:21:26,830 --> 00:21:32,950
in Linux if you mount on directory one

00:21:31,059 --> 00:21:35,770
and then use the same device you mount

00:21:32,950 --> 00:21:37,390
on directory to it will just increment

00:21:35,770 --> 00:21:40,120
the reference of a super block into a

00:21:37,390 --> 00:21:42,549
bad mount so all this work so I thought

00:21:40,120 --> 00:21:45,220
you can give any one of the devices of

00:21:42,549 --> 00:21:47,230
the sixty-four devices to the mount it

00:21:45,220 --> 00:21:52,169
will automatically bind mount because it

00:21:47,230 --> 00:21:56,919
sees that it's already mounted another

00:21:52,169 --> 00:22:00,700
another job of the of the so this is a

00:21:56,919 --> 00:22:04,120
device table on disk but there there is

00:22:00,700 --> 00:22:08,940
a whole object in kernel that is called

00:22:04,120 --> 00:22:14,140
the empty the multi device which

00:22:08,940 --> 00:22:16,990
presents to the server a linear it gives

00:22:14,140 --> 00:22:18,220
all the it all the payment that are

00:22:16,990 --> 00:22:23,230
listed it gives

00:22:18,220 --> 00:22:27,580
as a linear as a linear contact

00:22:23,230 --> 00:22:31,120
concatenated linear space and it in with

00:22:27,580 --> 00:22:36,190
with a single and map the server can

00:22:31,120 --> 00:22:41,640
access the all PMON in one in through a

00:22:36,190 --> 00:22:44,470
single pointer and also with t2 is the

00:22:41,640 --> 00:22:47,860
communication the communication with the

00:22:44,470 --> 00:22:49,870
kernel when I want to write a regular

00:22:47,860 --> 00:22:52,390
block devices is I just give you an

00:22:49,870 --> 00:22:56,409
offset I am this in this super block

00:22:52,390 --> 00:22:59,799
rights to this offset and so t2 means

00:22:56,409 --> 00:23:02,289
just an offset offset in the device

00:22:59,799 --> 00:23:04,570
table so you know and the devices don't

00:23:02,289 --> 00:23:11,620
need to be in the same size it's just

00:23:04,570 --> 00:23:14,710
the concatenation of space and so this

00:23:11,620 --> 00:23:19,150
gives you a lot of hardening and and I

00:23:14,710 --> 00:23:21,549
can also check you give me a t1 address

00:23:19,150 --> 00:23:23,590
is also actually a t1 address is also an

00:23:21,549 --> 00:23:25,030
offset t2 address is also an after so I

00:23:23,590 --> 00:23:27,220
can check you that you're not going out

00:23:25,030 --> 00:23:29,950
of bounds as a server as a user mode

00:23:27,220 --> 00:23:32,559
server I don't trust you completely so

00:23:29,950 --> 00:23:35,080
everything is checked this is why this

00:23:32,559 --> 00:23:37,539
the colonel knows all this information

00:23:35,080 --> 00:23:42,100
owns this information and it gives

00:23:37,539 --> 00:23:46,919
access for it to the server for it also

00:23:42,100 --> 00:23:49,450
there is a I check that you cannot a

00:23:46,919 --> 00:23:51,789
certain super block cannot access

00:23:49,450 --> 00:23:58,690
devices that doesn't belong to its

00:23:51,789 --> 00:24:02,710
device table so everything is is tried

00:23:58,690 --> 00:24:07,960
to be hardened in this way another thing

00:24:02,710 --> 00:24:12,400
another thing that is a very special

00:24:07,960 --> 00:24:14,289
here is the zero copy inode so I have

00:24:12,400 --> 00:24:19,659
all this I note info you know the inode

00:24:14,289 --> 00:24:24,130
number the size the times the GID UID

00:24:19,659 --> 00:24:26,380
all these information they don't run on

00:24:24,130 --> 00:24:28,419
the line they don't on the communication

00:24:26,380 --> 00:24:31,370
at the beginning of the create of the

00:24:28,419 --> 00:24:37,450
load of the inode from disk

00:24:31,370 --> 00:24:45,919
I look up I get or on creation new inode

00:24:37,450 --> 00:24:48,590
I get a poet pointer directly to the to

00:24:45,919 --> 00:24:51,559
the Zeus inode and the and the though

00:24:48,590 --> 00:24:55,700
and the protocol is that you could see

00:24:51,559 --> 00:24:57,980
the rule of operation is that inside the

00:24:55,700 --> 00:25:02,210
kernel I already know what it means to

00:24:57,980 --> 00:25:10,039
be a filesystem so I update I update all

00:25:02,210 --> 00:25:13,519
the fields I update all the fields here

00:25:10,039 --> 00:25:15,830
and then I dispatch the operation so

00:25:13,519 --> 00:25:19,909
let's for let's for instance I do a

00:25:15,830 --> 00:25:22,369
write I need to update the see time and

00:25:19,909 --> 00:25:26,299
time I added the see time M time

00:25:22,369 --> 00:25:29,049
directly in in persistent memory base by

00:25:26,299 --> 00:25:32,659
systems I'm actually directly accessing

00:25:29,049 --> 00:25:34,789
persistent memory and then i dispatched

00:25:32,659 --> 00:25:37,429
to the to the user mode and the user

00:25:34,789 --> 00:25:39,769
mode can do a steal flush if it's if it

00:25:37,429 --> 00:25:41,570
knows that it's it's actually persistent

00:25:39,769 --> 00:25:44,720
memory it needs to do a seal flush

00:25:41,570 --> 00:25:49,820
please update these cache lines to to

00:25:44,720 --> 00:25:53,330
real nvidia ephemeral if it's just an

00:25:49,820 --> 00:25:57,379
object let's say I mean XFS file system

00:25:53,330 --> 00:26:00,860
that already has an on disk format of

00:25:57,379 --> 00:26:03,769
his own then we were just coming it's

00:26:00,860 --> 00:26:06,399
it's a it's a shared memory object so

00:26:03,769 --> 00:26:10,340
this the shared memory object is

00:26:06,399 --> 00:26:14,929
lifetime is exactly as the lifetime of

00:26:10,340 --> 00:26:19,129
the VFS inode and once we created that

00:26:14,929 --> 00:26:21,950
handshake then we never copy this data

00:26:19,129 --> 00:26:27,730
back and forth we completely work on

00:26:21,950 --> 00:26:32,240
directly on the under on the object this

00:26:27,730 --> 00:26:37,750
and also another thing that was there is

00:26:32,240 --> 00:26:40,360
a and each each user mode object

00:26:37,750 --> 00:26:42,970
gives its pointer it's user mode pointer

00:26:40,360 --> 00:26:47,110
to the colonel now for the colonel is

00:26:42,970 --> 00:26:50,770
just an opaque handle it's su a struct

00:26:47,110 --> 00:26:53,620
Zeus inode undefined let's start design

00:26:50,770 --> 00:26:55,120
on pointer on defined so it's for the

00:26:53,620 --> 00:26:58,120
kernel is just a pointer it cannot it

00:26:55,120 --> 00:27:00,940
doesn't know what's in those fields but

00:26:58,120 --> 00:27:03,490
every operation that I call into the

00:27:00,940 --> 00:27:08,020
server that operates on inode I give it

00:27:03,490 --> 00:27:09,790
the Zeus inode info and here this is

00:27:08,020 --> 00:27:12,580
your you remember you gave it to me when

00:27:09,790 --> 00:27:15,580
we created the inode remember you gave

00:27:12,580 --> 00:27:19,900
me the handle this is your handle so you

00:27:15,580 --> 00:27:23,040
completely avoid any kind of inode hash

00:27:19,900 --> 00:27:28,320
tables and all kind of the operations

00:27:23,040 --> 00:27:31,690
fuze have of what object am i working on

00:27:28,320 --> 00:27:38,140
so there is no look there's a complete

00:27:31,690 --> 00:27:41,700
pointer access the opposite doesn't

00:27:38,140 --> 00:27:46,840
happen the user mode doesn't give

00:27:41,700 --> 00:27:49,750
doesn't tell the colonel there is a

00:27:46,840 --> 00:27:53,410
single case where the some there is a

00:27:49,750 --> 00:27:55,870
single case where where the the user

00:27:53,410 --> 00:27:59,050
mode goes with an eye control and says I

00:27:55,870 --> 00:28:02,710
want to operate on this super block so

00:27:59,050 --> 00:28:06,970
what happens that I have an SB key the

00:28:02,710 --> 00:28:10,000
kernel produces a curricular block of 64

00:28:06,970 --> 00:28:12,670
cryptographic key and gives it to the

00:28:10,000 --> 00:28:14,230
amount of the super block so only the

00:28:12,670 --> 00:28:18,550
super block that I was actually created

00:28:14,230 --> 00:28:21,390
on mount is able to access my resources

00:28:18,550 --> 00:28:24,550
my super block resources in the kernel

00:28:21,390 --> 00:28:28,840
but the opposite the kernel can use can

00:28:24,550 --> 00:28:32,410
hold pointers on the server easily so

00:28:28,840 --> 00:28:35,020
the the the all IP I know construction

00:28:32,410 --> 00:28:36,880
there's it's a lot of code but but the

00:28:35,020 --> 00:28:42,810
whole contraption is the zero copy was

00:28:36,880 --> 00:28:42,810
very actually simplifies code by the way

00:28:47,240 --> 00:28:59,240
okay so we kind of reach the end I think

00:28:53,470 --> 00:29:07,690
how do I actually access a how do I

00:28:59,240 --> 00:29:11,360
actually access my data from the server

00:29:07,690 --> 00:29:16,010
so there used to be there used to be a

00:29:11,360 --> 00:29:21,919
version one of this talk where we check

00:29:16,010 --> 00:29:24,890
you see the the purple or the pink pages

00:29:21,919 --> 00:29:27,950
so the application comes with pages that

00:29:24,890 --> 00:29:30,470
it wants to read or write what we used

00:29:27,950 --> 00:29:36,760
to do is that we used to map these pages

00:29:30,470 --> 00:29:39,289
into the server VM a call the call the

00:29:36,760 --> 00:29:42,970
files call the file system and the file

00:29:39,289 --> 00:29:51,950
system writes directly into application

00:29:42,970 --> 00:29:54,799
pages this is a beautiful novel idea but

00:29:51,950 --> 00:30:00,679
in practice it has a problem on Intel

00:29:54,799 --> 00:30:03,649
CPUs which are the important that the

00:30:00,679 --> 00:30:07,789
map and everything is very very fast but

00:30:03,649 --> 00:30:11,630
the on map of these pages out of the VMA

00:30:07,789 --> 00:30:15,080
of the server so I can now map other

00:30:11,630 --> 00:30:18,830
pages the on map doesn't scale because

00:30:15,080 --> 00:30:20,779
the unup has a list of all the threads

00:30:18,830 --> 00:30:25,870
that we were scared all the CPUs that

00:30:20,779 --> 00:30:33,620
were scheduled since the since the map

00:30:25,870 --> 00:30:37,760
and it will schedule a CPU thread to

00:30:33,620 --> 00:30:42,169
shoot down the TLB so in effect every

00:30:37,760 --> 00:30:44,210
single IO scheduler on C on all CPUs so

00:30:42,169 --> 00:30:47,480
I'm completely killing my scalability

00:30:44,210 --> 00:30:51,590
because all of a sudden I have this this

00:30:47,480 --> 00:30:54,440
bottleneck of oh I need all the CPUs in

00:30:51,590 --> 00:30:55,789
order to do mile which is exactly

00:30:54,440 --> 00:31:01,999
against

00:30:55,789 --> 00:31:04,899
this so I tried to do a patch I tried to

00:31:01,999 --> 00:31:10,359
do a patch a hacky patch of actually

00:31:04,899 --> 00:31:13,399
relieving relieving this bottleneck and

00:31:10,359 --> 00:31:15,859
the patch was saying look I know what

00:31:13,399 --> 00:31:19,669
I'm doing the system is pretty hard

00:31:15,859 --> 00:31:21,259
Ernie's is signed and everything here

00:31:19,669 --> 00:31:24,440
you have a flag that I'm telling you

00:31:21,259 --> 00:31:27,229
don't schedule on other CPUs none of the

00:31:24,440 --> 00:31:29,509
CPUs touched your mem this memory only

00:31:27,229 --> 00:31:33,259
one CPU touches memory just invalidate

00:31:29,509 --> 00:31:36,499
that on the single CPU I promise you but

00:31:33,259 --> 00:31:38,869
the kernel guys say you can promise

00:31:36,499 --> 00:31:43,369
until tomorrow but we are not taking

00:31:38,869 --> 00:31:47,330
that there is no promises if the

00:31:43,369 --> 00:31:49,940
malicious server can easily go copy the

00:31:47,330 --> 00:31:52,639
pointer somewhere else and after you're

00:31:49,940 --> 00:31:54,979
already free the pages and gave it to

00:31:52,639 --> 00:31:57,279
another system access it why because the

00:31:54,979 --> 00:32:01,489
TLB wasn't shoot down on the other CPU

00:31:57,279 --> 00:32:04,369
so after like an uphill battle the

00:32:01,489 --> 00:32:08,960
solution that was suggested that we need

00:32:04,369 --> 00:32:11,539
to do a true pair CPU variable in the

00:32:08,960 --> 00:32:15,409
kernel where we take the hierarchy of

00:32:11,539 --> 00:32:19,849
the memory the not at the very bottom

00:32:15,409 --> 00:32:25,099
page but the hierarchy above it we take

00:32:19,849 --> 00:32:30,470
the very last entry and we switch it on

00:32:25,099 --> 00:32:35,239
CP on per CPU so so each CPU actually

00:32:30,470 --> 00:32:37,759
has the very high address below the

00:32:35,239 --> 00:32:40,519
kernel addresses one of the very high

00:32:37,759 --> 00:32:43,009
address automatically switched so when I

00:32:40,519 --> 00:32:46,789
give you so it's like a thread locale

00:32:43,009 --> 00:32:49,340
but a CPU locale but this is a lot of

00:32:46,789 --> 00:32:51,590
work and it's in not only that it's a

00:32:49,340 --> 00:32:56,029
lot of work it's it's ok I've done all

00:32:51,590 --> 00:32:58,639
that work for Intel and now what about

00:32:56,029 --> 00:33:02,499
the other architectures am I not able to

00:32:58,639 --> 00:33:05,210
work on other other characters then so

00:33:02,499 --> 00:33:11,070
we threw that

00:33:05,210 --> 00:33:15,870
we threw that notion and and we and we

00:33:11,070 --> 00:33:18,900
devised a different system and so the

00:33:15,870 --> 00:33:23,330
system is so everything already in the

00:33:18,900 --> 00:33:28,200
API of the old API the version 1 API

00:33:23,330 --> 00:33:31,200
there was a system of saying get block

00:33:28,200 --> 00:33:33,690
and the get block was used by Emma so

00:33:31,200 --> 00:33:37,950
give me the premium block that belongs

00:33:33,690 --> 00:33:43,650
to the index of this file and it give so

00:33:37,950 --> 00:33:48,240
it gives me a t1 t1 t1 address below the

00:33:43,650 --> 00:33:50,280
top the t1 it gives me a D PPT I'll talk

00:33:48,240 --> 00:33:56,220
about the DPP T in a second gives me a

00:33:50,280 --> 00:33:58,530
t1 now give me a t1 block and I will map

00:33:56,220 --> 00:34:03,420
it for the application and then when

00:33:58,530 --> 00:34:06,690
they when the when the time comes you do

00:34:03,420 --> 00:34:10,080
an ad map and so there is already a get

00:34:06,690 --> 00:34:12,960
block boot block interface with a server

00:34:10,080 --> 00:34:15,600
you know give me your blocks now if I

00:34:12,960 --> 00:34:18,060
already have a get block interface with

00:34:15,600 --> 00:34:21,630
the server what I can do is just get the

00:34:18,060 --> 00:34:25,710
get block from the server do the copy

00:34:21,630 --> 00:34:30,179
myself in kernel and and put block okay

00:34:25,710 --> 00:34:32,540
I'm done copying now if I'm already if I

00:34:30,179 --> 00:34:36,419
already know the block I have it at hand

00:34:32,540 --> 00:34:39,510
then I can cache it I can put it in a

00:34:36,419 --> 00:34:41,580
mixer a pair I node and the next time

00:34:39,510 --> 00:34:43,140
you read the same block I say oh it's

00:34:41,580 --> 00:34:45,290
already cached I don't even have to go

00:34:43,140 --> 00:34:51,120
to the server and I can copy it again

00:34:45,290 --> 00:34:54,090
and so so it's it's a instead of doing

00:34:51,120 --> 00:34:55,590
the the mapping and all the TLB shooters

00:34:54,090 --> 00:35:00,500
then the problems we have we're just

00:34:55,590 --> 00:35:05,250
using the get block mechanism and and

00:35:00,500 --> 00:35:08,040
the way this is built is that you have

00:35:05,250 --> 00:35:13,200
an array you have a pointer to an array

00:35:08,040 --> 00:35:15,280
of 64 you 64 that you receive from the

00:35:13,200 --> 00:35:19,420
kernel and you have

00:35:15,280 --> 00:35:23,280
all kind of operations can I have is

00:35:19,420 --> 00:35:23,280
there a mouse that I can put over the

00:35:30,960 --> 00:35:38,890
the top eight beats tell me in operation

00:35:34,060 --> 00:35:42,510
so I can have up to two to 256 different

00:35:38,890 --> 00:35:50,590
operations the 255 a currently there is

00:35:42,510 --> 00:35:52,600
five of them so they beat something what

00:35:50,590 --> 00:35:58,510
is the operation and then I also have a

00:35:52,600 --> 00:36:01,690
56 bit of a value and then according to

00:35:58,510 --> 00:36:03,730
the operation I might have more so I

00:36:01,690 --> 00:36:07,030
have like these structures that tell me

00:36:03,730 --> 00:36:09,670
please do things so for the get block

00:36:07,030 --> 00:36:17,140
operation I want to write two megabytes

00:36:09,670 --> 00:36:19,780
I will have a t1 up a pointer and then I

00:36:17,140 --> 00:36:22,240
might have a repeat so the repeat is an

00:36:19,780 --> 00:36:27,960
operation by itself the repeat tells me

00:36:22,240 --> 00:36:32,020
and so here you have let's say I have a

00:36:27,960 --> 00:36:35,050
contiguous 1 megabyte in impe mm then I

00:36:32,020 --> 00:36:39,700
give you okay you have this is the

00:36:35,050 --> 00:36:42,430
address and you and it's repeated 256

00:36:39,700 --> 00:36:45,130
times for one megabyte or if I have each

00:36:42,430 --> 00:36:47,980
4 K goes in a different place in the

00:36:45,130 --> 00:36:51,340
behavior I just have like a a scatter

00:36:47,980 --> 00:36:53,410
gather list so this is like us what is

00:36:51,340 --> 00:36:55,450
IO map i-i'm is just a scattered gather

00:36:53,410 --> 00:36:57,550
list on steroids

00:36:55,450 --> 00:36:59,320
it's like it's not only that it is care

00:36:57,550 --> 00:37:00,610
gather list it also tells you what I

00:36:59,320 --> 00:37:04,360
want to do with them with that

00:37:00,610 --> 00:37:06,760
information so the one the first one the

00:37:04,360 --> 00:37:11,080
the basic one is get get block give me

00:37:06,760 --> 00:37:12,940
blocks to write to the second one is T

00:37:11,080 --> 00:37:17,200
to read remember we have T two devices

00:37:12,940 --> 00:37:20,170
we have regular block devices so I'm

00:37:17,200 --> 00:37:24,349
asking to rather to read from from this

00:37:20,170 --> 00:37:28,489
T 2 into this T 1 or 2 right

00:37:24,349 --> 00:37:31,519
this D 1 into this D 2 but this is the

00:37:28,489 --> 00:37:34,670
time to talk about dbpedia dt p rd p PT

00:37:31,519 --> 00:37:38,049
is a dual port pointer type so the door

00:37:34,670 --> 00:37:43,009
the dual port pointer type is actually

00:37:38,049 --> 00:37:50,420
an offset but an offset where it's an

00:37:43,009 --> 00:37:55,729
offset to some kind of pool some kind of

00:37:50,420 --> 00:37:59,799
memory pool it's an 8 but it's an 8 byte

00:37:55,729 --> 00:38:04,460
aligned offset so I have the very three

00:37:59,799 --> 00:38:14,059
lower bits I have free so the very three

00:38:04,460 --> 00:38:18,079
lower bits of code in coda pool the 0 s

00:38:14,059 --> 00:38:22,249
pool means my pmm devices so my all

00:38:18,079 --> 00:38:24,680
payment devices is a pool of a linear

00:38:22,249 --> 00:38:26,180
address space I give you an offset to

00:38:24,680 --> 00:38:29,089
that payment please write from that

00:38:26,180 --> 00:38:34,369
offset because the kernel already has

00:38:29,089 --> 00:38:38,259
access to the premium memory another

00:38:34,369 --> 00:38:43,130
special pool is number 7 which tells you

00:38:38,259 --> 00:38:48,019
please write to the application buffers

00:38:43,130 --> 00:38:51,229
so this is pool number 7 the content of

00:38:48,019 --> 00:38:56,029
this read directly into user buffers so

00:38:51,229 --> 00:39:00,109
this is like direct IO of T to devices

00:38:56,029 --> 00:39:00,710
and then the other five pools that are

00:39:00,109 --> 00:39:03,410
left

00:39:00,710 --> 00:39:06,200
six poles that are left there is a

00:39:03,410 --> 00:39:09,729
mechanism to actually allocate a pool

00:39:06,200 --> 00:39:14,420
and have like a shared memory

00:39:09,729 --> 00:39:16,700
communication with a server and so if

00:39:14,420 --> 00:39:18,769
it's not a premium based server it's

00:39:16,700 --> 00:39:22,880
it's based on something else or maybe

00:39:18,769 --> 00:39:25,569
it's even like a an SQL server or a

00:39:22,880 --> 00:39:29,119
MongoDB server that wants to communicate

00:39:25,569 --> 00:39:31,099
via this very fast communication channel

00:39:29,119 --> 00:39:34,460
it just emulates some file system

00:39:31,099 --> 00:39:36,279
interface let's say when I write to SQL

00:39:34,460 --> 00:39:40,660
within this

00:39:36,279 --> 00:39:46,789
Quarry then it I get a quarry back then

00:39:40,660 --> 00:39:48,920
then then there's six China six other

00:39:46,789 --> 00:39:51,529
pools that we can establish between us

00:39:48,920 --> 00:39:54,249
of shared memory so everywhere you see a

00:39:51,529 --> 00:39:57,380
teepee PT also also the eye notes

00:39:54,249 --> 00:40:00,950
remember the eye nodes that we saw there

00:39:57,380 --> 00:40:08,210
RDP PT the ID of the shared I know the

00:40:00,950 --> 00:40:10,339
objects exit ours soft links all the

00:40:08,210 --> 00:40:14,809
objects that we know that are kind of

00:40:10,339 --> 00:40:18,019
like on the on the the filesystem side

00:40:14,809 --> 00:40:21,619
but actually need access from the from

00:40:18,019 --> 00:40:25,640
the from the kernel

00:40:21,619 --> 00:40:28,039
instead of of copying them on the i/o

00:40:25,640 --> 00:40:30,980
control on the interface I'm just giving

00:40:28,039 --> 00:40:33,640
a pbbbt to them and were you were

00:40:30,980 --> 00:40:38,329
communicating through shared memory

00:40:33,640 --> 00:40:43,190
another another important another

00:40:38,329 --> 00:40:46,700
important object is the Zeus mem read

00:40:43,190 --> 00:40:50,450
and write so actually I'm just actually

00:40:46,700 --> 00:40:54,079
giving you this ones in in the server

00:40:50,450 --> 00:40:57,829
context so I can actually so the kernel

00:40:54,079 --> 00:41:00,980
has actual access to to the memory of

00:40:57,829 --> 00:41:03,739
the process of the server and so I can

00:41:00,980 --> 00:41:07,869
write I can read and write internally

00:41:03,739 --> 00:41:12,980
into into server buffers and that

00:41:07,869 --> 00:41:17,119
another operation scatter gathers on

00:41:12,980 --> 00:41:19,489
steroids is on map remember when we did

00:41:17,119 --> 00:41:23,749
get blocks and we put and we catch them

00:41:19,489 --> 00:41:29,230
or maybe we did a map and we put it on

00:41:23,749 --> 00:41:32,239
the application virtual space the server

00:41:29,230 --> 00:41:35,329
at some point says look I want to get

00:41:32,239 --> 00:41:39,200
rid of I'm revoking the access from this

00:41:35,329 --> 00:41:41,029
block I'm revoking that this one this

00:41:39,200 --> 00:41:45,680
block and if you want it again

00:41:41,029 --> 00:41:47,660
you'll get a page a page fault or please

00:41:45,680 --> 00:41:48,320
removed it from from your caching don't

00:41:47,660 --> 00:41:50,510
come

00:41:48,320 --> 00:41:54,410
to me again if you want the index of

00:41:50,510 --> 00:41:57,200
this valve so so this is done with the

00:41:54,410 --> 00:42:03,740
unmapped where where I give you a page

00:41:57,200 --> 00:42:12,440
index in the file an inode number and a

00:42:03,740 --> 00:42:14,960
number of pages I want to unwrap and so

00:42:12,440 --> 00:42:17,870
yeah so this is the way so this is the

00:42:14,960 --> 00:42:22,310
new way the new way means the kernel is

00:42:17,870 --> 00:42:24,950
doing the copying and is using a get

00:42:22,310 --> 00:42:27,920
block put block interface from the

00:42:24,950 --> 00:42:31,130
server that we already had instead of

00:42:27,920 --> 00:42:36,520
doing all this VM a marker it's less

00:42:31,130 --> 00:42:39,730
pretty but also an i/o map can be

00:42:36,520 --> 00:42:43,340
asynchronously called from the server

00:42:39,730 --> 00:42:48,230
through an i/o controls who IOC IO map

00:42:43,340 --> 00:42:50,690
execute and because let's say you have a

00:42:48,230 --> 00:42:52,790
background processes that go and say

00:42:50,690 --> 00:42:57,500
okay I'm going to take all these

00:42:52,790 --> 00:43:00,830
memories and I'm going to post them to

00:42:57,500 --> 00:43:04,400
two hard drives and unmount them and you

00:43:00,830 --> 00:43:06,980
know do you know management file system

00:43:04,400 --> 00:43:10,670
management then they can do it through

00:43:06,980 --> 00:43:12,950
that so so sometimes the colonel asked

00:43:10,670 --> 00:43:15,620
for an operation and in the results that

00:43:12,950 --> 00:43:17,600
it gets is an IMAP and sometimes the

00:43:15,620 --> 00:43:21,100
file system on his own accord saying

00:43:17,600 --> 00:43:25,450
okay do all these maintenance things

00:43:21,100 --> 00:43:25,450
yeah actually I think it's

00:43:28,930 --> 00:43:45,340
so yeah yes please sorry unless you open

00:43:41,780 --> 00:43:48,350
sauce you know any specific zeus server

00:43:45,340 --> 00:43:50,780
it seems rather unlikely that you will

00:43:48,350 --> 00:43:53,480
get the kernel pots upstream right

00:43:50,780 --> 00:43:56,990
is there any so there is a already took

00:43:53,480 --> 00:44:00,590
two examples of a fully function of our

00:43:56,990 --> 00:44:04,490
systems one is their food fest which is

00:44:00,590 --> 00:44:10,610
like a real foolish fast it's a really

00:44:04,490 --> 00:44:13,550
really foolish straight one to one API

00:44:10,610 --> 00:44:15,770
call to to a file system and then there

00:44:13,550 --> 00:44:18,040
is another one which is a toy FS which

00:44:15,770 --> 00:44:22,100
is a more complete set of

00:44:18,040 --> 00:44:25,490
implementations and yes please

00:44:22,100 --> 00:44:28,250
I I'm looking for for implementers

00:44:25,490 --> 00:44:31,220
because because I know that this

00:44:28,250 --> 00:44:35,960
interface is good for me but I haven't

00:44:31,220 --> 00:44:38,660
proven that it's generally good so I

00:44:35,960 --> 00:44:41,030
want to resist a serious system you know

00:44:38,660 --> 00:44:43,370
like SEF he was saying they're

00:44:41,030 --> 00:44:50,420
interested in all kind of network file

00:44:43,370 --> 00:44:54,820
systems a cluster said they were

00:44:50,420 --> 00:44:58,700
interested so like to see is my API

00:44:54,820 --> 00:45:03,350
mature enough do I can i supply all the

00:44:58,700 --> 00:45:07,850
functionality for you you probably can't

00:45:03,350 --> 00:45:10,820
mention any you know features you are

00:45:07,850 --> 00:45:13,910
implementing based on this at NetApp

00:45:10,820 --> 00:45:18,670
right this is all yeah non-disclosure

00:45:13,910 --> 00:45:21,910
stuff right yes Netta fascism is a very

00:45:18,670 --> 00:45:24,470
robust complete feature the file system

00:45:21,910 --> 00:45:32,540
including it stuff like snapshots and

00:45:24,470 --> 00:45:35,180
things that some a cow whatever you I

00:45:32,540 --> 00:45:38,370
don't know mirroring on other now it's a

00:45:35,180 --> 00:45:41,280
lot of it's very so yeah

00:45:38,370 --> 00:45:44,310
and exit ours and HCL's and all these

00:45:41,280 --> 00:45:46,800
things they are implemented all right so

00:45:44,310 --> 00:45:48,510
I think we're just about out of time so

00:45:46,800 --> 00:45:51,390
maybe if there are any other questions

00:45:48,510 --> 00:45:54,110
people can talk to Bo I was in the hall

00:45:51,390 --> 00:45:57,950
yes yeah yeah and you have my email and

00:45:54,110 --> 00:46:00,300
write to me and I'm sorry there is a

00:45:57,950 --> 00:46:03,780
Geary's there is already Catrice on

00:46:00,300 --> 00:46:06,780
github hope to put them in on the

00:46:03,780 --> 00:46:10,590
kernel.org soon enough

00:46:06,780 --> 00:46:13,260
and key top is available and and there's

00:46:10,590 --> 00:46:20,850
a mailing list I just it's all kind of

00:46:13,260 --> 00:46:23,510
new one and I was like busy so I like I

00:46:20,850 --> 00:46:28,950
just didn't bring that information but

00:46:23,510 --> 00:46:32,790
email me please email me and I will be

00:46:28,950 --> 00:46:35,490
glad up until now I've been buried in

00:46:32,790 --> 00:46:39,960
the work and the stability and the bugs

00:46:35,490 --> 00:46:43,250
and things now I'm finally feel it's

00:46:39,960 --> 00:46:45,570
mature and I want to address the public

00:46:43,250 --> 00:46:46,680
this is the right time thank you very

00:46:45,570 --> 00:46:50,320
much

00:46:46,680 --> 00:46:50,320

YouTube URL: https://www.youtube.com/watch?v=UCNwz_n9oBY


