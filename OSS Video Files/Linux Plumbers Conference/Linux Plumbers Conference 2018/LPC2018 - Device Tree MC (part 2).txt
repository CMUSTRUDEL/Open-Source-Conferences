Title: LPC2018 - Device Tree MC (part 2)
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	https://linuxplumbersconf.org/event/2/sessions/36/#20181114


Topics
Binding and Devicetree Source/DTB Validation: update and next steps
Binding specification format
Validation Process and Process
How to validate overlays
Devicetree Specification: update and next steps

Reducing devicetree memory and storage size

Overlays

Bootloader and Linux kernel implementation update
Remaining blockers and issues
Use cases
Devicetree compiler (dtc)

Next version of DTB/FDT format
Motivated by desire to replace metadata being encoded as normal data (metadata for overlays)
Other desired changes should be considered
Boot and Run-time Configuration
Pain points and needs
Multi-bus devices

Feedback from the trenches

how DTOs are used in embedded devices in practice
in U-Boot and Linux
in systems with FPGAs
Use of devicetrees in small code/data space (e.g. U-Boot SPL)

Connector node bindings

FPGA issues
Captions: 
	00:00:05,660 --> 00:00:13,260
but for now let's just focus on the the

00:00:08,880 --> 00:00:15,930
kernel so I don't have a any prepared

00:00:13,260 --> 00:00:20,039
material here at all I wanted this to

00:00:15,930 --> 00:00:21,930
just be an actual both where we discuss

00:00:20,039 --> 00:00:23,910
things you know people who are working

00:00:21,930 --> 00:00:26,430
on trying to get the kernel working with

00:00:23,910 --> 00:00:27,480
LLVM or get the kernel working works I

00:00:26,430 --> 00:00:30,750
know it's already working for some

00:00:27,480 --> 00:00:33,210
people maybe maybe go around and all

00:00:30,750 --> 00:00:36,120
talk about what we're doing

00:00:33,210 --> 00:00:39,200
say hello to each other and maybe

00:00:36,120 --> 00:00:42,030
coordinated bit but what we're up to

00:00:39,200 --> 00:00:45,090
so for those of you who don't know me

00:00:42,030 --> 00:00:45,720
I'm Marc Brown I'm the kernel work group

00:00:45,090 --> 00:00:50,060
tech leader

00:00:45,720 --> 00:00:54,060
Lenora and we've recently started

00:00:50,060 --> 00:00:56,460
picking up some of this work Linares

00:00:54,060 --> 00:00:59,579
good working on getting some automated

00:00:56,460 --> 00:01:02,970
build testing running with kernel CI and

00:00:59,579 --> 00:01:05,759
then once that's there we are our

00:01:02,970 --> 00:01:07,759
central planners to sit down look at the

00:01:05,759 --> 00:01:09,930
errors and warnings we're getting and

00:01:07,759 --> 00:01:15,720
submit patches for those that nobody

00:01:09,930 --> 00:01:20,190
else has done our initial focus is going

00:01:15,720 --> 00:01:23,100
to be on arm 64 and x86 arm 64 because

00:01:20,190 --> 00:01:27,600
that's what as Lenora we care about a

00:01:23,100 --> 00:01:30,000
lot and x86 because realistically the

00:01:27,600 --> 00:01:31,170
kernel community is mostly x86 based so

00:01:30,000 --> 00:01:43,380
we need to do that for want to get

00:01:31,170 --> 00:01:44,159
anywhere about it it did how

00:01:43,380 --> 00:01:49,439
about is it today

00:01:44,159 --> 00:01:50,880
hey so on x86 it will point Blair the

00:01:49,439 --> 00:01:56,250
kernel will point-blank refused to build

00:01:50,880 --> 00:01:58,350
because I've had some goat which I

00:01:56,250 --> 00:01:59,790
understand that there's some patches

00:01:58,350 --> 00:02:04,740
polluting about which might be published

00:01:59,790 --> 00:02:06,420
soon to fix but you know actually seeds

00:02:04,740 --> 00:02:09,509
it's just a non-starter because of that

00:02:06,420 --> 00:02:12,030
on arm 64 you can build and run a useful

00:02:09,509 --> 00:02:15,390
kernel already and there are a

00:02:12,030 --> 00:02:17,530
production system shipping with clang

00:02:15,390 --> 00:02:20,520
built kernels

00:02:17,530 --> 00:02:32,260
you can't do everything but it's

00:02:20,520 --> 00:02:32,920
tractable but just to throw a spanner in

00:02:32,260 --> 00:02:34,870
the works

00:02:32,920 --> 00:02:37,620
mainline def config doesn't build with a

00:02:34,870 --> 00:02:41,380
released clang seven dodo binary from

00:02:37,620 --> 00:02:45,160
LLVM dork there are a couple of missing

00:02:41,380 --> 00:02:55,570
features there yeah yeah the SSC Atomics

00:02:45,160 --> 00:03:02,280
are a big one there in good news this is

00:02:55,570 --> 00:03:07,180
on in good news papacy works build pappy

00:03:02,280 --> 00:03:09,550
c64 little-endian and big-endian are on

00:03:07,180 --> 00:03:11,410
big endian and you can be able to

00:03:09,550 --> 00:03:14,920
explore embedded and i boot tested it

00:03:11,410 --> 00:03:17,440
and I am reliably informed the 32-bit a

00:03:14,920 --> 00:03:20,530
PC works as well so for things that

00:03:17,440 --> 00:03:22,709
aren't armed and aren't x86 there is per

00:03:20,530 --> 00:03:29,560
PC and it builds and boots

00:03:22,709 --> 00:03:33,190
yay another good new 686 also works if

00:03:29,560 --> 00:03:37,470
you revert a few patches some go so we

00:03:33,190 --> 00:03:41,620
will use it now it works we use it we

00:03:37,470 --> 00:03:44,200
the dynamic tools team at Google we use

00:03:41,620 --> 00:03:48,100
it with the memory sanitizer which is

00:03:44,200 --> 00:03:53,230
not upstream but we build a and and run

00:03:48,100 --> 00:03:56,860
and use the x86 kernel disco and so

00:03:53,230 --> 00:04:01,000
you're working on why are you pushing

00:03:56,860 --> 00:04:04,030
any of your stuff upstream or are you

00:04:01,000 --> 00:04:09,220
just using it not much so we report some

00:04:04,030 --> 00:04:13,920
issues to see and other people but we

00:04:09,220 --> 00:04:13,920
don't we don't do much fixing ourselves

00:04:18,739 --> 00:04:26,820
hi everyone I'm Nick at Google I used to

00:04:23,940 --> 00:04:30,360
work on a kernel team for the pixel

00:04:26,820 --> 00:04:34,560
phones I now work on the yellow VM side

00:04:30,360 --> 00:04:36,690
of the equation so I've been working on

00:04:34,560 --> 00:04:40,530
this for a little bit of a little while

00:04:36,690 --> 00:04:43,140
and trying to coordinate both getting

00:04:40,530 --> 00:04:45,360
reports to LLVM developers hands and

00:04:43,140 --> 00:04:46,950
then now trying to fix things on the OEM

00:04:45,360 --> 00:04:49,890
side and get people on the yellow VM

00:04:46,950 --> 00:04:52,530
side to pick up pick up feature requests

00:04:49,890 --> 00:04:54,960
or plugs and implement them as well so

00:04:52,530 --> 00:04:56,730
I'm super interested in hearing people's

00:04:54,960 --> 00:04:58,590
experiences or getting in touch with

00:04:56,730 --> 00:05:01,170
people trying to sort out what issues

00:04:58,590 --> 00:05:03,870
that people are facing maybe getting

00:05:01,170 --> 00:05:05,520
help prioritizing these things and just

00:05:03,870 --> 00:05:09,290
seeing you know what what people's

00:05:05,520 --> 00:05:09,290
results are with testing this stuff so

00:05:17,540 --> 00:05:23,940
hello my name's bean Webster I guess to

00:05:20,850 --> 00:05:25,740
a certain extent I was around for near

00:05:23,940 --> 00:05:28,230
the beginning of this this work to total

00:05:25,740 --> 00:05:29,910
you're told it's partially my fault and

00:05:28,230 --> 00:05:33,420
certainly some of you have blamed me for

00:05:29,910 --> 00:05:34,770
it but anyway yeah I don't work out as

00:05:33,420 --> 00:05:37,500
much anymore

00:05:34,770 --> 00:05:39,110
certainly and but very very glad to see

00:05:37,500 --> 00:05:41,760
that so much work is being done

00:05:39,110 --> 00:05:43,560
certainly with many of you that I spoke

00:05:41,760 --> 00:05:46,220
to years and years ago about this in the

00:05:43,560 --> 00:05:46,220
first place so

00:05:52,050 --> 00:06:02,129
that's so last last time I tried to

00:06:00,539 --> 00:06:03,710
enable this in colonel CI with an

00:06:02,129 --> 00:06:08,580
upstream colonel in upstream like a

00:06:03,710 --> 00:06:10,259
shipping LLVM on x86 and arm things when

00:06:08,580 --> 00:06:12,330
things just didn't work with the deep

00:06:10,259 --> 00:06:13,860
the main the main the shipping deaf

00:06:12,330 --> 00:06:16,020
configs and the shipping trees and stuff

00:06:13,860 --> 00:06:17,460
so how how far are we and where are the

00:06:16,020 --> 00:06:20,580
obstacles from actually doing with

00:06:17,460 --> 00:06:23,870
upstream Elvia or shipping LLVM and a

00:06:20,580 --> 00:06:23,870
shipping colonel and deaf configs

00:06:25,069 --> 00:06:34,770
they there's a couple of LLVM features

00:06:30,270 --> 00:06:36,349
that are are needed so there's the

00:06:34,770 --> 00:06:43,530
awesome good to thing which we mentioned

00:06:36,349 --> 00:06:45,479
sse Atomics i think it is on arms see

00:06:43,530 --> 00:06:48,810
sorry yes yeah the élysée atomic thing

00:06:45,479 --> 00:06:52,530
is special ABI reserving special

00:06:48,810 --> 00:06:58,139
registers and there's also KVM does not

00:06:52,530 --> 00:06:59,969
work with with with clang because clang

00:06:58,139 --> 00:07:01,110
will generate a jump table using

00:06:59,969 --> 00:07:08,279
absolute addressing we need a hack to

00:07:01,110 --> 00:07:10,139
avoid yeah happy say it's mostly just

00:07:08,279 --> 00:07:12,419
config options so there are a few things

00:07:10,139 --> 00:07:15,029
like we don't clang doesn't support the

00:07:12,419 --> 00:07:18,090
vector instructions required to build

00:07:15,029 --> 00:07:22,849
the grade stuff unless you twiddle some

00:07:18,090 --> 00:07:22,849
options but it's mostly there

00:07:23,469 --> 00:07:28,209
I'm speaking to the microphone it's

00:07:25,179 --> 00:07:31,119
mostly there yeah yeah I mean that's get

00:07:28,209 --> 00:07:33,219
in the same situation alarm 64 you can

00:07:31,119 --> 00:07:37,479
turn off sufficient things to get it

00:07:33,219 --> 00:07:40,179
working but you know they are in the

00:07:37,479 --> 00:07:41,860
Deaf config there are a couple of

00:07:40,179 --> 00:07:46,289
patches making their way into mainline

00:07:41,860 --> 00:07:46,289
but again they're mostly there yeah

00:07:53,080 --> 00:07:58,449
so Zarek is there is there a known

00:07:55,720 --> 00:08:00,970
blessed place to grab the LLVM that has

00:07:58,449 --> 00:08:06,340
the right the right features to actually

00:08:00,970 --> 00:08:07,569
build and boot mainline so I think one

00:08:06,340 --> 00:08:09,190
of the things that that we're looking

00:08:07,569 --> 00:08:11,770
into right now is some some automated

00:08:09,190 --> 00:08:15,759
testing and I think the thing that is a

00:08:11,770 --> 00:08:18,849
little tricky is like as as we need to

00:08:15,759 --> 00:08:20,650
ship features in LLVM like how fast can

00:08:18,849 --> 00:08:24,610
we get those into people's hands because

00:08:20,650 --> 00:08:26,949
LLVM has its own release schedule which

00:08:24,610 --> 00:08:29,319
is like every six months I believe they

00:08:26,949 --> 00:08:31,599
put out a major version release anything

00:08:29,319 --> 00:08:34,870
so for instance like the Yellow Sea

00:08:31,599 --> 00:08:37,120
atomic fixes like we've very recently

00:08:34,870 --> 00:08:38,979
implemented them and clang but you know

00:08:37,120 --> 00:08:40,570
how soon is it until that becomes a

00:08:38,979 --> 00:08:42,610
published version number is always a

00:08:40,570 --> 00:08:44,529
question and then for any given Linux

00:08:42,610 --> 00:08:46,390
distribution you know it takes time for

00:08:44,529 --> 00:08:48,160
a maintainer to pick that up and package

00:08:46,390 --> 00:08:49,450
it and put it in in your favorite

00:08:48,160 --> 00:08:51,910
distribution that works with your setup

00:08:49,450 --> 00:08:54,040
kind of thing right so one of the things

00:08:51,910 --> 00:08:58,570
that that I started using recently that

00:08:54,040 --> 00:09:02,740
I've had some success with is there's a

00:08:58,570 --> 00:09:07,089
site apt LOV org that packages nightly

00:09:02,740 --> 00:09:08,110
builds of clang in the LLVM tools and so

00:09:07,089 --> 00:09:10,660
if you're on a deviant based

00:09:08,110 --> 00:09:12,790
distribution or you can apt install you

00:09:10,660 --> 00:09:15,850
can get a nightly build of clang that's

00:09:12,790 --> 00:09:18,700
pre-built otherwise right now building

00:09:15,850 --> 00:09:29,050
from source kind of thing for those of

00:09:18,700 --> 00:09:32,050
us I don't know the question was around

00:09:29,050 --> 00:09:40,420
what's the easiest way to get LLVM that

00:09:32,050 --> 00:09:42,339
has any given required fixes is there

00:09:40,420 --> 00:09:44,290
any mileage in having something like the

00:09:42,339 --> 00:09:45,760
kernel or cross tool fellow at the end

00:09:44,290 --> 00:09:47,709
because there are lots of people not

00:09:45,760 --> 00:09:49,360
using Debian who don't want or who don't

00:09:47,709 --> 00:09:50,890
want to add arbitrary random sites to

00:09:49,360 --> 00:09:53,890
the app list don't want to have the

00:09:50,890 --> 00:09:56,589
compiler arbitrarily update sure so so

00:09:53,890 --> 00:09:59,050
like I I think the hard part is like

00:09:56,589 --> 00:10:00,670
finding a way to package it in a way

00:09:59,050 --> 00:10:03,640
that works for everyone because everyone

00:10:00,670 --> 00:10:05,560
does Linux differently so like last week

00:10:03,640 --> 00:10:06,760
we had a request where someone says like

00:10:05,560 --> 00:10:08,590
we sent a patch for a fix

00:10:06,760 --> 00:10:10,270
warned up and someone said well where's

00:10:08,590 --> 00:10:12,460
the docker image you guys should just

00:10:10,270 --> 00:10:14,320
give us a docker image and then I mean

00:10:12,460 --> 00:10:16,540
the standard way that various places do

00:10:14,320 --> 00:10:19,180
this the Lennar O'Toole chain releases

00:10:16,540 --> 00:10:21,940
the kernel or just folders you can put

00:10:19,180 --> 00:10:23,980
anywhere yeah that would be a really

00:10:21,940 --> 00:10:25,600
standard way for people to ago okay yeah

00:10:23,980 --> 00:10:28,300
it's just it's like something we're not

00:10:25,600 --> 00:10:34,240
aware of kind of thing so I guess what

00:10:28,300 --> 00:10:35,890
did you call it was the kernel work so

00:10:34,240 --> 00:10:37,990
there is actually two more places where

00:10:35,890 --> 00:10:41,650
you can get reasonably pre-built

00:10:37,990 --> 00:10:44,410
versions one is still in our CI system

00:10:41,650 --> 00:10:46,900
where we automatically built new

00:10:44,410 --> 00:10:49,360
snapshots every night you can find those

00:10:46,900 --> 00:10:51,460
on snapshots total in our a talk I don't

00:10:49,360 --> 00:10:53,230
know the exact directory off the top of

00:10:51,460 --> 00:10:56,080
my head but you can find it looking

00:10:53,230 --> 00:10:58,600
around there and the other place is in

00:10:56,080 --> 00:11:00,220
the Android sources Android comes with

00:10:58,600 --> 00:11:02,980
its own version of clang that has a

00:11:00,220 --> 00:11:05,860
couple of patches and you can use that

00:11:02,980 --> 00:11:07,890
version as well and it generally has two

00:11:05,860 --> 00:11:11,320
patches needed to build Takano as well

00:11:07,890 --> 00:11:12,670
yeah I mean I think from from my

00:11:11,320 --> 00:11:16,060
perspective at the minute we're kind of

00:11:12,670 --> 00:11:20,050
until with the state things are at the

00:11:16,060 --> 00:11:22,350
minute it's probably reasonable to tell

00:11:20,050 --> 00:11:25,630
people that they can build from source

00:11:22,350 --> 00:11:28,840
because the applying is not complicated

00:11:25,630 --> 00:11:31,270
to build I mean it's a bit slow but it's

00:11:28,840 --> 00:11:32,560
not complicated and then you can get

00:11:31,270 --> 00:11:36,100
something it's just in the directory

00:11:32,560 --> 00:11:39,130
that you can you can refer to but I

00:11:36,100 --> 00:11:40,960
think there's you're talking about a git

00:11:39,130 --> 00:11:43,320
snaps or whatever revision control

00:11:40,960 --> 00:11:47,530
system these I think it is get snapshot

00:11:43,320 --> 00:11:50,200
so it's kind of they use SP end and like

00:11:47,530 --> 00:11:51,850
supposed to last week move to entirely

00:11:50,200 --> 00:12:02,170
to get I don't think they've completed

00:11:51,850 --> 00:12:03,940
that move and time yeah yeah so yeah I

00:12:02,170 --> 00:12:06,580
think one of the things that's that is

00:12:03,940 --> 00:12:10,180
like things kind of depend at the moment

00:12:06,580 --> 00:12:11,680
on your configurations so if you have an

00:12:10,180 --> 00:12:14,500
off-the-shelf config if it's a def

00:12:11,680 --> 00:12:17,020
config def configs change over time

00:12:14,500 --> 00:12:19,920
right so LLC Atomics was a config that

00:12:17,020 --> 00:12:21,930
was not default on until

00:12:19,920 --> 00:12:23,100
within the past couple of releases I

00:12:21,930 --> 00:12:26,790
believe yeah

00:12:23,100 --> 00:12:28,500
but depending on your kernel

00:12:26,790 --> 00:12:31,920
configuration your mileage may vary so

00:12:28,500 --> 00:12:35,010
for pixel two we shipped a clanging

00:12:31,920 --> 00:12:37,380
built kernel compiled with clang four so

00:12:35,010 --> 00:12:39,600
we were able to use a fairly old version

00:12:37,380 --> 00:12:42,650
of clang to compile the configs that

00:12:39,600 --> 00:12:42,650
we're using in our kernel configuration

00:12:43,670 --> 00:12:49,920
make a comment on the def config any new

00:12:47,520 --> 00:12:52,800
architecture any new feature in the

00:12:49,920 --> 00:12:57,240
architecture will be on by default and

00:12:52,800 --> 00:12:58,590
in def config or ETA config so I guess

00:12:57,240 --> 00:13:01,220
we'll have this problem every time we

00:12:58,590 --> 00:13:04,500
add a new feature to the architecture

00:13:01,220 --> 00:13:05,760
sure I mean if if we're adding things on

00:13:04,500 --> 00:13:06,870
our architecture like the tool chain

00:13:05,760 --> 00:13:11,610
needs to support these things if you

00:13:06,870 --> 00:13:13,740
want to use them oh of course it might

00:13:11,610 --> 00:13:15,570
also be the client becomes the fastest

00:13:13,740 --> 00:13:16,920
compiler to be developed and therefore

00:13:15,570 --> 00:13:23,060
all the GCC people get things broken

00:13:16,920 --> 00:13:23,060
instead but that's always gonna be fun

00:13:26,150 --> 00:13:35,190
so that's we have to get the tool chains

00:13:28,920 --> 00:13:36,300
from do anybody else have any top issues

00:13:35,190 --> 00:13:41,430
they have we're having with playing at a

00:13:36,300 --> 00:13:42,840
minute or anything they wanted to so so

00:13:41,430 --> 00:13:44,820
far we're only talking about the C

00:13:42,840 --> 00:13:46,590
compiler right what's this is there any

00:13:44,820 --> 00:13:48,060
effort of the assembler and linker and

00:13:46,590 --> 00:13:52,470
stuff like especially the parallel

00:13:48,060 --> 00:13:55,320
linker is actually quite attractive yeah

00:13:52,470 --> 00:13:57,540
so as of maybe three weeks ago I was

00:13:55,320 --> 00:14:02,820
able to successfully link and they are

00:13:57,540 --> 00:14:05,060
64 def config with LD we have it boot

00:14:02,820 --> 00:14:07,590
testing and continuous integration yeah

00:14:05,060 --> 00:14:09,120
if I think I assume there's probably

00:14:07,590 --> 00:14:12,330
more work I haven't even tried it in all

00:14:09,120 --> 00:14:16,790
yes config I haven't tried multiple ran

00:14:12,330 --> 00:14:19,650
configs kind of thing but I would say

00:14:16,790 --> 00:14:23,580
it's my personal priority to focus on

00:14:19,650 --> 00:14:27,270
compiling then to look at the rest of

00:14:23,580 --> 00:14:29,550
the cross tools and my personal feeling

00:14:27,270 --> 00:14:32,690
on this is that we're closer to be able

00:14:29,550 --> 00:14:34,820
to link the kernel with the LLVM

00:14:32,690 --> 00:14:36,380
linker than we are to assemble it with

00:14:34,820 --> 00:14:39,170
clangs integrated assembler I think

00:14:36,380 --> 00:14:41,930
there's a long tail of of work to be

00:14:39,170 --> 00:14:44,480
done in clang where the where the

00:14:41,930 --> 00:14:46,730
assembler lives before we can assemble

00:14:44,480 --> 00:14:50,750
the kernel woman with clang but it

00:14:46,730 --> 00:14:52,070
requires more more testing I encourage

00:14:50,750 --> 00:14:54,290
people like if you're interested in

00:14:52,070 --> 00:14:56,330
trying it you can just try it and then

00:14:54,290 --> 00:14:58,430
report bugs to us that way we have a

00:14:56,330 --> 00:15:00,620
list and we know you know are we 100

00:14:58,430 --> 00:15:02,780
missing features away are we for mitch

00:15:00,620 --> 00:15:04,550
missing features away are we one missing

00:15:02,780 --> 00:15:08,080
feature away like how close are we and

00:15:04,550 --> 00:15:08,080
how complicated this features as well

00:15:08,290 --> 00:15:12,740
well the assembler I think it's a big

00:15:10,310 --> 00:15:15,320
difference between inline assembly and

00:15:12,740 --> 00:15:17,990
assembler files so for assembler files I

00:15:15,320 --> 00:15:19,790
wouldn't even bother trying it for the

00:15:17,990 --> 00:15:21,550
inline assembly I think we we should be

00:15:19,790 --> 00:15:23,540
fairly close to being able to assembly

00:15:21,550 --> 00:15:28,630
assemble every single file we have in

00:15:23,540 --> 00:15:28,630
the kernel for the for x86 and arm 64

00:15:34,540 --> 00:15:40,730
so for the linker specifically as far as

00:15:39,410 --> 00:15:42,680
you know the only architecture people

00:15:40,730 --> 00:15:45,709
have actually actively tried it on as a

00:15:42,680 --> 00:15:49,250
art 64 and frankly that was because I

00:15:45,709 --> 00:15:52,519
wanted to get the kernel linking with

00:15:49,250 --> 00:15:54,010
lld so I could have our lld folks use it

00:15:52,519 --> 00:15:57,250
as a test case

00:15:54,010 --> 00:16:00,589
please don't ship it in production I

00:15:57,250 --> 00:16:02,510
would you know I'm hopeful LD will make

00:16:00,589 --> 00:16:04,490
a lot of progress and we have

00:16:02,510 --> 00:16:07,279
experimental II booted it on on dev

00:16:04,490 --> 00:16:08,930
boards but me and Nick having booted on

00:16:07,279 --> 00:16:10,490
a dev board on a desk does not mean you

00:16:08,930 --> 00:16:12,170
should be using it it means if your

00:16:10,490 --> 00:16:14,060
interest in developing LD this is a very

00:16:12,170 --> 00:16:15,889
good time to like you should throw the

00:16:14,060 --> 00:16:23,480
Linux kernel at LD and see what happens

00:16:15,889 --> 00:16:26,480
so the other thing that been on my mind

00:16:23,480 --> 00:16:29,839
a bit was plugins so the kernels

00:16:26,480 --> 00:16:31,190
starting to use GCC plug-ins for bunch

00:16:29,839 --> 00:16:35,410
of things especially sort of

00:16:31,190 --> 00:16:38,660
security-related glinting related stuff

00:16:35,410 --> 00:16:42,529
there's anybody thought about working on

00:16:38,660 --> 00:16:47,560
that how to handle that for clang suit

00:16:42,529 --> 00:16:47,560
builds case

00:16:57,460 --> 00:17:03,290
check check and I can speak to that

00:17:00,830 --> 00:17:07,040
right now no one's really working on it

00:17:03,290 --> 00:17:10,550
yet because check we haven't had we

00:17:07,040 --> 00:17:13,130
haven't had sort of a here's LLVM and

00:17:10,550 --> 00:17:15,470
clang here's your kernel now it builds

00:17:13,130 --> 00:17:18,199
fine yeah like why even bother

00:17:15,470 --> 00:17:21,800
yeah it's a bit premature yep the the

00:17:18,199 --> 00:17:24,199
the the time spent by people who

00:17:21,800 --> 00:17:26,120
actually know clanging LVM better

00:17:24,199 --> 00:17:29,960
focused on actually making it work at

00:17:26,120 --> 00:17:31,160
all I have a question on regarding to

00:17:29,960 --> 00:17:33,230
performance is there any difference

00:17:31,160 --> 00:17:35,180
between building in the kernel with

00:17:33,230 --> 00:17:41,690
clang and building with the traditional

00:17:35,180 --> 00:17:45,020
GCC probably yes do you mean build time

00:17:41,690 --> 00:17:46,850
to build the curtain trunk so at runtime

00:17:45,020 --> 00:17:49,520
there's a number of optimizations that

00:17:46,850 --> 00:17:52,310
we cannot do with clang that's a whole

00:17:49,520 --> 00:17:57,040
Assam duty problem that's one of them

00:17:52,310 --> 00:17:57,040
that's example

00:18:03,380 --> 00:18:11,420
it's always good to measure your configs

00:18:05,600 --> 00:18:14,060
I would say Azzam goto can give you

00:18:11,420 --> 00:18:15,680
performance wins in specific micro

00:18:14,060 --> 00:18:17,450
benchmarks that ingo have pointed out to

00:18:15,680 --> 00:18:20,300
us and that has been very helpful for us

00:18:17,450 --> 00:18:22,370
internally to take these numbers and say

00:18:20,300 --> 00:18:23,990
like here's concrete evidence that we

00:18:22,370 --> 00:18:26,270
can get a X percent performance

00:18:23,990 --> 00:18:28,610
improvement or not if if this is

00:18:26,270 --> 00:18:30,050
implemented in the compiler right that's

00:18:28,610 --> 00:18:32,450
something that's extremely powerful to

00:18:30,050 --> 00:18:35,120
present as an argument to to anyone on a

00:18:32,450 --> 00:18:37,130
tool chain side the other part of that

00:18:35,120 --> 00:18:40,130
which I just checked my email and saw

00:18:37,130 --> 00:18:41,870
tons of work on this right now is the

00:18:40,130 --> 00:18:44,540
kernel makes use of a compiler built in

00:18:41,870 --> 00:18:47,570
called built-in constant P that is used

00:18:44,540 --> 00:18:49,550
for evaluating like an drives me a lot

00:18:47,570 --> 00:18:52,610
of C++ is constant expert kind of thing

00:18:49,550 --> 00:18:55,220
is my understanding of it there are some

00:18:52,610 --> 00:18:58,220
edge cases where clang differs from GCC

00:18:55,220 --> 00:19:01,550
in implementation details which is legal

00:18:58,220 --> 00:19:04,070
because it's a compiler built in but if

00:19:01,550 --> 00:19:06,110
you don't optimize these away at compile

00:19:04,070 --> 00:19:11,840
time the runtime penalty is noticeable

00:19:06,110 --> 00:19:13,130
so we we had three four I've lost track

00:19:11,840 --> 00:19:17,540
I think there's between four and five

00:19:13,130 --> 00:19:19,250
patches to match GCC in its entirety

00:19:17,540 --> 00:19:20,930
which is not super fun because this is

00:19:19,250 --> 00:19:25,100
like bug for bug compatibility with

00:19:20,930 --> 00:19:27,260
another compiler now but the main the

00:19:25,100 --> 00:19:29,210
main parts have landed and the last two

00:19:27,260 --> 00:19:30,590
patches are outstanding and like

00:19:29,210 --> 00:19:31,880
someone's working on them today actually

00:19:30,590 --> 00:19:33,110
I was gonna give a talk with them

00:19:31,880 --> 00:19:35,060
they're supposed to be here and they

00:19:33,110 --> 00:19:37,420
waited too long to buy a ticket so he's

00:19:35,060 --> 00:19:39,640
back at HQ working on on this right now

00:19:37,420 --> 00:19:42,050
part of the problem with that particular

00:19:39,640 --> 00:19:44,150
thing is is because ----builtin constant

00:19:42,050 --> 00:19:45,920
P is being used incorrectly in the

00:19:44,150 --> 00:19:47,360
kernel building constant P is intended

00:19:45,920 --> 00:19:48,710
to be used for the pointers and the

00:19:47,360 --> 00:19:50,570
problem is this being used primarily to

00:19:48,710 --> 00:19:52,730
look at integers in the Linux kernel so

00:19:50,570 --> 00:19:54,260
one of the issues we have right now is

00:19:52,730 --> 00:19:55,820
exactly that it's a bug for bug

00:19:54,260 --> 00:19:57,470
compatibility the fact is we were

00:19:55,820 --> 00:19:59,030
misusing a tool the way it was

00:19:57,470 --> 00:20:00,680
originally intended to be used does it

00:19:59,030 --> 00:20:02,960
work in GCC absolutely

00:20:00,680 --> 00:20:04,490
but the problem unfortunately is is that

00:20:02,960 --> 00:20:05,480
people are doing something that happens

00:20:04,490 --> 00:20:08,120
to work not that's something it's

00:20:05,480 --> 00:20:09,470
supposed to work and the number of the

00:20:08,120 --> 00:20:11,630
things we've had to fight over the years

00:20:09,470 --> 00:20:14,120
where people's answers are fixed your

00:20:11,630 --> 00:20:15,890
compiler are indeed because GCC happens

00:20:14,120 --> 00:20:17,170
to do something that happens to be

00:20:15,890 --> 00:20:18,640
convenient for the kernel is

00:20:17,170 --> 00:20:20,110
at a point in time but was not the way

00:20:18,640 --> 00:20:21,910
it was originally intended it works

00:20:20,110 --> 00:20:22,510
magically not because it was intended

00:20:21,910 --> 00:20:25,900
that way

00:20:22,510 --> 00:20:27,100
right so I'm sure I agree that it's

00:20:25,900 --> 00:20:28,720
valuable it's just that it was never

00:20:27,100 --> 00:20:32,950
intended to be used in that fashion the

00:20:28,720 --> 00:20:34,480
fact that it works is is we're lucky it

00:20:32,950 --> 00:20:37,960
hasn't been that something hasn't

00:20:34,480 --> 00:20:39,820
changed to make it work I I hope one day

00:20:37,960 --> 00:20:41,770
that we'll have more people who

00:20:39,820 --> 00:20:45,010
contributes a Linux work on the C

00:20:41,770 --> 00:20:47,080
standard agreed because I feel like the

00:20:45,010 --> 00:20:49,390
carnal community really pushes the

00:20:47,080 --> 00:20:51,940
limits of what the language can do Paul

00:20:49,390 --> 00:20:54,250
McKenna does exactly this for us and a

00:20:51,940 --> 00:20:56,140
lot of more agreed agreed but in fact

00:20:54,250 --> 00:20:57,370
one of my theories is is when I first

00:20:56,140 --> 00:20:59,950
started all this is a lot of people

00:20:57,370 --> 00:21:01,870
would say well the Linux kernel has its

00:20:59,950 --> 00:21:03,940
own version of C because essentially the

00:21:01,870 --> 00:21:06,040
C standard didn't meet what we needed

00:21:03,940 --> 00:21:07,450
for the kernel and what I found over the

00:21:06,040 --> 00:21:09,220
years when I worked on it is in fact a

00:21:07,450 --> 00:21:10,660
lot of the the differences are things

00:21:09,220 --> 00:21:12,130
that didn't work in fact we're now a

00:21:10,660 --> 00:21:14,110
part of the standard and the reason they

00:21:12,130 --> 00:21:15,700
were was because people that were on the

00:21:14,110 --> 00:21:17,830
Standards Committee in fact were in fact

00:21:15,700 --> 00:21:20,590
developers this was useful this is

00:21:17,830 --> 00:21:23,140
exactly exactly so built-in constant P

00:21:20,590 --> 00:21:25,570
or something like it should it be in the

00:21:23,140 --> 00:21:27,640
in the standard absolutely at the same

00:21:25,570 --> 00:21:31,450
time just by show of hands who here has

00:21:27,640 --> 00:21:32,980
actually read the C standard yet that's

00:21:31,450 --> 00:21:34,510
more hands than I expected

00:21:32,980 --> 00:21:36,580
what's the matter but but the reality is

00:21:34,510 --> 00:21:37,900
is that most people even if they have

00:21:36,580 --> 00:21:40,060
read the standard of course don't know

00:21:37,900 --> 00:21:41,380
what a hundred percent and so the the

00:21:40,060 --> 00:21:42,820
reality is is people will compile

00:21:41,380 --> 00:21:44,680
something and if it works ago oh good

00:21:42,820 --> 00:21:46,150
this is great let's keep going but as

00:21:44,680 --> 00:21:48,850
people who port things on a regular

00:21:46,150 --> 00:21:51,220
basis to new compilers know things break

00:21:48,850 --> 00:21:53,950
as things get you know undefined

00:21:51,220 --> 00:21:55,090
behavior is AD is fixed and so on and so

00:21:53,950 --> 00:21:56,440
forth and this is one of those

00:21:55,090 --> 00:21:59,350
situations where we're using it in a way

00:21:56,440 --> 00:22:01,150
that we shouldn't be you need something

00:21:59,350 --> 00:22:05,770
that does something similar absolutely

00:22:01,150 --> 00:22:07,570
but that this what I mean I mean there's

00:22:05,770 --> 00:22:11,130
a bunch of movies work in LLVM and one

00:22:07,570 --> 00:22:11,130
of the motivations for working on it is

00:22:11,550 --> 00:22:17,800
at least makers more deliberate in our

00:22:16,480 --> 00:22:20,830
decisions with regard to what we're

00:22:17,800 --> 00:22:22,630
doing right at the edges just talk about

00:22:20,830 --> 00:22:23,890
plug-ins really fast and I know I'm out

00:22:22,630 --> 00:22:26,920
of the loop compared to some of other

00:22:23,890 --> 00:22:28,600
people in the front row but a number of

00:22:26,920 --> 00:22:30,040
the plugins that I've seen at least go

00:22:28,600 --> 00:22:31,080
through that are being used on the GCC

00:22:30,040 --> 00:22:33,239
side in fact

00:22:31,080 --> 00:22:35,070
ported from clanks so in fact some of

00:22:33,239 --> 00:22:36,509
those those plugins in fact are

00:22:35,070 --> 00:22:39,929
available whether or not they're plumbed

00:22:36,509 --> 00:22:41,700
in yet of course - it's a you know the

00:22:39,929 --> 00:22:43,379
the point that would we should be

00:22:41,700 --> 00:22:45,570
spending time on other things at the

00:22:43,379 --> 00:22:47,249
moment in case his point that you know

00:22:45,570 --> 00:22:49,679
until we can actually build and run the

00:22:47,249 --> 00:22:54,389
kernel reliably and usefully absolutely

00:22:49,679 --> 00:22:55,980
yeah always changing the Alexander Popov

00:22:54,389 --> 00:22:57,509
who's working on this like I would love

00:22:55,980 --> 00:22:59,549
to have this implemented in Alabama

00:22:57,509 --> 00:23:01,519
if it was implemented in LVM I would get

00:22:59,549 --> 00:23:04,019
it in pixel kernels as soon as possible

00:23:01,519 --> 00:23:06,539
right it's just like we need to get

00:23:04,019 --> 00:23:08,580
resources people developing building

00:23:06,539 --> 00:23:10,139
features on top kind of thing having it

00:23:08,580 --> 00:23:12,419
built in the first place

00:23:10,139 --> 00:23:14,519
just a like a fun anecdote for like a

00:23:12,419 --> 00:23:17,039
recent bug for a bug compatibility thing

00:23:14,519 --> 00:23:20,970
we had to match with GCC was named

00:23:17,039 --> 00:23:23,220
registers oh my god in C code you can

00:23:20,970 --> 00:23:25,889
say you know int foo I would like you to

00:23:23,220 --> 00:23:27,419
always use this register for it and the

00:23:25,889 --> 00:23:30,149
idea is what happens if you're building

00:23:27,419 --> 00:23:31,320
for a 32-bit is a and you say I want a

00:23:30,149 --> 00:23:33,149
64-bit variable

00:23:31,320 --> 00:23:35,340
put it in a register exactly where's the

00:23:33,149 --> 00:23:37,019
other half of that yeah that word go we

00:23:35,340 --> 00:23:38,580
fixed that partially but they would only

00:23:37,019 --> 00:23:40,109
fix it in a very narrow case and yeah

00:23:38,580 --> 00:23:42,600
yeah well we ended up having to match of

00:23:40,109 --> 00:23:48,629
course GCC and I think good next

00:23:42,600 --> 00:23:51,239
register exactly oh that's not fun that

00:23:48,629 --> 00:23:53,460
that's used for system calls if you have

00:23:51,239 --> 00:23:55,440
a 64-bit variable I know 32-bit is a

00:23:53,460 --> 00:23:59,190
record on bugs and GCC implementation of

00:23:55,440 --> 00:24:03,210
that sounds like a fragile thing to bugs

00:23:59,190 --> 00:24:04,499
and on just DCC bugs that legit bugs

00:24:03,210 --> 00:24:07,379
don't just changes the behavior that

00:24:04,499 --> 00:24:08,909
happened to break us know that do you

00:24:07,379 --> 00:24:09,929
know which which version did it change

00:24:08,909 --> 00:24:11,970
in because I want to make sure we're not

00:24:09,929 --> 00:24:14,669
I think 4.5 is fine based on the wrong

00:24:11,970 --> 00:24:17,389
one anything that we can build the

00:24:14,669 --> 00:24:17,389
carnal with is fine

00:24:25,450 --> 00:24:31,240
we've got five minutes left anybody III

00:24:28,810 --> 00:24:32,380
would like I like the first question is

00:24:31,240 --> 00:24:33,730
how bad is it

00:24:32,380 --> 00:24:37,840
I would like to flip it put a positive

00:24:33,730 --> 00:24:39,670
spin on it but what benchmarks would

00:24:37,840 --> 00:24:43,290
people like you know what what makes a

00:24:39,670 --> 00:24:43,290
good tool chain for the Linux kernel

00:24:45,360 --> 00:24:50,290
number one thing I want personally is

00:24:47,980 --> 00:24:52,330
all of the sanitizers that exist in

00:24:50,290 --> 00:24:53,860
clang that kind of feature which I'm

00:24:52,330 --> 00:24:55,090
repeatedly told a much better under

00:24:53,860 --> 00:24:56,920
clang but then I can't build a working

00:24:55,090 --> 00:25:05,530
deaf can fit kernel so I give up at that

00:24:56,920 --> 00:25:09,250
point because I got one now what I'd

00:25:05,530 --> 00:25:11,260
like to see still is a clang build as

00:25:09,250 --> 00:25:13,360
part of the zero day robot or kernel CI

00:25:11,260 --> 00:25:15,190
because one of the the biggest problems

00:25:13,360 --> 00:25:18,580
I certainly had and I suspect is still

00:25:15,190 --> 00:25:19,690
an issue is you unbreak things and then

00:25:18,580 --> 00:25:22,090
they get broken in the next Norwich

00:25:19,690 --> 00:25:24,070
window that's that's why the Lenora

00:25:22,090 --> 00:25:26,170
stuff is the first the first thing we're

00:25:24,070 --> 00:25:28,210
doing is getting multiple compilers or

00:25:26,170 --> 00:25:33,370
internal see I thank you my fellow am

00:25:28,210 --> 00:25:35,050
being fair enough you're pushing for it

00:25:33,370 --> 00:25:35,920
that's great here though so I'll see

00:25:35,050 --> 00:25:38,110
your things

00:25:35,920 --> 00:25:40,270
you know that's we're gonna get that and

00:25:38,110 --> 00:25:42,280
that'll also be useful for you GCC

00:25:40,270 --> 00:25:47,320
versions as well of course no same

00:25:42,280 --> 00:25:48,550
problem yeah yeah that's once you've got

00:25:47,320 --> 00:25:51,550
that there then we're gonna really start

00:25:48,550 --> 00:25:56,020
drilling down on the build and boot

00:25:51,550 --> 00:25:58,510
stuff but we want the idea is that if we

00:25:56,020 --> 00:26:00,510
have the kernel CI automation behind it

00:25:58,510 --> 00:26:03,700
it's gonna make our reports a lot more

00:26:00,510 --> 00:26:04,690
impactful because people know the kernel

00:26:03,700 --> 00:26:06,700
see I ain't going nowhere

00:26:04,690 --> 00:26:08,800
exactly they know that we will continue

00:26:06,700 --> 00:26:11,200
bugging them with the if they if things

00:26:08,800 --> 00:26:14,080
break so I want to follow up you

00:26:11,200 --> 00:26:17,740
mentioned smaller faster I think smaller

00:26:14,080 --> 00:26:20,230
faster write better ok ok let it let's

00:26:17,740 --> 00:26:21,940
put those in like yes those are like

00:26:20,230 --> 00:26:25,510
campaign slogans like smaller faster

00:26:21,940 --> 00:26:27,570
better yeah how do we quantify that like

00:26:25,510 --> 00:26:31,090
put those in more concrete terms for me

00:26:27,570 --> 00:26:32,830
so smaller binary size sure is this

00:26:31,090 --> 00:26:37,540
config optimized for size or config

00:26:32,830 --> 00:26:39,040
optimized for performance yeah but yeah

00:26:37,540 --> 00:26:40,300
but I mean like these are the

00:26:39,040 --> 00:26:42,040
like literally these are questions that

00:26:40,300 --> 00:26:43,540
we get on the mailing list right people

00:26:42,040 --> 00:26:46,450
want to know is it smaller faster better

00:26:43,540 --> 00:26:50,170
right but well by what measure nickk

00:26:46,450 --> 00:26:51,610
nickk the women sure what for

00:26:50,170 --> 00:26:53,620
performance right like what performance

00:26:51,610 --> 00:26:55,660
metrics do people care about right we

00:26:53,620 --> 00:26:57,670
have our set for Android and we're very

00:26:55,660 --> 00:26:59,080
careful with them because SOC vendors

00:26:57,670 --> 00:27:02,110
cheat like they've been caught cheating

00:26:59,080 --> 00:27:03,940
on them right but you know people can

00:27:02,110 --> 00:27:04,900
come up with benchmarks any given

00:27:03,940 --> 00:27:06,850
benchmark people can cherry-pick

00:27:04,900 --> 00:27:08,710
benchmarks and come to us and say hey

00:27:06,850 --> 00:27:11,020
here's a case where you're not you're

00:27:08,710 --> 00:27:12,940
not as performant as the competition and

00:27:11,020 --> 00:27:14,320
I look forward to that because I want

00:27:12,940 --> 00:27:16,390
those because then I can turn around and

00:27:14,320 --> 00:27:18,520
start figuring out like what's going

00:27:16,390 --> 00:27:20,440
wrong where where are we miss compiling

00:27:18,520 --> 00:27:24,870
what sequence was it that caused us to

00:27:20,440 --> 00:27:27,250
to fail this comparison so for me it's

00:27:24,870 --> 00:27:29,290
building the Karner with clang takes a

00:27:27,250 --> 00:27:31,480
lot longer than building with GCC that

00:27:29,290 --> 00:27:34,110
would be the most important thing for me

00:27:31,480 --> 00:27:37,870
yeah because I until 2000 kernels a day

00:27:34,110 --> 00:27:42,930
if clang lets me build 1500 Karnas like

00:27:37,870 --> 00:27:45,070
a future I built builds the kernels I

00:27:42,930 --> 00:27:47,140
when I check something in to get

00:27:45,070 --> 00:27:48,490
upstream I build the kernel to make sure

00:27:47,140 --> 00:27:52,090
I didn't break the build build on each

00:27:48,490 --> 00:27:53,800
commit now and that limits the number of

00:27:52,090 --> 00:27:54,940
patches I can apply while I'm at the

00:27:53,800 --> 00:27:58,240
conference and running off battery

00:27:54,940 --> 00:28:00,130
because you're its lowers what's power

00:27:58,240 --> 00:28:02,290
efficient the the irony there of course

00:28:00,130 --> 00:28:05,950
is that clang used to be faster than GCC

00:28:02,290 --> 00:28:07,300
but then TCC's fixed and fixed that and

00:28:05,950 --> 00:28:09,400
made themselves a lot faster so they've

00:28:07,300 --> 00:28:10,990
they've surpassed the speed of clang and

00:28:09,400 --> 00:28:12,910
clang added new features which made them

00:28:10,990 --> 00:28:13,990
slower exactly so I'm just saying this

00:28:12,910 --> 00:28:15,730
to the other way around that was one of

00:28:13,990 --> 00:28:22,110
my arguments for using clang originally

00:28:15,730 --> 00:28:22,110
it was a faster very good very very good

00:28:22,980 --> 00:28:26,950
we've also got the parallel make in the

00:28:25,480 --> 00:28:28,450
parallel link stuff working then we

00:28:26,950 --> 00:28:31,240
might actually get on bigger machines

00:28:28,450 --> 00:28:33,460
LLVM might actually be faster or even in

00:28:31,240 --> 00:28:37,540
total in total build time even on

00:28:33,460 --> 00:28:38,980
smaller ones I mean multi-core if you

00:28:37,540 --> 00:28:40,360
could have the link state stage on my

00:28:38,980 --> 00:28:46,450
laptop it would make a big difference to

00:28:40,360 --> 00:28:48,460
me behind you just at the point that

00:28:46,450 --> 00:28:51,030
parts independent you can use the linker

00:28:48,460 --> 00:28:55,520
of GCC objects or

00:28:51,030 --> 00:28:55,520
you can now for combination should work

00:28:56,000 --> 00:29:03,300
so we're at a half hour so it's but the

00:29:01,470 --> 00:29:12,270
end of is there any final thing anybody

00:29:03,300 --> 00:29:14,790
wants to bring up nope I think for

00:29:12,270 --> 00:29:16,710
linking I mentioned that our armed 64

00:29:14,790 --> 00:29:20,850
def config is linking and you know top

00:29:16,710 --> 00:29:24,090
of shree build of LOV M L LD I think x86

00:29:20,850 --> 00:29:26,640
def config is about I think there are

00:29:24,090 --> 00:29:29,960
four separate individual issues two

00:29:26,640 --> 00:29:31,980
flags that I think can be removed from

00:29:29,960 --> 00:29:36,690
kernel make files because they're

00:29:31,980 --> 00:29:38,340
redundant or implicit defaults and one

00:29:36,690 --> 00:29:43,470
that's been picked up by the LD

00:29:38,340 --> 00:29:45,660
maintainer and I think one other that

00:29:43,470 --> 00:29:46,950
I'm losing track of but that's the rough

00:29:45,660 --> 00:29:51,180
order of magnitude of how many issues

00:29:46,950 --> 00:29:52,770
there are with LD on x86 for and to be

00:29:51,180 --> 00:29:55,260
more explicit about the earlier question

00:29:52,770 --> 00:29:57,600
if anyone has a benchmark that they

00:29:55,260 --> 00:30:01,860
think is important please let Nick or me

00:29:57,600 --> 00:30:03,870
know so we can run it and I'm super

00:30:01,860 --> 00:30:05,640
happy to answer questions or get in

00:30:03,870 --> 00:30:10,440
touch with people afterwards please come

00:30:05,640 --> 00:30:12,870
find me yeah yeah likewise so we're

00:30:10,440 --> 00:30:17,130
actually over time that so Barrow do you

00:30:12,870 --> 00:30:22,440
want to take over for the user space

00:30:17,130 --> 00:30:24,510
part of it obviously I'm not going to

00:30:22,440 --> 00:30:31,200
kill anyone for continuing to talk about

00:30:24,510 --> 00:30:34,830
kernel issues so essentially we can just

00:30:31,200 --> 00:30:37,100
keep going just moving the focus to user

00:30:34,830 --> 00:30:37,100
land

00:30:40,490 --> 00:30:45,380
looks like there's a whole lot of connor

00:30:42,630 --> 00:30:45,380
developers here

00:31:23,610 --> 00:31:28,470
okay looks like people are done leaving

00:31:25,650 --> 00:31:31,200
and coming in so essentially let's

00:31:28,470 --> 00:31:32,790
continue for what we're talking about in

00:31:31,200 --> 00:31:34,280
the last session just moving the focus

00:31:32,790 --> 00:31:36,390
to userland

00:31:34,280 --> 00:31:39,690
obviously there's a couple of different

00:31:36,390 --> 00:31:41,610
user lands that are interesting we can

00:31:39,690 --> 00:31:43,200
get one out of the way immediately which

00:31:41,610 --> 00:31:46,680
is Android which is already burning

00:31:43,200 --> 00:31:48,600
hundred percent with clangs so no issues

00:31:46,680 --> 00:31:49,800
there but of course if anyone is up for

00:31:48,600 --> 00:31:51,870
a fun project

00:31:49,800 --> 00:31:54,300
you can try getting that to compare mr.

00:31:51,870 --> 00:32:05,940
DC again I try it and it didn't work out

00:31:54,300 --> 00:32:10,260
of the box yes I didn't spend any real

00:32:05,940 --> 00:32:13,670
time looking into him but now I'll send

00:32:10,260 --> 00:32:13,670
you a bill talk next time I try

00:32:26,790 --> 00:32:34,450
yes and obviously it's always good to

00:32:32,350 --> 00:32:37,120
have two different compilers or even

00:32:34,450 --> 00:32:40,510
more modern two compilers to test stuff

00:32:37,120 --> 00:32:43,570
with and I've never been someone who

00:32:40,510 --> 00:32:45,940
hated Jesus your hated clang so I'm all

00:32:43,570 --> 00:32:52,390
in favor of Petrus that make both tool

00:32:45,940 --> 00:32:55,120
chains work I have a question how much

00:32:52,390 --> 00:32:57,130
work do you spend on optimization for

00:32:55,120 --> 00:32:59,260
specific architectures and client for

00:32:57,130 --> 00:33:01,810
example I work in gilepsy for

00:32:59,260 --> 00:33:04,720
optimization for Intel platforms and we

00:33:01,810 --> 00:33:07,210
work for X for a be accessed of eight

00:33:04,720 --> 00:33:08,920
weeks to eight weeks 212 and it's a lot

00:33:07,210 --> 00:33:10,780
of effort so I don't know how much work

00:33:08,920 --> 00:33:15,030
you spend on those kind of things but

00:33:10,780 --> 00:33:15,030
for clang and LVM now in the user space

00:33:29,340 --> 00:33:41,230
to take to the mailing lists ok let's

00:33:37,710 --> 00:33:44,530
talk about the more interesting user

00:33:41,230 --> 00:33:47,110
spaces in decline context one thing that

00:33:44,530 --> 00:33:49,120
is still making a lot of problems is

00:33:47,110 --> 00:33:53,650
trying to get really busy to compile

00:33:49,120 --> 00:34:00,670
with it by any chance is anyone here

00:33:53,650 --> 00:34:02,490
working on that I tried once I quit it

00:34:00,670 --> 00:34:05,050
was a nightmare

00:34:02,490 --> 00:34:07,620
pretty much the same here but maybe we

00:34:05,050 --> 00:34:07,620
can join

00:34:11,890 --> 00:34:16,250
now fortunately with all the other

00:34:14,270 --> 00:34:19,130
Lipsey's things are looking better you

00:34:16,250 --> 00:34:22,310
can compile a system with muscle and you

00:34:19,130 --> 00:34:26,830
see lips evil playing just fine but

00:34:22,310 --> 00:34:26,830
obviously jalebi is still interesting

00:34:34,790 --> 00:34:37,909
[Music]

00:34:43,480 --> 00:34:51,380
there is a there's a branch source where

00:34:48,100 --> 00:34:55,010
official jalebi source code that is

00:34:51,380 --> 00:34:57,380
maintained by Google but they do not

00:34:55,010 --> 00:35:02,810
approach it didn't approach ups us

00:34:57,380 --> 00:35:06,740
upstream yet so they keep pushing

00:35:02,810 --> 00:35:09,680
patches there are recent developments on

00:35:06,740 --> 00:35:12,410
that branch but Google just skip for

00:35:09,680 --> 00:35:16,130
their own and does not seem interested

00:35:12,410 --> 00:35:20,660
in helping us to narrow down what the

00:35:16,130 --> 00:35:23,780
issues are to build with claim so I

00:35:20,660 --> 00:35:28,160
think it's possible but we didn't get

00:35:23,780 --> 00:35:30,200
any information on it which is are they

00:35:28,160 --> 00:35:42,500
which are the issues that clang has

00:35:30,200 --> 00:35:46,150
currently I can check the developer name

00:35:42,500 --> 00:35:46,150
that that is coming to work on this

00:35:51,260 --> 00:35:56,720
in terms of security for example

00:35:53,079 --> 00:36:00,079
recently ingenuity we implemented the

00:35:56,720 --> 00:36:03,410
set control flow enforcement technology

00:36:00,079 --> 00:36:05,869
support is there any plan for building

00:36:03,410 --> 00:36:10,660
that also for their client tool change

00:36:05,869 --> 00:36:10,660
like terms it's against arrow P attacks

00:36:11,079 --> 00:36:21,530
for instance clang has so I implement

00:36:16,849 --> 00:36:25,040
this I'm just speaking about what but so

00:36:21,530 --> 00:36:28,329
there's two things in LLVM that one's

00:36:25,040 --> 00:36:30,920
called CFI is preventing forward jumps

00:36:28,329 --> 00:36:34,339
to indirect targets that were not known

00:36:30,920 --> 00:36:37,339
at compile time and then there's a

00:36:34,339 --> 00:36:39,170
shadow call stack for protecting and and

00:36:37,339 --> 00:36:41,599
I think they're roughly analogous but

00:36:39,170 --> 00:36:43,940
they're they're in there in clang and I

00:36:41,599 --> 00:36:46,630
think they'll be turned on in Android

00:36:43,940 --> 00:36:46,630
pretty soon

00:36:50,900 --> 00:36:57,470
so the next thing that's still causing a

00:36:53,660 --> 00:37:00,319
lot of trouble in building entire user

00:36:57,470 --> 00:37:02,750
space with fangers elf utils there's a

00:37:00,319 --> 00:37:04,430
couple of nested functions in there and

00:37:02,750 --> 00:37:17,390
a couple of variable-length arrays and

00:37:04,430 --> 00:37:19,789
structs no it's a separate thing that

00:37:17,390 --> 00:37:22,210
actually duplicates a lot of things and

00:37:19,789 --> 00:37:22,210
Benitez

00:37:27,130 --> 00:37:31,539
now another package that frequently

00:37:29,559 --> 00:37:33,430
causes problems when trying to build the

00:37:31,539 --> 00:37:38,259
entire here's a space with a mystery lip

00:37:33,430 --> 00:37:41,680
which uses asthma go to so that will

00:37:38,259 --> 00:37:48,609
should be fixed automatically when the

00:37:41,680 --> 00:37:50,950
fixes for the corners in also under dry

00:37:48,609 --> 00:37:54,059
lip side of things desert will call tree

00:37:50,950 --> 00:37:59,049
I ask an ad that doesn't work with

00:37:54,059 --> 00:38:01,660
playing LTO files but obviously the

00:37:59,049 --> 00:38:05,170
workaround for that is to just disable

00:38:01,660 --> 00:38:15,039
FTL for those files but that's another

00:38:05,170 --> 00:38:19,289
thing no tools can subject files and has

00:38:15,039 --> 00:38:19,289
no idea how to handle LLVM byte codes

00:38:22,979 --> 00:38:32,279
right exactly

00:38:34,469 --> 00:38:43,589
it's part of stuff that generates

00:38:39,430 --> 00:38:43,589
similar maps for object introspection

00:38:44,910 --> 00:38:52,089
have you tried the plying with open

00:38:49,119 --> 00:38:54,759
blasts the the dimeric it's a core

00:38:52,089 --> 00:38:57,099
library for many of the new pipe I and

00:38:54,759 --> 00:38:59,049
other stuffs for richer learning subs

00:38:57,099 --> 00:39:00,640
usually when we build or rebuild the

00:38:59,049 --> 00:39:02,890
world every time that you leaves you

00:39:00,640 --> 00:39:05,019
change or gzz change that is one of the

00:39:02,890 --> 00:39:06,849
things that the core of that thing it's

00:39:05,019 --> 00:39:09,519
in Fortran so I don't know if you have

00:39:06,849 --> 00:39:13,650
try building that library open blossom

00:39:09,519 --> 00:39:13,650
with with clang or LLVM tool change

00:39:14,580 --> 00:39:20,040
so anecdotally if it's part of numpy and

00:39:17,280 --> 00:39:22,170
Syfy then it must somehow bill because

00:39:20,040 --> 00:39:24,480
it builds on Macs and Apple has not

00:39:22,170 --> 00:39:26,190
distributed GCC for many years like do

00:39:24,480 --> 00:39:29,190
you see literally just symlinks to clang

00:39:26,190 --> 00:39:30,810
I don't know what kind of hacks they may

00:39:29,190 --> 00:39:38,700
have in place to make that work but it

00:39:30,810 --> 00:39:41,490
does so there's at least flang is a

00:39:38,700 --> 00:39:43,380
front end for lowing Fortran to LOV Mir

00:39:41,490 --> 00:39:45,210
and I think there's discussion at the

00:39:43,380 --> 00:39:47,970
latest alluvium Developers Conference in

00:39:45,210 --> 00:39:50,850
the United States about either rewriting

00:39:47,970 --> 00:39:52,710
it or developing a second one but I

00:39:50,850 --> 00:39:53,760
think for high performance can compute a

00:39:52,710 --> 00:39:57,840
lot of people are interested in in

00:39:53,760 --> 00:40:00,360
Fortran now another thing that I know

00:39:57,840 --> 00:40:02,760
works is compiling the Fortran related

00:40:00,360 --> 00:40:03,990
parts with GCC under C related parts was

00:40:02,760 --> 00:40:06,360
clang and then just linking them

00:40:03,990 --> 00:40:12,750
together in the end binary compatibility

00:40:06,360 --> 00:40:15,620
is good enough if you're really

00:40:12,750 --> 00:40:28,980
desperate there's f2c as well which

00:40:15,620 --> 00:40:32,340
works so the good news is that Jesus

00:40:28,980 --> 00:40:35,880
already did entire list of packages well

00:40:32,340 --> 00:40:39,060
these two have known problems outside of

00:40:35,880 --> 00:40:42,360
some packages that aren't really matter

00:40:39,060 --> 00:40:43,830
of this conference like a few games but

00:40:42,360 --> 00:40:45,930
obviously there's a couple more

00:40:43,830 --> 00:40:49,350
components in the EM that we may want to

00:40:45,930 --> 00:40:54,210
look at like lip C++ a replacement for

00:40:49,350 --> 00:40:56,550
lip STD C++ I think nobody is really

00:40:54,210 --> 00:40:58,890
using that in the Linux world because of

00:40:56,550 --> 00:41:02,310
binary compatibility issues can get

00:40:58,890 --> 00:41:04,620
really bad fun than for example you are

00:41:02,310 --> 00:41:07,140
linking the system libraries of boost or

00:41:04,620 --> 00:41:09,150
qt or something to lip C++ and then you

00:41:07,140 --> 00:41:12,390
try to run a binary only application

00:41:09,150 --> 00:41:15,180
that has been linked to a Lib as TD C++

00:41:12,390 --> 00:41:18,740
on another distribution obviously that's

00:41:15,180 --> 00:41:22,140
going to cause cymbal crashes and just

00:41:18,740 --> 00:41:23,690
now with almost certainty a crash on

00:41:22,140 --> 00:41:31,020
startup

00:41:23,690 --> 00:41:33,120
but yeah so Chrome OS seems to be using

00:41:31,020 --> 00:41:37,800
it to the ER which makes sense chrome

00:41:33,120 --> 00:41:39,810
actually fills all the time using its

00:41:37,800 --> 00:41:42,620
internal copy unless you explicitly

00:41:39,810 --> 00:41:42,620
disable it

00:41:47,760 --> 00:41:54,119
is anybody using flying to build GCC and

00:41:52,890 --> 00:41:56,430
or vice versa

00:41:54,119 --> 00:42:02,040
at some point we really need to deal

00:41:56,430 --> 00:42:05,730
with the Thompson attack so the V are

00:42:02,040 --> 00:42:09,570
actually building clang with GCC all the

00:42:05,730 --> 00:42:11,490
time and the other direction is

00:42:09,570 --> 00:42:12,990
something that I've actually tried to do

00:42:11,490 --> 00:42:16,350
but it didn't work immediately and I

00:42:12,990 --> 00:42:20,070
didn't have to time to fix it so that's

00:42:16,350 --> 00:42:22,220
another thing to look into but Jesus he

00:42:20,070 --> 00:42:24,150
tends to use a couple of constructs that

00:42:22,220 --> 00:42:31,910
aren't really friendly to other

00:42:24,150 --> 00:42:31,910
compilers on its own sauce yeah

00:42:48,070 --> 00:42:53,350
how is Clank working without FTO since

00:42:51,550 --> 00:42:57,520
outer vo is a technology that came up

00:42:53,350 --> 00:42:59,080
from Google it works fine in GCC it came

00:42:57,520 --> 00:43:00,760
up with good performance optimization at

00:42:59,080 --> 00:43:02,950
some point but I don't know it's like

00:43:00,760 --> 00:43:08,800
super special with superpowers inclined

00:43:02,950 --> 00:43:11,290
or lbm so so my understanding Auto FTO

00:43:08,800 --> 00:43:12,730
is a way of doing lower someone correct

00:43:11,290 --> 00:43:15,040
me if I'm wrong my understanding of auto

00:43:12,730 --> 00:43:18,450
FTO is a way of doing lower overhead

00:43:15,040 --> 00:43:21,010
sampling based profiling as opposed to

00:43:18,450 --> 00:43:22,660
instrumenting a binary which potentially

00:43:21,010 --> 00:43:25,630
can change the performance

00:43:22,660 --> 00:43:27,790
characteristics so on Intel this

00:43:25,630 --> 00:43:29,950
requires hardware support for the auto

00:43:27,790 --> 00:43:32,410
FDL part is using the same place so on

00:43:29,950 --> 00:43:35,650
x86 we make use of last branch records

00:43:32,410 --> 00:43:39,640
LB ours are recently the feature is

00:43:35,650 --> 00:43:41,380
called e TM is my understanding and I

00:43:39,640 --> 00:43:45,460
believe my understanding is that there's

00:43:41,380 --> 00:43:46,870
some kernel work like that is required

00:43:45,460 --> 00:43:53,790
to hook that up to expose that up

00:43:46,870 --> 00:43:57,010
through user space the coresight stuff

00:43:53,790 --> 00:44:01,540
including e TM is that's all upstream

00:43:57,010 --> 00:44:03,070
there's some there's only one major

00:44:01,540 --> 00:44:04,900
framework feature outstanding but it's

00:44:03,070 --> 00:44:06,850
all perfectly usable especially if

00:44:04,900 --> 00:44:09,300
you're running in full system mode so

00:44:06,850 --> 00:44:12,570
you can do there's people working on

00:44:09,300 --> 00:44:17,530
using auto after you with that already

00:44:12,570 --> 00:44:22,240
and I think we're we're interested in

00:44:17,530 --> 00:44:25,450
using it on arm platforms for various

00:44:22,240 --> 00:44:27,010
devices I think one of the things that's

00:44:25,450 --> 00:44:27,280
tricky then is once you have that in

00:44:27,010 --> 00:44:29,770
place

00:44:27,280 --> 00:44:32,290
anything that relies on sampling can be

00:44:29,770 --> 00:44:33,670
a double-edged sword because if you're

00:44:32,290 --> 00:44:35,620
not measuring something and you don't

00:44:33,670 --> 00:44:39,510
have profiles for it right you might

00:44:35,620 --> 00:44:39,510
make the wrong call optimization call

00:44:43,800 --> 00:44:51,300
okay then another component of em that

00:44:48,620 --> 00:44:53,100
countly probably nobody is really using

00:44:51,300 --> 00:44:55,380
but it could be interesting is compiler

00:44:53,100 --> 00:44:58,920
RT which essentially replaces slippery

00:44:55,380 --> 00:45:01,020
CC it's kind of similar to the lip C++

00:44:58,920 --> 00:45:03,060
situation most people just aren't using

00:45:01,020 --> 00:45:06,720
it because they fear compatibility

00:45:03,060 --> 00:45:08,580
issues but in latest versions compiler

00:45:06,720 --> 00:45:11,760
RT exports a couple of symbols that

00:45:08,580 --> 00:45:15,240
aren't indeed GCC and clang can generate

00:45:11,760 --> 00:45:17,130
those and actually probably generates

00:45:15,240 --> 00:45:20,990
more perform code for eV and it's using

00:45:17,130 --> 00:45:34,320
compiler T instead of GCC

00:45:20,990 --> 00:45:36,870
so anyone working on that so some of my

00:45:34,320 --> 00:45:39,930
teammates on Android LLVM side are

00:45:36,870 --> 00:45:42,000
working in ship Lib compiler RT the

00:45:39,930 --> 00:45:44,700
alternative is Lib GCC is a lot of like

00:45:42,000 --> 00:45:47,280
your built-ins and various parts of the

00:45:44,700 --> 00:45:49,530
runtime that aren't part of the the Lib

00:45:47,280 --> 00:45:51,920
C runtime and I think one of the issues

00:45:49,530 --> 00:45:55,620
that we're running into has to do with

00:45:51,920 --> 00:45:57,680
symbols being Reax ported from Lib GCC

00:45:55,620 --> 00:46:01,020
from Lib em that were intentionally

00:45:57,680 --> 00:46:03,120
exported but happened to be as my

00:46:01,020 --> 00:46:05,160
understanding of the problem so tracking

00:46:03,120 --> 00:46:06,570
some of those down as that is the

00:46:05,160 --> 00:46:09,830
current thing but we hope to have that

00:46:06,570 --> 00:46:09,830
soon at least on on Android

00:46:16,880 --> 00:46:23,360
okay then next thing that is also coming

00:46:20,360 --> 00:46:26,120
up as lld I've actually tried building

00:46:23,360 --> 00:46:28,280
an entire system using LED Esther system

00:46:26,120 --> 00:46:31,280
blinker you're getting rid of the BFD

00:46:28,280 --> 00:46:34,040
and gold but that's somewhat problematic

00:46:31,280 --> 00:46:37,040
because of compatibility between the

00:46:34,040 --> 00:46:39,200
linker script so quite a few tools that

00:46:37,040 --> 00:46:42,500
you'd find on a usual system use custom

00:46:39,200 --> 00:46:47,690
linker scripts and aren't compatible as

00:46:42,500 --> 00:46:49,520
for what Elodie can handle but other

00:46:47,690 --> 00:46:53,480
than that is starting to look good yeah

00:46:49,520 --> 00:46:57,440
it's can compile even complex libraries

00:46:53,480 --> 00:47:01,360
like QT and then link stuff to it anyone

00:46:57,440 --> 00:47:01,360
working on those problems

00:47:05,750 --> 00:47:10,430
not working with a mower can find the

00:47:07,790 --> 00:47:12,470
patches take a look at the FreeBSD ports

00:47:10,430 --> 00:47:15,530
tree like Terry switch to LOD so

00:47:12,470 --> 00:47:19,780
anything is a patch or at least has to

00:47:15,530 --> 00:47:19,780
use PFD is marked there

00:47:30,740 --> 00:47:36,440
okay looks like we got pretty much

00:47:33,350 --> 00:47:39,100
everything covered does anyone have any

00:47:36,440 --> 00:47:39,100
other topics

00:47:48,240 --> 00:47:51,720
I've been dealing with this with for

00:47:50,290 --> 00:47:55,330
three years

00:47:51,720 --> 00:47:57,550
how often do you release clunk for

00:47:55,330 --> 00:47:59,920
example and you see we're used to every

00:47:57,550 --> 00:48:01,390
April May we have to reveal the world in

00:47:59,920 --> 00:48:03,970
the operating system but incline how

00:48:01,390 --> 00:48:05,740
often is your release if I move for

00:48:03,970 --> 00:48:08,200
example my entire operating system to be

00:48:05,740 --> 00:48:09,910
built with clang in what is the season

00:48:08,200 --> 00:48:12,810
of the year of the faun of rebuilding

00:48:09,910 --> 00:48:12,810
and stuff and so on

00:48:14,040 --> 00:48:21,040
it seems to be on roughly as six months

00:48:18,430 --> 00:48:25,870
release cycle but I've seen divergences

00:48:21,040 --> 00:48:30,280
in both directions so I guess you can

00:48:25,870 --> 00:48:37,720
assumes six months and then adjusted a

00:48:30,280 --> 00:48:38,080
little now so one thing that frowned

00:48:37,720 --> 00:48:40,570
upon

00:48:38,080 --> 00:48:43,270
on the GCC side of things but actually

00:48:40,570 --> 00:48:45,700
if I can't bike line people know is just

00:48:43,270 --> 00:48:49,560
using a snapshot instead of a released

00:48:45,700 --> 00:48:51,730
version there's a lot of users of

00:48:49,560 --> 00:48:54,040
stabilized snapshots that aren't based

00:48:51,730 --> 00:48:57,010
on an official release version in the

00:48:54,040 --> 00:48:59,790
clang world by the GCC people would tell

00:48:57,010 --> 00:48:59,790
you not to do that

00:49:12,800 --> 00:49:22,620
thanks for tens well we're about five

00:49:20,310 --> 00:49:24,290
minutes after the starting time but I

00:49:22,620 --> 00:49:27,420
thought we should probably get started

00:49:24,290 --> 00:49:35,010
this is titled as a Boff how many of you

00:49:27,420 --> 00:49:36,810
have heard of Gen Z Wow well I wanted to

00:49:35,010 --> 00:49:39,780
I wanted to give a brief overview of

00:49:36,810 --> 00:49:41,640
what gen Z was just to kind of get

00:49:39,780 --> 00:49:45,030
people to understand what how we think

00:49:41,640 --> 00:49:48,600
of it in our role as Linux developers

00:49:45,030 --> 00:49:51,450
and then I want to show kind of where

00:49:48,600 --> 00:49:53,910
we're starting to think about how gen Z

00:49:51,450 --> 00:49:55,590
and Linux should work together there are

00:49:53,910 --> 00:49:57,120
a lot of things you can do with gen Z

00:49:55,590 --> 00:50:00,030
we're trying to make sure you can do all

00:49:57,120 --> 00:50:01,890
of them I'm here with my with actually

00:50:00,030 --> 00:50:06,060
the the core Gen Z development team at

00:50:01,890 --> 00:50:07,800
HPE Betty doll and Jim hull if you guys

00:50:06,060 --> 00:50:10,350
have questions comments

00:50:07,800 --> 00:50:12,810
it's supposed to be bop like in informal

00:50:10,350 --> 00:50:14,550
and so if you want me to stop presenting

00:50:12,810 --> 00:50:16,920
and just chat about stuff for a long

00:50:14,550 --> 00:50:18,420
time that's perfectly fine but I thought

00:50:16,920 --> 00:50:20,880
if we had if we had some material that

00:50:18,420 --> 00:50:22,590
to kind of set the set the stage people

00:50:20,880 --> 00:50:25,110
kind of get an idea of what we what we

00:50:22,590 --> 00:50:27,660
expect to be what we're thinking about

00:50:25,110 --> 00:50:30,630
and how we're kind of getting this this

00:50:27,660 --> 00:50:33,060
effort kind of rolling so first off Gen

00:50:30,630 --> 00:50:38,160
Z is a system interconnect right it's a

00:50:33,060 --> 00:50:40,830
systemic connect like PCI UPI or or

00:50:38,160 --> 00:50:43,890
InfiniBand or Ethernet it glues parts of

00:50:40,830 --> 00:50:45,630
the computer together Gen Z is designed

00:50:43,890 --> 00:50:47,490
to scale from you know point-to-point

00:50:45,630 --> 00:50:49,830
links between a processor and memory all

00:50:47,490 --> 00:50:51,900
the way out to a data center so it's

00:50:49,830 --> 00:50:58,260
kind of a big spec how BIG's the current

00:50:51,900 --> 00:51:01,680
spec Jim okay the core spec I remember

00:50:58,260 --> 00:51:06,630
at a kernel summit many years ago Lina's

00:51:01,680 --> 00:51:09,030
complained that the UEFI spec was was so

00:51:06,630 --> 00:51:10,830
long and he said that he was unwilling

00:51:09,030 --> 00:51:14,190
to read any spec that was longer than

00:51:10,830 --> 00:51:17,070
the king james version of the bible so i

00:51:14,190 --> 00:51:18,200
think gen Z is approaching that there's

00:51:17,070 --> 00:51:19,800
a lot of stuff in there that

00:51:18,200 --> 00:51:22,109
unfortunately it's got kind of

00:51:19,800 --> 00:51:23,579
everything in it because it wants

00:51:22,109 --> 00:51:25,499
to do a lot of different stuff and a lot

00:51:23,579 --> 00:51:27,180
of functionality and I think it's gonna

00:51:25,499 --> 00:51:29,819
take us a couple years to kind of get an

00:51:27,180 --> 00:51:32,009
idea of what parts of it are useful in

00:51:29,819 --> 00:51:34,799
what kinds of environments because it

00:51:32,009 --> 00:51:36,150
can do so many different things it's

00:51:34,799 --> 00:51:37,769
designed to be switched or

00:51:36,150 --> 00:51:39,539
point-to-point it's supposed to be a

00:51:37,769 --> 00:51:41,819
memory semantic fabric that means that

00:51:39,539 --> 00:51:45,059
you can actually do byte level loads

00:51:41,819 --> 00:51:47,099
store access over this fabric so like PC

00:51:45,059 --> 00:51:49,499
I can write PC is a memory semantic bus

00:51:47,099 --> 00:51:50,670
you can do loads and stores over the PCI

00:51:49,499 --> 00:51:52,680
bus

00:51:50,670 --> 00:51:54,299
InfiniBand is not a memory semantic

00:51:52,680 --> 00:51:56,130
fabric right you can't do loads and

00:51:54,299 --> 00:51:58,410
stores addressable loads and stores over

00:51:56,130 --> 00:52:00,690
InfiniBand except using some of the verb

00:51:58,410 --> 00:52:02,789
stuff which is more of a DMA operation

00:52:00,690 --> 00:52:05,730
so InfiniBand is kind of midway between

00:52:02,789 --> 00:52:07,950
Ethernet and PCI in terms of what its

00:52:05,730 --> 00:52:09,660
capabilities are and Gen Z is all the

00:52:07,950 --> 00:52:12,690
way over in the yes we can actually do

00:52:09,660 --> 00:52:15,269
we can map a remote machines memory into

00:52:12,690 --> 00:52:18,119
my process and do load and store access

00:52:15,269 --> 00:52:21,239
from my act from my application too much

00:52:18,119 --> 00:52:23,249
to memory located in a remote machine if

00:52:21,239 --> 00:52:24,900
you remember about the the machine

00:52:23,249 --> 00:52:27,839
program we talked about years ago a

00:52:24,900 --> 00:52:30,239
couple years ago the fabric in that was

00:52:27,839 --> 00:52:31,769
a prototype of some of this stuff and so

00:52:30,239 --> 00:52:33,569
a lot of the capabilities we were

00:52:31,769 --> 00:52:35,519
talking about in the machine are enabled

00:52:33,569 --> 00:52:38,640
by this particular memory somatic fabric

00:52:35,519 --> 00:52:40,499
and so when you build systems using Gen

00:52:38,640 --> 00:52:43,079
Z you can get a lot of the functionality

00:52:40,499 --> 00:52:45,779
that we're talking about in a in a

00:52:43,079 --> 00:52:48,210
heterogeneous multi system image

00:52:45,779 --> 00:52:49,739
massively shared memory machine we're

00:52:48,210 --> 00:52:52,559
building systems like this right now

00:52:49,739 --> 00:52:54,239
under contract to the government and

00:52:52,559 --> 00:52:56,970
we're building we're looking at building

00:52:54,239 --> 00:53:00,420
some of these things commercially so Gen

00:52:56,970 --> 00:53:02,430
Z is unlike PCI gens II is packet

00:53:00,420 --> 00:53:04,349
switched and that means you take chunks

00:53:02,430 --> 00:53:06,509
of data put it in a packet and throw it

00:53:04,349 --> 00:53:08,940
into the fabric and the fabric routes it

00:53:06,509 --> 00:53:11,519
to its destination and then a reply

00:53:08,940 --> 00:53:13,410
packet may may wander back along the

00:53:11,519 --> 00:53:15,420
same routing that means there's routing

00:53:13,410 --> 00:53:16,799
and address ability and subnetting and

00:53:15,420 --> 00:53:18,960
all those kinds of questions

00:53:16,799 --> 00:53:20,640
there's multipath questions and there's

00:53:18,960 --> 00:53:22,049
what do what you do when you lose

00:53:20,640 --> 00:53:24,539
packets and that kind of stuff we're

00:53:22,049 --> 00:53:27,210
talking about congestion control and so

00:53:24,539 --> 00:53:31,049
you talk about you talk about something

00:53:27,210 --> 00:53:33,569
like PCI where it's pretty simple in a

00:53:31,049 --> 00:53:35,039
lot of ways because PCI is a simple tree

00:53:33,569 --> 00:53:35,530
right you got a you got a hub and you've

00:53:35,039 --> 00:53:37,990
got

00:53:35,530 --> 00:53:39,400
this tree tree structure which which

00:53:37,990 --> 00:53:41,770
simplifies a lot of the routing

00:53:39,400 --> 00:53:43,570
questions or you look at USB which is

00:53:41,770 --> 00:53:45,640
really is a treats you know as a single

00:53:43,570 --> 00:53:48,790
single hosted thing which controls all

00:53:45,640 --> 00:53:50,410
the routing in the system those are very

00:53:48,790 --> 00:53:53,890
simple and in Jen's II we're talking

00:53:50,410 --> 00:53:55,540
about having a header a fabric that

00:53:53,890 --> 00:53:58,360
doesn't really have any particular

00:53:55,540 --> 00:54:00,550
controller or particular route of the

00:53:58,360 --> 00:54:02,530
tree and so you can kind of connect

00:54:00,550 --> 00:54:04,810
things however you like and then in fact

00:54:02,530 --> 00:54:07,600
on top of the physical connections you

00:54:04,810 --> 00:54:10,450
can provide a software-defined routing

00:54:07,600 --> 00:54:12,280
topology which may not exactly match the

00:54:10,450 --> 00:54:14,800
physical link so it's like if you have

00:54:12,280 --> 00:54:16,660
two routes to a host to the fabric you

00:54:14,800 --> 00:54:18,580
may decide for performance reasons or

00:54:16,660 --> 00:54:20,530
congestion reasons or whatever that you

00:54:18,580 --> 00:54:21,670
only want to allow the system to use one

00:54:20,530 --> 00:54:26,080
of those and you can actually configure

00:54:21,670 --> 00:54:27,580
that all on software it's crazy or you

00:54:26,080 --> 00:54:29,050
can actually set the both up and then

00:54:27,580 --> 00:54:31,120
the the switch will alternate between

00:54:29,050 --> 00:54:34,480
the two routes so you can get some

00:54:31,120 --> 00:54:35,710
failure failure recovery like that you

00:54:34,480 --> 00:54:37,900
can plug almost anything into it

00:54:35,710 --> 00:54:42,360
anything from a processor to a memory

00:54:37,900 --> 00:54:45,340
board to to another computer to devices

00:54:42,360 --> 00:54:51,070
GPUs whatever you want it's a pretty

00:54:45,340 --> 00:54:52,630
general-purpose device so here's the

00:54:51,070 --> 00:54:54,430
question for this group of course where

00:54:52,630 --> 00:54:57,370
does it fit into Linux right the

00:54:54,430 --> 00:55:01,720
question is Gen Z is an interesting new

00:54:57,370 --> 00:55:03,130
fabric how is it the same and how is it

00:55:01,720 --> 00:55:05,110
different from stuff that's already in

00:55:03,130 --> 00:55:06,970
Linux so when looking at evaluating an

00:55:05,110 --> 00:55:09,640
architecture for bringing gen Z into

00:55:06,970 --> 00:55:11,230
Linux how do we look how do we evaluate

00:55:09,640 --> 00:55:13,480
that compared to the current software

00:55:11,230 --> 00:55:15,130
because one of the one of the simple

00:55:13,480 --> 00:55:18,010
rules of software is you try not to

00:55:15,130 --> 00:55:19,840
change too much all at once and you try

00:55:18,010 --> 00:55:21,820
not to make and you try to take existing

00:55:19,840 --> 00:55:23,830
knowledge from similar technologies and

00:55:21,820 --> 00:55:26,110
adapt them in similar ways to a new

00:55:23,830 --> 00:55:28,000
technology so that people understand how

00:55:26,110 --> 00:55:30,790
it works we can learn from past mistakes

00:55:28,000 --> 00:55:33,120
or we can repeat past mistakes both of

00:55:30,790 --> 00:55:33,120
those are true

00:55:36,049 --> 00:55:44,910
exactly by that key thing that it does

00:55:42,299 --> 00:55:48,180
is it allows machine room-scale

00:55:44,910 --> 00:55:50,190
load and store access nothing else does

00:55:48,180 --> 00:55:52,470
this you can literally have an entire

00:55:50,190 --> 00:55:54,809
machine move of computers on a single

00:55:52,470 --> 00:55:56,309
gens II fabric and I can execute a load

00:55:54,809 --> 00:55:59,579
instruction and user space from a

00:55:56,309 --> 00:56:03,990
process on this machine pneumonic does

00:55:59,579 --> 00:56:09,089
not scale yes this scales to machine

00:56:03,990 --> 00:56:10,980
room level skills it is it is the only

00:56:09,089 --> 00:56:12,839
difference between there's a couple of

00:56:10,980 --> 00:56:14,849
differences because we also sell new a

00:56:12,839 --> 00:56:19,260
link right yeah new only cuz at HP

00:56:14,849 --> 00:56:21,630
product right so but so I understand

00:56:19,260 --> 00:56:23,460
numeral II quite well now one of the

00:56:21,630 --> 00:56:24,990
things that Numa link one of the

00:56:23,460 --> 00:56:27,089
limitations of Numa link is that it's

00:56:24,990 --> 00:56:29,369
tied to the particular interconnect of

00:56:27,089 --> 00:56:31,380
the Numa link technology that we have

00:56:29,369 --> 00:56:33,480
today it's a proprietary technology it's

00:56:31,380 --> 00:56:36,359
not a consortium standard that means the

00:56:33,480 --> 00:56:38,099
only people that sell Numa link are HPE

00:56:36,359 --> 00:56:41,030
you can't purchase new more linked

00:56:38,099 --> 00:56:41,030
devices from anybody

00:56:46,890 --> 00:56:52,380
so what oh we actually have a microphone

00:56:49,680 --> 00:56:55,349
here yeah yeah so let me describe how

00:56:52,380 --> 00:56:59,040
it's different from Numa link so Numa

00:56:55,349 --> 00:57:01,290
link is a new malinka connects the UPI

00:56:59,040 --> 00:57:04,680
or qpi links on intel processors

00:57:01,290 --> 00:57:07,140
together that's what it does today which

00:57:04,680 --> 00:57:09,809
which means you have the limitations of

00:57:07,140 --> 00:57:11,280
QPR UPI so you're not directly connected

00:57:09,809 --> 00:57:13,170
to the processor you have another level

00:57:11,280 --> 00:57:14,730
of indirection um that means you have

00:57:13,170 --> 00:57:17,420
additional latency in the in the

00:57:14,730 --> 00:57:19,770
transactions Numa link is also currently

00:57:17,420 --> 00:57:22,109
physically defined by a copper only

00:57:19,770 --> 00:57:24,359
media which means that the connection

00:57:22,109 --> 00:57:26,369
topology is very limited NUMA link

00:57:24,359 --> 00:57:28,079
currently scales to two racks that is it

00:57:26,369 --> 00:57:31,589
you can't go beyond two racks or Numa

00:57:28,079 --> 00:57:32,520
like the wire you can't make the wires

00:57:31,589 --> 00:57:35,250
any longer

00:57:32,520 --> 00:57:38,040
yeah but the signaling doesn't work and

00:57:35,250 --> 00:57:41,040
so Jen Z is defined as both a copper

00:57:38,040 --> 00:57:43,109
standard and an optical standard I mean

00:57:41,040 --> 00:57:44,549
we have we have a low cost optical

00:57:43,109 --> 00:57:47,010
technology that we're working on and

00:57:44,549 --> 00:57:48,990
that lets us get further much greater

00:57:47,010 --> 00:57:51,020
distance new only Kyle

00:57:48,990 --> 00:57:54,330
so not switched rights point-to-point

00:57:51,020 --> 00:57:55,860
kind of semi switched whereas whereas

00:57:54,330 --> 00:57:57,990
Chauncey is softer - finally it's

00:57:55,860 --> 00:58:00,330
routable so I can actually scale to

00:57:57,990 --> 00:58:02,190
multiple levels of switches obviously

00:58:00,330 --> 00:58:05,670
with increasing latency but that's what

00:58:02,190 --> 00:58:07,710
lets me get to bigger scale right Newman

00:58:05,670 --> 00:58:09,720
link is only a memory transport

00:58:07,710 --> 00:58:12,150
technology doesn't define Technica

00:58:09,720 --> 00:58:15,210
transfers for device information it

00:58:12,150 --> 00:58:17,310
doesn't it doesn't give you a general

00:58:15,210 --> 00:58:19,560
packet transport right so it's a very

00:58:17,310 --> 00:58:22,530
limited it's divine it's defined as a

00:58:19,560 --> 00:58:24,570
memory inter cadet right so that's what

00:58:22,530 --> 00:58:30,510
it's for it's to make big Numa systems

00:58:24,570 --> 00:58:31,170
Numa link Jen's Jen's ecosystems company

00:58:30,510 --> 00:58:33,300
that does that

00:58:31,170 --> 00:58:36,540
right so InfiniBand doesn't do load

00:58:33,300 --> 00:58:38,340
store access and finna ban has DMA

00:58:36,540 --> 00:58:41,040
access but it doesn't do direct process

00:58:38,340 --> 00:58:43,080
load store do blog looks was a scale MP

00:58:41,040 --> 00:58:46,050
for example does that what scale MP does

00:58:43,080 --> 00:58:48,960
that yes but but that only by only by

00:58:46,050 --> 00:58:51,000
using DMA to copy data around instead of

00:58:48,960 --> 00:58:52,320
doing direct access so it's different

00:58:51,000 --> 00:58:55,470
capabilities well that's this but is it

00:58:52,320 --> 00:58:57,630
the same or not so it's also not capable

00:58:55,470 --> 00:58:59,609
of doing devices you can't put devices

00:58:57,630 --> 00:59:04,010
on InfiniBand InfiniBand is a coastal

00:58:59,609 --> 00:59:06,590
host interconnect yeah you need this

00:59:04,010 --> 00:59:09,060
yeah absolutely

00:59:06,590 --> 00:59:11,070
you're describing an either/or problem

00:59:09,060 --> 00:59:13,380
here which is already being experienced

00:59:11,070 --> 00:59:14,670
for at least a decade with persistent

00:59:13,380 --> 00:59:17,580
memory yep

00:59:14,670 --> 00:59:21,390
and so my suggestion where does it fit

00:59:17,580 --> 00:59:23,250
in belongs with the originator of the

00:59:21,390 --> 00:59:26,070
idea to make up their mind on what it is

00:59:23,250 --> 00:59:27,359
yep absolutely so that's that's my well

00:59:26,070 --> 00:59:28,859
so James II is that the other

00:59:27,359 --> 00:59:30,510
interesting thing about James II is it's

00:59:28,859 --> 00:59:34,500
a fairly large consortium at this point

00:59:30,510 --> 00:59:36,780
I think sixty members 60-ish large

00:59:34,500 --> 00:59:38,880
corporation members probably most of the

00:59:36,780 --> 00:59:40,590
companies that that you know of in the

00:59:38,880 --> 00:59:43,290
hardware space are members of the James

00:59:40,590 --> 00:59:45,630
II consortium so the hope is that there

00:59:43,290 --> 00:59:47,820
will be enough of a marketplace there

00:59:45,630 --> 00:59:50,369
that will start to see interoperable

00:59:47,820 --> 00:59:52,770
products in the gen Z space that start

00:59:50,369 --> 00:59:55,410
to start to show where the capabilities

00:59:52,770 --> 00:59:57,600
of the system you know me I'm just a

00:59:55,410 --> 01:00:00,510
software engineer I'm I'm you know paid

00:59:57,600 --> 01:00:02,400
to do development of Gen Z drivers and

01:00:00,510 --> 01:00:04,559
Linux and my employers happily pay

01:00:02,400 --> 01:00:05,940
for to do that I have no idea where the

01:00:04,559 --> 01:00:08,819
market is gonna take this thing it's a

01:00:05,940 --> 01:00:11,369
huge spec it does a lot of stuff I think

01:00:08,819 --> 01:00:13,859
you can understand that does it does

01:00:11,369 --> 01:00:16,589
more than anyone existing fabric does

01:00:13,859 --> 01:00:18,299
today I have one more question yeah I

01:00:16,589 --> 01:00:21,210
didn't see it on your slide yet

01:00:18,299 --> 01:00:23,670
what's the coherency story Gen Z doesn't

01:00:21,210 --> 01:00:25,829
have any intrinsic coherency um it is

01:00:23,670 --> 01:00:26,700
possible to layer coherency protocols on

01:00:25,829 --> 01:00:30,510
top of it

01:00:26,700 --> 01:00:38,789
oh so it's both too much and too little

01:00:30,510 --> 01:00:40,410
yes okay yeah yeah but in a

01:00:38,789 --> 01:00:42,059
heterogeneous environment multiple

01:00:40,410 --> 01:00:44,549
system images you can understand why you

01:00:42,059 --> 01:00:46,260
wouldn't want coherence but if you're

01:00:44,549 --> 01:00:47,849
trying to build a large homogeneous

01:00:46,260 --> 01:00:50,730
single system image you can understand

01:00:47,849 --> 01:00:52,349
why you might want to go well I guess if

01:00:50,730 --> 01:00:55,020
I were going at this for the third time

01:00:52,349 --> 01:00:57,569
having copy and then open Kathy it's an

01:00:55,020 --> 01:01:00,329
interesting opportunity to explore how

01:00:57,569 --> 01:01:02,970
you solve this issue of having optional

01:01:00,329 --> 01:01:06,869
coherency yep and how you address the

01:01:02,970 --> 01:01:09,029
issue of maximizing the coherency story

01:01:06,869 --> 01:01:11,010
the difference between Kathy and open

01:01:09,029 --> 01:01:15,690
Kathy is that you can't take advantage

01:01:11,010 --> 01:01:17,730
of proprietary things so leaving it out

01:01:15,690 --> 01:01:19,890
in order to get open Kathy yes that's a

01:01:17,730 --> 01:01:21,329
compromise yep so yeah why are you gonna

01:01:19,890 --> 01:01:23,849
build a brand new thing and include it

01:01:21,329 --> 01:01:26,430
with compromises so I like standard

01:01:23,849 --> 01:01:29,400
standards are awesome yeah and let's

01:01:26,430 --> 01:01:32,190
have just one more that would be awesome

01:01:29,400 --> 01:01:33,690
yeah well or zero board be even better

01:01:32,190 --> 01:01:35,250
right if we could if we had some

01:01:33,690 --> 01:01:35,789
existing system that could do what we

01:01:35,250 --> 01:01:40,289
needed

01:01:35,789 --> 01:01:42,240
well PCIe 4 isn't here yet and when it

01:01:40,289 --> 01:01:45,059
is is great if it had a competitor I

01:01:42,240 --> 01:01:46,079
believe in duopoly x' pci 4 is not

01:01:45,059 --> 01:01:50,039
supposed to do system-to-system

01:01:46,079 --> 01:01:52,619
interconnect equal I actually know the

01:01:50,039 --> 01:01:54,150
author of the editor of the PCI for spec

01:01:52,619 --> 01:01:55,950
right to spent the last weekend with him

01:01:54,150 --> 01:01:57,690
chatting about and we talked about the

01:01:55,950 --> 01:02:00,119
differences between PCI 4 and its

01:01:57,690 --> 01:02:01,559
capabilities and what Gen Z does and it

01:02:00,119 --> 01:02:04,049
was interesting really interesting to

01:02:01,559 --> 01:02:06,299
talk about where PCI is going PCI is

01:02:04,049 --> 01:02:08,760
really trying to get trying to trying to

01:02:06,299 --> 01:02:10,740
get some more scalability into its

01:02:08,760 --> 01:02:12,750
specification by adding repeaters into

01:02:10,740 --> 01:02:15,210
the you know a better definition how the

01:02:12,750 --> 01:02:16,650
repeaters work in PCIe to try to get

01:02:15,210 --> 01:02:19,319
longer bus

01:02:16,650 --> 01:02:20,400
and that's a serious challenge for PCI

01:02:19,319 --> 01:02:23,760
because they're basically having to

01:02:20,400 --> 01:02:25,349
reconstruct the packets every every few

01:02:23,760 --> 01:02:28,079
millimeters it seems like within the

01:02:25,349 --> 01:02:31,500
machine just to get PCI signalling to

01:02:28,079 --> 01:02:37,890
work and that's like ah that's horribly

01:02:31,500 --> 01:02:39,569
tedious exactly exactly

01:02:37,890 --> 01:02:42,029
well and the reason the reason we're

01:02:39,569 --> 01:02:44,970
with the the places where Gen Z is is

01:02:42,029 --> 01:02:48,960
maybe interesting is because it is both

01:02:44,970 --> 01:02:52,500
a packet transport and a memory semantic

01:02:48,960 --> 01:02:55,260
fabric you can you can create a you can

01:02:52,500 --> 01:02:56,700
you could take a single a single like of

01:02:55,260 --> 01:02:59,450
an entire machine when connected with

01:02:56,700 --> 01:03:03,299
Gen Z and you can partition it up into

01:02:59,450 --> 01:03:05,130
into into separate system images with a

01:03:03,299 --> 01:03:07,470
collection of devices and a collection

01:03:05,130 --> 01:03:10,589
of media and a collection of processors

01:03:07,470 --> 01:03:12,839
and and define a machine in software

01:03:10,589 --> 01:03:15,029
right because you have this notion of

01:03:12,839 --> 01:03:17,130
something which can operate either like

01:03:15,029 --> 01:03:19,410
InfiniBand with doing DMA transactions

01:03:17,130 --> 01:03:34,230
or like PCI with doing load and store

01:03:19,410 --> 01:03:37,049
access there isn't any hardware yet the

01:03:34,230 --> 01:03:39,359
the reality is that right today is the

01:03:37,049 --> 01:03:40,950
Phi's that gen Z is using and specified

01:03:39,359 --> 01:03:42,900
for the same files will be used for

01:03:40,950 --> 01:03:45,599
InfiniBand alright so it's gonna be the

01:03:42,900 --> 01:03:47,190
same speed as infinite in but because

01:03:45,599 --> 01:03:49,710
you're allowed to do different kinds of

01:03:47,190 --> 01:03:52,069
transactions over the kinds of the kinds

01:03:49,710 --> 01:03:55,140
of software you can write are different

01:03:52,069 --> 01:03:56,940
right you can talk about defining

01:03:55,140 --> 01:03:59,609
enormous enormous state in memory

01:03:56,940 --> 01:04:02,369
databases and and avoiding avoiding

01:03:59,609 --> 01:04:03,539
avoiding the the verbs construction of

01:04:02,369 --> 01:04:06,210
packets back and forth across the

01:04:03,539 --> 01:04:08,099
network to transfer data at a packet

01:04:06,210 --> 01:04:10,170
level and you can start just doing load

01:04:08,099 --> 01:04:12,270
and store access which is lower latency

01:04:10,170 --> 01:04:13,799
typically because you don't have to get

01:04:12,270 --> 01:04:15,359
into the kernel and transfer packets

01:04:13,799 --> 01:04:17,339
around you're just doing your emitting a

01:04:15,359 --> 01:04:20,339
processor instruction which ends up on

01:04:17,339 --> 01:04:23,010
the fabric so it is it's an interesting

01:04:20,339 --> 01:04:25,890
idea and so I'm not I'm not here to sell

01:04:23,010 --> 01:04:28,349
Gen Z right I want to explain what it is

01:04:25,890 --> 01:04:29,340
and talk about what we're doing to get

01:04:28,349 --> 01:04:31,980
it into the kernel

01:04:29,340 --> 01:04:33,960
because for it to be successful in the

01:04:31,980 --> 01:04:36,450
colonel you we're gonna need to have

01:04:33,960 --> 01:04:39,300
kind of a consensus that yes jamesy

01:04:36,450 --> 01:04:42,920
devices may exist we want them to work

01:04:39,300 --> 01:04:45,330
in the kernel this way okay so I'm not I

01:04:42,920 --> 01:04:47,010
think an arguments about whether it

01:04:45,330 --> 01:04:48,270
should exist that's you know it's a

01:04:47,010 --> 01:04:50,160
marketing problem that's not my

01:04:48,270 --> 01:04:52,250
technical problem it has some

01:04:50,160 --> 01:04:55,740
interesting technical challenges right

01:04:52,250 --> 01:04:57,660
you know crazy new fabric and they're

01:04:55,740 --> 01:04:59,430
just like just like we worked on Itanium

01:04:57,660 --> 01:05:02,190
for 10 years so it has some interesting

01:04:59,430 --> 01:05:04,470
ideas it ended up not being as

01:05:02,190 --> 01:05:08,700
successful as we might have hoped you

01:05:04,470 --> 01:05:11,220
know maybe this what exactly exactly and

01:05:08,700 --> 01:05:13,170
and we are we are building hardware Gen

01:05:11,220 --> 01:05:22,830
Z in it today for sale for a real

01:05:13,170 --> 01:05:23,910
customer so yeah right so that's the

01:05:22,830 --> 01:05:25,800
question how much of the existing

01:05:23,910 --> 01:05:29,190
infrastructure can we can we take

01:05:25,800 --> 01:05:31,710
advantage of it's not PCIe right so we

01:05:29,190 --> 01:05:34,410
can't use we can't make it look like

01:05:31,710 --> 01:05:36,690
PCIe if we want to offer all of its

01:05:34,410 --> 01:05:38,190
capabilities now one of the things that

01:05:36,690 --> 01:05:40,740
the gen Z consortium has been talking

01:05:38,190 --> 01:05:43,230
about is this notion of PCI emulation

01:05:40,740 --> 01:05:45,030
right if you want to bring Gen Z into a

01:05:43,230 --> 01:05:47,160
system and not change the operating

01:05:45,030 --> 01:05:48,810
system at all and just make an existing

01:05:47,160 --> 01:05:51,750
operating system be able to use it as a

01:05:48,810 --> 01:05:54,780
device and media bus you could just make

01:05:51,750 --> 01:05:56,760
it work like PCIe right it's got the

01:05:54,780 --> 01:05:59,310
same kinds of notions and so imagine

01:05:56,760 --> 01:06:03,600
writing an enormous firmware blob that

01:05:59,310 --> 01:06:07,140
sits in your ACPI and you AFI code that

01:06:03,600 --> 01:06:10,100
makes gen Z look just like PCIe right

01:06:07,140 --> 01:06:10,100
imagine doing that

01:06:14,660 --> 01:06:20,730
yeah could I reuse some of that

01:06:17,910 --> 01:06:22,200
infrastructure so absolutely and so

01:06:20,730 --> 01:06:24,840
that's what I'm going to talk about how

01:06:22,200 --> 01:06:27,360
it looks like PCI and USB in particular

01:06:24,840 --> 01:06:29,940
USB is obviously not the same kind of

01:06:27,360 --> 01:06:32,610
performance notion but it has a lot of

01:06:29,940 --> 01:06:35,100
the same kinds of topological notions

01:06:32,610 --> 01:06:37,590
and so it's interesting to compare Gen Z

01:06:35,100 --> 01:06:40,380
and USB for the topological similarity

01:06:37,590 --> 01:06:41,580
and which is which is turn which has

01:06:40,380 --> 01:06:43,380
been useful in our discussions

01:06:41,580 --> 01:06:45,990
internally about how are we going to

01:06:43,380 --> 01:06:47,550
hook this thing up right not in terms

01:06:45,990 --> 01:06:48,960
about how you're gonna use it but how

01:06:47,550 --> 01:06:51,240
are you gonna manage it so you're

01:06:48,960 --> 01:06:53,010
talking about management and and and

01:06:51,240 --> 01:06:55,290
actually use of the fabric as separate

01:06:53,010 --> 01:06:57,240
notions so you talk about a gen C bridge

01:06:55,290 --> 01:07:00,600
device well gen Zee Bridge device takes

01:06:57,240 --> 01:07:02,610
a takes at an end point and connects it

01:07:00,600 --> 01:07:06,360
and connects it into the fabric you know

01:07:02,610 --> 01:07:08,130
it's like a PCIe root complex or a USB

01:07:06,360 --> 01:07:10,320
host controller interface that's what

01:07:08,130 --> 01:07:12,150
that's what a gens eBridge device is so

01:07:10,320 --> 01:07:14,280
when you talk about a gens II switch

01:07:12,150 --> 01:07:16,230
well and PCIe those are also called

01:07:14,280 --> 01:07:18,990
switches and USB that's called a hub

01:07:16,230 --> 01:07:21,240
right you have one way of taking

01:07:18,990 --> 01:07:23,640
multiple devices and communicating with

01:07:21,240 --> 01:07:25,500
them over a single link well we talked

01:07:23,640 --> 01:07:27,600
about Gen Z components well the gen Z

01:07:25,500 --> 01:07:29,460
component is the fundamental hardware

01:07:27,600 --> 01:07:31,440
thing that can connect to the fabric so

01:07:29,460 --> 01:07:32,970
a PCIe that's called an endpoint and an

01:07:31,440 --> 01:07:38,010
USB that's called a host or a device

01:07:32,970 --> 01:07:40,470
right so when we talk about when we talk

01:07:38,010 --> 01:07:46,560
about the fundamental elements of Gen Z

01:07:40,470 --> 01:07:49,560
are components and links and there was

01:07:46,560 --> 01:07:51,270
one more thing I forget and the

01:07:49,560 --> 01:07:55,530
components get linked together right and

01:07:51,270 --> 01:07:58,050
and switch is just a component that has

01:07:55,530 --> 01:08:00,720
multiple multiple links coming out of it

01:07:58,050 --> 01:08:03,030
and can route packets between them so a

01:08:00,720 --> 01:08:05,250
switch is just another gens II device a

01:08:03,030 --> 01:08:06,960
gens II component and it's managed just

01:08:05,250 --> 01:08:08,790
like all the other jamesy components and

01:08:06,960 --> 01:08:12,600
you can configure it to route packets

01:08:08,790 --> 01:08:14,790
however you like so unlike us beware the

01:08:12,600 --> 01:08:18,710
hub is kind of special and gens these

01:08:14,790 --> 01:08:18,710
switches are pretty pretty generic yeah

01:08:23,000 --> 01:08:26,940
it depends right depends on how slow

01:08:25,469 --> 01:08:28,770
your switches we're you know we're

01:08:26,940 --> 01:08:30,630
talking we're talking on the order of

01:08:28,770 --> 01:08:33,989
you know tens of nanoseconds for

01:08:30,630 --> 01:08:35,279
switching latency but yeah I don't know

01:08:33,989 --> 01:08:36,799
what the actual values are going to be

01:08:35,279 --> 01:08:39,509
until somebody builds something

01:08:36,799 --> 01:08:42,420
it is devant and designed to be switched

01:08:39,509 --> 01:08:46,020
unlike Ethernet or unlike IP which is

01:08:42,420 --> 01:08:47,489
designed for in sub bizarro way and in

01:08:46,020 --> 01:08:48,870
particular the addressing comes pretty

01:08:47,489 --> 01:08:51,509
early in the packet so you can route

01:08:48,870 --> 01:08:54,779
without having to store a lot of data we

01:08:51,509 --> 01:08:57,270
have Gen Z has a notion of subnets it's

01:08:54,779 --> 01:08:59,850
kind of a soft notion you don't you

01:08:57,270 --> 01:09:03,179
could instantiate an entire jens e

01:08:59,850 --> 01:09:04,770
fabric is a single subnet and try to

01:09:03,179 --> 01:09:06,540
figure out how to get routing to work

01:09:04,770 --> 01:09:09,089
within that or you can actually create

01:09:06,540 --> 01:09:10,739
subnets and that allows you to do do

01:09:09,089 --> 01:09:14,310
some kind of routing construction you

01:09:10,739 --> 01:09:17,370
talk about USB is having USB as having

01:09:14,310 --> 01:09:19,920
hubs and you have all these addresses

01:09:17,370 --> 01:09:22,620
being you know this hub to this hub to

01:09:19,920 --> 01:09:23,940
this hub to this device when Gen Z you

01:09:22,620 --> 01:09:26,819
don't have to have that explicit of

01:09:23,940 --> 01:09:29,549
routing from the source each switch is

01:09:26,819 --> 01:09:31,799
configured to say when I get a packet

01:09:29,549 --> 01:09:34,109
with this subnet ID it goes out this

01:09:31,799 --> 01:09:36,120
port or if it's on the same subnet as me

01:09:34,109 --> 01:09:37,980
than if it's this component idea goes

01:09:36,120 --> 01:09:39,839
out this port and so each switch is

01:09:37,980 --> 01:09:42,299
configured in this very straightforward

01:09:39,839 --> 01:09:44,790
fashion with a flat table of subnets and

01:09:42,299 --> 01:09:48,150
a flat table of component IDs it's

01:09:44,790 --> 01:09:50,130
pretty simple notion of routing but it

01:09:48,150 --> 01:09:53,219
does allow some flexibility and it

01:09:50,130 --> 01:09:56,100
allows again the host so the

01:09:53,219 --> 01:09:58,500
complication here is that because the S

01:09:56,100 --> 01:10:02,219
ID and C IDs those subnet ID is in

01:09:58,500 --> 01:10:05,190
componenets ar-ar-ar softly definable -

01:10:02,219 --> 01:10:07,290
defined at runtime and because the

01:10:05,190 --> 01:10:08,270
routing can be specified in a lot of

01:10:07,290 --> 01:10:11,610
different ways

01:10:08,270 --> 01:10:13,590
unlike USB weather routing is specified

01:10:11,610 --> 01:10:14,909
by the hardware it's like the routing to

01:10:13,590 --> 01:10:16,770
any particular there's only one route to

01:10:14,909 --> 01:10:18,929
any device in USB because it's a

01:10:16,770 --> 01:10:20,310
straight tree in Gen Z you can have a

01:10:18,929 --> 01:10:24,239
fabric consider getting multiple routes

01:10:20,310 --> 01:10:25,860
how you set up the routing is is not

01:10:24,239 --> 01:10:29,370
determine cannot be determined

01:10:25,860 --> 01:10:30,750
automatically it's a policy decision so

01:10:29,370 --> 01:10:31,820
this was the first place where we said

01:10:30,750 --> 01:10:34,230
wait a minute

01:10:31,820 --> 01:10:38,210
where do we want to do policy do we like

01:10:34,230 --> 01:10:41,070
to do policy inside the Linux kernel

01:10:38,210 --> 01:10:42,750
right we don't like to do policy in the

01:10:41,070 --> 01:10:44,850
Linux kernel Linux kernel likes to say

01:10:42,750 --> 01:10:46,680
no I don't do policy policy is done by

01:10:44,850 --> 01:10:48,090
somebody outside of me so when we

01:10:46,680 --> 01:10:50,070
started looking at stuff like this when

01:10:48,090 --> 01:10:51,750
we started thinking about how how we

01:10:50,070 --> 01:10:53,700
wanted it to work in Linux we started

01:10:51,750 --> 01:10:56,130
thinking wait a minute we need to do

01:10:53,700 --> 01:11:03,060
some of the management of this fabric in

01:10:56,130 --> 01:11:06,060
user space exactly in the gen Z spec has

01:11:03,060 --> 01:11:08,700
one component on the fabric as being the

01:11:06,060 --> 01:11:10,320
fabric the fabric manager immense and

01:11:08,700 --> 01:11:18,770
then there's a backup if that one can't

01:11:10,320 --> 01:11:18,770
be reached grant you have a question yep

01:11:19,610 --> 01:11:24,090
about routing a lot can you explain how

01:11:21,780 --> 01:11:25,650
probing and discovery of devices goes

01:11:24,090 --> 01:11:27,210
because PCI has a whole discovery

01:11:25,650 --> 01:11:29,850
protocol of how to discover devices so

01:11:27,210 --> 01:11:31,950
does USB so it is Gen Z and so does

01:11:29,850 --> 01:11:35,100
Fiber Channel and Cota's InfiniBand and

01:11:31,950 --> 01:11:36,750
of course so how does it can you give a

01:11:35,100 --> 01:11:40,860
little later on how that works

01:11:36,750 --> 01:11:48,900
Oh Jim why don't you talk about that we

01:11:40,860 --> 01:11:50,670
can fix that okay so the discovery

01:11:48,900 --> 01:11:51,960
happens but you start out with some

01:11:50,670 --> 01:11:53,670
device that you're connected to if

01:11:51,960 --> 01:11:55,350
you're on a CPU that's the bridge as he

01:11:53,670 --> 01:11:56,700
talked about so you you you know where

01:11:55,350 --> 01:11:59,100
the bridge is you find that by some

01:11:56,700 --> 01:12:01,230
other mechanism like PCI maybe it's you

01:11:59,100 --> 01:12:03,030
know it appears as a PCI device or maybe

01:12:01,230 --> 01:12:05,700
it's in a CPI but you've got a

01:12:03,030 --> 01:12:13,170
connection to your local gens II

01:12:05,700 --> 01:12:14,790
component and you will cause it to it's

01:12:13,170 --> 01:12:15,989
it has it has something in it called

01:12:14,790 --> 01:12:18,960
control space which he hasn't talked

01:12:15,989 --> 01:12:20,640
about yet which is on the order of PCI

01:12:18,960 --> 01:12:22,050
config space the same kind of idea it's

01:12:20,640 --> 01:12:24,390
it's a place that has defined

01:12:22,050 --> 01:12:26,910
architected structures in it that you

01:12:24,390 --> 01:12:29,310
can talk to you and you can find out how

01:12:26,910 --> 01:12:32,070
many interfaces your component has and

01:12:29,310 --> 01:12:34,200
then you can you can cause a packet to

01:12:32,070 --> 01:12:35,730
go out each one of those interfaces and

01:12:34,200 --> 01:12:37,350
you can find out what's on the other

01:12:35,730 --> 01:12:40,590
side of it to send me the link is up and

01:12:37,350 --> 01:12:43,110
once you've done that maybe it's a

01:12:40,590 --> 01:12:44,640
switch and you want to talk to it so

01:12:43,110 --> 01:12:45,450
then there's this concept in Jen's II

01:12:44,640 --> 01:12:47,040
called

01:12:45,450 --> 01:12:49,770
to relay where you send the packet to

01:12:47,040 --> 01:12:51,480
that switch and then it sends it out the

01:12:49,770 --> 01:12:53,580
the interface that you want and so you

01:12:51,480 --> 01:12:54,090
you basically build out one step at a

01:12:53,580 --> 01:12:57,180
time

01:12:54,090 --> 01:12:59,310
discovering the entire fabric by using

01:12:57,180 --> 01:13:02,460
these control space accesses and sending

01:12:59,310 --> 01:13:06,290
packets out the designated interfaces

01:13:02,460 --> 01:13:06,290
does that make sense okay

01:13:34,619 --> 01:13:39,780
so yes there is it there isn't there is

01:13:38,070 --> 01:13:41,159
a scalability inherent scalability

01:13:39,780 --> 01:13:42,960
problem that you know the more devices

01:13:41,159 --> 01:13:45,119
there are the more transactions you have

01:13:42,960 --> 01:13:46,469
to send to each one and there's like

01:13:45,119 --> 01:13:54,389
some kind of N squared problem going on

01:13:46,469 --> 01:13:58,199
there right yeah so so as as ki said

01:13:54,389 --> 01:14:00,300
routing is done completely by s ID and C

01:13:58,199 --> 01:14:03,929
ID the subnet and component IDs totally

01:14:00,300 --> 01:14:05,810
separate from address ability in Gen Z

01:14:03,929 --> 01:14:12,810
every component you discover has a

01:14:05,810 --> 01:14:14,280
64-bit data space of its own in terms of

01:14:12,810 --> 01:14:16,349
mapping that into the address space of

01:14:14,280 --> 01:14:18,150
the Year hosts on the original side Gen

01:14:16,349 --> 01:14:20,310
Z has this concept called as EMM you a

01:14:18,150 --> 01:14:22,409
gens e memory management unit which

01:14:20,310 --> 01:14:25,230
basically says given some physical

01:14:22,409 --> 01:14:27,590
address on my localhost what component

01:14:25,230 --> 01:14:31,409
ID and address do I want to send this to

01:14:27,590 --> 01:14:33,719
so that's how you map remote objects

01:14:31,409 --> 01:14:35,340
into your address space so instead of

01:14:33,719 --> 01:14:38,010
the resource allocation being done

01:14:35,340 --> 01:14:40,500
globally across the entire fabric they

01:14:38,010 --> 01:14:43,590
act the address space allocation is done

01:14:40,500 --> 01:14:45,330
locally per component each component

01:14:43,590 --> 01:14:47,520
sets up a mapping from its physical

01:14:45,330 --> 01:14:49,440
address space to the global Gen Z

01:14:47,520 --> 01:14:53,510
address space which consists of a subnet

01:14:49,440 --> 01:14:57,389
ID a component ID and a 64-bit address

01:14:53,510 --> 01:14:59,580
so you have 32 bits 16 bits of subnet 16

01:14:57,389 --> 01:15:02,219
bits of component 12 bits of combustible

01:14:59,580 --> 01:15:05,580
and 64 bits of address within that

01:15:02,219 --> 01:15:07,199
within that within that component so

01:15:05,580 --> 01:15:09,599
then you map that into your own local so

01:15:07,199 --> 01:15:11,790
unlike PCIe which has a single address

01:15:09,599 --> 01:15:13,770
space for the entire thing right we have

01:15:11,790 --> 01:15:15,420
one address space per component so at

01:15:13,770 --> 01:15:17,010
least we don't have address space

01:15:15,420 --> 01:15:19,730
allocation that you have to talk to the

01:15:17,010 --> 01:15:19,730
devices about

01:15:23,940 --> 01:15:31,110
yep exactly

01:15:26,280 --> 01:15:35,580
yeah you like it Wow

01:15:31,110 --> 01:15:35,580
yeah okay good

01:15:35,590 --> 01:15:42,460
here's here's some more similarities and

01:15:38,590 --> 01:15:44,170
differences gen Z enumeration as we

01:15:42,460 --> 01:15:46,210
talked about is controlled by walking

01:15:44,170 --> 01:15:48,190
the control space doing reads and writes

01:15:46,210 --> 01:15:50,830
out of control space just like PCIe is

01:15:48,190 --> 01:15:54,220
is done you know you read out of PCI

01:15:50,830 --> 01:15:55,540
control control space routing in Gen Z

01:15:54,220 --> 01:15:56,440
as I said it's all controlled by

01:15:55,540 --> 01:15:58,990
software

01:15:56,440 --> 01:16:00,640
unlike PCIe and USB which is fixed by

01:15:58,990 --> 01:16:03,520
the topology right if you're gonna route

01:16:00,640 --> 01:16:05,080
a USB transaction there's only one route

01:16:03,520 --> 01:16:06,610
every USB device you don't have

01:16:05,080 --> 01:16:10,360
multipath so you don't have any

01:16:06,610 --> 01:16:12,640
questions gen Z does of course it does

01:16:10,360 --> 01:16:15,040
everything it does both memory map

01:16:12,640 --> 01:16:17,110
memory map access and you can send

01:16:15,040 --> 01:16:19,210
messages so you can you can actually

01:16:17,110 --> 01:16:21,310
build a network on top of this that it

01:16:19,210 --> 01:16:22,660
does not know about the remote addresses

01:16:21,310 --> 01:16:25,330
you're just sending a message to a

01:16:22,660 --> 01:16:28,480
particular what is it a registered like

01:16:25,330 --> 01:16:30,700
the context a context yeah so it's like

01:16:28,480 --> 01:16:36,040
a porch right you can send a Datagram to

01:16:30,700 --> 01:16:37,990
a port on a remote machine so what we so

01:16:36,040 --> 01:16:40,600
this is like kind of a picture this is

01:16:37,990 --> 01:16:42,340
my lame picture for management of what

01:16:40,600 --> 01:16:44,950
the linux driver stack looks like where

01:16:42,340 --> 01:16:48,550
you have where you have a bus subsystem

01:16:44,950 --> 01:16:50,650
and then you have bus specific drivers

01:16:48,550 --> 01:16:55,060
that talk into the particular subsystem

01:16:50,650 --> 01:16:57,310
so when we talk about Jen's II whoa what

01:16:55,060 --> 01:16:58,810
happened we talked about Gen Z then

01:16:57,310 --> 01:17:01,480
we're talking about creating a Gen Z

01:16:58,810 --> 01:17:03,610
subsystem and then some gen Z device

01:17:01,480 --> 01:17:05,740
drivers on top of that that that plug

01:17:03,610 --> 01:17:07,570
into existing kernel infrastructures so

01:17:05,740 --> 01:17:10,180
if you have if you have a block device

01:17:07,570 --> 01:17:12,070
that's accessible over Gen Z then you're

01:17:10,180 --> 01:17:14,260
going to write a gens e block device

01:17:12,070 --> 01:17:16,450
driver that sits on top of the gen Z sub

01:17:14,260 --> 01:17:18,430
system that provides a block interface

01:17:16,450 --> 01:17:20,740
to the kernel so I can I can write file

01:17:18,430 --> 01:17:23,560
I put a file system on that if you have

01:17:20,740 --> 01:17:25,030
a network and a network thing that you

01:17:23,560 --> 01:17:26,470
want to do over gen Z then I can create

01:17:25,030 --> 01:17:28,930
something that looks like a network

01:17:26,470 --> 01:17:32,230
device driver and and plug it into the

01:17:28,930 --> 01:17:33,580
network subsystem and the other thing

01:17:32,230 --> 01:17:35,170
that I'm the other thing we're going to

01:17:33,580 --> 01:17:35,900
expose here is this bus management

01:17:35,170 --> 01:17:38,840
driver right in

01:17:35,900 --> 01:17:41,480
in PCIe or USB that's all inside the

01:17:38,840 --> 01:17:44,170
kernel right when you talk about USB USB

01:17:41,480 --> 01:17:46,580
devices device IDs are assigned

01:17:44,170 --> 01:17:49,100
dynamically by the kernel it's a pretty

01:17:46,580 --> 01:17:51,650
simple policy the last device was number

01:17:49,100 --> 01:17:54,710
10 the next device is going to be number

01:17:51,650 --> 01:17:56,450
11 with Gen Z because we want to we want

01:17:54,710 --> 01:17:58,490
to make this expo qui want to expose

01:17:56,450 --> 01:18:00,740
this to user space we're gonna have to

01:17:58,490 --> 01:18:03,170
come up with an API between that bus

01:18:00,740 --> 01:18:04,280
management layer and user space because

01:18:03,170 --> 01:18:07,370
we're going to pump a bunch of that

01:18:04,280 --> 01:18:10,880
stuff up on user space and that means

01:18:07,370 --> 01:18:13,370
that Gen Z may not entirely come up

01:18:10,880 --> 01:18:15,140
without user space so we're talking

01:18:13,370 --> 01:18:17,030
about you know right now it's pretty

01:18:15,140 --> 01:18:18,980
simple and you when you have when you

01:18:17,030 --> 01:18:20,600
have an idiom is it's like well you

01:18:18,980 --> 01:18:21,980
could do a bunch of stuff in there to

01:18:20,600 --> 01:18:23,990
get the bus to talk to the rest of your

01:18:21,980 --> 01:18:26,150
peripherals what if you're booting from

01:18:23,990 --> 01:18:29,000
Gen Z what does that even mean you know

01:18:26,150 --> 01:18:31,910
can I can I do that successfully and the

01:18:29,000 --> 01:18:34,430
answer is we don't know yet but you know

01:18:31,910 --> 01:18:37,700
if the bioscan loaded an image over Gen

01:18:34,430 --> 01:18:40,820
Z into RAM that I guess we're good yeah

01:18:37,700 --> 01:18:43,100
and so just like just like USB where the

01:18:40,820 --> 01:18:45,650
BIOS often enumerates the USB devices

01:18:43,100 --> 01:18:47,870
and numbers them all and and talks to

01:18:45,650 --> 01:18:49,760
them and in at bot at boot time to get a

01:18:47,870 --> 01:18:51,230
boot image and then the kernel comes

01:18:49,760 --> 01:18:53,780
along later andrea numerate s-- the

01:18:51,230 --> 01:18:55,460
entire bus I imagine we're gonna end up

01:18:53,780 --> 01:18:58,250
with something similar to that on Gen Z

01:18:55,460 --> 01:18:59,840
I don't know how far out the BIOS will

01:18:58,250 --> 01:19:01,760
end up Renu Mirae tting Gen Z or if it

01:18:59,840 --> 01:19:03,920
does it at all I have no idea

01:19:01,760 --> 01:19:05,540
that's a BIOS person's problem I'm not a

01:19:03,920 --> 01:19:09,890
BIOS engineer and our team doesn't do

01:19:05,540 --> 01:19:12,050
biases yeah well one comment do you have

01:19:09,890 --> 01:19:13,580
to have to understand that corporations

01:19:12,050 --> 01:19:16,580
involved in Gen Z are interested in

01:19:13,580 --> 01:19:19,790
having unmodified OSS right the current

01:19:16,580 --> 01:19:21,950
red hats and windows and so there's a

01:19:19,790 --> 01:19:24,890
big push to make sure on unmodified OSS

01:19:21,950 --> 01:19:26,480
work and so there's a big push in some

01:19:24,890 --> 01:19:28,610
parts of the consortium to put a lot of

01:19:26,480 --> 01:19:30,320
that stuff in the firmware yeah so that

01:19:28,610 --> 01:19:31,370
you don't have to change the kernel no

01:19:30,320 --> 01:19:32,600
that's not what we're interested in

01:19:31,370 --> 01:19:36,080
we're its and in changing the kernel

01:19:32,600 --> 01:19:38,090
right so as I said we've been talking

01:19:36,080 --> 01:19:40,820
about this PCI emulation to make gen Z

01:19:38,090 --> 01:19:42,950
look like PCI and so it may be that all

01:19:40,820 --> 01:19:45,290
the bios that the way that you boot off

01:19:42,950 --> 01:19:47,480
of Gen Z is by having the BIOS do pci

01:19:45,290 --> 01:19:49,099
emulation and we use the existing PCI

01:19:47,480 --> 01:19:55,070
stack in the BIOS

01:19:49,099 --> 01:19:57,230
who knows not our problem come on so

01:19:55,070 --> 01:19:59,840
really simple plan right

01:19:57,230 --> 01:20:02,260
create a new gen Z bus subsystem that's

01:19:59,840 --> 01:20:04,400
create but kind of with a small C

01:20:02,260 --> 01:20:05,750
because when we talk about creating a

01:20:04,400 --> 01:20:08,599
new bus subsystem really what we're

01:20:05,750 --> 01:20:10,670
gonna go do is steal code and ideas from

01:20:08,599 --> 01:20:13,820
existing bus subsystems I've talked

01:20:10,670 --> 01:20:16,639
about how USB and and PCIe are have a

01:20:13,820 --> 01:20:17,750
lot of commonality with Gen Z and so

01:20:16,639 --> 01:20:23,510
we're gonna go steal a bunch of that

01:20:17,750 --> 01:20:26,719
stuff and expose the management up to

01:20:23,510 --> 01:20:30,530
user space and hope it all works out so

01:20:26,719 --> 01:20:32,659
we're hoping to have some this

01:20:30,530 --> 01:20:34,159
presentation is really long one of the

01:20:32,659 --> 01:20:36,530
things we're working on right now is a

01:20:34,159 --> 01:20:37,909
software simulation of Gen Z so we can

01:20:36,530 --> 01:20:41,420
actually do a bunch of this development

01:20:37,909 --> 01:20:42,829
with with no hardware at all I mean what

01:20:41,420 --> 01:20:46,040
we're doing is we're creating multiple

01:20:42,829 --> 01:20:48,739
VMs on us on a shared infrastructure and

01:20:46,040 --> 01:20:51,260
using intervie em messaging and Inter VM

01:20:48,739 --> 01:20:53,869
shared memory to set up kind of our

01:20:51,260 --> 01:20:55,849
little virtual Gen Z bus and so we're

01:20:53,869 --> 01:20:56,810
hoping to be able to simulate Gen Z to

01:20:55,849 --> 01:20:59,630
the point where we can get all the

01:20:56,810 --> 01:21:01,790
management infrastructure demonstrate

01:20:59,630 --> 01:21:03,770
that on a laptop you know instead of

01:21:01,790 --> 01:21:06,139
having to have actual Gen Z Hardware so

01:21:03,770 --> 01:21:10,369
we can do a bunch of this development in

01:21:06,139 --> 01:21:12,739
a pretty simple emulation environment so

01:21:10,369 --> 01:21:14,389
our other I mean are there

01:21:12,739 --> 01:21:15,800
representatives of other people who are

01:21:14,389 --> 01:21:18,260
talking about gen z within their

01:21:15,800 --> 01:21:20,619
companies here have experiences to share

01:21:18,260 --> 01:21:20,619
or

01:21:21,860 --> 01:21:24,670
awesome

01:21:28,650 --> 01:21:33,179
we didn't talk about security at all Gen

01:21:31,469 --> 01:21:34,800
Z actually has a pretty elaborate

01:21:33,179 --> 01:21:35,369
security story and that's longer than

01:21:34,800 --> 01:21:38,070
this

01:21:35,369 --> 01:21:39,510
Boff would go on for there are there's a

01:21:38,070 --> 01:21:42,210
bunch of security stuff and the gen Z

01:21:39,510 --> 01:21:44,790
stuff about about our keys and and s

01:21:42,210 --> 01:21:46,409
keys and all kinds of stuff obviously

01:21:44,790 --> 01:21:48,630
with you know talking about byte level

01:21:46,409 --> 01:21:56,460
accessibility you need to have some

01:21:48,630 --> 01:21:58,590
access control yeah if there are other

01:21:56,460 --> 01:22:01,830
questions we'll be around I'm afraid our

01:21:58,590 --> 01:22:03,810
our Boff time is about up if you have

01:22:01,830 --> 01:22:05,790
questions you know I'll hang around we

01:22:03,810 --> 01:22:08,219
have a break right now it's actually

01:22:05,790 --> 01:22:09,840
started about six minutes ago if you

01:22:08,219 --> 01:22:11,159
want to come up and chat with us during

01:22:09,840 --> 01:22:13,650
the break we'll be here but otherwise

01:22:11,159 --> 01:22:14,969
really I really appreciate everybody

01:22:13,650 --> 01:22:16,949
showing up and asking interesting

01:22:14,969 --> 01:22:18,360
questions and challenging our

01:22:16,949 --> 01:22:24,210
assumptions that Gen Z is gonna be the

01:22:18,360 --> 01:22:25,739
best thing ever and keep us honest as we

01:22:24,210 --> 01:22:28,619
implement code and submit patches

01:22:25,739 --> 01:22:30,119
because you know it's gonna be a bunch

01:22:28,619 --> 01:22:31,830
of new code and it's gonna be wrong the

01:22:30,119 --> 01:22:34,830
first several iterations because it

01:22:31,830 --> 01:22:37,050
always is I think so much and we'll be

01:22:34,830 --> 01:22:38,690
here ask us questions thanks for coming

01:22:37,050 --> 01:22:42,750
up thanks for coming by

01:22:38,690 --> 01:22:46,090
[Applause]

01:22:42,750 --> 01:22:48,550
okay you guys about ready to talk about

01:22:46,090 --> 01:22:50,080
painful painful stuff actually the last

01:22:48,550 --> 01:22:52,750
presentation had some painful things

01:22:50,080 --> 01:22:57,550
that they discussed I think you uh you

01:22:52,750 --> 01:22:59,849
remember some of that so quick quiz

01:22:57,550 --> 01:23:02,110
before we start

01:22:59,849 --> 01:23:03,460
we've had some file system discussions

01:23:02,110 --> 01:23:05,260
we've had lots of good discussions block

01:23:03,460 --> 01:23:06,480
device discussions what was the favorite

01:23:05,260 --> 01:23:15,250
so far do you guys have a favorite

01:23:06,480 --> 01:23:17,080
presentation so far any anything okay

01:23:15,250 --> 01:23:19,260
well what I'd like to do is talk a

01:23:17,080 --> 01:23:23,230
little bit about some of the file system

01:23:19,260 --> 01:23:25,300
activity that's been you know driving

01:23:23,230 --> 01:23:27,489
things I worry about every day and some

01:23:25,300 --> 01:23:29,110
of the people in this room and some of

01:23:27,489 --> 01:23:30,820
the people at this conference you know

01:23:29,110 --> 01:23:33,909
if you picked up your phone and looked

01:23:30,820 --> 01:23:36,940
at FS devel today you know if you look

01:23:33,909 --> 01:23:39,940
today what would you see as things that

01:23:36,940 --> 01:23:42,070
are bugging people in file system what

01:23:39,940 --> 01:23:44,860
would you see in activity you'd see

01:23:42,070 --> 01:23:48,520
things relating to file notify you'd

01:23:44,860 --> 01:23:51,070
things with splice use after free and

01:23:48,520 --> 01:23:57,400
lock pads lots of lock bugs forever for

01:23:51,070 --> 01:24:00,159
20 years and then some IO map issues dax

01:23:57,400 --> 01:24:02,230
issues it's interesting I think if you

01:24:00,159 --> 01:24:03,429
looked at the same list five years ago

01:24:02,230 --> 01:24:07,409
and ten years ago you'd see a lot of

01:24:03,429 --> 01:24:07,409
commonality it's kind of interesting

01:24:10,440 --> 01:24:15,180
okay just a little background I used to

01:24:13,440 --> 01:24:16,740
be the file system architect at IBM I

01:24:15,180 --> 01:24:20,460
work for Microsoft now and Azure storage

01:24:16,740 --> 01:24:23,660
I authored the original assist VFS which

01:24:20,460 --> 01:24:26,280
one of the larger and more active EFS is

01:24:23,660 --> 01:24:30,540
former storage network working group

01:24:26,280 --> 01:24:31,830
chair and I work in Azure storage now on

01:24:30,540 --> 01:24:32,940
the Linux side and I think there's a

01:24:31,830 --> 01:24:34,020
number of Microsoft people here

01:24:32,940 --> 01:24:36,120
presenting so it's kind of an

01:24:34,020 --> 01:24:38,310
interesting change for me to see

01:24:36,120 --> 01:24:40,560
Microsoft presenting on Linux something

01:24:38,310 --> 01:24:41,760
I find fascinating this is as we saw

01:24:40,560 --> 01:24:44,310
here this is not a Microsoft

01:24:41,760 --> 01:24:48,870
presentation but I am intrigued about

01:24:44,310 --> 01:24:50,400
all this recent change okay so what are

01:24:48,870 --> 01:24:51,690
we gonna talk about today I'd like to

01:24:50,400 --> 01:24:52,800
talk about some general activity I'd

01:24:51,690 --> 01:24:54,570
like to talk about some of the changes

01:24:52,800 --> 01:24:55,950
that have been going on I want to talk

01:24:54,570 --> 01:25:00,690
about some of the things that are

01:24:55,950 --> 01:25:02,910
driving this activity and but let's

01:25:00,690 --> 01:25:06,120
start with some status updates so what

01:25:02,910 --> 01:25:08,460
has what's happened in the last 14

01:25:06,120 --> 01:25:11,330
months I think you as you saw a few days

01:25:08,460 --> 01:25:13,950
ago we released the people's front right

01:25:11,330 --> 01:25:16,430
so actually do it does anybody know is

01:25:13,950 --> 01:25:18,780
that a reference to Monty Python okay

01:25:16,430 --> 01:25:22,250
okay so there there's two people fronts

01:25:18,780 --> 01:25:24,360
do you know which people's front it is

01:25:22,250 --> 01:25:28,560
okay so it's probably the Judean

01:25:24,360 --> 01:25:34,080
people's was curious about that I had a

01:25:28,560 --> 01:25:35,580
vague memory from long ago yeah so

01:25:34,080 --> 01:25:37,500
anyway this is an interesting joke about

01:25:35,580 --> 01:25:40,530
the people's front but here we deal with

01:25:37,500 --> 01:25:42,390
some really cool activity now what's

01:25:40,530 --> 01:25:46,710
been driving the activity over the last

01:25:42,390 --> 01:25:49,920
step well actually for a long time well

01:25:46,710 --> 01:25:52,590
Dave Howells in the new mount API a new

01:25:49,920 --> 01:25:54,060
FS info API because every file system

01:25:52,590 --> 01:25:57,420
has different types of metadata to

01:25:54,060 --> 01:26:03,870
return we have various security issues

01:25:57,420 --> 01:26:05,730
security features but there are many new

01:26:03,870 --> 01:26:07,980
security features that are important I

01:26:05,730 --> 01:26:10,500
think a lot of you have seen discussions

01:26:07,980 --> 01:26:13,170
about nvme about faster storage

01:26:10,500 --> 01:26:14,610
technology and how that affects network

01:26:13,170 --> 01:26:16,680
file system so it affects local file

01:26:14,610 --> 01:26:19,470
systems how it breaks things in unusual

01:26:16,680 --> 01:26:21,780
ways the i/o patterns are different we

01:26:19,470 --> 01:26:23,520
have cheaper faster network adapters you

01:26:21,780 --> 01:26:24,000
know I've got 40 gig adapters at home

01:26:23,520 --> 01:26:26,770
now

01:26:24,000 --> 01:26:28,750
you want to copy that Monty Python movie

01:26:26,770 --> 01:26:31,500
that you watched I'm going to copy it in

01:26:28,750 --> 01:26:34,659
a few seconds instead of a few hours

01:26:31,500 --> 01:26:36,429
we've got statics came in Dave Howell

01:26:34,659 --> 01:26:38,739
statics came in about a little over a

01:26:36,429 --> 01:26:40,960
year ago how do we extend that to

01:26:38,739 --> 01:26:42,730
include attributes relating to offline

01:26:40,960 --> 01:26:44,440
storage the cloud new security

01:26:42,730 --> 01:26:46,630
attributes things that matter for

01:26:44,440 --> 01:26:48,309
cluster file systems for specialized

01:26:46,630 --> 01:26:51,610
file systems for network file systems I

01:26:48,309 --> 01:26:53,110
think many of you saw Derek Dave Turner

01:26:51,610 --> 01:26:56,650
and Derek and the changes they've

01:26:53,110 --> 01:26:58,929
recently done for D do lots of things

01:26:56,650 --> 01:27:02,290
relating to lakhs and lakhs and lakhs

01:26:58,929 --> 01:27:04,210
and more lakhs of driving activity now

01:27:02,290 --> 01:27:05,800
if you look through the last week's

01:27:04,210 --> 01:27:08,500
activity you'll still see things like

01:27:05,800 --> 01:27:11,050
XFS supporting larger block sizes and

01:27:08,500 --> 01:27:15,730
page size it's been an issue for many

01:27:11,050 --> 01:27:18,099
many years and my favorite we have olga

01:27:15,730 --> 01:27:21,849
who has the patch set about broadening

01:27:18,099 --> 01:27:23,530
the use of a copy offload we should

01:27:21,849 --> 01:27:24,579
allow copy offload between two mounts in

01:27:23,530 --> 01:27:27,369
the same file system what the file

01:27:24,579 --> 01:27:28,659
system figured out make copy faster

01:27:27,369 --> 01:27:31,420
people actually do file copies

01:27:28,659 --> 01:27:34,900
occasionally and fix our copy tools and

01:27:31,420 --> 01:27:37,119
of course I worked in Azure so I deal

01:27:34,900 --> 01:27:39,960
with long latency and cloud as the

01:27:37,119 --> 01:27:47,260
target anyway you had a question

01:27:39,960 --> 01:27:49,480
actually supposed to repeat to our is

01:27:47,260 --> 01:27:50,949
this the only page I hate to to guess

01:27:49,480 --> 01:27:53,260
ahead for the next slide I would I'm

01:27:50,949 --> 01:27:57,130
curious about 64-bit time I don't see it

01:27:53,260 --> 01:27:59,440
here so his point about 64-bit time is

01:27:57,130 --> 01:28:01,599
well thought and it is drew it drove a

01:27:59,440 --> 01:28:04,540
lot of activity I don't mention it

01:28:01,599 --> 01:28:07,300
particularly here because a lot of it

01:28:04,540 --> 01:28:10,750
has has been done I think as you know

01:28:07,300 --> 01:28:13,599
both NFS and SMB support longer time

01:28:10,750 --> 01:28:15,969
stamps it varied by file system SMB uses

01:28:13,599 --> 01:28:16,750
DC time so start back you know 500 years

01:28:15,969 --> 01:28:21,520
400 years

01:28:16,750 --> 01:28:24,550
NFS supports uh the the larger time

01:28:21,520 --> 01:28:27,280
stamps as well so there are a variety of

01:28:24,550 --> 01:28:29,050
file systems but it is hell for XFS test

01:28:27,280 --> 01:28:31,059
when you're testing to appliances

01:28:29,050 --> 01:28:33,040
running Linux because you don't know

01:28:31,059 --> 01:28:34,840
what file systems tiny granularity for

01:28:33,040 --> 01:28:36,940
actually you do you can find it but it's

01:28:34,840 --> 01:28:39,370
a little tricky to get XFS just to pass

01:28:36,940 --> 01:28:41,469
when the time granularity is course on

01:28:39,370 --> 01:28:43,690
some Linux file systems and fine grained

01:28:41,469 --> 01:28:45,280
on others because the network protocols

01:28:43,690 --> 01:28:47,140
and cluster protocols generally support

01:28:45,280 --> 01:28:49,570
the 64-bit timestamps but not all local

01:28:47,140 --> 01:28:51,820
file systems do these changes as far as

01:28:49,570 --> 01:28:52,930
I know haven't been a controversial but

01:28:51,820 --> 01:28:55,390
if you're aware of something maybe we

01:28:52,930 --> 01:28:56,620
can talk about that toward the end ok so

01:28:55,390 --> 01:28:58,350
at the file system summit you'll

01:28:56,620 --> 01:29:00,699
recognize many of the people here

01:28:58,350 --> 01:29:03,340
obviously a great group of developers I

01:29:00,699 --> 01:29:06,160
think you guys can can see some familiar

01:29:03,340 --> 01:29:07,420
faces there and you know it's a

01:29:06,160 --> 01:29:12,330
wonderful thing to work with this group

01:29:07,420 --> 01:29:15,100
this was in Park City Utah this year and

01:29:12,330 --> 01:29:17,170
you know watching this some of the

01:29:15,100 --> 01:29:19,630
discussions have been very very

01:29:17,170 --> 01:29:21,219
enlightening over the years and it's a

01:29:19,630 --> 01:29:23,650
hard problem ok so what are the most

01:29:21,219 --> 01:29:26,910
active file systems any poll anybody

01:29:23,650 --> 01:29:26,910
know what the most active file system is

01:29:27,090 --> 01:29:33,610
about RFS and XFS yeah letter FS 1 and X

01:29:30,520 --> 01:29:34,930
2 Festa - so butter FS had 927 changes I

01:29:33,610 --> 01:29:36,580
just measured it you know just before my

01:29:34,930 --> 01:29:40,810
presentation I was kind of curious this

01:29:36,580 --> 01:29:43,960
is - our c2 from 415 so what is it 10

01:29:40,810 --> 01:29:45,820
months something like that so btrfs had

01:29:43,960 --> 01:29:50,260
almost a thousand changes its activity

01:29:45,820 --> 01:29:55,360
is up XFS 564 its activities up then the

01:29:50,260 --> 01:29:57,190
VFS itself f2 FS and sifts then you have

01:29:55,360 --> 01:29:58,120
you know NFS you know it's it's

01:29:57,190 --> 01:29:59,710
interesting one of the things people

01:29:58,120 --> 01:30:01,540
don't realize the NFS server is actually

01:29:59,710 --> 01:30:03,190
not that active in the kernel compared

01:30:01,540 --> 01:30:05,830
with some of the user space servers like

01:30:03,190 --> 01:30:07,960
Ganesha or like some of the people I was

01:30:05,830 --> 01:30:10,660
talking to earlier today in samba you

01:30:07,960 --> 01:30:13,000
know samba is you know 4000 change

01:30:10,660 --> 01:30:15,520
that's per year right so user space

01:30:13,000 --> 01:30:16,719
servers are a lot bigger but you know

01:30:15,520 --> 01:30:19,090
it's interesting to see these activity

01:30:16,719 --> 01:30:22,120
you know btrfs XFS the VFS overall are

01:30:19,090 --> 01:30:23,620
extremely active file systems and you

01:30:22,120 --> 01:30:26,230
know just look at the remember I pulled

01:30:23,620 --> 01:30:27,550
up the mailing list just now you'll see

01:30:26,230 --> 01:30:31,480
Dave Jenner you'll see a lot of really

01:30:27,550 --> 01:30:34,480
interesting patches so this is a

01:30:31,480 --> 01:30:35,590
fascinating time I work on 6ko our

01:30:34,480 --> 01:30:38,199
activities up more than a hundred

01:30:35,590 --> 01:30:39,430
percent so it looks good we're I'm very

01:30:38,199 --> 01:30:42,010
pleased to see the activity coming from

01:30:39,430 --> 01:30:45,310
Red Hat I'm from Susa coming from over

01:30:42,010 --> 01:30:47,380
20 companies it's a lot of fun okay so

01:30:45,310 --> 01:30:49,949
here's the myth a lot of people think

01:30:47,380 --> 01:30:55,590
that we support POSIX

01:30:49,949 --> 01:30:57,489
do we care I mean POSIX is pretty small

01:30:55,590 --> 01:31:00,040
compared to what we have to support

01:30:57,489 --> 01:31:01,090
Linux when you look at XFS test half the

01:31:00,040 --> 01:31:03,909
tests are testing things that aren't

01:31:01,090 --> 01:31:05,010
even POSIX right they're there so you

01:31:03,909 --> 01:31:08,440
know let's look at this realistically

01:31:05,010 --> 01:31:10,179
our problem in file systems we got 293

01:31:08,440 --> 01:31:13,900
sis calls maybe more now but I looked at

01:31:10,179 --> 01:31:16,960
this a few months ago 293 sis calls less

01:31:13,900 --> 01:31:18,640
than half of them are POSIX so we got a

01:31:16,960 --> 01:31:21,969
lot of work as file system developers

01:31:18,640 --> 01:31:23,380
and people think it's just POSIX so what

01:31:21,969 --> 01:31:25,510
are the goals we want to make Linux fast

01:31:23,380 --> 01:31:26,830
right we want to make it secure you know

01:31:25,510 --> 01:31:28,540
if you're an NFS developer and you're

01:31:26,830 --> 01:31:30,699
trying to mount to some NetApp appliance

01:31:28,540 --> 01:31:32,860
you want it secure and fast and stable

01:31:30,699 --> 01:31:34,060
predictable you want the app writers to

01:31:32,860 --> 01:31:35,770
not know they're running on a network

01:31:34,060 --> 01:31:37,659
file system or a block file system or

01:31:35,770 --> 01:31:39,370
cluster file system you don't want them

01:31:37,659 --> 01:31:42,989
to worry about the timestamp granularity

01:31:39,370 --> 01:31:45,310
and something to break because of small

01:31:42,989 --> 01:31:47,830
strange behavior changes in one file

01:31:45,310 --> 01:31:48,310
systems we have over 60 file systems in

01:31:47,830 --> 01:31:50,260
Linux

01:31:48,310 --> 01:31:51,760
not counting fuse I don't know how many

01:31:50,260 --> 01:31:53,580
you guys set through the presentation

01:31:51,760 --> 01:31:55,840
just before this was talking about fuse

01:31:53,580 --> 01:31:57,699
user space with more than double the

01:31:55,840 --> 01:31:59,650
number of file systems that's a lot of

01:31:57,699 --> 01:32:01,540
file systems and as an app writer you're

01:31:59,650 --> 01:32:04,179
not in a special case every single one

01:32:01,540 --> 01:32:06,159
of those you might special case btrfs

01:32:04,179 --> 01:32:09,550
you're not going to special case NFS

01:32:06,159 --> 01:32:11,170
smb3 xof two of us you know every single

01:32:09,550 --> 01:32:12,820
file system so we have to make it

01:32:11,170 --> 01:32:15,730
predictable for app writer so we have to

01:32:12,820 --> 01:32:16,900
make it secure and reliable and give

01:32:15,730 --> 01:32:20,409
them the integrity features they need

01:32:16,900 --> 01:32:23,170
okay so what about presentations at this

01:32:20,409 --> 01:32:24,670
conference we've already had the one

01:32:23,170 --> 01:32:27,909
just before this but look at the other

01:32:24,670 --> 01:32:30,100
seven or eight presentations just at

01:32:27,909 --> 01:32:33,640
this conference on various file system

01:32:30,100 --> 01:32:35,350
topics zero copy user mode file name

01:32:33,640 --> 01:32:37,000
encoding case insensitive file names

01:32:35,350 --> 01:32:38,020
that's actually a significant interest

01:32:37,000 --> 01:32:42,510
to me because I have to deal with

01:32:38,020 --> 01:32:46,420
servers like Windows that are mostly

01:32:42,510 --> 01:32:48,730
case insensitive I have to do with both

01:32:46,420 --> 01:32:50,770
untrusted file system shift F s FS

01:32:48,730 --> 01:32:52,600
checkpointing and then of course we have

01:32:50,770 --> 01:32:54,730
this presentation on vireio how do we

01:32:52,600 --> 01:32:56,290
optimize i/o in cluster and network file

01:32:54,730 --> 01:32:57,600
system cases to take advantage of things

01:32:56,290 --> 01:32:58,800
like Verdejo

01:32:57,600 --> 01:33:01,380
more and more and I've left out

01:32:58,800 --> 01:33:03,690
something ok so just before the call I

01:33:01,380 --> 01:33:05,580
was talking to Jeremy Allison the lead

01:33:03,690 --> 01:33:07,500
server developer for Samba what are your

01:33:05,580 --> 01:33:09,480
favorite paint words what do you love to

01:33:07,500 --> 01:33:11,130
hate about the colonel and his first

01:33:09,480 --> 01:33:12,360
thing was why don't we have NFS Apple

01:33:11,130 --> 01:33:13,950
support or rich Apple support whatever

01:33:12,360 --> 01:33:16,310
to call it our SM vehicle support why

01:33:13,950 --> 01:33:18,750
don't we have that because we have

01:33:16,310 --> 01:33:22,200
petabytes of data we cannot migrate to

01:33:18,750 --> 01:33:23,760
Linux without rich apples whether you

01:33:22,200 --> 01:33:25,440
call it NFS for one apples where they

01:33:23,760 --> 01:33:28,230
call it ZFS Ackles they already support

01:33:25,440 --> 01:33:30,570
all this stuff right in samba but you

01:33:28,230 --> 01:33:33,120
have petabytes worth of data that he was

01:33:30,570 --> 01:33:36,990
aware of that cannot be migrated because

01:33:33,120 --> 01:33:38,880
there are no deny aces all of those

01:33:36,990 --> 01:33:41,520
models are close enough but without

01:33:38,880 --> 01:33:44,430
there's so many things break obviously

01:33:41,520 --> 01:33:46,050
every modern server EMC NetApp every

01:33:44,430 --> 01:33:48,030
other operating system the world except

01:33:46,050 --> 01:33:49,950
for a Linux supports that concept so

01:33:48,030 --> 01:33:51,240
that was his number one complaint his

01:33:49,950 --> 01:33:52,620
second was an interesting security

01:33:51,240 --> 01:33:56,550
problem that I hadn't thought about

01:33:52,620 --> 01:33:57,780
Buono follow is useless if you're a

01:33:56,550 --> 01:33:59,760
server developer and you're worried

01:33:57,780 --> 01:34:01,410
about somebody changing a path out from

01:33:59,760 --> 01:34:05,790
underneath you due to a symlink

01:34:01,410 --> 01:34:06,450
you need the whole path to not to be oh

01:34:05,790 --> 01:34:08,640
no follow

01:34:06,450 --> 01:34:10,440
oh no follow is only the tail end of the

01:34:08,640 --> 01:34:12,690
path so as a Samba developer they're

01:34:10,440 --> 01:34:14,520
dealing with really hard security

01:34:12,690 --> 01:34:17,040
problems where nasty people are trying

01:34:14,520 --> 01:34:21,360
to get it Etsy password or some evil

01:34:17,040 --> 01:34:26,190
path by using siblings so how do we make

01:34:21,360 --> 01:34:28,050
it so oh no follow is over the whole

01:34:26,190 --> 01:34:29,490
path not just the target so that was an

01:34:28,050 --> 01:34:30,720
interesting thing and of course he has

01:34:29,490 --> 01:34:32,520
the various things about locking and

01:34:30,720 --> 01:34:33,750
performance and nascent i/o and all that

01:34:32,520 --> 01:34:36,030
but those were the top two and they're

01:34:33,750 --> 01:34:38,400
kind of interesting so we as filesystem

01:34:36,030 --> 01:34:40,770
gulfs how do we fix this well okay

01:34:38,400 --> 01:34:42,480
what's my favorite problem copy I was

01:34:40,770 --> 01:34:44,850
experimenting a little bit with you know

01:34:42,480 --> 01:34:47,300
various platforms Windows Mac etc and

01:34:44,850 --> 01:34:50,340
one of the things I noticed was that

01:34:47,300 --> 01:34:54,240
robocopy a common tool that windows that

01:34:50,340 --> 01:34:57,360
means use parallel wise as IO why does

01:34:54,240 --> 01:34:59,820
that matter well when you do a something

01:34:57,360 --> 01:35:01,050
simple you take her laptop mount to

01:34:59,820 --> 01:35:03,000
something and then a files for SMB you

01:35:01,050 --> 01:35:04,620
pegged the CPU why are you pegging the

01:35:03,000 --> 01:35:07,110
CPU in some cases well the answer is

01:35:04,620 --> 01:35:09,369
because depending on your network copy

01:35:07,110 --> 01:35:14,889
offload and the adapter and such

01:35:09,369 --> 01:35:16,769
your i/o is not well parallelized your

01:35:14,889 --> 01:35:20,409
copying you know dozens of large files

01:35:16,769 --> 01:35:22,059
but you're not issuing many copies in

01:35:20,409 --> 01:35:23,379
parallel like robocopy would you're not

01:35:22,059 --> 01:35:25,360
issuing lots of IO and parallel from

01:35:23,379 --> 01:35:27,610
different processes so it tends to

01:35:25,360 --> 01:35:29,559
overuse one processor in peg so the

01:35:27,610 --> 01:35:31,449
performance is a lot worse than it

01:35:29,559 --> 01:35:34,209
should be for something as simple as

01:35:31,449 --> 01:35:35,649
copy ok and then there's a really

01:35:34,209 --> 01:35:38,860
interesting discussion that's been going

01:35:35,649 --> 01:35:40,989
on it's close to merge ready I think

01:35:38,860 --> 01:35:44,679
but although was talking about NFS copy

01:35:40,989 --> 01:35:46,209
offload why can't we allow NFS to decide

01:35:44,679 --> 01:35:49,300
whether it can copy from mount a to

01:35:46,209 --> 01:35:51,039
mount B SMB same thing why can't we let

01:35:49,300 --> 01:35:52,389
us and B or cluster file system decide

01:35:51,039 --> 01:35:54,610
you can copy from A to B because we're

01:35:52,389 --> 01:35:58,229
gonna copy it a lot faster than if you

01:35:54,610 --> 01:36:01,179
read every byte and write every byte

01:35:58,229 --> 01:36:04,539
right that's very expensive letting the

01:36:01,179 --> 01:36:07,719
backend filesystem do the copy is much

01:36:04,539 --> 01:36:11,050
faster than having every page read in

01:36:07,719 --> 01:36:13,229
and every page read written out in many

01:36:11,050 --> 01:36:16,689
cases this can be done in the backend

01:36:13,229 --> 01:36:19,149
literally a thousand times faster so

01:36:16,689 --> 01:36:22,479
this copy parallelization this allowing

01:36:19,149 --> 01:36:24,999
cross across mount copy from the same

01:36:22,479 --> 01:36:28,119
filesystem letting the filesystem do

01:36:24,999 --> 01:36:31,840
what it does best right let btrfs or XFS

01:36:28,119 --> 01:36:35,969
or NFS or SMB figure out or Gluster let

01:36:31,840 --> 01:36:39,909
it figure out what it can do don't limit

01:36:35,969 --> 01:36:41,829
the local filesystem artificially so we

01:36:39,909 --> 01:36:43,179
do too much sometimes in the DFS when a

01:36:41,829 --> 01:36:45,280
filesystem someone else could do it more

01:36:43,179 --> 01:36:48,309
efficiently and copy was just a blatant

01:36:45,280 --> 01:36:51,249
example of this so a fascinating example

01:36:48,309 --> 01:36:53,260
- or in many cluster file systems in

01:36:51,249 --> 01:36:56,829
many cloud file systems it's expensive

01:36:53,260 --> 01:36:58,479
to update metadata so our sync some

01:36:56,829 --> 01:37:00,610
other file systems had options or copy

01:36:58,479 --> 01:37:02,860
tools had options CP doesn't I don't

01:37:00,610 --> 01:37:07,269
think but has an option to set the file

01:37:02,860 --> 01:37:09,489
size once very fast now there's no

01:37:07,269 --> 01:37:13,580
metadata updates

01:37:09,489 --> 01:37:17,360
the standard linux copy tools when you

01:37:13,580 --> 01:37:19,429
copy every single block and sometimes

01:37:17,360 --> 01:37:21,020
these block sizes are quite small is

01:37:19,429 --> 01:37:22,429
updating metadata updating metadata

01:37:21,020 --> 01:37:32,030
updating metadata on every single

01:37:22,429 --> 01:37:35,869
extending right so question talk to so

01:37:32,030 --> 01:37:39,020
if you have an atomic set of your file

01:37:35,869 --> 01:37:41,199
size and then you copy in the data how

01:37:39,020 --> 01:37:46,040
is that not a security risk you're

01:37:41,199 --> 01:37:48,980
exposing potentially previous data that

01:37:46,040 --> 01:37:51,080
was on the hard drive within that file

01:37:48,980 --> 01:37:54,739
you know what I mean so you you say I

01:37:51,080 --> 01:37:57,230
want to copy a file that's one megabyte

01:37:54,739 --> 01:37:59,210
so you say you set the inode to say it's

01:37:57,230 --> 01:38:01,190
it's a megabyte and then you start

01:37:59,210 --> 01:38:03,349
loading in the data but you get a third

01:38:01,190 --> 01:38:05,330
of the way well the other 2/3 is

01:38:03,349 --> 01:38:07,639
whatever's already on the disk and has

01:38:05,330 --> 01:38:10,849
space allocated for it yeah that's a

01:38:07,639 --> 01:38:15,380
very good question so you know back to

01:38:10,849 --> 01:38:17,690
the to the general point a filesystem

01:38:15,380 --> 01:38:20,389
doesn't have to support all of these

01:38:17,690 --> 01:38:23,360
features so let's take the example of

01:38:20,389 --> 01:38:25,849
you know SMB or NFS right you could they

01:38:23,360 --> 01:38:27,260
support sparse files most cluster file

01:38:25,849 --> 01:38:29,900
system supports the parse file so that

01:38:27,260 --> 01:38:32,060
extending right it's empty nothing

01:38:29,900 --> 01:38:33,290
happened there is no data there there

01:38:32,060 --> 01:38:34,580
are no pages so there's no security

01:38:33,290 --> 01:38:36,469
exposure because you've said it to one

01:38:34,580 --> 01:38:39,320
megabyte any read of that will just

01:38:36,469 --> 01:38:43,280
return zeros because it's empty now CP

01:38:39,320 --> 01:38:45,050
itself supports sparse files so the CP

01:38:43,280 --> 01:38:48,500
command itself does check for sparse

01:38:45,050 --> 01:38:50,389
files but it doesn't set the file size

01:38:48,500 --> 01:38:53,330
first so you can have this extending

01:38:50,389 --> 01:38:55,310
right problem so if it detected a sparse

01:38:53,330 --> 01:38:58,179
file it would copy it more efficiently

01:38:55,310 --> 01:39:00,710
but it doesn't set the file size once

01:38:58,179 --> 01:39:02,119
now set the file size once there are no

01:39:00,710 --> 01:39:06,320
pages behind it so there's no security

01:39:02,119 --> 01:39:08,389
there's no data being leaked this isn't

01:39:06,320 --> 01:39:09,949
the key optimal for all file systems I'm

01:39:08,389 --> 01:39:11,900
not suggesting this is the default that

01:39:09,949 --> 01:39:13,369
you should move to but there are at

01:39:11,900 --> 01:39:15,280
least there is at least one tool in

01:39:13,369 --> 01:39:17,650
Linux and certainly Windows and Mac's

01:39:15,280 --> 01:39:21,940
that allow you to

01:39:17,650 --> 01:39:24,550
as a parameter do this which is a huge

01:39:21,940 --> 01:39:26,290
help when you have these weird back-end

01:39:24,550 --> 01:39:27,730
cluster file systems I'm sure that there

01:39:26,290 --> 01:39:29,140
guys out here working for NASA fenders

01:39:27,730 --> 01:39:32,670
that have strange cluster file systems

01:39:29,140 --> 01:39:37,480
where metadata ops are expensive and

01:39:32,670 --> 01:39:39,070
it's an example of a simple option it

01:39:37,480 --> 01:39:40,650
would be great to expand the sparse file

01:39:39,070 --> 01:39:43,860
support beyond CP

01:39:40,650 --> 01:39:46,719
okay back to i/o sizes so last I checked

01:39:43,860 --> 01:39:48,610
and Chuck could probably confirm NFS

01:39:46,719 --> 01:39:54,400
uses one Meg i/o by default I believe

01:39:48,610 --> 01:39:58,300
right SMB uses windows uses either one

01:39:54,400 --> 01:40:00,159
or eight we use for I saw a little bit

01:39:58,300 --> 01:40:03,429
worst performance Linux to Linux with

01:40:00,159 --> 01:40:06,400
eight so I I moved the SMB one to four

01:40:03,429 --> 01:40:08,580
Meg instead of eight Meg but the reason

01:40:06,400 --> 01:40:14,050
for a larger i/o is you know with these

01:40:08,580 --> 01:40:15,940
moderate network adapters basically get

01:40:14,050 --> 01:40:19,780
large packet sizes it's very efficient

01:40:15,940 --> 01:40:21,520
to send one mega or larger now you try

01:40:19,780 --> 01:40:23,500
the DD command you tried many of these

01:40:21,520 --> 01:40:29,710
commands if was unbuffered they're gonna

01:40:23,500 --> 01:40:32,140
copy 512 bytes 4k it's terrible and you

01:40:29,710 --> 01:40:36,250
know that's literally gonna be ten times

01:40:32,140 --> 01:40:39,219
slower or 50 times slower depending on

01:40:36,250 --> 01:40:41,980
your latency to copy that way then

01:40:39,219 --> 01:40:45,250
leveraging these larger i/o sizes so as

01:40:41,980 --> 01:40:46,690
you saw earlier I mentioned an XSS patch

01:40:45,250 --> 01:40:48,580
where they're dealing with larger block

01:40:46,690 --> 01:40:50,469
size is making block size larger than

01:40:48,580 --> 01:40:54,190
page size that introduced a lot of

01:40:50,469 --> 01:40:57,310
problems so how do we get the copy tool

01:40:54,190 --> 01:40:59,770
smart enough to copy the right sizes big

01:40:57,310 --> 01:41:02,980
enough so a cluster file system or these

01:40:59,770 --> 01:41:06,880
specialized file systems go faster you

01:41:02,980 --> 01:41:10,840
know this is 2018 not 1980 something

01:41:06,880 --> 01:41:14,320
where while 512 byte copy size might

01:41:10,840 --> 01:41:16,090
make sense okay rich Apple problem as I

01:41:14,320 --> 01:41:17,949
mentioned Jeremy Allison Google Samba

01:41:16,090 --> 01:41:19,449
team he viewed this as the number one

01:41:17,949 --> 01:41:21,280
problem with the Linux file system API

01:41:19,449 --> 01:41:22,989
it's been argued about for years what's

01:41:21,280 --> 01:41:26,469
the problem with this we have POSIX

01:41:22,989 --> 01:41:28,449
Ackles they don't support deny modes

01:41:26,469 --> 01:41:30,790
and unfortunately with government

01:41:28,449 --> 01:41:33,280
regulations European laws privacy laws

01:41:30,790 --> 01:41:35,350
HIPPA there are so many cases where you

01:41:33,280 --> 01:41:39,219
need narrow deny aces and a more

01:41:35,350 --> 01:41:41,199
complicated model Apache many of these

01:41:39,219 --> 01:41:44,020
web services have gone to a model where

01:41:41,199 --> 01:41:46,540
they allow very intricate claims for

01:41:44,020 --> 01:41:48,730
allowing or denying access decisions we

01:41:46,540 --> 01:41:52,090
have no such capability in Linux without

01:41:48,730 --> 01:41:55,090
some way of storing something that is

01:41:52,090 --> 01:41:57,850
richer than our current POSIX allow and

01:41:55,090 --> 01:42:01,210
even worse mode bits are somewhat

01:41:57,850 --> 01:42:03,580
painful to deal with now what about

01:42:01,210 --> 01:42:06,190
metadata every file system has been and

01:42:03,580 --> 01:42:10,090
data if you look at the NFS RFC NFS for

01:42:06,190 --> 01:42:11,620
two you'll see file system related mated

01:42:10,090 --> 01:42:14,469
it metadata you'll see various named

01:42:11,620 --> 01:42:17,590
attributes that can be returned on on on

01:42:14,469 --> 01:42:19,750
inodes you'll see various metadata that

01:42:17,590 --> 01:42:22,449
can be returned not just on the file

01:42:19,750 --> 01:42:24,250
system but also on files so it's same

01:42:22,449 --> 01:42:28,000
with smb3 you've got things that are

01:42:24,250 --> 01:42:29,699
unique to a window server or Mac server

01:42:28,000 --> 01:42:31,780
and you have things that actually are

01:42:29,699 --> 01:42:34,810
generic like I looked at the last set of

01:42:31,780 --> 01:42:36,250
flags let's say for argument's sake that

01:42:34,810 --> 01:42:38,050
you're sitting in Starbucks and you're

01:42:36,250 --> 01:42:40,360
mounted to a j''r because you're

01:42:38,050 --> 01:42:41,590
downloading your presentation or you've

01:42:40,360 --> 01:42:42,670
got a resume because you're talking to a

01:42:41,590 --> 01:42:46,350
new processor you're running you know

01:42:42,670 --> 01:42:51,010
Libre Office on a some smb3 mount to the

01:42:46,350 --> 01:42:53,110
city and Starbucks when you look at that

01:42:51,010 --> 01:42:55,840
you know it's in the cloud longer

01:42:53,110 --> 01:42:59,080
latency do you want to advertise that

01:42:55,840 --> 01:43:01,930
support to some apps because you know if

01:42:59,080 --> 01:43:05,920
you're a Mac you know they're a little

01:43:01,930 --> 01:43:08,620
finder it queries the icon as you bring

01:43:05,920 --> 01:43:10,780
up a window do you want to do that if

01:43:08,620 --> 01:43:12,250
it's loaded in the cloud if you have

01:43:10,780 --> 01:43:13,719
something that's cached in the backend

01:43:12,250 --> 01:43:15,460
server and the cloud you want to do that

01:43:13,719 --> 01:43:18,640
so I was looking at some of the flags

01:43:15,460 --> 01:43:20,199
relating to offline storage and things

01:43:18,640 --> 01:43:22,000
like that that were added and Windows

01:43:20,199 --> 01:43:23,590
recently they're just as important for

01:43:22,000 --> 01:43:26,199
Linux as they would be the Windows or

01:43:23,590 --> 01:43:28,660
Mac and I thought about this like why

01:43:26,199 --> 01:43:30,790
aren't we exposing more metadata we've

01:43:28,660 --> 01:43:34,180
been kind of conservative we've exposed

01:43:30,790 --> 01:43:35,560
the statics API but the number of flags

01:43:34,180 --> 01:43:37,090
you know we really could add a lot more

01:43:35,560 --> 01:43:39,780
and then similarly they have been

01:43:37,090 --> 01:43:44,230
discussion about the file system

01:43:39,780 --> 01:43:45,760
info you know there's no real harm in

01:43:44,230 --> 01:43:47,800
some of these cases because they apply

01:43:45,760 --> 01:43:49,510
to Windows just as well as they do to

01:43:47,800 --> 01:43:51,969
Linux or the Mac as well as they do to

01:43:49,510 --> 01:43:54,520
Linux they they're not just unique to

01:43:51,969 --> 01:43:57,130
one OS some of these actually some of

01:43:54,520 --> 01:43:59,290
these some of these flags

01:43:57,130 --> 01:44:02,560
does it have as an example this does it

01:43:59,290 --> 01:44:04,510
have extended integrity checks in other

01:44:02,560 --> 01:44:06,790
words is it a higher reliability file is

01:44:04,510 --> 01:44:08,469
that file marked for more integrity well

01:44:06,790 --> 01:44:10,000
that's a flag window supports you could

01:44:08,469 --> 01:44:12,610
also imagine this being supported in

01:44:10,000 --> 01:44:14,530
Linux where one file is mark is more

01:44:12,610 --> 01:44:16,929
reliable than another so you can set

01:44:14,530 --> 01:44:20,080
this file is more important okay

01:44:16,929 --> 01:44:25,480
so on big theme I want to talk about

01:44:20,080 --> 01:44:29,620
here sometimes the file system ext4 XFS

01:44:25,480 --> 01:44:32,710
letter FS NFS SMB knows more than the

01:44:29,620 --> 01:44:34,480
VFS layer it knows what block device

01:44:32,710 --> 01:44:35,410
it's on it knows the characteristics of

01:44:34,480 --> 01:44:40,179
the block device a little bit better

01:44:35,410 --> 01:44:41,830
perhaps it knows attributes of how it

01:44:40,179 --> 01:44:43,690
was formatted how its intended security

01:44:41,830 --> 01:44:46,690
issues it knows the identity of the user

01:44:43,690 --> 01:44:49,239
better it can optimize more efficiently

01:44:46,690 --> 01:44:51,250
sometimes in the VFS layer when you're

01:44:49,239 --> 01:44:53,380
copying from A to B if you give it to

01:44:51,250 --> 01:44:55,810
the file system sometimes the file

01:44:53,380 --> 01:44:58,020
system you know at the higher level the

01:44:55,810 --> 01:45:00,730
file system can do it more efficiently

01:44:58,020 --> 01:45:03,250
the low-level file system than than the

01:45:00,730 --> 01:45:06,910
mapping layer ok let's talk about some

01:45:03,250 --> 01:45:09,460
these cool features we've had over the

01:45:06,910 --> 01:45:12,960
past year some really neat changes for D

01:45:09,460 --> 01:45:15,340
doob we've had some great enhancements

01:45:12,960 --> 01:45:20,050
in the file system layer I think you saw

01:45:15,340 --> 01:45:21,340
that that's that a set of api's that we

01:45:20,050 --> 01:45:23,500
talked about earlier and you've seen the

01:45:21,340 --> 01:45:25,300
change rate in the file system now file

01:45:23,500 --> 01:45:28,239
systems are one of the most active areas

01:45:25,300 --> 01:45:29,410
of Linux kernel I think one of the

01:45:28,239 --> 01:45:30,820
problems we're going to have is how do

01:45:29,410 --> 01:45:34,270
we get together and discuss this well

01:45:30,820 --> 01:45:37,179
good news next year we have vault

01:45:34,270 --> 01:45:39,460
B starting after a one-year absence we

01:45:37,179 --> 01:45:40,960
also have the file system summit we have

01:45:39,460 --> 01:45:42,960
the storage developer conference every

01:45:40,960 --> 01:45:45,370
year and of course that'll be also in

01:45:42,960 --> 01:45:48,070
tel-aviv in January there'll be another

01:45:45,370 --> 01:45:49,750
one so we'll have two storage developer

01:45:48,070 --> 01:45:50,840
conferences next year one in the fall

01:45:49,750 --> 01:45:53,630
and then

01:45:50,840 --> 01:45:56,540
in January lots of opportunities discuss

01:45:53,630 --> 01:45:58,840
these storage features but what's

01:45:56,540 --> 01:46:03,560
probably more important than any of this

01:45:58,840 --> 01:46:05,840
testing so I think as you've seen every

01:46:03,560 --> 01:46:09,620
file system uses XFS test despite its

01:46:05,840 --> 01:46:12,530
name there are lots of file here's an

01:46:09,620 --> 01:46:15,170
example from my sips code of a wiki that

01:46:12,530 --> 01:46:17,120
I set up for this Ted so who apply seen

01:46:15,170 --> 01:46:19,280
wandering around has done a really good

01:46:17,120 --> 01:46:22,660
job on showing how to automate X the

01:46:19,280 --> 01:46:25,280
best testing for his example of ext4

01:46:22,660 --> 01:46:27,890
we need to add to it we need to increase

01:46:25,280 --> 01:46:29,390
it it's a really nice bucket for dumping

01:46:27,890 --> 01:46:30,590
all of the tests because what's our goal

01:46:29,390 --> 01:46:33,680
to make sure all the stuff works

01:46:30,590 --> 01:46:35,380
reliably so you know far more important

01:46:33,680 --> 01:46:41,270
than anything else here I think is is

01:46:35,380 --> 01:46:44,360
getting this testing as Samba you know

01:46:41,270 --> 01:46:45,980
Samba has a developer kind of culture

01:46:44,360 --> 01:46:47,210
that every time you put a new feature in

01:46:45,980 --> 01:46:49,550
you have to put the test case in first

01:46:47,210 --> 01:46:51,920
we're not quite as good about that in in

01:46:49,550 --> 01:46:54,560
the kernel VFS but you know it sometimes

01:46:51,920 --> 01:46:55,880
come sometimes were able to do that but

01:46:54,560 --> 01:46:59,830
this is an area where I really want to

01:46:55,880 --> 01:47:03,590
hammer how important that is okay so

01:46:59,830 --> 01:47:05,180
we've got a couple minutes left and the

01:47:03,590 --> 01:47:08,590
problem is that everybody here knows

01:47:05,180 --> 01:47:12,170
more than I do about their particular

01:47:08,590 --> 01:47:14,390
whatever so let's open up some questions

01:47:12,170 --> 01:47:16,880
I see some in the back let me hand the

01:47:14,390 --> 01:47:21,250
VMware a block out so you can ask it and

01:47:16,880 --> 01:47:21,250
see what pain points most interest you

01:47:22,450 --> 01:47:26,060
it's been a while since I've worked on

01:47:24,410 --> 01:47:30,200
file systems I actually worked for

01:47:26,060 --> 01:47:31,580
Microsoft one of the innovations that

01:47:30,200 --> 01:47:33,860
happened probably about five six years

01:47:31,580 --> 01:47:36,800
ago was you know just like offload copy

01:47:33,860 --> 01:47:39,220
offload there was also the trim offload

01:47:36,800 --> 01:47:41,510
right yes which was the unused space

01:47:39,220 --> 01:47:43,640
allocations being sent down to the

01:47:41,510 --> 01:47:46,580
device is that going anywhere is that

01:47:43,640 --> 01:47:47,000
widely adopted yeah that's a really good

01:47:46,580 --> 01:47:49,460
question

01:47:47,000 --> 01:47:52,060
trim offload and any opinions here about

01:47:49,460 --> 01:47:52,060
trim offload

01:47:54,300 --> 01:47:57,690
you know one of the things that we also

01:47:56,429 --> 01:48:00,570
ought to talk about is there is this

01:47:57,690 --> 01:48:03,179
wonderful t10 like API that similar to

01:48:00,570 --> 01:48:06,389
in a SMB and out of s have a similar way

01:48:03,179 --> 01:48:08,099
of supporting this some of the features

01:48:06,389 --> 01:48:09,780
and that being able to handle block

01:48:08,099 --> 01:48:11,670
device offload a little bit better so

01:48:09,780 --> 01:48:14,790
it's the file system is mapping it down

01:48:11,670 --> 01:48:18,530
to the block layer these are interesting

01:48:14,790 --> 01:48:24,389
things to think about I find fascinating

01:48:18,530 --> 01:48:26,449
any comments about that guys so what

01:48:24,389 --> 01:48:35,540
favorite pain points do you guys have

01:48:26,449 --> 01:48:35,540
you guys let me get I can't talk to you

01:48:35,690 --> 01:48:41,219
this is actually more of a user space

01:48:38,449 --> 01:48:43,829
thing but the kernel provides a lot of

01:48:41,219 --> 01:48:46,650
facilities for making things a bit

01:48:43,829 --> 01:48:49,530
easier like file says file copies and

01:48:46,650 --> 01:48:50,760
various metadata updates but when you're

01:48:49,530 --> 01:48:52,860
writing code that actually makes use of

01:48:50,760 --> 01:48:56,670
them you end up having to write rewrite

01:48:52,860 --> 01:48:58,139
the same sort of fall back to like oh

01:48:56,670 --> 01:49:00,809
well this kernel is too old

01:48:58,139 --> 01:49:02,670
this kernels too old yep and also like

01:49:00,809 --> 01:49:05,880
oh do I can I use ref links here can I

01:49:02,670 --> 01:49:08,369
use send file here it'd be quite useful

01:49:05,880 --> 01:49:09,570
to have a library for sort of common

01:49:08,369 --> 01:49:12,059
file system operations

01:49:09,570 --> 01:49:14,639
please use whatever the most efficient

01:49:12,059 --> 01:49:16,920
operation this kernel supports to do

01:49:14,639 --> 01:49:19,860
this operation yeah that's actually a

01:49:16,920 --> 01:49:21,059
very good point so one of you guys some

01:49:19,860 --> 01:49:25,380
of you guys might remember there was a

01:49:21,059 --> 01:49:28,139
discussion I just saw about gee let's

01:49:25,380 --> 01:49:30,960
see do you guys did you guys follow that

01:49:28,139 --> 01:49:33,179
gee Lipsy versus the kernel owning the

01:49:30,960 --> 01:49:35,099
mapping of these so for argument's sake

01:49:33,179 --> 01:49:37,590
say you add some user space API that's

01:49:35,099 --> 01:49:39,480
useful the problem is that the kernel

01:49:37,590 --> 01:49:41,340
developer who wrote that now has a sis

01:49:39,480 --> 01:49:44,010
call that's exposed in a really ugly way

01:49:41,340 --> 01:49:46,889
and no library to call that so you have

01:49:44,010 --> 01:49:48,270
a completely separate team over here and

01:49:46,889 --> 01:49:51,329
a completely separate file system team

01:49:48,270 --> 01:49:53,190
over here and as an app developer you

01:49:51,329 --> 01:49:55,320
don't see a library that matches the

01:49:53,190 --> 01:49:58,349
kernel you're calling gee Lipsy which is

01:49:55,320 --> 01:50:00,239
unrelated to your kernel so it's a

01:49:58,349 --> 01:50:02,219
difficult thing we're typically in

01:50:00,239 --> 01:50:03,809
Windows or Mac or whatever your your

01:50:02,219 --> 01:50:06,949
user space library in your kernel you

01:50:03,809 --> 01:50:06,949
would see the entry point

01:50:07,250 --> 01:50:10,220
or you wouldn't if you didn't see the

01:50:08,240 --> 01:50:11,660
entry point you know not to call it so

01:50:10,220 --> 01:50:12,800
you know your example of ref link or

01:50:11,660 --> 01:50:15,710
whatever is a good one

01:50:12,800 --> 01:50:21,470
so one of the other fascinating things

01:50:15,710 --> 01:50:23,360
is metadata so how do I insist see if I

01:50:21,470 --> 01:50:26,600
can support the ref link API call

01:50:23,360 --> 01:50:30,700
well I query metadata on the file system

01:50:26,600 --> 01:50:33,110
on the target and look okay it

01:50:30,700 --> 01:50:34,700
advertises support for block ref County

01:50:33,110 --> 01:50:37,520
okay if it's sports block ref counting

01:50:34,700 --> 01:50:39,080
its sports roughly okay that's easy but

01:50:37,520 --> 01:50:40,760
I have no way of telling the user the

01:50:39,080 --> 01:50:43,970
app don't even bother calling hreflang I

01:50:40,760 --> 01:50:46,250
have the I'm querying this I can dump it

01:50:43,970 --> 01:50:48,050
to debug data but there's no Stata fess

01:50:46,250 --> 01:50:49,990
API call number Dave hell's I've

01:50:48,050 --> 01:50:52,820
mentioned Dave Howells patch so what

01:50:49,990 --> 01:50:55,970
your app could query that file system

01:50:52,820 --> 01:50:57,230
doesn't support hreflang I mean would if

01:50:55,970 --> 01:50:59,060
you mounted did this server but not this

01:50:57,230 --> 01:51:01,460
server or you would if you mounted here

01:50:59,060 --> 01:51:03,200
but not here I know that and so I can

01:51:01,460 --> 01:51:05,390
return yup not supported but it would be

01:51:03,200 --> 01:51:07,670
nice in your app if you could query the

01:51:05,390 --> 01:51:08,660
Stata fess and get that back and I think

01:51:07,670 --> 01:51:10,070
that was one of the intents of date

01:51:08,660 --> 01:51:13,190
Howell's patch to allow filesystem to

01:51:10,070 --> 01:51:15,860
return more information and if you look

01:51:13,190 --> 01:51:19,100
at the NFS RFC for 4.2 if you look at

01:51:15,860 --> 01:51:20,930
the SMB protocol standard documentation

01:51:19,100 --> 01:51:22,220
you'll see there's quite a bit of

01:51:20,930 --> 01:51:24,700
metadata like this that would be

01:51:22,220 --> 01:51:26,900
valuable for app developers to get query

01:51:24,700 --> 01:51:29,540
so they could make decisions about how

01:51:26,900 --> 01:51:31,070
to compensate user space without going

01:51:29,540 --> 01:51:34,100
through really convoluted error paths

01:51:31,070 --> 01:51:36,530
and the problem is not the errors paths

01:51:34,100 --> 01:51:37,850
the problem is the error numbers one

01:51:36,530 --> 01:51:39,650
filesystem is gonna return yup not

01:51:37,850 --> 01:51:42,020
supported one's gonna return e IO and

01:51:39,650 --> 01:51:45,140
others gonna return you know end so

01:51:42,020 --> 01:51:47,630
you're it'll confuse your app so it's a

01:51:45,140 --> 01:51:51,950
it's really quite painful for some of

01:51:47,630 --> 01:51:54,610
these features so what what other pain

01:51:51,950 --> 01:51:57,610
points you guys have some favorite ones

01:51:54,610 --> 01:51:57,610
yeah

01:52:00,959 --> 01:52:08,159
so I guess I'm just wondering when the

01:52:03,689 --> 01:52:11,130
next thing comes along I mean or if we

01:52:08,159 --> 01:52:13,949
are evolving our current things into the

01:52:11,130 --> 01:52:16,289
next thing so I see a lot of I mean

01:52:13,949 --> 01:52:19,800
we've got with XFS we recently got ref

01:52:16,289 --> 01:52:22,860
links I've seen plans to internalize

01:52:19,800 --> 01:52:25,409
that capability and perhaps bring XFS

01:52:22,860 --> 01:52:26,010
the capability to do snapshots or things

01:52:25,409 --> 01:52:28,650
like this

01:52:26,010 --> 01:52:30,539
we've got butter FS but honestly I don't

01:52:28,650 --> 01:52:31,889
know is anybody convinced that's going

01:52:30,539 --> 01:52:34,340
to mature to the point that it's

01:52:31,889 --> 01:52:38,760
supported by Enterprise distributions

01:52:34,340 --> 01:52:40,860
when are we going to get to the point

01:52:38,760 --> 01:52:44,789
where we've got purpose-built file

01:52:40,860 --> 01:52:47,459
systems for modern storage you know not

01:52:44,789 --> 01:52:48,179
spinning media Apple had one come out

01:52:47,459 --> 01:52:52,010
recently

01:52:48,179 --> 01:52:53,239
it's got thin provisioning snapshotting

01:52:52,010 --> 01:52:55,679
checksumming

01:52:53,239 --> 01:52:57,329
redundancy capabilities all of these

01:52:55,679 --> 01:52:59,369
modern things if we want those things

01:52:57,329 --> 01:53:01,800
now we have to stack it up through

01:52:59,369 --> 01:53:04,439
device mapper use the file systems that

01:53:01,800 --> 01:53:06,900
we have I mean what is on the horizon

01:53:04,439 --> 01:53:10,199
this is a these are I think you've

01:53:06,900 --> 01:53:14,130
phrased it extremely well so let's step

01:53:10,199 --> 01:53:16,019
back 10,000 feet if you knew somebody

01:53:14,130 --> 01:53:17,610
you know know maybe there's some guys in

01:53:16,019 --> 01:53:20,719
their 60s here who could go pull out

01:53:17,610 --> 01:53:24,389
college textbooks maybe guys in the 70s

01:53:20,719 --> 01:53:25,920
it's really interesting file system

01:53:24,389 --> 01:53:28,439
problems happen I mean there's still

01:53:25,920 --> 01:53:31,499
there's stuff in the 60s in file system

01:53:28,439 --> 01:53:34,199
texts that still apply so these aren't

01:53:31,499 --> 01:53:35,820
new second thing you bring up a lot of

01:53:34,199 --> 01:53:40,139
really good points

01:53:35,820 --> 01:53:46,260
purpose-built file systems I think that

01:53:40,139 --> 01:53:48,090
we have enormous work to do but it's

01:53:46,260 --> 01:53:49,439
focused largely on a few local file

01:53:48,090 --> 01:53:52,110
systems and then the cluster Network

01:53:49,439 --> 01:53:53,429
rings right because there aren't I mean

01:53:52,110 --> 01:53:55,619
if you look at the file system activity

01:53:53,429 --> 01:53:57,689
it's really for local file systems it's

01:53:55,619 --> 01:54:01,079
maniacal focus on four or five file

01:53:57,689 --> 01:54:03,030
systems locally that's it it's not like

01:54:01,079 --> 01:54:04,409
you know this isn't you know JFS and

01:54:03,030 --> 01:54:06,090
riser efest and all these it's not

01:54:04,409 --> 01:54:11,250
nobody cares about these right we've got

01:54:06,090 --> 01:54:14,230
it's it's really and as you said XFS

01:54:11,250 --> 01:54:17,790
rather than eating btrfs has the

01:54:14,230 --> 01:54:20,890
reputation for more enterprise workloads

01:54:17,790 --> 01:54:22,900
but I think that the bigger problem is

01:54:20,890 --> 01:54:24,550
that distros that we tend to use I mean

01:54:22,900 --> 01:54:26,170
a lot of people are using rel how old is

01:54:24,550 --> 01:54:28,930
rel kernel it's basically four or five

01:54:26,170 --> 01:54:31,780
years old many of the features that

01:54:28,930 --> 01:54:33,100
actually are in XFS and butter FS users

01:54:31,780 --> 01:54:35,620
aren't aware of because they're running

01:54:33,100 --> 01:54:39,160
now what's the most recent stable distro

01:54:35,620 --> 01:54:43,350
kernel probably bun - right what's that

01:54:39,160 --> 01:54:45,520
415 how old is it almost a year right so

01:54:43,350 --> 01:54:47,110
there's been a lot of activity that

01:54:45,520 --> 01:54:49,780
you're not seeing in what people

01:54:47,110 --> 01:54:52,780
actually run and I think unlike Windows

01:54:49,780 --> 01:54:54,610
or Mac you're not saying rollouts of

01:54:52,780 --> 01:54:56,650
these new features in service upgrades

01:54:54,610 --> 01:54:57,850
every six months you're seeing some

01:54:56,650 --> 01:54:59,470
usual space changes but a lot of these

01:54:57,850 --> 01:55:01,660
key kernel features for XFS aren't

01:54:59,470 --> 01:55:03,340
getting there it's fascinating you

01:55:01,660 --> 01:55:05,560
mentioned snapshots because you know I

01:55:03,340 --> 01:55:08,890
remember the snapshot support for four

01:55:05,560 --> 01:55:12,940
XFS experimental stuff many years ago so

01:55:08,890 --> 01:55:15,310
this is a this is something that you

01:55:12,940 --> 01:55:16,960
know is very important it's it's it's a

01:55:15,310 --> 01:55:18,760
lot of effort to produce these new

01:55:16,960 --> 01:55:20,770
features and it takes a long time to

01:55:18,760 --> 01:55:22,660
bake them in which is why I guess I'm

01:55:20,770 --> 01:55:25,840
wondering why we haven't gotten started

01:55:22,660 --> 01:55:27,460
on maybe the next thing yet or as I said

01:55:25,840 --> 01:55:29,620
it could be that we're just evolving

01:55:27,460 --> 01:55:31,390
these things but you mentioned that some

01:55:29,620 --> 01:55:32,890
of these concepts have been around since

01:55:31,390 --> 01:55:35,890
the beginning I mean I remember reading

01:55:32,890 --> 01:55:37,210
about the BFS file system and how they

01:55:35,890 --> 01:55:38,980
developed that with the extended

01:55:37,210 --> 01:55:41,020
attributes and everything but it was

01:55:38,980 --> 01:55:42,730
very much centered around this idea of

01:55:41,020 --> 01:55:44,620
spinning media with locality of

01:55:42,730 --> 01:55:47,230
reference and all these things it's

01:55:44,620 --> 01:55:48,820
still there and in in XFS with

01:55:47,230 --> 01:55:51,850
allocation groups and things like this

01:55:48,820 --> 01:55:54,760
what I'm talking about is like with the

01:55:51,850 --> 01:56:01,450
modern hardware you you want to do more

01:55:54,760 --> 01:56:03,090
I mean like trims and you know a garbage

01:56:01,450 --> 01:56:07,630
collection and things like this so

01:56:03,090 --> 01:56:09,670
copy-on-write semantics and you know

01:56:07,630 --> 01:56:11,320
things that'll preserve that Hardware

01:56:09,670 --> 01:56:13,570
you're no longer concerned about the

01:56:11,320 --> 01:56:15,850
sorts of things that you were tied to

01:56:13,570 --> 01:56:18,780
before I think these points are great

01:56:15,850 --> 01:56:20,800
now I remember back in the IBM days

01:56:18,780 --> 01:56:22,660
Linux architect all that dealing with

01:56:20,800 --> 01:56:24,460
file system questions I was witnessing

01:56:22,660 --> 01:56:28,420
this argument between LVM

01:56:24,460 --> 01:56:30,460
and the IBM equivalent one of the things

01:56:28,420 --> 01:56:32,830
that's fascinating is we've constructed

01:56:30,460 --> 01:56:35,440
an abstraction layer that's about as bad

01:56:32,830 --> 01:56:39,010
as possible for some workloads because

01:56:35,440 --> 01:56:42,130
it hides from the guy who needs it you

01:56:39,010 --> 01:56:43,840
know utter fsor XFS the physical

01:56:42,130 --> 01:56:46,810
attributes of the device underneath it

01:56:43,840 --> 01:56:50,080
in some cases so it's much easier to lie

01:56:46,810 --> 01:56:52,570
to beat your FS or XFS about the actual

01:56:50,080 --> 01:56:54,580
characteristics because ultimately the

01:56:52,570 --> 01:56:56,560
placement of those blocks is dependent

01:56:54,580 --> 01:56:58,360
on many things that only the file system

01:56:56,560 --> 01:57:00,070
is aware of and yet we're in this world

01:56:58,360 --> 01:57:02,500
where we're making assumptions as you

01:57:00,070 --> 01:57:06,160
say that are directly tied to spinning

01:57:02,500 --> 01:57:09,250
disks not modern SSDs much less the ten

01:57:06,160 --> 01:57:12,969
to a hundred times faster and VMI's at

01:57:09,250 --> 01:57:14,469
home I have an nvme it's really cool to

01:57:12,969 --> 01:57:17,350
get multiple gigabytes per second

01:57:14,469 --> 01:57:19,630
copying but it's not optimal because the

01:57:17,350 --> 01:57:21,810
file systems weren't designed to handle

01:57:19,630 --> 01:57:25,870
I mean you can go on Amazon and get a

01:57:21,810 --> 01:57:27,400
relatively cheap nvme our file systems

01:57:25,870 --> 01:57:28,570
aren't optimized for that yet at the

01:57:27,400 --> 01:57:29,790
same time some of the back-end cloud

01:57:28,570 --> 01:57:32,110
file systems and some of these

01:57:29,790 --> 01:57:35,320
specialized file systems behind NFS

01:57:32,110 --> 01:57:36,610
appliances or samba appliances are but

01:57:35,320 --> 01:57:39,100
how do we get these a little bit broader

01:57:36,610 --> 01:57:41,580
I think this is a very good point you

01:57:39,100 --> 01:57:44,830
make so the other thing too is that I

01:57:41,580 --> 01:57:48,340
you brought up a good point about having

01:57:44,830 --> 01:57:50,140
the all these separate layers you have

01:57:48,340 --> 01:57:51,910
the file system who's trying to think in

01:57:50,140 --> 01:57:54,190
terms of spinning or rotational media

01:57:51,910 --> 01:57:55,719
but you have thin provisioning caching

01:57:54,190 --> 01:57:58,420
and things like this at the device

01:57:55,719 --> 01:58:01,540
mapper layer or whatever but there are

01:57:58,420 --> 01:58:04,900
ways where I don't know how it'd be

01:58:01,540 --> 01:58:06,550
possible but but if if the file system

01:58:04,900 --> 01:58:10,450
could communicate better with the block

01:58:06,550 --> 01:58:13,840
layer you could do more strategic things

01:58:10,450 --> 01:58:15,400
about you know say when you pre allocate

01:58:13,840 --> 01:58:18,070
or something you could tell thin

01:58:15,400 --> 01:58:20,920
provisioning in the block layer to do

01:58:18,070 --> 01:58:23,950
that allocation you could use there's a

01:58:20,920 --> 01:58:26,890
new target now it's called DM write

01:58:23,950 --> 01:58:29,860
cache and it's a streaming write cache

01:58:26,890 --> 01:58:32,620
and you could do vectored atomic writes

01:58:29,860 --> 01:58:36,040
with that target in which case you could

01:58:32,620 --> 01:58:37,820
eliminate journaling so if there was the

01:58:36,040 --> 01:58:39,920
API in there

01:58:37,820 --> 01:58:42,140
available to talk between them I think

01:58:39,920 --> 01:58:43,520
these are very important and some of we

01:58:42,140 --> 01:58:44,660
think some of these may be touched on

01:58:43,520 --> 01:58:45,950
later in the conference and they

01:58:44,660 --> 01:58:47,660
certainly were touched on the storage

01:58:45,950 --> 01:58:48,800
developer conference but one of the

01:58:47,660 --> 01:58:52,610
things I want to throw out to you guys

01:58:48,800 --> 01:58:56,900
just how does a change or a model when

01:58:52,610 --> 01:58:59,080
storage is almost as fast as RAM you

01:58:56,900 --> 01:59:03,560
know persistent storage

01:58:59,080 --> 01:59:05,630
Ram overlapping address spaces nvme is

01:59:03,560 --> 01:59:07,430
so fast that there's times when in the

01:59:05,630 --> 01:59:09,080
address space it needs to be exposed

01:59:07,430 --> 01:59:10,460
this changes all kinds of things this is

01:59:09,080 --> 01:59:12,200
not my area obviously this is not

01:59:10,460 --> 01:59:15,160
something I deal with every day but it

01:59:12,200 --> 01:59:20,690
changes how we think about file systems

01:59:15,160 --> 01:59:23,840
when we have storage this fast now back

01:59:20,690 --> 01:59:26,390
to your snapshot question snapshots are

01:59:23,840 --> 01:59:30,410
evolving I added snapshot support just

01:59:26,390 --> 01:59:32,480
what 418 kernel in Linux client so the

01:59:30,410 --> 01:59:33,710
SMB client can view snapshots what are

01:59:32,480 --> 01:59:36,080
the hell we have to deal with you

01:59:33,710 --> 01:59:37,970
mentioned timestamps well the timestamps

01:59:36,080 --> 01:59:41,060
come in one format GMT and they go out

01:59:37,970 --> 01:59:42,710
in another format like so I queried a

01:59:41,060 --> 01:59:44,720
server with I have to do a specialized I

01:59:42,710 --> 01:59:46,520
out pool for it and then I want to mount

01:59:44,720 --> 01:59:48,740
with a snapshot just so you can see your

01:59:46,520 --> 01:59:51,110
older copy of you know the mounts to

01:59:48,740 --> 01:59:52,310
various older copies of it I have to you

01:59:51,110 --> 01:59:53,840
know these are the kinds of hell the

01:59:52,310 --> 01:59:55,370
little tiny things that you deal with

01:59:53,840 --> 01:59:58,310
but one of the things I'm fascinated

01:59:55,370 --> 01:59:59,780
about is how do I tie something like

01:59:58,310 --> 02:00:03,590
smb3 which is had snapshot support

01:59:59,780 --> 02:00:05,110
forever how do I tie my version which is

02:00:03,590 --> 02:00:07,340
now implemented in the latest client

02:00:05,110 --> 02:00:10,640
rather late compared to Windows how do I

02:00:07,340 --> 02:00:13,250
tie that into the more usable

02:00:10,640 --> 02:00:15,230
infrastructure that Linux user space

02:00:13,250 --> 02:00:16,670
tools provide instead of having to do

02:00:15,230 --> 02:00:19,130
kind of hacks like you know specifying

02:00:16,670 --> 02:00:23,330
on the mount these are challenges and

02:00:19,130 --> 02:00:26,090
they valve very slowly in Linux some

02:00:23,330 --> 02:00:28,220
that firstly did anybody else have a

02:00:26,090 --> 02:00:33,830
question before I I don't want to drone

02:00:28,220 --> 02:00:36,140
on so the you're right about the the

02:00:33,830 --> 02:00:37,490
fast devices and stuff like it makes us

02:00:36,140 --> 02:00:39,230
rethink some of these things right now

02:00:37,490 --> 02:00:41,270
as I said we have kind of this device

02:00:39,230 --> 02:00:46,160
map or stack and then file system at the

02:00:41,270 --> 02:00:48,260
top I think about the next file system

02:00:46,160 --> 02:00:51,620
quite a lot because what it might look

02:00:48,260 --> 02:00:51,960
like because with env enemy because the

02:00:51,620 --> 02:00:54,060
file

02:00:51,960 --> 02:00:56,040
system might be the place where you

02:00:54,060 --> 02:00:58,680
would want to know about snapshots and

02:00:56,040 --> 02:01:00,510
encryption and deduplication and all of

02:00:58,680 --> 02:01:03,060
these other modern things and then write

02:01:00,510 --> 02:01:05,820
it out once without it knows exactly

02:01:03,060 --> 02:01:07,469
where it's going in one shot if you have

02:01:05,820 --> 02:01:10,290
all this remapping underneath you're

02:01:07,469 --> 02:01:12,630
adding just the milliseconds of you know

02:01:10,290 --> 02:01:15,030
extra operations to get the remapping

02:01:12,630 --> 02:01:17,940
done and stuff we recently did some work

02:01:15,030 --> 02:01:19,860
to try and future-proof ourself a little

02:01:17,940 --> 02:01:23,160
bit against some of these things by

02:01:19,860 --> 02:01:26,400
speeding up device mapper a bit but it

02:01:23,160 --> 02:01:29,940
you know I think that layering does add

02:01:26,400 --> 02:01:33,650
latency the latency matters I mean we're

02:01:29,940 --> 02:01:37,770
dealing with stuff with insanely fast

02:01:33,650 --> 02:01:39,510
Layton sees within vme today but also

02:01:37,770 --> 02:01:42,000
we're dealing with NFS and s and be

02:01:39,510 --> 02:01:43,560
running over our DMA so the network

02:01:42,000 --> 02:01:47,310
connection to that back-end storage is

02:01:43,560 --> 02:01:48,420
insanely low latency and yet we're

02:01:47,310 --> 02:01:51,239
adding all these layers in the backend

02:01:48,420 --> 02:01:54,510
that are defeating a lot of the value we

02:01:51,239 --> 02:01:58,050
have there so I think that that being

02:01:54,510 --> 02:02:00,060
able to expose this to butter FS or XFS

02:01:58,050 --> 02:02:01,500
to your local filesystem is very

02:02:00,060 --> 02:02:06,030
important but I want to give you another

02:02:01,500 --> 02:02:08,219
example why today on a filesystem you

02:02:06,030 --> 02:02:10,080
might have a movie that you're editing

02:02:08,219 --> 02:02:12,510
it might have an index that's more

02:02:10,080 --> 02:02:15,030
important quality so you might want to

02:02:12,510 --> 02:02:16,680
mark it for higher integrity butter FS

02:02:15,030 --> 02:02:18,900
could do that or x FS could do that

02:02:16,680 --> 02:02:20,820
where it marked one file with different

02:02:18,900 --> 02:02:22,350
attributes than another based on some

02:02:20,820 --> 02:02:24,510
i/o pattern based on an owner based on

02:02:22,350 --> 02:02:28,230
security based on the app saying this

02:02:24,510 --> 02:02:30,390
matter is more block device doesn't know

02:02:28,230 --> 02:02:33,630
anything about this so how do you do

02:02:30,390 --> 02:02:36,390
this in a way so butter FS and x FS can

02:02:33,630 --> 02:02:37,830
expose real workloads where one file

02:02:36,390 --> 02:02:40,200
matters a thousand times more than

02:02:37,830 --> 02:02:41,640
another there was a wonderful storage

02:02:40,200 --> 02:02:43,680
developer conference presentation I

02:02:41,640 --> 02:02:48,890
recommend going back years you can find

02:02:43,680 --> 02:02:53,930
it where they showed how data integrity

02:02:48,890 --> 02:02:57,090
matters now in a world where the I the

02:02:53,930 --> 02:02:58,770
sizes are going from you know megabytes

02:02:57,090 --> 02:03:01,340
to gigabytes to petabytes right we're

02:02:58,770 --> 02:03:01,340
now the

02:03:02,310 --> 02:03:10,630
error rate is similar to what it was 20

02:03:06,400 --> 02:03:12,880
years ago but the data sites are so much

02:03:10,630 --> 02:03:14,170
bigger so the data sets much bigger but

02:03:12,880 --> 02:03:16,780
the error rates the same we have an

02:03:14,170 --> 02:03:21,219
impossible problem to solve right we are

02:03:16,780 --> 02:03:22,510
creating sort of we are going to die

02:03:21,219 --> 02:03:25,810
we're all going to blow up in some

02:03:22,510 --> 02:03:28,929
horrible accident because data rates

02:03:25,810 --> 02:03:33,489
sorry data sizes are so big and those

02:03:28,929 --> 02:03:35,619
bit flips are now happening far more

02:03:33,489 --> 02:03:38,170
often just simply because of the math we

02:03:35,619 --> 02:03:40,449
now have bigger sets of data so fast

02:03:38,170 --> 02:03:42,880
anything one of the videos I thought I

02:03:40,449 --> 02:03:45,310
was screaming at his disc drive stack

02:03:42,880 --> 02:03:47,710
and watching the error rates change as

02:03:45,310 --> 02:03:49,060
he screamed at is just of course this

02:03:47,710 --> 02:03:50,860
wouldn't be a factor with SSE but I

02:03:49,060 --> 02:03:52,679
thought was fascinating to look at that

02:03:50,860 --> 02:03:56,139
something as simple as yelling at your

02:03:52,679 --> 02:04:00,130
rack of disks actually and it was a

02:03:56,139 --> 02:04:02,920
great video could affect the error rate

02:04:00,130 --> 02:04:05,860
so we we have to think about integrity

02:04:02,920 --> 02:04:07,719
end to end that means from the NFS or

02:04:05,860 --> 02:04:10,929
SMB client or it's a cluster client all

02:04:07,719 --> 02:04:12,040
the way down through the XFS file system

02:04:10,929 --> 02:04:14,830
all the way down to the block layer all

02:04:12,040 --> 02:04:16,980
the way down this is a end-to-end

02:04:14,830 --> 02:04:20,320
integrity problem that we have to solve

02:04:16,980 --> 02:04:24,070
and it's getting worse so I was

02:04:20,320 --> 02:04:25,599
fascinated by that by that problem but I

02:04:24,070 --> 02:04:26,440
do recommend if you go to the storage of

02:04:25,599 --> 02:04:29,800
El poor conference there's some

02:04:26,440 --> 02:04:35,949
wonderful presentations in past years on

02:04:29,800 --> 02:04:37,239
some of these topics ok thank you guys

02:04:35,949 --> 02:04:39,630
for your time there are lots of file

02:04:37,239 --> 02:04:41,650
system developers lurking around here so

02:04:39,630 --> 02:04:43,179
you know obviously bring forth your

02:04:41,650 --> 02:04:44,409
questions and Linux F Festival is a

02:04:43,179 --> 02:04:47,440
great place to ask these kind of

02:04:44,409 --> 02:04:52,350
questions and once again please send

02:04:47,440 --> 02:04:57,409
patches and test cases ok thank you guys

02:04:52,350 --> 02:04:57,409

YouTube URL: https://www.youtube.com/watch?v=EFLJrz4FmCM


