Title: LPC2018 - Android and the kernel: herding billions of penguins, one version at a time
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/61/
speaker:  Todd Kjos (Google), Sandeep Patil (Google)


Historically, kernels that ran on Android devices have typically been 2+ years old compared to mainline (this year's flagship devices are shipping with 4.9 kernels) and because of the challenges associated with updating, most devices in the field are far behind the latest long-term stable (LTS) releases. The Android team has been gradually putting in place the necessary processes and enhancements to permanently bridge this gap. Much of the work on the Android kernel in 2018 focused on improving the ability to update the kernel -- at least to recent LTS levels. This work comprises a significant testing effort to ensure downstream partners that updating to new LTS levels is safe, as well as process work to convince partners that the security benefits of taking LTS patches far outweigh the risk of new bugs. The testing also focuses on ABI consistency (within LTS releases) for interfaces relied upon by userspace and kernel modules. This has resulted in enhancements to the LTP suite and a new proposal to the mailing list for "kernel namespaces".

Additionally, the Android kernel testing benefits from additional tools developed by Google that are enabled via the Clang compiler. Google's devices have been shipping kernels built via Clang for 2 years. The Android team tests and assists in maintaining arm and arm64 kernel builds with clang.

The talk will also cover some of the key features being developed for Android and introduce topics that will be discussed during the Android Micro-Conference.
Captions: 
	00:00:06,160 --> 00:00:13,619
hey everyone my name is Sandeep Patil I

00:00:09,100 --> 00:00:16,240
work on Android systems team in Google I

00:00:13,619 --> 00:00:19,570
wanted to talk to you to everyone and

00:00:16,240 --> 00:00:22,179
basically tell you about how and how we

00:00:19,570 --> 00:00:25,570
are managed maintaining Linux kernels

00:00:22,179 --> 00:00:28,359
with respect to Android how has Android

00:00:25,570 --> 00:00:30,249
progress from we talked about similar

00:00:28,359 --> 00:00:33,520
things last year and polymers as well

00:00:30,249 --> 00:00:34,960
the things that we've done over the past

00:00:33,520 --> 00:00:36,400
year the things that we are continuing

00:00:34,960 --> 00:00:42,340
to doing and the changes that we've made

00:00:36,400 --> 00:00:43,960
to the process to to how we work to and

00:00:42,340 --> 00:00:47,800
to basically even in terms of

00:00:43,960 --> 00:00:49,510
contribution we also discuss the

00:00:47,800 --> 00:00:51,160
problems that were talked about last

00:00:49,510 --> 00:00:53,500
year and over the last year about

00:00:51,160 --> 00:00:56,410
Android and how Android manages kernel

00:00:53,500 --> 00:00:58,150
of what pitfalls are what problems we

00:00:56,410 --> 00:00:59,590
have when we're dealing when we're

00:00:58,150 --> 00:01:03,310
dealing with kernel that is basically

00:00:59,590 --> 00:01:06,280
outside of Android platform to get into

00:01:03,310 --> 00:01:09,250
that so basically the overall agenda

00:01:06,280 --> 00:01:11,710
that I wanted that I just split in about

00:01:09,250 --> 00:01:14,109
four different parts is life of an

00:01:11,710 --> 00:01:18,670
Android device this is actually talked

00:01:14,109 --> 00:01:21,579
about written in very much great details

00:01:18,670 --> 00:01:24,369
by none other than Gregg even on Android

00:01:21,579 --> 00:01:26,740
comm for example about why Android

00:01:24,369 --> 00:01:29,619
kernels are the way they are how they

00:01:26,740 --> 00:01:32,590
start how they continue to be maintained

00:01:29,619 --> 00:01:35,200
in and why do for example to answer the

00:01:32,590 --> 00:01:36,639
try to answer actually think a simple

00:01:35,200 --> 00:01:38,170
question but why does an Android device

00:01:36,639 --> 00:01:40,389
basically end up starting with the

00:01:38,170 --> 00:01:43,630
kernel that's already 2 years old and

00:01:40,389 --> 00:01:46,929
why does it never catch up so the life

00:01:43,630 --> 00:01:48,729
of team icicles is basically a simple

00:01:46,929 --> 00:01:52,179
diagram that I wanted to walk everyone

00:01:48,729 --> 00:01:54,569
through and set the base of the problem

00:01:52,179 --> 00:01:56,889
and then we go into details about

00:01:54,569 --> 00:01:59,350
specifics in the Android problems

00:01:56,889 --> 00:02:00,909
followed by the changes that we've made

00:01:59,350 --> 00:02:03,759
and are in the process of making in

00:02:00,909 --> 00:02:06,670
order to solve them our kernel

00:02:03,759 --> 00:02:09,039
development process project travel was

00:02:06,670 --> 00:02:11,560
one of the biggest undertaking Android

00:02:09,039 --> 00:02:14,439
took from Android olio and Android PI

00:02:11,560 --> 00:02:15,490
for example and that has affected how we

00:02:14,439 --> 00:02:17,050
do cones

00:02:15,490 --> 00:02:19,240
how Android interacts with Colonel what

00:02:17,050 --> 00:02:21,040
are the expectations for Android is a

00:02:19,240 --> 00:02:22,840
platform from kernel and weisswurst I as

00:02:21,040 --> 00:02:26,230
well so we go into details for that as

00:02:22,840 --> 00:02:28,120
well and now and then I'll probably

00:02:26,230 --> 00:02:32,530
gonna have a lot of time for questions

00:02:28,120 --> 00:02:35,140
as well at the end all right so that's

00:02:32,530 --> 00:02:37,060
the life of an Android device go for

00:02:35,140 --> 00:02:39,100
example if this diagram has been

00:02:37,060 --> 00:02:41,890
repeated about five times over already

00:02:39,100 --> 00:02:44,380
it's also on source android comm the

00:02:41,890 --> 00:02:46,780
easiest but the part that I want to

00:02:44,380 --> 00:02:49,060
basically allow elaborate on in terms of

00:02:46,780 --> 00:02:53,140
the Android device code is the third

00:02:49,060 --> 00:02:55,330
line in this pretty much Android common

00:02:53,140 --> 00:02:57,070
is the kernel that we maintain long term

00:02:55,330 --> 00:03:00,250
stable is something that's maintained by

00:02:57,070 --> 00:03:02,560
Grieg for example upstream or we know

00:03:00,250 --> 00:03:04,870
Android common current whenever LTS

00:03:02,560 --> 00:03:07,660
release is declared we basically start

00:03:04,870 --> 00:03:09,550
the Android common kernel to patch it

00:03:07,660 --> 00:03:12,310
with the out of tree Android patches and

00:03:09,550 --> 00:03:15,910
that process is fairly quick it has been

00:03:12,310 --> 00:03:17,350
reduced down to weeks the compared to

00:03:15,910 --> 00:03:19,780
months now and we're going to talk about

00:03:17,350 --> 00:03:21,700
that later as well about how we ended up

00:03:19,780 --> 00:03:23,110
doing that but the third line here is

00:03:21,700 --> 00:03:25,030
the most important that's the kernel

00:03:23,110 --> 00:03:26,920
that basically can run on the hardware

00:03:25,030 --> 00:03:29,140
that's going to show up in an Android

00:03:26,920 --> 00:03:32,590
phone because that's the very first time

00:03:29,140 --> 00:03:34,870
for example let's walk to you let me

00:03:32,590 --> 00:03:37,000
walk you through a saying SOC lifetime

00:03:34,870 --> 00:03:38,950
well aren't actually talk just about it

00:03:37,000 --> 00:03:40,060
briefly in his previous track like all

00:03:38,950 --> 00:03:42,340
embedded devices interpreting

00:03:40,060 --> 00:03:44,950
two-year-old kernels the reason is

00:03:42,340 --> 00:03:48,250
because if I'm a hardware manufacturer

00:03:44,950 --> 00:03:50,680
I'm specifying an SOC I start with the

00:03:48,250 --> 00:03:53,680
specification probably an RTL design and

00:03:50,680 --> 00:03:55,900
emulator and most of the manufactures

00:03:53,680 --> 00:03:58,060
are pretty good at keeping up with what

00:03:55,900 --> 00:03:59,920
is upstream what is mainline current so

00:03:58,060 --> 00:04:01,780
they'll follow Linnaeus this branch plus

00:03:59,920 --> 00:04:05,200
whatever out of three changes they have

00:04:01,780 --> 00:04:07,150
they keep merging from from RC to RC or

00:04:05,200 --> 00:04:10,000
each major or minor version to minor

00:04:07,150 --> 00:04:12,490
version as long as they're validating

00:04:10,000 --> 00:04:14,230
the emulator and RTL designs as soon as

00:04:12,490 --> 00:04:16,870
for example the chip tapes out though

00:04:14,230 --> 00:04:19,660
that kernel is now that kernel is

00:04:16,870 --> 00:04:21,840
actually used to validate if the chip is

00:04:19,660 --> 00:04:25,300
working right a lot of times

00:04:21,840 --> 00:04:27,070
Android itself is actually used to

00:04:25,300 --> 00:04:28,680
validate whether that chip is working

00:04:27,070 --> 00:04:30,780
okay or not and there's a

00:04:28,680 --> 00:04:32,940
advantage here because that means you're

00:04:30,780 --> 00:04:35,639
bringing up is actually done before the

00:04:32,940 --> 00:04:37,110
strip is out and then you're confident

00:04:35,639 --> 00:04:40,169
enough because you have been doing a

00:04:37,110 --> 00:04:44,190
generation over generations that the

00:04:40,169 --> 00:04:45,840
software is right and mostly accurate to

00:04:44,190 --> 00:04:47,940
be able to validate how the hardware is

00:04:45,840 --> 00:04:49,680
coming out to me so there are for

00:04:47,940 --> 00:04:52,979
example even in let's say factory setup

00:04:49,680 --> 00:04:54,270
you're not only its kernel and some

00:04:52,979 --> 00:04:56,880
command-line tools its kernel and

00:04:54,270 --> 00:04:58,289
Android booted and people and I've even

00:04:56,880 --> 00:05:00,539
seen adb commands done in order to

00:04:58,289 --> 00:05:02,639
validate a particular hardware so and

00:05:00,539 --> 00:05:05,789
all of that is possible because the SOC

00:05:02,639 --> 00:05:08,250
manufacturer in this case started using

00:05:05,789 --> 00:05:11,580
upstream kernel right when it was in the

00:05:08,250 --> 00:05:14,130
RTL phase but now that they've done so

00:05:11,580 --> 00:05:17,430
much when the chip came out it is it

00:05:14,130 --> 00:05:18,960
becomes plus the Android bringing up a

00:05:17,430 --> 00:05:20,960
sample that's when though these

00:05:18,960 --> 00:05:23,400
associates now start getting into a

00:05:20,960 --> 00:05:25,320
boards or reference device and the

00:05:23,400 --> 00:05:28,889
boards that basically probably will end

00:05:25,320 --> 00:05:32,550
up in a full that after that point

00:05:28,889 --> 00:05:34,770
onwards it is considered a lot riskier

00:05:32,550 --> 00:05:36,720
proposition for example to basically

00:05:34,770 --> 00:05:39,330
overall all the software from kernel

00:05:36,720 --> 00:05:41,310
upwards including Android in order to be

00:05:39,330 --> 00:05:42,720
in order to make a phone so what ends up

00:05:41,310 --> 00:05:44,430
happening is most of the manufacturer

00:05:42,720 --> 00:05:47,010
end up snapping to the long term stable

00:05:44,430 --> 00:05:48,360
kernel that was that is the latest at

00:05:47,010 --> 00:05:50,430
that time because they've been following

00:05:48,360 --> 00:05:52,650
the mainline and kill them usually

00:05:50,430 --> 00:05:55,050
around the end of the year long term

00:05:52,650 --> 00:05:57,080
stable kernel is declared and so that's

00:05:55,050 --> 00:06:00,300
the kernel that they end up snapping to

00:05:57,080 --> 00:06:04,650
let's put a fake timeline let's say that

00:06:00,300 --> 00:06:06,870
happened at the end of 2016 and 2017 at

00:06:04,650 --> 00:06:09,510
the beginning of 2017 basically they

00:06:06,870 --> 00:06:11,580
snap to that kernel they merged Android

00:06:09,510 --> 00:06:13,710
patches from Android common if you will

00:06:11,580 --> 00:06:16,409
because we get requests to about how do

00:06:13,710 --> 00:06:18,720
we run Android with this car and now

00:06:16,409 --> 00:06:22,349
that SOC kernel is basically frozen in

00:06:18,720 --> 00:06:24,990
time in terms of kernel major and minor

00:06:22,349 --> 00:06:27,539
widget the the actual product from that

00:06:24,990 --> 00:06:28,860
SOC is what we call the device kernel

00:06:27,539 --> 00:06:32,330
because now that SOC gets put on the

00:06:28,860 --> 00:06:34,560
board and an OEM and ODM starts making

00:06:32,330 --> 00:06:38,460
products with it which again is a long

00:06:34,560 --> 00:06:40,070
cycle with many stakeholders in between

00:06:38,460 --> 00:06:44,699
whether it's carriers whether it's

00:06:40,070 --> 00:06:46,440
Factory whether it's so that process the

00:06:44,699 --> 00:06:49,949
latest for example what we what you

00:06:46,440 --> 00:06:52,740
would see that SOC on in a device at

00:06:49,949 --> 00:06:57,449
let's say from the 2016 timeline let's

00:06:52,740 --> 00:06:59,130
say about q2 2018 so if that one started

00:06:57,449 --> 00:07:01,530
with doing all the things right that

00:06:59,130 --> 00:07:03,720
they could with the latest LTS that was

00:07:01,530 --> 00:07:06,000
available to them at the point of time

00:07:03,720 --> 00:07:07,800
the SOC was made the only the first

00:07:06,000 --> 00:07:11,699
device with that SOC actually showed up

00:07:07,800 --> 00:07:13,770
in about a year and a half later which

00:07:11,699 --> 00:07:15,750
means with the two-year LTS you're

00:07:13,770 --> 00:07:16,949
already close to end of life and your

00:07:15,750 --> 00:07:19,610
kernel support is gone by the time you

00:07:16,949 --> 00:07:23,070
launch an Android device oh and that's

00:07:19,610 --> 00:07:25,260
basically how Android device kernels get

00:07:23,070 --> 00:07:27,539
made up and pretty much every single one

00:07:25,260 --> 00:07:30,449
of them is different even though they

00:07:27,539 --> 00:07:34,139
ultimately started at the same point of

00:07:30,449 --> 00:07:36,510
origin in LTS we don't change the

00:07:34,139 --> 00:07:39,389
Android common kernel nearly as enough

00:07:36,510 --> 00:07:41,160
after for example a particular the

00:07:39,389 --> 00:07:42,919
number of features that are required for

00:07:41,160 --> 00:07:53,970
a particular Android desert release

00:07:42,919 --> 00:07:56,360
sorry and basically how it's that means

00:07:53,970 --> 00:07:59,610
every single Android device has its own

00:07:56,360 --> 00:08:01,289
kernel if you will even even if it's the

00:07:59,610 --> 00:08:05,310
same SOC because it gets modified here

00:08:01,289 --> 00:08:11,280
every which way along the way well and

00:08:05,310 --> 00:08:14,789
based so that basically breaks down into

00:08:11,280 --> 00:08:16,229
multiple problems that have been again

00:08:14,789 --> 00:08:19,590
discussed but I'm gonna reiterate this

00:08:16,229 --> 00:08:22,650
and stressing on some point here so what

00:08:19,590 --> 00:08:24,630
ends up that that entire process ends up

00:08:22,650 --> 00:08:27,810
creating for example Android devices

00:08:24,630 --> 00:08:30,780
have older kernels I think I just talked

00:08:27,810 --> 00:08:33,810
about why that is but it in some cases

00:08:30,780 --> 00:08:37,050
it's also older than two year old for

00:08:33,810 --> 00:08:40,890
example and an SOC is not necessarily

00:08:37,050 --> 00:08:42,750
tied to the time of life in the market

00:08:40,890 --> 00:08:45,300
the same is to see that I shipped a

00:08:42,750 --> 00:08:48,090
device with in 2018 there's no reason

00:08:45,300 --> 00:08:50,010
why a new device in 2019 can't be

00:08:48,090 --> 00:08:52,170
we configured with the same as you see

00:08:50,010 --> 00:08:53,970
so that SOC lives longer the longer it

00:08:52,170 --> 00:08:55,800
lives the older kernel you are seeing on

00:08:53,970 --> 00:08:57,330
Android devices as well so it's not only

00:08:55,800 --> 00:09:01,920
just two year old it can be three year

00:08:57,330 --> 00:09:04,290
old even we are managing multiple kernel

00:09:01,920 --> 00:09:06,450
versions this is something that we end

00:09:04,290 --> 00:09:08,839
up dealing with every time Android as a

00:09:06,450 --> 00:09:12,210
platform I think about two years ago

00:09:08,839 --> 00:09:13,650
literally made a single statement about

00:09:12,210 --> 00:09:14,930
what it needs from kernel which is that

00:09:13,650 --> 00:09:16,470
it should have a binder driver and

00:09:14,930 --> 00:09:19,260
that's it pretty much

00:09:16,470 --> 00:09:23,490
so what that ends up do making is there

00:09:19,260 --> 00:09:25,260
was no so you would see kernels from

00:09:23,490 --> 00:09:28,680
three to two three four to three

00:09:25,260 --> 00:09:30,750
fourteen sixteen eighteen or and four

00:09:28,680 --> 00:09:32,880
four four and all sorts of them and what

00:09:30,750 --> 00:09:35,640
that means is now that platform cannot

00:09:32,880 --> 00:09:37,529
make any assumptions whatsoever in terms

00:09:35,640 --> 00:09:39,570
of what kernel it will be running on so

00:09:37,529 --> 00:09:41,640
if I want to use the latest and greatest

00:09:39,570 --> 00:09:44,130
feature that was added in say for nine

00:09:41,640 --> 00:09:46,260
kernel and I want to make sure I can use

00:09:44,130 --> 00:09:48,390
it on all the Android devices as of

00:09:46,260 --> 00:09:50,130
Android platform developer I cannot make

00:09:48,390 --> 00:09:51,540
that assumption so my so the Android

00:09:50,130 --> 00:09:54,690
platform code ends up having this

00:09:51,540 --> 00:09:56,339
peggotty where oh if it's if this is

00:09:54,690 --> 00:09:57,420
supported make sure you can use this if

00:09:56,339 --> 00:09:59,339
this is not supported to make sure you

00:09:57,420 --> 00:10:02,180
can use that extra extra and that just

00:09:59,339 --> 00:10:06,750
makes it even more complicated

00:10:02,180 --> 00:10:09,839
the slower non-existent kernel updates

00:10:06,750 --> 00:10:12,350
is is the other problem because of how

00:10:09,839 --> 00:10:15,870
those kernels flow downstream into

00:10:12,350 --> 00:10:18,330
Android devices or even if for example

00:10:15,870 --> 00:10:20,370
our stable kernels have up there get get

00:10:18,330 --> 00:10:21,690
pretty much weekly updates we've been

00:10:20,370 --> 00:10:24,180
merging into Android commands it's

00:10:21,690 --> 00:10:27,000
really difficult because of the large

00:10:24,180 --> 00:10:29,700
amount of Android out of three code for

00:10:27,000 --> 00:10:31,380
those updates to be merged into the SOC

00:10:29,700 --> 00:10:34,170
and down into the device check device

00:10:31,380 --> 00:10:35,880
device cannot but even that I think

00:10:34,170 --> 00:10:37,080
we've come around to come around to

00:10:35,880 --> 00:10:38,220
solve and I'm going to talk more about

00:10:37,080 --> 00:10:39,839
that later as well

00:10:38,220 --> 00:10:41,640
the biggest problem after that is

00:10:39,839 --> 00:10:43,290
basically making those updates available

00:10:41,640 --> 00:10:47,130
to users on the in the field and for

00:10:43,290 --> 00:10:49,410
that oh now basically there are multiple

00:10:47,130 --> 00:10:51,110
logistical hurdles holds the hurdles

00:10:49,410 --> 00:10:53,580
that always come around which is around

00:10:51,110 --> 00:10:55,110
security like how do we know that this

00:10:53,580 --> 00:10:58,830
if you're having

00:10:55,110 --> 00:11:00,360
saying 200 bug fixes then how do we

00:10:58,830 --> 00:11:00,990
validate these two hundred bucks fixes

00:11:00,360 --> 00:11:02,310
of not breaking

00:11:00,990 --> 00:11:03,779
something that is crucial whether its

00:11:02,310 --> 00:11:06,060
performance whether it's an actual bug

00:11:03,779 --> 00:11:08,520
and we've taken steps in order to give

00:11:06,060 --> 00:11:10,260
that confidence to everyone whether it's

00:11:08,520 --> 00:11:12,570
carriers whether it's OMS and audience

00:11:10,260 --> 00:11:14,370
in order to feel confident that LT has

00:11:12,570 --> 00:11:16,589
changes as they are flowing into the

00:11:14,370 --> 00:11:20,730
kernel are being tested every along

00:11:16,589 --> 00:11:23,430
every which along the way forth problem

00:11:20,730 --> 00:11:25,620
their errors as of last year there was

00:11:23,430 --> 00:11:28,529
no continuous integration for kernels

00:11:25,620 --> 00:11:30,839
with respect to Android oh there's a

00:11:28,529 --> 00:11:33,870
batch if let's say main line get updated

00:11:30,839 --> 00:11:36,240
from RC 1 to RC to the Android testing

00:11:33,870 --> 00:11:37,980
for that kernel is voluntary

00:11:36,240 --> 00:11:41,550
I think Amit who does a great job of

00:11:37,980 --> 00:11:43,470
maintaining AMT on Android Google sort

00:11:41,550 --> 00:11:45,089
come for example he would test go ingest

00:11:43,470 --> 00:11:47,850
an Android device or Android board that

00:11:45,089 --> 00:11:50,580
he has available like an Heike and what

00:11:47,850 --> 00:11:52,740
manually import it so there's and there

00:11:50,580 --> 00:11:55,830
is literally no SIA and this is true

00:11:52,740 --> 00:11:58,470
even if we have four or five kernel

00:11:55,830 --> 00:12:01,709
versions there is nothing that verifies

00:11:58,470 --> 00:12:03,779
that a patch in the kernel can let's say

00:12:01,709 --> 00:12:06,240
for 14 curve when we don't have a for 14

00:12:03,779 --> 00:12:08,880
device at hand can work with Android

00:12:06,240 --> 00:12:11,220
does it's basically it's there it's a

00:12:08,880 --> 00:12:13,410
patch it's a forward probe from 4/9 to

00:12:11,220 --> 00:12:15,300
414 for example but there is nothing

00:12:13,410 --> 00:12:19,529
that can verify that as of today and

00:12:15,300 --> 00:12:23,550
we're fixing that to fifth problem and

00:12:19,529 --> 00:12:25,680
this is big it planes we would hear from

00:12:23,550 --> 00:12:28,050
kernel developers and we also have the

00:12:25,680 --> 00:12:30,450
same problem even as Android kernel or

00:12:28,050 --> 00:12:32,250
platform delivers is that we can't run

00:12:30,450 --> 00:12:34,890
or test mainline kernels with Android

00:12:32,250 --> 00:12:36,600
today oh because there is no device that

00:12:34,890 --> 00:12:40,829
would have a mainline kernel running OH

00:12:36,600 --> 00:12:41,850
the latest you would find is about one

00:12:40,829 --> 00:12:45,510
and a half year old

00:12:41,850 --> 00:12:48,930
LTS car being run on on one of the

00:12:45,510 --> 00:12:50,760
latest flagship devices for example and

00:12:48,930 --> 00:12:52,410
last but not the least which I think

00:12:50,760 --> 00:12:54,360
everyone knows about is millions of lies

00:12:52,410 --> 00:12:56,430
about out of 3 code there are two

00:12:54,360 --> 00:12:58,709
contributors to it obviously one is us

00:12:56,430 --> 00:12:59,850
from Android because we also have tend

00:12:58,709 --> 00:13:01,620
to have a bunch of our total code in

00:12:59,850 --> 00:13:03,149
Android common and of course then there

00:13:01,620 --> 00:13:07,020
is the hardware specific code that

00:13:03,149 --> 00:13:10,970
supports each SOC virtually so let's get

00:13:07,020 --> 00:13:10,970
into each one of them one at a time

00:13:11,949 --> 00:13:17,959
order multiple kernels like I said when

00:13:15,160 --> 00:13:22,339
until two years ago we didn't have any

00:13:17,959 --> 00:13:25,939
of this about around Oreo I think I

00:13:22,339 --> 00:13:27,559
talked about we have Android devices

00:13:25,939 --> 00:13:31,480
that basically get launched with earlier

00:13:27,559 --> 00:13:33,619
we have a 318 for four and four nine

00:13:31,480 --> 00:13:34,910
requirement of such so for example if a

00:13:33,619 --> 00:13:38,449
device has been launched with oh you

00:13:34,910 --> 00:13:40,999
can't be on a curve with a kernel that

00:13:38,449 --> 00:13:42,379
is any older than 318 now again 318 is

00:13:40,999 --> 00:13:44,419
still about three years old at the

00:13:42,379 --> 00:13:46,699
earlier time by the way or maybe two

00:13:44,419 --> 00:13:49,399
years old at door time but it's still

00:13:46,699 --> 00:13:51,290
better than having Oreo ASIS with 3/4

00:13:49,399 --> 00:13:55,069
because it gives it releases your data

00:13:51,290 --> 00:13:57,739
said immediately that happened with Pi

00:13:55,069 --> 00:13:59,449
we stepped it up a notch because we

00:13:57,739 --> 00:14:01,369
wanted to make sure all the updates that

00:13:59,449 --> 00:14:03,889
we are doing whatever contributions

00:14:01,369 --> 00:14:05,809
we're making the LTS changes are

00:14:03,889 --> 00:14:07,759
actually showing up on Android devices

00:14:05,809 --> 00:14:11,109
because once a device was launched with

00:14:07,759 --> 00:14:15,049
say for for--why there was nothing that

00:14:11,109 --> 00:14:18,139
basically checked or had any use for oil

00:14:15,049 --> 00:14:20,059
will not use any check for those devices

00:14:18,139 --> 00:14:21,949
being upgraded to a later stable of

00:14:20,059 --> 00:14:25,069
kernel version so what we did in order

00:14:21,949 --> 00:14:27,139
to kind of mitigate that is with PI we

00:14:25,069 --> 00:14:28,790
added the stable patch version at the

00:14:27,139 --> 00:14:30,799
end of each of minimum kernel version so

00:14:28,790 --> 00:14:32,540
instead of saying the minimum kernel

00:14:30,799 --> 00:14:34,369
should be four four or four nine and

00:14:32,540 --> 00:14:40,399
four fourteen we are now saying for for

00:14:34,369 --> 00:14:42,319
107 +49 84 plus and for 14 42 plus so

00:14:40,399 --> 00:14:44,119
the for 984 is pretty much what you

00:14:42,319 --> 00:14:46,429
would end up seeing in most of the

00:14:44,119 --> 00:14:49,459
flagship devices for example which is

00:14:46,429 --> 00:14:51,739
still again that one and a half to two

00:14:49,459 --> 00:14:53,419
years delay from the main one but the

00:14:51,739 --> 00:14:56,989
good part about is the LTS patch

00:14:53,419 --> 00:15:00,110
versions are down two months then years

00:14:56,989 --> 00:15:02,660
older instead of so and there is a story

00:15:00,110 --> 00:15:04,699
about 107 and why that happened so we've

00:15:02,660 --> 00:15:06,769
been doing this for about two years with

00:15:04,699 --> 00:15:08,179
Greg and there's exactly one occasion

00:15:06,769 --> 00:15:11,119
when we found a bug in stable kernel

00:15:08,179 --> 00:15:13,609
that because the fear has always been oh

00:15:11,119 --> 00:15:15,259
if we take stable kernel and which is

00:15:13,609 --> 00:15:17,509
like 50 to hundreds of patches every

00:15:15,259 --> 00:15:19,220
week we never know what bugs and

00:15:17,509 --> 00:15:22,279
regressions is going to introduce to

00:15:19,220 --> 00:15:23,480
users and devices because because

00:15:22,279 --> 00:15:24,740
we don't want to regress devices that's

00:15:23,480 --> 00:15:28,189
basically the argument that you would

00:15:24,740 --> 00:15:31,399
get from updating data but we've been

00:15:28,189 --> 00:15:33,110
doing this for about two years and there

00:15:31,399 --> 00:15:35,689
is exactly one occasion and which is why

00:15:33,110 --> 00:15:40,699
therefore for 1:07 happened instead of

00:15:35,689 --> 00:15:42,620
for for 1:26 I think because in for for

00:15:40,699 --> 00:15:44,629
108 unfortunately there is a bug that

00:15:42,620 --> 00:15:47,059
got introduced in one of the USB

00:15:44,629 --> 00:15:49,999
controllers which we found out through

00:15:47,059 --> 00:15:51,829
the CI that I'll talk about and then

00:15:49,999 --> 00:15:54,079
that got fixed we reported that got

00:15:51,829 --> 00:15:55,579
fixed in for for 128 but we just didn't

00:15:54,079 --> 00:15:58,129
have enough time to basically update and

00:15:55,579 --> 00:15:59,449
run the wool best and triage and

00:15:58,129 --> 00:16:05,360
everything that's why it was stuck at

00:15:59,449 --> 00:16:09,860
four for one second right so that at

00:16:05,360 --> 00:16:11,899
least gets us to having minimum say LTS

00:16:09,860 --> 00:16:15,559
patch version which is months older than

00:16:11,899 --> 00:16:18,800
what it is today which is great ah but

00:16:15,559 --> 00:16:21,499
the problem of Android must continue to

00:16:18,800 --> 00:16:24,769
work with following kernel version still

00:16:21,499 --> 00:16:26,990
doesn't solve with PI we can expect the

00:16:24,769 --> 00:16:29,540
kernels though with the device launched

00:16:26,990 --> 00:16:30,889
kernels will be at least 4 4 n+ but we

00:16:29,540 --> 00:16:32,839
still have updates we will obviously

00:16:30,889 --> 00:16:36,470
want users and everyone to upgrade

00:16:32,839 --> 00:16:39,290
Android devices from Oreo to PI or new

00:16:36,470 --> 00:16:41,420
go to PI for example in those cases we

00:16:39,290 --> 00:16:43,160
still as a platform have to continue

00:16:41,420 --> 00:16:46,250
working with older kernels that's why I

00:16:43,160 --> 00:16:48,500
highlight at 4 9 4 14 4 19 let's say

00:16:46,250 --> 00:16:50,990
we're taking a progression from Iran

00:16:48,500 --> 00:16:52,730
from a year from now but we still have

00:16:50,990 --> 00:16:54,829
to continue working with 318 and for 4

00:16:52,730 --> 00:16:57,769
we can't just assume a new feature

00:16:54,829 --> 00:17:01,519
introduced in 49 even though for mine is

00:16:57,769 --> 00:17:03,100
the minimum kernel version let's say is

00:17:01,519 --> 00:17:06,110
going to exist in all Android devices

00:17:03,100 --> 00:17:08,510
you have so the code the platform code

00:17:06,110 --> 00:17:11,480
still doesn't go away so the platform

00:17:08,510 --> 00:17:14,959
deprecation effectively is about 6 years

00:17:11,480 --> 00:17:20,419
or 5 to 6 years instead of 3 years even

00:17:14,959 --> 00:17:23,179
if you have caused adding CI a few

00:17:20,419 --> 00:17:24,559
things happened since last year or they

00:17:23,179 --> 00:17:26,350
were in process even when we talked

00:17:24,559 --> 00:17:29,679
about it last year as well but there

00:17:26,350 --> 00:17:32,149
we've been working with Lin ro there's a

00:17:29,679 --> 00:17:33,059
portal core QA reports totally neuro

00:17:32,149 --> 00:17:36,419
dot-org

00:17:33,059 --> 00:17:39,149
and we've been reporting the kernel

00:17:36,419 --> 00:17:41,159
function test which is a part of which

00:17:39,149 --> 00:17:42,539
uses a test suite that we added that we

00:17:41,159 --> 00:17:46,460
introduced as part of project trouble

00:17:42,539 --> 00:17:49,499
and and many more and it tests the Linux

00:17:46,460 --> 00:17:53,370
mainline I think next are C and stable

00:17:49,499 --> 00:17:55,379
and reports all of those all of those

00:17:53,370 --> 00:17:57,659
test results to the mailing list this is

00:17:55,379 --> 00:17:59,639
the first I think I don't know if it was

00:17:57,659 --> 00:18:04,019
the first time but we are I think this

00:17:59,639 --> 00:18:06,240
is running arm 32 I'm 64 x86 and as many

00:18:04,019 --> 00:18:08,009
arm hardware as we we can get hands on

00:18:06,240 --> 00:18:10,529
in order to test upstream kernels to

00:18:08,009 --> 00:18:11,879
make sure like boot and tests and all of

00:18:10,529 --> 00:18:14,220
those sanity checks are not basically

00:18:11,879 --> 00:18:15,929
baking kernel CI has been doing this

00:18:14,220 --> 00:18:18,330
adding everyone knows about kernels GI

00:18:15,929 --> 00:18:20,009
currency also test downstream into

00:18:18,330 --> 00:18:23,009
android common kernel for example once

00:18:20,009 --> 00:18:24,749
LTS really dismayed it gets merged into

00:18:23,009 --> 00:18:27,659
android common kernel so that's where it

00:18:24,749 --> 00:18:30,450
gets tested again with elk eft as well

00:18:27,659 --> 00:18:33,299
as with kernel CI with kernel CI we get

00:18:30,450 --> 00:18:36,059
boot coverage on about adding 200 plus

00:18:33,299 --> 00:18:38,700
boards we've been contributing to the

00:18:36,059 --> 00:18:41,490
linux test project ourselves we've been

00:18:38,700 --> 00:18:43,580
introduced adding more and more tests

00:18:41,490 --> 00:18:48,570
for system call and this is basically

00:18:43,580 --> 00:18:51,149
not - this is basically testing for

00:18:48,570 --> 00:18:53,580
correctness we want to make sure when

00:18:51,149 --> 00:18:56,340
our android is platform is expecting a

00:18:53,580 --> 00:18:57,720
system call to work in a way and be

00:18:56,340 --> 00:18:59,999
written in error return a particular

00:18:57,720 --> 00:19:02,999
error in a way it does that on all

00:18:59,999 --> 00:19:04,830
devices because if that's been let's say

00:19:02,999 --> 00:19:06,869
a profile is not changed in a way that

00:19:04,830 --> 00:19:08,580
now suddenly something can't pass

00:19:06,869 --> 00:19:10,740
because there's a new field added in the

00:19:08,580 --> 00:19:15,149
device kernel in a certain for example

00:19:10,740 --> 00:19:17,279
so we've been doing that the pre submit

00:19:15,149 --> 00:19:18,960
testing on android curl is something

00:19:17,279 --> 00:19:20,610
that we're starting up or we've started

00:19:18,960 --> 00:19:22,139
builds with it and we are starting up

00:19:20,610 --> 00:19:24,899
with precept and so all those tests are

00:19:22,139 --> 00:19:27,629
now we are running on Android kernel

00:19:24,899 --> 00:19:29,940
with something called cuttlefish and

00:19:27,629 --> 00:19:31,230
this is something that I wanted to let

00:19:29,940 --> 00:19:32,580
everyone know kernel a the kernel

00:19:31,230 --> 00:19:34,980
developers an Android developer so like

00:19:32,580 --> 00:19:37,590
it's a target that is available as of

00:19:34,980 --> 00:19:40,440
today in AOSP for example which you can

00:19:37,590 --> 00:19:42,269
build it's like an emulator but not an

00:19:40,440 --> 00:19:45,170
emulator because it behaves like an

00:19:42,269 --> 00:19:47,990
android device it's not intended only to

00:19:45,170 --> 00:19:50,360
say test apps you can treat it as an

00:19:47,990 --> 00:19:53,930
Android device like like your phone it

00:19:50,360 --> 00:19:56,750
will show up as a phone on your x86

00:19:53,930 --> 00:19:59,270
laptop laptop xx's workstations and you

00:19:56,750 --> 00:20:00,980
can run Android with it and the best

00:19:59,270 --> 00:20:04,250
thing about color fish is you can an

00:20:00,980 --> 00:20:06,440
Android kernels by default with it and I

00:20:04,250 --> 00:20:08,060
think if correct me if I'm wrong I think

00:20:06,440 --> 00:20:09,140
you can even run min Lincoln without any

00:20:08,060 --> 00:20:10,760
changes at least or maybe there are a

00:20:09,140 --> 00:20:12,950
couple of changes that we are working on

00:20:10,760 --> 00:20:15,290
documentation to make sure cuttlefish

00:20:12,950 --> 00:20:18,770
runs mean Lincoln's that's how we're

00:20:15,290 --> 00:20:20,690
planning to test those Android comes to

00:20:18,770 --> 00:20:23,060
make sure we can test I'll say an

00:20:20,690 --> 00:20:25,760
Android PI and Android Oreo to make sure

00:20:23,060 --> 00:20:27,770
they continue to work with older and

00:20:25,760 --> 00:20:30,290
newer kernels and all of them so there's

00:20:27,770 --> 00:20:31,940
a big matrix if you look if you expand

00:20:30,290 --> 00:20:33,800
those combinations I think that matrix

00:20:31,940 --> 00:20:36,710
basically end up climbing like 30 or 40

00:20:33,800 --> 00:20:39,200
cells with Android releases versus

00:20:36,710 --> 00:20:43,340
kernel versions and whatnot and that we

00:20:39,200 --> 00:20:44,780
are all planning to start doing with pre

00:20:43,340 --> 00:20:47,170
submit so every change that goes into

00:20:44,780 --> 00:20:49,610
Android kernel whether it's an LTS much

00:20:47,170 --> 00:20:51,770
it basically goes through some sanity

00:20:49,610 --> 00:20:54,470
checks on all of this with all of these

00:20:51,770 --> 00:20:57,170
combinations followed by maybe a weekly

00:20:54,470 --> 00:20:59,270
or bi-weekly post submit test where we

00:20:57,170 --> 00:21:02,300
actually run longer tests with including

00:20:59,270 --> 00:21:05,260
things like CTS and CTS to make sure

00:21:02,300 --> 00:21:10,990
nothing is prick nothing is broken and

00:21:05,260 --> 00:21:14,500
lastly we have also been working with

00:21:10,990 --> 00:21:17,810
SOC vendors where we basically send out

00:21:14,500 --> 00:21:21,110
releases release emails every time we

00:21:17,810 --> 00:21:22,910
merge LTS okay can you guys also merge

00:21:21,110 --> 00:21:24,710
this and test and report us any problem

00:21:22,910 --> 00:21:28,370
you have well and if you're reporting

00:21:24,710 --> 00:21:29,840
problem can you tell us what exactly the

00:21:28,370 --> 00:21:31,430
test you're on and so more likely than

00:21:29,840 --> 00:21:33,680
not we want them to make sure we can

00:21:31,430 --> 00:21:36,440
reproduce it if at all possible and I

00:21:33,680 --> 00:21:38,720
think apart from merge conflicts I don't

00:21:36,440 --> 00:21:41,090
remember seeing a single report where

00:21:38,720 --> 00:21:43,130
again LTS or Android common in the ended

00:21:41,090 --> 00:21:43,820
up breaking downstream correct me if I'm

00:21:43,130 --> 00:21:45,770
wrong again

00:21:43,820 --> 00:21:47,360
yeah I don't remember the only the

00:21:45,770 --> 00:21:48,830
biggest part we get to know what it is

00:21:47,360 --> 00:21:51,320
conflict for example also then we can

00:21:48,830 --> 00:21:53,030
ask hey why is this changed can we do it

00:21:51,320 --> 00:21:56,419
or do it in a better way and this

00:21:53,030 --> 00:21:58,970
basically means they have the freedom to

00:21:56,419 --> 00:22:01,129
do it do their testing and they also can

00:21:58,970 --> 00:22:04,159
come along as we are merging Colonel so

00:22:01,129 --> 00:22:06,799
when we are saying Android PI requires a

00:22:04,159 --> 00:22:08,419
four for 107 patch version that version

00:22:06,799 --> 00:22:10,429
is already merged and tested by them

00:22:08,419 --> 00:22:11,600
like weeks before we actually end up

00:22:10,429 --> 00:22:13,309
saying no that's the one that we

00:22:11,600 --> 00:22:14,539
probably cannot decide on because we get

00:22:13,309 --> 00:22:17,509
test results back and say you know

00:22:14,539 --> 00:22:20,409
everything looks good and nothing is and

00:22:17,509 --> 00:22:22,940
then we have pretty much very much

00:22:20,409 --> 00:22:24,919
confident testing bar on across the

00:22:22,940 --> 00:22:26,299
partners in order to make sure that is

00:22:24,919 --> 00:22:28,759
not that is going to be okay I think

00:22:26,299 --> 00:22:33,789
I'll use the host control bug was also

00:22:28,759 --> 00:22:37,100
founded right right the kernel updates

00:22:33,789 --> 00:22:39,559
it's like a explain it's still a huge

00:22:37,100 --> 00:22:42,049
issue with carriers and vendors alike or

00:22:39,559 --> 00:22:44,690
with carriers it's part of the safety

00:22:42,049 --> 00:22:48,100
about the number of changes even though

00:22:44,690 --> 00:22:52,730
vendors are now taking LTS updates this

00:22:48,100 --> 00:22:54,859
still don't necessarily want to want to

00:22:52,730 --> 00:22:56,450
update it update a device that's

00:22:54,859 --> 00:22:58,450
actually shipped so basically they're

00:22:56,450 --> 00:23:01,340
breaking of point instead of launching

00:22:58,450 --> 00:23:04,190
their SOC is now launching a device so

00:23:01,340 --> 00:23:05,749
we've ended up managing we managed

00:23:04,190 --> 00:23:08,989
pushing that boundary to a launch of a

00:23:05,749 --> 00:23:10,940
device instead of launched SOC but after

00:23:08,989 --> 00:23:12,499
launching the device is still something

00:23:10,940 --> 00:23:14,869
that we need to continue to work on

00:23:12,499 --> 00:23:16,970
because after that when if you want to

00:23:14,869 --> 00:23:19,879
do say an upgrade from four four two

00:23:16,970 --> 00:23:22,429
four nine there's literally oh the

00:23:19,879 --> 00:23:24,710
question is always why why can't we

00:23:22,429 --> 00:23:26,179
continue taking LDS updates and even if

00:23:24,710 --> 00:23:28,009
we do take LTR subtest then how do we

00:23:26,179 --> 00:23:29,690
make it make sure that they show up on

00:23:28,009 --> 00:23:31,989
devices so I think well so we're

00:23:29,690 --> 00:23:34,549
planning to concentrate mainly on the

00:23:31,989 --> 00:23:39,259
getting those stable kernel updates on

00:23:34,549 --> 00:23:42,739
to the devices first right so as part of

00:23:39,259 --> 00:23:44,389
that so for launch we can do we can make

00:23:42,739 --> 00:23:46,519
sure minimum kernel version is there so

00:23:44,389 --> 00:23:48,919
we know we have a limited set of kernels

00:23:46,519 --> 00:23:51,340
that we have to manage for any given

00:23:48,919 --> 00:23:53,989
desert release so PI and also introduced

00:23:51,340 --> 00:23:56,929
LTS we are planning to continue moving

00:23:53,989 --> 00:23:58,999
this needle with the increasing the LDS

00:23:56,929 --> 00:24:01,519
intake even after a device launch

00:23:58,999 --> 00:24:04,370
obviously we are planning to lead by

00:24:01,519 --> 00:24:06,920
example ourselves and

00:24:04,370 --> 00:24:08,870
then the biggest step would be also make

00:24:06,920 --> 00:24:10,730
the stable update as part of the whole

00:24:08,870 --> 00:24:14,170
security process because that's the

00:24:10,730 --> 00:24:17,180
that's the goal if we can prove that

00:24:14,170 --> 00:24:20,300
though that that devices can sustain

00:24:17,180 --> 00:24:23,510
this because then I'll a bug is a bug I

00:24:20,300 --> 00:24:27,110
think a bug is a bug is a bug there's no

00:24:23,510 --> 00:24:29,690
security or security bug as such it's

00:24:27,110 --> 00:24:31,520
they're all bug fixes and you can trust

00:24:29,690 --> 00:24:34,580
them they're safe they're B they've been

00:24:31,520 --> 00:24:36,800
tested everywhere along the way and you

00:24:34,580 --> 00:24:38,870
should really not worry about them and

00:24:36,800 --> 00:24:41,240
if there is a bug happen it's software

00:24:38,870 --> 00:24:42,980
but it happens even today it happens so

00:24:41,240 --> 00:24:46,040
we're not increasing the probability in

00:24:42,980 --> 00:24:48,620
any way than a normal security update

00:24:46,040 --> 00:24:52,600
would on a given device for example

00:24:48,620 --> 00:24:52,600
that's basically where we're headed

00:24:52,960 --> 00:24:56,780
other problem no testing target or

00:24:55,190 --> 00:24:57,710
targets kernel developers for example

00:24:56,780 --> 00:25:00,170
hey why would I

00:24:57,710 --> 00:25:02,360
this is a very common thing that I've

00:25:00,170 --> 00:25:04,700
seen I've read myself on mailing it for

00:25:02,360 --> 00:25:08,150
example hey all I'm running Android but

00:25:04,700 --> 00:25:09,950
how do I run the latest kernel on

00:25:08,150 --> 00:25:11,330
Android because I that's who that's what

00:25:09,950 --> 00:25:13,940
I send my patches against you can

00:25:11,330 --> 00:25:16,100
probably go one version is two versions

00:25:13,940 --> 00:25:17,920
list but you still know even if people

00:25:16,100 --> 00:25:21,620
developers are probably ok with having

00:25:17,920 --> 00:25:22,970
latest LTS running Android device in

00:25:21,620 --> 00:25:25,190
order to test their changes but even

00:25:22,970 --> 00:25:27,620
that doesn't happen because let's I mean

00:25:25,190 --> 00:25:29,600
for now it's about a year and a half so

00:25:27,620 --> 00:25:32,150
basically that becomes a big turn-off

00:25:29,600 --> 00:25:33,830
like there is no way I can just Android

00:25:32,150 --> 00:25:35,480
with my changes to make sure I didn't

00:25:33,830 --> 00:25:39,620
break anything even a simple regression

00:25:35,480 --> 00:25:41,179
test problem being and it's the same

00:25:39,620 --> 00:25:42,559
problem for us like how do we test if

00:25:41,179 --> 00:25:44,360
we're adding a change in Android how do

00:25:42,559 --> 00:25:45,440
we test it against the latest kernel to

00:25:44,360 --> 00:25:47,600
make sure we're not assuming something

00:25:45,440 --> 00:25:49,510
that's wrong or same when we are

00:25:47,600 --> 00:25:52,490
starting work when we work on account

00:25:49,510 --> 00:25:55,400
the problem again is because of large

00:25:52,490 --> 00:25:55,940
amount of out of tree code we have it

00:25:55,400 --> 00:25:59,150
ourselves

00:25:55,940 --> 00:26:01,179
in Android common and but the big chunk

00:25:59,150 --> 00:26:04,370
of them is also for hardware support of

00:26:01,179 --> 00:26:06,200
cuttlefish the the device ends up

00:26:04,370 --> 00:26:08,600
solving this problem in a way but we

00:26:06,200 --> 00:26:12,230
still have all work to make sure it

00:26:08,600 --> 00:26:13,610
works out of main line as is including

00:26:12,230 --> 00:26:15,770
all the changes that you need for

00:26:13,610 --> 00:26:18,710
Android so I have something that Ivan

00:26:15,770 --> 00:26:20,350
I don't want to show in terms of the

00:26:18,710 --> 00:26:23,360
Android parts of the thing ah

00:26:20,350 --> 00:26:26,990
alright so Android common kernel thanks

00:26:23,360 --> 00:26:29,600
to John Amit and all the Leonora folks

00:26:26,990 --> 00:26:32,600
even are we a whole bunch of changes

00:26:29,600 --> 00:26:36,500
from Android kernel have been merged

00:26:32,600 --> 00:26:38,360
upstream so far so what we did for over

00:26:36,500 --> 00:26:41,150
the year over the over the past year is

00:26:38,360 --> 00:26:44,120
we started from scratch our criteria was

00:26:41,150 --> 00:26:46,850
what do we really need what do we really

00:26:44,120 --> 00:26:48,380
need in order to boot and run Android in

00:26:46,850 --> 00:26:51,710
the scanner because when he started that

00:26:48,380 --> 00:26:54,320
currently had about 100 by about 800 mm

00:26:51,710 --> 00:26:56,570
patches on top of the kernel latest LDS

00:26:54,320 --> 00:27:00,110
at the time so we went through that and

00:26:56,570 --> 00:27:02,960
we found out when we did 419 it's about

00:27:00,110 --> 00:27:04,490
30 patches that you need all the lines

00:27:02,960 --> 00:27:05,929
of code changes is there and we did

00:27:04,490 --> 00:27:08,270
obviously use cuttlefish

00:27:05,929 --> 00:27:10,370
we haven't found so that's what you end

00:27:08,270 --> 00:27:12,230
up needing just to boot whole bunch of

00:27:10,370 --> 00:27:14,690
changes and slash features in Android

00:27:12,230 --> 00:27:17,510
common kernel that I talked about for at

00:27:14,690 --> 00:27:21,170
the end that Android ends abusing but in

00:27:17,510 --> 00:27:23,750
order for mainline kernel to basically

00:27:21,170 --> 00:27:26,960
run Android that's how many changes you

00:27:23,750 --> 00:27:29,720
need and it shouldn't be much so our

00:27:26,960 --> 00:27:33,590
first and foremost is target is to make

00:27:29,720 --> 00:27:36,350
sure that goes down to zero the second

00:27:33,590 --> 00:27:37,910
so as part of that basically apart from

00:27:36,350 --> 00:27:40,520
the up streaming work that everyone else

00:27:37,910 --> 00:27:41,900
has done and with them what we are also

00:27:40,520 --> 00:27:45,020
doing is we went through that list and

00:27:41,900 --> 00:27:46,340
say there are changes that we've been

00:27:45,020 --> 00:27:50,450
carrying for about eight to nine years

00:27:46,340 --> 00:27:51,559
that really we're not sure if we're used

00:27:50,450 --> 00:27:54,950
because they would thing with Android

00:27:51,559 --> 00:27:57,380
because we never did this for kernel

00:27:54,950 --> 00:27:59,840
until two years ago oh we didn't know

00:27:57,380 --> 00:28:02,470
it's the fear where if we end up

00:27:59,840 --> 00:28:05,240
removing something what will happen if

00:28:02,470 --> 00:28:08,809
it will end up breaking someone so we

00:28:05,240 --> 00:28:12,380
did a survey of sort with everyone and

00:28:08,809 --> 00:28:14,870
asked a name do we need to ice trees to

00:28:12,380 --> 00:28:17,570
be appended to kernel for example no

00:28:14,870 --> 00:28:19,970
that drops ten patches do we need XYZ

00:28:17,570 --> 00:28:21,679
feature that drops 60 pounds and that

00:28:19,970 --> 00:28:25,220
basically reduced it down to like 200 of

00:28:21,679 --> 00:28:26,960
them and out of them we found 300 of

00:28:25,220 --> 00:28:27,900
them were actually also it's 30 of about

00:28:26,960 --> 00:28:31,260
30 of them are actually

00:28:27,900 --> 00:28:33,300
Nydia to boot which is great we still

00:28:31,260 --> 00:28:36,120
have our work cut out for us in terms of

00:28:33,300 --> 00:28:37,860
up streaming we know the binder priority

00:28:36,120 --> 00:28:41,010
inheritance but I think they've been on

00:28:37,860 --> 00:28:43,200
the mailing list once but that's being

00:28:41,010 --> 00:28:46,170
worked on EAS is a big piece that

00:28:43,200 --> 00:28:49,230
Android common curl has that's also

00:28:46,170 --> 00:28:51,450
being worked on an SD card FS which is

00:28:49,230 --> 00:28:53,790
the one that's used for adoptable

00:28:51,450 --> 00:28:55,800
storage and apps on Android and that's

00:28:53,790 --> 00:28:57,870
probably the biggest one that we that we

00:28:55,800 --> 00:29:00,330
plan to work on following in the

00:28:57,870 --> 00:29:02,700
following year in order to make sure our

00:29:00,330 --> 00:29:06,660
target is to be 0 because then we don't

00:29:02,700 --> 00:29:09,000
want to have to maintain this out of

00:29:06,660 --> 00:29:10,740
tree and I'll talk about that later as

00:29:09,000 --> 00:29:11,880
well the back ports are still probably

00:29:10,740 --> 00:29:13,170
going to be around because of the

00:29:11,880 --> 00:29:14,490
problem that I mentioned earlier where

00:29:13,170 --> 00:29:18,720
we still have to continue supporting all

00:29:14,490 --> 00:29:21,390
the cards what do we do about out of

00:29:18,720 --> 00:29:26,610
three hardware specific code basically

00:29:21,390 --> 00:29:30,240
there are no that explains everything

00:29:26,610 --> 00:29:32,910
I'm not well I have but we I wanted to

00:29:30,240 --> 00:29:39,090
leave this with a discussion slash

00:29:32,910 --> 00:29:40,890
question slash an idea but before we get

00:29:39,090 --> 00:29:45,240
there I want you to talk about project

00:29:40,890 --> 00:29:46,950
treble and its relations to the Linux

00:29:45,240 --> 00:29:49,200
kernel and what it ended up doing so

00:29:46,950 --> 00:29:52,230
project treble introduced in Android

00:29:49,200 --> 00:29:56,190
audio it did introduce a concept called

00:29:52,230 --> 00:29:57,780
window interface the wind f line in that

00:29:56,190 --> 00:30:01,220
diagram basically calls render interface

00:29:57,780 --> 00:30:04,290
what that means is we basically split

00:30:01,220 --> 00:30:07,140
architect Android into architectural II

00:30:04,290 --> 00:30:08,970
the one part that we call framework or

00:30:07,140 --> 00:30:12,020
interchangeably use framework slash

00:30:08,970 --> 00:30:18,120
system is something that is to be

00:30:12,020 --> 00:30:20,520
hardware / render / basically agnostic

00:30:18,120 --> 00:30:23,340
to hardware and then and then anything

00:30:20,520 --> 00:30:25,440
that lives in that diagram below vendor

00:30:23,340 --> 00:30:27,050
is the what project travel ended up

00:30:25,440 --> 00:30:29,280
defining something that depends on

00:30:27,050 --> 00:30:31,830
hardware is not a so basically obviously

00:30:29,280 --> 00:30:34,320
hardware abstraction layers became a

00:30:31,830 --> 00:30:36,560
part of wind up in that case but the big

00:30:34,320 --> 00:30:39,990
piece that became part of vintage is

00:30:36,560 --> 00:30:42,960
actually the living stone although Linux

00:30:39,990 --> 00:30:44,730
is something oh that is hardware

00:30:42,960 --> 00:30:46,860
dependent I mean it does give you

00:30:44,730 --> 00:30:49,679
support for hardware but it's not

00:30:46,860 --> 00:30:53,070
necessarily Hardware dependent it's not

00:30:49,679 --> 00:30:55,380
necessarily that that has to define its

00:30:53,070 --> 00:30:56,940
interfaces through a language that we

00:30:55,380 --> 00:30:58,950
introduced with project revolvers title

00:30:56,940 --> 00:31:01,530
it the Linux kernel interfaces to user

00:30:58,950 --> 00:31:04,020
space are supposed to be forever right

00:31:01,530 --> 00:31:06,330
so it's not something that we have to

00:31:04,020 --> 00:31:09,150
worry about versioning and being stable

00:31:06,330 --> 00:31:11,010
but and yet it ended up being on the

00:31:09,150 --> 00:31:15,590
vendor side of things and the reason for

00:31:11,010 --> 00:31:19,980
that is simply because of that because

00:31:15,590 --> 00:31:23,220
all of the Android devices have a huge

00:31:19,980 --> 00:31:25,260
amount of out of tree vendor code so the

00:31:23,220 --> 00:31:27,450
deliverable or as much as it is

00:31:25,260 --> 00:31:31,320
architected the deliverable for making

00:31:27,450 --> 00:31:33,780
an Android device falls on the odm / om

00:31:31,320 --> 00:31:35,910
as much as it falls on the hardware

00:31:33,780 --> 00:31:39,720
maker or the or the vendor in this case

00:31:35,910 --> 00:31:41,610
and that entity is what delivers the

00:31:39,720 --> 00:31:44,490
Linux kernel to support that can be

00:31:41,610 --> 00:31:46,650
given hardware and that's exactly why it

00:31:44,490 --> 00:31:48,570
ends up being on the other side of

00:31:46,650 --> 00:31:51,570
winter what we would actually like to be

00:31:48,570 --> 00:31:53,640
is obviously on the platform side where

00:31:51,570 --> 00:31:56,730
then we can move the platform with the

00:31:53,640 --> 00:31:58,740
kernel as part of project travel what we

00:31:56,730 --> 00:32:02,130
also introduced is something called as

00:31:58,740 --> 00:32:05,400
the generating system image to give you

00:32:02,130 --> 00:32:08,040
a brief overview of what generic system

00:32:05,400 --> 00:32:10,590
image is is it's basically what proves

00:32:08,040 --> 00:32:14,010
the project travel split what it does is

00:32:10,590 --> 00:32:17,370
it we build we can build a way speed am

00:32:14,010 --> 00:32:19,650
Android open source code and create a

00:32:17,370 --> 00:32:22,050
system image replace the system image

00:32:19,650 --> 00:32:24,030
that's on any given Android device with

00:32:22,050 --> 00:32:26,400
that one and it boots and it works

00:32:24,030 --> 00:32:29,460
because that then proves that we've

00:32:26,400 --> 00:32:31,020
successfully implemented project trouble

00:32:29,460 --> 00:32:32,460
the split has successfully been

00:32:31,020 --> 00:32:34,410
implemented on the in device and that's

00:32:32,460 --> 00:32:37,710
actually literally how project travel

00:32:34,410 --> 00:32:39,570
tests are run we the the integrity of

00:32:37,710 --> 00:32:41,700
and raw Android implementation on a

00:32:39,570 --> 00:32:45,120
given device gets replaced with what we

00:32:41,700 --> 00:32:46,920
call GSI and then it passes CTS and VDS

00:32:45,120 --> 00:32:48,900
tests on top of it that's the concept of

00:32:46,920 --> 00:32:52,280
generic system image and that basically

00:32:48,900 --> 00:32:56,880
tested the project travel required

00:32:52,280 --> 00:32:58,530
right so I was a bit so basically that's

00:32:56,880 --> 00:33:01,050
what in every project traveling between

00:32:58,530 --> 00:33:03,420
Android is on one side of this plate

00:33:01,050 --> 00:33:05,430
while the Linux kernel and the render

00:33:03,420 --> 00:33:08,160
implementation of an interface that we

00:33:05,430 --> 00:33:12,560
define is on the other side of it if we

00:33:08,160 --> 00:33:15,270
want to try and solve the world Hardware

00:33:12,560 --> 00:33:19,530
specific code being out of tree and try

00:33:15,270 --> 00:33:21,720
and move the kernel updated with try and

00:33:19,530 --> 00:33:25,310
move kernel with platform what we want

00:33:21,720 --> 00:33:30,240
is actually this which we won't think

00:33:25,310 --> 00:33:32,040
generic where that GSI being the generic

00:33:30,240 --> 00:33:34,620
system image and project rebel allow

00:33:32,040 --> 00:33:37,470
already has set up the ways for doing

00:33:34,620 --> 00:33:38,760
the tests and doing and making sure this

00:33:37,470 --> 00:33:41,520
can happen operationally and

00:33:38,760 --> 00:33:43,560
logistically where a generic kernel that

00:33:41,520 --> 00:33:46,230
we really hopefully just an upstream

00:33:43,560 --> 00:33:49,770
mean Lincoln can run on any human

00:33:46,230 --> 00:33:52,620
Android device provided the hardware

00:33:49,770 --> 00:33:56,340
whatever specific code guarantees to a

00:33:52,620 --> 00:33:57,870
stable or /and interface and this

00:33:56,340 --> 00:33:59,910
doesn't necessarily have to be something

00:33:57,870 --> 00:34:01,440
that goes on through a device to an user

00:33:59,910 --> 00:34:03,840
but it's something that we can use to

00:34:01,440 --> 00:34:05,550
test it's something that we can use we

00:34:03,840 --> 00:34:07,800
have project trouble to make sure every

00:34:05,550 --> 00:34:10,770
single Android device here are there's

00:34:07,800 --> 00:34:12,510
to this so then not only just cuttlefish

00:34:10,770 --> 00:34:16,520
is something that can run a kernel or a

00:34:12,510 --> 00:34:19,169
generic curl it can be any human device

00:34:16,520 --> 00:34:21,530
obviously how would we get there a world

00:34:19,169 --> 00:34:23,310
punch it against a kernel symbol

00:34:21,530 --> 00:34:25,830
namespaces it's just something that

00:34:23,310 --> 00:34:29,510
started showing up on the mailing list

00:34:25,830 --> 00:34:32,669
as well this is basically to try and

00:34:29,510 --> 00:34:35,159
figure out how many how scattered is the

00:34:32,669 --> 00:34:37,409
internal current symbols usage across

00:34:35,159 --> 00:34:39,750
subsystems and also limited for

00:34:37,409 --> 00:34:42,540
potentially going forward the compiler

00:34:39,750 --> 00:34:44,669
because a compiler for signal company

00:34:42,540 --> 00:34:46,409
for Android Android itself uses the

00:34:44,669 --> 00:34:49,080
single compiler but kernel is an open

00:34:46,409 --> 00:34:51,780
story right now it can be GCC or clang

00:34:49,080 --> 00:34:55,679
and monitor the in-kernel ABI because

00:34:51,780 --> 00:34:57,930
now we have these parts to communicate

00:34:55,679 --> 00:34:59,710
with everyone in order to tell them if

00:34:57,930 --> 00:35:02,349
we pretty much have a weekly

00:34:59,710 --> 00:35:04,330
release per se we can probably tell

00:35:02,349 --> 00:35:05,770
everyone hey this is the LTS update

00:35:04,330 --> 00:35:07,570
we've tried our best but this is the how

00:35:05,770 --> 00:35:10,270
the ABI has changed between the kernel

00:35:07,570 --> 00:35:12,040
can make sure whatever code you probably

00:35:10,270 --> 00:35:14,859
will get affected by it you've adjusted

00:35:12,040 --> 00:35:17,890
to it or try best possible in order to

00:35:14,859 --> 00:35:20,200
not change that API when the when those

00:35:17,890 --> 00:35:21,310
kernels are being released to when

00:35:20,200 --> 00:35:26,410
there's release notes are being sent to

00:35:21,310 --> 00:35:28,750
the partners process updates obviously

00:35:26,410 --> 00:35:31,119
we are trying very hard to make sure

00:35:28,750 --> 00:35:37,240
everything goes up stream first with all

00:35:31,119 --> 00:35:38,440
you'll notice you'll notice a few of the

00:35:37,240 --> 00:35:40,599
things that we've been working on have

00:35:38,440 --> 00:35:43,060
already shown upstream whether it's F 2

00:35:40,599 --> 00:35:45,970
FS four checkpoints there are patches

00:35:43,060 --> 00:35:47,470
that showed up for the symbol namespaces

00:35:45,970 --> 00:35:49,690
there are patches that showed up for our

00:35:47,470 --> 00:35:53,470
device mapper target the backup on right

00:35:49,690 --> 00:35:56,109
for example we've we were also doing

00:35:53,470 --> 00:36:00,400
something that in terms of security bugs

00:35:56,109 --> 00:36:02,410
where they were embargoed and would show

00:36:00,400 --> 00:36:04,300
up in common for example common kernel

00:36:02,410 --> 00:36:07,869
before they actually show up stream

00:36:04,300 --> 00:36:10,770
that's been reversed now and we actively

00:36:07,869 --> 00:36:13,330
basically end up reporting them to

00:36:10,770 --> 00:36:14,980
upstream first and make make sure we fix

00:36:13,330 --> 00:36:17,260
it upstream and then take them or

00:36:14,980 --> 00:36:21,910
downstream through LTS kernel updates as

00:36:17,260 --> 00:36:24,369
much as possible and basically we've

00:36:21,910 --> 00:36:26,680
been testing may monitoring and testing

00:36:24,369 --> 00:36:28,000
all the chain or all of the kernel

00:36:26,680 --> 00:36:30,849
changes whether it's merged if our

00:36:28,000 --> 00:36:36,070
Android with next able on arm hardware

00:36:30,849 --> 00:36:38,589
and same with cuttlefish as well there

00:36:36,070 --> 00:36:40,960
are more updates on what we've been

00:36:38,589 --> 00:36:42,970
doing up things like the user space no

00:36:40,960 --> 00:36:45,790
memory killer checkpoints that I talked

00:36:42,970 --> 00:36:48,190
about ashram and I on another thing that

00:36:45,790 --> 00:36:51,780
is in the kernel but it's in staging we

00:36:48,190 --> 00:36:54,849
want to figure out how we can make sure

00:36:51,780 --> 00:36:55,930
Android is going to be ok if we take HP

00:36:54,849 --> 00:36:56,410
motor basically replace it with

00:36:55,930 --> 00:36:59,740
something else

00:36:56,410 --> 00:37:01,570
DRM kms is another thing Android user

00:36:59,740 --> 00:37:02,890
device 3 was highly controversial last

00:37:01,570 --> 00:37:05,619
year I have a bunch of updates regarding

00:37:02,890 --> 00:37:09,670
that that I I'm planning to talk about

00:37:05,619 --> 00:37:11,290
tomorrow and Android resizable partition

00:37:09,670 --> 00:37:12,920
these are this is all basically

00:37:11,290 --> 00:37:14,720
targeting to make sure Android

00:37:12,920 --> 00:37:16,390
so get more and more of this both in

00:37:14,720 --> 00:37:18,770
kernel as well as for platforms so

00:37:16,390 --> 00:37:22,480
anyone interested maybe show to show up

00:37:18,770 --> 00:37:26,920
into my mg and that's tomorrow I see and

00:37:22,480 --> 00:37:26,920
that's pretty much it that's all here

00:37:42,100 --> 00:37:49,900
hey any guides or any like any

00:37:46,910 --> 00:37:53,570
documentation on using cuttlefish

00:37:49,900 --> 00:37:56,330
showing up on Android or come soon the

00:37:53,570 --> 00:37:59,510
person should talk to - no more of this

00:37:56,330 --> 00:38:01,070
Lee Alistair and me even if you want but

00:37:59,510 --> 00:38:05,110
yes we're working on that that's gonna

00:38:01,070 --> 00:38:05,110
show up on another console right

00:38:12,720 --> 00:38:17,910
did I understand correctly that Android

00:38:14,910 --> 00:38:19,430
only has 30 patches that are not

00:38:17,910 --> 00:38:23,040
upstream yes

00:38:19,430 --> 00:38:25,470
well 30 patches that are required that

00:38:23,040 --> 00:38:27,570
are needed to boot Android and they're

00:38:25,470 --> 00:38:30,660
not obscene yeah they're in android come

00:38:27,570 --> 00:38:34,560
and go if you want and then they're dead

00:38:30,660 --> 00:38:36,450
nearest is this SD card FS up I think

00:38:34,560 --> 00:38:38,460
there's a winder path and I'm sure I'm

00:38:36,450 --> 00:38:40,140
probably missing a couple but what this

00:38:38,460 --> 00:38:42,390
exercise was to try and figure out

00:38:40,140 --> 00:38:44,400
what's the minimum that we need and that

00:38:42,390 --> 00:38:51,420
with those 30 pages I think we boot cut

00:38:44,400 --> 00:38:55,710
off a if I'm not mistaken yeah what oh I

00:38:51,420 --> 00:38:57,300
don't know because I think the way that

00:38:55,710 --> 00:38:59,070
we need to frame it is the minimum

00:38:57,300 --> 00:39:01,410
number of patches not just to boot with

00:38:59,070 --> 00:39:03,030
for cts compliance and I think the

00:39:01,410 --> 00:39:06,090
number is probably gonna be pretty close

00:39:03,030 --> 00:39:10,380
to 30 anyway yes because number of wood

00:39:06,090 --> 00:39:12,090
years City is complex yes right so you

00:39:10,380 --> 00:39:13,860
talked about the generic kernel image

00:39:12,090 --> 00:39:16,320
with the out of tree hardware support

00:39:13,860 --> 00:39:19,080
stuff pushed into presumably proprietary

00:39:16,320 --> 00:39:21,630
binary blob modules what's being done to

00:39:19,080 --> 00:39:23,070
move that hardware support into the

00:39:21,630 --> 00:39:26,790
mainline kernel as well do we have any

00:39:23,070 --> 00:39:31,770
hope for that oh well your knowledge is

00:39:26,790 --> 00:39:33,600
as good as mine basically well we don't

00:39:31,770 --> 00:39:35,880
want to say properly its its kernel it's

00:39:33,600 --> 00:39:38,880
GPL it's all open even if their kernel

00:39:35,880 --> 00:39:42,570
modules there well they will be open

00:39:38,880 --> 00:39:46,170
what the generic kernel image does is

00:39:42,570 --> 00:39:49,380
basically now for example it would make

00:39:46,170 --> 00:39:51,810
sure those kernel modules a those device

00:39:49,380 --> 00:39:54,690
driver can be modules or must be modules

00:39:51,810 --> 00:39:57,060
you can't depend on a kernel that's

00:39:54,690 --> 00:39:58,860
basically changed internally just so a

00:39:57,060 --> 00:40:01,350
particular driver would work

00:39:58,860 --> 00:40:04,590
that can't happen anymore you can't

00:40:01,350 --> 00:40:06,960
export any symbols that you want because

00:40:04,590 --> 00:40:09,090
that's how the driver is written that

00:40:06,960 --> 00:40:11,820
can't happen anymore because remember

00:40:09,090 --> 00:40:13,740
all of those drivers have to work with

00:40:11,820 --> 00:40:15,300
the current generic kernel image that we

00:40:13,740 --> 00:40:18,480
want to be able to build and test any

00:40:15,300 --> 00:40:22,090
given devices right because now all of

00:40:18,480 --> 00:40:24,130
those I'm pretty sure I've seen

00:40:22,090 --> 00:40:25,300
where things get intertwined so much

00:40:24,130 --> 00:40:27,430
that there is literally a cyclic

00:40:25,300 --> 00:40:29,260
dependency of drivers and then if you

00:40:27,430 --> 00:40:33,040
make them as kernel modules

00:40:29,260 --> 00:40:34,840
it doesn't even boot because we no

00:40:33,040 --> 00:40:37,030
matter which driver you load first it's

00:40:34,840 --> 00:40:38,890
not going to work and so those all of

00:40:37,030 --> 00:40:41,200
those problems stop happening so now

00:40:38,890 --> 00:40:43,300
what that means is sure if you're

00:40:41,200 --> 00:40:45,280
shipping an Android device to a user

00:40:43,300 --> 00:40:47,200
just to let's say if that increases boot

00:40:45,280 --> 00:40:49,390
time you may even choose to build that

00:40:47,200 --> 00:40:51,220
module or driver in the kernel in order

00:40:49,390 --> 00:40:53,560
to basically continue to work but you

00:40:51,220 --> 00:40:55,030
know but by having this test which has

00:40:53,560 --> 00:40:57,460
to work with the generate kernel image

00:40:55,030 --> 00:40:59,350
for example that same driver has to be

00:40:57,460 --> 00:41:01,720
able to build in Buddhist kernel modules

00:40:59,350 --> 00:41:03,640
which automatically makes it much more

00:41:01,720 --> 00:41:07,810
upstream really than what it would have

00:41:03,640 --> 00:41:11,530
been before so the whole base it's a

00:41:07,810 --> 00:41:13,180
natural progression they are but well

00:41:11,530 --> 00:41:14,680
yeah apart from that it's like I said

00:41:13,180 --> 00:41:21,670
it's your knowledge is as much as good

00:41:14,680 --> 00:41:25,240
as mine in that case how do we motivate

00:41:21,670 --> 00:41:28,540
OMS and audience who are basically

00:41:25,240 --> 00:41:30,850
shipping products to to to follow this

00:41:28,540 --> 00:41:33,310
is there any way that you that you have

00:41:30,850 --> 00:41:36,310
in mind to force all sorts with the

00:41:33,310 --> 00:41:38,980
future USP releases well with Android

00:41:36,310 --> 00:41:43,240
releases we've done the minimum kernel

00:41:38,980 --> 00:41:45,340
version thing if we do end up doing that

00:41:43,240 --> 00:41:46,630
you can and of course we need help

00:41:45,340 --> 00:41:48,520
because we for example to be starting

00:41:46,630 --> 00:41:50,920
this research right now for one of the

00:41:48,520 --> 00:41:53,350
biggest requirement for a generic kernel

00:41:50,920 --> 00:41:56,080
image is a is kernel or let's say even

00:41:53,350 --> 00:41:58,690
arm 64 kernels today are ready to be

00:41:56,080 --> 00:42:00,250
generally but I we started doing this I

00:41:58,690 --> 00:42:02,560
still don't know if all subsystem for

00:42:00,250 --> 00:42:04,780
all subsystems we can have drivers that

00:42:02,560 --> 00:42:08,980
get plugged into a random kernel for

00:42:04,780 --> 00:42:10,930
example I I've covered about four of

00:42:08,980 --> 00:42:13,540
them and they all seem to be fine but

00:42:10,930 --> 00:42:15,520
this has to be at the beginning of SOC

00:42:13,540 --> 00:42:18,130
which is right at the beginning of your

00:42:15,520 --> 00:42:20,650
boot cycle but there are steps taken

00:42:18,130 --> 00:42:23,530
already in order to basically go on this

00:42:20,650 --> 00:42:25,960
path with the kernel version with the

00:42:23,530 --> 00:42:28,570
GSI for Android in this case that takes

00:42:25,960 --> 00:42:31,220
care of Android if we do the kernel part

00:42:28,570 --> 00:42:33,410
then that also moves the

00:42:31,220 --> 00:42:36,500
in that way as well because those tests

00:42:33,410 --> 00:42:38,150
remember they have to be they are they

00:42:36,500 --> 00:42:42,050
have to be positive you launch an

00:42:38,150 --> 00:42:44,240
Android device in that case okay going

00:42:42,050 --> 00:42:47,359
going to the part where the top of the

00:42:44,240 --> 00:42:49,760
vendor portion of the Tribble now one of

00:42:47,359 --> 00:42:52,190
the things we deal with quite a lot is

00:42:49,760 --> 00:42:54,710
with the request API of the cameras

00:42:52,190 --> 00:42:56,300
that's currently in the user space it's

00:42:54,710 --> 00:43:00,319
not in the kernel space but it's going

00:42:56,300 --> 00:43:02,720
into the kernel space so we I kind of

00:43:00,319 --> 00:43:04,280
hope that with the request API going in

00:43:02,720 --> 00:43:05,780
the kernel space if some of this this

00:43:04,280 --> 00:43:08,930
vendor space can shrink because right

00:43:05,780 --> 00:43:10,849
now the cameras section of the kernel is

00:43:08,930 --> 00:43:11,960
one of the one of the things that has to

00:43:10,849 --> 00:43:14,210
be outside in the vendor space because

00:43:11,960 --> 00:43:15,920
it's user space and that's and it's not

00:43:14,210 --> 00:43:18,740
part of the kernel at this time right

00:43:15,920 --> 00:43:20,810
I'm not familiar with what you're saying

00:43:18,740 --> 00:43:24,890
in terms of request API oh request API

00:43:20,810 --> 00:43:27,349
is is part of the hell three in

00:43:24,890 --> 00:43:30,829
infrastructure implementation of how the

00:43:27,349 --> 00:43:34,190
camera frames requested from through the

00:43:30,829 --> 00:43:36,020
pipeline so basic you request the format

00:43:34,190 --> 00:43:37,550
you want in advance and it delivers it

00:43:36,020 --> 00:43:41,990
as opposed to working as a streaming

00:43:37,550 --> 00:43:44,810
pipeline okay well if I'm understanding

00:43:41,990 --> 00:43:48,220
you correctly you're basically trying to

00:43:44,810 --> 00:43:58,390
keep that API stable so you can move

00:43:48,220 --> 00:43:58,390
along okay

00:44:05,770 --> 00:44:10,849
that is exactly why for example can I

00:44:09,230 --> 00:44:13,579
can you can draw an analogy with that

00:44:10,849 --> 00:44:17,000
with for example DM km/s the display

00:44:13,579 --> 00:44:18,829
with Android is there FB there is a bit

00:44:17,000 --> 00:44:21,470
of implementation there's a DM VMs as

00:44:18,829 --> 00:44:24,650
well if we standardize that in order to

00:44:21,470 --> 00:44:27,140
make sure yes so if you if you make the

00:44:24,650 --> 00:44:28,910
house smaller and smaller in the point

00:44:27,140 --> 00:44:30,140
that there is no need that's basically

00:44:28,910 --> 00:44:31,460
when you have a very stable kernel

00:44:30,140 --> 00:44:32,930
interface which Android can directly

00:44:31,460 --> 00:44:36,200
rely on that's where we want to be

00:44:32,930 --> 00:44:38,780
definitely yes

00:44:36,200 --> 00:44:42,410
what if anything changed for trouble

00:44:38,780 --> 00:44:46,490
between eight nine with hundred nine

00:44:42,410 --> 00:44:49,400
yeah are many things with respect to

00:44:46,490 --> 00:44:53,349
kernel there are more tests there are

00:44:49,400 --> 00:44:57,260
more there are changes in terms of how

00:44:53,349 --> 00:44:59,780
verified boot works but only in the

00:44:57,260 --> 00:45:01,760
device tree there are user space changes

00:44:59,780 --> 00:45:05,510
with respect to properties there are

00:45:01,760 --> 00:45:08,180
things that were left will not left that

00:45:05,510 --> 00:45:10,099
were kind of unfinished in terms of the

00:45:08,180 --> 00:45:12,170
separation from platform to vendor and

00:45:10,099 --> 00:45:15,020
all of that was plugged with Android

00:45:12,170 --> 00:45:19,960
night so I know nine is more much more

00:45:15,020 --> 00:45:19,960
complete maybe kinetically complete then

00:45:21,460 --> 00:45:24,880
yes yes

00:45:25,219 --> 00:45:30,949
okay I think we're done with this one

00:45:28,229 --> 00:45:30,949

YouTube URL: https://www.youtube.com/watch?v=O5N_YcHX8zc


