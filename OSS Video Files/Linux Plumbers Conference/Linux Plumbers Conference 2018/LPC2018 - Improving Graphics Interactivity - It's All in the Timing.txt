Title: LPC2018 - Improving Graphics Interactivity - It's All in the Timing
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/68/
speaker:  Keith Packard (HP)


Interactive applications, which includes everything from real time
games through flight simulators and virtual reality environments,
place strong real-time requirements on the whole computing environment
to ensure that the correct data are presented to the user at the
correct time. This requires two things; the first is that the time
when the information will be displayed be known to the application so
that the correct contents can be computed, and second that the frame
actually be displayed at that time.

These two pieces of information are managed inconsistently through the
graphics stack, making it difficult for applications to provide a
smooth animation experience to users. And because of the many APIs
which lie between the application rendering using OpenGL or Vulkan and
the underlying hardware, a failure to correctly handle things at
any point along the chain will result in stuttering results.

Fixing this requires changes throughout the system, from making the
kernel provide better control and information about the queuing and
presentation of images through changes in composited window systems to
ensure that images are displayed at the target time, and that
the actual time of presentation is reported back to applications and
finally additions to rendering APIs like Vulkan to expose control
over image presentation times and feedback about when images ended up
being visible to the user.

This presentation will first demonstrate the effects of poor display
timing support inherent in the current graphics stack, talk about the
different solutions required at each level of the system and finally
show the working system.
Captions: 
	00:00:05,840 --> 00:00:10,980
and I regularly see him in other

00:00:08,490 --> 00:00:12,840
countries I don't think I've seen Paul

00:00:10,980 --> 00:00:14,580
in Portland in many years we did see

00:00:12,840 --> 00:00:16,230
each other once in Portland we did it

00:00:14,580 --> 00:00:19,320
actually verified that we both live in

00:00:16,230 --> 00:00:21,510
Portland thank you for coming this

00:00:19,320 --> 00:00:23,310
morning I love speaking first it gives

00:00:21,510 --> 00:00:24,630
me an opportunity to get my talk out of

00:00:23,310 --> 00:00:26,250
the way so I can enjoy the rest of the

00:00:24,630 --> 00:00:28,680
conference without any concerns

00:00:26,250 --> 00:00:31,529
my name is Keith Packard I'm currently

00:00:28,680 --> 00:00:35,430
consulting for a valve who has a deep

00:00:31,529 --> 00:00:37,680
and abiding interest in the Linux I'll

00:00:35,430 --> 00:00:40,530
stand over here deep and abiding

00:00:37,680 --> 00:00:42,660
interest in in Linux graphics as that's

00:00:40,530 --> 00:00:44,910
one of their primary platforms for for

00:00:42,660 --> 00:00:46,370
shipping all of their fine games they

00:00:44,910 --> 00:00:50,429
actually support a number of people

00:00:46,370 --> 00:00:51,449
doing Linux graphics development and one

00:00:50,429 --> 00:00:53,160
of the things that they're most

00:00:51,449 --> 00:00:54,329
interested in is improving the

00:00:53,160 --> 00:00:56,789
open-source drivers in the open-source

00:00:54,329 --> 00:00:59,339
graphics stack and I'm working on kind

00:00:56,789 --> 00:01:02,370
of the display half of that I'm talking

00:00:59,339 --> 00:01:04,650
about some display timing stuff okay so

00:01:02,370 --> 00:01:06,210
we talked about display timing and we

00:01:04,650 --> 00:01:09,180
talked about animations on the screen

00:01:06,210 --> 00:01:11,100
and it used to be that you would watch

00:01:09,180 --> 00:01:14,310
an animation and you were excited if it

00:01:11,100 --> 00:01:16,800
was pretty smooth and actually moved on

00:01:14,310 --> 00:01:18,360
the screen expectations have risen at

00:01:16,800 --> 00:01:19,740
this point you want to interactive

00:01:18,360 --> 00:01:21,420
graphics application so we're talking

00:01:19,740 --> 00:01:23,010
about something where you have where

00:01:21,420 --> 00:01:26,010
you're providing input which is changing

00:01:23,010 --> 00:01:28,650
the scene and when you have that the the

00:01:26,010 --> 00:01:30,300
application really needs to know when

00:01:28,650 --> 00:01:32,220
the content that it's currently

00:01:30,300 --> 00:01:34,800
generating is going to be presented

00:01:32,220 --> 00:01:37,260
obviously we can't we can't have zero

00:01:34,800 --> 00:01:39,330
latency between rendering and display

00:01:37,260 --> 00:01:41,190
and so the application is going to

00:01:39,330 --> 00:01:43,100
predict what's seeing the user is

00:01:41,190 --> 00:01:45,660
expecting to see several frames ahead

00:01:43,100 --> 00:01:47,400
computing a scene for that time and then

00:01:45,660 --> 00:01:50,220
asking the display system to present it

00:01:47,400 --> 00:01:52,020
at that time you also want a constant

00:01:50,220 --> 00:01:53,520
frame rate if you don't have a constant

00:01:52,020 --> 00:01:56,820
frame rate the user the user gets a

00:01:53,520 --> 00:02:00,240
sense of jerkiness and judder which is

00:01:56,820 --> 00:02:03,060
very very disconcerting this is true on

00:02:00,240 --> 00:02:04,560
the desktop it's very true and and very

00:02:03,060 --> 00:02:06,720
important in a virtual reality or

00:02:04,560 --> 00:02:09,179
augmented reality environment where the

00:02:06,720 --> 00:02:11,099
with a primary one of the primary

00:02:09,179 --> 00:02:13,590
drivers of the change of the scene is a

00:02:11,099 --> 00:02:14,730
change of the users pose and so if

00:02:13,590 --> 00:02:17,060
you're moving your head around you

00:02:14,730 --> 00:02:19,319
really expect the world to appear steady

00:02:17,060 --> 00:02:21,329
and the only way you're gonna get that

00:02:19,319 --> 00:02:22,650
if the application knows exactly when

00:02:21,329 --> 00:02:25,499
their frame is going to be presented to

00:02:22,650 --> 00:02:28,260
the user the question is why is this

00:02:25,499 --> 00:02:30,810
hard we've been doing 3d animated

00:02:28,260 --> 00:02:33,480
graphics for how long now like 40 years

00:02:30,810 --> 00:02:36,480
and yet we still struggle with getting

00:02:33,480 --> 00:02:38,250
it smooth and making it work well these

00:02:36,480 --> 00:02:40,349
days there's a lot of moving parts right

00:02:38,250 --> 00:02:42,150
there's a the systems have gotten very

00:02:40,349 --> 00:02:43,650
complicated there's a lot of

00:02:42,150 --> 00:02:46,019
interactions in software and hardware

00:02:43,650 --> 00:02:47,669
our display systems have gotten more

00:02:46,019 --> 00:02:50,700
complicated right it used to be you had

00:02:47,669 --> 00:02:53,280
the monitor and you had the frame buffer

00:02:50,700 --> 00:02:54,930
and the monitor was a CRT and when you

00:02:53,280 --> 00:02:56,250
provided voltage to the CRT the

00:02:54,930 --> 00:02:58,680
phosphorous who are illuminated there

00:02:56,250 --> 00:03:00,959
was no delay between or no perceptible

00:02:58,680 --> 00:03:03,090
delay between providing a signal to the

00:03:00,959 --> 00:03:05,280
monitor having the user see it these

00:03:03,090 --> 00:03:07,290
days monitors can buffer a couple of

00:03:05,280 --> 00:03:09,719
frames ahead which makes it very

00:03:07,290 --> 00:03:11,849
difficult for the application to get an

00:03:09,719 --> 00:03:14,730
idea of when its output is going to be

00:03:11,849 --> 00:03:16,409
presented we also have more

00:03:14,730 --> 00:03:18,150
sophisticated desktop environments it

00:03:16,409 --> 00:03:20,030
used to be that you rendered the scene

00:03:18,150 --> 00:03:23,340
and when the application drew something

00:03:20,030 --> 00:03:25,079
the next time the scant the the scan out

00:03:23,340 --> 00:03:27,659
engine went through that pixel it would

00:03:25,079 --> 00:03:29,030
display what you had just drawn and

00:03:27,659 --> 00:03:32,159
today we want to have sophisticated

00:03:29,030 --> 00:03:35,430
desktop events with animations and with

00:03:32,159 --> 00:03:37,319
with translucency and other effects on

00:03:35,430 --> 00:03:39,209
the screen and that means that there's a

00:03:37,319 --> 00:03:40,709
yet another system in between the

00:03:39,209 --> 00:03:43,889
application and the display called the

00:03:40,709 --> 00:03:46,560
compositing environment so whaling is a

00:03:43,889 --> 00:03:49,229
fully composited windowing system X has

00:03:46,560 --> 00:03:51,090
optional compositing windows now uses

00:03:49,229 --> 00:03:52,799
compositing the matte cos tan has always

00:03:51,090 --> 00:03:55,079
used compositing Android uses

00:03:52,799 --> 00:03:56,819
compositing and so the compositing

00:03:55,079 --> 00:03:58,680
compositing desktop environment is now

00:03:56,819 --> 00:04:00,900
kind of standard and that introduces

00:03:58,680 --> 00:04:02,340
additional software and additional

00:04:00,900 --> 00:04:04,620
complexity into the system and it makes

00:04:02,340 --> 00:04:07,409
it more difficult to figure out when

00:04:04,620 --> 00:04:09,090
things are being displayed another big

00:04:07,409 --> 00:04:10,799
change over the last 20 years has been

00:04:09,090 --> 00:04:13,680
the introduction of power and thermal

00:04:10,799 --> 00:04:15,299
management so now instead of the system

00:04:13,680 --> 00:04:16,829
running at a constant speed where once

00:04:15,299 --> 00:04:19,169
you kind of got going you kind of knew

00:04:16,829 --> 00:04:21,690
what was going on now the system will

00:04:19,169 --> 00:04:23,639
dynamically change the the the power

00:04:21,690 --> 00:04:27,300
processing power available the memory

00:04:23,639 --> 00:04:28,949
speed the GPU vs. CPU timing some

00:04:27,300 --> 00:04:30,539
systems will actually change the display

00:04:28,949 --> 00:04:33,030
timing dynamically in order to reduce

00:04:30,539 --> 00:04:35,550
power and that introduces a

00:04:33,030 --> 00:04:37,590
additional source of source of you know

00:04:35,550 --> 00:04:39,570
change in the latency of the system so

00:04:37,590 --> 00:04:41,130
measuring the system once and expecting

00:04:39,570 --> 00:04:44,250
it to continue to behave like that it's

00:04:41,130 --> 00:04:46,160
no longer it's no longer adequate and

00:04:44,250 --> 00:04:47,790
and the other thing is that our

00:04:46,160 --> 00:04:50,790
computational environment has become

00:04:47,790 --> 00:04:53,520
more complicated when the CPU was

00:04:50,790 --> 00:04:55,110
directly drawing to memory and doing all

00:04:53,520 --> 00:04:57,420
your animation directly with the CPU

00:04:55,110 --> 00:04:58,710
um you knew exactly when the pixels were

00:04:57,420 --> 00:05:00,540
getting changed in the screen because

00:04:58,710 --> 00:05:03,390
the instruction to write data into the

00:05:00,540 --> 00:05:05,220
frame buffer had completed now the GPU

00:05:03,390 --> 00:05:07,320
is a massively parallel separate

00:05:05,220 --> 00:05:09,360
computer on your machine and you pass it

00:05:07,320 --> 00:05:11,160
commands in a queue and say go and

00:05:09,360 --> 00:05:13,350
sometime in the future it will have

00:05:11,160 --> 00:05:15,780
finished that those those rendering

00:05:13,350 --> 00:05:18,240
operations and synchronizing between the

00:05:15,780 --> 00:05:19,680
GPU and the CPU is very expensive and it

00:05:18,240 --> 00:05:21,360
takes a lot of time so you want to

00:05:19,680 --> 00:05:23,250
minimize the number of times that you do

00:05:21,360 --> 00:05:25,380
that synchronization and that means that

00:05:23,250 --> 00:05:29,100
you don't have a good idea of where the

00:05:25,380 --> 00:05:31,290
GPU is in its computational workload the

00:05:29,100 --> 00:05:32,790
display of course can't start displaying

00:05:31,290 --> 00:05:35,160
the first pixel in the frame buffer

00:05:32,790 --> 00:05:37,050
until the GPU is done rendering the last

00:05:35,160 --> 00:05:38,580
pixel in the frame buffer that means

00:05:37,050 --> 00:05:40,260
that you have a huge amount of latency

00:05:38,580 --> 00:05:41,910
between when the rendering is complete

00:05:40,260 --> 00:05:43,650
or that when the rendering is started

00:05:41,910 --> 00:05:45,420
and when the display can even think

00:05:43,650 --> 00:05:46,920
about beginning and so there's

00:05:45,420 --> 00:05:49,050
additional latency is additional

00:05:46,920 --> 00:05:50,940
complexity it's just a very complicated

00:05:49,050 --> 00:05:53,810
environment I want to show you a couple

00:05:50,940 --> 00:05:56,460
of a couple of ways that we do display

00:05:53,810 --> 00:05:58,560
here's kind of the the classic before

00:05:56,460 --> 00:06:00,900
Window System environment where the

00:05:58,560 --> 00:06:02,520
system had 2 frame buffers are you draw

00:06:00,900 --> 00:06:03,870
two one you tell the display

00:06:02,520 --> 00:06:05,280
please start scanning out from this

00:06:03,870 --> 00:06:08,880
thing I've just drawn and we call that a

00:06:05,280 --> 00:06:10,890
flip so with only two buffers you

00:06:08,880 --> 00:06:12,360
actually have to wait for the flip to

00:06:10,890 --> 00:06:13,470
complete before you can start drawing

00:06:12,360 --> 00:06:15,480
the next scene and that's why this is

00:06:13,470 --> 00:06:19,500
that's why there's a delay between the

00:06:15,480 --> 00:06:21,390
drawing operations here so you draw on a

00:06:19,500 --> 00:06:23,400
one frame buffer you ask for it to flip

00:06:21,390 --> 00:06:25,320
the flip can't happen until the until

00:06:23,400 --> 00:06:27,990
the video system is ready and so there's

00:06:25,320 --> 00:06:30,180
a delay between when you ask for their

00:06:27,990 --> 00:06:31,950
flip to occur and when it actually

00:06:30,180 --> 00:06:35,580
occurs and of course it actually occurs

00:06:31,950 --> 00:06:36,720
at V blank and that delay is wasted GPU

00:06:35,580 --> 00:06:38,760
time of course you know you're not

00:06:36,720 --> 00:06:40,440
actually using the GPU so what

00:06:38,760 --> 00:06:42,360
applications are do is they try to get

00:06:40,440 --> 00:06:45,030
as much complexity into the scenes they

00:06:42,360 --> 00:06:46,590
could without going over right so you

00:06:45,030 --> 00:06:46,740
want you want to have that delay as well

00:06:46,590 --> 00:06:48,270
as

00:06:46,740 --> 00:06:53,910
possible so you're burning as many watts

00:06:48,270 --> 00:06:56,009
in your GP as you can let's see another

00:06:53,910 --> 00:06:57,479
another popular mode was instead of

00:06:56,009 --> 00:06:59,970
flipping the frame buffer we'll copy

00:06:57,479 --> 00:07:03,419
from what from the the rendered image

00:06:59,970 --> 00:07:05,550
onto the active scan out buffer this was

00:07:03,419 --> 00:07:07,740
this is common if you're only presenting

00:07:05,550 --> 00:07:09,389
a subset of the screen you don't want to

00:07:07,740 --> 00:07:11,160
replace the entire screen contents you

00:07:09,389 --> 00:07:15,360
just want to replace the subset we used

00:07:11,160 --> 00:07:17,910
to do this for for window DRI two you do

00:07:15,360 --> 00:07:20,430
a copy of the contents this of course

00:07:17,910 --> 00:07:22,860
means that the in this environment

00:07:20,430 --> 00:07:25,470
you're gonna wait for V blank and then

00:07:22,860 --> 00:07:27,810
you're going to start the copy on the

00:07:25,470 --> 00:07:30,030
and the the hope here is that the copy

00:07:27,810 --> 00:07:31,830
is going faster than the scan out so

00:07:30,030 --> 00:07:33,240
even if you start copying at the top of

00:07:31,830 --> 00:07:34,830
the frame buffer you're hoping that

00:07:33,240 --> 00:07:36,720
you're gonna get the copy enough ahead

00:07:34,830 --> 00:07:38,280
of the scan out engine that the the

00:07:36,720 --> 00:07:40,139
pixels that you're gonna get going out

00:07:38,280 --> 00:07:42,000
the display are all the new image of

00:07:40,139 --> 00:07:43,710
course if this if the copy goes a little

00:07:42,000 --> 00:07:45,479
slower or starts a little bit later

00:07:43,710 --> 00:07:47,490
you're going to get an artifact on the

00:07:45,479 --> 00:07:49,139
screen called a tear where you see some

00:07:47,490 --> 00:07:51,539
of the old contents at the top at the

00:07:49,139 --> 00:07:53,820
perhaps the top of this key frame buffer

00:07:51,539 --> 00:07:56,190
and the new contents at the bottom and

00:07:53,820 --> 00:07:58,080
that's a that's an undesirable artifact

00:07:56,190 --> 00:08:00,719
and so we like to use the flipping

00:07:58,080 --> 00:08:03,419
technique and so in a composited

00:08:00,719 --> 00:08:04,949
environment in particular the the system

00:08:03,419 --> 00:08:06,599
works very hard to make sure that you're

00:08:04,949 --> 00:08:07,560
flipping every time and that way you

00:08:06,599 --> 00:08:10,710
know that you're getting a complete

00:08:07,560 --> 00:08:12,780
frame buffer with no tear the problem

00:08:10,710 --> 00:08:15,240
with that is that if you if you take a

00:08:12,780 --> 00:08:17,729
little bit too long rendering then the

00:08:15,240 --> 00:08:19,380
flip may not happen at this V blank it

00:08:17,729 --> 00:08:21,270
may happen it may actually have to wait

00:08:19,380 --> 00:08:23,190
until the next feed length because you

00:08:21,270 --> 00:08:26,039
can only flip at the V blank interval

00:08:23,190 --> 00:08:28,380
typically and so that means that if you

00:08:26,039 --> 00:08:30,479
miss this frame buffer you're gonna wait

00:08:28,380 --> 00:08:31,860
all the way until the next frame so

00:08:30,479 --> 00:08:34,620
you're gonna miss a frame and I'll show

00:08:31,860 --> 00:08:36,510
you what that looks like the application

00:08:34,620 --> 00:08:38,130
here this is this is a composited

00:08:36,510 --> 00:08:39,599
environment that I'm showing but you can

00:08:38,130 --> 00:08:41,820
see here the application and the

00:08:39,599 --> 00:08:43,469
compositing system together are taking

00:08:41,820 --> 00:08:46,860
just a little bit too long so you've

00:08:43,469 --> 00:08:49,110
missed that V blank interval and so now

00:08:46,860 --> 00:08:51,450
that first frame is gonna wait all the

00:08:49,110 --> 00:08:53,399
way until frame number two now typically

00:08:51,450 --> 00:08:54,930
the application has no idea that it's

00:08:53,399 --> 00:08:56,910
misty blank it may get feedback

00:08:54,930 --> 00:08:58,320
eventually but when it's starting you're

00:08:56,910 --> 00:09:00,240
rendering it doesn't know because it

00:08:58,320 --> 00:09:01,890
wants to get going right away and so

00:09:00,240 --> 00:09:03,930
awake for an indication of when that D

00:09:01,890 --> 00:09:06,620
Blanc happened so it's gonna say okay

00:09:03,930 --> 00:09:08,790
I'm gonna draw now for frame number two

00:09:06,620 --> 00:09:10,020
and it's gonna cue up all of its

00:09:08,790 --> 00:09:11,580
rendering and then it's get a tell the

00:09:10,020 --> 00:09:13,320
compositor okay just play your frame

00:09:11,580 --> 00:09:15,060
number two and now the fret and that

00:09:13,320 --> 00:09:17,310
compositor is gonna say well I'd love to

00:09:15,060 --> 00:09:18,690
display frame number two but it's not

00:09:17,310 --> 00:09:19,770
gonna be displayed until frame number

00:09:18,690 --> 00:09:21,450
three because frame number two is

00:09:19,770 --> 00:09:23,279
contains the contents of the first thing

00:09:21,450 --> 00:09:26,100
that I drew so you can see now that my

00:09:23,279 --> 00:09:28,589
application is potentially perpetually

00:09:26,100 --> 00:09:30,360
one frame behind and what the

00:09:28,589 --> 00:09:33,750
application is going to do is eventually

00:09:30,360 --> 00:09:35,250
figure out oh I'm a frame behind somehow

00:09:33,750 --> 00:09:37,020
it's gonna get some feedback from the

00:09:35,250 --> 00:09:39,600
system somehow and it's gonna drop a

00:09:37,020 --> 00:09:41,070
frame at that point to catch up again so

00:09:39,600 --> 00:09:43,500
now you have two glitches you have the

00:09:41,070 --> 00:09:44,820
glitch when you started drawing and you

00:09:43,500 --> 00:09:47,459
and you dropped your frame so now the

00:09:44,820 --> 00:09:49,170
frame the the screen stalled for an

00:09:47,459 --> 00:09:51,300
entire frame and now you have another

00:09:49,170 --> 00:09:53,250
glitch where the animation jumps between

00:09:51,300 --> 00:09:54,870
two frames because you're going to

00:09:53,250 --> 00:09:56,820
display one frame earlier than it would

00:09:54,870 --> 00:10:00,180
have been in a smooth animation like you

00:09:56,820 --> 00:10:00,839
see in this company oh I'm going the

00:10:00,180 --> 00:10:03,450
wrong direction

00:10:00,839 --> 00:10:05,010
can't even operate my own device today

00:10:03,450 --> 00:10:07,170
this is what happens when you display a

00:10:05,010 --> 00:10:09,329
frame early okay so say your system is

00:10:07,170 --> 00:10:12,690
rendering and most of the time you're

00:10:09,329 --> 00:10:14,640
taking over one frame time to render the

00:10:12,690 --> 00:10:16,529
scene and so you decided to say well

00:10:14,640 --> 00:10:20,250
okay I'm only going to display every

00:10:16,529 --> 00:10:21,720
other frame and so you you you render up

00:10:20,250 --> 00:10:24,120
all your content you get it ready to go

00:10:21,720 --> 00:10:25,890
and you say go and the system says oh

00:10:24,120 --> 00:10:28,950
look you happen to be early today

00:10:25,890 --> 00:10:29,910
let me display your frame now and you're

00:10:28,950 --> 00:10:31,770
like wait a minute

00:10:29,910 --> 00:10:33,720
this content is not supposed to be seen

00:10:31,770 --> 00:10:37,290
now I'm trying to wait for every other

00:10:33,720 --> 00:10:39,029
frame so I get 30 Hertz refresh still

00:10:37,290 --> 00:10:41,490
smooth looking animation but

00:10:39,029 --> 00:10:43,430
unfortunately because some graphics

00:10:41,490 --> 00:10:45,450
environments don't have a way to ask for

00:10:43,430 --> 00:10:47,670
asking you to wait for a particular

00:10:45,450 --> 00:10:49,920
frame you're gonna end up displaying the

00:10:47,670 --> 00:10:52,170
frame early and you get an artifact on

00:10:49,920 --> 00:10:54,240
the screen even though you're rendering

00:10:52,170 --> 00:10:56,130
faster than you thought you would be

00:10:54,240 --> 00:10:58,140
going so you've got plenty of time

00:10:56,130 --> 00:11:00,420
you're not running too slowly you just

00:10:58,140 --> 00:11:02,640
computed the contents for the wrong time

00:11:00,420 --> 00:11:04,589
on the screen this actually happens

00:11:02,640 --> 00:11:07,230
quite a lot you see people complaining

00:11:04,589 --> 00:11:10,110
now that they're James their games are

00:11:07,230 --> 00:11:12,449
jerky on their on their screen and it

00:11:10,110 --> 00:11:14,140
turns out that they're rendering at 30

00:11:12,449 --> 00:11:15,910
Hertz but sometimes

00:11:14,140 --> 00:11:17,800
frames are arriving early and the

00:11:15,910 --> 00:11:20,410
application isn't asking for them to be

00:11:17,800 --> 00:11:22,930
delayed correctly one particular reason

00:11:20,410 --> 00:11:25,390
for this is that the new Vulkan API has

00:11:22,930 --> 00:11:27,730
no way to ask for you for the frame to

00:11:25,390 --> 00:11:30,310
be displayed at a particular time

00:11:27,730 --> 00:11:34,390
there's no there's no API for that so

00:11:30,310 --> 00:11:36,130
you just say go and you get it next okay

00:11:34,390 --> 00:11:37,720
so now we've seen a couple of problems

00:11:36,130 --> 00:11:38,740
we've got a kind of a sense of what the

00:11:37,720 --> 00:11:41,590
environment is so what are the

00:11:38,740 --> 00:11:43,990
requirements to get this to work right

00:11:41,590 --> 00:11:46,510
so the first thing is the application

00:11:43,990 --> 00:11:48,250
has to know when the content is going to

00:11:46,510 --> 00:11:49,990
be seen by the user it has to be able to

00:11:48,250 --> 00:11:51,730
know when V blank is going to occur I

00:11:49,990 --> 00:11:53,590
mean it also needs to know what

00:11:51,730 --> 00:11:56,560
additional delays are in the display

00:11:53,590 --> 00:11:58,630
system so if you have a monitor which

00:11:56,560 --> 00:12:00,270
has an entire frame a buffer or maybe it

00:11:58,630 --> 00:12:02,500
has a few milliseconds of latency

00:12:00,270 --> 00:12:05,020
ideally the application would be able to

00:12:02,500 --> 00:12:08,230
know that so in the VR headsets that

00:12:05,020 --> 00:12:10,000
that HTC produces with a lot in

00:12:08,230 --> 00:12:12,700
cooperation with valve those actually we

00:12:10,000 --> 00:12:14,410
actually know what the display lag in

00:12:12,700 --> 00:12:16,810
that system is we've measured it right

00:12:14,410 --> 00:12:18,760
so we actually tell the application this

00:12:16,810 --> 00:12:20,350
display has some lag you're going to

00:12:18,760 --> 00:12:22,510
want to produce content that's a little

00:12:20,350 --> 00:12:24,370
further in the future than you thought

00:12:22,510 --> 00:12:26,950
so that you so that the the scene as

00:12:24,370 --> 00:12:28,810
projected is is projected correctly not

00:12:26,950 --> 00:12:31,180
only that but we know that the scan out

00:12:28,810 --> 00:12:33,310
takes time so you actually want to

00:12:31,180 --> 00:12:35,770
generate content for the top of the

00:12:33,310 --> 00:12:37,510
frame which is at an earlier time than

00:12:35,770 --> 00:12:40,020
the content of the bottom of the frame

00:12:37,510 --> 00:12:42,070
so actually actively reprojected

00:12:40,020 --> 00:12:44,200
recomputing the content as the scanline

00:12:42,070 --> 00:12:46,180
goes down so that the contents at the

00:12:44,200 --> 00:12:47,740
bottom of the screen are further in the

00:12:46,180 --> 00:12:52,890
future than the contents at the top of

00:12:47,740 --> 00:12:56,680
the screen so it gets pretty complicated

00:12:52,890 --> 00:12:58,390
I'm sorry I'm getting over a cold you

00:12:56,680 --> 00:13:00,730
need to allow the applications to

00:12:58,390 --> 00:13:02,890
specify when the content is going to be

00:13:00,730 --> 00:13:04,630
displayed there's a couple of extensions

00:13:02,890 --> 00:13:06,730
that I'll talk about an OpenGL and valve

00:13:04,630 --> 00:13:08,740
and volcán that are going to be they're

00:13:06,730 --> 00:13:10,810
going to allow you to do this but that

00:13:08,740 --> 00:13:12,760
that control needs to be precise in

00:13:10,810 --> 00:13:15,310
absolute frames it's not please delay

00:13:12,760 --> 00:13:17,650
two frames no I really need to say this

00:13:15,310 --> 00:13:19,480
content needs to be displayed at you

00:13:17,650 --> 00:13:22,420
know at you know forty seven point three

00:13:19,480 --> 00:13:23,950
seconds into the of absolute time so

00:13:22,420 --> 00:13:26,650
that I know when that content is can be

00:13:23,950 --> 00:13:28,150
displayed that content needs that time

00:13:26,650 --> 00:13:30,580
needs to be synchronized

00:13:28,150 --> 00:13:32,380
system time and my device input times

00:13:30,580 --> 00:13:34,360
that I thought I can have a global sense

00:13:32,380 --> 00:13:37,360
of time and know when the content is

00:13:34,360 --> 00:13:39,040
gonna appear to the user the display

00:13:37,360 --> 00:13:40,840
system better be able to actually commit

00:13:39,040 --> 00:13:41,380
to getting to this frames display it on

00:13:40,840 --> 00:13:43,680
time

00:13:41,380 --> 00:13:45,940
if you can't display the frame on time

00:13:43,680 --> 00:13:47,320
when the application asks for it then

00:13:45,940 --> 00:13:49,690
you're gonna get those artifacts that I

00:13:47,320 --> 00:13:51,280
showed you another important part about

00:13:49,690 --> 00:13:53,080
this and this is something it's fairly

00:13:51,280 --> 00:13:54,760
recent is that we need to tell the

00:13:53,080 --> 00:13:58,240
applications when the frames were

00:13:54,760 --> 00:14:00,280
displayed most graphic systems today run

00:13:58,240 --> 00:14:01,840
open-loop which is to say you can ask

00:14:00,280 --> 00:14:04,180
for a frame to be displayed at a

00:14:01,840 --> 00:14:06,310
particular time but you may get no idea

00:14:04,180 --> 00:14:09,160
that when it's happened you may be able

00:14:06,310 --> 00:14:10,870
to intuit or figure out when it when it

00:14:09,160 --> 00:14:13,330
was displayed just because some things

00:14:10,870 --> 00:14:15,430
are getting slower it's like oh I I

00:14:13,330 --> 00:14:16,870
didn't get that buffer freed as soon as

00:14:15,430 --> 00:14:19,420
I thought it was going to be freed I

00:14:16,870 --> 00:14:20,650
must be a frame ahead now so you might

00:14:19,420 --> 00:14:22,960
be able to figure it out but you need

00:14:20,650 --> 00:14:24,970
some more positive mechanism of saying

00:14:22,960 --> 00:14:27,490
this frame was displayed you know at

00:14:24,970 --> 00:14:28,720
forty six point four seconds this frame

00:14:27,490 --> 00:14:33,190
was displayed and you know whatever

00:14:28,720 --> 00:14:35,230
whatever time and you also want to know

00:14:33,190 --> 00:14:38,170
when the rendering was done so you want

00:14:35,230 --> 00:14:39,970
to know how much time you had after the

00:14:38,170 --> 00:14:42,100
rendering completed before the frame was

00:14:39,970 --> 00:14:43,540
needed on on the screen so you wanna

00:14:42,100 --> 00:14:45,940
again when I get a sense of how much

00:14:43,540 --> 00:14:47,470
Marge and you have in the GPU so that

00:14:45,940 --> 00:14:49,390
when your margin starts going down as

00:14:47,470 --> 00:14:51,400
your scene becomes more complicated you

00:14:49,390 --> 00:14:52,900
may want to reduce your frame rate or

00:14:51,400 --> 00:14:56,320
you may want to reduce the scene

00:14:52,900 --> 00:14:58,180
complexity that GPU time and the display

00:14:56,320 --> 00:14:58,990
time need to be in the same time doing

00:14:58,180 --> 00:15:01,690
right now

00:14:58,990 --> 00:15:03,610
a typical the typical way you get GPU

00:15:01,690 --> 00:15:06,220
timing information is that the GPU has

00:15:03,610 --> 00:15:07,750
its own clock separate it's a separate

00:15:06,220 --> 00:15:09,550
processor it's got a separate crystal

00:15:07,750 --> 00:15:11,170
it's got a separate time domain and so

00:15:09,550 --> 00:15:12,970
you can ask the GPU one thing is

00:15:11,170 --> 00:15:15,580
completed it says all that completed at

00:15:12,970 --> 00:15:17,890
my time at 8.4 seconds it's like well

00:15:15,580 --> 00:15:19,570
okay I've got the display time of 40

00:15:17,890 --> 00:15:21,700
some seconds and the rendering time of

00:15:19,570 --> 00:15:23,440
eight seconds how do those how do those

00:15:21,700 --> 00:15:26,020
correlate and we'll show you how we fix

00:15:23,440 --> 00:15:27,580
that okay I'm going to talk about a

00:15:26,020 --> 00:15:29,680
little bit about OpenGL although I have

00:15:27,580 --> 00:15:32,590
been working on it because this is what

00:15:29,680 --> 00:15:34,290
was the genesis of the the current X the

00:15:32,590 --> 00:15:37,300
X mechanisms that they'd all talk about

00:15:34,290 --> 00:15:39,430
the the extension that I worked on that

00:15:37,300 --> 00:15:42,010
I'd look at most closely was this oml

00:15:39,430 --> 00:15:44,200
sync control and this actually lets the

00:15:42,010 --> 00:15:46,240
argit's specify which frame count in the

00:15:44,200 --> 00:15:48,610
absolute frame count the frame will be

00:15:46,240 --> 00:15:51,040
displayed at it's got some complicated

00:15:48,610 --> 00:15:53,260
math about modulus and divisors and all

00:15:51,040 --> 00:15:54,850
kinds of stuff that you could mostly

00:15:53,260 --> 00:15:56,440
ignore that because I don't know what

00:15:54,850 --> 00:15:59,170
they were thinking but you can't

00:15:56,440 --> 00:16:01,270
actually specify an absolute frame time

00:15:59,170 --> 00:16:02,470
unfortunately provides you know no

00:16:01,270 --> 00:16:04,630
feedback as to whether that was

00:16:02,470 --> 00:16:07,120
successful or not you just get a you get

00:16:04,630 --> 00:16:07,900
a okay so I'm I promise to display this

00:16:07,120 --> 00:16:09,520
at some point

00:16:07,900 --> 00:16:13,390
I'm you've asked for it to be displayed

00:16:09,520 --> 00:16:15,070
at this time it's a start another thing

00:16:13,390 --> 00:16:17,320
another control that was provided

00:16:15,070 --> 00:16:19,810
earlier in OpenGL is SWAT control and

00:16:17,320 --> 00:16:22,030
that allows you to specify a relative

00:16:19,810 --> 00:16:23,890
interval between frames and that sound

00:16:22,030 --> 00:16:25,840
applications used to switch from 60

00:16:23,890 --> 00:16:28,690
Hertz to 30 Hertz they would set the

00:16:25,840 --> 00:16:31,210
swap control value from 1 to 2 so you

00:16:28,690 --> 00:16:32,950
display every other frame again no

00:16:31,210 --> 00:16:35,350
feedback when the presentation actually

00:16:32,950 --> 00:16:38,080
occurred so in Vulcan we've got a couple

00:16:35,350 --> 00:16:40,030
of new things Google actually came up

00:16:38,080 --> 00:16:42,310
with an extension for Android called

00:16:40,030 --> 00:16:44,680
Google display timing and this extension

00:16:42,310 --> 00:16:47,920
actually allows you to specify absolute

00:16:44,680 --> 00:16:49,630
times relative to the processors the OS

00:16:47,920 --> 00:16:52,030
time the clock monotonic on the system

00:16:49,630 --> 00:16:54,040
please display this frame at this clock

00:16:52,030 --> 00:16:56,080
monotonic value and it's the display

00:16:54,040 --> 00:17:00,160
systems job to figure out what that

00:16:56,080 --> 00:17:01,900
means for the g4 the display engine well

00:17:00,160 --> 00:17:04,270
you get feedback for win frames were

00:17:01,900 --> 00:17:06,820
displayed again using the same monotonic

00:17:04,270 --> 00:17:10,360
value you also get feedback about how

00:17:06,820 --> 00:17:12,880
much how much Leyton's how much over

00:17:10,360 --> 00:17:15,850
space you had in the G on the GPU so you

00:17:12,880 --> 00:17:17,650
get an idea of how much how much gap you

00:17:15,850 --> 00:17:18,880
have available to fill up with

00:17:17,650 --> 00:17:21,250
additional rendering so you can get an

00:17:18,880 --> 00:17:25,600
idea of of whether you're running on

00:17:21,250 --> 00:17:27,940
time unfortunately because of the

00:17:25,600 --> 00:17:30,940
Android display system architecture this

00:17:27,940 --> 00:17:32,590
is not something you get right away you

00:17:30,940 --> 00:17:34,480
don't get this feedback after every

00:17:32,590 --> 00:17:36,640
frame as soon as it's been displayed I

00:17:34,480 --> 00:17:38,290
mean in fact in the in the end roid

00:17:36,640 --> 00:17:40,480
display architecture this data may be

00:17:38,290 --> 00:17:43,090
displayed may be delayed by up to 5

00:17:40,480 --> 00:17:46,120
frames so I mean you may find out that

00:17:43,090 --> 00:17:48,340
you relate you know 5 frames later which

00:17:46,120 --> 00:17:50,680
is an awful lot off a long time to the

00:17:48,340 --> 00:17:52,360
user who's got a VR headset strapped to

00:17:50,680 --> 00:17:53,890
their head and they're attempting not to

00:17:52,360 --> 00:17:55,389
fall over

00:17:53,890 --> 00:17:57,219
of course you

00:17:55,389 --> 00:17:58,899
a desktop environment where we're not so

00:17:57,219 --> 00:18:00,579
worried about power consumption we're

00:17:58,899 --> 00:18:02,169
more willing to take the context which

00:18:00,579 --> 00:18:04,329
is necessary to get that information

00:18:02,169 --> 00:18:06,279
back to the application quickly so in my

00:18:04,329 --> 00:18:09,399
implementation of Google display timing

00:18:06,279 --> 00:18:11,799
on Mesa you actually get the information

00:18:09,399 --> 00:18:13,869
very soon after V blank the event the

00:18:11,799 --> 00:18:15,339
event comes back from the system wanders

00:18:13,869 --> 00:18:18,179
its way all the way through the display

00:18:15,339 --> 00:18:20,919
system and it's all all synchronously

00:18:18,179 --> 00:18:22,599
recorded so it's probably within a less

00:18:20,919 --> 00:18:24,609
than a millisecond of the actual V blank

00:18:22,599 --> 00:18:25,659
that you kept this data back you don't

00:18:24,609 --> 00:18:27,009
know when the data is going to be

00:18:25,659 --> 00:18:28,659
available because the EPI doesn't

00:18:27,009 --> 00:18:30,999
provide any way for you to figure out

00:18:28,659 --> 00:18:33,309
when it will be available so if you ask

00:18:30,999 --> 00:18:34,989
too early you're not gonna get the one

00:18:33,309 --> 00:18:39,369
for the previous frame which is kind of

00:18:34,989 --> 00:18:41,799
annoying another interesting problem is

00:18:39,369 --> 00:18:44,320
the is that volcán provides no way for

00:18:41,799 --> 00:18:46,690
the application to kind of clock itself

00:18:44,320 --> 00:18:48,099
by presentations which is to say I don't

00:18:46,690 --> 00:18:50,229
want to get too far ahead of the

00:18:48,099 --> 00:18:51,969
rendering engine I want to be always two

00:18:50,229 --> 00:18:53,769
frames ahead or always one frame ahead

00:18:51,969 --> 00:18:55,269
or whatever whatever I need to do in

00:18:53,769 --> 00:18:57,579
order to cover my in order to make sure

00:18:55,269 --> 00:18:59,289
the GPU stays busy but volcán doesn't

00:18:57,579 --> 00:19:01,929
provide any way for you to clock the

00:18:59,289 --> 00:19:04,239
application by fly just by displayed

00:19:01,929 --> 00:19:07,089
frames it allows you to clock it by

00:19:04,239 --> 00:19:08,559
available display buffers because when

00:19:07,089 --> 00:19:10,629
you ask for a display buffer you can

00:19:08,559 --> 00:19:11,979
only get one that is idle and so if the

00:19:10,629 --> 00:19:13,690
other ones are all being rendered -

00:19:11,979 --> 00:19:17,259
you're not gonna get one for a while

00:19:13,690 --> 00:19:19,089
you'll wait but the number of display

00:19:17,259 --> 00:19:21,219
buffers may need to be large for some

00:19:19,089 --> 00:19:24,489
obscure corner cases typically these

00:19:21,219 --> 00:19:26,529
days we allocate four so you may not you

00:19:24,489 --> 00:19:28,809
may your that means you're gonna have

00:19:26,529 --> 00:19:31,179
between one and four frames buffered and

00:19:28,809 --> 00:19:32,799
you don't know how many it is oh it's

00:19:31,179 --> 00:19:35,649
just to say you may get as many as four

00:19:32,799 --> 00:19:37,059
frames ahead of the GP of the display

00:19:35,649 --> 00:19:39,700
engine in your rendering which is

00:19:37,059 --> 00:19:42,609
annoying the best practice today

00:19:39,700 --> 00:19:44,859
actually uses this Vulcan extension

00:19:42,609 --> 00:19:46,359
called display control it only works on

00:19:44,859 --> 00:19:48,820
direct display environments it doesn't

00:19:46,359 --> 00:19:50,409
work in a Windows system and so we do

00:19:48,820 --> 00:19:52,779
this with the VR headsets right now we

00:19:50,409 --> 00:19:54,909
actually clock the system based upon V

00:19:52,779 --> 00:19:56,139
blanks coming to the application to make

00:19:54,909 --> 00:19:57,789
sure that we're no more than one frame

00:19:56,139 --> 00:19:59,409
ahead the problem with that of course is

00:19:57,789 --> 00:20:01,629
that we have no idea if the present

00:19:59,409 --> 00:20:03,429
actually occur to that V blank so if we

00:20:01,629 --> 00:20:05,859
ever get if we ever get behind the

00:20:03,429 --> 00:20:07,690
display we have we can't figure it out

00:20:05,859 --> 00:20:09,130
very soon it takes us a long time in

00:20:07,690 --> 00:20:10,780
order to discover that

00:20:09,130 --> 00:20:13,750
we got a frame behind because we get no

00:20:10,780 --> 00:20:15,430
immediate feedback so we want something

00:20:13,750 --> 00:20:17,140
as triggered by present and we're

00:20:15,430 --> 00:20:20,200
working on working on some extensions

00:20:17,140 --> 00:20:21,550
the all the in the easy thing to do here

00:20:20,200 --> 00:20:23,800
is to implement it on Mesa and I

00:20:21,550 --> 00:20:26,350
implemented on Mesa and I get a fence

00:20:23,800 --> 00:20:29,110
now after the present happens the only

00:20:26,350 --> 00:20:31,570
hard part is actually specifying when

00:20:29,110 --> 00:20:34,720
that is because there's no really good

00:20:31,570 --> 00:20:36,790
idea of when the present has completed

00:20:34,720 --> 00:20:38,350
it's like well did it happen in the V

00:20:36,790 --> 00:20:40,360
Blanc well we don't really have a notion

00:20:38,350 --> 00:20:41,800
of V blanket volcán so there's a bunch

00:20:40,360 --> 00:20:44,950
of semantics that we need to figure out

00:20:41,800 --> 00:20:47,320
to specify a time that is tight enough

00:20:44,950 --> 00:20:50,230
to be useful and loose enough to be both

00:20:47,320 --> 00:20:52,270
testable and implementable so we're

00:20:50,230 --> 00:20:54,550
working on that another extension and in

00:20:52,270 --> 00:20:56,320
the recent version of volcán is called

00:20:54,550 --> 00:21:00,400
calibrated time stamps I worked on this

00:20:56,320 --> 00:21:02,980
one over the fall this actually lets you

00:21:00,400 --> 00:21:04,930
take a function call they get you back

00:21:02,980 --> 00:21:07,240
times in multiple domains so you can get

00:21:04,930 --> 00:21:10,030
a GPU time and a clock monotonic time

00:21:07,240 --> 00:21:12,040
that are at the same time of course you

00:21:10,030 --> 00:21:14,230
know in our relativistic world there's

00:21:12,040 --> 00:21:15,820
no such thing as the same time but we

00:21:14,230 --> 00:21:18,040
but what the system actually what this

00:21:15,820 --> 00:21:20,980
extension actually does is it says okay

00:21:18,040 --> 00:21:23,470
I sampled all these clocks and all of

00:21:20,980 --> 00:21:25,150
them are within this Delta of each other

00:21:23,470 --> 00:21:27,730
I sampled them all within this amount of

00:21:25,150 --> 00:21:30,010
time and that time is usually you know

00:21:27,730 --> 00:21:31,660
way less than a millisecond so we're

00:21:30,010 --> 00:21:33,400
actually able to give the application an

00:21:31,660 --> 00:21:35,320
idea of whether the answer they got back

00:21:33,400 --> 00:21:37,000
is usable or not I mean if they don't

00:21:35,320 --> 00:21:37,710
like the battle they got they can always

00:21:37,000 --> 00:21:40,330
try again

00:21:37,710 --> 00:21:41,860
so that's actually that actually I used

00:21:40,330 --> 00:21:44,710
that in the implementation of Google

00:21:41,860 --> 00:21:46,750
display timing so we actually the Google

00:21:44,710 --> 00:21:49,240
Display timing now gives you time GPU

00:21:46,750 --> 00:21:50,950
times that are relative to the clock

00:21:49,240 --> 00:21:52,750
monotonic time you get for the displays

00:21:50,950 --> 00:21:55,660
you can correlate them which is NASA

00:21:52,750 --> 00:21:57,490
which is useful okay so this is what

00:21:55,660 --> 00:21:59,860
Vulcan used to look like when you had an

00:21:57,490 --> 00:22:02,980
application you would basically say okay

00:21:59,860 --> 00:22:05,140
I'm gonna assume that I'm that I'm that

00:22:02,980 --> 00:22:07,870
I'm that I'm keeping up with the display

00:22:05,140 --> 00:22:09,970
and I'm gonna render a frame for the

00:22:07,870 --> 00:22:11,470
current time and I'm gonna I'm just

00:22:09,970 --> 00:22:13,750
gonna go present it and it's gonna get

00:22:11,470 --> 00:22:15,400
presented at whatever that time is right

00:22:13,750 --> 00:22:17,320
and then I'm gonna and then I'm gonna

00:22:15,400 --> 00:22:19,810
say okay the next time that I'm gonna

00:22:17,320 --> 00:22:22,030
render for is for whatever that current

00:22:19,810 --> 00:22:22,930
time is plus however long the frame is

00:22:22,030 --> 00:22:24,610
right

00:22:22,930 --> 00:22:26,020
whatever my refresh interval is I'm

00:22:24,610 --> 00:22:27,610
gonna render the next frame for the next

00:22:26,020 --> 00:22:29,620
time you can see this is running

00:22:27,610 --> 00:22:31,690
open-loop I get no feedback here so if I

00:22:29,620 --> 00:22:34,840
if I make mistakes well they're gonna

00:22:31,690 --> 00:22:36,460
kind of persist for a while you can you

00:22:34,840 --> 00:22:38,230
can put some additional tweaks in this

00:22:36,460 --> 00:22:41,440
to kind of recover eventually but it

00:22:38,230 --> 00:22:43,420
takes a while okay so the new volcán

00:22:41,440 --> 00:22:45,790
luke loop is going to look like this I'm

00:22:43,420 --> 00:22:46,990
gonna render a frame for the current

00:22:45,790 --> 00:22:49,900
time that I want to show on the screen

00:22:46,990 --> 00:22:51,370
and then I'm gonna present that frame at

00:22:49,900 --> 00:22:53,440
that current time that's obviously a

00:22:51,370 --> 00:22:54,820
time in the future I'm sorry I kind of

00:22:53,440 --> 00:22:56,590
messed up the code in this loop I wasn't

00:22:54,820 --> 00:22:58,420
thinking very clearly um and then I'm

00:22:56,590 --> 00:23:00,310
gonna go find out when historically

00:22:58,420 --> 00:23:01,870
frames were presented I'm gonna get

00:23:00,310 --> 00:23:03,340
whatever data the system could provide

00:23:01,870 --> 00:23:05,260
me for feedback in terms of when the

00:23:03,340 --> 00:23:07,150
frames were displayed I'm gonna figure

00:23:05,260 --> 00:23:08,770
out what a reasonable frame step is

00:23:07,150 --> 00:23:10,840
going to be given what I have been

00:23:08,770 --> 00:23:12,910
managing and a few in the past and I'm

00:23:10,840 --> 00:23:15,220
going to compute the next the next time

00:23:12,910 --> 00:23:17,050
the display based upon that so here you

00:23:15,220 --> 00:23:18,850
can see we've closed the loop now the

00:23:17,050 --> 00:23:21,070
display system is providing feedback to

00:23:18,850 --> 00:23:24,520
the system and I can get it I can get it

00:23:21,070 --> 00:23:28,660
controlled okay so now I'm going to talk

00:23:24,520 --> 00:23:30,280
about some changes in X the the awesome

00:23:28,660 --> 00:23:32,500
part is because of the work we did with

00:23:30,280 --> 00:23:34,840
the oml sync control extension for GL

00:23:32,500 --> 00:23:36,490
the present extension actually provides

00:23:34,840 --> 00:23:38,620
enough information to close the loop

00:23:36,490 --> 00:23:40,180
here it actually provides control over

00:23:38,620 --> 00:23:41,920
when things are going to be displayed

00:23:40,180 --> 00:23:44,170
and it tells you when things were

00:23:41,920 --> 00:23:45,700
displayed unfortunately the

00:23:44,170 --> 00:23:47,620
implementation kind of lags the

00:23:45,700 --> 00:23:51,570
capabilities the extension when the

00:23:47,620 --> 00:23:51,570
desktop is composited there is a bug

00:23:52,050 --> 00:23:57,690
let's see so in an X system when you're

00:23:55,450 --> 00:23:59,800
doing a flip in a composited environment

00:23:57,690 --> 00:24:01,750
ideally what would happen is you would

00:23:59,800 --> 00:24:03,250
do a bunch of rendering are you do some

00:24:01,750 --> 00:24:07,930
compositing and then you'd wait for a

00:24:03,250 --> 00:24:09,550
frame to be displayed right and so oh no

00:24:07,930 --> 00:24:11,740
this is the none compositing case in the

00:24:09,550 --> 00:24:14,440
in compositing case that little green X

00:24:11,740 --> 00:24:16,690
box that's gonna be X just doing stuff

00:24:14,440 --> 00:24:18,100
to get the frame ready to go and then

00:24:16,690 --> 00:24:19,510
it's gonna be flipped onto the screen at

00:24:18,100 --> 00:24:21,460
the be blank when you're copying it's

00:24:19,510 --> 00:24:22,990
gonna look a little different you're

00:24:21,460 --> 00:24:24,940
gonna you're gonna do a bunch of drawing

00:24:22,990 --> 00:24:26,860
you're gonna go tell X hey X I want this

00:24:24,940 --> 00:24:28,060
presented X is gonna do a little bit of

00:24:26,860 --> 00:24:29,850
work and then it's gonna wait for V

00:24:28,060 --> 00:24:32,200
blank and then X is gonna do the copy

00:24:29,850 --> 00:24:33,820
and then the application is gonna get

00:24:32,200 --> 00:24:35,809
notified the application is gonna go on

00:24:33,820 --> 00:24:38,450
its way these work great in an

00:24:35,809 --> 00:24:40,219
compositive case this is when ex doesn't

00:24:38,450 --> 00:24:41,929
have a compositing manager so you're

00:24:40,219 --> 00:24:44,779
running you're running with all the

00:24:41,929 --> 00:24:46,309
artifacts that entails ideally in a

00:24:44,779 --> 00:24:47,869
composite environment it would look very

00:24:46,309 --> 00:24:49,729
much the same right

00:24:47,869 --> 00:24:51,469
you do a bunch of draw you tell X it

00:24:49,729 --> 00:24:52,639
would go do some compositing and get it

00:24:51,469 --> 00:24:54,529
ready for the frame and it would get

00:24:52,639 --> 00:24:56,899
presented right away

00:24:54,529 --> 00:24:59,570
and that would be you wouldn't see any

00:24:56,899 --> 00:25:02,629
any big problems unfortunately there's a

00:24:59,570 --> 00:25:05,299
bug and the bug is that X the

00:25:02,629 --> 00:25:07,190
compositing the composite extension and

00:25:05,299 --> 00:25:12,409
the present extension don't talk to each

00:25:07,190 --> 00:25:14,509
other the present extension says oh I

00:25:12,409 --> 00:25:16,369
would like to present the scene and so

00:25:14,509 --> 00:25:18,259
it carefully gets the new route window

00:25:16,369 --> 00:25:20,929
ready - the new window contents ready to

00:25:18,259 --> 00:25:23,269
go and then and then and it waits for a

00:25:20,929 --> 00:25:25,549
V blank because of course it wants to

00:25:23,269 --> 00:25:27,830
present this that that frame at V blank

00:25:25,549 --> 00:25:29,509
time and envy blank time it says Oh

00:25:27,830 --> 00:25:31,969
time to present and what do you do to

00:25:29,509 --> 00:25:33,440
present oh you tell the compositing

00:25:31,969 --> 00:25:36,200
manager that you'd like to present your

00:25:33,440 --> 00:25:37,759
scene and so now at V blank time you

00:25:36,200 --> 00:25:39,440
tell the compositing manager please show

00:25:37,759 --> 00:25:41,269
the new contents of my window the

00:25:39,440 --> 00:25:42,769
compositing managers like awesome I'll

00:25:41,269 --> 00:25:44,479
go get the new contents and construct a

00:25:42,769 --> 00:25:47,989
new frame buffer and get a new image

00:25:44,479 --> 00:25:51,080
ready and wait for me like so now you're

00:25:47,989 --> 00:25:53,059
always a frame behind which could be

00:25:51,080 --> 00:25:55,820
taught which would be tolerable if you

00:25:53,059 --> 00:25:57,559
told the application that right if the

00:25:55,820 --> 00:25:58,940
application knew when it was frame was

00:25:57,559 --> 00:26:00,799
being displayed it could probably

00:25:58,940 --> 00:26:02,869
survive yeah it's an additional frame of

00:26:00,799 --> 00:26:05,570
lag windows does that application

00:26:02,869 --> 00:26:07,849
survive unfortunately it's it's as bad

00:26:05,570 --> 00:26:09,649
as you can imagine X actually tells the

00:26:07,849 --> 00:26:12,289
application that its frame was displayed

00:26:09,649 --> 00:26:14,330
when it told the compositing manager to

00:26:12,289 --> 00:26:18,469
display the frame which is to say one

00:26:14,330 --> 00:26:22,489
frame early so that's pretty awful so

00:26:18,469 --> 00:26:24,919
every frame is is delayed by a by

00:26:22,489 --> 00:26:27,739
exactly one by one frame or more and

00:26:24,919 --> 00:26:30,679
every frame is the time that every frame

00:26:27,739 --> 00:26:32,869
is presented is a lie which is kind of

00:26:30,679 --> 00:26:34,159
suboptimal and you can see this in a

00:26:32,869 --> 00:26:35,929
composited environment if you've ever

00:26:34,159 --> 00:26:36,769
done gameplay and in compositing

00:26:35,929 --> 00:26:39,679
environments like wait a minute

00:26:36,769 --> 00:26:41,330
everything is kind of off and you turn

00:26:39,679 --> 00:26:44,239
out compositing and it's awesome

00:26:41,330 --> 00:26:45,440
um Weston and Wayland doesn't the

00:26:44,239 --> 00:26:47,239
Westend implementation of whaling

00:26:45,440 --> 00:26:49,249
doesn't have this problem because it

00:26:47,239 --> 00:26:49,700
actually starts compositing slightly

00:26:49,249 --> 00:26:52,429
before

00:26:49,700 --> 00:26:57,679
be blank instead of at the blank which

00:26:52,429 --> 00:26:58,880
is a nice feature so really simple

00:26:57,679 --> 00:27:00,710
occludes that I implemented a couple

00:26:58,880 --> 00:27:02,750
years ago to test out to see if this was

00:27:00,710 --> 00:27:05,120
actually something and I could solve it

00:27:02,750 --> 00:27:07,159
was to send the to tell the compositor

00:27:05,120 --> 00:27:09,260
that there was new window contents right

00:27:07,159 --> 00:27:10,909
when the present pixmap occurred as soon

00:27:09,260 --> 00:27:12,889
as the application called present pixmap

00:27:10,909 --> 00:27:14,419
you tell the compositor hey there's new

00:27:12,889 --> 00:27:16,190
content for this window and the

00:27:14,419 --> 00:27:18,110
compositor would construct a new window

00:27:16,190 --> 00:27:21,260
image and get it displayed at the

00:27:18,110 --> 00:27:24,529
appropriate frame so this worked as long

00:27:21,260 --> 00:27:26,720
as the application wanted its content to

00:27:24,529 --> 00:27:28,639
be displayed in the next frame and as

00:27:26,720 --> 00:27:31,250
long as a compositor managed to get the

00:27:28,639 --> 00:27:33,380
contents ready in time for that frame so

00:27:31,250 --> 00:27:34,850
I was I was kind of lying to the

00:27:33,380 --> 00:27:37,130
application because I was telling the

00:27:34,850 --> 00:27:38,539
application that its contents were going

00:27:37,130 --> 00:27:40,429
to be displayed when it asks for them to

00:27:38,539 --> 00:27:42,230
be displayed I was kind of counting on

00:27:40,429 --> 00:27:44,630
the system to work and keep things in

00:27:42,230 --> 00:27:48,340
line so as long as you had plenty of

00:27:44,630 --> 00:27:50,750
margin in your GPU this was awesome and

00:27:48,340 --> 00:27:52,340
of course it worked in unless the

00:27:50,750 --> 00:27:54,529
application wanted to render at 30 Hertz

00:27:52,340 --> 00:27:56,510
which was like well no you're gonna get

00:27:54,529 --> 00:27:58,399
rendered one frame early every time

00:27:56,510 --> 00:28:00,049
because it was just you know it was a

00:27:58,399 --> 00:28:02,960
test it was like can this work at all

00:28:00,049 --> 00:28:04,429
and I tested that with some some

00:28:02,960 --> 00:28:06,169
measurement stuff I've setup at home and

00:28:04,429 --> 00:28:08,840
it worked it worked pretty well it was

00:28:06,169 --> 00:28:11,990
like nice so I have a slightly better X

00:28:08,840 --> 00:28:14,000
Cluj so now what I want to do is I want

00:28:11,990 --> 00:28:15,980
to have the X server pend the damage

00:28:14,000 --> 00:28:17,539
until the right time and we'll talk

00:28:15,980 --> 00:28:19,669
about the right time in a while

00:28:17,539 --> 00:28:22,100
deliver the damage compositor at that

00:28:19,669 --> 00:28:23,960
appropriate time remember what damage

00:28:22,100 --> 00:28:26,179
that I sent to the compositor so the

00:28:23,960 --> 00:28:28,580
future damage occurs I'm gonna kind of

00:28:26,179 --> 00:28:30,380
pretend that that didn't happen and now

00:28:28,580 --> 00:28:33,260
I'm gonna send the present events at the

00:28:30,380 --> 00:28:35,779
same time as a compositor event the

00:28:33,260 --> 00:28:38,029
compositor gets its present events so

00:28:35,779 --> 00:28:39,409
I'm going to tie the presentation that

00:28:38,029 --> 00:28:41,389
I'm going to tell the application that

00:28:39,409 --> 00:28:44,179
its contents were displayed when the

00:28:41,389 --> 00:28:47,539
next compositor frame is displayed so

00:28:44,179 --> 00:28:49,850
now if if things work correctly and then

00:28:47,539 --> 00:28:51,769
the application is going to get notified

00:28:49,850 --> 00:28:54,380
that its contents were displayed when

00:28:51,769 --> 00:28:57,320
the compositor displayed its its its

00:28:54,380 --> 00:28:58,960
contents so the only potential confusion

00:28:57,320 --> 00:29:01,309
here is if there's additional

00:28:58,960 --> 00:29:03,230
application changes between the time

00:29:01,309 --> 00:29:05,360
that the compositor started

00:29:03,230 --> 00:29:07,460
it's composition and the time the

00:29:05,360 --> 00:29:09,170
display occurred and so the the X server

00:29:07,460 --> 00:29:11,690
is making some assumptions that the

00:29:09,170 --> 00:29:13,430
application isn't doing crazy stuff the

00:29:11,690 --> 00:29:15,260
nice thing about this simple clue just

00:29:13,430 --> 00:29:17,150
that no changes than compositor required

00:29:15,260 --> 00:29:18,980
right I'm not gonna I'm not gonna change

00:29:17,150 --> 00:29:20,450
what the compositor does I'm gonna send

00:29:18,980 --> 00:29:22,790
it damage and expect it to present a

00:29:20,450 --> 00:29:25,820
frame and I can hide all of the magic in

00:29:22,790 --> 00:29:27,560
the X server I'm a slightly more

00:29:25,820 --> 00:29:31,730
principled X fix that I'm planning on

00:29:27,560 --> 00:29:33,380
doing is to actually mark the damage

00:29:31,730 --> 00:29:37,220
events with sequence numbers so I can

00:29:33,380 --> 00:29:40,190
actually tell what what damage the

00:29:37,220 --> 00:29:42,020
compositor has managed to process

00:29:40,190 --> 00:29:43,520
because I'm going to send those numbers

00:29:42,020 --> 00:29:46,160
to the composite and the compositor is

00:29:43,520 --> 00:29:48,740
gonna tell me which damage sequence it

00:29:46,160 --> 00:29:52,100
has it had managed to get to in the

00:29:48,740 --> 00:29:54,110
process of its presentation so the goal

00:29:52,100 --> 00:29:55,940
here is it's just a slightly more

00:29:54,110 --> 00:29:57,680
principle to fix it's going to require

00:29:55,940 --> 00:29:59,480
some changes and compositors but they're

00:29:57,680 --> 00:30:01,370
not very major basically the compositor

00:29:59,480 --> 00:30:03,290
is gonna take a value out of the last

00:30:01,370 --> 00:30:06,410
damage that event that it processed and

00:30:03,290 --> 00:30:07,610
hand it back to the X server and that

00:30:06,410 --> 00:30:09,950
works pretty well okay so now the

00:30:07,610 --> 00:30:11,330
question is what's the right time I can

00:30:09,950 --> 00:30:12,890
tell you right now that I've studied a

00:30:11,330 --> 00:30:15,860
bunch of windows systems and they choose

00:30:12,890 --> 00:30:17,900
they have different answers windows

00:30:15,860 --> 00:30:21,230
actually delays your application by an

00:30:17,900 --> 00:30:25,280
entire frame every single time so when

00:30:21,230 --> 00:30:27,470
you present a frame windows starts

00:30:25,280 --> 00:30:29,240
rendering the composited in scene

00:30:27,470 --> 00:30:31,430
containing that frame at the next feed

00:30:29,240 --> 00:30:32,810
length just like X does today the

00:30:31,430 --> 00:30:34,190
advantage that Windows has is they don't

00:30:32,810 --> 00:30:36,740
lie about when your scene is getting

00:30:34,190 --> 00:30:37,610
presented so the applications can can

00:30:36,740 --> 00:30:39,140
recover from that

00:30:37,610 --> 00:30:42,140
but that means in Windows you're always

00:30:39,140 --> 00:30:44,210
a frame behind right because this and

00:30:42,140 --> 00:30:46,040
and so applications often want to get

00:30:44,210 --> 00:30:47,690
rid of that and so they go into full

00:30:46,040 --> 00:30:49,520
screen direct mode which gets rid of

00:30:47,690 --> 00:30:54,380
that overhead but that has all kinds of

00:30:49,520 --> 00:30:56,810
other other adventures on Mac cause they

00:30:54,380 --> 00:30:58,370
give you a fixed amount of time within

00:30:56,810 --> 00:30:59,810
the frame for the compositing I don't

00:30:58,370 --> 00:31:01,850
remember how much it is it's several

00:30:59,810 --> 00:31:03,950
milliseconds that means the amount of

00:31:01,850 --> 00:31:06,980
time you have to render your application

00:31:03,950 --> 00:31:08,450
is is less the total frame time by that

00:31:06,980 --> 00:31:10,850
amount so I think it's probably you know

00:31:08,450 --> 00:31:12,560
it's a it's four milliseconds so in a 16

00:31:10,850 --> 00:31:14,480
millisecond frame now your application

00:31:12,560 --> 00:31:16,370
gets 12 milliseconds to render its frame

00:31:14,480 --> 00:31:16,909
and if you miss that window then you're

00:31:16,370 --> 00:31:19,970
gonna get too

00:31:16,909 --> 00:31:21,349
play to the next frame what I would like

00:31:19,970 --> 00:31:26,479
to do is do a little something a little

00:31:21,349 --> 00:31:27,919
fancier maybe and maybe I can't one

00:31:26,479 --> 00:31:29,299
thing you can obviously do is you can

00:31:27,919 --> 00:31:31,340
just do a bunch of measurements we've

00:31:29,299 --> 00:31:32,960
got huge amounts of data here right I

00:31:31,340 --> 00:31:34,669
can keep track of how long the

00:31:32,960 --> 00:31:37,789
compositing process has taken

00:31:34,669 --> 00:31:38,960
historically get a get a sense if there

00:31:37,789 --> 00:31:39,979
are any dramatic changes of the

00:31:38,960 --> 00:31:42,739
environment like windows got

00:31:39,979 --> 00:31:44,989
reconfigured or something and guess that

00:31:42,739 --> 00:31:47,149
the the compositing time for the next

00:31:44,989 --> 00:31:49,070
frame is going to either be similar or

00:31:47,149 --> 00:31:50,690
very different from the previous rain so

00:31:49,070 --> 00:31:52,369
I can probably do a better job in a

00:31:50,690 --> 00:31:55,129
fixed time with some pretty simple

00:31:52,369 --> 00:31:58,099
heuristics another idea that I had it's

00:31:55,129 --> 00:32:00,590
even simpler than that is to look at

00:31:58,099 --> 00:32:02,960
when the application which has the users

00:32:00,590 --> 00:32:05,479
intent or it has the users input focus

00:32:02,960 --> 00:32:07,489
and say that when that application does

00:32:05,479 --> 00:32:09,769
it present I can probably start

00:32:07,489 --> 00:32:11,720
compositing right then and and just kind

00:32:09,769 --> 00:32:13,159
of let the other applications float it's

00:32:11,720 --> 00:32:15,679
like well the other applications come

00:32:13,159 --> 00:32:17,359
along and render stuff they may get into

00:32:15,679 --> 00:32:18,499
this frame if they're early or they may

00:32:17,359 --> 00:32:21,679
get into the next frame with they're

00:32:18,499 --> 00:32:23,779
late and that seems like a pretty simple

00:32:21,679 --> 00:32:28,970
heuristic and I'm gonna go experiment

00:32:23,779 --> 00:32:30,769
that probably first it would be nice if

00:32:28,970 --> 00:32:32,599
the application would tell me that it

00:32:30,769 --> 00:32:34,249
was going to do a present this this

00:32:32,599 --> 00:32:35,960
frame or not so be nice to the

00:32:34,249 --> 00:32:37,999
application can say yeah I'm running at

00:32:35,960 --> 00:32:39,739
30 Hertz right now so if you get stuff

00:32:37,999 --> 00:32:41,090
from other applications for the

00:32:39,739 --> 00:32:43,190
intervening frames go ahead and do a

00:32:41,090 --> 00:32:46,789
display if you like maybe it doesn't

00:32:43,190 --> 00:32:48,979
matter and of course is the if the

00:32:46,789 --> 00:32:51,019
application never presents a frame what

00:32:48,979 --> 00:32:53,149
do i do then well I'm gonna have to fall

00:32:51,019 --> 00:32:54,940
back on some other heuristics so that

00:32:53,149 --> 00:32:57,229
may that may make that more complicated

00:32:54,940 --> 00:32:58,970
okay the final section that I wanted to

00:32:57,229 --> 00:33:01,609
talk about today was the the Linux

00:32:58,970 --> 00:33:03,169
kernel api's this is plumbers so we try

00:33:01,609 --> 00:33:04,940
to talk about all parts of the system

00:33:03,169 --> 00:33:08,720
the Linux kernel is a part of my

00:33:04,940 --> 00:33:11,149
environment the Linux kernel has a an

00:33:08,720 --> 00:33:14,720
API for flipping frame buffers that

00:33:11,149 --> 00:33:16,789
dates from the late 90s from an era when

00:33:14,720 --> 00:33:19,970
the kernel was was desperately concerned

00:33:16,789 --> 00:33:22,220
about allocations there's a finite

00:33:19,970 --> 00:33:25,399
number of events you can queue in the

00:33:22,220 --> 00:33:28,429
kernel and this is very strangely

00:33:25,399 --> 00:33:30,740
strangely managed it actually counts the

00:33:28,429 --> 00:33:33,320
amount of space allocated for

00:33:30,740 --> 00:33:36,679
each it each K Malik call literally

00:33:33,320 --> 00:33:39,200
calls KZ Alok to allocate an allocated

00:33:36,679 --> 00:33:40,670
event to deliver and then it says oh if

00:33:39,200 --> 00:33:43,340
we've allocated a lot of those we're

00:33:40,670 --> 00:33:46,490
just gonna say no which means the

00:33:43,340 --> 00:33:47,480
application has to say oh I got a busy

00:33:46,490 --> 00:33:49,370
back from the colonel

00:33:47,480 --> 00:33:51,470
that means I've allocated too many

00:33:49,370 --> 00:33:52,970
events let me go read some events so

00:33:51,470 --> 00:33:54,710
here I am in the middle of my rendering

00:33:52,970 --> 00:33:56,450
processing trying to get ready to

00:33:54,710 --> 00:33:59,870
present a new frame well I gotta go stop

00:33:56,450 --> 00:34:02,660
wait hold on and go process events about

00:33:59,870 --> 00:34:04,760
V blanks that occurred a while ago it's

00:34:02,660 --> 00:34:05,780
really ugly and there's no reason for

00:34:04,760 --> 00:34:07,460
that to be in the kernel

00:34:05,780 --> 00:34:11,050
I can literally delete code from the

00:34:07,460 --> 00:34:13,850
kernel and fix this application problem

00:34:11,050 --> 00:34:16,310
and so every application that uses that

00:34:13,850 --> 00:34:17,929
API has this grotty a little Cluj oh I

00:34:16,310 --> 00:34:21,639
got a busy back let me go read some

00:34:17,929 --> 00:34:25,250
events and let me retry which is ugly

00:34:21,639 --> 00:34:28,429
the times provided from the kernel are

00:34:25,250 --> 00:34:30,100
only in microsecond granularity the

00:34:28,429 --> 00:34:32,240
kernel has a nanosecond clock

00:34:30,100 --> 00:34:33,830
Volken likes the nanosecond clock

00:34:32,240 --> 00:34:36,200
everybody likes nanoseconds these days

00:34:33,830 --> 00:34:38,300
I'm sure in ten years away picoseconds

00:34:36,200 --> 00:34:39,980
but there's no reason not to provide

00:34:38,300 --> 00:34:41,540
nanoseconds back to user space I've

00:34:39,980 --> 00:34:43,970
already fixed one of the api's in the

00:34:41,540 --> 00:34:45,409
kernel to provide nanoseconds I think we

00:34:43,970 --> 00:34:48,830
should fix the flip API to provide

00:34:45,409 --> 00:34:50,750
nanoseconds as well the other another

00:34:48,830 --> 00:34:53,600
problem with the Linux flip API is

00:34:50,750 --> 00:34:56,540
there's only a single spot a single

00:34:53,600 --> 00:34:58,310
queue entry in the kernel thanks when

00:34:56,540 --> 00:34:59,869
you provide a flip to the kernel you're

00:34:58,310 --> 00:35:03,290
gonna say ok kernel go ahead and flip

00:34:59,869 --> 00:35:05,270
and you-you-you-you hue an entry for

00:35:03,290 --> 00:35:06,980
that particular screen and you can't

00:35:05,270 --> 00:35:09,050
change what's queued you can't add

00:35:06,980 --> 00:35:11,210
additional things to the queue you are

00:35:09,050 --> 00:35:13,250
stuck you are committed to displaying

00:35:11,210 --> 00:35:14,960
that frame of that feed life which means

00:35:13,250 --> 00:35:18,170
that you want to commit as late as

00:35:14,960 --> 00:35:19,130
possible but then you're terrified that

00:35:18,170 --> 00:35:20,980
you're gonna miss fee blank because

00:35:19,130 --> 00:35:23,000
you're gonna get you're gonna get some

00:35:20,980 --> 00:35:24,950
interrupt latency in the system and

00:35:23,000 --> 00:35:26,480
you're not gonna get it there in time so

00:35:24,950 --> 00:35:28,580
you really want to ideally what you'll

00:35:26,480 --> 00:35:30,770
be able to do is say I think I want to

00:35:28,580 --> 00:35:32,210
display this frame and then at the

00:35:30,770 --> 00:35:33,980
future be able to come back and say yeah

00:35:32,210 --> 00:35:37,420
I don't really want to display that

00:35:33,980 --> 00:35:37,420
frame can you display this frame instead

00:35:37,840 --> 00:35:43,280
and or I or you'd be able to say uncute

00:35:42,140 --> 00:35:43,670
it's like oh I don't really want to

00:35:43,280 --> 00:35:45,170
display

00:35:43,670 --> 00:35:48,589
frame I want to get rid of that from the

00:35:45,170 --> 00:35:50,599
cue and and and go on with other things

00:35:48,589 --> 00:35:52,940
which is really important if you have

00:35:50,599 --> 00:35:55,579
more if you change that single cue spot

00:35:52,940 --> 00:35:57,589
to multiple cue spots another problem is

00:35:55,579 --> 00:35:59,180
that it blocks for rendering so here I

00:35:57,589 --> 00:36:01,760
am in my display process which is

00:35:59,180 --> 00:36:04,430
supposed to be nicely asynchronous but

00:36:01,760 --> 00:36:06,710
I've got my I got you know I've got this

00:36:04,430 --> 00:36:08,270
entire command queue of rendering

00:36:06,710 --> 00:36:09,950
commands and all the compositor

00:36:08,270 --> 00:36:12,770
rendering commands sitting there and I

00:36:09,950 --> 00:36:15,829
know when I flip to that and before when

00:36:12,770 --> 00:36:18,170
I asked to queue for display there

00:36:15,829 --> 00:36:20,119
kernels synchronously waits for all of

00:36:18,170 --> 00:36:21,710
that rendering to complete before it

00:36:20,119 --> 00:36:23,119
will return from the queue and that

00:36:21,710 --> 00:36:27,190
means that my window system stalls

00:36:23,119 --> 00:36:29,900
waiting for rendering which is terrible

00:36:27,190 --> 00:36:31,040
which the combination of all these

00:36:29,900 --> 00:36:33,589
effects is that it means that I really

00:36:31,040 --> 00:36:36,170
can't effectively support what the

00:36:33,589 --> 00:36:38,780
Vulcan system knows of as mailbox mode

00:36:36,170 --> 00:36:41,359
and mailbox mode is please let me keep

00:36:38,780 --> 00:36:43,450
rendering frames and display the last

00:36:41,359 --> 00:36:46,430
one that completed before V blank

00:36:43,450 --> 00:36:48,770
because I as soon as I commit to

00:36:46,430 --> 00:36:50,660
displaying a frame I can't queue new

00:36:48,770 --> 00:36:52,670
frames which means that I want to wait

00:36:50,660 --> 00:36:54,650
really long but I don't know which frame

00:36:52,670 --> 00:36:57,349
has completed before V blank because the

00:36:54,650 --> 00:37:00,859
the the queue API synchronously waits

00:36:57,349 --> 00:37:02,869
for the rendering it's just a mess okay

00:37:00,859 --> 00:37:05,329
so I want to queue without blocking this

00:37:02,869 --> 00:37:08,450
seems really stupidly simple it's like

00:37:05,329 --> 00:37:10,640
yeah sure the hardware is gonna wait for

00:37:08,450 --> 00:37:12,890
for the rendering to be done let the

00:37:10,640 --> 00:37:16,369
kernel deal with that and don't make my

00:37:12,890 --> 00:37:19,760
application block the alternative of

00:37:16,369 --> 00:37:22,040
course is to have user space take take

00:37:19,760 --> 00:37:24,319
an event sometime before V blank and

00:37:22,040 --> 00:37:26,510
queue then it's like okay a millisecond

00:37:24,319 --> 00:37:29,809
will for a V blank user space is gonna

00:37:26,510 --> 00:37:31,309
figure out which which buffer which of

00:37:29,809 --> 00:37:33,980
the many buffers that may want to

00:37:31,309 --> 00:37:35,750
display at this V blank is ready and

00:37:33,980 --> 00:37:37,790
display the latest one and I could do

00:37:35,750 --> 00:37:39,410
all that computation in a user space but

00:37:37,790 --> 00:37:42,260
that means that now I have to burn a

00:37:39,410 --> 00:37:44,480
bunch of GPU rendering time in user

00:37:42,260 --> 00:37:46,609
space because I have to make sure that I

00:37:44,480 --> 00:37:48,500
get that command to the kernel before V

00:37:46,609 --> 00:37:50,720
black happens and I don't want to do

00:37:48,500 --> 00:37:52,430
that I want to be able to queue multiple

00:37:50,720 --> 00:37:54,319
flips in the kernel again we want to

00:37:52,430 --> 00:37:57,230
wait for that Regnery to be rendering to

00:37:54,319 --> 00:37:59,480
be complete and display the latest

00:37:57,230 --> 00:38:01,970
pleaded buffer but that means that I

00:37:59,480 --> 00:38:04,250
want to just have all of the all of the

00:38:01,970 --> 00:38:06,200
possible frames queued down into the

00:38:04,250 --> 00:38:08,300
kernel and for the when the colonel

00:38:06,200 --> 00:38:09,680
wants to ask is you know is committed to

00:38:08,300 --> 00:38:11,900
going and picking something for the next

00:38:09,680 --> 00:38:14,359
frame so right at V blank or you know a

00:38:11,900 --> 00:38:16,010
few microseconds before V blank when it

00:38:14,359 --> 00:38:18,320
needs to commit to which frame proper to

00:38:16,010 --> 00:38:20,119
display it should go walk the queue and

00:38:18,320 --> 00:38:22,100
pull off the latest one which is

00:38:20,119 --> 00:38:23,869
completed it can go ask the GPU which of

00:38:22,100 --> 00:38:25,780
these are completed and pick the latest

00:38:23,869 --> 00:38:28,130
one and get that into the frame buffer

00:38:25,780 --> 00:38:30,650
and it would be nice if I could actually

00:38:28,130 --> 00:38:31,520
queue for multiple frames ahead so if

00:38:30,650 --> 00:38:33,859
I'm playing a movie

00:38:31,520 --> 00:38:35,390
I would love to render ten frames queues

00:38:33,859 --> 00:38:37,010
of the kernel and how the application go

00:38:35,390 --> 00:38:39,140
to sleep all right so I've done all the

00:38:37,010 --> 00:38:40,460
complicated rendering operations from

00:38:39,140 --> 00:38:41,900
getting a movie displayed all the

00:38:40,460 --> 00:38:43,820
buffers are sitting there in memory and

00:38:41,900 --> 00:38:45,920
all I want to have happen is that V

00:38:43,820 --> 00:38:48,109
blank for it to go pick the next one and

00:38:45,920 --> 00:38:49,609
now I can get my GPU to go idle for

00:38:48,109 --> 00:38:52,130
longer periods of time which would save

00:38:49,609 --> 00:38:54,980
a bunch of power so that would be nice

00:38:52,130 --> 00:38:56,840
I would love to be able to cancel queued

00:38:54,980 --> 00:38:58,670
entries if I'm gonna cube 30 frames

00:38:56,840 --> 00:39:00,260
ahead I would really like to be able to

00:38:58,670 --> 00:39:02,300
hit escape and my movie player and have

00:39:00,260 --> 00:39:02,930
the movie stopped instead of stopped in

00:39:02,300 --> 00:39:05,180
a second

00:39:02,930 --> 00:39:06,590
that will be nice and it's really

00:39:05,180 --> 00:39:08,960
necessary if I don't have multiple

00:39:06,590 --> 00:39:10,580
queues cuz I need to be able to cancel

00:39:08,960 --> 00:39:15,109
what's going on and replace it with a

00:39:10,580 --> 00:39:16,910
future entry okay so in summary what I

00:39:15,109 --> 00:39:19,430
what I'm working on right now and what

00:39:16,910 --> 00:39:22,400
I've nearly finished is extending Vulcan

00:39:19,430 --> 00:39:24,380
to expose existing X capabilities and

00:39:22,400 --> 00:39:27,680
existing Linux kernel capabilities so in

00:39:24,380 --> 00:39:30,740
both X and Wayland and direct to display

00:39:27,680 --> 00:39:32,090
we have all this all this new Vulcan API

00:39:30,740 --> 00:39:34,340
available and it works

00:39:32,090 --> 00:39:36,440
I want to go fix I'm working right now

00:39:34,340 --> 00:39:37,790
on fixing timing under composited X I

00:39:36,440 --> 00:39:40,100
had that hack seemed to work pretty well

00:39:37,790 --> 00:39:42,380
I want to go make it more principled and

00:39:40,100 --> 00:39:44,119
I want to replace the Linux lip API so

00:39:42,380 --> 00:39:46,910
that I have all the all the capabilities

00:39:44,119 --> 00:39:48,440
that I talked about okay thanks that's

00:39:46,910 --> 00:39:50,300
the end of my presentation if I have

00:39:48,440 --> 00:39:56,050
questions please stand up

00:39:50,300 --> 00:39:56,050
I think Paul has a microphone he does

00:39:56,859 --> 00:40:01,210
nobody's awake yet Oh over here

00:40:03,550 --> 00:40:07,750
you're supposed to be able to throw that

00:40:04,900 --> 00:40:13,060
thing so in X there are a lot more

00:40:07,750 --> 00:40:16,780
drawing commands than just present like

00:40:13,060 --> 00:40:20,220
extra window and stuff like that or is

00:40:16,780 --> 00:40:22,660
it that one only that one command that

00:40:20,220 --> 00:40:25,330
there's a couple of answers to that the

00:40:22,660 --> 00:40:26,860
first answer is that 3d applications

00:40:25,330 --> 00:40:28,720
don't use any of the core rendering and

00:40:26,860 --> 00:40:30,400
so they don't matter the only X

00:40:28,720 --> 00:40:32,770
rendering command that they do use is

00:40:30,400 --> 00:40:34,810
this present pixmap command the other

00:40:32,770 --> 00:40:36,940
thing is is that applications that are

00:40:34,810 --> 00:40:39,250
double buffered so gtk applications or

00:40:36,940 --> 00:40:41,320
QT applications do although their

00:40:39,250 --> 00:40:44,290
rendering with those X commits screen

00:40:41,320 --> 00:40:46,750
and then take that off screen buffer and

00:40:44,290 --> 00:40:49,240
present it using that present pixmap so

00:40:46,750 --> 00:40:50,800
that present pixmap should ideally be

00:40:49,240 --> 00:40:53,500
the only place where applications

00:40:50,800 --> 00:40:55,120
interact with the display engine that's

00:40:53,500 --> 00:40:56,710
not true because there are legacy

00:40:55,120 --> 00:40:58,180
applications that use the core drawing

00:40:56,710 --> 00:40:59,560
stuff and they're just gonna look

00:40:58,180 --> 00:41:11,830
terrible no matter what so we don't care

00:40:59,560 --> 00:41:13,030
about them yep under X so there is X

00:41:11,830 --> 00:41:14,680
there's a there's an external

00:41:13,030 --> 00:41:17,200
compositing mechanism called the

00:41:14,680 --> 00:41:19,060
compositing manager oftentimes that is

00:41:17,200 --> 00:41:20,620
integrated with the window manager but

00:41:19,060 --> 00:41:22,720
there there are technically separate

00:41:20,620 --> 00:41:24,280
systems but they're often integrated

00:41:22,720 --> 00:41:26,530
into a single process because that makes

00:41:24,280 --> 00:41:29,920
it easier but that compositing manager

00:41:26,530 --> 00:41:31,660
is outside of X and it often uses GL or

00:41:29,920 --> 00:41:34,930
Vulcan to do the rendering of the scene

00:41:31,660 --> 00:41:38,260
and so it gets told about changes in the

00:41:34,930 --> 00:41:40,000
application contents constructs a total

00:41:38,260 --> 00:41:42,460
scene of the system and then calls

00:41:40,000 --> 00:41:44,680
present pixmap because again that's the

00:41:42,460 --> 00:41:49,140
only interesting X rendering operation

00:41:44,680 --> 00:41:49,140
any more question back here

00:41:53,490 --> 00:41:58,180
yeah I got some water what is the

00:41:56,200 --> 00:42:00,580
number-one thing you wish the GPU would

00:41:58,180 --> 00:42:04,360
do to help you out number one thing that

00:42:00,580 --> 00:42:06,100
GPU could do to help me out that so

00:42:04,360 --> 00:42:08,460
there's there's two systems here's there

00:42:06,100 --> 00:42:12,160
there's the GPU and the display engine

00:42:08,460 --> 00:42:14,140
the GPU could provide more accurate

00:42:12,160 --> 00:42:15,970
signaling about when it's completed

00:42:14,140 --> 00:42:18,340
without requiring a bunch of complicated

00:42:15,970 --> 00:42:20,020
synchronization also I'd like to know

00:42:18,340 --> 00:42:23,200
when the GPU is done with operations

00:42:20,020 --> 00:42:25,480
we're getting better at that the other

00:42:23,200 --> 00:42:28,390
thing the GPU would be really good to do

00:42:25,480 --> 00:42:31,660
and it does some systems do do is a GPU

00:42:28,390 --> 00:42:33,850
could allow me to to run the compositing

00:42:31,660 --> 00:42:35,620
system at a higher priority than the

00:42:33,850 --> 00:42:37,660
application rendering so that I could

00:42:35,620 --> 00:42:40,120
know that the compositing operations and

00:42:37,660 --> 00:42:41,320
the application rendering the

00:42:40,120 --> 00:42:44,620
compositing operation would take

00:42:41,320 --> 00:42:46,570
priority and some some GPUs do this so

00:42:44,620 --> 00:42:49,240
allow multiple threads effectively and

00:42:46,570 --> 00:42:51,220
allow me to get some priority for the

00:42:49,240 --> 00:42:53,530
compositing system those who those would

00:42:51,220 --> 00:43:00,940
help with the with the with the problems

00:42:53,530 --> 00:43:02,680
that we have today we are and you have

00:43:00,940 --> 00:43:04,960
to deal with the time domain of your

00:43:02,680 --> 00:43:06,280
input on one side and off of your output

00:43:04,960 --> 00:43:08,740
on the other one and keep them in sync

00:43:06,280 --> 00:43:10,960
how do you generally deal with the fact

00:43:08,740 --> 00:43:14,200
that your clock source are going to

00:43:10,960 --> 00:43:16,450
drift in your CPU clock in the GPU clock

00:43:14,200 --> 00:43:18,580
and don't come from the same crystal is

00:43:16,450 --> 00:43:20,230
it gonna drift right wait and so I told

00:43:18,580 --> 00:43:22,090
you about that extent volcán extension

00:43:20,230 --> 00:43:23,890
we created to get you a GPU in a CPU

00:43:22,090 --> 00:43:25,960
time that are closely correlated you

00:43:23,890 --> 00:43:27,880
just call that every frame and now you

00:43:25,960 --> 00:43:30,310
now you if the clocks drift slowly

00:43:27,880 --> 00:43:31,810
you'll resynchronize it every frame and

00:43:30,310 --> 00:43:33,580
so you're always within you know you're

00:43:31,810 --> 00:43:36,130
talking about clocks that are a few ppm

00:43:33,580 --> 00:43:37,780
at the worst and so you're not gonna be

00:43:36,130 --> 00:43:39,250
off by very much over the time of a

00:43:37,780 --> 00:43:40,210
frame yeah but you don't just want to

00:43:39,250 --> 00:43:42,430
get it at the start of the application

00:43:40,210 --> 00:43:44,440
and use it as a constant you need to

00:43:42,430 --> 00:43:49,060
constantly refresh those those

00:43:44,440 --> 00:43:52,060
synchronize times no questions just a

00:43:49,060 --> 00:43:56,080
clarification I think the kernel API for

00:43:52,060 --> 00:43:58,210
atomic only stalls for the go bid for

00:43:56,080 --> 00:43:59,620
the way for the Gobi so basically

00:43:58,210 --> 00:44:00,600
programmed registers on the display

00:43:59,620 --> 00:44:03,540
engine too

00:44:00,600 --> 00:44:06,120
the next frame and his tolls for the go

00:44:03,540 --> 00:44:07,620
beat so but basically I was looking at

00:44:06,120 --> 00:44:09,600
the code last night and it sure looks

00:44:07,620 --> 00:44:11,670
like it stalls for the frame waiting for

00:44:09,600 --> 00:44:13,440
the render to complete most of the time

00:44:11,670 --> 00:44:14,700
maybe not always I'm talking about

00:44:13,440 --> 00:44:16,920
well-written drivers I don't know which

00:44:14,700 --> 00:44:19,320
one to look at but it's supposed to only

00:44:16,920 --> 00:44:20,850
wait for the go bid basically you're

00:44:19,320 --> 00:44:23,430
programmed the registers and only when

00:44:20,850 --> 00:44:26,190
the when you sure that the frame can go

00:44:23,430 --> 00:44:31,160
through you set go and then you wait for

00:44:26,190 --> 00:44:31,160
the blank to basically thanks

00:44:38,380 --> 00:44:41,679
[Music]

00:44:51,530 --> 00:44:55,770
fortunately the CPU side is very low

00:44:53,820 --> 00:44:58,410
overhead for certainly for compositing

00:44:55,770 --> 00:45:00,900
there's a bunch of context switching

00:44:58,410 --> 00:45:03,030
required but not a lot of actual CPU

00:45:00,900 --> 00:45:05,100
time I mean because you have so many

00:45:03,030 --> 00:45:07,830
cores these days we really aren't seeing

00:45:05,100 --> 00:45:10,020
starvation on the CPU side the lack of

00:45:07,830 --> 00:45:11,670
the lack of fine-grained scheduling on

00:45:10,020 --> 00:45:14,370
the GPU is a much more significant

00:45:11,670 --> 00:45:15,990
concern obviously on the CPU side what

00:45:14,370 --> 00:45:18,900
we often do is run the compositor a

00:45:15,990 --> 00:45:20,310
higher priority so possibly a real-time

00:45:18,900 --> 00:45:22,110
priority in order to make sure that it

00:45:20,310 --> 00:45:25,050
gets CPU time when it needs it so that's

00:45:22,110 --> 00:45:26,460
you know we the operating system is that

00:45:25,050 --> 00:45:28,590
you know it provides pretty good

00:45:26,460 --> 00:45:29,880
real-time support these days and so we

00:45:28,590 --> 00:45:32,310
really haven't seen a lot of problem

00:45:29,880 --> 00:45:34,320
there but yeah obviously a concern it

00:45:32,310 --> 00:45:35,640
used to be a big deal but processors are

00:45:34,320 --> 00:45:37,380
fast enough and the overhead is low

00:45:35,640 --> 00:45:39,780
enough and we do have some real-time

00:45:37,380 --> 00:45:41,960
scheduling capability thank you very

00:45:39,780 --> 00:45:41,960
much

00:45:43,710 --> 00:45:45,770

YouTube URL: https://www.youtube.com/watch?v=CP3PfOhE28s


