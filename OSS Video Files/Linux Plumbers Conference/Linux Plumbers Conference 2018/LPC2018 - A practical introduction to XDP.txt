Title: LPC2018 - A practical introduction to XDP
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/71/
speaker:  Jesper Dangaard Brouer (Red Hat), Andy Gospodarek (Broadcom)


The eXpress Data Path (XDP) has been gradually integrated into the Linux kernel over several releases. XDP offers fast and programmable packet processing in kernel context. The operating system kernel itself provides a safe execution environment for custom packet processing applications, in form of eBPF programs, executed in device driver context. XDP provides a fully integrated solution working in concert with the kernel's networking stack. Applications are written in higher level languages such as C and compiled via LLVM into eBPF bytecode which the kernel statically analyses for safety, and JIT translates into native instructions. This is an alternative approach, compared to kernel bypass mechanisms (like DPDK and netmap).

This talk gives a practical focused introduction to XDP. Describing and giving code examples for the programming environment provided to the XDP developer. The programmer need to change their mindeset a bit, when coding for this XDP/eBPF execution environment. XDP programs are often split between eBPF-code running kernel side and userspace control plane. The control plane API not predefined, and is up to the programmer, through userspace manipulating shared eBPF maps.
Captions: 
	00:00:05,550 --> 00:00:10,920
you wonder well yes when I realized

00:00:09,480 --> 00:00:13,860
we've spent the last two days and the

00:00:10,920 --> 00:00:15,300
networking micro conference which really

00:00:13,860 --> 00:00:16,529
was a lot about XDP so we decided the

00:00:15,300 --> 00:00:18,869
last minute we would just do this

00:00:16,529 --> 00:00:21,240
practical introduction yeah we heard

00:00:18,869 --> 00:00:22,650
this thing like XTP is really cool so we

00:00:21,240 --> 00:00:24,570
like we found this stuff on the internet

00:00:22,650 --> 00:00:33,180
and we download it and play a little bit

00:00:24,570 --> 00:00:36,690
let's see yeah been a busy 24 hours yeah

00:00:33,180 --> 00:00:40,620
I'm yes / yeah and I dunno what XTP is

00:00:36,690 --> 00:00:43,109
so I sort of invented all right so yeah

00:00:40,620 --> 00:00:44,550
yeah so so we really want you to get

00:00:43,109 --> 00:00:46,320
something out of this or sort of our

00:00:44,550 --> 00:00:48,539
tutorials if you want we want you to

00:00:46,320 --> 00:00:49,800
learn something you want you to when you

00:00:48,539 --> 00:00:52,469
go out of here actually know what this

00:00:49,800 --> 00:00:54,359
XTP stuff is and also to explain how it

00:00:52,469 --> 00:00:56,489
works the relationship with with B pair

00:00:54,359 --> 00:00:59,309
for you I will teach you all about the

00:00:56,489 --> 00:01:00,809
fundamental elements you can use and we

00:00:59,309 --> 00:01:02,609
will show you a real program code I used

00:01:00,809 --> 00:01:04,230
to the people from going away from this

00:01:02,609 --> 00:01:07,140
talk tables write code for

00:01:04,230 --> 00:01:08,730
xtp and understand this stuff you're

00:01:07,140 --> 00:01:11,310
also going to touch some of the advanced

00:01:08,730 --> 00:01:13,110
concepts and at last we're gonna just

00:01:11,310 --> 00:01:14,970
talk about also the like photo driver

00:01:13,110 --> 00:01:16,470
developers because we need this to be

00:01:14,970 --> 00:01:18,240
adapted in more drivers so we actually

00:01:16,470 --> 00:01:21,720
have some slides of how to actually code

00:01:18,240 --> 00:01:25,200
this up in your driver and yeah let's

00:01:21,720 --> 00:01:26,970
see how much you'll learn all right so

00:01:25,200 --> 00:01:31,320
first of all we'll start off what is xtp

00:01:26,970 --> 00:01:32,730
so it's really just a maybe new not

00:01:31,320 --> 00:01:34,440
anymore but it's still new to a lot of

00:01:32,730 --> 00:01:35,730
folks and that's okay it's a new

00:01:34,440 --> 00:01:38,600
programmable layer and the kernel

00:01:35,730 --> 00:01:41,040
network stack its runtime programmable

00:01:38,600 --> 00:01:43,680
really is targeted at BPF is packet

00:01:41,040 --> 00:01:46,740
processing so the important key to

00:01:43,680 --> 00:01:49,500
remember is that last orange there is

00:01:46,740 --> 00:01:50,880
not kernel bypass so yes you get to do

00:01:49,500 --> 00:01:52,680
it before the kernel stack does things

00:01:50,880 --> 00:01:54,840
but it is not kernel bypass you're in

00:01:52,680 --> 00:01:56,280
line with the kernel all of the many fun

00:01:54,840 --> 00:02:00,030
features available in Linux kernel are

00:01:56,280 --> 00:02:01,560
are available to you and in programs

00:02:00,030 --> 00:02:05,040
it's a little bit unique to compile to a

00:02:01,560 --> 00:02:06,450
platform and dependent epbb PF which by

00:02:05,040 --> 00:02:08,879
the way we're just gonna say BPF the

00:02:06,450 --> 00:02:11,790
whole time because ii BPF is just about

00:02:08,879 --> 00:02:14,580
impossible to pronounce mouthful yeah in

00:02:11,790 --> 00:02:15,900
any reasonable amount of time so don't

00:02:14,580 --> 00:02:18,180
be alarmed if we leave the e off for

00:02:15,900 --> 00:02:19,160
most of this time but yeah come on into

00:02:18,180 --> 00:02:19,880
a bytecode one of the really

00:02:19,160 --> 00:02:21,380
cool things about a being

00:02:19,880 --> 00:02:22,730
platform-independent is as you might

00:02:21,380 --> 00:02:29,210
imagine you can actually run the same

00:02:22,730 --> 00:02:32,240
compiled BPF binaries on arm on x86 they

00:02:29,210 --> 00:02:33,560
all work pretty cool and and that's

00:02:32,240 --> 00:02:36,080
that's one of the real powers if you

00:02:33,560 --> 00:02:38,060
want to deploy it fast or deploy at

00:02:36,080 --> 00:02:39,950
multiple places you can I know there's a

00:02:38,060 --> 00:02:42,140
discussion earlier today about the fact

00:02:39,950 --> 00:02:43,700
that there are some some caveats for

00:02:42,140 --> 00:02:46,250
compiling some of your user space code

00:02:43,700 --> 00:02:48,470
that loads this it's dependent on the

00:02:46,250 --> 00:02:50,000
kernel version you're running Alexei and

00:02:48,470 --> 00:02:51,800
others at Facebook are looking at that

00:02:50,000 --> 00:02:53,420
working around that so you can have one

00:02:51,800 --> 00:02:54,740
binary that maybe you could run on

00:02:53,420 --> 00:03:00,020
multiple versions across your fleet

00:02:54,740 --> 00:03:02,360
without much trouble so also we've got

00:03:00,020 --> 00:03:03,440
kind of the key design goals yes what

00:03:02,360 --> 00:03:06,860
you want to say something go ahead yes

00:03:03,440 --> 00:03:09,050
so so so to solve the design when I

00:03:06,860 --> 00:03:11,270
started this project was we need to

00:03:09,050 --> 00:03:13,370
close the performance gap to the to the

00:03:11,270 --> 00:03:17,090
kernel bypass solutions that has been

00:03:13,370 --> 00:03:19,940
sort of my motivation to to compete with

00:03:17,090 --> 00:03:22,100
DB DK because I was not thinking I was

00:03:19,940 --> 00:03:27,110
thinking that they we are comparing

00:03:22,100 --> 00:03:28,340
apples and oranges how you say it like

00:03:27,110 --> 00:03:32,870
that's correct

00:03:28,340 --> 00:03:34,970
yeah right yeah so so I was really

00:03:32,870 --> 00:03:36,620
thinking it was unfair these performance

00:03:34,970 --> 00:03:39,410
comparison against the Linux Network

00:03:36,620 --> 00:03:41,540
stack and DB DK so but now we're

00:03:39,410 --> 00:03:43,340
operating at the same level as STP DK

00:03:41,540 --> 00:03:45,110
and now we can actually compare HTTP

00:03:43,340 --> 00:03:48,410
against the BTK was the performance gap

00:03:45,110 --> 00:03:50,600
and my real motivation is closing the

00:03:48,410 --> 00:03:53,120
gap is actually not to be faster than

00:03:50,600 --> 00:03:56,180
that the the kernel bypass stuff I'm

00:03:53,120 --> 00:03:59,180
fine with like if I'm have a 10% gap or

00:03:56,180 --> 00:04:01,070
something then as as long as I have a

00:03:59,180 --> 00:04:03,790
more generic solution to this problem

00:04:01,070 --> 00:04:06,320
instead of bypassing the whole kernel

00:04:03,790 --> 00:04:09,380
unlike DB decay we operate on at least

00:04:06,320 --> 00:04:11,900
directly under packet buffers there was

00:04:09,380 --> 00:04:13,820
sort of my original name for XP person

00:04:11,900 --> 00:04:16,010
Tom Herbert they came up with a much

00:04:13,820 --> 00:04:17,900
better name for an HTTP type of packet

00:04:16,010 --> 00:04:19,940
buffers remember Tom claims to that X is

00:04:17,900 --> 00:04:26,030
the fastest letter and that was why he

00:04:19,940 --> 00:04:27,710
liked X - yeah yeah so yeah so we

00:04:26,030 --> 00:04:30,260
operate on the packet before converting

00:04:27,710 --> 00:04:32,010
it to the to the mutation start to call

00:04:30,260 --> 00:04:34,710
the sk p and

00:04:32,010 --> 00:04:37,260
and this is one of the points why quite

00:04:34,710 --> 00:04:39,240
a network stack its conceived to be slow

00:04:37,260 --> 00:04:41,730
it's because the networks like upfront

00:04:39,240 --> 00:04:44,550
we took the decision 20 years ago maybe

00:04:41,730 --> 00:04:46,170
25 years ago then that these this

00:04:44,550 --> 00:04:47,670
packets they should believe T be

00:04:46,170 --> 00:04:49,320
delivered into sockets that's why it's

00:04:47,670 --> 00:04:52,650
called the HK PE because it's the socket

00:04:49,320 --> 00:04:54,420
buffer and and we're sort of realized

00:04:52,650 --> 00:04:56,220
that if we want to do something fast you

00:04:54,420 --> 00:04:58,710
don't take the discus up front if you

00:04:56,220 --> 00:05:02,160
don't need it you can use xt p in this

00:04:58,710 --> 00:05:04,800
tissues cases another important design

00:05:02,160 --> 00:05:07,440
goal is that we want to be able to work

00:05:04,800 --> 00:05:11,100
in concert with the network stack so

00:05:07,440 --> 00:05:14,460
HDPE is in fact not a colonel bypass but

00:05:11,100 --> 00:05:16,980
it's a bypass of the network stack but

00:05:14,460 --> 00:05:18,540
we want to cooperate with the network

00:05:16,980 --> 00:05:21,780
stack and fall throughs and networks

00:05:18,540 --> 00:05:25,500
like when we find a packet we will not

00:05:21,780 --> 00:05:29,400
handle in ATP but we can handle perfect

00:05:25,500 --> 00:05:30,960
package posture and we'll talk about

00:05:29,400 --> 00:05:32,670
this some more too but not only can we

00:05:30,960 --> 00:05:32,970
fall fall back to the kernel stack if we

00:05:32,670 --> 00:05:35,130
need to

00:05:32,970 --> 00:05:36,690
there's work underway to take current

00:05:35,130 --> 00:05:38,760
kernel data structures that exist and

00:05:36,690 --> 00:05:40,470
allow us to inspect those and find out

00:05:38,760 --> 00:05:42,180
if we can make a forwarding decision

00:05:40,470 --> 00:05:45,360
based on already well-known data so we

00:05:42,180 --> 00:05:47,310
end up with essentially being a a new

00:05:45,360 --> 00:05:53,250
fast path if you will for the kernel

00:05:47,310 --> 00:05:55,710
yeah another important design goal is

00:05:53,250 --> 00:05:58,530
like the flexibility like with DVD K we

00:05:55,710 --> 00:06:00,240
stay still the whole whole net card and

00:05:58,530 --> 00:06:03,090
we are we are not doing that with xt p

00:06:00,240 --> 00:06:05,570
we are we are putting in a filter and we

00:06:03,090 --> 00:06:07,860
even have now received cube we can do

00:06:05,570 --> 00:06:10,470
just know what's received cure we're

00:06:07,860 --> 00:06:12,000
handling this stuff on and and do like

00:06:10,470 --> 00:06:14,310
she will copy into user space and

00:06:12,000 --> 00:06:16,500
advanced stuff but we are not taking the

00:06:14,310 --> 00:06:23,100
whole NIC that is part of the

00:06:16,500 --> 00:06:25,800
flexibility of this so yeah so there are

00:06:23,100 --> 00:06:27,300
really two ways to think about xcp to

00:06:25,800 --> 00:06:28,680
different kernel hooks the one that we

00:06:27,300 --> 00:06:32,130
really care the most about is the native

00:06:28,680 --> 00:06:33,570
mode XD p so this has a driver hook

00:06:32,130 --> 00:06:38,360
typically it happens just after the

00:06:33,570 --> 00:06:41,250
buffer is DM aid I made available as

00:06:38,360 --> 00:06:43,320
before SK buffs are allocated so you're

00:06:41,250 --> 00:06:45,249
really operating on on raw information

00:06:43,320 --> 00:06:48,549
we're not waiting for the memory Alec

00:06:45,249 --> 00:06:50,289
allocation to happen in this case this

00:06:48,549 --> 00:06:51,759
is going to give us the opportunity to

00:06:50,289 --> 00:06:54,159
have the smallest number of actual

00:06:51,759 --> 00:06:55,389
instructions executed before we start

00:06:54,159 --> 00:06:56,979
inspecting the packet that's really

00:06:55,389 --> 00:06:58,449
actually the power of the DP DK is that

00:06:56,979 --> 00:06:59,979
they're not doing anything except going

00:06:58,449 --> 00:07:02,199
is there a packet is there a packet is

00:06:59,979 --> 00:07:03,609
there a packet and when there is you do

00:07:02,199 --> 00:07:04,989
something and then move on so there's a

00:07:03,609 --> 00:07:08,379
really small number of instructions

00:07:04,989 --> 00:07:10,149
executed per packet process now one of

00:07:08,379 --> 00:07:12,429
the downsides to this hence it's listed

00:07:10,149 --> 00:07:14,199
in what should be read is it there's a

00:07:12,429 --> 00:07:15,429
there is driver modification required to

00:07:14,199 --> 00:07:16,929
use this mode so there's a limited

00:07:15,429 --> 00:07:19,929
number of drivers that currently support

00:07:16,929 --> 00:07:21,069
all the all the operations but this is

00:07:19,929 --> 00:07:22,539
the highest performance mode just

00:07:21,069 --> 00:07:24,339
remember this is the smallest number of

00:07:22,539 --> 00:07:27,459
instructions that are executed before

00:07:24,339 --> 00:07:30,189
operating on a packet the other mode

00:07:27,459 --> 00:07:32,199
which some people call it skb mode or

00:07:30,189 --> 00:07:36,489
generic XDP mode it was actually born

00:07:32,199 --> 00:07:38,739
out of conference about a year ago dave

00:07:36,489 --> 00:07:41,619
was really excited about xcp

00:07:38,739 --> 00:07:43,599
and really encouraged people to think

00:07:41,619 --> 00:07:45,039
about can we have something native and I

00:07:43,599 --> 00:07:47,859
think before the conference was over

00:07:45,039 --> 00:07:50,649
David produced a patch and sort of the

00:07:47,859 --> 00:07:54,579
point is that that which generic HDPE or

00:07:50,649 --> 00:07:55,539
x2 mode you can it works on any net

00:07:54,579 --> 00:07:58,299
device that's right

00:07:55,539 --> 00:08:00,699
so so you just available on your laptop

00:07:58,299 --> 00:08:02,619
because so two problem is that with the

00:08:00,699 --> 00:08:06,009
hardware solution you have to test it on

00:08:02,619 --> 00:08:08,649
the server that has this expensive right

00:08:06,009 --> 00:08:13,449
but which with the generic mode it's a

00:08:08,649 --> 00:08:15,429
simulated mode of HTP with with a sqb so

00:08:13,449 --> 00:08:18,299
we do tricks to make it look like this

00:08:15,429 --> 00:08:21,029
is like the HTTP mode that allows you to

00:08:18,299 --> 00:08:23,919
develop your program on your laptop

00:08:21,029 --> 00:08:27,039
really and just test it on on your neck

00:08:23,919 --> 00:08:28,539
without really having to to to load your

00:08:27,039 --> 00:08:30,669
program every time on the server and

00:08:28,539 --> 00:08:32,349
then when you're done with your program

00:08:30,669 --> 00:08:34,000
you load it on the real server that's

00:08:32,349 --> 00:08:35,979
right that's why you get one to

00:08:34,000 --> 00:08:37,449
performance the great thing is because

00:08:35,979 --> 00:08:40,360
there's such a larger number of

00:08:37,449 --> 00:08:43,659
instructions that are executed before

00:08:40,360 --> 00:08:45,639
running these programs you you get great

00:08:43,659 --> 00:08:47,410
justification for doing this native mode

00:08:45,639 --> 00:08:49,329
doing the development because you

00:08:47,410 --> 00:08:54,639
realize the performance gap is huge I

00:08:49,329 --> 00:08:56,860
mean it's really massive granted yeah so

00:08:54,639 --> 00:08:58,540
we you could you could do this but but

00:08:56,860 --> 00:09:06,250
yeah native mode is

00:08:58,540 --> 00:09:06,790
the way to go yeah so ultimately do you

00:09:06,250 --> 00:09:08,830
expect

00:09:06,790 --> 00:09:10,930
basically all Network drivers to

00:09:08,830 --> 00:09:13,540
eventually have native mode to be

00:09:10,930 --> 00:09:14,650
modified to use that yes yes that's

00:09:13,540 --> 00:09:16,480
that's what I'm hoping for

00:09:14,650 --> 00:09:18,130
okay so there's no there's no

00:09:16,480 --> 00:09:20,460
fundamental on some network drivers

00:09:18,130 --> 00:09:23,860
devices can do it in some cannot know

00:09:20,460 --> 00:09:25,210
yet this is old this is a software thing

00:09:23,860 --> 00:09:27,520
so you should be able to support an

00:09:25,210 --> 00:09:30,700
in-network driver so and are you

00:09:27,520 --> 00:09:33,490
expecting that base is going to be built

00:09:30,700 --> 00:09:35,500
into the driver API so that you're not

00:09:33,490 --> 00:09:37,540
doing have duplicating this stuff all

00:09:35,500 --> 00:09:39,550
the way through and every driver or so

00:09:37,540 --> 00:09:41,140
are you expecting framework changes well

00:09:39,550 --> 00:09:42,970
there are already I mean there are new

00:09:41,140 --> 00:09:45,310
NGO ops that already exists to handle

00:09:42,970 --> 00:09:47,650
the insertion of the program and then to

00:09:45,310 --> 00:09:49,330
handle transmit yeah I'm so I mean yeah

00:09:47,650 --> 00:09:50,890
that's there you just need to fill out I

00:09:49,330 --> 00:09:52,390
think we're going to discuss what

00:09:50,890 --> 00:09:55,420
actions you have and I think it's quite

00:09:52,390 --> 00:09:57,490
complete now and and the way it has an

00:09:55,420 --> 00:09:58,930
advanced target topic that we're going

00:09:57,490 --> 00:10:01,480
to cover right we are going to do this

00:09:58,930 --> 00:10:02,860
redirect and we have a way to extend the

00:10:01,480 --> 00:10:06,280
types of redirects we can do without

00:10:02,860 --> 00:10:07,600
having to change the drivers so we have

00:10:06,280 --> 00:10:10,090
to have a core set of actions and

00:10:07,600 --> 00:10:10,450
drivers and then we can evolve in the

00:10:10,090 --> 00:10:12,250
car

00:10:10,450 --> 00:10:13,600
I even have crazy price of actually

00:10:12,250 --> 00:10:15,610
removing there's KP allocation

00:10:13,600 --> 00:10:17,410
completely different drivers and making

00:10:15,610 --> 00:10:20,290
happening in the core so that's like I

00:10:17,410 --> 00:10:40,900
could I don't know how many roads or yes

00:10:20,290 --> 00:10:43,530
down the road it should be used us

00:10:40,900 --> 00:10:45,790
testing it is quite fast actually

00:10:43,530 --> 00:10:51,460
because we are doing it quite early

00:10:45,790 --> 00:10:53,110
before invoking the rest of the network

00:10:51,460 --> 00:10:56,170
stack so you can actually drop package

00:10:53,110 --> 00:11:00,930
quite faster but I don't want to

00:10:56,170 --> 00:11:00,930
recommend doing that another question

00:11:06,410 --> 00:11:12,650
or the only design for length standalone

00:11:08,870 --> 00:11:14,150
ultra-high-speed I'm kicking the guys

00:11:12,650 --> 00:11:24,590
from Amazon to actually implemented and

00:11:14,150 --> 00:11:28,010
then promise they will table do it in

00:11:24,590 --> 00:11:37,190
talk more into them like this yes okay I

00:11:28,010 --> 00:11:48,890
see okay so switching and it's quite

00:11:37,190 --> 00:11:59,750
useful box into so we're not covering

00:11:48,890 --> 00:12:02,300
bugs in this talk I just have to fix

00:11:59,750 --> 00:12:04,550
those box sorry any of the limitations

00:12:02,300 --> 00:12:11,090
are not intentional yeah okay yeah thank

00:12:04,550 --> 00:12:12,770
you so xt p and b PE b PF b PF they they

00:12:11,090 --> 00:12:15,140
are quite connected and sort of very

00:12:12,770 --> 00:12:19,040
interconnected so we do to depend on it

00:12:15,140 --> 00:12:23,690
and how is this disconnected so if if

00:12:19,040 --> 00:12:25,160
you see it as as h TP a-- how is you can

00:12:23,690 --> 00:12:27,500
see there's a data plane and a control

00:12:25,160 --> 00:12:30,170
plane so house if you view it in with

00:12:27,500 --> 00:12:32,420
these these goggles on how would it look

00:12:30,170 --> 00:12:35,390
so the data plane is still inside the

00:12:32,420 --> 00:12:38,270
kernel but is split into two things one

00:12:35,390 --> 00:12:41,450
is the sort of the core network part

00:12:38,270 --> 00:12:43,340
that is in charge of moving packets

00:12:41,450 --> 00:12:45,800
quickly a lot of it actually happens

00:12:43,340 --> 00:12:48,260
down on the drivers of making moving

00:12:45,800 --> 00:12:51,020
fast but it's still kernel code and then

00:12:48,260 --> 00:12:53,630
we have the attached PPF program which

00:12:51,020 --> 00:12:56,300
is the policy logic you get to decide an

00:12:53,630 --> 00:12:57,890
action or fate of the packet and you get

00:12:56,300 --> 00:13:01,910
read/write access to the packet buffers

00:12:57,890 --> 00:13:05,240
and the control plane is it's done done

00:13:01,910 --> 00:13:06,650
from user space so you obviously you

00:13:05,240 --> 00:13:08,660
have to load it from user space but you

00:13:06,650 --> 00:13:10,880
can also control the behavior of your

00:13:08,660 --> 00:13:14,240
program from user space through maps and

00:13:10,880 --> 00:13:16,430
we will get into David Erin's idea of

00:13:14,240 --> 00:13:18,740
wave let's look up in kernels a person

00:13:16,430 --> 00:13:20,209
set by help us but everything from the

00:13:18,740 --> 00:13:23,360
user space construed the system car

00:13:20,209 --> 00:13:25,790
to control this so that is the split so

00:13:23,360 --> 00:13:28,639
we'd be another bypass right we don't

00:13:25,790 --> 00:13:30,170
bypass the into the so user space and

00:13:28,639 --> 00:13:31,910
have that that's that is our control

00:13:30,170 --> 00:13:33,529
plate as our days are playing but our

00:13:31,910 --> 00:13:38,749
taste plane is in the kernel so that's

00:13:33,529 --> 00:13:44,420
that's to frame that are you thinking

00:13:38,749 --> 00:13:45,679
this so so really the way to just think

00:13:44,420 --> 00:13:47,720
about is we've talked about this before

00:13:45,679 --> 00:13:49,189
sort of shouldn't be a surprise but this

00:13:47,720 --> 00:13:51,290
driver hook is the one that's executing

00:13:49,189 --> 00:13:52,459
this the CB bf byte code so this is this

00:13:51,290 --> 00:13:54,259
is what we talked about these BPF

00:13:52,459 --> 00:13:56,629
programs there really aren't any

00:13:54,259 --> 00:14:01,309
restrictions on how its generated or

00:13:56,629 --> 00:14:02,689
loaded it attaches this BPA file

00:14:01,309 --> 00:14:03,860
descriptor and we'll kind of go through

00:14:02,689 --> 00:14:07,339
a little bit of a Code walkthrough on

00:14:03,860 --> 00:14:09,559
this too but it attaches it and creates

00:14:07,339 --> 00:14:13,309
the maps all this happens through the

00:14:09,559 --> 00:14:15,579
BPF syscall so yeah so songs of Pontus

00:14:13,309 --> 00:14:17,809
that you could do handwritten EPF

00:14:15,579 --> 00:14:19,189
instructions and put it in but it's

00:14:17,809 --> 00:14:20,990
really not practical I have seen code

00:14:19,189 --> 00:14:24,470
doing this actually system T has an

00:14:20,990 --> 00:14:26,480
array of write code instructions and

00:14:24,470 --> 00:14:27,889
pushes this in and if you've yeah if

00:14:26,480 --> 00:14:30,709
you've ever looked at for example

00:14:27,889 --> 00:14:32,839
there's a spanning tree demon that opens

00:14:30,709 --> 00:14:35,119
a raw socket and there's actually BPF

00:14:32,839 --> 00:14:38,149
byte code that's cryptically written to

00:14:35,119 --> 00:14:40,100
make sure that only BPD use come up on

00:14:38,149 --> 00:14:41,629
that raw socket so there's there's BPF

00:14:40,100 --> 00:14:42,769
byte code that's already it's been in

00:14:41,629 --> 00:14:45,170
the kernel for a while if you've used

00:14:42,769 --> 00:14:47,749
TCP dump before and filtered that's BPF

00:14:45,170 --> 00:14:49,369
byte code so this is a fairly you know

00:14:47,749 --> 00:14:52,189
well-known you know construct and

00:14:49,369 --> 00:14:54,259
virtual machine in the kernel we want to

00:14:52,189 --> 00:14:56,149
recommend using a little VM and si Lang

00:14:54,259 --> 00:14:58,369
to actually generate drive don't write

00:14:56,149 --> 00:15:00,170
it by hand I mean if you have a lot of

00:14:58,369 --> 00:15:02,089
spare time and you really want to write

00:15:00,170 --> 00:15:03,439
these byte this byte code by yourself

00:15:02,089 --> 00:15:05,569
feel free but really the best way to

00:15:03,439 --> 00:15:07,720
think use these with bcc tools and and

00:15:05,569 --> 00:15:14,209
using lib BPF to help load these things

00:15:07,720 --> 00:15:17,839
these objects created by bio vm so so

00:15:14,209 --> 00:15:19,279
we're gonna focus on on a few things

00:15:17,839 --> 00:15:20,899
that are in samples BPF in the kernel

00:15:19,279 --> 00:15:23,929
source tree we're gonna look at the

00:15:20,899 --> 00:15:26,779
restricted c code typically that makes

00:15:23,929 --> 00:15:29,120
up is compiled into the BPF byte code is

00:15:26,779 --> 00:15:31,180
in a file underscore currency that's the

00:15:29,120 --> 00:15:33,970
typical convention today

00:15:31,180 --> 00:15:36,670
it's restricted the idea is you can

00:15:33,970 --> 00:15:38,770
protect the kernel there's you know

00:15:36,670 --> 00:15:44,380
discussions about you know is BPF harm

00:15:38,770 --> 00:15:45,820
is is BPF harmful is it not fairly well

00:15:44,380 --> 00:15:48,570
assumed right now and everybody feels

00:15:45,820 --> 00:15:50,830
very confident that BPF is safe to use

00:15:48,570 --> 00:15:52,600
but to verify I could push the

00:15:50,830 --> 00:15:53,770
restrictions on that so that's why

00:15:52,600 --> 00:15:55,990
Picard was tricked at sea it's

00:15:53,770 --> 00:15:57,760
restricted in part you verify or make

00:15:55,990 --> 00:15:59,950
sure you can you cannot do loops but

00:15:57,760 --> 00:16:02,800
people are working on like basic stuff

00:15:59,950 --> 00:16:04,960
but you can't UK you can't go there's

00:16:02,800 --> 00:16:07,779
buffer overruns and under runs or

00:16:04,960 --> 00:16:08,860
overruns shouldn't be a problem but yeah

00:16:07,779 --> 00:16:10,420
we'll talk about that a little bit more

00:16:08,860 --> 00:16:11,800
and how you how you code slightly

00:16:10,420 --> 00:16:14,020
differently to deal with that the other

00:16:11,800 --> 00:16:15,880
thing is that we compile these these

00:16:14,020 --> 00:16:18,400
into elf objects and so this currency

00:16:15,880 --> 00:16:21,610
becomes current Oh surprise surprise and

00:16:18,400 --> 00:16:23,350
then we can use Lib BPF to load this is

00:16:21,610 --> 00:16:25,000
the data plane the XTP data plane that

00:16:23,350 --> 00:16:27,640
yes per is referencing a minute ago

00:16:25,000 --> 00:16:29,589
so we'll load that XTP data plane

00:16:27,640 --> 00:16:32,500
program using the user space control

00:16:29,589 --> 00:16:36,250
plane program that is conveniently named

00:16:32,500 --> 00:16:37,720
user with the underscore user dot c and

00:16:36,250 --> 00:16:40,209
this will load the load the program's

00:16:37,720 --> 00:16:43,000
make sure the maps initialized access

00:16:40,209 --> 00:16:44,410
the maps if needed so the great thing is

00:16:43,000 --> 00:16:48,339
if you have a kernel source tree

00:16:44,410 --> 00:16:50,500
available you've got these BPF samples

00:16:48,339 --> 00:16:52,839
already available I think there is an

00:16:50,500 --> 00:16:56,320
interest in packaging some of these

00:16:52,839 --> 00:16:58,180
samples for distros as individual rpms

00:16:56,320 --> 00:16:59,709
or Deb's there are other distros that

00:16:58,180 --> 00:17:01,480
have them already in them and I also

00:16:59,709 --> 00:17:03,100
have a github repository so we can build

00:17:01,480 --> 00:17:05,890
out of trees I just want to have the

00:17:03,100 --> 00:17:08,079
kernel sauce that's right and and yeah

00:17:05,890 --> 00:17:10,059
there's a lot more tooling stuff going

00:17:08,079 --> 00:17:12,130
on right alright so we'll talk about the

00:17:10,059 --> 00:17:13,959
basic building blocks that you need to

00:17:12,130 --> 00:17:17,770
to get moving

00:17:13,959 --> 00:17:20,890
so there's sort of grandmas hinting at

00:17:17,770 --> 00:17:23,350
what what kind of like actions do we

00:17:20,890 --> 00:17:28,630
actually have and do expects also if you

00:17:23,350 --> 00:17:31,390
expect more right so so yeah yeah so

00:17:28,630 --> 00:17:32,650
there are sort of highlighted halfway in

00:17:31,390 --> 00:17:37,390
yellow here you can see we have drop

00:17:32,650 --> 00:17:38,650
pass TX abort and redirect and we sort

00:17:37,390 --> 00:17:40,900
of at this point feel as though these

00:17:38,650 --> 00:17:42,910
are the complete set of operations that

00:17:40,900 --> 00:17:44,260
are needed you can handle almost any

00:17:42,910 --> 00:17:47,980
other operation we

00:17:44,260 --> 00:17:49,330
these drops pretty self-explanatory the

00:17:47,980 --> 00:17:51,600
packet has just completely dropped these

00:17:49,330 --> 00:17:56,320
make for the most amazing benchmarks

00:17:51,600 --> 00:17:58,090
yeah however that you know what what

00:17:56,320 --> 00:18:01,690
bjorn real revealed to us this week

00:17:58,090 --> 00:18:03,130
interestingly enough right is that even

00:18:01,690 --> 00:18:04,390
if you can't drop as fast as some other

00:18:03,130 --> 00:18:06,010
tool when you're actually performing

00:18:04,390 --> 00:18:07,830
real transformations on packets or doing

00:18:06,010 --> 00:18:09,850
a real inspection or doing real counting

00:18:07,830 --> 00:18:12,400
things start to level off pretty well

00:18:09,850 --> 00:18:14,350
but I actually see the X to Pedro up as

00:18:12,400 --> 00:18:16,810
a really good test of the hardware and

00:18:14,350 --> 00:18:18,730
is that this is my hardware test to make

00:18:16,810 --> 00:18:20,110
sure that like what how do I did I get

00:18:18,730 --> 00:18:22,120
to they can they actually perform at

00:18:20,110 --> 00:18:24,370
this piece and and and in fact that's

00:18:22,120 --> 00:18:26,380
exactly what I did not a week ago I had

00:18:24,370 --> 00:18:27,700
some new hardware I wanted to see can we

00:18:26,380 --> 00:18:31,660
hit the limits that we thought we could

00:18:27,700 --> 00:18:34,810
and really good evaluation - there's a

00:18:31,660 --> 00:18:36,310
high evaluation - yes right absolutely

00:18:34,810 --> 00:18:38,620
yes and people people use other tools

00:18:36,310 --> 00:18:40,690
for that as well but I of course

00:18:38,620 --> 00:18:42,430
CloudFlare I can use it for the DDoS

00:18:40,690 --> 00:18:44,530
protection and right in the production

00:18:42,430 --> 00:18:48,130
for that and so does Facebook for their

00:18:44,530 --> 00:18:49,210
protection against those curious by the

00:18:48,130 --> 00:18:50,860
way that maybe weren't in the talk

00:18:49,210 --> 00:18:54,190
earlier this week I think the number was

00:18:50,860 --> 00:18:56,500
since May 2017 every packet that's gone

00:18:54,190 --> 00:19:00,730
to facebook.com has been filtered by an

00:18:56,500 --> 00:19:03,220
xdp program yes so it's pretty pretty

00:19:00,730 --> 00:19:04,900
amazing deployment I will continue so

00:19:03,220 --> 00:19:06,820
we've got the benchmark the amazing

00:19:04,900 --> 00:19:08,800
benchmark creator xtp drop so we have

00:19:06,820 --> 00:19:10,240
xdp pass so this is where we this is one

00:19:08,800 --> 00:19:11,620
of the key things that xtp has that we

00:19:10,240 --> 00:19:13,930
don't get with other things like DP DK

00:19:11,620 --> 00:19:15,580
so packet inspection could happen you

00:19:13,930 --> 00:19:17,560
can verify it's an okay packet you can

00:19:15,580 --> 00:19:19,200
do whatever and say all right sounds

00:19:17,560 --> 00:19:22,120
great move it up to the kernel tree and

00:19:19,200 --> 00:19:25,240
that's exactly what xt p pass does so

00:19:22,120 --> 00:19:27,940
it's fairly lightweight it's lightweight

00:19:25,240 --> 00:19:29,140
as your program is but in general just

00:19:27,940 --> 00:19:30,520
lets it go back up the stack and

00:19:29,140 --> 00:19:34,680
continue to progress as needed

00:19:30,520 --> 00:19:36,610
the other one is x DP TX or transmit so

00:19:34,680 --> 00:19:38,260
this will take the packet you can

00:19:36,610 --> 00:19:39,850
possibly perform transformation on it if

00:19:38,260 --> 00:19:41,020
you want send it immediately back out

00:19:39,850 --> 00:19:43,420
the same port on which it was received

00:19:41,020 --> 00:19:46,720
this is the classic case that people

00:19:43,420 --> 00:19:48,630
have for a load balancer or maybe even

00:19:46,720 --> 00:19:50,560
you could think of it as a sort of a

00:19:48,630 --> 00:19:52,150
people used to talk about a router on a

00:19:50,560 --> 00:19:55,619
stick a long time ago that would that

00:19:52,150 --> 00:19:57,609
would certainly be the case here

00:19:55,619 --> 00:19:59,649
also another good test of what the

00:19:57,609 --> 00:20:01,089
hardware can do you spread this out

00:19:59,649 --> 00:20:02,889
amongst multiple cores and you can start

00:20:01,089 --> 00:20:04,509
to see you know how much how much can

00:20:02,889 --> 00:20:05,859
your Hardware handle but also has a lot

00:20:04,509 --> 00:20:07,479
of good applications especially in a

00:20:05,859 --> 00:20:09,249
packet transformation case it's quite

00:20:07,479 --> 00:20:12,399
good to test the PCI bandwidth limits

00:20:09,249 --> 00:20:14,049
and you can also do that too you can

00:20:12,399 --> 00:20:17,769
benchmark your NIC and your server all

00:20:14,049 --> 00:20:19,329
with one app so the other thing is XDP

00:20:17,769 --> 00:20:21,429
aborted so this is a case it's actually

00:20:19,329 --> 00:20:23,049
not very different from XDP drop there's

00:20:21,429 --> 00:20:24,789
a variety of reasons why you might in

00:20:23,049 --> 00:20:26,859
your program choose to say I don't want

00:20:24,789 --> 00:20:29,349
this packet is invalid some error

00:20:26,859 --> 00:20:30,579
happened maybe you don't have there's a

00:20:29,349 --> 00:20:32,469
variety of reasons but the biggest

00:20:30,579 --> 00:20:36,099
difference between drop and aborted is

00:20:32,469 --> 00:20:38,169
we demonstrate the ability to populate

00:20:36,099 --> 00:20:39,609
the trace buffer to say that that

00:20:38,169 --> 00:20:41,169
something happened yeah so there's the

00:20:39,609 --> 00:20:43,659
trace point you can attach to to when

00:20:41,169 --> 00:20:45,549
you want to debug your program so it's

00:20:43,659 --> 00:20:46,839
it wouldn't affect performance before we

00:20:45,549 --> 00:20:49,149
actually attached to a trace point it

00:20:46,839 --> 00:20:50,409
also zero cost that's right but you get

00:20:49,149 --> 00:20:52,299
to note something happens so there is

00:20:50,409 --> 00:20:54,369
there is the opportunity to escape from

00:20:52,299 --> 00:20:56,829
this BPF layer and provide some

00:20:54,369 --> 00:21:00,459
information to the to the developer or

00:20:56,829 --> 00:21:03,190
system administrator and the last one

00:21:00,459 --> 00:21:05,199
and the most amazing and interesting and

00:21:03,190 --> 00:21:07,239
useful one is xtp redirect so the

00:21:05,199 --> 00:21:10,179
redirect idea is that you can redirect

00:21:07,239 --> 00:21:11,349
to another port if you like you can yes

00:21:10,179 --> 00:21:12,699
where's got some tricks I'll talk about

00:21:11,349 --> 00:21:15,309
a little bit later you can redirect to

00:21:12,699 --> 00:21:16,509
other CPUs yeah to handle things so

00:21:15,309 --> 00:21:18,190
there's an opportunity to take a packet

00:21:16,509 --> 00:21:21,190
in send it somewhere else

00:21:18,190 --> 00:21:22,659
and redirect is also used for the AF xtp

00:21:21,190 --> 00:21:25,929
why we read our way into user space

00:21:22,659 --> 00:21:27,519
that's right more about that later so

00:21:25,929 --> 00:21:29,079
and what the one thing I will mention

00:21:27,519 --> 00:21:31,149
too for those people that have used DP

00:21:29,079 --> 00:21:34,029
DK are familiar with it the sort of

00:21:31,149 --> 00:21:35,289
parallel analogies TX and redirect are

00:21:34,029 --> 00:21:37,659
very similar to the actions you might

00:21:35,289 --> 00:21:44,619
get if you use DP d d BD k tools where

00:21:37,659 --> 00:21:46,569
you have the the l2 l2 TX

00:21:44,619 --> 00:21:49,059
one of the one of the DVD K tests I

00:21:46,569 --> 00:21:50,769
swear I've run it before where I think

00:21:49,059 --> 00:21:51,849
it's a test PMD which yeah if you run

00:21:50,769 --> 00:21:53,529
that if you're on test PMD and you

00:21:51,849 --> 00:21:55,029
choose the l2 forwarding to be the

00:21:53,529 --> 00:21:57,669
you're just that's the name of the test

00:21:55,029 --> 00:21:59,289
l2 forward if you had one port in there

00:21:57,669 --> 00:22:00,609
that'd be the equivalent of the XT PTX

00:21:59,289 --> 00:22:04,869
to bring the packet in and send it back

00:22:00,609 --> 00:22:07,269
out if you actually had to physical PCI

00:22:04,869 --> 00:22:08,440
functions associated with it and did the

00:22:07,269 --> 00:22:11,500
l2 forward that'd be the equal

00:22:08,440 --> 00:22:13,210
of xdp redirect operation or one of the

00:22:11,500 --> 00:22:15,850
one of the things redirect can do yeah I

00:22:13,210 --> 00:22:17,050
want to cover the next one sure it so so

00:22:15,850 --> 00:22:18,820
we were so how can you actually

00:22:17,050 --> 00:22:21,070
cooperate with the network stack so they

00:22:18,820 --> 00:22:23,530
so the the the power of being able to

00:22:21,070 --> 00:22:26,020
modify the packets quite quite quite

00:22:23,530 --> 00:22:27,730
good because we even though the HTTP

00:22:26,020 --> 00:22:30,400
path seems like oh you just want to pass

00:22:27,730 --> 00:22:32,770
it on to stack but because you can pop

00:22:30,400 --> 00:22:34,390
and push headers and modify them you

00:22:32,770 --> 00:22:36,670
actually get opportunity to actually to

00:22:34,390 --> 00:22:40,390
change and effect if the colonel doesn't

00:22:36,670 --> 00:22:42,970
know a specific on wire protocol you can

00:22:40,390 --> 00:22:43,840
you can map it remove it or map it into

00:22:42,970 --> 00:22:45,910
something they couldn't actually

00:22:43,840 --> 00:22:48,040
understand I think you had a good use

00:22:45,910 --> 00:22:49,180
case for yeah so we came across

00:22:48,040 --> 00:22:51,760
something pretty recently

00:22:49,180 --> 00:22:53,590
we're in Van network telemetry or int is

00:22:51,760 --> 00:22:56,230
becoming interesting and popular in some

00:22:53,590 --> 00:22:58,570
cases and when we first started looking

00:22:56,230 --> 00:23:00,100
at this there wasn't kernel support for

00:22:58,570 --> 00:23:03,190
it and so the opportunity presented

00:23:00,100 --> 00:23:05,080
itself where we could make sure to

00:23:03,190 --> 00:23:06,580
inspect those headers remove those

00:23:05,080 --> 00:23:08,380
headers if needed and continue to pass

00:23:06,580 --> 00:23:10,320
that packet up to stack and it gave us

00:23:08,380 --> 00:23:14,920
the opportunity to do something quickly

00:23:10,320 --> 00:23:16,000
that we couldn't do before and it didn't

00:23:14,920 --> 00:23:17,770
have to change the kernel I didn't have

00:23:16,000 --> 00:23:19,090
to change the kernel like support for

00:23:17,770 --> 00:23:21,190
the kernel you can actually just write a

00:23:19,090 --> 00:23:22,600
fix it before it the kernel it works

00:23:21,190 --> 00:23:25,090
like artists with some software and

00:23:22,600 --> 00:23:27,120
actually used in the in pencil imagery

00:23:25,090 --> 00:23:29,680
food for something right and it was

00:23:27,120 --> 00:23:32,050
quick to develop really useful for a

00:23:29,680 --> 00:23:34,000
demo it was awesome yeah so another

00:23:32,050 --> 00:23:35,380
thing how to you can communicate

00:23:34,000 --> 00:23:38,380
different stuff is like we have this

00:23:35,380 --> 00:23:39,880
this miso taste area you can when you

00:23:38,380 --> 00:23:42,250
have tail calls you gotta actually you

00:23:39,880 --> 00:23:44,350
come if you do some operation you want

00:23:42,250 --> 00:23:46,270
to store this information about you did

00:23:44,350 --> 00:23:49,180
some passing after packet or some other

00:23:46,270 --> 00:23:51,220
metadata you want in another stage you

00:23:49,180 --> 00:23:53,530
don't have to repeat the same thing so

00:23:51,220 --> 00:23:56,890
you can you have 32 bytes to communicate

00:23:53,530 --> 00:23:58,960
maybe to TC the in and you can attach

00:23:56,890 --> 00:24:00,790
another PPF hook there which can can

00:23:58,960 --> 00:24:02,860
take this information and use that for

00:24:00,790 --> 00:24:04,930
example after an exam where I am in the

00:24:02,860 --> 00:24:08,020
currently where I said there's KB mark

00:24:04,930 --> 00:24:09,910
from XTP you figure out this is a bad

00:24:08,020 --> 00:24:12,840
packet or something you mark you can

00:24:09,910 --> 00:24:17,230
actually put the meditator you the TLS

00:24:12,840 --> 00:24:19,660
that these TC hook picks this up put a

00:24:17,230 --> 00:24:21,180
mark on des KB and and then you can add

00:24:19,660 --> 00:24:24,000
a net filter that

00:24:21,180 --> 00:24:25,680
rule that matches on this mark so you

00:24:24,000 --> 00:24:27,450
can actually decide whom you communicate

00:24:25,680 --> 00:24:34,260
different stuff down just down the

00:24:27,450 --> 00:24:41,340
network stack this way quit other words

00:24:34,260 --> 00:24:43,170
I'm gonna wait for the box can we do the

00:24:41,340 --> 00:24:45,870
forward marking on the transmitted part

00:24:43,170 --> 00:24:49,440
like which gives some sort of a hint to

00:24:45,870 --> 00:24:54,330
the TC at the egress under no just a

00:24:49,440 --> 00:24:58,770
security no no egress first and I'm

00:24:54,330 --> 00:25:01,170
going to put a guide to work on it so

00:24:58,770 --> 00:25:03,720
yeah so then we also have to you can

00:25:01,170 --> 00:25:05,760
call helpers too this is because from

00:25:03,720 --> 00:25:07,140
the PPF code you cannot call random

00:25:05,760 --> 00:25:10,290
kernel functions you have to export this

00:25:07,140 --> 00:25:13,350
as a helper first and and this is

00:25:10,290 --> 00:25:15,900
actually let's touch on that real quick

00:25:13,350 --> 00:25:17,670
before we go to the next slide so I

00:25:15,900 --> 00:25:21,270
think one of the things too that using

00:25:17,670 --> 00:25:23,070
BPF gives us is that we do have we do

00:25:21,270 --> 00:25:27,180
need to spray this speed this up and

00:25:23,070 --> 00:25:28,470
okay I'm taking we'll talk about the

00:25:27,180 --> 00:25:31,110
helpers here and this we actually have

00:25:28,470 --> 00:25:33,150
helped us here yeah so so one of the

00:25:31,110 --> 00:25:35,520
ideas with the helpers what you eat what

00:25:33,150 --> 00:25:38,570
you could do and this is basically David

00:25:35,520 --> 00:25:42,210
a Hertz talk so you can go watch that

00:25:38,570 --> 00:25:43,860
but but it is so debate but the basic

00:25:42,210 --> 00:25:46,020
fundamental idea is that you should see

00:25:43,860 --> 00:25:47,960
HTTP a software flowed because you want

00:25:46,020 --> 00:25:50,730
to cooperate with the network stack and

00:25:47,960 --> 00:25:52,200
you just configured an it takes in the

00:25:50,730 --> 00:25:55,950
existing networks that I guess you want

00:25:52,200 --> 00:25:57,660
and then you you have your you have X to

00:25:55,950 --> 00:26:01,890
be to accelerate only part of it the

00:25:57,660 --> 00:26:04,590
fast path and we could fall down to two

00:26:01,890 --> 00:26:07,140
to and and call path on the packets that

00:26:04,590 --> 00:26:09,090
we cannot accelerate in the fast path so

00:26:07,140 --> 00:26:13,050
later networks like handle those and IP

00:26:09,090 --> 00:26:16,200
routing is a good example which it's as

00:26:13,050 --> 00:26:18,990
mentioned David implemented and we made

00:26:16,200 --> 00:26:22,620
a Luca function which allow us to look

00:26:18,990 --> 00:26:25,200
up in the route table and so we can

00:26:22,620 --> 00:26:27,390
actually like accelerate route logo ups

00:26:25,200 --> 00:26:30,220
but I can see we're and I'll have time

00:26:27,390 --> 00:26:32,440
so go watch the Davis talk

00:26:30,220 --> 00:26:34,509
so because what you really want to see

00:26:32,440 --> 00:26:49,929
his code right this is audience what is

00:26:34,509 --> 00:26:53,730
it so here's a pretty simple example of

00:26:49,929 --> 00:26:56,200
this restricted C code and just a simple

00:26:53,730 --> 00:27:00,039
inspect to see if it's UDP if it is drop

00:26:56,200 --> 00:27:01,480
it on the floor so one of the cool

00:27:00,039 --> 00:27:03,009
things about this that we get is we're

00:27:01,480 --> 00:27:04,539
not writing all of our application

00:27:03,009 --> 00:27:06,820
libraries from scratch again

00:27:04,539 --> 00:27:08,379
every time we do a BPF program you can

00:27:06,820 --> 00:27:10,120
see at the very top that we've got

00:27:08,379 --> 00:27:11,590
struct keith header because we're

00:27:10,120 --> 00:27:13,480
including we can include kernel header

00:27:11,590 --> 00:27:15,700
files so we have information about how

00:27:13,480 --> 00:27:17,409
big some of these structures are we also

00:27:15,700 --> 00:27:18,490
then and I'm just gonna kind of walk

00:27:17,409 --> 00:27:21,610
over here because I have long arms and

00:27:18,490 --> 00:27:23,559
pointed stuff so then we also have we

00:27:21,610 --> 00:27:25,299
can get sides of structures we can see

00:27:23,559 --> 00:27:26,980
we also can just access right into the

00:27:25,299 --> 00:27:30,129
structure because we've cast it to to

00:27:26,980 --> 00:27:31,779
this struct d tedder how we actually

00:27:30,129 --> 00:27:33,070
write kernel code right we cast a

00:27:31,779 --> 00:27:34,059
structure down on there right you're not

00:27:33,070 --> 00:27:36,220
you don't have to go to the top of your

00:27:34,059 --> 00:27:37,720
file and define some fake new function

00:27:36,220 --> 00:27:39,250
that you've defined or fake new

00:27:37,720 --> 00:27:41,080
structure that you've defined 15 times

00:27:39,250 --> 00:27:42,279
in other apps you've written you just

00:27:41,080 --> 00:27:43,720
get to use what's there for the kernel

00:27:42,279 --> 00:27:45,820
now in this case one of the interesting

00:27:43,720 --> 00:27:49,720
nuances that you might see is the very

00:27:45,820 --> 00:27:52,480
first thing we do is we get a pointer to

00:27:49,720 --> 00:27:53,919
the data we get a pointer to the end of

00:27:52,480 --> 00:27:58,240
the data and then we try to figure out

00:27:53,919 --> 00:27:59,649
is the data further out than whatever

00:27:58,240 --> 00:28:01,149
our network offset is so in other words

00:27:59,649 --> 00:28:03,429
do we have enough space to look for this

00:28:01,149 --> 00:28:04,840
this is a place that's think this is

00:28:03,429 --> 00:28:06,909
code that's put in there for the BPF of

00:28:04,840 --> 00:28:08,350
the EBP a verifier so this is a boundary

00:28:06,909 --> 00:28:10,269
checks almost everything you do any

00:28:08,350 --> 00:28:12,669
memory you access you need to provide a

00:28:10,269 --> 00:28:14,379
check to the verifier first anyone who

00:28:12,669 --> 00:28:17,080
so you should really do these kind of

00:28:14,379 --> 00:28:19,029
pine tree shakes right all right but we

00:28:17,080 --> 00:28:20,559
often forget them but you cannot forget

00:28:19,029 --> 00:28:22,330
them here because then the verify comes

00:28:20,559 --> 00:28:24,279
and slaps you that's right and if you

00:28:22,330 --> 00:28:25,809
forget your boundary takes it this is

00:28:24,279 --> 00:28:27,669
like you have to do this for security

00:28:25,809 --> 00:28:29,980
reasons right but right now you forget

00:28:27,669 --> 00:28:31,860
them but I've actually couple of times

00:28:29,980 --> 00:28:34,870
written code and actually forgot these

00:28:31,860 --> 00:28:36,460
boundary checks and I was like no my

00:28:34,870 --> 00:28:39,369
code is correct but the verify says no

00:28:36,460 --> 00:28:41,970
no my course no and then I check it okay

00:28:39,369 --> 00:28:44,039
I forgot the boundary change right

00:28:41,970 --> 00:28:45,330
I even ended up writing to Danielle

00:28:44,039 --> 00:28:48,450
saying if this code doesn't work and say

00:28:45,330 --> 00:28:53,129
yes probably very sure Nicole you're

00:28:48,450 --> 00:28:56,309
doing your action verifies correct it's

00:28:53,129 --> 00:28:58,860
it's rare the verifier is wrong it does

00:28:56,309 --> 00:29:00,899
happen but especially based on the

00:28:58,860 --> 00:29:02,970
maturity we have today so so what we see

00:29:00,899 --> 00:29:04,740
right now too is we do a quick so we

00:29:02,970 --> 00:29:06,659
checked the length and then we go and we

00:29:04,740 --> 00:29:07,860
say parse ipv4 so let's take a look at

00:29:06,659 --> 00:29:08,429
that function I think it's on the next

00:29:07,860 --> 00:29:11,909
slide

00:29:08,429 --> 00:29:13,889
yes so here's another great example

00:29:11,909 --> 00:29:15,809
we've sort of shown another way using

00:29:13,889 --> 00:29:17,399
some pointer math to check to make sure

00:29:15,809 --> 00:29:19,980
that whatever we're looking at is

00:29:17,399 --> 00:29:21,929
something we can actually access another

00:29:19,980 --> 00:29:22,830
key thing to think about here whenever

00:29:21,929 --> 00:29:24,750
we're coding something we're very

00:29:22,830 --> 00:29:27,029
typically we just say all right you know

00:29:24,750 --> 00:29:28,440
here's the new header it's pointer this

00:29:27,029 --> 00:29:30,299
data and then we just go ahead and

00:29:28,440 --> 00:29:31,529
automatically access the structure

00:29:30,299 --> 00:29:33,120
element well here we've got to remember

00:29:31,529 --> 00:29:34,620
it's not actually that we need to care

00:29:33,120 --> 00:29:36,480
just about the pointer it's the pointer

00:29:34,620 --> 00:29:37,620
it's the end of the point or the end of

00:29:36,480 --> 00:29:40,529
the structure that we care about so we

00:29:37,620 --> 00:29:43,200
do our IP h plus 1 for fun pointer math

00:29:40,529 --> 00:29:44,879
tricks to appease the verifier and then

00:29:43,200 --> 00:29:47,460
we can just return IP h protocol and we

00:29:44,879 --> 00:29:50,429
and we can do a check and and and the +1

00:29:47,460 --> 00:29:52,649
here for for nuts for people who don't

00:29:50,429 --> 00:29:54,330
usually code see is that what +1 is

00:29:52,649 --> 00:29:56,250
because this is a pointer to a struct so

00:29:54,330 --> 00:29:58,769
it's we advance the struct size of the

00:29:56,250 --> 00:30:00,210
struct once so so so people that don't

00:29:58,769 --> 00:30:03,090
reach secret that Marcel

00:30:00,210 --> 00:30:04,769
we had a full comment for that yeah but

00:30:03,090 --> 00:30:07,379
but what the panel here is also that

00:30:04,769 --> 00:30:09,539
this stuff gets in line so we we do to

00:30:07,379 --> 00:30:11,399
function simple function calls in our

00:30:09,539 --> 00:30:13,200
code but we have to inline them because

00:30:11,399 --> 00:30:16,289
there's some wonderful restrictions for

00:30:13,200 --> 00:30:17,850
for for PPF that that we don't have

00:30:16,289 --> 00:30:19,289
function calls which is not completely

00:30:17,850 --> 00:30:22,049
true because we just added function

00:30:19,289 --> 00:30:24,090
calls but but generally this is what

00:30:22,049 --> 00:30:27,450
what what's available today though yes

00:30:24,090 --> 00:30:30,659
yeah okay all right let's move on which

00:30:27,450 --> 00:30:35,129
yeah so we have yeah so yeah there's a

00:30:30,659 --> 00:30:36,690
new Libby PF is the library we want to

00:30:35,129 --> 00:30:38,190
standardize on that's right this is

00:30:36,690 --> 00:30:40,159
available in the currents we were

00:30:38,190 --> 00:30:42,240
discussing with with different

00:30:40,159 --> 00:30:44,190
distributions how we actually is because

00:30:42,240 --> 00:30:46,049
we could ship this with together with

00:30:44,190 --> 00:30:48,690
different distributions to make a little

00:30:46,049 --> 00:30:50,580
bit easier right now it's it's primarily

00:30:48,690 --> 00:30:51,690
in the kernel tree this leap PPF and

00:30:50,580 --> 00:30:54,240
it's used by perf

00:30:51,690 --> 00:30:55,980
it's used by Shuba Quetta it's used by

00:30:54,240 --> 00:30:57,750
the samples issues by the

00:30:55,980 --> 00:31:00,270
testing so there's different uses of it

00:30:57,750 --> 00:31:02,520
and it will be shipped by the

00:31:00,270 --> 00:31:03,750
distributions hopefully so as you

00:31:02,520 --> 00:31:05,880
remember from our example earlier we

00:31:03,750 --> 00:31:07,860
talked about how the the BPF code is

00:31:05,880 --> 00:31:09,900
actually in these underscore currency

00:31:07,860 --> 00:31:12,140
and object file 0 so here you can see

00:31:09,900 --> 00:31:15,540
we've got a file this is our precompiled

00:31:12,140 --> 00:31:17,760
BPF program xt p1 underscore current oh

00:31:15,540 --> 00:31:19,830
we're just gonna we specify the type

00:31:17,760 --> 00:31:22,530
that it's x DP and then we literally

00:31:19,830 --> 00:31:24,419
just call this function right here this

00:31:22,530 --> 00:31:26,010
part of the BPF that loads it for us and

00:31:24,419 --> 00:31:27,480
the return we get back is appointed of

00:31:26,010 --> 00:31:30,419
the object and a pointer to the file

00:31:27,480 --> 00:31:32,700
descriptor that are there ready for us

00:31:30,419 --> 00:31:34,500
to use yes so the handle is a file

00:31:32,700 --> 00:31:36,390
descriptor as we've always known it from

00:31:34,500 --> 00:31:45,179
your next this is our handle to the

00:31:36,390 --> 00:31:48,330
program and this is this is just another

00:31:45,179 --> 00:31:49,860
example it's a little bit more advanced

00:31:48,330 --> 00:31:52,679
but it's because you could actually add

00:31:49,860 --> 00:31:54,210
as I said the whole thing has to be in

00:31:52,679 --> 00:31:56,370
line but you can actually have an elf

00:31:54,210 --> 00:31:59,700
object with multiple programs within

00:31:56,370 --> 00:32:01,919
that probe you have C file if you want

00:31:59,700 --> 00:32:04,350
to load the depending on what you want

00:32:01,919 --> 00:32:07,410
you want to you can load the different

00:32:04,350 --> 00:32:09,720
sections of the PPF program if this is

00:32:07,410 --> 00:32:11,010
just an example of how you you would you

00:32:09,720 --> 00:32:13,919
would do that if you have several

00:32:11,010 --> 00:32:15,360
programs within one L file so with a

00:32:13,919 --> 00:32:19,410
given interface can you have multiple

00:32:15,360 --> 00:32:21,540
programs loaded at once ok so yeah so

00:32:19,410 --> 00:32:23,910
but but the reason I'm showing this is

00:32:21,540 --> 00:32:25,440
you can have multiple programs loaded

00:32:23,910 --> 00:32:27,960
because it's but in each different hooks

00:32:25,440 --> 00:32:29,669
and it depends on the pivot but able to

00:32:27,960 --> 00:32:31,710
xtp you can only have one program loaded

00:32:29,669 --> 00:32:34,140
but what I'm using in some of my

00:32:31,710 --> 00:32:35,610
programs is that I am I have a HTP

00:32:34,140 --> 00:32:38,340
program but I also have a trace point

00:32:35,610 --> 00:32:40,950
program to actually catch errors so I'm

00:32:38,340 --> 00:32:42,690
in the same C file I both have the

00:32:40,950 --> 00:32:46,650
program that want I want to attach to

00:32:42,690 --> 00:32:49,200
the to catch the the HTTP aborted for

00:32:46,650 --> 00:32:56,370
example or another trade plan to tangles

00:32:49,200 --> 00:32:58,470
errors so attaching this this HTTP

00:32:56,370 --> 00:32:59,549
program to something so now that we've

00:32:58,470 --> 00:33:03,330
got it loaded you probably remember

00:32:59,549 --> 00:33:04,799
earlier we had pro-gay FD had had was a

00:33:03,330 --> 00:33:06,510
file descriptor that we had for this

00:33:04,799 --> 00:33:09,460
this program so now we can say alright

00:33:06,510 --> 00:33:12,660
just set the

00:33:09,460 --> 00:33:15,760
BPF set link xt PFD pretty simple we

00:33:12,660 --> 00:33:18,900
translate the name using AF name to

00:33:15,760 --> 00:33:22,000
index attached to the if' index and

00:33:18,900 --> 00:33:26,470
there we go now we're often running and

00:33:22,000 --> 00:33:28,720
we are attached so so now what the code

00:33:26,470 --> 00:33:31,180
that's in the section associated with

00:33:28,720 --> 00:33:33,730
that in XTP coronado is attached to our

00:33:31,180 --> 00:33:35,740
III row device and every time a packet

00:33:33,730 --> 00:33:36,510
arrives it goes it goes for that code

00:33:35,740 --> 00:33:39,610
yep

00:33:36,510 --> 00:33:40,960
so we also have to explain a little bit

00:33:39,610 --> 00:33:42,550
about how you actually use these maps

00:33:40,960 --> 00:33:44,200
they're sort of you can use for the

00:33:42,550 --> 00:33:46,720
control plane you can also use it to

00:33:44,200 --> 00:33:50,200
store other information but so we have

00:33:46,720 --> 00:33:53,250
to like what what how does it look when

00:33:50,200 --> 00:33:57,550
you have one to add a map so this is on

00:33:53,250 --> 00:34:00,130
the PPF side on the undercurrent the

00:33:57,550 --> 00:34:04,180
underscore current so this is how you

00:34:00,130 --> 00:34:05,590
define a map and and this is just a

00:34:04,180 --> 00:34:09,160
struct that gets picked up at the

00:34:05,590 --> 00:34:11,620
section maps and and then we have to why

00:34:09,160 --> 00:34:12,760
you're executing to prepare program your

00:34:11,620 --> 00:34:15,340
access is like that you could do a

00:34:12,760 --> 00:34:17,980
lookup in the map and in this case we

00:34:15,340 --> 00:34:20,380
are we are just using as a counter and

00:34:17,980 --> 00:34:24,310
here we're just doing plus one but

00:34:20,380 --> 00:34:26,740
because we have per CPU array was a

00:34:24,310 --> 00:34:27,820
stretch so we yeah we are allowed just

00:34:26,740 --> 00:34:30,070
to do a plus one so there's no

00:34:27,820 --> 00:34:33,940
concurrency issues here it does say in

00:34:30,070 --> 00:34:35,470
the comment that if it is a basic array

00:34:33,940 --> 00:34:37,390
you're the obvious have to have some

00:34:35,470 --> 00:34:38,980
synchronization here at some atomic

00:34:37,390 --> 00:34:42,600
operations and you can use to swing

00:34:38,980 --> 00:34:44,770
fetch in that operation I will show

00:34:42,600 --> 00:34:46,150
what's kind of amazing is we're talking

00:34:44,770 --> 00:34:47,860
about such a few number of instructions

00:34:46,150 --> 00:34:50,380
to actually do transformations on these

00:34:47,860 --> 00:34:52,510
packets that just a simple optimization

00:34:50,380 --> 00:34:53,920
of using a per CPU array instead of one

00:34:52,510 --> 00:34:56,530
array that needs to take a lock across

00:34:53,920 --> 00:34:58,330
all CPUs makes a huge difference I mean

00:34:56,530 --> 00:34:59,320
a tremendous difference so it's

00:34:58,330 --> 00:35:01,570
important to think about how in this

00:34:59,320 --> 00:35:03,220
case with the queer offloading the the

00:35:01,570 --> 00:35:06,340
work of summing these stats to the

00:35:03,220 --> 00:35:08,280
control plane because that's not the

00:35:06,340 --> 00:35:11,680
next not did not dislike the next one

00:35:08,280 --> 00:35:14,020
but but so how do you do we get from

00:35:11,680 --> 00:35:17,380
user space how do you get a hold of the

00:35:14,020 --> 00:35:20,020
of the map after five to scripture so so

00:35:17,380 --> 00:35:22,119
we when you are the program the loaded

00:35:20,020 --> 00:35:24,130
this we

00:35:22,119 --> 00:35:26,049
you have this the slip PPF function

00:35:24,130 --> 00:35:27,190
where you can actually find find a map

00:35:26,049 --> 00:35:29,049
by name

00:35:27,190 --> 00:35:31,299
you can also some of the older programs

00:35:29,049 --> 00:35:33,400
we also assume that we always take index

00:35:31,299 --> 00:35:35,019
zero of the map but actually now we have

00:35:33,400 --> 00:35:37,359
a little bit nicer that you actually

00:35:35,019 --> 00:35:39,160
look up by name so you don't make

00:35:37,359 --> 00:35:42,789
mistakes about and I have implicit

00:35:39,160 --> 00:35:44,740
assumptions of in that the order do to

00:35:42,789 --> 00:35:46,749
find the maps and some of the sample

00:35:44,740 --> 00:35:49,779
codes still have this the older method

00:35:46,749 --> 00:35:53,230
of su having assumption about the order

00:35:49,779 --> 00:36:02,829
of the defiance in the in the kernel

00:35:53,230 --> 00:36:04,329
file yeah so there's no file descriptor

00:36:02,829 --> 00:36:06,069
associated with that thing see so is the

00:36:04,329 --> 00:36:09,039
namespace that you're looking up no this

00:36:06,069 --> 00:36:11,499
is this is so this is the object I have

00:36:09,039 --> 00:36:14,589
up here so the object is as a leap EPF

00:36:11,499 --> 00:36:16,390
object that I'm I'm asking for this so

00:36:14,589 --> 00:36:19,809
this is this is the this is the the

00:36:16,390 --> 00:36:21,910
program then loaded the so but what you

00:36:19,809 --> 00:36:23,259
get back out is a file description you

00:36:21,910 --> 00:36:26,230
can actually get this file description

00:36:23,259 --> 00:36:29,380
in another way requiring but we are not

00:36:26,230 --> 00:36:31,210
going into that so now we have to this

00:36:29,380 --> 00:36:31,509
is the user space code does that make

00:36:31,210 --> 00:36:33,279
sense

00:36:31,509 --> 00:36:34,989
this is a space code that is yet that

00:36:33,279 --> 00:36:37,869
you shouldn't mention that that's quite

00:36:34,989 --> 00:36:40,569
important so now I have have to fight

00:36:37,869 --> 00:36:42,460
got the file descriptor now I and I and

00:36:40,569 --> 00:36:45,099
I need to read this information out and

00:36:42,460 --> 00:36:46,960
as Andy has hinted that because we have

00:36:45,099 --> 00:36:49,150
two per CPU stuff it makes the

00:36:46,960 --> 00:36:50,739
complication a little bit more more

00:36:49,150 --> 00:36:54,190
trouble like we have to do more work in

00:36:50,739 --> 00:36:56,019
user space now because we have we have

00:36:54,190 --> 00:37:00,849
to take that the number of possible CPUs

00:36:56,019 --> 00:37:03,759
and I do the the lookup of the elements

00:37:00,849 --> 00:37:06,970
and get the value out we will have a

00:37:03,759 --> 00:37:10,420
counter per CPU and as you can see up

00:37:06,970 --> 00:37:14,430
here we have we have to have a small for

00:37:10,420 --> 00:37:16,390
loop to actually sum this up so and and

00:37:14,430 --> 00:37:18,069
we sort of get the benefit of

00:37:16,390 --> 00:37:19,420
performance on the kernel side but we

00:37:18,069 --> 00:37:22,269
had to do a little bit more on the use

00:37:19,420 --> 00:37:24,119
of space side to to to sum this up and

00:37:22,269 --> 00:37:27,099
that that is sort of a good optimization

00:37:24,119 --> 00:37:28,569
to push a little bit more we're going to

00:37:27,099 --> 00:37:30,989
use this base then under HMDA on the

00:37:28,569 --> 00:37:30,989
fast path

00:37:31,960 --> 00:37:39,710
do you want anything more about this no

00:37:34,910 --> 00:37:43,970
I think we probably got a hustle too so

00:37:39,710 --> 00:37:47,210
when we so that's the descriptive

00:37:43,970 --> 00:37:50,599
concepts so we have to redirect action

00:37:47,210 --> 00:37:52,910
which is sort of a special one and I'm

00:37:50,599 --> 00:37:55,339
sort of hoping that this would be will

00:37:52,910 --> 00:37:57,829
be the last action because we can we can

00:37:55,339 --> 00:37:59,900
buy wheat awakening we are redirecting

00:37:57,829 --> 00:38:02,599
into maps that gives us flexibility to

00:37:59,900 --> 00:38:06,680
invent new bulking code or not working

00:38:02,599 --> 00:38:08,480
code new new new code that that can

00:38:06,680 --> 00:38:12,880
extend without a change in the drivers

00:38:08,480 --> 00:38:15,470
anymore the redirect also hides bulking

00:38:12,880 --> 00:38:17,240
so yeah do you have to remember to use

00:38:15,470 --> 00:38:19,910
to redirect map call this activates

00:38:17,240 --> 00:38:21,980
parking but I can see we have like four

00:38:19,910 --> 00:38:26,329
minutes left so there's different types

00:38:21,980 --> 00:38:28,820
of maps there's that's all fun but but

00:38:26,329 --> 00:38:30,020
let's move on to a way you want to so if

00:38:28,820 --> 00:38:31,280
you're a Knick driver developer this is

00:38:30,020 --> 00:38:32,390
kind of the key slide for you if you

00:38:31,280 --> 00:38:33,650
currently don't have a driver that

00:38:32,390 --> 00:38:35,960
supports xdp you're gonna need to think

00:38:33,650 --> 00:38:38,060
about implementing these different

00:38:35,960 --> 00:38:40,550
operations so this is a real

00:38:38,060 --> 00:38:44,810
trimmed-down version we did a whole

00:38:40,550 --> 00:38:47,390
slide this is what needs to do all you

00:38:44,810 --> 00:38:48,890
need to do so we you can see we've got

00:38:47,390 --> 00:38:52,640
the five options we talked about there

00:38:48,890 --> 00:38:53,660
the five actions we talked about ideally

00:38:52,640 --> 00:38:56,300
it will take you more than one line of

00:38:53,660 --> 00:38:57,619
code to implement the code to just do

00:38:56,300 --> 00:39:00,170
the transmit or to do the redirect

00:38:57,619 --> 00:39:02,480
action but this can fit in a fairly

00:39:00,170 --> 00:39:05,450
small space inside your nappy your nappy

00:39:02,480 --> 00:39:07,490
poll handler to do this and then the the

00:39:05,450 --> 00:39:09,770
key with all this is that some of this

00:39:07,490 --> 00:39:11,690
as yes per mentioned there's a bulking

00:39:09,770 --> 00:39:13,130
operation that's available which gives

00:39:11,690 --> 00:39:14,510
us another huge performance boost when

00:39:13,130 --> 00:39:17,000
we're doing these rapid transmits you

00:39:14,510 --> 00:39:18,650
don't need to necessarily write the

00:39:17,000 --> 00:39:20,270
doorbell for your NIC every single time

00:39:18,650 --> 00:39:22,550
to make sure every single packet sent

00:39:20,270 --> 00:39:25,010
you can send a few of those then write

00:39:22,550 --> 00:39:27,020
the doorbell so so pump from the NIC

00:39:25,010 --> 00:39:29,420
drive it they usually the process one

00:39:27,020 --> 00:39:30,829
packet at a time so we made an API where

00:39:29,420 --> 00:39:32,720
where we still simulate there'd be a

00:39:30,829 --> 00:39:35,420
processing one pack at a time but we

00:39:32,720 --> 00:39:37,400
actually achieve bulking by combining

00:39:35,420 --> 00:39:39,260
this we have to slash operation and in

00:39:37,400 --> 00:39:40,849
the end yeah it's sort of the key that

00:39:39,260 --> 00:39:41,960
when we do we do the flush write

00:39:40,849 --> 00:39:44,270
everything down to the driver at once

00:39:41,960 --> 00:39:46,490
right the doorbell

00:39:44,270 --> 00:39:48,110
moments impact of doing bulking of doing

00:39:46,490 --> 00:39:50,720
receive bulking but we are hiding this

00:39:48,110 --> 00:39:52,430
behind a little bit another interface so

00:39:50,720 --> 00:39:55,760
we don't have to make the drivers more

00:39:52,430 --> 00:39:57,620
complicated by huge I can say 40% yeah

00:39:55,760 --> 00:40:02,120
legitimately that makes a huge

00:39:57,620 --> 00:40:04,190
difference yeah everybody's asking about

00:40:02,120 --> 00:40:06,170
this like what is the restriction for

00:40:04,190 --> 00:40:10,490
the driver model so we used to have like

00:40:06,170 --> 00:40:12,500
the requirement of one page per Percy

00:40:10,490 --> 00:40:15,620
frame that is no longer true because

00:40:12,500 --> 00:40:18,260
until they in there drivers they are

00:40:15,620 --> 00:40:20,840
having one page and they're having to

00:40:18,260 --> 00:40:26,990
package they can just fit two packets in

00:40:20,840 --> 00:40:29,240
one page which is 4 kilobytes and but

00:40:26,990 --> 00:40:32,150
what we sort of kept wealth requirement

00:40:29,240 --> 00:40:35,150
is that this memory must be continued

00:40:32,150 --> 00:40:37,820
contiguous physical memory that that

00:40:35,150 --> 00:40:39,800
this packets gets gets delivered in and

00:40:37,820 --> 00:40:42,320
you have to have some Headroom and you

00:40:39,800 --> 00:40:44,720
also have to have some from some tail

00:40:42,320 --> 00:40:47,300
room when these kids transferred into

00:40:44,720 --> 00:40:50,420
the network stack we need extra room in

00:40:47,300 --> 00:40:52,070
in the end of the packet to to have

00:40:50,420 --> 00:40:55,220
something called the S key BC add info

00:40:52,070 --> 00:40:56,870
section which is also a requirement for

00:40:55,220 --> 00:41:00,830
the driver how they have to lay layout

00:40:56,870 --> 00:41:04,220
this memory requirement so one of the

00:41:00,830 --> 00:41:05,540
other big one of the other issue nots

00:41:04,220 --> 00:41:07,520
not support issues right now is we are

00:41:05,540 --> 00:41:11,270
not splitting frames across multiple

00:41:07,520 --> 00:41:13,040
pages so if you're really in love with

00:41:11,270 --> 00:41:17,930
jumbo frames you might be out of luck

00:41:13,040 --> 00:41:21,530
for now we are not supporting John it's

00:41:17,930 --> 00:41:24,050
complicated things and it's so we could

00:41:21,530 --> 00:41:26,540
couldn't like to have it be higher order

00:41:24,050 --> 00:41:31,580
pages for jumbo frames but then there we

00:41:26,540 --> 00:41:34,130
have slowed down the normal normal use

00:41:31,580 --> 00:41:37,700
case of HTTP just to support jumbo

00:41:34,130 --> 00:41:41,120
frames you have a question no you're not

00:41:37,700 --> 00:41:46,700
allowed to ask questions yeah we don't

00:41:41,120 --> 00:41:48,620
have it was just him it wasn't what

00:41:46,700 --> 00:41:51,650
about G ro or other technologies that

00:41:48,620 --> 00:41:53,510
amalgamate so this this happens before

00:41:51,650 --> 00:41:55,850
the g io step so this this is really

00:41:53,510 --> 00:41:58,130
another non-issue but because it happens

00:41:55,850 --> 00:42:00,710
later so did the network stack just

00:41:58,130 --> 00:42:02,569
so if it gets passed on to a network

00:42:00,710 --> 00:42:04,460
stack it can call up these packets but

00:42:02,569 --> 00:42:05,420
that's in native mode what about it SKB

00:42:04,460 --> 00:42:07,940
receive mode

00:42:05,420 --> 00:42:11,319
several frames are it's it's is we don't

00:42:07,940 --> 00:42:14,299
have time to I can explain it offline

00:42:11,319 --> 00:42:19,009
hunt table table to later yeah yeah

00:42:14,299 --> 00:42:20,839
abort XD be aborted so so we what I

00:42:19,009 --> 00:42:24,410
recently added I we have sort of hat now

00:42:20,839 --> 00:42:25,970
have a pluggable model for for the

00:42:24,410 --> 00:42:28,759
receive queue so you can have another

00:42:25,970 --> 00:42:30,799
memory model perceive queue I've been

00:42:28,759 --> 00:42:36,470
using that actually to get the serial

00:42:30,799 --> 00:42:39,019
copy mode in F FX DP and there's an

00:42:36,470 --> 00:42:40,489
opportunity to to share this allocated

00:42:39,019 --> 00:42:45,049
code between the different drivers and

00:42:40,489 --> 00:42:49,279
I'm going to work on that next week so

00:42:45,049 --> 00:42:51,440
we are actually out of time we're told

00:42:49,279 --> 00:42:53,599
it is a strict requirement yes we are

00:42:51,440 --> 00:42:54,950
apparently the walls coming down so so

00:42:53,599 --> 00:42:57,940
thank you and this is actually a

00:42:54,950 --> 00:43:03,909
combined effort of many people Thanks

00:42:57,940 --> 00:43:03,909

YouTube URL: https://www.youtube.com/watch?v=Y103CWBa1BI


