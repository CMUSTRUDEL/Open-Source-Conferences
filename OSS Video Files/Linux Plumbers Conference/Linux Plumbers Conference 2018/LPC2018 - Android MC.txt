Title: LPC2018 - Android MC
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	https://linuxplumbersconf.org/event/2/sessions/25/#20181114


Android continues to find interesting new applications and problems to solve, both within and outside the mobile arena. Mainlining continues to be an area of focus, as do a number of areas of core Android functionality, including the kernel. Other areas where there is ongoing work include the low memory killer, dynamically-allocated Binder devices, kernel namespaces, EAS, userdata FS checkpointing and DT.

The working planning document is here:
https://docs.google.com/spreadsheets/d/1ymzOB4wapccX6t1b11T2-m9ny8buN7EuUqhCxrsmKe4
Captions: 
	00:00:05,840 --> 00:00:10,730
this is the 2018 andrew michael

00:00:07,880 --> 00:00:13,219
conference so

00:00:10,730 --> 00:00:16,580
a few things about the micro conference

00:00:13,219 --> 00:00:17,090
itself first I'd like to welcome you on

00:00:16,580 --> 00:00:19,400
behalf

00:00:17,090 --> 00:00:22,669
Todd Amit and myself the organisation

00:00:19,400 --> 00:00:24,680
committee this is the yearly sync point

00:00:22,669 --> 00:00:28,099
where we get quite a number of people

00:00:24,680 --> 00:00:31,189
from the Google team to sync with the

00:00:28,099 --> 00:00:34,960
kernel development teams and whoever is

00:00:31,189 --> 00:00:36,220
interested in any of the handler work

00:00:34,960 --> 00:00:38,510
[Music]

00:00:36,220 --> 00:00:40,460
this year is a bit different because

00:00:38,510 --> 00:00:43,010
unlike the other years where we take a

00:00:40,460 --> 00:00:44,960
double slot where we had we have just

00:00:43,010 --> 00:00:47,059
one slot and yesterday there was a full

00:00:44,960 --> 00:00:48,800
talk by Sandeep which ran through most

00:00:47,059 --> 00:00:52,309
of the you know theory part of what's

00:00:48,800 --> 00:00:58,129
new and so on so the focus really is on

00:00:52,309 --> 00:01:00,890
discussion I will be really strict about

00:00:58,129 --> 00:01:04,280
the 15 minute that is allocated to every

00:01:00,890 --> 00:01:05,750
talk so if you haven't gone to any

00:01:04,280 --> 00:01:07,250
discussion by 10 minutes I'm gonna

00:01:05,750 --> 00:01:08,929
probably shut you down right there and

00:01:07,250 --> 00:01:09,229
say okay that was your last slide your

00:01:08,929 --> 00:01:12,950
paper

00:01:09,229 --> 00:01:14,810
switching over the mics so the material

00:01:12,950 --> 00:01:17,599
for all the presentations is online

00:01:14,810 --> 00:01:19,550
already so I you know by all means if

00:01:17,599 --> 00:01:20,840
there's a topic of interest to you just

00:01:19,550 --> 00:01:23,149
go ahead and grab the slides and look at

00:01:20,840 --> 00:01:25,989
them ahead of time so when the top comes

00:01:23,149 --> 00:01:29,509
around you have your questions ready

00:01:25,989 --> 00:01:31,459
what else should I say yeah it obviously

00:01:29,509 --> 00:01:32,810
15 minutes is pretty short so we don't

00:01:31,459 --> 00:01:36,170
expect the discussions to kind of like

00:01:32,810 --> 00:01:37,970
end at 15 minutes the goal is to start

00:01:36,170 --> 00:01:39,530
the conversation and by all means you

00:01:37,970 --> 00:01:41,270
know the hallway is open for anybody to

00:01:39,530 --> 00:01:46,789
continue the conversation there is a

00:01:41,270 --> 00:01:49,580
break at 3:30 so you know well that'll

00:01:46,789 --> 00:01:50,869
get me an opportunity to if nothing else

00:01:49,580 --> 00:01:52,959
starts some of those conversations there

00:01:50,869 --> 00:01:56,509
if they haven't already started

00:01:52,959 --> 00:01:57,709
there is a either pad that the shell is

00:01:56,509 --> 00:01:59,330
going to be maintaining by all means

00:01:57,709 --> 00:02:03,050
please feel free to contribute to it it

00:01:59,330 --> 00:02:05,360
is open all as I had mentioned to the

00:02:03,050 --> 00:02:07,310
speakers ahead of time we are gonna do

00:02:05,360 --> 00:02:12,140
something a bit different this year so

00:02:07,310 --> 00:02:13,640
as a summary for the end of day tomorrow

00:02:12,140 --> 00:02:15,590
I'm gonna be presenting this progress

00:02:13,640 --> 00:02:19,489
report and effectively I got a one line

00:02:15,590 --> 00:02:21,409
per discussion item you know wins - dues

00:02:19,489 --> 00:02:22,520
and losses you've changed named if you

00:02:21,409 --> 00:02:24,170
like don't like him I don't care

00:02:22,520 --> 00:02:26,360
essentially just put bullet items in

00:02:24,170 --> 00:02:27,440
there put anything that's important in

00:02:26,360 --> 00:02:29,630
bold we're honest of which over the

00:02:27,440 --> 00:02:31,940
three categories it falls into the point

00:02:29,630 --> 00:02:33,920
is anybody that reads this six months

00:02:31,940 --> 00:02:36,020
down the road knows what was made it in

00:02:33,920 --> 00:02:38,750
terms of progress on any of the specific

00:02:36,020 --> 00:02:40,040
topics that we talked about so if you're

00:02:38,750 --> 00:02:42,590
one of the speakers please make sure to

00:02:40,040 --> 00:02:44,530
fill your wine you know by end of day

00:02:42,590 --> 00:02:47,390
today that'd be great

00:02:44,530 --> 00:02:50,090
cameras okay so the rule I was told is

00:02:47,390 --> 00:02:52,220
speakers have to essentially be here

00:02:50,090 --> 00:02:54,740
left word not in front of the camera

00:02:52,220 --> 00:02:56,510
here so anywhere from where I am to my

00:02:54,740 --> 00:02:58,340
left is good all right

00:02:56,510 --> 00:03:02,960
and that's about all I got to say I'm

00:02:58,340 --> 00:03:05,870
turning it over to Martin thank you sir

00:03:02,960 --> 00:03:09,650
yes the mic is right here if you want

00:03:05,870 --> 00:03:12,850
mine I can give it to you as well I just

00:03:09,650 --> 00:03:12,850
have to find a power button

00:03:14,980 --> 00:03:19,530
here's my incompetence showing come on

00:03:17,290 --> 00:03:22,680
how to turn this guy on

00:03:19,530 --> 00:03:44,170
yeah I'm thinking about twisting it but

00:03:22,680 --> 00:03:46,269
no how about this alright so my name is

00:03:44,170 --> 00:03:47,980
Sam Orton I work in the Android team at

00:03:46,269 --> 00:03:52,900
Google but I'm here to talk to you about

00:03:47,980 --> 00:03:54,430
a series name symbol namespaces so let's

00:03:52,900 --> 00:03:56,620
start the problem that dispatch service

00:03:54,430 --> 00:03:58,180
is trying to tackle so the problem that

00:03:56,620 --> 00:04:00,910
we're trying to solve is that the kernel

00:03:58,180 --> 00:04:04,690
has as a recent kernel version more than

00:04:00,910 --> 00:04:06,310
30k exported symbols and those symbols

00:04:04,690 --> 00:04:07,540
are basically exported into a global

00:04:06,310 --> 00:04:10,420
namespace which means that they are

00:04:07,540 --> 00:04:12,280
visible to all modules that are present

00:04:10,420 --> 00:04:13,630
in the kernel and the problem this

00:04:12,280 --> 00:04:15,940
creates is that it's really hard to

00:04:13,630 --> 00:04:19,060
manage the export service because any

00:04:15,940 --> 00:04:20,560
module can use any symbol sometimes you

00:04:19,060 --> 00:04:22,120
get modules using symbols they really

00:04:20,560 --> 00:04:23,950
shouldn't be like symbols that are meant

00:04:22,120 --> 00:04:27,100
to be until to a certain subsystem for

00:04:23,950 --> 00:04:28,570
example these kind of infractions can

00:04:27,100 --> 00:04:31,120
also be really hard to catch and code

00:04:28,570 --> 00:04:32,320
review because I'm not all symbols are

00:04:31,120 --> 00:04:33,490
named very well and there are some

00:04:32,320 --> 00:04:35,320
symbols where you really wonder what

00:04:33,490 --> 00:04:37,180
subsystem they belong to and it's not so

00:04:35,320 --> 00:04:40,060
obvious and that you really should have

00:04:37,180 --> 00:04:41,500
been using a simple so it makes it

00:04:40,060 --> 00:04:43,150
really hard to reason about the export

00:04:41,500 --> 00:04:46,990
surface or even to visualize the export

00:04:43,150 --> 00:04:48,960
service trying to make it more specific

00:04:46,990 --> 00:04:51,610
how this affects Android is if you

00:04:48,960 --> 00:04:53,020
attended some deeps talk yesterday you

00:04:51,610 --> 00:04:54,760
saw that we want to move to a model

00:04:53,020 --> 00:04:57,550
where we basically have a single Co

00:04:54,760 --> 00:04:59,169
image and for an app for an architecture

00:04:57,550 --> 00:05:01,720
and that means that all the device

00:04:59,169 --> 00:05:03,760
specific stuff will be for touchscreen

00:05:01,720 --> 00:05:06,190
and things like that they likes to be

00:05:03,760 --> 00:05:08,940
loadable kernel modules and because the

00:05:06,190 --> 00:05:11,650
kernel kernel doesn't have a stable API

00:05:08,940 --> 00:05:12,940
that means those modules could break if

00:05:11,650 --> 00:05:15,639
somebody updates any one of these

00:05:12,940 --> 00:05:16,990
symbols and we basically want to reduce

00:05:15,639 --> 00:05:19,000
or actually really we want to emulate

00:05:16,990 --> 00:05:21,720
eliminates the chance of such breakages

00:05:19,000 --> 00:05:24,690
such that when your SOC van or Android

00:05:21,720 --> 00:05:26,220
new generic Konoe image that you don't

00:05:24,690 --> 00:05:28,350
have to worry about your modules

00:05:26,220 --> 00:05:32,700
breaking because some of these symbols

00:05:28,350 --> 00:05:34,980
have changed so there are different

00:05:32,700 --> 00:05:36,240
categories of exported symbols you know

00:05:34,980 --> 00:05:38,670
there are symbols that are actually

00:05:36,240 --> 00:05:40,110
meant for drivers to be used but they're

00:05:38,670 --> 00:05:42,720
also quite some symbols that are really

00:05:40,110 --> 00:05:44,190
only exported because some core kernel

00:05:42,720 --> 00:05:46,440
functionality is split up into multiple

00:05:44,190 --> 00:05:48,570
modules like the ipv4 stack as an

00:05:46,440 --> 00:05:50,070
example where the implementation is

00:05:48,570 --> 00:05:51,330
split over multiple modules and that's

00:05:50,070 --> 00:05:53,040
the only reason why the symbols are

00:05:51,330 --> 00:05:55,740
exported but it doesn't really make

00:05:53,040 --> 00:05:57,000
sense to use these symbols doesn't make

00:05:55,740 --> 00:05:59,490
sense for a driver I'm sorry the IP

00:05:57,000 --> 00:06:00,690
subsystem to use these symbols and some

00:05:59,490 --> 00:06:02,420
symbols are really only meant for

00:06:00,690 --> 00:06:04,440
internal and to be useful for debugging

00:06:02,420 --> 00:06:05,970
but because they're all in a global

00:06:04,440 --> 00:06:10,320
namespace there is no way to indicate

00:06:05,970 --> 00:06:12,300
this or to limit their use so the idea

00:06:10,320 --> 00:06:13,919
of symbol namespaces is to make this API

00:06:12,300 --> 00:06:15,180
surface more clear and to allows a

00:06:13,919 --> 00:06:18,210
different shade between these different

00:06:15,180 --> 00:06:20,850
classes of exports that we have but also

00:06:18,210 --> 00:06:23,070
to reduce the global API surface so

00:06:20,850 --> 00:06:25,650
there is no this one big pool of symbols

00:06:23,070 --> 00:06:27,270
that people can put into their drivers

00:06:25,650 --> 00:06:28,830
but actually make it much more concise

00:06:27,270 --> 00:06:35,010
what symbols are meant for use in which

00:06:28,830 --> 00:06:37,290
art so talking about the export API just

00:06:35,010 --> 00:06:39,960
a reminder if you ask regular C language

00:06:37,290 --> 00:06:42,330
this is static it's not visible to any

00:06:39,960 --> 00:06:44,180
kernel modules where if you have global

00:06:42,330 --> 00:06:46,440
linkage is not visible to local local

00:06:44,180 --> 00:06:48,330
kernel modules as well global kernel

00:06:46,440 --> 00:06:50,040
modules you actually have to export a

00:06:48,330 --> 00:06:52,050
symbol for it to be usable by lunches

00:06:50,040 --> 00:06:56,540
and so this is where we have 30 K

00:06:52,050 --> 00:06:59,010
instances that today so if you look at

00:06:56,540 --> 00:07:00,720
the diagram on the right like the global

00:06:59,010 --> 00:07:02,610
symbols are visible only to built-in

00:07:00,720 --> 00:07:04,919
codes and then the exported symbols in

00:07:02,610 --> 00:07:07,680
orange as basically was visible to go to

00:07:04,919 --> 00:07:10,229
boku mo mo choice which is a subset so

00:07:07,680 --> 00:07:12,060
what the symbol namespace might series

00:07:10,229 --> 00:07:14,130
does is it allows you to export a symbol

00:07:12,060 --> 00:07:16,440
to a specific namespace so instead I was

00:07:14,130 --> 00:07:16,999
saying just export symbol with the

00:07:16,440 --> 00:07:19,219
function

00:07:16,999 --> 00:07:21,049
you actually append the namespace as a

00:07:19,219 --> 00:07:23,629
second parameter to the export symbol

00:07:21,049 --> 00:07:25,789
macro what this does is basically puts a

00:07:23,629 --> 00:07:27,409
symbol in a separate namespace and you

00:07:25,789 --> 00:07:29,719
will only as a drive will be able to use

00:07:27,409 --> 00:07:31,849
a symbol in such a namespace if you plus

00:07:29,719 --> 00:07:34,339
explicitly import this namespace into

00:07:31,849 --> 00:07:35,989
your driver so doing that it's very

00:07:34,339 --> 00:07:37,699
simple there is a simple micro module

00:07:35,989 --> 00:07:39,679
imported s and you specify the namespace

00:07:37,699 --> 00:07:41,119
that you want to import now once you put

00:07:39,679 --> 00:07:43,459
such a statement in your driver then you

00:07:41,119 --> 00:07:48,199
will be able to use the symbols that are

00:07:43,459 --> 00:07:49,699
in that namespace so you know the result

00:07:48,199 --> 00:07:51,349
is on the right so instead of having

00:07:49,699 --> 00:07:54,139
just this big global proof exported

00:07:51,349 --> 00:07:55,849
symbols you know the global export

00:07:54,139 --> 00:07:58,579
synthesize has become a bit smaller and

00:07:55,849 --> 00:08:02,659
instead we have an even nicer linearity

00:07:58,579 --> 00:08:04,279
USB storage symbol namespace which can

00:08:02,659 --> 00:08:06,019
only be accessed by twice versus

00:08:04,279 --> 00:08:08,269
importing it and so the result of that

00:08:06,019 --> 00:08:08,659
is that by default the number of export

00:08:08,269 --> 00:08:11,509
system

00:08:08,659 --> 00:08:13,099
symbols is a lot smaller and the API is

00:08:11,509 --> 00:08:14,569
also a lot more clearly defined

00:08:13,099 --> 00:08:16,669
like if somebody now wanted to use these

00:08:14,569 --> 00:08:18,199
symbols and the driver that it doesn't

00:08:16,669 --> 00:08:20,119
belong to it's a lot easier to catch

00:08:18,199 --> 00:08:22,399
them someone the top it says import

00:08:20,119 --> 00:08:24,199
namespace USB storage you could think

00:08:22,399 --> 00:08:25,639
why this doesn't make sense this right

00:08:24,199 --> 00:08:30,379
we really shouldn't be using any signals

00:08:25,639 --> 00:08:31,959
from that namespace the other thing I've

00:08:30,379 --> 00:08:35,149
worked in the patch supplied series is

00:08:31,959 --> 00:08:37,250
automation because one of the

00:08:35,149 --> 00:08:39,860
implications of using this is that if

00:08:37,250 --> 00:08:42,110
you export or you know limit our symbol

00:08:39,860 --> 00:08:44,120
to a certain namespace you have to find

00:08:42,110 --> 00:08:45,769
all usages of that symbol and add like

00:08:44,120 --> 00:08:48,050
the relevant import namespaces to the

00:08:45,769 --> 00:08:49,699
driver and that can be really annoying

00:08:48,050 --> 00:08:52,519
because you know it's hard to track down

00:08:49,699 --> 00:08:54,319
all usages for the symbol so the packs

00:08:52,519 --> 00:08:57,319
are basically contains the script that

00:08:54,319 --> 00:08:59,540
automatically calculates dependencies of

00:08:57,319 --> 00:09:01,100
a driver to which namespaces it depends

00:08:59,540 --> 00:09:02,809
on and it can actually order add them

00:09:01,100 --> 00:09:04,300
with a country no script which is

00:09:02,809 --> 00:09:06,730
basically the semantics

00:09:04,300 --> 00:09:10,030
uses so if you want to convert your

00:09:06,730 --> 00:09:11,800
subsystem to use exported in order to

00:09:10,030 --> 00:09:13,210
export symbols through a namespace all

00:09:11,800 --> 00:09:14,740
you have to do is move it to a namespace

00:09:13,210 --> 00:09:17,110
run the script and the script will

00:09:14,740 --> 00:09:18,520
automatically patch all the Vipers using

00:09:17,110 --> 00:09:23,110
that symbol T and for the namespace

00:09:18,520 --> 00:09:24,580
itself so it's really easy to use so the

00:09:23,110 --> 00:09:26,410
current upstream status the patch set is

00:09:24,580 --> 00:09:28,690
really small so it's around 300 lines of

00:09:26,410 --> 00:09:31,690
code which includes the automation that

00:09:28,690 --> 00:09:33,460
I just mentioned I send a v1 series in

00:09:31,690 --> 00:09:35,620
July and the feedback has been positive

00:09:33,460 --> 00:09:37,900
I think that the high-level feedback so

00:09:35,620 --> 00:09:39,610
far and not strictly related to the

00:09:37,900 --> 00:09:42,430
implementation itself has been that it

00:09:39,610 --> 00:09:44,200
would be nice to auto exports symbols

00:09:42,430 --> 00:09:45,760
based on the module name so that you

00:09:44,200 --> 00:09:48,610
don't actually explicitly have to go

00:09:45,760 --> 00:09:50,350
into your module and say export to this

00:09:48,610 --> 00:09:52,210
namespace would say all symbols for this

00:09:50,350 --> 00:09:53,530
module go into this namespace so that's

00:09:52,210 --> 00:09:56,620
just something to make it even easier to

00:09:53,530 --> 00:09:58,450
use likewise and Auto imports like there

00:09:56,620 --> 00:10:00,100
may be some drivers that all live in the

00:09:58,450 --> 00:10:01,960
same directory and you all need to

00:10:00,100 --> 00:10:04,020
import that namespace so instead of

00:10:01,960 --> 00:10:06,130
manually adding like import statements

00:10:04,020 --> 00:10:09,010
tweets driver you could also say well

00:10:06,130 --> 00:10:11,020
for all the drivers in this directory

00:10:09,010 --> 00:10:14,500
you know other auto import that

00:10:11,020 --> 00:10:16,390
namespace so the idea is to collect some

00:10:14,500 --> 00:10:21,400
feedback here and hopefully send out a

00:10:16,390 --> 00:10:23,080
v2 next week and see where it goes so I

00:10:21,400 --> 00:10:24,670
have some slides on the implementation

00:10:23,080 --> 00:10:27,250
but I first wanted to start a discussion

00:10:24,670 --> 00:10:28,600
so we just got a feeling for how do you

00:10:27,250 --> 00:10:32,610
recognize the form that I've described

00:10:28,600 --> 00:10:32,610
and what do you think about the solution

00:10:33,240 --> 00:10:38,500
can you tell me how does it work with

00:10:35,530 --> 00:10:40,900
inheritance like if some of the symbols

00:10:38,500 --> 00:10:45,490
you're importing also use other exported

00:10:40,900 --> 00:10:49,300
symbols what happens if the symbols that

00:10:45,490 --> 00:10:52,560
you import in turn use other exported

00:10:49,300 --> 00:10:52,560
symbols how does that work

00:11:04,470 --> 00:11:08,830
right so that module has its own import

00:11:07,510 --> 00:11:10,480
that module has its own importance and

00:11:08,830 --> 00:11:11,440
that has its own symbols and it doesn't

00:11:10,480 --> 00:11:14,910
even matter as for the checks that

00:11:11,440 --> 00:11:17,529
Google wants to do it's still per module

00:11:14,910 --> 00:11:20,110
you want to see what each module

00:11:17,529 --> 00:11:20,950
consumes if this module depends on

00:11:20,110 --> 00:11:22,450
another module

00:11:20,950 --> 00:11:26,650
great then you see what that module

00:11:22,450 --> 00:11:29,200
consumes it's still checking on a per

00:11:26,650 --> 00:11:30,820
module basis if you want to reports just

00:11:29,200 --> 00:11:34,350
do inheritance everything's gonna go to

00:11:30,820 --> 00:11:36,490
the root right but I guess some of the

00:11:34,350 --> 00:11:37,810
namespaces are going to be kind of

00:11:36,490 --> 00:11:39,400
meaningless like o'clock everybody's

00:11:37,810 --> 00:11:42,279
going to import clocks right o'clock

00:11:39,400 --> 00:11:45,820
yeah or USB or USB serial I mean but we

00:11:42,279 --> 00:11:48,370
need to start scoping somehow but at

00:11:45,820 --> 00:11:50,680
least like four o'clock not all the

00:11:48,370 --> 00:11:51,970
exported global not all the globally

00:11:50,680 --> 00:11:56,020
exported clock functions need to be

00:11:51,970 --> 00:11:59,820
exported right but that's the thing we

00:11:56,020 --> 00:11:59,820
want to start reducing the size

00:12:11,200 --> 00:12:17,920
I was just gonna say that and the

00:12:15,339 --> 00:12:20,769
nesting part can also be post-process by

00:12:17,920 --> 00:12:22,600
an external to tool as well like for

00:12:20,769 --> 00:12:23,709
example if a module imports a bunch of

00:12:22,600 --> 00:12:26,560
symbol but that depends on another

00:12:23,709 --> 00:12:27,850
module so then that report can be in it

00:12:26,560 --> 00:12:31,949
externally it doesn't have to be baked

00:12:27,850 --> 00:12:31,949
into the importing Michals

00:12:43,660 --> 00:12:48,639
can you go back one slide yeah sure so

00:12:47,170 --> 00:12:54,519
when you say out of export to namespace

00:12:48,639 --> 00:12:56,500
based on cable mod name is this for

00:12:54,519 --> 00:12:58,569
things that you're saying want to export

00:12:56,500 --> 00:13:00,399
to a namespace so take the USB core for

00:12:58,569 --> 00:13:02,800
example I'll have a function that says

00:13:00,399 --> 00:13:04,180
export symbol namespace and then you're

00:13:02,800 --> 00:13:05,709
saying you would automatic fill that in

00:13:04,180 --> 00:13:09,819
with USB core based on the cable mod

00:13:05,709 --> 00:13:11,410
name you don't have to add like the

00:13:09,819 --> 00:13:13,769
namespace to all of the exports but you

00:13:11,410 --> 00:13:16,750
just do it based on the module okay um I

00:13:13,769 --> 00:13:18,519
would like to not use that all the time

00:13:16,750 --> 00:13:21,579
because USB core is a module name

00:13:18,519 --> 00:13:24,040
instead of just USB yeah it might be

00:13:21,579 --> 00:13:25,690
nice to override that yeah I think it

00:13:24,040 --> 00:13:27,519
really depends on the granularity like

00:13:25,690 --> 00:13:29,500
because so much also really small and it

00:13:27,519 --> 00:13:31,569
probably doesn't make sense to like

00:13:29,500 --> 00:13:33,430
limit the scope of decibels to just a

00:13:31,569 --> 00:13:36,850
module name but you want a group go into

00:13:33,430 --> 00:13:38,319
a bigger I go fax for it symbols yeah it

00:13:36,850 --> 00:13:39,519
really depends so I think it's an

00:13:38,319 --> 00:13:44,579
optional thing that you can use but

00:13:39,519 --> 00:13:44,579
don't have to use our uniform

00:13:53,810 --> 00:14:00,440
both yeah so the patches modify mottos

00:13:57,710 --> 00:14:02,180
basically so I can repeat the question

00:14:00,440 --> 00:14:04,460
the question was whether I check for

00:14:02,180 --> 00:14:05,810
violations at low time or also bill time

00:14:04,460 --> 00:14:08,390
so the answer is pose

00:14:05,810 --> 00:14:10,580
so the patches contain modifications to

00:14:08,390 --> 00:14:11,960
my poster based food checks for each

00:14:10,580 --> 00:14:14,420
symbol to which names face it is

00:14:11,960 --> 00:14:16,070
exported or whether is exported to a

00:14:14,420 --> 00:14:18,260
namespace at all and then for all uses

00:14:16,070 --> 00:14:20,390
of that symbol whether they import the

00:14:18,260 --> 00:14:21,650
relevant namespace there's some

00:14:20,390 --> 00:14:24,500
discussion about whether it should be a

00:14:21,650 --> 00:14:26,780
warning or an error if you feel the

00:14:24,500 --> 00:14:28,190
import I'm also seeing an error at this

00:14:26,780 --> 00:14:29,390
point and I think that that has also

00:14:28,190 --> 00:14:42,800
been the upstream and feedback so far

00:14:29,390 --> 00:14:46,040
like if we enforce this is that coming

00:14:42,800 --> 00:14:48,440
after module dependencies like how if

00:14:46,040 --> 00:14:49,430
that's module that is exporting the

00:14:48,440 --> 00:14:51,980
namespace

00:14:49,430 --> 00:14:56,450
it hasn't been loaded yet but how is

00:14:51,980 --> 00:14:57,620
that handled so I mean the namespace is

00:14:56,450 --> 00:14:58,760
not exclusive to my chill like a

00:14:57,620 --> 00:15:00,620
namespace can be used by multiple

00:14:58,760 --> 00:15:02,930
modules right so all that what post us

00:15:00,620 --> 00:15:04,790
is parses all the symbols that are

00:15:02,930 --> 00:15:06,680
exported by a module and the sign is

00:15:04,790 --> 00:15:09,680
those symbols - yeah you said at runtime

00:15:06,680 --> 00:15:12,230
when you the model gets loaded you check

00:15:09,680 --> 00:15:13,520
all the imported namespaces but that

00:15:12,230 --> 00:15:16,480
depends on another module that might

00:15:13,520 --> 00:15:16,480
have not loaded yet

00:15:22,830 --> 00:15:31,440
right so you happens after the

00:15:24,900 --> 00:15:31,440
dependency now that doesn't change

00:15:31,900 --> 00:15:41,980
um hey Martin so I so this is this is

00:15:39,730 --> 00:15:45,100
really really good stuff I just had a

00:15:41,980 --> 00:15:47,830
side comment like one of the things

00:15:45,100 --> 00:15:49,510
about modules is you know you can you

00:15:47,830 --> 00:15:52,270
can try to partition it like this but

00:15:49,510 --> 00:15:54,580
you can't really control what is called

00:15:52,270 --> 00:15:56,620
into the kernel right after module is

00:15:54,580 --> 00:15:59,290
loaded so if somebody wanted to do you

00:15:56,620 --> 00:16:02,320
know do something like kale Sims look up

00:15:59,290 --> 00:16:03,339
and get the function pointer yeah it's

00:16:02,320 --> 00:16:04,690
actually something that came up as

00:16:03,339 --> 00:16:06,640
people would like to use this even for

00:16:04,690 --> 00:16:08,710
internal stuff right so this mechanism

00:16:06,640 --> 00:16:09,670
allows you to enforce it across modules

00:16:08,710 --> 00:16:11,380
but it would be nice if you could

00:16:09,670 --> 00:16:13,240
actually enforce it you know for in Khan

00:16:11,380 --> 00:16:14,260
used to which is something I haven't

00:16:13,240 --> 00:16:15,640
really looked at but it would be

00:16:14,260 --> 00:16:16,650
interesting to be able to do such a

00:16:15,640 --> 00:16:19,650
thing

00:16:16,650 --> 00:16:19,650
yeah

00:16:20,190 --> 00:16:25,900
so I'm just curious in generating these

00:16:23,950 --> 00:16:27,730
patches did you find many situations

00:16:25,900 --> 00:16:30,610
where there were you know drivers

00:16:27,730 --> 00:16:33,550
choosing mm you know symbols that they

00:16:30,610 --> 00:16:34,960
shouldn't be or is there like examples

00:16:33,550 --> 00:16:36,100
of violations that were could be

00:16:34,960 --> 00:16:38,680
corrected or something like that

00:16:36,100 --> 00:16:39,910
I mostly I used to use be subsystem

00:16:38,680 --> 00:16:41,830
which is you know pretty well it

00:16:39,910 --> 00:16:44,410
contains I know greg has told some

00:16:41,830 --> 00:16:46,450
stories about you know many cases where

00:16:44,410 --> 00:16:47,830
drivers were trying to use symbols that

00:16:46,450 --> 00:16:49,060
they shouldn't use or actually people

00:16:47,830 --> 00:16:50,290
trying to add symbols to export

00:16:49,060 --> 00:16:51,580
namespace that really shouldn't happen

00:16:50,290 --> 00:16:53,260
so I know such things has happened in

00:16:51,580 --> 00:16:56,620
the past which yes so I looked at this

00:16:53,260 --> 00:16:59,140
for a certain large SOC vendors driver 3

00:16:56,620 --> 00:17:01,510
and it was horrible

00:16:59,140 --> 00:17:02,980
they were exporting and then you see

00:17:01,510 --> 00:17:04,570
that when they try and push those

00:17:02,980 --> 00:17:07,089
drivers upstream and randomly try and

00:17:04,570 --> 00:17:09,880
export random symbols and that's what

00:17:07,089 --> 00:17:11,440
causes me to trigger this all it's like

00:17:09,880 --> 00:17:12,580
they shouldn't be doing that and this is

00:17:11,440 --> 00:17:19,470
a big hint that they shouldn't be doing

00:17:12,580 --> 00:17:22,480
that seconds left how are you Oh

00:17:19,470 --> 00:17:25,450
once this how do you start off here is

00:17:22,480 --> 00:17:27,190
this every subsystem is clean slate and

00:17:25,450 --> 00:17:30,730
everyone starts importing everything or

00:17:27,190 --> 00:17:31,990
do you automatically and import imported

00:17:30,730 --> 00:17:34,750
namespaces and then everyone starts

00:17:31,990 --> 00:17:36,790
cleaning up what's right now it's an

00:17:34,750 --> 00:17:37,540
incremental approach so we will keep the

00:17:36,790 --> 00:17:39,070
global namespace

00:17:37,540 --> 00:17:40,390
and if substance want to start

00:17:39,070 --> 00:17:41,830
converting they can simply you know

00:17:40,390 --> 00:17:45,340
start exporting to a namespace run a

00:17:41,830 --> 00:17:46,540
script and add the updated virus so it's

00:17:45,340 --> 00:17:49,060
really a matter of you know we can

00:17:46,540 --> 00:17:50,860
convert subsystem by subsystem over

00:17:49,060 --> 00:17:56,710
there's not really any intercept system

00:17:50,860 --> 00:17:59,100
dependencies thanks oh thank you sir

00:17:56,710 --> 00:17:59,100
anything

00:17:59,310 --> 00:18:02,640
[Applause]

00:18:04,820 --> 00:18:07,940
[Applause]

00:18:13,250 --> 00:18:19,129
hello my name is Suren Bagdasarian I

00:18:15,710 --> 00:18:21,559
work for Google and today I will be

00:18:19,129 --> 00:18:26,899
presenting psi monitor for memory

00:18:21,559 --> 00:18:30,519
pressure detection so currently in

00:18:26,899 --> 00:18:34,250
Android we use the impression signals to

00:18:30,519 --> 00:18:36,649
detect memory pressure however the

00:18:34,250 --> 00:18:38,960
Empress really measures reclaiming

00:18:36,649 --> 00:18:41,750
efficiency rather than what we want to

00:18:38,960 --> 00:18:44,809
measure which is how much the user

00:18:41,750 --> 00:18:48,110
experience is affected by memory

00:18:44,809 --> 00:18:50,120
contention so it has a number of other

00:18:48,110 --> 00:18:54,429
issues but this is a fundamental problem

00:18:50,120 --> 00:18:58,669
for us for for what we are trying to do

00:18:54,429 --> 00:19:01,250
so up to recently we didn't have any

00:18:58,669 --> 00:19:03,679
other mechanisms to do that but a recent

00:19:01,250 --> 00:19:07,700
patch that called psi which is precious

00:19:03,679 --> 00:19:11,720
tall information it was merged a couple

00:19:07,700 --> 00:19:15,590
weeks ago into the 420 by John's Rainier

00:19:11,720 --> 00:19:18,529
and what it does it measures amount of

00:19:15,590 --> 00:19:21,289
times that tasks are delayed as result

00:19:18,529 --> 00:19:26,210
of resource contention and resources in

00:19:21,289 --> 00:19:30,980
this cases can be memory i/o or CPU so

00:19:26,210 --> 00:19:33,440
it records a complete delay or stall the

00:19:30,980 --> 00:19:37,549
total stall time average and calculate

00:19:33,440 --> 00:19:40,730
averages over 10 60 and 300 seconds so

00:19:37,549 --> 00:19:43,669
psi allows to basically it records

00:19:40,730 --> 00:19:44,960
complete or partial stalls and I can

00:19:43,669 --> 00:19:48,370
talk a little bit more about what

00:19:44,960 --> 00:19:48,370
complete and partial stall means

00:19:48,700 --> 00:19:53,830
it's considering those calculations

00:19:51,340 --> 00:19:56,440
number of CPUs and number of non idle

00:19:53,830 --> 00:19:59,470
tasks the most important part for us is

00:19:56,440 --> 00:20:04,240
it represents a much more direct measure

00:19:59,470 --> 00:20:08,020
of how the user is affected by memory

00:20:04,240 --> 00:20:12,600
contention because it's directly

00:20:08,020 --> 00:20:12,600
measures of the delay time of the tasks

00:20:13,320 --> 00:20:20,830
so that's all great but why we cannot

00:20:17,410 --> 00:20:24,100
use vanilla psi implementation on

00:20:20,830 --> 00:20:26,560
Android so androids is usually runs on

00:20:24,100 --> 00:20:28,630
mobile systems which I have quite

00:20:26,560 --> 00:20:30,790
limited amount of memory relatively

00:20:28,630 --> 00:20:33,490
limited amount of memory and our

00:20:30,790 --> 00:20:35,350
applications and services are quite

00:20:33,490 --> 00:20:37,600
often unpredictable they have

00:20:35,350 --> 00:20:40,480
unpredictable and aggressive memory

00:20:37,600 --> 00:20:46,560
usage patterns so your memory usage

00:20:40,480 --> 00:20:50,560
might be growing too fast for averages

00:20:46,560 --> 00:20:53,470
to reflect that goals because averages

00:20:50,560 --> 00:20:56,020
as I said are over multiple seconds so

00:20:53,470 --> 00:20:58,840
in those multiple seconds your system

00:20:56,020 --> 00:21:04,450
might become unusable before you can do

00:20:58,840 --> 00:21:07,360
anything with it so to do is that we are

00:21:04,450 --> 00:21:09,610
working on a PSI monitor test set

00:21:07,360 --> 00:21:11,370
so it's heavily utilizes already

00:21:09,610 --> 00:21:17,400
existing psi machinery

00:21:11,370 --> 00:21:20,530
it's it monitors psi signal whenever

00:21:17,400 --> 00:21:23,140
system enters a stall state so normally

00:21:20,530 --> 00:21:27,820
it is not active it activates only when

00:21:23,140 --> 00:21:30,040
there's a stove being recorded the API

00:21:27,820 --> 00:21:33,670
is very simple to be unfresh API so you

00:21:30,040 --> 00:21:38,740
can use event is to wait for the events

00:21:33,670 --> 00:21:42,390
from the user space it supports multiple

00:21:38,740 --> 00:21:47,710
concurrent monitors for all PSI matrix

00:21:42,390 --> 00:21:50,410
and each each of those multiple monitors

00:21:47,710 --> 00:21:53,050
supports its own configurable thresholds

00:21:50,410 --> 00:21:57,960
and tracking window which are expressed

00:21:53,050 --> 00:21:57,960
in microseconds so it's in time units

00:21:58,530 --> 00:22:03,750
this chart shows basically the

00:22:01,860 --> 00:22:08,039
implementation of the psi monitor it's a

00:22:03,750 --> 00:22:10,620
simple sliding window you can see in the

00:22:08,039 --> 00:22:14,100
beginning that when there is no stall

00:22:10,620 --> 00:22:17,220
the blue line is just stall signal so

00:22:14,100 --> 00:22:20,309
when it's not growing the PSI monitor is

00:22:17,220 --> 00:22:23,370
dormant so it's not active as soon as it

00:22:20,309 --> 00:22:26,970
starts growing it activates and those

00:22:23,370 --> 00:22:31,169
vertical lines show where it checks psi

00:22:26,970 --> 00:22:33,000
grows and as soon as current psi grows

00:22:31,169 --> 00:22:36,299
goes over the threshold in basically

00:22:33,000 --> 00:22:39,679
will generate their unit and user space

00:22:36,299 --> 00:22:43,650
will be notified so a small

00:22:39,679 --> 00:22:45,990
simplifications that we use when install

00:22:43,650 --> 00:22:48,000
spans multiple windows we assume the

00:22:45,990 --> 00:22:52,470
linear growth in the previous window

00:22:48,000 --> 00:22:54,090
that allows to that allows us to have a

00:22:52,470 --> 00:22:55,970
simpler implementation where we don't

00:22:54,090 --> 00:22:59,130
need to remember all the intermediate

00:22:55,970 --> 00:23:02,400
points where we in the previous window

00:22:59,130 --> 00:23:06,630
where we measured the PSI signal and

00:23:02,400 --> 00:23:09,659
just approximate basically is the growth

00:23:06,630 --> 00:23:12,510
I have a patch set which implements is

00:23:09,659 --> 00:23:14,460
more strictly basically remembering all

00:23:12,510 --> 00:23:16,799
those intermediate steps but in testing

00:23:14,460 --> 00:23:18,390
I didn't see much difference between

00:23:16,799 --> 00:23:23,490
those so it seems to be a good

00:23:18,390 --> 00:23:27,299
approximation for at least our task and

00:23:23,490 --> 00:23:30,390
this last slide shows comparison between

00:23:27,299 --> 00:23:32,669
PSI mother and vm pressure during while

00:23:30,390 --> 00:23:35,159
we are running a memory stress test so

00:23:32,669 --> 00:23:40,409
on the bottoms there are several metrics

00:23:35,159 --> 00:23:42,900
that shows memory situation of this of

00:23:40,409 --> 00:23:44,970
our system and those spikes show where

00:23:42,900 --> 00:23:46,650
the memory pressure was so high that

00:23:44,970 --> 00:23:49,049
stress was killed

00:23:46,650 --> 00:23:53,190
that's why we have

00:23:49,049 --> 00:24:00,539
if our free memory spikes it goes up and

00:23:53,190 --> 00:24:03,090
on the charts on the upper chart I plot

00:24:00,539 --> 00:24:06,269
where the VM pressure events and psi

00:24:03,090 --> 00:24:08,850
vans were triggered and so on the bottom

00:24:06,269 --> 00:24:11,460
others that black line we have the air

00:24:08,850 --> 00:24:14,610
pressure events and concept of the PSI

00:24:11,460 --> 00:24:18,809
events and you can see that psi events

00:24:14,610 --> 00:24:21,739
show the points where memory pressure

00:24:18,809 --> 00:24:24,659
grows high and we have to kill something

00:24:21,739 --> 00:24:27,239
much better than VM pressure events

00:24:24,659 --> 00:24:30,119
which have a lot of false positives and

00:24:27,239 --> 00:24:32,309
it also triggers much less which means

00:24:30,119 --> 00:24:39,480
user space will not be woken up very

00:24:32,309 --> 00:24:40,640
often so that's yeah that's pretty much

00:24:39,480 --> 00:24:43,540
it so

00:24:40,640 --> 00:24:43,540
for discussion

00:24:46,860 --> 00:24:53,620
yeah are you planning to make these

00:24:49,299 --> 00:25:13,450
accessible to third-party apps or only

00:24:53,620 --> 00:25:19,150
to the system so I'm not sure yet if

00:25:13,450 --> 00:25:22,990
Android will provide any API to use them

00:25:19,150 --> 00:25:25,299
probably not directly because I see a

00:25:22,990 --> 00:25:26,230
silicon's policies and all that good

00:25:25,299 --> 00:25:28,929
stuff

00:25:26,230 --> 00:25:35,380
but we probably will will provide

00:25:28,929 --> 00:25:38,429
something too for applications to to

00:25:35,380 --> 00:25:41,730
have more visibility about system states

00:25:38,429 --> 00:25:45,299
we definitely plan to use it in the

00:25:41,730 --> 00:25:50,320
activity manager for example so that

00:25:45,299 --> 00:25:51,850
they are more or less we what this

00:25:50,320 --> 00:25:53,980
allows us to do is basically to

00:25:51,850 --> 00:25:56,169
coordinate between different parts of

00:25:53,980 --> 00:25:58,900
the system so theater manager can know

00:25:56,169 --> 00:26:02,200
where pressure is high so I don't need

00:25:58,900 --> 00:26:04,500
to respond a process that was killed by

00:26:02,200 --> 00:26:09,460
slow and regular and just a second ago

00:26:04,500 --> 00:26:15,039
so those kind of api's they are possible

00:26:09,460 --> 00:26:18,610
with this patch as for what that API

00:26:15,039 --> 00:26:21,529
will do will look like it's a bit early

00:26:18,610 --> 00:26:25,009
to tell

00:26:21,529 --> 00:26:25,009
okay thank you

00:26:33,150 --> 00:26:38,500
so you you're looking at em killing is

00:26:37,210 --> 00:26:40,420
there any it looks like you have an

00:26:38,500 --> 00:26:43,179
opportunity actually to detect systems

00:26:40,420 --> 00:26:45,370
and perhaps take some action that's

00:26:43,179 --> 00:26:47,820
short of killing a process maybe slowing

00:26:45,370 --> 00:26:47,820
it down somehow

00:26:50,170 --> 00:26:55,179
looks like you have an opportunity to

00:26:52,530 --> 00:26:57,100
measure processes and catch them earlier

00:26:55,179 --> 00:26:59,290
when they start to running into some

00:26:57,100 --> 00:27:01,450
pressure and take some other action

00:26:59,290 --> 00:27:10,320
besides killing them or killing the

00:27:01,450 --> 00:27:14,860
antagonist both of those threshold and

00:27:10,320 --> 00:27:17,740
sliding-window are basically time units

00:27:14,860 --> 00:27:21,460
so it's much more understandable and

00:27:17,740 --> 00:27:25,510
let's say if we try to assume VM

00:27:21,460 --> 00:27:28,830
pressures and basically it's it's

00:27:25,510 --> 00:27:33,190
difficult to find connection between how

00:27:28,830 --> 00:27:37,780
good your claim is or how efficient with

00:27:33,190 --> 00:27:40,419
how much time was lost by the for the

00:27:37,780 --> 00:27:42,400
users tasks in here we are operating in

00:27:40,419 --> 00:27:44,980
the time domain so it's much easier to

00:27:42,400 --> 00:27:46,780
assume so and you can have multiple

00:27:44,980 --> 00:27:50,049
monitor so you can have monitor at the

00:27:46,780 --> 00:27:52,419
lower threshold which will tell you okay

00:27:50,049 --> 00:27:54,850
we just started the memory pressures

00:27:52,419 --> 00:27:58,150
just started mounting so you can do some

00:27:54,850 --> 00:28:00,460
early actions and there will be also -

00:27:58,150 --> 00:28:02,590
we say okay we're critical level so we

00:28:00,460 --> 00:28:04,720
need to kill something yeah and just to

00:28:02,590 --> 00:28:07,290
add to that for example Android today

00:28:04,720 --> 00:28:09,730
the activity activity manager sends out

00:28:07,290 --> 00:28:12,580
notifications to applications for on

00:28:09,730 --> 00:28:15,100
trim memory calls where applications are

00:28:12,580 --> 00:28:16,960
supposed to volunteer and free up some

00:28:15,100 --> 00:28:20,049
memory those calls as far as I

00:28:16,960 --> 00:28:21,840
understand today happen based on how

00:28:20,049 --> 00:28:25,030
many cached background apps are

00:28:21,840 --> 00:28:26,590
something some thing like this which

00:28:25,030 --> 00:28:28,990
gives you a notification from the kernel

00:28:26,590 --> 00:28:30,640
itself can be used potentially to

00:28:28,990 --> 00:28:33,540
trigger those calls to the apps in order

00:28:30,640 --> 00:28:33,540
to free up some more memory

00:28:39,810 --> 00:28:44,910
you know we got four minutes I know

00:28:42,510 --> 00:28:47,730
there were some previous efforts to kind

00:28:44,910 --> 00:28:50,430
of move the low memory color out to user

00:28:47,730 --> 00:28:53,280
space that weren't I guess successful is

00:28:50,430 --> 00:28:56,040
the internal implementation how is this

00:28:53,280 --> 00:28:57,960
implementation doing relative I mean is

00:28:56,040 --> 00:29:03,060
there any sort of metrics of better or

00:28:57,960 --> 00:29:09,210
worse compared to kernel module compared

00:29:03,060 --> 00:29:11,670
to the current yeah so this test was I

00:29:09,210 --> 00:29:13,860
specifically this particular test I ran

00:29:11,670 --> 00:29:18,000
was in kernel and 1k because most of the

00:29:13,860 --> 00:29:20,790
Android devices to use so when whenever

00:29:18,000 --> 00:29:23,640
those tests this task is killed it's a

00:29:20,790 --> 00:29:26,790
in kernel encase killing I want to make

00:29:23,640 --> 00:29:31,940
sure that you know they use it switch to

00:29:26,790 --> 00:29:34,920
user space does not skews the results so

00:29:31,940 --> 00:29:37,080
that issue of course it's difficult to

00:29:34,920 --> 00:29:39,510
compete with in kernel LMK because it's

00:29:37,080 --> 00:29:41,700
inside the kernel you don't have to send

00:29:39,510 --> 00:29:45,570
to user space any signals and then send

00:29:41,700 --> 00:29:49,070
secure back to kernel so the round-trip

00:29:45,570 --> 00:29:52,500
is much shorter but there are also

00:29:49,070 --> 00:29:55,440
downsides of that the biggest downside

00:29:52,500 --> 00:29:58,200
is is that coordination between LMK in

00:29:55,440 --> 00:30:03,540
kernel and your system which is in zero

00:29:58,200 --> 00:30:05,640
space so up to now basically LMK was

00:30:03,540 --> 00:30:08,250
doing its own thing without coordinating

00:30:05,640 --> 00:30:10,560
anything with anybody so this gives us

00:30:08,250 --> 00:30:12,690
an opportunity to actually coordinate

00:30:10,560 --> 00:30:15,720
and user space different parts of the

00:30:12,690 --> 00:30:18,420
system so as I said for example if

00:30:15,720 --> 00:30:22,260
something is killed the other part is

00:30:18,420 --> 00:30:24,450
existing does not try to respond so

00:30:22,260 --> 00:30:26,730
Zehra absolute zero is upside of having

00:30:24,450 --> 00:30:29,580
it in users user space and we always

00:30:26,730 --> 00:30:31,230
think that it's worse doing this even

00:30:29,580 --> 00:30:33,510
though we take some ketones and

00:30:31,230 --> 00:30:36,480
performance because you cannot get

00:30:33,510 --> 00:30:38,460
around the fact that you need

00:30:36,480 --> 00:30:40,169
you know additional latency you

00:30:38,460 --> 00:30:44,630
introduce additional latency by having

00:30:40,169 --> 00:30:48,059
those making use in cyberspace thanks

00:30:44,630 --> 00:30:51,780
so just extending that question um so in

00:30:48,059 --> 00:30:53,549
terms of the latency for you know for

00:30:51,780 --> 00:30:54,929
the round-trip since this is getting

00:30:53,549 --> 00:30:57,299
handled and uses piece you know do you

00:30:54,929 --> 00:31:01,890
have some stats and whether can it keep

00:30:57,299 --> 00:31:04,350
up with you know certain spikes of

00:31:01,890 --> 00:31:06,780
memory pressure where is part of

00:31:04,350 --> 00:31:09,210
directly claim you really need the kilt

00:31:06,780 --> 00:31:11,460
to have a Curt really fast I was yeah

00:31:09,210 --> 00:31:15,870
the latency we were measuring when we

00:31:11,460 --> 00:31:19,470
were moving to Jesus pace L&K I did

00:31:15,870 --> 00:31:21,990
collect a lot of stats about the latency

00:31:19,470 --> 00:31:24,780
of receiving the signal from the kernel

00:31:21,990 --> 00:31:26,730
and and since CQ I have a number of

00:31:24,780 --> 00:31:31,350
caches in the kernel which improves that

00:31:26,730 --> 00:31:37,980
path also some some drivers actually

00:31:31,350 --> 00:31:39,330
were delaying sequel for example its if

00:31:37,980 --> 00:31:42,380
I remember correctly it was in the

00:31:39,330 --> 00:31:47,309
beginning of the year the delays are

00:31:42,380 --> 00:31:50,460
somewhere around tens of milliseconds in

00:31:47,309 --> 00:31:54,450
the case of memory contention as the

00:31:50,460 --> 00:31:56,630
user space module can wait for the to

00:31:54,450 --> 00:31:59,549
see the impact of a kill before it

00:31:56,630 --> 00:32:01,049
decides to do anything else in terms of

00:31:59,549 --> 00:32:04,679
other signals that it might receive

00:32:01,049 --> 00:32:09,390
subsequently you are talking about that

00:32:04,679 --> 00:32:11,780
those fixes for drivers know just the

00:32:09,390 --> 00:32:15,059
fact that you know once the kill is

00:32:11,780 --> 00:32:16,830
initiated you know the impact of the

00:32:15,059 --> 00:32:18,360
kill you know the memory that gets

00:32:16,830 --> 00:32:22,500
reclaimed as part of that you know does

00:32:18,360 --> 00:32:26,500
it take the complete okay so the

00:32:22,500 --> 00:32:33,490
question is how how fast replay

00:32:26,500 --> 00:32:35,169
cute processes yeah like userspace

00:32:33,490 --> 00:32:37,750
accounting for the entire memory that

00:32:35,169 --> 00:32:42,820
got released as part of the kill before

00:32:37,750 --> 00:32:46,290
it exon the subsequent triggers okay I'm

00:32:42,820 --> 00:32:49,400
gonna see just this continues on yeah

00:32:46,290 --> 00:32:49,400
[Music]

00:32:50,560 --> 00:32:57,499
[Applause]

00:32:59,909 --> 00:33:05,470
hey my name is Christian and I want to

00:33:03,789 --> 00:33:09,700
talk about dynamically allocated binary

00:33:05,470 --> 00:33:11,200
devices so constantly I've been starting

00:33:09,700 --> 00:33:13,299
I think there's a patch settle so now

00:33:11,200 --> 00:33:15,789
floating around on L KML

00:33:13,299 --> 00:33:17,799
we've been discussing using binary

00:33:15,789 --> 00:33:21,360
devices and different IPC namespaces

00:33:17,799 --> 00:33:23,169
specifically in sewing containers

00:33:21,360 --> 00:33:25,270
interesting to be a bunch of people

00:33:23,169 --> 00:33:28,480
interested in this and there are a few

00:33:25,270 --> 00:33:30,520
limitations we cool few limitations we

00:33:28,480 --> 00:33:33,580
had it never works on my laptop that's

00:33:30,520 --> 00:33:36,100
why there are a few limitations we had

00:33:33,580 --> 00:33:39,730
and that we tried to address and at our

00:33:36,100 --> 00:33:41,950
for example help out with so first of

00:33:39,730 --> 00:33:43,690
all miners not available as a kernel

00:33:41,950 --> 00:33:45,610
module and there's a bunch of

00:33:43,690 --> 00:33:48,780
distributions that really don't want to

00:33:45,610 --> 00:33:51,100
set config binder to yes by default

00:33:48,780 --> 00:33:54,549
they'd much rather have it be loadable

00:33:51,100 --> 00:33:57,580
as a module so we had a patch set for

00:33:54,549 --> 00:33:59,049
that or originally but there were a

00:33:57,580 --> 00:34:01,179
bunch of problems that actually relate

00:33:59,049 --> 00:34:04,150
to export symbol because binder was

00:34:01,179 --> 00:34:06,370
using a functions that we really didn't

00:34:04,150 --> 00:34:09,700
like that were used in the binder driver

00:34:06,370 --> 00:34:12,159
and so these have been removed but it's

00:34:09,700 --> 00:34:14,440
still outstanding making it possible to

00:34:12,159 --> 00:34:15,790
come said yeah say basically that binder

00:34:14,440 --> 00:34:18,159
is available as a kernel module that

00:34:15,790 --> 00:34:20,619
would be helpful and and there are two

00:34:18,159 --> 00:34:22,690
other problems the first one is there is

00:34:20,619 --> 00:34:24,970
currently no way to do dynamic device

00:34:22,690 --> 00:34:28,990
allocation so meaning you actually I

00:34:24,970 --> 00:34:30,460
think have to said a string in the

00:34:28,990 --> 00:34:32,800
kernel config saying these are the

00:34:30,460 --> 00:34:35,169
binder devices that I want and then

00:34:32,800 --> 00:34:36,520
the binder driver will chunk it into

00:34:35,169 --> 00:34:38,350
individual strings and then create the

00:34:36,520 --> 00:34:39,760
devices based on this but that's fixed

00:34:38,350 --> 00:34:42,070
like you cannot changed his number as

00:34:39,760 --> 00:34:43,840
far as I understand right now so that's

00:34:42,070 --> 00:34:46,990
a big limitation obviously because we

00:34:43,840 --> 00:34:55,570
might not know at compile time how many

00:34:46,990 --> 00:34:57,400
minor devices we need at the same way

00:34:55,570 --> 00:34:59,080
the same way you don't necessarily know

00:34:57,400 --> 00:35:04,720
how many loop devices you need

00:34:59,080 --> 00:35:06,790
I mean binders different the loop

00:35:04,720 --> 00:35:11,260
devices in that this is a fixed system

00:35:06,790 --> 00:35:12,790
resource and your used binder only in a

00:35:11,260 --> 00:35:14,500
limited type of system I mean I

00:35:12,790 --> 00:35:16,540
understand you want to make it a more

00:35:14,500 --> 00:35:19,480
generic IPC right is that the goal oh

00:35:16,540 --> 00:35:21,460
yeah sure I mean let's see what's the I

00:35:19,480 --> 00:35:24,070
mean the binder is a very specific

00:35:21,460 --> 00:35:26,470
Android thing today do you want to make

00:35:24,070 --> 00:35:28,630
it a more generic yeah well basically

00:35:26,470 --> 00:35:30,760
yeah it's so for example for these for

00:35:28,630 --> 00:35:31,690
these container use cases it's there are

00:35:30,760 --> 00:35:33,670
a bunch of people out there that one

00:35:31,690 --> 00:35:35,290
around Android inside of a container or

00:35:33,670 --> 00:35:38,350
they're actually around Android inside

00:35:35,290 --> 00:35:42,460
of a container on a generic like amd64

00:35:38,350 --> 00:35:44,020
system or whatever and so sorry yeah I

00:35:42,460 --> 00:35:45,400
know that's the world we live in its I'm

00:35:44,020 --> 00:35:46,600
not saying that it's the greatest world

00:35:45,400 --> 00:35:47,920
ever but yet it's just this is

00:35:46,600 --> 00:35:49,270
definitely happening like there are

00:35:47,920 --> 00:35:52,030
solutions out there that allow you to do

00:35:49,270 --> 00:35:53,500
just that and I mean to some extent it's

00:35:52,030 --> 00:35:57,400
similar to what Chrome OS is doing right

00:35:53,500 --> 00:36:00,550
I don't know what Chrome OS I don't know

00:35:57,400 --> 00:36:03,369
how they do so and the third and the

00:36:00,550 --> 00:36:05,680
third part is essentially that you have

00:36:03,369 --> 00:36:08,200
no prepare a PC name so you have no

00:36:05,680 --> 00:36:10,180
they're basically all of those IPC

00:36:08,200 --> 00:36:13,210
devices that you can use always belong

00:36:10,180 --> 00:36:15,460
to the initial IPC namespace which is

00:36:13,210 --> 00:36:17,440
different from other IPC mechanisms for

00:36:15,460 --> 00:36:20,950
example another example is def M because

00:36:17,440 --> 00:36:23,230
M Q essentially and Def Jam em they both

00:36:20,950 --> 00:36:25,330
are mountable per IPC namespace or

00:36:23,230 --> 00:36:27,369
they're separate file systems and they

00:36:25,330 --> 00:36:29,109
have a different IPC namespace attached

00:36:27,369 --> 00:36:31,210
to the devices so that's the whole idea

00:36:29,109 --> 00:36:34,109
so this is the problem space and I think

00:36:31,210 --> 00:36:34,109
I need to hurry up a little

00:36:35,060 --> 00:36:42,030
so basically there is three there are

00:36:38,130 --> 00:36:43,350
two solutions I'd say roughly so if the

00:36:42,030 --> 00:36:45,870
first one is the patch that we're seeing

00:36:43,350 --> 00:36:47,370
right now it's you attaching a new IPC

00:36:45,870 --> 00:36:49,710
namespace and open so imagine you

00:36:47,370 --> 00:36:51,270
handing off a binder device to a process

00:36:49,710 --> 00:36:53,460
that runs in a different IPC namespace

00:36:51,270 --> 00:36:56,130
you call open on it and then in you IPC

00:36:53,460 --> 00:36:57,690
namespace gets attached to it which

00:36:56,130 --> 00:36:58,710
sounds reasonable as the first approach

00:36:57,690 --> 00:37:01,380
the problem is that this is

00:36:58,710 --> 00:37:03,390
unprecedented in the kernel as far as I

00:37:01,380 --> 00:37:04,920
know there is nothing inside the kernel

00:37:03,390 --> 00:37:06,720
that change this namespace space and

00:37:04,920 --> 00:37:08,820
open and I've just come up with a weird

00:37:06,720 --> 00:37:10,830
exploit but basically there is one right

00:37:08,820 --> 00:37:13,260
here if you send a binary FD into a

00:37:10,830 --> 00:37:15,240
different namespace IPC namespace and

00:37:13,260 --> 00:37:17,190
you reopen it through proc bit FD binder

00:37:15,240 --> 00:37:17,880
you're now switching the namespace it's

00:37:17,190 --> 00:37:20,640
the least in the current implementation

00:37:17,880 --> 00:37:26,160
yeah exactly and it's like I I really

00:37:20,640 --> 00:37:27,660
don't want this the second one is this

00:37:26,160 --> 00:37:29,190
is related to the dynamic binary

00:37:27,660 --> 00:37:31,230
allocation problem you could do it

00:37:29,190 --> 00:37:32,760
similar to what you do with loop control

00:37:31,230 --> 00:37:34,950
you call an open on a loop current lock

00:37:32,760 --> 00:37:37,230
what cut it back in the days you call an

00:37:34,950 --> 00:37:38,670
open on binder loop control and you

00:37:37,230 --> 00:37:40,380
dynamically allocate in your binder

00:37:38,670 --> 00:37:42,750
device and then you can use you def to

00:37:40,380 --> 00:37:47,370
rename the binder device to whatever you

00:37:42,750 --> 00:37:49,590
want basically and I think one solution

00:37:47,370 --> 00:37:52,020
that I would like and I would like to

00:37:49,590 --> 00:37:55,650
hear input in this is if you sort of do

00:37:52,020 --> 00:37:57,720
it like MQ and DEF chadman you do a

00:37:55,650 --> 00:38:01,110
binary fascist entually it's mountable

00:37:57,720 --> 00:38:04,080
in different IPC namespaces and when you

00:38:01,110 --> 00:38:05,610
mount it and you you just have a binder

00:38:04,080 --> 00:38:08,040
loop control device but no binder

00:38:05,610 --> 00:38:09,750
devices and then a process inside of a

00:38:08,040 --> 00:38:12,630
different IPC namespace conscious call

00:38:09,750 --> 00:38:15,660
open on the device and the advantage is

00:38:12,630 --> 00:38:17,580
that the IPC namespace is fixed to the

00:38:15,660 --> 00:38:21,530
back to this mount it doesn't change

00:38:17,580 --> 00:38:21,530
it's actually attached to the device

00:38:23,030 --> 00:38:31,010
oh okay it's crazy but you'll like it

00:38:26,990 --> 00:38:33,080
that's that's good this is it's gonna

00:38:31,010 --> 00:38:36,500
dish add additional work to systems

00:38:33,080 --> 00:38:37,490
today right because I thought about

00:38:36,500 --> 00:38:39,200
backward compatible

00:38:37,490 --> 00:38:40,910
sorry it's not backwards well that's

00:38:39,200 --> 00:38:42,710
what I did we I've totally been thinking

00:38:40,910 --> 00:38:43,850
about this and I'm not saying have

00:38:42,710 --> 00:38:45,380
solved this problem okay

00:38:43,850 --> 00:38:46,850
but one of the one a few ideas that are

00:38:45,380 --> 00:38:49,250
basically you make it a config option at

00:38:46,850 --> 00:38:51,140
first you say this is opt-in like if you

00:38:49,250 --> 00:38:52,730
want to like have a want to have binary

00:38:51,140 --> 00:38:55,340
fest and yes if you don't want to have

00:38:52,730 --> 00:38:58,040
binary SS then totally up to you then we

00:38:55,340 --> 00:39:01,670
just set up basically set it up like it

00:38:58,040 --> 00:39:03,860
used to be before and yeah and this

00:39:01,670 --> 00:39:05,480
gives you a long time to actually switch

00:39:03,860 --> 00:39:08,000
because Todd was making it very clear

00:39:05,480 --> 00:39:10,010
any solution that we come up with it

00:39:08,000 --> 00:39:14,600
must be backwards compatible yeah yeah

00:39:10,010 --> 00:39:17,590
what do you think of this device use

00:39:14,600 --> 00:39:17,590
case I'm fine with it

00:39:35,339 --> 00:39:40,329
hardware binder versus what is the

00:39:37,569 --> 00:39:42,220
normal binder and based on that there

00:39:40,329 --> 00:39:44,470
are there are there's there's policy

00:39:42,220 --> 00:39:46,690
news space which decides what processes

00:39:44,470 --> 00:39:48,520
can do with those nodes if we're

00:39:46,690 --> 00:39:52,750
dynamically creating those nodes how

00:39:48,520 --> 00:39:54,490
does that work so you need some yes file

00:39:52,750 --> 00:39:57,190
system access so you write a selection

00:39:54,490 --> 00:39:59,740
rule name yes but how does userspace

00:39:57,190 --> 00:40:01,720
know which one is which well if you're

00:39:59,740 --> 00:40:02,980
dynamically creating them sorry what so

00:40:01,720 --> 00:40:04,420
you need some sort of capability

00:40:02,980 --> 00:40:19,750
checkers well it's user space within

00:40:04,420 --> 00:40:21,670
that container Thanks oh and by the way

00:40:19,750 --> 00:40:31,030
I'm really shitty here's I'm sorry so

00:40:21,670 --> 00:40:32,559
you need to speak a lot some one thing

00:40:31,030 --> 00:40:34,990
that came up and one of the original pet

00:40:32,559 --> 00:40:37,510
sets was whether we could also use IPC

00:40:34,990 --> 00:40:39,490
namespaces to basically have the

00:40:37,510 --> 00:40:41,710
individual devices like we could use IPC

00:40:39,490 --> 00:40:43,869
names faces for you know binder or by a

00:40:41,710 --> 00:40:45,190
vendor binder because that's also kind

00:40:43,869 --> 00:40:47,619
of like there right now three separate

00:40:45,190 --> 00:40:49,900
devices but I think it's not possible

00:40:47,619 --> 00:40:52,020
for a process to be part of multiple I

00:40:49,900 --> 00:40:55,900
perceive me as faceless that's correct

00:40:52,020 --> 00:40:57,910
with this solution yeah oh I think it

00:40:55,900 --> 00:41:00,369
actually is so you basically use you you

00:40:57,910 --> 00:41:02,260
what you want is for example a container

00:41:00,369 --> 00:41:05,530
to still see services on the host right

00:41:02,260 --> 00:41:07,089
or in a different IPC namespace yeah I

00:41:05,530 --> 00:41:08,589
mean it's that way in Android well yeah

00:41:07,089 --> 00:41:10,089
yeah so what I would do in this

00:41:08,589 --> 00:41:11,680
situation is basically you could bind

00:41:10,089 --> 00:41:14,140
mount the device node from a different

00:41:11,680 --> 00:41:16,420
IP c-- mount into the namespace into the

00:41:14,140 --> 00:41:19,240
different IPC namespace and the thing is

00:41:16,420 --> 00:41:21,220
this works in contrast to the open

00:41:19,240 --> 00:41:23,079
solution is because the namespace is

00:41:21,220 --> 00:41:27,309
attached to the actual device node and

00:41:23,079 --> 00:41:29,859
not not doesn't get switched on open but

00:41:27,309 --> 00:41:31,630
if you do this if you do an open you can

00:41:29,859 --> 00:41:33,790
pass a file descriptor off to some other

00:41:31,630 --> 00:41:36,549
namespace across the socket and

00:41:33,790 --> 00:41:38,860
everything will just work right and so

00:41:36,549 --> 00:41:40,660
what I think you should be it's

00:41:38,860 --> 00:41:42,370
solve that problem exactly that's yet

00:41:40,660 --> 00:41:43,990
either bind mounted device note in there

00:41:42,370 --> 00:41:46,630
so the process can just open the device

00:41:43,990 --> 00:41:47,980
note before it starts exactly but it's

00:41:46,630 --> 00:41:48,370
not it doesn't switch like that's my

00:41:47,980 --> 00:41:50,170
hole

00:41:48,370 --> 00:41:52,570
so my point is essentially I want to

00:41:50,170 --> 00:41:54,310
make very very sure that at the IPC

00:41:52,570 --> 00:41:56,620
namespace or whatever label is attached

00:41:54,310 --> 00:41:58,780
to the actual K object basically or to

00:41:56,620 --> 00:42:00,640
the to the device node essentially such

00:41:58,780 --> 00:42:02,410
that it you cannot change it user space

00:42:00,640 --> 00:42:04,660
should not be able to switch namespaces

00:42:02,410 --> 00:42:08,500
with it like with open Cisco that's

00:42:04,660 --> 00:42:10,810
crazy so will this solve your issue of

00:42:08,500 --> 00:42:14,940
containers of your only bound to this

00:42:10,810 --> 00:42:14,940
per container yeah a new one and then

00:42:15,390 --> 00:42:20,320
but you're not it's not an IPC namespace

00:42:18,040 --> 00:42:22,480
it's it's a mountain named space it's

00:42:20,320 --> 00:42:25,420
well it's it's mountable per IPC

00:42:22,480 --> 00:42:26,830
namespace so it's attached to an IPC

00:42:25,420 --> 00:42:28,660
namespace it's not it doesn't have

00:42:26,830 --> 00:42:29,410
anything to do with a mouth namespace as

00:42:28,660 --> 00:42:32,320
far as I know

00:42:29,410 --> 00:42:35,980
so MQ is doing XD exact same thing so

00:42:32,320 --> 00:42:37,510
mmq will refuse well mq is mountable in

00:42:35,980 --> 00:42:39,580
the same namespace again but it's going

00:42:37,510 --> 00:42:41,380
to be has the same IPC namespace so it

00:42:39,580 --> 00:42:45,360
sees the same devices it's the same with

00:42:41,380 --> 00:42:50,020
the DEF pts mounts you mount them again

00:42:45,360 --> 00:42:52,360
yes I know I know we learned more I've

00:42:50,020 --> 00:42:54,970
seen so many box and I figure it's crazy

00:42:52,360 --> 00:42:56,770
yeah but it's the gen the idea is kind

00:42:54,970 --> 00:42:58,270
of similar you switch in a new IPC

00:42:56,770 --> 00:43:00,880
namespace you mount it and then it's

00:42:58,270 --> 00:43:03,040
your new instance you could even if you

00:43:00,880 --> 00:43:04,510
want to be super crazy and the

00:43:03,040 --> 00:43:06,430
privileges are the same between two

00:43:04,510 --> 00:43:09,090
different IPC namespaces you could also

00:43:06,430 --> 00:43:12,850
just bind mount the whole directory of

00:43:09,090 --> 00:43:14,620
of a different binder FS instance into

00:43:12,850 --> 00:43:17,200
the different other IPC namespace then

00:43:14,620 --> 00:43:19,780
you even share the bind up control

00:43:17,200 --> 00:43:22,180
device name services and then all the

00:43:19,780 --> 00:43:25,990
namespaces share can share the services

00:43:22,180 --> 00:43:29,620
that you are running ok so your last

00:43:25,990 --> 00:43:31,270
option dedicated major number you don't

00:43:29,620 --> 00:43:33,340
need it's everything can be dynamic

00:43:31,270 --> 00:43:35,560
because once going off namespaces and

00:43:33,340 --> 00:43:38,350
names and you'll be fine the only

00:43:35,560 --> 00:43:40,150
dedicated number okay I don't think you

00:43:38,350 --> 00:43:42,910
need do you want a dedicated number for

00:43:40,150 --> 00:43:44,410
your no because your binder FS will

00:43:42,910 --> 00:43:47,170
create the binder control node on

00:43:44,410 --> 00:43:49,090
automatically so you don't care ok so I

00:43:47,170 --> 00:43:50,910
really don't care it's just a I don't

00:43:49,090 --> 00:43:54,779
yeah I wasn't sure ok

00:43:50,910 --> 00:44:00,000
four minutes four minutes a one-minute

00:43:54,779 --> 00:44:02,910
four minutes or can you say something

00:44:00,000 --> 00:44:04,500
about the the use case why Android in

00:44:02,910 --> 00:44:06,660
containers Elizabeth alright so

00:44:04,500 --> 00:44:09,809
basically basically one of the ideas is

00:44:06,660 --> 00:44:11,670
that you I think it's a streaming

00:44:09,809 --> 00:44:13,529
solution so basically you run around

00:44:11,670 --> 00:44:15,779
Android in a container and then you

00:44:13,529 --> 00:44:18,420
abstract the way that you stream down

00:44:15,779 --> 00:44:20,609
the end by graphics and so on to

00:44:18,420 --> 00:44:22,559
handheld devices that's basically the

00:44:20,609 --> 00:44:25,470
idea and I think there is a bunch of

00:44:22,559 --> 00:44:27,930
different people working on this right

00:44:25,470 --> 00:44:30,900
so I'm not the one working on this so I

00:44:27,930 --> 00:44:34,289
buy knowledge about this is quickly

00:44:30,900 --> 00:44:41,789
converges to zero but I know a bit about

00:44:34,289 --> 00:44:42,930
namespaces so yeah yeah so there are

00:44:41,789 --> 00:44:44,279
commercial solutions that they're

00:44:42,930 --> 00:44:49,740
actually using this kind of thing

00:44:44,279 --> 00:44:53,460
Hach runs a game server on Qualcomm arm

00:44:49,740 --> 00:45:00,450
servers hallway is actually running a

00:44:53,460 --> 00:45:07,799
similar thing now there's a set of

00:45:00,450 --> 00:45:10,039
patches that I think this is much better

00:45:07,799 --> 00:45:10,039
way

00:45:11,740 --> 00:45:17,260
yeah so it's um I work on web krishnan

00:45:14,609 --> 00:45:19,000
there's only so many so much detail we

00:45:17,260 --> 00:45:20,440
can give public a but we are working

00:45:19,000 --> 00:45:21,970
with those different companies I

00:45:20,440 --> 00:45:26,109
couldn't even if I wanted to do be

00:45:21,970 --> 00:45:27,520
honest we like we do have very very

00:45:26,109 --> 00:45:30,130
similar use cases and we've been working

00:45:27,520 --> 00:45:32,980
with some of those similar thing we like

00:45:30,130 --> 00:45:35,740
use Qualcomm servers and we run 200

00:45:32,980 --> 00:45:37,810
vendor containers on those machines each

00:45:35,740 --> 00:45:40,240
of them having to bind our devices what

00:45:37,810 --> 00:45:43,420
we do right now is we actually use the

00:45:40,240 --> 00:45:46,119
binder devices option on the command

00:45:43,420 --> 00:45:48,400
line to create I think about 250 or

00:45:46,119 --> 00:45:49,990
whatever devices hard-coded and then the

00:45:48,400 --> 00:45:51,820
container manager will bind mount those

00:45:49,990 --> 00:45:54,070
as their binder in the different

00:45:51,820 --> 00:45:56,020
containers that kind of works but it's

00:45:54,070 --> 00:45:57,550
very wasteful because it's not allocated

00:45:56,020 --> 00:46:00,640
dynamically there's no way to clean

00:45:57,550 --> 00:46:02,200
stuff up it's put in it's got a bunch of

00:46:00,640 --> 00:46:03,700
columns and we would much rather the

00:46:02,200 --> 00:46:05,950
containers themselves be able to bounce

00:46:03,700 --> 00:46:08,140
back needle FS then allocate those by

00:46:05,950 --> 00:46:10,540
the devices on demand because we don't

00:46:08,140 --> 00:46:13,000
know an android used to just use one

00:46:10,540 --> 00:46:14,770
kind of device that's been changed it

00:46:13,000 --> 00:46:17,830
might change again we don't know how

00:46:14,770 --> 00:46:21,910
many we need to create already and we

00:46:17,830 --> 00:46:23,260
don't say you know like we don't as far

00:46:21,910 --> 00:46:24,369
as the kernel manager we don't know what

00:46:23,260 --> 00:46:25,599
the container is gonna be doing we don't

00:46:24,369 --> 00:46:27,070
know how many kind of the bus it's gonna

00:46:25,599 --> 00:46:29,050
need so it's much better if it can

00:46:27,070 --> 00:46:31,599
allocate its own thing it's also not

00:46:29,050 --> 00:46:33,910
nice that they all ship if effect

00:46:31,599 --> 00:46:36,550
basically they communicate via the same

00:46:33,910 --> 00:46:38,980
IPC namespace which I which is not wise

00:46:36,550 --> 00:46:40,359
from a security from a security

00:46:38,980 --> 00:46:42,070
perspective I mean it would be much

00:46:40,359 --> 00:46:44,560
better if you're already running in a

00:46:42,070 --> 00:46:46,750
separate IPC namespace by default so

00:46:44,560 --> 00:46:49,660
please also use devices that have the

00:46:46,750 --> 00:46:51,700
same IPC namespace I just wanted to make

00:46:49,660 --> 00:46:54,280
a quick comment I think it's a good idea

00:46:51,700 --> 00:46:57,490
to have dynamic binder creation I think

00:46:54,280 --> 00:46:59,349
that's a good idea by itself as assuming

00:46:57,490 --> 00:47:01,359
we can solve whatever problems arise

00:46:59,349 --> 00:47:02,890
from that but I wanted to make this

00:47:01,359 --> 00:47:05,830
statement from the point of view of

00:47:02,890 --> 00:47:07,030
Android security containers are not

00:47:05,830 --> 00:47:10,710
security boundaries

00:47:07,030 --> 00:47:13,210
they're just accounting boundaries so

00:47:10,710 --> 00:47:17,589
whoever's trying to run Android in

00:47:13,210 --> 00:47:20,950
containers that can never be compliant

00:47:17,589 --> 00:47:22,920
as far as our tests are concerned so

00:47:20,950 --> 00:47:25,680
just be aware of that I

00:47:22,920 --> 00:47:28,020
I said I cannot say anything to the use

00:47:25,680 --> 00:47:30,630
case I'm probably pretty sure that these

00:47:28,020 --> 00:47:39,030
people that actually do this don't care

00:47:30,630 --> 00:47:41,579
about this that maybe so yeah exactly

00:47:39,030 --> 00:47:43,380
one sick one too well you can have some

00:47:41,579 --> 00:47:45,750
security boundaries with username spaces

00:47:43,380 --> 00:48:04,559
but that gets you yeah I know what

00:47:45,750 --> 00:48:09,839
you're saying Cheers as part of the

00:48:04,559 --> 00:48:12,480
Power Team and this is to present one of

00:48:09,839 --> 00:48:14,369
the tools that we use between Harma to

00:48:12,480 --> 00:48:16,200
evaluate patches a modification and the

00:48:14,369 --> 00:48:18,329
goal is to try to collect feedbacks in

00:48:16,200 --> 00:48:21,030
order to understand how we can make it

00:48:18,329 --> 00:48:23,069
more useful for the community these this

00:48:21,030 --> 00:48:27,030
tool so the problem is essentially is

00:48:23,069 --> 00:48:29,849
that when we push changes to to get it

00:48:27,030 --> 00:48:31,380
we do quite a lot we spent quite a lot

00:48:29,849 --> 00:48:33,210
of time reviewing them and check that

00:48:31,380 --> 00:48:35,940
the code is fine and whatever but

00:48:33,210 --> 00:48:38,280
usually probably Google can run some

00:48:35,940 --> 00:48:39,930
verification in there CI loop but at

00:48:38,280 --> 00:48:43,619
least the results are not exposed

00:48:39,930 --> 00:48:45,630
outside and there are not really results

00:48:43,619 --> 00:48:49,079
that report power performance trade-off

00:48:45,630 --> 00:48:51,059
for the changes that are proposed and of

00:48:49,079 --> 00:48:53,270
course when when we are looking a

00:48:51,059 --> 00:48:55,650
contribution that effects some of the

00:48:53,270 --> 00:48:57,180
some of the power and performance frame

00:48:55,650 --> 00:48:58,589
or like the scheduler or power

00:48:57,180 --> 00:49:00,480
management framework so power R and

00:48:58,589 --> 00:49:02,460
whatever we would really like to know

00:49:00,480 --> 00:49:04,710
what is the impact but on performance is

00:49:02,460 --> 00:49:06,480
empower when we apply those changes

00:49:04,710 --> 00:49:08,520
possibly before the pilot changes but

00:49:06,480 --> 00:49:10,470
even if if the changes are applied to

00:49:08,520 --> 00:49:12,480
try to I likes possible defects or

00:49:10,470 --> 00:49:15,210
things that we can try to improve in the

00:49:12,480 --> 00:49:16,920
future for target so in general would be

00:49:15,210 --> 00:49:18,540
really nice to have a tool which is

00:49:16,920 --> 00:49:21,180
freely available for people that just

00:49:18,540 --> 00:49:22,110
push their own modification you can try

00:49:21,180 --> 00:49:26,520
to get some kind of

00:49:22,110 --> 00:49:28,290
what they are the heme pots and and also

00:49:26,520 --> 00:49:29,910
another problem is we have to identify a

00:49:28,290 --> 00:49:32,220
set of reasonable benchmarks that

00:49:29,910 --> 00:49:34,470
everybody agree that are usable as a

00:49:32,220 --> 00:49:37,620
reference to verify the quality of of

00:49:34,470 --> 00:49:39,900
pages that we send so one of the

00:49:37,620 --> 00:49:43,020
possible solution is these tools that we

00:49:39,900 --> 00:49:45,000
deal with in harp the idea is that you

00:49:43,020 --> 00:49:47,310
have a set of changes that you want

00:49:45,000 --> 00:49:49,020
apply on top of our caramel so you can

00:49:47,310 --> 00:49:50,550
list at the Chez one of the pages that

00:49:49,020 --> 00:49:53,850
you want to test that you have a

00:49:50,550 --> 00:49:58,500
reference colonel and these descri will

00:49:53,850 --> 00:50:01,200
take care to compile and flesh a target

00:49:58,500 --> 00:50:03,090
device which each one of those cannon

00:50:01,200 --> 00:50:06,000
listed here and for every kernel that

00:50:03,090 --> 00:50:08,100
you compile and put the device then we

00:50:06,000 --> 00:50:09,570
end over the device to work with

00:50:08,100 --> 00:50:11,910
automation which is another standard

00:50:09,570 --> 00:50:14,610
tool that use a reference agenda so

00:50:11,910 --> 00:50:17,100
these reference agenda provides very

00:50:14,610 --> 00:50:19,410
well-defined set of use cases and

00:50:17,100 --> 00:50:21,690
benchmark real applications be executed

00:50:19,410 --> 00:50:23,880
on the target device and collect result

00:50:21,690 --> 00:50:26,490
in a predefined ad format all the

00:50:23,880 --> 00:50:28,860
results and Robin are in a folder this

00:50:26,490 --> 00:50:30,510
is done for every single camera page we

00:50:28,860 --> 00:50:32,550
wanna test and then there is a final

00:50:30,510 --> 00:50:35,840
tool that basically generates a report

00:50:32,550 --> 00:50:38,010
that allows us to easily compare the

00:50:35,840 --> 00:50:40,740
different candles in terms of the

00:50:38,010 --> 00:50:43,500
different matrix that we we collect so I

00:50:40,740 --> 00:50:47,700
have an example here and if you can if I

00:50:43,500 --> 00:50:51,690
can open it just to give you quick view

00:50:47,700 --> 00:50:53,550
of what we get so the output can be

00:50:51,690 --> 00:50:56,760
different formats but basically let's

00:50:53,550 --> 00:51:00,090
assume it's like an HTML an HTML

00:50:56,760 --> 00:51:04,170
document and for example in this case we

00:51:00,090 --> 00:51:06,240
are comparing two different kernels the

00:51:04,170 --> 00:51:09,180
specific case is a is a page set

00:51:06,240 --> 00:51:11,370
containing the most recent es series of

00:51:09,180 --> 00:51:14,610
pages with respect to the standard

00:51:11,370 --> 00:51:16,380
kernel and you get a predefined set of

00:51:14,610 --> 00:51:18,720
output formats so it make it really easy

00:51:16,380 --> 00:51:20,640
for people that knows this format to see

00:51:18,720 --> 00:51:23,430
what are the the effects you get what

00:51:20,640 --> 00:51:25,770
numbers or plots to evaluate in this

00:51:23,430 --> 00:51:28,980
case is like a performance matrix so the

00:51:25,770 --> 00:51:31,560
time required to generate a frame you

00:51:28,980 --> 00:51:34,000
notice also that we run many iterations

00:51:31,560 --> 00:51:36,130
so by default is like 38 duration for

00:51:34,000 --> 00:51:38,020
test and we compare at the results for

00:51:36,130 --> 00:51:41,110
all those iterations were some kind of

00:51:38,020 --> 00:51:43,300
statistical significant results and we

00:51:41,110 --> 00:51:45,190
do this for many different workloads

00:51:43,300 --> 00:51:46,690
that have been defined to be interesting

00:51:45,190 --> 00:51:48,580
we have different kind of plots that

00:51:46,690 --> 00:51:50,560
allow us to better highlights behavior

00:51:48,580 --> 00:51:53,440
like in this case is always the frame

00:51:50,560 --> 00:51:55,390
generation time but we can see that

00:51:53,440 --> 00:51:57,280
there are p havior that are maintained

00:51:55,390 --> 00:52:00,130
but we go faster with one camera with

00:51:57,280 --> 00:52:01,660
respect to another and and so on for all

00:52:00,130 --> 00:52:03,700
the different workloads and we have also

00:52:01,660 --> 00:52:06,370
resuming results at the end where we see

00:52:03,700 --> 00:52:08,680
what are the different like energy or

00:52:06,370 --> 00:52:11,380
performance impact in percentage that we

00:52:08,680 --> 00:52:13,390
have comparing the baseline Canet with

00:52:11,380 --> 00:52:14,710
respect to the page that our proposal

00:52:13,390 --> 00:52:18,880
and this can be done for multiple

00:52:14,710 --> 00:52:24,580
different kml so if I go back to my

00:52:18,880 --> 00:52:27,100
presentation which is this one we have a

00:52:24,580 --> 00:52:30,880
pretty simple energy measurement setup

00:52:27,100 --> 00:52:33,310
use an ACME cape borda all this set up

00:52:30,880 --> 00:52:35,020
is really hundred and hundred and fifty

00:52:33,310 --> 00:52:37,300
dollars it can be it's really designed

00:52:35,020 --> 00:52:40,600
to be using on desk for for single

00:52:37,300 --> 00:52:42,250
developers and some reference board so

00:52:40,600 --> 00:52:44,350
you can really collect the power and

00:52:42,250 --> 00:52:47,560
performance measurements out of these

00:52:44,350 --> 00:52:49,090
out of this tool the problem is that

00:52:47,560 --> 00:52:50,740
right now this is just a set of

00:52:49,090 --> 00:52:52,690
guidelines for us so we have the tools

00:52:50,740 --> 00:52:55,240
they are there and we can teach people

00:52:52,690 --> 00:52:56,890
how to use them we would like to

00:52:55,240 --> 00:52:59,200
understand if it's possible somehow to

00:52:56,890 --> 00:53:01,600
have some kind of automation going on on

00:52:59,200 --> 00:53:03,250
top of these on top of tools like those

00:53:01,600 --> 00:53:04,890
ones so these are some of the discussion

00:53:03,250 --> 00:53:10,050
point I would like to collect feedbacks

00:53:04,890 --> 00:53:15,010
today about these tools so the first is

00:53:10,050 --> 00:53:18,720
okay do you think we can make this by

00:53:15,010 --> 00:53:21,960
integrating our provider

00:53:18,720 --> 00:53:23,790
no more easy way or which kind of

00:53:21,960 --> 00:53:26,280
devices we should consider as a

00:53:23,790 --> 00:53:30,089
reference we usually use a iq9 6d or

00:53:26,280 --> 00:53:33,599
pixel devices some other solution is

00:53:30,089 --> 00:53:36,119
possible and again sometimes it's the

00:53:33,599 --> 00:53:37,770
set of benchmarks to be used at some

00:53:36,119 --> 00:53:39,390
people care more about some work laws

00:53:37,770 --> 00:53:41,549
respect to other we would like to know

00:53:39,390 --> 00:53:43,829
if we have to put attention into

00:53:41,549 --> 00:53:45,599
integrating other workloads I think that

00:53:43,829 --> 00:53:48,720
it's pretty important to distinguish

00:53:45,599 --> 00:53:51,000
workers that targets interactivity like

00:53:48,720 --> 00:53:52,980
junk bench or poor energy efficiencies

00:53:51,000 --> 00:53:55,230
or evaluating like how much we are

00:53:52,980 --> 00:53:57,390
energy efficient in claiming back out

00:53:55,230 --> 00:53:59,819
your videos or just hitting the home

00:53:57,390 --> 00:54:02,280
screen and performance benchmark PC

00:53:59,819 --> 00:54:07,109
marking Geekbench maybe other options

00:54:02,280 --> 00:54:09,230
are that can be served off so here

00:54:07,109 --> 00:54:13,160
basically is there any feedback about

00:54:09,230 --> 00:54:13,160
this kind of framework

00:54:17,579 --> 00:54:23,920
so we are using part of this solution in

00:54:21,069 --> 00:54:28,569
our form management working group so not

00:54:23,920 --> 00:54:30,519
the compilation and we are using merely

00:54:28,569 --> 00:54:32,559
so the workload automation at the end

00:54:30,519 --> 00:54:34,119
the agenda to make some power

00:54:32,559 --> 00:54:36,760
consumption measurement and Elisabeth

00:54:34,119 --> 00:54:40,150
processing but all the previous part we

00:54:36,760 --> 00:54:42,130
are using our CIE loop and so on and how

00:54:40,150 --> 00:54:45,430
do you get how do you trigger this kind

00:54:42,130 --> 00:54:47,289
of test so each time someone push a new

00:54:45,430 --> 00:54:50,740
committee in is dev branch we are

00:54:47,289 --> 00:54:54,700
creating a new branch which may allow

00:54:50,740 --> 00:54:56,650
ongoing dev which trigger automatically

00:54:54,700 --> 00:55:00,190
a new compilation so these are git

00:54:56,650 --> 00:55:02,140
repositories that we get and once the

00:55:00,190 --> 00:55:05,289
build is finished we trigger a lava job

00:55:02,140 --> 00:55:10,599
by than the workload automation and the

00:55:05,289 --> 00:55:14,619
release a post-processing stuff so we

00:55:10,599 --> 00:55:16,750
are not compared with we are not doing

00:55:14,619 --> 00:55:18,760
this final graphic comparison but all

00:55:16,750 --> 00:55:21,539
the result all available yes and some

00:55:18,760 --> 00:55:21,539
web interface

00:55:26,700 --> 00:55:32,680
yeah I guess just some feedback would be

00:55:30,480 --> 00:55:36,089
do you measure like different power

00:55:32,680 --> 00:55:39,069
states - like for example like suspend

00:55:36,089 --> 00:55:42,009
because the ice next slide I saw really

00:55:39,069 --> 00:55:52,059
just like benchmarks yeah so the idea is

00:55:42,009 --> 00:55:55,390
to run and we measured at the battery

00:55:52,059 --> 00:55:58,390
power later so we measure the overall

00:55:55,390 --> 00:56:00,400
system energy consumption for a for a

00:55:58,390 --> 00:56:02,589
device we don't really care we have

00:56:00,400 --> 00:56:04,269
other kind of test that digs down into

00:56:02,589 --> 00:56:06,130
the details of different contribution

00:56:04,269 --> 00:56:07,990
but in this specific case for this tool

00:56:06,130 --> 00:56:10,690
what we wanna see is that in the main

00:56:07,990 --> 00:56:12,369
domains of interactive workloads energy

00:56:10,690 --> 00:56:14,109
efficient workers and performance

00:56:12,369 --> 00:56:17,740
workers we don't do progressions or

00:56:14,109 --> 00:56:19,450
notable difference spending I guess

00:56:17,740 --> 00:56:22,329
these are all just active workloads and

00:56:19,450 --> 00:56:25,480
nothing like you know your bottom power

00:56:22,329 --> 00:56:28,380
of suspend basically in your screen off

00:56:25,480 --> 00:56:28,380
mode suspend

00:56:29,440 --> 00:56:34,040
weed workload automation you have some

00:56:31,880 --> 00:56:36,530
use case which which is called the idle

00:56:34,040 --> 00:56:39,860
use case where you can set screen of a

00:56:36,530 --> 00:56:42,200
screen on for example and there is no

00:56:39,860 --> 00:56:47,330
support for suspend to wrap variable yet

00:56:42,200 --> 00:56:49,100
but we are looking at that so do you

00:56:47,330 --> 00:56:51,410
think you can interesting to have more

00:56:49,100 --> 00:56:52,790
detailed energy measure sometimes they

00:56:51,410 --> 00:56:56,330
put the concern from people is that they

00:56:52,790 --> 00:56:58,850
don't want to see real measurements from

00:56:56,330 --> 00:57:01,400
a target board especially if you post a

00:56:58,850 --> 00:57:03,710
contribution on get it where you work

00:57:01,400 --> 00:57:05,630
you test them on one specific device may

00:57:03,710 --> 00:57:07,310
be an internal device you don't want to

00:57:05,630 --> 00:57:09,410
disclose real numbers that's actually

00:57:07,310 --> 00:57:12,770
one of the concerns that we collected so

00:57:09,410 --> 00:57:15,250
far so then you have to keep analyzing

00:57:12,770 --> 00:57:15,250
results

00:57:18,970 --> 00:57:27,050
how difficult is it to integrate new

00:57:21,740 --> 00:57:29,320
devices or new workloads yes we have an

00:57:27,050 --> 00:57:31,730
abstraction where you have to provide

00:57:29,320 --> 00:57:34,120
basically at this level you have to

00:57:31,730 --> 00:57:36,800
provide few scripts of bash scripts that

00:57:34,120 --> 00:57:39,290
tells exactly how to build an image for

00:57:36,800 --> 00:57:41,420
one specific device and provided you

00:57:39,290 --> 00:57:43,220
have the compilation products for for

00:57:41,420 --> 00:57:45,710
that device how to flash them on that

00:57:43,220 --> 00:57:47,630
device by reunion device it's just a

00:57:45,710 --> 00:57:49,310
bash script so the obstruction is there

00:57:47,630 --> 00:57:50,900
in the engine is just pulling these

00:57:49,310 --> 00:57:53,600
scripts and provided you know how to

00:57:50,900 --> 00:57:58,970
script in bash flashing all the devices

00:57:53,600 --> 00:58:01,400
should be reasonably simple so one

00:57:58,970 --> 00:58:02,570
question I this all looks really cool in

00:58:01,400 --> 00:58:04,760
some of the work that I've done with

00:58:02,570 --> 00:58:06,620
workload automation one of the gotchas I

00:58:04,760 --> 00:58:09,110
see is quite often the tests aren't

00:58:06,620 --> 00:58:10,790
really publicly available so things like

00:58:09,110 --> 00:58:13,370
Jake badge isn't something that you can

00:58:10,790 --> 00:58:17,480
just easily find and you know it's in

00:58:13,370 --> 00:58:19,280
there SP now okay that's good so yes but

00:58:17,480 --> 00:58:20,780
I was trying to see I know Steve Michael

00:58:19,280 --> 00:58:22,100
a couple years back had gone through

00:58:20,780 --> 00:58:24,170
some efforts trying to create kind of a

00:58:22,100 --> 00:58:28,150
more open set of tests has there been

00:58:24,170 --> 00:58:28,150
any effort to try to do that as well

00:58:28,900 --> 00:58:33,230
these things are they bored with across

00:58:31,610 --> 00:58:34,970
time and these now what it is right now

00:58:33,230 --> 00:58:36,260
but actually we are using pieces that

00:58:34,970 --> 00:58:36,790
was already there we are actually using

00:58:36,260 --> 00:58:38,380
what

00:58:36,790 --> 00:58:40,330
automation with all the things that he

00:58:38,380 --> 00:58:42,190
provides the only thing is that like we

00:58:40,330 --> 00:58:43,690
want to try to standardize things I

00:58:42,190 --> 00:58:46,060
define which workers you have

00:58:43,690 --> 00:58:47,800
potentially to run and provide results

00:58:46,060 --> 00:58:49,510
in a standardized form in such a way

00:58:47,800 --> 00:58:51,760
that everybody that knows more or less

00:58:49,510 --> 00:58:54,910
this language let's say can easily see

00:58:51,760 --> 00:58:57,100
if a batch if some kind of benefit or

00:58:54,910 --> 00:58:58,780
not performance

00:58:57,100 --> 00:59:01,060
I just reproducing them if you don't

00:58:58,780 --> 00:59:02,860
have access to those benchmarks it's the

00:59:01,060 --> 00:59:05,110
concern I guess and maybe that's not a

00:59:02,860 --> 00:59:06,610
big issue for most then yeah well in

00:59:05,110 --> 00:59:08,950
principle it would be nice if you can

00:59:06,610 --> 00:59:11,590
just post things on Gerrit and somehow

00:59:08,950 --> 00:59:14,410
within Google a machine or maybe they'll

00:59:11,590 --> 00:59:15,820
in our approach is also working just

00:59:14,410 --> 00:59:17,290
transparently there is a set of

00:59:15,820 --> 00:59:18,910
predefined devices where you can call

00:59:17,290 --> 00:59:20,440
that power performance results and you

00:59:18,910 --> 00:59:21,990
know you have the report there you don't

00:59:20,440 --> 00:59:25,320
have to install anything at that point

00:59:21,990 --> 00:59:25,320
four minutes

00:59:33,800 --> 00:59:38,369
so you are using only one single and

00:59:37,080 --> 00:59:41,550
gender to run everything

00:59:38,369 --> 00:59:44,490
once you have one in gender where you

00:59:41,550 --> 00:59:46,619
are running all the tests yeah so there

00:59:44,490 --> 00:59:51,330
is one reference agenda that we use for

00:59:46,619 --> 00:59:54,960
scheduler related things whatever you

00:59:51,330 --> 00:59:57,599
want so it's one boot and you're running

00:59:54,960 --> 00:59:59,820
all the tests in one single synchron's

00:59:57,599 --> 01:00:01,440
have you think about rebooting the bot

00:59:59,820 --> 01:00:03,240
because we have discovered some in

01:00:01,440 --> 01:00:06,330
interaction I mean if you are running

01:00:03,240 --> 01:00:09,690
for example some the lhamo test and with

01:00:06,330 --> 01:00:11,790
some junk bench on idle or idle test you

01:00:09,690 --> 01:00:14,310
can see some impact of the Vellamo test

01:00:11,790 --> 01:00:15,930
in the either and junk bench result so

01:00:14,310 --> 01:00:18,210
yeah maybe that would be good to be able

01:00:15,930 --> 01:00:22,619
to reboot between each single yeah

01:00:18,210 --> 01:00:24,150
that's an option of W we have these

01:00:22,619 --> 01:00:26,400
options that all can feel good every

01:00:24,150 --> 01:00:28,140
time I don't think we're a good at least

01:00:26,400 --> 01:00:29,730
not between the iteration of the same

01:00:28,140 --> 01:00:32,099
test maybe between different as the

01:00:29,730 --> 01:00:36,030
result but is eventually one option to

01:00:32,099 --> 01:00:38,040
be harder and actually yeah the good

01:00:36,030 --> 01:00:39,990
point is that in general testing pages

01:00:38,040 --> 01:00:42,030
is always if everybody comes up with all

01:00:39,990 --> 01:00:43,740
its own recipe you have to spend time

01:00:42,030 --> 01:00:45,420
try to understand how to fix things and

01:00:43,740 --> 01:00:47,130
make them working there should be

01:00:45,420 --> 01:00:48,510
something that is a connect solution

01:00:47,130 --> 01:00:50,849
available somewhere you can just cruise

01:00:48,510 --> 01:00:54,740
purchased and see the comparison that

01:00:50,849 --> 01:00:54,740
would be really very very useful

01:01:17,510 --> 01:01:24,889
[Applause]

01:01:33,170 --> 01:01:40,020
hi I'm Paula I'm part of dipendra

01:01:36,930 --> 01:01:43,770
penalty Daniel Allison burgers also

01:01:40,020 --> 01:01:45,270
possible the Android kernel team we've

01:01:43,770 --> 01:01:47,849
been asked to work on the problem of

01:01:45,270 --> 01:01:49,890
updates making updates smoother this

01:01:47,849 --> 01:01:53,160
presentation presentation we'll both be

01:01:49,890 --> 01:01:56,809
about that there's specific problem we

01:01:53,160 --> 01:01:59,069
were looking at me move forward a slight

01:01:56,809 --> 01:02:00,720
we have we've had the system of baby

01:01:59,069 --> 01:02:03,690
updates since I keep forgetting I think

01:02:00,720 --> 01:02:05,700
his end doesn't really matter

01:02:03,690 --> 01:02:07,799
whereby we put down as as you probably

01:02:05,700 --> 01:02:10,980
all know we have it in B slots for

01:02:07,799 --> 01:02:13,410
system and and vendor and boots put down

01:02:10,980 --> 01:02:16,410
the new ones next to the old ones reboot

01:02:13,410 --> 01:02:18,480
off the new ones and if we get all the

01:02:16,410 --> 01:02:20,099
way for boot completes we mark the new

01:02:18,480 --> 01:02:22,170
slaughters it's good and then we can

01:02:20,099 --> 01:02:24,240
boot off and you slot from then on and

01:02:22,170 --> 01:02:26,250
if it fails three times typically three

01:02:24,240 --> 01:02:28,349
times always three times normally then

01:02:26,250 --> 01:02:30,750
we um roll back and go back to the old

01:02:28,349 --> 01:02:33,420
one and that works pretty well but the

01:02:30,750 --> 01:02:37,410
problem is once the new partitions that

01:02:33,420 --> 01:02:38,940
modifying user data and then we were if

01:02:37,410 --> 01:02:40,920
there's a crash after that point and we

01:02:38,940 --> 01:02:43,829
roll back we're using the old system

01:02:40,920 --> 01:02:46,079
vendor boot image with the new user date

01:02:43,829 --> 01:02:47,339
always for the halfway house new user

01:02:46,079 --> 01:02:50,849
data which is probably even slightly

01:02:47,339 --> 01:02:52,200
worse and that is not a supported

01:02:50,849 --> 01:02:56,730
situation there's no reason why it

01:02:52,200 --> 01:02:59,460
should work so basically we need some

01:02:56,730 --> 01:03:01,170
form of way of rolling back user data

01:02:59,460 --> 01:03:03,140
I mean clearly a B user data makes no

01:03:01,170 --> 01:03:05,430
sense at all that would be stupid

01:03:03,140 --> 01:03:06,720
so what's needed is some form of check

01:03:05,430 --> 01:03:08,210
pointing and by the way we tend to use

01:03:06,720 --> 01:03:11,280
check pointing and snapshots

01:03:08,210 --> 01:03:12,870
interchangeably forgive us for that

01:03:11,280 --> 01:03:16,560
that means the same thing as far as

01:03:12,870 --> 01:03:19,800
we're concerned okay so there are two

01:03:16,560 --> 01:03:21,150
basic approaches to this problem if the

01:03:19,800 --> 01:03:22,410
file system supports me the fastest

01:03:21,150 --> 01:03:24,540
thing you have on user data supports

01:03:22,410 --> 01:03:26,130
checkpoints or snapshots then you're

01:03:24,540 --> 01:03:27,750
pretty much home and dry there's a few

01:03:26,130 --> 01:03:30,750
at least from a kernel point of view

01:03:27,750 --> 01:03:35,100
there's some API issues but that's not

01:03:30,750 --> 01:03:36,330
actually our department so the trouble

01:03:35,100 --> 01:03:37,470
is none of the file systems we tend to

01:03:36,330 --> 01:03:39,360
use and user day to actually support

01:03:37,470 --> 01:03:41,370
checkpoints so I did support checkpoints

01:03:39,360 --> 01:03:44,420
but first here's Daniel to talk about

01:03:41,370 --> 01:03:44,420
how we fixed that

01:03:53,840 --> 01:04:01,320
so I worked on adding a check pointing

01:03:57,780 --> 01:04:05,640
into F two FS the flash friendly file

01:04:01,320 --> 01:04:07,200
system so for those of you that aren't

01:04:05,640 --> 01:04:10,980
too familiar with the internal

01:04:07,200 --> 01:04:14,370
structures I put a little diagram of the

01:04:10,980 --> 01:04:18,900
basics on disk structure and there is a

01:04:14,370 --> 01:04:22,860
nice checkpointing section and the way

01:04:18,900 --> 01:04:25,020
that F 2 of s works is it this period

01:04:22,860 --> 01:04:27,660
will be updating that checkpoint which

01:04:25,020 --> 01:04:29,430
indexes into like what parts of the

01:04:27,660 --> 01:04:33,300
other metadata are currently relevant

01:04:29,430 --> 01:04:36,180
and the general gist of the feature is

01:04:33,300 --> 01:04:40,230
that we stop generating new checkpoints

01:04:36,180 --> 01:04:41,760
for some period of time and the base is

01:04:40,230 --> 01:04:45,000
currently like controlled as like a

01:04:41,760 --> 01:04:48,480
mount option then you would remount and

01:04:45,000 --> 01:04:52,080
resume checkpointing and the end result

01:04:48,480 --> 01:04:54,930
of that is that anything that you do if

01:04:52,080 --> 01:04:58,380
you happen to like unmount or crash or

01:04:54,930 --> 01:05:02,070
anything in between sort of mounting

01:04:58,380 --> 01:05:04,200
with that option and remapping to turn

01:05:02,070 --> 01:05:09,030
that option off you would effectively

01:05:04,200 --> 01:05:11,580
not have any of those changes persist so

01:05:09,030 --> 01:05:20,700
the patches for this have already gone

01:05:11,580 --> 01:05:23,190
in as of 4 for 20 and the s biggest

01:05:20,700 --> 01:05:27,690
performance change currently is just in

01:05:23,190 --> 01:05:30,120
the mounting itself so in order to keep

01:05:27,690 --> 01:05:32,610
some of the guarantees that we need to

01:05:30,120 --> 01:05:35,880
be running smoothly we need to do a

01:05:32,610 --> 01:05:41,580
certain amount of garbage collection up

01:05:35,880 --> 01:05:44,400
front because without without having

01:05:41,580 --> 01:05:46,350
access to checkpointing there is only so

01:05:44,400 --> 01:05:51,010
much garbage collection that we can do

01:05:46,350 --> 01:05:54,320
once this feature is turned on

01:05:51,010 --> 01:05:56,060
so as long as we have done the amount of

01:05:54,320 --> 01:05:58,610
garbage collection we need to upfront to

01:05:56,060 --> 01:06:02,240
again run as long as we need you in this

01:05:58,610 --> 01:06:04,220
node without having any major like any

01:06:02,240 --> 01:06:07,270
like real performance impact but her

01:06:04,220 --> 01:06:07,270
running as we normally would

01:06:13,140 --> 01:06:18,079
as any questions about that part

01:06:28,310 --> 01:06:35,330
okay so that deals with the problem

01:06:30,750 --> 01:06:38,550
pretty thoroughly when we have 4 F 2 FS

01:06:35,330 --> 01:06:41,760
unfortunately we don't specify the file

01:06:38,550 --> 01:06:44,960
system with Android I believe the

01:06:41,760 --> 01:06:48,360
majority of devices still use ext4

01:06:44,960 --> 01:06:50,190
that's true and that's not going to

01:06:48,360 --> 01:06:52,140
change anytime soon and no maybe other

01:06:50,190 --> 01:06:54,780
file systems out there too so we need a

01:06:52,140 --> 01:06:57,590
system that will work in the file system

01:06:54,780 --> 01:07:00,180
does not itself support checkpointing

01:06:57,590 --> 01:07:02,580
just before we go down with that well

01:07:00,180 --> 01:07:03,870
that actually did mean at that point

01:07:02,580 --> 01:07:05,280
there's two things you can do you can go

01:07:03,870 --> 01:07:07,440
above the file system and look at using

01:07:05,280 --> 01:07:08,670
something like overlay FS or you can go

01:07:07,440 --> 01:07:11,520
below the file system and work at the

01:07:08,670 --> 01:07:14,130
block layer we have only way to the

01:07:11,520 --> 01:07:17,310
overlay FS is promising and is actually

01:07:14,130 --> 01:07:20,160
some interesting work I was what to my

01:07:17,310 --> 01:07:22,890
attention which might make overlay FS

01:07:20,160 --> 01:07:24,480
useful in the future at this point of

01:07:22,890 --> 01:07:28,610
time overlay FS does not play well with

01:07:24,480 --> 01:07:33,840
SELinux so it's not that suitable for

01:07:28,610 --> 01:07:37,080
Android solution so the the decision was

01:07:33,840 --> 01:07:38,400
made to work at the block level so the

01:07:37,080 --> 01:07:40,380
obvious question of the block level is

01:07:38,400 --> 01:07:44,340
why not use DM snap DM snap exists it

01:07:40,380 --> 01:07:46,320
works it's great the snapshots and it

01:07:44,340 --> 01:07:46,830
requires an external volume so there's

01:07:46,320 --> 01:07:48,210
your answer

01:07:46,830 --> 01:07:51,240
there's no external volume and androids

01:07:48,210 --> 01:07:55,020
nowhere we could put one DM snaps it

01:07:51,240 --> 01:07:57,210
seems to be dead in the water but we

01:07:55,020 --> 01:08:00,480
were thinking about this and we realized

01:07:57,210 --> 01:08:03,050
that if we knew where the empty space

01:08:00,480 --> 01:08:05,370
was on the unused space was on user data

01:08:03,050 --> 01:08:09,420
we could find some way of using that to

01:08:05,370 --> 01:08:10,980
store the snapshots so what we did was

01:08:09,420 --> 01:08:13,770
we came up with a new driver which I'm

01:08:10,980 --> 01:08:16,950
calling DM valve name is provisional

01:08:13,770 --> 01:08:18,690
data center back up on lights

01:08:16,950 --> 01:08:20,100
Oh sorry there was one thing I want to

01:08:18,690 --> 01:08:21,630
bring up well I'm trying to upstream

01:08:20,100 --> 01:08:24,600
diem Bao I've got some suggestions from

01:08:21,630 --> 01:08:26,310
the lithium snap maintainer z-- one of

01:08:24,600 --> 01:08:30,840
the ideas they had was to create a file

01:08:26,310 --> 01:08:32,730
on user data before you reboots I should

01:08:30,840 --> 01:08:34,560
know but boys that snapshotting and then

01:08:32,730 --> 01:08:36,360
extracts the using fine map to extract

01:08:34,560 --> 01:08:40,170
the blocks from that the location of

01:08:36,360 --> 01:08:41,820
blocks in that file and then you and

01:08:40,170 --> 01:08:43,440
then use DM linear to use that device

01:08:41,820 --> 01:08:45,450
that file as a device which you could

01:08:43,440 --> 01:08:49,500
then access below the filesystem as a

01:08:45,450 --> 01:08:51,390
storage via DM snap that would that

01:08:49,500 --> 01:08:53,250
would work I'm confident it would work

01:08:51,390 --> 01:08:55,920
but it would only give you half the

01:08:53,250 --> 01:08:56,940
available space for storage because it

01:08:55,920 --> 01:08:58,620
because that's what it would do

01:08:56,940 --> 01:09:04,860
you're backing up to it you've lost half

01:08:58,620 --> 01:09:07,950
the space so I don't think that works

01:09:04,860 --> 01:09:09,900
for us spaces freeing up more use of

01:09:07,950 --> 01:09:11,790
data to take an update it's not a good

01:09:09,900 --> 01:09:15,960
idea I enjoyed the only one as much as

01:09:11,790 --> 01:09:17,730
little as we have to so I the idea was

01:09:15,960 --> 01:09:20,730
we dynamically detect so I developed

01:09:17,730 --> 01:09:22,410
this device whose idea is use the three

01:09:20,730 --> 01:09:24,300
blocks on the on the driver as the

01:09:22,410 --> 01:09:26,360
storage space so first of all we

01:09:24,300 --> 01:09:28,530
identify the three blocks which we do by

01:09:26,360 --> 01:09:30,210
running the trim on the filesystem which

01:09:28,530 --> 01:09:33,540
issued trims through the DM layer which

01:09:30,210 --> 01:09:35,520
we which we capture and then we

01:09:33,540 --> 01:09:37,170
basically all fuse the writes we look at

01:09:35,520 --> 01:09:38,790
what they're lighting over if it's

01:09:37,170 --> 01:09:43,230
original data we make sure we back it up

01:09:38,790 --> 01:09:44,640
into one of those please free blocks and

01:09:43,230 --> 01:09:48,000
then of course we keep a log of that so

01:09:44,640 --> 01:09:49,890
that if we want to go back we can this

01:09:48,000 --> 01:09:51,960
means that the forward path is very

01:09:49,890 --> 01:09:53,760
clean we've only written over the three

01:09:51,960 --> 01:09:56,190
areas so if we've got to go forwards we

01:09:53,760 --> 01:09:57,540
simply we simply stop doing it it's like

01:09:56,190 --> 01:10:02,360
we simply stop writing anything else

01:09:57,540 --> 01:10:04,410
down and given that's the 99% case I

01:10:02,360 --> 01:10:05,610
update works that should be all we have

01:10:04,410 --> 01:10:07,920
to do

01:10:05,610 --> 01:10:09,570
but it's possible from the log and the

01:10:07,920 --> 01:10:15,510
blocks and the free data to roll back

01:10:09,570 --> 01:10:16,619
after a reboot if you have to it's

01:10:15,510 --> 01:10:19,880
efficient it uses all the space

01:10:16,619 --> 01:10:24,000
available no no problems there

01:10:19,880 --> 01:10:33,270
is it worked so that's what we're trying

01:10:24,000 --> 01:10:35,219
to do questions how much share extra

01:10:33,270 --> 01:10:40,190
free space do you require to be able to

01:10:35,219 --> 01:10:43,409
do checkpointing on update so both

01:10:40,190 --> 01:10:47,670
systems are as efficient as you could

01:10:43,409 --> 01:10:49,800
expect them to be as in if you if you

01:10:47,670 --> 01:10:52,320
create a new file there's no difference

01:10:49,800 --> 01:10:54,179
if you open rise 100 megabytes of a file

01:10:52,320 --> 01:10:56,100
we have to keep a copy of the original

01:10:54,179 --> 01:10:57,780
data either with Daniel on my solution

01:10:56,100 --> 01:10:59,730
so it's a hundred megabytes of space

01:10:57,780 --> 01:11:04,770
needed for that operation basically

01:10:59,730 --> 01:11:07,170
overbites is one for one new files 3 ok

01:11:04,770 --> 01:11:08,880
and like if I change like one byte with

01:11:07,170 --> 01:11:10,800
a whatever you basically like saving a

01:11:08,880 --> 01:11:13,560
page or a block or what what's the

01:11:10,800 --> 01:11:28,409
granularity so the block solution oddly

01:11:13,560 --> 01:11:33,170
enough is a block pretty much the way

01:11:28,409 --> 01:11:36,840
that F 12s would be working normally so

01:11:33,170 --> 01:11:39,179
we end up all the times with you have to

01:11:36,840 --> 01:11:42,960
have as it tries to droop all the rights

01:11:39,179 --> 01:11:47,850
together so things can end up moving as

01:11:42,960 --> 01:11:49,889
you go so all of that continued work

01:11:47,850 --> 01:11:52,290
continues to work as it would be apart

01:11:49,889 --> 01:11:54,449
from it not being allowed to write into

01:11:52,290 --> 01:11:57,409
the blocks that it needs for the

01:11:54,449 --> 01:11:57,409
previous checkpoint

01:12:01,090 --> 01:12:07,550
I've gone so I recently added snapshot

01:12:04,580 --> 01:12:09,140
support two kernels ago to the SME three

01:12:07,550 --> 01:12:12,920
sips driver which file system support

01:12:09,140 --> 01:12:14,960
snapshots today I mean other than mine

01:12:12,920 --> 01:12:17,570
other than SMB 3 but I cheat because

01:12:14,960 --> 01:12:19,100
every NASA device supports it so I'm

01:12:17,570 --> 01:12:30,380
just I'm not having to do the hard work

01:12:19,100 --> 01:12:32,510
you're having you do the hard work yeah

01:12:30,380 --> 01:12:33,560
so I guess cotton when I'm stepping at

01:12:32,510 --> 01:12:35,390
10,000 feet

01:12:33,560 --> 01:12:36,680
alright there's no infrastructure like

01:12:35,390 --> 01:12:38,990
there is an every other operating system

01:12:36,680 --> 01:12:41,000
to like open a previous version right

01:12:38,990 --> 01:12:42,170
there's like open Flags to open previous

01:12:41,000 --> 01:12:45,350
versions and every other operating

01:12:42,170 --> 01:12:47,300
system so what I do is on Mount I have a

01:12:45,350 --> 01:12:48,830
farm that's a snapshot and a timestamp

01:12:47,300 --> 01:12:51,350
and it's really ugly because you got to

01:12:48,830 --> 01:12:53,390
know the timestamp but is there any

01:12:51,350 --> 01:12:54,980
infrastructure like a tool a user space

01:12:53,390 --> 01:12:57,050
thing I should plug into because then

01:12:54,980 --> 01:12:58,880
butter FSN SMB and whoever whatever you

01:12:57,050 --> 01:13:02,750
do would have the same tool so you

01:12:58,880 --> 01:13:13,460
didn't have to remember weird filesystem

01:13:02,750 --> 01:13:16,160
specific stuff right now it doesn't give

01:13:13,460 --> 01:13:19,550
you the option to switch back and forth

01:13:16,160 --> 01:13:21,500
between them it's more of a you can set

01:13:19,550 --> 01:13:30,500
it in a mode where you can go back if

01:13:21,500 --> 01:13:33,050
you need to I mean we didn't we didn't

01:13:30,500 --> 01:13:34,310
attempt to engineer a full snapshot

01:13:33,050 --> 01:13:36,140
solution here with multiple snapshots

01:13:34,310 --> 01:13:37,940
but let's see debris from the old ones

01:13:36,140 --> 01:13:40,160
we were very focused on the problem

01:13:37,940 --> 01:13:42,410
which is if things go wrong we need to

01:13:40,160 --> 01:13:44,420
roll back to the old state and that was

01:13:42,410 --> 01:13:48,430
the only problem we try to solve so

01:13:44,420 --> 01:13:51,020
these solutions are not intended to be

01:13:48,430 --> 01:13:52,430
an equivalent of a full of full

01:13:51,020 --> 01:13:54,170
snapshotting solution that like you

01:13:52,430 --> 01:13:55,610
might like they're talking about where

01:13:54,170 --> 01:13:57,500
you can open old versions of files and

01:13:55,610 --> 01:13:58,670
they saw individual files and all that

01:13:57,500 --> 01:14:00,560
kind of nice stuff we don't have any of

01:13:58,670 --> 01:14:02,840
that nor do we particularly plan to

01:14:00,560 --> 01:14:05,120
implement it because our problem is

01:14:02,840 --> 01:14:07,370
Rather's is very focused which is

01:14:05,120 --> 01:14:19,650
loading the whole thing back in one file

01:14:07,370 --> 01:14:23,480
when things get about sandy the snapshot

01:14:19,650 --> 01:14:26,640
is exactly one version old and never

01:14:23,480 --> 01:14:29,040
more than that and the reason for that

01:14:26,640 --> 01:14:32,400
is because we always wanted the ability

01:14:29,040 --> 01:14:35,010
to automatically roll back if something

01:14:32,400 --> 01:14:36,710
goes wrong so nothing has to intervene

01:14:35,010 --> 01:14:39,930
and do anything to the file system

01:14:36,710 --> 01:14:41,520
because the biggest use cases is if

01:14:39,930 --> 01:14:44,490
update is wrong we don't want to leave

01:14:41,520 --> 01:14:45,720
the user data with the wrong update we

01:14:44,490 --> 01:14:48,690
want to we want it to roll back

01:14:45,720 --> 01:14:51,660
automatically so the role in this case

01:14:48,690 --> 01:14:54,060
is or the responsibility is to the

01:14:51,660 --> 01:14:56,430
caller or on Android in order to commit

01:14:54,060 --> 01:14:58,830
the snapshot so basically ultimately you

01:14:56,430 --> 01:15:00,960
never have more than one that were and

01:14:58,830 --> 01:15:03,120
and we wanted an automatic rollback when

01:15:00,960 --> 01:15:04,800
you do reboot because that reboot can

01:15:03,120 --> 01:15:05,220
happen any time and we have no control

01:15:04,800 --> 01:15:08,040
over it

01:15:05,220 --> 01:15:09,980
I mean the rebuilds probably cause the

01:15:08,040 --> 01:15:12,390
device crashed is not good news

01:15:09,980 --> 01:15:13,800
so the an example I was thinking of

01:15:12,390 --> 01:15:14,810
let's say you did your presentation you

01:15:13,800 --> 01:15:17,400
screwed up

01:15:14,810 --> 01:15:19,500
I mean I did a presentation I screwed up

01:15:17,400 --> 01:15:20,760
right so what I was trying to see if

01:15:19,500 --> 01:15:22,860
there's any commonality and what you're

01:15:20,760 --> 01:15:25,950
talking about what letter FS does what

01:15:22,860 --> 01:15:27,690
as what I'd now do an sp3 so you screwed

01:15:25,950 --> 01:15:29,910
up your presentation today all you'd

01:15:27,690 --> 01:15:30,960
have to do an SMB 3 in my kernel driver

01:15:29,910 --> 01:15:33,780
right in the kernel with us is just

01:15:30,960 --> 01:15:35,220
mount snapshot just some directory and

01:15:33,780 --> 01:15:39,300
then you could just do dips between your

01:15:35,220 --> 01:15:42,090
yeah that's what a full snapshot

01:15:39,300 --> 01:15:44,160
solution should do and we have not

01:15:42,090 --> 01:15:46,560
implemented a full snapshot solution we

01:15:44,160 --> 01:15:49,170
have implemented it just a whole yeah a

01:15:46,560 --> 01:15:52,830
limited solution which allows us to roll

01:15:49,170 --> 01:15:54,870
back everything that's super useful I'm

01:15:52,830 --> 01:15:56,490
not saying it's not useful but what I

01:15:54,870 --> 01:15:58,320
was getting at is that you know the API

01:15:56,490 --> 01:16:01,590
is for that are more complicated in my

01:15:58,320 --> 01:16:03,090
case simpler in your case but I can do

01:16:01,590 --> 01:16:05,070
that too by the way if it helps but so

01:16:03,090 --> 01:16:06,210
you could but the thing that's that's

01:16:05,070 --> 01:16:07,590
interesting is I thought that most

01:16:06,210 --> 01:16:08,490
common use cases like you screw up a

01:16:07,590 --> 01:16:09,540
presentation you're looking at a

01:16:08,490 --> 01:16:11,070
different trying to find the previous

01:16:09,540 --> 01:16:14,190
version of a single file that's you

01:16:11,070 --> 01:16:16,140
screwed up um doesn't so butter if s is

01:16:14,190 --> 01:16:16,340
the only guy XFS you know that in the

01:16:16,140 --> 01:16:17,630
goal

01:16:16,340 --> 01:16:20,840
dmap you days there's no there's no

01:16:17,630 --> 01:16:22,400
other file system other than btrfs that

01:16:20,840 --> 01:16:24,020
today would allow you to do something

01:16:22,400 --> 01:16:27,650
vaguely similar so there's no user space

01:16:24,020 --> 01:16:30,070
tools not so well there's DFS DFS I

01:16:27,650 --> 01:16:34,760
think has snapshots

01:16:30,070 --> 01:16:37,040
we don't want minute yeah I've got a

01:16:34,760 --> 01:16:38,989
quick question on the DM snap where you

01:16:37,040 --> 01:16:42,020
help will to set it up in the lab

01:16:38,989 --> 01:16:44,179
because when I try to test DM snap and I

01:16:42,020 --> 01:16:46,849
was trying to snapshot a extra for block

01:16:44,179 --> 01:16:49,130
device mounted block device and it looks

01:16:46,849 --> 01:16:51,650
like DM snap tries to lock the device

01:16:49,130 --> 01:16:55,040
exclusively so I was not able to

01:16:51,650 --> 01:16:57,440
snapshot mounted XT for block device so

01:16:55,040 --> 01:17:00,530
I had to unmount it and then use another

01:16:57,440 --> 01:17:02,750
block device that's true and then then I

01:17:00,530 --> 01:17:05,300
was able to snapshot and use the DM snap

01:17:02,750 --> 01:17:07,369
to do it snapshot so my question is does

01:17:05,300 --> 01:17:10,699
DM snap can actually snapshot are

01:17:07,369 --> 01:17:13,580
mounted no I mean creates a second

01:17:10,699 --> 01:17:16,340
device and then two more devices and

01:17:13,580 --> 01:17:18,650
then you mount on those devices DM snap

01:17:16,340 --> 01:17:20,000
does yeah and need the problem we had is

01:17:18,650 --> 01:17:21,739
the DM snap requires an extra device

01:17:20,000 --> 01:17:31,449
which we don't have and I think we're

01:17:21,739 --> 01:17:36,230
being tipped off 15 seconds okay yeah a

01:17:31,449 --> 01:17:38,330
DM snap is an has its own LVM it the

01:17:36,230 --> 01:17:43,219
filesystem thinks it writes exactly the

01:17:38,330 --> 01:17:46,239
same block and DM snap says no you're

01:17:43,219 --> 01:17:49,159
actually writing to another block

01:17:46,239 --> 01:17:52,840
alright so it exclusively owns the

01:17:49,159 --> 01:17:52,840
exactly that's that's the problem

01:17:54,810 --> 01:18:00,949
[Applause]

01:18:05,600 --> 01:18:12,420
my name's David Anderson I work at

01:18:08,250 --> 01:18:14,489
Google on the Android team so one of

01:18:12,420 --> 01:18:16,530
androids big update ability problems is

01:18:14,489 --> 01:18:21,389
that after a few years we start to run

01:18:16,530 --> 01:18:23,699
out of space to update devices so

01:18:21,389 --> 01:18:26,130
normally devices I have over provisioned

01:18:23,699 --> 01:18:27,600
partitions and they're all most of

01:18:26,130 --> 01:18:29,909
Android unlike a desktop operating

01:18:27,600 --> 01:18:32,699
system resides in read-only partitions

01:18:29,909 --> 01:18:35,520
so in this sample device here with this

01:18:32,699 --> 01:18:38,250
partition table the system partition has

01:18:35,520 --> 01:18:40,770
been allocated at two gigs but maybe the

01:18:38,250 --> 01:18:42,719
initial image on it is only 1.5 and the

01:18:40,770 --> 01:18:44,550
manufacturer doing that let's say they

01:18:42,719 --> 01:18:47,040
want three years of updates they have to

01:18:44,550 --> 01:18:50,400
hope that that extra 500 Meg's of slack

01:18:47,040 --> 01:18:52,889
is enough for those three years and

01:18:50,400 --> 01:18:55,500
unfortunately these partitions run out

01:18:52,889 --> 01:18:57,659
of space at different rates so almost

01:18:55,500 --> 01:19:01,590
always at least on pixel system runs out

01:18:57,659 --> 01:19:03,690
of space long before vendor does so

01:19:01,590 --> 01:19:05,850
let's say after three years system is

01:19:03,690 --> 01:19:08,969
completely full and this vendor

01:19:05,850 --> 01:19:10,860
partition has two hundred Meg's free we

01:19:08,969 --> 01:19:12,630
can't actually take that space from

01:19:10,860 --> 01:19:14,400
vendor to use for system and that's

01:19:12,630 --> 01:19:16,440
because each partition is signed in

01:19:14,400 --> 01:19:20,670
America and they may be signed by

01:19:16,440 --> 01:19:23,040
different providers or vendors so an

01:19:20,670 --> 01:19:25,290
obvious solution to this is why not just

01:19:23,040 --> 01:19:28,320
rewrite the GPT if you're not familiar

01:19:25,290 --> 01:19:30,690
GPT is the Geo ID partition table and

01:19:28,320 --> 01:19:33,060
it's the fixed partition layout used on

01:19:30,690 --> 01:19:34,889
most modern devices and desktops and

01:19:33,060 --> 01:19:35,489
there are already tools for this like

01:19:34,889 --> 01:19:38,260
gparted

01:19:35,489 --> 01:19:41,350
that can resize and move partitions and

01:19:38,260 --> 01:19:42,850
right Anu GPT there's two reasons we

01:19:41,350 --> 01:19:44,710
don't want to do this one is that

01:19:42,850 --> 01:19:47,670
Android doesn't specify partitioning

01:19:44,710 --> 01:19:51,070
system even though GPT is super popular

01:19:47,670 --> 01:19:52,510
we don't require that devices use it and

01:19:51,070 --> 01:19:54,880
second is that it's just inherently

01:19:52,510 --> 01:19:56,770
risky we don't want to risk user data

01:19:54,880 --> 01:20:00,820
becoming completely inaccessible due to

01:19:56,770 --> 01:20:03,730
an over-the-air update so our solution

01:20:00,820 --> 01:20:05,530
for this was to use device mapper so

01:20:03,730 --> 01:20:07,659
instead of having individual fixed

01:20:05,530 --> 01:20:10,090
partitions for a system product vendor

01:20:07,659 --> 01:20:12,820
we now have one big fixed partition

01:20:10,090 --> 01:20:14,590
called super and within that we use

01:20:12,820 --> 01:20:16,900
device mapper to allocate logical

01:20:14,590 --> 01:20:18,400
partitions you'll notice that in this

01:20:16,900 --> 01:20:21,610
diagram it's a few partitions that are

01:20:18,400 --> 01:20:24,130
still fixed like the boot partition that

01:20:21,610 --> 01:20:26,980
has to stay a fixed partition because it

01:20:24,130 --> 01:20:28,510
has the kernel and user data is also

01:20:26,980 --> 01:20:32,280
fixed we just don't want to touch that

01:20:28,510 --> 01:20:36,369
so super is mostly for read-only

01:20:32,280 --> 01:20:40,270
partitions so the implementation for

01:20:36,369 --> 01:20:42,219
this is pretty similar to LVM or GPT at

01:20:40,270 --> 01:20:44,380
the top of the super partition there's a

01:20:42,219 --> 01:20:46,480
little chunk of metadata that describes

01:20:44,380 --> 01:20:50,110
partition names and what regions of the

01:20:46,480 --> 01:20:52,210
disk they occupy and unlike GPT these

01:20:50,110 --> 01:20:55,179
regions can be these partitions can be

01:20:52,210 --> 01:20:57,340
fragmented so when you're your initial

01:20:55,179 --> 01:20:59,230
device layout may have system and vendor

01:20:57,340 --> 01:21:01,869
each occupying one region of the disk

01:20:59,230 --> 01:21:04,239
but after an OTA let's say an over the

01:21:01,869 --> 01:21:06,880
air update decides to resize the system

01:21:04,239 --> 01:21:09,790
partition we don't actually move vendor

01:21:06,880 --> 01:21:13,179
and make a contiguous region for system

01:21:09,790 --> 01:21:15,349
we instead add a second chunk of the

01:21:13,179 --> 01:21:18,560
disk to the

01:21:15,349 --> 01:21:20,599
metadata for system and this Maps really

01:21:18,560 --> 01:21:23,179
nicely to device mapper the DM layer

01:21:20,599 --> 01:21:26,329
atom linear module I'll lets us just

01:21:23,179 --> 01:21:30,829
string together random regions of block

01:21:26,329 --> 01:21:32,530
devices we had to change a few aspects

01:21:30,829 --> 01:21:35,630
of the boot sequence to make this work

01:21:32,530 --> 01:21:38,449
previously an Android key we would skip

01:21:35,630 --> 01:21:40,670
and yet RMF us the kernel would boot

01:21:38,449 --> 01:21:42,139
directly to the system partition we

01:21:40,670 --> 01:21:43,550
can't do that anymore because the kernel

01:21:42,139 --> 01:21:45,469
doesn't actually understand our

01:21:43,550 --> 01:21:47,780
partitioning system it can't find the

01:21:45,469 --> 01:21:49,880
system image so instead we now have a

01:21:47,780 --> 01:21:51,290
ram disk in the boot partition and

01:21:49,880 --> 01:21:53,300
there's a first stage in it in there

01:21:51,290 --> 01:21:56,030
that reads the super partition metadata

01:21:53,300 --> 01:21:58,579
and I creates our device macro devices

01:21:56,030 --> 01:22:00,710
and we had to change our FS tab mounting

01:21:58,579 --> 01:22:04,270
code so it could find those partitions

01:22:00,710 --> 01:22:07,070
as to do as if they were in the GPT

01:22:04,270 --> 01:22:09,260
over-the-air updates can now resize

01:22:07,070 --> 01:22:12,079
create delete these dynamic partitions

01:22:09,260 --> 01:22:14,510
they don't have to touch GPT this is all

01:22:12,079 --> 01:22:18,550
handled in a user space by a library

01:22:14,510 --> 01:22:18,550
called labelled key that is an AO SP

01:22:18,610 --> 01:22:23,409
another thing we had to change is how

01:22:21,020 --> 01:22:26,090
devices are flashed so previously

01:22:23,409 --> 01:22:28,400
devices most devices were flashed from

01:22:26,090 --> 01:22:30,770
the bootloader using a confusingly named

01:22:28,400 --> 01:22:32,540
protocol called fastboot but obviously

01:22:30,770 --> 01:22:35,750
boot loaders do not have device mapper

01:22:32,540 --> 01:22:37,719
they don't run the Linux kernel so we

01:22:35,750 --> 01:22:40,940
needed a user space solution to this

01:22:37,719 --> 01:22:43,099
so now devices that need to flash

01:22:40,940 --> 01:22:45,619
dynamic partitions they will actually

01:22:43,099 --> 01:22:47,719
boot into a recovery image of the Linux

01:22:45,619 --> 01:22:50,750
kernel and start a daemon called fast

01:22:47,719 --> 01:22:53,360
boot D and this is obviously too slow

01:22:50,750 --> 01:22:55,940
for flashing the factory we don't want

01:22:53,360 --> 01:22:58,310
to sit there booting up devices factory

01:22:55,940 --> 01:23:00,079
line just to flash them so we can also

01:22:58,310 --> 01:23:02,590
pre generate an image of the super

01:23:00,079 --> 01:23:02,590
partition

01:23:02,849 --> 01:23:06,540
we found device mapper with

01:23:04,500 --> 01:23:09,030
super-flexible we had already been using

01:23:06,540 --> 01:23:11,760
DM Verity and just stacked on top of our

01:23:09,030 --> 01:23:12,810
new logical partitions I continued to

01:23:11,760 --> 01:23:14,639
work

01:23:12,810 --> 01:23:17,190
we also found we can retrofit older

01:23:14,639 --> 01:23:19,260
devices so even if a device doesn't have

01:23:17,190 --> 01:23:22,280
a super partition it doesn't really

01:23:19,260 --> 01:23:27,119
matter because iam linear lets us ditch

01:23:22,280 --> 01:23:29,760
any device into a logical partition so

01:23:27,119 --> 01:23:31,469
we can retrofit this devices just by

01:23:29,760 --> 01:23:36,119
reusing the existing partition tables

01:23:31,469 --> 01:23:37,800
they have we also did some performance

01:23:36,119 --> 01:23:39,540
measurement we found there's a no

01:23:37,800 --> 01:23:42,300
measurable performance impact up to

01:23:39,540 --> 01:23:44,579
hundreds of extents and a partition we

01:23:42,300 --> 01:23:46,440
did see a measurable overhead once you

01:23:44,579 --> 01:23:48,599
got into thousands and tens of thousands

01:23:46,440 --> 01:23:51,659
we're not expecting that to be a problem

01:23:48,599 --> 01:23:53,820
Android has one security update a month

01:23:51,659 --> 01:23:55,139
and one major dessert release a year so

01:23:53,820 --> 01:24:00,810
you have to be updating a device for

01:23:55,139 --> 01:24:03,360
like 60 to 80 years before you hit and a

01:24:00,810 --> 01:24:07,250
very common question it is why not LVN

01:24:03,360 --> 01:24:09,750
and mostly problems specific to country

01:24:07,250 --> 01:24:11,610
the first is we need to generate factory

01:24:09,750 --> 01:24:13,770
images we need to be able to generate an

01:24:11,610 --> 01:24:15,900
image off the build that we can just

01:24:13,770 --> 01:24:18,210
flash on to devices without actually

01:24:15,900 --> 01:24:22,139
generating the young I'll be a metadata

01:24:18,210 --> 01:24:25,079
on the device our non Amy updates

01:24:22,139 --> 01:24:27,239
need to survive power loss so for

01:24:25,079 --> 01:24:29,730
example if you have a phone that is not

01:24:27,239 --> 01:24:31,590
an AV device and you're updating and you

01:24:29,730 --> 01:24:32,969
yank out the battery we try very hard to

01:24:31,590 --> 01:24:36,630
make it so when you put the battery back

01:24:32,969 --> 01:24:41,400
in the update will continue and resume

01:24:36,630 --> 01:24:43,730
and if we're writing metadata we want

01:24:41,400 --> 01:24:46,380
that we want to preserve that property

01:24:43,730 --> 01:24:48,719
and lastly we needed a quota mechanism

01:24:46,380 --> 01:24:51,210
for partition owners we want the ability

01:24:48,719 --> 01:24:51,639
to have certain partitions owned by one

01:24:51,210 --> 01:24:53,320
vendor

01:24:51,639 --> 01:24:55,840
and other partitions owned by another

01:24:53,320 --> 01:24:58,420
and have a quota on how much space there

01:24:55,840 --> 01:25:00,310
each allowed to have and the easiest way

01:24:58,420 --> 01:25:07,980
to do that was to just encode encode

01:25:00,310 --> 01:25:07,980
that quota inside the metadata questions

01:25:09,869 --> 01:25:15,159
didn't quite get your rationale for a

01:25:12,250 --> 01:25:17,050
why you didn't want to add user data to

01:25:15,159 --> 01:25:19,980
the the set of partitions you could

01:25:17,050 --> 01:25:24,580
resize on-the-fly so initially when we

01:25:19,980 --> 01:25:28,139
do this we actually wanted to resize

01:25:24,580 --> 01:25:30,489
user data as part of that so let's say

01:25:28,139 --> 01:25:31,570
you actually ran up space in super

01:25:30,489 --> 01:25:34,119
partition we'd be able to start

01:25:31,570 --> 01:25:35,650
encroaching into user data that turned

01:25:34,119 --> 01:25:38,290
out to be a huge can of worms for many

01:25:35,650 --> 01:25:42,000
reasons and we backed off that and just

01:25:38,290 --> 01:25:44,020
to reduce the risk of user data becoming

01:25:42,000 --> 01:25:49,020
inaccessible or corrupted we just kept

01:25:44,020 --> 01:25:49,020
it out for now okay thank you

01:25:53,690 --> 01:25:58,680
there was a path there's a path in the

01:25:56,340 --> 01:26:02,550
flow where there was a possibility that

01:25:58,680 --> 01:26:05,880
you would require a factory reset and

01:26:02,550 --> 01:26:08,250
that's basically for us is a regression

01:26:05,880 --> 01:26:11,430
from what the current a B update

01:26:08,250 --> 01:26:14,130
behavior is we don't know how much or

01:26:11,430 --> 01:26:17,130
what the frequency of that path that

01:26:14,130 --> 01:26:19,470
happens but we definitely intend to

01:26:17,130 --> 01:26:21,570
monitor and see what we can do about we

01:26:19,470 --> 01:26:27,480
are so basically that was there is to

01:26:21,570 --> 01:26:30,090
include use a little bit so it's all the

01:26:27,480 --> 01:26:32,370
changes available in ASP master now for

01:26:30,090 --> 01:26:36,030
the support yeah my question is this

01:26:32,370 --> 01:26:40,020
upstream yes and so do you know if the

01:26:36,030 --> 01:26:43,080
regular Linux distributions also pick up

01:26:40,020 --> 01:26:50,880
the user tools and all that or it's just

01:26:43,080 --> 01:26:54,030
for Android yeah because it looks yeah

01:26:50,880 --> 01:26:56,450
but do you know if it was adopted other

01:26:54,030 --> 01:26:56,450
than

01:27:04,630 --> 01:27:10,340
if the sitter's the simpler metadata

01:27:07,730 --> 01:27:11,660
format that we have in is something that

01:27:10,340 --> 01:27:13,460
you require because you're updating

01:27:11,660 --> 01:27:15,800
again the update case is also you need

01:27:13,460 --> 01:27:18,070
to Android in that case the libraries

01:27:15,800 --> 01:27:20,090
are there the metadata format we

01:27:18,070 --> 01:27:22,790
definitely intend to document and

01:27:20,090 --> 01:27:24,830
basically open up anyone is free to use

01:27:22,790 --> 01:27:27,680
it wherever they want it's basic

01:27:24,830 --> 01:27:29,210
ultimately it's DM linear which works

01:27:27,680 --> 01:27:31,430
exactly the same way everywhere it's

01:27:29,210 --> 01:27:33,050
basically how do you get the metadata in

01:27:31,430 --> 01:27:35,000
the user space in order to configure DM

01:27:33,050 --> 01:27:49,120
Y with LVM it has its own format we have

01:27:35,000 --> 01:27:49,120
the on disk metadata format finance

01:27:53,150 --> 01:28:03,380
I just want to say we do know that some

01:28:00,050 --> 01:28:06,739
companies actually change the GPT on OTA

01:28:03,380 --> 01:28:10,699
and we really asked them to not do that

01:28:06,739 --> 01:28:12,199
please but they they do that and they

01:28:10,699 --> 01:28:14,060
say that they've never run into any

01:28:12,199 --> 01:28:15,140
problems to which we say well how do you

01:28:14,060 --> 01:28:18,469
know if you didn't run into any problems

01:28:15,140 --> 01:28:19,550
the device in boot so that we really

01:28:18,469 --> 01:28:23,830
think that this is the better way

01:28:19,550 --> 01:28:23,830
forward just a comment

01:28:31,960 --> 01:28:37,540
all good really break all right so let's

01:28:35,860 --> 01:28:39,600
break down until four will start to pour

01:28:37,540 --> 01:28:39,600
over

01:28:40,550 --> 01:28:49,420
[Applause]

01:28:45,550 --> 01:28:53,200
oh okay my name is Sandeep Patil I work

01:28:49,420 --> 01:28:57,010
in Android kernel team one of the

01:28:53,200 --> 01:28:58,930
reasons we're talking about FS tab and

01:28:57,010 --> 01:29:02,170
DDS is because of something that we did

01:28:58,930 --> 01:29:03,370
back in Android earlier for example and

01:29:02,170 --> 01:29:06,940
we actually talked about it in the

01:29:03,370 --> 01:29:10,570
Palmers as well and what we did for

01:29:06,940 --> 01:29:13,270
project rebel is when we wanted to split

01:29:10,570 --> 01:29:15,370
platform from vendor implementation

01:29:13,270 --> 01:29:17,470
which means we also wanted to make sure

01:29:15,370 --> 01:29:19,810
all the code that that is responsible

01:29:17,470 --> 01:29:22,180
for vendor and hardware part lives in

01:29:19,810 --> 01:29:25,030
the vendor partition and yet and all the

01:29:22,180 --> 01:29:27,310
code that is responsible for platform

01:29:25,030 --> 01:29:29,920
lives in a system partition what that

01:29:27,310 --> 01:29:32,200
means was we also wanted to make sure

01:29:29,920 --> 01:29:34,510
the SE Linux policy that goes and

01:29:32,200 --> 01:29:37,060
basically attributes every single one of

01:29:34,510 --> 01:29:38,350
them also is split across these two so

01:29:37,060 --> 01:29:40,120
in order to be able to do that that

01:29:38,350 --> 01:29:42,820
means we have to basically build the SE

01:29:40,120 --> 01:29:44,260
policy as we boot into Android and we

01:29:42,820 --> 01:29:47,670
wanted to be able to source that AC

01:29:44,260 --> 01:29:49,660
policy from both of these partitions

01:29:47,670 --> 01:29:52,240
assuming that one of them can get

01:29:49,660 --> 01:29:54,700
updated particularly if not for what

01:29:52,240 --> 01:29:55,960
that meant for in it at the time was we

01:29:54,700 --> 01:29:58,060
wanted to make sure both of these

01:29:55,960 --> 01:30:00,490
partitions are available as soon as in

01:29:58,060 --> 01:30:03,580
it has started and that wasn't the case

01:30:00,490 --> 01:30:06,640
for say nany B devices at the time for a

01:30:03,580 --> 01:30:09,100
B devices I think system partition was

01:30:06,640 --> 01:30:10,360
being mounted as root but vendor

01:30:09,100 --> 01:30:14,520
partition was not guaranteed to be

01:30:10,360 --> 01:30:21,040
around so our solution to that was that

01:30:14,520 --> 01:30:23,200
what that is is basically a way for us

01:30:21,040 --> 01:30:28,210
to tell in it where to look for system

01:30:23,200 --> 01:30:30,730
and window partition that way so to

01:30:28,210 --> 01:30:33,070
retract a bit before this basic it was

01:30:30,730 --> 01:30:35,470
it used to be a FS tab sitting in say

01:30:33,070 --> 01:30:37,170
system partition in it would then go and

01:30:35,470 --> 01:30:39,420
read their first tab and then start

01:30:37,170 --> 01:30:41,790
positions as usual now that we need

01:30:39,420 --> 01:30:43,710
these partitions even before selinux

01:30:41,790 --> 01:30:46,260
policy is loaded that means we don't

01:30:43,710 --> 01:30:47,910
have any file system to work off of but

01:30:46,260 --> 01:30:51,810
we still need to get this information to

01:30:47,910 --> 01:30:55,350
in it somehow so that somehow at that

01:30:51,810 --> 01:30:58,050
time turned out to be device tree and

01:30:55,350 --> 01:30:59,969
that basically means we were locked to

01:30:58,050 --> 01:31:04,710
the device within the feature at that

01:30:59,969 --> 01:31:07,440
time was called we must change its name

01:31:04,710 --> 01:31:09,390
early mom first stage mom because the

01:31:07,440 --> 01:31:12,630
amount for system and when it happens in

01:31:09,390 --> 01:31:14,630
units first days what you see that it is

01:31:12,630 --> 01:31:17,219
basically a device we mind binding that

01:31:14,630 --> 01:31:22,110
basically reflect an extra step entry

01:31:17,219 --> 01:31:23,940
for Android and the things in bold there

01:31:22,110 --> 01:31:26,910
are basically what our vendor specific

01:31:23,940 --> 01:31:29,340
for example the SOC sixty to 400 part is

01:31:26,910 --> 01:31:31,020
something that is very specific and you

01:31:29,340 --> 01:31:33,690
don't know that in everyone so it had to

01:31:31,020 --> 01:31:35,790
be hard-coded in the division which is

01:31:33,690 --> 01:31:37,679
caused a lot of tree speakers that means

01:31:35,790 --> 01:31:41,370
whenever you want to change anything you

01:31:37,679 --> 01:31:43,050
have to basically flash the kernel in

01:31:41,370 --> 01:31:45,179
order to be able to basically figure out

01:31:43,050 --> 01:31:47,820
where to mount row and that has caused a

01:31:45,179 --> 01:31:50,310
lot of cross dependencies same thing

01:31:47,820 --> 01:31:54,449
basically continued on for we verified

01:31:50,310 --> 01:31:59,030
good 200 which basically use a BB so we

01:31:54,449 --> 01:31:59,030
actually piled on to this method and

01:32:01,640 --> 01:32:07,940
what this is supposed to do as of today

01:32:05,840 --> 01:32:09,650
knees mentioned all the partitioning

01:32:07,940 --> 01:32:13,190
names without there's lots of its that

01:32:09,650 --> 01:32:15,950
are verified by ABB the reason for that

01:32:13,190 --> 01:32:17,210
is again in its what go and read this

01:32:15,950 --> 01:32:20,420
and make sure all of these partitions

01:32:17,210 --> 01:32:23,690
are verified using a VPN made constant

01:32:20,420 --> 01:32:25,280
to the oh the biggest part here for

01:32:23,690 --> 01:32:26,750
example boot it's not even that there's

01:32:25,280 --> 01:32:29,150
not even a fine system on it but it is

01:32:26,750 --> 01:32:32,480
verified it is part of the verified boot

01:32:29,150 --> 01:32:36,170
chain the effects manager flag changed

01:32:32,480 --> 01:32:37,820
from say verify to bbb-but and there's

01:32:36,170 --> 01:32:41,030
one more thing that's not mentioned here

01:32:37,820 --> 01:32:45,140
but it did happen is the vendor specific

01:32:41,030 --> 01:32:48,830
part the the name the SOC / 62 400 that

01:32:45,140 --> 01:32:51,260
also changed into basically as a DT

01:32:48,830 --> 01:32:54,230
property called boot device which is

01:32:51,260 --> 01:32:56,660
which is a way for any to tell which

01:32:54,230 --> 01:32:58,340
exact device to look for system and

01:32:56,660 --> 01:33:00,530
vendor partition from because there are

01:32:58,340 --> 01:33:04,310
reference devices that may have say an

01:33:00,530 --> 01:33:05,420
emmc and ufs both have both system and

01:33:04,310 --> 01:33:07,550
vendor partition and we need to know

01:33:05,420 --> 01:33:09,440
which one is to boot from so the way to

01:33:07,550 --> 01:33:14,060
do that was again with University or

01:33:09,440 --> 01:33:15,680
well suffice it a we basically made one

01:33:14,060 --> 01:33:17,060
change and we pretty much Python and for

01:33:15,680 --> 01:33:20,030
the next two years in order to basically

01:33:17,060 --> 01:33:22,910
keep moving with Android P however

01:33:20,030 --> 01:33:26,000
there's one change that happened which

01:33:22,910 --> 01:33:27,470
is all Android devices are now expected

01:33:26,000 --> 01:33:29,329
to have system to be mounted as root

01:33:27,470 --> 01:33:32,150
doesn't matter whether

01:33:29,329 --> 01:33:34,400
and with our David soccer they'll

01:33:32,150 --> 01:33:36,500
yourself where we're trying to work on

01:33:34,400 --> 01:33:38,570
getting logical partitions in shape

01:33:36,500 --> 01:33:41,869
which means we have an opportunity here

01:33:38,570 --> 01:33:43,790
to basically get rid of all of these

01:33:41,869 --> 01:33:46,250
bindings from device tree and put them

01:33:43,790 --> 01:33:49,309
back into a system which we think where

01:33:46,250 --> 01:33:52,760
they belong and which that means the

01:33:49,309 --> 01:33:54,590
gram disk comes back which is what we're

01:33:52,760 --> 01:33:57,050
calling frustration embrace all this

01:33:54,590 --> 01:33:59,030
means is the current init binary in

01:33:57,050 --> 01:34:00,679
Android already has two stages first and

01:33:59,030 --> 01:34:02,360
second but the first stage now gets

01:34:00,679 --> 01:34:04,159
executed out of this round is why the

01:34:02,360 --> 01:34:07,730
second stage gets pushed down to the

01:34:04,159 --> 01:34:09,409
system direction we would we obviously

01:34:07,730 --> 01:34:12,050
want to maintain the property that

01:34:09,409 --> 01:34:14,599
system is still the root filesystem for

01:34:12,050 --> 01:34:16,340
Android so first stage party first a

01:34:14,599 --> 01:34:18,050
jump test after it's done doing what it

01:34:16,340 --> 01:34:20,059
is supposed to do which is mount

01:34:18,050 --> 01:34:22,429
partitions and low Racing policy if you

01:34:20,059 --> 01:34:25,250
switch route into slash system and then

01:34:22,429 --> 01:34:29,719
everything and then it never it is not

01:34:25,250 --> 01:34:31,730
seen ever doesn't have to be special FS

01:34:29,719 --> 01:34:34,670
tab for that root filesystem we I think

01:34:31,730 --> 01:34:36,920
we are planning to have a flag that

01:34:34,670 --> 01:34:38,809
tells which one of the partitions are to

01:34:36,920 --> 01:34:42,469
be mounting this special first stage and

01:34:38,809 --> 01:34:43,219
which ones are it ends up unifying all

01:34:42,469 --> 01:34:46,790
tribal

01:34:43,219 --> 01:34:49,369
non project configurations removes

01:34:46,790 --> 01:34:51,380
entirely anything any need to have

01:34:49,369 --> 01:34:52,760
anything in the device tree including

01:34:51,380 --> 01:34:54,889
those will be made up configurations

01:34:52,760 --> 01:34:56,090
because we realize we actually don't

01:34:54,889 --> 01:34:57,860
need to really fight boot partition

01:34:56,090 --> 01:35:02,420
because it's verified by the controller

01:34:57,860 --> 01:35:04,460
in the first place doesn't have to be

01:35:02,420 --> 01:35:05,960
different for different partition it can

01:35:04,460 --> 01:35:08,059
be the exact same FS tab that gets

01:35:05,960 --> 01:35:10,909
copied into say vendor and as well as

01:35:08,059 --> 01:35:13,280
the first agent is just the FS manager

01:35:10,909 --> 01:35:16,000
Flags can vary and that decides which

01:35:13,280 --> 01:35:20,270
stage of connect those partitions

01:35:16,000 --> 01:35:21,949
and lastly the boot device part can go

01:35:20,270 --> 01:35:23,300
back to being passed by a colonel from

01:35:21,949 --> 01:35:25,460
online which basically completely

01:35:23,300 --> 01:35:26,690
removes everything that we added in

01:35:25,460 --> 01:35:33,889
device fee and that's what we would like

01:35:26,690 --> 01:35:36,050
to do last but not least another thing

01:35:33,889 --> 01:35:38,750
that we are trying to do in our device

01:35:36,050 --> 01:35:41,630
trees is for Android device trees were

01:35:38,750 --> 01:35:43,040
appended to the gzip kernel image for

01:35:41,630 --> 01:35:46,070
the long list of times the bootloader is

01:35:43,040 --> 01:35:47,360
basically unzip the kernel and then find

01:35:46,070 --> 01:35:49,489
the device we appended to it and then

01:35:47,360 --> 01:35:52,130
run through them to find the devices

01:35:49,489 --> 01:35:54,590
that the base DT that is applicable to

01:35:52,130 --> 01:35:55,940
the SOC we are actually going to get rid

01:35:54,590 --> 01:35:58,219
of those patches that operates this

01:35:55,940 --> 01:36:00,290
because what we ended up doing with pine

01:35:58,219 --> 01:36:02,750
was we version the booty Michigan

01:36:00,290 --> 01:36:06,350
because boot image error was immutable

01:36:02,750 --> 01:36:07,760
before because if a bootloader is

01:36:06,350 --> 01:36:09,800
carrying that with that particular

01:36:07,760 --> 01:36:12,260
header then we didn't want to break any

01:36:09,800 --> 01:36:14,239
of them so what we did last year was to

01:36:12,260 --> 01:36:16,130
version it I think that boot image is at

01:36:14,239 --> 01:36:18,170
version 1 now so we have an opportunity

01:36:16,130 --> 01:36:19,850
where we can put a device tree and

01:36:18,170 --> 01:36:22,400
create a good image and call it version

01:36:19,850 --> 01:36:24,320
2 so and we can and then the boot can

01:36:22,400 --> 01:36:25,909
check for boot image to be whether it's

01:36:24,320 --> 01:36:27,590
version 1 or 2 and then expect the

01:36:25,909 --> 01:36:29,000
device will be there so from now onwards

01:36:27,590 --> 01:36:31,850
we want the device to used to live there

01:36:29,000 --> 01:36:34,130
which means this good side effect of it

01:36:31,850 --> 01:36:35,869
also gets rid of about 8 to 10 patches

01:36:34,130 --> 01:36:39,340
just to obtain the device 3 at the end

01:36:35,869 --> 01:36:39,340
of the third one that we've been

01:36:39,770 --> 01:36:44,520
that's at least the solution we have in

01:36:42,660 --> 01:36:53,970
mind but we are open for solutions

01:36:44,520 --> 01:36:57,540
anything else that you can think of my

01:36:53,970 --> 01:36:59,180
coffees are bad yeah so I'm very excited

01:36:57,540 --> 01:37:01,760
for all this I could probably nag today

01:36:59,180 --> 01:37:04,560
but one of the things I've been kind of

01:37:01,760 --> 01:37:07,700
bringing up occasionally is sometimes

01:37:04,560 --> 01:37:10,920
those paths that are very SOC specific

01:37:07,700 --> 01:37:13,470
again any thoughts our discussion on

01:37:10,920 --> 01:37:15,510
using things like position labels for a

01:37:13,470 --> 01:37:18,810
system or that sort of thing

01:37:15,510 --> 01:37:20,940
so the partition names are not associate

01:37:18,810 --> 01:37:23,310
specific but it's basically the the

01:37:20,940 --> 01:37:26,340
controller that the the names come from

01:37:23,310 --> 01:37:27,090
the the controller ever there is nothing

01:37:26,340 --> 01:37:29,810
we can do

01:37:27,090 --> 01:37:32,430
so we any does go and create like

01:37:29,810 --> 01:37:34,350
siblings which are by name just like how

01:37:32,430 --> 01:37:36,750
you'd ever do and that's exactly how

01:37:34,350 --> 01:37:39,840
everything is found right now this much

01:37:36,750 --> 01:37:44,010
of it but yeah we haven't really thought

01:37:39,840 --> 01:37:45,510
of standardizing how device to be is to

01:37:44,010 --> 01:37:47,250
be named I don't think it's in

01:37:45,510 --> 01:37:51,330
opposition I don't think we actually

01:37:47,250 --> 01:37:53,700
should even do that because the

01:37:51,330 --> 01:37:55,770
configuration is vendor every board is

01:37:53,700 --> 01:37:57,420
different every Association a controller

01:37:55,770 --> 01:37:59,370
is different we don't necessarily want

01:37:57,420 --> 01:38:01,140
to standardize the name for it because

01:37:59,370 --> 01:38:02,550
that means how you register to the

01:38:01,140 --> 01:38:04,350
respective subsystem in the kernel

01:38:02,550 --> 01:38:07,530
changes because of that because we

01:38:04,350 --> 01:38:08,670
didn't want to figure out one way or the

01:38:07,530 --> 01:38:10,740
other you're gonna have to tell Android

01:38:08,670 --> 01:38:11,970
which one is which is the device that

01:38:10,740 --> 01:38:13,380
you are looking for partition form

01:38:11,970 --> 01:38:15,060
either you tell it through boot device

01:38:13,380 --> 01:38:17,640
in order to create a standardized name

01:38:15,060 --> 01:38:21,350
how you tell it is only the questions if

01:38:17,640 --> 01:38:21,350
you have idea about getting rid of

01:38:22,139 --> 01:38:27,429
yeah mostly just thinking as if you use

01:38:25,150 --> 01:38:29,139
a partition label then as they're

01:38:27,429 --> 01:38:30,729
discovered they can be automatically

01:38:29,139 --> 01:38:34,809
matched and this is how sometimes

01:38:30,729 --> 01:38:36,130
distress would you know do it but there

01:38:34,809 --> 01:38:39,900
is the risk where you could have two

01:38:36,130 --> 01:38:39,900
devices that have the same partitions

01:38:40,949 --> 01:39:00,400
but I'm not sure if the avb okay as long

01:38:58,659 --> 01:39:01,479
as they're both signed properly then I

01:39:00,400 --> 01:39:03,599
guess the question is why would it

01:39:01,479 --> 01:39:03,599
matter

01:39:12,959 --> 01:39:19,479
yeah so now that you brought back the

01:39:15,849 --> 01:39:22,059
unit ROM FS have you looked into ways of

01:39:19,479 --> 01:39:24,369
freeing that memory or have you yes well

01:39:22,059 --> 01:39:26,979
that gets freed before the alright after

01:39:24,369 --> 01:39:30,209
switching so the second stage takes care

01:39:26,979 --> 01:39:30,209
of that oh yes

01:39:31,890 --> 01:39:36,660
that the reason behind switching group

01:39:34,920 --> 01:39:38,400
completely and execute to the second

01:39:36,660 --> 01:39:42,090
station there's not there's no leaks in

01:39:38,400 --> 01:39:44,120
the first so we never you can never go

01:39:42,090 --> 01:39:44,120
back

01:39:56,839 --> 01:40:04,670
that's it let's go Wow okay

01:40:01,200 --> 01:40:04,670
[Applause]

01:40:18,400 --> 01:40:27,060
oh yeah you can use them all right okay

01:40:24,310 --> 01:40:27,060
thank you all

01:40:27,069 --> 01:40:32,859
so I'm going to talk about our the work

01:40:30,909 --> 01:40:35,530
we have been doing with getting trying

01:40:32,859 --> 01:40:38,169
to get ash my mode of staging the plan

01:40:35,530 --> 01:40:41,439
that we have all the work that we did

01:40:38,169 --> 01:40:43,239
and the you know the the open questions

01:40:41,439 --> 01:40:45,419
and the problems that that we're dealing

01:40:43,239 --> 01:40:45,419
with

01:40:52,750 --> 01:40:59,320
so why do we want to do this so the

01:40:56,110 --> 01:41:01,920
thing about the ashram driver is it's

01:40:59,320 --> 01:41:07,510
it's been in staging for so many years

01:41:01,920 --> 01:41:09,100
things in staging are not Linux ABI you

01:41:07,510 --> 01:41:11,350
know they can be deleted at any time

01:41:09,100 --> 01:41:13,300
they're not expected to be supported so

01:41:11,350 --> 01:41:17,740
it's not a good thing to have it in

01:41:13,300 --> 01:41:20,350
staging ash mmmm is it's by design is

01:41:17,740 --> 01:41:24,460
it's just like a wrapper layer on top of

01:41:20,350 --> 01:41:26,620
sh mem and that design has had a lot of

01:41:24,460 --> 01:41:29,770
issues that we have seen recently like

01:41:26,620 --> 01:41:33,160
with with locks and deadlocks and things

01:41:29,770 --> 01:41:36,190
like that but keep coming up and then

01:41:33,160 --> 01:41:38,020
the reason is you know Linux systems

01:41:36,190 --> 01:41:40,840
already have mem ft so we'd rather just

01:41:38,020 --> 01:41:43,420
use that and add features that are

01:41:40,840 --> 01:41:45,970
missing in that it you know it's robust

01:41:43,420 --> 01:41:48,990
widely tested if I understand it's

01:41:45,970 --> 01:41:53,260
actually been around longer than as

01:41:48,990 --> 01:41:56,740
Ashman and it's it's very well

01:41:53,260 --> 01:41:58,750
integrated with the core MN

01:41:56,740 --> 01:42:03,310
you know subsystem in the inner kernel

01:41:58,750 --> 01:42:06,040
so we'd rather use that so the the

01:42:03,310 --> 01:42:08,320
roadmap kind of looks like you know you

01:42:06,040 --> 01:42:10,780
want to add missing features to mem FD

01:42:08,320 --> 01:42:13,420
whatever we need send those patches

01:42:10,780 --> 01:42:16,020
upstream remove use cases and use a

01:42:13,420 --> 01:42:19,180
space that don't need Ashman at all

01:42:16,020 --> 01:42:21,970
change the implementation and Android so

01:42:19,180 --> 01:42:24,640
our plan is to keep the API in in the

01:42:21,970 --> 01:42:26,590
Android libraries the same but changed

01:42:24,640 --> 01:42:29,500
the underlying implementation to

01:42:26,590 --> 01:42:33,940
actually use mam ft instead of instead

01:42:29,500 --> 01:42:38,260
of ashram and then we have to look into

01:42:33,940 --> 01:42:40,150
the problem of apps that don't use the

01:42:38,260 --> 01:42:43,450
Android libraries and directly use a

01:42:40,150 --> 01:42:46,480
shman like like the Chrome browser and

01:42:43,450 --> 01:42:48,820
so we have to look into doing things

01:42:46,480 --> 01:42:51,880
like add adding is SELinux rules and

01:42:48,820 --> 01:42:54,410
monitoring auditing and seeing who's

01:42:51,880 --> 01:42:58,220
using it and working with them to move

01:42:54,410 --> 01:42:59,960
from it and then finally you know after

01:42:58,220 --> 01:43:01,940
everything is done we can look into

01:42:59,960 --> 01:43:07,130
removing the driver from staging or

01:43:01,940 --> 01:43:09,980
something like that so one of the

01:43:07,130 --> 01:43:13,340
features actually the only feature that

01:43:09,980 --> 01:43:15,530
is missing that we wanted in MFT is for

01:43:13,340 --> 01:43:19,790
memory protection so Android has this

01:43:15,530 --> 01:43:21,620
use case where you can allocate a region

01:43:19,790 --> 01:43:24,770
of memory and send it across to another

01:43:21,620 --> 01:43:26,900
process and when you before you send it

01:43:24,770 --> 01:43:30,320
you can set the protections for that

01:43:26,900 --> 01:43:32,090
region to to be read-only so that you

01:43:30,320 --> 01:43:33,710
can so that the sender could continue to

01:43:32,090 --> 01:43:36,470
write to it but the receiver will only

01:43:33,710 --> 01:43:43,550
get a read on the view of the of the

01:43:36,470 --> 01:43:45,260
memory region and so there's a class and

01:43:43,550 --> 01:43:50,900
in Android called cursor window which

01:43:45,260 --> 01:43:54,830
which needs this so pattice for this are

01:43:50,900 --> 01:43:57,080
completed and we sent them upstream last

01:43:54,830 --> 01:44:01,790
week and it's it's looking good it

01:43:57,080 --> 01:44:03,410
should get more soon so this was the

01:44:01,790 --> 01:44:09,140
this is one of the other features that

01:44:03,410 --> 01:44:11,570
we thought initially a memory might need

01:44:09,140 --> 01:44:15,470
but it turns out that there's not a lot

01:44:11,570 --> 01:44:17,120
of people using pinning and unpinning in

01:44:15,470 --> 01:44:20,570
fact the only use of we have seen is is

01:44:17,120 --> 01:44:23,510
chrome so we're we're working with the

01:44:20,570 --> 01:44:26,000
chrome teams to to try to move away from

01:44:23,510 --> 01:44:28,910
it on regular Linux they don't even use

01:44:26,000 --> 01:44:31,700
ashpan they use other other methods to

01:44:28,910 --> 01:44:34,859
do what the pinning unpinning interface

01:44:31,700 --> 01:44:39,510
was supposed to do

01:44:34,859 --> 01:44:45,809
and there are no issues with pinning and

01:44:39,510 --> 01:44:49,229
unpinning like it's not exactly a stable

01:44:45,809 --> 01:44:54,959
way of of doing the doing what its it

01:44:49,229 --> 01:44:57,239
was intended to do so so you know work

01:44:54,959 --> 01:45:00,479
on that is ongoing with it grow moving

01:44:57,239 --> 01:45:04,320
away from it and stuff like that and

01:45:00,479 --> 01:45:06,149
then the other part in our roadmap has

01:45:04,320 --> 01:45:09,349
been hard to remove useless that don't

01:45:06,149 --> 01:45:13,800
need Ashman so I identified a use case

01:45:09,349 --> 01:45:15,989
in in the Android runtime that was using

01:45:13,800 --> 01:45:19,409
it just for naming memory regions not

01:45:15,989 --> 01:45:21,449
even for sharing memory and so I took

01:45:19,409 --> 01:45:24,959
that out and I made it use anonymous

01:45:21,449 --> 01:45:27,989
regions which actually turned out to be

01:45:24,959 --> 01:45:30,329
saving kernel memory and was much faster

01:45:27,989 --> 01:45:31,979
actually to just use that and to name

01:45:30,329 --> 01:45:35,729
those anonymous regions we already have

01:45:31,979 --> 01:45:39,479
a patch to in in our kernel trees that's

01:45:35,729 --> 01:45:46,439
not upstream to do that it's a PR CTL we

01:45:39,479 --> 01:45:49,050
will push that upstream so so once

01:45:46,439 --> 01:45:50,039
upstream and you know the kernel side of

01:45:49,050 --> 01:45:53,639
it is taken care of

01:45:50,039 --> 01:45:57,149
you know the next plan is as I was

01:45:53,639 --> 01:46:02,399
saying change the Android libraries the

01:45:57,149 --> 01:46:03,719
native libraries to use mam ft this is

01:46:02,399 --> 01:46:06,929
what it would look like the android

01:46:03,719 --> 01:46:10,679
framework would use the the library

01:46:06,929 --> 01:46:16,050
unchanged at the interface level but it

01:46:10,679 --> 01:46:19,349
would instead use map teams and one of

01:46:16,050 --> 01:46:23,729
the big issues is that how do we deal

01:46:19,349 --> 01:46:29,239
with apps that don't don't go through

01:46:23,729 --> 01:46:29,239
the libraries but directly access Ashman

01:46:29,489 --> 01:46:34,980
so what can we do about that so one of

01:46:31,860 --> 01:46:37,860
the solutions is as far as to study the

01:46:34,980 --> 01:46:40,770
problem by adding I see in the next

01:46:37,860 --> 01:46:48,480
rules and auditing and seeing who's

01:46:40,770 --> 01:46:50,850
using it and yes we work with whoever is

01:46:48,480 --> 01:46:55,230
using them directly in this way and have

01:46:50,850 --> 01:46:58,350
them move away from it after a while we

01:46:55,230 --> 01:47:00,570
can maybe make it more strict and change

01:46:58,350 --> 01:47:02,880
the SELinux toast actually deny access

01:47:00,570 --> 01:47:05,969
so that was one of the suggestions we

01:47:02,880 --> 01:47:08,730
got and then finally at some point in

01:47:05,969 --> 01:47:10,680
the future when nobody is using it all

01:47:08,730 --> 01:47:14,610
the apps are using the new interface

01:47:10,680 --> 01:47:19,500
then we can possibly just remove the

01:47:14,610 --> 01:47:20,790
driver the back-up plan is in case there

01:47:19,500 --> 01:47:23,700
are apps that are just not getting

01:47:20,790 --> 01:47:26,310
updated and the worst case scenario that

01:47:23,700 --> 01:47:29,040
we were thinking of writing a very small

01:47:26,310 --> 01:47:31,050
driver that does not have the pinning

01:47:29,040 --> 01:47:33,690
unpinning support which we have

01:47:31,050 --> 01:47:35,610
deprecated anyway but it but still makes

01:47:33,690 --> 01:47:39,540
the API work and move there out of

01:47:35,610 --> 01:47:40,920
staging and into drivers Android so

01:47:39,540 --> 01:47:43,010
probably Craig would have something to

01:47:40,920 --> 01:47:43,010
say

01:47:53,710 --> 01:47:58,910
not breaking user space eh guys

01:47:55,790 --> 01:48:00,620
important I understand that but if

01:47:58,910 --> 01:48:01,719
you're implementing something that you

01:48:00,620 --> 01:48:06,560
know is broken

01:48:01,719 --> 01:48:33,710
why oh I add it back right because you

01:48:06,560 --> 01:48:37,190
know I mean right but haven't you

01:48:33,710 --> 01:48:39,200
protected raw access to dev and Android

01:48:37,190 --> 01:48:40,640
for a long time I mean you just pay some

01:48:39,200 --> 01:48:43,610
shouldn't be able to do that they

01:48:40,640 --> 01:48:52,400
shouldn't have the permission really

01:48:43,610 --> 01:48:54,080
user space apps could do that but binder

01:48:52,400 --> 01:48:56,469
I thought was at least went through lib

01:48:54,080 --> 01:48:56,469
binder

01:49:17,280 --> 01:49:22,540
you're guaranteed that all the accesses

01:49:20,200 --> 01:49:25,660
to ashram are not coming why a library

01:49:22,540 --> 01:49:29,290
but are open coded but yeah ashram has

01:49:25,660 --> 01:49:31,470
always been open so yeah we will end up

01:49:29,290 --> 01:49:36,160
breaking user space if we do anything

01:49:31,470 --> 01:49:38,050
yeah so slightly different topic but are

01:49:36,160 --> 01:49:41,350
you planning like you're gonna add

01:49:38,050 --> 01:49:43,660
selinux rules to flag like those device

01:49:41,350 --> 01:49:45,850
those apps that actually open - mem

01:49:43,660 --> 01:49:47,140
directly are you planning on surfacing

01:49:45,850 --> 01:49:50,340
that through the Play Store or how are

01:49:47,140 --> 01:49:50,340
you planning on actually auditing that

01:50:04,500 --> 01:50:10,330
so are you planning on running every app

01:50:07,000 --> 01:50:17,020
in the Play Store and flagging looking

01:50:10,330 --> 01:50:20,470
at the kernel logs Oh dere ways - well

01:50:17,020 --> 01:50:22,090
like oh there are ways we can do in

01:50:20,470 --> 01:50:25,110
order to figure that out but the problem

01:50:22,090 --> 01:50:28,150
is how do we make sure that is

01:50:25,110 --> 01:50:32,740
deprecated because I don't think that's

01:50:28,150 --> 01:50:35,590
going to happen sooner than we get mem

01:50:32,740 --> 01:50:40,600
FD ready for replacement in lips oodles

01:50:35,590 --> 01:50:42,490
and so yes so the problem is how do we

01:50:40,600 --> 01:50:44,830
what's the what's our stopgap solution

01:50:42,490 --> 01:50:46,210
so would should we have like a wrapper

01:50:44,830 --> 01:50:49,360
driver that you were saying for the

01:50:46,210 --> 01:50:51,520
while we try to work on apps removing

01:50:49,360 --> 01:50:55,090
the open coded thing because that's the

01:50:51,520 --> 01:50:56,920
long tail I mean if you I mean I see no

01:50:55,090 --> 01:50:59,260
difference between this one and the

01:50:56,920 --> 01:51:01,420
small driver than what we have in

01:50:59,260 --> 01:51:03,100
drivers staging today I mean I said I'll

01:51:01,420 --> 01:51:10,780
leave it alone so you guys figure out

01:51:03,100 --> 01:51:12,400
how to do this but no but I mean so rip

01:51:10,780 --> 01:51:14,290
out pin and unpin support today from

01:51:12,400 --> 01:51:15,710
what we have once you get the emit MFT

01:51:14,290 --> 01:51:17,540
stuff though I've been working

01:51:15,710 --> 01:51:22,070
and go from there I mean if we can start

01:51:17,540 --> 01:51:24,830
deleting stuff I think I mentioned it

01:51:22,070 --> 01:51:26,510
somewhere that because yeah take out of

01:51:24,830 --> 01:51:28,640
take out a huge chunk of the driver that

01:51:26,510 --> 01:51:31,220
nobody's using keep the interface is it

01:51:28,640 --> 01:51:33,260
and then is it possible to keep the user

01:51:31,220 --> 01:51:37,000
space interface for Ashman but

01:51:33,260 --> 01:51:37,000
internally use memory FD all the way

01:51:37,420 --> 01:51:43,510
five minutes I don't I wish I don't

01:51:41,060 --> 01:51:46,070
think the API a lends itself to that

01:51:43,510 --> 01:51:48,020
well we're good a map use a space a pair

01:51:46,070 --> 01:51:50,030
to use mmmm FD anyway but you have no

01:51:48,020 --> 01:51:52,700
control over the file descriptor right

01:51:50,030 --> 01:51:54,830
in the user space we need to find

01:51:52,700 --> 01:51:57,770
descriptor yes I think it more I don't

01:51:54,830 --> 01:51:59,660
know but if you could rewrite it to do

01:51:57,770 --> 01:52:01,550
the same thing so internally use memory

01:51:59,660 --> 01:52:11,530
15 the driver by keeping the use user

01:52:01,550 --> 01:52:18,980
space the same it's kind of like

01:52:11,530 --> 01:52:22,190
babysitting user space well no this

01:52:18,980 --> 01:52:26,090
again this is a stopgap solution but but

01:52:22,190 --> 01:52:29,150
it gets rid of the wall the hope is it

01:52:26,090 --> 01:52:31,970
removes the Ashman code as it stands and

01:52:29,150 --> 01:52:34,070
it's basically a wrapper to maybe have

01:52:31,970 --> 01:52:37,090
declared like for example ion buffers

01:52:34,070 --> 01:52:37,090
are to be a member

01:52:41,870 --> 01:52:51,780
well it's been there I don't like that I

01:52:49,650 --> 01:52:53,400
mean ideally I'd like it to be deleted

01:52:51,780 --> 01:52:54,870
right because it's duplicating

01:52:53,400 --> 01:52:56,610
functionality we have belts or if you

01:52:54,870 --> 01:52:58,380
can rewrite it around mem F T there's

01:52:56,610 --> 01:53:00,690
also some fun things we can run user

01:52:58,380 --> 01:53:03,120
space code from modules in kernel space

01:53:00,690 --> 01:53:06,150
that way you might be able to wrap fun

01:53:03,120 --> 01:53:08,880
way I'll talk to you later about that if

01:53:06,150 --> 01:53:10,170
you want to just wrap it that way we

01:53:08,880 --> 01:53:13,260
might be able to keep the same kernel

01:53:10,170 --> 01:53:16,080
interface if I mean the problem is you

01:53:13,260 --> 01:53:18,360
have to keep this kernel API yes we made

01:53:16,080 --> 01:53:19,980
that guarantee so let's work and figure

01:53:18,360 --> 01:53:22,050
it out but doing the work that you have

01:53:19,980 --> 01:53:24,239
so far is great so future stuff doesn't

01:53:22,050 --> 01:53:26,850
touch it yeah if we can evolve over time

01:53:24,239 --> 01:53:28,650
and I'm not gonna delete it

01:53:26,850 --> 01:53:42,270
I know people use it I'd love to delete

01:53:28,650 --> 01:53:44,700
I on so I know parcel like what we use

01:53:42,270 --> 01:53:47,040
in binder to transfer stuff use this ash

01:53:44,700 --> 01:53:48,870
man when you go beyond like the typical

01:53:47,040 --> 01:53:50,460
buy no transaction windows if you pass

01:53:48,870 --> 01:53:52,920
like a block of a binder that's bigger

01:53:50,460 --> 01:53:53,610
than a megabyte it transparently uses

01:53:52,920 --> 01:53:55,830
ash mem

01:53:53,610 --> 01:53:58,200
so I wonder if this is a problem with

01:53:55,830 --> 01:54:00,000
treble where you know we going to update

01:53:58,200 --> 01:54:01,980
like the system partition to migrate to

01:54:00,000 --> 01:54:04,110
mem of T and you send something to

01:54:01,980 --> 01:54:06,060
vendor code and the vendor code still

01:54:04,110 --> 01:54:08,280
use the old Lib C utils and expects it

01:54:06,060 --> 01:54:12,150
to be an ash man file descriptor so

01:54:08,280 --> 01:54:13,950
that's a few you thought about or let's

01:54:12,150 --> 01:54:15,570
talk offline but yeah that's something I

01:54:13,950 --> 01:54:22,080
wanted about because there is this

01:54:15,570 --> 01:54:22,550
implicit assumption and yeah well yeah

01:54:22,080 --> 01:54:25,609
it can

01:54:22,550 --> 01:54:25,609
[Music]

01:54:27,620 --> 01:54:32,490
well but if you do it from new devices

01:54:29,940 --> 01:54:34,290
only than in your book yeah right but

01:54:32,490 --> 01:54:35,670
then that means you we're still gonna

01:54:34,290 --> 01:54:37,110
send the new version of system which

01:54:35,670 --> 01:54:38,880
uses nouvelle obscene utils to all

01:54:37,110 --> 01:54:41,070
devices - right but there is no old

01:54:38,880 --> 01:54:42,990
vendor everything is brand new so

01:54:41,070 --> 01:54:44,040
everything is talking to community okay

01:54:42,990 --> 01:54:46,200
but it means we need to have a version

01:54:44,040 --> 01:54:49,290
of system for all tender anew Fernando

01:54:46,200 --> 01:54:56,520
right yes which is what the VMDK would

01:54:49,290 --> 01:54:58,790
give you okay let's talk offline one

01:54:56,520 --> 01:54:58,790
minute

01:55:07,530 --> 01:55:15,110
it's right there I'm just a little sad

01:55:11,700 --> 01:55:15,110
that nobody really likes unpinning

01:55:15,560 --> 01:55:49,520
nobody seems to like unpinning but I

01:55:17,670 --> 01:55:57,660
thought it was so elegant so it's whoa I

01:55:49,520 --> 01:56:00,390
don't have anything I talked all about

01:55:57,660 --> 01:56:09,210
it in yesterday's but I'm gonna go

01:56:00,390 --> 01:56:12,240
through that out of three Hardware

01:56:09,210 --> 01:56:14,100
supporting code pretty much every single

01:56:12,240 --> 01:56:19,020
Android device has millions and millions

01:56:14,100 --> 01:56:20,760
of lines of those how can we do or deal

01:56:19,020 --> 01:56:22,500
with it and while you carrying kernel

01:56:20,760 --> 01:56:23,520
updates with Android Pickers and where

01:56:22,500 --> 01:56:25,050
it has the problem baby

01:56:23,520 --> 01:56:26,790
pretty much carrying about five to six

01:56:25,050 --> 01:56:30,960
pounds I think to give you a perspective

01:56:26,790 --> 01:56:35,600
I think we still have three ten which is

01:56:30,960 --> 01:56:41,460
which was released in 2013

01:56:35,600 --> 01:56:43,980
so with project trouble with what we

01:56:41,460 --> 01:56:47,040
ended up doing GSI which is what we call

01:56:43,980 --> 01:56:49,410
generic system image and we use that

01:56:47,040 --> 01:56:53,310
system image that is built on most out

01:56:49,410 --> 01:56:54,630
of the USP code and but the project type

01:56:53,310 --> 01:56:56,280
of the implementation is verified by

01:56:54,630 --> 01:56:59,130
basically putting that system image on

01:56:56,280 --> 01:57:00,650
any Android device that pretty much

01:56:59,130 --> 01:57:02,500
verifies all the interfaces between

01:57:00,650 --> 01:57:05,320
platform and the rendering

01:57:02,500 --> 01:57:08,170
mutation are implemented correctly we

01:57:05,320 --> 01:57:10,720
also run a couple of tests Suites on top

01:57:08,170 --> 01:57:13,410
of a device that's booted with GSI so

01:57:10,720 --> 01:57:16,600
that basically proves the entire idea

01:57:13,410 --> 01:57:18,610
project triple where we have stable

01:57:16,600 --> 01:57:20,350
interfaces across platform and vendor

01:57:18,610 --> 01:57:22,630
and then so that means we can move

01:57:20,350 --> 01:57:25,090
platform forward as long as we are not

01:57:22,630 --> 01:57:27,310
breaking those interfaces without having

01:57:25,090 --> 01:57:33,160
to update anything from the hot a

01:57:27,310 --> 01:57:35,320
specific function the gtii in that case

01:57:33,160 --> 01:57:37,360
we wanted to explore the option where

01:57:35,320 --> 01:57:40,870
can we do that with the kernel because

01:57:37,360 --> 01:57:44,560
we really don't want or like maintaining

01:57:40,870 --> 01:57:46,270
310 kernel in 2080 for example which is

01:57:44,560 --> 01:57:49,120
five years old we are maintaining six of

01:57:46,270 --> 01:57:51,940
them at the same time and so we started

01:57:49,120 --> 01:57:54,250
on this study about is it possible or

01:57:51,940 --> 01:57:56,320
can we start small can we maybe start

01:57:54,250 --> 01:58:00,970
with the signal architecture say on 64

01:57:56,320 --> 01:58:03,460
which we know was written pretty much to

01:58:00,970 --> 01:58:06,100
be at least the CPU core was written

01:58:03,460 --> 01:58:08,290
pretty much to be as runtime

01:58:06,100 --> 01:58:09,700
configurable or as and pretty much

01:58:08,290 --> 01:58:11,470
everything is detected in the boot at

01:58:09,700 --> 01:58:13,270
the boot time but we are not sure

01:58:11,470 --> 01:58:14,770
whether everything is we I went through

01:58:13,270 --> 01:58:16,510
we went through a bunch of small

01:58:14,770 --> 01:58:20,500
subsystems all of them are configurable

01:58:16,510 --> 01:58:22,180
through device free but there are big

01:58:20,500 --> 01:58:23,770
subsystems and I know Alice is going to

01:58:22,180 --> 01:58:29,680
talk about hearing came as the display

01:58:23,770 --> 01:58:31,930
camera graphics are there any other

01:58:29,680 --> 01:58:33,190
associate that needs something core in

01:58:31,930 --> 01:58:34,450
the upstream kernel right now that's

01:58:33,190 --> 01:58:36,940
just completely missing which go

01:58:34,450 --> 01:58:39,630
basically stop them from booting I know

01:58:36,940 --> 01:58:42,490
there are a whole bunch of non

01:58:39,630 --> 01:58:43,890
architecture or non-associated where

01:58:42,490 --> 01:58:47,980
specific changes that every single

01:58:43,890 --> 01:58:49,390
kernel has and we welcome that that's

01:58:47,980 --> 01:58:51,460
that's absolutely fine

01:58:49,390 --> 01:58:52,960
but what we are trying to find out or

01:58:51,460 --> 01:58:54,620
what I'm trying to gauge and this is

01:58:52,960 --> 01:58:57,050
basically

01:58:54,620 --> 01:59:01,250
for a question is is it feasible as

01:58:57,050 --> 01:59:04,280
after a what do we see as possible

01:59:01,250 --> 01:59:06,770
blocking issues I just picked up two of

01:59:04,280 --> 01:59:08,870
the display cameras do some two of them

01:59:06,770 --> 01:59:10,490
that I worried about what what else are

01:59:08,870 --> 01:59:12,830
we missing is there for example I'm

01:59:10,490 --> 01:59:17,120
sixty-four see people is it all there

01:59:12,830 --> 01:59:18,680
does it cover all the variant does talk

01:59:17,120 --> 01:59:23,270
framework cover everything I actually

01:59:18,680 --> 01:59:25,310
don't know so I ask you does do we have

01:59:23,270 --> 01:59:28,760
all the support needed for power

01:59:25,310 --> 01:59:31,450
management for paintings for regulators

01:59:28,760 --> 01:59:33,620
is that can we not all be configured and

01:59:31,450 --> 01:59:36,400
through device free so the kernel

01:59:33,620 --> 01:59:39,710
basically just boots

01:59:36,400 --> 01:59:43,180
obviously this assumes that anything

01:59:39,710 --> 01:59:44,330
that is needed to the generic curve is

01:59:43,180 --> 01:59:46,310
loadable

01:59:44,330 --> 01:59:48,470
as kernel module which means you need

01:59:46,310 --> 01:59:51,050
find systems and in which case the any

01:59:48,470 --> 01:59:52,190
tardy basically ends up playing that

01:59:51,050 --> 01:59:53,840
role as well where you don't actually

01:59:52,190 --> 01:59:55,670
need the storage you can basically have

01:59:53,840 --> 01:59:57,980
those kernel modules in the in Atari as

01:59:55,670 --> 02:00:00,350
long as you can put two in it so what we

01:59:57,980 --> 02:00:02,600
are looking for is basically put two in

02:00:00,350 --> 02:00:04,970
it can we put two in it on any arm 64

02:00:02,600 --> 02:00:07,580
CPU today and if we can put two in it

02:00:04,970 --> 02:00:09,620
then anything else that you need from

02:00:07,580 --> 02:00:11,240
then onwards to boot and void can be

02:00:09,620 --> 02:00:13,670
loaded as core module as long as you

02:00:11,240 --> 02:00:15,680
have support for device tree to specify

02:00:13,670 --> 02:00:19,150
those things and that's pretty much the

02:00:15,680 --> 02:00:21,500
question we've been looking at that

02:00:19,150 --> 02:00:24,490
we've gone through a couple of subsystem

02:00:21,500 --> 02:00:24,490
but we still don't know anything

02:00:25,460 --> 02:00:31,020
if you see this as a problem or you see

02:00:29,070 --> 02:00:32,160
or you think obscure no it's already

02:00:31,020 --> 02:00:34,700
ready for this and we should basically

02:00:32,160 --> 02:00:34,700
go ahead and

02:00:40,940 --> 02:00:46,170
so in order to have a generic Colonel

02:00:44,130 --> 02:00:48,510
don't you need like a guaranteed ABI

02:00:46,170 --> 02:00:53,150
between modules and the kernel itself

02:00:48,510 --> 02:00:55,949
and what do maintainer think about that

02:00:53,150 --> 02:00:57,690
so this is a generic kernel interface so

02:00:55,949 --> 02:00:59,849
think of this as an enterprise kernel I

02:00:57,690 --> 02:01:03,119
got red hat enterprise kernel right they

02:00:59,849 --> 02:01:04,619
say we're going this way and then they

02:01:03,119 --> 02:01:05,969
also make a guarantee these certain

02:01:04,619 --> 02:01:07,710
api's aren't going to change so you

02:01:05,969 --> 02:01:09,690
don't have to rebuild modules but let's

02:01:07,710 --> 02:01:11,579
just try and see can we boot everything

02:01:09,690 --> 02:01:21,389
as a model today then let's take the

02:01:11,579 --> 02:01:25,619
next step of the answer is an all mod

02:01:21,389 --> 02:01:29,280
config kernel almost boots on a lot of

02:01:25,619 --> 02:01:31,110
platforms and that's mostly stupid

02:01:29,280 --> 02:01:33,690
options that get turned on by default

02:01:31,110 --> 02:01:36,409
when you run all mod config we don't

02:01:33,690 --> 02:01:43,429
actually want to turn on rather than

02:01:36,409 --> 02:01:43,429
drivers so the answer should be yes

02:01:48,289 --> 02:01:54,630
maybe maybe some platforms do but the

02:01:51,719 --> 02:01:57,179
the kernel shouldn't what about security

02:01:54,630 --> 02:01:59,099
engines for example do you need to talk

02:01:57,179 --> 02:02:01,320
to a security engine and SOC specific

02:01:59,099 --> 02:02:15,960
wait before you start running the stuff

02:02:01,320 --> 02:02:17,570
from the RAM disk when you're not

02:02:15,960 --> 02:02:20,219
necessarily verifiably but things like

02:02:17,570 --> 02:02:22,260
any kind of IPC channel establishment

02:02:20,219 --> 02:02:23,280
with trust with the trust zone something

02:02:22,260 --> 02:02:25,139
is running on a trusted own or the

02:02:23,280 --> 02:02:26,670
secure element I don't know there a lot

02:02:25,139 --> 02:02:28,380
of them are also again associate

02:02:26,670 --> 02:02:29,909
specific I don't know I know it could

02:02:28,380 --> 02:02:32,699
those be modules and would it be valid

02:02:29,909 --> 02:02:36,079
to load them up and it's the first time

02:02:32,699 --> 02:02:38,369
actually worried about having drivers as

02:02:36,079 --> 02:02:39,929
modules I know that's going to be

02:02:38,369 --> 02:02:43,469
feasible what I'm worried about is

02:02:39,929 --> 02:02:44,909
subsystems not having say enough

02:02:43,469 --> 02:02:47,550
exported signal in order for those

02:02:44,909 --> 02:02:49,229
drivers to function that way or device

02:02:47,550 --> 02:02:58,050
you bindings that don't exist or we

02:02:49,229 --> 02:03:02,880
don't we need more I'm just surprised

02:02:58,050 --> 02:03:05,489
you think this would be a problem the

02:03:02,880 --> 02:03:08,639
goal of farm 64 was to make this work I

02:03:05,489 --> 02:03:14,070
don't think anybody's tested this you

02:03:08,639 --> 02:03:15,749
wait I'm 64 in this we know people I

02:03:14,070 --> 02:03:17,880
mean the reason I know about all mod

02:03:15,749 --> 02:03:20,420
configures there's somebody at Leonora

02:03:17,880 --> 02:03:23,369
has been testing that for test purposes

02:03:20,420 --> 02:03:28,530
I'm related to like deploying in

02:03:23,369 --> 02:03:30,059
production so I guess the big question

02:03:28,530 --> 02:03:32,849
is if it works today

02:03:30,059 --> 02:03:34,469
then we can tell the SOC vendors you're

02:03:32,849 --> 02:03:38,639
2.5 million lines of code better not

02:03:34,469 --> 02:03:39,900
break that assumption yes that's the

02:03:38,639 --> 02:03:42,300
part of the coin and that's that's the

02:03:39,900 --> 02:03:44,929
big key and that's would be the good

02:03:42,300 --> 02:03:47,130
that would help them clean up their code

02:03:44,929 --> 02:03:49,349
and if it doesn't work today it's

02:03:47,130 --> 02:03:53,249
probably more in the small bugs somebody

02:03:49,349 --> 02:03:55,619
can fix level than anything nice I mean

02:03:53,249 --> 02:03:57,119
the the building stuff is modules is

02:03:55,619 --> 02:03:59,940
covered by all the build coverage stuff

02:03:57,119 --> 02:04:02,249
that's like export symbols and stuff are

02:03:59,940 --> 02:04:03,659
fine and the device tree stuff is

02:04:02,249 --> 02:04:18,090
unaffected by whether you're building

02:04:03,659 --> 02:04:20,280
modular so there are processors that are

02:04:18,090 --> 02:04:23,039
put in with at the same time and you

02:04:20,280 --> 02:04:25,469
basically because of you dealing it

02:04:23,039 --> 02:04:26,789
everything up until in it runs now

02:04:25,469 --> 02:04:28,289
you're dealing in the world boot

02:04:26,789 --> 02:04:29,610
sequence and those core processors are

02:04:28,289 --> 02:04:32,190
also actually responsible for turning

02:04:29,610 --> 02:04:33,719
your crops for example and then that all

02:04:32,190 --> 02:04:34,540
works because everything is baked into

02:04:33,719 --> 02:04:36,400
the kernel

02:04:34,540 --> 02:04:38,020
is all of that right-hander Putin before

02:04:36,400 --> 02:04:39,370
anything happens and now all of that is

02:04:38,020 --> 02:04:41,740
not going to happen if there are such

02:04:39,370 --> 02:04:43,180
assumptions made for some platforms not

02:04:41,740 --> 02:04:47,770
an option but for some platforms and

02:04:43,180 --> 02:04:50,560
then they yeah what I can see is some

02:04:47,770 --> 02:04:52,210
things we have implicit dependencies

02:04:50,560 --> 02:04:55,270
between drivers like that that aren't

02:04:52,210 --> 02:04:57,370
described that just happens by luck to

02:04:55,270 --> 02:04:58,840
work in a monolithic kernel right I

02:04:57,370 --> 02:05:03,490
would consider it out a bug no matter

02:04:58,840 --> 02:05:05,020
what yes oh yeah to what extent can we

02:05:03,490 --> 02:05:08,730
assume that the bootloader will take

02:05:05,020 --> 02:05:20,050
care of this baseline configuration

02:05:08,730 --> 02:05:23,050
before handing over to the kernel I mean

02:05:20,050 --> 02:05:25,000
if you're booting from an RD then it

02:05:23,050 --> 02:05:27,070
doesn't really matter the boot what the

02:05:25,000 --> 02:05:30,630
bootloader is doing is the same no

02:05:27,070 --> 02:05:33,790
matter whether it was booting modular or

02:05:30,630 --> 02:05:36,460
built in it's still the bootloader is

02:05:33,790 --> 02:05:38,320
handing the it's starting the kernel and

02:05:36,460 --> 02:05:41,410
saying here is a block of memory with

02:05:38,320 --> 02:05:43,090
the innatron disk in it I mean so long

02:05:41,410 --> 02:05:47,050
as the ROM works you're probably fine

02:05:43,090 --> 02:05:49,630
hopefully so in terms of who's actually

02:05:47,050 --> 02:05:51,730
testing stuff like this kernel CI today

02:05:49,630 --> 02:05:54,010
actually is testing the the boot to ram

02:05:51,730 --> 02:05:56,110
disk model with the kind of the upstream

02:05:54,010 --> 02:05:58,030
def config for arm 64 the boot to ram

02:05:56,110 --> 02:06:00,760
disk is like our baseline minimum so on

02:05:58,030 --> 02:06:02,260
the on the 20 or 30 different arm 64

02:06:00,760 --> 02:06:03,610
platforms that are already in kernel CI

02:06:02,260 --> 02:06:05,710
this is this just works

02:06:03,610 --> 02:06:07,630
but remember DEFCON think has a bunch of

02:06:05,710 --> 02:06:09,880
stuff built in yeah yeah but def config

02:06:07,630 --> 02:06:12,220
has it's still kind of a smaller size I

02:06:09,880 --> 02:06:13,810
am fit and we have been trying all mod

02:06:12,220 --> 02:06:15,940
config but you actually need all mod

02:06:13,810 --> 02:06:25,570
config plus a few other things turn back

02:06:15,940 --> 02:06:30,430
on in order to do basic basically I'm 64

02:06:25,570 --> 02:06:32,350
with yeah yeah that's that's basically

02:06:30,430 --> 02:06:35,310
the that's what kernel CI does today on

02:06:32,350 --> 02:06:35,310
all the arm 64

02:06:37,260 --> 02:06:43,919
this is all mod config produced stable

02:06:41,550 --> 02:06:56,189
outputs like if you run it twice is

02:06:43,919 --> 02:06:57,539
guaranteed to yes yes but yes I was just

02:06:56,189 --> 02:07:00,300
thinking you mentioned that there are

02:06:57,539 --> 02:07:02,550
conflicting options that get toggled not

02:07:00,300 --> 02:07:02,909
the way that we that's stable but all

02:07:02,550 --> 02:07:05,099
right

02:07:02,909 --> 02:07:07,709
so does it make sense for K conflict to

02:07:05,099 --> 02:07:18,269
be enhanced in order to call these out

02:07:07,709 --> 02:07:19,829
at the moment specific ones you need to

02:07:18,269 --> 02:07:21,629
build your platform and you make a def

02:07:19,829 --> 02:07:23,070
config for your platform you make a diff

02:07:21,629 --> 02:07:24,780
config here's a few things that are

02:07:23,070 --> 02:07:26,639
enabled even x86 is that way I don't

02:07:24,780 --> 02:07:28,859
know if x86 can build on all mod config

02:07:26,639 --> 02:07:30,929
I mean the the obvious the obvious thing

02:07:28,859 --> 02:07:32,699
is like you do all mod config in even

02:07:30,929 --> 02:07:34,530
your drive old drivers for serial

02:07:32,699 --> 02:07:36,209
console get to turn into modules so you

02:07:34,530 --> 02:07:37,590
can't actually boot and see any serial

02:07:36,209 --> 02:07:38,639
output so you might be booting but

02:07:37,590 --> 02:07:41,159
you're not getting anything that's

02:07:38,639 --> 02:07:43,949
detectable by the test framework so yeah

02:07:41,159 --> 02:07:45,539
so there's just a few loose um actual

02:07:43,949 --> 02:07:48,149
minimal things that you want to built-in

02:07:45,539 --> 02:07:50,030
in order to to boot even and and there's

02:07:48,149 --> 02:07:53,070
also some things that all mod like

02:07:50,030 --> 02:07:55,229
select selections for me noms and from

02:07:53,070 --> 02:07:57,030
choices and things they all mod called

02:07:55,229 --> 02:07:58,349
fake does they're just really stupid

02:07:57,030 --> 02:08:00,590
that you would never do in production

02:07:58,349 --> 02:08:00,590
yeah

02:08:00,709 --> 02:08:08,189
even it's just a built test can an all

02:08:04,320 --> 02:08:11,189
mod config cause certain pieces of code

02:08:08,189 --> 02:08:14,359
to not be built right so then so even as

02:08:11,189 --> 02:08:14,359
a build test is not giving us

02:08:25,210 --> 02:08:38,290
we can only have one memory allocation

02:08:28,280 --> 02:08:38,290
over three minutes someone in the back

02:08:52,100 --> 02:08:57,900
yeah just in terms of subsystems there

02:08:56,190 --> 02:09:00,900
you've got the flood displaying graphic

02:08:57,900 --> 02:09:02,910
stuff one subsystem that at the moment

02:09:00,900 --> 02:09:06,210
cannot possibly be multi that is the

02:09:02,910 --> 02:09:10,920
iommu on which a lot of the display and

02:09:06,210 --> 02:09:12,870
media peripherals might depend on now in

02:09:10,920 --> 02:09:14,790
theory it's it's okay to build a kernel

02:09:12,870 --> 02:09:17,220
today with all of the possible I mean

02:09:14,790 --> 02:09:19,710
your drivers built in 164 yeah they

02:09:17,220 --> 02:09:21,570
won't fight with each other but that

02:09:19,710 --> 02:09:23,430
doesn't mean then you've got you've got

02:09:21,570 --> 02:09:25,500
to build the kernel for all of the

02:09:23,430 --> 02:09:33,000
currently known devices and can't add

02:09:25,500 --> 02:09:39,540
them later one of those systems so don't

02:09:33,000 --> 02:09:43,050
calls into drivers go but the the the

02:09:39,540 --> 02:09:44,580
implementation of I am mu was still a

02:09:43,050 --> 02:09:46,140
register and register interface into a

02:09:44,580 --> 02:09:48,140
core subsystem and if that's not the

02:09:46,140 --> 02:09:50,340
case tonight

02:09:48,140 --> 02:09:52,740
yeah the drive is register themselves

02:09:50,340 --> 02:09:55,290
into the core subsystem the problem is

02:09:52,740 --> 02:09:59,520
then the device is behind the I remember

02:09:55,290 --> 02:10:03,000
use depend on the arm you drive it being

02:09:59,520 --> 02:10:04,500
detected first so you will end up not

02:10:03,000 --> 02:10:06,510
Pro being any of your graphic stuff

02:10:04,500 --> 02:10:08,190
until in it and then you'll give up

02:10:06,510 --> 02:10:10,560
because there's no I'm mu driver and

02:10:08,190 --> 02:10:12,090
then if you do load those they will have

02:10:10,560 --> 02:10:13,740
to work without the arm mu which

02:10:12,090 --> 02:10:15,720
generally means they won't work very

02:10:13,740 --> 02:10:17,790
well but then do we have a case where

02:10:15,720 --> 02:10:20,190
IMM use would be driver would be needed

02:10:17,790 --> 02:10:24,870
and needed for boot to Brandis for

02:10:20,190 --> 02:10:27,090
example I probably know on mobile well

02:10:24,870 --> 02:10:29,370
in that case then we can load I mean in

02:10:27,090 --> 02:10:32,520
your driver first followed by the rest

02:10:29,370 --> 02:10:34,920
of the papers if it's if it's all built

02:10:32,520 --> 02:10:36,390
in yes looks like currently it's

02:10:34,920 --> 02:10:39,740
impossible to go there anything as a

02:10:36,390 --> 02:10:39,740
module they know mu

02:10:44,739 --> 02:10:49,360
there's some hilarity with how we figure

02:10:47,260 --> 02:10:51,100
out whether there's an IMU in use as

02:10:49,360 --> 02:10:56,219
well which I can't remember anybody

02:10:51,100 --> 02:10:56,219
fixed which required it to be built in

02:10:58,110 --> 02:11:13,390
well yes they are yeah yeah but then how

02:11:10,870 --> 02:11:14,860
does DME buff when the buffer is being

02:11:13,390 --> 02:11:16,900
transferred from one device to the other

02:11:14,860 --> 02:11:18,850
would it automatically get mapped into

02:11:16,900 --> 02:11:20,700
the device's address space why I'm a me

02:11:18,850 --> 02:11:24,940
driver if I mention real device thing

02:11:20,700 --> 02:11:28,420
sort of odd but not that familiar with

02:11:24,940 --> 02:11:31,840
the wide ear my buff works but I believe

02:11:28,420 --> 02:11:36,570
it should they should automatically

02:11:31,840 --> 02:11:39,280
handle this where necessary yeah the

02:11:36,570 --> 02:11:47,950
other driver has to actually call the

02:11:39,280 --> 02:11:49,180
DME map in okay to map it on the one

02:11:47,950 --> 02:11:51,190
other question ahead is like for the

02:11:49,180 --> 02:11:55,210
clock in power do you see that as well

02:11:51,190 --> 02:11:57,400
as you know being part of modules oh yes

02:11:55,210 --> 02:11:59,950
anything apart from what you need to run

02:11:57,400 --> 02:12:01,330
for example because you know for CPU

02:11:59,950 --> 02:12:02,800
itself you're doing boot up you know

02:12:01,330 --> 02:12:04,480
there's usually cases where they want to

02:12:02,800 --> 02:12:06,820
bump up the frequencies and stuff and so

02:12:04,480 --> 02:12:07,810
there's some minimal clock power I'm

02:12:06,820 --> 02:12:09,520
sure I'm gonna have to cut you off

02:12:07,810 --> 02:12:11,320
because we're really out of time so I'll

02:12:09,520 --> 02:12:15,420
cause you guys to pick this up a person

02:12:11,320 --> 02:12:15,420
named Cindy Alastair

02:12:21,949 --> 02:12:34,120
so DRM kms r android if I could find my

02:12:26,090 --> 02:12:34,120
mouse all yours

02:12:46,390 --> 02:12:50,540
hi my name is Alice truck and I work for

02:12:49,820 --> 02:12:51,970
Google

02:12:50,540 --> 02:12:58,820
I just wanted to talk to you guys about

02:12:51,970 --> 02:13:00,650
DRM kms for Android and I looked back a

02:12:58,820 --> 02:13:01,900
few other presentations I've be done

02:13:00,650 --> 02:13:03,770
over the years about this subject

02:13:01,900 --> 02:13:06,440
obviously there's been a lot of interest

02:13:03,770 --> 02:13:08,030
in dear M kms for Android but there

02:13:06,440 --> 02:13:10,910
hasn't been a whole lot of action in

02:13:08,030 --> 02:13:13,160
actually implementing it so one of the

02:13:10,910 --> 02:13:15,530
things I was just going to go through is

02:13:13,160 --> 02:13:16,910
exactly why we want to use DRM kms why

02:13:15,530 --> 02:13:20,000
is the problem today that we don't use

02:13:16,910 --> 02:13:23,000
it and what's happened over the last few

02:13:20,000 --> 02:13:28,580
years with DRM kms and kind of where we

02:13:23,000 --> 02:13:31,040
want to get to so this is kind of a

02:13:28,580 --> 02:13:33,440
classic thing you'll see on most arm or

02:13:31,040 --> 02:13:37,070
most shipping Android implementations

02:13:33,440 --> 02:13:38,870
you'll have an IP provider or the SOC

02:13:37,070 --> 02:13:40,670
manufacturer Walsh will provide the 3d

02:13:38,870 --> 02:13:42,290
core the 3d graphics driver the video

02:13:40,670 --> 02:13:44,570
driver the display driver to scaler and

02:13:42,290 --> 02:13:46,370
everything will all be built in is some

02:13:44,570 --> 02:13:48,260
kind of mega driver or there might be

02:13:46,370 --> 02:13:50,420
separate drivers but they won't be using

02:13:48,260 --> 02:13:52,070
standard kernel interfaces and they'll

02:13:50,420 --> 02:13:54,620
have some kind of proprietary interface

02:13:52,070 --> 02:13:56,060
that runs between kernel user space and

02:13:54,620 --> 02:13:58,730
this is not a problem for Android

02:13:56,060 --> 02:14:00,260
because Android doesn't specify that you

02:13:58,730 --> 02:14:03,020
have to use any particular kernel

02:14:00,260 --> 02:14:04,880
interface and the Hal abstraction layer

02:14:03,020 --> 02:14:07,220
allows you to hide this behind the

02:14:04,880 --> 02:14:08,470
growler kind of harbor compose a module

02:14:07,220 --> 02:14:10,820
[Music]

02:14:08,470 --> 02:14:14,210
but this does cause problems for us

02:14:10,820 --> 02:14:14,990
because in based on what sandy was just

02:14:14,210 --> 02:14:17,350
saying about gki

02:14:14,990 --> 02:14:20,480
we don't really want to have so much

02:14:17,350 --> 02:14:23,120
custom code running inside modules

02:14:20,480 --> 02:14:25,400
because if it's a security problem found

02:14:23,120 --> 02:14:27,350
or there's some other capability that we

02:14:25,400 --> 02:14:29,600
want to add we should be able to do that

02:14:27,350 --> 02:14:31,270
in the kernel in the core kernel rather

02:14:29,600 --> 02:14:33,890
than having to do it in driver modules

02:14:31,270 --> 02:14:35,840
which we would obviously prefer not to

02:14:33,890 --> 02:14:37,760
touch and there are other reasons as

02:14:35,840 --> 02:14:40,600
well while white dieren kms is the right

02:14:37,760 --> 02:14:40,600
thing to do

02:14:40,920 --> 02:14:48,640
so as I said there's no requirements

02:14:44,080 --> 02:14:51,120
standardized in in Android most shipping

02:14:48,640 --> 02:14:54,160
implementations are still using FB dev

02:14:51,120 --> 02:14:55,600
we code duplication is problem

02:14:54,160 --> 02:14:56,920
everybody implements their own display

02:14:55,600 --> 02:14:59,380
code their own synchronization

02:14:56,920 --> 02:15:02,400
mechanisms their own communication paths

02:14:59,380 --> 02:15:06,060
with GPU and and vtu

02:15:02,400 --> 02:15:08,200
there's not really any reason for that

02:15:06,060 --> 02:15:09,520
these drivers aren't live stream and

02:15:08,200 --> 02:15:11,770
obviously be great if they were because

02:15:09,520 --> 02:15:13,300
a lot of a lot of devices with AOSP for

02:15:11,770 --> 02:15:14,800
example you can build the kernel and the

02:15:13,300 --> 02:15:17,500
user space for them but then you can't

02:15:14,800 --> 02:15:19,360
actually see the graphics without blobs

02:15:17,500 --> 02:15:21,490
or without additional drivers to the

02:15:19,360 --> 02:15:23,620
kernel and you certainly can't be non

02:15:21,490 --> 02:15:25,360
SSE kernels on those devices because you

02:15:23,620 --> 02:15:28,990
will lack these multimedia drivers so

02:15:25,360 --> 02:15:30,550
upstream is good and and another thing

02:15:28,990 --> 02:15:32,350
that's important to us is the ability to

02:15:30,550 --> 02:15:33,670
actually test and debug display drivers

02:15:32,350 --> 02:15:36,010
which currently we really can't do

02:15:33,670 --> 02:15:39,900
because of these proprietary interfaces

02:15:36,010 --> 02:15:45,640
that are being used for display

02:15:39,900 --> 02:15:49,050
so back in 2013 Calabria and when are on

02:15:45,640 --> 02:15:52,420
Google all work together to merge the

02:15:49,050 --> 02:15:54,040
destacia to sync driver and merge DRM

02:15:52,420 --> 02:15:58,690
KMS explicit fencing with support and

02:15:54,040 --> 02:16:00,670
then on the Google side we enabled the

02:15:58,690 --> 02:16:03,160
non-speculative fencing capability in

02:16:00,670 --> 02:16:04,990
the harbor composer 2 API which would

02:16:03,160 --> 02:16:07,270
have which opened the door to actually

02:16:04,990 --> 02:16:08,650
supporting DRM kms but then

02:16:07,270 --> 02:16:11,590
unfortunately because the changes went

02:16:08,650 --> 02:16:13,810
into 410 and not 49 they weren't in the

02:16:11,590 --> 02:16:15,820
fallen LTS so a lot of partners didn't

02:16:13,810 --> 02:16:19,930
have those changes and we ended up back

02:16:15,820 --> 02:16:22,600
porting them in may pixel 1 shipped with

02:16:19,930 --> 02:16:25,960
the original frame of the driver and

02:16:22,600 --> 02:16:29,500
they multi snapdragon frame buffer

02:16:25,960 --> 02:16:32,050
driver and then unfortunately again in

02:16:29,500 --> 02:16:34,240
October 2017 pixel 2 again shipped with

02:16:32,050 --> 02:16:37,530
FB dev even though we had the capability

02:16:34,240 --> 02:16:40,110
to do something with DRM kms

02:16:37,530 --> 02:16:42,179
and but finally now in October 2018

02:16:40,110 --> 02:16:45,840
we've shipped a deer and drive a deer on

02:16:42,179 --> 02:16:49,380
KMS driver on cork on SS ease which is

02:16:45,840 --> 02:16:51,300
great but what's interesting about this

02:16:49,380 --> 02:16:53,519
is that because we have a sliding three

02:16:51,300 --> 02:16:54,780
kernel support window for Android when

02:16:53,519 --> 02:16:56,160
we get to Android which key will

02:16:54,780 --> 02:16:58,050
although we have to support for an hour

02:16:56,160 --> 02:17:01,769
for 14 and for 19 and all those kernels

02:16:58,050 --> 02:17:03,150
will have DRM kms capability because it

02:17:01,769 --> 02:17:06,450
will all have that in our fencing model

02:17:03,150 --> 02:17:07,769
that's required for our composing too so

02:17:06,450 --> 02:17:12,480
hopefully we'll have deer and everywhere

02:17:07,769 --> 02:17:15,080
at some point so this is the new model

02:17:12,480 --> 02:17:17,670
that we'd like to see we'd like to see

02:17:15,080 --> 02:17:20,490
the core kernel D around subsystem

02:17:17,670 --> 02:17:22,230
display driver be upstream and the 3d

02:17:20,490 --> 02:17:23,820
driver we're not really trying to attach

02:17:22,230 --> 02:17:25,410
that at the moment obviously we would

02:17:23,820 --> 02:17:27,630
have to support DRM render nodes to work

02:17:25,410 --> 02:17:29,519
with the display and then the video

02:17:27,630 --> 02:17:32,760
codec and scaler are problems that won't

02:17:29,519 --> 02:17:34,320
be solved at a later time the Lib DRM

02:17:32,760 --> 02:17:35,910
the growl at module and the DRM harbour

02:17:34,320 --> 02:17:37,440
composer module can then be provided

02:17:35,910 --> 02:17:38,550
from a generic source of the vendor

02:17:37,440 --> 02:17:42,000
doesn't need to differentiate these

02:17:38,550 --> 02:17:43,050
components and in fact one thing that we

02:17:42,000 --> 02:17:44,370
are actually looking at as well as

02:17:43,050 --> 02:17:46,110
whether we could actually get rid of the

02:17:44,370 --> 02:17:47,940
dear mr the composer altogether and just

02:17:46,110 --> 02:17:50,630
do everything call everything from the

02:17:47,940 --> 02:17:50,630
framework itself

02:17:52,000 --> 02:17:56,690
so we'll end up with one display driver

02:17:54,770 --> 02:18:02,300
interface for Android more share code

02:17:56,690 --> 02:18:03,740
better debugging and a better a better

02:18:02,300 --> 02:18:06,650
mechanism for testing and standardized

02:18:03,740 --> 02:18:08,000
mapping metasoma testimony Sosa's

02:18:06,650 --> 02:18:10,220
one of the key things that we're

02:18:08,000 --> 02:18:12,650
thinking about adding is bringing the

02:18:10,220 --> 02:18:16,850
Intel GPU tools test suite into Android

02:18:12,650 --> 02:18:19,940
VTS so if we detect drm KMS we'll test

02:18:16,850 --> 02:18:21,200
it using intel GPU tools and then maybe

02:18:19,940 --> 02:18:25,070
eventually will require shipping

02:18:21,200 --> 02:18:26,870
implementations to pass those tests so

02:18:25,070 --> 02:18:29,930
current status just to give you guys an

02:18:26,870 --> 02:18:32,390
idea of where we are with with our pixel

02:18:29,930 --> 02:18:33,890
3 device a very small number of changes

02:18:32,390 --> 02:18:38,450
to the drm core that's required to

02:18:33,890 --> 02:18:41,180
support the modified MSM drm driver and

02:18:38,450 --> 02:18:43,100
then there is a large number of

02:18:41,180 --> 02:18:45,200
outstanding device specific changes that

02:18:43,100 --> 02:18:48,350
were made to the MSM driver for the

02:18:45,200 --> 02:18:51,920
snapdragon display engine those are I

02:18:48,350 --> 02:18:53,240
believe that coder or are working to

02:18:51,920 --> 02:18:55,430
upstream those changes to the mainline

02:18:53,240 --> 02:18:56,630
kernel so hopefully they'll they'll go

02:18:55,430 --> 02:19:01,850
upstream at some point at least some of

02:18:56,630 --> 02:19:03,620
them well and in the open source we've

02:19:01,850 --> 02:19:05,030
tried to make sure that we're doing the

02:19:03,620 --> 02:19:07,820
right thing as well with anything that's

02:19:05,030 --> 02:19:09,470
involved with DRM stack so Lib DRM Mesa

02:19:07,820 --> 02:19:13,400
and deer and have a composer of not all

02:19:09,470 --> 02:19:17,060
being resync twith upstream we've

02:19:13,400 --> 02:19:18,500
enabled DRM KMS on Heike 99 1600 SP and

02:19:17,060 --> 02:19:21,380
the new board that were about to add the

02:19:18,500 --> 02:19:23,900
eagle board x-15 already uses drm KMS

02:19:21,380 --> 02:19:25,310
from the gecko and pixel 3-wood has been

02:19:23,900 --> 02:19:28,130
already been released to LSP as well and

02:19:25,310 --> 02:19:30,110
it uses DRM KMS and the Intel GPU tools

02:19:28,130 --> 02:19:31,500
will hopefully be out of shortly to name

02:19:30,110 --> 02:19:34,590
us be

02:19:31,500 --> 02:19:36,319
and another couple of things that we're

02:19:34,590 --> 02:19:38,519
thinking about in the future will be

02:19:36,319 --> 02:19:40,859
obviously we'll have all our boards to

02:19:38,519 --> 02:19:42,179
steer around KMS will all the

02:19:40,859 --> 02:19:45,599
implementations will be tested using

02:19:42,179 --> 02:19:47,370
IntelliJ PU tools and will hopefully

02:19:45,599 --> 02:19:50,819
also be able to start setting up a

02:19:47,370 --> 02:19:53,520
chameleon display validation and what

02:19:50,819 --> 02:19:56,279
this what this little board does is it

02:19:53,520 --> 02:19:59,310
takes video in from the from the the

02:19:56,279 --> 02:20:02,310
phone or the device under test and then

02:19:59,310 --> 02:20:04,380
can actually send that information to to

02:20:02,310 --> 02:20:05,970
another machine and it can use that to

02:20:04,380 --> 02:20:07,920
compare gold and crcs without

02:20:05,970 --> 02:20:10,739
necessarily requiring right back support

02:20:07,920 --> 02:20:12,210
on the display engine so hopefully when

02:20:10,739 --> 02:20:14,069
we have that in place we'll be able to

02:20:12,210 --> 02:20:16,590
say somebody check something into the

02:20:14,069 --> 02:20:19,590
kernel run the harbor composed of tests

02:20:16,590 --> 02:20:21,479
on on top of the drm KMS driver and if

02:20:19,590 --> 02:20:23,819
something visually is wrong then we'll

02:20:21,479 --> 02:20:25,439
be able to say that was a bad change and

02:20:23,819 --> 02:20:29,189
now that's really where we want to get

02:20:25,439 --> 02:20:31,880
to from a display point of view so

02:20:29,189 --> 02:20:31,880
that's all I had

02:20:34,620 --> 02:20:40,950
I think we prefer that you call the

02:20:38,430 --> 02:20:42,840
Intel GPU tools project the IGT project

02:20:40,950 --> 02:20:46,020
it's we want to unbranded as quickly as

02:20:42,840 --> 02:20:48,210
possible just it's called i GT now I

02:20:46,020 --> 02:20:50,280
think it's called a GT test graphics

02:20:48,210 --> 02:20:51,750
test wait it's recursive but we're

02:20:50,280 --> 02:20:53,370
trying to remove the Intel from it

02:20:51,750 --> 02:20:54,840
because some people are like oh we don't

02:20:53,370 --> 02:20:59,280
were contributed something with Intel in

02:20:54,840 --> 02:21:00,689
it that's great so just I'm just curious

02:20:59,280 --> 02:21:04,410
what's the contribution model for are

02:21:00,689 --> 02:21:06,960
you - ah I'm not a maintainer so there's

02:21:04,410 --> 02:21:08,729
two other people who maintain but

02:21:06,960 --> 02:21:10,410
essentially like send it to the mailing

02:21:08,729 --> 02:21:12,390
list get it reviewed once you have like

02:21:10,410 --> 02:21:14,300
a handful of patches and want to keep

02:21:12,390 --> 02:21:18,300
computing we give you commit rights

02:21:14,300 --> 02:21:20,460
there's a CI bar testing the stuff to

02:21:18,300 --> 02:21:21,990
make sure things keep working so I think

02:21:20,460 --> 02:21:23,820
we myrrh the project and we encourage

02:21:21,990 --> 02:21:27,140
partners to off-screen those patches and

02:21:23,820 --> 02:21:27,140
we just mirror that project

02:21:34,530 --> 02:21:37,649
anything else

02:21:39,010 --> 02:21:46,990
still got five minutes to go can you say

02:21:45,040 --> 02:21:53,141
anything about the plans about codex

02:21:46,990 --> 02:21:55,990
sorry the video encoder and the I think

02:21:53,141 --> 02:21:57,340
it will go along a similar line so when

02:21:55,990 --> 02:22:00,040
we have a time to kind of deconstruct

02:21:57,340 --> 02:22:02,021
what the things that we can see your

02:22:00,040 --> 02:22:04,540
doing and what's the missing in the

02:22:02,021 --> 02:22:07,210
upstream kernel we'll take a look and

02:22:04,540 --> 02:22:09,400
see what we can do upstream to address

02:22:07,210 --> 02:22:12,400
those issues and we'll we'll start to do

02:22:09,400 --> 02:22:13,960
a similar thing in the video the reason

02:22:12,400 --> 02:22:15,340
why I've looked at display first is that

02:22:13,960 --> 02:22:16,900
I believe that we are in a place now

02:22:15,340 --> 02:22:21,370
where there's no reason not to use the

02:22:16,900 --> 02:22:23,380
RM kms upstream there may be value add

02:22:21,370 --> 02:22:28,450
functionality from the SOC manufacturers

02:22:23,380 --> 02:22:30,641
that if pixel 3 was able to share with

02:22:28,450 --> 02:22:33,521
it's a step in the right direction just

02:22:30,641 --> 02:22:36,190
proves that you can so we would want to

02:22:33,521 --> 02:22:37,570
see a similar thing for the reason why

02:22:36,190 --> 02:22:39,660
I'm asking is because some of the stuff

02:22:37,570 --> 02:22:42,521
in the display for example modifiers

02:22:39,660 --> 02:22:43,960
works you can test it better if you have

02:22:42,521 --> 02:22:49,360
a producer that usually is not in the

02:22:43,960 --> 02:22:51,311
display yes yes I mean we will probably

02:22:49,360 --> 02:22:54,370
need to end up baking a lot of data

02:22:51,311 --> 02:22:55,990
there to test this effectively if you're

02:22:54,370 --> 02:22:59,260
using something like a tile texture or

02:22:55,990 --> 02:23:00,521
pitar pixel format or FB compression or

02:22:59,260 --> 02:23:01,931
something about we'll need for lobs that

02:23:00,521 --> 02:23:05,490
we can actually upload to test the

02:23:01,931 --> 02:23:05,490
display engine not necessarily

02:23:11,590 --> 02:23:19,210
I wondering which our composure

02:23:17,590 --> 02:23:24,390
implementation is being used in the

02:23:19,210 --> 02:23:24,390
pixel free pixel 3 does not use theorem

02:23:25,710 --> 02:23:31,540
which I believe is over source okay and

02:23:29,770 --> 02:23:33,550
is there any reason for that and in big

02:23:31,540 --> 02:23:34,180
gap in functionality that is an

02:23:33,550 --> 02:23:40,239
excellent question

02:23:34,180 --> 02:23:44,079
I don't know we would obviously if if if

02:23:40,239 --> 02:23:45,699
our goal right now is not to require

02:23:44,079 --> 02:23:46,869
that DRM public impose risk use double

02:23:45,699 --> 02:23:48,609
there is this down the table composer

02:23:46,869 --> 02:23:50,260
but should the graphics team of Android

02:23:48,609 --> 02:23:51,040
decide they don't want that abstraction

02:23:50,260 --> 02:23:52,750
anymore

02:23:51,040 --> 02:23:54,010
then we would want to be in a place

02:23:52,750 --> 02:23:56,020
where we knew that everybody behaves

02:23:54,010 --> 02:23:59,109
correctly and if it's standard interface

02:23:56,020 --> 02:24:00,579
so we don't want to see like nothing

02:23:59,109 --> 02:24:02,260
works unless you call a magic eye

02:24:00,579 --> 02:24:04,840
orbital event a specific extension

02:24:02,260 --> 02:24:07,960
before you can screen so that's where

02:24:04,840 --> 02:24:10,899
ITT comes in if we can show that basic

02:24:07,960 --> 02:24:12,640
things work then we might be able to go

02:24:10,899 --> 02:24:14,500
forward with getting rid of the hover

02:24:12,640 --> 02:24:16,840
compose on how the harbor composer has a

02:24:14,500 --> 02:24:19,210
really tough tough thing because most

02:24:16,840 --> 02:24:21,399
public opposers don't just do what the

02:24:19,210 --> 02:24:24,100
harbor composer spec says they should do

02:24:21,399 --> 02:24:25,420
they're actually a nexus for information

02:24:24,100 --> 02:24:27,430
that comes through from the GPU driver

02:24:25,420 --> 02:24:29,109
from a video decoder from everything and

02:24:27,430 --> 02:24:30,850
the they will they'll hand all those

02:24:29,109 --> 02:24:32,680
peripherals inside the DRM Harbach

02:24:30,850 --> 02:24:34,720
composer and that's something that we

02:24:32,680 --> 02:24:36,220
want to discourage we're trying to break

02:24:34,720 --> 02:24:37,300
up those connections so that people

02:24:36,220 --> 02:24:39,970
don't dig that from their harbour

02:24:37,300 --> 02:24:41,079
composers and that's kind of the

02:24:39,970 --> 02:24:43,409
probably the toughest part of this

02:24:41,079 --> 02:24:43,409
problem

02:24:44,101 --> 02:24:48,391
but right now is not necessarily our

02:24:45,931 --> 02:24:50,880
focus but they still need a place where

02:24:48,391 --> 02:24:52,920
we going to put all the knowledge that

02:24:50,880 --> 02:24:56,101
you can't express you through the DRA

02:24:52,920 --> 02:24:58,650
might be a yes so there is an idea to

02:24:56,101 --> 02:25:00,360
add something called the planet and the

02:24:58,650 --> 02:25:01,830
planet will be something like a deer and

02:25:00,360 --> 02:25:04,440
Hobbit composer but it will not have the

02:25:01,830 --> 02:25:06,090
right to call into the kernel so it will

02:25:04,440 --> 02:25:08,431
or not to the display engine engine

02:25:06,090 --> 02:25:09,870
directly so we'll be able to collect

02:25:08,431 --> 02:25:11,880
information potentially through the

02:25:09,870 --> 02:25:13,440
binder or through some other maybe it

02:25:11,880 --> 02:25:14,910
will be able to access a service or some

02:25:13,440 --> 02:25:16,950
other limited or set of functionality

02:25:14,910 --> 02:25:18,690
they'll allow it to come up with a

02:25:16,950 --> 02:25:19,950
composition plan that it then sends the

02:25:18,690 --> 02:25:22,170
surface plan which will actually submit

02:25:19,950 --> 02:25:26,101
the commands to this play so the idea is

02:25:22,170 --> 02:25:27,660
that the the deer on harbour closure is

02:25:26,101 --> 02:25:29,670
no longer its sole control of how this

02:25:27,660 --> 02:25:31,410
ring has programmed and the advantage of

02:25:29,670 --> 02:25:32,641
that is that when we start writing tests

02:25:31,410 --> 02:25:35,101
we don't have to write tests though

02:25:32,641 --> 02:25:37,080
vendor-specific that whole if if deaf

02:25:35,101 --> 02:25:37,790
intel don't do this thing because is a

02:25:37,080 --> 02:25:40,590
bug

02:25:37,790 --> 02:25:41,910
don't call they hold the deer and my

02:25:40,590 --> 02:25:43,561
orbitals in this particular wager to

02:25:41,910 --> 02:25:45,630
this part of the limitation what we

02:25:43,561 --> 02:25:48,181
instead do is just send it to the planet

02:25:45,630 --> 02:25:50,280
which is a event the component get back

02:25:48,181 --> 02:25:51,480
a composition which is filtered out

02:25:50,280 --> 02:25:54,030
anything that the harbour can't manage

02:25:51,480 --> 02:25:55,590
all we prefer to do and then just push

02:25:54,030 --> 02:25:58,021
it through to the display by surface way

02:25:55,590 --> 02:25:58,830
but that's not being implemented and i

02:25:58,021 --> 02:26:01,380
don't think it's planned to the

02:25:58,830 --> 02:26:03,430
implements of the queue so at the moment

02:26:01,380 --> 02:26:05,810
it's status quo with

02:26:03,430 --> 02:26:11,120
there is also the option to go buy a

02:26:05,810 --> 02:26:11,660
atomic check-in the DRM although there

02:26:11,120 --> 02:26:13,550
are Senate

02:26:11,660 --> 02:26:16,300
yeah there are some drawbacks atomic

02:26:13,550 --> 02:26:20,090
checking I could guess performance

02:26:16,300 --> 02:26:23,360
especially at multiple times it's

02:26:20,090 --> 02:26:26,620
definitely good I think that's something

02:26:23,360 --> 02:26:26,620
that we were planning on adding

02:26:29,170 --> 02:26:34,630
they get a moment the rules and kind of

02:26:30,790 --> 02:26:36,610
hard-coded though I think each sec each

02:26:34,630 --> 02:26:38,050
has to see customization empirical it

02:26:36,610 --> 02:26:39,640
can provide the planning out for them I

02:26:38,050 --> 02:26:42,390
don't know if it necessarily does

02:26:39,640 --> 02:26:42,390
something like you suggesting

02:26:51,590 --> 02:27:05,199
all right thanks holster all right

02:27:06,310 --> 02:27:18,739
no Android MC would be complete without

02:27:08,600 --> 02:27:20,510
a discussion of ion oh there we go all

02:27:18,739 --> 02:27:24,949
right so this is me talking about ion

02:27:20,510 --> 02:27:27,260
this year once again at LPC so I just

02:27:24,949 --> 02:27:29,630
did a really quick overview about what

02:27:27,260 --> 02:27:30,949
has changed of these last year still

02:27:29,630 --> 02:27:32,420
deleting with a net deletion of code

02:27:30,949 --> 02:27:34,819
which i think is good progress and shows

02:27:32,420 --> 02:27:37,340
what's going on there's a lot of work to

02:27:34,819 --> 02:27:38,630
clean up the ion ion framework keep

02:27:37,340 --> 02:27:41,329
removing things not needed and really

02:27:38,630 --> 02:27:42,319
start to focus things and if I if I

02:27:41,329 --> 02:27:43,460
hadn't already submitted the slide I

02:27:42,319 --> 02:27:45,470
probably would have added a slide just

02:27:43,460 --> 02:27:48,199
now talking about so are we deleting ion

02:27:45,470 --> 02:27:49,640
and why do we still need ion and every

02:27:48,199 --> 02:27:50,930
year this comes up and people ask me so

02:27:49,640 --> 02:27:53,750
do we still need it and I think this

02:27:50,930 --> 02:27:55,579
reinter have come to is that I think ion

02:27:53,750 --> 02:27:56,810
does still serve a purpose but it's a

02:27:55,579 --> 02:28:00,290
slightly different purpose than maybe

02:27:56,810 --> 02:28:01,369
what it started out as it's not the

02:28:00,290 --> 02:28:06,050
point it's not something the problem

02:28:01,369 --> 02:28:07,220
about trying to be a constraint solver

02:28:06,050 --> 02:28:10,159
or everything

02:28:07,220 --> 02:28:12,949
it's reloading a simple memory

02:28:10,159 --> 02:28:15,020
allocating space allocation API for user

02:28:12,949 --> 02:28:17,500
space to be able to allocate a certain

02:28:15,020 --> 02:28:20,300
set of memory and then pass those off to

02:28:17,500 --> 02:28:22,939
DMA buff importers so that's what I see

02:28:20,300 --> 02:28:24,590
ion is the use case for I've it's come

02:28:22,939 --> 02:28:26,359
up a couple different places if for some

02:28:24,590 --> 02:28:28,340
reason we all got together and decided

02:28:26,359 --> 02:28:29,479
that maybe all those using all the

02:28:28,340 --> 02:28:30,859
people who actually want to use annika

02:28:29,479 --> 02:28:32,540
to use something else I would be more

02:28:30,859 --> 02:28:34,520
than happy to delete it but people keep

02:28:32,540 --> 02:28:38,270
saying they want ion so for now we're

02:28:34,520 --> 02:28:39,890
still gonna keep it round so the

02:28:38,270 --> 02:28:41,540
question is is that ion still in staging

02:28:39,890 --> 02:28:44,149
what's actually blocking ion going

02:28:41,540 --> 02:28:47,619
enough staging these are the big issues

02:28:44,149 --> 02:28:50,800
I think that are blocking ion staging

02:28:47,619 --> 02:28:53,149
the first is ion uncashed allocations

02:28:50,800 --> 02:28:56,329
ions to support cash in on cache

02:28:53,149 --> 02:28:59,180
allocations since it was created as we

02:28:56,329 --> 02:29:01,489
move to it properly used the DMA api's

02:28:59,180 --> 02:29:02,500
and a better coherency model it turns

02:29:01,489 --> 02:29:04,180
out that

02:29:02,500 --> 02:29:06,910
to make the uncashed allocations

02:29:04,180 --> 02:29:09,880
actually work properly with that is very

02:29:06,910 --> 02:29:12,400
tricky because we actually have to call

02:29:09,880 --> 02:29:14,080
the DMA api's in the right order what we

02:29:12,400 --> 02:29:17,290
find is is that you can't you can't

02:29:14,080 --> 02:29:18,880
actually do this in a in a way and I you

02:29:17,290 --> 02:29:20,770
want to end up with a catch-22 about

02:29:18,880 --> 02:29:23,080
trying to synchronize pages without

02:29:20,770 --> 02:29:24,850
actually having access to part of the

02:29:23,080 --> 02:29:26,890
device structure so it makes trying to

02:29:24,850 --> 02:29:29,020
get uncashed allocations that are

02:29:26,890 --> 02:29:31,150
actually safe very difficult

02:29:29,020 --> 02:29:33,400
I'd like to honestly just drop support

02:29:31,150 --> 02:29:34,780
for uncashed allocations just because it

02:29:33,400 --> 02:29:36,490
seems like they're not a very popular

02:29:34,780 --> 02:29:37,690
use case but there are some people who

02:29:36,490 --> 02:29:39,700
have code out for you to really want

02:29:37,690 --> 02:29:41,950
that so I'm working with them to review

02:29:39,700 --> 02:29:43,450
their youth case and why exactly they

02:29:41,950 --> 02:29:46,420
think they need it so that's still

02:29:43,450 --> 02:29:48,880
something we're working through at the

02:29:46,420 --> 02:29:50,470
very another option I've thought about

02:29:48,880 --> 02:29:52,240
is maybe just putting in a kernel config

02:29:50,470 --> 02:29:55,000
option saying allow on cached

02:29:52,240 --> 02:29:56,260
allocations just to Wow just just to be

02:29:55,000 --> 02:29:57,640
able to have it off in the default case

02:29:56,260 --> 02:29:59,500
for most people who may not need on

02:29:57,640 --> 02:30:02,560
cache allocations and then those who

02:29:59,500 --> 02:30:05,230
actually want to concern it on another

02:30:02,560 --> 02:30:07,480
relating issue is skipping cache

02:30:05,230 --> 02:30:10,120
maintenance so when I'd it's the major

02:30:07,480 --> 02:30:13,660
rework a couple of kernel versions ago I

02:30:10,120 --> 02:30:14,980
thought that the we when I did that we

02:30:13,660 --> 02:30:16,480
would end up being said to do some minor

02:30:14,980 --> 02:30:18,760
optimizations to maybe get some

02:30:16,480 --> 02:30:20,200
performance back just because the way

02:30:18,760 --> 02:30:23,650
thinks we're working we're now calling

02:30:20,200 --> 02:30:25,030
do you may map DMA on map more often and

02:30:23,650 --> 02:30:27,070
therefore we're also thinking having to

02:30:25,030 --> 02:30:28,230
sync the cache is more often but it

02:30:27,070 --> 02:30:30,430
turns out that this may have actually

02:30:28,230 --> 02:30:32,080
introduced some major performance

02:30:30,430 --> 02:30:35,230
regressions which we only found out

02:30:32,080 --> 02:30:38,500
until fairly recently so we're looking

02:30:35,230 --> 02:30:40,180
at that to try and do some optimizations

02:30:38,500 --> 02:30:44,050
and the optimizations we're looking at

02:30:40,180 --> 02:30:45,430
should be fairly seemed like they should

02:30:44,050 --> 02:30:47,290
be fairly obvious things to do mostly

02:30:45,430 --> 02:30:49,440
because when the initial code for this

02:30:47,290 --> 02:30:52,450
was written by me I kind of took the

02:30:49,440 --> 02:30:54,610
what I think of as the slow and obvious

02:30:52,450 --> 02:30:56,350
approach instead of maybe the slightly

02:30:54,610 --> 02:30:57,520
smarter approach just just to get a

02:30:56,350 --> 02:30:59,770
proof-of-concept out there to show that

02:30:57,520 --> 02:31:01,330
the I n stuff was actually working

02:30:59,770 --> 02:31:03,430
correctly and then work about speeding

02:31:01,330 --> 02:31:06,460
it up but clearly we need to do some

02:31:03,430 --> 02:31:08,710
more work about thinking about that I've

02:31:06,460 --> 02:31:10,870
been again discussing with some people

02:31:08,710 --> 02:31:14,380
with patches some on less some off list

02:31:10,870 --> 02:31:16,419
about approaches to this and I think the

02:31:14,380 --> 02:31:19,119
issue we've run into is try to figure

02:31:16,419 --> 02:31:22,629
how to actually meet all use cases that

02:31:19,119 --> 02:31:24,100
actually will make it possible to call

02:31:22,629 --> 02:31:27,819
the map and on map in the right places

02:31:24,100 --> 02:31:29,979
it's sometimes kind of ties into places

02:31:27,819 --> 02:31:31,539
where the android framework is that

02:31:29,979 --> 02:31:32,619
seems to want to want to call this I can

02:31:31,539 --> 02:31:36,699
talk about more of this during the

02:31:32,619 --> 02:31:39,699
discussion period another sort of thorn

02:31:36,699 --> 02:31:41,379
in my side is the carve out chunk heaps

02:31:39,699 --> 02:31:43,299
these are ones I still want to delete

02:31:41,379 --> 02:31:46,209
I've perhaps was negligent of leaving

02:31:43,299 --> 02:31:47,319
them and no there's some at least one

02:31:46,209 --> 02:31:49,419
person who wants to try and keep them

02:31:47,319 --> 02:31:51,639
around but I need to review the patches

02:31:49,419 --> 02:31:52,779
just because nobody has really stepped

02:31:51,639 --> 02:31:54,339
up to I think through the hard part

02:31:52,779 --> 02:31:56,919
about figuring out how to actually tie

02:31:54,339 --> 02:31:58,539
the allocation in and get that tied up

02:31:56,919 --> 02:32:01,319
in a generic way without having to call

02:31:58,539 --> 02:32:05,020
into board specific platform code and

02:32:01,319 --> 02:32:08,109
finally the last one is splitting up def

02:32:05,020 --> 02:32:09,069
ion into dev heap 0 def heap 1 this has

02:32:08,109 --> 02:32:10,689
been something that's been requests we

02:32:09,069 --> 02:32:12,819
just to have finer grained security

02:32:10,689 --> 02:32:15,339
controls most at the SU Linux layer for

02:32:12,819 --> 02:32:16,689
controlling individual dep nodes so I've

02:32:15,339 --> 02:32:18,669
seen patches for that I think we just

02:32:16,689 --> 02:32:20,229
need to work out exactly where the

02:32:18,669 --> 02:32:28,239
testing and review infrastructure goes

02:32:20,229 --> 02:32:31,509
so discussion time okay so Liam pratik

02:32:28,239 --> 02:32:33,489
I'm glad you're both here would you like

02:32:31,509 --> 02:32:34,839
to give us I'd like to see if we can

02:32:33,489 --> 02:32:37,149
just get some open questions I think

02:32:34,839 --> 02:32:38,739
let's start with the uncashed

02:32:37,149 --> 02:32:42,029
allocations if you want to give you know

02:32:38,739 --> 02:32:42,029
30-second summary of

02:32:48,529 --> 02:32:56,819
thirty seconds in the past most of our

02:32:54,149 --> 02:32:58,079
use cases it's only the device that

02:32:56,819 --> 02:33:00,539
accesses the buffer so we don't need to

02:32:58,079 --> 02:33:02,579
do any cache maintenance in the past and

02:33:00,539 --> 02:33:03,779
the rare cases where CPU did do access

02:33:02,579 --> 02:33:05,369
with the old version of lye on we had a

02:33:03,779 --> 02:33:08,549
octal so the user space could call in

02:33:05,369 --> 02:33:10,229
and basically do the clean and

02:33:08,549 --> 02:33:11,789
invalidate with the new version of I and

02:33:10,229 --> 02:33:14,039
we can't do that

02:33:11,789 --> 02:33:15,779
we can't rely on the user space being

02:33:14,039 --> 02:33:18,539
able to do the cache maintance even

02:33:15,779 --> 02:33:20,459
through the DMA buff sink Isles because

02:33:18,539 --> 02:33:22,919
there may not be a device attached so

02:33:20,459 --> 02:33:26,399
we've had to switch over to using cache

02:33:22,919 --> 02:33:28,489
maintenance always-on DMA map and DNA

02:33:26,399 --> 02:33:30,479
unmapped just in case there might be

02:33:28,489 --> 02:33:33,060
user space access like you need the

02:33:30,479 --> 02:33:34,350
invalidate onion on the unmapped in case

02:33:33,060 --> 02:33:36,419
somebody user space is going to access

02:33:34,350 --> 02:33:38,549
the memory and there may not be a device

02:33:36,419 --> 02:33:39,869
there for there begins to view access to

02:33:38,549 --> 02:33:42,089
do cache mean and so that's why we

02:33:39,869 --> 02:33:44,430
switched to uncashed for most of our use

02:33:42,089 --> 02:33:46,199
cases that way we could safely skip the

02:33:44,430 --> 02:33:49,799
cache maintenance across the board that

02:33:46,199 --> 02:33:51,569
was our main use case for and I think

02:33:49,799 --> 02:33:53,189
part of my argument has always been this

02:33:51,569 --> 02:33:56,039
sort of seems like it's solving the

02:33:53,189 --> 02:33:57,569
wrong problem just because a it sort of

02:33:56,039 --> 02:33:59,520
seems like it's a missing use case if

02:33:57,569 --> 02:34:00,839
you're trying to call begin CPU asks us

02:33:59,520 --> 02:34:02,669
and you haven't actually called DMA

02:34:00,839 --> 02:34:04,680
above attach this means you're trying to

02:34:02,669 --> 02:34:06,359
call begin CPU access at the wrong time

02:34:04,680 --> 02:34:08,249
and therefore nothing should actually

02:34:06,359 --> 02:34:10,140
happen and it shouldn't actually be

02:34:08,249 --> 02:34:12,419
necessary and therefore we should

02:34:10,140 --> 02:34:14,249
actually be able to do that so I guess

02:34:12,419 --> 02:34:17,879
I've never quite been able to grok

02:34:14,249 --> 02:34:20,520
exactly why user space still is trying

02:34:17,879 --> 02:34:23,729
to call presumably hand off the buffer

02:34:20,520 --> 02:34:25,140
without actually having a device

02:34:23,729 --> 02:34:26,489
attached and maybe this gets to the

02:34:25,140 --> 02:34:28,589
point is that it sort of seems like

02:34:26,489 --> 02:34:31,140
somehow the android framework which

02:34:28,589 --> 02:34:32,850
seems to be doing this once is is not

02:34:31,140 --> 02:34:35,129
quite doing the buffer hand off the way

02:34:32,850 --> 02:34:37,589
I would expect with a DMA map D my own

02:34:35,129 --> 02:34:39,329
map API so yes I guess that's what it's

02:34:37,589 --> 02:34:40,739
coming down to is ideally like we spoke

02:34:39,329 --> 02:34:43,560
a little bit before is if you could have

02:34:40,739 --> 02:34:46,260
these devices in this use case just keep

02:34:43,560 --> 02:34:48,539
the buffer DMA mapped the whole time and

02:34:46,260 --> 02:34:50,010
then game a unmapped at the end of the

02:34:48,539 --> 02:34:52,140
use case you'd be fine because then the

02:34:50,010 --> 02:34:53,879
user space begins deep you access and

02:34:52,140 --> 02:34:54,930
and NCP you access there'd be a device

02:34:53,879 --> 02:34:56,939
there it would work

02:34:54,930 --> 02:34:58,109
but the clients like display and stuff

02:34:56,939 --> 02:35:00,210
have come back and said we don't know

02:34:58,109 --> 02:35:03,029
when the use case ends because I enjoy

02:35:00,210 --> 02:35:04,050
pipelines so they don't they can't they

02:35:03,029 --> 02:35:06,239
can't wait to the end of the use case to

02:35:04,050 --> 02:35:08,970
call DME on map so they always DME map

02:35:06,239 --> 02:35:09,989
and Demian map while they're being all

02:35:08,970 --> 02:35:12,300
this buffer comes to them in the

02:35:09,989 --> 02:35:13,470
pipeline so they'd need to know they

02:35:12,300 --> 02:35:14,489
need support from android framework to

02:35:13,470 --> 02:35:20,010
know when the use case ends so that they

02:35:14,489 --> 02:35:21,899
could do the DMA on map yeah so this is

02:35:20,010 --> 02:35:24,300
sort of where we're stuck at right now

02:35:21,899 --> 02:35:27,180
about trying to work through this like I

02:35:24,300 --> 02:35:28,920
said because we're still seeing requests

02:35:27,180 --> 02:35:30,899
for ion that are not necessarily Android

02:35:28,920 --> 02:35:34,250
specific I'm trying not to throw out too

02:35:30,899 --> 02:35:42,029
many Android specific hacks into ion but

02:35:34,250 --> 02:35:45,270
we'll see what happens so there used to

02:35:42,029 --> 02:35:48,540
be the relic lock/unlock very really

02:35:45,270 --> 02:35:50,100
early in the days yeah you're looking

02:35:48,540 --> 02:35:52,380
for something similarly friendly no no a

02:35:50,100 --> 02:35:54,149
relic lock and unlock is fine and it's

02:35:52,380 --> 02:35:56,729
there but the problem is is it's it's

02:35:54,149 --> 02:35:58,439
gonna do the DMA sync so that begins CPU

02:35:56,729 --> 02:36:01,649
access and the growl lock on lock is

02:35:58,439 --> 02:36:03,120
going to do the game a sink and NCP you

02:36:01,649 --> 02:36:05,430
access which is all fine but the problem

02:36:03,120 --> 02:36:08,250
is the device may not be attached

02:36:05,430 --> 02:36:09,960
anymore because it may have so the if

02:36:08,250 --> 02:36:11,399
the device isn't there an ion then it

02:36:09,960 --> 02:36:12,660
won't do any cache maintenance it'll

02:36:11,399 --> 02:36:14,399
just do a no op and that's where you're

02:36:12,660 --> 02:36:17,189
in trouble so you know you're you're

02:36:14,399 --> 02:36:19,050
you're attached you get your device

02:36:17,189 --> 02:36:20,460
access and then at some point the buffer

02:36:19,050 --> 02:36:22,620
is being passed down the pipeline so you

02:36:20,460 --> 02:36:24,510
have to game a unmapped and remove your

02:36:22,620 --> 02:36:26,609
device and then there's some kind of

02:36:24,510 --> 02:36:27,149
post-processing by some module that does

02:36:26,609 --> 02:36:28,770
the biggie

02:36:27,149 --> 02:36:30,540
does the growl lock lock but now it

02:36:28,770 --> 02:36:33,270
can't it doesn't result in any cache

02:36:30,540 --> 02:36:34,949
maintenance so you either always had to

02:36:33,270 --> 02:36:37,470
do your invalidate on the DMA on map

02:36:34,949 --> 02:36:39,390
which is wasteful on the case that there

02:36:37,470 --> 02:36:41,819
may be CPU access which is not the

02:36:39,390 --> 02:36:43,260
normal case so I basically write down

02:36:41,819 --> 02:36:44,550
you're doing that every time you do that

02:36:43,260 --> 02:36:45,960
from the device them for you yeah you

02:36:44,550 --> 02:36:47,580
they're always yeah the modules are

02:36:45,960 --> 02:36:49,710
always detaching so you know if we could

02:36:47,580 --> 02:36:51,390
keep herself DMA map the whole time we'd

02:36:49,710 --> 02:36:52,710
be fine but they need to know they need

02:36:51,390 --> 02:36:54,930
to be told at the end of the use case

02:36:52,710 --> 02:36:58,650
somehow the DMA on map and that's why

02:36:54,930 --> 02:36:59,870
they're not doing that so it's a kind of

02:36:58,650 --> 02:37:02,010
[Applause]

02:36:59,870 --> 02:37:03,450
so we're probably going to talk more

02:37:02,010 --> 02:37:06,060
about this afterwards if anyone is

02:37:03,450 --> 02:37:09,090
interested but I think those were the

02:37:06,060 --> 02:37:10,740
major issues we're still looking at if

02:37:09,090 --> 02:37:13,260
anyone else has any comments about my on

02:37:10,740 --> 02:37:16,350
the one thing that I saw that was sort

02:37:13,260 --> 02:37:19,590
of weird is at least the DMA buf API in

02:37:16,350 --> 02:37:22,350
the kernel on the DMA buff unmapped

02:37:19,590 --> 02:37:24,750
almost every existing driver does

02:37:22,350 --> 02:37:26,160
nothing and so that sort of suggests if

02:37:24,750 --> 02:37:29,210
everybody's kind of taking this cheap

02:37:26,160 --> 02:37:33,060
you know to avoid doing the flushing

02:37:29,210 --> 02:37:35,220
maybe the API isn't accurate not what we

02:37:33,060 --> 02:37:36,750
really need yeah absolutely agreed this

02:37:35,220 --> 02:37:38,610
is something else I was going to think

02:37:36,750 --> 02:37:40,590
about looking at the DMA buff api's as

02:37:38,610 --> 02:37:42,090
well because agreed when I implemented

02:37:40,590 --> 02:37:44,100
this I was kind of going about what the

02:37:42,090 --> 02:37:48,000
API suggested just because try and

02:37:44,100 --> 02:37:52,920
follow the framework but yeah four

02:37:48,000 --> 02:37:54,360
minutes to go okay anything else about

02:37:52,920 --> 02:37:57,050
ion otherwise I'm happy to give people

02:37:54,360 --> 02:37:57,050
five minutes back

02:38:00,210 --> 02:38:26,220
okay all right so we got one last

02:38:11,460 --> 02:38:29,989
presentation regarding cuttlefish yeah

02:38:26,220 --> 02:38:32,640
so sandy mentioned this in he's kind of

02:38:29,989 --> 02:38:33,750
his presentation yesterday and a lot of

02:38:32,640 --> 02:38:36,000
people have asked me about it

02:38:33,750 --> 02:38:37,529
I just wanted to briefly explain what

02:38:36,000 --> 02:38:39,149
cuttlefish is and why you might want to

02:38:37,529 --> 02:38:46,350
use it why it's kind of interesting for

02:38:39,149 --> 02:38:48,540
thermal hacking so why is cuttlefish so

02:38:46,350 --> 02:38:50,870
cuttlefish is Android virtual device

02:38:48,540 --> 02:38:55,800
based on qme

02:38:50,870 --> 02:38:57,810
it's x86 64 based so we can use KVM

02:38:55,800 --> 02:39:01,350
hardware so hardware virtualization on

02:38:57,810 --> 02:39:02,580
the Google cloud platform and on Google

02:39:01,350 --> 02:39:07,770
Cloud if you want to use it on Google

02:39:02,580 --> 02:39:09,600
Cloud because Google Cloud you you would

02:39:07,770 --> 02:39:11,250
create a Linux file system on the Google

02:39:09,600 --> 02:39:12,960
cloud and you would run this inside that

02:39:11,250 --> 02:39:14,279
that Linux file system and it would use

02:39:12,960 --> 02:39:17,880
nested virtualization to achieve

02:39:14,279 --> 02:39:21,510
hardware acceleration it's it's vert il

02:39:17,880 --> 02:39:23,399
based for the most part so the block and

02:39:21,510 --> 02:39:25,109
network serial GPU are all coming

02:39:23,399 --> 02:39:27,989
through the standard ver tire driver

02:39:25,109 --> 02:39:30,060
interfaces but there is this driver that

02:39:27,989 --> 02:39:34,710
we added to staging recently I think it

02:39:30,060 --> 02:39:36,300
was out in 417 which is still being used

02:39:34,710 --> 02:39:38,640
by some legacy components in the

02:39:36,300 --> 02:39:42,180
cuttlefish port for things like input

02:39:38,640 --> 02:39:45,600
and audio but we're planning on removing

02:39:42,180 --> 02:39:47,430
that there's a kernel deaf conflict to

02:39:45,600 --> 02:39:49,020
enable those drivers and the Android

02:39:47,430 --> 02:39:51,689
features which is in the Android kernel

02:39:49,020 --> 02:39:54,090
commentary and it's not to be confused

02:39:51,689 --> 02:39:55,410
with an Android emulator which has a

02:39:54,090 --> 02:39:57,149
whole bunch of kernel changes like

02:39:55,410 --> 02:39:59,970
goldfish pipe and goldfish address space

02:39:57,149 --> 02:40:00,989
which we don't need for cuttlefish so

02:39:59,970 --> 02:40:02,760
that means that we can develop it

02:40:00,989 --> 02:40:04,649
upstream and the open it develop the

02:40:02,760 --> 02:40:06,140
user space is developed in AOSP and the

02:40:04,649 --> 02:40:09,180
kernel changes are all developed

02:40:06,140 --> 02:40:11,130
upstream and mainline Linux

02:40:09,180 --> 02:40:12,690
the verb Wi-Fi driver which is used for

02:40:11,130 --> 02:40:14,460
virtual Wi-Fi on custom fish is not

02:40:12,690 --> 02:40:16,830
currently upstream it's pending with you

02:40:14,460 --> 02:40:23,311
on that next but it should hopefully go

02:40:16,830 --> 02:40:25,021
in soon so if you want to build

02:40:23,311 --> 02:40:26,700
cuttlefish if you want to try it out

02:40:25,021 --> 02:40:28,950
these are the kind of steps you need to

02:40:26,700 --> 02:40:31,980
take you just check out the code lunch

02:40:28,950 --> 02:40:35,970
it builder as a usual platform just like

02:40:31,980 --> 02:40:37,290
you a bill for pixel and then when you

02:40:35,970 --> 02:40:38,910
want to build yourself a kernel you can

02:40:37,290 --> 02:40:40,200
just pull the kernel comment the common

02:40:38,910 --> 02:40:41,760
kernel which normally can't be built for

02:40:40,200 --> 02:40:44,820
any specific target but now it can it

02:40:41,760 --> 02:40:46,740
can be built for cuttlefish we have

02:40:44,820 --> 02:40:49,650
support in all of the kernel branches

02:40:46,740 --> 02:40:53,010
back to 318 but we obviously would

02:40:49,650 --> 02:40:54,480
recommend that you either for 14 or the

02:40:53,010 --> 02:40:55,890
Android mainline tracking branch should

02:40:54,480 --> 02:40:57,601
be used main line track is probably most

02:40:55,890 --> 02:41:00,380
useful for kernel developers to visit

02:40:57,601 --> 02:41:03,680
you can try our C's penalties which

02:41:00,380 --> 02:41:06,150
rebase the Android patch set on top of

02:41:03,680 --> 02:41:08,780
so it's just a kind of very simple flow

02:41:06,150 --> 02:41:12,390
to build the kernel nothing fancy there

02:41:08,780 --> 02:41:14,430
and there's a custom tool that comes as

02:41:12,390 --> 02:41:15,690
part of the host build for Android when

02:41:14,430 --> 02:41:17,190
you build for cuttlefish you got this

02:41:15,690 --> 02:41:18,930
tool called launch CVD which is

02:41:17,190 --> 02:41:23,521
basically a wrapper around the qmu

02:41:18,930 --> 02:41:26,040
binary and you can pass it a BZ image in

02:41:23,521 --> 02:41:28,050
kernel path and it will pick that up and

02:41:26,040 --> 02:41:31,021
use that instead of the pre-built kernel

02:41:28,050 --> 02:41:33,240
that's checked in which again is useful

02:41:31,021 --> 02:41:35,430
for kernel development and if this tool

02:41:33,240 --> 02:41:37,590
will actually pass the QM you all of the

02:41:35,430 --> 02:41:39,811
device parameters the Vertigo

02:41:37,590 --> 02:41:41,190
specification stuff all the block

02:41:39,811 --> 02:41:42,390
devices everything so you don't need to

02:41:41,190 --> 02:41:43,740
worry about any of that it just picks

02:41:42,390 --> 02:41:45,720
those things out of your Android build

02:41:43,740 --> 02:41:48,720
tree out of your product out directory

02:41:45,720 --> 02:41:51,210
and you can use ADB just as you would on

02:41:48,720 --> 02:41:53,760
a real device you can connect to the

02:41:51,210 --> 02:41:57,030
display of the device using tight VNC

02:41:53,760 --> 02:41:59,190
and you can get the kernel log out of

02:41:57,030 --> 02:42:00,630
magic file and cuttlefish runtime then

02:41:59,190 --> 02:42:02,851
you can also retrieve a log cat if you

02:42:00,630 --> 02:42:04,410
don't want to use ADB so when you fire

02:42:02,851 --> 02:42:06,210
up the VNC connection this is what

02:42:04,410 --> 02:42:09,811
you'll get it's getting its standard ESP

02:42:06,210 --> 02:42:12,450
build in a full and configuration

02:42:09,811 --> 02:42:13,801
it'll be running inside the MC so Cass

02:42:12,450 --> 02:42:15,570
if you've ever used the Android emulator

02:42:13,801 --> 02:42:17,730
the Android SDK it's very similar to how

02:42:15,570 --> 02:42:21,271
that works it's just as using an

02:42:17,730 --> 02:42:23,070
unpatched version of qmu and what can

02:42:21,271 --> 02:42:26,120
run mainline Linux kernels and AOSP

02:42:23,070 --> 02:42:29,551
generic AOSP

02:42:26,120 --> 02:42:30,870
so stuff we need to do this is all very

02:42:29,551 --> 02:42:32,881
new so we obviously need to add

02:42:30,870 --> 02:42:34,080
documentation probably mostly what I've

02:42:32,881 --> 02:42:36,301
just showing you and a little bit more

02:42:34,080 --> 02:42:39,360
to explain what it does eliminate the

02:42:36,301 --> 02:42:42,330
VSOP driver and we're also working on

02:42:39,360 --> 02:42:43,561
adding GPU acceleration to cuttlefish

02:42:42,330 --> 02:42:45,961
which is another way that we're going to

02:42:43,561 --> 02:42:49,440
try and enable DRM kms so we're gonna

02:42:45,961 --> 02:42:51,330
add vertically D support to the build so

02:42:49,440 --> 02:42:52,891
that the graphics acceleration will be

02:42:51,330 --> 02:42:55,230
done on the host side on the virtual

02:42:52,891 --> 02:42:57,110
machine on the qmu side rather than

02:42:55,230 --> 02:43:00,030
actually in the guest at the moment

02:42:57,110 --> 02:43:01,950
cuttlefish is using Swift shader which

02:43:00,030 --> 02:43:06,330
is a software GPU implementation that

02:43:01,950 --> 02:43:08,580
runs in the guest and work I've also

02:43:06,330 --> 02:43:10,681
just managed to get working the arm 64

02:43:08,580 --> 02:43:12,391
build of cuttlefish which is just using

02:43:10,681 --> 02:43:14,490
it's basically a variant of the arm 64

02:43:12,391 --> 02:43:16,891
def config that enables the Android

02:43:14,490 --> 02:43:20,461
options required to run Android on top

02:43:16,891 --> 02:43:21,690
of artists 4 def config plus something

02:43:20,461 --> 02:43:25,530
like a couple of other tweaks that we

02:43:21,690 --> 02:43:26,881
need for qmu so please try it out it's a

02:43:25,530 --> 02:43:29,791
great way of developing for Android

02:43:26,881 --> 02:43:31,351
Android kernels you can just boot Linux

02:43:29,791 --> 02:43:33,631
up something breaks you just control C

02:43:31,351 --> 02:43:34,891
you start up again or you can connect

02:43:33,631 --> 02:43:36,511
your TV to it and you can set a

02:43:34,891 --> 02:43:39,061
breakpoint in the kernel using QM use

02:43:36,511 --> 02:43:40,950
gdb facility if you've ever used QM to

02:43:39,061 --> 02:43:42,841
debug a kernel it's all those same

02:43:40,950 --> 02:43:44,521
features exist it's just this kind of

02:43:42,841 --> 02:43:45,870
hand holds you through the Android

02:43:44,521 --> 02:43:47,490
integration so you don't need to worry

02:43:45,870 --> 02:43:48,110
about building a specific build of

02:43:47,490 --> 02:44:00,500
Android

02:43:48,110 --> 02:44:02,240
specifying specific blacks to Cuba um so

02:44:00,500 --> 02:44:05,330
you mentioned you're using Swiss shader

02:44:02,240 --> 02:44:10,250
at the moment for the arm 64 port just

02:44:05,330 --> 02:44:17,271
Swift shader working there now so if you

02:44:10,250 --> 02:44:19,160
build from 64 you need to build just

02:44:17,271 --> 02:44:27,650
because of that reason the Swiss shaders

02:44:19,160 --> 02:44:29,900
cogeneration but when we replace the the

02:44:27,650 --> 02:44:33,980
GP pipeline with the GP 3d that problem

02:44:29,900 --> 02:44:35,601
will go away so I think it shouldn't

02:44:33,980 --> 02:44:38,240
take us too long to get back to those

02:44:35,601 --> 02:44:41,630
changes and the GPU support will also

02:44:38,240 --> 02:44:44,391
work in Google Cloud for the Verdejo the

02:44:41,630 --> 02:44:52,011
intention is that if you if you pay for

02:44:44,391 --> 02:44:55,160
the GPU instance what will also enable

02:44:52,011 --> 02:44:57,471
is will actually use for shader in qmu

02:44:55,160 --> 02:44:58,971
instead so if you don't want anyone if

02:44:57,471 --> 02:45:00,380
you don't want hardware acceleration but

02:44:58,971 --> 02:45:02,210
you still want to run around 60 core

02:45:00,380 --> 02:45:13,070
that becomes a possibility because we'll

02:45:02,210 --> 02:45:15,891
be using an x86 64 swift shader okay so

02:45:13,070 --> 02:45:17,660
I I assume I can install any

02:45:15,891 --> 02:45:19,160
applications to write the Android

02:45:17,660 --> 02:45:22,130
applications that I develop on

02:45:19,160 --> 02:45:24,681
cuttlefish customizers that's right if

02:45:22,130 --> 02:45:27,200
that is the case why would I use this

02:45:24,681 --> 02:45:30,110
over emulator sorry I did not follow

02:45:27,200 --> 02:45:31,370
that part so if you use it if you're

02:45:30,110 --> 02:45:33,230
developing the kernel for the emulator

02:45:31,370 --> 02:45:34,880
you basically have to pick a version of

02:45:33,230 --> 02:45:36,500
the kernel that the emulator team posted

02:45:34,880 --> 02:45:40,641
all of that changes to the emulator

02:45:36,500 --> 02:45:41,960
changes in our home screen right right

02:45:40,641 --> 02:45:44,391
so that the current release for the

02:45:41,960 --> 02:45:46,820
emulator i think is 4.4 so if you want

02:45:44,391 --> 02:45:49,700
to look that far back you can the other

02:45:46,820 --> 02:45:51,561
thing is the emulators qmu is a is a

02:45:49,700 --> 02:45:53,090
fork of qmu so for the emulators they

02:45:51,561 --> 02:45:55,070
even work at all you can't use

02:45:53,090 --> 02:45:56,840
that yummy build you have to use the QR

02:45:55,070 --> 02:46:06,979
meters checked into the emulator and

02:45:56,840 --> 02:46:09,050
that is nice the emulator that's

02:46:06,979 --> 02:46:11,660
distributed as part of the SDK has some

02:46:09,050 --> 02:46:14,270
lot some quality of life stuff that you

02:46:11,660 --> 02:46:16,040
won't have on cuttlefish like the UI is

02:46:14,270 --> 02:46:17,810
a lot nicer

02:46:16,040 --> 02:46:20,899
it already has passed through GPU

02:46:17,810 --> 02:46:23,720
support so frankly cuttlefish is what I

02:46:20,899 --> 02:46:27,200
wish that our SDK emulator had evolved

02:46:23,720 --> 02:46:30,830
into and that sort of didn't happen for

02:46:27,200 --> 02:46:32,120
reason to out of my control and because

02:46:30,830 --> 02:46:33,590
of people who aren't here to defend

02:46:32,120 --> 02:46:38,240
themselves so I want some lemon to the

02:46:33,590 --> 02:46:39,740
bus we've talked with the emulator team

02:46:38,240 --> 02:46:41,660
a little bit and we're trying to push

02:46:39,740 --> 02:46:42,020
them towards using video for stuff like

02:46:41,660 --> 02:46:44,390
this

02:46:42,020 --> 02:46:46,370
and so maybe it will convert to support

02:46:44,390 --> 02:46:49,010
in the future maybe it won't but I would

02:46:46,370 --> 02:46:51,109
say if if you are just a regular app

02:46:49,010 --> 02:46:54,109
developer you probably don't care if

02:46:51,109 --> 02:46:56,359
you're running a tip a tree kernel and

02:46:54,109 --> 02:46:58,670
so the sdk emulator is fine if you're a

02:46:56,359 --> 02:47:00,320
kernel developer you don't care as much

02:46:58,670 --> 02:47:01,910
about the quality life stuff you just

02:47:00,320 --> 02:47:06,070
want to be able to Boonton attach V and

02:47:01,910 --> 02:47:06,070
C and some cuttlefish is great for that

02:47:06,700 --> 02:47:15,229
and so you mentioned that you're looking

02:47:11,450 --> 02:47:17,689
at converting a bunch of drivers to bert

02:47:15,229 --> 02:47:19,580
io including the audio stuff yeah have

02:47:17,689 --> 02:47:21,920
you concretely looked at the audio

02:47:19,580 --> 02:47:24,560
variety f or is that just a to do at the

02:47:21,920 --> 02:47:26,479
minute for us we'll try and use any if

02:47:24,560 --> 02:47:31,550
there's a pending vertigo standard that

02:47:26,479 --> 02:47:33,439
we haven't that we can but there in the

02:47:31,550 --> 02:47:35,960
case of a GPU for example we might end

02:47:33,439 --> 02:47:38,090
up creating a fork of that because the

02:47:35,960 --> 02:47:41,420
way that verse I use of space is being

02:47:38,090 --> 02:47:42,890
used with long Seibert I GP 3ds is not

02:47:41,420 --> 02:47:45,620
necessarily something we want to use

02:47:42,890 --> 02:47:47,810
yeah I there there is some work going on

02:47:45,620 --> 02:47:50,439
at i/o for audio but I which have not

02:47:47,810 --> 02:47:52,580
been able to find the actual specs for

02:47:50,439 --> 02:47:54,580
but I have some concerns about the

02:47:52,580 --> 02:47:57,620
description and how utiful it is so

02:47:54,580 --> 02:47:59,840
having a more useful thing especially

02:47:57,620 --> 02:48:01,280
for use cases like this yeah would be

02:47:59,840 --> 02:48:05,149
super helpful

02:48:01,280 --> 02:48:06,710
yeah is it likely to be Eric that's

02:48:05,149 --> 02:48:10,279
looking at this or

02:48:06,710 --> 02:48:11,779
if it's vert I uh I know audio I don't

02:48:10,279 --> 02:48:14,330
know at the moment we I don't we don't

02:48:11,779 --> 02:48:16,100
really we plan to to pursue that but we

02:48:14,330 --> 02:48:17,359
haven't yeah okay so yeah it's an in

02:48:16,100 --> 02:48:20,449
planning rather than a concrete thing

02:48:17,359 --> 02:48:21,979
yeah yeah we all switch the Versailles

02:48:20,449 --> 02:48:23,479
of input soon there was no reason for us

02:48:21,979 --> 02:48:27,729
not to use it we just to the user so

02:48:23,479 --> 02:48:27,729
that that's an easy one to to use

02:48:33,119 --> 02:48:39,670
you just say something about fertile GPU

02:48:36,310 --> 02:48:44,170
having some requiring changes or forking

02:48:39,670 --> 02:48:47,050
you're all right this is so Versailles

02:48:44,170 --> 02:48:49,600
of GPU is so then correct me if I'm

02:48:47,050 --> 02:48:51,939
wrong Versailles of GPU is a very basic

02:48:49,600 --> 02:48:55,619
vert I Oh driver it's just exposing a

02:48:51,939 --> 02:48:59,199
DMA command buffer to the user space and

02:48:55,619 --> 02:49:01,149
we had some concerns that because verso

02:48:59,199 --> 02:49:04,630
GPU 3d is typically being used with

02:49:01,149 --> 02:49:06,310
Virgil which is taking OpenGL ES streams

02:49:04,630 --> 02:49:07,510
and then converting to gallium and then

02:49:06,310 --> 02:49:10,029
writing them into this command buffer

02:49:07,510 --> 02:49:12,130
and then communicating them back to the

02:49:10,029 --> 02:49:13,779
virtual support inside qme a virtual

02:49:12,130 --> 02:49:16,569
memory support that we wouldn't want to

02:49:13,779 --> 02:49:18,189
conflate that when we added our GPU

02:49:16,569 --> 02:49:19,750
tunneling support because we want to

02:49:18,189 --> 02:49:25,449
support Vulcan ultimately and we want to

02:49:19,750 --> 02:49:27,159
support emulator and so we don't want my

02:49:25,449 --> 02:49:28,930
transliterated GL shader or a

02:49:27,159 --> 02:49:30,520
transliterated GL control stream we

02:49:28,930 --> 02:49:34,090
don't need to run desktop GL inside

02:49:30,520 --> 02:49:36,460
Android so what we're looking at writing

02:49:34,090 --> 02:49:38,289
just a very simple binary of binary

02:49:36,460 --> 02:49:41,590
representation of the OpenGL commands

02:49:38,289 --> 02:49:43,029
into that command buffer instead so I

02:49:41,590 --> 02:49:45,399
don't know whether we'd actually need to

02:49:43,029 --> 02:49:47,350
tweak the vote I expect a denote like we

02:49:45,399 --> 02:49:51,189
are doing this crazy thing in the Bob I

02:49:47,350 --> 02:49:56,460
know I know I rolled it but it's been a

02:49:51,189 --> 02:49:58,779
while I pretty sure I respect the 3d

02:49:56,460 --> 02:50:01,029
there's like you can pick a start of a

02:49:58,779 --> 02:50:03,460
new protocol so you can add acceleration

02:50:01,029 --> 02:50:04,779
protocols to the kernel so current

02:50:03,460 --> 02:50:06,880
leaders only it only exposes one

02:50:04,779 --> 02:50:08,829
acceleration protocol to the capability

02:50:06,880 --> 02:50:10,689
set system it exposes one acceleration

02:50:08,829 --> 02:50:12,819
force which is treaty you can expose

02:50:10,689 --> 02:50:14,590
another I plans to expose spice and a

02:50:12,819 --> 02:50:19,350
few other things but like right so we

02:50:14,590 --> 02:50:19,350
could do something like add an idea yeah

02:50:19,949 --> 02:50:25,239
yeah the kernel will ask the cueing me

02:50:23,170 --> 02:50:27,069
for a list of potted supports and you

02:50:25,239 --> 02:50:29,109
can do then support your own one you can

02:50:27,069 --> 02:50:31,210
expose it to you mean converse I have 3d

02:50:29,109 --> 02:50:32,289
that's ygp 3d is absolutely fine for

02:50:31,210 --> 02:50:33,699
what we were using us just literally

02:50:32,289 --> 02:50:35,439
that change and we just wanted to make

02:50:33,699 --> 02:50:37,000
sure that we didn't make it cause any

02:50:35,439 --> 02:50:39,221
confusion about writing a binary stream

02:50:37,000 --> 02:50:42,161
that's not compact

02:50:39,221 --> 02:50:43,721
yeah I'm very happy to take upstream if

02:50:42,161 --> 02:50:45,400
we can work that out but I nearly short

02:50:43,721 --> 02:50:47,951
yeah just adding another acceleration

02:50:45,400 --> 02:50:55,421
profile should then you can do what you

02:50:47,951 --> 02:50:59,161
want on your pipes awesome have you

02:50:55,421 --> 02:51:04,391
thought of using cross VM instead of Kim

02:50:59,161 --> 02:51:05,921
yes so one of the reasons one of the

02:51:04,391 --> 02:51:08,051
reasons why we want to make sure that we

02:51:05,921 --> 02:51:11,230
are ver tire clean is that we are not

02:51:08,051 --> 02:51:12,521
tied to QM so one of the one of the

02:51:11,230 --> 02:51:13,931
things you'll see when you actually try

02:51:12,521 --> 02:51:16,091
cuttlefishes that's doing this thing

02:51:13,931 --> 02:51:19,781
where it's using its spawning an IV SH

02:51:16,091 --> 02:51:21,641
man in program attached is to qmu to

02:51:19,781 --> 02:51:22,900
provide shared memory between the guests

02:51:21,641 --> 02:51:24,431
and the host and kind of want to get rid

02:51:22,900 --> 02:51:27,791
of that because it's very specific to Q

02:51:24,431 --> 02:51:29,561
mu so what we want to do is make sure

02:51:27,791 --> 02:51:31,781
everything uses Verto instead and then

02:51:29,561 --> 02:51:33,821
we should be more hypervisor agnostic

02:51:31,781 --> 02:51:35,201
but for our own internal reasons we may

02:51:33,821 --> 02:51:37,181
want to use it across VM at some point

02:51:35,201 --> 02:51:39,221
and you can probably figure out that

02:51:37,181 --> 02:51:41,610
might lead to other things happening as

02:51:39,221 --> 02:51:41,610
a result

02:51:43,439 --> 02:51:48,380
but it will be qmu in AOSP for the time

02:51:46,170 --> 02:51:48,380
being

02:51:51,750 --> 02:51:56,489
all right just wanted to make a comment

02:51:54,540 --> 02:51:58,350
on the difference between cuttlefish in

02:51:56,489 --> 02:52:00,660
the emulator they serve different

02:51:58,350 --> 02:52:03,899
audiences the emulator has to run on

02:52:00,660 --> 02:52:06,510
Windows Esther on Mac OS cuttlefish only

02:52:03,899 --> 02:52:09,330
ever cares about running on Linux and so

02:52:06,510 --> 02:52:12,210
that allows us to move faster and to

02:52:09,330 --> 02:52:13,890
have a cleaner code base so the reason

02:52:12,210 --> 02:52:16,140
why the emulator has to run on Mac OS

02:52:13,890 --> 02:52:18,750
and on Windows is like Queen whisky M is

02:52:16,140 --> 02:52:21,029
patched in the first place so it's just

02:52:18,750 --> 02:52:25,170
a long to different to different

02:52:21,029 --> 02:52:26,640
audiences is what I wanted to say yeah

02:52:25,170 --> 02:52:28,109
another cool thing you can do with

02:52:26,640 --> 02:52:29,520
cuttlefish kernels as well as you can

02:52:28,109 --> 02:52:31,080
run them just on the command line with Q

02:52:29,520 --> 02:52:32,609
mu so there's nothing specifically being

02:52:31,080 --> 02:52:34,020
changed in the queue DEFCON 4 gotta

02:52:32,609 --> 02:52:36,239
patches that would disallow you from

02:52:34,020 --> 02:52:37,410
using just a normal Q I mean flow so if

02:52:36,239 --> 02:52:38,970
you just wanted to boot like a Linux

02:52:37,410 --> 02:52:41,160
file system just test some uses base

02:52:38,970 --> 02:52:43,140
code or unlike some other binary that's

02:52:41,160 --> 02:52:45,870
hard to get on Android you can just fire

02:52:43,140 --> 02:52:47,310
up the and the Android binary kernel

02:52:45,870 --> 02:52:49,260
test exactly the same thing using a

02:52:47,310 --> 02:52:50,790
Linux user space which would goldfish is

02:52:49,260 --> 02:52:52,590
a bit of a pain because it's expecting

02:52:50,790 --> 02:52:54,029
things like the non driver and the pipe

02:52:52,590 --> 02:52:55,319
driver and everything to be on the QM

02:52:54,029 --> 02:52:57,770
side which a couple of fish does not

02:52:55,319 --> 02:52:57,770
require

02:53:00,360 --> 02:53:03,650
okay thank you

02:53:07,220 --> 02:53:11,909
okay so this is that was pretty much the

02:53:09,839 --> 02:53:13,520
last talk here there's one just one last

02:53:11,909 --> 02:53:15,869
housekeeping thing I wanted to do before

02:53:13,520 --> 02:53:18,119
people kind of run out of the room

02:53:15,869 --> 02:53:20,399
especially for people that were actually

02:53:18,119 --> 02:53:22,289
doing a presentation here it could be

02:53:20,399 --> 02:53:29,899
one second if I can grab this and get it

02:53:22,289 --> 02:53:32,459
to do if I can find my mouse all right

02:53:29,899 --> 02:53:33,479
bingo so I had some questions we're

02:53:32,459 --> 02:53:35,970
running filling this out for the

02:53:33,479 --> 02:53:40,979
speakers I'm just gonna take the example

02:53:35,970 --> 02:53:42,810
of the binder the dynamically allocated

02:53:40,979 --> 02:53:44,100
binders so the winds there was one of

02:53:42,810 --> 02:53:46,319
the designs that seemed to kind of

02:53:44,100 --> 02:53:48,930
surface being like the primary thing

02:53:46,319 --> 02:53:50,669
chosen so I put that in there there was

02:53:48,930 --> 02:53:52,499
a few of them that were kind of

02:53:50,669 --> 02:53:54,449
discarded I put them in the losses so

02:53:52,499 --> 02:53:57,209
the idea there is just to kind of give a

02:53:54,449 --> 02:54:01,979
really quick snapshot of in your talk

02:53:57,209 --> 02:54:05,879
what you thought was the winning track

02:54:01,979 --> 02:54:07,560
or not so that people that are from the

02:54:05,879 --> 02:54:09,659
outside can get a bird's-eye view of

02:54:07,560 --> 02:54:11,009
what happens in your presentation it

02:54:09,659 --> 02:54:13,589
doesn't have to be paragraphs just like

02:54:11,009 --> 02:54:14,879
bullet items at most all right other

02:54:13,589 --> 02:54:17,970
than that thank you very much for

02:54:14,879 --> 02:54:20,100
attending for participating and you know

02:54:17,970 --> 02:54:22,260
best of luck with your upcoming Android

02:54:20,100 --> 02:54:28,049
project and see you next year

02:54:22,260 --> 02:54:28,049

YouTube URL: https://www.youtube.com/watch?v=xMtDDEj-02c


