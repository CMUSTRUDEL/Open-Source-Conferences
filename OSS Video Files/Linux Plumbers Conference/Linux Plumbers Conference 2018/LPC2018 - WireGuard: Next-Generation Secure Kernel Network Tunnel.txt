Title: LPC2018 - WireGuard: Next-Generation Secure Kernel Network Tunnel
Publication date: 2018-11-28
Playlist: Linux Plumbers Conference 2018
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/66/
speaker:  Jason Donenfeld


WireGuard [1] [2] is a new network tunneling mechanism written for
Linux, which, after three years of development, is nearly ready for
upstream. It uses a formally proven cryptographic protocol, custom
tailored for the Linux kernel, and has already seen very widespread
deployment, in everything from smart phones to massive data center
clusters. WireGuard uses a novel timer mechanism to hide state from
userspace, and in general presents userspace with a "stateless" and
"declarative" system of establishing secure tunnels. The codebase is
also remarkably small and has been written with a number of defense in
depth techniques. Integration into the larger Linux ecosystem is
advancing at a health rate, with recent patches for systemd and
NetworkManager merged. There is also ongoing work into combining
WireGuard with automatic configuration and mesh routing daemons on
Linux. This talk will focus on a wide variety of WireGuardâ€™s innards
and tentacles onto other projects. The presentation will walk through
WireGuard's integration into the netdev subsystem, its unique use of
network namespaces, why kernel space is necessary is necessary, the
various hurdles that have gone into designing a cryptographic protocol
specifically with kernel constraints in mind. It will also examine a
practical approach to formal verification, suitable for kernel
engineers and not just academics, and connect the ideas of that with
our extensive continuous integration testing framework across multiple
kernel architectures and versions. As if that was not already enough,
we will also take a close look at the interesting performance aspects
of doing high throughput CPU-bound computations in kernel space while
still keeping latency to a minimum. On the topic of smartphones, the
talk will examine power efficiency techniques of both the
implementation and of the protocol design, our experience in
integrating this into Android kernels, and the relationship between
cryptographic secrets and smartphones suspend cycles. Finally we will
look carefully at the WireGuard userspace API and its usage in various
daemons and managers. In short, this presentation will examine the
networking and cryptography design, the kernel engineering, and the
userspace integration considerations of WireGuard.

[1] https://www.wireguard.com
[2] https://www.wireguard.com/papers/wireguard.pdf
Captions: 
	00:00:06,550 --> 00:00:15,550
okay yet so this is on wire guard which

00:00:10,750 --> 00:00:19,420
is a new VPN tunnel made specifically

00:00:15,550 --> 00:00:23,619
for the Linux kernel so first a bit of

00:00:19,420 --> 00:00:25,930
background Jason this handle on the

00:00:23,619 --> 00:00:28,390
Internet and my background is mostly an

00:00:25,930 --> 00:00:32,680
exploitation i crypto voles colonel

00:00:28,390 --> 00:00:35,050
voles and so I've seen a lot of bugs

00:00:32,680 --> 00:00:36,610
I've exploited a lot of bugs and the

00:00:35,050 --> 00:00:39,430
goal of wire guard was to make something

00:00:36,610 --> 00:00:41,590
that has kind of a defense in depth

00:00:39,430 --> 00:00:45,460
against a lot of the bugs I've seen in

00:00:41,590 --> 00:00:47,590
the wild so what is my guard it's a

00:00:45,460 --> 00:00:50,649
layer three secure network tunnel for

00:00:47,590 --> 00:00:52,089
reform for v6 and as we'll see

00:00:50,649 --> 00:00:55,329
throughout the presentation it's it's

00:00:52,089 --> 00:00:58,059
very opinionated wire guard is only

00:00:55,329 --> 00:01:00,070
layer three because I think that layer

00:00:58,059 --> 00:01:02,769
three is the right way to do tunnels on

00:01:00,070 --> 00:01:05,170
your network so it doesn't have tons of

00:01:02,769 --> 00:01:07,860
knobs and options to configure in wild

00:01:05,170 --> 00:01:10,030
ways the general idea is if you

00:01:07,860 --> 00:01:12,310
configure your network around wire guard

00:01:10,030 --> 00:01:16,360
it'll probably have a better security

00:01:12,310 --> 00:01:17,800
posture than otherwise it's been

00:01:16,360 --> 00:01:20,290
designed for the Linux kernel so a lot

00:01:17,800 --> 00:01:21,730
of the the protocol decisions and crypto

00:01:20,290 --> 00:01:24,430
decisions have been motivated by the

00:01:21,730 --> 00:01:26,980
constraints given to us by kernel space

00:01:24,430 --> 00:01:29,170
but of course there are you know the

00:01:26,980 --> 00:01:31,180
slower user space cross-platform things

00:01:29,170 --> 00:01:36,090
so we can be everywhere

00:01:31,180 --> 00:01:36,090
it's udp-based it's not a new IP

00:01:36,330 --> 00:01:42,880
protocol type it's just UDP so it gets

00:01:39,100 --> 00:01:45,460
through the internet usually the

00:01:42,880 --> 00:01:47,860
cryptography is conservative but still

00:01:45,460 --> 00:01:51,370
modern so we don't want to use anything

00:01:47,860 --> 00:01:55,570
too newfangled but we we also want to be

00:01:51,370 --> 00:01:58,090
pretty kind of a slick and fast ISO

00:01:55,570 --> 00:02:00,370
we'll get into that in a bit and the

00:01:58,090 --> 00:02:01,990
emphasis is on being extremely simple

00:02:00,370 --> 00:02:04,570
and extremely honorable and wanted to be

00:02:01,990 --> 00:02:07,410
the kind of thing so one will will breed

00:02:04,570 --> 00:02:10,810
an afternoon just for pleasure

00:02:07,410 --> 00:02:15,370
the authentication is similar to SSH

00:02:10,810 --> 00:02:17,170
where both sides exchange little base64

00:02:15,370 --> 00:02:18,520
public keys now you're familiar with

00:02:17,170 --> 00:02:20,260
authorized keys you just kind of copy

00:02:18,520 --> 00:02:22,300
and paste in that file

00:02:20,260 --> 00:02:27,400
why our guard goes for kind of a similar

00:02:22,300 --> 00:02:29,590
familiar model it's it's supposed to be

00:02:27,400 --> 00:02:30,910
a replacement for many uses of Open VPN

00:02:29,590 --> 00:02:33,120
and IPSec

00:02:30,910 --> 00:02:36,880
certainly not all uses there are always

00:02:33,120 --> 00:02:39,370
you know good things that they cover

00:02:36,880 --> 00:02:41,650
specifically but for I think many of the

00:02:39,370 --> 00:02:46,060
uses why regardin tends to be a strong

00:02:41,650 --> 00:02:49,110
replacement for those and it originally

00:02:46,060 --> 00:02:53,349
grew out of a stealth rootkit project I

00:02:49,110 --> 00:02:55,660
had an exfiltration method that lived in

00:02:53,349 --> 00:02:58,900
the kernel space and I saw that a lot of

00:02:55,660 --> 00:03:00,670
the things I was doing for offensive

00:02:58,900 --> 00:03:03,489
security and you know kind of an attack

00:03:00,670 --> 00:03:06,220
scenario were even more useful in a

00:03:03,489 --> 00:03:08,380
defense scenario it turns out a lot of

00:03:06,220 --> 00:03:10,569
the things you need for being stealthy

00:03:08,380 --> 00:03:12,730
inside a network that you're after is

00:03:10,569 --> 00:03:17,799
equally as good for defending your own

00:03:12,730 --> 00:03:19,780
network so these numbers are a bit out

00:03:17,799 --> 00:03:21,670
of date now but the general idea holds I

00:03:19,780 --> 00:03:23,470
mean openvpn it's like a hundred

00:03:21,670 --> 00:03:25,720
thousand lines of code or so plus you

00:03:23,470 --> 00:03:28,209
need to open this a cell for Linux exif

00:03:25,720 --> 00:03:31,090
RM layer is around like 100,000 lines

00:03:28,209 --> 00:03:32,950
ish the knees like strongswan or some i

00:03:31,090 --> 00:03:34,180
caiman in the user space it's like

00:03:32,950 --> 00:03:35,290
strong twin itself is four hundred

00:03:34,180 --> 00:03:37,720
thousand eleven i mean these are very

00:03:35,290 --> 00:03:39,760
big projects so off to Ethier is kind of

00:03:37,720 --> 00:03:42,700
interesting it implements like every VPN

00:03:39,760 --> 00:03:43,630
protocol point one and that's you know

00:03:42,700 --> 00:03:45,639
three hundred thousand lines of code

00:03:43,630 --> 00:03:47,200
wire guard is trying to be like around

00:03:45,639 --> 00:03:50,350
four thousand lines of code it's a

00:03:47,200 --> 00:03:52,299
really like small thing that that

00:03:50,350 --> 00:03:54,630
security professionals will read in

00:03:52,299 --> 00:03:54,630
their free time

00:03:54,870 --> 00:04:01,120
they're always these these like internet

00:03:58,930 --> 00:04:02,950
fundraisers let's get this company to

00:04:01,120 --> 00:04:04,569
audit this project and then they'll be

00:04:02,950 --> 00:04:08,109
the hata report it'll be great and I

00:04:04,569 --> 00:04:09,400
guess that is good but a lot of these a

00:04:08,109 --> 00:04:11,160
lot of these projects that are being

00:04:09,400 --> 00:04:15,609
audited with all this you know a

00:04:11,160 --> 00:04:17,650
crowdfunded money and one night is so

00:04:15,609 --> 00:04:19,329
big that even if a company spends you

00:04:17,650 --> 00:04:21,820
know two weeks on it three weeks four

00:04:19,329 --> 00:04:23,830
weeks a bunch of Engineers the next day

00:04:21,820 --> 00:04:25,720
some other guy looks at another part

00:04:23,830 --> 00:04:28,360
that they didn't quite look at and finds

00:04:25,720 --> 00:04:29,830
even more bugs and it's just kind of the

00:04:28,360 --> 00:04:32,080
nature of the thing when a code base is

00:04:29,830 --> 00:04:33,700
really big you have a lot of bugs and

00:04:32,080 --> 00:04:35,470
it's hard to find them whereas

00:04:33,700 --> 00:04:38,350
but something remains small and

00:04:35,470 --> 00:04:40,540
manageable you not only get more

00:04:38,350 --> 00:04:42,970
eyeballs because people find it just

00:04:40,540 --> 00:04:44,380
kind of a manageable enjoyable thing but

00:04:42,970 --> 00:04:47,410
I think you can get a lot deeper

00:04:44,380 --> 00:04:49,060
coverage of that kind of thing you know

00:04:47,410 --> 00:04:50,800
if you spend three weeks on four

00:04:49,060 --> 00:04:52,360
thousand lines of code versus three

00:04:50,800 --> 00:04:54,640
weeks on you know hundred thousand lines

00:04:52,360 --> 00:04:56,170
you write you can see what happens so

00:04:54,640 --> 00:04:59,460
you know visualizing this and the

00:04:56,170 --> 00:05:02,410
planetary system where Pluto out there

00:04:59,460 --> 00:05:06,250
so why are guard also tries to be a very

00:05:02,410 --> 00:05:09,010
simple interface we don't want to

00:05:06,250 --> 00:05:11,470
introduce any new concepts so you you

00:05:09,010 --> 00:05:13,150
add the interface with IP link and you

00:05:11,470 --> 00:05:14,950
set the addresses the routes you can

00:05:13,150 --> 00:05:18,280
even use old-school I have config IP

00:05:14,950 --> 00:05:20,740
tables works the way you expect we'll

00:05:18,280 --> 00:05:23,230
see in a bit how the old-school let's

00:05:20,740 --> 00:05:25,960
the host allows deny is actually more

00:05:23,230 --> 00:05:27,880
secure under wire guard so the

00:05:25,960 --> 00:05:29,350
everything that builds on top of an

00:05:27,880 --> 00:05:33,160
ordinary network interface that you

00:05:29,350 --> 00:05:36,040
already know how to use can work on wire

00:05:33,160 --> 00:05:40,770
guys so we're you have in one case eth0

00:05:36,040 --> 00:05:46,950
or wlan0 with la Gardie you have WG zero

00:05:40,770 --> 00:05:49,480
our guard is also a bit blasphemous we

00:05:46,950 --> 00:05:53,020
we step away from a lot of their really

00:05:49,480 --> 00:05:55,720
pristine layering assumptions that were

00:05:53,020 --> 00:05:59,500
done in IPSec so an IPSec there's like a

00:05:55,720 --> 00:06:04,570
transformation table which like

00:05:59,500 --> 00:06:05,830
coordinates with a policy daemon and the

00:06:04,570 --> 00:06:07,960
key exchange is managed in the user

00:06:05,830 --> 00:06:10,900
space is one layer whereas you have the

00:06:07,960 --> 00:06:12,430
actual data packet encryption in the

00:06:10,900 --> 00:06:16,270
kernel and it's like nicely separated

00:06:12,430 --> 00:06:18,550
and pluggable and extensible and it's

00:06:16,270 --> 00:06:20,500
not hooked into the routing layer it's

00:06:18,550 --> 00:06:22,870
something else so that you can keep

00:06:20,500 --> 00:06:24,280
track of the exact marks on the packets

00:06:22,870 --> 00:06:27,850
and it's all kind of like very nicely

00:06:24,280 --> 00:06:30,820
layered but it turns out with a lot of

00:06:27,850 --> 00:06:32,650
that pristine layering that kind of like

00:06:30,820 --> 00:06:34,270
academically nice layering is you get

00:06:32,650 --> 00:06:37,860
all this complexity that people just

00:06:34,270 --> 00:06:40,870
can't really manage or deploy well it's

00:06:37,860 --> 00:06:42,910
you you have to become you know

00:06:40,870 --> 00:06:44,260
something of an expert to deploy that

00:06:42,910 --> 00:06:46,210
kind of thing and then feel good that

00:06:44,260 --> 00:06:47,110
you've done the right thing so why are

00:06:46,210 --> 00:06:48,430
guard

00:06:47,110 --> 00:06:49,690
it's rid of the layering smooshes

00:06:48,430 --> 00:06:53,230
everything down to the network interface

00:06:49,690 --> 00:06:55,240
which is in a sense wrong it creates

00:06:53,230 --> 00:06:59,320
contradictions but then we've got a lot

00:06:55,240 --> 00:07:01,360
of really nice solutions and engineering

00:06:59,320 --> 00:07:05,220
decisions that that mitigate those

00:07:01,360 --> 00:07:07,480
contradictions to make it coherent again

00:07:05,220 --> 00:07:08,980
so the fundamental idea is called

00:07:07,480 --> 00:07:12,880
cryptokey routing so we have an

00:07:08,980 --> 00:07:16,780
association between the piers public

00:07:12,880 --> 00:07:20,290
keys and the IP addresses that the pier

00:07:16,780 --> 00:07:22,480
is allowed to be inside the tunnel so

00:07:20,290 --> 00:07:24,730
they can have any IP addresses outside

00:07:22,480 --> 00:07:26,470
the tunnel like their public internet

00:07:24,730 --> 00:07:28,960
facing endpoint but inside the tunnel

00:07:26,470 --> 00:07:30,970
each peer is bound to a certain set of

00:07:28,960 --> 00:07:34,570
tunneled IP addresses allowed IP

00:07:30,970 --> 00:07:36,490
addresses so the general scheme of

00:07:34,570 --> 00:07:39,190
things a wire guard interface has a

00:07:36,490 --> 00:07:40,870
private key and it listens on a UDP port

00:07:39,190 --> 00:07:45,580
on the Internet and then it has a list

00:07:40,870 --> 00:07:48,160
of peers each peer has his identity by

00:07:45,580 --> 00:07:51,580
this public key so up here is a public

00:07:48,160 --> 00:07:53,050
key and then it has this list of of

00:07:51,580 --> 00:07:57,610
tunneled IP addresses allowed IP

00:07:53,050 --> 00:08:01,420
addresses so were you to talk to a

00:07:57,610 --> 00:08:03,550
server that you wanted to tunnel all

00:08:01,420 --> 00:08:05,980
your traffic maybe that server would

00:08:03,550 --> 00:08:08,650
have would have allowed IP 0 /z or the

00:08:05,980 --> 00:08:11,100
whole internet well trust that this peer

00:08:08,650 --> 00:08:13,680
it's telling me the whole internet but

00:08:11,100 --> 00:08:16,540
if you're connecting to another site and

00:08:13,680 --> 00:08:19,270
you only want that site to give you like

00:08:16,540 --> 00:08:22,210
a / 24 then you would only trust that

00:08:19,270 --> 00:08:24,790
site to telling us last 24 and then

00:08:22,210 --> 00:08:30,520
finally peer optionally has an endpoint

00:08:24,790 --> 00:08:32,260
IP and port optionally because if if you

00:08:30,520 --> 00:08:35,680
don't put it the first time that peer

00:08:32,260 --> 00:08:37,090
connects to you you'll learn it and if

00:08:35,680 --> 00:08:38,770
it ever changes IP you learned that new

00:08:37,090 --> 00:08:42,550
IP and so it'll roam around a lot like

00:08:38,770 --> 00:08:45,040
mosh if you've ever used that so the the

00:08:42,550 --> 00:08:46,690
fundamental idea here is this one or one

00:08:45,040 --> 00:08:50,170
relationship between a public key and an

00:08:46,690 --> 00:08:51,520
IP address if you give me a public key I

00:08:50,170 --> 00:08:53,620
can tell you the list of P addresses

00:08:51,520 --> 00:08:55,960
it's allowed to be more importantly if

00:08:53,620 --> 00:08:58,030
you give me an IP address there's only

00:08:55,960 --> 00:08:59,020
one peer that could possibly have been

00:08:58,030 --> 00:09:03,190
that IP

00:08:59,020 --> 00:09:07,570
dress inside the tunnel so to look at a

00:09:03,190 --> 00:09:11,200
simple configuration a server here has

00:09:07,570 --> 00:09:13,270
maybe two clients one of them is allowed

00:09:11,200 --> 00:09:15,160
to be the slash 32 so only this IP

00:09:13,270 --> 00:09:18,550
address and then this whole kind of

00:09:15,160 --> 00:09:21,250
network that slash 24 likewise this pier

00:09:18,550 --> 00:09:23,760
can be this slash 32 and maybe also we

00:09:21,250 --> 00:09:26,590
give it that slash sixteen network

00:09:23,760 --> 00:09:28,300
meanwhile on a client might say okay

00:09:26,590 --> 00:09:29,860
will allow the server to tunnel the

00:09:28,300 --> 00:09:36,700
whole internet so the server can send me

00:09:29,860 --> 00:09:38,860
traffic for anybody and by the way if

00:09:36,700 --> 00:09:40,810
this is confusing feel free to interrupt

00:09:38,860 --> 00:09:42,370
during it and just call out a question

00:09:40,810 --> 00:09:49,620
because these are kind of fundamental

00:09:42,370 --> 00:09:52,180
concepts to get down so you're saying

00:09:49,620 --> 00:09:54,130
I'm basically doing peer-to-peer

00:09:52,180 --> 00:09:55,870
communication but you're opening up a

00:09:54,130 --> 00:09:58,510
whole network why the whole network

00:09:55,870 --> 00:10:01,350
instead of the point-to-point connection

00:09:58,510 --> 00:10:04,060
so it's a tunnel right so it is

00:10:01,350 --> 00:10:05,560
point-to-point between two peers but on

00:10:04,060 --> 00:10:08,860
one end you might have a peer that's

00:10:05,560 --> 00:10:10,980
like a router and behind that wire guard

00:10:08,860 --> 00:10:13,330
peer you have like a whole network

00:10:10,980 --> 00:10:15,250
physically connected and then you want

00:10:13,330 --> 00:10:17,080
to be able to tunnel everybody but for

00:10:15,250 --> 00:10:19,420
many people they're just fine sending a

00:10:17,080 --> 00:10:22,900
single IP I mean it can work with any

00:10:19,420 --> 00:10:23,530
topology you know any pattern of

00:10:22,900 --> 00:10:25,090
networks

00:10:23,530 --> 00:10:28,060
it doesn't really matter client-server

00:10:25,090 --> 00:10:29,890
is kind of the obvious case but you

00:10:28,060 --> 00:10:37,000
could do full meshes or anything like

00:10:29,890 --> 00:10:39,790
that okay so the the flow of this is

00:10:37,000 --> 00:10:43,150
user space sends a packet using you know

00:10:39,790 --> 00:10:44,980
send or write or whatever it's the Linux

00:10:43,150 --> 00:10:46,540
kernel the ordinary routing table stuff

00:10:44,980 --> 00:10:49,090
and Linux says alright it looks like

00:10:46,540 --> 00:10:50,980
that's for wd0 of the interface and now

00:10:49,090 --> 00:10:52,840
the wire guard driver starts managing it

00:10:50,980 --> 00:10:55,600
and it looks at the destination IP

00:10:52,840 --> 00:10:58,930
address of that packet to determine

00:10:55,600 --> 00:11:00,250
which peer should it be sent to and then

00:10:58,930 --> 00:11:04,000
why our guard will encrypt it fit up

00:11:00,250 --> 00:11:07,150
here and send it off in reverse wire

00:11:04,000 --> 00:11:08,950
guard gets an encrypted UDP packet yet

00:11:07,150 --> 00:11:10,930
decrypt the packet and in doing so it

00:11:08,950 --> 00:11:12,790
learns which peer sent it which public

00:11:10,930 --> 00:11:16,260
key sent it

00:11:12,790 --> 00:11:19,600
and then it looks at the source IP and

00:11:16,260 --> 00:11:22,720
it says were I sending to the source IP

00:11:19,600 --> 00:11:24,940
which appear would I be sending to and

00:11:22,720 --> 00:11:28,270
if that turns out to be the same as the

00:11:24,940 --> 00:11:30,100
peer that sent it then it's allowed and

00:11:28,270 --> 00:11:34,180
then it's handed to the Linux networking

00:11:30,100 --> 00:11:36,010
stack and otherwise it's dropped just a

00:11:34,180 --> 00:11:36,940
clarifying question when you decrypt the

00:11:36,010 --> 00:11:38,560
packet does that mean if you have

00:11:36,940 --> 00:11:39,820
multiple public keys you have to decrypt

00:11:38,560 --> 00:11:42,280
with each one to find out which one

00:11:39,820 --> 00:11:43,930
works or is there some more there's an

00:11:42,280 --> 00:11:49,090
index in there so we do want there's no

00:11:43,930 --> 00:11:50,410
trial decryption so again with this

00:11:49,090 --> 00:11:53,920
there is this like 1:1 relationship

00:11:50,410 --> 00:11:58,330
between the source IP of the packet and

00:11:53,920 --> 00:11:59,890
then the peer that actually sent it so

00:11:58,330 --> 00:12:03,850
it makes system administration super

00:11:59,890 --> 00:12:06,520
easy if it comes from WG 0 and it's from

00:12:03,850 --> 00:12:09,460
yoshis total IP address of you know 91

00:12:06,520 --> 00:12:11,740
68 517 then it definitely came from

00:12:09,460 --> 00:12:13,810
Yoshi we're sure about that and all we

00:12:11,740 --> 00:12:15,540
need to know is is it from wire guard

00:12:13,810 --> 00:12:18,310
interface and does it have a certain IP

00:12:15,540 --> 00:12:20,110
and so the IP tables rules for this or

00:12:18,310 --> 00:12:25,360
you know obvious it's like you know the

00:12:20,110 --> 00:12:28,240
- I and - s right and now suddenly at C

00:12:25,360 --> 00:12:30,160
host loud and I work which is kind of

00:12:28,240 --> 00:12:31,960
crazy I'm not saying people should use

00:12:30,160 --> 00:12:37,360
that stuff anymore but you do now have

00:12:31,960 --> 00:12:40,660
the strict binding to IP addresses so

00:12:37,360 --> 00:12:42,040
the way we make this look stateless to

00:12:40,660 --> 00:12:49,750
user space where you just like set it up

00:12:42,040 --> 00:12:52,510
and go is with a set of timers so you

00:12:49,750 --> 00:12:54,940
set up the peers and then it works and

00:12:52,510 --> 00:12:56,589
we'll look at a demo in a bit and the

00:12:54,940 --> 00:12:58,600
way we do this is we have timers in the

00:12:56,589 --> 00:13:00,339
in the kernel that manage all the state

00:12:58,600 --> 00:13:03,210
of the protocol for you there's never a

00:13:00,339 --> 00:13:07,150
concept that's exposed to the user of

00:13:03,210 --> 00:13:10,750
connecting connected the tunnel is there

00:13:07,150 --> 00:13:12,339
and configured or it's not and we've

00:13:10,750 --> 00:13:13,390
tried to design a super simple state

00:13:12,339 --> 00:13:15,400
machine so that every possible

00:13:13,390 --> 00:13:18,610
transition between states is accounted

00:13:15,400 --> 00:13:19,780
for so how's it work use your space

00:13:18,610 --> 00:13:23,650
sends a packet

00:13:19,780 --> 00:13:25,510
if we have no session for the last two

00:13:23,650 --> 00:13:28,840
minutes then we send a handshake

00:13:25,510 --> 00:13:31,690
initiation packet if we don't have a

00:13:28,840 --> 00:13:34,440
handshake response after five seconds we

00:13:31,690 --> 00:13:39,330
send a new handshake initiation packet

00:13:34,440 --> 00:13:44,050
if we successfully receive an

00:13:39,330 --> 00:13:47,290
authenticated incoming packet there are

00:13:44,050 --> 00:13:49,360
two cases one is that we naturally have

00:13:47,290 --> 00:13:51,760
something to reply so you send me a ping

00:13:49,360 --> 00:13:53,260
I've got a pong to send back to you the

00:13:51,760 --> 00:13:55,540
other case is you send me something I

00:13:53,260 --> 00:13:57,490
got the message great but I don't have

00:13:55,540 --> 00:13:59,980
anything to say back and so after 10

00:13:57,490 --> 00:14:03,730
seconds of not having anything to say

00:13:59,980 --> 00:14:05,830
I send you an empty authenticated packet

00:14:03,730 --> 00:14:08,050
just so you know that I at least got

00:14:05,830 --> 00:14:09,370
there so then if you don't if you've

00:14:08,050 --> 00:14:11,620
sent something but you don't receive

00:14:09,370 --> 00:14:13,150
anything back within 15 seconds then we

00:14:11,620 --> 00:14:14,440
just go back to the bidding at beginning

00:14:13,150 --> 00:14:16,210
of the state machine and we send a

00:14:14,440 --> 00:14:18,270
handshake initiation packet we know

00:14:16,210 --> 00:14:21,070
something has gone wrong in the protocol

00:14:18,270 --> 00:14:22,450
and so with this kind of very simple

00:14:21,070 --> 00:14:24,880
model we can always keep a connection

00:14:22,450 --> 00:14:31,870
active and we'll see it's got some nice

00:14:24,880 --> 00:14:33,520
stealth properties out of it too so yeah

00:14:31,870 --> 00:14:36,520
you have an interface through the peers

00:14:33,520 --> 00:14:39,910
immediately it's sent and usually the

00:14:36,520 --> 00:14:43,270
way this works is you it's very hard to

00:14:39,910 --> 00:14:45,790
miss configure this the tunnel just

00:14:43,270 --> 00:14:49,210
won't work a lot of the time if it's

00:14:45,790 --> 00:14:51,390
misconfigured and so it fails safe

00:14:49,210 --> 00:14:54,400
rather than failing open there's no like

00:14:51,390 --> 00:14:55,990
it worked great but oh I was in like the

00:14:54,400 --> 00:14:58,089
null cipher mode and so I had no

00:14:55,990 --> 00:15:02,320
security it's either you know working or

00:14:58,089 --> 00:15:03,790
it's not working and as I mentioned that

00:15:02,320 --> 00:15:05,560
the endpoints are roam which is really

00:15:03,790 --> 00:15:07,030
convenient so if you put your laptop to

00:15:05,560 --> 00:15:10,390
sleep and open up on another network

00:15:07,030 --> 00:15:13,120
you're still on the tunnel or on mobile

00:15:10,390 --> 00:15:18,010
it can go between wireless and the

00:15:13,120 --> 00:15:19,450
cellular network seamlessly and you know

00:15:18,010 --> 00:15:22,270
the identities or something you're used

00:15:19,450 --> 00:15:23,380
to is just like SSH and everything else

00:15:22,270 --> 00:15:25,330
is kind of invisible to the

00:15:23,380 --> 00:15:28,500
administrator so let's let's take a look

00:15:25,330 --> 00:15:28,500
at how this works yeah

00:15:30,760 --> 00:15:37,160
thank you how do you deal with key

00:15:34,880 --> 00:15:40,070
exchange basically we said the public

00:15:37,160 --> 00:15:41,480
key is is what you're indexing with how

00:15:40,070 --> 00:15:43,310
do you get the initial public private

00:15:41,480 --> 00:15:48,079
key exchange done so it's the same as

00:15:43,310 --> 00:15:51,170
SSH with SSH people will do it somehow

00:15:48,079 --> 00:15:53,329
and so the let's go yeah I mean so the

00:15:51,170 --> 00:15:56,089
idea is like there's public key

00:15:53,329 --> 00:15:59,360
cryptography going on here but surely

00:15:56,089 --> 00:16:01,250
every new protocol that uses a form of

00:15:59,360 --> 00:16:03,680
public key cryptography shouldn't be

00:16:01,250 --> 00:16:05,300
required to resolve the key exchange

00:16:03,680 --> 00:16:07,880
problem or the key distribution problem

00:16:05,300 --> 00:16:10,399
rather so why our guard can hook into

00:16:07,880 --> 00:16:13,220
LDAP if that that's there you can you

00:16:10,399 --> 00:16:15,529
know set up TLS Damons you can hook into

00:16:13,220 --> 00:16:17,180
terrible job of frameworks I mean any

00:16:15,529 --> 00:16:20,149
kind of existing copy and paste is

00:16:17,180 --> 00:16:21,380
popular a lot of people are kind of

00:16:20,149 --> 00:16:23,240
doing cloud deployments where they have

00:16:21,380 --> 00:16:27,230
like ansible sending all these out to

00:16:23,240 --> 00:16:29,570
their servers already yeah anything

00:16:27,230 --> 00:16:31,970
works we don't impose a particular key

00:16:29,570 --> 00:16:33,610
distribution you say the endpoints are

00:16:31,970 --> 00:16:36,709
like hidden from the admin is that

00:16:33,610 --> 00:16:38,930
obscured for a reason or is that like

00:16:36,709 --> 00:16:41,540
available for debugging if some things

00:16:38,930 --> 00:16:44,149
are you you can there's like a debug log

00:16:41,540 --> 00:16:45,890
and but that the point is like you don't

00:16:44,149 --> 00:16:47,690
ever need to monitor is it connecting

00:16:45,890 --> 00:16:49,010
connected but let's let's do the demo

00:16:47,690 --> 00:16:50,270
and I think that might answer some

00:16:49,010 --> 00:16:53,980
questions and then after that we'll

00:16:50,270 --> 00:16:53,980
we'll get back to that

00:16:57,910 --> 00:17:06,490
okay so we have pure a and pure B Alice

00:17:01,840 --> 00:17:09,640
Bob usual characters so we generate a

00:17:06,490 --> 00:17:12,100
key on Alice and to private W Jen key

00:17:09,640 --> 00:17:14,079
and then we do the same on Bob and when

00:17:12,100 --> 00:17:18,420
you look at it it's just like 32 bytes

00:17:14,079 --> 00:17:20,470
in base 64 and we can drive a public key

00:17:18,420 --> 00:17:23,110
we can drive a public key from the

00:17:20,470 --> 00:17:25,660
private key with WG pub keys so just

00:17:23,110 --> 00:17:30,130
like really basic kind of unix-like

00:17:25,660 --> 00:17:33,820
commands all right now we add the

00:17:30,130 --> 00:17:35,280
interface IP link add just usual thing

00:17:33,820 --> 00:17:37,390
and then we can give it an IP address

00:17:35,280 --> 00:17:39,730
again this is like not wired are

00:17:37,390 --> 00:17:45,250
specific this is kind of network admin

00:17:39,730 --> 00:17:47,020
101 on Linux and then we can we can set

00:17:45,250 --> 00:17:50,710
the private key that we just aerated

00:17:47,020 --> 00:17:53,200
using the WG utility and we set the

00:17:50,710 --> 00:17:57,130
interface up and now we can do the same

00:17:53,200 --> 00:18:04,990
on Bob we add the interface you know we

00:17:57,130 --> 00:18:06,730
give it the IP address and we say here's

00:18:04,990 --> 00:18:10,470
the private key that's the private file

00:18:06,730 --> 00:18:10,470
that we just generated and we sit up

00:18:12,840 --> 00:18:18,850
okay so now when we hit IP address we

00:18:15,220 --> 00:18:20,680
have multiple different interfaces so

00:18:18,850 --> 00:18:23,710
first eth0 we can pretend that's like

00:18:20,680 --> 00:18:26,920
our internet facing interface so like if

00:18:23,710 --> 00:18:30,160
one I need to 168 range then WG 0 that's

00:18:26,920 --> 00:18:33,790
our tunnel and so that the 10 / 24

00:18:30,160 --> 00:18:35,530
network is inside the tunnel and so

00:18:33,790 --> 00:18:37,870
we'll be telling the peers about each

00:18:35,530 --> 00:18:39,250
other now that's when we hit W G we see

00:18:37,870 --> 00:18:40,420
the current status there public key and

00:18:39,250 --> 00:18:44,560
private key and they're listening on a

00:18:40,420 --> 00:18:46,180
port and now we can tell Alice about Bob

00:18:44,560 --> 00:18:49,390
so this case the key distribution

00:18:46,180 --> 00:18:51,790
mechanism is copy and paste and Bob is

00:18:49,390 --> 00:18:53,860
allowed to be 1000 to inside the tunnel

00:18:51,790 --> 00:18:59,560
and it can be reached on the Internet at

00:18:53,860 --> 00:19:01,030
192 168 1 dot 2 4 5 182 both and then

00:18:59,560 --> 00:19:04,420
we'll do the same thing on Bob will tell

00:19:01,030 --> 00:19:09,470
Bob about Alice so we set the peer a

00:19:04,420 --> 00:19:13,789
public key will give it the allowed ip's

00:19:09,470 --> 00:19:15,649
so in this case Alice is 1000 1/32

00:19:13,789 --> 00:19:20,960
inside the tunnel and the end point is

00:19:15,649 --> 00:19:22,249
when I see 168 1 by 182 oh and that's it

00:19:20,960 --> 00:19:24,889
now we just ping the other side and

00:19:22,249 --> 00:19:26,989
Margaret handles the rest it's there's

00:19:24,889 --> 00:19:29,869
like not a lot more to wire ger than

00:19:26,989 --> 00:19:31,909
that it's kind of all it does when we

00:19:29,869 --> 00:19:33,109
hit WG now you see there's there's a

00:19:31,909 --> 00:19:34,849
handshake that happened

00:19:33,109 --> 00:19:38,109
there's the pier and it you know shows

00:19:34,849 --> 00:19:40,820
you the amount of transferring and such

00:19:38,109 --> 00:19:42,889
but that's it it's not a more

00:19:40,820 --> 00:19:44,539
complicated thing like that wire guard

00:19:42,889 --> 00:19:46,609
is trying to just be the simple building

00:19:44,539 --> 00:19:49,789
block from which you could make more

00:19:46,609 --> 00:19:53,269
complicated things okay where they're

00:19:49,789 --> 00:19:55,039
still questions given that so you

00:19:53,269 --> 00:19:56,239
mentioned key distribution is not a

00:19:55,039 --> 00:19:57,769
problem you're trying to solve

00:19:56,239 --> 00:19:59,960
if you've already solved key

00:19:57,769 --> 00:20:01,759
distribution for a different key type do

00:19:59,960 --> 00:20:05,929
you have some way of deriving wire guard

00:20:01,759 --> 00:20:09,950
keys from say like an x.509 key I mean

00:20:05,929 --> 00:20:13,220
you could maybe do that the wire guard

00:20:09,950 --> 00:20:16,659
private key you generate by picking a

00:20:13,220 --> 00:20:18,710
random number masking off some bits and

00:20:16,659 --> 00:20:20,989
multiplying it by the base point on an

00:20:18,710 --> 00:20:21,859
elliptic curve and so presumably you

00:20:20,989 --> 00:20:24,590
could pull this kind of thing out of

00:20:21,859 --> 00:20:28,700
x.509 or you could even put it in x.509

00:20:24,590 --> 00:20:31,429
and if that's your thing sure I'm not

00:20:28,700 --> 00:20:41,149
advocating anyone use x.509 ever for

00:20:31,429 --> 00:20:43,549
anything but you could do it I was

00:20:41,149 --> 00:20:45,529
curious does wire guard implement any

00:20:43,549 --> 00:20:46,399
form of perfect forward security it does

00:20:45,529 --> 00:20:48,799
so we'll get into the security

00:20:46,399 --> 00:20:51,889
properties in a bit but it has all the

00:20:48,799 --> 00:20:53,299
nice things you want yeah what issues

00:20:51,889 --> 00:20:54,259
would open be n in particular is the

00:20:53,299 --> 00:20:56,859
fact that everything has to go through

00:20:54,259 --> 00:20:58,820
user spaces back have you done any

00:20:56,859 --> 00:21:01,070
differential performance analysis

00:20:58,820 --> 00:21:03,529
between your kernel implementation might

00:21:01,070 --> 00:21:04,940
be stuck and OpenVPN yes and we'll have

00:21:03,529 --> 00:21:06,889
numbers in a bit so let's let's move on

00:21:04,940 --> 00:21:09,769
I think it'll answer a lot yeah I just

00:21:06,889 --> 00:21:12,169
have a comment your key distribution

00:21:09,769 --> 00:21:15,109
things like one of the nice properties

00:21:12,169 --> 00:21:16,970
of this is and I've been talking to

00:21:15,109 --> 00:21:19,070
Jason about trying to do this is to

00:21:16,970 --> 00:21:21,410
build on top of the wide route

00:21:19,070 --> 00:21:22,880
interfaces once you connect to

00:21:21,410 --> 00:21:25,760
yeah you can run something like the

00:21:22,880 --> 00:21:27,260
routing protocol on top of it and define

00:21:25,760 --> 00:21:29,660
an extensions you writing program

00:21:27,260 --> 00:21:31,340
distribute or the other keys so you can

00:21:29,660 --> 00:21:39,380
build a full mesh that automatically

00:21:31,340 --> 00:21:42,350
learns the other piece yeah okay sue

00:21:39,380 --> 00:21:44,720
so WG as you saw is like the

00:21:42,350 --> 00:21:49,400
configuration tool really basic small

00:21:44,720 --> 00:21:51,980
thing works just like IP similar kind of

00:21:49,400 --> 00:21:53,510
syntax and then you can build more

00:21:51,980 --> 00:21:55,460
things on top of it so we're already in

00:21:53,510 --> 00:21:59,050
the lots of network managers we're an

00:21:55,460 --> 00:22:01,970
open were over C NICS system D Network D

00:21:59,050 --> 00:22:05,990
Linux kit we're an edge router stuff

00:22:01,970 --> 00:22:07,970
network manager fleet okay and IO I'll

00:22:05,990 --> 00:22:10,210
put it in you know babble and bird and

00:22:07,970 --> 00:22:12,350
whatnot and it's very easy to integrate

00:22:10,210 --> 00:22:16,700
it's just this kind of little building

00:22:12,350 --> 00:22:18,920
block the tools shipped with this little

00:22:16,700 --> 00:22:20,750
shell script initially this was just

00:22:18,920 --> 00:22:23,450
like my own quick and dirty shell script

00:22:20,750 --> 00:22:24,950
for my laptop called WT quick but people

00:22:23,450 --> 00:22:27,620
liked it and now it's distributed and so

00:22:24,950 --> 00:22:29,750
it adds a couple fields to the to the

00:22:27,620 --> 00:22:32,470
config file like address and DNS and

00:22:29,750 --> 00:22:34,670
post up post down three up three down

00:22:32,470 --> 00:22:36,410
but it's just like a dump shell script

00:22:34,670 --> 00:22:40,310
and so you have up and down and then it

00:22:36,410 --> 00:22:41,870
does what you would expect I thought it

00:22:40,310 --> 00:22:43,550
was convenient other people did too but

00:22:41,870 --> 00:22:44,900
you know it's just one of the many kind

00:22:43,550 --> 00:22:48,440
of wrappers you can make around this

00:22:44,900 --> 00:22:50,810
stuff wire it has a lot of cool network

00:22:48,440 --> 00:22:53,450
name space tricks where the wire guard

00:22:50,810 --> 00:22:55,720
interface can live in one namespace but

00:22:53,450 --> 00:22:58,490
a physical interface can live in another

00:22:55,720 --> 00:23:00,320
and so this is kind of a nice

00:22:58,490 --> 00:23:02,450
alternative to routing table pack so we

00:23:00,320 --> 00:23:03,020
can look at two ways where this would

00:23:02,450 --> 00:23:05,420
work

00:23:03,020 --> 00:23:07,940
one is the containers where over here

00:23:05,420 --> 00:23:09,920
you have say a docker container and the

00:23:07,940 --> 00:23:12,530
only interface you give that container

00:23:09,920 --> 00:23:13,960
is WG 0 so it the only way can access it

00:23:12,530 --> 00:23:17,990
outside network is through wire guard

00:23:13,960 --> 00:23:19,460
but the UDP socket for Lara guard

00:23:17,990 --> 00:23:24,260
actually lives and you're in a namespace

00:23:19,460 --> 00:23:27,620
that has a real that has a real Ethernet

00:23:24,260 --> 00:23:29,720
card and wireless card so the docker is

00:23:27,620 --> 00:23:31,280
forced to go through wire guard and

00:23:29,720 --> 00:23:34,550
can't see any other paths to the

00:23:31,280 --> 00:23:35,070
internet we can also reverse this whole

00:23:34,550 --> 00:23:40,190
thing

00:23:35,070 --> 00:23:43,019
where you can move your actual physical

00:23:40,190 --> 00:23:44,789
interfaces into a namespace that you'd

00:23:43,019 --> 00:23:47,490
call a little physical or something and

00:23:44,789 --> 00:23:48,899
over here you could run DHCP and WEP a

00:23:47,490 --> 00:23:50,519
supplicant and all the things that are

00:23:48,899 --> 00:23:51,960
you know always kind of messing with

00:23:50,519 --> 00:23:54,539
your routing table and network

00:23:51,960 --> 00:23:56,880
configuration whereas over here in the

00:23:54,539 --> 00:23:58,500
in a namespace you have ping or you know

00:23:56,880 --> 00:24:00,480
your browser or whatever and the only

00:23:58,500 --> 00:24:02,759
way that can see the Internet is through

00:24:00,480 --> 00:24:05,399
wire guard so in this way you can have

00:24:02,759 --> 00:24:06,990
perfect isolation and that's because

00:24:05,399 --> 00:24:11,009
we're able to separate where the UDP

00:24:06,990 --> 00:24:12,690
socket is and where the interfaces but

00:24:11,009 --> 00:24:14,610
of course all the usual routing table

00:24:12,690 --> 00:24:16,250
hacks and policy routing work just as

00:24:14,610 --> 00:24:19,559
well

00:24:16,250 --> 00:24:21,149
okay so security design principle that's

00:24:19,559 --> 00:24:25,440
really important with this is to have

00:24:21,149 --> 00:24:27,450
stack fixed length headers so all the

00:24:25,440 --> 00:24:29,820
headers have fixed fixed width fields so

00:24:27,450 --> 00:24:31,019
we don't need any parsers and so this

00:24:29,820 --> 00:24:33,029
kind of eliminates a whole class of

00:24:31,019 --> 00:24:35,879
vulnerabilities so if we have no parsers

00:24:33,029 --> 00:24:38,100
we have no partial phones kind of

00:24:35,879 --> 00:24:41,940
amazing so that's a lot different than

00:24:38,100 --> 00:24:45,149
formats like I said one or you know a

00:24:41,940 --> 00:24:46,789
different variable length packets where

00:24:45,149 --> 00:24:48,899
you do have to do parsing and

00:24:46,789 --> 00:24:50,460
complicated arithmetic to make sure

00:24:48,899 --> 00:24:52,289
you're not going out of bounds or you're

00:24:50,460 --> 00:24:53,789
you know interpreting the numbers

00:24:52,289 --> 00:24:55,860
correctly you're not overflowing

00:24:53,789 --> 00:24:57,779
integers or we just don't have this we

00:24:55,860 --> 00:25:01,110
have no parsing things are fixed length

00:24:57,779 --> 00:25:03,659
and so the packet is either that length

00:25:01,110 --> 00:25:07,080
or it's not and it therefore has these

00:25:03,659 --> 00:25:12,840
valid fields or it doesn't so it's very

00:25:07,080 --> 00:25:15,990
simple in that sense we also don't want

00:25:12,840 --> 00:25:18,899
to allocate memory in response to

00:25:15,990 --> 00:25:20,539
unauthenticated packets which means all

00:25:18,899 --> 00:25:24,570
the state required for wire guard is

00:25:20,539 --> 00:25:26,100
allocated during configuration so it's

00:25:24,570 --> 00:25:27,990
kind of great if we have you know no

00:25:26,100 --> 00:25:32,279
heap then we kind of like eliminate heat

00:25:27,990 --> 00:25:34,200
bulb like that but this place is a

00:25:32,279 --> 00:25:35,700
pretty unusual constraint on the crypto

00:25:34,200 --> 00:25:38,669
because now we're operating over a

00:25:35,700 --> 00:25:40,440
finite amount of space tonight amount of

00:25:38,669 --> 00:25:42,299
pre allocated memory now of course

00:25:40,440 --> 00:25:43,860
that's always the case with a computer

00:25:42,299 --> 00:25:45,809
computer never has infinite memory so

00:25:43,860 --> 00:25:48,210
that's kind of a nice assumption to make

00:25:45,809 --> 00:25:51,390
as a security posture against das

00:25:48,210 --> 00:25:53,070
other attacks but being so strict about

00:25:51,390 --> 00:25:54,570
it places you know some interesting

00:25:53,070 --> 00:25:55,950
cryptographic considerations for

00:25:54,570 --> 00:25:59,430
designing a protocol that can meet that

00:25:55,950 --> 00:26:01,290
requirement and then as a corollary of

00:25:59,430 --> 00:26:03,180
not wanting to mutate a finite amount of

00:26:01,290 --> 00:26:05,490
state that means that we don't want to

00:26:03,180 --> 00:26:09,330
modify any of that state in response to

00:26:05,490 --> 00:26:11,460
a packet that's unauthenticated so then

00:26:09,330 --> 00:26:14,880
we don't have kind of pre off phones

00:26:11,460 --> 00:26:16,950
which is nice but again it places more

00:26:14,880 --> 00:26:19,590
pressure on the crypto system because

00:26:16,950 --> 00:26:24,450
now we need authentication every packet

00:26:19,590 --> 00:26:25,350
no matter what it's also stealthy as I

00:26:24,450 --> 00:26:29,940
mentioned it grew out of a rootkit

00:26:25,350 --> 00:26:32,880
project and it means it doesn't respond

00:26:29,940 --> 00:26:34,380
to any unauthenticated packets you can't

00:26:32,880 --> 00:26:37,890
scan the internet for wire guard

00:26:34,380 --> 00:26:39,800
endpoints and so it only will respond if

00:26:37,890 --> 00:26:42,300
the packet receives is the right crypto

00:26:39,800 --> 00:26:43,740
and so it's not chatty when the peers

00:26:42,300 --> 00:26:46,020
have nothing to say to each other

00:26:43,740 --> 00:26:49,440
then they just stop sending packets

00:26:46,020 --> 00:26:51,890
there's no like constant ping going back

00:26:49,440 --> 00:26:53,880
and forth or constant noise it's just

00:26:51,890 --> 00:26:59,010
protocol does its thing when they're

00:26:53,880 --> 00:27:00,360
talking and otherwise it goes silent ok

00:26:59,010 --> 00:27:03,750
and this was the question you're asking

00:27:00,360 --> 00:27:06,000
about the the crypto we use we want this

00:27:03,750 --> 00:27:07,170
to be super solid so we're using

00:27:06,000 --> 00:27:10,050
something called the noise protocol

00:27:07,170 --> 00:27:11,730
framework and so why our guard project

00:27:10,050 --> 00:27:15,750
really early on was working with noise

00:27:11,730 --> 00:27:16,860
and we're like really kind of directed

00:27:15,750 --> 00:27:21,170
some of the early decisions so that

00:27:16,860 --> 00:27:23,190
would be suitable for wire guard and

00:27:21,170 --> 00:27:25,860
noise was made by the same guy who did

00:27:23,190 --> 00:27:28,140
the signal protocol if ever you signal

00:27:25,860 --> 00:27:31,920
the messaging app and so it's kind of

00:27:28,140 --> 00:27:33,540
similar in spirit today it has the usual

00:27:31,920 --> 00:27:36,840
list of properties that we'll go through

00:27:33,540 --> 00:27:39,990
for that key exchange we use modern

00:27:36,840 --> 00:27:43,290
primitives curve 2 5 5 19 for

00:27:39,990 --> 00:27:44,910
diffie-hellman like to ester hashing and

00:27:43,290 --> 00:27:49,650
cha-cha poly for authenticated

00:27:44,910 --> 00:27:51,720
encryption now I mentioned a wire guard

00:27:49,650 --> 00:27:54,660
was an opinionated project

00:27:51,720 --> 00:27:56,010
there's no cypher agility you can't pick

00:27:54,660 --> 00:27:58,100
your ciphers these are the ones I say

00:27:56,010 --> 00:28:01,680
are good and that's what you'll use

00:27:58,100 --> 00:28:04,050
which in some way might seem outrageous

00:28:01,680 --> 00:28:06,090
except first of all these are good

00:28:04,050 --> 00:28:08,730
ciphers to use and second of all if they

00:28:06,090 --> 00:28:13,400
break and you upgrade which is how you

00:28:08,730 --> 00:28:16,590
generally do software if you have a

00:28:13,400 --> 00:28:18,750
negotiation then you always have issues

00:28:16,590 --> 00:28:21,150
of the compatibility and the downgrade

00:28:18,750 --> 00:28:24,300
and this whole long history of attacks

00:28:21,150 --> 00:28:27,720
so the water guard approach instead is

00:28:24,300 --> 00:28:29,820
to have version crypto where this is

00:28:27,720 --> 00:28:31,590
good now I'm pretty sure this will be

00:28:29,820 --> 00:28:33,360
good and you know 20 years 30 years but

00:28:31,590 --> 00:28:35,190
who knows there could be the crypto

00:28:33,360 --> 00:28:36,930
Armageddon and everything breaks and

00:28:35,190 --> 00:28:38,910
everything is awful and then you'll

00:28:36,930 --> 00:28:40,740
upgrade to the next version and so

00:28:38,910 --> 00:28:44,100
that's a lot different than something

00:28:40,740 --> 00:28:45,840
like a TLS where it's negotiating all

00:28:44,100 --> 00:28:47,400
these different cipher suites and like

00:28:45,840 --> 00:28:50,070
half are insecure and shouldn't be

00:28:47,400 --> 00:28:51,660
turned on but are and then admins have

00:28:50,070 --> 00:28:53,850
to like keep track of what's the latest

00:28:51,660 --> 00:28:57,660
that they should be you know it's just a

00:28:53,850 --> 00:28:59,430
mess and rarely done right so in this

00:28:57,660 --> 00:29:02,220
way we keep it very simple here's what

00:28:59,430 --> 00:29:06,900
it uses and we can't upgrade later if we

00:29:02,220 --> 00:29:11,010
need but this should be solid for very

00:29:06,900 --> 00:29:13,050
foreseeable future okay so the security

00:29:11,010 --> 00:29:15,720
properties we have strong key agreement

00:29:13,050 --> 00:29:17,550
not authenticity we have key compromised

00:29:15,720 --> 00:29:19,050
impersonation resistance which is kind

00:29:17,550 --> 00:29:22,530
of interesting that's if someone steals

00:29:19,050 --> 00:29:23,490
your private key not only can they

00:29:22,530 --> 00:29:25,410
impersonate you because they have your

00:29:23,490 --> 00:29:26,990
private key but if you're vulnerable to

00:29:25,410 --> 00:29:30,180
keep compromising personation that means

00:29:26,990 --> 00:29:32,400
anyone can personally anyone else to you

00:29:30,180 --> 00:29:33,750
just like if you steal someone's private

00:29:32,400 --> 00:29:36,840
key then all of sudden they can't tell

00:29:33,750 --> 00:29:38,940
faces apart and so we're resistant to

00:29:36,840 --> 00:29:40,200
that unknown key share so when you

00:29:38,940 --> 00:29:42,560
establish a session with someone they

00:29:40,200 --> 00:29:45,000
haven't passed it on to someone else

00:29:42,560 --> 00:29:46,350
there's key secrecy there's for secrecy

00:29:45,000 --> 00:29:46,830
so we have a new session every two

00:29:46,350 --> 00:29:48,330
minutes

00:29:46,830 --> 00:29:50,160
wherever certain number of packets and

00:29:48,330 --> 00:29:52,320
we're always kind of rationing that

00:29:50,160 --> 00:29:55,470
forward and throwing away the ephemeral

00:29:52,320 --> 00:29:56,420
x' we're sure there's a strong session

00:29:55,470 --> 00:29:59,550
uniqueness

00:29:56,420 --> 00:30:02,460
there's identity hiding to an extent so

00:29:59,550 --> 00:30:04,400
that you can't figure out which public

00:30:02,460 --> 00:30:07,530
keys are communicating with each other

00:30:04,400 --> 00:30:10,500
there's replay attack prevention which

00:30:07,530 --> 00:30:12,120
you need but we also allow for the

00:30:10,500 --> 00:30:14,790
network to reorder packets because

00:30:12,120 --> 00:30:15,900
that's what networks do and so we have

00:30:14,790 --> 00:30:20,810
to allow for reordering

00:30:15,900 --> 00:30:23,340
but we want to prevent against replays

00:30:20,810 --> 00:30:26,790
and so it's crypto designed for

00:30:23,340 --> 00:30:30,540
kernel-space so we we want the crypto

00:30:26,790 --> 00:30:34,490
system to be able to to meet these goals

00:30:30,540 --> 00:30:37,290
of having you know a few allocations to

00:30:34,490 --> 00:30:39,090
always be authenticated and this

00:30:37,290 --> 00:30:40,320
generally means we need to be one round

00:30:39,090 --> 00:30:44,130
trip and so we'll get into what that

00:30:40,320 --> 00:30:46,020
means later we also have a clear

00:30:44,130 --> 00:30:47,280
division between the the slow path for

00:30:46,020 --> 00:30:49,080
the diffie-hellman for the public key

00:30:47,280 --> 00:30:51,990
operations and the fast path symmetric

00:30:49,080 --> 00:30:53,070
key but we've put the handshake in

00:30:51,990 --> 00:30:54,870
kernel space it's different from

00:30:53,070 --> 00:30:56,610
something like strongswan we're like

00:30:54,870 --> 00:30:57,570
that's ripped out and user space and

00:30:56,610 --> 00:31:01,020
there's like help kid in that link

00:30:57,570 --> 00:31:02,880
between them instead we're able to hook

00:31:01,020 --> 00:31:04,650
up the data plate and state machine with

00:31:02,880 --> 00:31:07,830
the handshake state machine in a really

00:31:04,650 --> 00:31:11,940
nice intimate way that makes the whole

00:31:07,830 --> 00:31:16,620
thing a lot less complex and that faster

00:31:11,940 --> 00:31:19,830
to the cryptography has also been

00:31:16,620 --> 00:31:23,520
formally verified so we have a symbolic

00:31:19,830 --> 00:31:26,040
proof tamarin others have done symbolic

00:31:23,520 --> 00:31:29,280
proofs and things like probe Erath

00:31:26,040 --> 00:31:32,580
there's now a computational proof it's

00:31:29,280 --> 00:31:35,250
been done with crypto Vera I mean this

00:31:32,580 --> 00:31:37,140
is kind of a cool interface you you

00:31:35,250 --> 00:31:39,420
write out a model of it and either the

00:31:37,140 --> 00:31:40,920
prover will kind of figure out how to do

00:31:39,420 --> 00:31:42,480
it for you or you have to help it along

00:31:40,920 --> 00:31:45,090
and so there's like this neat web

00:31:42,480 --> 00:31:47,240
interface where you you know you can

00:31:45,090 --> 00:31:49,290
like step through the inductive proof

00:31:47,240 --> 00:31:51,540
but we're pretty certain that the

00:31:49,290 --> 00:31:54,480
protocol doesn't have catastrophic

00:31:51,540 --> 00:31:57,560
errors at this point there's a lot of

00:31:54,480 --> 00:31:57,560
different academics looking at it

00:31:59,700 --> 00:32:04,410
have you done any Phi think of this

00:32:01,980 --> 00:32:07,350
because having rather what do any

00:32:04,410 --> 00:32:09,870
fighting buzzing yeah because otherwise

00:32:07,350 --> 00:32:12,390
you still can trust yeah I mean two tons

00:32:09,870 --> 00:32:14,430
of buzzing so I mean as I mentioned my

00:32:12,390 --> 00:32:16,980
background supposed to exploitation and

00:32:14,430 --> 00:32:19,980
so the fun thing for me is like make it

00:32:16,980 --> 00:32:22,550
and then try and break it so I've got

00:32:19,980 --> 00:32:24,590
tons and tons of buzzers from I regard

00:32:22,550 --> 00:32:28,920
other people have tried making

00:32:24,590 --> 00:32:30,240
implementations wire guard and it's

00:32:28,920 --> 00:32:31,680
pretty easy for me to find out if

00:32:30,240 --> 00:32:33,000
they're working or not because I've kept

00:32:31,680 --> 00:32:35,010
like a nice little collection of these

00:32:33,000 --> 00:32:39,030
maybe I should open sourced at some

00:32:35,010 --> 00:32:40,470
point be useful but yeah there's also of

00:32:39,030 --> 00:32:43,070
some kind of like preliminary research

00:32:40,470 --> 00:32:45,870
into generating formally verified

00:32:43,070 --> 00:32:47,100
implementation of wire guard where we

00:32:45,870 --> 00:32:50,190
would like to generate the C code and

00:32:47,100 --> 00:32:52,280
that could be interesting but indeed

00:32:50,190 --> 00:32:56,220
fuzzing is important

00:32:52,280 --> 00:33:00,960
all right speed wide wise it is really

00:32:56,220 --> 00:33:03,480
fast we do multi-core cryptography we

00:33:00,960 --> 00:33:05,520
have kind of interesting requirement

00:33:03,480 --> 00:33:08,940
where we need to like assign the

00:33:05,520 --> 00:33:10,290
sequence numbers in serial and ingest

00:33:08,940 --> 00:33:12,390
packets in serial because we don't want

00:33:10,290 --> 00:33:13,980
to reorder them unnecessarily but we

00:33:12,390 --> 00:33:16,500
want to encrypt everything in parallel

00:33:13,980 --> 00:33:20,010
so we've got like a dual queue system to

00:33:16,500 --> 00:33:21,420
handle this one requirement with wire

00:33:20,010 --> 00:33:24,510
guard it's a little bit different than

00:33:21,420 --> 00:33:29,490
that other things is we want there to be

00:33:24,510 --> 00:33:30,900
fast multi flow fast single flow traffic

00:33:29,490 --> 00:33:34,920
in addition to multi flow of traffic so

00:33:30,900 --> 00:33:37,730
a traditional decision that's made is

00:33:34,920 --> 00:33:41,520
let's put each flow on different core

00:33:37,730 --> 00:33:43,470
and so that's great if you have like a

00:33:41,520 --> 00:33:44,970
massive router with like millions of

00:33:43,470 --> 00:33:47,100
people behind it but that's not so great

00:33:44,970 --> 00:33:48,570
if you're running wire guard I'm like a

00:33:47,100 --> 00:33:50,130
tiny Linksys router and you're just

00:33:48,570 --> 00:33:54,030
trying to download a file as fast as

00:33:50,130 --> 00:33:56,130
possible and so we want both the single

00:33:54,030 --> 00:34:00,620
flow traditional way to be fast but we

00:33:56,130 --> 00:34:00,620
also want multi flow to work properly

00:34:00,920 --> 00:34:06,240
and so we have a single queue that's

00:34:03,960 --> 00:34:09,540
shared by all the CPUs rather than a

00:34:06,240 --> 00:34:11,310
queue per CPU and so we don't need to

00:34:09,540 --> 00:34:13,190
rely on the scheduler to have certain

00:34:11,310 --> 00:34:15,120
semantics because we can

00:34:13,190 --> 00:34:18,510
whichever thread is running we can

00:34:15,120 --> 00:34:19,830
always get an ex packet and so the

00:34:18,510 --> 00:34:22,380
serial transmission queue will wait

00:34:19,830 --> 00:34:24,120
until it has continuous items from the

00:34:22,380 --> 00:34:28,040
parallel encryption queues and then

00:34:24,120 --> 00:34:28,040
it'll send everything off from there

00:34:29,780 --> 00:34:37,560
so one aspect for dealing with CPU

00:34:33,659 --> 00:34:39,780
locality and things like Numa is you

00:34:37,560 --> 00:34:43,200
know if a packet comes in on one CPU or

00:34:39,780 --> 00:34:45,330
it's like part of some pages from their

00:34:43,200 --> 00:34:47,970
cache than one CPU we don't necessarily

00:34:45,330 --> 00:34:50,730
want to spread those ample and then have

00:34:47,970 --> 00:34:52,980
a bunch of thrashing and so it would be

00:34:50,730 --> 00:34:54,950
nice to bundle related packets somehow

00:34:52,980 --> 00:34:57,860
but we don't want to just naively use

00:34:54,950 --> 00:35:01,860
flow because we want fast moontak flow

00:34:57,860 --> 00:35:03,300
we want fast single flow so the question

00:35:01,860 --> 00:35:05,670
is how do we choose the size of the

00:35:03,300 --> 00:35:07,590
bundle how do we pick a bunch of packets

00:35:05,670 --> 00:35:08,940
as a whole and so the answer to this

00:35:07,590 --> 00:35:12,300
turns out to be something called generic

00:35:08,940 --> 00:35:14,850
segmentation offload where we have the

00:35:12,300 --> 00:35:19,040
net device claim that it supports these

00:35:14,850 --> 00:35:22,020
gso super packets so usually this is for

00:35:19,040 --> 00:35:24,720
Ethernet drivers that can like chunk up

00:35:22,020 --> 00:35:26,340
TCP or something in the hardware so we

00:35:24,720 --> 00:35:28,530
lie and we say we're the same and we can

00:35:26,340 --> 00:35:31,350
chuck it up in hardware so then we get

00:35:28,530 --> 00:35:33,270
like a massive 65k packet we chunk it up

00:35:31,350 --> 00:35:38,160
in software but now we know that this

00:35:33,270 --> 00:35:42,510
chunk is related and contiguous and so

00:35:38,160 --> 00:35:44,730
then we can encrypt those on one CPU and

00:35:42,510 --> 00:35:46,290
kind of keep them bundled together and

00:35:44,730 --> 00:35:48,600
that's kind of like a nice compromise

00:35:46,290 --> 00:35:50,760
between having everything be multi flow

00:35:48,600 --> 00:35:52,920
based or having everything be strictly

00:35:50,760 --> 00:35:56,280
single flow we have have a nice balance

00:35:52,920 --> 00:35:57,240
between the two of them and so visually

00:35:56,280 --> 00:35:59,640
the way that works is we have like a

00:35:57,240 --> 00:36:02,220
ring buffer and each buffer points to a

00:35:59,640 --> 00:36:04,580
list of packets and each and the CPU is

00:36:02,220 --> 00:36:09,750
kind of rolling through the ring buffer

00:36:04,580 --> 00:36:11,070
sending out these bundles and so the

00:36:09,750 --> 00:36:13,260
performance is good we're in the kernel

00:36:11,070 --> 00:36:15,210
space we're fast and low latency unlike

00:36:13,260 --> 00:36:16,880
things like Open VPN they have to copy

00:36:15,210 --> 00:36:19,290
things back and forth a million times

00:36:16,880 --> 00:36:20,970
chopped poly is super fast on the

00:36:19,290 --> 00:36:25,860
hardware and it's safe to implement on

00:36:20,970 --> 00:36:26,789
all hardware 8 yes sometimes has nice

00:36:25,860 --> 00:36:31,589
instructions but

00:36:26,789 --> 00:36:33,019
it doesn't you have to write like a you

00:36:31,589 --> 00:36:35,279
know software implementation of it and

00:36:33,019 --> 00:36:39,869
because of cache timing attacks you

00:36:35,279 --> 00:36:41,609
can't easily use tables a an S box and

00:36:39,869 --> 00:36:43,469
so it's very difficult on a lot of

00:36:41,609 --> 00:36:48,239
platforms to make a a es implementation

00:36:43,469 --> 00:36:50,400
that's both fast and safe the other

00:36:48,239 --> 00:36:53,449
thing is that Intel vector instructions

00:36:50,400 --> 00:36:56,130
are getting wider and wider and so

00:36:53,449 --> 00:36:57,869
chopped poly right now is very

00:36:56,130 --> 00:37:02,579
competitive with AES especially with

00:36:57,869 --> 00:37:03,900
avx-512 so we again we kind of get best

00:37:02,579 --> 00:37:06,599
of both worlds by going with cha-cha

00:37:03,900 --> 00:37:10,079
poly and general wire guards very simple

00:37:06,599 --> 00:37:13,189
and so you know less code faster program

00:37:10,079 --> 00:37:17,369
not always but in this case certainly so

00:37:13,189 --> 00:37:19,109
ok so we only have five minutes so we

00:37:17,369 --> 00:37:23,369
have like simple measurements it says

00:37:19,109 --> 00:37:25,140
things work well I don't know ok the

00:37:23,369 --> 00:37:28,259
confluence of the these security

00:37:25,140 --> 00:37:30,179
properties give us give us a one

00:37:28,259 --> 00:37:31,679
roundtrip key exchange we're gonna

00:37:30,179 --> 00:37:33,569
sheiter to respond or responder back to

00:37:31,679 --> 00:37:35,099
initiator it both calculate something

00:37:33,569 --> 00:37:39,929
and then they can send the data back and

00:37:35,099 --> 00:37:42,059
forth I think we don't quite have time

00:37:39,929 --> 00:37:44,609
to go into all the details especially if

00:37:42,059 --> 00:37:46,619
we're gonna do questions so we'll skip

00:37:44,609 --> 00:37:49,890
through some of these details but I'll

00:37:46,619 --> 00:37:51,689
show one last thing all right key

00:37:49,890 --> 00:37:54,029
exchange one round-trip it's super

00:37:51,689 --> 00:37:56,729
simple in the end after a bunch of

00:37:54,029 --> 00:37:58,349
slides of cool cryptography stuff and it

00:37:56,729 --> 00:38:00,329
turns out the actual key exchange part

00:37:58,349 --> 00:38:03,329
is like four hundred or so lines of code

00:38:00,329 --> 00:38:04,650
so that's really cool and as we

00:38:03,329 --> 00:38:07,999
mentioned there's like no ex-59 it's

00:38:04,650 --> 00:38:10,709
just the simple basics for public keys

00:38:07,999 --> 00:38:12,689
wire guard has a poor-man's post quantum

00:38:10,709 --> 00:38:14,729
resistance where it relies on elliptic

00:38:12,689 --> 00:38:17,069
curve ography but you can also mix in a

00:38:14,729 --> 00:38:20,519
pre shared key so there's this thing

00:38:17,069 --> 00:38:22,679
called Grover's algorithm that shows you

00:38:20,519 --> 00:38:26,609
have an optimal speed up with quantum

00:38:22,679 --> 00:38:28,949
computer of a square root and that you

00:38:26,609 --> 00:38:31,049
can't get better with a generic brute

00:38:28,949 --> 00:38:34,679
force search dictionary search on a

00:38:31,049 --> 00:38:36,479
photo computer and so if we have a 256

00:38:34,679 --> 00:38:38,329
bit symmetric key quantum computer will

00:38:36,479 --> 00:38:40,620
break that as though it's a it's a

00:38:38,329 --> 00:38:44,400
128-bit symmetric key which is

00:38:40,620 --> 00:38:46,170
efficiently large and so you can mix in

00:38:44,400 --> 00:38:49,470
this pre-shared key if you want to have

00:38:46,170 --> 00:38:53,040
a post calm security in addition to the

00:38:49,470 --> 00:38:55,380
elliptic curve security but you can also

00:38:53,040 --> 00:38:57,390
do the hybrid approach where instead of

00:38:55,380 --> 00:38:59,430
having both sides pre share this key you

00:38:57,390 --> 00:39:02,730
can establish a wire guard tunnel and

00:38:59,430 --> 00:39:04,080
then inside the tunnel you can do one of

00:39:02,730 --> 00:39:05,940
these newfangled post quantum key

00:39:04,080 --> 00:39:08,070
exchanges there's like a dis competition

00:39:05,940 --> 00:39:09,720
for them now how many of them will be

00:39:08,070 --> 00:39:12,210
broken and terrible how many of them are

00:39:09,720 --> 00:39:15,170
actually good we don't know and so you

00:39:12,210 --> 00:39:18,030
could make the tunnel and do all of them

00:39:15,170 --> 00:39:19,650
like the whole NIST portfolio hash the

00:39:18,030 --> 00:39:22,740
results together and set that as your

00:39:19,650 --> 00:39:24,570
pre shared key and has photographers

00:39:22,740 --> 00:39:26,280
learn more about post Clem cryptography

00:39:24,570 --> 00:39:28,980
than that kind of thing can change and

00:39:26,280 --> 00:39:31,140
so we have some mechanism for at least

00:39:28,980 --> 00:39:33,150
allowing this to be post quantum secure

00:39:31,140 --> 00:39:35,970
without committing to algorithms that

00:39:33,150 --> 00:39:41,640
photographers currently haven't settled

00:39:35,970 --> 00:39:44,460
on okay there's abuse resistance too so

00:39:41,640 --> 00:39:47,400
hashing symmetric crypto were fast but

00:39:44,460 --> 00:39:50,940
pub key crypto is slow and so we've got

00:39:47,400 --> 00:39:53,700
this nice cookie system to prevent an

00:39:50,940 --> 00:39:55,400
attacker from overwhelming the kernel

00:39:53,700 --> 00:39:57,960
with requests to do handshakes

00:39:55,400 --> 00:40:01,010
unfortunately we also don't have time to

00:39:57,960 --> 00:40:03,840
go into how this works but that's okay

00:40:01,010 --> 00:40:04,760
all right so inclusion before we get to

00:40:03,840 --> 00:40:07,620
questions

00:40:04,760 --> 00:40:12,420
why are guards like around 4000 codes

00:40:07,620 --> 00:40:14,550
super basic data structures we tried to

00:40:12,420 --> 00:40:17,070
make the design of it lead to secure

00:40:14,550 --> 00:40:17,940
coding practices where you're

00:40:17,070 --> 00:40:21,030
implementing it you'll probably

00:40:17,940 --> 00:40:25,200
implement it well we keep minimal state

00:40:21,030 --> 00:40:31,260
and we don't want memory allocations we

00:40:25,200 --> 00:40:32,820
try to keep it super stealthy yeah okay

00:40:31,260 --> 00:40:35,540
you can open up to questions

00:40:32,820 --> 00:40:38,280
Oh actually one thing I should mention

00:40:35,540 --> 00:40:40,320
it's in every Linux distro now wire

00:40:38,280 --> 00:40:42,420
guard that come flush the stall but it's

00:40:40,320 --> 00:40:44,540
also on the BSD s and Mac and iOS and

00:40:42,420 --> 00:40:46,770
Android and we'll have windows out soon

00:40:44,540 --> 00:40:48,330
there's like an academic paper if you

00:40:46,770 --> 00:40:51,630
want to read how all that works this

00:40:48,330 --> 00:40:54,210
published a while ago just like a git

00:40:51,630 --> 00:40:55,950
repo mailing list

00:40:54,210 --> 00:40:58,470
IRC if you want to come I have this

00:40:55,950 --> 00:41:01,560
massive bag of stickers if you guys want

00:40:58,470 --> 00:41:03,330
stickers there's plenty of interesting

00:41:01,560 --> 00:41:06,330
work to do if you guys want to develop

00:41:03,330 --> 00:41:09,570
it will probably have v9 posted to the

00:41:06,330 --> 00:41:12,930
mailing list soon and so we're trying to

00:41:09,570 --> 00:41:15,570
get upstream and I think the wire guard

00:41:12,930 --> 00:41:16,680
portion of things anyway is is going

00:41:15,570 --> 00:41:19,530
pretty well there

00:41:16,680 --> 00:41:22,980
so okay questions real I have a question

00:41:19,530 --> 00:41:26,130
on performance so are you able to get

00:41:22,980 --> 00:41:30,450
line rate with the internal crypto I

00:41:26,130 --> 00:41:32,640
want to get what line rate like on a 25

00:41:30,450 --> 00:41:35,670
Gbps card are you able to get 25 Gbps

00:41:32,640 --> 00:41:39,360
tunnel traffic I mean it depends on the

00:41:35,670 --> 00:41:41,610
CPU so I think a lot of cases we get

00:41:39,360 --> 00:41:44,070
line rate pretty easily and some others

00:41:41,610 --> 00:41:46,260
we don't there's still some issues we're

00:41:44,070 --> 00:41:48,210
working out with the queuing system and

00:41:46,260 --> 00:41:51,690
the multi Q stuff but I think for the

00:41:48,210 --> 00:41:53,820
most part it's really fast and so I

00:41:51,690 --> 00:41:54,690
guess the CPU can do it then we hit line

00:41:53,820 --> 00:41:56,280
rate pretty easily

00:41:54,690 --> 00:41:58,850
okay so I guess my follow-up question

00:41:56,280 --> 00:42:01,650
there was do you see any scope for

00:41:58,850 --> 00:42:03,990
offloads for the encryption and

00:42:01,650 --> 00:42:08,310
decryption because what typically

00:42:03,990 --> 00:42:10,680
happens is when you offload it you get

00:42:08,310 --> 00:42:12,810
greater performance from the neck itself

00:42:10,680 --> 00:42:15,090
with the speed and you also free up the

00:42:12,810 --> 00:42:17,280
CPU right yes so there are people

00:42:15,090 --> 00:42:21,500
working on this kind of thing and not in

00:42:17,280 --> 00:42:21,500
the traditional crypto offload way of

00:42:21,770 --> 00:42:26,700
like sending everything to like a

00:42:23,790 --> 00:42:28,650
separate accelerator device but rather

00:42:26,700 --> 00:42:30,930
putting things indeed in the Nix where

00:42:28,650 --> 00:42:33,090
rather than encrypting the skp and

00:42:30,930 --> 00:42:34,920
software you just like mark it and then

00:42:33,090 --> 00:42:37,350
if it hits the NIC that has this quality

00:42:34,920 --> 00:42:38,880
than the nickel do it so I I can

00:42:37,350 --> 00:42:40,380
definitely foresee this kind of thing in

00:42:38,880 --> 00:42:42,270
the pipeline okay and I think you

00:42:40,380 --> 00:42:44,310
mentioned this initially do you you see

00:42:42,270 --> 00:42:47,460
this as a replacement for IPSec or do

00:42:44,310 --> 00:42:49,890
you see it coexisting in many cases as a

00:42:47,460 --> 00:42:53,460
replacement it does a lot of things that

00:42:49,890 --> 00:42:57,560
are similar I piece it also does many

00:42:53,460 --> 00:43:00,960
things that wire guard does not and I

00:42:57,560 --> 00:43:02,760
think in designing new networks if you

00:43:00,960 --> 00:43:04,800
go with what wire guard provides you get

00:43:02,760 --> 00:43:06,560
kind of an overall stronger thing but

00:43:04,800 --> 00:43:09,440
there are some people who will want

00:43:06,560 --> 00:43:11,630
of the infinite complexity that IPSec

00:43:09,440 --> 00:43:13,340
provides and it's already in tons of

00:43:11,630 --> 00:43:15,350
hardware and you know ip6 not going away

00:43:13,340 --> 00:43:17,180
but now at least there's wire guard for

00:43:15,350 --> 00:43:22,670
people who want kind of a simpler more

00:43:17,180 --> 00:43:24,460
basic more secure building block can you

00:43:22,670 --> 00:43:28,670
flash back to the performance slide

00:43:24,460 --> 00:43:30,230
the graphs yeah the bar graph the graph

00:43:28,670 --> 00:43:36,320
is old I don't know if those numbers

00:43:30,230 --> 00:43:38,720
even mean anything but we can these are

00:43:36,320 --> 00:43:40,970
three years old now I don't know if they

00:43:38,720 --> 00:43:46,090
say something it's fast and whatever

00:43:40,970 --> 00:43:46,090
systems I was on show it was faster but

00:43:50,410 --> 00:43:57,710
how widely deployed is it

00:43:53,960 --> 00:43:59,810
I don't know precisely but I do know

00:43:57,710 --> 00:44:02,450
several massive corporations that are

00:43:59,810 --> 00:44:06,170
rolling it out and there are also

00:44:02,450 --> 00:44:09,800
commercial VPN providers are selling

00:44:06,170 --> 00:44:11,720
service on it come and like bunch of

00:44:09,800 --> 00:44:16,700
small companies are using it but justice

00:44:11,720 --> 00:44:19,610
admins so at this point it's like very

00:44:16,700 --> 00:44:20,870
much out there but it's open-source

00:44:19,610 --> 00:44:22,190
software so I don't have any solid

00:44:20,870 --> 00:44:23,690
numbers you know is that like a product

00:44:22,190 --> 00:44:26,870
where I have a customer list or

00:44:23,690 --> 00:44:32,000
something you know one more question and

00:44:26,870 --> 00:44:37,490
then yes so when you measure forms to

00:44:32,000 --> 00:44:39,410
use your own crypto library right that's

00:44:37,490 --> 00:44:41,990
right though I think I think there's old

00:44:39,410 --> 00:44:44,030
numbers were not but yeah now now for

00:44:41,990 --> 00:44:46,970
the most did you use the crypto layer

00:44:44,030 --> 00:44:49,520
from the kernel to compare with for

00:44:46,970 --> 00:44:52,310
example originally I did yeah before I

00:44:49,520 --> 00:44:54,200
moved away from that but yeah recently I

00:44:52,310 --> 00:44:55,880
was using those implementations yeah I

00:44:54,200 --> 00:44:57,830
think you immediately see that the

00:44:55,880 --> 00:44:59,840
crypto is the problem there right what

00:44:57,830 --> 00:45:02,060
you immediately see that the crypto is

00:44:59,840 --> 00:45:04,520
the problem that the crypto is the

00:45:02,060 --> 00:45:07,430
probably IPSec performs if you run per

00:45:04,520 --> 00:45:09,140
if you see that the crypto oh yeah but

00:45:07,430 --> 00:45:10,970
there's also just a lot of general

00:45:09,140 --> 00:45:12,020
overhead and the packet handling and

00:45:10,970 --> 00:45:14,210
it's latex it's slightly more

00:45:12,020 --> 00:45:18,130
complicated path for as wire guard it's

00:45:14,210 --> 00:45:18,130
like just basic boring network interface

00:45:18,839 --> 00:45:25,140
yeah yeah so it'd be fun to rerun these

00:45:21,180 --> 00:45:27,240
I mean in any case for like a ideally

00:45:25,140 --> 00:45:29,279
optimized implementation it does just

00:45:27,240 --> 00:45:31,380
come down to what primitives are being

00:45:29,279 --> 00:45:33,539
used they're both in the kernel they

00:45:31,380 --> 00:45:35,400
should both be really fast that the real

00:45:33,539 --> 00:45:38,309
takeaway is that something like Open VPN

00:45:35,400 --> 00:45:39,869
and user space is super slow as you get

00:45:38,309 --> 00:45:42,990
them as benchmarks should be somehow

00:45:39,869 --> 00:45:45,089
comparable right I mean that was what

00:45:42,990 --> 00:45:46,740
you should should use to put the same

00:45:45,089 --> 00:45:47,940
trip to layer for both well this what

00:45:46,740 --> 00:45:50,039
I'm saying those benchmarks from a while

00:45:47,940 --> 00:45:52,349
ago are the same crypto yeah okay yeah

00:45:50,039 --> 00:45:56,039
yet now I have moved away because I so

00:45:52,349 --> 00:45:58,620
it's like faster than that was but let's

00:45:56,039 --> 00:46:03,330
securely thank the speaker brake is on

00:45:58,620 --> 00:46:03,330

YouTube URL: https://www.youtube.com/watch?v=CejbCQ5wS7Q


