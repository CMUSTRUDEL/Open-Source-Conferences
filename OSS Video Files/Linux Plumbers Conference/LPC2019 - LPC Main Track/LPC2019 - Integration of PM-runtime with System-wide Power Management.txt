Title: LPC2019 - Integration of PM-runtime with System-wide Power Management
Publication date: 2019-11-18
Playlist: LPC2019 - LPC Main Track
Description: 
	Integration of PM-runtime with System-wide Power Management

Speaker
 Rafael Wysocki (Intel Open Source Technology Center)

Description
There are two flavors of power management supported by the Linux kernel: system-wide PM based on transitions of the entire system into sleep states and working-state PM focused on controlling individual components when the system as a whole is working. PM-runtime is part of working-state PM concerned about the opportunity to put devices into low-power states when they are not in use.

Since both PM-runtime and system-wide PM act on devices in a similar way (that is, they both put devices into low-power states and possibly enable them to generate wakeup signals), optimizations related to the handling of already suspended devices can be made, at least in principle. In particular:
It should be possible to avoid resuming devices already suspended by runtime PM during system-wide PM transitions to sleep states.
It should be possible to leave devices suspended during system-wide PM transitions to sleep states in PM-runtime suspend while resuming the system from those states.
* It should be possible to re-use PM-runtime callbacks in device drivers for the handling of system-wide PM.

These optimizations are done by some drivers, but making them work in general turns out to be a hard problem. They are achieved in different ways by different drivers and some of them are in effect only in specific platform configurations. Moreover, there are no general guidelines or recipes that driver writers can follow in order to arrange for these optimizations to take place. In an attempt to start a discussion on approaching this problem space more consistently, I will give an overview of it, describe the solutions proposed and used so far and suggest some changes that may help to improve the situation.
Captions: 
	00:00:00,160 --> 00:00:01,513
- Welcome to the track,

00:00:02,720 --> 00:00:06,420
Rafael Wysocki, Intel Open Source Technology Center,

00:00:06,420 --> 00:00:09,030
everyone probably doesn't need an introduction.

00:00:09,030 --> 00:00:12,650
Linux power management maintainer, ACPI maintainer,

00:00:12,650 --> 00:00:14,510
works on Rafael standard time

00:00:14,510 --> 00:00:17,750
and we have still not defined what that is.

00:00:17,750 --> 00:00:20,241
And I've worked with Raphael in the past

00:00:20,241 --> 00:00:22,580
on ACPI standards and such,

00:00:22,580 --> 00:00:25,340
always a consistent supporter of

00:00:25,340 --> 00:00:26,500
what's best for the industry

00:00:26,500 --> 00:00:28,770
and I've always really enjoyed working with him.

00:00:28,770 --> 00:00:32,540
And we look forward to hearing from you now

00:00:32,540 --> 00:00:35,440
and questions during are just fine,

00:00:35,440 --> 00:00:36,273
five minutes before

00:00:36,273 --> 00:00:38,960
we're gonna swap for the next speakers,

00:00:38,960 --> 00:00:42,310
but Raphael will continue his Q&A

00:00:42,310 --> 00:00:45,690
but that's just so we don't lose time for the laptop setup.

00:00:45,690 --> 00:00:47,463
And with that,

00:00:48,650 --> 00:00:50,200
Raphael.

00:00:50,200 --> 00:00:51,100
- Okay, thank you.

00:00:52,500 --> 00:00:55,663
Let me switch over to the presentation mode.

00:01:05,690 --> 00:01:06,903
Well, fine.

00:01:11,900 --> 00:01:13,163
Let's see if I can,

00:01:14,540 --> 00:01:16,273
oh yeah, I can do that.

00:01:21,900 --> 00:01:25,120
I may just go down to the floor,

00:01:25,120 --> 00:01:26,387
I don't like setups like that

00:01:26,387 --> 00:01:28,860
where I'm above the people I talk to.

00:01:28,860 --> 00:01:31,400
So thanks for the introduction,

00:01:31,400 --> 00:01:34,680
oh, I'm too close to speaker apparently.

00:01:34,680 --> 00:01:36,483
Thanks for the introduction, Darren.

00:01:37,690 --> 00:01:39,515
Very nice, thank you.

00:01:39,515 --> 00:01:40,950
(laughing)

00:01:40,950 --> 00:01:42,690
So I won't repeat that.

00:01:44,150 --> 00:01:45,400
Among other things I do,

00:01:45,400 --> 00:01:48,160
I've been maintaining the infrastructure

00:01:48,160 --> 00:01:50,740
for power management and kernel for a while.

00:01:50,740 --> 00:01:53,033
Like some ten years, now.

00:01:54,610 --> 00:01:57,300
And today I'm going to talk

00:01:57,300 --> 00:02:00,000
about one thing related to that

00:02:00,000 --> 00:02:03,853
which is how to combine different pieces of it together.

00:02:05,240 --> 00:02:07,360
It counts as different pieces are turned about

00:02:07,360 --> 00:02:09,320
at different times by different people

00:02:09,320 --> 00:02:14,060
that may not be like designed to work with each other

00:02:14,060 --> 00:02:17,290
so there are some cases in which you have

00:02:17,290 --> 00:02:19,453
to do some extra work to do that.

00:02:21,550 --> 00:02:24,403
First off, all that is about,

00:02:30,120 --> 00:02:33,043
all that is about energy efficiency.

00:02:34,400 --> 00:02:37,640
Energy efficiency meaning optimizing the usage of energy

00:02:37,640 --> 00:02:42,640
so that it is not wasted, basically.

00:02:43,040 --> 00:02:45,230
Right, so we want to use as much energy

00:02:45,230 --> 00:02:47,220
as necessary to do certain things,

00:02:47,220 --> 00:02:50,150
but we don't want to sacrifice

00:02:50,150 --> 00:02:52,633
a lot of performance for that, usually.

00:02:54,650 --> 00:02:56,680
All right so the photo illustrates

00:02:56,680 --> 00:02:58,203
three ways of moving around,

00:03:06,056 --> 00:03:09,556
like here, in the bottom left-hand corner,

00:03:10,410 --> 00:03:11,410
you have people walking,

00:03:11,410 --> 00:03:13,580
you have a guy riding a bicycle

00:03:13,580 --> 00:03:17,560
and a guy riding an electric vehicle

00:03:17,560 --> 00:03:21,810
which is a lime scooter, I guess.

00:03:21,810 --> 00:03:26,810
So question to the audience as a matter of warm-up,

00:03:26,860 --> 00:03:28,930
which of the three ways of moving around

00:03:28,930 --> 00:03:30,380
is the most energy efficient?

00:03:33,060 --> 00:03:35,650
Well, yes, the bicycle,

00:03:35,650 --> 00:03:37,640
but that depends on the distance.

00:03:37,640 --> 00:03:39,360
If the distance is short enough,

00:03:39,360 --> 00:03:44,050
you are better off by walking, right,

00:03:44,050 --> 00:03:46,150
than riding a bicycle.

00:03:46,150 --> 00:03:50,000
But if you want to get somewhere far away,

00:03:50,000 --> 00:03:51,636
yes, the bicycle is the most

00:03:51,636 --> 00:03:53,513
energy efficient way to do that.

00:03:54,400 --> 00:03:55,233
Okay.

00:03:58,100 --> 00:04:03,100
So in Linux, if you want to, as I said,

00:04:03,350 --> 00:04:05,480
prevent energy from being wasted,

00:04:05,480 --> 00:04:07,250
there are two ways to do that.

00:04:07,250 --> 00:04:11,720
One way operates on the system-wide basis,

00:04:11,720 --> 00:04:14,100
it's referred to as system-wide power management

00:04:14,100 --> 00:04:17,420
and it's based on putting the system as a whole

00:04:17,420 --> 00:04:22,420
into suspend or hibernation like that, right.

00:04:22,550 --> 00:04:25,823
So the entire system goes into a low-power state.

00:04:28,513 --> 00:04:29,983
In a hopefully ordered way.

00:04:31,450 --> 00:04:36,450
Now the other way is to operate individual devices

00:04:37,440 --> 00:04:42,320
and either suspend them or use their capacity

00:04:43,370 --> 00:04:46,640
wireless system as hold some useful work.

00:04:46,640 --> 00:04:49,423
So devices are not in use we just turn them off.

00:04:51,201 --> 00:04:54,120
Okay so that is kind of analogous to the two ways

00:04:54,120 --> 00:04:56,550
of getting from one side of the river

00:04:56,550 --> 00:05:00,470
to the other side illustrated here in the photo.

00:05:00,470 --> 00:05:04,510
So the close background there's a bridge.

00:05:04,510 --> 00:05:06,170
Obviously you can use it to get

00:05:06,170 --> 00:05:08,630
from that side of the river to the other one,

00:05:08,630 --> 00:05:11,600
and there's a ferry in the foreground,

00:05:11,600 --> 00:05:14,050
which also can be used for the same purpose.

00:05:14,050 --> 00:05:17,440
So the bridge is kind of an obvious thing, right?

00:05:17,440 --> 00:05:18,960
It's there, you can use it.

00:05:18,960 --> 00:05:21,020
So now the question is why would anyone

00:05:21,020 --> 00:05:24,210
need a ferry in that situation?

00:05:24,210 --> 00:05:27,250
Well the answer is that the ferry

00:05:27,250 --> 00:05:28,923
covers a different use case.

00:05:31,070 --> 00:05:33,500
If you don't want to walk up the bridge

00:05:33,500 --> 00:05:35,610
and walk it and so on,

00:05:35,610 --> 00:05:36,700
you might just use the ferry

00:05:36,700 --> 00:05:41,650
to get from one point on one riverbank to the other quickly.

00:05:41,650 --> 00:05:42,713
And it's more fun.

00:05:44,636 --> 00:05:46,380
So there are different use cases

00:05:46,380 --> 00:05:50,943
and this is similar to the energy efficiency use cases.

00:05:53,540 --> 00:05:54,620
If your system is in use,

00:05:54,620 --> 00:05:56,843
like my laptop right now,

00:05:58,600 --> 00:06:01,720
for displaying the slides but it doesn't do anything else,

00:06:01,720 --> 00:06:05,210
so I basically want the other devices on it

00:06:05,210 --> 00:06:06,623
to be in low power states.

00:06:07,690 --> 00:06:10,640
Whether or not this happens actually,

00:06:10,640 --> 00:06:14,300
I'm not sure, but this is the idea, right.

00:06:14,300 --> 00:06:18,130
If I stop using it and close the lid

00:06:18,130 --> 00:06:19,810
and put it into my bag,

00:06:19,810 --> 00:06:22,450
I don't want it to do anything.

00:06:22,450 --> 00:06:23,880
And that's the other use case,

00:06:23,880 --> 00:06:25,880
that's for system-wide power management.

00:06:28,760 --> 00:06:31,567
So there are different use cases

00:06:31,567 --> 00:06:33,283
and different ways to do things.

00:06:36,780 --> 00:06:41,780
PM-runtime is part of the power management

00:06:41,797 --> 00:06:43,510
in the system working state

00:06:43,510 --> 00:06:45,553
in which work is done in general.

00:06:47,920 --> 00:06:49,068
You can consider it as

00:06:49,068 --> 00:06:52,980
a power management coordination framework, essentially.

00:06:52,980 --> 00:06:56,974
Because what is helps to do is to coordinate

00:06:56,974 --> 00:07:00,620
different power management operations

00:07:01,847 --> 00:07:04,540
carried out on different devices with each other,

00:07:04,540 --> 00:07:06,500
so there are dependencies between devices,

00:07:06,500 --> 00:07:09,990
there are code-like errors, different things,

00:07:09,990 --> 00:07:11,980
all of that needs to be coordinated.

00:07:11,980 --> 00:07:14,493
And that's what the PM-runtime is for.

00:07:16,360 --> 00:07:20,100
So PM-runtime defines meta states for devices,

00:07:20,100 --> 00:07:23,090
one of them is suspended, one of them is active.

00:07:23,090 --> 00:07:27,363
Active is a meta state in which the device can process data.

00:07:28,510 --> 00:07:31,246
It is accessible to software and so on.

00:07:31,246 --> 00:07:33,850
Suspended is a meta state in which

00:07:33,850 --> 00:07:37,500
the device may not be accessible.

00:07:37,500 --> 00:07:39,810
It doesn't do anything, it may not be accessible,

00:07:39,810 --> 00:07:43,473
you can't assume that you can actually access it in any way.

00:07:44,320 --> 00:07:48,410
It depends on the bus, driver, device type and so on,

00:07:48,410 --> 00:07:52,150
But that's a general notion.

00:07:52,150 --> 00:07:53,720
Okay so there are two operations,

00:07:53,720 --> 00:07:56,660
leading from suspended to active is resume,

00:07:56,660 --> 00:08:00,260
and leading from active to suspended is you'll see suspend.

00:08:00,260 --> 00:08:04,170
So there are two transient meta states

00:08:04,170 --> 00:08:06,080
corresponding to these two transitions,

00:08:06,080 --> 00:08:07,860
so the device is resuming when

00:08:07,860 --> 00:08:10,370
the resume operation is in progress

00:08:10,370 --> 00:08:11,580
and the device is suspending

00:08:11,580 --> 00:08:13,113
when this is in progress.

00:08:16,340 --> 00:08:19,330
Role, one of the roles of PM-runtime

00:08:19,330 --> 00:08:22,680
is to prevent those operations

00:08:22,680 --> 00:08:24,890
from taking place at the same time.

00:08:24,890 --> 00:08:26,650
Right, it'd state that it has to,

00:08:26,650 --> 00:08:31,010
or even it has to prevent two suspend operations

00:08:31,010 --> 00:08:33,600
from being attempted in a row,

00:08:33,600 --> 00:08:35,223
like on the same device.

00:08:36,290 --> 00:08:41,290
So it has to track the state of the device,

00:08:41,290 --> 00:08:43,190
or rather the meta state of the device

00:08:47,870 --> 00:08:50,060
so that those things happen at the right times.

00:08:50,060 --> 00:08:52,240
Okay there is one more thing,

00:08:52,240 --> 00:08:55,040
so if the device appears to be idle

00:08:55,899 --> 00:09:00,200
to the driver core or any piece of the code,

00:09:00,200 --> 00:09:04,200
it can invoke or initiate a third operation

00:09:04,200 --> 00:09:06,590
defined in the PM-runtime framework

00:09:06,590 --> 00:09:07,760
which is the idle track.

00:09:07,760 --> 00:09:12,270
So there is an event which triggers this

00:09:12,270 --> 00:09:14,790
and the operation is started

00:09:14,790 --> 00:09:17,380
and then it checks if it is desirable

00:09:17,380 --> 00:09:18,810
to suspend a device right now

00:09:18,810 --> 00:09:23,810
or maybe some delay is necessary or something like that.

00:09:24,201 --> 00:09:25,363
Okay so that's it.

00:09:27,610 --> 00:09:30,420
Again, as I said, that takes care of the dependencies

00:09:30,420 --> 00:09:31,913
between devices and so on.

00:09:36,043 --> 00:09:38,780
So the system-wide power management

00:09:38,780 --> 00:09:41,230
is kind of more complicated,

00:09:41,230 --> 00:09:42,620
which you can figure out

00:09:43,790 --> 00:09:45,720
from this diagram.

00:09:45,720 --> 00:09:47,820
Actually this is the working state

00:09:47,820 --> 00:09:50,713
in which PM-runtime leaves.

00:09:52,290 --> 00:09:55,190
There are two system suspend flows here,

00:09:55,190 --> 00:09:59,100
one of them is a traditional platform base suspend

00:09:59,100 --> 00:10:04,100
with all of the operations involved illustrated,

00:10:05,280 --> 00:10:06,450
the other is suspend to idle,

00:10:06,450 --> 00:10:09,660
this is a new thing, relatively new

00:10:11,077 --> 00:10:12,520
in respect to this one.

00:10:12,520 --> 00:10:15,630
So the only difference is this part here

00:10:15,630 --> 00:10:20,630
in which the CPUs were basically put offline

00:10:22,410 --> 00:10:24,090
and a platform was invoked to

00:10:28,497 --> 00:10:29,410
turn off power from everything

00:10:29,410 --> 00:10:31,020
like to turn everything off.

00:10:31,020 --> 00:10:34,040
But in this case, just the suspend to idle

00:10:34,040 --> 00:10:38,380
simply leaves the processors or CPUs in idle states

00:10:39,550 --> 00:10:41,040
with the assumption that

00:10:42,367 --> 00:10:44,809
the hardware will do the right thing

00:10:44,809 --> 00:10:47,560
and put itself into a half-power state

00:10:49,549 --> 00:10:51,553
if everything is idle.

00:10:53,710 --> 00:10:57,180
From the device power management perspective

00:10:57,180 --> 00:11:00,040
they are analogous so there are

00:11:02,460 --> 00:11:06,000
in each cycle like here or here,

00:11:06,000 --> 00:11:07,780
there are two transitions of the whole system,

00:11:07,780 --> 00:11:09,500
one of them is suspending the whole system

00:11:09,500 --> 00:11:12,220
and the other one is a resume of the system, right?

00:11:12,220 --> 00:11:14,310
So the entire system goes to

00:11:15,830 --> 00:11:18,420
is suspended in this transition

00:11:18,420 --> 00:11:19,570
ending this transition.

00:11:20,450 --> 00:11:22,950
That may happen at any time.

00:11:22,950 --> 00:11:25,273
So there is a difference between,

00:11:26,580 --> 00:11:29,090
this is the most important difference

00:11:29,090 --> 00:11:32,800
between PM-runtime and the system-wide thing.

00:11:32,800 --> 00:11:34,690
This can happen at any time,

00:11:34,690 --> 00:11:39,690
so devices may be in, how do you say,

00:11:43,040 --> 00:11:45,450
may be processing data when this happens,

00:11:45,450 --> 00:11:46,950
so there may be a queue of requests

00:11:46,950 --> 00:11:49,810
the device the driver of the device is handling

00:11:49,810 --> 00:11:52,530
and the system suspend is triggered by user space

00:11:52,530 --> 00:11:57,500
so it may be triggered while this operation is in progress.

00:11:57,500 --> 00:11:59,283
So drivers have to take care of it.

00:12:00,320 --> 00:12:01,410
There are other things that has

00:12:01,410 --> 00:12:04,540
to be taken care of because of that.

00:12:04,540 --> 00:12:08,043
So there are four phases of each transition.

00:12:09,000 --> 00:12:11,797
In each phase, all of the devices in the system

00:12:11,797 --> 00:12:13,773
are serviced in each phase,

00:12:14,630 --> 00:12:16,560
and there is a callback

00:12:16,560 --> 00:12:19,813
that may be invoked for each of them in each phase.

00:12:22,274 --> 00:12:26,407
I'm not aware of any devices that actually are handled

00:12:27,600 --> 00:12:30,290
in a meaningful way in all the phases here

00:12:30,290 --> 00:12:33,210
but the different devices may use different phases,

00:12:33,210 --> 00:12:35,780
or are handled in different ways.

00:12:35,780 --> 00:12:39,460
And analogously during system resume,

00:12:39,460 --> 00:12:42,380
there also are four phases

00:12:42,380 --> 00:12:46,730
and in each phase the driver walks

00:12:47,990 --> 00:12:49,600
the whole device hierarchy,

00:12:49,600 --> 00:12:52,820
each device uses that and there is a callback

00:12:52,820 --> 00:12:54,853
that may be invoked for each of them.

00:12:57,721 --> 00:13:02,710
Okay so now, there is some, from the beginning,

00:13:02,710 --> 00:13:04,510
there has been some coordination

00:13:04,510 --> 00:13:09,230
between PM-runtime and system-wide power management.

00:13:09,230 --> 00:13:12,910
Historically, PM-runtime was introduced first,

00:13:12,910 --> 00:13:15,300
no, second, the system-wide power management

00:13:15,300 --> 00:13:16,600
was introduced in the beginning,

00:13:16,600 --> 00:13:19,250
PM-runtime was added later.

00:13:19,250 --> 00:13:23,080
So there are devices, or rather I should say,

00:13:23,080 --> 00:13:25,450
there are device drivers that only support

00:13:25,450 --> 00:13:27,630
system-wide power management.

00:13:27,630 --> 00:13:29,460
Which is kind of mandatory,

00:13:29,460 --> 00:13:31,710
so if the kernel is built with

00:13:33,430 --> 00:13:35,410
system-wide power management support

00:13:35,410 --> 00:13:40,410
which means that config, pm, sleep configuration is set,

00:13:42,730 --> 00:13:44,350
all of the drivers are expected

00:13:44,350 --> 00:13:46,793
to support system-wide power management.

00:13:48,380 --> 00:13:51,140
At the same time, PM-runtime is optional.

00:13:51,140 --> 00:13:53,633
So drivers may or may not support it,

00:13:55,520 --> 00:13:56,353
yeah optional.

00:13:57,299 --> 00:14:02,299
So there is some coordination between this and PM-runtime.

00:14:03,410 --> 00:14:05,396
And the coordination is that,

00:14:05,396 --> 00:14:06,503
at the beginning,

00:14:12,680 --> 00:14:14,100
the runtime suspend operations

00:14:14,100 --> 00:14:15,783
are blocked for all devices.

00:14:17,480 --> 00:14:20,223
Actually I should say in the first phase.

00:14:21,920 --> 00:14:24,110
Runtime suspend operations are blocked

00:14:24,110 --> 00:14:25,890
so you can't runtime suspend

00:14:25,890 --> 00:14:27,800
or devices can't be runtime suspended

00:14:27,800 --> 00:14:29,090
while this is running.

00:14:29,090 --> 00:14:30,390
Which is good because then

00:14:32,080 --> 00:14:34,900
runtime suspend may happen at the wrong time

00:14:34,900 --> 00:14:37,240
with respect to the system-wide callbacks

00:14:37,240 --> 00:14:38,090
and so on and so.

00:14:40,671 --> 00:14:42,933
But runtime resume can still happen.

00:14:44,090 --> 00:14:46,610
The reason why is because in some cases

00:14:46,610 --> 00:14:49,390
it is necessary to resume devices from runtime suspend

00:14:49,390 --> 00:14:51,383
when the system is wholly suspending.

00:14:53,670 --> 00:14:57,198
And so for example, runtime suspend

00:14:57,198 --> 00:15:01,560
may run in this phase,

00:15:01,560 --> 00:15:06,160
but in this phase the PM-runtime is disabled entirely.

00:15:06,160 --> 00:15:07,880
For all devices.

00:15:07,880 --> 00:15:09,540
And enabled in this phase.

00:15:09,540 --> 00:15:11,720
And obviously here, right,

00:15:11,720 --> 00:15:16,292
this is when PM-runtime is disabled for all devices

00:15:16,292 --> 00:15:18,200
and it is enabled here.

00:15:18,200 --> 00:15:21,440
That is problematic because

00:15:21,440 --> 00:15:22,943
well more on that later.

00:15:26,330 --> 00:15:30,040
There are things that we would like to happen

00:15:30,040 --> 00:15:32,030
which are not strictly necessary

00:15:32,030 --> 00:15:34,280
but from the energy efficiency point of view

00:15:34,280 --> 00:15:38,133
and from the point of view of the suspend performance,

00:15:39,990 --> 00:15:42,530
I mean the system suspend performance

00:15:42,530 --> 00:15:46,300
which means we want system suspend transitions

00:15:46,300 --> 00:15:48,950
and system resume transitions to be fast.

00:15:48,950 --> 00:15:53,063
Like to, we want them to take as little time as possible.

00:15:54,770 --> 00:15:57,600
So for example, suspended devices

00:16:00,540 --> 00:16:02,000
should be handled transparently,

00:16:02,000 --> 00:16:07,000
I mean that if the device is suspended by PM-runtime,

00:16:07,540 --> 00:16:10,310
when the system suspend starts

00:16:10,310 --> 00:16:12,450
it would be best to actually

00:16:12,450 --> 00:16:14,393
leave the device in suspend, right,

00:16:15,490 --> 00:16:18,673
because it is suspended, we can leave it like that.

00:16:19,630 --> 00:16:23,600
And now obviously during the resume of the system,

00:16:23,600 --> 00:16:26,323
we want the devices that are previously suspended

00:16:26,323 --> 00:16:30,580
to stay in suspend because there is no need to touch them.

00:16:30,580 --> 00:16:31,800
Generally speaking.

00:16:31,800 --> 00:16:36,660
There are cases in which they actually have to be touched,

00:16:36,660 --> 00:16:38,290
but again more on that later.

00:16:38,290 --> 00:16:40,990
So we want the suspended devices

00:16:40,990 --> 00:16:42,300
to be handled transparently

00:16:42,300 --> 00:16:43,323
generally speaking.

00:16:45,904 --> 00:16:48,227
The other thing is callback re-use.

00:16:50,010 --> 00:16:52,900
So the title of the slide is

00:16:52,900 --> 00:16:54,260
PM-runtime Callbacks Re-use,

00:16:54,260 --> 00:16:58,080
actually I think that it would be more appropriate

00:16:58,080 --> 00:17:00,120
to say Callback Re-use in general

00:17:01,365 --> 00:17:03,563
because for some devices,

00:17:05,079 --> 00:17:06,980
the PM-runtime handling is the same

00:17:06,980 --> 00:17:11,763
as the suspend wide suspend resume handling.

00:17:12,950 --> 00:17:14,310
Input devices are like that,

00:17:14,310 --> 00:17:15,923
character devices in general.

00:17:17,484 --> 00:17:19,434
It is the same thing for suspended them

00:17:20,940 --> 00:17:22,450
in the working state of a system

00:17:22,450 --> 00:17:25,200
and during a system-wide operations.

00:17:25,200 --> 00:17:28,720
There are devices for which that cannot be done,

00:17:28,720 --> 00:17:31,480
but there's a lot of devices where it,

00:17:31,480 --> 00:17:35,440
actually this slide is sort of related.

00:17:35,440 --> 00:17:37,180
So this is an old factory

00:17:37,180 --> 00:17:42,180
which has been turned into a modern business park

00:17:43,330 --> 00:17:44,930
by adding some new architecture

00:17:44,930 --> 00:17:46,520
and you know, remodeling things,

00:17:46,520 --> 00:17:51,240
so this is like a re-use of something that existed before.

00:17:51,240 --> 00:17:55,320
So I would think rather the drivers that support

00:17:56,480 --> 00:17:57,820
system-wide power management

00:17:57,820 --> 00:17:59,447
already may want to use the same callbacks

00:17:59,447 --> 00:18:00,883
for PM-runtime for example.

00:18:04,470 --> 00:18:06,333
So we want those two things.

00:18:07,270 --> 00:18:10,760
There are complications, obviously.

00:18:10,760 --> 00:18:13,865
One of them is, or not one of them,

00:18:13,865 --> 00:18:17,010
there is a couple of limitations

00:18:17,010 --> 00:18:22,010
coming from how the power management of devices

00:18:22,350 --> 00:18:24,910
is organized, generally speaking.

00:18:24,910 --> 00:18:29,730
So there are dependencies between devices.

00:18:29,730 --> 00:18:31,880
So the blue part of the diagram

00:18:31,880 --> 00:18:36,253
is the device hierarchy or a small piece of it, actually.

00:18:37,310 --> 00:18:39,050
Parents are above children,

00:18:39,050 --> 00:18:42,910
the double-headed arrows go from children to parents

00:18:44,544 --> 00:18:47,720
and they obviously the dependencies go both ways

00:18:47,720 --> 00:18:51,713
because the ordering during suspend whatever it is,

00:18:53,070 --> 00:18:56,150
runtime suspend or system-wide suspend,

00:18:57,454 --> 00:19:01,700
suspend ordering is the reverse of the resume ordering,

00:19:01,700 --> 00:19:05,203
so the ordering requirements go both ways.

00:19:06,240 --> 00:19:08,620
There may be links between devices

00:19:08,620 --> 00:19:11,520
in addition to the parent child relationships.

00:19:11,520 --> 00:19:14,490
This is a device link it can be added and again,

00:19:14,490 --> 00:19:16,260
it represents a dependency.

00:19:16,260 --> 00:19:18,340
It doesn't matter, for this diagram

00:19:18,340 --> 00:19:20,280
it doesn't matter which way it goes.

00:19:20,280 --> 00:19:22,190
So say this device may be a supplier

00:19:22,190 --> 00:19:23,953
and this device may be a consumer.

00:19:25,650 --> 00:19:28,450
Which means that the consumer

00:19:28,450 --> 00:19:30,500
has to be suspended before the supplier

00:19:30,500 --> 00:19:33,250
and the supplier has to be resumed before the consumer.

00:19:34,240 --> 00:19:35,220
So there are dependencies

00:19:35,220 --> 00:19:37,920
and they have to be taken into account.

00:19:37,920 --> 00:19:38,810
Always.

00:19:38,810 --> 00:19:43,810
Now there is also a complication

00:19:43,930 --> 00:19:48,250
related to the structure

00:19:48,250 --> 00:19:50,513
of the power management code in the kernel.

00:19:51,910 --> 00:19:55,250
So the driver core is evoked for all the operations

00:19:55,250 --> 00:19:57,540
like runtime suspend, runtime resume,

00:19:57,540 --> 00:19:58,800
for all the phases of

00:19:59,991 --> 00:20:03,103
the system suspend and resume transitions.

00:20:04,670 --> 00:20:07,710
What it does, it looks for a callback

00:20:07,710 --> 00:20:09,830
to carry out each of the operations

00:20:13,230 --> 00:20:16,400
and it looks for that callback at the highest level

00:20:18,973 --> 00:20:20,260
where it can be defined.

00:20:20,260 --> 00:20:25,260
Which means in the layer of code

00:20:25,680 --> 00:20:27,700
that I refer to as the middle layer

00:20:27,700 --> 00:20:31,190
because it is between device drivers and the driver core

00:20:31,190 --> 00:20:35,360
and that may be device types, device classes,

00:20:35,360 --> 00:20:38,300
bus types and PM domains.

00:20:38,300 --> 00:20:43,300
So the driver core looks into that layer for a callback,

00:20:44,710 --> 00:20:47,253
and then if it's there, it will invoke it.

00:20:48,430 --> 00:20:50,970
If it's not there it will look into the driver

00:20:50,970 --> 00:20:53,673
and invoke a callback from a driver directly,

00:20:55,110 --> 00:20:57,383
but as a rule it first looks at the middle layer.

00:21:01,374 --> 00:21:04,080
The class and type case is not interesting here

00:21:04,080 --> 00:21:07,900
because all the PM handling is class specific

00:21:07,900 --> 00:21:10,520
or type specific so they have to coordinate

00:21:10,520 --> 00:21:15,520
PM-runtime with system-wide power management by themselves,

00:21:17,220 --> 00:21:21,873
classes and types have to do that in their own ways.

00:21:23,624 --> 00:21:26,430
The interesting and complicated case

00:21:26,430 --> 00:21:30,180
is when there is a bus and there are drivers.

00:21:30,180 --> 00:21:35,180
Which handle devices on the bus, with this bus type.

00:21:39,353 --> 00:21:42,370
What happens here is that the driver core

00:21:44,022 --> 00:21:45,920
carries out a suspend operation, okay

00:21:47,080 --> 00:21:49,813
or one of the phases of system-wide suspend.

00:21:49,813 --> 00:21:51,743
Runtime suspend or somewhat.

00:21:51,743 --> 00:21:54,763
So it first looks for a callback here in the bus.

00:21:56,919 --> 00:21:57,860
If it is there, it will be run.

00:21:57,860 --> 00:21:59,300
And that callback is responsible

00:21:59,300 --> 00:22:01,890
for running the driver callback in that case.

00:22:01,890 --> 00:22:05,853
But it may also access the device and do something to it.

00:22:07,260 --> 00:22:11,080
The PCI power management is a good example of that.

00:22:11,080 --> 00:22:14,900
PCI, the PCI layer handles all of

00:22:14,900 --> 00:22:18,120
the standard PCI power management.

00:22:18,120 --> 00:22:20,170
Drivers don't need to do that.

00:22:20,170 --> 00:22:24,140
So that PCI layer we programmed the PMCSR

00:22:26,090 --> 00:22:28,600
is a register of PCI devices,

00:22:28,600 --> 00:22:33,600
and in order to program them into say low power states.

00:22:35,300 --> 00:22:38,140
And drivers need to do something in addition,

00:22:38,140 --> 00:22:40,570
for example stop the queues and all that.

00:22:40,570 --> 00:22:44,790
So the bus type callback usually invokes

00:22:44,790 --> 00:22:46,000
a driver callback first

00:22:46,000 --> 00:22:48,842
and then does something to the device

00:22:48,842 --> 00:22:51,560
to put it into a low power state.

00:22:51,560 --> 00:22:52,930
That's how it works as a rule.

00:22:52,930 --> 00:22:54,290
Sometimes there are differences

00:22:54,290 --> 00:22:56,410
between bus types, but anyway.

00:22:56,410 --> 00:23:00,090
The thing to remember is that the bus type callbacks

00:23:00,090 --> 00:23:02,440
may want to access the device directly

00:23:02,440 --> 00:23:06,683
without involving the driver.

00:23:08,750 --> 00:23:12,720
Okay, there may not be callbacks

00:23:12,720 --> 00:23:15,240
in a bus type for power management.

00:23:15,240 --> 00:23:17,450
There are bus types where, or buses

00:23:17,450 --> 00:23:18,829
where the bus protocol

00:23:18,829 --> 00:23:21,810
doesn't define power management operations at all,

00:23:21,810 --> 00:23:24,640
in that case there are no callbacks here

00:23:24,640 --> 00:23:27,773
and the driver core looks,

00:23:28,840 --> 00:23:31,920
or invokes callback driver callbacks directly.

00:23:31,920 --> 00:23:34,310
In those cases, which I will refer to

00:23:34,310 --> 00:23:36,193
as pass-through bus types,

00:23:38,270 --> 00:23:41,840
the bus type set of callbacks may be replaced

00:23:41,840 --> 00:23:43,177
with PM domain instead of callbacks.

00:23:43,177 --> 00:23:47,300
So PM domain is just a power management

00:23:47,300 --> 00:23:48,973
kind of replacement of a bus.

00:23:50,560 --> 00:23:54,410
It does all the things that the bus would do

00:23:54,410 --> 00:23:58,757
except that PM domains can be used for multiple drivers

00:23:59,750 --> 00:24:02,790
on multiple buses at the same time.

00:24:02,790 --> 00:24:07,750
Like say ACPI PM domain can be used for platform devices

00:24:07,750 --> 00:24:12,750
and I-squared-C devices, SPI devices and all of that.

00:24:16,607 --> 00:24:20,090
And it does, it kind of bypasses bus

00:24:22,445 --> 00:24:25,260
and takes the role of the bus essentially

00:24:25,260 --> 00:24:26,530
in power management.

00:24:26,530 --> 00:24:28,290
Might talk to the device directly

00:24:28,290 --> 00:24:31,470
and is responsible for invoking driver callbacks.

00:24:31,470 --> 00:24:34,070
Okay so all of that is kind of complicated

00:24:34,070 --> 00:24:36,410
but all of that has to be taken into account

00:24:36,410 --> 00:24:38,150
when you want to integrate

00:24:38,150 --> 00:24:41,093
PM-runtime with system-wide power management.

00:24:42,730 --> 00:24:47,730
The next thing is devices that are already in suspend

00:24:49,580 --> 00:24:54,570
during system-wide suspend may need to be reconfigured.

00:24:54,570 --> 00:24:56,100
In the photo there's a bridge

00:24:57,720 --> 00:25:00,160
undergoing a reconfiguration.

00:25:00,160 --> 00:25:02,539
That looks kind of scary but

00:25:02,539 --> 00:25:04,872
(inaudible)

00:25:06,430 --> 00:25:09,270
Yes it is, yeah.

00:25:09,270 --> 00:25:10,433
But yeah, okay.

00:25:11,840 --> 00:25:15,122
So the question really was about the photo.

00:25:15,122 --> 00:25:17,244
(laughing)

00:25:17,244 --> 00:25:19,577
(inaudible)

00:25:21,190 --> 00:25:22,450
Yeah, I do.

00:25:22,450 --> 00:25:25,534
Not only from pollen, okay.

00:25:25,534 --> 00:25:29,318
Anyway, there is in the photo there is a bridge

00:25:29,318 --> 00:25:30,743
undergoing a reconfiguration.

00:25:30,743 --> 00:25:32,493
Yes, it is most nice.

00:25:35,025 --> 00:25:39,350
So yeah, but you know, devices may need to be reconfigured.

00:25:39,350 --> 00:25:42,520
Now the reasons why may be multiple

00:25:42,520 --> 00:25:46,923
but most importantly that is related to Wakeup.

00:25:49,270 --> 00:25:51,080
That is related to Wakeup

00:25:51,080 --> 00:25:53,540
and the reason why is because

00:25:53,540 --> 00:25:58,270
PM-runtime always enables the Wakeup device,

00:25:58,270 --> 00:25:59,800
or device Wakeup, sorry.

00:25:59,800 --> 00:26:02,233
Device Wakeup is always enabled by PM-runtime.

00:26:03,220 --> 00:26:05,900
The reason why is because PM-runtime thinks that

00:26:05,900 --> 00:26:08,700
if there is something going outside

00:26:08,700 --> 00:26:11,358
that may interact with the device

00:26:11,358 --> 00:26:14,220
it's good to know about it.

00:26:14,220 --> 00:26:18,773
Because this is expected to be transparent,

00:26:20,369 --> 00:26:24,970
so if the device is configured to handle something

00:26:24,970 --> 00:26:28,730
some external events also that should also happen

00:26:28,730 --> 00:26:30,263
when the device is suspended,

00:26:31,300 --> 00:26:34,803
so PM-runtime enables device Wakeup.

00:26:35,970 --> 00:26:38,671
System-wide power management on the other hand,

00:26:38,671 --> 00:26:43,570
has a switch which can be operated by user space

00:26:43,570 --> 00:26:44,713
for every device.

00:26:45,850 --> 00:26:49,620
And if user space says oh I don't want this device

00:26:49,620 --> 00:26:51,603
to wake up the system from sleep,

00:26:53,630 --> 00:26:58,630
then it will write disable to this attribute

00:26:59,190 --> 00:27:03,140
and then there is a difference between PM-runtime

00:27:03,140 --> 00:27:04,700
and system-wide power management

00:27:04,700 --> 00:27:06,260
with respect to device Wakeup.

00:27:06,260 --> 00:27:08,950
And in that case, if the device

00:27:08,950 --> 00:27:13,280
has been suspended in the working state,

00:27:13,280 --> 00:27:15,130
it may need to be resumed just in order

00:27:15,130 --> 00:27:20,130
to disable wakeup before the system goes to sleep.

00:27:23,410 --> 00:27:26,600
That doesn't, it may or may not be necessary,

00:27:26,600 --> 00:27:27,670
that depends on the device,

00:27:27,670 --> 00:27:30,060
on the bus and on the other things.

00:27:30,060 --> 00:27:31,680
On what PM domain is used

00:27:31,680 --> 00:27:34,353
but it may be necessary to resume the device.

00:27:39,210 --> 00:27:41,100
Another complication is that,

00:27:41,100 --> 00:27:43,100
actually this is Sea World in San Diego,

00:27:45,579 --> 00:27:49,150
and these are like orca show

00:27:50,881 --> 00:27:54,220
so kind of intermittent interactions, right,

00:27:54,220 --> 00:27:57,870
because orcas and humans are different species

00:27:57,870 --> 00:27:59,460
and live in different environments,

00:27:59,460 --> 00:28:01,690
don't live together basically.

00:28:01,690 --> 00:28:03,753
So can only interact intermittently.

00:28:05,360 --> 00:28:10,360
But anyway, the devices can interact intermittently as well.

00:28:11,110 --> 00:28:13,093
So I have one example of that.

00:28:14,060 --> 00:28:18,650
Which is sometimes in order to remove power from one device,

00:28:18,650 --> 00:28:23,650
you need a different device to handle it for you.

00:28:23,680 --> 00:28:26,617
Like you have a device,

00:28:29,170 --> 00:28:30,993
let's say a PCI device,

00:28:33,106 --> 00:28:37,087
which is kind of a PCI device with a complicated part

00:28:41,380 --> 00:28:43,000
behind the PCI interface

00:28:43,000 --> 00:28:44,023
and it needs to be,

00:28:45,850 --> 00:28:47,650
to remove power from it,

00:28:47,650 --> 00:28:51,380
you may need to talk to a PM power management unit

00:28:52,985 --> 00:28:54,917
on the platform or in the SOC.

00:28:56,520 --> 00:28:59,220
And in order to do that you may need

00:28:59,220 --> 00:29:01,640
to carry out a I-squared-C transaction.

00:29:01,640 --> 00:29:06,640
Between the power management unit and your driver.

00:29:06,840 --> 00:29:10,060
So you need to send a command

00:29:10,060 --> 00:29:12,610
to the power management unit

00:29:12,610 --> 00:29:13,950
in the platform

00:29:13,950 --> 00:29:16,853
in order to remove power from this device.

00:29:17,770 --> 00:29:21,200
For that you need the I-squared-C controller to be on,

00:29:21,200 --> 00:29:23,430
right, it cannot be suspended.

00:29:23,430 --> 00:29:25,710
So you have to resume the controller,

00:29:25,710 --> 00:29:27,540
carry out the I-squared-C transaction,

00:29:27,540 --> 00:29:29,570
tell the power management unit

00:29:29,570 --> 00:29:31,850
to remove power from this device,

00:29:31,850 --> 00:29:33,700
and then the device can be suspended.

00:29:34,910 --> 00:29:37,760
So this is kind of an intermittent reaction, interaction,

00:29:42,399 --> 00:29:43,232
I have in mind.

00:29:43,232 --> 00:29:45,257
So in order to do something to the device

00:29:45,257 --> 00:29:47,900
you may need to resume another device

00:29:47,900 --> 00:29:51,350
and use it to carry out the action

00:29:51,350 --> 00:29:54,870
but it is not necessary for the target device

00:29:54,870 --> 00:29:56,103
on a regular basis.

00:29:57,870 --> 00:29:58,703
Okay?

00:29:59,790 --> 00:30:03,253
Interestingly enough, this can happen during system suspend.

00:30:05,320 --> 00:30:09,880
Because you may need to remove power from devices

00:30:09,880 --> 00:30:14,090
when you suspend them during system suspend transitions.

00:30:14,090 --> 00:30:16,920
And you may need to restore power to devices

00:30:16,920 --> 00:30:19,033
when you resume them during system resume.

00:30:20,830 --> 00:30:21,663
Okay

00:30:28,060 --> 00:30:30,560
So all of those things get in the way

00:30:30,560 --> 00:30:34,150
when you want to, when you want to

00:30:34,150 --> 00:30:37,350
handle suspended devices transparently

00:30:37,350 --> 00:30:39,000
and you want to re-use callbacks.

00:30:39,920 --> 00:30:41,890
There are ways to do it.

00:30:41,890 --> 00:30:43,700
Those ways are not

00:30:45,820 --> 00:30:47,447
I'm going please down here,

00:30:47,447 --> 00:30:49,512
talk about each of them a bit,

00:30:49,512 --> 00:30:54,030
but they are not like very well

00:30:54,950 --> 00:30:57,300
integrated with each other,

00:30:57,300 --> 00:30:59,057
they have use cases in which

00:30:59,057 --> 00:31:01,640
they are applicable various cases,

00:31:01,640 --> 00:31:04,100
there are cases in which they are not,

00:31:04,100 --> 00:31:06,243
and none of them is ideal.

00:31:07,700 --> 00:31:11,160
So first of all there is direct complete optimization

00:31:11,160 --> 00:31:12,620
and the idea is as follows.

00:31:12,620 --> 00:31:17,473
You say that a device is suspended to start with.

00:31:18,790 --> 00:31:23,483
Now in the prepare phase of device suspend,

00:31:24,424 --> 00:31:27,880
the callback from the driver or bus type for it

00:31:27,880 --> 00:31:30,940
may return a value that is greater than zero

00:31:30,940 --> 00:31:32,310
and then the driver can only see

00:31:32,310 --> 00:31:34,430
oh this device is suspended

00:31:35,784 --> 00:31:38,240
and prepare callback return something positive,

00:31:38,240 --> 00:31:43,000
so I can actually keep the device in suspend,

00:31:43,000 --> 00:31:45,550
or it may remain suspended.

00:31:45,550 --> 00:31:50,550
In that case the driver core will actually skip

00:31:51,910 --> 00:31:55,000
all the other phases of suspend and resume for this device

00:31:55,000 --> 00:31:57,963
and will only invoke the complete callback on the way back.

00:31:59,020 --> 00:32:01,143
So this is a direct complete thing.

00:32:02,310 --> 00:32:05,030
It is optional, you have to, as I said,

00:32:05,030 --> 00:32:09,140
return a value that is greater than zero from prepare.

00:32:09,140 --> 00:32:10,283
It has limitations.

00:32:12,130 --> 00:32:13,370
The limitations are--

00:32:13,370 --> 00:32:14,620
- [Man] I had a question.

00:32:16,241 --> 00:32:18,717
In the previous slide if you were talking,

00:32:18,717 --> 00:32:20,213
can you go to the previous slide?

00:32:22,849 --> 00:32:26,150
So in this case, the device suspend and device

00:32:26,150 --> 00:32:28,350
as you were talking about system-wide

00:32:28,350 --> 00:32:30,150
suspend resume sequence,

00:32:30,150 --> 00:32:32,670
but the prepare function,

00:32:32,670 --> 00:32:36,240
you're expecting the driver to return a positive number

00:32:36,240 --> 00:32:38,280
if the driver had already put the device

00:32:38,280 --> 00:32:40,610
in runtime suspend, right?

00:32:40,610 --> 00:32:45,160
- Not if, this is the necessary condition.

00:32:45,160 --> 00:32:47,640
So if the device is runtime suspended

00:32:47,640 --> 00:32:50,890
and prepare returns a positive number,

00:32:50,890 --> 00:32:52,040
it doesn't have to,

00:32:52,040 --> 00:32:54,253
it may return a positive number.

00:32:55,730 --> 00:32:57,230
And that's when this triggers.

00:32:59,650 --> 00:33:02,650
But the limitations are that the

00:33:04,600 --> 00:33:07,350
it can only be done safely if all the children

00:33:07,350 --> 00:33:11,210
and consumers of the target device

00:33:11,210 --> 00:33:15,660
also use this optimization,

00:33:15,660 --> 00:33:18,300
because otherwise the device may be suspended

00:33:18,300 --> 00:33:21,660
and somebody may want it or may need to use it

00:33:21,660 --> 00:33:23,123
to suspend itself.

00:33:24,370 --> 00:33:27,480
And also the intermittent interactions

00:33:27,480 --> 00:33:29,740
I was talking about are not covered.

00:33:29,740 --> 00:33:33,770
Because if something is needed,

00:33:33,770 --> 00:33:36,360
if something is needed in this phase,

00:33:36,360 --> 00:33:37,910
if the device is needed in this phase

00:33:37,910 --> 00:33:42,013
by another device or for handling another device,

00:33:43,370 --> 00:33:45,603
then this doesn't work, right?

00:33:48,070 --> 00:33:52,170
Okay, another way to that has been proposed

00:33:52,170 --> 00:33:53,940
and you see this in multiple places

00:33:53,940 --> 00:33:57,240
the kernels used to use wrappers around PM-runtime callbacks

00:33:58,900 --> 00:34:03,283
to kind of provide system-wide power management callbacks.

00:34:04,150 --> 00:34:06,743
Okay, wrapped buildings here.

00:34:08,610 --> 00:34:12,656
So this also has, so first of all,

00:34:12,656 --> 00:34:16,010
why is necessary to use a wrapper

00:34:16,010 --> 00:34:17,240
in the first place?

00:34:17,240 --> 00:34:20,360
Well it may be necessary in the pass-through case

00:34:20,360 --> 00:34:22,603
where the bus type doesn't handle,

00:34:24,250 --> 00:34:25,630
doesn't provide any callbacks

00:34:25,630 --> 00:34:29,940
and the driver core calls the driver callback directly.

00:34:29,940 --> 00:34:32,660
Because in that case, if you want to point

00:34:32,660 --> 00:34:37,660
your system-wide say suspend callback pointer

00:34:40,090 --> 00:34:44,060
to your runtime PM suspend routine,

00:34:44,060 --> 00:34:46,433
that routine may not,

00:34:48,010 --> 00:34:49,390
in principle it may be invoked

00:34:49,390 --> 00:34:51,880
when the device is already suspended

00:34:51,880 --> 00:34:54,560
in which case it will be bad, right,

00:34:54,560 --> 00:34:57,470
to run it twice in a row on the same device.

00:34:57,470 --> 00:35:00,653
So there needs to be a check for

00:35:00,653 --> 00:35:03,260
is the device suspended in that callback.

00:35:03,260 --> 00:35:05,890
Obviously for PM-runtime it is not necessary

00:35:05,890 --> 00:35:08,540
so it is better to have a wrapper to do that check

00:35:08,540 --> 00:35:12,940
and do something else in addition to it.

00:35:12,940 --> 00:35:17,940
Again this is an approach with limitations.

00:35:21,100 --> 00:35:23,210
And that's mostly because of the way

00:35:23,210 --> 00:35:25,150
it is done in practice in the kernel.

00:35:25,150 --> 00:35:25,983
I'm sorry.

00:35:28,820 --> 00:35:30,380
- [Man] Suspend in work.

00:35:30,380 --> 00:35:31,600
(laughing)

00:35:31,600 --> 00:35:33,513
- Yeah, the graphics.

00:35:35,520 --> 00:35:36,378
Okay.

00:35:36,378 --> 00:35:38,628
(laughing)

00:35:45,340 --> 00:35:46,857
Okay so first of all it does

00:35:48,010 --> 00:35:51,020
the way it is implemented is by invoking

00:35:51,020 --> 00:35:52,860
middle-layer PM-runtime callbacks

00:35:52,860 --> 00:35:55,070
in addition to the driver

00:35:55,070 --> 00:35:57,710
so the wrapper actually does the whole

00:35:57,710 --> 00:36:02,460
PM-runtime transition during system-wide suspend or resume.

00:36:02,460 --> 00:36:04,780
That may not work in general,

00:36:04,780 --> 00:36:06,320
it works in certain cases,

00:36:06,320 --> 00:36:07,970
doesn't work in general.

00:36:07,970 --> 00:36:11,010
It disables runtime PM when it is run

00:36:11,010 --> 00:36:14,003
because it has to use the middle layer callbacks

00:36:16,230 --> 00:36:17,103
from PM-runtime.

00:36:18,640 --> 00:36:23,640
Also the kind of, the approach used by it

00:36:26,340 --> 00:36:29,780
by those wrappers in the handling

00:36:29,780 --> 00:36:32,870
of suspended devices during resume

00:36:32,870 --> 00:36:34,370
is kind of questionable

00:36:34,370 --> 00:36:38,100
because they only look at the user counter

00:36:38,100 --> 00:36:42,368
of PM-runtime and the child counter of PM-runtime

00:36:42,368 --> 00:36:45,590
to decide whether or not to leave the devices in suspend.

00:36:45,590 --> 00:36:46,870
It may not be sufficient

00:36:48,850 --> 00:36:50,420
in the majority of case.

00:36:50,420 --> 00:36:55,110
Okay so the photos here are illustrations

00:36:55,110 --> 00:36:57,200
of something that looks impressive

00:36:57,200 --> 00:36:59,170
but there's something wrong with it.

00:36:59,170 --> 00:37:02,530
So this is the Leaning Tower in Pisa, obviously.

00:37:02,530 --> 00:37:06,033
And this is, well, so that is in Warsaw,

00:37:07,040 --> 00:37:09,370
and the thing that went wrong here is

00:37:09,370 --> 00:37:14,350
that this building looks unfinished.

00:37:14,350 --> 00:37:17,530
And the reason why is that it had a windshield

00:37:17,530 --> 00:37:21,320
like this one at the top but the windshield burnt down

00:37:21,320 --> 00:37:24,380
and then when the pieces of it were falling

00:37:24,380 --> 00:37:29,380
during the fire, it actually damaged the glass panels

00:37:29,490 --> 00:37:33,650
on the facade so they had to remove them.

00:37:33,650 --> 00:37:36,433
So this is like an example where

00:37:36,433 --> 00:37:41,433
so it looks impressive but it is not quite there.

00:37:41,690 --> 00:37:44,393
Like those callback wrappers.

00:37:46,250 --> 00:37:49,107
Now the most recent attempts to do that

00:37:52,670 --> 00:37:57,670
or to make the desired things happen

00:37:59,120 --> 00:38:01,300
was to use driver flags.

00:38:01,300 --> 00:38:06,050
So drivers can set those flags on a device when they

00:38:06,050 --> 00:38:09,380
these two are related to direct complete

00:38:10,240 --> 00:38:12,411
so I am not going to talk about them.

00:38:12,411 --> 00:38:17,020
This is to say that the device does need

00:38:17,020 --> 00:38:19,240
to be resumed from the driver perspective.

00:38:19,240 --> 00:38:21,073
So the bus type or driver core,

00:38:22,010 --> 00:38:23,630
the bus type or driver core doing this

00:38:23,630 --> 00:38:26,264
suspend will not try to resume the device

00:38:26,264 --> 00:38:29,850
if this flag is set unless it thinks

00:38:29,850 --> 00:38:32,043
that it needs to do that by itself.

00:38:34,050 --> 00:38:36,650
And that flag obviously says that

00:38:36,650 --> 00:38:37,920
the driver wants the device

00:38:37,920 --> 00:38:42,410
to be left in suspend during system resume.

00:38:42,410 --> 00:38:47,410
So it is still there are coverage gaps

00:38:49,453 --> 00:38:50,773
in that approach, too.

00:38:51,780 --> 00:38:56,628
Because even if you set the flags and you know

00:38:56,628 --> 00:38:58,920
provide the same callback for,

00:38:58,920 --> 00:39:01,490
point your callback pointers to the same callback

00:39:01,490 --> 00:39:04,820
for PM-runtime and system-wide suspend resume,

00:39:04,820 --> 00:39:05,950
there's still

00:39:08,230 --> 00:39:10,260
it doesn't cover their intermittent interactions

00:39:10,260 --> 00:39:11,173
it's not possible.

00:39:12,280 --> 00:39:15,710
If your device is in suspend,

00:39:15,710 --> 00:39:18,610
was left in suspend by the bus type

00:39:18,610 --> 00:39:23,240
and then somebody wants it during the late stage

00:39:23,240 --> 00:39:26,920
of a system suspend, this doesn't work.

00:39:26,920 --> 00:39:31,570
And also this, for callback re-use you need to set the

00:39:33,460 --> 00:39:36,727
smart suspend flag which is kind of ugly

00:39:38,160 --> 00:39:40,020
or kind of inconvenient

00:39:40,020 --> 00:39:42,270
because it should be sufficient to just

00:39:42,270 --> 00:39:45,370
point the callbacks to the same routine and be done

00:39:45,370 --> 00:39:47,570
without setting your flag in addition to it.

00:39:48,840 --> 00:39:49,673
All right

00:39:51,430 --> 00:39:53,700
These are kind of illustrations of that.

00:39:53,700 --> 00:39:58,700
The buildings that are kind of left in a bad shape

00:40:00,100 --> 00:40:04,593
even though the area around them as improved a lot.

00:40:06,210 --> 00:40:07,043
Okay.

00:40:08,250 --> 00:40:09,853
So yeah, what can we do?

00:40:11,150 --> 00:40:15,497
Obviously, there is a need to combine

00:40:18,650 --> 00:40:21,980
all those methods together so if one driver

00:40:21,980 --> 00:40:26,980
uses this way to handle the problem I was talking about

00:40:28,797 --> 00:40:31,440
and the other driver uses a different approach,

00:40:31,440 --> 00:40:33,383
they should work together, anyway.

00:40:36,255 --> 00:40:39,293
And intermittent interactions should be covered.

00:40:42,490 --> 00:40:43,553
Today, they aren't.

00:40:48,101 --> 00:40:50,963
There are two observations that can be made.

00:40:52,740 --> 00:40:55,300
The first one I already talked about.

00:40:55,300 --> 00:40:58,050
So devices cannot be runtime suspended

00:40:58,050 --> 00:40:59,520
during system-wide operations

00:40:59,520 --> 00:41:04,520
because of the usage counter incrementation

00:41:05,940 --> 00:41:08,023
up front in the prepare phase.

00:41:09,717 --> 00:41:11,820
And the second observation,

00:41:11,820 --> 00:41:13,000
which also is important,

00:41:13,000 --> 00:41:16,540
there are two cases, two reasons why

00:41:16,540 --> 00:41:21,260
PM-runtime can be used during system-wide

00:41:21,260 --> 00:41:22,410
power management transitions.

00:41:22,410 --> 00:41:26,977
First of all, it may be used from a callback

00:41:29,140 --> 00:41:34,140
running in a system-wide power management flow

00:41:35,420 --> 00:41:36,483
for the same device.

00:41:37,670 --> 00:41:40,690
Like for example, the driver sees that

00:41:40,690 --> 00:41:42,070
oh I need to resume the device

00:41:42,070 --> 00:41:44,270
because of wakeup settings.

00:41:44,270 --> 00:41:47,410
So it will use PM-runtime for that.

00:41:47,410 --> 00:41:50,163
Or a bus type can see the same thing.

00:41:51,950 --> 00:41:53,623
And the other case is obviously that

00:41:53,623 --> 00:41:55,373
it maybe comes from somewhere else.

00:41:56,950 --> 00:42:01,190
So now the idea or the what can be done here

00:42:01,190 --> 00:42:06,190
is that well, if that PM-runtime is called from

00:42:08,720 --> 00:42:10,840
the callback of the same device,

00:42:10,840 --> 00:42:11,673
just run it.

00:42:12,530 --> 00:42:16,740
It can be run because it belongs to the flow,

00:42:16,740 --> 00:42:18,700
this is the same device we just handled,

00:42:18,700 --> 00:42:20,683
we can just run it.

00:42:22,010 --> 00:42:23,373
In other cases,

00:42:27,720 --> 00:42:28,870
it depends, right?

00:42:28,870 --> 00:42:32,660
So if it is called after system-wide PM

00:42:32,660 --> 00:42:34,350
has done anything to the device,

00:42:34,350 --> 00:42:35,250
we have to file it

00:42:38,050 --> 00:42:40,946
because otherwise it might try to undo

00:42:40,946 --> 00:42:45,503
what was done by the system-wide PM.

00:42:47,400 --> 00:42:51,730
In the other case, the right approach in my opinion,

00:42:51,730 --> 00:42:54,500
and this is something that I wanted to,

00:42:54,500 --> 00:42:57,333
this is why the talk is given today,

00:42:58,300 --> 00:43:00,610
the second case in my opinion,

00:43:00,610 --> 00:43:05,310
would be to defer if we see that somebody needs a device

00:43:05,310 --> 00:43:08,840
during the system-wide transition,

00:43:08,840 --> 00:43:10,650
say during system suspend,

00:43:10,650 --> 00:43:13,840
that indicates that this may be an intermittent interaction

00:43:13,840 --> 00:43:15,990
and the device may be needed by somebody

00:43:15,990 --> 00:43:18,590
to do something to another device.

00:43:18,590 --> 00:43:20,963
In that case it would be good to just,

00:43:22,110 --> 00:43:24,380
defer the suspending of this device

00:43:24,380 --> 00:43:26,590
to the latest possible time

00:43:26,590 --> 00:43:29,240
and allow intermittent interactions to happen.

00:43:29,240 --> 00:43:32,820
If we do that then we don't have to block PM-runtime

00:43:32,820 --> 00:43:35,513
during system-wide suspend and resume.

00:43:37,550 --> 00:43:41,770
And then we can possibly get rid of callback wrappers

00:43:41,770 --> 00:43:45,800
because they really don't help, in general.

00:43:45,800 --> 00:43:50,110
Which, so even if you wrap the driver callbacks like here,

00:43:50,110 --> 00:43:53,010
the bus may still want to talk to the device

00:43:53,010 --> 00:43:56,493
and will do that regardless of the wrapper.

00:43:57,910 --> 00:44:01,020
So in the general case, callback wrappers don't help,

00:44:01,020 --> 00:44:04,130
they only help in the pass-through case really

00:44:04,130 --> 00:44:06,230
and in some PM-domain cases

00:44:08,971 --> 00:44:12,127
so again, if what I said is done,

00:44:13,240 --> 00:44:17,218
we could possibly get rid of the wrappers and use the

00:44:17,218 --> 00:44:22,218
direct complete optimization when possible.

00:44:22,690 --> 00:44:27,150
And then handle the other cases in a transparent way

00:44:27,150 --> 00:44:30,373
that I was talking about.

00:44:31,970 --> 00:44:33,650
Okay, that's it.

00:44:33,650 --> 00:44:34,563
30 seconds.

00:44:35,544 --> 00:44:37,794
(laughing)

00:44:38,660 --> 00:44:40,350
If you have any more questions

00:44:40,350 --> 00:44:42,650

YouTube URL: https://www.youtube.com/watch?v=5GXjQsnH8H8


