Title: LPC2019 - What does remote attestation buy you?
Publication date: 2019-11-18
Playlist: LPC2019 - LPC Main Track
Description: 
	What does remote attestation buy you?

Speaker
 Matthew Garrett (Google)

Description
TPM remote attestation (a mechanism allowing remote sites to ask a computer to prove what software it booted) was an object of fear in the open source community in the 2000s, a potential existential threat to Linux's ability to interact with the free internet. These concerns have largely not been realised, and now there's increasing interest in ways we can use remote attestation to improve security while avoiding privacy concerns or attacks on user freedom.

More modern uses of remote attestation include simplifying deployment of machines to remote locations, easy recovery of systems with nothing more than a network connection, automatic issuance of machine identity tokens, trust-based access control to sensitive resources and more. We've released a full implementation, so this presentation will discuss how it can be tied in to various layers of the Linux stack in ways that give us new functionality without sacrificing security or freedom.
Captions: 
	00:00:00,140 --> 00:00:04,320
- Hello everybody, I think we're past the starting time,

00:00:04,320 --> 00:00:06,480
so just a couple of quick notes

00:00:06,480 --> 00:00:08,690
since we're starting the afternoon session here.

00:00:08,690 --> 00:00:12,920
We have two talks, they're about 45 minutes each.

00:00:12,920 --> 00:00:14,240
So first, we have Matthew Garrett

00:00:14,240 --> 00:00:16,343
speaking on remote attestation.

00:00:17,980 --> 00:00:19,720
I chatted with him and it's probably,

00:00:19,720 --> 00:00:21,910
if you have questions, give it five more minutes,

00:00:21,910 --> 00:00:24,150
and otherwise, they're probably better at the end,

00:00:24,150 --> 00:00:26,090
but he's probably gonna cover

00:00:26,090 --> 00:00:30,320
what you have to ask for anyway, so focus on that.

00:00:30,320 --> 00:00:31,990
Other than that, I don't think

00:00:31,990 --> 00:00:33,860
we have anything specific to say,

00:00:33,860 --> 00:00:35,130
I'm sure most of you have seen Matthew

00:00:35,130 --> 00:00:39,030
a couple of times at a conference before, maybe about 20.

00:00:39,030 --> 00:00:41,700
Yeah, I know, we have the guy up here

00:00:41,700 --> 00:00:43,310
who's sort of losing his marbles,

00:00:43,310 --> 00:00:46,253
and making funny questions, but I'll ignore him.

00:00:47,565 --> 00:00:50,380
And after that we have Theng, I think,

00:00:50,380 --> 00:00:52,080
I'm sorry, I get names wrong,

00:00:52,080 --> 00:00:54,870
will speak on fastboot, so stay around for that too.

00:00:54,870 --> 00:00:56,233
Other than that, let's go.

00:00:58,336 --> 00:01:01,670
- OK, my name is Matthew Garrett,

00:01:01,670 --> 00:01:05,660
I work at Google on one of the internal platform

00:01:05,660 --> 00:01:06,960
security teams.

00:01:06,960 --> 00:01:10,610
So my job is not focused on the production servers

00:01:10,610 --> 00:01:12,610
and not focused on any products,

00:01:12,610 --> 00:01:15,400
but instead I work on the security of the systems

00:01:15,400 --> 00:01:18,980
that are used by Google employees on a day-to-day basis,

00:01:18,980 --> 00:01:22,100
ranging from phones up through workstations,

00:01:22,100 --> 00:01:23,623
laptops, and servers.

00:01:24,520 --> 00:01:28,950
Today, going to talking about TPM-based remote attestation

00:01:28,950 --> 00:01:33,780
and why this is useful, both in corporate environments,

00:01:33,780 --> 00:01:38,780
but also in potentially personal environments,

00:01:39,220 --> 00:01:41,660
and we'll get into that a little later.

00:01:41,660 --> 00:01:45,270
Let's begin with, it's helpful to have some idea

00:01:45,270 --> 00:01:50,270
of what we actually mean when I say attestation,

00:01:51,930 --> 00:01:56,450
and here is a not particularly helpful dictionary definition

00:01:56,450 --> 00:02:00,320
but the point here is that when we talk about attestation,

00:02:00,320 --> 00:02:02,030
we're talking about something

00:02:02,960 --> 00:02:05,460
attesting to the state of something else,

00:02:05,460 --> 00:02:07,980
we're saying this thing says,

00:02:07,980 --> 00:02:10,580
and has a justifiable reason for doing so,

00:02:10,580 --> 00:02:14,283
this thing is true about something else.

00:02:15,600 --> 00:02:19,549
And attestation in general is a sort of difficult problem,

00:02:19,549 --> 00:02:21,730
for the most part, we don't trust people

00:02:21,730 --> 00:02:24,230
to attest to their own competence

00:02:25,100 --> 00:02:27,420
because historically, we've found that people

00:02:27,420 --> 00:02:29,740
are not particularly trustworthy in that respect.

00:02:29,740 --> 00:02:34,740
If you ask someone, are you someone I should hire?

00:02:35,440 --> 00:02:38,030
Then there's a decent chance that they'll say yes,

00:02:38,030 --> 00:02:40,040
and if you then trust them on that,

00:02:40,040 --> 00:02:41,330
you may find out that in fact,

00:02:41,330 --> 00:02:44,803
they were not necessarily someone who you should've hired.

00:02:48,030 --> 00:02:49,310
And the same is true with computers.

00:02:49,310 --> 00:02:53,070
While computers are not in themselves

00:02:53,070 --> 00:02:57,240
capable of doing anything without being told to,

00:02:57,240 --> 00:03:01,610
for the most part, if someone tells a computer

00:03:01,610 --> 00:03:04,533
to lie to you, then the computer will lie to you.

00:03:06,710 --> 00:03:09,090
If a computer's running trustworthy code

00:03:09,090 --> 00:03:11,810
and you ask the computer, are you running trustworthy code?

00:03:11,810 --> 00:03:13,700
And the computer comes back and says yes,

00:03:13,700 --> 00:03:15,730
then sure, that's a good sign.

00:03:15,730 --> 00:03:18,810
However, if the computer is not running trustworthy code,

00:03:18,810 --> 00:03:22,500
and you ask the computer, are you running trustworthy code?

00:03:22,500 --> 00:03:25,243
It's probably not going to say no.

00:03:26,452 --> 00:03:28,320
(laughs)

00:03:28,320 --> 00:03:32,000
So you basically have a state diagram

00:03:32,000 --> 00:03:35,040
where the response is yes, I'm running trustworthy code,

00:03:35,040 --> 00:03:37,640
which can either mean yes, I am running trustworthy code,

00:03:37,640 --> 00:03:40,200
or no, I'm not running trustworthy code,

00:03:40,200 --> 00:03:42,500
but whoever wrote the malicious code

00:03:42,500 --> 00:03:45,450
was competent enough to convince me to lie to you about it.

00:03:49,040 --> 00:03:51,150
So telling the difference between these two things

00:03:51,150 --> 00:03:55,230
when all you have is a computer is basically impossible,

00:03:55,230 --> 00:03:57,740
we need something more than that.

00:03:57,740 --> 00:04:01,720
So we need some sort of third party

00:04:01,720 --> 00:04:06,460
that can be relied upon to give us accurate information,

00:04:06,460 --> 00:04:09,143
even if the computer itself is being compromised.

00:04:12,610 --> 00:04:14,780
Sorry, I should clarify, when I say on most platforms here,

00:04:14,780 --> 00:04:16,600
I'm specifically talking about PCs,

00:04:16,600 --> 00:04:18,950
there are alternative approaches

00:04:18,950 --> 00:04:22,470
that's being implemented in various other spaces,

00:04:22,470 --> 00:04:24,270
mobile phones for instance,

00:04:24,270 --> 00:04:26,970
tend to have non-TPM based solutions to this,

00:04:26,970 --> 00:04:31,160
although TPMs are becoming increasingly common

00:04:31,160 --> 00:04:32,750
in the phone space as well.

00:04:32,750 --> 00:04:35,540
So TPM is a Trusted Platform Module,

00:04:35,540 --> 00:04:40,540
it's a small device that doesn't consume a lot of power.

00:04:42,610 --> 00:04:47,610
But as a consequence, it's also not particularly powerful.

00:04:48,020 --> 00:04:50,630
It sits there, it can't do a lot.

00:04:50,630 --> 00:04:53,460
There's some degree of support

00:04:53,460 --> 00:04:56,230
for cryptographic primitives on the TPM.

00:04:56,230 --> 00:04:58,610
TPMs can generate cryptographic keys,

00:04:58,610 --> 00:05:00,640
they can encrypt some information,

00:05:00,640 --> 00:05:02,513
they consign some information.

00:05:03,440 --> 00:05:05,700
They can generate random numbers,

00:05:05,700 --> 00:05:09,630
but other than that, they can't do a whole lot.

00:05:09,630 --> 00:05:11,980
They've got a small amount of local storage,

00:05:11,980 --> 00:05:15,730
but really again, not a lot of local storage.

00:05:15,730 --> 00:05:18,630
And the most fundamentally important thing,

00:05:18,630 --> 00:05:20,320
and something that was frequently misunderstood

00:05:20,320 --> 00:05:22,900
about TPMs in the past, is that TPMs

00:05:22,900 --> 00:05:27,900
have no ability to directly inspect the state of the system.

00:05:28,260 --> 00:05:32,500
TPMs on most PC platforms are attached to the LPC,

00:05:32,500 --> 00:05:36,110
the Low Pin Count bus, which is a derivative

00:05:36,110 --> 00:05:39,063
of the old PC ISA bus.

00:05:40,050 --> 00:05:42,650
There's no way they can DNA stuff arbitrarily

00:05:42,650 --> 00:05:45,040
out of memory, there's no way they can see

00:05:45,040 --> 00:05:46,780
what the CPU is doing.

00:05:46,780 --> 00:05:49,710
There's just physically no connection

00:05:49,710 --> 00:05:52,290
between the TPM and where most

00:05:52,290 --> 00:05:53,740
of the system's data is kept.

00:05:56,030 --> 00:06:01,030
So that makes it sound like a TPMs not particularly useful,

00:06:01,290 --> 00:06:05,610
if a TPM is incapable of inspecting the state of the system,

00:06:05,610 --> 00:06:09,370
how does the TPM find out about the state of the system?

00:06:09,370 --> 00:06:12,130
And the answer is that well, if you want to know

00:06:12,130 --> 00:06:13,450
about the state of the operating system,

00:06:13,450 --> 00:06:15,980
then the operating system tells the TPM,

00:06:15,980 --> 00:06:20,410
and this is arguably getting back

00:06:20,410 --> 00:06:23,170
to the problem we had before of,

00:06:23,170 --> 00:06:25,130
how do we trust the operating system

00:06:25,130 --> 00:06:28,580
to tell the TPM the truth?

00:06:28,580 --> 00:06:31,410
And obviously we can't because we can't trust

00:06:31,410 --> 00:06:33,860
the operating system to give us that information.

00:06:35,060 --> 00:06:36,980
In order to determine whether we can trust

00:06:36,980 --> 00:06:38,930
the operating system, we need to know

00:06:38,930 --> 00:06:42,590
whether we can trust the previous components.

00:06:42,590 --> 00:06:44,960
And so the way this works on TPMs

00:06:44,960 --> 00:06:47,510
is that the bootloader tells the TPM

00:06:47,510 --> 00:06:48,970
about the operating system.

00:06:48,970 --> 00:06:50,990
If the operating system has been tampered with,

00:06:50,990 --> 00:06:52,830
then when bootloader tells the TPM

00:06:52,830 --> 00:06:55,610
about the operating system, it will tell it

00:06:55,610 --> 00:06:58,480
that this operating system is different

00:06:58,480 --> 00:07:00,330
to the operating system you expected.

00:07:01,400 --> 00:07:04,870
Obviously, an attacker could tamper with the bootloader,

00:07:04,870 --> 00:07:09,520
so the firmware tells the TPM about the bootloader,

00:07:09,520 --> 00:07:12,180
and then again, if the bootloader is modified,

00:07:12,180 --> 00:07:14,883
then the TPM will be given different information.

00:07:17,170 --> 00:07:20,070
These days, the firmware is basically

00:07:20,070 --> 00:07:22,040
a small operating system itself,

00:07:22,040 --> 00:07:27,040
so the very early stages of the firmware tell the TPM

00:07:27,160 --> 00:07:29,170
about the rest of the firmware.

00:07:29,170 --> 00:07:33,940
On Intel systems, if you have the Bootguard feature enabled,

00:07:33,940 --> 00:07:38,940
then the Management Engine, which is an entirely separate

00:07:40,540 --> 00:07:45,120
x86 device that is embedded in the platform chip set,

00:07:45,120 --> 00:07:48,540
will verify the firmware and tell the TPM

00:07:48,540 --> 00:07:50,580
about the firmware bootblock.

00:07:50,580 --> 00:07:52,680
So if you can trust the Management Engine,

00:07:53,940 --> 00:07:55,569
you can trust everything.

00:07:55,569 --> 00:07:57,652
(laughs)

00:07:59,900 --> 00:08:04,370
But as I said, the TPMs are not particularly competent

00:08:04,370 --> 00:08:07,560
or complicated, they can't obtain

00:08:07,560 --> 00:08:09,260
significant contextual information,

00:08:09,260 --> 00:08:11,270
or store significant contextual information

00:08:11,270 --> 00:08:12,880
about what they're being given.

00:08:12,880 --> 00:08:16,210
So what can we actually pass to the TPM?

00:08:16,210 --> 00:08:19,540
And the answer is a series of cryptographic hashes,

00:08:19,540 --> 00:08:22,720
rather than tell the TPM anything complicated

00:08:22,720 --> 00:08:27,090
about the operating system or the bootloader,

00:08:27,090 --> 00:08:30,880
we generate a cryptographic hash of that component,

00:08:30,880 --> 00:08:33,240
and pass that to the TPM.

00:08:33,240 --> 00:08:37,160
Now the TPM doesn't store that value directly,

00:08:37,160 --> 00:08:39,260
because otherwise you could just get to the point

00:08:39,260 --> 00:08:41,710
where you have a much less operating system

00:08:41,710 --> 00:08:46,270
and you just overwrite the TPMs stored values.

00:08:46,270 --> 00:08:48,830
Instead, the TPM has a series of what are called,

00:08:48,830 --> 00:08:52,580
Platform Configuration Registers, or PCRs.

00:08:52,580 --> 00:08:55,860
And when you provide a hash to the TPM,

00:08:55,860 --> 00:09:00,860
you say, please use this hash to extend this PCR.

00:09:03,450 --> 00:09:07,890
And the TPM then takes the current value of the PCR,

00:09:07,890 --> 00:09:11,560
takes the value you passed it, concatenates those,

00:09:11,560 --> 00:09:13,840
and then takes a cryptographic hash of that,

00:09:13,840 --> 00:09:17,100
and then that's what's stored in the PCR.

00:09:17,100 --> 00:09:20,630
Now that means that the value of the PCR

00:09:20,630 --> 00:09:24,920
depends on the value of every hash that was given to it.

00:09:24,920 --> 00:09:28,260
But critically, it also depends on the order

00:09:28,260 --> 00:09:30,270
that it was given those hashes.

00:09:30,270 --> 00:09:34,390
If you pass it a hash that is all zeroes,

00:09:34,390 --> 00:09:36,490
and then a hash that is all ones,

00:09:36,490 --> 00:09:38,330
you'll get a different final answer

00:09:38,330 --> 00:09:40,270
to if you passed a hash that's all ones,

00:09:40,270 --> 00:09:41,970
and then a hash that's all zeroes.

00:09:44,410 --> 00:09:48,440
So you have something that is predictable

00:09:48,440 --> 00:09:50,730
as long as the inputs are predictable.

00:09:50,730 --> 00:09:54,930
But otherwise, impossible to spoof,

00:09:54,930 --> 00:09:58,530
as long as the cryptographic hash algorithm in question

00:09:58,530 --> 00:09:59,393
is not broken.

00:10:01,080 --> 00:10:02,917
Now, there are multiple PCRs,

00:10:02,917 --> 00:10:06,200
and different PCRs are used to measure

00:10:06,200 --> 00:10:09,250
different boot components, PCR0 is used

00:10:09,250 --> 00:10:10,920
to measure the system firmware.

00:10:10,920 --> 00:10:15,920
PCR2 is used to measure Option ROM drivers

00:10:16,320 --> 00:10:19,373
and associated files.

00:10:20,501 --> 00:10:24,020
PCR7 for instance, is used on x86 systems

00:10:24,020 --> 00:10:26,943
to measure the secure boot configuration state.

00:10:29,690 --> 00:10:33,210
So the TPM now has a bunch of these hashes,

00:10:33,210 --> 00:10:37,340
and the TPM will give those hashes back

00:10:37,340 --> 00:10:39,330
to anybody that asks for them.

00:10:39,330 --> 00:10:42,360
But you want to know that those hashes

00:10:42,360 --> 00:10:45,260
actually came from the TPM.

00:10:45,260 --> 00:10:48,680
So the TPM is able to generate a signature

00:10:48,680 --> 00:10:51,810
that covers the PCR values and a nonce,

00:10:51,810 --> 00:10:54,640
so the nonce is provided in order to prevent

00:10:56,220 --> 00:11:00,070
someone recording a TPM transaction

00:11:00,070 --> 00:11:03,790
where the values are good and then replacing

00:11:03,790 --> 00:11:05,290
the operating system with something malicious

00:11:05,290 --> 00:11:09,270
and just giving you the same response.

00:11:09,270 --> 00:11:12,300
Every time that you want the TPM to attest,

00:11:12,300 --> 00:11:14,250
you give it a new random value,

00:11:14,250 --> 00:11:17,390
and the signature that comes back covers the hashes

00:11:17,390 --> 00:11:20,393
and that random value which prevents this replay attack.

00:11:22,890 --> 00:11:26,940
Once you get this block back, so you've got the PCR values

00:11:26,940 --> 00:11:29,200
and you've got a signature that covers those values,

00:11:29,200 --> 00:11:31,480
you can verify that the signature matches

00:11:31,480 --> 00:11:34,540
and then you can see whether the PCRs

00:11:34,540 --> 00:11:36,483
match the expected values, and if they do,

00:11:36,483 --> 00:11:39,480
then system booted in the expected state.

00:11:39,480 --> 00:11:40,940
In a moment I'm going to come back

00:11:40,940 --> 00:11:43,490
to how you know that you can trust the sign-in key.

00:11:45,610 --> 00:11:48,300
But if the operating system is the thing

00:11:48,300 --> 00:11:51,040
that's asking the TPM for this information,

00:11:51,040 --> 00:11:53,830
and if the operating system is something

00:11:53,830 --> 00:11:56,480
that makes a policy decision based on this,

00:11:56,480 --> 00:11:59,010
a malicious operating system can just ignore the fact

00:11:59,010 --> 00:12:01,240
that the values were not the ones that were expected,

00:12:01,240 --> 00:12:03,860
and can do whatever it wants to do anyway.

00:12:03,860 --> 00:12:07,770
So in order to handle this attestation in a meaningful way,

00:12:07,770 --> 00:12:12,620
we need a trusted third party, at the other end,

00:12:12,620 --> 00:12:15,690
and this is where remote attestation comes in.

00:12:15,690 --> 00:12:18,850
And remote attestation, rather than the operating system

00:12:18,850 --> 00:12:21,290
attempting to validate the PCRs itself,

00:12:21,290 --> 00:12:26,290
a remote machine takes the signed values and the signature

00:12:27,540 --> 00:12:30,310
and then looks at those values,

00:12:30,310 --> 00:12:32,530
and makes some sort of policy decision

00:12:32,530 --> 00:12:34,640
based on whether it believes that those values

00:12:34,640 --> 00:12:37,933
are legitimate and good or not.

00:12:43,500 --> 00:12:46,180
Problem here is firstly, well OK,

00:12:46,180 --> 00:12:48,030
how do I know that these values are actually

00:12:48,030 --> 00:12:49,953
coming from a TPM at all?

00:12:51,170 --> 00:12:54,340
These are all very standard cryptographic operations,

00:12:54,340 --> 00:12:57,660
it's very easy to write a piece of software

00:12:57,660 --> 00:13:01,470
that behaves the same way as a real TPM.

00:13:01,470 --> 00:13:05,490
In fact, there are multiple software implementations

00:13:05,490 --> 00:13:08,760
of TPMs that are used for validation testing.

00:13:08,760 --> 00:13:12,310
But each TPM has what's called an Endorsement Key.

00:13:12,310 --> 00:13:14,157
Now the Endorsement Key can either be generated

00:13:14,157 --> 00:13:17,670
by the TPM at runtime, but more commonly,

00:13:17,670 --> 00:13:21,300
the Endorsement Key is generated at the factory

00:13:21,300 --> 00:13:23,083
while the TPM is being produced.

00:13:24,290 --> 00:13:27,750
The TPM manufacturer then generates and provides

00:13:27,750 --> 00:13:32,370
a certificate that corresponds to that Endorsement Key

00:13:32,370 --> 00:13:35,620
and which chains back to the TPM manufacturer.

00:13:35,620 --> 00:13:40,620
So, when initially determining whether

00:13:41,310 --> 00:13:43,160
the information you're looking at

00:13:43,160 --> 00:13:45,880
is coming from a real TPM, you make sure

00:13:45,880 --> 00:13:49,570
that the TPM has a valid Endorsement Certificate,

00:13:49,570 --> 00:13:54,570
and that certificate chains back to the TPM manufacturer.

00:13:55,130 --> 00:13:58,620
And then you verify that the Attestation Key,

00:13:58,620 --> 00:14:03,620
the key that's used to sign the PCR values,

00:14:04,340 --> 00:14:06,863
corresponds to the Endorsement Key.

00:14:06,863 --> 00:14:11,130
And there's a kind of slightly awkward set of hoops

00:14:11,130 --> 00:14:13,140
that you jump through to make this happen,

00:14:13,140 --> 00:14:15,840
unless you're actually implementing this yourself,

00:14:15,840 --> 00:14:17,160
which I recommend you don't do,

00:14:17,160 --> 00:14:18,750
for reasons I'll get onto later.

00:14:18,750 --> 00:14:21,640
You don't need to care, just magic happens here,

00:14:21,640 --> 00:14:22,473
and it's good.

00:14:23,904 --> 00:14:25,930
(laughs)

00:14:25,930 --> 00:14:30,570
So, we can then say, OK, the signature

00:14:30,570 --> 00:14:35,570
that covers these PCRs was made with an Attestation Key

00:14:35,950 --> 00:14:38,520
that corresponds to an Endorsement Key

00:14:38,520 --> 00:14:42,573
that came from a real TPM, as opposed to a software TPM.

00:14:43,540 --> 00:14:47,350
And great, we have the ability for the remote site

00:14:47,350 --> 00:14:52,043
to verify that this set of PCRs came from a real TPM.

00:14:54,000 --> 00:14:57,743
The problem is, interpreting these values is difficult.

00:14:59,090 --> 00:15:03,603
If all we have is the set of final PCR values,

00:15:05,350 --> 00:15:07,280
that doesn't tell us a lot.

00:15:07,280 --> 00:15:11,280
So sure, we can say, OK, these values today

00:15:11,280 --> 00:15:14,330
are not the same as these values from yesterday,

00:15:14,330 --> 00:15:17,810
but does that mean that the system was compromised?

00:15:17,810 --> 00:15:20,160
Or does that mean that the system was upgraded?

00:15:21,030 --> 00:15:24,730
Leads to, in the sort of situation

00:15:24,730 --> 00:15:28,240
where upgrading a system causes it to now misbehave,

00:15:28,240 --> 00:15:29,580
as I'm sure we've all experienced,

00:15:29,580 --> 00:15:31,950
the difference may not that semantically useful,

00:15:31,950 --> 00:15:35,380
but it's still relevant that we have some way

00:15:35,380 --> 00:15:38,883
of knowing what the cause for the changed values is.

00:15:41,610 --> 00:15:45,530
Thankfully we have one, the TPM event log

00:15:45,530 --> 00:15:50,530
is something that contains additional data,

00:15:50,730 --> 00:15:53,380
but also contains every event.

00:15:53,380 --> 00:15:58,150
So the TPM itself only has access to the final hash value.

00:15:58,150 --> 00:16:02,823
The event log contains a record of how we got to that state.

00:16:05,240 --> 00:16:08,070
The TPM has no awareness of the event log,

00:16:08,070 --> 00:16:10,740
the event log is stored in system memory,

00:16:10,740 --> 00:16:12,760
and it contains a bunch of metadata

00:16:12,760 --> 00:16:15,690
that corresponds to the hash value,

00:16:15,690 --> 00:16:18,440
but which is not itself part of the TPM,

00:16:18,440 --> 00:16:22,550
the TPM only gets the hash, the TPM can't see the log.

00:16:22,550 --> 00:16:25,060
So stuff that we put in the event log would include,

00:16:25,060 --> 00:16:29,710
for instance, when we measure a bootloader,

00:16:29,710 --> 00:16:33,130
we only pass the hash of the bootloader

00:16:34,600 --> 00:16:37,550
to the TPM,

00:16:37,550 --> 00:16:40,653
but the event log would contain information like,

00:16:41,980 --> 00:16:46,160
which file on the file system was booted

00:16:46,160 --> 00:16:48,543
in order to generate this hash.

00:16:50,040 --> 00:16:53,980
So there's a lot of useful additional information there.

00:16:53,980 --> 00:16:55,313
Had a question?

00:17:04,591 --> 00:17:05,810
- A question here.

00:17:05,810 --> 00:17:08,510
You say that TPM doesn't have any access

00:17:08,510 --> 00:17:13,100
to the TPM event log, so the question is,

00:17:13,100 --> 00:17:18,100
what part of the system generates the event log?

00:17:18,120 --> 00:17:22,020
- Yeah, so the event log is generated by,

00:17:22,020 --> 00:17:24,563
in the boot environment, the firmware.

00:17:26,210 --> 00:17:30,790
When a boot component wants to pass a measurement to the TPM

00:17:30,790 --> 00:17:34,503
it calls a firmware command, on BIOS systems,

00:17:34,503 --> 00:17:36,840
there's a software interrupt to do this,

00:17:36,840 --> 00:17:40,120
on UEFI, there's a TPM protocol that you open

00:17:40,120 --> 00:17:42,420
and then there's a command,

00:17:42,420 --> 00:17:45,560
the function points are hanging off that that you call.

00:17:45,560 --> 00:17:47,980
The firmware then does the communication with the TPM,

00:17:47,980 --> 00:17:50,870
but it also appends the additional metadata

00:17:50,870 --> 00:17:53,153
that you give it to the event log.

00:17:55,290 --> 00:17:56,720
At the point where you're handing off

00:17:56,720 --> 00:17:58,670
to the runtime operating system,

00:17:58,670 --> 00:18:00,600
the operating system takes responsibility

00:18:00,600 --> 00:18:03,440
for maintaining the event log from that point onwards.

00:18:03,440 --> 00:18:08,440
So on Linux, on UEFI systems, we copy the event log

00:18:09,230 --> 00:18:12,150
from the firmware up to the running operating system,

00:18:12,150 --> 00:18:13,920
and we don't actually continue appending to it,

00:18:13,920 --> 00:18:17,520
instead we just generate a new event log

00:18:17,520 --> 00:18:20,720
in a separate location that's exposed elsewhere in SIS FS,

00:18:20,720 --> 00:18:22,100
but you can merge these things together

00:18:22,100 --> 00:18:26,723
in order to get an overall contiguous event log.

00:18:27,880 --> 00:18:31,160
Now, the bit earlier where I said,

00:18:31,160 --> 00:18:35,380
OK, you can't necessarily trust the operating system,

00:18:35,380 --> 00:18:38,950
so if the event log is under firmware control

00:18:38,950 --> 00:18:40,620
and under operating system control,

00:18:40,620 --> 00:18:41,453
and we don't necessarily trust

00:18:41,453 --> 00:18:43,547
either the firmware or the operating system,

00:18:43,547 --> 00:18:45,950
how do we trust the event log?

00:18:45,950 --> 00:18:50,120
And the answer there is actually fairly straightforward.

00:18:50,120 --> 00:18:55,120
We know how the TPM generates its values,

00:18:55,400 --> 00:18:59,220
so we can just replay the values in the event log

00:18:59,220 --> 00:19:03,960
in the same way, and if the event log is legitimate,

00:19:03,960 --> 00:19:07,220
we should get the same values that the TPM has.

00:19:07,220 --> 00:19:09,674
Turns out this isn't always true, but,

00:19:09,674 --> 00:19:11,040
(laughs)

00:19:11,040 --> 00:19:12,400
I'll get to that later.

00:19:15,260 --> 00:19:20,150
So we replay the hashes and they get to the same end result,

00:19:20,150 --> 00:19:23,210
great, so we now know that those hashes in the event log

00:19:23,210 --> 00:19:28,040
correspond to what was actually measured,

00:19:28,040 --> 00:19:29,560
either that or someone has broken

00:19:29,560 --> 00:19:31,120
whichever cryptographic hash we're using,

00:19:31,120 --> 00:19:33,473
in which case, we're all going to have a bad day.

00:19:36,768 --> 00:19:37,610
(background talking)

00:19:37,610 --> 00:19:40,850
Yeah, different level of broken.

00:19:40,850 --> 00:19:44,950
So the next thing is to look at the individual events,

00:19:44,950 --> 00:19:48,140
and depending on the event type,

00:19:48,140 --> 00:19:52,200
it's potentially possible to verify

00:19:52,200 --> 00:19:54,890
that the additional metadata that was provided

00:19:54,890 --> 00:19:58,990
in the event log, itself hashes to the value

00:19:58,990 --> 00:20:01,643
that was put into the TPM.

00:20:03,540 --> 00:20:04,920
So an example of this would be say,

00:20:04,920 --> 00:20:08,190
the kernel command line, if the kernel command line

00:20:08,190 --> 00:20:13,190
is put into the event log, then we can replay the event log,

00:20:13,340 --> 00:20:16,100
we can look at the hash that corresponded

00:20:16,100 --> 00:20:17,900
to the kernel event log, make sure that

00:20:17,900 --> 00:20:19,350
that's part of a series of things

00:20:19,350 --> 00:20:22,720
that corresponds to the final value in the TPM,

00:20:22,720 --> 00:20:25,970
and if so, we can then check whether the kernel command line

00:20:25,970 --> 00:20:29,290
in the event log hashes to the value that was measured.

00:20:29,290 --> 00:20:31,110
And if so, we know that the event log

00:20:31,110 --> 00:20:33,600
contains a legitimate, untampered with,

00:20:33,600 --> 00:20:35,350
copy of the kernel command line,

00:20:35,350 --> 00:20:38,000
and then the remote system can look at that,

00:20:38,000 --> 00:20:41,850
and make a policy decision, like if it sees

00:20:41,850 --> 00:20:46,630
Intel IOMMU equals off, it can potentially determine

00:20:46,630 --> 00:20:51,630
that your system is vulnerable to DNA-based attacks,

00:20:51,730 --> 00:20:52,950
and therefore your system

00:20:52,950 --> 00:20:54,340
shouldn't be considered trustworthy,

00:20:54,340 --> 00:20:57,013
and refuse to grant you access to a resource.

00:20:59,930 --> 00:21:02,860
So the event log largely contains information

00:21:02,860 --> 00:21:05,430
that is defined by a combination

00:21:05,430 --> 00:21:10,430
of the trusted computing group PC Client Specification,

00:21:10,570 --> 00:21:15,570
the TCG EFI Specification, and the Microsoft

00:21:16,380 --> 00:21:18,920
Secure Boot PCR7 Specification,

00:21:18,920 --> 00:21:23,020
that is confusingly buried at the end of a webpage

00:21:23,020 --> 00:21:25,936
about something related but mostly different.

00:21:25,936 --> 00:21:28,019
(laughs)

00:21:31,320 --> 00:21:34,307
So we get a bunch of information about the firmware,

00:21:34,307 --> 00:21:39,307
and we get the hashes of any EFI drivers that were loaded,

00:21:39,630 --> 00:21:42,290
and any EFI applications that were loaded,

00:21:42,290 --> 00:21:44,150
such as your bootloader.

00:21:44,150 --> 00:21:46,980
We get information about the Secure Boot configurations

00:21:46,980 --> 00:21:50,410
merged into PCR7, so PCR7 ends up telling you,

00:21:50,410 --> 00:21:52,310
was Secure Boot enabled?

00:21:52,310 --> 00:21:54,720
If Secure Boot enabled, what was the set

00:21:54,720 --> 00:21:57,730
of trusted sign-in keys, and also,

00:21:57,730 --> 00:22:01,350
which sign-in key was used to verify

00:22:01,350 --> 00:22:03,263
whatever actually booted the system?

00:22:04,470 --> 00:22:07,310
There's actually potentially, a lot more.

00:22:07,310 --> 00:22:11,040
Operating systems are free to put whatever they want

00:22:11,040 --> 00:22:13,490
into the event log, and Windows

00:22:13,490 --> 00:22:18,110
actually stuffs a huge amount of additional information

00:22:18,110 --> 00:22:20,090
into the event log, including information

00:22:20,090 --> 00:22:23,550
about whether the system was booted

00:22:23,550 --> 00:22:25,610
with the test sign-in keys enabled,

00:22:25,610 --> 00:22:29,630
whether the system was using the TPM

00:22:29,630 --> 00:22:32,240
to provide the decryption key,

00:22:32,240 --> 00:22:35,620
and also the hashes and sign-in information

00:22:35,620 --> 00:22:37,790
of a lot of early boot components,

00:22:37,790 --> 00:22:39,480
so by looking at the event log,

00:22:39,480 --> 00:22:42,490
you can verify whether Windows launched

00:22:42,490 --> 00:22:46,260
Windows Defender in the early boot process

00:22:46,260 --> 00:22:49,560
before any of the used line applications were started.

00:22:49,560 --> 00:22:52,463
Right now on Linux side, we're not doing as much of that.

00:22:54,650 --> 00:22:57,570
The event log also contains a lot of information

00:22:57,570 --> 00:22:59,263
about the system firmware.

00:23:00,230 --> 00:23:03,950
The spec gives some guidance on what

00:23:03,950 --> 00:23:05,860
some of this information should look like,

00:23:05,860 --> 00:23:09,050
the spec is not well followed in this respect,

00:23:09,050 --> 00:23:12,270
different vendors put very different information

00:23:12,270 --> 00:23:13,963
in the same events.

00:23:14,840 --> 00:23:18,700
And in some cases we have no idea

00:23:18,700 --> 00:23:20,873
what that information actually is.

00:23:21,780 --> 00:23:23,830
PCR0, while it is expected to contain

00:23:23,830 --> 00:23:25,200
information about the firmware,

00:23:25,200 --> 00:23:27,630
contains generally, multiple different measurements,

00:23:27,630 --> 00:23:30,820
and in the case where you're using Bootguard,

00:23:30,820 --> 00:23:35,270
the first measurement in there would be Bootguard

00:23:35,270 --> 00:23:40,100
validating the early firmware block.

00:23:40,100 --> 00:23:41,700
If you're using Intel TXT,

00:23:41,700 --> 00:23:45,080
which is a TPM-based technology,

00:23:45,080 --> 00:23:47,570
then you may also have a measurement of code

00:23:47,570 --> 00:23:50,030
that's contained within the system chip set.

00:23:50,030 --> 00:23:51,630
And this can get very confusing

00:23:51,630 --> 00:23:55,003
because when you upgrade the firmware,

00:23:56,290 --> 00:23:57,930
the code that's within the chip set

00:23:57,930 --> 00:24:00,520
doesn't also get updated, so if different revisions

00:24:00,520 --> 00:24:04,780
of the chip set have different versions of that firmware,

00:24:04,780 --> 00:24:06,570
you can have different systems that,

00:24:06,570 --> 00:24:08,550
even though they're running the same firmware version,

00:24:08,550 --> 00:24:11,183
end up with different final values in PCR0.

00:24:15,020 --> 00:24:17,610
Now some vendors have realized that,

00:24:17,610 --> 00:24:20,850
well OK, if the point of this is to verify the firmware,

00:24:20,850 --> 00:24:23,170
it would be good for people to know

00:24:23,170 --> 00:24:25,260
what the legitimate values are.

00:24:25,260 --> 00:24:29,830
And some vendors put this information in README files

00:24:29,830 --> 00:24:31,760
that accompany their firmware update,

00:24:31,760 --> 00:24:35,470
which is not the most straightforward way

00:24:35,470 --> 00:24:38,003
to obtain machine passable information.

00:24:40,860 --> 00:24:43,500
But also the Linux Vendor Firmware Service

00:24:45,660 --> 00:24:48,140
has a field where you can provide this information.

00:24:48,140 --> 00:24:51,410
However, as I said, PCR0 itself

00:24:51,410 --> 00:24:53,930
actually contains multiple events,

00:24:53,930 --> 00:24:57,840
and ideally, we want to be able to look at individual events

00:24:57,840 --> 00:24:59,060
rather than just the final event,

00:24:59,060 --> 00:25:03,153
both because it's informative, for instance,

00:25:04,320 --> 00:25:06,920
one of the events is supposed to be the firmware version,

00:25:06,920 --> 00:25:09,930
so having a cryptographically verifiable way of saying,

00:25:09,930 --> 00:25:12,290
OK, this platform is running this version

00:25:12,290 --> 00:25:14,553
of the firmware, is useful,

00:25:17,318 --> 00:25:19,640
you can end up in situations where,

00:25:19,640 --> 00:25:22,160
depending on chip set revision,

00:25:22,160 --> 00:25:24,320
the PCR0 value may be different,

00:25:24,320 --> 00:25:27,060
and if you're able to see all the individual values,

00:25:27,060 --> 00:25:30,253
then you can figure that out and handle it appropriately.

00:25:31,370 --> 00:25:33,920
So knowing the valid values is useful

00:25:33,920 --> 00:25:36,460
as is knowing how to parse information from them.

00:25:36,460 --> 00:25:40,780
HP Workstations, in the BIOS Version field,

00:25:40,780 --> 00:25:42,840
in the event that is supposed to contain

00:25:42,840 --> 00:25:47,440
the firmware version, provides like 180 bytes or so

00:25:47,440 --> 00:25:49,680
of information which includes the firmware version,

00:25:49,680 --> 00:25:52,160
something that looks like a date stamp,

00:25:52,160 --> 00:25:55,363
and then a lot of stuff that is very mysterious.

00:25:57,220 --> 00:26:00,240
No idea whether we can pull any information out of that

00:26:00,240 --> 00:26:02,083
or if we should attempt to.

00:26:04,420 --> 00:26:07,170
So that's been, so far, mostly about validating

00:26:07,170 --> 00:26:10,440
the device state, but device state, while interesting,

00:26:10,440 --> 00:26:12,130
is not the only thing you care about.

00:26:12,130 --> 00:26:14,723
You also care about device identity.

00:26:15,830 --> 00:26:19,360
Two laptops running exactly the same firmware,

00:26:19,360 --> 00:26:21,090
running the same operating system,

00:26:21,090 --> 00:26:23,820
but one belongs to me and one belongs

00:26:23,820 --> 00:26:25,583
to a state-sponsored attacker.

00:26:26,580 --> 00:26:28,810
If they're both trying to access the same resource,

00:26:28,810 --> 00:26:30,490
it's helpful for me to be able to tell

00:26:30,490 --> 00:26:32,790
which of them is the legitimate machine

00:26:32,790 --> 00:26:35,963
and which of them is the malicious machine.

00:26:38,320 --> 00:26:43,320
So every machine has a unique Endorsement Key in the TPM,

00:26:43,750 --> 00:26:46,830
but that doesn't tell you anything about the machine,

00:26:46,830 --> 00:26:48,780
that tells you something about the TPM.

00:26:51,430 --> 00:26:53,240
The trusted computing group have a spec

00:26:53,240 --> 00:26:55,000
for something called a platform certificate,

00:26:55,000 --> 00:26:59,140
and platform certificates bind the Endorsement Key

00:26:59,140 --> 00:27:00,910
to the system.

00:27:00,910 --> 00:27:05,910
So you have a certificate that contains information

00:27:06,450 --> 00:27:09,050
about the Endorsement Key, but also contains for instance,

00:27:09,050 --> 00:27:11,080
the machine's serial number.

00:27:11,080 --> 00:27:13,350
So if you have the platform certificate,

00:27:13,350 --> 00:27:14,730
and if you have the Endorsement Key,

00:27:14,730 --> 00:27:16,810
and we previously talked about how you get

00:27:16,810 --> 00:27:19,070
and verify trust in the Endorsement Key,

00:27:19,070 --> 00:27:20,860
you can then verify that this machine

00:27:20,860 --> 00:27:23,640
is the machine with this serial number,

00:27:23,640 --> 00:27:25,900
and then if you have a decent relationship

00:27:25,900 --> 00:27:30,900
with your system vendor, when you purchase the system,

00:27:30,920 --> 00:27:33,720
they can tell you in advance what serial number

00:27:33,720 --> 00:27:35,320
is going to be shipped to you,

00:27:35,320 --> 00:27:39,550
and then you can pre-trust systems

00:27:39,550 --> 00:27:41,990
as long as they provide a platform certificate

00:27:41,990 --> 00:27:45,380
that has a serial number that corresponds

00:27:45,380 --> 00:27:47,403
to the presented Endorsement Key.

00:27:48,760 --> 00:27:50,200
Right now there's not particularly good

00:27:50,200 --> 00:27:51,610
ecosystem support for this.

00:27:51,610 --> 00:27:56,480
There are, Intel have some amount of tooling

00:27:56,480 --> 00:27:59,270
to provide this information, but it's not

00:27:59,270 --> 00:28:03,770
really as yet as picked up by the majority of PC vendors.

00:28:03,770 --> 00:28:07,223
The other problem is that the platform certificate is,

00:28:08,720 --> 00:28:12,060
not an X.509 PKI certificate

00:28:12,060 --> 00:28:14,450
of the sort that you're sort of generally used to,

00:28:14,450 --> 00:28:16,620
it's something called an attribute certificate,

00:28:16,620 --> 00:28:20,423
and almost no tooling supports this at all.

00:28:22,090 --> 00:28:25,910
The only widespread crypto library

00:28:25,910 --> 00:28:28,380
that is able to support this is Bouncy Castle,

00:28:28,380 --> 00:28:30,843
which then ties you into the Java ecosystem.

00:28:32,010 --> 00:28:34,173
OpenSSL cannot parse these things.

00:28:37,540 --> 00:28:39,020
Once you've got strong device identity,

00:28:39,020 --> 00:28:44,020
you can do stuff like, trust a system

00:28:44,490 --> 00:28:48,010
based on OK, we can cryptographically verify

00:28:48,010 --> 00:28:50,060
that this machine has this serial number,

00:28:50,060 --> 00:28:53,470
and as long as the vendor isn't shipping multiple systems

00:28:53,470 --> 00:28:54,870
with the same serial number,

00:28:57,160 --> 00:28:58,820
we know that any machine that's able

00:28:58,820 --> 00:29:02,600
to cryptographically prove that it has this serial number

00:29:02,600 --> 00:29:06,380
is the machine that we ordered that had that serial number.

00:29:06,380 --> 00:29:08,990
So right now, you buy a new server,

00:29:08,990 --> 00:29:12,513
and you want to put some secret material on it.

00:29:13,800 --> 00:29:16,280
How do you do that, how you do bootstrap that?

00:29:16,280 --> 00:29:21,220
So you can send it to a data center

00:29:21,220 --> 00:29:24,300
and then someone that you trust can rack it,

00:29:24,300 --> 00:29:25,950
logon, prove their identity,

00:29:25,950 --> 00:29:27,810
and then install the secret information.

00:29:27,810 --> 00:29:29,210
You can get it shipped to your office,

00:29:29,210 --> 00:29:30,680
and you can put the secret material on there

00:29:30,680 --> 00:29:32,120
and then ship it to the data center.

00:29:32,120 --> 00:29:34,020
But in that case, anyone who intercepts it

00:29:34,020 --> 00:29:36,720
is going to be able to obtain that secret information.

00:29:37,690 --> 00:29:42,690
If you're able to trust device identity well,

00:29:43,230 --> 00:29:46,180
then you can just have the manufacturer

00:29:46,180 --> 00:29:48,570
ship that system straight to the data center,

00:29:48,570 --> 00:29:52,170
you can have an arbitrary untrusted person rack it,

00:29:52,170 --> 00:29:55,000
and then the machine can netboot,

00:29:55,000 --> 00:29:57,100
perform remote attestation, you can verify

00:29:57,100 --> 00:29:59,200
the machine's identity, you can verify

00:29:59,200 --> 00:30:01,540
that it booted the operating system you expected

00:30:01,540 --> 00:30:03,220
with the firmware you expected,

00:30:03,220 --> 00:30:07,610
and then you can, well OK, this is a trustworthy machine

00:30:07,610 --> 00:30:10,020
in a trustworthy state, I can provision it

00:30:10,020 --> 00:30:11,300
with secret information.

00:30:11,300 --> 00:30:14,050
And you don't need anybody locally with the machine

00:30:14,050 --> 00:30:16,940
to generate that trust.

00:30:16,940 --> 00:30:20,200
(background talking)

00:30:20,200 --> 00:30:22,379
Do you want the microphone.

00:30:22,379 --> 00:30:25,462
(background talking)

00:30:28,377 --> 00:30:30,220
- You got a missing step in your trust

00:30:30,220 --> 00:30:34,980
because you can't trust the Endorsement Key Certificate

00:30:34,980 --> 00:30:36,900
to attest to the serial number

00:30:36,900 --> 00:30:39,200
because I could go out and buy a TPM

00:30:39,200 --> 00:30:41,503
at the same manufacturer and use that

00:30:41,503 --> 00:30:44,520
to fake a serial number and entire log.

00:30:44,520 --> 00:30:47,100
- The platform certificate's not issued by the,

00:30:47,100 --> 00:30:50,380
- Right, so do you have to do this really complicated.

00:30:50,380 --> 00:30:52,370
- Yeah, so the generating the trust

00:30:52,370 --> 00:30:53,860
in the Endorsement Key is not just

00:30:53,860 --> 00:30:55,003
looking at the Endorsement Certificate,

00:30:55,003 --> 00:30:57,830
that only gets you back to the TPM vendor,

00:30:57,830 --> 00:31:00,850
so you need instead to look at the combination

00:31:00,850 --> 00:31:02,900
of the Endorsement Key and the platform certificate

00:31:02,900 --> 00:31:07,900
in order to verify the device identity

00:31:08,330 --> 00:31:10,067
as opposed to the TPM identity.

00:31:14,350 --> 00:31:18,350
So this also opens up some other fun possibilities,

00:31:18,350 --> 00:31:21,570
for instance, if a machine is able to,

00:31:21,570 --> 00:31:24,260
if you can generate proof that a machine

00:31:24,260 --> 00:31:25,910
is the machine you expected it to be,

00:31:25,910 --> 00:31:29,040
you can then issue the machine with another certificate

00:31:29,040 --> 00:31:34,040
that allows you to bind a machine's TPM identity

00:31:34,240 --> 00:31:36,240
to its internet identity.

00:31:36,240 --> 00:31:38,250
So you can issue a certificate that includes

00:31:38,250 --> 00:31:39,350
the machine host name,

00:31:40,750 --> 00:31:43,670
and tie the host name to the Endorsement Key.

00:31:43,670 --> 00:31:46,330
And then you can trust that machine

00:31:46,330 --> 00:31:48,390
to generate proof of its own identity

00:31:48,390 --> 00:31:50,070
for arbitrary services.

00:31:50,070 --> 00:31:52,870
And so an example here is that you could generate

00:31:52,870 --> 00:31:55,473
the SSH host key on the TPM,

00:31:56,440 --> 00:31:59,660
and then have the machine have a certificate

00:31:59,660 --> 00:32:01,110
that allows it to demonstrate,

00:32:01,110 --> 00:32:04,630
right, this SSH host key chains back

00:32:04,630 --> 00:32:08,410
to a TPM that is associated with this host name,

00:32:08,410 --> 00:32:11,940
and then trust on first use and SSH goes away.

00:32:11,940 --> 00:32:14,560
This is somewhat annoying to actually implement

00:32:14,560 --> 00:32:17,570
because the SSH protocol doesn't let you do this

00:32:17,570 --> 00:32:21,030
in terms of its certificate validation,

00:32:21,030 --> 00:32:23,793
so we need to extend SSH a little to do this but,

00:32:26,050 --> 00:32:28,603
that's just mostly typing.

00:32:31,040 --> 00:32:33,670
And in the Linux world, so in the past few years

00:32:33,670 --> 00:32:36,460
we've gone from a situation where basically,

00:32:36,460 --> 00:32:39,880
the firmware was the only thing generating TPM measurements

00:32:39,880 --> 00:32:42,873
and events to the majority of the boot chain doing so.

00:32:43,840 --> 00:32:46,550
I mentioned PCR7 and Secure Boot stuff,

00:32:46,550 --> 00:32:49,670
so one of the problems with that was that,

00:32:49,670 --> 00:32:53,910
when you use Shim to bridge between the Microsoft

00:32:53,910 --> 00:32:55,960
Secure Boot rooted trust and the individual

00:32:55,960 --> 00:32:59,650
distribution rooted trust, that information vanished,

00:32:59,650 --> 00:33:01,623
and so it was not possible to verify

00:33:01,623 --> 00:33:03,500
what in the system was booting

00:33:03,500 --> 00:33:06,200
with the distribution certificate

00:33:06,200 --> 00:33:10,180
or booting with a certificate that the end user

00:33:10,180 --> 00:33:11,560
had installed.

00:33:11,560 --> 00:33:14,360
So Shim now measures the certificates

00:33:14,360 --> 00:33:17,380
that it actually ends up using into PCR7 as well,

00:33:17,380 --> 00:33:21,690
so the final PCR7 values now give you information

00:33:21,690 --> 00:33:24,210
about the entire certificate chain,

00:33:24,210 --> 00:33:27,513
not just the initial component thereof.

00:33:30,060 --> 00:33:34,070
Latest Grub code will also measure the kernel,

00:33:34,070 --> 00:33:37,130
the initramfs, the kernel command line,

00:33:37,130 --> 00:33:42,110
and if you want, every single command that Grub executes,

00:33:42,110 --> 00:33:47,110
so you can get a lot of information about the boot process.

00:33:48,970 --> 00:33:51,940
The event log is exported via this

00:33:51,940 --> 00:33:54,203
very easy to remember path.

00:33:56,400 --> 00:34:00,570
TPM 2.0 devices that are using the TCG 2

00:34:00,570 --> 00:34:04,630
crypto agile log format, that will only appear

00:34:04,630 --> 00:34:07,253
on 5.3 or later, so,

00:34:08,580 --> 00:34:09,550
because,

00:34:09,550 --> 00:34:11,360
(background talking)

00:34:11,360 --> 00:34:12,193
right.

00:34:13,930 --> 00:34:16,213
Once the kernel has booted, then,

00:34:18,860 --> 00:34:19,880
we basically handoff

00:34:19,880 --> 00:34:22,570
to the Integrity Measurement Architecture, or IMA,

00:34:22,570 --> 00:34:24,810
which is then responsible for,

00:34:24,810 --> 00:34:27,360
based on a policy that was given to it,

00:34:27,360 --> 00:34:31,640
measuring any applications or sensitive files

00:34:31,640 --> 00:34:33,090
that are accessed at runtime.

00:34:36,090 --> 00:34:40,310
So right now we're still sort of lacking PCR0 values

00:34:40,310 --> 00:34:42,370
from vendors, but the other thing we're missing

00:34:42,370 --> 00:34:44,880
is that distributions are not giving us

00:34:44,880 --> 00:34:48,380
the expected PCR values for things like their bootloaders

00:34:48,380 --> 00:34:49,343
or their kernels.

00:34:51,870 --> 00:34:53,683
Are you, do you publish that now?

00:34:56,020 --> 00:34:56,880
Soon?

00:34:56,880 --> 00:35:00,190
Great, Fetora will do that soon apparently.

00:35:00,190 --> 00:35:04,040
(background talking)

00:35:04,040 --> 00:35:06,210
So I think talking about this in the sense of,

00:35:06,210 --> 00:35:07,160
well, this sounds like something

00:35:07,160 --> 00:35:10,020
where you need a big corporate-level

00:35:10,020 --> 00:35:12,740
amount of infrastructure, but that's not strictly true.

00:35:12,740 --> 00:35:15,053
Remote attestation doesn't need to be particularly remote,

00:35:15,053 --> 00:35:17,560
all you need is a communications channel

00:35:17,560 --> 00:35:20,950
to a trusted device and some way to indicate

00:35:20,950 --> 00:35:23,090
success or failure.

00:35:23,090 --> 00:35:27,470
So, because imagine a small device

00:35:27,470 --> 00:35:29,560
that you plug into a USB port,

00:35:29,560 --> 00:35:33,653
that during boot, you tap it and then it,

00:35:34,820 --> 00:35:37,910
through some software agent running on the operating system,

00:35:37,910 --> 00:35:41,120
ends up verifying the TPM state,

00:35:41,120 --> 00:35:44,180
and then tells you via a blinking LED

00:35:44,180 --> 00:35:46,320
whether the state is expected or not.

00:35:46,320 --> 00:35:49,880
So we can go that simple, but we could also imagine

00:35:49,880 --> 00:35:51,180
using Bluetooth to communicate

00:35:51,180 --> 00:35:53,030
between a phone and a laptop,

00:35:53,030 --> 00:35:55,450
and then the phone being able to connect

00:35:55,450 --> 00:36:00,450
to the vendor's site, to the distribution site,

00:36:00,640 --> 00:36:03,870
and then pull down the expected values

00:36:03,870 --> 00:36:05,630
and check whether what you booted

00:36:05,630 --> 00:36:07,810
matches the expected values and tell you

00:36:07,810 --> 00:36:10,760
whether your system is running in an expected state or not.

00:36:12,390 --> 00:36:16,700
In terms of implementations, HIRS, H-I-R-S,

00:36:16,700 --> 00:36:18,550
is the most complete implementation,

00:36:18,550 --> 00:36:23,530
but it's also run by the U.S. government,

00:36:23,530 --> 00:36:26,110
and is therefore immensely complicated

00:36:26,110 --> 00:36:27,260
and large and unwieldy.

00:36:28,840 --> 00:36:32,560
Keylime has a very nice website,

00:36:32,560 --> 00:36:35,830
but is also the thing that's probably

00:36:35,830 --> 00:36:37,820
the easiest to deploy at the moment.

00:36:37,820 --> 00:36:42,150
In terms of implementation, it's a set of Python

00:36:42,150 --> 00:36:44,040
that wraps various C binaries,

00:36:44,040 --> 00:36:49,040
so it's not a particularly elegant implementation,

00:36:50,020 --> 00:36:52,593
it does however work and exists now.

00:36:54,830 --> 00:36:56,710
The team I'm on has been working on

00:36:56,710 --> 00:37:00,480
a complete implementation of all of this in Go,

00:37:00,480 --> 00:37:02,130
we're running this internally,

00:37:02,130 --> 00:37:05,770
we now have something like 30,000 machines

00:37:05,770 --> 00:37:08,233
performing remote attestation on a daily basis,

00:37:09,640 --> 00:37:12,150
which is using this code.

00:37:12,150 --> 00:37:15,380
Now this does not include the Python server we're using

00:37:15,380 --> 00:37:17,840
'cause they're very heavily tied into our infrastructure,

00:37:17,840 --> 00:37:19,730
and just don't work elsewhere,

00:37:19,730 --> 00:37:22,520
but there is a sample client and a sample server

00:37:22,520 --> 00:37:24,748
implemented as part of that.

00:37:24,748 --> 00:37:27,831
(background talking)

00:37:31,190 --> 00:37:32,023
- [Male] Do they implement

00:37:32,023 --> 00:37:33,230
the same wire protocol as Keylime?

00:37:33,230 --> 00:37:34,063
- No.

00:37:35,897 --> 00:37:40,700
They could do, this is largely just the implementations,

00:37:40,700 --> 00:37:42,900
if you want to wrap the information you get

00:37:42,900 --> 00:37:45,403
into a specific wire protocol, yeah, go for it.

00:37:46,810 --> 00:37:49,106
Anyway, so

00:37:49,106 --> 00:37:51,840
(background talking)

00:37:51,840 --> 00:37:55,343
Go-attestation implements both ends,

00:37:56,240 --> 00:38:01,240
it has the code for performing key certification,

00:38:01,820 --> 00:38:04,477
generating a quote, and generating

00:38:04,477 --> 00:38:08,170
the Attestation Keys, and then the server cipher

00:38:08,170 --> 00:38:09,820
validates in all of that stuff.

00:38:09,820 --> 00:38:12,240
Right now, it will tell you whether your event log is valid,

00:38:12,240 --> 00:38:14,210
but it won't give you the metadata

00:38:14,210 --> 00:38:17,360
from the individual events, that code's written,

00:38:17,360 --> 00:38:20,623
but we're trying to figure out the right API to expose.

00:38:21,540 --> 00:38:23,460
So it'll be granting shortly.

00:38:23,460 --> 00:38:27,000
In terms of stuff to do, making this all work really well

00:38:27,000 --> 00:38:30,210
involves platform certificates being basically ubiquitous,

00:38:30,210 --> 00:38:32,490
and we're a long way from being there yet.

00:38:32,490 --> 00:38:36,370
System vendors, we want to get PCR0 values,

00:38:36,370 --> 00:38:38,110
device vendors, it would be really nice

00:38:38,110 --> 00:38:41,470
to know whether a specific driver hash value

00:38:41,470 --> 00:38:43,480
corresponds to something that was actually issued

00:38:43,480 --> 00:38:47,223
by a specific GPU manufacturer, for instance.

00:38:49,110 --> 00:38:51,830
OS vendors, we love to have, or the boot components,

00:38:51,830 --> 00:38:54,700
it sound like Fetora's going to be doing that soon.

00:38:54,700 --> 00:38:56,750
General agreement on what material

00:38:56,750 --> 00:38:57,790
should be measured and when,

00:38:57,790 --> 00:39:01,070
how much additional metadata should we be generating

00:39:01,070 --> 00:39:02,323
during the boot process, is there any more

00:39:02,323 --> 00:39:04,070
that we need to be?

00:39:04,070 --> 00:39:07,300
And then ideally also, validation,

00:39:07,300 --> 00:39:08,870
infrastructure for validating the firmware

00:39:08,870 --> 00:39:10,920
actually behaves the correct way.

00:39:10,920 --> 00:39:13,420
There have been cases where you can reboot firmware

00:39:13,420 --> 00:39:16,160
and it'll do something like accidentally measure

00:39:17,300 --> 00:39:20,320
the time of day, which then means that the measurement

00:39:20,320 --> 00:39:22,680
will vary every time.

00:39:22,680 --> 00:39:24,970
So that's bad, we would like it to be possible

00:39:24,970 --> 00:39:26,880
to know that that's not going to happen.

00:39:26,880 --> 00:39:28,560
So I think we've got about two minutes for questions

00:39:28,560 --> 00:39:30,963
before I have to get out of the way for the next speaker.

00:39:34,770 --> 00:39:37,710
- So you say measuring the time would be bad

00:39:37,710 --> 00:39:39,090
in agreement on what should be measured

00:39:39,090 --> 00:39:40,950
as long as it's measured in a way

00:39:40,950 --> 00:39:43,720
that it is its own independent measurement

00:39:43,720 --> 00:39:45,350
that you can read in the log,

00:39:45,350 --> 00:39:48,410
at some level that doesn't really matter, right?

00:39:48,410 --> 00:39:50,650
- Yup, there's no problem with measuring something

00:39:50,650 --> 00:39:53,170
as long as it's put in a defined place

00:39:53,170 --> 00:39:55,520
in a defined structure with defined semantics.

00:39:55,520 --> 00:39:57,110
The time's not actually particularly useful

00:39:57,110 --> 00:39:59,380
because the clock could just lie to you.

00:39:59,380 --> 00:40:01,209
- [Male] I agree it's not useful.

00:40:01,209 --> 00:40:02,256
(background talking)

00:40:02,256 --> 00:40:03,089
- That's got a bad idea to put it in ZL

00:40:03,089 --> 00:40:04,510
because you're statement's true,

00:40:04,510 --> 00:40:05,820
but only true if you could actually do it

00:40:05,820 --> 00:40:07,143
for everything in the log.

00:40:08,850 --> 00:40:11,770
- And there's also a facility where we seal

00:40:11,770 --> 00:40:14,670
certain data PCR values, we can't have them

00:40:14,670 --> 00:40:17,260
changing every boot and do that sealing.

00:40:17,260 --> 00:40:18,220
- [Male] Sure that's true,

00:40:18,220 --> 00:40:20,030
but from an attestation perspective,

00:40:20,030 --> 00:40:21,427
you care about the facility.

00:40:21,427 --> 00:40:23,350
- Right from attestation, if you're going to measure

00:40:23,350 --> 00:40:24,510
dynamic data, that should probably

00:40:24,510 --> 00:40:27,143
go into a different PCR from all the static data.

00:40:28,420 --> 00:40:29,420
Any other questions?

00:40:36,034 --> 00:40:37,853
- I'm a little skeptical about all of this,

00:40:37,853 --> 00:40:40,460
for one simple reason that it relies

00:40:40,460 --> 00:40:44,177
on all the signing machinery to be more or less bug-free,

00:40:44,177 --> 00:40:46,240
and we know how common bug-free software is,

00:40:46,240 --> 00:40:51,070
and secondly, it rely on the TPM's various private sides

00:40:51,070 --> 00:40:52,720
its various keys not leaking,

00:40:52,720 --> 00:40:55,350
and SGX had machinery to do remote attestation,

00:40:55,350 --> 00:40:57,840
and it's leaked twice because of side-channel attacks,

00:40:57,840 --> 00:41:00,458
what's to stop something similar happening here?

00:41:00,458 --> 00:41:03,541
(background talking)

00:41:06,660 --> 00:41:08,730
- Side-channel attacks work if you've got

00:41:08,730 --> 00:41:10,040
a high-bandwidth side-channel,

00:41:10,040 --> 00:41:11,880
which is why SGX was attacked.

00:41:11,880 --> 00:41:14,690
But TPM sits on a very low-bandwidth bus.

00:41:14,690 --> 00:41:16,650
This isn't a deliberate defense mechanism,

00:41:16,650 --> 00:41:18,650
it's just a cost thing, but that makes it

00:41:18,650 --> 00:41:20,620
very difficult to get side-channels into,

00:41:20,620 --> 00:41:22,450
it's not impossible, but it's very difficult

00:41:22,450 --> 00:41:24,271
to get side-channels in.

00:41:24,271 --> 00:41:27,503
(background talking)

00:41:27,503 --> 00:41:30,410
- Even Management Engine TPMs that run in firmware

00:41:30,410 --> 00:41:33,210
instead of, a physical TPM is difficult

00:41:33,210 --> 00:41:34,800
to get out through side-channels.

00:41:34,800 --> 00:41:37,120
- It's not necessarily impossible,

00:41:37,120 --> 00:41:40,650
but on the other hand, there's no key material

00:41:40,650 --> 00:41:42,600
that's shared across multiple TPMs,

00:41:42,600 --> 00:41:44,890
attacking a single TPM only gets you

00:41:44,890 --> 00:41:47,280
the key material for that specific TPM.

00:41:47,280 --> 00:41:50,650
So if you're going to want to fake the results

00:41:50,650 --> 00:41:53,740
of a given machine, you're going to need access

00:41:53,740 --> 00:41:55,170
to that machine with enough time

00:41:55,170 --> 00:41:56,520
to extract key material from it,

00:41:56,520 --> 00:41:58,420
and then after that you can duplicate that machine,

00:41:58,420 --> 00:41:59,760
but only that machine.

00:41:59,760 --> 00:42:04,139
So it would have to be a very targeted attack.

00:42:04,139 --> 00:42:07,889
(background talking)

00:42:07,889 --> 00:42:10,306
Yeah, I think, last question.

00:42:13,833 --> 00:42:17,010
- I just wanted to say thanks for the fix in my laptop

00:42:17,010 --> 00:42:18,230
way back when, but (laughs)

00:42:18,230 --> 00:42:19,599
- Oh, you're welcome.

00:42:19,599 --> 00:42:20,620
(laughs)

00:42:20,620 --> 00:42:23,373
- On a more related note, (laughs)

00:42:24,420 --> 00:42:25,570
on a more related note,

00:42:27,270 --> 00:42:31,800
how far do we need to go in providing material,

00:42:31,800 --> 00:42:34,440
does it have to be like the case that,

00:42:34,440 --> 00:42:35,900
if you got hardware in your machine,

00:42:35,900 --> 00:42:39,810
that also needs to be somehow logging firmware versions

00:42:39,810 --> 00:42:41,908
into these logs as well, or?

00:42:41,908 --> 00:42:43,300
- Yeah, that's a great question.

00:42:43,300 --> 00:42:45,220
So what we see at the moment is that,

00:42:45,220 --> 00:42:47,780
in terms of the boot environment,

00:42:47,780 --> 00:42:50,490
any Option ROMs that are on plugin cards

00:42:50,490 --> 00:42:55,490
will be measured into PCR2 and that will generally include

00:42:55,530 --> 00:42:57,993
any additional,

00:42:59,850 --> 00:43:02,010
metadata and firmware.

00:43:02,010 --> 00:43:04,120
Once we're later into the boot process,

00:43:04,120 --> 00:43:06,300
that's then up to the operating system to set

00:43:06,300 --> 00:43:08,500
and to find a policy, so we can either

00:43:08,500 --> 00:43:10,340
do that via measurement or we can basically

00:43:10,340 --> 00:43:12,450
do that by just asserting that well,

00:43:12,450 --> 00:43:15,170
the operating system or the hardware

00:43:15,170 --> 00:43:17,663
will not load anything that isn't appropriately signed.

00:43:20,330 --> 00:43:22,870
- One question, back to that TPM event log.

00:43:22,870 --> 00:43:27,870
So as I understand correctly, if you talk directly

00:43:28,130 --> 00:43:32,590
via a PC to that TPM, then the TPM event log

00:43:32,590 --> 00:43:35,300
is not created, right?

00:43:35,300 --> 00:43:37,133
- The firmware, you need to,

00:43:38,740 --> 00:43:40,270
if you're going to extend the event log,

00:43:40,270 --> 00:43:42,490
then you need to be using functionality

00:43:42,490 --> 00:43:44,330
that knows how to extend the event log.

00:43:44,330 --> 00:43:47,500
So if you drive the firmware directly behind the,

00:43:47,500 --> 00:43:48,333
if you drive the TPM directly behind

00:43:48,333 --> 00:43:52,170
the firmware's back, then unless you yourself

00:43:52,170 --> 00:43:54,640
extend the event log, then the event log won't be extended.

00:43:54,640 --> 00:43:56,820
It's basically, the thing that is directly

00:43:56,820 --> 00:43:58,570
talking to the TPM has to take responsibility

00:43:58,570 --> 00:44:00,020
for managing the event log.

00:44:00,020 --> 00:44:03,568
- [Male] OK, makes sense, thank you, thank you.

00:44:03,568 --> 00:44:05,050
- Thank you.

00:44:05,050 --> 00:44:06,100
- Thank you very much.

00:44:06,100 --> 00:44:08,350

YouTube URL: https://www.youtube.com/watch?v=c-e7dm2aGBg


