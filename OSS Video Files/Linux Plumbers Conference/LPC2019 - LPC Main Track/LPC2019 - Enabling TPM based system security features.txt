Title: LPC2019 - Enabling TPM based system security features
Publication date: 2019-11-18
Playlist: LPC2019 - LPC Main Track
Description: 
	Enabling TPM based system security features

Speaker
Mr Andreas Fuchs (Fraunhofer SIT)

Description
Nowadays all consumer PC/laptop devices contain TPM2.0 security chip (due to Windows hardware requirements). Also servers and embedded devices increasingly carry these TPMs. It provides several security functions to the system and the user, such as smartcard-like secure keystore and key operations, secure secret storage, bruteforce-protected access control, etc.

These capabilities can be used in a multitude of scenarios and use cases, including disk encryption, device authentication, user authentication, network authentication, etc. of desktops/laptops, servers, IoTs, mobiles, etc.
Utilizing the TPM requires several layers of software; the driver (inside the kernel), tpm middleware (a TSS implementation), security middleware (e.g. pkcs11), applications (e.g. ssh).

This talk first gives an architectural overview of the hard-/software components involved in typical use cases. Then we will dive into a set of concrete use cases and on different ways in which they can be built up; these use cases will be related to device/user authentication around pkcs11 and openssl implementations.

The talk will end with a list of software and works in progress for introducing TPM functionality to core applications. Finally, a list of potential projects for extending the utilization of the TPM in core software is presented. This latter list shall then drive the discussion on which software is missing or which software has cotributors attending that would like to include such features or which software is currently missing on the list. The current lists of core software are available and updated at https://tpm2-software.github.io/software

Keywords: core libraries, device support, security, tpm, tss
Captions: 
	00:00:00,110 --> 00:00:03,160
- Hi everyone, so let me get started by who I am,

00:00:03,160 --> 00:00:05,090
because this is my first LPC.

00:00:05,090 --> 00:00:08,740
And I dunno, I guess only those who went to Foston

00:00:08,740 --> 00:00:10,380
may know me, or not.

00:00:10,380 --> 00:00:13,780
I've working on TPMs on and off for like 13 years now,

00:00:13,780 --> 00:00:16,363
which is kind of a long time I guess.

00:00:17,260 --> 00:00:20,670
And actually the working on TPM 1.2 and the TSS 1.2

00:00:20,670 --> 00:00:23,937
was what got this whole interest of mine in the TSS,

00:00:23,937 --> 00:00:26,770
and the new API for TPM2 started.

00:00:26,770 --> 00:00:30,670
So yeah, other than that I worked for Fraunhofer SIT,

00:00:30,670 --> 00:00:32,310
working on trustworthy platforms.

00:00:32,310 --> 00:00:35,720
I'm also a TCG member, so I'm specifying

00:00:35,720 --> 00:00:38,960
this whole API stuff in the working group there.

00:00:38,960 --> 00:00:42,190
And I'm the maintainer of the TPM2 TSS,

00:00:42,190 --> 00:00:45,440
which is the core library that TPM2 TSS engine,

00:00:45,440 --> 00:00:49,860
and TPM2 TOTP, which is a port of what Matthew Garreg

00:00:49,860 --> 00:00:54,520
introduced three or four years ago over to TPM 2.0.

00:00:54,520 --> 00:00:56,863
If any of you ever notice that thing.

00:00:57,887 --> 00:01:00,980
But let's take a slower start.

00:01:00,980 --> 00:01:02,750
So what I will actually talking about,

00:01:02,750 --> 00:01:04,510
we're talking in terms of hardware.

00:01:04,510 --> 00:01:09,230
So there is this TPM trusted platform module,

00:01:09,230 --> 00:01:14,230
which is a Smartcard-like thing on your laptops,

00:01:14,350 --> 00:01:16,963
on your desktops, on your I don't know what.

00:01:18,100 --> 00:01:21,000
And it has a lot of Smartcard-like capabilities,

00:01:21,000 --> 00:01:23,760
in terms of using and storing keys,

00:01:23,760 --> 00:01:27,790
and being a secure environment for you to handle your keys.

00:01:27,790 --> 00:01:31,130
It also has these remote attestation capabilities

00:01:31,130 --> 00:01:33,220
that Matthew talked about yesterday

00:01:33,220 --> 00:01:37,440
that actually I'm not gonna touch at all in this talk,

00:01:37,440 --> 00:01:40,610
because I wanna go for the low-hanging fruits,

00:01:40,610 --> 00:01:42,770
the stuff that's easily usable

00:01:42,770 --> 00:01:44,370
without too much infrastructure.

00:01:45,540 --> 00:01:48,980
TPMs, there's a lot of misconceptions, as there always is.

00:01:48,980 --> 00:01:52,000
So TPMs oftentimes come as a separate chip,

00:01:52,000 --> 00:01:56,210
which I don't know about some of the hardware TPM vendors,

00:01:56,210 --> 00:01:58,360
which either connected via LPC,

00:01:58,360 --> 00:02:01,500
which was mostly from the 1.2 days.

00:02:01,500 --> 00:02:05,290
Nowadays you mostly have SPI connected chips,

00:02:05,290 --> 00:02:08,550
or there's also specification for I square C-connected chips

00:02:08,550 --> 00:02:11,823
for the embedded area, where you don't have enough SPI left.

00:02:13,490 --> 00:02:15,790
On some platforms it's implemented in firmware,

00:02:15,790 --> 00:02:18,330
in what I still refer to as the Southbridge,

00:02:18,330 --> 00:02:20,100
I don't know what you call it nowadays.

00:02:20,100 --> 00:02:21,600
But it's like the other thing.

00:02:25,380 --> 00:02:27,830
You have implementations in TEEs,

00:02:27,830 --> 00:02:30,574
AKA TrustZone or whatever.

00:02:30,574 --> 00:02:35,490
On some mobile devices there exists or existed versions

00:02:35,490 --> 00:02:38,010
of TPMs that people put in there.

00:02:38,010 --> 00:02:41,470
And thanks to Microsoft and thanks to Windows Logo program,

00:02:41,470 --> 00:02:44,350
we have them in every PC nowadays.

00:02:44,350 --> 00:02:47,280
So it's just there, it's sitting there,

00:02:47,280 --> 00:02:49,253
and we should make use of it.

00:02:50,240 --> 00:02:53,670
Now besides the TPM itself, there's of course the CPU,

00:02:53,670 --> 00:02:56,640
where the OS lives, where the TSS lives,

00:02:56,640 --> 00:03:00,220
and where all the fun is, at least as much as I'm concerned,

00:03:00,220 --> 00:03:02,963
because I don't implement TPMs, thankfully.

00:03:03,950 --> 00:03:07,120
So what is the TPM software stack?

00:03:07,120 --> 00:03:09,180
So the kernel has a driver for TPM,

00:03:09,180 --> 00:03:11,490
it has had one for a very long time.

00:03:11,490 --> 00:03:14,920
And the kernel exposes dev/tpm0,

00:03:14,920 --> 00:03:17,140
or nowadays dev/tpmrm0.

00:03:17,140 --> 00:03:19,170
But the thing that you can do with this device

00:03:19,170 --> 00:03:21,230
is you can send a byte buffer,

00:03:21,230 --> 00:03:23,030
and you get back a byte buffer.

00:03:23,030 --> 00:03:26,300
It's martial data of TPM commands and TPM responses,

00:03:26,300 --> 00:03:29,730
and while you have to interpret them yourselves,

00:03:29,730 --> 00:03:33,380
unless of course you use something like a TSS.

00:03:33,380 --> 00:03:36,270
So you can think of the open source implementation

00:03:36,270 --> 00:03:39,850
of the TSS as something like the meesa, or mesa,

00:03:39,850 --> 00:03:43,200
I don't know how you pronounce it, for TCG specifications.

00:03:43,200 --> 00:03:46,520
If you think of OpenGL, the TCG specifications,

00:03:46,520 --> 00:03:49,440
the TPM defines the functionality for the hardware,

00:03:49,440 --> 00:03:53,470
the TSS defines the software API for this functionality.

00:03:53,470 --> 00:03:58,060
And then the TPM2 TSS project and its libraries

00:03:58,060 --> 00:03:59,820
implement the glue code.

00:03:59,820 --> 00:04:04,820
So the equivalence to an OpenGL support in GDK,

00:04:06,320 --> 00:04:09,030
godot or wayland would be, we put stuff into OpenSSL,

00:04:09,030 --> 00:04:12,023
we put stuff into pkcs11, we put stuff into cryptsetup.

00:04:14,200 --> 00:04:17,670
So this is why it's like one of the core things

00:04:17,670 --> 00:04:20,053
or core security features that you wanna get.

00:04:20,903 --> 00:04:25,030
So this is the stack more graphically this time.

00:04:25,030 --> 00:04:27,290
As I already mentioned, at the bottom

00:04:27,290 --> 00:04:29,450
we have the device driver.

00:04:29,450 --> 00:04:32,710
We have resource managers, there's one living in the kernel,

00:04:32,710 --> 00:04:37,170
there's one living in another project for user space,

00:04:37,170 --> 00:04:39,653
which has a few more capabilities.

00:04:40,880 --> 00:04:44,500
Then there is the TCTI, which is an abstraction layer

00:04:44,500 --> 00:04:46,360
for interprocess communication.

00:04:46,360 --> 00:04:48,660
And so the idea here is that at runtime

00:04:48,660 --> 00:04:52,770
you can choose whether you wanna talk to the TPM,

00:04:52,770 --> 00:04:54,660
either via the resource manager

00:04:54,660 --> 00:04:56,760
if you're on a fully loaded operating system,

00:04:56,760 --> 00:04:59,270
or if you're still in RD, you can run the same tool

00:04:59,270 --> 00:05:02,060
and just at runtime choose a different TCTI module

00:05:02,060 --> 00:05:04,540
in order to talk to dev/tpm0.

00:05:04,540 --> 00:05:06,950
Or you can have a very different TCTI module

00:05:06,950 --> 00:05:08,580
that talks to a simulator.

00:05:08,580 --> 00:05:10,670
So it's all interchangeable at runtime,

00:05:10,670 --> 00:05:13,720
that's the only purpose that you need to memorize

00:05:13,720 --> 00:05:15,750
for what the TCTI is.

00:05:15,750 --> 00:05:18,790
And recently we gained a library

00:05:18,790 --> 00:05:21,713
that makes loading those much easier, thanks to Phil.

00:05:23,140 --> 00:05:27,550
The three main APIs that you're might be using,

00:05:27,550 --> 00:05:30,400
or hopefully will be using would be the system API,

00:05:30,400 --> 00:05:34,680
the enhanced system API, and what we call the feature API.

00:05:34,680 --> 00:05:36,960
And I'm sorry for the horrible naming,

00:05:36,960 --> 00:05:40,483
but that's spec working, and specification groups.

00:05:41,330 --> 00:05:44,550
So the system API is something that's very, very low level.

00:05:44,550 --> 00:05:47,210
Gives you full control and has basically no requirements

00:05:47,210 --> 00:05:50,861
against any backing libraries,

00:05:50,861 --> 00:05:54,270
or not even in memory allocation mechanism,

00:05:54,270 --> 00:05:57,440
it's completely caller allocated.

00:05:57,440 --> 00:05:58,840
So that's something you wanna use

00:05:58,840 --> 00:06:01,890
if you're on UEVI, or if you're on the writing firmware

00:06:01,890 --> 00:06:04,050
for very, very small microcontroller.

00:06:04,050 --> 00:06:05,240
But other than that you probably

00:06:05,240 --> 00:06:08,110
don't want to concern yourself with that API.

00:06:08,110 --> 00:06:10,340
The other two ones are much more interesting.

00:06:10,340 --> 00:06:15,340
So the esys API gives you a nice interface

00:06:15,640 --> 00:06:18,923
for one-to-one mapping to TPM commands.

00:06:20,130 --> 00:06:21,520
And in the background for you

00:06:21,520 --> 00:06:23,280
it does a lot of the session handling.

00:06:23,280 --> 00:06:24,900
So when you talk to a TPM,

00:06:24,900 --> 00:06:27,830
you have cryptographic sessions that enable you

00:06:27,830 --> 00:06:30,550
to do HMAC-based authentication

00:06:30,550 --> 00:06:32,810
instead of sending your passwords on the plane,

00:06:32,810 --> 00:06:37,130
or to do parameter encryption between the CPU and the TPM,

00:06:37,130 --> 00:06:39,270
or even over network connection.

00:06:39,270 --> 00:06:42,350
So this is all done, all this metadata handling is done

00:06:42,350 --> 00:06:43,490
by the esys.

00:06:47,520 --> 00:06:51,150
So coming up very soon hopefully there is the feature API.

00:06:51,150 --> 00:06:53,360
There's also been a spec in draft form,

00:06:53,360 --> 00:06:55,280
don't even look at it.

00:06:55,280 --> 00:06:58,480
From what I heard, it's being completely reworked,

00:06:58,480 --> 00:07:01,770
and it's gonna be implemented soon.

00:07:01,770 --> 00:07:05,000
And this gives you a very, very high level

00:07:05,850 --> 00:07:08,380
of talking to the TPM.

00:07:08,380 --> 00:07:12,220
Where you have no custom type definitions anymore,

00:07:12,220 --> 00:07:14,440
but all the interfacing with the TPM

00:07:14,440 --> 00:07:18,860
is handled via JSON-encoded parameter files

00:07:18,860 --> 00:07:20,990
and provides a policy language,

00:07:20,990 --> 00:07:22,990
it provides an automatic key store, stuff like that.

00:07:22,990 --> 00:07:26,263
So that's very, very convenient, high level API.

00:07:28,090 --> 00:07:31,010
So this is all implemented, so all those APIs

00:07:31,010 --> 00:07:35,840
are or are going to be implemented in the TPM2 TSS project.

00:07:35,840 --> 00:07:37,783
That's the core libraries project.

00:07:39,470 --> 00:07:42,580
And I heard recently that it's so,

00:07:42,580 --> 00:07:45,910
so hard to build our stuff, and we have so many dependencies

00:07:45,910 --> 00:07:47,310
in order to build our stuff,

00:07:47,310 --> 00:07:50,140
so just to debunk that we are using Autotools,

00:07:50,140 --> 00:07:54,000
we're using pkg-config, and we have one dependency

00:07:54,000 --> 00:07:55,960
which is either libcrypto or libgcrypt,

00:07:55,960 --> 00:07:57,910
you can decide your crypto backend yourself.

00:07:57,910 --> 00:08:01,060
So I think that's reasonably easy to just type

00:08:01,060 --> 00:08:02,697
in English, -j.

00:08:02,697 --> 00:08:05,980
Coming up in the next API

00:08:05,980 --> 00:08:09,270
we'll probably have to also include libcurl and libjson-c,

00:08:09,270 --> 00:08:13,760
but I think three dependencies are still easily manageable.

00:08:13,760 --> 00:08:17,840
And the second project is the TPM to ABRMD.

00:08:17,840 --> 00:08:20,160
This is the user space resource manager.

00:08:20,160 --> 00:08:22,760
Again, two dependencies, easy to build.

00:08:22,760 --> 00:08:25,170
And another of the core projects

00:08:25,170 --> 00:08:29,110
would be the TPM2 tools, which basically gives you

00:08:29,110 --> 00:08:31,400
command line control over the TPM.

00:08:31,400 --> 00:08:34,200
And we're just running through the release candidates

00:08:34,200 --> 00:08:37,680
of the 4.0 release, so we completely broke parameters

00:08:37,680 --> 00:08:40,253
in API, but now it's better.

00:08:41,870 --> 00:08:44,380
And again, it also has only two dependencies.

00:08:44,380 --> 00:08:46,060
And so for all these core projects,

00:08:46,060 --> 00:08:47,010
what we're trying to achieve

00:08:47,010 --> 00:08:50,210
is we're just trying to follow best practices.

00:08:50,210 --> 00:08:52,560
We're targeting around 80% of test coverage,

00:08:52,560 --> 00:08:54,450
we have scanbuilds on every pull request,

00:08:54,450 --> 00:08:56,680
we have coverity for every release.

00:08:56,680 --> 00:09:00,220
CII for best practices, lgtm tells we have good code.

00:09:00,220 --> 00:09:03,440
So machines say we're nice.

00:09:03,440 --> 00:09:05,820
And actually now there's an effort going on

00:09:05,820 --> 00:09:09,970
to have multi-distro CI on every pull request

00:09:09,970 --> 00:09:12,750
by using docker in Travis,

00:09:12,750 --> 00:09:15,440
which I've found very intriguing and interesting.

00:09:15,440 --> 00:09:18,083
So I'm really looking forward to that being merged.

00:09:20,560 --> 00:09:23,720
And of course there's people, there's community,

00:09:23,720 --> 00:09:26,250
unique community, so this is the list of maintainers

00:09:26,250 --> 00:09:30,390
we currently have active on each of those core projects.

00:09:30,390 --> 00:09:33,730
Especially wanna point out Elias who is the first volunteer

00:09:33,730 --> 00:09:36,110
maintainer who's not being paid to work on this stuff,

00:09:36,110 --> 00:09:37,633
so that's pretty cool.

00:09:38,840 --> 00:09:41,610
More than 100 contributors if we go through the get logs,

00:09:41,610 --> 00:09:43,810
and we're currently packaged for basically

00:09:43,810 --> 00:09:47,670
every major distribution, not with the most recent version

00:09:47,670 --> 00:09:49,503
usually except for Arch I guess.

00:09:50,550 --> 00:09:54,940
But still, you can basically fget or DNF get us

00:09:54,940 --> 00:09:56,980
on every platform.

00:09:56,980 --> 00:10:01,860
Beyond Linux distributions, we even support Windows,

00:10:01,860 --> 00:10:04,880
so we have Visual Studio build files

00:10:04,880 --> 00:10:07,713
if anybody's interested in that, I guess not.

00:10:09,888 --> 00:10:14,888
We have had patches for making us work on QNX, VxWorks,

00:10:15,330 --> 00:10:19,820
recently we merged something to better support FreeBSD.

00:10:19,820 --> 00:10:23,330
And I've seen a prototype of using Sappy

00:10:23,330 --> 00:10:27,520
in a stripped-down version on an Arduino microcontroller,

00:10:27,520 --> 00:10:30,720
so that's how low you can get with our stack.

00:10:30,720 --> 00:10:35,720
And this is the website that you wanna keep in mind,

00:10:35,780 --> 00:10:38,470
this is our community website, whatever,

00:10:38,470 --> 00:10:40,130
where you find links to the mailing list,

00:10:40,130 --> 00:10:43,380
links to different talks, like the one I'm giving here

00:10:43,380 --> 00:10:45,640
will be linked, and hopefully in the future

00:10:45,640 --> 00:10:48,223
we will get some tutorials on there as well.

00:10:49,480 --> 00:10:51,870
Or you send a pull request once you figured your way

00:10:51,870 --> 00:10:52,833
through the stack.

00:10:54,080 --> 00:10:57,210
All right, but the thing I actually promised in the abstract

00:10:57,210 --> 00:10:59,100
when handing in this talk was to discuss

00:10:59,100 --> 00:11:01,040
different use cases, so that was the background

00:11:01,040 --> 00:11:02,350
of what we're talking about.

00:11:02,350 --> 00:11:06,170
This is how this is useful for core infrastructure,

00:11:06,170 --> 00:11:08,013
core system security features.

00:11:09,590 --> 00:11:14,010
The very first and very much easiest thing to do

00:11:14,010 --> 00:11:17,080
is you wanna shield your keys when you store them

00:11:17,080 --> 00:11:20,280
and when you use them so that they don't leak.

00:11:20,280 --> 00:11:23,610
Keys in RAM are always a bad idea, just heartbleed.

00:11:25,453 --> 00:11:27,700
Keys on disk are just as dangerous,

00:11:27,700 --> 00:11:29,820
because even though you can protect them

00:11:29,820 --> 00:11:32,480
with a user password, those passwords can be brute forced

00:11:32,480 --> 00:11:33,920
or dictionary attacked.

00:11:33,920 --> 00:11:37,010
And especially when you look at servers or embedded devices,

00:11:37,010 --> 00:11:39,760
they don't have a step for having, I dunno,

00:11:39,760 --> 00:11:41,380
the admin going to the data center,

00:11:41,380 --> 00:11:43,380
approach each of your machines and type in

00:11:43,380 --> 00:11:45,790
some kind of password in order to unlock the keys

00:11:45,790 --> 00:11:49,000
to serve to the outside world, that doesn't make any sense.

00:11:49,000 --> 00:11:54,000
So you need some ways to prevent the malicious copying

00:11:54,210 --> 00:11:56,923
of your IDs, or cloning.

00:11:58,640 --> 00:12:01,970
And that's easy to be done just using the TPM for that,

00:12:01,970 --> 00:12:03,920
it's right there on the device already.

00:12:06,130 --> 00:12:07,970
How do you do that?

00:12:07,970 --> 00:12:10,370
Might sound very complicated, actually it's not.

00:12:11,300 --> 00:12:16,263
This is a project also hosted on this call libraries,

00:12:17,877 --> 00:12:22,057
GitHub namespace, which is an open SSL engine

00:12:23,070 --> 00:12:26,740
that basically, I don't know how many of you guys know

00:12:26,740 --> 00:12:29,900
how OpenSSL works, so they have this internal interface

00:12:29,900 --> 00:12:34,230
where you can, at runtime, load additional engines

00:12:34,230 --> 00:12:36,247
into the OpenSSL library that perform

00:12:36,247 --> 00:12:39,290
the cryptographic operations for OpenSSL.

00:12:39,290 --> 00:12:43,240
And so we wrote one of those libraries that uses,

00:12:43,240 --> 00:12:46,730
that then hands off the cryptographic operations to the TPM,

00:12:46,730 --> 00:12:49,420
and spits the results back into OpenSSL.

00:12:49,420 --> 00:12:54,420
So this way, just by setting, what is it,

00:12:54,450 --> 00:12:58,610
the engine to TPM2-TSS, and setting the key form

00:12:58,610 --> 00:13:02,210
to engine with just two command line parameters,

00:13:02,210 --> 00:13:04,940
you already have all your keys coming from the TPM

00:13:04,940 --> 00:13:09,130
instead of your RAM, which prevents cloning

00:13:09,130 --> 00:13:12,223
of your identities already, so it's easy to integrate.

00:13:23,610 --> 00:13:25,920
- [Audience Member] How would that compare, performance-wise

00:13:25,920 --> 00:13:30,320
if the encryption is done not in the TPM, on OpenSSL I mean?

00:13:30,320 --> 00:13:32,600
- That depends highly on the performance of your TPM,

00:13:32,600 --> 00:13:36,340
so there is TPMs ranging from I guess 300 milliseconds

00:13:36,340 --> 00:13:39,940
per signature, down to 150 or 100 milliseconds,

00:13:39,940 --> 00:13:41,220
which is kind of slow.

00:13:41,220 --> 00:13:43,280
If you're in a virtual environment,

00:13:43,280 --> 00:13:47,650
I would maybe propose exposing a virtual TPM

00:13:47,650 --> 00:13:49,680
to each of your virtual machines,

00:13:49,680 --> 00:13:52,010
and then you will get the whole software

00:13:52,010 --> 00:13:57,010
and CPU-accelerated stuff in the virtual TPM,

00:13:57,360 --> 00:13:59,810
running on your Dom zero, if that's your concern.

00:14:01,020 --> 00:14:02,560
- [Audience Member] Well that still

00:14:02,560 --> 00:14:06,397
doesn't answer my question besides your mileage may vary.

00:14:06,397 --> 00:14:08,050
And yeah, I understand it might vary,

00:14:08,050 --> 00:14:10,380
but do I need to do my own benchmarks

00:14:10,380 --> 00:14:12,210
to get the ballpark figure,

00:14:12,210 --> 00:14:13,760
whether it'll be slower or not?

00:14:15,470 --> 00:14:17,420
- Well it's definitely gonna be slower.

00:14:20,400 --> 00:14:23,680
There's no doubt about that, hardware TPM is always slower.

00:14:23,680 --> 00:14:26,790
And even if you run a virtual TPM in a cloud center,

00:14:26,790 --> 00:14:30,460
you have to do a bunch of VT switching

00:14:30,460 --> 00:14:32,720
in order to hand down the messages to the hypervisor.

00:14:32,720 --> 00:14:35,680
VTPM has the backup, so you're always gonna be slower.

00:14:35,680 --> 00:14:37,990
The order of magnitude for VTPM,

00:14:37,990 --> 00:14:39,840
I don't know how long it takes.

00:14:39,840 --> 00:14:43,231
I guess, do we have a cloud track somewhere?

00:14:43,231 --> 00:14:46,260
So that depends on how long it takes

00:14:46,260 --> 00:14:49,940
for Dom U to Dom zero switching and back.

00:14:49,940 --> 00:14:52,210
- But for example, when it was integrated

00:14:52,210 --> 00:14:55,730
to a patch two, it only matters for the handshake

00:14:55,730 --> 00:14:57,330
and establishing the connection,

00:14:57,330 --> 00:14:59,730
'cause the session key will be handled in memory,

00:14:59,730 --> 00:15:02,840
and the session encryption is fast and accelerated

00:15:02,840 --> 00:15:04,940
with CPU structures, et cetera.

00:15:04,940 --> 00:15:07,760
- Yeah, thank you, so you really wanna only put

00:15:07,760 --> 00:15:10,410
your long-lived IDs into the TPM,

00:15:10,410 --> 00:15:13,870
and session secrets or session encryption

00:15:13,870 --> 00:15:15,033
is done on the fly.

00:15:16,780 --> 00:15:19,170
- I'm gonna challenge your assertion that this is easy,

00:15:19,170 --> 00:15:22,550
with specifying the engine and the key form.

00:15:22,550 --> 00:15:25,020
You then have to get that into every single application

00:15:25,020 --> 00:15:26,820
in the system, no, you are not done

00:15:26,820 --> 00:15:31,210
until people can take the PEM file with the wrapped keys,

00:15:31,210 --> 00:15:34,100
and expect it to just work in all applications.

00:15:34,100 --> 00:15:37,140
But we are fixing things like Fedora distribution guidelines

00:15:37,140 --> 00:15:42,070
to state that if your application takes keys in a file,

00:15:42,070 --> 00:15:45,643
thou shalt also accept RFC7518, PKCS11 URIs,

00:15:48,530 --> 00:15:51,810
and thou shalt also accept the wrapped file,

00:15:51,810 --> 00:15:53,560
and just do the right thing.

00:15:53,560 --> 00:15:56,710
So don't stop there, don't say it's easy,

00:15:56,710 --> 00:15:58,037
you are not done yet.

00:15:58,970 --> 00:16:00,070
- I would never say so,

00:16:00,070 --> 00:16:03,230
and actually there's gonna be a slide a while later.

00:16:03,230 --> 00:16:04,510
What I actually wanna do right now

00:16:04,510 --> 00:16:08,720
is implement the EVPPK key interfaces.

00:16:09,660 --> 00:16:11,950
There's a half-done pull request

00:16:11,950 --> 00:16:13,860
that's been hangin' around for quite some time,

00:16:13,860 --> 00:16:16,620
that will enable us to just load the key,

00:16:16,620 --> 00:16:21,620
because then we auto detect the private TSS key pemp header,

00:16:23,970 --> 00:16:26,880
which is the same header and actually the same data format

00:16:26,880 --> 00:16:30,020
as James is using for his implementation,

00:16:30,020 --> 00:16:31,150
so we're even interchangeable

00:16:31,150 --> 00:16:33,410
between those two implementations, thanks.

00:16:34,960 --> 00:16:36,860
Yeah, that's definitely on the agenda.

00:16:37,730 --> 00:16:40,610
I would love, I would just skip ahead now.

00:16:40,610 --> 00:16:43,492
I'm still searching for a second maintainer,

00:16:43,492 --> 00:16:46,950
with more OpenSSL knowledge to be able to review

00:16:46,950 --> 00:16:51,390
the EVVP key implementation that's hanging around

00:16:51,390 --> 00:16:54,630
in the pull request, because that's going a lot deeper

00:16:54,630 --> 00:16:57,570
into OpenSSL than what I've been doing so far,

00:16:57,570 --> 00:16:59,290
and what I would be comfortable with.

00:16:59,290 --> 00:17:01,610
So if there's anybody here who wants to maintain

00:17:01,610 --> 00:17:05,453
an OpenSSL engine, I'll be waiting right out the door.

00:17:07,370 --> 00:17:08,970
Hmm?

00:17:08,970 --> 00:17:09,803
Cool.

00:17:10,970 --> 00:17:13,290
- [Audience Member] Just a comment on the speed issue,

00:17:13,290 --> 00:17:16,030
they're getting faster, really faster really quickly.

00:17:16,030 --> 00:17:17,530
And we know how fast they're getting faster,

00:17:17,530 --> 00:17:20,730
because the Windows logo spec has a table

00:17:20,730 --> 00:17:23,130
of environments that are going to be doing that

00:17:23,130 --> 00:17:24,870
for compliance over time.

00:17:24,870 --> 00:17:27,993
And so you can literally just look up how fast they are.

00:17:28,870 --> 00:17:29,703
- Cool.

00:17:32,210 --> 00:17:36,243
All right, next use case, user authentication.

00:17:37,580 --> 00:17:40,810
We probably all know the typical Smartcard workflow.

00:17:40,810 --> 00:17:45,330
You have PKCS11 modules for those.

00:17:45,330 --> 00:17:49,130
And the Smartcard is your proof of possession.

00:17:49,130 --> 00:17:51,080
Then you enter a PIN into a file forks,

00:17:51,080 --> 00:17:52,530
Thunderbird, whatever.

00:17:52,530 --> 00:17:57,530
And that gives you a way to authenticate to a web server.

00:17:58,920 --> 00:18:02,940
It's more secure, and I guess more convenient

00:18:02,940 --> 00:18:05,050
than upcoming password policies.

00:18:05,050 --> 00:18:07,520
I think recently I've done up to 15 characters

00:18:07,520 --> 00:18:11,000
from three different number spaces, and whatever.

00:18:11,000 --> 00:18:14,810
So I actually prefer my four-digit PINs over that,

00:18:14,810 --> 00:18:16,150
very very much.

00:18:16,150 --> 00:18:18,710
So what's currently a work in progress

00:18:18,710 --> 00:18:20,800
is another of those projects,

00:18:20,800 --> 00:18:25,800
which is the PKCS11 virtual Smartcard, based on a TPM.

00:18:26,680 --> 00:18:29,540
And here the model shifts a little bit.

00:18:29,540 --> 00:18:31,380
So instead of having proof of possession

00:18:31,380 --> 00:18:33,770
by holding a Smartcard, you have proof of possession

00:18:33,770 --> 00:18:37,250
by holding your laptop, which is more or less

00:18:37,250 --> 00:18:40,820
the same thing, at least as long

00:18:40,820 --> 00:18:42,670
as you only have a class zero card reader,

00:18:42,670 --> 00:18:45,470
which 99% of people have I guess,

00:18:45,470 --> 00:18:47,189
and proof of knowledge, you enter your PIN

00:18:47,189 --> 00:18:49,640
and we are fully compatible.

00:18:49,640 --> 00:18:53,410
So as soon as you do that, well,

00:18:53,410 --> 00:18:56,880
basically just install the PKCS11 driver and you're done.

00:18:56,880 --> 00:18:59,020
Again, it's very easy.

00:18:59,020 --> 00:19:01,330
Especially if you use,

00:19:01,330 --> 00:19:05,863
I think it's the libpk11 was it called?

00:19:06,970 --> 00:19:09,550
That gives you a way to work

00:19:09,550 --> 00:19:13,160
with multiple backend PKCS11 providers,

00:19:13,160 --> 00:19:15,750
because currently it's hard to have more than one installed,

00:19:15,750 --> 00:19:17,950
and it gets kind of messy addressing them.

00:19:17,950 --> 00:19:20,603
So that's something that's being solved there.

00:19:21,727 --> 00:19:23,477
And also it's easier to setup then.

00:19:26,350 --> 00:19:29,700
More user authentication happens on VPNs.

00:19:29,700 --> 00:19:34,050
So typically you enter your username and your password,

00:19:34,050 --> 00:19:37,200
which is again, a very long password,

00:19:37,200 --> 00:19:39,900
and it's not too secure because well,

00:19:39,900 --> 00:19:41,810
if somebody just looks at your keyboard

00:19:41,810 --> 00:19:44,800
while you're typing stuff in, they can impersonate you

00:19:44,800 --> 00:19:47,220
and log in to the same VPN as you did.

00:19:47,220 --> 00:19:51,210
This happens especially at conferences, I've been told,

00:19:51,210 --> 00:19:52,780
at security conferences.

00:19:52,780 --> 00:19:55,810
So people are switching over from passwords to fingerprints,

00:19:55,810 --> 00:19:59,210
because that's more secure in practice, apparently,

00:19:59,210 --> 00:20:01,330
even though then you always have to carry around

00:20:01,330 --> 00:20:02,193
your own glasses.

00:20:03,860 --> 00:20:07,331
So in order to get around that problem, again,

00:20:07,331 --> 00:20:10,610
you can switch over from a username password-based approach

00:20:10,610 --> 00:20:13,300
to a machine and user password approach.

00:20:13,300 --> 00:20:16,180
Pretty similar to PKCS11, and that gives you

00:20:16,180 --> 00:20:20,943
a whole new level of security for network access.

00:20:22,060 --> 00:20:24,940
Actually that's been done for Openconnect

00:20:24,940 --> 00:20:26,350
by David Woodhouse.

00:20:26,350 --> 00:20:30,550
He basically just took the code from the OpenSSL engine,

00:20:30,550 --> 00:20:33,000
ported it to his Openconnect project,

00:20:33,000 --> 00:20:35,850
and now at least on this machine here,

00:20:35,850 --> 00:20:39,840
the Openconnect is cooler than the original Anyconnect

00:20:39,840 --> 00:20:40,963
in that regard.

00:20:42,110 --> 00:20:44,850
There's also been the implementation of Strongswan,

00:20:44,850 --> 00:20:49,140
which is the whole IP sec of whole-blown attestation

00:20:49,140 --> 00:20:50,453
kind of access.

00:20:52,330 --> 00:20:55,400
And I'm hoping, I haven't tested it yet,

00:20:55,400 --> 00:20:57,090
that using the OpenSSL engine,

00:20:57,090 --> 00:21:00,600
we should also get openvpn working pretty nicely.

00:21:00,600 --> 00:21:01,980
What I would love to see of course

00:21:01,980 --> 00:21:04,750
would be WireGuard, Tinc and whatnot

00:21:04,750 --> 00:21:07,160
to support TPMs as well.

00:21:07,160 --> 00:21:10,090
- Nicos has now ported my openconnect code

00:21:10,090 --> 00:21:12,343
into GNU TOS as well, so GNU TOS.

00:21:13,490 --> 00:21:15,830
Not merged yet, but he's working on supporting that.

00:21:15,830 --> 00:21:19,683
- Okay, I'll add that right to the slides, awesome, yeah.

00:21:22,650 --> 00:21:26,780
So that much for user authentication.

00:21:26,780 --> 00:21:29,880
Disk encryption is another one of those core features

00:21:29,880 --> 00:21:31,570
that you wanna have on your system,

00:21:31,570 --> 00:21:33,590
or system security features.

00:21:33,590 --> 00:21:35,670
So what I'm now talking about,

00:21:35,670 --> 00:21:39,139
I don't know how many of you suffered through Bitlocker,

00:21:39,139 --> 00:21:41,793
but wouldn't Bitlocker for Linux be awesome?

00:21:43,200 --> 00:21:47,050
What it gives you, it gives you a binding of the disk

00:21:47,050 --> 00:21:49,400
to the machine, which means that you cannot

00:21:49,400 --> 00:21:51,890
just remove the disk, put it into a different machine,

00:21:51,890 --> 00:21:55,550
and be able to directly access over there.

00:21:55,550 --> 00:21:58,320
It gives you short PINs instead of long passwords.

00:21:58,320 --> 00:22:02,710
Again, something that I very much like for my convenience.

00:22:02,710 --> 00:22:05,450
And you don't run into the issue

00:22:05,450 --> 00:22:06,993
of dictionary attacks anymore.

00:22:08,150 --> 00:22:10,323
No matter how nice your encryption is,

00:22:12,300 --> 00:22:15,300
you always have to basically add a character every two years

00:22:15,300 --> 00:22:16,900
according to Moore's law.

00:22:16,900 --> 00:22:18,610
And you don't wanna do that forever,

00:22:18,610 --> 00:22:21,520
because I hope to live for a few more years,

00:22:21,520 --> 00:22:24,393
and so my brain wouldn't handle that.

00:22:26,720 --> 00:22:30,610
So what this means is that we encrypt the disk

00:22:30,610 --> 00:22:32,643
and seal the key to the TPM.

00:22:34,290 --> 00:22:37,900
This has even more utility in other areas than the desktop.

00:22:37,900 --> 00:22:39,530
If you think about the data center,

00:22:39,530 --> 00:22:43,530
where currently we're using just standard crypt setup

00:22:43,530 --> 00:22:46,210
and locks, people can basically go in

00:22:46,210 --> 00:22:49,890
and rip out hard disks and walk away with them,

00:22:49,890 --> 00:22:51,720
and be able to access the data.

00:22:51,720 --> 00:22:55,150
If you're able to bind the disk, cryptographically,

00:22:55,150 --> 00:22:59,170
to the machine, people would have to rip out the main board

00:22:59,170 --> 00:23:00,870
alongside with the disk, and the main board

00:23:00,870 --> 00:23:02,180
is a little harder to carry,

00:23:02,180 --> 00:23:06,400
and easier to see that somebody ripped out the main board,

00:23:06,400 --> 00:23:07,900
because their machine is down.

00:23:09,830 --> 00:23:12,590
Embedded devices, same story once again.

00:23:12,590 --> 00:23:15,960
You wanna be able to bind data from, I don't know,

00:23:15,960 --> 00:23:18,670
an SD card that's sitting in an external slot,

00:23:18,670 --> 00:23:22,130
I dunno if you've seen this industrial-grade equipment,

00:23:22,130 --> 00:23:23,430
they have this SD card slot,

00:23:23,430 --> 00:23:26,680
and everything is just on an SD or MMC card.

00:23:26,680 --> 00:23:29,730
You wanna be able to bind this stuff to the machine

00:23:29,730 --> 00:23:32,950
so people can't just rip out the card

00:23:32,950 --> 00:23:34,500
while walking past the machine.

00:23:35,500 --> 00:23:38,940
And if you're really fancy, and this is the only time

00:23:38,940 --> 00:23:40,530
I think I'm gonna touch at this stage,

00:23:40,530 --> 00:23:43,530
you can even bind the encryption of your disk

00:23:43,530 --> 00:23:48,530
to the integrity status of your BIOS, or UFI or whatever.

00:23:51,620 --> 00:23:55,580
I think I've heard that occasionally there is bugs in there

00:23:55,580 --> 00:23:58,050
and people flash it and exploit it.

00:23:58,050 --> 00:24:02,350
So that's what lot of people call local attestation,

00:24:02,350 --> 00:24:06,290
where if the BIOS or early boot code changes,

00:24:06,290 --> 00:24:08,070
the TPM would just deny you access

00:24:08,070 --> 00:24:10,193
to the secret decrypt the hard disk.

00:24:11,420 --> 00:24:15,560
And we have actually running code for that.

00:24:15,560 --> 00:24:19,060
So there's been a proof of concept implementation

00:24:19,060 --> 00:24:21,790
of this whole thing, and at the bottom here

00:24:21,790 --> 00:24:25,660
you see from this desktop the way it looks.

00:24:25,660 --> 00:24:27,860
So the only thing that we changed at that time

00:24:27,860 --> 00:24:29,597
was basically to the LUKS format,

00:24:29,597 --> 00:24:34,597
you just add the --TPM parameter, it's easy, okay.

00:24:37,590 --> 00:24:39,780
So I think that was pretty easy,

00:24:39,780 --> 00:24:41,560
and we defined a new key slot type,

00:24:41,560 --> 00:24:45,160
and there's on LUKS2 we actually have JSON

00:24:45,160 --> 00:24:47,220
on our hard disk, I didn't know that.

00:24:47,220 --> 00:24:50,830
But that's pretty cool, because it's easily extendable.

00:24:50,830 --> 00:24:54,710
So there was this new key slot type that we defined

00:24:54,710 --> 00:24:57,840
that tells cryptsetup or libcryptsetup

00:24:57,840 --> 00:25:00,800
where on the TPM to find the disk encryption secret,

00:25:00,800 --> 00:25:03,790
and whether it's bound to PCR state

00:25:03,790 --> 00:25:04,720
or whether it's not bound,

00:25:04,720 --> 00:25:07,613
whether it's dictionary attack protected or not.

00:25:08,560 --> 00:25:10,910
So the essential information,

00:25:10,910 --> 00:25:12,790
and then you could just LUKS open it

00:25:12,790 --> 00:25:16,960
without doing anything, without having to add any parameter.

00:25:16,960 --> 00:25:19,840
So this was the proof of concept for this whole thing,

00:25:19,840 --> 00:25:24,060
and then talking with a maintainer with Milan on that stuff,

00:25:24,060 --> 00:25:27,160
we're now gonna be re-architecting this whole thing,

00:25:27,160 --> 00:25:29,140
or he's gonna do, I think they have a lifting

00:25:29,140 --> 00:25:30,690
on the re-architecting thing,

00:25:30,690 --> 00:25:32,690
and making cryptsetup module-aware,

00:25:32,690 --> 00:25:35,190
and having TPM be one of the main modules.

00:25:35,190 --> 00:25:38,350
So hopefully for 2.3 or 2.4 release

00:25:38,350 --> 00:25:42,913
we will see this on upstream, and ready to use for everyone.

00:25:44,760 --> 00:25:47,700
All right, well what's missing?

00:25:47,700 --> 00:25:49,700
There's this whole field of attestation, as I said,

00:25:49,700 --> 00:25:51,330
I'm not gonna touch that because I think

00:25:51,330 --> 00:25:54,987
there's so many simpler things that would increment

00:25:54,987 --> 00:25:59,987
or increase the security much easier and much faster.

00:25:59,990 --> 00:26:04,990
For example, 802.1X capabilities,

00:26:05,000 --> 00:26:07,970
just using identity secrets in the TPM

00:26:07,970 --> 00:26:10,273
in order to authenticate for network access.

00:26:10,273 --> 00:26:12,140
I would love to see that in NetworkManager

00:26:12,140 --> 00:26:13,410
or systemd-networkd.

00:26:13,410 --> 00:26:16,960
I would to have to have my gnome-keyring or kwallet

00:26:18,120 --> 00:26:21,950
backed by the TPM, so you cannot just copy over the file

00:26:21,950 --> 00:26:24,363
and I dunno, decrypt it somewhere else.

00:26:25,711 --> 00:26:27,840
I already mentioned Wireguard and Tinc.

00:26:27,840 --> 00:26:31,100
I would love to have GnuPG support the TPM.

00:26:31,100 --> 00:26:35,030
Unfortunately they don't have PKCS11 backend interface,

00:26:35,030 --> 00:26:36,900
otherwise we could just plug it in.

00:26:36,900 --> 00:26:38,510
But I would love to see that supported,

00:26:38,510 --> 00:26:41,570
because currently I'm working on this whole TPM stuff,

00:26:41,570 --> 00:26:44,040
and whenever I do a release I have to go ahead

00:26:44,040 --> 00:26:46,803
and use a software token, which is kind of frustrating.

00:26:47,920 --> 00:26:50,210
And as I mentioned, I would love to have

00:26:50,210 --> 00:26:52,620
a second maintainer for the OpenSSL engine,

00:26:52,620 --> 00:26:55,400
with more knowledge of OpenSSL than myself,

00:26:55,400 --> 00:26:58,010
'cause I've been in too many areas

00:26:58,010 --> 00:27:02,773
to dive too deep into this thing.

00:27:04,210 --> 00:27:07,604
So, what do I want from you all?

00:27:07,604 --> 00:27:08,563
Well, all y'all.

00:27:10,360 --> 00:27:12,100
Help to spread the TPM support

00:27:12,100 --> 00:27:14,490
into the whole core infrastructure,

00:27:14,490 --> 00:27:17,110
which is something that will, I dunno,

00:27:17,110 --> 00:27:18,780
for the greater good of the world

00:27:18,780 --> 00:27:21,630
just make everything more secure and convenient, I dunno.

00:27:22,860 --> 00:27:26,980
The areas of interest is basically everywhere.

00:27:26,980 --> 00:27:29,360
I've personally worked on projects

00:27:29,360 --> 00:27:31,510
to integrate stuff into desktop, into server,

00:27:31,510 --> 00:27:33,020
into network equipment, into automotive,

00:27:33,020 --> 00:27:36,290
into railway controllers, we have a proof of concept

00:27:36,290 --> 00:27:40,720
research work where currently they don't have any security,

00:27:40,720 --> 00:27:42,620
so it would be nice to have some security,

00:27:42,620 --> 00:27:44,817
and why not go for TPM directly.

00:27:44,817 --> 00:27:47,890
Seen that in energy and IoT everywhere.

00:27:47,890 --> 00:27:51,430
And at least for the desktop server market,

00:27:51,430 --> 00:27:52,900
the TPM is already there.

00:27:52,900 --> 00:27:56,060
So why not make Linux be able to utilize

00:27:56,060 --> 00:27:59,323
the capabilities of your platform to all extent?

00:28:01,760 --> 00:28:04,620
Well what would you need to do if you were interested

00:28:04,620 --> 00:28:06,440
in helping out with that?

00:28:06,440 --> 00:28:09,030
Basically just take any of those examples and copy,

00:28:09,030 --> 00:28:12,120
or in a step-by-step guide, you identify

00:28:12,120 --> 00:28:14,860
the cryptographic operations, study yourself for that.

00:28:14,860 --> 00:28:17,110
You come up with a key storage scheme,

00:28:17,110 --> 00:28:20,110
whether you wanna have it persistent in the TPM

00:28:20,110 --> 00:28:22,660
so you have access during very, very early boot,

00:28:22,660 --> 00:28:24,420
or whether you wanna have the TSS

00:28:24,420 --> 00:28:26,090
manage your key store for you,

00:28:26,090 --> 00:28:29,190
or whether you wanna have your own key store with PEM files,

00:28:29,190 --> 00:28:31,310
with certain headers and stuff like that.

00:28:31,310 --> 00:28:33,180
Then you think of your access control scheme,

00:28:33,180 --> 00:28:35,750
do you wanna have it just bound to the device,

00:28:35,750 --> 00:28:38,350
as I mentioned, for data centers or embedded systems?

00:28:38,350 --> 00:28:40,180
Do you wanna have it password protected,

00:28:40,180 --> 00:28:43,330
similar to the whole PKCS11 scheme?

00:28:43,330 --> 00:28:45,050
Or do you wanna have more policy,

00:28:45,050 --> 00:28:47,390
such as I dunno, local attestation,

00:28:47,390 --> 00:28:51,550
or you can even have expiration time on keys on the TPM,

00:28:51,550 --> 00:28:54,280
where after a certain runtime of the TPM

00:28:54,280 --> 00:28:58,500
it will cease allowing access to that key,

00:28:58,500 --> 00:28:59,713
which is kind of cool.

00:29:00,970 --> 00:29:02,960
And then you implement the crypto.

00:29:02,960 --> 00:29:06,390
And if that sounds complicated, just come talk to me

00:29:06,390 --> 00:29:09,840
in the hallway tomorrow at the TPM secure boot session,

00:29:09,840 --> 00:29:11,690
or drop me an email or whatever,

00:29:11,690 --> 00:29:13,343
and I would love to help you.

00:29:15,860 --> 00:29:17,170
What would this look like?

00:29:17,170 --> 00:29:19,800
Just to give you a very, very slight impression.

00:29:19,800 --> 00:29:21,563
I know this is code, this is scary.

00:29:24,938 --> 00:29:28,480
If or once Fapi comes out,

00:29:28,480 --> 00:29:30,500
enabling your software to do a signature

00:29:30,500 --> 00:29:33,990
using a TSS-managed key will be as simple

00:29:33,990 --> 00:29:36,140
as those two lines of code.

00:29:36,140 --> 00:29:39,420
So I'm literally speaking of two lines of code

00:29:39,420 --> 00:29:42,853
in order to enable TPM support in your software.

00:29:43,820 --> 00:29:46,360
If you wanna have more control and a direct interaction

00:29:46,360 --> 00:29:49,550
with the TPM, then you would go for Esys.

00:29:49,550 --> 00:29:52,820
And there it would be four lines of code,

00:29:52,820 --> 00:29:56,150
plus a bunch of variable declarations beforehand.

00:29:56,150 --> 00:29:58,250
But that's actually it in the end as well.

00:30:00,910 --> 00:30:02,380
This is what it looks like in practice,

00:30:02,380 --> 00:30:05,070
so this is taken directly from the OpenSSL engine.

00:30:05,070 --> 00:30:09,721
The OpenSSL rand functions, just call getrandom repeatedly

00:30:09,721 --> 00:30:12,030
until you have enough random data collected

00:30:12,030 --> 00:30:13,620
as the user requested.

00:30:13,620 --> 00:30:17,120
Or here we have, well, encapsulated in a TPM key,

00:30:17,120 --> 00:30:19,860
and then this is the decryption call.

00:30:19,860 --> 00:30:23,460
And I would recommend highly to just look at that code,

00:30:23,460 --> 00:30:26,000
copy it wherever you can.

00:30:26,000 --> 00:30:28,680
It's BSD3 class I think.

00:30:28,680 --> 00:30:31,503
So it's as liberal as it gets, I guess.

00:30:33,140 --> 00:30:37,170
All right, and that was a little faster than expected,

00:30:37,170 --> 00:30:39,323
but that gives us more time for questions.

00:30:52,630 --> 00:30:56,020
- So you mentioned Bitlocker type unlock stuff.

00:30:56,020 --> 00:30:57,560
So there are various circumstances

00:30:57,560 --> 00:30:59,440
under which the PCRs that you seal

00:30:59,440 --> 00:31:01,020
an unlock key to can change.

00:31:01,020 --> 00:31:03,750
For instance, firmware updates, bootloader upgrades,

00:31:03,750 --> 00:31:06,030
or depending on policy, or DBX updates

00:31:06,030 --> 00:31:07,980
if you're just using PCR7.

00:31:07,980 --> 00:31:11,070
Are you looking at any kind of integrated infrastructure

00:31:11,070 --> 00:31:14,910
for calculating expected PCR values,

00:31:14,910 --> 00:31:16,740
and automatically resealing stuff

00:31:16,740 --> 00:31:18,623
when relevant updates occur?

00:31:20,177 --> 00:31:25,177
- That's a, I would love to integrate the stuff,

00:31:25,350 --> 00:31:27,620
and I know that there are some works of yours,

00:31:27,620 --> 00:31:29,520
some works of Philip's.

00:31:29,520 --> 00:31:31,557
- [Philip] Come to my talk tomorrow.

00:31:31,557 --> 00:31:34,193
- (laughs) Yep, for example.

00:31:35,850 --> 00:31:37,980
This whole precalculation is a big problem.

00:31:37,980 --> 00:31:40,820
So the way that currently the idea

00:31:40,820 --> 00:31:43,380
for the cryptsetup integration is,

00:31:43,380 --> 00:31:46,410
you would have some kind of backup key slot,

00:31:46,410 --> 00:31:51,010
with a long password that you put into a safe somewhere.

00:31:51,010 --> 00:31:52,970
And once you do an update

00:31:52,970 --> 00:31:55,110
to any of your other boot components,

00:31:55,110 --> 00:31:56,810
you basically reboot the system,

00:31:56,810 --> 00:31:58,930
enter the long frickin' password,

00:31:58,930 --> 00:32:00,330
you delete the old key slot,

00:32:00,330 --> 00:32:03,330
you recreate the key slot with the TPM and you're done.

00:32:03,330 --> 00:32:06,170
So that would be one practical workflow,

00:32:06,170 --> 00:32:08,730
without having to build up, I dunno,

00:32:08,730 --> 00:32:11,130
a few hundred thousand lines of code

00:32:11,130 --> 00:32:12,580
of infrastructure beforehand.

00:32:13,676 --> 00:32:16,676
(audience mumbling)

00:32:18,110 --> 00:32:18,943
- [Audience Member] On a practical basis

00:32:18,943 --> 00:32:19,820
that doesn't work at all,

00:32:19,820 --> 00:32:21,540
because nobody remember what the passphrase is,

00:32:21,540 --> 00:32:23,110
or realizes why it's important,

00:32:23,110 --> 00:32:25,393
and when they do a firmware update their machines break.

00:32:27,800 --> 00:32:29,500
- Yes. - Okay. (laughs)

00:32:29,500 --> 00:32:33,090
- But it's the only solution that's currently implemented.

00:32:33,090 --> 00:32:34,610
In order to go any further,

00:32:34,610 --> 00:32:37,060
I think we need a lot of what Phil's gonna be talking about

00:32:37,060 --> 00:32:40,260
tomorrow, and especially support from distros.

00:32:40,260 --> 00:32:44,800
Because the only way for you to predict the PCRs

00:32:44,800 --> 00:32:46,960
for the next reboot after the update

00:32:46,960 --> 00:32:48,760
is if you know those in advance.

00:32:48,760 --> 00:32:51,380
So you need a way to incorporate that,

00:32:52,470 --> 00:32:55,763
to incorporate the whole stuff and the whole scheme

00:32:55,763 --> 00:32:58,950
into your update manager,

00:32:58,950 --> 00:33:00,780
and then you can prepare for the next boot,

00:33:00,780 --> 00:33:02,530
and so on, and just take it from there.

00:33:02,530 --> 00:33:06,900
- That's why we have put the hashes for firmware stuff

00:33:06,900 --> 00:33:09,160
as a field in LVSS. - Sorry?

00:33:09,160 --> 00:33:11,680
- We've put that as a field in FVSS for firmware updates,

00:33:11,680 --> 00:33:14,070
so you can actually have that data

00:33:14,070 --> 00:33:16,033
on the new firmware you're getting.

00:33:17,040 --> 00:33:19,100
And I think Microsoft's gonna acquire it

00:33:19,100 --> 00:33:23,233
in their end files, which will help us a lot.

00:33:24,700 --> 00:33:25,533
- Even better.

00:33:25,533 --> 00:33:26,830
- [Audience Member] While you're answering other questions,

00:33:26,830 --> 00:33:29,130
could you switch to the previous slide please?

00:33:34,700 --> 00:33:36,810
Okay then, meanwhile, does it look

00:33:36,810 --> 00:33:39,510
like you are getting random data from the TPM?

00:33:39,510 --> 00:33:41,750
- Yes. - Why?

00:33:41,750 --> 00:33:45,983
How are they more random than anything else, or are they?

00:33:47,480 --> 00:33:49,840
- Well, I don't know how much random.

00:33:49,840 --> 00:33:54,840
They are CCAAEAL4 plus certified random,

00:33:55,010 --> 00:33:58,113
if that means anything to you, I don't know.

00:33:59,250 --> 00:34:01,680
And other than that, the nice thing about random data

00:34:01,680 --> 00:34:04,610
is the more random data you collect and hash together

00:34:04,610 --> 00:34:07,270
as a seed, the more random it is in the end,

00:34:07,270 --> 00:34:10,520
because well, entropy increases the more you collect.

00:34:10,520 --> 00:34:12,270
- [Audience Member] Okay, so you basically think

00:34:12,270 --> 00:34:14,920
that they'll be more random

00:34:14,920 --> 00:34:17,010
to collect the data from the TPM.

00:34:17,010 --> 00:34:20,740
- No, I would say go ahead take random data from the TPM,

00:34:20,740 --> 00:34:22,270
take random data from your CPU,

00:34:22,270 --> 00:34:23,840
take random data from your network card

00:34:23,840 --> 00:34:26,520
and throw that all together into an entropy pool.

00:34:26,520 --> 00:34:28,850
- [Audience Member] Yeah, but I'm asking

00:34:28,850 --> 00:34:30,170
about what I see on the slide.

00:34:30,170 --> 00:34:33,330
So you think it might make sense to get them from TPM?

00:34:33,330 --> 00:34:35,980
- Yeah, sure, as one of the sources.

00:34:35,980 --> 00:34:38,523
- Okay, yeah, next question here.

00:34:40,220 --> 00:34:42,580
As far as I understand, Windows 10 takes

00:34:42,580 --> 00:34:46,360
the ownership of TPM, and if you have a dual boot machine

00:34:46,360 --> 00:34:49,340
and you want to seal your own secrets,

00:34:49,340 --> 00:34:52,260
is it possible to use TPM from Linux

00:34:52,260 --> 00:34:57,260
for the cryptsetup encryption whilst not breaking Bitlocker

00:34:58,060 --> 00:35:00,203
for that to continue to work as well?

00:35:01,050 --> 00:35:04,530
- Well thankfully, for better or worse

00:35:04,530 --> 00:35:07,670
I should probably say, the term ownership

00:35:07,670 --> 00:35:11,300
is not a TPM term in the sense

00:35:14,750 --> 00:35:16,393
that it was with 1.2 types.

00:35:17,930 --> 00:35:21,510
Right now what you have is you have a privacy administrator,

00:35:21,510 --> 00:35:25,350
you have the owner or storage administrator,

00:35:27,730 --> 00:35:30,820
you have the platform hierarchy,

00:35:30,820 --> 00:35:32,670
which is controlled by the BIOS,

00:35:32,670 --> 00:35:35,260
and you have the lockout authority.

00:35:35,260 --> 00:35:39,700
And taking ownership of the TPM can mean any of those.

00:35:39,700 --> 00:35:41,270
The most important one is, I guess,

00:35:41,270 --> 00:35:43,223
definitely seeing the lockout auth,

00:35:44,090 --> 00:35:46,390
because that's the authorization

00:35:46,390 --> 00:35:51,230
that can be used to reset the dictionary attack counters.

00:35:51,230 --> 00:35:53,610
So from that perspective,

00:35:53,610 --> 00:35:56,370
I guess it's not too much of a problem.

00:35:56,370 --> 00:35:58,740
Usually you would probably also want to protect

00:35:58,740 --> 00:36:03,190
your endorsement hierarchy, so the privacy aspects

00:36:03,190 --> 00:36:04,740
of the TPM.

00:36:04,740 --> 00:36:08,010
Again, this is not a problem for us to store stuff

00:36:08,010 --> 00:36:09,910
on the MV space of the TPM,

00:36:09,910 --> 00:36:11,640
so what remains is the storage hierarchy.

00:36:11,640 --> 00:36:14,780
So far I've only seen people use nolauth

00:36:14,780 --> 00:36:17,240
for the storage hierarchy, thankfully.

00:36:17,240 --> 00:36:22,240
But, we are also following the TCG guidance on,

00:36:24,940 --> 00:36:27,120
what is it called, EK certificate

00:36:27,120 --> 00:36:31,750
and the TPM provisioning guidance documents.

00:36:31,750 --> 00:36:34,400
And those basically more or less reflect

00:36:34,400 --> 00:36:36,860
what also microsoft is doing on Windows.

00:36:36,860 --> 00:36:40,130
So we wanna be able to support that, definitely.

00:36:40,130 --> 00:36:42,520
But you will not have most probably

00:36:42,520 --> 00:36:46,310
is easy interchangeability of key formats

00:36:46,310 --> 00:36:51,310
unless you're using this TSS on Windows as well, yeah.

00:36:51,340 --> 00:36:52,173
- Okay. - So.

00:36:54,100 --> 00:36:56,547
- [Audience Member] So on Windows there's actually a concept

00:36:56,547 --> 00:36:58,830
to be able to disable Bitlocker.

00:36:58,830 --> 00:37:01,890
And some of the firmware upgrading tools on Windows will,

00:37:01,890 --> 00:37:03,200
with the correct administrative rights,

00:37:03,200 --> 00:37:05,440
will disable Bitlocker so that you'll come back

00:37:05,440 --> 00:37:07,220
and you'll be able to reseal it properly

00:37:07,220 --> 00:37:08,470
the next time you boot.

00:37:08,470 --> 00:37:09,850
Have you thought about looking at anything similar

00:37:09,850 --> 00:37:11,370
with cryptsetup?

00:37:11,370 --> 00:37:14,203
- Basically that's what currently is supported.

00:37:15,193 --> 00:37:19,397
What you can do is you can add a key slot to LUKS

00:37:20,390 --> 00:37:22,910
with another password, do a reboot,

00:37:22,910 --> 00:37:27,170
and somehow tell initrd to then, after the reboot,

00:37:27,170 --> 00:37:30,150
create a new key slot with a TPM binding,

00:37:30,150 --> 00:37:33,700
and remove the key slot with another password

00:37:33,700 --> 00:37:36,040
and the old one, so that would be totally possible.

00:37:36,040 --> 00:37:39,970
It's merely a matter of adding a 10-line script

00:37:39,970 --> 00:37:41,360
to initrd, I guess.

00:37:41,360 --> 00:37:42,638
- [Audience Member] Well and getting

00:37:42,638 --> 00:37:43,860
all the distros to adopt that, I guess.

00:37:43,860 --> 00:37:45,670
- I think a lot of this stuff is,

00:37:45,670 --> 00:37:48,210
I dunno how many initrd systems we currently have,

00:37:48,210 --> 00:37:50,460
and how many more are currently in the plannings.

00:37:50,460 --> 00:37:51,960
Oh, six? - Eight.

00:37:51,960 --> 00:37:53,980
- Eight, nice.

00:37:53,980 --> 00:37:55,861
How many more are in the planning.

00:37:55,861 --> 00:37:57,343
- [Audience Member] I'm writing two.

00:37:57,343 --> 00:37:59,363
- Okay, so we're up to 10.

00:38:01,180 --> 00:38:03,820
So I think that that's the big issue here.

00:38:03,820 --> 00:38:06,720
We need to be able to somehow, I dunno,

00:38:06,720 --> 00:38:10,240
I'm trying to do it at upstream first,

00:38:10,240 --> 00:38:14,650
enabling libcryptsetup to have the capability to begin with,

00:38:14,650 --> 00:38:16,320
and then we can think about how this

00:38:16,320 --> 00:38:20,390
can trickle down into, I dunno, system D into Drakoo,

00:38:20,390 --> 00:38:23,343
into update interval and so on, and so on, and so on.

00:38:24,220 --> 00:38:29,220
Maybe have a GRUP module for cryptsetup with TPM support.

00:38:29,290 --> 00:38:30,803
I dunno. - Maybe not.

00:38:32,010 --> 00:38:34,454
- [Audience Member] It does support PLEX studio,

00:38:34,454 --> 00:38:35,750
that's important.

00:38:35,750 --> 00:38:37,730
- Cool. - GRUP itself.

00:38:37,730 --> 00:38:41,290
- Yep, well we only need to add libjsonc

00:38:41,290 --> 00:38:43,660
and then you're fine, I guess.

00:38:43,660 --> 00:38:45,920
- [Audience Member] So one more thing to mention,

00:38:45,920 --> 00:38:49,470
there was a mention that there was PCR0 field on LVFS,

00:38:49,470 --> 00:38:52,950
and that's true, but there's actually multiple PCR0 values

00:38:52,950 --> 00:38:54,870
you can have for a given machine.

00:38:54,870 --> 00:38:58,550
Depending on the ME or depending on certain SKUs,

00:38:58,550 --> 00:38:59,660
so it's gonna be very difficult

00:38:59,660 --> 00:39:03,183
to predictably build PCR0 unless you knew all those details.

00:39:07,230 --> 00:39:10,330
- I would currently be most already happy I guess

00:39:10,330 --> 00:39:13,670
if someone would come up with correct schemes

00:39:13,670 --> 00:39:17,610
and correct scripts to integrate a kernel update

00:39:17,610 --> 00:39:20,650
into the precalculation of the PCR measurements

00:39:20,650 --> 00:39:23,890
to do the resealing of those values.

00:39:23,890 --> 00:39:25,789
I think that's, at least for me,

00:39:25,789 --> 00:39:28,920
I go from the later stages to the earlier stages

00:39:28,920 --> 00:39:32,320
of the boot chain, but I guess we can come from both ends

00:39:32,320 --> 00:39:33,470
and meet in the middle.

00:39:35,980 --> 00:39:38,880
- [Audience Member] Just kernel work with that BIOS thing.

00:39:41,080 --> 00:39:44,520
The ability to actually read the log correctly is new in 5.3

00:39:44,520 --> 00:39:47,113
so it hasn't had a lot of time yet.

00:39:49,550 --> 00:39:51,220
- Matthew has patch, right?

00:39:51,220 --> 00:39:52,053
- [Audience Member] Amongst others.

00:39:52,053 --> 00:39:53,017
- Amongst others?

00:39:57,813 --> 00:40:01,163
All right, I guess it's three minutes left, so.

00:40:02,700 --> 00:40:03,833
Talk to me outside.

00:40:05,070 --> 00:40:07,742

YouTube URL: https://www.youtube.com/watch?v=XUFUw_UR1qc


