Title: LPC2019 - Linux kernel fastboot on the way
Publication date: 2019-11-18
Playlist: LPC2019 - LPC Main Track
Description: 
	Linux kernel fastboot on the way

Speaker
Mr Feng Tang

Description
Linux kernel fastboot is critical for all kinds of platforms: from embedded/smartphone to desktop/cloud, and it has been hugely improved over years. But, is it all done? Not yet!

This topic will first share the optimizations done for our platform, which cut the kernel (inside a VM) bootime from 3000ms to 300ms, and then list the future potential optimization points.

Here are our optimizations:
1. really enable device drivers' asynchronous probing, like i915 to improve boot parallelization
2. deferred memory init leveraging memory hotplug feature
3. Optimize rootfs mounting (including storage driver and mounting)
4. kernel modules and configs optimization
5. reduce the hypervisor cost
6. tools for profiling/analyzing

Potential optimizations spots for future, which needs discussion and collaboration from the whole community:
1. how to make maximal use of multi-core and effectively distribute boot tasks to each core
2. smp init for each CPU core costs about 8ms, a big burden for large systems
3. force highest cpufreq as early as possible (kernel decompress time)
4. devices enumeration for firmware (like ACPI) set to be parallel
5. in-kernel deferred memory init (for 4GB+ platform)
6. user space optimization like systemd
Captions: 
	00:00:00,120 --> 00:00:02,340
- Hello, everyone, I'm Feng Tang.

00:00:02,340 --> 00:00:03,600
I come from China,

00:00:03,600 --> 00:00:06,650
and I work for the Intel Linux System Engineering,

00:00:06,650 --> 00:00:09,360
previously the Open Source Technology Center.

00:00:09,360 --> 00:00:11,583
So today I will talk about the fastboot.

00:00:16,267 --> 00:00:17,617
So here is some background.

00:00:18,600 --> 00:00:22,370
I think everybody wants his Linux devices to boot faster,

00:00:22,370 --> 00:00:26,810
no matter whether it's an embedded device like your phone,

00:00:26,810 --> 00:00:29,003
the laptop, desktop, or the servers.

00:00:30,436 --> 00:00:31,703
And back in 2008,

00:00:33,515 --> 00:00:36,137
Arjan and Auke had introduced their

00:00:36,137 --> 00:00:38,120
"Booting Linux in Five Seconds."

00:00:38,120 --> 00:00:41,470
I think at that time, it was a big whoa-whoa.

00:00:41,470 --> 00:00:44,093
And yeah, at that time, I was very impressed.

00:00:45,960 --> 00:00:50,463
And recently, the kernel boot time has been improved hugely,

00:00:52,314 --> 00:00:54,893
but for this audience,

00:00:56,090 --> 00:00:59,023
I will show you how still a lot of things can do.

00:01:04,760 --> 00:01:06,550
Sorry, oh, here's an agenda.

00:01:06,550 --> 00:01:08,800
So my talk will be two parts.

00:01:08,800 --> 00:01:10,250
The first one will be sharing

00:01:11,730 --> 00:01:13,553
what we have done for our platform.

00:01:15,930 --> 00:01:17,380
The next one will be discussing

00:01:17,380 --> 00:01:20,553
the potential optimization points, what we can do next.

00:01:24,000 --> 00:01:28,410
So here's the reason we need to do the boot optimization.

00:01:28,410 --> 00:01:32,820
Because while we were working on the automotive solution,

00:01:32,820 --> 00:01:34,110
and there's a high requirement

00:01:34,110 --> 00:01:38,450
for the United States Department of Transportation

00:01:38,450 --> 00:01:40,960
that the rear camera must be functional

00:01:40,960 --> 00:01:43,763
after you press a power button, in two seconds.

00:01:44,820 --> 00:01:49,100
And in that platform, the boot includes several phases,

00:01:49,100 --> 00:01:52,720
including the hardware power on, the firmware,

00:01:52,720 --> 00:01:55,800
the bootloader, the hypervisor, and the

00:01:57,180 --> 00:01:58,563
kernel and user space,

00:01:59,410 --> 00:02:03,383
and pre-kernel already took about 500 milliseconds,

00:02:04,510 --> 00:02:08,743
and the budget left for us is about 400 milliseconds.

00:02:10,050 --> 00:02:13,090
Since it's running on hypervisor,

00:02:13,090 --> 00:02:16,237
the initial kernel boot time is about 300.

00:02:16,237 --> 00:02:18,210
Sorry, three seconds,

00:02:18,210 --> 00:02:22,750
and finally we cut it to about 300 milliseconds,

00:02:22,750 --> 00:02:24,990
which meets the requirement,

00:02:24,990 --> 00:02:27,703
and the car is close to mass production.

00:02:31,220 --> 00:02:32,860
Here's platform info.

00:02:32,860 --> 00:02:36,983
So this platform is the best on the statistics.

00:02:37,830 --> 00:02:39,220
So it has

00:02:39,220 --> 00:02:40,910
four core CPU

00:02:43,288 --> 00:02:45,360
with eight gigabytes of RAM,

00:02:45,360 --> 00:02:50,083
and it uses the EMMC card as the root file system.

00:02:51,610 --> 00:02:52,660
So for info,

00:02:52,660 --> 00:02:56,330
we can see that we are running on top of a hypervisor

00:02:56,330 --> 00:02:59,480
because automotive needs some isolation

00:02:59,480 --> 00:03:01,120
for security reasons,

00:03:01,120 --> 00:03:04,930
so we're running based on the hypervisor,

00:03:04,930 --> 00:03:06,928
which is called ACRN.

00:03:06,928 --> 00:03:09,640
Recently, the first batch of these patches

00:03:09,640 --> 00:03:12,370
has been loaded to the upstream kernel.

00:03:12,370 --> 00:03:14,573
And then in the left,

00:03:17,020 --> 00:03:19,420
this is very similar to the Xen.

00:03:19,420 --> 00:03:21,380
The left side is like the dm-0,

00:03:21,380 --> 00:03:23,613
which is a server OS,

00:03:24,760 --> 00:03:28,320
and we're using the Clear Linux as the server OS,

00:03:28,320 --> 00:03:32,123
and it's running with 4.19 kernel.

00:03:35,820 --> 00:03:38,780
Here we talk about the methodology.

00:03:38,780 --> 00:03:40,500
So I think everybody knows this.

00:03:40,500 --> 00:03:42,373
So it has three steps.

00:03:43,240 --> 00:03:45,822
The first one would be profiling,

00:03:45,822 --> 00:03:47,623
which would be mirroring the data.

00:03:48,590 --> 00:03:52,810
Then on to analyzing to find the hotspots.

00:03:52,810 --> 00:03:57,810
And then the optimization, and this is a recursive process.

00:03:58,340 --> 00:04:02,670
We optimize one point, and then to the next, and the next,

00:04:02,670 --> 00:04:04,303
until we meet the target.

00:04:07,670 --> 00:04:11,210
Next one is first to do the boot optimization,

00:04:11,210 --> 00:04:15,873
we need to get the accurate kernel boot time,

00:04:16,820 --> 00:04:18,960
and currently,

00:04:18,960 --> 00:04:23,427
I think the boot time could be divided to three phases.

00:04:23,427 --> 00:04:26,043
The first part is kernel decompression.

00:04:27,242 --> 00:04:29,263
Then the second is dark phase.

00:04:30,540 --> 00:04:35,097
We all see in our kernel message log, starting with a zero,

00:04:36,800 --> 00:04:39,563
and then there's the normal timestamp.

00:04:41,470 --> 00:04:45,363
A zero because that clock is not initialized yet.

00:04:46,210 --> 00:04:50,960
So here you can see, it's just like the sunrise,

00:04:50,960 --> 00:04:54,250
before the sunrise, where it's all dark.

00:04:54,250 --> 00:04:55,573
We don't know the time.

00:04:58,600 --> 00:05:01,343
Next is about how to check the kernel boot time.

00:05:02,600 --> 00:05:04,850
We have several ways.

00:05:04,850 --> 00:05:09,850
We have the systemd-analyze, which comes with systemd.

00:05:09,850 --> 00:05:13,483
And we can also check from the printk timestamp,

00:05:14,480 --> 00:05:16,740
and that's the one where we can just check,

00:05:16,740 --> 00:05:20,943
find the keywords, running something as the initial process.

00:05:23,540 --> 00:05:28,540
But these commands are not accurate enough.

00:05:28,780 --> 00:05:31,013
We can see from the right picture.

00:05:31,956 --> 00:05:34,556
The systemd-analyze will naturally tell you the time

00:05:35,520 --> 00:05:39,163
for the normal phase plus the user space loading.

00:05:45,314 --> 00:05:46,770
And

00:05:46,770 --> 00:05:49,470
to run something as the init,

00:05:49,470 --> 00:05:52,033
it actually just shows a normal phase.

00:05:53,780 --> 00:05:57,743
So to get the real boot time, we need some tools.

00:06:00,293 --> 00:06:02,180
Here it talks about, just briefly,

00:06:02,180 --> 00:06:05,490
the profiling tools we've used.

00:06:05,490 --> 00:06:08,600
So the initcall debug is very key,

00:06:08,600 --> 00:06:13,423
and beyond that, we have the very powerful tool, bootchart,

00:06:14,300 --> 00:06:18,853
which can give us a good view of how the time is spent.

00:06:20,180 --> 00:06:25,040
And next is printk with absolute timestamp.

00:06:25,040 --> 00:06:26,403
On the last slide,

00:06:27,770 --> 00:06:31,393
I said that is all the existing tools.

00:06:33,840 --> 00:06:38,070
Actually, I don't give the right time.

00:06:38,070 --> 00:06:42,220
The only thing we can trust is actually the timer.

00:06:42,220 --> 00:06:44,350
For the X86, it's the TSC.

00:06:45,760 --> 00:06:49,070
After the system is powered on, it's just increasing

00:06:51,539 --> 00:06:52,372
the fixed rate.

00:06:53,890 --> 00:06:58,233
So during our profiling, we have our own printk

00:06:58,233 --> 00:07:00,140
with the absolute timestamp,

00:07:00,140 --> 00:07:04,463
and we can load actual time which have been spent.

00:07:10,680 --> 00:07:11,513
Next

00:07:12,497 --> 00:07:13,330
is the tools

00:07:14,450 --> 00:07:16,623
to check the hotspots.

00:07:18,380 --> 00:07:22,463
With these tools, with bootchart, with printk time,

00:07:22,463 --> 00:07:23,450
with the initcall debug,

00:07:23,450 --> 00:07:26,730
we can also check many things from

00:07:27,988 --> 00:07:29,970
the picture from the log,

00:07:29,970 --> 00:07:32,879
but still there are things missing,

00:07:32,879 --> 00:07:35,970
because for some functions which are not covered

00:07:35,970 --> 00:07:40,030
by the initcall debug, we don't know it,

00:07:40,030 --> 00:07:44,130
and we need to give some special care to them.

00:07:44,130 --> 00:07:45,999
Simply we can just add some printk

00:07:45,999 --> 00:07:50,163
in the entrance and exit of that function.

00:07:53,570 --> 00:07:57,290
Also there would be something

00:07:57,290 --> 00:08:00,700
hiding in this bootchart picture.

00:08:00,700 --> 00:08:03,417
It's asynchronous initialization.

00:08:05,378 --> 00:08:06,290
It will hide a lot of things from the log or the bootchart,

00:08:11,720 --> 00:08:13,793
and we need to manually dump them.

00:08:19,037 --> 00:08:23,540
All the tools we use is just to find the real hotspots

00:08:26,522 --> 00:08:27,803
and the real hotspots.

00:08:32,030 --> 00:08:33,800
The next one is analyze.

00:08:33,800 --> 00:08:36,523
So with profile tools,

00:08:37,740 --> 00:08:41,103
we need to get the whole picture of the boot process.

00:08:42,600 --> 00:08:45,410
That is, we need to know every millisecond,

00:08:45,410 --> 00:08:46,683
where it is used,

00:08:50,052 --> 00:08:52,880
and then we need to check how

00:08:52,880 --> 00:08:54,800
and why it took so much time

00:08:56,150 --> 00:08:59,833
and whether it is really necessary to take so much time.

00:09:03,700 --> 00:09:06,403
By this, we can find the hotspots.

00:09:10,550 --> 00:09:13,620
So there are three major hotspots

00:09:13,620 --> 00:09:16,703
which consume much time in the boot process.

00:09:18,446 --> 00:09:20,913
One is kind of the workaround for the drivers.

00:09:23,530 --> 00:09:25,797
Also there will be some unnecessary modules

00:09:25,797 --> 00:09:27,713
and configures building the kernel.

00:09:29,500 --> 00:09:32,573
We need to get rid of them one by one.

00:09:36,095 --> 00:09:37,470
And then also there is

00:09:39,521 --> 00:09:42,111
some unexpected small functions.

00:09:42,111 --> 00:09:46,203
You can overlook them, but they actually take a lot of time,

00:09:47,140 --> 00:09:49,473
so we have to profile very carefully.

00:09:55,020 --> 00:09:59,940
So the next one shows how the profile

00:09:59,940 --> 00:10:00,773
results,

00:10:01,890 --> 00:10:05,093
which the upper one is the whole system

00:10:06,771 --> 00:10:10,190
from when you press the power button.

00:10:10,190 --> 00:10:12,150
It goes through the hardware.

00:10:12,150 --> 00:10:14,960
There's some power management, I see,

00:10:14,960 --> 00:10:19,960
and then it goes to the firmware init, then the bootloader.

00:10:20,690 --> 00:10:22,070
The purple one, the small one,

00:10:22,070 --> 00:10:24,553
is the hypervisor initialization time.

00:10:25,410 --> 00:10:30,403
And then comes the kernel part, and next is user space.

00:10:32,820 --> 00:10:37,820
For the kernel part, the lower one is kind of a breakdown.

00:10:40,772 --> 00:10:45,280
It just lists from the time point of view.

00:10:45,280 --> 00:10:48,800
For the biggest time consumer for our kernel boot

00:10:49,800 --> 00:10:52,840
so we can see the kernel decompression,

00:10:52,840 --> 00:10:56,593
the memory initialization, the SMP init,

00:10:57,740 --> 00:11:02,740
which means you bring up all the long BSP boot processors.

00:11:03,970 --> 00:11:05,713
And next one is firmware init.

00:11:07,700 --> 00:11:10,720
It actually enumerates

00:11:10,720 --> 00:11:11,586
all the devices,

00:11:11,586 --> 00:11:15,683
most of the devices in the system and those from the tables.

00:11:17,210 --> 00:11:22,210
Next mostly is just driver stuff, the graphics, the storage,

00:11:23,240 --> 00:11:24,723
some I/O controllers.

00:11:25,680 --> 00:11:28,793
And the last one is the file system mounting.

00:11:33,560 --> 00:11:34,393
So,

00:11:35,340 --> 00:11:39,073
here is just an overview of all the hotspots.

00:11:42,090 --> 00:11:45,870
It's driver asynchronous probing,

00:11:45,870 --> 00:11:48,893
the root file system mounting, the memory initialization,

00:11:49,880 --> 00:11:52,260
the kernel modules and the kernel configs,

00:11:52,260 --> 00:11:55,013
and the graphics is a big part of our boot process,

00:11:56,360 --> 00:11:58,793
and the last on is virtualization cost.

00:12:03,140 --> 00:12:06,210
Here is some profile data.

00:12:06,210 --> 00:12:08,800
The green means it used to be a big trouble,

00:12:08,800 --> 00:12:10,673
and we can solve them.

00:12:12,848 --> 00:12:17,848
And the black ones means the current status.

00:12:18,054 --> 00:12:20,050
It lists some of the most time-consuming

00:12:20,050 --> 00:12:21,713
of the final platform.

00:12:22,900 --> 00:12:26,550
And yeah, we hope we can still improve more,

00:12:26,550 --> 00:12:28,783
but we will talk about it later.

00:12:30,870 --> 00:12:31,703
So,

00:12:33,900 --> 00:12:37,400
the driver asynchronous probe framework

00:12:37,400 --> 00:12:39,713
was actually set up 10 years ago,

00:12:40,580 --> 00:12:43,483
but rare drivers really use it.

00:12:45,980 --> 00:12:46,813
And

00:12:48,810 --> 00:12:50,670
so it's pretty simple

00:12:50,670 --> 00:12:53,450
if we use the asynchronous probing.

00:12:53,450 --> 00:12:56,143
We can put the initial tasks onto the modules,

00:12:58,391 --> 00:13:02,670
and they will be right in parallel and save a lot of time.

00:13:04,590 --> 00:13:07,480
So to do that, it's

00:13:07,480 --> 00:13:08,313
simple.

00:13:08,313 --> 00:13:11,223
You can just set the driver's probe type.

00:13:13,580 --> 00:13:16,870
And also there's another way to try that's easy to try.

00:13:16,870 --> 00:13:19,490
If you want just to try on your own system,

00:13:19,490 --> 00:13:21,690
you can use the last

00:13:23,510 --> 00:13:24,343
sentence.

00:13:24,343 --> 00:13:25,953
Just add them to the command line,

00:13:27,890 --> 00:13:32,050
just to see if this asynchronous probing can.

00:13:32,050 --> 00:13:33,250
If it can save time

00:13:33,250 --> 00:13:36,710
on your own platform without booting a new kernel,

00:13:36,710 --> 00:13:38,613
just using the existing one.

00:13:38,613 --> 00:13:40,350
Change the command line.

00:13:43,150 --> 00:13:46,693
So next is a picture of the original boot.

00:13:47,850 --> 00:13:52,850
So we can see here, most of them, the driver boot,

00:13:56,120 --> 00:13:59,140
the only one good thing is the MMC driver.

00:13:59,140 --> 00:13:59,973
Oh, sorry.

00:14:01,018 --> 00:14:04,470
It already uses asynchronous probe.

00:14:04,470 --> 00:14:07,850
It put its probe scanning function into a worker

00:14:09,525 --> 00:14:11,883
so that it could run in parallel.

00:14:15,040 --> 00:14:15,957
Next one is

00:14:17,397 --> 00:14:20,030
the boot with asynchronous probing.

00:14:20,030 --> 00:14:23,743
We can see many drivers are running in parallel.

00:14:26,115 --> 00:14:28,780
And then we can see we've got about

00:14:30,580 --> 00:14:32,150
20% improvement

00:14:33,410 --> 00:14:37,523
just to simply make them synchronous.

00:14:38,882 --> 00:14:43,530
So I think what we can do is just check our drivers

00:14:43,530 --> 00:14:44,570
to see if there

00:14:45,800 --> 00:14:46,633
could be

00:14:47,530 --> 00:14:48,880
use of synchronous probing.

00:14:50,040 --> 00:14:53,353
It could benefit all the platforms running by these drivers.

00:14:57,690 --> 00:14:59,803
Next one is the root file system mounting,

00:15:00,640 --> 00:15:02,163
which is a critical chain.

00:15:03,700 --> 00:15:04,533
And

00:15:06,600 --> 00:15:07,660
the problem we've met

00:15:07,660 --> 00:15:10,253
is mostly about the driver's efficiency.

00:15:12,370 --> 00:15:14,350
Our platform,

00:15:14,350 --> 00:15:15,183
even

00:15:16,950 --> 00:15:19,820
as I said, we are using the EMMC card

00:15:19,820 --> 00:15:21,910
as the root file system.

00:15:21,910 --> 00:15:25,510
Still, the SATA initialization takes about

00:15:27,280 --> 00:15:28,503
up to 200 milliseconds,

00:15:32,274 --> 00:15:35,420
and the real file system root storage

00:15:35,420 --> 00:15:38,503
takes about 40 to 100 milliseconds.

00:15:40,963 --> 00:15:43,510
Since it's a critical chain, we just wanted it

00:15:45,060 --> 00:15:48,280
to run as quick as possible,

00:15:48,280 --> 00:15:52,350
so we did something.

00:15:52,350 --> 00:15:56,920
We moved the driver to the earliest stage of the

00:15:58,039 --> 00:16:01,240
init, which is by changing the MMC file.

00:16:01,240 --> 00:16:02,890
It's ordering an entire MMC file.

00:16:03,910 --> 00:16:06,770
And we also disabled in our platform.

00:16:06,770 --> 00:16:11,770
We have several controllers for the SD host controllers.

00:16:12,020 --> 00:16:14,853
We disabled the not used ones,

00:16:16,020 --> 00:16:19,383
and we also disabled the nonused protocols,

00:16:22,680 --> 00:16:24,640
and also removed some

00:16:26,264 --> 00:16:28,433
hacky delay inside the original driver.

00:16:33,430 --> 00:16:37,936
So the last note is about we need to add rootwait cue

00:16:37,936 --> 00:16:39,500
to command line.

00:16:39,500 --> 00:16:41,870
It will tell you that is how much time

00:16:41,870 --> 00:16:43,980
your system is working

00:16:43,980 --> 00:16:46,023
for your root file system to be ready.

00:16:48,190 --> 00:16:51,250
Initially, it was about several hundred milliseconds

00:16:51,250 --> 00:16:54,750
in our system, and with these optimizations,

00:16:54,750 --> 00:16:56,463
they are solved.

00:16:59,590 --> 00:17:02,823
Next one is about the deferred memory initialization.

00:17:04,580 --> 00:17:05,413
So

00:17:06,890 --> 00:17:09,083
our system has eight gigabytes,

00:17:09,930 --> 00:17:12,690
and they cost more than 100 milliseconds.

00:17:12,690 --> 00:17:16,140
It was actually about 150 initially.

00:17:16,140 --> 00:17:17,600
And actually, in our early boot,

00:17:17,600 --> 00:17:20,850
we don't need that much memory, and

00:17:22,440 --> 00:17:25,350
with the memory hotplug feature,

00:17:25,350 --> 00:17:27,910
we just during the boot phase,

00:17:27,910 --> 00:17:30,520
we initialize about two gigabytes,

00:17:30,520 --> 00:17:34,561
and in the user space, to initialize the rest.

00:17:34,561 --> 00:17:37,793
Okay?

00:17:41,500 --> 00:17:44,710
- [Audience Member] I think for this particular use case,

00:17:44,710 --> 00:17:47,830
hotplug feature is probably not the best

00:17:47,830 --> 00:17:52,061
because currently, a deferred memory initialization,

00:17:52,061 --> 00:17:54,480
I mean, kernel supports deferred memory initialization

00:17:54,480 --> 00:17:57,740
where you can initialize memory after SMP,

00:17:57,740 --> 00:18:02,050
so it also could be used to initialize track pages,

00:18:02,050 --> 00:18:04,930
and virtually, it would eliminate, like,

00:18:04,930 --> 00:18:09,580
all 150 milliseconds that you use to initialize memory.

00:18:09,580 --> 00:18:13,120
But as of right now, it only works per

00:18:14,390 --> 00:18:16,940
node, and since it's a single node system--

00:18:16,940 --> 00:18:18,100
- Yeah, yeah. - It won't work.

00:18:18,100 --> 00:18:20,400
But there is a set of patches flying around.

00:18:20,400 --> 00:18:25,400
There is like, ktasks, which also initialize memory

00:18:26,130 --> 00:18:29,470
right after SMP, so you could remove all the hotspots

00:18:29,470 --> 00:18:32,790
apart from the kernel and won't have to spend the time

00:18:32,790 --> 00:18:34,509
initializing the first gigabyte and so on.

00:18:34,509 --> 00:18:36,548
It would be still much faster.

00:18:36,548 --> 00:18:39,608
- Yeah, I don't know the exact status,

00:18:39,608 --> 00:18:42,554
but in the following improvements, I actually mentioned,

00:18:42,554 --> 00:18:44,445
we can use some key strategies

00:18:44,445 --> 00:18:48,028
to defer the memory initializing in kernel.

00:18:49,944 --> 00:18:53,345
You said kernel already has this feature?

00:18:53,345 --> 00:18:54,962
- [Audience Member] Deferred memory initialization

00:18:54,962 --> 00:18:56,164
is part of the kernel.

00:18:56,164 --> 00:19:00,826
- Yes, there is deferred memory initialization configure,

00:19:00,826 --> 00:19:04,743
but I don't think that's these kinds of things.

00:19:09,544 --> 00:19:11,377
- What I mean is that,

00:19:12,254 --> 00:19:13,087
with this,

00:19:14,072 --> 00:19:16,830
with initializing the first two gigabytes of memory

00:19:16,830 --> 00:19:19,660
and then initializing the rest by hotplugging it later,

00:19:19,660 --> 00:19:24,230
you basically delay the rest of the memory initialization

00:19:24,230 --> 00:19:27,230
to the hotplug phase to the user space

00:19:27,230 --> 00:19:29,410
when you have other CPU's doing some other work

00:19:29,410 --> 00:19:31,470
starting the user processes.

00:19:31,470 --> 00:19:34,930
But you can initialize all the memory fast

00:19:34,930 --> 00:19:36,773
right after SMP before the user space?

00:19:36,773 --> 00:19:38,530
- [Feng] Yeah, okay, that is the point, yeah, yeah.

00:19:38,530 --> 00:19:40,007
- If you use-- - I mention that.

00:19:40,007 --> 00:19:41,272
- The different memory initialization plus--

00:19:41,272 --> 00:19:43,079
- [Feng] We'll talk about it, yeah, yeah.

00:19:43,079 --> 00:19:44,280
- [Audience Member] Yes, plus the ktask patches.

00:19:44,280 --> 00:19:45,990
- Yeah, the kernel one, yeah, yeah, yeah, yeah, exactly.

00:19:45,990 --> 00:19:47,710
Okay, yeah.

00:19:47,710 --> 00:19:48,640
That would be

00:19:50,370 --> 00:19:51,593
almost the same thing.

00:19:54,190 --> 00:19:55,490
It's about what we can do.

00:19:57,050 --> 00:20:00,090
Next one is about the CPU frequency.

00:20:00,090 --> 00:20:02,663
The CPU frequency actually matters a lot,

00:20:03,600 --> 00:20:08,330
especially for those without IO operations.

00:20:08,330 --> 00:20:10,293
For example, the decompression.

00:20:12,090 --> 00:20:12,923
In

00:20:14,548 --> 00:20:18,690
our kernel, our CPU usually runs at 1.9 gigahertz,

00:20:20,270 --> 00:20:25,250
and it has a turbo mode, which is running at 2.4 gigahertz.

00:20:25,250 --> 00:20:27,360
If we force it to run the

00:20:29,249 --> 00:20:30,860
2.4 gigahertz,

00:20:30,860 --> 00:20:35,860
we'll get a lot of improvement for the overall boot time.

00:20:35,920 --> 00:20:36,753
And

00:20:38,880 --> 00:20:41,240
because CPU frequency usually is set

00:20:41,240 --> 00:20:43,045
by the BIOS on the firmware,

00:20:43,045 --> 00:20:46,817
and the kernel is only controlled by, and too,

00:20:46,817 --> 00:20:50,593
the CPU frequency at subsystem getting initialized,

00:20:53,160 --> 00:20:56,040
so my question here would be:

00:20:56,040 --> 00:21:01,040
Can we enable it and make it a kernel config option

00:21:01,090 --> 00:21:03,173
so that we can benefit from it?

00:21:05,136 --> 00:21:07,810
I know it depends on platform.

00:21:07,810 --> 00:21:10,800
If we force the highest frequency,

00:21:10,800 --> 00:21:15,460
it may hurt some hardware, but if there is some option,

00:21:15,460 --> 00:21:18,210
that would be very

00:21:18,210 --> 00:21:19,043
cool.

00:21:26,420 --> 00:21:29,500
- Maybe work with, say, firmware standards bodies

00:21:29,500 --> 00:21:32,480
to give us, say, user-defined phase

00:21:32,480 --> 00:21:34,440
to change the core frequency

00:21:34,440 --> 00:21:37,930
and then just in the Linux boot step, call that,

00:21:37,930 --> 00:21:38,763
because I don't know

00:21:38,763 --> 00:21:43,630
if you want to have 500 different frequency drivers

00:21:43,630 --> 00:21:46,360
in an early boot-up called for a generic distro kernel.

00:21:46,360 --> 00:21:50,570
But firmware already has to be able to set something up,

00:21:50,570 --> 00:21:54,600
so we could at least enable the kernel call into firmware

00:21:54,600 --> 00:21:56,440
to set the frequency right when we join,

00:21:56,440 --> 00:21:57,920
when we enter the kernel, right?

00:21:57,920 --> 00:22:01,440
- Yes, I'm for setting our frequencies just

00:22:05,340 --> 00:22:06,410
right into registers.

00:22:06,410 --> 00:22:10,470
It's very easy, but we raise a request to the firmware team.

00:22:10,470 --> 00:22:11,303
They don't care.

00:22:11,303 --> 00:22:14,540
- Why even request firmware to change the frequency?

00:22:14,540 --> 00:22:18,060
Why not, like, have this as a setting of the firmware?

00:22:18,060 --> 00:22:20,910
So basically when kernel is started, firmware already--

00:22:20,910 --> 00:22:22,230
- [Alex] 'Cause the firmware doesn't know

00:22:22,230 --> 00:22:23,063
when the kernel starts,

00:22:23,063 --> 00:22:25,480
and you don't necessarily want to run, say,

00:22:25,480 --> 00:22:29,200
the GRUB whole menu really fast.

00:22:29,200 --> 00:22:30,330
That's not useful.

00:22:30,330 --> 00:22:32,740
- Well, I mean, it can switch to the highest frequency

00:22:32,740 --> 00:22:34,000
right before dropping to the kernel.

00:22:34,000 --> 00:22:35,980
- [Alex] How do you know when you jump to the kernel?

00:22:35,980 --> 00:22:36,813
- The firmware knows when it jumps to the kernel.

00:22:36,813 --> 00:22:38,040
- [Alex] The firmware does not know

00:22:38,040 --> 00:22:38,873
when it jumps to the kernel.

00:22:38,873 --> 00:22:41,730
The firmware knows when it executes random EFI applications.

00:22:41,730 --> 00:22:42,563
That's what it knows.

00:22:42,563 --> 00:22:44,370
- [Audience Member] Right, but you have a setting

00:22:44,370 --> 00:22:46,640
that, like, before it executes--

00:22:46,640 --> 00:22:47,810
- [Alex] You mean exit boot services,

00:22:47,810 --> 00:22:49,990
and then just go, like, sure.

00:22:49,990 --> 00:22:52,177
That's the implicit way of doing it.

00:22:52,177 --> 00:22:53,240
- [Audience Member] Right, right.

00:22:53,240 --> 00:22:55,030
- But I personally would prefer

00:22:55,030 --> 00:22:56,510
if we just could make it explicit

00:22:56,510 --> 00:22:57,830
because maybe in another use case,

00:22:57,830 --> 00:22:59,790
you'd rather want to have the lowest frequency

00:22:59,790 --> 00:23:00,790
for other reasons.

00:23:00,790 --> 00:23:01,623
I don't know.

00:23:01,623 --> 00:23:02,680
Because your kernel just happens to know

00:23:02,680 --> 00:23:05,340
that it wants to run really slow now.

00:23:05,340 --> 00:23:06,500
- [Audience Member] It's still possible to do,

00:23:06,500 --> 00:23:08,543
but for all kind of boots, of course.

00:23:09,530 --> 00:23:12,370
- A generic interface kind of makes more sense in my book.

00:23:12,370 --> 00:23:14,327
So you're saying you requested that from your firmware team,

00:23:14,327 --> 00:23:15,840
and they didn't reply?

00:23:15,840 --> 00:23:18,695
- Yes, they are busy.

00:23:18,695 --> 00:23:22,580
So we chose to control it inside the kernel.

00:23:22,580 --> 00:23:25,790
So yeah, the chain is very simple.

00:23:25,790 --> 00:23:29,930
Just I think just one interface is fine,

00:23:29,930 --> 00:23:33,100
just to bump the frequency.

00:23:33,100 --> 00:23:34,440
- Yes, is that going to work

00:23:34,440 --> 00:23:36,760
across all CPU families, across all vendors,

00:23:36,760 --> 00:23:39,699
across all generations for the last 20 years?

00:23:39,699 --> 00:23:41,360
- Yes, that's a good question.

00:23:41,360 --> 00:23:44,950
So make it a kernel option.

00:23:44,950 --> 00:23:46,040
- [Alex] If you make it a kernel option,

00:23:46,040 --> 00:23:47,900
distros are not going to be able to pick it up.

00:23:47,900 --> 00:23:50,440
So if you want this to be a generic interface

00:23:50,440 --> 00:23:53,100
that anyone can use, it has to be something

00:23:53,100 --> 00:23:54,730
that is generically callable,

00:23:54,730 --> 00:23:57,100
and if it requires 500 kilobytes of code addition

00:23:57,100 --> 00:23:59,370
in early boot-up code, just to be able to configure

00:23:59,370 --> 00:24:02,190
all the different register configuration combinations

00:24:02,190 --> 00:24:03,100
that there are-- - Okay.

00:24:03,100 --> 00:24:04,473
- [Alex] It's not going to scale.

00:24:04,473 --> 00:24:05,306
- That would be more generic, yeah.

00:24:05,306 --> 00:24:06,580
- It needs to be some generic interface,

00:24:06,580 --> 00:24:08,760
and the platform is the one that knows how to configure it,

00:24:08,760 --> 00:24:10,560
so it kind of makes sense to use it.

00:24:11,765 --> 00:24:14,652
- [Feng] You want a higher and a lower frequency, right?

00:24:14,652 --> 00:24:17,750
- Just work hard with your guys, seriously.

00:24:17,750 --> 00:24:19,560
There has to be a way.

00:24:19,560 --> 00:24:20,393
- [Feng] Okay.

00:24:20,393 --> 00:24:22,402
- I think it's the one point where it makes the most sense.

00:24:22,402 --> 00:24:26,660
I mean, in u-boot, we do have code, for example,

00:24:26,660 --> 00:24:29,182
that does actually detect, like,

00:24:29,182 --> 00:24:31,470
when you enter the Linux kernel,

00:24:31,470 --> 00:24:34,460
it actually does configure the frequency to go up

00:24:34,460 --> 00:24:36,120
right at that point in time.

00:24:36,120 --> 00:24:38,800
There are those mechanisms around for firmware.

00:24:38,800 --> 00:24:41,430
It's just having something standardized and more explicit

00:24:41,430 --> 00:24:43,600
rather than implicit, and booting the kernel,

00:24:43,600 --> 00:24:45,380
it probably wants to be a fast mechanism.

00:24:45,380 --> 00:24:48,909
It makes more sense because on the other hand,

00:24:48,909 --> 00:24:52,100
what you don't want to get into is a situation

00:24:52,100 --> 00:24:56,410
where you boost up the frequency really high,

00:24:56,410 --> 00:24:58,990
and then the kernel does not have a CPU driver.

00:24:58,990 --> 00:25:00,630
So you keep it at a really high frequency

00:25:00,630 --> 00:25:03,540
and eventually just burn out your CPU, right?

00:25:03,540 --> 00:25:06,610
So you kind of want to give the control

00:25:06,610 --> 00:25:09,773
over whether you want to have that boost over to the OS.

00:25:10,720 --> 00:25:14,190
- Yeah, okay, you are talking about a more general solution.

00:25:14,190 --> 00:25:15,023
Yeah.

00:25:15,870 --> 00:25:16,703
Yeah.

00:25:16,703 --> 00:25:19,890
- [Audience Member] So what to do about non-UEFI firmware

00:25:19,890 --> 00:25:22,514
like u-boot just with device tree?

00:25:22,514 --> 00:25:24,380
- U-boot with just device tree can still use UEFI.

00:25:24,380 --> 00:25:25,213
That's fine.

00:25:25,213 --> 00:25:26,046
It's all there.

00:25:26,046 --> 00:25:27,990
Just ignore all the legacy boot path

00:25:27,990 --> 00:25:30,050
because nobody cares anymore.

00:25:30,050 --> 00:25:31,255
- [Audience Member] We do.

00:25:31,255 --> 00:25:32,400
(audience chuckles)

00:25:32,400 --> 00:25:34,170
- Then you might want to change your boot flow.

00:25:34,170 --> 00:25:36,370
I mean, there is even with u-boot these days.

00:25:36,370 --> 00:25:39,293
There's no reason not to use the UEFI boot path.

00:25:39,293 --> 00:25:40,126
- [Audience Member] Code size?

00:25:40,126 --> 00:25:41,440
- Say that again?

00:25:41,440 --> 00:25:42,360
- [Audience Member] Code size?

00:25:42,360 --> 00:25:45,740
- Do you know how much code size gets added

00:25:45,740 --> 00:25:47,733
by adding the UEFI option in u-boot?

00:25:48,970 --> 00:25:50,450
- [Feng] It's like--

00:25:50,450 --> 00:25:52,256
- [Audience Member] More than zero.

00:25:52,256 --> 00:25:53,089
- Say that again?

00:25:53,089 --> 00:25:53,922
- [Audience Member] More than zero.

00:25:53,922 --> 00:25:55,030
- It's more than zero, yes.

00:25:56,510 --> 00:25:58,560
But you can remove the FT support for it.

00:26:00,100 --> 00:26:02,330
- [Audience Member] So code size is one thing,

00:26:02,330 --> 00:26:04,970
and it slows down the kexec

00:26:04,970 --> 00:26:07,200
because kernel relocation is slow,

00:26:07,200 --> 00:26:11,703
but the second thing is that UEFI makes u-boot,

00:26:12,740 --> 00:26:15,110
like, boot slow because there's, like,

00:26:15,110 --> 00:26:17,070
more stuff that needs to be done

00:26:17,070 --> 00:26:20,060
prior to actually jumping to the kernel.

00:26:20,060 --> 00:26:23,440
In our experiments, it was, like, not too well done,

00:26:23,440 --> 00:26:24,583
like almost half a second, I think.

00:26:24,583 --> 00:26:26,580
- Half a second is definitely out of any league

00:26:26,580 --> 00:26:27,810
that we should see.

00:26:27,810 --> 00:26:30,520
If you're seeing half a second, we should work on it.

00:26:30,520 --> 00:26:33,620
Let's get down together and just improve that situation.

00:26:33,620 --> 00:26:34,453
- [Audience Member] Sure.

00:26:34,453 --> 00:26:35,940
- If we see anything in that boot flow

00:26:35,940 --> 00:26:38,376
that really gets us significantly slower,

00:26:38,376 --> 00:26:41,870
I'm not talking about, like, say, one/two milliseconds,

00:26:41,870 --> 00:26:42,770
even, yeah.

00:26:42,770 --> 00:26:47,370
That's along a timeline that I can certainly see you taking,

00:26:47,370 --> 00:26:51,190
but half a second is way off the charts, right?

00:26:51,190 --> 00:26:52,920
Yes, we need to load the kernel internally,

00:26:52,920 --> 00:26:54,593
but we do that in any boot path.

00:26:56,470 --> 00:26:59,240
Actually, if I stop callbacks and such,

00:26:59,240 --> 00:27:00,940
they shouldn't add too much to it.

00:27:03,334 --> 00:27:05,284
- True, I know you raised a good point.

00:27:06,532 --> 00:27:10,850
It was certainly with extreme performance.

00:27:10,850 --> 00:27:14,050
Yeah, if we want to apply to all platforms,

00:27:14,050 --> 00:27:16,460
we'll have to have a lot of trade-off,

00:27:16,460 --> 00:27:20,160
and if we just want to meet a specific requirement

00:27:20,160 --> 00:27:21,810
for one specific platform

00:27:21,810 --> 00:27:24,950
so you can do some not-so-decent way, right?

00:27:24,950 --> 00:27:27,330
- Yes, if you're doing a hack. - It's a good point, yeah.

00:27:27,330 --> 00:27:29,640
- [Alex] Then you do the hack in your firmware, right?

00:27:29,640 --> 00:27:30,473
- Yeah.

00:27:30,473 --> 00:27:31,320
- [Alex] Because, I mean, you as Intel,

00:27:31,320 --> 00:27:33,799
I'm sure you can change the firmware just fine.

00:27:33,799 --> 00:27:34,890
- It's not that easy.

00:27:34,890 --> 00:27:37,083
- Ah, you can change your firmware just fine.

00:27:38,040 --> 00:27:40,910
But if you want to have a generic mechanism,

00:27:40,910 --> 00:27:42,040
which I really think we should have.

00:27:42,040 --> 00:27:44,900
I think that's a great idea, boosting the kernel frequency

00:27:44,900 --> 00:27:48,040
on early boot is definitely a good way to get a faster boot,

00:27:48,040 --> 00:27:49,230
boot times.

00:27:49,230 --> 00:27:51,890
We should really talk about a generic interface.

00:27:51,890 --> 00:27:53,283
- Okay, thank you.

00:27:55,900 --> 00:27:59,820
So for this picture, I think it's pretty obvious,

00:27:59,820 --> 00:28:01,710
but I still keep it.

00:28:01,710 --> 00:28:04,031
So we use

00:28:04,031 --> 00:28:06,920
a loadable module when possible,

00:28:06,920 --> 00:28:10,840
and we disable everything not necessary.

00:28:10,840 --> 00:28:12,350
But we need to be careful.

00:28:12,350 --> 00:28:16,130
Something will break the kernel or panic.

00:28:16,130 --> 00:28:19,320
And we disable all the debug features

00:28:19,320 --> 00:28:20,530
for our release version.

00:28:20,530 --> 00:28:22,840
You know, the debug version will still have these,

00:28:22,840 --> 00:28:27,760
spinlock, mutex, and EF checks, good stuff,

00:28:27,760 --> 00:28:31,333
but for release, we disable them, all of them.

00:28:32,252 --> 00:28:34,253
And in the platform,

00:28:34,253 --> 00:28:37,100
we have a lot of high level controllers,

00:28:37,100 --> 00:28:39,070
but we don't actually use them.

00:28:39,070 --> 00:28:39,970
We disable them

00:28:40,910 --> 00:28:44,890
because every initialization will cost some time

00:28:46,520 --> 00:28:48,720
because also the kernel size matters.

00:28:48,720 --> 00:28:51,070
If we would use some module drivers,

00:28:51,070 --> 00:28:53,090
the kernel would be smaller.

00:28:53,090 --> 00:28:54,840
It would be faster loading

00:28:57,690 --> 00:28:59,380
and faster decompression.

00:28:59,380 --> 00:29:00,213
- [Alex] So in here, you're saying

00:29:00,213 --> 00:29:01,950
that you want to use modules

00:29:01,950 --> 00:29:05,770
rather than compile things into the kernel, right?

00:29:05,770 --> 00:29:06,917
- For the necessary ones.

00:29:06,917 --> 00:29:07,780
- [Alex] For the necessary ones.

00:29:07,780 --> 00:29:08,856
- Yeah.

00:29:08,856 --> 00:29:10,760
- [Alex] But you still want to use modules instead?

00:29:10,760 --> 00:29:12,870
Did you measure that modules actually are faster?

00:29:12,870 --> 00:29:14,193
I remember that a couple years ago,

00:29:14,193 --> 00:29:19,120
we did look at exactly that problem set of loading modules,

00:29:19,120 --> 00:29:22,060
and they actually ended up slowing the system down a lot.

00:29:22,060 --> 00:29:24,050
Because you sequentially load initial.

00:29:24,050 --> 00:29:27,260
Like, you reload and relocate every single kernel module

00:29:27,260 --> 00:29:29,740
that you actually need to load, et cetera, et cetera.

00:29:29,740 --> 00:29:30,573
- [Feng] You're right.

00:29:30,573 --> 00:29:31,770
- It turned out to be a lot of overhead.

00:29:31,770 --> 00:29:34,820
- Yeah, I needed to emphasize before

00:29:34,820 --> 00:29:37,440
that because what we've done

00:29:37,440 --> 00:29:39,610
is actually for our specific platform,

00:29:39,610 --> 00:29:42,690
and with that special

00:29:43,780 --> 00:29:44,993
application, actually, it's a camera application.

00:29:47,784 --> 00:29:49,330
It needs to be functional.

00:29:49,330 --> 00:29:52,480
So we did not only the kernel stuff

00:29:53,803 --> 00:29:55,050
and the user space stuff.

00:29:55,050 --> 00:29:59,100
We tried to load the application faster, and

00:30:01,160 --> 00:30:05,770
those modules, a lot less modules are loaded in parallel

00:30:05,770 --> 00:30:08,255
with our camera application.

00:30:08,255 --> 00:30:09,088
- [Alex] Oh.

00:30:09,088 --> 00:30:12,020
- Yeah, that's especially for our platform, yeah.

00:30:12,020 --> 00:30:15,080
- So you basically will configure equals Y

00:30:15,080 --> 00:30:17,860
on all the options that you need to boot.

00:30:17,860 --> 00:30:18,693
- [Feng] Yeah, exactly.

00:30:18,693 --> 00:30:21,080
- And everything that can be initialized later,

00:30:21,080 --> 00:30:24,423
you leave as modules because now you get the parallels.

00:30:24,423 --> 00:30:26,020
- Yeah, right. - Okay.

00:30:26,020 --> 00:30:28,563
- So we love doing the distributing stuff.

00:30:29,560 --> 00:30:31,140
- Are you getting more parallelism out of it?

00:30:31,140 --> 00:30:33,060
Because I remember that there was, like, a time,

00:30:33,060 --> 00:30:35,960
at least a while back, when loading a module meant

00:30:35,960 --> 00:30:38,276
you were basically stopping the world.

00:30:38,276 --> 00:30:40,040
Did that disappear by now?

00:30:40,040 --> 00:30:40,993
I didn't track.

00:30:44,400 --> 00:30:45,233
- I also haven't checked.

00:30:45,233 --> 00:30:46,380
- [Audience Member] I had the same question, actually.

00:30:46,380 --> 00:30:47,578
I wanted to ask.

00:30:47,578 --> 00:30:50,060
Did you really measure the parallelism you were getting?

00:30:50,060 --> 00:30:53,320
Like, the parallelization efficiency you've been getting

00:30:53,320 --> 00:30:55,720
by loading modules later?

00:30:55,720 --> 00:30:57,670
And what kind of extra work you can do

00:30:57,670 --> 00:30:59,153
while they're being loaded?

00:31:03,560 --> 00:31:05,170
- So

00:31:05,170 --> 00:31:09,280
for our platform, we don't have that much, so

00:31:09,280 --> 00:31:12,223
for the post-kernel phase,

00:31:13,600 --> 00:31:14,433
to be frank,

00:31:15,820 --> 00:31:19,160
I haven't done much profiling

00:31:19,160 --> 00:31:20,717
stuff.

00:31:20,717 --> 00:31:24,737
So we only have several modules, and we keep those

00:31:26,240 --> 00:31:28,960
which is needed by the camera application

00:31:28,960 --> 00:31:33,960
inside kernel building, and we use asynchronous probing

00:31:34,230 --> 00:31:35,880
to make them boot in parallel.

00:31:35,880 --> 00:31:38,403
For our stuff, we just put it into modules.

00:31:43,526 --> 00:31:46,710
So here's

00:31:46,710 --> 00:31:48,693
the potential optimization points.

00:31:51,180 --> 00:31:53,203
I will go through them one by one.

00:31:55,760 --> 00:31:59,533
The first one is universality versus performance.

00:32:02,910 --> 00:32:07,820
Your kernel driver wants to cover all the hardwares

00:32:07,820 --> 00:32:09,083
with one copy of code,

00:32:10,390 --> 00:32:11,223
and

00:32:12,961 --> 00:32:16,240
our experience shows that many long delay in the drivers

00:32:16,240 --> 00:32:19,173
is actually just to cover one broken hardware,

00:32:20,090 --> 00:32:21,820
and that everybody else needs to pay

00:32:21,820 --> 00:32:25,443
for this specific broken hardware.

00:32:27,980 --> 00:32:31,241
For some examples, the graphics drivers,

00:32:31,241 --> 00:32:32,810
camera graphics drivers.

00:32:32,810 --> 00:32:34,413
We ought to detect the

00:32:36,320 --> 00:32:38,180
configuration if we read

00:32:39,050 --> 00:32:41,743
32 times for one register.

00:32:43,516 --> 00:32:46,630
In our platform, it could take about

00:32:48,727 --> 00:32:51,010
500 milliseconds,

00:32:51,010 --> 00:32:55,780
and previously, it was just to try to read file times,

00:32:55,780 --> 00:32:57,540
32 times.

00:32:57,540 --> 00:33:01,220
And then later, there was broken monitors

00:33:01,220 --> 00:33:04,040
from Acer or some brand,

00:33:04,040 --> 00:33:05,790
so then the graphics driver changed it.

00:33:05,790 --> 00:33:08,893
It changed the read retry number from five to 32.

00:33:12,190 --> 00:33:15,140
And then similar things for the other driver,

00:33:15,140 --> 00:33:17,110
for our SDHC driver.

00:33:17,110 --> 00:33:19,210
I think in the kernel or upstream,

00:33:19,210 --> 00:33:21,920
the SD host controller driver,

00:33:21,920 --> 00:33:25,113
there's one delay inside the power-related operation.

00:33:26,360 --> 00:33:27,423
It's 10 milliseconds.

00:33:28,980 --> 00:33:30,580
- [Alex] Isn't that part of the spec?

00:33:30,580 --> 00:33:31,510
- What?

00:33:31,510 --> 00:33:33,810
- That could easily be a number that's part of the spec.

00:33:33,810 --> 00:33:35,660
It just has to be there

00:33:35,660 --> 00:33:37,883
in order to power up a card, for example.

00:33:39,220 --> 00:33:41,590
- Yes, just for one card.

00:33:41,590 --> 00:33:43,640
For one type of controller.

00:33:43,640 --> 00:33:46,593
It is not inside any of the specs.

00:33:47,813 --> 00:33:50,280
It's just to cover one broken hardware.

00:33:50,280 --> 00:33:51,113
- [Alex] Okay.

00:33:52,514 --> 00:33:55,340
- And I've tried many platforms,

00:33:55,340 --> 00:33:57,370
and we don't need that delay.

00:33:57,370 --> 00:33:58,203
- [Alex] Okay.

00:34:01,774 --> 00:34:03,024
- So my question here is:

00:34:04,710 --> 00:34:09,291
Can we just add some kernel parameters to tune these delays?

00:34:09,291 --> 00:34:10,124
- [Alex] No.

00:34:10,124 --> 00:34:13,030
- Yes, so that's my passion.

00:34:13,030 --> 00:34:15,557
Why is it rejected by the parameters?

00:34:15,557 --> 00:34:17,750
- So "no" is a pretty obvious answer on that one.

00:34:17,750 --> 00:34:19,900
Always, whenever you think about these cases,

00:34:19,900 --> 00:34:23,523
always, don't think of a specific embedded application.

00:34:23,523 --> 00:34:25,290
Think of distros, right?

00:34:25,290 --> 00:34:26,123
- [Feng] Yeah, okay.

00:34:26,123 --> 00:34:28,500
- That's the easy way to basically think on your own

00:34:28,500 --> 00:34:30,290
whether something like this could get accepted.

00:34:30,290 --> 00:34:31,123
- [Feng] Yeah.

00:34:31,123 --> 00:34:33,020
- Quirks, however, is a really good idea, right?

00:34:33,020 --> 00:34:34,674
Check on PCI ID's.

00:34:34,674 --> 00:34:36,050
Check on DMI ID's.

00:34:36,050 --> 00:34:37,420
Check on whatever ID's.

00:34:37,420 --> 00:34:40,520
You will be able to easily be able to get them in there.

00:34:40,520 --> 00:34:42,420
Or even just change the whole concept.

00:34:42,420 --> 00:34:43,253
Like, for example,

00:34:43,253 --> 00:34:45,240
if you're saying you're reading a register

00:34:45,240 --> 00:34:49,290
to detect the monitor, well, maybe, doing that in a, like...

00:34:50,490 --> 00:34:51,323
What is it called?

00:34:51,323 --> 00:34:52,723
Work queue, work item, work.

00:34:54,370 --> 00:34:56,690
Is a much smarter way of doing it

00:34:56,690 --> 00:35:00,010
than pausing the initialization for it, right?

00:35:00,010 --> 00:35:00,843
- Yeah.

00:35:03,910 --> 00:35:05,863
Okay, we'll go faster, okay?

00:35:06,890 --> 00:35:08,520
So here's in-kernel.

00:35:08,520 --> 00:35:10,883
There's a memory deferred initialization,

00:35:11,900 --> 00:35:13,663
just addressed by this gentleman.

00:35:16,529 --> 00:35:20,580
So just after the SMP is initialized,

00:35:20,580 --> 00:35:22,800
all the core system is up and running.

00:35:22,800 --> 00:35:24,190
We can just do something

00:35:25,760 --> 00:35:28,343
to load some of the memory initialization work.

00:35:31,770 --> 00:35:32,603
And another problem

00:35:32,603 --> 00:35:37,090
is when doing the driver asynchronous probing.

00:35:37,090 --> 00:35:40,900
It will mess up some of the controllers index

00:35:40,900 --> 00:35:45,450
for, like, the uart, the spi, the I-squared-C.

00:35:45,450 --> 00:35:48,730
Because the selected devices collecting to them

00:35:48,730 --> 00:35:50,370
rely on the fixed number.

00:35:50,370 --> 00:35:53,040
If we use asynchronous probing,

00:35:53,040 --> 00:35:55,593
the control index may be messed up.

00:35:58,440 --> 00:36:00,009
Okay, so.

00:36:00,009 --> 00:36:00,842
- [Audience Member] I mean,

00:36:00,842 --> 00:36:03,160
isn't udev supposed to address this?

00:36:03,160 --> 00:36:03,993
- Excuse me?

00:36:03,993 --> 00:36:06,253
- Isn't udev supposed to address this problem?

00:36:07,110 --> 00:36:10,483
Providing device names that are consistent across reboot?

00:36:12,536 --> 00:36:15,584
(Feng stammers)

00:36:15,584 --> 00:36:19,027
- Yeah, we can try to do that, but

00:36:19,027 --> 00:36:21,770
that will cost a lot extra for us

00:36:21,770 --> 00:36:24,053
because we have the uart, and we have the spi,

00:36:24,053 --> 00:36:27,656
and we have the I-squared-C for our platform,

00:36:27,656 --> 00:36:29,000
a lot of stuff.

00:36:29,000 --> 00:36:29,833
So

00:36:30,720 --> 00:36:33,860
one possible solution is just to add some of the

00:36:35,750 --> 00:36:39,520
platform data into the data structure of the device.

00:36:39,520 --> 00:36:43,523
We're connecting the PCI ID with some fixed number.

00:36:45,370 --> 00:36:49,183
This may easily help the situation.

00:36:50,920 --> 00:36:54,180
So I used to have a driver, a patch,

00:36:54,180 --> 00:36:57,240
to make a map to do the asynchronous probe

00:36:57,240 --> 00:37:02,000
and suddenly I had to drop it because of this problem.

00:37:02,000 --> 00:37:03,213
So I rest it here.

00:37:08,220 --> 00:37:10,300
- [Audience Member] So udev does work very well,

00:37:10,300 --> 00:37:12,830
but it requires round tripping from user to kernel,

00:37:12,830 --> 00:37:15,480
which means you have a huge context switch overhead,

00:37:15,480 --> 00:37:18,277
and it doesn't do it fast, so it does it well, but slowly.

00:37:18,277 --> 00:37:19,802
- [Alex] It doesn't do it well, either.

00:37:19,802 --> 00:37:20,785
- [Audience Member] It doesn't do it, really, no.

00:37:20,785 --> 00:37:22,360
Definitely not. - It doesn't work that way.

00:37:22,360 --> 00:37:23,193
- [Audience Member] Yep.

00:37:27,870 --> 00:37:32,190
- Okay, next one is parallize SMP initialization.

00:37:32,190 --> 00:37:37,010
So in our system, and I also profiled some other systems,

00:37:37,010 --> 00:37:38,120
including servers,

00:37:38,120 --> 00:37:43,070
usually it takes about six to 10 milliseconds to bring up

00:37:44,302 --> 00:37:45,135
one CPU.

00:37:47,786 --> 00:37:51,210
And it used to be more in the older kernel.

00:37:54,260 --> 00:37:56,850
So currently, I don't know how to solve this,

00:37:56,850 --> 00:38:00,223
but I just think there may be some space to improve here.

00:38:02,866 --> 00:38:05,910
Currently, all the CPU's are brought up

00:38:05,910 --> 00:38:09,223
by their aligned CPU hotplug framework.

00:38:12,280 --> 00:38:15,120
Maybe we can try to optimize it

00:38:16,930 --> 00:38:20,040
because for the Linux system, with a lot of CPU's,

00:38:20,040 --> 00:38:22,363
it really takes quite some time.

00:38:27,550 --> 00:38:30,770
Next one is the firmware init.

00:38:32,410 --> 00:38:34,730
In our existing, the final numbers,

00:38:34,730 --> 00:38:39,730
the firmware ACPI initialization still takes a lot of time

00:38:40,460 --> 00:38:45,460
because it is running before the SMP is initialized.

00:38:46,079 --> 00:38:46,912
Sorry,

00:38:48,160 --> 00:38:50,030
it's in the critical path,

00:38:50,030 --> 00:38:52,720
and it cannot be asynchronous now.

00:38:52,720 --> 00:38:56,780
Maybe we can just carefully check them.

00:38:56,780 --> 00:39:00,880
We don't need to do all of them in the critical path, and

00:39:02,330 --> 00:39:04,513
split them to a different phase.

00:39:05,900 --> 00:39:07,880
Because for the general device,

00:39:07,880 --> 00:39:11,910
I think they could be enumerated later.

00:39:11,910 --> 00:39:14,030
- [Audience Member] I had a comment on the previous slide.

00:39:14,030 --> 00:39:14,863
- Okay.

00:39:15,798 --> 00:39:18,560
- Have you checked where the time is spent

00:39:18,560 --> 00:39:19,940
during the SMP initialization?

00:39:19,940 --> 00:39:23,280
Because from what I remember, on some broken CPU's,

00:39:23,280 --> 00:39:25,480
it takes a longer time to

00:39:26,910 --> 00:39:28,820
synchronize TSC

00:39:28,820 --> 00:39:32,303
so that there was like a delay loop of each task,

00:39:34,430 --> 00:39:38,350
like across table, TSC, and it's done on every single CPU.

00:39:38,350 --> 00:39:39,350
- [Feng] Yeah.

00:39:39,350 --> 00:39:42,280
- So, I mean, if the hardware is not broken,

00:39:42,280 --> 00:39:43,670
you don't have to do that.

00:39:43,670 --> 00:39:46,160
It's just a possibility that that's where you spend time

00:39:46,160 --> 00:39:47,573
to calibrate the TSC.

00:39:49,400 --> 00:39:53,480
- I profiled several platforms, so TSC is fine.

00:39:53,480 --> 00:39:54,313
It's just

00:39:55,260 --> 00:39:58,380
when we bring up kind of each CPU,

00:39:58,380 --> 00:40:02,184
it will set up a lot of the user case, right?

00:40:02,184 --> 00:40:05,010
And instead of running a lot of the initializing function,

00:40:05,010 --> 00:40:07,710
there will be a big list of them, one by one.

00:40:07,710 --> 00:40:11,120
- Yeah, I know the tech is very deep for CPU initialization

00:40:11,120 --> 00:40:12,630
but just where you spent time there.

00:40:12,630 --> 00:40:14,063
Like, what actually?

00:40:17,200 --> 00:40:18,440
- I haven't checked the details,

00:40:18,440 --> 00:40:21,323
but it seems there's some synchronization.

00:40:22,180 --> 00:40:26,840
They're waiting for something to act, okay?

00:40:26,840 --> 00:40:27,673
Okay.

00:40:31,190 --> 00:40:33,133
So we're almost done here.

00:40:35,190 --> 00:40:38,253
So the last one I was mentioning was about the user space.

00:40:39,170 --> 00:40:41,520
So you in one picture previously,

00:40:41,520 --> 00:40:44,790
we noticed that it takes us

00:40:44,790 --> 00:40:48,103
about 100 milliseconds to load the systemd,

00:40:49,120 --> 00:40:51,013
and the file prevelance is too much.

00:40:55,100 --> 00:40:59,340
So we tried to use some lightweight initial program

00:41:01,503 --> 00:41:02,600
which will

00:41:03,930 --> 00:41:08,040
just try to load the less serious stuff

00:41:08,040 --> 00:41:11,063
and use a readahead to preload some libraries,

00:41:12,773 --> 00:41:16,443
then just start our camera application.

00:41:21,812 --> 00:41:23,643
With that,

00:41:23,643 --> 00:41:25,460
with using that,

00:41:25,460 --> 00:41:27,993
we could get some time back.

00:41:28,850 --> 00:41:31,020
And also,

00:41:31,020 --> 00:41:32,860
my question is:

00:41:32,860 --> 00:41:35,100
Can we just add the initial program, then,

00:41:35,100 --> 00:41:37,600
into the command line to do some preloading stuff?

00:41:41,710 --> 00:41:42,543
- It's already there.

00:41:42,543 --> 00:41:43,376
It's called init equals.

00:41:43,376 --> 00:41:46,730
There's a command on option to define the init program

00:41:46,730 --> 00:41:47,830
as well as arguments,

00:41:47,830 --> 00:41:50,940
so if init equals is always the last parameter,

00:41:50,940 --> 00:41:53,430
you define that, and then after that comes your executable

00:41:53,430 --> 00:41:55,040
and your parameters.

00:41:55,040 --> 00:41:55,873
It's all there.

00:41:55,873 --> 00:41:57,023
- You mean preloading?

00:42:00,480 --> 00:42:01,313
- [Audience Members] I think

00:42:01,313 --> 00:42:02,560
he's asking a different question.

00:42:02,560 --> 00:42:04,110
He doesn't want to specify a net.

00:42:04,110 --> 00:42:05,490
He wants to preload a net.

00:42:05,490 --> 00:42:06,323
- Yes, yes.

00:42:06,323 --> 00:42:07,740
- [Audience Member] So a command line option.

00:42:07,740 --> 00:42:08,620
- Yeah, we already do that.

00:42:08,620 --> 00:42:10,160
It's just preload.

00:42:10,160 --> 00:42:13,080
Sorry, I'm making it clear that it's preload.

00:42:13,080 --> 00:42:15,890
Once the root file system is mounting,

00:42:15,890 --> 00:42:18,700
it's just to start preloading the initial program

00:42:18,700 --> 00:42:20,200
so that we don't have to wait.

00:42:21,280 --> 00:42:23,224
Broken call, wait for it.

00:42:23,224 --> 00:42:24,382
- How much time do you have

00:42:24,382 --> 00:42:26,261
in between the root file system is mounted

00:42:26,261 --> 00:42:29,294
and you actually trying to find that application?

00:42:29,294 --> 00:42:31,986
Like the call in the kernel that tries to find init?

00:42:31,986 --> 00:42:32,819
How much time do you spend

00:42:32,819 --> 00:42:34,610
in between those two points in time?

00:42:36,490 --> 00:42:39,723
- For the loading times, actually, the disk read time.

00:42:42,044 --> 00:42:44,150
- So what I'm saying is,

00:42:44,150 --> 00:42:46,710
the kernel needs to be able to access the volume, right?

00:42:46,710 --> 00:42:49,160
It needs to be able to actually find that inner process,

00:42:49,160 --> 00:42:50,080
so it needs to have a driver

00:42:50,080 --> 00:42:51,970
loaded with all the storage back end.

00:42:51,970 --> 00:42:53,500
It needs to have the file system loaded.

00:42:53,500 --> 00:42:54,990
It needs to actually have the file system mounted,

00:42:54,990 --> 00:42:56,490
et cetera, et cetera, correct?

00:42:59,100 --> 00:43:00,280
Which stage are you trying to preload?

00:43:00,280 --> 00:43:02,680
- Okay, you mean there's not much space

00:43:02,680 --> 00:43:04,010
for doing the preloading?

00:43:04,010 --> 00:43:05,730
- [Audience Member] So I think what Alex is saying is,

00:43:05,730 --> 00:43:07,640
you may not have the time to do the preload.

00:43:07,640 --> 00:43:08,940
Is that your argument?

00:43:08,940 --> 00:43:12,220
- What I'm saying is maybe the time that you have to preload

00:43:12,220 --> 00:43:15,130
is about two milliseconds, and that is moot

00:43:15,130 --> 00:43:17,600
because from the kernel boot flow,

00:43:17,600 --> 00:43:21,240
by the point in time you search for the root target,

00:43:21,240 --> 00:43:26,060
you mount the root target, and you try to load in it

00:43:26,060 --> 00:43:27,764
and execute it.

00:43:27,764 --> 00:43:30,690
That's almost like two function calls

00:43:30,690 --> 00:43:31,840
right after each other.

00:43:31,840 --> 00:43:34,550
There's very little time in between those points in time

00:43:34,550 --> 00:43:36,150
which means if you want to do that,

00:43:36,150 --> 00:43:37,360
you would actually have to

00:43:37,360 --> 00:43:40,530
completely take the whole boot flow upside down in Linux.

00:43:40,530 --> 00:43:41,363
- [Feng] Yeah.

00:43:41,363 --> 00:43:44,370
- And instead of passing the root target,

00:43:44,370 --> 00:43:47,670
which equals parameter on the command line,

00:43:47,670 --> 00:43:51,210
pass that really late, you would have to pass that,

00:43:51,210 --> 00:43:52,330
I don't know, like, dynamically,

00:43:52,330 --> 00:43:53,660
as soon as you load drivers.

00:43:53,660 --> 00:43:55,213
I have no idea.

00:43:55,213 --> 00:43:57,239
That's a flow that we don't have at all.

00:43:57,239 --> 00:43:58,072
- [Feng] I understand that, yeah.

00:43:58,072 --> 00:44:01,373
- [Tim] You could put it in an init wrap at best.

00:44:01,373 --> 00:44:03,570
- [Alex] Okay, Tim was just saying,

00:44:03,570 --> 00:44:05,643
you could put it into an init wrap at best.

00:44:07,200 --> 00:44:10,453
How does that buy you any time?

00:44:12,980 --> 00:44:14,480
Okay, I think he's walking up.

00:44:16,066 --> 00:44:17,480
- [Audience Member] I'm sorry, is there another one?

00:44:17,480 --> 00:44:18,313
- [Alex] Well, there's this one.

00:44:18,313 --> 00:44:19,510
You can...

00:44:19,510 --> 00:44:21,227
Oh, there you go.

00:44:21,227 --> 00:44:22,060
Yeah, he has one for you.

00:44:22,060 --> 00:44:23,840
- [Audience Member] So just one quick thing.

00:44:23,840 --> 00:44:24,940
Take a look at Alpine.

00:44:26,720 --> 00:44:29,720
Alpine is a distro that works very well for vetted systems.

00:44:29,720 --> 00:44:31,010
Init's very small.

00:44:31,010 --> 00:44:32,590
It takes an incredibly small amount of time,

00:44:32,590 --> 00:44:36,110
and it's easy to optimize this kind of problem,

00:44:36,110 --> 00:44:39,093
especially when you're transitioning to UserLAnd.

00:44:40,860 --> 00:44:44,360
- I guess my observation on this particular item was

00:44:44,360 --> 00:44:48,850
if you put the systemd dmesg into initramfs,

00:44:48,850 --> 00:44:51,360
I don't know if that's possible or if that screws you up,

00:44:51,360 --> 00:44:53,080
but initramfs is gonna be in memory

00:44:53,080 --> 00:44:55,483
before you mount the other file systems.

00:44:56,500 --> 00:45:00,200
I wanted to back up several slides to your issue of...

00:45:02,270 --> 00:45:03,320
Keep going.

00:45:03,320 --> 00:45:04,640
Let me see.

00:45:04,640 --> 00:45:05,490
It was your...

00:45:05,490 --> 00:45:06,323
No, keep going.

00:45:07,190 --> 00:45:09,290
Yeah, can we handle it in a better way?

00:45:09,290 --> 00:45:14,040
So there's a couple of classes of kernel issues

00:45:14,040 --> 00:45:18,030
that fall into this category of they're highly specialized

00:45:18,030 --> 00:45:23,030
depending on your configuration and your hardware that

00:45:24,240 --> 00:45:25,780
it's very hard to share them

00:45:25,780 --> 00:45:27,770
with the rest of the community because of that, right?

00:45:27,770 --> 00:45:31,750
So you want to make a way to parameterize the kernel

00:45:31,750 --> 00:45:35,310
so that you can cut out cruft that you're not gonna use,

00:45:35,310 --> 00:45:40,310
but it's then very hard to share that with other people.

00:45:40,600 --> 00:45:42,410
There's not really a kernel mechanism, you know?

00:45:42,410 --> 00:45:44,560
You brought up the kernel parameter tuning,

00:45:45,830 --> 00:45:49,420
but that still leaves some poor soul at another company

00:45:49,420 --> 00:45:52,900
to go through and find all those parameters again

00:45:52,900 --> 00:45:57,220
and to hand-tune them, and so it seems...

00:45:57,220 --> 00:45:59,100
I don't have a solution here,

00:45:59,100 --> 00:46:01,400
but it seems like a better approach to the problem

00:46:01,400 --> 00:46:03,641
would be to set up some kind of system

00:46:03,641 --> 00:46:06,150
where, like, all this information that you've got

00:46:06,150 --> 00:46:07,890
is really, really good, but it's, you know,

00:46:07,890 --> 00:46:10,300
five years from now, it's gonna be buried, you know,

00:46:10,300 --> 00:46:13,315
on a plumber's video somewhere on YouTube,

00:46:13,315 --> 00:46:17,350
and someone's gonna have to do this all over again.

00:46:17,350 --> 00:46:19,670
And so it would be nice if there was a sharing,

00:46:19,670 --> 00:46:20,900
a place where you could share this stuff.

00:46:20,900 --> 00:46:24,560
I'm not sure that the kernel source tree is the right place.

00:46:24,560 --> 00:46:27,140
Maybe it is, but maybe we need to actually think

00:46:27,140 --> 00:46:29,660
about some other place where we can share this type

00:46:29,660 --> 00:46:32,060
of tuning information.

00:46:32,060 --> 00:46:33,680
Like, you guys went through a lot of trouble

00:46:33,680 --> 00:46:34,940
to get this information.

00:46:34,940 --> 00:46:36,290
It's hard-won.

00:46:36,290 --> 00:46:38,100
I'd be nice to be able to share it with other people,

00:46:38,100 --> 00:46:41,400
but I don't have a solution for how to do that sharing

00:46:41,400 --> 00:46:43,353
or where to do that sharing.

00:46:43,353 --> 00:46:46,103
- Yeah, I'm tuning these things.

00:46:47,553 --> 00:46:50,410
I've made some patches to the upstream menus,

00:46:50,410 --> 00:46:53,570
trying to figure, just as Alex has said.

00:46:53,570 --> 00:46:54,520
That got rejected

00:46:54,520 --> 00:46:58,690
because of bringing the new kind of parameters.

00:46:58,690 --> 00:47:01,390
So yeah, so you think we need something

00:47:01,390 --> 00:47:04,170
inside the kernel documentation about these things?

00:47:04,170 --> 00:47:07,540
- [Audience Member] Maybe documentation, I don't know.

00:47:07,540 --> 00:47:10,520
- So my suggestion would be a simple, quick one.

00:47:10,520 --> 00:47:14,330
There's a webpage called Kernel Newbies, which is a Wiki,

00:47:14,330 --> 00:47:16,047
which you can just add a page to and say,

00:47:16,047 --> 00:47:19,117
"Well, if you want to optimize boot time really fast,

00:47:19,117 --> 00:47:20,797
"look at these items, and by the way,

00:47:20,797 --> 00:47:23,377
"these are some low-hanging fruits to potentially optimize

00:47:23,377 --> 00:47:26,277
"with alternatives upstream going forward."

00:47:26,277 --> 00:47:27,110
So people can pick up versions.

00:47:27,110 --> 00:47:28,430
- [MC] I'm gonna throw in a mine here.

00:47:28,430 --> 00:47:30,140
We're now into break time.

00:47:30,140 --> 00:47:34,190
We're past the time, so if you have a lot more,

00:47:34,190 --> 00:47:35,730
I would suggest scheduling above

00:47:35,730 --> 00:47:39,350
or, you know, finding a hack room and continuing there.

00:47:39,350 --> 00:47:40,750
If people want to keep chatting

00:47:40,750 --> 00:47:43,350
until the next speaker comes in, I'm not gonna stop you,

00:47:43,350 --> 00:47:46,150
but just so people know that they're in the break.

00:47:46,150 --> 00:47:47,160
Thank you very much.

00:47:47,160 --> 00:47:48,256
- Okay. (audience applauds)

00:47:48,256 --> 00:47:50,423

YouTube URL: https://www.youtube.com/watch?v=A7N_O8pnyTw


