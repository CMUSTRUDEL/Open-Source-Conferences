Title: LPC2019 - printk: Why is it so complicated?
Publication date: 2019-11-18
Playlist: LPC2019 - LPC Main Track
Description: 
	printk: Why is it so complicated?

Speaker
 John Ogness (Linutronix GmbH)

Description
The printk() function has a long history of issues and has undergone many iterations to improve performance and reliability. Yet it is still not an acceptable solution to reliably allow the kernel to send detailed information to the user. And these problems are even magnified when using a real-time system. So why is printk() so complicated and why are we having such a hard time finding a good solution?

This talk will briefly cover the history of printk() and why the recent major rework was necessary. It will go through the details of the rework and why we believe it solves many of the issues. And it will present the issues still not solved (such as fully synchronous console writing), why these issues are particularly complex and controversial, and review some of the proposed solutions for moving forward.

This talk may be of particular interest to developers with experience or interest in lockless ring buffers, memory barriers, and NMI-safe synchronization.
Captions: 
	00:00:00,280 --> 00:00:03,993
- Hi, so, I think we're ready to begin.

00:00:07,320 --> 00:00:09,090
Officially, there's no MC right now,

00:00:09,090 --> 00:00:11,560
so I'm just going to introduce myself.

00:00:11,560 --> 00:00:14,083
We're good, lad, do we need to shut the door in the back?

00:00:15,587 --> 00:00:18,220
- [Audience Member] I'll get it.

00:00:18,220 --> 00:00:19,520
- Someone's got it, great.

00:00:23,340 --> 00:00:25,810
Okay, my name is John Ogness,

00:00:25,810 --> 00:00:29,960
I'm one of the happy hackers at Linutronix in Germany,

00:00:29,960 --> 00:00:32,297
and I'm here to talk about printk.

00:00:36,290 --> 00:00:39,570
A slight disclaimer when I begin here,

00:00:39,570 --> 00:00:40,760
we're doing, actually,

00:00:40,760 --> 00:00:42,650
we're working on re-engineering a lot

00:00:42,650 --> 00:00:46,450
of printk to address a lot of long standing problems,

00:00:46,450 --> 00:00:49,030
but none of the work that I am presenting here

00:00:49,030 --> 00:00:50,450
is mainline yet.

00:00:50,450 --> 00:00:51,480
Yeah, so, we've been working on this

00:00:51,480 --> 00:00:53,410
for a year and a half already,

00:00:53,410 --> 00:00:56,330
but there is, actually none of this in mainline yet.

00:00:56,330 --> 00:01:00,030
Lots and lots of patches and discussions on the main lists.

00:01:00,030 --> 00:01:02,460
So it could, actually, end up being different

00:01:02,460 --> 00:01:03,710
than we see here as well.

00:01:05,770 --> 00:01:08,900
So, the main thing about why is printk so complicated,

00:01:08,900 --> 00:01:11,560
isn't it just a function that just prints something?

00:01:11,560 --> 00:01:13,580
Let's just, maybe, really quick, take a look at

00:01:13,580 --> 00:01:15,890
what are the requirements, actually of printk.

00:01:15,890 --> 00:01:18,100
So, you have the basic requirements

00:01:18,100 --> 00:01:20,180
that printk can be called from any context,

00:01:20,180 --> 00:01:22,200
and scheduling context, NMI context,

00:01:22,200 --> 00:01:24,750
interrupt, hard-interrupt context.

00:01:24,750 --> 00:01:25,670
That's a requirement,

00:01:25,670 --> 00:01:28,160
these are simple requirements, actually.

00:01:28,160 --> 00:01:30,483
It stores messages into a ringbuffer.

00:01:30,483 --> 00:01:32,820
This ringbuffer is then made available to user space,

00:01:32,820 --> 00:01:35,400
for example, syslog, /dev/kmsg,

00:01:35,400 --> 00:01:37,040
there's the kmsg-dump facilities,

00:01:37,040 --> 00:01:38,270
so that if the machine crashes,

00:01:38,270 --> 00:01:40,373
it can actually grab those logs.

00:01:41,400 --> 00:01:43,110
And printk is also responsible

00:01:44,040 --> 00:01:46,330
for pushing messages out onto the console,

00:01:46,330 --> 00:01:48,580
which might be a graphic screen or

00:01:48,580 --> 00:01:51,660
a serial, or network, for example.

00:01:51,660 --> 00:01:54,010
So those are the simple requirements, actually.

00:01:55,350 --> 00:01:57,710
Here's where it starts to get complicated.

00:01:57,710 --> 00:02:00,400
So, we also would like our printk

00:02:00,400 --> 00:02:03,980
to not be missing any messages if we crash or hang,

00:02:03,980 --> 00:02:05,810
for any reason, right?

00:02:05,810 --> 00:02:09,730
So if we're crashing in bizarre contexts when

00:02:09,730 --> 00:02:11,910
we're holding certain spinlocks,

00:02:11,910 --> 00:02:15,550
or some other exotic locks, it might be really hard

00:02:15,550 --> 00:02:19,350
to actually get those messages stored.

00:02:19,350 --> 00:02:21,180
So we might actually missing some messages

00:02:21,180 --> 00:02:22,070
when the machine crashes.

00:02:22,070 --> 00:02:24,570
They might actually not be in the ringbuffer even.

00:02:25,661 --> 00:02:27,138
We would also like that

00:02:27,138 --> 00:02:29,400
the console doesn't miss any messages, right?

00:02:29,400 --> 00:02:33,409
So if my machine crashes I would like to see what happened.

00:02:33,409 --> 00:02:35,300
I don't wanna see nothingness,

00:02:35,300 --> 00:02:37,340
or I don't want there to be missing messages, right?

00:02:37,340 --> 00:02:40,050
So, this is also really important.

00:02:40,050 --> 00:02:42,240
And the reason why this is so difficult is

00:02:42,240 --> 00:02:45,260
because the different console drivers,

00:02:45,260 --> 00:02:47,630
they do a lot of interesting stuff, you know,

00:02:47,630 --> 00:02:50,910
where they're not, thinking about that

00:02:50,910 --> 00:02:53,920
they might being called from in a MyContext, for example.

00:02:53,920 --> 00:02:54,823
You know, they don't think about this

00:02:54,823 --> 00:02:56,850
when they write these drivers.

00:02:56,850 --> 00:02:58,620
Things like, the whole graphics subsystem

00:02:58,620 --> 00:03:02,960
or even doing the network console become really complicated

00:03:02,960 --> 00:03:06,010
if we're crashing it in a MyContext, for example.

00:03:06,010 --> 00:03:08,480
How could we even get that stuff out?

00:03:08,480 --> 00:03:11,370
And then, of course, the big requirement,

00:03:11,370 --> 00:03:13,990
which is the biggest one on the wishlist is,

00:03:13,990 --> 00:03:17,230
we don't want printk to interfere the system at all, right?

00:03:17,230 --> 00:03:19,460
So, we want to see the messages immediately,

00:03:19,460 --> 00:03:22,563
we want them to be restored reliably from any context,

00:03:23,424 --> 00:03:24,910
but we also don't want them to disturb the system

00:03:24,910 --> 00:03:25,743
at all while running, yeah?

00:03:25,743 --> 00:03:27,630
So if I stick in my USB stick,

00:03:27,630 --> 00:03:29,940
I shouldn't see latency spikes

00:03:29,940 --> 00:03:32,763
because it's telling me the devices,

00:03:34,020 --> 00:03:36,430
the different partitions that were found on my USB stick.

00:03:36,430 --> 00:03:38,090
But I still wanna see those messages, right?

00:03:38,090 --> 00:03:40,740
When we put in our USB stick, we want to see those messages,

00:03:40,740 --> 00:03:42,520
we just don't want them to disturb

00:03:42,520 --> 00:03:45,970
our real-time applications that are running, for example.

00:03:45,970 --> 00:03:49,700
And if I'm allowed to quote myself, I actually wrote

00:03:49,700 --> 00:03:50,993
it well as summary,

00:03:52,161 --> 00:03:54,100
"If it's a part of printk,

00:03:54,100 --> 00:03:56,930
then it's already implicitly on every single line

00:03:56,930 --> 00:03:58,280
of code in the kernel."

00:03:58,280 --> 00:04:01,500
Because any line of code of kernel,

00:04:01,500 --> 00:04:02,630
code in the kernel could

00:04:02,630 --> 00:04:05,670
potentially crash, which would cause printk

00:04:05,670 --> 00:04:08,310
to start doing stack traces and these kinds of things.

00:04:08,310 --> 00:04:11,810
So this is what makes printk so difficult,

00:04:11,810 --> 00:04:12,770
is it's everywhere.

00:04:12,770 --> 00:04:15,300
It's a very simple function that a lot

00:04:15,300 --> 00:04:17,700
of people don't even like and try to avoid

00:04:17,700 --> 00:04:19,360
but it's, at the same time,

00:04:19,360 --> 00:04:21,530
it goes very deep in the system, yeah?

00:04:21,530 --> 00:04:23,870
And when our system crashes, now all of a sudden,

00:04:23,870 --> 00:04:25,940
printk is very important to us.

00:04:25,940 --> 00:04:27,067
Now this time we start complaining,

00:04:27,067 --> 00:04:30,040
"Who wrote that, and why is printk not working like this?"

00:04:30,040 --> 00:04:30,873
So, at the same time,

00:04:30,873 --> 00:04:32,930
it's a very important piece of the kernel.

00:04:34,480 --> 00:04:37,120
So I went through to look at the history of printk

00:04:37,120 --> 00:04:38,380
just to see where it came from,

00:04:38,380 --> 00:04:39,440
and it turns out that printk

00:04:39,440 --> 00:04:42,150
has been around since the dawn of time, right,

00:04:42,150 --> 00:04:44,160
so Linux 0.01.

00:04:44,160 --> 00:04:48,053
This is actually the contents of kernel/printk.c.

00:04:49,160 --> 00:04:51,560
So we see here that there's no ringbuffer involved

00:04:51,560 --> 00:04:52,393
or anything like this,

00:04:52,393 --> 00:04:54,853
it's just directly smprintf or sprintf-ing

00:04:56,680 --> 00:05:00,870
the string into temporary buffer, one kilobyte,

00:05:00,870 --> 00:05:04,623
and then pushing it out to the TTY using assembly calls.

00:05:06,150 --> 00:05:08,023
So it's a synchronous printk.

00:05:09,330 --> 00:05:11,070
And if we go through back the logs now,

00:05:11,070 --> 00:05:13,160
I'm only highlighting the ones, this is,

00:05:13,160 --> 00:05:14,720
actually this list is only the things

00:05:14,720 --> 00:05:17,980
that I consider significant to the printk history.

00:05:17,980 --> 00:05:19,090
And even from this list,

00:05:19,090 --> 00:05:21,490
I'm only gonna be talking about a couple items on

00:05:21,490 --> 00:05:23,530
this list because it has a very long history,

00:05:23,530 --> 00:05:26,220
it's been there for almost 30 years now.

00:05:26,220 --> 00:05:28,370
So, when we first started off in '91,

00:05:28,370 --> 00:05:31,270
we had this direct synchronous printing to the terminal.

00:05:31,270 --> 00:05:35,520
This is obviously something that is very reliable,

00:05:35,520 --> 00:05:38,270
but in a modern system where we have lots of different CPUs

00:05:38,270 --> 00:05:40,020
that maybe want to print, obviously,

00:05:40,020 --> 00:05:43,033
this solution would not work today, in this form at least.

00:05:44,570 --> 00:05:46,520
Not long later, we introduced the ringbuffer,

00:05:46,520 --> 00:05:49,336
and this is mainly because we needed syslog support,

00:05:49,336 --> 00:05:53,720
syslog needs to be able to access the previous messages

00:05:53,720 --> 00:05:56,770
that we've already given out, so we need to log them.

00:05:56,770 --> 00:05:59,979
And we also introduced kernel regis--,

00:05:59,979 --> 00:06:02,290
I'm sorry, console registration

00:06:02,290 --> 00:06:06,740
which meant if a console registers at some later point,

00:06:06,740 --> 00:06:09,320
then we need to spit out the messages

00:06:09,320 --> 00:06:11,360
that it's already missed, right?

00:06:11,360 --> 00:06:12,193
So this is,

00:06:12,193 --> 00:06:13,720
and this is something that we still do today, right?

00:06:13,720 --> 00:06:15,880
So if the net console registers, you know,

00:06:15,880 --> 00:06:17,060
after a few seconds

00:06:17,060 --> 00:06:19,970
then all the messages that the net console actually missed

00:06:19,970 --> 00:06:21,920
will get spit out over the net console.

00:06:23,130 --> 00:06:25,050
Log levels became in because once people,

00:06:25,050 --> 00:06:26,930
all these developers start working on Linux,

00:06:26,930 --> 00:06:29,290
they started adding all kinds of messages

00:06:29,290 --> 00:06:32,230
and so the log levels came in there so we could reduce

00:06:32,230 --> 00:06:33,203
or increase that.

00:06:36,045 --> 00:06:36,878
The...

00:06:37,810 --> 00:06:39,170
At some point we decided we wanted to have

00:06:39,170 --> 00:06:40,130
more consoles, right?

00:06:40,130 --> 00:06:41,560
So at the beginning we messed with just the TTY

00:06:41,560 --> 00:06:42,737
and then later we said,

00:06:42,737 --> 00:06:44,920
"Well, we can also do serial."

00:06:44,920 --> 00:06:47,150
And later even came network.

00:06:47,150 --> 00:06:49,060
So we could use all these consoles at the same time,

00:06:49,060 --> 00:06:50,990
so we actually had support from multiple consoles

00:06:50,990 --> 00:06:52,580
like we registered.

00:06:52,580 --> 00:06:54,850
And the way it was implemented is really,

00:06:54,850 --> 00:06:56,450
when a message came in from printk,

00:06:56,450 --> 00:06:57,820
then we went through a for-loop

00:06:57,820 --> 00:07:00,160
and just printed synchronously

00:07:00,160 --> 00:07:02,000
to every one of these consoles.

00:07:02,000 --> 00:07:05,610
And actually that code still exists today, you know?

00:07:05,610 --> 00:07:06,810
For every single message,

00:07:06,810 --> 00:07:09,893
we go and we print to every registered console.

00:07:12,690 --> 00:07:16,310
We then started having problems that, okay,

00:07:16,310 --> 00:07:17,800
we needed some sort of protection

00:07:17,800 --> 00:07:19,040
'cause we added locking in there,

00:07:19,040 --> 00:07:21,250
obviously when SMP came onto the scene,

00:07:21,250 --> 00:07:22,420
we need some sort of locking,

00:07:22,420 --> 00:07:23,253
and we had the problem well what if

00:07:23,253 --> 00:07:25,430
a lock is taken and now we crash?

00:07:25,430 --> 00:07:26,263
Right?

00:07:26,263 --> 00:07:28,120
And so we introduced a really great function called

00:07:28,120 --> 00:07:29,650
bust_spinlocks,

00:07:29,650 --> 00:07:31,130
which goes against everything

00:07:31,130 --> 00:07:32,100
that anyone has ever learned

00:07:32,100 --> 00:07:34,530
in computer engineering.

00:07:34,530 --> 00:07:35,660
Which basically says,

00:07:35,660 --> 00:07:37,440
well, if we're in a panic situation

00:07:37,440 --> 00:07:38,970
then let's just forget the locks, right?

00:07:38,970 --> 00:07:40,620
They're not important anymore, right?

00:07:40,620 --> 00:07:43,380
Which the locks really do have a purpose, right?

00:07:43,380 --> 00:07:44,213
But we thought,

00:07:44,213 --> 00:07:46,867
"Okay, well it's better than nothing, right?"

00:07:48,400 --> 00:07:50,070
And then, actually, 10 years later,

00:07:50,070 --> 00:07:52,280
about the 10 year anniversary of printk,

00:07:52,280 --> 00:07:53,580
there was a big change that came in

00:07:53,580 --> 00:07:57,477
from Andrew in the 2.4 kernel where really it was really

00:07:57,477 --> 00:08:00,090
the architecture of printk was changed quite a bit.

00:08:00,090 --> 00:08:02,700
There was this console_sem which was a semaphore

00:08:02,700 --> 00:08:04,300
that was brought it,

00:08:04,300 --> 00:08:06,150
that replaced the lock.

00:08:06,150 --> 00:08:09,650
There was a locking introduced for the log buffer

00:08:09,650 --> 00:08:10,780
and several other things.

00:08:10,780 --> 00:08:11,840
There was also, for example,

00:08:11,840 --> 00:08:14,410
an oops_in_progress global variable that was introduced

00:08:14,410 --> 00:08:16,580
so the whole system could decide what to do

00:08:16,580 --> 00:08:17,763
in a panic situation.

00:08:18,990 --> 00:08:19,823
And,

00:08:20,730 --> 00:08:21,730
actually this is,

00:08:21,730 --> 00:08:23,560
if you look at the patch from back then,

00:08:23,560 --> 00:08:25,920
this is pretty much what printk looks like now.

00:08:25,920 --> 00:08:28,800
This is actually very significant overhaul of the printk

00:08:28,800 --> 00:08:32,610
design that still exists today, more or less.

00:08:32,610 --> 00:08:34,970
But what's significant here, which I've highlighted,

00:08:34,970 --> 00:08:37,200
is that this was the moment that printk became

00:08:37,200 --> 00:08:38,950
non-synchronous.

00:08:38,950 --> 00:08:42,140
So rather than for every printk we print synchronously

00:08:42,140 --> 00:08:43,430
to every console,

00:08:43,430 --> 00:08:45,660
it was changed so that if somebody,

00:08:45,660 --> 00:08:48,500
if a printk comes in and someone else is already printing,

00:08:48,500 --> 00:08:50,870
then just let them print my message too, right?

00:08:50,870 --> 00:08:53,010
So, basically,

00:08:53,010 --> 00:08:55,810
that meant printk might go really fast if someone else

00:08:55,810 --> 00:08:57,970
is already doing the printing.

00:08:57,970 --> 00:08:59,970
Now, if you're the guy doing the printing,

00:08:59,970 --> 00:09:01,640
that's not gonna be fun if all of a sudden

00:09:01,640 --> 00:09:03,480
all these people start doing printks,

00:09:03,480 --> 00:09:05,493
you have a lot of work to do ahead of you.

00:09:08,610 --> 00:09:10,860
So, little bit later we got dynamic allocating,

00:09:10,860 --> 00:09:13,040
that came in because before up to this point

00:09:13,040 --> 00:09:15,180
it was just a static buffer in the kernel.

00:09:15,180 --> 00:09:17,120
So now actually when the kernel boots,

00:09:17,120 --> 00:09:19,500
fairly early in the boot process,

00:09:19,500 --> 00:09:21,760
it'll actually allocate memory dynamically

00:09:21,760 --> 00:09:24,780
and then move those messages over to the dynamic version

00:09:24,780 --> 00:09:27,563
so you can have very large printk buffers if you want.

00:09:29,390 --> 00:09:33,640
And, at some point we wanted this big kernel lock removed

00:09:33,640 --> 00:09:35,510
the BKL, right?

00:09:35,510 --> 00:09:39,670
And we weren't disabling interrupts while we were printing

00:09:39,670 --> 00:09:42,470
on the consoles but we realized when we removed the BKL

00:09:42,470 --> 00:09:44,270
all of a sudden nothing worked anymore.

00:09:44,270 --> 00:09:46,207
So, to work around that we said,

00:09:46,207 --> 00:09:48,150
"Okay, well if we're gonna be caught in the console drivers

00:09:48,150 --> 00:09:50,130
then we need to disable interrupts."

00:09:50,130 --> 00:09:52,090
And this is because the drivers are doing all kinds of

00:09:52,090 --> 00:09:52,923
things,

00:09:53,934 --> 00:09:57,050
we just need to be safe and disable the interrupts there.

00:09:57,050 --> 00:09:59,410
Timing information came in,

00:09:59,410 --> 00:10:01,390
and here's what's really interesting.

00:10:01,390 --> 00:10:03,850
So now we're disabling the interrupts during the console

00:10:03,850 --> 00:10:06,180
printing, and we notice we're having these huge

00:10:06,180 --> 00:10:08,400
latency spikes because interrupts are disabled

00:10:08,400 --> 00:10:10,880
for a long time when I'm printing a line on serial

00:10:10,880 --> 00:10:13,810
it might be 960kbs or something,

00:10:13,810 --> 00:10:15,430
it takes a long time to print that line

00:10:15,430 --> 00:10:18,400
and the interrupts are disabled for that huge thing.

00:10:18,400 --> 00:10:20,000
So what was our solution?

00:10:20,000 --> 00:10:23,460
Let's ignore the latency time if we're printing

00:10:23,460 --> 00:10:24,600
to the consoles.

00:10:24,600 --> 00:10:25,433
Right?

00:10:25,433 --> 00:10:29,010
So, rather than addressing the issue at that point,

00:10:29,010 --> 00:10:32,450
we just decide well let's just ignore those latencies

00:10:32,450 --> 00:10:35,220
so that we can track other latencies, right?

00:10:35,220 --> 00:10:37,540
But this doesn't make sense really, I mean,

00:10:37,540 --> 00:10:40,270
if I have real-time system and it has a huge latency,

00:10:40,270 --> 00:10:41,103
and I'm like,

00:10:41,103 --> 00:10:43,290
"Well why aren't, the serial console isn't even showing up

00:10:43,290 --> 00:10:44,123
on my graphs,"

00:10:44,123 --> 00:10:45,920
well it's because we're ignoring that latency.

00:10:45,920 --> 00:10:46,753
Secretly.

00:10:48,410 --> 00:10:50,320
The kdump interface showed up so that, you know,

00:10:50,320 --> 00:10:53,070
if a kernel crashes you could actually get to the logs.

00:10:54,340 --> 00:10:56,230
And then here's what I call one of the first

00:10:56,230 --> 00:10:57,450
real big duct tapes

00:10:57,450 --> 00:10:58,543
started to show in,

00:11:00,060 --> 00:11:02,960
keep in mind we have registered consoles that are

00:11:02,960 --> 00:11:06,330
registering later, and we need to reprint everything.

00:11:06,330 --> 00:11:08,540
But at that point, and still today,

00:11:08,540 --> 00:11:11,190
there is only one index that keep tracks of where

00:11:11,190 --> 00:11:12,740
we are in this ringbuffer, right?

00:11:12,740 --> 00:11:15,750
So when someone else registers,

00:11:15,750 --> 00:11:17,910
and we need to replay the ringbuffer,

00:11:17,910 --> 00:11:19,927
then what we do is we say,

00:11:19,927 --> 00:11:22,410
"Okay, this is now an exclusive console."

00:11:22,410 --> 00:11:26,270
We reset the index, and we only print to this one console

00:11:26,270 --> 00:11:27,350
until we get back to there,

00:11:27,350 --> 00:11:29,650
and now we let everyone else print again.

00:11:29,650 --> 00:11:31,580
This works, of course.

00:11:31,580 --> 00:11:35,430
But there are more elegant ways to handle multiple consoles,

00:11:35,430 --> 00:11:36,880
right?

00:11:36,880 --> 00:11:38,350
Okay.

00:11:38,350 --> 00:11:42,370
And with 3.4 actually, with the push of systemd,

00:11:42,370 --> 00:11:44,520
there was a lot of re-engineering to printk,

00:11:44,520 --> 00:11:48,340
this is I would call the second major revision of printk.

00:11:48,340 --> 00:11:51,090
This is where we actually went from just a list of strings

00:11:51,090 --> 00:11:53,310
in a ringbuffer to actual real structures that were

00:11:53,310 --> 00:11:54,790
variable length.

00:11:54,790 --> 00:11:56,860
We added sequence numbers

00:11:56,860 --> 00:11:58,840
and we added the /dev/kmsg interface,

00:11:58,840 --> 00:12:02,250
read and write, so that the systemd daemon could

00:12:03,230 --> 00:12:05,473
directly access the printk stuff.

00:12:09,870 --> 00:12:12,990
Okay so this, anyway, this is a big change.

00:12:12,990 --> 00:12:16,090
And the interesting thing is once we have sequence numbers,

00:12:16,090 --> 00:12:18,730
so we can actually number, which is a good thing because

00:12:18,730 --> 00:12:20,260
if you have sequence numbers, now you can detect

00:12:20,260 --> 00:12:22,100
if you've dropped, like if we've lost some messages,

00:12:22,100 --> 00:12:24,900
before we didn't know that we were dropping anything

00:12:24,900 --> 00:12:26,310
because they weren't numbered.

00:12:26,310 --> 00:12:28,800
So once we have sequence numbers, now we can detect

00:12:28,800 --> 00:12:30,400
that messages are being dropped.

00:12:31,690 --> 00:12:35,010
And what recently, 2016,

00:12:35,010 --> 00:12:36,420
the idea of NMI

00:12:36,420 --> 00:12:39,440
because until that point we still couldn't really

00:12:39,440 --> 00:12:41,190
print from NMI context, right?

00:12:41,190 --> 00:12:44,880
Because printf, prtink still tries to print to the console

00:12:44,880 --> 00:12:46,200
if no one else is printing,

00:12:46,200 --> 00:12:47,033
then I need to do it.

00:12:47,033 --> 00:12:50,250
And if I'm in a NMI context this isn't gonna work, right?

00:12:50,250 --> 00:12:53,625
So there was actually several iterations here,

00:12:53,625 --> 00:12:56,200
you can actually see the evolution to the safe buffers,

00:12:56,200 --> 00:12:57,700
but actually came in 4.18,

00:12:57,700 --> 00:12:59,070
where actually have safe buffers.

00:12:59,070 --> 00:13:01,690
These are special buffers set aside,

00:13:01,690 --> 00:13:04,010
and if we want a printk from NMI context,

00:13:04,010 --> 00:13:06,449
we just copy to those buffers and then we trigger a IRQ

00:13:06,449 --> 00:13:10,260
work and it's supposed to then copy it into the real

00:13:10,260 --> 00:13:12,973
ringbuffer under the lock.

00:13:14,620 --> 00:13:16,210
Now, what happens when we crash?

00:13:16,210 --> 00:13:17,730
We've got all these things sitting in these buffers

00:13:17,730 --> 00:13:21,090
that hasn't been moved over yet and we crash,

00:13:21,090 --> 00:13:23,690
then also we want to flush those buffers

00:13:23,690 --> 00:13:26,193
so can see them when the machine panics.

00:13:27,700 --> 00:13:30,050
Very recently, so last year,

00:13:30,050 --> 00:13:31,910
there was a lot of work to add,

00:13:31,910 --> 00:13:34,770
a console ownering/waiter concept.

00:13:34,770 --> 00:13:37,180
So this is, you know, we're coming up on 30 years

00:13:37,180 --> 00:13:38,130
and finally we're like,

00:13:38,130 --> 00:13:40,710
okay, this one guy who's printing, if there's all these

00:13:40,710 --> 00:13:43,900
other people calling printks and this one printer's

00:13:43,900 --> 00:13:47,030
stuck printing, then the CPU might just be printing

00:13:47,030 --> 00:13:48,740
the rest of it's life.

00:13:48,740 --> 00:13:51,190
No one else gets a chance to do anything, right?

00:13:51,190 --> 00:13:54,057
And so, this new logic came in that says,

00:13:54,057 --> 00:13:57,340
"If someone's printing, then I'm actually gonna take over

00:13:57,340 --> 00:13:58,173
the printing."

00:13:58,173 --> 00:13:59,006
Right?

00:13:59,006 --> 00:14:01,260
So each person that prints is actually taking over

00:14:01,260 --> 00:14:03,963
from another task that might already be printing.

00:14:05,160 --> 00:14:06,130
And then finally,

00:14:06,130 --> 00:14:07,160
really new,

00:14:07,160 --> 00:14:09,950
is we have a feature called LOG_CONT,

00:14:09,950 --> 00:14:12,000
which means I can just do part,

00:14:12,000 --> 00:14:14,130
I can kind of build my message on the fly with

00:14:14,130 --> 00:14:16,320
multiple printk calls and at some point

00:14:16,320 --> 00:14:17,573
flush that whole thing.

00:14:18,660 --> 00:14:21,930
That in of itself is kind of a nightmare.

00:14:21,930 --> 00:14:24,300
But we actually with the 5.0,

00:14:24,300 --> 00:14:28,630
we actually have a pretty good idea of how to at least,

00:14:28,630 --> 00:14:31,380
to coordinate whose partial messages are who.

00:14:31,380 --> 00:14:33,010
If you have two different CPUs that are doing partial

00:14:33,010 --> 00:14:34,930
messages, then it's,

00:14:34,930 --> 00:14:36,070
we have to be able to coordinate

00:14:36,070 --> 00:14:37,270
is this piece coming from him

00:14:37,270 --> 00:14:39,040
or is this piece coming from this guy?

00:14:39,040 --> 00:14:42,940
So with 5.0 we actually have caller IDs now

00:14:42,940 --> 00:14:44,790
that we can tell who's printing what.

00:14:46,270 --> 00:14:47,103
So what are the open issues?

00:14:47,103 --> 00:14:48,380
We've added all these changes,

00:14:48,380 --> 00:14:50,090
we've added all these features,

00:14:50,090 --> 00:14:52,880
what are the current issues right now with printk?

00:14:52,880 --> 00:14:56,780
First of all, we have this raw_spinlock called lock-buff

00:14:56,780 --> 00:15:00,410
that's protecting the lock buffer, no, the log buffer,

00:15:00,410 --> 00:15:01,640
the ringbuffer.

00:15:01,640 --> 00:15:05,300
The problem with that is it cannot be taken from NMI context

00:15:05,300 --> 00:15:06,690
at all times, right?

00:15:06,690 --> 00:15:09,030
Like if we were an NMI, we'll try to take it,

00:15:09,030 --> 00:15:10,640
if it's, we'll do a try lock, if we get it,

00:15:10,640 --> 00:15:11,840
great, we can print.

00:15:11,840 --> 00:15:12,910
But if it's already locked,

00:15:12,910 --> 00:15:15,630
we still have to use the safe buffers, right?

00:15:15,630 --> 00:15:19,923
So we can't actually write into the ringbuffer immediately.

00:15:20,790 --> 00:15:23,180
So now we get to the safe buffers,

00:15:23,180 --> 00:15:24,500
they have a problem that, for example,

00:15:24,500 --> 00:15:26,360
they're using bogus timestamps.

00:15:26,360 --> 00:15:29,100
So the timestamping is not happening when it goes into

00:15:29,100 --> 00:15:31,230
the safe buffers, the timestamps are happening

00:15:31,230 --> 00:15:33,440
when it actually makes it to the real ringbuffer, right?

00:15:33,440 --> 00:15:35,810
Which might be considerably later, yeah?

00:15:35,810 --> 00:15:37,900
So when we look at our dmesg we see all these nice

00:15:37,900 --> 00:15:40,330
timestamps, but if any of those messages were coming

00:15:40,330 --> 00:15:43,820
from the safe buffers, those numbers are wrong.

00:15:43,820 --> 00:15:45,800
So those actually is not the order that the things

00:15:45,800 --> 00:15:47,650
were happening, and you can't even sort it

00:15:47,650 --> 00:15:49,600
because the timestamps come much later.

00:15:51,190 --> 00:15:54,440
It relies on the irq-work mechanism which is fairly

00:15:54,440 --> 00:15:57,760
reliable, but there are situations where this might be

00:15:57,760 --> 00:15:59,850
the last thing the CPU ever does,

00:15:59,850 --> 00:16:02,253
if we don't print now it's going to be lost.

00:16:03,380 --> 00:16:05,830
And then we have a little technical issue, that,

00:16:05,830 --> 00:16:08,410
you know, I said that if we have a panic situation

00:16:08,410 --> 00:16:11,900
we flush the safe buffers, but that's also not so trivial

00:16:11,900 --> 00:16:13,350
and there's situations, for example,

00:16:13,350 --> 00:16:15,380
if we can't bring all the CPUs offline,

00:16:15,380 --> 00:16:16,650
then we don't flush.

00:16:16,650 --> 00:16:18,540
So there's actually quite a bit of situations

00:16:18,540 --> 00:16:21,090
where the safe buffers will not get flushed at all.

00:16:22,390 --> 00:16:26,173
The console drivers are a problem that they're very slow,

00:16:28,000 --> 00:16:30,300
but really the problem is that we're calling them all with

00:16:30,300 --> 00:16:33,170
interrupts disabled, and we're calling them all together,

00:16:33,170 --> 00:16:34,003
right?

00:16:34,003 --> 00:16:37,000
So we have five consoles and we're gonna do all five of them

00:16:37,000 --> 00:16:38,920
with interrupts disabled, even if one of 'em's

00:16:38,920 --> 00:16:40,630
really fast and one of 'em's really slow,

00:16:40,630 --> 00:16:42,660
we're gonna do all five of them and then we're gonna,

00:16:42,660 --> 00:16:44,363
re-enable interrupts.

00:16:45,270 --> 00:16:47,550
Of course the fact that we're ignoring interrupt latencies

00:16:47,550 --> 00:16:50,870
with consoles, I don't have to say much about that.

00:16:50,870 --> 00:16:52,970
And we have a problem with that the console drivers

00:16:52,970 --> 00:16:54,780
are just not reliable in the panic situation

00:16:54,780 --> 00:16:56,240
because they're not made for that, you know?

00:16:56,240 --> 00:16:58,360
If we're panicking in NMI context,

00:16:58,360 --> 00:17:00,293
the drivers just won't help us.

00:17:02,210 --> 00:17:03,043
Another issue,

00:17:03,900 --> 00:17:06,760
we're treating info messages exactly the same as

00:17:06,760 --> 00:17:08,330
emergency message, right?

00:17:08,330 --> 00:17:10,113
So that message that just says,

00:17:11,010 --> 00:17:14,270
our /dev/random is finally ready with real random data,

00:17:14,270 --> 00:17:17,810
is exactly as important as we just resolved a null pointer,

00:17:17,810 --> 00:17:19,250
right?

00:17:19,250 --> 00:17:21,560
Which means we're keeping these at the,

00:17:21,560 --> 00:17:23,410
we're handling them, the exactly the same

00:17:23,410 --> 00:17:26,370
which means, are we, do we treat them both as an emergency?

00:17:26,370 --> 00:17:28,700
Or do we treat them both as informational?

00:17:28,700 --> 00:17:30,590
But the whole handling of this, you know.

00:17:30,590 --> 00:17:32,790
Obviously one is more important than the other.

00:17:32,790 --> 00:17:35,690
It's nice that the random is, it's ready,

00:17:35,690 --> 00:17:38,080
but I would prefer to get the information

00:17:38,080 --> 00:17:39,680
that we just did a null pointer.

00:17:41,900 --> 00:17:43,700
I already mentioned that, you know,

00:17:43,700 --> 00:17:45,540
we've improved this, that you know,

00:17:45,540 --> 00:17:47,680
every time that someone does a printk,

00:17:47,680 --> 00:17:50,580
this task takes over the printing task, right?

00:17:50,580 --> 00:17:53,310
So, that printing task is finally relieved

00:17:53,310 --> 00:17:55,460
and someone else can come along.

00:17:55,460 --> 00:17:58,000
The problem is when I'm the last guy,

00:17:58,000 --> 00:17:59,670
I get to do the rest, right?

00:17:59,670 --> 00:18:01,600
So, you know, if there's like,

00:18:01,600 --> 00:18:04,510
you know, 50-60 printks that have been, you know,

00:18:04,510 --> 00:18:06,350
stacking up there and all of a sudden I'm the last one,

00:18:06,350 --> 00:18:08,955
I'm actually have a lot of stuff that I need to print there,

00:18:08,955 --> 00:18:09,788
right?

00:18:09,788 --> 00:18:11,050
So that's,

00:18:11,050 --> 00:18:12,970
it's not fun to be the last guy in that situation.

00:18:12,970 --> 00:18:15,740
So although this did really relieve a lot of real

00:18:15,740 --> 00:18:20,110
situations, it was very helpful to hand off the printk-ing.

00:18:20,110 --> 00:18:21,460
But if you're the last one,

00:18:22,700 --> 00:18:23,533
it's no fun.

00:18:23,533 --> 00:18:26,290
And this actually makes it a big wildcard for callers

00:18:26,290 --> 00:18:27,310
of printk.

00:18:27,310 --> 00:18:29,800
You know, if I'm in certain context I might be afraid

00:18:29,800 --> 00:18:31,790
of using printk because am I,

00:18:31,790 --> 00:18:33,130
is it gonna be expensive?

00:18:33,130 --> 00:18:34,190
Or is it going to be cheap?

00:18:34,190 --> 00:18:36,710
I don't even know, it depends on the ordering

00:18:36,710 --> 00:18:39,333
if I was the last task to do the printing.

00:18:40,350 --> 00:18:43,210
And the last major open issue is the fact that

00:18:43,210 --> 00:18:45,580
we have this oops_in_progress global variable,

00:18:45,580 --> 00:18:50,300
which is kind of politely requesting drivers to ignore

00:18:50,300 --> 00:18:54,340
their locks, and we also have a bust_spinlocks function

00:18:54,340 --> 00:18:58,170
that explicitly tells printk to ignore its locks.

00:18:58,170 --> 00:19:02,840
And it's my opinion that we're a lot of brilliant people

00:19:02,840 --> 00:19:05,050
and after 30 years of printk there has to be a way,

00:19:05,050 --> 00:19:08,280
a better way to do this than to just ignore locks,

00:19:08,280 --> 00:19:11,080
because it actually doesn't work in a lot of situations.

00:19:12,980 --> 00:19:15,470
So the problem, you know, after looking at this,

00:19:15,470 --> 00:19:16,320
I looked at all these issues,

00:19:16,320 --> 00:19:17,797
I looked at the history and I said,

00:19:17,797 --> 00:19:19,457
"What is the main issue here?"

00:19:20,470 --> 00:19:22,600
And the main issue that I got out of this is we have a

00:19:22,600 --> 00:19:24,250
tug-of-war going on.

00:19:24,250 --> 00:19:27,040
We want this non-interference, you know,

00:19:27,040 --> 00:19:28,910
that we can just printk whatever as much,

00:19:28,910 --> 00:19:31,360
we can just be, a loop of printk-ing,

00:19:31,360 --> 00:19:33,080
we don't want to disturb the system.

00:19:33,080 --> 00:19:35,580
And at the other time, at the same time,

00:19:35,580 --> 00:19:39,010
if it crashes, we want this information now, right?

00:19:39,010 --> 00:19:41,340
And these are two requirements that are actually

00:19:41,340 --> 00:19:43,080
working against each other.

00:19:43,080 --> 00:19:46,300
And so what happens is we end up with a solution

00:19:46,300 --> 00:19:48,170
that's not good for both sides, right?

00:19:48,170 --> 00:19:50,390
So we're both tug-of-warring and this side's not happy

00:19:50,390 --> 00:19:51,700
and that side's not happy,

00:19:51,700 --> 00:19:54,210
and we just got something kind of in the middle.

00:19:54,210 --> 00:19:57,950
And I was kind of inspired by Randall Monroe,

00:19:57,950 --> 00:20:00,300
who wrote an article about tug-of-war,

00:20:00,300 --> 00:20:01,133
and he said,

00:20:01,133 --> 00:20:02,860
"In the ultimate game of tug-of-war

00:20:02,860 --> 00:20:05,317
the only winning move is not to pull."

00:20:06,310 --> 00:20:09,330
So, we need to remove this that we have

00:20:09,330 --> 00:20:10,910
printk fighting with itself:

00:20:10,910 --> 00:20:12,860
do I want to be non-interference,

00:20:12,860 --> 00:20:14,660
or I want to be reliable?

00:20:14,660 --> 00:20:15,930
And really if,

00:20:15,930 --> 00:20:19,140
the only purpose of my talk really is this, right?

00:20:19,140 --> 00:20:20,890
So we'll go into some solutions,

00:20:20,890 --> 00:20:25,040
but really this idea of we need to get out of this mindset

00:20:25,040 --> 00:20:28,070
that printk has to do both sides equally, right?

00:20:28,070 --> 00:20:30,440
We need to have this,

00:20:30,440 --> 00:20:33,180
we need to handle these things separately.

00:20:33,180 --> 00:20:35,250
So what does it mean to not pull?

00:20:35,250 --> 00:20:36,290
Right?

00:20:36,290 --> 00:20:39,290
And it turns out, if you look at what printk is doing,

00:20:39,290 --> 00:20:41,020
and then if you ask yourself the question,

00:20:41,020 --> 00:20:44,010
what is it printing and when is it printing,

00:20:44,010 --> 00:20:45,810
then you can start to see actually,

00:20:45,810 --> 00:20:47,460
we can actually divide

00:20:47,460 --> 00:20:50,290
these two countering requirements, right?

00:20:50,290 --> 00:20:52,180
So for example, when I'm crashing,

00:20:52,180 --> 00:20:54,170
when there's warn_ons happening,

00:20:54,170 --> 00:20:55,003
things like this.

00:20:55,003 --> 00:20:57,120
These are situations that we know about,

00:20:57,120 --> 00:20:59,370
we know that it's happening, right?

00:20:59,370 --> 00:21:00,750
They're being triggered and we're calling into the

00:21:00,750 --> 00:21:01,680
bug function, right?

00:21:01,680 --> 00:21:04,010
So it knows that there's something serious going on,

00:21:04,010 --> 00:21:08,310
as opposed to someone who's just printing random

00:21:08,310 --> 00:21:10,253
information about the USB or whatever.

00:21:11,340 --> 00:21:13,140
So the fact that what we're printing

00:21:13,140 --> 00:21:14,860
and when we're printing it, for example,

00:21:14,860 --> 00:21:16,370
if also if I'm in a panic situation,

00:21:16,370 --> 00:21:17,610
that's also a win,

00:21:17,610 --> 00:21:20,330
then the things in there are extremely important.

00:21:20,330 --> 00:21:22,520
So we can kind of start to partition this,

00:21:22,520 --> 00:21:25,104
and to see there's actually two different types

00:21:25,104 --> 00:21:27,033
of scenarios there.

00:21:27,960 --> 00:21:30,270
And so really, my solution is,

00:21:30,270 --> 00:21:32,530
my recommendation, what I'm trying to push,

00:21:32,530 --> 00:21:34,580
is that we split this into two problems

00:21:34,580 --> 00:21:37,220
with two different solutions.

00:21:37,220 --> 00:21:40,210
So, the first problem is the non-interference one.

00:21:40,210 --> 00:21:41,930
And so, what I'm really trying to push

00:21:41,930 --> 00:21:44,400
is to make printk fully preemptible, right?

00:21:44,400 --> 00:21:45,820
So we do this first of all,

00:21:45,820 --> 00:21:49,050
with a all-context-safe ringbuffer.

00:21:49,050 --> 00:21:51,340
So we need to get away from this raw_spinlock

00:21:51,340 --> 00:21:54,590
that's sitting around protecting the ringbuffer.

00:21:54,590 --> 00:21:56,930
This will give us the freedom that we can just,

00:21:56,930 --> 00:21:58,730
it doesn't matter what context we're in,

00:21:58,730 --> 00:22:00,320
we can just insert those messages

00:22:00,320 --> 00:22:01,660
into the ring buffer, right?

00:22:01,660 --> 00:22:02,830
So this will help us,

00:22:02,830 --> 00:22:05,140
this non-interference that we don't have to do any

00:22:05,140 --> 00:22:07,960
special locks, or we're you know,

00:22:07,960 --> 00:22:10,390
causing extra IRQ works or anything like this,

00:22:10,390 --> 00:22:13,290
we could just throw it in there and it's in there.

00:22:13,290 --> 00:22:14,210
The second thing is,

00:22:14,210 --> 00:22:16,540
is that we go to per-console kthreads.

00:22:16,540 --> 00:22:19,070
And I'll go into these things in a little bit more detail

00:22:19,070 --> 00:22:20,960
in the upcoming slides.

00:22:20,960 --> 00:22:25,460
Now, kthreads have been tried in the past.

00:22:25,460 --> 00:22:27,050
But in my opinion, the problem was

00:22:27,050 --> 00:22:30,220
the past attempts at using kthreads is

00:22:30,220 --> 00:22:34,410
they didn't try to separate the critical messages

00:22:34,410 --> 00:22:35,490
for the non-critical message.

00:22:35,490 --> 00:22:37,520
They still, they tried to do everything with the kthread.

00:22:37,520 --> 00:22:40,150
So you're not really solving the problem,

00:22:40,150 --> 00:22:42,580
you're just moving it into kthreads,

00:22:42,580 --> 00:22:44,230
which is not necessarily helpful.

00:22:45,820 --> 00:22:48,160
So the other problem which we want to solve,

00:22:48,160 --> 00:22:49,220
which is a separate problem,

00:22:49,220 --> 00:22:50,880
is reliability.

00:22:50,880 --> 00:22:54,540
And the idea was that we provide an official synchronous

00:22:54,540 --> 00:22:57,100
channel where we can put important messages.

00:22:57,100 --> 00:22:58,820
For example, when the machine is crashing,

00:22:58,820 --> 00:23:00,230
panic situation, bugs,

00:23:00,230 --> 00:23:03,830
and we use this other channel, this synchronous channel

00:23:03,830 --> 00:23:06,563
when want to get this out, get this information out.

00:23:07,460 --> 00:23:08,820
So this also,

00:23:08,820 --> 00:23:12,360
to make use of the all-context-safe ringbuffer

00:23:12,360 --> 00:23:13,560
that can be used anytime,

00:23:13,560 --> 00:23:15,710
so we can get those messages in the ringbuffer all the time.

00:23:15,710 --> 00:23:18,200
This is really important because there a lot of interfaces

00:23:18,200 --> 00:23:19,033
in kernel, for example,

00:23:19,033 --> 00:23:20,670
the kmsg_dump interface,

00:23:20,670 --> 00:23:22,930
where other calls backs need to get,

00:23:22,930 --> 00:23:24,810
will just grab those messages from the ring buffer.

00:23:24,810 --> 00:23:26,180
So it's really important that we at least

00:23:26,180 --> 00:23:27,070
get those in the ring buffer.

00:23:27,070 --> 00:23:28,960
We need the all-context-safe ringbuffer

00:23:28,960 --> 00:23:31,020
for both scenarios.

00:23:31,020 --> 00:23:33,160
But for the reliability scenario we're also gonna have

00:23:33,160 --> 00:23:34,330
atomic consoles,

00:23:34,330 --> 00:23:35,163
which is something that I'm going to

00:23:35,163 --> 00:23:36,160
talk about in a minute,

00:23:36,160 --> 00:23:38,160
and something called emergency messages.

00:23:39,730 --> 00:23:40,980
So first let's talk about the ring buffer

00:23:40,980 --> 00:23:42,350
which we need for both,

00:23:42,350 --> 00:23:43,493
they both need this.

00:23:44,420 --> 00:23:46,010
Even though it's not,

00:23:46,010 --> 00:23:47,900
the problems are being solved separately

00:23:47,900 --> 00:23:50,430
but both problems need this thing.

00:23:50,430 --> 00:23:53,543
The first iteration was something that was using a CPU lock,

00:23:54,700 --> 00:23:59,160
and this ring buffer can be called from any context,

00:23:59,160 --> 00:24:03,650
it supports multiple readers and a single writing CPU.

00:24:03,650 --> 00:24:06,430
Right, so when I say writing CPU it means

00:24:06,430 --> 00:24:09,603
if the CPU's writing and then there's an NMI on the CPU,

00:24:09,603 --> 00:24:11,980
that CPU can also continue to write, right?

00:24:11,980 --> 00:24:14,960
But another CPU would actually have to

00:24:14,960 --> 00:24:16,483
wait for the CPU to finish.

00:24:17,920 --> 00:24:20,380
It stores all data contiguously in memory,

00:24:20,380 --> 00:24:22,610
exactly like the current printk,

00:24:22,610 --> 00:24:25,070
and it's a relatively simple implementation.

00:24:25,070 --> 00:24:27,080
And we're not gonna go into this,

00:24:27,080 --> 00:24:29,710
but actually if you got to the website from Linux Plumbers

00:24:29,710 --> 00:24:31,410
and you download my slides,

00:24:31,410 --> 00:24:34,480
there's like ten slides after my thank you slide,

00:24:34,480 --> 00:24:36,520
that show a lot of pictures and a lot of detail.

00:24:36,520 --> 00:24:38,500
So if you're really interested in how we're implementing

00:24:38,500 --> 00:24:40,780
this, it's a lot of detailed information.

00:24:40,780 --> 00:24:43,573
But unfortunately, I don't have enough time here for that.

00:24:44,670 --> 00:24:47,370
Now the implementation is using this CPU-lock,

00:24:47,370 --> 00:24:50,220
which is actually a CPU re-entrant spinlock.

00:24:50,220 --> 00:24:54,260
Which means if a CPU grabs the spinlock,

00:24:54,260 --> 00:24:57,480
and the owner of that spinlock is the same CPU,

00:24:57,480 --> 00:24:59,040
then I also get it, right?

00:24:59,040 --> 00:25:01,760
So it's, you're allowed to re grab that spinlock

00:25:01,760 --> 00:25:03,807
if it's on the CPU, same CPU.

00:25:03,807 --> 00:25:06,963
And we use this to serialize the writers.

00:25:07,840 --> 00:25:10,790
And there's also in the Appendix the code to show you

00:25:10,790 --> 00:25:12,640
what the CPU-lock looks like in code.

00:25:13,790 --> 00:25:15,520
What this ringbuffer also does is it

00:25:15,520 --> 00:25:18,550
uses logical positions to avoid an ABA problem,

00:25:18,550 --> 00:25:19,453
so if you have a, you know,

00:25:19,453 --> 00:25:21,967
ringbuffer that's only 4 kilobytes large,

00:25:21,967 --> 00:25:23,470
and it wraps around,

00:25:23,470 --> 00:25:25,580
we're lockless now so a reader,

00:25:25,580 --> 00:25:26,480
a reader might say,

00:25:26,480 --> 00:25:28,100
Okay I want to read this message.

00:25:28,100 --> 00:25:30,750
And maybe the reader blocked for a couple seconds,

00:25:30,750 --> 00:25:32,670
and then when I actually came time to read it,

00:25:32,670 --> 00:25:34,330
maybe that ringbuffer's wrapped three times

00:25:34,330 --> 00:25:35,163
since then, right?

00:25:35,163 --> 00:25:36,530
So it's reading the position,

00:25:36,530 --> 00:25:38,420
but it's actually a totally wrong message.

00:25:38,420 --> 00:25:41,700
And so rather than just using an index into a buffer,

00:25:41,700 --> 00:25:44,740
it's actually just a logical position that just keeps going

00:25:44,740 --> 00:25:47,790
on so that we have an actual unsigned long that has to wrap

00:25:47,790 --> 00:25:50,133
before that, for that ABA problem.

00:25:51,970 --> 00:25:54,760
The only real concerns about this version

00:25:54,760 --> 00:25:56,600
was that the CPU-lock has kind of a

00:25:56,600 --> 00:25:58,163
Big Kernel Lock feel to it.

00:25:59,330 --> 00:26:00,700
You can only have one in the system,

00:26:00,700 --> 00:26:02,210
if you have more than one in your system

00:26:02,210 --> 00:26:05,390
you can actually really easily create deadlocks.

00:26:05,390 --> 00:26:08,050
So we have, those kind of start to feel like BKL already,

00:26:08,050 --> 00:26:09,920
we only have one.

00:26:09,920 --> 00:26:14,110
And if we're gonna be doing any NMI locking at all,

00:26:14,110 --> 00:26:15,390
so for example, If I'm,

00:26:15,390 --> 00:26:17,650
if there's a chance that one NMI context is

00:26:17,650 --> 00:26:19,897
going to wait for another CPU,

00:26:21,100 --> 00:26:22,130
then you're also gonna have a problem.

00:26:22,130 --> 00:26:25,630
So, the NMI contexts are also required to use

00:26:25,630 --> 00:26:28,320
this global CPU-lock.

00:26:28,320 --> 00:26:31,110
Right, so it kinda has a BKL feel to it

00:26:31,110 --> 00:26:36,110
when you're talking NMI contexts and synchronizing the log.

00:26:38,270 --> 00:26:40,240
Yeah, it should never but it's done in the past,

00:26:40,240 --> 00:26:41,810
and the concerns are what if it does it again

00:26:41,810 --> 00:26:42,907
in the future, right?

00:26:44,380 --> 00:26:46,903
So then, to get around this situation,

00:26:48,347 --> 00:26:51,257
I was asked by Petr, who's the maintainer of printk,

00:26:51,257 --> 00:26:53,210
"Well can we do this without that CPU-lock?"

00:26:53,210 --> 00:26:55,150
And actually I happen to have one in my pocket

00:26:55,150 --> 00:26:58,360
because I was kind of working on a lockless version

00:26:58,360 --> 00:26:59,747
anyway, and so I was like,

00:26:59,747 --> 00:27:02,040
"Okay, well let's try that."

00:27:02,040 --> 00:27:04,320
And so I actually created a new version, a different version

00:27:04,320 --> 00:27:06,900
of the ringbuffer, and this one was truly lockless,

00:27:06,900 --> 00:27:09,100
so it doesn't grab any locks whatsoever.

00:27:09,100 --> 00:27:11,530
It supports multiple readers, multiple writers,

00:27:11,530 --> 00:27:14,570
all contexts, and the raw record data

00:27:14,570 --> 00:27:15,610
is stored contiguously.

00:27:15,610 --> 00:27:18,740
So there's some information that's not stored contiguously,

00:27:18,740 --> 00:27:22,160
but basically all of the printk messages themselves

00:27:22,160 --> 00:27:23,500
are all stored contiguously

00:27:23,500 --> 00:27:25,350
just like the current implementation.

00:27:26,960 --> 00:27:28,960
The way it works is it uses descriptors

00:27:28,960 --> 00:27:30,040
to store the meta-data.

00:27:30,040 --> 00:27:32,740
So we actually have, we have the ringbuffer itself,

00:27:32,740 --> 00:27:34,230
which has the raw data, and there's actually

00:27:34,230 --> 00:27:37,820
a separate structure that uses descriptors to describe

00:27:37,820 --> 00:27:39,853
where the records are located in there.

00:27:41,270 --> 00:27:43,040
In order to simplify this,

00:27:43,040 --> 00:27:46,560
I actually factored this into three different structures.

00:27:46,560 --> 00:27:48,614
So, it uses something called a numlist,

00:27:48,614 --> 00:27:50,076
which is just a numbered list,

00:27:50,076 --> 00:27:53,229
and the job of the numbered list is to sequence the records.

00:27:53,229 --> 00:27:55,330
It has a dataring buffer which is just,

00:27:55,330 --> 00:27:57,090
the basically a primitive ringbuffer,

00:27:57,090 --> 00:28:00,320
very similar to the version from 1992,

00:28:00,320 --> 00:28:03,420
to just track the raw data as the records,

00:28:03,420 --> 00:28:04,970
individual records.

00:28:04,970 --> 00:28:08,000
And then it uses a high-level printk-ringbuffer structure,

00:28:08,000 --> 00:28:11,100
which basically provides the interface to the ringbuffer.

00:28:11,100 --> 00:28:14,320
So it's using the dataring and the numlist

00:28:14,320 --> 00:28:17,090
to provide a coherent reader/writer interface

00:28:17,090 --> 00:28:18,850
to support all of the features of printk

00:28:18,850 --> 00:28:21,023
that we are, that we now have to support.

00:28:22,540 --> 00:28:24,500
To avoid the ABA problem,

00:28:24,500 --> 00:28:27,580
it also use logical positions for the dataring,

00:28:27,580 --> 00:28:29,300
and the numbered list, the numlist,

00:28:29,300 --> 00:28:30,980
which is actually a link list,

00:28:30,980 --> 00:28:33,700
uses node IDs rather than pointers because

00:28:33,700 --> 00:28:35,120
with pointers you can very quickly

00:28:35,120 --> 00:28:36,903
also get into the ABA problem.

00:28:38,740 --> 00:28:41,130
So what was the problem with this one?

00:28:41,130 --> 00:28:42,303
It was complicated,

00:28:43,290 --> 00:28:45,790
doing a pure lockless multi-reader/multi-writer

00:28:45,790 --> 00:28:48,280
was not easy and there's still in my opinion,

00:28:48,280 --> 00:28:50,380
ongoing research on this topic.

00:28:50,380 --> 00:28:52,530
I had the three different data structures,

00:28:52,530 --> 00:28:54,710
there was multiple writer variables

00:28:54,710 --> 00:28:56,000
that were shared between,

00:28:56,000 --> 00:28:58,060
that could be shared between CPUs.

00:28:58,060 --> 00:29:02,160
Which means you're left with nine memory barrier pairs.

00:29:02,160 --> 00:29:05,390
So basically, you have 18 memory barriers in this stuff,

00:29:05,390 --> 00:29:07,830
which is, becomes first of all,

00:29:07,830 --> 00:29:11,880
difficult to document because we don't really have

00:29:11,880 --> 00:29:14,850
a formalized method of documenting our memory barriers,

00:29:14,850 --> 00:29:17,200
so we have, we've done a lot of stuff in the direction

00:29:17,200 --> 00:29:20,077
of memory barriers and proving them,

00:29:20,077 --> 00:29:23,240
but the documentation, the kernel is still kinda

00:29:23,240 --> 00:29:25,000
do whatever you want.

00:29:25,000 --> 00:29:26,070
And when you've got 18 of them

00:29:26,070 --> 00:29:28,033
do whatever you want is not so easy.

00:29:29,439 --> 00:29:31,310
And obviously it's difficult to review.

00:29:31,310 --> 00:29:33,898
So we've got the data lists, the dataring,

00:29:33,898 --> 00:29:36,897
the numlist, we've got the 18 memory barriers in there.

00:29:36,897 --> 00:29:40,410
And it's difficult for other people to prove

00:29:40,410 --> 00:29:43,850
or to believe that what I've done is actually correct.

00:29:43,850 --> 00:29:47,340
And the situation came up, or the question came up,

00:29:47,340 --> 00:29:50,930
do we really need multi-writer support anyway, right?

00:29:50,930 --> 00:29:53,390
Can we just, the CPU-lock version

00:29:53,390 --> 00:29:55,660
actually was quite simple, right?

00:29:55,660 --> 00:29:56,887
The difference between the CPU-lock version

00:29:56,887 --> 00:30:00,040
and this version was really that this is multi-writer

00:30:00,040 --> 00:30:00,873
and that one's not.

00:30:00,873 --> 00:30:02,700
And if we don't really need that

00:30:02,700 --> 00:30:05,363
then maybe it's not worth all this extra effort.

00:30:06,770 --> 00:30:08,060
Okay, ringbuffer.

00:30:08,060 --> 00:30:10,120
So we got the two ringbuffers there,

00:30:10,120 --> 00:30:11,130
let's move onto the next one.

00:30:11,130 --> 00:30:13,440
It gets a little bit easier, maybe.

00:30:13,440 --> 00:30:15,740
So if we get to the topic of non-interference,

00:30:16,600 --> 00:30:18,370
that we want to solve,

00:30:18,370 --> 00:30:21,860
I proposed doing per console kernel threads.

00:30:21,860 --> 00:30:25,070
And the advantage of this is we can totally decouple

00:30:25,070 --> 00:30:27,830
the printk callers from the console, right?

00:30:27,830 --> 00:30:29,700
So when someone calls printk,

00:30:29,700 --> 00:30:31,970
that context is not actually printing.

00:30:31,970 --> 00:30:33,070
All they're doing is throwing it into a ringbuffer

00:30:33,070 --> 00:30:34,910
and then they're done, right?

00:30:34,910 --> 00:30:36,860
And there's actually a lot of advantages to that

00:30:36,860 --> 00:30:40,650
because there's a lot of crazy locks, for example,

00:30:40,650 --> 00:30:43,420
the console lock, that's involved in printk callers

00:30:43,420 --> 00:30:46,360
and printk callers don't want to deal with that,

00:30:46,360 --> 00:30:48,120
those consoles, they don't need to deal with them at all.

00:30:48,120 --> 00:30:49,720
Why should they have to?

00:30:49,720 --> 00:30:51,280
We're talking about non-interference here,

00:30:51,280 --> 00:30:53,180
they're just trying to get a message into the ringbuffer,

00:30:53,180 --> 00:30:54,013
right?

00:30:54,013 --> 00:30:56,623
So, let's decouple printk from the console completely.

00:30:57,820 --> 00:30:58,990
By doing this,

00:30:58,990 --> 00:31:01,890
we can now have individual iterators per console.

00:31:01,890 --> 00:31:04,570
So every console thread is just keeping track of where

00:31:04,570 --> 00:31:08,130
it is, which means that if I have a really fast console

00:31:08,130 --> 00:31:09,730
it can get the messages out quickly,

00:31:09,730 --> 00:31:11,000
and if I have a slow one it's going slow,

00:31:11,000 --> 00:31:12,760
but the slow console is not affecting

00:31:12,760 --> 00:31:14,090
the fast console, right?

00:31:14,090 --> 00:31:16,910
So maybe, on the network console I'm actually seeing

00:31:16,910 --> 00:31:19,970
that ftrace dump, I'm not missing anything.

00:31:19,970 --> 00:31:22,020
And on the serial console, I'm missing like 90%

00:31:22,020 --> 00:31:23,980
of the messages, but it doesn't matter.

00:31:23,980 --> 00:31:25,470
The way it is right now,

00:31:25,470 --> 00:31:27,320
they all miss 90% of the messages,

00:31:27,320 --> 00:31:29,500
which is just insane, right?

00:31:29,500 --> 00:31:31,950
We've got these fast consoles and they're being tied

00:31:31,950 --> 00:31:34,410
to a stone because they're dragging a serial console

00:31:34,410 --> 00:31:35,590
with them, right?

00:31:35,590 --> 00:31:37,653
So, let them go fast.

00:31:39,270 --> 00:31:41,070
There was also some patches floating around about

00:31:41,070 --> 00:31:43,360
individual log levels per console.

00:31:43,360 --> 00:31:45,820
In this situation that would also be very good

00:31:45,820 --> 00:31:46,653
because we can say,

00:31:46,653 --> 00:31:49,560
"So if I have a fast console, let it log a lot.

00:31:49,560 --> 00:31:51,680
If I have a slow console, let's have it log a little bit."

00:31:51,680 --> 00:31:54,340
You know, we can play with these things.

00:31:54,340 --> 00:31:57,040
And then obviously features like the exclusive console,

00:31:57,040 --> 00:31:58,340
which is really in my opinion,

00:31:58,340 --> 00:32:00,540
a real piece of duct tape,

00:32:00,540 --> 00:32:02,140
they just disappear on their own.

00:32:02,140 --> 00:32:03,690
Every console has their own iterator,

00:32:03,690 --> 00:32:04,880
they always start at the beginning

00:32:04,880 --> 00:32:06,700
and they just dump everything that there is, right?

00:32:06,700 --> 00:32:08,803
They're not affected by each other.

00:32:09,710 --> 00:32:12,503
So it makes a lot of sense in a lot of levels.

00:32:13,820 --> 00:32:16,070
So what are the concerns about this?

00:32:16,070 --> 00:32:18,570
First of all, obviously what happened with,

00:32:18,570 --> 00:32:19,560
what's with the console lock?

00:32:19,560 --> 00:32:21,020
We can't just ignore it and throw it away,

00:32:21,020 --> 00:32:23,080
the console lock does serve a purpose.

00:32:23,080 --> 00:32:25,440
One of the ideas from me was that

00:32:25,440 --> 00:32:28,100
we can turn it into something similar to a read/write lock

00:32:28,100 --> 00:32:30,220
where we have lots of readers that are allowed to,

00:32:30,220 --> 00:32:31,290
to go in there,

00:32:31,290 --> 00:32:34,280
in this case it would be the console kthreads.

00:32:34,280 --> 00:32:36,200
Or for the people that are not part of printk,

00:32:36,200 --> 00:32:37,300
so for example,

00:32:37,300 --> 00:32:38,870
as far as I'm aware of the DRM,

00:32:38,870 --> 00:32:40,460
the whole graphic infrastructure,

00:32:40,460 --> 00:32:42,930
they're also taking the console lock.

00:32:42,930 --> 00:32:44,190
If they take it, okay,

00:32:44,190 --> 00:32:46,140
then we'll keep all of our readers out of it

00:32:46,140 --> 00:32:47,840
but as soon as they're done with it

00:32:47,840 --> 00:32:50,130
then we can go ahead and let all readers go back in

00:32:50,130 --> 00:32:52,383
and get in there, work with the consoles.

00:32:53,793 --> 00:32:57,370
What we can also possibly do is use a per-console lock,

00:32:57,370 --> 00:32:58,330
which in my opinion,

00:32:58,330 --> 00:33:00,910
would be sufficient because as far as I know,

00:33:00,910 --> 00:33:05,700
the graphics people that are using this console semaphore,

00:33:05,700 --> 00:33:07,950
they're basically just using it as some sort of special

00:33:07,950 --> 00:33:11,090
locking for their TTYs or whatever, their displays.

00:33:11,090 --> 00:33:12,430
So really if they each,

00:33:12,430 --> 00:33:14,350
if each console has its own lock, in my opinion,

00:33:14,350 --> 00:33:15,183
that would be sufficient

00:33:15,183 --> 00:33:17,360
but we need to look at it in detail.

00:33:17,360 --> 00:33:19,050
Printk itself doesn't need this,

00:33:19,050 --> 00:33:21,510
the consoles themselves don't need this,

00:33:21,510 --> 00:33:23,710
but there are other people using this stuff.

00:33:25,220 --> 00:33:26,500
Because really at the end,

00:33:26,500 --> 00:33:29,100
the printk should not care about the console at all.

00:33:29,100 --> 00:33:31,900
They're just dumping messages to the ring buffer, right?

00:33:32,960 --> 00:33:35,480
The other concern is can we rely on kthreads

00:33:35,480 --> 00:33:36,670
for console printing?

00:33:36,670 --> 00:33:40,220
And my answer is that's not what we're trying to solve here,

00:33:40,220 --> 00:33:43,360
the kthreads are not solving the reliability problem,

00:33:43,360 --> 00:33:45,950
people need to stop thinking that.

00:33:45,950 --> 00:33:47,390
Stop thinking it as one problem

00:33:47,390 --> 00:33:49,170
and think of it as two problems.

00:33:49,170 --> 00:33:51,920
The kthreads are solving the issue of

00:33:51,920 --> 00:33:53,430
non-interference, right?

00:33:53,430 --> 00:33:55,570
There's other things that we'll see in the slides

00:33:55,570 --> 00:33:56,973
about solving the,

00:33:59,440 --> 00:34:00,690
the reliability.

00:34:00,690 --> 00:34:03,150
So if we can learn to stop pulling on each other,

00:34:03,150 --> 00:34:04,730
then we can actually start focusing

00:34:04,730 --> 00:34:07,490
how can we make the reliability solution more reliable,

00:34:07,490 --> 00:34:09,980
how can we make the non-interface, interference solution

00:34:09,980 --> 00:34:12,193
more non-interfering.

00:34:13,600 --> 00:34:15,070
If you go to reliability,

00:34:15,070 --> 00:34:17,710
I introduced something called atomic consoles,

00:34:17,710 --> 00:34:20,720
that's a new special callback in the console structure

00:34:20,720 --> 00:34:22,060
called right-atomic.

00:34:22,060 --> 00:34:25,510
It's basically like an early printk but it's safe.

00:34:25,510 --> 00:34:29,420
So we have early printk implementations for drivers

00:34:29,420 --> 00:34:32,470
but they're not safe, they just kinda just override

00:34:32,470 --> 00:34:34,720
the registers and don't worry about anything.

00:34:35,610 --> 00:34:38,380
That's not gonna work if two of two different CPUs

00:34:38,380 --> 00:34:40,740
are doing that at the same time, right?

00:34:40,740 --> 00:34:44,410
So let's create an atomic callback to really allow

00:34:44,410 --> 00:34:47,150
consoles to actually implement on their driver

00:34:48,270 --> 00:34:50,040
writing that is truly atomic,

00:34:50,040 --> 00:34:51,840
that can be called from any context.

00:34:54,560 --> 00:34:58,420
It also goes into atomic consoles are also synchronous.

00:34:58,420 --> 00:35:00,920
So if I'm gonna do an atomic write,

00:35:00,920 --> 00:35:03,260
then I'm actually going to sit there in an atomic write

00:35:03,260 --> 00:35:04,093
until it's done.

00:35:04,093 --> 00:35:06,890
This is kinda going back to the routes of printk 001,

00:35:06,890 --> 00:35:09,850
where you're actually sitting there until it's out there.

00:35:09,850 --> 00:35:11,420
So we're, we want to be reliable.

00:35:11,420 --> 00:35:12,690
I'm not just gonna throw it in there

00:35:12,690 --> 00:35:14,570
and hope someone else printed it, no.

00:35:14,570 --> 00:35:16,990
I'm gonna sit there and I'm going to print it

00:35:16,990 --> 00:35:19,493
and I'm gonna stay sitting here until it's printed.

00:35:23,240 --> 00:35:24,240
By doing that,

00:35:24,240 --> 00:35:27,120
we can actually ignore the console lock altogether,

00:35:27,120 --> 00:35:29,860
because we're doing something special there, right?

00:35:29,860 --> 00:35:32,240
So we're doing something atomic and the drivers

00:35:32,240 --> 00:35:33,850
are the ones that are gonna have to implement this, right?

00:35:33,850 --> 00:35:36,710
So if I have a driver and I have the right function,

00:35:36,710 --> 00:35:38,020
and I have the right atomic function,

00:35:38,020 --> 00:35:40,320
then it's my responsibility as the driver author

00:35:40,320 --> 00:35:42,770
to make sure that those two things are synchronized.

00:35:42,770 --> 00:35:45,683
And actually you can use the CPU-lock to do this.

00:35:47,090 --> 00:35:49,320
Now we don't want to use this reliability atomic consoles

00:35:49,320 --> 00:35:51,100
for everything because obviously,

00:35:51,100 --> 00:35:53,030
if I'm gonna sit in there and block until it's done,

00:35:53,030 --> 00:35:54,780
this is really gonna slow my system down,

00:35:54,780 --> 00:35:59,370
this is gonna be major interference on general level, right?

00:35:59,370 --> 00:36:01,270
But we're not, this is not dealing with interference,

00:36:01,270 --> 00:36:02,890
this is dealing with the reliability.

00:36:02,890 --> 00:36:04,140
And so really,

00:36:04,140 --> 00:36:06,460
the only things we want to be reliable

00:36:06,460 --> 00:36:08,380
are the critical messages.

00:36:08,380 --> 00:36:10,130
Not all the messages, right?

00:36:10,130 --> 00:36:11,940
So the only thing we really want to be printing

00:36:11,940 --> 00:36:13,400
are emergency messages,

00:36:13,400 --> 00:36:15,350
which we'll see on the next two slides.

00:36:18,740 --> 00:36:19,600
What's also nice about when,

00:36:19,600 --> 00:36:22,560
'cause PREEMPT_RT is going mainline,

00:36:22,560 --> 00:36:26,130
which means that the spinlocks that the different

00:36:26,130 --> 00:36:28,290
console drivers are taking are not actually spinlocks,

00:36:28,290 --> 00:36:30,300
they can actually sleep.

00:36:30,300 --> 00:36:34,650
Which means if we've got these atomic consoles

00:36:34,650 --> 00:36:37,030
that are available for PREEMPT_RT,

00:36:37,030 --> 00:36:39,650
then we can actually still do this reliability

00:36:39,650 --> 00:36:41,370
though the atomic writes,

00:36:41,370 --> 00:36:44,190
but the normal writes can still be sleeping spinlocks

00:36:44,190 --> 00:36:46,860
and we don't have to worry about anything

00:36:46,860 --> 00:36:49,720
regarding latencies of console drivers, right?

00:36:49,720 --> 00:36:50,720
So this--

00:36:50,720 --> 00:36:53,110
- [Audience Member] That makes a lot of sense aside of RT

00:36:53,110 --> 00:36:55,843
because there's no reason to,

00:36:56,700 --> 00:37:01,440
for that printing out of random messages that need atomic.

00:37:02,430 --> 00:37:05,060
- Yeah, it makes sense for everybody, right?

00:37:05,060 --> 00:37:05,893
So...

00:37:06,950 --> 00:37:08,290
Really there's, yeah.

00:37:08,290 --> 00:37:10,670
But the difference is, I mean, RT they're not actually

00:37:10,670 --> 00:37:13,240
spin locks, they're disabling interrupts.

00:37:13,240 --> 00:37:16,580
So we can actually, when we get to this ignoring of the

00:37:16,580 --> 00:37:20,170
latencies, then we can actually do that.

00:37:20,170 --> 00:37:21,830
Because the drivers are still doing

00:37:21,830 --> 00:37:23,043
spinlock irq safe, right?

00:37:23,043 --> 00:37:24,630
That the code is there, right?

00:37:24,630 --> 00:37:26,420
So only in the PREEMPT_RT is that not actually

00:37:26,420 --> 00:37:27,470
disabling interrupts.

00:37:28,940 --> 00:37:31,220
Anyway, if we, when we have these atomic consoles

00:37:31,220 --> 00:37:33,670
then we also don't need these special oops_in_progress

00:37:33,670 --> 00:37:35,940
that's supposed to be evaluated by the different drivers

00:37:35,940 --> 00:37:37,020
to do something special.

00:37:37,020 --> 00:37:39,330
And we don't need to ignore our locks because we have a

00:37:39,330 --> 00:37:41,613
function available to just write.

00:37:42,970 --> 00:37:45,270
Now the concerns with the atomic consoles are,

00:37:45,270 --> 00:37:47,650
how many drivers could we actually implement

00:37:47,650 --> 00:37:49,010
to be atomic?

00:37:49,010 --> 00:37:50,670
In my first release Canada,

00:37:50,670 --> 00:37:54,550
I implemented the 8250 UART as an example,

00:37:54,550 --> 00:37:58,110
but it was not trivial, you have to be really careful there

00:37:58,110 --> 00:38:00,937
to synchronize that and you have to make use of the CPU log.

00:38:03,610 --> 00:38:05,720
Basically the way it worked is, for example,

00:38:05,720 --> 00:38:07,280
if when writing to serial,

00:38:07,280 --> 00:38:10,760
we're using the CPU-log to synchronize per character.

00:38:10,760 --> 00:38:13,570
And we're using the CPU-log per line for the emergency,

00:38:13,570 --> 00:38:14,990
for the emergency messages, right?

00:38:14,990 --> 00:38:18,470
So like the serial is allowed to do one character at a time,

00:38:18,470 --> 00:38:20,600
which is just putting on the FIFa that's really fast.

00:38:20,600 --> 00:38:22,570
And then but if all the line comes along,

00:38:22,570 --> 00:38:26,120
then we can actually interrupt that with the atomic level

00:38:26,120 --> 00:38:27,623
and do an entire line.

00:38:29,360 --> 00:38:30,860
There was also the question of

00:38:31,700 --> 00:38:35,130
can something be done for systems without atomic consoles?

00:38:35,130 --> 00:38:37,080
Because, you know, let's face it.

00:38:37,080 --> 00:38:40,150
People have to write these atomic write function everywhere

00:38:41,098 --> 00:38:42,450
and maybe they can't figure it out

00:38:42,450 --> 00:38:44,080
or it just doesn't exist.

00:38:44,080 --> 00:38:46,300
So there was some different ideas floating around

00:38:46,300 --> 00:38:48,380
about how we can help these systems

00:38:48,380 --> 00:38:50,770
that actually don't have atomic consoles.

00:38:50,770 --> 00:38:53,540
For example, Linux recently threw up the idea

00:38:53,540 --> 00:38:56,980
that we could throw things into a separate memory variable

00:38:56,980 --> 00:38:58,860
in a reliable address,

00:38:58,860 --> 00:39:00,330
and when the system reboots

00:39:00,330 --> 00:39:01,970
maybe we can still read that area.

00:39:01,970 --> 00:39:04,560
And there's actually some tests around, and amazingly,

00:39:04,560 --> 00:39:06,440
after you reboot your system you can actually,

00:39:06,440 --> 00:39:07,820
in many situations,

00:39:07,820 --> 00:39:09,500
read most of that memory again.

00:39:09,500 --> 00:39:12,210
So that might be something that could be interesting.

00:39:12,210 --> 00:39:14,440
We could try some things like trying to print

00:39:14,440 --> 00:39:18,250
synchronously if we're not in an atomic context,

00:39:18,250 --> 00:39:20,020
assuming we can even detect that.

00:39:20,020 --> 00:39:22,370
Or we could fall back to the craziness

00:39:22,370 --> 00:39:23,520
that we're doing today.

00:39:24,380 --> 00:39:27,310
In my opinion, we really need to split this.

00:39:27,310 --> 00:39:29,460
And we need to start handling separate solutions

00:39:29,460 --> 00:39:32,000
and let people start to deal with the atomic console

00:39:32,000 --> 00:39:33,140
problem.

00:39:33,140 --> 00:39:36,190
But reality's a different situation, so,

00:39:36,190 --> 00:39:37,820
we still have to decide on that.

00:39:37,820 --> 00:39:42,590
- Yeah, but the thing is right now we have a mindset that

00:39:42,590 --> 00:39:46,650
we think something must work for all consoles

00:39:46,650 --> 00:39:48,200
or it can't work for any,

00:39:48,200 --> 00:39:51,120
which is wrong because their hardware from the hardware

00:39:51,120 --> 00:39:53,090
site totally different.

00:39:53,090 --> 00:39:54,833
And so,

00:39:56,910 --> 00:40:00,470
a lot of machines still have serial in the data centers

00:40:00,470 --> 00:40:01,720
in or

00:40:02,930 --> 00:40:05,480
boxes which developers use.

00:40:05,480 --> 00:40:07,610
And so we,

00:40:07,610 --> 00:40:10,870
a lot of people, including me, and Petr, and who else,

00:40:10,870 --> 00:40:13,630
has random hacks to make it work

00:40:13,630 --> 00:40:15,363
even if the thing crashes in NMI,

00:40:17,190 --> 00:40:21,080
but that's another solution so we really should understand

00:40:21,080 --> 00:40:24,860
and should accept that there is hardware which can provide

00:40:24,860 --> 00:40:27,910
atomic writes, and there's hardware which can't.

00:40:27,910 --> 00:40:30,480
And we can't solve the problem with

00:40:31,890 --> 00:40:34,380
the graphics stuff at all.

00:40:34,380 --> 00:40:37,830
I mean, unless there's a switch in the graphics

00:40:37,830 --> 00:40:38,993
device where it say,

00:40:40,327 --> 00:40:44,500
"I write into this and now the hardware itself

00:40:44,500 --> 00:40:48,780
or the firmware in there switches reliably to VTA mode."

00:40:48,780 --> 00:40:50,220
- Although they are working on this actually right now.

00:40:50,220 --> 00:40:51,520
I think they'll make it too.

00:40:51,520 --> 00:40:55,393
- Yeah, but this is the only way how this can be solved.

00:40:56,460 --> 00:41:00,270
I was recently carousing about that whole thing because

00:41:00,270 --> 00:41:02,640
I was trying to debunk something which would needed

00:41:02,640 --> 00:41:03,913
a laptop to debunk.

00:41:04,950 --> 00:41:08,743
So, it never made anything to any screen so,

00:41:09,840 --> 00:41:11,440
it just doesn't work.

00:41:11,440 --> 00:41:13,660
- Did the memory buffer work on the laptop?

00:41:15,110 --> 00:41:19,093
- That discussion came up after I actually figured it out.

00:41:20,120 --> 00:41:21,503
What was broken,

00:41:22,480 --> 00:41:23,780
I mean,

00:41:23,780 --> 00:41:28,740
but for a lot of my other work I have consoles which allow

00:41:30,330 --> 00:41:31,770
atomic,

00:41:31,770 --> 00:41:36,650
so, the word console can't do atomic.

00:41:36,650 --> 00:41:39,060
- But I mean there are a lot that don't as well so.

00:41:39,060 --> 00:41:41,393
- Yeah, so shout out to all hardware people,

00:41:42,360 --> 00:41:45,640
awesome stuff like the USB DiVA port

00:41:45,640 --> 00:41:47,853
do not work in the atomic context.

00:41:49,600 --> 00:41:50,483
So it's useless.

00:41:52,430 --> 00:41:53,263
- Right.

00:41:54,775 --> 00:41:55,810
The extra memory

00:41:55,810 --> 00:41:58,930
which survives to reset,

00:41:58,930 --> 00:42:00,650
that's great.

00:42:00,650 --> 00:42:03,863
Or that's quick-lived in the graphics card,

00:42:05,660 --> 00:42:07,370
which still has the graphics problem

00:42:07,370 --> 00:42:08,943
that it scrolls too fast.

00:42:10,020 --> 00:42:13,170
- And I think that once the kernel officially provides

00:42:13,170 --> 00:42:15,530
an interface, right, we officially say we want to

00:42:15,530 --> 00:42:18,747
do this split, then it becomes more interesting for drivers

00:42:18,747 --> 00:42:20,000
and we have a lot of brilliant people out there

00:42:20,000 --> 00:42:21,970
that'll actually figure how to make things work atomic,

00:42:21,970 --> 00:42:24,220
or there'll be new hardware people doing things atomic.

00:42:24,220 --> 00:42:27,540
But right now we're just paper-taping over everything

00:42:27,540 --> 00:42:29,300
and no one's doing anything about it,

00:42:29,300 --> 00:42:31,400
except for screaming when it doesn't work.

00:42:32,820 --> 00:42:34,920
So the last thing on the list of things is

00:42:34,920 --> 00:42:36,600
emergency messages.

00:42:36,600 --> 00:42:39,130
Which means that at any point we can have certain

00:42:39,130 --> 00:42:42,170
messages that we're sending into the printk infrastructure

00:42:42,170 --> 00:42:45,303
that we're tagging for immediate and synchronous printing.

00:42:46,300 --> 00:42:47,980
Obviously the concerns here are

00:42:47,980 --> 00:42:49,760
what is considered important?

00:42:49,760 --> 00:42:53,260
So my first version actually used a log level,

00:42:53,260 --> 00:42:56,270
but that's pretty hard to do, but it works.

00:42:56,270 --> 00:42:59,390
But the log level's kind of a grey area, what,

00:42:59,390 --> 00:43:01,640
you know, is warning really warning or not,

00:43:01,640 --> 00:43:03,400
are people misusing that?

00:43:03,400 --> 00:43:05,210
So, you know, there are other ideas from me

00:43:05,210 --> 00:43:07,220
that maybe log level, I've kinda the impression

00:43:07,220 --> 00:43:09,730
that log level's not the way to go.

00:43:09,730 --> 00:43:11,540
There's only certain situations, you know;

00:43:11,540 --> 00:43:14,450
bug, warn, oops, panic, you know,

00:43:14,450 --> 00:43:16,770
let's just maybe have the developers decide

00:43:16,770 --> 00:43:17,973
what's really important,

00:43:18,970 --> 00:43:21,160
the things we're sending mainline for when a thing crashes

00:43:21,160 --> 00:43:23,510
and we can just use the atomic writes for that.

00:43:24,450 --> 00:43:26,840
Another option is maybe that the console drivers

00:43:26,840 --> 00:43:28,330
themselves should somehow decide,

00:43:28,330 --> 00:43:29,920
I'm not sure about this but, you know,

00:43:29,920 --> 00:43:34,230
for example what Linux offered that we could have,

00:43:34,230 --> 00:43:36,170
you know, memory area, we want everything to kind of

00:43:36,170 --> 00:43:38,330
go in there, then that's kind of the console,

00:43:38,330 --> 00:43:41,030
the special console that's deciding that.

00:43:41,030 --> 00:43:42,840
Or maybe the user should decide, maybe we should be

00:43:42,840 --> 00:43:44,750
using log level threshold and we just need to clean up

00:43:44,750 --> 00:43:46,600
our log levels, right?

00:43:46,600 --> 00:43:47,697
Because maybe a user says,

00:43:47,697 --> 00:43:50,370
"I don't care, I want everything synchronous."

00:43:50,370 --> 00:43:51,203
Or they say,

00:43:51,203 --> 00:43:52,320
"No, I just want certain types

00:43:52,320 --> 00:43:53,360
of messages to be synchronous."

00:43:53,360 --> 00:43:54,450
I don't know.

00:43:54,450 --> 00:43:55,283
This is like I've said,

00:43:55,283 --> 00:43:57,090
I've done implementation with log level

00:43:57,090 --> 00:43:58,267
and we get it to work,

00:43:58,267 --> 00:44:00,150
but systemd likes to play with log levels a lot

00:44:00,150 --> 00:44:03,583
so it's hard to kind of keep that filtered.

00:44:05,850 --> 00:44:07,223
Yeah, ignore Longview.

00:44:12,900 --> 00:44:14,190
So I'm kinda running out of time here,

00:44:14,190 --> 00:44:16,090
so I'm just kinda gonna finish up really quick.

00:44:16,090 --> 00:44:17,190
So this the status until now,

00:44:17,190 --> 00:44:21,890
you see this began way back in February of 2018.

00:44:21,890 --> 00:44:23,890
My last post was the RFCv4

00:44:25,600 --> 00:44:27,130
last month,

00:44:27,130 --> 00:44:29,860
and we're still discussing on the things there.

00:44:29,860 --> 00:44:33,904
In particular it's still some things that they think

00:44:33,904 --> 00:44:38,610
that's considered too complicated that we need to sort out.

00:44:38,610 --> 00:44:39,890
One thing to note is

00:44:39,890 --> 00:44:44,330
is that the RFCv1, which is using the CPU-lock ringbuffer,

00:44:44,330 --> 00:44:49,060
is actually part of the PREEMPT series since 5.0.3.

00:44:49,060 --> 00:44:52,900
So the RT people are actually already switched over,

00:44:52,900 --> 00:44:54,260
but that's using a different ring buffer than I'm

00:44:54,260 --> 00:44:57,500
currently posting so, I don't know.

00:44:58,410 --> 00:44:59,870
Looking forward I'm just gonna kind of put down

00:44:59,870 --> 00:45:01,530
these are the steps that we've kind of outlined

00:45:01,530 --> 00:45:02,763
how we want to continue.

00:45:04,000 --> 00:45:07,430
We want to start off by replacing the mainline ringbuffer,

00:45:07,430 --> 00:45:08,943
just kind of go slowly.

00:45:10,210 --> 00:45:12,710
Then we would need to fix the log continuous that actually

00:45:12,710 --> 00:45:16,230
works NMI safe, then we can remove that logbuf_lock,

00:45:16,230 --> 00:45:18,020
remove the safe buffers,

00:45:18,020 --> 00:45:19,430
introduce per-console threads,

00:45:19,430 --> 00:45:22,110
maybe something similar to threadirqs now

00:45:22,110 --> 00:45:24,150
to kind of let people kind of migrate into it.

00:45:24,150 --> 00:45:25,350
They can at the beginning,

00:45:25,350 --> 00:45:28,150
they can actually choose if they want to have it or not.

00:45:29,490 --> 00:45:32,620
We're gonna have to decide the emergency messages thing

00:45:32,620 --> 00:45:37,003
and yeah, the right atomics we're also gonna need, so.

00:45:37,940 --> 00:45:40,210
Anyway, the point thing here is this is not just a huge

00:45:40,210 --> 00:45:44,550
to-do list, actually RFCv1 implemented like 95%

00:45:44,550 --> 00:45:45,830
of this, right?

00:45:45,830 --> 00:45:47,550
There is actual code there.

00:45:47,550 --> 00:45:50,970
Maybe it can't be used as it was with the RFCv1,

00:45:50,970 --> 00:45:52,760
but there is, you can do a lot of testing,

00:45:52,760 --> 00:45:55,300
it is in the PREEMPT_RT patch set

00:45:55,300 --> 00:45:56,480
and we can actually, you know,

00:45:56,480 --> 00:45:58,000
really see how these things work

00:45:58,000 --> 00:46:00,520
if they are really as reliable as we think they are.

00:46:00,520 --> 00:46:03,520
And if they're not as non-interferring as we think they are.

00:46:05,170 --> 00:46:06,820
Really quick thanks to a lot of people

00:46:06,820 --> 00:46:10,290
that gave me an enormous amount of support working on this,

00:46:10,290 --> 00:46:11,930
there's no way I could've done this myself.

00:46:11,930 --> 00:46:13,230
Printk is way too big,

00:46:13,230 --> 00:46:17,790
it's approaching 30 years old and that's just,

00:46:17,790 --> 00:46:19,580
it's got a lot of history.

00:46:19,580 --> 00:46:21,260
And also to the Linux Foundation for helping

00:46:21,260 --> 00:46:22,723
us bring PREEMPT_RT mainline.

00:46:23,970 --> 00:46:25,830
We probably don't have time for questions but maybe

00:46:25,830 --> 00:46:27,690
if there's one or two good ones, otherwise

00:46:27,690 --> 00:46:29,940
I'm happy to talk about this all day outside.

00:46:33,210 --> 00:46:34,043
Toss this.

00:46:35,650 --> 00:46:39,753
- So how about the tracing printing?

00:46:41,199 --> 00:46:42,032
- The Ftrace?

00:46:42,032 --> 00:46:42,890
- Ftrace, yes.

00:46:42,890 --> 00:46:45,560
- Yeah, so actually I tried to use Ftrace in the beginning.

00:46:45,560 --> 00:46:47,180
Ftrace has two problems,

00:46:47,180 --> 00:46:50,690
first of all it's designed for per-CPU usage.

00:46:50,690 --> 00:46:53,050
So, which means we're gonna have to create large buffers

00:46:53,050 --> 00:46:56,600
on every single CPU even though we may not be using

00:46:56,600 --> 00:46:58,650
90% of those buffers, right?

00:46:58,650 --> 00:47:01,860
So if I have 128 CPUs and everyone's getting a megabyte,

00:47:01,860 --> 00:47:03,950
maybe we don't care, maybe that is okay.

00:47:03,950 --> 00:47:04,960
So that's the one issue,

00:47:04,960 --> 00:47:08,440
is that we can't efficiently use those buffers.

00:47:08,440 --> 00:47:13,440
The second issue is that Ftrace is not lockless for reading.

00:47:14,040 --> 00:47:18,290
So the non-consuming readers in Ftrace do have to take locks

00:47:18,290 --> 00:47:20,130
so that's also not acceptable.

00:47:20,130 --> 00:47:22,280
So that was another problem that I had,

00:47:22,280 --> 00:47:27,280
so with those two issues it was decided that I should spend

00:47:27,510 --> 00:47:30,550
my effort just making a printk specific ringbuffer

00:47:30,550 --> 00:47:31,490
rather than using Ftrace.

00:47:31,490 --> 00:47:34,370
And this by the way, this buffer is not interesting

00:47:34,370 --> 00:47:36,810
for Ftrace because of the fact that

00:47:36,810 --> 00:47:38,250
it's a global shared buffer, right?

00:47:38,250 --> 00:47:41,530
So Ftrace is optimized to be per-CPU

00:47:41,530 --> 00:47:43,580
also all the cache alignment and everything it's

00:47:43,580 --> 00:47:46,160
doing is really great, so that we're not, you know.

00:47:46,160 --> 00:47:48,120
The CPUs aren't killing each other,

00:47:48,120 --> 00:47:51,050
whereas this one we have a global thing so I'm only,

00:47:51,050 --> 00:47:54,910
I've done tests and it takes about on a modern ARM 64,

00:47:54,910 --> 00:47:58,673
one and a half microseconds per printk into that ringbuffer.

00:47:58,673 --> 00:48:02,170
And Ftrace can go about six times that speed, right so,

00:48:02,170 --> 00:48:05,550
it's considerably slower than Ftrace but it also supports

00:48:05,550 --> 00:48:07,350
different things in Ftrace.

00:48:07,350 --> 00:48:09,170
- So would it make sense to kind of

00:48:10,700 --> 00:48:12,460
make it configurable in some way?

00:48:12,460 --> 00:48:15,380
So that in some cases we would like to have

00:48:16,720 --> 00:48:21,720
use Ftrace for Ftrace-like semantics for printk.

00:48:21,870 --> 00:48:24,100
So like we can have one framework instead of two

00:48:24,100 --> 00:48:24,933
for printing?

00:48:24,933 --> 00:48:26,520
- I mean that,

00:48:26,520 --> 00:48:29,830
we surely can at some point experiment with it,

00:48:29,830 --> 00:48:32,840
but I at the moment I would go for

00:48:32,840 --> 00:48:34,860
keep it simple first.

00:48:34,860 --> 00:48:37,367
Make it work, solve the problems we have,

00:48:37,367 --> 00:48:42,160
and then introduce new ones, not the other way around.

00:48:42,160 --> 00:48:43,160
- I agree with that.

00:48:44,690 --> 00:48:45,790
- Any other questions?

00:48:47,410 --> 00:48:48,810
So we're just missing lunch,

00:48:48,810 --> 00:48:50,120
we're just missing the beginning of lunch

00:48:50,120 --> 00:48:53,660
right now so no one has to panic about missing anything.

00:48:53,660 --> 00:48:54,493
- So,

00:48:54,493 --> 00:48:55,720
- Missing the long lines.

00:48:55,720 --> 00:48:57,020
- This is very impressive,

00:48:59,000 --> 00:49:00,940
I see you put a lot of effort in it

00:49:00,940 --> 00:49:04,100
and I'm curious who pays you for that

00:49:04,100 --> 00:49:05,693
and why exactly?

00:49:07,790 --> 00:49:09,860
I mean, as I said, it's great but

00:49:10,850 --> 00:49:13,940
why your employer pays for that?

00:49:13,940 --> 00:49:14,773
- So we are--

00:49:14,773 --> 00:49:16,523
- I don't know why I employed him.

00:49:17,420 --> 00:49:18,910
- Yeah, I don't know why either.

00:49:18,910 --> 00:49:20,620
I'm happy that he did though.

00:49:20,620 --> 00:49:22,420
So this actually initially,

00:49:22,420 --> 00:49:25,540
this whole effort became part of the umbrella from

00:49:25,540 --> 00:49:29,810
the Linux Foundation trying to bring printk real-time.

00:49:29,810 --> 00:49:32,950
But we've actually extended beyond what that funding

00:49:32,950 --> 00:49:33,783
can give.

00:49:33,783 --> 00:49:36,190
So it was initially, I think we thought would take a month,

00:49:36,190 --> 00:49:37,080
right?

00:49:37,080 --> 00:49:38,350
And so, you know,

00:49:38,350 --> 00:49:40,700
there's a lot of my own personal private time,

00:49:40,700 --> 00:49:43,470
my own interests, I mean I have my name out there,

00:49:43,470 --> 00:49:44,560
I'm working on this.

00:49:44,560 --> 00:49:45,850
I also want to see it working,

00:49:45,850 --> 00:49:48,420
I'm a big real-time fan so I want it to work.

00:49:48,420 --> 00:49:50,280
And the maintainers, you know,

00:49:50,280 --> 00:49:53,780
like Petr who's spending weeks and now Peter who's

00:49:53,780 --> 00:49:55,493
doing all kinds of reviews,

00:49:56,520 --> 00:49:57,770
there's no one really paying for that.

00:49:57,770 --> 00:50:00,430
But that's, I mean we're kinda, we get to do it

00:50:00,430 --> 00:50:01,460
during work I guess.

00:50:01,460 --> 00:50:02,820
Sometimes.

00:50:02,820 --> 00:50:05,860
But yeah, I'm not getting paid full-time to work on this

00:50:05,860 --> 00:50:07,350
for sure not,

00:50:07,350 --> 00:50:09,773
because it's way too expensive.

00:50:11,460 --> 00:50:14,230
There's so much stuff especially with the memory barriers.

00:50:14,230 --> 00:50:16,060
I really encourage people to download this

00:50:16,060 --> 00:50:19,310
and look at the following slides in the Appendix

00:50:19,310 --> 00:50:21,278
that really go into the memory barriers,

00:50:21,278 --> 00:50:22,920
there's just so much stuff there.

00:50:22,920 --> 00:50:25,370
I think when we started doing this we didn't realize

00:50:25,370 --> 00:50:27,850
how much baggage that we would have to go into.

00:50:27,850 --> 00:50:30,000
There's so much history, so many requirements,

00:50:30,000 --> 00:50:35,000
it really is a quite complicated topic, so yeah.

00:50:35,000 --> 00:50:37,150
But I'm happy to improve the world, right?

00:50:37,150 --> 00:50:38,853
So it's okay.

00:50:39,970 --> 00:50:40,803
I love Linux.

00:50:42,983 --> 00:50:44,316
You in the back?

00:50:45,420 --> 00:50:48,593
Could you throw your box to the corner?

00:50:50,990 --> 00:50:54,150
- So, since you're introducing emergency messages

00:50:54,150 --> 00:50:57,100
doesn't that necessarily mean that,

00:50:57,100 --> 00:50:59,970
that those might be out of sequence as they're printed

00:50:59,970 --> 00:51:02,510
if you have some non-emergency messages

00:51:02,510 --> 00:51:03,470
that happened before?

00:51:03,470 --> 00:51:04,303
- Yes.

00:51:04,303 --> 00:51:06,280
But the timestamps are all accurate.

00:51:06,280 --> 00:51:07,830
- So the timestamps are when they,

00:51:07,830 --> 00:51:09,220
when they're--

00:51:09,220 --> 00:51:11,550
- Yes, so the reason why the timestamps right now

00:51:11,550 --> 00:51:13,730
are not accurate is because of the safe buffers.

00:51:13,730 --> 00:51:15,620
But once we have a lockless ringbuffer,

00:51:15,620 --> 00:51:18,210
then we can just, we can put those in right now, right?

00:51:18,210 --> 00:51:20,340
So all the timestamps are accurate.

00:51:20,340 --> 00:51:22,180
- So going back to your example,

00:51:22,180 --> 00:51:24,300
if like a USB drive is plugged in,

00:51:24,300 --> 00:51:27,080
and then I was thinking well what would happen if

00:51:27,080 --> 00:51:28,900
that caused a panic in itself?

00:51:28,900 --> 00:51:30,980
You would get some messages out of sequence,

00:51:30,980 --> 00:51:31,813
but you would see,

00:51:31,813 --> 00:51:33,660
you would eventually see all of them--

00:51:33,660 --> 00:51:34,710
- From the timestamp, yeah,

00:51:34,710 --> 00:51:36,560
for example like a worn on or something.

00:51:36,560 --> 00:51:38,590
A worn on comes right away, maybe you see that,

00:51:38,590 --> 00:51:41,420
and then you see a bunch of messages that actually came

00:51:41,420 --> 00:51:44,700
before that, but that was printed synchronously

00:51:44,700 --> 00:51:46,450
and the other things were printed by the kthread

00:51:46,450 --> 00:51:48,280
which maybe got scheduled afterwards, right?

00:51:48,280 --> 00:51:49,740
But the timestamps are there.

00:51:49,740 --> 00:51:52,993
- Also you mentioned the RAM buffer,

00:51:53,875 --> 00:51:56,300
that is, I'm not sure if that's necessarily a new idea

00:51:56,300 --> 00:51:58,563
because we've had RAM moves for a while.

00:52:01,163 --> 00:52:03,530
- Yeah, that's true, yeah so.

00:52:03,530 --> 00:52:04,450
I don't know, Linux just talked about it

00:52:04,450 --> 00:52:05,688
last two weeks ago or something.

00:52:05,688 --> 00:52:09,500
- It was more about having it on the machines

00:52:09,500 --> 00:52:12,950
which do not have persistent RAM buffers,

00:52:12,950 --> 00:52:16,350
which is users laptop and that's what we care about

00:52:16,350 --> 00:52:19,430
because that's what we can't debunk right now,

00:52:19,430 --> 00:52:21,473
because we lose all the information.

00:52:23,350 --> 00:52:26,940
So there was some experiment how

00:52:28,020 --> 00:52:32,550
much DRAM actually retains information over a reset,

00:52:32,550 --> 00:52:36,510
or even over a power off, which is impressive.

00:52:36,510 --> 00:52:39,170
So, but of course what we really want

00:52:39,170 --> 00:52:43,190
and we were asking for that for 20 plus years now,

00:52:43,190 --> 00:52:47,320
and not getting it from the hardware people

00:52:47,320 --> 00:52:52,320
is actually persistent storage for exactly that purpose.

00:52:52,700 --> 00:52:54,090
Maybe we,

00:52:54,090 --> 00:52:55,573
if it's there,

00:52:56,560 --> 00:52:59,990
if the persistent storage exists on the hardware

00:52:59,990 --> 00:53:02,780
it's just a matter of writing a console driver

00:53:02,780 --> 00:53:05,180
which writes out to that thing,

00:53:05,180 --> 00:53:08,350
and with that split that console driver

00:53:08,350 --> 00:53:13,010
can write out anything and can even write out

00:53:13,010 --> 00:53:14,823
synchronous old-time.

00:53:15,950 --> 00:53:20,700
So that's the interesting change to the current mode,

00:53:20,700 --> 00:53:23,450
to the current mode which just treats everything

00:53:23,450 --> 00:53:24,530
the same way.

00:53:24,530 --> 00:53:27,360
Now when we switch over to something which is really

00:53:27,360 --> 00:53:30,050
useful, like persistent,

00:53:30,050 --> 00:53:34,820
persistent storage which is, which has no limitations

00:53:34,820 --> 00:53:39,140
in locking or whatever, we just can write out to it

00:53:39,140 --> 00:53:40,650
and be done with it.

00:53:40,650 --> 00:53:43,490
So that's where we want to go

00:53:44,800 --> 00:53:46,240
and

00:53:46,240 --> 00:53:47,073
I mean the--

00:53:47,073 --> 00:53:49,300
- eFIP store does not count.

00:53:49,300 --> 00:53:51,360
- No, eFIP store does not count.

00:53:51,360 --> 00:53:53,440
eFIP store is

00:53:56,640 --> 00:53:57,473
pstore.

00:54:00,110 --> 00:54:01,540
It doesn't work.

00:54:01,540 --> 00:54:03,130
- But it would be nice to have something integrated

00:54:03,130 --> 00:54:03,990
into printk, right?

00:54:03,990 --> 00:54:05,107
So we're using these kind of things

00:54:05,107 --> 00:54:06,980
and the machine does just reboot,

00:54:06,980 --> 00:54:08,460
and then all those messages are put right back

00:54:08,460 --> 00:54:09,700
into the ringbuffer, right?

00:54:09,700 --> 00:54:11,340
So my machine crashes, I don't see anything,

00:54:11,340 --> 00:54:13,540
gonna hit reset, and I come back up and now I can

00:54:13,540 --> 00:54:15,460
dmesg and I see them all, like something like that.

00:54:15,460 --> 00:54:17,900
Like an integrated solution would be nice.

00:54:17,900 --> 00:54:21,140
- And back to your initial question about ordering,

00:54:21,140 --> 00:54:24,270
I mean, if there's an emergency where you really want to see

00:54:24,270 --> 00:54:26,700
the emergency and that's the most important thing

00:54:26,700 --> 00:54:27,690
we need to get out.

00:54:27,690 --> 00:54:31,220
Because, in a lot of situations where the machine

00:54:31,220 --> 00:54:34,040
is actually crashing, the most important thing

00:54:34,040 --> 00:54:36,410
you need to get is the backtrace.

00:54:37,533 --> 00:54:38,765
- And the register dump.

00:54:38,765 --> 00:54:39,598
- Pardon?

00:54:39,598 --> 00:54:40,431
- And the register dump.

00:54:40,431 --> 00:54:42,273
- And the register dump, yeah.

00:54:43,950 --> 00:54:46,423
The less interesting part is all the,

00:54:47,280 --> 00:54:51,470
Oh, I loaded 5,000 gazillion modules and things like that,

00:54:51,470 --> 00:54:52,923
but anyway, it's there.

00:54:54,800 --> 00:54:57,060
The thing right now we often do not get

00:54:57,060 --> 00:54:58,320
the backtrace out of

00:55:00,464 --> 00:55:04,420
the printk, we just are lost in something.

00:55:04,420 --> 00:55:08,600
And that's especially true when the crash happens, right,

00:55:08,600 --> 00:55:12,240
while the driver while loading

00:55:12,240 --> 00:55:14,780
printks and then

00:55:14,780 --> 00:55:16,000
the interrupt hits,

00:55:16,000 --> 00:55:19,960
crashes because the driver was not fully yet initialized

00:55:19,960 --> 00:55:23,350
and then you just lock up the machine and be done with it.

00:55:23,350 --> 00:55:25,613
And that's what we want to get away with.

00:55:27,410 --> 00:55:30,443
And everything after that is nice to have.

00:55:34,590 --> 00:55:35,593
- Any other questions?

00:55:40,810 --> 00:55:44,530
- So I was wondering if there's an agreed approach

00:55:44,530 --> 00:55:49,040
for cases where you print out a ton of stuff over printk

00:55:49,040 --> 00:55:51,200
but too much for pr_cont to be reasonable,

00:55:51,200 --> 00:55:53,870
like if particular nasty things happen

00:55:53,870 --> 00:55:57,130
you can get an oops on multiple CPUs at the same time,

00:55:57,130 --> 00:55:59,303
and then it's difficult to leave that.

00:56:01,530 --> 00:56:05,050
One approach might be you add a CPU number or some context

00:56:05,050 --> 00:56:07,330
on the printk lines, but that might break it--

00:56:07,330 --> 00:56:09,040
- Yeah, we actually have that now since 5.0,

00:56:09,040 --> 00:56:10,540
it's called the caller ID.

00:56:10,540 --> 00:56:11,373
- We do have that.

00:56:11,373 --> 00:56:13,520
- It's beautiful, when you print that out you see,

00:56:13,520 --> 00:56:16,840
if you're in a task context you see the thread ID.

00:56:16,840 --> 00:56:19,570
If you're in some sort of scheduling or NMI or something

00:56:19,570 --> 00:56:20,900
you see the CPU ID.

00:56:20,900 --> 00:56:22,150
And you can sort all those out,

00:56:22,150 --> 00:56:24,230
they can all dump at the same time.

00:56:24,230 --> 00:56:25,740
Just grab that output, sort it,

00:56:25,740 --> 00:56:27,160
and you have your stack traces.

00:56:27,160 --> 00:56:28,010
It's beautiful actually.

00:56:28,010 --> 00:56:29,587
- Good solve problem, that's a...

00:56:29,587 --> 00:56:30,560
(chuckles drown out speaker)

00:56:30,560 --> 00:56:32,360
- Yeah the caller ID, I was really excited to see that

00:56:32,360 --> 00:56:35,650
come in, that just came into 5.0, and it was a big,

00:56:35,650 --> 00:56:36,483
but you have to turn it on,

00:56:36,483 --> 00:56:38,530
it's not turned on by default so turn on caller ID,

00:56:38,530 --> 00:56:39,380
it's really good.

00:56:41,540 --> 00:56:43,940
That's the only part of printk I like right now.

00:56:45,690 --> 00:56:48,570
- Usually it's recommended to turn off caller.

00:56:48,570 --> 00:56:49,720
- Anything?

00:56:49,720 --> 00:56:53,643

YouTube URL: https://www.youtube.com/watch?v=saPQZ_tnxwE


