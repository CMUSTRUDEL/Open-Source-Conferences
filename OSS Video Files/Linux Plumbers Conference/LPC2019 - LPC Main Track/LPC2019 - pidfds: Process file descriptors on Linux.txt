Title: LPC2019 - pidfds: Process file descriptors on Linux
Publication date: 2019-11-18
Playlist: LPC2019 - LPC Main Track
Description: 
	Traditionally processes are identified globally via process identifiers (PIDs). Due to how pid allocation works the kernel is free to recycle PIDs once a process has been reaped. As such, PIDs do not allow another process to maintain a private, stable reference on a process. On systems under pressure it is thus possible that a PID is recycled without other (non-parent) processes being aware of it. This becomes rather problematic when (non-parent) processes are in charge of managing other processes as is the case for system managers or userspace implementations of OOM killers.

Over the last months we have been working on solving these and other problems by introducing pidfds â€“ process file descriptors. Among other nice properties, the allow callers to maintain a private, stable reference on a process.

In this talk we will look at challenges we faced and the different approaches people pushed for. We will see what already has been implement and pushed upstream, look into various implementation details and outline what we have planned for the future.

Christian Brauner
Captions: 
	00:00:00,320 --> 00:00:02,780
- Hey, I'm Christian.

00:00:02,780 --> 00:00:07,073
I work as a sort of kernel engineer at Canonical.

00:00:08,350 --> 00:00:09,420
Do a lot of upstream work,

00:00:09,420 --> 00:00:12,120
maintain a few bits and pieces in the upstream kernel.

00:00:13,120 --> 00:00:15,750
And originally I was supposed to give a talk about

00:00:15,750 --> 00:00:17,110
writing a kernel driver in Rust,

00:00:17,110 --> 00:00:19,990
which is still work we are doing actually,

00:00:19,990 --> 00:00:22,213
but I got bronchitis, so you get pidfds.

00:00:23,230 --> 00:00:24,470
I don't know if it's a fair trade

00:00:24,470 --> 00:00:28,030
but everybody, we're on the same page,

00:00:28,030 --> 00:00:30,003
this is pidfds not Rust, in this case.

00:00:31,860 --> 00:00:32,693
Right.

00:00:33,930 --> 00:00:35,380
And we can do this in different ways.

00:00:35,380 --> 00:00:38,800
Usually I don't mind taking questions during my talk

00:00:38,800 --> 00:00:42,850
so if you have a pressing issue

00:00:42,850 --> 00:00:44,223
just ask right away.

00:00:46,080 --> 00:00:46,913
Okay.

00:00:50,133 --> 00:00:52,033
That will switch us to the next slide.

00:00:55,460 --> 00:00:56,640
Great.

00:00:56,640 --> 00:00:58,173
So, pidfds, what is that,

00:00:59,110 --> 00:01:00,480
I guess is the first question.

00:01:00,480 --> 00:01:03,873
I mean, who has heard about this work in the first place?

00:01:05,070 --> 00:01:08,180
Ah, okay, so LWN did a good job.

00:01:08,180 --> 00:01:11,907
(Christian laughs) (audience laughs)

00:01:11,907 --> 00:01:13,220
So, the basic idea,

00:01:13,220 --> 00:01:15,960
it's a file descriptor that refers to a process,

00:01:15,960 --> 00:01:17,050
which is not a new idea

00:01:17,050 --> 00:01:22,050
and I'm going to get to this piece in a little bit,

00:01:23,400 --> 00:01:25,990
but specifically the way we did it

00:01:25,990 --> 00:01:28,220
for the initial implementation

00:01:28,220 --> 00:01:31,770
is that it's an FD which refers to a thread-group leader.

00:01:31,770 --> 00:01:34,020
So, right now you cannot have

00:01:34,020 --> 00:01:37,270
a pidfd that refers to a single thread,

00:01:37,270 --> 00:01:40,310
just because we didn't have a use case for it.

00:01:40,310 --> 00:01:42,560
It's not necessarily out of scope,

00:01:42,560 --> 00:01:44,120
it's something we could think about

00:01:44,120 --> 00:01:46,620
but it probably requires a lot more thinking

00:01:47,840 --> 00:01:50,023
about the semantics that we would need.

00:01:51,450 --> 00:01:54,000
And the idea is that a pidfd serves as sort of

00:01:54,000 --> 00:01:56,830
stable and private handle

00:01:56,830 --> 00:01:58,910
that guarantees you it will always refer

00:01:58,910 --> 00:02:01,233
to the same process.

00:02:03,944 --> 00:02:07,113
And it abuses something in the kernel

00:02:07,113 --> 00:02:10,570
that has existed for a long time

00:02:10,570 --> 00:02:13,000
which is the kernel's version of a stable handle

00:02:13,000 --> 00:02:16,623
on a process which is struct pid.

00:02:17,600 --> 00:02:20,680
And note this uses, yeah,

00:02:20,680 --> 00:02:24,580
we use struct pid not task_struct, right,

00:02:24,580 --> 00:02:26,260
for the kernel, actually,

00:02:26,260 --> 00:02:28,170
thread if you want to put it like this.

00:02:28,170 --> 00:02:30,670
A task is identified by a task_struct.

00:02:30,670 --> 00:02:33,690
You could also argue that

00:02:33,690 --> 00:02:37,980
we could've made a pidfd refer to a task_struct.

00:02:37,980 --> 00:02:40,700
Why didn't we do this?

00:02:40,700 --> 00:02:44,188
Did somebody have an obvious intuition why we didn't do it?

00:02:44,188 --> 00:02:45,541
- [Audience Member] It recycles them too fast?

00:02:45,541 --> 00:02:46,499
- Sorry?

00:02:46,499 --> 00:02:48,320
- [Audience Member] It recycles them too fast?

00:02:48,320 --> 00:02:51,640
- Probably that, yes, but also just the sheer size.

00:02:51,640 --> 00:02:52,660
So one of the reasons,

00:02:52,660 --> 00:02:57,100
if you read the comment for struct pid in the kernel,

00:02:57,100 --> 00:03:00,170
it will give an explanation why it exists in the first place

00:03:00,170 --> 00:03:02,670
and why it exists in the first place was basically,

00:03:02,670 --> 00:03:07,500
oh, we need to keep a stable reference

00:03:07,500 --> 00:03:11,000
to a process a lot of times and we wanna recycle task_struct

00:03:11,000 --> 00:03:12,330
because it's burning too much memory.

00:03:12,330 --> 00:03:15,240
It's pretty big, if you look at the file it's like there's

00:03:16,220 --> 00:03:19,410
massive amounts of information in there.

00:03:19,410 --> 00:03:24,233
And so that's why you used struct pid, exactly.

00:03:27,490 --> 00:03:29,140
So why did we do this in the first place?

00:03:29,140 --> 00:03:31,010
Stable, private handle, why would you want this?

00:03:31,010 --> 00:03:33,030
Why aren't PIDs enough,

00:03:33,030 --> 00:03:36,390
I guess is the burning first question.

00:03:36,390 --> 00:03:39,250
And why did we use FDs and not, for example,

00:03:39,250 --> 00:03:42,113
UUIDs which some people suggested, and so on.

00:03:43,190 --> 00:03:45,730
So, the issue, well,

00:03:45,730 --> 00:03:49,710
the main reason why we did it is PID recycling

00:03:49,710 --> 00:03:53,450
which some people think is not really an issue.

00:03:53,450 --> 00:03:55,950
So, PID allocation inside of the kernel.

00:03:55,950 --> 00:03:56,783
Oh, and by the way,

00:03:56,783 --> 00:03:59,520
if anyone knows more about something than I do

00:03:59,520 --> 00:04:01,100
please yell as well.

00:04:01,100 --> 00:04:03,980
So, the way pid allocation in the kernel

00:04:03,980 --> 00:04:06,000
happens is cyclically.

00:04:06,000 --> 00:04:08,950
So, if you hit the maximum number of PIDs

00:04:08,950 --> 00:04:10,360
that you configured on your system

00:04:10,360 --> 00:04:13,220
then it wraps around and finds the next free PID.

00:04:13,220 --> 00:04:16,340
So, this way you can recycle PIDs,

00:04:16,340 --> 00:04:17,540
especially if you're on a system

00:04:17,540 --> 00:04:19,290
that is under a lot of pressure,

00:04:19,290 --> 00:04:21,870
so you create a lot of processes

00:04:21,870 --> 00:04:23,873
that exit very fast, and so on.

00:04:26,010 --> 00:04:28,710
And it shouldn't be an issue if you bump the number of

00:04:29,810 --> 00:04:32,620
what the maximum size of a PID can be, very highest,

00:04:32,620 --> 00:04:34,530
to four million, and so on,

00:04:34,530 --> 00:04:38,720
but usually on a standard system it's about 32,000

00:04:38,720 --> 00:04:41,820
which is fairly quick to recycle.

00:04:41,820 --> 00:04:43,770
And it's also not a theoretical issue.

00:04:43,770 --> 00:04:47,700
If you look, I linked to a bunch of CVEs and problems.

00:04:47,700 --> 00:04:51,093
So, the most well-known one is I guess,

00:04:52,700 --> 00:04:55,140
yes, this is the one in polkit,

00:04:55,140 --> 00:04:56,890
I think Jann might have found this.

00:04:58,578 --> 00:05:01,270
So, you could

00:05:01,270 --> 00:05:04,460
win a race against polkit

00:05:04,460 --> 00:05:07,860
to recycle a bunch of processes so fast

00:05:07,860 --> 00:05:10,320
that you wrapped the PID

00:05:10,320 --> 00:05:13,430
and then tricked polkit into authenticating you

00:05:14,480 --> 00:05:16,270
with the wrong process.

00:05:16,270 --> 00:05:19,083
So this is an issue that actually happens.

00:05:20,330 --> 00:05:22,547
There is a bunch of PID-based Mac exploits, actually.

00:05:22,547 --> 00:05:25,330
That's something I found which is pretty interesting.

00:05:25,330 --> 00:05:26,970
So they have issues with this as well,

00:05:26,970 --> 00:05:28,120
and as far as I know,

00:05:28,120 --> 00:05:29,660
I don't know the Apple source code

00:05:29,660 --> 00:05:31,410
so this is a wild guess on my part,

00:05:31,410 --> 00:05:32,910
they don't have something like

00:05:34,751 --> 00:05:37,380
a stable handle on a process.

00:05:37,380 --> 00:05:40,740
And there's a bunch more issues

00:05:40,740 --> 00:05:43,190
I linked to that were discussed,

00:05:43,190 --> 00:05:44,563
another CVE as well.

00:05:46,870 --> 00:05:50,430
Another reason was shared libraries.

00:05:50,430 --> 00:05:54,470
So, basically forking off invisible helper processes

00:05:54,470 --> 00:05:57,260
without having to rely on SIGCHLD

00:05:57,260 --> 00:06:00,413
to get exit notifications for a given process.

00:06:01,320 --> 00:06:02,920
This is especially relevant if

00:06:02,920 --> 00:06:05,643
you're a generic shared library, as some people call it,

00:06:05,643 --> 00:06:09,010
that have an event loop which has a bunch of callbacks

00:06:09,010 --> 00:06:11,280
and some of those callbacks, for example,

00:06:11,280 --> 00:06:14,640
react to SIGCHLD signals.

00:06:14,640 --> 00:06:17,460
If they get one they try to wait,

00:06:17,460 --> 00:06:19,623
either generically on all processes,

00:06:20,500 --> 00:06:23,130
but they might end up reaping processes

00:06:23,130 --> 00:06:25,250
they don't really wanted to reap

00:06:25,250 --> 00:06:28,810
and also taking away that process from

00:06:28,810 --> 00:06:31,350
the other callback in the event loop

00:06:31,350 --> 00:06:33,800
that actually wanted to wait on those processes.

00:06:33,800 --> 00:06:34,633
So with pidfds,

00:06:34,633 --> 00:06:38,913
and hopefully we can get to this bit time-wise,

00:06:40,120 --> 00:06:42,970
will allow you to solve this issue eventually, cleanly.

00:06:42,970 --> 00:06:45,320
They partially already do.

00:06:45,320 --> 00:06:47,630
And process management delegation

00:06:47,630 --> 00:06:50,070
which requires a bit more work than what we have right now.

00:06:50,070 --> 00:06:51,590
Right now we just have sort of a

00:06:51,590 --> 00:06:53,863
skeleton for process handling.

00:06:54,840 --> 00:06:58,300
So, ideally hand off a handle to a non-parent process,

00:06:58,300 --> 00:07:01,343
for example for waiting and signaling safely.

00:07:02,590 --> 00:07:06,500
I would like to at least explore the possibility

00:07:06,500 --> 00:07:09,570
of making it possible that non-parent processes

00:07:09,570 --> 00:07:12,620
can wait on a process.

00:07:12,620 --> 00:07:14,893
So if you hand off a pidfd to them,

00:07:16,030 --> 00:07:18,360
the way exactly how we would implement this is,

00:07:18,360 --> 00:07:20,040
I haven't worked on this specifically

00:07:20,040 --> 00:07:22,230
but it would be pretty cool if this would be possible,

00:07:22,230 --> 00:07:23,640
but it needs to be safe

00:07:23,640 --> 00:07:26,730
and it probably would need to be a property that you specify

00:07:26,730 --> 00:07:31,190
at process creation time, so when you create the pidfd.

00:07:31,190 --> 00:07:34,110
We'll see in a bit how we create pidfds.

00:07:34,110 --> 00:07:36,000
And the last reason is,

00:07:36,000 --> 00:07:37,403
and this is sort of my,

00:07:39,730 --> 00:07:42,773
I guess, defense against why we didn't use UUIDs,

00:07:44,440 --> 00:07:46,300
the ubiquity of FDs in userspace.

00:07:46,300 --> 00:07:48,530
So, we already have a lot of patterns

00:07:48,530 --> 00:07:51,450
in userspace to deal with FDs.

00:07:51,450 --> 00:07:54,670
This includes, for example, parsing out fdinfo

00:07:54,670 --> 00:07:56,620
from /proc/self/fdinfo and then the FD,

00:07:58,120 --> 00:08:00,730
that's generic code you can reuse.

00:08:00,730 --> 00:08:02,880
Most userspace programs that are

00:08:03,920 --> 00:08:08,840
related to any kind of Linuxy, UNIXy system

00:08:08,840 --> 00:08:10,510
will know how to deal with FDs.

00:08:10,510 --> 00:08:12,750
So, they will have an event loop usually

00:08:12,750 --> 00:08:16,513
where you can stuff FDs in and listen for events.

00:08:17,620 --> 00:08:20,660
They have code to receive and send FDs.

00:08:20,660 --> 00:08:22,190
So, it's pretty easy,

00:08:22,190 --> 00:08:24,210
so ideally it should be pretty easy

00:08:24,210 --> 00:08:26,063
to switch to using pidfds

00:08:28,080 --> 00:08:30,123
which was also pretty important.

00:08:33,360 --> 00:08:35,240
So, does userspace really care about this feature?

00:08:35,240 --> 00:08:39,220
I mean, this a question as a kernel engineer

00:08:39,220 --> 00:08:41,260
we ask ourselves quite a lot, right?

00:08:41,260 --> 00:08:43,060
So, are we just doing this, well,

00:08:43,060 --> 00:08:46,160
I would be fine with just doing my work for fun, obviously,

00:08:46,160 --> 00:08:50,140
but it's also pretty cool that you can come up and say,

00:08:50,140 --> 00:08:52,730
oh, by the way, this is really a feature that people want

00:08:52,730 --> 00:08:54,180
and that people actually use.

00:08:55,450 --> 00:08:57,650
And it's a feature that people actually use.

00:08:58,520 --> 00:08:59,720
So some people actually,

00:08:59,720 --> 00:09:01,840
some projects got in touch and were, like,

00:09:01,840 --> 00:09:05,350
cool that this work exists, we've been trying to use it.

00:09:05,350 --> 00:09:08,890
Qt was one of the examples, systemd was one of the examples,

00:09:08,890 --> 00:09:12,540
CRIU and lmkd definitely

00:09:12,540 --> 00:09:15,800
because there were also people, Joel, is Joel around?

00:09:15,800 --> 00:09:18,450
Ah, Joel Fernandes from Google was involved

00:09:18,450 --> 00:09:20,113
in part of this work as well.

00:09:21,480 --> 00:09:23,596
And so D-Bus, for example, has something that is called

00:09:23,596 --> 00:09:25,710
ConnectionUnixProcessIDHandle

00:09:25,710 --> 00:09:27,363
which is PID-based right now,

00:09:29,748 --> 00:09:32,970
which is used for, well I'm not sure if it's used for,

00:09:32,970 --> 00:09:36,090
oh, it's used to track a remote peer,

00:09:36,090 --> 00:09:39,820
and it's obviously vulnerable to PID races as well.

00:09:39,820 --> 00:09:43,230
And so they have at least an issue up where they discuss

00:09:43,230 --> 00:09:46,340
switching to pidfds to get rid of this problem

00:09:46,340 --> 00:09:49,873
and reliably track peers.

00:09:50,950 --> 00:09:54,910
Qt, they were once involved in an initial version

00:09:56,306 --> 00:09:58,570
of the patch set a long while ago,

00:09:58,570 --> 00:10:00,220
I'll be mentioning this in a bit.

00:10:01,390 --> 00:10:03,470
They want to fork off invisible helper process

00:10:03,470 --> 00:10:06,230
because they fall under the category of

00:10:06,230 --> 00:10:07,730
shared libraries that I've been mentioning,

00:10:07,730 --> 00:10:09,150
generic shared libraries,

00:10:09,150 --> 00:10:12,370
that don't know what other processes,

00:10:12,370 --> 00:10:15,050
what other callbacks in the event loop

00:10:15,050 --> 00:10:16,943
will fork off helper processes.

00:10:17,880 --> 00:10:21,430
And systemd wants to use it for process management

00:10:21,430 --> 00:10:24,160
toto caelo as far as I understand.

00:10:24,160 --> 00:10:26,140
A specific issue they have up right now

00:10:26,140 --> 00:10:28,020
is to reliably kill processes

00:10:28,020 --> 00:10:30,730
when you don't have the freezer cgroup available.

00:10:30,730 --> 00:10:32,760
So, if you have the freezer cgroup available

00:10:32,760 --> 00:10:36,560
you just freeze the cgroup and then you kill all processes,

00:10:36,560 --> 00:10:39,570
and zombies can't do syscalls so you're fine.

00:10:39,570 --> 00:10:42,400
But on systems where you don't have the freezer cgroup,

00:10:42,400 --> 00:10:45,043
you want to reliably kill processes so,

00:10:45,920 --> 00:10:48,590
and you need to identify whether they're in the right cgroup

00:10:48,590 --> 00:10:51,350
so what you can do is you can get a pidfd,

00:10:51,350 --> 00:10:53,180
you can read the information in

00:10:53,180 --> 00:10:54,770
what cgroup that process is in,

00:10:54,770 --> 00:10:58,090
but because you're holding and FD which is a stable handle

00:11:00,130 --> 00:11:02,640
you can then reliably kill the process.

00:11:02,640 --> 00:11:04,715
So pidfd_send_signal makes it safe to

00:11:04,715 --> 00:11:07,393
kill off processes reliably.

00:11:08,550 --> 00:11:12,240
And CRIU has something that is called detect_pid_reuse.

00:11:12,240 --> 00:11:13,870
They do predump which is,

00:11:13,870 --> 00:11:15,590
Adrian can correct me if I'm wrong,

00:11:15,590 --> 00:11:17,970
they do a series of predumps when they

00:11:19,050 --> 00:11:20,800
store all information of a process

00:11:20,800 --> 00:11:22,320
that they later on want to restore.

00:11:22,320 --> 00:11:24,720
And if you do multiple predumps to, for example,

00:11:24,720 --> 00:11:27,480
track memory changes over time for a process,

00:11:27,480 --> 00:11:29,710
you need to make sure that it's still the same process.

00:11:29,710 --> 00:11:32,620
So they have a function called detect_pid_reuse

00:11:32,620 --> 00:11:35,963
which uses the, I think, process starting time or something.

00:11:37,232 --> 00:11:39,960
It's really just a heuristic and it's not really reliable,

00:11:39,960 --> 00:11:42,830
and they wanna switch to pidfds for this as well

00:11:42,830 --> 00:11:46,020
which would also let them get rid of this problem.

00:11:46,020 --> 00:11:49,080
And lmkd is

00:11:49,080 --> 00:11:51,650
Android's low memory killer daemon

00:11:53,410 --> 00:11:55,020
which wants to make use of pidfds

00:11:55,020 --> 00:11:58,080
to also avoid PID recycling issues.

00:11:58,080 --> 00:12:01,870
And they're probably the ones who profit

00:12:02,880 --> 00:12:07,870
a lot off this since I'm assuming that they

00:12:07,870 --> 00:12:09,950
are under memory pressure a lot, (laughs)

00:12:09,950 --> 00:12:12,273
and they fork off a bunch of processes.

00:12:14,470 --> 00:12:17,623
Right, so prior art, this was always important.

00:12:18,500 --> 00:12:20,250
Obviously, this is completely my idea

00:12:20,250 --> 00:12:23,220
and nobody had that idea before. (laughs)

00:12:23,220 --> 00:12:24,223
No, I'm joking.

00:12:25,072 --> 00:12:27,630
This is obviously, it's something that,

00:12:27,630 --> 00:12:29,623
actually, Alexa reminded me of this,

00:12:29,623 --> 00:12:32,500
it's pretty obvious if you look at Linux itself,

00:12:32,500 --> 00:12:35,480
if you look at the proc PID directory,

00:12:35,480 --> 00:12:38,067
proc itself already pins a process, right?

00:12:38,067 --> 00:12:40,810
That's sort of why struct pid exists as well.

00:12:40,810 --> 00:12:43,340
So, a proc PID directory, if you have an FD to it,

00:12:43,340 --> 00:12:45,680
it pins struct pid in the kernel already.

00:12:45,680 --> 00:12:47,020
You can't do anything with it

00:12:47,020 --> 00:12:48,580
and it doesn't help you at all

00:12:48,580 --> 00:12:50,790
but the concept is there as well.

00:12:50,790 --> 00:12:52,530
Just staring at the code for a while

00:12:52,530 --> 00:12:54,580
you could probably have figured this out.

00:12:56,060 --> 00:12:57,790
But there are also other systems

00:12:58,862 --> 00:13:01,280
who had similar ideas.

00:13:01,280 --> 00:13:02,680
My fault actually was,

00:13:02,680 --> 00:13:05,790
which is sort of the fault

00:13:05,790 --> 00:13:08,443
a lot of people have that are born later in time,

00:13:09,720 --> 00:13:13,630
I naively assumed, for some systems,

00:13:13,630 --> 00:13:15,400
that they had it when they didn't

00:13:15,400 --> 00:13:17,680
so I didn't get my history right, basically.

00:13:17,680 --> 00:13:19,970
For example, I always assumed that Solaris had it.

00:13:19,970 --> 00:13:22,720
So illumos, which is the open source alternative to it,

00:13:23,620 --> 00:13:25,900
but they don't, they actually just have a pure userspace

00:13:25,900 --> 00:13:26,933
emulation of a process table handle.

00:13:26,933 --> 00:13:30,650
There's procopen, procrun, procclose, procfree,

00:13:30,650 --> 00:13:33,120
which is vulnerable to all of the problems

00:13:33,120 --> 00:13:35,703
that I detailed at the beginning of the talk.

00:13:36,640 --> 00:13:40,100
And OpenBSD and NetBSD also don't have it,

00:13:40,100 --> 00:13:43,160
I've looked at their kernel source code.

00:13:43,160 --> 00:13:45,970
There is no private, stable process handles.

00:13:45,970 --> 00:13:49,830
They have references to it, so it's sometimes mentioned,

00:13:49,830 --> 00:13:51,953
but there is no implementation for it.

00:13:54,070 --> 00:13:54,903
FreeBSD has it,

00:13:54,903 --> 00:13:58,520
I guess that this is the most well-known example.

00:13:58,520 --> 00:14:02,220
I think this derives back from the Capsicum project

00:14:02,220 --> 00:14:03,520
why they implemented it.

00:14:03,520 --> 00:14:06,660
So they have something which is not called pidfd,

00:14:06,660 --> 00:14:08,790
obviously on Linux you always have to

00:14:08,790 --> 00:14:10,960
come up with your own name,

00:14:10,960 --> 00:14:12,343
so they call it procdesc.

00:14:13,480 --> 00:14:17,600
A process file descriptor, I guess, and process descriptor.

00:14:17,600 --> 00:14:21,940
And they have three syscalls, pdfork, pdgetpid, and pdkill,

00:14:21,940 --> 00:14:25,430
and on Linux we sort of have two of those.

00:14:25,430 --> 00:14:28,530
We have pdfork and pdkill now

00:14:28,530 --> 00:14:32,070
but the semantics actually differ in a bunch of aspects

00:14:32,070 --> 00:14:34,070
and I can go into more detail

00:14:34,070 --> 00:14:35,870
if you really want to know about it,

00:14:37,076 --> 00:14:40,680
but for now it's sort of, the concept is at least similar.

00:14:40,680 --> 00:14:45,113
The semantics are sometimes different, like,

00:14:46,450 --> 00:14:51,450
for example, the way we on Linux deal with processes

00:14:54,533 --> 00:14:56,470
where we explicitly ignore SIGCHLD,

00:14:56,470 --> 00:14:59,063
we auto-reap the processes so they just go away.

00:15:00,760 --> 00:15:02,460
There is nothing fancy going on.

00:15:02,460 --> 00:15:05,220
What FreeBSD actually is doing,

00:15:05,220 --> 00:15:07,980
it's reparenting it to init

00:15:07,980 --> 00:15:10,540
and then init gets a SIGCHLD,

00:15:10,540 --> 00:15:14,530
and so FreeBSD is, for example, saying (claps)

00:15:14,530 --> 00:15:16,333
PID one, go deal with it.

00:15:18,450 --> 00:15:23,450
So, this means that they have to do some things differently

00:15:23,670 --> 00:15:25,620
the way we did it or intend to do it

00:15:25,620 --> 00:15:28,430
for future features on Linux.

00:15:28,430 --> 00:15:31,990
And Linux had, there were multiple pushes to get

00:15:31,990 --> 00:15:35,030
a concept of a private process stable handle

00:15:36,650 --> 00:15:40,792
via an FD in forkfd and CLONE_FD.

00:15:40,792 --> 00:15:43,290
CLONE_FD might be one that is the most well-known

00:15:43,290 --> 00:15:45,883
which was sort of a collaboration between Qt,

00:15:47,840 --> 00:15:50,590
yes, which came from a collaboration from Qt

00:15:50,590 --> 00:15:52,290
and, uh, is it David Drysdale?

00:15:52,290 --> 00:15:54,610
I don't wanna lie right now.

00:15:54,610 --> 00:15:56,640
But there is a patch for this out.

00:15:56,640 --> 00:15:58,220
You can Google for CLONE_FD

00:15:58,220 --> 00:15:59,890
and you should see the patch set.

00:15:59,890 --> 00:16:04,370
And actually, even back in the day, I guess 2015,

00:16:04,370 --> 00:16:06,380
people were very receptive to the idea

00:16:06,380 --> 00:16:09,020
but the patch set itself tried get in, sorry, yes?

00:16:09,020 --> 00:16:10,303
- [Audience Member] Do you want more prior art?

00:16:10,303 --> 00:16:11,656
- [Host] Mic.

00:16:11,656 --> 00:16:14,630
- Another piece of prior art is the work from Casey Dahlin,

00:16:14,630 --> 00:16:17,350
I think it was in 2009, waitfd,

00:16:17,350 --> 00:16:20,410
which let you do a waitpid on file descriptors

00:16:20,410 --> 00:16:21,743
so you could poll things.

00:16:23,390 --> 00:16:26,133
This also worked for thread-directed signals,

00:16:27,420 --> 00:16:30,200
such as you get from waitpid on ptrace processes,

00:16:30,200 --> 00:16:32,113
which unfortunately it looks like this won't do

00:16:32,113 --> 00:16:35,370
because it's a per-process thing only, a shame.

00:16:35,370 --> 00:16:37,760
- Currently, yeah, there is technically,

00:16:37,760 --> 00:16:38,750
to repeat, there is technically--

00:16:38,750 --> 00:16:40,020
- [Audience Member] There is actually a use case

00:16:40,020 --> 00:16:41,810
but I'll get to that later.

00:16:41,810 --> 00:16:43,530
- Yes, there are use cases.

00:16:43,530 --> 00:16:44,880
I originally thought, for example,

00:16:44,880 --> 00:16:46,860
for pthread management or something

00:16:46,860 --> 00:16:48,810
it would be really nice to have this, yes.

00:16:48,810 --> 00:16:51,630
So there is technically no reason not to do it.

00:16:51,630 --> 00:16:53,390
I think when we started this work

00:16:53,390 --> 00:16:56,130
I spoke to Florian Weimar and asked him

00:16:56,130 --> 00:16:58,940
what do you think about making use of this for pthread?

00:16:58,940 --> 00:17:00,950
And he was like, mm, yeah, it sounds interesting,

00:17:00,950 --> 00:17:03,100
but also we need to be backwards compatible.

00:17:03,100 --> 00:17:03,944
So if they ever, for example,

00:17:03,944 --> 00:17:06,440
they are saying this is a use case we have,

00:17:06,440 --> 00:17:09,300
please let's get this done and we can think about it.

00:17:09,300 --> 00:17:14,300
It's really that Oleg Nesterov basically said

00:17:14,360 --> 00:17:16,880
oh, if we do CLONE_THREAD right now with pidfds

00:17:16,880 --> 00:17:18,250
it gets really hairy

00:17:18,250 --> 00:17:21,873
and are we really sure that we want to do this right now?

00:17:26,167 --> 00:17:27,125
(staff member murmurs)

00:17:27,125 --> 00:17:27,958
Ah, okay.

00:17:29,390 --> 00:17:32,780
Right, so this is prior art.

00:17:32,780 --> 00:17:34,450
I can talk about CLONE_FD.

00:17:34,450 --> 00:17:37,910
So, I tried to figure out why it didn't get merged.

00:17:37,910 --> 00:17:41,540
I think the reason is it tried to do many things

00:17:41,540 --> 00:17:44,680
at the same time in one patch set,

00:17:44,680 --> 00:17:46,010
which is understandable, right?

00:17:46,010 --> 00:17:47,600
It's usually you have a really cool idea

00:17:47,600 --> 00:17:49,880
and you think these are all the features

00:17:49,880 --> 00:17:51,070
that we can build on top of it,

00:17:51,070 --> 00:17:53,010
here is the patch set that makes all of them

00:17:53,010 --> 00:17:54,240
available at the same time.

00:17:54,240 --> 00:17:57,311
And this is usually not an approach that flies very well

00:17:57,311 --> 00:17:59,520
on Linux which is also fine because, you know,

00:17:59,520 --> 00:18:01,810
if you merge it and then you have to route it through a tree

00:18:01,810 --> 00:18:03,940
and then you have to be responsible for it,

00:18:03,940 --> 00:18:04,773
somebody needs to maintain it

00:18:04,773 --> 00:18:07,230
and it's not guaranteed that people are staying around,

00:18:07,230 --> 00:18:11,490
and so on, so doing it in a sort of more piecemeal fashion

00:18:11,490 --> 00:18:13,556
is usually the better approach.

00:18:13,556 --> 00:18:16,865
But the idea

00:18:16,865 --> 00:18:20,140
was similar but it also makes auto-reaping semantics

00:18:21,160 --> 00:18:23,870
so that a process just exits and goes away

00:18:23,870 --> 00:18:27,280
and nobody has to wait on it with FDs, and so on.

00:18:27,280 --> 00:18:32,280
So, it wasn't clear-cut, I think, as it should have been.

00:18:32,390 --> 00:18:35,173
So this really didn't land.

00:18:36,060 --> 00:18:36,893
Right.

00:18:37,740 --> 00:18:39,540
So what did we do?

00:18:39,540 --> 00:18:43,450
Well, we tried to build a new API,

00:18:43,450 --> 00:18:47,390
and so far this work is spanning four kernel releases.

00:18:47,390 --> 00:18:48,990
And actually this sounds like

00:18:50,010 --> 00:18:52,370
this has been a massive amount of code

00:18:52,370 --> 00:18:55,100
and we've changed many, many things.

00:18:55,100 --> 00:18:56,443
Actually, we didn't.

00:18:57,420 --> 00:18:59,490
The actual changes that we needed

00:18:59,490 --> 00:19:01,823
in the kernel are not that huge.

00:19:02,880 --> 00:19:06,680
It's just that I sort of wanted to choose it,

00:19:06,680 --> 00:19:09,034
being the one who sort of tried to guide this a little,

00:19:09,034 --> 00:19:10,920
there were a lot more people involved in the discussion

00:19:10,920 --> 00:19:15,173
and design so this is obviously not my personal achievement.

00:19:16,880 --> 00:19:20,040
Was just that I wanted to have a sustainable speed

00:19:20,040 --> 00:19:24,770
so that we could be sure that the things we are doing

00:19:24,770 --> 00:19:29,380
are correct and also that we have time to react to bugs.

00:19:29,380 --> 00:19:30,610
So, if you have to do,

00:19:30,610 --> 00:19:32,693
you push new features at the same time,

00:19:33,530 --> 00:19:36,190
and a lot of features at the same time.

00:19:36,190 --> 00:19:37,810
If things break you, you know,

00:19:37,810 --> 00:19:40,690
it might break in a bunch of places at the same, and so on.

00:19:40,690 --> 00:19:43,310
If you do it piecemeal over a couple of kernels

00:19:43,310 --> 00:19:46,943
you have time to catch design mistakes also and, yeah.

00:19:48,770 --> 00:19:51,390
Building a new API, a comment I would like to make,

00:19:51,390 --> 00:19:54,130
this is the first time I actually speak about this so

00:19:55,010 --> 00:19:56,433
lucky you, or not,

00:19:58,420 --> 00:20:01,950
is the pidfd API was, in my imagination at least

00:20:01,950 --> 00:20:04,600
and people who were involved in this work

00:20:04,600 --> 00:20:07,580
like Joel and a bunch of other Google guys

00:20:07,580 --> 00:20:08,963
might disagree with this,

00:20:09,820 --> 00:20:12,270
my intention was never to sort of say

00:20:12,270 --> 00:20:14,370
pidfd is replacing the PID API completely.

00:20:18,900 --> 00:20:20,180
I always thought of it,

00:20:20,180 --> 00:20:22,900
it's an alternative way of managing processes

00:20:22,900 --> 00:20:26,020
that is probably very useful to you

00:20:26,020 --> 00:20:27,907
if you need to be very, very sure that

00:20:27,907 --> 00:20:29,650
the process you're operating on

00:20:29,650 --> 00:20:32,930
is actually the process that you're operating on,

00:20:32,930 --> 00:20:34,750
and also that there is a connection between

00:20:34,750 --> 00:20:36,710
the PID API and the pidfd API

00:20:36,710 --> 00:20:40,360
so that you sort of, you can choose one,

00:20:40,360 --> 00:20:41,700
you don't necessarily have to choose

00:20:41,700 --> 00:20:44,730
either I'm doing pidfds or I'm doing PIDs,

00:20:44,730 --> 00:20:46,980
but you can use both at the same time.

00:20:46,980 --> 00:20:48,990
Now, that has limits obviously,

00:20:48,990 --> 00:20:51,081
but the way we designed it, actually,

00:20:51,081 --> 00:20:52,420
and you will see this at the clone

00:20:52,420 --> 00:20:54,510
when we talk about the CLONE_PIDFD flag,

00:20:54,510 --> 00:20:59,040
there is a nice interaction between the two of them.

00:20:59,040 --> 00:21:01,340
So, the pidfd API is not

00:21:01,340 --> 00:21:06,340
PIDs are a completely wrong concept, don't use them anymore,

00:21:06,510 --> 00:21:09,760
here's a new way of doing process management.

00:21:09,760 --> 00:21:13,790
Sure, I expect that there will be new features

00:21:13,790 --> 00:21:15,940
in the future that will be based on pidfds

00:21:15,940 --> 00:21:18,060
that you can't based on PIDs

00:21:18,060 --> 00:21:21,240
by virtue of how they are implemented

00:21:23,287 --> 00:21:24,687
but that should be about it.

00:21:26,020 --> 00:21:27,150
Right, so,

00:21:27,150 --> 00:21:29,700
one of the first things we did in

00:21:29,700 --> 00:21:33,440
kernel 5.1 was pidfd_send_signal.

00:21:33,440 --> 00:21:37,147
So, a way to send signals through pidfds.

00:21:38,130 --> 00:21:41,050
You could argue that we started the wrong way around.

00:21:41,050 --> 00:21:42,930
So, we didn't implement something

00:21:42,930 --> 00:21:45,270
that lets you create a pidfd right away,

00:21:45,270 --> 00:21:49,060
we started off with a syscall that operates on a pidfd.

00:21:49,060 --> 00:21:50,160
The reason for this is

00:21:52,020 --> 00:21:54,160
that it's the most obvious thing

00:21:54,160 --> 00:21:56,600
that userspace wants or would ask for,

00:21:56,600 --> 00:21:58,380
reliably sending signals.

00:21:58,380 --> 00:21:59,530
Especially if you think about

00:21:59,530 --> 00:22:03,060
any type of process management, this is what you want.

00:22:03,060 --> 00:22:05,660
You don't want to be end up in a situation

00:22:05,660 --> 00:22:08,450
where you accidentally send a signal to a wrong process,

00:22:08,450 --> 00:22:11,130
especially if you're talking about SIGKILL,

00:22:11,130 --> 00:22:14,153
so it was very easy to make the case for pidfd_send_signal.

00:22:17,100 --> 00:22:20,310
Yes, so, here is a bunch of,

00:22:20,310 --> 00:22:23,773
here we get into a tricky area to some extent.

00:22:28,640 --> 00:22:31,410
It being the obvious piece that you really, really want,

00:22:31,410 --> 00:22:33,900
it also meant that people had a lot of opinions,

00:22:33,900 --> 00:22:35,060
which is fine,

00:22:35,060 --> 00:22:38,060
but everybody pushed in a different direction

00:22:38,060 --> 00:22:41,210
because everybody had different needs.

00:22:41,210 --> 00:22:42,690
Some people just wanted a pidfd

00:22:42,690 --> 00:22:45,600
to be a very abstract handle, myself included.

00:22:45,600 --> 00:22:48,240
Other people wanted

00:22:48,240 --> 00:22:50,330
to correspond to a proc PID directory

00:22:50,330 --> 00:22:53,610
so that they could get easy metadata access,

00:22:53,610 --> 00:22:56,510
which then proved to be really difficult

00:22:56,510 --> 00:22:59,080
in terms of security when you think about

00:22:59,080 --> 00:23:02,330
creating a process from the clone syscall, and so on.

00:23:02,330 --> 00:23:05,110
So there was a lot of back-and-forth going on,

00:23:05,110 --> 00:23:09,243
and long, long email threads about this,

00:23:10,150 --> 00:23:12,063
but we finally,

00:23:13,571 --> 00:23:15,630
we came to a sort of compromise, I think.

00:23:15,630 --> 00:23:18,240
So with pidfd_send_signal you can use a shortcut,

00:23:18,240 --> 00:23:20,990
you can open a process proc PID directory

00:23:20,990 --> 00:23:22,970
and use the FD that you get from it

00:23:22,970 --> 00:23:25,450
which already is in-kernel a stable handle

00:23:25,450 --> 00:23:27,200
as it pins a struct pid,

00:23:27,200 --> 00:23:29,630
and you can pass this to pidfd_send_signal

00:23:29,630 --> 00:23:34,610
and then send signals to processes.

00:23:34,610 --> 00:23:36,620
This is a very nice shortcut for userspace.

00:23:36,620 --> 00:23:37,760
Actually, they like it a lot.

00:23:37,760 --> 00:23:39,690
I don't like it from the perspective of,

00:23:39,690 --> 00:23:42,670
I would've liked an API that is very, very consistent

00:23:42,670 --> 00:23:44,720
and you don't have two different types of FDs

00:23:44,720 --> 00:23:46,680
that your API is dealing with,

00:23:46,680 --> 00:23:47,950
but it's only this syscall

00:23:47,950 --> 00:23:49,620
and actually there is precedent in the kernel.

00:23:49,620 --> 00:23:53,090
Like for example, in new mount API we'll likely gain

00:23:53,090 --> 00:23:57,100
a fsinfo syscall and the fsinfo syscall will operate on

00:23:57,100 --> 00:23:59,710
regular FDs that you get from

00:23:59,710 --> 00:24:02,650
directories and so on that are mount points,

00:24:02,650 --> 00:24:05,430
but also on FDs that are returned

00:24:05,430 --> 00:24:08,900
from the new mount API syscalls such as fspick or fsopen

00:24:08,900 --> 00:24:10,550
which are a total different type.

00:24:11,940 --> 00:24:15,600
So, we have precedence of this in the kernel

00:24:15,600 --> 00:24:17,423
so I don't think it's that bad.

00:24:18,402 --> 00:24:21,850
pidfd_send_signal currently does the job of kill,

00:24:21,850 --> 00:24:23,730
positive PID, and then the signals.

00:24:23,730 --> 00:24:27,230
So, currently there is no way,

00:24:27,230 --> 00:24:29,090
we can enable this later,

00:24:29,090 --> 00:24:30,170
there's currently no way to say

00:24:30,170 --> 00:24:33,620
I want to signal this specific thread.

00:24:33,620 --> 00:24:36,330
It's always a random thread in the thread group

00:24:36,330 --> 00:24:37,290
that wants the signal

00:24:37,290 --> 00:24:38,873
so that doesn't have it blocked, and so on.

00:24:38,873 --> 00:24:41,830
This is exactly how kill operates today.

00:24:41,830 --> 00:24:42,773
Also,

00:24:47,674 --> 00:24:49,413
we don't allow you to signal

00:24:51,191 --> 00:24:52,693
a pidfd that lives in a PID namespace

00:24:56,120 --> 00:24:58,360
of which you are not an ancestor PID namespace

00:24:58,360 --> 00:25:00,063
because they are hierarchical.

00:25:01,400 --> 00:25:03,920
Yes, so you can signal upwards.

00:25:03,920 --> 00:25:06,670
If you somehow get access to a pidfd

00:25:06,670 --> 00:25:08,410
from a different PID namespace,

00:25:08,410 --> 00:25:10,470
that is either a sibling PID namespace

00:25:10,470 --> 00:25:12,940
or is an ancestor PID namespace,

00:25:12,940 --> 00:25:17,163
you can signal upwards and you can't signal horizontally.

00:25:18,520 --> 00:25:20,550
There might be use cases for this in the future

00:25:20,550 --> 00:25:21,570
where you can do this,

00:25:21,570 --> 00:25:23,410
where you can signal between different,

00:25:23,410 --> 00:25:27,350
send signals between different PID namespaces via pidfds,

00:25:27,350 --> 00:25:29,040
but again, there wasn't a use case for it

00:25:29,040 --> 00:25:30,950
so we didn't see a reason to

00:25:30,950 --> 00:25:33,313
come up with complicated semantics right away.

00:25:34,350 --> 00:25:36,580
But again, there is nothing that prevents us

00:25:36,580 --> 00:25:39,880
from doing this in the future.

00:25:39,880 --> 00:25:42,980
Eric actually was in favor of this, but, yeah,

00:25:42,980 --> 00:25:44,380
just didn't have a use case.

00:25:46,910 --> 00:25:51,560
And then in 5.2 we landed probably,

00:25:51,560 --> 00:25:54,030
ah, it's not the most important bit but it's,

00:25:54,030 --> 00:25:56,630
I like that piece of code specifically.

00:25:56,630 --> 00:25:58,230
Oh, and by the way, I should say

00:25:59,180 --> 00:26:01,790
I talked about code size and this syscall is really small.

00:26:01,790 --> 00:26:03,930
It lives in kernel/signal.c

00:26:03,930 --> 00:26:06,146
and if you look at the patch it's really not,

00:26:06,146 --> 00:26:09,034
it's not a complicated syscall

00:26:09,034 --> 00:26:12,023
and it's not a lot of code, so.

00:26:13,580 --> 00:26:16,740
CLONE_PIDFD, so the idea was you want to be able to

00:26:16,740 --> 00:26:18,840
create processes at creation time,

00:26:18,840 --> 00:26:21,480
and here we ran into another challenge.

00:26:21,480 --> 00:26:22,980
We ran into the same challenge we had

00:26:22,980 --> 00:26:24,360
with pidfd_send_signals,

00:26:24,360 --> 00:26:28,100
what type of file descriptor are we going to make this?

00:26:28,100 --> 00:26:30,010
And at first it was, like,

00:26:30,010 --> 00:26:31,963
for consistency, please make it,

00:26:33,360 --> 00:26:35,883
Linus had opinions about this, I think,

00:26:38,396 --> 00:26:41,280
make CLONE_PIDFD return

00:26:43,050 --> 00:26:46,860
an FD to the proc PID directory of the process.

00:26:46,860 --> 00:26:49,740
And then Jann and I teamed up

00:26:50,780 --> 00:26:53,670
and implemented two different solutions

00:26:53,670 --> 00:26:56,380
because we thought it wouldn't be feasible

00:26:56,380 --> 00:26:58,420
to do it as file descriptors

00:26:58,420 --> 00:27:00,480
to proc PID directories of the process,

00:27:00,480 --> 00:27:02,420
because of security reasons it would've meant

00:27:02,420 --> 00:27:04,170
rework proc to make it more safe

00:27:04,170 --> 00:27:06,060
because there are, like for example,

00:27:06,060 --> 00:27:09,360
proc PID net contains a bunch of information that is not,

00:27:09,360 --> 00:27:11,510
where you can snoop on networking information

00:27:11,510 --> 00:27:13,960
of other processes so we would have needed a way

00:27:13,960 --> 00:27:15,810
to restrict access to this

00:27:15,810 --> 00:27:17,520
to be able to safely send around

00:27:17,520 --> 00:27:20,170
these file descriptors and so on, so it was all,

00:27:20,170 --> 00:27:22,763
and the code was really complicated to get right.

00:27:24,310 --> 00:27:25,910
The patch set is still on LKML

00:27:25,910 --> 00:27:28,170
because we sent out two RFCs at the same time.

00:27:28,170 --> 00:27:30,200
One for the approach that we went with

00:27:30,200 --> 00:27:31,950
and one for the proc PID approach.

00:27:31,950 --> 00:27:33,970
And the proc PID approach, even just the code,

00:27:33,970 --> 00:27:37,000
even though we tried to make it very as elegant as possible,

00:27:37,000 --> 00:27:38,083
it's really ugly.

00:27:40,480 --> 00:27:43,220
It's also because of how proc works, and so on.

00:27:43,220 --> 00:27:44,670
I'm pretty happy that we ended up with

00:27:44,670 --> 00:27:46,060
what we ended up with.

00:27:46,060 --> 00:27:49,000
So, what we did is, as you can see,

00:27:49,000 --> 00:27:53,900
we used anon_inodes, anonymous inodes.

00:27:53,900 --> 00:27:56,023
Does everybody know what this is?

00:27:58,150 --> 00:28:00,060
Okay, so a brief explanation,

00:28:00,060 --> 00:28:04,410
it's basically just a single inode in the kernel,

00:28:04,410 --> 00:28:06,253
it's a small, little subsystem,

00:28:08,048 --> 00:28:12,990
and this inode is shared between all file descriptors.

00:28:14,520 --> 00:28:16,430
Right, so you have a timerfd,

00:28:16,430 --> 00:28:19,050
this is used by timerfds, by signalfds,

00:28:19,050 --> 00:28:21,060
BPF uses it as well,

00:28:21,060 --> 00:28:23,270
I guess the new mount API uses it as well.

00:28:23,270 --> 00:28:25,090
So they don't really require full inodes,

00:28:25,090 --> 00:28:27,480
you don't need to allocate a new inode all of the time

00:28:27,480 --> 00:28:30,200
and then when all references to the inode are dropped

00:28:30,200 --> 00:28:31,853
you destroy it, and so on.

00:28:32,997 --> 00:28:34,490
The inode just functions

00:28:34,490 --> 00:28:36,670
to hang on a bunch of file operations on there,

00:28:36,670 --> 00:28:38,550
that's all you need it for.

00:28:38,550 --> 00:28:42,290
So it's a really cheap way of creating a stable handle.

00:28:42,290 --> 00:28:44,070
And the other nice thing is

00:28:44,070 --> 00:28:45,840
all of the infrastructure is already there.

00:28:45,840 --> 00:28:47,030
We don't need to come up with

00:28:47,030 --> 00:28:49,870
a separate tiny, little file systems for pidfds and so on,

00:28:49,870 --> 00:28:51,606
but all of the infrastructure is there.

00:28:51,606 --> 00:28:54,240
That's the code, that's the core code,

00:28:54,240 --> 00:28:56,460
there is more changes to this but that's the core code

00:28:56,460 --> 00:28:58,780
in fork.c that creates a pidfd.

00:28:58,780 --> 00:29:03,490
You specify a flag at process creation time

00:29:03,490 --> 00:29:05,563
and then you allocate a new file.

00:29:06,400 --> 00:29:09,700
You stash a reference

00:29:09,700 --> 00:29:12,700
to struct pid of the process you just created in there,

00:29:12,700 --> 00:29:15,538
and then you have a stable process handle,

00:29:15,538 --> 00:29:17,720
you return that FD.

00:29:17,720 --> 00:29:22,200
So, we stole (laughs) the last usable

00:29:23,710 --> 00:29:25,380
flag for this from clone,

00:29:25,380 --> 00:29:29,093
so when CLONE_PIDFD landed, clone was saturated.

00:29:30,364 --> 00:29:31,920
There are a bunch of flags that are unused

00:29:31,920 --> 00:29:33,570
that the kernel currently ignores

00:29:33,570 --> 00:29:35,270
but we can't safely reuse them

00:29:35,270 --> 00:29:38,713
because I started looking at userspace

00:29:39,568 --> 00:29:41,590
and glibc and musl,

00:29:41,590 --> 00:29:43,520
that's the way you pronounce it, right, muscle?

00:29:43,520 --> 00:29:44,473
Useful muscle.

00:29:45,480 --> 00:29:48,390
And they, for example,

00:29:48,390 --> 00:29:51,640
they still pass CLONE_DETACHED down,

00:29:51,640 --> 00:29:53,930
and the CLONE_DETACHED flag has been ignored, I think,

00:29:53,930 --> 00:29:56,130
since kernel 2.6 something, or something.

00:29:56,130 --> 00:29:58,390
But it means if I then would go on,

00:29:58,390 --> 00:30:00,240
someone to decide, like,

00:30:00,240 --> 00:30:02,230
let's recycle the CLONE_DETACHED flag

00:30:02,230 --> 00:30:05,040
because nobody should be using this anymore in userspace,

00:30:05,040 --> 00:30:06,743
and, well, two libcs are broken,

00:30:07,710 --> 00:30:09,630
so that wasn't going to fly.

00:30:09,630 --> 00:30:13,280
So, out of clone flags, we've solved that problem later,

00:30:13,280 --> 00:30:14,680
we have a new clone version.

00:30:16,230 --> 00:30:19,910
Another specialty about pidfds is,

00:30:19,910 --> 00:30:22,540
which I tried to push for also for the new mount API

00:30:22,540 --> 00:30:25,200
but that wasn't super well-received,

00:30:25,200 --> 00:30:27,290
is that they are CLOEXEC by default,

00:30:27,290 --> 00:30:29,860
but especially for pidfds I guess it makes sense.

00:30:29,860 --> 00:30:31,793
You really don't want to leak pidfds

00:30:34,090 --> 00:30:35,713
into a child process.

00:30:37,830 --> 00:30:40,803
So, yeah, as you can see they're CLOEXEC by default.

00:30:41,910 --> 00:30:43,500
Which, in my ideal world,

00:30:43,500 --> 00:30:46,550
every new file descriptor type that we create

00:30:46,550 --> 00:30:49,563
should be CLOEXEC by default because you can use,

00:30:50,950 --> 00:30:54,133
what we decide, how is fcntl?

00:30:54,133 --> 00:30:55,500
- [Man] I, I mean, I say functal.

00:30:55,500 --> 00:30:57,410
- Functal, okay.

00:30:57,410 --> 00:30:58,420
Let's go with functal.

00:30:58,420 --> 00:31:02,550
You can take fcntl and take away the CLOEXEC flag.

00:31:02,550 --> 00:31:04,230
To do it race-free the other way around

00:31:04,230 --> 00:31:06,460
is a bit more difficult.

00:31:06,460 --> 00:31:08,560
But there are certain factions of the kernel

00:31:08,560 --> 00:31:10,550
that think that's not a great idea

00:31:10,550 --> 00:31:12,720
because then we end up with

00:31:12,720 --> 00:31:16,190
some file descriptors that have O_CLOEXEC by default

00:31:16,190 --> 00:31:17,820
and some file descriptors that are not.

00:31:17,820 --> 00:31:20,740
But actually, even before pidfd change landed

00:31:20,740 --> 00:31:22,580
this was already the case, for example,

00:31:22,580 --> 00:31:24,530
for the seccomp notifier FD,

00:31:24,530 --> 00:31:25,780
which is a new file descriptor type

00:31:25,780 --> 00:31:26,930
that you can get from seccomp,

00:31:26,930 --> 00:31:28,490
is CLOEXEC by default as well

00:31:28,490 --> 00:31:30,820
so that ship had already sailed, but, yes.

00:31:30,820 --> 00:31:33,160
If you think about adding a new

00:31:33,160 --> 00:31:35,020
file descriptor type it would be,

00:31:35,020 --> 00:31:37,260
I would strongly urge you to consider

00:31:37,260 --> 00:31:38,810
to make it CLOEXEC by default

00:31:38,810 --> 00:31:43,013
because userspace will really thank you for doing that.

00:31:44,020 --> 00:31:48,560
And also, we wanted to have a connection.

00:31:48,560 --> 00:31:51,050
So there are two ways where the pidfd API

00:31:51,050 --> 00:31:54,070
and the PID API are connected here.

00:31:54,070 --> 00:31:56,160
So if you specify CLONE_PIDFD,

00:31:56,160 --> 00:31:58,110
the original implementation that we had

00:31:58,110 --> 00:32:01,420
and then also the original CLONE_FD patch that had,

00:32:01,420 --> 00:32:02,583
last I looked at it,

00:32:03,881 --> 00:32:05,840
was that if you specified the flag

00:32:05,840 --> 00:32:08,720
then clone didn't return a PID

00:32:08,720 --> 00:32:10,640
but it returned you an FD,

00:32:10,640 --> 00:32:13,180
so basically you did type switching based on a flag

00:32:13,180 --> 00:32:15,320
which is not very nice

00:32:15,320 --> 00:32:19,160
but this was the first implementation that we had.

00:32:19,160 --> 00:32:23,600
It also meant that you couldn't return zero, right?

00:32:23,600 --> 00:32:24,630
For file descriptor,

00:32:24,630 --> 00:32:28,560
zero is a perfectly fine value if stdin is closed.

00:32:28,560 --> 00:32:31,000
But obviously zero as a return value

00:32:31,000 --> 00:32:33,137
is used to indicate that this is

00:32:33,137 --> 00:32:35,610
the child process right now and not the parent process,

00:32:35,610 --> 00:32:40,000
so we could not have allocated file descriptors

00:32:40,000 --> 00:32:42,850
starting from zero, which again, is not very nice.

00:32:42,850 --> 00:32:46,290
So Oleg suggested how, at least for clone,

00:32:46,290 --> 00:32:49,833
we abuse the parent TID pointer argument,

00:32:50,750 --> 00:32:52,223
TID pointer argument,

00:32:53,580 --> 00:32:56,900
which is already reused as a return argument

00:32:56,900 --> 00:32:58,680
only for CLONE_PARENT_SETTID,

00:32:58,680 --> 00:32:59,870
and for legacy clone

00:33:01,786 --> 00:33:04,370
make it incompatible with CLONE_PIDFD.

00:33:04,370 --> 00:33:07,280
So what you get right now, even with legacy clone,

00:33:07,280 --> 00:33:10,770
is you get a PID back, normal behavior,

00:33:10,770 --> 00:33:13,000
but you also get a pidfd placed

00:33:13,000 --> 00:33:15,950
in the parent TID pointer argument.

00:33:15,950 --> 00:33:17,390
So you see,

00:33:17,390 --> 00:33:18,810
there is not additional effort needed

00:33:18,810 --> 00:33:21,360
for you to find out what the PID is for that pidfd,

00:33:22,480 --> 00:33:25,380
which is again different to FreeBSD, you have pdfork,

00:33:25,380 --> 00:33:27,550
it gives you a procdesc back

00:33:27,550 --> 00:33:32,040
and then you need pdgetpid, I think, another system call,

00:33:32,040 --> 00:33:35,600
that gives you the pidfd back,

00:33:35,600 --> 00:33:37,280
gives you the PID back for the

00:33:37,280 --> 00:33:38,930
proc file descriptor that you used.

00:33:38,930 --> 00:33:40,410
For us, it's both at the same time,

00:33:40,410 --> 00:33:42,550
PID and pidfd which is nice,

00:33:42,550 --> 00:33:45,000
so you can choose what you're operating on.

00:33:45,000 --> 00:33:46,800
Probably if you don't wanted pidfds,

00:33:46,800 --> 00:33:49,670
you wouldn't have specified CLONE_PIDFD but, yeah.

00:33:49,670 --> 00:33:50,623
And also,

00:33:51,550 --> 00:33:52,800
if you have a pidfd but you don't have a PID

00:33:54,060 --> 00:33:55,690
and you want to learn

00:33:57,598 --> 00:33:59,070
what PID this pidfd is referring to,

00:33:59,070 --> 00:34:01,417
we have /proc/<pid>/fd/fdinfo,

00:34:01,417 --> 00:34:06,417
and fd/fdinfo will currently give you

00:34:06,860 --> 00:34:10,420
the PID number for,

00:34:10,420 --> 00:34:11,740
in the PID namespace

00:34:11,740 --> 00:34:14,430
of the proc instance you're looking at,

00:34:14,430 --> 00:34:16,513
so you can parse out the PID.

00:34:18,640 --> 00:34:20,833
There's an alternative way of doing this.

00:34:22,010 --> 00:34:24,060
Right, so, this is obviously,

00:34:24,060 --> 00:34:25,630
now you can in a raise free way

00:34:25,630 --> 00:34:27,900
create pidfds at process creation time,

00:34:27,900 --> 00:34:29,343
but with the new clone system call

00:34:29,343 --> 00:34:31,010
that I added, clone three,

00:34:31,010 --> 00:34:33,360
you also have a dedicated return argument

00:34:33,360 --> 00:34:35,030
and it's now a structure

00:34:35,970 --> 00:34:40,970
which gives you back the pidfd, so it's cleaner.

00:34:42,290 --> 00:34:43,803
Also, we're not out of flags.

00:34:45,190 --> 00:34:48,030
This is work that has been done by Joel,

00:34:48,030 --> 00:34:50,923
this is something that we discussed early on.

00:34:50,923 --> 00:34:55,550
This also had some controversy associated with it

00:34:55,550 --> 00:34:58,360
because we have different requirements

00:34:58,360 --> 00:35:00,380
and different ideas of what we want from this.

00:35:00,380 --> 00:35:02,037
But basically, right now,

00:35:02,037 --> 00:35:04,810
(coughs) if you have a pidfd, I'm sorry,

00:35:04,810 --> 00:35:07,500
if you have a pidfd you can

00:35:07,500 --> 00:35:11,710
get exit notifications even as a non-parent process.

00:35:11,710 --> 00:35:13,660
You don't get the exit status currently

00:35:13,660 --> 00:35:16,910
but you at least get notified that process has exited.

00:35:16,910 --> 00:35:19,260
Well, technically, to be very precise,

00:35:19,260 --> 00:35:23,110
you get notified when the thread group leader exits

00:35:23,110 --> 00:35:24,900
and the thread group is empty.

00:35:24,900 --> 00:35:26,980
Well, it should never be the case.

00:35:26,980 --> 00:35:28,393
That's a bug.

00:35:29,390 --> 00:35:31,320
There was actually a bug

00:35:31,320 --> 00:35:33,730
where you could have a zombie thread group leader

00:35:33,730 --> 00:35:37,210
but thread SID was still alive which shouldn't happen

00:35:37,210 --> 00:35:38,710
because now you have a problem that you can't

00:35:38,710 --> 00:35:41,450
send signals to a zombie thread group leader so

00:35:41,450 --> 00:35:43,730
find all of the threads and kill them one by one.

00:35:43,730 --> 00:35:45,570
But yes, so when the thread group leader exits

00:35:45,570 --> 00:35:48,950
and the thread group is empty you get notified that

00:35:48,950 --> 00:35:52,120
this process is now gone,

00:35:52,120 --> 00:35:54,913
which means, for a shared library,

00:35:55,757 --> 00:35:58,107
if you use pidfds you can now turn off SIGCHLD,

00:35:59,231 --> 00:36:01,570
say I don't want a signal when that process exits

00:36:01,570 --> 00:36:05,230
because I have a pidfd and it's in an epoll loop,

00:36:05,230 --> 00:36:10,153
and I just wanna be notified over the pidfd not via SIGCHLD.

00:36:11,610 --> 00:36:14,110
Which made a lot of people very happy, apparently.

00:36:15,170 --> 00:36:18,070
So you can hand off these pidfds, stuff it in epoll loops,

00:36:18,070 --> 00:36:21,760
and then watch for process exits.

00:36:21,760 --> 00:36:23,020
Also again, this is the code,

00:36:23,020 --> 00:36:26,020
it lives in two different files but I compacted it together,

00:36:27,320 --> 00:36:31,200
pidfd_poll lives in fork.c

00:36:31,200 --> 00:36:32,700
because it's a file method

00:36:32,700 --> 00:36:37,230
and do_notify_pidfd lives in, don't let me lie, signal.c?

00:36:37,230 --> 00:36:38,063
Oh, yes.

00:36:40,700 --> 00:36:44,930
So when a process exits and do_notify_parent is called,

00:36:44,930 --> 00:36:46,870
it calls do_notify_pidfd

00:36:46,870 --> 00:36:50,910
and if you have been watching closely

00:36:50,910 --> 00:36:53,200
you see that in struct pid there is

00:36:55,087 --> 00:36:57,530
hlist_head task, no, nonsense,

00:36:57,530 --> 00:36:59,540
wait_queue_head_t wait_pidfd.

00:36:59,540 --> 00:37:01,363
So, struct pid,

00:37:02,490 --> 00:37:05,357
everyone gets notified that has a reference to struct pid

00:37:05,357 --> 00:37:06,213
via such a pidfd.

00:37:07,600 --> 00:37:09,313
Okay, and,

00:37:10,460 --> 00:37:13,350
that's obviously, that's a pretty interesting,

00:37:13,350 --> 00:37:16,160
it's a pretty interesting piece of work.

00:37:16,160 --> 00:37:18,410
It's not as advanced as what FreeBSD has

00:37:19,445 --> 00:37:20,623
to draw comparisons.

00:37:21,740 --> 00:37:24,850
FreeBSD has kqueue and they also can get

00:37:24,850 --> 00:37:28,760
notifications such as the exit status

00:37:28,760 --> 00:37:32,960
for non-parent processes via kqueue,

00:37:32,960 --> 00:37:35,320
because kqueue, in contrast to epoll,

00:37:35,320 --> 00:37:36,950
gives you information back from the kernel

00:37:36,950 --> 00:37:38,053
so you can just stuff,

00:37:40,650 --> 00:37:43,630
put stuff in the, as we do with epoll,

00:37:43,630 --> 00:37:45,490
you can put stuff from userspace in there

00:37:45,490 --> 00:37:46,840
and if you get a notification on the FD

00:37:46,840 --> 00:37:48,170
you get it back from the kernel

00:37:48,170 --> 00:37:49,870
so you stuff your own information in there,

00:37:49,870 --> 00:37:51,550
kqueue also gives you back information

00:37:51,550 --> 00:37:54,170
from the kernel places in there

00:37:54,170 --> 00:37:57,110
especially for proc file descriptors.

00:37:57,110 --> 00:37:59,330
And then you can also watch

00:37:59,330 --> 00:38:01,870
when one of these proc file descriptors

00:38:01,870 --> 00:38:04,590
forks or exits, and so on, that's pretty nice.

00:38:04,590 --> 00:38:06,130
Maybe at some point in the future

00:38:06,130 --> 00:38:07,380
we can have something similar,

00:38:07,380 --> 00:38:08,947
but since we don't have kqueue

00:38:08,947 --> 00:38:11,430
and epoll can't give you back data from the kernel,

00:38:11,430 --> 00:38:13,113
at least not as far as I know,

00:38:14,320 --> 00:38:16,110
there is currently no nice way to do this

00:38:16,110 --> 00:38:17,810
and we didn't wanna implement read

00:38:18,720 --> 00:38:22,103
on pidfds at this point in time.

00:38:23,278 --> 00:38:24,640
Jann was against this as well

00:38:24,640 --> 00:38:26,240
for security reasons, and so on.

00:38:26,240 --> 00:38:29,023
So currently if you're a non-parent you cannot,

00:38:29,898 --> 00:38:33,040
well, you can read proc, obviously, to get the exit status,

00:38:33,040 --> 00:38:36,040
but there is no easy way to read it off of the pidfd,

00:38:36,040 --> 00:38:38,853
but, yeah, we can probably find ways to do this.

00:38:40,990 --> 00:38:44,720
And also in 5.3 is pidfds without CLONE_PIDFD.

00:38:44,720 --> 00:38:47,939
So, this came especially from

00:38:47,939 --> 00:38:51,830
the lmkd guys at Android,

00:38:53,020 --> 00:38:56,270
and also systemd had a use case for this.

00:38:56,270 --> 00:38:57,840
So if you forked a process

00:38:57,840 --> 00:38:59,547
and you wanted to get a

00:38:59,547 --> 00:39:01,464
pollable pidfd for them

00:39:03,472 --> 00:39:05,639
then you couldn't do this,

00:39:06,636 --> 00:39:08,969
but with pidfd_open you can.

00:39:09,823 --> 00:39:13,018
You specify the PID and then you get a pidfd for it

00:39:13,018 --> 00:39:15,185
which is pollable as well.

00:39:19,307 --> 00:39:20,691
And for 5.4,

00:39:20,691 --> 00:39:25,691
this is sort of the last bit for the skeleton, more or less,

00:39:25,970 --> 00:39:30,290
is waiting, this is proposed so it's been sent to Linus,

00:39:30,290 --> 00:39:33,210
I don't know if he's going to take it, maybe he won't,

00:39:33,210 --> 00:39:36,810
but it's up for the 5.4 merge window,

00:39:36,810 --> 00:39:39,192
is waiting through pidfds.

00:39:39,192 --> 00:39:40,460
We had a bit of a discussion how

00:39:40,460 --> 00:39:42,050
we exactly wanted to implement this.

00:39:42,050 --> 00:39:45,630
The most obvious way to a lot of people

00:39:45,630 --> 00:39:49,693
seemed to add a new type to the waitid system call, P_PIDFD,

00:39:50,670 --> 00:39:54,960
which, yes, which you can specify a pidfd

00:39:54,960 --> 00:39:58,600
and then you can wait on it.

00:39:58,600 --> 00:40:03,023
So that's sort of the core API that we have right now.

00:40:04,410 --> 00:40:07,040
The ideas, there is a bunch of ideas

00:40:08,580 --> 00:40:11,960
that I still have that I have started working on

00:40:14,690 --> 00:40:16,850
but haven't fully,

00:40:16,850 --> 00:40:20,070
I'm not fully sure about what semantics I want.

00:40:20,070 --> 00:40:22,390
Like, one of the things for example that I like,

00:40:22,390 --> 00:40:25,100
and that a lot of userspace projects also like

00:40:25,100 --> 00:40:27,900
is the kill-on-close semantics

00:40:27,900 --> 00:40:30,180
that FreeBSD has by default.

00:40:30,180 --> 00:40:31,960
So if you close the pidfd

00:40:31,960 --> 00:40:34,660
and it's the last FD that refers to the

00:40:34,660 --> 00:40:38,600
struct file that stashes away struct pid,

00:40:38,600 --> 00:40:43,233
then the process automatically gets SIGKILLed.

00:40:44,430 --> 00:40:46,660
We have it the other way,

00:40:46,660 --> 00:40:48,770
and if you want to keep the process alive

00:40:48,770 --> 00:40:51,740
even when the last pidfd has been closed on FreeBSD

00:40:51,740 --> 00:40:54,280
you need to specify a special flag

00:40:54,280 --> 00:40:56,523
called PD_DAEMON, I think.

00:40:57,990 --> 00:40:59,247
For us, it's the default.

00:40:59,247 --> 00:41:02,940
The process stays alive even if you specify,

00:41:02,940 --> 00:41:04,883
even if the last pidfd is closed.

00:41:05,850 --> 00:41:08,223
But there is,

00:41:09,310 --> 00:41:11,280
we could implement a flag

00:41:12,560 --> 00:41:14,280
at process creation time

00:41:15,130 --> 00:41:16,540
that lets you kill a process

00:41:16,540 --> 00:41:18,550
when the last FD referring to it is closed.

00:41:18,550 --> 00:41:21,040
The problem is that on FreeBSD

00:41:21,040 --> 00:41:24,120
cleaning up struct files,

00:41:24,120 --> 00:41:25,990
basically the release method that is called

00:41:25,990 --> 00:41:28,600
when a file is destroyed is called synchronously,

00:41:28,600 --> 00:41:30,830
so by the time close returns on FreeBSD

00:41:30,830 --> 00:41:33,380
you are sure that the release method has run.

00:41:33,380 --> 00:41:35,750
On Linux we have a work queue,

00:41:35,750 --> 00:41:37,650
so if you close an FD

00:41:37,650 --> 00:41:41,750
and close returns and it's the last FD,

00:41:41,750 --> 00:41:44,840
the release method might not necessarily been called

00:41:44,840 --> 00:41:46,270
because it's been added to your work queue

00:41:46,270 --> 00:41:47,360
the kernel might decide,

00:41:47,360 --> 00:41:48,820
ah, I'm gonna do this a little bit later

00:41:48,820 --> 00:41:50,700
because, you know, memory pressure or whatever.

00:41:50,700 --> 00:41:53,630
So it's asynchronously, and it's kind of,

00:41:53,630 --> 00:41:55,935
I'm kind of on the fence whether that still

00:41:55,935 --> 00:42:00,080
makes it a good idea or not,

00:42:00,080 --> 00:42:03,710
but I think I'm getting, running out of time.

00:42:03,710 --> 00:42:07,010
So, I hope I could give you an overview of

00:42:07,010 --> 00:42:09,303
the API we sort of built,

00:42:10,890 --> 00:42:14,110
and hopefully convinced you of its usefulness,

00:42:14,110 --> 00:42:17,804
and a little bit of glimpse into the future.

00:42:17,804 --> 00:42:19,710
There's one more thing

00:42:21,080 --> 00:42:23,970
that we would need to make the shared library case

00:42:23,970 --> 00:42:27,943
completely usable,

00:42:29,600 --> 00:42:33,730
but yeah, I'm pretty happy that we have this right now.

00:42:33,730 --> 00:42:35,283
And if you have any questions.

00:42:41,660 --> 00:42:42,820
- [Host] Also if, excuse me,

00:42:42,820 --> 00:42:45,610
if Jerome's here, could you please start hooking up?

00:42:45,610 --> 00:42:49,080
- [Christian] Oh, yes, I can also unplug.

00:42:49,080 --> 00:42:50,030
- [Host] Thank you.

00:42:51,262 --> 00:42:52,095
(audience claps)

00:42:52,095 --> 00:42:53,313
- [Man In White] Wait, I have a question.

00:42:55,290 --> 00:42:56,820
- Oh, yeah.

00:42:56,820 --> 00:43:00,070
- Have you given any thought about integrating with cgroups?

00:43:00,070 --> 00:43:03,833
Like, cgroups 2's cgroup.procs?

00:43:06,100 --> 00:43:11,100
- Mmm, no, what exactly would be your idea?

00:43:11,850 --> 00:43:13,280
- Well, when you open cgroup.procs

00:43:13,280 --> 00:43:15,980
it gives you a list of file descriptors, right,

00:43:15,980 --> 00:43:17,730
or PIDs, right?

00:43:17,730 --> 00:43:19,630
And between the time you do something with those PIDs

00:43:19,630 --> 00:43:22,410
and you opened it, it could've changed, right?

00:43:22,410 --> 00:43:26,360
- You could, ah, I think we had a discussion about,

00:43:26,360 --> 00:43:28,070
did we have this discussion about it?

00:43:28,070 --> 00:43:30,570
A flag where you can kill per cgroup or something?

00:43:34,128 --> 00:43:37,150
There are certainly ways where we can think about this

00:43:37,150 --> 00:43:38,900
where you can make it so that you could

00:43:38,900 --> 00:43:40,800
take down a whole cgroup, for example,

00:43:40,800 --> 00:43:44,190
but so far I haven't thought about this, but yeah.

00:43:44,190 --> 00:43:46,880
To be honest, there are so many possibilities

00:43:46,880 --> 00:43:48,930
that you could go with, that you could do,

00:43:48,930 --> 00:43:52,030
that it's kind of sometimes hard to be,

00:43:52,030 --> 00:43:53,603
to stay calm about this,

00:43:54,459 --> 00:43:56,590
but I don't want to rush things.

00:43:56,590 --> 00:43:58,470
But we're always open for patches.

00:43:58,470 --> 00:44:03,470
Like, the pidfds stuff has its own tree, so, yeah.

00:44:03,960 --> 00:44:06,400
One thing I would really like is

00:44:07,810 --> 00:44:09,680
I wanna make it so, and I tried to make it so,

00:44:09,680 --> 00:44:12,220
is often on Linux at process creation

00:44:12,220 --> 00:44:14,530
if you create a process with a specific property

00:44:15,900 --> 00:44:19,850
you then can later on use a prctl, or some other syscall,

00:44:19,850 --> 00:44:22,300
to change this property, to switch it on or switch it off,

00:44:22,300 --> 00:44:24,140
which is something that I don't really like

00:44:24,140 --> 00:44:26,750
especially if you think about process delegation,

00:44:26,750 --> 00:44:28,340
process management delegation,

00:44:28,340 --> 00:44:30,530
you really want that property to be created

00:44:30,530 --> 00:44:31,750
at process creation time

00:44:31,750 --> 00:44:33,640
and that process sticks with this process

00:44:33,640 --> 00:44:35,300
until it goes away,

00:44:35,300 --> 00:44:37,330
and that's something that I would really like.

00:44:37,330 --> 00:44:38,873
So basically treat it like a,

00:44:40,320 --> 00:44:43,063
almost like a capability on the file descriptor,

00:44:44,420 --> 00:44:48,180
that would be something I would really like to see more.

00:44:48,180 --> 00:44:49,950
Yeah, sorry.

00:44:49,950 --> 00:44:53,150
- So, do I understand correctly that pidfds

00:44:53,150 --> 00:44:56,643
prevent PID recycling, the recycling for the PIDs?

00:44:58,910 --> 00:45:00,730
- [Man] The PID can be recycled but you won't--

00:45:00,730 --> 00:45:03,360
- Oh, sorry, ah yes, I should be very clear,

00:45:03,360 --> 00:45:04,210
I didn't mention this.

00:45:04,210 --> 00:45:06,463
Oh, this was a totally snafu on my part.

00:45:07,320 --> 00:45:10,990
So, the PID can be recycled itself,

00:45:10,990 --> 00:45:12,290
so it doesn't pin the PID.

00:45:12,290 --> 00:45:13,750
It's not like, I think on Windows,

00:45:13,750 --> 00:45:15,720
where the PID just stays around.

00:45:15,720 --> 00:45:18,730
It guarantees you that when the process is exited

00:45:18,730 --> 00:45:20,397
and, for example, you send a signal to it,

00:45:20,397 --> 00:45:21,780
you say kill this process,

00:45:21,780 --> 00:45:24,060
but the process is already been gone,

00:45:24,060 --> 00:45:26,120
then the kernel will tell you ESRCH

00:45:26,120 --> 00:45:31,120
which is errno for there is no such process, it has gone.

00:45:31,870 --> 00:45:35,060
So that pidfd is a stable handle in the sense

00:45:35,060 --> 00:45:36,860
you can't be tricked into operating

00:45:36,860 --> 00:45:38,750
on a process that doesn't exist anymore.

00:45:38,750 --> 00:45:40,660
But the PID itself can be recycled.

00:45:40,660 --> 00:45:44,110
- But that means that, for example, to track the cgroup

00:45:44,110 --> 00:45:46,910
I need to open the pidfd, check the cgroup,

00:45:46,910 --> 00:45:48,990
and check if the pidfd is still valid.

00:45:48,990 --> 00:45:50,270
- Yes, there is code,

00:45:50,270 --> 00:45:53,970
there is a sample program exactly for that reason

00:45:53,970 --> 00:45:54,920
because I knew there came up,

00:45:54,920 --> 00:45:59,920
there is a sample program in the samples directory

00:46:00,595 --> 00:46:02,040
/pidfd something something

00:46:02,040 --> 00:46:04,740
that shows you how to, in the raise free manner,

00:46:04,740 --> 00:46:09,740
turn an anonymous inode pidfd into a proc PID directory.

00:46:10,300 --> 00:46:14,380
It basically involves parsing out the proc pidfd info,

00:46:14,380 --> 00:46:16,230
the PID from that file,

00:46:16,230 --> 00:46:18,690
then opening that file and then sending a signal

00:46:18,690 --> 00:46:20,970
and checking whether it's still the same process.

00:46:20,970 --> 00:46:22,260
So, it's already in there,

00:46:22,260 --> 00:46:24,510
you can see how this can be done in a raise free manner,

00:46:24,510 --> 00:46:25,450
we exactly thought about this case--

00:46:25,450 --> 00:46:27,550
- [Host] Okay, I'm sorry to interrupt but,

00:46:27,550 --> 00:46:28,383
thank you very much.

00:46:28,383 --> 00:46:30,135
Let's thank the speaker and let's welcome our next speaker.

00:46:30,135 --> 00:46:32,079

YouTube URL: https://www.youtube.com/watch?v=aCrFujGG8MM


