Title: LPC2019 - Red Hat joins CI party, brings cookies
Publication date: 2019-09-17
Playlist: Linux Plumbers Conference 2019
Description: 
	Red Hat joins CI party, brings cookies

Speakers
 Nikolai Kondrashov (Red Hat)
 Veronika Kabatova (Red Hat)

Description
For the past couple of years the CKI ("cookie") project at Red Hat has been transforming the way the company tests kernels, going from staged testing to continuous integration. We've been testing patches posted to internal maillists, responding with our results, and last year we started testing stable queues maintained by Greg KH, posting results to the "stable" maillist.

Now we'd like to expand our efforts to more upstream maillists, and join forces with CI systems already out there. We'll introduce you to the way our CI works, which tests we run, our extensive park of hardware, and how we report results. We'd like to hear what you need from a CI system, and how we can improve. We'd like to invite you to cooperation, both long-term, and right there, at a hackfest organized during the conference.

Naturally, real cookies will make an appearance.
Captions: 
	00:00:00,330 --> 00:00:01,930
- [Host] All right, well,

00:00:01,930 --> 00:00:03,784
welcome to the last block of the day.

00:00:03,784 --> 00:00:05,276
Hooray. (whooping)

00:00:05,276 --> 00:00:06,550
It's the best talk of the day,

00:00:06,550 --> 00:00:07,790
I'm sure. - Yes.

00:00:07,790 --> 00:00:10,525
- [Host] Two of my young coworkers

00:00:10,525 --> 00:00:14,575
have been working on a very important project with Red Hat.

00:00:14,575 --> 00:00:16,930
I'm sure they're gonna be enthusiastic,

00:00:16,930 --> 00:00:18,829
way more enthusiastic than me.

00:00:18,829 --> 00:00:20,410
(chuckling)

00:00:20,410 --> 00:00:23,239
Share all the information about what we're doing

00:00:23,239 --> 00:00:26,180
to bring the world of continuous integration

00:00:26,180 --> 00:00:29,050
into the world of the kernel on Red Hat.

00:00:29,050 --> 00:00:31,491
I hope you're all ready for some exciting fun.

00:00:31,491 --> 00:00:32,502
(laughing)

00:00:32,502 --> 00:00:34,216
I don't know if there's really cookies or not,

00:00:34,216 --> 00:00:35,258
if not, it's their fault. - There's cookies,

00:00:35,258 --> 00:00:37,120
there's cookies.

00:00:37,120 --> 00:00:38,374
I mean, there's no cookies.

00:00:38,374 --> 00:00:41,042
(laughing)

00:00:41,042 --> 00:00:44,810
- So next, Veronika, Nikolai.

00:00:44,810 --> 00:00:46,090
- Okay.

00:00:46,090 --> 00:00:47,620
Thanks everybody for coming

00:00:47,620 --> 00:00:49,950
And, yeah, we're gonna be talking about

00:00:50,960 --> 00:00:53,690
how we introduced CI into the kernel development at Red Hat

00:00:53,690 --> 00:00:55,540
and how we hope to bring it upstream.

00:00:56,870 --> 00:00:57,703
How we're doing it

00:00:57,703 --> 00:01:01,403
and how we think it could cooperate with others.

00:01:03,020 --> 00:01:05,887
But first, is there anybody who doesn't like cookies?

00:01:05,887 --> 00:01:07,530
(chuckling)

00:01:07,530 --> 00:01:10,140
Okay, that's good, that's good.

00:01:10,140 --> 00:01:10,973
We're all set.

00:01:12,330 --> 00:01:14,510
- [Man] I don't like Crawford cookies.

00:01:14,510 --> 00:01:18,940
- Nobody likes those, we're not talking about those.

00:01:18,940 --> 00:01:20,590
So.

00:01:20,590 --> 00:01:23,190
- Okay, hi, I'm Veronika, you might know me

00:01:23,190 --> 00:01:24,780
from some of the mailing lists,

00:01:24,780 --> 00:01:27,810
when I'm usually a very generic annoyance.

00:01:27,810 --> 00:01:30,947
I'm also an organizer of Czech Python Conference

00:01:30,947 --> 00:01:32,613
and Wannabe mentor.

00:01:33,597 --> 00:01:35,290
- And I'm Nicolai Kondrashov,

00:01:35,290 --> 00:01:37,593
I'm an engineer at Red Hat, obviously.

00:01:39,070 --> 00:01:41,270
I'm also an electronics embedded enthusiast

00:01:41,270 --> 00:01:43,140
and I also maintain DIGImend project

00:01:43,140 --> 00:01:45,241
where I work on drivers for graphics tablets.

00:01:45,241 --> 00:01:50,241
And I do stuff like usbhid-dump and use hidrd-convert

00:01:50,260 --> 00:01:54,893
for the HID devices, but that's outside work.

00:01:56,810 --> 00:02:00,160
So and we are part of the CKI team

00:02:00,160 --> 00:02:01,760
that is pronounced cookie,

00:02:01,760 --> 00:02:03,600
or supposed to be pronounced cookie.

00:02:03,600 --> 00:02:07,523
And we are spread over the world in different places

00:02:07,523 --> 00:02:09,660
and we're kind of a collection

00:02:09,660 --> 00:02:10,930
of people from different teams

00:02:10,930 --> 00:02:12,880
at Red Hat trying to push this forward.

00:02:14,410 --> 00:02:18,003
And I want to start with the fact that not too long ago,

00:02:19,724 --> 00:02:23,170
kernel release testing at Red Hat was kind of archaic.

00:02:23,170 --> 00:02:24,983
And well,

00:02:26,830 --> 00:02:30,080
to find bugs it took a lot of effort

00:02:30,080 --> 00:02:32,130
from everybody involved, as well as time.

00:02:33,120 --> 00:02:36,553
And it looked kind of like this a little bit.

00:02:40,770 --> 00:02:43,830
So the developers usually threw the build over the wall

00:02:43,830 --> 00:02:45,290
and the testers play with it

00:02:45,290 --> 00:02:46,650
and through it over the wall again.

00:02:46,650 --> 00:02:49,830
Until they couldn't and then

00:02:50,785 --> 00:02:51,872
a release happened.

00:02:51,872 --> 00:02:54,872
(audience laughing)

00:02:57,030 --> 00:03:00,530
And that was of course,

00:03:00,530 --> 00:03:02,320
inefficient in a collaboration,

00:03:02,320 --> 00:03:04,290
communication standpoint and took a while,

00:03:04,290 --> 00:03:07,060
but the worst thing was that our tests

00:03:07,060 --> 00:03:08,980
were running at the end of our,

00:03:08,980 --> 00:03:11,290
the great code pipeline that exists

00:03:11,290 --> 00:03:13,215
both inside and outside Red Hat.

00:03:13,215 --> 00:03:16,883
That means, as bugs progress down the pipeline,

00:03:18,030 --> 00:03:19,970
the further they go,

00:03:19,970 --> 00:03:23,280
the longer it takes for them to get fixed,

00:03:23,280 --> 00:03:24,536
as you need to go back

00:03:24,536 --> 00:03:28,767
and communicate the bug and have the fix accepted.

00:03:28,767 --> 00:03:30,160
And then wait for the code

00:03:30,160 --> 00:03:32,760
to percolate downstream all the time.

00:03:32,760 --> 00:03:37,060
And the final few bugs, which were actually hit by our test,

00:03:37,060 --> 00:03:38,593
took the longest to fix.

00:03:40,517 --> 00:03:45,090
And so we decided to improve that situation, of course,

00:03:45,090 --> 00:03:47,420
and we needed to do it much earlier,

00:03:47,420 --> 00:03:49,350
but we didn't it anyway.

00:03:49,350 --> 00:03:52,210
And right now, we have automatic tests running

00:03:52,210 --> 00:03:55,160
for the kernel repos that we have inside Red Hat

00:03:55,160 --> 00:03:57,430
for the ones that going to release

00:03:57,430 --> 00:03:58,940
and then into

00:04:01,930 --> 00:04:02,870
distribution.

00:04:02,870 --> 00:04:07,429
And we have tests running that go into mail lists

00:04:07,429 --> 00:04:10,093
as soon as they get posted on the mail list.

00:04:10,970 --> 00:04:13,370
But we thought we could brig it also to upstream

00:04:13,370 --> 00:04:15,600
to join the others already sending

00:04:15,600 --> 00:04:17,150
their reports intel and RO

00:04:19,240 --> 00:04:21,630
and maybe take it a little further.

00:04:21,630 --> 00:04:25,068
So we want those tests run, obviously on Linux 3.

00:04:25,068 --> 00:04:29,390
And we want it to run on some specific subsystem trees.

00:04:29,390 --> 00:04:33,070
And finally, we want them to run on the contributions

00:04:33,070 --> 00:04:34,750
that go into subsystem mail lists,

00:04:34,750 --> 00:04:38,570
before maintainers even set their eyes on it.

00:04:38,570 --> 00:04:40,590
We want the tests to run fast.

00:04:40,590 --> 00:04:43,760
We want the tests to provide results fast.

00:04:43,760 --> 00:04:47,570
And we want to shorten the feedback loop

00:04:47,570 --> 00:04:48,403
as much as possible,

00:04:48,403 --> 00:04:52,530
so that the bugs are found faster sooner and fixed

00:04:52,530 --> 00:04:57,530
and so that ultimately RHEL quality increases.

00:04:59,260 --> 00:05:01,960
So why we think that could be useful for other people,

00:05:01,960 --> 00:05:05,400
not only to us, is because we have tons of hardware.

00:05:05,400 --> 00:05:09,140
Starting with x86 and the whole zoo of aarch64

00:05:09,140 --> 00:05:12,103
and then ppc64, ppc64le and finally,

00:05:13,310 --> 00:05:15,400
the difficult to obtain s390x.

00:05:15,400 --> 00:05:19,060
And we have machines to start with, VMs obviously,

00:05:19,060 --> 00:05:21,780
and down to laptops, PCs, servers, mainframes,

00:05:21,780 --> 00:05:23,430
all kinds of stuff.

00:05:23,430 --> 00:05:27,880
We have this in our labs and available for testing on.

00:05:27,880 --> 00:05:30,880
As well, we have various kinds of peripheral and hardware

00:05:30,880 --> 00:05:34,200
like GPUs and NICs and all kinds of stuff

00:05:34,200 --> 00:05:36,216
that we can target.

00:05:36,216 --> 00:05:39,210
They're all part of a single system at Red Hat

00:05:39,210 --> 00:05:40,440
which maintains the inventory

00:05:40,440 --> 00:05:43,200
and provides the way to reserve this hardware

00:05:43,200 --> 00:05:46,633
and to run tests on and to provision the stuff.

00:05:48,400 --> 00:05:50,430
We have a lot of tests,

00:05:50,430 --> 00:05:52,430
we run a lot of tests, both from the upstream

00:05:52,430 --> 00:05:57,230
and developed internally and this is just a few of them.

00:05:57,230 --> 00:06:00,700
And what's more important, is that behind each of these

00:06:00,700 --> 00:06:03,380
we have maintainers, specific people

00:06:03,380 --> 00:06:06,367
who are responsible for the tests to work.

00:06:06,367 --> 00:06:08,010
And you can see like names repeated

00:06:08,010 --> 00:06:09,470
because, obviously, some people maintain

00:06:09,470 --> 00:06:12,030
a few more tests than one.

00:06:12,030 --> 00:06:15,710
And that allows us to keep them working

00:06:15,710 --> 00:06:17,050
and we keep them on track

00:06:17,050 --> 00:06:19,410
and always sync up as developers

00:06:19,410 --> 00:06:24,410
and work on the issues as they arise inevitably.

00:06:25,420 --> 00:06:30,030
And we already work with stable Linux,

00:06:30,030 --> 00:06:35,030
the stable tree, the stable RC tree and the stable queue,

00:06:35,260 --> 00:06:37,530
which Greg works on, where he keeps his patches

00:06:37,530 --> 00:06:40,820
to be incorporated into the stable releases.

00:06:40,820 --> 00:06:42,840
And here's an example of the report

00:06:42,840 --> 00:06:47,540
that we just sent to stable mail list.

00:06:47,540 --> 00:06:50,640
Starting with, obviously, the overview.

00:06:50,640 --> 00:06:55,394
This test passed and this is the kernel repo which was used,

00:06:55,394 --> 00:07:00,394
the commit and the artifacts that we produced.

00:07:00,410 --> 00:07:03,413
Finally, we go to the make commands

00:07:03,413 --> 00:07:04,900
that we used to build it.

00:07:04,900 --> 00:07:09,314
Here's the images and the configs that were produced.

00:07:09,314 --> 00:07:11,750
Then we follow with the summary of the tests

00:07:11,750 --> 00:07:13,670
for each of the architectures and the hosts

00:07:13,670 --> 00:07:15,830
so that they can be, right now there are two hosts

00:07:15,830 --> 00:07:18,040
for each architecture for each run

00:07:18,040 --> 00:07:18,900
and all the tests.

00:07:18,900 --> 00:07:21,715
Some test survived, means that they don't affect

00:07:21,715 --> 00:07:25,741
the result of the total summary of the test

00:07:25,741 --> 00:07:29,053
and like for tests that we have just introducing or fixing.

00:07:30,920 --> 00:07:33,010
Yeah, we have the comment on that on the message.

00:07:33,010 --> 00:07:35,910
And the second host of the same architecture,

00:07:35,910 --> 00:07:40,910
then the ppc64, both hosts, x86, both hosts.

00:07:41,080 --> 00:07:43,950
And at the end we have the links to the tests

00:07:43,950 --> 00:07:48,770
which we store in the same repo on GitHub right now.

00:07:48,770 --> 00:07:52,460
And that allows us to have tight control

00:07:52,460 --> 00:07:55,100
on what exactly to execute to apply fixes quicker

00:07:55,100 --> 00:07:58,540
and to respond to the changes in the kernel faster.

00:07:58,540 --> 00:08:03,470
And to isolate us from some developments that can interfere

00:08:03,470 --> 00:08:05,770
with the specific versions that we're testing.

00:08:07,309 --> 00:08:10,285
If we go further into the logs that we post,

00:08:10,285 --> 00:08:12,873
we have them organized by the architectural hosts

00:08:12,873 --> 00:08:17,130
and the specific tests and each test can have multiple logs.

00:08:17,130 --> 00:08:20,153
And if we take the example of this stable queue report,

00:08:21,110 --> 00:08:23,770
we can see how they would work.

00:08:23,770 --> 00:08:26,730
So this run failed

00:08:26,730 --> 00:08:31,220
and immediately, we send the copy of this report

00:08:31,220 --> 00:08:35,423
to test maintainers who will be able to step in

00:08:35,423 --> 00:08:38,740
and comment on the failure if something goes wrong,

00:08:38,740 --> 00:08:40,430
if there's a false positive

00:08:40,430 --> 00:08:42,330
and take action if something's broken.

00:08:44,590 --> 00:08:46,590
In this case, the test failed here.

00:08:46,590 --> 00:08:47,840
So not the merge or compile.

00:08:47,840 --> 00:08:49,940
And this is the specific test that failed.

00:08:51,120 --> 00:08:53,250
And this is the summary of what we actually tested,

00:08:53,250 --> 00:08:57,150
the repository from the stable tree, the commit exactly

00:08:58,010 --> 00:09:00,227
and then the commit from the queue tree

00:09:00,227 --> 00:09:03,090
and the patches that were in that queue tree.

00:09:03,090 --> 00:09:06,360
And finally, we can see the test that failed.

00:09:06,360 --> 00:09:07,827
And if you go to the logs,

00:09:07,827 --> 00:09:10,960
you can find the ppc64le first host

00:09:10,960 --> 00:09:13,300
And these are the logs for this test.

00:09:13,300 --> 00:09:16,117
And in this case, the problem was in this file

00:09:16,117 --> 00:09:18,503
and we can find it and point out

00:09:18,503 --> 00:09:20,860
that this particular test failed.

00:09:20,860 --> 00:09:24,060
And finally, this was actually a false positive

00:09:24,060 --> 00:09:25,160
and our maintainer stepped in

00:09:25,160 --> 00:09:28,110
and just pointed out what the problem was

00:09:28,110 --> 00:09:29,893
and when he's gonna fix it.

00:09:34,230 --> 00:09:36,280
- So as we stated at the beginning,

00:09:36,280 --> 00:09:39,320
the tests were only run for kernel builds.

00:09:39,320 --> 00:09:41,640
Now the rate at which we are running the test

00:09:41,640 --> 00:09:43,400
is much higher, the tests are running

00:09:43,400 --> 00:09:46,470
for every posted patch internally

00:09:46,470 --> 00:09:50,790
and for various upstream kernels as well.

00:09:50,790 --> 00:09:52,300
That means that it's much easier

00:09:52,300 --> 00:09:54,984
to discover bugs also in the tests.

00:09:54,984 --> 00:09:57,249
The software, the current cases,

00:09:57,249 --> 00:10:00,663
In the case in which we could have seen right now,

00:10:01,660 --> 00:10:05,040
the issue was that test wasn't ready to run

00:10:05,040 --> 00:10:06,483
on that kind of machine.

00:10:08,830 --> 00:10:10,580
So let's talk a bit about

00:10:10,580 --> 00:10:13,963
more kernel test bugs that we discovered.

00:10:15,140 --> 00:10:17,590
LTP is the most widely used

00:10:17,590 --> 00:10:21,211
and most comprehensive kernel test suit.

00:10:21,211 --> 00:10:24,920
And it contains a very large number of tests

00:10:24,920 --> 00:10:28,771
for subsystems and CVs.

00:10:28,771 --> 00:10:32,763
They do releases twice a year.

00:10:33,720 --> 00:10:35,920
And so, sometimes we can find issues

00:10:35,920 --> 00:10:37,333
in those releases as well.

00:10:38,310 --> 00:10:40,440
But right now, a few weeks ago,

00:10:40,440 --> 00:10:42,500
we started more closely collaborating

00:10:42,500 --> 00:10:45,080
with the LTP upstream maintainers.

00:10:45,080 --> 00:10:50,080
We started using more new commits from the master directly,

00:10:51,330 --> 00:10:54,330
to not only find bugs in the kernel,

00:10:54,330 --> 00:10:57,510
but also in the LTP test suit as well

00:10:57,510 --> 00:11:02,313
and to basically make the test suit more stable faster.

00:11:03,510 --> 00:11:06,940
These are just some examples of the bugs

00:11:06,940 --> 00:11:10,583
that we were able to find in the LTP test suit.

00:11:11,435 --> 00:11:15,830
And migrating to using newer commits

00:11:15,830 --> 00:11:18,980
helped us to find other possible kernel issues.

00:11:18,980 --> 00:11:21,083
These are not yet debugged.

00:11:23,000 --> 00:11:25,240
Let's keep it with LTP,

00:11:25,240 --> 00:11:28,750
but talk about bugs that were actually verified

00:11:28,750 --> 00:11:31,700
and already fixed in the upstream kernels.

00:11:31,700 --> 00:11:34,960
This is a kernel bug that was discovered

00:11:34,960 --> 00:11:37,343
by the migrate pages test.

00:11:38,560 --> 00:11:41,060
You can see the email to the upstream mailing list

00:11:41,060 --> 00:11:43,890
from one of the LTP test maintainers,

00:11:43,890 --> 00:11:48,890
who stepped in and debugged the failure and found the issue.

00:11:50,420 --> 00:11:54,150
Here you we can you see the patch that's resolved,

00:11:54,150 --> 00:11:56,013
that failure in the upstream tree.

00:11:58,370 --> 00:12:01,810
Here is another example of LTP test,

00:12:01,810 --> 00:12:06,630
this case, MTEST06 which started hanging.

00:12:06,630 --> 00:12:10,423
I think it was in kernel slick 420 and higher.

00:12:11,730 --> 00:12:15,763
And this happens on ARM actually.

00:12:17,130 --> 00:12:21,613
You can, again, find here, the commit that fixed the issue.

00:12:22,740 --> 00:12:27,260
Let's keep with the MTEST06 which is like a very nice test

00:12:27,260 --> 00:12:28,903
finding a lot of issues.

00:12:30,160 --> 00:12:34,713
Here is another issue which was, again, on ARM.

00:12:35,770 --> 00:12:39,040
Very hard to reproduce and debug.

00:12:39,040 --> 00:12:42,540
And I want to point out this reply on the mailing list,

00:12:42,540 --> 00:12:45,790
maybe we should be doing more testing on ARM and PPC.

00:12:45,790 --> 00:12:49,060
And this is what Nik talked about at the beginning

00:12:49,060 --> 00:12:52,030
when he showed all the hardware

00:12:52,030 --> 00:12:54,670
that we are doing the testing on.

00:12:54,670 --> 00:12:56,910
Actually, most of the bugs that we found

00:12:56,910 --> 00:12:59,763
were on non x86 architectures.

00:13:02,770 --> 00:13:05,590
This is another test we are running, KVM unit test.

00:13:07,480 --> 00:13:12,480
It's finding some bugs as well in the upstream kernel.

00:13:12,740 --> 00:13:14,283
Again, this happened on ARM.

00:13:15,570 --> 00:13:17,693
Here was an issue with the timer.

00:13:21,340 --> 00:13:24,683
BLKTESTS are another large test suit that we are running.

00:13:25,860 --> 00:13:28,643
This bug happened also on ARM.

00:13:31,310 --> 00:13:34,900
Another issue, this time on the x86 actually,

00:13:34,900 --> 00:13:37,910
there was base root trace call,

00:13:37,910 --> 00:13:41,430
again, already resolved upstream, of course.

00:13:41,430 --> 00:13:42,930
And by testing kernel,

00:13:42,930 --> 00:13:46,290
we actually don't only find bugs in the kernel itself,

00:13:46,290 --> 00:13:49,280
but also in packages that depend on kernel.

00:13:49,280 --> 00:13:51,930
In this case, there was a bug in ZIPL,

00:13:51,930 --> 00:13:54,670
which is s390 boot loader.

00:13:54,670 --> 00:13:59,670
We worked with the boot loader team to resolve the problem.

00:14:02,840 --> 00:14:07,397
Since we started talking about the stable reports,

00:14:07,397 --> 00:14:12,397
we're actually faster than the stable build systems.

00:14:14,130 --> 00:14:17,670
And find things, not only what are bugs in kernel,

00:14:17,670 --> 00:14:21,143
but bugs in the patches, how the patches are posted.

00:14:25,860 --> 00:14:27,703
This one was a really fun one.

00:14:27,703 --> 00:14:29,590
(man speaking away from mic)

00:14:29,590 --> 00:14:31,127
- [Man] It's difficult to read them.

00:14:31,127 --> 00:14:31,960
- You don't need to read them.

00:14:31,960 --> 00:14:34,210
(laughing)

00:14:35,840 --> 00:14:39,540
Yeah, this one was a fun one, because it was discovered

00:14:40,411 --> 00:14:45,411
like around the time we started sending the stable report.

00:14:45,432 --> 00:14:48,015
All of the boot testing failed.

00:14:49,860 --> 00:14:54,080
We hit a kernel panic on all architectures.

00:14:54,080 --> 00:14:57,050
And it was actually a test for CI

00:14:57,050 --> 00:15:00,610
that was pushed into the stable repositories.

00:15:00,610 --> 00:15:03,663
The test, the CI systems testing the kernel.

00:15:03,663 --> 00:15:06,164
- [Nikolai] We were so happy we found this one.

00:15:06,164 --> 00:15:07,900
(chuckles)

00:15:07,900 --> 00:15:10,103
- Yeah, this one was really funny.

00:15:13,600 --> 00:15:17,190
Since we would for a very long time

00:15:17,190 --> 00:15:20,020
if we were talking in detail

00:15:20,020 --> 00:15:22,490
about all the bugs that we found,

00:15:22,490 --> 00:15:26,973
we set up a tracker in the linked Git repository,

00:15:28,510 --> 00:15:32,420
where you can find all the upstream bugs

00:15:32,420 --> 00:15:34,596
that help public bug tracker

00:15:34,596 --> 00:15:36,296
or resolution on the mailing list,

00:15:37,820 --> 00:15:42,683
on this link, so we can save some time.

00:15:44,630 --> 00:15:46,650
And before we move forward,

00:15:46,650 --> 00:15:50,229
I want to thank to every developer and test maintainer

00:15:50,229 --> 00:15:54,940
that is helping us resolve the issues and debug them

00:15:54,940 --> 00:15:57,660
because without you, we wouldn't be able

00:15:57,660 --> 00:15:59,310
to do the work that we are doing.

00:16:00,810 --> 00:16:02,174
- Yeah, this is the kind of work

00:16:02,174 --> 00:16:05,590
that goes across the departments at Red Hat

00:16:05,590 --> 00:16:07,920
and across all the kinds of people involved

00:16:07,920 --> 00:16:09,400
with this, of course.

00:16:09,400 --> 00:16:11,530
And we are not using that bug tracker

00:16:11,530 --> 00:16:13,093
to track the issues, of course, at Red Hat,

00:16:13,093 --> 00:16:14,730
it's just for the outside.

00:16:14,730 --> 00:16:16,970
But a lot of bugs that we find,

00:16:16,970 --> 00:16:18,530
of course, stay inside Red Hat

00:16:18,530 --> 00:16:21,476
because they can be in stable kernels and things like that

00:16:21,476 --> 00:16:24,363
and this is just for the publishing.

00:16:26,630 --> 00:16:29,070
- Yeah, so let's talk about the actual

00:16:29,070 --> 00:16:31,467
C-kind implementation for a second.

00:16:33,110 --> 00:16:36,190
The kernel development is a bit different

00:16:36,190 --> 00:16:39,910
than a development of random user-space build rates

00:16:39,910 --> 00:16:42,653
that are on GitHub, as we all know probably.

00:16:43,880 --> 00:16:47,100
We are using GitLab CI

00:16:47,100 --> 00:16:50,010
and we are hacking around it a bit

00:16:50,910 --> 00:16:53,223
to make it do what we want it to do.

00:16:54,820 --> 00:16:57,070
Let's just start with the triggers,

00:16:57,070 --> 00:16:58,230
we need to figure out

00:16:58,230 --> 00:17:01,633
how to actually test things and what to test.

00:17:03,500 --> 00:17:06,240
The basic one is a Git trigger.

00:17:06,240 --> 00:17:09,100
We need to figure out when there was

00:17:09,100 --> 00:17:12,080
a new commit to the Git tree.

00:17:12,080 --> 00:17:14,933
We clone that tree build it, test it.

00:17:17,120 --> 00:17:20,560
The other ones of the simple triggers

00:17:20,560 --> 00:17:22,600
are for Fedora build systems.

00:17:22,600 --> 00:17:24,450
We are testing Fedora kernel builds

00:17:24,450 --> 00:17:27,143
from build of Koji and COPR.

00:17:28,850 --> 00:17:31,900
And probably, the most advanced trigger we have

00:17:31,900 --> 00:17:33,670
is for patches.

00:17:35,417 --> 00:17:39,890
Parsing all the emails from mailing list is,

00:17:39,890 --> 00:17:42,070
as we probably all know, a lot of pain.

00:17:42,070 --> 00:17:44,450
So we are using Patchwork for this,

00:17:44,450 --> 00:17:46,410
so we don't need to reinvent all the work

00:17:46,410 --> 00:17:48,183
Patchwork is already doing.

00:17:49,180 --> 00:17:53,420
It's a management tool to make it easier

00:17:53,420 --> 00:17:55,870
to track the patches on the mailing list.

00:17:55,870 --> 00:17:59,220
We just query the Patchwork API and grab new patches,

00:17:59,220 --> 00:18:03,113
apply them to the tree, build it, test it.

00:18:04,880 --> 00:18:07,000
The other triggers you can see here,

00:18:07,000 --> 00:18:08,850
are for GitHub and GitLab.

00:18:08,850 --> 00:18:11,430
These are actually for testing our tests

00:18:11,430 --> 00:18:16,430
with known stable kernels and to test our pipeline as well.

00:18:17,930 --> 00:18:21,280
Then lower down in the diagram,

00:18:21,280 --> 00:18:23,780
you can see all our stages.

00:18:23,780 --> 00:18:28,700
The lint one is for checking the patches.

00:18:28,700 --> 00:18:32,360
For example, with the check patch BL script.

00:18:32,360 --> 00:18:35,080
We are only using this one internally right now,

00:18:35,080 --> 00:18:38,553
but there's no reason why it couldn't be extended

00:18:38,553 --> 00:18:42,853
to upstream once we start testing patches upstream as well.

00:18:43,910 --> 00:18:48,150
The merge stage serves for either just cloning the Git tree

00:18:49,020 --> 00:18:51,470
or also applying the patches,

00:18:51,470 --> 00:18:53,010
in case patches are being tested.

00:18:53,010 --> 00:18:56,205
Then we obviously build the kernel.

00:18:56,205 --> 00:18:58,470
Publish it so people from upstream

00:18:58,470 --> 00:19:00,410
can download the binary directly

00:19:00,410 --> 00:19:03,963
and get the kernel we actually tested.

00:19:05,840 --> 00:19:09,350
The test stage follows, we are doing the testing in Beaker,

00:19:09,350 --> 00:19:13,279
which contains all those machines Nik talked about.

00:19:13,279 --> 00:19:15,460
And then there is a review stage,

00:19:15,460 --> 00:19:18,510
which is showed in the dotted lines

00:19:18,510 --> 00:19:20,160
because we are getting rid of it.

00:19:22,050 --> 00:19:24,672
It basically just slows down

00:19:24,672 --> 00:19:27,000
getting the report out to the developers

00:19:27,000 --> 00:19:29,470
and we are CC'ing the test maintainers

00:19:29,470 --> 00:19:31,290
on the reports anyways.

00:19:31,290 --> 00:19:33,800
So there's no need to wait

00:19:34,660 --> 00:19:35,493
and

00:19:36,850 --> 00:19:38,023
make it slower.

00:19:39,060 --> 00:19:41,460
So all the emails that are going to upstream

00:19:41,460 --> 00:19:45,223
are fully automated, there is no review stage.

00:19:47,360 --> 00:19:51,380
Then all of this is put together in the email reports,

00:19:51,380 --> 00:19:53,933
which you've already seen some examples of.

00:19:56,320 --> 00:20:00,340
Now let's see how the full GitLab CI pipeline looks.

00:20:00,340 --> 00:20:03,420
You can see that it's pretty large.

00:20:03,420 --> 00:20:06,070
This one actually contains also the review stage,

00:20:06,070 --> 00:20:08,223
so you can see it all looks.

00:20:09,140 --> 00:20:10,990
It all starts with linting,

00:20:12,163 --> 00:20:15,190
merging and then it branches out

00:20:16,210 --> 00:20:17,363
to all the targets that we want to test.

00:20:17,363 --> 00:20:20,460
In this case, there are different architectures,

00:20:20,460 --> 00:20:23,693
but we can add targets for debug kernels as well.

00:20:25,750 --> 00:20:29,227
Then we publish the kernels, test them.

00:20:29,227 --> 00:20:32,420
And the review stage here is a manual step,

00:20:32,420 --> 00:20:36,380
that's why it's shown at the start of the pipeline,

00:20:36,380 --> 00:20:38,853
that's just a GitLab CI thing.

00:20:40,250 --> 00:20:45,250
Where if the developer or person from QE reviews the report

00:20:46,020 --> 00:20:49,143
and determines if it's a real failure or not,

00:20:50,116 --> 00:20:53,560
they can click the particular button

00:20:53,560 --> 00:20:56,893
and send the report or make sure it doesn't get sent.

00:20:57,950 --> 00:21:01,180
As I mentioned, we are trying to get rid of this stage

00:21:01,180 --> 00:21:03,223
and it's not used for upstream.

00:21:05,860 --> 00:21:09,433
So let's talk in details about the actual triggers.

00:21:10,336 --> 00:21:15,336
For the Git repo, Git doesn't really send you notifications

00:21:15,980 --> 00:21:17,578
when there are new commits.

00:21:17,578 --> 00:21:22,420
So we need to pull the repo in regular intervals.

00:21:22,420 --> 00:21:26,720
And we check if we've already seen that particular commit.

00:21:26,720 --> 00:21:30,593
If not, then we clone the repo, build and test it.

00:21:33,410 --> 00:21:37,362
For Patchwork, the part with cloning the repo is same.

00:21:37,362 --> 00:21:41,770
But we are pulling the Patchwork API

00:21:41,770 --> 00:21:44,740
and getting new patch series from there

00:21:44,740 --> 00:21:47,793
and then we are testing each patch series separately.

00:21:51,210 --> 00:21:54,503
We apply the patches and build and test them.

00:21:56,946 --> 00:22:00,610
(speaking away from mic)

00:22:00,610 --> 00:22:02,180
- So I have a question.

00:22:02,180 --> 00:22:05,080
You said if it sees the Git commit then,

00:22:05,080 --> 00:22:07,200
if it's seen it before, it doesn't do anything?

00:22:07,200 --> 00:22:08,033
- [Veronika] No.

00:22:08,033 --> 00:22:09,620
- What happens if you're watching a tree

00:22:09,620 --> 00:22:11,493
and you wanted to watch multiple branches

00:22:11,493 --> 00:22:13,940
and you merge-- - It's per branch.

00:22:13,940 --> 00:22:16,160
- One branch up to another one,

00:22:16,160 --> 00:22:17,760
it won't do again will it?

00:22:17,760 --> 00:22:20,873
I mean, does it keep record of the hashes?

00:22:21,730 --> 00:22:24,010
- It keeps a record of the hashes,

00:22:24,010 --> 00:22:28,100
but it's watching the branches and trees separately.

00:22:28,100 --> 00:22:31,560
- Okay, the reason I asked is 'cause we,

00:22:31,560 --> 00:22:33,350
at least for my tree, we start off

00:22:33,350 --> 00:22:35,750
putting commits in one branch.

00:22:35,750 --> 00:22:37,660
When we decide they're done and baked,

00:22:37,660 --> 00:22:39,200
we move them over to another branch.

00:22:39,200 --> 00:22:41,837
It's really just, it doesn't need to be tested again,

00:22:41,837 --> 00:22:44,630
they go over exactly the same, so, thank you.

00:22:44,630 --> 00:22:48,590
- Yeah we watch the trees and we watch the branches

00:22:48,590 --> 00:22:53,490
and then check if in our history of commits,

00:22:53,490 --> 00:22:56,793
there is already a hash of that commit present.

00:23:02,130 --> 00:23:06,080
Yeah, so the stable queue development is a bit special,

00:23:06,080 --> 00:23:11,080
it's not like patches sent to the Patchwork or just pushed,

00:23:11,774 --> 00:23:15,120
they're using quilt like series

00:23:15,120 --> 00:23:17,330
in a separate Git repository.

00:23:17,330 --> 00:23:21,370
So we have to actually check both this repository

00:23:21,370 --> 00:23:24,350
and the base repo, where to apply the patches

00:23:24,350 --> 00:23:25,970
and match them together.

00:23:25,970 --> 00:23:27,920
There are still some quirks

00:23:27,920 --> 00:23:31,173
which we are trying to figure out

00:23:31,173 --> 00:23:35,193
and some details, as always.

00:23:36,290 --> 00:23:38,500
But this is also a very specific workflow

00:23:38,500 --> 00:23:41,140
that we are trying to handle and use

00:23:41,140 --> 00:23:43,190
so we actually found some issues

00:23:44,100 --> 00:23:45,923
with these repositories as well.

00:23:47,550 --> 00:23:50,590
The Koji and COPR triggers are very simple

00:23:50,590 --> 00:23:53,430
because we don't need to actually build the kernel.

00:23:53,430 --> 00:23:56,110
The Fedora build systems are doing this for us.

00:23:56,110 --> 00:24:00,720
We only pull the new builds for the kernels

00:24:00,720 --> 00:24:03,063
that we are interested in and test them.

00:24:04,020 --> 00:24:07,433
You can see some logs from the trigger.

00:24:08,520 --> 00:24:10,830
The build systems are using a messaging system

00:24:10,830 --> 00:24:12,530
so we have a list of our deployed.

00:24:13,780 --> 00:24:15,700
You can see here, the logs

00:24:15,700 --> 00:24:18,330
for a known kernel build that completed.

00:24:18,330 --> 00:24:21,510
And yeah, we have a lot of debugs logs here

00:24:21,510 --> 00:24:24,810
so we can see that pipeline wasn't triggered

00:24:24,810 --> 00:24:27,523
for this particular build.

00:24:28,550 --> 00:24:31,720
Here you can see a build that failed from COPR.

00:24:31,720 --> 00:24:35,053
So this is, again, not a build that we are interested in.

00:24:36,110 --> 00:24:38,510
And here you can actually see a build

00:24:38,510 --> 00:24:42,170
for Fedora 30 which we are interested in

00:24:42,170 --> 00:24:43,580
and which we are testing.

00:24:43,580 --> 00:24:47,573
And a pipeline was triggered for this particular build.

00:24:51,170 --> 00:24:55,893
So now, just a few words about our CI setup.

00:24:57,870 --> 00:25:01,050
We have a bot that we ask to test

00:25:01,050 --> 00:25:05,170
because we need to test the changes

00:25:05,170 --> 00:25:10,170
with known good kernel, so we know that nothing broke.

00:25:12,920 --> 00:25:14,940
The full pipelines are being executed

00:25:14,940 --> 00:25:18,133
just with the changes that we push to the pipeline.

00:25:18,970 --> 00:25:23,360
And the interesting part here is also

00:25:23,360 --> 00:25:28,063
that our code is fully upstream and public,

00:25:28,063 --> 00:25:32,420
but the Beaker that the testing happens in,

00:25:32,420 --> 00:25:33,493
runs internally.

00:25:34,360 --> 00:25:37,730
So we actually need to trigger all this pipeline internally

00:25:37,730 --> 00:25:40,080
and that adds some additional complexity

00:25:40,080 --> 00:25:42,670
that we need to handle in this trigger,

00:25:42,670 --> 00:25:45,363
which is basically the fun part.

00:25:47,790 --> 00:25:49,930
Now, I hand it to Nik to

00:25:49,930 --> 00:25:52,503
talk about some more details. - Yes, thank you.

00:25:53,760 --> 00:25:56,310
So since this particular way

00:25:56,310 --> 00:26:00,068
we trigger the pipelines is very curious because

00:26:00,068 --> 00:26:05,068
GitLab CI is done for repos obviously stored in GitLab

00:26:05,470 --> 00:26:07,030
and we don't store kernel in GitLab,

00:26:07,030 --> 00:26:08,432
none of it is in GitLab.

00:26:08,432 --> 00:26:12,160
So we have to trick GitLab CI to start picking up our jobs.

00:26:12,160 --> 00:26:16,330
So we do it by making empty commits to a special Git repo

00:26:16,330 --> 00:26:19,240
and then triggering the CI on those commits

00:26:19,240 --> 00:26:22,860
and supplying the parameters of the kernel to be tested

00:26:22,860 --> 00:26:25,990
with those jobs.

00:26:25,990 --> 00:26:27,820
So it goes like this for example.

00:26:27,820 --> 00:26:31,040
A baseline trigger detected some commits in some repos,

00:26:31,040 --> 00:26:34,370
it submits one commit to one branch

00:26:34,370 --> 00:26:35,287
and another commit to another branch.

00:26:35,287 --> 00:26:38,765
And we have separate branches for separate kernel trees.

00:26:38,765 --> 00:26:41,440
Stable queue detected another one.

00:26:41,440 --> 00:26:42,830
Submits to stable branch again,

00:26:42,830 --> 00:26:44,850
because we're still testing stable.

00:26:44,850 --> 00:26:47,800
And the Patchwork detected some patches

00:26:47,800 --> 00:26:49,910
being posted to the mail list for rhel7.

00:26:49,910 --> 00:26:52,010
We submit it to rhel7 branch.

00:26:52,010 --> 00:26:54,910
And the GitHub bot came in and detected some merge request

00:26:54,910 --> 00:26:59,520
somewhere in GitLab or GitHub and was asked to test.

00:26:59,520 --> 00:27:01,255
And then it submits like a bunch of jobs

00:27:01,255 --> 00:27:04,890
to multiple branches to test for multiple Git trees

00:27:04,890 --> 00:27:08,570
to test our own changes to our own pipeline.

00:27:08,570 --> 00:27:10,590
This repo is private because we test

00:27:10,590 --> 00:27:13,813
some commits that are private to Red Hat.

00:27:15,990 --> 00:27:20,890
And there is all, the commits can look like this,

00:27:20,890 --> 00:27:22,600
like the branches, there's a bunch

00:27:22,600 --> 00:27:25,400
of empty commits being created there

00:27:25,400 --> 00:27:28,550
on which the CI pipeline was started.

00:27:28,550 --> 00:27:30,900
And you can see the stages of those pipelines to the right.

00:27:30,900 --> 00:27:34,409
Some failed, some passed, some are still being executed.

00:27:34,409 --> 00:27:37,300
And specific commits have commitments

00:27:37,300 --> 00:27:39,570
just explaining what kind of parameters went in there.

00:27:39,570 --> 00:27:44,120
And you can go thorough those commits in the repository

00:27:44,120 --> 00:27:48,020
and see which exact parameters went into this specific run.

00:27:48,020 --> 00:27:51,080
And do specified things like the Git repo,

00:27:51,080 --> 00:27:53,173
the URL, the hashes,

00:27:54,850 --> 00:27:57,330
where to send the reports and which branch was there

00:27:57,330 --> 00:27:59,390
and et cetera, et cetera, et cetera.

00:27:59,390 --> 00:28:01,620
So baseline is the simplest

00:28:01,620 --> 00:28:05,170
and the stable is more complicated in fit here.

00:28:05,170 --> 00:28:06,920
And you can see like which commit

00:28:08,150 --> 00:28:11,220
of the stable tree was used

00:28:11,220 --> 00:28:13,040
and which commit of the queue tree was used.

00:28:13,040 --> 00:28:18,040
And this way, since this is all stored in the parameters,

00:28:18,310 --> 00:28:22,230
we can re-trigger the same commit for the same job run

00:28:22,230 --> 00:28:25,989
for the same commit to the same state of both trees.

00:28:25,989 --> 00:28:28,850
And the patch commit obviously refers back

00:28:29,693 --> 00:28:32,970
to the specific patches in Patchwork

00:28:32,970 --> 00:28:35,960
and specific, for example,

00:28:35,960 --> 00:28:38,122
the specific subject that was used

00:28:38,122 --> 00:28:40,730
and where to send the emails, et cetera.

00:28:40,730 --> 00:28:44,043
So this all carries on to the pipeline.

00:28:45,410 --> 00:28:47,080
And the re-triggers, for example,

00:28:47,080 --> 00:28:49,780
when we test specific parts of the pipeline,

00:28:49,780 --> 00:28:51,700
we don't need to nourish and build the kernel again.

00:28:51,700 --> 00:28:54,206
We just use the images that we built previously

00:28:54,206 --> 00:28:56,666
from another run that turned out to be good.

00:28:56,666 --> 00:28:59,540
We just point to them, like you can see at the bottom,

00:28:59,540 --> 00:29:01,290
we are pointing specifically to artifacts

00:29:01,290 --> 00:29:02,740
that we built before.

00:29:02,740 --> 00:29:06,430
And we can run our tests on our own pipeline

00:29:06,430 --> 00:29:08,413
with those artifacts so it goes faster.

00:29:09,600 --> 00:29:12,723
And the same here, for every branch it's the same.

00:29:14,710 --> 00:29:17,530
And since about,

00:29:17,530 --> 00:29:19,494
we need to change our pipeline

00:29:19,494 --> 00:29:22,381
and if we do this in the same repo

00:29:22,381 --> 00:29:25,200
as those triggers submit to, it would be unusable.

00:29:25,200 --> 00:29:26,600
We have a separate repo,

00:29:26,600 --> 00:29:28,760
which actually contains our pipeline code.

00:29:28,760 --> 00:29:31,360
If anybody knows how GitLab CI works,

00:29:31,360 --> 00:29:35,310
there is a file in the repo which describes the pipeline.

00:29:35,310 --> 00:29:37,100
- [Man] Can I ask a question, Nikolai?

00:29:37,100 --> 00:29:38,670
- Yeah.

00:29:38,670 --> 00:29:40,257
- So based on how you setup the YAML files here

00:29:40,257 --> 00:29:41,530
and the triggering here,

00:29:41,530 --> 00:29:42,750
it seems like it's pretty easy

00:29:42,750 --> 00:29:45,530
to plug in any subsystem or Git tree in here

00:29:45,530 --> 00:29:47,200
to trigger testing.

00:29:47,200 --> 00:29:49,580
Is that right? - Yes, yes, absolutely right.

00:29:49,580 --> 00:29:52,190
- So anybody wants to plug in the CTI

00:29:52,190 --> 00:29:56,620
just can probably what, send an email to CTI project?

00:29:56,620 --> 00:30:01,620
- Submit a full request to the the pipeline-data repository

00:30:02,210 --> 00:30:04,500
with a link to your Git tree.

00:30:04,500 --> 00:30:06,180
If you have issues with the parameters,

00:30:06,180 --> 00:30:07,680
we can help you out with that.

00:30:08,543 --> 00:30:09,713
- Yeah.

00:30:11,023 --> 00:30:13,038
(man speaking away from mic)

00:30:13,038 --> 00:30:14,381
(audience exclaims)

00:30:14,381 --> 00:30:17,580
(audience laughing)

00:30:17,580 --> 00:30:19,130
- [Man] I gotta warm up, sorry.

00:30:20,210 --> 00:30:24,020
- So your stuff is built on top of Beaker, right.

00:30:24,020 --> 00:30:27,520
So how do you add hardware or how do you run this

00:30:27,520 --> 00:30:29,380
in your own lab if you're not using Beaker or--

00:30:29,380 --> 00:30:30,895
- Yeah, that's the point, that's the point.

00:30:30,895 --> 00:30:33,983
We get to this, we get to this, this is a good question.

00:30:35,280 --> 00:30:36,720
So-- - So, are you going

00:30:36,720 --> 00:30:37,610
to talk about it?

00:30:37,610 --> 00:30:39,540
I had a similar question, so I'll wait.

00:30:39,540 --> 00:30:40,391
- Yeah, we're going to talk about it.

00:30:40,391 --> 00:30:41,653
- Okay. - Another question.

00:30:41,653 --> 00:30:44,153
- I have a different question.

00:30:45,200 --> 00:30:47,820
So you use your own trigger for builds

00:30:47,820 --> 00:30:50,820
and you use your own tests, you use own machine pulls.

00:30:50,820 --> 00:30:54,350
So what parts of the GitLab are you using?

00:30:54,350 --> 00:30:59,350
- We use the GitLab CI to maintain the connection

00:30:59,700 --> 00:31:01,470
between the jobs that we run inside the CI.

00:31:01,470 --> 00:31:03,541
Like we connect, okay, we merge this,

00:31:03,541 --> 00:31:06,110
then we build it, then we test,

00:31:06,110 --> 00:31:07,720
then we send the reports.

00:31:07,720 --> 00:31:09,300
Kind of binds all the stages together

00:31:09,300 --> 00:31:10,730
and allows us to monitor it.

00:31:10,730 --> 00:31:13,680
We see the logs, how it's happening, to restart it.

00:31:13,680 --> 00:31:17,150
To keep the track, like the history of the jobs that we ran.

00:31:17,150 --> 00:31:18,512
Things like that.

00:31:18,512 --> 00:31:21,290
It does the same thing that Jenkins would do,

00:31:21,290 --> 00:31:23,286
if you know what Jenkins is.

00:31:23,286 --> 00:31:24,820
- No, I don't, but I'm trying to understand

00:31:24,820 --> 00:31:28,670
how much work are you, how much of the functionality

00:31:28,670 --> 00:31:30,800
you're actually reusing from--

00:31:30,800 --> 00:31:33,141
- From GitLab? - From GitLab, yes.

00:31:33,141 --> 00:31:37,080
- GitLab allows you a lot of customizations for the CI.

00:31:37,080 --> 00:31:40,210
You basically just write batch commands, for example,

00:31:40,210 --> 00:31:44,180
or execute any other language you want.

00:31:44,180 --> 00:31:48,830
So we just allow GitLab CI to build the kernel,

00:31:48,830 --> 00:31:53,680
or to merge patches, or to send a job to Beaker.

00:31:53,680 --> 00:31:57,320
So we are using the whole pipeline

00:31:57,320 --> 00:31:59,340
and CI ecosystem from GitLab

00:32:01,070 --> 00:32:03,680
and that's the part that's interacting with,

00:32:03,680 --> 00:32:05,803
for example, the Git trees and Beaker.

00:32:07,490 --> 00:32:08,862
If that makes sense. - You don't store

00:32:08,862 --> 00:32:09,943
the Git tree as this.

00:32:11,072 --> 00:32:12,870
I mean, you said you do an empty commit,

00:32:12,870 --> 00:32:14,883
so the kernel tree actually managed by GitLab.

00:32:15,796 --> 00:32:17,946
- Basically there is a job there if you go,

00:32:18,880 --> 00:32:20,430
that's going to be a long wait.

00:32:21,280 --> 00:32:24,630
There is a job that says clone that repo,

00:32:24,630 --> 00:32:26,210
check out this commit, like this,

00:32:26,210 --> 00:32:28,480
basically, batch script, you can say.

00:32:28,480 --> 00:32:30,903
Clone the tree, check out the commit,

00:32:31,768 --> 00:32:34,303
merge the patches, build the kernel.

00:32:34,303 --> 00:32:38,110
Like another job would say build the kernel

00:32:38,110 --> 00:32:40,380
and put the artifacts up there.

00:32:40,380 --> 00:32:44,590
And the next job says, okay, point at that kernel,

00:32:44,590 --> 00:32:46,633
tell Beaker to start testing from that kernel

00:32:46,633 --> 00:32:48,610
that is stored there.

00:32:48,610 --> 00:32:52,190
And GitLab CI is basically orchestrating

00:32:52,190 --> 00:32:54,260
and linking all those stages together.

00:32:54,260 --> 00:32:56,940
Let's us see the overview to restart a particular job

00:32:56,940 --> 00:32:59,287
in the pipeline and things like that.

00:32:59,287 --> 00:33:00,787
- [Man] Thank you.

00:33:01,700 --> 00:33:05,760
- So to trick GitLab CI, we use two repos.

00:33:05,760 --> 00:33:08,050
One repo, where we keep the actual code for the pipeline,

00:33:08,050 --> 00:33:09,910
the batch scripts and the YAML files.

00:33:09,910 --> 00:33:11,402
And the other one is just the very minimal stuff,

00:33:11,402 --> 00:33:15,290
that includes those, like the rhel7 includes

00:33:15,290 --> 00:33:17,580
the rhel7 specific stuff in the clone pipeline

00:33:17,580 --> 00:33:21,410
and rhel8 does the same and stable and so on.

00:33:21,410 --> 00:33:24,410
So further on for the testing, we don't have much time left.

00:33:26,530 --> 00:33:29,330
We have these basic data flows.

00:33:29,330 --> 00:33:33,990
We have the test database, which is at the moment, private,

00:33:33,990 --> 00:33:37,670
because we have a mix upstream and downstream stuff there

00:33:37,670 --> 00:33:39,877
and some things like goes into rhel7

00:33:39,877 --> 00:33:42,600
and rhel8, which is secret.

00:33:42,600 --> 00:33:44,870
But we have a plan to separate

00:33:44,870 --> 00:33:46,550
the private parts and the public parts

00:33:46,550 --> 00:33:49,130
and publish the parts that are public,

00:33:49,130 --> 00:33:53,300
so that we can work with people on that.

00:33:53,300 --> 00:33:54,870
Then we have to the tool which goes

00:33:54,870 --> 00:33:57,730
and transforms that database according to,

00:33:57,730 --> 00:33:59,820
takes parts, pieces of our test

00:34:00,770 --> 00:34:02,470
and according to parameters,

00:34:02,470 --> 00:34:05,000
like which kernel to test and which test to run,

00:34:05,000 --> 00:34:08,140
it creates a special XML file which we can feed to Beaker

00:34:08,140 --> 00:34:11,230
and which tells us exactly where to pull everything

00:34:11,230 --> 00:34:13,830
and which tests to run and how, et cetera.

00:34:13,830 --> 00:34:17,077
And Beaker is the system that was developed at Red Hat

00:34:17,077 --> 00:34:19,770
and was actually started by kernel developers.

00:34:19,770 --> 00:34:22,740
And it's open source, it's at BeakerPorject.org.

00:34:22,740 --> 00:34:24,990
But the problem is that nobody can set it up.

00:34:26,160 --> 00:34:28,180
So (laughs)

00:34:29,330 --> 00:34:33,760
we tried and that's the big problem that was hinted at.

00:34:33,760 --> 00:34:38,270
And another problem is that even if it was open system,

00:34:38,270 --> 00:34:41,080
the thing is that, what matters in this case

00:34:41,080 --> 00:34:42,390
is the hardware that we have.

00:34:42,390 --> 00:34:45,300
It would be good that somebody could install Beaker

00:34:45,300 --> 00:34:47,550
and actually start running our CI somewhere

00:34:47,550 --> 00:34:48,550
if they want to work on it

00:34:48,550 --> 00:34:51,750
or if they want to bring it up themselves.

00:34:51,750 --> 00:34:55,200
And maybe that will happen and maybe it will be easier,

00:34:55,200 --> 00:34:57,550
because people are working on improving Beaker.

00:34:58,710 --> 00:35:01,450
Or maybe we'll implement supports for some other system,

00:35:01,450 --> 00:35:02,843
which is also in the plans.

00:35:03,810 --> 00:35:08,810
So tested devices contains the information

00:35:08,852 --> 00:35:11,983
on which architectures we are able to test,

00:35:12,890 --> 00:35:15,720
which host types are available.

00:35:15,720 --> 00:35:18,580
The Beaker system allows you to specify very precisely,

00:35:18,580 --> 00:35:20,110
which host you want, which parameters.

00:35:20,110 --> 00:35:21,910
Like how much RAM, how much disk space.

00:35:21,910 --> 00:35:24,450
What kind of disk, what kind of hardware.

00:35:24,450 --> 00:35:27,380
Special like, interface cards or whatever.

00:35:27,380 --> 00:35:31,450
But since this is specific and too fine grained,

00:35:31,450 --> 00:35:33,290
we have our special host types

00:35:33,290 --> 00:35:36,050
like if we want to run specific test on bare metal,

00:35:36,050 --> 00:35:39,240
or we want this test to run with MegaRAID cards

00:35:39,240 --> 00:35:43,223
or we want the RDMA hardware or stuff like that.

00:35:44,114 --> 00:35:46,020
Then of course, there are the multiple trees,

00:35:46,020 --> 00:35:49,490
various kind likes realtime kernel

00:35:49,490 --> 00:35:52,855
or upstream this or upstream that or,

00:35:52,855 --> 00:35:56,850
all kinds which can be split for different purposes.

00:35:56,850 --> 00:35:58,590
For some test they'll run for rhel7,

00:35:58,590 --> 00:36:02,720
some for rhel8, or some can run for upstream.

00:36:02,720 --> 00:36:06,169
Finally, not finally, then there are the components

00:36:06,169 --> 00:36:07,840
of the build that we are testing.

00:36:07,840 --> 00:36:10,420
Because we might need to test for the upstream kernel,

00:36:10,420 --> 00:36:14,260
which in our pipeline, produces only the kernel image

00:36:14,260 --> 00:36:15,600
or we can test something

00:36:15,600 --> 00:36:18,380
that was submitted to our build system

00:36:18,380 --> 00:36:21,630
which produces the kernel, headers, the internal headers,

00:36:21,630 --> 00:36:25,490
the user-space headers, the debug information.

00:36:25,490 --> 00:36:28,350
And depending on the components that we get,

00:36:28,350 --> 00:36:29,980
we can choose to run specific tests

00:36:29,980 --> 00:36:31,520
like which might be the debugging

00:36:31,520 --> 00:36:33,040
for this specific test or something,

00:36:33,040 --> 00:36:35,691
or need to build some module

00:36:35,691 --> 00:36:39,560
which needs the kernel headers and things like that.

00:36:39,560 --> 00:36:41,220
So we need to branch on that.

00:36:41,220 --> 00:36:42,900
Finally, we of course have the test sets.

00:36:42,900 --> 00:36:46,000
For example, we need to run the network on this build,

00:36:46,000 --> 00:36:47,870
or a developer requests the network,

00:36:47,870 --> 00:36:49,230
makes the build and says, like,

00:36:49,230 --> 00:36:50,063
okay, run the network test.

00:36:50,063 --> 00:36:53,990
And this is how we specify which tests concern network.

00:36:53,990 --> 00:36:56,430
Finally, we have the suit information,

00:36:56,430 --> 00:36:57,470
the suite information.

00:36:57,470 --> 00:37:00,810
There are like about 75 test suites

00:37:00,810 --> 00:37:03,150
which are run for upstream right now.

00:37:03,150 --> 00:37:04,800
And some of them are very small

00:37:04,800 --> 00:37:09,800
and some of them are like LTPLite or USEX or KVM test.

00:37:10,130 --> 00:37:12,220
And then an example of suite data.

00:37:12,220 --> 00:37:15,810
This is not being run for upstream right now.

00:37:15,810 --> 00:37:18,160
This is the test that you can run yourself.

00:37:18,160 --> 00:37:20,773
So it will probably be run for upstream soon.

00:37:21,610 --> 00:37:23,740
So of course, start with the test name,

00:37:23,740 --> 00:37:25,030
then there is the location

00:37:25,030 --> 00:37:27,363
and the GitHub repo that I showed you before.

00:37:28,710 --> 00:37:30,010
In this case here,

00:37:30,010 --> 00:37:33,070
there is the host type that we want to use

00:37:33,070 --> 00:37:35,433
and the additional requirements for the host

00:37:35,433 --> 00:37:36,366
that the test might need.

00:37:36,366 --> 00:37:38,580
And this is in a special Beaker language

00:37:38,580 --> 00:37:39,500
which can look like this.

00:37:39,500 --> 00:37:42,050
Like okay, I don't want to run on Mustang or HP Moonshot

00:37:42,050 --> 00:37:43,400
because I don't work there.

00:37:44,490 --> 00:37:45,950
Then there's of course the maintainers

00:37:45,950 --> 00:37:47,760
which we need to contact if anything happens.

00:37:47,760 --> 00:37:50,700
And then there is sometimes the big patterns

00:37:50,700 --> 00:37:52,690
which describe where a test has to run.

00:37:52,690 --> 00:37:56,470
Like for example, which sets this belongs to.

00:37:56,470 --> 00:37:59,174
And this is actually a nice feature.

00:37:59,174 --> 00:38:02,520
This specifies when the test should run,

00:38:02,520 --> 00:38:04,400
if we are running for a patch

00:38:04,400 --> 00:38:06,520
and this specifies the specific files

00:38:06,520 --> 00:38:08,580
that need to be changed for this test to run.

00:38:08,580 --> 00:38:10,383
So for example, if we change something

00:38:10,383 --> 00:38:12,593
that's not related to KVM we don't run this test.

00:38:12,593 --> 00:38:15,225
And if it's a KVM change, then we run this test

00:38:15,225 --> 00:38:19,270
based on this regex plus for the source files.

00:38:19,270 --> 00:38:22,180
Then the actual architectures of course that we run on.

00:38:22,180 --> 00:38:25,160
And the trees that we run on.

00:38:25,160 --> 00:38:29,150
Finally, you can specify multiple instances

00:38:29,150 --> 00:38:30,860
of this test suite which can differ

00:38:30,860 --> 00:38:32,210
by parameters, for example.

00:38:32,210 --> 00:38:34,379
And here's an example of one.

00:38:34,379 --> 00:38:36,960
This has two instances and they differ

00:38:36,960 --> 00:38:39,050
by their environment arrivals

00:38:39,050 --> 00:38:41,160
and also there's one thing,

00:38:41,160 --> 00:38:45,110
this is how you specify whether the test is waived or not.

00:38:45,110 --> 00:38:48,283
Like do we take it seriously or is not ready yet?

00:38:49,480 --> 00:38:50,900
And-- (woman speaking away from mic)

00:38:50,900 --> 00:38:51,733
I'm sorry. - How do you

00:38:51,733 --> 00:38:56,531
determine waived versus...

00:38:57,593 --> 00:38:59,990
How do you determine waived?

00:38:59,990 --> 00:39:03,650
Where does that data come from and how do you feed it in?

00:39:03,650 --> 00:39:06,780
- Thank you, at the moment this is manual,

00:39:06,780 --> 00:39:08,800
that we decide ourselves based on

00:39:08,800 --> 00:39:12,620
how trustworthy the test is and how much we tested it.

00:39:12,620 --> 00:39:16,210
So when the test is waived, it is executed,

00:39:16,210 --> 00:39:18,850
with normal jobs like with upstream even.

00:39:18,850 --> 00:39:21,018
But we ignore the test.

00:39:21,018 --> 00:39:23,800
We show the results but we say like it's ignored.

00:39:23,800 --> 00:39:28,800
That let's us test the test in the battle situations.

00:39:29,510 --> 00:39:31,744
Ideally we would like to have the statistics

00:39:31,744 --> 00:39:33,710
and we're working on that and determine,

00:39:33,710 --> 00:39:36,250
like, if this test ran by itself.

00:39:36,250 --> 00:39:37,403
But this is very difficult to achieve

00:39:37,403 --> 00:39:39,850
because this depends on the complexity of this test.

00:39:39,850 --> 00:39:41,460
Like I want to run this big test longer

00:39:41,460 --> 00:39:43,360
and this short test short, less time.

00:39:43,360 --> 00:39:48,140
And there are many variables and the manual way is the best.

00:39:48,140 --> 00:39:50,020
Yes. - So, going back

00:39:50,020 --> 00:39:54,480
to your thing on the source code that you have referenced.

00:39:54,480 --> 00:39:57,490
So is that used by your system today

00:39:57,490 --> 00:39:59,661
to skip patches that don't touch

00:39:59,661 --> 00:40:01,680
certain areas of the kernel?

00:40:01,680 --> 00:40:03,090
- Yes. - Okay.

00:40:03,090 --> 00:40:06,660
- But this is only happening when the test patches.

00:40:06,660 --> 00:40:09,690
If when the test baselines like repeating the Git repo,

00:40:09,690 --> 00:40:11,170
then they run everything.

00:40:12,040 --> 00:40:15,110
Okay, so here's an example of using that particular feature.

00:40:15,110 --> 00:40:18,560
So if we don't specify the test, the patch,

00:40:18,560 --> 00:40:20,260
then it produces this many tests for upstream.

00:40:20,260 --> 00:40:22,030
And if you did specify the patch,

00:40:22,030 --> 00:40:24,173
it produces this many tests for upstream.

00:40:25,050 --> 00:40:28,400
And another, the specific job that is generating the XML.

00:40:28,400 --> 00:40:30,380
We can say like, generate XML.

00:40:30,380 --> 00:40:32,100
Specific kernel, this is the tree

00:40:32,100 --> 00:40:34,769
and this is the architecture and this is the patch.

00:40:34,769 --> 00:40:38,380
And it will start outputting like lots

00:40:38,380 --> 00:40:40,250
and lots of stuff like this.

00:40:40,250 --> 00:40:42,309
And if you take a look at the record for a test,

00:40:42,309 --> 00:40:46,090
there is the test name and the Git repo

00:40:46,090 --> 00:40:48,602
and the waived status and the maintainers

00:40:48,602 --> 00:40:50,810
and for example for the maximum time

00:40:50,810 --> 00:40:53,080
that this test is allowed to run.

00:40:53,080 --> 00:40:55,590
And this is how it would look in Beaker.

00:40:55,590 --> 00:40:57,320
The submitted jobs for specific, like,

00:40:57,320 --> 00:41:00,380
this is separate for peer architecture.

00:41:00,380 --> 00:41:04,440
And inside there can be multiple hosts for a job.

00:41:04,440 --> 00:41:08,183
And this is how a specific host run would look like

00:41:08,183 --> 00:41:10,540
when we tests and the results in that system

00:41:10,540 --> 00:41:12,970
and which you cannot inspect there.

00:41:12,970 --> 00:41:14,310
But this is, of course, available

00:41:14,310 --> 00:41:15,810
only internally at the moment.

00:41:17,090 --> 00:41:21,570
So the part about reporting is, oh, it's very short.

00:41:21,570 --> 00:41:24,030
So as we proceed through the pipeline,

00:41:24,030 --> 00:41:26,200
each stage generates a Bunch of artifacts,

00:41:26,200 --> 00:41:28,790
like the log files and the state of that stage.

00:41:28,790 --> 00:41:30,530
Results, like this has succeeded or not

00:41:30,530 --> 00:41:32,080
and it's the additional results.

00:41:32,080 --> 00:41:35,200
And as each job completes, it triggers a Webhook

00:41:35,200 --> 00:41:39,410
for our report process, which the report process ignores.

00:41:39,410 --> 00:41:41,480
Until we get then in the pipeline

00:41:41,480 --> 00:41:42,867
when it starts putting together the report

00:41:42,867 --> 00:41:47,020
and it takes the information from the first stages

00:41:47,020 --> 00:41:47,883
and puts it into summary.

00:41:47,883 --> 00:41:49,860
And then it takes the further information,

00:41:49,860 --> 00:41:51,660
like the maintainers that we put in there

00:41:51,660 --> 00:41:53,220
and whether it's waived or not,

00:41:53,220 --> 00:41:56,600
and puts it in the test summary and this overall summary

00:41:56,600 --> 00:41:57,563
and sends it off.

00:41:59,990 --> 00:42:03,650
- Okay, so we've been here for the first day of Plumbers.

00:42:03,650 --> 00:42:06,253
And during the distribution micro conference,

00:42:07,640 --> 00:42:08,960
there was a lot of people saying

00:42:08,960 --> 00:42:12,590
they are dealing with a lot of similar problems as we are.

00:42:12,590 --> 00:42:15,370
So we realized this also before

00:42:15,370 --> 00:42:18,325
and that's why we want to collaborate

00:42:18,325 --> 00:42:21,523
with other CI systems for the upstream.

00:42:23,990 --> 00:42:27,100
With the kernel maintainers, we can test your tree

00:42:27,100 --> 00:42:28,743
we already talked about this.

00:42:29,990 --> 00:42:32,340
With the test maintainers we can run your test

00:42:32,340 --> 00:42:36,280
and actually like test your tests as well.

00:42:36,280 --> 00:42:39,783
And for the other CI systems,

00:42:41,070 --> 00:42:44,910
there's a lot of stuff that we can collaborate on

00:42:44,910 --> 00:42:47,660
and join our efforts because everybody

00:42:47,660 --> 00:42:49,960
is dealing with the same problems.

00:42:49,960 --> 00:42:52,240
How to test things, what test to run,

00:42:52,240 --> 00:42:54,130
what hardware to run the test.

00:42:54,130 --> 00:42:56,650
And everybody is basically re-implementing

00:42:56,650 --> 00:42:58,543
the same thing all over again.

00:43:00,117 --> 00:43:02,650
And this is why we are organizing a hackfest

00:43:02,650 --> 00:43:06,963
right after Plumbers this Thursday and Friday.

00:43:08,362 --> 00:43:11,530
This is a very rough agenda.

00:43:11,530 --> 00:43:15,120
I'll skip to the last slide we have here

00:43:15,120 --> 00:43:17,920
because it has a link to our blog

00:43:17,920 --> 00:43:20,253
where you can find all the information.

00:43:21,290 --> 00:43:24,300
We are really looking forward to figuring out

00:43:24,300 --> 00:43:28,678
some common themes and actually creating some action items

00:43:28,678 --> 00:43:32,570
and then starting working on this

00:43:32,570 --> 00:43:34,370
so we don't need to re-implement

00:43:34,370 --> 00:43:36,260
all the work all over again.

00:43:36,260 --> 00:43:39,410
- [Nikolai] Yeah, we have a few places left, right?

00:43:39,410 --> 00:43:42,560
- Yeah, we have approximately about five spots.

00:43:42,560 --> 00:43:46,150
- So if you want to come-- - So if anybody is interested

00:43:46,150 --> 00:43:49,700
for the last minute, feel free to come.

00:43:49,700 --> 00:43:50,533
But let us know first so

00:43:50,533 --> 00:43:52,410
we know we can expect you. - Write us or catch us

00:43:52,410 --> 00:43:53,994
outside there and take a look at the agenda,

00:43:53,994 --> 00:43:55,670
there is lots of interesting stuff.

00:43:55,670 --> 00:43:57,640
Lots of people are already coming.

00:43:57,640 --> 00:43:59,625
- [Man] How do you add new hardware?

00:43:59,625 --> 00:44:01,140
- I'm sorry.

00:44:01,140 --> 00:44:02,449
- Unfortunately, I can attend

00:44:02,449 --> 00:44:04,610
'cause I'm in maintainer summit on one day

00:44:04,610 --> 00:44:06,240
and I was hoping to do that.

00:44:06,240 --> 00:44:10,030
And I was going to ask you some of the things,

00:44:10,030 --> 00:44:11,690
KSoft test, I haven't seen that

00:44:11,690 --> 00:44:12,615
in your test suite.

00:44:12,615 --> 00:44:14,220
Do you plan to-- - Yeah, KSoft test

00:44:14,220 --> 00:44:16,910
are very complicated because the test needs

00:44:16,910 --> 00:44:19,940
to be ready for CI which means it must give you

00:44:19,940 --> 00:44:23,160
a very clear pass fail output

00:44:23,160 --> 00:44:24,133
and KSoft tests don't really have that,

00:44:25,770 --> 00:44:26,800
at least they didn't have it

00:44:26,800 --> 00:44:29,340
at the time when we looked at them.

00:44:29,340 --> 00:44:31,200
- [Woman] When was that?

00:44:31,200 --> 00:44:33,990
- I'm not sure, but it was at least a year ago.

00:44:33,990 --> 00:44:35,360
- Okay, let's take a look at that

00:44:35,360 --> 00:44:40,053
because those tests are coming in from kernel developers.

00:44:40,053 --> 00:44:43,350
They go in when features go in,

00:44:43,350 --> 00:44:45,740
so there are advantages to using it.

00:44:45,740 --> 00:44:48,470
So if you wanna collaborate to

00:44:48,470 --> 00:44:50,207
make them better-- - Absolutely.

00:44:50,207 --> 00:44:52,360
- I am all for it and-- - Yeah.

00:44:52,360 --> 00:44:55,480
- I'll so we'll-- - Catch us up in the--

00:44:55,480 --> 00:44:56,850
- Yeah, we can talk offline.

00:44:56,850 --> 00:44:59,781
- Or write us and there is the address.

00:44:59,781 --> 00:45:01,728
- [Man] So do we arch our new hardware

00:45:01,728 --> 00:45:03,583
to move onto our disk five?

00:45:05,140 --> 00:45:08,150
- We go the Beaker administrators

00:45:08,150 --> 00:45:11,460
and the Beaker system is organized like in labs

00:45:11,460 --> 00:45:13,580
and these labs are spread all over the world.

00:45:13,580 --> 00:45:15,370
So there's somebody responsible for the labs.

00:45:15,370 --> 00:45:17,368
So you ask them like, okay,

00:45:17,368 --> 00:45:19,010
there's some hardware, can we added

00:45:19,010 --> 00:45:20,370
to the lab and they add it.

00:45:20,370 --> 00:45:21,983
And they add it to-- - So is it

00:45:21,983 --> 00:45:23,780
a different company from Red Hat?

00:45:23,780 --> 00:45:24,762
- No, no, no, it's the same,

00:45:24,762 --> 00:45:25,595
the same. - It's all internal.

00:45:25,595 --> 00:45:27,730
- It's just different people maintaining different labs

00:45:27,730 --> 00:45:29,990
and they add it, register the hardware there

00:45:29,990 --> 00:45:33,167
and then it pops up in their inventory

00:45:33,167 --> 00:45:34,603
and we can target it.

00:45:35,823 --> 00:45:38,510
- So I just wanted to say there a BoF session

00:45:38,510 --> 00:45:40,775
starting in two minutes about upstream kernels,

00:45:40,775 --> 00:45:42,000
CI projects in general.

00:45:42,000 --> 00:45:44,780
So if you can't attend the hackfest on Thursday and Friday,

00:45:44,780 --> 00:45:47,120
or even if you attend the hackfest on Thursday and Friday,

00:45:47,120 --> 00:45:48,870
you can still go to the BoF session

00:45:48,870 --> 00:45:50,858
to talk about general CI stuff.

00:45:50,858 --> 00:45:52,439
- When is that?

00:45:52,439 --> 00:45:53,272
When is it? - Now.

00:45:53,272 --> 00:45:55,220
- When, right now, Ametista room,

00:45:55,220 --> 00:45:56,980
I think it's two rooms down, yeah.

00:45:56,980 --> 00:45:59,030
- [Host] All right I think our time is up,

00:45:59,030 --> 00:46:00,772
thank you Veronika, thank you Nik.

00:46:00,772 --> 00:46:03,972

YouTube URL: https://www.youtube.com/watch?v=IM_k5fUsKhA


