Title: LPC2019 - XDP: the Distro View
Publication date: 2019-09-17
Playlist: Linux Plumbers Conference 2019
Description: 
	XDP: the Distro View

Speakers
 Jiri Benc (Red Hat)
Dr Toke Høiland-Jørgensen (RedHat)
 Jesper Dangaard Brouer (Red Hat)

Description
It goes without saying that XDP is wanted more and more by everyone. Of course, the Linux distributions want to bring to users what they want and need. Even better if it can be delivered in a polished package with as few surprises as possible: receiving bug reports stemming from users' misunderstanding and from their wrong expectations does not make good experience neither for the users nor for the distro developers.

XDP presents interesting challenges to distros: from the initial enablement (what config options to choose) and security considerations, through user supportability (packets "mysteriously" disappearing, tcpdump not seeing everything), through future extension (what happens after XDP is embraced by different tools, some of those being part of the distro, how that should interact with users' XDP programs?), to more high level questions, such as user perception ("how comes my super-important use case cannot be implemented using XDP?").

Some of those challenges are long solved, some are in progress or have good workarounds, some of them are yet unsolved. Some of those are solely the distro's responsibility, some of them need to be addressed upstream. The talk will present the challenges of enabling XDP in a distro. While it will also mention the solved ones, its main focus are the problems currently unsolved or in progress. We'll present some ideas and welcome discussion about possible solutions using the current infrastructure and about future directions.
Captions: 
	00:00:01,040 --> 00:00:04,503
- Now when a bug report comes,

00:00:05,370 --> 00:00:08,640
there are some things that changes a bit

00:00:08,640 --> 00:00:11,250
with in the introduction of BPF

00:00:11,250 --> 00:00:15,600
because BPF allows users to modify the behavior

00:00:15,600 --> 00:00:16,433
of the kernel.

00:00:16,433 --> 00:00:17,610
That's the whole point of BPF,

00:00:17,610 --> 00:00:19,960
to modify the behavior of the kernel.

00:00:19,960 --> 00:00:22,850
So, now, when a bug report comes,

00:00:22,850 --> 00:00:27,160
the system is behave behaving in an unexpected way,

00:00:27,160 --> 00:00:32,160
it might as well be because there's some stupid BPF program

00:00:32,460 --> 00:00:36,100
loaded or attached that does something that it should not

00:00:36,100 --> 00:00:36,933
be doing.

00:00:39,110 --> 00:00:40,230
It's probably nothing new

00:00:40,230 --> 00:00:42,690
because for example for in case of XDP,

00:00:42,690 --> 00:00:46,660
there might be program, XD program that is dropping packets.

00:00:46,660 --> 00:00:49,740
That's it's nothing new.

00:00:49,740 --> 00:00:52,740
There were such interfaces before.

00:00:52,740 --> 00:00:57,090
Netfilter, TC, yeah, so this is just one

00:00:57,090 --> 00:01:00,330
another place to look at but

00:01:00,330 --> 00:01:02,320
developers or engineers working on bug reports

00:01:02,320 --> 00:01:03,470
should be available at.

00:01:07,350 --> 00:01:10,700
Similarly two users, this is yet another way

00:01:10,700 --> 00:01:14,390
to screw up the system and now this is probably

00:01:14,390 --> 00:01:16,280
the responsibility of distributions

00:01:16,280 --> 00:01:21,263
to make easier for the users to out what's wrong.

00:01:22,260 --> 00:01:25,370
So, we are thinking about creating some cheat sheets.

00:01:25,370 --> 00:01:29,840
What to do if packets have suddenly disappearing

00:01:29,840 --> 00:01:34,350
or when developing your own BPF programs,

00:01:34,350 --> 00:01:36,763
and it's misbehaving, what to look for.

00:01:39,120 --> 00:01:41,670
Now, I said the bpftool provides

00:01:41,670 --> 00:01:45,950
only the view in the current moment.

00:01:45,950 --> 00:01:47,270
Now, that might be a problem

00:01:47,270 --> 00:01:49,700
because if we have some automation

00:01:49,700 --> 00:01:53,423
or some systems, some daemons who load and unload,

00:01:54,736 --> 00:01:59,240
loads and unloads, for example, XDP programs

00:01:59,240 --> 00:02:02,040
now the system might be misbehaving,

00:02:02,040 --> 00:02:06,203
but at the moment, we look at the snapshot of the system.

00:02:07,290 --> 00:02:10,193
It might be no, XDP programs loaded.

00:02:11,200 --> 00:02:14,530
So this might be pretty hard to debug.

00:02:14,530 --> 00:02:19,530
And also some custom users might prefer to have some

00:02:21,580 --> 00:02:25,460
history log of what happened on their systems,

00:02:25,460 --> 00:02:27,360
what programs were loaded and so on,

00:02:27,360 --> 00:02:30,410
because they right now, record what program

00:02:30,410 --> 00:02:32,010
get executed it by the users.

00:02:32,010 --> 00:02:34,313
So, this might be a bit similar thing.

00:02:35,400 --> 00:02:38,570
One pretty obvious point where to add this

00:02:38,570 --> 00:02:40,323
is the audit subsystem.

00:02:41,407 --> 00:02:43,970
Actually, Oshar is not in this room.

00:02:43,970 --> 00:02:47,630
He tried to send patches, adding that, but it got stuck

00:02:47,630 --> 00:02:50,590
on disagreement between the audit system

00:02:50,590 --> 00:02:53,330
audit subsystem maintainers and BPF subsystem maintainers.

00:02:53,330 --> 00:02:57,940
So, that's something that we would like them

00:02:57,940 --> 00:03:02,210
to talk with each other maybe use this opportunity to do so.

00:03:02,210 --> 00:03:05,200
And do something.

00:03:05,200 --> 00:03:06,950
Open with purpose and have a solution.

00:03:06,950 --> 00:03:10,420
The audit is not necessarily the only thing.

00:03:10,420 --> 00:03:11,620
- [Audience Member] No one's allowed to leave the room

00:03:11,620 --> 00:03:13,082
until we fixed this disagreement.

00:03:13,082 --> 00:03:15,332
(laughing)

00:03:16,920 --> 00:03:21,920
- Now, of course, distributions want to be secured.

00:03:24,020 --> 00:03:29,020
So, what does that mean for eBPF as well?

00:03:30,899 --> 00:03:34,803
There are two things that we need to pay attention to

00:03:36,110 --> 00:03:39,790
and that's first, is Spectre, as always.

00:03:39,790 --> 00:03:41,723
That's a problem for everyone.

00:03:43,010 --> 00:03:45,410
And second is the Verifier.

00:03:45,410 --> 00:03:47,940
I'm not saying that Verifier is buggy or something.

00:03:47,940 --> 00:03:50,210
But the thing is that the Verifier

00:03:50,210 --> 00:03:55,190
is the only difference between malicious BPF programs

00:03:55,190 --> 00:03:56,210
and a kernel.

00:03:56,210 --> 00:03:57,710
So, any bug in the Verifier is

00:03:58,850 --> 00:04:01,550
it might be, in fact, serious.

00:04:01,550 --> 00:04:03,193
So, how to get around this?

00:04:04,380 --> 00:04:07,030
First thing, I strongly advise

00:04:07,030 --> 00:04:10,400
to switch BPF_JIT_ALWAYS_ON on config option

00:04:10,400 --> 00:04:13,420
to turn it on to protect the system

00:04:13,420 --> 00:04:17,700
from malicious (mumbles) on machines because of Spectre.

00:04:17,700 --> 00:04:22,700
And the second thing is currently, unprivileged users

00:04:24,260 --> 00:04:28,070
are allowed to load and under some conditions,

00:04:28,070 --> 00:04:31,310
also attach BPF programs to a kernel.

00:04:31,310 --> 00:04:34,070
So, is that a problem or not?

00:04:34,070 --> 00:04:36,700
- I would say that the memory management code

00:04:36,700 --> 00:04:38,780
of the kernel is the only defense

00:04:38,780 --> 00:04:42,720
between user space and where things in the kernel

00:04:43,864 --> 00:04:44,760
- Yes. - I,

00:04:44,760 --> 00:04:46,690
why do we pick out the verifier because

00:04:46,690 --> 00:04:48,900
it's just scary and we're just new

00:04:48,900 --> 00:04:50,550
and we don't understand it completely.

00:04:50,550 --> 00:04:52,340
I think that's the only reason we singled it out.

00:04:52,340 --> 00:04:53,663
- Yes, you're right.

00:04:53,663 --> 00:04:54,693
You're right, we're not singling it out.

00:04:54,693 --> 00:04:56,040
This is the only reason.

00:04:56,040 --> 00:04:59,410
It's fresh, it's new, it's developing quickly.

00:04:59,410 --> 00:05:02,870
So, the likelihood of bugs, it might be higher.

00:05:02,870 --> 00:05:04,200
I'm not saying there are bugs.

00:05:04,200 --> 00:05:07,200
I'm saying that bugs in Verifier are dangerous.

00:05:07,200 --> 00:05:09,379
- The fear of the unknown.

00:05:09,379 --> 00:05:12,460
- I would say the the (chuckling)

00:05:12,460 --> 00:05:14,730
- Anyways, they just - Carefulness of new.

00:05:14,730 --> 00:05:17,220
- I just think some of the attention on the Verifier

00:05:17,220 --> 00:05:18,830
is overdone and lets just be clear

00:05:18,830 --> 00:05:20,640
why we're concerned about it, that's all.

00:05:20,640 --> 00:05:21,720
- Yep, as, I agree. - because any part

00:05:21,720 --> 00:05:24,006
of the kernel can be buggy and can cause (mumbles) problems

00:05:24,006 --> 00:05:25,283
that the Verifier can cause.

00:05:25,283 --> 00:05:26,116
- Yeah.

00:05:26,116 --> 00:05:29,180
And the last thing is when a bug in Verifier is found,

00:05:29,180 --> 00:05:30,720
it is fixed quickly. - That's true.

00:05:30,720 --> 00:05:31,893
- So, that's important.

00:05:34,660 --> 00:05:37,590
So, for, at least for now,

00:05:37,590 --> 00:05:39,720
I mean the things that we were considering

00:05:39,720 --> 00:05:42,040
is that Verifier bugs, if there are some,

00:05:42,040 --> 00:05:43,463
might be dangerous.

00:05:44,690 --> 00:05:49,160
BPF has been used in the past to ease exploits

00:05:49,160 --> 00:05:50,590
of the Spectre class.

00:05:50,590 --> 00:05:52,060
Again, it doesn't mean that it,

00:05:52,060 --> 00:05:54,380
they would not be exploitable without BPF.

00:05:54,380 --> 00:05:57,930
Just that BPF makes that easier to exploit them.

00:05:57,930 --> 00:06:00,700
And also from some, from threads

00:06:00,700 --> 00:06:04,180
on the NetDev mailing list, it's apparent that,

00:06:04,180 --> 00:06:05,660
at least Alex says he's considering

00:06:05,660 --> 00:06:08,483
switching off unprivileged BPF by default.

00:06:09,620 --> 00:06:14,620
So, what can be dome to switch off unprivileged BPF

00:06:14,970 --> 00:06:17,800
to mitigate these three problems?

00:06:17,800 --> 00:06:19,023
I mean, the three bugs.

00:06:20,380 --> 00:06:23,290
There's SSCTL that can be set only once

00:06:23,290 --> 00:06:26,250
that turns off unprivileged PBF

00:06:27,290 --> 00:06:31,060
but there's no way for the distributions to set

00:06:31,060 --> 00:06:32,890
that by default.

00:06:32,890 --> 00:06:34,380
We tried to get patch up stream,

00:06:34,380 --> 00:06:38,310
but we did not succeed, so, currently,

00:06:38,310 --> 00:06:41,620
in Rail, we have this Rail specific patch

00:06:41,620 --> 00:06:45,700
that does this and allows this to be actually

00:06:45,700 --> 00:06:49,203
over re done by boot kernel boot option.

00:06:50,160 --> 00:06:53,370
And (mumbles) we'd be sitting it in a boot loader.

00:06:53,370 --> 00:06:57,000
Maybe everybody would like to see this

00:06:57,000 --> 00:06:59,236
in upstream, the ability of the distro

00:06:59,236 --> 00:07:01,950
to turn off unprivileged BPF.

00:07:01,950 --> 00:07:05,260
- I think about Spectre, it's a very interesting topic

00:07:05,260 --> 00:07:09,390
because the irony of the situation

00:07:09,390 --> 00:07:11,300
is that we have the Verifier to look

00:07:11,300 --> 00:07:12,690
for Spectre like patterns

00:07:12,690 --> 00:07:14,563
and eliminate them or prevent programs

00:07:14,563 --> 00:07:17,300
to load that have these Spectre patterns.

00:07:17,300 --> 00:07:20,210
But the fact of the matter is is that we add

00:07:20,210 --> 00:07:22,270
the verifier checks after we've learned

00:07:22,270 --> 00:07:24,260
about the fact that these Spectre things exist,

00:07:24,260 --> 00:07:25,840
therefore, it is possible that people

00:07:25,840 --> 00:07:28,090
have deployed the eBPF programs previously

00:07:28,090 --> 00:07:30,130
that are using these patterns and so

00:07:30,130 --> 00:07:31,593
you install a kernel with the Verifier

00:07:31,593 --> 00:07:34,040
that can look for the patterns.

00:07:34,040 --> 00:07:36,200
It's kind of like, you lock the door

00:07:36,200 --> 00:07:39,150
after the thief if in your house already, okay.

00:07:39,150 --> 00:07:41,143
So, it is a serious concern.

00:07:43,440 --> 00:07:44,273
- Yep.

00:07:45,940 --> 00:07:50,370
So, now okay, we have unprivileged BPF switched off,

00:07:50,370 --> 00:07:52,743
but that means other problems.

00:07:53,810 --> 00:07:56,880
The first thing is that daemons

00:07:56,880 --> 00:07:59,440
that are manipulating maps, BPF maps,

00:07:59,440 --> 00:08:01,640
they need to be privileged.

00:08:01,640 --> 00:08:05,753
Which means that in a distribution,

00:08:05,753 --> 00:08:08,710
when in the future we have several packages

00:08:08,710 --> 00:08:11,080
that use BPF for different purposes,

00:08:11,080 --> 00:08:13,140
running daemons, accessing maps,

00:08:13,140 --> 00:08:16,010
they all need to basically run a route,

00:08:16,010 --> 00:08:19,363
which is not really enhancing distro security.

00:08:21,350 --> 00:08:25,600
Worse, only this applies even when they are

00:08:25,600 --> 00:08:28,663
only reading from maps, not just, not also writings.

00:08:30,143 --> 00:08:35,143
And I mean, enabling BPF map reads or something like that

00:08:36,080 --> 00:08:39,300
for non route is not, obviously, a solution

00:08:39,300 --> 00:08:43,260
because BPF maps can actually contain

00:08:43,260 --> 00:08:45,273
some secretive sensitive stuff too.

00:08:46,980 --> 00:08:49,633
Because that can influence the behavior of

00:08:49,633 --> 00:08:52,900
loading BPF program and it's, when it's something

00:08:52,900 --> 00:08:54,440
that responsible, I don't know,

00:08:54,440 --> 00:08:57,080
for DDOS protection on a host or something,

00:08:57,080 --> 00:08:59,090
that might be a problem.

00:08:59,090 --> 00:09:01,710
So, we would like to see a solution

00:09:01,710 --> 00:09:04,860
that allows some access rights,

00:09:04,860 --> 00:09:08,000
access control for maps for various daemons,

00:09:08,000 --> 00:09:12,084
such as Andillo Lutomirski proposed or something similar.

00:09:12,084 --> 00:09:14,267
- Yeah, I was just gonna say,

00:09:14,267 --> 00:09:16,984
if a privileged user puts secrets on a map

00:09:16,984 --> 00:09:19,380
and then exposes it to unprivileged users,

00:09:19,380 --> 00:09:24,380
I mean, this is like, what if they load a module or export,

00:09:24,760 --> 00:09:26,535
I don't know if you can protect against privileged users

00:09:26,535 --> 00:09:29,925
being exporting secrets, right.

00:09:29,925 --> 00:09:31,039
I mean.

00:09:31,039 --> 00:09:32,097
- [Audience Member 2] But we can't even let

00:09:32,097 --> 00:09:34,330
them export secrets now.

00:09:34,330 --> 00:09:35,803
- They can export all sorts of secrets, right?

00:09:35,803 --> 00:09:37,905
I mean, just look at IBSEC,

00:09:37,905 --> 00:09:40,483
like IBSEC dump, oh, there's all my keys.

00:09:40,483 --> 00:09:42,310
We're doing access SSH key, I mean we,

00:09:42,310 --> 00:09:43,980
there's tons of ways to exploit secrets now.

00:09:43,980 --> 00:09:46,610
Right like, saying that BPF was somehow

00:09:46,610 --> 00:09:48,530
as a privileged user is exploiting more secrets

00:09:48,530 --> 00:09:51,120
than every other system tool we have today

00:09:51,120 --> 00:09:54,777
that's has great privileges is, I think, a little bit much.

00:09:58,130 --> 00:10:00,240
But I get it, a solution that can respond.

00:10:00,240 --> 00:10:02,880
So, I think that this discussion is on point, right,

00:10:02,880 --> 00:10:04,629
(mumbling) maps more secure.

00:10:04,629 --> 00:10:06,450
So, I think the,

00:10:06,450 --> 00:10:08,390
my only kind of, I think the problem

00:10:08,390 --> 00:10:11,567
is maybe overstated and the solution's still good, so.

00:10:11,567 --> 00:10:15,490
- So, right now we have this discussion on capBPF.

00:10:15,490 --> 00:10:18,310
Introducing capBPF so that you don't need caps as admin

00:10:18,310 --> 00:10:19,900
but you have this.

00:10:19,900 --> 00:10:21,383
- But this still means that you have to

00:10:21,383 --> 00:10:24,120
grab to all daemons that need access to maps,

00:10:24,120 --> 00:10:26,530
so we would like to see more fine grained solution

00:10:26,530 --> 00:10:28,400
to protect daemons against each other.

00:10:28,400 --> 00:10:29,450
- Right.

00:10:29,450 --> 00:10:30,453
- I was just. - I would actually

00:10:30,453 --> 00:10:33,540
love to have some sort of a combination

00:10:33,540 --> 00:10:36,760
of cap, like some customizable,

00:10:36,760 --> 00:10:40,940
maybe cap thing where we could attach

00:10:40,940 --> 00:10:42,530
some policy to it, like (mumbles)

00:10:42,530 --> 00:10:45,950
and then it could only partially expose all

00:10:45,950 --> 00:10:47,710
the sub commands that BPF has.

00:10:47,710 --> 00:10:50,760
This would be great but, doesn't exist yet.

00:10:50,760 --> 00:10:54,155
Maybe we get there but (faint speaking)

00:10:54,155 --> 00:10:55,550
- [Audience Member 3] I was just thinking along

00:10:55,550 --> 00:10:57,290
the same lines as you guys that part of the problem

00:10:57,290 --> 00:11:00,270
is that BPF is not an information domain

00:11:00,270 --> 00:11:02,330
and all our security enforcement engines

00:11:02,330 --> 00:11:04,440
are not really aware of it.

00:11:04,440 --> 00:11:09,330
So, SE Linux, seConf, you know, appArmor, all those guys,

00:11:09,330 --> 00:11:12,920
don't know what this is and it's coming for the kernel

00:11:12,920 --> 00:11:14,990
and you'd like to say, yeah, you can do this

00:11:14,990 --> 00:11:15,990
but you can't do that.

00:11:15,990 --> 00:11:18,620
And so if you don't, I mean, kind of like

00:11:18,620 --> 00:11:20,910
we need to work together with those folks

00:11:20,910 --> 00:11:25,910
to get a general set up policies and mechanisms in place

00:11:25,930 --> 00:11:28,310
that work, otherwise, people are just gonna say

00:11:28,310 --> 00:11:32,730
either, I want it or I have to turn it off.

00:11:32,730 --> 00:11:34,457
- Yes, 100% agreed.

00:11:34,457 --> 00:11:36,810
- [Audience Member 4] A lot of these discussions in my mind

00:11:36,810 --> 00:11:38,670
always bring it back to wait,

00:11:38,670 --> 00:11:40,090
don't we have a file descriptor?

00:11:40,090 --> 00:11:42,700
Don't we have file system privileges?

00:11:42,700 --> 00:11:44,970
Can't we somehow integrate this traditional means

00:11:44,970 --> 00:11:47,360
by which we grant access to objects with this thing,

00:11:47,360 --> 00:11:51,130
so, BPF map, file descriptor, traditionally mixed

00:11:51,130 --> 00:11:53,630
permissions, give it to this daemon in this group.

00:11:54,565 --> 00:11:58,283
- Yeah, sounds that it could - I hope so, I hope so.

00:12:01,200 --> 00:12:06,200
- Okay, let's look at some other pain points of XDP.

00:12:09,310 --> 00:12:10,223
Three parts,

00:12:11,130 --> 00:12:14,560
pain points for users, for developers and for distros.

00:12:15,490 --> 00:12:20,490
So, for users, the pain point number one for users

00:12:21,200 --> 00:12:26,200
is that they heard about the nice new XDP thing,

00:12:26,750 --> 00:12:29,930
they want to try it out, so they want some package

00:12:29,930 --> 00:12:31,914
in the distribution to install it.

00:12:31,914 --> 00:12:33,520
(laughing)

00:12:33,520 --> 00:12:35,520
But they are none.

00:12:35,520 --> 00:12:37,730
So, that's one of the things

00:12:37,730 --> 00:12:39,790
but this will solve over time itself.

00:12:39,790 --> 00:12:42,223
Just nothing, this is something to expect.

00:12:44,050 --> 00:12:47,190
Another problem for users, a bit surprise for them,

00:12:47,190 --> 00:12:50,470
tcpdump does not see all packets.

00:12:50,470 --> 00:12:53,600
Now, if there is XDP_DROP, INIUS or something,

00:12:53,600 --> 00:12:56,250
this was discussed yesterday, so let me just skip it.

00:12:57,950 --> 00:13:00,730
Similar thing, the interface statistics,

00:13:00,730 --> 00:13:05,730
IP, IP or address show doesn't restore packets

00:13:08,640 --> 00:13:10,470
in the statistics.

00:13:10,470 --> 00:13:13,450
So this is really the similar thing to that.

00:13:13,450 --> 00:13:16,020
I think there have been some talks

00:13:16,020 --> 00:13:17,560
on - Yeah, we discussed it.

00:13:17,560 --> 00:13:19,860
The issue, the issue that gets raised

00:13:19,860 --> 00:13:24,860
is that should the counter bumps in XDP path

00:13:25,270 --> 00:13:28,990
be on by default because people want maximum performance

00:13:28,990 --> 00:13:30,820
any cache miss would be concerning?

00:13:30,820 --> 00:13:32,740
And we go back and forth about the (mumbles).

00:13:32,740 --> 00:13:36,770
Having them off by default would be insanely inconsistent

00:13:36,770 --> 00:13:38,520
with how the rest of the system works

00:13:38,520 --> 00:13:41,629
and for visibility by default is desirable.

00:13:41,629 --> 00:13:43,800
And people who wants good performance

00:13:43,800 --> 00:13:47,660
can turn off the statistics if that's appropriate for them.

00:13:47,660 --> 00:13:48,663
- Yeah. - Yeah,

00:13:48,663 --> 00:13:50,137
that might be a good solution.

00:13:50,137 --> 00:13:51,860
The real problem right now is that

00:13:51,860 --> 00:13:54,790
the different windows have different behaviors.

00:13:54,790 --> 00:13:56,963
So, some actually show up in the

00:13:56,963 --> 00:13:59,110
- U tool custom statistics?

00:13:59,110 --> 00:14:00,610
Yes. - Yeah, so some show up

00:14:00,610 --> 00:14:04,060
at the IF config or IP link stats,

00:14:04,060 --> 00:14:07,900
and some drivers don't and some, you actually have,

00:14:07,900 --> 00:14:10,680
it's still, actually, all of them still count

00:14:10,680 --> 00:14:13,580
the counters in some way or another.

00:14:13,580 --> 00:14:16,890
And often exported by HH tool stats,

00:14:16,890 --> 00:14:19,570
which is even more confusing.

00:14:19,570 --> 00:14:21,070
- So, yeah we need standardization

00:14:21,070 --> 00:14:22,090
before this gets more out of control.

00:14:22,090 --> 00:14:25,760
- So, so the go ahead issue of counting the packets

00:14:25,760 --> 00:14:27,830
but everybody does - Everyone's coming in arrays.

00:14:27,830 --> 00:14:28,710
There's no argument.

00:14:28,710 --> 00:14:29,543
- Yeah, so.

00:14:29,543 --> 00:14:30,376
- It's happening already.

00:14:30,376 --> 00:14:31,960
- But it's just carried in different places,

00:14:31,960 --> 00:14:32,880
which is a mess.

00:14:32,880 --> 00:14:33,963
- Yes, I agree.

00:14:36,610 --> 00:14:38,120
- Okay, thanks.

00:14:38,120 --> 00:14:43,120
And then , what we saw in practice

00:14:43,460 --> 00:14:46,960
is people, what I think XD program

00:14:46,960 --> 00:14:49,410
attention to your interface and then wondering, oh

00:14:49,410 --> 00:14:51,130
and then doing a benchmark and running,

00:14:51,130 --> 00:14:54,230
okay, it's not that fast as it was.

00:14:54,230 --> 00:14:58,613
And that's because for some reason, XDP generic

00:14:58,613 --> 00:15:01,791
was used instead of the driver XDP.

00:15:01,791 --> 00:15:03,676
So, this is something,

00:15:03,676 --> 00:15:06,560
it's probably a matter of education of the users.

00:15:06,560 --> 00:15:09,760
- Yeah, so, so the fallback that we thought was really smart

00:15:09,760 --> 00:15:12,450
that you just fall back to generic XDP,

00:15:12,450 --> 00:15:15,450
actually users are (mumbles) because people don't realize it

00:15:15,450 --> 00:15:17,480
and they don't realize it and

00:15:17,480 --> 00:15:19,599
- But and - it's just to see for people.

00:15:19,599 --> 00:15:22,090
- And there's also some small (mumbles) case sematic

00:15:22,090 --> 00:15:24,880
differences that we need to address at some point as well.

00:15:24,880 --> 00:15:28,470
So, but still, the fact that you can test

00:15:28,470 --> 00:15:31,960
and write XDP programs no matter what your system is

00:15:31,960 --> 00:15:34,830
is, I think a more important win

00:15:34,830 --> 00:15:38,230
than the confusion that, which is education issue, right?

00:15:38,230 --> 00:15:39,063
- Yeah.

00:15:39,063 --> 00:15:40,500
- I would actually recommend people not to use

00:15:40,500 --> 00:15:44,740
generic XDP and instead use the VETH support.

00:15:44,740 --> 00:15:46,750
- And that's what we do with our test cases, right?

00:15:46,750 --> 00:15:47,583
- Yeah. - Yeah.

00:15:47,583 --> 00:15:50,223
That's the test cases, that also my XDP tutorial.

00:15:51,190 --> 00:15:54,490
- But we have precedence that XDP always will show up, so,

00:15:54,490 --> 00:15:55,930
too late to take it off by default.

00:15:55,930 --> 00:15:57,220
- We cannot remove generic XDP

00:15:57,220 --> 00:16:00,600
but later slides, I have also issues with generic XDP

00:16:00,600 --> 00:16:01,570
that, excuse me,

00:16:01,570 --> 00:16:03,540
- Yeah, maybe having a flag that would cause

00:16:03,540 --> 00:16:05,900
not to fall back to XD generic.

00:16:05,900 --> 00:16:06,733
- You know what?

00:16:06,733 --> 00:16:08,820
There is a flag added for the metronome driver,

00:16:08,820 --> 00:16:12,250
which allowed you to have both hardware off loaded

00:16:12,250 --> 00:16:17,250
and non hardware off loaded XDP program at the same time.

00:16:17,360 --> 00:16:20,680
Right, so, the hardware one would execute

00:16:20,680 --> 00:16:22,090
and then it would pop it to the CPU

00:16:22,090 --> 00:16:23,860
and you'd do the CPU one and the driver

00:16:23,860 --> 00:16:25,870
and we could have one that could say, please,

00:16:25,870 --> 00:16:27,780
if XD, generic XP is the only option,

00:16:27,780 --> 00:16:29,500
please fail this operation.

00:16:29,500 --> 00:16:31,940
This XDP program - I think we support it.

00:16:31,940 --> 00:16:33,870
- I think we do too. - With the tutorial,

00:16:33,870 --> 00:16:37,311
I'm forcing native XDP and failing it

00:16:37,311 --> 00:16:39,354
when people are trying to - There's so many features,

00:16:39,354 --> 00:16:41,670
we don't know if we support it

00:16:41,670 --> 00:16:44,859
- Like a warning that this is not what you are expecting.

00:16:44,859 --> 00:16:45,764
- Do we support?

00:16:45,764 --> 00:16:48,167
I think we - I think we do support it.

00:16:48,167 --> 00:16:51,305
(chatter) - Okay.

00:16:51,305 --> 00:16:53,472
(chatter)

00:16:56,768 --> 00:16:59,239
- Okay. - Generic if it didn't work.

00:16:59,239 --> 00:17:00,080
- We can force it.

00:17:00,080 --> 00:17:04,355
If we load it as XDP - Okay, I'll work on this.

00:17:04,355 --> 00:17:05,660
Let's continue.

00:17:05,660 --> 00:17:07,060
- Please move on.

00:17:07,060 --> 00:17:08,690
- Yep.

00:17:08,690 --> 00:17:13,690
Now for developers, there are also some laptop battery low.

00:17:14,500 --> 00:17:15,423
- Oh my God.

00:17:16,360 --> 00:17:17,193
- Six minutes.

00:17:17,193 --> 00:17:19,860
That's not enough for our presentation. (laughing)

00:17:19,860 --> 00:17:20,890
- [Facilitator] You guys thought I gave you

00:17:20,890 --> 00:17:22,250
a big sign on this (mumbles)?

00:17:22,250 --> 00:17:25,029
- Yeah, someone's sabotaging. (laughing)

00:17:25,029 --> 00:17:26,210
- [Jasper] Yeah, this is a common

00:17:26,210 --> 00:17:27,410
developer experience problem.

00:17:27,410 --> 00:17:30,231
Low battery. (laughing)

00:17:30,231 --> 00:17:33,436
- Let's just the switch.

00:17:33,436 --> 00:17:35,420
(laughing) - That's an IBM problem.

00:17:35,420 --> 00:17:40,360
- So, one of the problems that the developer experience,

00:17:40,360 --> 00:17:45,177
developers experience is the XD programs

00:17:45,177 --> 00:17:50,177
that's are not really correct, not in a way

00:17:50,920 --> 00:17:52,340
that correctness, but in the way

00:17:52,340 --> 00:17:54,720
that they cannot really work

00:17:54,720 --> 00:17:57,697
on a particular interface with a particular features

00:17:57,697 --> 00:17:59,640
that's supported by the driver.

00:17:59,640 --> 00:18:02,937
They are accepted by the kernel.

00:18:02,937 --> 00:18:05,920
They are attached and during execution packets

00:18:05,920 --> 00:18:07,463
are signed to the DROP.

00:18:08,350 --> 00:18:10,670
So, this is something that Jasper will cover

00:18:10,670 --> 00:18:11,793
a bit more later.

00:18:13,432 --> 00:18:15,160
Another pain point for developers

00:18:15,160 --> 00:18:19,540
is that there's a perception that XDP is the holy grail

00:18:19,540 --> 00:18:21,370
to solve all problems.

00:18:21,370 --> 00:18:24,770
It might be in a few years but currently,

00:18:24,770 --> 00:18:27,360
it's still missing some fundamental features

00:18:27,360 --> 00:18:30,140
such as ability to duplicate packets

00:18:30,140 --> 00:18:34,423
or just redirect them to arbitrary interface,

00:18:35,500 --> 00:18:37,310
clone them and so on.

00:18:37,310 --> 00:18:42,060
So, we have actually already saw several attempts

00:18:42,060 --> 00:18:45,510
to implement a custom solution

00:18:45,510 --> 00:18:49,690
or usually some data plane using XDP into kernel,

00:18:49,690 --> 00:18:54,690
then the developers realize that they cannot really

00:18:54,830 --> 00:18:57,890
broadcast packets to multiple interfaces.

00:18:57,890 --> 00:19:02,890
So, they turned to AFXDP only to find out

00:19:02,965 --> 00:19:06,750
that the performance using XDP is not what they wanted

00:19:06,750 --> 00:19:09,527
because of various other problems

00:19:09,527 --> 00:19:13,013
that we will not have time to cover in this talk.

00:19:15,520 --> 00:19:20,520
Another pain point, Verifier is quite good at rejecting

00:19:21,660 --> 00:19:24,280
programs that are really valid

00:19:24,280 --> 00:19:27,450
because it cannot verify them as correct.

00:19:27,450 --> 00:19:31,310
And this is of course, the correct behavior of the Verifier.

00:19:31,310 --> 00:19:35,070
If it cannot decide, it needs to re check the programs.

00:19:35,070 --> 00:19:38,550
But quite often, development of XDP programs

00:19:38,550 --> 00:19:40,990
means re writing the program again and again

00:19:40,990 --> 00:19:44,170
until the Verifier likes the program,

00:19:44,170 --> 00:19:45,423
which is painful.

00:19:47,280 --> 00:19:50,250
Now, for - Do you have some examples?

00:19:50,250 --> 00:19:52,140
Or like, I think what would help

00:19:52,140 --> 00:19:56,500
would be to somehow make, or someone was starting

00:19:56,500 --> 00:19:58,670
this discussion on some of those features,

00:19:58,670 --> 00:20:02,170
like if the verifier could potentially be extended

00:20:02,170 --> 00:20:05,260
to support them if it's verifiable.

00:20:05,260 --> 00:20:08,742
- So, what's the best way to send that to you?

00:20:08,742 --> 00:20:09,575
Just on

00:20:09,575 --> 00:20:10,566
- I mean, like BPS mailing list or something.

00:20:10,566 --> 00:20:12,149
- Yeah, okay, yeah.

00:20:14,040 --> 00:20:16,350
- I think for the developer experiences,

00:20:16,350 --> 00:20:19,810
also that the Verifier is actually correct

00:20:19,810 --> 00:20:20,980
and reject the program.

00:20:20,980 --> 00:20:23,510
But it works on your particular figure

00:20:23,510 --> 00:20:25,270
what bad code it is so, for developer,

00:20:25,270 --> 00:20:27,490
you have to do this iterative process

00:20:27,490 --> 00:20:29,320
of having to test it all the time

00:20:29,320 --> 00:20:30,960
because you will screw up and you don't

00:20:30,960 --> 00:20:31,840
do your bandwidth checks

00:20:31,840 --> 00:20:34,027
so that's the Verifier is straight.

00:20:34,027 --> 00:20:36,230
For all my bandwidth checks, I send it to you

00:20:36,230 --> 00:20:38,820
and you said, no, Jasper, you're actually,

00:20:38,820 --> 00:20:40,630
your code sucks because the Verifier saw

00:20:40,630 --> 00:20:44,170
that your bandwidth (mumbles) last year, yes.

00:20:44,170 --> 00:20:45,003
- Yeah, it's true.

00:20:45,003 --> 00:20:46,460
I think it's gotten better over time with the

00:20:46,460 --> 00:20:48,336
C imitation maybe but

00:20:48,336 --> 00:20:49,550
- Ya, the CM's taking care of a lot

00:20:49,550 --> 00:20:51,190
because people had very hard time

00:20:51,190 --> 00:20:53,470
finding back when bike loads is wrong

00:20:53,470 --> 00:20:54,960
and then you have to bike load them as well.

00:20:54,960 --> 00:20:56,637
I don't know what this bike load means.

00:20:56,637 --> 00:20:58,870
I go to C program.

00:20:58,870 --> 00:21:01,880
- We're used to when it compiles, it's done, right?

00:21:01,880 --> 00:21:02,713
- Exactly.

00:21:04,740 --> 00:21:06,940
- So, and for distribution, there,

00:21:06,940 --> 00:21:08,610
we have three slides for that actually.

00:21:08,610 --> 00:21:11,550
So, we probably won't have that much time

00:21:11,550 --> 00:21:14,743
to go through all of that but let's see.

00:21:16,380 --> 00:21:19,500
Problem number one that we're facing at this moment is

00:21:21,934 --> 00:21:25,740
category example, we have in the future, not now,

00:21:25,740 --> 00:21:28,220
let's say, let's assume we have several packages

00:21:28,220 --> 00:21:30,570
that all make use of XDP.

00:21:30,570 --> 00:21:32,653
And now the customer wants them all.

00:21:34,040 --> 00:21:39,040
And the problem is that XDP allows only one program

00:21:39,120 --> 00:21:41,890
to be loaded to a particular interface.

00:21:41,890 --> 00:21:45,000
So, now, the packages are fighting with each other.

00:21:45,000 --> 00:21:49,370
Or similar problem, user writes his own XDP program to do,

00:21:49,370 --> 00:21:52,110
for example, some filtering or such

00:21:52,110 --> 00:21:55,810
and then installs a package that makes use of XDP.

00:21:55,810 --> 00:21:59,353
Maybe even without the user knowing that.

00:22:00,240 --> 00:22:03,143
Because the expectation is that in the future,

00:22:04,270 --> 00:22:07,900
more packages will take, make use of XDP functionality,

00:22:07,900 --> 00:22:10,063
system D already does, for example.

00:22:11,700 --> 00:22:14,020
So, this is a big problem.

00:22:14,020 --> 00:22:15,240
And this needs to be solved.

00:22:15,240 --> 00:22:19,423
This is what Tokay will talk about in a few minutes.

00:22:21,400 --> 00:22:26,170
Another thing that we encountered was the

00:22:26,170 --> 00:22:30,540
was the problems on other architectures than just X8684.

00:22:30,540 --> 00:22:33,973
It seems that very few people, if someone at all

00:22:33,973 --> 00:22:38,853
will test these features on our architectures.

00:22:41,310 --> 00:22:46,032
Another problem we see is a risk of fragmentation.

00:22:46,032 --> 00:22:50,650
Right now, iproute is using its own BPF loader library.

00:22:50,650 --> 00:22:52,370
We have libpbf.

00:22:52,370 --> 00:22:54,390
I think, I'm not sure if it is Cilium.

00:22:54,390 --> 00:22:57,850
I think Cilium is using its own solution as well.

00:22:57,850 --> 00:22:59,980
So, (laughing)

00:22:59,980 --> 00:23:01,810
- [Tokay] So in Cilium right now,

00:23:01,810 --> 00:23:04,260
we're using the iproute tool

00:23:04,260 --> 00:23:05,913
program loader. - Okay, okay.

00:23:08,610 --> 00:23:10,830
- In future, it might change.

00:23:10,830 --> 00:23:12,630
I mean, so, right now, there's some effort

00:23:12,630 --> 00:23:15,620
to actually bring the BPF into iproute too,

00:23:15,620 --> 00:23:18,850
and that would, I mean, the goal long term

00:23:18,850 --> 00:23:23,850
is to have ideally libbpf as a common thing

00:23:25,183 --> 00:23:27,813
that everyone would rely on.

00:23:29,140 --> 00:23:32,430
And then also the behavior of loading the program

00:23:32,430 --> 00:23:34,120
would be the same.

00:23:34,120 --> 00:23:35,370
So that would be ideal.

00:23:35,370 --> 00:23:37,520
- Yeah, and that's what we like to see too.

00:23:40,920 --> 00:23:43,353
So, let's pick the BPF has the solution.

00:23:44,360 --> 00:23:47,070
It has problems of its own.

00:23:47,070 --> 00:23:51,960
So, the API is not really that much stable,

00:23:51,960 --> 00:23:53,480
at least to our experience.

00:23:53,480 --> 00:23:56,420
I think this is just a matter of time

00:23:56,420 --> 00:23:58,200
until it's stabilized completely.

00:23:58,200 --> 00:24:01,330
But right now, it's a bit challenging

00:24:01,330 --> 00:24:03,860
to really include it in distribution

00:24:03,860 --> 00:24:07,623
and support users on distribution upgrades.

00:24:10,110 --> 00:24:12,970
Another problem that we hate is that libbpf

00:24:12,970 --> 00:24:17,970
being part of the kernel means that

00:24:18,220 --> 00:24:20,400
when building, when packaging it,

00:24:20,400 --> 00:24:23,730
it's packaged out of the kernel source code,

00:24:23,730 --> 00:24:26,550
which means the library version or the package version

00:24:26,550 --> 00:24:31,550
is the kernel version, which in case we update the kernel,

00:24:31,950 --> 00:24:35,713
for example, the, for the stable tree,

00:24:35,713 --> 00:24:40,713
and the the libbpf did not change its version,

00:24:41,530 --> 00:24:43,360
the package version changes.

00:24:43,360 --> 00:24:46,133
And it needs to be updated unnecessarily.

00:24:47,677 --> 00:24:50,433
There is a libbpf repo on Github.

00:24:51,680 --> 00:24:56,680
That is basically a sync of the in kernel library,

00:24:56,870 --> 00:24:59,800
to a standalone project.

00:24:59,800 --> 00:25:02,600
So, we're currently thinking and we're fusing that.

00:25:02,600 --> 00:25:06,680
The question is, of course, how much we can rely

00:25:06,680 --> 00:25:09,347
on this being available long term.

00:25:09,347 --> 00:25:11,500
- [Audience Member 2] One thing that would be really useful

00:25:11,500 --> 00:25:13,160
for that. - He has a microphone.

00:25:13,160 --> 00:25:13,993
- I have one.

00:25:13,993 --> 00:25:14,848
I'm wearing one.

00:25:14,848 --> 00:25:15,950
(laughing) but I can do, yeah

00:25:17,260 --> 00:25:22,260
is, if there's a way to sync, I guess,

00:25:23,500 --> 00:25:25,710
I don't think there's any versions on the Github versions.

00:25:25,710 --> 00:25:27,880
So, there's no version tax.

00:25:27,880 --> 00:25:31,820
So we sort of have to look at the (mumbles)

00:25:31,820 --> 00:25:33,470
which does this actually correspond to,

00:25:33,470 --> 00:25:35,970
so having releases of that,

00:25:35,970 --> 00:25:38,580
maybe just corresponding to the kernel versions.

00:25:38,580 --> 00:25:40,380
- So, I don't know how you do it in Rail.

00:25:40,380 --> 00:25:44,278
Like the libbpf has a version.

00:25:44,278 --> 00:25:47,500
I think right now, it's 005 or something

00:25:47,500 --> 00:25:50,700
and we bump it with every new development cycle.

00:25:50,700 --> 00:25:54,060
- Yes, just tag that in Git as well so we can find them.

00:25:54,060 --> 00:25:55,440
- Yeah, that's a good point.

00:25:55,440 --> 00:25:58,721
Because but also, I think the way you do it is you bump

00:25:58,721 --> 00:26:02,900
in the definition file, you bump the data SO version

00:26:02,900 --> 00:26:06,090
and then for the whole cycle, that is being modified.

00:26:06,090 --> 00:26:08,860
So, its actually the second to newest version

00:26:08,860 --> 00:26:09,960
that's the shippable one.

00:26:09,960 --> 00:26:13,918
So just by having this explicit in the repository.

00:26:13,918 --> 00:26:14,751
This is, the 005 is fine.

00:26:16,504 --> 00:26:18,703
It's not like just having something there.

00:26:21,230 --> 00:26:23,830
- You can imagine that these problems are the reason

00:26:23,830 --> 00:26:26,323
why people are like, oh, I'm just gonna (mumbles)

00:26:26,323 --> 00:26:28,140
a copy of libbpf into my tree.

00:26:28,140 --> 00:26:30,480
- And this what we hate actually.

00:26:30,480 --> 00:26:35,070
- Yes, so, please get past all of these problems.

00:26:35,070 --> 00:26:36,890
And don't do that.

00:26:36,890 --> 00:26:39,260
- I think the biggest problem with the copy

00:26:39,260 --> 00:26:43,140
in your own tree, I mean, I don't really think personally,

00:26:43,140 --> 00:26:44,970
it's too much of a big problem

00:26:44,970 --> 00:26:49,260
but it's rather like distros.

00:26:50,210 --> 00:26:52,230
I mean, for example, like Ubuntu,

00:26:52,230 --> 00:26:55,280
they just shipped bpftool right now,

00:26:55,280 --> 00:26:58,690
and it already exists for you for a couple of years, right?

00:26:58,690 --> 00:27:01,360
So, it's just super super slow.

00:27:01,360 --> 00:27:04,887
That's and if you like the pahole,

00:27:04,887 --> 00:27:07,643
and I think it's also BCC tools.

00:27:08,620 --> 00:27:12,530
They pull in a copy because they can use the features

00:27:12,530 --> 00:27:16,280
right now with this kernel if they do so, right?

00:27:16,280 --> 00:27:19,250
So, it's like a pro and con, right?

00:27:19,250 --> 00:27:22,960
- The problem it's against most distros policy

00:27:22,960 --> 00:27:24,440
for obvious reasons.

00:27:24,440 --> 00:27:28,070
You don't want to have one library in system multiple times

00:27:28,070 --> 00:27:30,250
because if there is security work,

00:27:30,250 --> 00:27:32,165
you have to fix it in multiple places.

00:27:32,165 --> 00:27:33,720
- I was gonna say the same thing.

00:27:33,720 --> 00:27:35,740
Like, do we do this with crypto libraries?

00:27:35,740 --> 00:27:37,240
No.

00:27:37,240 --> 00:27:40,630
Because if you gotta fix a bug, you want it fixed.

00:27:40,630 --> 00:27:41,627
- Yeah, just like regular bugs as well.

00:27:41,627 --> 00:27:44,270
There was just one, I send a patch yesterday,

00:27:44,270 --> 00:27:45,820
if it doesn't work with the old kernels

00:27:45,820 --> 00:27:47,910
and then you have to go around and

00:27:47,910 --> 00:27:49,083
- Hit all the cases.

00:27:50,670 --> 00:27:53,600
- Yeah, I wish distributions would be faster

00:27:53,600 --> 00:27:55,750
in adapting the stuff, so.

00:27:55,750 --> 00:27:56,817
I think that's a big. - It can get difficult.

00:27:56,817 --> 00:27:58,760
That's what this discussion is about.

00:27:58,760 --> 00:28:00,610
- Yeah, one of the problem bytes not faster

00:28:00,610 --> 00:28:05,160
is that the development is really fast and changes

00:28:05,160 --> 00:28:10,160
quite a lot, so distros probably tend

00:28:10,480 --> 00:28:13,070
to take a bit conservative approach and to

00:28:15,680 --> 00:28:20,680
stabilize a particular version and not try update too fast.

00:28:20,820 --> 00:28:22,510
- And if you think about it, there is a matrix

00:28:22,510 --> 00:28:24,670
getting created if you're suggesting

00:28:24,670 --> 00:28:26,580
that you would use the libbpf repo

00:28:26,580 --> 00:28:28,530
because then you need a stable branch.

00:28:28,530 --> 00:28:30,431
- Yes that was my, going to be my (chuckles)

00:28:30,431 --> 00:28:31,580
- [David] And it would be great to have.

00:28:31,580 --> 00:28:33,640
- Right, but then there's this,

00:28:33,640 --> 00:28:36,610
now all of us developers have to manage two copies

00:28:36,610 --> 00:28:39,440
two copies in the kernel stable branch and

00:28:39,440 --> 00:28:43,190
our bug fixes to libbpf, they're generally being sent

00:28:43,190 --> 00:28:45,150
to the the stable. - Stable.

00:28:45,150 --> 00:28:46,210
- They're a big part of this.

00:28:46,210 --> 00:28:47,750
- Yeah, I think so.

00:28:47,750 --> 00:28:48,860
- All right.

00:28:48,860 --> 00:28:51,041
So, we're gonna package it from the kernel.

00:28:51,041 --> 00:28:52,540
(chuckles)

00:28:52,540 --> 00:28:54,110
- Cool.

00:28:54,110 --> 00:28:59,110
So, and also there's the pahole,

00:28:59,310 --> 00:29:04,310
which, it's a bit weird to have this functionality

00:29:04,800 --> 00:29:05,750
in this tool.

00:29:05,750 --> 00:29:08,950
So, maybe for, this is mostly for developers

00:29:08,950 --> 00:29:10,240
and user's perception.

00:29:10,240 --> 00:29:12,540
Maybe splitting that out to a different tool,

00:29:12,540 --> 00:29:16,040
maybe in the same package might be more useful.

00:29:16,040 --> 00:29:17,907
On the other hand, it might not be issue in the future

00:29:17,907 --> 00:29:21,547
when they have proper BPF support and GCC and CON

00:29:21,547 --> 00:29:25,150
and then we will not need pahole anymore.

00:29:25,150 --> 00:29:27,530
So, yeah. - and I think right now,

00:29:27,530 --> 00:29:28,700
probably Yung Huang knows better

00:29:28,700 --> 00:29:31,150
but the kernel actually relies on pahole

00:29:32,520 --> 00:29:36,570
to have this PTF conversion like 12 two BTF.

00:29:36,570 --> 00:29:39,320
Because if you would compile the kernel with BTF,

00:29:39,320 --> 00:29:42,730
debugging enabled, then it would convert it.

00:29:42,730 --> 00:29:47,730
So, ripping it out might be an issue in that sense.

00:29:48,864 --> 00:29:51,530
(faint speaking)

00:29:51,530 --> 00:29:55,290
- The functionality already in the latest BPF NICs,

00:29:55,290 --> 00:29:57,150
single NICs as well.

00:29:57,150 --> 00:30:00,530
And so, basically as well, you have latest pahole

00:30:00,530 --> 00:30:03,690
and like, one pole and 70 series,

00:30:03,690 --> 00:30:06,480
something like that, 173 version.

00:30:06,480 --> 00:30:10,950
And also if you enable the BTF with debugging for

00:30:10,950 --> 00:30:15,460
and it will automatically place the binary blob of a BTF

00:30:15,460 --> 00:30:19,680
in this kernel or BTF directory

00:30:19,680 --> 00:30:21,670
and so you don't need to do anything.

00:30:21,670 --> 00:30:23,620
It's just seeing that fix the location.

00:30:26,399 --> 00:30:27,232
- Okay.

00:30:28,490 --> 00:30:29,633
- Just a teaser.

00:30:31,716 --> 00:30:32,770
(laughing)

00:30:32,770 --> 00:30:34,740
There's another talk in the other track

00:30:34,740 --> 00:30:39,160
on the GCC support for the CFT because

00:30:39,160 --> 00:30:41,590
it looks like the tool chain people

00:30:41,590 --> 00:30:44,510
feel there is a greater adoption of the originals

00:30:44,510 --> 00:30:48,490
on CDF within the user running software.

00:30:48,490 --> 00:30:51,073
So, it looks like they are not yet looking at GCC,

00:30:51,073 --> 00:30:54,410
generic BTF but rather CDF.

00:30:54,410 --> 00:30:56,020
To me, that means that we will probably need

00:30:56,020 --> 00:30:58,050
to talk more with the tool chain folks

00:30:58,050 --> 00:31:00,360
about why we are using BTF and not CDF

00:31:00,360 --> 00:31:02,860
and how to merge together in order to ger GCC

00:31:02,860 --> 00:31:03,963
generated directly.

00:31:05,727 --> 00:31:09,291
Thanks. - Okay.

00:31:09,291 --> 00:31:10,124
- [Audience Member 5] Just one thing.

00:31:10,124 --> 00:31:12,630
Considering that we are doing a builds with clients,

00:31:12,630 --> 00:31:17,630
and that GCC, we don't want to build the BTF experience

00:31:17,720 --> 00:31:21,210
into a single compositor and replicate it across

00:31:21,210 --> 00:31:22,373
multiple tools chains.

00:31:28,493 --> 00:31:29,326
- Okay.

00:31:31,660 --> 00:31:35,760
Yeah, and the third slide about distros experience problems,

00:31:35,760 --> 00:31:38,970
it's more about future thoughts.

00:31:38,970 --> 00:31:42,680
We were talking about the, we were talking with the

00:31:42,680 --> 00:31:44,813
virtualization developers.

00:31:45,660 --> 00:31:50,180
And one thing that would be nice to have

00:31:50,180 --> 00:31:55,180
and would improve the overall experience

00:31:55,824 --> 00:32:00,824
for, I would say, tools and solutions built

00:32:00,950 --> 00:32:04,694
on top of distribution and packaging distribution.

00:32:04,694 --> 00:32:06,480
It is of course, virtualization's better

00:32:06,480 --> 00:32:08,480
because virtualization supports for XDP.

00:32:09,410 --> 00:32:12,460
So, (mumbles) does support XDP currently.

00:32:12,460 --> 00:32:14,360
The support is there but the performance

00:32:14,360 --> 00:32:16,950
is not as good as it could be.

00:32:16,950 --> 00:32:21,760
So, things like having XDP passthrough would be nice,

00:32:21,760 --> 00:32:25,130
which means executing the (mumbles) not in the guest

00:32:25,130 --> 00:32:28,640
but in the host on behalf of the guest.

00:32:28,640 --> 00:32:32,800
Or even off loading XDP right to the hardware

00:32:32,800 --> 00:32:36,870
would be nice but then we are facing some problems with

00:32:36,870 --> 00:32:40,580
VM retribution migrations when we need to ensure

00:32:40,580 --> 00:32:43,820
that the features on the new machine

00:32:43,820 --> 00:32:47,000
really match the features on the old machine.

00:32:47,000 --> 00:32:48,880
So, we are back in the feature problem,

00:32:48,880 --> 00:32:50,120
which - We've been talking

00:32:50,120 --> 00:32:52,490
about passthrough for the past two or three years.

00:32:52,490 --> 00:32:55,103
It's an old idea but it's nit easy to implement.

00:32:58,600 --> 00:33:01,810
- Now, there are some problems, which are already problems

00:33:01,810 --> 00:33:05,600
of the user expectation and user perception,

00:33:05,600 --> 00:33:07,500
so this is is fixable and this is mostly

00:33:07,500 --> 00:33:09,723
for the distributions to do, I'd say.

00:33:10,640 --> 00:33:13,050
One thing, XDP has really strong marketing.

00:33:13,050 --> 00:33:17,730
Everyone wants XDP, which is nice.

00:33:17,730 --> 00:33:21,100
But then the disappointment comes as I talk about

00:33:21,100 --> 00:33:23,863
there are no ready to solutions at this moment.

00:33:25,440 --> 00:33:30,393
And when someone talks, someone thinks okay, let's do.

00:33:31,360 --> 00:33:34,490
I will take this opportunity and develop my own solution,

00:33:34,490 --> 00:33:36,370
which everyone will use.

00:33:36,370 --> 00:33:41,370
Then they usually are stopped by lack of features

00:33:41,400 --> 00:33:42,433
at this point.

00:33:43,530 --> 00:33:47,550
Then they turn to AF_XDP and I already covered the rest.

00:33:47,550 --> 00:33:52,550
So, right now, what makes most sense

00:33:52,900 --> 00:33:56,710
to me or to us, is to, for distributions

00:33:56,710 --> 00:34:01,710
to focus, not on end users of XDP, but on developers.

00:34:01,890 --> 00:34:06,890
Enable them to write best or good useful XDP

00:34:07,380 --> 00:34:09,793
or BPF based solutions.

00:34:10,890 --> 00:34:14,300
For that, we need more examples for developers.

00:34:14,300 --> 00:34:17,720
We need some best practices covered

00:34:17,720 --> 00:34:20,600
in developing BPF programs on XDP.

00:34:20,600 --> 00:34:23,300
We need better education about limitations

00:34:23,300 --> 00:34:27,380
how to work around them or how to work with upstream

00:34:27,380 --> 00:34:29,923
to lift those limitations.

00:34:32,900 --> 00:34:36,570
Those guys, (mumbles) already started that.

00:34:36,570 --> 00:34:38,760
So, there is a Github XD project.

00:34:38,760 --> 00:34:43,200
It contends to sub projects, XDP tutorial,

00:34:43,200 --> 00:34:47,930
which is a good starting point for developing

00:34:47,930 --> 00:34:50,500
your own XD programs.

00:34:50,500 --> 00:34:53,690
Might be good idea to actually package this

00:34:53,690 --> 00:34:57,950
in distributions, to be easy consumable by people,

00:34:57,950 --> 00:34:59,480
by developers.

00:34:59,480 --> 00:35:04,423
And there's also XDP tools currently a work in progress,

00:35:06,030 --> 00:35:09,730
which is supposed to contain tools

00:35:09,730 --> 00:35:13,440
that are directly usable initially for simple use cases.

00:35:13,440 --> 00:35:15,763
Later, maybe for even difficult ones.

00:35:17,030 --> 00:35:18,843
So, thanks.

00:35:20,217 --> 00:35:21,513
With that. - All right.

00:35:22,810 --> 00:35:23,853
- Okay. - Thank you.

00:35:25,497 --> 00:35:27,410
You guys didn't really think we were just gonna

00:35:27,410 --> 00:35:28,580
be an hour, right?

00:35:28,580 --> 00:35:30,530
So, so long we're asking the speaker change,

00:35:30,530 --> 00:35:32,430
I'll ask the heresy question.

00:35:32,430 --> 00:35:35,630
Why not rip the libbpf out of the kernel tree

00:35:35,630 --> 00:35:37,800
and make it an external library?

00:35:37,800 --> 00:35:39,860
Forcing kernel developers to think about

00:35:39,860 --> 00:35:42,293
user experience perspectives?

00:35:45,053 --> 00:35:47,220
(chatter)

00:35:48,710 --> 00:35:50,280
It really comes down to things like,

00:35:50,280 --> 00:35:52,173
API is disappearing and stuff.

00:35:57,320 --> 00:35:58,450
- It's a good question.

00:35:58,450 --> 00:35:59,350
It could be done.

00:35:59,350 --> 00:36:00,880
On the other hand, it's already there

00:36:00,880 --> 00:36:04,150
and now, like from the story good point of view

00:36:05,690 --> 00:36:09,333
that's the basis where people contribute to.

00:36:12,870 --> 00:36:13,810
If you would rip it out,

00:36:13,810 --> 00:36:14,797
then again, we would have problems.

00:36:14,797 --> 00:36:17,300
So, I guess with bpftool and others

00:36:17,300 --> 00:36:20,280
that how to build it and it's,

00:36:20,280 --> 00:36:23,050
would maybe slow things down.

00:36:23,050 --> 00:36:27,610
And, I mean, in terms of debugging and, you know.

00:36:27,610 --> 00:36:30,010
- So, what we've done is we've made it

00:36:30,010 --> 00:36:33,370
the dependency situation's simpler inside the kernel.

00:36:33,370 --> 00:36:36,262
And as a result, it's more difficult outside the kernel.

00:36:36,262 --> 00:36:37,420
- [Audience Member 2] Are we at a point that

00:36:37,420 --> 00:36:39,290
outside the kernel becomes more important?

00:36:39,290 --> 00:36:40,890
- So, I think what happened was like

00:36:40,890 --> 00:36:42,548
perf set the precedence.

00:36:42,548 --> 00:36:44,093
- [Audience Member 2] And that was a bad process.

00:36:45,660 --> 00:36:48,000
There is not kernel dependency between perf

00:36:48,000 --> 00:36:50,040
like distribution to make an appearance

00:36:50,040 --> 00:36:52,710
of because it's (mumbles) - I agree.

00:36:52,710 --> 00:36:55,350
Just, it just means that deploying a new kernel feature

00:36:55,350 --> 00:36:58,100
is so much more barbaric and time consuming.

00:36:58,100 --> 00:37:00,401
If you've got this external thing, you've gotta

00:37:00,401 --> 00:37:01,960
- [Audience Member 2] That's where it's a kernel perspective

00:37:01,960 --> 00:37:03,760
versus a user perspective.

00:37:03,760 --> 00:37:05,970
And at some point, - I mean,

00:37:05,970 --> 00:37:08,190
I mean, that's sort of the trade off

00:37:08,190 --> 00:37:11,950
that out of tree repository is solving, right.

00:37:11,950 --> 00:37:15,420
So, people can use that for building it

00:37:15,420 --> 00:37:18,990
and but like the main development and everything happens

00:37:18,990 --> 00:37:22,340
upstream and also all the features that people implement

00:37:22,340 --> 00:37:25,650
can be up streamed along with their brush sets.

00:37:25,650 --> 00:37:26,850
So everything is there, right.

00:37:26,850 --> 00:37:31,850
So it's also convenient for progress in that sense, so.

00:37:32,010 --> 00:37:32,843
- And that's why I say it's convenient

00:37:32,843 --> 00:37:35,340
for kernel developers and convenient for users.

00:37:35,340 --> 00:37:36,840
- [Facilitator] But the correct question is

00:37:36,840 --> 00:37:39,460
does this replication into a Github repositories

00:37:39,460 --> 00:37:40,313
make you happy?

00:37:41,440 --> 00:37:43,160
- I ended up copying it into my tree

00:37:43,160 --> 00:37:45,330
because it was the easiest thing to do.

00:37:45,330 --> 00:37:46,600
It is a bit of a pain in the butt.

00:37:46,600 --> 00:37:47,990
- [Facilitator] Can you answer my question.

00:37:47,990 --> 00:37:49,890
Is the replication to a Github repository

00:37:49,890 --> 00:37:51,870
solving the problem?

00:37:51,870 --> 00:37:53,320
- That's for, I guess, the distribution.

00:37:53,320 --> 00:37:56,734
- But then, yeah, again, - It's part (mumbles)

00:37:56,734 --> 00:37:58,200
it's like channel of the staple thing.

00:37:58,200 --> 00:38:00,100
But a lot of that is automated, right?

00:38:00,100 --> 00:38:02,580
So, we should automate it to also

00:38:02,580 --> 00:38:05,210
branch off stable trees or they, as,

00:38:05,210 --> 00:38:06,923
I think there's potential to solve it that way.

00:38:06,923 --> 00:38:08,860
- [Tokay] I think so too.

00:38:08,860 --> 00:38:10,360
- Yeah.

00:38:10,360 --> 00:38:13,610
Yeah, I mean the problem is you want to start using it.

00:38:13,610 --> 00:38:15,740
Distro doesn't have it, so you have right now,

00:38:15,740 --> 00:38:17,380
to pull this thing in, right?

00:38:17,380 --> 00:38:21,890
Until the distros catch up and actually release libbpf

00:38:21,890 --> 00:38:23,410
along with the kernel version,

00:38:23,410 --> 00:38:26,480
so that's always in sync, like epiro 2 for example.

00:38:27,543 --> 00:38:29,854
- But that's, you have that problem with the kernel as well,

00:38:29,854 --> 00:38:30,687
right?

00:38:30,687 --> 00:38:32,857
You need a new kernel to be able to get

00:38:32,857 --> 00:38:35,980
into a lot of the features. - Yeah.

00:38:35,980 --> 00:38:37,910
But it should also work backwards, right?

00:38:37,910 --> 00:38:40,300
So, just because you've updated the kernel,

00:38:40,300 --> 00:38:42,140
doesn't mean libbpf stopped.

00:38:42,140 --> 00:38:42,973
Or if you update libbpf,

00:38:42,973 --> 00:38:45,450
but you still work in your old kernels,

00:38:45,450 --> 00:38:47,633
and with the way it's being done now,

00:38:47,633 --> 00:38:50,960
I think there's some gaping holes that are not

00:38:50,960 --> 00:38:53,110
that's not being consistently done exactly.

00:38:56,970 --> 00:38:57,803
All right.

00:38:57,803 --> 00:38:58,636
Moving on?

00:38:58,636 --> 00:38:59,469
- Yes. - Yes.

00:38:59,469 --> 00:39:02,987
So, as Gary said, now we come to the solutions.

00:39:02,987 --> 00:39:05,190
(chuckling)

00:39:05,190 --> 00:39:07,700
and one of the things that we wanted to talk about

00:39:07,700 --> 00:39:11,440
is this Multiple XDP programs on a single interface.

00:39:11,440 --> 00:39:13,443
And as I (mumbles) there's already people doing this.

00:39:13,443 --> 00:39:16,530
So this is more trying to convert general solution

00:39:16,530 --> 00:39:18,250
that can solve everybody's problems.

00:39:18,250 --> 00:39:22,880
We can get, agree to do it the same way.

00:39:22,880 --> 00:39:27,410
So, as we already heard, we can only run one program

00:39:27,410 --> 00:39:28,950
on each interface.

00:39:28,950 --> 00:39:31,730
So, if we want to have multiple functions in sequence,

00:39:31,730 --> 00:39:33,020
this can just be debugging.

00:39:33,020 --> 00:39:36,290
We want to catch to dump the packets before all our

00:39:36,290 --> 00:39:39,340
weird XDP programs starts strings to them.

00:39:39,340 --> 00:39:41,860
Or if we have different, like we have DDOS filter

00:39:41,860 --> 00:39:44,830
and then we have a IDS and then we have a routing thing

00:39:44,830 --> 00:39:47,660
and they're all XDP accelerated.

00:39:47,660 --> 00:39:49,933
We probably want to be able to compost them.

00:39:52,470 --> 00:39:55,150
And we can do that today if we control all the XDP programs.

00:39:55,150 --> 00:39:58,483
I'll show some examples of how this is already being done.

00:40:00,870 --> 00:40:02,610
But that's not necessarily enough.

00:40:02,610 --> 00:40:03,590
I come back to that.

00:40:03,590 --> 00:40:07,550
So, I've found two pieces of prior art.

00:40:07,550 --> 00:40:10,287
One is a Facebook Katran Longbantze

00:40:11,250 --> 00:40:14,220
has this mechanism for multi-program loading.

00:40:14,220 --> 00:40:17,730
So, these are the two XDP programs

00:40:17,730 --> 00:40:19,940
that would run in sequence.

00:40:19,940 --> 00:40:21,310
Usually, they would also do something.

00:40:21,310 --> 00:40:23,990
But this is to so, the first one,

00:40:23,990 --> 00:40:27,270
we can see loops from Suro in this array.

00:40:27,270 --> 00:40:29,870
The route array, which is an array of,

00:40:29,870 --> 00:40:31,913
it's a territory map and then array of programs.

00:40:31,913 --> 00:40:35,870
So, a loop form Suro and if the tail call proceeds,

00:40:35,870 --> 00:40:37,540
it's not going to return.

00:40:37,540 --> 00:40:39,920
So what this does is it goes with the array

00:40:39,920 --> 00:40:41,803
until it finds an index that contains a program

00:40:41,803 --> 00:40:43,310
that it can tail according to.

00:40:43,310 --> 00:40:46,770
And if it doesn't find anything, it just does XDP paths.

00:40:46,770 --> 00:40:49,570
So, then the second program will be in this array

00:40:49,570 --> 00:40:50,980
at index zero.

00:40:50,980 --> 00:40:52,820
So, the tail call in the first one,

00:40:52,820 --> 00:40:55,750
is going to end up tail calling into the second one.

00:40:55,750 --> 00:40:58,900
And as you can see, that starts as I equals one.

00:40:58,900 --> 00:41:00,910
So, that's not going to tail call into itself.

00:41:00,910 --> 00:41:03,780
Because it sits at index zero.

00:41:03,780 --> 00:41:05,527
But it's going to continue in the same array.

00:41:05,527 --> 00:41:08,253
So, the array becomes your execution sequence.

00:41:09,710 --> 00:41:11,970
The good thing about this is you can have multiple programs

00:41:11,970 --> 00:41:12,960
in just one map.

00:41:12,960 --> 00:41:16,620
You just put them into the map in the sequence you want.

00:41:16,620 --> 00:41:19,210
But the problem is that the programs

00:41:19,210 --> 00:41:21,950
need to know their position in the array.

00:41:21,950 --> 00:41:23,820
So, you need to recompile the programs.

00:41:23,820 --> 00:41:26,020
And obviously, you need to have this loop in there

00:41:26,020 --> 00:41:27,340
in the first place.

00:41:27,340 --> 00:41:29,500
And also, it doesn't matter.

00:41:29,500 --> 00:41:32,480
You can't really do with this set up

00:41:32,480 --> 00:41:37,030
different actions depending on the return code

00:41:37,030 --> 00:41:39,880
of the first program.

00:41:39,880 --> 00:41:42,830
So, another one is CloudFlair released

00:41:42,830 --> 00:41:45,000
this XDP dump utility,

00:41:45,000 --> 00:41:49,730
which is sort of, it's a utility that's created

00:41:49,730 --> 00:41:54,730
as a way to inspect packets after your XDP program runs.

00:41:55,540 --> 00:41:57,533
So that contains these, most of these,

00:41:57,533 --> 00:42:02,200
like the first two ones are in a library.h

00:42:02,200 --> 00:42:04,460
you can include in your own XDP program.

00:42:04,460 --> 00:42:06,120
And then you use it like you see in main.

00:42:06,120 --> 00:42:09,840
So, instead of calling return, you call return XDP cab exit.

00:42:09,840 --> 00:42:13,170
And XDP cab exit up here will go in

00:42:13,170 --> 00:42:16,863
and look into a hook map that you already defined.

00:42:18,660 --> 00:42:20,610
There's also macros to do all this.

00:42:20,610 --> 00:42:22,870
And it, and the lookup P is the action.

00:42:22,870 --> 00:42:25,740
And if it finds one, it will tail call it,

00:42:25,740 --> 00:42:28,090
then, the tail call is not going to return,

00:42:28,090 --> 00:42:30,040
and if there's nothing in the map for that action,

00:42:30,040 --> 00:42:31,740
we just pass the actions through.

00:42:31,740 --> 00:42:34,760
So, this allows you to define your XDP dump utility.

00:42:34,760 --> 00:42:38,610
I want to see all packets that are being redirected by this

00:42:41,260 --> 00:42:43,720
by this program or I just want to see all the paths,

00:42:43,720 --> 00:42:45,420
I want to see everything that's being dropped.

00:42:45,420 --> 00:42:49,420
And then the tail call program will then end up replicating

00:42:49,420 --> 00:42:51,790
the same tone again.

00:42:51,790 --> 00:42:53,270
So, the nice thing about this,

00:42:53,270 --> 00:42:55,327
is we have a different hooks per program action codes.

00:42:55,327 --> 00:42:59,430
So, we can inspect what is the program actually doing.

00:42:59,430 --> 00:43:02,620
But again, the programs need to include the helper.

00:43:02,620 --> 00:43:05,120
And you have to have one map per chain to also,

00:43:05,120 --> 00:43:08,220
if you do, if you have lots of maps that you want to,

00:43:08,220 --> 00:43:09,900
lots of programs that you want to compost,

00:43:09,900 --> 00:43:12,483
you need to replicate this for every program.

00:43:13,490 --> 00:43:15,640
And also this doesn't allow you to insert a program

00:43:15,640 --> 00:43:16,610
before what yore doing.

00:43:16,610 --> 00:43:18,570
Then that program you insert before

00:43:18,570 --> 00:43:19,630
needs to do this again.

00:43:19,630 --> 00:43:24,630
So, yes, to summarize the limitations that we just saw,

00:43:25,880 --> 00:43:29,350
the first one is we need to include tail call code

00:43:29,350 --> 00:43:31,030
into every program.

00:43:31,030 --> 00:43:34,320
So, for first thing, if we are not the program author,

00:43:34,320 --> 00:43:36,800
our vendor just gave us some BPF bit byte code

00:43:36,800 --> 00:43:38,610
and says, please run this on your machine.

00:43:38,610 --> 00:43:41,130
And for some reason, we trust them to let us

00:43:41,130 --> 00:43:42,163
to let them do this.

00:43:45,090 --> 00:43:47,530
Also, if one of your vendors then comes,

00:43:47,530 --> 00:43:49,410
oh we're doing the Katran thing.

00:43:49,410 --> 00:43:51,840
Here's the, just give us the array and the position

00:43:51,840 --> 00:43:52,710
and the other one that comes.

00:43:52,710 --> 00:43:55,760
Oh, please include this helper function from the cloud flags

00:43:55,760 --> 00:43:59,390
to P dump the thing, then you're going to have to

00:43:59,390 --> 00:44:02,060
coordinate different ways of doing this.

00:44:02,060 --> 00:44:05,580
And if someone inserts a new return statement somewhere

00:44:05,580 --> 00:44:08,780
that doesn't do the let's look up in the map logic,

00:44:08,780 --> 00:44:10,680
then you're going to have weird failure modes,

00:44:10,680 --> 00:44:13,080
where you're not going to be able to chain call.

00:44:14,040 --> 00:44:16,740
And also, even if you do control the software,

00:44:16,740 --> 00:44:19,610
you don't necessarily want to recompile your programs

00:44:19,610 --> 00:44:22,133
just to change the tail call order.

00:44:23,630 --> 00:44:25,370
Or maybe you can't, because you loaded it

00:44:25,370 --> 00:44:28,330
and then the daemon that had the source code went away

00:44:28,330 --> 00:44:29,163
or something.

00:44:30,150 --> 00:44:31,700
And also, if you're the Sys admin

00:44:31,700 --> 00:44:32,710
and not the program author,

00:44:32,710 --> 00:44:35,820
you cannot enforce policies, so you cannot say,

00:44:35,820 --> 00:44:39,140
the programs included in this tail call order

00:44:39,140 --> 00:44:40,750
but now I want to run them in the opposite order

00:44:40,750 --> 00:44:41,980
for some reason.

00:44:41,980 --> 00:44:45,090
Such as, I want to insert diagnostics into the chain call

00:44:45,090 --> 00:44:49,140
at arbitrary places or I just want to run my IDS

00:44:49,140 --> 00:44:50,890
before my DDOS filter or something.

00:44:53,240 --> 00:44:56,620
So, what we wanted to do is try to come up with a new way

00:44:56,620 --> 00:45:00,270
to do this that builds on what we have already.

00:45:00,270 --> 00:45:02,660
So we want to be able to run multiple programs

00:45:02,660 --> 00:45:05,150
in the hook with arbitrary execution order

00:45:05,150 --> 00:45:07,863
that we can change dynamically as a Sys admin.

00:45:09,620 --> 00:45:13,400
And that has this feature where we can

00:45:13,400 --> 00:45:14,910
have different chain call orders

00:45:14,910 --> 00:45:17,270
depending on the XDP return code.

00:45:17,270 --> 00:45:20,420
So, I think the most common thing

00:45:20,420 --> 00:45:23,450
will probably be to just say if it's an XDP pass,

00:45:23,450 --> 00:45:24,500
we will call the next one.

00:45:24,500 --> 00:45:26,510
So, the drops sort of go away

00:45:26,510 --> 00:45:27,690
if you, like the DDOS filter,

00:45:27,690 --> 00:45:30,180
if I drop something, we don't wanna then send that package

00:45:30,180 --> 00:45:31,420
into the IDS.

00:45:31,420 --> 00:45:32,900
But there can also be cases like,

00:45:32,900 --> 00:45:35,570
we wanna debug all the drops from this program

00:45:35,570 --> 00:45:37,870
or something and we want this to work

00:45:37,870 --> 00:45:39,330
without modifying the programs

00:45:39,330 --> 00:45:41,610
at the sales level themselves.

00:45:41,610 --> 00:45:43,233
So, how can we do this?

00:45:47,100 --> 00:45:49,370
We have two ingredients in this solution.

00:45:49,370 --> 00:45:52,750
One is, we have, we define a (mumbles) data structure

00:45:52,750 --> 00:45:54,910
to define the program sequence.

00:45:54,910 --> 00:45:56,530
So, it's basically a map.

00:45:56,530 --> 00:45:58,470
I'll show some examples of how we can implement this.

00:45:58,470 --> 00:46:01,010
But the basic idea is we take the current program ID

00:46:01,010 --> 00:46:02,550
when the program exits.

00:46:02,550 --> 00:46:04,720
We have the ID if the program had just ran

00:46:04,720 --> 00:46:07,210
and the return code that it returned to us.

00:46:07,210 --> 00:46:08,790
Then we look at the that into a map

00:46:08,790 --> 00:46:11,020
or some data structure and then we get back

00:46:11,020 --> 00:46:12,750
is there another program that we want to run.

00:46:12,750 --> 00:46:15,180
Similar to, you saw, the chain codes before?

00:46:15,180 --> 00:46:17,070
Like if it works, we're just gonna chain call

00:46:17,070 --> 00:46:18,070
otherwise we return.

00:46:19,053 --> 00:46:21,210
So, this is similar to CloudFlair's XDP dump.

00:46:21,210 --> 00:46:22,930
Like, as a map, you look up the return code

00:46:22,930 --> 00:46:24,060
and you get back.

00:46:24,060 --> 00:46:26,790
It's just that instead of having one map per program,

00:46:26,790 --> 00:46:29,510
we just have a map where we can also use the program ID

00:46:29,510 --> 00:46:30,990
as a P.

00:46:30,990 --> 00:46:33,560
And the second thing to make this work

00:46:33,560 --> 00:46:35,890
is that we hook the program return.

00:46:35,890 --> 00:46:39,610
We saw an example yesterday for the bulking

00:46:39,610 --> 00:46:41,750
that we can rewrite programs to do something

00:46:41,750 --> 00:46:43,100
when they return.

00:46:43,100 --> 00:46:45,180
So, it's basically that we want to do.

00:46:45,180 --> 00:46:47,550
Either we rewrite the return instructions

00:46:47,550 --> 00:46:49,790
and instead of returning, we do basically

00:46:49,790 --> 00:46:52,550
what we saw on the prior art example before.

00:46:52,550 --> 00:46:54,500
Or we just hook into the place in the kernel

00:46:54,500 --> 00:46:57,275
where we do the call out to XDP.

00:46:57,275 --> 00:46:58,677
So, I show some examples of that.

00:46:58,677 --> 00:47:03,160
But first, this is my attempt to diagram

00:47:03,160 --> 00:47:05,240
how would this work when we set it up.

00:47:05,240 --> 00:47:06,700
So, we startup with the XDP hook,

00:47:06,700 --> 00:47:09,270
we have the first program with ID one.

00:47:09,270 --> 00:47:11,710
That runs then it returns, comes down here

00:47:11,710 --> 00:47:13,480
and we have the program sequence map,

00:47:13,480 --> 00:47:16,240
so, if the program returns paths,

00:47:16,240 --> 00:47:17,830
we will get the leg up in the first one.

00:47:17,830 --> 00:47:19,340
Program ID one, return pass.

00:47:19,340 --> 00:47:21,310
Okay, next ID is two.

00:47:21,310 --> 00:47:22,670
So, we wrote down, find an ID.

00:47:22,670 --> 00:47:25,640
Yes, okay, we tail call that to ID two.

00:47:25,640 --> 00:47:26,600
That returns.

00:47:26,600 --> 00:47:27,800
Did that return pass?

00:47:27,800 --> 00:47:30,190
Yes. Okay, next ID three.

00:47:30,190 --> 00:47:32,760
We'll go down there and we'll end up here again.

00:47:32,760 --> 00:47:35,140
ID three return DROP, wait, that's not in there.

00:47:35,140 --> 00:47:35,973
So it wasn't found.

00:47:35,973 --> 00:47:38,220
Okay, we'll just pass return code through.

00:47:38,220 --> 00:47:39,860
So, this gives you sort of a

00:47:41,010 --> 00:47:42,860
if you do, if the first one returns pass,

00:47:42,860 --> 00:47:45,030
you'll get ID one to three.

00:47:45,030 --> 00:47:45,863
And if the first one returns TX,

00:47:45,863 --> 00:47:48,020
should go up straight to three.

00:47:48,020 --> 00:47:49,930
So, for example, I program three

00:47:49,930 --> 00:47:53,140
could just be something that turns return codes into drops

00:47:53,140 --> 00:47:54,690
in this example.

00:47:54,690 --> 00:47:57,990
So that's sort of the flow of how this would work.

00:47:57,990 --> 00:47:59,550
And then you can modify the structure

00:47:59,550 --> 00:48:00,530
to change the order.

00:48:00,530 --> 00:48:02,530
I'll show some examples of that as well.

00:48:03,810 --> 00:48:06,270
So, this could be a way to implement it.

00:48:06,270 --> 00:48:09,180
We do a chain call look up struct

00:48:09,180 --> 00:48:11,100
with a pro data in the return code

00:48:11,100 --> 00:48:13,820
and we just use that as the key

00:48:13,820 --> 00:48:16,253
in a tail call lookup map.

00:48:17,510 --> 00:48:19,320
So that becomes a composite thing.

00:48:19,320 --> 00:48:22,670
Others suggested, oh, we can do LPM matching in this.

00:48:22,670 --> 00:48:25,580
So, if the return code is not set,

00:48:25,580 --> 00:48:29,860
then that means wildcard return codes.

00:48:29,860 --> 00:48:30,910
That might be useful.

00:48:32,660 --> 00:48:36,850
And that's, so that becomes the chain call function.

00:48:36,850 --> 00:48:39,550
I'll come back to how we get to code that.

00:48:39,550 --> 00:48:42,300
The alternative is we do a two level map.

00:48:42,300 --> 00:48:45,640
So we look up the, we get the chain call map

00:48:45,640 --> 00:48:46,930
that's a path index.

00:48:46,930 --> 00:48:47,980
I forgot to mention that.

00:48:47,980 --> 00:48:49,800
We have a per if_index structure

00:48:49,800 --> 00:48:52,070
that defines the program sequence.

00:48:52,070 --> 00:48:53,660
So we could also do find the map

00:48:53,660 --> 00:48:56,020
then do an inner map lookup on the program ID

00:48:56,020 --> 00:49:00,600
and then each, in a map is then a per return code lookup.

00:49:00,600 --> 00:49:01,700
It's basically the same thing

00:49:01,700 --> 00:49:04,993
but it's two look ups instead of one with a composite key.

00:49:06,820 --> 00:49:11,730
So that's a matter of taste, which one do you like better?

00:49:11,730 --> 00:49:13,240
How many maps do you wanna,

00:49:13,240 --> 00:49:15,250
do you wanna build the struct to the look up?

00:49:15,250 --> 00:49:18,843
Or do you wanna manage more maps?

00:49:20,940 --> 00:49:22,930
I think I'm leaning towards the composite one.

00:49:22,930 --> 00:49:25,220
We're trying to stress that.

00:49:25,220 --> 00:49:27,530
So, how do we get all this to work?

00:49:27,530 --> 00:49:28,740
There's, we come out,

00:49:28,740 --> 00:49:31,210
came up with basically three ways we might do this.

00:49:31,210 --> 00:49:34,130
One is the user space only implementation,

00:49:34,130 --> 00:49:35,630
which is okay, let's get,

00:49:35,630 --> 00:49:39,820
we have libbpf and if we assume that everything

00:49:39,820 --> 00:49:41,740
is going to use libbpf as a loader,

00:49:41,740 --> 00:49:44,660
we can just define the BPF chain call

00:49:44,660 --> 00:49:49,550
as a BPF function, which libbpf will then create and pin

00:49:49,550 --> 00:49:53,373
for each if_index and then ask the programs that load it,

00:49:54,300 --> 00:49:57,310
this map will be populated by the loader.

00:49:57,310 --> 00:50:00,253
And then the loader will also before it loads the programs,

00:50:00,253 --> 00:50:04,290
it will rewrite the eBPF byte code

00:50:04,290 --> 00:50:08,720
to call into this other function.

00:50:08,720 --> 00:50:10,710
And then, and with the right maps.

00:50:10,710 --> 00:50:11,940
- [Audience Person] So, I think your assumption

00:50:11,940 --> 00:50:16,150
that everything will use libbpf presupposes that BPF libbpf

00:50:16,150 --> 00:50:18,890
is public domain instead of GPL code.

00:50:18,890 --> 00:50:19,723
- Yes.

00:50:19,723 --> 00:50:22,039
I don't actually think this is the right way to do it.

00:50:22,039 --> 00:50:23,170
(laughing)

00:50:23,170 --> 00:50:25,560
So, but as a distro, for example,

00:50:25,560 --> 00:50:28,250
we could enforce, we will only support your XDP program

00:50:28,250 --> 00:50:30,690
if you use this loader that we are shipping to you.

00:50:30,690 --> 00:50:32,906
Like, you could do the same, it doesn't have to be libbpf

00:50:32,906 --> 00:50:35,910
but if we have one place in the system

00:50:35,910 --> 00:50:38,710
that all programs go through, we can do this re running.

00:50:39,600 --> 00:50:42,450
So, the pros, we don't have to change the kernel.

00:50:42,450 --> 00:50:43,283
Yay!

00:50:43,283 --> 00:50:46,040
But as you pointed out, it only works

00:50:46,040 --> 00:50:48,340
if all the loaders do this and libbpf

00:50:48,340 --> 00:50:51,320
is probably not necessarily going to be there

00:50:51,320 --> 00:50:55,480
but and also user space has to do all the bookkeeping

00:50:55,480 --> 00:50:57,070
because we again, we're baking,

00:50:57,070 --> 00:50:59,410
when we load the programs, the map is going to be baked

00:50:59,410 --> 00:51:02,920
into the program just as it is now.

00:51:02,920 --> 00:51:05,120
So, if we want to swap the map,

00:51:05,120 --> 00:51:07,550
then we need to get all the programs off code,

00:51:07,550 --> 00:51:08,870
rewrite it again with new maps

00:51:08,870 --> 00:51:11,060
and reload it and that's not necessarily feasible.

00:51:11,060 --> 00:51:13,100
So, I put this up here just to say, yes,

00:51:13,100 --> 00:51:15,840
I think technically, it might be possible

00:51:15,840 --> 00:51:17,860
to get this to work and use this space,

00:51:17,860 --> 00:51:20,180
but I don't think it's going to be very robust.

00:51:20,180 --> 00:51:22,150
Which of course means that we need kernel support.

00:51:22,150 --> 00:51:25,090
Yay! (chuckling)

00:51:25,090 --> 00:51:26,580
That is actually the real reason I'm up here.

00:51:26,580 --> 00:51:27,960
I'm trying to get you guys on board

00:51:27,960 --> 00:51:29,120
that we need kernel support for this.

00:51:29,120 --> 00:51:32,380
So, in the kernel, there's two ways which we do this.

00:51:32,380 --> 00:51:34,220
We have this nice verifier

00:51:34,220 --> 00:51:38,120
that sees all the XDP programs as they're loaded.

00:51:38,120 --> 00:51:40,230
It already rewrites stuff.

00:51:40,230 --> 00:51:42,720
So, we could define the BPF chain call function

00:51:42,720 --> 00:51:45,570
in whichever version like we saw before.

00:51:45,570 --> 00:51:48,290
As BPF kernel BPF helper function.

00:51:48,290 --> 00:51:50,290
And then the verifier wants a program is loaded,

00:51:50,290 --> 00:51:52,620
that can be a CCTL that says

00:51:52,620 --> 00:51:55,480
chain calls are enabled and if this is there,

00:51:55,480 --> 00:51:57,430
the verifier will go on and hook the returns

00:51:57,430 --> 00:52:01,510
from the program and turn those into BPF helper call

00:52:01,510 --> 00:52:03,480
or call for whatever.

00:52:03,480 --> 00:52:07,100
And then user space still has the responsibility

00:52:07,100 --> 00:52:09,330
of populating the map and helper works in a way

00:52:09,330 --> 00:52:10,880
that if the map is not there,

00:52:10,880 --> 00:52:13,110
if it's not, if there's nothing in it and so on,

00:52:13,110 --> 00:52:15,700
it just, it will just become one map look up that fails.

00:52:15,700 --> 00:52:17,830
And then you just return kernel.

00:52:17,830 --> 00:52:19,170
This is so this is nice.

00:52:19,170 --> 00:52:20,360
It's enforceable system.

00:52:20,360 --> 00:52:22,960
Why it uses the existing tail call infrastructure,

00:52:22,960 --> 00:52:25,337
which meas we won't get another indirect call

00:52:25,337 --> 00:52:26,640
for everything in the sequence.

00:52:26,640 --> 00:52:28,890
It just jumps the whole BPF thing.

00:52:28,890 --> 00:52:30,370
And the occurrences, we have to go

00:52:30,370 --> 00:52:32,653
and get our hands dirty with the verifier,

00:52:33,500 --> 00:52:37,210
more complexities to already complex piece of code.

00:52:37,210 --> 00:52:38,990
The other thing we could do

00:52:38,990 --> 00:52:41,250
is for HPD, is we have a single kernel function

00:52:41,250 --> 00:52:44,037
that always is used to run all their XDP programs,

00:52:44,037 --> 00:52:47,990
the distros return BPF run prog.

00:52:47,990 --> 00:52:51,300
So that could just do BPF run prog,

00:52:51,300 --> 00:52:56,300
get the return code, do the BPF chain call logic

00:52:57,190 --> 00:52:58,640
as a regular kernel function.

00:52:59,710 --> 00:53:03,670
And then call that before returning your code

00:53:03,670 --> 00:53:07,490
to the driver and then just do another run BPF prog call.

00:53:07,490 --> 00:53:09,480
And then again, use this space for populate map

00:53:09,480 --> 00:53:10,990
and everything is good.

00:53:10,990 --> 00:53:13,670
So, this is again, enforceable system wide,

00:53:13,670 --> 00:53:15,030
we're in the kernel, everything is good.

00:53:15,030 --> 00:53:16,890
We don't need to do anything in the verifier,

00:53:16,890 --> 00:53:18,903
we just hook into the HDP structure.

00:53:19,780 --> 00:53:22,700
But as we saw yesterday, that means that each sequence

00:53:22,700 --> 00:53:25,683
in the call chain, we get a new indirect call.

00:53:27,380 --> 00:53:30,830
And also we need the check and the fast path.

00:53:30,830 --> 00:53:32,210
We can't turn it off completely.

00:53:32,210 --> 00:53:34,680
There will be at least one branch in that function

00:53:34,680 --> 00:53:36,610
to see if this function is enabled.

00:53:36,610 --> 00:53:38,760
I'm not sure that's actually going to be measurable

00:53:38,760 --> 00:53:39,593
overhead.

00:53:39,593 --> 00:53:41,410
It's more the indirect call things

00:53:41,410 --> 00:53:42,243
I'm worried about from this.

00:53:42,243 --> 00:53:43,840
But it's definitely simpler to implement.

00:53:43,840 --> 00:53:45,923
So, I guess maybe we can try it and see.

00:53:47,450 --> 00:53:48,480
- [Facilitator] It even suggests

00:53:48,480 --> 00:53:50,650
that since it the three requires

00:53:50,650 --> 00:53:53,480
no verifier changes, we could go for that.

00:53:53,480 --> 00:53:54,510
- Yes. - And if if doesn't work,

00:53:54,510 --> 00:53:56,888
like or I guess, we do have to touch the verifier.

00:53:56,888 --> 00:53:58,096
- Yes.

00:53:58,096 --> 00:53:59,257
- [Audience Member 6] There's.

00:53:59,257 --> 00:54:00,424
- That's side.

00:54:04,191 --> 00:54:05,024
- Thank you.

00:54:05,024 --> 00:54:06,770
You mentioned that one of your goals

00:54:06,770 --> 00:54:09,433
is to have this usable by XDP programs

00:54:09,433 --> 00:54:10,890
that have not been modified.

00:54:10,890 --> 00:54:13,550
But you're saying you wanna introduce a new chain call

00:54:13,550 --> 00:54:18,100
helper, which implies you need to have all programs

00:54:18,100 --> 00:54:19,550
have that in there.

00:54:19,550 --> 00:54:22,120
- No because the, the verifier

00:54:22,120 --> 00:54:24,300
turns return codes into calls to that helper.

00:54:24,300 --> 00:54:25,133
On this case, it will not be helper,

00:54:25,133 --> 00:54:26,989
it will just be functionality in the kernel.

00:54:26,989 --> 00:54:27,910
- [Audience Member 6] Okay, cool.

00:54:27,910 --> 00:54:30,741
- And there's a precedence for doing that already, right?

00:54:30,741 --> 00:54:32,253
We do it in the C group site.

00:54:33,380 --> 00:54:36,043
They call, they make a chain of programs and

00:54:36,043 --> 00:54:40,480
there's a precedence for having chains and programs run

00:54:40,480 --> 00:54:42,280
and then you return and there's some

00:54:44,250 --> 00:54:46,420
precedence of return codes that you get the right one,

00:54:46,420 --> 00:54:47,360
you know, so.

00:54:47,360 --> 00:54:48,193
- So, how do you load those?

00:54:48,193 --> 00:54:50,820
Do you just do add one to the chain?

00:54:50,820 --> 00:54:53,277
Can you modify the sequence?

00:54:53,277 --> 00:54:55,940
- So, the order of the C groups, right?

00:54:55,940 --> 00:54:57,750
So, I actually each C group can have

00:54:57,750 --> 00:55:00,120
a multiple and it's in order of insertion.

00:55:00,120 --> 00:55:01,400
Although, I think with XDP,

00:55:01,400 --> 00:55:03,790
you'd wanna have a priority where you wanna insert things

00:55:03,790 --> 00:55:04,660
in different orders.

00:55:04,660 --> 00:55:06,750
- Yeah, so that's C groups.

00:55:06,750 --> 00:55:07,870
- We also thought about, okay,

00:55:07,870 --> 00:55:12,120
let's just have XDP attach, just be additive.

00:55:12,120 --> 00:55:13,760
So just attach one to the end of the sequence.

00:55:13,760 --> 00:55:15,800
And then the kernel just keeps a link list.

00:55:15,800 --> 00:55:18,310
But the problem with that is it becomes really difficult

00:55:18,310 --> 00:55:19,220
to modify, right?

00:55:19,220 --> 00:55:20,400
So that's why we went with the ledge

00:55:20,400 --> 00:55:22,411
look up in the map and use that to the

00:55:22,411 --> 00:55:23,740
- Right, 'cause you definitely wanna have

00:55:23,740 --> 00:55:25,010
that priority aspect of it.

00:55:25,010 --> 00:55:27,020
So, for example, the XDP dump where you can say, no,

00:55:27,020 --> 00:55:28,290
mine takes highest priority.

00:55:28,290 --> 00:55:30,300
But I don't know about modifying things.

00:55:30,300 --> 00:55:33,100
Maybe the program writers don't want someone else

00:55:33,100 --> 00:55:35,840
coming in and modifying their program, right.

00:55:35,840 --> 00:55:37,210
So, it's - Well, they already do that

00:55:37,210 --> 00:55:38,580
for constant blinding and all this other stuff.

00:55:38,580 --> 00:55:41,580
- Yeah, that's, verify execute in the BPF code.

00:55:41,580 --> 00:55:43,390
You load into the kernel ever.

00:55:43,390 --> 00:55:44,223
- Yeah. - Yeah,

00:55:44,223 --> 00:55:47,230
but it doesn't need to be necessarily re writing

00:55:47,230 --> 00:55:48,063
the eBPF code.

00:55:48,063 --> 00:55:52,220
It can also just be insert a hook

00:55:52,220 --> 00:55:57,220
on JIT, like, do this thing but inject it as JIT code

00:55:58,900 --> 00:56:02,692
into the function itself without modifying the BPF software.

00:56:02,692 --> 00:56:04,200
- [Audience Member 7] So just from a user's perspective,

00:56:04,200 --> 00:56:06,040
to have some consistency with the way C groups

00:56:06,040 --> 00:56:09,248
is done, I think there would be a huge plus.

00:56:09,248 --> 00:56:11,548
- Yeah, I'll look into exactly how that works.

00:56:12,580 --> 00:56:13,580
One more down there.

00:56:14,472 --> 00:56:16,722
(mumbling)

00:56:18,100 --> 00:56:19,700
- Thanks.

00:56:19,700 --> 00:56:21,690
So I'm wondering if this is not similar

00:56:21,690 --> 00:56:23,370
a little bit to package filtering,

00:56:23,370 --> 00:56:26,326
where we started with chains and at some point,

00:56:26,326 --> 00:56:29,610
we got to a tree, where you wanna have a hash function

00:56:29,610 --> 00:56:30,443
and distribute.

00:56:30,443 --> 00:56:32,020
Here, you're talking about a chain,

00:56:32,020 --> 00:56:35,010
which can be long, multiple applications running,

00:56:35,010 --> 00:56:38,900
latency will recur and if you have a tree

00:56:38,900 --> 00:56:40,710
at some point, where you're doing a hash

00:56:40,710 --> 00:56:44,040
and split into different programs,

00:56:44,040 --> 00:56:46,570
might be the next evolution of this, I'm not sure.

00:56:46,570 --> 00:56:48,008
- Possibly.

00:56:48,008 --> 00:56:51,143
And, I think you can actually express a tree with this.

00:56:52,156 --> 00:56:53,510
- [Audience Member 7] With multiple applications,

00:56:53,510 --> 00:56:56,610
like having a generic hash depending on the (mumbles)

00:56:56,610 --> 00:56:58,690
you go to program A or program B.

00:56:58,690 --> 00:56:59,900
- Yeah. - Okay.

00:56:59,900 --> 00:57:02,700
- You're sort of striking a balance between usability

00:57:02,700 --> 00:57:04,013
and I really care about performance

00:57:04,013 --> 00:57:06,410
because if I really really care about performance,

00:57:06,410 --> 00:57:08,550
I'm gonna optimize one program and do loader myself,

00:57:08,550 --> 00:57:09,383
I think. - Yes yes.

00:57:09,383 --> 00:57:12,160
- Like, if you care about every cycle

00:57:12,160 --> 00:57:14,260
and every indirect call and every branch,

00:57:14,260 --> 00:57:16,530
you're gonna knock the list of programs.

00:57:16,530 --> 00:57:18,391
I just, I don't think that's true.

00:57:18,391 --> 00:57:20,400
- [Tokay] Yeah, so it really needs to be optional.

00:57:20,400 --> 00:57:21,940
- I think it's you know, like as soon as

00:57:21,940 --> 00:57:23,750
you start talking about trees and hash maps

00:57:23,750 --> 00:57:27,260
it's like how complex do we want this infrastructure to be

00:57:27,260 --> 00:57:28,650
when we can already do that already

00:57:28,650 --> 00:57:30,553
by writing a BPF program?

00:57:30,553 --> 00:57:32,960
The sooner the power of the BPF itself

00:57:32,960 --> 00:57:35,040
is that you can write the exact program you need,

00:57:35,040 --> 00:57:36,425
right and you're not calling lists of things

00:57:36,425 --> 00:57:40,303
or even trees, right, so, I think it's just a trade off.

00:57:41,990 --> 00:57:45,640
- And I think the other thing to consider if you are reusing

00:57:45,640 --> 00:57:49,060
tail call infrastructure that you cannot use other

00:57:49,060 --> 00:57:50,613
features in the verifier,

00:57:51,564 --> 00:57:55,350
in the BFP, like a BPF to BPF calls

00:57:55,350 --> 00:57:57,570
and those things that we disable.

00:57:57,570 --> 00:57:59,100
- [David] Oh would you disable those for tail calls?

00:57:59,100 --> 00:58:00,460
- Yeah. - Oh cool.

00:58:00,460 --> 00:58:02,482
I didn't know.

00:58:02,482 --> 00:58:04,110
Good to know, I mean.

00:58:04,110 --> 00:58:06,560
- But I think it's solvable to overcome that limitation.

00:58:06,560 --> 00:58:08,600
But yeah - Because once you have

00:58:08,600 --> 00:58:11,030
tail calls, you can't do a holistic analysis

00:58:11,030 --> 00:58:12,970
of what features set is used by the entirety

00:58:12,970 --> 00:58:14,670
- Yeah, we'll come back to that.

00:58:14,670 --> 00:58:16,103
Jasper has. - Okay.

00:58:17,340 --> 00:58:20,640
- Yeah, but like, so, one thing I didn't mention

00:58:20,640 --> 00:58:22,150
is that the nice thing about using it

00:58:22,150 --> 00:58:24,540
doing it as tail calls is we already enforced

00:58:24,540 --> 00:58:26,840
a maximum program limit whereas this thing

00:58:26,840 --> 00:58:29,583
if we don't prevent it from, it could loop forever.

00:58:31,210 --> 00:58:32,990
- Two observations.

00:58:32,990 --> 00:58:36,620
Anytime that system engineers try to centralize

00:58:36,620 --> 00:58:38,780
something in the user space, they punt to the kernel.

00:58:38,780 --> 00:58:40,970
That's what we're doing here.

00:58:40,970 --> 00:58:43,570
Second observation is that this makes me think

00:58:43,570 --> 00:58:48,570
about the XDP program per queue ideas

00:58:48,620 --> 00:58:50,820
and you would need three keys at that point.

00:58:51,810 --> 00:58:53,470
- No, you would just need - Or you would have

00:58:53,470 --> 00:58:55,970
a separate map for each set of thing, okay.

00:58:55,970 --> 00:58:57,480
So, please keep that in mind.

00:58:57,480 --> 00:58:58,760
- [Second Speaker] Yes.

00:58:58,760 --> 00:59:00,120
- Okay, cool.

00:59:00,120 --> 00:59:03,220
So, actually, the idea was very much lets see

00:59:03,220 --> 00:59:04,900
can we do this in user space?

00:59:04,900 --> 00:59:06,540
And can we make it work?

00:59:06,540 --> 00:59:08,090
But I don't actually believe this is going

00:59:08,090 --> 00:59:11,802
to work in practice from user space because yeah.

00:59:11,802 --> 00:59:14,160
- One problem with that is this is,

00:59:14,160 --> 00:59:14,993
we talked about it before.

00:59:14,993 --> 00:59:17,650
This is actually stealing tail calls from the programs.

00:59:17,650 --> 00:59:22,050
So if you're using tail calls for this, you're limiting

00:59:22,050 --> 00:59:26,690
the programs, so the number of tail calls they can do.

00:59:26,690 --> 00:59:28,478
- Well just something - You could reset the counter

00:59:28,478 --> 00:59:29,976
every time you do this.

00:59:29,976 --> 00:59:30,843
- See? - You could reset

00:59:30,843 --> 00:59:32,283
the counter every time but then you would need

00:59:32,283 --> 00:59:34,740
a separate counter - Yes, something like that.

00:59:34,740 --> 00:59:36,953
- So, is there, just to follow up.

00:59:36,953 --> 00:59:38,517
I think that's true but on the other hand,

00:59:38,517 --> 00:59:41,990
we can also potentially bump the limit.

00:59:41,990 --> 00:59:45,010
We have one million instructions, so.

00:59:45,010 --> 00:59:45,843
- Yeah.

00:59:46,750 --> 00:59:47,710
- I'm just curious.

00:59:47,710 --> 00:59:51,910
Is there a concrete user of this?

00:59:51,910 --> 00:59:53,850
Or is this like a build it and we might have

00:59:53,850 --> 00:59:55,470
some users that want to use it?

00:59:55,470 --> 00:59:58,330
I'm just like, seems like a lot of complexity.

00:59:58,330 --> 00:59:59,163
And I'm not sure.

00:59:59,163 --> 01:00:00,980
(chatter)

01:00:00,980 --> 01:00:02,880
- [Man] Yeah, we'd like to use it.

01:00:02,880 --> 01:00:03,750
- But why?

01:00:03,750 --> 01:00:05,310
I mean, you control your entire program.

01:00:05,310 --> 01:00:06,167
Why don't you just write the program that you need?

01:00:06,167 --> 01:00:08,630
- But there's, in theory, there is different teams

01:00:08,630 --> 01:00:10,560
responsible for different parts of the program.

01:00:10,560 --> 01:00:11,393
So we have.

01:00:12,290 --> 01:00:15,020
So there's a - I've had distribution

01:00:15,020 --> 01:00:16,850
like this was the first thing that came up

01:00:16,850 --> 01:00:18,730
and Tony was like, let's turn on XDP.

01:00:18,730 --> 01:00:19,990
And then we have two different teams like,

01:00:19,990 --> 01:00:20,823
we wanna use it.

01:00:20,823 --> 01:00:21,656
We wanna use it.

01:00:21,656 --> 01:00:22,630
What are we gonna do?

01:00:22,630 --> 01:00:23,850
- Okay. - So,

01:00:23,850 --> 01:00:25,550
and the debugging thing is the other thing,

01:00:25,550 --> 01:00:27,904
which might be solvable by hooking in but.

01:00:27,904 --> 01:00:31,360
(mumbling in background) - Don't worry, we'll make

01:00:31,360 --> 01:00:32,293
it optional.

01:00:33,325 --> 01:00:34,730
(faint speaking) Yeah.

01:00:34,730 --> 01:00:35,783
We want to - I just think

01:00:35,783 --> 01:00:38,670
that as a baseline, we will sacrifice some performance

01:00:38,670 --> 01:00:39,503
- Yes. - by doing

01:00:39,503 --> 01:00:40,439
- It's going to be optional. - Optimization

01:00:40,439 --> 01:00:42,700
and I worry a bit about, like I said,

01:00:42,700 --> 01:00:44,060
there's a trade off between complexity, right?

01:00:44,060 --> 01:00:45,330
There's, I think there's a tendency

01:00:45,330 --> 01:00:46,950
to try to over engineer this to the point

01:00:46,950 --> 01:00:49,180
like, we want to work for all every use

01:00:49,180 --> 01:00:51,730
possible use case and I think at some point,

01:00:51,730 --> 01:00:53,820
we can say, hey, system owner of the system,

01:00:53,820 --> 01:00:56,670
who manages the and provisions the system.

01:00:56,670 --> 01:00:59,260
Your responsibility is also to manage the programs

01:00:59,260 --> 01:01:00,400
that are running chains.

01:01:00,400 --> 01:01:03,460
'Cause somebody still has to load these in the right order.

01:01:03,460 --> 01:01:04,633
Right, like - Yeah.

01:01:06,360 --> 01:01:07,260
- I mean, - But that

01:01:07,260 --> 01:01:08,320
we can solve in user space.

01:01:08,320 --> 01:01:10,030
- Just like kind of like,

01:01:10,030 --> 01:01:11,135
- Yeah. - I hope

01:01:11,135 --> 01:01:12,530
it doesn't get too complex, right?

01:01:12,530 --> 01:01:14,430
- We're trying to make it as simple as possible.

01:01:14,430 --> 01:01:16,019
But no simpler.

01:01:16,019 --> 01:01:20,970
- So, the use space is really (background chatter)

01:01:20,970 --> 01:01:22,070
- Can I? One quick thing.

01:01:22,070 --> 01:01:23,540
We've talked about doing this internally

01:01:23,540 --> 01:01:25,530
but all in user space as well?

01:01:25,530 --> 01:01:27,310
I think you could imagine there would be one daemon

01:01:27,310 --> 01:01:29,590
responsible for actually attaching XDP programs

01:01:29,590 --> 01:01:32,510
and every other daemon would send the program IDs

01:01:32,510 --> 01:01:34,520
to that daemon over (mumbles) or something.

01:01:34,520 --> 01:01:36,680
And that user space daemon would then rewrite

01:01:36,680 --> 01:01:38,330
all the programs to use the right tail calls

01:01:38,330 --> 01:01:39,430
to build up the chain.

01:01:40,300 --> 01:01:42,380
- Yeah, but then that daemon would need to cache

01:01:42,380 --> 01:01:43,224
all the programs and rewrite them again.

01:01:43,224 --> 01:01:44,222
- [Man] Yes, you're gonna have to

01:01:44,222 --> 01:01:45,647
keep all the programs and rewrite them.

01:01:45,647 --> 01:01:47,540
- [Facilitator] Again, this is why we punted a kernel

01:01:47,540 --> 01:01:49,443
for essentialized operations. - Yeah.

01:01:55,190 --> 01:01:57,890
- The use case really is the user installs

01:01:57,890 --> 01:02:02,540
two packages using XDP and it just works.

01:02:02,540 --> 01:02:05,290
So, I cannot imagine administrator

01:02:05,290 --> 01:02:09,350
of the machine to ordering those packages or something.

01:02:09,350 --> 01:02:11,563
That's not good user experience.

01:02:12,410 --> 01:02:14,010
- [Facilitator] And like we said,

01:02:14,010 --> 01:02:16,000
if you do want the best performance,

01:02:16,000 --> 01:02:17,620
and you want this completely integrated solution,

01:02:17,620 --> 01:02:19,450
you would implement it.

01:02:19,450 --> 01:02:22,410
- Yeah, so it's like the simplest thing that can just work

01:02:22,410 --> 01:02:23,990
and then if you want to be more fancy,

01:02:23,990 --> 01:02:25,140
you can do something yourself.

01:02:25,140 --> 01:02:27,870
So, the last - You also sort of

01:02:27,870 --> 01:02:32,211
have similar issue in TC, for example, right?

01:02:32,211 --> 01:02:35,040
There are also, a user can install multiple programs,

01:02:35,040 --> 01:02:38,760
they still have to interact with each other

01:02:38,760 --> 01:02:42,270
because if one breaks the sequence,

01:02:42,270 --> 01:02:44,700
then yeah, so some form or cooperation

01:02:44,700 --> 01:02:48,033
is still needed after all this, even in XDP as well.

01:02:49,860 --> 01:02:52,173
- Very hallway talk. - Yes, we also need

01:02:52,173 --> 01:02:53,880
to have time for Jasper.

01:02:53,880 --> 01:02:56,130
- We had a bet whether or not he would get time

01:02:56,130 --> 01:02:56,991
to say anything.

01:02:56,991 --> 01:02:59,160
(laughing) - Might not.

01:02:59,160 --> 01:03:01,830
- Yeah, so I'll just skip over this pretty quick.

01:03:01,830 --> 01:03:04,510
This is just some samples of if you just wanna update

01:03:04,510 --> 01:03:06,840
the sequence, you could do link list operations

01:03:06,840 --> 01:03:08,780
in this map, but if you want to do something

01:03:08,780 --> 01:03:12,070
more complex by change the order completely

01:03:12,070 --> 01:03:14,540
in one atomic operation, you just create a new map

01:03:14,540 --> 01:03:16,716
and then that's a function to replace it.

01:03:16,716 --> 01:03:18,300
And then there's that to remedy update.

01:03:18,300 --> 01:03:19,150
How do we handle that?

01:03:19,150 --> 01:03:21,140
That's details, we'll figure it out.

01:03:21,140 --> 01:03:22,363
- Jasper. - Yeah.

01:03:23,640 --> 01:03:28,370
- It's, see the next problem of like feature

01:03:28,370 --> 01:03:29,900
detection we've been fighting over this

01:03:29,900 --> 01:03:31,450
for a couple of years, I think.

01:03:34,340 --> 01:03:36,560
So how do we ensure a program will actually work

01:03:36,560 --> 01:03:38,320
when we load it successfully

01:03:38,320 --> 01:03:40,070
because that's not this case today?

01:03:42,530 --> 01:03:46,343
So, XDP features depend on the driver support.

01:03:47,230 --> 01:03:49,657
And it sort of breaks the BPF feature systems.

01:03:49,657 --> 01:03:52,290
The BPF have a feature system by that way

01:03:52,290 --> 01:03:54,550
that if you use a functionality

01:03:54,550 --> 01:03:57,080
that is not available in the BFP call,

01:03:57,080 --> 01:03:59,750
you will not be allowed to load this BPF program.

01:03:59,750 --> 01:04:02,133
It will simply get rejected at load time.

01:04:03,630 --> 01:04:05,840
Because the BPF calls always come by then,

01:04:05,840 --> 01:04:06,710
so that's great.

01:04:06,710 --> 01:04:08,063
We can always know this.

01:04:08,950 --> 01:04:12,410
But XDP challenged this because it's modules.

01:04:12,410 --> 01:04:15,010
It is actually driver modules that get loaded

01:04:15,010 --> 01:04:16,920
that's not part of the calls.

01:04:16,920 --> 01:04:19,260
We don't know what features they have.

01:04:19,260 --> 01:04:21,803
So, they have different features.

01:04:25,160 --> 01:04:25,993
So,

01:04:28,000 --> 01:04:32,220
this is the most, the question I get the most often

01:04:32,220 --> 01:04:34,330
is does this NIC work with XDP?

01:04:34,330 --> 01:04:37,660
And we really cannot answer that question.

01:04:37,660 --> 01:04:42,406
Our answer is like, go read the kernel source.

01:04:42,406 --> 01:04:43,490
(laughing)

01:04:43,490 --> 01:04:44,440
That's what I do.

01:04:44,440 --> 01:04:45,550
That's not a problem for me.

01:04:45,550 --> 01:04:48,183
I don't know why it's such a problem for everybody else.

01:04:49,030 --> 01:04:51,830
So, that's really not a good answer so.

01:04:51,830 --> 01:04:54,140
So, we have to get up with a better answer

01:04:54,140 --> 01:04:56,460
and then people with the don't ask me,

01:04:56,460 --> 01:04:58,970
like she just loaded and I'll use generic XDP

01:04:58,970 --> 01:05:03,210
without noticing and that's, you'll complain

01:05:03,210 --> 01:05:05,000
about performance and, as David said,

01:05:05,000 --> 01:05:07,730
there actually some (mumbles) cases that we don't handle,

01:05:07,730 --> 01:05:09,780
which will also drop packets silently,

01:05:09,780 --> 01:05:11,523
which is a nice feature.

01:05:12,730 --> 01:05:16,747
So, we that's a support issue for (mumbles).

01:05:18,975 --> 01:05:21,820
- And others. - Yeah, and as John

01:05:21,820 --> 01:05:23,783
always says, is there any re uses?

01:05:24,890 --> 01:05:27,320
So we actually have (mumbles) that won't require it

01:05:27,320 --> 01:05:29,620
if it has XDP support.

01:05:29,620 --> 01:05:33,340
Or else they want to fall back to using the TC hooks instead

01:05:33,340 --> 01:05:35,490
but they cannot do that today.

01:05:35,490 --> 01:05:40,270
If so, as a user configures this to use XDP,

01:05:40,270 --> 01:05:42,450
then it will just drop his packets

01:05:42,450 --> 01:05:44,140
because it wasn't there.

01:05:44,140 --> 01:05:47,740
So, can I actually have, we have implemented

01:05:47,740 --> 01:05:52,390
(mumbles) to do funny stuff in there.

01:05:52,390 --> 01:05:54,180
And they really can't use it

01:05:54,180 --> 01:05:57,150
because if, then NIC has to support the feature

01:05:57,150 --> 01:05:59,550
and if it doesn't, it will just drop the packets

01:05:59,550 --> 01:06:01,740
and that's really not good user experience.

01:06:01,740 --> 01:06:03,890
And they can implement the same NTC

01:06:03,890 --> 01:06:05,350
but lower performance.

01:06:05,350 --> 01:06:06,870
So if they really want to know this

01:06:06,870 --> 01:06:11,870
and then the BM or the virtual team in (mumbles)

01:06:11,950 --> 01:06:14,830
always complains that they want to do VM migration

01:06:14,830 --> 01:06:15,710
and they cannot.

01:06:15,710 --> 01:06:17,360
I think (mumbles) recovered that.

01:06:18,460 --> 01:06:20,620
So, the original argument was, well,

01:06:20,620 --> 01:06:22,663
all drivers must support all our features.

01:06:22,663 --> 01:06:24,513
That was never really true, right?

01:06:26,450 --> 01:06:28,377
Even today, there only a few drivers to support

01:06:28,377 --> 01:06:29,623
the redirect feature.

01:06:33,770 --> 01:06:38,770
So, the real issue is actually that it's too easy

01:06:38,870 --> 01:06:41,170
to shoot yourself in the foot.

01:06:41,170 --> 01:06:45,560
So, the kernel allows you to attach XDP programs

01:06:45,560 --> 01:06:48,820
where the features in the driver isn't implemented and then

01:06:51,830 --> 01:06:52,663
thank you.

01:06:53,774 --> 01:06:55,330
And then we have the silent drops again,

01:06:55,330 --> 01:06:56,993
which is a real pain in the ass.

01:07:02,400 --> 01:07:06,260
So, but we really need something that can reject earlier.

01:07:06,260 --> 01:07:08,950
Because I actually don't believe that you can just,

01:07:08,950 --> 01:07:11,440
if you just export feature space to user space,

01:07:11,440 --> 01:07:12,570
people are not going to look at it.

01:07:12,570 --> 01:07:15,510
They are not going to spend the time

01:07:15,510 --> 01:07:20,250
checking these feature bits and then actually

01:07:20,250 --> 01:07:24,120
not load their program, so I really like an old solution

01:07:24,120 --> 01:07:26,270
where the kernel enforces this

01:07:26,270 --> 01:07:29,900
and rejects if you load a program or attach a program

01:07:31,360 --> 01:07:33,310
that isn't compatible with your system.

01:07:34,780 --> 01:07:37,360
So that's what the BPF verifier already does.

01:07:37,360 --> 01:07:39,150
It retakes load times.

01:07:39,150 --> 01:07:40,103
It's really nice.

01:07:41,240 --> 01:07:43,360
So, we don't allow them to run something

01:07:43,360 --> 01:07:44,410
that is not possible.

01:07:48,830 --> 01:07:52,131
So, I'll get back to why I don't like tail calls.

01:07:52,131 --> 01:07:53,630
(laughing)

01:07:53,630 --> 01:07:56,690
So, (mumbles) places do all this stuff on tails calls

01:07:56,690 --> 01:08:00,130
and tail calls are really really

01:08:00,130 --> 01:08:03,133
blocking my initial solution.

01:08:04,420 --> 01:08:08,580
So, obvious solutions to me would to do this feature check

01:08:08,580 --> 01:08:12,540
or match at, when you load it at attach time.

01:08:12,540 --> 01:08:14,160
So you have to be prepare program, load it,

01:08:14,160 --> 01:08:17,150
and then we attach it, we check if these feature bits

01:08:17,150 --> 01:08:19,103
matches up, what the program uses.

01:08:20,030 --> 01:08:22,670
But that is not possible for tail calls.

01:08:22,670 --> 01:08:25,500
I tried to explain a number of times

01:08:25,500 --> 01:08:28,250
why this is problematic and people don't get it.

01:08:28,250 --> 01:08:31,670
So, it's much easier with an example.

01:08:31,670 --> 01:08:35,370
If you have .1, you have the driver tail call

01:08:35,370 --> 01:08:37,223
in the tail call map.

01:08:38,680 --> 01:08:42,489
And the tail call calls in, so a second level

01:08:42,489 --> 01:08:46,923
tail call map and later, it is updated.

01:08:48,170 --> 01:08:49,870
This is second level tail call map

01:08:50,730 --> 01:08:54,360
with a program that uses unsupported feature.

01:08:54,360 --> 01:08:55,920
How can the driver see this?

01:08:55,920 --> 01:08:58,510
That is sort of what happened

01:08:58,510 --> 01:09:03,190
is that the tail calls actually added a hook

01:09:03,190 --> 01:09:05,270
outside the drivers' control.

01:09:05,270 --> 01:09:08,250
So the initial program that gets attached

01:09:08,250 --> 01:09:10,270
actually calls a function down in the driver

01:09:10,270 --> 01:09:14,660
in the, to attach but all the way down

01:09:14,660 --> 01:09:17,890
all of a sudden, you can change the program run time

01:09:17,890 --> 01:09:20,970
by changing the tail call map.

01:09:20,970 --> 01:09:22,050
- [Facilitator] You could declare

01:09:22,050 --> 01:09:23,670
what features a program needs

01:09:23,670 --> 01:09:26,950
and what features a map needs and not allow a program

01:09:26,950 --> 01:09:29,127
to call into a program which requires more features

01:09:29,127 --> 01:09:30,587
or into a map, which works

01:09:30,587 --> 01:09:33,130
- [Audience Member 2] The main space in universe of the maps

01:09:33,130 --> 01:09:35,460
in the programs are completely different.

01:09:35,460 --> 01:09:37,140
They don't know about each other.

01:09:37,140 --> 01:09:40,320
You could load the map independently of the programs

01:09:40,320 --> 01:09:42,050
and then populate the map with pointers

01:09:42,050 --> 01:09:44,120
to programs that use the unsupported features.

01:09:44,120 --> 01:09:45,230
- I have to - Sure, but that's not

01:09:45,230 --> 01:09:47,760
a problem if the map says using this map

01:09:47,760 --> 01:09:49,054
requires feature (mumbles)

01:09:49,054 --> 01:09:50,920
- [Audience Member 2] Okay that would be a new facility,

01:09:50,920 --> 01:09:52,000
obviously. - Yeah, so you have

01:09:52,000 --> 01:09:54,693
to restrict, you have to restrict the maps.

01:09:55,750 --> 01:09:57,960
- So, for example, like in the XDP case, right,

01:09:57,960 --> 01:10:00,840
couldn't we, on program load,

01:10:00,840 --> 01:10:02,870
also specify the if_index?

01:10:02,870 --> 01:10:05,540
I think we do this today in terms of off load,

01:10:05,540 --> 01:10:06,892
- Wait for the next slide.

01:10:06,892 --> 01:10:08,424
(laughing)

01:10:08,424 --> 01:10:10,180
- That's actually the next slide.

01:10:10,180 --> 01:10:14,020
Virtual solution proposal number two but

01:10:14,020 --> 01:10:17,020
that is if you already proposed that that's good.

01:10:17,020 --> 01:10:17,853
So, (laughing).

01:10:19,600 --> 01:10:22,167
So solution two is to do this load time.

01:10:22,167 --> 01:10:23,700
To prepare for load time because that would actually

01:10:23,700 --> 01:10:27,299
fit how BPF also does the rejection.

01:10:27,299 --> 01:10:30,123
BPF does rejection on load time and not attach time.

01:10:31,320 --> 01:10:34,500
So if, as Daniel says, if you supply the if_index

01:10:34,500 --> 01:10:37,890
at load time, like the hardware off load already does,

01:10:37,890 --> 01:10:39,800
we could do this.

01:10:39,800 --> 01:10:41,930
So, how does this solve the problem

01:10:41,930 --> 01:10:46,693
with the if_index or tail calls?

01:10:48,480 --> 01:10:52,300
So, like Meyers proposed, we have to check the features

01:10:52,300 --> 01:10:53,860
when we insert into a tail call

01:10:55,153 --> 01:10:59,340
that these, that they will match up

01:10:59,340 --> 01:11:02,260
and to do that, I think we have to bind also

01:11:02,260 --> 01:11:04,243
the tail call map to our if_index.

01:11:06,870 --> 01:11:08,900
- I mean, I don't think you really have to bind it,

01:11:08,900 --> 01:11:12,740
but I think like, in tracing case,

01:11:12,740 --> 01:11:16,273
we do have a flag, I think in the BPF prog structure.

01:11:17,230 --> 01:11:21,120
And then when we attach a program to the tail call map,

01:11:21,120 --> 01:11:23,020
we check the feature there as well

01:11:23,020 --> 01:11:24,970
and we could do it for the F index.

01:11:24,970 --> 01:11:28,710
If you are, if you know that this program was loading

01:11:28,710 --> 01:11:30,700
or was supported in the if_index,

01:11:30,700 --> 01:11:35,630
you can attach the, or keep the if_index

01:11:35,630 --> 01:11:38,110
in the BPF prog structure and then

01:11:38,110 --> 01:11:40,690
for all the other programs to there later loaded

01:11:40,690 --> 01:11:41,523
into the tail call maps,

01:11:41,523 --> 01:11:45,280
you can compare whether it's feature compatible, right?

01:11:45,280 --> 01:11:46,880
So, _ Yeah.

01:11:46,880 --> 01:11:50,570
Yeah, that's basically, you want to store the if_index

01:11:50,570 --> 01:11:53,120
to make this match against, you have to

01:11:54,850 --> 01:11:57,640
- You could keep track of basically incompatible features

01:11:57,640 --> 01:11:59,840
so at the beginning, all the features are compatible.

01:11:59,840 --> 01:12:04,290
But then as you start mapping these things to interfaces,

01:12:04,290 --> 01:12:06,740
the features that are unsupported by those drivers

01:12:06,740 --> 01:12:09,460
get marked as incompatible, and then you can't add stuff

01:12:09,460 --> 01:12:11,980
that uses incompatible features in the future.

01:12:11,980 --> 01:12:14,070
- Sounds like a more complex solution.

01:12:14,070 --> 01:12:15,483
What I would do is you ask back

01:12:15,483 --> 01:12:18,890
every time you load a BPF program,

01:12:18,890 --> 01:12:21,250
you have to have the if_index in it,

01:12:21,250 --> 01:12:26,120
asks, asks the driver does this match up with this?

01:12:26,120 --> 01:12:27,410
I want to use this if_index.

01:12:27,410 --> 01:12:28,243
I'm using these features.

01:12:28,243 --> 01:12:30,270
Then you get approval.

01:12:30,270 --> 01:12:31,620
And then once your program is loaded,

01:12:31,620 --> 01:12:33,043
and have a if_index attached, you know

01:12:33,043 --> 01:12:35,240
that this is supported for this device.

01:12:35,240 --> 01:12:38,970
And then when you attach it and want to put it into a map,

01:12:38,970 --> 01:12:42,530
then this map have to have a matching if_index

01:12:43,474 --> 01:12:46,170
then we don't need anything else in a single index.

01:12:46,170 --> 01:12:48,850
- I think your solution would be possible as well.

01:12:48,850 --> 01:12:52,443
And it would be more generic because you could attach

01:12:52,443 --> 01:12:54,453
a program also to another index in the end.

01:12:54,453 --> 01:12:57,130
- So, but it depends on how you represent the features.

01:12:57,130 --> 01:12:58,220
- Right, yes.

01:12:58,220 --> 01:13:01,680
- But, below all the - Which we'll get into

01:13:01,680 --> 01:13:03,257
a long discussion with also.

01:13:03,257 --> 01:13:05,570
- But the good thing in that is you don't have

01:13:05,570 --> 01:13:08,260
to expose the features or how you represent them

01:13:08,260 --> 01:13:09,410
anywhere to user space.

01:13:09,410 --> 01:13:11,120
So it's like only kernel internal.

01:13:11,120 --> 01:13:12,160
And it can change, right?

01:13:12,160 --> 01:13:13,530
So, - Well could you do it

01:13:13,530 --> 01:13:17,510
with maybe BTF so that you annotate the maps

01:13:17,510 --> 01:13:19,894
with the list of restrictions in the program?

01:13:19,894 --> 01:13:21,040
So that when you load the programs,

01:13:21,040 --> 01:13:23,130
you have, you know, a list of restrictions

01:13:23,130 --> 01:13:25,980
and then the if_index is like one of the possible

01:13:25,980 --> 01:13:27,770
restrictions, so you have this general case

01:13:27,770 --> 01:13:29,550
where you can say, I only allow these helpers

01:13:29,550 --> 01:13:30,583
or something?

01:13:30,583 --> 01:13:32,590
(faint talking) Yeah.

01:13:32,590 --> 01:13:34,440
I wonder if this would also help the off load folks

01:13:34,440 --> 01:13:36,550
because right now, they have no hope of supporting

01:13:36,550 --> 01:13:38,430
this kind of maps program, I think , right?

01:13:38,430 --> 01:13:40,510
But if you had an offload chip, you could say,

01:13:40,510 --> 01:13:42,910
I only support these helpers on this map type

01:13:42,910 --> 01:13:44,520
and then they can load the programs as well.

01:13:44,520 --> 01:13:46,700
- Yeah, I think the solution will also,

01:13:46,700 --> 01:13:48,470
also massively help the offload people

01:13:48,470 --> 01:13:51,877
that their if_index will be logged,

01:13:52,960 --> 01:13:54,940
they will log it down to what they support

01:13:54,940 --> 01:13:56,090
and then - and it's,

01:13:56,090 --> 01:13:57,810
I mean, I think BTF is the way forward

01:13:57,810 --> 01:14:00,290
because BTF we already defined, we already have maps

01:14:00,290 --> 01:14:01,570
definitions for BTF.

01:14:01,570 --> 01:14:03,788
So, yeah, you just need a new type

01:14:03,788 --> 01:14:07,210
to program restrictions or something.

01:14:07,210 --> 01:14:10,050
- You would basically have a set of all possible features.

01:14:10,050 --> 01:14:11,067
And then every time you restrict it,

01:14:11,067 --> 01:14:13,390
you would just do set intersection,

01:14:13,390 --> 01:14:15,350
like these are the features and I do now.

01:14:15,350 --> 01:14:17,490
And then you would get a smaller and smaller set.

01:14:17,490 --> 01:14:18,557
You can never increase it.

01:14:18,557 --> 01:14:19,840
You can only restrict it.

01:14:19,840 --> 01:14:21,459
- [Tobi] Like implement it all at once, right?

01:14:21,459 --> 01:14:23,890
You could just implement if index is a start

01:14:23,890 --> 01:14:26,750
as long as you could, in the future, add things.

01:14:26,750 --> 01:14:29,380
- It's pretty common to have multiple interfaces, though.

01:14:29,380 --> 01:14:31,737
And it's very common for them to have the exact same driver

01:14:31,737 --> 01:14:33,300
and the exact same feature sets.

01:14:33,300 --> 01:14:36,840
So binding it seems kind of restrictive.

01:14:36,840 --> 01:14:39,800
Well, binding to feature sets is much less likely

01:14:39,800 --> 01:14:40,963
to cause problems.

01:14:42,290 --> 01:14:45,120
- So, I actually tried to implement this feature set

01:14:45,120 --> 01:14:48,460
stuff but I ran into that you can have maps

01:14:48,460 --> 01:14:49,557
that code into other tail call maps

01:14:49,557 --> 01:14:51,890
that call into another tail call map, so,

01:14:51,890 --> 01:14:54,650
what I had to do, I had to do a full tree traversal

01:14:54,650 --> 01:14:56,120
of all the maps to figure out

01:14:56,120 --> 01:14:57,860
when I want to change something,

01:14:57,860 --> 01:14:59,100
if I want to restrict it more,

01:14:59,100 --> 01:15:02,570
I have to go ask all the maps and then restrict features

01:15:02,570 --> 01:15:04,710
for all the maps and take call into,

01:15:04,710 --> 01:15:06,780
it was, I actually did implementation

01:15:06,780 --> 01:15:09,094
but I was not happy about the complexity.

01:15:09,094 --> 01:15:10,110
- What would be really great

01:15:10,110 --> 01:15:12,410
is that if we actually reached a holy grail

01:15:12,410 --> 01:15:15,890
of all the drivers to support all the XDP features,

01:15:15,890 --> 01:15:18,160
then this would all cancel out very simply.

01:15:18,160 --> 01:15:19,891
- [Jasper] That would solve it in the first place.

01:15:19,891 --> 01:15:20,730
(chuckles)

01:15:20,730 --> 01:15:22,538
- Maybe much less work.

01:15:22,538 --> 01:15:24,910
- But that's like a pipe dream.

01:15:24,910 --> 01:15:27,990
- [Tobi] So, maybe a question then, why do the drivers

01:15:27,990 --> 01:15:29,570
support different feature sets?

01:15:29,570 --> 01:15:30,920
- Why don't - It is insanely

01:15:30,920 --> 01:15:34,160
a lot of complex work to support the full feature set.

01:15:34,160 --> 01:15:36,470
It's not trivial to do it.

01:15:36,470 --> 01:15:38,133
You can't just go into an arbitrary drive, like,

01:15:38,133 --> 01:15:40,040
let's add XDP redirect support,

01:15:40,040 --> 01:15:43,570
no it's really complicated, it's buffer sharing, locking,

01:15:43,570 --> 01:15:45,583
reference counting, it's not easy.

01:15:49,340 --> 01:15:50,770
- I just mentioned in the offload case,

01:15:50,770 --> 01:15:53,680
it may not actually be possible to support all the features,

01:15:53,680 --> 01:15:56,340
except some other concepts don't necessarily map

01:15:56,340 --> 01:15:58,761
to the how do I like (mumbles) maps?

01:15:58,761 --> 01:16:01,480
- Yeah, that's some, hardware offloading.

01:16:01,480 --> 01:16:04,793
You cannot simply possible to have all the features.

01:16:07,100 --> 01:16:08,523
- Tobi, can you get the password?

01:16:12,920 --> 01:16:13,753
Thanks.

01:16:13,753 --> 01:16:15,370
I was just gonna say, we don't always know

01:16:15,370 --> 01:16:16,430
if the if_index were attaching to

01:16:16,430 --> 01:16:18,340
so like if in cases of XDP cap where we're just

01:16:18,340 --> 01:16:21,180
writing programs to pin tail call maps,

01:16:21,180 --> 01:16:22,050
we don't actually know what if_index

01:16:22,050 --> 01:16:23,460
we're attaching the program to,

01:16:23,460 --> 01:16:26,162
so we can't load it with the if_index.

01:16:26,162 --> 01:16:27,710
I don't know how that would work.

01:16:27,710 --> 01:16:30,359
- Yeah, that's sort of a good point.

01:16:30,359 --> 01:16:32,064
Because you have to tail, that's also

01:16:32,064 --> 01:16:33,380
because you use the tail calls,

01:16:33,380 --> 01:16:34,320
right? - Yes.

01:16:34,320 --> 01:16:37,720
- [Jasper] And sometimes you also use the same tail call map

01:16:37,720 --> 01:16:39,840
on different interface, right?

01:16:39,840 --> 01:16:41,060
- You could, yeah, I guess.

01:16:41,060 --> 01:16:42,600
So, one thing that we've been thinking about

01:16:42,600 --> 01:16:44,023
and I think Facebook's Katran does this.

01:16:44,023 --> 01:16:45,800
It's like bonding support.

01:16:45,800 --> 01:16:49,360
The idea that you can attach some XDP program to a bonnet

01:16:49,360 --> 01:16:51,560
interface and the way, it doesn't work right now, obviously

01:16:51,560 --> 01:16:53,420
but the way you fake it is you just

01:16:53,420 --> 01:16:56,900
attach the same XDP program to both interfaces.

01:16:56,900 --> 01:16:58,300
And then you end up in the same path

01:16:58,300 --> 01:17:00,390
and you end up sharing tail call maps,

01:17:00,390 --> 01:17:02,400
all the sort of good stuff.

01:17:02,400 --> 01:17:04,176
Maybe you should just get rid of tail calls, huh?

01:17:04,176 --> 01:17:06,509
(chuckling)

01:17:07,530 --> 01:17:11,780
- Yeah, tail calls have been a pain for a long time.

01:17:11,780 --> 01:17:14,067
(laughing)

01:17:14,067 --> 01:17:15,480
- But it's awesome. - And then

01:17:15,480 --> 01:17:18,640
then with this solution too, I realized that

01:17:18,640 --> 01:17:23,634
oh, shit, generic XDP actually when we move

01:17:23,634 --> 01:17:26,093
this, when we move from attach time to load time,

01:17:27,240 --> 01:17:30,550
at load time, I don't know if this is going to be used

01:17:30,550 --> 01:17:32,773
at the native hook or the generic hook.

01:17:34,160 --> 01:17:36,360
So, I was like, uh oh, how do we solve that?

01:17:38,780 --> 01:17:42,450
So we could say generic is supposed to support everything

01:17:42,450 --> 01:17:43,800
but as David mentioned before,

01:17:43,800 --> 01:17:47,340
we actually have unsupported features.

01:17:47,340 --> 01:17:50,190
- [Tobi] Okay, this is something we have 100% control over.

01:17:50,190 --> 01:17:51,060
- Yeah yeah.

01:17:51,060 --> 01:17:53,360
And someone just needs to kick me

01:17:53,360 --> 01:17:55,170
to actually, to fulfill just

01:17:56,080 --> 01:17:56,913
- [Facilitator] You should kick the guy

01:17:56,913 --> 01:17:58,040
who wrote generic XDP.

01:17:58,040 --> 01:17:59,690
I think he should have to fix all these problems.

01:17:59,690 --> 01:18:00,940
- Yeah, he has to fix it.

01:18:03,660 --> 01:18:04,493
Yeah.

01:18:05,360 --> 01:18:08,393
So, one possible solution is the now okay,

01:18:08,393 --> 01:18:11,620
then we have to supply more information than just if_index

01:18:12,800 --> 01:18:17,720
and say if this is native or generic also.

01:18:17,720 --> 01:18:20,287
But that's sort of annoying from a API perspective

01:18:20,287 --> 01:18:22,880
that we have to supply more information

01:18:22,880 --> 01:18:24,000
to get a bit if_index.

01:18:24,000 --> 01:18:25,093
It could just be the if_index.

01:18:25,093 --> 01:18:27,810
That would be so simple and already supported

01:18:27,810 --> 01:18:30,423
for hardware offloads.

01:18:31,780 --> 01:18:34,350
The second option is that we simply

01:18:35,290 --> 01:18:38,453
need the if_index imply that this is native XDP.

01:18:39,591 --> 01:18:41,720
And then force the inventor of generic XDP

01:18:42,993 --> 01:18:45,170
to implement all the features.

01:18:45,170 --> 01:18:46,920
- So, we have three layers of features.

01:18:46,920 --> 01:18:48,500
We have the hardware off loader case.

01:18:48,500 --> 01:18:51,040
We have the CPU native in the driver case

01:18:51,040 --> 01:18:53,590
and we have generic XDP and they're all different.

01:18:53,590 --> 01:18:54,890
- Yeah.

01:18:54,890 --> 01:18:56,190
That's really nice, right?

01:18:58,160 --> 01:18:59,250
- [Man] Too many features.

01:18:59,250 --> 01:19:00,950
- Yes. - Yeah.

01:19:00,950 --> 01:19:02,100
That's the next discussion.

01:19:02,100 --> 01:19:04,190
How do we then express these features and agree

01:19:04,190 --> 01:19:05,870
on what is the feature?

01:19:05,870 --> 01:19:07,940
- So, I just wondered, maybe, I think somebody

01:19:07,940 --> 01:19:09,380
was maybe half joking when they said

01:19:09,380 --> 01:19:10,740
maybe we just don't allow tail calls.

01:19:10,740 --> 01:19:14,210
But now that we have calls, like proper calls,

01:19:14,210 --> 01:19:16,060
maybe it's not so bad just to say

01:19:16,060 --> 01:19:17,200
we don't support tail calls.

01:19:17,200 --> 01:19:18,323
I mean, from,

01:19:19,450 --> 01:19:20,960
for offloaded XDP.

01:19:20,960 --> 01:19:23,020
- [Person] But it's API now.

01:19:23,020 --> 01:19:24,830
- Yeah but that doesn't mean we have to say,

01:19:24,830 --> 01:19:26,610
going forward, that doesn't mean that it has

01:19:26,610 --> 01:19:27,443
to always work, right?

01:19:27,443 --> 01:19:29,416
It doesn't work now, so.

01:19:29,416 --> 01:19:31,550
(laughing)

01:19:31,550 --> 01:19:33,154
- Yeah.

01:19:33,154 --> 01:19:34,680
Yeah, we always had issues with this and

01:19:34,680 --> 01:19:37,887
- If we say, if we just document it really well

01:19:37,887 --> 01:19:40,540
and throw some warning in the logs,

01:19:40,540 --> 01:19:42,700
and say, like if you're trying to offload stuff

01:19:42,700 --> 01:19:45,004
with XDP and you have tail calls.

01:19:45,004 --> 01:19:46,490
- [Audience Member 1] We could also just turn tail calls

01:19:46,490 --> 01:19:47,503
into a feature.

01:19:48,740 --> 01:19:50,433
That's represented with this and if you use that,

01:19:50,433 --> 01:19:52,340
it's going to be really restrictive

01:19:52,340 --> 01:19:53,580
what you can do with your program

01:19:53,580 --> 01:19:56,460
because lots of places, it wouldn't just be supported.

01:19:56,460 --> 01:19:57,930
- But I think they already have so many problems

01:19:57,930 --> 01:20:00,320
with offloading anyways, like CPU maps

01:20:00,320 --> 01:20:02,870
and helpers and all these other things.

01:20:02,870 --> 01:20:04,130
- Then again, if you do that,

01:20:04,130 --> 01:20:05,820
then you're messing with the people

01:20:05,820 --> 01:20:08,410
who are using tail calls as a solution to

01:20:08,410 --> 01:20:11,180
this multi program problem in their infrastructure

01:20:11,180 --> 01:20:13,750
and suddenly it's off - We're giving them

01:20:13,750 --> 01:20:14,583
a new solution.

01:20:16,130 --> 01:20:18,430
- Yeah, it is also what Toby is proposing,

01:20:18,430 --> 01:20:20,480
then we'll really tie ourselves into tail calls.

01:20:20,480 --> 01:20:22,270
This is like the solution to all, right?

01:20:22,270 --> 01:20:23,950
- [Toby] No, we can answer that without tail calls.

01:20:23,950 --> 01:20:25,480
- [Facilitator] Yeah, you're saying to remove the feature

01:20:25,480 --> 01:20:26,960
you want to use?

01:20:26,960 --> 01:20:28,138
I don't understand. - No but you just convinced me

01:20:28,138 --> 01:20:30,065
I shouldn't use it. (laughing)

01:20:30,065 --> 01:20:30,898
- [Facilitator] Okay, okay.

01:20:32,250 --> 01:20:34,640
- So, but that's that also goes into something David

01:20:34,640 --> 01:20:38,160
has been talking about that we could actually have

01:20:38,160 --> 01:20:41,790
a more library kind of thing that you can actually call

01:20:41,790 --> 01:20:43,000
BFP functions.

01:20:43,000 --> 01:20:45,580
- Yeah, because if you go to real BPF calls

01:20:45,580 --> 01:20:48,360
all this logic about what should we do if there's XDP DROP

01:20:48,360 --> 01:20:51,550
versus XDP Pass, it's cooked into the application.

01:20:51,550 --> 01:20:54,310
It just falls out from the implementation.

01:20:54,310 --> 01:20:55,810
- So we had real function calls

01:20:55,810 --> 01:20:57,160
and - But then each function

01:20:57,160 --> 01:21:00,110
would need to declare which features this function is using.

01:21:00,110 --> 01:21:02,977
And then at link time, you would need to resolve that, so.

01:21:02,977 --> 01:21:05,610
- No, I'm just saying, the thing that you would consider

01:21:05,610 --> 01:21:09,620
multiple programs would be a whole program.

01:21:09,620 --> 01:21:11,880
- [Speaker 1] Yeah, you cannot update it at runtime later.

01:21:11,880 --> 01:21:12,713
- Right.

01:21:12,713 --> 01:21:14,664
- [Speaker 1] But you still need to resolve it across

01:21:14,664 --> 01:21:15,497
- There needs to be some glue thing

01:21:15,497 --> 01:21:17,370
that puts it together in those

01:21:17,370 --> 01:21:19,950
the feature sets of the individual components, right?

01:21:19,950 --> 01:21:21,430
- Yeah. - So

01:21:21,430 --> 01:21:24,410
functions in a BPF in kernel library that's available

01:21:24,410 --> 01:21:26,570
to XDP programs would have tags or something like that.

01:21:26,570 --> 01:21:27,543
- [Speaker 1] Yeah, but then we already

01:21:27,543 --> 01:21:29,980
have the functionality to tag features.

01:21:29,980 --> 01:21:32,600
And then we already have a different way of solving this.

01:21:32,600 --> 01:21:33,433
- Right.

01:21:35,460 --> 01:21:38,260
I don't know how practical it is to turn tail calls off.

01:21:39,200 --> 01:21:40,582
- I only have a couple of slide left.

01:21:40,582 --> 01:21:43,993
And so, people can get out of here.

01:21:45,080 --> 01:21:45,913
So,

01:21:48,920 --> 01:21:53,380
so we really want these features

01:21:53,380 --> 01:21:55,540
to be detectable by the verifier

01:21:55,540 --> 01:21:57,900
because or else we need to supply,

01:21:57,900 --> 01:22:01,010
we need to trust user space to supply us

01:22:01,010 --> 01:22:03,740
with what kind of features that this program actually do

01:22:03,740 --> 01:22:07,796
and I'm not sure we want to trust the input

01:22:07,796 --> 01:22:09,220
we get from there.

01:22:09,220 --> 01:22:12,920
So, we really want the verifier to be able to

01:22:12,920 --> 01:22:14,730
detect the features.

01:22:14,730 --> 01:22:18,120
And one way detection strategy is to reduce

01:22:18,120 --> 01:22:19,420
the features (mumbles) use

01:22:21,147 --> 01:22:23,070
by looking at the return codes.

01:22:23,070 --> 01:22:24,660
We have a huge problem if the return code

01:22:24,660 --> 01:22:27,910
come from a register, we just have to assume everything.

01:22:27,910 --> 01:22:31,620
And we can take out the XDP redirect if the helper is used.

01:22:31,620 --> 01:22:33,640
So, that's the return codes, right?

01:22:33,640 --> 01:22:35,970
- [Facilitator] Also return codes can come from a map.

01:22:35,970 --> 01:22:37,560
- Exactly, that's the problem.

01:22:37,560 --> 01:22:39,560
That's quite difficult to detect, right?

01:22:42,580 --> 01:22:44,370
This is a bit more interesting.

01:22:44,370 --> 01:22:45,710
Return codes are sort of obvious.

01:22:45,710 --> 01:22:48,220
We have to detect those.

01:22:48,220 --> 01:22:50,200
But there's also other things that can depend

01:22:50,200 --> 01:22:51,190
on our driver feature.

01:22:51,190 --> 01:22:53,728
For example, XDP adjust meter, which is

01:22:53,728 --> 01:22:55,593
depend on the driver feature,

01:22:56,700 --> 01:23:00,210
is actually expressed on a, today, it fails runtime.

01:23:00,210 --> 01:23:02,939
I think we can do better if it was a feature.

01:23:02,939 --> 01:23:04,500
We also have the adjust tail,

01:23:04,500 --> 01:23:07,840
which also have influence on some of the features

01:23:07,840 --> 01:23:11,360
we want to implement to have multiple support for XDP

01:23:11,360 --> 01:23:12,273
in the drivers.

01:23:13,130 --> 01:23:15,536
And the verifier, that's really easy to detect

01:23:15,536 --> 01:23:16,890
that will help us in use,

01:23:16,890 --> 01:23:20,623
so that would be also extending the feature bits.

01:23:22,200 --> 01:23:24,700
But we really don't want to expose these feature bits

01:23:24,700 --> 01:23:27,060
as UIP IT users.

01:23:27,060 --> 01:23:30,323
So, if we can get verifier to detect it,

01:23:31,304 --> 01:23:36,304
(mumbles) expiring, exporting this at the user space.

01:23:37,530 --> 01:23:41,650
But then in the end, how do users then ask

01:23:41,650 --> 01:23:43,610
figure out the first question that I always get,

01:23:43,610 --> 01:23:45,410
does my NICs support XDP?

01:23:45,410 --> 01:23:49,440
So, we have to give it express these feature bits

01:23:49,440 --> 01:23:53,060
somehow to user space so that users can see it.

01:23:53,060 --> 01:23:54,070
There's two options.

01:23:54,070 --> 01:23:57,810
It's just to expose these feature bits an ETH tool

01:23:57,810 --> 01:24:00,283
as the, as we already have.

01:24:01,255 --> 01:24:03,205
And every driver, we knew how to do it.

01:24:04,657 --> 01:24:06,420
The other thing is to do probing,

01:24:06,420 --> 01:24:09,230
like bpftool that we load a program

01:24:09,230 --> 01:24:11,920
with these features and see if it fails or not,

01:24:11,920 --> 01:24:14,413
which is a little bit, so.

01:24:15,570 --> 01:24:19,440
- This is not even just a support program loading properly.

01:24:19,440 --> 01:24:21,040
This is a introspection thing.

01:24:21,040 --> 01:24:24,033
Like please give me attributes of my system.

01:24:25,010 --> 01:24:27,270
Like, same like asking what kind of hardware

01:24:27,270 --> 01:24:28,750
is in my machine?

01:24:28,750 --> 01:24:29,670
- Yeah.

01:24:29,670 --> 01:24:31,620
Yeah, so it's - loading a BPF program

01:24:31,620 --> 01:24:35,050
to detect features kind of seems outside that scope.

01:24:35,050 --> 01:24:37,480
And a feature bit export sounds a lot better.

01:24:37,480 --> 01:24:40,167
- Yeah, we already do that a lot or all the drivers.

01:24:40,167 --> 01:24:41,373
But and kind of hardware features.

01:24:41,373 --> 01:24:45,520
- Also if we do it at attach time, that's has side effects.

01:24:45,520 --> 01:24:47,550
So, do I support DROP?

01:24:47,550 --> 01:24:49,600
Oops, I dropped all my packets while I was probing

01:24:49,600 --> 01:24:50,807
for this feature.

01:24:50,807 --> 01:24:53,057
(laughing)

01:24:54,370 --> 01:24:55,400
- Yeah, so you have, yeah,

01:24:55,400 --> 01:24:57,370
you cannot do it at attach time.

01:24:57,370 --> 01:24:59,910
- [Facilitator] Who's running bpftool over and over

01:24:59,910 --> 01:25:01,601
and over again on my machine?

01:25:01,601 --> 01:25:03,800
(laughing)

01:25:03,800 --> 01:25:06,160
- Yeah, so, unfortunately, you know.

01:25:06,160 --> 01:25:08,785
- [Facilitator] We have minus seven minutes.

01:25:08,785 --> 01:25:10,240
(laughing)

01:25:10,240 --> 01:25:12,330
- There's a gap before the break intentionally.

01:25:12,330 --> 01:25:13,700
- Yeah. - There was.

01:25:15,276 --> 01:25:17,380
(chatter) - There were actually

01:25:17,380 --> 01:25:19,410
so, I think we had all (mumbles)

01:25:19,410 --> 01:25:20,830
comments and questions but more.

01:25:20,830 --> 01:25:22,200
- [Facilitator] We can ask questions

01:25:22,200 --> 01:25:23,717
if people wanna talk about stuff.

01:25:23,717 --> 01:25:26,770
- People are allowed to leave now. (chuckles)

01:25:26,770 --> 01:25:28,100
so, you will not be scolded

01:25:28,100 --> 01:25:29,070
if you wanna talk about stuff.

01:25:29,070 --> 01:25:30,603
- [Jasper] The doors are now unlocked.

01:25:30,603 --> 01:25:31,436
(laughing)

01:25:31,436 --> 01:25:35,320
- Wait, we didn't solve the adit subsystem controversy.

01:25:35,320 --> 01:25:36,870
We can't leave.

01:25:36,870 --> 01:25:38,822
- Yeah, that's true but it was with a lecture

01:25:38,822 --> 01:25:39,850
and, is he here?

01:25:39,850 --> 01:25:42,600
- So, Jasper, so one last question

01:25:42,600 --> 01:25:44,743
on the feature deduction.

01:25:45,650 --> 01:25:46,850
It would be actually be really nice

01:25:46,850 --> 01:25:48,810
if the user wouldn't have to do anything at all

01:25:48,810 --> 01:25:50,490
in terms of specifying something.

01:25:50,490 --> 01:25:51,323
- [Jasper] Yes.

01:25:52,350 --> 01:25:53,183
Do we think it's possible?

01:25:53,183 --> 01:25:55,530
- So I'm wondering how feasible it is,

01:25:55,530 --> 01:25:59,620
like, how many XDP native NICs would be present

01:25:59,620 --> 01:26:01,370
in one machine.?

01:26:01,370 --> 01:26:02,910
I'm wondering if you, I mean, like the

01:26:02,910 --> 01:26:06,070
- [Facilitator] We would like that number to decrease.

01:26:06,070 --> 01:26:07,230
- Yes. - Hundreds.

01:26:07,230 --> 01:26:09,630
But I mean, I'm just wondering,

01:26:09,630 --> 01:26:11,730
- I would like to get to - crawling does,

01:26:13,110 --> 01:26:16,580
crawling those features is not like

01:26:16,580 --> 01:26:17,590
doesn't take much, right?

01:26:17,590 --> 01:26:20,120
So, what if you could white list

01:26:21,480 --> 01:26:25,970
all the NICs in the program that would support

01:26:25,970 --> 01:26:28,810
this specific BPF program, right?

01:26:28,810 --> 01:26:30,640
- Oh, you create a subset of if_indexes

01:26:30,640 --> 01:26:32,626
that match what the program is

01:26:32,626 --> 01:26:36,340
- So, so you would keep track like if index is in your name

01:26:36,340 --> 01:26:39,730
space, where this program can be attached to

01:26:39,730 --> 01:26:42,230
because the features are there

01:26:42,230 --> 01:26:43,830
that you, that the verifier crawled

01:26:43,830 --> 01:26:46,360
and found it to be okay.

01:26:46,360 --> 01:26:49,030
And then when you actually attach it,

01:26:49,030 --> 01:26:50,190
it would work just fine.

01:26:50,190 --> 01:26:53,810
But if you want to attach it to some other NIC

01:26:53,810 --> 01:26:56,350
where either it wasn't verified for

01:26:56,350 --> 01:26:58,870
or it's not supported because it's not simply white listed

01:26:58,870 --> 01:26:59,703
for that program.

01:26:59,703 --> 01:27:01,640
You will just reject it there, right?

01:27:01,640 --> 01:27:02,473
I don't know.

01:27:02,473 --> 01:27:03,411
I just...

01:27:03,411 --> 01:27:04,460
- That's more of an internal API thing, right?

01:27:04,460 --> 01:27:06,226
If the driver has an NDO.

01:27:06,226 --> 01:27:07,643
(talking over each other)

01:27:07,643 --> 01:27:10,134
- everything just internal without exposing anything

01:27:10,134 --> 01:27:12,060
(mumbles)

01:27:12,060 --> 01:27:13,267
- That might be an interesting option

01:27:13,267 --> 01:27:16,503
that you can actually see all these if_index are the same.

01:27:16,503 --> 01:27:19,010
They're all supporting features so

01:27:19,010 --> 01:27:21,560
- If you just, I don't know,

01:27:21,560 --> 01:27:24,413
like, maximum 100 NICs, I don't know how much it would.

01:27:29,200 --> 01:27:32,030
- I'm wondering if someone could provide some background

01:27:32,030 --> 01:27:32,997
on how difficult it is

01:27:32,997 --> 01:27:36,048
to add XDP Redirect direct to a driver.

01:27:36,048 --> 01:27:37,400
- [Facilitator] It's a lot of work.

01:27:37,400 --> 01:27:39,063
- [Tobi] You can pass it over that way,

01:27:39,063 --> 01:27:40,800
you'll get some answers.

01:27:40,800 --> 01:27:42,290
- Or just (mumbles) once.

01:27:42,290 --> 01:27:43,150
It does turn around. (talking over each other)

01:27:43,150 --> 01:27:45,806
- Here we go. - It's not

01:27:45,806 --> 01:27:46,639
It's not.

01:27:50,320 --> 01:27:52,386
(chatter)

01:27:52,386 --> 01:27:53,219
(laughing)

01:27:53,219 --> 01:27:54,052
- I've done it a few times.

01:27:54,052 --> 01:27:57,770
It really just depends on how the driver is built.

01:27:57,770 --> 01:27:59,600
The biggest problem is it's so dependent

01:27:59,600 --> 01:28:02,210
on the memory management of the driver

01:28:02,210 --> 01:28:04,280
and page recycling and everything.

01:28:04,280 --> 01:28:05,820
- [Man] We have another talk this afternoon

01:28:05,820 --> 01:28:06,653
about some of that.

01:28:06,653 --> 01:28:09,500
Actually, the major problem is the transmit cubes

01:28:09,500 --> 01:28:10,960
so you have these hidden transmit cubes.

01:28:10,960 --> 01:28:14,730
You have to have allocate one transmit cube per CPU.

01:28:14,730 --> 01:28:17,533
Right now, that's John's fantastic model.

01:28:18,970 --> 01:28:20,626
- [Man] Please come to the next talk this afternoon.

01:28:20,626 --> 01:28:22,080
- We have a whole talk about

01:28:22,080 --> 01:28:24,222
all these problems that John created.

01:28:24,222 --> 01:28:27,183
(laughing)

01:28:27,183 --> 01:28:29,020
They'd actually have to have

01:28:29,020 --> 01:28:33,100
a real understanding of allocating transmit cubes

01:28:33,100 --> 01:28:35,230
and have different types of transmit cubes rate.

01:28:35,230 --> 01:28:36,710
Take a log or you don't take a log.

01:28:36,710 --> 01:28:40,230
So that's actually what the major pitfall

01:28:40,230 --> 01:28:42,150
when you implement XDP and redirect

01:28:42,150 --> 01:28:44,240
that you have to support these transmit cubes

01:28:44,240 --> 01:28:45,510
and how you do that correctly.

01:28:45,510 --> 01:28:47,600
There's also the memory model on top of it,

01:28:47,600 --> 01:28:49,390
which is also fun.

01:28:49,390 --> 01:28:50,830
- [Guy] It's just a bit tricky

01:28:50,830 --> 01:28:52,110
because the drivers are different

01:28:52,110 --> 01:28:52,943
is the biggest problem, right?

01:28:52,943 --> 01:28:54,160
- Right. - I can't go in,

01:28:54,160 --> 01:28:56,340
I mean, I could go into a (mumbles) driver and change it

01:28:56,340 --> 01:28:58,370
and make it support, redirect, although,

01:28:58,370 --> 01:28:59,203
I think it already does (mumbles)

01:28:59,203 --> 01:29:01,010
- It does. - It does.

01:29:01,010 --> 01:29:02,110
- Like some other driver, right?

01:29:02,110 --> 01:29:03,550
But then their queue allocation scheme

01:29:03,550 --> 01:29:04,800
is completely different.

01:29:04,800 --> 01:29:06,560
They do memory buffering completely different

01:29:06,560 --> 01:29:09,830
and maybe we can argue about if that's a good or bad

01:29:09,830 --> 01:29:10,663
in itself.

01:29:10,663 --> 01:29:12,580
- But the thing is it has to work between different drivers.

01:29:12,580 --> 01:29:14,923
That's how redirect has to work for all.

01:29:17,370 --> 01:29:18,460
- Yes, one of the problems is

01:29:18,460 --> 01:29:22,780
there's actually three drivers in particular.

01:29:22,780 --> 01:29:24,810
They all support different allocation schemes.

01:29:24,810 --> 01:29:26,880
They allocate a different number of transmit cubes.

01:29:26,880 --> 01:29:31,140
Some for redirect, some for only for XDPTX, some not.

01:29:31,140 --> 01:29:34,610
So how easy it is depends on how well you know your driver.

01:29:34,610 --> 01:29:37,740
- And then adding support for EFXDP complicates

01:29:37,740 --> 01:29:38,730
this to another level.

01:29:38,730 --> 01:29:40,110
- Yeah, hat is - It is

01:29:40,110 --> 01:29:41,610
all about queue allocation.

01:29:41,610 --> 01:29:43,649
Please come to the afternoon presentation.

01:29:43,649 --> 01:29:44,969
It's a really serious issue.

01:29:44,969 --> 01:29:47,260
- [Male] And it's also like, you can implement redirect

01:29:47,260 --> 01:29:49,480
but it's if you do ti wrong, it's just going

01:29:49,480 --> 01:29:52,457
to drop your packet silently on the floor, right?

01:29:52,457 --> 01:29:53,840
And even if you do it right, it may still

01:29:53,840 --> 01:29:55,560
drop your packet silently on the floor,

01:29:55,560 --> 01:29:56,573
which is why - It sounds like

01:29:56,573 --> 01:29:58,665
a really awesome feature to (mumbles)

01:29:58,665 --> 01:29:59,810
- [Guy] And there are issues redirecting

01:29:59,810 --> 01:30:04,100
from a driver from one driver to another driver.

01:30:04,100 --> 01:30:05,940
There are most of those are solved

01:30:05,940 --> 01:30:08,350
but those are really bad to start with.

01:30:08,350 --> 01:30:12,040
So, there's all sorts of fun things to encounter,

01:30:12,040 --> 01:30:14,360
so, I mean, I think this is one of the nice things

01:30:14,360 --> 01:30:15,560
about the whole thing, I'll say,

01:30:15,560 --> 01:30:17,270
is that you all have really presented

01:30:17,270 --> 01:30:20,880
a lot of the problems that are needed

01:30:20,880 --> 01:30:23,380
when you're thinking of how to distribute this

01:30:23,380 --> 01:30:24,840
and how to support it.

01:30:24,840 --> 01:30:27,570
Up to this point, I feel like it's been

01:30:27,570 --> 01:30:29,700
supported by the hardware vendors

01:30:29,700 --> 01:30:33,010
or supported by the people who are doing a ton of work.

01:30:33,010 --> 01:30:35,040
- [Person] Implemented by hackers for hackers.

01:30:35,040 --> 01:30:35,873
- That's right.

01:30:35,873 --> 01:30:37,390
That's right and I mean, I don't know

01:30:37,390 --> 01:30:40,000
how many times I've had to walk people through

01:30:40,000 --> 01:30:41,420
how do I get it going?

01:30:41,420 --> 01:30:43,030
And, - Yeah,

01:30:43,030 --> 01:30:45,640
this has been about like reducing

01:30:45,640 --> 01:30:47,950
the amount of black magic you need to use this.

01:30:47,950 --> 01:30:48,823
- Right. - Yeah.

01:30:51,947 --> 01:30:54,310
- Still (faint talking) nice hardware.

01:30:54,310 --> 01:30:55,280
- Yeah.

01:30:55,280 --> 01:30:58,550
One a bit different point.

01:30:58,550 --> 01:31:02,180
For the features or limiting the tail call maps

01:31:02,180 --> 01:31:07,180
for particle features, I talk with Arnold yesterday

01:31:08,420 --> 01:31:12,850
about slightly different thing that is attaching programs

01:31:12,850 --> 01:31:16,780
to Trace or to F probes to functions

01:31:16,780 --> 01:31:20,590
and basically, there is really similar thing here

01:31:20,590 --> 01:31:25,060
than we, so the idea was to tracing sk_buff

01:31:25,060 --> 01:31:28,150
throughout the kernel attaching the same program

01:31:28,150 --> 01:31:32,070
to all functions in the kernel that have sk_buff

01:31:32,070 --> 01:31:34,130
as parameter as any parameter.

01:31:34,130 --> 01:31:38,570
So the thing is how to detect better calling

01:31:39,490 --> 01:31:44,490
BPF helper that expects sk_buff as a parameter?

01:31:44,520 --> 01:31:47,570
How can verifier find out that this helper

01:31:47,570 --> 01:31:48,920
is called correctly?

01:31:48,920 --> 01:31:50,150
- [Facilitator] BTF.

01:31:50,150 --> 01:31:52,170
- Yes, you, of course, it's a BTF.

01:31:52,170 --> 01:31:53,490
So, one thing is that,

01:31:53,490 --> 01:31:55,820
so you can of course, take that at runtime

01:31:55,820 --> 01:31:58,710
so the BTF program can enumerate the parameters,

01:31:58,710 --> 01:32:01,650
find out which are sk_buff based in BTF

01:32:01,650 --> 01:32:04,800
and then call helper but that is runtime overhead.

01:32:04,800 --> 01:32:06,770
That's unnecessary.

01:32:06,770 --> 01:32:08,700
So one of the, Tony, I did

01:32:08,700 --> 01:32:10,830
- [Facilitator] The overhead would be at attach point.

01:32:10,830 --> 01:32:12,110
- It will not

01:32:12,110 --> 01:32:13,917
because - those are tail calls,

01:32:13,917 --> 01:32:15,730
'cause they're tail calls, okay, I understand.

01:32:15,730 --> 01:32:20,050
- So, but it could be if you specify

01:32:20,050 --> 01:32:21,840
while loading the program.

01:32:21,840 --> 01:32:24,020
Okay, this program expects

01:32:24,020 --> 01:32:26,650
or can be attached only to functions

01:32:26,650 --> 01:32:29,360
that have sk_buff as a first

01:32:29,360 --> 01:32:31,110
or the second parameter.

01:32:31,110 --> 01:32:35,900
And then just, but and then we're at the same problem.

01:32:35,900 --> 01:32:40,090
We're limiting the, where the program can be attached to,

01:32:40,090 --> 01:32:42,140
at load time and this is really the same.

01:32:43,950 --> 01:32:48,610
- It seems like it's because we created a separation,

01:32:48,610 --> 01:32:51,680
there are program types where the context is fixed.

01:32:51,680 --> 01:32:52,930
And then we have these F probes

01:32:52,930 --> 01:32:54,980
where it's a variable context, basically.

01:32:57,722 --> 01:33:01,900
- So, I think in tracing, we do have this return code

01:33:01,900 --> 01:33:02,780
overwrite.

01:33:02,780 --> 01:33:04,770
I think that Yung Huang can confirm.

01:33:04,770 --> 01:33:09,113
And I think in tail calls, we do have a bit for that.

01:33:10,710 --> 01:33:13,360
And that would be checked in the call map, right.

01:33:13,360 --> 01:33:16,103
It's not that pretty but it seems to work, so.

01:33:17,359 --> 01:33:18,891
- Yeah. - Nice.

01:33:18,891 --> 01:33:19,724
- Yeah, should we take,

01:33:19,724 --> 01:33:20,557
should we take a (mumbles) time?

01:33:20,557 --> 01:33:22,087
- The question is how to make it generic.

01:33:22,087 --> 01:33:24,710
The code to make it more generic, right?

01:33:24,710 --> 01:33:27,260
- I think that, I think the rest is hallway talk, right?

01:33:27,260 --> 01:33:28,580
- Yeah. - I think so.

01:33:28,580 --> 01:33:29,413
- Good.

01:33:29,413 --> 01:33:30,743
Okay one last, one last comment.

01:33:31,750 --> 01:33:36,750
- [Speaker 1] Okay and one thing, Tokay said that you're,

01:33:38,550 --> 01:33:42,050
I mean that tail calls they, there's to be agreement

01:33:42,050 --> 01:33:43,410
that tail calls are problem.

01:33:43,410 --> 01:33:45,660
You said that it invalidates your solution

01:33:45,660 --> 01:33:46,840
by seven tail calls.

01:33:46,840 --> 01:33:49,480
I would argue those are not really tail calls

01:33:49,480 --> 01:33:54,480
or at least the problems do not affect your thing

01:33:54,500 --> 01:33:58,023
because we are bound to a particular index only.

01:33:59,860 --> 01:34:01,853

YouTube URL: https://www.youtube.com/watch?v=NpDoK6kmGe0


