Title: LPC2019 - Upstream Graphics: Too little, too late
Publication date: 2019-09-17
Playlist: Linux Plumbers Conference 2019
Description: 
	Upstream Graphics: Too little, too late

Speaker
 Daniel Vetter (Intel)
Description
DRM is merging new drivers at a brisk pace, and with lima and panfrost to support ARM Mali GPUs the last obvious gap in not yet reverse-engineered hardware is getting closed. Plus new features, more contributors, more patches - in general upstream graphics is as healthy as it's never been before.

Time for some celebratory drinks, except this talk will be none of that. Now that we've achieved the goal of supporting all things graphics in upstream, the struggles didn't disappear. The promised land of "Upstream First" is leaving a rather sour aftertaste.

This talk will go through all the ways companies and teams have tried to ship graphics drivers using upstream, and how they all go wrong.

It will, unfortunately, not present solutions.
Captions: 
	00:00:00,250 --> 00:00:03,990
- Well yeah it's working, before it was blank.

00:00:03,990 --> 00:00:07,470
So when I was looking at the CFP for Plumbers

00:00:07,470 --> 00:00:10,215
and kernel summit, I was like thinking,

00:00:10,215 --> 00:00:11,745
well I have a little bit of this reputation

00:00:11,745 --> 00:00:13,050
of doing highly critical talks,

00:00:13,050 --> 00:00:15,203
I need to find a topic to complain about.

00:00:16,178 --> 00:00:17,128
And the trouble is,

00:00:24,132 --> 00:00:25,453
things are going great in graphics.

00:00:27,167 --> 00:00:28,517
So I think this is like the much more

00:00:28,517 --> 00:00:31,577
honest title for this talk because if you look back

00:00:31,577 --> 00:00:36,577
10 years ago we merged GEM, the graphics execution manager

00:00:37,730 --> 00:00:40,120
managing rendering and graphics memory.

00:00:40,120 --> 00:00:43,280
We merged kernel modesetting roughly

00:00:43,280 --> 00:00:45,340
also about 10 years ago.

00:00:45,340 --> 00:00:48,937
We had the Intel driver and the AMD driver

00:00:48,937 --> 00:00:51,430
on also about 10 years ago.

00:00:51,430 --> 00:00:53,500
We were proudly celebrating achievement

00:00:53,500 --> 00:00:56,453
of OpenGL 2 10 years behind the industry.

00:00:58,371 --> 00:01:01,023
So (laughs) it was pretty bad.

00:01:03,568 --> 00:01:07,509
It was a bit of R and D project

00:01:07,509 --> 00:01:12,450
like TCOMP companies and a few distros and that's it.

00:01:12,450 --> 00:01:14,810
And if you compare this to today,

00:01:14,810 --> 00:01:18,448
the graphics subsystem has grown a lot.

00:01:18,448 --> 00:01:23,140
About 10% of the kernel doesn't really matter.

00:01:23,140 --> 00:01:25,890
You take lines of codes and commits with people, whatever.

00:01:25,890 --> 00:01:29,670
It's a round out but it was about equal size again

00:01:29,670 --> 00:01:32,947
in user space for the GL drivers Vulkan.

00:01:32,947 --> 00:01:34,547
I came in just last week and apparently,

00:01:34,547 --> 00:01:39,547
we have 50 modesetting atomic modeset drivers

00:01:39,870 --> 00:01:43,486
so that's the latest and greatest stuff.

00:01:43,486 --> 00:01:46,050
We have the latest OpenGl almost.

00:01:46,050 --> 00:01:49,980
The GLES for socks, we have Vulkan drivers.

00:01:49,980 --> 00:01:54,463
And just one number that's astonishing at least to me.

00:01:55,920 --> 00:01:58,923
The smallest driver, and it's not just a component driver.

00:01:58,923 --> 00:02:02,300
It's an actual DRM subsystem graphics driver

00:02:02,300 --> 00:02:04,830
that we have is about 250 lines.

00:02:04,830 --> 00:02:07,380
And I looked at it, it's an actual driver.

00:02:07,380 --> 00:02:09,700
You could maybe spend another 15 lines

00:02:09,700 --> 00:02:13,010
for suspend resume support. (audience laughs)

00:02:13,010 --> 00:02:15,855
But that's like one end and then the other end,

00:02:15,855 --> 00:02:17,618
we have over two million lines

00:02:17,618 --> 00:02:19,994
of code for the AMD thing so we have full orders

00:02:19,994 --> 00:02:23,963
of magnitude between the smallest and the biggest.

00:02:25,391 --> 00:02:30,391
So it's really, the subsystem really started going.

00:02:31,920 --> 00:02:36,810
So I wanna bit explain how and why we achieved this.

00:02:36,810 --> 00:02:40,830
One thing is definitely the Atomic Modeset APR

00:02:40,830 --> 00:02:42,910
which is a complete revamp we've done

00:02:42,910 --> 00:02:45,853
a few years ago of the kernel modesetting

00:02:45,853 --> 00:02:48,650
with a lot more support for planes

00:02:48,650 --> 00:02:51,599
to make the small SoCs happy and the super low power users.

00:02:51,599 --> 00:02:55,590
Just better support for lots of outputs.

00:02:55,590 --> 00:03:00,590
We have blending, writeback, color space conversions

00:03:00,710 --> 00:03:03,849
for all the fancy new TVs and the high definition stuff.

00:03:03,849 --> 00:03:08,730
Still gracefully handling display pulled link failures

00:03:08,730 --> 00:03:10,273
which apparently is a thing.

00:03:11,773 --> 00:03:13,323
We even have content protection.

00:03:14,526 --> 00:03:19,526
So it's really, we have with Atomic

00:03:21,040 --> 00:03:23,180
I really think we've achieved the goal

00:03:23,180 --> 00:03:26,163
to have one display API to rule them all.

00:03:28,011 --> 00:03:33,011
A similar things on the rendering side.

00:03:33,071 --> 00:03:37,983
Before Atomic Modesetting, we essentially just had

00:03:39,720 --> 00:03:44,493
a hodgepodge of incompatible stuff without much sharing.

00:03:45,670 --> 00:03:49,430
We now have a DMA buff, across the road

00:03:49,430 --> 00:03:52,042
with buffer up checks for zero copy buffer sharing.

00:03:52,042 --> 00:03:55,860
We have DMA reservations which handle access

00:03:55,860 --> 00:03:58,140
from drivers to make sure that they're not

00:03:58,140 --> 00:03:59,980
all standing on top of each other.

00:03:59,980 --> 00:04:04,310
But all the DMA access is nicely pipelined

00:04:04,310 --> 00:04:06,190
and nicely synchronized.

00:04:06,190 --> 00:04:10,613
We have DMA fences to track what the GPU's doing

00:04:13,240 --> 00:04:17,563
or anything else and again, that's cross driver.

00:04:18,563 --> 00:04:20,960
It can just pass them around which is really nice

00:04:20,960 --> 00:04:24,430
for some of the server workloads

00:04:24,430 --> 00:04:26,402
where you just plug in one GPU

00:04:26,402 --> 00:04:28,848
after another until your box is full.

00:04:28,848 --> 00:04:31,460
Or for SSEs where you have lots

00:04:31,460 --> 00:04:33,570
of little small drivers, one for display,

00:04:33,570 --> 00:04:35,860
one for rendering, one for the camera,

00:04:35,860 --> 00:04:37,610
and they all need to work together.

00:04:39,738 --> 00:04:42,797
We have this wait wound mutex that we landed

00:04:42,797 --> 00:04:47,565
almost 10 years ago which was just fancy edition

00:04:47,565 --> 00:04:52,040
to plain kernel mutexes for graph locking problems

00:04:52,040 --> 00:04:56,350
and apparently we have a lot of those in graphics drivers.

00:04:56,350 --> 00:05:00,670
We made a fancy new synchronization object thingy

00:05:00,670 --> 00:05:05,670
off of Vulkan for better user space API for fences.

00:05:06,970 --> 00:05:11,970
So lots of great cross vendor stuff there.

00:05:14,695 --> 00:05:18,972
Now this is the interfaces, the cross-driver stuff.

00:05:18,972 --> 00:05:23,856
The other thing, and really that's the story

00:05:23,856 --> 00:05:26,810
between the 250 line complete kernel driver

00:05:26,810 --> 00:05:31,265
is we have an enormous amount of helpful libraries nowadays.

00:05:31,265 --> 00:05:34,080
So if you have a simple piece of hardware,

00:05:34,080 --> 00:05:36,680
essentially you write a few lines

00:05:38,172 --> 00:05:40,688
of code and then you just glue together

00:05:40,688 --> 00:05:41,863
your real driver with the helpers.

00:05:43,066 --> 00:05:45,103
So if you look at that 250 line driver,

00:05:46,524 --> 00:05:48,420
essentially it's about 1/3 include files

00:05:49,333 --> 00:05:51,210
and whitespace and curly braces.

00:05:51,210 --> 00:05:54,510
About 1/3 of it is just the vtables

00:05:54,510 --> 00:05:57,760
filling out the existing helpers, they still need it.

00:05:57,760 --> 00:06:02,380
And 1/3 is just one function that lights up the panel

00:06:02,380 --> 00:06:05,410
because that's the one nonstandard port.

00:06:05,410 --> 00:06:10,410
So we have a really nice modeler helpers

00:06:11,180 --> 00:06:15,126
for the display side so it's not

00:06:15,126 --> 00:06:17,090
just one block but you can pick and choose

00:06:17,090 --> 00:06:20,233
the bits and pieces, pardon, that you want.

00:06:21,197 --> 00:06:23,273
And you know the others are right here around.

00:06:24,480 --> 00:06:26,990
We have on top of the Atomic stuff

00:06:26,990 --> 00:06:31,060
because Atomic as I explained rules the world,

00:06:31,060 --> 00:06:36,060
is way too powerful and feature-full for simple displays.

00:06:36,750 --> 00:06:38,730
But you might just have one display

00:06:38,730 --> 00:06:41,840
and it can do nothing else than small panels

00:06:41,840 --> 00:06:44,360
somewhere on a box, embedded box.

00:06:44,360 --> 00:06:49,023
So for those we have the simple display pipe helpers

00:06:49,023 --> 00:06:51,230
that just break all that complexity down

00:06:51,230 --> 00:06:54,897
to four callbacks or something like that

00:06:54,897 --> 00:06:56,940
and they're all optional.

00:06:56,940 --> 00:07:01,433
We have helpers for all the output standards out there.

00:07:02,482 --> 00:07:05,300
DisplayPort, MIPI is the standards

00:07:05,300 --> 00:07:08,810
for all the panels in tablets and phones.

00:07:08,810 --> 00:07:13,696
HDMI of course with all the slightly funny things

00:07:13,696 --> 00:07:17,459
that TV do, unrequired, EDID is the metadata

00:07:17,459 --> 00:07:20,671
of the packet that most displays send

00:07:20,671 --> 00:07:24,901
back to you to tell you what to do.

00:07:24,901 --> 00:07:29,753
We have helpers for a lot of the power saving features

00:07:29,753 --> 00:07:32,558
that you use in small panels and tablets

00:07:32,558 --> 00:07:37,210
like if you just freeze the entire machine

00:07:37,210 --> 00:07:39,139
and just keep the display alive,

00:07:39,139 --> 00:07:41,823
that's called self refresh for display.

00:07:41,823 --> 00:07:45,710
We have nice pile of functions

00:07:45,710 --> 00:07:47,599
that you can just plug in and it's alll taken care of.

00:07:47,599 --> 00:07:50,062
Or damage tracking, if you just upload

00:07:50,062 --> 00:07:54,402
the blinking cursor not always everything.

00:07:54,402 --> 00:07:56,570
Saves a lot of memory bandwidth

00:07:56,570 --> 00:07:58,150
and all the power expense.

00:07:58,150 --> 00:08:02,140
And of course we have the old fbdev subsystem,

00:08:02,140 --> 00:08:04,640
back 10 years ago when we merged

00:08:04,640 --> 00:08:07,070
kernel modesetting a lot of people were

00:08:07,070 --> 00:08:09,961
I saw this already this kernel modesetting thing.

00:08:09,961 --> 00:08:14,320
And fbdev subsystem, why are you not using it?

00:08:14,320 --> 00:08:16,976
And I think we've superseded it now so well

00:08:16,976 --> 00:08:21,094
that with one line in the fbdev emulation

00:08:21,094 --> 00:08:24,430
to enable this and wire it up.

00:08:24,430 --> 00:08:27,969
You have a fully functioning fbdev driver

00:08:27,969 --> 00:08:32,168
written in the new Atomic modeset infrastructure.

00:08:32,168 --> 00:08:36,300
I think some examples were in four times fewer lines

00:08:36,300 --> 00:08:40,870
of code than the old thing but roughly same featureset.

00:08:42,723 --> 00:08:44,163
And we have more helpers!

00:08:45,800 --> 00:08:50,330
On the rendering side we have a nice generic GPU scheduler

00:08:50,330 --> 00:08:53,750
nowadays that people are not too appreciative

00:08:53,750 --> 00:08:57,655
if their background compute job makes the desktop freeze.

00:08:57,655 --> 00:09:01,506
Things like that are, there's a lot

00:09:01,506 --> 00:09:06,483
of work going on around TTM which is the thing

00:09:06,483 --> 00:09:09,824
to manage VRAM and things like that.

00:09:09,824 --> 00:09:13,360
Making it a bit more modular so you can pick and choose.

00:09:13,360 --> 00:09:16,553
A lot of that has already been done, pulling out concepts.

00:09:17,610 --> 00:09:19,460
And algorithms and locking...

00:09:23,465 --> 00:09:26,330
Locking algorithms and locking primitives.

00:09:26,330 --> 00:09:30,060
And again we have the subsystem

00:09:30,060 --> 00:09:32,738
that needs to scale by a factor of 10,000.

00:09:32,738 --> 00:09:37,187
So if we have the fancy super complex helpers

00:09:37,187 --> 00:09:40,750
on one side we also have the super simple helpers

00:09:40,750 --> 00:09:42,622
on the other side so we can actually

00:09:42,622 --> 00:09:46,370
write a driver in 250 lines of code

00:09:46,370 --> 00:09:51,370
so we have helpers for the simple displays

00:09:51,435 --> 00:09:55,030
that only have a little bit of VRAM and do nothing else.

00:09:55,030 --> 00:09:57,100
Nowadays they're mostly found on servers.

00:09:57,100 --> 00:10:00,662
So that's the last set of drivers that we made

00:10:00,662 --> 00:10:04,743
to take over for fbdev before we can sunset that.

00:10:06,237 --> 00:10:08,733
We have shared memory helpers,

00:10:09,838 --> 00:10:12,863
which is the equivalent for simple display drivers on socks.

00:10:12,863 --> 00:10:17,863
We have the CMA DMA helpers for the slightly less capable

00:10:19,052 --> 00:10:23,830
display blocks that need contiguous DMA memory.

00:10:23,830 --> 00:10:28,190
With everything we've been trying really hard

00:10:28,190 --> 00:10:31,770
to make the batteries included there by default.

00:10:31,770 --> 00:10:35,140
So you just write the driver and you get

00:10:35,140 --> 00:10:37,603
reasonable default behavior for everything.

00:10:39,240 --> 00:10:44,240
So things are working really great on the helper front.

00:10:45,610 --> 00:10:50,350
Then more awesome stuff, over the past 10 years,

00:10:50,350 --> 00:10:52,942
with the SOCs they're a lot more modular

00:10:52,942 --> 00:10:57,610
with s86 where open source graphics drivers

00:10:57,610 --> 00:11:01,500
started out you just got one GPU from AMD

00:11:01,500 --> 00:11:05,010
or Intel or whoever, it contains everything

00:11:05,010 --> 00:11:07,200
and it's all vendor specific.

00:11:07,200 --> 00:11:10,327
You just smash it in one driver and you're good.

00:11:10,327 --> 00:11:12,812
But in the SOC side there's a lot more sharing

00:11:12,812 --> 00:11:17,050
of little IP blocks and SSE going on.

00:11:17,050 --> 00:11:21,890
So we have bridge drivers that support transcoders

00:11:21,890 --> 00:11:24,770
or the display block as an output

00:11:24,770 --> 00:11:26,370
and then there's a bridge driver

00:11:27,702 --> 00:11:29,298
that converts that output into something

00:11:29,298 --> 00:11:31,300
that an HDMI TV can understand.

00:11:31,300 --> 00:11:34,930
And similar for panels because

00:11:34,930 --> 00:11:38,790
of all this semi-smart power saving

00:11:38,790 --> 00:11:42,540
for HSD panels need quite a bit of control logic.

00:11:42,540 --> 00:11:45,398
And of course every panel is different.

00:11:45,398 --> 00:11:49,300
Every revision of a panel happens to be different.

00:11:49,300 --> 00:11:53,230
So we have, I think, I honestly don't know.

00:11:53,230 --> 00:11:55,095
A massive pile of panel drivers

00:11:55,095 --> 00:11:59,520
that you can nicely can connect them with DT.

00:11:59,520 --> 00:12:01,290
Plug it all in so you have one driver

00:12:01,290 --> 00:12:02,913
and plug in the panel.

00:12:04,269 --> 00:12:07,190
And in general there's been a lot of work

00:12:07,190 --> 00:12:12,190
to componentizing the rather monolithic DRM approach

00:12:12,700 --> 00:12:14,773
to make it fit for SSEs.

00:12:14,773 --> 00:12:19,773
We are on track to fix the hot unplug issues

00:12:20,040 --> 00:12:25,040
so nowadays if you plug out a DP multistream dock

00:12:26,230 --> 00:12:28,600
or something that the machine doesn't freeze

00:12:28,600 --> 00:12:32,303
that often anymore. (audience laughs)

00:12:33,389 --> 00:12:37,690
And it is a lot of hard work.

00:12:37,690 --> 00:12:41,476
The same thing with USB docks and things like that.

00:12:41,476 --> 00:12:44,470
We're straining out all the referencing counting

00:12:44,470 --> 00:12:46,053
madness there and all the bugs.

00:12:47,561 --> 00:12:52,040
We've also done massive improvements

00:12:52,040 --> 00:12:56,250
in terms of selftests and regression tests.

00:12:56,250 --> 00:12:59,030
So the past two years we've added a lot

00:12:59,030 --> 00:13:02,960
of in-kernel regression tests in DRM

00:13:02,960 --> 00:13:06,260
just for the helpers, just mock a DRM drive

00:13:07,193 --> 00:13:08,160
and do a bunch of transactions

00:13:08,160 --> 00:13:10,810
and things and make sure the helper actually

00:13:10,810 --> 00:13:13,910
follows the contract that we think it should follow.

00:13:13,910 --> 00:13:18,150
So big shoutout to KUnit, we really wanna see

00:13:18,150 --> 00:13:20,960
this thing land so we can go away

00:13:20,960 --> 00:13:24,380
from dock tape to something slightly more structured.

00:13:24,380 --> 00:13:27,697
And on the userspace side, for the IOCTLs,

00:13:27,697 --> 00:13:29,950
especially on the modeset side

00:13:29,950 --> 00:13:33,788
with the Atomic Modesetting, lots more features.

00:13:33,788 --> 00:13:36,140
Lots more potential that the drivers

00:13:36,140 --> 00:13:37,823
don't implement it the same way.

00:13:38,990 --> 00:13:42,580
So we're working to some nice cross-vendor standards.

00:13:42,580 --> 00:13:46,969
Then of course, like I said, graphics is the same

00:13:46,969 --> 00:13:49,570
science again in userspace.

00:13:49,570 --> 00:13:52,673
So it is a lot of awesome stuff going on in userspace.

00:13:54,570 --> 00:13:57,600
One thing is the gallium stack.

00:13:57,600 --> 00:14:01,374
This is framework for providing a GL driver.

00:14:01,374 --> 00:14:06,374
Now also supported by Intel, pretty soon

00:14:07,080 --> 00:14:11,933
after being a holdout for almost 10 years.

00:14:14,400 --> 00:14:18,930
Then over the past 10 years for the userspace stack

00:14:18,930 --> 00:14:22,185
you need a compiler for your shaders that run on the GPU.

00:14:22,185 --> 00:14:27,185
And we've had quite a bit of GPU compiler struggles

00:14:29,330 --> 00:14:34,330
with LLBM competing, two, three different kind

00:14:37,230 --> 00:14:39,160
of intermediate representations.

00:14:39,160 --> 00:14:42,520
And their entire ball of optimization passes

00:14:42,520 --> 00:14:45,870
in the openGL and the Mesa 3D stack.

00:14:45,870 --> 00:14:49,292
And I think it's now looking like they'll be settling

00:14:49,292 --> 00:14:53,490
on the one true compiler stack to rule them all.

00:14:53,490 --> 00:14:56,850
At least on the backend side, at least from compute,

00:14:56,850 --> 00:14:58,463
they're still gonna be LLVM.

00:14:59,550 --> 00:15:03,490
Taking OpenCL kernels or whatever.

00:15:03,490 --> 00:15:07,326
Another thing is also that the reverse engineering tools

00:15:07,326 --> 00:15:10,881
that the Invidia reverse engineering people started

00:15:10,881 --> 00:15:15,881
over 10 years ago, they're really nice now.

00:15:16,200 --> 00:15:20,040
On some driver engineers from teams

00:15:20,040 --> 00:15:23,210
that do open source from the hardware vendors side

00:15:23,210 --> 00:15:25,180
have been heard saying that they're better

00:15:25,180 --> 00:15:28,510
than their internal tools for managing

00:15:28,510 --> 00:15:31,483
register sets and instructioning coding.

00:15:32,903 --> 00:15:34,713
And also it's all...

00:15:37,150 --> 00:15:42,030
Also really nice for moving the userspace side

00:15:42,030 --> 00:15:45,910
of the stack forward then we have Khronos,

00:15:45,910 --> 00:15:49,010
which is the standards committee for OpenGL

00:15:49,010 --> 00:15:50,896
or standards group for OpenGL

00:15:50,896 --> 00:15:53,166
and Vulkan and all these things.

00:15:53,166 --> 00:15:55,496
And Khronos has started opening up.

00:15:55,496 --> 00:15:57,110
There's now an opensource test suite

00:15:58,402 --> 00:16:01,833
for Vulkan and GLES and significant chunks of GL.

00:16:03,270 --> 00:16:07,454
And they're moving away from the very closed

00:16:07,454 --> 00:16:12,454
industry group that GL has been 10 plus years ago.

00:16:17,213 --> 00:16:20,330
More great stuff in userspace.

00:16:20,330 --> 00:16:23,170
We have a massive pile of reverse engineer drivers.

00:16:23,170 --> 00:16:26,947
Panfrost is for the modern or new rMali chips.

00:16:28,926 --> 00:16:33,173
Lima is for the first generation rMali chips.

00:16:34,210 --> 00:16:39,210
Freedreno is for the Qualcomm, the Reno GPUs.

00:16:39,683 --> 00:16:41,870
Etnaviv is for Vivante GPUs.

00:16:41,870 --> 00:16:44,510
I think they're move used in very constrained

00:16:44,510 --> 00:16:48,787
embedded situations, a lot more on the powered.

00:16:48,787 --> 00:16:53,600
I said it already, Intel abandoned

00:16:53,600 --> 00:16:58,600
or is on track to abandon their separate train

00:16:59,650 --> 00:17:04,590
and is now also writing a GL driver

00:17:04,590 --> 00:17:06,730
using this Gallium framework.

00:17:06,730 --> 00:17:09,548
So even in userspace we have enormous amounts

00:17:09,548 --> 00:17:14,548
of codesharing which allows us

00:17:15,100 --> 00:17:18,364
to reverse engineer and develop drivers

00:17:18,364 --> 00:17:22,310
with ridiculously few people compared

00:17:22,310 --> 00:17:27,263
with the proprietary teams in fairly little time.

00:17:28,440 --> 00:17:31,734
And I think one thing, one example is

00:17:31,734 --> 00:17:36,734
that exemplifies this is AMD was a bit light

00:17:38,450 --> 00:17:43,340
with their Vulkan driver, took quite a bit longer

00:17:43,340 --> 00:17:46,170
in legal review to get that thing out the door.

00:17:46,170 --> 00:17:48,040
A bunch of people got bored and figured

00:17:48,040 --> 00:17:50,040
that they learned Vulkan, this shiny new

00:17:51,247 --> 00:17:56,247
3D and compute graphics API by just writing a driver.

00:17:58,152 --> 00:18:00,660
And the thing is now with this driver,

00:18:00,660 --> 00:18:04,863
just a few people, few customers between Google and Vulf

00:18:04,863 --> 00:18:09,863
and Redhat are reusing all the infrastructure

00:18:10,720 --> 00:18:13,670
we have shared code to interact

00:18:13,670 --> 00:18:17,610
with the compositors and all the baseline infrastructure.

00:18:17,610 --> 00:18:21,441
Plus all this, the compiler infrastructure

00:18:21,441 --> 00:18:24,150
that we now have, we now have this radv Vulkan

00:18:26,860 --> 00:18:31,860
AMD driver and new AMD compiler thing called ACO.

00:18:32,114 --> 00:18:36,000
Which was done, like I said, by one handful of people.

00:18:36,000 --> 00:18:41,000
Really about this many and it's beating AMD.

00:18:42,660 --> 00:18:46,180
So it's on par or better across the board.

00:18:46,180 --> 00:18:51,180
And so same story in the kernel as in userspace.

00:18:54,280 --> 00:18:56,880
We've developed so many helpers,

00:18:56,880 --> 00:19:00,890
so much shared code, so much experience as a community

00:19:01,864 --> 00:19:06,864
that we can develop open source GPU drivers

00:19:08,132 --> 00:19:13,132
really well and cheaply and we're getting there.

00:19:14,390 --> 00:19:19,220
So another thing, going towards the community.

00:19:21,741 --> 00:19:24,540
The moving over to gitlab everywhere

00:19:24,540 --> 00:19:28,633
means mostly userspace, the kernel is quite lacking.

00:19:29,605 --> 00:19:31,925
I made a talk last year but for a bunch

00:19:31,925 --> 00:19:33,120
of infrastructure reasons we haven't

00:19:33,120 --> 00:19:35,390
really moved on the kernel side.

00:19:35,390 --> 00:19:38,630
But Mesa3D, the GL Vulkan project

00:19:38,630 --> 00:19:41,340
is fully embracing merge requests.

00:19:41,340 --> 00:19:45,240
Firing up CIs so that every merge request

00:19:45,240 --> 00:19:48,307
gets tested and you can't push broken stuff.

00:19:48,307 --> 00:19:52,360
And I think just about now, the first hardware CI

00:19:52,360 --> 00:19:55,681
is getting integrated so you do a merge request

00:19:55,681 --> 00:20:00,681
and it gets tested I think on freedreno hardware

00:20:00,950 --> 00:20:05,950
by in a CI that Google is paying for.

00:20:08,760 --> 00:20:10,920
Yeah like I said the kernel is stuck

00:20:11,840 --> 00:20:15,190
on quite a bit of infrastructure work unfortunately.

00:20:15,190 --> 00:20:17,660
So hopefully we can get going.

00:20:17,660 --> 00:20:20,025
On the other hand it's really nice

00:20:20,025 --> 00:20:21,270
if the userspace people figure this out

00:20:21,270 --> 00:20:24,023
so we know what works and what doesn't work.

00:20:24,023 --> 00:20:26,972
Another thing is XDC, our conference,

00:20:26,972 --> 00:20:30,720
has been growing quite a bit and we need

00:20:30,720 --> 00:20:34,303
to actually reject talks and discussion proposals nowadays.

00:20:35,621 --> 00:20:39,540
We're using the same software as Plumbers

00:20:39,540 --> 00:20:41,788
so that works fairly well.

00:20:41,788 --> 00:20:43,193
We've done this the first time this year.

00:20:44,515 --> 00:20:48,180
And XDC has sponsors now since two years.

00:20:48,180 --> 00:20:51,640
So another sign that we're growing up

00:20:51,640 --> 00:20:54,630
and no longer a bunch of bored students

00:20:54,630 --> 00:20:58,420
with working together with a tiny R and D team

00:20:58,420 --> 00:21:02,690
to do a tag team of opensource graphics

00:21:02,690 --> 00:21:03,903
might be a real thing.

00:21:04,780 --> 00:21:08,360
We've been growing up a lot, so it's like

00:21:08,360 --> 00:21:10,120
lots of great stuff but...

00:21:13,413 --> 00:21:17,959
There's... (audience laughs)

00:21:17,959 --> 00:21:22,350
There is a bit of an embarrassment. (laughs)

00:21:22,350 --> 00:21:26,690
Going on so I think I need to address

00:21:26,690 --> 00:21:30,091
the talk title once more. (audience laughs)

00:21:30,091 --> 00:21:32,440
I mean to look a bit about the elephant

00:21:32,440 --> 00:21:36,080
in the room because that thing's not working great.

00:21:37,850 --> 00:21:42,850
And I think we need to look, one side is

00:21:43,306 --> 00:21:48,306
NVIDIA does create great GPUs and they do this

00:21:49,210 --> 00:21:52,780
since like two decades but there's also

00:21:52,780 --> 00:21:56,100
a few other things going on that make it

00:21:56,100 --> 00:21:59,970
especially hard for a nice opensource

00:21:59,970 --> 00:22:03,569
cross vendor solution to work for NVIDIA.

00:22:03,569 --> 00:22:07,250
And that's this. (audience laughs)

00:22:07,250 --> 00:22:11,130
So the thing is I'll say it, Khronos is opening up.

00:22:11,130 --> 00:22:16,130
We have an opensource test suite now for Vulkan.

00:22:16,548 --> 00:22:19,344
We have an opensource test suite for GLES on SSCs.

00:22:19,344 --> 00:22:24,344
And we have an opensource test suite for GL, kinda.

00:22:28,279 --> 00:22:32,920
So the trouble with G is it's over 20 years old

00:22:32,920 --> 00:22:37,860
and I would say roughly-ish since 20 years,

00:22:37,860 --> 00:22:42,860
NVIDIA defines how desktop GL works.

00:22:43,230 --> 00:22:47,420
There's a standard PDF somewhere and it's trying

00:22:47,420 --> 00:22:51,032
to document all the things, not really succeeding.

00:22:51,032 --> 00:22:54,950
And for a long time, and that still holds,

00:22:54,950 --> 00:22:57,260
is essentially desktop GL is defined

00:22:57,260 --> 00:23:00,083
by whatever the NVIDIA binary block does.

00:23:01,050 --> 00:23:04,573
And even with the test suite that Khronos now doing is,

00:23:06,586 --> 00:23:09,043
there's two huge limitations on that.

00:23:10,012 --> 00:23:12,390
One is it's mainly just focused

00:23:12,390 --> 00:23:16,970
on making sure the new GL4 features are well covered.

00:23:16,970 --> 00:23:19,360
And the other bit is it's not really caring

00:23:19,360 --> 00:23:21,950
about the compatibility profiles.

00:23:21,950 --> 00:23:24,703
So in the GL3 years,

00:23:27,450 --> 00:23:30,190
desktop GL was split up and a lot

00:23:30,190 --> 00:23:33,660
of the GL1 and GL, well mostly GL1 features

00:23:33,660 --> 00:23:37,940
were put into a corner called compatibility profile.

00:23:37,940 --> 00:23:40,250
But they interact in all kinds of funny ways

00:23:40,250 --> 00:23:43,583
with the new shader features in GL3 and GL4.

00:23:44,999 --> 00:23:47,634
And the trouble is that a lot of the professional

00:23:47,634 --> 00:23:51,607
desktop applications for CUDA that decide

00:23:51,607 --> 00:23:54,920
and all that stuff, they use all

00:23:54,920 --> 00:23:58,100
that old GL stuff still because

00:23:58,100 --> 00:24:01,410
they've been written 20, 30 years ago.

00:24:01,410 --> 00:24:03,300
But they also want to use the new stuff

00:24:03,300 --> 00:24:05,360
and essentially the only driver where they work

00:24:05,360 --> 00:24:10,360
is the NVIDIA one so NVIDIA is...

00:24:11,314 --> 00:24:15,570
Is owning desktop GL and NVIDIA is owning

00:24:15,570 --> 00:24:17,833
even more anything computer-related

00:24:17,833 --> 00:24:20,560
with CUDA, which is entirely

00:24:23,265 --> 00:24:26,430
an NVIDIA defined standard.

00:24:26,430 --> 00:24:29,026
AMD is trying to do their own thing

00:24:29,026 --> 00:24:33,350
and they know that without CUDA support

00:24:33,350 --> 00:24:35,876
they can't ship their hardware.

00:24:35,876 --> 00:24:38,340
So they've had a transpiler and it works

00:24:38,340 --> 00:24:41,230
about as well as a transpiler that does source

00:24:41,230 --> 00:24:43,223
to source transformation does.

00:24:44,920 --> 00:24:48,610
And obviously they're totally not in the driver's seat.

00:24:48,610 --> 00:24:53,610
So if you want to define, defend high margins,

00:24:53,880 --> 00:24:56,650
it's great to have high, a great product of course.

00:24:56,650 --> 00:24:59,460
But it also really helps if you have

00:24:59,460 --> 00:25:01,249
a moat around your great product

00:25:01,249 --> 00:25:05,863
that prevents other people breaking into it.

00:25:06,790 --> 00:25:10,060
Now this is userspace, right?

00:25:10,060 --> 00:25:13,000
So you could say well, so...

00:25:13,000 --> 00:25:15,660
Why is this not better on the kernel?

00:25:15,660 --> 00:25:20,238
And the trouble is a bit that NVIDIA's

00:25:20,238 --> 00:25:22,370
playing the same thing on the kernel

00:25:22,370 --> 00:25:25,333
with the low-level infrastructure.

00:25:27,110 --> 00:25:30,000
So let's go through them. (laugh)

00:25:30,000 --> 00:25:32,470
The first one is libglvnd, so this is the problem

00:25:32,470 --> 00:25:35,450
that if you try to install the NVIDIA driver

00:25:35,450 --> 00:25:38,134
it's gonna throw out all the other GL drivers.

00:25:38,134 --> 00:25:41,790
Which is not terribly nice behavior.

00:25:41,790 --> 00:25:44,147
It didn't matter for a long time

00:25:44,147 --> 00:25:45,753
'cause all you bought was NVIDIA anyway.

00:25:46,710 --> 00:25:51,710
But nowadays with the dual GPU laptops

00:25:52,720 --> 00:25:56,113
where you have both the integrated Intel and NVIDIA,

00:25:57,830 --> 00:25:59,570
you need two drivers and of course,

00:25:59,570 --> 00:26:02,180
the opensource driver stack has this problem solved.

00:26:02,180 --> 00:26:05,952
You can install Mesa and you get all the drivers.

00:26:05,952 --> 00:26:10,600
So this had to be ported, it was renamed.

00:26:11,520 --> 00:26:15,580
And polished and back edited by mostly NVIDIA people

00:26:15,580 --> 00:26:20,310
called GLVendor instead of the Mesa DLI loader

00:26:20,310 --> 00:26:24,026
and put under an NVIDIA project on GitHub.

00:26:24,026 --> 00:26:26,186
But I think it's now moving back,

00:26:26,186 --> 00:26:30,670
so that fight is over.

00:26:30,670 --> 00:26:33,343
We could have just used a DRI loader

00:26:33,343 --> 00:26:35,592
and improved that one I think.

00:26:35,592 --> 00:26:39,010
And the next one is, these are the old slides

00:26:39,010 --> 00:26:43,360
because this was supposed to read EGL display device.

00:26:43,360 --> 00:26:46,902
So the entire point of moving, or one of the points

00:26:46,902 --> 00:26:49,408
of moving kernel modesetting into,

00:26:49,408 --> 00:26:52,065
or modesetting display drivers into the kernel was

00:26:52,065 --> 00:26:57,065
that you could run something else than X, like ViaLung.

00:26:57,310 --> 00:27:02,310
And NVIDIA's display driver is running

00:27:03,520 --> 00:27:05,880
in userspace integrated with X.

00:27:05,880 --> 00:27:09,703
So when this was about to take off,

00:27:10,600 --> 00:27:13,113
an NVIDIA engineer came to X to say,

00:27:14,292 --> 00:27:17,157
we have them quite often there discussing things.

00:27:17,157 --> 00:27:19,920
Presenting about EGL display device,

00:27:19,920 --> 00:27:22,570
their solution to how to do cross-vendor

00:27:22,570 --> 00:27:27,570
modesetting in an X allowing agnostic way.

00:27:29,536 --> 00:27:33,961
And of course cross-vendor means it runs on NVIDIA.

00:27:33,961 --> 00:27:37,040
But the other problem was also right around

00:27:37,040 --> 00:27:39,290
that time we finally got around to merging

00:27:39,290 --> 00:27:43,800
Atomic Modesetting to extend the graphics subsystem

00:27:43,800 --> 00:27:46,230
to all these other use cases that we didn't support

00:27:46,230 --> 00:27:50,170
as far as like an embedded for tablets and all these things.

00:27:50,170 --> 00:27:54,020
And of course NVIDIA's EGL display device thing

00:27:54,020 --> 00:27:56,500
supported nothing, like Atomic.

00:27:56,500 --> 00:27:59,107
It was essentially the legacy modesetting API

00:27:59,107 --> 00:28:02,543
rewritten as an EGL extension.

00:28:03,390 --> 00:28:04,900
So that thing fell short because

00:28:04,900 --> 00:28:06,593
obviously it missed the point.

00:28:07,840 --> 00:28:09,770
So the next thing was well, okay,

00:28:09,770 --> 00:28:12,581
so maybe we can use kernel modesetting.

00:28:12,581 --> 00:28:15,925
But we have all these special buffer formats.

00:28:15,925 --> 00:28:20,035
Like forever compression engine and all these things.

00:28:20,035 --> 00:28:25,000
So they abstracted away the entire protocol

00:28:25,000 --> 00:28:28,822
between a desktop client and the composite

00:28:28,822 --> 00:28:31,473
that takes all of the clients together and renders them.

00:28:31,473 --> 00:28:36,330
Which of course, on X11 it's called DRI.

00:28:36,330 --> 00:28:37,590
Rayland has their own versions

00:28:37,590 --> 00:28:39,750
that work with the opensource graphics.

00:28:39,750 --> 00:28:41,590
And then NVIDIA created EGL streams

00:28:41,590 --> 00:28:43,020
and they actually insisted so much

00:28:43,020 --> 00:28:44,650
on that thing that I think Gnome

00:28:44,650 --> 00:28:48,810
and the Gnome mutter compositor

00:28:48,810 --> 00:28:51,675
has support for EGL streams because otherwise,

00:28:51,675 --> 00:28:53,570
the NVIDIA block doesn't work.

00:28:53,570 --> 00:28:57,860
And meanwhile, we worked on this problem in upstream too

00:28:57,860 --> 00:29:01,440
and came up with these buffer format modifiers

00:29:02,650 --> 00:29:04,570
which people again after a few years

00:29:05,567 --> 00:29:07,997
tried to standardize in some EGL extensions.

00:29:07,997 --> 00:29:11,960
And I think NVIDIA managed to block it

00:29:11,960 --> 00:29:16,310
for almost a year because they didn't quite like it.

00:29:16,310 --> 00:29:21,310
The next one is reistributable firmware

00:29:21,410 --> 00:29:23,150
which is not a problem you can just reverse engineer with.

00:29:23,150 --> 00:29:26,010
A number of people have done that.

00:29:26,010 --> 00:29:31,010
The trouble starts once the hardware checks for a signature

00:29:32,140 --> 00:29:37,140
and I think on average that firmware blob

00:29:37,500 --> 00:29:42,500
in a redistributable license package

00:29:42,500 --> 00:29:47,110
is a few years away, one, two at least.

00:29:47,110 --> 00:29:49,230
Which completely took out the steam

00:29:51,564 --> 00:29:52,397
from that reverse engineering project.

00:29:53,742 --> 00:29:55,606
No one likes to work on software

00:29:55,606 --> 00:29:58,818
that no user can reasonably use.

00:29:58,818 --> 00:30:02,430
Because you would need to install the NVIDIA stack,

00:30:02,430 --> 00:30:05,180
run it once, extract the firmware image,

00:30:05,180 --> 00:30:07,230
then throw it all out again and then you can

00:30:07,230 --> 00:30:12,230
run the opensource stack, that's just too painful.

00:30:13,370 --> 00:30:17,770
But the thing is NVIDIA owns the market.

00:30:17,770 --> 00:30:21,860
They own it with a great product but they own it all.

00:30:21,860 --> 00:30:24,250
So by just setting the standard,

00:30:24,250 --> 00:30:27,600
I would say it would be stupid not to try this.

00:30:27,600 --> 00:30:31,970
Which is like, so what's the business case

00:30:31,970 --> 00:30:35,391
between behind open GPU drivers?

00:30:35,391 --> 00:30:37,960
Because clearly from NVIDIA's point

00:30:37,960 --> 00:30:40,689
of view it doesn't really exist.

00:30:40,689 --> 00:30:44,740
But the nice thing after 10 years

00:30:44,740 --> 00:30:47,860
of really pushing for this really hard is,

00:30:47,860 --> 00:30:51,324
I think on the customer side it clearly exists.

00:30:51,324 --> 00:30:54,660
It exists so much that customers are willing

00:30:54,660 --> 00:30:58,252
to pay consulting shops to just reverse engineer a driver

00:30:58,252 --> 00:31:02,538
if they don't get it or hire entire driver teams.

00:31:02,538 --> 00:31:07,330
And I've done a quick count for current GPU hardware.

00:31:07,330 --> 00:31:10,030
We have more reverse engineered drivers

00:31:10,030 --> 00:31:14,673
in our upstreams now than vendor supported ones.

00:31:14,673 --> 00:31:17,363
So clearly from a customer point of view,

00:31:18,972 --> 00:31:21,423
the business case exists.

00:31:22,648 --> 00:31:26,011
Now the trouble is from a hardware vendor point of view,

00:31:26,011 --> 00:31:28,790
there's three companies, that's Intel,

00:31:28,790 --> 00:31:31,673
IMD, and Broadcom for Raspberry Pi.

00:31:33,760 --> 00:31:38,760
And if you want to do graphics drivers,

00:31:39,436 --> 00:31:42,480
opensource graphics drivers without

00:31:44,790 --> 00:31:47,300
the massive pain of reverse engineering

00:31:47,300 --> 00:31:51,710
which at least means you're a bit too late.

00:31:51,710 --> 00:31:54,417
You need the hardware vendor support right?

00:31:54,417 --> 00:31:57,423
Now the trouble is they have fairly big teams

00:31:57,423 --> 00:32:01,099
and someone needs to pay the bills.

00:32:01,099 --> 00:32:06,099
And that leads me to the third title change,

00:32:06,890 --> 00:32:09,510
because a bait and flip is only funny

00:32:09,510 --> 00:32:14,083
if you do it a few times so we're back to the real talk.

00:32:16,273 --> 00:32:20,810
Of upstream graphics and how well does this work

00:32:20,810 --> 00:32:25,383
if you wanna ship product with it?

00:32:26,650 --> 00:32:29,133
So here's an example, Android by Google.

00:32:30,520 --> 00:32:32,960
It takes about 1/2 a year from Linux-next

00:32:32,960 --> 00:32:37,322
to show a patch series, just ignoring

00:32:37,322 --> 00:32:39,447
all the review that we need to do before

00:32:39,447 --> 00:32:44,100
in a release, roughly worst-case.

00:32:44,100 --> 00:32:46,631
Then if you're lucky or well, if you're really unlucky,

00:32:46,631 --> 00:32:49,410
it takes another year for this thing

00:32:49,410 --> 00:32:53,400
to show up in an LTS release.

00:32:53,400 --> 00:32:58,183
Which is generally what most customers want-ish.

00:33:00,340 --> 00:33:02,280
And then it takes another year for Google

00:33:02,280 --> 00:33:04,110
to rebase this and I think last year

00:33:04,110 --> 00:33:06,870
there was a great talk about how they celebrated cutting

00:33:06,870 --> 00:33:09,223
that time down from two to one year.

00:33:11,901 --> 00:33:15,520
And honestly that talk was primary motivation

00:33:15,520 --> 00:33:18,663
for doing this talk here because in this presentation,

00:33:18,663 --> 00:33:22,900
I celebrated all the milestones

00:33:22,900 --> 00:33:25,590
about oh, at the very end of the talk

00:33:25,590 --> 00:33:27,660
there was this oh and in the next upgrade,

00:33:27,660 --> 00:33:30,200
we're totally gonna be able to use this feature.

00:33:30,200 --> 00:33:34,490
And I was like wait, we merged this three years ago.

00:33:34,490 --> 00:33:37,380
What's going on here?

00:33:37,380 --> 00:33:42,380
And the thing is, Android is the well-known example.

00:33:43,170 --> 00:33:45,693
But it's the same problem every year.

00:33:45,693 --> 00:33:50,137
It's the same problem for service,

00:33:50,137 --> 00:33:55,137
for embedded, for Android, for anything in between.

00:33:56,220 --> 00:33:59,449
So you need to support a few years of LTS

00:33:59,449 --> 00:34:02,780
with your graphics driver if you want

00:34:02,780 --> 00:34:05,757
to actually sell your silicon chips.

00:34:05,757 --> 00:34:09,277
Except there's no such thing as an LTS.

00:34:09,277 --> 00:34:12,857
Because if you actually look at what customers use,

00:34:12,857 --> 00:34:16,050
occasionally they just misaligned

00:34:16,050 --> 00:34:18,640
and miss the LTS and don't want to wait a year

00:34:18,640 --> 00:34:20,730
so you get another kernel release.

00:34:20,730 --> 00:34:25,730
Or they realized well, our drivers GPU seems

00:34:26,957 --> 00:34:29,350
to move a bit quicker than the other bits

00:34:29,350 --> 00:34:32,220
of the kernel so let's just backport it.

00:34:32,220 --> 00:34:35,240
So maybe you have an LTS but driver's GPU,

00:34:35,240 --> 00:34:39,730
the part I care about, is totally not an LTS.

00:34:39,730 --> 00:34:42,517
The next thing is they need to have tons of patches.

00:34:47,100 --> 00:34:49,420
Just today I chatted with someone

00:34:49,420 --> 00:34:52,040
who's trying to upstream a DRM driver

00:34:52,040 --> 00:34:56,760
from the vendor tree and cleaned it all nice up.

00:34:56,760 --> 00:34:59,470
Figured oh I should probably boot this

00:34:59,470 --> 00:35:02,120
on upstream before I submit it.

00:35:02,120 --> 00:35:03,774
And then realized that the clock driver's

00:35:03,774 --> 00:35:08,307
not in upstream and the regular driver's not in upstream

00:35:08,307 --> 00:35:11,470
and ISC driver's not in upstream,

00:35:11,470 --> 00:35:13,740
so it doesn't really work.

00:35:13,740 --> 00:35:15,860
So there's usually tons of patches

00:35:15,860 --> 00:35:19,420
all incompatible with what upstream expects.

00:35:19,420 --> 00:35:21,193
So everyone's different.

00:35:22,510 --> 00:35:27,510
So you're a GPU vendor and you have

00:35:27,665 --> 00:35:30,940
this nice driver and you try to ship it

00:35:30,940 --> 00:35:33,320
and you've done the right thing,

00:35:33,320 --> 00:35:35,200
you've done upstream first development.

00:35:35,200 --> 00:35:39,400
So it is an upstream but it's not anywhere

00:35:39,400 --> 00:35:42,825
even close to a tree where your customers are.

00:35:42,825 --> 00:35:47,825
So there's a bunch of approaches with this.

00:35:48,983 --> 00:35:53,983
And one thing, this is the Redhat Enterprise Linux approach,

00:35:54,020 --> 00:35:56,260
but I think a bunch of others do it too.

00:35:56,260 --> 00:35:59,880
It's just, you look at drivers GPU

00:35:59,880 --> 00:36:02,510
and you stand back in awe and say

00:36:02,510 --> 00:36:05,160
I don't understand this, I just take it all

00:36:05,160 --> 00:36:07,800
and plug it into my kernel and then scream

00:36:07,800 --> 00:36:10,233
at my kernel until it compiles in shipping.

00:36:11,283 --> 00:36:13,805
(audience laughs)

00:36:13,805 --> 00:36:17,075
I think this works great if you don't have

00:36:17,075 --> 00:36:22,075
a too bad support contract where you actually,

00:36:23,210 --> 00:36:26,420
or if on your team a lot of the people

00:36:26,420 --> 00:36:28,800
who did write the upstream stuff work

00:36:28,800 --> 00:36:31,323
and so they can maybe debug problems.

00:36:32,160 --> 00:36:33,770
It definitely doesn't really work

00:36:33,770 --> 00:36:36,270
if you have random other drivers in there

00:36:38,010 --> 00:36:41,000
because that random other driver

00:36:41,000 --> 00:36:43,826
might actually expect the driver's GPU subsystem behavior

00:36:43,826 --> 00:36:48,620
from the LTS plus patches that it was developed against

00:36:48,620 --> 00:36:52,873
and not the LTS plus drivers GPU from 4.3.

00:36:54,079 --> 00:36:59,079
So this kind of works-ish, but it has huge problems.

00:37:00,697 --> 00:37:04,970
The next one is it just say well,

00:37:04,970 --> 00:37:08,435
I mean it's a driver how big can it be?

00:37:08,435 --> 00:37:10,090
(audience laughs)

00:37:10,090 --> 00:37:12,872
And so you end up cherry picking 1000 patches

00:37:12,872 --> 00:37:15,800
or something like that from upstream.

00:37:15,800 --> 00:37:18,147
And there's these two approaches here.

00:37:18,147 --> 00:37:21,110
One is you just say...

00:37:25,570 --> 00:37:29,520
I'm gonna cherry pick 1000 individual patches

00:37:29,520 --> 00:37:31,730
and make sure I only get the stuff

00:37:31,730 --> 00:37:35,330
for the GPU that I want, I want to reduce the risk.

00:37:35,330 --> 00:37:37,150
But of course that means your driver's

00:37:37,150 --> 00:37:40,320
a completely new different driver from the upstream driver

00:37:41,255 --> 00:37:43,740
which means you get to redo all the validation

00:37:43,740 --> 00:37:46,490
and all the review because the assumptions

00:37:46,490 --> 00:37:48,810
of the original patch are out the window

00:37:48,810 --> 00:37:50,210
if you don't take all of it.

00:37:51,660 --> 00:37:55,508
The other approach is you just copy drivers GPU

00:37:55,508 --> 00:37:57,940
but with get, essentially you take

00:37:57,940 --> 00:38:00,350
the entire history including all the mergers

00:38:01,200 --> 00:38:03,540
and you transplant that entire history

00:38:03,540 --> 00:38:06,170
with the same mergers to your LTS kernel

00:38:06,170 --> 00:38:08,720
and hope it still works because if you don't keep

00:38:08,720 --> 00:38:11,230
the same mergers all the merge conflicts move around

00:38:11,230 --> 00:38:15,233
and you get back to cherry picking 1000 patches.

00:38:19,202 --> 00:38:21,880
We have done this a few times,

00:38:21,880 --> 00:38:25,210
mostly for customers who absolutely insist

00:38:25,210 --> 00:38:28,417
that they want git commits for everything.

00:38:28,417 --> 00:38:32,813
And who pay enough to get git commits for everything.

00:38:32,813 --> 00:38:36,563
Because it's not cheap to do this.

00:38:37,463 --> 00:38:42,463
The other approach that I've also seen

00:38:42,470 --> 00:38:46,581
is copying drivers GPU but you copy it

00:38:46,581 --> 00:38:51,060
and then you rename all the clashing functions

00:38:51,060 --> 00:38:54,950
and rename the driver module so that you just

00:38:54,950 --> 00:38:58,370
have a driver for this module and nothing else

00:38:58,370 --> 00:39:01,302
and the completely separate DRM subsystem.

00:39:01,302 --> 00:39:04,350
It's obviously enormous amounts of work

00:39:04,350 --> 00:39:06,879
because you really need to make sure

00:39:06,879 --> 00:39:11,055
that the distros or customer's DRM subsystem

00:39:11,055 --> 00:39:14,030
doesn't badly interfere with your own copy

00:39:14,030 --> 00:39:16,691
of the DRM subsystem so another approach

00:39:16,691 --> 00:39:21,640
to solve this are DKMS stuff.

00:39:21,640 --> 00:39:24,162
This share core code problem is,

00:39:24,162 --> 00:39:28,120
you make a separate kernel module.

00:39:28,120 --> 00:39:31,910
You take your upstream driver, this is what AMD does.

00:39:31,910 --> 00:39:35,193
And the cherry picking is what they told us

00:39:35,193 --> 00:39:37,313
by the way if you put blame around.

00:39:38,782 --> 00:39:41,745
So you take your upstream kernel

00:39:41,745 --> 00:39:43,862
and you just copy just the driver sources

00:39:43,862 --> 00:39:48,373
to your customer or distro tree.

00:39:48,373 --> 00:39:53,373
And then every time you use a new helper function

00:39:54,510 --> 00:39:57,632
that your downstream kernel doesn't have yet,

00:39:57,632 --> 00:40:00,053
you write a patch with a few ifdevs

00:40:00,053 --> 00:40:04,279
and the copy pasted version of that upstream helper

00:40:04,279 --> 00:40:07,069
to make it all work again. (laughs)

00:40:07,069 --> 00:40:10,906
So I think in AMD's case this is 300 patches

00:40:10,906 --> 00:40:15,773
that they rebase every time their upstream changes.

00:40:18,350 --> 00:40:21,603
It's not 1000, it's not really better.

00:40:22,963 --> 00:40:26,390
So another approach is you just rate catch

00:40:26,390 --> 00:40:28,423
and say oh I want a stable driver ABI.

00:40:29,496 --> 00:40:32,060
And the thing is this works in userspace.

00:40:32,060 --> 00:40:35,150
So in userspace, the Mesa3D project,

00:40:35,150 --> 00:40:37,810
we have stable ABI's with the kernel

00:40:37,810 --> 00:40:42,810
of course or protocols with the compositors.

00:40:45,480 --> 00:40:48,380
You mostly manage to not break it and I think

00:40:48,380 --> 00:40:50,220
as a general rule of thumb we keep

00:40:50,220 --> 00:40:53,460
between three and five years of backwards compatibility

00:40:53,460 --> 00:40:56,857
with old stuff and the thing is,

00:40:56,857 --> 00:41:01,176
you can do a Mesa driver and just link in all the helpers.

00:41:01,176 --> 00:41:06,140
And not use the shared objects so you could

00:41:06,140 --> 00:41:10,609
even do a backport of a driver more or less

00:41:10,609 --> 00:41:13,801
without affecting the current driver

00:41:13,801 --> 00:41:17,510
for the current hardware that's already shipping

00:41:17,510 --> 00:41:19,250
in the distro or whatever.

00:41:19,250 --> 00:41:21,790
So with this actually you can ship

00:41:22,681 --> 00:41:24,090
random upstream driver snapshot.

00:41:24,090 --> 00:41:26,140
And I think a pretty similar approach

00:41:27,134 --> 00:41:29,090
is the travel Android's travel project

00:41:29,090 --> 00:41:31,723
where they're also trying to compartmentalize,

00:41:31,723 --> 00:41:35,700
to fence off the drivers against the other stuff

00:41:35,700 --> 00:41:37,360
and put lots and lots of...

00:41:41,180 --> 00:41:46,180
Stable APIs around them so that you can upgrade the driver

00:41:46,763 --> 00:41:50,470
without having to upgrade anything else.

00:41:50,470 --> 00:41:51,413
Now of course,

00:41:54,140 --> 00:41:57,780
having a stable driver ABI defeats code sharing

00:41:58,778 --> 00:42:02,173
so that would completely defeat the point of upstream.

00:42:03,230 --> 00:42:07,140
Because going back to the happy story

00:42:07,140 --> 00:42:08,721
of how awesome upstream graphics is,

00:42:08,721 --> 00:42:11,990
you don't achieve a graphics driver

00:42:11,990 --> 00:42:15,181
in 250 lines without code sharing.

00:42:15,181 --> 00:42:19,650
So one approach that might work,

00:42:19,650 --> 00:42:21,390
I don't think anyone's ever tried it,

00:42:21,390 --> 00:42:23,689
is to have a stable subsystem ABI

00:42:23,689 --> 00:42:26,940
and essentially make each driver module

00:42:26,940 --> 00:42:29,630
just link in the entire subsystem

00:42:29,630 --> 00:42:34,630
without any exporting, but... (audience laughs)

00:42:36,149 --> 00:42:40,130
Getting back to the business case of doing upstream first,

00:42:40,130 --> 00:42:43,584
in userspace I think it works, it works rather well

00:42:43,584 --> 00:42:48,584
for graphics driver but in the kernel space, it is rough.

00:42:49,220 --> 00:42:52,410
Say you have your driver, you shepherd it

00:42:52,410 --> 00:42:55,243
through upstream review, you're a good citizen,

00:42:57,449 --> 00:42:59,426
you refactor it, you share code,

00:42:59,426 --> 00:43:00,968
you make sure every, there's nice

00:43:00,968 --> 00:43:02,370
and clean cross driver interfaces,

00:43:02,370 --> 00:43:06,473
shared concepts, shared code, all these helper libraries.

00:43:08,056 --> 00:43:09,830
And then you have it in upstream.

00:43:09,830 --> 00:43:12,552
And then you take your upstream driver

00:43:12,552 --> 00:43:15,209
and you take all the crap that you've thrown out

00:43:15,209 --> 00:43:18,360
and add it back in because you don't have all

00:43:18,360 --> 00:43:20,093
these nice helpers in downstream

00:43:20,093 --> 00:43:22,860
because they're running on some old kernels.

00:43:22,860 --> 00:43:26,253
And then once you put the crap back in you ship it.

00:43:27,592 --> 00:43:29,543
And yeah.

00:43:31,130 --> 00:43:33,440
This sounded like a really good idea

00:43:33,440 --> 00:43:35,253
10 years ago when we started.

00:43:39,660 --> 00:43:42,720
Unfortunately, with the companies

00:43:42,720 --> 00:43:45,733
doing upstream first on the kernel,

00:43:46,759 --> 00:43:50,960
it just doesn't work and I've been

00:43:50,960 --> 00:43:55,910
in quite a lot of meetings where essentially

00:43:55,910 --> 00:43:58,708
we're justifying upstream first

00:43:58,708 --> 00:44:00,649
because we're the upstream first team

00:44:00,649 --> 00:44:02,646
and if you wouldn't do upstream first

00:44:02,646 --> 00:44:03,643
it would be kind of embarrassing.

00:44:05,380 --> 00:44:07,210
But not because it actually makes

00:44:08,742 --> 00:44:10,881
a whole lot of business sense.

00:44:10,881 --> 00:44:14,800
So why do we do this, some customers require upstream first

00:44:14,800 --> 00:44:16,890
'cause for the review and the code sharing

00:44:16,890 --> 00:44:20,063
and the quality and then proceed to ignore upstream.

00:44:21,370 --> 00:44:26,160
So in a way, the Linux kernel,

00:44:26,160 --> 00:44:29,490
the way I see it is in a really icky spot.

00:44:29,490 --> 00:44:33,530
It's too big and too fast to just say well forget it.

00:44:33,530 --> 00:44:35,170
I'm gonna make a stable ABI

00:44:35,170 --> 00:44:36,943
and solve this problem like that.

00:44:38,680 --> 00:44:43,680
And it's also too late for actually shipping upstream first.

00:44:48,132 --> 00:44:50,882
And I don't know how to fix this,

00:44:53,540 --> 00:44:57,266
but I do think if we do want upstream GPU drivers,

00:44:57,266 --> 00:45:02,266
open source, we need to somehow figure this out

00:45:03,350 --> 00:45:07,985
so that upstream first and the kernel doesn't mean

00:45:07,985 --> 00:45:12,298
you clean it up, you have a nice driver

00:45:12,298 --> 00:45:15,340
that doesn't really pay the bills.

00:45:15,340 --> 00:45:17,710
Not at least for your huge thing.

00:45:17,710 --> 00:45:19,530
It did pay the bills 10 years ago

00:45:19,530 --> 00:45:21,243
when it was two, three people.

00:45:22,140 --> 00:45:24,420
Then you add in back all the crap

00:45:24,420 --> 00:45:29,340
and then you ship it because that doesn't work.

00:45:29,340 --> 00:45:33,670
And I'm not sure we have time for questions, unfortunately.

00:45:33,670 --> 00:45:35,421
- [Moderator] Yeah we're running out of time.

00:45:35,421 --> 00:45:37,213
We can maybe spend five minutes on questions.

00:45:40,065 --> 00:45:41,865
And the mic-- - Have sort of

00:45:41,865 --> 00:45:42,698
a question statement.

00:45:48,080 --> 00:45:51,010
So your last couple slides you sound like,

00:45:51,010 --> 00:45:54,250
already made exactly for we've been living this too.

00:45:54,250 --> 00:45:58,530
Just like GPU but I think our business case

00:45:58,530 --> 00:45:59,827
is different and works a little better

00:45:59,827 --> 00:46:02,480
and we're really strongly endorsing upstream first

00:46:02,480 --> 00:46:04,620
and we are getting the business case value

00:46:04,620 --> 00:46:06,833
out of it that you seem to be lacking.

00:46:06,833 --> 00:46:08,820
It's because the customers want it,

00:46:08,820 --> 00:46:11,693
the customers are willing to pay extra to get it,

00:46:11,693 --> 00:46:14,112
and we're able to work with the distribution channel

00:46:14,112 --> 00:46:19,000
which is the enterprise Linux to do the backports

00:46:19,000 --> 00:46:21,063
in a coordinated way, we don't have,

00:46:22,138 --> 00:46:23,776
I don't know anything about your world

00:46:23,776 --> 00:46:24,609
but it sounds like you spend a lot

00:46:24,609 --> 00:46:27,240
of time talking about Android where it was a big mess.

00:46:29,037 --> 00:46:30,917
- It's the same everywhere. - Well I can put a patch

00:46:30,917 --> 00:46:32,969
downstream to kernel and I can ship it

00:46:32,969 --> 00:46:34,090
to a customer and a supported enterprise distro

00:46:35,045 --> 00:46:37,040
in eight months, tops and I can get it

00:46:37,040 --> 00:46:41,520
to them earlier with a backport scheme in four months.

00:46:41,520 --> 00:46:44,289
So how do you get all the value out of it?

00:46:44,289 --> 00:46:48,391
Why, where do you struggle?

00:46:48,391 --> 00:46:51,770
- One is that the four months with,

00:46:51,770 --> 00:46:54,090
so one thing is if you backport it

00:46:54,090 --> 00:46:58,152
if you have thousands of patches if you're unlucky.

00:46:58,152 --> 00:47:02,050
So it's a bit bigger and the other thing is...

00:47:04,030 --> 00:47:06,393
I don't see eight months.

00:47:08,377 --> 00:47:10,130
I'm not sure how you get, and the other thing,

00:47:10,130 --> 00:47:12,870
so on the business case-- - We get eight months

00:47:12,870 --> 00:47:15,990
because we spend a lot of money working

00:47:15,990 --> 00:47:18,490
with commercial distributions to get eight months.

00:47:19,679 --> 00:47:20,780
That's the end of the story, this is--

00:47:20,780 --> 00:47:21,613
- Yeah that's exactly-- - None of this happens

00:47:22,500 --> 00:47:23,770
for free, I think it's the important takeaway.

00:47:23,770 --> 00:47:25,400
You don't get backports for free,

00:47:25,400 --> 00:47:26,357
you don't get any of the stuff for free.

00:47:26,357 --> 00:47:30,560
There's engineers working on this full time, a lot of them.

00:47:30,560 --> 00:47:32,632
- The thing is if you compare this to userspace,

00:47:32,632 --> 00:47:36,864
we do upstream first in userspace and it works.

00:47:36,864 --> 00:47:39,960
- But your userspace doesn't come

00:47:39,960 --> 00:47:42,860
in an enterprise distro for at least another period

00:47:42,860 --> 00:47:45,546
of time, you're saying-- - You can just upgrade it.

00:47:45,546 --> 00:47:47,149
- You're saying you can just

00:47:47,149 --> 00:47:48,530
upgrade it-- - To a stable API.

00:47:48,530 --> 00:47:49,670
- People may or may not accept that.

00:47:49,670 --> 00:47:52,287
We've also had the same problem in our userspace

00:47:52,287 --> 00:47:54,437
where people don't want the opensource userspace

00:47:54,437 --> 00:47:56,190
that I just downloaded from the internet.

00:47:56,190 --> 00:47:58,299
I want the one my distribution is supporting fully.

00:47:58,299 --> 00:48:00,320
But they won't upgrade either.

00:48:00,320 --> 00:48:01,940
They want the distribution to put it back.

00:48:01,940 --> 00:48:03,950
You end up with userspace doesn't solve it either

00:48:03,950 --> 00:48:07,140
because the serious, serious support-wanting customers

00:48:07,140 --> 00:48:10,113
always want support from their vendors, always.

00:48:10,113 --> 00:48:13,863
- We have time for one more question.

00:48:17,809 --> 00:48:18,642
Oh, sorry.

00:48:22,630 --> 00:48:26,080
- So one of our pain points is the whole backporting.

00:48:26,080 --> 00:48:30,390
Thousands of patches with merge commits and just making

00:48:30,390 --> 00:48:32,510
it all reasonably work for the kernel.

00:48:33,854 --> 00:48:35,580
Part of that is an artifact of the fact

00:48:35,580 --> 00:48:37,720
that you've chosen to have a development model

00:48:37,720 --> 00:48:39,820
to optimize productivity to produce

00:48:39,820 --> 00:48:41,915
the kernel in the first place.

00:48:41,915 --> 00:48:44,070
So you have a complex merge history

00:48:44,070 --> 00:48:45,950
and things like that, right, in your subsystem.

00:48:45,950 --> 00:48:48,038
And that's a valid choice, there's nothing neccesarily wrong

00:48:48,038 --> 00:48:50,466
with that but if you chose to trade off

00:48:50,466 --> 00:48:54,100
some execution on original development

00:48:54,100 --> 00:48:57,100
and tweaking it so it makes it easier

00:48:57,100 --> 00:48:59,250
to backport and maintain downstream,

00:48:59,250 --> 00:49:00,863
what do you think can be done there?

00:49:02,413 --> 00:49:05,760
- I think we managed to get here

00:49:06,770 --> 00:49:08,980
through this radical code sharing

00:49:08,980 --> 00:49:11,670
and refactoring and doing things.

00:49:11,670 --> 00:49:14,410
Both in userspace and the kernel.

00:49:14,410 --> 00:49:18,154
So I'm not sure we would have managed

00:49:18,154 --> 00:49:20,679
to get to the happy place where we can say,

00:49:20,679 --> 00:49:25,336
we have really great drivers for a lot of stuff

00:49:25,336 --> 00:49:30,336
without this but yeah, now-- - Can you tweak it now?

00:49:30,383 --> 00:49:32,883
Does it make sense to tweak it now?

00:49:32,883 --> 00:49:34,840
I don't have answers, I'm just--

00:49:34,840 --> 00:49:36,290
- So the trouble, like I said,

00:49:36,290 --> 00:49:38,220
the customer use case or the customer

00:49:38,220 --> 00:49:40,020
to customer business case for opensource graphics

00:49:40,020 --> 00:49:42,290
is definitely here and that's why we have

00:49:42,290 --> 00:49:44,493
more reverse engineered drivers

00:49:44,493 --> 00:49:46,417
than vendor supported drivers.

00:49:46,417 --> 00:49:48,493
And if we now start to switch,

00:49:49,580 --> 00:49:52,093
we're gonna kill the reverse engineered drivers.

00:49:53,354 --> 00:49:55,207
Because they're benefiting in a way

00:49:55,207 --> 00:49:56,655
from all that refactoring and sharing.

00:49:56,655 --> 00:50:01,484
- You can still do the refactoring, but it--

00:50:01,484 --> 00:50:05,250
- Maybe, but yeah, and I guess

00:50:05,250 --> 00:50:07,069
we're out of time. - So at some point,

00:50:07,069 --> 00:50:08,985
yeah sounds like we're not gonna be able

00:50:08,985 --> 00:50:10,680
to solve this problem now so we're exiting

00:50:10,680 --> 00:50:13,028
on such an up note but thanks so much

00:50:13,028 --> 00:50:15,800
to Daniel and I'm sure we'll be continuing

00:50:15,800 --> 00:50:18,613
this conversation in the hallways.

00:50:18,613 --> 00:50:20,042

YouTube URL: https://www.youtube.com/watch?v=S1I34t5RpnI


