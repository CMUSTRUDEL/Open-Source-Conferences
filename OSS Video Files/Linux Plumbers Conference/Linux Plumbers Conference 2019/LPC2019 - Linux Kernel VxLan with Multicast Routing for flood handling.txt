Title: LPC2019 - Linux Kernel VxLan with Multicast Routing for flood handling
Publication date: 2019-09-17
Playlist: Linux Plumbers Conference 2019
Description: 
	Linux Kernel VxLan with Multicast Routing for flood handling

The Linux kernel VxLan driver supports two ways of handling flooded traffic to multiple remote VxLan termination end points (VTEPS):
(a) Head end replication: where the VxLan driver sends a copy of the packet to each participating remote VTEPs
(b) Use of multicast routing to forward to participating remote VTEPs

(b) is generally preferred for both hardware and software VTEP deployments because it scales better. The kernel VxLan driver supports (b) with static config today. One has to specify the multicast group with the outgoing uplink interface for VxLan multicast replication to work. This is mostly ok for deployments where VTEPs are deployed on the host/hypervisor. When deploying Linux VTEPs on the Top-Of-the-Rack (TOR) switches in a data center CLOS network, it is impossible to configure the outgoing interface statically. Typically a multicast routing protocol like PIM is used to dynamically calculate multicast trees and install forwarding paths for multicast traffic.

In this talk we will cover:
- Vxlan Multicast deployment scenarios with Vxlan VTEPs at the TOR switches
- Current challenges with integrating Vxlan Multicast replication in a dynamic multicast routing environment
- Solutions to these challenges: (a) Patches to fix routing of locally generated multicast packets (need for ip_mr_output) (b) Patches to VxLan driver to allow multicast replication without a static outgoing interface
- Scale
- Futures on VxLan deployments in multicast environment
Captions: 
	00:00:00,620 --> 00:00:01,740
- Okay, I think we're good.

00:00:01,740 --> 00:00:02,613
I'll get started.

00:00:04,060 --> 00:00:06,960
The slide says "Welcome to Linux Plumbers 2019"

00:00:06,960 --> 00:00:09,933
but I know you're only here for the networking track.

00:00:12,180 --> 00:00:13,460
Regardless, welcome everyone.

00:00:13,460 --> 00:00:15,750
Thanks for taking the time to travel

00:00:15,750 --> 00:00:17,000
out to beautiful Lisbon

00:00:18,630 --> 00:00:20,570
and to see all the amazing talks

00:00:20,570 --> 00:00:22,570
that we're gonna have these next couple days.

00:00:22,570 --> 00:00:25,310
I've been asked to show these welcome slides

00:00:25,310 --> 00:00:30,310
even though we had the first session starting at 10 a.m.

00:00:30,710 --> 00:00:34,290
Thank all of our sponsors, here they are on the screen.

00:00:34,290 --> 00:00:37,490
Facebook also sponsored our networking track

00:00:37,490 --> 00:00:40,310
in Vancouver too, so thanks for them again.

00:00:40,310 --> 00:00:41,440
We have to appreciate these people

00:00:41,440 --> 00:00:42,750
because otherwise we wouldn't be able

00:00:42,750 --> 00:00:43,980
to have this fantastic event

00:00:43,980 --> 00:00:46,283
without all of their incredible support.

00:00:47,480 --> 00:00:49,500
Here is the wireless information

00:00:49,500 --> 00:00:50,380
if you don't have it already.

00:00:50,380 --> 00:00:53,600
I think it's on the back of all of our name tags, too.

00:00:53,600 --> 00:00:55,098
So there's that.

00:00:55,098 --> 00:00:56,430
And there's the URL to the Code of Conduct

00:00:56,430 --> 00:00:59,143
which we're required to let you know about.

00:01:00,830 --> 00:01:01,850
Yeah so you should go read that

00:01:01,850 --> 00:01:03,420
if you're interested in the policies

00:01:03,420 --> 00:01:05,600
and everything as far as that's concerned.

00:01:05,600 --> 00:01:07,040
There's what the schedule is,

00:01:07,040 --> 00:01:08,610
you can click on the different things

00:01:08,610 --> 00:01:10,101
in the networking track to get to

00:01:10,101 --> 00:01:12,313
when your favorite talk's going to be.

00:01:13,490 --> 00:01:15,640
We're on Portuguese time

00:01:15,640 --> 00:01:17,630
which means that we start at 10 a.m.

00:01:17,630 --> 00:01:21,460
And lunch is at 1:30 and then our evening events

00:01:21,460 --> 00:01:23,873
are in the 7-9 p.m. time frame.

00:01:25,270 --> 00:01:27,640
Monday night has a welcome reception here,

00:01:27,640 --> 00:01:30,200
I think downstairs or upstairs or wherever

00:01:30,200 --> 00:01:32,290
at the Sete Colinas room.

00:01:32,290 --> 00:01:33,860
Tuesday night everyone's on their own,

00:01:33,860 --> 00:01:35,830
go find somewhere to eat on your own

00:01:35,830 --> 00:01:37,670
and then there's a Plenary with buses

00:01:37,670 --> 00:01:39,480
that start at 7:30, I've been told

00:01:39,480 --> 00:01:41,030
that it's gonna be a fantastic,

00:01:42,100 --> 00:01:44,700
almost over the top kind of event,

00:01:44,700 --> 00:01:46,080
really good food and everything,

00:01:46,080 --> 00:01:47,280
so that should be great.

00:01:52,497 --> 00:01:55,200
We have almost all the slides on here.

00:01:55,200 --> 00:01:57,790
The people who have not put it up yet,

00:01:57,790 --> 00:01:58,623
you know who you are.

00:01:58,623 --> 00:02:00,000
I've already given you a hard time,

00:02:00,000 --> 00:02:02,100
we don't need to go into that any further.

00:02:02,950 --> 00:02:04,150
But everything will be on here,

00:02:04,150 --> 00:02:05,600
so you don't have to hook your laptop up

00:02:05,600 --> 00:02:08,120
and we do, operate very efficiently

00:02:08,120 --> 00:02:10,023
during this wonderful conference.

00:02:11,610 --> 00:02:14,540
If you have any questions about the LPC event

00:02:14,540 --> 00:02:15,670
in any way, shape, or form,

00:02:15,670 --> 00:02:18,360
all these people on this list are fantastic individuals.

00:02:18,360 --> 00:02:20,530
I've been working with them for the past

00:02:20,530 --> 00:02:21,890
several weeks and months

00:02:21,890 --> 00:02:24,420
and they will be able to solve whatever problem

00:02:24,420 --> 00:02:25,290
you may come up with,

00:02:25,290 --> 00:02:26,900
and so you should go contact them.

00:02:26,900 --> 00:02:28,110
Okay?

00:02:28,110 --> 00:02:30,101
So without further ado,

00:02:30,101 --> 00:02:31,640
Roopa Prahpu is gonna come up

00:02:31,640 --> 00:02:34,680
and give her presentation on VXLan,

00:02:34,680 --> 00:02:37,020
multicast routing and flooding.

00:02:37,020 --> 00:02:39,040
Roopa has been contributing to Linux Networking

00:02:39,040 --> 00:02:40,943
for a significant amount of time,

00:02:42,210 --> 00:02:44,770
specifically when we needed to make statistics better

00:02:44,770 --> 00:02:47,270
with Netlink and everything, she made that happen.

00:02:47,270 --> 00:02:48,760
She's fixing bugs in the bridging code

00:02:48,760 --> 00:02:50,793
and in those areas all the time.

00:02:51,871 --> 00:02:55,986
So, please welcome Roopa Prahpu.

00:02:55,986 --> 00:02:58,236
(applause)

00:03:01,090 --> 00:03:02,463
Is it in this directory?

00:03:08,400 --> 00:03:09,233
Awesome.

00:03:13,310 --> 00:03:14,143
Cool.

00:03:16,394 --> 00:03:17,227
Thanks.

00:03:18,640 --> 00:03:19,960
- Two more minutes?

00:03:19,960 --> 00:03:20,793
- Three more.

00:03:24,270 --> 00:03:27,110
- Thanks David, hello everyone.

00:03:27,110 --> 00:03:27,960
My name is Roopa,

00:03:28,810 --> 00:03:31,810
yeah it's yet another VXLan talk for me

00:03:31,810 --> 00:03:34,930
I've been doing VXLan talks for the past two or three years

00:03:34,930 --> 00:03:38,040
because that area is still being developed.

00:03:38,040 --> 00:03:40,350
There are a lot of RFCs coming out

00:03:40,350 --> 00:03:41,981
on optimizations to VXLan

00:03:41,981 --> 00:03:44,110
and overlays in general in the data center.

00:03:44,110 --> 00:03:47,060
So, yeah, every year there's been a lot

00:03:47,060 --> 00:03:48,920
of work going on in this area.

00:03:48,920 --> 00:03:53,130
So Nicolay is, I think he doesn't know that his name is

00:03:53,130 --> 00:03:57,020
on the slides, but he does work with me on multicast,

00:03:57,020 --> 00:03:59,830
and he is actually an expert at multicast.

00:03:59,830 --> 00:04:04,420
So yeah, I'm glad that my talk is the first.

00:04:04,420 --> 00:04:07,300
That means I get to be done with it,

00:04:07,300 --> 00:04:09,120
but I'm sorry you have to listen to multicast

00:04:09,120 --> 00:04:11,523
the first thing in the networking summit.

00:04:14,454 --> 00:04:15,621
So the agenda.

00:04:16,920 --> 00:04:18,720
I am very thankful for the Portuguese time.

00:04:18,720 --> 00:04:21,850
This is the first conference I've got to sleep a bit.

00:04:21,850 --> 00:04:23,070
For the people who are jet-lagged,

00:04:23,070 --> 00:04:25,520
you know you sleep for two hours and you wake up

00:04:25,520 --> 00:04:27,670
and then you get some sleep in the morning.

00:04:28,630 --> 00:04:30,080
Okay, so agenda.

00:04:30,080 --> 00:04:31,933
VXLan and Flooding,

00:04:33,720 --> 00:04:35,817
and I'll talk a little bit about the VXLan

00:04:35,817 --> 00:04:37,890
and multicast stuff.

00:04:37,890 --> 00:04:40,390
State of VXLan and multicast for flooding

00:04:40,390 --> 00:04:43,410
and limitations of the current implementation

00:04:43,410 --> 00:04:46,140
and fixes and futures.

00:04:46,140 --> 00:04:47,680
So, a few terminologies.

00:04:47,680 --> 00:04:50,920
These are used mainly in the RFC

00:04:50,920 --> 00:04:52,610
so I've just put a slide on.

00:04:52,610 --> 00:04:55,703
VTEP is nothing but a VXLan Termination End Point.

00:04:56,920 --> 00:05:01,120
BUM flooding is what is usually used

00:05:01,120 --> 00:05:03,610
in the term for covering flooding,

00:05:03,610 --> 00:05:06,453
basically Broadcast, Unknown Unicast and Multicast.

00:05:07,300 --> 00:05:10,620
PIM, PIM is a very complex control plane protocol

00:05:10,620 --> 00:05:15,150
for multicast handling, and its deployment

00:05:15,150 --> 00:05:17,150
and management is complex and that's why

00:05:17,150 --> 00:05:19,920
people don't use multicast in most situations,

00:05:19,920 --> 00:05:24,453
but you'll see why it's being used in VXLan environments.

00:05:25,360 --> 00:05:27,610
Ipmr is basically, you use that

00:05:27,610 --> 00:05:31,740
to refer to the kernel IP multicast routing stack.

00:05:31,740 --> 00:05:34,500
OIL is nothing but an outgoing interface list.

00:05:34,500 --> 00:05:37,470
And OIF, as you know in the routing world,

00:05:37,470 --> 00:05:40,270
in the Linux kernel it's the outgoing interface.

00:05:40,270 --> 00:05:44,350
And forwarding information is, like the FIB,

00:05:44,350 --> 00:05:49,350
the bridge and layer two forwarding information database

00:05:49,830 --> 00:05:52,310
is called FTB, and E-VPN is something

00:05:52,310 --> 00:05:55,280
that I've talked in multiple talks in the past.

00:05:55,280 --> 00:05:57,320
It's basically a control plane for VXLan.

00:05:57,320 --> 00:06:00,290
It's becoming very popular and, like I said,

00:06:00,290 --> 00:06:01,877
every year there are more RFCs

00:06:03,570 --> 00:06:06,463
for optimizations in the VXLan environment.

00:06:07,550 --> 00:06:12,550
So VXLan is nothing but a UDP tunnel, as you all know.

00:06:12,920 --> 00:06:14,740
I don't expect everybody to be working on,

00:06:14,740 --> 00:06:19,440
most of them here who don't use VXLan or overlays.

00:06:19,440 --> 00:06:22,470
But VXLan, in the data center,

00:06:22,470 --> 00:06:24,320
it is part of the infrastructure,

00:06:24,320 --> 00:06:26,990
where your host probably does not see it

00:06:26,990 --> 00:06:30,350
in most of the cases, but about the host,

00:06:30,350 --> 00:06:33,130
once you enter the switch and the data center

00:06:33,130 --> 00:06:36,540
and the cloud sometimes, is built on overlays.

00:06:36,540 --> 00:06:38,220
Basically you tunnel traffic.

00:06:38,220 --> 00:06:42,890
And this is made mostly layer two traffic.

00:06:42,890 --> 00:06:44,900
Your racks connected to other racks,

00:06:44,900 --> 00:06:49,393
and to your even virtual private cloud and so on.

00:06:53,370 --> 00:06:57,310
And VXLan tunnel endpoints are nothing but the points

00:07:00,160 --> 00:07:02,760
where you, it's basically, if you're deploying Linux,

00:07:02,760 --> 00:07:06,400
it's basically a device that creates the VXLan device.

00:07:06,400 --> 00:07:07,233
Right?

00:07:07,233 --> 00:07:09,820
It encaps and decaps VXLan traffic.

00:07:09,820 --> 00:07:12,560
So it could be your host, hypervisor, container-OS

00:07:12,560 --> 00:07:15,740
or your cloud instance, or it could also be

00:07:15,740 --> 00:07:17,170
your top-of-rack switch

00:07:17,170 --> 00:07:19,740
and other switches in the data center.

00:07:19,740 --> 00:07:24,740
So, and, like in any other layer two environment,

00:07:25,640 --> 00:07:27,480
you basically learn information,

00:07:27,480 --> 00:07:30,610
forwarding database by flooding.

00:07:30,610 --> 00:07:31,443
Right?

00:07:31,443 --> 00:07:34,620
Unlike routing, where there is a routing protocol,

00:07:34,620 --> 00:07:37,060
which works with other routing protocols

00:07:37,060 --> 00:07:40,610
in a distributed fashion to build

00:07:40,610 --> 00:07:42,240
your forwarding information,

00:07:42,240 --> 00:07:44,580
in layer two environments you usually flood.

00:07:44,580 --> 00:07:46,870
And when you're talking about layer two environments

00:07:46,870 --> 00:07:50,620
that span the entire data center or the cloud,

00:07:50,620 --> 00:07:53,760
you tend to not flood,

00:07:53,760 --> 00:07:56,600
because the flood domain is larger here

00:07:56,600 --> 00:07:58,980
and you want to reduce that flooding

00:07:58,980 --> 00:08:00,510
and flooding of broadcast traffic.

00:08:00,510 --> 00:08:02,440
Basically, when you talk about flooding,

00:08:02,440 --> 00:08:05,440
it's basically an ARP, which is a broadcast

00:08:05,440 --> 00:08:09,430
which can be flooded to all the nodes in the data center.

00:08:09,430 --> 00:08:12,240
So in the Linux kernel,

00:08:12,240 --> 00:08:15,030
the layer two forwarding information is,

00:08:15,030 --> 00:08:17,050
especially for VXLan,

00:08:17,050 --> 00:08:18,883
it is the Mac, vni, dst_port and dst_ip.

00:08:20,140 --> 00:08:21,850
And dst_ip is nothing but

00:08:21,850 --> 00:08:25,453
your remote endpoint, VXLan endpoint,

00:08:27,310 --> 00:08:31,973
and it's an IP network because VXLan uses an IP underlay.

00:08:33,440 --> 00:08:37,190
This is a pictorial representation

00:08:37,190 --> 00:08:38,590
of what I was talking about.

00:08:39,920 --> 00:08:42,810
There is, these are two nodes,

00:08:42,810 --> 00:08:45,970
which are acting as VXLan termination endpoints,

00:08:45,970 --> 00:08:48,670
Basically initiating a VXLan tunnel

00:08:48,670 --> 00:08:50,740
and terminating a VXLan tunnel.

00:08:50,740 --> 00:08:53,890
And it gives you an example

00:08:53,890 --> 00:08:57,130
of how the forwarding database is maintained.

00:08:57,130 --> 00:08:58,790
Sorry, I realize there is a typo there,

00:08:58,790 --> 00:09:02,363
it's vxlan-10 in the forwarding database,

00:09:03,890 --> 00:09:06,780
but as you can see, VTEP1 has an IP

00:09:06,780 --> 00:09:08,300
and VTEP2 has another IP,

00:09:08,300 --> 00:09:12,210
and the UDP tunnel is basically using an underlay

00:09:12,210 --> 00:09:15,123
which is an IP unicast underlay.

00:09:16,810 --> 00:09:20,310
So there are many ways flooding is implemented

00:09:20,310 --> 00:09:22,940
in the VXLan driver today.

00:09:22,940 --> 00:09:26,960
So an all-zero MAC address is like

00:09:26,960 --> 00:09:29,780
your default route in your L3 domain.

00:09:29,780 --> 00:09:32,660
Basically when you don't hit a specific MAC entry,

00:09:32,660 --> 00:09:37,660
you hit the all-zero MAC address, and it'll replicate,

00:09:37,770 --> 00:09:42,770
or it'll forward to or flood to the IP addresses

00:09:43,010 --> 00:09:45,380
that are there in that list.

00:09:45,380 --> 00:09:47,110
So there is an example here

00:09:47,110 --> 00:09:49,510
for something called Head End Replication,

00:09:49,510 --> 00:09:52,390
where you replicate at your source node,

00:09:52,390 --> 00:09:56,483
at your VTEP source you replicate to multiple VTEPs.

00:09:57,520 --> 00:09:59,530
This example actually shows you two entries,

00:09:59,530 --> 00:10:02,530
but this replication list can grow if

00:10:02,530 --> 00:10:05,260
you are talking about multiple racks

00:10:05,260 --> 00:10:06,770
in a data-center-like environment,

00:10:06,770 --> 00:10:10,100
and each rack is a tunnel endpoint.

00:10:10,100 --> 00:10:12,430
And these IP addresses at the end are basically

00:10:12,430 --> 00:10:15,393
your per-rack VTEPs.

00:10:16,610 --> 00:10:21,610
And these, in cases, again, can be populated

00:10:21,800 --> 00:10:26,800
by a control plane, like eBGB, sorry E-VPN, using BGP.

00:10:29,520 --> 00:10:31,380
And the other way to flood

00:10:31,380 --> 00:10:34,040
is basically use multicast replication.

00:10:34,040 --> 00:10:35,430
So instead of replicating

00:10:35,430 --> 00:10:38,440
on the source VXLan tunnel endpoint,

00:10:38,440 --> 00:10:41,920
you use multicast so that, multicast, as you know,

00:10:41,920 --> 00:10:46,650
it has good replication properties.

00:10:46,650 --> 00:10:50,440
Basically you send to a multicast using multicast

00:10:50,440 --> 00:10:53,520
on the source, but then you replicate on the other end,

00:10:53,520 --> 00:10:55,880
when it reaches the destination.

00:10:55,880 --> 00:11:00,410
So VXLan driver actually has all the support

00:11:00,410 --> 00:11:01,713
to use multicast.

00:11:03,580 --> 00:11:06,093
And it's used as an optimization for flooding.

00:11:07,630 --> 00:11:11,960
So here is a little more information.

00:11:11,960 --> 00:11:14,500
VTEPs in a multicast environment,

00:11:14,500 --> 00:11:16,810
or VXLan tunnel endpoints in a multicast environment,

00:11:16,810 --> 00:11:19,340
they source and receive multicast traffic.

00:11:19,340 --> 00:11:23,280
And if you know of IGMP, I've put a reference there.

00:11:23,280 --> 00:11:27,740
IGMP is a protocol that is used to express interest

00:11:27,740 --> 00:11:28,810
in a multicast group.

00:11:28,810 --> 00:11:32,160
Many hosts do that, VMs and so on.

00:11:32,160 --> 00:11:36,080
VTEPs on routers will use the underlay IP multicast routing

00:11:36,080 --> 00:11:39,643
to route the originated multicast traffic.

00:11:40,590 --> 00:11:43,090
So PIM is, again I have a reference there,

00:11:43,090 --> 00:11:45,720
it is a control plane for multicast.

00:11:45,720 --> 00:11:48,580
Basically these are routers which build the

00:11:50,600 --> 00:11:52,863
IP multicast routing database in the kernel.

00:11:55,470 --> 00:11:59,180
So this shows you a picture of how VXLan

00:11:59,180 --> 00:12:00,820
with multicast underlay is done

00:12:00,820 --> 00:12:04,560
when the VTEP is on a host.

00:12:04,560 --> 00:12:06,790
Host here could be a hypervisor.

00:12:06,790 --> 00:12:09,650
So the VXLan driver today allows

00:12:09,650 --> 00:12:13,283
you to specify multicast address and uplink interface.

00:12:14,130 --> 00:12:19,090
So the host1, host2, they actually express interest in

00:12:19,090 --> 00:12:21,660
that multicast by doing an IGMP join.

00:12:21,660 --> 00:12:23,710
So that's how the switch knows that

00:12:24,620 --> 00:12:26,860
these host are interested in that traffic.

00:12:26,860 --> 00:12:29,930
That's how they forward you that multicast traffic.

00:12:29,930 --> 00:12:32,620
And on the routers, you have the PIMD,

00:12:32,620 --> 00:12:35,670
which is again the multicast control plane,

00:12:35,670 --> 00:12:40,670
which builds that multicast database, routing database.

00:12:41,190 --> 00:12:46,030
And, as you can see, the IPMR table actually has an OIL list

00:12:46,030 --> 00:12:51,030
which has uplink1 and uplink2 in its outgoing list.

00:12:54,940 --> 00:12:57,530
So how does VTEP, VXLan tunnel endpoint,

00:12:57,530 --> 00:12:58,650
on a switch look today?

00:12:58,650 --> 00:13:00,840
So VXLan driver is configured

00:13:00,840 --> 00:13:03,970
with the OIF for the multicast group, the same thing.

00:13:03,970 --> 00:13:05,404
If you use VXLan today,

00:13:05,404 --> 00:13:10,404
you would specify the multicast group and the uplink port,

00:13:12,040 --> 00:13:14,780
but it allows you to specify just one uplink port.

00:13:14,780 --> 00:13:17,840
So this picture actually shows where the problem is.

00:13:17,840 --> 00:13:22,840
IPMR thinks that it needs to distribute multicast traffic

00:13:22,980 --> 00:13:25,560
on uplink1 and uplink2, and VXLan,

00:13:25,560 --> 00:13:28,500
which is on the switch, it actually thinks

00:13:28,500 --> 00:13:31,883
that only uplink1 is interested in multicast traffic.

00:13:34,790 --> 00:13:36,890
So they both, ipmr and VXLan,

00:13:36,890 --> 00:13:40,363
are not in sync with each other.

00:13:41,730 --> 00:13:45,017
So if you can, this actually points out that

00:13:45,017 --> 00:13:48,390
multicast on VXLan driver actually works best

00:13:48,390 --> 00:13:49,870
for the host case, but not

00:13:49,870 --> 00:13:54,283
where the switch is the VXLan tunnel originator.

00:13:55,370 --> 00:13:58,950
There is no multicast routing lookup performed

00:13:58,950 --> 00:14:03,533
when VXLan driver actually initiates a multicast traffic.

00:14:04,390 --> 00:14:07,540
It only supports a static multicast OIL.

00:14:07,540 --> 00:14:10,340
Like you saw, only uplink1.

00:14:10,340 --> 00:14:11,510
Does not work in cases

00:14:11,510 --> 00:14:14,710
where VTEPs are located on a multicast router.

00:14:14,710 --> 00:14:17,430
So basically it does not work well,

00:14:17,430 --> 00:14:18,510
as you see in this picture,

00:14:18,510 --> 00:14:22,430
when the VXLan driver and the PIM control plane

00:14:22,430 --> 00:14:24,373
are on the same node.

00:14:27,890 --> 00:14:30,490
So the VTEP on the switch, the ideal case,

00:14:30,490 --> 00:14:31,810
this is what we want to get to

00:14:31,810 --> 00:14:34,920
and this is what this talk is about,

00:14:34,920 --> 00:14:39,360
is basically VXLan driver only knows the multicast group

00:14:39,360 --> 00:14:42,800
to replicate to, and it relies on ipmr,

00:14:42,800 --> 00:14:46,480
the IP multicast routing table on the same node,

00:14:46,480 --> 00:14:49,873
to find the outgoing list of packets.

00:14:52,320 --> 00:14:54,170
So a little bit on multicast routing.

00:14:55,020 --> 00:14:58,120
Multicast IP routing is used to distribute

00:14:59,050 --> 00:15:01,970
to multiple recipients, or multiple recipients

00:15:01,970 --> 00:15:03,510
who are interested in the multicast traffic.

00:15:03,510 --> 00:15:06,033
And that's how it is an optimized way to flood.

00:15:08,200 --> 00:15:12,870
I also talked about PIM, so let's move on here.

00:15:12,870 --> 00:15:17,060
Linux kernel multicast code is in impr.c.

00:15:17,060 --> 00:15:20,503
Received IP multicast packets actually get into ip_mr_input,

00:15:21,400 --> 00:15:23,650
and ip_mr_input actually decides whether it needs

00:15:23,650 --> 00:15:28,303
to forward or locally receive that multicast traffic.

00:15:29,480 --> 00:15:31,400
Locally generated multicast traffic,

00:15:31,400 --> 00:15:33,290
and we are talking about locally generated here

00:15:33,290 --> 00:15:37,630
because VXLan-encapped multicast packets is what

00:15:37,630 --> 00:15:39,660
we are interested in.

00:15:39,660 --> 00:15:43,280
And those actually hit ip_mc_output directly,

00:15:43,280 --> 00:15:47,893
which outputs it, Txs it through a device.

00:15:50,210 --> 00:15:52,420
So locally generated packets don't go

00:15:52,420 --> 00:15:54,040
through the multicast routing lookup,

00:15:54,040 --> 00:15:56,963
and that's the problem that we see with VXLan.

00:15:58,800 --> 00:16:02,770
What happens is, VXLan actually sets, it takes the device,

00:16:02,770 --> 00:16:05,600
it sets the OIF, and once it sets the OIF,

00:16:05,600 --> 00:16:09,350
this bypasses all routing checks

00:16:09,350 --> 00:16:13,930
in ip_route_output function,

00:16:13,930 --> 00:16:16,303
and it hits ip_mc_output directly.

00:16:17,310 --> 00:16:21,180
So ipmr has ip_mr_input today,

00:16:21,180 --> 00:16:23,340
but no equivalent ip_mr_output,

00:16:23,340 --> 00:16:25,620
which is what is needed here.

00:16:25,620 --> 00:16:30,620
And ip_mc_output directly xmits it out of the static OIF.

00:16:30,850 --> 00:16:34,700
This is just a picture of what I described just now.

00:16:34,700 --> 00:16:37,680
VXLan driver takes the OIF

00:16:37,680 --> 00:16:41,913
and uses that OIF in the route lookup, which is a problem.

00:16:46,310 --> 00:16:49,850
Yeah, so what this means is basically does not work,

00:16:49,850 --> 00:16:52,847
the OIF list that is used for the VXLan is not used.

00:16:52,847 --> 00:16:53,680
It cannot be used

00:16:53,680 --> 00:16:56,563
in a dynamic multicast routing environment with PIM.

00:16:57,920 --> 00:17:00,122
And why is this needed though?

00:17:00,122 --> 00:17:03,743
So distribution, like I showed in one of the slides,

00:17:04,630 --> 00:17:08,160
the PIM or the multicast control plane

00:17:08,160 --> 00:17:11,310
and ipmr know exactly how many parts

00:17:11,310 --> 00:17:14,293
they have to distribute the multicast traffic over.

00:17:15,300 --> 00:17:19,470
Also, in cases of Multihoming, Multihoming is something

00:17:19,470 --> 00:17:23,143
that I talked in at last LPC, again involving VXLan,

00:17:25,370 --> 00:17:27,880
and a PIM implementation

00:17:29,060 --> 00:17:32,940
that understands Multihoming is actually capable of

00:17:35,430 --> 00:17:38,570
programming the IP multicast routing database

00:17:38,570 --> 00:17:43,570
with OIFs that point to the peer Multihoming routers

00:17:47,222 --> 00:17:49,680
to re-route the traffic.

00:17:49,680 --> 00:17:53,053
So that's why the dynamic environment is important.

00:17:55,420 --> 00:17:56,963
So the need for ip_mr_output.

00:18:00,600 --> 00:18:03,700
So basically all multicast traffic,

00:18:03,700 --> 00:18:05,250
locally generated multicast traffic,

00:18:05,250 --> 00:18:06,803
actually hits ip_mc_output,

00:18:07,740 --> 00:18:09,990
and it does not go through ip_mr_lookup.

00:18:09,990 --> 00:18:12,793
That's what this talks about again.

00:18:16,620 --> 00:18:18,270
So the changes required here,

00:18:18,270 --> 00:18:21,420
the OIF in VXLan driver is still needed,

00:18:21,420 --> 00:18:26,220
because you want to tell the kernel data path

00:18:26,220 --> 00:18:30,710
that there is multicast, there is a node,

00:18:30,710 --> 00:18:32,597
or there is a endpoint on the local node

00:18:34,850 --> 00:18:38,040
that is interested in the multicast traffic.

00:18:38,040 --> 00:18:41,073
This is basically for Rxing the multicast traffic,

00:18:42,690 --> 00:18:47,083
receiving VXLan tunnel packets and terminating them.

00:18:48,090 --> 00:18:51,280
And this has to be achieved by IGMP join.

00:18:51,280 --> 00:18:54,930
So you need the OIF, but what you want to do is

00:18:54,930 --> 00:18:58,850
you do not want to use that OIF in the routing lookups.

00:18:58,850 --> 00:19:02,913
So basically this has to be another VXLan flag.

00:19:03,910 --> 00:19:06,210
VXLan driver at this point has a lot of flags.

00:19:07,377 --> 00:19:10,980
And this flag basically tells you that use ipmr

00:19:10,980 --> 00:19:15,933
or IP multicast routing to find the real outgoing list.

00:19:17,090 --> 00:19:22,090
We do have patches, but they are still being soaked.

00:19:22,200 --> 00:19:25,470
Basically and, ipmr patches

00:19:25,470 --> 00:19:27,860
also need an ipmr six equivalent.

00:19:27,860 --> 00:19:32,860
So, and we have a huge test suite to test VXLan overlays,

00:19:34,940 --> 00:19:38,853
but it does not support IPv6 at the moment and so,

00:19:40,650 --> 00:19:42,390
yeah, actually we carry a bunch of patches

00:19:42,390 --> 00:19:47,210
to even create VXLan on IPv6 underlay

00:19:47,210 --> 00:19:50,270
and then have it stitched into our test framework

00:19:50,270 --> 00:19:51,833
to be able to test this.

00:19:53,280 --> 00:19:56,890
And this is, this actually touches

00:19:56,890 --> 00:20:01,890
all locally generated multicast traffic, so we are hesitant.

00:20:03,520 --> 00:20:05,500
So basically we are trying to see

00:20:05,500 --> 00:20:08,260
how much test coverage we can get,

00:20:08,260 --> 00:20:12,040
because we don't want to break any multicast applications,

00:20:12,040 --> 00:20:15,170
other applications, so I think what we have done is,

00:20:15,170 --> 00:20:18,920
the code, right now it will fallback to the old ip_mc_output

00:20:20,470 --> 00:20:23,013
if the ip_mr_forward lookup fails.

00:20:25,650 --> 00:20:29,070
And with this, you can see a slight indirection

00:20:29,070 --> 00:20:30,540
in the output path.

00:20:30,540 --> 00:20:33,190
Basically it does an ip_mr_output,

00:20:33,190 --> 00:20:37,000
which does an ipmr lookup on the transmit path,

00:20:37,000 --> 00:20:40,720
and then finds the outgoing list

00:20:42,010 --> 00:20:44,870
instead of relying on the outgoing list from the packet

00:20:44,870 --> 00:20:48,467
or the flow that came into ip_route_output.

00:20:49,520 --> 00:20:53,343
And then eventually does an ip_mc_output, as usual.

00:20:56,230 --> 00:20:59,540
So, I'm almost reaching the end of the talk.

00:20:59,540 --> 00:21:01,890
Bigger picture, this is a busy slide,

00:21:01,890 --> 00:21:05,593
but this is what it looks like.

00:21:06,520 --> 00:21:09,230
Rack1 and Rack2, you have switches

00:21:09,230 --> 00:21:13,120
that are running the multicast control plane,

00:21:13,120 --> 00:21:15,880
they are running a VXLan control plane,

00:21:15,880 --> 00:21:18,770
and they have the VXLan device

00:21:18,770 --> 00:21:22,110
to initiate and terminate VXLan tunnels.

00:21:22,110 --> 00:21:25,620
And on each rack, to cover the Multihoming case,

00:21:25,620 --> 00:21:28,810
there are these two switches that are actually connected

00:21:28,810 --> 00:21:32,250
by a peer link to re-route traffic.

00:21:32,250 --> 00:21:35,010
And as you can see, the Vms in the racks,

00:21:35,010 --> 00:21:38,740
they eventually get connected to both the switches.

00:21:38,740 --> 00:21:43,460
And there is a little bit of work in the control plane,

00:21:43,460 --> 00:21:46,150
actually the control plane becomes more complex

00:21:46,150 --> 00:21:49,530
when it involves a Multihoming case.

00:21:49,530 --> 00:21:52,133
And, yeah.

00:21:53,590 --> 00:21:54,953
So, futures.

00:21:57,070 --> 00:21:59,820
There are a lot of multicast optimizations

00:21:59,820 --> 00:22:03,380
still being done for VXLan,

00:22:03,380 --> 00:22:05,010
mostly at the control plane level,

00:22:05,010 --> 00:22:07,950
but then these end up requiring some changes

00:22:07,950 --> 00:22:09,260
in the VXLan driver.

00:22:09,260 --> 00:22:13,000
For example, last year I talked about the same thing,

00:22:13,000 --> 00:22:16,290
scaling the VXLan forwarding database

00:22:19,519 --> 00:22:20,380
for the Multihoming case,

00:22:20,380 --> 00:22:22,500
so that the control plane can insert

00:22:22,500 --> 00:22:27,500
and delete, or insert and re-route traffic faster.

00:22:29,920 --> 00:22:33,260
And I talked about FDBs using the nexthop groups,

00:22:33,260 --> 00:22:36,910
and there is a nexthop groups talk by David some time.

00:22:36,910 --> 00:22:40,003
I think it's the last talk on Wednesday.

00:22:40,940 --> 00:22:44,050
So these optimizations are still being done,

00:22:44,050 --> 00:22:45,740
for example Selective Multicast,

00:22:45,740 --> 00:22:50,360
in this case is, as I've talked before,

00:22:50,360 --> 00:22:55,273
IGMP is something that is used to datamine receivers

00:22:57,730 --> 00:22:59,780
that are interested in a multicast group.

00:23:00,993 --> 00:23:03,660
And that is again, IGMP reports,

00:23:05,089 --> 00:23:10,016
and there is a lot of things that go on in an IGMP protocol.

00:23:10,016 --> 00:23:12,349
And if you can, for example,

00:23:14,560 --> 00:23:18,390
the layer two domain is being extended using VXLan

00:23:18,390 --> 00:23:23,390
to a larger domain now, and having this IGMP flooding also

00:23:23,730 --> 00:23:27,330
to datamined receivers and sources

00:23:27,330 --> 00:23:30,410
across the data center becomes heavy.

00:23:30,410 --> 00:23:33,580
Again, it's like a lot of traffic,

00:23:33,580 --> 00:23:37,990
and so there is a lot of RFCs and discussions

00:23:37,990 --> 00:23:40,310
and ideas right now which are going around

00:23:40,310 --> 00:23:43,940
to better implement IGMP for these environments.

00:23:43,940 --> 00:23:46,640
Basically the control plane carries some of

00:23:46,640 --> 00:23:48,620
this IGMP distribution.

00:23:48,620 --> 00:23:51,960
Instead of flooding over the VXLan tunnels,

00:23:51,960 --> 00:23:56,690
they use the VXLan control plane

00:23:56,690 --> 00:23:59,520
to actually distribute this via BGP.

00:23:59,520 --> 00:24:01,730
So that's another thing that will require changes

00:24:01,730 --> 00:24:04,480
in the VXLan to handle IGMP

00:24:04,480 --> 00:24:07,940
or handle multicast forwarding information.

00:24:07,940 --> 00:24:11,510
Then we have a similar concept of ARP proxy

00:24:11,510 --> 00:24:15,140
to avoid ARP flooding over VXLan tunnels.

00:24:15,140 --> 00:24:19,680
Similarly IGMP and MLD proxy is also being discussed.

00:24:19,680 --> 00:24:24,680
There is an RFC for this to proxy these requests.

00:24:27,290 --> 00:24:29,430
This is a list, a long list, of RFCs,

00:24:29,430 --> 00:24:32,393
if you're ever interested in multicast and VXLan.

00:24:35,600 --> 00:24:38,273
Yeah, that's about it.

00:24:39,870 --> 00:24:43,170
- Thank you Roopa, if we have any questions,

00:24:43,170 --> 00:24:46,169
make sure you get one of these boxes and speak into it

00:24:46,169 --> 00:24:48,110
because everything is being recorded.

00:24:48,110 --> 00:24:49,510
Yeah, he'll throw it at you.

00:24:50,390 --> 00:24:51,737
- So this, wow.

00:24:51,737 --> 00:24:54,730
(audience laughing)

00:24:54,730 --> 00:24:56,090
Hi, I'm Dave Taht.

00:24:56,090 --> 00:24:58,610
In part I'm trying to cut down the scope of multicast,

00:24:58,610 --> 00:25:00,620
which is my talk tomorrow.

00:25:00,620 --> 00:25:03,550
One of the questions that I have that makes my head hurt

00:25:03,550 --> 00:25:06,700
is what happens if you try running a multicast protocol

00:25:06,700 --> 00:25:08,860
over this multicast protocol?

00:25:08,860 --> 00:25:13,860
Example would be mDNS, I do a service lookup for that,

00:25:13,880 --> 00:25:15,173
what happens?

00:25:16,500 --> 00:25:18,788
- I don't know, my head hurts too.

00:25:18,788 --> 00:25:21,500
(audience lauging)

00:25:21,500 --> 00:25:23,210
Yeah, I don't know.

00:25:23,210 --> 00:25:27,360
Actually, the multicast control plane is very horrid

00:25:27,360 --> 00:25:29,040
and with the Multihoming,

00:25:29,040 --> 00:25:31,250
I actually want to thank a lot of people who work

00:25:31,250 --> 00:25:34,780
on the multicast control plane, who live this every day.

00:25:34,780 --> 00:25:35,733
And, yeah.

00:25:37,130 --> 00:25:38,383
Sorry, I don't know.

00:25:40,010 --> 00:25:41,303
- Any other questions?

00:25:46,550 --> 00:25:47,400
- [Male Attendee] You can throw it, dude.

00:25:47,400 --> 00:25:48,303
- I could.

00:25:49,330 --> 00:25:51,830
I feel like someone took it off the head one time.

00:25:53,303 --> 00:25:54,533
- [David] That's the whole idea.

00:25:55,870 --> 00:25:59,930
- You mentioned a lot about VXLan across the data center.

00:25:59,930 --> 00:26:02,750
Do you also see a use case for VXLan

00:26:02,750 --> 00:26:06,220
across multiple geographically dispersed data centers?

00:26:06,220 --> 00:26:08,300
Or is that not scaling well yet?

00:26:08,300 --> 00:26:12,550
- So there is something called the same E-VPN

00:26:12,550 --> 00:26:16,200
across data centers, it's called E-VPN DCI,

00:26:16,200 --> 00:26:19,230
data center interconnect, so yes,

00:26:19,230 --> 00:26:21,630
there are RFCs to cover that as well,

00:26:21,630 --> 00:26:24,393
basically, yeah, across the WAN.

00:26:28,178 --> 00:26:30,147
- [Male Attendee] Throw it.

00:26:30,147 --> 00:26:31,986
- And I didn't lose my head.

00:26:31,986 --> 00:26:36,986
Hi, with respect to her question, following on on that,

00:26:37,810 --> 00:26:40,750
with Edge and IoT we might have VXLans

00:26:40,750 --> 00:26:43,960
that span geographic areas.

00:26:43,960 --> 00:26:47,050
What if you don't know that you want to subscribe

00:26:47,050 --> 00:26:50,123
to a certain network, I mean how do you handle that?

00:26:51,790 --> 00:26:53,220
- As a node?

00:26:53,220 --> 00:26:57,640
- As, this feels a lot like publish and subscribe,

00:26:57,640 --> 00:27:00,230
and what if there's a new network you want to be a part of

00:27:00,230 --> 00:27:02,600
and you don't even know yet to register

00:27:02,600 --> 00:27:05,130
that you want to listen.

00:27:05,130 --> 00:27:07,170
- So new networks are discovered by flooding,

00:27:07,170 --> 00:27:08,763
is that what you're getting at?

00:27:10,120 --> 00:27:12,707
- Yeah, but then it felt like you had to say,

00:27:12,707 --> 00:27:14,980
"I want to join a network, foo."

00:27:14,980 --> 00:27:17,270
And you don't even know there is a foo initially,

00:27:17,270 --> 00:27:20,040
and then, so you have to tell all the nodes and the switches

00:27:20,040 --> 00:27:23,170
in between, "Hey, please find me foo type of thing."

00:27:23,170 --> 00:27:26,480
- Yeah, so that's usually achieved by flooding

00:27:26,480 --> 00:27:30,710
and multicast is used as an optimization to that flooding.

00:27:30,710 --> 00:27:31,770
- [Audience Member] Okay.

00:27:31,770 --> 00:27:34,180
- So basically your VXLan tunnel endpoints,

00:27:34,180 --> 00:27:38,560
they all register a multicast group, right?

00:27:38,560 --> 00:27:43,560
And every rack or every port or a group of nodes,

00:27:43,800 --> 00:27:45,413
if your new network is a port,

00:27:46,580 --> 00:27:50,160
it joins or it's built into the network as anything else,

00:27:50,160 --> 00:27:55,120
and the VXLan control plane, if it doesn't know about it,

00:27:55,120 --> 00:27:58,870
it has not discovered it yet, it'll resort to flooding.

00:27:58,870 --> 00:28:02,420
And obviously the administrator would have configured

00:28:02,420 --> 00:28:05,110
a VXLan multicast endpoint at that end.

00:28:05,110 --> 00:28:10,060
So what happens is you, yeah, you will flood the traffic

00:28:10,060 --> 00:28:13,830
and that, basically if you think of it like an ARP request,

00:28:13,830 --> 00:28:15,720
so it'll go to that other node

00:28:15,720 --> 00:28:19,970
and that node will actually flood it in the local domain.

00:28:19,970 --> 00:28:22,840
So it will get to all your nodes, and they'll respond,

00:28:22,840 --> 00:28:26,943
and that's how the whole control plane gets,

00:28:29,290 --> 00:28:30,770
knows about the host.

00:28:30,770 --> 00:28:33,930
- So with these, you know, like with IoT and it being

00:28:33,930 --> 00:28:37,610
way more distributed, how would this affect your timeouts

00:28:37,610 --> 00:28:41,610
or time-to-live type of thing for these flooding packets?

00:28:41,610 --> 00:28:45,990
- The IoT and VXLan, I am not very sure on the performance.

00:28:45,990 --> 00:28:46,823
- It's all kind of new,

00:28:46,823 --> 00:28:50,660
but I think this would be a use case just for security

00:28:50,660 --> 00:28:52,450
in overlay networks.

00:28:52,450 --> 00:28:53,540
- Yeah, sure.

00:28:53,540 --> 00:28:57,390
I've not seen any studies on the performance impact

00:28:58,367 --> 00:29:01,910
of scaling to IoDs. - Thank you.

00:29:01,910 --> 00:29:03,210
- [David] He can catch it.

00:29:04,680 --> 00:29:05,933
- There we go.

00:29:05,933 --> 00:29:07,022
- Thanks.

00:29:07,022 --> 00:29:10,630
Roopa, you said early in your talk

00:29:10,630 --> 00:29:13,250
that solutions to this problem involve either flooding

00:29:13,250 --> 00:29:16,450
when you have a VTEP endpoint that says if yet undiscovered,

00:29:16,450 --> 00:29:19,336
or using a controller to program your forwarding database.

00:29:19,336 --> 00:29:20,169
- [Roopa] Yeah.

00:29:20,169 --> 00:29:22,030
- What's the advantage to using multicast here?

00:29:22,030 --> 00:29:23,970
It seems like you're generating a lot of traffic

00:29:23,970 --> 00:29:27,010
for not necessarily a lot of value added

00:29:27,010 --> 00:29:29,350
in terms of discovery time.

00:29:29,350 --> 00:29:34,140
- Yeah, so for small environments, the orchestrator

00:29:34,140 --> 00:29:35,800
who knows about all the endpoints,

00:29:35,800 --> 00:29:40,350
like some of these virtual hypervisors

00:29:42,100 --> 00:29:46,600
which provide a distributed cloud or provisioning systems,

00:29:46,600 --> 00:29:48,270
they know about every node

00:29:48,270 --> 00:29:51,090
or every allocation of MAC address and IP,

00:29:51,090 --> 00:29:54,850
and they can program their control plane

00:29:54,850 --> 00:29:58,820
or the forwarding database saying that that node is present.

00:29:58,820 --> 00:30:01,530
But there is also this discovery factor, right?

00:30:01,530 --> 00:30:05,430
You have to provide flooding for those nodes

00:30:05,430 --> 00:30:08,930
that the control plane does not know about yet.

00:30:08,930 --> 00:30:11,930
For dynamically coming and going environments.

00:30:11,930 --> 00:30:16,490
So yeah, so that's why E-VPN does exist,

00:30:16,490 --> 00:30:18,440
and E-VPN distributes this traffic,

00:30:18,440 --> 00:30:22,750
but still it allows for flooding for that small window

00:30:22,750 --> 00:30:24,460
when the control plane is catching up

00:30:24,460 --> 00:30:27,910
and the VMs are trying to reach each other.

00:30:27,910 --> 00:30:30,320
- So this is potentially an additive technology,

00:30:30,320 --> 00:30:32,974
not a sole technology for solving this problem.

00:30:32,974 --> 00:30:33,807
- [Roopa] Yeah.

00:30:33,807 --> 00:30:34,640
- Thanks.

00:30:36,630 --> 00:30:38,130
- [David] Any other questions?

00:30:41,440 --> 00:30:42,960
Okay, thank you very much Roopa.

00:30:42,960 --> 00:30:43,985
- [Roopa] Thank you.

00:30:43,985 --> 00:30:45,495

YouTube URL: https://www.youtube.com/watch?v=xlReECfi-uo


