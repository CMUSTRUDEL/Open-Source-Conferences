Title: LPC2019 - VFIO IOMMU PCI MC
Publication date: 2019-09-17
Playlist: Linux Plumbers Conference 2019
Description: 
	VFIO/IOMMU/PCI MC
Captions: 
	00:00:00,269 --> 00:00:03,111
- Hello everyone, good afternoon.

00:00:03,111 --> 00:00:06,444
I'm very glad to to be here and and and

00:00:08,731 --> 00:00:10,837
attended this is discussion,

00:00:10,837 --> 00:00:13,837
so today I bring one bring the topic

00:00:15,756 --> 00:00:19,506
I bring here is a group default domain type.

00:00:23,692 --> 00:00:28,167
So I will first briefly introduce what are the problems

00:00:28,167 --> 00:00:32,225
we are suffering and then I will propose

00:00:32,225 --> 00:00:35,308
how could we fix it and then I'd like

00:00:36,231 --> 00:00:38,231
to discuss the user API.

00:00:41,254 --> 00:00:45,837
First what what the problems we are suffering currently

00:00:46,769 --> 00:00:49,436
in IOMMU driver we have a global

00:00:51,001 --> 00:00:54,391
domain type called IOMMU_def_domain_type.

00:00:54,391 --> 00:00:57,195
This is determined by kernel configuration

00:00:57,195 --> 00:00:58,778
or boot parameters.

00:01:00,353 --> 00:01:03,554
And the boot commander parameters we

00:01:03,554 --> 00:01:07,391
override the kernel boot configuration.

00:01:07,391 --> 00:01:12,224
So this causes some problems, for example the problem one.

00:01:14,191 --> 00:01:17,917
So, what if default domain type is DMA while

00:01:17,917 --> 00:01:20,961
the users might want wanted to to bypass

00:01:20,961 --> 00:01:24,369
IOMMU for some super speed devices for

00:01:24,369 --> 00:01:27,934
example NIC device for performance

00:01:27,934 --> 00:01:31,017
consideration so and so we is current

00:01:31,918 --> 00:01:35,585
with current IOMMU driver we cannot do this.

00:01:36,495 --> 00:01:38,578
So then the next problem,

00:01:41,178 --> 00:01:44,062
for example if the deferred domain type is identity

00:01:44,062 --> 00:01:47,133
but users might want to DMA

00:01:47,133 --> 00:01:49,633
might want want to use DMA for

00:01:50,700 --> 00:01:53,367
some legacy 32 bit devices so so

00:01:55,611 --> 00:01:58,694
currently a different different IOMMU

00:02:00,144 --> 00:02:03,565
driver have have different solutions for example,

00:02:03,565 --> 00:02:07,048
if we use Intel's IOMMU a driver

00:02:07,048 --> 00:02:10,414
where we are forced, where we are first DMA

00:02:10,414 --> 00:02:12,997
for the legacy 32 bit devices.

00:02:15,971 --> 00:02:17,867
So, more and more users are looking forward

00:02:17,867 --> 00:02:20,897
to a fine grained default domain type.

00:02:20,897 --> 00:02:25,314
So, this is why I bring this topic to our discussion.

00:02:27,970 --> 00:02:30,581
- [Ben] Do we still have a 32-bit

00:02:30,581 --> 00:02:31,414
(faint speaking) - And discuss

00:02:31,414 --> 00:02:35,331
(faint speaking in background)

00:02:36,521 --> 00:02:38,256
(laughing)

00:02:38,256 --> 00:02:39,793
- Better.

00:02:39,793 --> 00:02:43,126
Do we have a domain type on Intel or AMD

00:02:44,439 --> 00:02:48,164
that supports both remapped region near the

00:02:48,164 --> 00:02:51,952
bottom (mumbles) devices and offset variant

00:02:51,952 --> 00:02:54,659
of the full NSG mapping near the top or we don't have that

00:02:54,659 --> 00:02:55,992
on Intel or AMD?

00:02:57,437 --> 00:02:58,270
(faint speaking in background)

00:02:58,270 --> 00:02:59,162
Okay.

00:02:59,162 --> 00:03:02,804
Because we've had cases of interesting devices

00:03:02,804 --> 00:03:06,505
that tend to set a current DMM mask at smaller

00:03:06,505 --> 00:03:08,305
than the actual DMM mask,

00:03:08,305 --> 00:03:11,847
it was one basically 32 bit things

00:03:11,847 --> 00:03:16,436
for some of the ring resources to save hardware resources.

00:03:16,436 --> 00:03:18,606
But they can deal with full 64 bit addresses

00:03:18,606 --> 00:03:20,196
for actual data transfers.

00:03:20,196 --> 00:03:23,151
And and so effectively, something like this

00:03:23,151 --> 00:03:26,401
would be forced to use your DMA domain.

00:03:28,149 --> 00:03:32,566
We solve that on some par by effectively having both.

00:03:34,691 --> 00:03:37,013
By having a window that is remapped at the bottom

00:03:37,013 --> 00:03:39,009
and the window that is an offset version

00:03:39,009 --> 00:03:41,951
of the direct mapping at the top.

00:03:41,951 --> 00:03:44,518
And then it become purely a policy

00:03:44,518 --> 00:03:47,837
to decide whether you authorize that second window

00:03:47,837 --> 00:03:50,873
as security mechanism or not.

00:03:50,873 --> 00:03:52,899
It's a bit trickier for guests

00:03:52,899 --> 00:03:57,399
because the bypass window is more difficult to create.

00:03:58,601 --> 00:04:00,337
But that's just food for thought.

00:04:00,337 --> 00:04:02,087
That's something that

00:04:03,111 --> 00:04:04,528
that been useful.

00:04:05,840 --> 00:04:08,116
But, yeah, continue.

00:04:08,116 --> 00:04:12,449
- Yeah, so, I think IOMMU (mumbles)

00:04:14,014 --> 00:04:16,681
dial support part of the address

00:04:19,156 --> 00:04:23,184
use the dynamic and part of the dial support.

00:04:23,184 --> 00:04:24,017
So, okay.

00:04:25,894 --> 00:04:29,238
So, how can we, how do we do it?

00:04:29,238 --> 00:04:32,488
So, my idea, my proposal is to we split

00:04:33,909 --> 00:04:35,409
the boot sequence.

00:04:36,279 --> 00:04:40,112
So, currently we doing boot, we allocate group

00:04:40,949 --> 00:04:43,911
and allocate a default domain

00:04:43,911 --> 00:04:45,421
and attach domain to device.

00:04:45,421 --> 00:04:49,004
And then if the attach failed, so IM driver

00:04:50,116 --> 00:04:55,116
might request a different domain type on attach failure.

00:04:55,405 --> 00:04:58,905
So, so now let's move the group allocation

00:05:00,159 --> 00:05:01,278
out of this loop.

00:05:01,278 --> 00:05:05,382
So, first we allocate a group for each device

00:05:05,382 --> 00:05:10,382
and at the same time, with determining the domain type.

00:05:10,606 --> 00:05:14,939
So, here, we maybe, that domain type maybe come from

00:05:16,239 --> 00:05:20,283
three sides, for example, that device, the driver

00:05:20,283 --> 00:05:25,116
might hard code some devices for some types of translation

00:05:27,707 --> 00:05:32,457
and the user maybe specify some devices to use some type.

00:05:35,521 --> 00:05:38,122
And also, we have a default domain type.

00:05:38,122 --> 00:05:41,955
So, all these driver will override user input.

00:05:43,830 --> 00:05:48,663
And the user input will override the global default value.

00:05:49,641 --> 00:05:53,724
So after we allocated the group and determine the

00:05:55,266 --> 00:05:59,098
default domain type, then we allocate the domain

00:05:59,098 --> 00:06:01,765
and attach the domain to device.

00:06:02,894 --> 00:06:04,171
- [2nd Participant] Just a question to help understand this.

00:06:04,171 --> 00:06:06,540
Is this, I mean the stuff on the left sounds like

00:06:06,540 --> 00:06:09,006
it happens at remuneration time.

00:06:09,006 --> 00:06:09,839
Is that right?

00:06:09,839 --> 00:06:11,420
As opposed to driver binding time?

00:06:11,420 --> 00:06:12,286
- Yeah.

00:06:12,286 --> 00:06:14,627
- And I'm not sure you're talking about,

00:06:14,627 --> 00:06:16,815
I assume you're talking about the driver binding time

00:06:16,815 --> 00:06:18,355
on the right.

00:06:18,355 --> 00:06:19,995
Is that true?

00:06:19,995 --> 00:06:21,956
So, you're moving things, proposing moving things

00:06:21,956 --> 00:06:24,853
from enumeration time to driver binding time?

00:06:24,853 --> 00:06:29,353
- No, just the split one loop to input into two loops.

00:06:32,539 --> 00:06:34,049
- Yeah, but you see, it still double enumeration.

00:06:34,049 --> 00:06:36,799
So, yeah, so one thing that I've,

00:06:38,881 --> 00:06:41,158
worried me about what we already do today

00:06:41,158 --> 00:06:44,075
with our IOMMU, in fact, is we have

00:06:45,469 --> 00:06:47,311
some dependency here on the fact that we have

00:06:47,311 --> 00:06:50,041
an enumeration pass that is separate from actually

00:06:50,041 --> 00:06:53,379
registering with a device model and binding the drivers.

00:06:53,379 --> 00:06:57,834
Not all buses have that, platform buses don't.

00:06:57,834 --> 00:07:02,583
Which mean, in non PCI cases, this is difficult

00:07:02,583 --> 00:07:04,927
because we don't have a way to have a holistic view

00:07:04,927 --> 00:07:08,713
of the bus and until we've started binding

00:07:08,713 --> 00:07:12,872
or they does raise a question that could come in

00:07:12,872 --> 00:07:15,734
and might help us (mumbles) is added hacks

00:07:15,734 --> 00:07:17,742
we have in PCIs.

00:07:17,742 --> 00:07:20,156
Generalize the ID of having the bus,

00:07:20,156 --> 00:07:23,304
which is in non active state

00:07:23,304 --> 00:07:26,392
where we add things but we do not bind drivers

00:07:26,392 --> 00:07:31,392
and we have an activate generic at the device model level

00:07:31,481 --> 00:07:34,300
mechanism on that said bus, where we actually

00:07:34,300 --> 00:07:37,240
(mumbles) to the binding and that will help

00:07:37,240 --> 00:07:39,211
with other cases where we might have some

00:07:39,211 --> 00:07:41,190
cross dependencies to solve et cetera.

00:07:41,190 --> 00:07:42,130
So, again, food for thought.

00:07:42,130 --> 00:07:44,882
Something that came to me a couple of times in the past

00:07:44,882 --> 00:07:46,981
and never really did anything about it.

00:07:46,981 --> 00:07:49,915
But, we effectively have that in PCI, which is

00:07:49,915 --> 00:07:53,392
added flag, which has always, I think,

00:07:53,392 --> 00:07:57,444
been unpleasant but we just dealt with it.

00:07:57,444 --> 00:07:59,597
And something like this, if we don't want to make

00:07:59,597 --> 00:08:04,264
it PCI specific, will probably want a similar mechanism.

00:08:06,807 --> 00:08:07,640
- Yes.

00:08:07,640 --> 00:08:09,640
That's the problem, yes.

00:08:11,382 --> 00:08:13,564
- I mean, this already exists for ARM

00:08:13,564 --> 00:08:14,783
with non PCI devices.

00:08:14,783 --> 00:08:17,674
I'm not sure what's PC - Non specific (mumbles)

00:08:17,674 --> 00:08:19,891
- No, I mean, the - (mumbling) to support

00:08:19,891 --> 00:08:20,844
non PCI models.

00:08:20,844 --> 00:08:21,987
- [Will] Yeah, there's already two hooks, right?

00:08:21,987 --> 00:08:23,549
There the add device and the attach device

00:08:23,549 --> 00:08:24,982
and that happens pretty early.

00:08:24,982 --> 00:08:26,126
- [Ben] But they happened together

00:08:26,126 --> 00:08:29,801
in a sense, cover (faint speaking) or not.

00:08:29,801 --> 00:08:32,379
The device model doesn't really have a mechanism

00:08:32,379 --> 00:08:36,469
for hooking up a device to - Sorry, the microphone.

00:08:36,469 --> 00:08:38,392
- We don't have a mechanism in Driver Core

00:08:38,392 --> 00:08:39,791
to hooking up a device to a bus

00:08:39,791 --> 00:08:42,257
without triggering the driver matching.

00:08:42,257 --> 00:08:44,684
So, we have some hooks, but these are not easily

00:08:44,684 --> 00:08:47,722
called when all of the devices are present yet.

00:08:47,722 --> 00:08:49,945
And I'm not even getting to hop back considerations here.

00:08:49,945 --> 00:08:52,945
But this, a lot of what we do in PCI

00:08:55,518 --> 00:08:58,595
require us to have a view of everything

00:08:58,595 --> 00:09:02,192
that we give in bus before we make decisions about it.

00:09:02,192 --> 00:09:03,025
And that - It's actually worse.

00:09:03,025 --> 00:09:04,818
Hot plugs make it all worse for Intel

00:09:04,818 --> 00:09:07,622
because of he way the BIOS tables describe devices.

00:09:07,622 --> 00:09:09,697
And so we have a first enumeration pass.

00:09:09,697 --> 00:09:11,287
I don't know if we've properly fixed this

00:09:11,287 --> 00:09:13,753
to cope with a hot plug because of the way

00:09:13,753 --> 00:09:18,083
that it lists certain, which devices are behind which IOMMU.

00:09:18,083 --> 00:09:20,007
And if they don't exist at the moment,

00:09:20,007 --> 00:09:22,981
that is past, where it used to be the case,

00:09:22,981 --> 00:09:25,142
then they it doesn't get tagged correctly.

00:09:25,142 --> 00:09:27,567
And when it's later hot plugged,

00:09:27,567 --> 00:09:28,972
the (mumbling)

00:09:28,972 --> 00:09:31,509
we have another pass for the Intel one.

00:09:31,509 --> 00:09:33,259
- And the PCI path is

00:09:35,479 --> 00:09:38,279
allegedly better because in theory,

00:09:38,279 --> 00:09:40,438
hot plug happens, these day at least,

00:09:40,438 --> 00:09:43,080
behind hot plug motors and so you tend

00:09:43,080 --> 00:09:46,092
to not have siblings showing up the big machine.

00:09:46,092 --> 00:09:49,503
Probably do, and possibly, the way BIOSs do

00:09:49,503 --> 00:09:52,209
are things like enabling and disabling

00:09:52,209 --> 00:09:55,660
random chips and PCI devices and thing like this.

00:09:55,660 --> 00:09:57,385
And so in practice, we do have siblings

00:09:57,385 --> 00:09:59,498
showing up on an existing bus.

00:09:59,498 --> 00:10:00,876
And they're gonna have to cope

00:10:00,876 --> 00:10:04,973
with whatever decision we've made for that bus,

00:10:04,973 --> 00:10:08,909
which is not necessarily can not necessarily

00:10:08,909 --> 00:10:11,007
be a separate group or domain.

00:10:11,007 --> 00:10:12,340
So, it's a mess.

00:10:13,395 --> 00:10:16,354
But yeah, to go back to your point because

00:10:16,354 --> 00:10:19,373
I'm sorry, I'm using up your time.

00:10:19,373 --> 00:10:22,556
Within the existing context of having that bus there,

00:10:22,556 --> 00:10:24,918
splitting up in two makes sense.

00:10:24,918 --> 00:10:26,683
I don't see a problem with that.

00:10:26,683 --> 00:10:30,024
I'm just more quite more interested in how do you intend

00:10:30,024 --> 00:10:31,937
to communicate the configuration information

00:10:31,937 --> 00:10:35,095
from user space to the kernel.

00:10:35,095 --> 00:10:36,357
At what point does that happen?

00:10:36,357 --> 00:10:37,411
Because those bus that will happen automatically

00:10:37,411 --> 00:10:38,956
at boot time anyway.

00:10:38,956 --> 00:10:40,873
So, show, - The problem

00:10:42,160 --> 00:10:45,938
from splitting the default domain type

00:10:45,938 --> 00:10:49,562
attachment from device enumeration is that

00:10:49,562 --> 00:10:51,813
you lose certain security features.

00:10:51,813 --> 00:10:54,960
So, the option is that you don't attach the device

00:10:54,960 --> 00:10:56,562
to any domain and just let it pass through

00:10:56,562 --> 00:10:58,786
until the driver comes around.

00:10:58,786 --> 00:11:01,311
But then the device has full access to everything.

00:11:01,311 --> 00:11:02,978
You don't what that.

00:11:04,312 --> 00:11:06,657
- In fact, allegedly, we want to have a domain, not a

00:11:06,657 --> 00:11:10,396
- And you can, you also can block the device by default?

00:11:10,396 --> 00:11:11,336
- Yeah.

00:11:11,336 --> 00:11:13,694
- Because there might be devices which have

00:11:13,694 --> 00:11:14,694
our regions.

00:11:15,725 --> 00:11:18,109
For the BIOS, USB controllers for example,

00:11:18,109 --> 00:11:20,942
or other devices like yeah I think

00:11:22,748 --> 00:11:24,903
some network concepts this too.

00:11:24,903 --> 00:11:27,224
And some platforms.

00:11:27,224 --> 00:11:29,110
- They are under control of the firmware until a certain

00:11:29,110 --> 00:11:32,223
- So, we need do something with the device

00:11:32,223 --> 00:11:33,368
at attachment time.

00:11:33,368 --> 00:11:36,443
At detection time, at enumeration time.

00:11:36,443 --> 00:11:39,693
So, and the question is when you want a

00:11:42,854 --> 00:11:44,851
program default domain time at enumeration time,

00:11:44,851 --> 00:11:49,851
it could but my question is how you want to specify that.

00:11:50,214 --> 00:11:53,342
- Yeah, that's in my next - Okay.

00:11:53,342 --> 00:11:55,834
- So, this, so user API,

00:11:55,834 --> 00:11:59,834
so we can introduce two IOMMU a commander option

00:12:02,292 --> 00:12:05,209
to specify what kind of domain type

00:12:06,094 --> 00:12:09,190
do you want to for some specific devices?

00:12:09,190 --> 00:12:12,564
For example, the DMA is for the DMA mapping

00:12:12,564 --> 00:12:15,239
and the identity is for the identity mapping.

00:12:15,239 --> 00:12:16,739
- So, we find out,

00:12:17,578 --> 00:12:22,500
the question is that this could give two different

00:12:22,500 --> 00:12:24,213
default domain types for the same group.

00:12:24,213 --> 00:12:27,325
You can specify one device of a group in DMA

00:12:27,325 --> 00:12:29,403
and one in identity.

00:12:29,403 --> 00:12:31,014
And then - to specify the same device?

00:12:31,014 --> 00:12:35,345
- No, given you have a group that two or more devices

00:12:35,345 --> 00:12:36,883
and you specify one device and DMA

00:12:36,883 --> 00:12:38,927
and the other in identity, then,

00:12:38,927 --> 00:12:40,046
the question is what to do about that.

00:12:40,046 --> 00:12:41,475
- Where we have detectors that conflict

00:12:41,475 --> 00:12:44,993
and print a message in the kernel message,

00:12:44,993 --> 00:12:47,674
but I think we can use, first of all,

00:12:47,674 --> 00:12:50,705
we needed to kill the user data used

00:12:50,705 --> 00:12:53,705
that conflict certain helping input.

00:12:56,089 --> 00:13:01,089
So, and there we, I think we can use the first that come,

00:13:01,118 --> 00:13:03,521
first service for serve.

00:13:03,521 --> 00:13:06,309
- [Ben] First of all, I don't (mumbles)

00:13:06,309 --> 00:13:09,123
The one problem I see here

00:13:09,123 --> 00:13:12,134
(laughing)

00:13:12,134 --> 00:13:13,731
- [Man] Can't Ben speak, just no topic.

00:13:13,731 --> 00:13:15,327
(laughing)

00:13:15,327 --> 00:13:17,744
- So, is this is not working.

00:13:19,175 --> 00:13:22,675
It's still, trying to come with arguments.

00:13:24,590 --> 00:13:27,340
(faint speaking)

00:13:29,088 --> 00:13:30,180
- Go ahead, it's fine.

00:13:30,180 --> 00:13:31,096
- It was really quiet.

00:13:31,096 --> 00:13:32,893
- Yeah, it's fine.

00:13:32,893 --> 00:13:33,885
We can hear.

00:13:33,885 --> 00:13:38,885
- It's, it's still, it can't come with an average, right,

00:13:39,258 --> 00:13:40,859
which means it's still something that's only going

00:13:40,859 --> 00:13:44,442
to be useful for very very small (buzzing)

00:13:44,442 --> 00:13:48,238
Oops, (mumbling) for all the people out there.

00:13:48,238 --> 00:13:50,993
And it's not something that is too easy

00:13:50,993 --> 00:13:52,790
be able to deal with manager, like,

00:13:52,790 --> 00:13:55,786
no, you want to have a configuration plan

00:13:55,786 --> 00:13:57,285
where you say, oh, I trust that thing.

00:13:57,285 --> 00:14:00,684
I want it fast and secure, trust that thing.

00:14:00,684 --> 00:14:03,341
Generate (mumbles) and alignment become arm's length

00:14:03,341 --> 00:14:05,737
and that's not gonna work.

00:14:05,737 --> 00:14:06,980
And it's a problem and I don't know

00:14:06,980 --> 00:14:09,882
what solution could be here and with these two

00:14:09,882 --> 00:14:13,772
(mumbles) driver modules, which mean maybe,

00:14:13,772 --> 00:14:16,721
on of them had a chance to do something

00:14:16,721 --> 00:14:19,721
before it loads them, in which case,

00:14:20,842 --> 00:14:22,438
it makes sense to (mumbles)

00:14:22,438 --> 00:14:24,547
maybe complicated by something else.

00:14:24,547 --> 00:14:26,625
To be able to specify these things

00:14:26,625 --> 00:14:28,887
and to have them apply what (mumbles)

00:14:28,887 --> 00:14:29,897
of the drivers start binding.

00:14:29,897 --> 00:14:31,964
The minute a driver points to the device,

00:14:31,964 --> 00:14:34,834
whatever group has select then points it

00:14:34,834 --> 00:14:37,084
that device becomes frozen.

00:14:38,134 --> 00:14:42,488
But to keep things in flux, the driver binds.

00:14:42,488 --> 00:14:44,938
And food for though again,

00:14:44,938 --> 00:14:47,968
but I tried to think of it in a term of distro

00:14:47,968 --> 00:14:50,360
and configuration by the user.

00:14:50,360 --> 00:14:52,741
This is probably fine for your average HPC user,

00:14:52,741 --> 00:14:56,024
which is happy to have a three page room kernel (mumbles)

00:14:56,024 --> 00:14:58,660
completely tuned to the system.

00:14:58,660 --> 00:15:01,574
But in the more generic case,

00:15:01,574 --> 00:15:04,991
it's not really going to be partly usable

00:15:06,554 --> 00:15:08,273
is what is not usable.

00:15:08,273 --> 00:15:10,566
- Right, and this is PCI specific.

00:15:10,566 --> 00:15:11,399
- As well.

00:15:12,644 --> 00:15:13,477
In addition.

00:15:13,477 --> 00:15:15,240
Yeah, this one's working better.

00:15:15,240 --> 00:15:18,107
- To cope with device (mumbles)

00:15:18,107 --> 00:15:19,733
- No, it was broken.

00:15:19,733 --> 00:15:22,483
(faint speaking)

00:15:24,700 --> 00:15:28,039
- [Man] And you'd want it to be produced at runtime.

00:15:28,039 --> 00:15:29,181
- Yeah.

00:15:29,181 --> 00:15:32,514
You might have to RM mode in the driver.

00:15:33,556 --> 00:15:35,193
Maybe we can even invent a new driver hook

00:15:35,193 --> 00:15:36,478
to tell it, oh, let us configure it

00:15:36,478 --> 00:15:38,051
and (mumbles) all your DNAs.

00:15:38,051 --> 00:15:38,884
I don't know.

00:15:38,884 --> 00:15:41,139
We can make things up but you want to be

00:15:41,139 --> 00:15:43,565
something that can at least,

00:15:43,565 --> 00:15:48,315
or at least set up for the next boot in a reasonable way.

00:15:50,090 --> 00:15:53,898
- Do we need to use this to have dynamic groups

00:15:53,898 --> 00:15:58,567
that maybe the devices in a group disappear and re appear

00:15:58,567 --> 00:16:00,960
with the properties you provide the (mumbling)

00:16:00,960 --> 00:16:02,597
or something like that?

00:16:02,597 --> 00:16:06,231
'Cause I agree this is gonna be a horrendous command line

00:16:06,231 --> 00:16:08,541
and it doesn't match well that we have

00:16:08,541 --> 00:16:12,006
we're specifying devices when we're really setting

00:16:12,006 --> 00:16:15,089
trying to describe groups of devices.

00:16:16,801 --> 00:16:20,551
- This is turning into buff territory again.

00:16:20,551 --> 00:16:22,989
Not really, because we're opening a lot

00:16:22,989 --> 00:16:26,123
of can of worms that we've had in,

00:16:26,123 --> 00:16:30,617
one of them is we have no good way to tell drivers

00:16:30,617 --> 00:16:33,240
that some horrendous stuff is happening on the PCI.

00:16:33,240 --> 00:16:34,924
Please stop what you are doing and get ready

00:16:34,924 --> 00:16:36,166
to reinitialize yourself.

00:16:36,166 --> 00:16:37,420
Windows has it.

00:16:37,420 --> 00:16:40,566
You can wipe the IOMMU driver underneath the driver

00:16:40,566 --> 00:16:41,646
and put a new one in.

00:16:41,646 --> 00:16:44,514
And it recovers at runtime.

00:16:44,514 --> 00:16:47,474
The ability to have the, to tell a a device

00:16:47,474 --> 00:16:50,864
that your bus interface is being reinitialized,

00:16:50,864 --> 00:16:52,873
stop what you're doing.

00:16:52,873 --> 00:16:54,390
It's not that hard to do for drivers.

00:16:54,390 --> 00:16:56,369
Only til driver have some form to reset

00:16:56,369 --> 00:17:00,478
to work thread to deal with error conditions,

00:17:00,478 --> 00:17:01,500
things like this.

00:17:01,500 --> 00:17:03,753
It's gonna probably the same as a suspend resume path

00:17:03,753 --> 00:17:05,073
in many many many cases.

00:17:05,073 --> 00:17:08,579
But we could probably use that as a fallback

00:17:08,579 --> 00:17:11,594
if we don't have anything else.

00:17:11,594 --> 00:17:15,553
But having the ability to especially for what a (mumbles)

00:17:15,553 --> 00:17:16,493
form to move things around

00:17:16,493 --> 00:17:18,154
because we're running out of space, right.

00:17:18,154 --> 00:17:19,976
Take the driver off the bus.

00:17:19,976 --> 00:17:22,542
Shuffle the BARs and bring them back on

00:17:22,542 --> 00:17:25,125
is not necessarily something we

00:17:27,477 --> 00:17:28,568
- You're asking the graduate questions.

00:17:28,568 --> 00:17:29,984
Let me ask the kindergarten question

00:17:29,984 --> 00:17:33,119
of why do we need to set up the IOMMU

00:17:33,119 --> 00:17:34,952
before PCI set master?

00:17:38,843 --> 00:17:40,433
(faint speaking in background)

00:17:40,433 --> 00:17:42,500
- Well, you're talking about setting it up

00:17:42,500 --> 00:17:43,963
before we load the driver.

00:17:43,963 --> 00:17:47,129
My question is why do we need to do that

00:17:47,129 --> 00:17:48,894
if the device can't do anything?

00:17:48,894 --> 00:17:51,018
- What does it hep to wait for the driver?

00:17:51,018 --> 00:17:54,625
- The driver knows a lot more about the model that it needs.

00:17:54,625 --> 00:17:56,216
- That's your choice

00:17:56,216 --> 00:17:58,357
more than the driver choice here.

00:17:58,357 --> 00:18:00,853
Devices have firmware and firmware can do something

00:18:00,853 --> 00:18:04,417
without the driver and it can somewhere.

00:18:04,417 --> 00:18:06,391
- Well, the domain won't before the driver does

00:18:06,391 --> 00:18:09,607
(mumbles) in the mask but let's ignore the fact

00:18:09,607 --> 00:18:11,523
that some drivers don't, cause of the default

00:18:11,523 --> 00:18:16,523
32-bit mask and that's something we should probably fix.

00:18:16,527 --> 00:18:19,694
But the difficulty is that this is not

00:18:22,169 --> 00:18:24,015
necessarily a driver policy.

00:18:24,015 --> 00:18:28,404
This is many case, going to be a user policy.

00:18:28,404 --> 00:18:31,120
Is it a, it's often gonna be a compromise between security

00:18:31,120 --> 00:18:32,781
and preference program.

00:18:32,781 --> 00:18:36,287
- So, you might be able to do a driver parameter

00:18:36,287 --> 00:18:38,992
as opposed to a kernel command line parameter.

00:18:38,992 --> 00:18:41,918
- And then we are arranged for all of the drivers

00:18:41,918 --> 00:18:44,918
to have the same syntax so that GUIs

00:18:44,918 --> 00:18:48,087
and configuration tools and management tools

00:18:48,087 --> 00:18:50,676
can actually deal with it.

00:18:50,676 --> 00:18:52,627
We don't have a good way to generate deploy driver

00:18:52,627 --> 00:18:55,337
parameters across drivers in any deployment tool

00:18:55,337 --> 00:18:56,587
that I know of.

00:18:59,223 --> 00:19:00,604
Yeah, I mean, all those things are possible.

00:19:00,604 --> 00:19:02,854
They all have pro and cons.

00:19:06,711 --> 00:19:08,371
- [Presenter] Okay, I think that my time is up.

00:19:08,371 --> 00:19:09,951
So thank you for your

00:19:09,951 --> 00:19:12,389
- [4th Participant] Where are you on, what,

00:19:12,389 --> 00:19:14,790
I suspect you are (mumbles)

00:19:14,790 --> 00:19:18,565
so what's the client for (mumbling)

00:19:18,565 --> 00:19:21,154
is there anything you want to ask?

00:19:21,154 --> 00:19:26,154
(speaking faintly) following his device slip?

00:19:30,116 --> 00:19:33,414
- I think I can pull up a way with patches

00:19:33,414 --> 00:19:36,502
for this for more discussion.

00:19:36,502 --> 00:19:39,834
- Yeah, you can feel free to use it there

00:19:39,834 --> 00:19:42,257
the conference to the final confirm

00:19:42,257 --> 00:19:45,020
with the people who took part in the discussion.

00:19:45,020 --> 00:19:46,309
- Yeah. - It seems like

00:19:46,309 --> 00:19:47,976
it's not necessarily

00:19:49,672 --> 00:19:53,957
- Yeah, I mean, even more discussion, I think.

00:19:53,957 --> 00:19:56,707
- Wait, hold on to your question.

00:19:58,841 --> 00:19:59,688
Let's ask around here.

00:19:59,688 --> 00:20:01,670
Do we think we are okay just having that temporal

00:20:01,670 --> 00:20:03,493
into something better or are we going

00:20:03,493 --> 00:20:07,910
to create a verbal (mumbles) for it?

00:20:11,245 --> 00:20:15,245
- I hardly know anything about PCI or the IOMMU.

00:20:16,202 --> 00:20:19,419
So, maybe, what I'm asking doesn't make sense.

00:20:19,419 --> 00:20:24,012
But I'm wondering whether specifying the mapping type

00:20:24,012 --> 00:20:28,447
can be postponed until the VFIO device is created?

00:20:28,447 --> 00:20:31,428
- That will become possible in your head.

00:20:31,428 --> 00:20:32,518
- No, this is not about VFIO.

00:20:32,518 --> 00:20:35,711
This is about the DMA API default mapping.

00:20:35,711 --> 00:20:37,707
So, this is not about deep assignment.

00:20:37,707 --> 00:20:41,910
It's about whether the device has full access

00:20:41,910 --> 00:20:44,163
to the system or whether it has translated.

00:20:44,163 --> 00:20:49,050
But the IOMMU and the device driver takes control of it, so.

00:20:49,050 --> 00:20:52,812
- Once you do a VFIO, you definitely want the IOMMU

00:20:52,812 --> 00:20:56,063
at the (mumbling)

00:20:56,063 --> 00:20:59,480
- So, that approach, I'm pretty much fine

00:21:01,752 --> 00:21:03,667
if we can make it non PCI specific.

00:21:03,667 --> 00:21:07,220
So, if we, for example, specify a PCI in front of it

00:21:07,220 --> 00:21:08,718
or something.

00:21:08,718 --> 00:21:13,218
Or call the or call it upci.IOMMU.pci.ema or something

00:21:15,695 --> 00:21:17,278
or, yeah, whatever.

00:21:18,865 --> 00:21:21,361
- I still quite like the DMA mapping to go fast enough

00:21:21,361 --> 00:21:22,441
that people don't have to care

00:21:22,441 --> 00:21:25,668
because theoretically, as we were talking about earlier,

00:21:25,668 --> 00:21:28,037
on Intel, all you need to do to map something

00:21:28,037 --> 00:21:29,662
is a single 64 bit right.

00:21:29,662 --> 00:21:30,766
You don't have to have any logging

00:21:30,766 --> 00:21:33,495
or anything theoretically.

00:21:33,495 --> 00:21:35,654
And mapping can be lazy

00:21:35,654 --> 00:21:40,020
and it could go fast enough that people don't care.

00:21:40,020 --> 00:21:42,690
Or at least it could go a lot faster than does map

00:21:42,690 --> 00:21:43,851
in theory.

00:21:43,851 --> 00:21:46,277
And I would like to aspire to that

00:21:46,277 --> 00:21:48,843
rather than having the cheap hack of

00:21:48,843 --> 00:21:50,875
oh, just turn it off then.

00:21:50,875 --> 00:21:52,953
I'd like to keep pursuing that.

00:21:52,953 --> 00:21:56,620
However naive it is, I'd like to keep going.

00:21:57,702 --> 00:21:58,535
- Sorry. - I think

00:21:58,535 --> 00:21:59,368
I'm missing some background.

00:21:59,368 --> 00:22:01,878
Is the only point of this a performance play?

00:22:01,878 --> 00:22:03,956
Is that the only reason for this?

00:22:03,956 --> 00:22:05,581
- The performance and security.

00:22:05,581 --> 00:22:07,323
- So, instead of trying to make our map faster

00:22:07,323 --> 00:22:09,610
we're handing a weird command line option to turn it off.

00:22:09,610 --> 00:22:10,443
- Yes.

00:22:10,443 --> 00:22:12,663
- Okay, that's doesn't, oh, forget it.

00:22:12,663 --> 00:22:14,126
- Well, it's also that some things

00:22:14,126 --> 00:22:17,714
have traditionally been broken and drivers

00:22:17,714 --> 00:22:20,314
have been broken so sometimes we have dumb identity mapping

00:22:20,314 --> 00:22:21,893
for other stupid reasons.

00:22:21,893 --> 00:22:24,424
But it's mainly that stupid reason, yes.

00:22:24,424 --> 00:22:26,096
- Ultimately, I don't like this because

00:22:26,096 --> 00:22:27,942
we shouldn't need it.

00:22:27,942 --> 00:22:29,986
- So, what - Even if that's

00:22:29,986 --> 00:22:31,077
a naive observation.

00:22:31,077 --> 00:22:32,041
- I'm sorry guys.

00:22:32,041 --> 00:22:33,155
What's the actual bottleneck?

00:22:33,155 --> 00:22:36,369
Is it sorry, just last, one last question.

00:22:36,369 --> 00:22:39,202
Is the bottleneck actually the map

00:22:40,119 --> 00:22:43,080
or is it just because we missed the TLB bus?

00:22:43,080 --> 00:22:45,030
- [Man] Are you talking about fundamental hardware reasons?

00:22:45,030 --> 00:22:47,220
Or are you talking about today's software?

00:22:47,220 --> 00:22:48,996
- Both - Both.

00:22:48,996 --> 00:22:50,784
What was the underlying reason for that?

00:22:50,784 --> 00:22:52,085
- We did - Our map sucks

00:22:52,085 --> 00:22:54,040
or how do I, is - our map will always suck

00:22:54,040 --> 00:22:55,351
because you're actually bashing on the hardware

00:22:55,351 --> 00:22:57,214
and doing the IOTLB flash.

00:22:57,214 --> 00:23:00,697
Right, so there will always be an actual latency on that.

00:23:00,697 --> 00:23:01,890
- [Man] Theoretically on Intel.

00:23:01,890 --> 00:23:04,670
It's a single 64-bit right of the PTE.

00:23:04,670 --> 00:23:07,096
And if you do nasty tricks like having

00:23:07,096 --> 00:23:09,267
a one on one mapping that only populating.

00:23:09,267 --> 00:23:11,931
So you're not having to allocate an IO virtual address.

00:23:11,931 --> 00:23:15,553
You know it because it's if you do nasty tricks,

00:23:15,553 --> 00:23:18,398
it merely is a 64-bit right without any logging

00:23:18,398 --> 00:23:21,010
and IOVA allocator and any stuff like that,

00:23:21,010 --> 00:23:22,484
you can get a little bit faster.

00:23:22,484 --> 00:23:25,011
- There was some work from Technion in Israel

00:23:25,011 --> 00:23:27,368
a few years ago on doing exactly that.

00:23:27,368 --> 00:23:29,539
And the first mapping ever given physical page

00:23:29,539 --> 00:23:33,622
gets the corresponding virtual bus address for it

00:23:34,578 --> 00:23:36,621
and second and subsequent mappings

00:23:36,621 --> 00:23:38,653
have to do something else or ref count.

00:23:38,653 --> 00:23:41,196
But for the common case, it's really faster map

00:23:41,196 --> 00:23:42,856
and it goes a lot faster.

00:23:42,856 --> 00:23:46,443
And I don't think we ever looked harder in just doing that.

00:23:46,443 --> 00:23:48,437
- You will still have people who want

00:23:48,437 --> 00:23:51,942
the real bypass because if anything, iotlb

00:23:51,942 --> 00:23:54,738
in some circumstances again look at nasty people

00:23:54,738 --> 00:23:57,822
like GPU through access, very very large data set.

00:23:57,822 --> 00:24:01,322
The cost of the iotlb becomes prohibitive.

00:24:02,251 --> 00:24:03,084
- [British Guy] But it's the GPUs

00:24:03,084 --> 00:24:05,205
we particularly want to have mapping but

00:24:05,205 --> 00:24:09,684
- It's anything that's gonna ask DMA a large amount of data

00:24:09,684 --> 00:24:11,854
in a short amount of time.

00:24:11,854 --> 00:24:14,414
- Yes, I think that's something that we can quickly

00:24:14,414 --> 00:24:16,029
discuss with a micro conference maybe,

00:24:16,029 --> 00:24:18,516
Wednesday for a BUF 12 45.

00:24:18,516 --> 00:24:21,030
So I think it's - Thank you, thank you.

00:24:21,030 --> 00:24:24,365
- Can you put a list of what we want to talk about?

00:24:24,365 --> 00:24:27,874
I'm keen on trying to revisit having

00:24:27,874 --> 00:24:29,446
configuring to something that's an actual

00:24:29,446 --> 00:24:31,752
non command line interface for this,

00:24:31,752 --> 00:24:35,064
just to dig a little bit more into this if possible.

00:24:35,064 --> 00:24:37,564
- Okay, thank you. - Thank you.

00:24:45,223 --> 00:24:47,890
(faint talking)

00:25:52,643 --> 00:25:54,509
- Okay, good afternoon everybody.

00:25:54,509 --> 00:25:55,613
So my name is Eric Auger.

00:25:55,613 --> 00:26:00,311
And my topic today is about hardware nested paging

00:26:00,311 --> 00:26:04,394
environment in the system MMUv3 driver and above.

00:26:08,304 --> 00:26:12,581
So, just to give, so I have a lot of echo, no?

00:26:12,581 --> 00:26:13,647
Do you have it on?

00:26:13,647 --> 00:26:15,216
(faint speaking)

00:26:15,216 --> 00:26:16,286
Okay.

00:26:16,286 --> 00:26:18,953
Just a little bit of background,

00:26:20,534 --> 00:26:22,547
so what we want to achieve is to be able

00:26:22,547 --> 00:26:26,561
to run a document system and then refer it (mumbles)

00:26:26,561 --> 00:26:30,894
and make it able to walk with VFIO assigned devices,

00:26:31,976 --> 00:26:35,726
and unfortunately the way we can achieve this

00:26:36,774 --> 00:26:40,234
cannot be the way implemented on Intel.

00:26:40,234 --> 00:26:43,252
Because of Intel, they are also called the caching mode.

00:26:43,252 --> 00:26:47,585
And is EQMU the Intel IOMMU device exposes it a bit.

00:26:48,978 --> 00:26:52,785
So, the driver on the guest is imposed

00:26:52,785 --> 00:26:55,202
to send TNB validation on map

00:26:56,601 --> 00:27:01,601
and this lowers the (mumbles) to trap everything

00:27:05,111 --> 00:27:09,766
and using the trick, it was quite easy to integrate

00:27:09,766 --> 00:27:11,773
with VFIO, with alternate (mumbles)

00:27:11,773 --> 00:27:16,524
SMMUv3 specification does not specify the trick.

00:27:16,524 --> 00:27:19,524
So, in 2017, so I tried to introduce

00:27:20,653 --> 00:27:22,820
my arch fake caching mode.

00:27:23,824 --> 00:27:27,157
And so unfortunately, so it was rejected

00:27:28,242 --> 00:27:30,585
by Will at that point. (chuckles)

00:27:30,585 --> 00:27:31,823
But I understand why.

00:27:31,823 --> 00:27:35,892
So it was not exposed by specification.

00:27:35,892 --> 00:27:39,705
So, the natural way to use the VFIO integration

00:27:39,705 --> 00:27:43,367
was to use hardware nested paging.

00:27:43,367 --> 00:27:46,617
Which is specified in the architecture.

00:27:47,874 --> 00:27:52,041
And so, the first nesting was sent in August 2018.

00:27:53,631 --> 00:27:56,887
From that very beginning, we had some dependencies

00:27:56,887 --> 00:27:59,054
with the SVA Intel series.

00:28:00,183 --> 00:28:02,388
We were using some common APIs.

00:28:02,388 --> 00:28:05,237
So, typical user for reporting API,

00:28:05,237 --> 00:28:06,739
which is now upstream.

00:28:06,739 --> 00:28:09,817
But also, the cache invalidate the API.

00:28:09,817 --> 00:28:14,817
And at the beginning also, we had we were using the same

00:28:14,888 --> 00:28:17,221
API to pass the PASID table.

00:28:19,405 --> 00:28:21,322
So, this is a little history.

00:28:21,322 --> 00:28:22,907
Now if we look at the state today.

00:28:22,907 --> 00:28:26,970
So no we have v9 variable, so, which was sent

00:28:26,970 --> 00:28:28,637
in August this year.

00:28:30,318 --> 00:28:32,106
Now it's split into two parts

00:28:32,106 --> 00:28:35,189
so, the IOMMU part and the VFIO part.

00:28:36,837 --> 00:28:39,068
This is working on real hardware

00:28:39,068 --> 00:28:41,735
because sorry, it was just v9 v2

00:28:42,632 --> 00:28:45,299
and it was also tested by Linaro

00:28:46,564 --> 00:28:48,911
with some grade two devices.

00:28:48,911 --> 00:28:51,054
We have a QEMU integration that is ready

00:28:51,054 --> 00:28:55,248
and waiting for the (mumbles) to show up.

00:28:55,248 --> 00:28:58,415
And so now if we enter into the detail

00:29:00,219 --> 00:29:03,136
of both series or first IOMMU part.

00:29:05,718 --> 00:29:09,551
Just to explain, we have two different flavors

00:29:10,628 --> 00:29:14,711
of APIs to pass the guest PASID entry information

00:29:16,173 --> 00:29:18,317
on ARM and on Intel.

00:29:18,317 --> 00:29:21,817
So, on ARM we are able to to pass directly

00:29:23,419 --> 00:29:25,849
the pointer to the PASID table

00:29:25,849 --> 00:29:29,857
but on Intel, this is not possible because

00:29:29,857 --> 00:29:32,233
in the PASID entry, you find that information

00:29:32,233 --> 00:29:34,496
from both the stage one tables

00:29:34,496 --> 00:29:38,142
and the station tables in the Intel's workable.

00:29:38,142 --> 00:29:41,854
This is a level, the first one level.

00:29:41,854 --> 00:29:44,983
The first level and the second level.

00:29:44,983 --> 00:29:49,097
So this explains why we currently have two different APIs

00:29:49,097 --> 00:29:52,430
to bind to bind the guest configuration.

00:29:55,856 --> 00:29:58,590
On ARM, we have also something very specific

00:29:58,590 --> 00:30:03,222
to the MSIN ring because the ARM SMMU v3 hardware.

00:30:03,222 --> 00:30:06,139
SMMU in general translates the MSIs

00:30:07,036 --> 00:30:09,869
where on Intel, they are bypassed.

00:30:11,110 --> 00:30:15,680
So, the guest needs to provide its stage one binding

00:30:15,680 --> 00:30:20,680
of MSIs so that the (mumbles) can be nested binding.

00:30:22,062 --> 00:30:24,752
So, stage one plus stage two that

00:30:24,752 --> 00:30:28,187
eventually which is the physical domain.

00:30:28,187 --> 00:30:30,220
So this means that I was forced to introduce

00:30:30,220 --> 00:30:32,987
to space a special MSI cookie.

00:30:32,987 --> 00:30:36,107
Okay, so it's the complex part, I would say,

00:30:36,107 --> 00:30:37,671
of the series.

00:30:37,671 --> 00:30:42,027
And the on the SSMU v3 sign, so in the driver,

00:30:42,027 --> 00:30:47,027
so it was a matter of enabling new condition of states

00:30:47,049 --> 00:30:49,376
from stage one to stage one plus stage two

00:30:49,376 --> 00:30:50,986
and conversely.

00:30:50,986 --> 00:30:54,865
And obviously, so we need to implement the IOMMU

00:30:54,865 --> 00:30:56,663
user API we saw just before.

00:30:56,663 --> 00:31:01,047
So, it's quite invasive in the SMMU v3 driver.

00:31:01,047 --> 00:31:04,778
But it's not that much complex, I would say,

00:31:04,778 --> 00:31:07,471
besides maybe the MSI handling,

00:31:07,471 --> 00:31:11,856
which is a little bit more tricky to understand.

00:31:11,856 --> 00:31:15,965
On VFIO side, so for me, it's more trivial.

00:31:15,965 --> 00:31:18,725
So, we just bind to the IOMMU user API

00:31:18,725 --> 00:31:22,382
we introduced in the previous series

00:31:22,382 --> 00:31:24,671
and now both of the series is related

00:31:24,671 --> 00:31:26,994
to the fault reporting handling because

00:31:26,994 --> 00:31:30,661
we introduced a new item in the VFIO device.

00:31:33,812 --> 00:31:37,062
And also, that rose to share, to expose

00:31:38,616 --> 00:31:41,938
to the user space the fault and we have a ring

00:31:41,938 --> 00:31:46,105
of faults that is un-mappable from the user space.

00:31:48,179 --> 00:31:51,346
And to prepare for the introduction of

00:31:54,847 --> 00:31:57,331
recoverable evolves.

00:31:57,331 --> 00:32:00,570
So, now we have a versioning mechanism,

00:32:00,570 --> 00:32:03,809
which is a proposed directly by the VFIO API.

00:32:03,809 --> 00:32:06,148
So, in the capabilities for the

00:32:06,148 --> 00:32:08,064
the introduced region, we can update it.

00:32:08,064 --> 00:32:12,064
And later on, we can support recoverable errors.

00:32:15,430 --> 00:32:18,674
So, now I come to the actual real discussion.

00:32:18,674 --> 00:32:21,240
So, first of all, I would like to understand

00:32:21,240 --> 00:32:24,812
from you if there is any conception (mumbles)

00:32:24,812 --> 00:32:26,342
I mean with the support.

00:32:26,342 --> 00:32:28,312
I know it can, so it's complex.

00:32:28,312 --> 00:32:31,340
It's invasive from a performance size,

00:32:31,340 --> 00:32:35,007
so it can be handled, besides we have no way

00:32:37,763 --> 00:32:40,213
benchmarks to provide at the moment.

00:32:40,213 --> 00:32:43,272
We have plus VFIO IOMMU solution,

00:32:43,272 --> 00:32:47,522
which can be seen as competitor for some use cases.

00:32:50,012 --> 00:32:52,363
And besides that, so it's something that's specified

00:32:52,363 --> 00:32:55,946
in the SMMU specification and so I think it

00:32:57,541 --> 00:32:59,458
was worth to enable it.

00:33:00,763 --> 00:33:04,008
So, this is a first question so, do you

00:33:04,008 --> 00:33:06,527
maintenance see any blocker in

00:33:06,527 --> 00:33:09,777
enabling the hardware on nested paging.

00:33:11,551 --> 00:33:12,901
- Okay.

00:33:12,901 --> 00:33:16,318
And, in the ARM SMMU registry definition,

00:33:18,879 --> 00:33:23,674
the count is, is it context is (mumbles)

00:33:23,674 --> 00:33:27,239
contains VMID being your, in your connectivity.

00:33:27,239 --> 00:33:31,238
That means UTLB entries is use the VMID

00:33:31,238 --> 00:33:34,426
and ASID ask the name space changing.

00:33:34,426 --> 00:33:37,114
That's different from Intel.

00:33:37,114 --> 00:33:40,031
Intel directory use the PASID, yes?

00:33:41,548 --> 00:33:42,518
Is that right?

00:33:42,518 --> 00:33:46,761
Intel directly use the PASID as the TLB entries

00:33:46,761 --> 00:33:47,844
them spacing?

00:33:48,712 --> 00:33:50,462
Not the window of it.

00:33:54,610 --> 00:33:57,428
- [3rd Participant] You mean that the

00:33:57,428 --> 00:34:01,125
- I mean, your IOMMU TLB directory is

00:34:01,125 --> 00:34:03,148
- [3rd Participant] Is direct bypass?

00:34:03,148 --> 00:34:05,898
- Yeah, user PASID as the, as the

00:34:07,535 --> 00:34:08,746
- Yeah, yes. - Yeah,

00:34:08,746 --> 00:34:10,774
that's different from the ARM's one.

00:34:10,774 --> 00:34:13,883
ARM use the VMID and not use PASID.

00:34:13,883 --> 00:34:18,619
PASID the, how to think about this, this difference?

00:34:18,619 --> 00:34:22,369
Why ARM use another VMID, not directly PASID?

00:34:24,564 --> 00:34:27,766
- Sorry, actually, in my case, I do not focus much

00:34:27,766 --> 00:34:32,766
on the PASID use case, because I have a single PASID

00:34:32,815 --> 00:34:36,232
up to now, I have a similar context in my

00:34:39,723 --> 00:34:41,223
in my PASID table.

00:34:45,643 --> 00:34:48,876
So, I think there are, we have discrepancies

00:34:48,876 --> 00:34:52,085
in the way we time it as the caches, the TLBs

00:34:52,085 --> 00:34:55,002
on ARM and Intel but so, I can not.

00:35:01,547 --> 00:35:03,864
- The PASID is 20 bits, yeah.

00:35:03,864 --> 00:35:07,531
And the VMID, what's the ARM VMID with this,

00:35:08,609 --> 00:35:10,109
maybe not 20 bits.

00:35:11,163 --> 00:35:13,212
- About 60. - 60?

00:35:13,212 --> 00:35:14,365
- 14? - 16.

00:35:14,365 --> 00:35:15,781
- Oh, 16, okay.

00:35:15,781 --> 00:35:20,781
So, why not directly use the PASID IDs for this design?

00:35:21,194 --> 00:35:23,138
I want to - Because that's not

00:35:23,138 --> 00:35:25,636
directly what the TLBs are targeting.

00:35:25,636 --> 00:35:27,719
- So, question, actually.

00:35:29,248 --> 00:35:31,399
You're talking about the hardware architecture

00:35:31,399 --> 00:35:33,645
that is designed to support translation

00:35:33,645 --> 00:35:37,167
at both the hypervisor and the guest local, right?

00:35:37,167 --> 00:35:41,084
So, how come is your TLB can not tag with both?

00:35:42,484 --> 00:35:44,049
Okay. - (mumbled) ASID add the link.

00:35:44,049 --> 00:35:47,966
- Yeah, okay, so you have ASID ad PASID or not?

00:35:48,954 --> 00:35:51,253
- [Will] PASID is stage one, right?

00:35:51,253 --> 00:35:54,120
- Yeah, so the ASID is the (mumbles)

00:35:54,120 --> 00:35:55,939
and I don't think it's worthwhile us talking about too long

00:35:55,939 --> 00:35:58,730
but the ASID is the ID for the first data translation.

00:35:58,730 --> 00:36:00,799
So then that would be potentially

00:36:00,799 --> 00:36:01,975
have PASIDs involved as well.

00:36:01,975 --> 00:36:04,427
And then VMID is the stage two context, which is your

00:36:04,427 --> 00:36:06,607
- Okay, but the TLB starts with both

00:36:06,607 --> 00:36:08,710
- Yes. - Okay okay.

00:36:08,710 --> 00:36:09,610
I know. - PASID is all PCS stuff.

00:36:09,610 --> 00:36:10,517
- That's what I thought

00:36:10,517 --> 00:36:13,361
but from the conversation here, I was under the impression

00:36:13,361 --> 00:36:15,611
that wasn't the case, yeah.

00:36:17,526 --> 00:36:21,879
- Sorry, actually that's not answer to my original question.

00:36:21,879 --> 00:36:25,462
I think the question was for Will directly.

00:36:26,773 --> 00:36:29,820
- Yeah, so I mean the, in terms of conceptual blockers,

00:36:29,820 --> 00:36:32,897
I think I've got a few questions and concerns

00:36:32,897 --> 00:36:34,105
and we can probably follow them up

00:36:34,105 --> 00:36:36,134
between the two of us.

00:36:36,134 --> 00:36:37,901
One thing I think, and correct me if I'm wrong,

00:36:37,901 --> 00:36:41,599
is that's you're writing a whole load of PASID support

00:36:41,599 --> 00:36:43,427
for dealing with the emulation, whereas

00:36:43,427 --> 00:36:46,185
actually, Linux running native

00:36:46,185 --> 00:36:49,048
in the guests doesn't use PASIDS for anything.

00:36:49,048 --> 00:36:50,113
- For the - Yes, right

00:36:50,113 --> 00:36:52,456
so I think I'd rather do it the other way round.

00:36:52,456 --> 00:36:54,959
And I know that is a bit of a problem for you.

00:36:54,959 --> 00:36:58,792
I'd rather we had Linux using PASIDS natively.

00:36:59,639 --> 00:37:00,649
Or at least knowing how to do it

00:37:00,649 --> 00:37:01,656
and then we had your code.

00:37:01,656 --> 00:37:04,680
Otherwise we have a whole lot of code we can't test

00:37:04,680 --> 00:37:09,013
and since, there's no hard (buzzing)

00:37:10,578 --> 00:37:12,482
Maybe we shouldn't talk at the same time.

00:37:12,482 --> 00:37:14,732
(laughing)

00:37:17,472 --> 00:37:18,629
- Another question. - Okay.

00:37:18,629 --> 00:37:21,467
- But anyway, - We can you now this question

00:37:21,467 --> 00:37:23,816
I start another question.

00:37:23,816 --> 00:37:24,649
- [Will] I haven't finished yet.

00:37:24,649 --> 00:37:25,717
Let me just finish my point.

00:37:25,717 --> 00:37:29,235
- Okay, I ask another question about

00:37:29,235 --> 00:37:30,996
- [1st Presenter] Will has not completed.

00:37:30,996 --> 00:37:33,662
If you accept, Will can you complete?

00:37:33,662 --> 00:37:34,616
- Yeah yeah, sure, so the only other thing

00:37:34,616 --> 00:37:35,722
is I have

00:37:35,722 --> 00:37:37,864
- Please don't put the kids together.

00:37:37,864 --> 00:37:39,675
- Oh oh oh, got it.

00:37:39,675 --> 00:37:40,729
(laughing)

00:37:40,729 --> 00:37:43,110
- Matter an empty matter.

00:37:43,110 --> 00:37:45,211
yeah, so the other thing is I mean,

00:37:45,211 --> 00:37:47,436
there's very little in the way of general purpose

00:37:47,436 --> 00:37:49,628
PASID capable hardware that I'm aware of.

00:37:49,628 --> 00:37:52,150
So, I certainly have no way of testing any of this.

00:37:52,150 --> 00:37:53,716
I don't know if you have a way of testing it.

00:37:53,716 --> 00:37:57,581
I'd like someone who can regularly test this

00:37:57,581 --> 00:37:58,742
so that we don't see regressions.

00:37:58,742 --> 00:38:01,989
Because we're at a point now where in ARM,

00:38:01,989 --> 00:38:05,020
64 parts, they tend to shift with an SMMU v3

00:38:05,020 --> 00:38:05,983
in the service space.

00:38:05,983 --> 00:38:08,640
People are using it and if you get that code wrong,

00:38:08,640 --> 00:38:11,062
it's disastrous and they lose data and things like that.

00:38:11,062 --> 00:38:14,248
So, I'm just nervous about writing

00:38:14,248 --> 00:38:15,990
quite a lot of complex code and introducing

00:38:15,990 --> 00:38:20,310
complex code to the driver, which we are unable to test.

00:38:20,310 --> 00:38:22,133
- Yeah, so on my side, as I stated,

00:38:22,133 --> 00:38:25,059
so I tested on two different questions, so,

00:38:25,059 --> 00:38:27,429
I'm aware that you may not have access

00:38:27,429 --> 00:38:29,896
to the same kind of machines but,

00:38:29,896 --> 00:38:33,866
so I hope nowadays, we can see your SMMU v3 implementation

00:38:33,866 --> 00:38:36,683
with two stages with right implementation

00:38:36,683 --> 00:38:38,185
for the TMBs and so on.

00:38:38,185 --> 00:38:40,185
- But are you using PRI?

00:38:41,819 --> 00:38:43,432
- Sorry? - Are you using PRI?

00:38:43,432 --> 00:38:44,564
- No. - Exactly.

00:38:44,564 --> 00:38:46,045
Okay.

00:38:46,045 --> 00:38:48,667
But as a (mumbles), so if I wait for this

00:38:48,667 --> 00:38:51,420
kind of hardware to be available,

00:38:51,420 --> 00:38:53,186
so I can wait forever so.

00:38:53,186 --> 00:38:55,851
- Is that the problem, I mean?

00:38:55,851 --> 00:38:56,803
Repeat what you just said, right.

00:38:56,803 --> 00:39:01,220
We contest, so, why not maybe, is that what you said,

00:39:02,323 --> 00:39:04,076
which might take a while before we even have

00:39:04,076 --> 00:39:06,593
or maybe look at a simpler version.

00:39:06,593 --> 00:39:09,426
We do not support multiple PASIDs.

00:39:10,832 --> 00:39:12,787
We still allow nesting with single PASID.

00:39:12,787 --> 00:39:15,506
- So, that's actually what I tried to achieve.

00:39:15,506 --> 00:39:18,577
I tried to remove this dependency on PRI and so on.

00:39:18,577 --> 00:39:20,627
And so we had the discussion with Jean Phillip.

00:39:20,627 --> 00:39:25,016
And I think waiting for more and more features

00:39:25,016 --> 00:39:27,970
so, we are just not because we are gonna test it.

00:39:27,970 --> 00:39:30,918
But with the current series,

00:39:30,918 --> 00:39:33,853
can be tested with actual hardware today, so.

00:39:33,853 --> 00:39:35,847
- [Ben] As long as you don't create PASID table

00:39:35,847 --> 00:39:38,373
with more than one entry.

00:39:38,373 --> 00:39:39,599
- Yes, yes.

00:39:39,599 --> 00:39:41,529
But in any case, the enumeration code does not

00:39:41,529 --> 00:39:44,530
support more that one, than one PASID at the moment.

00:39:44,530 --> 00:39:46,613
I could develop that but.

00:39:51,582 --> 00:39:53,243
- I mean, you could, could you nobble the feature

00:39:53,243 --> 00:39:56,993
and just not support it in the emulated SMMU?

00:39:57,841 --> 00:39:59,686
- Yes, I can. - I would prefer something,

00:39:59,686 --> 00:40:02,264
just for baby steps and then that's then

00:40:02,264 --> 00:40:04,041
a simpler thing to reason about.

00:40:04,041 --> 00:40:06,560
It's completely independent from the SVM work.

00:40:06,560 --> 00:40:08,968
Module or structure repainting, which is fine.

00:40:08,968 --> 00:40:10,680
I don't care which tree that comes via.

00:40:10,680 --> 00:40:12,282
And then we can always try to enable it later on

00:40:12,282 --> 00:40:13,709
when we got something that we understand

00:40:13,709 --> 00:40:15,341
what he bloody hell it does,

00:40:15,341 --> 00:40:17,872
'cause that's one of the reasons that I

00:40:17,872 --> 00:40:19,643
have not been paying too much attention to this

00:40:19,643 --> 00:40:23,726
is that I don't see, I don't see people using it.

00:40:25,564 --> 00:40:26,411
- [2nd Presenter] Yeah sure, sure.

00:40:26,411 --> 00:40:28,176
But it's a chicken and egg issue.

00:40:28,176 --> 00:40:30,000
- It is. - There's no Linux

00:40:30,000 --> 00:40:34,249
integration, so no people will devise hardware for that.

00:40:34,249 --> 00:40:35,478
So, just for the others.

00:40:35,478 --> 00:40:37,501
So this is a hardware implementation choice

00:40:37,501 --> 00:40:39,213
to implement both stages.

00:40:39,213 --> 00:40:41,536
And also you have to devise the right topology

00:40:41,536 --> 00:40:45,547
for the TMBs otherwise, it may not work for Paris or

00:40:45,547 --> 00:40:47,732
- So, how'd you 'cause we have vertIOI MMU

00:40:47,732 --> 00:40:49,323
and I think that merged now.

00:40:49,323 --> 00:40:51,830
- Yes, but the story is not complete

00:40:51,830 --> 00:40:55,020
because so it's, the driver is there

00:40:55,020 --> 00:40:58,089
but the way to integrate it with the firmware

00:40:58,089 --> 00:41:01,006
is not ready because we do not know

00:41:02,172 --> 00:41:05,422
if we should use the AOIT for the SCPI.

00:41:07,752 --> 00:41:12,752
And so now, (mumbles) is pushing for quick on PCI

00:41:13,702 --> 00:41:17,314
to build the bindings without the AOIT table

00:41:17,314 --> 00:41:20,895
so, that I don't figure out how this is feasible.

00:41:20,895 --> 00:41:22,695
So, yes, the driver is available

00:41:22,695 --> 00:41:26,027
but it cannot be used at the moment.

00:41:26,027 --> 00:41:29,531
Whereas, I think this solution can be used now.

00:41:29,531 --> 00:41:31,745
- That's not a good reason for having two drivers, though.

00:41:31,745 --> 00:41:33,412
Or two devices even.

00:41:34,862 --> 00:41:37,038
I think, what probably needs to be done is a document

00:41:37,038 --> 00:41:39,701
or not, nothing big, a text file

00:41:39,701 --> 00:41:42,176
needs to be in to say, hey, what, you're doing this.

00:41:42,176 --> 00:41:43,558
You should use vertIOMMU.

00:41:43,558 --> 00:41:46,379
Oh, you're doing this, then you should use the nested one.

00:41:46,379 --> 00:41:48,956
Because if we just have two emulated devices

00:41:48,956 --> 00:41:52,004
and neither of them quite do what, they don't cover the

00:41:52,004 --> 00:41:54,027
whole space, it's kind of a - I understand what you mean,

00:41:54,027 --> 00:41:57,387
so I can write such sort of documentation

00:41:57,387 --> 00:41:58,242
on the other ones.

00:41:58,242 --> 00:42:00,540
So, that's funny because we don't have

00:42:00,540 --> 00:42:02,373
any performance to use

00:42:03,437 --> 00:42:06,839
for either the vert IOMMU, not this solution.

00:42:06,839 --> 00:42:08,273
So, - But the vert IOMMU

00:42:08,273 --> 00:42:10,409
is a lot more portable than this.

00:42:10,409 --> 00:42:12,362
This is very mush tied to a specific piece of hardware

00:42:12,362 --> 00:42:14,415
and I think it's a lot of effort to invest

00:42:14,415 --> 00:42:16,191
in one particular piece of architecture,

00:42:16,191 --> 00:42:18,392
one particular driver, one particular piece of hardware

00:42:18,392 --> 00:42:22,457
with an unclear use case and unclear benefit.

00:42:22,457 --> 00:42:24,285
Whereas the vert IOMMU, at the very least,

00:42:24,285 --> 00:42:25,587
you get a specification out of it.

00:42:25,587 --> 00:42:27,928
- What we know for sure is vert IOMMU

00:42:27,928 --> 00:42:32,658
if you have dynamic mappings, you will have difficulties

00:42:32,658 --> 00:42:35,861
to sustain the performance, whereas with this solution,

00:42:35,861 --> 00:42:38,957
it should be transparent IOMMU.

00:42:38,957 --> 00:42:42,200
So, IOMMU normally, the vert IOMMU looks

00:42:42,200 --> 00:42:44,349
so, for (mumbles) equally,

00:42:44,349 --> 00:42:46,293
I agree and so it will work exactly.

00:42:46,293 --> 00:42:49,210
But for nested or for, we will face

00:42:50,568 --> 00:42:53,993
exactly the same issue as we have on X86.

00:42:53,993 --> 00:42:57,194
So that's why I try to push both initial IM modes

00:42:57,194 --> 00:42:58,965
working on the vert IOMMU.

00:42:58,965 --> 00:43:00,880
You know, so.

00:43:00,880 --> 00:43:02,215
Please.

00:43:02,215 --> 00:43:06,051
- Do we know of a reasonably available PCI device

00:43:06,051 --> 00:43:09,551
that implement PASID PRI and all that gunk

00:43:10,429 --> 00:43:14,611
other than in the in (mumbles) or AMDG PU?

00:43:14,611 --> 00:43:18,068
Because you don't want to touch all the drivers.

00:43:18,068 --> 00:43:19,579
Mm?

00:43:19,579 --> 00:43:21,239
(faint speaking in the background)

00:43:21,239 --> 00:43:22,587
Who? Sorry.

00:43:22,587 --> 00:43:25,437
(faint speaking)

00:43:25,437 --> 00:43:27,270
Not readily available.

00:43:30,573 --> 00:43:32,081
- [Participant] But that class of device

00:43:32,081 --> 00:43:33,914
where you're basically

00:43:35,421 --> 00:43:38,614
- But we had the whole shebang going on R

00:43:38,614 --> 00:43:42,764
with the MVDI MV link but none of that is

00:43:42,764 --> 00:43:46,374
either public or readily available or

00:43:46,374 --> 00:43:49,234
- [Participant] Aren't they (faint speaking)

00:43:49,234 --> 00:43:52,151
and I bet there are supports there.

00:43:53,201 --> 00:43:55,201
So, how can we find out?

00:43:56,085 --> 00:43:57,781
You want to get something that can be abused

00:43:57,781 --> 00:43:59,119
as a general purpose.

00:43:59,119 --> 00:44:00,631
(faint talking)

00:44:00,631 --> 00:44:05,025
- If we have a non to expensive PCI basis, FPGA,

00:44:05,025 --> 00:44:07,272
we could just put together something

00:44:07,272 --> 00:44:08,356
if people can hear us.

00:44:08,356 --> 00:44:10,313
- Yeah, if you've got something that can be abused

00:44:10,313 --> 00:44:12,490
as a general purpose PC target device,

00:44:12,490 --> 00:44:14,777
then you can essentially craft your own packets

00:44:14,777 --> 00:44:16,660
and do your own crap,

00:44:16,660 --> 00:44:18,905
which a lot of these things are in software

00:44:18,905 --> 00:44:21,226
ultimately then, yes, you can go

00:44:21,226 --> 00:44:25,766
and make yourself a device with duct tape and string

00:44:25,766 --> 00:44:29,183
that implements PRI and or PASID support.

00:44:31,279 --> 00:44:34,096
And you can have something - What the state of the

00:44:34,096 --> 00:44:36,819
latest design where PCIe end point stuff.

00:44:36,819 --> 00:44:38,635
It can do all of the, generate all the

00:44:38,635 --> 00:44:40,999
PRI message and all that crap?

00:44:40,999 --> 00:44:44,589
'Cause then pick up any of those things.

00:44:44,589 --> 00:44:47,437
Six, 70 bucks, it'll ARM 64 thingy that has PCI

00:44:47,437 --> 00:44:50,214
and you flip it into device mode

00:44:50,214 --> 00:44:52,704
and we can create a test button.

00:44:52,704 --> 00:44:54,329
- And some of them are more generic than others

00:44:54,329 --> 00:44:58,104
and give you more ability to craft your own packets

00:44:58,104 --> 00:45:00,067
but yeah, I'm fairly sure that some of those

00:45:00,067 --> 00:45:02,545
will be able to do this.

00:45:02,545 --> 00:45:05,604
- So, there have been points about, but I'm not sure

00:45:05,604 --> 00:45:09,714
if we could modify it something like a PRI

00:45:09,714 --> 00:45:14,131
or in either IDs that goes along with the PCI packet.

00:45:19,443 --> 00:45:22,068
At the max, I think maybe you can try to change

00:45:22,068 --> 00:45:23,485
the requester ID.

00:45:26,977 --> 00:45:30,442
- Yeah, the PASID is interesting one.

00:45:30,442 --> 00:45:32,692
(mumbling)

00:45:34,387 --> 00:45:35,751
- Okay. - It could go complex.

00:45:35,751 --> 00:45:39,067
Let's try to see if any of us find something.

00:45:39,067 --> 00:45:43,594
- If you don't find, let's come back to the original

00:45:43,594 --> 00:45:46,405
- So, there is a new controller cadence,

00:45:46,405 --> 00:45:50,068
PCI controller, which also supports endpoint mode.

00:45:50,068 --> 00:45:52,317
Again, in that also, I'm not sure if you could

00:45:52,317 --> 00:45:56,734
modify the PASID or things like that but I can check.

00:46:00,207 --> 00:46:01,040
- Okay.

00:46:03,434 --> 00:46:08,085
So, then when your answer is not fully clear for me.

00:46:08,085 --> 00:46:09,693
So, shall I continue working on this?

00:46:09,693 --> 00:46:12,252
Or shall I stop? (laughing)

00:46:12,252 --> 00:46:14,154
- [Person] As long as there's time, you keep working on it.

00:46:14,154 --> 00:46:15,549
(laughing)

00:46:15,549 --> 00:46:17,158
- Yeah.

00:46:17,158 --> 00:46:20,426
Well, so we can talk about that a little.

00:46:20,426 --> 00:46:23,345
Then, for you maintenance also, the question is

00:46:23,345 --> 00:46:26,690
so, I know you had some pain to follow the user API

00:46:26,690 --> 00:46:29,366
we introduced on the IOMMU side,

00:46:29,366 --> 00:46:33,033
which were shared with the pan series on SVA

00:46:38,393 --> 00:46:39,643
for Intel also.

00:46:41,763 --> 00:46:44,918
So, just to help you follow also stages,

00:46:44,918 --> 00:46:47,918
so what can be done with your, maybe

00:46:49,288 --> 00:46:52,705
sender separate series just with user API

00:46:55,392 --> 00:46:58,654
so, I think now, we can, you can have an overall

00:46:58,654 --> 00:47:01,571
understanding of what it is useful.

00:47:03,734 --> 00:47:06,393
So, my next target for this series

00:47:06,393 --> 00:47:08,976
to land upstream if it happens,

00:47:09,965 --> 00:47:12,589
is to get the user API accepted.

00:47:12,589 --> 00:47:17,589
I think we share the same understanding on Intel's side.

00:47:17,702 --> 00:47:22,494
And also, it would allow you to review the right

00:47:22,494 --> 00:47:23,911
the right series.

00:47:24,979 --> 00:47:26,775
So, what do you prefer?

00:47:26,775 --> 00:47:29,832
Shall we send a separate series for just continue

00:47:29,832 --> 00:47:34,832
the user API or can you follow the respective series either

00:47:35,081 --> 00:47:37,371
on Intel's side or ARM's side.

00:47:37,371 --> 00:47:39,599
So, it's up to to you, so.

00:47:39,599 --> 00:47:41,109
I take all question.

00:47:41,109 --> 00:47:42,751
- May I ask another question?

00:47:42,751 --> 00:47:43,811
- Okay.

00:47:43,811 --> 00:47:47,257
Can I get the answer then we'll jump to you.

00:47:47,257 --> 00:47:49,041
- [Man Participant] Okay.

00:47:49,041 --> 00:47:50,541
And oh, no, sorry.

00:47:52,630 --> 00:47:54,297
I really don't know.

00:47:55,520 --> 00:47:57,809
- Yeah, so I would prefer a separate posting of only

00:47:57,809 --> 00:48:01,730
the API changes because that's what I review usually.

00:48:01,730 --> 00:48:03,244
- Okay. - and if it's self contained,

00:48:03,244 --> 00:48:06,685
and then it's easier for me and I can skim through

00:48:06,685 --> 00:48:08,959
it much quicker so.

00:48:08,959 --> 00:48:11,209
- Similar to what John had.

00:48:13,534 --> 00:48:16,198
I know for the fourth reporting API, John

00:48:16,198 --> 00:48:19,142
managed a public, I mean, shared the repo.

00:48:19,142 --> 00:48:20,225
Is that something you prefer?

00:48:20,225 --> 00:48:22,608
I mean, I and Ari can work together,

00:48:22,608 --> 00:48:25,309
put the shared UAPI there.

00:48:25,309 --> 00:48:29,101
And then submit patches of that repo with that.

00:48:29,101 --> 00:48:30,620
- [Participant] Yeah, sure.

00:48:30,620 --> 00:48:33,020
Can I get the big picture of the API changes

00:48:33,020 --> 00:48:33,853
and - Okay.

00:48:36,738 --> 00:48:37,693
(faint speaking) Yeah yeah.

00:48:37,693 --> 00:48:40,784
Yeah, I'll talk a little bit about next session.

00:48:40,784 --> 00:48:42,173
Thanks.

00:48:42,173 --> 00:48:44,590
- Okay, so your question now.

00:48:45,742 --> 00:48:46,742
- Thank you.

00:48:47,900 --> 00:48:48,733
Okay.

00:48:49,593 --> 00:48:52,260
My question is that's obviously,

00:48:55,504 --> 00:49:00,087
the ARM architecture part the VMID in the stream table,

00:49:02,062 --> 00:49:04,742
and that's different from Intel's do it.

00:49:04,742 --> 00:49:07,600
They put it in the PASID table, yeah.

00:49:07,600 --> 00:49:10,904
That means Intel's PASID table the stage two

00:49:10,904 --> 00:49:15,904
could be, could be supported some (mumbles) function

00:49:16,619 --> 00:49:18,751
these kind of things.

00:49:18,751 --> 00:49:22,584
And the limit of design is tough, is must bind

00:49:28,971 --> 00:49:30,971
physical function to one

00:49:31,982 --> 00:49:34,913
- Must bind, what? - Bind the physical function.

00:49:34,913 --> 00:49:39,241
F ec, physical function, function but PCI physical function

00:49:39,241 --> 00:49:41,599
to one (mumbles) machine, yeah.

00:49:41,599 --> 00:49:45,285
But the Intel code bind the several.

00:49:45,285 --> 00:49:48,805
- This is the - Yeah, so Sagan mode, yeah.

00:49:48,805 --> 00:49:49,927
How do you think about this?

00:49:49,927 --> 00:49:54,094
Do you think ARM's architecture should be modified

00:49:54,949 --> 00:49:56,400
to support this kernel?

00:49:56,400 --> 00:49:59,164
- I think this is beyond the scope of,

00:49:59,164 --> 00:50:01,227
I don't think it's relevant to what Eric

00:50:01,227 --> 00:50:02,892
is asking the audience.

00:50:02,892 --> 00:50:03,725
Maybe,

00:50:03,725 --> 00:50:05,813
(mumbling) with architects at ARM.

00:50:05,813 --> 00:50:07,678
I'm not the only person trying to

00:50:07,678 --> 00:50:09,220
- Okay okay.

00:50:09,220 --> 00:50:12,349
I don't know, I think, I rather well, Eric,

00:50:12,349 --> 00:50:14,480
I don't know if you have other questions for the audience.

00:50:14,480 --> 00:50:16,759
- Yeah, I'm sorry, so maybe you can discuss

00:50:16,759 --> 00:50:20,992
with ARM people, you will get more interesting feedbacks.

00:50:20,992 --> 00:50:25,242
- I just means, I just look at certain part to see.

00:50:26,793 --> 00:50:31,710
And I think maybe Sagan mode is a little bit more flexible.

00:50:32,887 --> 00:50:34,769
- I think that - But the point

00:50:34,769 --> 00:50:36,584
is that we're not discussing that now.

00:50:36,584 --> 00:50:38,655
- Oh, okay okay. - Okay.

00:50:38,655 --> 00:50:40,711
So, I don't know if you want to wrap it up.

00:50:40,711 --> 00:50:42,337
Eric, do you have any further questions?

00:50:42,337 --> 00:50:43,554
- Yes, I finish the last point.

00:50:43,554 --> 00:50:45,614
It was about DMS side binding,

00:50:45,614 --> 00:50:47,830
which I think this is the most difficult part

00:50:47,830 --> 00:50:50,080
in our in the IOMMU series.

00:50:52,406 --> 00:50:56,156
But well, so let's put the first steps first.

00:50:57,691 --> 00:51:00,958
This documentation you are requesting, Will.

00:51:00,958 --> 00:51:04,541
We'll discuss about technical details.

00:51:04,541 --> 00:51:06,620
- And by the way, my idea and I see

00:51:06,620 --> 00:51:08,938
another question is that do you plan to have a

00:51:08,938 --> 00:51:11,835
window technology for them?

00:51:11,835 --> 00:51:14,585
I mean, in PASID, they are usages

00:51:16,568 --> 00:51:19,199
currently don't have any windows technology

00:51:19,199 --> 00:51:22,449
means just like ASID used by CPUs and a

00:51:23,725 --> 00:51:25,543
low over with version.

00:51:25,543 --> 00:51:29,312
And do you have plan because because

00:51:29,312 --> 00:51:32,062
because ARM use 16 bit as to ASID

00:51:37,401 --> 00:51:39,843
ASID and we might, so do you have,

00:51:39,843 --> 00:51:42,676
do you wan to do window technology

00:51:43,629 --> 00:51:45,379
to for the VMID ASID,

00:51:46,234 --> 00:51:48,901
for your for ARM's IOMMU design?

00:51:49,971 --> 00:51:51,804
Just a bit more wider.

00:51:52,917 --> 00:51:55,381
- Again, not - I think

00:51:55,381 --> 00:51:58,141
we answered the question, we are not discussing that now.

00:51:58,141 --> 00:52:00,690
So, I think we should move over to Jacob

00:52:00,690 --> 00:52:03,884
and answer your questions offline later when it's relevant

00:52:03,884 --> 00:52:06,867
to the topic you are handling.

00:52:06,867 --> 00:52:07,700
Thank you.

00:52:08,976 --> 00:52:11,194
- [Eric] So, thank you for your attention.

00:52:11,194 --> 00:52:13,444
(applause)

00:52:26,885 --> 00:52:28,364
(soft chatter)

00:52:28,364 --> 00:52:29,940
- There's something.

00:52:29,940 --> 00:52:31,408
I don't even care if I don't have access to it.

00:52:31,408 --> 00:52:34,340
Just if someone can run something.

00:52:34,340 --> 00:52:36,715
Otherwise I come maintain that stuff.

00:52:36,715 --> 00:52:37,882
Or remove ATS.

00:52:40,400 --> 00:52:42,567
(silence)

00:52:46,402 --> 00:52:48,652
(coughing)

00:52:54,166 --> 00:52:55,162
(chatter)

00:52:55,162 --> 00:52:57,261
They need to have an ATC as well

00:52:57,261 --> 00:53:01,511
so that we can check the (chatter)

00:53:06,126 --> 00:53:08,626
And emulation number TL, NHEC.

00:53:10,886 --> 00:53:13,136
(laughing)

00:53:14,242 --> 00:53:17,492
(mumbling and chatter)

00:53:27,764 --> 00:53:30,514
(faint speaking)

00:53:45,289 --> 00:53:46,122
Hello.

00:53:46,990 --> 00:53:48,249
My name is Jacob Pan.

00:53:48,249 --> 00:53:49,446
I work for Intel.

00:53:49,446 --> 00:53:51,548
Used to be called an Open Source Technology Center

00:53:51,548 --> 00:53:55,619
but now it's something more obscure and but anyway.

00:53:55,619 --> 00:53:57,930
(laughing)

00:53:57,930 --> 00:54:01,493
Anyway, while your memory or cache is still warm

00:54:01,493 --> 00:54:04,146
about PASID, we're gonna talk more about PASID

00:54:04,146 --> 00:54:07,315
and this topic was initially proposed

00:54:07,315 --> 00:54:08,739
by my colleague.

00:54:08,739 --> 00:54:13,322
He couldn't come here so I try to cover the whole topic

00:54:15,299 --> 00:54:18,632
and hopefully what I said, it's correct.

00:54:20,274 --> 00:54:23,656
If it's wrong, you can forward it to him.

00:54:23,656 --> 00:54:25,266
(laughing)

00:54:25,266 --> 00:54:28,849
So, I wanna talk about the PASID basically,

00:54:29,933 --> 00:54:32,766
lifecycle management and basically

00:54:34,372 --> 00:54:36,789
in a bigger context of shared virtual addressing

00:54:36,789 --> 00:54:38,193
or shared virtual memory.

00:54:38,193 --> 00:54:42,193
And I'm gonna use IOASID or ASID interchangeably

00:54:43,794 --> 00:54:48,087
in this case 'cause in the upstream proposed patches,

00:54:48,087 --> 00:54:51,047
we agreed that we were gonna use IOASID,

00:54:51,047 --> 00:54:52,880
which is more neutral.

00:54:55,302 --> 00:54:59,294
So, we're gonna talk about the allocation free.

00:54:59,294 --> 00:55:03,446
And if I have time, we can talk about the mapping

00:55:03,446 --> 00:55:07,447
between debiting gas cause PASID versus

00:55:07,447 --> 00:55:10,115
no identity being I guess, is its own PASID space

00:55:10,115 --> 00:55:13,448
versus host's always use the host PASID.

00:55:16,002 --> 00:55:19,780
And then the typical lifecycle, second step

00:55:19,780 --> 00:55:22,780
is allocation and unbind to a either

00:55:24,788 --> 00:55:27,930
can be guest or host process.

00:55:27,930 --> 00:55:32,443
And more importantly, it's the tear down part

00:55:32,443 --> 00:55:36,053
or the exception cases there had a lot of risk conditions.

00:55:36,053 --> 00:55:39,307
I wanted to touch upon and I have quite a

00:55:39,307 --> 00:55:43,474
maybe three opens, hopefully, to get some answers.

00:55:45,054 --> 00:55:49,105
So, those are exception cases for process termination

00:55:49,105 --> 00:55:53,825
or guest crash and it's because it's a silent device,

00:55:53,825 --> 00:55:57,238
sometimes device, device have direct control

00:55:57,238 --> 00:56:00,223
to the, I mean, driver in the guest has direct control

00:56:00,223 --> 00:56:03,625
to the device so they can issue work

00:56:03,625 --> 00:56:06,984
dispatch work and do word submission

00:56:06,984 --> 00:56:08,678
also can abort PASID.

00:56:08,678 --> 00:56:11,371
Those may be a little bit out of sync

00:56:11,371 --> 00:56:15,204
with the softer side of handling, for example,

00:56:17,012 --> 00:56:19,582
page request service that's going on

00:56:19,582 --> 00:56:23,749
between the IOMMU and the user space in the guest.

00:56:28,144 --> 00:56:31,844
Before I can jump into the technical part,

00:56:31,844 --> 00:56:35,844
this is kind of continuation or, Eric was asking

00:56:37,994 --> 00:56:41,380
in terms of upstream plan, can we make it

00:56:41,380 --> 00:56:44,412
upstream in a very can coordinate and

00:56:44,412 --> 00:56:49,005
also revealable fashion, so, what we have in mind

00:56:49,005 --> 00:56:51,313
was to divide into baby steps,

00:56:51,313 --> 00:56:54,483
make something really simple first

00:56:54,483 --> 00:56:57,235
and then get those merged and then move on

00:56:57,235 --> 00:57:00,120
to solve more complex problems.

00:57:00,120 --> 00:57:04,404
So, roughly, our plan is to submit in three phases.

00:57:04,404 --> 00:57:09,045
Currently, we are on just supporting PCI device assignment.

00:57:09,045 --> 00:57:12,370
So, or the nested translation basically,

00:57:12,370 --> 00:57:17,370
guest shared virtual memory without handling page request.

00:57:17,637 --> 00:57:22,220
So, this is the latest patch posted here in last month.

00:57:23,485 --> 00:57:28,058
So for that, we only need basically, three APIs.

00:57:28,058 --> 00:57:31,225
IOMMU APIs and corresponding VFIO APIs

00:57:34,126 --> 00:57:36,126
that's in Eric's series.

00:57:37,624 --> 00:57:40,374
So, we need to as Eric mentioned,

00:57:41,410 --> 00:57:44,810
we don't have, we have per PASID granularity

00:57:44,810 --> 00:57:47,180
to assigned to individual guest this way.

00:57:47,180 --> 00:57:50,304
And then the guest PASID table is on the by the host

00:57:50,304 --> 00:57:53,402
and then and we only have bind guest PASID

00:57:53,402 --> 00:57:58,402
per PASID basis, so we introduced API to bind guest PASID.

00:57:58,455 --> 00:58:02,939
And and if the caching validation part is shared

00:58:02,939 --> 00:58:04,772
between ARM and Intel.

00:58:07,486 --> 00:58:10,104
- [Ben] You mean the cache for PASID table.

00:58:10,104 --> 00:58:14,243
- Including the yeah, the guest PASID cache

00:58:14,243 --> 00:58:16,480
- [Ben] Sorry, the, for the recordings.

00:58:16,480 --> 00:58:17,569
When you cache in your

00:58:17,569 --> 00:58:18,738
I haven't followed the patches.

00:58:18,738 --> 00:58:20,669
Which specific caches are you talking about?

00:58:20,669 --> 00:58:23,655
- It is IOTLB device TLB, validation.

00:58:23,655 --> 00:58:25,822
The PASID cache validation

00:58:27,118 --> 00:58:29,734
does not use this API, basically, resolved

00:58:29,734 --> 00:58:32,207
in the bind in the guest PASID.

00:58:32,207 --> 00:58:36,323
- So, I'm coming here from a different world

00:58:36,323 --> 00:58:39,048
so then some details I'm not familiar with.

00:58:39,048 --> 00:58:40,510
You're saying that some conditions,

00:58:40,510 --> 00:58:43,602
we have to share the PASID space between guest and hosts

00:58:43,602 --> 00:58:46,954
that do not have completely off the kernel PASID space?

00:58:46,954 --> 00:58:50,846
- Yeah, so simply it's case where PASID space

00:58:50,846 --> 00:58:51,934
is system wide.

00:58:51,934 --> 00:58:53,706
So no matter how many guests you have,

00:58:53,706 --> 00:58:57,037
you always draw PASID space allocation from the host,

00:58:57,037 --> 00:58:58,844
which say the - Just because the IOTLB

00:58:58,844 --> 00:59:01,607
is not tagged by some form of VMID.

00:59:01,607 --> 00:59:03,051
It's only target by PASID.

00:59:03,051 --> 00:59:04,837
- Yeah. - Okay.

00:59:04,837 --> 00:59:08,900
- Well, yeah, that just relatively simple.

00:59:08,900 --> 00:59:12,131
We don't have to do the guest host PASID translation.

00:59:12,131 --> 00:59:15,922
Because one other feature we have is the NQ command.

00:59:15,922 --> 00:59:19,058
The guest application can directly submit work

00:59:19,058 --> 00:59:21,122
without going into the driver

00:59:21,122 --> 00:59:24,205
and if you do the guest PASID itself,

00:59:26,323 --> 00:59:30,354
we have to do a guest host PASID translation.

00:59:30,354 --> 00:59:32,781
- But you on, but because in hardware

00:59:32,781 --> 00:59:35,185
you have a single PASID space that you share

00:59:35,185 --> 00:59:37,518
between host and guest while

00:59:38,529 --> 00:59:41,245
if I understand correctly, Mark is saying about ARM,

00:59:41,245 --> 00:59:43,541
your TLB is tagged by VMID and PASID,

00:59:43,541 --> 00:59:47,232
meaning that you have a full PASID space for every guest

00:59:47,232 --> 00:59:50,933
so we do not have to do any guest host translation, right?

00:59:50,933 --> 00:59:53,911
Because on Power the same, Power PC back when I was a

00:59:53,911 --> 00:59:58,911
(mumbles), we tagged both and so, each guest

00:59:59,244 --> 01:00:01,919
would have a complete PASID space.

01:00:01,919 --> 01:00:03,754
I'm trying to understand what the (mumbles)

01:00:03,754 --> 01:00:05,397
- Sorry, I'm on the edge of my knowledge here as well.

01:00:05,397 --> 01:00:07,011
But the problem as I understand it

01:00:07,011 --> 01:00:09,230
is you have the main TLBs of the IOMMU,

01:00:09,230 --> 01:00:10,879
which maybe for us, ASID VMID.

01:00:10,879 --> 01:00:12,692
For Intel, probably something else, I don't know.

01:00:12,692 --> 01:00:13,779
And then you have the ATCs,

01:00:13,779 --> 01:00:17,276
which the IOTLBs in the PCI end point, right?

01:00:17,276 --> 01:00:20,016
And that part is PCI spec.

01:00:20,016 --> 01:00:22,739
And the things in there, I suspect,

01:00:22,739 --> 01:00:24,299
are only PASID tagged.

01:00:24,299 --> 01:00:25,904
- By (mumbles)

01:00:25,904 --> 01:00:28,051
- Well, yes, but they're not gonna have knowledge of

01:00:28,051 --> 01:00:29,988
- Inside of the - Right, so that will

01:00:29,988 --> 01:00:33,173
fill from the main IOMMU TLB.

01:00:33,173 --> 01:00:35,571
But the tag is going to be different

01:00:35,571 --> 01:00:38,180
is the way I understand it.

01:00:38,180 --> 01:00:41,259
- 'Cause this is only, this is only a problem

01:00:41,259 --> 01:00:44,676
if you wan a single BDFN to support PASID

01:00:47,421 --> 01:00:50,595
from different partitions of both option guests.

01:00:50,595 --> 01:00:55,595
Or, 'cause usually the BDFN maps some address space or VMID.

01:00:57,158 --> 01:00:58,656
At least that's how I understand things.

01:00:58,656 --> 01:01:01,917
But my understanding of Intel is not that good, so.

01:01:01,917 --> 01:01:03,808
- [Man] I think that the each BFD

01:01:03,808 --> 01:01:05,462
we have is also in PASID space.

01:01:05,462 --> 01:01:06,515
- Yeah. - I don't see.

01:01:06,515 --> 01:01:09,016
- Yeah, he said the PASID table is per BDF.

01:01:09,016 --> 01:01:10,632
- [Ben] So why do you need to share something

01:01:10,632 --> 01:01:12,442
that I'm trying to understand?

01:01:12,442 --> 01:01:16,413
- From upstream perspective, it's simplicity for right now.

01:01:16,413 --> 01:01:17,755
'Cause this way,

01:01:17,755 --> 01:01:19,344
- But that mean that every time a guest

01:01:19,344 --> 01:01:21,306
want to pop a PASID, he has to talk to the hypervisor

01:01:21,306 --> 01:01:24,473
which makes it a lot more complicated.

01:01:25,813 --> 01:01:28,183
- Every time, sorry, I didn't get it.

01:01:28,183 --> 01:01:29,948
- Every time the guest want to allocate

01:01:29,948 --> 01:01:33,115
a new PASID, it needs to coordinate with a hypervisor,

01:01:33,115 --> 01:01:34,271
which sounds complicated.

01:01:34,271 --> 01:01:36,237
He shouldn't need to do that.

01:01:36,237 --> 01:01:39,404
If you have a - We have the implemented

01:01:40,940 --> 01:01:45,857
emulated kind of interface for PASID allocation in the spec

01:01:47,238 --> 01:01:49,180
kind of like the caching mode.

01:01:49,180 --> 01:01:51,042
- [Ben] Okay, let's move on.

01:01:51,042 --> 01:01:52,886
I need to understand more about your hardware

01:01:52,886 --> 01:01:54,782
actually doing here.

01:01:54,782 --> 01:01:58,282
- So, I really wanna get out of this slide

01:01:59,408 --> 01:02:02,408
is can we agree on these baby steps?

01:02:06,571 --> 01:02:07,580
(mumbling)

01:02:07,580 --> 01:02:09,469
I think agreeing on that does go back

01:02:09,469 --> 01:02:10,871
to understanding that question.

01:02:10,871 --> 01:02:14,450
Why do we need an interface to communicate

01:02:14,450 --> 01:02:18,014
with a hypervisor and coordinate on PASIDs?

01:02:18,014 --> 01:02:19,607
Why would we need to do that.

01:02:19,607 --> 01:02:21,359
It's something we need to discuss before

01:02:21,359 --> 01:02:22,229
we agree to do it, right?

01:02:22,229 --> 01:02:24,948
- It's in the spec as hardware.

01:02:24,948 --> 01:02:27,637
- I'm perfectly prepared to declare the detail specs

01:02:27,637 --> 01:02:30,227
are frankly insane at times and maybe

01:02:30,227 --> 01:02:32,243
we don't want to do it that way.

01:02:32,243 --> 01:02:36,209
What is the actual hardware restriction

01:02:36,209 --> 01:02:37,633
that means we have to do this?

01:02:37,633 --> 01:02:40,217
- There's no hardware restrictions, even with

01:02:40,217 --> 01:02:45,217
even with the emulated PASID, you know, the guest only

01:02:45,435 --> 01:02:48,566
PASID allocation, we called a virtual command interface.

01:02:48,566 --> 01:02:51,800
It can still be intercepted by the hypervisor

01:02:51,800 --> 01:02:56,383
can provide either identity or an identity mapping, so.

01:02:57,342 --> 01:02:59,677
- [Participant] So, we are totally free within Linux

01:02:59,677 --> 01:03:01,532
to declare we're gonna do identity mapping

01:03:01,532 --> 01:03:02,887
because anything else is pointless

01:03:02,887 --> 01:03:05,320
and not have to do any of this stuff

01:03:05,320 --> 01:03:07,973
of individual PASIDs, right?

01:03:07,973 --> 01:03:08,835
- Okay. - But that's

01:03:08,835 --> 01:03:12,063
just a special case, basically you say, right?

01:03:12,063 --> 01:03:12,896
- Rewind.

01:03:14,159 --> 01:03:15,621
I have two devices.

01:03:15,621 --> 01:03:18,321
One is in guest A, the other one is in guest B.

01:03:18,321 --> 01:03:20,784
They both use PASID one.

01:03:20,784 --> 01:03:21,929
Where is the problem?

01:03:21,929 --> 01:03:24,172
Why do I need to turn those two PASID ones

01:03:24,172 --> 01:03:26,441
into some other PASID?

01:03:26,441 --> 01:03:30,968
Why can't the hardware, is IOT not tagging the BDFN

01:03:30,968 --> 01:03:33,598
along with the PASID or what?

01:03:33,598 --> 01:03:36,011
- They both use PASID but one of the

01:03:36,011 --> 01:03:38,331
say, page request come in, they're gonna

01:03:38,331 --> 01:03:39,815
- [Ben] The BDFN should differentiate.

01:03:39,815 --> 01:03:40,723
- BDFN and the PASID.

01:03:40,723 --> 01:03:43,393
It comes with BDFN PASID.

01:03:43,393 --> 01:03:45,307
But that's just PASID one.

01:03:45,307 --> 01:03:46,444
- But it's different PASID one.

01:03:46,444 --> 01:03:47,986
It's the PASID of that BDFN.

01:03:47,986 --> 01:03:52,711
The PASID one of that BDFN and they go to different guests.

01:03:52,711 --> 01:03:54,171
- Yeah, (faint talking)

01:03:54,171 --> 01:03:56,088
Yeah, it's combination.

01:03:57,718 --> 01:04:02,468
But we also allow BDF PASID within one BDF multiple path,

01:04:04,000 --> 01:04:07,365
multiple sub divides and being assigned to separate guests.

01:04:07,365 --> 01:04:11,101
- Okay, that is the answer I was looking for.

01:04:11,101 --> 01:04:14,434
So, you're allowing within a same device

01:04:16,075 --> 01:04:20,002
same, let's say originator ID to be less PCI specific.

01:04:20,002 --> 01:04:23,551
You allow several multiple PASIDs to be targeted

01:04:23,551 --> 01:04:25,736
at different VM contexts.

01:04:25,736 --> 01:04:26,569
- [Jason] Yeah, exactly.

01:04:26,569 --> 01:04:27,402
- Okay.

01:04:29,480 --> 01:04:32,659
- E6, E6 to support scalable IEOB

01:04:32,659 --> 01:04:34,067
that you are doing this.

01:04:34,067 --> 01:04:36,184
- Yeah yeah, it's exactly for.

01:04:36,184 --> 01:04:37,899
- So, I think for scalable IoE

01:04:37,899 --> 01:04:38,815
- [Ben] Ooh, I don't now what scalable IoE is.

01:04:38,815 --> 01:04:41,257
- The scalable IoE is the only mode in Intel

01:04:41,257 --> 01:04:42,746
with super PASID.

01:04:42,746 --> 01:04:46,164
- Yeah, it's the way in which you actually

01:04:46,164 --> 01:04:50,414
share the same BDF function with multiple contexts.

01:04:52,053 --> 01:04:55,275
So that means that the BDF will remain the same

01:04:55,275 --> 01:04:57,845
and you will need to have a pool of PASIDs from its use.

01:04:57,845 --> 01:05:00,059
- So, it basically for lazy people

01:05:00,059 --> 01:05:02,669
who don't want to implement a SROV.

01:05:02,669 --> 01:05:05,167
(laughing) - Or who have hit other limits

01:05:05,167 --> 01:05:06,834
with SIOV, but okay.

01:05:08,051 --> 01:05:09,637
That's a viable justification.

01:05:09,637 --> 01:05:12,580
- No absolutely, but I wanted to clarify it.

01:05:12,580 --> 01:05:15,484
I think it's some of us at least myself,

01:05:15,484 --> 01:05:17,750
were missing that background.

01:05:17,750 --> 01:05:19,952
- Scalable IoE spec is available,

01:05:19,952 --> 01:05:22,003
that's why we - Yeah, but those

01:05:22,003 --> 01:05:23,796
are scalable IoE patch is already merged, guys.

01:05:23,796 --> 01:05:27,971
- Let's not figure why because we had SROV, but okay.

01:05:27,971 --> 01:05:29,644
- [4th Participant] Or it's just a lightweight.

01:05:29,644 --> 01:05:31,720
It's very lightweight.

01:05:31,720 --> 01:05:33,560
- It's not lightweight for software to have to deal with it.

01:05:33,560 --> 01:05:35,324
But (laughing).

01:05:35,324 --> 01:05:36,989
- So, I also have a question.

01:05:36,989 --> 01:05:40,940
So, when the guest has one of these mediator devices,

01:05:40,940 --> 01:05:43,658
does it have an emulated IOMMU?

01:05:43,658 --> 01:05:45,241
Or - Yeah.

01:05:45,241 --> 01:05:46,824
- So, it's - But the

01:05:47,876 --> 01:05:50,275
- [5th Participant] CC Intel IOMMU basically itself.

01:05:50,275 --> 01:05:53,150
- Yeah, CC Intel IOMMU but only sees PCI device.

01:05:53,150 --> 01:05:55,017
The media device presented as is, yeah.

01:05:55,017 --> 01:05:57,600
- Okay, and given ISI and that,

01:06:01,066 --> 01:06:05,582
and with that IOMMU it has also a PSID report or

01:06:05,582 --> 01:06:07,832
that - Yeah, it has to be, yeah.

01:06:07,832 --> 01:06:09,160
So. - So then probably

01:06:09,160 --> 01:06:12,685
the best is to have a non identity guest host PSID mapping

01:06:12,685 --> 01:06:13,518
and just

01:06:15,861 --> 01:06:17,358
- But then you can't do that sharing thing

01:06:17,358 --> 01:06:19,574
that's they were talking about.

01:06:19,574 --> 01:06:20,407
- What sharing thing?

01:06:20,407 --> 01:06:23,740
- Of having the thing - Yes, scalable IoE

01:06:24,848 --> 01:06:27,739
is actually having the same media at work.

01:06:27,739 --> 01:06:30,810
- Yeah, I know, I know but you can tell the guest

01:06:30,810 --> 01:06:33,643
basically, you have say, 16 PASIDs

01:06:34,795 --> 01:06:37,178
and the physical device has 32

01:06:37,178 --> 01:06:39,726
and then you can partition your host PASID space

01:06:39,726 --> 01:06:42,298
among the guests PSID space.

01:06:42,298 --> 01:06:44,214
- Yeah, we thought about that.

01:06:44,214 --> 01:06:45,970
That's complicated too.

01:06:45,970 --> 01:06:47,558
- [Ben] So you also end up with interesting complications.

01:06:47,558 --> 01:06:48,807
- [5th Participant] Yeah you need to keep tracking the host,

01:06:48,807 --> 01:06:50,800
which guest PASID maps to which host PSID

01:06:50,800 --> 01:06:52,164
and do the translation all the time.

01:06:52,164 --> 01:06:55,839
- And how do you reasonably make the decision

01:06:55,839 --> 01:07:00,241
of out of your limited PASID space who gets how much?

01:07:00,241 --> 01:07:03,158
- Right that another concern, yeah.

01:07:04,299 --> 01:07:08,032
So, we can touch that I have only four slides.

01:07:08,032 --> 01:07:10,956
But I think for our first baby step,

01:07:10,956 --> 01:07:13,813
we don't need to concern too much

01:07:13,813 --> 01:07:16,257
or it's just PCI device assignment.

01:07:16,257 --> 01:07:19,588
And can we agree on the things,

01:07:19,588 --> 01:07:24,588
those API can get merged first and then we can move on.

01:07:24,955 --> 01:07:27,825
- I don't think the break down is controversial.

01:07:27,825 --> 01:07:28,739
I don't know.

01:07:28,739 --> 01:07:30,156
Anybody disagree?

01:07:31,316 --> 01:07:34,290
The breakdown seems to be perfectly reasonable.

01:07:34,290 --> 01:07:36,393
I would like to just to get the patches

01:07:36,393 --> 01:07:39,476
I mean, I'm interested how you define the amount

01:07:39,476 --> 01:07:42,402
that gets located for every

01:07:42,402 --> 01:07:44,617
context or virtual device sort of stuff?

01:07:44,617 --> 01:07:45,812
So those are the little nasty things

01:07:45,812 --> 01:07:47,170
that you don't think about initially

01:07:47,170 --> 01:07:50,860
and then they come and bit you badly later on.

01:07:50,860 --> 01:07:52,196
- I mean, would there be a performance issue

01:07:52,196 --> 01:07:54,724
if you have hundreds of (mumbles).

01:07:54,724 --> 01:07:56,903
- Well, it depend what you define by preference

01:07:56,903 --> 01:07:59,335
if the user just can't do what he wants to do

01:07:59,335 --> 01:08:00,686
because he's running out of space.

01:08:00,686 --> 01:08:03,244
It's pick up the functionality problem.

01:08:03,244 --> 01:08:05,115
- Oh, something that you have to request for

01:08:05,115 --> 01:08:07,168
- Can you pass the mic between here.

01:08:07,168 --> 01:08:10,873
- What, so yeah, so you talk about a request.

01:08:10,873 --> 01:08:12,685
So that mean you have an API.

01:08:12,685 --> 01:08:14,510
It not just emulating a piece of hardware

01:08:14,510 --> 01:08:16,578
so it gets a bit more complex here.

01:08:16,578 --> 01:08:18,495
- That's that's. - Okay.

01:08:21,031 --> 01:08:23,594
And so the next. - The question I still have

01:08:23,594 --> 01:08:26,770
is why do you need a separate guest PASID interface

01:08:26,770 --> 01:08:31,030
to find guest PASID when we have bind PASID?

01:08:31,030 --> 01:08:33,843
Can we make the bind PASID interface suitable

01:08:33,843 --> 01:08:38,316
for both, for host and for guest PASID bindings?

01:08:38,316 --> 01:08:39,149
- [Ben] Good point, nested translation.

01:08:39,149 --> 01:08:41,313
- No, it's different because the guest, the host binding

01:08:41,313 --> 01:08:44,482
you have the, for example, the MM notifier

01:08:44,482 --> 01:08:47,235
but the guest bind doesn't have it.

01:08:47,235 --> 01:08:51,230
It's by the guest CR3 so that when the guest

01:08:51,230 --> 01:08:54,873
process terminates, it has the result in the unbind

01:08:54,873 --> 01:08:57,773
and eventually pass that so, it's very different

01:08:57,773 --> 01:08:59,523
than the native bind.

01:09:03,777 --> 01:09:06,616
But we do, in terms of tracking.

01:09:06,616 --> 01:09:08,080
- It's different in what it does

01:09:08,080 --> 01:09:09,655
but should it, does it need to be different

01:09:09,655 --> 01:09:11,405
in term of interface?

01:09:12,500 --> 01:09:14,907
That I think more, don't quote me if I'm wrong

01:09:14,907 --> 01:09:17,721
but that's more the question, right?

01:09:17,721 --> 01:09:19,096
Should API be different?

01:09:19,096 --> 01:09:22,007
I mean, we could imagine mass virtualization

01:09:22,007 --> 01:09:25,559
when were gonna have a guest binding the sub guest.

01:09:25,559 --> 01:09:28,541
- The difference between the host handling,

01:09:28,541 --> 01:09:30,871
between the handling of a PASID fault on the host

01:09:30,871 --> 01:09:33,123
and which, one which has

01:09:33,123 --> 01:09:36,908
and the guest is handling of fault, rights?

01:09:36,908 --> 01:09:38,779
The actual fault function that is running the end.

01:09:38,779 --> 01:09:39,612
- Yeah.

01:09:39,612 --> 01:09:40,556
- So we can have a base interface,

01:09:40,556 --> 01:09:45,122
which is more like this, which doesn't have an MM

01:09:45,122 --> 01:09:50,122
as a parameter but more like a fault handler descriptor

01:09:50,216 --> 01:09:51,890
or something.

01:09:51,890 --> 01:09:56,890
And then put on top of that the host and the guest support.

01:09:57,299 --> 01:10:01,547
- The fault handling if that's in native case

01:10:01,547 --> 01:10:05,661
is usually just handled within the IOMMU host IOMMU driver

01:10:05,661 --> 01:10:08,478
itself where guest bind, it needs to inject through

01:10:08,478 --> 01:10:09,478
VFIO, right?

01:10:10,373 --> 01:10:14,040
So, we already have the IOMMU device forward

01:10:15,512 --> 01:10:18,704
reporting APS, so that's common.

01:10:18,704 --> 01:10:20,357
But that - Let's look at

01:10:20,357 --> 01:10:23,156
the patches, I don't know, it's hard to,

01:10:23,156 --> 01:10:25,252
we're getting into details that's hard to decide anything

01:10:25,252 --> 01:10:27,382
without actually seeing the code.

01:10:27,382 --> 01:10:28,944
- [Participant] What exactly is calling the APIs

01:10:28,944 --> 01:10:31,464
on the left hand pane there?

01:10:31,464 --> 01:10:35,631
Are those visible to arbitrary PCI device drivers?

01:10:36,642 --> 01:10:37,804
- VFIO? - No, those are,

01:10:37,804 --> 01:10:40,068
a guest bind is VFIO, yeah. - Okay.

01:10:40,068 --> 01:10:42,151
- It's as through Eric's,

01:10:44,392 --> 01:10:47,107
those cache invalidates really the guest

01:10:47,107 --> 01:10:49,357
passed on cache invalidate.

01:10:50,828 --> 01:10:53,702
And the IO8 allocation, those are shared

01:10:53,702 --> 01:10:56,380
between guest and the host but there will be

01:10:56,380 --> 01:10:59,516
a switch to decide whether you're in the guest or not

01:10:59,516 --> 01:11:01,335
so, you use separate allocator.

01:11:01,335 --> 01:11:03,070
- So, with, I think, interface value

01:11:03,070 --> 01:11:07,877
are you just register some kind of fault handling mechanism

01:11:07,877 --> 01:11:12,877
for a given PASID or, for example could just register its

01:11:13,098 --> 01:11:14,682
own fault handling mechanism for PSID

01:11:14,682 --> 01:11:17,166
but if it wants to pass through that PASID

01:11:17,166 --> 01:11:20,749
to the guest, and then we have the separate

01:11:21,843 --> 01:11:25,610
piece of code which does that for host processes,

01:11:25,610 --> 01:11:27,006
which are then called by device driver

01:11:27,006 --> 01:11:30,166
that (mumbles) PASIDs with the device.

01:11:30,166 --> 01:11:32,136
- Yeah, VFIO is just one of the device driver

01:11:32,136 --> 01:11:34,017
can be treated that way.

01:11:34,017 --> 01:11:36,816
And yeah, I have one of the open

01:11:36,816 --> 01:11:39,553
was to talk about the, some,

01:11:39,553 --> 01:11:43,352
the gaps in terms of fault reporting.

01:11:43,352 --> 01:11:46,082
Maybe we can talk, if that's - So, that mean

01:11:46,082 --> 01:11:48,567
effectively, that on the host side the

01:11:48,567 --> 01:11:51,766
the implementation is directly done in the IOMMU driver

01:11:51,766 --> 01:11:55,736
for the hots side fault handler, right?

01:11:55,736 --> 01:11:58,269
That what you were saying before?

01:11:58,269 --> 01:11:59,102
- Sorry.

01:11:59,102 --> 01:12:01,852
Yeah, the host detects the fault.

01:12:03,086 --> 01:12:05,286
- But implementation of the fault handler itself

01:12:05,286 --> 01:12:08,786
is in host IOMMU driver or it's elsewhere?

01:12:10,436 --> 01:12:13,213
- Yes, the IOMMU driver implements the first time.

01:12:13,213 --> 01:12:18,213
But say, there is unrecoverable fault and recover fault.

01:12:18,254 --> 01:12:21,560
So, it will make determination whether you want

01:12:21,560 --> 01:12:25,248
to give a driver a chance to do something about a fault,

01:12:25,248 --> 01:12:27,800
like, I think the previous discussion you had.

01:12:27,800 --> 01:12:29,906
So, and then can tell, you know,

01:12:29,906 --> 01:12:33,189
the driver did something, you say, reset, whatever.

01:12:33,189 --> 01:12:34,987
Give it (mumbling) being handled,

01:12:34,987 --> 01:12:39,092
kind of like the ROQ were handled or continue case.

01:12:39,092 --> 01:12:42,168
And that was for guest fault,

01:12:42,168 --> 01:12:44,405
there'll be a flag say this guest PASID

01:12:44,405 --> 01:12:46,481
belong to the guest, so you don't do anything.

01:12:46,481 --> 01:12:48,405
You give to the guest and the guest

01:12:48,405 --> 01:12:51,119
will handle MM fault and then eventually come back.

01:12:51,119 --> 01:12:52,684
Give you paid response.

01:12:52,684 --> 01:12:57,351
So, I guess, it's similar than the ISVA native SVA bind.

01:12:59,253 --> 01:13:03,086
I can look into it whether we can consolidate.

01:13:04,702 --> 01:13:07,151
Yeah but maybe think of this, we'll get a little bit more

01:13:07,151 --> 01:13:11,372
you know, the structure gets a little more complicated.

01:13:11,372 --> 01:13:12,482
Yeah.

01:13:12,482 --> 01:13:14,512
Yeah, definitely I can look into that, yeah.

01:13:14,512 --> 01:13:16,391
- [Ben] Okay.

01:13:16,391 --> 01:13:18,421
That was something I was also wondering about

01:13:18,421 --> 01:13:19,922
when looking at the pictures, so.

01:13:19,922 --> 01:13:22,948
- Okay, so maybe just at least flag or something

01:13:22,948 --> 01:13:27,265
to indicate, okay, but in terms of fault reporting,

01:13:27,265 --> 01:13:29,393
that should be enabled to share.

01:13:29,393 --> 01:13:33,058
Yeah, 'cause right now we have print device,

01:13:33,058 --> 01:13:36,650
IOMMU detail for fault device, fault handling.

01:13:36,650 --> 01:13:39,444
- So, in the case where we do not have sharing

01:13:39,444 --> 01:13:43,217
of PASID space, it will be nice if the exact same interface

01:13:43,217 --> 01:13:44,982
could be used and so, effectively, that means

01:13:44,982 --> 01:13:47,776
that's bind gPASID is a nope.

01:13:47,776 --> 01:13:51,291
Or just whatever housekeeping that may need to be done

01:13:51,291 --> 01:13:55,411
in hardware for flushing the PASID cache or something.

01:13:55,411 --> 01:13:56,244
So, I don't know.

01:13:56,244 --> 01:13:59,170
I haven't looked, but it will be still nice

01:13:59,170 --> 01:14:01,828
to have the same interface for registering PASIDs

01:14:01,828 --> 01:14:04,749
regardless of the type of IOMMU we have under the hood.

01:14:04,749 --> 01:14:08,988
- I see, so instead of just a dead API for ARM, for example,

01:14:08,988 --> 01:14:10,837
you want - So, if you don't share,

01:14:10,837 --> 01:14:13,600
or on Intel and you're not in share mode

01:14:13,600 --> 01:14:15,971
and you have separate PASID spaces, you want to be look at

01:14:15,971 --> 01:14:16,974
- [Jacob] We don't have that anymore.

01:14:16,974 --> 01:14:17,807
- Mm?

01:14:17,807 --> 01:14:18,640
- [Jacob] We don't have that anymore.

01:14:18,640 --> 01:14:19,473
We - Oh, that's okay.

01:14:19,473 --> 01:14:21,442
So, Intel went all the way to removing the ability

01:14:21,442 --> 01:14:22,275
to - Right,

01:14:22,275 --> 01:14:24,300
because there wasn't user anyways, so.

01:14:24,300 --> 01:14:25,409
- Oh yeah.

01:14:25,409 --> 01:14:27,968
There's always other reason we don't use ATS.

01:14:27,968 --> 01:14:29,416
- [Participant] And the table have to be contiguous

01:14:29,416 --> 01:14:30,608
and it was just horrible.

01:14:30,608 --> 01:14:31,691
- Okay, yeah.

01:14:33,664 --> 01:14:36,214
- Is this the wrong time to ask how do you cope

01:14:36,214 --> 01:14:38,733
with first level versus second level faults

01:14:38,733 --> 01:14:40,536
when you're passing through PASIDs?

01:14:40,536 --> 01:14:43,339
And do you pre fault the actual target page

01:14:43,339 --> 01:14:46,172
when the guest has faulted in the,

01:14:47,059 --> 01:14:48,892
I suppose, your domain?

01:14:48,892 --> 01:14:50,787
- Yeah, for the first phase, where Intel required

01:14:50,787 --> 01:14:52,047
a guest pre fault page.

01:14:52,047 --> 01:14:55,547
And the second level is pinned down, yeah.

01:14:57,020 --> 01:14:59,020
So, it's remaining time.

01:15:00,409 --> 01:15:01,970
I wanna kind of touch on the

01:15:01,970 --> 01:15:04,620
- The second level, you said is pined down.

01:15:04,620 --> 01:15:07,203
I hope that's not our long term

01:15:13,568 --> 01:15:16,664
- So, this picture, we try to show,

01:15:16,664 --> 01:15:18,595
we basically have two flows.

01:15:18,595 --> 01:15:22,678
The slow PAS and the fast PAS for the PASID setup

01:15:24,625 --> 01:15:29,105
and the run time DMA, so, the slow PAS we have,

01:15:29,105 --> 01:15:31,988
you know the bit band prime PASID and PASID cache

01:15:31,988 --> 01:15:35,300
invalidation and eventually go, PASID programming.

01:15:35,300 --> 01:15:38,609
And on a fast PAS, we handle DMA and a page request.

01:15:38,609 --> 01:15:41,062
The point I try to make is that we

01:15:41,062 --> 01:15:44,395
because the interaction for page request

01:15:45,437 --> 01:15:49,368
is between the guest process, guest kernel

01:15:49,368 --> 01:15:53,212
and the IOMMU where device can also directly control

01:15:53,212 --> 01:15:55,640
work submission with the PASID.

01:15:55,640 --> 01:15:57,134
So we have this race condition,

01:15:57,134 --> 01:16:00,645
especially when we need to tear down.

01:16:00,645 --> 01:16:04,018
So, I think Alex will review the patch holes

01:16:04,018 --> 01:16:08,010
or mention that and when we unregister the,

01:16:08,010 --> 01:16:11,080
so those are the issue I wanna bring up.

01:16:11,080 --> 01:16:15,692
Because we can do per PASID and a BDF assignment

01:16:15,692 --> 01:16:19,525
to a guest, and we will, we lack of a function

01:16:21,488 --> 01:16:24,031
that will reset on a per PASID basis.

01:16:24,031 --> 01:16:27,563
But it's also important keep the PASID lifecycle separate

01:16:27,563 --> 01:16:30,361
meaning, when you terminate the PASID for whatever reason,

01:16:30,361 --> 01:16:32,551
you don't want it either anything remain.

01:16:32,551 --> 01:16:34,428
We need to drain everything in the software,

01:16:34,428 --> 01:16:39,011
in the hardware so, I wanna propose adding a new API

01:16:39,011 --> 01:16:43,584
to do the PASID stop, which does the PASID drain

01:16:43,584 --> 01:16:46,527
and also clear other pending faults.

01:16:46,527 --> 01:16:48,482
- [Ben] You mean the driver API?

01:16:48,482 --> 01:16:49,982
- Yeah, IOMMU API.

01:16:51,242 --> 01:16:53,875
- [Ben] Sorry, okay, I didn't follow something.

01:16:53,875 --> 01:16:55,787
- So, basically, the use case would be,

01:16:55,787 --> 01:16:58,843
say, for example, today if the device wanted to issue

01:16:58,843 --> 01:17:02,428
a command, say, I wanna abort this PASID

01:17:02,428 --> 01:17:03,809
and it goes to device and the device

01:17:03,809 --> 01:17:06,744
will not be able to abort if there are pending faults.

01:17:06,744 --> 01:17:08,630
But there is no way, but the pending faults

01:17:08,630 --> 01:17:12,575
are basically responded by the IOMMU drivers.

01:17:12,575 --> 01:17:15,204
So, there's lack of communication there.

01:17:15,204 --> 01:17:18,977
But if we have this API to stop the PASID

01:17:18,977 --> 01:17:21,535
and drain everything and when it time to unbind

01:17:21,535 --> 01:17:24,438
and to abort it, there will be always succeed.

01:17:24,438 --> 01:17:26,426
So the un-registration of the handler

01:17:26,426 --> 01:17:27,875
will also always succeed.

01:17:27,875 --> 01:17:31,412
We don't have to, they will succeed.

01:17:31,412 --> 01:17:35,146
- [Person] Was that the hardware to abort directly?

01:17:35,146 --> 01:17:36,372
- Well, you need, yes.

01:17:36,372 --> 01:17:37,705
You need, sorry,

01:17:39,323 --> 01:17:42,625
- I mean, you need the hardware to support the PASID reset

01:17:42,625 --> 01:17:46,884
and draining up all the transactions in flight if that

01:17:46,884 --> 01:17:48,775
- [Ben] And do we have to all interface to that?

01:17:48,775 --> 01:17:50,295
- I don't think that is

01:17:50,295 --> 01:17:54,519
- I think by spec, the hardware is the highest weight

01:17:54,519 --> 01:17:57,447
for the all the pending page request to be responded,

01:17:57,447 --> 01:18:00,591
otherwise, the device will not abort.

01:18:00,591 --> 01:18:01,491
- But it's not that.

01:18:01,491 --> 01:18:04,840
I mean, we do, do we have a way that is standard

01:18:04,840 --> 01:18:08,291
to tell a piece of hardware today's, stop using that PASID?

01:18:08,291 --> 01:18:12,033
Regardless, assuming it finishes all its pending requests.

01:18:12,033 --> 01:18:14,033
And I don't think we do.

01:18:14,879 --> 01:18:17,764
- [Person] If we put on the (mumbling and coughing)

01:18:17,764 --> 01:18:19,264
- No. - Microphone.

01:18:20,375 --> 01:18:22,299
- Yeah, sorry.

01:18:22,299 --> 01:18:25,226
- I mean, it's the equivalent of (mumbles) and I don't think

01:18:25,226 --> 01:18:28,410
it is currently available at the PASID granularity.

01:18:28,410 --> 01:18:30,084
- [2nd Presenter] Right, that's the point, yeah.

01:18:30,084 --> 01:18:31,902
- So, fundamentally, what you need,

01:18:31,902 --> 01:18:36,107
because you have a guest to stop using your PASID.

01:18:36,107 --> 01:18:40,357
The host must not re freeze and delaying real PASID

01:18:44,922 --> 01:18:48,764
until it has reasonable trusted agent

01:18:48,764 --> 01:18:53,764
telling it that piece of hardware is no longer using it.

01:18:54,114 --> 01:18:56,828
That agent has to be in the hypervisor,

01:18:56,828 --> 01:18:59,341
So, but I assume that if you have a device

01:18:59,341 --> 01:19:00,918
that can be shared with multiple guests,

01:19:00,918 --> 01:19:05,212
there must be some form of coordinating driver

01:19:05,212 --> 01:19:06,823
in hypervisor because otherwise,

01:19:06,823 --> 01:19:08,662
I don't know how you can do that.

01:19:08,662 --> 01:19:11,344
It's a bit like the PF if you (mumbling).

01:19:11,344 --> 01:19:14,351
- Well, if the device misbehave and it's still

01:19:14,351 --> 01:19:16,510
doing transaction with the old PASID,

01:19:16,510 --> 01:19:18,772
it will get auto responded.

01:19:18,772 --> 01:19:20,660
- Until it gets allocated to somebody else.

01:19:20,660 --> 01:19:22,597
And then you have a real problem on your hands.

01:19:22,597 --> 01:19:24,215
- There's no way to, I don't think.

01:19:24,215 --> 01:19:27,434
- No, but so, that's why I'm not saying let's bother

01:19:27,434 --> 01:19:30,939
too much about the driver, device with physically broken

01:19:30,939 --> 01:19:33,134
and just saying the device that it can

01:19:33,134 --> 01:19:34,130
- It's not broken.

01:19:34,130 --> 01:19:36,053
It's actually by spec.

01:19:36,053 --> 01:19:39,126
The device abort can be timed out

01:19:39,126 --> 01:19:43,684
or pending if you, if the IOMMU driver does not respond

01:19:43,684 --> 01:19:44,964
to all the pending faults.

01:19:44,964 --> 01:19:46,852
- Yeah, so what you're trying to fix here

01:19:46,852 --> 01:19:47,971
is just chicken and egg thing

01:19:47,971 --> 01:19:52,204
where you try to stop the PASID at the hypervisor level.

01:19:52,204 --> 01:19:56,174
But you can't because the device on behalf of the guest

01:19:56,174 --> 01:19:59,072
is waiting on an IOMMU response.

01:19:59,072 --> 01:20:01,560
So you do need indeed, I see what you mean,

01:20:01,560 --> 01:20:06,143
tell the IOMMU drivers to terminate any pending request

01:20:09,477 --> 01:20:10,727
for that PASID.

01:20:11,599 --> 01:20:13,099
I understand that.

01:20:14,654 --> 01:20:17,987
I am still somewhat wondering in term of

01:20:19,664 --> 01:20:21,898
from a security perspective

01:20:21,898 --> 01:20:24,576
how the hypervisor get reasonable guarantee

01:20:24,576 --> 01:20:29,280
that that device has indeed stop using the PASID

01:20:29,280 --> 01:20:31,408
and doesn't have something in the guest

01:20:31,408 --> 01:20:34,539
we're gonna sneaks through more requests

01:20:34,539 --> 01:20:36,295
after we think the PASID is free

01:20:36,295 --> 01:20:38,864
and we're gonna give it to somebody else.

01:20:38,864 --> 01:20:42,947
And that smells to me that there is a gap in spec

01:20:44,524 --> 01:20:48,750
that needs to be addressed and so, it's an Intel spec,

01:20:48,750 --> 01:20:53,167
guys, to provide some standardized hardware mechanism

01:20:56,659 --> 01:21:00,432
to say do not issue anything anymore

01:21:00,432 --> 01:21:03,159
with that PASID or maybe in and that would be

01:21:03,159 --> 01:21:06,021
- That's the reason that it's the invalid response for.

01:21:06,021 --> 01:21:10,285
I mean, they're telling no more request from their PASID.

01:21:10,285 --> 01:21:13,868
The invalid response from the IOMMU driver,

01:21:15,603 --> 01:21:16,881
the response code I mean.

01:21:16,881 --> 01:21:18,278
- So the response, do you have today

01:21:18,278 --> 01:21:19,896
a response code on the bus

01:21:19,896 --> 01:21:22,505
that tell the device no more request for that PASID?

01:21:22,505 --> 01:21:25,986
But that's only useful if the device has done the request.

01:21:25,986 --> 01:21:29,721
The device hasn't done a request yet.

01:21:29,721 --> 01:21:31,018
I don't know.

01:21:31,018 --> 01:21:33,570
You know, I can run a little bit of code on the device

01:21:33,570 --> 01:21:37,720
that can adapt the request shortly after I've been killed.

01:21:37,720 --> 01:21:40,193
So, it's I don't know, it's kind of corner cases

01:21:40,193 --> 01:21:43,780
that I think deserve a big magnifier

01:21:43,780 --> 01:21:45,395
and make sure that there's have been addressed.

01:21:45,395 --> 01:21:46,977
We're not gonna solve it now.

01:21:46,977 --> 01:21:48,270
And I think we should move on.

01:21:48,270 --> 01:21:50,741
But - I must ask you to

01:21:50,741 --> 01:21:54,222
wrap up, I don't know if you have any further questions

01:21:54,222 --> 01:21:56,192
for the audience or you want to follow up

01:21:56,192 --> 01:21:57,399
when is the, if you have time.

01:21:57,399 --> 01:21:58,433
I mean, - Okay, yeah

01:21:58,433 --> 01:22:01,516
just a quick question maybe for Alex.

01:22:03,036 --> 01:22:06,036
If we implement this kind of a stop,

01:22:07,026 --> 01:22:09,692
and then we can guarantee our registration never fail,

01:22:09,692 --> 01:22:12,609
would that be I guess, suitable for

01:22:14,439 --> 01:22:16,967
for this API, I mean, so on registration,

01:22:16,967 --> 01:22:19,873
a fault handler means we don't care, like you say

01:22:19,873 --> 01:22:22,227
and it will never fail.

01:22:22,227 --> 01:22:26,579
- Yeah, my concern was that in the previous,

01:22:26,579 --> 01:22:30,329
in the previous iteration, the unregistration

01:22:31,267 --> 01:22:33,788
could fail and then the question was

01:22:33,788 --> 01:22:36,497
what does VFIO do at that point?

01:22:36,497 --> 01:22:39,992
So, it just seemed like we needed to make the

01:22:39,992 --> 01:22:41,854
de registration not fail but I agree

01:22:41,854 --> 01:22:44,587
with the concern of how do we make sure

01:22:44,587 --> 01:22:46,420
the device then stops?

01:22:47,415 --> 01:22:49,792
- [Jacob] This a little bit beyond software, I guess.

01:22:49,792 --> 01:22:53,341
- Is that gonna be part of the assignable interface

01:22:53,341 --> 01:22:56,839
to the SVA device to make it stop using?

01:22:56,839 --> 01:22:58,893
- I can bring this question back to the

01:22:58,893 --> 01:23:00,153
query write us back and

01:23:00,153 --> 01:23:01,131
- Okay. - Yeah,

01:23:01,131 --> 01:23:02,731
it's little bit beyond software.

01:23:02,731 --> 01:23:03,564
- [Alex] Maybe if we're tearing it down

01:23:03,564 --> 01:23:06,975
or essentially doing an FLR sort of thing on the AI

01:23:06,975 --> 01:23:08,240
then - Yeah,

01:23:08,240 --> 01:23:11,495
that could be per device implementations well

01:23:11,495 --> 01:23:15,359
but spec wise, I agree, there should be something

01:23:15,359 --> 01:23:18,942
to make sure it's clean between lives yeah.

01:23:20,809 --> 01:23:23,429
And and then another point is that

01:23:23,429 --> 01:23:28,137
open, it's when we need to support a mediator device,

01:23:28,137 --> 01:23:32,932
meaning today, we have only per physical devices

01:23:32,932 --> 01:23:36,945
and then the for handling, it's also per physical device.

01:23:36,945 --> 01:23:40,195
I want to add a multiple data per PASID

01:23:42,272 --> 01:23:46,469
for handling data, such that when per PASID

01:23:46,469 --> 01:23:50,122
fault handle, per PASID fault happens,

01:23:50,122 --> 01:23:53,329
we can report it to the device driver

01:23:53,329 --> 01:23:55,503
with appropriate data, so.

01:23:55,503 --> 01:23:57,344
- [Ben] You mean just a voice to argument.

01:23:57,344 --> 01:23:58,326
- What's that?

01:23:58,326 --> 01:23:59,853
- [Ben] You mean just a voice to argument

01:23:59,853 --> 01:24:02,008
that we pass back to the handler?

01:24:02,008 --> 01:24:03,154
- Yeah.

01:24:03,154 --> 01:24:05,606
But today we only have per device label.

01:24:05,606 --> 01:24:07,208
But we need to have basically

01:24:07,208 --> 01:24:10,291
add more IRQ vector, yeah, so that's.

01:24:11,607 --> 01:24:13,328
And - I think we have

01:24:13,328 --> 01:24:14,558
to wrap it up.

01:24:14,558 --> 01:24:16,527
- Okay, sorry the - Be careful the

01:24:16,527 --> 01:24:21,527
(mumbling) the conference (mumbling)

01:24:21,854 --> 01:24:22,687
Thank you.

01:24:22,687 --> 01:24:27,376
- [Jacob] Thank you. (applause)

01:24:27,376 --> 01:24:28,493
- Okay, hello.

01:24:28,493 --> 01:24:29,731
My name is Cornelia Huck.

01:24:29,731 --> 01:24:31,255
I'm working for Red Hat.

01:24:31,255 --> 01:24:34,338
I'm mainly doing SV90 virtualization.

01:24:35,783 --> 01:24:38,801
That where I basically come from, mainframe stuff.

01:24:38,801 --> 01:24:41,858
I've been doing virtualization for some years now

01:24:41,858 --> 01:24:46,121
and I'm mainly looking at this from the VFIO perspective,

01:24:46,121 --> 01:24:49,523
not so much from my IOMMU side.

01:24:49,523 --> 01:24:52,384
So, what I basically want to talk about

01:24:52,384 --> 01:24:56,467
or more get people to be of to discuss and so on,

01:24:59,614 --> 01:25:03,281
is that is sometimes have really weird stuff

01:25:04,739 --> 01:25:06,618
happening of different architectures.

01:25:06,618 --> 01:25:10,338
I notice this quite often with my mainframe perspective.

01:25:10,338 --> 01:25:12,919
I see pictures posted and they are often

01:25:12,919 --> 01:25:15,134
assuming everything is PCI.

01:25:15,134 --> 01:25:16,217
No, it's not.

01:25:17,402 --> 01:25:21,144
Or that everything is working somehow

01:25:21,144 --> 01:25:24,295
in a way that is similar to what x86 is doing

01:25:24,295 --> 01:25:28,291
and that's also obviously not just happening.

01:25:28,291 --> 01:25:31,060
Those guys of you who are doing ARM or Power,

01:25:31,060 --> 01:25:35,558
or whatever, will have encountered that same problem,

01:25:35,558 --> 01:25:38,975
I guess, so what I really want to do here

01:25:40,181 --> 01:25:42,237
is not really talk about these points

01:25:42,237 --> 01:25:43,988
I have on the slide here.

01:25:43,988 --> 01:25:47,864
That's what mainly when I was just thinking about stuff.

01:25:47,864 --> 01:25:52,402
What is really things I have seen that are problematic?

01:25:52,402 --> 01:25:54,695
That's the classic, of course, the (mumbles) stuff

01:25:54,695 --> 01:25:56,981
it's not as important for VFIO.

01:25:56,981 --> 01:25:59,992
It's more important in other areas.

01:25:59,992 --> 01:26:04,557
But there's also stuff that is not so quite obvious.

01:26:04,557 --> 01:26:08,057
One of my favorite kind of examples is PCI

01:26:10,456 --> 01:26:12,192
on the mainframe.

01:26:12,192 --> 01:26:17,109
PCI on the mainframe is just not what you expect PCI to be.

01:26:17,968 --> 01:26:22,511
It is using some instructions, no memory map IO.

01:26:22,511 --> 01:26:25,261
So, it's totally crazy basically.

01:26:29,884 --> 01:26:32,389
Another example also from the mainframe side

01:26:32,389 --> 01:26:35,918
is that our actually main set of devices

01:26:35,918 --> 01:26:38,501
we are using is not PCI at all.

01:26:40,026 --> 01:26:41,980
It happens on other architectures as well

01:26:41,980 --> 01:26:43,694
that you have one PCI devices

01:26:43,694 --> 01:26:48,094
but for SV90, the actual main set of devices you are using

01:26:48,094 --> 01:26:50,629
is CCW channel IO devices,

01:26:50,629 --> 01:26:53,648
which work in a completely different way.

01:26:53,648 --> 01:26:57,231
You don't use the normal IOMMU interactions

01:26:58,936 --> 01:27:02,218
because it's basically done by hardware.

01:27:02,218 --> 01:27:03,933
You send a channel (mumbles) there,

01:27:03,933 --> 01:27:07,011
it does the translation, it does stuff.

01:27:07,011 --> 01:27:11,194
And that's something where people are just looking

01:27:11,194 --> 01:27:13,094
at me with big eyes and go,

01:27:13,094 --> 01:27:16,261
it's not like PCI on x86, no it's not.

01:27:18,474 --> 01:27:21,224
(faint speaking)

01:27:22,730 --> 01:27:24,594
Actual the channel IO instructions

01:27:24,594 --> 01:27:26,892
that we're using today is from the marching 80s

01:27:26,892 --> 01:27:31,225
so it's marching you up. (laughing)

01:27:32,956 --> 01:27:36,623
So, what I wanted to do is start discussion,

01:27:37,791 --> 01:27:42,101
start awareness and I, what I also wanted to do

01:27:42,101 --> 01:27:44,755
what was my cunning plan is not to do much of the talking

01:27:44,755 --> 01:27:48,041
but let you do a little bit of the talking.

01:27:48,041 --> 01:27:51,776
And just bring up stuff from ARM, from Power, from whatever

01:27:51,776 --> 01:27:55,512
where you notice that there is some things

01:27:55,512 --> 01:27:59,520
made by people coming from x86 platforms,

01:27:59,520 --> 01:28:02,282
which are not (mumbles) on your platforms.

01:28:02,282 --> 01:28:04,526
Just that people have heard about it

01:28:04,526 --> 01:28:07,176
that they can keep in the back of their mind.

01:28:07,176 --> 01:28:08,602
Okay, I'm designing something.

01:28:08,602 --> 01:28:10,602
I have a new feature and it might not

01:28:10,602 --> 01:28:15,431
just work like I think, like people with that background

01:28:15,431 --> 01:28:17,181
might think it works.

01:28:18,401 --> 01:28:23,288
So, does anybody has any weird examples to share?

01:28:23,288 --> 01:28:26,139
Or something just which has come up repeatedly

01:28:26,139 --> 01:28:28,722
which just didn't work out like

01:28:29,888 --> 01:28:32,471
they thought it would work out?

01:28:33,604 --> 01:28:34,576
- [Alex] Eric mentioned one earlier.

01:28:34,576 --> 01:28:38,392
The MSI mapping on Arm is pretty weird.

01:28:38,392 --> 01:28:39,945
- [Eric] What's weird about it?

01:28:39,945 --> 01:28:41,395
(laughing)

01:28:41,395 --> 01:28:42,532
- That's a good answer.

01:28:42,532 --> 01:28:44,867
I have another one.

01:28:44,867 --> 01:28:46,617
Level triggered MSIs.

01:28:47,935 --> 01:28:49,100
(faint speaking)

01:28:49,100 --> 01:28:50,767
- What? - Yeah, yeah.

01:28:51,681 --> 01:28:52,842
You have that in your hallway.

01:28:52,842 --> 01:28:53,675
Don't laugh.

01:28:53,675 --> 01:28:54,555
It's good.

01:28:54,555 --> 01:28:55,892
You know you want it.

01:28:55,892 --> 01:28:58,142
(laughing)

01:28:59,386 --> 01:29:03,491
- Mind you, interface in Dion PC Express

01:29:03,491 --> 01:29:06,042
are effectively level (mumbles) size

01:29:06,042 --> 01:29:07,694
and you have a lot of interesting problem.

01:29:07,694 --> 01:29:09,564
Nobody think about if they get stuck

01:29:09,564 --> 01:29:10,758
to one in the bridge for example

01:29:10,758 --> 01:29:13,430
because you just FLR will kill your device

01:29:13,430 --> 01:29:17,792
while it had raised it but didn't send the go down message.

01:29:17,792 --> 01:29:20,491
And yeah, there's lots of interesting issues.

01:29:20,491 --> 01:29:24,538
That's why you, any same virtualization modern one

01:29:24,538 --> 01:29:28,845
these days refuses to pass through stuff with an LSI.

01:29:28,845 --> 01:29:29,762
Just don't.

01:29:32,507 --> 01:29:36,172
Struct was a whole IOMMU subsystem originally.

01:29:36,172 --> 01:29:39,820
Was very very much designed around x86

01:29:39,820 --> 01:29:41,744
and it was very very difficult to adapt it

01:29:41,744 --> 01:29:44,827
to Power as you, as you may remember.

01:29:47,057 --> 01:29:52,057
But I mean, it's the first one to propose something wins

01:29:52,090 --> 01:29:54,300
and if you haven't been following (mumbles)

01:29:54,300 --> 01:29:57,028
which nobody does, you miss that that thing was happening

01:29:57,028 --> 01:29:59,609
and so you don't get involved because you're busy doing

01:29:59,609 --> 01:30:02,946
something else and by the time you realize it's all upstream

01:30:02,946 --> 01:30:04,093
and then you want to do your own thing

01:30:04,093 --> 01:30:06,305
and then you really really struggle.

01:30:06,305 --> 01:30:07,369
But - I know that the two

01:30:07,369 --> 01:30:10,508
that Power is only using the IOMMU groups

01:30:10,508 --> 01:30:13,299
but nothing else from the IOMMU code.

01:30:13,299 --> 01:30:14,998
So, I wondered always why this is

01:30:14,998 --> 01:30:16,807
and maybe you can explain what's so different

01:30:16,807 --> 01:30:18,400
about the Power IOMMU.

01:30:18,400 --> 01:30:21,893
- Honestly, last I've looked at the details of that

01:30:21,893 --> 01:30:22,893
a while ago,

01:30:28,301 --> 01:30:29,564
there's a holy story behind that.

01:30:29,564 --> 01:30:32,116
I think probably because we had our own infrastructure

01:30:32,116 --> 01:30:35,851
that was there and different in software.

01:30:35,851 --> 01:30:38,921
Fundamentally, as always (mumbles) IOMMU

01:30:38,921 --> 01:30:41,357
were simpler, they didn't have trees.

01:30:41,357 --> 01:30:43,715
They were just tables.

01:30:43,715 --> 01:30:46,994
They, the grouping was not as arbitrary

01:30:46,994 --> 01:30:49,095
as what can we do in it but that has changed over time.

01:30:49,095 --> 01:30:50,763
We used to have, for example, the address space

01:30:50,763 --> 01:30:51,738
being shared between all the groups.

01:30:51,738 --> 01:30:53,907
We just had segments of it assigned to groups.

01:30:53,907 --> 01:30:55,038
That has changed.

01:30:55,038 --> 01:30:57,741
Depending on the generation of Power system,

01:30:57,741 --> 01:30:58,970
a lot of those assumptions that those things

01:30:58,970 --> 01:31:01,065
could be arbitrarily mapped and device could be

01:31:01,065 --> 01:31:03,460
arbitrarily put into groups were not true.

01:31:03,460 --> 01:31:07,030
They became true with later implementation of Power.

01:31:07,030 --> 01:31:09,363
But they were not initially.

01:31:11,647 --> 01:31:12,480
The

01:31:15,308 --> 01:31:17,497
but a lot of it is just inertia.

01:31:17,497 --> 01:31:19,248
We had a whole infrastructure built and

01:31:19,248 --> 01:31:21,957
working on different software model.

01:31:21,957 --> 01:31:25,813
And switching to the IOMMU group model

01:31:25,813 --> 01:31:28,378
would have required pulling everything out

01:31:28,378 --> 01:31:29,833
but part of our problem Power, yes,

01:31:29,833 --> 01:31:32,543
is we have a hypervisor.

01:31:32,543 --> 01:31:33,682
And we have a hypervisor that doesn't work

01:31:33,682 --> 01:31:35,774
like any other hypervisor.

01:31:35,774 --> 01:31:39,570
It's a hypervisor that require high back calls

01:31:39,570 --> 01:31:44,377
for apparently everything you want to do short of breathing

01:31:44,377 --> 01:31:47,388
and which interface that makes assumption

01:31:47,388 --> 01:31:49,423
in what how you do DMA devices

01:31:49,423 --> 01:31:51,659
that looks a lot what AX does and pretty much

01:31:51,659 --> 01:31:54,198
nothing to do with what Linux does.

01:31:54,198 --> 01:31:57,804
And I will say, we, I'm not involved with Power anymore.

01:31:57,804 --> 01:32:01,699
But yes, a lot of was driven by that.

01:32:01,699 --> 01:32:02,532
So,

01:32:02,532 --> 01:32:05,206
- Yeah - We had no controlled groups

01:32:05,206 --> 01:32:06,657
in the guest peripheral.

01:32:06,657 --> 01:32:08,892
The group was set by hypervisor first.

01:32:08,892 --> 01:32:10,454
And we had no control whatsoever.

01:32:10,454 --> 01:32:12,753
- Okay. - But I was just

01:32:12,753 --> 01:32:16,997
about to say that we can't have the IOMMU

01:32:16,997 --> 01:32:20,098
which is also an IOMMU which runs in a hypervisor

01:32:20,098 --> 01:32:23,122
so, but your one is probably different.

01:32:23,122 --> 01:32:25,705
- But then we, yeah, but when KVM came round the corner

01:32:25,705 --> 01:32:28,608
we started also doing, so get your IOMMU

01:32:28,608 --> 01:32:29,662
something that could be useful in Power,

01:32:29,662 --> 01:32:32,995
I'm pretty sure for the KVMKs bit 'cause

01:32:34,273 --> 01:32:38,606
we've been emulating the Power hypervisor IOMMU APIs

01:32:41,633 --> 01:32:42,849
in the guest.

01:32:42,849 --> 01:32:47,535
And so we have on Power today had for pretty much ever.

01:32:47,535 --> 01:32:50,603
The hyper calls is that allow the guest

01:32:50,603 --> 01:32:54,004
to put translation into an IOMMU.

01:32:54,004 --> 01:32:57,793
And we then went to iteration of how we're going to actually

01:32:57,793 --> 01:33:00,208
handle that on the host side.

01:33:00,208 --> 01:33:02,447
In part because we had some fast pass

01:33:02,447 --> 01:33:04,306
to get those things in what's called

01:33:04,306 --> 01:33:08,031
remodels MMU off in the host, don't get me started.

01:33:08,031 --> 01:33:09,353
Which should be here tomorrow.

01:33:09,353 --> 01:33:11,679
But it was really difficult.

01:33:11,679 --> 01:33:14,047
We couldn't even do a guest page.

01:33:14,047 --> 01:33:16,628
We didn't access, have an implementation of these things

01:33:16,628 --> 01:33:17,939
if we want them to be fast.

01:33:17,939 --> 01:33:22,793
We couldn't do access most of Linux's basic primitives

01:33:22,793 --> 01:33:24,586
because we didn't have access to the kernel

01:33:24,586 --> 01:33:26,419
virtual address space.

01:33:28,246 --> 01:33:30,091
And so, yeah, a lot of these things

01:33:30,091 --> 01:33:32,760
makes things a bit more tricky because

01:33:32,760 --> 01:33:35,204
this is not really how the thing was thought out

01:33:35,204 --> 01:33:37,441
but eventually I think, especially Alex,

01:33:37,441 --> 01:33:39,668
they managed to get things working.

01:33:39,668 --> 01:33:41,835
Also not very pretty, but,

01:33:43,158 --> 01:33:44,437
big questions also that came up.

01:33:44,437 --> 01:33:48,102
Because we started having an IOMMU in the guest

01:33:48,102 --> 01:33:51,055
early on, when do we pin the pages?

01:33:51,055 --> 01:33:53,791
And if we pin at the point where the guest

01:33:53,791 --> 01:33:55,637
put the translation, that mean the guest

01:33:55,637 --> 01:33:59,804
can arbitrarily choose to pin page and unpin pages

01:34:01,192 --> 01:34:04,004
how that accounted in the host.

01:34:04,004 --> 01:34:05,352
How do we set limits?

01:34:05,352 --> 01:34:06,515
What happen if you hit the limit

01:34:06,515 --> 01:34:09,880
because we can't fail an IOMMU insertion?

01:34:09,880 --> 01:34:12,212
No driver can deal with that properly.

01:34:12,212 --> 01:34:15,478
And I'm reasonably sure that 90% of the network drivers

01:34:15,478 --> 01:34:17,438
all there if they fail a translation

01:34:17,438 --> 01:34:20,310
are going to be very very, doing very very very very

01:34:20,310 --> 01:34:21,857
bad things to you.

01:34:21,857 --> 01:34:26,098
They, they don't put in the ring instead,

01:34:26,098 --> 01:34:28,874
pointer to the main page, which is what we should be doing.

01:34:28,874 --> 01:34:31,249
So that the device don't some writing to some

01:34:31,249 --> 01:34:33,582
stale translation somewhere.

01:34:34,964 --> 01:34:37,214
So, it's, it's complicated.

01:34:39,016 --> 01:34:40,306
There's lots of history there.

01:34:40,306 --> 01:34:43,082
Let's stop because I could go forever.

01:34:43,082 --> 01:34:43,915
Find other examples.

01:34:43,915 --> 01:34:47,433
- There's lots of history always involved, yeah.

01:34:47,433 --> 01:34:51,600
So, does anybody of you have some crux, basically,

01:34:53,148 --> 01:34:56,280
on how devices are being used?

01:34:56,280 --> 01:34:59,253
One thing I notice is when I was talk,

01:34:59,253 --> 01:35:02,717
when there was that patch that coming for migration

01:35:02,717 --> 01:35:05,134
of devices attached by a VFIO

01:35:06,558 --> 01:35:08,739
and there always assume that everybody

01:35:08,739 --> 01:35:11,122
who wanted to migrate a guest from system A

01:35:11,122 --> 01:35:13,796
to system B, had the silent device

01:35:13,796 --> 01:35:16,874
as accessible by both systems.

01:35:16,874 --> 01:35:19,433
But it seems that's a rather exotic case,

01:35:19,433 --> 01:35:21,860
which I thought was more of the default case

01:35:21,860 --> 01:35:23,983
that everybody wanted to use.

01:35:23,983 --> 01:35:27,483
So, do you guys, can you think of anything

01:35:28,417 --> 01:35:32,262
like that where you made assumptions which just

01:35:32,262 --> 01:35:33,892
did not turn out to be true?

01:35:33,892 --> 01:35:38,823
- Well, Linux has one assumption that has been sad

01:35:38,823 --> 01:35:41,768
for some, but I'm pretty sure for (mumbles) as well,

01:35:41,768 --> 01:35:43,155
the one that you cannot migrate

01:35:43,155 --> 01:35:45,411
if you have assigned devices.

01:35:45,411 --> 01:35:47,232
- [Alex] We're working on that.

01:35:47,232 --> 01:35:49,154
- [Cornelia] It's in the box.

01:35:49,154 --> 01:35:52,603
- 'Cause we have hardware that can migrate DM pages

01:35:52,603 --> 01:35:53,436
within (mumbles) DMAs from.

01:35:53,436 --> 01:35:56,535
Oh, we can also not move pages that are currently

01:35:56,535 --> 01:35:57,689
used for DMA.

01:35:57,689 --> 01:35:58,692
We can.

01:35:58,692 --> 01:36:00,255
We have hardware to do that.

01:36:00,255 --> 01:36:02,260
But there is no way to (mumbles) up into Linux.

01:36:02,260 --> 01:36:03,634
There is no relationship between

01:36:03,634 --> 01:36:06,284
the guts of the migrate page and the VM.

01:36:06,284 --> 01:36:09,201
And whatever DMA mapping, IOMMU API

01:36:10,282 --> 01:36:11,901
we might know whether there is something

01:36:11,901 --> 01:36:15,292
mapped to the page or not, but he doesn't even know.

01:36:15,292 --> 01:36:19,948
So, X won that but we can't give it to them in KVM.

01:36:19,948 --> 01:36:22,567
Because we have no, Linux was designed around the idea

01:36:22,567 --> 01:36:23,857
that you would never ever ever have

01:36:23,857 --> 01:36:26,024
to do something like this.

01:36:27,351 --> 01:36:30,702
- But to support migration on life migration

01:36:30,702 --> 01:36:32,581
on guest versus (mumbles) devices,

01:36:32,581 --> 01:36:35,581
you need at least access and 30 bits

01:36:37,562 --> 01:36:40,058
at least 30 bits for IOMMU.

01:36:40,058 --> 01:36:42,029
IOMMU page tables, right?

01:36:42,029 --> 01:36:46,821
Then you need at lest 30 bits for IOMMU page tables, right?

01:36:46,821 --> 01:36:49,673
To not lose any in flight DMA.

01:36:49,673 --> 01:36:51,553
- [Ben] That or active cooperation with the driver,

01:36:51,553 --> 01:36:53,530
which is harder.

01:36:53,530 --> 01:36:54,363
Yeah.

01:36:57,202 --> 01:37:00,185
- The active cooperation is probably what we're working on

01:37:00,185 --> 01:37:01,389
with M Dev, though, so.

01:37:01,389 --> 01:37:03,115
- It's the way that we work.

01:37:03,115 --> 01:37:06,282
And 30 bit IOMMU, some do, some don't.

01:37:08,021 --> 01:37:09,132
Yeah.

01:37:09,132 --> 01:37:10,754
Active provision with the driver probably the best

01:37:10,754 --> 01:37:11,587
at this point.

01:37:11,587 --> 01:37:14,993
I mean, the easy way is you use a suspend resume

01:37:14,993 --> 01:37:18,550
call backs and find a way to stream the hardware state.

01:37:18,550 --> 01:37:19,383
So,

01:37:20,458 --> 01:37:22,479
- That makes it less live.

01:37:22,479 --> 01:37:24,534
- Yes, it does.

01:37:24,534 --> 01:37:26,919
- Yeah, I mean for CCW, what I actually

01:37:26,919 --> 01:37:28,850
plan to do to support migration

01:37:28,850 --> 01:37:32,073
is have some kind of (mumbles), which is easy to do

01:37:32,073 --> 01:37:34,503
because it's always a channel program which is

01:37:34,503 --> 01:37:37,127
then on and you can just wait if it's idle

01:37:37,127 --> 01:37:40,297
and then migrate it over and then we start it again.

01:37:40,297 --> 01:37:41,216
That should be not too hard.

01:37:41,216 --> 01:37:44,696
- Yeah. - But from IOMMU remapped IO,

01:37:44,696 --> 01:37:49,279
it's obviously much more difficult than it was problem.

01:37:50,534 --> 01:37:52,852
- Mind you, talking about something different

01:37:52,852 --> 01:37:56,891
and in this case, if, I see something on risk five

01:37:56,891 --> 01:37:57,891
called CSRs.

01:37:59,012 --> 01:38:01,280
(faint speaking) No no.

01:38:01,280 --> 01:38:03,620
Somebody's somebody knows.

01:38:03,620 --> 01:38:05,311
I though that, I've seen something that looks

01:38:05,311 --> 01:38:06,903
dangerously like having a (mumbles) bus

01:38:06,903 --> 01:38:09,245
to control devices that is not ordered

01:38:09,245 --> 01:38:11,245
with the main data path.

01:38:13,788 --> 01:38:14,663
Doesn't ring any bell?

01:38:14,663 --> 01:38:16,913
No risk five people around?

01:38:18,271 --> 01:38:19,576
CSRs.

01:38:19,576 --> 01:38:20,409
- CSR.

01:38:22,210 --> 01:38:24,127
You mean the HOBS - Mic.

01:38:26,614 --> 01:38:27,975
- Mic. - Mic.

01:38:27,975 --> 01:38:32,392
- You mean the HO, HV, GV, how to say that, I forget.

01:38:36,359 --> 01:38:40,609
VH, the guest model changed to the hypervisor model

01:38:42,133 --> 01:38:43,858
VSR issues?

01:38:43,858 --> 01:38:47,269
- No, look, no, maybe I missed something.

01:38:47,269 --> 01:38:49,166
There have been people in the past been doing that

01:38:49,166 --> 01:38:50,555
and it's evil.

01:38:50,555 --> 01:38:53,467
Effectively, a separate bus to send commands

01:38:53,467 --> 01:38:56,561
or separate instructions that is not in order

01:38:56,561 --> 01:38:59,474
with your main data path.

01:38:59,474 --> 01:39:01,301
- You mean PCI order?

01:39:01,301 --> 01:39:03,019
- Order in general.

01:39:03,019 --> 01:39:04,440
Whether this is a PCI ordering mechanism

01:39:04,440 --> 01:39:06,157
or some other ordering mechanism,

01:39:06,157 --> 01:39:07,743
but at least there is one.

01:39:07,743 --> 01:39:09,306
- You mean, there's a complete side bend bus.

01:39:09,306 --> 01:39:10,696
- Yeah, yeah.

01:39:10,696 --> 01:39:13,599
We have, there's some cell (mumbles) machines

01:39:13,599 --> 01:39:14,737
where something lovely like this

01:39:14,737 --> 01:39:18,374
where you had no way to stop the DM engine controller

01:39:18,374 --> 01:39:20,855
and know for sure that it had to finish

01:39:20,855 --> 01:39:23,272
pushing order for data into memory.

01:39:23,272 --> 01:39:25,513
And so you're changing your AMTU.

01:39:25,513 --> 01:39:27,400
You have to free and relocate all the packet

01:39:27,400 --> 01:39:29,330
but you don't know when this thing has stopped actually

01:39:29,330 --> 01:39:31,427
writing to memory.

01:39:31,427 --> 01:39:33,510
Yeah, it's hardware guys.

01:39:36,621 --> 01:39:39,745
Always coming up with funny IDs.

01:39:39,745 --> 01:39:42,495
(faint speaking)

01:39:47,668 --> 01:39:50,091
While you put a delay and assume that the thing,

01:39:50,091 --> 01:39:52,483
you're never gonna be stuck in the bridge more than that

01:39:52,483 --> 01:39:57,483
but (chuckles) it's wishful thinking sometimes.

01:39:57,615 --> 01:40:01,032
- We wait and hope for the best approach.

01:40:03,310 --> 01:40:04,143
- [Ben] That was a lot of what a

01:40:04,143 --> 01:40:07,060
cell processor was about, mind you.

01:40:09,463 --> 01:40:11,353
- [Eric] Cornelia, I don't know, I mean,

01:40:11,353 --> 01:40:14,567
I think we have to stick to the channel.

01:40:14,567 --> 01:40:17,274
Even that is open ended question.

01:40:17,274 --> 01:40:19,300
I don't know if you want to summarize it somehow

01:40:19,300 --> 01:40:21,564
for the audience so that maybe we can discuss

01:40:21,564 --> 01:40:24,064
it further the following days.

01:40:25,065 --> 01:40:27,917
- What I had is less of a question.

01:40:27,917 --> 01:40:30,650
It is really more that I wanted to just

01:40:30,650 --> 01:40:34,046
pull together some of the things which are different

01:40:34,046 --> 01:40:37,470
on different architectures which we should keep in mind.

01:40:37,470 --> 01:40:40,317
You've now heard about that weirdness on Power,

01:40:40,317 --> 01:40:44,567
which is really yeah, I don't want to work with it.

01:40:46,266 --> 01:40:50,034
But it's just something that I had noted

01:40:50,034 --> 01:40:53,948
that so many people are coming from x86 PCI perspective

01:40:53,948 --> 01:40:56,423
and I just wanted to raise awareness here,

01:40:56,423 --> 01:40:58,604
okay, there's different stuff.

01:40:58,604 --> 01:41:00,237
If you were doing something,

01:41:00,237 --> 01:41:05,102
just stop for a moment and think, is that what I am doing?

01:41:05,102 --> 01:41:07,909
More PCI specific, more x86 specific

01:41:07,909 --> 01:41:09,947
or it it really something more channel,

01:41:09,947 --> 01:41:13,645
so, if it is more channel, please try

01:41:13,645 --> 01:41:16,965
to check in with other architecture specialists.

01:41:16,965 --> 01:41:18,658
- 30 seconds on this one.

01:41:18,658 --> 01:41:20,432
First is keep in mind,

01:41:20,432 --> 01:41:25,432
you have the weirdest architecture of all. (laughing)

01:41:27,729 --> 01:41:30,146
But yeah, on PCI, one by one.

01:41:31,902 --> 01:41:36,011
If you know hardware design or are one yourself,

01:41:36,011 --> 01:41:40,094
do not have DMA address with limitations, please.

01:41:40,954 --> 01:41:45,704
Not everybody has its memory from 0 to 40-something bits.

01:41:46,553 --> 01:41:49,675
Or maybe few of you do if you're lucky.

01:41:49,675 --> 01:41:51,300
Some machines have a different layout

01:41:51,300 --> 01:41:55,072
and there is no standard mechanism whatsoever

01:41:55,072 --> 01:41:57,395
for hardware to expose its capabilities.

01:41:57,395 --> 01:41:59,722
Drivers might, in some circumstance and Linux

01:41:59,722 --> 01:42:03,215
is very very bad at dealing with all the restrictions.

01:42:03,215 --> 01:42:04,965
So, yeah, just don't.

01:42:07,920 --> 01:42:10,587
- Anybody have any other points?

01:42:11,480 --> 01:42:14,816
- It's not IOMU related but it's IOMMU related,

01:42:14,816 --> 01:42:16,885
which is the semantics of IO remaps,

01:42:16,885 --> 01:42:20,996
so, I updated one of the many useless documents

01:42:20,996 --> 01:42:23,750
on the documentation to deal with IO remap.

01:42:23,750 --> 01:42:26,833
But there's also IO remap WC and IO remap no cache.

01:42:26,833 --> 01:42:28,945
And I don't think anyone knows what they mean

01:42:28,945 --> 01:42:30,283
except - I tried, I failed.

01:42:30,283 --> 01:42:31,710
- Okay, even Ben doesn't know.

01:42:31,710 --> 01:42:34,389
- I tried to get some kind of agreement

01:42:34,389 --> 01:42:36,147
of what they mean.

01:42:36,147 --> 01:42:38,259
So, the problem is what is the meaning

01:42:38,259 --> 01:42:42,342
semantic, especially in term of ordering

01:42:42,342 --> 01:42:45,803
of an access to a region that has been mapped

01:42:45,803 --> 01:42:48,755
with some of the attributes and how does it matches again,

01:42:48,755 --> 01:42:51,509
between architectures, what are the effect of buyers?

01:42:51,509 --> 01:42:53,640
And what is the relationship between

01:42:53,640 --> 01:42:58,081
those access and access made to different memory types?

01:42:58,081 --> 01:43:01,248
Such as normal IOM to WCM normal remap

01:43:02,443 --> 01:43:05,267
or between that and cache-able access?

01:43:05,267 --> 01:43:07,366
And I'm pretty sure every single architecture

01:43:07,366 --> 01:43:08,906
get it different.

01:43:08,906 --> 01:43:09,864
And it's

01:43:09,864 --> 01:43:10,697
(faint speaking)

01:43:10,697 --> 01:43:11,530
I don't think so.

01:43:11,530 --> 01:43:15,441
And I'm pretty sure drivers get it wrong.

01:43:15,441 --> 01:43:17,092
And there is no clear semantic.

01:43:17,092 --> 01:43:21,184
And the kernel doesn't expose even basic guarantees

01:43:21,184 --> 01:43:24,316
that we have a lot of very strong guarantee

01:43:24,316 --> 01:43:25,972
expose of normal IO remap

01:43:25,972 --> 01:43:30,535
of ordering between accesses, between accesses and DMAs

01:43:30,535 --> 01:43:32,872
or and cache-able accesses and all of that.

01:43:32,872 --> 01:43:36,293
It's all very strong and very strict.

01:43:36,293 --> 01:43:38,412
You can even stronger, I suppose, if you want to.

01:43:38,412 --> 01:43:41,254
But at least we have those guarantees.

01:43:41,254 --> 01:43:43,413
We have non documented on any of

01:43:43,413 --> 01:43:47,008
the other memory types whatsoever.

01:43:47,008 --> 01:43:49,508
And yeah, it's a free for all.

01:43:50,600 --> 01:43:52,864
We should try to fix it one day.

01:43:52,864 --> 01:43:54,584
You've - Okay, if you say we,

01:43:54,584 --> 01:43:57,135
then - You and I (laughing)

01:43:57,135 --> 01:43:59,128
- [Cornelia] Or was it a (mumbles)

01:43:59,128 --> 01:44:01,908
- I think Will and I are the two more familiar

01:44:01,908 --> 01:44:04,094
with the problem probably in the community,

01:44:04,094 --> 01:44:05,177
to be honest.

01:44:06,617 --> 01:44:08,036
But yeah.

01:44:08,036 --> 01:44:09,809
Well, thank you for at least formalizing

01:44:09,809 --> 01:44:12,722
the correct semantics of the normal MMIOs.

01:44:12,722 --> 01:44:13,588
- It's a grievance if you understand it

01:44:13,588 --> 01:44:16,788
'cause you're formalizing it (faint speaking)

01:44:16,788 --> 01:44:17,621
- Yeah.

01:44:19,135 --> 01:44:19,968
- Okay.

01:44:21,011 --> 01:44:25,527
- And, and in (mumbles) and IO remember W

01:44:25,527 --> 01:44:29,694
that combine, before that, we don't implement that

01:44:31,089 --> 01:44:34,794
best APIs so, that's, it's therefore,

01:44:34,794 --> 01:44:39,124
to use the strong order to map and I find some problem

01:44:39,124 --> 01:44:41,957
because in hardware, store all the

01:44:43,476 --> 01:44:46,559
cannot process the alignment problem.

01:44:47,475 --> 01:44:50,975
And we are deal with some alignment issues

01:44:52,064 --> 01:44:55,564
and so, we just take off this strong order

01:44:57,074 --> 01:45:00,019
attribute for the IO map WC.

01:45:00,019 --> 01:45:02,086
- But you also want to be on Power.

01:45:02,086 --> 01:45:04,405
On Power PC, we also remove the dodge bits

01:45:04,405 --> 01:45:06,723
which technically means remove the strong

01:45:06,723 --> 01:45:09,591
all the bit, we get away with it because

01:45:09,591 --> 01:45:13,182
the semantic of cache inhibited space

01:45:13,182 --> 01:45:17,273
without that bit is still reasonably palatable.

01:45:17,273 --> 01:45:21,725
And we do shovel the buyers inside of the accesses as well.

01:45:21,725 --> 01:45:23,500
Interestingly enough, the way we do it on Power PC

01:45:23,500 --> 01:45:25,964
means that if you use (mumbles) on WC mapping,

01:45:25,964 --> 01:45:27,946
you will not get combining.

01:45:27,946 --> 01:45:29,820
You need to use raw.

01:45:29,820 --> 01:45:33,644
Because we have full sync, like full heavyweight buyers

01:45:33,644 --> 01:45:35,894
in every writer pretty much

01:45:37,668 --> 01:45:40,629
to keep the synchronization with the,

01:45:40,629 --> 01:45:43,087
with cache-able memory.

01:45:43,087 --> 01:45:46,754
And so, ideally, WC will have its own set of

01:45:47,690 --> 01:45:51,521
read or writers, which becomes a mass,

01:45:51,521 --> 01:45:53,965
we have a (mumbles) explosion of accesses

01:45:53,965 --> 01:45:56,475
and memory space types.

01:45:56,475 --> 01:45:58,395
I'm not sure what the right answer to that is.

01:45:58,395 --> 01:46:00,259
- We need to document.

01:46:00,259 --> 01:46:02,516
- We can document that it doesn't do what you expect.

01:46:02,516 --> 01:46:04,500
But (laughing)

01:46:04,500 --> 01:46:07,421
- [Eric] I think I have to stop it but map,

01:46:07,421 --> 01:46:10,937
it will take a couple of one two examples

01:46:10,937 --> 01:46:13,634
mentioned and probably we can discuss them further Wednesday

01:46:13,634 --> 01:46:15,898
if there is time or well, in the conference,

01:46:15,898 --> 01:46:19,786
I mean, can be something that can be discussed

01:46:19,786 --> 01:46:23,023
and to find a way forward, but for that time being,

01:46:23,023 --> 01:46:24,940
thank you very much and

01:46:27,942 --> 01:46:29,319
- Okay, yeah. Thank you all

01:46:29,319 --> 01:46:33,069
for your stories. (applause)

01:46:35,036 --> 01:46:36,734
(chatter) - Hardware is a road

01:46:36,734 --> 01:46:41,734
to device, but it doesn't mean it's (faint speaking)

01:46:42,745 --> 01:46:43,578
- I see.

01:46:44,786 --> 01:46:46,997
It's the memory issues.

01:46:46,997 --> 01:46:49,747
Because IO, IO it must be strong.

01:46:53,683 --> 01:46:57,335
- Strong, not always. - But the problem is

01:46:57,335 --> 01:47:00,168
some people use IO to make memory.

01:47:01,101 --> 01:47:02,950
Not just that.

01:47:02,950 --> 01:47:04,954
- According to a friend of mine,

01:47:04,954 --> 01:47:06,853
should a (mumbles) - You use

01:47:06,853 --> 01:47:09,576
- IO, remember to, basically use IO remember,

01:47:09,576 --> 01:47:13,736
to mapping the memory of - I think that's what

01:47:13,736 --> 01:47:17,184
all of Power drivers used to do back in the old days.

01:47:17,184 --> 01:47:22,184
And then we (chatter) was invited specifically

01:47:22,195 --> 01:47:25,028
for making framework first faster.

01:47:26,700 --> 01:47:29,950
And so, (soft chatter)

01:47:31,761 --> 01:47:32,881
that does not side effect,

01:47:32,881 --> 01:47:34,019
doesn't have side effects.

01:47:34,019 --> 01:47:36,164
It's just a piece of button, a piece of memory.

01:47:36,164 --> 01:47:38,414
(coughing)

01:47:42,883 --> 01:47:45,317
(chatter) Side effects.

01:47:45,317 --> 01:47:48,150
(throat clearing)

01:47:50,547 --> 01:47:53,466
- Now we have two topics that are strictly related

01:47:53,466 --> 01:47:56,108
on resource allocation and we're starting with John

01:47:56,108 --> 01:47:58,501
and option, reduce the PCI bars.

01:47:58,501 --> 01:48:00,168
So, thank you, John.

01:48:01,931 --> 01:48:03,747
- [Ben] All those things.

01:48:03,747 --> 01:48:06,997
- [Alex] Can you close the door please.

01:48:13,684 --> 01:48:14,684
- Now, okay.

01:48:15,742 --> 01:48:17,142
My name is John Derrick.

01:48:17,142 --> 01:48:20,225
I'm with Intel's division which deals

01:48:21,530 --> 01:48:25,863
with the non volatile storage host storage software.

01:48:26,719 --> 01:48:29,295
Today, I wanna talk about what we can do

01:48:29,295 --> 01:48:32,751
to make sure that mandatory BARs

01:48:32,751 --> 01:48:36,577
are successfully allocated as well as talk about

01:48:36,577 --> 01:48:40,267
what we can do about BARs which are not mandatory.

01:48:40,267 --> 01:48:42,260
Whether we can allocate them or not.

01:48:42,260 --> 01:48:47,093
And how we need to reduce them, in order to allocate them.

01:48:47,956 --> 01:48:50,869
So, the first thing I wanna do is talk about

01:48:50,869 --> 01:48:54,431
what is a required and what is an optional BAR?

01:48:54,431 --> 01:48:57,720
So, for my main example, I wanna talk about NVMe.

01:48:57,720 --> 01:49:01,277
We have NVMe BAR zero, which is a mandatory BAR.

01:49:01,277 --> 01:49:03,164
It's the register set.

01:49:03,164 --> 01:49:06,333
And then any other NVMe BAR, the MMIO BARs

01:49:06,333 --> 01:49:09,660
that are, those are the controller memory buffer

01:49:09,660 --> 01:49:12,257
and or the persistent memory region.

01:49:12,257 --> 01:49:15,545
So, in NVMe terminology, in the controller memory buffer

01:49:15,545 --> 01:49:20,545
is anything that the controller can handle that is volatile.

01:49:20,807 --> 01:49:24,083
So, this could be scatter gather lists,

01:49:24,083 --> 01:49:27,309
POPs, which is a form of scatter gather lists.

01:49:27,309 --> 01:49:30,610
Submission Q entries, completion Q entries,

01:49:30,610 --> 01:49:33,128
ray data and re data.

01:49:33,128 --> 01:49:35,606
And the persistent memory region is similar

01:49:35,606 --> 01:49:38,295
but it's a non volatile region.

01:49:38,295 --> 01:49:41,698
So, this is typically on the order of a lot

01:49:41,698 --> 01:49:43,327
a lot more more memory than just

01:49:43,327 --> 01:49:46,327
the normal controller memory buffer.

01:49:48,527 --> 01:49:50,813
So, the problem statement that I wanna talk about

01:49:50,813 --> 01:49:54,563
is the limited resources on these PCI domains

01:49:55,897 --> 01:49:58,413
often they don't often allow for the use

01:49:58,413 --> 01:50:00,508
of these optional BARs.

01:50:00,508 --> 01:50:02,880
So, the CMB, we don't get to use it.

01:50:02,880 --> 01:50:05,836
The PMR, we don't get to use it.

01:50:05,836 --> 01:50:10,048
All we have is the mandatory NVMe BAR, for example.

01:50:10,048 --> 01:50:12,864
The second use, the second issue is that

01:50:12,864 --> 01:50:16,974
the max for, max-first resource assignment that we have

01:50:16,974 --> 01:50:19,351
in the resources assignment code,

01:50:19,351 --> 01:50:22,954
typically, we will assign the most

01:50:22,954 --> 01:50:25,454
the most required sizes first.

01:50:28,168 --> 01:50:31,321
So, you could end up with an optional BAR,

01:50:31,321 --> 01:50:33,811
say, several megabytes size being assigned

01:50:33,811 --> 01:50:36,894
before the required BAR, for example,

01:50:37,986 --> 01:50:40,416
16 kilobytes, - So, let me just rewind

01:50:40,416 --> 01:50:41,499
for a minute.

01:50:43,375 --> 01:50:46,685
The, all of this stem from the fact

01:50:46,685 --> 01:50:49,939
that we also don't have a way to specify

01:50:49,939 --> 01:50:52,226
to the generate code what is optional

01:50:52,226 --> 01:50:53,514
and what is required, correct?

01:50:53,514 --> 01:50:55,054
- Yes. - Okay.

01:50:55,054 --> 01:50:56,867
So, I'll get to that.

01:50:56,867 --> 01:50:58,757
Yeah, and then the third point on the slide

01:50:58,757 --> 01:51:01,677
is it's kind of a combination of the first two.

01:51:01,677 --> 01:51:04,731
So, if you have limited resources in your PCI domain,

01:51:04,731 --> 01:51:07,337
and you're max first resource assignment code,

01:51:07,337 --> 01:51:10,318
you get uneven resource assignments.

01:51:10,318 --> 01:51:15,116
So, to show it as an example, I'll show you my PCI domain,

01:51:15,116 --> 01:51:17,193
my example PCI domain.

01:51:17,193 --> 01:51:20,570
So this is a typical PCI domain that I work with.

01:51:20,570 --> 01:51:24,133
You might have a report with 64 megabytes

01:51:24,133 --> 01:51:26,278
of non pre-fetch able memory.

01:51:26,278 --> 01:51:30,090
Same with a setup pre fetch able memory.

01:51:30,090 --> 01:51:32,257
You have an A port switch.

01:51:34,126 --> 01:51:36,543
And then a set of end points.

01:51:38,881 --> 01:51:41,648
So, on this slide, you can see that we have

01:51:41,648 --> 01:51:43,565
a an uneven allocation.

01:51:45,477 --> 01:51:48,344
We've been able to successfully assign

01:51:48,344 --> 01:51:51,053
the all of the required BARs in this case,

01:51:51,053 --> 01:51:53,446
these are assuming this is NVMe.

01:51:53,446 --> 01:51:57,519
So, we've been able to assign all these non pre fetch able

01:51:57,519 --> 01:52:01,128
resources, but we have an uneven assignment

01:52:01,128 --> 01:52:03,464
for the pre fetch able resources,

01:52:03,464 --> 01:52:05,037
which means that four of these devices

01:52:05,037 --> 01:52:07,679
could potentially be using CMB or PMR

01:52:07,679 --> 01:52:09,716
and four of the devices could not be,

01:52:09,716 --> 01:52:12,984
this makes kind of an odd user experience

01:52:12,984 --> 01:52:17,734
for users, especially when we're, if the peer to peer DMA

01:52:19,692 --> 01:52:22,641
work gets developed more in the future.

01:52:22,641 --> 01:52:25,495
It's gonna show some weird latencies

01:52:25,495 --> 01:52:28,238
between siblings. - How does it even work?

01:52:28,238 --> 01:52:33,238
I mean, you cannot on PCI disable individual paths.

01:52:33,284 --> 01:52:35,163
So if a BAR has not been assigned,

01:52:35,163 --> 01:52:38,095
in theory, you must not enable the entire device

01:52:38,095 --> 01:52:40,000
because device actually assigned

01:52:40,000 --> 01:52:42,702
to something you don't want.

01:52:42,702 --> 01:52:45,417
In practice, you make it to sign on top of RAM.

01:52:45,417 --> 01:52:47,358
And so it's never gonna be reached.

01:52:47,358 --> 01:52:50,437
But it's still not correct.

01:52:50,437 --> 01:52:54,195
- So that's kind of where I was going with this, so.

01:52:54,195 --> 01:52:57,862
So you don't, especially with the NVMe case,

01:52:58,933 --> 01:53:01,521
you don't necessarily need these optional BARs.

01:53:01,521 --> 01:53:04,139
If we can assign them to where they can be reached,

01:53:04,139 --> 01:53:06,239
then there is no problem.

01:53:06,239 --> 01:53:07,825
Or is there a problem?

01:53:07,825 --> 01:53:11,706
As long as we can get to this NVMe register set on BAR zero

01:53:11,706 --> 01:53:15,283
then we can successfully use the NVMe BAR.

01:53:15,283 --> 01:53:18,533
The optional BAR just doesn't get used.

01:53:20,121 --> 01:53:23,704
- That presume that we have an accepted way

01:53:25,713 --> 01:53:28,761
of leaving an unassigned BAR into a region

01:53:28,761 --> 01:53:32,042
that is not mapped into the (mumbles) bridge.

01:53:32,042 --> 01:53:33,344
- That's correct. - Which we may

01:53:33,344 --> 01:53:36,195
or may not have because we could have cases where,

01:53:36,195 --> 01:53:37,663
I mean, we don't know that for sure, right.

01:53:37,663 --> 01:53:40,215
We could have a gigantic BAR that goes beyond

01:53:40,215 --> 01:53:42,659
the size of system RAM and behind the switch

01:53:42,659 --> 01:53:45,204
and that switch is open to everything else.

01:53:45,204 --> 01:53:46,037
I don't know.

01:53:46,037 --> 01:53:49,413
We have no guarantee that we can even do that.

01:53:49,413 --> 01:53:51,725
In short of having a device that support re sizable BARs,

01:53:51,725 --> 01:53:54,725
which nobody does, as far as I know.

01:53:57,286 --> 01:54:01,072
This, we, I mean, we can look at trying to do it.

01:54:01,072 --> 01:54:02,823
But it's there are gonna be some interesting heuristics

01:54:02,823 --> 01:54:05,535
in the code, which I'm not particularly fond of.

01:54:05,535 --> 01:54:07,331
- So, the main reason I wanna talk about this

01:54:07,331 --> 01:54:09,972
is because the persistent memory region

01:54:09,972 --> 01:54:13,305
is an MMIO space of non volatile memory.

01:54:14,802 --> 01:54:16,410
Non volatile by accessible memory

01:54:16,410 --> 01:54:20,330
is becoming really affordable and we expect

01:54:20,330 --> 01:54:23,721
to see larger devices with these regions.

01:54:23,721 --> 01:54:25,956
So, - You, are you in control

01:54:25,956 --> 01:54:27,072
of the actual devices?

01:54:27,072 --> 01:54:28,197
Are you designing them yourselves?

01:54:28,197 --> 01:54:29,435
Or. - No.

01:54:29,435 --> 01:54:30,854
- No? Yes?

01:54:30,854 --> 01:54:31,978
- No. - No, you purchased it.

01:54:31,978 --> 01:54:34,370
You are, you're buying somebody else PCI device

01:54:34,370 --> 01:54:37,037
and putting it into your system.

01:54:38,604 --> 01:54:41,147
Well I'm just saying because there is a way

01:54:41,147 --> 01:54:43,071
to try to solve that problem that has been used

01:54:43,071 --> 01:54:46,452
by, I believe, at least AMD, which is to have the BAR

01:54:46,452 --> 01:54:48,751
initially come up with a small size.

01:54:48,751 --> 01:54:52,251
And then have the driver call a kernel API

01:54:53,410 --> 01:54:56,138
that exists today to resize it.

01:54:56,138 --> 01:54:57,787
- [John] They talk about re sizable BARs.

01:54:57,787 --> 01:55:01,255
- No, not the PCI re sizable BAR stuff.

01:55:01,255 --> 01:55:03,744
I think there is basically, I don't think they use that.

01:55:03,744 --> 01:55:04,817
But basically. - They did.

01:55:04,817 --> 01:55:05,963
- Oh they did in the newer stuff?

01:55:05,963 --> 01:55:07,217
- Yes. - Okay.

01:55:07,217 --> 01:55:09,118
- Because a some point, I remember some devices

01:55:09,118 --> 01:55:11,131
that basically did the hardware.

01:55:11,131 --> 01:55:14,884
So they, it comes up as a normal BAR for small size.

01:55:14,884 --> 01:55:18,060
And then the driver does something to the device

01:55:18,060 --> 01:55:20,725
that changes the BAR sizing and then

01:55:20,725 --> 01:55:22,906
recall the resource allocation routines.

01:55:22,906 --> 01:55:25,063
- Yeah, they're using the standard PCI resizing

01:55:25,063 --> 01:55:26,038
(soft speaking)

01:55:26,038 --> 01:55:28,497
- Okay. - Oh, sorry, I was saying

01:55:28,497 --> 01:55:30,912
the AMD cards do use the standard

01:55:30,912 --> 01:55:33,302
PCI re sizable BAR these days.

01:55:33,302 --> 01:55:34,135
- Okay.

01:55:35,392 --> 01:55:38,633
That's technically the way to solve that.

01:55:38,633 --> 01:55:41,515
It doesn't, provided we handle it proper in Linux,

01:55:41,515 --> 01:55:42,849
which is a whole other cattle of fish

01:55:42,849 --> 01:55:45,121
and then we haven't even thrown hot plug range

01:55:45,121 --> 01:55:48,371
into your beautiful picture over there.

01:55:50,496 --> 01:55:51,329
But

01:55:53,008 --> 01:55:55,466
- Yeah, so to your point, the main problem

01:55:55,466 --> 01:55:56,930
with the end point is that there's no way

01:55:56,930 --> 01:56:00,054
to say, my end point is this size.

01:56:00,054 --> 01:56:02,157
I would like to to be this size.

01:56:02,157 --> 01:56:06,218
That where I'd like to consider this limiting it

01:56:06,218 --> 01:56:10,672
at the bridge upstream at the end point instead.

01:56:10,672 --> 01:56:13,042
So, instead we have a morpher allocation.

01:56:13,042 --> 01:56:15,203
We've been able to limit it at the bridge

01:56:15,203 --> 01:56:18,244
because you can specify the limits inside the bridge.

01:56:18,244 --> 01:56:19,862
- [Ben] But not per device.

01:56:19,862 --> 01:56:20,695
- Whats that?

01:56:20,695 --> 01:56:21,579
- Not per device.

01:56:21,579 --> 01:56:25,637
I mean, how can you change the size of a BAR on a device?

01:56:25,637 --> 01:56:26,904
- You don't change the size of the BAR.

01:56:26,904 --> 01:56:29,719
You can see in this example that we have pre fetch able

01:56:29,719 --> 01:56:32,306
16 still, but we've limited the address range.

01:56:32,306 --> 01:56:35,291
- Oh, DSPs are bridges. - And the main

01:56:35,291 --> 01:56:36,425
- Sorry, yes. - The main reason,

01:56:36,425 --> 01:56:39,019
so a little more background, NVMe,

01:56:39,019 --> 01:56:41,223
the way we have the CMV set up right now

01:56:41,223 --> 01:56:44,679
is with just a peer just a generic allocator.

01:56:44,679 --> 01:56:47,305
So, if we can limit it that allocator pool

01:56:47,305 --> 01:56:50,458
to that eight megabytes in this example.

01:56:50,458 --> 01:56:52,187
Then we never hit that average stage.

01:56:52,187 --> 01:56:53,426
- So, this is okay,

01:56:53,426 --> 01:56:56,075
so this is, so I completely missed the fact

01:56:56,075 --> 01:56:59,584
that your DSP things were bridges.

01:56:59,584 --> 01:57:03,552
So they are basically the downstream ports of the switch.

01:57:03,552 --> 01:57:04,385
- That's correct.

01:57:04,385 --> 01:57:07,590
- Okay, that makes more sense.

01:57:07,590 --> 01:57:11,673
So, yeah, in your specific case, your hack works.

01:57:12,570 --> 01:57:16,667
The problem, of course, is it's only work

01:57:16,667 --> 01:57:20,501
as long as it's a single end point you have.

01:57:20,501 --> 01:57:24,585
You have multiple functions or SIOV or any other things

01:57:24,585 --> 01:57:26,205
that happen, these days, it's gonna stop working,

01:57:26,205 --> 01:57:29,926
so, do you have, or probably, your next slide.

01:57:29,926 --> 01:57:33,593
Do you have some thought about how to enable

01:57:34,869 --> 01:57:38,952
such a mechanism that will not cause other things

01:57:40,090 --> 01:57:42,339
to break horribly?

01:57:42,339 --> 01:57:43,315
- I haven't thought about that.

01:57:43,315 --> 01:57:45,578
But there is a concern.

01:57:45,578 --> 01:57:46,718
I think you were getting to this point.

01:57:46,718 --> 01:57:51,218
So, there's a concern address space violation aliasing

01:57:52,521 --> 01:57:54,564
if one device aliases into the next.

01:57:54,564 --> 01:57:56,642
I think that's kind of what you were getting at?

01:57:56,642 --> 01:57:58,375
- Well, yeah, because those devices are effectively

01:57:58,375 --> 01:58:01,215
going to be decoding to each domain.

01:58:01,215 --> 01:58:04,845
And so if you have more than one below that bridge,

01:58:04,845 --> 01:58:06,731
how do you arrange them in a way?

01:58:06,731 --> 01:58:10,429
I mean, you basically won't be able to do it

01:58:10,429 --> 01:58:13,478
because of the natural line,

01:58:13,478 --> 01:58:15,384
oh, the windows are not aligned.

01:58:15,384 --> 01:58:17,591
Yeah, you must still be able to play funny games

01:58:17,591 --> 01:58:21,412
but it's the, resulting assignment algorithm

01:58:21,412 --> 01:58:24,085
become unmanageable itself.

01:58:24,085 --> 01:58:26,222
The catastrophe that are existing

01:58:26,222 --> 01:58:29,029
resource allocation algorithm.

01:58:29,029 --> 01:58:32,362
We're gonna talk about that a bit later.

01:58:33,853 --> 01:58:36,492
- Sorry, I missed how this actually solved the problem.

01:58:36,492 --> 01:58:40,742
How does PCI when enumerating this bridge recognize

01:58:42,622 --> 01:58:45,158
that there's eight megs on the downstream port

01:58:45,158 --> 01:58:47,563
and therefore, it can assign a 16 meg?

01:58:47,563 --> 01:58:49,480
- Well, it's, it hacks.

01:58:51,270 --> 01:58:54,007
- So, right now we go all the way down

01:58:54,007 --> 01:58:56,435
and we calculate how much memory we need

01:58:56,435 --> 01:58:58,030
and all the end points and then we comeback up

01:58:58,030 --> 01:59:01,493
and we assign everything based on that,

01:59:01,493 --> 01:59:05,493
so instead, we would collect all of the resource

01:59:06,452 --> 01:59:09,033
requirements on every single end point.

01:59:09,033 --> 01:59:11,469
We would distribute it fairly.

01:59:11,469 --> 01:59:14,051
And fairly is policy.

01:59:14,051 --> 01:59:17,213
So, fairly to all of the DSPs and that would be

01:59:17,213 --> 01:59:19,439
our limits to each of the end points.

01:59:19,439 --> 01:59:21,209
- [Alex] But how does PCI know that this works

01:59:21,209 --> 01:59:23,574
for any given device?

01:59:23,574 --> 01:59:24,500
- It doesn't today.

01:59:24,500 --> 01:59:26,333
- No, so this would be

01:59:28,183 --> 01:59:30,946
this would be part of the whether or not

01:59:30,946 --> 01:59:34,622
the device could be have optional BARs or not.

01:59:34,622 --> 01:59:37,580
- So, there is a bunch of things like this.

01:59:37,580 --> 01:59:42,459
Again, it's one of those kind of worms we should open

01:59:42,459 --> 01:59:47,307
when I say for everyone, so I'll try to be brief if I can.

01:59:47,307 --> 01:59:52,225
This hot plug, a whole bunch of other things like this

01:59:52,225 --> 01:59:53,940
bring a couple of problems that we have

01:59:53,940 --> 01:59:57,001
that are completely structured to the way we do PCI.

01:59:57,001 --> 01:59:59,199
One is that the actual assignment is before

01:59:59,199 --> 02:00:01,531
we even talk to the driver.

02:00:01,531 --> 02:00:04,370
We don't have any way to driver coordinate before things

02:00:04,370 --> 02:00:05,453
get assigned.

02:00:07,566 --> 02:00:09,592
But then hot plug gets another range.

02:00:09,592 --> 02:00:10,920
We don't have a way at run time

02:00:10,920 --> 02:00:12,155
that the drivers, sorry guys,

02:00:12,155 --> 02:00:15,852
I'm gonna have to erase on everything, get all four bits,

02:00:15,852 --> 02:00:18,019
which barely, Windows has.

02:00:19,240 --> 02:00:20,747
- [5th Participant] Stuff in progress.

02:00:20,747 --> 02:00:21,799
- Okay.

02:00:21,799 --> 02:00:23,045
I haven't seen that.

02:00:23,045 --> 02:00:25,253
Because we want to be able, especially with Thunderbolt,

02:00:25,253 --> 02:00:29,503
so Thunderbolt is the elephant in the crystal shop.

02:00:31,388 --> 02:00:34,627
People are coming your system that has

02:00:34,627 --> 02:00:39,627
16 meg hot plug window on your bridge and brig a 2 gig GPU

02:00:40,098 --> 02:00:43,944
behind five bridges plus two XHDIs and God knows what else

02:00:43,944 --> 02:00:47,461
and then try to (mumbles) another one.

02:00:47,461 --> 02:00:49,459
And is no way your boot time allocation

02:00:49,459 --> 02:00:51,649
will be able to fit in all that.

02:00:51,649 --> 02:00:55,196
And so, we have tricks to try to allocate

02:00:55,196 --> 02:00:57,739
within the context of things that have not

02:00:57,739 --> 02:00:59,457
had any allocation before.

02:00:59,457 --> 02:01:01,253
But you get which thing that you boot with the device

02:01:01,253 --> 02:01:02,945
plugged in, you're gonna get something different.

02:01:02,945 --> 02:01:05,322
And if you put with other device plugged in

02:01:05,322 --> 02:01:06,822
and then - FBP help

02:01:08,137 --> 02:01:09,387
- FPB? - Bridge.

02:01:11,601 --> 02:01:13,300
- No that's yet a new invention by Intel

02:01:13,300 --> 02:01:17,171
that I don't know that, or something else.

02:01:17,171 --> 02:01:18,110
- [Alex] Could you pass the mic?

02:01:18,110 --> 02:01:21,843
- Yeah, but the PCI standard grow about 12 minute,

02:01:21,843 --> 02:01:24,762
none of them are implemented by anybody.

02:01:24,762 --> 02:01:26,418
And it's impossible to follow.

02:01:26,418 --> 02:01:27,835
So, I don't know.

02:01:29,527 --> 02:01:30,740
I don't know.

02:01:30,740 --> 02:01:34,113
We, there's even more basic things like this.

02:01:34,113 --> 02:01:37,587
For example, you mentioned non pre fetch able, right?

02:01:37,587 --> 02:01:40,112
You're lucky you're that small.

02:01:40,112 --> 02:01:42,414
There are other ways, especially with SROV.

02:01:42,414 --> 02:01:45,550
And conveniently, PCI never thought

02:01:45,550 --> 02:01:50,550
to put a 64-bit non pre fetch able window in the bridges.

02:01:50,821 --> 02:01:53,507
Now, PC Express has this interesting little blurb

02:01:53,507 --> 02:01:55,613
in the spec that says actually you can put

02:01:55,613 --> 02:01:59,790
non pre fetch able BARs into bride pre fetch able

02:01:59,790 --> 02:02:00,623
windows.

02:02:01,828 --> 02:02:03,823
Which could be the only way to deal with that

02:02:03,823 --> 02:02:05,536
some case, but Linux is far from being able

02:02:05,536 --> 02:02:06,824
to explore that, as far as I know

02:02:06,824 --> 02:02:07,931
unless there's something I don't know about

02:02:07,931 --> 02:02:09,598
happening somewhere.

02:02:11,196 --> 02:02:13,446
But yeah, it's it's a mess.

02:02:17,609 --> 02:02:19,276
But it brings - Yeah.

02:02:20,613 --> 02:02:22,644
So do you, are you proposing some kind of quirk

02:02:22,644 --> 02:02:26,636
mechanism for a bender device ID saying

02:02:26,636 --> 02:02:28,213
these BARs are - Yes, I kind of am.

02:02:28,213 --> 02:02:30,829
So, I mean, you could do something like

02:02:30,829 --> 02:02:32,953
look up in a in the driver itself

02:02:32,953 --> 02:02:34,794
but the driver hasn't bound at that time

02:02:34,794 --> 02:02:36,545
so, it would be something probably appropriate

02:02:36,545 --> 02:02:39,123
for the PCI layer you would have a class code.

02:02:39,123 --> 02:02:43,011
The NVMe, for example, would have an optional BAR.

02:02:43,011 --> 02:02:46,317
It would say the optional BAR in the minimum size.

02:02:46,317 --> 02:02:49,260
But other devices, I'm not sure.

02:02:49,260 --> 02:02:51,758
- Yeah, you could easily, I mean, in this case,

02:02:51,758 --> 02:02:52,669
you've got BARs that are optional

02:02:52,669 --> 02:02:54,421
and you can run all these devices without them

02:02:54,421 --> 02:02:56,396
but you can easily imagine different cases

02:02:56,396 --> 02:02:58,488
where devices will not work if they don't get

02:02:58,488 --> 02:03:00,156
what they require so - Exactly.

02:03:00,156 --> 02:03:01,974
- You need the exact opposite, so.

02:03:01,974 --> 02:03:03,700
- Ideally, in the grand scheme of things,

02:03:03,700 --> 02:03:06,528
you will want to flag in a original flags that tell you

02:03:06,528 --> 02:03:08,494
whether the thing is optional.

02:03:08,494 --> 02:03:09,607
It might even more than that.

02:03:09,607 --> 02:03:10,440
Is it optional?

02:03:10,440 --> 02:03:13,139
Is it optional at any size?

02:03:13,139 --> 02:03:14,618
Or is it a binary thing?

02:03:14,618 --> 02:03:17,634
And a problem of is you have no communication

02:03:17,634 --> 02:03:21,213
with the driver to be able to establish that.

02:03:21,213 --> 02:03:24,134
Short of having quirks and

02:03:24,134 --> 02:03:25,443
I've been trying to think of ways

02:03:25,443 --> 02:03:28,766
where we could talk to drivers

02:03:28,766 --> 02:03:30,443
before they get to formally bind

02:03:30,443 --> 02:03:32,591
and that's never gonna work.

02:03:32,591 --> 02:03:34,560
And then I tried to figure out whether we could find

02:03:34,560 --> 02:03:38,396
where we would delay the resource allocation

02:03:38,396 --> 02:03:40,321
to drive after all drivers that bound

02:03:40,321 --> 02:03:43,663
on a given segment, but there is so much existing code

02:03:43,663 --> 02:03:45,896
that makes assumption that this is not the case

02:03:45,896 --> 02:03:49,146
that, short of having some kind of flag

02:03:50,938 --> 02:03:53,897
in the struct PCI driver that says this driver can't do that

02:03:53,897 --> 02:03:56,497
and do it only if every driver for everything

02:03:56,497 --> 02:03:58,747
on that bus has a flag set.

02:04:00,701 --> 02:04:03,873
It's, it's difficult but I need to learn a bit more

02:04:03,873 --> 02:04:06,024
about what you mentioned the idea of telling driver

02:04:06,024 --> 02:04:07,564
that we're gonna re allocate everything.

02:04:07,564 --> 02:04:11,397
That's gonna be useful if we can make it work.

02:04:15,140 --> 02:04:19,219
So, in your case, you could we could do a quirk.

02:04:19,219 --> 02:04:22,721
It's nasty because it's completely device specific.

02:04:22,721 --> 02:04:23,683
And it's in the core kernel.

02:04:23,683 --> 02:04:26,516
It's ugly but it's sort of doable.

02:04:30,180 --> 02:04:33,327
But then we would have to put the infrastructure

02:04:33,327 --> 02:04:36,411
allocator to understand the meaning of that quirk,

02:04:36,411 --> 02:04:38,201
deal with it.

02:04:38,201 --> 02:04:39,792
Are you keen in making that allocator

02:04:39,792 --> 02:04:43,726
even more competitive than it already is?

02:04:43,726 --> 02:04:45,525
(laughing)

02:04:45,525 --> 02:04:50,272
Well, this overlaps a lot with my slots later on

02:04:50,272 --> 02:04:51,728
with resource allocator.

02:04:51,728 --> 02:04:52,998
And it's open all sort of questions.

02:04:52,998 --> 02:04:55,537
And we should have, should we have some kind

02:04:55,537 --> 02:04:58,949
of more transaction allocator ways of create a whole view

02:04:58,949 --> 02:05:00,942
of the what we want to create and only comment it

02:05:00,942 --> 02:05:03,355
if we decide it's better than the one we had before.

02:05:03,355 --> 02:05:06,795
And we can potentially run through different algorithms.

02:05:06,795 --> 02:05:09,483
Until and have some form of formal metrics

02:05:09,483 --> 02:05:12,959
to decide what is, what better means

02:05:12,959 --> 02:05:14,973
and can we even create those?

02:05:14,973 --> 02:05:16,622
- [John] The solution of all solutions, yeah.

02:05:16,622 --> 02:05:18,354
- It's yeah, okay.

02:05:18,354 --> 02:05:20,395
- So, I have another reason for the mandatory

02:05:20,395 --> 02:05:23,904
and optional BARs and I'll show you another use case.

02:05:23,904 --> 02:05:26,899
So, this was a use case that I ran into.

02:05:26,899 --> 02:05:30,832
I had a report with non pre fetch able 64 megabytes.

02:05:30,832 --> 02:05:33,199
And pre fetch able was less than one megabyte

02:05:33,199 --> 02:05:35,654
and that's because it contained MSIX.

02:05:35,654 --> 02:05:39,517
So, there was no, there was no pre fetch able space

02:05:39,517 --> 02:05:41,184
for subordinate bus.

02:05:42,973 --> 02:05:46,547
The max first resource assignment code

02:05:46,547 --> 02:05:49,283
assigned the pre fetch able BAR first

02:05:49,283 --> 02:05:52,020
on that (coughing) and then the non pre fetch able

02:05:52,020 --> 02:05:53,426
was completely disabled.

02:05:53,426 --> 02:05:55,531
So, this device was effectively useless

02:05:55,531 --> 02:05:58,722
even though the NVMe driver bound to it.

02:05:58,722 --> 02:06:03,002
And that's the piece of code that says we can do this.

02:06:03,002 --> 02:06:06,293
So, if we had this mandatory and optional BARs

02:06:06,293 --> 02:06:08,798
and something like this wouldn't happen.

02:06:08,798 --> 02:06:11,688
- PCI enabled resources should have failed, or no?

02:06:11,688 --> 02:06:13,605
The driver should have failed at probe time, no?

02:06:13,605 --> 02:06:14,954
- I did not see that, no.

02:06:14,954 --> 02:06:17,379
- Oh, I thought we were checking that we had

02:06:17,379 --> 02:06:20,046
correct allocation on every BAR,

02:06:20,938 --> 02:06:24,397
mind you we don't have IOMMU on IO space at least

02:06:24,397 --> 02:06:29,397
or the way to (mumbling) on Power but, we might have,

02:06:30,483 --> 02:06:33,008
- So, it probably did fail because it would have

02:06:33,008 --> 02:06:34,925
tried to read BAR zero.

02:06:36,225 --> 02:06:39,350
But still it's, if it fails, then

02:06:39,350 --> 02:06:41,644
when it could have succeeded,

02:06:41,644 --> 02:06:44,311
then that's kind of undesirable.

02:06:45,629 --> 02:06:49,796
- It's undesirable to do it at that point in time.

02:06:50,884 --> 02:06:52,935
I agree. - No, I agree.

02:06:52,935 --> 02:06:56,685
So a second pass might be a second allocator.

02:06:57,668 --> 02:07:00,393
- But that bring back the, Shim and I,

02:07:00,393 --> 02:07:01,226
should we do the opposite one

02:07:01,226 --> 02:07:03,548
where we technically could on PCI Express

02:07:03,548 --> 02:07:06,566
put the non pre fetch able one into the pre fetch able

02:07:06,566 --> 02:07:10,188
window because in practice usually the pre fetch able ones

02:07:10,188 --> 02:07:12,157
are the big ones and non pre fetch able one

02:07:12,157 --> 02:07:13,740
are the small ones.

02:07:14,602 --> 02:07:15,435
So, yeah.

02:07:18,920 --> 02:07:23,112
The difficulty when you touch anything in that code,

02:07:23,112 --> 02:07:25,078
is you can be pretty sure you're

02:07:25,078 --> 02:07:26,542
gonna break something somewhere.

02:07:26,542 --> 02:07:30,149
Some obscure x86 machine happens to work

02:07:30,149 --> 02:07:33,492
despite some hidden devices we don't know about.

02:07:33,492 --> 02:07:35,124
But we change something in that algorithm.

02:07:35,124 --> 02:07:37,154
Suddenly we start overlapping those hidden devices

02:07:37,154 --> 02:07:37,987
and boom!

02:07:41,396 --> 02:07:43,729
So, you need lot of testing.

02:07:44,593 --> 02:07:48,339
But yeah, I think it makes sense, Bjorn,

02:07:48,339 --> 02:07:52,839
to delay the attempt at allocating pre fetch able BARs

02:07:54,691 --> 02:07:57,244
into non pre fetch able window until after

02:07:57,244 --> 02:07:59,217
we have handled the non pre fetch able BAR

02:07:59,217 --> 02:08:02,059
into the non pre fetch able windows.

02:08:02,059 --> 02:08:04,952
Fundamentally, the reason we didn't care is that in theory,

02:08:04,952 --> 02:08:06,428
unless you have assigned all the BAR for device,

02:08:06,428 --> 02:08:08,845
you cannot use that device.

02:08:08,845 --> 02:08:11,678
We have that assumption in theory.

02:08:12,596 --> 02:08:16,342
We might have bugs in a code that's supposed to enforce it.

02:08:16,342 --> 02:08:18,691
So, I think the first thing you need to do

02:08:18,691 --> 02:08:20,315
and I don't disagree with it,

02:08:20,315 --> 02:08:24,315
is have that concept that BAR we couldn't assign

02:08:25,385 --> 02:08:28,516
can be left in a place where it's harmless.

02:08:28,516 --> 02:08:32,093
Which mean outside of the reach of its parent bridge.

02:08:32,093 --> 02:08:35,676
And we need to be able to not only do that.

02:08:36,557 --> 02:08:38,542
Then verify that we could and if we can't,

02:08:38,542 --> 02:08:41,502
we have to refuse enabling the device.

02:08:41,502 --> 02:08:43,472
And it needs to work even in context

02:08:43,472 --> 02:08:45,688
where we might do games of resizing bridges

02:08:45,688 --> 02:08:47,185
and things like this in the future.

02:08:47,185 --> 02:08:49,699
And so we need some flags to mark these things

02:08:49,699 --> 02:08:52,616
need to be and stay out of the way.

02:08:57,532 --> 02:08:59,559
If we have that and we agree on that,

02:08:59,559 --> 02:09:02,497
then yes, as a second step, having this idea

02:09:02,497 --> 02:09:06,195
that the shuffling that code to favor

02:09:06,195 --> 02:09:08,700
some BARs versus others on the ground

02:09:08,700 --> 02:09:12,117
that we can survive if those aren't under

02:09:13,802 --> 02:09:17,136
some circumstances, yeah, maybe, why not?

02:09:17,136 --> 02:09:20,636
Another aspect to that of that problem is,

02:09:24,360 --> 02:09:26,895
I think, we assign by category regardless

02:09:26,895 --> 02:09:27,728
of the device, right?

02:09:27,728 --> 02:09:30,978
We assign all of the non pre fetch able

02:09:32,198 --> 02:09:35,387
of all the devices and got through all the

02:09:35,387 --> 02:09:38,637
non pre fetch able and so, the ordering

02:09:41,923 --> 02:09:44,102
had this idea that some device

02:09:44,102 --> 02:09:45,892
that we don't have the concept that some device

02:09:45,892 --> 02:09:47,809
are more required than others.

02:09:47,809 --> 02:09:49,152
And that's also a problem.

02:09:49,152 --> 02:09:51,175
We have system devices that must be assigned

02:09:51,175 --> 02:09:53,342
or nothing will work while

02:09:55,137 --> 02:09:56,885
while your Thunderbolt adapter, if it doesn't work,

02:09:56,885 --> 02:09:57,718
it doesn't work.

02:09:57,718 --> 02:10:01,212
But that, no, at least you can boot your machine.

02:10:01,212 --> 02:10:05,295
So, this is another part of that same discussion.

02:10:06,197 --> 02:10:10,343
- I don't know, John, if you, I don't know,

02:10:10,343 --> 02:10:12,734
what's the way forward to boot something

02:10:12,734 --> 02:10:15,600
while you keep it as NVMe solution

02:10:15,600 --> 02:10:16,517
and or the?

02:10:17,396 --> 02:10:21,239
- Well, it needs to solve those bugs in the poll first.

02:10:21,239 --> 02:10:22,757
Those are in the poll but yeah,

02:10:22,757 --> 02:10:25,090
this probably needs to exist

02:10:26,113 --> 02:10:29,360
with resource allocation rewrite.

02:10:29,360 --> 02:10:32,693
- So, just for a matter of keeping time,

02:10:34,152 --> 02:10:36,339
unless you have something you want to ask the audience,

02:10:36,339 --> 02:10:39,839
I think given that Benjamin topic is quite

02:10:41,215 --> 02:10:43,160
related to this one, maybe we can follow on

02:10:43,160 --> 02:10:46,128
and just keep discussing the resource allocation.

02:10:46,128 --> 02:10:49,132
- We probably can also use a buff as well.

02:10:49,132 --> 02:10:50,713
- Yeah, but I think they talked a little bit

02:10:50,713 --> 02:10:53,937
unless you have something else you want to ask specifically.

02:10:53,937 --> 02:10:56,160
- What's you're current workaround?

02:10:56,160 --> 02:10:58,653
I assume you have a way to get things working now?

02:10:58,653 --> 02:11:00,856
Is that something that we should look at?

02:11:00,856 --> 02:11:05,856
- There is no workaround so we've asked our firmware team

02:11:06,079 --> 02:11:09,475
our, sorry, not our firmware, our BIOS and firmware

02:11:09,475 --> 02:11:11,883
to allocate more space.

02:11:11,883 --> 02:11:14,864
And that's actually another one I wanna show you.

02:11:14,864 --> 02:11:19,804
So, that's a one where the slot's not occupied at the top.

02:11:19,804 --> 02:11:23,897
The BIOS didn't leave us enough room for anything basically

02:11:23,897 --> 02:11:27,760
because there was a management handle in the upstream port.

02:11:27,760 --> 02:11:31,531
So, we've asked our firmware teams to work

02:11:31,531 --> 02:11:33,383
with a lot of these things.

02:11:33,383 --> 02:11:37,383
But we can't trust any vendor platform BIOS, so.

02:11:39,395 --> 02:11:42,895
That's why we have PCI equals realloc, so.

02:11:43,878 --> 02:11:44,711
Okay.

02:11:47,366 --> 02:11:50,158
Okay. - Thanks very much.

02:11:50,158 --> 02:11:52,013
(applause)

02:11:52,013 --> 02:11:55,096
(microphone buzzing)

02:12:03,370 --> 02:12:04,203
- Okay.

02:12:04,203 --> 02:12:08,536
So I'm gonna take it from here for reasons, reasons.

02:12:10,539 --> 02:12:11,861
I am not a - Yeah, but I

02:12:11,861 --> 02:12:14,929
will set fire to the PR people.

02:12:14,929 --> 02:12:15,762
- Well I don't have.

02:12:15,762 --> 02:12:17,023
I didn't end up making any slides.

02:12:17,023 --> 02:12:19,251
I can go up there if you want.

02:12:19,251 --> 02:12:20,535
(chuckling)

02:12:20,535 --> 02:12:22,588
- It will save me having to set fire anyway.

02:12:22,588 --> 02:12:25,838
(chatter and laughing)

02:12:44,972 --> 02:12:47,717
- Can you make sure it's Amazon Projects nine?

02:12:47,717 --> 02:12:49,159
- (faint talking) no.

02:12:49,159 --> 02:12:51,409
(laughing)

02:12:52,768 --> 02:12:53,601
- Thanks.

02:12:55,334 --> 02:12:57,360
(mumbling)

02:12:57,360 --> 02:13:00,342
(laughing)

02:13:00,342 --> 02:13:03,443
- All right, so, PCI resource allocation.

02:13:03,443 --> 02:13:08,026
We started, so we just continue on on what you started.

02:13:09,314 --> 02:13:14,073
The we have a bunch of problems to say the least

02:13:14,073 --> 02:13:17,323
and part of them relates to the way we,

02:13:22,114 --> 02:13:26,531
on one hand, try to honor what the firmware has done.

02:13:28,484 --> 02:13:33,067
And on, and may or may not decide it was correct or not

02:13:34,495 --> 02:13:38,640
and try to resign some things and then come back later

02:13:38,640 --> 02:13:42,123
and look at, oh we have hardware, we have some space left.

02:13:42,123 --> 02:13:44,114
Let's see if we can spread it and all those kind of

02:13:44,114 --> 02:13:48,926
very heuristic things to try to get things working.

02:13:48,926 --> 02:13:51,761
And then we have a whole pile of platform architectures

02:13:51,761 --> 02:13:52,948
that don't do that.

02:13:52,948 --> 02:13:55,448
And they decide to just purely

02:13:57,736 --> 02:14:00,008
reassign everything from scratch

02:14:00,008 --> 02:14:01,385
based on the idea that Linux was always,

02:14:01,385 --> 02:14:04,741
we always do better than whatever you (soft talking)

02:14:04,741 --> 02:14:07,408
it's probably a fair assumption.

02:14:08,869 --> 02:14:12,630
And then we have a platform with a bit of an in between.

02:14:12,630 --> 02:14:17,219
And some architectures have policies per bus more or less.

02:14:17,219 --> 02:14:18,052
Not clear.

02:14:19,279 --> 02:14:23,529
And and all of that, so, sorry, I might be starting

02:14:24,669 --> 02:14:26,078
in the wrong order here.

02:14:26,078 --> 02:14:29,042
The, if we want to start fixing some

02:14:29,042 --> 02:14:32,265
of those allocation problem, we need to probably,

02:14:32,265 --> 02:14:35,428
we probably want to do it in a way that is not x86 specific

02:14:37,786 --> 02:14:39,796
or ARM specific or anything.

02:14:39,796 --> 02:14:42,601
And we want to try to consolidate a little bit

02:14:42,601 --> 02:14:47,089
across the board how we are doing things on PCI

02:14:47,089 --> 02:14:48,664
when it comes to resource allocation management

02:14:48,664 --> 02:14:49,836
across all architectures.

02:14:49,836 --> 02:14:52,738
It's the first thing I wanted to look at.

02:14:52,738 --> 02:14:54,290
So I started unwinding some of the string

02:14:54,290 --> 02:14:55,620
you have been unwinding and I realized

02:14:55,620 --> 02:14:59,037
that a lot of the code is a cross between

02:15:01,534 --> 02:15:04,446
what's in the architecture code, what architecture six does

02:15:04,446 --> 02:15:08,574
with two bus claiming of existing resources that it has

02:15:08,574 --> 02:15:11,500
versus realloc and then a bunch of architectures

02:15:11,500 --> 02:15:12,417
and something completely different.

02:15:12,417 --> 02:15:15,917
ARM 64 at the moment, since the DSM patent

02:15:18,343 --> 02:15:22,219
finally, was just reallocating everything like ARM 32.

02:15:22,219 --> 02:15:27,126
Almost all unbated devices decide that whatever might

02:15:27,126 --> 02:15:29,165
have existed before is pointless and irrelevant

02:15:29,165 --> 02:15:31,663
and (mumbles) reassign everything.

02:15:31,663 --> 02:15:33,528
Most of them forget to tell the core

02:15:33,528 --> 02:15:36,147
to reassign bus numbers.

02:15:36,147 --> 02:15:38,195
It tends to work because Linux tends to be

02:15:38,195 --> 02:15:39,761
reasonably good at figuring out the ROM

02:15:39,761 --> 02:15:41,511
and resigning anyway.

02:15:42,788 --> 02:15:47,705
But there is a mess of policies and there is no consistency

02:15:51,238 --> 02:15:54,942
in how those policies are implemented.

02:15:54,942 --> 02:15:59,146
They have been some improvements in recent years

02:15:59,146 --> 02:16:01,365
in function being created in a generic code

02:16:01,365 --> 02:16:04,613
which has PCI claiming resources, I think,

02:16:04,613 --> 02:16:06,625
or something like that, bus resources,

02:16:06,625 --> 02:16:10,208
which try to consolidate some of the non 36

02:16:14,536 --> 02:16:18,286
arch, attempts at claiming existing resources

02:16:19,550 --> 02:16:21,217
set by the firmware.

02:16:22,086 --> 02:16:24,880
And then people are being calling PC allocate

02:16:24,880 --> 02:16:29,766
and allocator resources as a way to claim the rest,

02:16:29,766 --> 02:16:32,691
to assign the rest and then claim it.

02:16:32,691 --> 02:16:36,421
But most controllers in the embedded

02:16:36,421 --> 02:16:39,444
will actually don't do that and they sort of

02:16:39,444 --> 02:16:43,838
manually call lower level functions, two of them

02:16:43,838 --> 02:16:46,392
to do the bus sizing and then allocation

02:16:46,392 --> 02:16:51,392
to P bus, sizes, resources and whatever the, its friend is.

02:16:51,412 --> 02:16:53,412
So it's very very messy.

02:16:55,284 --> 02:16:58,534
The way the policies decide what to do,

02:16:59,539 --> 02:17:01,492
whether we want to re allocate everything

02:17:01,492 --> 02:17:05,159
or whether we want to honor what's there and

02:17:07,677 --> 02:17:11,421
reallocate what's missing or broken or whatever.

02:17:11,421 --> 02:17:13,641
There's actually four different actual policies

02:17:13,641 --> 02:17:17,141
that have enumerated so far in the kernel.

02:17:18,290 --> 02:17:23,290
Is decided as a side effect of how those calls are made

02:17:23,297 --> 02:17:25,686
and by whom and where at the moment.

02:17:25,686 --> 02:17:28,686
There's no clear reasoning about it.

02:17:29,828 --> 02:17:32,661
It's very hard to reason about it.

02:17:33,738 --> 02:17:36,080
In many cases, in all the new stuff,

02:17:36,080 --> 02:17:38,988
all the new device trip As to PCI controllers

02:17:38,988 --> 02:17:40,542
to all the ARM world, et cetera.

02:17:40,542 --> 02:17:43,946
It's quite nasty, this code I actually done

02:17:43,946 --> 02:17:47,027
in the PCI control driver itself.

02:17:47,027 --> 02:17:49,758
Sometime, they come in bit and they try all

02:17:49,758 --> 02:17:52,960
to use but practice only half of them do use.

02:17:52,960 --> 02:17:53,793
And so there's a lot of duplication

02:17:53,793 --> 02:17:55,988
of those three magic function calls.

02:17:55,988 --> 02:17:57,799
They may or may not honor (mumbles)

02:17:57,799 --> 02:18:00,481
which is a way to tell it to cleanse existing stuff

02:18:00,481 --> 02:18:02,398
instead of reassigning.

02:18:04,138 --> 02:18:06,571
None of them implement what you want Bjorn,

02:18:06,571 --> 02:18:11,203
which is what 36 does, which is to claim what they

02:18:11,203 --> 02:18:13,487
assign what's missing, none of them do that.

02:18:13,487 --> 02:18:15,320
None of them ever did.

02:18:16,290 --> 02:18:19,038
But more than that, the PCI controller driver

02:18:19,038 --> 02:18:21,704
is not the place for that decision.

02:18:21,704 --> 02:18:24,841
It's the policy of how resources should be managed

02:18:24,841 --> 02:18:28,571
on a given platform, should not live in the driver

02:18:28,571 --> 02:18:32,366
for the IP block that is operating as a PCI host bridge.

02:18:32,366 --> 02:18:34,117
That IP block could be user accepted tomorrow

02:18:34,117 --> 02:18:36,905
could be used while we have a CPI that attach everything.

02:18:36,905 --> 02:18:40,409
But on somewhere else, which might want to have

02:18:40,409 --> 02:18:44,186
different policy and we had that problem already on some

02:18:44,186 --> 02:18:45,747
Amazon stuff with a DSM,

02:18:45,747 --> 02:18:49,218
but that was the CPI but because ARM 64 in a CPI

02:18:49,218 --> 02:18:53,191
was doing things like 32 instead of doing things

02:18:53,191 --> 02:18:54,108
like a x86.

02:18:57,028 --> 02:19:01,695
So, I think I could pull more examples of that ROM mess.

02:19:02,832 --> 02:19:05,977
Point is I want to, I'm not pretending I'm gonna fix

02:19:05,977 --> 02:19:07,332
everything here.

02:19:07,332 --> 02:19:12,072
I'm trying and I have already about 30 or 40 patches.

02:19:12,072 --> 02:19:14,803
I need to do with another person (mumbling).

02:19:14,803 --> 02:19:17,759
To try to at least do two things.

02:19:17,759 --> 02:19:21,272
One is have a single function that everybody calls

02:19:21,272 --> 02:19:25,413
to apply the policy, to do the resource allocation

02:19:25,413 --> 02:19:28,413
according of to the selected policy.

02:19:32,393 --> 02:19:34,840
And so, and that is many ways,

02:19:34,840 --> 02:19:37,259
a way to try to get rid of all that weird code,

02:19:37,259 --> 02:19:40,586
we have an alias alpha, HPI risk, et cetera

02:19:40,586 --> 02:19:42,943
that try to use a lower level stuff by hand.

02:19:42,943 --> 02:19:44,015
The Power PC one is terrible.

02:19:44,015 --> 02:19:47,242
I wrote it because it's based on an ancient

02:19:47,242 --> 02:19:50,306
fork of x86 plus all those things

02:19:50,306 --> 02:19:51,459
and I can probably fix it.

02:19:51,459 --> 02:19:53,386
I haven't fixed it yet.

02:19:53,386 --> 02:19:56,822
And bring everybody to a single top level thing

02:19:56,822 --> 02:20:00,322
in the generate code that applies a policy

02:20:01,618 --> 02:20:04,544
in a consistent way across the architecture.

02:20:04,544 --> 02:20:07,909
Second problem is where is the policy issues made

02:20:07,909 --> 02:20:11,095
and that's something I haven't completely solved yet.

02:20:11,095 --> 02:20:12,913
We have a number of global PCI flags

02:20:12,913 --> 02:20:16,036
we can use for that, or what Power PC does today.

02:20:16,036 --> 02:20:21,023
We have PCI probably, which is more or less used for that.

02:20:21,023 --> 02:20:23,518
I've been toying with a number of options there

02:20:23,518 --> 02:20:28,018
and we can discuss that more when I come back to that.

02:20:29,987 --> 02:20:33,320
The third, not the problem, goal I have,

02:20:34,197 --> 02:20:37,142
which I haven't achieved yet because I got distracted

02:20:37,142 --> 02:20:41,919
with other things is as I moved a lot of that stuff

02:20:41,919 --> 02:20:45,017
into generate code, I had to modify a little bit

02:20:45,017 --> 02:20:47,555
some of that generate code that we don't use on x86.

02:20:47,555 --> 02:20:51,531
It's the one that was created for all of the new platforms.

02:20:51,531 --> 02:20:53,707
So, to take into account some of the subtly

02:20:53,707 --> 02:20:56,372
different requirement of some of the architecture.

02:20:56,372 --> 02:20:59,420
On not many of them, some of them are obscure

02:20:59,420 --> 02:21:03,024
and probably removed and I did remove some of

02:21:03,024 --> 02:21:05,716
the most obscure weird stuff from PA risk

02:21:05,716 --> 02:21:08,284
and Alpha and I got people to actually test that.

02:21:08,284 --> 02:21:11,201
And so far, it seems to be working.

02:21:12,453 --> 02:21:15,216
But seems like whether a BAR is likely zero,

02:21:15,216 --> 02:21:17,565
means unassigned or if it was value to value.

02:21:17,565 --> 02:21:18,565
And I created a weak helper

02:21:18,565 --> 02:21:21,917
for the architecture decide that.

02:21:21,917 --> 02:21:24,067
But the default so far, has been good enough

02:21:24,067 --> 02:21:27,069
for almost everybody, which is to decide

02:21:27,069 --> 02:21:29,238
that of (mumbles) is your policies, then yes,

02:21:29,238 --> 02:21:31,071
you have to ignore it.

02:21:32,015 --> 02:21:34,903
Otherwise, you consider it non allocated.

02:21:34,903 --> 02:21:36,430
But they ask things like this

02:21:36,430 --> 02:21:38,235
and I'm trying to bring these things

02:21:38,235 --> 02:21:41,640
and slowly message that generic code

02:21:41,640 --> 02:21:44,640
to make it closer to what a x86 does

02:21:46,024 --> 02:21:48,647
until the point where we can remove chunk of x86

02:21:48,647 --> 02:21:51,191
and make it user generated.

02:21:51,191 --> 02:21:53,522
And the reason I'm taking that approach

02:21:53,522 --> 02:21:56,355
is I'm very weary of changing x86.

02:21:57,946 --> 02:21:59,957
And changing its behavior because we have a

02:21:59,957 --> 02:22:03,483
very long history of very very strange things on x86 chips.

02:22:03,483 --> 02:22:06,066
As I said, the visible devices,

02:22:07,787 --> 02:22:10,820
we had BIOS SMM things that bluff if you start

02:22:10,820 --> 02:22:14,347
moving something around and God know what, right?

02:22:14,347 --> 02:22:19,097
And it's by far, but the reason I want to consider people

02:22:20,556 --> 02:22:22,243
around what x86 does.

02:22:22,243 --> 02:22:25,326
It is by far the most tested platform

02:22:27,821 --> 02:22:30,812
and architecture we have when it comes to PCI.

02:22:30,812 --> 02:22:34,816
And so, whenever people want to quit from,

02:22:34,816 --> 02:22:37,676
if I achieve my goal, when somebody tomorrow

02:22:37,676 --> 02:22:40,033
come up with a new BAR sizing, sharing,

02:22:40,033 --> 02:22:42,601
spreading mechanism that works for Thunderbolt

02:22:42,601 --> 02:22:45,031
and allows yo to do that, it,

02:22:45,031 --> 02:22:49,698
that thing will also work for the non x86 architectures.

02:22:51,231 --> 02:22:54,824
Today, for example, the code we have to try to spread

02:22:54,824 --> 02:22:58,112
across the values hot plug bridges, the remaining space,

02:22:58,112 --> 02:23:00,945
for example, this thing only works

02:23:02,438 --> 02:23:04,650
underneath the hot plug bridge.

02:23:04,650 --> 02:23:05,483
There is actually no reason

02:23:05,483 --> 02:23:07,645
why we couldn't do that (mumbles).

02:23:07,645 --> 02:23:09,657
That on x86, we never need that.

02:23:09,657 --> 02:23:12,408
And so the code was rich with deeply bolted assumption

02:23:12,408 --> 02:23:14,934
how the code is structured that it is operating

02:23:14,934 --> 02:23:18,101
on a sub, on a child bridge somewhere.

02:23:19,518 --> 02:23:21,808
That will be the reason where to assign with buses,

02:23:21,808 --> 02:23:24,485
especially since (mumbles) buses can be hot plugged

02:23:24,485 --> 02:23:26,735
on a bunch of x86 platform.

02:23:27,781 --> 02:23:30,264
It's also reasonable way to do your initial assignment

02:23:30,264 --> 02:23:32,308
on platform that want to resign everything

02:23:32,308 --> 02:23:34,952
and have a bunch of empty hot plug capable

02:23:34,952 --> 02:23:36,452
top level bridges.

02:23:37,350 --> 02:23:39,609
Let's spread what we have available to them.

02:23:39,609 --> 02:23:42,814
It will be a reasonable way to policy to implement.

02:23:42,814 --> 02:23:45,768
But the code architecture is incapable of doing it

02:23:45,768 --> 02:23:48,887
in ways that are not that trivial to fix

02:23:48,887 --> 02:23:50,148
because of how (mumbling)

02:23:50,148 --> 02:23:52,560
- [Eric] You, Benjamin, when you're referring to hot plug,

02:23:52,560 --> 02:23:55,357
you're referring to the automatic realloc.

02:23:55,357 --> 02:23:58,044
- No, this other one we have that tries to spread

02:23:58,044 --> 02:23:59,294
the free space.

02:24:00,239 --> 02:24:02,693
So we have something today where, if we detect

02:24:02,693 --> 02:24:05,538
that we have a bridge that have some

02:24:05,538 --> 02:24:08,691
that underneath which there is a bunch of hot plug

02:24:08,691 --> 02:24:10,966
like, so typically, a hot plug switch, right?

02:24:10,966 --> 02:24:14,665
Top level, we have a bunch of hot plugs below it.

02:24:14,665 --> 02:24:19,665
And there is a bunch of free space that is not used

02:24:19,679 --> 02:24:22,369
by any of existing window the bottom,

02:24:22,369 --> 02:24:24,180
we actually try to spread it and we basically

02:24:24,180 --> 02:24:27,448
try to expand the size of all of the hot plug bridge

02:24:27,448 --> 02:24:30,531
underneath to donate that free space.

02:24:32,386 --> 02:24:33,817
Again, it's not a (mumbles).

02:24:33,817 --> 02:24:36,970
It's not gonna deal with your two gigabyte GPU

02:24:36,970 --> 02:24:37,803
on Thunderbolt.

02:24:37,803 --> 02:24:40,978
And that will require more crazy thing that we discuss

02:24:40,978 --> 02:24:43,985
over here such as telling device to stop reassign things

02:24:43,985 --> 02:24:45,298
and all that.

02:24:45,298 --> 02:24:47,875
But it will generally increase the chances

02:24:47,875 --> 02:24:52,875
that your hot plug will work for more basic things at least.

02:24:53,152 --> 02:24:55,442
While, initially, GP drivers tend to be better at dealing

02:24:55,442 --> 02:24:57,881
with not being able to get full big BARs these days.

02:24:57,881 --> 02:25:01,271
As I said, we're starting to have a resize, which helps.

02:25:01,271 --> 02:25:02,520
In many case, because we don't actually need

02:25:02,520 --> 02:25:05,844
to access GPU BARs much for graphics.

02:25:05,844 --> 02:25:09,177
Everything is GM8 and it's not actually,

02:25:10,127 --> 02:25:12,960
not as true with compute but yeah,

02:25:14,198 --> 02:25:17,198
GPU need for giant BAR is lessening.

02:25:19,741 --> 02:25:22,741
So, yeah, so this is a big overview.

02:25:24,034 --> 02:25:27,017
The, one of the main point of contention I was having

02:25:27,017 --> 02:25:29,535
with (mumbles) from that software,

02:25:29,535 --> 02:25:33,558
something we probably would be better having a chat about,

02:25:33,558 --> 02:25:36,264
was the concept of having those different

02:25:36,264 --> 02:25:37,670
policies in the first place.

02:25:37,670 --> 02:25:41,474
You didn't like it and you wanted everybody

02:25:41,474 --> 02:25:44,814
to do like a, which is to effectively apply

02:25:44,814 --> 02:25:48,481
what's already there and unless it's broken.

02:25:49,406 --> 02:25:52,073
And the problem I have with this

02:25:53,802 --> 02:25:55,969
is is is at least twofold.

02:25:57,334 --> 02:26:02,334
One is, I am weary of changing the fundamental PC allocation

02:26:05,326 --> 02:26:09,909
strategy done by every embedded device in the next day.

02:26:11,313 --> 02:26:13,986
It's a gigantic break if you if using Twitch.

02:26:13,986 --> 02:26:16,180
We know on ARM 64, for example Lorenzo,

02:26:16,180 --> 02:26:17,769
that it does break things.

02:26:17,769 --> 02:26:22,352
- You mean, trying to honor firmware and then reassign,

02:26:23,637 --> 02:26:24,604
yeah, it would break.

02:26:24,604 --> 02:26:25,519
- Yeah.

02:26:25,519 --> 02:26:28,769
And the, and beyond response of that is

02:26:30,103 --> 02:26:33,070
and feel free to to intervene because it has

02:26:33,070 --> 02:26:34,703
to be a conversation.

02:26:34,703 --> 02:26:38,627
Your response to that was but if it's broken,

02:26:38,627 --> 02:26:41,050
we should then reassign.

02:26:41,050 --> 02:26:45,630
The question becomes, how do you define this problem?

02:26:45,630 --> 02:26:48,911
And I have not been able to come with a good definition

02:26:48,911 --> 02:26:52,295
that doesn't involve having Google AI

02:26:52,295 --> 02:26:55,024
look at you PC allocations, and mm, I don't like that one.

02:26:55,024 --> 02:26:56,123
I could do better.

02:26:56,123 --> 02:26:58,192
- Right, so here's my problem with this.

02:26:58,192 --> 02:27:02,499
I think we're saying that the only way to make these

02:27:02,499 --> 02:27:07,499
ARM embedded systems work is to throw away what we have

02:27:07,595 --> 02:27:09,334
and reallocate from scratch.

02:27:09,334 --> 02:27:13,609
- I'm not saying this is - And if we're saying that,

02:27:13,609 --> 02:27:15,844
what I think you're saying is we're depending

02:27:15,844 --> 02:27:19,093
on the current Linux allocation strategy

02:27:19,093 --> 02:27:23,048
and I don't know how we validate if we change that

02:27:23,048 --> 02:27:24,034
how do we validate?

02:27:24,034 --> 02:27:25,652
It's gonna give the same results.

02:27:25,652 --> 02:27:28,856
- The, so that's a good point.

02:27:28,856 --> 02:27:30,233
- We've always had that problem

02:27:30,233 --> 02:27:32,184
across all the embedded platforms

02:27:32,184 --> 02:27:35,133
where the boot loader is brought up one device to boot from

02:27:35,133 --> 02:27:37,052
and everything else is off the rails.

02:27:37,052 --> 02:27:39,138
We have always had that problem in Linux.

02:27:39,138 --> 02:27:40,235
And it's not - So,

02:27:40,235 --> 02:27:42,090
- Just PCI resource allocation,

02:27:42,090 --> 02:27:43,740
you change something, you kind of make sure

02:27:43,740 --> 02:27:44,618
it works for everybody.

02:27:44,618 --> 02:27:46,143
And that hard when it touches a whole bunch

02:27:46,143 --> 02:27:48,897
of different platforms but that is not a new

02:27:48,897 --> 02:27:50,036
or different issue.

02:27:50,036 --> 02:27:53,197
- It's no and fundamentally, we do hope,

02:27:53,197 --> 02:27:55,520
and I think it's a reasonable expectation,

02:27:55,520 --> 02:28:00,020
to to think that whatever resource allocation strategy

02:28:01,015 --> 02:28:04,845
on Linux is capable of creating the functional allocation

02:28:04,845 --> 02:28:06,421
from a clean slate.

02:28:06,421 --> 02:28:09,712
I think that's, it's not a far fetched requirement.

02:28:09,712 --> 02:28:12,684
We might be able to test and I'm gonna get back to that

02:28:12,684 --> 02:28:14,601
if I have time testing.

02:28:16,155 --> 02:28:18,314
- Just wanted to mention that well,

02:28:18,314 --> 02:28:21,147
trying to honor firmware resources

02:28:22,150 --> 02:28:24,633
when in better platforms, I mean,

02:28:24,633 --> 02:28:27,627
the problem was that for instance, some bridges

02:28:27,627 --> 02:28:30,383
may be under allocated. - Yeah yeah yeah, oh.

02:28:30,383 --> 02:28:33,272
- So, it's not exactly the question you ask.

02:28:33,272 --> 02:28:35,117
- So, it's an ARM - It's not necessarily

02:28:35,117 --> 02:28:37,668
broken, but it problem is it triggers regression.

02:28:37,668 --> 02:28:38,999
So, - Yes, there is a whole

02:28:38,999 --> 02:28:41,788
an arm length of reason why it is broken.

02:28:41,788 --> 02:28:43,293
- This is also something you can come up

02:28:43,293 --> 02:28:45,032
with the tests with for, right?

02:28:45,032 --> 02:28:47,194
You can do test cases for the resource allocation

02:28:47,194 --> 02:28:48,470
without actually having - I wasn't going to

02:28:48,470 --> 02:28:51,220
- To have the boards. - get there.

02:28:52,230 --> 02:28:56,179
One of the things that I have not have a chance to work on

02:28:56,179 --> 02:28:58,903
and I want to finish what I'm doing first,

02:28:58,903 --> 02:29:01,124
which is configuration across architectures.

02:29:01,124 --> 02:29:04,176
And I want your agreement, Dion, that you will let me

02:29:04,176 --> 02:29:06,484
keep that concept of policy because this is what

02:29:06,484 --> 02:29:10,837
we do today and I don't want to change that as well.

02:29:10,837 --> 02:29:12,700
We have different policies simply

02:29:12,700 --> 02:29:14,895
by calling different functions.

02:29:14,895 --> 02:29:19,300
I want to have much, but, those things in common.

02:29:19,300 --> 02:29:21,266
- Well, the thing I don't like about reassign

02:29:21,266 --> 02:29:23,509
all those, I don't think it's - [Ben] But we do it today.

02:29:23,509 --> 02:29:26,093
This is how everything works except x86 today.

02:29:26,093 --> 02:29:30,251
- I know, but it's there's no semantics.

02:29:30,251 --> 02:29:31,084
- [Ben] What do you mean?

02:29:31,084 --> 02:29:33,744
- You're not telling us anything about how we

02:29:33,744 --> 02:29:36,400
ought to do the reallocation.

02:29:36,400 --> 02:29:37,880
- Well, I mean, most of the time, your buyers

02:29:37,880 --> 02:29:39,934
doesn't know any better.

02:29:39,934 --> 02:29:44,453
Uboot code is a dumber version of Linux code, right?

02:29:44,453 --> 02:29:47,504
It doesn't even try to deal with leaving space for hot plug

02:29:47,504 --> 02:29:49,263
or anything like that.

02:29:49,263 --> 02:29:51,100
The point is, we're talking about platforms

02:29:51,100 --> 02:29:55,399
where you don't have that information anywhere.

02:29:55,399 --> 02:29:57,584
We could and I'm, we can think about

02:29:57,584 --> 02:29:59,625
where to improve things on top of that.

02:29:59,625 --> 02:30:02,949
There's many things we could improve

02:30:02,949 --> 02:30:04,265
if it becomes necessary.

02:30:04,265 --> 02:30:06,338
Could, as a device tell you that prefer allocation

02:30:06,338 --> 02:30:07,426
for that bridge is that much

02:30:07,426 --> 02:30:09,400
and we could honor that, for example.

02:30:09,400 --> 02:30:10,913
There's all sorts of things we could do.

02:30:10,913 --> 02:30:13,996
But my point is I want to consolidate

02:30:15,497 --> 02:30:19,664
what is at the moment, rat nest of different stuff

02:30:20,990 --> 02:30:24,395
done across architectures, control drivers et cetera,

02:30:24,395 --> 02:30:27,199
all over the place, which all boil down to fundamentally

02:30:27,199 --> 02:30:30,723
applying for three or four different policies

02:30:30,723 --> 02:30:32,503
and I can break that down into a single function

02:30:32,503 --> 02:30:34,109
that picks up all these things.

02:30:34,109 --> 02:30:35,785
There is a question of how would be the policy

02:30:35,785 --> 02:30:39,343
and there's a couple of fiddly bits there.

02:30:39,343 --> 02:30:41,042
And apply it.

02:30:41,042 --> 02:30:43,179
And it's actually a pretty nice piece of code,

02:30:43,179 --> 02:30:46,801
in a sense that it's really clear when you look at this.

02:30:46,801 --> 02:30:49,708
This is what happens, this is a flow of initializing PCI.

02:30:49,708 --> 02:30:51,008
It's driven by policies.

02:30:51,008 --> 02:30:53,906
They're gonna be about two, three, maybe four again.

02:30:53,906 --> 02:30:55,931
There's an issue of how we interpret that,

02:30:55,931 --> 02:30:57,774
yes and stuff, which we could probably

02:30:57,774 --> 02:30:59,288
need to talk about a bit more.

02:30:59,288 --> 02:31:01,621
But - Yeah, I have no problem

02:31:02,724 --> 02:31:04,559
with trying to consolidate that.

02:31:04,559 --> 02:31:06,186
- I don't want to - That makes sense

02:31:06,186 --> 02:31:07,019
- Change the behavior.

02:31:07,019 --> 02:31:07,852
You know what I mean?

02:31:07,852 --> 02:31:10,740
It's the changing how we deal with all (mumbles)

02:31:10,740 --> 02:31:12,784
that platform that reassign everything today

02:31:12,784 --> 02:31:15,236
and maybe we want to go down that path, I don't know.

02:31:15,236 --> 02:31:16,833
It's just such a can of worm.

02:31:16,833 --> 02:31:18,439
Because I know it will break things.

02:31:18,439 --> 02:31:19,856
We have examples.

02:31:21,031 --> 02:31:22,721
- That ID - I want to

02:31:22,721 --> 02:31:24,059
make it a separate problem.

02:31:24,059 --> 02:31:27,801
- Yeah, it would be useful, I think, to

02:31:27,801 --> 02:31:29,855
examine some of the problems that we know about

02:31:29,855 --> 02:31:30,765
in more detail.

02:31:30,765 --> 02:31:31,917
I feel like we're just - So, one of

02:31:31,917 --> 02:31:32,931
- It doesn't really - one of the common ones

02:31:32,931 --> 02:31:34,718
- Get into the cause of what the failure is.

02:31:34,718 --> 02:31:36,870
- So, one of the common ones is going to be

02:31:36,870 --> 02:31:38,619
that those platforms are just going to give the

02:31:38,619 --> 02:31:40,715
entire space to a single bridge,

02:31:40,715 --> 02:31:42,233
which has a boot device on it.

02:31:42,233 --> 02:31:45,153
And feed it to hardware, which could be right

02:31:45,153 --> 02:31:47,953
in the middle of your face.

02:31:47,953 --> 02:31:51,024
And that's, it's a valid location.

02:31:51,024 --> 02:31:52,828
But it's also a really bad one.

02:31:52,828 --> 02:31:54,292
And if you have a hot plug bridge,

02:31:54,292 --> 02:31:56,229
right now, pull in, you got nothing left for, right?

02:31:56,229 --> 02:31:57,921
Well, it's still a validation that

02:31:57,921 --> 02:31:59,412
a (mumbles) allocation that boot

02:31:59,412 --> 02:32:00,763
because you haven't plugged anything.

02:32:00,763 --> 02:32:02,091
When you try to plug something,

02:32:02,091 --> 02:32:04,474
the reason everything falls apart.

02:32:04,474 --> 02:32:07,891
So, the and it is not an uncommon example

02:32:09,211 --> 02:32:11,543
and Uboot is not the only BIOS out there, of course.

02:32:11,543 --> 02:32:14,917
Uboot has gotten better with PCI.

02:32:14,917 --> 02:32:18,622
But I think it is reasonable to expect,

02:32:18,622 --> 02:32:20,216
especially with things like hot plug,

02:32:20,216 --> 02:32:23,534
where we do the allocation on entire segments

02:32:23,534 --> 02:32:26,725
and the (mumbles) of segments asks us anyway.

02:32:26,725 --> 02:32:29,808
That Linux has reasonably trusted way

02:32:31,505 --> 02:32:33,851
of reallocating PCI resources.

02:32:33,851 --> 02:32:36,406
Fundamentally, in fact, if you think about it,

02:32:36,406 --> 02:32:39,727
what is the difference between a platform

02:32:39,727 --> 02:32:42,185
where nothing is allocated from the root?

02:32:42,185 --> 02:32:43,844
Down sorry.

02:32:43,844 --> 02:32:45,852
Nothing is allocated from the root down,

02:32:45,852 --> 02:32:47,912
versus a platform where some things are there

02:32:47,912 --> 02:32:48,941
that we don't touch.

02:32:48,941 --> 02:32:50,989
And the we have this space behind the hot plug bridge

02:32:50,989 --> 02:32:53,451
where nothing is allocated on from the right down

02:32:53,451 --> 02:32:55,178
until you plug something and then

02:32:55,178 --> 02:32:58,279
without touching the top level bridge, right?

02:32:58,279 --> 02:32:59,895
You now have to allocate everything

02:32:59,895 --> 02:33:01,330
below that top level bridge.

02:33:01,330 --> 02:33:03,997
The first case was just a subset

02:33:04,901 --> 02:33:07,053
of the second case, in a way,

02:33:07,053 --> 02:33:09,081
which what do we do here needs to work.

02:33:09,081 --> 02:33:10,796
So, if it works below a hot plug bridge,

02:33:10,796 --> 02:33:13,750
it may as well work for other platform

02:33:13,750 --> 02:33:18,542
that doesn't have anything already allocated at all.

02:33:18,542 --> 02:33:21,415
And and a lot of those platform are going

02:33:21,415 --> 02:33:25,842
to just come up with every device (mumbles) state

02:33:25,842 --> 02:33:27,197
and nothing in the BAR, so we are going

02:33:27,197 --> 02:33:29,611
to reallocate anyway.

02:33:29,611 --> 02:33:32,346
So, for nano, it is a problem of us

02:33:32,346 --> 02:33:34,799
being capable of doing the allocation.

02:33:34,799 --> 02:33:36,988
Doesn't go where?

02:33:36,988 --> 02:33:41,543
The, it's just that the all the mention of those platform

02:33:41,543 --> 02:33:43,981
have made a conscious decision that whatever

02:33:43,981 --> 02:33:47,398
was there don't, if any, by the firmware,

02:33:48,848 --> 02:33:50,947
is worth less and should be thrown away.

02:33:50,947 --> 02:33:54,701
And it's a reasonable thing to do in many cases,

02:33:54,701 --> 02:33:56,868
Linux will do much better.

02:33:57,746 --> 02:34:01,814
But, as long as we are going to different problem,

02:34:01,814 --> 02:34:05,058
and we can at least consolidate what exists today

02:34:05,058 --> 02:34:08,836
and make it cleaner and easier to work with.

02:34:08,836 --> 02:34:10,919
We can we can defer that.

02:34:11,936 --> 02:34:14,103
Do we have that agreement?

02:34:15,384 --> 02:34:17,763
- Yeah, I don't have a problem with cleaning up what's there

02:34:17,763 --> 02:34:20,641
and, I think we can - So I can resume working

02:34:20,641 --> 02:34:22,182
on my patches.

02:34:22,182 --> 02:34:24,655
- Reassign everything, I don't think that's a core

02:34:24,655 --> 02:34:26,271
piece of the problem.

02:34:26,271 --> 02:34:31,271
- Yeah, so fundamentally, I still have to tackle Power PC,

02:34:31,440 --> 02:34:34,380
which I've been procrastinating.

02:34:34,380 --> 02:34:36,155
Also because I don't have any Power PC anymore.

02:34:36,155 --> 02:34:38,405
Actually I still have a G5.

02:34:39,346 --> 02:34:44,255
But that's okay, I don't live very far from those who do.

02:34:44,255 --> 02:34:47,747
And the key thing is going to be the last stage,

02:34:47,747 --> 02:34:50,217
which is makes things look so much like x86

02:34:50,217 --> 02:34:52,753
that we can now make it 36 (faint speaking).

02:34:52,753 --> 02:34:54,610
That's the holy grail, at least as far as

02:34:54,610 --> 02:34:56,493
that specific patch is concerned.

02:34:56,493 --> 02:35:01,493
I might start looking at upstream little bits of it early.

02:35:02,038 --> 02:35:04,066
And slowly move to it because otherwise,

02:35:04,066 --> 02:35:05,899
it's gonna be too big.

02:35:08,573 --> 02:35:10,490
It's all right as it is

02:35:11,642 --> 02:35:14,570
and it should be bisectable at this stage,

02:35:14,570 --> 02:35:17,420
so I need to go back to it.

02:35:17,420 --> 02:35:20,234
It's been a couple of month now since I touched

02:35:20,234 --> 02:35:23,234
but yeah, this is what I want to do.

02:35:25,369 --> 02:35:30,008
Any comment, discussion, other aspect in that specific area

02:35:30,008 --> 02:35:31,425
that you want to?

02:35:33,529 --> 02:35:34,521
- [Will] I'm not sure if it was mentioned.

02:35:34,521 --> 02:35:35,923
I know testing was briefly mentioned.

02:35:35,923 --> 02:35:36,892
- Oh yeah yeah - How are you going

02:35:36,892 --> 02:35:38,306
to test to and have you got any ideas

02:35:38,306 --> 02:35:40,806
for generating PCI topologies?

02:35:41,846 --> 02:35:44,307
- So, as it is, the series is hopefully meant

02:35:44,307 --> 02:35:46,628
to not change anything for what happening before.

02:35:46,628 --> 02:35:50,146
So, I rely a lot of inspection of course,

02:35:50,146 --> 02:35:53,782
and for the few cases where I have to take the stuff apart

02:35:53,782 --> 02:35:57,942
because the (mumbles) alpha was using antiqued methods

02:35:57,942 --> 02:36:00,606
that were just completely wrong.

02:36:00,606 --> 02:36:03,692
I just tried to manage to find a few people who still have

02:36:03,692 --> 02:36:07,665
those machines and have them basically, just test it for me.

02:36:07,665 --> 02:36:08,571
And it's still booting.

02:36:08,571 --> 02:36:09,939
Things still need to be working.

02:36:09,939 --> 02:36:12,272
Your PCI still needs to be assigned properly.

02:36:12,272 --> 02:36:13,713
Thankfully, those machines do not do

02:36:13,713 --> 02:36:17,046
fancy hot plugs or nobody cares anymore.

02:36:18,951 --> 02:36:22,701
The vast majority of system out there by far,

02:36:25,418 --> 02:36:28,211
are just reassigning everything and I'm not changing that.

02:36:28,211 --> 02:36:30,909
I'm just changing the way, I'm just making

02:36:30,909 --> 02:36:32,558
all that open code call a single function

02:36:32,558 --> 02:36:34,698
with all the same thing.

02:36:34,698 --> 02:36:39,132
So, I'm hoping that sitting in NEXT for a while

02:36:39,132 --> 02:36:42,581
is probably be sufficient for that.

02:36:42,581 --> 02:36:46,831
Long run, so, I have been sticking hard with tests.

02:36:48,355 --> 02:36:52,522
Properly new allocators, new method, new policies,

02:36:53,687 --> 02:36:56,501
we want to change, we want to,

02:36:56,501 --> 02:36:59,458
we think we have a better way of shuffling

02:36:59,458 --> 02:37:02,330
resources around such as what you want to do et cetera.

02:37:02,330 --> 02:37:04,400
How do we test that?

02:37:04,400 --> 02:37:06,821
And how do we test we have regressed everybody?

02:37:06,821 --> 02:37:10,286
And I don't know whether it's something

02:37:10,286 --> 02:37:13,619
we can tackle easily to, in a short term

02:37:16,569 --> 02:37:20,402
but it would be nice if we defined fine format

02:37:22,434 --> 02:37:26,591
that specifically capture the PCI set up of a given system.

02:37:26,591 --> 02:37:29,287
Potentially several with hot plug

02:37:29,287 --> 02:37:32,996
and we create a big database somewhere of these things

02:37:32,996 --> 02:37:37,496
and when we untangle the resource allocation to go to,

02:37:38,423 --> 02:37:40,381
it's a bit more self contained.

02:37:40,381 --> 02:37:43,148
And we effectively can run it in user space

02:37:43,148 --> 02:37:44,815
across these things.

02:37:46,172 --> 02:37:50,922
And what we store is, we don't just store the PCI layout.

02:37:52,043 --> 02:37:55,266
We store the P layout and what allocation we have done,

02:37:55,266 --> 02:37:56,548
with it today,

02:37:56,548 --> 02:37:58,850
so that we can spot whether we have changed something.

02:37:58,850 --> 02:38:00,797
Doesn't mean we have a regression.

02:38:00,797 --> 02:38:04,797
But at least we can apply first, automated thing

02:38:06,184 --> 02:38:09,110
to test whether what it looks valid and there's no

02:38:09,110 --> 02:38:11,406
overlaps and horrible things and that.

02:38:11,406 --> 02:38:12,925
- [Man] Do you think there any way we could use

02:38:12,925 --> 02:38:16,003
K-Unit or something to? - I don't know.

02:38:16,003 --> 02:38:17,424
- Piece of a database. - I honestly don't know.

02:38:17,424 --> 02:38:19,563
I haven't thought that far.

02:38:19,563 --> 02:38:21,557
I don't that one - I know there is

02:38:21,557 --> 02:38:25,158
in GUI called the eVota test model

02:38:25,158 --> 02:38:28,912
for resource allocation, if you remember Bjorn, you present,

02:38:28,912 --> 02:38:30,925
- [Ben] But there's kernel module.

02:38:30,925 --> 02:38:33,984
- Well, I mean, I'm throwing, tossing ideas around.

02:38:33,984 --> 02:38:37,446
I mean, that's - Yeah, my thinking

02:38:37,446 --> 02:38:40,363
is that ideally, we need to be able

02:38:43,024 --> 02:38:45,998
to run something in user space

02:38:45,998 --> 02:38:50,629
that feeds large, that I said, that we keep enriching.

02:38:50,629 --> 02:38:52,262
And we find ways to un code

02:38:52,262 --> 02:38:54,921
and there's nasty bits such as, oh, that machine type

02:38:54,921 --> 02:38:57,552
has a rig in there that doesn't tell you

02:38:57,552 --> 02:38:59,864
about the duration (chuckling)

02:38:59,864 --> 02:39:02,715
and we might need to get to the point where

02:39:02,715 --> 02:39:04,268
to deal with some of those systems,

02:39:04,268 --> 02:39:06,149
we actually really have to do a quirk

02:39:06,149 --> 02:39:07,645
and we might have to do that the hard way

02:39:07,645 --> 02:39:11,163
by breaking the, I mean, somebody who,

02:39:11,163 --> 02:39:12,874
one of the three people on earth write that system.

02:39:12,874 --> 02:39:15,413
Because those things are disappearing, right?

02:39:15,413 --> 02:39:17,955
Hidden devices tend to go away.

02:39:17,955 --> 02:39:21,260
Hidden devices that are not represented by the firmware

02:39:21,260 --> 02:39:22,593
tend to go away.

02:39:25,649 --> 02:39:29,369
Yeah, so, that just, very very just high level thought.

02:39:29,369 --> 02:39:31,702
I haven't really gone into details and I'm not sure

02:39:31,702 --> 02:39:35,113
I will be the person to have the bandwidth to tackle that

02:39:35,113 --> 02:39:38,363
in any reasonable time frame from here.

02:39:39,259 --> 02:39:40,862
But for somebody who's interested,

02:39:40,862 --> 02:39:43,292
it's definitely something to look into.

02:39:43,292 --> 02:39:45,641
Especially with all that hot plug crap

02:39:45,641 --> 02:39:47,979
and all that Thunderbolt crap and all that.

02:39:47,979 --> 02:39:49,062
Because yeah.

02:39:51,928 --> 02:39:54,057
- [Alex] I'm just wondering if you've seen any set that,

02:39:54,057 --> 02:39:56,649
is it (mumbles), or something there,

02:39:56,649 --> 02:39:58,603
there was (mumbles)

02:39:58,603 --> 02:40:02,436
Yeah, so on hot plug, it would start and stop.

02:40:03,587 --> 02:40:05,370
It would stop all the devices,

02:40:05,370 --> 02:40:07,920
re do all the bus numbers - Yeah, that's what

02:40:07,920 --> 02:40:08,763
you mentioned earlier?

02:40:08,763 --> 02:40:10,357
I haven't seen it.

02:40:10,357 --> 02:40:12,107
When was that posted?

02:40:14,752 --> 02:40:16,200
- It's been posted pretty frequently.

02:40:16,200 --> 02:40:19,358
I'm just wondering what you think about that approach?

02:40:19,358 --> 02:40:24,358
- Oh, I think we have to do that for a number of reasons.

02:40:24,812 --> 02:40:29,312
And it might be useful for all those things, actually.

02:40:30,322 --> 02:40:32,500
Such as some of those IOMMU problems

02:40:32,500 --> 02:40:34,781
where if you want to change the grouping

02:40:34,781 --> 02:40:38,285
or change the policies on existing loaded devices,

02:40:38,285 --> 02:40:42,170
we have to effectively to do the same thing.

02:40:42,170 --> 02:40:45,758
Yeah, I'm reasonably confident that we will not

02:40:45,758 --> 02:40:48,073
be able to deal with some

02:40:48,073 --> 02:40:50,421
of the more crazy Thunderbolt things

02:40:50,421 --> 02:40:52,364
and whatever next is gonna come up

02:40:52,364 --> 02:40:57,364
because I suspect we are just started going done that path

02:40:57,698 --> 02:41:01,301
of crazy hot plug without having a way

02:41:01,301 --> 02:41:04,854
to redo allocation with live devices.

02:41:04,854 --> 02:41:08,274
And that will require active collaboration.

02:41:08,274 --> 02:41:09,925
And the simplest way I can think of doing that

02:41:09,925 --> 02:41:12,725
is to figure out everybody under the segments

02:41:12,725 --> 02:41:15,881
of the (mumbles) that we need to reallocate,

02:41:15,881 --> 02:41:17,990
to be stopped, one way or another.

02:41:17,990 --> 02:41:19,726
And whether the existing suspend call

02:41:19,726 --> 02:41:22,942
are sufficient or good for that even, probably not.

02:41:22,942 --> 02:41:24,578
Some of the suspend call are going to do things

02:41:24,578 --> 02:41:28,291
like flush the disk cache onto the platter

02:41:28,291 --> 02:41:30,447
because we're expecting to spin down the disk

02:41:30,447 --> 02:41:34,581
and then it's gonna take 10 seconds to spin back up.

02:41:34,581 --> 02:41:36,966
You really don't want to do these things.

02:41:36,966 --> 02:41:40,770
Some of the stuff we've been doing for suspend to disk,

02:41:40,770 --> 02:41:43,061
like the free stuff might be more appropriate.

02:41:43,061 --> 02:41:45,103
I don't know, I don't, I can't tell you today

02:41:45,103 --> 02:41:48,236
what the right way to do it.

02:41:48,236 --> 02:41:49,561
All pro and cons, right?

02:41:49,561 --> 02:41:52,944
Adding new callbacks, yet another set of callbacks

02:41:52,944 --> 02:41:55,907
into the never ending series that most drivers

02:41:55,907 --> 02:41:58,478
are never going to implement.

02:41:58,478 --> 02:42:01,170
I don't know, but yes, in principle,

02:42:01,170 --> 02:42:05,051
something like this appears inevitable to me,

02:42:05,051 --> 02:42:05,884
unavoidable.

02:42:05,884 --> 02:42:09,383
We're gonna have to do something like this.

02:42:09,383 --> 02:42:10,923
- Benjamin, for the sake of time,

02:42:10,923 --> 02:42:14,588
I think we need to give Kishon time

02:42:14,588 --> 02:42:16,338
to present his topic.

02:42:16,338 --> 02:42:20,244
But I suggest we can keep discussing this

02:42:20,244 --> 02:42:21,077
in the conference and if

02:42:21,077 --> 02:42:22,664
you want, - I've pretty much

02:42:22,664 --> 02:42:23,774
said everything I wanted to say.

02:42:23,774 --> 02:42:28,101
So, it's mostly about feedbacks, thoughts and questions.

02:42:28,101 --> 02:42:30,816
- [Eric] Maybe you can try to summarize it on Wednesday or

02:42:30,816 --> 02:42:33,499
- Yeah yeah, both, below the corridors or whatever.

02:42:33,499 --> 02:42:35,079
- Yeah.

02:42:35,079 --> 02:42:37,513
If any question, just reach out to Ben

02:42:37,513 --> 02:42:39,648
and we can take it from there.

02:42:39,648 --> 02:42:40,830
- [6th Participant] It's a very intriguing,

02:42:40,830 --> 02:42:41,819
very different code,

02:42:41,819 --> 02:42:43,665
that no one understands anymore.

02:42:43,665 --> 02:42:45,273
- I am aware of that.

02:42:45,273 --> 02:42:48,022
Let me take, maybe just one to give you

02:42:48,022 --> 02:42:49,328
an example. - And you keep saying

02:42:49,328 --> 02:42:50,878
that you have no bandwidth

02:42:50,878 --> 02:42:53,216
and you haven't got to it in a couple of months

02:42:53,216 --> 02:42:54,668
and are you gonna be able to stick with this?

02:42:54,668 --> 02:42:57,078
'Cause you're touching a very tricky area

02:42:57,078 --> 02:42:58,860
that no one understands.

02:42:58,860 --> 02:43:00,916
- The stuff I'm doing at the moment,

02:43:00,916 --> 02:43:03,472
the simplification part is not changing the behaviors.

02:43:03,472 --> 02:43:05,555
It's making it easier to understand.

02:43:05,555 --> 02:43:07,274
So I'm hoping to be able to do that

02:43:07,274 --> 02:43:09,107
without doing too much

02:43:10,166 --> 02:43:12,422
where we the, what you mentioned is when

02:43:12,422 --> 02:43:14,922
we started actually tackling the allocator itself.

02:43:14,922 --> 02:43:17,500
And I've already tackled some of these things.

02:43:17,500 --> 02:43:18,777
I don't have no bandwidth.

02:43:18,777 --> 02:43:20,489
I don't have the bandwidth to start

02:43:20,489 --> 02:43:23,232
the whole new testing thing.

02:43:23,232 --> 02:43:26,780
There is one interesting example is a whole PCI rig basis,

02:43:26,780 --> 02:43:28,429
bridge basis, we don't read the bridge bases

02:43:28,429 --> 02:43:31,762
at all today initially because if we do,

02:43:32,743 --> 02:43:35,388
we break all those platform we want to re

02:43:35,388 --> 02:43:37,591
(mumbling)

02:43:37,591 --> 02:43:38,925
because of weird, there's a thing

02:43:38,925 --> 02:43:42,583
that you add it once in the code without any description

02:43:42,583 --> 02:43:45,495
or nothing and just enable that list of why

02:43:45,495 --> 02:43:46,748
that test is there.

02:43:46,748 --> 02:43:49,487
And nobody so far have been capable of telling me why.

02:43:49,487 --> 02:43:51,478
It's there and it's breaking that.

02:43:51,478 --> 02:43:53,569
And we don't know why.

02:43:53,569 --> 02:43:54,822
Yeah.

02:43:54,822 --> 02:43:56,270
Thank you.

02:43:56,270 --> 02:43:59,552
- We thank Benjamin for presenting

02:43:59,552 --> 02:44:01,802
(applause)

02:44:13,010 --> 02:44:14,719
- I press the

02:44:14,719 --> 02:44:16,886
(chatter)

02:44:26,478 --> 02:44:28,645
(chatter)

02:44:38,946 --> 02:44:43,196
(soft speaking in the background)

02:44:44,315 --> 02:44:45,815
- Yeah, thank you.

02:44:46,851 --> 02:44:49,087
Hi, I'm Kishon Vijay Abraham.

02:44:49,087 --> 02:44:51,985
I work for Texas Instruments.

02:44:51,985 --> 02:44:55,235
I mostly work on service MNCM and PCIe.

02:44:56,795 --> 02:44:58,072
I maintain the five subsystem

02:44:58,072 --> 02:45:03,072
and also the, and also maintain the PCIe Endpoint subsystem.

02:45:03,213 --> 02:45:05,951
Today, I'd like to discuss about implementing

02:45:05,951 --> 02:45:09,730
NTB controller using configurable PCIe endpoint.

02:45:09,730 --> 02:45:13,359
So, I've given introduction to NTB,

02:45:13,359 --> 02:45:16,339
what are the various constraints using

02:45:16,339 --> 02:45:18,589
building an NTB controller,

02:45:18,589 --> 02:45:22,922
how I model them using a configurable PCIe endpoint.

02:45:32,013 --> 02:45:35,930
Okay, so NTB stands for Non-Transparent Bridge.

02:45:37,314 --> 02:45:39,832
It allows, it is a point to point bus

02:45:39,832 --> 02:45:42,593
allowing two systems to communicate with each other.

02:45:42,593 --> 02:45:46,010
So here, it allows, so here it allows two

02:45:49,214 --> 02:45:50,468
maybe it's not seeing,

02:45:50,468 --> 02:45:53,079
okay, so here it allows two for systems

02:45:53,079 --> 02:45:55,908
to communicate with each other.

02:45:55,908 --> 02:46:00,908
So, the NTB is functionally similar to a Plan Spring bridge

02:46:01,249 --> 02:46:06,249
except that the address domains on both sides of the bridge

02:46:06,368 --> 02:46:07,701
are independent.

02:46:12,352 --> 02:46:16,639
And the devices that are percent in the downstream

02:46:16,639 --> 02:46:18,944
downstream part of the bridge is not missable

02:46:18,944 --> 02:46:21,584
to the upstream part of the bridge.

02:46:21,584 --> 02:46:25,568
And the NTB device also exposes a type zero configuration

02:46:25,568 --> 02:46:29,459
space header, which is similar to that of an endpoint.

02:46:29,459 --> 02:46:31,542
That has the root ports and the switches,

02:46:31,542 --> 02:46:35,286
usually have type one configuration space header.

02:46:35,286 --> 02:46:39,793
So NTB is implemented by some of the Intel processors

02:46:39,793 --> 02:46:42,793
AMD processor and there are some switches,

02:46:42,793 --> 02:46:45,902
which actually agreement NTB,

02:46:45,902 --> 02:46:50,465
so, the NTB provide three primary constraints

02:46:50,465 --> 02:46:53,593
using which the host on either side of the bridge

02:46:53,593 --> 02:46:55,668
can communicate with each other.

02:46:55,668 --> 02:46:58,886
One is the scratch pad registers, the doorbell registers

02:46:58,886 --> 02:47:00,803
and the memory windows.

02:47:07,141 --> 02:47:10,409
- Don't they also usually have DM engines?

02:47:10,409 --> 02:47:11,242
- Sorry?

02:47:11,242 --> 02:47:13,126
- [Ben] Don't they also usually have DMA engines?

02:47:13,126 --> 02:47:14,427
- The NTB controllers?

02:47:14,427 --> 02:47:15,285
- Yeah.

02:47:15,285 --> 02:47:17,285
- Some switches has DMA.

02:47:19,469 --> 02:47:23,259
But I'm not sure, the generally NTB Linux framework

02:47:23,259 --> 02:47:26,960
how far it supports an NTB in the switch,

02:47:26,960 --> 02:47:30,627
I think that's something we have to explore.

02:47:32,672 --> 02:47:35,667
So, scratchpad registers, the scratchpad registers

02:47:35,667 --> 02:47:39,394
it's a normal register space provided by the NTB

02:47:39,394 --> 02:47:41,769
to each of the hosts.

02:47:41,769 --> 02:47:45,383
So the scratchpad registers are both readable and writable

02:47:45,383 --> 02:47:48,596
from both sides of the bridge.

02:47:48,596 --> 02:47:52,187
So, the scratchpad registers are used by their applications,

02:47:52,187 --> 02:47:55,399
which uses NTB to share controller status implementation

02:47:55,399 --> 02:47:57,399
between these two hosts.

02:47:58,458 --> 02:48:00,492
There are two parts of scratchpad.

02:48:00,492 --> 02:48:03,770
One is the self scratchpad and the other is peer scratchpad.

02:48:03,770 --> 02:48:06,619
So each host here has its own scratchpad,

02:48:06,619 --> 02:48:09,870
which is the self scratchpad and it will also

02:48:09,870 --> 02:48:12,705
be able to access the scratchpad of the other hosts,

02:48:12,705 --> 02:48:14,895
which is the peer scratchpad.

02:48:14,895 --> 02:48:17,981
And then there is, they have global registers.

02:48:17,981 --> 02:48:22,033
The global registers are used to send (mumbles)

02:48:22,033 --> 02:48:24,372
from one end of, one set of NTB to the other side,

02:48:24,372 --> 02:48:27,117
so basically, the host to one, can actually intervene

02:48:27,117 --> 02:48:29,813
the host two using the Doorbell register.

02:48:29,813 --> 02:48:33,079
And then there are memory windows

02:48:33,079 --> 02:48:36,656
so the actual transfers of data between the two hosts.

02:48:36,656 --> 02:48:38,277
How do you think these memory windows?

02:48:38,277 --> 02:48:39,419
So these are the primary constructs

02:48:39,419 --> 02:48:44,252
using which both the host can communicate with each other.

02:48:45,661 --> 02:48:50,363
So now, let's get into the details of how I built

02:48:50,363 --> 02:48:53,475
NTB functionality using a SoC.

02:48:53,475 --> 02:48:55,767
So in order to build NTB functionality,

02:48:55,767 --> 02:48:58,220
in a SoC by SoC should be capable

02:48:58,220 --> 02:49:01,669
or should implement multiple endpoint instances

02:49:01,669 --> 02:49:04,469
so here the SoC actually implements

02:49:04,469 --> 02:49:07,101
two endpoint instances and the host, which communicate

02:49:07,101 --> 02:49:10,268
with each other should be connected to

02:49:11,549 --> 02:49:14,750
one endpoint that is present in the SoC.

02:49:14,750 --> 02:49:17,444
So once you have a hardware with this configuration,

02:49:17,444 --> 02:49:19,710
the endpoint one and endpoint two controllers

02:49:19,710 --> 02:49:22,903
can be configured such that a transaction

02:49:22,903 --> 02:49:26,736
from one host can be rooted to the other host.

02:49:29,749 --> 02:49:33,999
So, in order to configure the endpoint controllers,

02:49:35,789 --> 02:49:37,576
they have the address translation unit,

02:49:37,576 --> 02:49:39,878
which is the inbound address translation unit

02:49:39,878 --> 02:49:42,334
and the outbound translation unit.

02:49:42,334 --> 02:49:45,504
So, all the incoming transactions should happen

02:49:45,504 --> 02:49:48,485
where base address registers.

02:49:48,485 --> 02:49:52,577
So, if a host one, if host one has to access any region

02:49:52,577 --> 02:49:57,435
within SoC, it has to be using those base address registers.

02:49:57,435 --> 02:49:59,871
The inbound address translation unit

02:49:59,871 --> 02:50:02,917
can be configures such that access to BAR

02:50:02,917 --> 02:50:06,697
will actually reach a target in the local intra connect.

02:50:06,697 --> 02:50:10,642
So in the case of normal endpoint applications,

02:50:10,642 --> 02:50:13,008
the address translation unit will be configured

02:50:13,008 --> 02:50:16,724
such that the base address register any access

02:50:16,724 --> 02:50:20,053
to base address register will reach the linear

02:50:20,053 --> 02:50:23,535
or memory space or to a peripheral register space.

02:50:23,535 --> 02:50:28,222
But in the case of NTB, the address translation unit

02:50:28,222 --> 02:50:30,711
should be configured sch that access to bus

02:50:30,711 --> 02:50:32,960
actually reach the outbound region

02:50:32,960 --> 02:50:35,627
of the other endpoint instances.

02:50:36,629 --> 02:50:37,823
Sorry.

02:50:37,823 --> 02:50:40,037
- [Ben] And the other way around.

02:50:40,037 --> 02:50:40,870
- I didn't get you.

02:50:40,870 --> 02:50:43,325
- [Ben] That's alright, just go on.

02:50:43,325 --> 02:50:48,325
- Yeah, so, once the transaction hits the outbound region,

02:50:48,494 --> 02:50:50,896
the PC controller will rule the transaction

02:50:50,896 --> 02:50:53,688
to host two based on your outbound address translation

02:50:53,688 --> 02:50:55,271
unit configuration.

02:50:59,957 --> 02:51:04,290
So, for implementing NTB configurable PCIe endpoint,

02:51:06,884 --> 02:51:09,594
so, all the primary constraints

02:51:09,594 --> 02:51:12,659
that is used in building an NTB should any host be used,

02:51:12,659 --> 02:51:15,041
which is the scratchpad registers, the doorbell registers

02:51:15,041 --> 02:51:17,053
and the memory windows.

02:51:17,053 --> 02:51:21,108
However, the add a new constraint or new region

02:51:21,108 --> 02:51:23,788
which just specially required when you want to make

02:51:23,788 --> 02:51:27,621
a configurable PCIe endpoint behave as an NTB.

02:51:29,279 --> 02:51:33,360
So, the control and status VDN, it has the register space

02:51:33,360 --> 02:51:35,657
for configuring the endpoint controller.

02:51:35,657 --> 02:51:38,802
So here, the endpoint controller can initially

02:51:38,802 --> 02:51:42,255
write some of the information like number of memory windows

02:51:42,255 --> 02:51:45,377
supported the scratchpad offset et cetera,

02:51:45,377 --> 02:51:47,336
which can be read by the host.

02:51:47,336 --> 02:51:49,097
And the host can write to this region

02:51:49,097 --> 02:51:51,439
whenever it has to configure the outbound address

02:51:51,439 --> 02:51:52,856
translation unit.

02:51:57,980 --> 02:52:01,085
So, so there are five regions,

02:52:01,085 --> 02:52:02,375
the controller and status regions,

02:52:02,375 --> 02:52:06,353
which is specific to the configurable PCIe endpoint.

02:52:06,353 --> 02:52:10,099
The self scratchpad region, the peer scratchpad region,

02:52:10,099 --> 02:52:12,600
the doorbell region and the memory windows.

02:52:12,600 --> 02:52:14,153
So there are five regions and we have

02:52:14,153 --> 02:52:15,903
only six 36-bit BARs.

02:52:17,032 --> 02:52:19,839
So if a platform supports 32-bit BARs,

02:52:19,839 --> 02:52:22,145
then we could assign one region,

02:52:22,145 --> 02:52:24,868
we could assign none region for every bug.

02:52:24,868 --> 02:52:27,989
- This is the details of a specific implementation, right?

02:52:27,989 --> 02:52:32,504
Technically, a nontransparent bridge can be different.

02:52:32,504 --> 02:52:34,895
It just happened to be the one that you're talking about

02:52:34,895 --> 02:52:37,356
that it, like this, right?

02:52:37,356 --> 02:52:38,380
- [Kishon] Like what?

02:52:38,380 --> 02:52:40,630
- Well, organized this way.

02:52:41,576 --> 02:52:45,729
There is no standard for that, is there?

02:52:45,729 --> 02:52:48,543
- There is no standard, so you mean the the regions?

02:52:48,543 --> 02:52:52,758
- Yeah, specific details of the organization of

02:52:52,758 --> 02:52:54,258
yeah, - So, yeah so

02:52:56,197 --> 02:52:58,128
- As far as (faint speaking)

02:52:58,128 --> 02:53:00,692
- Yeah and the style of scratchpads and the type

02:53:00,692 --> 02:53:03,499
of intrepid generates and the number of memory windows,

02:53:03,499 --> 02:53:05,366
whether it's pre fetch able or not, whether there is

02:53:05,366 --> 02:53:06,536
a DM engine or not.

02:53:06,536 --> 02:53:08,710
All those things are completely implementation specific.

02:53:08,710 --> 02:53:09,735
- [Kishon] Correct, all those implementation specific.

02:53:09,735 --> 02:53:11,531
- Okay, okay.

02:53:11,531 --> 02:53:12,759
(faint speaking)

02:53:12,759 --> 02:53:15,605
No I just wanted to clarify that.

02:53:15,605 --> 02:53:19,022
- Yeah, so, so, these are like the basic,

02:53:21,185 --> 02:53:23,567
so if you want to have basic NTB functionality

02:53:23,567 --> 02:53:25,015
you will have these regions,

02:53:25,015 --> 02:53:27,501
obviously there are more additional regions,

02:53:27,501 --> 02:53:29,955
additional functional these which are specific

02:53:29,955 --> 02:53:32,669
to some of the hardware.

02:53:32,669 --> 02:53:35,569
For example, some hardware have memory space region,

02:53:35,569 --> 02:53:38,716
which is optional et cetera.

02:53:38,716 --> 02:53:43,054
Yeah, so we have five regions and six 32-bit BARs.

02:53:43,054 --> 02:53:46,722
And if a platform supports only 64-bit BARs,

02:53:46,722 --> 02:53:50,402
or if they have BARs for some, the sole purpose,

02:53:50,402 --> 02:53:53,046
then we won't be able to have,

02:53:53,046 --> 02:53:54,741
then we won't be able to allocate BARs

02:53:54,741 --> 02:53:56,970
for all these regions.

02:53:56,970 --> 02:54:00,154
So, we combine these regions in such a way

02:54:00,154 --> 02:54:01,727
that we don't break the functionality

02:54:01,727 --> 02:54:05,975
while making sure that access to one host

02:54:05,975 --> 02:54:09,696
doesn't access a region that it shouldn't access.

02:54:09,696 --> 02:54:13,779
So, the BAR zero so the control and status region

02:54:14,711 --> 02:54:18,459
and self scratchpad region are combined

02:54:18,459 --> 02:54:20,325
to be mapped to BAR zero.

02:54:20,325 --> 02:54:25,010
And you give a separate BAR for the peer scratchpad region.

02:54:25,010 --> 02:54:27,562
For the doorbell region and memory window one,

02:54:27,562 --> 02:54:29,968
you give BAR two, so these are like the basic,

02:54:29,968 --> 02:54:32,400
at least three BARs, you need to implement

02:54:32,400 --> 02:54:33,712
the NTB functionality.

02:54:33,712 --> 02:54:36,924
And if there are additional free BARs,

02:54:36,924 --> 02:54:40,341
you could have additional memory windows.

02:54:44,917 --> 02:54:49,148
So here, as I said, I combined the control status region

02:54:49,148 --> 02:54:53,215
and the scratchpad region and the inbound

02:54:53,215 --> 02:54:55,034
address translation unit as configured

02:54:55,034 --> 02:54:59,256
such that any access to BARs will reach the controller

02:54:59,256 --> 02:55:01,562
status region and the scratchpad region.

02:55:01,562 --> 02:55:05,676
So, the controller status region and the scratchpad regions

02:55:05,676 --> 02:55:10,505
are memory that are actually allocated in the DDR.

02:55:10,505 --> 02:55:14,950
So, the scratchpad of yeah, so the scratchpad

02:55:14,950 --> 02:55:19,720
of one host is also the peer scratchpad of the other host

02:55:19,720 --> 02:55:23,184
so we use the second BAR to access

02:55:23,184 --> 02:55:25,023
the peer scratchpad region.

02:55:25,023 --> 02:55:28,019
So whenever the host one has to access the control

02:55:28,019 --> 02:55:31,801
status region or the scratchpad, it will use BAR zero.

02:55:31,801 --> 02:55:34,351
If it has to use, if it has to access the scratchpad,

02:55:34,351 --> 02:55:38,231
it will use BAR zero with a appropriate offset.

02:55:38,231 --> 02:55:40,959
And similarly, if host two has to access

02:55:40,959 --> 02:55:43,746
the peer scratchpad region, it will use the BAR one.

02:55:43,746 --> 02:55:47,280
Same thing for the other host also.

02:55:47,280 --> 02:55:50,098
So here we model the controller status region,

02:55:50,098 --> 02:55:55,015
the self scratchpad region and the peer scratchpad regions.

02:55:57,568 --> 02:56:01,735
So for, so, now we'll model the doorbell registers

02:56:02,846 --> 02:56:05,056
and the memory windows.

02:56:05,056 --> 02:56:08,355
For the doorbell registers, we'll use the MSI

02:56:08,355 --> 02:56:10,188
or MSIX functionality.

02:56:11,110 --> 02:56:14,941
So, generally, while the host, say, for example,

02:56:14,941 --> 02:56:17,839
you think this endpoint connected to this host

02:56:17,839 --> 02:56:22,172
while this host initializes the endpoint two device,

02:56:24,157 --> 02:56:27,062
it will, while initializing,

02:56:27,062 --> 02:56:29,625
it will populate the MSI capability

02:56:29,625 --> 02:56:32,933
with the MSI address and MSI data,

02:56:32,933 --> 02:56:35,408
I mean, there is, for the MSI, there is a separate table.

02:56:35,408 --> 02:56:37,574
But it's the same mechanism.

02:56:37,574 --> 02:56:40,465
So, when the when this endpoint as to

02:56:40,465 --> 02:56:42,603
raise and interrupt to the host two,

02:56:42,603 --> 02:56:47,381
it will take the MSI data and write to the MSI address.

02:56:47,381 --> 02:56:51,199
But configured by host two during the initialization.

02:56:51,199 --> 02:56:55,782
So now, for the NTB case, instead of the endpoint

02:56:55,782 --> 02:56:59,919
writing the MSI data to MSIX address, we'll make sure

02:56:59,919 --> 02:57:03,425
the host one can directly write the MSI data

02:57:03,425 --> 02:57:04,758
to MSIX address.

02:57:05,772 --> 02:57:09,355
So, when during the initialization process,

02:57:10,876 --> 02:57:14,051
the endpoint function driver that runs in this SoC

02:57:14,051 --> 02:57:18,400
will revolve memory for MSI and for memory window.

02:57:18,400 --> 02:57:20,774
Because we have combined the doorbell

02:57:20,774 --> 02:57:22,691
and memory one regions.

02:57:23,584 --> 02:57:28,286
So, so it will just resolve some region in this space

02:57:28,286 --> 02:57:30,855
and configure the inbound address translation unit,

02:57:30,855 --> 02:57:33,211
so that BAR two is mapped to this region

02:57:33,211 --> 02:57:35,689
in the outbound address space.

02:57:35,689 --> 02:57:38,645
Now, once the host comes and initializes

02:57:38,645 --> 02:57:41,622
the endpoint device, it will populate the MSI

02:57:41,622 --> 02:57:45,502
or the MSIX capability with the address and data.

02:57:45,502 --> 02:57:50,112
So once the host has configured the MSI table,

02:57:50,112 --> 02:57:53,197
it will write a command in the controller

02:57:53,197 --> 02:57:57,405
and status region that it has configured the MSI table.

02:57:57,405 --> 02:58:01,405
So, only after, so only after this the host here

02:58:02,343 --> 02:58:06,176
writes that the MSI table has been configured,

02:58:07,455 --> 02:58:08,555
the software running here will know

02:58:08,555 --> 02:58:12,609
that the MSI capability has valid address and data here.

02:58:12,609 --> 02:58:16,554
So once the host two writes a command, to configure

02:58:16,554 --> 02:58:19,270
that it has configured the MSI capability,

02:58:19,270 --> 02:58:21,631
the function driver will configure the outbound address

02:58:21,631 --> 02:58:25,142
translation unit so that the address space

02:58:25,142 --> 02:58:28,833
result for MSIX is mapped to and MSI address.

02:58:28,833 --> 02:58:31,666
- This looks weird. (chuckles)

02:58:31,666 --> 02:58:34,416
Kishon, for, I mean, I think the,

02:58:37,311 --> 02:58:39,930
the question here is that, A,

02:58:39,930 --> 02:58:43,908
how does it map to the current endpoint subsystem?

02:58:43,908 --> 02:58:47,041
And second, I think, for the sake of timing,

02:58:47,041 --> 02:58:49,793
I think you should seek feedback from the audience,

02:58:49,793 --> 02:58:53,033
because I don't think you can, I think if you,

02:58:53,033 --> 02:58:56,934
the time you have to ask the controversial question

02:58:56,934 --> 02:58:57,779
you want sorted out.

02:58:57,779 --> 02:59:00,193
Because I think we are running out of time.

02:59:00,193 --> 02:59:02,128
I think it's built on top of the endpoint

02:59:02,128 --> 02:59:04,074
that we have patches there already.

02:59:04,074 --> 02:59:05,018
- [Kishon] Yes.

02:59:05,018 --> 02:59:09,268
- You do need to make sure that the MSIX table that

02:59:11,025 --> 02:59:15,525
is as a host, and I look, I see your device MSIX table

02:59:16,994 --> 02:59:20,959
in behind the BAR, that never goes away.

02:59:20,959 --> 02:59:22,895
I don't used to talk about it being remapped

02:59:22,895 --> 02:59:23,728
to something.

02:59:23,728 --> 02:59:24,768
That must never go away.

02:59:24,768 --> 02:59:28,907
So, host never finish configurating MSIs.

02:59:28,907 --> 02:59:32,147
The host might poke at the table to enable disable MSI,

02:59:32,147 --> 02:59:33,373
et cetera, runtime.

02:59:33,373 --> 02:59:36,430
The host, these days, can actually pop new MSIs

02:59:36,430 --> 02:59:38,172
at runtime any MSIX table.

02:59:38,172 --> 02:59:40,769
Perfectly possible and we have APIs to do that.

02:59:40,769 --> 02:59:44,307
- So, okay, so, the host actually can write

02:59:44,307 --> 02:59:48,054
to this command region as ad when it configures

02:59:48,054 --> 02:59:49,221
the MSI table.

02:59:51,356 --> 02:59:55,304
So, whenever you do something like a log IRQ

02:59:55,304 --> 02:59:57,924
or something, I think that's when the MSI tables

02:59:57,924 --> 03:00:00,820
or the MSI capability gets configured.

03:00:00,820 --> 03:00:01,984
So I tried to understand what problem

03:00:01,984 --> 03:00:02,893
you're trying to solve here.

03:00:02,893 --> 03:00:04,853
You're trying to - So, I'm trying to

03:00:04,853 --> 03:00:09,827
- Open an outbound window from the device to the host

03:00:09,827 --> 03:00:13,524
that is encompass all the possible MSI addresses

03:00:13,524 --> 03:00:16,457
so you can actually write them.

03:00:16,457 --> 03:00:17,836
- Direct, yes. - Okay.

03:00:17,836 --> 03:00:18,844
I see.

03:00:18,844 --> 03:00:20,744
- So. - You could do that lazily.

03:00:20,744 --> 03:00:22,632
You could check the point where you're sending an MSI

03:00:22,632 --> 03:00:24,691
that table doesn't have the address to send

03:00:24,691 --> 03:00:27,676
and then recompute the table.

03:00:27,676 --> 03:00:28,850
You now, - So, the idea

03:00:28,850 --> 03:00:31,744
is to for basically the high level idea is for

03:00:31,744 --> 03:00:34,001
host one to interrupt host two.

03:00:34,001 --> 03:00:38,672
And we use the MSI capabilities that is present in the SoC.

03:00:38,672 --> 03:00:40,846
- Yeah so, if you don't necessarily need that command

03:00:40,846 --> 03:00:42,881
that tells you that MSIs have been configured.

03:00:42,881 --> 03:00:47,076
You could perfectly well, verify whether the MSI

03:00:47,076 --> 03:00:49,701
you're trying to send fit into the current table you have

03:00:49,701 --> 03:00:52,371
and if it doesn't, then - So, so in this host,

03:00:52,371 --> 03:00:54,683
actually, tries to interrupt the host to the software

03:00:54,683 --> 03:00:57,778
or anything here is totally transparent.

03:00:57,778 --> 03:01:01,445
It doesn't really snoop or do anything once.

03:01:04,089 --> 03:01:05,753
It does all this mapping.

03:01:05,753 --> 03:01:07,973
The host one can directly interrupt the host two

03:01:07,973 --> 03:01:09,243
by just writing to the base

03:01:09,243 --> 03:01:10,490
- What I'm saying yes.

03:01:10,490 --> 03:01:12,962
But it first need to look into the table

03:01:12,962 --> 03:01:15,379
to figure out where to write.

03:01:16,570 --> 03:01:19,295
- So, this one doesn't has to write.

03:01:19,295 --> 03:01:22,401
All it knows is it has to write to this region.

03:01:22,401 --> 03:01:25,401
And (faint speaking)

03:01:26,372 --> 03:01:28,518
And you will show - That's all,

03:01:28,518 --> 03:01:30,975
let me just quickly make sure I understand.

03:01:30,975 --> 03:01:33,546
It's a magic right that the hardware will turn into an MSI

03:01:33,546 --> 03:01:36,563
or is it just the actual write of the MSI message

03:01:36,563 --> 03:01:38,545
that happens to be mapped?

03:01:38,545 --> 03:01:39,941
- [Kishon] It is actual rate of the

03:01:39,941 --> 03:01:41,118
- Exactly, this exactly what I'm saying.

03:01:41,118 --> 03:01:44,072
So you need to make sure that the outbound

03:01:44,072 --> 03:01:47,155
that create an outbound region in one

03:01:48,778 --> 03:01:53,009
that covers all the address space that you need

03:01:53,009 --> 03:01:56,318
to cover all the MSIX addresses of two.

03:01:56,318 --> 03:01:57,562
- [Kishon] So that's what it's down there.

03:01:57,562 --> 03:01:58,915
- But you don't need that command to do that.

03:01:58,915 --> 03:02:00,085
You can do that lazily.

03:02:00,085 --> 03:02:01,938
When you want to send - So you can't really

03:02:01,938 --> 03:02:04,610
map an entire outbound space because this address space

03:02:04,610 --> 03:02:06,521
is really limited.

03:02:06,521 --> 03:02:09,810
- Sure but thankfully the host usually

03:02:09,810 --> 03:02:10,643
will be very nice to you

03:02:10,643 --> 03:02:12,511
and most of the MSIs gonna be very close

03:02:12,511 --> 03:02:14,110
to each other all of them.

03:02:14,110 --> 03:02:17,164
So, but the point is you don't need that command

03:02:17,164 --> 03:02:19,558
that tells you configure the MSIs.

03:02:19,558 --> 03:02:23,328
You know that you have or not yet configure the window

03:02:23,328 --> 03:02:25,626
and then the point where we want to send an interrupt

03:02:25,626 --> 03:02:28,959
you can check pretty easily that address

03:02:31,102 --> 03:02:34,685
which you have to pull out of the table fit

03:02:36,098 --> 03:02:37,634
in your current window.

03:02:37,634 --> 03:02:41,495
And if it doesn't then you reconfigure the window.

03:02:41,495 --> 03:02:43,969
- Does this mean that host one needs to know

03:02:43,969 --> 03:02:46,969
the host two's MSI table in terms of

03:02:48,719 --> 03:02:51,052
of the MSI? - So the address,

03:02:52,043 --> 03:02:54,953
it doesn't have to because all it accesses is this.

03:02:54,953 --> 03:02:57,191
And you would have done the mapping from here to here

03:02:57,191 --> 03:02:58,904
and here to here.

03:02:58,904 --> 03:03:00,386
- [Eric] So that's a hardware mapping.

03:03:00,386 --> 03:03:03,697
- No this is , so, this is function driver

03:03:03,697 --> 03:03:07,209
NTB function driver running in this SoC,

03:03:07,209 --> 03:03:09,163
which configures this

03:03:09,163 --> 03:03:12,904
to this but it doesn't, when it initially comes up,

03:03:12,904 --> 03:03:16,073
it doesn't know which others this has to be mapped to.

03:03:16,073 --> 03:03:18,637
That will happen only after host two has initialized

03:03:18,637 --> 03:03:20,220
the MSI capability.

03:03:22,981 --> 03:03:23,814
So,

03:03:23,814 --> 03:03:26,280
- [Ben] Yeah, but the MSI capabilities in the BAR, right?

03:03:26,280 --> 03:03:28,592
So, the MSI table, the MSI x-ray,

03:03:28,592 --> 03:03:33,150
so the MSI x table is somewhere in the memory

03:03:33,150 --> 03:03:35,317
of the host one. - Got it.

03:03:36,167 --> 03:03:38,367
Sometimes in the memory of the SoC,

03:03:38,367 --> 03:03:41,427
not necessarily host one because both share the same

03:03:41,427 --> 03:03:42,594
DDR and stuff.

03:03:43,732 --> 03:03:45,571
- Wait wait wait, we're talking about the case

03:03:45,571 --> 03:03:47,162
where one interrupts two.

03:03:47,162 --> 03:03:47,995
- [Kishon] Correct.

03:03:47,995 --> 03:03:52,505
Okay, which mean the MSI X table that we are interested in

03:03:52,505 --> 03:03:54,841
is MSI X table of one.

03:03:54,841 --> 03:03:56,536
- It's host two. It's host two.

03:03:56,536 --> 03:03:58,284
- One is interrupting two.

03:03:58,284 --> 03:04:01,211
- Yeah so it's the MSI's table for host two.

03:04:01,211 --> 03:04:02,649
- No.

03:04:02,649 --> 03:04:04,458
One - It's two (mumbles)

03:04:04,458 --> 03:04:07,657
- Yes, which means it's returning MSI by host one,

03:04:07,657 --> 03:04:10,352
which we are talking about the MX table of one.

03:04:10,352 --> 03:04:12,606
- No no no. - no no.

03:04:12,606 --> 03:04:13,439
- Yes.

03:04:13,439 --> 03:04:14,272
- No. - No.

03:04:14,272 --> 03:04:17,269
- No, forget about the host one part,

03:04:17,269 --> 03:04:20,529
so you consider only host two and then point device,

03:04:20,529 --> 03:04:22,952
consider only a host - MSIX table

03:04:22,952 --> 03:04:24,441
is in the endpoint.

03:04:24,441 --> 03:04:25,274
- Correct correct.

03:04:25,274 --> 03:04:27,077
You consider, you forget about this part.

03:04:27,077 --> 03:04:29,738
You have a host connected to an endpoint.

03:04:29,738 --> 03:04:30,571
- [Ben] Yes.

03:04:30,571 --> 03:04:33,571
- So the MSI table for this endpoint

03:04:34,584 --> 03:04:36,216
- It's completely - In the endpoint

03:04:36,216 --> 03:04:38,360
- It's in endpoint two.

03:04:38,360 --> 03:04:40,192
So this one does not know about this.

03:04:40,192 --> 03:04:42,011
- Oh, I thought the endpoint was host one

03:04:42,011 --> 03:04:44,350
through your non NT, non transparent bridge.

03:04:44,350 --> 03:04:45,183
- No.

03:04:45,183 --> 03:04:47,807
So, if you look at the entire picture,

03:04:47,807 --> 03:04:51,094
the MSIX table will somewhere be in the DDR.

03:04:51,094 --> 03:04:52,790
- Host one, which is what I'm saying

03:04:52,790 --> 03:04:55,623
- No no no, there is only one SoC.

03:04:57,348 --> 03:05:00,750
So, this is like one SoC, which has two endpoint instances.

03:05:00,750 --> 03:05:02,908
- [Ben] Oh gosh, I see.

03:05:02,908 --> 03:05:04,732
- It's not a separate device.

03:05:04,732 --> 03:05:06,411
- The picture confused me.

03:05:06,411 --> 03:05:07,244
Sorry.

03:05:07,244 --> 03:05:10,647
Ah, get, ah, yeah yeah yeah yeah.

03:05:10,647 --> 03:05:11,480
I get it.

03:05:12,390 --> 03:05:14,480
(faint speaking)

03:05:14,480 --> 03:05:18,486
No no, I was, I just did not completely

03:05:18,486 --> 03:05:21,174
understand that this is what all inside the one SoC

03:05:21,174 --> 03:05:22,865
that pretends to be the NTB bridge

03:05:22,865 --> 03:05:25,967
and I thought this was a bit of a host there.

03:05:25,967 --> 03:05:27,079
- The endpoint host devices.

03:05:27,079 --> 03:05:27,912
- Yeah yeah yeah.

03:05:27,912 --> 03:05:29,315
Okay, I'm getting now.

03:05:29,315 --> 03:05:31,990
Sorry, I'm sorry, I apologize.

03:05:31,990 --> 03:05:34,657
- Yeah so, so this configuration

03:05:35,534 --> 03:05:37,784
(laughing)

03:05:41,310 --> 03:05:44,916
So host one will be able to ring the doorbell

03:05:44,916 --> 03:05:48,038
of host two, same thing the other direction

03:05:48,038 --> 03:05:52,425
was the host two will also has the similar configuration

03:05:52,425 --> 03:05:56,008
within which it can interrupt the host one.

03:05:57,778 --> 03:05:59,278
So, okay so, oops.

03:06:04,249 --> 03:06:06,916
And similarly for memory window,

03:06:08,260 --> 03:06:10,503
the host two after initial.

03:06:10,503 --> 03:06:12,579
So this is my current design.

03:06:12,579 --> 03:06:14,367
Maybe this is something we could discuss

03:06:14,367 --> 03:06:18,668
but host two will allocate memory and then

03:06:18,668 --> 03:06:22,562
it will again populate the address in the controller

03:06:22,562 --> 03:06:24,621
and status region.

03:06:24,621 --> 03:06:26,108
And then it will write the command

03:06:26,108 --> 03:06:27,829
to configure memory window.

03:06:27,829 --> 03:06:32,266
So, once it writes a command to configure memory window,

03:06:32,266 --> 03:06:33,882
the software running here will configure

03:06:33,882 --> 03:06:35,037
the outbound translation unit

03:06:35,037 --> 03:06:38,764
so, that the space is so for memory window,

03:06:38,764 --> 03:06:41,293
it's mapped to an address that is actually programmed

03:06:41,293 --> 03:06:42,907
by the host.

03:06:42,907 --> 03:06:46,128
So the and so for accessing memory window one

03:06:46,128 --> 03:06:49,772
host one will write to BAR two with an offset

03:06:49,772 --> 03:06:52,600
using which it relaxes a buffer in the host,

03:06:52,600 --> 03:06:54,730
in the other host.

03:06:54,730 --> 03:06:58,115
So same thing applies for other memory windows.

03:06:58,115 --> 03:07:00,193
So similarly it will during re initialization,

03:07:00,193 --> 03:07:03,022
it will resolve memory for other memory windows

03:07:03,022 --> 03:07:05,601
configured inbound address translation unit.

03:07:05,601 --> 03:07:09,361
The host driver comes up, it allocates memory.

03:07:09,361 --> 03:07:11,194
MW2 whatever, MW3 MW4.

03:07:12,228 --> 03:07:15,209
It writes a command to configure memory window.

03:07:15,209 --> 03:07:17,870
At that time, the outbound address translation unit

03:07:17,870 --> 03:07:22,203
of this will be configured so that it's mapped here.

03:07:24,369 --> 03:07:28,574
So this is the overall software architecture.

03:07:28,574 --> 03:07:32,894
On the top is the host say, I can return in the bottoms

03:07:32,894 --> 03:07:35,137
the endpoints at architecture.

03:07:35,137 --> 03:07:37,594
On the host side, there is a

03:07:37,594 --> 03:07:40,312
on the host side, there is a NTB framework

03:07:40,312 --> 03:07:44,106
which abstracts the various NTB hardware.

03:07:44,106 --> 03:07:47,048
And also the various NTB applications

03:07:47,048 --> 03:07:48,676
that is currently present.

03:07:48,676 --> 03:07:52,357
So, right now, the supports Intel NTB hardware

03:07:52,357 --> 03:07:54,940
AMD and also there is a switch.

03:07:56,270 --> 03:07:58,493
It supports NTB, netdev application

03:07:58,493 --> 03:08:01,503
which actually creates an internet interface

03:08:01,503 --> 03:08:05,003
over PCIe NTB and there are other NTB tool

03:08:07,674 --> 03:08:09,860
which can use for normal debugging

03:08:09,860 --> 03:08:13,292
perf and pingpong are like other simple tools.

03:08:13,292 --> 03:08:17,110
On the endpoint side, there is a PCIe endpoint code,

03:08:17,110 --> 03:08:20,920
which abstracts the various endpoint devices

03:08:20,920 --> 03:08:23,409
and right now, it has one function driver,

03:08:23,409 --> 03:08:25,659
which is the PCIe EPF test.

03:08:26,864 --> 03:08:29,947
So, right now PCIe design BAR cadence

03:08:33,765 --> 03:08:35,772
and there are like few other windows

03:08:35,772 --> 03:08:38,772
who actually support PCIe endpoints.

03:08:40,176 --> 03:08:42,918
So, so for writing the support I have to add

03:08:42,918 --> 03:08:47,533
a new hardware driver, which is NTB hardware EPF

03:08:47,533 --> 03:08:51,785
and on the endpoint side, I have to add a PCIe ECF

03:08:51,785 --> 03:08:54,097
NTB function driver.

03:08:54,097 --> 03:08:56,290
There are some modifications to the endpoint code,

03:08:56,290 --> 03:08:58,653
because now the endpoints function device

03:08:58,653 --> 03:09:03,355
will now have reference to two endpoint instances.

03:09:03,355 --> 03:09:05,539
And also there is a new arms basically

03:09:05,539 --> 03:09:10,372
to map MSI table to the outbound address translation unit.

03:09:11,832 --> 03:09:14,757
So once this part is done,

03:09:14,757 --> 03:09:17,759
we could have two independent hosts

03:09:17,759 --> 03:09:22,009
connected to multi endpoint instance supported SoC.

03:09:23,679 --> 03:09:27,059
We should be able to use any of this applications

03:09:27,059 --> 03:09:31,142
to transfer data from one host to the other host.

03:09:32,848 --> 03:09:36,098
- And (faint speaking)

03:09:38,505 --> 03:09:39,522
- [Kishon] Sorry?

03:09:39,522 --> 03:09:43,862
- Can it be done, the hardware that it's supported today?

03:09:43,862 --> 03:09:47,048
The cadence designware, - Yeah.

03:09:47,048 --> 03:09:49,522
- Yeah. - So the endpoint devices,

03:09:49,522 --> 03:09:52,750
so there are few other endpoint devices

03:09:52,750 --> 03:09:56,113
that is structured, that is layered (mumbles).

03:09:56,113 --> 03:09:58,685
And these are like IPs used by multiple other windows

03:09:58,685 --> 03:10:02,535
like Samsung, DA, everyone uses one of these cadence

03:10:02,535 --> 03:10:03,868
or synopsis IPs.

03:10:05,609 --> 03:10:08,875
- I should ask you to summarize and if you have questions,

03:10:08,875 --> 03:10:12,741
for the audience. - Yeah, I have one slide more.

03:10:12,741 --> 03:10:13,991
Maybe complete.

03:10:14,950 --> 03:10:18,350
Yeah, so, as part of this, as part of this hook,

03:10:18,350 --> 03:10:21,147
I'm also hiding device tree support for

03:10:21,147 --> 03:10:22,505
for endpoint function.

03:10:22,505 --> 03:10:24,293
So previously the endpoint function devices

03:10:24,293 --> 03:10:26,810
are created using configure first.

03:10:26,810 --> 03:10:28,662
So for creating an endpoint function device

03:10:28,662 --> 03:10:31,001
you used to create something like this.

03:10:31,001 --> 03:10:35,309
But now for, so the problem is you can barely

03:10:35,309 --> 03:10:39,335
link a function to one endpoint instance.

03:10:39,335 --> 03:10:42,594
Now we have to link a function to two instances

03:10:42,594 --> 03:10:45,163
and better and device tree, in my opinion,

03:10:45,163 --> 03:10:49,315
was a better presentation for this kind of use cases.

03:10:49,315 --> 03:10:52,482
So, the root should be a EPF bus which

03:10:54,037 --> 03:10:58,115
has the PCIe EPF bus compatible property.

03:10:58,115 --> 03:11:03,115
So the EPF bus driver will create endpoint function device

03:11:03,549 --> 03:11:05,716
for each of the sub notes.

03:11:06,695 --> 03:11:09,778
Here have one one NTB function device

03:11:10,689 --> 03:11:13,106
so we have a single NTB node.

03:11:14,783 --> 03:11:19,263
The compatible here will find or will bind the endpoint

03:11:19,263 --> 03:11:22,294
function device to the endpoint function driver.

03:11:22,294 --> 03:11:25,534
And EPCS will have the P handles

03:11:25,534 --> 03:11:27,484
to the PCA endpoint instances.

03:11:27,484 --> 03:11:31,302
Since it's an NTB, it should have P handle to two two

03:11:31,302 --> 03:11:33,180
PCA endpoint instances.

03:11:33,180 --> 03:11:36,647
And then EPC names, which is basically

03:11:36,647 --> 03:11:40,267
corresponding to the P handles that is in PCS.

03:11:40,267 --> 03:11:42,084
And then when the device ID are

03:11:42,084 --> 03:11:44,179
what you can actually program,

03:11:44,179 --> 03:11:45,776
in the configuration space header.

03:11:45,776 --> 03:11:48,088
So these five properties will be common

03:11:48,088 --> 03:11:50,471
to all endpoint function devices.

03:11:50,471 --> 03:11:53,361
They (mumbles) the number of memory widows.

03:11:53,361 --> 03:11:57,058
And memory windows are actually specific to a

03:11:57,058 --> 03:11:58,725
are specific to NTB.

03:11:59,761 --> 03:12:03,860
We still use configure first to start the endpoint

03:12:03,860 --> 03:12:06,019
controller to actually tell that it's ready

03:12:06,019 --> 03:12:07,642
to establish a link.

03:12:07,642 --> 03:12:11,216
So this is because we can't have a function driver

03:12:11,216 --> 03:12:14,002
start an endpoint instance because that will break

03:12:14,002 --> 03:12:16,984
a multiple function endpoint devices.

03:12:16,984 --> 03:12:21,442
- Have you thought at all about extending that support

03:12:21,442 --> 03:12:25,025
an arbitrary number of endpoint rather than

03:12:25,885 --> 03:12:27,802
just a point to point connection?

03:12:27,802 --> 03:12:29,489
So that means having more sets of peer registers

03:12:29,489 --> 03:12:30,513
and - Yeah,

03:12:30,513 --> 03:12:31,346
so it's like ports.

03:12:31,346 --> 03:12:33,977
It's like multiple ports is what you actually mean.

03:12:33,977 --> 03:12:37,849
So this design actually, how I really intend this to be

03:12:37,849 --> 03:12:41,266
done is for us to support multiple ports.

03:12:42,448 --> 03:12:45,254
It should actually use multiple physical functions,

03:12:45,254 --> 03:12:48,375
which is actually supported in the PCA specification.

03:12:48,375 --> 03:12:51,168
So, there are advantages and disadvantages.

03:12:51,168 --> 03:12:53,300
One of the primary use cases for us and also

03:12:53,300 --> 03:12:55,785
the advantages is we should be, we could provide

03:12:55,785 --> 03:12:58,702
isolation between different devices

03:13:00,363 --> 03:13:03,401
because when you have multiple physical functions,

03:13:03,401 --> 03:13:07,598
then you give a separate ID to each of these devices.

03:13:07,598 --> 03:13:10,511
- Okay and another quick one.

03:13:10,511 --> 03:13:13,789
I'm last one to advocate against a device share.

03:13:13,789 --> 03:13:15,902
More disadvantage.

03:13:15,902 --> 03:13:18,564
The and I don't like configfs that much

03:13:18,564 --> 03:13:23,564
but it is our standard for doing that sort of stuff,

03:13:23,653 --> 03:13:27,820
it is in USB gadget and it is now on PCI endpoint.

03:13:28,811 --> 03:13:32,774
I don't mind having device two representation

03:13:32,774 --> 03:13:35,944
that is equivalent and bijective

03:13:35,944 --> 03:13:38,400
so that we can go back and forth with complete equivalence

03:13:38,400 --> 03:13:39,776
between the device representation

03:13:39,776 --> 03:13:42,036
and the configfs representation.

03:13:42,036 --> 03:13:43,581
In fact, it will be probably useful for some

03:13:43,581 --> 03:13:46,653
of the USB gadget stuff as well.

03:13:46,653 --> 03:13:50,562
But I still think the same thing should be doable

03:13:50,562 --> 03:13:53,272
both ways. - Yeah, I agree.

03:13:53,272 --> 03:13:55,104
- So you should be able to create the same link

03:13:55,104 --> 03:13:58,127
across endpoints on the configfs and

03:13:58,127 --> 03:13:59,096
- Yes, I agree.

03:13:59,096 --> 03:14:01,823
So yeah I agree. - Okay cool.

03:14:01,823 --> 03:14:04,425
- So why is both the endpoints visible

03:14:04,425 --> 03:14:06,425
to a single OS instance?

03:14:08,667 --> 03:14:10,171
- [Kishon] Why is both endpoints?

03:14:10,171 --> 03:14:12,530
- Visible to a single OS instance.

03:14:12,530 --> 03:14:15,254
I mean, the (soft speaking)

03:14:15,254 --> 03:14:17,845
Yeah, but my point is that the host one

03:14:17,845 --> 03:14:20,162
should only be seeing its endpoint

03:14:20,162 --> 03:14:22,582
- No no no, so this is not in host, right.

03:14:22,582 --> 03:14:24,345
This is in the endpoint.

03:14:24,345 --> 03:14:26,648
This is in a multi function endpoint instance.

03:14:26,648 --> 03:14:29,042
You are building a NTB function driver

03:14:29,042 --> 03:14:30,869
or NTB function device.

03:14:30,869 --> 03:14:34,701
So NTB function device has two part, two sides.

03:14:34,701 --> 03:14:38,532
Each side will be connected to a separate endpoint instance.

03:14:38,532 --> 03:14:39,995
- Yes but my understanding, maybe,

03:14:39,995 --> 03:14:41,444
correct me if I'm wrong.

03:14:41,444 --> 03:14:43,574
Where does this data structure go?

03:14:43,574 --> 03:14:45,164
It goes to the OS, right?

03:14:45,164 --> 03:14:48,730
- No, the OS or the SoC that, the SoC

03:14:48,730 --> 03:14:50,690
that's acting as a non transparent bridge.

03:14:50,690 --> 03:14:52,194
- [Kishon] Yes.

03:14:52,194 --> 03:14:55,984
- So, the two host, they are connected to a single SoC

03:14:55,984 --> 03:14:59,848
that has two port and that that SoC plays

03:14:59,848 --> 03:15:01,884
act as a bridge between the two hosts.

03:15:01,884 --> 03:15:05,801
And this is the description the DT of that SoC.

03:15:07,053 --> 03:15:09,399
It tells it to connect those two ports together

03:15:09,399 --> 03:15:11,649
to make an NTB out of them.

03:15:14,471 --> 03:15:16,630
Unfortunately, I think we need to write it down.

03:15:16,630 --> 03:15:18,091
- Yes.

03:15:18,091 --> 03:15:21,924
I just want to ask you if it's possible before

03:15:23,213 --> 03:15:28,213
merging upstream the endpoint implementation driver.

03:15:28,270 --> 03:15:29,928
It would be nice if you test it

03:15:29,928 --> 03:15:33,845
across all endpoint controllers implementations

03:15:35,257 --> 03:15:37,312
to make sure that the design is valid.

03:15:37,312 --> 03:15:40,189
Because there are, I know in the past there are

03:15:40,189 --> 03:15:43,356
- All is a very big word but at least.

03:15:44,653 --> 03:15:47,076
At least maybe the most common one.

03:15:47,076 --> 03:15:49,485
I suppose designware is probably is the most common one.

03:15:49,485 --> 03:15:51,609
- I could test both in designware and cadence.

03:15:51,609 --> 03:15:55,799
So I tested this is cadence so, so I could connect

03:15:55,799 --> 03:15:59,157
two endpoint, two host connected to a

03:15:59,157 --> 03:16:03,036
the (mumbles) it has like two endpoint instances.

03:16:03,036 --> 03:16:06,401
And then I was able to use NTB netdev to communicate

03:16:06,401 --> 03:16:09,125
between the centers using standard ping tools

03:16:09,125 --> 03:16:10,085
and perf tools.

03:16:10,085 --> 03:16:12,394
- Just to make sure the design,

03:16:12,394 --> 03:16:14,197
you can implement it on different

03:16:14,197 --> 03:16:15,530
- [Kishon] Yes.

03:16:16,967 --> 03:16:20,456
- In grand scheme of things, the main thing

03:16:20,456 --> 03:16:22,335
that could be problematic would be things

03:16:22,335 --> 03:16:23,377
like a number of windows.

03:16:23,377 --> 03:16:25,537
So if the architecture is reasonably flexible,

03:16:25,537 --> 03:16:27,934
how may windows you have, for example,

03:16:27,934 --> 03:16:29,551
that sort of thing would probably,

03:16:29,551 --> 03:16:31,541
is the the kind (mumbles).

03:16:31,541 --> 03:16:34,391
I wouldn't put it past somebody to make one

03:16:34,391 --> 03:16:37,798
where the whole MSI stuff has to be hardware generated.

03:16:37,798 --> 03:16:40,140
But that's the kind of problem that

03:16:40,140 --> 03:16:42,723
let's solve it when we have to.

03:16:45,312 --> 03:16:47,378
But yeah, I mean.

03:16:47,378 --> 03:16:50,828
I reckon, those two seem to be the most common

03:16:50,828 --> 03:16:55,439
out there so, it makes sense to focus on them.

03:16:55,439 --> 03:16:59,584
- Yeah, so I'll, I targeted to post the patches

03:16:59,584 --> 03:17:03,079
before LPC but wasn't able to but I should be able to

03:17:03,079 --> 03:17:04,677
in a couple of weeks.

03:17:04,677 --> 03:17:07,010
But I have all this working.

03:17:08,320 --> 03:17:12,070
Yeah so, some of the references for the work.

03:17:14,937 --> 03:17:17,346
- [Eric] Any questions?

03:17:17,346 --> 03:17:18,579
Just.

03:17:18,579 --> 03:17:21,010
We are really running out of time, guys.

03:17:21,010 --> 03:17:22,593
So I mean, quickly.

03:17:24,149 --> 03:17:28,866
- What's your next plan to build up with the router?

03:17:28,866 --> 03:17:29,708
- [Kishon] Sorry?

03:17:29,708 --> 03:17:32,620
- I mean just the transfer from peer to peer,

03:17:32,620 --> 03:17:35,953
you don't need to do that way, just one,

03:17:37,483 --> 03:17:39,411
one master and one slave.

03:17:39,411 --> 03:17:43,328
But I think you do that, maybe you want to have

03:17:45,026 --> 03:17:48,776
a switch, that means a lot host could plug in

03:17:49,764 --> 03:17:53,431
the plug in your chip and the hardware thing

03:17:56,177 --> 03:17:58,510
because that's where be more complex.

03:17:58,510 --> 03:17:59,798
- You must transfer distance.

03:17:59,798 --> 03:18:04,765
- So, so so, in my opinion, it should be like a repeat

03:18:04,765 --> 03:18:08,397
of this device tree in all multiple times.

03:18:08,397 --> 03:18:12,932
So, every time you use use endpoint instance,

03:18:12,932 --> 03:18:15,886
it means it will use one physical function on that endpoint.

03:18:15,886 --> 03:18:19,045
You just replicate it multiple times.

03:18:19,045 --> 03:18:20,992
So as many physical functions as

03:18:20,992 --> 03:18:25,325
is that you'll be able to bind a NTB device to that.

03:18:28,323 --> 03:18:30,838
- I think guys, I think we should wrap it up.

03:18:30,838 --> 03:18:32,816
I'm sorry we can take it offline

03:18:32,816 --> 03:18:37,650
while I invite you to discuss further on Wednesday

03:18:37,650 --> 03:18:40,817
quarter to one, I mean, for a PCI BUF.

03:18:42,785 --> 03:18:45,801
And to talk to us, I mean, to maintain

03:18:45,801 --> 03:18:46,823
there's everybody in the room

03:18:46,823 --> 03:18:49,973
about outstanding topics and what you would like to discuss

03:18:49,973 --> 03:18:52,224
given that the conference is sill ongoing.

03:18:52,224 --> 03:18:54,160
And last but not least, thank you very much

03:18:54,160 --> 03:18:57,929
for showing up and for making this happen.

03:18:57,929 --> 03:18:59,983
So thank you very much to the speakers

03:18:59,983 --> 03:19:02,740
and to everybody who attended the micro conference.

03:19:02,740 --> 03:19:04,271

YouTube URL: https://www.youtube.com/watch?v=ozlQ1XQreac


