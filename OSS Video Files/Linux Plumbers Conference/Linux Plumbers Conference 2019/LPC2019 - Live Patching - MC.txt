Title: LPC2019 - Live Patching - MC
Publication date: 2019-09-20
Playlist: Linux Plumbers Conference 2019
Description: 
	Live Patching - MC
Captions: 
	00:00:01,517 --> 00:00:04,184
(male laughing)

00:00:05,060 --> 00:00:06,540
- Okay.

00:00:06,540 --> 00:00:09,490
Welcome to the livepatching microconference.

00:00:11,119 --> 00:00:12,560
We have a lot of talks today.

00:00:12,560 --> 00:00:14,270
Hopefully a lot of discussion.

00:00:14,270 --> 00:00:16,680
So feel free if you need to talk.

00:00:16,680 --> 00:00:20,240
Raise your hand and we'll throw one of these cubes.

00:00:20,240 --> 00:00:23,330
And, when you talk into the cube, please hold it up.

00:00:23,330 --> 00:00:25,700
Because they're having problems

00:00:25,700 --> 00:00:26,750
projecting it so

00:00:27,620 --> 00:00:29,290
you gotta hold it right up to your mouth

00:00:29,290 --> 00:00:30,622
when you talk into it.

00:00:30,622 --> 00:00:32,272
And don't put the cubes together.

00:00:34,500 --> 00:00:35,400
I think that's it.

00:00:36,381 --> 00:00:37,214
- Stand up.

00:00:37,214 --> 00:00:39,640
- Oh yeah, and when you wanna ask a question,

00:00:39,640 --> 00:00:42,470
stand up while you're talking in the cube.

00:00:43,800 --> 00:00:45,422
All right.

00:00:45,422 --> 00:00:46,394
- [Male] Also everyone know that

00:00:46,394 --> 00:00:47,390
they can help help keep evens.

00:00:47,390 --> 00:00:49,630
- Yes, we have an Etherpad.

00:00:49,630 --> 00:00:50,470
Here's the link.

00:00:51,709 --> 00:00:53,750
Feel free to help out.

00:00:53,750 --> 00:00:55,120
It's a collaborative effort,

00:00:55,120 --> 00:00:55,953
taking notes.

00:00:57,420 --> 00:00:58,420
And here's Miroslav.

00:01:00,150 --> 00:01:02,590
- Hi, welcome, I'm Miroslav from SUSE.

00:01:02,590 --> 00:01:04,800
I'm going to talk a bit about what happened

00:01:04,800 --> 00:01:07,670
in our livepatching free over the last year.

00:01:08,880 --> 00:01:11,450
It was a short year,

00:01:11,450 --> 00:01:13,520
so nothing much happened.

00:01:13,520 --> 00:01:15,730
But at the same time, it was important,

00:01:15,730 --> 00:01:19,970
because we managed to merge atomic replace.

00:01:21,261 --> 00:01:24,400
Which means that now we could

00:01:25,840 --> 00:01:28,420
implement what we call cumulative patches.

00:01:29,270 --> 00:01:32,810
So, that if you livepatch something in the system,

00:01:32,810 --> 00:01:35,300
a function or two functions, it doesn't matter.

00:01:35,300 --> 00:01:36,860
And then you have a new version.

00:01:36,860 --> 00:01:39,220
So, you can stagger patches like that

00:01:40,974 --> 00:01:42,430
and so somewhere in the future you're

00:01:42,430 --> 00:01:46,080
going to have batch patches,

00:01:47,630 --> 00:01:50,440
each batch patching something else in the system,

00:01:50,440 --> 00:01:51,800
which is not nice,

00:01:51,800 --> 00:01:54,210
but if you're going to have cumulative patch,

00:01:54,210 --> 00:01:58,121
so it shows that each version is a super set

00:01:58,121 --> 00:02:00,310
of a previous patch.

00:02:00,310 --> 00:02:03,393
And with atomic replace all those previous patches

00:02:03,393 --> 00:02:06,480
could be atomically removed right now.

00:02:06,480 --> 00:02:09,370
And say this is quite important.

00:02:09,370 --> 00:02:14,290
This is how we implement and deploy livepatches at SUSE.

00:02:15,901 --> 00:02:19,610
We, for quite a time, because we have this feature

00:02:19,610 --> 00:02:22,470
in kgraft, and it works quite well.

00:02:23,850 --> 00:02:27,970
This atomic replace was,

00:02:27,970 --> 00:02:30,090
or could have been implemented,

00:02:30,090 --> 00:02:31,720
thanks to consistency model.

00:02:31,720 --> 00:02:34,800
So, this is one thing which is maybe not so clear,

00:02:34,800 --> 00:02:38,860
but we have consistency model so there could be

00:02:42,818 --> 00:02:46,057
more feature rich livepatches implemented

00:02:47,870 --> 00:02:51,140
but there's also yet a side of the consistency model.

00:02:51,140 --> 00:02:56,073
So, it gives us information but if a kernel

00:02:57,060 --> 00:02:59,580
from previous livepatches is even used in a system

00:02:59,580 --> 00:03:02,190
because consistency model would move

00:03:02,190 --> 00:03:04,590
all the task from the old code.

00:03:04,590 --> 00:03:07,020
So, now, if you know that there's nothing,

00:03:07,020 --> 00:03:09,910
it has no task in the old code you can remove it.

00:03:09,910 --> 00:03:13,220
So, that's why the atomic replace was implemented.

00:03:14,060 --> 00:03:18,220
And, the second major feature was selftests.

00:03:19,150 --> 00:03:20,830
Now, yes, question.

00:03:20,830 --> 00:03:21,663
Thank you.

00:03:25,070 --> 00:03:28,500
- Sorry, so on the first one the cumulative pattern,

00:03:28,500 --> 00:03:32,440
the atomic replace, how do you know which patterns

00:03:32,440 --> 00:03:36,170
are to be removed from the running kernel

00:03:36,170 --> 00:03:38,610
and the new cumulative patch is to be applied?

00:03:38,610 --> 00:03:40,030
Is it still a series of patches?

00:03:40,030 --> 00:03:41,120
The new cumulative one?

00:03:41,120 --> 00:03:42,390
Or is it just one patch.

00:03:42,390 --> 00:03:45,440
- It's just one module with all the new functions.

00:03:45,440 --> 00:03:48,270
So, you apply it and then you remove

00:03:48,270 --> 00:03:49,680
all the previous patches.

00:03:49,680 --> 00:03:52,500
- You have to remove all, you can't

00:03:52,500 --> 00:03:55,490
remove a subset of the currently applied ones, right?

00:03:56,669 --> 00:03:57,857
- No.

00:03:57,857 --> 00:04:00,150
- [Man In Blue And White Shirt] Right, okay. Cool. Thanks.

00:04:01,650 --> 00:04:04,250
- But off goes it could be done

00:04:04,250 --> 00:04:07,790
with a new livepatch, so it's only up to you.

00:04:07,790 --> 00:04:09,320
It would not be a cumulative patch

00:04:09,320 --> 00:04:12,210
but you could still use atomic replace.

00:04:12,210 --> 00:04:15,100
So, just some functions or some patched functions

00:04:15,100 --> 00:04:17,260
would be reverted, in a way.

00:04:17,260 --> 00:04:18,600
So that's still possible.

00:04:18,600 --> 00:04:22,240
- [Man In Blue And White Shirt] Yup, thanks.

00:04:22,240 --> 00:04:23,073
- So, selftests.

00:04:24,030 --> 00:04:28,020
So, now we have selftests in tools testing

00:04:28,020 --> 00:04:31,740
so that's slash slash livepatch.

00:04:31,740 --> 00:04:33,230
Those are really important.

00:04:35,020 --> 00:04:36,690
It was quite a bit of work,

00:04:36,690 --> 00:04:40,220
thanks to Joe Lawrence from Red Hat.

00:04:40,220 --> 00:04:42,920
And it helped us tremendously

00:04:44,140 --> 00:04:47,600
because it caught a couple of bugs with new features.

00:04:48,950 --> 00:04:52,550
Personally, it helped me quite a bit when I tried

00:04:52,550 --> 00:04:56,670
to implement real live trace support support on system Z,

00:04:57,970 --> 00:04:59,720
which is now in the wild.

00:04:59,720 --> 00:05:02,490
So, that was great.

00:05:02,490 --> 00:05:06,690
So, now I'm thinking about that maybe it would be great to

00:05:08,950 --> 00:05:11,250
not force the policy

00:05:11,250 --> 00:05:12,490
but maybe it would be great to do

00:05:12,490 --> 00:05:14,360
something we do with documentations.

00:05:14,360 --> 00:05:15,990
So, when there's a new feature,

00:05:15,990 --> 00:05:18,170
we'd like a new documentation as well

00:05:18,170 --> 00:05:19,910
because it helps people.

00:05:19,910 --> 00:05:24,680
And, so, maybe we should also require new selftests

00:05:24,680 --> 00:05:28,644
for that feature I think because it is really important

00:05:28,644 --> 00:05:33,010
and so maybe I don't know what you think about it.

00:05:33,010 --> 00:05:34,490
I think it would be good policy.

00:05:34,490 --> 00:05:38,190
Not solving what should be rigid but should be,

00:05:39,384 --> 00:05:41,440
what's the correct word?

00:05:41,440 --> 00:05:42,273
- [Man Off Screen] Encouraged.

00:05:42,273 --> 00:05:43,106
- Encouraged!

00:05:43,106 --> 00:05:44,790
Thank you. (laughs)

00:05:47,130 --> 00:05:48,390
Yeah, well, okay.

00:05:48,390 --> 00:05:49,223
So forced.

00:05:49,223 --> 00:05:50,056
No.

00:05:50,056 --> 00:05:54,180
Okay, so these two features are really important

00:05:54,180 --> 00:05:56,440
because now I think that not that

00:05:57,310 --> 00:05:59,360
the livepatching is feature complete,

00:05:59,360 --> 00:06:04,360
but it's almost there for almost everyone

00:06:05,030 --> 00:06:07,210
to use it in a productive way.

00:06:08,977 --> 00:06:12,990
Of course, there are some catches, but.

00:06:12,990 --> 00:06:17,990
Now, last year I talked about CGG optimizations

00:06:19,284 --> 00:06:24,110
and how they are not so great for us

00:06:24,110 --> 00:06:26,930
because they complicate things sometimes.

00:06:26,930 --> 00:06:31,746
So, now we have flive-patching option for GCC

00:06:31,746 --> 00:06:36,260
and it disables certain set of dangerous optimizations.

00:06:37,120 --> 00:06:41,220
And we use it in upstream kernel right now so

00:06:41,220 --> 00:06:45,940
whenever you enable config livepatch you also

00:06:45,940 --> 00:06:48,340
enable this option so the whole kernel gets

00:06:48,340 --> 00:06:50,790
compiled without certain optimizations.

00:06:50,790 --> 00:06:54,925
Now, you may wonder if there's some performance impact.

00:06:54,925 --> 00:06:58,690
There was even an article on Phoronix about that.

00:06:58,690 --> 00:07:00,080
So, it's really important.

00:07:01,010 --> 00:07:03,930
And, the answer is, the outcome is,

00:07:03,930 --> 00:07:06,840
there's almost no performance impact.

00:07:06,840 --> 00:07:09,280
All of those optimizations, which are disabled,

00:07:09,280 --> 00:07:14,280
are either not used at all or used in really

00:07:14,476 --> 00:07:19,476
small amount of functions, a small set of code.

00:07:19,960 --> 00:07:22,980
So, the performance impact was not so important.

00:07:23,823 --> 00:07:28,810
There were something like 10 percent decrease in scheduler

00:07:28,810 --> 00:07:33,810
but it was something we could live with, I think.

00:07:34,244 --> 00:07:36,860
And of course, there were many bug fixes

00:07:36,860 --> 00:07:38,010
and minor improvements.

00:07:39,170 --> 00:07:40,003
Question.

00:07:41,256 --> 00:07:42,940
- [Audience Member] Can you mention the versions

00:07:42,940 --> 00:07:46,290
of the compiler and the kernel that introduced these.

00:07:46,290 --> 00:07:47,460
- Yeah, good question.

00:07:47,460 --> 00:07:52,460
So, flive-patching made us do GCC nine so it's there.

00:07:52,580 --> 00:07:57,220
And the config option enabling flive-patching

00:07:57,220 --> 00:08:00,676
was merged in five two.

00:08:00,676 --> 00:08:01,556
- [Audience Member] Probably, I dont.

00:08:01,556 --> 00:08:02,540
- Probably. - [Audience Member] Yeah.

00:08:02,540 --> 00:08:03,410
- I don't remember.

00:08:03,410 --> 00:08:05,460
Five two, because now we are at

00:08:05,460 --> 00:08:07,740
five three so five two or five one.

00:08:07,740 --> 00:08:08,870
I'm not sure.

00:08:08,870 --> 00:08:09,703
Yeah.

00:08:09,703 --> 00:08:13,130
Okay, one important thing didn't make it to the list.

00:08:13,130 --> 00:08:17,000
So, now our mailing list is archived on lore.kernel.org.

00:08:17,860 --> 00:08:22,590
There, all emails since starting June this year,

00:08:23,460 --> 00:08:27,360
we should provide, we unbox all the archives

00:08:27,360 --> 00:08:30,180
so in the future it's going to be fine for everybody

00:08:30,180 --> 00:08:32,340
so there's an archive right now.

00:08:33,460 --> 00:08:35,710
And, that's it.

00:08:35,710 --> 00:08:37,810
Now, there are some things.

00:08:37,810 --> 00:08:39,240
Whoa, it's over there.

00:08:39,240 --> 00:08:40,360
All right.

00:08:40,360 --> 00:08:44,200
Which are not solved yet. We talked about them last year

00:08:46,360 --> 00:08:51,090
and the important outcome of last LPC was that

00:08:53,663 --> 00:08:56,240
all these things made some progress.

00:08:56,240 --> 00:08:58,850
So, now, today there's going to be talk

00:08:58,850 --> 00:09:00,890
about a creation tooling from Nicolai.

00:09:01,810 --> 00:09:06,117
It's working, so now we have something like automation tool

00:09:07,140 --> 00:09:10,840
for creating livepatches from a source code.

00:09:12,010 --> 00:09:13,810
To get the source code.

00:09:13,810 --> 00:09:14,690
There's going to be talk about

00:09:14,690 --> 00:09:16,650
our system state changes management.

00:09:16,650 --> 00:09:21,650
We talked about it a lot last year so now it's almost done.

00:09:22,130 --> 00:09:25,190
We will not talk about architecture support today.

00:09:26,150 --> 00:09:27,440
There's been some progress.

00:09:27,440 --> 00:09:31,330
So there's objtool for arm64 flying around.

00:09:31,330 --> 00:09:36,330
There are rumours about obj tool for s390 with org unwinder.

00:09:36,810 --> 00:09:38,340
So that's important.

00:09:38,340 --> 00:09:42,730
There's going to be talk about objtool for power pc.

00:09:43,700 --> 00:09:48,140
So now, a lot is coming in near future.

00:09:48,140 --> 00:09:50,650
We will not talk about userspace livepatching today.

00:09:50,650 --> 00:09:54,570
There's been some progress so maybe next year

00:09:54,570 --> 00:09:57,930
at LPC there's going to be talk about it to you.

00:09:57,930 --> 00:09:59,180
So, that's it.

00:09:59,180 --> 00:10:00,013
Questions?

00:10:04,090 --> 00:10:08,350
Okay, no. So, thank you and let's do the next talk.

00:10:09,514 --> 00:10:12,514
(audience clapping)

00:10:19,680 --> 00:10:20,961
And it's me again.

00:10:20,961 --> 00:10:24,110
(audience laughing)

00:10:24,110 --> 00:10:26,710
So, rethinking late kernel module patching.

00:10:26,710 --> 00:10:30,590
So, now, we have a feature which we like

00:10:30,590 --> 00:10:33,380
and don't like much at the same time.

00:10:33,380 --> 00:10:38,380
So, imagine that you like a special function in a module.

00:10:38,450 --> 00:10:39,670
Now, the problem is, of course,

00:10:39,670 --> 00:10:43,170
that you don't know if that module is

00:10:43,170 --> 00:10:46,720
or is not loaded when you patch it.

00:10:46,720 --> 00:10:51,720
So, if it is not, that module has to be patched on load

00:10:54,200 --> 00:10:56,460
and before it is being executed.

00:10:59,850 --> 00:11:02,990
We have a solution in the kernel.

00:11:02,990 --> 00:11:07,500
So, we don't use module dependencies,

00:11:07,500 --> 00:11:11,730
which could be perceived as a go-to solution.

00:11:12,720 --> 00:11:16,100
I'll talk about it a little later.

00:11:17,410 --> 00:11:22,410
We solve it by something quite similar to module notifiers.

00:11:22,620 --> 00:11:24,890
So, we have hooks in kernel module loader

00:11:24,890 --> 00:11:26,550
so whenever a module is loaded

00:11:26,550 --> 00:11:31,160
we check if there's a patch for that module in the system.

00:11:31,160 --> 00:11:34,690
And if it is not, that module is patched.

00:11:34,690 --> 00:11:39,690
Now, the problem is that it leads to some ugly code.

00:11:39,960 --> 00:11:43,410
Let's talk about it like that.

00:11:44,550 --> 00:11:49,180
Because there are some arch specific things in the kernel.

00:11:49,180 --> 00:11:52,274
So, relocations, alternatives,

00:11:52,274 --> 00:11:55,230
parainstructions, static keys.

00:11:55,230 --> 00:11:57,310
And this is only x86.

00:11:57,310 --> 00:12:02,150
There are some other things on different architectures.

00:12:02,150 --> 00:12:06,850
And, for example, all the things are currently

00:12:07,780 --> 00:12:12,030
resolved in the kernel module but if you don't,

00:12:12,890 --> 00:12:15,610
if you patch a module which is not loaded yet,

00:12:15,610 --> 00:12:17,500
and so you do it later,

00:12:17,500 --> 00:12:21,900
you need to solve all these issues later as well.

00:12:21,900 --> 00:12:24,905
So, what we do is that we take all those

00:12:24,905 --> 00:12:27,220
ELF sections, which are important,

00:12:30,780 --> 00:12:34,540
rename them so the kernel module does not see them,

00:12:34,540 --> 00:12:36,550
and we process them later.

00:12:36,550 --> 00:12:39,534
So, all the relocations, which are important,

00:12:39,534 --> 00:12:40,980
are resolved later.

00:12:41,940 --> 00:12:44,680
And because alternatives and parainstructions,

00:12:44,680 --> 00:12:47,930
all those things have to be applied

00:12:47,930 --> 00:12:50,930
after the relocations are resolved.

00:12:50,930 --> 00:12:54,420
We do the same even for that.

00:12:54,420 --> 00:12:59,420
Now, it works but it's fragile.

00:12:59,610 --> 00:13:02,650
And of course it's unmaintainable in the long term

00:13:02,650 --> 00:13:05,680
because you never know, there could be a new

00:13:05,680 --> 00:13:08,150
arch specific feature later

00:13:08,150 --> 00:13:11,920
and we would need to solve it again, and again, and again.

00:13:11,920 --> 00:13:16,920
And now, there's now in-kernel notifier

00:13:17,000 --> 00:13:19,410
living in the server which would tell you

00:13:19,410 --> 00:13:21,630
there's a new feature which is interesting for you.

00:13:21,630 --> 00:13:23,830
So, it doesn't work like this.

00:13:23,830 --> 00:13:25,860
So, alternative solutions.

00:13:27,420 --> 00:13:29,520
Beagle introduce module dependencies.

00:13:29,520 --> 00:13:34,490
So, now it will be just as every patching module would be,

00:13:34,490 --> 00:13:37,390
every livepatch would be like ordinary module.

00:13:37,390 --> 00:13:41,040
So, it would load all those modules,

00:13:42,560 --> 00:13:44,360
which are supposed to be patched.

00:13:44,360 --> 00:13:47,200
Which would mean that you would load even

00:13:47,200 --> 00:13:49,880
those modules you don't really need.

00:13:49,880 --> 00:13:54,740
I don't know, USB, when you don't need USB at all,

00:13:56,360 --> 00:13:58,030
anything for our systems.

00:13:58,030 --> 00:13:59,130
I don't know what.

00:13:59,130 --> 00:14:02,450
So, maybe this is not the best solution

00:14:02,450 --> 00:14:03,980
because I really don't like it.

00:14:03,980 --> 00:14:06,690
It's just, it's pointless to do.

00:14:06,690 --> 00:14:08,880
There might be even be issues with that.

00:14:08,880 --> 00:14:11,080
Because there are customers who don't like,

00:14:11,080 --> 00:14:13,230
or who would not like this behavior at all.

00:14:14,570 --> 00:14:17,365
There was an idea to half-load them.

00:14:17,365 --> 00:14:22,365
So, those modules would be loaded but only initialized,

00:14:24,570 --> 00:14:29,570
patched, and they would be hidden from the system in a fact.

00:14:30,220 --> 00:14:32,460
So, that was one idea.

00:14:33,550 --> 00:14:37,010
Then the other one was that we could split,

00:14:37,010 --> 00:14:40,240
now there's one monolithic livepatch.

00:14:40,240 --> 00:14:43,080
So, we could split the livepatch to

00:14:43,080 --> 00:14:44,170
their object life patches.

00:14:44,170 --> 00:14:47,750
So, there would be a livepatch for IBM Linux

00:14:47,750 --> 00:14:50,410
and then for each and every to-be-patched module.

00:14:51,550 --> 00:14:56,120
Yes, that could work, but it will also introduce some,

00:14:57,880 --> 00:15:01,770
maybe, problems in our atomic replace infrastructure.

00:15:03,890 --> 00:15:05,910
Maybe, not unsolvable,

00:15:05,910 --> 00:15:09,530
but there should be a code before that.

00:15:09,530 --> 00:15:11,150
So, no one knows.

00:15:11,150 --> 00:15:14,650
We could introduce something like per-object consistency

00:15:14,650 --> 00:15:17,030
but there are problems with it too, I think,

00:15:17,030 --> 00:15:20,170
so it's not the best solution either.

00:15:20,170 --> 00:15:22,640
So, there are also disadvantages.

00:15:22,640 --> 00:15:27,630
And then there was something like Blue Sky idea from Joe.

00:15:27,630 --> 00:15:31,720
So, we could livepatch only loaded modules.

00:15:31,720 --> 00:15:35,200
And if a module is not loaded we can replace, for example,

00:15:35,200 --> 00:15:40,200
we can replace that file with a kernel module just on disc.

00:15:41,620 --> 00:15:44,690
And blacklist some vulnerable versions.

00:15:44,690 --> 00:15:49,690
So, but, well, that would introduce a maintenance burden

00:15:50,030 --> 00:15:54,140
and even an implementation burden on users in a way

00:15:54,140 --> 00:15:56,800
that now you don't, in my opinion,

00:15:56,800 --> 00:15:59,700
now you don't know what to livepatch.

00:15:59,700 --> 00:16:01,350
So, you don't know which version

00:16:01,350 --> 00:16:03,610
of the module is even loaded.

00:16:03,610 --> 00:16:05,400
So, I don't know.

00:16:05,400 --> 00:16:07,760
So, those are three alternatives.

00:16:07,760 --> 00:16:09,910
Three different solutions to the problem.

00:16:12,946 --> 00:16:15,060
Now, at the start of the discussion,

00:16:15,060 --> 00:16:19,180
because, I think I don't like any of these, to be honest.

00:16:19,180 --> 00:16:21,250
I don't like the kernel solution as well.

00:16:21,250 --> 00:16:26,250
But, I think it's maybe the best one of those introduced.

00:16:27,660 --> 00:16:31,873
So, I'm always pointing to there which it's there.

00:16:31,873 --> 00:16:33,422
So, it doesn't matter.

00:16:33,422 --> 00:16:35,960
(audience laughs)

00:16:35,960 --> 00:16:37,220
(microphone feedback)

00:16:37,220 --> 00:16:38,053
Sorry.

00:16:38,950 --> 00:16:40,978
So, my proposal would be to --

00:16:40,978 --> 00:16:43,306
(microphone feedback)

00:16:43,306 --> 00:16:45,090
To, just, okay.

00:16:45,090 --> 00:16:48,610
My proposal would be to do something different so

00:16:48,610 --> 00:16:51,140
let's go back through current solution.

00:16:51,140 --> 00:16:53,640
And, let's make it better.

00:16:53,640 --> 00:16:55,656
So, for example, we could, I think,

00:16:55,656 --> 00:16:58,520
now that we have selftests.

00:16:58,520 --> 00:17:01,996
We could and we should implement selftests for

00:17:01,996 --> 00:17:06,996
all those problematic issues and livepatches.

00:17:07,450 --> 00:17:11,720
So, lads, if there, if we have issues with jump tables,

00:17:11,720 --> 00:17:16,720
so let's introduce selftests for all those

00:17:17,340 --> 00:17:20,380
creative things that could happen with jump tables.

00:17:21,380 --> 00:17:23,880
I think, yeah, it's a lot of work.

00:17:23,880 --> 00:17:26,050
But, it could help us in the long term,

00:17:26,050 --> 00:17:28,910
as well, for different kind of reasons.

00:17:28,910 --> 00:17:33,620
And, we could even, I said there's no notifier about

00:17:33,620 --> 00:17:36,550
new features in the kernel arch specific features

00:17:36,550 --> 00:17:39,330
but we could have it.

00:17:39,330 --> 00:17:41,520
I mean, I mean, we could have a tool

00:17:41,520 --> 00:17:45,290
which would have a byte list of known things.

00:17:45,290 --> 00:17:49,130
Like, so we know how to deal with relocations.

00:17:49,130 --> 00:17:51,040
We know how to deal with alternatives

00:17:52,572 --> 00:17:53,910
and parainstructions right now.

00:17:53,910 --> 00:17:58,100
And, there could be a tool which would say,

00:17:58,100 --> 00:17:59,500
"Okay so there's a livepatch

00:17:59,500 --> 00:18:01,450
"and there's a thing I don't know about

00:18:02,420 --> 00:18:04,620
"so it's probably a new feature.

00:18:04,620 --> 00:18:06,270
"You should take a look at this."

00:18:11,910 --> 00:18:13,840
- Yeah there's also the case where

00:18:13,840 --> 00:18:18,840
an existing section, like the format of it changes, right?

00:18:20,400 --> 00:18:23,880
So, let's say you add a field to the alternative struct.

00:18:23,880 --> 00:18:25,020
- Yes.

00:18:25,020 --> 00:18:26,670
- Then the tooling may or may not notice that.

00:18:26,670 --> 00:18:27,760
- Yes. - Right?

00:18:27,760 --> 00:18:28,750
- Yes.

00:18:28,750 --> 00:18:29,583
So, maybe.

00:18:29,583 --> 00:18:30,433
Okay, so the tool

00:18:32,340 --> 00:18:34,940
should be produced like checking that.

00:18:34,940 --> 00:18:38,540
I mean, something similar to x86 instruction decoder

00:18:38,540 --> 00:18:41,780
because there are 232 implementations in the kernel

00:18:41,780 --> 00:18:43,950
right now thanks to only two.

00:18:43,950 --> 00:18:47,470
And there's a syncronizing code,

00:18:47,470 --> 00:18:52,190
so there's a script which does just calls DIFF

00:18:52,190 --> 00:18:53,690
on test versions

00:18:53,690 --> 00:18:55,900
and if there's a difference it synchronizes it.

00:18:55,900 --> 00:18:58,640
So, just maybe something like this?

00:19:00,529 --> 00:19:01,362
- Yeah.

00:19:05,200 --> 00:19:06,033
- [Audience Member] Just have a question

00:19:06,033 --> 00:19:07,130
about the Blue Sky idea.

00:19:07,130 --> 00:19:10,570
How would that actually work together with module signing

00:19:10,570 --> 00:19:14,750
if you are patching the on disc version of binary.

00:19:14,750 --> 00:19:16,740
- Oh, yeah. Also, that's a good point.

00:19:18,780 --> 00:19:22,620
- I think the idea was to patch it at build time.

00:19:22,620 --> 00:19:27,390
You take the original module, attach some livepatch.

00:19:29,360 --> 00:19:30,490
Well, this was one of the ideas.

00:19:30,490 --> 00:19:32,460
Attach some kind of livepatch blob to it

00:19:32,460 --> 00:19:37,460
so it becomes like a self signing, or self patching module.

00:19:37,620 --> 00:19:42,030
- So, it would heal itself, on loading.

00:19:45,135 --> 00:19:47,660
- Another kind of variation on this idea

00:19:47,660 --> 00:19:50,710
of keeping what we have today, but improving it.

00:19:52,140 --> 00:19:53,300
We could, for example, this is

00:19:53,300 --> 00:19:55,050
something that Nicolai mentioned to me today.

00:19:55,050 --> 00:19:57,570
We could, for example, disallow like

00:19:59,640 --> 00:20:03,130
jump labels in patched code.

00:20:03,980 --> 00:20:07,610
Or, we could have tooling that would force that.

00:20:07,610 --> 00:20:12,480
And as an alternative to that, you could just check.

00:20:12,480 --> 00:20:15,170
You could do a non static jump conditional

00:20:15,170 --> 00:20:18,450
so you could check whether the enabled bit

00:20:18,450 --> 00:20:21,100
is set at run time, rather than

00:20:21,100 --> 00:20:23,370
patching the nock or the jump.

00:20:28,170 --> 00:20:29,003
- Yes, sorry.

00:20:31,880 --> 00:20:32,720
- Go ahead.

00:20:32,720 --> 00:20:37,410
- I wonder if there is a possibility

00:20:37,410 --> 00:20:40,329
to actually detect these new features, for example,

00:20:40,329 --> 00:20:45,110
if they all make some section in the ELF formats.

00:20:45,110 --> 00:20:50,110
So, maybe we could check all built modules

00:20:50,400 --> 00:20:52,740
and their ELF sections

00:20:52,740 --> 00:20:55,660
and check if we are able to handle all of them.

00:20:55,660 --> 00:20:58,910
So, if there is a new feature then there might appear

00:20:58,910 --> 00:21:01,510
in the build of the entire kernel new section

00:21:01,510 --> 00:21:03,820
that we are not able to deal with.

00:21:03,820 --> 00:21:07,090
- Yes, yes, this was an assumption, something like this.

00:21:08,060 --> 00:21:08,893
Steve?

00:21:10,150 --> 00:21:11,607
- What's the problem with jump tables?

00:21:11,607 --> 00:21:15,880
Or you said, wait, basically, static calls?

00:21:16,810 --> 00:21:17,643
- Yeah.

00:21:17,643 --> 00:21:18,490
- No, that's not static calls.

00:21:18,490 --> 00:21:19,323
Static keys.

00:21:19,323 --> 00:21:20,510
- Yeah, the static keys.

00:21:22,876 --> 00:21:25,313
We haven't implemented static calls yet.

00:21:25,313 --> 00:21:26,146
(audience laughs)

00:21:26,146 --> 00:21:26,979
In the future.

00:21:26,979 --> 00:21:27,820
No, static keys.

00:21:27,820 --> 00:21:28,920
Why is that a problem?

00:21:30,060 --> 00:21:30,893
Reason why I'm saying that is

00:21:30,893 --> 00:21:34,110
because you have more than one jump table or label.

00:21:34,110 --> 00:21:35,550
Like, you can duplicate them.

00:21:35,550 --> 00:21:37,490
And, with the same key.

00:21:37,490 --> 00:21:39,230
If you use the same key, for like,

00:21:39,230 --> 00:21:42,090
say you if you have a function, you add a new function.

00:21:42,090 --> 00:21:43,670
And it will update both of them.

00:21:43,670 --> 00:21:45,730
- Yeah, I think the problem with that

00:21:45,730 --> 00:21:50,110
if you referenced existing static key in a different module,

00:21:50,110 --> 00:21:52,310
I mean, references in the livepatch

00:21:52,310 --> 00:21:55,080
so that is an ELF section with that location.

00:21:56,620 --> 00:22:00,060
- So, basically, it's adding a new self key.

00:22:00,060 --> 00:22:02,800
But then again, like you said, why, or no?

00:22:02,800 --> 00:22:04,020
- No, I don't think so.

00:22:04,020 --> 00:22:08,100
So, whenever that patch module is loaded, so,

00:22:08,100 --> 00:22:10,620
jump label infrastructure needs to know about

00:22:10,620 --> 00:22:15,620
this location and switch accordingly or not.

00:22:15,761 --> 00:22:18,260
(speaking off microphone)

00:22:18,260 --> 00:22:20,560
- So, there's something like.

00:22:20,560 --> 00:22:23,990
Okay, so, if you look at module finalized in

00:22:23,990 --> 00:22:27,940
arch x86 so there's a call to jump label apply something.

00:22:28,920 --> 00:22:33,920
So, whenever a module is loaded that function is called

00:22:34,430 --> 00:22:36,470
and those locations are processed

00:22:36,470 --> 00:22:38,040
and acted upon accordingly.

00:22:38,040 --> 00:22:40,390
So, I think this is the problem.

00:22:40,390 --> 00:22:41,670
- Wait, why is that a problem?

00:22:41,670 --> 00:22:44,550
- Because, when you load a patching module,

00:22:46,280 --> 00:22:49,020
that to be patched module --

00:22:49,020 --> 00:22:50,410
- Well, you have to find the state,

00:22:50,410 --> 00:22:51,510
I guess you have to find, make sure it's

00:22:51,510 --> 00:22:52,960
at the state as the old one?

00:22:52,960 --> 00:22:55,030
Or is it just don't know what the state will be?

00:22:55,030 --> 00:22:55,863
Is that the problem?

00:22:55,863 --> 00:22:56,696
- Yes, exactly.

00:22:56,696 --> 00:22:59,150
So, you don't know because that module isn't loaded at all.

00:22:59,150 --> 00:23:02,030
So, it's gonna be loaded maybe in a future

00:23:02,030 --> 00:23:04,880
and then you need to process it.

00:23:04,880 --> 00:23:07,860
At that moment, later in the future, not right now.

00:23:08,830 --> 00:23:10,520
- Wait, you're saying, for loading of a module

00:23:10,520 --> 00:23:12,300
it's a jump label.

00:23:12,300 --> 00:23:14,780
I thought the jump label would actually be there already.

00:23:14,780 --> 00:23:17,890
I guess I'm missing the actual problem.

00:23:17,890 --> 00:23:19,810
- Yeah, because the R2 modules anyway.

00:23:21,126 --> 00:23:23,880
- Yeah, it's like the one module that you patched it

00:23:23,880 --> 00:23:26,720
so when you apply the patch module,

00:23:28,200 --> 00:23:30,080
you still have the old and the new.

00:23:30,960 --> 00:23:34,320
- Let's say you're patching the KVM module

00:23:34,320 --> 00:23:36,270
but first you load the livepatch module

00:23:36,270 --> 00:23:38,120
and the KVM module isn't loaded yet.

00:23:39,120 --> 00:23:39,953
- Okay.

00:23:39,953 --> 00:23:41,810
- And there's a function in the KVM module

00:23:41,810 --> 00:23:43,680
that uses a static key.

00:23:43,680 --> 00:23:45,280
And the static key lives in KVM.

00:23:47,432 --> 00:23:49,140
The new version of the function of that in the

00:23:49,140 --> 00:23:52,990
livepatch module is not going to be able to be

00:23:52,990 --> 00:23:57,990
fully initialized if it still has that same static key.

00:23:58,020 --> 00:24:00,170
Because the static key doesn't exist yet.

00:24:00,170 --> 00:24:03,560
So, it's going to try to initialize it and try to --

00:24:03,560 --> 00:24:05,520
- How do you handle global, or not global variables,

00:24:05,520 --> 00:24:08,587
but variables pulled into a module.

00:24:08,587 --> 00:24:10,737
- Well, it's not pulled in.

00:24:10,737 --> 00:24:11,570
We make an external reference to it.

00:24:11,570 --> 00:24:13,230
So, we go find it, wherever it is.

00:24:14,590 --> 00:24:15,940
So, when that jump label inits,

00:24:15,940 --> 00:24:18,370
it's going to try to access that key in KVM

00:24:19,482 --> 00:24:20,315
but it's not there yet.

00:24:20,315 --> 00:24:22,480
So, our current architecture is to delay

00:24:22,480 --> 00:24:27,340
that jump label initialization until KVM is loaded.

00:24:27,340 --> 00:24:31,230
And then we do the initialization specific

00:24:31,230 --> 00:24:34,100
to that KVM module.

00:24:34,100 --> 00:24:35,000
- And why is that?

00:24:35,000 --> 00:24:36,570
Or you just don't like doing that?

00:24:36,570 --> 00:24:37,403
Or is it complex?

00:24:37,403 --> 00:24:38,240
- Yeah we don't like doing it.

00:24:38,240 --> 00:24:39,610
It's complex.

00:24:39,610 --> 00:24:41,630
We have to have a lot of arch specific codes.

00:24:41,630 --> 00:24:42,570
It's fragile.

00:24:42,570 --> 00:24:43,720
- Okay, that, okay.

00:24:43,720 --> 00:24:44,770
I think you just answered my question.

00:24:44,770 --> 00:24:45,603
Thank you.

00:24:49,110 --> 00:24:50,930
- So I think I understand.

00:24:52,110 --> 00:24:54,560
Jump labels are not supported if,

00:24:54,560 --> 00:24:55,740
as of now it's not supported,

00:24:55,740 --> 00:24:58,790
if the module is not yet loaded.

00:24:58,790 --> 00:25:00,670
- Sounds like you do kind of support it now

00:25:00,670 --> 00:25:02,110
but you don't plan on to.

00:25:02,110 --> 00:25:04,170
- Because, we are seeing. Sorry.

00:25:04,170 --> 00:25:06,350
- As of now, we don't support jump labels at all.

00:25:06,350 --> 00:25:08,550
I was speaking hypothetically because,

00:25:09,904 --> 00:25:11,180
just to simplify the discussion.

00:25:11,180 --> 00:25:12,620
In other cases we do that.

00:25:12,620 --> 00:25:14,920
Like, for alternatives and parawork patching

00:25:14,920 --> 00:25:16,150
we do what I described to you.

00:25:16,150 --> 00:25:19,520
And we would potentially do that for jump labels too,

00:25:19,520 --> 00:25:20,640
we just haven't implemented it yet

00:25:20,640 --> 00:25:21,990
because we're like, we're kind of

00:25:21,990 --> 00:25:23,580
tired of doing these hacks.

00:25:24,570 --> 00:25:27,130
- Yeah and of course, just a remark.

00:25:27,980 --> 00:25:30,530
It could be worked around in a livepatch

00:25:30,530 --> 00:25:33,490
because you can do all kinds of things in a livepatch.

00:25:33,490 --> 00:25:38,490
You can patch the patching module as well.

00:25:38,930 --> 00:25:40,980
You can patch the patching infrastructure

00:25:42,063 --> 00:25:42,930
living in the kernel so you can do all kinds of things.

00:25:42,930 --> 00:25:45,750
So, even the jump label things

00:25:45,750 --> 00:25:47,550
could be somehow worked around.

00:25:47,550 --> 00:25:51,840
- Yeah, but if the module is already loaded like

00:25:51,840 --> 00:25:53,500
pair the static key or leaves,

00:25:53,500 --> 00:25:56,030
if it's already loaded it should be able to patch it, right?

00:25:56,030 --> 00:25:58,900
Because, but when we create a livepatch

00:25:58,900 --> 00:26:01,060
we are seeing a message saying that jump labels

00:26:01,060 --> 00:26:04,290
are not supported yet, use static key falls instead.

00:26:04,290 --> 00:26:05,130
Is that a different?

00:26:05,130 --> 00:26:06,330
- Is that K patch build?

00:26:08,670 --> 00:26:11,312
Is that a K patch build error message that you're seeing?

00:26:11,312 --> 00:26:13,401
- [Man In Black Shirt] Yeah.

00:26:13,401 --> 00:26:14,602
- So, I can't answer that.

00:26:14,602 --> 00:26:16,772
(laughter)

00:26:16,772 --> 00:26:20,040
- Yeah, we recently added that error message

00:26:21,530 --> 00:26:24,380
because we don't support jump labels yet, so.

00:26:26,490 --> 00:26:28,700
Well, trace points are different.

00:26:28,700 --> 00:26:30,090
We do support trace points.

00:26:30,090 --> 00:26:33,100
I know those are jump labels but they're different

00:26:33,100 --> 00:26:38,100
because in that case you want to create a new static key

00:26:38,400 --> 00:26:43,150
associated with that trace point in the patch module.

00:26:43,150 --> 00:26:45,360
You don't want it to be the same one so like,

00:26:45,360 --> 00:26:46,193
I guess you could,

00:26:46,193 --> 00:26:48,890
but the way we implemented is you can enable trace point

00:26:48,890 --> 00:26:50,110
in the original version of the function

00:26:50,110 --> 00:26:51,640
or the patched version of the function.

00:26:51,640 --> 00:26:53,970
- Like I said we just don't do it.

00:26:53,970 --> 00:26:56,020
We follow the other way.

00:26:56,020 --> 00:26:59,090
So, you reference the original static key.

00:26:59,090 --> 00:27:01,850
But there's all those thrace board macros

00:27:01,850 --> 00:27:04,770
could be changed, a bit.

00:27:04,770 --> 00:27:07,450
Not improved, but changed a bit to reference

00:27:07,450 --> 00:27:11,290
the static key living elsewhere and we just

00:27:11,290 --> 00:27:15,010
acquire that elsewhere the address in a different way.

00:27:15,010 --> 00:27:16,590
So, it's just call sims.

00:27:18,380 --> 00:27:19,230
That can be done.

00:27:20,077 --> 00:27:22,580
(audience member speaking off microphone)

00:27:22,580 --> 00:27:23,413
Yeah.

00:27:24,610 --> 00:27:26,560
- Yeah, that would be another complication.

00:27:27,512 --> 00:27:29,362
I don't know who came out with that idea anyway.

00:27:29,362 --> 00:27:32,362
(audience laughing)

00:27:37,824 --> 00:27:40,050
Any more question or idea?

00:27:40,050 --> 00:27:41,200
Ideas would be welcome.

00:27:48,370 --> 00:27:49,850
Okay, so nothing?

00:27:55,382 --> 00:27:56,215
So, no issue?

00:27:56,215 --> 00:27:57,060
Concluded somehow.

00:27:57,060 --> 00:27:58,750
So, what's the conclusion?

00:27:58,750 --> 00:28:02,260
So, are we gonna think about a different solution

00:28:03,840 --> 00:28:06,810
or should so we go with the current one

00:28:06,810 --> 00:28:11,050
and improve it in a way I was talking about?

00:28:16,730 --> 00:28:17,770
Yes, Massami.

00:28:17,770 --> 00:28:19,800
- Yeah, I think that there it seems that

00:28:19,800 --> 00:28:24,800
the current solution is a bit away to solve that this issue.

00:28:27,020 --> 00:28:32,020
Because, we'll say, simplify or that

00:28:32,230 --> 00:28:35,540
the just make it simple,

00:28:36,470 --> 00:28:40,410
like architecture dependent code,

00:28:41,994 --> 00:28:46,427
you can make other simple interface for

00:28:48,872 --> 00:28:51,990
such kind of self modifying code

00:28:53,470 --> 00:28:58,470
to the update later, you know.

00:29:01,950 --> 00:29:03,890
- So, you think, you like our current approach?

00:29:03,890 --> 00:29:04,840
Is that what you're saying?

00:29:04,840 --> 00:29:08,260
- Yeah, current approach, yeah, it seems

00:29:09,443 --> 00:29:11,450
that the model is very good.

00:29:11,450 --> 00:29:13,790
- I mean, we thought we liked it too.

00:29:13,790 --> 00:29:16,135
Like a few years ago, when we implemented it.

00:29:16,135 --> 00:29:17,320
(audience laughs)

00:29:17,320 --> 00:29:21,070
But, it seems to be a source of a large percentage of our,

00:29:22,250 --> 00:29:24,210
sizable percentage of our bugs.

00:29:24,210 --> 00:29:26,720
And the bugs can be, they can range anywhere

00:29:26,720 --> 00:29:28,690
from completely innocuous to

00:29:28,690 --> 00:29:30,330
panic your system and you don't really --

00:29:30,330 --> 00:29:34,440
- Yeah, but anyway, maybe you need to implement

00:29:34,440 --> 00:29:37,340
somewhere test cases for such

00:29:37,340 --> 00:29:40,780
your kernel cases so that they're.

00:29:40,780 --> 00:29:42,390
- Well, the problem is like with the jump labels

00:29:42,390 --> 00:29:45,840
we recently discovered that we had a bug there

00:29:45,840 --> 00:29:47,650
that we wouldn't have had test cases,

00:29:47,650 --> 00:29:49,603
we didn't implement it.

00:29:49,603 --> 00:29:52,410
So, the problem is every architecture has its own,

00:29:52,410 --> 00:29:56,647
kind of, quirks and special sections in patching things.

00:29:58,907 --> 00:30:01,250
- At the same time, it's not that bad.

00:30:01,250 --> 00:30:02,919
The arch works well.

00:30:02,919 --> 00:30:07,698
- I'm not sure that the sections

00:30:07,698 --> 00:30:10,590
are architecture dependent or

00:30:10,590 --> 00:30:12,850
architecture some system dependent.

00:30:15,196 --> 00:30:16,596
- It depends on the feature.

00:30:18,300 --> 00:30:22,790
Alternatives and para work patching instructions

00:30:22,790 --> 00:30:25,600
are arch specific.

00:30:25,600 --> 00:30:27,390
- [Massami] Oh, yeah, right.

00:30:27,390 --> 00:30:30,650
- Jump labels might be arch independent.

00:30:30,650 --> 00:30:32,220
- If you're worried about jump labels itself

00:30:32,220 --> 00:30:34,340
I think that's something it's one of the relatively

00:30:34,340 --> 00:30:36,535
new ones and I think it's.

00:30:36,535 --> 00:30:39,610
When the artica had the same problem with implementing,

00:30:39,610 --> 00:30:41,270
or you know, we had with interrupts,

00:30:41,270 --> 00:30:42,850
everyone implemented interrupts differently

00:30:42,850 --> 00:30:45,420
so we just went through and said,

00:30:45,420 --> 00:30:46,500
Thomas Lecture said screw it

00:30:46,500 --> 00:30:49,270
and we make all architectures do interrupts the same

00:30:50,540 --> 00:30:52,190
And implemented that, and that made RT

00:30:52,190 --> 00:30:54,860
a hell of a lot easier to go forward.

00:30:54,860 --> 00:30:55,930
We could do the same thing.

00:30:55,930 --> 00:31:00,370
Our problem with jump labels, I don't know who's the,

00:31:00,370 --> 00:31:01,939
Jason, is it Jason? Who's the--

00:31:01,939 --> 00:31:03,010
- Barron?

00:31:03,010 --> 00:31:03,843
- [Miroslav] Jason Barron.

00:31:03,843 --> 00:31:04,960
- Is he still, I haven't seen him in awhile

00:31:04,960 --> 00:31:06,060
- [Miroslav] No, he's not here, I think.

00:31:06,060 --> 00:31:09,620
- Yeah, I haven't seen him in awhile so he's sort of MIA

00:31:09,620 --> 00:31:13,780
a little bit but I'm all for making jump labels easier

00:31:13,780 --> 00:31:16,320
across archs and if that makes it easier for you it's

00:31:16,320 --> 00:31:18,590
basically, like, I personally

00:31:18,590 --> 00:31:20,930
don't care about live kernel patching

00:31:20,930 --> 00:31:23,830
but those that don't care about RT,

00:31:23,830 --> 00:31:26,720
the way we got it in was we made their code better

00:31:26,720 --> 00:31:29,520
so if we can make jump labels better and 'cause --

00:31:29,520 --> 00:31:30,580
- Maybe alternatives too.

00:31:30,580 --> 00:31:34,450
Like maybe we can have generic alternatives

00:31:34,450 --> 00:31:37,120
and parainstructions, yeah.

00:31:37,120 --> 00:31:39,820
- So, my point is, let's not find hacks

00:31:39,820 --> 00:31:41,650
around each architecture.

00:31:41,650 --> 00:31:45,461
Let's take back, let's say if we could fix the

00:31:45,461 --> 00:31:49,060
problem area to be easier for you

00:31:49,060 --> 00:31:51,416
and at the same time make it easier for everyone.

00:31:51,416 --> 00:31:53,580
'Cause that'll be a benefit.

00:31:53,580 --> 00:31:55,730
So those that don't care about live kernel patching

00:31:55,730 --> 00:31:58,500
if you start changing things to make it easier for people

00:31:58,500 --> 00:32:00,866
then people will start liking you.

00:32:00,866 --> 00:32:01,699
That's kinda how RT got it.

00:32:01,699 --> 00:32:03,590
'Cause no one cared about RT but when we started

00:32:03,590 --> 00:32:06,520
improving things all the time then people are like,

00:32:06,520 --> 00:32:07,970
"Oh, this is actually kind of cool.

00:32:07,970 --> 00:32:10,004
"They're helping us."

00:32:10,004 --> 00:32:14,020
- And that would make objtools life easier too, right?

00:32:14,020 --> 00:32:15,770
And probably plenty of other tools.

00:32:19,790 --> 00:32:20,623
- Oh, question.

00:32:22,290 --> 00:32:24,250
- Just a comment, I think conceptually

00:32:24,250 --> 00:32:26,760
the current approach seems

00:32:26,760 --> 00:32:30,210
the better one, just conceptually.

00:32:30,210 --> 00:32:34,210
I know it has been a source of bugs though maintaining

00:32:34,210 --> 00:32:36,990
a fleet which will have lots of livepatches,

00:32:36,990 --> 00:32:39,640
let's say, or patches that keep coming in.

00:32:40,520 --> 00:32:42,410
That approach probably works better.

00:32:43,720 --> 00:32:45,260
However, of the alternatives,

00:32:45,260 --> 00:32:47,740
what is the most appealing to you right now?

00:32:47,740 --> 00:32:50,300
To solve the problems that you have currently?

00:32:52,234 --> 00:32:54,840
From the discussion, it kind of felt like the Blue Sky

00:32:54,840 --> 00:32:59,610
idea is taking, it seems like the most appealing.

00:32:59,610 --> 00:33:03,180
- Okay, so, the first one would be the simplest.

00:33:03,180 --> 00:33:04,150
- [Man In Blue Shirt] Yes.

00:33:04,150 --> 00:33:06,550
- Because to introduce the dependencies is easy.

00:33:07,385 --> 00:33:08,440
- [Man In Blue Shirt] Exactly, and we

00:33:08,440 --> 00:33:10,010
did not discuss it enough.

00:33:10,010 --> 00:33:11,370
In my view, so.

00:33:11,370 --> 00:33:15,611
- Yes, but I think, so, it's not a technical problem

00:33:15,611 --> 00:33:18,730
I think the problem is on the user's,

00:33:18,730 --> 00:33:20,520
or our customer's side.

00:33:20,520 --> 00:33:23,860
Because I think some of them would be

00:33:23,860 --> 00:33:27,190
really unhappy with loading unneeded modules.

00:33:27,190 --> 00:33:30,170
Because they have a fixed set of modules

00:33:30,170 --> 00:33:31,770
which are allowed and that's it.

00:33:33,700 --> 00:33:35,850
And not only modules, packages, everything.

00:33:36,890 --> 00:33:38,990
- I mean, they are either compiled or not.

00:33:40,000 --> 00:33:42,360
If they are compiling available on the system,

00:33:43,410 --> 00:33:44,670
they expect them to be loaded.

00:33:44,670 --> 00:33:47,200
- No, we live in a distribution world

00:33:47,200 --> 00:33:49,930
so it's set on our side.

00:33:50,870 --> 00:33:52,830
- [Audience Member] So, we could also split them into

00:33:52,830 --> 00:33:56,490
different packages and then some of them might be optional.

00:33:56,490 --> 00:33:57,323
- [Audience Member] Yeah.

00:33:57,323 --> 00:33:59,452
- [Audience Member] And also, I think that there's

00:33:59,452 --> 00:34:03,580
some customers also do some images of installed system

00:34:03,580 --> 00:34:06,830
that they distribute to their

00:34:06,830 --> 00:34:10,960
computers and they have just what they need there.

00:34:10,960 --> 00:34:13,620
- Now, the problem with that is how do you split out

00:34:13,620 --> 00:34:15,540
the livepatches that you've built.

00:34:15,540 --> 00:34:17,140
What goes into the base package

00:34:17,140 --> 00:34:19,690
and how do you split out livepatches?

00:34:19,690 --> 00:34:22,820
- Of course, but, yeah, that's a problem.

00:34:22,820 --> 00:34:25,950
And the other one is that this is, of course,

00:34:26,850 --> 00:34:30,720
all hypothetics because we don't know much

00:34:30,720 --> 00:34:32,530
about our customers usage.

00:34:33,950 --> 00:34:36,930
So, just it could be a good idea.

00:34:36,930 --> 00:34:37,920
Maybe not.

00:34:37,920 --> 00:34:38,753
No one knows.

00:34:38,753 --> 00:34:41,220
But I'm hesitant to even try it.

00:34:43,493 --> 00:34:44,572
- [Man In Blue Shirt] Why?

00:34:44,572 --> 00:34:46,766
- Just can't.

00:34:46,766 --> 00:34:50,190
- Okay, so, right.

00:34:50,190 --> 00:34:51,640
So, that's not the good reason.

00:34:51,640 --> 00:34:53,020
I think you agree with that as well.

00:34:53,020 --> 00:34:54,400
It's just.

00:34:54,400 --> 00:34:56,320
- Well, well it's a good reason

00:34:56,320 --> 00:34:59,570
if you care about your customers or care about your users.

00:34:59,570 --> 00:35:01,361
So, you just don't want to --

00:35:01,361 --> 00:35:03,450
- But, what I mean is there is no data

00:35:03,450 --> 00:35:05,300
to justify it either way, right now.

00:35:05,300 --> 00:35:06,260
- [Miroslav] Yes, that's true.

00:35:06,260 --> 00:35:07,780
- And that's why it's not a good reason

00:35:07,780 --> 00:35:09,649
to rule it out right now.

00:35:09,649 --> 00:35:10,720
- [Miroslav] Yes.

00:35:10,720 --> 00:35:12,980
- Yeah. Okay, but.

00:35:14,830 --> 00:35:17,900
- It could be because for exactly the same reason,

00:35:17,900 --> 00:35:19,060
because you don't know.

00:35:19,060 --> 00:35:23,520
So, the question is whether you like more

00:35:23,520 --> 00:35:27,390
to play on the safe side or not.

00:35:28,770 --> 00:35:33,340
Meaning, if you want to get your customers to

00:35:35,487 --> 00:35:37,680
a non-likeable situation or not.

00:35:37,680 --> 00:35:40,710
So, just, we don't, I think.

00:35:41,930 --> 00:35:43,970
- There was actually one more idea

00:35:43,970 --> 00:35:46,620
that's probably not mentioned there,

00:35:46,620 --> 00:35:51,620
actually, refuse load modules

00:35:54,180 --> 00:35:57,130
that could be livepatched

00:35:57,130 --> 00:35:59,950
and are not loaded at the moment when the

00:35:59,950 --> 00:36:01,760
livepatch was installed like.

00:36:03,490 --> 00:36:07,140
So that prevent loading modules that

00:36:08,070 --> 00:36:13,070
would have this troubles but it's also problematic because,

00:36:13,520 --> 00:36:18,520
for example, some USB devices just

00:36:18,710 --> 00:36:23,580
needed to load modules according to what device is attached.

00:36:24,610 --> 00:36:26,480
And we don't know what customers do.

00:36:26,480 --> 00:36:29,640
They might do some regular maintenance,

00:36:29,640 --> 00:36:30,770
or something like this.

00:36:30,770 --> 00:36:34,550
Or, in case of problems it might need to go there

00:36:34,550 --> 00:36:39,390
with some tool and attach it to solve something.

00:36:40,240 --> 00:36:42,220
It would prevent them.

00:36:42,220 --> 00:36:43,690
- So, so, oh go ahead.

00:36:43,690 --> 00:36:46,545
- So, one last thing is, I'm going to go back

00:36:46,545 --> 00:36:48,020
because I mentioned this a few years ago as I was saying.

00:36:48,020 --> 00:36:51,710
I still find it kind of stupid to be loading a module

00:36:51,710 --> 00:36:54,890
that you have to patch since you're loading it anyway

00:36:54,890 --> 00:36:58,160
what's the reason why you just can't fix that module,

00:36:58,160 --> 00:37:01,260
or have a way of at least patching it maybe patching it

00:37:01,260 --> 00:37:02,725
in user space or, and I know you have to sign it

00:37:02,725 --> 00:37:04,080
or something, probably.

00:37:04,080 --> 00:37:05,920
It's probably a signing issue.

00:37:05,920 --> 00:37:07,123
Is that the case, or?

00:37:11,500 --> 00:37:13,340
- Would you say that's the Blue Sky idea?

00:37:13,340 --> 00:37:14,340
- I think so.

00:37:14,340 --> 00:37:16,850
- So, that is one of the things we've considered.

00:37:18,280 --> 00:37:19,970
But it has some downsides as well.

00:37:19,970 --> 00:37:24,440
I think, also, the fact that we haven't discussed this,

00:37:24,440 --> 00:37:25,990
but we talked about this today,

00:37:27,230 --> 00:37:31,340
the fact that all the modules you're patching

00:37:31,340 --> 00:37:35,560
might not be loaded when you load it.

00:37:35,560 --> 00:37:36,630
The livepatch.

00:37:37,480 --> 00:37:40,890
That means that you still need to do, kind of,

00:37:40,890 --> 00:37:43,613
granular per object sections.

00:37:46,650 --> 00:37:51,640
So, we still might have that complexity of having

00:37:51,640 --> 00:37:55,080
per module jump label sections

00:37:55,080 --> 00:37:57,340
and per module alternative sections,

00:37:57,340 --> 00:37:58,600
and things like that.

00:37:58,600 --> 00:38:00,220
- And then it's not worth it.

00:38:00,220 --> 00:38:02,050
- Yeah, 'cause that would have been the big benefit of it,

00:38:02,050 --> 00:38:03,486
would be to get rid of those sections

00:38:03,486 --> 00:38:05,650
but might need them anyway.

00:38:07,680 --> 00:38:10,580
- And, the answer to your question is still the same.

00:38:10,580 --> 00:38:13,790
It's just, because you never know

00:38:13,790 --> 00:38:15,930
when you livepatch the system,

00:38:15,930 --> 00:38:18,930
the version of that existing loaded module.

00:38:18,930 --> 00:38:23,580
So, it could be the non-fixed one from a year ago,

00:38:23,580 --> 00:38:26,120
or it could be a new one fixed as to your proposal.

00:38:26,120 --> 00:38:27,320
So, you just don't know.

00:38:27,320 --> 00:38:29,970
So, you would have to have different

00:38:29,970 --> 00:38:32,010
or a couple versions of the livepatch.

00:38:32,010 --> 00:38:34,820
And apply them accordingly to what's in the system.

00:38:34,820 --> 00:38:36,280
And there's the problem.

00:38:36,280 --> 00:38:37,780
- I mean, so, it sounds like.

00:38:39,300 --> 00:38:42,023
Why do you have to have your livepatch module

00:38:42,023 --> 00:38:44,230
fix more than one module code.

00:38:44,230 --> 00:38:46,210
Can't you just make it one per module?

00:38:47,101 --> 00:38:50,650
- That's the second idea.

00:38:50,650 --> 00:38:51,920
- And, I mean, well this is part of that

00:38:51,920 --> 00:38:53,250
because then you do the whole thing

00:38:53,250 --> 00:38:55,340
and if the module is not there you just don't load it.

00:38:55,340 --> 00:38:58,770
Or, have a way of changing your tool to livepatch

00:38:58,770 --> 00:39:00,580
the actual module itself.

00:39:00,580 --> 00:39:02,890
So, when the module is loaded it just

00:39:02,890 --> 00:39:05,997
calls a different function at the point there.

00:39:05,997 --> 00:39:07,830
You might be able to have a.

00:39:07,830 --> 00:39:09,010
Have you looked into doing that?

00:39:09,010 --> 00:39:11,110
- So, Petrr, do you want?

00:39:11,110 --> 00:39:16,110
- So, it creates the complexity of generating

00:39:16,199 --> 00:39:21,199
livepatches because as we do it now,

00:39:22,720 --> 00:39:26,610
then we release some product and then do

00:39:26,610 --> 00:39:28,570
maintenance updates of the kernel.

00:39:29,450 --> 00:39:31,910
And together, we do maintenance update

00:39:31,910 --> 00:39:36,700
we also provide livepatches from the critical fixes

00:39:36,700 --> 00:39:40,190
for the already released kernels.

00:39:40,190 --> 00:39:41,630
Which means the original one

00:39:41,630 --> 00:39:45,510
and also the already released maintenance update.

00:39:45,510 --> 00:39:50,510
So, it means that the number of livepatches

00:39:51,710 --> 00:39:55,100
that we need to prepare is growing with the time.

00:39:56,170 --> 00:40:01,170
If we, together with the livepatch, also distribute

00:40:01,430 --> 00:40:06,430
different versions of the modules that can be loaded or not,

00:40:09,360 --> 00:40:14,360
then we will not only need to release increasing number

00:40:14,390 --> 00:40:17,980
of livepatches but we will have also, like

00:40:17,980 --> 00:40:21,270
for the same livepatch, support different versions

00:40:21,270 --> 00:40:23,900
of some module that has been fixed.

00:40:25,007 --> 00:40:26,850
- No, so, what I'm saying is why can't you do that.

00:40:26,850 --> 00:40:29,560
So, what you said was when you add a new livepatch,

00:40:29,560 --> 00:40:32,510
atomically you switch, which has already been patched.

00:40:32,510 --> 00:40:34,710
You throw out every everything in the whole,

00:40:35,791 --> 00:40:37,900
everything in that module or is it just?

00:40:37,900 --> 00:40:38,740
- Everything's patched.

00:40:38,740 --> 00:40:41,370
So, everything in all of those previous livepatches.

00:40:41,370 --> 00:40:43,370
- So, if I have function A patched

00:40:43,370 --> 00:40:45,365
and I add a new livepatch.

00:40:45,365 --> 00:40:50,198
(audience member speaking off microphone)

00:40:51,440 --> 00:40:53,320
So, you have.

00:40:55,440 --> 00:40:57,390
Say you have function A patched

00:40:57,390 --> 00:40:59,640
and then you add a new livepatch that patches function B,

00:40:59,640 --> 00:41:02,210
do you have to actually make it so it patches A and B again

00:41:02,210 --> 00:41:04,540
and just throw away the old data and make it AB again?

00:41:04,540 --> 00:41:06,480
Or do you just patch B

00:41:06,480 --> 00:41:08,380
and have two livepatches living at the same time?

00:41:08,380 --> 00:41:09,640
- No.

00:41:09,640 --> 00:41:10,473
The former one.

00:41:10,473 --> 00:41:12,930
So, you patch both in your livepatch.

00:41:12,930 --> 00:41:15,070
- So, that actually makes things really easy.

00:41:15,070 --> 00:41:16,680
This is, no, I'm saying is.

00:41:16,680 --> 00:41:18,370
Okay, so you go in,

00:41:18,370 --> 00:41:21,612
you could have your tool that loads this say,

00:41:21,612 --> 00:41:26,461
"This module doesn't exist and I need to patch it."

00:41:26,461 --> 00:41:29,370
If you know where that module exists,

00:41:29,370 --> 00:41:32,240
livepatch the actual module in user space,

00:41:32,240 --> 00:41:33,700
where it's not been loaded yet.

00:41:33,700 --> 00:41:35,060
You know where the address is.

00:41:35,060 --> 00:41:37,660
It has a no-op we're using ftrace.

00:41:37,660 --> 00:41:40,256
Just go change that no-op to point two-oh.

00:41:40,256 --> 00:41:44,660
So switch that to a jump to the new code and patch it.

00:41:44,660 --> 00:41:46,150
And you could have it in a separate section,

00:41:46,150 --> 00:41:48,400
so that you could throw it away and re-add it.

00:41:48,400 --> 00:41:51,390
So, when you do this you just constantly

00:41:51,390 --> 00:41:53,930
update the modules online.

00:41:53,930 --> 00:41:55,450
So, you don't have this crazy thing.

00:41:55,450 --> 00:41:56,860
It's either the modules are gonna be all.

00:41:56,860 --> 00:41:58,790
In fact, actually I would do that to all modules,

00:41:58,790 --> 00:42:00,980
regardless, so they unload it and load it.

00:42:00,980 --> 00:42:03,810
Now you have a direct, it's not using ftrace anymore,

00:42:03,810 --> 00:42:05,350
it's just doing a direct jump now.

00:42:05,350 --> 00:42:06,920
'Cause you could do this easily in

00:42:06,920 --> 00:42:09,800
user space because you don't have traces.

00:42:09,800 --> 00:42:10,710
Understand what I'm saying?

00:42:10,710 --> 00:42:13,500
So, if you have a section of where like a livepatch,

00:42:13,500 --> 00:42:15,240
or like, you know, fixed section

00:42:15,240 --> 00:42:17,640
and then you put the code of all the new functions

00:42:17,640 --> 00:42:21,160
in that section and that module in the dot KO module.

00:42:21,160 --> 00:42:22,660
And then when it's loaded,

00:42:22,660 --> 00:42:26,440
you don't touch the actual code but that no-op location

00:42:26,440 --> 00:42:29,697
just changes to be jump to the new guy.

00:42:32,401 --> 00:42:37,401
(audience member speaking off microphone)

00:42:37,610 --> 00:42:38,620
- You may be able.

00:42:38,620 --> 00:42:39,660
Module signing, yes.

00:42:39,660 --> 00:42:43,250
But the thing is, if you know you're going to update

00:42:43,250 --> 00:42:45,300
a new module this has got to be a livepatch

00:42:45,300 --> 00:42:49,038
so actually you could actually just update the new modules.

00:42:49,038 --> 00:42:53,871
(audience member speaking off microphone)

00:42:56,800 --> 00:42:58,450
- Which makes it a little bit more difficult

00:42:58,450 --> 00:43:01,300
when you want to actually be able to turn the patch on

00:43:01,300 --> 00:43:03,670
and off during run time which we currently support.

00:43:03,670 --> 00:43:05,370
You can actually revert the patch.

00:43:06,990 --> 00:43:09,540
- Actually it doesn't, because it's still a jump,

00:43:09,540 --> 00:43:13,450
you just remove it and then if you enable it again

00:43:13,450 --> 00:43:15,080
have it go through the old section.

00:43:15,080 --> 00:43:18,094
So, everything will be exactly, basically exactly, the same.

00:43:18,094 --> 00:43:22,927
(audience member speaking off microphone)

00:43:23,830 --> 00:43:26,610
- When you would do the replacing on disc,

00:43:26,610 --> 00:43:29,340
the whole KO rewriting, back and forth

00:43:29,340 --> 00:43:30,930
then you actually would have to store

00:43:30,930 --> 00:43:32,130
both versions somewhere,

00:43:33,150 --> 00:43:35,130
right, when you are switching the patch one off.

00:43:35,130 --> 00:43:36,374
- Yeah, but the thing is, like you said,

00:43:36,374 --> 00:43:39,160
it solves so many things.

00:43:39,160 --> 00:43:43,190
Much more than trying to fight all the, okay, you know,

00:43:43,190 --> 00:43:44,150
"I'm loading a module.

00:43:44,150 --> 00:43:46,750
"Now I have to bring it in later."

00:43:46,750 --> 00:43:50,360
That is much more complex than just doing

00:43:50,360 --> 00:43:53,660
everything on disc, and then loading it

00:43:53,660 --> 00:43:54,510
when you need to load it.

00:43:54,510 --> 00:43:56,100
And then you can actually monitor and see it.

00:43:56,100 --> 00:43:57,700
And you could just sign, maybe change it

00:43:57,700 --> 00:43:59,700
so you can have partial sign so you could actually

00:43:59,700 --> 00:44:02,880
have a double section in the module

00:44:02,880 --> 00:44:05,420
you could have signing for both of them, somehow.

00:44:06,537 --> 00:44:08,154
Your tool fixes it.

00:44:08,154 --> 00:44:10,340
(audience member speaking off microphone)

00:44:10,340 --> 00:44:14,850
- If we have signed modules and we have module

00:44:14,850 --> 00:44:18,620
which is unpatched which is staying on the hard drive

00:44:18,620 --> 00:44:21,450
and we want to patch it, we obviously would

00:44:21,450 --> 00:44:22,450
break the signature.

00:44:24,220 --> 00:44:27,819
In this case, our livepatch should also be signed, right?

00:44:27,819 --> 00:44:28,810
- Mmm-hmm.

00:44:28,810 --> 00:44:31,200
- Couldn't both files be combined

00:44:31,200 --> 00:44:34,470
and there are signatures to be checked together.

00:44:36,000 --> 00:44:38,810
So, if we are warding co-module,

00:44:39,826 --> 00:44:42,910
I suppose it has a header which says how long is the --

00:44:42,910 --> 00:44:43,743
- It's the ELF.

00:44:43,743 --> 00:44:47,690
- Yeah, so we can check whether the file is longer

00:44:47,690 --> 00:44:52,463
than that and to see at the end of the first ELF

00:44:53,330 --> 00:44:58,330
we have second elf, which is obviously the livepatch.

00:44:58,660 --> 00:45:02,420
We can then check the signature attached after that.

00:45:02,420 --> 00:45:07,090
- Yeah, that's exact. I mean, change the signatary code.

00:45:07,090 --> 00:45:07,923
- So, I'm saying is --

00:45:07,923 --> 00:45:09,200
- We're running out of time though.

00:45:09,200 --> 00:45:11,890
- Okay, so I just real quick, I really do

00:45:11,890 --> 00:45:14,180
strongly believe you should take a bigger effort.

00:45:14,180 --> 00:45:15,630
I have several ideas about this

00:45:15,630 --> 00:45:17,310
because I thought about this before from last time.

00:45:17,310 --> 00:45:18,870
I still think it's better.

00:45:18,870 --> 00:45:21,080
Especially since you're more worried about building on top.

00:45:21,080 --> 00:45:21,913
We're not building on top.

00:45:21,913 --> 00:45:23,200
We're just going to replace it.

00:45:23,200 --> 00:45:24,750
Having a separate section where the code is,

00:45:24,750 --> 00:45:26,780
so if you need to add a new livepatch,

00:45:26,780 --> 00:45:29,170
you just blow it and blow away the old one,

00:45:29,170 --> 00:45:31,360
put in the new section, and change it.

00:45:31,360 --> 00:45:32,840
And you should know what that,

00:45:32,840 --> 00:45:34,650
you could even put a signed signature in there

00:45:34,650 --> 00:45:37,170
because you should know what the end result is.

00:45:37,170 --> 00:45:38,670
So, you could do everything on your own things

00:45:38,670 --> 00:45:40,500
and when you supply the livepatching

00:45:40,500 --> 00:45:42,760
and you got to change the modules online you know

00:45:42,760 --> 00:45:45,380
exactly what the end result of those modules will be

00:45:45,380 --> 00:45:47,530
so you should easily just send a signature,

00:45:48,380 --> 00:45:50,970
and then update it and then that should already match.

00:45:54,580 --> 00:45:56,130
- And I think this should be in a separate file,

00:45:56,130 --> 00:45:58,950
rather than modifying the same KO.

00:45:58,950 --> 00:46:02,680
So, the module loading code should accommodate

00:46:02,680 --> 00:46:05,950
for an extra file which would probe for

00:46:05,950 --> 00:46:08,050
is there a livepatch available for this module

00:46:08,050 --> 00:46:09,780
and load that along with the module

00:46:09,780 --> 00:46:12,460
so the signing code remains separate as well.

00:46:12,460 --> 00:46:15,630
Also, it accommodates for the module removal case

00:46:15,630 --> 00:46:18,790
where a livepatch comes into the system,

00:46:18,790 --> 00:46:20,320
which is already loaded.

00:46:20,320 --> 00:46:23,100
Then you unload the module, the livepatch goes back.

00:46:23,100 --> 00:46:26,120
But then if you have a separate livepatch queue

00:46:26,120 --> 00:46:30,480
for that module on the disc, you can reload it again.

00:46:30,480 --> 00:46:31,330
Both of them.

00:46:31,330 --> 00:46:32,330
- Yeah, I like that.

00:46:34,669 --> 00:46:35,850
- Okay, we gotta move on.

00:46:36,990 --> 00:46:38,499
Thank you.

00:46:38,499 --> 00:46:41,499
(audience clapping)

00:46:45,728 --> 00:46:47,120
- Okay, who's next?

00:46:47,120 --> 00:46:49,040
- Is it my turn?

00:46:49,040 --> 00:46:50,850
- Yes, it is your turn.

00:46:57,980 --> 00:46:58,813
- Thanks.

00:47:01,480 --> 00:47:03,710
- Hi, my name is Nicolai Stange.

00:47:03,710 --> 00:47:07,910
I work for SUSE during the past last year

00:47:07,910 --> 00:47:11,860
on automating source-based livepatch creation,

00:47:11,860 --> 00:47:12,693
in particular.

00:47:14,590 --> 00:47:17,530
Who is not aware about the idea behind,

00:47:17,530 --> 00:47:21,180
or the concepts behind source-based livepatch creation?

00:47:21,180 --> 00:47:22,120
I assume everybody.

00:47:22,120 --> 00:47:23,270
Hands up, who knows it?

00:47:25,100 --> 00:47:27,240
Okay, so I make it really quick.

00:47:27,240 --> 00:47:30,460
So, what you usually want to have,

00:47:30,460 --> 00:47:33,180
or what we want to have is we want to create our

00:47:33,180 --> 00:47:37,390
livepatches as external modules in source code.

00:47:37,390 --> 00:47:40,310
Which means we have to copy everything from

00:47:40,310 --> 00:47:42,000
the Linux kernel sources over to

00:47:42,000 --> 00:47:44,370
our external module code, basically.

00:47:45,640 --> 00:47:50,640
That's, I mean, that's a stupid task for me.

00:47:51,010 --> 00:47:53,010
I'm usually doing it manually.

00:47:54,110 --> 00:47:57,810
And so I've worked on automating that.

00:47:57,810 --> 00:48:02,810
And, so, the klp-ccp utility is the result.

00:48:03,120 --> 00:48:06,170
Ccp is for C Copy&Paste.

00:48:07,156 --> 00:48:08,206
In case you wondered.

00:48:09,680 --> 00:48:13,695
And how it works, is basically take a bunch of options

00:48:13,695 --> 00:48:17,580
and the original GCC command line

00:48:17,580 --> 00:48:20,130
from the original kernel build.

00:48:20,130 --> 00:48:24,870
Let's say you are patching KVM into your tab

00:48:24,870 --> 00:48:26,700
something like omx.cnc

00:48:27,590 --> 00:48:30,260
command line used to compile VMX.C.

00:48:33,727 --> 00:48:35,900
It takes a complete command line

00:48:35,900 --> 00:48:40,190
because it needs to reproduce the preprocessed environment

00:48:40,190 --> 00:48:42,780
which includes things like microdefinitions,

00:48:43,819 --> 00:48:47,720
how to switch path, and so on.

00:48:49,110 --> 00:48:50,410
When it worked, it worked.

00:48:52,294 --> 00:48:55,310
Oh, one more thing to note is that it is given

00:48:55,310 --> 00:48:58,220
the set of patched function from which to build

00:48:59,066 --> 00:49:01,330
the source closure, if you want.

00:49:01,330 --> 00:49:06,330
Like, needed functions and type definitions and what not.

00:49:06,897 --> 00:49:10,997
So, when it worked it preprocessed power eight

00:49:10,997 --> 00:49:15,700
and out of that information it will build the closure,

00:49:15,700 --> 00:49:19,780
which means, for example, it will follow the color graph

00:49:19,780 --> 00:49:22,790
of the starting from the looped patch set

00:49:26,407 --> 00:49:27,240
it will follow the color graph, and copy,

00:49:27,240 --> 00:49:31,830
for example, functions, static functions, for example.

00:49:33,440 --> 00:49:36,030
It will extract or deconstruct definitions

00:49:36,030 --> 00:49:39,500
or pull needed in or something like that.

00:49:40,620 --> 00:49:45,057
In it's final step, it deprocesses the closure

00:49:46,420 --> 00:49:49,870
and writes the output to a file.

00:49:51,240 --> 00:49:52,530
Are there any question?

00:49:52,530 --> 00:49:56,880
Please ask because I'm soft in doing this

00:49:56,880 --> 00:49:58,510
and maybe something unclear.

00:50:01,050 --> 00:50:01,883
No?

00:50:02,950 --> 00:50:07,950
Okay, so, when in particular when building

00:50:08,620 --> 00:50:11,290
the closure of the patched function klp-ccp

00:50:12,440 --> 00:50:15,330
has to know some pieces of information

00:50:15,330 --> 00:50:17,450
about original kernel build.

00:50:17,450 --> 00:50:22,370
When implementing this I put the problem aside

00:50:22,370 --> 00:50:27,370
and decided I would just invoke some external

00:50:27,373 --> 00:50:32,373
user provided scripts, providing me with that information.

00:50:33,345 --> 00:50:36,850
So, for example, and example would be

00:50:36,850 --> 00:50:38,600
what I can externalization.

00:50:38,600 --> 00:50:40,550
It's exactly, kind of, what we talked

00:50:40,550 --> 00:50:43,660
about with the static keys.

00:50:43,660 --> 00:50:47,540
So if you need to access a global variable

00:50:47,540 --> 00:50:49,980
from the original patched objects

00:50:49,980 --> 00:50:53,250
you had somehow have to resolve it.

00:50:54,260 --> 00:50:56,970
So, and that's what I call externalization.

00:50:56,970 --> 00:50:59,442
Whether or not it's possible, and so on.

00:50:59,442 --> 00:51:03,310
So, then, what I'd like to do in this talk

00:51:03,310 --> 00:51:07,580
is to collect ideas and opinions to obtain various pieces

00:51:07,580 --> 00:51:10,893
of information about the original kernel build.

00:51:15,750 --> 00:51:20,750
The first thing is the GCC command line used

00:51:22,240 --> 00:51:27,240
when compiling the patched object.

00:51:27,630 --> 00:51:30,160
So, there are several ideas I had.

00:51:30,160 --> 00:51:34,190
So, the first one is to just run make and silent mode

00:51:36,450 --> 00:51:38,630
and simulation mode in particular

00:51:42,070 --> 00:51:45,287
and copy the command line out of the output.

00:51:46,270 --> 00:51:50,730
The problem with that is that it depends on the GCC version

00:51:50,730 --> 00:51:54,000
because kvid will adds and removes

00:51:54,000 --> 00:51:56,280
certain options depending if the

00:51:56,280 --> 00:51:57,960
compiler supports it or not.

00:51:57,960 --> 00:51:59,920
So, if you want to reproduce your build

00:51:59,920 --> 00:52:02,340
on a different machine then used to compile

00:52:02,340 --> 00:52:03,640
the kernel, it won't work.

00:52:04,560 --> 00:52:07,530
Another problem is there are some targets

00:52:07,530 --> 00:52:09,720
which are always rebuild,

00:52:09,720 --> 00:52:13,270
which basically cluttered the output.

00:52:14,290 --> 00:52:19,290
It's not good for automation and extracting the output.

00:52:19,540 --> 00:52:24,540
So, another idea is to somehow store away a package away

00:52:26,240 --> 00:52:30,160
or whatever the .cmd files produce by kvid

00:52:31,793 --> 00:52:33,730
for tracking whether or not

00:52:33,730 --> 00:52:37,220
some complete command has changed.

00:52:38,730 --> 00:52:42,090
Yeah, the disadvantage of that is basically

00:52:42,090 --> 00:52:47,090
that this contain absolute path and so you can't move your,

00:52:49,655 --> 00:52:52,780
I mean you can but you have to fix up your path,

00:52:52,780 --> 00:52:56,560
but you can't move your configured kernel directory

00:52:56,560 --> 00:52:59,280
or whatever to somewhere else.

00:52:59,280 --> 00:53:02,520
On the upside, the nice thing about this .cmd file

00:53:02,520 --> 00:53:06,010
is it also contains the header switch

00:53:07,280 --> 00:53:09,640
which is needed for finding

00:53:11,710 --> 00:53:15,230
objects to patch for header field changes.

00:53:19,126 --> 00:53:20,730
So, basically these are the output from

00:53:20,730 --> 00:53:25,730
GCC minus M something to create these make file roots.

00:53:29,472 --> 00:53:32,080
The simplest one, the stupidest one,

00:53:32,080 --> 00:53:34,610
is just to capture the whole make output

00:53:34,610 --> 00:53:35,862
from the kernel compilation

00:53:35,862 --> 00:53:40,660
and your file of interest, or something.

00:53:40,660 --> 00:53:45,490
- So, what exactly do you need from the GCC command line?

00:53:45,490 --> 00:53:49,100
- Right now I need everything preprocessor related.

00:53:49,100 --> 00:53:51,730
Like, microdefinitions, undefs,

00:53:51,730 --> 00:53:55,650
header search path, and yeah that's it.

00:53:56,820 --> 00:54:01,820
But for simplicity I'm taking the whole GCC command line

00:54:02,810 --> 00:54:04,117
and throw away what I...

00:54:05,114 --> 00:54:10,114
Okay, and one thing in the short future,

00:54:10,250 --> 00:54:15,227
or the near future, what I would like to do is to WARN_ON

00:54:18,420 --> 00:54:22,460
architecture specific flex orderings,

00:54:22,460 --> 00:54:24,030
code iterations somehow.

00:54:24,030 --> 00:54:26,050
Like for example, you could do something

00:54:26,050 --> 00:54:28,910
just as an example, I don't know if it's actually used,

00:54:28,910 --> 00:54:31,830
you can have F pec struct

00:54:31,830 --> 00:54:34,370
which would affect the livepatch, obviously.

00:54:35,470 --> 00:54:38,630
And, there are some changing calling conventions,

00:54:38,630 --> 00:54:42,232
for example, and I want to do something like that.

00:54:42,232 --> 00:54:44,314
So, I just decided to take the whole thing

00:54:44,314 --> 00:54:46,900
and (laughs) pick what I need.

00:54:46,900 --> 00:54:47,733
Yeah.

00:54:48,860 --> 00:54:53,060
Oh, and another reason is that I thought it would probably

00:54:53,060 --> 00:54:57,140
facilitate automation if I could just can positively

00:54:57,140 --> 00:55:02,140
command like get it somewhere and just throw it at klp-ccp.

00:55:03,090 --> 00:55:08,090
Are there any more ideas how to get the command line?

00:55:08,640 --> 00:55:10,560
Or comments?

00:55:10,560 --> 00:55:11,470
There's, uh...

00:55:19,440 --> 00:55:20,273
- Oh!

00:55:24,680 --> 00:55:28,560
- Sorry, I've seen a lot of this recently

00:55:28,560 --> 00:55:31,520
just for like editor integrations.

00:55:31,520 --> 00:55:32,353
- Can you stand up?

00:55:32,353 --> 00:55:33,186
- Yeah, sure.

00:55:33,186 --> 00:55:35,110
I've seen a lot of this recently for editor integrations

00:55:35,110 --> 00:55:36,830
where people will have claimed or whatever

00:55:36,830 --> 00:55:39,910
and will have produced a common file format

00:55:39,910 --> 00:55:41,720
called compilecommands.json

00:55:43,960 --> 00:55:46,320
which essentially includes how to compile

00:55:46,320 --> 00:55:49,660
every single C file in the Linux tree.

00:55:49,660 --> 00:55:52,790
So, there's already tools to generate that.

00:55:54,020 --> 00:55:55,890
I've seen scripts that will just go through

00:55:55,890 --> 00:55:57,840
and, you know, pause every .O.cmd file.

00:55:58,729 --> 00:56:01,900
And, there's also a tool called Bear, B-E-A-R,

00:56:01,900 --> 00:56:03,280
which you just prefix, like it gives you,

00:56:03,280 --> 00:56:05,280
bear make it will just spit out this json file,

00:56:05,280 --> 00:56:07,740
which, you know, remembers how to build everything

00:56:07,740 --> 00:56:09,370
in the kernel which is very useful

00:56:09,370 --> 00:56:10,650
for editor integrations, right.

00:56:10,650 --> 00:56:13,410
So, whenever I change a file in emax it will go ahead

00:56:13,410 --> 00:56:15,780
and recompile and give me some intelligent warnings,

00:56:15,780 --> 00:56:16,740
and what not.

00:56:16,740 --> 00:56:21,740
So, I guess there's already some work to make that easier,

00:56:23,380 --> 00:56:24,933
not for this purpose, but you could probably

00:56:24,933 --> 00:56:27,590
make use of that.

00:56:28,700 --> 00:56:31,262
- Yeah, thanks, that's really good information to have.

00:56:31,262 --> 00:56:33,790
I'll ask you after this.

00:56:33,790 --> 00:56:34,959
- [Man In Glasses] Yeah, yeah, no worries.

00:56:34,959 --> 00:56:36,880
Yeah I'll meet you outside.

00:56:36,880 --> 00:56:38,270
- Okay, so is there?

00:56:39,579 --> 00:56:40,500
- [Man In Glasses] Who can I wound?

00:56:43,029 --> 00:56:45,862
(audience laughs)

00:56:46,892 --> 00:56:49,500
- Recently I run in nearly the same

00:56:49,500 --> 00:56:52,380
situation as you but for other purposes.

00:56:52,380 --> 00:56:57,380
I'm maintaining something like kernel, several 100,000.

00:57:00,750 --> 00:57:03,830
I'm in the same situation as you I'm maintaining something,

00:57:05,452 --> 00:57:08,500
maybe 10-15 kernels up to 20 sometimes.

00:57:08,500 --> 00:57:12,513
Running 100 to 1000 machines and I was

00:57:15,170 --> 00:57:19,256
in the situation where when I have to build livepatch,

00:57:19,256 --> 00:57:22,400
I have kernels built over the last two years

00:57:22,400 --> 00:57:26,300
with several different tool chains while changed.

00:57:27,250 --> 00:57:32,250
And it was a real pain to investigate which kernel

00:57:32,780 --> 00:57:37,120
with which tool chain was built old build options were.

00:57:37,120 --> 00:57:39,870
And so on, and so on.

00:57:39,870 --> 00:57:44,870
Generally, what I did is build .tmb file

00:57:45,380 --> 00:57:47,880
where I am setting up my tool chain.

00:57:48,980 --> 00:57:53,560
Source tool chain, something, enable.

00:57:55,090 --> 00:57:58,970
And I'm running this file to the Git from

00:57:58,970 --> 00:58:02,210
which I am building the kernel to the exact release,

00:58:02,210 --> 00:58:04,250
or to the hive of the release

00:58:04,250 --> 00:58:07,500
or whatever you use to maintain your files.

00:58:08,920 --> 00:58:13,920
Using that, I can use unified script built kernel,

00:58:14,830 --> 00:58:19,830
let's say, which does all the flux options

00:58:21,640 --> 00:58:26,640
we need into the command line and, just includes build.tmv.

00:58:28,790 --> 00:58:31,550
When you have your build.tmb file,

00:58:31,550 --> 00:58:33,920
which sources the tool chain,

00:58:34,800 --> 00:58:39,800
checks its version whether it is exactly what you expect.

00:58:40,210 --> 00:58:43,450
In my case, it enables C cache and some other stuff

00:58:43,450 --> 00:58:46,907
but basically it stops the built in environment.

00:58:46,907 --> 00:58:51,780
You could take just the file and the source

00:58:51,780 --> 00:58:54,010
and then you will reproduce your exact

00:58:54,010 --> 00:58:57,530
build environment used for building the kernel

00:58:57,530 --> 00:58:59,730
which made my life easy.

00:58:59,730 --> 00:59:01,170
- Yeah, yeah, yeah.

00:59:01,170 --> 00:59:04,430
The problem with that approach is that

00:59:04,430 --> 00:59:08,130
it would be hard to set it up with cross compiling, I guess.

00:59:09,090 --> 00:59:13,420
Because what I would love to do is do all this

00:59:13,420 --> 00:59:17,660
on my development machine and not having to.

00:59:17,660 --> 00:59:19,760
I mean if you have, like, 50 kernels and

00:59:20,720 --> 00:59:22,132
three architectures, or something like that,

00:59:22,132 --> 00:59:26,270
then it's getting real pain to do that

00:59:26,270 --> 00:59:31,270
on every architecture and search for a machine somewhere.

00:59:32,373 --> 00:59:35,857
But, yeah, that's certainly an option.

00:59:38,220 --> 00:59:40,570
- You can also use containers, I guess.

00:59:40,570 --> 00:59:42,410
You know, use a container to build the kernel

00:59:42,410 --> 00:59:46,550
and then save that away then you have the exact environment,

00:59:46,550 --> 00:59:48,290
you know, used to build the kernel

00:59:48,290 --> 00:59:50,920
you can build your livepatch modules with as well.

00:59:55,310 --> 00:59:57,694
- So, any more comments on that?

00:59:57,694 --> 00:59:58,527
I suppose not.

00:59:59,370 --> 01:00:02,740
Okay, thanks, and let's head over to the next topic.

01:00:02,740 --> 01:00:05,610
So, that's the topic of externalizability

01:00:06,530 --> 01:00:10,510
of mostly static functions.

01:00:10,510 --> 01:00:12,790
And what that means is, so,

01:00:12,790 --> 01:00:17,710
when building the closure of the patched functions.

01:00:17,710 --> 01:00:20,350
Closure with respect to the core graph, basically.

01:00:22,130 --> 01:00:25,763
There's an optimization possible to sometimes

01:00:27,430 --> 01:00:30,580
to leave out a function and refer to the

01:00:31,990 --> 01:00:34,810
original in kernel instance instead.

01:00:35,810 --> 01:00:40,810
So, for example, it's possible when obviously that function

01:00:41,720 --> 01:00:45,700
has been changed and GCC admitted it was out

01:00:45,700 --> 01:00:50,700
and inter process optimization into the patched object.

01:00:52,650 --> 01:00:57,650
So, the question is, how to find out if that has happened.

01:00:59,120 --> 01:01:04,120
So, if GCC admitted some function of interest

01:01:06,869 --> 01:01:10,020
into the to-be-patched object,

01:01:11,020 --> 01:01:15,350
it turns out it's harder than I expected it to be.

01:01:16,386 --> 01:01:17,590
(laughs)

01:01:17,590 --> 01:01:20,600
Because , yeah, there's several options.

01:01:23,290 --> 01:01:27,080
So, first you can just have a look at the symbol table

01:01:27,080 --> 01:01:28,540
and see if it's there or not.

01:01:29,730 --> 01:01:32,100
And the problem with that approach is that

01:01:32,100 --> 01:01:35,210
there are in same patched object

01:01:35,210 --> 01:01:37,490
you can have incompatible definition

01:01:39,015 --> 01:01:41,590
of a function with the same name.

01:01:41,590 --> 01:01:43,620
It's actually a real concern.

01:01:43,620 --> 01:01:45,670
There's an example from NFS.

01:01:47,030 --> 01:01:52,030
So, another option is to inspect the output of the IPA dump

01:01:54,570 --> 01:01:58,288
from GCC which we are storing anyway.

01:01:58,288 --> 01:01:59,738
The problem with that is that

01:02:01,158 --> 01:02:05,160
it doesn't have any records for dead code elimination.

01:02:05,160 --> 01:02:07,973
So, it could happen that some function

01:02:07,973 --> 01:02:11,440
has been optimized away completely

01:02:11,440 --> 01:02:15,110
and it would not have a record in the IPA dumps.

01:02:15,980 --> 01:02:18,910
So, that on its own it suffers either.

01:02:20,720 --> 01:02:23,690
Then we are thinking about, we already

01:02:23,690 --> 01:02:28,690
have the source location information from klp-ccp

01:02:28,810 --> 01:02:31,820
like line number and column, or whatever.

01:02:31,820 --> 01:02:35,380
And we could relate that to DWARF info,

01:02:36,590 --> 01:02:41,590
in principle, and see if there is a corresponding

01:02:44,020 --> 01:02:48,310
graph entry for that function at that line

01:02:48,310 --> 01:02:52,790
and having some in sense we would recognize it and

01:02:52,790 --> 01:02:55,430
checking if there's an address stored

01:02:55,430 --> 01:02:58,390
in the DWARF entry .text address.

01:02:59,600 --> 01:03:01,350
The problem with that is that

01:03:02,190 --> 01:03:06,480
optimized clones are not distinguishable

01:03:06,480 --> 01:03:09,390
from proper out-of-line instances.

01:03:12,809 --> 01:03:15,820
- Okay, so first in mind is the DWARF,

01:03:15,820 --> 01:03:20,820
I once asked about using DWARF for IPA clones dump

01:03:22,570 --> 01:03:27,160
so instead of it, the answer was that DWARF,

01:03:27,160 --> 01:03:29,670
in terms of optimization, is not so reliable,

01:03:29,670 --> 01:03:30,610
as you noticed.

01:03:30,610 --> 01:03:31,443
- Yeah, it's...

01:03:32,530 --> 01:03:35,630
- That we should not use it, or try to use it.

01:03:35,630 --> 01:03:39,980
So, then I asked for IPA clones dump

01:03:39,980 --> 01:03:41,850
which was implemented so maybe

01:03:41,850 --> 01:03:46,720
the best would be to ask to get dead code elimination

01:03:46,720 --> 01:03:51,720
to the dump as well because GCC has to make

01:03:51,970 --> 01:03:53,820
a decision about it at some point

01:03:53,820 --> 01:03:56,830
so maybe it is easy to dump it.

01:03:56,830 --> 01:03:59,530
- So, you mean we would ask the GCC guys

01:03:59,530 --> 01:04:02,660
to have IPA dump complete,

01:04:02,660 --> 01:04:06,837
like having every function emitted into the final object?

01:04:09,090 --> 01:04:09,923
- Could be.

01:04:09,923 --> 01:04:11,130
- Having some record

01:04:11,130 --> 01:04:13,220
- Something like this, yes.

01:04:13,220 --> 01:04:14,850
- Okay, yeah we can do that.

01:04:16,443 --> 01:04:19,750
The reason why I'm bring that up is in particular

01:04:19,750 --> 01:04:23,510
this is relating source location information to actual

01:04:25,040 --> 01:04:28,220
symbol entries is that we need that

01:04:28,220 --> 01:04:29,690
for klp convert as well.

01:04:30,900 --> 01:04:35,900
I mean, if you want to some how pass this information down

01:04:36,620 --> 01:04:40,560
the chain, like through klp-ccp, to KP convert,

01:04:41,484 --> 01:04:46,300
for example, to resolve clashing symbols,

01:04:48,310 --> 01:04:51,320
we are basically the only option

01:04:51,320 --> 01:04:54,360
is to look at DWARF, I think.

01:04:54,360 --> 01:04:57,710
Because that would allow us to relay the

01:04:57,710 --> 01:05:00,430
source location information to the DWARF entry

01:05:01,460 --> 01:05:06,460
and to the address of the symbol and tell the klp convert,

01:05:07,660 --> 01:05:11,450
yeah that's something you want or you don't want.

01:05:13,505 --> 01:05:16,910
I mean, what I don't like is there's three sources

01:05:16,910 --> 01:05:19,880
I have to combine somehow (laughs),

01:05:21,422 --> 01:05:25,730
and yes, IPA clones if we can have that from the

01:05:25,730 --> 01:05:27,330
GCC guys would be much better

01:05:28,280 --> 01:05:32,730
for only deciding whether or not some function is there

01:05:32,730 --> 01:05:36,220
or not, but in the long term, it might make sense

01:05:36,220 --> 01:05:41,220
to somehow be able to correlate source location information

01:05:43,980 --> 01:05:46,944
to similar addresses.

01:05:46,944 --> 01:05:51,320
- Okay, so, let's ask about a DWARF situation first.

01:05:51,320 --> 01:05:53,630
If it can be fixed somehow, or...

01:05:54,990 --> 01:05:55,880
- I don't know.

01:05:55,880 --> 01:05:58,110
- Yeah, I know, so that's my proposal.

01:05:58,110 --> 01:06:01,780
So, let's find out first and then decide.

01:06:01,780 --> 01:06:02,613
- Okay.

01:06:04,410 --> 01:06:06,020
So, that's.

01:06:06,020 --> 01:06:10,240
And then the last question is would it make sense

01:06:10,240 --> 01:06:14,800
to come up with some convention for retrieving these

01:06:14,800 --> 01:06:19,800
IPA clones which are these clone dump files.

01:06:20,580 --> 01:06:25,580
I mean, as opposed to everybody having his own scripts,

01:06:26,470 --> 01:06:30,920
and his own conventions, and I don't know.

01:06:33,740 --> 01:06:37,139
- I think we can't decide right now.

01:06:37,139 --> 01:06:37,972
- Yeah.

01:06:37,972 --> 01:06:40,860
- I think it depends on the final pipeline too much, so.

01:06:40,860 --> 01:06:41,693
- Yeah.

01:06:41,693 --> 01:06:45,920
- Let's first come up with a pipeline and then discuss.

01:06:45,920 --> 01:06:47,200
- And decide on, yeah.

01:06:48,790 --> 01:06:50,340
- So, that's my question.

01:06:50,340 --> 01:06:55,080
So, what about timeline and pipeline and everything, so.

01:06:55,080 --> 01:06:55,960
Are you?

01:06:56,860 --> 01:06:59,520
- I mean, I am using it since a week or so.

01:07:00,492 --> 01:07:01,450
What exactly?

01:07:02,860 --> 01:07:04,500
Timeline for what?

01:07:04,500 --> 01:07:07,133
- Yeah, because I think if we ...

01:07:08,230 --> 01:07:10,000
Maybe, ask first.

01:07:10,000 --> 01:07:11,600
- Okay. (laughs)

01:07:11,600 --> 01:07:12,433
I'll just.

01:07:12,433 --> 01:07:15,160
So I took a quick look at the code and it looks like

01:07:15,160 --> 01:07:17,790
it's a lot of code, right?

01:07:17,790 --> 01:07:22,790
So, I was wondering is it complex and is that a concern?

01:07:23,363 --> 01:07:28,363
- (laughing) Yes, it is complex but in a way,

01:07:28,610 --> 01:07:32,420
I mean there's been something specific

01:07:32,420 --> 01:07:35,160
to the C language or how microprocessing works,

01:07:35,160 --> 01:07:35,993
and stuff like that.

01:07:35,993 --> 01:07:40,020
So, yeah, it's complex due to preprocessing.

01:07:40,020 --> 01:07:43,620
The point is I have test cases for everything of that.

01:07:43,620 --> 01:07:47,090
So, like testing each aspect of the deprocessing part.

01:07:48,050 --> 01:07:50,700
And I consider it to solve problem.

01:07:50,700 --> 01:07:53,320
And I don't expect box on that part.

01:07:53,320 --> 01:07:58,020
I mean, part of curse is still not ready.

01:07:59,590 --> 01:08:04,070
For example, what could be a source of fragility

01:08:04,070 --> 01:08:07,710
would be to turn the GCC command line

01:08:07,710 --> 01:08:09,660
into some preprocessor environment.

01:08:10,900 --> 01:08:12,560
Which I tried to reproduce, basically,

01:08:12,560 --> 01:08:17,240
from the GCC version and command line.

01:08:17,240 --> 01:08:19,140
Because there's, for example,

01:08:19,140 --> 01:08:24,140
a predefined macro film in GCC, just to give an example.

01:08:24,200 --> 01:08:25,930
I mean, for another example is

01:08:25,930 --> 01:08:30,460
if you give GCC a minus O, for optimize,

01:08:30,460 --> 01:08:32,640
it would define as optimize macro

01:08:32,640 --> 01:08:35,280
which is actually used in the Linux kernel.

01:08:35,280 --> 01:08:36,710
And, yeah, stuff like that.

01:08:36,710 --> 01:08:39,982
So, I mean,

01:08:39,982 --> 01:08:43,220
(laughs) on the other hand the GCC are very well organized

01:08:43,220 --> 01:08:45,520
in that respect so it's probably hard

01:08:45,520 --> 01:08:47,270
to miss anything there.

01:08:47,270 --> 01:08:50,290
- So, if something broke in that area,

01:08:50,290 --> 01:08:53,480
like what would be the fail mode?

01:08:53,480 --> 01:08:54,710
Like, would it be,

01:08:54,710 --> 01:08:57,840
could you anticipate like it corrupting the patch module?

01:08:57,840 --> 01:09:02,060
- Yeah, the most common fail mode would be to have a

01:09:02,060 --> 01:09:04,170
non-compilable livepatch module.

01:09:04,170 --> 01:09:07,251
I mean, if you get, hopefully. (laughs)

01:09:07,251 --> 01:09:08,084
- (laughs) Hopefully!

01:09:08,084 --> 01:09:09,220
Yeah, but okay, there's still another

01:09:09,220 --> 01:09:13,890
point I haven't solved yet is pragmas.

01:09:14,810 --> 01:09:17,370
The most pragmas in Linux kernel are the diagnostic

01:09:17,370 --> 01:09:19,040
so I just in the beginning I just

01:09:19,040 --> 01:09:23,120
threw every pragmas away, but some are not.

01:09:23,120 --> 01:09:27,740
For example, there's a F pec struct analog pragmas.

01:09:27,740 --> 01:09:31,320
These are actually used in like three or four places.

01:09:31,320 --> 01:09:33,940
And, yeah, but, yeah.

01:09:37,770 --> 01:09:40,720
So, I think the more sources of

01:09:44,490 --> 01:09:47,496
error or something, will be in the scripting around it

01:09:47,496 --> 01:09:52,496
like getting the information about

01:09:52,750 --> 01:09:56,582
these from GCC and something else.

01:09:56,582 --> 01:09:59,470
- [Audience Member] So, you are actually already using this?

01:09:59,470 --> 01:10:02,894
- Yeah, I mean, since last week, so. (laughs)

01:10:02,894 --> 01:10:04,370
- [Audience Member] Okay, okay.

01:10:04,370 --> 01:10:08,000
- Okay, so let me ask about next steps.

01:10:08,000 --> 01:10:09,510
So, what's your proposal?

01:10:09,510 --> 01:10:14,510
Because you're surely not asking us to review that monster.

01:10:15,700 --> 01:10:19,840
- Yeah, please review klp-ccp. (laughs)

01:10:22,160 --> 01:10:24,320
Yeah, we'll meet next year, right?

01:10:24,320 --> 01:10:27,010
So, yeah, it's like 70,000 lines of code

01:10:27,010 --> 01:10:28,460
to come back to the question.

01:10:30,450 --> 01:10:31,720
- 70,000?

01:10:31,720 --> 01:10:35,216
- Yup, yeah, 69 something, yeah.

01:10:35,216 --> 01:10:38,030
(audience laughs)

01:10:38,030 --> 01:10:42,000
Yeah, I mean, for the most part it's a C evaluation

01:10:42,000 --> 01:10:44,620
and stuff like that so the actual deprocessing enclosure

01:10:44,620 --> 01:10:46,980
building would be something like 5,000 probably.

01:10:46,980 --> 01:10:49,580
So, that's where the livepatching specific logic is.

01:10:53,130 --> 01:10:54,080
So, yeah.

01:10:54,080 --> 01:10:55,130
Yeah, the next steps.

01:10:56,100 --> 01:10:58,820
I mean, I would of course love if people

01:10:58,820 --> 01:11:00,910
start using it or trying it out.

01:11:02,780 --> 01:11:06,410
I personally would appreciate any

01:11:06,410 --> 01:11:08,431
feedback on the command line.

01:11:08,431 --> 01:11:09,700
On the script interface.

01:11:09,700 --> 01:11:11,620
And what can be improved about that.

01:11:12,485 --> 01:11:13,318
And.

01:11:16,500 --> 01:11:18,140
Yeah.

01:11:18,140 --> 01:11:18,973
So then.

01:11:20,130 --> 01:11:22,580
So, my conclusion is that we won't have any

01:11:22,580 --> 01:11:25,110
upstream changes to cable it or whatever,

01:11:25,110 --> 01:11:30,110
but it's a tool a person in the back proposed, yeah, and.

01:11:35,210 --> 01:11:37,400
Any more questions or comments?

01:11:40,080 --> 01:11:43,202
Doesn't seem to be the case.

01:11:43,202 --> 01:11:46,202
(audience clapping)

01:12:05,190 --> 01:12:07,110
- Hi, I'm Kamalesh Babulal.

01:12:07,110 --> 01:12:09,830
I work with Linux Technologies, indirect IBM.

01:12:10,700 --> 01:12:13,020
So, this is more about, like,

01:12:13,020 --> 01:12:15,000
an update of what's happening with

01:12:15,000 --> 01:12:18,702
object tool support on power.

01:12:18,702 --> 01:12:21,680
I tried to fit the one slide rule,

01:12:21,680 --> 01:12:23,400
so I just, like, divide it.

01:12:23,400 --> 01:12:27,590
So, we go the left one first, then right next.

01:12:27,590 --> 01:12:31,140
So, last year when we had the talk,

01:12:31,140 --> 01:12:34,130
actually there was like zero line of code actually written.

01:12:34,130 --> 01:12:36,970
So most, it was, like, pitching the idea

01:12:36,970 --> 01:12:39,890
on, like, what we have on power.

01:12:39,890 --> 01:12:41,090
What can be done.

01:12:41,090 --> 01:12:43,830
And I was just asking to see where to go.

01:12:43,830 --> 01:12:46,730
Because I was honestly a little scared looking at what Josh

01:12:46,730 --> 01:12:48,970
did with hawk and minder and I was a little scared

01:12:48,970 --> 01:12:53,060
whether I should do something similar for power.

01:12:54,730 --> 01:12:56,560
So, the current state, as of now,

01:12:56,560 --> 01:12:58,970
it's like, I would say it's pretty good shape.

01:12:58,970 --> 01:13:00,180
I've not posted it as such,

01:13:00,180 --> 01:13:02,830
but it's available on the GitHub as such.

01:13:02,830 --> 01:13:05,510
You can start, if anyone is interested before

01:13:05,510 --> 01:13:07,580
it hits L gamer you can just start.

01:13:07,580 --> 01:13:11,380
It's public so you can start running on new power boxes.

01:13:11,380 --> 01:13:15,840
So, one thing is, like, it the object was all about

01:13:16,690 --> 01:13:21,690
imposing rules of how the stack is at a particular point,

01:13:23,130 --> 01:13:25,870
or how we do the stack validation at a particular point.

01:13:25,870 --> 01:13:30,870
So, the major part is we owed these, like, to enclose

01:13:31,300 --> 01:13:34,460
a particular set of rules you're going to go through

01:13:34,460 --> 01:13:38,340
every inspection in a .O file and make sure that,

01:13:38,340 --> 01:13:42,460
you know, it follows a set of ABZ rules.

01:13:42,460 --> 01:13:45,440
So, most of the outline thing of like enforcement

01:13:45,440 --> 01:13:47,300
of rule and all those things are there.

01:13:47,300 --> 01:13:50,030
So, the major work was, like, on the decoder part,

01:13:50,030 --> 01:13:52,020
that is the biggest meet,

01:13:52,020 --> 01:13:55,030
which is record for every arch we supported, as such.

01:13:55,030 --> 01:14:00,030
So, the decoder for power is not like a very big,

01:14:01,410 --> 01:14:03,510
or it doesn't covers all the cases,

01:14:03,510 --> 01:14:08,510
but it just is very small one which has only for those

01:14:09,990 --> 01:14:11,500
which you are interested from

01:14:11,500 --> 01:14:13,580
the prospect of object or latch.

01:14:13,580 --> 01:14:15,330
For other thing, it's just like,

01:14:15,330 --> 01:14:19,280
we don't care and, like, one type is what we ask as now.

01:14:21,050 --> 01:14:24,950
Oh, yeah, and I have copied, or say, borrowed from what

01:14:24,950 --> 01:14:27,578
we have in arch lib in step.

01:14:27,578 --> 01:14:32,578
Where we have a decoder which does a lot more than

01:14:32,610 --> 01:14:34,660
what is expected for object tool as such.

01:14:34,660 --> 01:14:36,910
So, I just picked up small bits and pieces

01:14:36,910 --> 01:14:38,270
and just group of instructions

01:14:38,270 --> 01:14:40,740
which we are interested in from there.

01:14:40,740 --> 01:14:42,510
And the first thing to start would be,

01:14:42,510 --> 01:14:45,960
is, like, the stack operation is what first group

01:14:45,960 --> 01:14:49,871
of operation which decoder as we interested is, like,

01:14:49,871 --> 01:14:52,360
what is the current state of stack

01:14:52,360 --> 01:14:54,830
and the instructions which may not operate these stacks.

01:14:54,830 --> 01:14:57,030
So, the reason is, like, when are locate,

01:14:57,030 --> 01:14:59,615
make sure you delocate before you either written

01:14:59,615 --> 01:15:00,870
from the function.

01:15:00,870 --> 01:15:04,506
Or whenever you do a jump or a call to an external function.

01:15:04,506 --> 01:15:06,340
Those kinds of thing.

01:15:06,340 --> 01:15:09,610
And the second one, which is all about the branches.

01:15:09,610 --> 01:15:11,810
Conditional and unconditional.

01:15:11,810 --> 01:15:15,640
And we have our guys, they know that the numbers

01:15:15,640 --> 01:15:20,130
between sections we have for different kind of branches

01:15:20,130 --> 01:15:24,480
are, like, huge and we have, like, interesting things

01:15:24,480 --> 01:15:28,930
like branch with LR set unset.

01:15:28,930 --> 01:15:31,460
And we have large different kinds of branches.

01:15:31,460 --> 01:15:33,130
Okay, let's not get into it, but.

01:15:33,130 --> 01:15:36,000
Yeah, it was like a huge operation which we needed.

01:15:36,000 --> 01:15:37,090
And another interesting thing

01:15:37,090 --> 01:15:38,840
would obviously be, like dead ends.

01:15:39,740 --> 01:15:43,280
So, if for example, you are passing through a whole function

01:15:43,280 --> 01:15:45,530
and you want to make sure you pass through...

01:15:47,612 --> 01:15:51,160
You want to make sure that every section is reachable.

01:15:51,160 --> 01:15:53,360
From entry to exit.

01:15:53,360 --> 01:15:54,690
And there might be cases where you

01:15:54,690 --> 01:15:58,040
have BUG_ON, BUG or BUG_ON or WARN_ON.

01:15:58,040 --> 01:16:02,050
Or even, those will translate to dead ends.

01:16:02,050 --> 01:16:04,270
That's like the code would not go below it.

01:16:04,270 --> 01:16:06,820
So, figuring out those things.

01:16:06,820 --> 01:16:09,680
And, okay, one interesting thing with par counts

01:16:09,680 --> 01:16:10,990
as, like, the switch keys.

01:16:12,360 --> 01:16:17,360
So, the switch key will be something like this.

01:16:18,000 --> 01:16:19,470
If you see this right,

01:16:19,470 --> 01:16:22,060
like what I explain to you have to go through...

01:16:22,060 --> 01:16:23,650
Whenever you have a dead end,

01:16:23,650 --> 01:16:26,340
the inspections below that would never be reachable.

01:16:26,340 --> 01:16:29,680
And something similar happened to switch also.

01:16:29,680 --> 01:16:33,110
So, here, you have all those things

01:16:33,110 --> 01:16:35,130
and these are the cases over here.

01:16:35,130 --> 01:16:36,840
So, basically I would be like,

01:16:36,840 --> 01:16:40,100
from this would be kind of a dead end.

01:16:40,100 --> 01:16:43,530
And you would not be able to go to case zero,

01:16:43,530 --> 01:16:45,000
case one, default and all.

01:16:45,000 --> 01:16:47,190
All those things under case zero would be

01:16:47,190 --> 01:16:49,660
something some of your and case one.

01:16:50,820 --> 01:16:52,830
Those are the in sections which you might not

01:16:52,830 --> 01:16:56,110
be able to reach gently.

01:16:56,110 --> 01:16:58,680
So, what I'm mean is like for the switch cases

01:16:58,680 --> 01:17:02,190
we need special way of figuring out if it's

01:17:02,190 --> 01:17:07,190
a switch table or not and thanks to guys and Josh,

01:17:07,330 --> 01:17:09,730
they came up with an interesting GCC plugin

01:17:09,730 --> 01:17:14,110
which I have, you know, kind of used it.

01:17:16,730 --> 01:17:17,563
Thank you.

01:17:19,580 --> 01:17:22,920
So, yeah, and we have, like, a lot of

01:17:22,920 --> 01:17:25,930
interesting block sequences which are, like,

01:17:27,696 --> 01:17:28,529
the local entry point

01:17:28,529 --> 01:17:30,340
and the global entry point kind of a thing,

01:17:30,340 --> 01:17:33,790
which needed to be taken care of.

01:17:33,790 --> 01:17:37,950
What would that mean is like the NTO stack

01:17:37,950 --> 01:17:40,690
with offset eight, not with zero.

01:17:40,690 --> 01:17:43,050
So we have a little ...

01:17:43,050 --> 01:17:44,614
Okay, something like this.

01:17:44,614 --> 01:17:47,120
I'll better show you how it looks like.

01:17:47,120 --> 01:17:48,570
You have something like this.

01:17:49,620 --> 01:17:51,220
So, if you see it, right?

01:17:51,220 --> 01:17:53,540
The first one would be, like, it's no-op code.

01:17:53,540 --> 01:17:54,373
It's nothing.

01:17:54,373 --> 01:17:55,206
It's zero.

01:17:56,620 --> 01:17:59,140
Something like that, we needed to take care of that also

01:17:59,140 --> 01:18:01,370
as a decoder but we are interested for object passage

01:18:01,370 --> 01:18:03,190
but one thing we are interested is, like,

01:18:03,190 --> 01:18:05,500
what is the start of the function, as such?

01:18:05,500 --> 01:18:09,560
So, you need to take care of these kinds of things.

01:18:12,380 --> 01:18:16,530
And, yeah, once you group all the instructions, the decoder

01:18:16,530 --> 01:18:18,070
is fine with, okay we figured out

01:18:18,070 --> 01:18:20,020
like these are the instructions we need to...

01:18:20,020 --> 01:18:21,580
We have grouped up all the instructions

01:18:21,580 --> 01:18:24,160
then come say stack validation point.

01:18:24,160 --> 01:18:26,140
And that is pretty awesome when it comes to power

01:18:26,140 --> 01:18:28,830
because by ABI definition,

01:18:30,060 --> 01:18:31,160
we do the right thing.

01:18:32,720 --> 01:18:36,130
But, the stack validation is enforcement

01:18:37,130 --> 01:18:40,620
is more valid for the ACM code which we write by hand.

01:18:40,620 --> 01:18:41,580
That is rare.

01:18:41,580 --> 01:18:44,860
The enforcement is something which is really required.

01:18:46,050 --> 01:18:49,520
And on the kernel side, what we wanted was

01:18:49,520 --> 01:18:51,970
certain annotations were missing, like,

01:18:51,970 --> 01:18:54,480
for example, BUG_ON is not a dead end.

01:18:54,480 --> 01:18:56,670
You can reach a section below that

01:18:57,783 --> 01:19:00,610
so you have to introduce a new annotation.

01:19:00,610 --> 01:19:03,062
I mean you have to add an annotation to

01:19:03,062 --> 01:19:05,362
BUG_ON, WARN_ON, and WARN, which were missing.

01:19:10,100 --> 01:19:12,660
So, once the rules started enforcing I figured out

01:19:12,660 --> 01:19:17,530
that a lot of ASM cleanup will come up

01:19:17,530 --> 01:19:18,660
and first thing would be, like,

01:19:18,660 --> 01:19:22,170
the end of function marker for hand to hand assembly.

01:19:22,170 --> 01:19:25,240
So, what we currently do as of now is we say, oh,

01:19:25,240 --> 01:19:26,670
this is the beginning of a function

01:19:26,670 --> 01:19:28,360
but we don't say that it ends.

01:19:29,270 --> 01:19:32,420
So those kinds of things are going to come

01:19:32,420 --> 01:19:35,980
and we are going to have a lot of cleanup message.

01:19:35,980 --> 01:19:37,690
So, that is the state as of now

01:19:38,940 --> 01:19:43,200
and yeah I'm sure I need to cover, like,

01:19:43,200 --> 01:19:44,770
when I'm testing more and more I'm sure

01:19:44,770 --> 01:19:46,840
I'll be able to cover a lot of other things

01:19:46,840 --> 01:19:48,820
which current objects will touch.

01:19:48,820 --> 01:19:50,480
So, this is the current state as of now.

01:19:50,480 --> 01:19:51,730
Any comments on that, or?

01:20:03,620 --> 01:20:06,640
- Yes, I'm not sure, sorry.

01:20:08,010 --> 01:20:11,450
You mentioned the dead ends for BUG_ON and WARN_ON.

01:20:12,360 --> 01:20:14,320
I'm not sure I understood whether

01:20:14,320 --> 01:20:16,990
you reached a conclusion on that.

01:20:16,990 --> 01:20:17,920
Whether you had a solution.

01:20:17,920 --> 01:20:19,790
- So the things like we are missing annotations there

01:20:19,790 --> 01:20:22,050
saying that, you know, this is not the end of function

01:20:22,050 --> 01:20:24,270
you have to go below that also.

01:20:24,270 --> 01:20:26,720
Because for object tool you're just passing

01:20:26,720 --> 01:20:28,150
every instruction and you want to make sure

01:20:28,150 --> 01:20:29,490
that everything's reachable

01:20:29,490 --> 01:20:31,290
and you're doing the right thing.

01:20:31,290 --> 01:20:32,787
So, for example, after BUG_ON

01:20:32,787 --> 01:20:36,530
what if you're calling a function?

01:20:36,530 --> 01:20:37,880
Okay, let's put it this way.

01:20:37,880 --> 01:20:40,040
You have a BUG_ON and you're just calling your function,

01:20:40,040 --> 01:20:42,000
without, I mean this is theoretic example,

01:20:42,000 --> 01:20:44,710
that you're not constricted to stacking the right way.

01:20:44,710 --> 01:20:47,090
So, that's not the right thing to do, right?

01:20:47,090 --> 01:20:48,670
So, if there is a dead end then you say,

01:20:48,670 --> 01:20:51,680
okay, this is the dead end and it's an origin point

01:20:51,680 --> 01:20:53,770
and you just stop the analysis there.

01:20:53,770 --> 01:20:58,770
- Yeah, but, because, on ARM I realize that

01:20:59,526 --> 01:21:03,670
it is possible to compile depending on the configuration

01:21:03,670 --> 01:21:06,210
of the kernel you can compile the BUG_ON out.

01:21:08,300 --> 01:21:12,620
So, the, I don't remember the name of the config option,

01:21:12,620 --> 01:21:15,750
and at least to me it seem like

01:21:21,090 --> 01:21:25,580
it would almost make sense to consider the

01:21:25,580 --> 01:21:29,880
BUG_ON so the break operations or whatever is on power PC.

01:21:29,880 --> 01:21:32,430
At least on ARM, it's just a break operation

01:21:32,430 --> 01:21:35,240
that triggers an exception like no-op.

01:21:36,860 --> 01:21:40,733
That would just go through because in the end

01:21:40,733 --> 01:21:43,920
the final code can be either compiled

01:21:44,964 --> 01:21:48,700
with or without that break instruction.

01:21:48,700 --> 01:21:52,140
And for the warns, the warns are not,

01:21:52,140 --> 01:21:54,000
I mean, you're supposed to be able to

01:21:54,000 --> 01:21:56,220
go through them, so, anyway.

01:21:56,220 --> 01:22:01,220
- For, I guess, always it's like trap restriction.

01:22:01,350 --> 01:22:02,650
Inserted trap restriction.

01:22:04,010 --> 01:22:07,330
So, gently classify them as dead ends, as of now.

01:22:07,330 --> 01:22:08,430
- [Man With Beard] Yeah, yeah but--

01:22:08,430 --> 01:22:09,380
- Okay, this is how it is.

01:22:09,380 --> 01:22:12,660
So, for the things like the object tool to work

01:22:12,660 --> 01:22:14,290
we want to reach everything

01:22:14,290 --> 01:22:16,570
so you classify them as alternative instructions.

01:22:16,570 --> 01:22:19,670
So, whenever there's a WARN_ON it generates a trap

01:22:19,670 --> 01:22:21,950
but you say, "Oh this is not a dead end.

01:22:23,090 --> 01:22:24,460
"Go to the next instruction."

01:22:24,460 --> 01:22:26,560
- [Man With Beard] Yeah, it's like a no-op.

01:22:26,560 --> 01:22:27,840
- So for here we do this.

01:22:27,840 --> 01:22:29,130
And for the power I do that.

01:22:29,130 --> 01:22:31,010
So, you pass to the next instruction

01:22:31,010 --> 01:22:33,830
saying you have another it's not a dead end,

01:22:33,830 --> 01:22:35,370
go on to the next instruction,

01:22:35,370 --> 01:22:38,110
carry on with your analysis kind of a thing.

01:22:38,110 --> 01:22:40,210
We have a lot of other interesting things like,

01:22:40,210 --> 01:22:42,238
what happens if it's a white function, right.

01:22:42,238 --> 01:22:44,950
Sometimes we don't have written from the function.

01:22:44,950 --> 01:22:46,750
That instruction is totally missing.

01:22:48,860 --> 01:22:50,260
So, can you imagine, you don't have it

01:22:50,260 --> 01:22:52,210
a written queue or something like that.

01:22:54,343 --> 01:22:56,787
We have cases where like where you have branch,

01:22:58,720 --> 01:23:01,020
greater than, I mean written greater than,

01:23:01,020 --> 01:23:04,300
kind of branches so you aren't coming down itself.

01:23:05,320 --> 01:23:07,920
So, what happens to the second half of the function?

01:23:09,870 --> 01:23:10,990
For object tool, you're supposed to

01:23:10,990 --> 01:23:13,060
analyze second half also.

01:23:13,060 --> 01:23:16,110
So, what I do is like, as of now,

01:23:16,110 --> 01:23:19,360
I call them alternative so what I say is like

01:23:19,360 --> 01:23:21,090
when you have such branches the

01:23:21,090 --> 01:23:23,270
alternative insertion is the next insertion.

01:23:24,330 --> 01:23:25,720
So, you carry on with the

01:23:27,040 --> 01:23:29,040
unlisting of the whole function message.

01:23:30,090 --> 01:23:31,940
So, we have these kinds of things

01:23:31,940 --> 01:23:34,510
but these are just my idea.

01:23:34,510 --> 01:23:37,140
But I'm sure when I'm going to post to the mailing list

01:23:37,140 --> 01:23:38,610
people are going to beat the heck out of me

01:23:38,610 --> 01:23:43,390
and I see one person already there, yeah, so. (laughs)

01:23:45,630 --> 01:23:49,570
- So you were saying you treat bugs as no-ops on ARM?

01:23:50,662 --> 01:23:51,600
- [Man With Beard] That was an idea.

01:23:51,600 --> 01:23:52,433
- It's an idea, yeah?

01:23:52,433 --> 01:23:55,100
'Cause I'm curious I would kind of like if we did that.

01:23:56,380 --> 01:24:00,840
Because you can actually return from a bug if you're clever.

01:24:02,250 --> 01:24:04,730
But I'm curious would that actually break?

01:24:04,730 --> 01:24:07,010
would object tool not like that?

01:24:07,970 --> 01:24:09,430
I'm not sure, yeah.

01:24:11,360 --> 01:24:14,830
- I haven't tested for the x86

01:24:14,830 --> 01:24:19,830
but as far as I remember on the ARM64 case,

01:24:19,920 --> 01:24:22,800
it seemed to work fine, so.

01:24:24,451 --> 01:24:26,510
- I mean it could be configured,

01:24:26,510 --> 01:24:29,080
like on x86 I think bugs are

01:24:29,080 --> 01:24:32,120
annotated by GCC to be no return.

01:24:32,120 --> 01:24:35,560
So, this compiler already assumes you don't return from it.

01:24:35,560 --> 01:24:37,350
If you did, bad things would happen.

01:24:37,350 --> 01:24:39,300
So, obj tool kind of follows that same.

01:24:40,690 --> 01:24:42,400
But, we have to move on.

01:24:42,400 --> 01:24:45,880
We have one more short talk before the break, so.

01:24:48,180 --> 01:24:50,240
- On the future plans, it's like,

01:24:50,240 --> 01:24:52,410
before I posted my code Angus had

01:24:52,410 --> 01:24:54,690
posted one of the really nice cleanup already.

01:24:54,690 --> 01:24:57,870
We have an object tool code floating for ARM.

01:24:57,870 --> 01:24:59,530
So, the good thing would be like

01:24:59,530 --> 01:25:01,870
if we can get the ARM code patched in

01:25:01,870 --> 01:25:03,900
because it has a lot of cleanups already.

01:25:03,900 --> 01:25:05,700
And my current patch is based on it

01:25:05,700 --> 01:25:08,340
because more realistic cleanups are similar

01:25:08,340 --> 01:25:10,730
so I'm just rebasing it on the ARM code.

01:25:10,730 --> 01:25:13,660
It would be nice if people can test more off it

01:25:13,660 --> 01:25:16,430
or just review it more and get the ARM thing in

01:25:16,430 --> 01:25:19,330
so that the thing would be easy for me to get it in.

01:25:20,720 --> 01:25:23,960
So, the reason why I saying is it decodes a lot of things.

01:25:23,960 --> 01:25:26,610
I mean, it's a nice work where arch dependent

01:25:26,610 --> 01:25:28,210
and independent pieces are done.

01:25:29,080 --> 01:25:31,540
But, my personal opinion is like,

01:25:31,540 --> 01:25:34,550
once we get all the three things in then

01:25:34,550 --> 01:25:36,350
possibly there are a lot of other cleanups

01:25:36,350 --> 01:25:37,730
which I would like to do,

01:25:37,730 --> 01:25:41,932
especially with the arch bits and the non-arch bits.

01:25:41,932 --> 01:25:45,250
I want to do that because it's still more

01:25:45,250 --> 01:25:46,970
arch specific even after the cleanup so.

01:25:46,970 --> 01:25:49,410
So, that's my thing.

01:25:49,410 --> 01:25:52,680
And possibly use the same GCC plugin

01:25:52,680 --> 01:25:55,090
which does the switch table direction.

01:25:55,090 --> 01:25:57,093
It's common between power and arch, I mean ARM.

01:25:57,093 --> 01:25:59,650
And, the last thing would be it's

01:25:59,650 --> 01:26:01,710
like triggers more and more testing.

01:26:01,710 --> 01:26:05,030
As of now, I've just tried it on one particular GCC version

01:26:05,030 --> 01:26:06,490
and I'm not aware of all the

01:26:06,490 --> 01:26:09,960
subsets of instructions which are generated on par.

01:26:09,960 --> 01:26:12,500
That means that I will need to try at least,

01:26:12,500 --> 01:26:15,460
like, two or three versions of compiler

01:26:15,460 --> 01:26:18,500
before posting it and I'm sure there are, like, a lot more

01:26:18,500 --> 01:26:21,370
tricky instructions which I need to take care of.

01:26:21,370 --> 01:26:24,720
And, the current idea which I'm using for all those things

01:26:24,720 --> 01:26:26,950
has always been alternative instructions,

01:26:28,170 --> 01:26:29,040
which are dead end for me.

01:26:29,040 --> 01:26:32,530
And I'm sure there are like most modern way of doing things.

01:26:32,530 --> 01:26:35,850
I just push it sometime later this year

01:26:35,850 --> 01:26:36,930
and yeah, please review it

01:26:36,930 --> 01:26:39,050
and let me know what you guys think about it.

01:26:39,920 --> 01:26:41,420
And thanks a lot for last year

01:26:41,420 --> 01:26:45,350
when you pitched a lot of ideas so it did help a lot.

01:26:45,350 --> 01:26:46,586
Thank you.

01:26:46,586 --> 01:26:49,586
(audience clapping)

01:27:08,590 --> 01:27:12,160
- Hi, I'm Joe Lawrence from Red Hat.

01:27:12,160 --> 01:27:13,460
I work on the kpatch team.

01:27:14,410 --> 01:27:16,796
So I know we are running a little late,

01:27:16,796 --> 01:27:20,210
so this talk is pretty quick and simple.

01:27:20,210 --> 01:27:23,090
Slide one almost speaks for itself, and that is,

01:27:23,090 --> 01:27:25,643
do we need a livepatch developers guide?

01:27:28,077 --> 01:27:32,490
Quickly I just go over, for people maybe not familiar

01:27:32,490 --> 01:27:36,726
with our existing livepatch documentation.

01:27:36,726 --> 01:27:40,000
We have a bunch of files in the tree

01:27:40,000 --> 01:27:42,420
that cover a range of subjects

01:27:42,420 --> 01:27:45,820
and I think the documentation is actually really good.

01:27:47,185 --> 01:27:52,110
And for every subject it describes how the feature works,

01:27:52,110 --> 01:27:55,694
how you might use it, maybe a little bit of history,

01:27:55,694 --> 01:27:59,810
and some of the sections even have used cases

01:27:59,810 --> 01:28:00,760
sprinkled in there.

01:28:02,420 --> 01:28:05,970
So, like I said, this pretty much covers, I think,

01:28:05,970 --> 01:28:09,910
all the current features that livepatch supports.

01:28:13,040 --> 01:28:16,960
On the other hand, the kpatch project kind of took

01:28:16,960 --> 01:28:20,749
a different angle as far as documentation.

01:28:20,749 --> 01:28:25,180
And we have a developers guide on GitHub

01:28:25,180 --> 01:28:28,813
that covers this set of subjects.

01:28:30,950 --> 01:28:35,950
It's very similar to the livepatching ones, however,

01:28:36,510 --> 01:28:41,510
we kind of document from the perspective of a patch writer

01:28:41,910 --> 01:28:46,910
who may have a question and not know specifics about

01:28:49,450 --> 01:28:51,250
any particular subject.

01:28:51,250 --> 01:28:54,870
So, for example, I'll just go back real quick.

01:28:54,870 --> 01:28:58,820
So, even though I think I wrote a lot of the unpatching

01:28:58,820 --> 01:29:02,610
callbacks documentation, I have to go back to it a lot,

01:29:02,610 --> 01:29:05,580
to kind of verify, oh you know, how does it work?

01:29:05,580 --> 01:29:06,780
How did we implement it?

01:29:07,910 --> 01:29:11,470
That said, if somebody didn't know about the unpatching

01:29:11,470 --> 01:29:14,360
callbacks, or they didn't know about shadow variables,

01:29:16,110 --> 01:29:19,070
they, I guess, would just have to go read through the entire

01:29:19,070 --> 01:29:20,720
list of documentation.

01:29:20,720 --> 01:29:25,720
So, the question that I had is that the current kpatch

01:29:27,780 --> 01:29:31,890
author guide is out of date and it references some

01:29:31,890 --> 01:29:33,390
deprecated features.

01:29:33,390 --> 01:29:37,270
It's talking about the days when kpatch

01:29:37,270 --> 01:29:41,810
carried its own helper module to support things

01:29:41,810 --> 01:29:46,805
like callbacks, and shadow variables, and things like that.

01:29:46,805 --> 01:29:50,350
And at the same time, it doesn't reference some of

01:29:50,350 --> 01:29:54,280
the new features that we have upstream like atomic replace.

01:29:55,860 --> 01:29:59,280
So, if we're in the space of

01:29:59,280 --> 01:30:02,970
needing to update the kpatch guide,

01:30:02,970 --> 01:30:06,580
the question I kind of had for livepatch developers is

01:30:06,580 --> 01:30:11,030
whether or not the documentation that we have upstream

01:30:11,030 --> 01:30:14,990
for livepatch in the kernel is sufficient for everybody,

01:30:14,990 --> 01:30:17,310
if it's easy to understand, and you know,

01:30:17,310 --> 01:30:20,200
in a format that's easy to digest,

01:30:20,200 --> 01:30:22,700
or maybe there's some ways we can

01:30:22,700 --> 01:30:26,460
make it better and easier to understand.

01:30:28,200 --> 01:30:30,580
So, this is the last slide

01:30:30,580 --> 01:30:32,430
and these were the potential options.

01:30:33,622 --> 01:30:35,060
The first one is pretty simple,

01:30:35,060 --> 01:30:36,230
and maybe everything's great

01:30:36,230 --> 01:30:37,590
and we don't need to do anything.

01:30:38,920 --> 01:30:43,150
Another option, when one of the kpatch developers eventually

01:30:43,150 --> 01:30:47,590
gets around to updating our documentation for kpatch build,

01:30:47,590 --> 01:30:50,851
maybe we can extract some of the livepatch

01:30:50,851 --> 01:30:54,150
relevant pieces and put that upstream.

01:30:55,750 --> 01:30:57,450
Maybe some other ideas are

01:30:58,590 --> 01:31:01,400
just make a file of frequently asked questions.

01:31:02,320 --> 01:31:05,600
And we get these a lot on the kpatch mailing list

01:31:05,600 --> 01:31:09,900
or the GitHub issues where people try to do something.

01:31:10,860 --> 01:31:15,860
Maybe we can just refer them to the relevant RST file.

01:31:16,360 --> 01:31:18,690
Oh, I want to do this thing.

01:31:18,690 --> 01:31:20,100
Go see shadow variables.

01:31:22,680 --> 01:31:25,900
And then the final ideas, which are probably a lot more work

01:31:27,200 --> 01:31:30,880
could include just going over various

01:31:32,398 --> 01:31:36,253
existing CVE's when people go and fix them.

01:31:36,253 --> 01:31:37,500
What did they do?

01:31:38,490 --> 01:31:41,480
What were some of the challenges that they had?

01:31:41,480 --> 01:31:45,240
And how did they go about fixing that?

01:31:45,240 --> 01:31:49,600
I think Nicolai did this awhile back for one of the melt,

01:31:53,090 --> 01:31:54,429
was it meltdown?

01:31:54,429 --> 01:31:56,679
Okay, and it was a very interesting read, so.

01:31:58,270 --> 01:32:00,530
Anyway, those are just kinda some of the ideas I had

01:32:00,530 --> 01:32:04,030
and wanted to see what you guys thought.

01:32:04,030 --> 01:32:06,870
- So, I think, does it work?

01:32:07,780 --> 01:32:08,613
Okay.

01:32:08,613 --> 01:32:12,184
So, I think the answer to all of those is yes.

01:32:12,184 --> 01:32:13,660
We'd like to have --

01:32:13,660 --> 01:32:15,170
- Yes to everything is perfect!

01:32:15,170 --> 01:32:16,360
- Yeah, no.

01:32:16,360 --> 01:32:19,270
(laughing)

01:32:19,270 --> 01:32:23,320
Yes, as in, we like to have everything like this.

01:32:23,320 --> 01:32:28,320
So, yesterday Jonathan complained in his talk

01:32:28,430 --> 01:32:32,290
that the current documentation folder

01:32:32,290 --> 01:32:35,600
is a huge pile of different things.

01:32:35,600 --> 01:32:40,180
So, there's kernel process deployment documentation.

01:32:40,180 --> 01:32:42,400
There's a documentation for administrators.

01:32:43,411 --> 01:32:46,490
There are docs for kernel developers

01:32:46,490 --> 01:32:48,770
and user documentation as well.

01:32:48,770 --> 01:32:51,400
So, it should be sorted somehow.

01:32:51,400 --> 01:32:54,820
And currently I think we only have

01:32:54,820 --> 01:32:56,640
kernel developer documentation.

01:32:56,640 --> 01:33:01,640
So, explaining features and the design of livepatching.

01:33:03,540 --> 01:33:06,290
So, I think it's a great idea to have

01:33:06,290 --> 01:33:08,440
a documentation for users as well.

01:33:08,440 --> 01:33:12,170
So, explaining examples.

01:33:14,080 --> 01:33:17,440
- Okay, so, one small reservation they have with

01:33:17,440 --> 01:33:19,140
the users side of things is

01:33:19,140 --> 01:33:21,860
I think there's various implementations.

01:33:21,860 --> 01:33:23,870
Are they using kpatch load?

01:33:23,870 --> 01:33:27,340
Are they using kgraft, etc.?

01:33:27,340 --> 01:33:29,400
- At least kgraft is obsolete, in a way,

01:33:29,400 --> 01:33:30,970
so don't worry about it.

01:33:30,970 --> 01:33:33,980
So, that's one thing which could be crossed out,

01:33:33,980 --> 01:33:37,330
but no, I think upstream livepatch, for example,

01:33:37,330 --> 01:33:40,720
because I don't know about your future plans

01:33:40,720 --> 01:33:45,720
if you plan to migrate from kpatch to upstream.

01:33:48,358 --> 01:33:49,970
- I think right now we are still kinda

01:33:49,970 --> 01:33:52,690
an open mind about either one, right.

01:33:52,690 --> 01:33:54,180
They're both kinda still.

01:33:54,180 --> 01:33:56,250
We have some ideas about how to improve the

01:33:56,250 --> 01:33:58,914
object based, like kpatch build approach.

01:33:58,914 --> 01:34:01,850
And I know, Joe, Nicolai and others

01:34:01,850 --> 01:34:04,870
are working on the source based approach, so.

01:34:04,870 --> 01:34:07,770
We're gonna just kinda, we wanna make a decision

01:34:07,770 --> 01:34:10,490
but we don't think we're in a place to make a decision yet.

01:34:14,450 --> 01:34:18,590
- So, I agree we need a developer

01:34:18,590 --> 01:34:21,320
and a user guide that needs to be separate.

01:34:22,630 --> 01:34:25,210
The kernel one is great, livepatch,

01:34:25,210 --> 01:34:27,080
when I look at it that's all there.

01:34:27,080 --> 01:34:29,710
But then when it comes to the user space tools to create,

01:34:29,710 --> 01:34:30,730
I don't know which ones to use.

01:34:30,730 --> 01:34:32,330
This, of course, there's kpatch,

01:34:32,330 --> 01:34:35,130
there's kgraft, there's probably something else.

01:34:35,130 --> 01:34:39,300
And as he just said, kgraft is being deprecated

01:34:39,300 --> 01:34:41,240
but the other complicating factor

01:34:41,240 --> 01:34:42,800
is when I look at the kpatch tools,

01:34:42,800 --> 01:34:47,560
the kpatch documentation refers to livepatch in some places

01:34:47,560 --> 01:34:49,800
and the kpatch kernel module in some places.

01:34:49,800 --> 01:34:53,040
And kpatch, when it says kpatch

01:34:53,040 --> 01:34:54,670
does it mean the kpatch user space tools

01:34:54,670 --> 01:34:58,950
or kpatch the kernel module which probably no one is using

01:34:58,950 --> 01:34:59,830
when they are talking about

01:34:59,830 --> 01:35:01,410
the upstream kernel one and so on.

01:35:01,410 --> 01:35:03,750
So, it's complicated in that way.

01:35:03,750 --> 01:35:05,670
- We have a great name space problem

01:35:05,670 --> 01:35:07,600
in the kpatch documentation.

01:35:07,600 --> 01:35:09,190
There's only so many different ways

01:35:09,190 --> 01:35:11,320
you can say livepatch, kpatch, et cetera.

01:35:12,680 --> 01:35:15,560
- One thing we could do obviously is like reading one

01:35:15,560 --> 01:35:16,940
which we have for the.

01:35:16,940 --> 01:35:19,340
Every time the feature goes in we have

01:35:19,340 --> 01:35:20,910
the developer guide, as such,

01:35:20,910 --> 01:35:23,430
and have something, like what we have for locking

01:35:23,430 --> 01:35:24,880
which Russ did sometime back.

01:35:25,990 --> 01:35:28,300
Guide for the people, the authors who are going to

01:35:28,300 --> 01:35:29,800
alter a livepatch, as such.

01:35:29,800 --> 01:35:34,800
It's a little common if just a guide for users, as such,

01:35:35,030 --> 01:35:37,660
which exist so possibly

01:35:37,660 --> 01:35:39,850
I'm not sure if we want body documentations or not.

01:35:39,850 --> 01:35:42,550
One for the developer explaining the feature as which,

01:35:42,550 --> 01:35:45,640
I mean we do it always, but the user guide would be like.

01:35:46,920 --> 01:35:49,870
- So it seems like the people definitely

01:35:49,870 --> 01:35:52,680
like the idea of some user documentation.

01:35:53,600 --> 01:35:55,470
Do we feel that the kernel documentation

01:35:55,470 --> 01:35:57,080
is in a good enough place

01:35:57,080 --> 01:35:58,960
or do we feel that needs

01:35:58,960 --> 01:36:00,800
maybe a little bit more hand holding?

01:36:04,560 --> 01:36:09,560
- So, the kernel documentation has currently how to load,

01:36:10,190 --> 01:36:13,840
like, what is the technology behind livepatch

01:36:13,840 --> 01:36:16,750
and how to load and unload, that kind of stuff.

01:36:16,750 --> 01:36:20,820
So, but it can be the one location to have

01:36:20,820 --> 01:36:23,550
both the creation documentation.

01:36:23,550 --> 01:36:28,120
As far as, like, you can have both things merged together

01:36:28,120 --> 01:36:30,370
in a single stream, I think, that would make.

01:36:31,928 --> 01:36:32,940
- We're several minutes into the break right now

01:36:32,940 --> 01:36:35,570
so if you want any snacks or anything

01:36:35,570 --> 01:36:37,120
it's only open during the break

01:36:37,120 --> 01:36:39,326
so I would say we stop right here.

01:36:39,326 --> 01:36:40,730
- Yes, we can come back.

01:36:40,730 --> 01:36:41,563
Thank you.

01:36:41,563 --> 01:36:44,563
(audience clapping)

01:36:53,220 --> 01:36:54,540
- Okay, hello?

01:36:54,540 --> 01:36:56,420
So, my name is Pettr Mladek.

01:36:57,458 --> 01:36:58,670
I'm working for SUSE.

01:36:59,799 --> 01:37:04,603
And I will talk about new API for handling

01:37:07,610 --> 01:37:11,620
system state changes done by livepatches.

01:37:11,620 --> 01:37:16,440
It was an API that was discussed last year

01:37:17,870 --> 01:37:22,870
and it is needed usually for changes done by

01:37:26,100 --> 01:37:27,828
livepatch callbacks

01:37:27,828 --> 01:37:32,828
and, for example, one situation was the L1...

01:37:35,516 --> 01:37:36,349
- L1TF.

01:37:36,349 --> 01:37:41,349
- L1TF vulnerability when it was about

01:37:41,600 --> 01:37:45,990
inverting some byte in patch tables, yeah,

01:37:46,930 --> 01:37:50,320
and actually we could not do this

01:37:50,320 --> 01:37:54,210
before all the call to all the system was able

01:37:54,210 --> 01:37:56,750
to handle this bit correctly.

01:37:56,750 --> 01:38:01,423
So, the livepatch did divide it updated the called

01:38:03,330 --> 01:38:07,770
and then the system was transitioned so that

01:38:11,180 --> 01:38:15,760
every task was able to handle the inverted bit

01:38:16,700 --> 01:38:20,370
and then in post transition callback

01:38:21,640 --> 01:38:24,350
we finally started to invert this bit to

01:38:27,140 --> 01:38:29,820
prevent the vulnerability.

01:38:30,740 --> 01:38:32,840
And, why we need the API.

01:38:33,720 --> 01:38:37,070
It's related to atomic replace

01:38:38,234 --> 01:38:39,890
and maintaining livepatches

01:38:39,890 --> 01:38:42,850
because when we produced another livepatch

01:38:42,850 --> 01:38:46,430
it will fix some more sequence fixes

01:38:46,430 --> 01:38:51,430
then it needs to know what's already on the system.

01:38:51,430 --> 01:38:55,500
So, if there is livepatch that already

01:38:55,500 --> 01:38:57,950
did this change or didn't.

01:38:59,080 --> 01:39:04,080
If it actually needs to convert the bytes or not, and so on.

01:39:08,150 --> 01:39:13,150
And, also, if there might be another version of the fix

01:39:14,157 --> 01:39:19,157
it needs to know what's the situation that's taking over.

01:39:21,882 --> 01:39:26,882
And, also, we actually currently don't have any way how to

01:39:30,850 --> 01:39:35,250
create, like, dependencies or define some compatibility

01:39:35,250 --> 01:39:38,950
between livepatches because we actually even allow

01:39:38,950 --> 01:39:41,550
to install all the livepatch

01:39:41,550 --> 01:39:46,199
it will basically replace the new one but in this case

01:39:46,199 --> 01:39:50,710
it wouldn't work because the other livepatch

01:39:50,710 --> 01:39:53,600
would introduce code that wouldn't be able to

01:39:53,600 --> 01:39:57,410
handle this inverted bit and the system would crash.

01:39:58,410 --> 01:40:03,410
So, we wanted to have some API that would help to keep,

01:40:06,880 --> 01:40:11,880
to help with maintaining this and making it safe.

01:40:12,180 --> 01:40:16,030
On the other hand, this is something that is

01:40:16,030 --> 01:40:18,660
rarely used so we wanted to make it simple.

01:40:19,910 --> 01:40:24,810
So, I came up with this API.

01:40:24,810 --> 01:40:29,810
It's currently sent us, it's second version send

01:40:34,462 --> 01:40:36,590
and he go throughout the positive feedback.

01:40:36,590 --> 01:40:40,010
Anyway, what it does, it introduces

01:40:40,010 --> 01:40:44,840
structures critical state that has just three numbers.

01:40:44,840 --> 01:40:48,300
ID which describes which is some

01:40:51,360 --> 01:40:56,360
number that defines what the system state we are monitoring

01:40:58,120 --> 01:41:03,120
or changing, the developer of the live patch

01:41:04,130 --> 01:41:05,380
will just choose one.

01:41:06,260 --> 01:41:09,060
Then there is version, it's again number,

01:41:09,060 --> 01:41:12,620
which means which version of the

01:41:12,620 --> 01:41:15,770
system state is this live patch introducing.

01:41:18,267 --> 01:41:23,267
And, then some data that to the callback store

01:41:24,730 --> 01:41:27,520
for this state so that the new version

01:41:27,520 --> 01:41:30,440
of the livepatch could take over

01:41:31,590 --> 01:41:33,890
and pass some information to the

01:41:33,890 --> 01:41:35,340
new version of the livepatch.

01:41:36,340 --> 01:41:38,320
Or, when the livepatch gets disabled

01:41:38,320 --> 01:41:41,650
so it has some information on how to actually the stuff.

01:41:44,620 --> 01:41:49,180
This structure is added to the

01:41:50,570 --> 01:41:53,870
top level structure call of the livepatch

01:41:53,870 --> 01:41:57,610
as there might be array at this state

01:41:57,610 --> 01:42:02,610
so each live patch could handle more states independently.

01:42:05,390 --> 01:42:08,370
And know there are three functions.

01:42:08,370 --> 01:42:12,770
One is klp_is_patch_compatible.

01:42:13,860 --> 01:42:18,360
And it's supposed to be called

01:42:18,360 --> 01:42:20,960
when the new live patch is enabled

01:42:20,960 --> 01:42:24,133
and what it does, it's checking the

01:42:27,310 --> 01:42:31,130
system status are already somehow set

01:42:31,130 --> 01:42:33,710
by the already installed livepatches

01:42:33,710 --> 01:42:37,160
and compare it with the states that the new livepatch

01:42:38,000 --> 01:42:41,420
is going to change or is able to handle.

01:42:41,420 --> 01:42:45,890
And there is actually difference between atomic replace

01:42:45,890 --> 01:42:50,890
or cumulative patch because this patch has to be able

01:42:51,170 --> 01:42:56,140
to handle all existing changes so that

01:42:56,140 --> 01:43:01,140
its version provided its array of the states

01:43:01,290 --> 01:43:04,240
has to be the same or higher

01:43:04,240 --> 01:43:06,370
than the already installed patches

01:43:07,350 --> 01:43:10,310
and it has to support all the states

01:43:10,310 --> 01:43:14,560
that are already manipulated by already installed patches.

01:43:14,560 --> 01:43:19,560
While the patch that is not replacing the older patches

01:43:21,430 --> 01:43:25,500
it is allowed to modify existing state for this

01:43:25,500 --> 01:43:29,350
the number has to be higher or the same

01:43:29,350 --> 01:43:33,900
as already existing but it doesn't have to handle

01:43:33,900 --> 01:43:36,110
all states at, yeah.

01:43:36,110 --> 01:43:38,750
And of course, patches could add

01:43:38,750 --> 01:43:41,310
new states or modify new states.

01:43:43,640 --> 01:43:46,030
And so this is the framework to handle

01:43:46,030 --> 01:43:48,180
the compatibility and then there are

01:43:49,530 --> 01:43:52,640
two functions to manipulate the state.

01:43:53,640 --> 01:43:58,640
One is klp_get_state that takes our argument

01:43:59,970 --> 01:44:03,480
pointed to the klp patch structure

01:44:03,480 --> 01:44:06,480
and typically it will be used in the callbacks

01:44:06,480 --> 01:44:09,800
and has a parameter it will get pointed to the

01:44:09,800 --> 01:44:14,680
locally defined variable patch

01:44:14,680 --> 01:44:19,680
which means the current patch, and the ID of that feature.

01:44:19,840 --> 01:44:24,840
And it will, this function just simply search

01:44:25,390 --> 01:44:29,950
the array of the states and return the point that's there.

01:44:30,860 --> 01:44:35,860
And so then you could access the data and so on.

01:44:38,730 --> 01:44:41,440
You usually don't need to care much about the version

01:44:41,440 --> 01:44:44,120
because you know your version

01:44:44,120 --> 01:44:46,260
and you know that when this is called

01:44:46,260 --> 01:44:48,960
it will already pass the check that we are compatible.

01:44:50,660 --> 01:44:55,460
And now, there is the other function that is needed

01:44:55,460 --> 01:44:58,720
to like take over or update the already

01:44:58,720 --> 01:45:03,600
existing changes and it's function klp_get_prev_state.

01:45:03,600 --> 01:45:08,000
It just takes ID and it search list of

01:45:08,000 --> 01:45:10,110
already installed live patches

01:45:11,530 --> 01:45:15,050
and search the array of states

01:45:15,050 --> 01:45:20,050
and retune the structure from the last installed

01:45:22,300 --> 01:45:25,100
livepatch that handle this state.

01:45:27,070 --> 01:45:29,850
And so that in the callbacks then you can use

01:45:29,850 --> 01:45:33,260
something like this like if the previous state exists

01:45:33,260 --> 01:45:35,520
then you might reuse it

01:45:35,520 --> 01:45:38,770
or just do nothing, or just copy the data,

01:45:38,770 --> 01:45:40,150
or something like this.

01:45:41,110 --> 01:45:45,020
Or, if it doesn't exist then you actually need to do

01:45:45,020 --> 01:45:50,020
actual changes and, for example, in the pre-transition

01:45:51,110 --> 01:45:55,510
callback you might need to allocate the buffer

01:45:55,510 --> 01:45:59,090
for the data because this is the only place,

01:46:00,190 --> 01:46:02,400
because the allocation could fail

01:46:02,400 --> 01:46:05,310
and pre-callback is the only callback that

01:46:05,310 --> 01:46:09,020
could fail and actually prevent the live patch from loading.

01:46:10,480 --> 01:46:15,480
And then, in the post patch callback you could fill the data

01:46:17,099 --> 01:46:20,700
and whatever you need to do to there.

01:46:23,380 --> 01:46:24,890
So, that's it.

01:46:25,800 --> 01:46:28,010
- [Audience Member] So, did you actually try to implement

01:46:28,010 --> 01:46:32,100
the Avantia fix using this API to see how much it actually

01:46:32,100 --> 01:46:33,520
makes things easier?

01:46:35,081 --> 01:46:36,310
- Not really.

01:46:36,310 --> 01:46:38,940
I have made selftest when I did

01:46:38,940 --> 01:46:43,940
some artificial modification of code. (laughs)

01:46:44,547 --> 01:46:45,380
- [Audience Member] Oh, sure.

01:46:47,330 --> 01:46:52,330
- Yeah, so, I use the data to save the old value

01:46:52,560 --> 01:46:56,234
and I set some another level

01:46:56,234 --> 01:47:01,234
and do a self test is doing even update

01:47:03,188 --> 01:47:05,280
and so on and disabling

01:47:07,160 --> 01:47:09,580
and checks that the local handled.

01:47:18,440 --> 01:47:23,440
I hope that Nicolai would give his opinion

01:47:24,410 --> 01:47:28,560
on whether it would makes him life easier

01:47:28,560 --> 01:47:33,030
or more complicated or if it would be good enough for him.

01:47:33,980 --> 01:47:37,000
- So, yeah I think it would solve the problem

01:47:37,000 --> 01:47:39,375
of this state management

01:47:39,375 --> 01:47:44,270
and yeah I've seen it on the mailing list

01:47:44,270 --> 01:47:45,320
and I liked it a lot.

01:47:46,482 --> 01:47:49,190
I personally think it would work

01:47:49,190 --> 01:47:51,510
with live patches like I want.

01:47:51,510 --> 01:47:53,120
So, it would solve the problem.

01:47:54,340 --> 01:47:55,173
And it's simple.

01:47:56,100 --> 01:47:56,933
Yes.

01:48:00,830 --> 01:48:01,663
- So.

01:48:05,630 --> 01:48:07,340
Any other questions, suggestions?

01:48:12,455 --> 01:48:14,101
(audience member speaking off microphone)

01:48:14,101 --> 01:48:15,600
(everyone laughs)

01:48:15,600 --> 01:48:16,980
- I acted already.

01:48:18,919 --> 01:48:20,930
(audience member speaking off microphone)

01:48:20,930 --> 01:48:23,580
- So I have fix some English,

01:48:24,860 --> 01:48:29,860
English words and strings and send it, push it.

01:48:31,180 --> 01:48:32,714
Okay, thank you.

01:48:32,714 --> 01:48:37,590
- And now we can start the byte sharing.

01:48:37,590 --> 01:48:40,210
- Yeah I was afraid Josh didn't

01:48:40,210 --> 01:48:45,170
look at it in some deep, some.

01:48:46,020 --> 01:48:49,390
- No, I looked at it and it looks good to me.

01:48:49,390 --> 01:48:50,890
I haven't looked at it in the detail,

01:48:50,890 --> 01:48:53,710
I'm sure I'll have some byte check comments,

01:48:53,710 --> 01:48:55,090
very minor things.

01:48:56,180 --> 01:48:58,020
Overall, it looks good.

01:48:59,050 --> 01:49:01,220
- Okay, so, thank you.

01:49:02,320 --> 01:49:05,320
(audience clapping)

01:49:08,229 --> 01:49:09,062
I don't know.

01:49:09,062 --> 01:49:09,895
Who's the next?

01:49:09,895 --> 01:49:10,728
- Joe.

01:49:28,520 --> 01:49:29,420
- Ah, much better.

01:49:30,890 --> 01:49:32,980
Hi, I'm Joe, again.

01:49:32,980 --> 01:49:35,660
And so I'll just start off with an apology

01:49:35,660 --> 01:49:37,200
that I have a lot of slides.

01:49:38,658 --> 01:49:40,530
I didn't have time to make them shorter.

01:49:40,530 --> 01:49:41,870
Sorry!

01:49:41,870 --> 01:49:43,740
And I'm owed a couple slides

01:49:43,740 --> 01:49:45,800
'cause I only had zero slides, I think,

01:49:45,800 --> 01:49:47,494
the last few years, so.

01:49:47,494 --> 01:49:48,940
I'm trying to catch up.

01:49:49,920 --> 01:49:53,550
So, I'm going to talk a bit about klp-convert

01:49:53,550 --> 01:49:55,270
and livepatch relocations.

01:49:57,980 --> 01:50:00,230
This talk probably would have made a lot more sense

01:50:00,230 --> 01:50:05,210
before we had the big late module patching conversation.

01:50:05,210 --> 01:50:09,150
But, for those who maybe missed some of those details

01:50:09,150 --> 01:50:13,430
there's a lot of review as to what this patch said

01:50:13,430 --> 01:50:15,810
and what this tool is trying to accomplish

01:50:15,810 --> 01:50:19,630
and currently what's the status of the patch set.

01:50:19,630 --> 01:50:20,463
What's solved?

01:50:20,463 --> 01:50:21,296
What's left?

01:50:24,030 --> 01:50:26,320
So, history is that this has been around

01:50:26,320 --> 01:50:27,420
for a couple of years.

01:50:28,498 --> 01:50:32,630
I think Josh posted the first RFC maybe in 2006.

01:50:33,570 --> 01:50:36,420
And it's kind of been, 2016, right.

01:50:38,128 --> 01:50:39,700
And it's kind of been passed around.

01:50:39,700 --> 01:50:44,620
I think I had a lot of comments for Joao on his version two.

01:50:44,620 --> 01:50:47,928
I think he eventually just said you can have it, so.

01:50:47,928 --> 01:50:50,240
(laughs) So, here I am.

01:50:51,330 --> 01:50:54,170
And I just wanted to mention that version five

01:50:54,170 --> 01:50:55,800
that's currently in progress

01:50:55,800 --> 01:50:59,710
has a lot of great kbuild cleanup from Masahiro.

01:51:01,361 --> 01:51:03,660
And, review comments from Miroslav.

01:51:05,020 --> 01:51:05,970
So, thank you guys.

01:51:07,100 --> 01:51:11,420
So, the very quick context of what this patchset is doing

01:51:11,420 --> 01:51:15,530
is that this is not related to kpatch build

01:51:15,530 --> 01:51:18,620
so it's not the easy three step

01:51:19,480 --> 01:51:22,730
build a reference, build a patch, and then combine them.

01:51:24,690 --> 01:51:29,690
This is a tool that would be useful in the incredibly simple

01:51:31,220 --> 01:51:35,380
source based patching model where you actually have C files

01:51:35,380 --> 01:51:40,380
and sources that you're dealing with, not the binary diffs.

01:51:43,700 --> 01:51:47,770
The main problem that klp-convert tries to solve is,

01:51:47,770 --> 01:51:50,173
what do you do about trying to access

01:51:50,173 --> 01:51:54,050
un-exported symbols from your livepatches.

01:51:54,050 --> 01:51:57,870
So, if the kernel defines something called

01:51:57,870 --> 01:52:02,770
hats or pretzel logic, maybe another kernel module

01:52:02,770 --> 01:52:06,510
defines a countit function but there is static API,

01:52:06,510 --> 01:52:08,850
how can a livepatch module,

01:52:08,850 --> 01:52:11,690
which is basically a regular module,

01:52:11,690 --> 01:52:13,800
how can you access those symbols?

01:52:13,800 --> 01:52:16,690
And if you try that today, it's just not gonna work.

01:52:19,080 --> 01:52:21,310
So, the first workaround that comes to mind

01:52:21,310 --> 01:52:23,673
is kallsyms lookups.

01:52:23,673 --> 01:52:27,990
In which case you provide, I think the string name,

01:52:27,990 --> 01:52:29,510
and maybe a bit of information about

01:52:29,510 --> 01:52:31,630
the object or the symbol position.

01:52:32,560 --> 01:52:35,250
It's essentially a way of like run time querying.

01:52:35,250 --> 01:52:36,510
You get a pointer.

01:52:36,510 --> 01:52:38,410
So, then all your code has to then kind of

01:52:38,410 --> 01:52:40,630
work through pointer and direction.

01:52:42,960 --> 01:52:45,750
What if there was an automated way to do it?

01:52:45,750 --> 01:52:49,550
And that's what klp-convert seeks to do.

01:52:50,730 --> 01:52:52,280
So, what it does is it actually integrates

01:52:52,280 --> 01:52:54,130
as part of the build process.

01:52:55,070 --> 01:52:56,800
So, when you're building the kernel

01:52:56,800 --> 01:53:01,670
and building all the modules, we create a symbols list

01:53:01,670 --> 01:53:04,890
and that list contains object files

01:53:04,890 --> 01:53:09,890
and a catalog of all the symbols that belong to that object.

01:53:12,730 --> 01:53:17,590
So, then when we go and we want to build a livepatch module

01:53:17,590 --> 01:53:20,650
we've inserted a klp script

01:53:22,050 --> 01:53:23,310
that essentially it says,

01:53:23,310 --> 01:53:25,530
okay you're trying to access hats,

01:53:25,530 --> 01:53:27,530
you're trying to access pretzel logic,

01:53:27,530 --> 01:53:30,860
let's go consult the symbols list to find out

01:53:30,860 --> 01:53:34,590
to whom they belong so we know you know what they are

01:53:34,590 --> 01:53:37,840
and so that we can resolve them later

01:53:37,840 --> 01:53:40,530
when we load your livepatch module.

01:53:44,010 --> 01:53:45,830
So, obviously the next question would be,

01:53:45,830 --> 01:53:47,680
well, how do you pull that magic off?

01:53:49,040 --> 01:53:51,550
And, the answer is relocations.

01:53:51,550 --> 01:53:54,540
And these are not just regular relocations

01:53:54,540 --> 01:53:56,300
that you know and love,

01:53:56,300 --> 01:54:00,813
but these are special livepatch relocations.

01:54:02,820 --> 01:54:05,590
And, what ends up happening when you build your

01:54:05,590 --> 01:54:10,590
livepatch module is that you'll have separate sections

01:54:11,700 --> 01:54:16,700
that been, sort of, have a name encoded in the section name.

01:54:16,750 --> 01:54:19,030
As you can see the section name format.

01:54:20,140 --> 01:54:22,490
So, for things like hats and pretzel logic,

01:54:23,500 --> 01:54:27,280
we've put them in a klp via Linux test section.

01:54:28,500 --> 01:54:31,310
And, the symbol names are sort of

01:54:31,310 --> 01:54:34,260
similarly encoded with special names.

01:54:37,520 --> 01:54:39,740
So, what ends up happening now is when you

01:54:39,740 --> 01:54:41,160
load your live patch module,

01:54:43,080 --> 01:54:47,930
as documented by, I think, Jessica in module ELF format,

01:54:49,410 --> 01:54:54,090
the livepatch core has code that basically

01:54:54,090 --> 01:54:56,350
runs through the relocations,

01:54:56,350 --> 01:54:58,430
looks for the specially named ones,

01:54:58,430 --> 01:55:03,250
and then can look up and resolve those

01:55:03,250 --> 01:55:05,600
relocations at run time.

01:55:05,600 --> 01:55:09,810
So, as future modules get loaded

01:55:09,810 --> 01:55:12,060
we can also resolve some of those as well.

01:55:13,970 --> 01:55:14,803
So,

01:55:17,800 --> 01:55:22,800
right now there is also architecture specific relocations,

01:55:26,920 --> 01:55:30,320
in which case we have an x86 implementation

01:55:31,550 --> 01:55:36,460
that handles alt instructions and parainstructions

01:55:36,460 --> 01:55:40,890
but unfortunately we don't have klp support

01:55:40,890 --> 01:55:43,700
so as far as generating those sections

01:55:43,700 --> 01:55:47,820
I think kpatch build might be the only tool

01:55:47,820 --> 01:55:49,220
that creates them today.

01:55:53,690 --> 01:55:57,150
So, the next few slides we're doing kind of

01:55:57,150 --> 01:56:00,780
a quick review and samples of what are

01:56:00,780 --> 01:56:04,200
some of the special sections that you may find in the kernel

01:56:04,200 --> 01:56:06,580
and sort of why are they interesting to us

01:56:06,580 --> 01:56:09,420
and why do we need to do special relocations for them.

01:56:11,250 --> 01:56:12,930
So, I set about going through the kernel

01:56:12,930 --> 01:56:15,840
and had to basically learn what all these

01:56:15,840 --> 01:56:17,920
special sections mean and do.

01:56:19,850 --> 01:56:24,011
The simplest example was smp_locks

01:56:24,011 --> 01:56:27,010
and if you had a piece of code that looks like that

01:56:27,010 --> 01:56:29,820
this is what your assembly output would look like

01:56:29,820 --> 01:56:34,110
and then in a special separate section you would have

01:56:34,110 --> 01:56:37,940
these relocations to the code in which case

01:56:37,940 --> 01:56:42,350
they may act differently depending on the smp environment.

01:56:43,680 --> 01:56:45,770
That said, this is a really boring example

01:56:45,770 --> 01:56:48,180
for klp-convert because we don't

01:56:48,180 --> 01:56:49,700
need to do anything special.

01:56:49,700 --> 01:56:51,350
Everything's local to the module.

01:56:52,888 --> 01:56:55,540
But, it seemed like the easiest introduction.

01:56:57,900 --> 01:57:00,430
Things get a little more interesting when you

01:57:00,430 --> 01:57:03,540
want to handle alt instructions.

01:57:03,540 --> 01:57:07,330
So, alternatives are just a means of

01:57:07,330 --> 01:57:12,330
keying off of a CPU feature and you either call in

01:57:12,850 --> 01:57:17,850
one set of assembly instructions or the second set.

01:57:18,220 --> 01:57:23,220
So, in this example I'm just showing you that the,

01:57:23,350 --> 01:57:26,010
so, for that piece of code you get an

01:57:26,010 --> 01:57:30,560
alt instructions section which includes an array

01:57:30,560 --> 01:57:35,560
of structures that have relocations to the old

01:57:37,200 --> 01:57:41,770
or the first alternative code location

01:57:41,770 --> 01:57:43,830
which would be located, I guess, in text.

01:57:44,990 --> 01:57:49,900
And then you also have the alternative instruction

01:57:49,900 --> 01:57:54,700
and that's located in the altinst_replacement section.

01:57:57,650 --> 01:58:00,240
So, initially when you look at this

01:58:00,240 --> 01:58:04,920
there is nothing special that klp-convert necessarily

01:58:04,920 --> 01:58:09,437
needs to do to the alt instructions section.

01:58:09,437 --> 01:58:14,437
However, if the text and the alt instruction

01:58:14,660 --> 01:58:17,130
replacement code, if they themselves had

01:58:17,130 --> 01:58:20,750
relocations then you would need to do something special.

01:58:20,750 --> 01:58:25,750
So, this is sort of where the arch specific nature

01:58:26,720 --> 01:58:30,513
of the klp relocations arose.

01:58:34,870 --> 01:58:39,397
And so this was the sort of problem that we had

01:58:41,620 --> 01:58:43,740
a couple years ago where there was

01:58:43,740 --> 01:58:46,710
an order of operations in problem.

01:58:46,710 --> 01:58:49,440
When you load a module, we would try to apply

01:58:49,440 --> 01:58:52,950
the alternatives first and then much later

01:58:54,060 --> 01:58:56,950
we would resolve the livepatch relocations.

01:58:59,410 --> 01:59:00,600
Right, so.

01:59:02,120 --> 01:59:05,610
The correct order was that we needed to load the livepatch,

01:59:06,860 --> 01:59:10,730
apply our special, funky relocations first,

01:59:10,730 --> 01:59:15,730
and then handle any alternatives and paravert patches.

01:59:17,470 --> 01:59:22,470
So, this is sort of the beginning of the complications of,

01:59:23,280 --> 01:59:27,080
you know, the things that livepatch needs to do to

01:59:27,080 --> 01:59:29,200
handle all of these sections.

01:59:32,680 --> 01:59:37,680
So, right now, kpatch build generates the right klp arch

01:59:40,002 --> 01:59:44,700
relocation sections, but klp-convert does not.

01:59:45,680 --> 01:59:50,040
And, some of that was simply because we didn't know

01:59:51,330 --> 01:59:54,640
where the late module patching discussion was going to go

01:59:54,640 --> 01:59:57,640
or if there'd be big changes to how

01:59:57,640 --> 01:59:59,660
and when we load it in livepatches.

02:00:02,570 --> 02:00:05,590
So, more complicated example is our jump tables.

02:00:05,590 --> 02:00:08,150
We were talking about this earlier.

02:00:08,150 --> 02:00:11,040
Jump tables allow you to sort of dynamically patch

02:00:11,040 --> 02:00:14,790
and choose which code you're executing.

02:00:16,900 --> 02:00:19,350
These are also kind of complicated.

02:00:22,020 --> 02:00:25,550
When you use these you end up with an entry

02:00:25,550 --> 02:00:30,550
in the module's jump table which you have two relocations

02:00:30,610 --> 02:00:35,320
to the sort of default path and, I think, the target path.

02:00:37,540 --> 02:00:40,840
And those are going to be local to the module.

02:00:40,840 --> 02:00:42,100
Not interesting.

02:00:42,100 --> 02:00:44,940
But, what could be interesting is if the module key

02:00:44,940 --> 02:00:48,820
lived somewhere else, so perhaps that's

02:00:48,820 --> 02:00:51,000
another kernel module that's not loaded.

02:00:55,090 --> 02:00:59,630
So, this is yet another klp-convert to do.

02:00:59,630 --> 02:01:01,940
And, in fact, it's a kpatch build to do.

02:01:02,990 --> 02:01:07,250
Today, we just tried to detect their usage

02:01:07,250 --> 02:01:11,790
in kpatch build and then tell the user to do something else,

02:01:11,790 --> 02:01:12,940
to apply a work around.

02:01:14,880 --> 02:01:19,140
So, I think, and as far as I understand handling

02:01:19,140 --> 02:01:22,630
the jump tables, I think we would need to do basically

02:01:22,630 --> 02:01:25,230
the same book keeping that

02:01:25,230 --> 02:01:27,380
we currently do for alt instructions

02:01:27,380 --> 02:01:31,410
and that is if we find one of these

02:01:33,220 --> 02:01:37,080
relocations that need to be resolved externally,

02:01:37,080 --> 02:01:42,080
then we would need to take the entry out of the jump table,

02:01:43,400 --> 02:01:47,310
put it aside in an arch specific section

02:01:48,240 --> 02:01:53,240
and then handle it according to this order of operations.

02:01:55,480 --> 02:01:56,520
Easy peasy, right?

02:02:01,600 --> 02:02:02,433
So, more to do.

02:02:03,770 --> 02:02:07,190
How many other of these architecture specific sections

02:02:07,190 --> 02:02:08,490
do we need to worry about?

02:02:09,490 --> 02:02:13,150
I had only started looking at the x86 ones.

02:02:13,150 --> 02:02:16,720
I think jump tables were probably the most complicated one.

02:02:16,720 --> 02:02:19,980
So, they seem reasonable but at the same time

02:02:19,980 --> 02:02:24,110
it's kind of annoying to have to essentially learn

02:02:24,110 --> 02:02:28,690
all the other code patching and special section mechanisms

02:02:28,690 --> 02:02:33,690
and then potentially modify them to operate dynamically.

02:02:35,300 --> 02:02:36,750
In the case of jump tables,

02:02:36,750 --> 02:02:40,050
I think the code assumes that you're loading

02:02:40,050 --> 02:02:42,680
a kernel module and everything is there for it.

02:02:43,950 --> 02:02:47,140
For us to do this trick, that code is going to

02:02:47,140 --> 02:02:52,020
need to handle the idea of, sort of, inert,

02:02:52,020 --> 02:02:55,140
you know, not ready jump labels

02:02:55,140 --> 02:02:56,700
and then later we're going to have to tell it,

02:02:56,700 --> 02:02:58,190
yeah, this one's ready to go.

02:02:58,190 --> 02:03:00,490
You can, you know, consider it live.

02:03:04,350 --> 02:03:08,360
So, in that regard, I think if we're going to support them,

02:03:08,360 --> 02:03:11,810
I think we need really good tests to make sure that

02:03:11,810 --> 02:03:16,040
when those other kernel features change that, you know,

02:03:16,040 --> 02:03:18,890
we're ensuring that klp-convert

02:03:18,890 --> 02:03:22,260
and livepatch is handling them appropriately.

02:03:24,010 --> 02:03:25,670
I've written a few of these tests

02:03:27,020 --> 02:03:31,730
and then when I was developing klp-convert,

02:03:31,730 --> 02:03:35,220
so I have modules with jump tables that try

02:03:35,220 --> 02:03:37,120
to do like a little bit of everything.

02:03:38,170 --> 02:03:41,820
So, things like that where you have jump tables

02:03:41,820 --> 02:03:44,840
that are defined in another module and it's not loaded,

02:03:44,840 --> 02:03:47,170
or maybe it is loaded, or it gets unloaded,

02:03:47,170 --> 02:03:49,420
all of these things we're going to have to,

02:03:49,420 --> 02:03:51,390
I think, write test for.

02:03:51,390 --> 02:03:53,130
Just to make sure that when the kernel moves

02:03:53,130 --> 02:03:55,040
that we're not missing something.

02:04:01,790 --> 02:04:03,750
- Sounds like would this be solved

02:04:03,750 --> 02:04:05,430
from what we were talking about earlier?

02:04:09,510 --> 02:04:12,440
- Almost, but not everything because this is only.

02:04:14,560 --> 02:04:18,720
This should solve the non-exported symbols as well.

02:04:18,720 --> 02:04:23,050
So, if they could live in VM Linux as well.

02:04:23,050 --> 02:04:26,100
So, if you try to reference non-exported symbols

02:04:26,100 --> 02:04:27,690
should be solved by this.

02:04:27,690 --> 02:04:32,690
We could do it differently and we can restriction

02:04:33,150 --> 02:04:36,390
in the kernel module loader but I'd have to think about it.

02:04:36,390 --> 02:04:37,223
- [Man In Audience] I mean, what's the issue?

02:04:37,223 --> 02:04:38,560
You're talking about the jump labels again.

02:04:38,560 --> 02:04:39,393
Okay, sorry.

02:04:39,393 --> 02:04:41,361
- Yeah, I know that's an example which could be solved.

02:04:41,361 --> 02:04:42,520
- [Man In Audience] Yeah.

02:04:42,520 --> 02:04:43,470
- By your proposal.

02:04:48,020 --> 02:04:51,210
- Yeah, so, most of these complications would go away.

02:04:51,210 --> 02:04:52,980
- [Man In Audience] And this is why I keep saying it's so,

02:04:52,980 --> 02:04:54,290
like everyone's like kind of reluctant

02:04:54,290 --> 02:04:56,950
from doing this but I think your idea is excellent.

02:04:56,950 --> 02:04:59,620
If we have like a k, like you,

02:04:59,620 --> 02:05:02,260
well I'll tell everyone so it's kind of recorded.

02:05:02,260 --> 02:05:05,510
What I was talking off line with Petrr here

02:05:05,510 --> 02:05:08,770
was the fact that if we had, okay, all your,

02:05:08,770 --> 02:05:10,800
you'd break it up per module or object,

02:05:10,800 --> 02:05:13,840
as your terms, and you know you load the kmodule,

02:05:13,840 --> 02:05:15,480
you have a directory in

02:05:15,480 --> 02:05:19,320
slash lib slash module slash you name dash R slash livepatch

02:05:19,320 --> 02:05:21,450
where you load all your modules that

02:05:21,450 --> 02:05:23,200
you're going to patch in.

02:05:23,200 --> 02:05:27,250
Or every module that needs to be patched has its own kpatch.

02:05:27,250 --> 02:05:28,930
Your tool when you're going, okay,

02:05:28,930 --> 02:05:30,970
up or add the live patch, you know,

02:05:32,018 --> 02:05:32,851
we'll load the kernel one

02:05:32,851 --> 02:05:34,680
then it will go through and look at all the modules

02:05:34,680 --> 02:05:37,240
that are loaded and find in this directory which ones

02:05:37,240 --> 02:05:38,090
that need to be loaded.

02:05:38,090 --> 02:05:39,530
So, it's only loaded there.

02:05:39,530 --> 02:05:41,520
Then you modify insert mod or whatever,

02:05:41,520 --> 02:05:43,470
how the user space helper that when you do

02:05:43,470 --> 02:05:47,660
insert a module it will check this path that's defined

02:05:47,660 --> 02:05:49,340
and everything's signed so you make sure

02:05:49,340 --> 02:05:51,170
you're getting everything correctly and you can even

02:05:51,170 --> 02:05:53,170
put version, like info module information

02:05:53,170 --> 02:05:55,550
in there so it even has version numbers and everything else.

02:05:55,550 --> 02:05:58,700
You go and say oh this module has a live patch to it,

02:05:58,700 --> 02:06:00,580
let's do it together on module load.

02:06:00,580 --> 02:06:03,420
Solves all these issues and then if you,

02:06:03,420 --> 02:06:05,130
the question about upgrading,

02:06:05,130 --> 02:06:07,770
you say okay now we want to upgrade you go and you

02:06:07,770 --> 02:06:12,030
do your, you would actually record what you have

02:06:12,030 --> 02:06:15,600
in the directory, blow it away, load all your new stuff in,

02:06:15,600 --> 02:06:17,620
go do all the updates again, just like you did when

02:06:17,620 --> 02:06:19,650
you removed the old atomically remove it

02:06:19,650 --> 02:06:22,540
and re-add it and I think all these

02:06:22,540 --> 02:06:23,980
issues go away with that.

02:06:23,980 --> 02:06:24,813
I ...

02:06:26,550 --> 02:06:28,460
- I'm all for, you know, big changes to

02:06:28,460 --> 02:06:32,830
make this simpler as long as they are consistent, right?

02:06:32,830 --> 02:06:35,800
Don't preclude me in the existing things that we support.

02:06:35,800 --> 02:06:37,820
- So I think that it actually might work.

02:06:37,820 --> 02:06:40,640
It might be a bit tricky because, for example,

02:06:40,640 --> 02:06:45,640
when we are loading some to be patched module later

02:06:45,930 --> 02:06:50,930
then we might need to like load the module then

02:06:51,240 --> 02:06:56,240
but don't call in its script.

02:06:56,370 --> 02:07:01,370
Then we need to load the live patch module

02:07:01,430 --> 02:07:06,430
so that it handles its locations, alternatives,

02:07:07,246 --> 02:07:08,440
all this stuff.

02:07:09,790 --> 02:07:14,790
And even that it actually enables the ftrace

02:07:15,120 --> 02:07:17,710
and stuff like this, to actually to do

02:07:17,710 --> 02:07:19,210
the action to the new code.

02:07:20,290 --> 02:07:22,690
And then when it's like transitioned

02:07:22,690 --> 02:07:27,690
and it's done, then we call in the new script of the

02:07:27,760 --> 02:07:32,760
to be patched module so that the fixed code is used.

02:07:34,450 --> 02:07:37,420
Like, but it's doable just that module code

02:07:37,420 --> 02:07:42,420
is quite tricky, but it's doable, I guess.

02:07:42,890 --> 02:07:47,780
- So, if we split it up so that each,

02:07:47,780 --> 02:07:51,100
basically, each patch module is specific to an object,

02:07:51,100 --> 02:07:53,360
right, or specific to a module, I mean,

02:07:54,504 --> 02:07:56,620
would that break the consistency model

02:07:56,620 --> 02:08:00,500
between modules and the kernel itself, or?

02:08:00,500 --> 02:08:01,980
- Yeah, yeah, I guess that we will

02:08:01,980 --> 02:08:05,020
need some more support from module loader, like,

02:08:05,020 --> 02:08:08,410
that we load new version of the livepatch

02:08:08,410 --> 02:08:12,507
that it will need to first load all the modules

02:08:13,540 --> 02:08:18,265
for each module that is already live patched.

02:08:18,265 --> 02:08:20,510
Once this is done and ready

02:08:20,510 --> 02:08:23,560
then it will need to start transition of

02:08:23,560 --> 02:08:25,860
all these module so we could not do

02:08:25,860 --> 02:08:29,430
by the inert call back from the module

02:08:29,430 --> 02:08:31,010
but it will need to be triggered

02:08:31,010 --> 02:08:32,750
from the module loader, but still,

02:08:33,900 --> 02:08:37,420
I think that it is something like doable, yeah.

02:08:37,420 --> 02:08:39,620
And it would remove, well,

02:08:39,620 --> 02:08:43,290
we still would need like our own code

02:08:43,290 --> 02:08:47,790
to actually create this sections

02:08:47,790 --> 02:08:51,370
but we will actually create the, like, the normal

02:08:51,370 --> 02:08:54,330
location sections, alternative sections,

02:08:54,330 --> 02:08:56,840
- [Joe] Not the arch ones.

02:08:56,840 --> 02:08:59,070
- Not the klp specific ones.

02:08:59,960 --> 02:09:03,080
We would need to keep them around and that stuff.

02:09:03,080 --> 02:09:05,250
- Well, that depends because you either have

02:09:05,250 --> 02:09:10,250
a separate special section with special relocations

02:09:10,530 --> 02:09:14,070
or you leave those as normal ones, ordinary ones,

02:09:14,070 --> 02:09:17,390
but then you need to, you need to change the

02:09:17,390 --> 02:09:21,720
module loader not to warn or error out on them.

02:09:21,720 --> 02:09:22,760
So, that's..

02:09:22,760 --> 02:09:24,290
- No, actually not.

02:09:24,290 --> 02:09:27,340
Because we need to load the module first

02:09:27,340 --> 02:09:30,120
like the to be patched so the symbols will be there.

02:09:31,280 --> 02:09:34,370
- Yes, yes, I know but you still,

02:09:35,710 --> 02:09:40,040
there's that non-ambiguous issue with static symbol

02:09:40,040 --> 02:09:43,590
so that you could have more symbols on the same name

02:09:43,590 --> 02:09:45,930
so you need to still have a name,

02:09:45,930 --> 02:09:48,120
how to differentiate between them.

02:09:48,120 --> 02:09:50,150
- [Audience Member] But, not in the same module.

02:09:50,150 --> 02:09:52,670
- But actually we already do this--

02:09:52,670 --> 02:09:54,270
- Well you could.

02:09:54,270 --> 02:09:55,380
Of course you could, yeah.

02:09:55,380 --> 02:10:00,380
- Yeah you could but it's already done via, it's, yeah, but.

02:10:01,280 --> 02:10:04,890
- Wouldn't the other klp relocations, the normal ones,

02:10:04,890 --> 02:10:05,723
take care of that case?

02:10:05,723 --> 02:10:07,800
- But, it's already solved.

02:10:07,800 --> 02:10:10,800
We have the same troubles when we generate

02:10:10,800 --> 02:10:13,950
our own like klp specific section.

02:10:13,950 --> 02:10:17,740
We already have to resolve the duplicity

02:10:17,740 --> 02:10:19,050
when creating this entry.

02:10:20,480 --> 02:10:21,313
- Oh, yes, sure.

02:10:21,313 --> 02:10:24,730
So, what I'm saying is that you still have to

02:10:24,730 --> 02:10:26,470
have those special sections, so.

02:10:26,470 --> 02:10:29,250
- Yeah, yeah, not special sections.

02:10:29,250 --> 02:10:33,130
Like, we need to be able to create the sections

02:10:33,130 --> 02:10:36,860
but actually we will create like normal sections

02:10:36,860 --> 02:10:39,440
that will be handled by the module loader.

02:10:41,443 --> 02:10:42,504
- No.

02:10:42,504 --> 02:10:44,130
- So, you need extra section but not extra code

02:10:44,130 --> 02:10:48,900
that will be handling it as a special section.

02:10:50,690 --> 02:10:54,820
- Like, we need to create the sections by our own code,

02:10:55,950 --> 02:10:59,510
by some post module was built.

02:10:59,510 --> 02:11:01,640
- Yeah, but they will not be special from the point of view

02:11:01,640 --> 02:11:03,117
of the actual anchor.

02:11:06,940 --> 02:11:09,050
- I think there should be, must be,

02:11:09,050 --> 02:11:12,070
handled separately because what Miroslav was mentioning

02:11:12,070 --> 02:11:15,530
is these multiple symbols of the same name

02:11:15,530 --> 02:11:20,480
and these actually do happen and what the

02:11:20,480 --> 02:11:25,480
klp relocation section provide is that you can

02:11:26,410 --> 02:11:30,140
specify an index which watch symbol of these

02:11:31,460 --> 02:11:33,520
several duplicates you want

02:11:33,520 --> 02:11:35,980
and for that you probably need special code,

02:11:35,980 --> 02:11:38,280
I mean you can merge into the module alone,

02:11:38,280 --> 02:11:40,380
I don't know but.

02:11:41,680 --> 02:11:42,553
- So, that, oh.

02:11:43,771 --> 02:11:45,919
- I was just gonna say that, yeah, for relocation--

02:11:45,919 --> 02:11:48,110
(microphone feedback)

02:11:48,110 --> 02:11:48,943
For relocation..

02:11:49,900 --> 02:11:50,733
Check.

02:11:52,280 --> 02:11:54,730
Okay, for relocations I just think

02:11:54,730 --> 02:11:58,590
you still need the special stuff

02:11:58,590 --> 02:12:00,710
but maybe for everything else you wouldn't.

02:12:01,890 --> 02:12:03,410
For all the alternatives and.

02:12:03,410 --> 02:12:06,790
- Yeah you wouldn't be creating another jump table

02:12:06,790 --> 02:12:10,530
or special section thing, just for this purpose.

02:12:10,530 --> 02:12:12,830
You might still have klp relocations, however.

02:12:14,170 --> 02:12:16,850
And those could be resolved ordinarily.

02:12:23,086 --> 02:12:24,370
Okay.

02:12:24,370 --> 02:12:26,260
To finishing it up, on the lighter

02:12:26,260 --> 02:12:28,600
side of things, other to do's.

02:12:30,010 --> 02:12:32,920
External modules currently the patch set

02:12:32,920 --> 02:12:35,070
really doesn't consider those right now.

02:12:37,168 --> 02:12:39,440
I think we can probably, if somebody really needed that,

02:12:39,440 --> 02:12:42,450
or if that was a requirement we would just

02:12:42,450 --> 02:12:46,770
have to somehow augment the symbol list database.

02:12:46,770 --> 02:12:49,230
I don't know, provide two symbols files

02:12:49,230 --> 02:12:50,380
or something like that.

02:12:51,260 --> 02:12:54,190
I don't know if anybody's really screaming for that,

02:12:54,190 --> 02:12:56,929
so, I think in at least the initial version

02:12:56,929 --> 02:12:59,190
I didn't really consider it a show stopper.

02:13:01,780 --> 02:13:04,570
The other strange bug that we encountered

02:13:04,570 --> 02:13:09,570
while developing the patch set was a BFD library bug

02:13:09,780 --> 02:13:14,780
where if you try to run something like objdump or gdb

02:13:15,900 --> 02:13:19,790
on the generated kernel object files

02:13:20,698 --> 02:13:25,698
they link against this binary format, I guess, library.

02:13:26,020 --> 02:13:29,890
It doesn't, or it didn't, like the fact that

02:13:29,890 --> 02:13:33,980
we were creating a second relocation section

02:13:33,980 --> 02:13:35,550
to the same section.

02:13:36,450 --> 02:13:39,130
It was built with the assumption that you'd only have one,

02:13:39,130 --> 02:13:41,700
you know, dot rella dot text that you wouldn't have,

02:13:41,700 --> 02:13:45,760
like, a dot rella dot klp dot text.

02:13:46,990 --> 02:13:50,240
So, right now, I think there's a,

02:13:50,240 --> 02:13:54,080
it's kinda mitigation that was recently checked in

02:13:54,080 --> 02:13:57,360
to kind of disable that assertion.

02:13:58,277 --> 02:14:03,277
At least with the latest version of bin noodles, anyway,

02:14:03,610 --> 02:14:08,610
and objdump it will at least continue processing the binary.

02:14:08,750 --> 02:14:13,750
It may not make complete sense of our klp sections just yet

02:14:14,780 --> 02:14:18,510
but, again, you can use it to maybe disassemble

02:14:18,510 --> 02:14:21,330
or whatever else you use those tools for.

02:14:25,360 --> 02:14:26,890
So, that's it.

02:14:26,890 --> 02:14:29,850
The patch set is version four, version five

02:14:29,850 --> 02:14:31,000
kind of in development.

02:14:31,850 --> 02:14:33,560
Probably post that soon.

02:14:35,150 --> 02:14:36,160
Any other questions?

02:14:40,140 --> 02:14:40,973
Okay.

02:14:44,270 --> 02:14:45,210
- No? Yes?

02:14:45,210 --> 02:14:46,043
- Sure, maybe.

02:14:50,240 --> 02:14:51,750
- It's actually real one.

02:14:51,750 --> 02:14:53,860
Why call it klp-convert?

02:14:55,290 --> 02:14:58,460
- Kernel livepatch relocation conversion.

02:14:58,460 --> 02:15:01,210
I think it's a question for Josh, he wrote it.

02:15:08,358 --> 02:15:09,290
- It's been a few years.

02:15:09,290 --> 02:15:12,336
(microphone feedback)

02:15:12,336 --> 02:15:13,740
It's been a few years.

02:15:13,740 --> 02:15:15,440
It's been few years since I wrote it

02:15:15,440 --> 02:15:18,260
but I think I was thinking that you

02:15:18,260 --> 02:15:23,260
convert normal relocations into our special klp relocations.

02:15:25,170 --> 02:15:27,660
That was the original intent and then its scope

02:15:27,660 --> 02:15:29,740
may or may not grow depending on this

02:15:29,740 --> 02:15:31,313
late module patching issue.

02:15:38,292 --> 02:15:39,125
- Okay.

02:15:39,125 --> 02:15:40,792
Who's up next?

02:15:40,792 --> 02:15:43,792
(audience clapping)

02:15:56,770 --> 02:15:58,240
- Hi again.

02:15:58,240 --> 02:16:00,520
So this talk is going to be more about

02:16:02,010 --> 02:16:05,330
how well are we testing livepatching infrastructure as such.

02:16:05,330 --> 02:16:09,567
Or, it's more about what is available as far as I know.

02:16:09,567 --> 02:16:11,600
I know the presentation tomorrow,

02:16:11,600 --> 02:16:13,910
how much more can we do, kind of thing.

02:16:14,990 --> 02:16:17,150
So, yeah, previously you handled two columns.

02:16:17,150 --> 02:16:18,550
Now, it's going to be three.

02:16:20,340 --> 02:16:25,290
So, the way it goes is like, on the left most thing,

02:16:27,640 --> 02:16:32,440
when we say livepatch test, as such, as like before 2019.

02:16:32,440 --> 02:16:33,850
I mean, beginning of this year,

02:16:33,850 --> 02:16:35,300
mostly it would mean is like.

02:16:36,850 --> 02:16:40,260
We can load the example modules and everything passes

02:16:40,260 --> 02:16:43,970
and that's fine as of now but beginning of this year

02:16:43,970 --> 02:16:46,630
we merged into selftest so that would mean that

02:16:47,790 --> 02:16:50,260
running a self test and everything's fine

02:16:50,260 --> 02:16:52,470
that we can say that safely.

02:16:53,420 --> 02:16:55,600
I call it this, to this, right,

02:16:55,600 --> 02:16:57,150
the green colored one, the light green.

02:16:57,150 --> 02:16:59,090
I call it as 50% safe.

02:16:59,090 --> 02:17:01,620
Yes, we are ready to go kind of thing.

02:17:01,620 --> 02:17:03,170
That's how I generally dumb it.

02:17:04,820 --> 02:17:08,250
And, I'm sure that most of us have our own

02:17:08,250 --> 02:17:11,970
unit test cases which are lined down in our own laptops.

02:17:11,970 --> 02:17:13,910
Which we use to test the features or

02:17:16,830 --> 02:17:19,930
test the features which are not upstream as of now.

02:17:20,840 --> 02:17:24,050
I know for sure that, you know, kpatch has its own

02:17:25,050 --> 02:17:29,390
set of test cases which is used to test kpatch, as such.

02:17:29,390 --> 02:17:32,220
But, the modules generated out of it can be tested, too.

02:17:32,220 --> 02:17:34,890
Can be used to test the kernel infrastructure,

02:17:34,890 --> 02:17:37,810
I mean, live patching whole infrastructure as of now.

02:17:38,780 --> 02:17:42,240
And, yes, what we do is, like, anyways,

02:17:42,240 --> 02:17:47,240
we do build live patches for all the CVE's and sacred fixes.

02:17:47,930 --> 02:17:51,260
That also exercises how well is the

02:17:51,260 --> 02:17:53,661
kernel infrastructure, as such.

02:17:53,661 --> 02:17:57,601
So, I call that as like 100%, like,

02:17:57,601 --> 02:18:00,500
if it passes both this condition,

02:18:00,500 --> 02:18:03,570
and it does, mostly it's like, so, yeah.

02:18:03,570 --> 02:18:05,820
So, then it's like 100% pass kind of a thing.

02:18:06,850 --> 02:18:09,960
So, this is what I'm aware that we currently have.

02:18:11,470 --> 02:18:13,910
And this how we are testing livepatching

02:18:13,910 --> 02:18:15,300
infrastructure, as such.

02:18:16,670 --> 02:18:18,500
I'll come to the random thing later

02:18:18,500 --> 02:18:20,990
and if you're going to see the combinations

02:18:20,990 --> 02:18:23,620
which I'm aware of what people test is like

02:18:23,620 --> 02:18:27,220
the distro kernel, distro tool chain,

02:18:28,540 --> 02:18:31,130
upstream kernel, distro tool chain.

02:18:31,130 --> 02:18:33,780
And you have upstream kernel and upstream tool chain.

02:18:33,780 --> 02:18:35,160
These are the combinations I've seen

02:18:35,160 --> 02:18:39,673
people testing livepatch with, and so.

02:18:40,670 --> 02:18:42,240
Again, the same combinations, right.

02:18:42,240 --> 02:18:44,640
If everything goes well with distro kernel

02:18:44,640 --> 02:18:46,920
and distro tool chain then, yeah, that's fine,

02:18:46,920 --> 02:18:48,870
but upstream kernel and distro tool chain

02:18:48,870 --> 02:18:50,260
everything's fine then.

02:18:50,260 --> 02:18:52,940
I call it, like, it's like 100% safe kind of thing.

02:18:52,940 --> 02:18:56,230
I don't know how many of us really do this.

02:18:56,230 --> 02:18:58,380
I put it in the red bar with the

02:18:58,380 --> 02:19:00,920
upstream current GCC build

02:19:00,920 --> 02:19:03,140
and current upstream kernel build it.

02:19:04,220 --> 02:19:07,620
Try building livepatching for that with all the test cases

02:19:07,620 --> 02:19:11,940
which we have so that kind of testing is also done.

02:19:12,920 --> 02:19:14,640
So, this is what I'm currently aware of.

02:19:14,640 --> 02:19:17,460
And, it was glad to see that this time

02:19:17,460 --> 02:19:19,020
our own we have a lot of discussions

02:19:19,020 --> 02:19:20,730
when we having hallway discussions

02:19:20,730 --> 02:19:22,900
even during other talks, like,

02:19:22,900 --> 02:19:25,050
we need to improve the selftest coverage.

02:19:25,050 --> 02:19:28,200
So, that will be something which will be nice to have.

02:19:28,200 --> 02:19:33,180
So, I guess we should be pushing more set of test cases

02:19:33,180 --> 02:19:37,000
and I'll come to the automation part later, later.

02:19:37,000 --> 02:19:40,400
One feedback which I got from the test teams

02:19:40,400 --> 02:19:42,300
that IBM is like,

02:19:42,300 --> 02:19:45,300
"Oh, it's all nice that you guys have.

02:19:45,300 --> 02:19:48,150
"You do a good job of testing but we don't."

02:19:50,190 --> 02:19:51,300
Okay, so they were like,

02:19:51,300 --> 02:19:53,980
"Do you have automated way of doing it?

02:19:53,980 --> 02:19:57,570
"Is that anything like LTB or any of those

02:19:57,570 --> 02:20:01,090
"very prominently used upstream projects

02:20:01,090 --> 02:20:04,880
"which I can just download and does it run perfect?"

02:20:04,880 --> 02:20:06,800
That's one question they had.

02:20:06,800 --> 02:20:08,910
And another question they had was like,

02:20:10,250 --> 02:20:12,440
we do a lot of random things with a lot of things

02:20:12,440 --> 02:20:15,300
like one good example of even which Joe mentioned

02:20:15,300 --> 02:20:17,660
was like load and unload modules,

02:20:17,660 --> 02:20:20,510
like 100 times, 400 times, continuously, like.

02:20:20,510 --> 02:20:22,480
Those kinds of this are, you just enable,

02:20:22,480 --> 02:20:27,480
disable a particular module which we have livepatch for.

02:20:28,292 --> 02:20:29,125
Even the example module if you're going to do

02:20:29,125 --> 02:20:30,720
100 times in order to do,

02:20:30,720 --> 02:20:32,510
to do those kinds of things, right?

02:20:32,510 --> 02:20:35,090
We don't have test cases of those sorts

02:20:35,090 --> 02:20:37,740
which are available in the test suites.

02:20:37,740 --> 02:20:40,080
Which are probably written by a lot of people.

02:20:40,080 --> 02:20:42,370
So, that's something where we lack coverage

02:20:42,370 --> 02:20:43,210
on the failure testcase.

02:20:43,210 --> 02:20:44,472
In order, we don't have testcases that

02:20:44,472 --> 02:20:47,560
really hammers how things are.

02:20:47,560 --> 02:20:49,260
Things which people should not do.

02:20:49,260 --> 02:20:50,790
Those kinds of test cases are something

02:20:50,790 --> 02:20:52,040
which are really missing.

02:20:54,000 --> 02:20:56,970
And, another thing which I wanted to say,

02:20:56,970 --> 02:21:00,030
like, I guess it's time that we start enabling

02:21:00,030 --> 02:21:01,730
livepatches default config in

02:21:01,730 --> 02:21:04,380
upstream kernels is a nice idea, and like.

02:21:04,380 --> 02:21:05,213
So, that.

02:21:07,640 --> 02:21:09,140
Does distribution have it now?

02:21:11,860 --> 02:21:13,600
- [Audience Member] That's not really the criteria

02:21:13,600 --> 02:21:15,660
usually for upstream feature to be enabled.

02:21:15,660 --> 02:21:18,000
Usually most of the feature that are not needed

02:21:18,000 --> 02:21:20,100
should be defaulted as abled.

02:21:20,100 --> 02:21:21,890
- Yes, I'm just asking should we.

02:21:21,890 --> 02:21:23,510
The reason why I ask, though, it's like,

02:21:23,510 --> 02:21:26,900
if it's enabled by default then a lot of automation test,

02:21:26,900 --> 02:21:28,540
I mean, like, pretests which has been run

02:21:28,540 --> 02:21:29,890
by lot many people.

02:21:30,860 --> 02:21:32,850
That would mean if that is enabled

02:21:32,850 --> 02:21:35,450
and selftest is enabled if it can, that means that

02:21:35,450 --> 02:21:38,110
they would capture anything which breaks.

02:21:42,180 --> 02:21:44,900
- I think it should stay as it is right now.

02:21:44,900 --> 02:21:47,110
So, it should be disabled by default.

02:21:47,110 --> 02:21:51,440
And, not, I would say that as Petrr said

02:21:51,440 --> 02:21:54,290
only those features which are required should be enabled

02:21:54,290 --> 02:21:57,730
but with all those changes with GCC

02:21:57,730 --> 02:22:01,030
and the flive patching option I talked about,

02:22:01,030 --> 02:22:02,520
I think it should be disabled by default.

02:22:02,520 --> 02:22:03,353
- Okay.

02:22:04,944 --> 02:22:09,270
- I mean, if the concern is that kernel CI

02:22:10,360 --> 02:22:12,900
or whoever zero enabled

02:22:12,900 --> 02:22:15,020
they do their own configurations anyway.

02:22:15,020 --> 02:22:18,430
Either they run config, which enables livepatch,

02:22:18,430 --> 02:22:20,550
or they actually have their own configuration

02:22:20,550 --> 02:22:22,640
which is what I think the kernel CI people

02:22:22,640 --> 02:22:25,330
they just enable everything for the test station.

02:22:25,330 --> 02:22:26,163
- I'm not sure.

02:22:26,163 --> 02:22:27,150
Possibly we want to cross check with them.

02:22:27,150 --> 02:22:28,190
- [Man In Black Shirt] Yeah, yeah, sure.

02:22:28,190 --> 02:22:29,030
That's a good point.

02:22:29,030 --> 02:22:31,850
- We need them to start running with livepatch enabled.

02:22:31,850 --> 02:22:33,470
- [Man In Black Shirt] That's a good point, definitely.

02:22:33,470 --> 02:22:34,900
Thanks.

02:22:34,900 --> 02:22:36,790
- Yeah and actually I think that there

02:22:36,790 --> 02:22:41,620
is even some file that describes what configuration options

02:22:41,620 --> 02:22:46,620
are needed for the given tests in the self test framework.

02:22:49,260 --> 02:22:52,700
So, actually, so I guess that if

02:22:52,700 --> 02:22:55,310
someone wants to run this test

02:22:55,310 --> 02:22:58,740
then they would likely enable this configure options.

02:22:59,780 --> 02:23:01,730
- Okay, the consensus which I'm trying to get is,

02:23:01,730 --> 02:23:04,020
like, I don't know if we do it

02:23:04,020 --> 02:23:05,070
but the whole point is,

02:23:05,070 --> 02:23:08,310
like, how do we got lot many people to test it indirectly.

02:23:08,310 --> 02:23:09,143
That's the question.

02:23:09,143 --> 02:23:12,950
We do, we do a lot of testing for us.

02:23:12,950 --> 02:23:15,080
These things we generally do not

02:23:15,080 --> 02:23:18,170
but how do we make sure that others also do it.

02:23:18,170 --> 02:23:20,370
That's something, which, is what the

02:23:20,370 --> 02:23:21,500
whole thing's all about.

02:23:21,500 --> 02:23:23,240
It's like, we are doing it.

02:23:23,240 --> 02:23:25,170
How do we help others, or what is those things

02:23:25,170 --> 02:23:27,170
we can do so that it gets more coverage.

02:23:33,255 --> 02:23:35,550
- I think that's a good question.

02:23:35,550 --> 02:23:38,200
We rewind maybe a couple months

02:23:39,640 --> 02:23:41,260
when the stack unwinding,

02:23:41,260 --> 02:23:44,990
or stack trace code broke livepatch,

02:23:44,990 --> 02:23:47,680
even though we had the test in place, I thought.

02:23:48,870 --> 02:23:50,470
It wasn't until Miroslav mentioned it

02:23:50,470 --> 02:23:53,220
on the mailing list that I know that it actually broke.

02:23:54,180 --> 02:23:57,430
And, I did query the zero day guys

02:23:57,430 --> 02:24:02,192
and I ran out of ways to rephrase my question.

02:24:02,192 --> 02:24:05,360
I didn't feel like I really got an answer out of

02:24:07,950 --> 02:24:11,240
exactly when do they run the tests with our configuration.

02:24:12,190 --> 02:24:13,570
That seemed ambiguous.

02:24:14,780 --> 02:24:17,090
So, I don't know, to Kamalesh's point

02:24:17,090 --> 02:24:20,606
the more people to test it the better

02:24:20,606 --> 02:24:22,350
and whatever we can do to make that happen,

02:24:22,350 --> 02:24:23,860
you know, that's reasonable.

02:24:23,860 --> 02:24:25,060
It would be a good idea.

02:24:26,190 --> 02:24:28,840
- One thing we definitely need is failure test cases.

02:24:29,750 --> 02:24:30,583
Things should fail.

02:24:30,583 --> 02:24:34,020
I mean, like, things, like, as of now, we have this like,

02:24:34,020 --> 02:24:35,630
this is how it's supposed to work.

02:24:35,630 --> 02:24:36,463
It works.

02:24:36,463 --> 02:24:37,600
And this is how it's supposed to fail.

02:24:37,600 --> 02:24:39,000
We don't have that criteria.

02:24:40,040 --> 02:24:42,770
- Well, there are a few cases which, I think,

02:24:42,770 --> 02:24:45,350
do fail to say load a module.

02:24:45,350 --> 02:24:49,590
I think, I don't recall off the top of my head but,

02:24:50,660 --> 02:24:52,760
yeah, we don't stress the machine

02:24:52,760 --> 02:24:56,170
or do insane things that a customer might try.

02:24:57,230 --> 02:24:58,063
- And we do.

02:24:58,063 --> 02:25:02,860
We do try to catch a lot of failures at build time.

02:25:02,860 --> 02:25:04,820
Kpatch build also.

02:25:07,380 --> 02:25:09,470
- Having said that, okay, that reminds me of another thing.

02:25:09,470 --> 02:25:11,880
It's like, there are lot of other included

02:25:11,880 --> 02:25:15,720
which captures information when something goes wrong.

02:25:15,720 --> 02:25:18,490
Like, a suicide report or support config.

02:25:18,490 --> 02:25:20,040
I guess we should go back and even check

02:25:20,040 --> 02:25:23,340
whether they capturing information about things

02:25:23,340 --> 02:25:25,170
we should delete from livepatch.

02:25:25,170 --> 02:25:26,003
Yeah, I'm not sure.

02:25:26,003 --> 02:25:28,600
I've not cross checked it just strikes mine.

02:25:28,600 --> 02:25:29,433
Like, now that.

02:25:30,450 --> 02:25:32,030
Anything which enterprise guys would

02:25:32,030 --> 02:25:34,000
might be capturing information about the current state

02:25:34,000 --> 02:25:36,843
of the machine, possibly we want to look at those files.

02:25:39,236 --> 02:25:44,069
(audience member speaking off microphone)

02:25:45,630 --> 02:25:47,810
- Yeah, that's something which we possibly want

02:25:47,810 --> 02:25:49,300
to look into also, actually.

02:25:51,240 --> 02:25:52,073
And,

02:25:53,680 --> 02:25:56,180
the craziest idea which was,

02:25:56,180 --> 02:25:59,990
like, testing random kernel patches,

02:25:59,990 --> 02:26:04,480
try to build it, and see if it breaks or not.

02:26:04,480 --> 02:26:07,290
I'm sure that it's like at least 70% of the patches

02:26:07,290 --> 02:26:09,450
are going to be non-buildable at all.

02:26:09,450 --> 02:26:12,576
And we showed builds we just tried setting it off.

02:26:12,576 --> 02:26:14,520
So, I don't know, it's just like ideas

02:26:14,520 --> 02:26:17,242
which like just came and we've discussing

02:26:17,242 --> 02:26:19,610
how can we break livepatching infrastructure,

02:26:19,610 --> 02:26:21,550
and these were the solutions they came up with.

02:26:21,550 --> 02:26:23,060
It's like, why don't you do it?

02:26:23,060 --> 02:26:24,200
So, the reason why they said it

02:26:24,200 --> 02:26:26,840
was doable was the middle one.

02:26:26,840 --> 02:26:28,360
We have something implementation

02:26:28,360 --> 02:26:29,790
the snow patching implementation.

02:26:29,790 --> 02:26:31,480
What it does, as of now, is

02:26:31,480 --> 02:26:36,190
like it listens to the RPC mailing list.

02:26:36,190 --> 02:26:38,770
So, every patch which comes in it will

02:26:38,770 --> 02:26:41,460
just read that to an internal Jenkins thing,

02:26:41,460 --> 02:26:42,980
which will just do a kernel build.

02:26:43,920 --> 02:26:47,280
So, this solution was like, we just add one more step to it.

02:26:48,340 --> 02:26:50,440
We just create a livepatch there,

02:26:51,296 --> 02:26:52,590
and we just try to insert it.

02:26:52,590 --> 02:26:54,990
So, that's something which is like a little crazier

02:26:54,990 --> 02:26:56,920
and now it's like yeah we can do that

02:26:56,920 --> 02:26:58,380
but I'm showing 70 to 80 percent

02:26:58,380 --> 02:26:59,310
of the patches would not build.

02:26:59,310 --> 02:27:00,280
You're like, that's fine,

02:27:00,280 --> 02:27:03,865
whichever builds let's try inserting it.

02:27:03,865 --> 02:27:07,080
It's like one crazy idea which guys thought of.

02:27:07,080 --> 02:27:09,030
Like, let's do these kinds of things.

02:27:09,030 --> 02:27:09,930
So, this is.

02:27:10,890 --> 02:27:15,060
- Yeah, I've considered similar things in the past.

02:27:15,920 --> 02:27:17,370
One problem with that is that

02:27:18,220 --> 02:27:21,180
just because it builds doesn't mean it's gonna run.

02:27:21,180 --> 02:27:25,330
So, it could crash and we don't know if it crashes

02:27:25,330 --> 02:27:29,827
'cause it's supposed to crash or because it's a real bug.

02:27:32,530 --> 02:27:35,160
- So, what we can always do is the guys have

02:27:35,160 --> 02:27:37,410
gone to the level of where they can fill out the functions.

02:27:37,410 --> 02:27:40,730
And if it had something to do with functions,

02:27:40,730 --> 02:27:43,670
which are like, from the livepatch tree data, as such.

02:27:43,670 --> 02:27:45,270
The functions which we can't hold on.

02:27:45,270 --> 02:27:47,840
This is just the general idea we came up with.

02:27:47,840 --> 02:27:49,460
I'm sure we can define it.

02:27:49,460 --> 02:27:53,230
- I think it would be really helpful for kpatch build

02:27:53,230 --> 02:27:56,010
if we had a way to somehow do that

02:27:56,010 --> 02:28:00,450
or just try to patch every single function

02:28:00,450 --> 02:28:03,240
in the kernel, you know, to see what breaks.

02:28:04,750 --> 02:28:05,600
'Cause, yeah.

02:28:06,680 --> 02:28:08,290
- I guess, I'm like, the whole idea

02:28:08,290 --> 02:28:12,140
which I'm trying to say is, like, how do we go about it?

02:28:12,140 --> 02:28:15,630
- Perhaps for test cases simply something like,

02:28:15,630 --> 02:28:17,800
identity patching would make sense.

02:28:17,800 --> 02:28:20,920
So that it try to replace a kernel with itself

02:28:20,920 --> 02:28:22,590
because you know it's gonna work,

02:28:22,590 --> 02:28:24,710
or how it's supposed to work,

02:28:24,710 --> 02:28:27,460
and you test things in livepatching infrastructure, so.

02:28:32,117 --> 02:28:33,034
- So, yeah.

02:28:35,080 --> 02:28:36,760
I mean, so, I just put across the ideas I had, so.

02:28:36,760 --> 02:28:38,170
The whole thing was like,

02:28:38,170 --> 02:28:39,420
what other things can we do

02:28:39,420 --> 02:28:42,900
or should we start discussing more on how do we start?

02:28:44,300 --> 02:28:48,400
- I had something earlier today.

02:28:48,400 --> 02:28:50,470
I went to the kselftest talk

02:28:51,690 --> 02:28:56,160
and they brought up an idea that I guess I had not

02:28:56,160 --> 02:28:59,510
considered when I created the selftests.

02:28:59,510 --> 02:29:02,710
And that was they were thinking of recommending

02:29:02,710 --> 02:29:07,140
that people grab the latest, greatest kselftests

02:29:07,140 --> 02:29:11,790
and run those against older stable kernels.

02:29:11,790 --> 02:29:13,540
And when I heard her say that,

02:29:13,540 --> 02:29:15,390
I remember thinking, like, oh my god.

02:29:16,490 --> 02:29:18,280
Every time I look at the test I always think of it

02:29:18,280 --> 02:29:21,330
as a snapshot of, you know, it's in the tree,

02:29:21,330 --> 02:29:24,580
it's testing that tree, that version.

02:29:24,580 --> 02:29:27,780
And, it kind of, you know made me wonder

02:29:27,780 --> 02:29:32,780
if we need an easier way, from the testing perspective, of

02:29:34,360 --> 02:29:37,360
figuring out what livepatching features,

02:29:37,360 --> 02:29:41,950
or feature versions, I guess, like, currently exists.

02:29:42,980 --> 02:29:43,813
You know, we.

02:29:43,813 --> 02:29:47,260
Do we maybe export a sysfs file that says,

02:29:47,260 --> 02:29:50,680
I don't know, has shadow variables.

02:29:50,680 --> 02:29:53,520
Or, has callbacks or atomic replace.

02:29:54,580 --> 02:29:56,610
Maybe this is all on one file, you know.

02:29:56,610 --> 02:29:59,360
Some way to get at it from user space

02:29:59,360 --> 02:30:03,820
without having to parse from kernel revision strings.

02:30:04,960 --> 02:30:07,590
I know from the kpatch build experience,

02:30:07,590 --> 02:30:12,590
when you start parsing the version strings

02:30:12,760 --> 02:30:14,490
you have to put in all these exceptions

02:30:14,490 --> 02:30:16,060
for the distributions, right.

02:30:16,060 --> 02:30:17,410
'Cause they start backboarding stuff

02:30:17,410 --> 02:30:18,960
and it's just kind of annoying.

02:30:19,860 --> 02:30:24,860
- So, do you know how the others use it in the selftests?

02:30:24,880 --> 02:30:28,140
I mean, because we are not the only ones with features.

02:30:28,140 --> 02:30:28,973
- I'd have to go look.

02:30:28,973 --> 02:30:30,070
I don't know.

02:30:30,070 --> 02:30:32,840
Other people that stated they have ways

02:30:32,840 --> 02:30:34,680
of reporting the features.

02:30:35,740 --> 02:30:40,120
And, the initial, I think this is

02:30:40,120 --> 02:30:43,810
in a couple of weeks or months ago,

02:30:43,810 --> 02:30:45,240
had a similar issue where I wanted to

02:30:45,240 --> 02:30:49,040
disable the tests for architectures that we don't

02:30:49,040 --> 02:30:51,930
support and I think I just wanted to key off

02:30:51,930 --> 02:30:54,030
the configuration variable.

02:30:54,030 --> 02:30:55,500
Because I'm a developer.

02:30:55,500 --> 02:30:56,360
I'm lazy.

02:30:56,360 --> 02:30:59,060
I run the tests from inside my kernel tree.

02:30:59,060 --> 02:31:01,870
The kernel configuration isn't present.

02:31:01,870 --> 02:31:03,740
So, the problem would be, I guess,

02:31:03,740 --> 02:31:06,550
if somebody installs the tests separately

02:31:06,550 --> 02:31:08,670
and they don't have the config.

02:31:08,670 --> 02:31:10,530
How do you get there from here?

02:31:10,530 --> 02:31:11,940
It's kind of an annoying thing.

02:31:11,940 --> 02:31:13,640
You know, you're building this user space thing

02:31:13,640 --> 02:31:15,000
out of the kernel tree, so.

02:31:17,080 --> 02:31:21,240
- I think this something general, so.

02:31:21,240 --> 02:31:22,073
- Yeah, must be.

02:31:22,073 --> 02:31:26,730
- We should ask Shua how to do it properly.

02:31:26,730 --> 02:31:27,590
- Right.

02:31:27,590 --> 02:31:29,170
And I guess two pieces, right?

02:31:29,170 --> 02:31:32,010
There's the kernel side which I would think

02:31:32,010 --> 02:31:34,870
subsystems get to I guess define how they do it.

02:31:34,870 --> 02:31:37,070
And if there's a standard that makes sense.

02:31:37,070 --> 02:31:39,000
A key value store or something.

02:31:40,060 --> 02:31:42,090
You know, could just write a grub utility

02:31:42,090 --> 02:31:44,140
to figure that out, so.

02:31:44,140 --> 02:31:45,490
The selftest, at the same time,

02:31:45,490 --> 02:31:48,760
could have a little library to help us out with that.

02:31:53,534 --> 02:31:55,720
- The last thing which, where I was like, I guess,

02:31:55,720 --> 02:32:00,330
something like CI for the patches which we are trying to do.

02:32:00,330 --> 02:32:01,700
At least with the livepatch data something

02:32:01,700 --> 02:32:03,390
which possibly we want.

02:32:06,350 --> 02:32:08,770
That would be nice to have if all the patches

02:32:08,770 --> 02:32:10,230
with which we are trying to put at least,

02:32:10,230 --> 02:32:13,640
like, a lot of things which other combinations

02:32:13,640 --> 02:32:16,710
which we have with us targets now is like, good enough.

02:32:18,220 --> 02:32:20,470
If it's possible then we should try doing it.

02:32:23,160 --> 02:32:24,200
So, yeah.

02:32:24,200 --> 02:32:26,950
This covers what I had.

02:32:28,030 --> 02:32:29,250
If there's something else which.

02:32:34,780 --> 02:32:37,020
So, one thing, are we going to push the

02:32:37,020 --> 02:32:39,010
testcases from our laptops to selftest?

02:32:42,440 --> 02:32:43,273
- We should.

02:32:43,273 --> 02:32:44,180
- Yeah, okay.

02:32:47,220 --> 02:32:51,090
(audience member speaking off microphone)

02:32:51,090 --> 02:32:53,820
- And another thing would be just like push the report

02:32:53,820 --> 02:32:56,770
and the separate config we want to figure out.

02:33:01,600 --> 02:33:03,417
So, yeah, that's what I had.

02:33:06,017 --> 02:33:07,321
Sure, thanks.

02:33:07,321 --> 02:33:10,321
(audience clapping)

02:33:38,420 --> 02:33:42,424
- My question is more about distribution point of view.

02:33:42,424 --> 02:33:45,850
And,

02:33:45,850 --> 02:33:50,220
how we can involve a user to do livepatching,

02:33:51,460 --> 02:33:53,690
and about open sale sourcing

02:33:53,690 --> 02:33:55,250
livepatching service that we have.

02:33:56,320 --> 02:33:59,800
So, recap last year, we had a suggestion about

02:33:59,800 --> 02:34:01,480
that livepatch repository.

02:34:03,420 --> 02:34:05,520
At work about this every improvement but

02:34:06,840 --> 02:34:10,780
we got disabled GCC optimization.

02:34:11,650 --> 02:34:13,710
And, I talking about elivepatch.

02:34:16,728 --> 02:34:20,940
So,

02:34:20,940 --> 02:34:25,460
updating from elivepatch, we move everything to docker.

02:34:26,794 --> 02:34:29,030
And, it's more simple to use

02:34:29,030 --> 02:34:32,450
and we updated the documentation.

02:34:32,450 --> 02:34:36,590
We tried to use travis-ci but it,

02:34:36,590 --> 02:34:40,830
I don't know if, by using kpatch build

02:34:40,830 --> 02:34:44,670
it takes too much time and we going time-out every time.

02:34:45,720 --> 02:34:47,700
So, we will probably try to move

02:34:47,700 --> 02:34:49,200
to a different infrastructure.

02:34:52,370 --> 02:34:53,790
The current infrastructure

02:34:53,790 --> 02:34:58,297
we have docker container but have the kpatch build.

02:34:59,880 --> 02:35:03,110
We've asked about the future we want to use

02:35:03,110 --> 02:35:05,540
a different docker container for

02:35:06,540 --> 02:35:08,717
reproduce the environment better.

02:35:14,590 --> 02:35:17,840
So, the discussion topics are:

02:35:20,350 --> 02:35:22,490
What is the next step from an open source

02:35:22,490 --> 02:35:23,810
distribution point of view

02:35:24,710 --> 02:35:26,390
that maybe doesn't have the resource

02:35:26,390 --> 02:35:27,590
to write each livepatch.

02:35:28,833 --> 02:35:33,550
And, are we even useful for

02:35:33,550 --> 02:35:37,870
open source livepatch distribution.

02:35:40,445 --> 02:35:44,240
And, how we can make more people

02:35:44,240 --> 02:35:46,880
involved already in writing livepatch.

02:35:46,880 --> 02:35:49,520
And I think Joe idea about

02:35:51,880 --> 02:35:53,350
writing more documentation

02:35:53,350 --> 02:35:56,880
is one good point about this.

02:35:58,420 --> 02:35:59,320
That's everything.

02:36:02,690 --> 02:36:06,973
So, if there is any question.

02:36:06,973 --> 02:36:11,973
Or, we can close.

02:36:12,649 --> 02:36:17,649
- Yeah, so to the point of sharing the livepatch sources,

02:36:17,940 --> 02:36:21,050
just a remark that Miroslav was showing to somebody

02:36:21,050 --> 02:36:24,130
during the break that actually we at SUSE actually do

02:36:24,130 --> 02:36:28,690
publish all livepatches we are distributing and generating.

02:36:28,690 --> 02:36:29,784
- [Alice] Okay.

02:36:29,784 --> 02:36:30,617
- Distributing to our customers.

02:36:30,617 --> 02:36:32,840
So they are publicly available in a Git stream.

02:36:34,507 --> 02:36:37,057
- Okay, I think also, I think is doing such things.

02:36:38,020 --> 02:36:39,404
- Maybe, I don't know.

02:36:39,404 --> 02:36:40,449
- Not anymore.

02:36:40,449 --> 02:36:41,652
- Not anymore?

02:36:41,652 --> 02:36:46,017
(audience member speaking off microphone)

02:36:46,017 --> 02:36:47,450
Okay.

02:36:47,450 --> 02:36:49,809
- [Man In Audience] We're working on changing that.

02:36:49,809 --> 02:36:51,372
- And.

02:36:51,372 --> 02:36:56,205
(audience member speaking off microphone)

02:37:08,469 --> 02:37:13,469
And, I think, like, also about order livepatch services

02:37:13,750 --> 02:37:18,750
I heard yesterday from Joe about kernel.

02:37:22,240 --> 02:37:27,010
- Yeah, maybe just to the sharing livepatch resources

02:37:27,010 --> 02:37:31,760
that it also depends on the other patches

02:37:31,760 --> 02:37:36,030
that are applied on the kernel that we are trying

02:37:36,944 --> 02:37:41,120
to livepatch because distributions

02:37:41,120 --> 02:37:45,190
usually have a lot of thousands of patches

02:37:45,190 --> 02:37:46,340
on top of upstream.

02:37:47,820 --> 02:37:49,690
These are called Frankenstein kernels

02:37:49,690 --> 02:37:54,210
so the livepatch from this kernel probably

02:37:54,210 --> 02:37:57,470
wouldn't be good or it will play nice

02:37:57,470 --> 02:38:00,910
with other kernel that don't have the other patches.

02:38:03,080 --> 02:38:05,540
- Yeah, I would like to add that even if you

02:38:05,540 --> 02:38:08,590
focus on like stable, some version of stable,

02:38:10,040 --> 02:38:14,500
and have actually do have source based livepatches.

02:38:14,500 --> 02:38:17,170
I don't know in which from the kpatch build

02:38:17,170 --> 02:38:19,570
livepatches come probably as a diff or something

02:38:20,960 --> 02:38:22,320
but for source based livepatches

02:38:22,320 --> 02:38:24,350
it's the result pretty much depends

02:38:24,350 --> 02:38:26,380
on the configuration and the architecture

02:38:26,380 --> 02:38:28,660
and everything so it's different.

02:38:28,660 --> 02:38:29,493
- [Alice] Yes.

02:38:29,493 --> 02:38:30,326
- Probably.

02:38:31,830 --> 02:38:34,330
- But would we otherwise use it for documentation?

02:38:37,729 --> 02:38:40,015
- [Audience Member] Sorry, can you say that again?

02:38:40,015 --> 02:38:41,770
Can you repeat that question?

02:38:41,770 --> 02:38:44,000
- If there can be anyway user for documentation

02:38:44,000 --> 02:38:46,250
like as example how to make patch

02:38:46,250 --> 02:38:48,210
or the user can use those examples.

02:38:51,060 --> 02:38:52,620
Because I think we're fine with having

02:38:52,620 --> 02:38:53,840
our community around that.

02:38:53,840 --> 02:38:55,790
So, if there are people that are happy.

02:39:03,547 --> 02:39:05,360
I don't know what.

02:39:05,360 --> 02:39:09,210
- Anyway, I think that maybe the best approach will be like

02:39:09,210 --> 02:39:12,310
to automate the stuff and I guess the

02:39:12,310 --> 02:39:17,310
work is in progress like that klp-gcc and klp converter

02:39:18,980 --> 02:39:23,190
are the pieces, big pieces that would help

02:39:23,190 --> 02:39:24,570
to actually automate this.

02:39:28,340 --> 02:39:31,480
- Yeah, I mean, if you're talking about like documenting

02:39:31,480 --> 02:39:36,480
it for like users, gen two users, desktop users,

02:39:36,560 --> 02:39:38,770
so I think there's no way

02:39:38,770 --> 02:39:43,770
because you have to inspect the patch

02:39:44,300 --> 02:39:46,480
basically if it's suitable for livepatching

02:39:46,480 --> 02:39:49,430
or not so I think it could become a problem.

02:39:49,430 --> 02:39:52,790
So, if you want to document it for like a

02:39:52,790 --> 02:39:54,180
certain class of people,

02:39:55,370 --> 02:39:59,570
livepatching off of that's pretty much been

02:39:59,570 --> 02:40:03,360
what Joe's talk had been about, so.

02:40:03,360 --> 02:40:08,360
I think.

02:40:11,144 --> 02:40:12,102
- Okay.

02:40:12,102 --> 02:40:14,360
Thank you.

02:40:14,360 --> 02:40:17,360
(audience clapping)

02:40:26,347 --> 02:40:29,347
(audience laughing)

02:40:33,903 --> 02:40:38,736

YouTube URL: https://www.youtube.com/watch?v=dT7hLONEInA


