Title: LPC2019 - Touch but don’t look: Running the kernel in execute only memory
Publication date: 2019-09-17
Playlist: Linux Plumbers Conference 2019
Description: 
	Touch but don’t look: Running the kernel in execute only memory

Speaker
 Rick Edgecombe (Intel)

Description
Execute only memory can protect from attacks that involve reading executable code. This feature already exists on some CPUs and is enabled for userspace.

This talk will explain how we are working on creating a virtualized “not-readable” permission bit for guest page tables for x86 and the impact to the kernel. This bit can be used to create execute-only memory for userspace programs as done on other architectures, but newly also kernel text itself. This project has a working POC, but requires extra care being taking in the kernel going forward around certain code patterns in order for the kernel to run in execute only. This will be the main “call to action” of the talk.

The talk will cover three areas:

-Benefits of execute only memory

As was covered in the talk last year by Kristen Accardi, execute only memory can protect code diversification schemes like KASLR, ASLR, and especially fined grained ASLR. This would be a brief summary and will also touch on some attacks that involve reading kernel text

-How we are implementing this across QEMU, KVM, and the guest Linux Kernel.

The solution is sort of novel and interesting it itself, but most of the talk will be about kernel impact of this feature on not the hypervisor implementation. The gist of the solution involves pretending to the guest that the CPU has one less physical address bit than it actually does, so what looks to the guest like a reserved bit looks to the CPU like a physical address bit. Our proposed new KVM APIs can allow userspace VMMs to duplicate memory such that this bit selects from differently permission-ed copies of the same guest physical memory. Intel EPT has the ability to create execute only guest physical memory, so by having the second half of the memory as execute only, we can make a bit that can mark guest virtual memory as execute only.

-Proposed APIs for using execute only memory in userspace and changes and restrictions required to the Linux kernel in order for it to map its own executable code as execute only.

Our POC required making surprisingly few changes to the Linux kernel, however there were impacts especially around features that involve modifying or mapping new executable code. Long term, however, supporting this feature fully would involve the community agreeing that going forward, code patterns that violate execute only memory would not be allowed in the kernel.
Captions: 
	00:00:01,460 --> 00:00:03,810
- [Rick] All right, I guess I'll just get started.

00:00:03,810 --> 00:00:06,910
So hi, I'm Rick Edgecombe, just to introduce myself a bit

00:00:06,910 --> 00:00:09,486
'cause probably most of you don't know me.

00:00:09,486 --> 00:00:11,500
I work on kernel hardening at Intel.

00:00:11,500 --> 00:00:12,333
Most of my career,

00:00:12,333 --> 00:00:14,650
I've worked on a pretty wide variety of userspace stuff

00:00:14,650 --> 00:00:17,250
before more recently moving into kernel

00:00:17,250 --> 00:00:19,510
and while I've got a bit of a security background,

00:00:19,510 --> 00:00:22,260
I'm much more of an engineer than an exploit developer.

00:00:23,495 --> 00:00:26,090
But today, I'm excited to talk about

00:00:26,090 --> 00:00:26,923
the work I've been doing

00:00:26,923 --> 00:00:29,460
on running the kernel in execute-only memory

00:00:29,460 --> 00:00:31,810
because it's been a pretty interesting project.

00:00:35,300 --> 00:00:37,190
So execute-only memory is of course memory

00:00:37,190 --> 00:00:40,210
that's not readable or writeable but is executable

00:00:40,210 --> 00:00:44,460
and it's useful for stopping the steps in attacks

00:00:44,460 --> 00:00:45,410
where the attacker needs

00:00:45,410 --> 00:00:47,283
to learn about the executable code.

00:00:48,270 --> 00:00:51,680
So it's a lesser known fact that some Intel CPUs

00:00:51,680 --> 00:00:53,530
actually support the ability to create

00:00:53,530 --> 00:00:58,300
execute-only memory on VMs, going back many generations.

00:00:58,300 --> 00:01:00,360
So today I'm gonna talk about, first of all,

00:01:00,360 --> 00:01:03,680
how this helps security-wise,

00:01:03,680 --> 00:01:08,680
then how to enable this for the kernel,

00:01:08,710 --> 00:01:12,290
and then lastly, ongoing work to make the feature

00:01:12,290 --> 00:01:14,010
safe to turn on and future rules

00:01:14,010 --> 00:01:15,690
that the kernel will have to follow

00:01:15,690 --> 00:01:16,550
in order to support

00:01:16,550 --> 00:01:18,583
running the Kernel in this mode.

00:01:18,583 --> 00:01:21,161
I have a fairly mature POC at this point but

00:01:21,161 --> 00:01:22,953
I haven't posted it to any lists to it's

00:01:22,953 --> 00:01:24,760
still a work-in-progress.

00:01:24,760 --> 00:01:27,918
I'm gonna have a link to some GitHub repos at the end

00:01:27,918 --> 00:01:31,223
if anyone wants to take a look at the current status.

00:01:33,490 --> 00:01:35,590
Okay, so, why use execute-only memory?

00:01:35,590 --> 00:01:38,150
The criteria is actually pretty simple.

00:01:38,150 --> 00:01:41,890
It's when your executable code or the location is secret.

00:01:41,890 --> 00:01:45,182
So if your executable code's known, public,

00:01:45,182 --> 00:01:49,220
and the location is known or can be found out easily,

00:01:49,220 --> 00:01:51,230
it really doesn't help you at all.

00:01:51,230 --> 00:01:53,020
So, if at the kernel, it's often the case

00:01:53,020 --> 00:01:55,480
that the executable code is known but

00:01:57,010 --> 00:01:59,910
for distro kernels and things like that but

00:01:59,910 --> 00:02:03,460
for unpublished cloud kernels, that can not be the case,

00:02:03,460 --> 00:02:06,160
so they might have patches or configs or compiler versions

00:02:06,160 --> 00:02:07,860
that the attacker wouldn't know about,

00:02:07,860 --> 00:02:10,310
so there's some code diversity there,

00:02:10,310 --> 00:02:12,160
but the main inspiration for this

00:02:12,160 --> 00:02:13,870
is the fine-grained KASLR

00:02:13,870 --> 00:02:16,620
that Kristen Accardi presented at this conference

00:02:16,620 --> 00:02:18,910
last year and for anyone that's unfamiliar,

00:02:18,910 --> 00:02:21,340
it's kind of like live patching on steroids

00:02:21,340 --> 00:02:24,170
where every function in the kernel is linked

00:02:24,170 --> 00:02:25,450
in a random order at boot time,

00:02:25,450 --> 00:02:28,270
so even if the boot image is known to an attacker,

00:02:28,270 --> 00:02:29,973
the kernel text wouldn't be.

00:02:31,270 --> 00:02:35,430
So, so far, just a short summary of where that's at,

00:02:35,430 --> 00:02:36,910
it's been booted with several

00:02:36,910 --> 00:02:39,420
of core subsystems randomized,

00:02:39,420 --> 00:02:41,040
but work is still going on it

00:02:41,040 --> 00:02:42,970
and if anyone wants to get an update,

00:02:42,970 --> 00:02:44,922
there's a link at the bottom where she has a Wiki

00:02:44,922 --> 00:02:47,450
where she maintains her status.

00:02:47,450 --> 00:02:49,550
And then lastly, up in userspace,

00:02:49,550 --> 00:02:52,150
the ASLR offsets are often considered secret

00:02:52,150 --> 00:02:54,803
and that's what Android uses execute-only memory for.

00:02:58,430 --> 00:03:00,540
So let's look at how this helps

00:03:00,540 --> 00:03:03,310
with some real world attacks.

00:03:03,310 --> 00:03:07,460
Probably most are familiar with this general format.

00:03:07,460 --> 00:03:10,300
The CVE listed here is use after free

00:03:10,300 --> 00:03:12,140
of a struck that has function pointers in it.

00:03:12,140 --> 00:03:14,460
So when that memory gets triggered

00:03:14,460 --> 00:03:16,540
by the attacker to be reused,

00:03:16,540 --> 00:03:21,290
then the attacker can control where those function pointers

00:03:21,290 --> 00:03:24,663
are pointing to in the old usage of the allocation.

00:03:25,710 --> 00:03:28,650
So, of course, in order for the attacker to use this,

00:03:28,650 --> 00:03:29,850
they need to know,

00:03:29,850 --> 00:03:30,683
if they want to use it

00:03:30,683 --> 00:03:31,650
for anything other than crashing the kernel,

00:03:31,650 --> 00:03:36,650
they need to know where to redirect control flow to.

00:03:40,550 --> 00:03:42,150
And then of course for ROP attacks,

00:03:42,150 --> 00:03:44,670
the attacker needs to know even more about the text

00:03:44,670 --> 00:03:46,720
because they need to know not just one location

00:03:46,720 --> 00:03:47,553
that's useful to them,

00:03:47,553 --> 00:03:49,800
but lots of little snippets all over the text

00:03:49,800 --> 00:03:53,010
that they can assemble using a fake stack

00:03:53,010 --> 00:03:56,670
that can execute as it's unwound.

00:03:56,670 --> 00:03:58,940
So this, of course, lets the attackers

00:03:58,940 --> 00:04:03,100
work around data execution protection technologies.

00:04:03,100 --> 00:04:06,490
So even if they can't have a way to

00:04:07,740 --> 00:04:10,950
write or create executable map code,

00:04:10,950 --> 00:04:13,740
they can just use the little gadgets

00:04:13,740 --> 00:04:15,060
scattered all over the text

00:04:15,060 --> 00:04:16,960
to create some new functionality

00:04:16,960 --> 00:04:20,643
and then sort of do something like executing arbitrary code.

00:04:23,250 --> 00:04:25,580
So now let's look at how this works

00:04:25,580 --> 00:04:27,913
in the case of a limited text leak.

00:04:28,813 --> 00:04:31,800
There's an attack called JIT-ROP,

00:04:31,800 --> 00:04:33,630
which was originally done for userspace

00:04:33,630 --> 00:04:35,380
against fine-grained randomization.

00:04:36,500 --> 00:04:38,780
And here we sort of mix that

00:04:38,780 --> 00:04:41,700
with some common kernel exploit steps

00:04:41,700 --> 00:04:44,840
to talk about how roughly this will work in the kernel.

00:04:44,840 --> 00:04:46,620
So the scenario is the attacker has some

00:04:46,620 --> 00:04:48,450
arbitrary call primitive

00:04:48,450 --> 00:04:51,230
and some leaks of some small code.

00:04:51,230 --> 00:04:53,520
So maybe a function pointer leaked

00:04:53,520 --> 00:04:55,740
or returned address off the stack or something like that,

00:04:55,740 --> 00:04:57,200
enough for them to get some idea

00:04:57,200 --> 00:04:59,483
of at least part of the text.

00:05:01,270 --> 00:05:03,050
So often this small region of text

00:05:03,050 --> 00:05:07,330
is not going to have enough gadgets to do a full ROP attack.

00:05:07,330 --> 00:05:09,870
But it's more likely that it may have some gadgets

00:05:09,870 --> 00:05:11,990
that can be used to form an arbitrary read primitive,

00:05:11,990 --> 00:05:14,120
in which case the attacker could just read

00:05:14,120 --> 00:05:16,970
the rest of the text and then know enough gadgets

00:05:16,970 --> 00:05:19,740
to do a second stage of the attack,

00:05:19,740 --> 00:05:22,333
which is often turning off the ability to call

00:05:22,333 --> 00:05:25,220
and turning on the ability to call back in userspace

00:05:25,220 --> 00:05:28,343
or SMEP as it's called on x86.

00:05:29,910 --> 00:05:32,040
So this is sort of the scenario that where

00:05:32,040 --> 00:05:34,030
execute-only memory helps.

00:05:34,030 --> 00:05:38,000
When the attacker has the ability to read the text,

00:05:38,000 --> 00:05:40,510
then they will be prevented from doing that.

00:05:40,510 --> 00:05:43,630
You can see that it's kind of a last line of defense.

00:05:43,630 --> 00:05:46,683
Ideally the attacker would be stopped earlier.

00:05:47,550 --> 00:05:50,330
So fuzzing and sanitizers would help prevent

00:05:50,330 --> 00:05:51,850
the use after free.

00:05:51,850 --> 00:05:55,940
And forward CFI would prevent the arbitrary call from being

00:05:55,940 --> 00:05:58,603
able to really call any place arbitrarily.

00:06:00,220 --> 00:06:01,730
But those are not completely foolproof

00:06:01,730 --> 00:06:05,890
so execute-only memory can sort of be a last line of defense

00:06:05,890 --> 00:06:06,740
where if they've already got

00:06:06,740 --> 00:06:07,670
those things that you don't want

00:06:07,670 --> 00:06:10,450
them to have then at least it can make 'em hard

00:06:10,450 --> 00:06:12,100
for them to use them.

00:06:12,100 --> 00:06:14,070
So the other factor here is

00:06:14,070 --> 00:06:17,060
being able to know the text with absolute confidence.

00:06:17,060 --> 00:06:20,060
If the attacker can only guess where things are,

00:06:20,060 --> 00:06:21,563
with some degree of certainty,

00:06:22,490 --> 00:06:23,620
it can help thwart attacks

00:06:23,620 --> 00:06:26,143
where an attacker has a foothold in a system.

00:06:27,030 --> 00:06:28,817
But they may be wary of crashing the kernel

00:06:28,817 --> 00:06:29,870
and being discovered,

00:06:29,870 --> 00:06:32,430
so if there's some attack they can do

00:06:32,430 --> 00:06:35,180
that has a not 100% chance of success,

00:06:35,180 --> 00:06:38,040
they could be forced to look for other attacks.

00:06:38,040 --> 00:06:41,040
Which leads to the next point,

00:06:41,040 --> 00:06:44,140
which is what other ways there are to discover text.

00:06:44,140 --> 00:06:48,390
So with KSLR, usually only a single text address leak

00:06:48,390 --> 00:06:52,238
is enough to de-randomize the whole kernel text.

00:06:52,238 --> 00:06:55,340
And of course execute-only memory can't stop data leaks.

00:06:55,340 --> 00:06:57,733
It's about stopping reading the text.

00:07:00,434 --> 00:07:02,510
And of course attacks are always advancing

00:07:02,510 --> 00:07:05,830
and there's been work on using cache side channels

00:07:05,830 --> 00:07:07,487
for de-randomizing text.

00:07:07,487 --> 00:07:11,320
And then lastly, the most straightforward deterministic way

00:07:11,320 --> 00:07:14,520
of reading text is using some sort of read exploit

00:07:14,520 --> 00:07:16,070
to read out the text.

00:07:16,070 --> 00:07:18,510
And this is the type of leak that execute-only memory

00:07:18,510 --> 00:07:19,343
helps with.

00:07:19,343 --> 00:07:21,890
So the point of this is that execute-only memory

00:07:21,890 --> 00:07:22,770
is not a lock box.

00:07:22,770 --> 00:07:24,730
You can't put code in there and assume the attacker

00:07:24,730 --> 00:07:26,570
will never learn anything about it.

00:07:26,570 --> 00:07:29,410
What it is, is it's another hardening feature

00:07:29,410 --> 00:07:32,623
that can lock some techniques used by attackers.

00:07:34,620 --> 00:07:36,370
So, with those limitations called out

00:07:36,370 --> 00:07:38,570
I want to explain why I'm actually still pretty excited

00:07:38,570 --> 00:07:39,603
about this feature.

00:07:40,680 --> 00:07:42,460
Security is an increasing concern

00:07:42,460 --> 00:07:44,750
and there's lots of proposals with different combinations

00:07:44,750 --> 00:07:48,460
of effectiveness, performance, and complexity.

00:07:48,460 --> 00:07:50,660
Ideally we want something like the green circle,

00:07:50,660 --> 00:07:53,680
where it's very effective, it has low complexity

00:07:53,680 --> 00:07:55,850
and low performance impact.

00:07:55,850 --> 00:07:57,510
That's a win.

00:07:57,510 --> 00:08:00,457
And if there's something on the opposite side

00:08:00,457 --> 00:08:02,210
with low effectiveness, high complexity,

00:08:02,210 --> 00:08:03,320
and high performance impact,

00:08:03,320 --> 00:08:04,640
then maybe it's not worth the trade off.

00:08:04,640 --> 00:08:08,110
And usually the mitigations are somewhere in between.

00:08:08,110 --> 00:08:09,940
So the cool thing about execute-only memory,

00:08:09,940 --> 00:08:11,690
it's not that it can stop all attacks,

00:08:11,690 --> 00:08:13,040
it's not like a big hammer,

00:08:16,270 --> 00:08:19,060
but it's targeting the older but still valid class

00:08:19,060 --> 00:08:21,580
of executable code focused attacks.

00:08:21,580 --> 00:08:23,380
But the unusual thing is that it doesn't,

00:08:23,380 --> 00:08:25,440
at least as I've been able to measure so far,

00:08:25,440 --> 00:08:27,040
bring much of a performance hit.

00:08:31,370 --> 00:08:34,030
Okay, so now I'm going to get into how this works,

00:08:34,030 --> 00:08:37,550
which is the part that is maybe especially interesting.

00:08:37,550 --> 00:08:39,940
Some people may be aware the x86 page tables

00:08:39,940 --> 00:08:42,070
don't have a way to set kernel memory

00:08:42,070 --> 00:08:43,990
as executable but not readable.

00:08:43,990 --> 00:08:45,610
So first I'm going to explain

00:08:45,610 --> 00:08:47,650
how to enable hardware support.

00:08:47,650 --> 00:08:52,650
And then after that to enable how to enable the kernel

00:08:52,790 --> 00:08:53,790
to run in this mode.

00:08:56,290 --> 00:08:59,230
So some CPUs today support execute-only memory.

00:08:59,230 --> 00:09:01,720
Recently until CPUs with protection keys,

00:09:01,720 --> 00:09:05,660
you can set user space memory to execute-only.

00:09:05,660 --> 00:09:08,620
Some ARM CPUs have this as well.

00:09:08,620 --> 00:09:11,410
And a piece of trivia I found when I was researching this,

00:09:11,410 --> 00:09:14,100
is that the 286 had the ability to create

00:09:14,100 --> 00:09:16,810
execute-only memory segments.

00:09:16,810 --> 00:09:19,160
Presumably they weren't concerned about JIT-ROP

00:09:20,380 --> 00:09:22,469
when they designed that

00:09:22,469 --> 00:09:23,870
but it is supported, so...

00:09:23,870 --> 00:09:26,240
But anyway, the place where this is relevant

00:09:26,240 --> 00:09:27,230
to what I'm going to talk about today

00:09:27,230 --> 00:09:29,500
is in extended page tables.

00:09:29,500 --> 00:09:31,330
So in case anyone's unfamiliar,

00:09:31,330 --> 00:09:33,610
hypervisors virtualize physical memory,

00:09:33,610 --> 00:09:36,500
so when there's a TLB miss in the guest,

00:09:36,500 --> 00:09:38,390
first the guest physical address is looked up

00:09:38,390 --> 00:09:40,280
from the normal page tables

00:09:40,280 --> 00:09:41,610
and then the host physical address

00:09:41,610 --> 00:09:43,790
is looked up from the extended page tables.

00:09:43,790 --> 00:09:45,740
And extended page tables is the Intel name

00:09:45,740 --> 00:09:46,903
for this technology.

00:09:47,970 --> 00:09:49,700
Sometimes it's called second level page tables

00:09:49,700 --> 00:09:51,610
or two-dimensional page tables.

00:09:51,610 --> 00:09:53,190
But in the Intel version,

00:09:53,190 --> 00:09:56,010
you can see in the permission bits here,

00:09:56,010 --> 00:09:58,110
I don't know if you guys can see on the (murmurs) here.

00:09:58,110 --> 00:10:03,110
So you can see there's a read bit that can be zeroed.

00:10:04,560 --> 00:10:05,880
This is on some CPUs.

00:10:05,880 --> 00:10:07,700
So not everything that supports EPT

00:10:07,700 --> 00:10:10,300
has execute-only memory support.

00:10:10,300 --> 00:10:14,480
But on, at least I found CPUs going back quite a while

00:10:14,480 --> 00:10:16,390
that do support it.

00:10:16,390 --> 00:10:19,220
So one way I looked at doing this

00:10:19,220 --> 00:10:20,870
was just to add a hypercall that could allow

00:10:20,870 --> 00:10:24,470
the guest to restrict physical memory,

00:10:24,470 --> 00:10:27,270
sort of downgrade memory permissions to be execute-only.

00:10:28,230 --> 00:10:29,590
And then the kernel could just

00:10:29,590 --> 00:10:32,230
call this hypercall on its text.

00:10:32,230 --> 00:10:34,720
So the problem with this is that

00:10:34,720 --> 00:10:36,890
the kernel is not used to managing fine-grained

00:10:36,890 --> 00:10:37,860
physical memory permissions.

00:10:37,860 --> 00:10:39,640
It's used to managing virtual memory permissions.

00:10:39,640 --> 00:10:41,950
And in a lot of cases it relies on

00:10:41,950 --> 00:10:44,270
being able to map the same physical memory

00:10:44,270 --> 00:10:46,260
twice with different permissions.

00:10:46,260 --> 00:10:47,520
A couple examples would be text patching

00:10:47,520 --> 00:10:50,513
where there's a read-only mapping and a read-write mapping.

00:10:51,440 --> 00:10:53,520
And then also when you talk about userspace

00:10:53,520 --> 00:10:54,630
it gets even more complicated

00:10:54,630 --> 00:10:57,550
'cause you could have multiple processes

00:10:57,550 --> 00:11:01,010
mapping the same physical memory with different permissions.

00:11:01,010 --> 00:11:03,090
Or there's also the direct mapping

00:11:03,090 --> 00:11:05,070
and also the userspace mapping in the same memory

00:11:05,070 --> 00:11:06,410
with different permissions.

00:11:06,410 --> 00:11:09,280
So it really just starts to become really complicated

00:11:09,280 --> 00:11:10,970
and in terms of the userspace support,

00:11:10,970 --> 00:11:13,455
I'm not even sure if it's possible to support

00:11:13,455 --> 00:11:15,460
the way that APIs are designed

00:11:15,460 --> 00:11:18,233
using just physical memory permissions.

00:11:19,306 --> 00:11:21,790
And the other reason is that some texts in the kernel

00:11:21,790 --> 00:11:24,390
is 4K pages like modules,

00:11:24,390 --> 00:11:29,390
so in order to go mark those pages as execute-only

00:11:29,460 --> 00:11:33,670
without marking random other adjacent physical memories

00:11:33,670 --> 00:11:34,533
execute-only,

00:11:35,430 --> 00:11:37,460
we need to break the large pages in the EPT

00:11:37,460 --> 00:11:39,520
which of course makes the EPT walks take longer

00:11:39,520 --> 00:11:41,180
and could impact performance.

00:11:41,180 --> 00:11:43,340
So that sort of was, I actually built this out

00:11:43,340 --> 00:11:46,500
to see how it would look and it looked

00:11:46,500 --> 00:11:47,850
pretty awkwardly wedged in there

00:11:47,850 --> 00:11:50,910
and then it also doesn't support userspace very well, so...

00:11:52,620 --> 00:11:54,780
So now a little bit of history.

00:11:54,780 --> 00:11:57,450
In the past, all memory was executable

00:11:57,450 --> 00:12:01,130
and attackers could just jump to data that they wrote.

00:12:01,130 --> 00:12:02,660
And then there was various

00:12:02,660 --> 00:12:06,150
data execution prevention bits added

00:12:06,150 --> 00:12:08,800
like the NX bit and the amd64.

00:12:08,800 --> 00:12:11,180
And you can see here, most of the permission bits

00:12:11,180 --> 00:12:14,890
are down here and then the NX bit is at the end

00:12:14,890 --> 00:12:16,720
next to the reserve region.

00:12:16,720 --> 00:12:19,160
So the ideal, what would fit best

00:12:19,160 --> 00:12:20,740
with how the kernel manages memory

00:12:20,740 --> 00:12:24,440
is just to have an execute-only memory bit

00:12:24,440 --> 00:12:27,000
in the guest page tables that it can set

00:12:27,000 --> 00:12:28,860
virtual memory to whatever permission it wants.

00:12:28,860 --> 00:12:32,790
And we have a physical address permission bit,

00:12:32,790 --> 00:12:34,590
not a virtual memory permission bit.

00:12:35,430 --> 00:12:37,490
So what we can do is that,

00:12:37,490 --> 00:12:40,210
usually physical memory's mapped once,

00:12:40,210 --> 00:12:42,220
as it would be for in the EPTs,

00:12:42,220 --> 00:12:44,090
it would be for real physical memory.

00:12:44,090 --> 00:12:48,030
But aliasing is supported so we can map it twice.

00:12:48,030 --> 00:12:51,560
And if we map the first region of memory

00:12:51,560 --> 00:12:55,260
as read-write execute permissions or whatever is needed

00:12:55,260 --> 00:12:57,690
by the hypervisor, sometimes it wants that to be read-only,

00:12:57,690 --> 00:12:58,920
or things like that.

00:12:58,920 --> 00:13:00,940
And then the second region of memory

00:13:00,940 --> 00:13:03,630
is the same physical memory

00:13:03,630 --> 00:13:05,730
mapped with execute-only permissions.

00:13:05,730 --> 00:13:08,580
That makes the top physical address bit

00:13:08,580 --> 00:13:11,170
now kind of be like an exo-permission bit.

00:13:11,170 --> 00:13:12,357
So when we toggle it

00:13:12,357 --> 00:13:15,910
and the PFN would be in the virtual page tables,

00:13:15,910 --> 00:13:17,440
we have a bit in the page tables now

00:13:17,440 --> 00:13:20,143
that acts like an exo-permission bit.

00:13:22,090 --> 00:13:24,180
So at this point we have kind of a neat hack,

00:13:24,180 --> 00:13:25,880
but we can actually take it one step further

00:13:25,880 --> 00:13:28,650
and make this bit backwards compatible

00:13:28,650 --> 00:13:33,650
with how the SGM says that x86 CPUs are supposed to behave.

00:13:34,340 --> 00:13:36,483
SGM being the Intel software manual.

00:13:37,870 --> 00:13:40,800
So there's a CPUID leaf that provides the number of

00:13:40,800 --> 00:13:43,810
physical address bits supported by CPU.

00:13:43,810 --> 00:13:47,030
And the number of, the top physical address bit

00:13:47,030 --> 00:13:51,330
to bit 51 in the page table is defined as a reserved area.

00:13:51,330 --> 00:13:55,290
And if a bit is set there the CPU will often throw

00:13:55,290 --> 00:13:58,620
a page fault with the reserve error code bits set.

00:13:58,620 --> 00:14:01,570
But the SGM says that this can't be relied on,

00:14:01,570 --> 00:14:03,540
that is my happen but in the future

00:14:03,540 --> 00:14:05,800
these bits may be used for other things.

00:14:05,800 --> 00:14:08,050
So it follows all the rules for these bits

00:14:08,050 --> 00:14:08,883
to mean something else.

00:14:08,883 --> 00:14:10,290
So what we do is when,

00:14:10,290 --> 00:14:13,530
this CPUID leaf here is what tells

00:14:13,530 --> 00:14:16,060
the physical address bits and it's usually virtualized

00:14:16,060 --> 00:14:17,460
by hypervisors,

00:14:17,460 --> 00:14:21,240
so when the guest queries this leaf,

00:14:21,240 --> 00:14:23,550
we just tell the guest that it actually has one less,

00:14:23,550 --> 00:14:25,350
the CPU has one less physical address bit

00:14:25,350 --> 00:14:26,870
than it actually has,

00:14:26,870 --> 00:14:29,360
which changes the meaning of that bit

00:14:29,360 --> 00:14:34,360
to be not the last physical address bit,

00:14:34,470 --> 00:14:36,140
but the first reserve bit.

00:14:36,140 --> 00:14:38,530
And so now we've moved this bit out of

00:14:38,530 --> 00:14:41,740
the physical address bit range into the reserve range

00:14:41,740 --> 00:14:44,990
and we've sort of in software created a new

00:14:47,520 --> 00:14:49,520
page table permission bit.

00:14:49,520 --> 00:14:51,990
So now it's just another,

00:14:51,990 --> 00:14:53,860
this is just like if,

00:14:53,860 --> 00:14:56,590
if a new CPU came out with a new permission bit

00:14:56,590 --> 00:14:58,330
and it's easy for the kernel to digest

00:14:58,330 --> 00:15:01,960
because it's used to handling things like that.

00:15:01,960 --> 00:15:04,560
So it's just like another CPU feature at this point.

00:15:07,180 --> 00:15:10,630
So I'm not going to have time to get into the VMM changes,

00:15:10,630 --> 00:15:13,400
but the short story is that this actually

00:15:13,400 --> 00:15:15,830
fit pretty well with how Qemu and KVM

00:15:15,830 --> 00:15:17,690
define their interfaces.

00:15:17,690 --> 00:15:19,040
So there wasn't a lot of changes needed

00:15:19,040 --> 00:15:20,600
to implement this.

00:15:20,600 --> 00:15:22,820
I hope that this is the same for other hypervisors,

00:15:22,820 --> 00:15:25,860
because I wouldn't want this to just be a Qemu/KVM feature,

00:15:25,860 --> 00:15:27,960
but I haven't looked at any of them, so

00:15:27,960 --> 00:15:29,160
hopefully it's the same.

00:15:31,240 --> 00:15:34,180
Okay, so before we get into using this for the kernel,

00:15:34,180 --> 00:15:35,810
I just want to digress a bit to talk about

00:15:35,810 --> 00:15:38,410
how this trick could be used for userspace.

00:15:38,410 --> 00:15:42,520
So today, like I said, if a CPU has protection keys,

00:15:42,520 --> 00:15:46,060
and you unprotect with PROT_EXEC but not PROT_READ

00:15:47,610 --> 00:15:49,590
and some other flag dependencies

00:15:49,590 --> 00:15:51,750
then you can get execute-only memory today.

00:15:51,750 --> 00:15:52,847
So the kernel is giving this to you.

00:15:52,847 --> 00:15:54,450
You don't need to use any protection keys,

00:15:54,450 --> 00:15:56,200
instructions, or anything like that.

00:15:56,200 --> 00:15:58,150
Just sort of happens transparently.

00:15:58,150 --> 00:16:00,810
And the same is on some ARM platforms,

00:16:00,810 --> 00:16:05,810
but the lack of hardware out there can lower the ROI

00:16:05,870 --> 00:16:07,560
for developers to try to take advantage

00:16:07,560 --> 00:16:09,260
of execute-only memory.

00:16:09,260 --> 00:16:11,887
So the nice thing about this EPT exo-feature

00:16:11,887 --> 00:16:13,750
is that it's been around for a lot longer

00:16:13,750 --> 00:16:15,400
and since most of the cloud's VMs

00:16:16,237 --> 00:16:18,750
we could probably turn this on for a ton of kernels

00:16:18,750 --> 00:16:22,210
for userspace without the stuff I'm about to talk about

00:16:22,210 --> 00:16:23,313
relatively easily.

00:16:24,160 --> 00:16:26,860
So that can make it more, the exo for user space

00:16:26,860 --> 00:16:28,140
more of an expected feature,

00:16:28,140 --> 00:16:30,930
and then maybe help everyone by making

00:16:30,930 --> 00:16:32,380
more apps using this so more hardware

00:16:32,380 --> 00:16:33,680
can be taken advantage of.

00:16:35,400 --> 00:16:37,130
And like I mentioned, Android uses this today

00:16:37,130 --> 00:16:39,260
so it is getting some usage,

00:16:39,260 --> 00:16:41,120
but maybe if we could make it more prevalent

00:16:41,120 --> 00:16:43,003
we could make it more of a thing.

00:16:45,220 --> 00:16:47,090
So back to the kernel.

00:16:47,090 --> 00:16:49,460
There's a ton of little tweaks all over the place

00:16:49,460 --> 00:16:53,460
needed to turn this on, like detecting it at boot,

00:16:53,460 --> 00:16:55,780
adjusting the PFN mask,

00:16:55,780 --> 00:16:57,870
adding information to dump page tables

00:16:57,870 --> 00:16:58,890
and little things like that,

00:16:58,890 --> 00:17:00,960
but the core of getting it turned on

00:17:00,960 --> 00:17:03,640
is as simple as adding a new permission bit,

00:17:03,640 --> 00:17:05,150
a page-type permission bit

00:17:05,150 --> 00:17:07,040
and then adding some set memory helpers

00:17:07,040 --> 00:17:09,500
because there's not any for setting exo-memory.

00:17:09,500 --> 00:17:11,343
I chose set memory, readable and not readable

00:17:11,343 --> 00:17:13,743
because I thought it was more generic.

00:17:15,410 --> 00:17:18,940
And like an x86, like the read-on memory,

00:17:18,940 --> 00:17:21,240
this is going to propagate automatically to direct map

00:17:21,240 --> 00:17:23,200
the not-readable permission.

00:17:23,200 --> 00:17:26,570
And so then we just set it on kernel and module text.

00:17:26,570 --> 00:17:31,110
As far as when this is set, it's whenever the kernel

00:17:31,110 --> 00:17:32,190
text would be read-only.

00:17:32,190 --> 00:17:34,690
So if the text is read-write and being loaded

00:17:34,690 --> 00:17:36,290
we don't set it as execute-only.

00:17:37,910 --> 00:17:42,910
And then for patching, at a really high level,

00:17:43,970 --> 00:17:45,720
this sort of seems to happen in two ways,

00:17:45,720 --> 00:17:48,370
either an existing mapping that was read-only

00:17:48,370 --> 00:17:49,990
is set to read-write temporarily

00:17:49,990 --> 00:17:52,280
and the patching happens on the existing mapping

00:17:52,280 --> 00:17:55,760
or a completely new mapping's created that's read-write

00:17:55,760 --> 00:17:58,337
and the patching happens through that mapping

00:17:58,337 --> 00:18:00,550
and the original mapping's left alone.

00:18:00,550 --> 00:18:04,070
So in either case, whenever the mapping is read-write,

00:18:04,070 --> 00:18:05,453
it's not set execute-only.

00:18:08,428 --> 00:18:11,810
So now we just change the rules underneath the kernel,

00:18:11,810 --> 00:18:13,380
as they've been since the beginning of time

00:18:13,380 --> 00:18:15,560
and sort of set it on the kernel text

00:18:15,560 --> 00:18:17,420
and turned it on to see what would happen

00:18:17,420 --> 00:18:19,523
and what broke was actually,

00:18:20,580 --> 00:18:22,860
it mostly just works, surprisingly.

00:18:22,860 --> 00:18:25,580
The main breakage was with text patching features.

00:18:25,580 --> 00:18:27,240
The writeable mappings get the correct permissions,

00:18:27,240 --> 00:18:28,150
like I just talked about,

00:18:28,150 --> 00:18:31,120
but a lot of the patching needs to decode instructions

00:18:31,120 --> 00:18:32,170
and things like that.

00:18:34,898 --> 00:18:36,530
And then some of them also need to verify that the

00:18:36,530 --> 00:18:38,773
patching was correct with the bug on checks.

00:18:39,867 --> 00:18:42,330
So those reads of the kernel text broke

00:18:42,330 --> 00:18:44,060
and I'll talk a little bit about how we fixed that

00:18:44,060 --> 00:18:45,430
'cause like I said, we don't want to lose

00:18:45,430 --> 00:18:47,150
the text batching features.

00:18:47,150 --> 00:18:49,350
One interesting thing that came up was that the kernel's

00:18:49,350 --> 00:18:52,560
read-only data is actually immediately appended

00:18:52,560 --> 00:18:54,470
to the executable data,

00:18:54,470 --> 00:18:57,693
and so the last page of the executable data,

00:18:58,950 --> 00:19:00,180
or the first page of the read-only data

00:19:00,180 --> 00:19:01,780
is set executable.

00:19:01,780 --> 00:19:05,060
So then when you set all the kernel text as execute-only

00:19:05,060 --> 00:19:06,940
it means the first part of the read-only data

00:19:06,940 --> 00:19:10,430
is not readable, which is obviously a problem.

00:19:10,430 --> 00:19:12,160
So the solution there is just to page-line

00:19:12,160 --> 00:19:14,910
the read-only data when you're doing execute-only text.

00:19:16,450 --> 00:19:18,140
And then hibernate breaks, since it expects

00:19:18,140 --> 00:19:19,560
to be able to read pages in the direct map,

00:19:19,560 --> 00:19:21,260
which are now not readable.

00:19:21,260 --> 00:19:22,790
It already checks that the page is present

00:19:22,790 --> 00:19:23,950
and assumes that means it's readable,

00:19:23,950 --> 00:19:25,550
so this is easy to fix.

00:19:25,550 --> 00:19:28,690
We just got to check the not readable permission as well.

00:19:28,690 --> 00:19:30,370
But since this is targeting VMs,

00:19:30,370 --> 00:19:32,700
in the current patches I have, I've just sort of disabled it

00:19:32,700 --> 00:19:34,900
when you're doing execute-only.

00:19:34,900 --> 00:19:36,860
I think this will probably be fixed,

00:19:36,860 --> 00:19:39,910
but the current status is that it's just disabled.

00:19:39,910 --> 00:19:43,540
The part of the oops message that prints the place

00:19:43,540 --> 00:19:45,300
where the fault happened,

00:19:45,300 --> 00:19:49,070
this fail was gracefully with probe kernel read failure,

00:19:49,070 --> 00:19:50,840
but the rest of the message including the stack trace

00:19:50,840 --> 00:19:51,833
works just fine.

00:19:52,730 --> 00:19:56,420
And then lastly, data embedded by the tool chain,

00:19:56,420 --> 00:19:58,670
which jump tables and literal pools

00:19:58,670 --> 00:20:00,233
and those kind of compiler operations,

00:20:01,560 --> 00:20:03,730
which was my biggest concern getting into this,

00:20:03,730 --> 00:20:05,870
it actually turned out to not be a problem

00:20:05,870 --> 00:20:08,423
and I'll get into a bit why that was the case.

00:20:10,270 --> 00:20:12,500
So the text patching features,

00:20:12,500 --> 00:20:15,150
like I said, they read the read-only mapping

00:20:15,150 --> 00:20:17,350
to decode instructions and things like that.

00:20:19,108 --> 00:20:20,610
So there are sort of two solutions to this.

00:20:20,610 --> 00:20:23,160
One was just to set the text in place readable

00:20:23,160 --> 00:20:24,820
whenever this is happening.

00:20:24,820 --> 00:20:26,090
And the other would be to do something like

00:20:26,090 --> 00:20:27,820
a text_poke for reads.

00:20:27,820 --> 00:20:30,460
Recently text_poke on x86 got changed to be

00:20:30,460 --> 00:20:31,520
a single CPU mapping,

00:20:31,520 --> 00:20:35,370
which means that no one else, no other CPUs

00:20:35,370 --> 00:20:37,290
can go in and use that write-only mapping

00:20:37,290 --> 00:20:38,260
while it's being written to.

00:20:38,260 --> 00:20:40,280
So if there's any write bugs or something like that

00:20:40,280 --> 00:20:44,230
they can't be used to go write to this mapping,

00:20:44,230 --> 00:20:46,210
and overwrite the kernel text.

00:20:46,210 --> 00:20:48,220
So we want to have something like that for reads

00:20:48,220 --> 00:20:51,610
where you would be able to go read the kernel text

00:20:51,610 --> 00:20:55,290
without allowing any other CPUs to read it.

00:20:55,290 --> 00:20:57,080
So for now, the simple solution,

00:20:57,080 --> 00:20:58,020
I went with the simple solution,

00:20:58,020 --> 00:21:00,583
which is just to mark the text in-place readable.

00:21:01,420 --> 00:21:02,860
But there's two things to point out about this,

00:21:02,860 --> 00:21:05,760
is that none of the cases where this was needed to be done,

00:21:05,760 --> 00:21:09,160
were triggerable from just an unprivileged user,

00:21:09,160 --> 00:21:11,260
'cause if the unprivileged user can trigger the text

00:21:11,260 --> 00:21:13,680
being set readable, it really reduces the benefit of this,

00:21:13,680 --> 00:21:15,000
since the attacker will just turn it off

00:21:15,000 --> 00:21:17,282
when they don't want it to be there.

00:21:17,282 --> 00:21:19,050
And then jump labels, which are triggerable

00:21:19,050 --> 00:21:20,710
by an unprivileged user,

00:21:20,710 --> 00:21:22,740
reading text was not strictly required in that case.

00:21:22,740 --> 00:21:24,720
So I sort of got away for now

00:21:24,720 --> 00:21:27,661
with not creating this text_poke for reads,

00:21:27,661 --> 00:21:28,770
but if there are any cases I missed

00:21:28,770 --> 00:21:31,250
or if there's any ones that are planned,

00:21:31,250 --> 00:21:33,430
then I'd have to go back and make something like

00:21:33,430 --> 00:21:36,563
the text_poke for reads in order to make this work.

00:21:37,720 --> 00:21:39,570
So for now we've gone with the easy solution

00:21:39,570 --> 00:21:42,560
but there's a plan in case something comes up.

00:21:42,560 --> 00:21:44,710
Okay, so, I found this part really interesting.

00:21:44,710 --> 00:21:46,940
It turns out the Gcc is not embedded data

00:21:46,940 --> 00:21:50,470
in executable code for a long time, or at least on x86.

00:21:50,470 --> 00:21:52,320
And I guess there's two reasons for this.

00:21:52,320 --> 00:21:55,120
One is just some sort of lease privilege reasoning,

00:21:55,120 --> 00:21:58,510
that sometimes gadgets are rare the attacker might need

00:21:58,510 --> 00:22:01,023
for a particular attack like stack pivots.

00:22:03,165 --> 00:22:06,320
And we don't mark any more data as executable than we need

00:22:06,320 --> 00:22:09,050
because there might be useful gadgets in there.

00:22:09,050 --> 00:22:11,330
But the other reason was that it was thought,

00:22:11,330 --> 00:22:12,420
at least there's a school of thought that

00:22:12,420 --> 00:22:14,010
it's better for performance,

00:22:14,010 --> 00:22:16,300
because there's separate caches for data and instructions,

00:22:16,300 --> 00:22:18,300
in some cases like the TLB,

00:22:18,300 --> 00:22:21,257
like if you have an iTLB and a dTLB,

00:22:21,257 --> 00:22:23,990
and you have data and executable code in the same page,

00:22:23,990 --> 00:22:26,540
then you get two entries where you really only needed one

00:22:26,540 --> 00:22:28,830
and it increases TLB pressure.

00:22:28,830 --> 00:22:30,410
The L1 cache is also split

00:22:30,410 --> 00:22:32,480
and so there's some similar complications there

00:22:32,480 --> 00:22:35,450
but in any case the Gcc people I talked to said

00:22:35,450 --> 00:22:39,310
that the compiler on x86, the compiler embedding data

00:22:39,310 --> 00:22:42,290
in executable code should be considered a bug.

00:22:42,290 --> 00:22:45,380
So this was really fortunate that this,

00:22:45,380 --> 00:22:46,770
for other random reasons,

00:22:46,770 --> 00:22:49,460
was just like it was needed for execute-only.

00:22:49,460 --> 00:22:52,140
And that's why, when I turned this on it just booted.

00:22:52,140 --> 00:22:53,270
I kind of didn't believe it at first.

00:22:53,270 --> 00:22:54,880
I thought I must've made a mistake,

00:22:54,880 --> 00:22:58,923
but it just sort of works, so that was really lucky.

00:23:01,000 --> 00:23:02,550
Okay, so performance.

00:23:02,550 --> 00:23:04,170
The core of this is a hardware permission bit,

00:23:04,170 --> 00:23:06,210
so I wasn't expecting a big hit,

00:23:06,210 --> 00:23:10,370
but potential areas that could still cause an issue are

00:23:10,370 --> 00:23:13,160
extra cache pressure from the mid-level EPT page tables

00:23:13,160 --> 00:23:15,510
since we're duplicating the physical addresses,

00:23:16,700 --> 00:23:18,570
extra mid-level translation cache pressure

00:23:18,570 --> 00:23:19,970
for a similar reason,

00:23:19,970 --> 00:23:21,660
and then also some extra memory usage

00:23:21,660 --> 00:23:23,820
for the extra EPT pages.

00:23:23,820 --> 00:23:24,730
Now these are faulted in,

00:23:24,730 --> 00:23:27,340
so they're not created until they're needed, but...

00:23:28,480 --> 00:23:32,495
So in testing so far, I haven't observed a slowdown.

00:23:32,495 --> 00:23:35,110
You can see in this benchmark execute-only

00:23:35,110 --> 00:23:37,090
actually came out a little bit faster.

00:23:37,090 --> 00:23:38,450
I don't think that's the case.

00:23:38,450 --> 00:23:39,903
I think this is just noise.

00:23:40,980 --> 00:23:43,187
So I was sort of expecting to see some slowdown here,

00:23:43,187 --> 00:23:44,660
so I'm going to keep looking for it,

00:23:44,660 --> 00:23:46,360
but so far I haven't observed any.

00:23:51,210 --> 00:23:54,920
Okay, so we just created a magical new security rule

00:23:54,920 --> 00:23:58,130
and our analysis is that it should work fine,

00:23:58,130 --> 00:24:00,480
but we don't want to rest on that.

00:24:00,480 --> 00:24:03,060
A couple things to still worry about are

00:24:03,060 --> 00:24:05,160
assembly that embeds data in text,

00:24:05,160 --> 00:24:06,620
'cause like I said the compiler won't do this,

00:24:06,620 --> 00:24:09,170
but in assembly you could still do it.

00:24:09,170 --> 00:24:11,850
C code that reads text for unknown reasons.

00:24:11,850 --> 00:24:14,150
And then maybe even some lurking bugs

00:24:14,150 --> 00:24:17,160
that read text on accident, currently with no consequence,

00:24:17,160 --> 00:24:18,630
and so we don't want to turn those

00:24:18,630 --> 00:24:21,440
inconsequential bugs into crashes.

00:24:21,440 --> 00:24:23,850
Some static analysis was done on the kernel text

00:24:23,850 --> 00:24:26,650
to see if there are any places that at least the kernel

00:24:26,650 --> 00:24:29,060
statically read itself and none were found.

00:24:29,060 --> 00:24:31,550
But they still can't rule out that this might be happening

00:24:31,550 --> 00:24:32,690
in some way.

00:24:32,690 --> 00:24:36,010
So the idea is to provide two enforcement options.

00:24:36,010 --> 00:24:38,100
One, where the kernel oopses like it does

00:24:38,100 --> 00:24:40,710
for any other memory permission violation,

00:24:40,710 --> 00:24:42,780
and another where it just fixes the permission,

00:24:42,780 --> 00:24:46,500
the readable bit, or the exo-permissions,

00:24:46,500 --> 00:24:49,760
it logs where it happened, with a stack trace and a warning,

00:24:49,760 --> 00:24:51,980
saying, "Exploit attempt detected,"

00:24:51,980 --> 00:24:54,530
like it does for an xbit violations.

00:24:54,530 --> 00:24:56,810
And then it just continues executing.

00:24:56,810 --> 00:24:59,180
So in this case the risk of turning this on

00:24:59,180 --> 00:25:01,020
is just extra log noise

00:25:01,020 --> 00:25:03,960
and it gives us a way to flush out any issues

00:25:03,960 --> 00:25:08,200
where this might have run across cases that I missed.

00:25:08,200 --> 00:25:10,860
And then slowly the idea is that non-strict mode

00:25:10,860 --> 00:25:12,600
could be a temporary thing

00:25:12,600 --> 00:25:14,753
and this would move toward strict mode.

00:25:17,238 --> 00:25:21,277
So before I talk about how that can work,

00:25:21,277 --> 00:25:24,770
I have to talk about what happens when there's XO violation.

00:25:24,770 --> 00:25:28,160
These XO faults are triggered actually by the hardware's

00:25:28,160 --> 00:25:29,399
EPT violations because they're

00:25:29,399 --> 00:25:32,390
physical memory permission violations.

00:25:32,390 --> 00:25:35,790
And what I have is KVM will see that it's an exo-permission

00:25:35,790 --> 00:25:37,212
violation and inject a fault

00:25:37,212 --> 00:25:40,010
into the guest that it can handle.

00:25:40,010 --> 00:25:43,230
Now, at least on Intel CPUs the existing exo-faults

00:25:43,230 --> 00:25:44,700
are from protection keys,

00:25:44,700 --> 00:25:46,180
which have their own error code.

00:25:46,180 --> 00:25:47,730
These are the error codes here.

00:25:49,320 --> 00:25:52,210
But the existing bits, so that error code doesn't really

00:25:52,210 --> 00:25:53,460
correspond to what we're doing here

00:25:53,460 --> 00:25:55,160
with this made up permission bit,

00:25:55,160 --> 00:25:58,530
so the existing bits though, at least semantically,

00:25:58,530 --> 00:26:00,010
have a way to describe

00:26:00,010 --> 00:26:02,790
what sounds like an exo-permission violation.

00:26:02,790 --> 00:26:05,190
The key bits being the pages present.

00:26:05,190 --> 00:26:08,849
It was a read violation but it was not an instruction fetch.

00:26:08,849 --> 00:26:11,110
So that's what I'm doing right now,

00:26:11,110 --> 00:26:12,830
is when there is an EPT violation,

00:26:12,830 --> 00:26:14,483
I inject a fault like that.

00:26:16,180 --> 00:26:17,670
But there's actually another option,

00:26:17,670 --> 00:26:19,600
which is this thing called VE,

00:26:19,600 --> 00:26:21,770
which stands for virtualization exception.

00:26:21,770 --> 00:26:23,960
So with VE, this is an Intel feature

00:26:23,960 --> 00:26:26,110
that's not implemented in the kernel today,

00:26:27,260 --> 00:26:29,550
there's a completely separate interrupt vector

00:26:29,550 --> 00:26:32,220
that can be configured to receive EPT violations

00:26:32,220 --> 00:26:33,700
directly to the guest.

00:26:33,700 --> 00:26:35,360
And it was imagined for usages like this

00:26:35,360 --> 00:26:38,000
where there's some way for the guest to fix its own

00:26:38,000 --> 00:26:39,720
EPT violations.

00:26:39,720 --> 00:26:41,250
The downside of using this,

00:26:41,250 --> 00:26:43,360
so it seems like it should be a really great fit,

00:26:43,360 --> 00:26:45,160
but the downside is that there's CPU that support

00:26:45,160 --> 00:26:48,280
execute-only memory, but not VE.

00:26:48,280 --> 00:26:50,436
And so for those CPUs, KVM would have to emulate VE

00:26:50,436 --> 00:26:53,540
and so it starts to become, not less complicated,

00:26:53,540 --> 00:26:55,390
but more complicated.

00:26:55,390 --> 00:26:58,340
And since we want to support a bunch of old CPUs with this,

00:26:59,678 --> 00:27:00,990
I went with the simplest method right now,

00:27:00,990 --> 00:27:02,340
which is just injecting the faults,

00:27:02,340 --> 00:27:05,563
but we'll see what people think on that.

00:27:07,930 --> 00:27:09,800
Okay, so implementing non-strict mode.

00:27:09,800 --> 00:27:14,800
And I talked earlier about how we don't want to have

00:27:15,160 --> 00:27:17,230
security solutions if they have too much complexity,

00:27:17,230 --> 00:27:18,300
that's not good.

00:27:18,300 --> 00:27:20,140
And this is where there's a little bit of complexity

00:27:20,140 --> 00:27:21,540
that creeps in.

00:27:21,540 --> 00:27:23,873
I'm hoping the non-strict mode would be a temporary thing.

00:27:23,873 --> 00:27:26,770
I think it's possible that all this work

00:27:26,770 --> 00:27:30,540
to sort of detect these exo-violations that were missed,

00:27:30,540 --> 00:27:32,270
maybe that will never be executed,

00:27:32,270 --> 00:27:37,270
maybe that somehow, the kernel was way more

00:27:37,340 --> 00:27:40,100
accepting to exo-permissions than I expected,

00:27:40,100 --> 00:27:42,356
so maybe this stuff is completely unneeded.

00:27:42,356 --> 00:27:45,640
So potential solutions for this are

00:27:46,860 --> 00:27:49,180
a hypercall, like the one I first discussed,

00:27:49,180 --> 00:27:52,570
that can turn off exo-permissions on the physical

00:27:52,570 --> 00:27:54,063
address range of the exo.

00:27:55,140 --> 00:27:57,310
And the problems with this is that sort of muddies

00:27:57,310 --> 00:27:59,270
the virtual memory abstraction

00:27:59,270 --> 00:28:01,730
and creates non-deterministic behavior

00:28:01,730 --> 00:28:02,930
when the pages are reused.

00:28:02,930 --> 00:28:06,860
So, say you were a user space program,

00:28:06,860 --> 00:28:08,470
and the kernel had an exo-violation,

00:28:08,470 --> 00:28:11,260
now that page is no longer actually exo,

00:28:11,260 --> 00:28:12,710
and that page gets assigned a user space,

00:28:12,710 --> 00:28:13,730
and you were relying on that

00:28:13,730 --> 00:28:15,370
and it doesn't work anymore.

00:28:15,370 --> 00:28:16,853
That's not ideal.

00:28:17,710 --> 00:28:21,220
You could disable execute only for the whole system,

00:28:21,220 --> 00:28:23,930
which has a similar problem for user space

00:28:23,930 --> 00:28:27,420
and is kind of just a little bit extreme.

00:28:27,420 --> 00:28:31,330
And then lastly, to try to fix the exo-permission

00:28:31,330 --> 00:28:33,660
in the guest page tables,

00:28:33,660 --> 00:28:36,670
which sort of keeps the nice virtual memory abstraction

00:28:36,670 --> 00:28:39,520
and how we're pretending this is a real hardware feature.

00:28:40,360 --> 00:28:42,150
But the problem with this is that the exo-faults

00:28:42,150 --> 00:28:44,080
can happen in any context.

00:28:44,080 --> 00:28:47,370
And so it could race, trying to fix some of the page tables

00:28:47,370 --> 00:28:52,370
we can't lock, and so this could race with other

00:28:52,580 --> 00:28:56,160
page tables changes and create all sorts of weird behavior.

00:28:56,160 --> 00:28:57,810
Another complication with all these

00:28:57,810 --> 00:29:00,200
is that if you probe the fault handler

00:29:00,200 --> 00:29:03,440
then you could be redirected into a BPF program or something

00:29:03,440 --> 00:29:06,090
that calls into the kernel and hits another XO fault.

00:29:07,370 --> 00:29:12,370
So that one, is still sort of open.

00:29:13,300 --> 00:29:15,720
Right now I've sort of just disabled probing

00:29:15,720 --> 00:29:18,740
when you're using the fault fixer on the fault handler.

00:29:18,740 --> 00:29:20,810
Not all probing, just on the fault handler.

00:29:20,810 --> 00:29:23,490
But I still need to look into

00:29:23,490 --> 00:29:24,720
maybe some better ways of doing that.

00:29:24,720 --> 00:29:26,160
But on the races though,

00:29:26,160 --> 00:29:30,423
I hesitantly say I think that this can be done.

00:29:31,980 --> 00:29:35,140
So, like I said, the exo-faults can happen at interrupt

00:29:35,140 --> 00:29:36,770
so we can't lock

00:29:36,770 --> 00:29:39,210
and so we need to locklessly change the page tables

00:29:39,210 --> 00:29:40,163
in fault handler.

00:29:41,300 --> 00:29:42,700
This is a little bit easier than it sounds

00:29:42,700 --> 00:29:46,120
because the exo-faults can only happen on exo-pages.

00:29:46,120 --> 00:29:48,860
And those pages only are created in a few cases,

00:29:48,860 --> 00:29:51,740
like in a limited set of cases.

00:29:51,740 --> 00:29:56,383
So we can avoid races here by forbidding any change

00:29:58,140 --> 00:30:01,040
of the page table permissions on those pages

00:30:01,940 --> 00:30:04,410
except for toggling the readable bit

00:30:04,410 --> 00:30:05,850
whenever the page might be loaded.

00:30:05,850 --> 00:30:08,260
So if it's in use, like if it's a module that's in use,

00:30:08,260 --> 00:30:12,680
then we can't change the permissions on it.

00:30:12,680 --> 00:30:15,520
Then the other case is that breaking of large pages,

00:30:15,520 --> 00:30:18,530
which can happen on the kernel text direct map.

00:30:18,530 --> 00:30:21,653
These page breaking could be overwritten by the fault fixer.

00:30:22,662 --> 00:30:24,140
So we can't break any large pages

00:30:24,140 --> 00:30:25,863
when the pages are not readable.

00:30:28,690 --> 00:30:33,270
So the main issue here was ftrace,

00:30:33,270 --> 00:30:35,040
which sets all the modules

00:30:35,040 --> 00:30:37,660
to be read-write and execute while it's patching.

00:30:37,660 --> 00:30:39,870
So if you're doing ftrace and then live patches

00:30:39,870 --> 00:30:40,703
uses this method.

00:30:40,703 --> 00:30:43,330
So if you're doing live patching or ftrace

00:30:43,330 --> 00:30:46,050
then right when the exo-fault fixer goes off

00:30:46,050 --> 00:30:47,710
then there could be issues.

00:30:47,710 --> 00:30:50,220
So the way I worked around this for now

00:30:50,220 --> 00:30:52,740
is using text_poke in ftrace

00:30:52,740 --> 00:30:54,320
and this was actually proposed earlier

00:30:54,320 --> 00:30:59,220
because the ftrace mapping leaving all the modules

00:30:59,220 --> 00:31:00,570
as read, write, and execute

00:31:01,900 --> 00:31:05,476
exposes that mapping for other CPUs that

00:31:05,476 --> 00:31:07,490
may have dangling pointers in there,

00:31:07,490 --> 00:31:09,860
so they would be able to go overwrite the text.

00:31:09,860 --> 00:31:13,460
So it's kind of better for security in other ways.

00:31:13,460 --> 00:31:18,460
But the reason why this wasn't merged was because

00:31:18,525 --> 00:31:23,525
it takes a little bit longer to go install the trace points

00:31:23,540 --> 00:31:24,580
using it this way.

00:31:24,580 --> 00:31:28,443
So this is an install time slow down.

00:31:29,870 --> 00:31:31,400
But here we have no other choice,

00:31:31,400 --> 00:31:34,410
so ftrace is, only when using the fault fixer,

00:31:34,410 --> 00:31:36,230
so not when you're using execute-only strict mode,

00:31:36,230 --> 00:31:37,900
only the non-strict mode,

00:31:37,900 --> 00:31:40,453
we go and use text_poke in that case.

00:31:41,490 --> 00:31:44,280
So I built a solution around this

00:31:44,280 --> 00:31:46,450
and it seems promising but I'm not ready to say

00:31:46,450 --> 00:31:47,693
that it's solved yet.

00:31:48,670 --> 00:31:51,133
But I'm still kind of going down this path.

00:31:55,090 --> 00:31:57,390
So this is the part that's the call to action.

00:31:58,437 --> 00:31:59,270
If we want the kernel having

00:31:59,270 --> 00:32:01,030
execute-only text to have a future,

00:32:01,030 --> 00:32:02,420
we need to have a new assumption

00:32:02,420 --> 00:32:04,803
that the kernel text is not always readable.

00:32:05,770 --> 00:32:09,670
If you have exo or non-exo architecture specific code

00:32:09,670 --> 00:32:10,803
that reads text,

00:32:17,220 --> 00:32:19,460
so then this is okay.

00:32:19,460 --> 00:32:21,850
If you have a module that needs to read itself

00:32:21,850 --> 00:32:24,840
for some weird reason, this is okay.

00:32:24,840 --> 00:32:27,140
There's a module parameter to mark the module

00:32:27,140 --> 00:32:29,130
as not exo-compatible.

00:32:29,130 --> 00:32:32,350
And then, but if you have core code

00:32:32,350 --> 00:32:34,990
that unconditionally reads text in the core kernel,

00:32:34,990 --> 00:32:37,560
you know, in C or something, then this would

00:32:37,560 --> 00:32:38,440
no longer be okay.

00:32:38,440 --> 00:32:41,110
You'd have to go check if you're using exo-text

00:32:41,110 --> 00:32:43,410
or we could create the text_poke for reads

00:32:43,410 --> 00:32:45,510
that just does the mem copy or mem compare

00:32:46,443 --> 00:32:47,340
if you're not using XO.

00:32:47,340 --> 00:32:48,640
But this would have to be sorted.

00:32:48,640 --> 00:32:50,960
A little more care needs to be taken with that.

00:32:50,960 --> 00:32:54,900
And then if you have x86 code that reads the text

00:32:54,900 --> 00:32:56,670
like all the text patching stuff I found,

00:32:56,670 --> 00:32:58,230
then you'd have to use more care.

00:32:58,230 --> 00:32:59,883
So if we want this to be a thing

00:32:59,883 --> 00:33:01,722
then we have to agree that going forward

00:33:01,722 --> 00:33:04,022
we'd have to go take more care in these cases.

00:33:06,590 --> 00:33:08,300
So my plans for this would be

00:33:08,300 --> 00:33:10,443
to first try to land userspace support.

00:33:12,345 --> 00:33:14,630
This would mostly be VMM enabling.

00:33:14,630 --> 00:33:18,040
And then in the guest kernel itself it would be

00:33:18,040 --> 00:33:20,500
pretty similar to just adding other permission bits

00:33:20,500 --> 00:33:23,220
which is sort of a well worn path.

00:33:23,220 --> 00:33:26,130
And then after that, that infrastructure was landed

00:33:26,130 --> 00:33:30,130
I'd try to land the XO feature for kernel.

00:33:30,130 --> 00:33:33,360
And then everyone would be using non-strict mode

00:33:33,360 --> 00:33:35,490
at the beginning and sort of watch and wait and see

00:33:35,490 --> 00:33:36,470
if anything was found

00:33:36,470 --> 00:33:39,270
and try to work around or fix any issues that are found.

00:33:40,987 --> 00:33:44,820
And then there's also some options for strengthening this.

00:33:44,820 --> 00:33:47,050
There's the symbol tables, which would be a pretty

00:33:47,050 --> 00:33:48,600
interesting target if you're trying to figure out

00:33:48,600 --> 00:33:51,290
where the functions are located in the kernel.

00:33:51,290 --> 00:33:54,610
So we'd want to leave these unmapped potentially,

00:33:54,610 --> 00:33:58,893
or dropped after boot, which would limit some functionality.

00:34:00,110 --> 00:34:05,110
And so that this could also be strengthening this feature.

00:34:05,460 --> 00:34:10,010
This wouldn't be the start of something to plug all leaks.

00:34:10,010 --> 00:34:12,730
That would sort of be a never-ending task.

00:34:12,730 --> 00:34:14,210
This is supposed to be just a hardening feature

00:34:14,210 --> 00:34:16,633
that blocks some ways of figuring this out.

00:34:17,640 --> 00:34:19,640
But the symbol tables seem like a big sort of thing

00:34:19,640 --> 00:34:21,260
that could be gone after.

00:34:21,260 --> 00:34:24,326
And then also maybe turning on execute-only

00:34:24,326 --> 00:34:25,159
for BPF JITs.

00:34:25,159 --> 00:34:26,400
I haven't looked at this at all.

00:34:26,400 --> 00:34:28,363
May be just a simple as turning it on.

00:34:29,860 --> 00:34:33,070
But that could also be useful if you leave any of the text

00:34:33,070 --> 00:34:35,370
as readable then that's where the attacker

00:34:35,370 --> 00:34:36,560
would probably start going around read and looking for

00:34:36,560 --> 00:34:37,660
the gadgets they need.

00:34:40,300 --> 00:34:42,510
So my favorite way to characterize this feature

00:34:42,510 --> 00:34:44,280
is it's kind of like the NX bit.

00:34:44,280 --> 00:34:46,490
You know, the NX stopped easy ways of getting

00:34:46,490 --> 00:34:49,093
arbitrary code execution for free in hardware.

00:34:49,984 --> 00:34:51,720
There's other ways, like ROP,

00:34:51,720 --> 00:34:54,950
where the attackers can still do arbitrary code execution,

00:34:54,950 --> 00:34:57,290
but the value of NX is that

00:34:57,290 --> 00:34:59,730
the performance security trade off is there

00:34:59,730 --> 00:35:01,560
and it stops a whole bunch of low level attacks,

00:35:01,560 --> 00:35:03,160
low effort attacks.

00:35:03,160 --> 00:35:05,300
So execute-only memory

00:35:05,300 --> 00:35:07,590
is available now in existing hardware.

00:35:07,590 --> 00:35:10,070
And hopefully, I'm going to keep looking,

00:35:10,070 --> 00:35:12,832
hopefully free or close to free performance-wise.

00:35:12,832 --> 00:35:16,130
But if we want to support this longterm,

00:35:16,130 --> 00:35:18,870
the cost is mostly in the complexity of now,

00:35:18,870 --> 00:35:21,590
especially text patching stuff has to take more care

00:35:21,590 --> 00:35:23,040
when reading the kernel text.

00:35:24,651 --> 00:35:25,900
And if anyone wants to look at the patches,

00:35:25,900 --> 00:35:27,440
like I said, I haven't posted the list yet

00:35:27,440 --> 00:35:28,740
because it's not ready.

00:35:28,740 --> 00:35:30,440
Some of these commits don't have commit messages

00:35:30,440 --> 00:35:31,273
and things like that,

00:35:31,273 --> 00:35:33,450
but if anyone wants to take an early look,

00:35:33,450 --> 00:35:35,500
I pretty much put them up here on GitHub.

00:35:37,450 --> 00:35:38,893
So that's it.

00:35:40,150 --> 00:35:41,063
Any questions?

00:35:44,214 --> 00:35:46,464
(applause)

00:35:50,800 --> 00:35:53,700
- Did you find any examples of modules that read themselves

00:35:53,700 --> 00:35:55,420
for weird reasons?

00:35:55,420 --> 00:35:58,300
- [Rick] I did not and I haven't looked yet,

00:35:58,300 --> 00:36:01,150
but I did find one case.

00:36:01,150 --> 00:36:03,500
Well, actually it was pointed out to me by a Gcc person

00:36:03,500 --> 00:36:04,370
I talked to,

00:36:04,370 --> 00:36:07,390
where there was a library with assembly code

00:36:07,390 --> 00:36:08,800
that did read itself.

00:36:08,800 --> 00:36:13,130
So I thought if anyone's using assembly language libraries

00:36:13,130 --> 00:36:15,410
or something in a module that there may be stuff like that.

00:36:15,410 --> 00:36:16,750
So I didn't find any in the modules,

00:36:16,750 --> 00:36:19,100
but I haven't looked that hard at that,

00:36:19,100 --> 00:36:21,923
but I have found it in, like I know of a case

00:36:21,923 --> 00:36:23,006
in userspace.

00:36:24,120 --> 00:36:26,358
- And what about literals in assembler?

00:36:26,358 --> 00:36:27,260
- [Rick] What was that?

00:36:27,260 --> 00:36:28,133
- Literals.

00:36:29,050 --> 00:36:29,883
- [Rick] Uh...

00:36:29,883 --> 00:36:31,037
- Well, you said they could exist

00:36:31,037 --> 00:36:34,403
but did you look at all at the x86 assembly?

00:36:34,403 --> 00:36:39,403
- [Rick] So there was somebody that had done some work

00:36:39,750 --> 00:36:43,410
on execute-only memory for userspace at Intel,

00:36:43,410 --> 00:36:45,990
had built some static analysis tools

00:36:45,990 --> 00:36:47,520
for analyzing userspace programs

00:36:47,520 --> 00:36:51,190
and they had adapted those to look at the kernel text

00:36:51,190 --> 00:36:53,118
and those tools of which I don't know the details,

00:36:53,118 --> 00:36:54,890
didn't find anything.

00:36:54,890 --> 00:36:57,640
So in the static case, it seemed like there wasn't.

00:36:57,640 --> 00:36:59,850
And also it boots with execute-only.

00:36:59,850 --> 00:37:01,980
Well, I set execute-only memory during boot,

00:37:01,980 --> 00:37:05,060
so if the assembly is happening really early,

00:37:05,060 --> 00:37:06,233
it's not execute-only.

00:37:07,360 --> 00:37:08,680
So then that should be fine,

00:37:08,680 --> 00:37:09,990
'cause I just want to turn this on

00:37:09,990 --> 00:37:11,393
before userspace comes up.

00:37:12,670 --> 00:37:13,763
Um, yeah.

00:37:17,830 --> 00:37:22,140
- So for userspace, have you found any application

00:37:22,140 --> 00:37:26,653
that assumes that PROT_EXEC implies PROT_READ?

00:37:27,550 --> 00:37:28,890
- [Rick] Yeah, so that's a good question.

00:37:28,890 --> 00:37:32,220
So I haven't done the userspace,

00:37:32,220 --> 00:37:35,720
first of all, I haven't done userspace patches

00:37:35,720 --> 00:37:37,270
for this feature yet.

00:37:37,270 --> 00:37:40,180
But that's how Protection Keys does it.

00:37:40,180 --> 00:37:44,042
So it said in the commit message that looked for

00:37:44,042 --> 00:37:45,690
userspace programs that did that,

00:37:45,690 --> 00:37:48,170
that just did PROT_EXEC because it should work.

00:37:48,170 --> 00:37:50,370
Thinking, oh, well, I'll just put one flag.

00:37:50,370 --> 00:37:51,457
And they didn't...

00:37:51,457 --> 00:37:54,023
- [Audience Member] (mumbles off mic)

00:37:54,023 --> 00:37:55,846
- But you haven't found any on 64?

00:37:55,846 --> 00:37:56,679
Is that what you said?

00:37:56,679 --> 00:37:58,680
- [Audience Member] (mumbles off mic)

00:37:58,680 --> 00:37:59,802
- Okay.

00:37:59,802 --> 00:38:03,140
No, no, so I haven't looked at all but all I saw was that

00:38:03,140 --> 00:38:04,770
for Protection Keys they looked

00:38:04,770 --> 00:38:05,720
and didn't see any.

00:38:06,660 --> 00:38:07,970
So yeah, I kind of thought

00:38:07,970 --> 00:38:09,270
that was kind of a brave choice to make

00:38:09,270 --> 00:38:11,283
but apparently it works out.

00:38:12,331 --> 00:38:16,860
- How does this affect things like crash dumps and stuff?

00:38:16,860 --> 00:38:21,420
Do you typically from KVM do that from the host side?

00:38:21,420 --> 00:38:23,070
- [Rick] You mean like an oops or something else?

00:38:23,070 --> 00:38:25,120
- Right. Like the crash dump oops because it's trying

00:38:25,120 --> 00:38:26,940
to read the text, write it out to the dump.

00:38:26,940 --> 00:38:30,290
- [Rick] Yes, so since we're injecting a fault,

00:38:30,290 --> 00:38:34,270
it actually works with the probe kernel read function,

00:38:34,270 --> 00:38:37,560
so this will just return it wasn't able to read the text.

00:38:37,560 --> 00:38:42,240
So the oops handler will try to read the text

00:38:42,240 --> 00:38:45,290
and find out that it's, it acts like it would be

00:38:45,290 --> 00:38:46,820
if the page was not present.

00:38:46,820 --> 00:38:48,970
And it just says, "Couldn't read the text."

00:38:49,960 --> 00:38:51,920
And then the stack trace works fine

00:38:51,920 --> 00:38:53,280
because that's off the symbol tables.

00:38:53,280 --> 00:38:55,820
- Yes, but what about like, the kdump patches

00:38:55,820 --> 00:38:58,130
and other stuff where you have like kexec to another

00:38:58,130 --> 00:38:59,480
kernel that's then going to

00:39:00,611 --> 00:39:02,940
write the panic progression down.

00:39:02,940 --> 00:39:03,773
- [Rick] I'm not sure.

00:39:03,773 --> 00:39:04,606
- Okay.

00:39:09,750 --> 00:39:11,323
- [Moderator] Any other questions?

00:39:13,300 --> 00:39:15,243
All right. Let's thank the speaker.

00:39:16,167 --> 00:39:17,401

YouTube URL: https://www.youtube.com/watch?v=BkRI9TFS8Eo


