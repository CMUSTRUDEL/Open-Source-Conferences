Title: LPC2019 - RDMA - MC
Publication date: 2019-09-20
Playlist: Linux Plumbers Conference 2019
Description: 
	RDMA - MC
Captions: 
	00:00:00,798 --> 00:00:03,798
(people chattering)

00:00:07,370 --> 00:00:09,740
- Hello, everyone.

00:00:09,740 --> 00:00:13,750
Thank you for coming for fourth RDA mini conference.

00:00:15,493 --> 00:00:19,250
We will start from memory specific topics,

00:00:19,250 --> 00:00:21,230
but don't be afraid.

00:00:21,230 --> 00:00:23,550
It's going to be related to RDA,

00:00:23,550 --> 00:00:28,550
related to blog device and something,

00:00:29,172 --> 00:00:34,172
other similar sub-system to us.

00:00:36,250 --> 00:00:38,230
First talk is going to be presented

00:00:38,230 --> 00:00:41,240
by three people from three different companies,

00:00:41,240 --> 00:00:43,708
Jason from Mellanox,

00:00:43,708 --> 00:00:45,330
Don from Reddit,

00:00:45,330 --> 00:00:47,550
and John from Nvidia,

00:00:47,550 --> 00:00:50,110
so it's actually joint work

00:00:50,110 --> 00:00:54,460
to improve and connect RDMA to memory management

00:00:54,460 --> 00:00:57,210
and to complex devices,

00:00:57,210 --> 00:00:58,830
like GPU devices,

00:00:58,830 --> 00:01:02,000
to share memory altogether over RDMA.

00:01:02,000 --> 00:01:06,160
So, it's going to be exciting session, long session,

00:01:07,121 --> 00:01:09,750
and we're expecting a lot of questions from you.

00:01:13,120 --> 00:01:13,990
- [John] Let's start.

00:01:13,990 --> 00:01:14,823
- Let's start?

00:01:17,270 --> 00:01:18,543
- All right.

00:01:18,543 --> 00:01:20,080
So, we titled this,

00:01:20,080 --> 00:01:21,520
I think we allocated 40 minutes

00:01:21,520 --> 00:01:24,480
or an hour for this topic, an hour,

00:01:24,480 --> 00:01:27,460
for the perennially complicated topic

00:01:27,460 --> 00:01:29,770
of Zone Device and get_user_pages,

00:01:29,770 --> 00:01:32,280
and how do we wanna fit all this together

00:01:32,280 --> 00:01:33,320
into the sub-systems?

00:01:33,320 --> 00:01:35,080
So, we've got a couple slides

00:01:35,080 --> 00:01:37,060
to help the audience catch up,

00:01:37,060 --> 00:01:39,630
if you're not totally familiar with all these things.

00:01:39,630 --> 00:01:41,470
So, the kernel has this thing called Zone Device,

00:01:41,470 --> 00:01:44,430
which Dan, here, created some time ago.

00:01:45,513 --> 00:01:47,000
(laughing)

00:01:47,000 --> 00:01:49,335
He doesn't wanna take responsibility for this,

00:01:49,335 --> 00:01:51,655
(laughing)

00:01:51,655 --> 00:01:52,654
- [Man] It was his fault.

00:01:52,654 --> 00:01:53,487
- I think it was created for DAX, right?

00:01:53,487 --> 00:01:56,620
- [Dan] Yeah, because it was created

00:01:57,912 --> 00:01:59,530
for get_user_pages for PMEM,

00:01:59,530 --> 00:02:00,363
or persistent memory.

00:02:00,363 --> 00:02:01,196
- Okay.

00:02:02,179 --> 00:02:03,350
- [Dan] And then, everybody

00:02:03,350 --> 00:02:04,183
found lots of other uses cases for it.

00:02:04,183 --> 00:02:05,180
- Lots of other use cases.

00:02:05,180 --> 00:02:06,240
So first, it was for DAX,

00:02:06,240 --> 00:02:08,690
which I suppose the FS DAX and Dev DAX

00:02:09,720 --> 00:02:11,530
items on the slide there,

00:02:11,530 --> 00:02:13,380
and then I'm not sure which came next.

00:02:13,380 --> 00:02:15,971
I think Jerome added Device Private for HMM,

00:02:15,971 --> 00:02:18,140
and Logan, who's not here,

00:02:18,140 --> 00:02:20,830
added PCIP to PDMA,

00:02:23,387 --> 00:02:25,537
which we're gonna start talking about next,

00:02:26,529 --> 00:02:29,480
is for transfers between two PCI devices

00:02:29,480 --> 00:02:30,430
in the same system,

00:02:32,330 --> 00:02:34,230
and you can kinda view Zone Device,

00:02:35,427 --> 00:02:36,260
this is how I've been kinda viewing it

00:02:36,260 --> 00:02:38,140
as an alternative to using the VMIO

00:02:39,258 --> 00:02:41,130
and PFM map flags

00:02:41,130 --> 00:02:44,192
when you insert pages to user space,

00:02:44,192 --> 00:02:45,240
'cause we're gonna start primarily talking

00:02:45,240 --> 00:02:47,250
about user space at this point,

00:02:47,250 --> 00:02:49,010
and really, I think the main motivation

00:02:49,010 --> 00:02:50,770
for having Zone Device pages at all

00:02:50,770 --> 00:02:52,760
has to do with interacting with user space.

00:02:52,760 --> 00:02:54,052
If you were solely in the kernel,

00:02:54,052 --> 00:02:57,790
there's less reasons why you'd need to have them.

00:02:57,790 --> 00:02:59,920
So, this is my master diagram

00:02:59,920 --> 00:03:01,880
to try and explain what it is that we're trying to do,

00:03:01,880 --> 00:03:03,830
and I'm gonna go stand over here

00:03:05,260 --> 00:03:06,250
and look at the camera,

00:03:06,250 --> 00:03:08,990
and it will be good. (laughing)

00:03:09,877 --> 00:03:12,178
So, the goal here is to enable this red line.

00:03:12,178 --> 00:03:14,470
So, this is an RDMA from the network

00:03:14,470 --> 00:03:16,760
and it goes through, the NIC,

00:03:16,760 --> 00:03:19,150
goes only through the PCI

00:03:19,150 --> 00:03:20,720
and ends up directly on something,

00:03:20,720 --> 00:03:22,110
like an NVMe.

00:03:22,110 --> 00:03:24,020
So, this red line is what we're trying to do,

00:03:25,041 --> 00:03:26,160
and today, you can't do that red line

00:03:26,160 --> 00:03:28,710
because there's no way to connect the RDMA driver

00:03:28,710 --> 00:03:31,230
with the FVIO driver in the kernel,

00:03:31,230 --> 00:03:33,610
there's no way to exchange those special information

00:03:33,610 --> 00:03:35,260
about the bar pages to set up

00:03:35,260 --> 00:03:37,900
all the pieces that are needed in to here.

00:03:37,900 --> 00:03:38,840
So, the concept

00:03:39,770 --> 00:03:41,440
is we'd have a single user space process,

00:03:41,440 --> 00:03:43,580
that's kind of shown in the middle,

00:03:43,580 --> 00:03:46,070
that's doing VFIO and RDMA together.

00:03:46,910 --> 00:03:47,890
On the VFIO side,

00:03:47,890 --> 00:03:49,640
it's getting bar pages through mmap

00:03:51,010 --> 00:03:52,380
and we wanna use the flow

00:03:52,380 --> 00:03:54,350
where we're creating Zone Device pages for them

00:03:54,350 --> 00:03:57,590
with the existing P2P DMA add resources,

00:03:57,590 --> 00:04:00,790
inspired flow, and then instead of using PFM map,

00:04:00,790 --> 00:04:01,790
we're using insert page,

00:04:01,790 --> 00:04:03,290
so there's actual struct pages

00:04:03,290 --> 00:04:04,440
behind the VMA,

00:04:05,480 --> 00:04:07,790
and that would allow the RDMA side

00:04:07,790 --> 00:04:09,490
to pick up the struct pages,

00:04:09,490 --> 00:04:10,380
get the information

00:04:10,380 --> 00:04:12,550
that tells all the rest of the system

00:04:12,550 --> 00:04:14,020
how to route those P2Ps

00:04:14,020 --> 00:04:15,560
out of the struct pages

00:04:15,560 --> 00:04:16,960
and then configure it's IOMU

00:04:17,812 --> 00:04:19,290
and use the DMA PI, and so forth.

00:04:19,290 --> 00:04:20,710
So, we can have this whole circle

00:04:20,710 --> 00:04:24,110
of communication using struct pages in the kernel side,

00:04:24,110 --> 00:04:26,300
and then communication with raw TLPs

00:04:26,300 --> 00:04:28,370
bypassing the system memory

00:04:28,370 --> 00:04:29,670
on the inner connect side.

00:04:32,910 --> 00:04:33,860
We're getting pretty close

00:04:33,860 --> 00:04:35,660
to having all the pieces to do this,

00:04:36,800 --> 00:04:39,430
but I think there's still a few tricky bits left,

00:04:40,825 --> 00:04:42,600
and I think the next slide is for Don,

00:04:42,600 --> 00:04:45,380
who's been working on the VFIO part of this.

00:04:47,500 --> 00:04:48,333
- Thanks, Jason.

00:04:48,333 --> 00:04:49,740
So, I'm gonna go over here,

00:04:49,740 --> 00:04:50,940
like we were instructed.

00:04:52,410 --> 00:04:55,260
So, we decided to pick the MVME

00:04:55,260 --> 00:04:57,290
because A, they're easier to get through

00:04:57,290 --> 00:04:59,590
and it's something we can play around with user space,

00:04:59,590 --> 00:05:01,409
even though we started the talk

00:05:01,409 --> 00:05:02,242
saying we're gonna do GPUs,

00:05:02,242 --> 00:05:04,620
because they're a lot more complicated and harder,

00:05:04,620 --> 00:05:05,970
so we figured we'd learn to walk

00:05:05,970 --> 00:05:08,010
before we gallop.

00:05:09,160 --> 00:05:12,430
So, the VFIO change is pretty simple.

00:05:12,430 --> 00:05:13,990
It was just a new ioctl

00:05:15,153 --> 00:05:16,735
and we basically did

00:05:16,735 --> 00:05:18,490
what some of the NVME drivers do,

00:05:18,490 --> 00:05:21,797
which is called peer to peer DMA create or add,

00:05:21,797 --> 00:05:24,090
and therefore, we hooked up,

00:05:24,090 --> 00:05:27,380
as Jason mentioned in the previous slide,

00:05:27,380 --> 00:05:28,450
the struct pages,

00:05:28,450 --> 00:05:29,840
which is what you need to do

00:05:29,840 --> 00:05:32,530
so you can do DMA mapping.

00:05:32,530 --> 00:05:33,550
Without a struct page,

00:05:33,550 --> 00:05:36,050
it doesn't know how to translate one user address

00:05:36,050 --> 00:05:37,740
to a physical address,

00:05:37,740 --> 00:05:39,140
so that's really the crux

00:05:39,140 --> 00:05:40,950
of the VFIO work.

00:05:40,950 --> 00:05:45,040
It was a simple, quick, easy way to do it,

00:05:45,040 --> 00:05:47,110
although, yesterday afternoon,

00:05:48,470 --> 00:05:50,820
one of the fun things of working with multiple people

00:05:50,820 --> 00:05:51,990
from multiple companies

00:05:51,990 --> 00:05:53,700
is we have lots of great ideas,

00:05:53,700 --> 00:05:56,950
and hopefully, that's what we're looking to get here.

00:05:56,950 --> 00:05:59,450
We actually had a debate over some issues and stuff,

00:05:59,450 --> 00:06:02,473
and now we're toying the idea of running this

00:06:02,473 --> 00:06:04,350
mostly through sysfs,

00:06:04,350 --> 00:06:06,310
and not use much of VFIO.

00:06:06,310 --> 00:06:10,330
So, if anyone has comments

00:06:10,330 --> 00:06:11,740
of pros, cons,

00:06:12,930 --> 00:06:15,080
yays, nays, whatever in that space,

00:06:15,080 --> 00:06:16,090
I'd like to hear it.

00:06:16,090 --> 00:06:18,920
So, one of the people I wish was here is Logan,

00:06:18,920 --> 00:06:20,080
so I wanted to ask him.

00:06:20,080 --> 00:06:21,489
Where's Logan?

00:06:21,489 --> 00:06:23,990
- Logan's coming to Europe for Austria

00:06:23,990 --> 00:06:24,823
in a few weeks.

00:06:24,823 --> 00:06:26,519
He didn't wanna come yet.

00:06:26,519 --> 00:06:29,110
I think it would be a good question for the audience

00:06:29,110 --> 00:06:30,740
is how do we wanna deal with the problem

00:06:30,740 --> 00:06:34,360
that we don't always get Zone Device pages, apparently?

00:06:34,360 --> 00:06:35,840
This is what I've been told,

00:06:35,840 --> 00:06:37,930
and maybe Dan

00:06:37,930 --> 00:06:39,160
knows more about this.

00:06:39,160 --> 00:06:41,370
I don't know where the other catch box went.

00:06:41,370 --> 00:06:42,254
- It's right here.

00:06:42,254 --> 00:06:43,790
Right there, Dan.

00:06:43,790 --> 00:06:46,640
- So, I recall a discussion

00:06:46,640 --> 00:06:49,410
between Logan and, I think it was Benjamin Herrenschmidt

00:06:49,410 --> 00:06:53,170
from PowerPC, when Logan was adding the P2P stuff

00:06:53,170 --> 00:06:55,100
where the PowerPC guys were kinda saying

00:06:55,100 --> 00:06:57,500
that they couldn't support what Logan was doing.

00:06:59,706 --> 00:07:01,140
- It might also,

00:07:01,140 --> 00:07:05,880
everything, probably, with PowerPC's issues with that are,

00:07:05,880 --> 00:07:07,620
but it might be this fact

00:07:08,856 --> 00:07:10,074
that we have this PTE flag,

00:07:10,074 --> 00:07:10,907
called PTE Dev Map.

00:07:10,907 --> 00:07:12,630
Basically, all it does is tell get_user_pages,

00:07:12,630 --> 00:07:13,463
"oh, by the way,

00:07:13,463 --> 00:07:15,830
"you gotta pin your pages a slightly different way,"

00:07:18,589 --> 00:07:19,450
but I have plans

00:07:19,450 --> 00:07:21,170
to try to kill that flag,

00:07:21,170 --> 00:07:23,080
and this will probably make it easier

00:07:23,080 --> 00:07:24,680
for S390 and other architectures

00:07:25,640 --> 00:07:26,473
to support Zone Device

00:07:26,473 --> 00:07:28,504
without needing to spend a PTE flag

00:07:28,504 --> 00:07:30,630
on this use case.

00:07:30,630 --> 00:07:32,560
- So, I think there's a couple things.

00:07:32,560 --> 00:07:34,190
I think you need Memory Hot Plug

00:07:34,190 --> 00:07:35,380
enabled in your architecture.

00:07:35,380 --> 00:07:36,769
- Right, yeah.

00:07:36,769 --> 00:07:37,602
- I don't know how broad that is

00:07:37,602 --> 00:07:38,590
across the kernel.

00:07:38,590 --> 00:07:40,320
- That's what PowerPC's missing.

00:07:40,320 --> 00:07:41,300
- You think PowerPC's missing.

00:07:41,300 --> 00:07:43,140
- Yeah, it's missing.

00:07:43,140 --> 00:07:44,220
It isn't?

00:07:44,220 --> 00:07:45,640
That's what I started.

00:07:45,640 --> 00:07:47,208
Well, it's missing the hook for it.

00:07:47,208 --> 00:07:48,041
- Yeah.

00:07:49,230 --> 00:07:52,550
Definitely, PowerPC has some support for Zone Device pages,

00:07:52,550 --> 00:07:54,650
like for example, for persistent memory,

00:07:54,650 --> 00:07:56,980
PowerPC does support persistent memory,

00:07:56,980 --> 00:07:59,080
and it does support Zone Device stuff

00:07:59,080 --> 00:07:59,913
and stuff like that,

00:07:59,913 --> 00:08:01,140
so definitely, there's some basic support.

00:08:01,140 --> 00:08:02,640
I'm not sure what was the problem.

00:08:02,640 --> 00:08:04,170
- I'd support sparse memory,

00:08:04,170 --> 00:08:05,930
I mean, sparse memory map.

00:08:05,930 --> 00:08:06,830
- Yes. - Okay.

00:08:06,830 --> 00:08:08,250
So, you need that, too.

00:08:08,250 --> 00:08:09,450
I was left with the impression,

00:08:09,450 --> 00:08:10,283
and this was a while ago,

00:08:10,283 --> 00:08:12,030
like last year, when this conversation happened

00:08:12,030 --> 00:08:15,330
that it had to do with the physical address

00:08:15,330 --> 00:08:16,790
of the bar pages,

00:08:16,790 --> 00:08:19,290
because of the way PowerPC laid out its memory map,

00:08:19,290 --> 00:08:21,300
there was a gigantic gap

00:08:21,300 --> 00:08:23,320
between system memory and the bar pages

00:08:23,320 --> 00:08:25,740
and this caused them some sort of grief.

00:08:25,740 --> 00:08:26,690
This, I don't know.

00:08:27,580 --> 00:08:28,730
- Shouldn't be a problem

00:08:28,730 --> 00:08:30,060
with sparse memory map.

00:08:30,060 --> 00:08:31,630
- This is also,

00:08:31,630 --> 00:08:34,510
'cause one of the problems with Zone Device

00:08:34,510 --> 00:08:36,340
is it assumes you want the linear map,

00:08:36,340 --> 00:08:37,820
'cause it wanted persistent memory,

00:08:37,820 --> 00:08:40,480
but we don't want the linear map for bar pages.

00:08:40,480 --> 00:08:42,230
So, I wonder if that's where they're running into issues.

00:08:42,230 --> 00:08:45,060
- [Jason] Maybe, maybe.

00:08:45,060 --> 00:08:45,893
- That could be a problem.

00:08:45,893 --> 00:08:48,019
But we certainly eliminate that.

00:08:48,019 --> 00:08:50,040
There's no need to have a linear map for this stuff.

00:08:50,040 --> 00:08:51,227
- [Jason] Okay.

00:08:51,227 --> 00:08:53,325
- But, certain if Ben is running somewhere

00:08:53,325 --> 00:08:54,790
the whole device.

00:08:54,790 --> 00:08:56,390
- Yes, I saw Ben around earlier.

00:08:57,825 --> 00:08:58,880
Yes.

00:08:58,880 --> 00:09:01,300
Sorry, and for the purpose of the video recording,

00:09:01,300 --> 00:09:02,133
if you're talking

00:09:02,133 --> 00:09:04,490
please stand up so you can get in the video,

00:09:04,490 --> 00:09:06,000
and hold the mic like this,

00:09:06,000 --> 00:09:08,230
I've been told. (laughing)

00:09:08,230 --> 00:09:09,063
A little higher.

00:09:09,063 --> 00:09:09,896
There you go.

00:09:09,896 --> 00:09:10,960
Just like this.

00:09:10,960 --> 00:09:12,310
Right at the chest bone.

00:09:14,810 --> 00:09:16,560
Okay, but just as a general question,

00:09:16,560 --> 00:09:18,930
can we assume that we can do

00:09:18,930 --> 00:09:22,340
the PCIP to P2PDMA add resources?

00:09:22,340 --> 00:09:24,970
Can we assume that'll work broadly on most systems,

00:09:26,230 --> 00:09:27,790
or is this something that's gonna work

00:09:27,790 --> 00:09:29,490
on a sub-set of our architectures?

00:09:33,580 --> 00:09:37,330
- It's gonna work on the ARM x86 and PowerPC

00:09:37,330 --> 00:09:39,260
not S390 right now.

00:09:39,260 --> 00:09:41,490
S390 has an issue on PowerPC,

00:09:41,490 --> 00:09:43,090
which is sub-archive.

00:09:45,230 --> 00:09:46,490
- PowerPC is, sorry?

00:09:46,490 --> 00:09:48,220
- S390 is slightly different

00:09:48,220 --> 00:09:50,075
than the rest of PowerPC.

00:09:50,075 --> 00:09:51,744
- Okay.

00:09:51,744 --> 00:09:54,060
S390 is slightly different than PowerPC.

00:09:54,060 --> 00:09:55,320
I didn't know that.

00:09:55,320 --> 00:09:57,410
I didn't even know it was related to PowerPC,

00:09:57,410 --> 00:09:59,960
so that shows you how much I know about this stuff.

00:10:01,330 --> 00:10:02,860
Okay.

00:10:02,860 --> 00:10:06,220
So, when Don was talking about an IO control for VFIO,

00:10:06,220 --> 00:10:07,500
the purpose was

00:10:08,520 --> 00:10:10,390
the thinking that we don't want to enable

00:10:10,390 --> 00:10:12,550
these Zone Device pages unconditionally,

00:10:12,550 --> 00:10:13,383
because there's a lot of systems

00:10:13,383 --> 00:10:14,216
that don't want them.

00:10:14,216 --> 00:10:16,130
It takes a lot of memory to set them up,

00:10:16,130 --> 00:10:18,134
and then there's architectures

00:10:18,134 --> 00:10:19,180
where it isn't gonna work still,

00:10:19,180 --> 00:10:22,140
and so, there's a discussion

00:10:22,140 --> 00:10:23,600
about how should we do this,

00:10:23,600 --> 00:10:25,870
and we started with maybe an IO control

00:10:25,870 --> 00:10:27,030
for VFIO made sense,

00:10:27,030 --> 00:10:29,570
and it does make sense in a VFIO-only context,

00:10:29,570 --> 00:10:30,870
but when you start to say,

00:10:31,891 --> 00:10:32,995
"well, we want all kinds of other drivers

00:10:32,995 --> 00:10:33,870
"to participate this to,

00:10:33,870 --> 00:10:35,190
"and maybe we need,"

00:10:35,190 --> 00:10:36,100
this is where we were getting to,

00:10:36,100 --> 00:10:37,990
"maybe we need a more."

00:10:37,990 --> 00:10:39,800
- Well, the big problem we had

00:10:39,800 --> 00:10:41,240
was you wanted to enable it

00:10:41,240 --> 00:10:42,073
for the entire bar

00:10:42,073 --> 00:10:42,906
for every device,

00:10:42,906 --> 00:10:43,739
and I'm like, "yeah,

00:10:43,739 --> 00:10:45,550
"that will just kill us in that,"

00:10:45,550 --> 00:10:47,820
so it definitely has to be

00:10:49,690 --> 00:10:52,600
a per bar, or maybe a per sub-bar issue

00:10:52,600 --> 00:10:55,290
that we've seen or heard multiple times,

00:10:55,290 --> 00:10:57,850
as well as you may have a bar

00:10:57,850 --> 00:11:01,090
that you want to partition across multiple users,

00:11:01,090 --> 00:11:03,230
so that's the other issue,

00:11:03,230 --> 00:11:05,290
and VFIO right now is geared

00:11:05,290 --> 00:11:08,170
for an all or none situation, right?

00:11:08,170 --> 00:11:09,860
You own the whole device

00:11:09,860 --> 00:11:11,710
or you don't own the device,

00:11:11,710 --> 00:11:14,160
and it doesn't partition the device

00:11:14,160 --> 00:11:16,140
across multiple users.

00:11:19,930 --> 00:11:23,150
So, that may not be as flexible.

00:11:23,150 --> 00:11:24,510
So, that's another reason why we're looking

00:11:24,510 --> 00:11:25,940
at the sysfs,

00:11:25,940 --> 00:11:27,737
where we can look at it more

00:11:27,737 --> 00:11:28,820
at a resource level,

00:11:28,820 --> 00:11:30,760
or in a resource,

00:11:30,760 --> 00:11:33,019
not necessarily even be a bar,

00:11:33,019 --> 00:11:34,667
but a piece of a bar that's device

00:11:34,667 --> 00:11:35,780
be a CMB or something like that.

00:11:35,780 --> 00:11:39,127
So, that's what we're kinda struggling with right now.

00:11:39,127 --> 00:11:41,090
- How big are these bars?

00:11:41,090 --> 00:11:42,980
- I think, like a Mellanox bar,

00:11:42,980 --> 00:11:45,190
is like 64 meg, 100 megabytes.

00:11:45,190 --> 00:11:46,990
I don't know what a GPU bar is like.

00:11:48,420 --> 00:11:51,230
- Yeah, it depends a bit on the enterprise GPUs.

00:11:51,230 --> 00:11:52,896
We're gonna size the bar

00:11:52,896 --> 00:11:54,231
or we have done it

00:11:54,231 --> 00:11:55,064
to cover the whole vAdmin,

00:11:55,064 --> 00:11:57,430
which can be 24 gigs.

00:11:57,430 --> 00:11:58,300
- 24 gigs.

00:11:58,300 --> 00:12:00,025
We're not talking about terabytes here,

00:12:00,025 --> 00:12:03,320
so are we running at a struct page base?

00:12:05,450 --> 00:12:07,820
- Well, if you start asking how many GPUs

00:12:07,820 --> 00:12:11,550
do you put on a high end HPC,

00:12:11,550 --> 00:12:12,660
and then do it all,

00:12:12,660 --> 00:12:14,420
we're talking six.

00:12:14,420 --> 00:12:16,850
I've seen presentations of 16

00:12:16,850 --> 00:12:18,180
of these things.

00:12:18,180 --> 00:12:20,890
So, 16 times whatever,

00:12:20,890 --> 00:12:21,820
what'd you say?

00:12:21,820 --> 00:12:22,700
- 17. - 24,

00:12:22,700 --> 00:12:24,020
but it's gonna get worse,

00:12:24,020 --> 00:12:26,214
so various GPU

00:12:26,214 --> 00:12:28,940
on the horizon with persistent memory,

00:12:28,940 --> 00:12:31,990
so we will have HPM, GGR, persistent memory,

00:12:31,990 --> 00:12:34,510
and then we're gonna go in the range of terabyte,

00:12:34,510 --> 00:12:36,390
but the PCI express bar is not expected

00:12:36,390 --> 00:12:37,223
to be that big.

00:12:37,223 --> 00:12:38,570
I don't think so, at least.

00:12:39,430 --> 00:12:40,263
- So, anyhow.

00:12:40,263 --> 00:12:41,990
But it could get large,

00:12:41,990 --> 00:12:43,850
so we don't wanna create

00:12:44,730 --> 00:12:45,820
this nice architecture

00:12:45,820 --> 00:12:49,050
and then we just tip everything over on it.

00:12:49,050 --> 00:12:50,170
- Well, I do wanna mention

00:12:50,170 --> 00:12:51,750
that, per device,

00:12:51,750 --> 00:12:55,900
each device will probably be 20, 30, 60 gigs,

00:12:55,900 --> 00:12:56,740
that sort of thing,

00:12:56,740 --> 00:12:59,270
so it's still manageable,

00:12:59,270 --> 00:13:01,860
but if you multiply them all together,

00:13:01,860 --> 00:13:02,710
now you've got a lot of bar space in aggregate.

00:13:02,710 --> 00:13:03,990
I just wanna clarify. - But the issue

00:13:03,990 --> 00:13:06,780
is the aggregate of device structs.

00:13:06,780 --> 00:13:07,740
- Right.

00:13:07,740 --> 00:13:08,660
I also think. - Page structs

00:13:08,660 --> 00:13:09,900
for device though.

00:13:09,900 --> 00:13:11,580
- I think a lot of us kinda broadly agree

00:13:11,580 --> 00:13:12,710
that we need some kind of future

00:13:12,710 --> 00:13:15,730
where we don't have to have struct pages for bars,

00:13:15,730 --> 00:13:17,870
but as yet,

00:13:17,870 --> 00:13:19,230
how to get there is a little unclear,

00:13:19,230 --> 00:13:20,970
so injecting struct pages

00:13:20,970 --> 00:13:23,930
is the walking step.

00:13:23,930 --> 00:13:25,330
We put the struct pages in,

00:13:25,330 --> 00:13:27,130
we build the use case,

00:13:27,130 --> 00:13:29,220
we demonstrate all the places where it wants to be,

00:13:29,220 --> 00:13:31,690
and then maybe it will be more clear

00:13:31,690 --> 00:13:33,370
how we can remove the struct page

00:13:33,370 --> 00:13:34,260
from this flow at all,

00:13:34,260 --> 00:13:36,810
because we don't really need the struct page.

00:13:36,810 --> 00:13:38,190
We could probably make it work

00:13:38,190 --> 00:13:40,930
with a different VMA flag in a lot of cases

00:13:40,930 --> 00:13:42,920
that says it's bar memory or something.

00:13:42,920 --> 00:13:44,166
I don't know.

00:13:44,166 --> 00:13:46,550
- Yeah, that was another discussion we had

00:13:46,550 --> 00:13:47,870
across the three companies,

00:13:47,870 --> 00:13:50,140
and we're trying to do a discussion about that,

00:13:50,140 --> 00:13:51,170
and we said, "well,

00:13:51,170 --> 00:13:52,860
"to get there, we would love to get

00:13:52,860 --> 00:13:53,740
"right to that point,

00:13:53,740 --> 00:13:54,573
"but it'd be really hard,"

00:13:54,573 --> 00:13:57,599
so that's why we wanna thank Dan

00:13:57,599 --> 00:13:59,677
for struct page device.

00:13:59,677 --> 00:14:02,540
It's at least a step to get us there

00:14:02,540 --> 00:14:03,930
and we're trying to figure out how to get.

00:14:03,930 --> 00:14:05,870
- That said, if somebody has a really good idea

00:14:05,870 --> 00:14:09,520
how to just avoid the struct pages step, we could.

00:14:09,520 --> 00:14:11,020
- And that's where we started.

00:14:12,274 --> 00:14:13,477
We started with the idea

00:14:13,477 --> 00:14:14,580
there's no way we're gonna be able to allocate

00:14:14,580 --> 00:14:18,200
struct page for the persistent memory range,

00:14:18,200 --> 00:14:19,880
and then we ran into issue after issue

00:14:19,880 --> 00:14:21,710
after compatibility after talking

00:14:21,710 --> 00:14:22,543
on the sub-systems,

00:14:22,543 --> 00:14:23,400
and then we said,

00:14:23,400 --> 00:14:25,120
"let's just try a Zone Device thing.

00:14:25,120 --> 00:14:26,170
"It'll be a Band-Aid,"

00:14:26,170 --> 00:14:29,316
and it's been a five year Band-Aid,

00:14:29,316 --> 00:14:33,660
and so, I kinda lost the faith

00:14:33,660 --> 00:14:35,210
on check page removal,

00:14:35,210 --> 00:14:37,660
and I'm more excited

00:14:37,660 --> 00:14:42,080
by, maybe, ideas about making it less expensive.

00:14:42,080 --> 00:14:43,170
- [Jason] Less expensive.

00:14:43,170 --> 00:14:44,910
- Like maybe could we make Zone Device

00:14:44,910 --> 00:14:46,000
always be huge pages,

00:14:47,143 --> 00:14:49,383
and build that kind of assumption in somewhere?

00:14:49,383 --> 00:14:51,560
- Yeah, that's where I was wondering,

00:14:51,560 --> 00:14:53,191
can we go to huge page?

00:14:53,191 --> 00:14:55,210
- Yeah, that sounds fantastic.

00:14:55,210 --> 00:14:56,570
- But yeah, that's also

00:14:56,570 --> 00:14:58,650
just not a very flushed out idea.

00:14:58,650 --> 00:14:59,970
- We've got two DMA zones,

00:14:59,970 --> 00:15:01,430
can we have two double zones?

00:15:01,430 --> 00:15:02,870
The big ones?

00:15:02,870 --> 00:15:04,460
- I think what Dan just explained

00:15:04,460 --> 00:15:05,900
is DAX has already been here,

00:15:05,900 --> 00:15:08,300
DAX has already tried to do without struct pages,

00:15:08,300 --> 00:15:09,840
and it just didn't work for DAX,

00:15:09,840 --> 00:15:13,190
so we're not nearly as well-resourced as DAX,

00:15:13,190 --> 00:15:16,299
so I don't wanna fight that fight yet either.

00:15:16,299 --> 00:15:17,280
(laughing)

00:15:17,280 --> 00:15:19,306
But we can see it coming.

00:15:19,306 --> 00:15:20,730
John is right here.

00:15:20,730 --> 00:15:23,390
We're gonna have hundreds of GPUs or whatever

00:15:24,694 --> 00:15:26,620
and terabytes of GPU bar memory

00:15:26,620 --> 00:15:28,090
in ridiculous systems,

00:15:28,090 --> 00:15:31,090
so this is probably gonna end up being a problem in the end.

00:15:32,000 --> 00:15:33,502
Okay.

00:15:33,502 --> 00:15:35,110
- That's when we really can add to

00:15:35,110 --> 00:15:35,943
- Maybe one comment,

00:15:35,943 --> 00:15:37,730
like about the reducing.

00:15:37,730 --> 00:15:39,020
So, the probably with DAX,

00:15:39,020 --> 00:15:41,740
why it was difficult to get rid of struct page

00:15:41,740 --> 00:15:46,560
was that you have quite a bit of memory management code

00:15:46,560 --> 00:15:47,660
and block query code

00:15:47,660 --> 00:15:49,650
that are used to normal pages,

00:15:49,650 --> 00:15:51,850
and you need to reuse all those for DAX

00:15:51,850 --> 00:15:55,970
because persistent memory is just another kind of storage,

00:15:55,970 --> 00:15:57,490
so you basically want to behave it

00:15:57,490 --> 00:15:58,740
just like another SSD,

00:16:02,467 --> 00:16:04,500
and so, it's not obvious that the argument

00:16:04,500 --> 00:16:06,660
translates to what you need to do

00:16:06,660 --> 00:16:08,150
with P2P bars

00:16:08,150 --> 00:16:09,920
because there, you basically,

00:16:11,200 --> 00:16:13,180
the memory and the bar memory

00:16:13,180 --> 00:16:15,020
is going to be mostly contained

00:16:15,020 --> 00:16:16,490
within the drivers,

00:16:16,490 --> 00:16:17,860
as far as I understand.

00:16:17,860 --> 00:16:20,210
- No, it goes out to user space,

00:16:20,210 --> 00:16:22,200
it gets into a VMA,

00:16:22,200 --> 00:16:25,780
from a VMA it can touch all the MM stuff, theoretically,

00:16:28,270 --> 00:16:30,340
and we couldn't block it off in certain places,

00:16:30,340 --> 00:16:32,670
but as soon as you block something off,

00:16:32,670 --> 00:16:33,930
somebody else stands up and says,

00:16:33,930 --> 00:16:35,770
"oh, I really need that."

00:16:35,770 --> 00:16:36,977
- Yeah.

00:16:36,977 --> 00:16:39,030
- That might touch this memory in my process.

00:16:40,730 --> 00:16:41,580
- Well. - Okay.

00:16:41,580 --> 00:16:42,790
Yeah, I just wanted to point out

00:16:42,790 --> 00:16:44,440
what was the problem with DocSend.

00:16:44,440 --> 00:16:45,273
- I think you're right.

00:16:45,273 --> 00:16:46,500
I think it's a lot simpler.

00:16:48,142 --> 00:16:48,975
Oh, you wanna switch with it.

00:16:48,975 --> 00:16:50,573
I think it's a lot simpler

00:16:50,573 --> 00:16:51,770
than the DAX problem

00:16:51,770 --> 00:16:53,742
because we don't have a file,

00:16:53,742 --> 00:16:54,870
a file system's never gonna be working with these pages,

00:16:54,870 --> 00:16:56,261
as far as I know.

00:16:56,261 --> 00:16:58,769
I think we can say that with clarity, I hope.

00:16:58,769 --> 00:17:00,850
(laughing)

00:17:00,850 --> 00:17:01,683
I say that,

00:17:01,683 --> 00:17:02,516
but then I also have visions

00:17:02,516 --> 00:17:04,830
of someone using Fuse or something on these things,

00:17:04,830 --> 00:17:05,680
so I don't know.

00:17:07,310 --> 00:17:08,312
- [Dan] That was on camera.

00:17:08,312 --> 00:17:09,311
- That was on camera.

00:17:09,311 --> 00:17:10,316
Okay.

00:17:10,316 --> 00:17:13,090
(laughing)

00:17:13,090 --> 00:17:15,130
So, because we're using,

00:17:15,130 --> 00:17:17,330
I guess this whole conversation started

00:17:17,330 --> 00:17:18,570
is because we're using struct page,

00:17:18,570 --> 00:17:19,600
we have an uncertainty

00:17:19,600 --> 00:17:21,903
that we might not be able to create them,

00:17:21,903 --> 00:17:23,498
so we need to have some sort

00:17:23,498 --> 00:17:26,090
of mechanism for that administrator to say,

00:17:26,090 --> 00:17:28,580
"hey, I actually want to do peer to peer DMA

00:17:28,580 --> 00:17:29,560
"on these devices.

00:17:29,560 --> 00:17:30,393
"Turn it on,"

00:17:31,694 --> 00:17:34,840
and that is where we were kinda struggling recently.

00:17:34,840 --> 00:17:35,700
So, sysfs.

00:17:35,700 --> 00:17:36,890
I like the sysfs idea,

00:17:36,890 --> 00:17:39,010
of some sort of thing in the PCI core

00:17:39,010 --> 00:17:40,356
where you can say,

00:17:40,356 --> 00:17:42,294
"this guy's enabled for P2P,"

00:17:42,294 --> 00:17:44,770
and the drivers pick up on that

00:17:44,770 --> 00:17:46,710
and do the right thing,

00:17:46,710 --> 00:17:48,060
'cause the driver needs to be aware.

00:17:48,060 --> 00:17:49,940
It needs to know their struct pages

00:17:49,940 --> 00:17:51,980
and it needs to insert them in the VMAs

00:17:51,980 --> 00:17:53,460
using some other call,

00:17:53,460 --> 00:17:56,430
not ReMAP PFN, or IOR ReMAP PFN,

00:17:56,430 --> 00:17:58,670
or whatever we're using in the driver today.

00:18:01,740 --> 00:18:03,180
Yes?

00:18:03,180 --> 00:18:04,150
- Just a question.

00:18:04,150 --> 00:18:06,910
Do you want to map the page CPU accessible?

00:18:06,910 --> 00:18:08,610
The PC express bar? - Yes.

00:18:08,610 --> 00:18:11,810
- And do you want to do that for regular VMA,

00:18:11,810 --> 00:18:12,890
like anonymous VMA?

00:18:12,890 --> 00:18:13,760
- We're already doing that.

00:18:13,760 --> 00:18:15,100
This is how VFIO works,

00:18:15,100 --> 00:18:16,230
this is how RDMA works.

00:18:16,230 --> 00:18:18,450
You do mmap on their char devs

00:18:18,450 --> 00:18:19,750
and you get back bar pages.

00:18:19,750 --> 00:18:22,390
- Yeah, but so you do mmap of a device file?

00:18:22,390 --> 00:18:23,670
- Yes, mmap of a char dev

00:18:23,670 --> 00:18:25,590
is how I think all these flows work.

00:18:25,590 --> 00:18:27,840
- Yeah, so if it's mmap of a device file, then fine,

00:18:27,840 --> 00:18:30,140
but if you want to map these pages inside

00:18:30,140 --> 00:18:31,240
an anonymous VMA.

00:18:32,807 --> 00:18:34,110
Okay.

00:18:34,110 --> 00:18:34,980
- That's not the picture I put up, right?

00:18:34,980 --> 00:18:36,160
- Okay. - So, I understand

00:18:36,160 --> 00:18:38,700
that maybe GPU guys are more interested in that.

00:18:38,700 --> 00:18:39,533
I don't know.

00:18:39,533 --> 00:18:40,740
- No, no, no.

00:18:40,740 --> 00:18:41,738
We don't wanna do that

00:18:41,738 --> 00:18:42,940
because on PC express bar,

00:18:42,940 --> 00:18:43,773
on PC express,

00:18:43,773 --> 00:18:44,870
you don't have cache currency,

00:18:44,870 --> 00:18:46,370
you don't have, so it's undefined.

00:18:46,370 --> 00:18:48,700
If you do have a CPU automatic operation

00:18:48,700 --> 00:18:50,200
on a PC express bar,

00:18:50,200 --> 00:18:51,780
and if you go look at a specification

00:18:51,780 --> 00:18:52,613
of PC express bar,

00:18:52,613 --> 00:18:54,420
it specifically say it's undefined.

00:18:54,420 --> 00:18:55,910
The result is undefined.

00:18:55,910 --> 00:18:57,730
On some CPU, x86,

00:18:57,730 --> 00:18:58,950
some old x86,

00:18:58,950 --> 00:19:01,140
it's gonna actually lock up the full system,

00:19:01,140 --> 00:19:02,460
so you're gonna lose all your CPU,

00:19:02,460 --> 00:19:04,640
which means you lose all your routing system.

00:19:06,036 --> 00:19:07,800
- [Don] There's no collision between old x86

00:19:07,800 --> 00:19:09,300
and this technology. - Right.

00:19:09,300 --> 00:19:12,350
- This takes a very recent.

00:19:13,520 --> 00:19:15,767
Sorry, I'm holding the mic and I'm not even doing it.

00:19:15,767 --> 00:19:19,190
So, my argument is we don't have to worry about old x86

00:19:19,190 --> 00:19:21,350
because there is no old x86

00:19:21,350 --> 00:19:22,600
that this stuff is gonna work on.

00:19:22,600 --> 00:19:23,973
- It doesn't matter.

00:19:23,973 --> 00:19:25,990
We've been doing VFIO for a long, long time.

00:19:25,990 --> 00:19:27,450
RDMA's doing it for a long, long time.

00:19:27,450 --> 00:19:30,290
Bar, pages, un-cache-able memory bar pages

00:19:30,290 --> 00:19:31,750
and system processes,

00:19:31,750 --> 00:19:33,400
it is standard in kernel at this point.

00:19:33,400 --> 00:19:34,760
- Right, but that was another feature

00:19:34,760 --> 00:19:36,490
of the Zone Device,

00:19:36,490 --> 00:19:38,750
and it was that it tagged it

00:19:38,750 --> 00:19:41,840
as the same un-cache-able device memory space

00:19:41,840 --> 00:19:43,130
and had those attributes on there

00:19:43,130 --> 00:19:44,930
built into the whole thing.

00:19:44,930 --> 00:19:46,473
So again, thanks, Dan.

00:19:46,473 --> 00:19:47,600
(laughing)

00:19:47,600 --> 00:19:48,433
- Thanks, Dan.

00:19:49,272 --> 00:19:50,890
Okay.

00:19:50,890 --> 00:19:52,800
Well, does the audience have any opinion

00:19:52,800 --> 00:19:55,270
on how we should be configuring this?

00:19:55,270 --> 00:19:56,103
Any ideas?

00:19:57,769 --> 00:19:58,610
Like I said, I like the sysfs thing.

00:19:58,610 --> 00:19:59,966
It's new.

00:19:59,966 --> 00:20:01,330
We only thought about it yesterday.

00:20:01,330 --> 00:20:02,340
- Ioctl, no.

00:20:02,340 --> 00:20:03,590
Sysfs, yes.

00:20:03,590 --> 00:20:05,050
- Okay, there we go.

00:20:05,050 --> 00:20:06,210
Easy peasy. - There we go.

00:20:06,210 --> 00:20:07,043
- Look at that.

00:20:07,043 --> 00:20:08,729
Consensus. (laughing)

00:20:08,729 --> 00:20:09,728
- [Don] You're off the hook, Alex.

00:20:09,728 --> 00:20:10,875
- [Alex] Yay!

00:20:10,875 --> 00:20:12,260
(laughing)

00:20:12,260 --> 00:20:13,842
- Alex says, "yay."

00:20:13,842 --> 00:20:17,159
(microphone squealing)

00:20:17,159 --> 00:20:17,992
All right.

00:20:17,992 --> 00:20:18,890
Don't cross the streams.

00:20:18,890 --> 00:20:21,210
Don't look at the catch boxes.

00:20:23,480 --> 00:20:25,358
And the other thing, I wanted.

00:20:25,358 --> 00:20:26,357
(man speaking off mic)

00:20:26,357 --> 00:20:27,356
(laughing)

00:20:27,356 --> 00:20:28,189
The other thing I wanted to point out

00:20:28,189 --> 00:20:30,060
that I discovered last week

00:20:30,060 --> 00:20:33,160
is that VFIO already has a mechanism

00:20:33,160 --> 00:20:35,720
to do P2P, apparently,

00:20:35,720 --> 00:20:38,130
but it just doesn't worry about struct pages

00:20:38,130 --> 00:20:39,510
or safety or security,

00:20:39,510 --> 00:20:42,770
and it directly looks into the PFN map VMAs

00:20:42,770 --> 00:20:45,420
and just DMA maps, whatever's in there,

00:20:45,420 --> 00:20:49,066
which is so far from okay.

00:20:49,066 --> 00:20:50,300
(laughing)

00:20:50,300 --> 00:20:53,000
So, we already have a user in the kernel

00:20:53,000 --> 00:20:54,540
that needs this functionality

00:20:54,540 --> 00:20:56,590
that we're talking about for correctness.

00:20:58,140 --> 00:20:59,500
I think there's a very strong motivation

00:20:59,500 --> 00:21:00,800
to do all of these things.

00:21:01,650 --> 00:21:02,483
Okay, struct pages.

00:21:02,483 --> 00:21:03,840
So, where are we going next?

00:21:05,560 --> 00:21:10,240
So, here's the general sequence of things

00:21:10,240 --> 00:21:11,073
as I see it

00:21:11,073 --> 00:21:13,160
in terms of trying to get patches out there.

00:21:13,160 --> 00:21:15,290
So, Don is working on a VFIO patch

00:21:15,290 --> 00:21:19,170
to allow VFIO to do its bar pages

00:21:19,170 --> 00:21:21,550
with the device P2P.

00:21:21,550 --> 00:21:22,780
So, instead of PFN map,

00:21:22,780 --> 00:21:24,530
it switches to normal struct pages

00:21:24,530 --> 00:21:25,780
and their Zone Device,

00:21:25,780 --> 00:21:27,730
P2P DMA pages.

00:21:27,730 --> 00:21:29,910
RDMA is getting pretty close

00:21:29,910 --> 00:21:31,590
to being able to use hmm_range_fault

00:21:31,590 --> 00:21:32,690
for it's ODP thing,

00:21:33,680 --> 00:21:36,300
and there's more talking about this in the next section,

00:21:36,300 --> 00:21:38,090
but hmm_range_fault is kind of a parallel

00:21:38,090 --> 00:21:40,127
to get_user_pages.

00:21:40,127 --> 00:21:41,950
(man speaking off mic)

00:21:41,950 --> 00:21:43,157
Oh.

00:21:43,157 --> 00:21:44,080
Well, it is the RDMA mini conf.

00:21:44,080 --> 00:21:47,600
So ODP, for those of you not in the RDMA community,

00:21:47,600 --> 00:21:48,570
this is sort of

00:21:49,630 --> 00:21:51,610
a way to avoid page pinning.

00:21:51,610 --> 00:21:53,200
The device can take a fault

00:21:53,200 --> 00:21:54,540
when it wants to touch a page,

00:21:54,540 --> 00:21:56,350
if it's not been mapped to the device,

00:21:56,350 --> 00:21:57,700
which allows the CPU

00:21:57,700 --> 00:22:00,110
to re-map it at a new address,

00:22:00,110 --> 00:22:03,471
so the underlying VMA page mappings

00:22:03,471 --> 00:22:05,130
can change dynamically

00:22:05,130 --> 00:22:06,700
and the device can keep track of them.

00:22:06,700 --> 00:22:08,120
So in a practical sense,

00:22:08,120 --> 00:22:10,110
if you mmap something in your process,

00:22:10,110 --> 00:22:10,970
DMA to it,

00:22:10,970 --> 00:22:12,606
then M-un-map it,

00:22:12,606 --> 00:22:14,060
and M-re-map something else there,

00:22:14,060 --> 00:22:15,490
the DMA still works,

00:22:15,490 --> 00:22:18,320
which is not how RDMA has historically worked

00:22:18,320 --> 00:22:19,470
with its classical MRs.

00:22:20,910 --> 00:22:22,150
So with hmm_range_fault,

00:22:22,150 --> 00:22:24,520
we have this more contained

00:22:24,520 --> 00:22:26,251
get_user_pages that we could add in

00:22:26,251 --> 00:22:28,190
knowledge about device P2P.

00:22:28,190 --> 00:22:30,220
It already has knowledge about Zone Device pages.

00:22:30,220 --> 00:22:32,730
It can be enhanced a little bit more

00:22:32,730 --> 00:22:34,250
to support more cases,

00:22:36,188 --> 00:22:38,370
and then we would teach the RDMA driver

00:22:38,370 --> 00:22:40,490
how to understand whatever it's doing

00:22:40,490 --> 00:22:43,730
and I believe the IOMMU driver's already okay.

00:22:43,730 --> 00:22:45,180
People keep telling me they're okay.

00:22:45,180 --> 00:22:46,870
I think they're okay.

00:22:46,870 --> 00:22:49,160
And Logan tells me that we need

00:22:49,160 --> 00:22:50,781
a little more information

00:22:50,781 --> 00:22:54,059
to determine if the pair,

00:22:54,059 --> 00:22:57,310
if the source and target PCI device themselves

00:22:57,310 --> 00:22:59,070
are acceptable for P2P.

00:22:59,070 --> 00:23:02,340
So, this is does the interconnecting

00:23:02,340 --> 00:23:03,870
its path support P2P.

00:23:03,870 --> 00:23:05,620
- [Don] Yeah, it's distance call.

00:23:05,620 --> 00:23:07,730
- Yeah, it's Logan's distance call.

00:23:07,730 --> 00:23:09,640
- Yes, so for peer to peer,

00:23:09,640 --> 00:23:11,150
maybe there is one thing to say.

00:23:11,150 --> 00:23:13,230
You can, as we do, peer to peer

00:23:13,230 --> 00:23:14,580
from two PCX prized device

00:23:14,580 --> 00:23:17,120
by going to whatever interconnect you have

00:23:17,120 --> 00:23:18,320
on the tree on the express,

00:23:18,320 --> 00:23:20,100
but you can also do peer to peer

00:23:20,100 --> 00:23:22,000
by going back to the route,

00:23:22,000 --> 00:23:24,240
the route port, which is VIOMU,

00:23:24,240 --> 00:23:26,940
and I believe we want to spot both cases,

00:23:26,940 --> 00:23:28,480
and obviously, the fastest one

00:23:28,480 --> 00:23:29,990
is when you don't goo back to the root

00:23:29,990 --> 00:23:31,500
because then it's a bottleneck flow.

00:23:31,500 --> 00:23:33,173
- [Don] It's the least insecure.

00:23:33,173 --> 00:23:34,172
(laughing)

00:23:34,172 --> 00:23:35,930
- So, this has turn out to be a really complicated topic.

00:23:35,930 --> 00:23:37,310
- Sorry, I shouldn't say this out loud.

00:23:37,310 --> 00:23:39,370
So, when you don't go up to the root port,

00:23:39,370 --> 00:23:40,540
it's the least secure

00:23:40,540 --> 00:23:43,470
because you don't have something protecting (mumbling)

00:23:43,470 --> 00:23:44,650
- Right, so this has turned out

00:23:44,650 --> 00:23:46,170
to be a really complicated topic,

00:23:46,170 --> 00:23:48,590
and Logan, when he initially

00:23:48,590 --> 00:23:50,570
on his P2P patches, merged,

00:23:50,570 --> 00:23:52,230
this was the main point of contention

00:23:52,230 --> 00:23:53,510
about how exactly you're doing this,

00:23:53,510 --> 00:23:55,020
'cause he started very simple.

00:23:55,020 --> 00:23:57,194
The first draft of those patches

00:23:57,194 --> 00:23:59,010
required a PCI switch

00:23:59,010 --> 00:24:00,960
and required ACS to be disabled.

00:24:00,960 --> 00:24:01,793
So in this case,

00:24:01,793 --> 00:24:04,461
you could take the shortcut through the root,

00:24:04,461 --> 00:24:06,761
bypass the root complex,

00:24:06,761 --> 00:24:08,260
and the reason for this

00:24:08,260 --> 00:24:11,650
is that the room complex is in a lot of common CPUs

00:24:11,650 --> 00:24:12,980
don't do this very well.

00:24:12,980 --> 00:24:14,560
They're either performance limited,

00:24:14,560 --> 00:24:15,940
or they just crash, or whatever.

00:24:15,940 --> 00:24:17,500
- Or you just don't have the routes.

00:24:17,500 --> 00:24:18,340
- Or they don't have the routes,

00:24:18,340 --> 00:24:19,630
or it's all broken.

00:24:19,630 --> 00:24:21,120
So since then,

00:24:21,120 --> 00:24:23,480
I believe the core code for P2P has gained

00:24:23,480 --> 00:24:25,930
more and more knowledge about when it's okay to do this.

00:24:25,930 --> 00:24:28,110
So, there is a call that we can make

00:24:28,110 --> 00:24:30,980
if we know the initiating and terminating struct PCI device,

00:24:30,980 --> 00:24:32,585
we can make a call

00:24:32,585 --> 00:24:33,418
and say, "is this okay?

00:24:33,418 --> 00:24:34,251
"Yes or no?"

00:24:34,251 --> 00:24:35,084
If it is, then we can proceed,

00:24:35,084 --> 00:24:37,190
if it's not, we have to stop,

00:24:37,190 --> 00:24:39,540
like in the ODP case,

00:24:39,540 --> 00:24:42,200
we would return a permanent failure for those pages.

00:24:43,560 --> 00:24:45,400
So, hooking all this infrastructure up

00:24:45,400 --> 00:24:47,350
is like a big deal, too.

00:24:47,350 --> 00:24:49,280
This is why struct pages

00:24:49,280 --> 00:24:50,510
look like a reasonable starting point,

00:24:50,510 --> 00:24:52,950
as we can do all the other stuff on this list

00:24:52,950 --> 00:24:54,480
to even get us started,

00:24:54,480 --> 00:24:56,660
and then if we do wanna go back and remove the struct pages,

00:24:56,660 --> 00:24:58,270
we're looking at mainly removing,

00:24:58,270 --> 00:25:00,490
exchanging something in range_fault

00:25:00,490 --> 00:25:02,230
and changing something in the bar mapping

00:25:02,230 --> 00:25:03,860
that's hopefully been hoisted up

00:25:03,860 --> 00:25:04,970
into sub-system layers

00:25:04,970 --> 00:25:07,572
and there's maybe only a few of those.

00:25:07,572 --> 00:25:08,700
So, I see a pretty clear path

00:25:08,700 --> 00:25:11,699
where we can keep evolving this in small steps

00:25:11,699 --> 00:25:14,850
and the various people with various expertises,

00:25:14,850 --> 00:25:15,820
like the IOMMU teams

00:25:15,820 --> 00:25:18,020
and the PCI people

00:25:18,020 --> 00:25:19,540
can do their parts

00:25:19,540 --> 00:25:22,630
with actual testable user space.

00:25:23,490 --> 00:25:25,090
So, I think it's very important.

00:25:27,810 --> 00:25:28,710
Does this sort of?

00:25:31,870 --> 00:25:32,890
All clear for everyone?

00:25:32,890 --> 00:25:34,840
Or do we wanna talk about this anymore?

00:25:35,990 --> 00:25:36,823
All right.

00:25:37,740 --> 00:25:39,420
So, I'm glad the room is so quiet,

00:25:39,420 --> 00:25:41,470
'cause I think that means we're on the right track.

00:25:42,437 --> 00:25:43,270
- That or they haven't had enough caffeine.

00:25:43,270 --> 00:25:44,500
- That or there's not enough caffeine.

00:25:44,500 --> 00:25:46,830
There is caffeine fueling stations outside.

00:25:46,830 --> 00:25:48,150
You put in this weird little disk

00:25:48,150 --> 00:25:49,930
and it gives you this tiny cup of coffee.

00:25:49,930 --> 00:25:51,570
You're supposed to have three of them

00:25:51,570 --> 00:25:52,610
before you come to a session.

00:25:52,610 --> 00:25:53,898
Three.

00:25:53,898 --> 00:25:54,731
(laughing)

00:25:54,731 --> 00:25:55,898
Three.

00:25:55,898 --> 00:25:56,897
- [Dan] I'm gonna estimate strength.

00:25:56,897 --> 00:25:58,110
(laughing)

00:25:58,110 --> 00:25:59,428
- You're supposed to be vibrating.

00:25:59,428 --> 00:26:00,960
(laughing)

00:26:00,960 --> 00:26:02,290
Okay, so the next thing

00:26:02,290 --> 00:26:04,320
I wanted to use some of this time for

00:26:04,320 --> 00:26:06,881
before we go on to the next thing.

00:26:06,881 --> 00:26:08,490
- I was gonna ask you.

00:26:08,490 --> 00:26:11,490
Is anybody looking at any standardization efforts in PICI

00:26:11,490 --> 00:26:14,450
to say how to communicate peer to peer?

00:26:14,450 --> 00:26:15,283
- Yes.

00:26:15,283 --> 00:26:17,504
I am not on the PCI sig,

00:26:17,504 --> 00:26:18,540
but I have heard fourth hand,

00:26:18,540 --> 00:26:21,580
the PCI sig has some work ongoing

00:26:21,580 --> 00:26:23,980
to define when, I think,

00:26:23,980 --> 00:26:27,270
it's when the host bridge will support this, I think.

00:26:27,270 --> 00:26:29,150
- Yeah, so they are gonna add,

00:26:30,907 --> 00:26:33,080
I don't know how many beat to the PCI express config,

00:26:33,080 --> 00:26:34,340
and VSV is gonna be monetary,

00:26:34,340 --> 00:26:36,380
so I don't know why

00:26:36,380 --> 00:26:37,820
we're talking about adding beats,

00:26:37,820 --> 00:26:39,970
but really, an AMI device can do peer to peer

00:26:39,970 --> 00:26:42,070
and my PC express can do bridges,

00:26:42,070 --> 00:26:44,250
because really, what matters is all the bridge

00:26:44,250 --> 00:26:48,390
between your device and whatever rows of device it might be,

00:26:48,390 --> 00:26:50,330
and those, basically, sometimes we do support it,

00:26:50,330 --> 00:26:51,310
sometimes we don't support it,

00:26:51,310 --> 00:26:52,160
and sometimes it depends

00:26:52,160 --> 00:26:54,730
on how the BIOS actually configure them,

00:26:54,730 --> 00:26:56,820
so we have a working group on that,

00:26:56,820 --> 00:27:00,020
and we're gonna deliver the report

00:27:00,020 --> 00:27:02,600
with a very support peer to peer note.

00:27:02,600 --> 00:27:03,600
- So, this will be real exciting.

00:27:03,600 --> 00:27:05,310
This will improve the PCI part,

00:27:05,310 --> 00:27:06,510
the distance calculation

00:27:07,358 --> 00:27:08,191
that was talked about earlier,

00:27:08,191 --> 00:27:09,800
and the distance calculator will be able to go in

00:27:09,800 --> 00:27:12,140
and use standard PCI config space to tell

00:27:12,140 --> 00:27:13,340
if it's okay or not.

00:27:13,340 --> 00:27:15,900
I think the direction it's going right now,

00:27:15,900 --> 00:27:17,670
at least as an interim in the kernel,

00:27:17,670 --> 00:27:18,770
there's some kind of white list

00:27:18,770 --> 00:27:20,920
that says, "these host bridges are okay,

00:27:20,920 --> 00:27:22,520
"these configurations are okay."

00:27:24,580 --> 00:27:26,380
- So, you keep talking about distance.

00:27:26,380 --> 00:27:28,420
It's not really that distance that matters though,

00:27:28,420 --> 00:27:29,780
it's that the path supports it.

00:27:29,780 --> 00:27:30,850
- Yeah, this is right. - Right,

00:27:30,850 --> 00:27:32,960
but that's what Logan called the function,

00:27:32,960 --> 00:27:34,593
so we referred. - But is there a reason

00:27:34,593 --> 00:27:36,300
it's called distance?

00:27:36,300 --> 00:27:37,938
Is there a performance issue

00:27:37,938 --> 00:27:39,970
with how far it is? - I think,

00:27:41,050 --> 00:27:42,580
someone can correct me if they remember the patches,

00:27:42,580 --> 00:27:45,694
but he was more worried about something simple

00:27:45,694 --> 00:27:48,470
and wondering what the distance was,

00:27:49,421 --> 00:27:51,170
and then distance got morphed into a check.

00:27:51,170 --> 00:27:52,580
- Yeah, I think that's true. - He ran

00:27:52,580 --> 00:27:55,060
into the ACS issues. - Okay.

00:27:55,060 --> 00:27:56,670
- So, he just overloaded. - I'm just

00:27:56,670 --> 00:27:57,730
trying to understand.

00:27:57,730 --> 00:28:00,270
- Yeah, we should probably create a new function

00:28:00,270 --> 00:28:01,460
that's a little more descriptive.

00:28:01,460 --> 00:28:02,293
- I think so.

00:28:02,293 --> 00:28:04,210
It would be nice if it was path enabled, right?

00:28:04,210 --> 00:28:05,970
You need a path record, man.

00:28:05,970 --> 00:28:08,275
See, we're never gonna communicate.

00:28:08,275 --> 00:28:10,920
- So anyhow, I think that's what it is,

00:28:10,920 --> 00:28:12,630
but Logan's not here, again.

00:28:12,630 --> 00:28:13,880
- It would be nice if he were here

00:28:13,880 --> 00:28:15,578
'cause he would explain this,

00:28:15,578 --> 00:28:18,178
but I wanna say, the way it was set up in the kernel

00:28:20,080 --> 00:28:24,770
involved using basically two MVME drivers

00:28:26,064 --> 00:28:27,160
The use case he was targeting

00:28:27,160 --> 00:28:29,540
is that you can have an MVME over PCI driver

00:28:29,540 --> 00:28:31,620
and an MVME over RDMA driver

00:28:31,620 --> 00:28:32,950
in the kernel,

00:28:32,950 --> 00:28:35,090
and they could somehow realize

00:28:35,090 --> 00:28:36,260
that they're talking to each other

00:28:36,260 --> 00:28:38,850
and they could allocate the transfer memory

00:28:38,850 --> 00:28:40,640
from the CMV of the PCI device.

00:28:40,640 --> 00:28:42,530
So, what he was attempting to do

00:28:42,530 --> 00:28:45,790
was I would do a transfer

00:28:45,790 --> 00:28:49,630
between my MVME over fabrics

00:28:49,630 --> 00:28:51,870
and my MVME on PCI,

00:28:51,870 --> 00:28:53,390
and it would bypass the system memory.

00:28:53,390 --> 00:28:56,000
The transfer would simply go into the CMB

00:28:56,000 --> 00:28:57,520
and then the device would execute it locally.

00:28:57,520 --> 00:28:59,710
So in that sense,

00:28:59,710 --> 00:29:01,000
distance made some sense

00:29:01,000 --> 00:29:03,530
because you wanna choose the CMB

00:29:03,530 --> 00:29:06,030
that's local to your RDMA device

00:29:06,030 --> 00:29:07,500
if you have multiple RDMA devices

00:29:07,500 --> 00:29:09,190
and multiple MVME drives,

00:29:09,190 --> 00:29:10,610
as systems tend to do,

00:29:10,610 --> 00:29:12,880
on multiple sockets with multiple switches,

00:29:12,880 --> 00:29:15,636
you kinda wanna have a concept of distance,

00:29:15,636 --> 00:29:18,630
but that's not where we are.

00:29:18,630 --> 00:29:22,130
We're not using that allocator thing

00:29:22,130 --> 00:29:22,963
that's in the kernel,

00:29:22,963 --> 00:29:24,630
the gen_alloc part of the P2P DMA

00:29:24,630 --> 00:29:27,430
because we assign them a user space

00:29:27,430 --> 00:29:29,870
and user space is responsible for plumbing them together,

00:29:29,870 --> 00:29:30,850
and they actually are different.

00:29:30,850 --> 00:29:32,420
It's not just CMB memory,

00:29:32,420 --> 00:29:33,720
which is kind of interchangeable.

00:29:33,720 --> 00:29:36,730
These are like registered bars from VFIO

00:29:36,730 --> 00:29:39,330
or UAR bars, doorbell bars,

00:29:39,330 --> 00:29:41,030
and RDMA NIC

00:29:41,030 --> 00:29:42,570
is actually really, really special

00:29:42,570 --> 00:29:45,650
and you can't interchange them,

00:29:45,650 --> 00:29:48,290
but yeah, I think we'll have some new APIs coming here.

00:29:48,290 --> 00:29:50,160
I think it's necessary.

00:29:50,160 --> 00:29:52,700
I just view this as the normal evolution.

00:29:52,700 --> 00:29:53,533
Sorry.

00:29:53,533 --> 00:29:54,870
- Yeah, so I just wanted to say

00:29:54,870 --> 00:29:56,830
I think the original distance calculation

00:29:56,830 --> 00:30:00,150
had how many bridges and switches were in between?

00:30:00,150 --> 00:30:03,490
So, it was more about which peer was closest,

00:30:03,490 --> 00:30:05,370
and more about a wait

00:30:05,370 --> 00:30:10,370
for waiting which bar you wanted to go to instead,

00:30:11,380 --> 00:30:14,150
assuming you had two interchangeable bars, basically.

00:30:14,150 --> 00:30:15,360
- [Jason] Yeah, I think so.

00:30:16,220 --> 00:30:18,664
- [Don] Yeah, so I think what happened

00:30:18,664 --> 00:30:20,312
is if you didn't have a distance,

00:30:20,312 --> 00:30:22,042
then that meant you couldn't get to it,

00:30:22,042 --> 00:30:23,930
so that became the default check.

00:30:23,930 --> 00:30:24,960
- That's how it kinda worked.

00:30:24,960 --> 00:30:27,300
- [Don] No distance means no connection.

00:30:27,300 --> 00:30:29,090
- It's also a little bit more complicated.

00:30:29,090 --> 00:30:31,520
There's a lot of complicated bits in here

00:30:31,520 --> 00:30:33,680
because you have to compute a dma_addr_t

00:30:34,570 --> 00:30:36,670
and you're starting from the bars,

00:30:36,670 --> 00:30:39,727
a phys_addr_t is for the bar, essentially,

00:30:39,727 --> 00:30:42,440
which is a CPU view of the way the bar

00:30:42,440 --> 00:30:45,230
has been realized into the CPU's memory map,

00:30:45,230 --> 00:30:46,960
and the PCI layer supports a lot

00:30:46,960 --> 00:30:48,230
of translation here,

00:30:48,230 --> 00:30:50,910
so the physical address,

00:30:50,910 --> 00:30:52,020
even when you're not using IOMMUs,

00:30:52,020 --> 00:30:53,120
even when you're going

00:30:54,697 --> 00:30:56,190
through a bridge,

00:30:56,190 --> 00:30:57,670
the DMA address and the physical address

00:30:57,670 --> 00:30:59,410
are not necessarily the same,

00:30:59,410 --> 00:31:01,970
so you do actually need to know

00:31:03,140 --> 00:31:05,310
the two struct devices that are inter-working here

00:31:05,310 --> 00:31:07,375
so that you can calculate

00:31:07,375 --> 00:31:08,208
all these adjustments,

00:31:08,208 --> 00:31:10,069
even when you're not using IOMMUs,

00:31:10,069 --> 00:31:11,230
and when you are using IOMMUs,

00:31:11,230 --> 00:31:13,460
I assume the IOMMU has to know it, as well,

00:31:13,460 --> 00:31:15,850
to make an adjustment somehow,

00:31:15,850 --> 00:31:17,600
or maybe it's wired

00:31:17,600 --> 00:31:19,670
so it can work with the phys_addr_t.

00:31:19,670 --> 00:31:20,680
I think that's the case today

00:31:20,680 --> 00:31:22,770
is all the IOMMU systems

00:31:22,770 --> 00:31:23,830
can work with the phys_addr_t

00:31:23,830 --> 00:31:25,880
and the phys_addr_t is sort of one to one

00:31:27,095 --> 00:31:29,090
with the dma_addr_t, for bars at least,

00:31:30,289 --> 00:31:32,360
but there's armed systems where that's not true,

00:31:32,360 --> 00:31:33,530
especially embedded systems

00:31:33,530 --> 00:31:35,150
with crazy and broken PCI.

00:31:36,677 --> 00:31:38,150
All right.

00:31:38,150 --> 00:31:39,390
Clear as mud?

00:31:39,390 --> 00:31:40,223
(laughing)

00:31:40,223 --> 00:31:41,056
Okay.

00:31:43,284 --> 00:31:45,027
So, the next little couple of

00:31:45,027 --> 00:31:46,170
(man speaking off mic)

00:31:46,170 --> 00:31:48,150
Yeah, the details are endless here.

00:31:49,100 --> 00:31:51,310
So, next couple of slides are about hmm_range_fault,

00:31:51,310 --> 00:31:52,910
and this is just to kind of talk

00:31:53,955 --> 00:31:55,380
about for the RDMA perspective

00:31:55,380 --> 00:31:56,915
what we're already doing.

00:31:56,915 --> 00:31:57,870
So, we're continuing on Jerome's work

00:31:57,870 --> 00:32:01,150
to get RDMA ODP and hmm integrated

00:32:01,150 --> 00:32:03,490
so that RDMA ODP is a lot more

00:32:03,490 --> 00:32:05,500
like, say, the nouveau driver

00:32:05,500 --> 00:32:07,470
in the way it operates the mm.

00:32:07,470 --> 00:32:11,000
So, this gives us all the common code in the mm

00:32:11,000 --> 00:32:14,300
that's handling this particular use case,

00:32:14,300 --> 00:32:17,012
and if anyone saw my talk on Monday

00:32:17,012 --> 00:32:18,190
about the challenges we have in RDMA

00:32:18,190 --> 00:32:20,950
and other sub-systems, like GPU,

00:32:20,950 --> 00:32:23,570
is that the get_user_pages

00:32:23,570 --> 00:32:25,770
is really not adequate,

00:32:25,770 --> 00:32:28,912
and we need some more different API.

00:32:28,912 --> 00:32:30,944
So, this is kind of the first walking steps

00:32:30,944 --> 00:32:31,940
of giving us these common APIs

00:32:31,940 --> 00:32:34,590
so that they can move ahead.

00:32:34,590 --> 00:32:36,510
So, everybody's kind of aware

00:32:36,510 --> 00:32:37,480
of how this works.

00:32:39,910 --> 00:32:42,010
The main differences between the two APIs,

00:32:42,935 --> 00:32:45,210
and they have a very similar purpose,

00:32:45,210 --> 00:32:48,810
is that the hmm flavor

00:32:48,810 --> 00:32:49,850
is working with phys_addr_t

00:32:49,850 --> 00:32:51,080
instead of struct pages.

00:32:51,080 --> 00:32:52,670
So, this is like this micro step

00:32:52,670 --> 00:32:53,840
to getting rid of struct pages,

00:32:53,840 --> 00:32:56,770
as the new APIs are trying to avoid having struct pages.

00:32:56,770 --> 00:32:58,750
Now that said, most of the people

00:32:58,750 --> 00:33:01,000
who are using the hmm_range_fault today,

00:33:01,000 --> 00:33:03,240
just turn around and get the struct pages anyway

00:33:03,240 --> 00:33:06,060
because they need them for Zone Device stuff,

00:33:06,990 --> 00:33:09,520
particularly device private for the GPU drivers;

00:33:09,520 --> 00:33:10,750
and then, we were talking about P2P.

00:33:10,750 --> 00:33:13,840
We'll need to go to get the P2P information,

00:33:13,840 --> 00:33:16,610
but perhaps there's alternatives there down the road.

00:33:16,610 --> 00:33:17,560
I can't really say.

00:33:18,860 --> 00:33:22,120
And it's got a whole bunch of special properties.

00:33:22,980 --> 00:33:25,280
I hope we're getting

00:33:25,280 --> 00:33:26,930
maybe a couple months away

00:33:26,930 --> 00:33:29,460
to actually having this all finished and merged.

00:33:29,460 --> 00:33:31,040
It turns out to be a lot of patches,

00:33:31,040 --> 00:33:34,260
and ODP is really, really broken,

00:33:34,260 --> 00:33:36,320
so it'd have to get fixed first,

00:33:36,320 --> 00:33:37,970
which I think I'm almost done on,

00:33:39,220 --> 00:33:40,070
but this has been

00:33:40,960 --> 00:33:43,870
a big, big pow wow from a lot of people contributing

00:33:43,870 --> 00:33:46,360
and Christoph Hellwig's name is there, too.

00:33:46,360 --> 00:33:48,270
He's been a big help, I think.

00:33:48,270 --> 00:33:49,970
He also isn't here, unfortunately.

00:33:54,397 --> 00:33:55,830
So, this is where we wanted to get to

00:33:55,830 --> 00:33:56,663
for the GPU side,

00:33:56,663 --> 00:33:57,950
and this is Jerome's concept

00:33:59,088 --> 00:34:01,040
of when somebody wants to do DMA to a page,

00:34:01,040 --> 00:34:02,790
we can treat it differently

00:34:02,790 --> 00:34:05,200
than just wanting CPU access to the page,

00:34:06,483 --> 00:34:08,930
and can have this idea that we can then take a DMA fault

00:34:08,930 --> 00:34:10,860
in kind of the mm area,

00:34:10,860 --> 00:34:13,739
and I think we even have a call back for this already

00:34:13,739 --> 00:34:15,940
in the device private stuff,

00:34:17,090 --> 00:34:18,500
and the concept of a DMA fault

00:34:18,500 --> 00:34:21,510
is it may not make the page accessible to the CPU,

00:34:21,510 --> 00:34:24,000
but it does make it accessible for DMA,

00:34:24,000 --> 00:34:26,470
and the key distinction there

00:34:26,470 --> 00:34:29,080
is what Jerome was talking about before about atomics.

00:34:29,080 --> 00:34:31,740
So, a page that's accessible for DMA

00:34:31,740 --> 00:34:33,600
is obviously accessible through the CPU.

00:34:33,600 --> 00:34:36,260
That's obvious, I think,

00:34:36,260 --> 00:34:37,510
but it may be a bar page

00:34:37,510 --> 00:34:38,730
and it may not support atomics,

00:34:38,730 --> 00:34:39,880
and may not be cache coherent,

00:34:39,880 --> 00:34:41,600
and it may not actually be something

00:34:41,600 --> 00:34:42,870
you want the CPU to touch

00:34:42,870 --> 00:34:43,703
in user space

00:34:43,703 --> 00:34:46,100
because it breaks the programming model.

00:34:46,100 --> 00:34:48,120
So, this sort of in between state

00:34:48,120 --> 00:34:50,180
where a page is still inaccessible

00:34:50,180 --> 00:34:51,380
in the CPU page tables,

00:34:51,380 --> 00:34:53,810
but is DMA-able,

00:34:53,810 --> 00:34:55,960
is his new concept, I think, in the kernel.

00:34:58,028 --> 00:35:02,220
So, this is tied into the P2P DMA stuff

00:35:02,220 --> 00:35:06,340
because essentially, it has pages

00:35:06,340 --> 00:35:08,570
that are always gonna return themselves

00:35:08,570 --> 00:35:09,990
when they DMA fault, essentially,

00:35:09,990 --> 00:35:11,520
is a way to think about it,

00:35:11,520 --> 00:35:12,450
at least conceptually

00:35:12,450 --> 00:35:14,603
for how this fits into the mm,

00:35:17,675 --> 00:35:19,230
and I think people keep telling me,

00:35:19,230 --> 00:35:20,270
I don't know anything about GPUs,

00:35:20,270 --> 00:35:21,850
but people keep telling me the GPUs

00:35:21,850 --> 00:35:22,770
have dynamic bars

00:35:22,770 --> 00:35:24,550
and they need to do all kinds of work

00:35:24,550 --> 00:35:27,000
when they do their faults.

00:35:27,850 --> 00:35:29,660
- Would you actually make it accessible?

00:35:29,660 --> 00:35:32,380
I thought the bar could still be mapped un-cache-able.

00:35:32,380 --> 00:35:34,680
CPU could do slow stuff to it,

00:35:34,680 --> 00:35:35,700
but you'd actually fault it

00:35:35,700 --> 00:35:38,020
or SIGBUS the application if it tried to cache?

00:35:38,020 --> 00:35:39,060
- You'd have to fault it back.

00:35:39,060 --> 00:35:41,630
For the GPU case, you'd have to fault it back to the CPU.

00:35:41,630 --> 00:35:43,483
- No, I'm saying in the general case

00:35:43,483 --> 00:35:46,440
of the MVME bar target. - Yeah.

00:35:46,440 --> 00:35:48,230
Okay, so in the general case,

00:35:48,230 --> 00:35:50,410
we can map a bar

00:35:50,410 --> 00:35:51,950
on a device in two ways.

00:35:51,950 --> 00:35:52,783
We can map it

00:35:53,789 --> 00:35:56,510
as you did an mmap on at device file,

00:35:56,510 --> 00:35:57,370
like Jerome was talking about.

00:35:57,370 --> 00:35:58,972
In this case,

00:35:58,972 --> 00:35:59,805
you get un-cached bar memory,

00:35:59,805 --> 00:36:01,320
or maybe write combining bar memory,

00:36:01,320 --> 00:36:03,550
and you, the application, understand

00:36:03,550 --> 00:36:06,180
that it's un-cached write combining bar memory

00:36:06,180 --> 00:36:07,670
and you're not gonna put bars in it,

00:36:07,670 --> 00:36:08,810
you're not gonna use atomics on it

00:36:08,810 --> 00:36:10,560
because that doesn't work.

00:36:10,560 --> 00:36:12,120
That's the easy, easy case.

00:36:12,120 --> 00:36:14,340
The more complicated case is the GPU case

00:36:14,340 --> 00:36:18,560
where memory is moving between GPUs inside

00:36:18,560 --> 00:36:19,730
and bar mapped,

00:36:19,730 --> 00:36:21,180
and all over the system.

00:36:21,180 --> 00:36:22,471
In this case,

00:36:22,471 --> 00:36:25,130
the application doesn't know

00:36:25,130 --> 00:36:26,090
that it's bar mapped,

00:36:26,090 --> 00:36:27,610
and it has its assumption

00:36:27,610 --> 00:36:29,940
that it's CPU memory with cache-ability

00:36:29,940 --> 00:36:32,910
that can have spin locks and everything.

00:36:32,910 --> 00:36:34,730
So, you need to keep that illusion up,

00:36:34,730 --> 00:36:37,740
even though it might be bar mapped

00:36:37,740 --> 00:36:38,800
at a certain moment.

00:36:38,800 --> 00:36:41,823
John should talk about this, not me.

00:36:41,823 --> 00:36:44,223
- We have a programming model

00:36:44,223 --> 00:36:47,180
that's, how to say this,

00:36:47,180 --> 00:36:48,732
generally we said, "okay,

00:36:48,732 --> 00:36:51,940
"we just migrate memory back and forth," right?

00:36:51,940 --> 00:36:54,750
So, it's either accessible on the GPU,

00:36:54,750 --> 00:36:57,480
in which case it's marked device private

00:36:57,480 --> 00:37:00,510
and that means un-mapped on the CPU side.

00:37:00,510 --> 00:37:02,140
One or the other.

00:37:02,140 --> 00:37:04,070
Or if you can't migrate to the GPU,

00:37:04,070 --> 00:37:05,410
you just leave it on the CPU

00:37:05,410 --> 00:37:07,730
and have the GPU's page tables point to sysbin,

00:37:07,730 --> 00:37:09,920
and okay, lined,

00:37:09,920 --> 00:37:10,890
but what you don't do

00:37:10,890 --> 00:37:12,060
is you don't say, "okay,

00:37:12,060 --> 00:37:13,540
"I'm not gonna do that.

00:37:13,540 --> 00:37:14,670
"I'll just go through the bar mappings,"

00:37:14,670 --> 00:37:17,370
because those are not coherent

00:37:17,370 --> 00:37:19,310
with the programming.

00:37:19,310 --> 00:37:21,858
The little program that you wrote to run on your GPU

00:37:21,858 --> 00:37:24,840
is not coherent with the accesses

00:37:24,840 --> 00:37:25,760
through the bar,

00:37:25,760 --> 00:37:27,720
and so that whole programming model doesn't work,

00:37:27,720 --> 00:37:29,084
so we just said, "no."

00:37:29,084 --> 00:37:31,850
So, the goal here

00:37:31,850 --> 00:37:33,330
is to have a programming model

00:37:33,330 --> 00:37:34,930
where you use the same virtual address

00:37:34,930 --> 00:37:36,415
to refer to the same memory everywhere,

00:37:36,415 --> 00:37:37,810
and so that's why

00:37:37,810 --> 00:37:40,664
we locked that out.

00:37:40,664 --> 00:37:41,960
Does that make sense?

00:37:41,960 --> 00:37:43,090
- All right, John,

00:37:43,090 --> 00:37:44,089
I think it's your turn.

00:37:44,089 --> 00:37:45,435
(laughing)

00:37:45,435 --> 00:37:46,434
- Good timing.

00:37:46,434 --> 00:37:47,439
- We're running a little long here,

00:37:47,439 --> 00:37:48,811
so John, we're gonna skip a few slides.

00:37:48,811 --> 00:37:50,289
- Oh, okay.

00:37:50,289 --> 00:37:52,956
(quiet chatter)

00:37:57,950 --> 00:38:01,910
Okay, so I was kinda tossed into this

00:38:01,910 --> 00:38:05,690
just to give you another facet of this,

00:38:05,690 --> 00:38:07,652
which is the get_user_pages part,

00:38:07,652 --> 00:38:09,290
and the thing here

00:38:09,290 --> 00:38:12,010
is we're proposing all this new behavior

00:38:12,950 --> 00:38:17,090
for mainly get_user_pages,

00:38:17,090 --> 00:38:18,310
and we're stacking on top

00:38:18,310 --> 00:38:21,540
of a very large, complex system.

00:38:21,540 --> 00:38:24,800
So, we find we can't just pop up

00:38:24,800 --> 00:38:25,990
and say, "okay,

00:38:25,990 --> 00:38:27,900
"we've got all this new peer to peer stuff,

00:38:27,900 --> 00:38:31,270
"we wanna have all these that Jason has been talking about,

00:38:31,270 --> 00:38:32,540
"all this new behavior,"

00:38:32,540 --> 00:38:34,330
but we're sitting on top of this,

00:38:34,330 --> 00:38:37,130
I'm abbreviating get_user_pages as GUP,

00:38:38,020 --> 00:38:40,420
we've got maybe 100 call sites,

00:38:40,420 --> 00:38:41,920
depending on how you count it,

00:38:43,030 --> 00:38:45,860
where people are calling get_user_pages.

00:38:45,860 --> 00:38:47,680
We've got 17 plus,

00:38:47,680 --> 00:38:50,140
the plus means that I've submitted a patch

00:38:50,140 --> 00:38:51,779
to add more flags.

00:38:51,779 --> 00:38:54,710
(laughing)

00:38:54,710 --> 00:38:55,650
Flags.

00:38:55,650 --> 00:38:58,250
You'll see 'em in the next slides.

00:38:58,250 --> 00:38:59,430
So, there's an awful lot of stuff there,

00:38:59,430 --> 00:39:01,560
and then we've got 10 or 15 API calls.

00:39:01,560 --> 00:39:03,911
I've got a nice little slide coming up

00:39:03,911 --> 00:39:06,070
where I show how it kinda multiplies out,

00:39:06,070 --> 00:39:07,840
and so this is a complicated thing;

00:39:08,850 --> 00:39:09,980
and then worse,

00:39:11,045 --> 00:39:13,390
get_user_pages was originally,

00:39:13,390 --> 00:39:14,440
and you can correct me,

00:39:14,440 --> 00:39:16,790
I don't know the history all that well,

00:39:16,790 --> 00:39:20,120
but it seems to me that it was originally an mm idea,

00:39:21,050 --> 00:39:22,660
certainly when I talked to file systems guys

00:39:22,660 --> 00:39:24,510
that it feels that way,

00:39:24,510 --> 00:39:27,070
and it's unaware of file systems,

00:39:27,070 --> 00:39:28,990
device pages, certainly peer to peer,

00:39:30,370 --> 00:39:33,160
and in fact, we had a fun conversation last night

00:39:33,160 --> 00:39:34,519
where we were saying,

00:39:34,519 --> 00:39:37,840
"nobody understands what get_user_pages really promises.

00:39:37,840 --> 00:39:39,810
"It's really a weak promise."

00:39:39,810 --> 00:39:40,860
Another way of saying that

00:39:40,860 --> 00:39:44,390
is it makes a promise that is so ridiculously weak

00:39:44,390 --> 00:39:46,720
that no reasonable human that looked at it

00:39:46,720 --> 00:39:47,760
would believe the promise.

00:39:47,760 --> 00:39:48,610
They would say,

00:39:48,610 --> 00:39:49,600
"that's so stupid.

00:39:49,600 --> 00:39:51,157
"It's useless.

00:39:51,157 --> 00:39:51,990
"Nobody would build that.

00:39:51,990 --> 00:39:53,320
"Obviously, they must mean more,

00:39:53,320 --> 00:39:55,731
"so I'll stack my house of cards here,"

00:39:55,731 --> 00:39:56,640
(chuckling)

00:39:56,640 --> 00:39:58,564
and that's what happened throughout.

00:39:58,564 --> 00:40:01,390
It makes a really weak promise

00:40:02,410 --> 00:40:03,610
and people needed more,

00:40:03,610 --> 00:40:05,090
and they built stuff on top of it,

00:40:05,090 --> 00:40:06,410
and 10 years later, people looked around

00:40:06,410 --> 00:40:09,680
and said, "all these interactions

00:40:09,680 --> 00:40:12,390
"between you using get_user_pages to pen memory,

00:40:12,390 --> 00:40:15,880
"and things called file systems are broken,"

00:40:15,880 --> 00:40:18,750
and somebody, when I was at LSFMM

00:40:19,762 --> 00:40:21,180
a year or two ago,

00:40:21,180 --> 00:40:22,400
while I was at the conference,

00:40:22,400 --> 00:40:24,250
somebody filed a bug at Nvidia

00:40:24,250 --> 00:40:25,813
that said, "hey,

00:40:25,813 --> 00:40:26,646
"we've got this funny thing.

00:40:28,997 --> 00:40:29,830
"It just breaks,"

00:40:29,830 --> 00:40:30,663
and it was this problem,

00:40:30,663 --> 00:40:31,640
and so here I am.

00:40:32,480 --> 00:40:33,930
So, let me get another slide.

00:40:36,770 --> 00:40:37,603
Right.

00:40:37,603 --> 00:40:40,000
So, this helps me a little bit.

00:40:40,000 --> 00:40:41,010
All of these,

00:40:41,010 --> 00:40:43,100
if you capitalize and put the words

00:40:43,100 --> 00:40:44,640
F-O-L-L underscore in front,

00:40:44,640 --> 00:40:46,680
so like follow split, follow populate,

00:40:46,680 --> 00:40:49,020
those are all get_user_pages flags.

00:40:49,020 --> 00:40:50,790
So, at your call sites,

00:40:50,790 --> 00:40:52,890
you can set these flags.

00:40:52,890 --> 00:40:54,304
Set as many as you want.

00:40:54,304 --> 00:40:56,554
(laughing)

00:40:58,180 --> 00:40:59,290
- [Man] Even conflicting ones.

00:40:59,290 --> 00:41:02,210
- Really, there's not a lot of rules out there,

00:41:02,210 --> 00:41:04,420
and then you can call all these different APIs,

00:41:04,420 --> 00:41:05,690
so if you multiply them all together,

00:41:05,690 --> 00:41:07,680
it's a really large number,

00:41:07,680 --> 00:41:10,480
and the part that I really enjoy

00:41:10,480 --> 00:41:12,610
is that you can say, "okay,

00:41:12,610 --> 00:41:15,090
"follow split and follow mlock and touch,

00:41:15,090 --> 00:41:16,120
"and maybe populate,

00:41:17,669 --> 00:41:19,740
"and I'd like a little follow long-term with that,

00:41:19,740 --> 00:41:20,740
"and I'm gonna call,

00:41:21,580 --> 00:41:23,590
"yeah, I'll call get_user_pages,"

00:41:23,590 --> 00:41:26,290
which in turn calls another one that's exposed.

00:41:27,130 --> 00:41:29,020
Follow page can be called separately,

00:41:29,020 --> 00:41:30,220
but it's also called

00:41:31,225 --> 00:41:33,180
by get_user_pages itself.

00:41:33,180 --> 00:41:35,560
So, it's really out of hand.

00:41:35,560 --> 00:41:37,480
Then, if I say, "quick,

00:41:37,480 --> 00:41:39,550
"tell me, are these pages pinned?

00:41:40,980 --> 00:41:42,120
"Quick, answer.

00:41:42,120 --> 00:41:43,120
"Well, okay.

00:41:43,120 --> 00:41:43,953
"Let me check.

00:41:43,953 --> 00:41:45,060
"does follow split pin the page?

00:41:45,060 --> 00:41:45,893
"No, it doesn't.

00:41:47,272 --> 00:41:49,050
"How about if I say populate?

00:41:49,050 --> 00:41:50,300
"Okay, well, that sets follow get,

00:41:50,300 --> 00:41:51,650
"which usually means

00:41:51,650 --> 00:41:53,160
"that it's gonna work its way down to here

00:41:53,160 --> 00:41:54,360
"and pin the page.

00:41:54,360 --> 00:41:55,560
"Okay, great so far."

00:41:55,560 --> 00:41:57,100
So, it's really hard,

00:41:57,100 --> 00:41:58,770
and if you change it or use it

00:41:59,810 --> 00:42:00,643
in new ways,

00:42:00,643 --> 00:42:02,800
like peer to peer and all this other stuff,

00:42:02,800 --> 00:42:04,132
you're gonna find

00:42:04,132 --> 00:42:06,180
that it becomes almost impossible

00:42:06,180 --> 00:42:07,013
to get it right.

00:42:10,417 --> 00:42:12,040
Of course, we wanna add new things here,

00:42:12,040 --> 00:42:13,790
like get_user_bvec,

00:42:13,790 --> 00:42:17,810
so instead of dealing with struct pages,

00:42:17,810 --> 00:42:21,520
it'd be nice to deal with bio vecs, right?

00:42:21,520 --> 00:42:22,420
That'd be nice.

00:42:22,420 --> 00:42:25,080
So, Christopher?

00:42:25,080 --> 00:42:25,950
Christoph?

00:42:25,950 --> 00:42:27,486
- [Dan] Christoph.

00:42:27,486 --> 00:42:28,489
- Christoph.

00:42:28,489 --> 00:42:30,050
Christoph Hellwig asked to do that,

00:42:30,050 --> 00:42:31,860
so I'm kinda looking at that.

00:42:31,860 --> 00:42:32,990
Other people have said, "well,

00:42:32,990 --> 00:42:35,820
"it should work with a scatter gather list,

00:42:37,030 --> 00:42:39,740
"because that's how most of the block stuff deals,

00:42:39,740 --> 00:42:41,280
"so we should be able to do that

00:42:41,280 --> 00:42:42,580
"instead of struct pages,"

00:42:43,694 --> 00:42:46,460
and then Ira jumped in

00:42:46,460 --> 00:42:49,820
and is proposing vaddr pin pages

00:42:49,820 --> 00:42:52,529
as a way to deal with DAX,

00:42:52,529 --> 00:42:54,122
and then of course, range_fault

00:42:54,122 --> 00:42:54,955
is not get_user_pages at all,

00:42:54,955 --> 00:42:57,540
it just kind of does things

00:42:57,540 --> 00:42:58,373
that are similar

00:42:59,300 --> 00:43:00,595
by not pinning pages.

00:43:00,595 --> 00:43:02,845
(laughing)

00:43:04,034 --> 00:43:04,867
Let's see.

00:43:05,854 --> 00:43:06,997
Whoops.

00:43:06,997 --> 00:43:08,130
- [Man] You went a slide too far.

00:43:08,130 --> 00:43:08,963
- Went too far?

00:43:10,090 --> 00:43:10,923
Sorry.

00:43:11,906 --> 00:43:13,585
(quiet chattering)

00:43:13,585 --> 00:43:14,801
Oh, I see.

00:43:14,801 --> 00:43:15,837
Just hit run again.

00:43:15,837 --> 00:43:18,362
- Just hit run again.

00:43:18,362 --> 00:43:20,240
(quiet mumbling)

00:43:20,240 --> 00:43:21,804
- Yeah, I missed.

00:43:21,804 --> 00:43:23,042
- Hey, that's pretty good.

00:43:23,042 --> 00:43:23,875
- Oh, I see.

00:43:23,875 --> 00:43:25,253
I'm not supposed to push that button.

00:43:25,253 --> 00:43:26,448
Sorry.

00:43:26,448 --> 00:43:29,180
(quiet chattering)

00:43:29,180 --> 00:43:30,420
Right, okay.

00:43:30,420 --> 00:43:32,810
So, this is kinda the same thing.

00:43:32,810 --> 00:43:34,910
So, file system awareness.

00:43:34,910 --> 00:43:36,314
In other words,

00:43:36,314 --> 00:43:38,034
if you call get_user_pages

00:43:38,034 --> 00:43:41,190
and then the file system is also operating on that,

00:43:41,190 --> 00:43:42,023
it's all broken.

00:43:44,579 --> 00:43:46,829
(laughing)

00:43:47,800 --> 00:43:49,810
The peer mappings, yeah,

00:43:49,810 --> 00:43:52,130
one of the ideas that we wanna stack on top here

00:43:52,130 --> 00:43:53,270
is we wanna say, "well,"

00:43:53,270 --> 00:43:54,840
I think we wanna say, "okay,

00:43:54,840 --> 00:43:56,100
"you've got these Zone Device pages.

00:43:56,100 --> 00:43:58,770
"What happens if you call get_user_pages on those?"

00:43:58,770 --> 00:44:01,000
Well, it seems like a cool idea

00:44:01,000 --> 00:44:03,170
if you set up bar mappings at that point.

00:44:04,020 --> 00:44:05,520
That makes sense,

00:44:05,520 --> 00:44:06,470
in some cases.

00:44:07,980 --> 00:44:10,070
We want to define the interaction with hmm

00:44:10,070 --> 00:44:12,180
with the hmm_range_fault,

00:44:12,180 --> 00:44:13,810
and then again,

00:44:13,810 --> 00:44:16,270
should we have these different APIs?

00:44:16,270 --> 00:44:18,200
And one of the things I wanna bring up here,

00:44:18,200 --> 00:44:19,780
and let's see how we're doing,

00:44:19,780 --> 00:44:21,850
is kind of a small point,

00:44:21,850 --> 00:44:24,310
but if you go back

00:44:26,472 --> 00:44:27,993
and you look at this constant,

00:44:30,870 --> 00:44:32,630
if you try to get this stuff reviewed,

00:44:32,630 --> 00:44:34,020
you're gonna find that you're gonna go back

00:44:34,020 --> 00:44:34,853
and forth a little bit,

00:44:34,853 --> 00:44:36,540
so someone will say, "okay,

00:44:38,279 --> 00:44:40,110
"I got this new API,

00:44:40,110 --> 00:44:41,560
"and I got all these flags,

00:44:41,560 --> 00:44:44,290
"so I don't really wanna have a wild west of people,

00:44:44,290 --> 00:44:46,670
"setting all these flags out there at the call sites,

00:44:46,670 --> 00:44:48,480
"so I want wrapper functions."

00:44:48,480 --> 00:44:51,060
So, the wrapper functions should set the flags.

00:44:51,060 --> 00:44:52,730
So, if you call this new function

00:44:52,730 --> 00:44:54,430
Ira's gonna talk a lot more about,

00:44:55,610 --> 00:44:57,090
it should set follow pin,

00:44:57,090 --> 00:44:58,250
which is a new flag,

00:44:58,250 --> 00:45:00,950
and it should set, maybe, follow long-term.

00:45:00,950 --> 00:45:03,090
Okay, great, except that some of the call sites

00:45:03,090 --> 00:45:05,080
only want one of those flags.

00:45:05,080 --> 00:45:07,862
Okay, well, let's have more wrappers then, right?

00:45:07,862 --> 00:45:10,776
(laughing)

00:45:10,776 --> 00:45:12,134
So, there's a balance,

00:45:12,134 --> 00:45:12,967
and so I'm kinda curious

00:45:12,967 --> 00:45:14,450
where people seem to balance

00:45:14,450 --> 00:45:16,850
if they've looked at any of this.

00:45:16,850 --> 00:45:18,650
How many wrappers are you gonna tolerate?

00:45:18,650 --> 00:45:21,230
Do you want a wrapper for every specific thing

00:45:21,230 --> 00:45:23,470
or do you just wanna do that with flags?

00:45:23,470 --> 00:45:25,170
At some point, we've gotta come up

00:45:26,282 --> 00:45:29,160
with not so many unconstrained flags,

00:45:29,160 --> 00:45:30,830
so I'm leaning toward, really,

00:45:30,830 --> 00:45:32,790
wrappers across the board.

00:45:32,790 --> 00:45:34,680
That would be my first,

00:45:34,680 --> 00:45:35,760
that's where I would reach,

00:45:35,760 --> 00:45:40,109
but then again, somebody, yeah.

00:45:40,109 --> 00:45:42,680
- I think wrappers are okay,

00:45:42,680 --> 00:45:45,550
but that explodes the API.

00:45:45,550 --> 00:45:48,100
I would rather maybe see some warn ons or something

00:45:49,569 --> 00:45:51,420
and some kernel docs that say,

00:45:51,420 --> 00:45:53,100
"this function takes these flags

00:45:53,100 --> 00:45:55,290
"and only these flags,"

00:45:55,290 --> 00:45:57,240
so something the same,

00:45:57,240 --> 00:45:59,990
'cause when I first started looking at this stuff,

00:45:59,990 --> 00:46:02,140
there was get_user_pages remote,

00:46:02,140 --> 00:46:04,100
and all it did was call get_user_pages

00:46:04,100 --> 00:46:06,410
with the follow remote flag,

00:46:06,410 --> 00:46:08,540
and I asked Dave Hanson, who's in my group,

00:46:08,540 --> 00:46:09,740
'cause I saw he wrote it,

00:46:09,740 --> 00:46:10,690
and I'm like, "why'd you do this?"

00:46:10,690 --> 00:46:11,970
He goes, "oh, I don't know.

00:46:11,970 --> 00:46:14,340
"It just seemed like the right thing to do at the time,"

00:46:14,340 --> 00:46:16,490
and so that's kinda what's happened

00:46:16,490 --> 00:46:19,310
is sometimes we think a wrapper's right,

00:46:19,310 --> 00:46:20,900
and sometimes we think a flag's right,

00:46:20,900 --> 00:46:21,860
and nobody's wrong,

00:46:21,860 --> 00:46:25,070
it's just that's how it's grown organically,

00:46:25,070 --> 00:46:25,990
like you said last night,

00:46:25,990 --> 00:46:28,080
into this mess.

00:46:28,080 --> 00:46:29,925
So, I think we do need

00:46:29,925 --> 00:46:31,495
to make a decision,

00:46:31,495 --> 00:46:32,650
how do we want this?

00:46:34,636 --> 00:46:35,840
But, yeah.

00:46:35,840 --> 00:46:39,680
And the unconstrained flag passing,

00:46:39,680 --> 00:46:40,740
you can pass flags

00:46:40,740 --> 00:46:42,920
that basically conflict with each other

00:46:42,920 --> 00:46:44,490
and there's no checks, currently.

00:46:44,490 --> 00:46:45,520
Nobody does that,

00:46:45,520 --> 00:46:47,320
so nothing's broken.

00:46:47,320 --> 00:46:49,270
- Yeah, the wrapper function

00:46:49,270 --> 00:46:50,950
can kinda help you check

00:46:50,950 --> 00:46:51,840
in that case.

00:46:51,840 --> 00:46:53,090
If you had a wrapper function,

00:46:53,090 --> 00:46:54,050
then it says, "I know

00:46:54,050 --> 00:46:57,240
"you're trying to pin these pages

00:46:57,240 --> 00:47:01,330
"so that some direct IO driver

00:47:01,330 --> 00:47:02,490
"can use them.

00:47:02,490 --> 00:47:04,540
"So, here's your case.

00:47:04,540 --> 00:47:06,680
"So, I know you need these flags."

00:47:06,680 --> 00:47:09,070
- So generally, I guess the idea

00:47:09,070 --> 00:47:11,820
is that if you have plenty of users

00:47:11,820 --> 00:47:15,410
that need the same set of flags,

00:47:16,680 --> 00:47:18,520
then wrapper is a good thing, yeah,

00:47:18,520 --> 00:47:20,610
because that's just easier to find

00:47:20,610 --> 00:47:22,730
and reason about and so on.

00:47:22,730 --> 00:47:23,830
You only have to check

00:47:25,100 --> 00:47:25,933
is this the normal user

00:47:25,933 --> 00:47:29,030
or is this setting some unusual sort of flags?

00:47:29,030 --> 00:47:29,863
But then, of course,

00:47:29,863 --> 00:47:31,860
you are going to have some users

00:47:31,860 --> 00:47:33,410
that always want something special,

00:47:33,410 --> 00:47:35,520
especially if it's get_user_pages,

00:47:35,520 --> 00:47:36,950
so then, probably for those,

00:47:36,950 --> 00:47:39,900
they will just have to use flags.

00:47:40,990 --> 00:47:43,110
So, the cases that are not really that common,

00:47:43,110 --> 00:47:45,410
you have two, three users in the whole kernel.

00:47:46,680 --> 00:47:48,493
- Okay, so we'll just do it by the numbers.

00:47:48,493 --> 00:47:50,180
- Yeah, I would just,

00:47:50,180 --> 00:47:51,640
for the common cases,

00:47:51,640 --> 00:47:52,870
I would do it,

00:47:52,870 --> 00:47:54,560
I would create a wrapper,

00:47:54,560 --> 00:47:56,830
then those that do not fall

00:47:56,830 --> 00:47:58,840
into any of the common cases,

00:48:00,370 --> 00:48:01,203
because for example,

00:48:01,203 --> 00:48:02,850
I would expect device drivers

00:48:02,850 --> 00:48:06,090
to all do more or less the same thing.

00:48:06,090 --> 00:48:06,923
- Right.

00:48:08,160 --> 00:48:08,993
There's a lot of flags

00:48:08,993 --> 00:48:10,630
that are just for the mm's internal use,

00:48:10,630 --> 00:48:12,620
like the one Ira mentioned.

00:48:12,620 --> 00:48:14,660
Those need to be kept away from the device driver

00:48:14,660 --> 00:48:16,110
and the device driver should never, ever, ever

00:48:16,110 --> 00:48:17,140
be allowed to use those.

00:48:17,140 --> 00:48:18,707
That'll make our life a lot simpler.

00:48:18,707 --> 00:48:20,560
- And so, that's where I'm saying

00:48:20,560 --> 00:48:23,350
that the GUP calls should enforce

00:48:23,350 --> 00:48:25,410
and say, "if you're a device driver

00:48:25,410 --> 00:48:27,866
"and you're using these flags, uh uh.

00:48:27,866 --> 00:48:29,890
"No."

00:48:29,890 --> 00:48:31,827
You can't do that. - At the call site

00:48:31,827 --> 00:48:34,890
is where you know where the flags are, right?

00:48:34,890 --> 00:48:36,930
- Right, internal to the call,

00:48:36,930 --> 00:48:38,690
the call actually does some checks

00:48:38,690 --> 00:48:40,360
and says, "these are internal flags.

00:48:40,360 --> 00:48:43,390
"If some driver's passing these in,"

00:48:43,390 --> 00:48:46,130
and the internal mm calls call something else

00:48:46,130 --> 00:48:50,390
that's an internal call that allows those flags.

00:48:50,390 --> 00:48:51,640
- As you were talking,

00:48:51,640 --> 00:48:53,940
we might even consider just not even exporting

00:48:55,260 --> 00:48:56,170
just two modules,

00:48:56,170 --> 00:48:58,110
the one that can take flags only.

00:48:58,110 --> 00:48:58,943
- Right.

00:48:58,943 --> 00:48:59,776
Yeah.

00:48:59,776 --> 00:49:00,997
Yeah.

00:49:00,997 --> 00:49:02,190
- [Jason] There's lots of flags that are okay.

00:49:02,190 --> 00:49:03,580
The flags that are compose-able

00:49:03,580 --> 00:49:05,100
and don't conflict with each other,

00:49:05,100 --> 00:49:05,933
those are fine,

00:49:05,933 --> 00:49:07,400
like read, write, long-term,

00:49:07,400 --> 00:49:10,150
those are all reasonable things to use for flags.

00:49:10,150 --> 00:49:11,310
It's when they interact with,

00:49:11,310 --> 00:49:12,830
"oh, I needed a special flag to trigger

00:49:12,830 --> 00:49:15,470
"this small behavior deep, deep down in the stack."

00:49:15,470 --> 00:49:16,590
Those are internal flags.

00:49:16,590 --> 00:49:17,764
- Like K dumps.

00:49:17,764 --> 00:49:18,790
- [Jason] Yeah.

00:49:18,790 --> 00:49:19,965
- And I know

00:49:19,965 --> 00:49:22,080
when we were talking about follow pin,

00:49:24,070 --> 00:49:26,330
Michael Hocko was basically saying,

00:49:26,330 --> 00:49:27,490
"okay, just hide that.

00:49:27,490 --> 00:49:30,060
"I don't wanna even see that flag at the call sites."

00:49:31,920 --> 00:49:32,753
- Yeah.

00:49:34,370 --> 00:49:35,203
And I agree

00:49:35,203 --> 00:49:37,270
because what I was saying is that, actually,

00:49:37,270 --> 00:49:38,860
device driver writers

00:49:38,860 --> 00:49:41,420
are about the most coolest users

00:49:41,420 --> 00:49:42,510
of get_user_pages

00:49:42,510 --> 00:49:46,420
because when some core mm stuff uses get_user_pages,

00:49:46,420 --> 00:49:48,600
then hopefully, they know what they are doing,

00:49:48,600 --> 00:49:50,850
but then if you want to use get_user_pages

00:49:50,850 --> 00:49:51,820
in your device driver

00:49:51,820 --> 00:49:55,010
to just somehow get your user buffer,

00:49:55,010 --> 00:49:57,100
then probably, you should just have a simple helper

00:49:57,100 --> 00:49:59,110
and you don't have to care about all those pages.

00:49:59,110 --> 00:50:02,590
Basically, read or write is the only thing you care about,

00:50:02,590 --> 00:50:05,890
and maybe long-term, kind of,

00:50:05,890 --> 00:50:08,150
but that are basically only two things you care about

00:50:08,150 --> 00:50:09,480
and you shouldn't be bothered

00:50:09,480 --> 00:50:11,131
having to go through another 14

00:50:11,131 --> 00:50:13,220
follow get_user_pages flags

00:50:13,220 --> 00:50:15,407
and think which ones you need.

00:50:15,407 --> 00:50:16,250
(laughing) - Okay.

00:50:17,540 --> 00:50:18,460
Let's see.

00:50:18,460 --> 00:50:19,480
I got a couple minutes.

00:50:19,480 --> 00:50:20,570
I wanted to make sure

00:50:23,020 --> 00:50:24,020
I talked a little bit about.

00:50:24,020 --> 00:50:24,853
Okay.

00:50:27,354 --> 00:50:28,187
Did I cover it all?

00:50:28,187 --> 00:50:29,358
Yeah.

00:50:29,358 --> 00:50:30,700
Yeah, I wanna cover Ira's thing in a little bit.

00:50:32,050 --> 00:50:32,883
Okay.

00:50:32,883 --> 00:50:33,970
Just to kinda give a lead in

00:50:33,970 --> 00:50:37,930
to connect this with what Ira's gonna talk about next,

00:50:37,930 --> 00:50:39,440
one of those things we listed

00:50:39,440 --> 00:50:42,430
was called vaddr_pin_pages.

00:50:42,430 --> 00:50:44,090
Of course, I'm encouraging the name

00:50:44,090 --> 00:50:46,140
to be slightly changed, but nevermind.

00:50:47,290 --> 00:50:51,540
So, this is a very interesting thing going on

00:50:51,540 --> 00:50:53,270
where we're saying, "okay,

00:50:53,270 --> 00:50:55,450
"as we go through this constellation

00:50:55,450 --> 00:50:57,240
"of API calls that are related,

00:50:57,240 --> 00:50:58,650
"that are basically GUP,

00:50:59,640 --> 00:51:01,380
"we're gonna find ourselves splitting them

00:51:01,380 --> 00:51:05,220
"into different names," probably,

00:51:05,220 --> 00:51:06,942
instead of just get_user_pages,

00:51:06,942 --> 00:51:08,760
there's probably gonna be new stuff,

00:51:08,760 --> 00:51:11,350
like we'll pick a new name for something

00:51:11,350 --> 00:51:13,680
so we can keep all this stuff straight,

00:51:13,680 --> 00:51:15,440
and these are, I guess you could call them,

00:51:15,440 --> 00:51:16,750
wrapper functions, perhaps?

00:51:16,750 --> 00:51:18,370
But this one is a little bit more than that

00:51:18,370 --> 00:51:20,230
because this one has a different API.

00:51:20,230 --> 00:51:22,560
This one, in addition to all the other goodies

00:51:22,560 --> 00:51:24,370
you have to pass GUP,

00:51:24,370 --> 00:51:27,050
this one is gonna take a context

00:51:27,050 --> 00:51:28,340
at the call site that says, "okay,

00:51:28,340 --> 00:51:30,760
"I know my mm and my open file descriptor,

00:51:32,110 --> 00:51:33,530
"and the file descriptor

00:51:34,481 --> 00:51:35,560
"has a lease attached to it,

00:51:35,560 --> 00:51:37,220
"a file lease,"

00:51:37,220 --> 00:51:38,870
and so everything's connected all up.

00:51:38,870 --> 00:51:40,220
You'll hear more about it.

00:51:40,220 --> 00:51:42,940
And now, it's okay

00:51:42,940 --> 00:51:44,680
to actually pin this page,

00:51:44,680 --> 00:51:46,540
and it's a separate ref count,

00:51:46,540 --> 00:51:48,180
in addition to the page ref count,

00:51:48,180 --> 00:51:49,013
kind of overloaded,

00:51:49,013 --> 00:51:51,100
but conceptually, it's separate.

00:51:51,100 --> 00:51:54,490
The page is now pinned with a different counter

00:51:55,370 --> 00:51:56,290
and the rest

00:51:56,290 --> 00:52:00,180
of the mm and file system functions,

00:52:00,180 --> 00:52:01,970
such as try to unmap,

00:52:01,970 --> 00:52:03,030
page make clean,

00:52:04,190 --> 00:52:05,610
these things can say, "oh,

00:52:05,610 --> 00:52:07,760
"I recognize that you're specially pinned,"

00:52:09,493 --> 00:52:10,760
and when you come in,

00:52:10,760 --> 00:52:13,613
sure, you're firing an MMU notifier,

00:52:13,613 --> 00:52:14,860
that's all very nice,

00:52:14,860 --> 00:52:18,620
but if it's a device or something

00:52:18,620 --> 00:52:20,980
that is unaware of those kind of things,

00:52:20,980 --> 00:52:22,360
we have a file lease

00:52:22,360 --> 00:52:25,114
that explains how all of this is gonna work,

00:52:25,114 --> 00:52:26,900
and so, I think

00:52:26,900 --> 00:52:28,570
the reason I'm interested in this

00:52:28,570 --> 00:52:31,320
is that this breaks the log jam.

00:52:31,320 --> 00:52:33,920
This is the way forward

00:52:33,920 --> 00:52:36,970
from the deadlock that we've had.

00:52:36,970 --> 00:52:39,000
- [Jason] So, would anybody like to bike shed the name

00:52:39,000 --> 00:52:40,090
while we're here,

00:52:40,090 --> 00:52:41,800
and get it out of your system?

00:52:41,800 --> 00:52:43,597
- No, actually, this is what it needs to be.

00:52:43,597 --> 00:52:45,600
(laughing)

00:52:45,600 --> 00:52:48,017
(chattering)

00:52:50,122 --> 00:52:51,760
- [Don] I've already changed the name, by the way.

00:52:51,760 --> 00:52:53,080
- What's the new name? - To what?

00:52:53,080 --> 00:52:54,370
- [Don] Uaddr_pin_pages.

00:52:54,370 --> 00:52:55,683
- Oh, no.

00:52:55,683 --> 00:52:56,691
That was the worst one.

00:52:56,691 --> 00:52:57,746
(laughing) No.

00:52:57,746 --> 00:52:58,745
We can't do that.

00:52:58,745 --> 00:52:59,578
- [Don] You have to start this.

00:52:59,578 --> 00:53:00,791
- [Jason] I don't like typing.

00:53:00,791 --> 00:53:02,270
(chattering)

00:53:02,270 --> 00:53:03,485
Better here than in the (mumbling)

00:53:03,485 --> 00:53:05,300
- Oh, yeah.

00:53:05,300 --> 00:53:06,550
The put_user_page,

00:53:06,550 --> 00:53:08,207
you may have seen that go by.

00:53:08,207 --> 00:53:10,270
We used to just say get_user_pages

00:53:10,270 --> 00:53:12,060
and then, put page.

00:53:12,060 --> 00:53:13,740
I've added in put_user_page

00:53:13,740 --> 00:53:15,440
as the complement to get_user_pages

00:53:15,440 --> 00:53:18,010
because in some cases,

00:53:18,010 --> 00:53:21,400
not all the cases for the GUP flags,

00:53:21,400 --> 00:53:22,233
but in some cases,

00:53:22,233 --> 00:53:24,490
we're gonna have this new count

00:53:24,490 --> 00:53:26,040
that says it's pinned

00:53:26,040 --> 00:53:27,960
by get_user_pages,

00:53:27,960 --> 00:53:29,820
as opposed to some other way

00:53:29,820 --> 00:53:31,920
of elevating the page ref count,

00:53:31,920 --> 00:53:33,550
and so you need a corresponding call

00:53:33,550 --> 00:53:34,383
to unpin it,

00:53:34,383 --> 00:53:37,290
and that's what put_user_page is gonna do, or does.

00:53:38,360 --> 00:53:39,470
- But then, there was a discussion,

00:53:39,470 --> 00:53:40,810
and I agree with Michael,

00:53:40,810 --> 00:53:41,660
that it'd be good

00:53:42,755 --> 00:53:45,370
to actually also the pinning part,

00:53:45,370 --> 00:53:46,610
whenever you say follow pin,

00:53:46,610 --> 00:53:48,620
then actually, you wouldn't be allowed to adjust it,

00:53:48,620 --> 00:53:51,370
but you would have wrapper function,

00:53:51,370 --> 00:53:54,020
basically, to use the pins among the except, basically,

00:53:54,020 --> 00:53:56,830
set the follow pin. - Right, and this is that.

00:53:56,830 --> 00:53:58,780
In fact, this is the set of wrapper functions

00:53:58,780 --> 00:53:59,613
you're seeing here.

00:53:59,613 --> 00:54:01,130
- Yeah.

00:54:01,130 --> 00:54:02,280
So, as far as I understand,

00:54:02,280 --> 00:54:03,990
what Ira is working on

00:54:03,990 --> 00:54:06,040
will also set follow long-term,

00:54:06,040 --> 00:54:08,110
but you don't want long-term

00:54:08,110 --> 00:54:11,210
for all the users that pin. - No.

00:54:11,210 --> 00:54:12,350
- No?

00:54:12,350 --> 00:54:13,460
You want set long-term?

00:54:13,460 --> 00:54:14,293
- No.

00:54:14,293 --> 00:54:15,890
We had this discussion on the (speech cut off)

00:54:15,890 --> 00:54:16,723
- Okay.

00:54:16,723 --> 00:54:17,556
- Yeah.

00:54:17,556 --> 00:54:19,091
- Yeah, the follow long-term

00:54:19,091 --> 00:54:19,924
is kinda independent

00:54:19,924 --> 00:54:21,670
from the follow pin.

00:54:21,670 --> 00:54:25,310
This should only happen for follow pin.

00:54:28,320 --> 00:54:29,680
- Right. Yeah.

00:54:29,680 --> 00:54:31,120
That's where he was saying

00:54:31,120 --> 00:54:35,390
where some of these

00:54:35,390 --> 00:54:36,720
should be flags exported,

00:54:36,720 --> 00:54:38,125
and some shouldn't,

00:54:38,125 --> 00:54:39,170
and I think the long-term should be exported

00:54:39,170 --> 00:54:40,940
because some people may wanna pin,

00:54:40,940 --> 00:54:43,970
but they know it's gonna be a relatively short pin.

00:54:43,970 --> 00:54:45,070
Others, like RDMA,

00:54:45,070 --> 00:54:46,970
are gonna wanna pin long-term,

00:54:46,970 --> 00:54:48,380
and they specify the long-term flags.

00:54:48,380 --> 00:54:50,420
So yeah, I agree with you Johann,

00:54:50,420 --> 00:54:51,960
and that's the way it's coded.

00:54:51,960 --> 00:54:54,270
Those are very nice and compose-able flags.

00:54:54,270 --> 00:54:56,863
Long-term does not affect the behavior

00:54:56,863 --> 00:54:57,870
of any of the other flags,

00:54:57,870 --> 00:54:59,120
like when you start having them interact,

00:54:59,120 --> 00:55:00,960
that's a bad set of flags you've got.

00:55:00,960 --> 00:55:01,793
- So, hold that thought

00:55:01,793 --> 00:55:03,900
because we just hit the end of the session,

00:55:03,900 --> 00:55:06,400
and we're gonna go into it more with Ira

00:55:06,400 --> 00:55:08,330
in the next one. - Do I need my laptop

00:55:08,330 --> 00:55:09,300
or are the slides on there?

00:55:09,300 --> 00:55:10,420
- [Jason] I don't have your slides.

00:55:10,420 --> 00:55:11,360
- Okay, I'll get it.

00:55:11,360 --> 00:55:12,740
So, is there any other discussion?

00:55:12,740 --> 00:55:13,780
Jerome's got something. - Yeah.

00:55:13,780 --> 00:55:15,130
I just wanted to point out,

00:55:16,088 --> 00:55:17,530
you don't want to allocate user patrons on device

00:55:17,530 --> 00:55:19,920
if it's malloc or a map of a regular file.

00:55:19,920 --> 00:55:21,450
As it was, you have to SIGBUS

00:55:21,450 --> 00:55:22,760
for the CPU access.

00:55:22,760 --> 00:55:24,010
SIGBUS or segfault.

00:55:25,290 --> 00:55:28,232
So, you do not want to allocate your page

00:55:28,232 --> 00:55:29,360
to work on the device pages,

00:55:29,360 --> 00:55:30,570
or actually inside.

00:55:30,570 --> 00:55:32,520
- [Ira] You mean device private pages.

00:55:32,520 --> 00:55:33,780
- Device private pages, yes,

00:55:33,780 --> 00:55:38,023
but you cannot get any other kind of Zone Device pages

00:55:38,023 --> 00:55:41,770
inside a regular mm VMA,

00:55:41,770 --> 00:55:43,580
so for me, regular VMA

00:55:43,580 --> 00:55:45,810
is a VMA that are coming from mmap,

00:55:45,810 --> 00:55:47,000
private, and MVME,

00:55:47,000 --> 00:55:48,880
or an mmap of earlier files

00:55:48,880 --> 00:55:50,460
is mmap of not a device file.

00:55:53,980 --> 00:55:54,813
- All right.

00:55:55,650 --> 00:55:56,483
Yeah, I'm okay.

00:55:56,483 --> 00:55:58,640
I just gotta find my slides now.

00:56:01,300 --> 00:56:02,930
Didn't know if they would be.

00:56:06,310 --> 00:56:08,670
- All right, well, while Ira's checking out his slides,

00:56:08,670 --> 00:56:10,720
does anybody have any questions for John

00:56:10,720 --> 00:56:12,600
or Jerome or Dan or Dan

00:56:15,604 --> 00:56:16,900
on our pages problems?

00:56:16,900 --> 00:56:17,900
Problems with pages?

00:56:20,000 --> 00:56:21,890
- Oh, there's all kinds of problems with pages.

00:56:21,890 --> 00:56:24,100
Okay, so I'm gonna go quickly

00:56:24,100 --> 00:56:25,440
through the first few slides

00:56:25,440 --> 00:56:27,950
because I drew pictures,

00:56:27,950 --> 00:56:30,120
and for people who were here

00:56:30,120 --> 00:56:32,190
a little over a year ago,

00:56:32,190 --> 00:56:33,340
or at LSF,

00:56:33,340 --> 00:56:36,060
this problem's kinda been going on for a long time,

00:56:36,060 --> 00:56:39,610
so a bug occurred with file system DAX

00:56:39,610 --> 00:56:41,220
where RDMA pages

00:56:41,220 --> 00:56:43,920
would corrupt the file system

00:56:43,920 --> 00:56:45,290
and there was some issues,

00:56:45,290 --> 00:56:47,520
so Dan just threw in

00:56:48,800 --> 00:56:52,430
another GUP user call site

00:56:52,430 --> 00:56:54,430
called get_user_pages_long-term

00:56:54,430 --> 00:56:57,570
and that would prevent any file system DAX pages

00:56:57,570 --> 00:56:59,110
from being pinned.

00:56:59,110 --> 00:57:01,740
So my job, since I joined Dan's group

00:57:01,740 --> 00:57:03,040
has been to solve this problem

00:57:03,040 --> 00:57:05,850
because I come from an RDMA background,

00:57:05,850 --> 00:57:08,160
and after much discussion

00:57:08,160 --> 00:57:11,030
and a very heated discussion at LSFMM,

00:57:11,870 --> 00:57:15,740
we kinda decided the failing truncate was okay

00:57:15,740 --> 00:57:17,200
with some caveats.

00:57:18,090 --> 00:57:20,670
Those caveats were that admins

00:57:20,670 --> 00:57:23,140
needed to understand why their truncate was failing

00:57:23,140 --> 00:57:24,150
on the file system

00:57:24,150 --> 00:57:26,900
so that they could override

00:57:26,900 --> 00:57:30,890
any application that was holding these pins

00:57:30,890 --> 00:57:31,830
by killing them

00:57:31,830 --> 00:57:32,830
or telling the user, "hey,

00:57:32,830 --> 00:57:33,990
"you need to quit your job,"

00:57:33,990 --> 00:57:38,990
or something to that extent. (laughing)

00:57:39,514 --> 00:57:41,170
So since LSF,

00:57:41,170 --> 00:57:44,240
I basically come up with a fail truncated patch set,

00:57:44,240 --> 00:57:45,730
and I submitted that patch set

00:57:45,730 --> 00:57:46,830
a couple weeks ago,

00:57:47,790 --> 00:57:49,580
and there was some feedback on it.

00:57:49,580 --> 00:57:50,900
So, I wanna quickly go over

00:57:50,900 --> 00:57:52,410
what that patch set did

00:57:52,410 --> 00:57:53,470
because I drew pictures

00:57:53,470 --> 00:57:55,100
because, on the mailing list,

00:57:55,100 --> 00:57:56,200
there's a lot of confusion,

00:57:56,200 --> 00:57:58,020
even amongst people that are really familiar

00:57:58,020 --> 00:57:59,260
with this problem

00:57:59,260 --> 00:58:03,000
as to what's been going on,

00:58:03,000 --> 00:58:04,580
and so the problem really

00:58:04,580 --> 00:58:07,120
is that you have a process

00:58:07,120 --> 00:58:09,290
and in its file descriptor table,

00:58:09,290 --> 00:58:11,370
you have a data file mapped

00:58:11,370 --> 00:58:13,960
to, like, a DAX file system.

00:58:13,960 --> 00:58:16,850
So, I open a file on a file system, like FOO,

00:58:16,850 --> 00:58:18,510
and then I mmap it,

00:58:18,510 --> 00:58:19,920
and now I've got that memory,

00:58:19,920 --> 00:58:21,360
and then I go ahead and register it

00:58:21,360 --> 00:58:22,860
with my RDMA device,

00:58:22,860 --> 00:58:24,330
which also has a file descriptor.

00:58:24,330 --> 00:58:27,360
So, that's coming into these RDMA file objects.

00:58:27,360 --> 00:58:28,730
So, this is like a struct file.

00:58:28,730 --> 00:58:30,950
There's an RDMA/uverbs thing,

00:58:30,950 --> 00:58:32,920
and under that, it has a memory region,

00:58:32,920 --> 00:58:35,380
and then when I call register,

00:58:35,380 --> 00:58:37,437
basically, I'm registering these pages

00:58:37,437 --> 00:58:39,330
that's connected to this memory region,

00:58:39,330 --> 00:58:40,930
but those pages are actually mapped

00:58:40,930 --> 00:58:42,390
through the address space and the inode

00:58:42,390 --> 00:58:43,740
to this data file,

00:58:43,740 --> 00:58:45,422
and of course, I have a VMA

00:58:45,422 --> 00:58:47,259
because I mmapped that thing.

00:58:47,259 --> 00:58:48,500
Okay.

00:58:48,500 --> 00:58:51,050
There's all these different file descriptors,

00:58:51,050 --> 00:58:53,080
different file objects

00:58:53,080 --> 00:58:55,490
that refer to different files,

00:58:55,490 --> 00:58:58,680
and the key is that in order to keep track

00:58:58,680 --> 00:59:01,580
of which files are pinned

00:59:01,580 --> 00:59:03,870
by this other sub-system,

00:59:03,870 --> 00:59:06,020
I've come up with a new GUP thing,

00:59:06,020 --> 00:59:08,830
which is the vaddr_pin_pages,

00:59:08,830 --> 00:59:11,040
uaddr_get_user_pages,

00:59:11,040 --> 00:59:12,986
vaddr_pin_pages, (laughing)

00:59:12,986 --> 00:59:15,000
whatever new call we call it

00:59:15,000 --> 00:59:16,370
and how long I have to type

00:59:17,838 --> 00:59:19,260
(laughing) to link these two together

00:59:19,260 --> 00:59:20,990
via a file pin object;

00:59:20,990 --> 00:59:22,820
and so, what we came up with

00:59:23,838 --> 00:59:24,730
is, through some discussions

00:59:24,730 --> 00:59:27,970
and Johann very helpfully said,

00:59:27,970 --> 00:59:29,080
"let's just figure out

00:59:29,080 --> 00:59:31,700
"how to know whether the admin,

00:59:31,700 --> 00:59:34,100
"what process they need to kill."

00:59:34,100 --> 00:59:36,790
So, this file pin,

00:59:36,790 --> 00:59:38,010
and this kinda goes on

00:59:38,010 --> 00:59:39,600
because part of the problem

00:59:39,600 --> 00:59:40,720
is what happens

00:59:40,720 --> 00:59:45,720
when you may unmap this memory,

00:59:45,770 --> 00:59:47,900
you may close this data file,

00:59:47,900 --> 00:59:49,920
but these pins still exist

00:59:49,920 --> 00:59:51,170
in your RDMA sub-system,

00:59:51,170 --> 00:59:53,240
and you can still use them.

00:59:53,240 --> 00:59:54,640
So at this point,

00:59:54,640 --> 00:59:56,950
if you look in procfs,

00:59:56,950 --> 00:59:59,150
this process currently

00:59:59,150 --> 01:00:00,150
with upstream kernel

01:00:01,295 --> 01:00:03,050
has no linkage to this pinned file,

01:00:03,920 --> 01:00:05,300
and so there's no way to tell

01:00:05,300 --> 01:00:07,217
that RDMA went off

01:00:07,217 --> 01:00:08,050
and pinned these pages,

01:00:08,050 --> 01:00:10,350
and this file is locked in memory,

01:00:10,350 --> 01:00:12,440
and the truncate's gonna fail.

01:00:13,370 --> 01:00:16,770
So, that's where these file pin objects come in,

01:00:16,770 --> 01:00:18,590
and it kinda gets worse

01:00:18,590 --> 01:00:20,610
because, with a fork,

01:00:20,610 --> 01:00:23,180
we now have all these file descriptors forked,

01:00:23,180 --> 01:00:24,680
we have all these same file descriptors

01:00:24,680 --> 01:00:26,060
pointing to the same struct files,

01:00:26,060 --> 01:00:28,320
including the RDMA struct file,

01:00:28,320 --> 01:00:30,460
which also has these pins,

01:00:30,460 --> 01:00:33,550
and even though you can't use the memory region

01:00:33,550 --> 01:00:35,210
because of RDMA,

01:00:35,210 --> 01:00:36,700
and you can sort of,

01:00:36,700 --> 01:00:38,080
but you may not be able to,

01:00:38,080 --> 01:00:39,390
the pin still exists,

01:00:39,390 --> 01:00:41,960
which means it'll still fail to truncate.

01:00:41,960 --> 01:00:43,370
Okay?

01:00:43,370 --> 01:00:45,740
So then, it's even worse

01:00:45,740 --> 01:00:47,250
because now, somebody can come along

01:00:47,250 --> 01:00:51,590
with SCM_RIGHTS and basically send this file descriptor

01:00:51,590 --> 01:00:53,430
to any random other process,

01:00:53,430 --> 01:00:55,860
which has no concept of any memory maps,

01:00:55,860 --> 01:00:57,700
no concept of any open files.

01:00:58,570 --> 01:01:02,150
So, this is where the patch set stands right now

01:01:02,150 --> 01:01:06,510
is the key is the file pinning, here,

01:01:06,510 --> 01:01:10,600
ties any sub-system that does any long-term pin

01:01:10,600 --> 01:01:12,890
to the file that got pinned.

01:01:12,890 --> 01:01:14,950
Now, when you call the GUP call,

01:01:16,380 --> 01:01:19,080
and this is where this additional context information

01:01:19,080 --> 01:01:21,020
that John mentioned,

01:01:21,020 --> 01:01:23,050
this context information comes in

01:01:23,050 --> 01:01:27,090
and allows the GUP sub-system to set up this linkage.

01:01:28,490 --> 01:01:30,690
We could add other things to that context,

01:01:30,690 --> 01:01:32,590
depending on what we need,

01:01:32,590 --> 01:01:34,220
but right now, that's the main purpose,

01:01:34,220 --> 01:01:35,300
and then this sub-system,

01:01:35,300 --> 01:01:36,450
when it unpins,

01:01:36,450 --> 01:01:37,900
specifies the same information,

01:01:37,900 --> 01:01:39,350
so that GUP can tear it down,

01:01:40,716 --> 01:01:41,549
and so what this allows

01:01:41,549 --> 01:01:44,022
is for RDMA,

01:01:44,022 --> 01:01:47,030
for XTP that has sockets,

01:01:47,030 --> 01:01:48,670
which also has a struct file

01:01:48,670 --> 01:01:49,820
somewhere up the stack,

01:01:49,820 --> 01:01:51,700
it's not plumbed in yet,

01:01:51,700 --> 01:01:55,240
but conceptually, anything that has a file descriptor

01:01:55,240 --> 01:01:58,960
to a sub-system that's going to do a long-term pin,

01:01:58,960 --> 01:02:01,290
that file descriptor

01:02:01,290 --> 01:02:05,670
is going to be shown in procfs

01:02:05,670 --> 01:02:07,700
as having this file pin,

01:02:07,700 --> 01:02:10,860
and basically locking this file from truncating.

01:02:10,860 --> 01:02:11,750
Okay?

01:02:11,750 --> 01:02:13,390
So, simple?

01:02:14,544 --> 01:02:16,192
I think I saw a question.

01:02:16,192 --> 01:02:19,250
- Yeah, so I had a question.

01:02:19,250 --> 01:02:20,787
This was interesting.

01:02:20,787 --> 01:02:24,354
So, when you have this one process A,

01:02:24,354 --> 01:02:26,230
and now you fork to process B,

01:02:26,230 --> 01:02:30,190
so process B cannot use the RDMA context

01:02:30,190 --> 01:02:31,023
to do stuff?

01:02:31,023 --> 01:02:32,180
How does it work?

01:02:32,180 --> 01:02:33,620
- No, it certainly can.

01:02:33,620 --> 01:02:34,453
- Yeah.

01:02:34,453 --> 01:02:36,034
- [Jason] All of the processes can use all of the things

01:02:36,034 --> 01:02:37,892
and it's ridiculous.

01:02:37,892 --> 01:02:39,830
It's like normal file descriptors.

01:02:39,830 --> 01:02:41,140
If you have the RDMA file descriptor,

01:02:41,140 --> 01:02:45,250
you can use the RDMA things in that file descriptor.

01:02:45,250 --> 01:02:46,930
Ira's shown it with RDMA,

01:02:46,930 --> 01:02:48,700
but you can make the same diagram with VFIO,

01:02:48,700 --> 01:02:50,340
you can make the same diagram with

01:02:50,340 --> 01:02:51,173
- Okay, yeah.

01:02:51,173 --> 01:02:52,006
I think I understand. - GPUS,

01:02:52,006 --> 01:02:53,090
and any char device, right?

01:02:53,090 --> 01:02:53,923
Yeah.

01:02:56,450 --> 01:02:58,170
- Some device reverse the flag

01:02:58,170 --> 01:03:01,420
on the device file when you open them,

01:03:01,420 --> 01:03:03,620
so if it was a flag where you can have co-exec

01:03:03,620 --> 01:03:05,460
or you can have also a wipe on fork.

01:03:07,450 --> 01:03:09,760
So, some device drivers will actually not allow you

01:03:09,760 --> 01:03:13,240
to use a device after you fork.

01:03:13,240 --> 01:03:14,073
- But not all.

01:03:15,224 --> 01:03:16,620
- [Jason] But that's the advisory, right?

01:03:16,620 --> 01:03:18,060
There's nothing that prevents,

01:03:18,060 --> 01:03:20,280
there's no way the kernel prevents you

01:03:20,280 --> 01:03:22,180
from passing file descriptors around.

01:03:22,180 --> 01:03:23,300
That's fundamental Unix.

01:03:23,300 --> 01:03:25,250
- Right, and I think that's the key

01:03:25,250 --> 01:03:27,480
because even if the file descriptor gets passed,

01:03:27,480 --> 01:03:28,970
and even if you can't use it here,

01:03:28,970 --> 01:03:31,050
if this process goes away,

01:03:31,050 --> 01:03:32,710
and now I try, an admin tries

01:03:32,710 --> 01:03:35,480
to truncate this file here, I can't,

01:03:35,480 --> 01:03:36,400
and I don't know,

01:03:36,400 --> 01:03:37,770
I need to know

01:03:37,770 --> 01:03:40,190
that it's these processes that are holding the pin,

01:03:40,190 --> 01:03:41,350
not the original process.

01:03:41,350 --> 01:03:43,330
So, that's the other key

01:03:43,330 --> 01:03:45,670
is, even if the file descriptor gets passed,

01:03:45,670 --> 01:03:47,090
as long as it's still open,

01:03:47,090 --> 01:03:49,820
whether it's useful or not, is irrelevant.

01:03:49,820 --> 01:03:52,700
It's still, that ownership,

01:03:52,700 --> 01:03:54,440
has been passed to some other process

01:03:54,440 --> 01:03:56,280
and we need to track that ownership.

01:03:56,280 --> 01:03:59,300
- So, I saw a really, really, really big mailing list

01:03:59,300 --> 01:04:00,370
about this topic,

01:04:00,370 --> 01:04:02,110
and maybe it's a good point to pause

01:04:02,110 --> 01:04:05,250
and say, "does anybody want to debate

01:04:05,250 --> 01:04:06,460
"Ira on this design

01:04:06,460 --> 01:04:09,000
"or say they don't like it or anything?"

01:04:09,000 --> 01:04:09,833
- Yeah.

01:04:10,738 --> 01:04:11,571
- I love it.

01:04:11,571 --> 01:04:12,744
- All right, Dan loves it.

01:04:12,744 --> 01:04:13,577
(laughing)

01:04:13,577 --> 01:04:15,340
- Okay, well let me,

01:04:15,340 --> 01:04:17,550
and so just a quick slide

01:04:17,550 --> 01:04:20,840
on some of the other sub-system.

01:04:20,840 --> 01:04:22,130
- But I do wanna mention,

01:04:22,130 --> 01:04:23,660
on the previous slide though.

01:04:25,350 --> 01:04:26,829
Right.

01:04:26,829 --> 01:04:27,860
So, where the thread left off,

01:04:27,860 --> 01:04:28,710
the email thread,

01:04:29,930 --> 01:04:32,380
we had it at one process

01:04:32,380 --> 01:04:34,830
'cause this is what Dave Jenner's thing was

01:04:34,830 --> 01:04:37,900
was that one process can own the lease, only one,

01:04:38,850 --> 01:04:40,650
but that's today's world,

01:04:40,650 --> 01:04:42,880
and I think where we wanna go

01:04:42,880 --> 01:04:44,440
is, in tomorrow's world,

01:04:44,440 --> 01:04:46,530
you wanna have a set of lease rules

01:04:46,530 --> 01:04:48,590
that allow more than one process

01:04:48,590 --> 01:04:50,140
to claim a lease.

01:04:50,140 --> 01:04:51,250
- I have more slides.

01:04:51,250 --> 01:04:52,638
- Good.

01:04:52,638 --> 01:04:53,950
(laughing)

01:04:53,950 --> 01:04:55,170
- Good and straight.

01:04:55,170 --> 01:04:56,003
Yeah.

01:04:56,003 --> 01:04:57,161
Great.

01:04:57,161 --> 01:04:58,161
Yeah, perfect.

01:04:58,161 --> 01:04:59,690
So, real quick though,

01:04:59,690 --> 01:05:01,600
there are some other sub-systems

01:05:01,600 --> 01:05:04,150
that actually pin memory through syscalls

01:05:04,150 --> 01:05:05,571
and other things.

01:05:05,571 --> 01:05:08,460
So, I also threw in an mm_struct ability

01:05:08,460 --> 01:05:10,220
to track the file pins,

01:05:10,220 --> 01:05:12,290
but I'm gonna gloss over that right now

01:05:12,290 --> 01:05:13,960
because let's get into the objections

01:05:13,960 --> 01:05:16,690
because yes, there was a large thread

01:05:16,690 --> 01:05:18,780
on the mailing list concerning this.

01:05:18,780 --> 01:05:21,150
So number one, Jason did point out

01:05:21,150 --> 01:05:23,790
that my interpretation of the lifetime

01:05:23,790 --> 01:05:27,080
of the uverbs file object was incorrect,

01:05:27,080 --> 01:05:28,760
and so I had a bug

01:05:29,660 --> 01:05:31,075
that I've actually fixed.

01:05:31,075 --> 01:05:35,620
In work sense, the patch set was submitted,

01:05:35,620 --> 01:05:37,120
and so I've fixed that bug.

01:05:37,120 --> 01:05:38,360
So, there was an issue,

01:05:38,360 --> 01:05:39,500
got it fixed,

01:05:39,500 --> 01:05:40,430
but the biggest issue,

01:05:40,430 --> 01:05:42,310
and I think this is the biggest contention

01:05:42,310 --> 01:05:44,730
is the semantics on the lease.

01:05:44,730 --> 01:05:46,650
So, I kinda glossed over the fact

01:05:46,650 --> 01:05:49,960
that, in order to actually do this pin,

01:05:49,960 --> 01:05:52,580
when the GUP code is actually walking the pages

01:05:52,580 --> 01:05:56,430
and it finds the data file pages,

01:05:56,430 --> 01:05:58,400
it then says, "oh, wait,

01:05:58,400 --> 01:05:59,680
"I can't take this pin

01:05:59,680 --> 01:06:01,000
"without a lease,"

01:06:01,000 --> 01:06:03,380
and so that was also part of what came out of LSF

01:06:03,380 --> 01:06:06,550
is that in order to be able to pin pages with a file,

01:06:06,550 --> 01:06:08,240
we needed this lease mechanism

01:06:08,240 --> 01:06:09,290
such that, basically,

01:06:09,290 --> 01:06:11,170
the file system was being told,

01:06:13,850 --> 01:06:15,750
"the layout of this file is pinned,

01:06:15,750 --> 01:06:17,090
"the layout can't change,

01:06:17,090 --> 01:06:18,450
"and I can't do anything with it

01:06:18,450 --> 01:06:21,550
"as long as this lease or this pin exists."

01:06:21,550 --> 01:06:22,383
- Sorry.

01:06:23,320 --> 01:06:26,020
So, John is busy adding a pin

01:06:26,020 --> 01:06:27,420
that tells the file system

01:06:27,420 --> 01:06:30,350
that the pages can't be messed with.

01:06:30,350 --> 01:06:32,750
So, you're adding yet another pin.

01:06:32,750 --> 01:06:33,710
- No. - So the pages

01:06:33,710 --> 01:06:34,543
can't be messed with.

01:06:34,543 --> 01:06:36,410
- So, there are two things here.

01:06:36,410 --> 01:06:37,870
One is a pin,

01:06:37,870 --> 01:06:39,780
which is gonna be pin countered

01:06:39,780 --> 01:06:41,480
in the struct page,

01:06:41,480 --> 01:06:43,940
and that's ultimately what says

01:06:43,940 --> 01:06:45,460
to the file system,

01:06:45,460 --> 01:06:46,900
"you cannot do write back on this

01:06:46,900 --> 01:06:49,282
"because I'm already, for example,

01:06:49,282 --> 01:06:50,340
"DMA-ing just to the page."

01:06:50,340 --> 01:06:51,390
So, that's one thing,

01:06:52,510 --> 01:06:55,010
and that's gonna be used by direct IO,

01:06:55,010 --> 01:06:56,980
by all the short-term, long-term,

01:06:56,980 --> 01:06:57,813
all the users,

01:06:58,780 --> 01:07:00,000
but then, there is the second thing

01:07:00,866 --> 01:07:02,700
that, for the long-term users,

01:07:02,700 --> 01:07:04,830
you have other set of problems,

01:07:04,830 --> 01:07:06,680
like you have to fail truncate

01:07:06,680 --> 01:07:07,730
or do some other stuff.

01:07:07,730 --> 01:07:10,700
So, the long-term users will have to have a lease

01:07:10,700 --> 01:07:12,690
so that you can fail truncate

01:07:12,690 --> 01:07:14,910
or, basically, the file system knows

01:07:14,910 --> 01:07:17,110
that this is not just wait for a bit

01:07:17,110 --> 01:07:18,700
and it will get better.

01:07:18,700 --> 01:07:19,690
- Yeah, I misspoke.

01:07:19,690 --> 01:07:22,602
Long-term pins will require the lease.

01:07:22,602 --> 01:07:25,179
That's a more correct statement.

01:07:25,179 --> 01:07:28,070
- Yeah, it's actually coming together pretty nicely.

01:07:28,070 --> 01:07:31,700
So, you've got basically two flags to talk about,

01:07:31,700 --> 01:07:35,160
follow long-term and follow pinned,

01:07:35,160 --> 01:07:37,120
and so in all these cases,

01:07:37,120 --> 01:07:38,740
you're gonna need to set follow pinned,

01:07:38,740 --> 01:07:39,840
and in some of these cases,

01:07:39,840 --> 01:07:41,740
you'll need to set follow long-term,

01:07:41,740 --> 01:07:44,010
and long-term is associated

01:07:44,010 --> 01:07:45,410
with the leases,

01:07:45,410 --> 01:07:47,950
and pinned is associated with that special ref count

01:07:47,950 --> 01:07:49,452
and put_user_pages.

01:07:49,452 --> 01:07:51,882
(Jason speaking off mic)

01:07:51,882 --> 01:07:53,450
- [Jason] Can we name that something better?

01:07:53,450 --> 01:07:54,283
(laughing)

01:07:54,283 --> 01:07:55,116
- Whatever.

01:07:55,116 --> 01:07:55,949
- [Jason] Okay.

01:07:55,949 --> 01:07:56,820
- I don't really care,

01:07:56,820 --> 01:07:58,020
if you have better name.

01:07:59,200 --> 01:08:00,760
- [Jason] It just seems to me that that one

01:08:00,760 --> 01:08:02,570
is all about allowing the pages

01:08:02,570 --> 01:08:03,880
to be written to,

01:08:03,880 --> 01:08:05,090
allowing dirty to be called

01:08:05,090 --> 01:08:05,923
and maybe that.

01:08:06,890 --> 01:08:07,890
- [Ira] You mean pin

01:08:09,036 --> 01:08:09,900
or the meaning of that flag? - No.

01:08:09,900 --> 01:08:11,439
The follow pinned flag

01:08:11,439 --> 01:08:15,330
means that the page has to be released

01:08:15,330 --> 01:08:18,300
with put_user_page, and it's a direct tie

01:08:18,300 --> 01:08:20,510
to the new pin count.

01:08:21,370 --> 01:08:22,556
- [Jason] Right.

01:08:22,556 --> 01:08:23,556
But the new pin count

01:08:23,556 --> 01:08:25,647
is only about set page dirty, right?

01:08:25,647 --> 01:08:26,648
- No.

01:08:26,648 --> 01:08:30,500
- It's about setting file systems

01:08:30,500 --> 01:08:32,060
and also mm,

01:08:32,060 --> 01:08:34,920
that there is someone who is physically accessing the page

01:08:34,920 --> 01:08:36,950
and you know nothing about it.

01:08:36,950 --> 01:08:38,060
Yeah.

01:08:38,060 --> 01:08:39,570
- And you have to count how many of those there are.

01:08:39,570 --> 01:08:40,940
- So basically, you cannot,

01:08:41,840 --> 01:08:43,160
if you have page reference,

01:08:43,160 --> 01:08:46,110
we still do all sorts of stuff with the page

01:08:46,110 --> 01:08:48,500
when the page reference count is elevated,

01:08:48,500 --> 01:08:51,260
but with pinned, we have to be really much more careful

01:08:51,260 --> 01:08:53,520
because someone is operating on the page data.

01:08:54,592 --> 01:08:56,080
- [Ira] Right, okay.

01:08:56,080 --> 01:08:57,090
- Get in line.

01:08:57,090 --> 01:09:00,050
- Yeah, I might think about that a little bit more.

01:09:00,050 --> 01:09:01,432
Anyway.

01:09:01,432 --> 01:09:02,265
So, yeah.

01:09:02,265 --> 01:09:03,270
I kinda glossed over that

01:09:03,270 --> 01:09:04,850
that we need these leases.

01:09:04,850 --> 01:09:06,870
So, a lot of the debate on the mailing list

01:09:06,870 --> 01:09:09,170
was who owns the lease?

01:09:09,170 --> 01:09:10,280
Who can remove the lease?

01:09:10,280 --> 01:09:11,630
And when can it be removed?

01:09:12,470 --> 01:09:13,490
Okay?

01:09:13,490 --> 01:09:15,910
Finally, there's this concept,

01:09:15,910 --> 01:09:18,760
and I think if you go back to the picture I had,

01:09:18,760 --> 01:09:20,940
there's this concept of when

01:09:20,940 --> 01:09:25,140
you lose all of these connections

01:09:25,140 --> 01:09:26,260
to this data file,

01:09:27,670 --> 01:09:29,600
effectively, this lease object,

01:09:29,600 --> 01:09:31,390
this is kind of what we're referring to

01:09:31,390 --> 01:09:33,740
as it's not really,

01:09:33,740 --> 01:09:36,140
there's this lease thing that was called

01:09:36,140 --> 01:09:38,020
that's hanging off the data file,

01:09:38,020 --> 01:09:40,400
that object still exists in the kernel,

01:09:40,400 --> 01:09:43,090
but from a user space perspective,

01:09:43,090 --> 01:09:44,550
nobody really has the lease

01:09:44,550 --> 01:09:46,190
because you can't call

01:09:46,190 --> 01:09:47,970
and actually release that lease anymore

01:09:47,970 --> 01:09:50,540
if you close these file descriptors.

01:09:50,540 --> 01:09:51,990
So, there was a lot of debate

01:09:52,864 --> 01:09:54,090
on when can you close a file descriptor?

01:09:54,090 --> 01:09:55,450
Can we hang the file descriptor?

01:09:55,450 --> 01:09:57,729
Can we not hang the file descriptor?

01:09:57,729 --> 01:09:59,200
What happens?

01:10:00,050 --> 01:10:01,530
I was kinda looking at it.

01:10:01,530 --> 01:10:04,718
Well, maybe we don't just let this happen.

01:10:04,718 --> 01:10:07,880
But there are some RDMA use cases

01:10:07,880 --> 01:10:09,140
that are coming down the pipe,

01:10:09,140 --> 01:10:12,630
there's a presentation in a couple sections here

01:10:13,930 --> 01:10:15,960
who people are wanting

01:10:15,960 --> 01:10:17,980
to actually take these file descriptors

01:10:17,980 --> 01:10:20,450
and send them to other processes.

01:10:20,450 --> 01:10:22,010
So, I really believe

01:10:22,010 --> 01:10:24,360
that having these zombie leases is okay.

01:10:26,870 --> 01:10:29,770
So, I said that I actually fixed the struct file.

01:10:29,770 --> 01:10:32,200
There was a circular reference in the struct file,

01:10:32,200 --> 01:10:34,660
and so this is the picture of the current state

01:10:34,660 --> 01:10:35,610
of my patches,

01:10:36,750 --> 01:10:38,190
and they haven't been released yet,

01:10:38,190 --> 01:10:39,430
but I just wanted to,

01:10:39,430 --> 01:10:41,220
'cause pictures are cool,

01:10:41,220 --> 01:10:42,310
at least for me,

01:10:42,310 --> 01:10:43,670
'cause I'm a Mac guy.

01:10:44,818 --> 01:10:46,966
(laughing)

01:10:46,966 --> 01:10:47,965
Yeah, I know.

01:10:47,965 --> 01:10:48,798
Should I say that at Linux?

01:10:48,798 --> 01:10:49,631
- [Jason] No.

01:10:49,631 --> 01:10:50,716
No, you shouldn't, (laughing)

01:10:50,716 --> 01:10:51,819
and you also don't work on RDMA.

01:10:51,819 --> 01:10:53,699
(laughing) - Shh.

01:10:53,699 --> 01:10:54,970
I don't work on it.

01:10:54,970 --> 01:10:56,670
- [Jason] Because you work for intel.

01:10:56,670 --> 01:10:57,980
- No!

01:10:57,980 --> 01:11:00,587
- I would call those other leases defunct.

01:11:00,587 --> 01:11:03,190
That matches more (speech covered by coughing)

01:11:03,190 --> 01:11:05,150
- Defunct could be, yeah.

01:11:05,150 --> 01:11:05,983
Yeah.

01:11:05,983 --> 01:11:06,816
- [Jason] They're not defunct

01:11:06,816 --> 01:11:07,649
and they're not zombies.

01:11:07,649 --> 01:11:11,010
They're held by an object that's internal to the kernel,

01:11:11,010 --> 01:11:11,843
or not even internal.

01:11:11,843 --> 01:11:13,170
They're held by an mr object,

01:11:13,170 --> 01:11:15,570
which is actually exposed to user space.

01:11:15,570 --> 01:11:16,780
From what I can gather,

01:11:16,780 --> 01:11:19,130
all of this is about debugging for the admin

01:11:19,130 --> 01:11:21,390
to be able to see the lease object

01:11:21,390 --> 01:11:22,270
under the thing that's holding it,

01:11:22,270 --> 01:11:23,610
and the thing that's holding it,

01:11:23,610 --> 01:11:26,080
at least in RDMA's case, is the mr.

01:11:26,080 --> 01:11:26,913
- [Ira] Right.

01:11:26,913 --> 01:11:28,570
- Yeah, I agree,

01:11:28,570 --> 01:11:29,880
but the thing is

01:11:29,880 --> 01:11:31,310
that the lease,

01:11:31,310 --> 01:11:32,970
which is, yeah,

01:11:32,970 --> 01:11:34,770
this thing here.

01:11:34,770 --> 01:11:37,810
So, it has a notion of owner,

01:11:37,810 --> 01:11:41,420
and the owner is going to be this guy,

01:11:42,360 --> 01:11:44,730
and actually, this file descriptor,

01:11:44,730 --> 01:11:46,780
this arrow is actually the file descriptor,

01:11:46,780 --> 01:11:49,490
so the owner will be going to be this arrow,

01:11:49,490 --> 01:11:51,170
and when this arrow goes away,

01:11:51,170 --> 01:11:54,320
the lease is in kind of a strange state there.

01:11:54,320 --> 01:11:56,260
- [Jason] Why does the lease have an owner?

01:11:56,260 --> 01:11:58,700
- So, there are two purposes.

01:11:58,700 --> 01:12:01,280
One is that when something happens with the lease,

01:12:01,280 --> 01:12:03,762
you are supposed to send a signal,

01:12:03,762 --> 01:12:07,410
and the signal has to have the file descriptor

01:12:07,410 --> 01:12:09,620
in its whatever.

01:12:09,620 --> 01:12:10,570
- [Jason] That makes sense.

01:12:10,570 --> 01:12:13,020
- So basically, the lease has to know

01:12:13,020 --> 01:12:16,194
who to signal and what file descriptor is it.

01:12:16,194 --> 01:12:18,760
- [Jason] We talked about this, too.

01:12:18,760 --> 01:12:20,230
- That gets to the next point

01:12:20,230 --> 01:12:22,600
of this exclusive lease,

01:12:22,600 --> 01:12:23,850
or unbreakable lease,

01:12:23,850 --> 01:12:27,340
which I actually do like John's name of unbreakable lease,

01:12:27,340 --> 01:12:29,550
because if it's an unbreakable lease,

01:12:29,550 --> 01:12:31,500
there is no SIGIO sent.

01:12:31,500 --> 01:12:34,810
So, that becomes the lead point, I believe.

01:12:34,810 --> 01:12:35,643
- This is more

01:12:37,480 --> 01:12:38,720
like aesthetic kind of problem,

01:12:38,720 --> 01:12:41,450
because we don't expect signals

01:12:41,450 --> 01:12:42,700
to be needed for this,

01:12:42,700 --> 01:12:46,073
but still, the lease is in non-started state, let's say,

01:12:46,073 --> 01:12:47,610
and the second thing is,

01:12:47,610 --> 01:12:51,010
and I didn't manage to check the code in detail,

01:12:51,010 --> 01:12:53,750
but the lease has the semantics

01:12:53,750 --> 01:12:56,407
that it's not a lock.rs,

01:12:56,407 --> 01:13:01,260
so if you get an exclusive lease,

01:13:01,260 --> 01:13:03,380
which means that nobody's supposed to change

01:13:03,380 --> 01:13:04,860
the layout of the file,

01:13:06,183 --> 01:13:07,250
then the owner of the lease

01:13:07,250 --> 01:13:08,660
is still supposed to be able

01:13:08,660 --> 01:13:09,960
to do anything with the file,

01:13:09,960 --> 01:13:12,860
so you can change the file under your hands, basically.

01:13:12,860 --> 01:13:14,601
- [Jason] Yeah, Dave mentioned

01:13:14,601 --> 01:13:15,434
that that's a big problem for this.

01:13:15,434 --> 01:13:16,830
- That's the supposed semantics.

01:13:16,830 --> 01:13:19,110
- This picture. - But any other process,

01:13:19,110 --> 01:13:20,240
which doesn't own the lease

01:13:20,240 --> 01:13:21,950
is not supposed to be able to do it,

01:13:21,950 --> 01:13:24,370
and he's supposed to block, basically,

01:13:24,370 --> 01:13:26,458
and he's going to block

01:13:26,458 --> 01:13:29,950
because when the file layout changes,

01:13:29,950 --> 01:13:31,950
we will call break lease,

01:13:31,950 --> 01:13:34,050
and the owner just passes fine

01:13:34,050 --> 01:13:35,990
and the known owner will get blocked

01:13:35,990 --> 01:13:37,360
on the lease.

01:13:37,360 --> 01:13:38,520
- [Jason] So, that does speak to the concept

01:13:38,520 --> 01:13:40,202
that these leases do not have owners.

01:13:40,202 --> 01:13:41,570
- [Ira] No, they do.

01:13:42,463 --> 01:13:43,693
- They do. - But they don't

01:13:43,693 --> 01:13:44,526
because there's no one that's allowed

01:13:44,526 --> 01:13:46,768
to change the layout once these things are created.

01:13:46,768 --> 01:13:47,710
That's the semantic we need.

01:13:47,710 --> 01:13:50,750
- Right, so that's where I differ with what you said

01:13:50,750 --> 01:13:55,230
is what I actually implemented is EDEADLOCK.

01:13:55,230 --> 01:13:58,500
So, if the owner tries to break this lease

01:13:58,500 --> 01:13:59,360
through some other call,

01:13:59,360 --> 01:14:00,899
like another thread or something,

01:14:00,899 --> 01:14:02,370
then he's gonna get a deadlock

01:14:02,370 --> 01:14:03,690
because he's now done something

01:14:03,690 --> 01:14:06,110
where he said, "I don't want this lease broken,

01:14:06,110 --> 01:14:08,320
"but now I tried to break it."

01:14:08,320 --> 01:14:09,153
- Yeah, okay.

01:14:09,153 --> 01:14:13,310
So, you are now changing the lease,

01:14:13,310 --> 01:14:15,450
so leases are not invented

01:14:15,450 --> 01:14:16,720
for this kind of thing.

01:14:16,720 --> 01:14:19,370
Leases exist for PNFS

01:14:19,370 --> 01:14:21,410
is probably the most prominent users,

01:14:21,410 --> 01:14:22,310
but there are others,

01:14:22,310 --> 01:14:25,180
but PNF is probably the easiest to understand.

01:14:25,180 --> 01:14:30,180
So, PNFS users will basically take this lease

01:14:30,680 --> 01:14:32,390
to pin the file layout.

01:14:32,390 --> 01:14:34,880
So basically, the client looks

01:14:34,880 --> 01:14:36,540
which physical blocks are used,

01:14:36,540 --> 01:14:38,550
basically modifies these blocks,

01:14:38,550 --> 01:14:40,260
changes allocation of the file.

01:14:40,260 --> 01:14:42,040
He just doesn't want other clients

01:14:42,040 --> 01:14:43,830
to do the same thing with the file,

01:14:43,830 --> 01:14:44,930
to not change them up.

01:14:47,144 --> 01:14:49,670
So, that's why the current lease semantics

01:14:49,670 --> 01:14:51,810
is that the owner of the lease can do anything

01:14:51,810 --> 01:14:53,680
because he has it cached locally

01:14:53,680 --> 01:14:54,880
and knows what he's doing

01:14:54,880 --> 01:14:57,930
and know everybody else blocks.

01:14:57,930 --> 01:15:00,320
That's why the semantics is currently defined,

01:15:00,320 --> 01:15:02,700
and if you want to define something else,

01:15:02,700 --> 01:15:03,533
sure, you can,

01:15:03,533 --> 01:15:05,430
but it has to be clearly explained

01:15:05,430 --> 01:15:06,520
what the semantics is

01:15:06,520 --> 01:15:07,353
and define it

01:15:07,353 --> 01:15:09,130
so that there's no confusion.

01:15:09,130 --> 01:15:10,510
- I agree with that.

01:15:10,510 --> 01:15:12,430
So, I'm working on nailing down

01:15:12,430 --> 01:15:14,730
what those semantics exactly are

01:15:14,730 --> 01:15:17,260
because the other thing that the current patch set has

01:15:17,260 --> 01:15:19,360
is a concept of a layout,

01:15:19,360 --> 01:15:22,100
like flag that is a layout lease,

01:15:22,100 --> 01:15:25,180
and I don't think that's fully needed.

01:15:25,180 --> 01:15:27,790
I think all we really need is an unbreakable flag

01:15:27,790 --> 01:15:31,238
and to extend the semantics of what a re-lease means,

01:15:31,238 --> 01:15:33,370
and this is kinda part of the problem,

01:15:35,031 --> 01:15:36,210
and this is why I added the layout flag,

01:15:36,210 --> 01:15:39,620
is by saying we want it an unbreakable layout lease,

01:15:39,620 --> 01:15:42,135
it meant that we were,

01:15:42,135 --> 01:15:45,010
well, we're actually taking a read lease,

01:15:45,010 --> 01:15:47,580
but we're taking a read lease on the layout.

01:15:49,330 --> 01:15:51,240
So, we're not modifying the layout,

01:15:51,240 --> 01:15:53,140
we only wanna be able to read it,

01:15:53,140 --> 01:15:55,880
but the data is right.

01:15:55,880 --> 01:15:58,330
So, the semantics of the lease

01:15:58,330 --> 01:15:59,650
are somewhat confusing

01:15:59,650 --> 01:16:02,290
because we're not taking a write lease,

01:16:02,290 --> 01:16:03,710
even though we're writing to the data

01:16:03,710 --> 01:16:05,553
and we have these pins

01:16:05,553 --> 01:16:06,386
and we have RDMA going to it,

01:16:06,386 --> 01:16:08,370
but it's a read lease for the layout,

01:16:08,370 --> 01:16:09,510
which is unbreakable,

01:16:09,510 --> 01:16:12,500
which means a write lease will try to break it, but can't,

01:16:12,500 --> 01:16:14,660
and it will get either EDEADLOCK

01:16:14,660 --> 01:16:15,780
if it's the same process,

01:16:15,780 --> 01:16:18,500
or basically just an ETEXT busy,

01:16:22,218 --> 01:16:24,710
and then the syadmin can take.

01:16:24,710 --> 01:16:25,580
- Okay.

01:16:25,580 --> 01:16:27,860
- Does that sound reasonable?

01:16:27,860 --> 01:16:28,693
- Yes.

01:16:28,693 --> 01:16:29,610
It would be also,

01:16:29,610 --> 01:16:31,110
another note, it would be good

01:16:32,150 --> 01:16:34,560
to explain the RDMA requirements,

01:16:34,560 --> 01:16:36,170
because you say you have problem

01:16:36,170 --> 01:16:37,620
with the process itself changing

01:16:37,620 --> 01:16:40,340
and on other process being able to change the layout.

01:16:41,930 --> 01:16:43,770
- That's what we're after here.

01:16:43,770 --> 01:16:46,360
The kernel is gonna set up DMA to these pages.

01:16:46,360 --> 01:16:47,193
- Yeah.

01:16:47,193 --> 01:16:49,782
- And once that DMA's established,

01:16:49,782 --> 01:16:52,650
the file system cannot change those pages,

01:16:52,650 --> 01:16:54,340
and I don't care if it's this process

01:16:54,340 --> 01:16:55,992
or another process,

01:16:55,992 --> 01:16:56,993
the file system cannot be

01:16:56,993 --> 01:16:57,998
- Yeah, okay.

01:16:57,998 --> 01:16:59,450
That would be solved by. - The layout is static.

01:16:59,450 --> 01:17:03,170
The layout is also pinned through the lease.

01:17:03,170 --> 01:17:06,020
The data can be written to,

01:17:06,020 --> 01:17:07,570
and we don't want the file system

01:17:07,570 --> 01:17:10,470
to try to write that data back.

01:17:10,470 --> 01:17:11,303
- Okay.

01:17:11,303 --> 01:17:13,390
But then, that really matches

01:17:13,390 --> 01:17:15,670
the kind of read layout lease, yeah.

01:17:15,670 --> 01:17:17,590
So basically, you don't want the layout to change,

01:17:17,590 --> 01:17:20,140
but even yourself are not allowed to change it.

01:17:20,140 --> 01:17:22,630
- Yes, absolutely, because if the same process

01:17:22,630 --> 01:17:24,170
tried to change it,

01:17:24,170 --> 01:17:25,003
they would break their own DMA

01:17:25,003 --> 01:17:27,410
that they just set up, unwillingly.

01:17:27,410 --> 01:17:29,287
We can't allow that. - It's not just,

01:17:29,287 --> 01:17:31,800
it's from a correctness perspective.

01:17:31,800 --> 01:17:33,542
Once we're doing DMA,

01:17:33,542 --> 01:17:35,490
the DMA cannot be controlled and stopped,

01:17:35,490 --> 01:17:36,810
we can't allow the pages

01:17:36,810 --> 01:17:38,750
to become somehow incoherent

01:17:38,750 --> 01:17:40,400
with that DMA.

01:17:40,400 --> 01:17:42,380
That's the whole DAX problem in a nutshell.

01:17:42,380 --> 01:17:43,590
- So, what do you expect, then,

01:17:43,590 --> 01:17:47,580
to happen when you will try

01:17:47,580 --> 01:17:52,580
to pin page that doesn't have underlying storage, like this?

01:17:53,340 --> 01:17:54,420
So, you can take a lease,

01:17:54,420 --> 01:17:55,980
the file doesn't have to be allocated.

01:17:55,980 --> 01:17:57,590
It can be just empty file.

01:17:57,590 --> 01:17:59,739
- Yeah, but then we'll get_user_pages of pages.

01:17:59,739 --> 01:18:02,599
- But get_user_pages will give you back

01:18:02,599 --> 01:18:04,550
page cache pages.

01:18:04,550 --> 01:18:06,128
It's perfectly happy to do it,

01:18:06,128 --> 01:18:08,500
but there is no underlying storage,

01:18:09,430 --> 01:18:11,179
but you don't care, really.

01:18:11,179 --> 01:18:12,860
- DMA doesn't care, right?

01:18:12,860 --> 01:18:14,420
As long as when we're done the DMA,

01:18:14,420 --> 01:18:15,850
it all goes puts back.

01:18:15,850 --> 01:18:17,274
- Yeah, okay.

01:18:17,274 --> 01:18:18,570
- So, Ira.

01:18:18,570 --> 01:18:21,190
- But, and if you do it in case of DAX.

01:18:21,190 --> 01:18:23,380
So, if you do it in case of DAX,

01:18:23,380 --> 01:18:26,780
then basically, that would be block allocation happening

01:18:26,780 --> 01:18:29,220
inside get_user_pages, basically.

01:18:29,220 --> 01:18:30,670
- And that starts to sound a little DEADLOCK-y.

01:18:30,670 --> 01:18:33,090
- And so, that is allowed to happen or not?

01:18:33,090 --> 01:18:34,180
- No, because with DAX,

01:18:34,180 --> 01:18:35,690
the pages are the back.

01:18:35,690 --> 01:18:37,240
- They're just out of physical storage.

01:18:37,240 --> 01:18:38,310
- But I'm saying, you want a workflow

01:18:38,310 --> 01:18:39,960
where you say, "layout lease,

01:18:39,960 --> 01:18:41,360
"and then call get_user_pages,"

01:18:41,360 --> 01:18:44,100
and the get_user_pages may cause allocations,

01:18:44,100 --> 01:18:45,960
but it can't because you have a layout lease.

01:18:45,960 --> 01:18:47,820
That doesn't sound right to me.

01:18:47,820 --> 01:18:49,250
- Yeah, so what you do?

01:18:51,662 --> 01:18:52,495
So, we could just.

01:18:54,301 --> 01:18:56,760
So, the pinning could just bail out with an error

01:18:56,760 --> 01:18:58,630
if it finds that actually

01:18:58,630 --> 01:19:00,160
it would have to cause block allocation

01:19:00,160 --> 01:19:03,230
if we basically get EDEADLOCK or whatever,

01:19:03,230 --> 01:19:04,890
or would block indefinitely,

01:19:04,890 --> 01:19:07,138
but you have to somehow devise it

01:19:07,138 --> 01:19:08,320
so that you don't DEADLOCK against yourself.

01:19:08,320 --> 01:19:09,730
- Yeah, and you have to make.

01:19:09,730 --> 01:19:11,630
- But that puts another requirement

01:19:12,816 --> 01:19:14,860
on the user to touch the pages first or something.

01:19:14,860 --> 01:19:15,693
- I think it's okay.

01:19:15,693 --> 01:19:17,610
These are fancy apps.

01:19:17,610 --> 01:19:20,210
You could require fallocate

01:19:20,210 --> 01:19:22,560
prior to taking that pin

01:19:23,740 --> 01:19:26,140
and if you didn't allocate ahead of time,

01:19:26,140 --> 01:19:28,120
then that's your own problem.

01:19:28,120 --> 01:19:30,690
- So, my initial idea

01:19:30,690 --> 01:19:31,523
would be that we would

01:19:31,523 --> 01:19:35,121
just make sure that you bail out

01:19:35,121 --> 01:19:37,970
if the underlying storage isn't allocated

01:19:37,970 --> 01:19:38,840
and you need it,

01:19:38,840 --> 01:19:40,010
like for page cache, we don't care,

01:19:40,010 --> 01:19:41,200
but of DAX,

01:19:41,200 --> 01:19:43,130
we would have to allocate underlying storage,

01:19:43,130 --> 01:19:45,080
which conflicts with holding the lease.

01:19:46,292 --> 01:19:47,292
- You'll get an unbreakable

01:19:47,292 --> 01:19:49,150
or you'll get your EDEADLOCK

01:19:49,150 --> 01:19:50,890
(speech muffled)

01:19:50,890 --> 01:19:53,132
- Yeah, that's probably what'll happen right now.

01:19:53,132 --> 01:19:55,150
- And then, since the user is the one

01:19:55,150 --> 01:19:57,530
who calls the F control to set the lease,

01:19:57,530 --> 01:19:59,520
the user's responsible for allocating

01:19:59,520 --> 01:20:01,050
and dealing with any races,

01:20:01,050 --> 01:20:01,883
'cause it's race-y, too.

01:20:01,883 --> 01:20:03,570
I do fallocate, then I get my lease,

01:20:03,570 --> 01:20:04,860
but am I still allocated

01:20:04,860 --> 01:20:07,340
or did something happen in the meantime?

01:20:08,270 --> 01:20:09,880
It's not ideal.

01:20:11,840 --> 01:20:13,500
Maybe it would be better if you started,

01:20:13,500 --> 01:20:15,140
you get the lease that makes it exclusive

01:20:15,140 --> 01:20:15,990
for your process,

01:20:15,990 --> 01:20:17,380
then you do the fallocate,

01:20:17,380 --> 01:20:19,437
then you switch that lease

01:20:19,437 --> 01:20:20,700
to be blocked permanently

01:20:20,700 --> 01:20:22,080
for even yourself.

01:20:22,080 --> 01:20:23,080
You see what I mean?

01:20:23,080 --> 01:20:24,090
- Yeah, yeah, yeah.

01:20:26,239 --> 01:20:27,388
- Are we getting this in notes?

01:20:27,388 --> 01:20:29,320
(laughing)

01:20:29,320 --> 01:20:31,325
- [Man] This is a pretty complex discussion,

01:20:31,325 --> 01:20:32,158
hard to caption in these notes.

01:20:32,158 --> 01:20:33,812
- Yeah.

01:20:33,812 --> 01:20:34,812
No, that's okay.

01:20:34,812 --> 01:20:35,810
- It's video recorded though.

01:20:35,810 --> 01:20:36,809
- It is.

01:20:36,809 --> 01:20:37,650
- Yeah, I'm gonna watch the video.

01:20:37,650 --> 01:20:39,816
- You're gonna watch. (laughing)

01:20:39,816 --> 01:20:40,850
- I told Leon yesterday,

01:20:40,850 --> 01:20:41,894
it's recorded, right?

01:20:41,894 --> 01:20:44,890
- [Jason] So, we're getting to the last four minutes here.

01:20:44,890 --> 01:20:46,440
- I haven't thought about that.

01:20:47,768 --> 01:20:49,440
I'm not a file system guy.

01:20:49,440 --> 01:20:51,518
I don't do anything anymore.

01:20:51,518 --> 01:20:53,290
(laughing)

01:20:53,290 --> 01:20:55,060
Okay, so anyway.

01:20:57,610 --> 01:20:58,770
Yeah, all right.

01:20:58,770 --> 01:21:01,350
But generally, that semantic sounds okay.

01:21:01,350 --> 01:21:02,325
- Yeah.

01:21:02,325 --> 01:21:04,310
So, that's why I wanted,

01:21:04,310 --> 01:21:07,720
like probably let's start with RDMA constraint

01:21:07,720 --> 01:21:11,170
and what RDMA would like to see, the semantics,

01:21:11,170 --> 01:21:14,440
then define the new type of lease,

01:21:14,440 --> 01:21:19,330
describe it, and then get to the particular linking

01:21:19,330 --> 01:21:21,280
or file structures and stuff like that,

01:21:22,660 --> 01:21:25,330
because if we don't get the first two steps,

01:21:25,330 --> 01:21:27,810
then the people looking at the step three,

01:21:27,810 --> 01:21:30,080
with diagram like this,

01:21:30,080 --> 01:21:31,130
they'll scratch their head and say,

01:21:31,130 --> 01:21:32,910
"oh, why do this so complicated?

01:21:32,910 --> 01:21:34,760
"And what's actually the problem?"

01:21:34,760 --> 01:21:38,723
And it's different than anything else we do and why?

01:21:38,723 --> 01:21:39,777
(laughing)

01:21:39,777 --> 01:21:41,240
- Okay, okay.

01:21:41,240 --> 01:21:42,440
And I think

01:21:42,440 --> 01:21:45,490
the current lease calls

01:21:45,490 --> 01:21:48,420
allow for a downgrade, upgrade,

01:21:48,420 --> 01:21:50,480
so I think what you're saying,

01:21:50,480 --> 01:21:51,540
you could take a release,

01:21:51,540 --> 01:21:53,260
you could fallocate,

01:21:55,515 --> 01:21:58,450
and that ensures nobody else has access to the file.

01:21:58,450 --> 01:22:00,230
- So, your fallocate is race-y.

01:22:00,230 --> 01:22:02,560
- And then, you allocate it

01:22:02,560 --> 01:22:06,090
and then you upgrade the re-lease to unbreakable,

01:22:06,090 --> 01:22:08,110
and then you can pin it.

01:22:08,110 --> 01:22:09,970
- That makes sense when you say it out loud.

01:22:09,970 --> 01:22:13,330
- And I don't think that's really that hard to do.

01:22:13,330 --> 01:22:14,219
Sound reasonable?

01:22:14,219 --> 01:22:16,670
I didn't think about the file system mechanics.

01:22:18,410 --> 01:22:20,280
- Why can't you just fallocate before?

01:22:20,280 --> 01:22:21,590
- Well, it's race-y then.

01:22:21,590 --> 01:22:24,250
It's race-y because if you don't have a lease

01:22:24,250 --> 01:22:26,280
and some other process can go and change the lease

01:22:26,280 --> 01:22:27,620
or make the pages callable

01:22:27,620 --> 01:22:28,760
or do something.

01:22:28,760 --> 01:22:29,820
- Yeah, so I guess.

01:22:29,820 --> 01:22:31,630
- By taking the re-lease to begin with,

01:22:31,630 --> 01:22:33,950
nobody else can have the file descriptor open

01:22:33,950 --> 01:22:34,980
in any other process.

01:22:34,980 --> 01:22:37,050
So, that basically guarantees nobody else

01:22:37,050 --> 01:22:40,760
is fallocate half your data sizes.

01:22:40,760 --> 01:22:43,060
- Or ftruncating at the same time you're fallocating.

01:22:43,060 --> 01:22:44,310
- Right, right, right.

01:22:44,310 --> 01:22:46,062
- Which would be just great.

01:22:46,062 --> 01:22:47,341
- Yeah.

01:22:47,341 --> 01:22:48,341
Yeah.

01:22:48,341 --> 01:22:49,174
- Okay. - Okay.

01:22:49,174 --> 01:22:50,007
- I guess what Jason said,

01:22:50,007 --> 01:22:51,752
first they could exclusively

01:22:51,752 --> 01:22:52,585
so that you can modify the file

01:22:52,585 --> 01:22:53,470
and no one else can,

01:22:55,260 --> 01:22:57,330
set up the file as you need it,

01:22:57,330 --> 01:22:59,700
and then if you want the self-protection,

01:22:59,700 --> 01:23:01,900
then downgrade to read.

01:23:01,900 --> 01:23:03,850
- I think it makes the flag

01:23:03,850 --> 01:23:05,430
that Ira was trying to define really clear what it is.

01:23:05,430 --> 01:23:07,230
It's what you said, self-protection.

01:23:08,500 --> 01:23:09,920
No one is allowed to change this

01:23:09,920 --> 01:23:11,100
is what the flag says

01:23:11,100 --> 01:23:12,530
and it cannot be broken,

01:23:12,530 --> 01:23:14,190
so there's no SIGIOs,

01:23:14,190 --> 01:23:15,820
I can't change it, as the owner,

01:23:15,820 --> 01:23:17,540
there's no such thing as an owner.

01:23:17,540 --> 01:23:18,800
It's like a special mode.

01:23:18,800 --> 01:23:21,210
- It might be better to take a write lease

01:23:21,210 --> 01:23:23,180
than downgrade it to a read unbreakable.

01:23:23,180 --> 01:23:24,600
- Yeah.

01:23:24,600 --> 01:23:26,110
- Because that's the semantics we want.

01:23:26,110 --> 01:23:27,410
We wanna be able to write.

01:23:28,278 --> 01:23:29,980
- Yeah, that makes sense. - And change the allocation.

01:23:29,980 --> 01:23:31,260
- Change the layout. - Set the allocation,

01:23:31,260 --> 01:23:32,970
and then do a read unbreakable,

01:23:32,970 --> 01:23:35,180
which is fix this.

01:23:35,180 --> 01:23:37,420
Not fix, you know.

01:23:37,420 --> 01:23:38,253
Static.

01:23:38,253 --> 01:23:39,190
Make static.

01:23:39,190 --> 01:23:40,616
- Yeah, make it static.

01:23:40,616 --> 01:23:42,990
- Dave, actually, and we've been going

01:23:42,990 --> 01:23:43,823
back and forth about this,

01:23:43,823 --> 01:23:46,870
you talked about calling it sealing,

01:23:46,870 --> 01:23:47,780
seal the file,

01:23:47,780 --> 01:23:48,890
allocate it, do everything you do,

01:23:48,890 --> 01:23:49,723
and seal it.

01:23:50,590 --> 01:23:51,960
- Yeah, there's precedent in the APIs

01:23:51,960 --> 01:23:53,510
and user space for that idea.

01:23:53,510 --> 01:23:54,930
- Okay. - Yeah.

01:23:54,930 --> 01:23:57,130
- That might make it clear to other people.

01:23:57,130 --> 01:23:58,540
- I'll be watching this video back

01:23:58,540 --> 01:24:00,040
and I'm gonna write that up. - I captured

01:24:00,040 --> 01:24:01,610
your final solution.

01:24:01,610 --> 01:24:02,840
- The final solution.

01:24:02,840 --> 01:24:03,673
Okay.

01:24:03,673 --> 01:24:05,137
Sounds ominous. - This is it.

01:24:05,137 --> 01:24:06,520
(laughing) This is it.

01:24:06,520 --> 01:24:07,353
I'm done.

01:24:07,353 --> 01:24:08,992
- That sounds really ominous.

01:24:08,992 --> 01:24:10,338
(laughing)

01:24:10,338 --> 01:24:11,380
- Okay, I guess that's it.

01:24:11,380 --> 01:24:12,213
I'm out of time.

01:24:13,090 --> 01:24:13,923
- So, before we run for the break,

01:24:13,923 --> 01:24:16,230
does anyone have any other questions

01:24:16,230 --> 01:24:18,860
for anyone from the last hour? - Comments?

01:24:18,860 --> 01:24:20,170
Please, any comments?

01:24:21,880 --> 01:24:22,713
- Okay. - Okay,

01:24:22,713 --> 01:24:25,090
well I hope everyone enjoyed out get_user_pages

01:24:25,090 --> 01:24:27,029
and Zone Device adventure for RDMA.

01:24:27,029 --> 01:24:28,295
(laughing)

01:24:28,295 --> 01:24:29,910
It felt like I've been here for a little while,

01:24:29,910 --> 01:24:31,260
so I think after the break,

01:24:34,933 --> 01:24:36,860
we're doing a discussion about IBMD.

01:24:36,860 --> 01:24:38,490
So, this is our friends

01:24:38,490 --> 01:24:40,740
from IONOS and Profitbricks.

01:24:42,210 --> 01:24:43,043
If you're here.

01:24:43,043 --> 01:24:44,116
Great.

01:24:44,116 --> 01:24:45,540
So, get your laptop set up

01:24:45,540 --> 01:24:46,610
for after the break,

01:24:46,610 --> 01:24:47,910
and thank you.

01:24:51,560 --> 01:24:53,030
- Hi.

01:24:53,030 --> 01:24:54,440
We are Jack Wang

01:24:54,440 --> 01:24:56,800
and I am Danil Kipnis

01:24:56,800 --> 01:25:00,870
from IONOS Cloud GmbH

01:25:00,870 --> 01:25:04,576
and we're gonna show a couple of slides

01:25:04,576 --> 01:25:07,040
about our driver.

01:25:10,444 --> 01:25:11,970
So, IBNBD is a block device

01:25:11,970 --> 01:25:14,580
which just allows store mappery mode,

01:25:14,580 --> 01:25:16,100
block device over RDMA

01:25:17,273 --> 01:25:19,810
and it consists in total

01:25:19,810 --> 01:25:21,140
out of four modules.

01:25:23,470 --> 01:25:26,210
So, it has, on the client side,

01:25:27,710 --> 01:25:29,390
IBNBD client presents itself

01:25:29,390 --> 01:25:32,730
as a local block device.

01:25:32,730 --> 01:25:34,910
It has a server part on the server side,

01:25:34,910 --> 01:25:38,460
which would access the real block device

01:25:38,460 --> 01:25:41,870
and it has two corresponding transport modules,

01:25:41,870 --> 01:25:42,800
client and server,

01:25:42,800 --> 01:25:44,840
which is this IBTRS layer

01:25:44,840 --> 01:25:47,510
is responsible for establishing RDMA,

01:25:47,510 --> 01:25:49,460
multiple RDMA connections,

01:25:50,411 --> 01:25:52,920
and multi-pathing, and automatic reconnect,

01:25:52,920 --> 01:25:53,840
and so on.

01:25:55,264 --> 01:25:57,770
I just wanted to briefly go over

01:25:57,770 --> 01:26:00,540
the main features of IBTRS

01:26:00,540 --> 01:26:04,930
because they have been discussed on the mailing list

01:26:04,930 --> 01:26:07,750
a couple of times, but still.

01:26:07,750 --> 01:26:11,120
Main features of IBTRS as a transport layer

01:26:11,120 --> 01:26:14,650
is that we pre-reserve memory on server side,

01:26:14,650 --> 01:26:16,090
so on connection establishment,

01:26:16,090 --> 01:26:18,690
server allocates queue depth

01:26:18,690 --> 01:26:21,550
of buffers of fixed size,

01:26:21,550 --> 01:26:22,620
and those buffers

01:26:23,820 --> 01:26:26,050
in sole responsibility of the client.

01:26:26,050 --> 01:26:27,870
Client decides how to use them.

01:26:27,870 --> 01:26:32,000
Then, the clients DAX RDMA writes

01:26:32,000 --> 01:26:35,810
with immediate field for write

01:26:35,810 --> 01:26:37,020
and request suite,

01:26:38,694 --> 01:26:41,110
and then server would reply with RDMA writes.

01:26:41,110 --> 01:26:42,720
So, this allows us,

01:26:43,720 --> 01:26:47,110
so we have a trade off between memory pre-allocation

01:26:47,110 --> 01:26:48,420
and better performance,

01:26:48,420 --> 01:26:50,700
since we don't have registration

01:26:50,700 --> 01:26:55,700
and end registration on server side in IO path for writes.

01:26:57,320 --> 01:26:58,153
Yeah?

01:26:59,222 --> 01:27:00,628
- How tightly coupled

01:27:00,628 --> 01:27:02,045
is IBTRS to IBND.

01:27:03,250 --> 01:27:04,780
IBTRS, can it stand on its own?

01:27:04,780 --> 01:27:06,990
- Yes, it's just a standalone module.

01:27:06,990 --> 01:27:08,330
It has an API

01:27:08,330 --> 01:27:09,390
and you can call,

01:27:09,390 --> 01:27:11,330
basically, the API it provides

01:27:11,330 --> 01:27:14,030
is to send or request a receipt

01:27:14,030 --> 01:27:15,140
for SJ lists,

01:27:15,140 --> 01:27:17,050
get together list with retried semantics.

01:27:17,050 --> 01:27:18,270
So, it's basically.

01:27:19,123 --> 01:27:21,511
- Why did you create the two models?

01:27:21,511 --> 01:27:23,860
- So, our original plan

01:27:23,860 --> 01:27:26,490
would be that we would have more users

01:27:26,490 --> 01:27:27,890
for this IBTRS layer.

01:27:28,750 --> 01:27:30,670
The thing is

01:27:32,135 --> 01:27:35,399
that the standard approach,

01:27:35,399 --> 01:27:37,870
where we have initiator attached,

01:27:39,266 --> 01:27:42,290
it says that we have a client,

01:27:42,290 --> 01:27:44,440
then we have a storage device

01:27:44,440 --> 01:27:46,490
which is equipped with MVME, SSD,

01:27:46,490 --> 01:27:47,850
SCSI, whatever devices

01:27:49,575 --> 01:27:50,570
and the idea behind IBTRS

01:27:50,570 --> 01:27:53,289
would be that two storages would be able

01:27:53,289 --> 01:27:54,150
to communicate with each other,

01:27:54,150 --> 01:27:57,290
for example, if we plan

01:27:57,290 --> 01:28:00,100
to implement a distributed rate solution

01:28:00,100 --> 01:28:01,210
and so on,

01:28:01,210 --> 01:28:02,820
so that independently

01:28:02,820 --> 01:28:05,020
of what the attached device is,

01:28:05,020 --> 01:28:06,920
I just wanna be capable of,

01:28:06,920 --> 01:28:08,390
if I received on one storage

01:28:08,390 --> 01:28:09,560
a scatter gather list,

01:28:10,502 --> 01:28:11,490
which I can map to PIO,

01:28:11,490 --> 01:28:13,050
to whatever I wish,

01:28:14,290 --> 01:28:15,870
I can forward it

01:28:15,870 --> 01:28:16,970
to the next storage,

01:28:16,970 --> 01:28:18,110
or request a read

01:28:18,110 --> 01:28:19,320
if I'm, for example,

01:28:19,320 --> 01:28:22,260
reconstructing a failed device locally

01:28:22,260 --> 01:28:23,290
from another storage.

01:28:23,290 --> 01:28:26,000
So basically, we wanted this IBTRS

01:28:26,000 --> 01:28:28,990
not to be unidirectional

01:28:28,990 --> 01:28:30,880
from initiate to target,

01:28:30,880 --> 01:28:34,380
but would be to just between two Linux hosts.

01:28:34,380 --> 01:28:36,100
So, we have two Linux hosts

01:28:36,100 --> 01:28:37,450
connected over RDMA,

01:28:37,450 --> 01:28:40,600
and for some reason we wanna send

01:28:40,600 --> 01:28:43,220
or request reads of SJ lists.

01:28:43,220 --> 01:28:47,430
That was the basic idea for this architecture,

01:28:47,430 --> 01:28:49,240
and further on,

01:28:49,240 --> 01:28:52,450
when we established,

01:28:52,450 --> 01:28:54,300
it's configurable, but we established

01:28:55,520 --> 01:28:57,860
one RDMA connection per CPU,

01:28:57,860 --> 01:29:01,350
and this allows us, for our particular use case,

01:29:01,350 --> 01:29:04,720
we have customer VMs binned to some running

01:29:04,720 --> 01:29:05,960
on some CPUs,

01:29:05,960 --> 01:29:07,980
and they would produce IOs on those CPUs.

01:29:07,980 --> 01:29:10,230
What we wanted to achieve in our case

01:29:10,230 --> 01:29:13,570
is that those replies

01:29:13,570 --> 01:29:15,040
to those requests

01:29:15,040 --> 01:29:16,600
would be processed on the same CPU.

01:29:16,600 --> 01:29:18,210
So, if it is set accordingly,

01:29:18,210 --> 01:29:20,680
the cube vectors of these connections,

01:29:20,680 --> 01:29:23,250
and then distribute the IRQs

01:29:23,250 --> 01:29:24,830
to our core indicated

01:29:24,830 --> 01:29:27,820
and our IOs are kind of pinned to the CPUs

01:29:27,820 --> 01:29:30,450
where they are produced the replies,

01:29:30,450 --> 01:29:33,620
and yeah, as it is done transport,

01:29:33,620 --> 01:29:37,830
I guess it allows two different multi-path policies.

01:29:37,830 --> 01:29:38,890
One is Round Robin

01:29:38,890 --> 01:29:42,520
and another one is where we choose the path

01:29:42,520 --> 01:29:44,590
with the minimum in flight

01:29:46,000 --> 01:29:47,540
for the next IO.

01:29:47,540 --> 01:29:48,870
- [Jason] So, I don't understand

01:29:48,870 --> 01:29:50,250
how you avoid on registration

01:29:50,250 --> 01:29:55,180
without creating security problems.

01:29:55,180 --> 01:29:57,460
- What do you mean, exactly?

01:29:57,460 --> 01:29:58,980
- You have to have on registration

01:29:58,980 --> 01:30:01,300
to deny client access to the memory buffers

01:30:01,300 --> 01:30:03,710
before you do anything with the memory buffers.

01:30:03,710 --> 01:30:05,760
- We do need to register,

01:30:06,715 --> 01:30:08,680
for example, on the write,

01:30:09,600 --> 01:30:10,770
on the write.

01:30:10,770 --> 01:30:12,480
So, we get user buffers

01:30:12,480 --> 01:30:15,020
and we wanna send it to remote memory

01:30:15,020 --> 01:30:16,620
of the server.

01:30:16,620 --> 01:30:19,420
So instead, as MVME over fabric, for example,

01:30:20,415 --> 01:30:21,540
is doing to send a command,

01:30:21,540 --> 01:30:24,160
and then the server would do that RDMA read.

01:30:24,160 --> 01:30:25,890
We just write directly into the memory

01:30:25,890 --> 01:30:26,860
of the server,

01:30:26,860 --> 01:30:28,280
which is pre-registered.

01:30:28,280 --> 01:30:30,130
But of course, if you need to do a read,

01:30:30,130 --> 01:30:32,120
then of course, we need to register

01:30:32,120 --> 01:30:33,520
the user buffers

01:30:33,520 --> 01:30:35,000
that we need to read,

01:30:35,000 --> 01:30:36,930
so we do need to return. - I'm not talking about,

01:30:36,930 --> 01:30:39,037
what I'm saying, once you do that write

01:30:39,037 --> 01:30:40,460
and the server wants to touch that memory

01:30:40,460 --> 01:30:42,590
because the client wrote to it,

01:30:42,590 --> 01:30:44,450
it needs to un-register it.

01:30:44,450 --> 01:30:46,250
You can't touch memory

01:30:46,250 --> 01:30:47,660
that's got an active R key.

01:30:49,358 --> 01:30:50,508
- Why?

01:30:50,508 --> 01:30:52,780
Why?

01:30:52,780 --> 01:30:55,540
I'm not quite sure.

01:30:55,540 --> 01:30:58,400
So, I've written stuff into registered memory,

01:30:58,400 --> 01:30:59,550
and then I pass it down

01:31:00,609 --> 01:31:01,442
to block device. - No,

01:31:01,442 --> 01:31:02,990
you definitely can't do that

01:31:02,990 --> 01:31:04,637
because at any moment,

01:31:04,637 --> 01:31:06,330
if the R key is active,

01:31:06,330 --> 01:31:09,770
somebody un-trusted could write to that memory,

01:31:09,770 --> 01:31:10,603
at any moment,

01:31:10,603 --> 01:31:12,700
as long as there's an active R key.

01:31:12,700 --> 01:31:13,856
- I don't think they care.

01:31:13,856 --> 01:31:15,100
- They have to care

01:31:15,100 --> 01:31:16,440
because you can't pass something

01:31:16,440 --> 01:31:19,200
to the block layer that's changing.

01:31:19,200 --> 01:31:21,070
The block layer wants to deal with things that stable,

01:31:21,070 --> 01:31:22,230
otherwise you can cause corruption

01:31:22,230 --> 01:31:23,640
at the block layer level.

01:31:23,640 --> 01:31:25,802
- But the only guy who has this R key.

01:31:25,802 --> 01:31:26,801
- [Jerome] Either of the block license.

01:31:26,801 --> 01:31:27,994
- Yes, and he's on.

01:31:27,994 --> 01:31:29,350
- No, no.

01:31:29,350 --> 01:31:31,140
We're talking about inside the server.

01:31:31,140 --> 01:31:33,790
- [Jerome] No, I'm saying that you're getting memory.

01:31:34,845 --> 01:31:35,752
Let's see the block.

01:31:35,752 --> 01:31:37,260
(laughing)

01:31:37,260 --> 01:31:40,130
You're getting data from a client

01:31:40,130 --> 01:31:42,360
that you want written out to a block device.

01:31:42,360 --> 01:31:44,190
It's not being written to a file system.

01:31:44,190 --> 01:31:46,080
It's being written to a block device.

01:31:46,080 --> 01:31:47,800
The client owns the file system

01:31:47,800 --> 01:31:50,010
or whatever else is in that block device.

01:31:50,010 --> 01:31:51,480
If the client wants to change that data,

01:31:51,480 --> 01:31:52,780
it's the clients, too.

01:31:53,807 --> 01:31:54,640
- [Jason] It doesn't matter.

01:31:54,640 --> 01:31:56,094
It doesn't matter

01:31:56,094 --> 01:31:58,930
because our block stack has all kinds of features

01:31:58,930 --> 01:32:00,530
that rely on the data being stable.

01:32:00,530 --> 01:32:02,970
For instance, we can't easily do T10 DIF

01:32:02,970 --> 01:32:05,660
if the data we're DIF-ing can change at any moment.

01:32:05,660 --> 01:32:06,850
We can't do dmraid,

01:32:08,017 --> 01:32:08,850
we can't do all kinds of things.

01:32:09,759 --> 01:32:12,360
(man speaking off mic)

01:32:12,360 --> 01:32:13,577
Are you sure?

01:32:13,577 --> 01:32:14,980
(man speaking off mic)

01:32:14,980 --> 01:32:15,813
Are you sure?

01:32:16,650 --> 01:32:17,850
I'm pretty sure it does.

01:32:18,825 --> 01:32:19,658
- Maybe not if it's write back.

01:32:19,658 --> 01:32:21,300
It's read-only.

01:32:21,300 --> 01:32:23,310
If you did it as write back before,

01:32:23,310 --> 01:32:25,470
DMA's being done to a disc

01:32:25,470 --> 01:32:26,830
and it's write only.

01:32:26,830 --> 01:32:29,677
- [Bart] No, the only requirement is that.

01:32:29,677 --> 01:32:30,678
- [Jason] Bart.

01:32:30,678 --> 01:32:31,677
Bart?

01:32:31,677 --> 01:32:32,861
Hands, Bart.

01:32:32,861 --> 01:32:33,865
Oh!

01:32:33,865 --> 01:32:35,120
(laughing)

01:32:35,120 --> 01:32:37,250
- They don't want in back there.

01:32:37,250 --> 01:32:38,850
For T10 DIF, of course,

01:32:38,850 --> 01:32:41,640
it's required that the data is stable

01:32:41,640 --> 01:32:43,050
during the write,

01:32:43,050 --> 01:32:45,820
but if T10 DIF is not used,

01:32:45,820 --> 01:32:47,880
it's the route that the data is being modified

01:32:47,880 --> 01:32:49,970
while it's being under DMA,

01:32:50,810 --> 01:32:52,850
but the requirement is, of course,

01:32:52,850 --> 01:32:55,510
after all changes have finished

01:32:55,510 --> 01:32:56,860
that another write happens.

01:33:00,040 --> 01:33:02,618
I can show you the articles on LWN

01:33:02,618 --> 01:33:03,915
that describe this in detail.

01:33:03,915 --> 01:33:04,924
(laughing)

01:33:04,924 --> 01:33:08,106
(Jason speaking off mic)

01:33:08,106 --> 01:33:09,770
- [Jason] This is the whole stable pages discussion,

01:33:09,770 --> 01:33:12,010
and you solve it by copying,

01:33:12,010 --> 01:33:13,310
so if you're having a performance bounds,

01:33:13,310 --> 01:33:15,580
you definitely don't wanna copy your unstable pages.

01:33:15,580 --> 01:33:16,850
- There is a flag

01:33:18,050 --> 01:33:20,900
that can be set somewhere,

01:33:20,900 --> 01:33:24,830
and whether or not for stable pages are required,

01:33:27,120 --> 01:33:29,580
and that's a flag for block device.

01:33:30,807 --> 01:33:32,516
(speech muffled)

01:33:32,516 --> 01:33:37,330
- Those specific kinds of devices (speech muffled)

01:33:39,500 --> 01:33:42,401
- [Jason] Beyond set for specific SCSI devices,

01:33:42,401 --> 01:33:43,450
they use this thing,

01:33:43,450 --> 01:33:45,860
but in the end, if you keep the open R key,

01:33:45,860 --> 01:33:47,970
then you have to set the flags Bart was talking about

01:33:47,970 --> 01:33:49,070
in all of your IOs

01:33:49,070 --> 01:33:51,600
that say you're not providing stable data,

01:33:51,600 --> 01:33:53,300
and you need to take that penalty,

01:33:54,400 --> 01:33:56,590
whatever it might be for your configuration.

01:33:57,753 --> 01:34:00,630
- So, the convention for pages,

01:34:00,630 --> 01:34:02,460
is here's special page flag course,

01:34:02,460 --> 01:34:03,780
page write back,

01:34:03,780 --> 01:34:06,720
and that means the page is a current write back

01:34:06,720 --> 01:34:08,270
and you're not supposed to change anything,

01:34:08,270 --> 01:34:10,350
that has been the convention for ages.

01:34:11,320 --> 01:34:12,500
You can have an exception

01:34:12,500 --> 01:34:13,860
and not go to the write back stage,

01:34:13,860 --> 01:34:16,730
but then you're not in standard block system anymore.

01:34:16,730 --> 01:34:19,210
You do something strange on the side.

01:34:19,210 --> 01:34:21,000
- And how it evolved over time

01:34:21,000 --> 01:34:22,430
is that, initially,

01:34:23,690 --> 01:34:26,090
there was no requirement for pages being stable,

01:34:27,565 --> 01:34:30,130
and some, I think that Chris Mason

01:34:30,130 --> 01:34:32,260
asked to require

01:34:33,338 --> 01:34:34,780
that pages would be stable during write out,

01:34:34,780 --> 01:34:37,703
but that caused performance regressions for certain users,

01:34:37,703 --> 01:34:40,230
so complained about it.

01:34:41,776 --> 01:34:43,960
I think that's how we ended up at the current behavior.

01:34:43,960 --> 01:34:46,830
It's throughout for most use cases

01:34:46,830 --> 01:34:49,820
to modify pages that are being written out.

01:34:49,820 --> 01:34:51,990
- Okay, but what I know from memory management

01:34:51,990 --> 01:34:53,630
is that when you go into write back,

01:34:53,630 --> 01:34:56,500
the pages mark as write only from user space,

01:34:56,500 --> 01:34:57,650
and so if you get a page fault

01:34:57,650 --> 01:34:58,560
and then you try to write to it,

01:34:58,560 --> 01:35:00,590
then the system could invalidate that

01:35:00,590 --> 01:35:02,850
and cause a rewrite at the end

01:35:02,850 --> 01:35:04,830
because the page was modified,

01:35:04,830 --> 01:35:06,460
while it was being under write back.

01:35:06,460 --> 01:35:08,800
Okay, but we still have the issue to deal with.

01:35:08,800 --> 01:35:09,950
This is not going away.

01:35:16,220 --> 01:35:17,820
- So, just for me to understand,

01:35:17,820 --> 01:35:19,410
if you say

01:35:22,385 --> 01:35:24,160
that even that the only client

01:35:24,160 --> 01:35:25,530
who has this R key

01:35:25,530 --> 01:35:27,510
is writing to that disk.

01:35:27,510 --> 01:35:28,780
I need to invalidate

01:35:28,780 --> 01:35:30,740
or I need to un-register this buffer

01:35:30,740 --> 01:35:32,240
and then register it again

01:35:32,240 --> 01:35:34,070
for reuse for this client?

01:35:34,070 --> 01:35:36,720
- I don't think you have to actually fully un-register,

01:35:36,720 --> 01:35:37,690
or not un-register,

01:35:37,690 --> 01:35:41,680
but you gotta have some sort of control mechanism,

01:35:41,680 --> 01:35:44,090
but assuming your connection

01:35:44,090 --> 01:35:46,150
is a trusted connection,

01:35:46,150 --> 01:35:47,150
you've logged in.

01:35:48,336 --> 01:35:49,169
- [Jason] We don't allow that.

01:35:49,169 --> 01:35:50,280
- Don't allow what?

01:35:50,280 --> 01:35:51,860
- [Jason] That's not in the model.

01:35:51,860 --> 01:35:52,693
- So?

01:35:52,693 --> 01:35:54,350
- [Jason] The thing on the other end is un-trusted.

01:35:54,350 --> 01:35:55,530
It's not allowed.

01:35:55,530 --> 01:35:57,110
I mean, it can corrupt its own data,

01:35:58,065 --> 01:35:58,898
but it can't corrupt the system.

01:35:58,898 --> 01:35:59,980
- It can't corrupt the system.

01:35:59,980 --> 01:36:02,360
They're using a ring buffer, essentially.

01:36:02,360 --> 01:36:03,617
Is that right?

01:36:03,617 --> 01:36:05,057
You're doing a ring buffer? - Yes.

01:36:05,057 --> 01:36:06,055
It's just a fixed set of.

01:36:06,055 --> 01:36:06,980
- So, all you really have to do

01:36:06,980 --> 01:36:08,720
to solve his problem

01:36:08,720 --> 01:36:10,830
is use head and tail

01:36:10,830 --> 01:36:12,890
and make sure that you don't ever,

01:36:12,890 --> 01:36:17,890
you don't update your tail until the flush is complete

01:36:18,080 --> 01:36:20,080
and the other side is not allowed to write

01:36:20,080 --> 01:36:21,660
until the tail is updated.

01:36:21,660 --> 01:36:23,340
So, you build semantics around it

01:36:23,340 --> 01:36:24,970
to provide your security,

01:36:24,970 --> 01:36:26,970
but since it's a logged in connection,

01:36:26,970 --> 01:36:30,065
you don't have to go to the whole un-register.

01:36:30,065 --> 01:36:30,898
- [Jason] You have to do all the steps, right?

01:36:30,898 --> 01:36:33,020
So, if you're sending unstable data to the block layer,

01:36:33,020 --> 01:36:34,750
you need to tell the block layer it's unstable.

01:36:34,750 --> 01:36:38,110
You certainly cannot touch that memory with a CPU,

01:36:38,110 --> 01:36:39,940
so you can only put blocks that you're gonna DMA

01:36:39,940 --> 01:36:41,810
with the block layer in there.

01:36:41,810 --> 01:36:42,830
That's the other little thing.

01:36:42,830 --> 01:36:46,545
You can't have a command channel or something?

01:36:46,545 --> 01:36:50,200
- So, the client, for one,

01:36:50,200 --> 01:36:51,630
the client wouldn't attach

01:36:51,630 --> 01:36:54,280
that block of memory

01:36:54,280 --> 01:36:56,920
until he really receives a reply back

01:36:56,920 --> 01:36:59,000
from the server with whatever,

01:36:59,000 --> 01:37:00,880
so some other buffer.

01:37:00,880 --> 01:37:03,740
So, until he gets back that reply from block layer,

01:37:03,740 --> 01:37:04,650
he never touches it.

01:37:04,650 --> 01:37:06,370
- [Jason] What do you mean some other buffer?

01:37:07,254 --> 01:37:09,270
You said some other buffer.

01:37:09,270 --> 01:37:10,330
How does your?

01:37:10,330 --> 01:37:12,100
- I have a batch of them.

01:37:12,100 --> 01:37:14,780
So, he has, for example, I don't know,

01:37:14,780 --> 01:37:16,200
512 of those buffers.

01:37:16,200 --> 01:37:17,690
He sends one buffer

01:37:17,690 --> 01:37:18,980
or I can set it to one.

01:37:20,225 --> 01:37:21,058
Let's say we allocate the single buffer,

01:37:21,058 --> 01:37:22,860
then it would be just (speaking in a foreign language),

01:37:22,860 --> 01:37:25,780
so he writes one block of data

01:37:25,780 --> 01:37:27,770
and then he cannot write anything ever again.

01:37:27,770 --> 01:37:29,650
- [Jason] Yeah, but how do you communicate the metadata?

01:37:29,650 --> 01:37:32,900
How do you say what LBA you're writing to?

01:37:34,190 --> 01:37:35,510
- What do you mean?

01:37:35,510 --> 01:37:37,160
So on top of that,

01:37:37,160 --> 01:37:38,630
into this J list,

01:37:38,630 --> 01:37:42,140
you can put, of course, some BIOFlex.

01:37:42,140 --> 01:37:43,550
- [Jason] No, I mean how does the client

01:37:43,550 --> 01:37:45,460
communicate to the server

01:37:45,460 --> 01:37:47,821
what BIO the chunk of the ring buffer

01:37:47,821 --> 01:37:50,200
or what LBA that your ring buffer is for.

01:37:50,200 --> 01:37:51,550
- Ah, using the immediate field.

01:37:51,550 --> 01:37:53,430
- [Jason] That's only 32 bits, isn't it?

01:37:53,430 --> 01:37:54,263
- Yes.

01:37:54,263 --> 01:37:55,830
32 bits is more than enough

01:37:55,830 --> 01:37:58,500
to address 512 buffers

01:38:00,920 --> 01:38:01,753
of Q depth.

01:38:01,753 --> 01:38:04,840
- [Jason] You never ever read your ring buffer with the CPU.

01:38:04,840 --> 01:38:05,880
- No.

01:38:05,880 --> 01:38:07,900
We never touch the buffer at all.

01:38:11,240 --> 01:38:12,820
- [Jason] All right, well you have to set the stable stuff

01:38:12,820 --> 01:38:14,220
that Bart was talking about.

01:38:15,457 --> 01:38:16,290
- [Jerome] Not if you're not gonna sit there

01:38:16,290 --> 01:38:17,267
and write over your own buffers.

01:38:17,267 --> 01:38:18,870
- No, it's for the block layer.

01:38:18,870 --> 01:38:21,180
The block layer has to know if it can trust the pages

01:38:21,180 --> 01:38:22,130
to be stable or not,

01:38:22,130 --> 01:38:23,530
so that when it does things

01:38:23,530 --> 01:38:25,010
that requires stable pages,

01:38:25,010 --> 01:38:26,550
it can copy it,

01:38:28,065 --> 01:38:28,898
'cause there's lots of scenarios

01:38:28,898 --> 01:38:30,480
where the data's not allowed to be changed,

01:38:30,480 --> 01:38:32,779
otherwise it corrupts the integrity

01:38:32,779 --> 01:38:33,778
of the stuff under the block,

01:38:33,778 --> 01:38:34,611
like T10 DIF, for instance,

01:38:34,611 --> 01:38:36,060
or when you're doing rate calculations.

01:38:36,060 --> 01:38:37,380
You can't do a rate calculation

01:38:37,380 --> 01:38:39,230
on a page that's constantly changing.

01:38:40,428 --> 01:38:41,429
- Yeah.

01:38:41,429 --> 01:38:42,262
- So, that's why we have this concept

01:38:42,262 --> 01:38:44,141
of stable, not stable,

01:38:44,141 --> 01:38:45,750
and, I guess, Bart says, it's evolved some more

01:38:46,619 --> 01:38:48,012
since I last looked at it.

01:38:48,012 --> 01:38:49,324
- Okay.

01:38:49,324 --> 01:38:54,324
- Okay.

01:38:54,490 --> 01:38:56,140
- So, there is some kind.

01:38:59,213 --> 01:39:00,492
Should I continue?

01:39:00,492 --> 01:39:01,545
(laughing)

01:39:01,545 --> 01:39:03,410
(man speaking off mic)

01:39:03,410 --> 01:39:06,040
- So, if you're just using the immediate data

01:39:06,040 --> 01:39:07,220
for the LBA

01:39:07,220 --> 01:39:08,730
or the block number, whatever,

01:39:09,881 --> 01:39:12,170
are you passing in an SG list

01:39:12,170 --> 01:39:14,230
or do you have a command channel?

01:39:14,230 --> 01:39:15,760
Is there a separate communications channel

01:39:15,760 --> 01:39:18,560
besides the RDMA write buffers?

01:39:18,560 --> 01:39:19,393
- No.

01:39:19,393 --> 01:39:20,720
So, the only thing we have

01:39:20,720 --> 01:39:23,320
is RDMA buffers

01:39:23,320 --> 01:39:24,710
in the immediate field.

01:39:24,710 --> 01:39:27,070
We code which buffer has been overwritten

01:39:27,070 --> 01:39:28,350
and at which offset,

01:39:28,350 --> 01:39:30,570
whatever beats are necessary there,

01:39:30,570 --> 01:39:34,216
and then, the layer above IBRTS

01:39:34,216 --> 01:39:36,990
is provided with a pointer

01:39:36,990 --> 01:39:38,330
where he can find his data,

01:39:38,330 --> 01:39:39,870
and inside this data,

01:39:39,870 --> 01:39:40,970
he can find the stuff,

01:39:41,810 --> 01:39:45,270
whatever sector, offset, size,

01:39:45,270 --> 01:39:46,590
whatever he wants to code there.

01:39:46,590 --> 01:39:47,910
- Okay, so then the CPU

01:39:47,910 --> 01:39:49,070
is touching the buffer,

01:39:49,070 --> 01:39:51,310
it's just touching it at the upper layer.

01:39:51,310 --> 01:39:53,730
The IBTRS is not touching it.

01:39:53,730 --> 01:39:54,563
- [Danil] Yeah, that's true.

01:39:54,563 --> 01:39:56,034
Yes.

01:39:56,034 --> 01:39:57,152
- But the upper layer is touching it.

01:39:57,152 --> 01:39:58,640
- The upper layer is touching it, yes.

01:39:59,730 --> 01:40:01,830
Well, he needs to construct a BIO

01:40:01,830 --> 01:40:02,690
out of this, actually,

01:40:02,690 --> 01:40:04,610
so he maps the pages.

01:40:05,728 --> 01:40:06,840
The pages is just mapped,

01:40:06,840 --> 01:40:08,750
but he does need to construct the BIO,

01:40:08,750 --> 01:40:11,340
so he needs to at least extract the sector,

01:40:12,360 --> 01:40:14,050
and he needs to extract something

01:40:14,050 --> 01:40:15,540
- Sector or length,

01:40:15,540 --> 01:40:16,420
the full SG list. - Length of set.

01:40:17,286 --> 01:40:18,717
- [Jason] But where does that come from?

01:40:18,717 --> 01:40:20,590
- It's embedded in the buffer.

01:40:20,590 --> 01:40:22,340
They have the command channel

01:40:22,340 --> 01:40:23,900
in front of the data.

01:40:23,900 --> 01:40:26,750
- [Jason] I said you can never touch this data

01:40:26,750 --> 01:40:27,583
with the CPU.

01:40:28,979 --> 01:40:29,812
- Well, that's what I'm telling you.

01:40:29,812 --> 01:40:31,127
It reads it.

01:40:31,127 --> 01:40:32,691
- [Jason] Well, you can't.

01:40:32,691 --> 01:40:36,781
- So, that means

01:40:36,781 --> 01:40:39,870
that we need to un-register this thing

01:40:39,870 --> 01:40:43,220
from RDMA before passing it down

01:40:43,220 --> 01:40:44,720
or before accessing it at all.

01:40:46,882 --> 01:40:48,130
- [Jason] Bart explained you can pass,

01:40:49,680 --> 01:40:52,061
Bart explained you can pass the buffers

01:40:52,061 --> 01:40:52,894
to the block layer.

01:40:52,894 --> 01:40:54,040
So, you can't touch them with the CPU,

01:40:54,040 --> 01:40:55,980
but you can construct a BIO for them

01:40:55,980 --> 01:40:57,611
and pass them to the block layer

01:40:57,611 --> 01:40:59,370
and flag them as unstable,

01:40:59,370 --> 01:41:01,270
and that's supposed to work,

01:41:01,270 --> 01:41:04,180
but you can't then K map those pages yourself

01:41:04,180 --> 01:41:05,630
and read some other metadata.

01:41:07,290 --> 01:41:09,110
You can only pass them to a block layer.

01:41:09,110 --> 01:41:11,377
You cannot access them with the CPU.

01:41:14,425 --> 01:41:18,350
- Really.

01:41:18,350 --> 01:41:20,810
So, we allocate,

01:41:20,810 --> 01:41:21,660
on service side,

01:41:21,660 --> 01:41:23,970
we allocate all this Q depth of buffer

01:41:23,970 --> 01:41:27,530
and we get the DMA address

01:41:27,530 --> 01:41:28,885
for each buffer.

01:41:28,885 --> 01:41:30,030
We have all the off site,

01:41:30,030 --> 01:41:34,460
so the first path we encode is protocol,

01:41:34,460 --> 01:41:38,360
so for, in our case, IBMVD,

01:41:38,360 --> 01:41:41,510
so it is PL all related structure

01:41:41,510 --> 01:41:42,860
which point to which buffer

01:41:44,413 --> 01:41:46,570
and LBA and read/write operation.

01:41:47,990 --> 01:41:49,860
- [Jason] Sorry, where is that stored?

01:41:49,860 --> 01:41:53,220
- It's stored in this big chunk of buffer.

01:41:53,220 --> 01:41:54,440
The first part

01:41:56,430 --> 01:41:58,890
is saved as protocol buffer,

01:41:58,890 --> 01:42:00,470
and the later part.

01:42:00,470 --> 01:42:01,560
- [Jason] That's what I'm saying you can't do.

01:42:01,560 --> 01:42:03,926
You can't put a protocol buffer

01:42:03,926 --> 01:42:05,430
in your ring buffer without doing invalidate.

01:42:06,950 --> 01:42:08,150
It's a security problem.

01:42:11,610 --> 01:42:13,100
- It's a security problem in the sense

01:42:13,100 --> 01:42:17,570
that somebody else would know this R key (speech muffled)

01:42:17,570 --> 01:42:18,950
- [Jason] No, your client is un-trusted,

01:42:18,950 --> 01:42:21,000
so the client can write to your control buffers

01:42:21,000 --> 01:42:22,220
while your CPU is reading them,

01:42:22,220 --> 01:42:24,150
and then you have a real problem.

01:42:24,150 --> 01:42:27,053
- If the client is buggy or something.

01:42:27,053 --> 01:42:27,886
- [Jason] Hostile.

01:42:27,886 --> 01:42:30,790
- Yeah, the problem is somebody looks at your code,

01:42:30,790 --> 01:42:32,700
they figure out how your code works,

01:42:32,700 --> 01:42:35,360
they write a hostile client,

01:42:35,360 --> 01:42:36,510
they then load that up,

01:42:36,510 --> 01:42:38,700
and then they log into your server

01:42:38,700 --> 01:42:40,260
and then they wait for you to get a buffer,

01:42:40,260 --> 01:42:41,130
and then they turn around

01:42:41,130 --> 01:42:43,140
and dump data all over you.

01:42:43,140 --> 01:42:44,630
So, that's the problem.

01:42:44,630 --> 01:42:47,853
Your client/server model

01:42:47,853 --> 01:42:52,060
is built assuming you're always gonna be connected

01:42:52,060 --> 01:42:55,650
to buy the well-behaved client

01:42:55,650 --> 01:42:57,970
and because the well-behaved client is remote,

01:42:57,970 --> 01:42:59,250
it's a remote machine,

01:42:59,250 --> 01:43:01,820
you don't have physical access to the remote machine,

01:43:01,820 --> 01:43:05,010
you can't verify the client module on it,

01:43:05,010 --> 01:43:06,870
it can be a nefarious module.

01:43:06,870 --> 01:43:09,610
- [Jason] Right, so the stance we've taken

01:43:09,610 --> 01:43:11,530
is you're allowed to do that,

01:43:11,530 --> 01:43:14,660
so long as the violations the remote side can do

01:43:14,660 --> 01:43:16,590
do not affect the operation and integrity

01:43:16,590 --> 01:43:17,590
of the local kernel.

01:43:18,650 --> 01:43:20,660
If you're reading memory with your local CPU,

01:43:20,660 --> 01:43:23,560
it's under DMA control, the adversary,

01:43:23,560 --> 01:43:26,030
you have to be super duper extra careful

01:43:26,030 --> 01:43:27,510
about how you read this data

01:43:27,510 --> 01:43:28,343
and process it

01:43:28,343 --> 01:43:31,460
so that it's not changing under your feet.

01:43:31,460 --> 01:43:33,780
So for instance, you could copy out of the ring buffer

01:43:33,780 --> 01:43:35,640
into the CPU memory

01:43:35,640 --> 01:43:36,660
in one shot,

01:43:36,660 --> 01:43:38,800
and then touch the CPU memory as a copy.

01:43:38,800 --> 01:43:41,050
Then, you're guaranteed nobody's touching it.

01:43:41,990 --> 01:43:43,660
Then, you could do your stuff with it.

01:43:43,660 --> 01:43:44,930
That would be okay.

01:43:44,930 --> 01:43:45,910
- Copy using DMA?

01:43:47,040 --> 01:43:48,780
- [Jason] No, just copying it with the CPU.

01:43:48,780 --> 01:43:49,980
It's a header or something.

01:43:49,980 --> 01:43:51,350
It's small. - Yes.

01:43:51,350 --> 01:43:52,724
- That part is common, yeah. - That's okay mode.

01:43:52,724 --> 01:43:56,149
This will be not a violation on security, right?

01:43:56,149 --> 01:43:57,380
- [Jason] If you copied it.

01:43:57,380 --> 01:44:00,829
- That's we are parsing to copy.

01:44:00,829 --> 01:44:04,024
(microphone squealing)

01:44:04,024 --> 01:44:05,270
- But that's what we do.

01:44:05,270 --> 01:44:06,760
Of course, we only copy.

01:44:06,760 --> 01:44:08,090
We never modify the stuff.

01:44:08,090 --> 01:44:09,390
So, the CPU is touching.

01:44:09,390 --> 01:44:11,730
You need to extract. - No, I mean literally copy,

01:44:11,730 --> 01:44:13,600
as in copy byte by byte

01:44:13,600 --> 01:44:16,460
and then access your structured data on the copy.

01:44:17,600 --> 01:44:19,960
- But copy over CPU or DMA?

01:44:19,960 --> 01:44:22,190
I don't see. - Copy with CPU.

01:44:22,190 --> 01:44:23,520
- But that's the only thing we do.

01:44:23,520 --> 01:44:26,290
We need to copy out the offset

01:44:26,290 --> 01:44:29,400
and clients and what else?

01:44:29,400 --> 01:44:31,037
Flags for BIO.

01:44:31,037 --> 01:44:32,840
- Jason's point is you just need

01:44:32,840 --> 01:44:35,600
to do a bulk copy of the header data

01:44:35,600 --> 01:44:37,010
to a memory location

01:44:37,010 --> 01:44:39,390
that is not accessible by the R key.

01:44:39,390 --> 01:44:41,180
Once it's in a memory location,

01:44:41,180 --> 01:44:43,180
not accessible by the R key,

01:44:43,180 --> 01:44:45,580
then it can't be touched by the remote host,

01:44:45,580 --> 01:44:48,180
then you can turn around and start parsing the data.

01:44:49,720 --> 01:44:52,810
- [Jason] But you need what's called the read once semantic

01:44:53,868 --> 01:44:55,052
in there currently.

01:44:55,052 --> 01:44:56,030
You need read once of the RDMA data.

01:44:58,580 --> 01:44:59,413
- Okay.

01:44:59,413 --> 01:45:01,450
So, what's the difference

01:45:01,450 --> 01:45:03,640
between copying it into one bulk

01:45:03,640 --> 01:45:06,560
or copy it byte by byte.

01:45:06,560 --> 01:45:08,570
- [Jason] You need the read once semantic.

01:45:08,570 --> 01:45:09,940
So, if you do mem copy,

01:45:09,940 --> 01:45:11,540
that's defined to be read once.

01:45:11,540 --> 01:45:12,740
It only reads it once.

01:45:12,740 --> 01:45:14,250
Every byte's read once.

01:45:14,250 --> 01:45:16,310
If you use the read once helper macro,

01:45:16,310 --> 01:45:19,190
that's also defined to be safe, sort of,

01:45:20,430 --> 01:45:23,650
but you can't just read it with the raw CPU.

01:45:23,650 --> 01:45:24,960
You get artifacts.

01:45:24,960 --> 01:45:26,630
There's a very good LWN article

01:45:26,630 --> 01:45:28,070
about all these artifacts

01:45:28,070 --> 01:45:30,150
that read once is supposed to counteract.

01:45:31,690 --> 01:45:32,523
- Okay.

01:45:34,843 --> 01:45:36,360
So, the work around for us

01:45:36,360 --> 01:45:39,500
would be to do double check

01:45:39,500 --> 01:45:43,250
on the way we read out our control information

01:45:43,250 --> 01:45:44,970
from those buffers.

01:45:44,970 --> 01:45:46,870
- [Jason] You have to read it once, essentially.

01:45:46,870 --> 01:45:48,320
- Yes, read it once.

01:45:48,320 --> 01:45:49,153
Okay.

01:45:50,030 --> 01:45:51,720
- Read once for every byte

01:45:51,720 --> 01:45:53,580
of the control buffer.

01:45:53,580 --> 01:45:54,807
- [Jason] Yes.

01:45:54,807 --> 01:45:55,930
- Okay.

01:45:55,930 --> 01:45:58,860
So, it's not just mem copy this bunch and just.

01:46:01,640 --> 01:46:04,020
- Or alternatively, you go ahead

01:46:04,020 --> 01:46:05,300
and un-register your memory

01:46:05,300 --> 01:46:07,400
after you get a work completion.

01:46:07,400 --> 01:46:09,460
- That's what most people do.

01:46:09,460 --> 01:46:11,230
- Go ahead and do your un-register memory,

01:46:11,230 --> 01:46:12,300
just that one buffer,

01:46:13,340 --> 01:46:17,110
do all the normal processing you have to do,

01:46:17,110 --> 01:46:20,160
and then re-register the memory

01:46:20,160 --> 01:46:22,940
probably just in some kernel thread later.

01:46:22,940 --> 01:46:24,390
- [Jason] So, Seggi asked you guys,

01:46:24,390 --> 01:46:25,590
Seggi asked on the list,

01:46:26,545 --> 01:46:29,123
why are you using a ring buffer constructor with RDMA write?

01:46:29,123 --> 01:46:30,596
Why aren't you just using send?

01:46:30,596 --> 01:46:31,429
It's almost exactly the same thing.

01:46:34,050 --> 01:46:37,530
- [Jack] Because we write from some papers.

01:46:38,600 --> 01:46:40,450
So, RDMA write is faster compared to.

01:46:42,579 --> 01:46:43,664
- [Jason] Is it really?

01:46:43,664 --> 01:46:46,124
- You gotta do the un-register, so you lose that.

01:46:46,124 --> 01:46:47,850
- [Jason] Yeah.

01:46:47,850 --> 01:46:49,772
Is it really even faster?

01:46:49,772 --> 01:46:53,410
- Register is a very slow progression.

01:46:53,410 --> 01:46:58,120
Register is a special (mumbling)

01:46:58,120 --> 01:47:00,030
- [Jason] But the un-register validation exists

01:47:00,030 --> 01:47:01,860
for security purposes.

01:47:01,860 --> 01:47:05,630
So, you can't just omit the invalidations

01:47:05,630 --> 01:47:08,430
without providing another way

01:47:08,430 --> 01:47:10,340
to guarantee the same security properties,

01:47:10,340 --> 01:47:11,360
like read once,

01:47:11,360 --> 01:47:12,870
marking pages unstable.

01:47:12,870 --> 01:47:14,000
These are all things.

01:47:14,000 --> 01:47:15,550
But I'm concerned that you haven't even thought

01:47:15,550 --> 01:47:16,450
about this at all.

01:47:17,868 --> 01:47:20,680
So, we've spent a lot of time cleaning up our existing ULPs.

01:47:20,680 --> 01:47:22,150
I don't really wanna merge another one

01:47:22,150 --> 01:47:26,230
that's got this security issue built into it.

01:47:26,230 --> 01:47:28,814
- [Bart] I have question about another topic

01:47:28,814 --> 01:47:31,070
for when the discussion about this topic is finished.

01:47:31,070 --> 01:47:33,706
- [Jason] Yeah, I think we've done this enough.

01:47:33,706 --> 01:47:36,860
- So, there was another session this morning

01:47:36,860 --> 01:47:38,040
about atomic writes.

01:47:38,040 --> 01:47:42,390
It's a topic that keeps popping up for databases.

01:47:42,390 --> 01:47:44,540
It allows to make databases more efficient,

01:47:45,460 --> 01:47:47,540
but it's not completely clear to me

01:47:47,540 --> 01:47:49,510
is how writes are processed

01:47:49,510 --> 01:47:52,310
by the IBTRS,

01:47:53,938 --> 01:47:54,840
and whether or not writes are split,

01:47:54,840 --> 01:47:56,290
and in case writes are split,

01:47:57,880 --> 01:48:01,370
is it possible to support atomic writes with this protocol

01:48:01,370 --> 01:48:03,120
that span multiple physical blocks?

01:48:06,140 --> 01:48:07,950
- For right operation,

01:48:07,950 --> 01:48:09,500
so we gather these

01:48:09,500 --> 01:48:11,680
then to for RDMA write

01:48:11,680 --> 01:48:12,930
two to three more buffer.

01:48:13,823 --> 01:48:14,656
So, that's it,

01:48:14,656 --> 01:48:19,490
and then just pass down to a block device.

01:48:20,994 --> 01:48:24,120
What do you talk about this atomic write?

01:48:24,120 --> 01:48:28,810
I don't think we have.

01:48:28,810 --> 01:48:31,280
- Atomic writes are supported by the MVME spec.

01:48:33,790 --> 01:48:35,800
- No, we don't have such semantic.

01:48:37,780 --> 01:48:39,046
- [Jason] Sorry.

01:48:39,046 --> 01:48:40,570
I guess since we're running out of time,

01:48:42,407 --> 01:48:43,480
does anyone in the room have opinions

01:48:43,480 --> 01:48:45,430
of how we should decide if we want to merge

01:48:45,430 --> 01:48:47,400
another relatively large ULP?

01:48:49,810 --> 01:48:51,820
What should the conditions be?

01:48:51,820 --> 01:48:53,620
I've heard people suggest that,

01:48:53,620 --> 01:48:56,030
since it duplicates MVME so very, very much,

01:48:56,030 --> 01:48:58,610
it's maybe not making sense.

01:48:58,610 --> 01:49:00,810
I've heard people say it's a lot faster than MVME,

01:49:00,810 --> 01:49:01,960
so that makes sense.

01:49:02,970 --> 01:49:04,860
I've heard questions about the security,

01:49:04,860 --> 01:49:07,608
I've heard questions about the design.

01:49:07,608 --> 01:49:08,611
- It's a whole lot faster

01:49:08,611 --> 01:49:11,525
because it's not doing the secure thing.

01:49:11,525 --> 01:49:13,092
If that's the key,

01:49:13,092 --> 01:49:16,105
I can tell you what the distro is gonna do,

01:49:16,105 --> 01:49:18,638
or not do, as the case may be.

01:49:18,638 --> 01:49:22,041
So, if it never goes to a distro,

01:49:22,041 --> 01:49:26,680
this is an exercise in software.

01:49:26,680 --> 01:49:28,220
- There are some optimizations possible

01:49:28,220 --> 01:49:30,620
for the upstream MVME target,

01:49:31,660 --> 01:49:34,080
memory, caching, SGL,

01:49:35,030 --> 01:49:37,150
or caching the buffer allocations

01:49:38,180 --> 01:49:39,680
that are used to receive data.

01:49:44,008 --> 01:49:47,350
- Personally, I'm not opposed to a new ULP,

01:49:47,350 --> 01:49:51,556
but I think there are some obvious security,

01:49:51,556 --> 01:49:52,920
maybe not so obvious,

01:49:52,920 --> 01:49:54,890
but there are some security issues

01:49:54,890 --> 01:49:57,420
with the current model you have right now,

01:49:57,420 --> 01:49:58,820
and those are gonna have to be addressed

01:49:58,820 --> 01:50:00,360
before it can be merged.

01:50:00,360 --> 01:50:04,550
My guess is, by the time you address those security issues,

01:50:04,550 --> 01:50:07,680
then you've got possibly even a different transfer model.

01:50:07,680 --> 01:50:11,200
You may even go away from RDMA writes entirely,

01:50:11,200 --> 01:50:12,750
'cause with the send model,

01:50:13,685 --> 01:50:15,609
at least then you don't have to worry

01:50:15,609 --> 01:50:19,110
about an application can't write into the buffer twice.

01:50:19,110 --> 01:50:20,110
Once it's written into,

01:50:20,110 --> 01:50:21,210
it comes off the list.

01:50:22,370 --> 01:50:25,320
So, the send model might be better for you guys

01:50:25,320 --> 01:50:27,240
in this case, and I don't know how much it would take you

01:50:27,240 --> 01:50:28,880
to re-work that,

01:50:28,880 --> 01:50:30,920
but you could also fix your security

01:50:30,920 --> 01:50:32,920
while still sticking with RDMA writes,

01:50:32,920 --> 01:50:36,300
but it's absolutely gonna cost you in your performance,

01:50:36,300 --> 01:50:37,590
but I'm not opposed,

01:50:37,590 --> 01:50:39,620
and especially I like the idea

01:50:39,620 --> 01:50:41,970
that your transport model

01:50:41,970 --> 01:50:45,280
is separate from your block driver,

01:50:45,280 --> 01:50:47,480
which makes it a model

01:50:47,480 --> 01:50:49,600
if you get it fixed

01:50:49,600 --> 01:50:52,360
and secured and working,

01:50:52,360 --> 01:50:54,370
it makes it something that could be generically used

01:50:54,370 --> 01:50:56,360
by other upper layer protocols,

01:50:56,360 --> 01:50:57,193
if they ever want to,

01:50:57,193 --> 01:50:58,790
and that, to me, is appealing.

01:50:58,790 --> 01:51:00,010
- [Jason] Seggi was complaining about that.

01:51:00,010 --> 01:51:02,440
He said, "why are we creating more mid-layers,"

01:51:02,440 --> 01:51:03,670
so I don't know.

01:51:04,984 --> 01:51:07,190
It would be more powerful if there was more users.

01:51:10,540 --> 01:51:12,488
I don't know how much the cost is

01:51:12,488 --> 01:51:13,321
to create the mid-layer,

01:51:13,321 --> 01:51:14,154
the code cost.

01:51:19,113 --> 01:51:22,632
- [Don] Where does IBTRS sit in the space?

01:51:22,632 --> 01:51:24,882
(mumbling)

01:51:27,642 --> 01:51:29,319
- Here, Don.

01:51:29,319 --> 01:51:30,388
- I'm sorry.

01:51:30,388 --> 01:51:33,476
The question was where does IBTRS sit

01:51:33,476 --> 01:51:35,620
in the space?

01:51:36,714 --> 01:51:37,547
That's all.

01:51:37,547 --> 01:51:38,880
- It's on top of RDMA CM.

01:51:40,952 --> 01:51:42,841
- You mean in kernel tree?

01:51:42,841 --> 01:51:43,843
- [Don] Yeah.

01:51:43,843 --> 01:51:45,736
- Inside the VS drivers (mumbling)

01:51:45,736 --> 01:51:48,130
The block device on top,

01:51:48,130 --> 01:51:51,944
it's on the block.

01:51:51,944 --> 01:51:53,337
So, yeah.

01:51:53,337 --> 01:51:54,660
- [Don] Okay.

01:51:54,660 --> 01:51:55,493
Okay.

01:51:56,760 --> 01:51:59,170
- [Jason] It's unfortunate Seggi wasn't able to make it

01:51:59,170 --> 01:52:02,200
because Seggi had the most comments, I think,

01:52:02,200 --> 01:52:04,930
and looked at it most closely of all of us.

01:52:04,930 --> 01:52:05,930
Leon, how much time?

01:52:08,953 --> 01:52:09,786
- [Leon] We don't have time.

01:52:09,786 --> 01:52:11,000
- [Jason] We don't have time.

01:52:11,000 --> 01:52:11,833
- [Leon] Minus three.

01:52:11,833 --> 01:52:12,960
- [Jason] Minus three.

01:52:12,960 --> 01:52:13,960
(laughing)

01:52:13,960 --> 01:52:14,967
All right.

01:52:14,967 --> 01:52:16,180
Did you have a lot more slides?

01:52:17,130 --> 01:52:19,207
- I have little bit more slides,

01:52:19,207 --> 01:52:20,995
but I wanted to jump over them,

01:52:20,995 --> 01:52:23,573
so basically, until somebody stops me.

01:52:23,573 --> 01:52:24,729
- [Jason] I see.

01:52:24,729 --> 01:52:25,562
(laughing) Okay.

01:52:25,562 --> 01:52:26,540
Then, we got to slide three.

01:52:26,540 --> 01:52:28,073
I don't know.

01:52:28,073 --> 01:52:30,560
Any closing remarks before we move on

01:52:30,560 --> 01:52:31,393
from you two?

01:52:33,570 --> 01:52:36,450
- Well, we will certainly look into this security thing,

01:52:37,301 --> 01:52:40,020
and look at what is the easier way to fix that,

01:52:40,020 --> 01:52:43,390
so either with atomic reads

01:52:46,110 --> 01:52:47,170
or with switching

01:52:48,964 --> 01:52:51,200
to post send, but yeah.

01:52:52,133 --> 01:52:56,068
So basically, of course we constructed it,

01:52:56,068 --> 01:52:59,364
it was designed originally for secure.

01:52:59,364 --> 01:53:02,257
Nobody can come and install

01:53:02,257 --> 01:53:05,320
and infinite decrypt machine

01:53:05,320 --> 01:53:06,710
to our data center,

01:53:06,710 --> 01:53:08,460
and then write stuff into,

01:53:10,440 --> 01:53:12,270
but basically, yes,

01:53:12,270 --> 01:53:16,560
if it is supposed to be

01:53:16,560 --> 01:53:18,410
a block device where you put

01:53:18,410 --> 01:53:20,420
whatever rocky communicator

01:53:20,420 --> 01:53:22,598
went to internet, then anybody.

01:53:22,598 --> 01:53:26,670
So basically, we don't have

01:53:26,670 --> 01:53:29,800
hostile clients because, basically,

01:53:29,800 --> 01:53:31,840
anybody hostile would just go

01:53:31,840 --> 01:53:34,120
and destroy our servers with a hammer.

01:53:34,120 --> 01:53:35,190
It would be way more easier

01:53:35,190 --> 01:53:36,880
than to write a hostile client.

01:53:36,880 --> 01:53:39,180
- Right, but for the upstream kernel,

01:53:39,180 --> 01:53:40,130
if we put it in there,

01:53:40,130 --> 01:53:41,200
people will use it,

01:53:41,200 --> 01:53:42,170
and when they use it,

01:53:42,170 --> 01:53:44,210
if they don't realize that they have to have

01:53:44,210 --> 01:53:46,150
a locked down data center,

01:53:46,150 --> 01:53:49,320
that's where the hostile part comes in.

01:53:49,320 --> 01:53:50,153
So, this is something,

01:53:50,153 --> 01:53:51,690
if you wanted to keep it in your own tree

01:53:51,690 --> 01:53:52,940
and out of the mainline kernel,

01:53:52,940 --> 01:53:53,773
you could do that

01:53:53,773 --> 01:53:55,960
and you could probably get away with these things

01:53:55,960 --> 01:53:58,060
because you have physical control

01:53:58,060 --> 01:53:59,680
over the entire cluster,

01:54:00,650 --> 01:54:02,750
but when you're talking about the upstream,

01:54:02,750 --> 01:54:04,960
we have to look at the security issues

01:54:04,960 --> 01:54:06,410
of people using it elsewhere.

01:54:11,410 --> 01:54:12,490
- [Jason] All right, then.

01:54:12,490 --> 01:54:13,323
Who's next?

01:54:15,003 --> 01:54:16,004
- [Man] Yuval.

01:54:16,004 --> 01:54:17,337
- [Jason] Yuval.

01:54:19,840 --> 01:54:20,673
Thank you.

01:54:22,852 --> 01:54:26,019
(audience applauding)

01:54:36,646 --> 01:54:37,964
- [Don] Oh, I'm sorry.

01:54:37,964 --> 01:54:40,047
You guys sitting here?

01:54:40,047 --> 01:54:42,880
Sorry, I just plunked myself down.

01:54:44,155 --> 01:54:46,322
I guess I won't sit there.

01:54:47,223 --> 01:54:48,806
I'll sit over here.

01:54:51,866 --> 01:54:54,259
- [Man] We gotta find a spot.

01:54:54,259 --> 01:54:57,176
(quiet chattering)

01:55:08,072 --> 01:55:11,322
(microphone squealing)

01:55:46,701 --> 01:55:48,784
- That's the other thing.

01:55:57,008 --> 01:56:00,131
- [Man] Steve, is your mic plugged in all the way.

01:56:00,131 --> 01:56:01,137
There.

01:56:01,137 --> 01:56:02,887
I'll get it up there.

01:56:13,563 --> 01:56:15,451
- [Jason] Is this Windows or Linux?

01:56:15,451 --> 01:56:16,453
- No, no.

01:56:16,453 --> 01:56:17,286
Ubuntu.

01:56:18,393 --> 01:56:21,310
(quiet chattering)

01:56:29,399 --> 01:56:31,464
- It might just be.

01:56:31,464 --> 01:56:32,466
- Oh, none of this.

01:56:32,466 --> 01:56:37,466
Other screen.

01:56:37,876 --> 01:56:39,943
- It's probably the laptop not the.

01:56:39,943 --> 01:56:42,860
(quiet chattering)

01:56:52,562 --> 01:56:54,821
Your laptop doesn't want to work.

01:56:54,821 --> 01:56:55,737
- [Man In Black] Hold on.

01:56:55,737 --> 01:56:56,738
Can I?

01:56:56,738 --> 01:56:59,649
(mumbling)

01:56:59,649 --> 01:57:02,566
(quiet chattering)

01:57:12,903 --> 01:57:17,844
Sometimes it just needs a bit of a (mumbling)

01:57:17,844 --> 01:57:20,761
(quiet chattering)

01:57:27,092 --> 01:57:28,460
- Leon, it looks like I should

01:57:28,460 --> 01:57:30,793
send you the presentation and you.

01:57:30,793 --> 01:57:33,710
(quiet chattering)

01:57:39,993 --> 01:57:42,839
- Now, we don't see any displays.

01:57:42,839 --> 01:57:46,143
(quiet chattering)

01:57:46,143 --> 01:57:48,445
Yeah, this one doesn't wanna work.

01:57:48,445 --> 01:57:49,979
Now, there's no display showing.

01:57:49,979 --> 01:57:52,853
(quiet chattering)

01:57:52,853 --> 01:57:56,832
Well, it's the built-in screen.

01:57:56,832 --> 01:57:59,516
It would show a different screen.

01:57:59,516 --> 01:58:01,118
It's not working.

01:58:01,118 --> 01:58:03,136
Why don't you? - Ubuntu is failing.

01:58:03,136 --> 01:58:04,764
- Ubuntu is failing

01:58:04,764 --> 01:58:07,514
(speech muffled)

01:58:08,637 --> 01:58:10,205
Start your session

01:58:10,205 --> 01:58:11,470
and I'll import it to my laptop.

01:58:11,470 --> 01:58:14,387
(quiet chattering)

01:58:40,557 --> 01:58:41,562
- No.

01:58:41,562 --> 01:58:42,857
You should be more flexible.

01:58:42,857 --> 01:58:43,913
I'm I a user.

01:58:43,913 --> 01:58:45,615
I'm used to complaining.

01:58:45,615 --> 01:58:47,245
(laughing)

01:58:47,245 --> 01:58:48,267
To the right guy.

01:58:48,267 --> 01:58:52,560
Change it, 'cause I might change everything else.

01:58:52,560 --> 01:58:54,094
(mumbling)

01:58:54,094 --> 01:58:55,372
So, can we start it up?

01:58:55,372 --> 01:58:56,656
- No, I have to.

01:58:56,656 --> 01:58:58,307
- Send it to me.

01:58:58,307 --> 01:58:59,331
We'll use this laptop.

01:58:59,331 --> 01:59:00,736
It worked earlier.

01:59:00,736 --> 01:59:02,965
- Can you swap PowerPoints?

01:59:02,965 --> 01:59:04,533
- [Jason] Yeah, we're doing that.

01:59:04,533 --> 01:59:06,386
(quiet chattering)

01:59:06,386 --> 01:59:08,835
- Sorry.

01:59:08,835 --> 01:59:12,137
- It is what it is.

01:59:12,137 --> 01:59:13,367
Maybe this'll work better.

01:59:13,367 --> 01:59:16,634
Okay, so I just need your things.

01:59:16,634 --> 01:59:19,546
You gotta be swift.

01:59:19,546 --> 01:59:21,659
- You wanna switch (mumbling)

01:59:21,659 --> 01:59:24,326
(quiet chatter)

01:59:26,277 --> 01:59:28,501
- Sure.

01:59:28,501 --> 01:59:29,500
- Okay.

01:59:29,500 --> 01:59:31,926
(quiet chatter)

01:59:31,926 --> 01:59:35,479
Okay, we'll do an unscheduled schedule change.

01:59:35,479 --> 01:59:39,153
- Hopefully someone does give up for your talk.

01:59:39,153 --> 01:59:41,587
- Where's the adaptor?

01:59:41,587 --> 01:59:42,628
- [Jason] Oh, here we go again.

01:59:42,628 --> 01:59:44,149
(laughing)

01:59:44,149 --> 01:59:45,148
I will find out.

01:59:45,148 --> 01:59:46,149
- No, no.

01:59:46,149 --> 01:59:47,148
This worked on Monday.

01:59:47,148 --> 01:59:49,586
- Oh yeah, the type C one worked.

01:59:49,586 --> 01:59:52,503
(quiet chattering)

01:59:55,055 --> 01:59:55,888
- Let's see.

01:59:55,888 --> 01:59:57,017
(quiet chattering)

01:59:57,017 --> 01:59:57,850
Let's see.

01:59:57,850 --> 01:59:59,281
(quiet chattering)

01:59:59,281 --> 02:00:00,279
Yeah, yeah.

02:00:00,279 --> 02:00:01,601
(laughing)

02:00:01,601 --> 02:00:04,518
(quiet chattering)

02:00:08,577 --> 02:00:09,734
- It's like a blue screen.

02:00:09,734 --> 02:00:12,651
(quiet chattering)

02:00:14,567 --> 02:00:17,911
- [Jason] Okay, so the unscheduled change of schedule,

02:00:17,911 --> 02:00:20,221
now this is recruiting RDMA performance

02:00:20,221 --> 02:00:22,079
or use of contiguous memory

02:00:22,079 --> 02:00:23,745
in larger pages for files,

02:00:23,745 --> 02:00:26,161
which is one of our mm talks.

02:00:26,161 --> 02:00:31,161
We seem to have a theme.

02:00:33,154 --> 02:00:34,337
- Yes.

02:00:34,337 --> 02:00:35,442
Good.

02:00:35,442 --> 02:00:36,640
Can you see this?

02:00:36,640 --> 02:00:38,336
- Very good. - Very well.

02:00:38,336 --> 02:00:39,567
- Okay, good.

02:00:39,567 --> 02:00:40,565
Where's my mouse?

02:00:40,565 --> 02:00:41,398
Come on.

02:00:41,398 --> 02:00:42,817
Come back.

02:00:42,817 --> 02:00:43,816
I control that. - It's like a Chrome OS.

02:00:43,816 --> 02:00:46,045
(quiet chattering)

02:00:46,045 --> 02:00:47,868
- Chrome OS works really great for this.

02:00:47,868 --> 02:00:49,026
- Very nice, yeah.

02:00:49,026 --> 02:00:52,720
- This for a while now.

02:00:52,720 --> 02:00:53,777
You can even have a split thing.

02:00:53,777 --> 02:00:56,006
This is here and I have my controls here,

02:00:56,006 --> 02:00:57,295
my commands and everything.

02:00:57,295 --> 02:00:58,688
(laughing)

02:00:58,688 --> 02:01:00,624
So, this is actually

02:01:00,624 --> 02:01:03,216
the third time I'm talking about the subject matter,

02:01:03,216 --> 02:01:05,167
and the second one was too technical

02:01:05,167 --> 02:01:07,117
and just went over everybody's head

02:01:07,117 --> 02:01:09,102
and so I'm trying to do this in a very simple way

02:01:09,102 --> 02:01:14,102
with some flash cards.

02:01:14,614 --> 02:01:16,039
So, I'm not sure

02:01:16,039 --> 02:01:18,905
if the effort that we put into it

02:01:18,905 --> 02:01:21,799
is actually worth it.

02:01:21,799 --> 02:01:26,166
In some way, I think we have lost control of this thing.

02:01:26,166 --> 02:01:27,687
We have talked for a long time

02:01:27,687 --> 02:01:29,065
about getting contiguous memory,

02:01:29,065 --> 02:01:31,239
actually for the last,

02:01:31,239 --> 02:01:33,339
I've talked about this for the last 15 years.

02:01:33,339 --> 02:01:34,581
What's happening now in my company

02:01:34,581 --> 02:01:37,180
is we have actually systems, like servers,

02:01:37,180 --> 02:01:40,252
that have terabytes of RAM,

02:01:40,252 --> 02:01:44,078
and they have 100 gig EDR fabric, RDMA,

02:01:44,078 --> 02:01:46,213
and so what happens now,

02:01:46,213 --> 02:01:48,177
you hire a new sysadmin,

02:01:48,177 --> 02:01:49,347
comes into the company,

02:01:49,347 --> 02:01:51,485
and okay, we have some files here

02:01:51,485 --> 02:01:53,378
of five gigabytes or 10 gigabytes,

02:01:53,378 --> 02:01:54,642
just copy them around a bit,

02:01:54,642 --> 02:01:56,659
and he, of course, the first thing he types

02:01:56,659 --> 02:02:00,518
is copy this filename to another location, right?

02:02:00,518 --> 02:02:03,119
And then, he sits there and waits,

02:02:03,119 --> 02:02:04,797
and he gets confused.

02:02:04,797 --> 02:02:07,137
We have 100 gig EDR fabric.

02:02:07,137 --> 02:02:09,521
Why is this copying of one thing

02:02:09,521 --> 02:02:11,055
fogging up my file, taking me two minutes

02:02:11,055 --> 02:02:13,295
or three minutes?

02:02:13,295 --> 02:02:14,815
Then, the experienced sysadmin comes

02:02:14,815 --> 02:02:16,047
and says, "oh, we have written

02:02:16,047 --> 02:02:20,587
"this copy tool that's using RDMA and everything

02:02:20,587 --> 02:02:22,653
"and it uses huge pages,"

02:02:22,653 --> 02:02:23,652
and the run that.

02:02:23,652 --> 02:02:26,271
Okay, it takes a fraction of a second.

02:02:26,271 --> 02:02:28,640
So, what we have, essentially,

02:02:28,640 --> 02:02:32,550
is a dual operating system on our machines.

02:02:33,930 --> 02:02:36,830
One is the copy command for the small files,

02:02:36,830 --> 02:02:37,970
and if you have big files,

02:02:37,970 --> 02:02:40,650
you need to run the special, big copy command

02:02:40,650 --> 02:02:42,750
that does the big copies,

02:02:42,750 --> 02:02:43,890
and the big copy command

02:02:43,890 --> 02:02:46,610
requires large, contiguous memory,

02:02:46,610 --> 02:02:48,930
and the small command can work

02:02:48,930 --> 02:02:50,610
for the configuration files

02:02:50,610 --> 02:02:51,810
for the executables and stuff like that,

02:02:51,810 --> 02:02:54,010
but as soon as you attach really serious,

02:02:54,010 --> 02:02:57,300
large data, you end up with specialized binaries

02:02:57,300 --> 02:03:00,800
that require large contiguous memory,

02:03:00,800 --> 02:03:03,850
and so since we couldn't provide

02:03:03,850 --> 02:03:06,320
any contiguous memory for user space,

02:03:06,320 --> 02:03:08,360
we still deal with these four kilobyte pages

02:03:08,360 --> 02:03:09,850
in many operations,

02:03:09,850 --> 02:03:11,370
and the interesting thing is also,

02:03:11,370 --> 02:03:13,700
these systems deteriorate over time.

02:03:13,700 --> 02:03:15,140
When you first boot them,

02:03:15,140 --> 02:03:16,200
there's a lot of contiguous memory,

02:03:16,200 --> 02:03:18,080
and if you allocate,

02:03:18,080 --> 02:03:20,680
let's say, 104 kilobyte pages,

02:03:20,680 --> 02:03:22,190
they are all in sequence,

02:03:22,190 --> 02:03:25,070
and when you submit them to the disk for IO,

02:03:25,070 --> 02:03:26,420
the IOs have to correlate them

02:03:26,420 --> 02:03:28,550
and make them all into one request.

02:03:28,550 --> 02:03:31,080
That kind of ability deteriorates

02:03:31,080 --> 02:03:32,130
as time passes

02:03:32,130 --> 02:03:34,170
and the memory gets de-fragmented,

02:03:34,170 --> 02:03:37,020
and so on Fridays, after seven days of operation,

02:03:37,020 --> 02:03:39,130
or manufacturer's operation,

02:03:39,130 --> 02:03:40,990
the system is sluggish,

02:03:40,990 --> 02:03:44,062
so we always reboot everything over the weekend.

02:03:44,062 --> 02:03:46,312
(laughing)

02:03:47,648 --> 02:03:50,250
(quiet chattering)

02:03:50,250 --> 02:03:51,679
Yes, right.

02:03:51,679 --> 02:03:53,990
(laughing)

02:03:53,990 --> 02:03:56,390
And so, on Monday, everything is fast again

02:03:56,390 --> 02:03:58,130
and you have contiguous memory.

02:03:58,130 --> 02:04:00,380
(laughing)

02:04:02,360 --> 02:04:06,340
So, the new thing also, now,

02:04:06,340 --> 02:04:08,740
is, okay, we got into first assistance,

02:04:08,740 --> 02:04:10,300
really high capacity,

02:04:10,300 --> 02:04:12,959
and then the experienced sysadmin came to me

02:04:12,959 --> 02:04:13,930
and said, "the system is not working anymore.

02:04:13,930 --> 02:04:16,500
"It's constantly having these hiccups,"

02:04:16,500 --> 02:04:17,333
and so we look at it.

02:04:17,333 --> 02:04:20,690
"Okay, well, the system has four terabytes of RAM,

02:04:20,690 --> 02:04:23,500
"that gives you one billion four kilobyte pages.

02:04:23,500 --> 02:04:25,230
"If you don't use huge pages,

02:04:25,230 --> 02:04:26,160
"then once in a while,

02:04:26,160 --> 02:04:27,610
"the kernel starts scanning,

02:04:27,610 --> 02:04:30,650
"it's building pages,

02:04:30,650 --> 02:04:32,200
"and it takes a while until it can do something

02:04:32,200 --> 02:04:35,771
"for the user again."

02:04:35,771 --> 02:04:37,420
(laughing)

02:04:37,420 --> 02:04:38,870
What we've done in that case

02:04:38,870 --> 02:04:39,900
is just, "okay,

02:04:39,900 --> 02:04:41,760
"every system must be configured,

02:04:42,850 --> 02:04:45,180
"most of the memory will be huge pages,"

02:04:45,180 --> 02:04:46,013
"and once you do that,

02:04:46,013 --> 02:04:47,850
"it's just four gigabyte left for the kernel

02:04:47,850 --> 02:04:48,920
"in four K pages,

02:04:48,920 --> 02:04:51,300
"the system behaves in a predictable way again as fast,"

02:04:51,300 --> 02:04:53,480
because you only have one million

02:04:53,480 --> 02:04:55,550
of these four K pages,

02:04:55,550 --> 02:04:57,050
closure around in the kernel.

02:04:58,040 --> 02:05:01,130
So, the contiguous memory problem

02:05:01,130 --> 02:05:04,160
is going further and further,

02:05:04,160 --> 02:05:06,750
and I think we have kind of lost control of these things.

02:05:06,750 --> 02:05:08,070
I'm not gonna show what happens

02:05:08,070 --> 02:05:09,540
if I actually, in three or four years,

02:05:09,540 --> 02:05:11,720
get some 16 or 30 gigabytes

02:05:11,720 --> 02:05:13,370
to the terabyte systems.

02:05:13,370 --> 02:05:15,540
This must getting much, much worse.

02:05:15,540 --> 02:05:18,490
So actually, what we are seeing what's happening

02:05:18,490 --> 02:05:19,940
in our production environment

02:05:20,877 --> 02:05:23,440
is we are ending up with a two-tiered system

02:05:23,440 --> 02:05:26,760
where we have tools that operate

02:05:26,760 --> 02:05:28,400
on two meg pages,

02:05:28,400 --> 02:05:29,233
and then we have to send it

02:05:29,233 --> 02:05:30,370
on the four kilobyte pages.

02:05:30,370 --> 02:05:32,500
So, we have this dual thing going on.

02:05:36,140 --> 02:05:38,090
So, that's pretty bad, actually.

02:05:39,630 --> 02:05:42,124
This transparent huge pages and stuff.

02:05:42,124 --> 02:05:44,590
We thought we could get that under control,

02:05:44,590 --> 02:05:46,610
but we are not having any progress there.

02:05:46,610 --> 02:05:49,070
So, we must have huge pages,

02:05:49,070 --> 02:05:50,520
otherwise the system slows down.

02:05:50,520 --> 02:05:52,400
We can't really get the performance we want

02:05:52,400 --> 02:05:54,940
and the system actually starts sloshing

02:05:54,940 --> 02:05:58,020
and doesn't work in an optimal way anymore.

02:06:00,310 --> 02:06:01,820
Yeah.

02:06:01,820 --> 02:06:04,240
So then, we have done some effort

02:06:05,701 --> 02:06:09,480
to provide automatic defragmentation in the past.

02:06:09,480 --> 02:06:11,340
There's logic in the kernel

02:06:11,340 --> 02:06:14,320
to defrag multiple four K pages

02:06:14,320 --> 02:06:16,330
that are contiguous

02:06:16,330 --> 02:06:19,570
and bring them back into a huge page back and forth.

02:06:19,570 --> 02:06:21,160
That has had some success,

02:06:21,160 --> 02:06:23,220
but still over time,

02:06:23,220 --> 02:06:25,526
there are certain four kilobyte pages

02:06:25,526 --> 02:06:27,079
that are pinned in memory

02:06:27,079 --> 02:06:28,690
that have caused a breakdown of the ability

02:06:29,683 --> 02:06:31,800
to recreate a huge page,

02:06:31,800 --> 02:06:32,850
and that's why,

02:06:32,850 --> 02:06:35,520
even with these optimizing mechanisms,

02:06:35,520 --> 02:06:37,900
we can never really fully prevent that,

02:06:37,900 --> 02:06:39,440
and thus, reboot,

02:06:40,450 --> 02:06:42,600
and this means also, in the week,

02:06:42,600 --> 02:06:44,420
we may have a need for a reboot

02:06:44,420 --> 02:06:47,220
because you need to run a different application

02:06:47,220 --> 02:06:49,360
on the system that has a different requirement

02:06:49,360 --> 02:06:50,193
on huge pages.

02:06:51,170 --> 02:06:53,340
Since you cannot reclaim the huge pages,

02:06:54,520 --> 02:06:58,410
you will have to reset the boot up configuration

02:06:58,410 --> 02:07:00,080
to another set of huge pages,

02:07:00,080 --> 02:07:01,520
and then you reboot the system

02:07:01,520 --> 02:07:02,353
and it comes up

02:07:02,353 --> 02:07:04,650
and then it can run your application.

02:07:04,650 --> 02:07:06,770
So, this all gets more and more awkward.

02:07:10,350 --> 02:07:14,090
So, I've kinda left this pretty simple.

02:07:14,090 --> 02:07:16,050
I'm not sure where you wanna go with this.

02:07:16,050 --> 02:07:17,020
I can go in more detail

02:07:17,020 --> 02:07:19,330
on the efforts that we've done

02:07:19,330 --> 02:07:22,100
to provide more contiguous memory

02:07:22,100 --> 02:07:24,350
and how to reconstruct contiguous memory

02:07:25,340 --> 02:07:26,840
and we've been trying this now

02:07:27,960 --> 02:07:29,240
for over a decade,

02:07:29,240 --> 02:07:32,220
but we don't have enough people behind this

02:07:32,220 --> 02:07:33,720
and we don't have enough urgency, actually,

02:07:33,720 --> 02:07:35,240
to address the issue.

02:07:35,240 --> 02:07:37,150
Everybody's trying to do something,

02:07:37,150 --> 02:07:39,590
some optimistic techniques here and there,

02:07:39,590 --> 02:07:41,610
but the fundamental thing is not being addressed.

02:07:41,610 --> 02:07:43,060
I think the fundamental thing

02:07:44,039 --> 02:07:45,360
is that the objects in the kernel

02:07:45,360 --> 02:07:46,620
are not moveable,

02:07:46,620 --> 02:07:47,453
so at some point,

02:07:47,453 --> 02:07:50,070
when you have an object that's constantly used,

02:07:50,070 --> 02:07:52,820
it will prevent creating continuous sections

02:07:52,820 --> 02:07:54,450
across that area.

02:07:54,450 --> 02:07:55,880
This is particularly true for files.

02:07:55,880 --> 02:07:57,750
So, inodes and dentries

02:07:58,640 --> 02:08:00,620
are one of these things,

02:08:00,620 --> 02:08:03,340
so as they system opens files,

02:08:03,340 --> 02:08:04,290
these are created,

02:08:04,290 --> 02:08:06,620
and you can't move them afterwards anymore.

02:08:06,620 --> 02:08:07,950
So, they pin pages,

02:08:07,950 --> 02:08:09,800
which will make sure

02:08:09,800 --> 02:08:12,510
that the whole section of memory

02:08:12,510 --> 02:08:14,610
can no longer be reclaimed as a huge page,

02:08:16,100 --> 02:08:18,050
and so over time,

02:08:18,050 --> 02:08:21,240
these allocations in memory develop

02:08:21,240 --> 02:08:23,390
that you cannot create contiguous memory anymore,

02:08:23,390 --> 02:08:24,470
and this proliferates,

02:08:24,470 --> 02:08:27,200
and ultimately leads to the end of this thing.

02:08:27,200 --> 02:08:28,990
So, what I've been trying to do

02:08:28,990 --> 02:08:30,090
when I had some time

02:08:31,042 --> 02:08:34,130
is create ways to make these objects moveable,

02:08:34,130 --> 02:08:37,310
and that has had some success,

02:08:37,310 --> 02:08:39,020
but it's not really complete

02:08:41,017 --> 02:08:42,000
and it seems that people

02:08:42,000 --> 02:08:44,190
don't think that this is too important.

02:08:44,190 --> 02:08:47,040
I'm not quite sure how to continue

02:08:47,040 --> 02:08:48,140
with this whole thing.

02:08:49,180 --> 02:08:51,310
It seems that the practical things

02:08:51,310 --> 02:08:53,910
are more going to this dual system

02:08:53,910 --> 02:08:56,690
of four K pages and two meg pages.

02:09:00,430 --> 02:09:02,430
So, I don't know

02:09:02,430 --> 02:09:05,460
how to continue this matter here

02:09:05,460 --> 02:09:07,210
and what to do in the future,

02:09:07,210 --> 02:09:09,390
but maybe it's inevitable

02:09:09,390 --> 02:09:11,890
that we do a tiered system.

02:09:11,890 --> 02:09:13,590
Anybody have any comments on this?

02:09:15,566 --> 02:09:19,030
- Have you guys ever?

02:09:19,030 --> 02:09:21,565
(microphone squealing)

02:09:21,565 --> 02:09:22,860
Have you guys ever experimented, sorry?

02:09:23,706 --> 02:09:25,020
Have you guys ever experimented?

02:09:26,241 --> 02:09:29,780
(microphone squealing)

02:09:29,780 --> 02:09:30,613
Yes.

02:09:31,920 --> 02:09:33,260
Have you guys ever experimented

02:09:33,260 --> 02:09:36,160
where you have that same philosophy

02:09:36,160 --> 02:09:39,670
but you always allocate small blocks

02:09:39,670 --> 02:09:41,910
from low range going up

02:09:41,910 --> 02:09:44,750
and the large blocks from high range going down,

02:09:44,750 --> 02:09:48,360
so hoping the two will balance as the system goes,

02:09:48,360 --> 02:09:49,730
where most small ones - You're talking

02:09:49,730 --> 02:09:50,860
about memory management.

02:09:50,860 --> 02:09:51,990
- Yeah. - Yes.

02:09:51,990 --> 02:09:54,650
There have been all sorts of methods.

02:09:54,650 --> 02:09:55,500
The increment in the kernel,

02:09:55,500 --> 02:09:57,650
that's a huge hodge podge these days.

02:09:58,755 --> 02:10:00,030
- So, those have failed?

02:10:01,650 --> 02:10:03,460
- They had limited success.

02:10:03,460 --> 02:10:04,560
- Limited success, thanks.

02:10:04,560 --> 02:10:06,260
- The problem was always at the end,

02:10:06,260 --> 02:10:09,630
some objects are created that are pinned

02:10:09,630 --> 02:10:12,960
that then prevent the re-establishment.

02:10:12,960 --> 02:10:15,250
- Right, but if you're always allocating small objects

02:10:15,250 --> 02:10:16,810
because they're the ones that are breaking up

02:10:16,810 --> 02:10:21,490
your two megs from a lower region working up,

02:10:21,490 --> 02:10:23,830
your big requests always come from the top

02:10:23,830 --> 02:10:27,060
and come and go and keep things contiguous,

02:10:27,060 --> 02:10:28,410
and your small ones always,

02:10:29,320 --> 02:10:30,490
even if they lock down,

02:10:30,490 --> 02:10:32,250
are only taking smaller pieces.

02:10:33,524 --> 02:10:35,268
- That's actually the strategy

02:10:35,268 --> 02:10:36,180
of taking the huge things from high memory

02:10:36,180 --> 02:10:38,190
ad you wanna take the other smaller bits

02:10:38,190 --> 02:10:39,850
from lower memory. - Right,

02:10:39,850 --> 02:10:41,880
and that hasn't worked either?

02:10:41,880 --> 02:10:43,870
- It had improved the situation, yes.

02:10:43,870 --> 02:10:44,703
- Oh, okay.

02:10:44,703 --> 02:10:46,219
Thanks.

02:10:46,219 --> 02:10:47,052
- But it's not a total solution.

02:10:47,052 --> 02:10:49,710
So, the problem is,

02:10:49,710 --> 02:10:51,460
as time progresses, memory becomes,

02:10:54,923 --> 02:10:56,520
there's more quantity of memory,

02:10:56,520 --> 02:10:57,630
there's more tools,

02:10:57,630 --> 02:10:59,360
there's more system diagnostics running,

02:10:59,360 --> 02:11:01,470
there's more usage of the memory sub-system,

02:11:01,470 --> 02:11:04,990
so this gets compensated as things get more complicated

02:11:04,990 --> 02:11:07,190
and the alt situation is then reconstructed,

02:11:07,190 --> 02:11:09,140
and then gets worse over time.

02:11:09,140 --> 02:11:10,880
So, this has been going on for a long time,

02:11:10,880 --> 02:11:13,020
where we first seen this again and again,

02:11:13,020 --> 02:11:14,950
so any progress we make,

02:11:14,950 --> 02:11:16,640
it's gonna be undone

02:11:16,640 --> 02:11:19,070
by the growth of the memory capacities.

02:11:23,540 --> 02:11:24,763
- Take it back.

02:11:24,763 --> 02:11:26,400
(laughing)

02:11:26,400 --> 02:11:27,590
- I take it the problem here

02:11:27,590 --> 02:11:30,530
is that two meg pages get cannibalized

02:11:30,530 --> 02:11:33,220
whenever you're running out of four K pages,

02:11:33,220 --> 02:11:36,420
and so it'll transition to two meg page

02:11:36,420 --> 02:11:38,520
to four K pages,

02:11:38,520 --> 02:11:40,990
then it'll allocate something that stays there,

02:11:40,990 --> 02:11:42,650
and then it can't reconstruct it.

02:11:42,650 --> 02:11:44,180
That's the problem, right? - That's what

02:11:45,047 --> 02:11:46,218
they typical thing is.

02:11:46,218 --> 02:11:47,200
- So, if you know the type of stuff

02:11:47,200 --> 02:11:48,500
that normally gets pinned,

02:11:48,500 --> 02:11:51,330
if it comes from specific caches, or whatever,

02:11:51,330 --> 02:11:52,700
could you force those

02:11:52,700 --> 02:11:57,230
to not come from a cannibalized two meg page?

02:11:58,500 --> 02:11:59,333
- Yes, of course.

02:11:59,333 --> 02:12:01,710
I know that dentries is a typical use case.

02:12:01,710 --> 02:12:04,389
We've tried various approaches like that,

02:12:04,389 --> 02:12:05,240
but then if the load changes,

02:12:05,240 --> 02:12:06,110
you do a find operation

02:12:06,110 --> 02:12:08,090
and you have dentries and inodes

02:12:08,090 --> 02:12:09,890
to search through a file system,

02:12:09,890 --> 02:12:11,640
then suddenly, you will run out of memory

02:12:11,640 --> 02:12:13,590
because you don't allow the expansion

02:12:13,590 --> 02:12:16,370
of the inode dentry caches

02:12:16,370 --> 02:12:17,203
and stuff like that.

02:12:17,203 --> 02:12:20,070
So yes, we have system conditions occurring.

02:12:22,180 --> 02:12:24,040
- [Jason] Have people explored

02:12:24,040 --> 02:12:25,300
making the kmem_cache

02:12:26,516 --> 02:12:27,866
use huge pages exclusively?

02:12:29,330 --> 02:12:30,770
- I'm the author of these things

02:12:30,770 --> 02:12:32,741
and you have a kernel option,

02:12:32,741 --> 02:12:34,551
you can set a kernel option

02:12:34,551 --> 02:12:36,366
and the system will come up as huge pages

02:12:36,366 --> 02:12:37,530
for the stacks.

02:12:37,530 --> 02:12:39,330
- And that helps a little bit, too, I suppose?

02:12:39,330 --> 02:12:41,440
- It causes more memory use

02:12:41,440 --> 02:12:44,610
and it will be very fast for a while,

02:12:44,610 --> 02:12:45,740
but at some point,

02:12:45,740 --> 02:12:47,470
you won't be able to have enough memory

02:12:47,470 --> 02:12:48,650
anymore for the other things.

02:12:48,650 --> 02:12:49,980
- Or you run out of memory, in that case.

02:12:49,980 --> 02:12:51,640
- Yes, but for the four terabytes,

02:12:51,640 --> 02:12:53,491
it's not a problem,

02:12:53,491 --> 02:12:54,650
but if you have a system with just four gigabytes,

02:12:54,650 --> 02:12:56,997
then you might run into some issues.

02:12:56,997 --> 02:12:58,290
- [Jason] Well, my next question,

02:12:58,290 --> 02:13:00,430
so has anybody thought

02:13:00,430 --> 02:13:03,470
about putting these K mem caches in virtual map?

02:13:06,070 --> 02:13:07,200
- We've had approaches,

02:13:07,200 --> 02:13:09,700
I've done approaches like that in 2008, 2009, yes,

02:13:11,649 --> 02:13:13,350
and we had some problems with some device drivers

02:13:13,350 --> 02:13:15,030
that actually wanted physical objects

02:13:15,030 --> 02:13:15,863
to address this.

02:13:16,780 --> 02:13:18,330
- [Jason] For dentries?

02:13:18,330 --> 02:13:19,790
- That's for inodes for Gentoo,

02:13:19,790 --> 02:13:20,890
but the slab allocator

02:13:21,780 --> 02:13:25,348
is supposed to provide DMA-able objects

02:13:25,348 --> 02:13:26,350
to the device drivers,

02:13:26,350 --> 02:13:27,810
and if you do a kmalloc

02:13:29,094 --> 02:13:29,927
and the stuff is not DMA-able,

02:13:29,927 --> 02:13:30,870
then you have an issue

02:13:30,870 --> 02:13:32,970
with lots of device drivers in the kernel.

02:13:33,960 --> 02:13:35,170
- [Jason] That sounds like it just goes back

02:13:35,170 --> 02:13:36,940
to the whole get_user_pages thing,

02:13:36,940 --> 02:13:38,000
except it's not get_user_pages,

02:13:38,000 --> 02:13:38,850
it's get kernel pages.

02:13:38,850 --> 02:13:39,820
- Yeah, it's another

02:13:39,820 --> 02:13:41,080
on the lower object level

02:13:41,080 --> 02:13:42,000
that I have to deal with.

02:13:42,000 --> 02:13:43,828
You just deal with the big ones, yes?

02:13:43,828 --> 02:13:46,036
(laughing)

02:13:46,036 --> 02:13:46,940
So, yeah.

02:13:46,940 --> 02:13:49,000
The ideal thing that I wanna do

02:13:49,000 --> 02:13:51,660
would be best to have call backs of these sub-systems

02:13:51,660 --> 02:13:54,060
and make sure that these objects are moveable.

02:13:54,060 --> 02:13:56,620
- You mean like a kmem_cache callback?

02:13:56,620 --> 02:13:58,230
We have that, don't we? - Yes.

02:13:58,230 --> 02:13:59,063
I have.

02:13:59,063 --> 02:14:00,070
We've proposed that API.

02:14:00,910 --> 02:14:05,410
The IOs system guys are not really fond of that

02:14:05,410 --> 02:14:07,240
and I don't know how to make

02:14:07,240 --> 02:14:08,430
a dentry moveable

02:14:08,430 --> 02:14:11,740
because the locking is so obscure and so convoluted.

02:14:11,740 --> 02:14:13,940
I think it's about 15 levels or so

02:14:13,940 --> 02:14:16,500
of various layers that you have to get to that

02:14:16,500 --> 02:14:18,544
and you can't really touch the object

02:14:18,544 --> 02:14:19,450
unless you come from a certain list,

02:14:19,450 --> 02:14:22,620
so this has been very difficult

02:14:22,620 --> 02:14:25,370
to get any cooperation at that level.

02:14:25,370 --> 02:14:27,540
- Have you considered sending a machine

02:14:27,540 --> 02:14:29,540
with four terabytes of RAM

02:14:29,540 --> 02:14:32,207
(mic squealing)

02:14:34,481 --> 02:14:35,314
- [Christoph] I would have to send them a cluster.

02:14:35,314 --> 02:14:37,710
We're getting into some millions of dollars, yeah.

02:14:37,710 --> 02:14:38,543
- Just two.

02:14:38,543 --> 02:14:39,857
- [Christoph] Just two.

02:14:39,857 --> 02:14:40,976
(laughing)

02:14:40,976 --> 02:14:41,983
- [Jason] Just two.

02:14:41,983 --> 02:14:42,984
That's what I'll tell Gerald.

02:14:42,984 --> 02:14:44,515
(mumbling)

02:14:44,515 --> 02:14:45,923
- Give that file some information.

02:14:45,923 --> 02:14:48,890
- [Jason] Did we get to the point,

02:14:49,745 --> 02:14:51,840
can X-Ray tree nodes be moveable now?

02:14:51,840 --> 02:14:53,840
- The X-Ray is implemented

02:14:53,840 --> 02:14:56,490
and these objects are moveable

02:14:56,490 --> 02:14:59,280
and have patches that will make all of this work.

02:14:59,280 --> 02:15:00,890
- [Jason] But it's not bee merged yet.

02:15:00,890 --> 02:15:01,910
- Not really much, no.

02:15:01,910 --> 02:15:03,240
There are some pieces of the X-Ray

02:15:03,240 --> 02:15:04,740
that has been merged.

02:15:04,740 --> 02:15:05,573
That's not complete there yet.

02:15:05,573 --> 02:15:06,580
Matthew's still working on it,

02:15:06,580 --> 02:15:08,880
and my stuff is going on top of his stuff,

02:15:08,880 --> 02:15:10,970
and so we have to wait until that's all done,

02:15:10,970 --> 02:15:12,660
and then we have the X-Ray moveable,

02:15:12,660 --> 02:15:13,910
but I really need to move

02:15:14,769 --> 02:15:15,602
is the inode and dentries.

02:15:16,478 --> 02:15:18,440
So, I can probably get a bit of a foothold there,

02:15:18,440 --> 02:15:20,180
but we're looking at five years or so

02:15:20,180 --> 02:15:21,890
until everything has been merged,

02:15:21,890 --> 02:15:23,230
and while that's going on

02:15:23,230 --> 02:15:26,562
we have to do this dance with the huge pages.

02:15:26,562 --> 02:15:27,930
Yeah.

02:15:27,930 --> 02:15:28,770
I found another solution.

02:15:28,770 --> 02:15:30,184
Right.

02:15:30,184 --> 02:15:31,308
The other thing

02:15:31,308 --> 02:15:32,400
is the problem goes away

02:15:32,400 --> 02:15:34,150
if you're a CPU manufacturer,

02:15:34,150 --> 02:15:36,768
which is start giving you larger page sizes.

02:15:36,768 --> 02:15:38,900
So, if you run a power nine system

02:15:38,900 --> 02:15:39,930
with 64K pages,

02:15:39,930 --> 02:15:42,670
or an ARM system with 64K pages,

02:15:42,670 --> 02:15:44,620
this problem doesn't exist.

02:15:44,620 --> 02:15:47,830
Actually, the copy operation works fine on ARM systems,

02:15:47,830 --> 02:15:48,880
ended up with just

02:15:48,880 --> 02:15:50,930
- You mean you run the whole system with 64K.

02:15:50,930 --> 02:15:51,910
- [Christoph] Yes, right.

02:15:51,910 --> 02:15:53,347
- Right.

02:15:53,347 --> 02:15:56,210
That's what we do on our ARM 64s.

02:15:56,210 --> 02:15:58,235
They use 64K pages. - Yeah, small ARM

02:15:58,235 --> 02:16:01,410
uses 64K pages. - Yeah.

02:16:01,410 --> 02:16:02,940
So, have you tried

02:16:06,112 --> 02:16:08,820
doing a scaled or discrete step thing.

02:16:08,820 --> 02:16:10,830
You said the problem is you can't use pages

02:16:10,830 --> 02:16:11,670
on four gigs,

02:16:12,857 --> 02:16:14,790
so size, the number of huge pages

02:16:14,790 --> 02:16:16,630
based on the size memory,

02:16:16,630 --> 02:16:20,870
so as memory hits terabyte numbers,

02:16:20,870 --> 02:16:24,100
it's an obvious win to have huge pages.

02:16:24,100 --> 02:16:25,830
It doesn't sound

02:16:27,626 --> 02:16:28,530
like it's nearly any advantage

02:16:28,530 --> 02:16:29,850
to do it on four gig,

02:16:29,850 --> 02:16:32,936
but it's too much turn going on

02:16:32,936 --> 02:16:35,600
in what we now think of as a small amount of memory.

02:16:35,600 --> 02:16:37,020
- Yeah, but you have all this legacy stuff

02:16:37,020 --> 02:16:39,750
that you have written for you for the last decade,

02:16:39,750 --> 02:16:40,780
so that you won't run,

02:16:40,780 --> 02:16:42,500
you can't run. - You still have legacy

02:16:42,500 --> 02:16:44,360
and you do the idea that I mentioned

02:16:44,360 --> 02:16:45,900
of small stuff in low memory

02:16:45,900 --> 02:16:47,300
and big stuff on high,

02:16:47,300 --> 02:16:48,840
and you start splitting it up

02:16:48,840 --> 02:16:50,776
based on size of memory,

02:16:50,776 --> 02:16:53,820
at 512 meg, it's this one.

02:16:53,820 --> 02:16:55,030
So, it doesn't have to be linear.

02:16:55,030 --> 02:16:56,290
It can be non-linear,

02:16:56,290 --> 02:17:00,040
based on some heuristic that you've learned over time,

02:17:00,040 --> 02:17:03,650
that this is the typical huge page property

02:17:03,650 --> 02:17:06,310
of multi-terabyte systems, you know?

02:17:06,310 --> 02:17:09,250
Versus this is the heuristic that works

02:17:09,250 --> 02:17:12,240
for typical 64 gig or less.

02:17:12,240 --> 02:17:13,400
- Staff employed, right?

02:17:13,400 --> 02:17:14,798
- Yeah. - Yeah.

02:17:14,798 --> 02:17:16,670
- Right, right.

02:17:16,670 --> 02:17:19,875
Math is a wonderful thing. (laughing)

02:17:19,875 --> 02:17:21,630
- I think this is not a new problem.

02:17:21,630 --> 02:17:23,370
I encountered this first

02:17:23,370 --> 02:17:25,271
in the early '90s.

02:17:25,271 --> 02:17:27,000
(laughing)

02:17:27,000 --> 02:17:29,523
But I think maybe,

02:17:29,523 --> 02:17:30,810
I don't know exactly how it works now,

02:17:30,810 --> 02:17:34,030
but is there anyway to incentivize

02:17:35,110 --> 02:17:39,040
by categorizing blocks or memory

02:17:39,040 --> 02:17:40,110
into some memory

02:17:40,110 --> 02:17:45,110
that are for re-use,

02:17:45,110 --> 02:17:47,070
where you require. - Yes, yes, yes, yes.

02:17:47,070 --> 02:17:48,600
A kernel core parameter has been there

02:17:48,600 --> 02:17:50,680
since 2005, I believe,

02:17:51,910 --> 02:17:54,100
where Mel Gorman has implemented a limit

02:17:54,100 --> 02:17:57,020
and you must have a certain area of kernel

02:17:57,020 --> 02:17:59,030
that has to be reclaimable.

02:17:59,030 --> 02:18:01,810
You can't pin anything in that area that exists

02:18:02,800 --> 02:18:04,810
and it causes a lot of memory issues

02:18:04,810 --> 02:18:06,230
if you try and use it.

02:18:06,230 --> 02:18:07,063
(laughing) - Yeah.

02:18:07,063 --> 02:18:09,430
So, it has to be set to a default value

02:18:09,430 --> 02:18:11,230
that will reinforce people

02:18:11,230 --> 02:18:15,340
to actually implement moving.

02:18:15,340 --> 02:18:16,200
- Once you set the thing,

02:18:16,200 --> 02:18:17,100
you need to know

02:18:17,100 --> 02:18:19,040
and how your program behaves

02:18:19,040 --> 02:18:21,160
and what kinds of sizes that are fired,

02:18:21,160 --> 02:18:22,260
and once you cross this boundary,

02:18:22,260 --> 02:18:23,800
you get an OM,

02:18:23,800 --> 02:18:25,180
and you need to know how to deal with the system,

02:18:25,180 --> 02:18:26,680
so you just employ a specialists

02:18:26,680 --> 02:18:28,480
to handle this thing, the situation.

02:18:29,580 --> 02:18:30,774
- I see. - Yes.

02:18:30,774 --> 02:18:31,800
(laughing)

02:18:31,800 --> 02:18:33,207
- [Jason] Don't send it this way.

02:18:33,207 --> 02:18:36,270
(laughing)

02:18:36,270 --> 02:18:37,110
- Okay.

02:18:37,110 --> 02:18:38,445
- [Jason] All right,

02:18:38,445 --> 02:18:39,340
are there any other questions for Christoph?

02:18:39,340 --> 02:18:40,750
- If anybody wants to help

02:18:40,750 --> 02:18:43,034
and get engaged in a long-term project,

02:18:43,034 --> 02:18:44,253
talk to me.

02:18:44,253 --> 02:18:45,120
(laughing) - Yes,

02:18:45,120 --> 02:18:47,130
and I know we're always interested in this in RDMA

02:18:47,130 --> 02:18:50,440
because the DMA lists and things,

02:18:50,440 --> 02:18:51,650
all the hardware works a lot better

02:18:51,650 --> 02:18:54,220
if it's processing contiguous memory.

02:18:54,220 --> 02:18:55,053
Everything gets faster,

02:18:55,053 --> 02:18:56,543
not just the CPU.

02:18:56,543 --> 02:18:58,170
Everything gets faster. - Yeah.

02:18:58,170 --> 02:18:59,003
Just think about it.

02:18:59,003 --> 02:19:00,595
You do an operation

02:19:00,595 --> 02:19:02,334
on four gigabyte of data,

02:19:02,334 --> 02:19:05,220
and so if you have a four kilobyte system,

02:19:05,220 --> 02:19:06,400
you're potentially sending it

02:19:06,400 --> 02:19:09,330
one million of these scatter gather entries

02:19:09,330 --> 02:19:10,600
to the device.

02:19:10,600 --> 02:19:12,980
Usually, devices support maybe 100,000 or so,

02:19:12,980 --> 02:19:15,990
so you're getting chunks supplemented to the device

02:19:15,990 --> 02:19:18,620
and you're allocating huge areas of memory

02:19:18,620 --> 02:19:19,700
just for the descriptors.

02:19:19,700 --> 02:19:21,410
There have been situations in the past

02:19:21,410 --> 02:19:23,631
where we had ran out of memory

02:19:23,631 --> 02:19:25,430
because we didn't have enough contiguous memory

02:19:25,430 --> 02:19:27,870
so the tables to describe this request,

02:19:27,870 --> 02:19:29,270
send it to a disk,

02:19:29,270 --> 02:19:33,650
so the tables tend to just have been virtualized, as well,

02:19:33,650 --> 02:19:35,640
and they have no reallocate virtual memory

02:19:35,640 --> 02:19:37,760
because they can't rely then on four kilobyte pages.

02:19:37,760 --> 02:19:39,050
Could be a gigabyte that you need

02:19:39,050 --> 02:19:41,320
for the descriptors to send down to the devices.

02:19:41,320 --> 02:19:42,153
- [Jason] And then you have tables and tables.

02:19:42,153 --> 02:19:43,130
- And then you have all sorts,

02:19:43,130 --> 02:19:45,370
we get stuff going on with that one.

02:19:45,370 --> 02:19:47,480
So, if you have two meg pages,

02:19:47,480 --> 02:19:50,010
you cut this by 512,

02:19:51,008 --> 02:19:52,880
so you reduce it significantly.

02:19:52,880 --> 02:19:54,170
The idea, I think, would be, of course,

02:19:54,170 --> 02:19:55,240
if it was dynamic

02:19:56,169 --> 02:19:57,940
and specify the order of these things.

02:19:58,960 --> 02:20:00,620
- Would there be another day

02:20:00,620 --> 02:20:01,610
to do more

02:20:01,610 --> 02:20:05,620
of software page sizes?

02:20:05,620 --> 02:20:07,050
Maintain the pages in,

02:20:07,050 --> 02:20:09,510
let's say, two pages at a time

02:20:09,510 --> 02:20:10,560
type of thing?

02:20:10,560 --> 02:20:12,000
- That has been done

02:20:12,000 --> 02:20:14,010
in 2003, 2004 by one guy,

02:20:15,573 --> 02:20:17,340
and in 2007, I had my implementation.

02:20:17,340 --> 02:20:19,495
- [Man] Yeah, I think I recalled something like that.

02:20:19,495 --> 02:20:20,496
- But that's all running

02:20:20,496 --> 02:20:21,991
against the same problem of de-fragmentation.

02:20:21,991 --> 02:20:23,100
If you have multiple page sizes

02:20:23,100 --> 02:20:24,030
that you manage it,

02:20:24,030 --> 02:20:25,662
at some point,

02:20:25,662 --> 02:20:27,030
you can't allocate the larger page sizes,

02:20:27,030 --> 02:20:28,167
same thing with huge pages.

02:20:28,167 --> 02:20:30,780
If you have more than two different types,

02:20:30,780 --> 02:20:32,740
then the problem gets even worse,

02:20:32,740 --> 02:20:35,670
and it gets down the hill faster.

02:20:35,670 --> 02:20:38,100
- But you said 64K worked,

02:20:38,100 --> 02:20:40,450
so if you have software 64K.

02:20:40,450 --> 02:20:41,283
- [Christoph] No, no.

02:20:41,283 --> 02:20:43,080
Software 64K is a smaller page size.

02:20:43,080 --> 02:20:44,810
It's the uniform page sizes. - Yes, yes.

02:20:44,810 --> 02:20:45,643
I understand that,

02:20:45,643 --> 02:20:47,400
but if you do the software,

02:20:47,400 --> 02:20:50,360
you just make the smallest allocator be 64K

02:20:50,360 --> 02:20:51,660
on a four K,

02:20:51,660 --> 02:20:52,870
that solves the problem

02:20:52,870 --> 02:20:54,530
because that's what you get today.

02:20:54,530 --> 02:20:55,480
- ARM can do that

02:20:55,480 --> 02:20:56,870
because it keeps the page state

02:20:56,870 --> 02:20:58,790
for 64K of pages

02:20:58,790 --> 02:21:01,010
in the first page table entry.

02:21:01,010 --> 02:21:02,240
- -- cannot do that.

02:21:02,240 --> 02:21:04,280
It keeps the state distributed

02:21:04,280 --> 02:21:06,260
over 16 or so entries,

02:21:06,260 --> 02:21:08,880
and the M must have an atomic way

02:21:08,880 --> 02:21:12,000
to update the various stage of the page table,

02:21:12,000 --> 02:21:13,710
and all these pages

02:21:14,863 --> 02:21:15,696
on this account.

02:21:16,583 --> 02:21:17,583
You get extremely complex

02:21:17,583 --> 02:21:18,970
to handle the page state modifications

02:21:18,970 --> 02:21:21,740
by the CPU and synchronize that with the kernel.

02:21:21,740 --> 02:21:23,410
- [Jason] If they're not atomic.

02:21:23,410 --> 02:21:24,433
- Yes.

02:21:24,433 --> 02:21:25,266
(laughing)

02:21:25,266 --> 02:21:26,530
And these things are at the very low level,

02:21:26,530 --> 02:21:28,170
nested in an extreme high

02:21:28,170 --> 02:21:30,030
and some other locking structures,

02:21:30,030 --> 02:21:31,230
and if you do that

02:21:31,230 --> 02:21:33,060
and you get some issue,

02:21:33,060 --> 02:21:34,250
you can't recover.

02:21:34,250 --> 02:21:36,948
- [Jason] We are beset on all sides by locking.

02:21:36,948 --> 02:21:39,198
(laughing)

02:21:41,320 --> 02:21:43,600
- So, if Intel would adopt the ARM approach

02:21:43,600 --> 02:21:46,430
and put this data in the first of the page table structures,

02:21:46,430 --> 02:21:47,263
we could do this.

02:21:47,263 --> 02:21:49,910
Actually, we have code already in ARM that does this,

02:21:52,980 --> 02:21:55,755
but anyways, I've been trying to get to the CPU team

02:21:55,755 --> 02:21:57,480
for entry for a while,

02:21:57,480 --> 02:22:00,838
and they've always said that their way is the best way

02:22:00,838 --> 02:22:01,671
and they can't change it.

02:22:01,671 --> 02:22:02,846
It's old.

02:22:02,846 --> 02:22:03,700
It has been there for decades now

02:22:03,700 --> 02:22:04,860
and works well,

02:22:04,860 --> 02:22:07,929
very optimized and stuff.

02:22:07,929 --> 02:22:08,930
- [Man] Optimized.

02:22:08,930 --> 02:22:10,610
- Optimized, yes. (laughing)

02:22:10,610 --> 02:22:13,170
It's optimize for ghosts.

02:22:13,170 --> 02:22:14,450
- Okay.

02:22:14,450 --> 02:22:15,283
- [Jason] Okay.

02:22:16,475 --> 02:22:18,070
All right, moving on.

02:22:23,207 --> 02:22:26,374
(audience applauding)

02:22:34,877 --> 02:22:37,794
(quiet chattering)

02:23:01,640 --> 02:23:04,890
- I could hear this - This talk is about

02:23:07,283 --> 02:23:09,650
- So if you - Can anyone hear me?

02:23:10,821 --> 02:23:12,100
- Yes. - 'Cause I'm not

02:23:12,100 --> 02:23:13,130
hearing myself. (people chattering)

02:23:13,130 --> 02:23:13,963
Anyway.

02:23:15,351 --> 02:23:17,600
- On the side. - Oh, okay.

02:23:17,600 --> 02:23:20,715
- For a proposal for how to share

02:23:20,715 --> 02:23:24,880
hardware objects between more

02:23:24,880 --> 02:23:26,250
than two processes.

02:23:27,930 --> 02:23:30,320
Funny thing is that I came here

02:23:30,320 --> 02:23:32,480
with a knowledge that I'm the only user

02:23:32,480 --> 02:23:34,580
and then, I met Alex,

02:23:34,580 --> 02:23:35,750
and I came to learn

02:23:35,750 --> 02:23:39,860
that there is a parallel effort

02:23:39,860 --> 02:23:42,800
similar effort for that,

02:23:42,800 --> 02:23:46,460
and they have a different approach.

02:23:46,460 --> 02:23:49,980
So, I will move fast on the slides,

02:23:49,980 --> 02:23:51,900
and then if Alex can join me,

02:23:51,900 --> 02:23:54,590
and then we can show the differences

02:23:54,590 --> 02:23:55,970
between the two approaches.

02:24:00,990 --> 02:24:05,307
Historically, this is used by Oracle

02:24:05,307 --> 02:24:06,790
for some time.

02:24:08,150 --> 02:24:09,320
Shamir was the one

02:24:09,320 --> 02:24:12,750
that took the effort

02:24:12,750 --> 02:24:16,200
to upstream this project,

02:24:16,200 --> 02:24:19,050
and I just pulled because Shamir,

02:24:19,050 --> 02:24:22,630
unfortunately, can no longer work on this project.

02:24:22,630 --> 02:24:24,230
I was pulled into it.

02:24:26,480 --> 02:24:28,560
So, here's the things I'm gonna talk.

02:24:28,560 --> 02:24:31,770
Mostly, I'm gonna touch the use case,

02:24:31,770 --> 02:24:33,220
as I see it,

02:24:33,220 --> 02:24:35,820
and then I will go over the API,

02:24:35,820 --> 02:24:38,380
how different process

02:24:38,380 --> 02:24:41,780
can get the objects.

02:24:44,470 --> 02:24:45,820
So, here's the thing.

02:24:45,820 --> 02:24:48,250
Consider a huge server

02:24:48,250 --> 02:24:50,480
with a huge amount of memory

02:24:50,480 --> 02:24:52,520
and many, many processes

02:24:52,520 --> 02:24:54,580
that serves client requests

02:24:55,640 --> 02:24:57,310
and each one of the process

02:24:57,310 --> 02:25:00,410
have create it's own MR,

02:25:00,410 --> 02:25:02,060
so the hardware

02:25:02,060 --> 02:25:03,370
needs to handle

02:25:03,370 --> 02:25:07,580
all of these thousands MR.

02:25:07,580 --> 02:25:08,950
So maybe, a better approach

02:25:08,950 --> 02:25:10,770
would be that one process

02:25:10,770 --> 02:25:15,180
would create one or maybe a few MRs

02:25:15,180 --> 02:25:16,310
and they will share it

02:25:16,310 --> 02:25:18,620
with some other process,

02:25:18,620 --> 02:25:21,910
it's like it's sharing the shared memory.

02:25:24,010 --> 02:25:25,910
So then, the other processes

02:25:25,910 --> 02:25:28,590
can use this MR

02:25:28,590 --> 02:25:30,860
and serve their clients.

02:25:30,860 --> 02:25:33,070
So, we only have only one

02:25:34,904 --> 02:25:35,737
of few MRs.

02:25:38,870 --> 02:25:40,800
Maybe I can stop here for a discussion

02:25:40,800 --> 02:25:42,920
because this is the use case,

02:25:42,920 --> 02:25:45,680
and I sense some feedbacks

02:25:45,680 --> 02:25:47,630
on the list on that,

02:25:47,630 --> 02:25:49,840
like security things,

02:25:49,840 --> 02:25:52,620
because we are sharing context

02:25:52,620 --> 02:25:54,860
and PD and MR

02:25:54,860 --> 02:25:57,730
between a few processes.

02:26:01,020 --> 02:26:03,060
- It's a little unusual

02:26:03,060 --> 02:26:06,100
that you're sharing access to process memory,

02:26:06,100 --> 02:26:09,810
but it doesn't strike me as a security thing

02:26:09,810 --> 02:26:10,990
because the process,

02:26:12,330 --> 02:26:16,090
all the sharing was mediated with file descriptors already

02:26:16,090 --> 02:26:17,960
and there's all kinds of ways you can share

02:26:17,960 --> 02:26:19,730
process memory using file descriptors,

02:26:19,730 --> 02:26:22,280
like with file-backed MFs and things,

02:26:23,630 --> 02:26:25,780
so it's not completely out of left field.

02:26:27,330 --> 02:26:29,154
- You mean, it's not a big haul.

02:26:29,154 --> 02:26:32,569
Any way you can share memory between processes.

02:26:32,569 --> 02:26:34,540
- That's what RDMA does here.

02:26:34,540 --> 02:26:35,650
You're creating an RDMA object

02:26:35,650 --> 02:26:36,880
that shares the memory of the process

02:26:36,880 --> 02:26:38,410
and then giving it to a remote user.

02:26:38,410 --> 02:26:40,310
Why would you tell me there's a security problem

02:26:40,310 --> 02:26:41,957
to get that same object to a local user?

02:26:41,957 --> 02:26:45,350
It doesn't make a lot of sense.

02:26:46,440 --> 02:26:48,770
I don't think there's a security concern here.

02:26:48,770 --> 02:26:51,470
So long as it's constrained by file descriptor passing

02:26:52,931 --> 02:26:54,740
and with the understanding that you have access

02:26:54,740 --> 02:26:55,739
to the file descriptor,

02:26:55,739 --> 02:26:57,150
you have access to all this stuff that's in it,

02:26:57,150 --> 02:26:59,430
including the memory maps and the R keys

02:26:59,430 --> 02:27:01,070
and so forth.

02:27:01,070 --> 02:27:03,390
- Any way to achieve that two processes

02:27:03,390 --> 02:27:05,440
have to share the memory itself,

02:27:05,440 --> 02:27:07,090
not only the MR.

02:27:07,090 --> 02:27:08,860
So, if they can share the memory,

02:27:08,860 --> 02:27:10,860
the MR is the next step anyway.

02:27:16,290 --> 02:27:19,630
- So, we have some solving SHMEM solutions.

02:27:19,630 --> 02:27:20,530
We have some cases

02:27:21,715 --> 02:27:23,310
where we're not even sharing the memory,

02:27:23,310 --> 02:27:24,830
we're just sharing the MR.

02:27:24,830 --> 02:27:29,080
Each process places its part of the data in its memory,

02:27:29,080 --> 02:27:31,220
but one process with send a scatter gather

02:27:31,220 --> 02:27:33,790
with all the memory from all the processes,

02:27:33,790 --> 02:27:35,820
even without sharing it.

02:27:35,820 --> 02:27:38,610
- So, one process will do the transmission

02:27:38,610 --> 02:27:40,813
on behalf of the other processes.

02:27:40,813 --> 02:27:42,510
- On behalf of all the rest of the processes, yeah.

02:27:42,510 --> 02:27:45,680
So, there's no real memory sharing between them,

02:27:45,680 --> 02:27:48,530
but there is sharing of the PDNMR,

02:27:48,530 --> 02:27:50,610
so one can do the transaction.

02:27:50,610 --> 02:27:53,270
- So, one process will do the transformation only.

02:27:53,270 --> 02:27:54,860
How the other processes

02:27:54,860 --> 02:27:57,600
will let them know.

02:27:57,600 --> 02:27:58,433
- They're ready?

02:27:59,280 --> 02:28:01,860
Might be some signaling. - Some sort of course.

02:28:01,860 --> 02:28:02,780
- Yeah. - Okay.

02:28:02,780 --> 02:28:04,220
- [Alex] Some sort of signaling of some kind.

02:28:04,220 --> 02:28:05,550
- Yeah, not separated.

02:28:05,550 --> 02:28:06,420
- [Jason] Alex, behind you.

02:28:06,420 --> 02:28:07,370
Alex. - The logic.

02:28:08,260 --> 02:28:10,070
So, the logic is central.

02:28:11,420 --> 02:28:12,380
The logic is central,

02:28:12,380 --> 02:28:15,170
so if you have thousand processes,

02:28:15,170 --> 02:28:17,690
you have to schedule between them.

02:28:17,690 --> 02:28:20,300
- So in that case, are you doing that

02:28:20,300 --> 02:28:23,397
with a single memory registration?

02:28:23,397 --> 02:28:25,920
Because each process has to register

02:28:25,920 --> 02:28:27,472
their piece of that, right?

02:28:27,472 --> 02:28:29,362
- [Jerome No.

02:28:29,362 --> 02:28:31,840
(quiet chattering)

02:28:31,840 --> 02:28:33,840
- So, this is a model we want to get to.

02:28:36,270 --> 02:28:38,130
We have, Yuval is working on one model.

02:28:38,130 --> 02:28:40,810
We wanted to work on a very similar,

02:28:40,810 --> 02:28:41,950
but slightly different model,

02:28:41,950 --> 02:28:44,360
so you can have each process

02:28:44,360 --> 02:28:46,700
share its own M key.

02:28:46,700 --> 02:28:48,200
Well, they have to share a PD

02:28:48,200 --> 02:28:49,690
between all the processes. - Sure.

02:28:49,690 --> 02:28:51,640
- Each one registers its one memory,

02:28:51,640 --> 02:28:53,970
but just passes the L key

02:28:53,970 --> 02:28:55,910
to the orchestration process

02:28:55,910 --> 02:28:57,060
to do the transmission.

02:28:57,060 --> 02:28:58,150
- So, he bundles them up

02:28:58,150 --> 02:28:59,610
and does a single. - Yeah,

02:28:59,610 --> 02:29:01,420
and obviously, each one has to signal

02:29:01,420 --> 02:29:04,050
when its data is ready in some way,

02:29:04,050 --> 02:29:05,690
or if it's an incoming message,

02:29:05,690 --> 02:29:08,060
you separate the data and tell them it's ready.

02:29:08,060 --> 02:29:08,893
- All right.

02:29:10,010 --> 02:29:11,740
Okay. - So, I think

02:29:11,740 --> 02:29:12,660
the whole use case for this, originally,

02:29:12,660 --> 02:29:16,650
was that there is a limited amount of MRs,

02:29:17,700 --> 02:29:19,740
so there's a resource, really,

02:29:19,740 --> 02:29:21,060
that's solved by this.

02:29:21,060 --> 02:29:24,010
It's possible to have more processes

02:29:24,010 --> 02:29:26,420
accessing the same amount of memory

02:29:26,420 --> 02:29:29,040
with the fewer MRs, basically.

02:29:30,090 --> 02:29:32,400
So, I think that's the root of it.

02:29:34,750 --> 02:29:37,720
- So, I don't think there's a real limit on MRs.

02:29:37,720 --> 02:29:38,650
They're huge.

02:29:39,500 --> 02:29:41,740
There is a performance penalty.

02:29:41,740 --> 02:29:43,580
Yeah, but there is a performance penalty

02:29:43,580 --> 02:29:46,420
if you register the same shared memory

02:29:46,420 --> 02:29:48,540
for each process with its own M key,

02:29:48,540 --> 02:29:50,970
so you're abusing, maybe,

02:29:50,970 --> 02:29:54,100
the amount of M keys for the same memory region,

02:29:54,100 --> 02:29:55,560
and if they're all sharing it,

02:29:55,560 --> 02:29:56,630
so it's simpler,

02:29:56,630 --> 02:29:57,880
the penalty on the hardware,

02:29:57,880 --> 02:29:59,730
the penalty on everything is larger.

02:30:02,640 --> 02:30:03,524
- Yes, but still,

02:30:03,524 --> 02:30:05,200
I think that's the use case

02:30:05,200 --> 02:30:06,820
that I have in the database.

02:30:07,724 --> 02:30:09,010
(dishes clattering)

02:30:09,010 --> 02:30:11,570
- But still, it will be much better,

02:30:11,570 --> 02:30:13,160
designed like this.

02:30:13,160 --> 02:30:14,960
A process that, okay.

02:30:18,048 --> 02:30:20,080
- Yeah, sorry.

02:30:20,080 --> 02:30:22,260
But implicit in this

02:30:22,260 --> 02:30:23,660
is if you're sharing the MR,

02:30:24,608 --> 02:30:25,480
then you've also shared the PD.

02:30:25,480 --> 02:30:27,410
So, you're putting all of these processes

02:30:27,410 --> 02:30:29,600
in the same security domain, same PD.

02:30:30,900 --> 02:30:31,970
- Yes. - And this,

02:30:31,970 --> 02:30:34,170
everybody understands that this is what's happening.

02:30:34,170 --> 02:30:35,500
- Yeah.

02:30:35,500 --> 02:30:38,120
- So, kinda my next question

02:30:38,120 --> 02:30:40,530
is why can't you just share

02:30:40,530 --> 02:30:43,300
the singular uverb's context FD?

02:30:43,300 --> 02:30:44,133
Why do you need?

02:30:46,010 --> 02:30:48,370
- Yeah, it's really based on that.

02:30:48,370 --> 02:30:49,266
- [Ira] I second that.

02:30:49,266 --> 02:30:51,830
- [Yuval] Oh, okay.

02:30:51,830 --> 02:30:54,350
- That gets back to my talk earlier

02:30:54,350 --> 02:30:57,520
because for what I'm working on,

02:30:57,520 --> 02:30:59,850
just sharing these little memory registration objects

02:30:59,850 --> 02:31:02,140
kinda breaks my architecture,

02:31:02,140 --> 02:31:03,590
where that doesn't get tracked,

02:31:03,590 --> 02:31:06,170
but if you just shared the whole context

02:31:06,170 --> 02:31:08,020
protection domain file descriptor,

02:31:08,020 --> 02:31:09,850
then everything's just beauty

02:31:09,850 --> 02:31:11,410
and it doesn't matter.

02:31:12,270 --> 02:31:13,760
So, yeah.

02:31:13,760 --> 02:31:15,830
That's why I'm a little concerned

02:31:15,830 --> 02:31:17,450
with your patch set on the list,

02:31:17,450 --> 02:31:19,830
but I'm not saying that what you are trying

02:31:19,830 --> 02:31:20,980
to do isn't wrong,

02:31:20,980 --> 02:31:23,980
it's just that I think maintaining

02:31:23,980 --> 02:31:25,880
the file descriptor model is important

02:31:26,980 --> 02:31:29,169
for a number of reasons.

02:31:29,169 --> 02:31:31,950
- Can you use a single file descriptor?

02:31:31,950 --> 02:31:34,660
Do you need these things in distinct file descriptors?

02:31:34,660 --> 02:31:35,493
- Yes, but still,

02:31:35,493 --> 02:31:39,740
how the other process get handled,

02:31:39,740 --> 02:31:41,910
not handled, the object,

02:31:41,910 --> 02:31:43,263
the PD itself,

02:31:43,263 --> 02:31:44,800
it has the context.

02:31:44,800 --> 02:31:45,710
- So Yuval, the thing,

02:31:45,710 --> 02:31:48,100
this is the difference between what we discussed

02:31:48,100 --> 02:31:50,270
where we see this

02:31:50,270 --> 02:31:51,730
as a single business logic

02:31:51,730 --> 02:31:53,830
running just on multiple processes.

02:31:53,830 --> 02:31:56,050
So, if a main process passes

02:31:56,050 --> 02:31:58,240
that FD to all the other processes,

02:31:58,240 --> 02:32:00,200
they share the same kernel context.

02:32:00,200 --> 02:32:02,380
It's just like running different threads

02:32:02,380 --> 02:32:04,200
in the current design.

02:32:04,200 --> 02:32:05,855
There's just the issue

02:32:05,855 --> 02:32:08,592
of how do these separate user space contexts

02:32:08,592 --> 02:32:10,200
reproduce the verb handles

02:32:10,200 --> 02:32:12,730
in their user space area?

02:32:12,730 --> 02:32:14,210
But then, there's no security

02:32:14,210 --> 02:32:15,420
between the processes.

02:32:15,420 --> 02:32:17,990
They're all sharing the same U context.

02:32:17,990 --> 02:32:19,300
All the objects are shared.

02:32:19,300 --> 02:32:21,210
Each one can may be destroyed or ruined,

02:32:21,210 --> 02:32:23,470
but again, it's like a multi-thread model.

02:32:25,836 --> 02:32:26,669
We discussed this,

02:32:26,669 --> 02:32:29,470
and you have to maybe check with the rest of your team.

02:32:29,470 --> 02:32:32,000
Is the security between the processes

02:32:32,000 --> 02:32:33,550
required in some way?

02:32:33,550 --> 02:32:34,480
I can create a PD,

02:32:34,480 --> 02:32:35,890
I can pass it to you,

02:32:35,890 --> 02:32:38,290
but you're not gonna tell me

02:32:38,290 --> 02:32:40,870
additional information of how you're gonna use it,

02:32:40,870 --> 02:32:42,652
or maybe I'll pass it.

02:32:42,652 --> 02:32:44,270
Sorry.

02:32:44,270 --> 02:32:45,621
- [Jason] It's behind you.

02:32:45,621 --> 02:32:46,454
- Oh.

02:32:46,454 --> 02:32:47,850
- But one suggestion on that

02:32:47,850 --> 02:32:49,350
is you pass the FD,

02:32:49,350 --> 02:32:50,450
like we're talking about,

02:32:50,450 --> 02:32:52,030
but then we have additional calls

02:32:52,030 --> 02:32:54,920
that say, "now that I've got this FD,

02:32:54,920 --> 02:32:56,900
"I want access to this object,

02:32:56,900 --> 02:32:57,733
"and there's." - No, no.

02:32:57,733 --> 02:32:59,310
We can't do that.

02:32:59,310 --> 02:33:00,250
- Why? - If you have the FD,

02:33:00,250 --> 02:33:02,180
you have access to everything in it.

02:33:02,180 --> 02:33:03,570
That's the Unix.

02:33:07,440 --> 02:33:08,500
- I'm okay with that,

02:33:08,500 --> 02:33:11,430
but he doesn't want to share everything.

02:33:11,430 --> 02:33:12,620
Is that true?

02:33:12,620 --> 02:33:14,960
Or can you share everything? - That's what my thought,

02:33:14,960 --> 02:33:17,150
and I think this is difference between the two,

02:33:17,150 --> 02:33:18,970
but I'm not sure that that is correct,

02:33:18,970 --> 02:33:19,900
so idea here

02:33:21,100 --> 02:33:23,100
is that one process create the context,

02:33:23,100 --> 02:33:25,940
is sharing the context,

02:33:25,940 --> 02:33:29,230
but then the second process

02:33:29,230 --> 02:33:32,110
has its own context that it can create

02:33:32,110 --> 02:33:34,190
some other PDs on top of the other.

02:33:35,560 --> 02:33:36,393
So, see.

02:33:36,393 --> 02:33:40,390
If the second process will use the shell context.

02:33:40,390 --> 02:33:42,190
Why? - Why does the second PD

02:33:42,190 --> 02:33:44,630
need to be in the same ucontext

02:33:44,630 --> 02:33:46,344
as the first? - Well, not the same.

02:33:46,344 --> 02:33:48,280
An extra one. - But you can't

02:33:48,280 --> 02:33:49,480
share the memory regions

02:33:49,480 --> 02:33:51,546
across that protection domain. - You can also

02:33:51,546 --> 02:33:52,544
have two FDs, right?

02:33:52,544 --> 02:33:54,587
You can open a private FD

02:33:54,587 --> 02:33:55,586
and a shared FD. - Yeah, that's what I mean,

02:33:55,586 --> 02:33:56,584
and do its work on the private.

02:33:56,584 --> 02:33:59,406
- But they have to be in the same protection domain.

02:33:59,406 --> 02:34:00,730
- No. - Only if

02:34:00,730 --> 02:34:02,820
they're gonna use that MR.

02:34:02,820 --> 02:34:05,245
- Well, that's what we're talking about,

02:34:05,245 --> 02:34:06,720
using the same MR. - Well, that's the point.

02:34:06,720 --> 02:34:08,070
If you're gonna use the MR,

02:34:09,483 --> 02:34:10,481
then all of your IB objects

02:34:10,481 --> 02:34:11,314
have to be in the same protection domain,

02:34:11,314 --> 02:34:12,950
and of course, they can influence each other

02:34:12,950 --> 02:34:14,610
in sort of unpredictable ways

02:34:14,610 --> 02:34:17,740
because the model for security is the protection domain

02:34:17,740 --> 02:34:19,189
is the barrier.

02:34:19,189 --> 02:34:20,180
You can't go outside your protection domain,

02:34:20,180 --> 02:34:21,780
but there's nothing to say you can't,

02:34:21,780 --> 02:34:25,300
you can invalidate any M key in that protection domain.

02:34:25,300 --> 02:34:27,800
Who knows what you could do to the QPS

02:34:27,800 --> 02:34:29,370
and onwards and onwards.

02:34:29,370 --> 02:34:32,170
- Right, so as soon as you have

02:34:32,170 --> 02:34:33,003
this private FD,

02:34:34,154 --> 02:34:37,070
as soon as you allow him access into that protection domain,

02:34:37,070 --> 02:34:39,990
he has access to everything,

02:34:41,190 --> 02:34:43,465
so it might as well just be a dup of the FD.

02:34:43,465 --> 02:34:45,100
- No, I think it's not a matter of security here.

02:34:45,100 --> 02:34:47,010
I'm trusting the other process.

02:34:47,010 --> 02:34:49,430
This is why I gave him the FD.

02:34:49,430 --> 02:34:50,800
- Okay. - But then,

02:34:50,800 --> 02:34:53,350
who handle the reference governing of the object?

02:34:53,350 --> 02:34:57,400
In his model, there is only one user object

02:34:57,400 --> 02:35:00,020
and each one of them can destroy the object.

02:35:00,020 --> 02:35:02,930
- Well, I think we need to solve that problem,

02:35:02,930 --> 02:35:05,380
and if we can solve that problem independently

02:35:05,380 --> 02:35:10,260
of having to do funny things with FDs,

02:35:10,260 --> 02:35:11,610
I think that would be okay,

02:35:13,175 --> 02:35:15,340
and my suggestion, when I heard what Alex was talking about,

02:35:15,340 --> 02:35:18,720
was I said, "well, why don't we just dup the U object

02:35:18,720 --> 02:35:20,300
"inside the same FD?"

02:35:20,300 --> 02:35:22,696
So, we have two IDR entries

02:35:22,696 --> 02:35:23,920
pointing to the same hardware object,

02:35:25,366 --> 02:35:27,970
and then we can do reference counting the way we want

02:35:27,970 --> 02:35:29,070
and everything's okay.

02:35:30,910 --> 02:35:33,130
That seems like it might work.

02:35:34,230 --> 02:35:36,440
- Don't you inherently get that though?

02:35:36,440 --> 02:35:37,480
- [Yuval] So, you mean there will be.

02:35:37,480 --> 02:35:38,370
- The ufile.

02:35:39,690 --> 02:35:41,780
- But if you have two processes,

02:35:41,780 --> 02:35:44,080
so you would have to IFDPDs

02:35:44,080 --> 02:35:46,200
and each process can destroy it,

02:35:46,200 --> 02:35:48,540
but there's only one kernel instance,

02:35:48,540 --> 02:35:49,930
so you have to have a reference,

02:35:49,930 --> 02:35:51,640
or as Jason suggested,

02:35:51,640 --> 02:35:54,620
two uobjects in the kernel to present them.

02:35:54,620 --> 02:35:56,870
So, we're talking about two different things here.

02:35:56,870 --> 02:35:59,160
First of all, the security model,

02:35:59,160 --> 02:36:00,950
are we okay with sharing everything?

02:36:00,950 --> 02:36:03,660
Because that's inherent the moment you share the FD,

02:36:03,660 --> 02:36:05,470
and then the implementation details,

02:36:06,485 --> 02:36:08,350
which there's some issues there to resolve.

02:36:08,350 --> 02:36:11,360
- [Yuval] There's no issue of security, right?

02:36:11,360 --> 02:36:13,640
- I think that actually dove tails

02:36:13,640 --> 02:36:14,840
into the security model.

02:36:14,840 --> 02:36:17,990
If I can close your memory region,

02:36:17,990 --> 02:36:20,640
that's part of what you're opening yourself up to here

02:36:20,640 --> 02:36:23,470
is if I'm allowing you another process

02:36:23,470 --> 02:36:24,890
to take control of this.

02:36:24,890 --> 02:36:26,440
- [Jason] There's allowing for security thing

02:36:26,440 --> 02:36:27,940
and then there's the next step

02:36:29,658 --> 02:36:31,140
is making it possible to write a correct application

02:36:31,140 --> 02:36:32,310
that has the semantics you want,

02:36:32,310 --> 02:36:34,060
and for that, you really do want ref counting.

02:36:34,060 --> 02:36:35,650
You wanna say, "I've shared this MR

02:36:35,650 --> 02:36:36,830
"to a bunch of places,

02:36:36,830 --> 02:36:37,730
"they're gonna cooperate,

02:36:37,730 --> 02:36:38,910
"they're gonna play by the rules,

02:36:38,910 --> 02:36:41,240
"and everything will work out."

02:36:41,240 --> 02:36:45,310
- So, that's kinda where my IOCTL

02:36:45,310 --> 02:36:47,240
just off the top of my head idea was

02:36:47,240 --> 02:36:49,170
is that this other process could say, "hey,

02:36:49,170 --> 02:36:50,630
"I wanna take a reference to this,"

02:36:50,630 --> 02:36:53,190
or something that says, "okay,

02:36:53,190 --> 02:36:55,160
"I don't want this to go away,

02:36:55,160 --> 02:36:56,892
"even if somebody else closes it,"

02:36:56,892 --> 02:36:59,270
but I'm not saying that's the right thing to do,

02:36:59,270 --> 02:37:01,170
but that's kinda what I'm thinking

02:37:01,170 --> 02:37:05,110
because in my very simplistic view,

02:37:05,110 --> 02:37:07,030
I'm like, if you're sharing this across this,

02:37:07,030 --> 02:37:08,600
you have to have some communication

02:37:08,600 --> 02:37:09,850
between the processes

02:37:09,850 --> 02:37:11,590
so that they're not closing memory regions

02:37:11,590 --> 02:37:13,140
out from each other.

02:37:13,140 --> 02:37:15,290
- [Jason] But still, you want the process

02:37:15,290 --> 02:37:16,860
to say, "oh, I'm done with that memory region.

02:37:16,860 --> 02:37:18,510
"If everybody else is done with it, delete it."

02:37:18,510 --> 02:37:19,700
You need that kind of semantic

02:37:19,700 --> 02:37:21,920
to make this actually workable.

02:37:21,920 --> 02:37:23,360
- Not necessarily.

02:37:24,220 --> 02:37:25,790
- Yeah, I think so. - They can do that

02:37:25,790 --> 02:37:26,670
on their own, though.

02:37:26,670 --> 02:37:28,689
They can communicate, "hey,

02:37:28,689 --> 02:37:29,522
"we're all done with this memory region,"

02:37:29,522 --> 02:37:31,325
and somebody destroys it. - They could,

02:37:31,325 --> 02:37:32,482
but then you're creating a big mess for them.

02:37:32,482 --> 02:37:34,030
You've created a feature that's kind of half unusable,

02:37:34,030 --> 02:37:36,210
and I've been thinking some more about Alex's thought,

02:37:36,210 --> 02:37:38,650
and I think it would be relatively easy

02:37:38,650 --> 02:37:42,146
to put what I'm gonna call a proxy uobject

02:37:42,146 --> 02:37:44,260
in the IDR,

02:37:44,260 --> 02:37:45,340
well, it's an X-Ray now,

02:37:45,340 --> 02:37:46,450
in the X-Ray,

02:37:46,450 --> 02:37:47,300
it would be owned

02:37:49,173 --> 02:37:50,006
by the other processes,

02:37:50,006 --> 02:37:51,880
and somehow this proxy one

02:37:51,880 --> 02:37:54,230
would refer back to the real one.

02:37:55,090 --> 02:37:57,552
You could build the ref counting that way

02:37:57,552 --> 02:37:59,610
and keep everything on track.

02:37:59,610 --> 02:38:02,440
- But still, that's on the whole global.

02:38:02,440 --> 02:38:04,650
So, what you really want is per MR.

02:38:05,940 --> 02:38:07,970
- How about saving this reference count

02:38:07,970 --> 02:38:09,470
in the hardware object,

02:38:10,420 --> 02:38:11,920
and that's it?

02:38:11,920 --> 02:38:13,080
- Depends on the hardware vendor.

02:38:13,080 --> 02:38:14,103
- [Jason] No.

02:38:14,103 --> 02:38:14,936
- No, in the IBTD.

02:38:14,936 --> 02:38:16,420
- [Jason] We're not reference counting the hardware object,

02:38:16,420 --> 02:38:18,060
we're reference counting that IDR entry

02:38:18,060 --> 02:38:19,690
is how our system works.

02:38:19,690 --> 02:38:22,200
So, when you destroy that IDR entry,

02:38:24,107 --> 02:38:26,707
it needs to somehow decide when it goes away or not.

02:38:28,600 --> 02:38:30,270
We might be able to just put a reference count

02:38:30,270 --> 02:38:31,103
in the uobject.

02:38:31,947 --> 02:38:33,930
(mumbling)

02:38:33,930 --> 02:38:35,510
Well, the file's reference count is just fine,

02:38:35,510 --> 02:38:37,030
but there are sub objects in the file

02:38:37,030 --> 02:38:38,760
that we're keeping track of.

02:38:38,760 --> 02:38:41,300
The file holds many, many IP objects,

02:38:41,300 --> 02:38:43,460
and each of them needs to be kept track.

02:38:43,460 --> 02:38:44,350
Maybe, I don't know.

02:38:44,350 --> 02:38:45,821
- So, okay.

02:38:45,821 --> 02:38:46,690
How about we take a step back?

02:38:46,690 --> 02:38:48,660
Let's talk about how we share these objects.

02:38:48,660 --> 02:38:51,350
So, we said we share the protection domain

02:38:51,350 --> 02:38:53,620
by sharing the file,

02:38:54,580 --> 02:38:57,440
but then if I want you to use one of my memory regions,

02:38:57,440 --> 02:39:00,911
I have to share my L key, et cetera,

02:39:00,911 --> 02:39:01,780
so when that happens. - No.

02:39:01,780 --> 02:39:03,250
I want to see a model

02:39:03,250 --> 02:39:04,770
where, if you're gonna use an object,

02:39:04,770 --> 02:39:05,980
you share the object.

02:39:05,980 --> 02:39:08,460
So, you need to share the PD, obviously,

02:39:08,460 --> 02:39:10,430
and you need to share the MR, obviously,

02:39:10,430 --> 02:39:12,750
and the L key comes along with the sharing.

02:39:12,750 --> 02:39:13,752
- Okay, you didn't let me finish,

02:39:13,752 --> 02:39:14,740
but I have to communicate that information to you.

02:39:14,740 --> 02:39:17,580
When I do that, that's sharing the object,

02:39:17,580 --> 02:39:20,230
that increases a ref count, right?

02:39:20,230 --> 02:39:22,410
And then, there's some other reciprocal call

02:39:22,410 --> 02:39:24,060
that says, "okay,

02:39:24,060 --> 02:39:26,010
"I can hand it to you

02:39:26,010 --> 02:39:27,230
"and I can say I'm done with it,

02:39:27,230 --> 02:39:29,730
"that decrements it, and now you own it."

02:39:29,730 --> 02:39:32,860
- [Jason] Yeah, maybe that's what we should do.

02:39:32,860 --> 02:39:34,200
That makes some sense.

02:39:34,200 --> 02:39:36,780
- But I think, to get back to my talk,

02:39:36,780 --> 02:39:37,790
if you do that,

02:39:37,790 --> 02:39:39,470
if I were to share it with you,

02:39:39,470 --> 02:39:41,490
and then I drop my reference,

02:39:41,490 --> 02:39:46,490
then my reference should drop from the ufile, right?

02:39:47,080 --> 02:39:48,760
- [Jason] No, the ufile is linked

02:39:48,760 --> 02:39:49,710
to the file descriptor.

02:39:49,710 --> 02:39:52,410
If you have a file descriptor in your process's FD table,

02:39:52,410 --> 02:39:53,810
you have a references to it.

02:39:53,810 --> 02:39:56,536
Period, full stop. - Yes, but does my memory,

02:39:56,536 --> 02:39:58,280
if I share a memory region to you

02:39:58,280 --> 02:39:59,200
and hand it off to you

02:39:59,200 --> 02:40:02,110
and I wanna drop my references to that memory region.

02:40:02,110 --> 02:40:04,050
- [Jason] You can't do that.

02:40:04,050 --> 02:40:06,050
You're not actually doing anything.

02:40:06,050 --> 02:40:07,830
There's still one ufile.

02:40:08,800 --> 02:40:10,250
The kernel doesn't know

02:40:10,250 --> 02:40:12,060
which processes have this ufile.

02:40:12,060 --> 02:40:14,940
We're just giving a tool to user space

02:40:14,940 --> 02:40:18,020
to manage reference counts in a slightly different way.

02:40:18,020 --> 02:40:20,610
- Okay, but my point is that what you're proposing

02:40:20,610 --> 02:40:22,680
is that if I,

02:40:24,353 --> 02:40:25,186
okay, getting back to my talk,

02:40:25,186 --> 02:40:27,380
if I register a file and I pin it

02:40:27,380 --> 02:40:28,740
and then I hand it off to you

02:40:28,740 --> 02:40:30,480
and I'm not owning it anymore,

02:40:31,450 --> 02:40:33,830
I'm okay with saying both processes own it,

02:40:33,830 --> 02:40:36,530
but that's not what he wants.

02:40:36,530 --> 02:40:37,800
- [Jason] No, it is what he wants.

02:40:37,800 --> 02:40:40,160
- No, he said he wants to hand it off

02:40:40,160 --> 02:40:43,240
and maybe one process doesn't own it anymore.

02:40:43,240 --> 02:40:45,434
- [Jason] Somebody has to be responsible for this thing.

02:40:45,434 --> 02:40:49,995
- Yes, it gets handed off to somebody else.

02:40:49,995 --> 02:40:52,820
- [Jason] In RDMA, we don't really have

02:40:52,820 --> 02:40:54,160
a concept of an owner.

02:40:56,139 --> 02:40:57,520
The struct. - Yes, the protection domain.

02:40:57,520 --> 02:40:59,960
- I think it's the reference count model.

02:40:59,960 --> 02:41:01,190
That's my understanding of it.

02:41:01,190 --> 02:41:02,140
- [Jason] The reference count model.

02:41:02,140 --> 02:41:03,710
We don't have a concept of an owner.

02:41:03,710 --> 02:41:05,140
- If I'm sharing with you

02:41:05,140 --> 02:41:06,889
and I lowered my reference count

02:41:06,889 --> 02:41:08,471
so it's like test,

02:41:08,471 --> 02:41:10,909
we're on the same ucontext, anyway.

02:41:10,909 --> 02:41:13,350
- We don't really care who is the owner,

02:41:13,350 --> 02:41:16,340
just we're counting how many owners we have.

02:41:16,340 --> 02:41:17,240
So the last one,

02:41:17,240 --> 02:41:18,540
we disposed of the object.

02:41:20,943 --> 02:41:22,276
- I think we're.

02:41:23,566 --> 02:41:24,540
It's different semantics.

02:41:24,540 --> 02:41:27,170
I'm not explaining myself correctly.

02:41:27,170 --> 02:41:29,150
- [Jason] Give him the mic, I think, please.

02:41:30,970 --> 02:41:32,470
- It's not so much who owns it,

02:41:32,470 --> 02:41:33,390
who doesn't own it.

02:41:33,390 --> 02:41:35,040
It's who can use it.

02:41:35,040 --> 02:41:38,520
And who's holding that registration.

02:41:38,520 --> 02:41:40,350
- [Jason] If you have the struct file in your FD table,

02:41:40,350 --> 02:41:41,830
you can use it.

02:41:41,830 --> 02:41:42,680
That's it.

02:41:42,680 --> 02:41:44,540
That's the extent of it.

02:41:44,540 --> 02:41:47,700
- Okay, so why do we need to ref count it?

02:41:47,700 --> 02:41:50,430
If we have multiple files

02:41:50,430 --> 02:41:52,290
that are referencing that,

02:41:52,290 --> 02:41:54,310
ref count's taken care of.

02:41:54,310 --> 02:41:56,240
- [Jason] The issue is you want to make the applications

02:41:56,240 --> 02:41:57,073
easier to write,

02:41:57,073 --> 02:41:59,160
and the applications want different models.

02:41:59,160 --> 02:42:01,080
Some of the models are.

02:42:01,080 --> 02:42:02,950
All the applications are sharing the same file descriptor,

02:42:02,950 --> 02:42:05,363
but in some cases, one application might be responsible

02:42:05,363 --> 02:42:07,465
for a certain subset of objects,

02:42:07,465 --> 02:42:10,850
the other application for a non-overlapping subset,

02:42:10,850 --> 02:42:12,678
and then there's some objects

02:42:12,678 --> 02:42:13,511
where maybe they're jointly responsible.

02:42:13,511 --> 02:42:14,814
- Okay.

02:42:14,814 --> 02:42:16,490
- [Jason] And this is like a ref count model.

02:42:16,490 --> 02:42:18,800
- Okay, but that...

02:42:21,580 --> 02:42:23,020
Back to my talk,

02:42:23,020 --> 02:42:26,080
if you have a file that's pinned in some of those

02:42:26,080 --> 02:42:28,380
that's only being use in one application

02:42:28,380 --> 02:42:29,580
and he's done with them,

02:42:30,450 --> 02:42:32,450
which process does the system then kill?

02:42:33,830 --> 02:42:34,820
- [Jason] All of them.

02:42:36,130 --> 02:42:39,320
The only way to forcibly destroy that thing

02:42:39,320 --> 02:42:40,480
that you created

02:42:40,480 --> 02:42:42,990
is to close the uverbs file.

02:42:42,990 --> 02:42:45,130
The only way to close it is to destroy

02:42:45,130 --> 02:42:47,330
every single process that's holding it open.

02:42:49,480 --> 02:42:50,313
- Okay.

02:42:50,313 --> 02:42:52,050
- [Jason] We don't have a fine grain kill for RDMA.

02:42:52,050 --> 02:42:54,710
You can't just target one MR and kill it.

02:42:54,710 --> 02:42:55,543
- Yeah, okay.

02:42:55,543 --> 02:42:56,960
So, I don't understand why you're introducing

02:42:56,960 --> 02:42:58,450
all this complexity, then.

02:42:58,450 --> 02:42:59,460
- [Jason] It's to make the program.

02:42:59,460 --> 02:43:02,050
It's to make the applications easier to write.

02:43:02,050 --> 02:43:03,120
It's easier to write

02:43:03,120 --> 02:43:04,640
if the kernel provides the small amount

02:43:04,640 --> 02:43:06,380
of shared memory for the reference count,

02:43:06,380 --> 02:43:07,900
then you try and build the reference count

02:43:07,900 --> 02:43:10,450
using some kind of crazy RPC thing,

02:43:10,450 --> 02:43:13,043
'cause that's a very difficult application model.

02:43:15,521 --> 02:43:17,550
- I won't argue that point.

02:43:17,550 --> 02:43:19,143
I agree with you,

02:43:19,143 --> 02:43:20,840
but I kinda feel like if you don't have a reference

02:43:20,840 --> 02:43:22,640
to this object, you shouldn't.

02:43:24,360 --> 02:43:25,193
- [Jason] You have a reference.

02:43:25,193 --> 02:43:26,755
That's what we're talking about.

02:43:26,755 --> 02:43:27,944
We're talking about how do we create a reference.

02:43:27,944 --> 02:43:28,942
- If you don't,

02:43:28,942 --> 02:43:29,941
if you drop that reference,

02:43:29,941 --> 02:43:30,802
then it should be dropped.

02:43:30,802 --> 02:43:32,331
- [Yuval] Yes, yes.

02:43:32,331 --> 02:43:35,900
- Okay.

02:43:35,900 --> 02:43:37,735
Maybe we're just saying the same thing.

02:43:37,735 --> 02:43:39,243
(mumbling)

02:43:39,243 --> 02:43:40,140
I don't know.

02:43:40,140 --> 02:43:42,390
I didn't mean to derail here.

02:43:43,840 --> 02:43:45,131
- First of all,

02:43:45,131 --> 02:43:46,733
the question to answer

02:43:46,733 --> 02:43:49,810
is if you can accept a shared FD,

02:43:49,810 --> 02:43:52,015
instead of unique FDs,

02:43:52,015 --> 02:43:54,020
because the original patches Shamir posted

02:43:54,020 --> 02:43:57,430
had multiple uverbs FDs,

02:43:57,430 --> 02:43:59,320
every process had its own uverbs FD

02:43:59,320 --> 02:44:00,380
and its own X-Ray

02:44:00,380 --> 02:44:01,690
with its own list

02:44:01,690 --> 02:44:04,220
of uobjects in it,

02:44:04,220 --> 02:44:06,010
and some of those uobjects

02:44:06,010 --> 02:44:06,980
were the same uobjects

02:44:06,980 --> 02:44:09,300
that were in other people's lists.

02:44:09,300 --> 02:44:11,170
That's very complicated.

02:44:11,170 --> 02:44:14,010
If you can tolerate a single ucontext,

02:44:14,010 --> 02:44:15,900
a single IDR

02:44:15,900 --> 02:44:17,710
in all of your processes,

02:44:17,710 --> 02:44:19,310
that's immensely simplifying.

02:44:21,240 --> 02:44:22,930
- I don't have the answer now,

02:44:22,930 --> 02:44:24,130
but I promise to check.

02:44:25,615 --> 02:44:26,831
- [Jason] This is your homework.

02:44:26,831 --> 02:44:27,664
- Yeah.

02:44:27,664 --> 02:44:29,066
(laughing)

02:44:29,066 --> 02:44:30,910
(chattering and laughing)

02:44:30,910 --> 02:44:33,330
- I think that sounds somewhat reasonable.

02:44:33,330 --> 02:44:34,700
- [Yuval] Are you familiar with.

02:44:34,700 --> 02:44:36,080
- A little bit, yes,

02:44:36,080 --> 02:44:38,160
from the earlier version.

02:44:38,160 --> 02:44:40,430
I worked on trying to implement it

02:44:40,430 --> 02:44:42,400
or support it,

02:44:43,930 --> 02:44:45,380
so I'm familiar with it,

02:44:46,443 --> 02:44:49,593
and the version we had didn't work.

02:44:49,593 --> 02:44:51,550
It had its problem,

02:44:51,550 --> 02:44:54,010
the one that we were trying to support.

02:44:54,010 --> 02:44:55,710
- But his suggestion,

02:44:56,545 --> 02:44:57,540
like use the same context.

02:44:57,540 --> 02:44:59,180
- [Man] Probably better now.

02:44:59,180 --> 02:45:00,013
- [Jason] Right.

02:45:00,013 --> 02:45:01,515
We're kinda looking.

02:45:01,515 --> 02:45:03,049
I know you guys are looking at this

02:45:03,049 --> 02:45:04,600
from the perspective of an out of tree kernel patch

02:45:04,600 --> 02:45:05,770
you've already written

02:45:05,770 --> 02:45:07,820
that does this other way,

02:45:07,820 --> 02:45:11,600
and it's created a lot of work and complexity in the kernel.

02:45:11,600 --> 02:45:13,460
I don't really like the complexity

02:45:13,460 --> 02:45:14,790
that's developing around the way

02:45:14,790 --> 02:45:16,390
uobjects are reference counted.

02:45:16,390 --> 02:45:18,240
That's starting to go into ugly town,

02:45:19,470 --> 02:45:20,370
but I think,

02:45:22,367 --> 02:45:23,633
I haven't thought about it a lot

02:45:23,633 --> 02:45:24,466
because I only learned about it yesterday,

02:45:24,466 --> 02:45:26,170
but I think we might be able to add

02:45:26,170 --> 02:45:28,800
this reference counting concept

02:45:28,800 --> 02:45:31,170
as an additional layer on the existing uobjects

02:45:31,170 --> 02:45:33,550
in a way that doesn't break everything.

02:45:33,550 --> 02:45:35,400
- [Man] And that sounds like a good idea to me,

02:45:35,400 --> 02:45:36,650
intuitively, but I'm not,

02:45:38,478 --> 02:45:39,500
but of course, I'd need to look at that more.

02:45:39,500 --> 02:45:40,710
- [Jason] If we keep going down that line,

02:45:40,710 --> 02:45:42,690
then the semantic that I keep asking about,

02:45:42,690 --> 02:45:45,320
I even asked this for Shamir's patch

02:45:45,320 --> 02:45:46,350
is in RDMA core,

02:45:46,350 --> 02:45:48,830
I want this concept of import from the kernel,

02:45:49,980 --> 02:45:52,660
import from the kernel the user space information I need.

02:45:52,660 --> 02:45:54,100
So, tell me what the L key is,

02:45:54,100 --> 02:45:56,190
tell me how to reconstruct the IBVPD,

02:45:56,190 --> 02:45:58,160
tell me how to reconstruct the IBVMR

02:45:58,160 --> 02:46:00,070
in my local process,

02:46:00,070 --> 02:46:02,850
and that would be a reasonable place to put the ref count,

02:46:02,850 --> 02:46:05,438
and that would be a reasonable place to put a mirror

02:46:05,438 --> 02:46:07,710
that's the decrement that ref count.

02:46:09,850 --> 02:46:11,190
It's weird.

02:46:11,190 --> 02:46:12,360
It's really, really weird,

02:46:12,360 --> 02:46:14,890
but maybe we could make it work.

02:46:14,890 --> 02:46:15,840
I'm not sure.

02:46:15,840 --> 02:46:17,370
- Yeah, so just a few points.

02:46:17,370 --> 02:46:18,480
So from security,

02:46:18,480 --> 02:46:19,650
one of the things we discusses

02:46:19,650 --> 02:46:22,760
was that once it passed the FD,

02:46:22,760 --> 02:46:25,210
that second process can access my resources

02:46:25,210 --> 02:46:26,870
and destroy them.

02:46:26,870 --> 02:46:29,330
So, I sort of gave up on security

02:46:29,330 --> 02:46:31,680
the moment I gave the FD to the other process,

02:46:31,680 --> 02:46:33,850
even if it wanted to import the PD

02:46:33,850 --> 02:46:37,140
to its own context, a ucontext,

02:46:37,140 --> 02:46:39,870
and then the PD

02:46:39,870 --> 02:46:41,830
and the MR are pretty much stateless,

02:46:41,830 --> 02:46:45,160
so it's pretty simple to expose them.

02:46:45,160 --> 02:46:48,220
Obviously, sharing the QPCQ data path,

02:46:48,220 --> 02:46:50,870
it's different story altogether.

02:46:50,870 --> 02:46:51,840
It's not your topic,

02:46:51,840 --> 02:46:54,260
but I'm just looking the broader sense,

02:46:54,260 --> 02:46:56,270
and even the context itself

02:46:57,240 --> 02:46:58,250
as a vendor provider,

02:46:58,250 --> 02:46:59,950
we have on the MLX context,

02:46:59,950 --> 02:47:02,240
some stateful objects

02:47:02,240 --> 02:47:03,350
that we'll have to solve,

02:47:03,350 --> 02:47:04,660
because the moment you gave the FD

02:47:04,660 --> 02:47:06,500
you want to probably reconstruct

02:47:06,500 --> 02:47:08,710
the user space IBV context

02:47:08,710 --> 02:47:12,560
and it has some stateful meaning in it.

02:47:12,560 --> 02:47:14,640
- [Yuval] Like private articles, yeah.

02:47:14,640 --> 02:47:15,860
- Yeah, driver-specific stuff

02:47:15,860 --> 02:47:17,320
that we'll have to probably deal

02:47:17,320 --> 02:47:18,153
and see how we do,

02:47:18,153 --> 02:47:20,470
and every vendor will probably have to solve

02:47:20,470 --> 02:47:22,830
its context issues

02:47:22,830 --> 02:47:24,680
because the PDMR are the simple part

02:47:24,680 --> 02:47:26,080
at the end of the day. - That's more constraint

02:47:26,080 --> 02:47:27,320
because we can now say,

02:47:27,320 --> 02:47:29,650
"well, the provider driver

02:47:29,650 --> 02:47:30,970
"has to provide an import,

02:47:30,970 --> 02:47:33,200
"and the kernel side has to provide

02:47:33,200 --> 02:47:35,660
"a data dump that can allow the import,"

02:47:35,660 --> 02:47:37,160
and if you have state in your objects,

02:47:37,160 --> 02:47:40,210
then you probably have to add kernel APIs

02:47:40,210 --> 02:47:41,840
to move that state into the kernel, basically,

02:47:41,840 --> 02:47:45,280
'cause that's the only way we could share it.

02:47:45,280 --> 02:47:47,670
None of this sounds insurmountable to me,

02:47:47,670 --> 02:47:49,470
and it seems to make the mess less,

02:47:50,340 --> 02:47:53,430
'cause we're making the mess a lot less

02:47:54,280 --> 02:47:57,260
than trying to create these weird shared object things.

02:47:57,260 --> 02:47:58,900
The weird shared object things

02:47:58,900 --> 02:48:01,160
creates a lot of problems

02:48:01,160 --> 02:48:03,150
for the way we destroy the world.

02:48:03,150 --> 02:48:05,130
When you try and destroy a PD,

02:48:05,130 --> 02:48:07,590
but you can't because an MR

02:48:07,590 --> 02:48:10,028
and some other FD is holding it open,

02:48:10,028 --> 02:48:12,460
yeah, that's a problem.

02:48:14,670 --> 02:48:16,260
It means we have to constrain the user space

02:48:16,260 --> 02:48:18,430
so that it can't import an MR

02:48:18,430 --> 02:48:20,490
unless it's already imported to the PD,

02:48:20,490 --> 02:48:22,270
which is starting to get really complicated

02:48:22,270 --> 02:48:24,420
because we don't actually have a formal way

02:48:24,420 --> 02:48:27,068
to traverse this graph of dependencies

02:48:27,068 --> 02:48:28,420
in our uobject system.

02:48:28,420 --> 02:48:30,290
The assumption is that all the uobjects

02:48:30,290 --> 02:48:32,400
in the dependency graph are inside a single IDR,

02:48:32,400 --> 02:48:34,510
and if we destroy that IDR and all the uobjects

02:48:34,510 --> 02:48:35,950
in a multi-pass thing,

02:48:35,950 --> 02:48:37,970
then everything will just get deleted.

02:48:37,970 --> 02:48:40,135
We can't rely on that assumption.

02:48:40,135 --> 02:48:40,968
Ah!

02:48:42,312 --> 02:48:43,520
It's become a big mess,

02:48:43,520 --> 02:48:44,830
and you guys haven't even started

02:48:44,830 --> 02:48:46,040
to think of how to deal with that

02:48:46,040 --> 02:48:47,140
in the patches I saw.

02:48:48,550 --> 02:48:49,520
They were sort of like, "well,

02:48:49,520 --> 02:48:50,770
"if everybody does this."

02:48:52,010 --> 02:48:53,730
I hope you can say you can tolerate this model

02:48:53,730 --> 02:48:56,330
because I think we can implement that fairly easily.

02:48:57,170 --> 02:48:59,680
The ucontext is the worst of the lot.

02:48:59,680 --> 02:49:01,300
That's hard.

02:49:01,300 --> 02:49:02,900
That needs a little thinking,

02:49:02,900 --> 02:49:04,060
but on the flip side

02:49:04,996 --> 02:49:06,460
is if you have millions of processes,

02:49:06,460 --> 02:49:08,310
which is what you said,

02:49:08,310 --> 02:49:10,560
then sharing the ucontext is also gonna help you

02:49:10,560 --> 02:49:11,820
reduce resource usage

02:49:11,820 --> 02:49:14,722
because there is a resource affiliated with the ucontext.

02:49:14,722 --> 02:49:15,555
- Yeah.

02:49:17,463 --> 02:49:18,370
- So, you might end up winning.

02:49:18,370 --> 02:49:19,679
I don't know.

02:49:19,679 --> 02:49:20,580
- Yeah.

02:49:20,580 --> 02:49:21,413
Again.

02:49:23,992 --> 02:49:26,690
- So, if you share the context

02:49:26,690 --> 02:49:29,910
and you have access to all the memory regions

02:49:29,910 --> 02:49:31,380
in the context,

02:49:31,380 --> 02:49:33,680
do I have to take a reference on it to use it.

02:49:35,270 --> 02:49:36,170
- [Yuval] Why not?

02:49:38,844 --> 02:49:39,863
- [Jason] No.

02:49:39,863 --> 02:49:40,861
Technically, no.

02:49:40,861 --> 02:49:41,883
You don't need to have a reference.

02:49:41,883 --> 02:49:42,716
- Okay, now I understand what you're talking about.

02:49:42,716 --> 02:49:43,560
- [Jason] The struct file is giving you

02:49:43,560 --> 02:49:45,482
all the reference you need,

02:49:45,482 --> 02:49:46,390
but if you wanna coordinate

02:49:46,390 --> 02:49:48,890
a timely destruction between multiple processes.

02:49:48,890 --> 02:49:50,330
- Then you would wanna take the reference

02:49:50,330 --> 02:49:52,540
and then you can drop it when you're done.

02:49:52,540 --> 02:49:54,664
- [Jason] Somebody needs to provide a reference.

02:49:54,664 --> 02:49:55,664
- Fair enough.

02:49:55,664 --> 02:49:57,890
Now, I understand your model.

02:49:57,890 --> 02:50:00,156
- But what about the reference

02:50:00,156 --> 02:50:01,155
of the model itself,

02:50:01,155 --> 02:50:02,570
like the second process can kill your MR.

02:50:03,580 --> 02:50:04,413
- Don't do that.

02:50:05,415 --> 02:50:06,415
(laughing)

02:50:06,415 --> 02:50:07,816
- [Yuval] Okay, you can't control.

02:50:07,816 --> 02:50:09,416
The process just died. - Don't share it.

02:50:09,416 --> 02:50:12,260
- But the process just died

02:50:12,260 --> 02:50:15,680
and all these resources are dying with them.

02:50:15,680 --> 02:50:17,250
So, the MR will be dying, right?

02:50:17,250 --> 02:50:18,920
- No, no, no, no.

02:50:18,920 --> 02:50:20,570
We're in a file descriptor model.

02:50:21,762 --> 02:50:24,600
The death of a process does not close the file descriptor.

02:50:24,600 --> 02:50:27,670
Now, he might orphan all of his stuff when he dies,

02:50:27,670 --> 02:50:29,910
and that might be a really legitimate reason

02:50:29,910 --> 02:50:31,810
why you don't want this kind of model.

02:50:32,974 --> 02:50:34,080
(chattering)

02:50:34,080 --> 02:50:35,480
- [Yuval] So now, you have to stand to the side

02:50:35,480 --> 02:50:37,340
and draw your face to the camera,

02:50:37,340 --> 02:50:39,371
and your pen to the wall.

02:50:39,371 --> 02:50:40,204
(laughing)

02:50:40,204 --> 02:50:41,390
- [Yuval] Do you need laptop?

02:50:41,390 --> 02:50:42,920
Oh, I see it here. - Oh, on the.

02:50:45,050 --> 02:50:47,260
I think that's probably what does sink it,

02:50:47,260 --> 02:50:49,230
'cause I think the model that Oracle has

02:50:49,230 --> 02:50:52,060
is these independent processes are largely independent,

02:50:52,060 --> 02:50:53,950
and they're gonna create a whole bunch of QPs

02:50:53,950 --> 02:50:54,840
and other stuff for their own uses,

02:50:54,840 --> 02:50:55,740
and if they crash,

02:50:56,810 --> 02:50:58,070
all the stuff that hasn't been shared,

02:50:58,070 --> 02:51:00,240
doesn't need to be cleaned up.

02:51:00,240 --> 02:51:01,442
Yes?

02:51:01,442 --> 02:51:02,380
(speech muffled)

02:51:02,380 --> 02:51:03,213
I think so.

02:51:03,213 --> 02:51:05,700
So, you do actually need the separation.

02:51:05,700 --> 02:51:07,200
- Yeah, just for resource cleaning,

02:51:07,200 --> 02:51:08,400
if something crashes.

02:51:08,400 --> 02:51:09,877
- Yes.

02:51:09,877 --> 02:51:11,910
- You don't wanna close all the processes

02:51:11,910 --> 02:51:13,370
to do proper cleanup.

02:51:13,370 --> 02:51:14,270
- Yeah.

02:51:14,270 --> 02:51:17,021
You just wanna keep the shared resources

02:51:17,021 --> 02:51:18,890
nebulously floating out there.

02:51:20,041 --> 02:51:23,500
- So, any way, they're going to need to context.

02:51:23,500 --> 02:51:24,600
One is the shared one

02:51:24,600 --> 02:51:26,290
and one, the private one. - You can't.

02:51:26,290 --> 02:51:27,520
It's useless.

02:51:27,520 --> 02:51:29,630
You can't references the MR that you shared

02:51:29,630 --> 02:51:31,520
unless you create a QP inside the PD,

02:51:31,520 --> 02:51:34,110
and you can't do that with another context.

02:51:36,460 --> 02:51:37,293
It's useless.

02:51:37,293 --> 02:51:40,080
So, you do really want the weird FD passing thing

02:51:40,080 --> 02:51:42,310
that you were about to explain in your slides.

02:51:43,418 --> 02:51:44,310
- I'm sorry.

02:51:44,310 --> 02:51:45,914
- [Jason] Which is.

02:51:45,914 --> 02:51:48,210
- Just for the resource. - For the clean up.

02:51:49,434 --> 02:51:50,640
For clean up.

02:51:50,640 --> 02:51:53,420
'Cause their model is if they lose one process, that's okay.

02:51:53,420 --> 02:51:54,890
They start it up again.

02:51:54,890 --> 02:51:55,810
The model you're talking about,

02:51:55,810 --> 02:51:58,280
you lose a process, you kill everybody,

02:51:58,280 --> 02:52:00,470
you clean up the mess.

02:52:00,470 --> 02:52:02,280
- Only when all the process dies,

02:52:02,280 --> 02:52:03,820
the file object destroyed

02:52:03,820 --> 02:52:05,010
and then everything's cleaned up,

02:52:05,010 --> 02:52:07,450
but if one process dies,

02:52:07,450 --> 02:52:09,560
the QPs, and whatever it created

02:52:09,560 --> 02:52:10,840
are orphans, as you said.

02:52:10,840 --> 02:52:12,284
They hang there.

02:52:12,284 --> 02:52:13,190
Nobody knows about them,

02:52:13,190 --> 02:52:14,290
nobody can clean them up.

02:52:14,290 --> 02:52:15,300
- [Jason] In his use model,

02:52:15,300 --> 02:52:16,590
that would be a memory leak,

02:52:16,590 --> 02:52:19,420
in a SHMEM use model,

02:52:19,420 --> 02:52:21,362
if you lose a process,

02:52:21,362 --> 02:52:22,540
you expect that everybody's gonna get killed

02:52:22,540 --> 02:52:24,263
and cleaned up anyway

02:52:24,263 --> 02:52:25,660
because that's how SHMEM works.

02:52:25,660 --> 02:52:26,500
- Yeah.

02:52:26,500 --> 02:52:27,333
- [Jason] So, it makes sense.

02:52:27,333 --> 02:52:28,600
You don't have a resource leak

02:52:28,600 --> 02:52:31,390
because you're not gonna respond that process.

02:52:31,390 --> 02:52:32,223
It's just gone.

02:52:33,280 --> 02:52:34,840
Okay, that's very sad.

02:52:36,767 --> 02:52:38,200
(laughing)

02:52:38,200 --> 02:52:39,850
We have to do the messy FD thing.

02:52:40,900 --> 02:52:43,370
You should go through the rest of your slides.

02:52:43,370 --> 02:52:44,350
- [Yuval] I think I'm done

02:52:44,350 --> 02:52:46,820
because this is the discussion

02:52:46,820 --> 02:52:47,970
that I wanted to raise.

02:52:49,756 --> 02:52:51,141
- Yeah, plus we're running out of time.

02:52:51,141 --> 02:52:52,358
- [Jason] Oh, we're out of time.

02:52:52,358 --> 02:52:54,010
- [Yuval] It's lunch time.

02:52:54,010 --> 02:52:56,210
So, you wanna hear me or to eat?

02:52:56,210 --> 02:52:58,570
- I'd like to see the slides.

02:52:58,570 --> 02:52:59,900
- Basically, the next slides

02:52:59,900 --> 02:53:01,550
are just describing the API,

02:53:02,648 --> 02:53:06,040
the implementation itself is on the list anyway.

02:53:10,220 --> 02:53:12,140
Next slide are not going deeply

02:53:12,140 --> 02:53:14,440
into the details of the implementation,

02:53:14,440 --> 02:53:16,240
just st the API and the usage.

02:53:24,460 --> 02:53:25,293
Yeah.

02:53:28,330 --> 02:53:29,163
- We talked for so long,

02:53:29,163 --> 02:53:32,230
my laptop went to sleep.

02:53:32,230 --> 02:53:33,710
- Okay, so here is the API.

02:53:35,930 --> 02:53:37,220
Again, like we said,

02:53:38,102 --> 02:53:41,420
the important process

02:53:41,420 --> 02:53:43,840
has its own context,

02:53:43,840 --> 02:53:46,680
and then using the FD,

02:53:46,680 --> 02:53:48,980
he'd like to import

02:53:48,980 --> 02:53:50,980
a specific PD

02:53:50,980 --> 02:53:52,780
from this context.

02:53:52,780 --> 02:53:54,360
So, the API looks like this.

02:53:54,360 --> 02:53:57,140
The first argument is the context

02:53:57,140 --> 02:53:58,630
of the process that's created

02:53:58,630 --> 02:53:59,560
by the process.

02:54:00,560 --> 02:54:02,410
Second argument is the FD

02:54:02,410 --> 02:54:05,836
that was passed by the SCM write socket.

02:54:05,836 --> 02:54:07,050
- [Man] This doesn't happen when the IFD is shared.

02:54:08,043 --> 02:54:09,643
When you share the FD with another process,

02:54:09,643 --> 02:54:10,907
why don't you give it full access?

02:54:10,907 --> 02:54:12,470
- [Jason] Well, this is the discussion.

02:54:12,470 --> 02:54:13,720
You don't wanna share the whole FD

02:54:13,720 --> 02:54:16,320
because you can't control the resource cleanup properly.

02:54:16,320 --> 02:54:17,820
- [Man] So, you miss.

02:54:17,820 --> 02:54:20,380
- [Jason] So, they wanna share objects,

02:54:20,380 --> 02:54:21,213
which is weird.

02:54:23,353 --> 02:54:24,660
It is, yeah.

02:54:24,660 --> 02:54:26,380
- So with this modality,

02:54:26,380 --> 02:54:29,183
importing process can have its own resources

02:54:29,183 --> 02:54:32,900
independent from the other context.

02:54:32,900 --> 02:54:35,490
- But the FD that we provide here

02:54:35,490 --> 02:54:37,230
is not the original FD,

02:54:37,230 --> 02:54:39,391
it's like a middle FD. - No, it's a middle FD.

02:54:39,391 --> 02:54:40,680
- Okay.

02:54:40,680 --> 02:54:41,738
- Yeah.

02:54:41,738 --> 02:54:43,230
- What do you mean middle FD?

02:54:43,230 --> 02:54:44,063
- What do I mean?

02:54:44,063 --> 02:54:44,896
It's the FD

02:54:46,126 --> 02:54:47,160
the original process creates.

02:54:47,160 --> 02:54:50,010
- There's lots of ways to use an API like this.

02:54:50,010 --> 02:54:53,400
This simply lets you copy a uobject

02:54:53,400 --> 02:54:55,010
from one FD to another.

02:54:55,010 --> 02:54:57,470
So, you can build all sorts of weird things about that,

02:54:57,470 --> 02:54:59,580
you can share the parent one, the global one,

02:54:59,580 --> 02:55:00,520
you can share it to everybody,

02:55:00,520 --> 02:55:01,770
and you can just copy

02:55:01,770 --> 02:55:03,990
and then resource cleanup will work correctly.

02:55:03,990 --> 02:55:05,450
You could make it.

02:55:05,450 --> 02:55:06,880
I don't know.

02:55:06,880 --> 02:55:07,713
You could create a third FD

02:55:07,713 --> 02:55:09,170
and pass the third FD,

02:55:09,170 --> 02:55:10,560
and then it just has what's supposed to be passed.

02:55:10,560 --> 02:55:12,340
I have no idea.

02:55:12,340 --> 02:55:13,700
You probably don't want a third FD.

02:55:13,700 --> 02:55:14,930
That's too complicated. - Well, the third FD

02:55:14,930 --> 02:55:17,010
helps so the receiving process

02:55:17,010 --> 02:55:19,220
will not be able to access all the resources

02:55:19,220 --> 02:55:20,469
of the parent,

02:55:20,469 --> 02:55:21,302
just the limited ones.

02:55:21,302 --> 02:55:22,580
- If that was your security model,

02:55:22,580 --> 02:55:23,480
but I think we've established

02:55:23,480 --> 02:55:24,490
we don't have that security model.

02:55:24,490 --> 02:55:26,145
- Yeah, that was, by the way,

02:55:26,145 --> 02:55:26,978
its first approach,

02:55:26,978 --> 02:55:28,870
to create a new FD

02:55:28,870 --> 02:55:31,390
just to export the object that you like.

02:55:33,600 --> 02:55:35,490
So, here is the same one.

02:55:35,490 --> 02:55:36,340
We have only two.

02:55:37,628 --> 02:55:39,170
One that holds the objects to share,

02:55:39,170 --> 02:55:41,780
and one of the process itself,

02:55:41,780 --> 02:55:43,126
and that's it.

02:55:43,126 --> 02:55:44,316
That's the API.

02:55:44,316 --> 02:55:46,420
The import MR looks more or less the same.

02:55:46,420 --> 02:55:49,660
So, idea here is that you import the MR

02:55:49,660 --> 02:55:52,090
and then you use the same API to destroy it,

02:55:52,090 --> 02:55:54,710
and then the objects keep reference counting,

02:55:54,710 --> 02:55:56,280
so we are safe.

02:55:56,280 --> 02:55:59,120
Second process can die, or kill it explicitly.

02:56:02,718 --> 02:56:04,170
The IB object is still alive.

02:56:08,530 --> 02:56:09,363
- So, like I said,

02:56:09,363 --> 02:56:10,500
it's a big, complicated mess

02:56:10,500 --> 02:56:12,080
to put the ref counting into the thing

02:56:12,080 --> 02:56:14,910
that was never meant to ref count like this.

02:56:14,910 --> 02:56:17,030
- Still, semantics is that both processes

02:56:17,030 --> 02:56:18,590
have full control of the object

02:56:18,590 --> 02:56:19,982
which they are sharing,

02:56:19,982 --> 02:56:21,210
'cause that's not under the case here.

02:56:21,210 --> 02:56:22,270
- No, they still have full control

02:56:22,270 --> 02:56:23,570
of the object they're sharing.

02:56:23,570 --> 02:56:25,390
- You can't import the stuff and activate it.

02:56:25,390 --> 02:56:27,460
- Yeah, once you import it.

02:56:27,460 --> 02:56:29,010
- What I mean full control?

02:56:29,010 --> 02:56:30,170
They cannot dispose

02:56:31,479 --> 02:56:32,312
the object itself,

02:56:32,312 --> 02:56:35,100
just the user object, the uobject.

02:56:35,100 --> 02:56:37,370
- They can truncate file, for example.

02:56:37,370 --> 02:56:41,650
If the file is shared, it can truncate it.

02:56:41,650 --> 02:56:42,850
- Oh, okay, okay. - Yeah.

02:56:42,850 --> 02:56:44,054
- But that's fine.

02:56:44,054 --> 02:56:44,887
Yeah.

02:56:46,090 --> 02:56:47,420
That's what we talked.

02:56:47,420 --> 02:56:48,860
If you want to share the amount,

02:56:48,860 --> 02:56:51,143
the memo itself should be anyway be shared.

02:56:51,143 --> 02:56:52,860
So, that's fine.

02:56:52,860 --> 02:56:53,900
They're trusted.

02:56:53,900 --> 02:56:55,440
That's what I meant.

02:56:55,440 --> 02:56:57,300
There is no security issue.

02:56:57,300 --> 02:56:59,440
We just want to keep the system safe,

02:56:59,440 --> 02:57:03,340
so one process cannot kill other process resource.

02:57:04,820 --> 02:57:07,370
- So, maybe ask a question for Jason.

02:57:07,370 --> 02:57:09,750
So here, when we import the MR,

02:57:09,750 --> 02:57:13,430
we want to some way provide the PD

02:57:13,430 --> 02:57:16,270
to prove that we are allowed to import the MR,

02:57:16,270 --> 02:57:17,750
because it's part of the tree.

02:57:17,750 --> 02:57:19,450
- Yeah, that's where it gets all messy.

02:57:19,450 --> 02:57:21,700
Somebody has to prove that.

02:57:21,700 --> 02:57:23,820
I don't know if that should be done

02:57:23,820 --> 02:57:28,650
implicitly or explicitly or what,

02:57:28,650 --> 02:57:30,050
but somebody has to prove

02:57:30,050 --> 02:57:32,520
that the PD can still be referenced.

02:57:32,520 --> 02:57:34,270
The entire graph can be referenced.

02:57:35,210 --> 02:57:37,540
- Are you meaning if you're using only the import PD,

02:57:37,540 --> 02:57:38,510
but you didn't even.

02:57:38,510 --> 02:57:40,650
- No, I just called import MR,

02:57:40,650 --> 02:57:42,197
I have the FD,

02:57:42,197 --> 02:57:43,460
I have the handle to the MR,

02:57:43,460 --> 02:57:45,180
but I left the PD behind.

02:57:45,180 --> 02:57:46,960
I didn't even import it.

02:57:46,960 --> 02:57:49,490
So, somebody has to check that I imported the PDs

02:57:49,490 --> 02:57:51,040
in order to allow me to import.

02:57:51,926 --> 02:57:52,925
You have to check it.

02:57:52,925 --> 02:57:53,758
- Who is you?

02:57:53,758 --> 02:57:54,591
- [Man] What do you mean?

02:57:54,591 --> 02:57:55,926
I. - The kernel

02:57:55,926 --> 02:57:58,330
has to make sure that when you import an MR.

02:57:58,330 --> 02:58:00,070
- That's not enough.

02:58:00,070 --> 02:58:02,410
You have to prevent it from being removed

02:58:02,410 --> 02:58:03,243
from the IDR

02:58:03,243 --> 02:58:05,180
until all of its children

02:58:05,180 --> 02:58:06,840
in the dependency graph are removed.

02:58:06,840 --> 02:58:08,600
So, you can't have the semantic

02:58:08,600 --> 02:58:09,600
where you can,

02:58:10,590 --> 02:58:12,730
you can't take something out of the local IDR.

02:58:12,730 --> 02:58:13,850
You just can't.

02:58:13,850 --> 02:58:15,630
- So, it's like a graph

02:58:15,630 --> 02:58:17,980
and we want to import part of the graph,

02:58:17,980 --> 02:58:20,380
part of the tree into my process.

02:58:20,380 --> 02:58:22,811
I can try and cherry pick.

02:58:22,811 --> 02:58:25,380
If I try and take a QP,

02:58:25,380 --> 02:58:27,570
I'm not talking to the data path and state stuff,

02:58:27,570 --> 02:58:29,320
QP is pointing to a CQ

02:58:29,320 --> 02:58:30,820
where, do I take the CQ first?

02:58:33,062 --> 02:58:35,100
- So Jason, why cannot manage to IDR

02:58:36,262 --> 02:58:38,390
when it's shared IDR

02:58:38,390 --> 02:58:41,399
or a non-shared. - I don't think it helps.

02:58:41,399 --> 02:58:42,967
- Remember, use the microphone.

02:58:42,967 --> 02:58:43,971
Stand up to the camera.

02:58:43,971 --> 02:58:46,808
(laughing)

02:58:46,808 --> 02:58:48,300
- [Jason] That's not the problem.

02:58:48,300 --> 02:58:49,690
It's not the IRD that's the problem,

02:58:49,690 --> 02:58:53,080
it's the lifetime of the discounted cloned uobject.

02:58:53,080 --> 02:58:55,740
- Once you are using two IDRs,

02:58:55,740 --> 02:58:59,430
you can actually manage lifetime of this object,

02:58:59,430 --> 02:59:00,950
'cause you already separated,

02:59:00,950 --> 02:59:02,370
or shared object

02:59:02,370 --> 02:59:04,220
and not shared object. - We cannot have two IDRs

02:59:04,220 --> 02:59:06,300
because we only have one number space,

02:59:06,300 --> 02:59:09,034
so that's impossible.

02:59:09,034 --> 02:59:11,430
(speech muffled)

02:59:11,430 --> 02:59:13,140
It's a lifetime problem.

02:59:13,140 --> 02:59:14,230
It's worse than I thought

02:59:14,230 --> 02:59:16,000
when we first discussed this.

02:59:16,000 --> 02:59:17,730
It's a lot worse than I thought.

02:59:17,730 --> 02:59:19,040
- So, can we get back

02:59:19,040 --> 02:59:22,170
to if your application

02:59:22,170 --> 02:59:23,820
can just share the context

02:59:23,820 --> 02:59:26,170
by sharing the file descriptor,

02:59:26,170 --> 02:59:27,930
would that solve these problems?

02:59:27,930 --> 02:59:29,700
- [Jason] We just determined it can't.

02:59:29,700 --> 02:59:31,022
- Why?

02:59:31,022 --> 02:59:32,554
- It solves the import problem,

02:59:32,554 --> 02:59:34,075
but we're stuck with the

02:59:34,075 --> 02:59:35,390
- [Jason] We're stuck with a cleanup problem now.

02:59:35,390 --> 02:59:38,350
- Well, but, I still think

02:59:38,350 --> 02:59:40,930
the cleanup problem could be an application problem

02:59:40,930 --> 02:59:43,300
and we could maybe provide some additional things

02:59:43,300 --> 02:59:44,980
that would be nice to use,

02:59:44,980 --> 02:59:46,330
but if they don't use them,

02:59:49,661 --> 02:59:50,494
then they crash,

02:59:51,455 --> 02:59:52,288
'cause somebody destroyed

02:59:52,288 --> 02:59:53,650
their memory region underneath them.

02:59:53,650 --> 02:59:54,483
- [Jason] I don't know

02:59:54,483 --> 02:59:56,400
if we can make it an application problem.

02:59:58,175 --> 03:00:00,320
- [Yuval] What is the tree node problem?

03:00:00,320 --> 03:00:03,530
- So, if I shared in the model we discussed previous,

03:00:03,530 --> 03:00:04,780
I shared the FD,

03:00:04,780 --> 03:00:07,390
both processes have access to the same ucontext.

03:00:08,400 --> 03:00:10,890
So basically, I have a single,

03:00:10,890 --> 03:00:14,020
or maybe a reference count PD in the kernel

03:00:14,020 --> 03:00:15,620
and both processes have it.

03:00:15,620 --> 03:00:17,970
Now, one process died,

03:00:17,970 --> 03:00:19,910
so the reference on the FD is down,

03:00:19,910 --> 03:00:22,360
but the reference of the PD is not down.

03:00:22,360 --> 03:00:24,180
Maybe that process

03:00:24,180 --> 03:00:26,510
also created a QP on that PD,

03:00:26,510 --> 03:00:28,330
so nobody's gonna clean up the QP

03:00:28,330 --> 03:00:30,050
because the FD's still alive.

03:00:30,050 --> 03:00:31,860
- But the QP should be associated

03:00:31,860 --> 03:00:34,440
with the common PD, right?

03:00:34,440 --> 03:00:36,050
- Well, that's - But the PD.

03:00:36,050 --> 03:00:37,270
- [Jason] The associated with the common PD,

03:00:37,270 --> 03:00:39,700
but logically, it's associated with that process.

03:00:39,700 --> 03:00:40,533
- Yeah.

03:00:40,533 --> 03:00:42,250
So now, you have 3000

03:00:42,250 --> 03:00:44,740
or 30,000 processes that created a PD.

03:00:44,740 --> 03:00:46,270
They all died beside the parents

03:00:46,270 --> 03:00:49,160
and you have 30,000 QP ghosts,

03:00:49,160 --> 03:00:50,780
CQ's living there,

03:00:50,780 --> 03:00:53,294
a PD with a reference is not a big deal.

03:00:53,294 --> 03:00:54,127
- But those would all be - There needs to be

03:00:54,127 --> 03:00:56,240
a dependency of the FD on all the local objects.

03:00:56,240 --> 03:00:57,830
Maybe it would track them.

03:00:57,830 --> 03:00:59,259
There's no other way,

03:00:59,259 --> 03:01:00,240
otherwise you can't clean up.

03:01:00,240 --> 03:01:02,880
- So, once the FD on all the processes get closed,

03:01:02,880 --> 03:01:03,980
those would get cleaned up.

03:01:03,980 --> 03:01:05,820
It's not permanently. - That's not their model.

03:01:05,820 --> 03:01:07,960
- So, the SHMEM model,

03:01:07,960 --> 03:01:09,020
in the SHMEM model,

03:01:09,020 --> 03:01:10,260
if something goes wrong,

03:01:10,260 --> 03:01:12,820
you just restart the entire cluster, basically, I guess,

03:01:12,820 --> 03:01:13,900
not just the machine.

03:01:13,900 --> 03:01:15,600
In their model, if one process dies,

03:01:15,600 --> 03:01:18,700
they wanna just reincarnate it and continue

03:01:18,700 --> 03:01:20,670
and let the rest of the system continue.

03:01:20,670 --> 03:01:23,640
- And it's imperative that you have PDs for every process.

03:01:23,640 --> 03:01:24,480
- Yes, sir.

03:01:24,480 --> 03:01:26,550
- [Jason] No, a global PD is what they want.

03:01:26,550 --> 03:01:27,970
- Right, so see, that would be okay.

03:01:27,970 --> 03:01:30,530
- I think the purpose is really the MRs,

03:01:30,530 --> 03:01:32,040
not the PDs by themselves,

03:01:32,040 --> 03:01:34,405
you just have to need the PD

03:01:34,405 --> 03:01:35,550
to get access to the MR.

03:01:35,550 --> 03:01:38,131
- [Jason] Yeah, but you need the PD

03:01:38,131 --> 03:01:38,964
to get access to the MRs.

03:01:38,964 --> 03:01:40,723
You can't create a QP without a PD

03:01:40,723 --> 03:01:41,556
and you need to create your QP

03:01:41,556 --> 03:01:42,390
on the correct PD.

03:01:42,390 --> 03:01:44,778
- So, it's about sharing MRs, really,

03:01:44,778 --> 03:01:47,850
but the shared PD kinda comes

03:01:47,850 --> 03:01:48,930
with the flow. - It's inevitable.

03:01:48,930 --> 03:01:50,110
It's inevitable.

03:01:50,110 --> 03:01:52,170
So, I don't know.

03:01:52,170 --> 03:01:53,220
You need a way to

03:01:53,220 --> 03:01:55,780
- And that's because there's too few MRs available.

03:01:57,420 --> 03:02:00,360
- [Jason] So, I'm having another idea

03:02:00,360 --> 03:02:01,460
that's a little worse.

03:02:03,530 --> 03:02:04,534
- What is worse?

03:02:04,534 --> 03:02:05,600
The import or the cleanup?

03:02:05,600 --> 03:02:06,700
- [Jason] The cleanup.

03:02:07,581 --> 03:02:09,080
So, if we accept that the import is too hard

03:02:09,080 --> 03:02:11,440
because of the graph problems and so forth,

03:02:11,440 --> 03:02:13,470
we really, really have problems.

03:02:14,761 --> 03:02:15,850
We have more than one uobject.

03:02:16,860 --> 03:02:19,880
If we could manage this ref count thing

03:02:20,770 --> 03:02:23,120
with another file descriptor, maybe,

03:02:23,120 --> 03:02:24,960
then when the file descriptor could be isolated

03:02:24,960 --> 03:02:25,890
to the process

03:02:26,871 --> 03:02:28,280
and it could be cleaned up,

03:02:28,280 --> 03:02:29,760
we could trigger a kernel cleanup

03:02:29,760 --> 03:02:30,720
of the segments.

03:02:32,536 --> 03:02:34,800
It's like a weird, weird way to do it.

03:02:36,937 --> 03:02:37,770
- It's not impossible.

03:02:37,770 --> 03:02:39,580
- [Jason] But it's sort of a model.

03:02:39,580 --> 03:02:41,070
It's sort of a model where you create

03:02:41,070 --> 03:02:43,490
a new ufile

03:02:43,490 --> 03:02:46,840
that likes a strict subset

03:02:46,840 --> 03:02:50,310
of somebody else's ucontext.

03:02:51,588 --> 03:02:53,249
It's kinda weird,

03:02:53,249 --> 03:02:55,410
or maybe a good, I don't know.

03:02:55,410 --> 03:02:57,033
- But in some way,

03:02:57,033 --> 03:02:57,940
you already have this sharing

03:02:57,940 --> 03:03:00,340
if you have a common process with multiple threads, right?

03:03:00,340 --> 03:03:01,173
- [Jason] Yeah, yeah.

03:03:01,173 --> 03:03:03,120
- You can do something with its own flags.

03:03:03,120 --> 03:03:05,120
- [Jason] The sharing isn't the problem.

03:03:05,120 --> 03:03:07,620
It's either getting them to be there,

03:03:07,620 --> 03:03:08,690
which we can do with shared FD,

03:03:08,690 --> 03:03:10,120
or it's cleaning them up

03:03:10,120 --> 03:03:13,350
when the objects that are not shared go away.

03:03:13,350 --> 03:03:15,140
- In the thread model,

03:03:15,140 --> 03:03:16,200
the cleanup works, right?

03:03:16,200 --> 03:03:18,170
- [Jason] In the thread model,

03:03:18,170 --> 03:03:19,200
the application has to do it.

03:03:19,200 --> 03:03:21,810
If one of your threads malfunctions and exits,

03:03:21,810 --> 03:03:23,770
then the application is responsible

03:03:23,770 --> 03:03:25,180
for cleaning up any resources.

03:03:25,180 --> 03:03:26,190
- If I kill the process,

03:03:26,190 --> 03:03:27,620
it will be cleaned up, right?

03:03:27,620 --> 03:03:28,453
- [Jason] Yes.

03:03:28,453 --> 03:03:30,200
- So, the operating system has the ability

03:03:30,200 --> 03:03:31,890
and accessibility to clean the stuff up.

03:03:31,890 --> 03:03:32,830
- [Jason] It cleans up everything.

03:03:32,830 --> 03:03:34,420
- That needs to be preserved.

03:03:34,420 --> 03:03:36,470
- [Jason] It would be preserved.

03:03:36,470 --> 03:03:37,430
Yeah.

03:03:37,430 --> 03:03:39,080
- So, when you have multi-process,

03:03:39,080 --> 03:03:40,370
if one process dies,

03:03:40,370 --> 03:03:41,440
you just want to bring this up.

03:03:41,440 --> 03:03:44,457
You don't wanna kill the entire service

03:03:44,457 --> 03:03:45,290
on that machine,

03:03:45,290 --> 03:03:47,160
'cause if you kill all the processes,

03:03:47,160 --> 03:03:48,660
cleanup would happen nicely,

03:03:48,660 --> 03:03:50,436
but you don't want to.

03:03:50,436 --> 03:03:52,057
- And the thread model,

03:03:52,057 --> 03:03:53,780
a thread can die

03:03:53,780 --> 03:03:55,540
and the threads will continue.

03:03:55,540 --> 03:03:57,760
- But if this thread did something bad

03:03:57,760 --> 03:03:58,680
and the process dies,

03:03:58,680 --> 03:04:00,120
everything will be cleaned up.

03:04:00,120 --> 03:04:01,160
If the thread dies,

03:04:01,160 --> 03:04:02,370
so that's another option.

03:04:02,370 --> 03:04:04,130
The IPC between the processes,

03:04:04,130 --> 03:04:06,110
if I create something on one process,

03:04:06,110 --> 03:04:07,930
I'll tell the parent process,

03:04:07,930 --> 03:04:08,960
so it somehow knows

03:04:08,960 --> 03:04:11,530
to decrement the ref count on behalf.

03:04:11,530 --> 03:04:13,050
- That, I don't think - The process

03:04:13,050 --> 03:04:15,490
will not have the chance to send anything.

03:04:15,490 --> 03:04:17,653
- [Jason] Well, I don't think

03:04:17,653 --> 03:04:18,486
we can do that without races.

03:04:20,520 --> 03:04:21,680
It has to be done by the kernel

03:04:21,680 --> 03:04:24,450
in a way that's free of races.

03:04:24,450 --> 03:04:26,260
So, this is what I was saying to Ira.

03:04:26,260 --> 03:04:29,237
You can't really delegate this to the application

03:04:29,237 --> 03:04:30,739
and have a correct application.

03:04:30,739 --> 03:04:32,004
The kernel has to manage it somehow,

03:04:32,004 --> 03:04:33,315
and if you're saying

03:04:33,315 --> 03:04:35,690
you're sharing a single FD,

03:04:35,690 --> 03:04:37,380
then the kernel needs to understand

03:04:37,380 --> 03:04:39,270
that some objects need to be destroyed

03:04:39,270 --> 03:04:40,760
when a process exits.

03:04:40,760 --> 03:04:43,270
That's just what they need

03:04:43,270 --> 03:04:44,950
to make cleanup work correctly,

03:04:44,950 --> 03:04:47,470
so you need some way to bind some subject of objects

03:04:47,470 --> 03:04:48,920
to the lifetime of a process,

03:04:49,980 --> 03:04:51,670
which is another FD.

03:04:51,670 --> 03:04:53,360
So inevitably, we get to two FDs.

03:04:53,360 --> 03:04:54,920
- Why do we need another FD?

03:04:54,920 --> 03:04:57,044
- [Jason] Because that's the only object

03:04:57,044 --> 03:04:59,029
in the kernel that can bind to a lifetime

03:04:59,029 --> 03:05:00,220
of a process, is an FD,

03:05:00,220 --> 03:05:01,990
that a driver should be touching with.

03:05:01,990 --> 03:05:03,790
We shouldn't be screwing around with other things.

03:05:03,790 --> 03:05:05,520
- The FD can read first with inode or something,

03:05:05,520 --> 03:05:06,770
if that's what you want.

03:05:06,770 --> 03:05:08,170
You can manage that object

03:05:08,170 --> 03:05:09,540
and destroy what you need.

03:05:09,540 --> 03:05:11,360
- It's not the only way it's done.

03:05:11,360 --> 03:05:13,150
- [Jason] It's the way a driver should do it.

03:05:13,150 --> 03:05:16,600
- So Jason, actually, the import API looks similar,

03:05:16,600 --> 03:05:19,650
so I have a context which is shared,

03:05:19,650 --> 03:05:22,090
I'm pulling the handle out of this context,

03:05:22,090 --> 03:05:23,720
and I'm just giving you another FD

03:05:23,720 --> 03:05:25,520
that I somehow created,

03:05:25,520 --> 03:05:28,420
saying that this handle of reconstructing

03:05:28,420 --> 03:05:30,480
on a new object,

03:05:30,480 --> 03:05:32,430
associated with an additional FD,

03:05:32,430 --> 03:05:35,660
but it has to be on a QP CQ on everything.

03:05:35,660 --> 03:05:37,100
- [Jason] This is creating a different problem

03:05:37,100 --> 03:05:41,240
where we can no longer reliably destroy our hardware objects

03:05:41,240 --> 03:05:44,870
because user space could create situations

03:05:44,870 --> 03:05:47,810
where the right dependencies don't exist

03:05:47,810 --> 03:05:49,810
in the objects I'm trying to destroy.

03:05:49,810 --> 03:05:50,830
This is a weird quirk

03:05:50,830 --> 03:05:53,250
of how our system works.

03:05:53,250 --> 03:05:54,590
- It needs to be cleaned up.

03:05:54,590 --> 03:05:55,490
Is this a problem?

03:05:57,210 --> 03:05:59,843
- [Jason] I have yet to think of a way to clean it up.

03:06:01,549 --> 03:06:03,961
Fundamentally, we have a graph of objects,

03:06:03,961 --> 03:06:06,170
and you have to do your object destroys

03:06:06,170 --> 03:06:08,700
in a bottom up fashion from that graph.

03:06:08,700 --> 03:06:10,900
- And can that be done in an automatic way?

03:06:10,900 --> 03:06:12,010
- [Jason] We have an automatic way.

03:06:12,010 --> 03:06:14,420
We go over the list of things multiple times,

03:06:14,420 --> 03:06:16,650
then essentially destroy it bottom up.

03:06:16,650 --> 03:06:17,860
It works.

03:06:17,860 --> 03:06:19,550
It's fine, but it depends

03:06:19,550 --> 03:06:21,620
on the entire graph being part of the list,

03:06:21,620 --> 03:06:22,470
the same list.

03:06:22,470 --> 03:06:24,085
So, if you say, "oh,

03:06:24,085 --> 03:06:25,089
"I'm gonna take that list,

03:06:25,089 --> 03:06:25,922
"I'm gonna split it up,"

03:06:25,922 --> 03:06:26,755
well, now you got a problem

03:06:26,755 --> 03:06:29,020
because you have a portion of the graph.

03:06:29,020 --> 03:06:30,310
You can't destroy a portion

03:06:30,310 --> 03:06:31,660
if it's the wrong portion,

03:06:32,653 --> 03:06:34,560
or it's interlinked with the graph

03:06:34,560 --> 03:06:35,460
on the other side.

03:06:36,750 --> 03:06:38,310
It's a problem.

03:06:38,310 --> 03:06:39,540
It's a big mess.

03:06:39,540 --> 03:06:41,610
- And the graph is specific for each process, right?

03:06:41,610 --> 03:06:42,443
- [Jason] Today, yeah.

03:06:42,443 --> 03:06:43,700
- Today, yeah.

03:06:43,700 --> 03:06:44,698
Yeah.

03:06:44,698 --> 03:06:45,702
- [Jason] So, I think the only answer

03:06:45,702 --> 03:06:47,060
is you have to share the whole graph always.

03:06:47,060 --> 03:06:48,110
- Or you create a separate graph

03:06:48,110 --> 03:06:49,660
that's composed of both of them

03:06:49,660 --> 03:06:50,650
and it's managed separately.

03:06:50,650 --> 03:06:52,258
- [Jason] We can't do that.

03:06:52,258 --> 03:06:55,520
We can't have a shared PD with that.

03:06:55,520 --> 03:06:56,940
- Some of the objects are shared

03:06:56,940 --> 03:06:58,250
between both graphs.

03:06:58,250 --> 03:07:00,030
- Why do we need them?

03:07:00,030 --> 03:07:01,470
- [Jason] That's just how it is.

03:07:01,470 --> 03:07:02,670
The PD has to be shared.

03:07:03,900 --> 03:07:05,120
- You thought we had to have some sort

03:07:05,120 --> 03:07:07,100
of intermediate process structure

03:07:07,100 --> 03:07:09,730
that's associated with both,

03:07:09,730 --> 03:07:11,190
is associated with a fine handle

03:07:11,190 --> 03:07:13,183
and it manages a state that you have shared.

03:07:13,183 --> 03:07:14,460
- [Jason] None of that matters.

03:07:14,460 --> 03:07:15,293
At the end of the day,

03:07:15,293 --> 03:07:17,090
the hardware object for PD

03:07:17,090 --> 03:07:18,500
must exist in both processes,

03:07:18,500 --> 03:07:19,630
must exist in both graphs,

03:07:19,630 --> 03:07:21,340
and it has to be exactly the same object,

03:07:21,340 --> 03:07:23,230
and if I wanna destroy that PD object,

03:07:23,230 --> 03:07:25,970
I can't unless I've destroyed all of the children

03:07:25,970 --> 03:07:27,330
in both of the processes.

03:07:27,330 --> 03:07:28,793
- Yes.

03:07:28,793 --> 03:07:29,626
- [Jason] Which is a big problem.

03:07:29,626 --> 03:07:30,890
that's a big problem for our model.

03:07:30,890 --> 03:07:33,106
- Can this band in the lower level?

03:07:33,106 --> 03:07:35,312
- [Jason] I don't.

03:07:35,312 --> 03:07:36,145
(speech muffled)

03:07:36,145 --> 03:07:37,413
I don't wanna do that.

03:07:37,413 --> 03:07:38,816
(laughing)

03:07:38,816 --> 03:07:41,460
- Then, you get to vendor-specific problems.

03:07:41,460 --> 03:07:43,100
- [Jason] No, I don't wanna do that.

03:07:43,100 --> 03:07:45,370
Okay, so this has gone in a really bad direction.

03:07:45,370 --> 03:07:46,870
We no longer have any solutions.

03:07:46,870 --> 03:07:48,420
- The ultimate solution is shut down the devices

03:07:48,420 --> 03:07:49,766
and restart them.

03:07:49,766 --> 03:07:52,483
(laughing)

03:07:52,483 --> 03:07:53,488
Then, you have a known state.

03:07:53,488 --> 03:07:55,281
(laughing)

03:07:55,281 --> 03:07:56,686
- But I guess you have two devices.

03:07:56,686 --> 03:07:57,951
- No, no.

03:07:57,951 --> 03:08:01,451
(laughing and chattering)

03:08:02,289 --> 03:08:03,289
- So, you used three.

03:08:03,289 --> 03:08:05,706
(chattering)

03:08:07,219 --> 03:08:08,052
- Yeah.

03:08:08,052 --> 03:08:08,885
You have anything?

03:08:08,885 --> 03:08:10,200
- We have the Windows model.

03:08:10,200 --> 03:08:11,580
We just reboot it every night.

03:08:11,580 --> 03:08:13,958
- [Jason] Well, I think we're well over time.

03:08:13,958 --> 03:08:17,458
(laughing and chattering)

03:08:19,119 --> 03:08:20,318
The food.

03:08:20,318 --> 03:08:21,717
It's lunch.

03:08:21,717 --> 03:08:23,030
- It's lunch time, guys.

03:08:23,030 --> 03:08:24,451
- Hold on, one more.

03:08:24,451 --> 03:08:26,430
No, no.

03:08:28,260 --> 03:08:31,250
Shamir has posted a huge patch set,

03:08:31,250 --> 03:08:33,850
and then I split it into three patch sets.

03:08:33,850 --> 03:08:35,910
The first one is like a preparation.

03:08:37,010 --> 03:08:39,280
I didn't see any more comments on that,

03:08:39,280 --> 03:08:42,510
so is it acceptable?

03:08:42,510 --> 03:08:44,620
It's like a cleanup patch set.

03:08:44,620 --> 03:08:49,378
It's not related to the shared PD.

03:08:49,378 --> 03:08:53,140
I didn't see any objections, sorry,

03:08:54,190 --> 03:08:57,230
any comments on this patch set.

03:08:59,544 --> 03:09:00,550
- [Ira] And if it is just cleanup though,

03:09:00,550 --> 03:09:02,787
you can just submit it

03:09:02,787 --> 03:09:05,754
and get it in writing

03:09:05,754 --> 03:09:08,006
as a separate patch.

03:09:08,006 --> 03:09:09,005
- It's a patch set.

03:09:09,005 --> 03:09:10,502
It's already set.

03:09:10,502 --> 03:09:12,910
I don't know.

03:09:12,910 --> 03:09:14,000
- It's already been submitted,

03:09:14,000 --> 03:09:16,087
but I can only speak for myself.

03:09:16,087 --> 03:09:17,210
I saw it on there,

03:09:17,210 --> 03:09:19,750
but I really haven't had the time to look it over

03:09:19,750 --> 03:09:21,510
and review it closely.

03:09:21,510 --> 03:09:23,810
- [Jason] Oh, I dropped it off patch works immediately.

03:09:23,810 --> 03:09:24,870
- Okay.

03:09:24,870 --> 03:09:26,007
- [Jason] Yes.

03:09:26,007 --> 03:09:27,012
(laughing)

03:09:27,012 --> 03:09:28,010
Yes.

03:09:28,010 --> 03:09:30,020
It's not okay. - So, it was not just cleanup?

03:09:30,020 --> 03:09:33,870
- [Jason] No, it's many major things that are wrong.

03:09:33,870 --> 03:09:35,653
Oh, I got my own box.

03:09:35,653 --> 03:09:38,870
No new write interfaces is fundamental.

03:09:38,870 --> 03:09:40,100
We're not doing write interfaces anymore,

03:09:40,100 --> 03:09:42,200
so all the new user APIs have to be ioctl.

03:09:43,511 --> 03:09:44,344
- I'm just going off what he says.

03:09:44,344 --> 03:09:45,177
- [Jason] I'm saying,

03:09:46,684 --> 03:09:47,930
there was, I can't remember,

03:09:49,506 --> 03:09:50,339
there was too many patches,

03:09:50,339 --> 03:09:51,172
they weren't ordered right,

03:09:51,172 --> 03:09:52,830
they didn't compile.

03:09:52,830 --> 03:09:54,210
- [Yuval] No, but it's fixed.

03:09:54,210 --> 03:09:55,043
It's fixed.

03:09:55,043 --> 03:09:55,876
- Some of those have been fixed.

03:09:55,876 --> 03:09:57,730
- But I think he's asking specifically

03:09:57,730 --> 03:09:59,280
just of the cleanup the uobject.

03:09:59,280 --> 03:10:00,113
- [Jason] Oh, that one.

03:10:00,113 --> 03:10:02,410
Okay, that one I haven't taken off of patch work.

03:10:02,410 --> 03:10:03,320
That one, I still. - See.

03:10:03,320 --> 03:10:05,070
That eight patch series or whatever

03:10:05,070 --> 03:10:06,983
is still there, I think.

03:10:06,983 --> 03:10:07,816
- That one, I kinda - Yeah, because any work

03:10:07,816 --> 03:10:08,730
I will continue to do,

03:10:08,730 --> 03:10:10,840
whether with Alex or not

03:10:10,840 --> 03:10:11,960
based on that.

03:10:11,960 --> 03:10:13,290
- Now that we've had this discussion,

03:10:13,290 --> 03:10:14,730
I don't even wanna move forward with that one

03:10:14,730 --> 03:10:17,700
until we have an answer for how we're gonna handle cleanup,

03:10:17,700 --> 03:10:19,420
and that will guide how we have to do

03:10:19,420 --> 03:10:21,109
the reference counting

03:10:21,109 --> 03:10:22,779
and the the reference counting scheme

03:10:22,779 --> 03:10:24,278
you developed in that patch

03:10:24,278 --> 03:10:27,560
doesn't seem to solve the cleanup problem, I'm afraid.

03:10:27,560 --> 03:10:28,630
- No, I mean cleanup

03:10:28,630 --> 03:10:31,770
to separate the uobjects

03:10:31,770 --> 03:10:33,960
pointers from the IB object.

03:10:33,960 --> 03:10:36,020
- [Jason] I mean that when I go to destroy a ufile,

03:10:36,020 --> 03:10:37,420
I'm gonna destroy all the uhardwares

03:10:37,420 --> 03:10:38,300
associated with it,

03:10:38,300 --> 03:10:40,970
and that kinda has to work somehow.

03:10:40,970 --> 03:10:42,956
I don't know what we'll do.

03:10:42,956 --> 03:10:44,825
- So, it's either the import problem

03:10:44,825 --> 03:10:46,530
or the cleanup problem.

03:10:46,530 --> 03:10:47,690
- [Jason] Maybe the ref counts solve it.

03:10:47,690 --> 03:10:48,523
I'm not sure.

03:10:49,536 --> 03:10:51,720
- Can you create more devices?

03:10:51,720 --> 03:10:53,173
- [Jason] I'm not, no.

03:10:53,173 --> 03:10:54,425
(laughing)

03:10:54,425 --> 03:10:55,460
I have to think about it.

03:10:55,460 --> 03:10:56,850
- I think the answer to your question was no.

03:10:56,850 --> 03:10:58,373
- [Jason] I think we'll have to think about it.

03:10:58,373 --> 03:11:00,660
(chattering)

03:11:00,660 --> 03:11:02,011
To the lunch.

03:11:02,011 --> 03:11:03,920
(chattering)

03:11:03,920 --> 03:11:04,870
- [Yuval] That's it then?

03:11:04,870 --> 03:11:06,232
- [Jason] All right.

03:11:06,232 --> 03:11:07,410
- So basically, you have to check the security model

03:11:07,410 --> 03:11:08,873
to start it,

03:11:08,873 --> 03:11:09,710
if we can go either way,

03:11:09,710 --> 03:11:10,980
then we have to do homework

03:11:10,980 --> 03:11:13,320
and see how we solve,

03:11:13,320 --> 03:11:15,630
come up with a global solution.

03:11:15,630 --> 03:11:18,947
- [Yuval] One solution, yeah.

03:11:18,947 --> 03:11:19,970
Yeah.

03:11:19,970 --> 03:11:20,920
Promise to do that.

03:11:24,255 --> 03:11:25,940
(groaning)

03:11:25,940 --> 03:11:26,780
- Okay, let's have lunch

03:11:26,780 --> 03:11:28,740
and you'll feel great. - That's it.

03:11:28,740 --> 03:11:29,573
- [Yuval] No, after lunch,

03:11:29,573 --> 03:11:31,454
you cannot really think.

03:11:31,454 --> 03:11:32,898

YouTube URL: https://www.youtube.com/watch?v=DtsdD1RPI2s


