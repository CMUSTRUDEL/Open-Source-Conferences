Title: LPC2019 - Multipath TCP Upstreaming
Publication date: 2019-09-17
Playlist: Linux Plumbers Conference 2019
Description: 
	Multipath TCP Upstreaming

Multipath TCP (MPTCP) is an increasingly popular protocol that members of the kernel community are actively working to upstream. A Linux kernel fork implementing the protocol has been developed and maintained since March 2009. While there are some large MPTCP deployments using this custom kernel, an upstream implementation will make the protocol available on Linux devices of all flavors.

MPTCP is closely coupled with TCP, but an implementation does not need to interfere with operation of normal TCP connections. Our roadmap for MPTCP in Linux begins with the server use case, where connections and additional TCP subflows are generally initiated by peer devices. This will start with RFC 6824 compliance, but with a minimal feature set to limit the code footprint for initial review and testing.

The MPTCP upstreaming community has shared a RFC patch set on the netdev list that shows our progress and how we plan to build around the TCP stack. We'll share our roadmap for how this patch set will evolve before final submission, and discuss how this first step will differ from the forked implementation.

Once we have merged our baseline code, we have plans to continue development of more advanced features for managing subflow creation (path management), scheduling outgoing packets across TCP subflows, and other capabilities important for client devices that initiate connections. This includes making use of a userspace path manager, which has an alpha release available already. In future kernel releases we will make use of additional TCP features and optimize MPTCP performance as we get more feedback from kernel users.

Both the communication and the code are public and open. You can find us at mptcp@lists.01.org and https://is.gd/mptcp_upstream
Captions: 
	00:00:00,620 --> 00:00:01,860
- Okay, we're gonna get started.

00:00:01,860 --> 00:00:04,010
I have a couple of important announcements.

00:00:04,860 --> 00:00:06,060
If you've been watching the screen,

00:00:06,060 --> 00:00:07,480
there's some late breaking news.

00:00:07,480 --> 00:00:11,323
The eBPF backend of GCC has been checked into the trunk.

00:00:12,160 --> 00:00:12,993
(member of audience cheering)

00:00:12,993 --> 00:00:13,970
Is that exciting?

00:00:13,970 --> 00:00:15,757
Like hell hath frozen over.

00:00:15,757 --> 00:00:17,610
(audience applauding)

00:00:17,610 --> 00:00:21,630
Another announcement important for the conference speakers,

00:00:21,630 --> 00:00:23,200
you wanna get your speaker's gift,

00:00:23,200 --> 00:00:24,730
please go to the registration table,

00:00:24,730 --> 00:00:25,640
they have it in a box.

00:00:25,640 --> 00:00:27,520
Just ask for it and they'll give it to you, okay.

00:00:27,520 --> 00:00:28,780
So if you want your speaker's gift,

00:00:28,780 --> 00:00:30,950
go to the registration table, okay?

00:00:30,950 --> 00:00:31,950
Thank you very much.

00:00:32,840 --> 00:00:37,840
Next up, we have a talk about a project

00:00:38,040 --> 00:00:41,960
that's kind of we've been waiting for it to happen

00:00:41,960 --> 00:00:43,510
for quite some time in fact.

00:00:43,510 --> 00:00:46,513
It's the upstreaming of the MPTCP implementation.

00:00:47,938 --> 00:00:49,550
So but it looks like we're on

00:00:49,550 --> 00:00:50,920
the right track right now.

00:00:50,920 --> 00:00:53,230
And we'll get all kinds of information

00:00:53,230 --> 00:00:54,880
about that from Mat and Matthieu.

00:00:54,880 --> 00:00:56,450
Okay, so please give a round of applause

00:00:56,450 --> 00:00:57,939
for these gentlemen.

00:00:57,939 --> 00:01:01,106
(audience applauding)

00:01:02,190 --> 00:01:04,040
- Great, so welcome to this presentation.

00:01:04,040 --> 00:01:06,110
So as Dave's mentioned,

00:01:06,110 --> 00:01:08,520
so we are Mat Martineau from Intel.

00:01:08,520 --> 00:01:11,000
And I'm Matthieu Baerts from Tessares,

00:01:11,000 --> 00:01:13,090
a small company from Belgium.

00:01:13,090 --> 00:01:17,350
And we are representing here a community of developers.

00:01:17,350 --> 00:01:20,950
So not everybody can come with us on the stage.

00:01:20,950 --> 00:01:24,620
But we have Peter Krystad from Intel also

00:01:24,620 --> 00:01:25,480
within the audience.

00:01:25,480 --> 00:01:28,150
But also from home, we have Ossama Othman,

00:01:28,150 --> 00:01:30,600
Christoph Paasch from Apple.

00:01:30,600 --> 00:01:33,830
We have Paolo Abeni, and Davide Caratti,

00:01:33,830 --> 00:01:36,373
and Florian Westphal from Red Hat.

00:01:37,910 --> 00:01:40,220
So we are going to talk about the progress

00:01:40,220 --> 00:01:43,140
that we have made over the last few months

00:01:43,140 --> 00:01:46,400
through upstream Multipath TCP to the Linux kernel.

00:01:46,400 --> 00:01:48,893
We will also ask you some question.

00:01:49,908 --> 00:01:53,330
I don't know if we are going on the right direction.

00:01:53,330 --> 00:01:55,160
So of course, please interrupt us

00:01:55,160 --> 00:01:58,563
if you have any question or solution for all issues.

00:01:59,580 --> 00:02:01,490
So during this presentation,

00:02:01,490 --> 00:02:04,220
we will introduce you to Multipath TCP.

00:02:04,220 --> 00:02:06,530
We will also go into details

00:02:06,530 --> 00:02:09,540
on what will be in our initial patch set.

00:02:09,540 --> 00:02:13,410
Then we will talk about what will arrive next

00:02:13,410 --> 00:02:15,323
before the short conclusion.

00:02:17,030 --> 00:02:18,750
So we have to start with that.

00:02:18,750 --> 00:02:20,790
What is Multipath TCP?

00:02:20,790 --> 00:02:21,623
So just to know it all,

00:02:21,623 --> 00:02:25,060
first, I can go for the following slides.

00:02:25,060 --> 00:02:27,390
May I ask you to raise your hand

00:02:27,390 --> 00:02:30,773
if you don't know anything about Multipath TCP?

00:02:32,190 --> 00:02:34,480
Okay and for you, all of you,

00:02:34,480 --> 00:02:37,773
do you plan to sleep in the next 45 minutes?

00:02:38,717 --> 00:02:39,550
(audience chuckles)

00:02:39,550 --> 00:02:41,830
Okay, nobody raised their hand.

00:02:41,830 --> 00:02:43,650
Also, just to know, is there many people

00:02:43,650 --> 00:02:46,363
that know also a bit about Multipath TCP?

00:02:47,930 --> 00:02:50,683
And some people, they know a lot about Multipath TCP?

00:02:51,820 --> 00:02:54,420
Ah, do you want to present here?

00:02:54,420 --> 00:02:57,150
No, sorry. (audience laughing)

00:02:57,150 --> 00:03:00,453
Great, so Multipath TCP in one sentence.

00:03:01,530 --> 00:03:04,340
It allow to exchange data for a single connection

00:03:04,340 --> 00:03:07,423
over different paths simultaneously.

00:03:08,620 --> 00:03:10,940
So it is breaking the assumption

00:03:10,940 --> 00:03:13,140
that one connection is restricted

00:03:13,140 --> 00:03:14,840
to the same five tuple.

00:03:14,840 --> 00:03:18,550
So behind the RFC, you can find a description

00:03:18,550 --> 00:03:21,970
of this protocol published in 2013.

00:03:21,970 --> 00:03:26,063
So it is supported by the IETF Multipath TCP working group.

00:03:26,950 --> 00:03:29,370
A typical representation of what the protocol

00:03:29,370 --> 00:03:32,050
can bring is represented on this slide.

00:03:32,050 --> 00:03:35,590
So on one hand, you have a full-on or any device

00:03:35,590 --> 00:03:38,700
that can be connected to different networks.

00:03:38,700 --> 00:03:42,960
It can also have different network interfaces

00:03:42,960 --> 00:03:44,180
directly to this network.

00:03:44,180 --> 00:03:46,270
And then you have a server on the other side

00:03:46,270 --> 00:03:50,970
that have fast access from many different networks.

00:03:50,970 --> 00:03:55,360
So with this setup, you can have more bandwidth, of course.

00:03:55,360 --> 00:03:57,950
You can also have more redundancy if you wish

00:03:58,910 --> 00:04:01,350
but you can also support some handover

00:04:01,350 --> 00:04:03,960
on mobility use cases.

00:04:03,960 --> 00:04:08,220
So a typical scenario is the walk-out one.

00:04:08,220 --> 00:04:10,913
So imagine that you are inside a building.

00:04:12,350 --> 00:04:16,250
You are going out of the building.

00:04:16,250 --> 00:04:19,590
And the Wi-Fi signal is getting weaker and weaker.

00:04:19,590 --> 00:04:23,060
But that's not an issue because you have Multipath TCP.

00:04:23,060 --> 00:04:26,623
The connection can continue on the cellular network.

00:04:29,290 --> 00:04:32,800
So this is useful knowing how hard it can be

00:04:32,800 --> 00:04:36,983
to detect a disconnection on the wireless network.

00:04:38,386 --> 00:04:41,510
So you don't have to restart a new connection

00:04:41,510 --> 00:04:44,043
and restart from where you were before.

00:04:45,180 --> 00:04:46,590
The switch also can be fast

00:04:46,590 --> 00:04:49,573
between the two networks.

00:04:50,810 --> 00:04:55,600
So different vendors have added Multipath TCP support.

00:04:55,600 --> 00:04:58,930
So Apple was mainly the first one

00:04:58,930 --> 00:05:01,423
since 2013, if I remember well.

00:05:02,410 --> 00:05:04,100
Mainly to support failover

00:05:04,100 --> 00:05:07,100
and this kind of walk-out scenario.

00:05:07,100 --> 00:05:09,860
Some other vendors also implemented it,

00:05:09,860 --> 00:05:11,600
also to have more bandwidth,

00:05:11,600 --> 00:05:14,510
especially in some countries like Korea.

00:05:14,510 --> 00:05:16,223
South Korea, of course.

00:05:17,840 --> 00:05:21,090
There is also another use case that I like to present.

00:05:21,090 --> 00:05:24,970
Because it's the one that we are working on at Tessares.

00:05:24,970 --> 00:05:27,470
It's about the residential gateway.

00:05:27,470 --> 00:05:29,890
So we can have hybrid residential gateway,

00:05:29,890 --> 00:05:33,260
router at home, where we can combine

00:05:33,260 --> 00:05:35,330
both LTE and DSL network.

00:05:35,330 --> 00:05:37,420
It's very useful especially when you're

00:05:37,420 --> 00:05:39,130
far away from a street cabinet,

00:05:39,130 --> 00:05:42,533
and your DSL connection is shit.

00:05:44,870 --> 00:05:46,930
Another very important use case

00:05:46,930 --> 00:05:51,930
is that Multipath TCP is part of the 5G standardization.

00:05:52,620 --> 00:05:56,220
It is part of the ATSSS function,

00:05:56,220 --> 00:05:58,460
which mean access steering,

00:05:58,460 --> 00:06:01,260
Access Traffic Steering, Stitching and Splitting,

00:06:01,260 --> 00:06:02,110
a very nice work.

00:06:03,060 --> 00:06:04,270
But basically to show that.

00:06:04,270 --> 00:06:07,220
So what it means is that to improve

00:06:07,220 --> 00:06:10,580
the end-user experience, you can have some steering,

00:06:10,580 --> 00:06:12,963
so you can select the best network.

00:06:13,940 --> 00:06:17,710
5G, Wi-Fi or 4G, especially if 5G

00:06:17,710 --> 00:06:19,870
is not available everywhere.

00:06:19,870 --> 00:06:22,600
You can have seamless handover.

00:06:22,600 --> 00:06:24,863
So switch from one network to another.

00:06:25,740 --> 00:06:28,300
And you can also have network aggregation

00:06:28,300 --> 00:06:31,903
if the operator want to give you more bandwidth.

00:06:36,450 --> 00:06:41,450
Great, it is part of the 5G but it is not,

00:06:42,810 --> 00:06:44,130
there is no implementation

00:06:44,130 --> 00:06:46,200
in the Linux upstream kernel.

00:06:46,200 --> 00:06:49,630
But the 3GPP guys, they have selected Multipath TCP

00:06:49,630 --> 00:06:51,503
because it's a major protocol.

00:06:53,550 --> 00:06:58,550
An implementation exists out of three since March 2009.

00:06:59,570 --> 00:07:03,730
It's not new, the last version is v0.95.

00:07:03,730 --> 00:07:06,240
And it is generally used as a client-server

00:07:06,240 --> 00:07:07,330
in current deployments.

00:07:07,330 --> 00:07:10,340
So currently, it's used by million of users.

00:07:10,340 --> 00:07:13,390
But the problem is that it's not upstreamable.

00:07:13,390 --> 00:07:14,850
It's not upstreamable mainly because

00:07:14,850 --> 00:07:18,010
it has been built to support experiment

00:07:18,010 --> 00:07:20,853
and rapid changes but not generic enough.

00:07:22,210 --> 00:07:24,503
Most of the user that install this kernel

00:07:24,503 --> 00:07:26,530
want to use Multipath TCP.

00:07:26,530 --> 00:07:29,520
So it is fine for them if other TCP connection

00:07:29,520 --> 00:07:32,450
are slightly affected, I mean consuming

00:07:32,450 --> 00:07:35,703
a bit more CPU cycle and a bit more memory.

00:07:37,730 --> 00:07:40,760
So towards Multipath TCP upstream,

00:07:40,760 --> 00:07:43,240
a group of developer that we represent

00:07:43,240 --> 00:07:44,930
have defined some guideline.

00:07:44,930 --> 00:07:48,063
So we have a new implementation.

00:07:49,580 --> 00:07:51,230
The guidelines say that the new implementation

00:07:51,230 --> 00:07:54,250
cannot affect the existing TCP stack.

00:07:54,250 --> 00:07:56,890
We don't want any performance regression

00:07:56,890 --> 00:07:58,800
in TCP stacks, of course.

00:07:58,800 --> 00:08:00,630
We don't want any code change

00:08:00,630 --> 00:08:04,120
if CONFIG_MPTCP is disabled.

00:08:04,120 --> 00:08:06,340
What we also want is to run something

00:08:06,340 --> 00:08:10,003
easy to maintain, also configurable.

00:08:11,170 --> 00:08:14,820
We don't want to have many if statement

00:08:14,820 --> 00:08:16,780
in the TCP code.

00:08:16,780 --> 00:08:19,910
And what we also want is to have,

00:08:19,910 --> 00:08:21,490
to have an implementation that can be used

00:08:21,490 --> 00:08:23,263
in variety of deployment.

00:08:24,610 --> 00:08:26,220
One compliance that we have fixed

00:08:26,220 --> 00:08:29,113
is that Multipath TCP will be opt-in.

00:08:30,780 --> 00:08:33,630
I mean that if you're a developer,

00:08:33,630 --> 00:08:36,713
an application developer of applications,

00:08:37,570 --> 00:08:39,270
if you want to have Multipath TCP,

00:08:39,270 --> 00:08:41,030
you will need to ask for it.

00:08:41,030 --> 00:08:43,230
Of course, there will be workaround for that.

00:08:43,230 --> 00:08:45,313
Mat will talk about that later.

00:08:46,740 --> 00:08:48,260
What we'll also like to do

00:08:48,260 --> 00:08:49,410
is to proceed in steps.

00:08:49,410 --> 00:08:51,600
So minimal feature set first,

00:08:51,600 --> 00:08:52,860
and then the optimization,

00:08:52,860 --> 00:08:54,933
and the advanced feature for later.

00:08:57,620 --> 00:09:01,533
So now let's talk about the protocol.

00:09:03,490 --> 00:09:05,440
We need to detail a bit

00:09:05,440 --> 00:09:07,240
because there are some notion that

00:09:07,240 --> 00:09:09,543
are very particular to MPTCP.

00:09:11,870 --> 00:09:14,960
So first creating a new protocol this day

00:09:14,960 --> 00:09:18,480
in a world full of very nice middle boxes,

00:09:18,480 --> 00:09:19,350
it's not easy.

00:09:19,350 --> 00:09:23,270
Either you go and you take the quick way,

00:09:23,270 --> 00:09:25,900
I mean you encrypt everything,

00:09:25,900 --> 00:09:27,760
you do that on top of UDP,

00:09:27,760 --> 00:09:30,480
oh sorry, UD-QUIC or you work with

00:09:30,480 --> 00:09:32,293
what is available in TCP.

00:09:33,793 --> 00:09:35,900
So MPTCP is an extension to TCP,

00:09:35,900 --> 00:09:38,010
the different connection comprising

00:09:38,010 --> 00:09:41,433
on MPTCP1 are called TCP subflows.

00:09:42,670 --> 00:09:45,790
In fact, there are TCP connection on the wire.

00:09:45,790 --> 00:09:48,910
So they can thank specific TCP option,

00:09:48,910 --> 00:09:51,020
they also behave like TCP.

00:09:51,020 --> 00:09:54,283
So you will still have SYN, SYN-ACK, ACK and whatever.

00:09:55,380 --> 00:09:57,720
So what is also important,

00:09:57,720 --> 00:09:59,620
and what the protocol would like to have

00:09:59,620 --> 00:10:03,820
is that the usage would be similar for the application.

00:10:03,820 --> 00:10:06,520
So if an application was using TCP previously,

00:10:06,520 --> 00:10:08,350
it should continue to do the same

00:10:08,350 --> 00:10:10,780
to use Multipath TCP, except of course,

00:10:10,780 --> 00:10:13,683
if it want to have some fine-grained control.

00:10:15,290 --> 00:10:19,030
One important notion in MPTCP world

00:10:19,030 --> 00:10:22,770
is the data sequence number.

00:10:22,770 --> 00:10:25,300
So to be able to reconstruct a stream

00:10:25,300 --> 00:10:27,220
sent over multiple subflow,

00:10:27,220 --> 00:10:31,490
you need a dedicated data sequence number.

00:10:31,490 --> 00:10:33,980
This is in addition to the TCP1

00:10:33,980 --> 00:10:36,603
because you need something at the MPTCP layer.

00:10:37,750 --> 00:10:39,273
I didn't do anything, I swear.

00:10:40,350 --> 00:10:42,767
- [Dave] It should come back.

00:10:43,660 --> 00:10:45,510
- So this is the DSS.

00:10:45,510 --> 00:10:47,660
So it is something needed.

00:10:47,660 --> 00:10:49,840
But also when we look at that

00:10:49,840 --> 00:10:51,420
from a stack pointer viewer,

00:10:51,420 --> 00:10:55,590
when an application send data to the kernel,

00:10:55,590 --> 00:10:58,343
MPTCP will select of course the subflow.

00:10:59,410 --> 00:11:01,290
But then the subflow will also need to know

00:11:01,290 --> 00:11:04,910
what need to be in the TCP option.

00:11:04,910 --> 00:11:08,120
So you will need to add some specific MPTCP option

00:11:08,120 --> 00:11:10,240
in the TCP header.

00:11:10,240 --> 00:11:13,233
So you can see that the layers are not clearly separated.

00:11:15,290 --> 00:11:17,650
In fact, this major TCP extension

00:11:17,650 --> 00:11:20,303
overlap so much with the regular TCP.

00:11:21,960 --> 00:11:24,470
Just also a quick note is that like TCP,

00:11:24,470 --> 00:11:26,030
if you have a sequence number,

00:11:26,030 --> 00:11:29,033
you also need ACK to ensure delivery.

00:11:32,680 --> 00:11:34,320
Then there are also some keyword

00:11:34,320 --> 00:11:36,563
that are really specific to MPTCP.

00:11:37,500 --> 00:11:39,000
So we have a few example here.

00:11:39,000 --> 00:11:42,830
So we have the MP_CAPABLE and the MP_JOIN.

00:11:42,830 --> 00:11:45,913
They are both visible on the TCP SYN packet.

00:11:46,810 --> 00:11:48,250
One is to announce of course

00:11:48,250 --> 00:11:50,650
that we can do Multipath TCP,

00:11:50,650 --> 00:11:52,610
and we will like to initiate a new one.

00:11:52,610 --> 00:11:55,980
The other one is to join a new TCP subflow

00:11:55,980 --> 00:11:59,023
to an existing MPTCP connection.

00:12:00,860 --> 00:12:05,110
We will also talk a bit about the DATA_FIN later

00:12:05,110 --> 00:12:08,710
but that's a typical response to the TCP FIN

00:12:08,710 --> 00:12:10,863
but for the MPTCP layer.

00:12:13,570 --> 00:12:17,130
Also important to say is the signaling

00:12:17,130 --> 00:12:20,120
because MPTCP needs some signaling.

00:12:20,120 --> 00:12:23,910
It is done via dedicated TCP ACK,

00:12:23,910 --> 00:12:26,120
and it is used to announce for example,

00:12:26,120 --> 00:12:29,380
additional addresses to the other host.

00:12:29,380 --> 00:12:32,930
So I'm available from this IP.

00:12:32,930 --> 00:12:36,130
It can also be used to conceal an announcement

00:12:36,130 --> 00:12:37,130
that has been done.

00:12:37,130 --> 00:12:38,600
We also have the fast close

00:12:38,600 --> 00:12:39,990
because maybe at some point,

00:12:39,990 --> 00:12:43,393
you want to free resources as quickly as possible.

00:12:44,890 --> 00:12:48,010
And you'll use what we called a Fast Close.

00:12:48,010 --> 00:12:51,590
A last bit which is worth mentioning

00:12:51,590 --> 00:12:54,050
because it will impact TCP code

00:12:54,050 --> 00:12:57,790
is that the received windows across

00:12:57,790 --> 00:13:00,163
the TCP subflow is shared.

00:13:01,610 --> 00:13:04,393
It is first by the protocol towards our deadlocks.

00:13:05,300 --> 00:13:06,530
We cannot change the protocol.

00:13:06,530 --> 00:13:08,490
There is a very good reason that it is there,

00:13:08,490 --> 00:13:10,840
and we will need to implement it.

00:13:10,840 --> 00:13:12,590
But Mat will talk about that later.

00:13:14,910 --> 00:13:17,350
So the last slide before talking about

00:13:17,350 --> 00:13:19,913
what will be in our initial patch set.

00:13:20,820 --> 00:13:24,370
It's just a small load about the different version

00:13:24,370 --> 00:13:27,559
that exists for Multipath TCP.

00:13:27,559 --> 00:13:29,300
So there are mainly and there are in fact,

00:13:29,300 --> 00:13:32,350
two version available.

00:13:32,350 --> 00:13:35,683
So you have the current RFC 6824,

00:13:36,520 --> 00:13:41,213
and its evolution that has been submitted for publication.

00:13:42,900 --> 00:13:45,860
Unfortunately or not, but there are

00:13:45,860 --> 00:13:48,800
some behavioral changes.

00:13:48,800 --> 00:13:51,603
So we will switch from v0 to v1.

00:13:54,660 --> 00:13:59,010
But what is important is that it is somehow better.

00:13:59,010 --> 00:14:01,500
It is better not only because my boss

00:14:01,500 --> 00:14:03,180
was leading the discussion

00:14:03,180 --> 00:14:06,200
but also because it has been written

00:14:06,200 --> 00:14:07,760
after having received some feedback

00:14:07,760 --> 00:14:11,647
from the different users and the different implementers.

00:14:12,560 --> 00:14:15,500
So in short, it should be easier

00:14:15,500 --> 00:14:17,970
to implement for some points.

00:14:17,970 --> 00:14:21,023
It will also allow a few more use cases.

00:14:22,210 --> 00:14:24,070
But also because it has been selected

00:14:24,070 --> 00:14:27,580
by the 3GPP organization for 5G.

00:14:27,580 --> 00:14:30,520
And we hope that all existing implementation

00:14:30,520 --> 00:14:33,283
will quickly switch to this new version.

00:14:34,200 --> 00:14:36,650
We would like to ask you a question.

00:14:36,650 --> 00:14:40,400
Is it okay if we only focus on the new RFC 6824 bis

00:14:41,850 --> 00:14:43,450
or the standard one?

00:14:43,450 --> 00:14:47,110
To avoid having some ugly code in MPTCP

00:14:47,110 --> 00:14:49,180
especially when we'll have to enter

00:14:49,180 --> 00:14:50,853
the different MPTCP option.

00:15:00,271 --> 00:15:03,640
- I think it's okay if you focus just on v1.

00:15:03,640 --> 00:15:04,473
- So thank you.

00:15:08,580 --> 00:15:13,580
Great, finally, we can now discuss

00:15:13,650 --> 00:15:16,680
about what will be in our first patch set

00:15:17,600 --> 00:15:20,350
that we will send soon, we hope.

00:15:23,120 --> 00:15:25,530
So our first RFC version has been shared

00:15:25,530 --> 00:15:28,623
on the Netlink mailing list in June, I think.

00:15:29,670 --> 00:15:32,630
But we will describe here what was already in it,

00:15:32,630 --> 00:15:35,080
what is in our development version,

00:15:35,080 --> 00:15:37,323
and what will be in the next few weeks.

00:15:39,300 --> 00:15:42,310
So to understand the following slides,

00:15:42,310 --> 00:15:45,530
here is the global architecture for MPTCP,

00:15:45,530 --> 00:15:47,450
the one that we have selected.

00:15:47,450 --> 00:15:50,673
The different items will of course, be detailed later.

00:15:51,560 --> 00:15:54,550
But just try to keep in mind this picture

00:15:54,550 --> 00:15:56,790
that might be useful for later.

00:15:56,790 --> 00:16:00,380
So the application will take two MPTCP layers

00:16:00,380 --> 00:16:01,953
through the socket API.

00:16:03,260 --> 00:16:05,813
MPTCP layer is in fact IP Proto.

00:16:07,170 --> 00:16:11,070
Then we have below the TCP subflows,

00:16:11,070 --> 00:16:14,940
and they are built on top of TCP ULP framework.

00:16:14,940 --> 00:16:17,333
And we will detail that later.

00:16:19,150 --> 00:16:22,000
And also remember that we will have to store

00:16:22,000 --> 00:16:24,633
some specific MPTCP data.

00:16:25,520 --> 00:16:28,400
This is done by using SKB extension.

00:16:28,400 --> 00:16:32,110
So to only store data for the MPTCP connection

00:16:32,110 --> 00:16:35,183
and not for all connections.

00:16:37,610 --> 00:16:41,233
Okay, if there is no question about that, let's continue.

00:16:42,550 --> 00:16:47,550
And so how application can create MPTCP circuit?

00:16:47,620 --> 00:16:50,100
So what we decided is to do that

00:16:50,100 --> 00:16:52,053
via the circuit API.

00:16:53,160 --> 00:16:57,330
So like TCP, you can see that we have a SOCK_STREAM,

00:16:57,330 --> 00:16:58,790
argument is still there.

00:16:58,790 --> 00:17:02,543
We also have AF_INET or AF_INET6,

00:17:04,120 --> 00:17:07,000
which lead me to a question that

00:17:07,000 --> 00:17:09,373
we also have is that for the moment,

00:17:10,930 --> 00:17:15,540
IPv6 is currently not supported by all implementation.

00:17:15,540 --> 00:17:17,700
It should not be hard to add

00:17:17,700 --> 00:17:20,550
but we would like to not focus on that

00:17:20,550 --> 00:17:22,734
for the beginning, yes?

00:17:22,734 --> 00:17:24,785
- [Member of Audience] I think you should do the opposite.

00:17:24,785 --> 00:17:26,291
(audience laughing)

00:17:26,291 --> 00:17:27,124
- [Member of Audience] Yes.

00:17:27,124 --> 00:17:28,490
- I agree, but it's a bit later.

00:17:28,490 --> 00:17:29,680
It's a bit too late.

00:17:30,710 --> 00:17:33,460
Knowing indeed, maybe we should have started with that.

00:17:34,320 --> 00:17:35,950
But the question is that

00:17:35,950 --> 00:17:37,710
we would like to push all patch.

00:17:37,710 --> 00:17:39,930
We would like also to have some feedback about that,

00:17:39,930 --> 00:17:42,420
and we would like to know if we can continue like that.

00:17:42,420 --> 00:17:45,477
Of course, IPv6 will be on the top of

00:17:45,477 --> 00:17:47,200
our to-do list for later.

00:17:47,200 --> 00:17:50,120
But would it be okay for upstream if we do that?

00:17:51,454 --> 00:17:53,363
- [Member of Audience] If we're certain about time.

00:17:53,363 --> 00:17:58,363
- I think that the upstreaming approach

00:17:58,390 --> 00:18:02,520
should be you should be submitting the most

00:18:02,520 --> 00:18:05,683
basic MPTCP functionality at the beginning.

00:18:06,700 --> 00:18:10,710
Therefore, you should be having IPv6 support

00:18:10,710 --> 00:18:13,040
from the start as well in the simplistic

00:18:13,040 --> 00:18:15,610
basic MPTCP implementations.

00:18:15,610 --> 00:18:18,400
We're way past the point of letting people

00:18:18,400 --> 00:18:20,670
submit IPv4 specific implementations

00:18:20,670 --> 00:18:21,570
of anything, anymore.

00:18:21,570 --> 00:18:22,880
We just can't allow that anymore.

00:18:22,880 --> 00:18:24,530
It's just not practical.

00:18:24,530 --> 00:18:26,900
People have, people's entire data centers

00:18:26,900 --> 00:18:29,900
are IPv6-enabled at this point.

00:18:29,900 --> 00:18:33,143
So I think you need to add IPv6 support as a requirement.

00:18:34,020 --> 00:18:34,853
- Thank you.

00:18:40,461 --> 00:18:43,380
(audience applauding)

00:18:43,380 --> 00:18:45,840
- Not to answer a question with a question

00:18:45,840 --> 00:18:47,440
but what's the hesitation

00:18:47,440 --> 00:18:49,800
from implementing this on IPv6?

00:18:49,800 --> 00:18:52,130
It doesn't seem like it should be

00:18:52,130 --> 00:18:54,750
have any particular extra difficulty.

00:18:54,750 --> 00:18:56,130
- No, it should not be difficult.

00:18:56,130 --> 00:18:58,530
It's just that we focus on IPv4 for the moment.

00:18:58,530 --> 00:19:01,400
Some structure are only using U32,

00:19:01,400 --> 00:19:03,570
for example, to store addresses.

00:19:03,570 --> 00:19:05,850
It's just that we don't want to start by adding unions

00:19:05,850 --> 00:19:07,663
and others but if we have--

00:19:07,663 --> 00:19:08,690
- I would agree with Dave,

00:19:08,690 --> 00:19:10,810
and given that your first primary example

00:19:10,810 --> 00:19:13,120
was the use of a cell phone over multiple networks,

00:19:13,120 --> 00:19:15,420
and they're primary users of IPv6,

00:19:15,420 --> 00:19:17,850
it would make sense to have that first.

00:19:17,850 --> 00:19:20,140
- I can guarantee we will not take it for Android

00:19:20,140 --> 00:19:21,643
without IPv6 support.

00:19:26,410 --> 00:19:27,540
- Anyone else wanna continue

00:19:27,540 --> 00:19:29,377
in this fantastic discussion?

00:19:29,377 --> 00:19:31,640
(audience laughing)

00:19:31,640 --> 00:19:32,740
Okay, please continue.

00:19:37,477 --> 00:19:41,144
- Great, okay so if we come back to the line

00:19:42,080 --> 00:19:44,440
that is written on the slide,

00:19:44,440 --> 00:19:47,370
we also have a DN IPPROTO_MPTCP.

00:19:47,370 --> 00:19:49,720
So of course, behind that, there is a number.

00:19:49,720 --> 00:19:52,170
The number that we have picked is 262,

00:19:52,170 --> 00:19:53,310
not because it's pretty

00:19:53,310 --> 00:19:56,203
but because we had some constraint there.

00:19:57,450 --> 00:19:59,740
On the wire, of course, we will only see

00:20:00,772 --> 00:20:03,310
IPPROTO_TCP because on the wire,

00:20:03,310 --> 00:20:07,043
you will not see a special number for the protocol there.

00:20:08,500 --> 00:20:11,250
But internally, we need a new number.

00:20:11,250 --> 00:20:14,510
INA, the responsible of signing the

00:20:14,510 --> 00:20:15,643
assigning a bit.

00:20:16,640 --> 00:20:21,640
So up to 256 but we need a new one.

00:20:21,750 --> 00:20:23,820
We don't really want to spend time

00:20:23,820 --> 00:20:26,210
at INA to ask them for a new number

00:20:26,210 --> 00:20:28,210
except if you know some socket for that.

00:20:29,130 --> 00:20:33,697
But what we have picked is that we took IPPROTO

00:20:35,476 --> 00:20:38,970
and then we added 0x100.

00:20:38,970 --> 00:20:40,670
Like that we hope that it should be fine

00:20:40,670 --> 00:20:43,010
because a number should not be too high

00:20:43,010 --> 00:20:46,943
after 255, which is the last number currently used.

00:20:48,190 --> 00:20:50,470
We of course check that in the kernel.

00:20:50,470 --> 00:20:52,210
It is fine to use this number.

00:20:52,210 --> 00:20:53,603
We had to change two or three line

00:20:53,603 --> 00:20:56,110
I think just to print the correct information.

00:20:56,110 --> 00:20:57,843
It was just for debugging.

00:20:58,790 --> 00:21:00,870
But we are wondering if you see

00:21:00,870 --> 00:21:03,310
any other issue that we could have with that,

00:21:03,310 --> 00:21:06,763
for example, libc, they also redefine all these numbers.

00:21:07,880 --> 00:21:11,820
In theory for the socket API,

00:21:11,820 --> 00:21:16,550
you need the integer for the last bit, so it's fine.

00:21:16,550 --> 00:21:20,283
But if you have anything to say about that, don't hesitate.

00:21:23,900 --> 00:21:25,550
We will continue to do that then.

00:21:29,440 --> 00:21:32,970
Okay, now about how you can interact

00:21:32,970 --> 00:21:36,490
with the current socket that we have just created.

00:21:36,490 --> 00:21:39,740
So as an application developer,

00:21:39,740 --> 00:21:41,620
what you want to do sometime

00:21:41,620 --> 00:21:46,550
is to tune how your MPTCP circuit will behave.

00:21:46,550 --> 00:21:50,660
But it can be on the global MPTCP circuit.

00:21:50,660 --> 00:21:52,980
But it could be also only for the subflow,

00:21:52,980 --> 00:21:55,850
only for the existing and future subflow

00:21:55,850 --> 00:21:58,920
or maybe, only for one specific subflow

00:21:58,920 --> 00:22:01,713
that you have on your MPTCP connection.

00:22:03,310 --> 00:22:05,980
This can be either complex to implement

00:22:05,980 --> 00:22:08,530
or not easy to read at the beginning.

00:22:08,530 --> 00:22:13,530
So what we want to do is not to settle on an API node.

00:22:13,920 --> 00:22:15,910
So all you can do is to interact

00:22:15,910 --> 00:22:19,350
with the MPTCP circuit if there is no subflow,

00:22:19,350 --> 00:22:21,473
and we will see what we will do later.

00:22:22,800 --> 00:22:24,063
Any objection for that?

00:22:27,120 --> 00:22:27,953
Good.

00:22:32,610 --> 00:22:33,980
Now an important topic.

00:22:33,980 --> 00:22:35,183
It's about security.

00:22:36,360 --> 00:22:39,800
Of course, we will do our best to avoid any issue.

00:22:39,800 --> 00:22:42,050
But it's clear that the initial implementation

00:22:42,050 --> 00:22:45,360
will not be hardened by broad use yet.

00:22:45,360 --> 00:22:47,870
So you will not have many company

00:22:47,870 --> 00:22:52,563
running a sysctl with CONFIG_MPTCP equal to yes.

00:22:54,540 --> 00:22:56,770
So what we would like to do is

00:22:56,770 --> 00:23:00,810
not allow any application to create MPTCP circuit.

00:23:00,810 --> 00:23:02,817
So the idea that we have,

00:23:02,817 --> 00:23:04,720
and we already implemented

00:23:04,720 --> 00:23:08,650
is to have a CCTL per network namespace.

00:23:08,650 --> 00:23:11,180
So by default, no application will be able

00:23:11,180 --> 00:23:13,520
to create any MPTCP circuit.

00:23:13,520 --> 00:23:17,610
If an admin turn on the option,

00:23:17,610 --> 00:23:20,620
then any application from this network namespace

00:23:20,620 --> 00:23:25,620
will be able to create an MPTCP circuit.

00:23:25,680 --> 00:23:26,623
Is it enough?

00:23:27,620 --> 00:23:29,700
- I think it may be over engineering

00:23:29,700 --> 00:23:32,053
to turn it off by default, even.

00:23:35,490 --> 00:23:37,290
If we're going to accept your code,

00:23:37,290 --> 00:23:38,190
it should be functional,

00:23:38,190 --> 00:23:39,940
and we should be able to trust it.

00:23:39,940 --> 00:23:44,940
- Yes, yeah, we have to trust ourselves, first.

00:23:45,422 --> 00:23:47,970
- [Dave] That's right.

00:23:47,970 --> 00:23:49,730
- Okay, that's a good news.

00:23:49,730 --> 00:23:52,110
Should we keep this option in the CCTL or?

00:23:56,690 --> 00:23:59,360
- I think we already have too many knobs in the tree.

00:23:59,360 --> 00:24:01,790
- I think it could be good to have this knob

00:24:01,790 --> 00:24:04,986
but on the opposite way.

00:24:04,986 --> 00:24:07,010
- [Matthieu] Yeah, to turn it off if there is an issue.

00:24:07,010 --> 00:24:08,596
- Yeah, in case of emergency

00:24:08,596 --> 00:24:12,372
but I think it's a minor detail.

00:24:12,372 --> 00:24:13,857
- Okay good, thank you.

00:24:13,857 --> 00:24:14,877
- And the other thing for the sysctl,

00:24:14,877 --> 00:24:17,240
you should just submit a patch to that.

00:24:17,240 --> 00:24:20,300
I mean like the model that is needed

00:24:20,300 --> 00:24:22,540
to extend the API that sysctl understands,

00:24:22,540 --> 00:24:25,130
and then it will also fuzz MPTCP right?

00:24:25,130 --> 00:24:26,970
So it's not like a big thing.

00:24:26,970 --> 00:24:28,721
- Yes, thank you.

00:24:28,721 --> 00:24:29,554
- [Member of Audience] All right.

00:24:29,554 --> 00:24:30,763
- [Dave] Question at the back.

00:24:32,740 --> 00:24:33,640
- Watch your head.

00:24:35,941 --> 00:24:36,774
(member of audience speaking faintly)

00:24:36,774 --> 00:24:38,377
(audience laughing)

00:24:38,377 --> 00:24:39,622
(member of audience speaking faintly)

00:24:39,622 --> 00:24:40,455
- You go ahead, please talk.

00:24:40,455 --> 00:24:41,520
- I just wanted to point out

00:24:41,520 --> 00:24:43,910
that per network namespace sysctls

00:24:43,910 --> 00:24:46,480
are not a security protection of any sort

00:24:46,480 --> 00:24:50,240
because with unprivileged namespaces,

00:24:50,240 --> 00:24:51,620
unprivileged user namespaces,

00:24:51,620 --> 00:24:53,410
anybody can create a network namespace,

00:24:53,410 --> 00:24:56,060
and anybody can set the sysctl to enabled.

00:24:56,060 --> 00:24:58,440
So if there's any sort of kernel exploit,

00:24:58,440 --> 00:24:59,613
anybody can exploit it.

00:25:02,840 --> 00:25:04,380
- Since you haven't but it's on the same slide here,

00:25:04,380 --> 00:25:06,190
I'd also make the argument that if you do

00:25:06,190 --> 00:25:09,520
have a sys-control that enables or disables

00:25:09,520 --> 00:25:13,910
MPTCP globally by the administrative interface,

00:25:13,910 --> 00:25:17,330
I'd make the argument that specifying a different

00:25:17,330 --> 00:25:20,940
IP protocol as an MPTCP might be less than ideal

00:25:20,940 --> 00:25:23,630
because your programming model would then

00:25:23,630 --> 00:25:26,760
create an environment where your socket call would fail

00:25:26,760 --> 00:25:30,010
as opposed to a socket option that would fail,

00:25:30,010 --> 00:25:31,900
the latter being potentially recoverable

00:25:31,900 --> 00:25:34,200
by an application, where the former would not.

00:25:35,300 --> 00:25:37,210
- On the other hand, we do have a

00:25:37,210 --> 00:25:39,840
cgroup hooks for a socket creation.

00:25:39,840 --> 00:25:41,880
And it's pretty easy to turn stuff off

00:25:41,880 --> 00:25:43,773
just by causing those to fail.

00:25:43,773 --> 00:25:45,190
- [Member of Audience] Yeah, like in (speaking faintly).

00:25:45,190 --> 00:25:48,450
- Yeah, another thing is if this is a module,

00:25:48,450 --> 00:25:50,410
you may want to prevent it from auto-loading

00:25:50,410 --> 00:25:52,500
based on somebody just asking for it.

00:25:52,500 --> 00:25:54,600
That might be a sufficient protection.

00:25:54,600 --> 00:25:56,840
- I also understand there's an SELinux hook

00:25:56,840 --> 00:25:58,520
for blocking stuff like that too,

00:25:58,520 --> 00:26:01,200
like we could get them at the SELinux hook as well.

00:26:01,200 --> 00:26:03,300
So cgroups, SELinux, there are a lot of ways

00:26:03,300 --> 00:26:05,800
to turn this thing off other than access control.

00:26:05,800 --> 00:26:08,600
And as he mentioned, a per net namespace sys-control

00:26:08,600 --> 00:26:10,230
is like a knob.

00:26:10,230 --> 00:26:12,003
It could be undone by anyone, so.

00:26:13,490 --> 00:26:14,690
- Good, thank you for...

00:26:20,350 --> 00:26:21,880
- From the security point of view,

00:26:21,880 --> 00:26:25,470
I think I'm not concerned of users

00:26:25,470 --> 00:26:27,650
actually creating the sockets.

00:26:27,650 --> 00:26:29,560
And as people just mentioned,

00:26:29,560 --> 00:26:31,120
there are a bunch of different ways

00:26:31,120 --> 00:26:34,350
to like switch it off, LSM and whatnot.

00:26:34,350 --> 00:26:37,450
I'm more concerned what the receive path

00:26:37,450 --> 00:26:39,220
inside the kernel will do.

00:26:39,220 --> 00:26:41,820
Whether they will go like any, I don't know,

00:26:41,820 --> 00:26:45,900
infinite loop, just parsing this TCP options and so on.

00:26:45,900 --> 00:26:50,900
So there, to turn that part off on emergencies,

00:26:51,380 --> 00:26:54,400
this need to be like carefully thought through.

00:26:54,400 --> 00:26:57,040
Like we had bugs in the forwarding sector for example.

00:26:57,040 --> 00:27:01,050
And this is changing TCP stacks.

00:27:01,050 --> 00:27:04,740
So this part of it, like for remote packet

00:27:04,740 --> 00:27:06,733
of desk type of attacks on MPTCP,

00:27:06,733 --> 00:27:08,210
this would be more concerning

00:27:08,210 --> 00:27:10,353
than userspace using this.

00:27:11,477 --> 00:27:13,580
- Right, okay, thank you.

00:27:13,580 --> 00:27:16,570
So this is all because on Multipath TCP

00:27:16,570 --> 00:27:19,700
is known also because on Apple,

00:27:19,700 --> 00:27:21,590
there was a security issue,

00:27:21,590 --> 00:27:26,310
where people were able to jailbreak the phone

00:27:26,310 --> 00:27:29,100
by using MPTCP socket.

00:27:29,100 --> 00:27:30,793
So we would like not to have the same there

00:27:30,793 --> 00:27:34,520
because we would like to have MPTCP

00:27:34,520 --> 00:27:37,360
famous for the thing but that's a good point

00:27:37,360 --> 00:27:40,120
that we need to check it, to check that,

00:27:40,120 --> 00:27:42,237
then see, thank you.

00:27:43,590 --> 00:27:44,820
- [Dave] So to summarize, I think that

00:27:44,820 --> 00:27:47,540
because of the cgroup-SELinux angle,

00:27:47,540 --> 00:27:48,880
it actually does make sense to have

00:27:48,880 --> 00:27:52,093
the separate socket number, protocol number.

00:27:53,980 --> 00:27:56,630
Okay and then Alexei's point about

00:27:56,630 --> 00:28:00,883
making sure the receive path is very strictly audited.

00:28:03,450 --> 00:28:04,283
- Thank you.

00:28:08,880 --> 00:28:10,430
All right, good, let's move on.

00:28:11,850 --> 00:28:16,090
So because MPTCP is big and complex,

00:28:16,090 --> 00:28:18,270
it is important to raise the debugging.

00:28:18,270 --> 00:28:22,080
So MPTCP will have a collection of counters

00:28:22,080 --> 00:28:24,160
for diagnostic and debug purposes

00:28:24,160 --> 00:28:25,723
because it's easy to retrieve.

00:28:26,970 --> 00:28:29,570
But a per socket data will be shared

00:28:29,570 --> 00:28:32,347
via with userspace via sock_diag.

00:28:33,610 --> 00:28:34,800
What we already did is that

00:28:34,800 --> 00:28:39,800
we extended TCP ULP framework to enable diag for them.

00:28:41,640 --> 00:28:43,603
But we also have another question here.

00:28:44,961 --> 00:28:47,420
MPTCP is really close to TCP,

00:28:47,420 --> 00:28:50,040
and as you all know, there are already some counters

00:28:50,040 --> 00:28:53,020
that can be found in proc/net/tcp.

00:28:53,020 --> 00:28:54,660
We just want to know if we also

00:28:54,660 --> 00:28:56,470
have to go in that direction to create

00:28:56,470 --> 00:29:00,450
a new proc/net/mptcp that can maybe

00:29:00,450 --> 00:29:02,923
be useful for embedded devices.

00:29:04,150 --> 00:29:06,860
We don't know what would be,

00:29:06,860 --> 00:29:08,640
what's your view about that?

00:29:10,837 --> 00:29:12,501
- [Member of Audience] This was the disclosed stuff.

00:29:12,501 --> 00:29:13,334
- [Member of Audience] This was disclosed

00:29:13,334 --> 00:29:16,090
on MedDev last week by Florian.

00:29:16,090 --> 00:29:16,923
- Oh.

00:29:16,923 --> 00:29:19,380
- So I think Florian already asked these questions.

00:29:19,380 --> 00:29:21,690
So you can-- - Okay.

00:29:21,690 --> 00:29:22,960
But I think the question that he had

00:29:22,960 --> 00:29:25,213
was more about the mid counters.

00:29:26,990 --> 00:29:30,220
While we could extend netstat for example,

00:29:30,220 --> 00:29:31,750
but here, it's more to know

00:29:31,750 --> 00:29:34,120
do we have to list all the connection?

00:29:34,120 --> 00:29:39,000
All the MPTCP connection like we can do with proc/net/tcp.

00:29:39,000 --> 00:29:42,081
- Oh, you mean the Artinet clinging interface, the SS?

00:29:42,081 --> 00:29:44,510
- [Member of Audience] No, it's the one in the old school,

00:29:44,510 --> 00:29:49,353
who asked that TCP, which is the all the open sockets.

00:29:49,353 --> 00:29:50,663
- Procfs.

00:29:50,663 --> 00:29:51,753
- [Member of Audience] Procfs, yeah.

00:29:51,753 --> 00:29:53,537
- Yeah, so we don't want that, right?

00:29:53,537 --> 00:29:56,750
- Cool, less work for us, thank you.

00:29:56,750 --> 00:29:59,085
- [Dave] If you want SS to be able to find,

00:29:59,085 --> 00:30:00,945
then put a Netlink interface, though.

00:30:00,945 --> 00:30:01,778
- [Mat] Yes.

00:30:01,778 --> 00:30:06,340
- Yes, and that's what we extended in ULP.

00:30:06,340 --> 00:30:08,233
KTLS here is already using it.

00:30:09,496 --> 00:30:11,572
- [Dave] Just say, we have 15 more minutes.

00:30:11,572 --> 00:30:12,870
- All right, thank you.

00:30:12,870 --> 00:30:15,110
So let's quickly move on.

00:30:15,110 --> 00:30:18,170
The tests, we have some kernel self-tests.

00:30:18,170 --> 00:30:19,940
They were easy to implement.

00:30:19,940 --> 00:30:22,070
We are testing a bunch of thing

00:30:22,070 --> 00:30:26,350
like connection between different circuits, MPTCP to MPTCP.

00:30:26,350 --> 00:30:28,350
Then we check that the fallback is correctly

00:30:28,350 --> 00:30:33,350
working with MPTCP to TCP and the opposite.

00:30:33,400 --> 00:30:35,220
And we test that in various condition

00:30:35,220 --> 00:30:37,750
including packet losses, reordering variation,

00:30:37,750 --> 00:30:40,110
networking, routing, and et cetera.

00:30:40,110 --> 00:30:43,060
But an important point is that we would like also

00:30:43,060 --> 00:30:46,190
to add MPTCP support to Packetdrill.

00:30:46,190 --> 00:30:48,670
It is more a backbone project.

00:30:48,670 --> 00:30:51,550
We are not actively working on that.

00:30:51,550 --> 00:30:54,960
But because Packetdrill is used to test

00:30:54,960 --> 00:30:57,680
most of the thing related to TCP and others,

00:30:57,680 --> 00:30:59,680
we would like to do the same with MPTCP.

00:31:01,560 --> 00:31:03,940
Also just a note that an existing,

00:31:03,940 --> 00:31:06,310
out-of-tree Packetdrill already exists

00:31:06,310 --> 00:31:10,000
with MPTCP support like we have with the Linux kernel.

00:31:10,000 --> 00:31:12,690
But this is old, based on an old version

00:31:12,690 --> 00:31:14,010
of Packetdrill and limited.

00:31:14,010 --> 00:31:16,210
So we need to work on that

00:31:16,210 --> 00:31:20,190
but if you don't know what to do this weekend, feel free.

00:31:20,190 --> 00:31:22,923
You can also have a look at that, and Mat.

00:31:27,670 --> 00:31:31,823
- So in deciding what we wanna support first,

00:31:33,160 --> 00:31:34,780
we took a look at the sort of

00:31:34,780 --> 00:31:37,750
the asymmetry and the code we need

00:31:37,750 --> 00:31:41,590
between supporting the server of an MPTCP connection

00:31:41,590 --> 00:31:44,110
and a device like a smart phone.

00:31:44,110 --> 00:31:48,730
And what we see is that in terms of the code

00:31:48,730 --> 00:31:50,880
that what you need to make the server side

00:31:50,880 --> 00:31:53,740
work is pretty much a subset of what you need

00:31:53,740 --> 00:31:54,640
on the client side.

00:31:54,640 --> 00:31:58,920
So on the client here, you've got,

00:31:58,920 --> 00:32:01,020
that's where you have the multiple interfaces.

00:32:01,020 --> 00:32:03,360
That's where you need to make decisions about

00:32:03,360 --> 00:32:05,260
where am I, more difficult decisions

00:32:05,260 --> 00:32:07,040
about where do I send something?

00:32:07,040 --> 00:32:12,040
When do I choose to open a new TCP subflow?

00:32:13,070 --> 00:32:16,300
And so since we have to implement

00:32:16,300 --> 00:32:18,283
all the server stuff first anyway,

00:32:18,283 --> 00:32:20,370
what makes sense to do is then

00:32:21,560 --> 00:32:24,850
upstream that smaller set of code to reveal,

00:32:24,850 --> 00:32:27,190
get it out, get it in use,

00:32:27,190 --> 00:32:29,300
work on fixing things up.

00:32:29,300 --> 00:32:32,423
And go from there.

00:32:35,690 --> 00:32:39,950
So in terms of talking about what we plan to upstream,

00:32:39,950 --> 00:32:41,040
we also wanted to point out that

00:32:41,040 --> 00:32:44,020
we do have, that the folks on our team

00:32:44,020 --> 00:32:47,367
have been upstreaming a few small things already.

00:32:47,367 --> 00:32:50,030
The SKB extensions.

00:32:50,030 --> 00:32:53,320
What we needed in Multipath TCP is that

00:32:53,320 --> 00:32:55,070
there are like the DSS mappings

00:32:55,070 --> 00:32:59,320
that are pretty closely coupled to the payload.

00:32:59,320 --> 00:33:02,480
And we just couldn't add everything

00:33:02,480 --> 00:33:04,780
we needed to struct sk_buff because that would

00:33:05,750 --> 00:33:06,830
increase the size quite a bit.

00:33:06,830 --> 00:33:10,573
So Florian Westphal added.

00:33:12,040 --> 00:33:14,730
So he took away the sp and nf_bridge pointers

00:33:14,730 --> 00:33:17,593
out of struct sk_buff, added one pointer back in

00:33:17,593 --> 00:33:20,763
with a couple of bits to say whether it's in use.

00:33:22,659 --> 00:33:26,200
And that is able to be used for features

00:33:26,200 --> 00:33:29,360
that occasionally, need to add something

00:33:29,360 --> 00:33:32,160
to the sk_buff structure but doesn't need

00:33:32,160 --> 00:33:35,050
to be there all the time, bloating the structure up.

00:33:35,050 --> 00:33:36,650
And so this is suitable for things

00:33:36,650 --> 00:33:38,600
that like us, don't fit there,

00:33:38,600 --> 00:33:40,870
but justify the extra overhead

00:33:40,870 --> 00:33:44,490
but it's also not the home for everything

00:33:44,490 --> 00:33:46,320
you ever dreamed of adding to sk_buff

00:33:46,320 --> 00:33:48,240
but David wouldn't merge.

00:33:48,240 --> 00:33:53,240
It's still a selected process to make sure that it fits.

00:33:53,784 --> 00:33:55,810
Another thing we've upstreamed is the

00:33:55,810 --> 00:33:58,540
like the soc_diag support for SS

00:33:58,540 --> 00:34:01,720
to tie that into the ULP infrastructure

00:34:01,720 --> 00:34:05,560
so that we could use it and like kTLS could use it too.

00:34:05,560 --> 00:34:10,560
So as Matthieu mentioned earlier,

00:34:11,090 --> 00:34:15,390
we've had the goal to impact TCP as little as possible.

00:34:15,390 --> 00:34:17,870
This is a kinda current diff stat of

00:34:18,830 --> 00:34:21,600
where our prototype touches the TCP stack.

00:34:21,600 --> 00:34:23,910
And the longer lines there are the places,

00:34:23,910 --> 00:34:27,840
where we are parsing and writing TCP options

00:34:27,840 --> 00:34:31,283
but other than that, it kept it pretty minimal.

00:34:32,410 --> 00:34:34,863
And what those changes are specifically,

00:34:36,862 --> 00:34:41,862
so in ULP layer, so as part of kTLS getting merged,

00:34:42,490 --> 00:34:45,770
there is some generic infrastructure to say

00:34:45,770 --> 00:34:49,310
to set a TCP ULP option, where you can

00:34:49,310 --> 00:34:52,030
insert an upper, like ULP is upper layer protocol.

00:34:52,030 --> 00:34:55,370
You can do something on top of TCP within the kernel.

00:34:55,370 --> 00:34:57,770
And it's got a bunch of hooks that

00:34:59,170 --> 00:35:00,270
get called when they're needed.

00:35:00,270 --> 00:35:04,890
And since kTLS doesn't support listening sockets

00:35:04,890 --> 00:35:07,760
right now, we found this race condition

00:35:07,760 --> 00:35:09,050
and when you're cloning a socket,

00:35:09,050 --> 00:35:11,520
where sometimes the socket gets created,

00:35:11,520 --> 00:35:14,370
and then gets deleted right away.

00:35:14,370 --> 00:35:15,940
And so we just needed the hook

00:35:15,940 --> 00:35:20,940
to be able to not corrupt the icsk_ulp_data.

00:35:21,340 --> 00:35:22,173
- [Dave] All right, it's fine

00:35:22,173 --> 00:35:23,990
that you're mentioning kTLS 'cause I'm wondering

00:35:23,990 --> 00:35:28,797
if we can kTLS MPTCP sockets?

00:35:28,797 --> 00:35:29,630
- I got a slide on that.

00:35:29,630 --> 00:35:30,463
- [Dave] Oh, thank you.

00:35:32,840 --> 00:35:36,620
- So beyond that, we exported

00:35:36,620 --> 00:35:38,700
TCP send MSS and TCP push

00:35:38,700 --> 00:35:42,900
'cause the MPTCP needs that level of control in sending

00:35:42,900 --> 00:35:46,163
and TCP receive options need to be handed around.

00:35:48,350 --> 00:35:50,090
We found, so when we're using

00:35:51,730 --> 00:35:55,770
SKB extensions, if we allow those SKBs

00:35:55,770 --> 00:35:58,423
with extensions to be coalesced or collapsed,

00:35:59,410 --> 00:36:01,280
we lose our information we need.

00:36:01,280 --> 00:36:03,630
So just a little bit of logic to skip that

00:36:03,630 --> 00:36:06,443
for things within MPTCP payload.

00:36:08,390 --> 00:36:10,410
As I mentioned with the git-diff stat,

00:36:10,410 --> 00:36:13,010
we have to parse those options, write those options.

00:36:15,208 --> 00:36:17,490
We need a flag in tcp_sock to say hey,

00:36:17,490 --> 00:36:21,320
are you a sub MPTCP subflow in order

00:36:21,320 --> 00:36:24,263
to support some of this changed behavior?

00:36:27,427 --> 00:36:30,540
And TCP minisocks and minor subflows,

00:36:30,540 --> 00:36:33,510
when they're being joined to an existing connection,

00:36:33,510 --> 00:36:35,073
slightly different process.

00:36:36,410 --> 00:36:40,350
When SKB goes into TCP_data_queue

00:36:40,350 --> 00:36:42,190
to get reassembled and stuff,

00:36:42,190 --> 00:36:44,540
we need to check there

00:36:44,540 --> 00:36:49,400
and attach our SKB extension or for X.

00:36:49,400 --> 00:36:52,480
So X, without payload, can carry

00:36:52,480 --> 00:36:55,450
MPTCP options and of course,

00:36:55,450 --> 00:36:56,450
those don't get reassembled,

00:36:56,450 --> 00:36:58,700
so you gotta have a chance to look at that

00:36:58,700 --> 00:36:59,950
and do something with it.

00:37:01,300 --> 00:37:03,160
TCP options received, well,

00:37:03,160 --> 00:37:05,920
we've got a new variety of TCP options.

00:37:05,920 --> 00:37:10,750
We need to store those and as Matthieu mentioned,

00:37:10,750 --> 00:37:13,010
the subflow receive windows,

00:37:13,010 --> 00:37:14,520
that's not in that diff stat yet,

00:37:14,520 --> 00:37:16,070
'cause we haven't written that code yet

00:37:16,070 --> 00:37:21,070
but basically, all those parallel TCP connections

00:37:22,880 --> 00:37:27,600
that are part of one MPTCP session,

00:37:27,600 --> 00:37:29,920
all of those advertise the same receive window

00:37:29,920 --> 00:37:33,860
together in order to prevent Multipath TCP

00:37:33,860 --> 00:37:38,550
from taking over an unfair share of the bandwidth.

00:37:38,550 --> 00:37:41,870
So but that does mean

00:37:41,870 --> 00:37:43,730
we're maintaining that value differently,

00:37:43,730 --> 00:37:47,560
we're writing a different value into the TCP header.

00:37:47,560 --> 00:37:50,543
We need to have the code to do something different.

00:37:52,540 --> 00:37:56,160
So that is the scope of what we're thinking about

00:37:56,160 --> 00:37:57,670
for an initial merge.

00:37:57,670 --> 00:38:00,010
And we have a few minutes left

00:38:00,010 --> 00:38:02,540
for the more advanced features

00:38:04,040 --> 00:38:06,380
that we see coming next

00:38:06,380 --> 00:38:08,430
to support things beyond the server use case

00:38:08,430 --> 00:38:10,743
because those are real important too.

00:38:12,020 --> 00:38:14,610
So a couple of pieces of terminology.

00:38:14,610 --> 00:38:17,400
One is this idea of the Path Manager

00:38:17,400 --> 00:38:21,410
in Multipath TCP, that is the kinda

00:38:21,410 --> 00:38:26,410
component that decides we've got the ability

00:38:26,980 --> 00:38:30,460
to set up TCP connections over different interfaces.

00:38:30,460 --> 00:38:31,690
Which ones do we do?

00:38:31,690 --> 00:38:32,830
Which interfaces do we use

00:38:32,830 --> 00:38:33,800
and when do we use them?

00:38:33,800 --> 00:38:35,683
And that's the Path Manager's job.

00:38:37,640 --> 00:38:40,820
So this, we're defined the generic

00:38:40,820 --> 00:38:44,540
that Netlink API have a userspace daemon

00:38:44,540 --> 00:38:47,293
that can listen on that,

00:38:48,220 --> 00:38:50,350
gets the MPTCP information about

00:38:50,350 --> 00:38:52,250
what peer interfaces are available,

00:38:52,250 --> 00:38:54,510
which IP addresses are available

00:38:54,510 --> 00:38:55,983
on the peer to connect to.

00:38:57,780 --> 00:38:59,760
It knows what local interfaces are available

00:38:59,760 --> 00:39:02,390
and it can say, create new subflows,

00:39:02,390 --> 00:39:04,060
disconnect subflows, that kinda thing.

00:39:04,060 --> 00:39:08,670
And it can also, you can have all kinds of policy

00:39:08,670 --> 00:39:11,620
you can imagine for power situations

00:39:11,620 --> 00:39:16,620
or carriers having constraints, and things like that.

00:39:16,720 --> 00:39:18,370
And so we just thought userspace

00:39:18,370 --> 00:39:19,800
was a better place for that.

00:39:19,800 --> 00:39:22,420
So we have been working on this in parallel

00:39:22,420 --> 00:39:23,920
with our kernel code.

00:39:23,920 --> 00:39:26,860
We have an MPTCPD project that's

00:39:27,893 --> 00:39:30,653
we have an alpha release up on GitHub at that URL.

00:39:33,170 --> 00:39:37,320
Second piece of MPTCP specific functionality,

00:39:37,320 --> 00:39:38,430
a packet scheduler.

00:39:38,430 --> 00:39:41,620
So you have multiple subflows established.

00:39:41,620 --> 00:39:44,360
You need to think about, okay,

00:39:44,360 --> 00:39:46,100
each packet that's going out,

00:39:46,100 --> 00:39:48,510
each piece of data, where do I want it to go?

00:39:48,510 --> 00:39:49,980
Do I want it to go over cellular?

00:39:49,980 --> 00:39:51,090
Do I want it to go over Wi-Fi?

00:39:51,090 --> 00:39:54,433
Do I want it to go over the lowest latency, et cetera?

00:39:55,820 --> 00:39:59,200
And so, on the server side,

00:39:59,200 --> 00:40:01,390
as I have that previous illustration

00:40:01,390 --> 00:40:04,363
that showed like kinda have one interface there.

00:40:05,270 --> 00:40:06,960
It's a little simpler choice,

00:40:06,960 --> 00:40:09,810
we can kinda have a basic scheduler that

00:40:11,410 --> 00:40:14,520
pays attention to whether the other end,

00:40:14,520 --> 00:40:16,260
the peer has requested, okay,

00:40:16,260 --> 00:40:19,550
use prefer this connection over another one.

00:40:19,550 --> 00:40:23,600
So for example, it might set,

00:40:23,600 --> 00:40:25,380
there's this backup flag that gets signal

00:40:25,380 --> 00:40:27,300
back and forth with Multipath TCP,

00:40:27,300 --> 00:40:32,300
and it can say only send something over cellular

00:40:32,510 --> 00:40:35,300
if there's no Wi-Fi connection, something like that.

00:40:35,300 --> 00:40:38,590
So this is something I think,

00:40:38,590 --> 00:40:40,050
there's probably been like graduate student

00:40:40,050 --> 00:40:42,080
research papers on performance of

00:40:42,080 --> 00:40:43,600
different schedulers and things.

00:40:43,600 --> 00:40:44,990
The out-of-tree implementation

00:40:44,990 --> 00:40:46,653
uses kernel modules for this.

00:40:49,408 --> 00:40:53,010
EBPF may be an option for allowing people

00:40:53,010 --> 00:40:58,010
to insert custom, like carrier-specific requirements

00:40:58,360 --> 00:41:01,470
for scheduling and allowing them to configure

00:41:01,470 --> 00:41:03,713
that per connection or system-wide.

00:41:05,910 --> 00:41:08,723
David kinda already covered the cgroup thing.

00:41:08,723 --> 00:41:11,780
There is attachment points for bind and connect already.

00:41:11,780 --> 00:41:14,210
There's not one on the socket call.

00:41:14,210 --> 00:41:16,463
So by adding one on the socket call,

00:41:17,320 --> 00:41:20,580
you could run applications in one cgroup,

00:41:20,580 --> 00:41:22,677
have those default to MPTCP,

00:41:22,677 --> 00:41:25,730
and that in addition to the kind of scenario

00:41:25,730 --> 00:41:27,490
of having a knob to turn,

00:41:27,490 --> 00:41:29,960
you could also someone, who wanted to run

00:41:29,960 --> 00:41:32,510
an existing binary could make things default

00:41:32,510 --> 00:41:34,853
to MPTCP that aren't doing it already.

00:41:39,060 --> 00:41:40,520
Yeah, we kinda touched on this one,

00:41:40,520 --> 00:41:42,000
running out of time.

00:41:42,000 --> 00:41:43,400
There's this interesting thing you can do

00:41:43,400 --> 00:41:46,740
with Multipath TCP, this break before make scenario.

00:41:46,740 --> 00:41:50,050
You can have an MPTCP session with zero

00:41:50,050 --> 00:41:52,250
currently open subflows.

00:41:52,250 --> 00:41:56,550
There's kind of a separate timeout at the MPTCP level.

00:41:56,550 --> 00:41:57,730
So it gives you a chance,

00:41:57,730 --> 00:41:59,930
like if you're trying to switch access points,

00:41:59,930 --> 00:42:02,160
your subflow can close without sending

00:42:02,160 --> 00:42:05,860
an MPTCP data fin that says close my MPTCP session.

00:42:05,860 --> 00:42:07,720
So the subflow goes away.

00:42:07,720 --> 00:42:09,690
You take your one WN,

00:42:09,690 --> 00:42:11,150
you switch access points,

00:42:11,150 --> 00:42:13,180
bring that back up, you got a new IP address.

00:42:13,180 --> 00:42:15,990
You establish a new subflow over that

00:42:17,320 --> 00:42:18,930
with that by IP address.

00:42:18,930 --> 00:42:21,380
And I don't know, that's something

00:42:21,380 --> 00:42:24,140
we'd wanna gauge demand for before

00:42:25,240 --> 00:42:26,390
putting the work there.

00:42:27,720 --> 00:42:32,093
Kinda running out of time on socket options.

00:42:33,541 --> 00:42:35,920
There's some different ways we could handle things

00:42:35,920 --> 00:42:38,640
but basically, there's a lot of them

00:42:38,640 --> 00:42:41,070
that would interfere with how MPTCP works,

00:42:41,070 --> 00:42:43,960
whether in option space or in the timing

00:42:43,960 --> 00:42:45,360
of when things get sent.

00:42:45,360 --> 00:42:47,890
So feel like we need to be careful there.

00:42:47,890 --> 00:42:50,640
Probably white-list certain options

00:42:50,640 --> 00:42:53,270
and let the MPTCP layer kinda mediate that

00:42:53,270 --> 00:42:55,440
and figure out what to do,

00:42:55,440 --> 00:42:59,143
what to skip, and since David asked about kernel TLS.

00:43:01,100 --> 00:43:05,290
So as we mentioned before,

00:43:05,290 --> 00:43:07,810
kernel TLS uses ULP,

00:43:07,810 --> 00:43:10,870
and an MPTCP socket is not a TCP socket.

00:43:10,870 --> 00:43:14,070
It doesn't have ULP, and even if it did,

00:43:14,070 --> 00:43:15,510
the hooks that you would insert

00:43:15,510 --> 00:43:18,100
at the MPTCP layer would need to do different stuff.

00:43:18,100 --> 00:43:18,933
- [Dave] Right.

00:43:18,933 --> 00:43:23,933
- So we, while we try to make MPTCP socket work

00:43:24,040 --> 00:43:26,570
as much like a TCP socket is possible,

00:43:26,570 --> 00:43:28,860
it would take extra work to do kTLS.

00:43:28,860 --> 00:43:33,860
And the things to think about with kTLS

00:43:34,610 --> 00:43:37,380
is that when you're sending on multiple subflows,

00:43:37,380 --> 00:43:41,540
that means like certain bytes from a TLS record

00:43:41,540 --> 00:43:42,750
might be on one interface,

00:43:42,750 --> 00:43:44,250
and certain bytes might be on another.

00:43:44,250 --> 00:43:47,440
And that doesn't seem to play well

00:43:47,440 --> 00:43:48,790
with hardware acceleration.

00:43:49,810 --> 00:43:52,930
And the other thing is that the DSS mappings

00:43:52,930 --> 00:43:55,520
that we're inserting in the TCP option headers

00:43:55,520 --> 00:43:57,690
assume that they have very specific knowledge

00:43:57,690 --> 00:43:59,930
of the sequence numbers of the data

00:43:59,930 --> 00:44:02,550
that's in that socket buffer,

00:44:02,550 --> 00:44:04,390
and that get received on the other side.

00:44:04,390 --> 00:44:07,960
And so if you have a low-level hardware accelerator,

00:44:07,960 --> 00:44:10,990
inserting TLS record delimiters into the stream

00:44:10,990 --> 00:44:12,867
and crypto padding and messing with

00:44:12,867 --> 00:44:14,373
the sequence numbers that,

00:44:15,240 --> 00:44:17,300
that's not gonna work out all that well.

00:44:17,300 --> 00:44:21,990
So looking at it, if you do the software TLS.

00:44:21,990 --> 00:44:22,830
- [Dave] Yes, I know.

00:44:22,830 --> 00:44:26,770
- Up on the stream, the application stream,

00:44:26,770 --> 00:44:29,350
before it gets touched by MPTCP

00:44:29,350 --> 00:44:31,220
and split across subflows,

00:44:31,220 --> 00:44:34,040
and accordingly, also on the receive side,

00:44:34,040 --> 00:44:37,140
you do the reassembly, and then feed that

00:44:37,140 --> 00:44:40,200
into the TLS infrastructure then that,

00:44:40,200 --> 00:44:41,880
that seems workable, so.

00:44:41,880 --> 00:44:42,713
- [Dave] Cool.

00:44:44,310 --> 00:44:46,803
- So that is what we've got.

00:44:48,070 --> 00:44:50,560
I think we're out of time for questions but--

00:44:50,560 --> 00:44:55,393
- Yeah, I'll allow one question, okay.

00:44:57,260 --> 00:44:58,353
She wins the lottery.

00:45:00,800 --> 00:45:03,730
- So there've been a lot of studies published

00:45:03,730 --> 00:45:06,610
that show MPTCP doesn't do well

00:45:06,610 --> 00:45:09,010
in cast-like scenarios,

00:45:09,010 --> 00:45:12,243
where you have many-to-one communication patterns?

00:45:15,310 --> 00:45:17,470
Has that issue been fixed already?

00:45:17,470 --> 00:45:19,546
Or is it on the roadmap?

00:45:19,546 --> 00:45:22,450
- I don't know, have you encountered that much, Matthieu?

00:45:22,450 --> 00:45:24,360
- [Matthieu] No, sorry.

00:45:24,360 --> 00:45:26,980
- [Lady] So these all coalesced in cast issues

00:45:26,980 --> 00:45:28,620
where let's say for example,

00:45:28,620 --> 00:45:31,120
a cellular is receiving simultaneous,

00:45:31,120 --> 00:45:33,890
a lot of connections from different clients.

00:45:33,890 --> 00:45:37,220
In those scenarios, MPTCP doesn't do so well

00:45:37,220 --> 00:45:39,470
because you have different subflows,

00:45:39,470 --> 00:45:41,280
where and each of the subflows are doing

00:45:41,280 --> 00:45:42,803
their own congestion control.

00:45:44,930 --> 00:45:47,141
- [Matthieu] Yeah, I think it's maybe better to--

00:45:47,141 --> 00:45:48,164
- Sure. - To go over that later.

00:45:48,164 --> 00:45:50,520
Because it might be linked to the current implementation.

00:45:50,520 --> 00:45:54,090
- Yeah, the degree to which I'm familiar with that,

00:45:54,090 --> 00:45:57,800
there has been research on MPTCP-specific connection,

00:45:57,800 --> 00:46:02,800
oh sorry, congestion options for the Linux kernel

00:46:03,530 --> 00:46:06,497
but we haven't talked about that being in scope yet.

00:46:06,497 --> 00:46:08,210
And I mean there's a lot of things

00:46:08,210 --> 00:46:10,180
I couldn't get to on that advanced feature list

00:46:10,180 --> 00:46:12,560
like zero copy and stuff like that,

00:46:12,560 --> 00:46:16,540
but anything that anyone's concerned about,

00:46:16,540 --> 00:46:18,260
questions like that, we have our

00:46:18,260 --> 00:46:21,620
mailing list here, mptcp@lists.01.org,

00:46:21,620 --> 00:46:24,440
and you can find us and ask those questions.

00:46:24,440 --> 00:46:27,730
And we also that the paper for this session

00:46:27,730 --> 00:46:30,953
is on the conference website with a bunch more details too.

00:46:31,990 --> 00:46:33,200
So thank you.

00:46:33,200 --> 00:46:34,440
- [Dave] Thank you very much.

00:46:34,440 --> 00:46:37,633

YouTube URL: https://www.youtube.com/watch?v=Y64n_R14GtI


