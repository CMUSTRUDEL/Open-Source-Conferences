Title: LPC2019 - BPF - MC
Publication date: 2019-11-18
Playlist: LPC2019 - MicroConferences
Description: 
	BPF - MC
Captions: 
	00:00:00,030 --> 00:00:04,950
so let's get started welcome to the PPF

00:00:02,129 --> 00:00:07,230
micro conference it's great to see so

00:00:04,950 --> 00:00:09,150
many people here we have a tight

00:00:07,230 --> 00:00:13,620
schedule so many things to talk about

00:00:09,150 --> 00:00:15,080
and every slot has roughly 20 minutes so

00:00:13,620 --> 00:00:18,539
after that you would need to make a

00:00:15,080 --> 00:00:21,090
heart break depending on how the

00:00:18,539 --> 00:00:24,590
discussion goes but we would like to

00:00:21,090 --> 00:00:28,410
cover as much as possible there are

00:00:24,590 --> 00:00:32,009
three speaker gifts that we can hand out

00:00:28,410 --> 00:00:33,750
and we decided we'll hand out this

00:00:32,009 --> 00:00:36,920
bigger gifts to those slots that have

00:00:33,750 --> 00:00:39,480
the best discussions because this is

00:00:36,920 --> 00:00:43,020
because it's it's about discussion to

00:00:39,480 --> 00:00:46,410
move things forward to make progress for

00:00:43,020 --> 00:00:50,910
them for upstreaming I'll code and you

00:00:46,410 --> 00:00:53,250
know and one more thing there's an ephah

00:00:50,910 --> 00:00:58,770
pet so I would like to encourage

00:00:53,250 --> 00:01:02,640
everyone to fill it in the URL this

00:00:58,770 --> 00:01:08,390
light I will update it here it's like if

00:01:02,640 --> 00:01:14,310
your pet or net slash slash P slash LPC

00:01:08,390 --> 00:01:16,259
2019 underscore and then there's BPF so

00:01:14,310 --> 00:01:19,380
that was from the previous micro

00:01:16,259 --> 00:01:21,960
conference so it would be great if

00:01:19,380 --> 00:01:24,210
everybody is helping out filling in the

00:01:21,960 --> 00:01:25,740
if a pet and with that said I don't want

00:01:24,210 --> 00:01:37,590
to waste any further time and give this

00:01:25,740 --> 00:01:40,439
lot to Andre thank you hi my name is

00:01:37,590 --> 00:01:42,420
Andy I'm working at Facebook and today

00:01:40,439 --> 00:01:45,930
we'll be talking about some of the

00:01:42,420 --> 00:01:49,079
ongoing and huge improvements to BPF

00:01:45,930 --> 00:01:50,490
developer experience in general so i'll

00:01:49,079 --> 00:01:52,079
start briefly like describing the

00:01:50,490 --> 00:01:53,790
problem that we are trying to solve

00:01:52,079 --> 00:01:56,040
currently at Facebook we have quite a

00:01:53,790 --> 00:01:58,649
lot of applications that use BPF usually

00:01:56,040 --> 00:02:00,899
they are done as a long-running daemons

00:01:58,649 --> 00:02:02,930
deployed either to the entire fleet or

00:02:00,899 --> 00:02:05,310
like big portions of the fleet so

00:02:02,930 --> 00:02:07,560
divided development BPL development is

00:02:05,310 --> 00:02:10,349
done it's you write the C code for VP

00:02:07,560 --> 00:02:14,010
our program then that C code by some

00:02:10,349 --> 00:02:16,530
means embedded into C or C++ usually

00:02:14,010 --> 00:02:18,930
application has a string right so like

00:02:16,530 --> 00:02:21,240
we have C code in C code as a string

00:02:18,930 --> 00:02:24,000
then that application gets packaged

00:02:21,240 --> 00:02:26,670
together with li BCC which embed clam

00:02:24,000 --> 00:02:28,620
LLVM together and that is deploy to data

00:02:26,670 --> 00:02:31,710
center then in data center what happens

00:02:28,620 --> 00:02:36,050
application start it uses its embedded

00:02:31,710 --> 00:02:40,110
Clank passes to its embedded BPF C code

00:02:36,050 --> 00:02:42,720
it uses system provided kernel headers

00:02:40,110 --> 00:02:46,130
and compiles all that together into an

00:02:42,720 --> 00:02:48,870
object file demarcated as BPF dot o and

00:02:46,130 --> 00:02:52,350
that object file is injected into the

00:02:48,870 --> 00:02:55,650
kernel so pretty much every single part

00:02:52,350 --> 00:02:59,010
in that red rectangle is problematic so

00:02:55,650 --> 00:03:02,340
first of all dependency on system kernel

00:02:59,010 --> 00:03:04,380
kernel headers it's a problem to keep it

00:03:02,340 --> 00:03:06,810
in sync it's a problem sometimes to just

00:03:04,380 --> 00:03:08,430
like deploy it for example if you have a

00:03:06,810 --> 00:03:10,739
custom kernel that you want to test out

00:03:08,430 --> 00:03:12,900
on a few machines like you usually won't

00:03:10,739 --> 00:03:15,660
have instinct kernels and then kind of

00:03:12,900 --> 00:03:16,980
headers get out of things like you you

00:03:15,660 --> 00:03:19,459
just get essentially data corruption

00:03:16,980 --> 00:03:22,410
like without sometimes knowing that

00:03:19,459 --> 00:03:25,590
second of all LLVM clang dependency is

00:03:22,410 --> 00:03:28,019
heavy both in terms of size and in terms

00:03:25,590 --> 00:03:30,780
of like startup resource usage so that

00:03:28,019 --> 00:03:34,680
causes outages sometimes due to like

00:03:30,780 --> 00:03:37,140
constraint machines and overall like

00:03:34,680 --> 00:03:39,630
this also causes the like problematic

00:03:37,140 --> 00:03:41,519
development cycle where you get vpf

00:03:39,630 --> 00:03:44,549
compilation errors in runtime just

00:03:41,519 --> 00:03:46,769
because you compile it in run time so we

00:03:44,549 --> 00:03:48,570
set out to solve this problem and the

00:03:46,769 --> 00:03:50,459
solution will be proposed this BPF core

00:03:48,570 --> 00:03:53,340
which is compiled stands for compile

00:03:50,459 --> 00:03:55,620
ones run everywhere and it because

00:03:53,340 --> 00:03:57,390
there's a few pieces some of them are

00:03:55,620 --> 00:03:59,940
done some of them are still in progress

00:03:57,390 --> 00:04:02,400
so instead of depending on system kernel

00:03:59,940 --> 00:04:04,650
headers we say that kernel should be

00:04:02,400 --> 00:04:07,709
self describing using btf and then we

00:04:04,650 --> 00:04:10,260
can take this BEF and generate C header

00:04:07,709 --> 00:04:13,709
which we do not usually BM Linux dot H

00:04:10,260 --> 00:04:15,840
which contains all the kernel structures

00:04:13,709 --> 00:04:17,700
and types including those that are

00:04:15,840 --> 00:04:20,760
internal to the kernel and not usually

00:04:17,700 --> 00:04:23,910
expose through the what kernel Heather's

00:04:20,760 --> 00:04:26,010
packages then instead of relying on LLVM

00:04:23,910 --> 00:04:27,570
and clang key in runtime you will pre

00:04:26,010 --> 00:04:29,310
compile the program

00:04:27,570 --> 00:04:30,630
that's not so simple so like you also

00:04:29,310 --> 00:04:32,490
need to record some relocation

00:04:30,630 --> 00:04:35,220
information to be able to ingest your

00:04:32,490 --> 00:04:38,370
program to specific kernel that program

00:04:35,220 --> 00:04:40,320
will be deployed to and well of course

00:04:38,370 --> 00:04:41,880
like by pre compiling you'll you already

00:04:40,320 --> 00:04:44,340
get like compilation errors in and like

00:04:41,880 --> 00:04:47,040
more natural complexion cycle but also

00:04:44,340 --> 00:04:49,620
dependency on just btf to validate that

00:04:47,040 --> 00:04:52,290
like your program is valid is valuable

00:04:49,620 --> 00:04:53,850
in that like you can pre validate that

00:04:52,290 --> 00:04:55,440
your program at least like the field

00:04:53,850 --> 00:04:57,990
excesses that you have in your program

00:04:55,440 --> 00:05:02,070
will match like the set of kernels that

00:04:57,990 --> 00:05:04,590
you care about so the first part is more

00:05:02,070 --> 00:05:06,510
or less done it's a kernel PDF you can

00:05:04,590 --> 00:05:09,030
enable it today was config debugging for

00:05:06,510 --> 00:05:14,040
BGF you need a pretty recent pothole

00:05:09,030 --> 00:05:16,140
1.13 or newer what you will get is bef

00:05:14,040 --> 00:05:18,120
information which is duplicated which is

00:05:16,140 --> 00:05:21,390
small which is embedded into the kernel

00:05:18,120 --> 00:05:23,730
image you can get it from Sisyphus with

00:05:21,390 --> 00:05:25,650
like says Carol BT FDM Linux you can see

00:05:23,730 --> 00:05:26,850
that it's roughly 2.2 megabytes

00:05:25,650 --> 00:05:30,030
depending on the configuration of your

00:05:26,850 --> 00:05:32,280
kernel as I said it'll cause all the

00:05:30,030 --> 00:05:34,770
types so you can use BPF tool to dump

00:05:32,280 --> 00:05:36,150
like one relatively big header with all

00:05:34,770 --> 00:05:38,790
the types which you can just include

00:05:36,150 --> 00:05:42,060
into your VP of program without any

00:05:38,790 --> 00:05:43,890
other system kernel header and it will

00:05:42,060 --> 00:05:47,400
just compile it will have tasks tracked

00:05:43,890 --> 00:05:48,960
SK buff whatever you need and it's not

00:05:47,400 --> 00:05:51,870
ideal there was some problems like

00:05:48,960 --> 00:05:53,880
macros right like bt f bt f and like

00:05:51,870 --> 00:05:56,580
dwarf to some extent doesn't encode

00:05:53,880 --> 00:05:57,840
define so some macro cysts will be

00:05:56,580 --> 00:06:00,770
available of course so that's the

00:05:57,840 --> 00:06:03,510
problem which we need to solve somehow

00:06:00,770 --> 00:06:06,630
the part that's also done was like field

00:06:03,510 --> 00:06:08,700
so essentially beyond btf BPF core

00:06:06,630 --> 00:06:11,490
consists of two parts first one is

00:06:08,700 --> 00:06:12,960
relocating fields because the problem is

00:06:11,490 --> 00:06:16,710
the lucky when you do introspection of

00:06:12,960 --> 00:06:18,600
the kernel structures if you will refer

00:06:16,710 --> 00:06:20,430
to field by name but like the actual

00:06:18,600 --> 00:06:21,840
memory layout changes between different

00:06:20,430 --> 00:06:24,180
kernel versions and kernel

00:06:21,840 --> 00:06:26,570
configurations so you cannot really know

00:06:24,180 --> 00:06:28,800
the offset beforehand so we will record

00:06:26,570 --> 00:06:30,930
like int and essentially field

00:06:28,800 --> 00:06:32,550
relocation where we will record like

00:06:30,930 --> 00:06:34,380
which type and which fields you want to

00:06:32,550 --> 00:06:36,390
access and then likely BPF will use

00:06:34,380 --> 00:06:38,400
again kernel be kiev on the target

00:06:36,390 --> 00:06:40,980
machine and the recorded recorded

00:06:38,400 --> 00:06:42,810
relocation to adjust your program

00:06:40,980 --> 00:06:45,270
just rights for the lucky will load the

00:06:42,810 --> 00:06:48,870
correct pieces of memory using usually

00:06:45,270 --> 00:06:51,090
BP appropriate so the part that's not

00:06:48,870 --> 00:06:52,890
done and is kind of up to discussion is

00:06:51,090 --> 00:06:55,650
the condition of relocation so if you

00:06:52,890 --> 00:06:58,290
look at the previous example we read IO

00:06:55,650 --> 00:06:59,640
AC read butts right and the problem is

00:06:58,290 --> 00:07:01,380
that like some kernels that are not

00:06:59,640 --> 00:07:03,870
compiled with configure your task

00:07:01,380 --> 00:07:06,780
accounting won't have this struct at all

00:07:03,870 --> 00:07:08,850
right so it's impossible to relocate so

00:07:06,780 --> 00:07:11,040
if you want to build the DPF program and

00:07:08,850 --> 00:07:13,560
compile it once and run it on kernels

00:07:11,040 --> 00:07:15,060
that both have IO accounting and not you

00:07:13,560 --> 00:07:18,360
will need to do some more and like what

00:07:15,060 --> 00:07:21,750
we proposed is to support external

00:07:18,360 --> 00:07:24,240
variables like some of those will be

00:07:21,750 --> 00:07:26,400
provided by Lee PPF so like config keys

00:07:24,240 --> 00:07:28,080
Linux version and stuff like that and

00:07:26,400 --> 00:07:30,420
then in your code you will just use your

00:07:28,080 --> 00:07:32,460
normal C logic like if something is

00:07:30,420 --> 00:07:34,340
enabled then you can try to access field

00:07:32,460 --> 00:07:38,100
otherwise you have to have some fallback

00:07:34,340 --> 00:07:39,450
like and there are the thing that's up

00:07:38,100 --> 00:07:41,030
to discussion is like two ways to

00:07:39,450 --> 00:07:43,680
implement is your own already

00:07:41,030 --> 00:07:47,250
implemented experimental support in

00:07:43,680 --> 00:07:50,130
clonk the way that you do it you put the

00:07:47,250 --> 00:07:53,640
external variable declaration in a

00:07:50,130 --> 00:07:55,590
special section and clank will recognize

00:07:53,640 --> 00:07:57,210
that and we write your instructions in

00:07:55,590 --> 00:07:59,160
such a way that the instruction that

00:07:57,210 --> 00:08:01,350
actually tried to load the value of the

00:07:59,160 --> 00:08:04,350
X term variable will get it as an

00:08:01,350 --> 00:08:06,600
embedded instruction so it's easy for

00:08:04,350 --> 00:08:09,090
Libby PF to just replace that like

00:08:06,600 --> 00:08:10,800
embedded constant into like the actual

00:08:09,090 --> 00:08:13,860
value once we load it on the target

00:08:10,800 --> 00:08:15,120
machine the problem with that is that it

00:08:13,860 --> 00:08:16,890
only supports up to eight by the

00:08:15,120 --> 00:08:18,390
excesses of course because we don't have

00:08:16,890 --> 00:08:21,780
the instruction that has more than eight

00:08:18,390 --> 00:08:23,190
byte immediate constant so we are

00:08:21,780 --> 00:08:25,110
researching the possibility of

00:08:23,190 --> 00:08:29,310
supporting this more genetically where

00:08:25,110 --> 00:08:31,890
you can extern any type and still have

00:08:29,310 --> 00:08:33,750
the same behavior where like if some

00:08:31,890 --> 00:08:35,849
conditions don't apply you won't even

00:08:33,750 --> 00:08:37,620
run the code and verifier will actually

00:08:35,849 --> 00:08:39,990
recognize that and will not produce an

00:08:37,620 --> 00:08:41,310
error or anything like that the problem

00:08:39,990 --> 00:08:43,200
is that is that the instructions

00:08:41,310 --> 00:08:45,060
generated are more complicated as you

00:08:43,200 --> 00:08:48,510
can see on the right side you will get

00:08:45,060 --> 00:08:51,090
like first the address of the in this

00:08:48,510 --> 00:08:53,100
case my struct right look r1 will get my

00:08:51,090 --> 00:08:54,180
struct address which typically will be

00:08:53,100 --> 00:08:56,520
some

00:08:54,180 --> 00:08:58,500
map similar to global like similar how

00:08:56,520 --> 00:09:00,750
we do this with global data and then it

00:08:58,500 --> 00:09:02,940
will be referenced at pointer with some

00:09:00,750 --> 00:09:05,310
of sad potentially to get the actual

00:09:02,940 --> 00:09:08,220
value of the field inside this track so

00:09:05,310 --> 00:09:11,459
to support that well first of all like

00:09:08,220 --> 00:09:12,839
the idea is that we can get the PPF

00:09:11,459 --> 00:09:15,630
essential you can gather all those

00:09:12,839 --> 00:09:17,850
extras that like it it recognizes either

00:09:15,630 --> 00:09:20,430
as like provided by Li PB v PF or

00:09:17,850 --> 00:09:22,140
provided by the user space it can

00:09:20,430 --> 00:09:24,779
construct the another special internal

00:09:22,140 --> 00:09:28,050
map similar to global data but make it

00:09:24,779 --> 00:09:29,880
read-only for both user space and kernel

00:09:28,050 --> 00:09:31,800
space so like it just like initialized

00:09:29,880 --> 00:09:33,480
ones and never used and then we will

00:09:31,800 --> 00:09:36,240
have to teach verifier to recognize

00:09:33,480 --> 00:09:37,800
pointers to that map so that like it can

00:09:36,240 --> 00:09:39,959
track the constants essentially

00:09:37,800 --> 00:09:41,580
throughout the flow of the program with

00:09:39,959 --> 00:09:43,140
that hopefully like you'll be able to

00:09:41,580 --> 00:09:45,089
just say like oh if some condition

00:09:43,140 --> 00:09:47,730
doesn't apply just like never try to

00:09:45,089 --> 00:09:50,399
allocate like read some field which

00:09:47,730 --> 00:09:51,990
doesn't exist on this kernel and it

00:09:50,399 --> 00:09:53,760
won't even matter like what of that was

00:09:51,990 --> 00:09:59,459
there because we will never run this

00:09:53,760 --> 00:10:08,520
code anyone has any questions objections

00:09:59,459 --> 00:10:10,440
sure I don't think it's wrong yeah in my

00:10:08,520 --> 00:10:13,950
C code how would I check that a given

00:10:10,440 --> 00:10:15,930
structure has a field so you cannot

00:10:13,950 --> 00:10:17,430
check like that some kernel struct has

00:10:15,930 --> 00:10:19,470
the field well at least like we don't

00:10:17,430 --> 00:10:21,589
have a way to do this so this will be

00:10:19,470 --> 00:10:24,360
either based on Linux kernel version

00:10:21,589 --> 00:10:26,400
check because you just know that some

00:10:24,360 --> 00:10:28,920
versions don't have it or based on

00:10:26,400 --> 00:10:30,870
config as I showed in the example or it

00:10:28,920 --> 00:10:32,400
can be provided by user space like in

00:10:30,870 --> 00:10:34,440
this case right like the my strap can be

00:10:32,400 --> 00:10:36,029
like anything so you can have like

00:10:34,440 --> 00:10:37,620
different flags like run this feature on

00:10:36,029 --> 00:10:39,420
that feature depending on what user

00:10:37,620 --> 00:10:41,070
space knows about the environment so

00:10:39,420 --> 00:10:43,140
like even if it's some very complicated

00:10:41,070 --> 00:10:46,170
condition you can just like check it and

00:10:43,140 --> 00:10:47,910
just send it to your program I think

00:10:46,170 --> 00:10:50,279
it'll be very nice to have some sort of

00:10:47,910 --> 00:10:51,810
read this field from a structure and if

00:10:50,279 --> 00:10:57,810
it doesn't exist just get some default

00:10:51,810 --> 00:10:59,550
value like zero maybe we need to think

00:10:57,810 --> 00:11:01,529
about like whether it's possible to

00:10:59,550 --> 00:11:05,250
support like in a kind of standard to

00:11:01,529 --> 00:11:07,310
see way but I'm not sure like I need to

00:11:05,250 --> 00:11:09,889
think about this it

00:11:07,310 --> 00:11:14,300
might be possible with bgf but I need to

00:11:09,889 --> 00:11:16,490
think about details what what what do

00:11:14,300 --> 00:11:17,899
you think that good default value is I

00:11:16,490 --> 00:11:20,990
think you would specify it when you're

00:11:17,899 --> 00:11:22,579
reading the field around it just like

00:11:20,990 --> 00:11:23,959
when you read from a map if something is

00:11:22,579 --> 00:11:31,249
not present you can get a default value

00:11:23,959 --> 00:11:34,399
usually yeah so we're thinking about

00:11:31,249 --> 00:11:37,519
extending Clank to provide sort of like

00:11:34,399 --> 00:11:39,499
C++ runtime type information and sort of

00:11:37,519 --> 00:11:42,439
analysis where you can actually wear

00:11:39,499 --> 00:11:46,180
with it this type equal to type but it's

00:11:42,439 --> 00:11:51,350
in the category of extending C language

00:11:46,180 --> 00:11:56,689
which triggers the stream it's

00:11:51,350 --> 00:11:58,009
restricted expanded C possible again

00:11:56,689 --> 00:11:59,839
yeah which is why I said like with

00:11:58,009 --> 00:12:04,189
standard C I'm not sure like if you can

00:11:59,839 --> 00:12:07,999
do it but you should bring good ideas

00:12:04,189 --> 00:12:10,339
things yeah it looked like you already

00:12:07,999 --> 00:12:12,439
had a bit of a macro accessor to read it

00:12:10,339 --> 00:12:14,329
something well so the macro that I used

00:12:12,439 --> 00:12:17,509
in this example just like abstracts this

00:12:14,329 --> 00:12:18,829
long bill team preserve accessory index

00:12:17,509 --> 00:12:20,750
it doesn't do like much it's just like

00:12:18,829 --> 00:12:22,699
VP appropriate because I was I think you

00:12:20,750 --> 00:12:24,680
just got just add like comma zero to

00:12:22,699 --> 00:12:26,689
that macro it's like read this field if

00:12:24,680 --> 00:12:28,870
it doesn't exist return zero not so

00:12:26,689 --> 00:12:28,870
simple

00:12:36,440 --> 00:12:40,860
you can do you can do it twice and if

00:12:38,940 --> 00:12:42,720
you get a different values and also

00:12:40,860 --> 00:12:44,310
think about this like the valley we will

00:12:42,720 --> 00:12:46,740
had this problem when dealing with

00:12:44,310 --> 00:12:49,260
automatic detection of syscall errors

00:12:46,740 --> 00:12:51,240
with air nose and stuff because there

00:12:49,260 --> 00:12:53,430
are some system calls that return

00:12:51,240 --> 00:12:55,410
something in the entire universe of long

00:12:53,430 --> 00:12:59,070
the value of long and therefore we

00:12:55,410 --> 00:13:00,240
needed the a processor carry condition

00:12:59,070 --> 00:13:04,680
in order to indicate error or not

00:13:00,240 --> 00:13:06,480
because all bits are valid so one thing

00:13:04,680 --> 00:13:08,400
to this right like the value that like

00:13:06,480 --> 00:13:10,350
this default value it's not necessarily

00:13:08,400 --> 00:13:12,240
an integer or something like that the

00:13:10,350 --> 00:13:13,950
appropriate can read like arbitrary

00:13:12,240 --> 00:13:16,200
piece of memories so how would you

00:13:13,950 --> 00:13:17,850
specify the default it's like it becomes

00:13:16,200 --> 00:13:20,750
complicated right so if you read like an

00:13:17,850 --> 00:13:22,920
integer field sure if you read like some

00:13:20,750 --> 00:13:25,530
variable size that right yeah so maybe

00:13:22,920 --> 00:13:27,780
for more unusual fields you would need

00:13:25,530 --> 00:13:29,640
some sort of a field exists explicit

00:13:27,780 --> 00:13:31,410
condition but I think a lot of cases

00:13:29,640 --> 00:13:33,360
would be handled with just a return 0

00:13:31,410 --> 00:13:36,600
return just one my comments are this

00:13:33,360 --> 00:13:38,850
built-in for preserve access index is an

00:13:36,600 --> 00:13:40,620
offset it's not actual a lot it's only

00:13:38,850 --> 00:13:44,790
DOS it's it's only adjusting like

00:13:40,620 --> 00:13:48,030
constant from 5 into 6 there is no

00:13:44,790 --> 00:13:49,680
default father there may be you could

00:13:48,030 --> 00:13:51,300
always return the 0 and then if the

00:13:49,680 --> 00:13:54,330
opposite is 0 you know it doesn't exist

00:13:51,300 --> 00:13:56,310
I don't know well maybe a probe read

00:13:54,330 --> 00:13:58,710
always feels everything with 0 if you

00:13:56,310 --> 00:14:00,720
provide invalid pointer so I yeah I

00:13:58,710 --> 00:14:02,730
think I think we need to like table this

00:14:00,720 --> 00:14:07,020
discussion and like follow up after it

00:14:02,730 --> 00:14:14,940
because yeah we have some more stuff any

00:14:07,020 --> 00:14:16,830
other questions okay so but beyond core

00:14:14,940 --> 00:14:19,140
there are things that we can and should

00:14:16,830 --> 00:14:22,740
probably improve to make the life of the

00:14:19,140 --> 00:14:25,020
DPF developers if you have application

00:14:22,740 --> 00:14:26,490
developers easier and like you probably

00:14:25,020 --> 00:14:28,350
won't go through all of them but let's

00:14:26,490 --> 00:14:31,170
let's start with BTW i have defined maps

00:14:28,350 --> 00:14:33,210
so for people that like watch the DP our

00:14:31,170 --> 00:14:35,880
development recently they know that like

00:14:33,210 --> 00:14:37,830
we recently added a simple way and like

00:14:35,880 --> 00:14:41,220
simple alternative way to define the PF

00:14:37,830 --> 00:14:44,120
maps in a Dacula declarative way which

00:14:41,220 --> 00:14:47,280
is heavily reliant on vtf information

00:14:44,120 --> 00:14:48,070
and this can be extended further to

00:14:47,280 --> 00:14:50,950
handle

00:14:48,070 --> 00:14:52,540
more complicated cases still in a pretty

00:14:50,950 --> 00:14:54,610
nice and understandable way so just to

00:14:52,540 --> 00:14:57,730
give you an example on the last is like

00:14:54,610 --> 00:15:00,400
how you would do the PF map definition

00:14:57,730 --> 00:15:02,830
before like you you would like have

00:15:00,400 --> 00:15:05,380
their BPF map def you will feel few

00:15:02,830 --> 00:15:07,570
fields key size value size and all stuff

00:15:05,380 --> 00:15:09,190
and if you want to also capture the type

00:15:07,570 --> 00:15:12,610
information you will have to do the

00:15:09,190 --> 00:15:15,730
separate BPF annotate kb pair macro

00:15:12,610 --> 00:15:18,520
where you will have to match the map my

00:15:15,730 --> 00:15:20,950
map name was this an integer with struct

00:15:18,520 --> 00:15:22,620
and so on and if you get like it wrong

00:15:20,950 --> 00:15:26,320
or it gets out of sync

00:15:22,620 --> 00:15:28,390
nothing will crash nothing will cost

00:15:26,320 --> 00:15:31,150
compilation error it will just not work

00:15:28,390 --> 00:15:33,640
like the type information will won't

00:15:31,150 --> 00:15:36,370
work so the the way that we recently

00:15:33,640 --> 00:15:38,800
added is on the right right we use a

00:15:36,370 --> 00:15:40,990
very simple you int and type macro

00:15:38,800 --> 00:15:43,690
sister-like one-liners essentially just

00:15:40,990 --> 00:15:46,000
like hiding the pointer to a type where

00:15:43,690 --> 00:15:48,400
you say that it's essentially the map is

00:15:46,000 --> 00:15:51,670
a set of key value pairs type is hash

00:15:48,400 --> 00:15:53,860
max entries will be one the interesting

00:15:51,670 --> 00:15:55,990
part is type key and type value here you

00:15:53,860 --> 00:15:57,520
specify that the key is of type integer

00:15:55,990 --> 00:16:00,340
which automatically means that the key

00:15:57,520 --> 00:16:02,380
is of for byte size and it will never

00:16:00,340 --> 00:16:04,060
get out of things similar for the value

00:16:02,380 --> 00:16:05,860
where you provide somewhat custom my

00:16:04,060 --> 00:16:09,370
value right then you just put it into

00:16:05,860 --> 00:16:11,590
dot maps section so it's shorter it

00:16:09,370 --> 00:16:15,760
captures type information and it's

00:16:11,590 --> 00:16:17,500
harder to get it wrong but what about

00:16:15,760 --> 00:16:19,240
the more complicated map in map case for

00:16:17,500 --> 00:16:20,680
example right now libby PF doesn't allow

00:16:19,240 --> 00:16:23,260
you to do it declaratively you'll have

00:16:20,680 --> 00:16:27,010
to do it in code was quite a lot of

00:16:23,260 --> 00:16:28,360
boilerplate IP route to has its own

00:16:27,010 --> 00:16:31,090
slightly different format and the way

00:16:28,360 --> 00:16:33,910
that they do it is through few extra

00:16:31,090 --> 00:16:36,430
fields that they're BPF map definition

00:16:33,910 --> 00:16:39,490
struct has in this case is ID in there

00:16:36,430 --> 00:16:41,710
ID and inner index and ID and inner idea

00:16:39,490 --> 00:16:44,440
on inner and outer map should match and

00:16:41,710 --> 00:16:47,920
the inner index specifies like which

00:16:44,440 --> 00:16:50,140
slot this map is put into so let's think

00:16:47,920 --> 00:16:52,200
about like how similar stuff can be done

00:16:50,140 --> 00:16:56,170
with like bt f defined maps

00:16:52,200 --> 00:16:58,210
what about like if you define the struct

00:16:56,170 --> 00:17:00,040
that defines the inner map definition

00:16:58,210 --> 00:17:00,700
which looks exactly the same like as a

00:17:00,040 --> 00:17:03,250
No

00:17:00,700 --> 00:17:05,620
ah map and for the outer map it also

00:17:03,250 --> 00:17:09,250
looks exactly the same like a map except

00:17:05,620 --> 00:17:11,199
that you have a array of values of type

00:17:09,250 --> 00:17:12,970
where type is actually this inner map

00:17:11,199 --> 00:17:15,730
because that's what mapping map is right

00:17:12,970 --> 00:17:17,410
it's a collection of other maps and the

00:17:15,730 --> 00:17:19,420
extra thing is that like you actually

00:17:17,410 --> 00:17:21,520
have to initialize it right to be useful

00:17:19,420 --> 00:17:25,000
so you will just refer to it by a

00:17:21,520 --> 00:17:28,000
pointer like a normal C code internally

00:17:25,000 --> 00:17:29,830
that will be like some elf relocations

00:17:28,000 --> 00:17:32,650
and you BPF will do some post-processing

00:17:29,830 --> 00:17:36,220
other stuff but this should work at

00:17:32,650 --> 00:17:38,350
least it compiles I just just just to

00:17:36,220 --> 00:17:40,180
show like why IP route wise is it's not

00:17:38,350 --> 00:17:42,130
desirable is it like once you add more

00:17:40,180 --> 00:17:44,290
than one inner map like you start to

00:17:42,130 --> 00:17:46,270
keep like duplicating fields that have

00:17:44,290 --> 00:17:49,420
to be kept in sync and it just becomes

00:17:46,270 --> 00:17:51,700
like nightmare to maintain while with

00:17:49,420 --> 00:17:54,400
the BT I've defined why you would just

00:17:51,700 --> 00:17:57,850
like add another map and pointer to it

00:17:54,400 --> 00:17:59,770
which is pretty nice the other like

00:17:57,850 --> 00:18:02,800
complicated case is proc array where you

00:17:59,770 --> 00:18:04,930
want to fill in like separate programs

00:18:02,800 --> 00:18:08,350
into a slots of program and then do tail

00:18:04,930 --> 00:18:11,050
call right now the IP route 2 also

00:18:08,350 --> 00:18:13,210
allows it by having the convention where

00:18:11,050 --> 00:18:17,260
you have a ID and then like the section

00:18:13,210 --> 00:18:20,500
name is ID slash the slot and stuff like

00:18:17,260 --> 00:18:22,240
that and we can do similar stuff as to

00:18:20,500 --> 00:18:24,430
map mapping map where we just use

00:18:22,240 --> 00:18:27,520
essentially a pointer to a function

00:18:24,430 --> 00:18:29,950
which feels pretty natural and you also

00:18:27,520 --> 00:18:34,270
say that like the values is the array of

00:18:29,950 --> 00:18:37,210
function prototypes and you just fill in

00:18:34,270 --> 00:18:40,300
the pointers and like with the new versi

00:18:37,210 --> 00:18:42,280
syntax for map array initialization you

00:18:40,300 --> 00:18:44,230
can even like do holes right you can say

00:18:42,280 --> 00:18:46,480
like 0 equals that and then pan equals

00:18:44,230 --> 00:18:51,630
that and like not specify the tooth so

00:18:46,480 --> 00:18:51,630
now so what do you think about that

00:18:54,580 --> 00:18:59,050
so this works well if your functions are

00:18:57,700 --> 00:19:00,340
always static and your and it's all

00:18:59,050 --> 00:19:03,730
defined in your code but what if the

00:19:00,340 --> 00:19:05,680
tail call you want to jump to is dynamic

00:19:03,730 --> 00:19:07,120
well you will still be able to do

00:19:05,680 --> 00:19:08,890
everything programmatic ins right it's

00:19:07,120 --> 00:19:10,900
just like the clarity of like common

00:19:08,890 --> 00:19:12,700
cases should be easier because right now

00:19:10,900 --> 00:19:15,310
the mapping map and like prog array is

00:19:12,700 --> 00:19:17,830
kind of cumbersome too to initialize and

00:19:15,310 --> 00:19:20,020
also like one one benefit of the latter

00:19:17,830 --> 00:19:22,570
latter use case is that like if you want

00:19:20,020 --> 00:19:24,940
to reuse the same sub program in two

00:19:22,570 --> 00:19:27,430
different progress you can do it was the

00:19:24,940 --> 00:19:29,650
B key F defined way while you I assumed

00:19:27,430 --> 00:19:31,690
you cannot do it was the section name

00:19:29,650 --> 00:19:37,770
convention that we have right now in a

00:19:31,690 --> 00:19:37,770
gear out - is it right probably right I

00:19:37,890 --> 00:19:42,760
think the approach should also work like

00:19:41,230 --> 00:19:45,400
in the case of sodium like those IDs

00:19:42,760 --> 00:19:47,410
they are actually constants that are

00:19:45,400 --> 00:19:48,850
emitted from orchestration system so

00:19:47,410 --> 00:19:51,130
that you basically fill this in

00:19:48,850 --> 00:19:54,810
dynamically but it should also work like

00:19:51,130 --> 00:20:01,900
if we would define this as a macro those

00:19:54,810 --> 00:20:04,440
actual initializations not fully sure

00:20:01,900 --> 00:20:04,440
yet but

00:20:08,910 --> 00:20:14,010
I mean yeah so the question is like how

00:20:12,450 --> 00:20:16,500
we do our castration system put this

00:20:14,010 --> 00:20:20,160
information in there dynamically I mean

00:20:16,500 --> 00:20:22,080
like from from Oh both ways a

00:20:20,160 --> 00:20:24,270
declarative right so like it's just like

00:20:22,080 --> 00:20:26,910
it's the question of how to generate Oh

00:20:24,270 --> 00:20:29,130
like in this case you generate ID which

00:20:26,910 --> 00:20:33,660
is valid and in this case you have the

00:20:29,130 --> 00:20:35,820
actual code that you have to run yeah I

00:20:33,660 --> 00:20:39,720
mean we have to think about this in play

00:20:35,820 --> 00:20:41,490
was the cilium code a little bit yeah I

00:20:39,720 --> 00:20:44,070
agree I mean we would have to figure it

00:20:41,490 --> 00:20:48,180
out on the way I'm not fully sure yet

00:20:44,070 --> 00:20:49,830
like I guess it's a common well not so

00:20:48,180 --> 00:20:51,840
much program but like the map in map is

00:20:49,830 --> 00:20:53,340
a very common complaint from from people

00:20:51,840 --> 00:20:55,350
who had to use it like programmatically

00:20:53,340 --> 00:21:03,180
with an EVP I mean the map in that case

00:20:55,350 --> 00:21:05,100
should be it's good yeah okay so then

00:21:03,180 --> 00:21:07,020
the question also becomes we've already

00:21:05,100 --> 00:21:09,660
discussed this in the list but backwards

00:21:07,020 --> 00:21:13,110
compatibility with Ivy right - and I

00:21:09,660 --> 00:21:15,360
think your idea was lib PPF can detect

00:21:13,110 --> 00:21:17,760
whether or not the btf stuff then and

00:21:15,360 --> 00:21:20,790
expose a hook - first time I lied about

00:21:17,760 --> 00:21:21,840
- if we port that usually BPM and do it

00:21:20,790 --> 00:21:23,130
yeah so what when I initially

00:21:21,840 --> 00:21:25,440
implemented the beat you have to find

00:21:23,130 --> 00:21:28,110
maps I wanted to just ignore unknown

00:21:25,440 --> 00:21:31,290
fields and lad like user application if

00:21:28,110 --> 00:21:32,880
they want to process it we want it to be

00:21:31,290 --> 00:21:34,380
like more strict but like we can relax

00:21:32,880 --> 00:21:36,000
it right like with some option you can

00:21:34,380 --> 00:21:38,550
say like if you don't recognize it like

00:21:36,000 --> 00:21:40,140
take no one feels but I think you want

00:21:38,550 --> 00:21:43,050
to take it a little bit further and just

00:21:40,140 --> 00:21:44,910
like not loudly BPF process they btf and

00:21:43,050 --> 00:21:47,000
instead just like call some call back or

00:21:44,910 --> 00:21:52,500
let user do it am i right

00:21:47,000 --> 00:21:56,100
no sorry I think like if the btf is

00:21:52,500 --> 00:21:58,530
there that means you're already using a

00:21:56,100 --> 00:22:02,940
zoom that means you're already using the

00:21:58,530 --> 00:22:05,100
new format so we don't need like so

00:22:02,940 --> 00:22:06,390
that's fine just let leap you have to do

00:22:05,100 --> 00:22:09,660
its thing and load the whole thing okay

00:22:06,390 --> 00:22:11,430
but if there's but if it's not there and

00:22:09,660 --> 00:22:14,130
we're loading an old program that's been

00:22:11,430 --> 00:22:16,500
compiled without bgf information or like

00:22:14,130 --> 00:22:19,770
I'm using now if you're about to format

00:22:16,500 --> 00:22:21,870
IP right - need to be able to hook in

00:22:19,770 --> 00:22:22,640
and say I still want to use the lip API

00:22:21,870 --> 00:22:24,950
functions to

00:22:22,640 --> 00:22:27,620
the whole thing but then I want to be

00:22:24,950 --> 00:22:30,710
able to go in and programmatically fit

00:22:27,620 --> 00:22:33,890
on the structures with the map and map

00:22:30,710 --> 00:22:37,730
information and opinion with India and

00:22:33,890 --> 00:22:40,220
then so continue I'm correct right now

00:22:37,730 --> 00:22:42,860
the API like of the new BPF is split

00:22:40,220 --> 00:22:45,080
into two parts like opening all three

00:22:42,860 --> 00:22:47,990
actually opening loading and attaching

00:22:45,080 --> 00:22:50,480
right so between you open and load you

00:22:47,990 --> 00:22:51,920
can actually create Maps right so look

00:22:50,480 --> 00:22:53,720
you you should be able to do like your

00:22:51,920 --> 00:22:55,700
custom map loading just created

00:22:53,720 --> 00:22:56,960
programmatically right you you load it

00:22:55,700 --> 00:22:58,460
from your Alf you created

00:22:56,960 --> 00:23:00,170
programmatically you put it into BPF

00:22:58,460 --> 00:23:10,160
object and then you can continue with

00:23:00,170 --> 00:23:13,070
log would that work oh cool okay yeah

00:23:10,160 --> 00:23:16,970
well I it's also just I don't want to

00:23:13,070 --> 00:23:20,150
re-implement the whole map thing I want

00:23:16,970 --> 00:23:22,550
to reuse as much from the PPF as I can I

00:23:20,150 --> 00:23:24,290
think you can just like if I think

00:23:22,550 --> 00:23:26,570
invaluable format like you cannot really

00:23:24,290 --> 00:23:29,000
reuse much right now you can use you can

00:23:26,570 --> 00:23:31,700
be you like you can reuse everything up

00:23:29,000 --> 00:23:34,790
to the map and map stuff up to the

00:23:31,700 --> 00:23:36,500
mapping map I see if it's partially many

00:23:34,790 --> 00:23:38,930
places we don't have a map and map we

00:23:36,500 --> 00:23:43,810
just want to use the loader to get all

00:23:38,930 --> 00:23:47,500
the other stuff we should yeah

00:23:43,810 --> 00:23:47,500
April a little time okay

00:23:49,210 --> 00:24:01,640
well that's for next time thank you

00:23:53,890 --> 00:24:01,640
[Applause]

00:24:45,610 --> 00:24:49,450
hello we are good

00:24:49,750 --> 00:24:56,710
so today I will talk about the PPF of

00:24:52,750 --> 00:24:59,740
debugging and in user space and we have

00:24:56,710 --> 00:25:02,380
a gdb we have LDB Wilhelmy other

00:24:59,740 --> 00:25:04,900
different debuggers but typical PPF

00:25:02,380 --> 00:25:08,250
debugging is not a lot of people touched

00:25:04,900 --> 00:25:11,770
and we just try if you have a print okay

00:25:08,250 --> 00:25:15,220
chase print okay so let's see what we

00:25:11,770 --> 00:25:17,940
can do better here and the first let me

00:25:15,220 --> 00:25:21,760
introduce a couple when use case and

00:25:17,940 --> 00:25:28,600
this is the load balancer self test

00:25:21,760 --> 00:25:30,790
program test ale for lob and a bunch of

00:25:28,600 --> 00:25:33,610
program here is a process packet is a

00:25:30,790 --> 00:25:36,760
call function and you get packet and

00:25:33,610 --> 00:25:38,980
then you test whether it's ipv4 or ipv6

00:25:36,760 --> 00:25:42,370
and then you extract some information

00:25:38,980 --> 00:25:44,440
and then you set the tango key and you

00:25:42,370 --> 00:25:47,500
try to say later I will try to do a load

00:25:44,440 --> 00:25:50,080
balancer work and but you may find a

00:25:47,500 --> 00:25:52,240
problem like okay some of the IP address

00:25:50,080 --> 00:25:54,640
is not a set up in the tunnel key and

00:25:52,240 --> 00:25:58,720
there is not another so what's going on

00:25:54,640 --> 00:26:00,340
and let's see how do we proceed from

00:25:58,720 --> 00:26:04,030
here and whether we can discover

00:26:00,340 --> 00:26:07,300
problems and you may get some hypothesis

00:26:04,030 --> 00:26:11,560
say ok and there may be some map look up

00:26:07,300 --> 00:26:14,770
and didn't get the value back and so and

00:26:11,560 --> 00:26:19,630
I want to say check at particular line

00:26:14,770 --> 00:26:23,080
for 3-1 and line for 45 and to see for

00:26:19,630 --> 00:26:25,330
my particular address whether this map

00:26:23,080 --> 00:26:28,300
lookup of failed and that's the reason

00:26:25,330 --> 00:26:32,830
so you get these hypotheses and you want

00:26:28,300 --> 00:26:34,660
to verify that we verify that and so the

00:26:32,830 --> 00:26:36,340
action will be okay typically in

00:26:34,660 --> 00:26:38,770
userspace 'you've you have this one you

00:26:36,340 --> 00:26:41,320
will say I want to have a breakpoint and

00:26:38,770 --> 00:26:45,430
as these two lines with this condition

00:26:41,320 --> 00:26:50,200
and well let's see how PPF can do that

00:26:45,430 --> 00:26:53,290
and another thing is suppose you verify

00:26:50,200 --> 00:26:55,960
it okay at particularly line 4 4 5 and

00:26:53,290 --> 00:26:57,850
it's missing oh it's a mystery why it

00:26:55,960 --> 00:27:00,760
missing I don't understand

00:26:57,850 --> 00:27:03,680
and so I want to print the map and I

00:27:00,760 --> 00:27:06,380
also want to print this

00:27:03,680 --> 00:27:11,530
and to see whether I make any mistake or

00:27:06,380 --> 00:27:14,420
not so in summary what we want to do is

00:27:11,530 --> 00:27:17,420
we want to break at the two points and

00:27:14,420 --> 00:27:19,640
also at the particular points if it

00:27:17,420 --> 00:27:21,260
happens or in the other point you could

00:27:19,640 --> 00:27:24,650
print the different things you want to

00:27:21,260 --> 00:27:25,880
print her some key and a printer map so

00:27:24,650 --> 00:27:28,160
in userspace

00:27:25,880 --> 00:27:30,890
you can just have a bring point here and

00:27:28,160 --> 00:27:33,980
then you have some conditions and then

00:27:30,890 --> 00:27:37,190
you just dump a gdb you can do that but

00:27:33,980 --> 00:27:39,830
in PPF k at of today typically and

00:27:37,190 --> 00:27:44,300
people will try to rewrite a program at

00:27:39,830 --> 00:27:46,340
v PM k or something and try to with this

00:27:44,300 --> 00:27:49,040
condition if this condition - i will

00:27:46,340 --> 00:27:51,320
print this key and you may not be able

00:27:49,040 --> 00:27:54,350
to print the whole map you'll be printer

00:27:51,320 --> 00:27:56,870
some of them it's bad most and so you

00:27:54,350 --> 00:28:00,800
need modified kernels and coordination

00:27:56,870 --> 00:28:05,330
it's pretty complex and how do we do it

00:28:00,800 --> 00:28:08,690
in BPF and think about this i have a

00:28:05,330 --> 00:28:12,560
simple idea and let's see how it works a

00:28:08,690 --> 00:28:15,290
lot so i will try to do let's see

00:28:12,560 --> 00:28:19,040
still user BPF - and i invented a new

00:28:15,290 --> 00:28:21,920
command for the program inspect so the

00:28:19,040 --> 00:28:25,100
idea is and from a high level user

00:28:21,920 --> 00:28:27,950
perspective you specify a location you

00:28:25,100 --> 00:28:32,450
specify action and you spike specify

00:28:27,950 --> 00:28:35,900
conditions and you may want to have

00:28:32,450 --> 00:28:38,320
several is basically inspectors back

00:28:35,900 --> 00:28:43,580
together the reason is you want to

00:28:38,320 --> 00:28:45,650
collectively collectively get more

00:28:43,580 --> 00:28:48,440
information and for this particular

00:28:45,650 --> 00:28:50,960
issue because they are correlated so

00:28:48,440 --> 00:28:53,420
we'll have a location and like a

00:28:50,960 --> 00:28:55,640
function name plus offset and have

00:28:53,420 --> 00:28:58,070
action you can skip something or you can

00:28:55,640 --> 00:29:01,370
print a sum expression you can printer

00:28:58,070 --> 00:29:04,310
some registers or print some memory as

00:29:01,370 --> 00:29:06,170
buffer some of the contents and a

00:29:04,310 --> 00:29:08,690
conditional you just condition or it's

00:29:06,170 --> 00:29:13,910
even can be a watch point it may only no

00:29:08,690 --> 00:29:16,430
work I just write so and and let's first

00:29:13,910 --> 00:29:17,350
just debugging typical jitters I'm a

00:29:16,430 --> 00:29:21,039
layer that's most

00:29:17,350 --> 00:29:24,220
comment so let's don't do this I mean

00:29:21,039 --> 00:29:26,169
non GData interpreter because hopefully

00:29:24,220 --> 00:29:30,580
people use it and they may have some

00:29:26,169 --> 00:29:33,400
other way side and so the current

00:29:30,580 --> 00:29:38,140
approach like this function name offset

00:29:33,400 --> 00:29:40,539
this is the like assembly level but I

00:29:38,140 --> 00:29:43,450
think a later on once we get better PDF

00:29:40,539 --> 00:29:46,150
support we already have some countable

00:29:43,450 --> 00:29:48,820
support but sometimes and the long amber

00:29:46,150 --> 00:29:51,429
file name this need to be really checked

00:29:48,820 --> 00:29:55,659
and verified before we really can't do

00:29:51,429 --> 00:30:08,530
at the source level so how any question

00:29:55,659 --> 00:30:11,890
about just this interface have you

00:30:08,530 --> 00:30:13,840
looked into our gdb remote gdb whether

00:30:11,890 --> 00:30:16,350
that could be an option for debugging

00:30:13,840 --> 00:30:23,020
VPS and the kernel

00:30:16,350 --> 00:30:27,610
yes remote gdb foot and the scene is a

00:30:23,020 --> 00:30:30,309
remote gdb as an interface it's possible

00:30:27,610 --> 00:30:32,590
and the thing we do here is whether we

00:30:30,309 --> 00:30:35,169
can leverage PPF to infrastructure or

00:30:32,590 --> 00:30:38,200
not because it's a user space remote gdb

00:30:35,169 --> 00:30:40,360
also is another way we could support it

00:30:38,200 --> 00:30:42,520
was enough interesting or things like

00:30:40,360 --> 00:30:50,020
that because they are all user space we

00:30:42,520 --> 00:30:52,500
can do it yes and if for no questions

00:30:50,020 --> 00:30:55,570
ok let's go to how we're doing the

00:30:52,500 --> 00:30:58,240
kernel to support ease before that let's

00:30:55,570 --> 00:31:02,080
have a more concrete example try to

00:30:58,240 --> 00:31:04,929
debug my own problems ok so suppose a

00:31:02,080 --> 00:31:07,419
program ID the 14 so here you try to

00:31:04,929 --> 00:31:10,090
inspect the program ID 14 and the

00:31:07,419 --> 00:31:14,340
location in the process packet tools 30

00:31:10,090 --> 00:31:18,789
and on the right hand side I have this

00:31:14,340 --> 00:31:20,980
PPF or by code remember just just just

00:31:18,789 --> 00:31:24,610
to remember here some time I myself

00:31:20,980 --> 00:31:28,780
confused is this 230 actually is 255

00:31:24,610 --> 00:31:30,630
minus 25 the reason we do this it just

00:31:28,780 --> 00:31:33,810
because of simplicity and

00:31:30,630 --> 00:31:36,990
forge it and because later on JIT may

00:31:33,810 --> 00:31:40,230
have Duty is like a each function has

00:31:36,990 --> 00:31:43,440
its own memory regions but this can

00:31:40,230 --> 00:31:46,140
change its back and action is a print

00:31:43,440 --> 00:31:48,660
first align printer hit one just just

00:31:46,140 --> 00:31:51,090
you just hit it so you know the problem

00:31:48,660 --> 00:31:54,560
here and you have a condition condition

00:31:51,090 --> 00:31:58,440
is like this register equal to 0 and

00:31:54,560 --> 00:32:01,110
because well it's a is if R 1 equal to 0

00:31:58,440 --> 00:32:03,780
you go to exit so that's a problem here

00:32:01,110 --> 00:32:06,630
and because go to some other places they

00:32:03,780 --> 00:32:08,640
miss the lookup so you have this way and

00:32:06,630 --> 00:32:11,780
then you want to print how another

00:32:08,640 --> 00:32:14,850
condition like you ipv6 you have a

00:32:11,780 --> 00:32:18,720
128-bit so you participate in to to

00:32:14,850 --> 00:32:20,550
places like from the arnai plus 0 ok

00:32:18,720 --> 00:32:24,570
this address equal to this way and

00:32:20,550 --> 00:32:27,180
another 64-bit equal to another way if

00:32:24,570 --> 00:32:29,970
this hit and a print this way this could

00:32:27,180 --> 00:32:34,880
be went back and try to debugger this

00:32:29,970 --> 00:32:37,500
problem and another way another way is

00:32:34,880 --> 00:32:41,490
suppose this indeed ahead you want to

00:32:37,500 --> 00:32:44,010
print as a key and also the basically

00:32:41,490 --> 00:32:46,520
the map itself and the command line is

00:32:44,010 --> 00:32:51,030
like you printed this memory region and

00:32:46,520 --> 00:32:55,050
also print a map name so on the line we

00:32:51,030 --> 00:32:58,350
will try to make it work and I mentioned

00:32:55,050 --> 00:33:00,450
earlier sauce annotated code may work in

00:32:58,350 --> 00:33:00,900
the future but right now we just focus

00:33:00,450 --> 00:33:03,060
on that

00:33:00,900 --> 00:33:05,690
oh no the source are not hidden codes

00:33:03,060 --> 00:33:08,400
and I on the right hand side like a

00:33:05,690 --> 00:33:11,760
statical or this if condition it will

00:33:08,400 --> 00:33:14,880
help you find the rich code to look and

00:33:11,760 --> 00:33:19,110
which register to use and which memory

00:33:14,880 --> 00:33:22,260
buffer you try to use to comparison yeah

00:33:19,110 --> 00:33:24,300
so and I think the next way is like a

00:33:22,260 --> 00:33:28,290
kernel support there may be some

00:33:24,300 --> 00:33:31,590
suggestions here and in order to do that

00:33:28,290 --> 00:33:36,150
I'm thinking about well and we try to

00:33:31,590 --> 00:33:39,000
use a PPF to debug a BPF and user can

00:33:36,150 --> 00:33:42,180
have some conditions actions and for

00:33:39,000 --> 00:33:44,190
each inspect and so we will just create

00:33:42,180 --> 00:33:47,669
a PPF program based

00:33:44,190 --> 00:33:50,840
you're spec and attach this PPF program

00:33:47,669 --> 00:33:55,309
to this particular JIT instruction and

00:33:50,840 --> 00:33:56,460
and this ppl program will share the Maps

00:33:55,309 --> 00:33:58,620
Global's

00:33:56,460 --> 00:34:01,429
in read-only mode of course you don't

00:33:58,620 --> 00:34:05,850
want to change the original program and

00:34:01,429 --> 00:34:09,000
with to be debugger ppl program and the

00:34:05,850 --> 00:34:14,429
context is the BPF 4k prop so it got a

00:34:09,000 --> 00:34:16,829
register it is supposed to get the JIT

00:34:14,429 --> 00:34:20,490
basically architecture all the registers

00:34:16,829 --> 00:34:23,429
from there and you will be able to if

00:34:20,490 --> 00:34:25,710
which it actually has a PPF pi code has

00:34:23,429 --> 00:34:28,200
a reasonable correlation you will be

00:34:25,710 --> 00:34:34,139
able to go to back by code and try to

00:34:28,200 --> 00:34:36,929
correlate with your conditions so for

00:34:34,139 --> 00:34:41,940
kernel support so we need a nested at a

00:34:36,929 --> 00:34:45,000
prop and currently actually we do not

00:34:41,940 --> 00:34:47,760
allow that in two different places where

00:34:45,000 --> 00:34:50,280
is a hip hop infrastructure itself does

00:34:47,760 --> 00:34:53,040
not like the nest here to keep Rob and

00:34:50,280 --> 00:34:55,740
the EPF infrastructure doesn't like the

00:34:53,040 --> 00:34:58,349
user currently we have a active program

00:34:55,740 --> 00:35:03,660
counter and it most of one so that means

00:34:58,349 --> 00:35:06,869
we don't support messed it and also we

00:35:03,660 --> 00:35:11,369
need a some kind of infrastructure

00:35:06,869 --> 00:35:14,010
change and to permit chase K prop BPF

00:35:11,369 --> 00:35:18,540
gt-r instruction because it is mostly

00:35:14,010 --> 00:35:20,520
allocated in the module address range so

00:35:18,540 --> 00:35:23,599
currently has some restrictions BPF

00:35:20,520 --> 00:35:26,579
itself is not really a module so

00:35:23,599 --> 00:35:29,490
currently get rejected and some other

00:35:26,579 --> 00:35:32,430
cases and architecture backhand I mean

00:35:29,490 --> 00:35:36,839
need some kind of the tricks to make it

00:35:32,430 --> 00:35:39,569
work so automated go at this point at

00:35:36,839 --> 00:35:42,990
the initial stage we will be debugging

00:35:39,569 --> 00:35:46,440
PPF at assembly level and I try to help

00:35:42,990 --> 00:35:48,480
people and I try to you know to rewrite

00:35:46,440 --> 00:35:52,410
your program with such a spring key or

00:35:48,480 --> 00:35:54,430
other stuff and this will help

00:35:52,410 --> 00:35:57,309
labor the work and

00:35:54,430 --> 00:36:01,420
the developers because they need a look

00:35:57,309 --> 00:36:03,369
at this instructions by code and the try

00:36:01,420 --> 00:36:05,740
to figure out was her condition and what

00:36:03,369 --> 00:36:10,680
they really want to do but hopefully we

00:36:05,740 --> 00:36:10,680
were you all from there so any questions

00:36:13,260 --> 00:36:18,339
so is it correct that like it assumes

00:36:16,690 --> 00:36:19,750
that you can easily reproduce the bug

00:36:18,339 --> 00:36:21,640
and you can run like multiple times

00:36:19,750 --> 00:36:23,619
right and just like try to like narrow

00:36:21,640 --> 00:36:26,920
down the problem right

00:36:23,619 --> 00:36:30,040
I don't know that case-by-case so for

00:36:26,920 --> 00:36:32,410
some programs you could try and get

00:36:30,040 --> 00:36:34,660
something and further narrow down and if

00:36:32,410 --> 00:36:36,880
we bug up here more than once or

00:36:34,660 --> 00:36:39,309
repeatedly for something like that if

00:36:36,880 --> 00:36:41,410
they just appear wise yeah well this may

00:36:39,309 --> 00:36:44,740
not be a right another question like I'm

00:36:41,410 --> 00:36:46,540
just curious like you list it like those

00:36:44,740 --> 00:36:48,730
nested K probe and all those problems

00:36:46,540 --> 00:36:51,579
right yeah would it be easier like if we

00:36:48,730 --> 00:36:53,770
can just switch out the jaded program

00:36:51,579 --> 00:36:55,599
into an interpreted program but but the

00:36:53,770 --> 00:36:59,829
exactly the same program right and then

00:36:55,599 --> 00:37:01,359
like teach BPF internal environment to

00:36:59,829 --> 00:37:03,520
record additional information that we

00:37:01,359 --> 00:37:06,250
want right would that simplify this

00:37:03,520 --> 00:37:08,710
implementation that's a will simplify

00:37:06,250 --> 00:37:10,630
the kernel support and we will still use

00:37:08,710 --> 00:37:15,549
a PPI program but we don't have this

00:37:10,630 --> 00:37:18,160
nested PPF problems and you the thing is

00:37:15,549 --> 00:37:20,140
yeah this this could be another choice

00:37:18,160 --> 00:37:22,059
for this so like I was thinking about

00:37:20,140 --> 00:37:25,299
you know like there's this three record

00:37:22,059 --> 00:37:26,859
and replay like add-on to GDP right well

00:37:25,299 --> 00:37:29,079
it actually records like all the

00:37:26,859 --> 00:37:31,990
important bay points in the program and

00:37:29,079 --> 00:37:35,079
unless you play it back so like with non

00:37:31,990 --> 00:37:37,030
jittered but like interpreted and some

00:37:35,079 --> 00:37:39,069
program won't have interpreted the

00:37:37,030 --> 00:37:42,400
program because we had JIT always on and

00:37:39,069 --> 00:37:44,500
I don't know whether we want to hack to

00:37:42,400 --> 00:37:48,730
bring it back just for this or not and

00:37:44,500 --> 00:37:51,549
but yeah it's possible and for that case

00:37:48,730 --> 00:37:54,549
and we potentially could add some hooks

00:37:51,549 --> 00:37:56,410
in the interpreter and the things will

00:37:54,549 --> 00:37:59,369
be a little bit easier alright from

00:37:56,410 --> 00:37:59,369
infrastructure perspective

00:38:03,250 --> 00:38:07,910
so yesterday I think there was a talk

00:38:05,660 --> 00:38:10,370
about you know kind of XTP and

00:38:07,910 --> 00:38:12,770
integrating xtp programs with tcp dump

00:38:10,370 --> 00:38:14,960
and will brigade to be able to see what

00:38:12,770 --> 00:38:18,010
the XDP does would be possible to use

00:38:14,960 --> 00:38:20,900
this to essentially say tell tcp dump

00:38:18,010 --> 00:38:22,880
kind of dump the packet at the start of

00:38:20,900 --> 00:38:24,410
this xtp program and then dump it at the

00:38:22,880 --> 00:38:26,090
end of the xtp program together with

00:38:24,410 --> 00:38:30,170
metadata or do you think that would have

00:38:26,090 --> 00:38:32,300
to be another mechanism yeah this can be

00:38:30,170 --> 00:38:35,330
done and so basically we write a BPI

00:38:32,300 --> 00:38:37,520
programs and in the beginning of this

00:38:35,330 --> 00:38:40,550
one and basically it's a k' probe it

00:38:37,520 --> 00:38:46,550
just returns so yeah this can be abused

00:38:40,550 --> 00:38:48,470
in that way so I kind of think that

00:38:46,550 --> 00:38:50,330
there's two modes of debugging when

00:38:48,470 --> 00:38:51,950
looking at BPF programs there is the

00:38:50,330 --> 00:38:53,600
live debugging where you want the BPI

00:38:51,950 --> 00:38:54,860
program to execute and trigger these K

00:38:53,600 --> 00:38:56,480
broke things and give you the

00:38:54,860 --> 00:39:01,400
information because you're not really

00:38:56,480 --> 00:39:03,320
sure in what scenario the problem exists

00:39:01,400 --> 00:39:05,480
right so you have to run and let it go

00:39:03,320 --> 00:39:07,130
and trigger you have other cases where

00:39:05,480 --> 00:39:10,280
you're starting to develop a new program

00:39:07,130 --> 00:39:12,350
and you have a packet piece of data and

00:39:10,280 --> 00:39:14,000
you want to step through your program

00:39:12,350 --> 00:39:17,540
and see what's wrong and there that's

00:39:14,000 --> 00:39:19,400
why we need some user space BPF thing

00:39:17,540 --> 00:39:20,960
where you can step through it with a gdb

00:39:19,400 --> 00:39:23,210
like interface or whatever it doesn't

00:39:20,960 --> 00:39:25,880
matter and attach this piece of data

00:39:23,210 --> 00:39:28,730
like the sk p that gets captured to

00:39:25,880 --> 00:39:31,810
debug simple initial program problems

00:39:28,730 --> 00:39:34,100
versus sophisticated yes active deployed

00:39:31,810 --> 00:39:35,390
program problems if we're solving two

00:39:34,100 --> 00:39:38,360
different problems but yes right here

00:39:35,390 --> 00:39:43,730
yes that's probably the next slice and

00:39:38,360 --> 00:39:45,740
basically single spot so uh so one more

00:39:43,730 --> 00:39:48,680
question on that are there also any

00:39:45,740 --> 00:39:52,610
plans to integrate this into for example

00:39:48,680 --> 00:39:55,100
I think dragon it's called right this

00:39:52,610 --> 00:39:58,040
weekend like dump two whole stack and

00:39:55,100 --> 00:40:01,280
register state and everything yes

00:39:58,040 --> 00:40:06,740
yeah is also used and this can be done

00:40:01,280 --> 00:40:08,900
in jacket and the single step so this is

00:40:06,740 --> 00:40:11,750
actually pretty hard and we could use

00:40:08,900 --> 00:40:14,960
chemo and if you use Kim and then we can

00:40:11,750 --> 00:40:17,510
use GDB GDB would give out chemo and

00:40:14,960 --> 00:40:22,210
you can get the address and then you

00:40:17,510 --> 00:40:25,400
make really single step and do something

00:40:22,210 --> 00:40:27,680
another another thing of course we want

00:40:25,400 --> 00:40:30,080
to see whether we can have a sleep about

00:40:27,680 --> 00:40:33,530
BPA program which is a much harder thing

00:40:30,080 --> 00:40:37,520
to attack but currently we have I don't

00:40:33,530 --> 00:40:40,640
know and we have long time we real-time

00:40:37,520 --> 00:40:43,030
is the merger to lemming line and where

00:40:40,640 --> 00:40:46,430
the BPF will be able to basically

00:40:43,030 --> 00:40:48,260
preventable or not maybe if we did

00:40:46,430 --> 00:40:50,330
program further maybe how something is

00:40:48,260 --> 00:40:53,630
be done whether we could piggyback on

00:40:50,330 --> 00:40:56,420
that and do some single stuff there just

00:40:53,630 --> 00:40:57,680
summarize thinking yeah not sure yet I

00:40:56,420 --> 00:41:00,710
mean I mean it's really interesting to

00:40:57,680 --> 00:41:02,450
think about having a user space BPF

00:41:00,710 --> 00:41:04,400
execution environment like a full

00:41:02,450 --> 00:41:06,110
execution environment we provide a

00:41:04,400 --> 00:41:08,300
buffer and an example program it's

00:41:06,110 --> 00:41:10,370
definitely like you don't need qmu you

00:41:08,300 --> 00:41:13,460
don't need any special things maybe even

00:41:10,370 --> 00:41:15,650
built into the gdb back end for BPF

00:41:13,460 --> 00:41:17,990
because it has reversible execution

00:41:15,650 --> 00:41:19,460
support it already has a mechanism where

00:41:17,990 --> 00:41:21,890
you can describe how instructions behave

00:41:19,460 --> 00:41:24,350
so yeah and there's a simulator inside

00:41:21,890 --> 00:41:26,030
gdb so we could like that yeah that's

00:41:24,350 --> 00:41:28,250
doing something only probably to help

00:41:26,030 --> 00:41:30,290
her yes helpers what you do with helpers

00:41:28,250 --> 00:41:31,370
we got that simulation library yeah

00:41:30,290 --> 00:41:35,480
that's the only problem

00:41:31,370 --> 00:41:38,680
helpers what it make any sense to expand

00:41:35,480 --> 00:41:43,790
the action instead of thing print or

00:41:38,680 --> 00:41:48,080
whatever you just say car my BPF program

00:41:43,790 --> 00:41:50,260
to perform our thief actions for the

00:41:48,080 --> 00:41:55,780
next of this for the next instruction

00:41:50,260 --> 00:42:03,950
okay yeah it's a doable I mean yeah and

00:41:55,780 --> 00:42:08,440
BPF trace points in vpf programs the

00:42:03,950 --> 00:42:16,660
packet comes in called the PPF program

00:42:08,440 --> 00:42:19,700
in perforate you go to users yeah I mean

00:42:16,660 --> 00:42:21,830
theoretically it's a PBL program and we

00:42:19,700 --> 00:42:24,010
can have a program ID and just you just

00:42:21,830 --> 00:42:25,490
send it in the Kaito it can do anything

00:42:24,010 --> 00:42:30,230
theoretical a

00:42:25,490 --> 00:42:32,359
I have a shower question did you ever

00:42:30,230 --> 00:42:34,130
see a need for a single stepping support

00:42:32,359 --> 00:42:35,990
I mean like when you had to debauch a

00:42:34,130 --> 00:42:38,330
PPF issue and you would say oh this

00:42:35,990 --> 00:42:40,940
would have solved I'm not a active

00:42:38,330 --> 00:42:43,070
really a peepee of a developer for real

00:42:40,940 --> 00:42:45,470
use case and I audience oh here probably

00:42:43,070 --> 00:42:47,270
our opinion I think I think the people

00:42:45,470 --> 00:42:49,250
who would find it useful will get

00:42:47,270 --> 00:42:51,020
discouraged with BPF before they would

00:42:49,250 --> 00:42:52,820
tell us that there's this is a necessary

00:42:51,020 --> 00:43:00,410
feature so we should take that into

00:42:52,820 --> 00:43:01,490
consideration okay question I think one

00:43:00,410 --> 00:43:03,170
thing about single stepping though is

00:43:01,490 --> 00:43:04,490
that since all BPI programs are kind of

00:43:03,170 --> 00:43:06,320
we kind of almost solved the halting

00:43:04,490 --> 00:43:09,320
problem maybe we can just record someone

00:43:06,320 --> 00:43:10,609
suggesting all the state full trace and

00:43:09,320 --> 00:43:12,950
then you don't need the single step so

00:43:10,609 --> 00:43:17,240
much because it's kind of bounded the

00:43:12,950 --> 00:43:18,470
information you could record okay yeah

00:43:17,240 --> 00:43:20,720
I'm not sure we need single stepping

00:43:18,470 --> 00:43:23,690
support but being able to kind of build

00:43:20,720 --> 00:43:29,930
a custom skb to throw at a BPF program

00:43:23,690 --> 00:43:32,869
and then kind of that could be extended

00:43:29,930 --> 00:43:42,800
I guess yeah is there a way to call that

00:43:32,869 --> 00:43:44,570
from users so I don't know if we can

00:43:42,800 --> 00:43:46,130
generically like do that because like

00:43:44,570 --> 00:43:48,530
when you do tracing right you cannot

00:43:46,130 --> 00:43:50,270
just simulate all internal kernel state

00:43:48,530 --> 00:43:52,220
and like your back can be dependent on

00:43:50,270 --> 00:43:54,650
kernel state or like inputs of the

00:43:52,220 --> 00:43:57,230
package so you know like it sometimes

00:43:54,650 --> 00:44:00,800
you have to debug live program with live

00:43:57,230 --> 00:44:02,869
inputs so like recording and then like

00:44:00,800 --> 00:44:07,670
maybe replying back would be watching so

00:44:02,869 --> 00:44:09,560
I would only command here that I I think

00:44:07,670 --> 00:44:13,280
like in this discussion where I think

00:44:09,560 --> 00:44:17,900
over focusing on the solution whereas I

00:44:13,280 --> 00:44:21,290
think that main focus here is to show

00:44:17,900 --> 00:44:23,420
that today debugging of if you have

00:44:21,290 --> 00:44:25,339
programs is a is a pain point and we're

00:44:23,420 --> 00:44:27,260
trying to simplify it as much as

00:44:25,339 --> 00:44:29,570
possible through whatever solution it is

00:44:27,260 --> 00:44:32,150
whether it will extend the strong with

00:44:29,570 --> 00:44:35,450
single step in like extra tracing to do

00:44:32,150 --> 00:44:39,259
in user space a adachin TV like we

00:44:35,450 --> 00:44:41,849
consider in all options open

00:44:39,259 --> 00:44:44,039
mainly to make the debug in easy so

00:44:41,849 --> 00:44:46,619
that's what it is about and this is just

00:44:44,039 --> 00:44:51,089
so far the ideas that seems the easiest

00:44:46,619 --> 00:44:52,919
to tackle first to what is worth we are

00:44:51,089 --> 00:44:58,199
actually adding support to the keno

00:44:52,919 --> 00:45:00,359
simulator for a BPF simulator of course

00:44:58,199 --> 00:45:02,669
the hen and the kennel helpers are sort

00:45:00,359 --> 00:45:04,499
of a problem there because what do you

00:45:02,669 --> 00:45:07,439
make them to actually return or what to

00:45:04,499 --> 00:45:10,679
do with the argument but we will

00:45:07,439 --> 00:45:13,769
basically try for it to be possible to

00:45:10,679 --> 00:45:16,650
at least attach two gdb to run the

00:45:13,769 --> 00:45:18,329
simulator to run your program and then

00:45:16,650 --> 00:45:20,130
at the minimum you know to be able to

00:45:18,329 --> 00:45:21,869
the back somehow you know like logic had

00:45:20,130 --> 00:45:26,039
problems with conditionals you know

00:45:21,869 --> 00:45:28,019
stuff like that yeah I think we probably

00:45:26,039 --> 00:45:29,249
need to table it but just just very

00:45:28,019 --> 00:45:30,779
quick comment the world like at least

00:45:29,249 --> 00:45:33,179
two or three simulator is already

00:45:30,779 --> 00:45:37,259
written in the simulator in the user

00:45:33,179 --> 00:45:39,179
space user space BPF interpreters and

00:45:37,259 --> 00:45:41,910
well the main problem is to set all of

00:45:39,179 --> 00:45:43,380
the helpers like calling into the kernel

00:45:41,910 --> 00:45:46,259
helpers you cannot really simulate any

00:45:43,380 --> 00:45:49,289
of this from you yeah which is main part

00:45:46,259 --> 00:45:51,179
of the VP of program logic we will try I

00:45:49,289 --> 00:45:53,699
mean we are interested in investigating

00:45:51,179 --> 00:45:55,829
and researching a bit to what extent it

00:45:53,699 --> 00:45:58,919
is possible to emulate kernel contexts

00:45:55,829 --> 00:46:00,569
you know in user space and the simulator

00:45:58,919 --> 00:46:02,759
in the neutral chain you know is part of

00:46:00,569 --> 00:46:04,799
the tool chain so sort of come for free

00:46:02,759 --> 00:46:06,809
right if you use agenda with it you know

00:46:04,799 --> 00:46:07,469
it'd be no deal so we'll just nothing

00:46:06,809 --> 00:46:09,749
basically

00:46:07,469 --> 00:46:14,009
this helps include the DVB support by

00:46:09,749 --> 00:46:16,109
the way I was just wondering I'm

00:46:14,009 --> 00:46:17,609
identifiy you saw anyone else but I

00:46:16,109 --> 00:46:19,169
think more than single stepping I'd love

00:46:17,609 --> 00:46:21,449
to have a way of taking a core dump of a

00:46:19,169 --> 00:46:23,549
BPF program so you know I get my skb

00:46:21,449 --> 00:46:25,469
data and then I can take a look at that

00:46:23,549 --> 00:46:26,969
and look about the register sale is so I

00:46:25,469 --> 00:46:28,859
think I don't for me you're having like

00:46:26,969 --> 00:46:30,869
a BPF a cert helper or something like

00:46:28,859 --> 00:46:33,029
that and if that assertion gets tripped

00:46:30,869 --> 00:46:34,529
then we got a core dump of what our

00:46:33,029 --> 00:46:38,729
program state is I think something like

00:46:34,529 --> 00:46:40,909
that might be useful as well exactly

00:46:38,729 --> 00:46:40,909
yeah

00:46:42,560 --> 00:46:49,530
okay maybe we don't think about that

00:46:46,400 --> 00:47:27,840
today is not allowed safety first

00:46:49,530 --> 00:47:30,840
thank you hello can hear me can

00:47:27,840 --> 00:47:31,230
everybody hear me okay thank you very

00:47:30,840 --> 00:47:34,380
much

00:47:31,230 --> 00:47:36,720
Joey you ready cool

00:47:34,380 --> 00:47:39,170
hello everyone my name is Lawrence I

00:47:36,720 --> 00:47:39,170
work for

00:47:48,119 --> 00:47:55,619
just test for a third time lucky I hope

00:47:54,209 --> 00:47:58,049
my name is Lawrence I work for

00:47:55,619 --> 00:48:01,259
CloudFlare and this is Joe works for or

00:47:58,049 --> 00:48:03,029
undecillion project I should say and for

00:48:01,259 --> 00:48:07,319
the next ten or so minutes we'll talk

00:48:03,029 --> 00:48:10,650
about our topic of writing a Peugeot you

00:48:07,319 --> 00:48:14,189
BPF library a little bit of introduction

00:48:10,650 --> 00:48:16,709
both psyllium and cloth they use MEAP f

00:48:14,189 --> 00:48:19,559
very heavily we do a cloud we use a lot

00:48:16,709 --> 00:48:21,689
of X T P we're starting to use TC and

00:48:19,559 --> 00:48:24,930
psyllium is a very heavy user of kind of

00:48:21,689 --> 00:48:27,059
the TC hook the general way that we use

00:48:24,930 --> 00:48:28,499
e PBF is that we have a long-running

00:48:27,059 --> 00:48:33,259
service that has written and go that

00:48:28,499 --> 00:48:37,499
ends up managing the lifetime and

00:48:33,259 --> 00:48:40,650
finally I have something to hold on to

00:48:37,499 --> 00:48:43,170
this is good which manages a lifetime of

00:48:40,650 --> 00:48:45,150
our BPF program so in you know again

00:48:43,170 --> 00:48:48,119
CloudFlare case that's like a dose

00:48:45,150 --> 00:48:50,670
mitigation system plus and layer for no

00:48:48,119 --> 00:48:56,569
balancer and then facili omit is

00:48:50,670 --> 00:48:56,569
container security system for kubernetes

00:48:56,599 --> 00:49:02,489
looking at the available ecosystem right

00:49:00,329 --> 00:49:05,039
now there's kind of two contenders I

00:49:02,489 --> 00:49:06,630
guess if you were to start investigating

00:49:05,039 --> 00:49:08,699
what could you use to to build your

00:49:06,630 --> 00:49:10,319
service the first one obviously is lip

00:49:08,699 --> 00:49:11,819
PPF which is kind of the canonical

00:49:10,319 --> 00:49:14,789
implementation it lives in the kernel

00:49:11,819 --> 00:49:17,819
it's written in C and the other one is

00:49:14,789 --> 00:49:21,089
called lip ECC our this is better which

00:49:17,819 --> 00:49:26,119
is focused on tracing I would say and

00:49:21,089 --> 00:49:28,979
Arats lip BPF and depends on a lot of VN

00:49:26,119 --> 00:49:30,449
so lip ECC to start off with has a

00:49:28,979 --> 00:49:32,849
fairly heavy runtime which has been

00:49:30,449 --> 00:49:35,519
mentioned this is Olivia I'm dependency

00:49:32,849 --> 00:49:36,929
which makes it very difficult to build

00:49:35,519 --> 00:49:40,979
and package at least that's what I found

00:49:36,929 --> 00:49:43,619
my personal kind of experience and there

00:49:40,979 --> 00:49:45,900
is a go wrapper that you can use which

00:49:43,619 --> 00:49:50,579
is called I advised ago PPF and that

00:49:45,900 --> 00:49:52,920
uses C go to call into lip BCC the PPF

00:49:50,579 --> 00:49:55,589
of course is where all the new features

00:49:52,920 --> 00:49:57,239
land where the good stuff is has

00:49:55,589 --> 00:49:59,729
relatively few external dependencies

00:49:57,239 --> 00:50:00,859
it's also pretty lightweight but there

00:49:59,729 --> 00:50:04,940
is no fully flat

00:50:00,859 --> 00:50:07,309
go rapper now I think I need to make a

00:50:04,940 --> 00:50:09,140
little detour and talk about the pure go

00:50:07,309 --> 00:50:10,940
syndrome because this is like a common

00:50:09,140 --> 00:50:12,980
occurrence that there's an established

00:50:10,940 --> 00:50:15,170
library out there and then the go people

00:50:12,980 --> 00:50:17,779
go out and rewrite it and go and don't

00:50:15,170 --> 00:50:20,599
end up using the common library and I

00:50:17,779 --> 00:50:23,180
think that often kind of ruffles and

00:50:20,599 --> 00:50:25,970
feathers and I want to give some context

00:50:23,180 --> 00:50:29,390
why that happens and I think why in a

00:50:25,970 --> 00:50:32,720
way it's it's encouraged by the

00:50:29,390 --> 00:50:34,970
ecosystem it's hard to avoid problems

00:50:32,720 --> 00:50:37,549
with Sego kind of the headline thing is

00:50:34,970 --> 00:50:39,769
that compared to just regular go calls a

00:50:37,549 --> 00:50:42,499
Segoe function calls relatively

00:50:39,769 --> 00:50:45,289
expensive so for kind of a very simple

00:50:42,499 --> 00:50:46,730
use case like a map lookup and the

00:50:45,289 --> 00:50:51,289
current implementation we probably end

00:50:46,730 --> 00:50:55,509
up paying you know 10% more CPU time to

00:50:51,289 --> 00:50:58,190
just do a lookup and really the develop

00:50:55,509 --> 00:51:01,700
experience when using Segoe isn't very

00:50:58,190 --> 00:51:03,950
good there's a problem of and if you

00:51:01,700 --> 00:51:06,079
want to call out to see somewhere that C

00:51:03,950 --> 00:51:08,960
has to be you know kind of built and and

00:51:06,079 --> 00:51:10,369
bundled you could link to the library

00:51:08,960 --> 00:51:11,839
dynamically if you want to but then we

00:51:10,369 --> 00:51:14,359
need to solve the packaging problem

00:51:11,839 --> 00:51:16,339
which isn't there yet there needs to be

00:51:14,359 --> 00:51:18,619
a stable API so we can kind of upgrade

00:51:16,339 --> 00:51:20,989
downgrade libraries etc and we could

00:51:18,619 --> 00:51:23,869
also just kind of take the BPF if we

00:51:20,989 --> 00:51:25,999
wanted to and copy it into our go source

00:51:23,869 --> 00:51:28,430
but I'm not sure how much we really

00:51:25,999 --> 00:51:29,890
solve with that and also pose other

00:51:28,430 --> 00:51:32,480
problems because we probably end up

00:51:29,890 --> 00:51:37,099
needing to replace the build system and

00:51:32,480 --> 00:51:39,920
it's fairly invasive but really what I

00:51:37,099 --> 00:51:42,289
think is the crucial point is that using

00:51:39,920 --> 00:51:44,779
Segoe makes the default tooling that go

00:51:42,289 --> 00:51:47,509
provides less useful and I think that's

00:51:44,779 --> 00:51:49,369
a very strong draw the whole go

00:51:47,509 --> 00:51:53,210
ecosystem which is that you get kind of

00:51:49,369 --> 00:51:56,059
integrated cross-compilation you get

00:51:53,210 --> 00:51:58,670
very good tools for debugging profiling

00:51:56,059 --> 00:52:01,509
and tracing once you start using Segoe

00:51:58,670 --> 00:52:01,509
that goes way

00:52:04,960 --> 00:52:13,569
Mike come sure so you you probably

00:52:09,790 --> 00:52:15,730
guessed where this was going basically

00:52:13,569 --> 00:52:19,089
so what we're looking at is writing a

00:52:15,730 --> 00:52:21,579
BPF library similar to live EPF but in

00:52:19,089 --> 00:52:25,030
pure go to avoid it's the sorts of

00:52:21,579 --> 00:52:26,710
problems that Lawrence described so we

00:52:25,030 --> 00:52:28,930
want to be able to write services that

00:52:26,710 --> 00:52:31,599
men and BPF in terms of loading the

00:52:28,930 --> 00:52:34,059
program's into the kernel modifying maps

00:52:31,599 --> 00:52:35,319
doing all of that that sort of thing you

00:52:34,059 --> 00:52:37,750
know collecting metrics from your data

00:52:35,319 --> 00:52:41,800
path manipulating the the data path

00:52:37,750 --> 00:52:43,300
forwarding behavior perhaps and we want

00:52:41,800 --> 00:52:47,200
to write this in MIT so that basically

00:52:43,300 --> 00:52:49,839
anybody can can use this library so the

00:52:47,200 --> 00:52:50,650
primary goals are to cover networking

00:52:49,839 --> 00:52:53,500
use cases

00:52:50,650 --> 00:52:57,059
so both CloudFlare and also psyllium

00:52:53,500 --> 00:53:00,609
with written go code to handle our

00:52:57,059 --> 00:53:04,540
interactions with BPF and we figure that

00:53:00,609 --> 00:53:07,690
it's it's much better to manage this

00:53:04,540 --> 00:53:09,970
manage the the interactions with the of

00:53:07,690 --> 00:53:12,210
the kernel in a single library rather

00:53:09,970 --> 00:53:15,250
than each maintaining our own separate

00:53:12,210 --> 00:53:17,890
library so wanna maintain minimal

00:53:15,250 --> 00:53:20,319
external dependencies so again this just

00:53:17,890 --> 00:53:23,349
makes it easier for any project to pick

00:53:20,319 --> 00:53:26,920
it up and use it you don't have some

00:53:23,349 --> 00:53:29,799
logger or some link library there that

00:53:26,920 --> 00:53:32,380
you need to pull in and close problems

00:53:29,799 --> 00:53:34,839
with that so we want to make sure that

00:53:32,380 --> 00:53:36,280
it's it's highly tested you know using

00:53:34,839 --> 00:53:39,609
the standard goal in unit testing

00:53:36,280 --> 00:53:40,750
frameworks and highly testable so one of

00:53:39,609 --> 00:53:43,599
the things that we've had some pain

00:53:40,750 --> 00:53:46,720
within psyllium actually is being able

00:53:43,599 --> 00:53:48,849
to mock out the BPF layer so that we can

00:53:46,720 --> 00:53:50,950
test the internal logic of how we

00:53:48,849 --> 00:53:53,200
process events and generate map entries

00:53:50,950 --> 00:53:56,799
and so we'd like to be able to provide

00:53:53,200 --> 00:53:59,349
some facility there which application

00:53:56,799 --> 00:54:01,930
writers who write code that interacts

00:53:59,349 --> 00:54:04,799
with BPF can also use these mocks to

00:54:01,930 --> 00:54:06,910
mock out BPF and test their own logic

00:54:04,799 --> 00:54:09,670
and in the core is really like solving

00:54:06,910 --> 00:54:12,790
the common problem so we we both have

00:54:09,670 --> 00:54:15,730
experience with writing some libraries

00:54:12,790 --> 00:54:17,650
now we want to solve those the common

00:54:15,730 --> 00:54:18,820
problems in a central library and make

00:54:17,650 --> 00:54:20,890
that library compose

00:54:18,820 --> 00:54:22,960
also that if you need some special extra

00:54:20,890 --> 00:54:25,600
logic that doesn't really make sense for

00:54:22,960 --> 00:54:27,610
anyone else then you can compose that

00:54:25,600 --> 00:54:30,300
you know map structure for instance into

00:54:27,610 --> 00:54:34,300
your own struct and then added your own

00:54:30,300 --> 00:54:36,430
functionality on top of that so non

00:54:34,300 --> 00:54:39,130
goals so we're not tell you typing

00:54:36,430 --> 00:54:42,490
tracing at this point the BCC provides a

00:54:39,130 --> 00:54:47,530
bunch of this it's just not a not a goal

00:54:42,490 --> 00:54:49,510
for our use cases and with the kind of

00:54:47,530 --> 00:54:52,030
composability idea

00:54:49,510 --> 00:54:54,280
we don't necessarily introduced support

00:54:52,030 --> 00:54:57,280
for all hook points you know maybe

00:54:54,280 --> 00:54:58,540
there's some extra either we could

00:54:57,280 --> 00:55:00,480
provide that functionality in a separate

00:54:58,540 --> 00:55:02,890
library or library riders could

00:55:00,480 --> 00:55:06,940
application writers could have that for

00:55:02,890 --> 00:55:08,440
themselves so steps for getting this up

00:55:06,940 --> 00:55:11,260
and running so initially we're on a

00:55:08,440 --> 00:55:14,710
target just Maps and programs so Maps

00:55:11,260 --> 00:55:17,760
creating maps deleting maps create read

00:55:14,710 --> 00:55:19,990
update delete all of in trees and maps

00:55:17,760 --> 00:55:25,360
pinning of those nets to the file system

00:55:19,990 --> 00:55:27,190
and supporting nested Maps per CPU for

00:55:25,360 --> 00:55:29,110
programs being able to create the

00:55:27,190 --> 00:55:35,740
programs pinning the programs attaching

00:55:29,110 --> 00:55:39,370
them to 2tc will you support reusing

00:55:35,740 --> 00:55:41,920
maps so question is will you support

00:55:39,370 --> 00:55:43,990
reusing maps yes doesn't map so you

00:55:41,920 --> 00:55:45,700
loaded the program it created a map and

00:55:43,990 --> 00:55:49,330
then you load another program which

00:55:45,700 --> 00:55:51,580
wants to use that yes absolutely so for

00:55:49,330 --> 00:55:53,530
instance in cilium case when we do an

00:55:51,580 --> 00:55:54,760
upgrade what we do is then the first

00:55:53,530 --> 00:55:56,320
time cilium will start up it will create

00:55:54,760 --> 00:55:58,570
maps and pin them to the file system and

00:55:56,320 --> 00:56:00,190
then we need to upgrade we need to cycle

00:55:58,570 --> 00:56:02,350
the process but we want to reap ikh up

00:56:00,190 --> 00:56:04,180
the existing method that exists on the

00:56:02,350 --> 00:56:06,700
file system so that's it's very much a

00:56:04,180 --> 00:56:10,720
part of what we do in cilium so we'll

00:56:06,700 --> 00:56:12,970
need that from the library I think and

00:56:10,720 --> 00:56:15,640
can we please coordinate so that lip PPF

00:56:12,970 --> 00:56:17,950
pins things the same place of as this

00:56:15,640 --> 00:56:19,590
thing yeah actually that's probably one

00:56:17,950 --> 00:56:21,550
of the goals that I that I have that I

00:56:19,590 --> 00:56:23,260
you know leaving off the slide but

00:56:21,550 --> 00:56:27,430
there's a whole bunch of things around

00:56:23,260 --> 00:56:30,250
the elf format yeah things like the

00:56:27,430 --> 00:56:31,870
deposit we're where we pin things to the

00:56:30,250 --> 00:56:32,780
file system and so on that I think we

00:56:31,870 --> 00:56:35,570
need to make sure that

00:56:32,780 --> 00:56:38,440
PF and this library have a consistent

00:56:35,570 --> 00:56:40,790
sort of view on yeah I guess sort of the

00:56:38,440 --> 00:56:42,710
meter question is that now that you're

00:56:40,790 --> 00:56:44,660
volunteering to button to maintain a

00:56:42,710 --> 00:56:46,850
whole separate library I also sort of

00:56:44,660 --> 00:56:50,210
committing to keeping all these

00:56:46,850 --> 00:56:52,430
semantics in sync with with yeah yeah so

00:56:50,210 --> 00:56:54,140
I mean in an ideal world I think I'd

00:56:52,430 --> 00:56:56,120
like if you can just compile an elf and

00:56:54,140 --> 00:56:58,790
then you just use whatever library it's

00:56:56,120 --> 00:57:02,000
not loaders elbow obviously the Devils

00:56:58,790 --> 00:57:04,730
in the details and you know we're gonna

00:57:02,000 --> 00:57:06,470
have to work through the figuring out

00:57:04,730 --> 00:57:09,820
how we establish these these standards

00:57:06,470 --> 00:57:12,980
and make sure that we keep in sync

00:57:09,820 --> 00:57:14,420
yes so I think the the kind of the one

00:57:12,980 --> 00:57:16,430
point I want to make is this is not

00:57:14,420 --> 00:57:19,010
intended to be able to kind of say

00:57:16,430 --> 00:57:20,840
replace IP route with something that's

00:57:19,010 --> 00:57:21,410
based on this right I don't think that's

00:57:20,840 --> 00:57:24,680
the goal

00:57:21,410 --> 00:57:26,420
like this is for you have a I mean we

00:57:24,680 --> 00:57:29,390
have very specific needs to kind of

00:57:26,420 --> 00:57:32,990
orchestrate our data path and to kind of

00:57:29,390 --> 00:57:34,610
do stuff with vpf and that's what them a

00:57:32,990 --> 00:57:36,860
library exists for it's not meant to

00:57:34,610 --> 00:57:38,930
kind of say you know replace if you want

00:57:36,860 --> 00:57:40,310
to do an IP route attached to your XDP

00:57:38,930 --> 00:57:43,310
interface then you should do that and

00:57:40,310 --> 00:57:46,880
then you know this is not the right tool

00:57:43,310 --> 00:57:48,590
for you to use so but don't do things

00:57:46,880 --> 00:57:50,180
deliberately differently like I'm not

00:57:48,590 --> 00:57:52,220
saying don't like you don't be able to

00:57:50,180 --> 00:57:54,680
do all the same things it's just like

00:57:52,220 --> 00:57:56,750
you're releasing this library as well

00:57:54,680 --> 00:58:01,880
and you just know that we'll have users

00:57:56,750 --> 00:58:04,100
using it and if it's not compatible they

00:58:01,880 --> 00:58:06,830
would be confused absolutely yeah so

00:58:04,100 --> 00:58:09,890
like do we have maybe we need some kind

00:58:06,830 --> 00:58:12,560
of functional high-level tests that are

00:58:09,890 --> 00:58:15,620
not sort of in program unit tests but

00:58:12,560 --> 00:58:18,800
that sort of tests all of these larger

00:58:15,620 --> 00:58:20,840
semantics such as eyepin I bloat this

00:58:18,800 --> 00:58:22,700
file it will show up pinned as at this

00:58:20,840 --> 00:58:25,340
location yeah I think I regret I mean

00:58:22,700 --> 00:58:27,770
the added thing is with the new GCC port

00:58:25,340 --> 00:58:30,770
is like what kind of elf does GCC in it

00:58:27,770 --> 00:58:34,160
right yeah it'll be fun all right so do

00:58:30,770 --> 00:58:36,980
you do the btf based pinning thing as

00:58:34,160 --> 00:58:39,260
well right how do you do pinning now so

00:58:36,980 --> 00:58:41,480
right now the pin is a function so you

00:58:39,260 --> 00:58:42,770
can your application can pin wherever

00:58:41,480 --> 00:58:45,050
you have a BP ffs

00:58:42,770 --> 00:58:47,180
so there's no default

00:58:45,050 --> 00:58:50,750
there's no defaults there's no defaults

00:58:47,180 --> 00:58:54,619
and it is better okay so the first step

00:58:50,750 --> 00:58:56,840
so this comes out of kind of a lengthy

00:58:54,619 --> 00:58:58,340
process I should say so we had a long

00:58:56,840 --> 00:59:01,040
discussion between kind of psyllium and

00:58:58,340 --> 00:59:02,300
CloudFlare of what is the first thing

00:59:01,040 --> 00:59:04,130
that we want to put in the shared

00:59:02,300 --> 00:59:07,760
library kind of in the sense what's the

00:59:04,130 --> 00:59:09,140
minimum sensible thing to put there that

00:59:07,760 --> 00:59:11,619
we can build upon it's kind of the first

00:59:09,140 --> 00:59:13,640
thing is this this map and program

00:59:11,619 --> 00:59:15,740
there's going to be a step two and a

00:59:13,640 --> 00:59:18,020
step three and what we explicitly left

00:59:15,740 --> 00:59:19,760
out right now is kind of the what I

00:59:18,020 --> 00:59:20,900
would call the Alpha loader exactly for

00:59:19,760 --> 00:59:23,660
the reasons that you kind of mentioned

00:59:20,900 --> 00:59:26,210
it's not entirely clear how compatible

00:59:23,660 --> 00:59:29,690
like in the best case will be absolutely

00:59:26,210 --> 00:59:32,770
compatible from the PPF but then do we

00:59:29,690 --> 00:59:35,180
need to be compatible with IP route 2 or

00:59:32,770 --> 00:59:39,619
yes but do we need to be compatible with

00:59:35,180 --> 00:59:41,030
GCC or I mean no but what just like what

00:59:39,619 --> 00:59:43,760
do you usually do do you just like take

00:59:41,030 --> 00:59:47,180
the map name and put it into the lip FS

00:59:43,760 --> 00:59:51,530
so for us we don't pin maps at all okay

00:59:47,180 --> 00:59:54,710
that works that's compatible yeah so I

00:59:51,530 --> 00:59:57,980
I'm not quite sure what's the plan for

00:59:54,710 --> 00:59:59,300
the loading so what do you propose for

00:59:57,980 --> 01:00:02,450
the loading because you see in program

00:59:59,300 --> 01:00:06,200
create create and close loading

01:00:02,450 --> 01:00:08,180
yes and no so this this is based on some

01:00:06,200 --> 01:00:10,160
work I did for for the closure tooling

01:00:08,180 --> 01:00:11,750
and you can create a program and there's

01:00:10,160 --> 01:00:14,660
a go package that allows you to assemble

01:00:11,750 --> 01:00:16,340
individual upp F instructions so for the

01:00:14,660 --> 01:00:18,710
purpose of the initial kind of code dump

01:00:16,340 --> 01:00:19,940
that we have we can create like little

01:00:18,710 --> 01:00:22,369
testing programs to make sure our

01:00:19,940 --> 01:00:25,640
implementation works the Syrian people

01:00:22,369 --> 01:00:27,109
can kind of load a program from the file

01:00:25,640 --> 01:00:28,430
system and then attach it wherever they

01:00:27,109 --> 01:00:30,260
want kind of interact with it in the

01:00:28,430 --> 01:00:32,210
normal way and then in the follow up

01:00:30,260 --> 01:00:35,359
will add the EBP uploader which actually

01:00:32,210 --> 01:00:36,859
takes an elf kind of puts it into this

01:00:35,359 --> 01:00:38,330
common format that we need and then you

01:00:36,859 --> 01:00:41,470
can load into the crown do other stuff

01:00:38,330 --> 01:00:43,369
with it so essentially it ends up

01:00:41,470 --> 01:00:46,250
composing like these different bits

01:00:43,369 --> 01:00:48,650
together that's the idea do you think

01:00:46,250 --> 01:00:50,330
about structuring in such a way that you

01:00:48,650 --> 01:00:52,130
know like all this heavy lifting and all

01:00:50,330 --> 01:00:53,900
the devil in the details is handled by

01:00:52,130 --> 01:00:56,119
DB PF where you probably don't care

01:00:53,900 --> 01:00:58,220
about this 10% overhead for C go right

01:00:56,119 --> 01:00:58,820
and probably no one is going to debug it

01:00:58,220 --> 01:01:00,740
from go

01:00:58,820 --> 01:01:02,570
into see on like what's going on wrong

01:01:00,740 --> 01:01:04,100
with Li BPF right you would probably go

01:01:02,570 --> 01:01:06,530
to the mailing list and I just said like

01:01:04,100 --> 01:01:10,580
doesn't work here's the example and then

01:01:06,530 --> 01:01:12,260
like for the crud operations that could

01:01:10,580 --> 01:01:15,080
be done directly in gold like through

01:01:12,260 --> 01:01:18,560
Cisco's right that would eliminate all

01:01:15,080 --> 01:01:20,330
this like semantic synchronization will

01:01:18,560 --> 01:01:23,030
need to do but will give you ultimate

01:01:20,330 --> 01:01:25,040
performance or whatever you want that's

01:01:23,030 --> 01:01:27,230
true it doesn't fix the packaging

01:01:25,040 --> 01:01:30,230
problems and the API problems and kind

01:01:27,230 --> 01:01:31,850
of I mean if I point somebody at this

01:01:30,230 --> 01:01:33,890
library and say hey you want you know go

01:01:31,850 --> 01:01:35,810
and use it if I have a pure go thing

01:01:33,890 --> 01:01:37,310
they can go get it they can run their

01:01:35,810 --> 01:01:39,650
thing but the imagine how many problems

01:01:37,310 --> 01:01:43,850
you create by getting out of synch with

01:01:39,650 --> 01:01:45,620
Lilith yeah yeah some of this is also

01:01:43,850 --> 01:01:47,060
like what do you do if you're not doing

01:01:45,620 --> 01:01:49,340
this and for instance maybe you're

01:01:47,060 --> 01:01:50,990
shelling out two IP route to to achieve

01:01:49,340 --> 01:01:52,070
all that kind of stuff today and then

01:01:50,990 --> 01:01:53,660
you don't get the level of integration

01:01:52,070 --> 01:01:58,910
and you're not getting the legislators

01:01:53,660 --> 01:02:03,310
little BPF saying stuff either well okay

01:01:58,910 --> 01:02:03,310
perhaps I think perhaps at some point

01:02:06,880 --> 01:02:11,870
that's the exact reason why we want to

01:02:09,320 --> 01:02:13,370
fix IP route to to you sleepy F because

01:02:11,870 --> 01:02:15,770
people are doing that and they're

01:02:13,370 --> 01:02:18,920
running into this and it's a real

01:02:15,770 --> 01:02:21,320
problem and so Rob just sort of

01:02:18,920 --> 01:02:23,540
preemptively trying to prevent you from

01:02:21,320 --> 01:02:26,680
creating recreating the same problems

01:02:23,540 --> 01:02:29,990
that we already have to type you back to

01:02:26,680 --> 01:02:33,620
just one comment it feels to me that now

01:02:29,990 --> 01:02:36,230
we kind at the point where loading of

01:02:33,620 --> 01:02:38,020
the elf files should eventually be done

01:02:36,230 --> 01:02:41,780
by the kernel

01:02:38,020 --> 01:02:43,580
right so it kind of that's what kernel

01:02:41,780 --> 01:02:46,220
does so if you just point to a tad out

01:02:43,580 --> 01:02:48,710
right so hey that out is danced through

01:02:46,220 --> 01:02:50,720
this bin processing thing if there is a

01:02:48,710 --> 01:02:53,870
format the result II that I saw elderly

01:02:50,720 --> 01:02:55,910
on accept so we kinda I guess at that

01:02:53,870 --> 01:03:00,470
point so you should be able to just say

01:02:55,910 --> 01:03:02,630
viewers L file kernel go loaded and how

01:03:00,470 --> 01:03:05,210
we do it that's secondary question but

01:03:02,630 --> 01:03:06,620
that will solve this go thing you can

01:03:05,210 --> 01:03:08,840
still keep like all of the ghost stuff

01:03:06,620 --> 01:03:11,060
as it go what you saying but the loading

01:03:08,840 --> 01:03:12,200
the most complex part is even with btf

01:03:11,060 --> 01:03:15,380
of the generator like a

01:03:12,200 --> 01:03:17,210
Shen's all the cold cold stuff and

01:03:15,380 --> 01:03:18,920
everything l did live EP if you have to

01:03:17,210 --> 01:03:21,260
be P of course that it's doing and

01:03:18,920 --> 01:03:24,010
probably you're done like you will get

01:03:21,260 --> 01:03:27,619
for free from this like Colonel loading

01:03:24,010 --> 01:03:29,480
so we support BTS so the loader in the

01:03:27,619 --> 01:03:32,030
other library has but you have to be TF

01:03:29,480 --> 01:03:34,730
calls so that in theory works but for

01:03:32,030 --> 01:03:35,780
the reasons we don't use it I think it

01:03:34,730 --> 01:03:37,040
would be great if we could get to a

01:03:35,780 --> 01:03:38,780
point where the colonel can load the elf

01:03:37,040 --> 01:03:42,020
but then the colonel also has to allow

01:03:38,780 --> 01:03:44,240
us to modify the EBP F in some way

01:03:42,020 --> 01:03:47,540
because that's a lot of the I mean kind

01:03:44,240 --> 01:03:49,010
of as the the maturity as EBP F is

01:03:47,540 --> 01:03:51,680
matured I think there's been more tools

01:03:49,010 --> 01:03:54,079
to say the elf file you can you can load

01:03:51,680 --> 01:03:55,700
that verbatim into the colonel right so

01:03:54,079 --> 01:03:57,500
like the the idea that the elf file is

01:03:55,700 --> 01:03:59,510
this declarative thing of everything you

01:03:57,500 --> 01:04:00,560
need to actually load it to the colonel

01:03:59,510 --> 01:04:03,470
that's kind of the assumption that

01:04:00,560 --> 01:04:06,079
you're making right and in the in the

01:04:03,470 --> 01:04:07,970
process of building our daemon or our

01:04:06,079 --> 01:04:09,829
software we found that often the time

01:04:07,970 --> 01:04:11,660
we've had to work around things where we

01:04:09,829 --> 01:04:15,890
need to you know change some conflict

01:04:11,660 --> 01:04:17,750
and all this other stuff so I think

01:04:15,890 --> 01:04:19,700
there's always going to be cases where

01:04:17,750 --> 01:04:21,560
we need to be able to just kind of load

01:04:19,700 --> 01:04:24,319
the elf and then do something with it

01:04:21,560 --> 01:04:26,710
and then put it into the kernel as a

01:04:24,319 --> 01:04:26,710
program

01:04:35,680 --> 01:04:43,120
do you want to continue sure I'll try so

01:04:40,060 --> 01:04:45,580
I start step two is performance so at

01:04:43,120 --> 01:04:48,040
the moment we use to go for this

01:04:45,580 --> 01:04:51,220
it obviously has certain certain costs

01:04:48,040 --> 01:04:52,750
associated with going to the C go so

01:04:51,220 --> 01:04:54,790
we'd like to get a native implementation

01:04:52,750 --> 01:04:56,950
that will improve that I mean that

01:04:54,790 --> 01:04:58,810
translates directly to CPU cycles and

01:04:56,950 --> 01:05:01,660
the amount of time number of events we

01:04:58,810 --> 01:05:03,700
can handle from BPF structurally that

01:05:01,660 --> 01:05:09,760
would probably be as a subpar package

01:05:03,700 --> 01:05:12,250
but I guess that's up to future future

01:05:09,760 --> 01:05:15,910
work and I guess this is the slide that

01:05:12,250 --> 01:05:18,520
we were basically just talking about in

01:05:15,910 --> 01:05:19,720
terms of yeah what is it what does it

01:05:18,520 --> 01:05:22,570
look like do we want to do well float

01:05:19,720 --> 01:05:25,210
how much of the elf loader do we do bgf

01:05:22,570 --> 01:05:29,200
support global variables is interesting

01:05:25,210 --> 01:05:31,390
for both of our use cases but based on

01:05:29,200 --> 01:05:33,970
some of the earlier discussion in the

01:05:31,390 --> 01:05:36,970
session it sounds like some of that

01:05:33,970 --> 01:05:41,620
stuff is sort of moving more into into B

01:05:36,970 --> 01:05:44,200
Kiev and exactly how much oh that makes

01:05:41,620 --> 01:05:47,640
sense to heaven a golang library versus

01:05:44,200 --> 01:05:51,220
something else is sort of up for debate

01:05:47,640 --> 01:05:54,280
but so the main point of this is really

01:05:51,220 --> 01:05:55,600
to to make people know we're trying to

01:05:54,280 --> 01:05:58,860
work on this if you're interested in a

01:05:55,600 --> 01:06:03,760
girl Lang library you know chat with us

01:05:58,860 --> 01:06:07,840
tell us what you're interested in you

01:06:03,760 --> 01:06:11,050
know love to have more people involved I

01:06:07,840 --> 01:06:14,470
think the main concern that we hear from

01:06:11,050 --> 01:06:16,930
people is so this problem exists because

01:06:14,470 --> 01:06:18,550
of language pragma nation and now we're

01:06:16,930 --> 01:06:21,370
going to have as a result library

01:06:18,550 --> 01:06:23,230
fragmentation and what is the

01:06:21,370 --> 01:06:26,470
propagation rate of bug fixes from the

01:06:23,230 --> 01:06:28,840
BPF into your thing and vice versa so

01:06:26,470 --> 01:06:30,580
it's like this lack of synchronization

01:06:28,840 --> 01:06:33,460
because there's no central repository of

01:06:30,580 --> 01:06:38,260
implementation of these useful

01:06:33,460 --> 01:06:39,700
facilities so i'll so here we go earlier

01:06:38,260 --> 01:06:41,130
in the day in a networking track were we

01:06:39,700 --> 01:06:43,210
talking about centralization

01:06:41,130 --> 01:06:44,590
centralizing things by putting them into

01:06:43,210 --> 01:06:46,600
the kernel and here we here at the thing

01:06:44,590 --> 01:06:48,020
all over again let's just move all the

01:06:46,600 --> 01:06:49,430
elf loading into the kernel and make

01:06:48,020 --> 01:06:51,800
make it happen there but that does not

01:06:49,430 --> 01:06:53,720
solve the case of dynamic code

01:06:51,800 --> 01:06:56,230
generation which is going to be a common

01:06:53,720 --> 01:06:59,090
way to do things would be yep because

01:06:56,230 --> 01:07:00,620
you'll want to optimize out facilities

01:06:59,090 --> 01:07:02,120
you don't use at all that's like one but

01:07:00,620 --> 01:07:04,430
to me that's one of the powers of EPF

01:07:02,120 --> 01:07:08,560
you can optimize the code down to what

01:07:04,430 --> 01:07:08,560
you actually are doing on your system

01:07:09,010 --> 01:07:14,090
exactly so uh anyways it's just I hope

01:07:12,620 --> 01:07:15,770
we can keep things in sync and not lose

01:07:14,090 --> 01:07:22,700
bug fixes in either direction and just

01:07:15,770 --> 01:07:24,560
kind of stay on top of things one last

01:07:22,700 --> 01:07:27,530
comment like we'll help which you guys

01:07:24,560 --> 01:07:30,140
develop it in the kernel three please

01:07:27,530 --> 01:07:32,240
yeah you want to add golang code into

01:07:30,140 --> 01:07:39,860
the kernel tree is that direct oh okay

01:07:32,240 --> 01:07:41,420
Dave what do you think I think they

01:07:39,860 --> 01:07:43,610
might just do that for the novelty of it

01:07:41,420 --> 01:07:46,460
I think it's like first go package from

01:07:43,610 --> 01:07:49,520
their kernel nice and I guess rust is

01:07:46,460 --> 01:07:51,230
next door but I think the problem was

01:07:49,520 --> 01:07:52,880
also on rendering it you cannot simply

01:07:51,230 --> 01:07:54,260
pull this into your library because then

01:07:52,880 --> 01:07:59,120
you would have to sort of pull the whole

01:07:54,260 --> 01:08:00,560
kernel and the thing that we've seeing

01:07:59,120 --> 01:08:03,860
is that like more and more companies

01:08:00,560 --> 01:08:05,210
using BPF and xdp and tracing and

01:08:03,860 --> 01:08:06,890
whatnot and they all come up with their

01:08:05,210 --> 01:08:09,340
own goal library so like there's

01:08:06,890 --> 01:08:11,720
actually huge go community and that's

01:08:09,340 --> 01:08:16,180
product trying to consolidate it into

01:08:11,720 --> 01:08:16,180
one thing that people can rely on

01:08:19,380 --> 01:08:24,220
maybe this idea of having kind of trying

01:08:22,000 --> 01:08:25,810
to work out what the elf format is was a

01:08:24,220 --> 01:08:27,310
good one right I mean it was talking to

01:08:25,810 --> 01:08:29,859
Jose earlier it's like something that

01:08:27,310 --> 01:08:32,290
he's interested in for GCC back and it

01:08:29,859 --> 01:08:33,880
seems like the PPF wants to figure out

01:08:32,290 --> 01:08:36,670
what it is we'd like to know what the

01:08:33,880 --> 01:08:38,290
format is you could perhaps put it in

01:08:36,670 --> 01:08:41,109
the kernel repository and create some

01:08:38,290 --> 01:08:42,850
automatically synched other partial git

01:08:41,109 --> 01:08:45,460
repository that has only the go pieces

01:08:42,850 --> 01:08:46,660
so that people that want to pull it in

01:08:45,460 --> 01:08:48,220
from go they'll need to pull in the

01:08:46,660 --> 01:08:56,830
whole kernel but are still getting a

01:08:48,220 --> 01:08:59,080
fully up-to-date so the next step so if

01:08:56,830 --> 01:09:00,520
you apply a patch to seen a petrol the

01:08:59,080 --> 01:09:02,140
BPF do you need to also see in the

01:09:00,520 --> 01:09:07,540
petrol to go lying piece and in the

01:09:02,140 --> 01:09:08,859
kernel tree the other question is so did

01:09:07,540 --> 01:09:10,750
the other thing to consider is maybe

01:09:08,859 --> 01:09:12,790
like then this library at some point

01:09:10,750 --> 01:09:15,489
could potentially become part of the

01:09:12,790 --> 01:09:16,810
core go yes that's another direction we

01:09:15,489 --> 01:09:19,120
could go and if we keep in all

01:09:16,810 --> 01:09:21,069
dependencies maybe you you either open

01:09:19,120 --> 01:09:26,739
it to it to that I don't actually talk

01:09:21,069 --> 01:09:28,390
to go line sort of core people but you

01:09:26,739 --> 01:09:29,920
mentioned there was was the key right if

01:09:28,390 --> 01:09:31,839
you can have these functional tests that

01:09:29,920 --> 01:09:33,970
would ensure compatibility and you can

01:09:31,839 --> 01:09:35,140
run that and you can get that these are

01:09:33,970 --> 01:09:35,920
the correlations that these with

01:09:35,140 --> 01:09:37,900
libraries happen

01:09:35,920 --> 01:09:41,440
that's what do you do it should in

01:09:37,900 --> 01:09:43,420
theory work like that needs continuous

01:09:41,440 --> 01:09:46,900
integration of some sort the big

01:09:43,420 --> 01:09:48,759
drawback is a harder to innovate and the

01:09:46,900 --> 01:09:51,819
PPF basically because you can't just

01:09:48,759 --> 01:09:53,680
kind of go and you know add a features

01:09:51,819 --> 01:09:54,940
it kind of oh and you know you need to

01:09:53,680 --> 01:09:57,190
coordinate I don't know if we're at that

01:09:54,940 --> 01:09:58,780
stage right now where you want to make

01:09:57,190 --> 01:10:02,410
that commitment it's kind of up for

01:09:58,780 --> 01:10:04,030
discussion I guess last comment yes okay

01:10:02,410 --> 01:10:06,370
I'll just made it a sort of meta comment

01:10:04,030 --> 01:10:09,190
but the problem is like lip BPF is the

01:10:06,370 --> 01:10:10,630
spec we don't have a spec that we can re

01:10:09,190 --> 01:10:11,200
implement it we don't have an iris II

01:10:10,630 --> 01:10:13,270
don't know

01:10:11,200 --> 01:10:16,570
so that becomes the spec and now you're

01:10:13,270 --> 01:10:18,790
like an independent implementation

01:10:16,570 --> 01:10:20,590
should be good thing but because the

01:10:18,790 --> 01:10:23,020
spec is also code it becomes really

01:10:20,590 --> 01:10:26,080
difficult to get them in sync so like

01:10:23,020 --> 01:10:28,960
I'm CI and ultimately testing is right

01:10:26,080 --> 01:10:31,480
like the only way we have to to ensure

01:10:28,960 --> 01:10:33,640
this so we need to have something like

01:10:31,480 --> 01:10:37,230
on the grid of lippy weave hat BPF had

01:10:33,640 --> 01:10:37,230
CI I'd say yeah exactly

01:10:37,680 --> 01:11:33,420
okay alright thanks a lot okay but like

01:11:28,989 --> 01:11:33,420
ten minutes should be okay ten minutes

01:11:50,469 --> 01:11:55,449
okay let's get started

01:11:56,889 --> 01:12:03,440
hello hello look good enough to everyone

01:12:00,860 --> 01:12:06,469
so my name is song Lu and I know

01:12:03,440 --> 01:12:10,460
everyone knows Alexi here so nothing to

01:12:06,469 --> 01:12:14,650
introduction and so we do Mildred to new

01:12:10,460 --> 01:12:14,650
capabilities so let's do two at a time

01:12:14,920 --> 01:12:19,280
so this is what we have now we have two

01:12:18,110 --> 01:12:22,670
very powerful

01:12:19,280 --> 01:12:25,790
Cisco's like perf even open and this is

01:12:22,670 --> 01:12:29,900
PDF now there are all under like pretty

01:12:25,790 --> 01:12:31,849
much mostly under cap sis admin which

01:12:29,900 --> 01:12:35,110
you can do something like small things

01:12:31,849 --> 01:12:37,880
with them without assists that mean but

01:12:35,110 --> 01:12:41,750
that's really limited very limited

01:12:37,880 --> 01:12:44,300
features so but this makes if you want

01:12:41,750 --> 01:12:47,810
to use the either of them you will need

01:12:44,300 --> 01:12:51,110
caps eSATA mean which give you something

01:12:47,810 --> 01:12:54,199
more than what you need and this is very

01:12:51,110 --> 01:12:58,550
dangerous in many use cases so what we

01:12:54,199 --> 01:13:00,980
were proposing is to cap to quit to

01:12:58,550 --> 01:13:05,179
capabilities for each of them

01:13:00,980 --> 01:13:07,190
so that for users who only need one of

01:13:05,179 --> 01:13:11,659
them or both of them you don't need a

01:13:07,190 --> 01:13:14,060
cap sees that mean and the first benefit

01:13:11,659 --> 01:13:18,429
is like you're going to be able to

01:13:14,060 --> 01:13:23,960
remove your root filesystem by mistake

01:13:18,429 --> 01:13:25,730
so so mostly like we focus on vpf cell

01:13:23,960 --> 01:13:28,610
there will be there there are two use

01:13:25,730 --> 01:13:30,800
cases with BP FY is the tracing users

01:13:28,610 --> 01:13:34,190
you're probably gonna need a cat with

01:13:30,800 --> 01:13:37,460
EPF and it has tracing instead of caps

01:13:34,190 --> 01:13:40,190
is that mean hopefully that will get

01:13:37,460 --> 01:13:44,150
your tracing a lot safer not room stuff

01:13:40,190 --> 01:13:46,670
and another use case is the VP of

01:13:44,150 --> 01:13:49,670
networking which we already have on that

01:13:46,670 --> 01:13:53,500
admin which is good wanna need a cat VPS

01:13:49,670 --> 01:13:53,500
and incurred not admin

01:13:53,790 --> 01:14:03,570
so this is currently or proposed

01:14:00,050 --> 01:14:09,450
capability control of other function of

01:14:03,570 --> 01:14:13,020
command within sis PPF and I don't know

01:14:09,450 --> 01:14:18,360
what we would discuss yet but maybe we

01:14:13,020 --> 01:14:20,130
can come back to this page later and so

01:14:18,360 --> 01:14:23,340
the one doing the thing that changed the

01:14:20,130 --> 01:14:25,590
sorry to jump in since we've created

01:14:23,340 --> 01:14:28,500
this slide just you earlier today we

01:14:25,590 --> 01:14:31,350
discuss with Jasper and target that was

01:14:28,500 --> 01:14:34,260
this the Swiss map of G so some of the

01:14:31,350 --> 01:14:38,550
map operations like mu cop update and

01:14:34,260 --> 01:14:40,200
delete we should just allow without any

01:14:38,550 --> 01:14:42,090
checks or say without even done

01:14:40,200 --> 01:14:44,280
privileged ik without currently they

01:14:42,090 --> 01:14:48,150
actually gated by unprivileged VP ever

01:14:44,280 --> 01:14:50,370
disables his control and some companies

01:14:48,150 --> 01:14:52,650
set it already to one and completely

01:14:50,370 --> 01:14:55,380
disable anything including like we

01:14:52,650 --> 01:14:59,730
didn't really write into the map which

01:14:55,380 --> 01:15:01,980
is kind of goes against the open and

01:14:59,730 --> 01:15:03,660
right style of like file system

01:15:01,980 --> 01:15:07,050
permissions if you open a file you get

01:15:03,660 --> 01:15:08,430
an F G there is no write checks on read

01:15:07,050 --> 01:15:12,240
and write because you do everything that

01:15:08,430 --> 01:15:16,920
open as a standard security stuff but we

01:15:12,240 --> 01:15:19,230
can do extra checks for some reason look

01:15:16,920 --> 01:15:21,840
up an update into the map which is kinda

01:15:19,230 --> 01:15:24,780
unnecessary and so we're thinking that

01:15:21,840 --> 01:15:28,050
we will sort of relax this with map of G

01:15:24,780 --> 01:15:29,640
this box with map of G would actually

01:15:28,050 --> 01:15:32,160
mean that this is just if you get an F G

01:15:29,640 --> 01:15:33,720
to your map you like in the map is

01:15:32,160 --> 01:15:35,430
read-only you'll be able to read it

01:15:33,720 --> 01:15:36,960
released if is if you opened it and

01:15:35,430 --> 01:15:38,820
during the open we check that it's RIT

01:15:36,960 --> 01:15:42,180
writable you will be able to read and

01:15:38,820 --> 01:15:44,460
write into it and I think this probably

01:15:42,180 --> 01:15:46,110
also goes in line with when you have PDF

01:15:44,460 --> 01:15:48,120
attached to a map you could also just

01:15:46,110 --> 01:15:49,950
dump the contents through the file

01:15:48,120 --> 01:15:53,250
system itself right so you can already

01:15:49,950 --> 01:15:56,130
read it as far as I'm aware so that

01:15:53,250 --> 01:15:58,730
would just yeah there would be

01:15:56,130 --> 01:15:58,730
consistent

01:16:00,929 --> 01:16:07,989
so considering that there is this thing

01:16:03,909 --> 01:16:12,670
of unprivileged BPF i've been wondering

01:16:07,989 --> 01:16:14,170
whether caps this admin is like should

01:16:12,670 --> 01:16:16,179
we just be checking for you have caps as

01:16:14,170 --> 01:16:20,070
admin or cabinet admin and just allow

01:16:16,179 --> 01:16:20,070
vpf stuff if you have either of those

01:16:24,869 --> 01:16:31,900
mmm so and thinking about capabilities

01:16:28,479 --> 01:16:34,209
I'm all for trying to get rid of the use

01:16:31,900 --> 01:16:35,979
of caps sysadmin but it's less about

01:16:34,209 --> 01:16:38,260
what you're doing and more about what

01:16:35,979 --> 01:16:41,079
what you have access to what you can

01:16:38,260 --> 01:16:43,900
read you know are you looking at bucket

01:16:41,079 --> 01:16:46,959
I'm looking at Network packets that's

01:16:43,900 --> 01:16:48,459
one set of of access control are you

01:16:46,959 --> 01:16:49,840
looking at kernel memory and you have

01:16:48,459 --> 01:16:51,400
access to like what what are the things

01:16:49,840 --> 01:16:53,530
you have access to it seems to me

01:16:51,400 --> 01:16:57,459
through seems to be exposed mostly

01:16:53,530 --> 01:16:59,889
through the helpers so I'm not sure if

01:16:57,459 --> 01:17:01,510
the maybe the commands mapped or

01:16:59,889 --> 01:17:03,849
something but it seems like access

01:17:01,510 --> 01:17:06,969
control is almost more time to what

01:17:03,849 --> 01:17:12,789
helpers you have access to it any at any

01:17:06,969 --> 01:17:16,659
you know through a program this rule

01:17:12,789 --> 01:17:18,820
that's why this cap let's say so just

01:17:16,659 --> 01:17:21,130
BPF alone does not allow you to like

01:17:18,820 --> 01:17:23,829
read anything networking because you

01:17:21,130 --> 01:17:25,449
still need cap net admin to attach and

01:17:23,829 --> 01:17:28,780
then to read because if you don't attach

01:17:25,449 --> 01:17:31,030
you if you cannot read anything that's

01:17:28,780 --> 01:17:32,739
why we did the whole attach with net

01:17:31,030 --> 01:17:35,739
admin in the first place because that's

01:17:32,739 --> 01:17:38,229
kind of basic ability you need to do

01:17:35,739 --> 01:17:40,449
networking so it's kind of the same

01:17:38,229 --> 01:17:42,400
taking the same so what what what trying

01:17:40,449 --> 01:17:44,709
to propose here is that that's what we

01:17:42,400 --> 01:17:46,510
did for net admin effectively and the

01:17:44,709 --> 01:17:48,360
same idea to do it for tracing so

01:17:46,510 --> 01:17:56,409
introduced kind of there is no

01:17:48,360 --> 01:18:00,389
separating I think I think part of this

01:17:56,409 --> 01:18:03,189
we probably need to check your

01:18:00,389 --> 01:18:04,749
capability in the verifier if you do not

01:18:03,189 --> 01:18:09,119
have certain capability you should not

01:18:04,749 --> 01:18:12,580
the concert and helper is that your

01:18:09,119 --> 01:18:15,370
question well I think that's

01:18:12,580 --> 01:18:17,230
we didn't think about that and do it as

01:18:15,370 --> 01:18:18,850
well it's just like net that mean

01:18:17,230 --> 01:18:22,630
already prevents it so this is like a

01:18:18,850 --> 01:18:24,970
little bit just additional check I think

01:18:22,630 --> 01:18:26,650
maybe the other way you feel one you all

01:18:24,970 --> 01:18:29,200
have not having me and bother you do not

01:18:26,650 --> 01:18:33,100
have kept racing maybe you should not to

01:18:29,200 --> 01:18:35,080
do something right I really do want a

01:18:33,100 --> 01:18:38,140
capped racing to me capped racing is

01:18:35,080 --> 01:18:39,910
something that allows you to see inside

01:18:38,140 --> 01:18:41,950
the kernel I think I think you probably

01:18:39,910 --> 01:18:44,620
agree right now I hate the fact that I

01:18:41,950 --> 01:18:47,020
have to be root to do a phrase that I

01:18:44,620 --> 01:18:48,910
really I mean I have to be rooted for

01:18:47,020 --> 01:18:50,620
specific reasons it's a it's definitely

01:18:48,910 --> 01:18:52,870
a privileged command but it'll be really

01:18:50,620 --> 01:18:56,230
nice to say cap would give my process

01:18:52,870 --> 01:18:58,060
capped racing and now I can do all my

01:18:56,230 --> 01:19:04,060
Tracy and not like said do anything else

01:18:58,060 --> 01:19:07,960
that's more dangerous so yeah I forgot

01:19:04,060 --> 01:19:09,820
to mention like this Crabtree thing

01:19:07,960 --> 01:19:14,350
should be include like access to tree

01:19:09,820 --> 01:19:17,020
suffice and which I didn't include in

01:19:14,350 --> 01:19:19,510
the movie go to the lower row there

01:19:17,020 --> 01:19:22,360
slice well that should be included there

01:19:19,510 --> 01:19:25,630
I think racing seems very nice but it's

01:19:22,360 --> 01:19:27,910
not clear to me what kappa PF how capi

01:19:25,630 --> 01:19:31,990
pf+ cabinet admin is better than just

01:19:27,910 --> 01:19:34,000
cabinet admin I was just gonna follow up

01:19:31,990 --> 01:19:35,890
on the tracing there's so think about it

01:19:34,000 --> 01:19:37,990
you can't make an attachment point

01:19:35,890 --> 01:19:39,700
without netted men but just by having

01:19:37,990 --> 01:19:41,680
cat BPM you good test

01:19:39,700 --> 01:19:46,570
Appa program by the user providing his

01:19:41,680 --> 01:19:48,760
own buffer into the test framework so

01:19:46,570 --> 01:19:51,280
this is goes back to his access to data

01:19:48,760 --> 01:19:52,810
do you have it and and for tracing it's

01:19:51,280 --> 01:19:54,280
like well you have read access do you

01:19:52,810 --> 01:19:56,020
have write access like those are the

01:19:54,280 --> 01:20:00,250
levels like that's basically control

01:19:56,020 --> 01:20:01,720
like read only is it rewrite right and

01:20:00,250 --> 01:20:04,690
I'm saying there might be people who

01:20:01,720 --> 01:20:08,080
want just read and that's a that's a

01:20:04,690 --> 01:20:09,670
smaller capability subset I'm not sure

01:20:08,080 --> 01:20:11,710
if this is because I haven't really used

01:20:09,670 --> 01:20:12,970
capital capabilities but I think I like

01:20:11,710 --> 01:20:14,770
it but the fact that it's like say if

01:20:12,970 --> 01:20:20,250
you have capabilities on you might get

01:20:14,770 --> 01:20:22,390
access right now the deepest treat is

01:20:20,250 --> 01:20:25,840
you can't it's like you have to be route

01:20:22,390 --> 01:20:27,370
to see it and once you have Theresa

01:20:25,840 --> 01:20:28,810
I would say if you have kept racing I

01:20:27,370 --> 01:20:30,790
guess they would give you access to it

01:20:28,810 --> 01:20:34,170
and now if we should allow should it be

01:20:30,790 --> 01:20:36,790
read right or should we have follow the

01:20:34,170 --> 01:20:38,830
the file system that follow the file

01:20:36,790 --> 01:20:40,300
system permissions then so you need to

01:20:38,830 --> 01:20:43,900
have both the file system permissions as

01:20:40,300 --> 01:20:45,190
well as cat keep tracing which means you

01:20:43,900 --> 01:20:46,570
probably need to create a new group and

01:20:45,190 --> 01:20:48,970
when you mount trace a pass you have to

01:20:46,570 --> 01:20:52,600
say okay mount it with this group and so

01:20:48,970 --> 01:20:54,160
you have access to it so I think one use

01:20:52,600 --> 01:20:55,510
case that they mentioned was testing the

01:20:54,160 --> 01:20:58,120
other thing is clear segregation of

01:20:55,510 --> 01:21:00,400
capabilities also like helps extend use

01:20:58,120 --> 01:21:02,710
cases for BPF so for the LS in use case

01:21:00,400 --> 01:21:05,200
if we trying to come up with gap EPF cap

01:21:02,710 --> 01:21:07,540
pack admin or clear segregation of who

01:21:05,200 --> 01:21:09,430
can attach a BPF program and what can

01:21:07,540 --> 01:21:11,050
they do with that do they have Mac admin

01:21:09,430 --> 01:21:15,670
to configure Nelson policy or something

01:21:11,050 --> 01:21:18,640
like that that's it if you have flasks

01:21:15,670 --> 01:21:21,670
of my cat vendors two of them kind of

01:21:18,640 --> 01:21:23,380
fits this model as well and under sort

01:21:21,670 --> 01:21:24,820
of on the tablet of grouping different

01:21:23,380 --> 01:21:27,580
things I think we've already mentioned

01:21:24,820 --> 01:21:30,610
it under the list but having CPU map and

01:21:27,580 --> 01:21:32,470
caps use admin but that's an HTTP

01:21:30,610 --> 01:21:34,570
feature so that means you can use all of

01:21:32,470 --> 01:21:36,310
HTTP except there's one thing and then

01:21:34,570 --> 01:21:39,880
you certainly need caps was happening

01:21:36,310 --> 01:21:41,620
for that and ID so can we move that cap

01:21:39,880 --> 01:21:45,700
another anode created case rights and so

01:21:41,620 --> 01:21:47,920
on but hey nobody used for it then HTTP

01:21:45,700 --> 01:21:53,020
and suddenly we're using we're applying

01:21:47,920 --> 01:21:54,490
caps as admin for HTTP the only other

01:21:53,020 --> 01:21:56,440
I'm not entirely convinced its

01:21:54,490 --> 01:21:59,830
capabilities or the right approach but

01:21:56,440 --> 01:22:01,840
it doesn't matter it's control there's a

01:21:59,830 --> 01:22:05,320
lot of baggage on capabilities and how

01:22:01,840 --> 01:22:07,120
it how its you know passes from process

01:22:05,320 --> 01:22:09,010
to process on fork and like there's a

01:22:07,120 --> 01:22:11,500
whole bunch of things now if those are

01:22:09,010 --> 01:22:14,470
helpful find ok capabilities but you

01:22:11,500 --> 01:22:17,230
know I if how finally granular you get

01:22:14,470 --> 01:22:19,030
you start losing some amount of utility

01:22:17,230 --> 01:22:20,890
like if you're saying you can use all

01:22:19,030 --> 01:22:23,800
that but not this even though both give

01:22:20,890 --> 01:22:30,310
you read access to the same data care

01:22:23,800 --> 01:22:33,910
it's interesting even with her read

01:22:30,310 --> 01:22:37,110
access only read-only access or I think

01:22:33,910 --> 01:22:37,110
that though there is a summer

01:22:38,840 --> 01:22:46,960
directions on Stan's about the security

01:22:42,400 --> 01:22:50,120
because that are caps cap tracing whoa

01:22:46,960 --> 01:22:54,970
expose that to summer symbol address

01:22:50,120 --> 01:22:58,280
information so that are it just sir

01:22:54,970 --> 01:23:02,510
policy but there yeah we need to

01:22:58,280 --> 01:23:10,150
consider about that are you know the pro

01:23:02,510 --> 01:23:10,150
K / seems also are expositor trace cap 3

01:23:15,580 --> 01:23:20,090
my point is I would like cap almost

01:23:18,590 --> 01:23:22,790
capped racing or could just be it would

01:23:20,090 --> 01:23:25,400
be basically another way of saying allow

01:23:22,790 --> 01:23:27,230
me to read like throw away the security

01:23:25,400 --> 01:23:29,090
of you know where what's inside the

01:23:27,230 --> 01:23:31,130
kernel I could see basically anything

01:23:29,090 --> 01:23:32,420
inside the kernel cap tracing basically

01:23:31,130 --> 01:23:35,300
it's a very privileged thing you don't

01:23:32,420 --> 01:23:37,280
give it to anyone just it's basically I

01:23:35,300 --> 01:23:38,900
just want I have control of my machine

01:23:37,280 --> 01:23:40,760
or I I'm the admin of machine I want to

01:23:38,900 --> 01:23:42,830
see what's going on well I'd also don't

01:23:40,760 --> 01:23:45,920
want to run something that might route

01:23:42,830 --> 01:23:47,870
my machine because it now has I do I do

01:23:45,920 --> 01:23:50,090
a pseudo or something like that I get

01:23:47,870 --> 01:23:51,800
myself full privileges to do anything to

01:23:50,090 --> 01:23:53,750
the machine I only want access to the

01:23:51,800 --> 01:23:57,680
tracing mechanisms yester it's going to

01:23:53,750 --> 01:23:59,930
expose that which will include proc K

01:23:57,680 --> 01:24:01,940
all Sims oh give me access to basically

01:23:59,930 --> 01:24:04,820
cap tracing to me is give me access to

01:24:01,940 --> 01:24:07,070
read anything basically it sounds like

01:24:04,820 --> 01:24:10,550
cap tracing has to be only in the root

01:24:07,070 --> 01:24:11,960
namespace but for net admin you

01:24:10,550 --> 01:24:14,000
definitely would like to be able to do

01:24:11,960 --> 01:24:15,770
stuff in other name spaces of our

01:24:14,000 --> 01:24:17,600
networking spaces especially so kind of

01:24:15,770 --> 01:24:21,080
like how do these capabilities interact

01:24:17,600 --> 01:24:22,160
with namespaces well that's that's why

01:24:21,080 --> 01:24:24,650
I'm not sure it's a good mapping

01:24:22,160 --> 01:24:26,480
capabilities themselves but I mean what

01:24:24,650 --> 01:24:28,820
we have is you know caps is admin which

01:24:26,480 --> 01:24:29,330
is rewrite I want it caps us admin that

01:24:28,820 --> 01:24:31,910
it's read-only

01:24:29,330 --> 01:24:33,920
that's what tracing would be like but

01:24:31,910 --> 01:24:36,910
now we're getting back to Dec like basic

01:24:33,920 --> 01:24:36,910
DAC access control

01:24:38,229 --> 01:24:43,449
so yeah so this is definitely not like a

01:24:41,559 --> 01:24:45,489
deal and not fine-grain the whole point

01:24:43,449 --> 01:24:48,039
here that is way better than what we

01:24:45,489 --> 01:24:50,679
have today so that's why like I think

01:24:48,039 --> 01:24:54,039
this is not the best of girls like in

01:24:50,679 --> 01:24:55,989
different domains meantime we should

01:24:54,039 --> 01:24:59,440
different to make it often great this is

01:24:55,989 --> 01:25:01,119
just like a first step and if someone

01:24:59,440 --> 01:25:04,590
just adds a cap Tracy I don't really

01:25:01,119 --> 01:25:04,590
care about the cap EPF that's all you're

01:25:04,679 --> 01:25:12,909
easy and I'll go on with that awesome so

01:25:09,519 --> 01:25:15,849
I want highlight one thing is like we're

01:25:12,909 --> 01:25:20,440
not proposing to set kappa b PF - your

01:25:15,849 --> 01:25:24,010
BP f - no cuz that cut kappa BB f to our

01:25:20,440 --> 01:25:27,159
b PF trees not that cap cap tracing

01:25:24,010 --> 01:25:29,559
4-perf because these tools are just way

01:25:27,159 --> 01:25:32,739
too powerful like you're not giving that

01:25:29,559 --> 01:25:35,499
to everyone but on other hand we with

01:25:32,739 --> 01:25:39,070
this cap were able to build alike other

01:25:35,499 --> 01:25:41,949
tools that could be safe for untrusted

01:25:39,070 --> 01:25:46,449
users like one thing we're discuss is

01:25:41,949 --> 01:25:50,199
like function func count is wound like a

01:25:46,449 --> 01:25:54,099
safest if you have pcs issues but it's

01:25:50,199 --> 01:25:56,289
probably not as safe as is ice but we do

01:25:54,099 --> 01:25:59,619
think it's possible to make it safe by

01:25:56,289 --> 01:26:03,639
limiting how many point you can trace

01:25:59,619 --> 01:26:08,829
and like make maybe also how heavy these

01:26:03,639 --> 01:26:10,209
trees are no not with cap Tracy do you

01:26:08,829 --> 01:26:12,570
know do you know what from count does

01:26:10,209 --> 01:26:15,929
well I don't know I just

01:26:12,570 --> 01:26:18,999
it's your opieop i'll i mean matters how

01:26:15,929 --> 01:26:20,739
secure how simple is that

01:26:18,999 --> 01:26:25,659
it's a first of all ends with py which

01:26:20,739 --> 01:26:27,780
really scares the hell out of me fair

01:26:25,659 --> 01:26:27,780
enough

01:26:28,090 --> 01:26:47,000
no idea what yes could you imagine maybe

01:26:38,870 --> 01:26:48,290
a native compare the bank account is it

01:26:47,000 --> 01:26:50,690
interesting to then write some

01:26:48,290 --> 01:26:52,520
application that does a bunch of you

01:26:50,690 --> 01:26:54,100
know it uses this cat tracing but

01:26:52,520 --> 01:26:56,270
they're not populates a DPF map which

01:26:54,100 --> 01:26:57,410
you know based on the way that you write

01:26:56,270 --> 01:26:58,610
it you know you're not exposing

01:26:57,410 --> 01:26:59,990
information you don't want to expose to

01:26:58,610 --> 01:27:02,450
um privileged and unprivileged just

01:26:59,990 --> 01:27:10,100
opens up that map and then can can read

01:27:02,450 --> 01:27:11,090
out of you know this information that

01:27:10,100 --> 01:27:12,500
would be sorta like if you want that

01:27:11,090 --> 01:27:14,270
fine grain then you have to go all the

01:27:12,500 --> 01:27:16,820
way down to say like what what date are

01:27:14,270 --> 01:27:19,640
you looking at like is that considered

01:27:16,820 --> 01:27:21,760
privileged or is it just like something

01:27:19,640 --> 01:27:21,760
else

01:27:29,010 --> 01:27:33,219
if you have the ability to read from a

01:27:31,570 --> 01:27:34,900
map without any access church you can

01:27:33,219 --> 01:27:37,900
build that yourself which is passing the

01:27:34,900 --> 01:27:39,630
F D to the map to s up process then

01:27:37,900 --> 01:27:41,710
drops privileges in it

01:27:39,630 --> 01:27:43,869
Jannik if you open it you open it

01:27:41,710 --> 01:27:45,880
privileged and load the BPF program and

01:27:43,869 --> 01:27:51,309
then you pass the read-only FTE down to

01:27:45,880 --> 01:27:52,929
this up the child well I guess there's

01:27:51,309 --> 01:27:54,400
the somebody erased a point about

01:27:52,929 --> 01:27:57,130
fine-grained access control right is

01:27:54,400 --> 01:27:58,869
there like a LSM policy for because cap

01:27:57,130 --> 01:28:00,040
capabilities is what you can do but if

01:27:58,869 --> 01:28:01,780
you want to do more fine-grained access

01:28:00,040 --> 01:28:02,920
checks like people in terms of what

01:28:01,780 --> 01:28:04,239
helpers you can execute with a

01:28:02,920 --> 01:28:09,219
particular program are there policies

01:28:04,239 --> 01:28:10,929
around BPF stuff but can you do

01:28:09,219 --> 01:28:14,349
fine-grained access controls with that

01:28:10,929 --> 01:28:16,389
LSM like means through the c linux or

01:28:14,349 --> 01:28:18,460
something yeah I doubt this a Linux

01:28:16,389 --> 01:28:23,889
implementer taenia with okay okay

01:28:18,460 --> 01:28:26,469
today there is some assilex integration

01:28:23,889 --> 01:28:27,940
will be PF but it is more along the

01:28:26,469 --> 01:28:31,090
lines of like are you allowed to create

01:28:27,940 --> 01:28:33,119
Maps or look at maps or update maps it

01:28:31,090 --> 01:28:37,290
doesn't get any more specific than that

01:28:33,119 --> 01:28:37,290
any Linux developers

01:28:40,450 --> 01:28:44,240
[Laughter]

01:29:00,750 --> 01:29:11,740
that's all I have okay let me stop hi

01:29:08,560 --> 01:29:13,720
everyone sorry so because of the visa

01:29:11,740 --> 01:29:17,010
issues according to this in remote mode

01:29:13,720 --> 01:29:20,830
so today my topic is how to reuse host

01:29:17,010 --> 01:29:24,640
gh backends as the offload backend so

01:29:20,830 --> 01:29:26,980
agenda so first why we do this then I

01:29:24,640 --> 01:29:30,070
would talk about how if you program is

01:29:26,980 --> 01:29:33,430
turned into a runnable image including

01:29:30,070 --> 01:29:35,950
bus house jet and after the jet so after

01:29:33,430 --> 01:29:38,590
that then let's say how some improve

01:29:35,950 --> 01:29:42,730
improvements could be two could be done

01:29:38,590 --> 01:29:47,320
to make the BBF Jenkins with better

01:29:42,730 --> 01:29:51,370
modularity then finally I will do a

01:29:47,320 --> 01:29:54,850
basic introduction on some of the DB PFR

01:29:51,370 --> 01:29:59,080
flow the prototyping work that we are

01:29:54,850 --> 01:30:02,670
doing I'm a smart Nick with risk of fire

01:29:59,080 --> 01:30:05,590
inside so first why do we need this

01:30:02,670 --> 01:30:08,200
obviously because a PPF could be

01:30:05,590 --> 01:30:11,440
offloaded so at the moment the offload

01:30:08,200 --> 01:30:14,020
mostly happen on networking devices for

01:30:11,440 --> 01:30:17,020
Grampa's smart Nick for example

01:30:14,020 --> 01:30:21,070
metronome and EFI perhaps there could be

01:30:17,020 --> 01:30:23,470
other PDF offload scenario in the future

01:30:21,070 --> 01:30:27,400
I think once the West Drive driver could

01:30:23,470 --> 01:30:29,410
be frightened using PPF so also for the

01:30:27,400 --> 01:30:31,930
offload obviously you want to use the

01:30:29,410 --> 01:30:36,880
architecture with strong ecosystem for

01:30:31,930 --> 01:30:41,610
example is 5 or 32 or access t4 or um

01:30:36,880 --> 01:30:44,140
DPF itself so and for all this

01:30:41,610 --> 01:30:47,860
architectures actually we have a stable

01:30:44,140 --> 01:30:49,900
host host the Jenkins already so when

01:30:47,860 --> 01:30:52,570
you stands offload actually the

01:30:49,900 --> 01:30:55,210
difference on the processor so there's a

01:30:52,570 --> 01:30:57,460
cottage in the ice is the same the third

01:30:55,210 --> 01:30:59,730
generation is the same so the Odin

01:30:57,460 --> 01:31:02,890
difference is how we install the program

01:30:59,730 --> 01:31:04,120
that is the wrong time is difference

01:31:02,890 --> 01:31:07,720
linking is difference

01:31:04,120 --> 01:31:09,820
so actually we really want to reuse so

01:31:07,720 --> 01:31:12,850
we really want to reuse code generation

01:31:09,820 --> 01:31:14,650
of the house to jet which also the

01:31:12,850 --> 01:31:19,210
biggest part

01:31:14,650 --> 01:31:22,180
so first how BPF program is turned into

01:31:19,210 --> 01:31:24,940
honorable image so a runnable image i

01:31:22,180 --> 01:31:27,220
think it must have all the instructions

01:31:24,940 --> 01:31:30,340
translated and obvious all the external

01:31:27,220 --> 01:31:33,190
reference we located for BPF program

01:31:30,340 --> 01:31:36,040
mostly maps static global data which

01:31:33,190 --> 01:31:41,320
also maps and a branch and the cost to

01:31:36,040 --> 01:31:43,060
helpers and BP f vp of course hence yeah

01:31:41,320 --> 01:31:45,790
as mentioned that s since it should have

01:31:43,060 --> 01:31:49,420
adjudicated and the current PFT its

01:31:45,790 --> 01:31:52,570
infrastructure to achieve this is we

01:31:49,420 --> 01:31:55,510
turn the say to real october BBF data

01:31:52,570 --> 01:31:59,170
which is a total contents BPF i saw and

01:31:55,510 --> 01:32:02,890
we do a linking on PPF i saw then the

01:31:59,170 --> 01:32:06,790
PPF fully relocated the PPF image is

01:32:02,890 --> 01:32:13,120
fated jenkins then generates the final

01:32:06,790 --> 01:32:14,770
image so it's not real October so the

01:32:13,120 --> 01:32:17,320
relocation generally it's not happen on

01:32:14,770 --> 01:32:20,290
a little image it's a hamper on the EPF

01:32:17,320 --> 01:32:23,020
I saw so there's two then there's too

01:32:20,290 --> 01:32:25,600
many stages for the courage its bank and

01:32:23,020 --> 01:32:29,520
compilation why is predicting the PPF

01:32:25,600 --> 01:32:32,910
total the second days after that we

01:32:29,520 --> 01:32:36,670
drive the bank runs to the cogeneration

01:32:32,910 --> 01:32:39,610
so for the praline King for hostage it

01:32:36,670 --> 01:32:41,350
first is when there is no BPF to be PF

01:32:39,610 --> 01:32:44,470
calls and send

01:32:41,350 --> 01:32:45,460
sends are very simple so input is BPF

01:32:44,470 --> 01:32:47,380
sequences

01:32:45,460 --> 01:32:49,690
I think the OD'ing external symbol

01:32:47,380 --> 01:32:52,360
reference is mapped in bought a moment

01:32:49,690 --> 01:32:54,480
because function the external function

01:32:52,360 --> 01:32:58,750
is adding helper function which is a

01:32:54,480 --> 01:33:01,630
casted into index using because it's

01:32:58,750 --> 01:33:04,720
absolute address so then the us-based

01:33:01,630 --> 01:33:07,860
loader it will create map and during

01:33:04,720 --> 01:33:14,350
that process it redirects instruction to

01:33:07,860 --> 01:33:18,310
the map index and the in the color space

01:33:14,350 --> 01:33:20,670
what you got is sequences with all the

01:33:18,310 --> 01:33:24,040
external reference funding index and

01:33:20,670 --> 01:33:25,960
later in color verifier there is a map

01:33:24,040 --> 01:33:28,300
and a help recorded writer which

01:33:25,960 --> 01:33:30,670
query the runtime system

01:33:28,300 --> 01:33:33,610
query what's the address for the anti

01:33:30,670 --> 01:33:36,640
index than graduate instruction there's

01:33:33,610 --> 01:33:40,860
a PPF instruction with absolute address

01:33:36,640 --> 01:33:44,200
so then after that everything is predict

01:33:40,860 --> 01:33:46,030
then but if there's a PDF to be the call

01:33:44,200 --> 01:33:48,160
I think things are different and because

01:33:46,030 --> 01:33:50,650
currently we are not doing the

01:33:48,160 --> 01:33:54,010
relocation I'm PPF I saw I think this

01:33:50,650 --> 01:33:57,580
flow there's a timer that's because the

01:33:54,010 --> 01:33:59,830
up final address we want is a address on

01:33:57,580 --> 01:34:03,040
the let you image but we don't aging is

01:33:59,830 --> 01:34:06,700
performed on the PPF I saw so but you

01:34:03,040 --> 01:34:08,290
can't know the final address you can

01:34:06,700 --> 01:34:11,890
only know the federal address after you

01:34:08,290 --> 01:34:15,100
finish the code generation so currently

01:34:11,890 --> 01:34:18,670
we've reserved this product SEC using a

01:34:15,100 --> 01:34:20,950
trial run so during verification during

01:34:18,670 --> 01:34:23,800
the pre linking actually we also call

01:34:20,950 --> 01:34:26,860
the jetpack hands to a trial run

01:34:23,800 --> 01:34:30,190
compilation to get the function called

01:34:26,860 --> 01:34:34,000
sub program address then after the

01:34:30,190 --> 01:34:37,240
answer which we which recalls a bank ins

01:34:34,000 --> 01:34:40,930
with all the sub program subprogram

01:34:37,240 --> 01:34:42,850
address to finalize all the addresses so

01:34:40,930 --> 01:34:46,960
you know after the praline King we've

01:34:42,850 --> 01:34:50,610
got PPF sequences has all the tress

01:34:46,960 --> 01:34:53,560
finalized and then after this approach

01:34:50,610 --> 01:34:55,750
largely simplify the chip and hence the

01:34:53,560 --> 01:34:57,580
Jade macarons what you need to do is

01:34:55,750 --> 01:35:00,180
just do one-to-one mapping of

01:34:57,580 --> 01:35:04,330
instructions and those resolves the

01:35:00,180 --> 01:35:08,050
local branch so soul only the PPF

01:35:04,330 --> 01:35:10,510
currently the PPF Jenkins dome needs to

01:35:08,050 --> 01:35:12,580
pass the first pass generate the

01:35:10,510 --> 01:35:14,290
instruction and also decode the

01:35:12,580 --> 01:35:18,670
instruction offsets which will be used

01:35:14,290 --> 01:35:21,430
to reserve local branch but there's one

01:35:18,670 --> 01:35:24,490
thing is BPF I sighs I think it's all

01:35:21,430 --> 01:35:26,620
pieces relative jump or call but at the

01:35:24,490 --> 01:35:29,020
moment the jet Bank and some Bank and

01:35:26,620 --> 01:35:34,060
sperm for example a ox 84 it will turn

01:35:29,020 --> 01:35:37,300
pc-relative go into absolute code using

01:35:34,060 --> 01:35:41,500
VR instruction so to summary for the

01:35:37,300 --> 01:35:41,949
hosted yet I think mostly it's the

01:35:41,500 --> 01:35:44,019
uterus

01:35:41,949 --> 01:35:46,530
this and the color space loaders it

01:35:44,019 --> 01:35:49,989
perform perform various predictions

01:35:46,530 --> 01:35:52,119
based on BPF I saw and mostly the

01:35:49,989 --> 01:35:55,059
protein king using three symbol tables

01:35:52,119 --> 01:35:57,789
with the first one is the map to Memphis

01:35:55,059 --> 01:36:00,429
dress the second is a helper address

01:35:57,789 --> 01:36:04,479
cables of service functional just ebooks

01:36:00,429 --> 01:36:07,539
and Pensions interleave whispered Incan

01:36:04,479 --> 01:36:11,019
because of the flow Dharma mentioned and

01:36:07,539 --> 01:36:12,969
also some Jade penguins generates long

01:36:11,019 --> 01:36:16,449
position dependent code sequences

01:36:12,969 --> 01:36:20,619
because using peer instruction cetera

01:36:16,449 --> 01:36:22,690
and also the final relative image

01:36:20,619 --> 01:36:24,940
generated doesn't contain any indication

01:36:22,690 --> 01:36:27,280
information because we think everything

01:36:24,940 --> 01:36:29,800
ends after the JIT comparison because

01:36:27,280 --> 01:36:32,949
there isn't another those things the

01:36:29,800 --> 01:36:38,110
whole code just runs on the flag then

01:36:32,949 --> 01:36:40,889
for PPF offload sins are a little bit

01:36:38,110 --> 01:36:44,709
different so for standing offload

01:36:40,889 --> 01:36:48,550
actually it's really the same that's

01:36:44,709 --> 01:36:51,900
because what a device 90 covered as the

01:36:48,550 --> 01:36:55,300
offload device allocate maps also

01:36:51,900 --> 01:36:58,539
helpers under the code is color space is

01:36:55,300 --> 01:37:01,900
reserved on the offload the device but

01:36:58,539 --> 01:37:05,079
fix the point so actually for offload so

01:37:01,900 --> 01:37:08,739
for static offload the device drivers

01:37:05,079 --> 01:37:11,619
shielded other addresses for data and

01:37:08,739 --> 01:37:14,530
code before doing the cogeneration which

01:37:11,619 --> 01:37:16,780
means you can also use the same flow as

01:37:14,530 --> 01:37:21,280
the hostage it generally you can predict

01:37:16,780 --> 01:37:25,360
in the PPF you need the PPF object fire

01:37:21,280 --> 01:37:27,969
and the Sun fade the link app EPF object

01:37:25,360 --> 01:37:30,039
to the Jade bank runs to the house the

01:37:27,969 --> 01:37:33,280
data back ends because the host Jenkins

01:37:30,039 --> 01:37:36,940
exactly just expect the input to be free

01:37:33,280 --> 01:37:39,729
of relocated PPF objects so I think the

01:37:36,940 --> 01:37:42,880
only change indeed it is the replace map

01:37:39,729 --> 01:37:46,269
FTE and the effects are PPF call those

01:37:42,880 --> 01:37:49,749
hooks which is used to create to create

01:37:46,269 --> 01:37:53,010
the address based on the input index

01:37:49,749 --> 01:37:55,570
there's hoops maybe this functions maybe

01:37:53,010 --> 01:38:00,310
maybe some tweaks for

01:37:55,570 --> 01:38:03,190
a float then for dynamic offload so

01:38:00,310 --> 01:38:06,490
generally the Cody's the code might be

01:38:03,190 --> 01:38:09,310
allocated by loader at runtime so you

01:38:06,490 --> 01:38:12,790
the device won't flow or the hostess

01:38:09,310 --> 01:38:16,060
I'll won't love the code address before

01:38:12,790 --> 01:38:18,790
the Rayleigh's right but I think at the

01:38:16,060 --> 01:38:21,310
moment most of the hostages if you are

01:38:18,790 --> 01:38:24,520
using those eyes are like armed this

01:38:21,310 --> 01:38:27,130
five you can generate peak sequences so

01:38:24,520 --> 01:38:29,560
actually because data is always play

01:38:27,130 --> 01:38:32,440
allocate it is with fixed address on the

01:38:29,560 --> 01:38:34,720
device that's a TB case so actually if

01:38:32,440 --> 01:38:36,850
your code sequence is peak there still

01:38:34,720 --> 01:38:38,620
there's a low difference with standing

01:38:36,850 --> 01:38:40,660
upload that your image can just be

01:38:38,620 --> 01:38:43,780
offloaded to anywhere then you can't run

01:38:40,660 --> 01:38:45,430
from anywhere it just works so and the

01:38:43,780 --> 01:38:49,960
nurses know needs a long time the

01:38:45,430 --> 01:38:53,560
information so long the example is the

01:38:49,960 --> 01:38:55,810
RFC BPF offload because I refuse a

01:38:53,560 --> 01:38:57,940
little bit complex because we don't have

01:38:55,810 --> 01:39:04,750
this relative jump so everything is the

01:38:57,940 --> 01:39:06,240
absolute jump so we can't do it at the

01:39:04,750 --> 01:39:09,130
moment what we are doing is the way

01:39:06,240 --> 01:39:11,680
remember the map index helper index in

01:39:09,130 --> 01:39:15,460
PPF sequences generally ways we complete

01:39:11,680 --> 01:39:18,550
is keep the PPF reading king happened on

01:39:15,460 --> 01:39:21,670
the hosts aside the way past those index

01:39:18,550 --> 01:39:23,710
tongue to the runtime loader on the

01:39:21,670 --> 01:39:26,710
device the loader actually is and use

01:39:23,710 --> 01:39:28,060
then it and also we encode the

01:39:26,710 --> 01:39:30,340
relocation information in the

01:39:28,060 --> 01:39:34,030
instructions itself because it's lucky

01:39:30,340 --> 01:39:36,520
that RFP instruction is 64 bytes with

01:39:34,030 --> 01:39:38,620
some top beats not used so we use those

01:39:36,520 --> 01:39:40,840
reserved the bit sensor to encode

01:39:38,620 --> 01:39:42,810
relocation information so then we have a

01:39:40,840 --> 01:39:46,180
long time loader on device which can

01:39:42,810 --> 01:39:50,920
relocate the image to dedicate those the

01:39:46,180 --> 01:39:53,950
the jump to the runtime code address so

01:39:50,920 --> 01:39:55,840
which I think if the device driver if

01:39:53,950 --> 01:39:58,770
your PPF offloads

01:39:55,840 --> 01:40:03,400
have complex offload the scenario maybe

01:39:58,770 --> 01:40:06,730
it should follow the same nur flow so to

01:40:03,400 --> 01:40:08,260
summary I think after some use occasion

01:40:06,730 --> 01:40:09,010
I believe the current hostage it

01:40:08,260 --> 01:40:11,550
balanced

01:40:09,010 --> 01:40:14,470
perhaps we used as a floatie Atlantians

01:40:11,550 --> 01:40:16,870
direct2d just with little change because

01:40:14,470 --> 01:40:19,540
the native data and the code are created

01:40:16,870 --> 01:40:22,540
created the same parity so generally

01:40:19,540 --> 01:40:26,530
data you always got a fixed address user

01:40:22,540 --> 01:40:29,170
ways host offload and for the college

01:40:26,530 --> 01:40:33,010
themself could be picked so you can load

01:40:29,170 --> 01:40:35,620
to anywhere and right so maybe there are

01:40:33,010 --> 01:40:37,900
some other scenes mountains entries for

01:40:35,620 --> 01:40:40,120
example for the office yet you need to

01:40:37,900 --> 01:40:42,550
generate some long time long time staff

01:40:40,120 --> 01:40:45,100
examples written from then now you

01:40:42,550 --> 01:40:48,210
should return to some form where exits

01:40:45,100 --> 01:40:51,810
not read not like the whole silicon and

01:40:48,210 --> 01:40:54,760
maybe some runtime error handling so

01:40:51,810 --> 01:40:57,640
generally those things if the device Inc

01:40:54,760 --> 01:41:00,360
us you the expert could expose those

01:40:57,640 --> 01:41:03,400
addresses to upload idiots otherwise

01:41:00,360 --> 01:41:06,250
after the image sphere you need to incur

01:41:03,400 --> 01:41:08,440
the relocation information that could be

01:41:06,250 --> 01:41:11,740
a problem for me before

01:41:08,440 --> 01:41:14,470
or risk of five or arms or two because

01:41:11,740 --> 01:41:16,780
you don't you need an extra header on

01:41:14,470 --> 01:41:21,460
the image which is not nice but I think

01:41:16,780 --> 01:41:25,440
the other choice and so so after all

01:41:21,460 --> 01:41:28,750
this I think severe we need a some minor

01:41:25,440 --> 01:41:31,390
improvements on the current state bank

01:41:28,750 --> 01:41:34,660
runs to make it could be the u s-- lands

01:41:31,390 --> 01:41:36,940
offload bank ins that's because first we

01:41:34,660 --> 01:41:40,990
need to enable multiple jenkins right

01:41:36,940 --> 01:41:41,890
because the offloading scenario is host

01:41:40,990 --> 01:41:43,990
to x86

01:41:41,890 --> 01:41:46,840
for example you can and you can have

01:41:43,990 --> 01:41:50,350
multiple of the device and definitely

01:41:46,840 --> 01:41:52,870
you want enable several bank runs at a

01:41:50,350 --> 01:41:56,920
moment of a OD'ing being able the host

01:41:52,870 --> 01:42:00,340
bank runs so the solution is I think we

01:41:56,920 --> 01:42:02,770
can split the PPF in each camp fire into

01:42:00,340 --> 01:42:07,570
EPF intelligent compiler plus the

01:42:02,770 --> 01:42:10,150
architect arc compiler so then for if

01:42:07,570 --> 01:42:13,120
there's no offload bus in changed it's

01:42:10,150 --> 01:42:16,120
the same strong symbol override and weak

01:42:13,120 --> 01:42:19,870
simple technology we used but if there's

01:42:16,120 --> 01:42:22,900
offload so generally the because we

01:42:19,870 --> 01:42:27,310
split the interface fire into two

01:42:22,900 --> 01:42:30,280
so also the user can use extra config to

01:42:27,310 --> 01:42:32,530
enable the beauty of a particular bank

01:42:30,280 --> 01:42:35,860
and for the namco risk of five and the

01:42:32,530 --> 01:42:38,080
moment I think the Jade PPF Bank hand is

01:42:35,860 --> 01:42:41,770
quite independent and you don't need to

01:42:38,080 --> 01:42:44,320
build us the Holy Ark that fire me can

01:42:41,770 --> 01:42:47,560
self stand you can just beauty just

01:42:44,320 --> 01:42:51,750
Beauty it with some simple Hellfire

01:42:47,560 --> 01:42:54,880
included so then the other thing is just

01:42:51,750 --> 01:42:58,300
there has some space to improve in the

01:42:54,880 --> 01:43:00,790
bank lends itself for example I think I

01:42:58,300 --> 01:43:03,820
feel we should try to generate peacoat

01:43:00,790 --> 01:43:06,940
as much as possible if the distance

01:43:03,820 --> 01:43:09,130
fades into the encoding or so it's

01:43:06,940 --> 01:43:10,930
better with just the bank and that yet

01:43:09,130 --> 01:43:13,450
Bank ins just to cut gene you don't

01:43:10,930 --> 01:43:15,730
don't do those longtime staff for

01:43:13,450 --> 01:43:18,520
example I cache wash those things may be

01:43:15,730 --> 01:43:21,570
refactored to some other hook out into

01:43:18,520 --> 01:43:24,520
it if you want to run it on the host and

01:43:21,570 --> 01:43:29,080
certain is made probably we can split

01:43:24,520 --> 01:43:32,740
compilation and linking because this has

01:43:29,080 --> 01:43:36,250
released us from the dharma of zhang the

01:43:32,740 --> 01:43:39,490
the verifier try wrong the interleaving

01:43:36,250 --> 01:43:43,450
of ridiculous accommodation so maybe

01:43:39,490 --> 01:43:48,220
also can make the the empire link stage

01:43:43,450 --> 01:43:50,560
more clean maybe oh yeah so just some

01:43:48,220 --> 01:43:54,220
basic ideas because I think the link

01:43:50,560 --> 01:43:56,920
hook can be just have an input real

01:43:54,220 --> 01:44:00,730
October program with three simple table

01:43:56,920 --> 01:44:03,910
or can be comparing two one so you just

01:44:00,730 --> 01:44:06,190
relocate using the index map index every

01:44:03,910 --> 01:44:10,360
index you query the table your new

01:44:06,190 --> 01:44:12,580
divides the image but the difference is

01:44:10,360 --> 01:44:15,430
now the linking where happened on the

01:44:12,580 --> 01:44:17,800
lady I saw instead of PPR PPF I so the

01:44:15,430 --> 01:44:22,810
linking should the link hook should be

01:44:17,800 --> 01:44:26,170
implemented for all the back ends so and

01:44:22,810 --> 01:44:28,000
also offload the infrastructure because

01:44:26,170 --> 01:44:30,340
professor are talking about seedbank

01:44:28,000 --> 01:44:32,080
hands but it's uploaded yet so also

01:44:30,340 --> 01:44:34,360
there's offloading infrastructure so

01:44:32,080 --> 01:44:36,429
this infrastructure could be improved

01:44:34,360 --> 01:44:38,949
slightly for

01:44:36,429 --> 01:44:40,980
if we are uploading generic at risk by

01:44:38,949 --> 01:44:43,179
processor because I think the

01:44:40,980 --> 01:44:45,670
infrastructure was delightful and if

01:44:43,179 --> 01:44:48,070
unless he offload its for example to

01:44:45,670 --> 01:44:51,370
bypass the whole report linking but for

01:44:48,070 --> 01:44:53,710
and stoked for generic offload wispier

01:44:51,370 --> 01:44:55,540
could use the same flow we could we

01:44:53,710 --> 01:44:57,820
could still go through those the same

01:44:55,540 --> 01:45:00,850
code so it's a little bit over cleaning

01:44:57,820 --> 01:45:02,770
we can improve and also the current

01:45:00,850 --> 01:45:05,469
offload the infrastructure was more or

01:45:02,770 --> 01:45:07,659
less desired for late device maybe if we

01:45:05,469 --> 01:45:10,690
want we have some other offload the

01:45:07,659 --> 01:45:13,679
scenario maybe it's simpler we don't

01:45:10,690 --> 01:45:17,380
need a selective structure those things

01:45:13,679 --> 01:45:19,810
so finally it's a hardware software

01:45:17,380 --> 01:45:23,050
prototyping so bedroom has a risk of

01:45:19,810 --> 01:45:27,190
five based as Monique so that's the

01:45:23,050 --> 01:45:29,620
generally it's matakohe it's a

01:45:27,190 --> 01:45:33,640
multi-core design with trans actually

01:45:29,620 --> 01:45:36,610
memory too easy the the sync between

01:45:33,640 --> 01:45:39,130
multi cause so I'm not going to guess in

01:45:36,610 --> 01:45:41,440
details because from having to say so

01:45:39,130 --> 01:45:43,870
just slides you can if you're interested

01:45:41,440 --> 01:45:46,780
you can check and generally it's a

01:45:43,870 --> 01:45:49,000
simple it's a standard risk five thirty

01:45:46,780 --> 01:45:52,929
two-bit with the integer and compressed

01:45:49,000 --> 01:45:56,340
instruction sets and weighs like forty

01:45:52,929 --> 01:45:59,590
sixty hook a instruction memory and

01:45:56,340 --> 01:46:03,480
standing and you can use it for stank

01:45:59,590 --> 01:46:07,420
and for code those things so we've got

01:46:03,480 --> 01:46:10,300
FPGA implementation and currently our

01:46:07,420 --> 01:46:13,120
model is the forty because a program

01:46:10,300 --> 01:46:15,790
model is you just write a say program

01:46:13,120 --> 01:46:18,280
you compile using stand it uses your

01:46:15,790 --> 01:46:20,980
standard let's go five to do to a change

01:46:18,280 --> 01:46:27,610
into a I have fire then you can use F

01:46:20,980 --> 01:46:32,590
GDB GDB GDB or F wrong to load it to the

01:46:27,610 --> 01:46:34,420
to talk to the gdb Jemma stop on a few

01:46:32,590 --> 01:46:37,480
GM controllers and the remote stop

01:46:34,420 --> 01:46:39,820
offloaded syncs to the FPGA cause those

01:46:37,480 --> 01:46:43,210
risk of F course then for the BPF

01:46:39,820 --> 01:46:45,340
offload its things are much complex much

01:46:43,210 --> 01:46:47,100
more complex or so we need to worry if I

01:46:45,340 --> 01:46:50,019
generally were if I to since first is

01:46:47,100 --> 01:46:52,809
offloaded one way to use risk five

01:46:50,019 --> 01:46:56,709
DBF Bank and it generates correct image

01:46:52,809 --> 01:46:58,959
secondly is the PPF program works so for

01:46:56,709 --> 01:47:01,749
the first part we are my thoughts

01:46:58,959 --> 01:47:03,760
actually is we implemented Ameen that

01:47:01,749 --> 01:47:06,459
they've driver implement all those

01:47:03,760 --> 01:47:10,449
necessary hooks though then we have a

01:47:06,459 --> 01:47:14,769
PPF program I have the same airway m2

01:47:10,449 --> 01:47:16,899
actions and the theory map during the I

01:47:14,769 --> 01:47:19,809
think it's you displace another leave

01:47:16,899 --> 01:47:23,559
EPF and create map with radiation memory

01:47:19,809 --> 01:47:27,610
create two networking requests to the

01:47:23,559 --> 01:47:31,989
GDP stop athlete to create map on the fe

01:47:27,610 --> 01:47:34,899
j RF you see then we talk we keep going

01:47:31,989 --> 01:47:37,300
down talk to the car driver and ask you

01:47:34,899 --> 01:47:41,679
to drive the whole way through five jet

01:47:37,300 --> 01:47:44,559
a bank hands to generate the translated

01:47:41,679 --> 01:47:47,469
PDF image data we use BPF tour to

01:47:44,559 --> 01:47:49,629
graduate the translated image but then

01:47:47,469 --> 01:47:51,820
ready to turn it in because it's raw

01:47:49,629 --> 01:47:55,479
instruction we turn it to a loadable elf

01:47:51,820 --> 01:47:57,999
then we use the same Efron or gdb to

01:47:55,479 --> 01:48:01,780
talk to the limo stop asked me to to

01:47:57,999 --> 01:48:04,209
inject the code to the RF is a to the to

01:48:01,780 --> 01:48:06,789
the offloaded code and offload code

01:48:04,209 --> 01:48:08,829
should have a pre-installed firmware

01:48:06,789 --> 01:48:12,129
which is just keep pulling the events

01:48:08,829 --> 01:48:14,439
then once it says there is a remote stop

01:48:12,129 --> 01:48:18,389
injected the BBF code it jump to the

01:48:14,439 --> 01:48:21,550
code and also we need a emulation

01:48:18,389 --> 01:48:25,419
package generator on running on the arm

01:48:21,550 --> 01:48:27,399
port to generate packets so it kept

01:48:25,419 --> 01:48:29,919
actually it may be just write something

01:48:27,399 --> 01:48:33,159
to some shared memories a PPA programs

01:48:29,919 --> 01:48:35,530
and fetch the packets from there so the

01:48:33,159 --> 01:48:38,619
whole thing is because country we finish

01:48:35,530 --> 01:48:40,629
the RTC the risk of echo side the

01:48:38,619 --> 01:48:43,059
periphery the networking stuff we're

01:48:40,629 --> 01:48:46,659
still catching up so we can reuse the

01:48:43,059 --> 01:48:51,389
lessons to emanate so yeah that's pretty

01:48:46,659 --> 01:48:54,539
much everything I want to share today so

01:48:51,389 --> 01:48:54,539
adding questions

01:49:00,010 --> 01:49:09,460
well if no one does I have a question so

01:49:06,700 --> 01:49:11,440
I think if we like in general there I

01:49:09,460 --> 01:49:14,800
really liked the idea of having more

01:49:11,440 --> 01:49:16,870
than one JIT compiled into the kernel

01:49:14,800 --> 01:49:18,489
because I think we've talked about it

01:49:16,870 --> 01:49:20,739
before it will help testing like

01:49:18,489 --> 01:49:23,080
tremendously all the different Jets but

01:49:20,739 --> 01:49:28,480
if we do it we should do it not only for

01:49:23,080 --> 01:49:30,370
the risk 5 JIT but for x86 as well so

01:49:28,480 --> 01:49:32,200
like because every time we do it

01:49:30,370 --> 01:49:34,180
something like special for like in a few

01:49:32,200 --> 01:49:37,510
specific or a risk 5 SP like whatever

01:49:34,180 --> 01:49:41,590
it's just not the draw so if we do it

01:49:37,510 --> 01:49:44,890
this type of peak style the JIT

01:49:41,590 --> 01:49:50,170
generation should be done for x86 as a

01:49:44,890 --> 01:49:53,050
as a minimum then another it had like

01:49:50,170 --> 01:49:57,520
while talking to would really need to do

01:49:53,050 --> 01:49:59,950
this pig code cannot be instead as a

01:49:57,520 --> 01:50:02,380
done as a set of callbacks into the JIT

01:49:59,950 --> 01:50:04,630
because in the end when this let's say

01:50:02,380 --> 01:50:06,640
this is risk 5 g generating the stuff

01:50:04,630 --> 01:50:11,410
and father float in the generated code

01:50:06,640 --> 01:50:13,540
moving into the processors the processor

01:50:11,410 --> 01:50:15,070
know where they will move it to so it

01:50:13,540 --> 01:50:18,190
can be done as a callback they will

01:50:15,070 --> 01:50:20,950
provide that cheated that it will be in

01:50:18,190 --> 01:50:22,960
that memory and like talk to me through

01:50:20,950 --> 01:50:24,220
the callbacks for every decision you

01:50:22,960 --> 01:50:26,470
need to make in terms of where all the

01:50:24,220 --> 01:50:31,989
helpers are instead of doing it a later

01:50:26,470 --> 01:50:35,140
phase as the serial locations okay so

01:50:31,989 --> 01:50:39,190
you mean pick color is not necessary

01:50:35,140 --> 01:50:41,560
right well it's kind of pig code but not

01:50:39,190 --> 01:50:45,790
quite so I was just hoping maybe it will

01:50:41,560 --> 01:50:46,720
be simple instead of doing take ok yeah

01:50:45,790 --> 01:50:49,989
it's possible

01:50:46,720 --> 01:50:53,710
yeah I just cannot think chica is a good

01:50:49,989 --> 01:50:55,960
you can just run to anywhere given the

01:50:53,710 --> 01:50:59,080
data we don't the data is always I think

01:50:55,960 --> 01:51:01,660
a fixed you won't move it and you always

01:50:59,080 --> 01:51:09,489
know the address of a data for any

01:51:01,660 --> 01:51:12,130
scenario at the moment so yeah yeah the

01:51:09,489 --> 01:51:13,640
olden problem are trying to is for

01:51:12,130 --> 01:51:17,840
example RFP portal

01:51:13,640 --> 01:51:20,810
it's absolute jump so we don't have puke

01:51:17,840 --> 01:51:23,150
out so we need some extra relocation

01:51:20,810 --> 01:51:25,550
when we need a runtime loader I think

01:51:23,150 --> 01:51:29,210
this issue can be actually simplified

01:51:25,550 --> 01:51:32,000
for other architectures okay one last

01:51:29,210 --> 01:51:34,280
question from so what's the point in

01:51:32,000 --> 01:51:36,860
having the jet for another architecture

01:51:34,280 --> 01:51:41,690
at the kernel level why isn't it at a in

01:51:36,860 --> 01:51:43,580
user space I can probably answer just to

01:51:41,690 --> 01:51:45,080
reuse because it's already written it's

01:51:43,580 --> 01:51:47,000
already in the column yeah but that same

01:51:45,080 --> 01:51:48,860
code could be ported to user space and

01:51:47,000 --> 01:51:56,510
be used independently as a user space

01:51:48,860 --> 01:52:01,430
process it's you could basically upload

01:51:56,510 --> 01:52:03,530
a row buyer already jittered byte code

01:52:01,430 --> 01:52:06,080
right that bypasses all the JIT

01:52:03,530 --> 01:52:16,550
infrastructure and just yet gets pushed

01:52:06,080 --> 01:52:18,410
to the the other system the verifier

01:52:16,550 --> 01:52:19,070
could be in user space I mean the kernel

01:52:18,410 --> 01:52:20,960
verifiers

01:52:19,070 --> 01:52:22,130
provides integrity for a kernel but

01:52:20,960 --> 01:52:25,310
you're shipping to a different system

01:52:22,130 --> 01:52:27,380
anyway so I mean what system it's in

01:52:25,310 --> 01:52:30,140
Nick on the same system you pushing it

01:52:27,380 --> 01:52:31,970
down so we already did the verification

01:52:30,140 --> 01:52:33,770
yeah but can you upload this as are you

01:52:31,970 --> 01:52:38,630
simple user rules or is it limited to

01:52:33,770 --> 01:52:40,310
route anyway I think we have the table

01:52:38,630 --> 01:52:42,200
but I don't know what I did is I started

01:52:40,310 --> 01:52:45,730
a joke but we waited five five five

01:52:42,200 --> 01:52:45,730
minute dollar okay

01:52:56,970 --> 01:53:01,410
we'll talk more in my presentation

01:53:24,140 --> 01:53:33,270
okay I'll get going I think cuz we're

01:53:27,810 --> 01:53:34,950
sure in time so this more or less comes

01:53:33,270 --> 01:53:36,990
from some work we did about a year ago

01:53:34,950 --> 01:53:39,870
with junk where we actually put a full

01:53:36,990 --> 01:53:41,670
CFG in the fire fire and found all the

01:53:39,870 --> 01:53:44,070
loops and verified that the loops were

01:53:41,670 --> 01:53:45,570
also natural loops and then sort of

01:53:44,070 --> 01:53:46,710
brute forced through the loops to verify

01:53:45,570 --> 01:53:49,500
they terminated a bunch of safety

01:53:46,710 --> 01:53:53,570
properties about them and then this is a

01:53:49,500 --> 01:53:58,110
better version of that so so we use skip

01:53:53,570 --> 01:53:58,710
skip is a a pass in both the LLVM and

01:53:58,110 --> 01:54:01,080
GCC

01:53:58,710 --> 01:54:02,730
if you don't know what it does the basic

01:54:01,080 --> 01:54:05,820
idea is to understand how variables

01:54:02,730 --> 01:54:07,650
change with execution so and you can

01:54:05,820 --> 01:54:10,740
find it in most optimizing compilers so

01:54:07,650 --> 01:54:12,660
I've they'll have a pass for this but to

01:54:10,740 --> 01:54:15,360
make it a little more concrete generally

01:54:12,660 --> 01:54:17,190
it's used on loops to sort of establish

01:54:15,360 --> 01:54:18,990
a set of conditions on the loop so the

01:54:17,190 --> 01:54:20,730
primarily so you can pull induction

01:54:18,990 --> 01:54:23,370
variables outside of the loops and

01:54:20,730 --> 01:54:25,710
optimize the loop case which we're going

01:54:23,370 --> 01:54:28,200
to use it here for is to establish that

01:54:25,710 --> 01:54:33,090
the loops terminate and that memory

01:54:28,200 --> 01:54:34,680
accesses are bounded so because we only

01:54:33,090 --> 01:54:36,240
have a limited time I think the best way

01:54:34,680 --> 01:54:38,040
to go about it is rather than it rather

01:54:36,240 --> 01:54:40,010
than try to establish what's cavities

01:54:38,040 --> 01:54:42,480
and there's not and go through sort of

01:54:40,010 --> 01:54:44,340
theoretical points I think the best way

01:54:42,480 --> 01:54:46,650
it is to just do an example and then

01:54:44,340 --> 01:54:50,700
show how that works with BPF and we'll

01:54:46,650 --> 01:54:50,910
go from there so this is a simple for

01:54:50,700 --> 01:54:53,640
loop

01:54:50,910 --> 01:54:56,070
I actually just cut it out of one of the

01:54:53,640 --> 01:54:58,260
examples in the PPF samples program and

01:54:56,070 --> 01:55:01,230
actually if just for simplicity I think

01:54:58,260 --> 01:55:02,880
the one in the actual kernel code base

01:55:01,230 --> 01:55:05,790
actually has a for loop inside of it but

01:55:02,880 --> 01:55:06,870
I cut it out because then we would have

01:55:05,790 --> 01:55:10,710
to talk about that as well and this is

01:55:06,870 --> 01:55:12,450
fits on one slide easier so once you run

01:55:10,710 --> 01:55:14,730
that through stealing into an object

01:55:12,450 --> 01:55:17,790
dump here's the here's the code that it

01:55:14,730 --> 01:55:20,040
generates one thing to note is we added

01:55:17,790 --> 01:55:22,290
a new instruction called in loop which

01:55:20,040 --> 01:55:25,140
denotes where the end of the for loop is

01:55:22,290 --> 01:55:28,380
so it is basically the bottom of this

01:55:25,140 --> 01:55:29,730
for them the reason we did that so in

01:55:28,380 --> 01:55:31,710
the original code we had to find all of

01:55:29,730 --> 01:55:32,460
the loops and this means you have to

01:55:31,710 --> 01:55:34,890
build a full

01:55:32,460 --> 01:55:36,420
configuration control flow graph and

01:55:34,890 --> 01:55:37,710
then you have to walk through that and

01:55:36,420 --> 01:55:39,030
try to decide what are what are good

01:55:37,710 --> 01:55:41,730
loops and bad loops that you can even

01:55:39,030 --> 01:55:43,620
verify so instead of doing that in the

01:55:41,730 --> 01:55:47,010
verifier in the kernel we do this in

01:55:43,620 --> 01:55:48,960
LLVM as a back-end and part of the BPF

01:55:47,010 --> 01:55:51,570
back-end and then we can insert this

01:55:48,960 --> 01:55:52,650
extra instruction here and then when we

01:55:51,570 --> 01:55:55,050
want to JIT and actually run this

01:55:52,650 --> 01:55:57,060
program we just no op that out it gets

01:55:55,050 --> 01:55:59,340
removed and it's no longer there I think

01:55:57,060 --> 01:56:01,080
if another option would be to use btf

01:55:59,340 --> 01:56:04,739
for this probably and annotate it and

01:56:01,080 --> 01:56:07,380
not have an extra instruction but oh

01:56:04,739 --> 01:56:09,060
well so that's what we have for now and

01:56:07,380 --> 01:56:11,120
so what I want to do is walk through

01:56:09,060 --> 01:56:13,890
what the verifier does with this code

01:56:11,120 --> 01:56:15,660
where we're gonna start is the verifier

01:56:13,890 --> 01:56:19,350
has run through all of this code is

01:56:15,660 --> 01:56:22,230
doing it's sort of execution of the code

01:56:19,350 --> 01:56:23,640
and it just tripped on the in loop so in

01:56:22,230 --> 01:56:24,870
this big switch statement that analyzes

01:56:23,640 --> 01:56:26,760
the instructions as you walk through

01:56:24,870 --> 01:56:28,710
them it goes oh this is an in loop

01:56:26,760 --> 01:56:30,930
instruction and so the instruction

01:56:28,710 --> 01:56:33,810
pointer points at that if statement

01:56:30,930 --> 01:56:35,370
right above it the instruction count is

01:56:33,810 --> 01:56:37,610
whatever line number that is right there

01:56:35,370 --> 01:56:40,980
so the first thing it's going to do is

01:56:37,610 --> 01:56:42,450
follow that go-to and it's going to

01:56:40,980 --> 01:56:44,910
start doing its calves analysis so what

01:56:42,450 --> 01:56:47,730
it's doing is it creates a array of all

01:56:44,910 --> 01:56:49,710
of the registers that the system has

01:56:47,730 --> 01:56:50,760
along with all the stack slots because

01:56:49,710 --> 01:56:53,820
we can push things in and out of the

01:56:50,760 --> 01:56:55,650
stack and so I mean the first thing it

01:56:53,820 --> 01:56:59,850
does is then says ok that's a read move

01:56:55,650 --> 01:57:02,310
of R 2 to R 5 on so we're basically just

01:56:59,850 --> 01:57:05,040
trying to trace all of the flows through

01:57:02,310 --> 01:57:07,230
this for loop alright so we can keep

01:57:05,040 --> 01:57:09,330
walking through this list and we can go

01:57:07,230 --> 01:57:11,160
and create what these are called scav

01:57:09,330 --> 01:57:15,810
expressions here and the way to read

01:57:11,160 --> 01:57:19,230
those the R 5 r v r0 is at each step as

01:57:15,810 --> 01:57:21,690
we go R 5 was first move an R 2 move

01:57:19,230 --> 01:57:24,150
into our five and then we have another

01:57:21,690 --> 01:57:26,640
move but we ended it with one and the

01:57:24,150 --> 01:57:30,630
underscore at the beginning is is meant

01:57:26,640 --> 01:57:35,400
to be the the initial condition of that

01:57:30,630 --> 01:57:37,260
register but because in the I guess

01:57:35,400 --> 01:57:39,120
technically we know it but when this

01:57:37,260 --> 01:57:41,160
code is being executed in the verifier

01:57:39,120 --> 01:57:44,910
that I wrote here I just leave it blank

01:57:41,160 --> 01:57:45,690
and we'll fill it in at the end and so

01:57:44,910 --> 01:57:47,160
the next

01:57:45,690 --> 01:57:49,260
problem we have is we've just ran to an

01:57:47,160 --> 01:57:50,699
if if statement and we don't have like

01:57:49,260 --> 01:57:51,900
proper fee nodes and all this kind of

01:57:50,699 --> 01:57:54,239
stuff my notes that we would have in

01:57:51,900 --> 01:57:57,030
like a real compiler so what we're going

01:57:54,239 --> 01:57:59,219
to do is walk each possible branch in

01:57:57,030 --> 01:58:01,230
the code and basically what we do is we

01:57:59,219 --> 01:58:04,410
get a trace through the code of every

01:58:01,230 --> 01:58:07,500
possible control flow possibility from

01:58:04,410 --> 01:58:10,710
the start of the loop back through it so

01:58:07,500 --> 01:58:13,530
we'll continue and because this was a go

01:58:10,710 --> 01:58:15,360
to the lob zero underscore three there

01:58:13,530 --> 01:58:18,690
we jump back over onto that side to

01:58:15,360 --> 01:58:23,640
start running this trace and you can see

01:58:18,690 --> 01:58:25,110
we have somewhere R 0 R 0 R 2 R 5 and

01:58:23,640 --> 01:58:30,050
we're just kind of doing the same thing

01:58:25,110 --> 01:58:32,699
and if we get multiple like multiple

01:58:30,050 --> 01:58:35,400
sorry look at like R 0 for example where

01:58:32,699 --> 01:58:39,510
we've done multiple move and then we did

01:58:35,400 --> 01:58:41,340
a multiplication or and then an addition

01:58:39,510 --> 01:58:43,770
so we just keep tacking those on and

01:58:41,340 --> 01:58:49,050
that's actually kept as a sort of a tree

01:58:43,770 --> 01:58:52,410
data structure as you walk through with

01:58:49,050 --> 01:58:56,570
one a little bit of complication here so

01:58:52,410 --> 01:58:59,730
when we do a move we want to both keep

01:58:56,570 --> 01:59:01,230
the register that's being moved in

01:58:59,730 --> 01:59:03,570
because we need that for the initial

01:59:01,230 --> 01:59:05,460
conditions but we also copy all of the

01:59:03,570 --> 01:59:07,920
state from the last one so that when

01:59:05,460 --> 01:59:09,780
we're looking at this we can say well R

01:59:07,920 --> 01:59:12,330
5 at this point is really whatever its

01:59:09,780 --> 01:59:18,930
initial state is plus 1 because it's a

01:59:12,330 --> 01:59:20,760
it's a assignment from R to okay now the

01:59:18,930 --> 01:59:22,800
next thing that is a bit odd in this

01:59:20,760 --> 01:59:24,630
trace because I didn't try to dr. this

01:59:22,800 --> 01:59:27,360
trace too much to make it nice is it has

01:59:24,630 --> 01:59:32,010
these shift left and shift right it's

01:59:27,360 --> 01:59:33,390
just clearing some bits but it's a bit

01:59:32,010 --> 01:59:37,260
ugly from trying to understand what's

01:59:33,390 --> 01:59:40,110
going on so we just sort of thing walk

01:59:37,260 --> 01:59:43,890
those through and then eventually you

01:59:40,110 --> 01:59:45,750
get down to the condition I'll just skip

01:59:43,890 --> 01:59:48,480
through that so at this point we've

01:59:45,750 --> 01:59:49,890
walked an entire trace sorry so effect

01:59:48,480 --> 01:59:53,940
we've walked an entire trace through the

01:59:49,890 --> 01:59:57,960
for loop we pushed a when we did that if

01:59:53,940 --> 01:59:59,159
statement in the LB B 0 1 over here on

01:59:57,960 --> 02:00:00,570
the right we've

01:59:59,159 --> 02:00:02,099
sigelei push something on our stack of

02:00:00,570 --> 02:00:04,559
traces so that we know to pop it and go

02:00:02,099 --> 02:00:06,809
back and finish that trace later but

02:00:04,559 --> 02:00:09,179
what we got what we get when we come out

02:00:06,809 --> 02:00:11,729
of this and I didn't prick I don't have

02:00:09,179 --> 02:00:13,079
any stack loads or stores here so we're

02:00:11,729 --> 02:00:15,659
not worried about the stack it's

02:00:13,079 --> 02:00:17,070
basically the output of the verifier

02:00:15,659 --> 02:00:18,510
that we push into the log if we're

02:00:17,070 --> 02:00:20,099
running in and like a verbose mode and

02:00:18,510 --> 02:00:21,809
what it's that what is showing is

02:00:20,099 --> 02:00:25,619
basically the state of all the registers

02:00:21,809 --> 02:00:27,329
that it knows about and what you can see

02:00:25,619 --> 02:00:29,099
from back here is the one we're gonna

02:00:27,329 --> 02:00:31,139
actually care about is our five and if

02:00:29,099 --> 02:00:32,400
you look at our five it has an unknown

02:00:31,139 --> 02:00:35,130
initial state so we haven't plugged that

02:00:32,400 --> 02:00:40,860
in but it's adding 1 to it if you look

02:00:35,130 --> 02:00:42,719
back here to the for loop you can you

02:00:40,860 --> 02:00:44,969
can see it clear that it see that from

02:00:42,719 --> 02:00:51,570
the j equals 0 j less than 300 j plus

02:00:44,969 --> 02:00:52,650
plus the other thing to note about this

02:00:51,570 --> 02:00:54,479
and I think I have a slide is I

02:00:52,650 --> 02:00:56,010
highlighted it here is I didn't actually

02:00:54,479 --> 02:00:58,739
implement the logic to handle

02:00:56,010 --> 02:00:59,969
multiplication in this example in the

02:00:58,739 --> 02:01:02,039
code and the verifier code that's

02:00:59,969 --> 02:01:03,749
running this example and so what it did

02:01:02,039 --> 02:01:06,749
is it just marked it as unknown instead

02:01:03,749 --> 02:01:08,369
of a proper add instruction and

02:01:06,749 --> 02:01:10,639
basically that means I have airfyer lost

02:01:08,369 --> 02:01:12,929
track of what that register is doing so

02:01:10,639 --> 02:01:14,579
that's sort of its way to back out of

02:01:12,929 --> 02:01:16,469
not knowing what's going on if these

02:01:14,579 --> 02:01:17,639
discretions get too complicated or your

02:01:16,469 --> 02:01:19,019
data structure starts using too much

02:01:17,639 --> 02:01:20,070
memory eventually just go throw your

02:01:19,019 --> 02:01:24,749
hands up and go I don't know what's

02:01:20,070 --> 02:01:27,209
going on so market is unknown all right

02:01:24,749 --> 02:01:28,829
so now we have that that table and the

02:01:27,209 --> 02:01:30,449
important one from the table is the reg

02:01:28,829 --> 02:01:32,039
number five because if we looked at the

02:01:30,449 --> 02:01:34,380
if statement here we have our 5 does not

02:01:32,039 --> 02:01:36,570
equal 300 all right and so then we can

02:01:34,380 --> 02:01:38,130
ask some things about our 5 looking at

02:01:36,570 --> 02:01:41,309
this register kind of a very simple

02:01:38,130 --> 02:01:42,900
example but but perhaps useful is we can

02:01:41,309 --> 02:01:44,189
say is our 5 monotonic mean it doesn't

02:01:42,900 --> 02:01:46,979
decide to go increase and then decrease

02:01:44,189 --> 02:01:48,209
and then go back up or any so on and we

02:01:46,979 --> 02:01:50,159
can say yes this is always increasing

02:01:48,209 --> 02:01:51,269
because it's an ad by one and if there

02:01:50,159 --> 02:01:52,320
were multiple instructions in there

02:01:51,269 --> 02:01:53,669
basically you could walk through that

02:01:52,320 --> 02:01:54,599
entire expression though it's an ad by

02:01:53,669 --> 02:01:56,249
1/2

02:01:54,599 --> 02:01:57,900
it's a multiplied by 3 well that's

02:01:56,249 --> 02:01:59,699
always going to be increasing so we say

02:01:57,900 --> 02:02:02,389
it's monotonic then the next thing you

02:01:59,699 --> 02:02:04,169
can say is well what is the trip count

02:02:02,389 --> 02:02:05,729
so you want to know how many times are

02:02:04,169 --> 02:02:07,050
going to go through this loop well this

02:02:05,729 --> 02:02:09,599
is a pretty simple case but it's ad by

02:02:07,050 --> 02:02:11,699
one and it's comparing it to 300 you can

02:02:09,599 --> 02:02:12,900
do a little logic on this and say ok

02:02:11,699 --> 02:02:15,570
well we know the trip count

02:02:12,900 --> 02:02:16,949
good and there was no memory accesses

02:02:15,570 --> 02:02:19,770
and this one so we can say its memory

02:02:16,949 --> 02:02:23,580
safe I'll talk a little bit about

02:02:19,770 --> 02:02:25,280
Montgomery safety later another just a

02:02:23,580 --> 02:02:28,590
quick comment about scaffolding

02:02:25,280 --> 02:02:30,150
scaffolding refers to like if we go back

02:02:28,590 --> 02:02:31,199
here we see that we have an ad by one

02:02:30,150 --> 02:02:33,540
but if you were to add by another

02:02:31,199 --> 02:02:35,190
register there's a process called

02:02:33,540 --> 02:02:37,619
scaffolding which has a bunch of

02:02:35,190 --> 02:02:40,050
equations on how to handle that so it's

02:02:37,619 --> 02:02:41,580
stuff like LLVM has a big table and you

02:02:40,050 --> 02:02:43,290
know how to handle two registers being

02:02:41,580 --> 02:02:46,920
added or register being multiplied or a

02:02:43,290 --> 02:02:48,300
constant and so on and the other thing

02:02:46,920 --> 02:02:49,860
we always have is if those get to it

02:02:48,300 --> 02:02:54,300
complicated we just bail out and say we

02:02:49,860 --> 02:02:56,310
don't know what's going on so the next

02:02:54,300 --> 02:02:58,050
trick and that didn't pop up on that

02:02:56,310 --> 02:02:59,580
example because it was a pretty simple

02:02:58,050 --> 02:03:03,570
example was how do we deal with memory

02:02:59,580 --> 02:03:05,310
safety what what the code will do any

02:03:03,570 --> 02:03:06,929
time it sees a read or write into memory

02:03:05,310 --> 02:03:08,820
it'll push the entire state of the

02:03:06,929 --> 02:03:11,159
register stack there and then once you

02:03:08,820 --> 02:03:13,409
know the trip count you can see all of

02:03:11,159 --> 02:03:16,050
the values of say if it's if it's a

02:03:13,409 --> 02:03:17,550
pretty simple index by eye and back in

02:03:16,050 --> 02:03:21,420
our for loop here for example if it was

02:03:17,550 --> 02:03:24,210
J I'm not gonna jump too far back there

02:03:21,420 --> 02:03:26,550
if it was reg 5 and we knew that reg 5

02:03:24,210 --> 02:03:28,770
was accessing a memory we would know all

02:03:26,550 --> 02:03:30,480
of the possible indexes into that array

02:03:28,770 --> 02:03:37,170
so we could get the bounds from the trip

02:03:30,480 --> 02:03:39,270
counts as well that was that the next

02:03:37,170 --> 02:03:41,010
trick is that we don't just have

02:03:39,270 --> 02:03:42,840
registers we also have the stack so you

02:03:41,010 --> 02:03:44,250
have to do a little extra complicated

02:03:42,840 --> 02:03:47,489
stuff to push things into and out of the

02:03:44,250 --> 02:03:49,530
stack basically what that means is when

02:03:47,489 --> 02:03:50,909
you say reg 5 you need to know if it's

02:03:49,530 --> 02:03:54,360
actually a slot on the stack that you're

02:03:50,909 --> 02:03:57,690
reading or not yeah good first question

02:03:54,360 --> 02:03:59,760
if you have a trip count that is odd and

02:03:57,690 --> 02:04:05,639
you increment by something that is even

02:03:59,760 --> 02:04:08,580
yes how do you end all that so in the in

02:04:05,639 --> 02:04:10,290
the knot equals here there's there's

02:04:08,580 --> 02:04:14,130
either special cases not even in this

02:04:10,290 --> 02:04:15,540
case not equals a sort of an annoying

02:04:14,130 --> 02:04:17,070
one to deal with so you have special

02:04:15,540 --> 02:04:18,960
cases but they're less than and greater

02:04:17,070 --> 02:04:20,670
than it gets much nicer right except if

02:04:18,960 --> 02:04:22,639
you have overflows how do you deal with

02:04:20,670 --> 02:04:26,460
those so we already have overflow

02:04:22,639 --> 02:04:27,720
precision in our in the bear fire itself

02:04:26,460 --> 02:04:29,280
and basically it says I don't know what

02:04:27,720 --> 02:04:31,020
this is anymore and basically when you

02:04:29,280 --> 02:04:33,870
get here and you go oh what is that what

02:04:31,020 --> 02:04:36,120
are the what are the min/max signed or

02:04:33,870 --> 02:04:37,950
unsigned values it'll say unknown and

02:04:36,120 --> 02:04:47,970
then we just bail out and go don't know

02:04:37,950 --> 02:04:49,590
what to do what else there I didn't find

02:04:47,970 --> 02:04:53,580
any so we're talking about scaffolding

02:04:49,590 --> 02:04:54,930
again so there's some really well-known

02:04:53,580 --> 02:04:56,280
operations like when you add a register

02:04:54,930 --> 02:04:57,960
to register it's pretty well understood

02:04:56,280 --> 02:05:00,840
how to handle that or multiply registers

02:04:57,960 --> 02:05:02,190
together shifts and and logical

02:05:00,840 --> 02:05:03,780
operations are a little bit a little bit

02:05:02,190 --> 02:05:05,970
more tricky and I don't actually have a

02:05:03,780 --> 02:05:07,290
solution in the code that ran this so I

02:05:05,970 --> 02:05:10,290
just sort of skipped over them which is

02:05:07,290 --> 02:05:11,940
a hack obviously the simple thing to do

02:05:10,290 --> 02:05:15,630
is just mark them as unknown except for

02:05:11,940 --> 02:05:20,220
the LLVM back end for BPF likes to

02:05:15,630 --> 02:05:23,940
introduce this code right here this

02:05:20,220 --> 02:05:25,230
shift shift which is unfortunate so we

02:05:23,940 --> 02:05:28,590
can either teach the backend not to

02:05:25,230 --> 02:05:30,330
admit that which would help or figure

02:05:28,590 --> 02:05:31,740
out the right solutions for the skip

02:05:30,330 --> 02:05:36,060
folding on these different different

02:05:31,740 --> 02:05:37,560
types of operations the next thing is it

02:05:36,060 --> 02:05:40,410
works fairly well for loops as long as

02:05:37,560 --> 02:05:42,420
the loops don't get too complicated

02:05:40,410 --> 02:05:44,640
I tried more complicated loops than this

02:05:42,420 --> 02:05:46,590
and actually the latest EPF back end

02:05:44,640 --> 02:05:49,860
with LLVM 10 that I pulled actually

02:05:46,590 --> 02:05:51,600
generated a pretty good code for finding

02:05:49,860 --> 02:05:53,850
induction variables like it didn't push

02:05:51,600 --> 02:05:55,800
them onto the stack and off the stack as

02:05:53,850 --> 02:05:58,860
much as I think like earlier LOV ohms

02:05:55,800 --> 02:06:00,330
have done I don't know if there's any

02:05:58,860 --> 02:06:02,250
like people that are working on this in

02:06:00,330 --> 02:06:05,070
the audience but seems to have gotten

02:06:02,250 --> 02:06:06,630
better I didn't really test it I just

02:06:05,070 --> 02:06:07,020
picked some random samples and looked

02:06:06,630 --> 02:06:10,410
through it

02:06:07,020 --> 02:06:13,620
cuz I was just trying to make this work

02:06:10,410 --> 02:06:17,970
and see what people think and that's it

02:06:13,620 --> 02:06:20,370
I can answer questions or jump around I

02:06:17,970 --> 02:06:21,990
think one thing is like this is better

02:06:20,370 --> 02:06:24,180
than in some sense right now we just

02:06:21,990 --> 02:06:25,650
brute force loops we run them through

02:06:24,180 --> 02:06:27,510
and then we verify the tournament by

02:06:25,650 --> 02:06:29,100
running the entire loop so in this case

02:06:27,510 --> 02:06:30,450
it's interesting just to look is instead

02:06:29,100 --> 02:06:32,820
of running the loop 300 times you run it

02:06:30,450 --> 02:06:34,830
once it gets even more interesting if

02:06:32,820 --> 02:06:37,050
you generate some code that runs a loop

02:06:34,830 --> 02:06:39,090
multiple times because now that we have

02:06:37,050 --> 02:06:40,170
the conditions we can just check on the

02:06:39,090 --> 02:06:41,310
first trip through so

02:06:40,170 --> 02:06:43,500
don't actually have to do this again

02:06:41,310 --> 02:06:45,239
folding multiple times once we get back

02:06:43,500 --> 02:06:51,000
to it we just check the conditions if

02:06:45,239 --> 02:06:52,290
they meet we can just skip the loop it

02:06:51,000 --> 02:06:53,310
gets more interesting maybe if you could

02:06:52,290 --> 02:06:55,080
do something with functions but I

02:06:53,310 --> 02:06:57,080
haven't explored that much all right if

02:06:55,080 --> 02:06:59,760
you could say this function will always

02:06:57,080 --> 02:07:04,469
terminate complete and is safe if it has

02:06:59,760 --> 02:07:06,360
these conditions and those traits would

02:07:04,469 --> 02:07:08,850
always have to be known constants right

02:07:06,360 --> 02:07:10,739
so you couldn't do it they'd not known

02:07:08,850 --> 02:07:13,170
constants because you can do the bounds

02:07:10,739 --> 02:07:15,000
as well like if there's a min max bounds

02:07:13,170 --> 02:07:17,670
you can do it so no and no one in the

02:07:15,000 --> 02:07:20,219
sense that they have to be scalars right

02:07:17,670 --> 02:07:27,150
right but but no not an immediate value

02:07:20,219 --> 02:07:31,320
yeah but I think this is probably if

02:07:27,150 --> 02:07:33,030
they're not known it's a bit tricky I

02:07:31,320 --> 02:07:34,140
don't know I don't think there is a

02:07:33,030 --> 02:07:35,160
solution if they're not knowing I'm not

02:07:34,140 --> 02:07:38,130
sure if you're gonna actually even

02:07:35,160 --> 02:07:48,750
terminate on a on the verifier doing the

02:07:38,130 --> 02:07:50,340
loop running the loop right now what

02:07:48,750 --> 02:07:52,590
happens if I pass on something like a

02:07:50,340 --> 02:07:55,290
packet to a function that doesn't look

02:07:52,590 --> 02:07:59,940
without half the veil higher because the

02:07:55,290 --> 02:08:01,560
plants are known so today but I believe

02:07:59,940 --> 02:08:04,710
like for example we have a use case

02:08:01,560 --> 02:08:06,420
where we read read a variable out of the

02:08:04,710 --> 02:08:09,330
packet and then that's how we know how

02:08:06,420 --> 02:08:11,190
many times to run a loop for example but

02:08:09,330 --> 02:08:14,940
then we always bound that by doing if

02:08:11,190 --> 02:08:16,110
it's greater than X if the trip count if

02:08:14,940 --> 02:08:17,580
the loop counter that you're trying to

02:08:16,110 --> 02:08:19,920
use for the loop is greater than X then

02:08:17,580 --> 02:08:21,840
return or abort or continue or do

02:08:19,920 --> 02:08:23,190
something right this is how we get

02:08:21,840 --> 02:08:27,239
around this because otherwise there's no

02:08:23,190 --> 02:08:29,130
if there is no bounds on the loop

02:08:27,239 --> 02:08:32,429
induction variable then there's no way

02:08:29,130 --> 02:08:34,650
just to tell if it's gonna terminate we

02:08:32,429 --> 02:08:37,429
just read an arbitrary byte and try to

02:08:34,650 --> 02:08:37,429
loop on it

02:08:46,410 --> 02:08:50,770
in case there were some mechanism to

02:08:48,880 --> 02:08:53,050
give you that information because I

02:08:50,770 --> 02:08:56,410
guess that this is implemented in the

02:08:53,050 --> 02:08:58,390
kernel right correct yes will you

02:08:56,410 --> 02:09:01,600
benefit from annotations from the

02:08:58,390 --> 02:09:02,920
compiler so the patient's we have here

02:09:01,600 --> 02:09:06,070
is just telling us where the loops are

02:09:02,920 --> 02:09:07,720
yes like the most basic one yeah like

02:09:06,070 --> 02:09:09,220
you know one thing I played a bit with

02:09:07,720 --> 02:09:10,750
is can we just annotate what the

02:09:09,220 --> 02:09:12,940
induction variable is so I can that's

02:09:10,750 --> 02:09:15,040
what the loop induction variable is we

02:09:12,940 --> 02:09:18,280
could try harder to track that one for

02:09:15,040 --> 02:09:19,750
example you might save like time and

02:09:18,280 --> 02:09:21,190
memory that way because you wouldn't

02:09:19,750 --> 02:09:22,810
need the entire table of all the

02:09:21,190 --> 02:09:24,340
registers right they go so right now

02:09:22,810 --> 02:09:26,470
it's sort of it'll track everything

02:09:24,340 --> 02:09:27,700
because it the code that I wrote doesn't

02:09:26,470 --> 02:09:30,160
know what the induction variable is

02:09:27,700 --> 02:09:32,440
until he gets to the end right mhm if

02:09:30,160 --> 02:09:34,000
you told it kind of ahead of time we

02:09:32,440 --> 02:09:36,880
could just track one registered price

02:09:34,000 --> 02:09:39,190
and other than creating new instructions

02:09:36,880 --> 02:09:42,760
that obviously it's not going to scale

02:09:39,190 --> 02:09:44,230
very well what would be the mechanism so

02:09:42,760 --> 02:09:45,610
right now we have B TF and they're tied

02:09:44,230 --> 02:09:47,080
to the instructions so we could have

02:09:45,610 --> 02:09:48,580
pulled that out of b TF right there I

02:09:47,080 --> 02:09:52,270
believe I think it would have been

02:09:48,580 --> 02:09:53,560
fairly painless to do it just could add

02:09:52,270 --> 02:09:55,090
instruction that because it was I think

02:09:53,560 --> 02:10:00,820
I when I we started playing this b TF

02:09:55,090 --> 02:10:01,870
was still in flux and a b TF wouldn't

02:10:00,820 --> 02:10:03,910
work i'm sure there's some way we can

02:10:01,870 --> 02:10:07,390
annotate the instruction from from the b

02:10:03,910 --> 02:10:09,910
PF back inside okay or we could do yeah

02:10:07,390 --> 02:10:12,010
something okay so it would be good we

02:10:09,910 --> 02:10:13,660
could touch because in case you need

02:10:12,010 --> 02:10:16,090
some annotations that we can provide

02:10:13,660 --> 02:10:17,500
from the compiler and if there is a

02:10:16,090 --> 02:10:22,890
mechanism to give you that information

02:10:17,500 --> 02:10:22,890
then we can do that easily yeah

02:10:30,120 --> 02:10:38,520
all right thanks a lot

02:10:33,130 --> 02:10:41,589
[Applause]

02:10:38,520 --> 02:10:41,589
[Music]

02:10:55,750 --> 02:11:03,920
alright should I start yeah

02:11:00,740 --> 02:11:04,790
hi everyone so my name is Mathieu de

02:11:03,920 --> 02:11:08,450
nuit

02:11:04,790 --> 02:11:10,130
I'm here to talk to you about my work on

02:11:08,450 --> 02:11:12,260
the restaurant table sequence system

02:11:10,130 --> 02:11:15,290
calls so it's not actually the EPF

02:11:12,260 --> 02:11:17,870
system called in this case but I made

02:11:15,290 --> 02:11:21,950
some experiments using the EPF byte code

02:11:17,870 --> 02:11:25,400
and create the prototype which I called

02:11:21,950 --> 02:11:27,650
the duan CPU system call so there might

02:11:25,400 --> 02:11:30,350
be I mean I might not push this upstream

02:11:27,650 --> 02:11:33,320
because basically we I've discussed

02:11:30,350 --> 02:11:34,910
others alternative solutions with Paul

02:11:33,320 --> 02:11:36,770
Turner this week so we'll see how it

02:11:34,910 --> 02:11:38,660
goes but I think it's worthwhile that I

02:11:36,770 --> 02:11:41,360
present the results of what I've done

02:11:38,660 --> 02:11:43,190
here so what the arteries start to both

02:11:41,360 --> 02:11:46,190
sequences in a nutshell a very quick

02:11:43,190 --> 02:11:48,260
context so it is a system call provided

02:11:46,190 --> 02:11:50,420
to user space so that user user space

02:11:48,260 --> 02:11:54,110
thread can register a trade like all

02:11:50,420 --> 02:11:57,860
storage data entry that will act as an

02:11:54,110 --> 02:12:00,050
ABI between the kernel and user space so

02:11:57,860 --> 02:12:02,720
the purpose of restorable sequences is

02:12:00,050 --> 02:12:04,550
to enable user space to implement very

02:12:02,720 --> 02:12:09,020
efficient per CPU data accesses

02:12:04,550 --> 02:12:11,960
including updates so there are a few

02:12:09,020 --> 02:12:14,840
reasons for requiring a kind of fall

02:12:11,960 --> 02:12:18,050
back to restart all sequences one of

02:12:14,840 --> 02:12:22,070
them is when trying to update the data

02:12:18,050 --> 02:12:24,740
of a remote CPU that is aware that works

02:12:22,070 --> 02:12:27,050
with CPU at plug so just setting the CPU

02:12:24,740 --> 02:12:30,470
affinity is not enough because it

02:12:27,050 --> 02:12:33,860
doesn't work well with CPU o'clock and

02:12:30,470 --> 02:12:37,250
other use cases so early and late per

02:12:33,860 --> 02:12:39,170
CPU data use in Lib C at initialization

02:12:37,250 --> 02:12:41,270
and in the tread life time and that

02:12:39,170 --> 02:12:45,020
includes also signal enters nested on

02:12:41,270 --> 02:12:46,490
top of anywhere in the tread and another

02:12:45,020 --> 02:12:48,530
use case is single stepping through

02:12:46,490 --> 02:12:51,680
researchable sequences with preexisting

02:12:48,530 --> 02:12:53,600
debuggers for new debuggers we there are

02:12:51,680 --> 02:12:56,180
modifications we can do to the debuggers

02:12:53,600 --> 02:12:58,100
to teach it about our sec but i mean it

02:12:56,180 --> 02:13:01,280
might have been nice to have a

02:12:58,100 --> 02:13:06,230
pre-existing debuggers not turn every

02:13:01,280 --> 02:13:08,330
program into never-ending busy loops so

02:13:06,230 --> 02:13:11,570
that's the system called

02:13:08,330 --> 02:13:15,290
I did mmm so it takes as argument

02:13:11,570 --> 02:13:19,460
basically a BPF bytecode length

02:13:15,290 --> 02:13:22,400
parameter and it returns a result so it

02:13:19,460 --> 02:13:24,770
does execute on a targeted CPU received

02:13:22,400 --> 02:13:27,440
as parameter and it can have some flags

02:13:24,770 --> 02:13:30,020
for future extensions so the

02:13:27,440 --> 02:13:34,280
requirements of this do one CPU are SEC

02:13:30,020 --> 02:13:36,530
fallback so it is not a fast path there

02:13:34,280 --> 02:13:38,960
can be a very large number of EBP F

02:13:36,530 --> 02:13:42,230
programs that can exist in userspace

02:13:38,960 --> 02:13:44,450
memory at any given time those are fall

02:13:42,230 --> 02:13:46,400
backs that might not be used often but

02:13:44,450 --> 02:13:49,670
they might be loaded in various

02:13:46,400 --> 02:13:51,650
applications so pre loading each of them

02:13:49,670 --> 02:13:54,280
into the kernel and jetting and things

02:13:51,650 --> 02:13:59,750
like that is impractical with respect to

02:13:54,280 --> 02:14:01,340
run time and memory consumption so so in

02:13:59,750 --> 02:14:03,950
this case what I did is so they are

02:14:01,340 --> 02:14:06,770
received as a parent as a parameter from

02:14:03,950 --> 02:14:09,050
user space to the kernel as a system

02:14:06,770 --> 02:14:10,910
call parameter for single use they

02:14:09,050 --> 02:14:13,660
execute and a specific CPU that is

02:14:10,910 --> 02:14:16,400
received as parameter and they need to

02:14:13,660 --> 02:14:18,650
to execute with a preemption disabled

02:14:16,400 --> 02:14:21,320
critical section so that they can

02:14:18,650 --> 02:14:25,040
provide exclusive per CPU data access

02:14:21,320 --> 02:14:26,960
and the tricky part is so they are

02:14:25,040 --> 02:14:30,310
actually dealing with user space memory

02:14:26,960 --> 02:14:34,070
of the color process of the color trap

02:14:30,310 --> 02:14:37,310
so so here I mean this is the tricky

02:14:34,070 --> 02:14:39,500
part is they may they may need to fault

02:14:37,310 --> 02:14:44,390
with preemption disabled and this is a

02:14:39,500 --> 02:14:47,360
big no-no in the kernel so I looked into

02:14:44,390 --> 02:14:49,580
the upstream Linux ebps infrastructure

02:14:47,360 --> 02:14:52,460
and I found it not really to be a good

02:14:49,580 --> 02:14:55,490
match for do on CPU so it focuses on

02:14:52,460 --> 02:14:59,800
load/store of stack and kernel data it

02:14:55,490 --> 02:15:02,330
calls so I do see people runtime

02:14:59,800 --> 02:15:04,880
interpreter also does not need the calls

02:15:02,330 --> 02:15:07,040
to external functions most of the EBP

02:15:04,880 --> 02:15:10,490
ff-fire because it does not touch any

02:15:07,040 --> 02:15:12,830
kernel data the EBP eff bytecode to

02:15:10,490 --> 02:15:14,420
native code jet I mean the speed it

02:15:12,830 --> 02:15:17,690
provides it's not really needed since

02:15:14,420 --> 02:15:20,360
it's a slow pad and also doing this

02:15:17,690 --> 02:15:22,160
conversion to jet requires extra memory

02:15:20,360 --> 02:15:25,370
allocation so

02:15:22,160 --> 02:15:27,530
and the other part so what I basically

02:15:25,370 --> 02:15:29,750
chose for that prototype is to do a very

02:15:27,530 --> 02:15:32,840
simple interpreter which does its own

02:15:29,750 --> 02:15:35,510
bytecode validation it interprets the

02:15:32,840 --> 02:15:37,580
bytecode and so so it's basically

02:15:35,510 --> 02:15:41,090
portable it does provide loots loop

02:15:37,580 --> 02:15:41,720
support and so the special thing about

02:15:41,090 --> 02:15:44,570
it

02:15:41,720 --> 02:15:47,710
so is that it creates a kind of mapping

02:15:44,570 --> 02:15:50,840
between the user space addresses and a

02:15:47,710 --> 02:15:54,710
shadow mapping into Colonel fee math

02:15:50,840 --> 02:15:57,020
memory of whatever it needs to access so

02:15:54,710 --> 02:16:01,550
it can access them the data from

02:15:57,020 --> 02:16:05,210
preemptive critical sections so some so

02:16:01,550 --> 02:16:07,340
this is more discussion here so while

02:16:05,210 --> 02:16:10,520
doing that and trying to kind of port

02:16:07,340 --> 02:16:13,040
all the researchable sequences use cases

02:16:10,520 --> 02:16:15,230
I had in user space to create the those

02:16:13,040 --> 02:16:17,690
byte code snippet to support them what I

02:16:15,230 --> 02:16:20,380
what I noticed might be needed

02:16:17,690 --> 02:16:23,450
eventually to add to the EBP eff

02:16:20,380 --> 02:16:27,140
instructions so first of all to define a

02:16:23,450 --> 02:16:29,690
memory model about EBP F so I mean you

02:16:27,140 --> 02:16:32,150
don't expect when you have let's say

02:16:29,690 --> 02:16:34,820
yeah I don't know Java C sharp so when

02:16:32,150 --> 02:16:36,381
you generate a byte code you want to

02:16:34,820 --> 02:16:38,720
generate it in a way that is

02:16:36,381 --> 02:16:41,150
architecture independent so that and

02:16:38,720 --> 02:16:43,640
then you push to whatever is going to

02:16:41,150 --> 02:16:46,010
digest it this bytecode and jetted the

02:16:43,640 --> 02:16:48,080
task to ensure that to enforce the

02:16:46,010 --> 02:16:49,910
memory model that is defined at the

02:16:48,080 --> 02:16:52,670
bytecode level in an architecture

02:16:49,910 --> 02:16:56,510
agnostic way and I found there was

02:16:52,670 --> 02:16:58,551
nothing like this regarding to EBP F so

02:16:56,510 --> 02:17:01,580
some things I would need also is new

02:16:58,551 --> 02:17:03,680
instructions that are actually based on

02:17:01,580 --> 02:17:06,650
that memory ordering so a load acquire

02:17:03,680 --> 02:17:08,750
instruction store release an actual

02:17:06,650 --> 02:17:12,950
plain memory bar your instruction those

02:17:08,750 --> 02:17:16,250
do not exist in EBP F I also found that

02:17:12,950 --> 02:17:18,830
there were some use cases where part of

02:17:16,250 --> 02:17:21,680
the interpreter execution did really not

02:17:18,830 --> 02:17:24,770
require preemption to be disabled so it

02:17:21,680 --> 02:17:28,341
was just for subsets of the execution

02:17:24,770 --> 02:17:30,200
that preemption needed to be disabled so

02:17:28,341 --> 02:17:33,440
that it might be interesting to

02:17:30,200 --> 02:17:35,540
eventually support some some mode where

02:17:33,440 --> 02:17:38,420
you when you pass by code it could

02:17:35,540 --> 02:17:41,210
with a flag saying I want to run with

02:17:38,420 --> 02:17:43,729
preemption enabled and then add to de

02:17:41,210 --> 02:17:45,830
BPF instruction set instructions that

02:17:43,729 --> 02:17:48,769
could enable and disable preemption for

02:17:45,830 --> 02:17:51,349
shorter critical sections so it could

02:17:48,769 --> 02:17:55,340
provide much finer grained protection

02:17:51,349 --> 02:17:57,260
against the scheduler preemption and one

02:17:55,340 --> 02:17:59,389
of the goal there is to minimize the

02:17:57,260 --> 02:18:04,309
schedule or latency impact for preempt

02:17:59,389 --> 02:18:06,889
RT yeah so that's mainly what I have I

02:18:04,309 --> 02:18:08,960
do have additional slides that give more

02:18:06,889 --> 02:18:11,240
detail about handling page faults with

02:18:08,960 --> 02:18:14,569
preemption disabled and execution

02:18:11,240 --> 02:18:18,309
mismatch between passes I guess I have

02:18:14,569 --> 02:18:23,450
time unless there are questions so far

02:18:18,309 --> 02:18:26,630
yeah do you have an example when you

02:18:23,450 --> 02:18:28,729
think of promote disable is no needed in

02:18:26,630 --> 02:18:33,559
your previous slides you mention in some

02:18:28,729 --> 02:18:36,469
cases yeah so the use case is a ring

02:18:33,559 --> 02:18:39,800
buffer that consists so it's a per CPU

02:18:36,469 --> 02:18:41,300
ring buffer and how you push let's say

02:18:39,800 --> 02:18:43,700
into that ring buffer would be two mem

02:18:41,300 --> 02:18:46,099
copy some amount of data let's say alpha

02:18:43,700 --> 02:18:50,420
page right in directly into the buffer

02:18:46,099 --> 02:18:52,429
and then update the offset of product

02:18:50,420 --> 02:18:55,729
amount of produced data into that buffer

02:18:52,429 --> 02:18:59,170
so all that would be done within a our

02:18:55,729 --> 02:19:02,649
sacred ago section in user space and

02:18:59,170 --> 02:19:07,849
what happens is you can be preempted

02:19:02,649 --> 02:19:10,279
while doing the mem copy and as long as

02:19:07,849 --> 02:19:12,260
you're preempted before storing the

02:19:10,279 --> 02:19:14,359
actual new value of the offset of how

02:19:12,260 --> 02:19:16,460
our so much has been produced

02:19:14,359 --> 02:19:18,349
whatever you copied over is just going

02:19:16,460 --> 02:19:20,510
to be overwritten so you don't care

02:19:18,349 --> 02:19:22,040
about being preempted at that point

02:19:20,510 --> 02:19:25,010
so in our seconds going to be aborted

02:19:22,040 --> 02:19:28,189
and it's just going to be overwritten so

02:19:25,010 --> 02:19:29,990
the same thing the same concept apply if

02:19:28,189 --> 02:19:33,040
we have that byte code running at the

02:19:29,990 --> 02:19:35,929
kernel level so if it gets preempted

02:19:33,040 --> 02:19:38,179
before reaching the update of the the

02:19:35,929 --> 02:19:39,859
actual amount of data stored you don't

02:19:38,179 --> 02:19:42,469
care it's going to be overwritten anyway

02:19:39,859 --> 02:19:47,680
so all that part can be run with

02:19:42,469 --> 02:19:50,320
preemption enabled so

02:19:47,680 --> 02:19:52,710
and I would do I did not do it but how I

02:19:50,320 --> 02:19:55,420
would do that preemption enabled part

02:19:52,710 --> 02:19:58,690
within the bytecode interpreter what

02:19:55,420 --> 02:20:02,080
basic basically to be to add pre-empting

02:19:58,690 --> 02:20:03,851
a preempt required checks in the

02:20:02,080 --> 02:20:06,460
interpreter so it would periodically

02:20:03,851 --> 02:20:08,710
check on the in the tread flags to see

02:20:06,460 --> 02:20:11,200
if it needs to be preempted and it will

02:20:08,710 --> 02:20:14,620
only check that while it is not within a

02:20:11,200 --> 02:20:18,400
pre-emptive critical section an explicit

02:20:14,620 --> 02:20:21,790
one mostly for the networking programs

02:20:18,400 --> 02:20:24,190
way it's useful for memory allocators

02:20:21,790 --> 02:20:27,250
tracing various things everything that

02:20:24,190 --> 02:20:29,591
uses per CPU data actually for choosing

02:20:27,250 --> 02:20:31,181
will have a persecuted I actually we are

02:20:29,591 --> 02:20:33,670
incremented before you'll call BB a

02:20:31,181 --> 02:20:38,860
program so that probably won't work for

02:20:33,670 --> 02:20:40,721
networking program can you repeat that

02:20:38,860 --> 02:20:43,870
three no for tracing will have this a

02:20:40,721 --> 02:20:45,670
per CPU BPF active counter yeah but I'm

02:20:43,870 --> 02:20:48,400
doing user space tracing from user space

02:20:45,670 --> 02:20:53,200
to user space no kernel involved oh okay

02:20:48,400 --> 02:20:57,820
I see LT TNG USD I see okay other

02:20:53,200 --> 02:21:01,030
questions sorry if I do have still some

02:20:57,820 --> 02:21:03,280
time I can talk about handling page

02:21:01,030 --> 02:21:06,040
faults with preemption disabled so ID

02:21:03,280 --> 02:21:08,650
what I did is a multi pass scheme so

02:21:06,040 --> 02:21:11,561
there's a first passed which task is to

02:21:08,650 --> 02:21:14,290
create kernel mappings of memory so it

02:21:11,561 --> 02:21:16,150
basically will execute truth by code

02:21:14,290 --> 02:21:18,221
without doing any of the store side

02:21:16,150 --> 02:21:20,200
effects to memory it's going to grab

02:21:18,221 --> 02:21:23,021
references to each user space page

02:21:20,200 --> 02:21:25,660
touched by the byte code it creates

02:21:23,021 --> 02:21:28,181
virtual mappings aligned on the same

02:21:25,660 --> 02:21:30,790
page color as user space pages to ensure

02:21:28,181 --> 02:21:33,521
that it's a requirement on virtually

02:21:30,790 --> 02:21:35,530
earliest architectures and then it

02:21:33,521 --> 02:21:37,511
enable so it enables preemption and

02:21:35,530 --> 02:21:40,660
restart bytecode interpretation each

02:21:37,511 --> 02:21:42,971
time a new page is added to the set so

02:21:40,660 --> 02:21:46,000
with this I do have a data structure

02:21:42,971 --> 02:21:47,500
mapping between user space memory

02:21:46,000 --> 02:21:50,471
addresses that need to be accessed by

02:21:47,500 --> 02:21:51,730
the byte code and kernel kernel mappings

02:21:50,471 --> 02:21:53,471
that can be touched

02:21:51,730 --> 02:21:56,080
from Interop android context or

02:21:53,471 --> 02:21:58,801
preemption disabled context and then the

02:21:56,080 --> 02:22:00,800
second pass performs store side effects

02:21:58,801 --> 02:22:04,550
so

02:22:00,800 --> 02:22:07,370
the thing is some algorithms want to

02:22:04,550 --> 02:22:09,410
change data underneath your feet between

02:22:07,370 --> 02:22:14,060
those two passes so what can you do

02:22:09,410 --> 02:22:15,680
against that so basically so the fact

02:22:14,060 --> 02:22:17,750
that you can load an address from user

02:22:15,680 --> 02:22:20,750
space and then want to either load or

02:22:17,750 --> 02:22:22,700
store from that address and this address

02:22:20,750 --> 02:22:25,270
may change between the two passes so we

02:22:22,700 --> 02:22:29,359
need to be able to identify such changes

02:22:25,270 --> 02:22:31,910
so I did this by doing a basically a

02:22:29,359 --> 02:22:34,340
small tracer so the interpreter includes

02:22:31,910 --> 02:22:36,979
a tracer that takes into account every

02:22:34,340 --> 02:22:39,350
load and store to and from tainted user

02:22:36,979 --> 02:22:41,450
space memory addresses so whenever I do

02:22:39,350 --> 02:22:43,970
a load in a store from a register

02:22:41,450 --> 02:22:46,010
content that register content is tagged

02:22:43,970 --> 02:22:47,960
with a flag that indicates whether that

02:22:46,010 --> 02:22:52,910
is the result of the value that came

02:22:47,960 --> 02:22:55,819
from memory or or ALU operation based on

02:22:52,910 --> 02:22:58,760
of such tainted value and it's the same

02:22:55,819 --> 02:23:01,040
thing for conditional branches so if a

02:22:58,760 --> 02:23:03,200
conditional branch always takes the same

02:23:01,040 --> 02:23:06,170
direction we don't care about it but if

02:23:03,200 --> 02:23:10,250
the branch depends on registers that are

02:23:06,170 --> 02:23:12,020
tainted again we need to track the

02:23:10,250 --> 02:23:14,479
execution flow and make sure it's the

02:23:12,020 --> 02:23:16,670
same between the two passes and then

02:23:14,479 --> 02:23:19,819
within the second pass that does the

02:23:16,670 --> 02:23:22,340
store side effects if we discover

02:23:19,819 --> 02:23:24,260
discrepancy between the state it means

02:23:22,340 --> 02:23:26,510
user space has corrupted the memory

02:23:24,260 --> 02:23:29,149
underneath our feet but it may be okay

02:23:26,510 --> 02:23:31,069
and it may be part of the algorithm how

02:23:29,149 --> 02:23:33,050
we define whether it's corruption or

02:23:31,069 --> 02:23:35,270
it's expected and we just need to retry

02:23:33,050 --> 02:23:37,700
is whether there has been at least one

02:23:35,270 --> 02:23:41,060
store side-effect observable by user

02:23:37,700 --> 02:23:43,130
space when we detect this discrepancy if

02:23:41,060 --> 02:23:44,899
there's not been any store side effect

02:23:43,130 --> 02:23:46,910
which can just restart everything if

02:23:44,899 --> 02:23:49,010
there's been at least one then we need

02:23:46,910 --> 02:23:50,720
to return to user space that it did

02:23:49,010 --> 02:23:55,939
corrupt the information underneath our

02:23:50,720 --> 02:23:58,450
feet and your algorithm is broken so

02:23:55,939 --> 02:23:58,450
that's it

02:24:00,721 --> 02:24:03,801
other questions

02:24:08,740 --> 02:24:25,479
okay thanks a lot sorry how much time do

02:24:16,750 --> 02:24:28,180
here perfect okay before I ask you a

02:24:25,479 --> 02:24:30,310
question I ask another question so in

02:24:28,180 --> 02:24:31,960
the beginning you said you may have a

02:24:30,310 --> 02:24:34,330
different completely different approach

02:24:31,960 --> 02:24:39,940
can you elaborate on that yeah

02:24:34,330 --> 02:24:41,680
quickly so here for single stepping

02:24:39,940 --> 02:24:43,840
through debuggers just ask people to

02:24:41,680 --> 02:24:45,850
upgrade their debugger with actual our

02:24:43,840 --> 02:24:47,740
sex report that might be an alternative

02:24:45,850 --> 02:24:51,130
option to doing this bytecode

02:24:47,740 --> 02:24:52,840
interpreter for the point where well

02:24:51,130 --> 02:24:54,400
actually actually this part I didn't

02:24:52,840 --> 02:24:56,229
quite get when you're talking because

02:24:54,400 --> 02:24:58,120
you're saying I don't want to change the

02:24:56,229 --> 02:25:00,280
debuggers but you are introducing new

02:24:58,120 --> 02:25:03,370
system calls so it's something users

02:25:00,280 --> 02:25:05,440
face still need to change so we have got

02:25:03,370 --> 02:25:07,720
this changing well so user space

02:25:05,440 --> 02:25:10,479
applications starting to use our sec or

02:25:07,720 --> 02:25:12,160
introducing new code but then the

02:25:10,479 --> 02:25:14,170
debugger might be a pre-existing tool

02:25:12,160 --> 02:25:16,390
right right so we have the freedom to

02:25:14,170 --> 02:25:17,950
talk to the gdb community and I'm

02:25:16,390 --> 02:25:20,710
actually going to techno cauldron this

02:25:17,950 --> 02:25:23,830
week to actually talk to them to make

02:25:20,710 --> 02:25:26,500
our cycle where as part of gdb but so

02:25:23,830 --> 02:25:28,660
then we have the question whether people

02:25:26,500 --> 02:25:30,910
so what do we do with end users which

02:25:28,660 --> 02:25:32,890
have newer applications with older gdb

02:25:30,910 --> 02:25:35,740
perhaps the right answer is to ask them

02:25:32,890 --> 02:25:38,170
to abrade gdb perhaps we want to do

02:25:35,740 --> 02:25:40,000
something more clever but if they don't

02:25:38,170 --> 02:25:42,340
upgrade the gdb I'm still missing how

02:25:40,000 --> 02:25:44,500
this new system called helps them okay

02:25:42,340 --> 02:25:46,360
so the problem with stepping true our

02:25:44,500 --> 02:25:48,310
sec single stepping through a restore

02:25:46,360 --> 02:25:50,140
table critical section with gdb is that

02:25:48,310 --> 02:25:52,840
it preempts in between every instruction

02:25:50,140 --> 02:25:55,180
and the behavior of our sec when it's

02:25:52,840 --> 02:25:57,820
preempted is to abort and if you don't

02:25:55,180 --> 02:26:00,040
have a an alternative way of executing

02:25:57,820 --> 02:26:03,100
what you want to do the way to end all

02:26:00,040 --> 02:26:07,300
the abort is to retry so you are big

02:26:03,100 --> 02:26:08,890
becoming an endless loop and yeah so I

02:26:07,300 --> 02:26:11,380
know this part I'm still missing how

02:26:08,890 --> 02:26:13,390
this system call helps this situation is

02:26:11,380 --> 02:26:16,600
so in the abort case rather than

02:26:13,390 --> 02:26:18,820
retrying you invoke do one CPU and gdb

02:26:16,600 --> 02:26:22,470
is not going to single step to do one

02:26:18,820 --> 02:26:22,470
CPU I see okay

02:26:25,150 --> 02:26:34,070
yeah how does the debugger communicate

02:26:31,610 --> 02:26:37,131
back to the abort handler that it needs

02:26:34,070 --> 02:26:39,771
to do this is called with because as the

02:26:37,131 --> 02:26:42,831
the the PPF instructions would be

02:26:39,771 --> 02:26:44,751
specific to whatever was interrupted by

02:26:42,831 --> 02:26:46,551
the debugger right the plan with this

02:26:44,751 --> 02:26:48,650
system call would be to make it part of

02:26:46,551 --> 02:26:50,871
the application so the application would

02:26:48,650 --> 02:26:52,371
implement a the critical section in

02:26:50,871 --> 02:26:54,951
assembly and on the airport

02:26:52,371 --> 02:27:04,940
it would just call this okay there's a

02:26:54,951 --> 02:27:07,331
question at the back and - this is very

02:27:04,940 --> 02:27:09,681
much like single stepping llse Atomics

02:27:07,331 --> 02:27:12,320
any other issues with those but the e on

02:27:09,681 --> 02:27:14,301
the difference is with LS c this is a

02:27:12,320 --> 02:27:16,431
new architecture that the debugger needs

02:27:14,301 --> 02:27:18,261
to support so there was no pre-existing

02:27:16,431 --> 02:27:20,391
Department that's supporting actual and

02:27:18,261 --> 02:27:22,280
pretty much all of those cases debugger

02:27:20,391 --> 02:27:24,141
uses horrible heuristics to try and

02:27:22,280 --> 02:27:26,360
guess which closing we also think we

02:27:24,141 --> 02:27:30,650
actually have the information to what to

02:27:26,360 --> 02:27:31,881
jump to you but also you have an ability

02:27:30,650 --> 02:27:33,921
to do something with r-spec that's

02:27:31,881 --> 02:27:36,621
difficult of LSC in that your debugger

02:27:33,921 --> 02:27:39,771
can stop all of the other threads in the

02:27:36,621 --> 02:27:42,291
application so if you had a mechanism to

02:27:39,771 --> 02:27:44,780
suppress our sex restart for a period of

02:27:42,291 --> 02:27:46,551
time you would be able to single step in

02:27:44,780 --> 02:27:50,061
one thread all other threads are

02:27:46,551 --> 02:27:52,190
suspended yeah but will it work with our

02:27:50,061 --> 02:27:57,501
sec being used over shared memory across

02:27:52,190 --> 02:28:00,771
processes that will not but also another

02:27:57,501 --> 02:28:02,661
problem this approach is that your

02:28:00,771 --> 02:28:04,940
behavior while debugging is now

02:28:02,661 --> 02:28:07,011
different to your behavior while not

02:28:04,940 --> 02:28:08,871
debugging because you're in the debug in

02:28:07,011 --> 02:28:12,501
case you're always going through the EBP

02:28:08,871 --> 02:28:15,381
F version of your algorithm which may

02:28:12,501 --> 02:28:18,801
not be like if you're if you have a bug

02:28:15,381 --> 02:28:20,570
in your application it's likely that the

02:28:18,801 --> 02:28:22,371
semantics of EBP F application is

02:28:20,570 --> 02:28:24,561
different to the semantics of your

02:28:22,371 --> 02:28:26,871
assembly sequence so now you can have

02:28:24,561 --> 02:28:28,251
application where whenever you run it

02:28:26,871 --> 02:28:30,501
through this it always works and

02:28:28,251 --> 02:28:32,900
whenever you're in normally you have a

02:28:30,501 --> 02:28:35,541
sort of bug that just does not seem

02:28:32,900 --> 02:28:36,030
great so how many applications are

02:28:35,541 --> 02:28:38,460
actually

02:28:36,030 --> 02:28:39,870
sharing stuff across processes relative

02:28:38,460 --> 02:28:42,540
to the case where it's just multiple

02:28:39,870 --> 02:28:44,490
threads within the same process so

02:28:42,540 --> 02:28:46,380
single process seems to be the main use

02:28:44,490 --> 02:28:48,690
case a memory allocator stuff and so on

02:28:46,380 --> 02:28:51,690
I care about the shared use case for

02:28:48,690 --> 02:28:54,660
tracing so I connect information from a

02:28:51,690 --> 02:28:56,490
shared memory map ring buffer so I mean

02:28:54,660 --> 02:28:58,050
there are different use cases if it's

02:28:56,490 --> 02:29:00,540
different people because I would suggest

02:28:58,050 --> 02:29:02,011
the for the majority of those users the

02:29:00,540 --> 02:29:03,450
ability to pause the other threads in

02:29:02,011 --> 02:29:05,521
single step for the actual assembly

02:29:03,450 --> 02:29:07,351
sequence is going to be what actually

02:29:05,521 --> 02:29:15,811
helps them to identify the bug in their

02:29:07,351 --> 02:29:18,511
application one other question like can

02:29:15,811 --> 02:29:21,780
you forwards you slides because there I

02:29:18,511 --> 02:29:22,230
think you're making is yes no even

02:29:21,780 --> 02:29:25,320
further

02:29:22,230 --> 02:29:27,511
yeah so this this part this is just a

02:29:25,320 --> 02:29:29,431
generic suggestion right for me so it's

02:29:27,511 --> 02:29:32,761
not related to this like anything this

02:29:29,431 --> 02:29:34,710
is just like your TV request in general

02:29:32,761 --> 02:29:36,811
for forgive you yeah and I may not even

02:29:34,710 --> 02:29:38,460
need them upstream I was it's just true

02:29:36,811 --> 02:29:40,471
this experience of working unusually

02:29:38,460 --> 02:29:41,820
based data I noticed that this was

02:29:40,471 --> 02:29:44,460
enough missing from the instructions

02:29:41,820 --> 02:29:46,980
absolutely so like this the lack of

02:29:44,460 --> 02:29:50,040
memory model was understood for a while

02:29:46,980 --> 02:29:53,820
now well at least since December of last

02:29:50,040 --> 02:29:57,900
year and we had the case two calls with

02:29:53,820 --> 02:30:02,061
all makini not sure which Peter I think

02:29:57,900 --> 02:30:04,230
you made it yeah and we'll stop

02:30:02,061 --> 02:30:07,590
follow-ups from this that we didn't

02:30:04,230 --> 02:30:09,450
quite like completed so and in terms of

02:30:07,590 --> 02:30:11,971
like your list of things like clock war

02:30:09,450 --> 02:30:14,940
stories movement barrier all of this is

02:30:11,971 --> 02:30:18,240
on to-do list understood this is need to

02:30:14,940 --> 02:30:21,540
happen and memory model like yeah must

02:30:18,240 --> 02:30:22,830
have sketches as well so you know the my

02:30:21,540 --> 02:30:26,730
point that you know the first time

02:30:22,830 --> 02:30:28,320
stepping on this rakes and yeah and the

02:30:26,730 --> 02:30:30,271
last thing I could say is not having a

02:30:28,320 --> 02:30:33,170
comparison swap was a bit weird if there

02:30:30,271 --> 02:30:36,330
since there was access yes that that

02:30:33,170 --> 02:30:39,030
that came at the networking at another

02:30:36,330 --> 02:30:40,590
King Kong as well yes this is also

02:30:39,030 --> 02:30:42,750
definitely like something that's missing

02:30:40,590 --> 02:30:45,240
there is nothing like architectural ey

02:30:42,750 --> 02:30:48,931
is missing it's just like was not done

02:30:45,240 --> 02:30:49,390
seem simple that and answering this

02:30:48,931 --> 02:30:52,080
preemption

02:30:49,390 --> 02:30:54,430
disable stuff so what we're thinking

02:30:52,080 --> 02:30:56,830
it's actually necessary for different

02:30:54,430 --> 02:30:59,290
other use cases like for tracing in

02:30:56,830 --> 02:31:01,330
particular people want to be able to

02:30:59,290 --> 02:31:03,430
poke into user memory while tracing and

02:31:01,330 --> 02:31:05,890
currently because production disable the

02:31:03,430 --> 02:31:07,810
the probability user is missing all of

02:31:05,890 --> 02:31:12,100
these values and people do all crazy

02:31:07,810 --> 02:31:16,000
hacks to to do this so we definitely

02:31:12,100 --> 02:31:19,180
looking for ways to allow faulting from

02:31:16,000 --> 02:31:21,760
the vdf code and it will be preemptable

02:31:19,180 --> 02:31:23,739
and not in our co critical section so it

02:31:21,760 --> 02:31:25,689
will be like new program types only like

02:31:23,739 --> 02:31:28,180
in system calls whether it's actually

02:31:25,689 --> 02:31:30,609
saved to default but then are there any

02:31:28,180 --> 02:31:33,939
reasons for disabling preemption in your

02:31:30,609 --> 02:31:36,489
use cases well that's that serious case

02:31:33,939 --> 02:31:37,989
like to fault to be able to access the

02:31:36,489 --> 02:31:40,630
user base memory we need it to be

02:31:37,989 --> 02:31:42,880
enabled preemption but why disable it

02:31:40,630 --> 02:31:43,180
what's the what's the reason why is it

02:31:42,880 --> 02:31:45,489
needed

02:31:43,180 --> 02:31:47,350
Oh for all the peer CPU accesses and

02:31:45,489 --> 02:31:49,000
everything ok it's for per CPU the

02:31:47,350 --> 02:31:56,310
locking could be an alternative as well

02:31:49,000 --> 02:31:58,110
per CPU locking sure all right thanks

02:31:56,310 --> 02:32:03,899
thank you

02:31:58,110 --> 02:32:03,899
[Applause]

02:32:12,489 --> 02:32:17,539
hello everyone I'm going to talk about

02:32:15,409 --> 02:32:20,479
kernel runtime security instrumentation

02:32:17,539 --> 02:32:23,720
I am KP I work in the Google Zurich

02:32:20,479 --> 02:32:26,300
office on detection response so before I

02:32:23,720 --> 02:32:29,029
tell about all of this it is an LS M

02:32:26,300 --> 02:32:30,949
that uses EBP F everyone is aware of

02:32:29,029 --> 02:32:33,399
what an LS M is here in the room I hope

02:32:30,949 --> 02:32:36,890
so with the show friends I guess

02:32:33,399 --> 02:32:38,600
awesome ok there are some LS mi I'll go

02:32:36,890 --> 02:32:40,489
through that in the presentation as well

02:32:38,600 --> 02:32:43,550
but LS m is this framework that allows

02:32:40,489 --> 02:32:45,020
you to place in certain sections in the

02:32:43,550 --> 02:32:46,339
kernel these are called hooks you can

02:32:45,020 --> 02:32:47,720
check whether you're allowed to do

02:32:46,339 --> 02:32:49,850
something with your parading system or

02:32:47,720 --> 02:32:52,459
not and we want to hook that with the VP

02:32:49,850 --> 02:32:57,079
of programs why do we want to do that

02:32:52,459 --> 02:32:58,459
well signals and mitigation in and these

02:32:57,079 --> 02:32:59,869
are not Unix signals these are signals

02:32:58,459 --> 02:33:02,959
that allow you to detect malicious

02:32:59,869 --> 02:33:04,520
activity they go hand in hand and a

02:33:02,959 --> 02:33:06,350
signal you can define roughly as

02:33:04,520 --> 02:33:07,550
something that could correlation

02:33:06,350 --> 02:33:09,560
correlate with maliciousness

02:33:07,550 --> 02:33:11,720
well it doesn't imply that and I'm going

02:33:09,560 --> 02:33:13,609
to give some examples there you can get

02:33:11,720 --> 02:33:16,069
these signals from the kernel from stuff

02:33:13,609 --> 02:33:18,140
like audit you can use perf to get those

02:33:16,069 --> 02:33:19,609
signals and then once you realize you

02:33:18,140 --> 02:33:21,770
have enough context based on some

02:33:19,609 --> 02:33:23,510
signals that you have you porno medicate

02:33:21,770 --> 02:33:26,510
stuff and for medication we have the

02:33:23,510 --> 02:33:28,310
LSMs we have SC Linux app armour you can

02:33:26,510 --> 02:33:31,220
use a comp and do medication using that

02:33:28,310 --> 02:33:32,930
so signal is just correlation and

02:33:31,220 --> 02:33:37,640
mitigation is just saying no don't do it

02:33:32,930 --> 02:33:40,129
it's bad i we realize there's something

02:33:37,640 --> 02:33:41,329
bad about every realizes we need to get

02:33:40,129 --> 02:33:43,249
new information from the operating

02:33:41,329 --> 02:33:45,890
system we need to add a new signal as

02:33:43,249 --> 02:33:48,199
per se and what do we need to do we need

02:33:45,890 --> 02:33:49,459
to update audit we let's say we need to

02:33:48,199 --> 02:33:52,699
update order to log environment

02:33:49,459 --> 02:33:54,109
variables now we want to do mitigation

02:33:52,699 --> 02:33:56,029
based on those new signals that we've

02:33:54,109 --> 02:33:59,539
added what do you want to do you have to

02:33:56,029 --> 02:34:02,419
update the LSMs so while they go hand in

02:33:59,539 --> 02:34:04,159
hand the process for doing signal and

02:34:02,419 --> 02:34:07,310
mitigation that's disjoined in the linux

02:34:04,159 --> 02:34:09,069
kernel right now I'm going to give you

02:34:07,310 --> 02:34:12,770
more examples of signals here right like

02:34:09,069 --> 02:34:14,390
up it's not really bad but a process

02:34:12,770 --> 02:34:16,459
that is executing and deleting its own

02:34:14,390 --> 02:34:18,529
executable something fishy is going on

02:34:16,459 --> 02:34:20,600
you want to audit log that the kernel

02:34:18,529 --> 02:34:22,489
module that gets loaded and it's hiding

02:34:20,600 --> 02:34:23,260
itself from prop modules why would you

02:34:22,489 --> 02:34:25,690
do that right

02:34:23,260 --> 02:34:28,300
suspicious environment variables

02:34:25,690 --> 02:34:31,660
setting the LD preload two times on the

02:34:28,300 --> 02:34:33,910
exact syscall y history size to zero

02:34:31,660 --> 02:34:35,680
while you execute the command something

02:34:33,910 --> 02:34:37,480
is fishy something fishy is going on

02:34:35,680 --> 02:34:39,190
there so you just want to already lock

02:34:37,480 --> 02:34:40,240
that and then you want to establish a

02:34:39,190 --> 02:34:43,120
fingerprint and then you want to

02:34:40,240 --> 02:34:46,540
medicate based on that some mitigations

02:34:43,120 --> 02:34:49,900
that the that we plan to do or we could

02:34:46,540 --> 02:34:51,730
do with this stuff and we need to is in

02:34:49,900 --> 02:34:53,950
data centers yeah why do you want to

02:34:51,730 --> 02:34:56,050
mount USB drives on servers you might

02:34:53,950 --> 02:34:58,990
want to have a like a whitelist of stuff

02:34:56,050 --> 02:35:01,030
that you are allowed to mount but that's

02:34:58,990 --> 02:35:03,280
sort of dynamic whitelist or dynamic Mac

02:35:01,030 --> 02:35:06,370
in the sense could be configured with

02:35:03,280 --> 02:35:07,960
the vpf again a white list of known calm

02:35:06,370 --> 02:35:09,910
or kernel modules is something again you

02:35:07,960 --> 02:35:13,540
can configure as a Mac using any PF on

02:35:09,910 --> 02:35:15,220
module loads also like preventing known

02:35:13,540 --> 02:35:16,510
vulnerable binaries from running like if

02:35:15,220 --> 02:35:19,510
you have millions and millions of

02:35:16,510 --> 02:35:21,641
servers you have it's very hard to patch

02:35:19,510 --> 02:35:23,230
all the binaries or simply delete the

02:35:21,641 --> 02:35:24,940
executable just because it's it's

02:35:23,230 --> 02:35:26,351
vulnerable so you want to you want to

02:35:24,940 --> 02:35:28,660
know that you want to have extra

02:35:26,351 --> 02:35:29,860
protections there and then you can what

02:35:28,660 --> 02:35:31,290
you may also want to prevent them from

02:35:29,860 --> 02:35:33,460
running on your production environment

02:35:31,290 --> 02:35:35,620
so there are two use cases for Google

02:35:33,460 --> 02:35:39,010
here we have our Corp environment which

02:35:35,620 --> 02:35:40,450
is which is obviously the west there's a

02:35:39,010 --> 02:35:43,420
lot of things that happen we want to

02:35:40,450 --> 02:35:46,450
audit log stuff there and we also have

02:35:43,420 --> 02:35:48,250
the the production environment it's very

02:35:46,450 --> 02:35:49,840
hard to get through but like we also

02:35:48,250 --> 02:35:54,010
want security and auditing happening

02:35:49,840 --> 02:35:58,480
there so how does it work

02:35:54,010 --> 02:36:01,120
we said we are nellis em so it maps to

02:35:58,480 --> 02:36:03,880
why are we using an RSM we could use

02:36:01,120 --> 02:36:06,670
something like set comp or use like hook

02:36:03,880 --> 02:36:08,620
system call entry points because SEC LSM

02:36:06,670 --> 02:36:10,840
is map better to security behaviors so

02:36:08,620 --> 02:36:13,000
I'm when I say security behaviors what I

02:36:10,840 --> 02:36:14,530
essentially mean is when I talk to a

02:36:13,000 --> 02:36:16,690
security analyst they don't tell me that

02:36:14,530 --> 02:36:18,460
look you know can you hook up the exact

02:36:16,690 --> 02:36:20,590
system call on the system right they

02:36:18,460 --> 02:36:22,391
tell me I want to lock this when a

02:36:20,590 --> 02:36:24,280
process is executed and that map's

02:36:22,391 --> 02:36:28,300
really well for from an allison

02:36:24,280 --> 02:36:29,891
perspective so one one good thing it is

02:36:28,300 --> 02:36:32,080
easy to miss if your instrumenting

02:36:29,891 --> 02:36:35,860
system calls because i this is something

02:36:32,080 --> 02:36:38,790
i am a few like or some many years back

02:36:35,860 --> 02:36:40,440
we missed the exactly at system call so

02:36:38,790 --> 02:36:42,750
missing out ordered logs because it's an

02:36:40,440 --> 02:36:44,670
API and not the behavior it's one of the

02:36:42,750 --> 02:36:46,230
ways you could do stuff I also realized

02:36:44,670 --> 02:36:47,460
when I was developing the LSM you have

02:36:46,230 --> 02:36:49,771
user mode helpers in the kernel that

02:36:47,460 --> 02:36:52,140
would do exec and definitely not a

02:36:49,771 --> 02:36:53,400
system called the pathway that it would

02:36:52,140 --> 02:36:56,220
get triggered but it does go through the

02:36:53,400 --> 02:36:58,590
LS m hook the other thing which I feel

02:36:56,220 --> 02:37:00,870
this could help with is actually benefit

02:36:58,590 --> 02:37:02,160
the LSM ecosystem because you get

02:37:00,870 --> 02:37:04,050
feedback from the security community

02:37:02,160 --> 02:37:06,300
coming in you ask them what are the

02:37:04,050 --> 02:37:08,190
actual security hooks you need and you

02:37:06,300 --> 02:37:09,510
want these in EPF programs to be simple

02:37:08,190 --> 02:37:10,830
enough so that security analysts or

02:37:09,510 --> 02:37:13,530
engineers or whatever you call them they

02:37:10,830 --> 02:37:15,330
can write that and then we get oh this

02:37:13,530 --> 02:37:16,800
place is where we need access control

02:37:15,330 --> 02:37:19,110
maybe somewhere in the block layer maybe

02:37:16,800 --> 02:37:21,420
somewhere somebody wants to protect LBA

02:37:19,110 --> 02:37:22,950
address ranges there so there is there

02:37:21,420 --> 02:37:24,690
is definitely we want to get that

02:37:22,950 --> 02:37:29,130
feedback loop going for the LS m

02:37:24,690 --> 02:37:31,410
ecosystem as well okay so other

02:37:29,130 --> 02:37:34,500
technical perspective that's a pretty

02:37:31,410 --> 02:37:36,510
picture that we show it it's it creates

02:37:34,500 --> 02:37:38,220
a file in security FS which is

02:37:36,510 --> 02:37:41,220
correspond it has one-to-one correlation

02:37:38,220 --> 02:37:43,230
with a LS amok it's not the same name

02:37:41,220 --> 02:37:45,240
because we might realize that some hook

02:37:43,230 --> 02:37:47,040
is a better map to the behavior so be

02:37:45,240 --> 02:37:49,350
PRM check security is mapping to process

02:37:47,040 --> 02:37:51,000
execution it could be be PRM set creds

02:37:49,350 --> 02:37:53,190
or whatever but you at least want to

02:37:51,000 --> 02:37:55,410
guarantee the stable API there the user

02:37:53,190 --> 02:37:57,750
they load the program typical BPF stop

02:37:55,410 --> 02:38:01,200
do BPF proclo get to file descriptors

02:37:57,750 --> 02:38:04,140
and what quieres I tend to do is it

02:38:01,200 --> 02:38:06,660
stores this your your BPF programs in an

02:38:04,140 --> 02:38:07,980
array in the dentary of this file that

02:38:06,660 --> 02:38:09,900
you create so it's that's what

02:38:07,980 --> 02:38:11,850
attachment essentially means and then

02:38:09,900 --> 02:38:13,650
you have other LS m's it can be stacked

02:38:11,850 --> 02:38:16,110
with this not a major a lesson yet it

02:38:13,650 --> 02:38:17,910
could be a major LSM if you know major

02:38:16,110 --> 02:38:20,940
LSMs have access to these things called

02:38:17,910 --> 02:38:23,040
security blobs and currently it's in the

02:38:20,940 --> 02:38:24,180
work to use like a parm and isolating

02:38:23,040 --> 02:38:25,920
some major LS M's

02:38:24,180 --> 02:38:29,010
you can use them you cannot use them

02:38:25,920 --> 02:38:30,690
together as of now but Karis I can be

02:38:29,010 --> 02:38:33,480
stacked with other atoms at this point

02:38:30,690 --> 02:38:35,910
and and when this PP aramchek security

02:38:33,480 --> 02:38:37,950
is encountered in the kernel it does it

02:38:35,910 --> 02:38:41,430
can say it can look at user arguments

02:38:37,950 --> 02:38:43,440
and stuff and say no don't do that what

02:38:41,430 --> 02:38:45,840
does it look like eventually so you have

02:38:43,440 --> 02:38:47,940
that buffer there that buffer there is

02:38:45,840 --> 02:38:51,420
the buffer that the ebps program is

02:38:47,940 --> 02:38:52,779
going to write to your audit logs the

02:38:51,420 --> 02:38:55,180
return value from the EPF

02:38:52,779 --> 02:38:56,470
program is essentially like a no perm

02:38:55,180 --> 02:38:58,749
don't do that

02:38:56,470 --> 02:39:00,010
that's your enforcement part there this

02:38:58,749 --> 02:39:02,799
buffer is currently the performance

02:39:00,010 --> 02:39:06,819
buffer because we have BPF perf event

02:39:02,799 --> 02:39:09,010
output it's quite performant and it's a

02:39:06,819 --> 02:39:10,899
it's pity that it's called perf because

02:39:09,010 --> 02:39:13,239
it's not performance is not its only use

02:39:10,899 --> 02:39:14,919
case and this is one of the questions or

02:39:13,239 --> 02:39:17,529
discussion topics I have at the end is

02:39:14,919 --> 02:39:19,810
is this I saw there were some proposals

02:39:17,529 --> 02:39:22,299
about making it more generic but our

02:39:19,810 --> 02:39:23,770
current our current plan is to use perf

02:39:22,299 --> 02:39:25,720
or anything that is there in that space

02:39:23,770 --> 02:39:28,899
that allows gives the same performance

02:39:25,720 --> 02:39:30,430
characteristics so and then on the top

02:39:28,899 --> 02:39:32,979
you have something that processes your

02:39:30,430 --> 02:39:34,810
audit logs like it could be or it could

02:39:32,979 --> 02:39:36,339
be a detection pipeline or some security

02:39:34,810 --> 02:39:37,569
product that you're building on top or

02:39:36,339 --> 02:39:39,669
it could be a small command line that

02:39:37,569 --> 02:39:41,890
allows you to hook these eb PF programs

02:39:39,669 --> 02:39:43,449
and actually masks the fact that there

02:39:41,890 --> 02:39:44,770
any PF programs and gives an interface

02:39:43,449 --> 02:39:46,539
to somebody who is a classical said a

02:39:44,770 --> 02:39:50,229
sysadmin and doesn't even want to write

02:39:46,539 --> 02:39:53,470
e b PF programs so it's you can have

02:39:50,229 --> 02:39:54,789
that there as well the there are few key

02:39:53,470 --> 02:39:56,709
design principles we're going to keep in

02:39:54,789 --> 02:39:58,930
mind when we writing this LS m and that

02:39:56,709 --> 02:40:00,819
is these helpers have to be precise and

02:39:58,930 --> 02:40:03,489
granular which means that i'm giving an

02:40:00,819 --> 02:40:05,799
example after this but you don't want

02:40:03,489 --> 02:40:07,479
things like VP of probe read because it

02:40:05,799 --> 02:40:09,640
is exposing too many kernel internals

02:40:07,479 --> 02:40:12,249
and if you want security people to write

02:40:09,640 --> 02:40:14,649
programs that can get a useful audit

02:40:12,249 --> 02:40:16,359
logs or useful medications they will not

02:40:14,649 --> 02:40:19,029
be able to use these helpers for

02:40:16,359 --> 02:40:21,039
creating that stuff is it also gives you

02:40:19,029 --> 02:40:23,399
you need start getting accesses to

02:40:21,039 --> 02:40:25,569
kernel data structures in this case and

02:40:23,399 --> 02:40:26,169
deployment on a large scale becomes a

02:40:25,569 --> 02:40:29,470
huge challenge

02:40:26,169 --> 02:40:34,449
so BPF probe read we want to avoid that

02:40:29,470 --> 02:40:36,100
stuff we use the pouring buffer I'm

02:40:34,449 --> 02:40:38,319
going to mention one particular thing

02:40:36,100 --> 02:40:39,789
that we really liked in comparison there

02:40:38,319 --> 02:40:40,959
is a bigger talk that we do and we

02:40:39,789 --> 02:40:43,749
compare all the other alternatives

02:40:40,959 --> 02:40:46,359
available but it's the time span is

02:40:43,749 --> 02:40:47,949
really short the essential benefit to

02:40:46,359 --> 02:40:49,479
user space here is the format in which

02:40:47,949 --> 02:40:51,760
you generate these audit logs is

02:40:49,479 --> 02:40:53,589
controlled by user space so I have my

02:40:51,760 --> 02:40:55,209
struct or whatever right I use the

02:40:53,589 --> 02:40:57,100
helpers to fill that information in I

02:40:55,209 --> 02:40:58,959
write it to the performance buffer and I

02:40:57,100 --> 02:41:01,239
own the life cycle or the format in

02:40:58,959 --> 02:41:03,339
which I'm writing audit logs to which is

02:41:01,239 --> 02:41:05,799
very useful other things like ordered in

02:41:03,339 --> 02:41:06,610
this case they have performance impact

02:41:05,799 --> 02:41:08,620
yes

02:41:06,610 --> 02:41:09,971
they also have limitations on the

02:41:08,620 --> 02:41:12,820
structure which you get the information

02:41:09,971 --> 02:41:13,841
back from from the colonel so the

02:41:12,820 --> 02:41:15,341
colonel is not in the business of

02:41:13,841 --> 02:41:17,891
dictating the format in which these logs

02:41:15,341 --> 02:41:19,150
are generated so that's why we like

02:41:17,891 --> 02:41:21,490
purfling buffer there are some

02:41:19,150 --> 02:41:22,750
advantages and disadvantages which are

02:41:21,490 --> 02:41:24,730
classical software engineering

02:41:22,750 --> 02:41:26,080
challenges if you're going to do per CPU

02:41:24,730 --> 02:41:29,080
stuff you will need to replicate memory

02:41:26,080 --> 02:41:31,091
and then you will have to honor on our

02:41:29,080 --> 02:41:34,301
initial calculations this doesn't amount

02:41:31,091 --> 02:41:36,551
to much on even if you have hundred CPUs

02:41:34,301 --> 02:41:39,761
and it works pretty much it so it works

02:41:36,551 --> 02:41:42,330
pretty well that's the example I was

02:41:39,761 --> 02:41:45,250
talking about the helper design choices

02:41:42,330 --> 02:41:46,420
so security analysts tell you that you

02:41:45,250 --> 02:41:47,950
know we want to log environment

02:41:46,420 --> 02:41:51,601
variables right you could write the

02:41:47,950 --> 02:41:54,400
helper that is Kell inverse right and

02:41:51,601 --> 02:41:55,841
which is the man variables can be 32

02:41:54,400 --> 02:41:59,170
pages long I was surprised to see that

02:41:55,841 --> 02:42:01,870
but yes they are and this is higher

02:41:59,170 --> 02:42:03,610
coverage but significant overhead

02:42:01,870 --> 02:42:05,261
because you have to copy norman

02:42:03,610 --> 02:42:07,570
variables into a buffer basically what

02:42:05,261 --> 02:42:10,061
Matthew was talking about for user page

02:42:07,570 --> 02:42:13,570
faults you cannot you cannot preempt eb

02:42:10,061 --> 02:42:15,460
PF programs but you could also have a

02:42:13,570 --> 02:42:17,710
more precise helper in this case which

02:42:15,460 --> 02:42:19,330
is get me the environment very get me

02:42:17,710 --> 02:42:20,980
the value of LD preload that because

02:42:19,330 --> 02:42:22,540
that's what i'm interested in or get me

02:42:20,980 --> 02:42:24,790
the value of fist file size or whatever

02:42:22,540 --> 02:42:26,051
so you start thinking about the actual

02:42:24,790 --> 02:42:27,490
information you need rather than dumping

02:42:26,051 --> 02:42:29,110
everything and generating a lot of

02:42:27,490 --> 02:42:31,380
overhead on your pipeline and on your

02:42:29,110 --> 02:42:35,080
user space and the system in general so

02:42:31,380 --> 02:42:36,841
that's rough case study of how we won't

02:42:35,080 --> 02:42:45,431
do coab or designing helpers yes

02:42:36,841 --> 02:42:47,351
somebody has a question yes but if you

02:42:45,431 --> 02:42:49,420
have preemption disabled while calling

02:42:47,351 --> 02:42:51,011
the helper it does not help you I am

02:42:49,420 --> 02:42:53,200
going to talk about hugging code on that

02:42:51,011 --> 02:42:55,690
Alex I said that we have people come up

02:42:53,200 --> 02:42:59,320
with weird hacks to or or I would say

02:42:55,690 --> 02:43:00,730
optimizations but let's I'm going to

02:42:59,320 --> 02:43:04,061
explain what kind of optimizations we

02:43:00,730 --> 02:43:05,591
came up for this so yeah these poor

02:43:04,061 --> 02:43:06,940
programs cannot sleep or run and they

02:43:05,591 --> 02:43:08,920
cannot they cannot be preempted

02:43:06,940 --> 02:43:11,620
so the LSM hooked us some

02:43:08,920 --> 02:43:14,320
pre-computation deep erm check security

02:43:11,620 --> 02:43:17,440
you get those an art pages you can't

02:43:14,320 --> 02:43:19,900
call you cat user pages remote it LS a

02:43:17,440 --> 02:43:20,590
MOOC is not it's not afflicted by the

02:43:19,900 --> 02:43:22,570
same thing as the

02:43:20,590 --> 02:43:24,370
so when the Ellison hook when you reach

02:43:22,570 --> 02:43:25,990
the LSI Mook you copy all the in have

02:43:24,370 --> 02:43:27,970
been very wills into the into the into a

02:43:25,990 --> 02:43:31,450
buffer and you pass it to the EVP of

02:43:27,970 --> 02:43:33,760
context in that as a pointer and yeah

02:43:31,450 --> 02:43:35,560
like and you can we add another

02:43:33,760 --> 02:43:37,120
optimization we check whether this call

02:43:35,560 --> 02:43:39,250
to the whether a call to this helper

02:43:37,120 --> 02:43:40,810
actually exists in the PPF program so

02:43:39,250 --> 02:43:44,020
that not all programs are afflicted with

02:43:40,810 --> 02:43:45,850
the with this copy of the buffer and the

02:43:44,020 --> 02:43:47,830
exact system call is not typically the

02:43:45,850 --> 02:43:50,200
most performant system calls anyways

02:43:47,830 --> 02:43:53,020
because i realized when i was running on

02:43:50,200 --> 02:43:55,330
a in a vm versus like when i was running

02:43:53,020 --> 02:43:57,970
on a large server that this was very

02:43:55,330 --> 02:43:59,590
minimal impact the again there is we

02:43:57,970 --> 02:44:02,200
published performance data with

02:43:59,590 --> 02:44:03,460
comparison to audit it's not an apples

02:44:02,200 --> 02:44:04,870
to apples comparison because audit

02:44:03,460 --> 02:44:06,970
doesn't even log environment variables

02:44:04,870 --> 02:44:09,580
but with the same amount of information

02:44:06,970 --> 02:44:11,710
we were able to kind of relatively tight

02:44:09,580 --> 02:44:15,580
distribution for latency even in the

02:44:11,710 --> 02:44:16,870
exact says called pathway and and also

02:44:15,580 --> 02:44:19,030
we could do these optimizations for

02:44:16,870 --> 02:44:22,840
anything that was not needed then you

02:44:19,030 --> 02:44:25,420
know don't enable auditing there so the

02:44:22,840 --> 02:44:27,790
the there are some questions we posted

02:44:25,420 --> 02:44:30,580
the patch set on the list and there are

02:44:27,790 --> 02:44:33,310
some questions that we want to have we

02:44:30,580 --> 02:44:36,939
have a single program type PPF proc type

02:44:33,310 --> 02:44:38,710
k RS i so that's and there is a single

02:44:36,939 --> 02:44:42,939
attachment type we don't want to

02:44:38,710 --> 02:44:45,250
complicate all of that stuff and since

02:44:42,939 --> 02:44:48,130
we want other and the analysts or

02:44:45,250 --> 02:44:49,630
security people to write programs so

02:44:48,130 --> 02:44:51,609
that's one thing that is up for

02:44:49,630 --> 02:44:55,149
discussion the performance buffer stuff

02:44:51,609 --> 02:44:57,030
is up for discussion and yeah that's

02:44:55,149 --> 02:45:02,220
pretty much it from my for my talk

02:44:57,030 --> 02:45:05,080
questions first of comments about a

02:45:02,220 --> 02:45:07,990
periphery upper yeah and you can have a

02:45:05,080 --> 02:45:10,000
per cpu preferring buffer yeah so that

02:45:07,990 --> 02:45:12,310
way you do not waste a man work memory

02:45:10,000 --> 02:45:14,790
or other cpus you just need opinion user

02:45:12,310 --> 02:45:17,439
space of process it was the degree cpu

02:45:14,790 --> 02:45:19,870
nice should work okay

02:45:17,439 --> 02:45:25,510
you can buffer okay are you the second

02:45:19,870 --> 02:45:27,609
is if you have how many data points all

02:45:25,510 --> 02:45:31,210
that had attached pointer for january

02:45:27,609 --> 02:45:33,430
SSM sorry how many basically you

02:45:31,210 --> 02:45:34,409
mentioned a few attach points right yeah

02:45:33,430 --> 02:45:38,169
and home

02:45:34,409 --> 02:45:39,249
oh the LSM hook if there is an Ellison

02:45:38,169 --> 02:45:42,039
hook and if you want to get data back

02:45:39,249 --> 02:45:44,109
from the Ellison MOOC you will create a

02:45:42,039 --> 02:45:46,449
file in the security FS there is a

02:45:44,109 --> 02:45:48,069
single attach type but you can get the

02:45:46,449 --> 02:45:50,020
file descriptor file you still DFS back

02:45:48,069 --> 02:45:51,819
you get the program file descriptor and

02:45:50,020 --> 02:45:53,079
then you attach the program you store it

02:45:51,819 --> 02:45:55,209
in the basically in the dentary for that

02:45:53,079 --> 02:45:58,359
so you essentially is a programmable

02:45:55,209 --> 02:46:07,119
like I oh say yes example yes exactly

02:45:58,359 --> 02:46:09,039
yeah any more questions yes so with the

02:46:07,119 --> 02:46:10,959
approaches you propose there I mean you

02:46:09,039 --> 02:46:13,720
kind of need to know in advance what you

02:46:10,959 --> 02:46:16,300
will touch within the program before you

02:46:13,720 --> 02:46:18,340
start the program so what what would you

02:46:16,300 --> 02:46:20,380
do if you need the program computation

02:46:18,340 --> 02:46:22,840
to identify the actual pages you're

02:46:20,380 --> 02:46:24,880
going to touch so so what happens is we

02:46:22,840 --> 02:46:27,669
know that we know the scale as I get in

02:46:24,880 --> 02:46:29,649
the VAR helper needs to have access to

02:46:27,669 --> 02:46:31,449
the argument pages right so you call get

02:46:29,649 --> 02:46:33,310
user get outrageous you know that

02:46:31,449 --> 02:46:35,560
there's a function call in there's a

02:46:33,310 --> 02:46:37,419
call to this helper and only if there's

02:46:35,560 --> 02:46:39,489
a call to the helper you will get the

02:46:37,419 --> 02:46:41,020
pages back you would get these specific

02:46:39,489 --> 02:46:44,260
pages back okay so it's a specific

02:46:41,020 --> 02:46:46,600
solution for a specific exactly it's not

02:46:44,260 --> 02:46:48,699
generically solving the sleeping evps

02:46:46,600 --> 02:46:50,260
problem for sure and when Alexa tells me

02:46:48,699 --> 02:46:52,180
that it's going to be happening anytime

02:46:50,260 --> 02:46:53,680
it's going to be happening soon that

02:46:52,180 --> 02:46:55,419
comforts me and I can get rid of all of

02:46:53,680 --> 02:46:57,850
that code and when you sleep in the

02:46:55,419 --> 02:46:59,709
pages is it just a get user page it get

02:46:57,850 --> 02:47:02,260
get user pages because kate user pages

02:46:59,709 --> 02:47:03,760
is a very weird like you you have to you

02:47:02,260 --> 02:47:06,340
you're appointed to the top of the stack

02:47:03,760 --> 02:47:08,289
there and then you can need to do weird

02:47:06,340 --> 02:47:09,699
pointer arithmetic i spend time doing

02:47:08,289 --> 02:47:11,439
that rather than doing all of that in

02:47:09,699 --> 02:47:13,810
the hooks context you can do that in the

02:47:11,439 --> 02:47:16,029
ls mmm yeah so so i did play with this a

02:47:13,810 --> 02:47:17,709
little bit the problem there I think it

02:47:16,029 --> 02:47:19,840
does not guarantee that it's within the

02:47:17,709 --> 02:47:22,630
page table it currently is the existence

02:47:19,840 --> 02:47:24,220
of the page so if after that within the

02:47:22,630 --> 02:47:26,319
interpreter you're actually trying to

02:47:24,220 --> 02:47:28,840
get control of that we copy other

02:47:26,319 --> 02:47:30,340
internal okay because otherwise

02:47:28,840 --> 02:47:32,499
otherwise we cannot guarantee anything

02:47:30,340 --> 02:47:35,729
we you could still trigger a page for it

02:47:32,499 --> 02:47:35,729
right like you yeah that's no

02:47:40,530 --> 02:47:47,340
just trying to decide how this mechanics

02:47:43,020 --> 02:47:50,370
work so this is part o everyone and you

02:47:47,340 --> 02:47:52,200
doing this num number of pages so how do

02:47:50,370 --> 02:47:52,859
you know how many pages are this parts

02:47:52,200 --> 02:47:57,570
are still missing

02:47:52,859 --> 02:47:59,220
so no pages to copy if you have it so

02:47:57,570 --> 02:48:00,990
like you know you know the num art pages

02:47:59,220 --> 02:48:03,720
it's still in the next VP item struct

02:48:00,990 --> 02:48:06,450
and in the Linux BPM struck has a

02:48:03,720 --> 02:48:09,630
pointer to the top of first page located

02:48:06,450 --> 02:48:12,270
also as you start iterating on the arc

02:48:09,630 --> 02:48:15,660
see an RV okay so yeah so it comes from

02:48:12,270 --> 02:48:19,109
the actual process well but then if the

02:48:15,660 --> 02:48:23,520
process is huge it can on purpose have

02:48:19,109 --> 02:48:27,630
well gigabyte of algebra though of Argos

02:48:23,520 --> 02:48:30,229
of re and now you just like copy the

02:48:27,630 --> 02:48:33,840
gigabyte of memory sure like so that's

02:48:30,229 --> 02:48:35,850
security it's not it's bounded by the

02:48:33,840 --> 02:48:37,550
the stack size so your stack our limit

02:48:35,850 --> 02:48:41,280
will limit that but if you have a giant

02:48:37,550 --> 02:48:43,470
stack our limit but there are not

02:48:41,280 --> 02:48:45,930
completely insane stack limits and the

02:48:43,470 --> 02:48:48,660
all those things will be contained

02:48:45,930 --> 02:48:51,300
within the stack and when it was first

02:48:48,660 --> 02:48:56,910
exact so it's it's not as bad as you

02:48:51,300 --> 02:48:59,160
think but it is potentially still very I

02:48:56,910 --> 02:49:00,930
mean yes this is this is a this is the

02:48:59,160 --> 02:49:02,310
what we want to also do in the helper

02:49:00,930 --> 02:49:03,720
choice there is right like if the

02:49:02,310 --> 02:49:07,560
environment so let's say you set LD

02:49:03,720 --> 02:49:09,479
preload to a gig last value right you

02:49:07,560 --> 02:49:10,710
leave the choice on to user space you

02:49:09,479 --> 02:49:11,790
leave the choice to them that what do

02:49:10,710 --> 02:49:13,859
you want to do in this case you want to

02:49:11,790 --> 02:49:16,380
reserve a buffer that is so large and

02:49:13,859 --> 02:49:18,090
then and get the audit data out or you

02:49:16,380 --> 02:49:20,160
want to mark that as an overflow and

02:49:18,090 --> 02:49:22,109
then lock the overflow as an audit lock

02:49:20,160 --> 02:49:23,790
because that's also signal if someone is

02:49:22,109 --> 02:49:26,250
trying to do that an LD preload with a

02:49:23,790 --> 02:49:27,510
gig size that is that that is that is

02:49:26,250 --> 02:49:29,250
actually a very malicious behavior that

02:49:27,510 --> 02:49:31,050
you want to audit and you may want to

02:49:29,250 --> 02:49:35,240
deny that from your reading VPS program

02:49:31,050 --> 02:49:35,240
itself so that's one option you have

02:49:40,189 --> 02:49:45,680
there's one thing I wanted to mention is

02:49:42,680 --> 02:49:47,600
in the context there the does the PPF

02:49:45,680 --> 02:49:48,830
context we don't allow any reads into

02:49:47,600 --> 02:49:50,449
the context from the program it's

02:49:48,830 --> 02:49:54,319
essentially like a token that you passed

02:49:50,449 --> 02:49:56,659
your helper because first issue is ease

02:49:54,319 --> 02:49:58,100
of use like we don't want the people who

02:49:56,659 --> 02:50:00,140
are using the helpers that we want them

02:49:58,100 --> 02:50:01,810
to use it as an API rather than playing

02:50:00,140 --> 02:50:05,960
with the court and also helps in keeping

02:50:01,810 --> 02:50:08,000
in in helps SS that maintain us work ASI

02:50:05,960 --> 02:50:09,620
to add and change things in the context

02:50:08,000 --> 02:50:12,470
without worrying about breaking user

02:50:09,620 --> 02:50:14,000
space so it is essentially your token

02:50:12,470 --> 02:50:16,370
that you pass to helper and get data

02:50:14,000 --> 02:50:18,140
back from it you don't have the verifier

02:50:16,370 --> 02:50:20,029
just says if you add access anything

02:50:18,140 --> 02:50:22,819
from the memory it just says no for now

02:50:20,029 --> 02:50:25,100
it's a conservative start to something

02:50:22,819 --> 02:50:27,350
we might revisit later on but we don't

02:50:25,100 --> 02:50:30,159
want to open open that can of worms to

02:50:27,350 --> 02:50:30,159
the user space right now

02:50:38,479 --> 02:50:42,590
right thank you thanks a lot

02:50:42,930 --> 02:50:49,129
[Applause]

02:51:07,990 --> 02:51:13,939
test test

02:51:10,210 --> 02:51:19,160
hello this one should be a shorter way

02:51:13,939 --> 02:51:21,290
so mad batch processing and we have

02:51:19,160 --> 02:51:23,990
discussed a little bit in upstream and

02:51:21,290 --> 02:51:25,399
we try to present here and to see where

02:51:23,990 --> 02:51:28,370
the other people some own opinions or

02:51:25,399 --> 02:51:31,700
not let's see and the use KC the quite

02:51:28,370 --> 02:51:34,570
clear a batch processing in general will

02:51:31,700 --> 02:51:37,189
give you some performance advantage and

02:51:34,570 --> 02:51:40,490
here we are talking about the map like

02:51:37,189 --> 02:51:43,100
map lookup map lookup and delete map

02:51:40,490 --> 02:51:48,620
update map delete all these operations

02:51:43,100 --> 02:51:51,170
and current current approach typically a

02:51:48,620 --> 02:51:55,310
user space to do is through the neck

02:51:51,170 --> 02:51:58,609
piece after another like a PPF map get

02:51:55,310 --> 02:52:00,620
an X key and for example and the typical

02:51:58,609 --> 02:52:02,689
user space you will get next key and

02:52:00,620 --> 02:52:06,680
then you will do something about this

02:52:02,689 --> 02:52:09,140
key and look up get the value or delete

02:52:06,680 --> 02:52:11,990
the previous key and then you go to the

02:52:09,140 --> 02:52:16,970
next where and get next key and when

02:52:11,990 --> 02:52:19,910
when cisco and at a time and the

02:52:16,970 --> 02:52:22,790
patching approach and will give you some

02:52:19,910 --> 02:52:25,880
performance because it able to do the

02:52:22,790 --> 02:52:28,220
say one hand your key lookup and one

02:52:25,880 --> 02:52:30,620
hand your key like a delete one at a

02:52:28,220 --> 02:52:34,310
time and in the kernel and there's some

02:52:30,620 --> 02:52:38,990
synthetic basically examples and just a

02:52:34,310 --> 02:52:41,090
tight loop to like look up for 1 million

02:52:38,990 --> 02:52:43,010
keys something like that can give a more

02:52:41,090 --> 02:52:46,220
than 70 percent performance improvement

02:52:43,010 --> 02:52:50,570
and the typical use case is a look up

02:52:46,220 --> 02:52:55,760
look up delete and delete that's in PCC

02:52:50,570 --> 02:52:58,160
and in some other applications and in

02:52:55,760 --> 02:53:01,670
upstream away have to currently

02:52:58,160 --> 02:53:04,040
approaches and firstly is a single batch

02:53:01,670 --> 02:53:05,720
processing and it doesn't know that

02:53:04,040 --> 02:53:09,020
distinguish between different elements

02:53:05,720 --> 02:53:10,180
the treatment is the same if you let me

02:53:09,020 --> 02:53:11,560
say look

02:53:10,180 --> 02:53:13,989
before we hand your keys a the way

02:53:11,560 --> 02:53:15,460
echoes through from first to the behind

02:53:13,989 --> 02:53:18,340
us and they return to you

02:53:15,460 --> 02:53:21,970
and that's our first away and the second

02:53:18,340 --> 02:53:25,270
way is like a programmable like each key

02:53:21,970 --> 02:53:27,819
we can have a PPF program and try to

02:53:25,270 --> 02:53:30,520
tell you what to do about this key and a

02:53:27,819 --> 02:53:33,460
for example you say delete and you can

02:53:30,520 --> 02:53:35,529
say look up you can say delete and look

02:53:33,460 --> 02:53:37,800
up so this kind of like a give you

02:53:35,529 --> 02:53:41,770
action for each key value pair

02:53:37,800 --> 02:53:45,430
so both approaches and we need to make

02:53:41,770 --> 02:53:49,270
sure and especially in the PPF hash

02:53:45,430 --> 02:53:51,160
table and it has a bucket and it's

02:53:49,270 --> 02:53:53,739
possible when you try to get next key

02:53:51,160 --> 02:53:56,109
and actually the key you try to start is

02:53:53,739 --> 02:53:58,660
deleted at this point you lose the

02:53:56,109 --> 02:54:01,120
information and where is the next key

02:53:58,660 --> 02:54:03,670
and the current implementation we say ok

02:54:01,120 --> 02:54:06,279
we just go to the first key and if this

02:54:03,670 --> 02:54:08,170
happens you could say from the first one

02:54:06,279 --> 02:54:10,470
go to second where you're suddenly lose

02:54:08,170 --> 02:54:12,910
check and you go to first where again

02:54:10,470 --> 02:54:15,040
second is circled one Hanjin and lose

02:54:12,910 --> 02:54:19,180
track again you go to a first so it's

02:54:15,040 --> 02:54:21,340
kind of bad so we needed we need to have

02:54:19,180 --> 02:54:23,290
a back better mechanism in kernel and

02:54:21,340 --> 02:54:26,430
the simpler just go through each key and

02:54:23,290 --> 02:54:30,939
if I delete head away to something and

02:54:26,430 --> 02:54:33,489
so no need come to the next slides we

02:54:30,939 --> 02:54:36,880
propose to do a bucket abased iteration

02:54:33,489 --> 02:54:41,260
and alexei mention it is in one of the

02:54:36,880 --> 02:54:45,630
upstream emails and the user user space

02:54:41,260 --> 02:54:48,790
and the the the go is the user space

02:54:45,630 --> 02:54:51,340
request does not based on keys it based

02:54:48,790 --> 02:54:54,640
on some kind of opaque number like a

02:54:51,340 --> 02:54:58,270
batch ID and internally this batch ID

02:54:54,640 --> 02:55:03,910
and map to some kind of the buckets in

02:54:58,270 --> 02:55:06,699
kernel and this and in kernel for each

02:55:03,910 --> 02:55:08,590
batch and we will first look take a log

02:55:06,699 --> 02:55:11,229
of all dispatch and then we do the

02:55:08,590 --> 02:55:14,350
operation and after operation is done we

02:55:11,229 --> 02:55:18,300
do unlock so this is actually a pretty

02:55:14,350 --> 02:55:21,761
simple idea is pretty simple and like

02:55:18,300 --> 02:55:23,980
Java and the Foley

02:55:21,761 --> 02:55:25,780
concurrent hash map has a similar

02:55:23,980 --> 02:55:33,641
mechanism so this is kind of like a

02:55:25,780 --> 02:55:35,830
standard way question what do you do if

02:55:33,641 --> 02:55:39,341
you have multiple elements in single

02:55:35,830 --> 02:55:41,740
bucket multiple single element in a

02:55:39,341 --> 02:55:43,480
single by you process as a patch you

02:55:41,740 --> 02:55:45,610
process all together what if the values

02:55:43,480 --> 02:55:49,120
are too big to output to the user space

02:55:45,610 --> 02:55:52,120
exactly in this case and we will return

02:55:49,120 --> 02:55:54,820
to user space say error code like a not

02:55:52,120 --> 02:55:57,730
enough space and then user space need to

02:55:54,820 --> 02:55:59,410
restart from that batch increase for

02:55:57,730 --> 02:56:04,240
example double they are buffer to the

02:55:59,410 --> 02:56:06,370
kernel and in worst case user space

02:56:04,240 --> 02:56:08,980
already know what's a maximum element is

02:56:06,370 --> 02:56:11,381
for your level for a particular map you

02:56:08,980 --> 02:56:13,271
need to provide a max element you just

02:56:11,381 --> 02:56:14,801
cover the whole thing it will care but

02:56:13,271 --> 02:56:16,601
user doesn't know how many hash

02:56:14,801 --> 02:56:18,311
collisions there are right no it does

02:56:16,601 --> 02:56:20,080
not but I actually have a question to a

02:56:18,311 --> 02:56:22,961
previous slide as well like where are

02:56:20,080 --> 02:56:25,961
this requirement of no duplicate

02:56:22,961 --> 02:56:27,700
previous one requirement could have no

02:56:25,961 --> 02:56:29,461
duplication in lookup doesn't mean like

02:56:27,700 --> 02:56:30,851
we should not return the same key twice

02:56:29,461 --> 02:56:33,311
yes

02:56:30,851 --> 02:56:34,990
something coffee why who user space and

02:56:33,311 --> 02:56:39,971
you but it's very easy to filter

02:56:34,990 --> 02:56:43,091
actually well it's not easy actually

02:56:39,971 --> 02:56:46,091
sometimes it if you go back repeatedly

02:56:43,091 --> 02:56:49,181
live and then you may get new keys and

02:56:46,091 --> 02:56:51,400
because it's so dynamically and

02:56:49,181 --> 02:56:55,591
something may delete new adding new

02:56:51,400 --> 02:56:58,601
things and you could but you could say I

02:56:55,591 --> 02:57:01,120
did it this way I opted to this way and

02:56:58,601 --> 02:57:04,961
then you say I remove this way some key

02:57:01,120 --> 02:57:06,641
may not be counted this way but if it's

02:57:04,961 --> 02:57:08,200
update you will have like previous value

02:57:06,641 --> 02:57:09,881
and new value so like if you see that

02:57:08,200 --> 02:57:12,131
the value changes look into the keys if

02:57:09,881 --> 02:57:13,870
you might have been deleted might have

02:57:12,131 --> 02:57:15,790
been gone for a while and I might be

02:57:13,870 --> 02:57:17,650
reacted because that's what I missed

02:57:15,790 --> 02:57:20,530
them and it might be the same the key

02:57:17,650 --> 02:57:22,091
and the value might be the same now but

02:57:20,530 --> 02:57:24,881
it might be at a different point in the

02:57:22,091 --> 02:57:26,200
length list inside of the bucket but so

02:57:24,881 --> 02:57:29,530
if you have the same situation was just

02:57:26,200 --> 02:57:33,851
bucket ID like you like one time you

02:57:29,530 --> 02:57:35,351
look up bucket zero and then like if you

02:57:33,851 --> 02:57:37,630
have mounted up

02:57:35,351 --> 02:57:40,811
we were doing error if like the packet

02:57:37,630 --> 02:57:41,830
ID will make forward progress it never

02:57:40,811 --> 02:57:43,630
go backward

02:57:41,830 --> 02:57:45,790
it may be stuck in a particular bucket

02:57:43,630 --> 02:57:48,221
they say no enough space and the user

02:57:45,790 --> 02:57:51,400
need to increase I mean the buffer size

02:57:48,221 --> 02:58:01,000
you will try you fail to succeed go to

02:57:51,400 --> 02:58:04,570
the next way never go back and as they

02:58:01,000 --> 02:58:06,790
say the simple I mean the you API and

02:58:04,570 --> 02:58:09,730
you just have a batch have input and

02:58:06,790 --> 02:58:13,721
output have some keys values buffer and

02:58:09,730 --> 02:58:16,511
how count this count is a input either

02:58:13,721 --> 02:58:19,150
provider a size of the buffer and output

02:58:16,511 --> 02:58:21,521
will be something like how many

02:58:19,150 --> 02:58:26,471
succeeded the user can get a sense and

02:58:21,521 --> 02:58:28,570
other is a map heavy I know map flex and

02:58:26,471 --> 02:58:30,690
this is the programmable or batch

02:58:28,570 --> 02:58:34,480
processing and proposed by Jakob

02:58:30,690 --> 02:58:37,540
unfortunately he is not here and so the

02:58:34,480 --> 02:58:39,910
idea is for each map and we kind of like

02:58:37,540 --> 02:58:42,311
to have a context which is a key value

02:58:39,910 --> 02:58:45,761
pair and there you fit into a PPF

02:58:42,311 --> 02:58:48,271
program and this ppl program will wrong

02:58:45,761 --> 02:58:51,370
and tell you what action for this

02:58:48,271 --> 02:58:54,160
basically map key and value pair and

02:58:51,370 --> 02:58:56,011
then you can say okay if it's a delete

02:58:54,160 --> 02:59:00,761
it will go to another thing and

02:58:56,011 --> 02:59:03,130
otherwise it probably do some action and

02:59:00,761 --> 02:59:06,971
in in the in the people program itself

02:59:03,130 --> 02:59:09,040
and it was synchronized RCU and then it

02:59:06,971 --> 02:59:11,170
will be for the Oh deleted the key it

02:59:09,040 --> 02:59:13,990
will go ahead delete but I gave you an

02:59:11,170 --> 02:59:16,710
option and try to do something of that

02:59:13,990 --> 02:59:20,650
something about this key value pair and

02:59:16,710 --> 02:59:22,690
before you delete it so this is a kind

02:59:20,650 --> 02:59:27,931
of like a programmable much more

02:59:22,690 --> 02:59:31,181
flexible and that's just another option

02:59:27,931 --> 02:59:32,860
what does that's a last slide so now up

02:59:31,181 --> 02:59:35,590
to discussion what do you think I'm I

02:59:32,860 --> 02:59:40,360
think what is interesting on the last

02:59:35,590 --> 02:59:42,490
approach what one example might be some

02:59:40,360 --> 02:59:44,740
sort of I don't know a garbage collector

02:59:42,490 --> 02:59:46,601
so you could compare timestamps already

02:59:44,740 --> 02:59:47,350
in your BPF program and then you can say

02:59:46,601 --> 02:59:49,390
okay

02:59:47,350 --> 02:59:51,909
in this element right away because right

02:59:49,390 --> 02:59:53,890
now you sort of have to do the lookup

02:59:51,909 --> 02:59:56,260
and then potentially that could be a

02:59:53,890 --> 02:59:58,330
race right because when then we need

02:59:56,260 --> 02:59:59,739
then say I'm going to delete it in the

02:59:58,330 --> 03:00:01,000
next system call it could already be

02:59:59,739 --> 03:00:02,500
gone and it could already be a new

03:00:01,000 --> 03:00:05,020
element but that's not what you actually

03:00:02,500 --> 03:00:08,619
want to delete that might happen that

03:00:05,020 --> 03:00:11,409
case it's always a chickie I mean it's

03:00:08,619 --> 03:00:13,720
the correct semantics it's hard to

03:00:11,409 --> 03:00:16,029
define I mean because you could race a

03:00:13,720 --> 03:00:18,250
little bit earlier to this offset a

03:00:16,029 --> 03:00:21,729
little bit and then it's really tricky

03:00:18,250 --> 03:00:23,710
yeah so for the programmable approach if

03:00:21,729 --> 03:00:25,659
you just want to dump all the elements

03:00:23,710 --> 03:00:28,600
like what will you do you will set up

03:00:25,659 --> 03:00:32,170
the perf buffer and will perceive and

03:00:28,600 --> 03:00:35,949
output all their values in this case yes

03:00:32,170 --> 03:00:37,840
and we will have a program itself and

03:00:35,949 --> 03:00:39,970
you do written to dump it to a

03:00:37,840 --> 03:00:42,010
preferring buffer but then so like

03:00:39,970 --> 03:00:44,830
whisper buffer approach the problem is

03:00:42,010 --> 03:00:46,359
that you don't have like a flow control

03:00:44,830 --> 03:00:48,340
essentially right like you will run the

03:00:46,359 --> 03:00:50,710
BPF program as fast as possible for

03:00:48,340 --> 03:00:52,390
every element and user space might not

03:00:50,710 --> 03:00:54,159
be able to consume all the elements you

03:00:52,390 --> 03:00:56,979
will be missing elements without knowing

03:00:54,159 --> 03:00:59,260
that right periphery now how would you

03:00:56,979 --> 03:01:02,649
dump a big table like you'll either have

03:00:59,260 --> 03:01:07,600
to pre allocate huge per bottle or you

03:01:02,649 --> 03:01:12,220
will lose elements right this is the

03:01:07,600 --> 03:01:17,290
same problem and you can you dump and

03:01:12,220 --> 03:01:19,449
then the I think the green buffer I

03:01:17,290 --> 03:01:21,699
don't know whether Peter can correct me

03:01:19,449 --> 03:01:24,689
and I think it will block all right and

03:01:21,699 --> 03:01:27,069
if you the kernel it will not block

03:01:24,689 --> 03:01:30,580
there's a flag at least right you'll

03:01:27,069 --> 03:01:34,060
know that you lost postings oh okay

03:01:30,580 --> 03:01:35,859
so yeah so there are of course like

03:01:34,060 --> 03:01:40,810
issues yeah if the ring buffer is too

03:01:35,859 --> 03:01:42,939
small like obviously but where this type

03:01:40,810 --> 03:01:46,659
of stuff I think we will need regardless

03:01:42,939 --> 03:01:48,640
is I think in an African tract it came

03:01:46,659 --> 03:01:51,189
out that would be good to have some sort

03:01:48,640 --> 03:01:53,739
of notification for the callback folder

03:01:51,189 --> 03:01:56,319
you expiring so this pretty much is the

03:01:53,739 --> 03:01:59,439
same mechanism so from very different

03:01:56,319 --> 03:02:01,780
use cases batching overview of this

03:01:59,439 --> 03:02:03,670
or like different zones in over you like

03:02:01,780 --> 03:02:06,010
all of this potentially is implementable

03:02:03,670 --> 03:02:08,890
with this new type of repair programs

03:02:06,010 --> 03:02:12,010
that are acting on map elements for Lulu

03:02:08,890 --> 03:02:13,780
potentially they can be called sighs to

03:02:12,010 --> 03:02:15,910
delete stuff in the program can actually

03:02:13,780 --> 03:02:19,300
see well whether this is on or not and

03:02:15,910 --> 03:02:22,680
do this zone stuff that you you wanted

03:02:19,300 --> 03:02:22,680
for different under you things right

03:02:37,189 --> 03:02:42,289
considering that the EB PF context runs

03:02:40,550 --> 03:02:43,999
with preemption disabled I'm not sure I

03:02:42,289 --> 03:02:47,689
understand how the synchronizers here is

03:02:43,999 --> 03:02:49,069
supposed to actually work because you

03:02:47,689 --> 03:02:50,930
cannot synchronize or see while

03:02:49,069 --> 03:02:52,720
preemption is off I'm pretty sure of

03:02:50,930 --> 03:03:00,109
that

03:02:52,720 --> 03:03:01,609
yeah we just remove it this is this may

03:03:00,109 --> 03:03:03,739
not this read all that you say but you

03:03:01,609 --> 03:03:07,249
runs through all of this then then do

03:03:03,739 --> 03:03:23,119
things like this is this is not during

03:03:07,249 --> 03:03:26,239
the program run this is the outside and

03:03:23,119 --> 03:03:28,220
primp wrong is inside and as he sees it

03:03:26,239 --> 03:03:35,390
does not approve any type of basically

03:03:28,220 --> 03:03:37,669
it just goes through the maps so maybe

03:03:35,390 --> 03:03:40,249
stupid questions about the way we will

03:03:37,669 --> 03:03:43,579
go through the regular rotating we worry

03:03:40,249 --> 03:03:45,169
about losing the the next key because if

03:03:43,579 --> 03:03:47,989
you have your nuts key on actually

03:03:45,169 --> 03:03:51,379
deleted okay we solve it by like if you

03:03:47,989 --> 03:03:56,329
have an open F P for this attached to

03:03:51,379 --> 03:03:59,239
the SV you have a pointer to the next to

03:03:56,329 --> 03:04:03,739
the next key so if not the key was

03:03:59,239 --> 03:04:05,659
deleted we were updated at the point for

03:04:03,739 --> 03:04:07,999
your next T it's already updated when

03:04:05,659 --> 03:04:12,709
you'll get it when the previous Knox was

03:04:07,999 --> 03:04:17,930
deleted but all these could be before

03:04:12,709 --> 03:04:19,669
and after right I mean if you've got

03:04:17,930 --> 03:04:21,470
something before this key that's all

03:04:19,669 --> 03:04:23,659
like that does kind of by design you do

03:04:21,470 --> 03:04:25,909
not escape it right we worry about it

03:04:23,659 --> 03:04:27,560
you have to go back but if you delete

03:04:25,909 --> 03:04:30,069
you don't have to go back to the first

03:04:27,560 --> 03:04:30,069
one so

03:04:30,370 --> 03:04:35,780
yes so essentially what traffic what

03:04:34,340 --> 03:04:38,240
your proposition is roughly what is

03:04:35,780 --> 03:04:39,860
implemented user space for exactly the

03:04:38,240 --> 03:04:41,931
same use case for a concurrent like

03:04:39,860 --> 03:04:44,240
update look up on the wall of the hash

03:04:41,931 --> 03:04:48,230
table and user space is doing it with

03:04:44,240 --> 03:04:50,120
the hazard pointers which is exactly

03:04:48,230 --> 03:04:51,920
sort of what you saying if you know that

03:04:50,120 --> 03:04:54,771
this is what you will be deleting and it

03:04:51,920 --> 03:04:56,601
is being deleted the the walk still

03:04:54,771 --> 03:04:59,210
preserves the element because it's

03:04:56,601 --> 03:05:01,130
walking it and this is sort of like

03:04:59,210 --> 03:05:02,540
alternative tour see you reclamation I

03:05:01,130 --> 03:05:08,300
think kernel wouldn't have cancer for in

03:05:02,540 --> 03:05:10,641
Jersey I mean we did user space doesn't

03:05:08,300 --> 03:05:12,590
know is generated right now well the in

03:05:10,641 --> 03:05:15,710
kernel one that gets deleted we could

03:05:12,590 --> 03:05:20,360
also say before we did it here to get an

03:05:15,710 --> 03:05:25,311
act and - well it's not that whatever

03:05:20,360 --> 03:05:30,500
both next is deleted as well yeah Tomica

03:05:25,311 --> 03:05:33,010
will be tricky if if I were possible I'm

03:05:30,500 --> 03:05:35,931
not sure whether it's possible

03:05:33,010 --> 03:05:38,240
couldn't we just move to the next bucket

03:05:35,931 --> 03:05:41,360
in case the previous element is not

03:05:38,240 --> 03:05:45,170
found because we are inconsistent anyway

03:05:41,360 --> 03:05:47,570
like even with the watch a approach if

03:05:45,170 --> 03:05:49,311
someone had elements to a bucket that we

03:05:47,570 --> 03:05:53,630
already Traverse we are going to miss

03:05:49,311 --> 03:05:56,240
elements anyway so that always happens

03:05:53,630 --> 03:05:58,311
so if we know in which direction we are

03:05:56,240 --> 03:06:01,340
going that in this case if we are

03:05:58,311 --> 03:06:03,950
dumping the entire map we already know

03:06:01,340 --> 03:06:06,620
that we want to finish so we wine we

03:06:03,950 --> 03:06:08,690
want to keep moving so I just move to

03:06:06,620 --> 03:06:13,271
the next bucket and provide me the next

03:06:08,690 --> 03:06:15,920
key that you can actually retrieve yeah

03:06:13,271 --> 03:06:18,110
basically in extreme case it's just

03:06:15,920 --> 03:06:19,971
everything you went back here that you

03:06:18,110 --> 03:06:22,280
didn't give a user a chance to a dump

03:06:19,971 --> 03:06:26,090
you just say moved on X 2 and X 1 has

03:06:22,280 --> 03:06:27,980
nothing so a common problem is that when

03:06:26,090 --> 03:06:29,181
you when you fetch and then you delete

03:06:27,980 --> 03:06:31,221
there's a chance that stuff change

03:06:29,181 --> 03:06:32,450
between when you fetched it and read it

03:06:31,221 --> 03:06:33,830
and when you delete it and what you

03:06:32,450 --> 03:06:36,230
really want to do is you want to fetch

03:06:33,830 --> 03:06:37,910
and delete it as an atomic operation so

03:06:36,230 --> 03:06:39,710
that you're deleting what you read and

03:06:37,910 --> 03:06:41,450
got in user space you know it was some

03:06:39,710 --> 03:06:43,101
event with some byte count or something

03:06:41,450 --> 03:06:46,370
you want to make sure that you deleted

03:06:43,101 --> 03:06:49,521
what you say so you basically want like

03:06:46,370 --> 03:06:51,500
fetch this delete this and return me

03:06:49,521 --> 03:06:53,391
something so that what I call this again

03:06:51,500 --> 03:06:55,700
I can get whatever is the next element

03:06:53,391 --> 03:06:57,380
and since you're fetching and deleting

03:06:55,700 --> 03:06:59,570
you're effectively always pulling out

03:06:57,380 --> 03:07:01,580
the first element from the bucket so the

03:06:59,570 --> 03:07:03,230
next element is just that same bucket

03:07:01,580 --> 03:07:04,700
again and then if you call it and it's

03:07:03,230 --> 03:07:06,470
empty you move on to the next one and

03:07:04,700 --> 03:07:09,110
until you find whatever is the next one

03:07:06,470 --> 03:07:12,590
that has something yes kind of like that

03:07:09,110 --> 03:07:14,960
although there's a some difference is if

03:07:12,590 --> 03:07:16,370
you are over the first go through here

03:07:14,960 --> 03:07:18,830
and suddenly it's gone you go back

03:07:16,370 --> 03:07:21,170
somebody exert a lot of CP for that you

03:07:18,830 --> 03:07:28,550
start kneading it snapped a little bit

03:07:21,170 --> 03:07:32,290
difference people are simply looking for

03:07:28,550 --> 03:07:35,990
something like a database crusher so

03:07:32,290 --> 03:07:38,271
look at key and table put cursor at this

03:07:35,990 --> 03:07:45,681
point and then lookup delete from

03:07:38,271 --> 03:07:49,370
multiple keys at once without work I

03:07:45,681 --> 03:07:53,860
think that's what the proposal is to do

03:07:49,370 --> 03:07:57,980
this multiple is that ones so to answer

03:07:53,860 --> 03:07:59,630
Michelle's point so we have we in a

03:07:57,980 --> 03:08:02,960
current hash table implementation we use

03:07:59,630 --> 03:08:05,420
a linked list of all click list nulls

03:08:02,960 --> 03:08:09,561
and why we're doing this null stuff

03:08:05,420 --> 03:08:11,630
because they can be cases where you

03:08:09,561 --> 03:08:14,110
start walking the linked list and in

03:08:11,630 --> 03:08:16,370
this bucket you have a key that like

03:08:14,110 --> 03:08:19,700
completely somewhere out like it could

03:08:16,370 --> 03:08:22,940
be before it could be after so like if

03:08:19,700 --> 03:08:24,320
you its me may not be related even to

03:08:22,940 --> 03:08:26,120
like delete in the element just by

03:08:24,320 --> 03:08:29,030
walking the bucket you potentially have

03:08:26,120 --> 03:08:30,860
braces getting the elements you can

03:08:29,030 --> 03:08:36,410
start in one bucket walking the new a

03:08:30,860 --> 03:08:37,880
listen finish that's why we started

03:08:36,410 --> 03:08:39,740
paying for the for the simple lookup

03:08:37,880 --> 03:08:41,960
that's why this how it works is how this

03:08:39,740 --> 03:08:45,050
whole not stuff walk will walk in this

03:08:41,960 --> 03:08:47,780
thing and like you found it not actually

03:08:45,050 --> 03:08:49,400
guard value it shows the bucket number

03:08:47,780 --> 03:08:52,670
it's in a different bike it will restart

03:08:49,400 --> 03:08:55,020
the whole thing where we're dumping we

03:08:52,670 --> 03:08:56,729
kind of dumping it along the way so I

03:08:55,020 --> 03:08:59,430
we like walk the whole thing

03:08:56,729 --> 03:09:07,500
pre-allocated for the dump because we

03:08:59,430 --> 03:09:10,289
have this reiterate stuff so it's so I

03:09:07,500 --> 03:09:13,439
think if I could basically call into the

03:09:10,289 --> 03:09:16,949
kernel say me saying give me a hundred

03:09:13,439 --> 03:09:19,890
elements with the qiyan values and

03:09:16,949 --> 03:09:23,189
delete them at the same time and then

03:09:19,890 --> 03:09:25,319
kind of tell me where where that ended I

03:09:23,189 --> 03:09:27,840
could that would give me the batching

03:09:25,319 --> 03:09:29,609
and it would I don't think it would be

03:09:27,840 --> 03:09:31,470
raised free because you're deleting it

03:09:29,609 --> 03:09:33,329
in the kernel so by definition you're

03:09:31,470 --> 03:09:34,760
you don't need to be walking link list

03:09:33,329 --> 03:09:42,529
you're always deleting from the front

03:09:34,760 --> 03:09:45,510
right not really

03:09:42,529 --> 03:09:47,909
auu deleted from front and it's supposed

03:09:45,510 --> 03:09:49,319
to I in a bucket a zero and come to a

03:09:47,909 --> 03:09:51,479
packed away and start you know delete

03:09:49,319 --> 03:09:53,250
and you're starting delete and assembled

03:09:51,479 --> 03:09:55,140
a filling packet is zero for that

03:09:53,250 --> 03:09:56,369
there's no problem if someone is adding

03:09:55,140 --> 03:09:58,710
or you go back do you need another

03:09:56,369 --> 03:10:01,170
bucket so long as I don't ever return to

03:09:58,710 --> 03:10:03,090
the earlier bucket right in this case it

03:10:01,170 --> 03:10:04,800
will return if you'll keep delete here

03:10:03,090 --> 03:10:06,539
now it's true that there may be so many

03:10:04,800 --> 03:10:08,579
insertions happening that I never

03:10:06,539 --> 03:10:10,649
successfully empty a bucket and move on

03:10:08,579 --> 03:10:12,659
to the next one yeah yeah yeah but

03:10:10,649 --> 03:10:15,149
imagine you have a bucket right like ten

03:10:12,659 --> 03:10:17,250
elements and you say like delete mow

03:10:15,149 --> 03:10:19,590
lookup and delete five elements right

03:10:17,250 --> 03:10:21,180
right you have to restart from the same

03:10:19,590 --> 03:10:23,130
bucket I have to restart from Saudi

03:10:21,180 --> 03:10:25,199
restart was always restart with the same

03:10:23,130 --> 03:10:26,970
bucket then you can get duplications

03:10:25,199 --> 03:10:33,479
because if you that's okay

03:10:26,970 --> 03:10:35,039
so publications are okay guys I think we

03:10:33,479 --> 03:10:39,899
need to we need we need to table the

03:10:35,039 --> 03:10:42,180
discussion I don't think right now and

03:10:39,899 --> 03:10:46,189
we out of time and we have a strict

03:10:42,180 --> 03:10:46,189
deadline thank you

03:10:46,630 --> 03:10:53,400
[Applause]

03:10:49,729 --> 03:10:55,200
and thank you everyone for coming it was

03:10:53,400 --> 03:10:57,600
an awesome if you have my crack

03:10:55,200 --> 03:11:02,430
conference thank you all the presenters

03:10:57,600 --> 03:11:03,860
and all the changes your presence made a

03:11:02,430 --> 03:11:07,390
big difference

03:11:03,860 --> 03:11:10,360
this is applause to you

03:11:07,390 --> 03:11:10,360

YouTube URL: https://www.youtube.com/watch?v=t66aeahLoGY


