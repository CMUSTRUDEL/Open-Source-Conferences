Title: LPC2019 - Real Time - MC
Publication date: 2019-11-18
Playlist: LPC2019 - MicroConferences
Description: 
	Real Time - MC
Captions: 
	00:00:00,970 --> 00:00:03,910
- Okay, so I suppose you can start.

00:00:05,600 --> 00:00:07,050
Course scheduling seems to be

00:00:08,550 --> 00:00:09,970
all the rage these days.

00:00:09,970 --> 00:00:11,220
I think this is the third

00:00:13,310 --> 00:00:14,143
talk on it.

00:00:16,400 --> 00:00:18,080
Who doesn't know what it is?

00:00:18,080 --> 00:00:19,221
Where do I start?

00:00:19,221 --> 00:00:21,170
(laughter)

00:00:21,170 --> 00:00:24,311
- [Man] You might ask who doesn't want to know what it is.

00:00:24,311 --> 00:00:27,736
- I don't want to know.

00:00:27,736 --> 00:00:30,470
(laughs)

00:00:30,470 --> 00:00:33,760
Okay, so core scheduling is basically

00:00:34,750 --> 00:00:36,090
again, scheduling

00:00:36,090 --> 00:00:39,560
but just for the SMT threads

00:00:39,560 --> 00:00:40,520
within one core,

00:00:41,890 --> 00:00:43,640
synchronized to our task selection.

00:00:47,460 --> 00:00:50,500
This all got really important when L1TF happened

00:00:52,610 --> 00:00:55,060
and then MDS happened and it fell apart.

00:00:57,670 --> 00:01:00,740
But since we're playing with the core scheduling idea

00:01:00,740 --> 00:01:02,200
for other reasons,

00:01:02,200 --> 00:01:03,800
people have come up and said,

00:01:03,800 --> 00:01:07,300
"We can use this for other purposes."

00:01:07,300 --> 00:01:08,700
Some of them are creative,

00:01:09,550 --> 00:01:11,200
some of them actually make sense,

00:01:12,160 --> 00:01:14,520
but to have the real-time people

00:01:14,520 --> 00:01:15,730
latched onto the idea,

00:01:17,600 --> 00:01:20,890
the problem is hyper threads are not really

00:01:22,180 --> 00:01:23,900
all that deterministic

00:01:23,900 --> 00:01:27,905
or they're very deterministically awful

00:01:27,905 --> 00:01:29,013
(laughs)

00:01:29,013 --> 00:01:31,140
for real-time interference

00:01:31,140 --> 00:01:33,100
for latencies and all that things,

00:01:33,100 --> 00:01:35,290
so a number of people have

00:01:36,940 --> 00:01:39,490
basically disabled SMT on their systems

00:01:40,340 --> 00:01:42,850
to gain better latency.

00:01:42,850 --> 00:01:44,010
Clark waves, yay.

00:01:46,810 --> 00:01:49,700
So a number of people have played

00:01:49,700 --> 00:01:51,450
with hot-plug and CPU sets

00:01:51,450 --> 00:01:54,260
to partially disable SMT

00:01:54,260 --> 00:01:56,420
so the non-real-time tasks

00:01:56,420 --> 00:01:59,150
can still get some through put benefit

00:01:59,150 --> 00:02:01,450
and there's all sorts of intermediate options.

00:02:03,180 --> 00:02:06,950
Core scheduling can give you another mix

00:02:06,950 --> 00:02:10,500
where you allow a real-time task to

00:02:12,000 --> 00:02:14,420
force IDLE-D the SMT siblings

00:02:15,650 --> 00:02:17,850
and thereby avoid the interference.

00:02:19,100 --> 00:02:21,050
Of course this brings up a whole bunch

00:02:21,050 --> 00:02:23,340
of interesting questions,

00:02:23,340 --> 00:02:25,990
I mean it wouldn't be real-time if there weren't any.

00:02:27,380 --> 00:02:30,140
Admission control will be impacted,

00:02:35,100 --> 00:02:36,600
yeah, so things like that.

00:02:40,410 --> 00:02:41,340
Daniel was

00:02:43,730 --> 00:02:48,730
studying some of that.

00:02:49,090 --> 00:02:52,370
- [Man] Regarding the animation controls,

00:02:52,370 --> 00:02:54,350
what we were talking about was that

00:02:54,350 --> 00:02:56,730
when we disable SMT

00:02:56,730 --> 00:02:58,420
we lose some CPUs.

00:02:58,420 --> 00:03:03,420
Let's say that we have two cores and with four threads CPU.

00:03:03,450 --> 00:03:05,690
When we disable HT,

00:03:05,690 --> 00:03:09,360
we end up with only two cores running, right?

00:03:09,360 --> 00:03:11,800
But in the current scattered line code,

00:03:11,800 --> 00:03:14,250
and Yuri might help me as well,

00:03:14,250 --> 00:03:16,630
so with the admission control

00:03:16,630 --> 00:03:19,340
assuming that we have these four CPUs

00:03:19,340 --> 00:03:21,600
when we have HT enabled,

00:03:21,600 --> 00:03:24,850
but, and the idea is that we can use at most

00:03:24,850 --> 00:03:27,930
by default 95% of CPU time,

00:03:28,940 --> 00:03:30,270
but it's

00:03:32,290 --> 00:03:34,530
95% of all CPUs.

00:03:34,530 --> 00:03:37,700
If we turn two of the CPUs off

00:03:37,700 --> 00:03:41,510
we will be able to use 190% of CPU.

00:03:41,510 --> 00:03:44,910
- So the trivial hack would be of course to then

00:03:44,910 --> 00:03:46,890
account double the bandwidth,

00:03:46,890 --> 00:03:48,980
and for however many siblings

00:03:48,980 --> 00:03:50,150
there are on the system

00:03:51,060 --> 00:03:51,960
to admission control,

00:03:51,960 --> 00:03:54,490
but then we need per CPU admission control,

00:03:54,490 --> 00:03:56,130
which we were already looking into,

00:03:56,130 --> 00:03:58,610
but which is slightly non-trivial.

00:04:01,630 --> 00:04:02,800
So this just has some

00:04:05,390 --> 00:04:07,740
very nice upsides, but it's also

00:04:10,660 --> 00:04:11,493
difficult again.

00:04:13,290 --> 00:04:15,930
- The one point that we need to consider is

00:04:15,930 --> 00:04:19,600
that on Sky Deadline we have the computation time

00:04:19,600 --> 00:04:21,520
the maximum execution time that we're

00:04:21,520 --> 00:04:22,840
expecting from one task.

00:04:23,860 --> 00:04:26,350
And if you run with SMT disabled,

00:04:26,350 --> 00:04:29,000
we have a better precision

00:04:29,000 --> 00:04:30,160
on that number, right?

00:04:30,160 --> 00:04:31,800
- [Man] Correct.

00:04:31,800 --> 00:04:34,530
- And when we have a core scheduling,

00:04:37,420 --> 00:04:40,120
is it good to have at all hyper

00:04:40,120 --> 00:04:41,940
trade-ins in the sky deadline?

00:04:41,940 --> 00:04:43,740
What do you think what people think?

00:04:45,340 --> 00:04:49,299
- [Presenter] So, for me, I guess it's good for the

00:04:49,299 --> 00:04:50,890
non-real-time part

00:04:50,890 --> 00:04:52,420
of the tasker system

00:04:52,420 --> 00:04:55,290
because if you disable hyper threading

00:04:56,220 --> 00:04:59,060
I mean forth not hyper threading then

00:04:59,060 --> 00:05:03,640
you basically have the available cores.

00:05:03,640 --> 00:05:06,170
If you let it on you can use part

00:05:06,170 --> 00:05:07,490
of the system for, for example,

00:05:07,490 --> 00:05:11,480
deadline tasks and force idle the other siblings

00:05:11,480 --> 00:05:13,440
and maybe on other cores that don't really

00:05:13,440 --> 00:05:16,900
interact with those you can run more stuff.

00:05:16,900 --> 00:05:18,630
- Right Daniel says,

00:05:18,630 --> 00:05:21,770
"Does it ever make sense to not force idle

00:05:21,770 --> 00:05:24,540
siblings for deadlines, and I think some of the soft

00:05:25,820 --> 00:05:28,420
real-time might actually want SMT on.

00:05:28,420 --> 00:05:30,487
I think people actually leave SMT on.

00:05:30,487 --> 00:05:34,760
- Yeah, I guess if you you're not into hard

00:05:34,760 --> 00:05:36,730
real-time type of R&D's I guess, yeah.

00:05:37,610 --> 00:05:40,340
- So yeah it should be policy, and not,

00:05:40,340 --> 00:05:41,640
I think strictly enforced.

00:05:42,930 --> 00:05:46,960
- So I wanted to try and understand something here

00:05:46,960 --> 00:05:48,470
which I know is gonna be difficult

00:05:48,470 --> 00:05:51,360
for me this early in the morning.

00:05:54,280 --> 00:05:56,150
Are you saying that if you've got,

00:05:56,150 --> 00:05:58,880
we've got core scheduling and SMT enabled,

00:06:00,070 --> 00:06:01,620
we can take a real-time task

00:06:01,620 --> 00:06:03,590
that we feel like has very hard deadlines

00:06:03,590 --> 00:06:04,630
or something and tag it

00:06:04,630 --> 00:06:06,980
so that it has no siblings?

00:06:06,980 --> 00:06:07,813
- [Presenter] Correct.

00:06:07,813 --> 00:06:08,800
- So that when we schedule it,

00:06:08,800 --> 00:06:10,270
it forces idle the other thread,

00:06:10,270 --> 00:06:11,880
and that gives us a,

00:06:11,880 --> 00:06:12,870
is that the mechanism?

00:06:12,870 --> 00:06:15,010
- So you avoid EDS empty interference

00:06:15,010 --> 00:06:16,880
by some random other thread

00:06:16,880 --> 00:06:18,580
that just happens to be co-schedulers

00:06:18,580 --> 00:06:20,440
on that core.

00:06:20,440 --> 00:06:22,580
- You just add the OT overhead

00:06:22,580 --> 00:06:24,810
of bringing the other thread into idle.

00:06:25,720 --> 00:06:27,960
- [Presenter] There is that.

00:06:27,960 --> 00:06:29,540
It doesn't come for free.

00:06:29,540 --> 00:06:30,890
There's no free lunch ever.

00:06:32,270 --> 00:06:33,770
Sadly.

00:06:33,770 --> 00:06:34,790
- [Man] No ponies?

00:06:34,790 --> 00:06:35,670
- No ponies.

00:06:35,670 --> 00:06:36,503
- [Man] Unicorn?

00:06:37,910 --> 00:06:38,953
- Talk to Case.

00:06:38,953 --> 00:06:40,100
(laughter)

00:06:40,100 --> 00:06:41,770
He has unicorns for you.

00:06:50,574 --> 00:06:51,850
- So I just wanna understand this.

00:06:51,850 --> 00:06:53,810
So it's basically it's whenever the RT task

00:06:53,810 --> 00:06:56,480
is scheduled onto the cores when you then--

00:06:56,480 --> 00:06:58,800
- Yeah you do it on scheduling.

00:06:58,800 --> 00:07:01,820
- Okay so, would it be possible just,

00:07:01,820 --> 00:07:03,720
would it be a flag, I mean one way I could see is just

00:07:03,720 --> 00:07:06,200
you know, don't let or make ISO CPU

00:07:06,200 --> 00:07:07,390
type of thing or CPU set,

00:07:07,390 --> 00:07:09,670
never let that one just shut down

00:07:09,670 --> 00:07:10,550
one of the things--

00:07:10,550 --> 00:07:12,490
- So that's something that people currently do.

00:07:12,490 --> 00:07:13,550
They do CPU sets,

00:07:13,550 --> 00:07:16,440
and they do the partial offline of siblings,

00:07:18,160 --> 00:07:19,510
but it's for the mixed workload

00:07:19,510 --> 00:07:22,930
where there is a lot of non-real-time story

00:07:22,930 --> 00:07:25,850
with some real-time stuff in,

00:07:25,850 --> 00:07:27,950
and you still want to get some

00:07:27,950 --> 00:07:28,870
of that benefit,

00:07:30,150 --> 00:07:31,360
so then fully disabling

00:07:31,360 --> 00:07:33,380
the hyper threads will be a bigger

00:07:33,380 --> 00:07:35,790
performance impact than necessary,

00:07:35,790 --> 00:07:39,680
and in these cases the core scheduling

00:07:39,680 --> 00:07:41,420
might help with that.

00:07:41,420 --> 00:07:42,410
- Okay so basically it sounds

00:07:42,410 --> 00:07:43,730
like something that they don't really care

00:07:43,730 --> 00:07:45,410
about true determinism.

00:07:45,410 --> 00:07:46,680
I mean we'll have a little,

00:07:46,680 --> 00:07:48,200
or well it could be deterministic,

00:07:48,200 --> 00:07:49,040
but the latency is like

00:07:49,040 --> 00:07:50,190
okay well we'll take the

00:07:50,190 --> 00:07:51,710
hit for the overhead cause we need the

00:07:51,710 --> 00:07:52,610
throughput anyway,

00:07:53,510 --> 00:07:55,560
so it's for that workload where you have,

00:07:57,112 --> 00:07:58,860
actually there's one right next to you too.

00:07:58,860 --> 00:08:00,550
- No, actually the thing is that

00:08:02,610 --> 00:08:04,780
you take the overhead for bringing

00:08:04,780 --> 00:08:07,660
the other thing out into idle,

00:08:07,660 --> 00:08:09,180
the other sibling,

00:08:09,180 --> 00:08:11,160
but you get in the advantage

00:08:11,160 --> 00:08:13,840
that you're having all the CPU

00:08:13,840 --> 00:08:15,860
shared resources for yourself

00:08:15,860 --> 00:08:17,100
while you're computing.

00:08:17,100 --> 00:08:18,700
- Yeah, there's no contention on

00:08:19,580 --> 00:08:20,700
instruction issue and there's no

00:08:20,700 --> 00:08:22,230
contention on your L1 cache,

00:08:23,160 --> 00:08:25,160
things like that, so you get the entire core,

00:08:25,160 --> 00:08:26,520
just for your real-time workload

00:08:26,520 --> 00:08:28,830
without the typical SMT interference.

00:08:28,830 --> 00:08:33,100
- So if you can stand the work and delay

00:08:33,100 --> 00:08:37,830
it takes to get the other sibling idle then...

00:08:38,940 --> 00:08:41,450
- Yeah, so that selection gets a little more expensive

00:08:41,450 --> 00:08:42,900
because we need to do

00:08:42,900 --> 00:08:44,300
that selection for two CPUs,

00:08:45,702 --> 00:08:47,550
and you need to send an IPI

00:08:47,550 --> 00:08:49,420
which is not entirely free.

00:08:49,420 --> 00:08:50,253
- [Man] Right.

00:08:52,316 --> 00:08:53,149
- Well then it's also not true that you

00:08:53,149 --> 00:08:54,990
don't have contention on your l1 cache

00:08:54,990 --> 00:08:56,420
if it's empty of anything you're

00:08:56,420 --> 00:08:58,790
interested in when you get the CPU.

00:08:58,790 --> 00:09:01,440
So that's a cost of setup, too.

00:09:01,440 --> 00:09:03,550
- Correct but that's something

00:09:03,550 --> 00:09:04,590
your real-time tasks already

00:09:04,590 --> 00:09:08,140
have to live with anyway.

00:09:08,140 --> 00:09:09,710
- [Man] So it's a little bit more.

00:09:11,163 --> 00:09:12,590
- No, I was saying, what my idea was

00:09:12,590 --> 00:09:14,010
so if you actually have the scheduling,

00:09:14,010 --> 00:09:15,810
if you're expecting a quick wake-up,

00:09:16,910 --> 00:09:18,310
this could cause a little bit or at least

00:09:18,310 --> 00:09:20,610
overhead on the wake up, and so that's why the jitter

00:09:20,610 --> 00:09:21,443
and then--

00:09:23,368 --> 00:09:24,860
- The thing is,

00:09:24,860 --> 00:09:27,000
you don't care about the quick wake-up.

00:09:27,000 --> 00:09:27,833
- Right that's what I'm saying--

00:09:27,833 --> 00:09:29,060
- You care about the end.

00:09:30,430 --> 00:09:31,940
- [Man] Yeah once you start running, you want to make sure

00:09:31,940 --> 00:09:34,592
that you are running as smoothly and--

00:09:34,592 --> 00:09:36,700
- See you ought to take the,

00:09:37,960 --> 00:09:39,530
let's quantify it,

00:09:39,530 --> 00:09:41,350
two microseconds hit on wake-up,

00:09:42,300 --> 00:09:46,860
then getting a runtime jitter which is

00:09:46,860 --> 00:09:47,870
non-deterministic.

00:09:48,720 --> 00:09:50,940
- And I guess this also probably would be useful

00:09:50,940 --> 00:09:52,490
for the no Hertz full,

00:09:52,490 --> 00:09:53,790
so if you have an RT task

00:09:53,790 --> 00:09:55,590
that's by itself,

00:09:55,590 --> 00:09:56,580
kicks off on the thing,

00:09:56,580 --> 00:09:58,370
runs in and doesn't want any interference

00:09:58,370 --> 00:10:00,930
from the kernel having the--

00:10:00,930 --> 00:10:05,050
- The HPC people switch off SMT anyway.

00:10:08,690 --> 00:10:10,390
- They turn off, oh.

00:10:10,390 --> 00:10:13,820
- They switch off SMT, HPC people turn off SMT.

00:10:13,820 --> 00:10:15,970
- [Man] Are they the only ones using the Hertz full or?

00:10:15,970 --> 00:10:19,000
- Yeah, that's the guys who use no Hertz full.

00:10:19,000 --> 00:10:20,340
- Yeah, so I'm trying, so who's,

00:10:20,340 --> 00:10:21,940
do you know are people are asking for

00:10:21,940 --> 00:10:23,750
this type of feature then?

00:10:23,750 --> 00:10:24,820
Or is it just something that we're helping

00:10:24,820 --> 00:10:26,280
or who brought up the problem?

00:10:26,280 --> 00:10:29,110
- No I mean the the core scheduling

00:10:29,110 --> 00:10:30,960
question comes obviously from the whole

00:10:30,960 --> 00:10:32,010
speculation crap,

00:10:33,794 --> 00:10:37,200
but people want to utilize SMT for

00:10:39,280 --> 00:10:40,230
several reasons,

00:10:42,330 --> 00:10:47,113
and then, but we have the same thing where,

00:10:50,340 --> 00:10:55,330
I was talking to RT people who would love to keep SMT on

00:10:55,330 --> 00:10:57,270
if they could isolate

00:10:59,472 --> 00:11:00,380
the core

00:11:00,380 --> 00:11:03,510
for the time the real-time task is running,

00:11:03,510 --> 00:11:06,630
and then give it back to random

00:11:06,630 --> 00:11:07,630
background workload.

00:11:09,070 --> 00:11:11,190
Because they see that the problem

00:11:11,190 --> 00:11:13,260
what they see is if they run,

00:11:14,330 --> 00:11:16,420
and you can easily figure it out

00:11:16,420 --> 00:11:18,190
by just offlining the CPU

00:11:19,540 --> 00:11:22,690
or in, out of the scheduling domain,

00:11:22,690 --> 00:11:25,010
same your runtime becomes,

00:11:25,010 --> 00:11:28,850
your execution time becomes deterministic and--

00:11:28,850 --> 00:11:31,250
- [Presenter] And more deterministic.

00:11:31,250 --> 00:11:33,660
- Yeah it's still a random generator but,

00:11:36,390 --> 00:11:40,020
but it becomes pretty good deterministic

00:11:40,020 --> 00:11:43,830
while when you have random other workloads

00:11:43,830 --> 00:11:45,750
on the other thread,

00:11:45,750 --> 00:11:47,850
then it depends what they are doing.

00:11:47,850 --> 00:11:49,400
- [Presenter] It's absolute chaos.

00:11:49,400 --> 00:11:51,100
- Completely out of the window,

00:11:51,100 --> 00:11:53,930
and that's especially true

00:11:53,930 --> 00:11:57,520
if you need to

00:11:57,520 --> 00:12:01,110
get on the resources which are only available once.

00:12:02,390 --> 00:12:05,370
So a lot of the issue ports are

00:12:06,330 --> 00:12:09,590
multiple, but we have things like ABX.

00:12:11,123 --> 00:12:12,310
- [Presenter] I mean, yeah, there's other ports and things

00:12:12,310 --> 00:12:13,470
and then the reaction.

00:12:13,470 --> 00:12:16,710
- Is this is going to be a config feature?

00:12:16,710 --> 00:12:17,543
So all RT tasks?

00:12:18,743 --> 00:12:20,630
Or do you have to actually do something to say tag this task

00:12:20,630 --> 00:12:23,410
once this ability, does it have to be an RT task?

00:12:23,410 --> 00:12:24,960
- No, no, it doesn't, so, so,

00:12:26,130 --> 00:12:28,590
the current implementation that is posted in,

00:12:29,600 --> 00:12:31,030
so I posted it once,

00:12:31,030 --> 00:12:31,980
and then I think the guys

00:12:31,980 --> 00:12:33,920
from (mutters) took it over.

00:12:33,920 --> 00:12:34,753
Thank you!

00:12:39,530 --> 00:12:42,230
That selection is outside of

00:12:42,230 --> 00:12:43,250
the scheduling classes.

00:12:43,250 --> 00:12:45,370
It works across all the scheduling classes.

00:12:45,370 --> 00:12:46,570
It worked for deadlines,

00:12:47,450 --> 00:12:49,720
FIFO, round robin, and other.

00:12:51,040 --> 00:12:53,680
Currently the only interface that is there,

00:12:53,680 --> 00:12:54,800
it's a C group interface,

00:12:54,800 --> 00:12:56,780
and this is because I was absolutely lazy.

00:12:56,780 --> 00:12:58,420
It was the easiest one to hack in,

00:12:58,420 --> 00:13:00,810
and the C group you can use,

00:13:01,780 --> 00:13:03,780
operate with Bash, I can echo into it.

00:13:03,780 --> 00:13:05,220
- So I can't complain,

00:13:06,930 --> 00:13:10,050
can't complain about other people,

00:13:10,050 --> 00:13:12,220
who is coming up with the C group thing first,

00:13:12,220 --> 00:13:14,840
instead of thinking about a proper interface?

00:13:14,840 --> 00:13:16,560
I blame it all on you.

00:13:16,560 --> 00:13:17,757
- You're welcome.

00:13:17,757 --> 00:13:20,007
(laughter)

00:13:21,550 --> 00:13:23,605
The pet shot, "This is a heck."

00:13:23,605 --> 00:13:26,020
(laughter)

00:13:26,020 --> 00:13:29,900
Anyway but the thinking is that we'll do a PR CTL

00:13:29,900 --> 00:13:30,950
for tasks.

00:13:35,140 --> 00:13:38,370
- [Man] So why why can't we have a

00:13:38,370 --> 00:13:39,203
solution like

00:13:40,930 --> 00:13:45,320
few cores are offlining one HT and then the scheduler only

00:13:45,320 --> 00:13:47,350
schedules real-time tasks on the cores

00:13:47,350 --> 00:13:49,280
that have HT disabled?

00:13:49,280 --> 00:13:52,260
Like that can be our solution for this, right?

00:13:52,260 --> 00:13:53,240
- Yeah and that's something

00:13:53,240 --> 00:13:54,590
that some people actually do,

00:13:54,590 --> 00:13:56,030
and I already mentioned that.

00:13:56,030 --> 00:14:00,200
As the CPU sets, and then you disable partial HD.

00:14:01,810 --> 00:14:03,140
- [Man] Is that not good enough?

00:14:04,120 --> 00:14:07,220
- There's always complaining people.

00:14:07,220 --> 00:14:09,710
I mean if most of your workload

00:14:09,710 --> 00:14:11,490
is non-real-time but you do

00:14:11,490 --> 00:14:13,410
care about those few real-time workloads,

00:14:13,410 --> 00:14:18,350
this might be a better solution than--

00:14:18,350 --> 00:14:19,430
Yeah, in terms of utilization,

00:14:19,430 --> 00:14:20,500
and always just killing

00:14:20,500 --> 00:14:21,450
some of the HD.

00:14:23,430 --> 00:14:25,590
- [Man] Yes, so on the interface for that

00:14:25,590 --> 00:14:28,250
then I guess we can have flagged also

00:14:28,250 --> 00:14:30,770
because we already have a flag to,

00:14:30,770 --> 00:14:34,310
for example I enable the runtime sharing.

00:14:35,460 --> 00:14:38,340
- Yeah so we still need to have this bike shed.

00:14:40,150 --> 00:14:41,990
API of ABIs yay!

00:14:45,244 --> 00:14:47,210
The thing I focused on while doing that

00:14:47,210 --> 00:14:49,570
pachet was just getting a mechanisms there

00:14:49,570 --> 00:14:51,520
and the general structure of it set up.

00:14:53,380 --> 00:14:55,480
The way it fundamentally works is

00:14:55,480 --> 00:14:58,020
every task gets a unsigned long cookie,

00:14:59,150 --> 00:15:00,260
and when you schedule,

00:15:01,540 --> 00:15:03,110
if the cookie is nonzero,

00:15:04,380 --> 00:15:06,080
all the siblings need to have a

00:15:06,080 --> 00:15:08,680
task of that same cookie or get forced idle.

00:15:10,020 --> 00:15:11,870
I don't care how the cookie gets set.

00:15:15,340 --> 00:15:19,530
So for the C Group we can tag all C Group

00:15:19,530 --> 00:15:23,170
and say all these tasks get the same cookie,

00:15:23,170 --> 00:15:24,230
and this is what I did,

00:15:24,230 --> 00:15:27,300
and then I basically stuck in the C group pointer.

00:15:29,960 --> 00:15:33,270
You can stick in a task pointer of its own task,

00:15:33,270 --> 00:15:34,570
and then it will only ever

00:15:35,700 --> 00:15:37,570
be the one which is for the real-time,

00:15:37,570 --> 00:15:39,530
or you can have it inherit,

00:15:39,530 --> 00:15:41,180
and then it becomes difficult,

00:15:41,180 --> 00:15:43,970
what do you point it to because the

00:15:43,970 --> 00:15:45,750
leading task and dying get reused.

00:15:49,640 --> 00:15:52,910
Fun questions like that still need to be answered.

00:15:52,910 --> 00:15:54,500
So yeah we'll have to bike shed

00:15:54,500 --> 00:15:57,530
on the specific APIs later.

00:16:01,320 --> 00:16:03,780
I am afraid we'll have to merge something

00:16:03,780 --> 00:16:06,120
like this because there's so many people

00:16:06,120 --> 00:16:08,210
that actually want it, even though--

00:16:08,210 --> 00:16:09,650
- [Man] For the wrong reasons.

00:16:09,650 --> 00:16:11,370
- For various reasons.

00:16:14,060 --> 00:16:16,370
Currently it is not a complete solution

00:16:16,370 --> 00:16:18,270
for any of the site channel stuff,

00:16:19,180 --> 00:16:20,810
but since we were working on it,

00:16:22,030 --> 00:16:24,540
enough people have shown interest

00:16:24,540 --> 00:16:26,190
for the feature for other reasons

00:16:28,240 --> 00:16:30,260
that I think there's a fair

00:16:31,980 --> 00:16:34,010
case to be made to merge some of this.

00:16:37,980 --> 00:16:40,300
- [Man] Going to the admission control,

00:16:40,300 --> 00:16:41,960
maybe the easiest thing to do would be

00:16:41,960 --> 00:16:43,820
to use just a half of the CPUs,

00:16:43,820 --> 00:16:45,420
just one per core,

00:16:45,420 --> 00:16:47,230
as the admission control

00:16:47,230 --> 00:16:48,063
to avoid the,

00:16:49,570 --> 00:16:52,390
yeah, but there is one question, when a task run,

00:16:52,390 --> 00:16:53,570
what would we do?

00:16:53,570 --> 00:16:56,540
So we have the admission control for one CPU in the core

00:16:56,540 --> 00:16:58,290
and none for the sibling let's say,

00:16:59,150 --> 00:17:01,800
and that should be discounted runtime of the one running

00:17:01,800 --> 00:17:02,900
in the sibling or not?

00:17:04,260 --> 00:17:06,980
And how this will interfere on group?

00:17:06,980 --> 00:17:09,830
- So for admission control, there's no runtime accounting

00:17:11,280 --> 00:17:12,860
or at least only D.

00:17:12,860 --> 00:17:16,770
- No, yeah, let's say that we decrease the

00:17:16,770 --> 00:17:17,720
admission control--

00:17:19,300 --> 00:17:21,110
- [Presenter] Oh, so,

00:17:21,110 --> 00:17:22,350
admission control.

00:17:22,350 --> 00:17:23,960
Let's get that line.

00:17:26,830 --> 00:17:29,290
The idea is to not allow more tasks

00:17:29,290 --> 00:17:31,500
on the system than there is time to run.

00:17:34,250 --> 00:17:36,220
Morton had a slot yesterday

00:17:36,220 --> 00:17:37,967
that brought up DVFS,

00:17:37,967 --> 00:17:39,710
and then it gets really complicated,

00:17:39,710 --> 00:17:41,460
but basically if,

00:17:42,760 --> 00:17:46,620
what scattered line tries to guarantee

00:17:46,620 --> 00:17:49,670
is a timely execution of your workload.

00:17:49,670 --> 00:17:52,220
Ideally it is before the deadline expires,

00:17:53,520 --> 00:17:57,340
with global EDF like we have now this is not a given.

00:17:57,340 --> 00:18:01,300
There are a number of workloads that do provide that,

00:18:01,300 --> 00:18:03,520
but what it does provide

00:18:03,520 --> 00:18:04,353
is that

00:18:05,750 --> 00:18:08,040
the missing of the deadlines is bounded.

00:18:08,040 --> 00:18:10,500
It will not get infinitely long misses,

00:18:11,690 --> 00:18:14,450
and we provide this guarantee by ensuring that

00:18:15,610 --> 00:18:19,900
we can never compute more than there is compute time for.

00:18:19,900 --> 00:18:21,510
And this is what admission control does.

00:18:21,510 --> 00:18:24,150
If we request a task,

00:18:24,150 --> 00:18:26,110
we tell it, this task

00:18:26,110 --> 00:18:27,750
wants this much run time

00:18:28,850 --> 00:18:30,500
over this period,

00:18:30,500 --> 00:18:33,010
and this is the bandwidth or utilization,

00:18:33,010 --> 00:18:36,510
and we add it up until some certain cap,

00:18:36,510 --> 00:18:39,210
currently that's in 95% wool time.

00:18:41,910 --> 00:18:43,300
If you were to exceed this,

00:18:43,300 --> 00:18:44,390
everything goes out the window

00:18:44,390 --> 00:18:45,550
and becomes an absolute mess.

00:18:45,550 --> 00:18:47,130
So at some point we need to say,

00:18:47,130 --> 00:18:48,630
this much and no more.

00:18:48,630 --> 00:18:50,950
This is what admission control does.

00:18:50,950 --> 00:18:53,330
So deadlines tasks you cannot fork them.

00:18:53,330 --> 00:18:55,260
Fork will fail always.

00:18:56,580 --> 00:19:00,370
You can only use get set after,

00:19:00,370 --> 00:19:01,780
which is the new system call

00:19:03,520 --> 00:19:05,040
on an existing task

00:19:05,040 --> 00:19:06,410
to request it be placed

00:19:06,410 --> 00:19:08,660
in the deadline class,

00:19:08,660 --> 00:19:10,150
and this will either succeed

00:19:10,150 --> 00:19:13,240
after which you can run the thing or it will fail

00:19:13,240 --> 00:19:16,450
if we say the system cannot support your request.

00:19:21,240 --> 00:19:22,073
So

00:19:23,500 --> 00:19:24,333
there's a whole,

00:19:28,490 --> 00:19:29,420
yeah so there's

00:19:30,650 --> 00:19:33,190
a whole debate on how good admission control is

00:19:33,190 --> 00:19:34,830
and how many guarantees it provides,

00:19:34,830 --> 00:19:36,540
currently not many guarantees,

00:19:36,540 --> 00:19:40,230
but it does provide that the system doesn't run away.

00:19:40,230 --> 00:19:41,710
It doesn't meltdown

00:19:41,710 --> 00:19:45,710
which is I think a very good guarantee to have.

00:19:50,300 --> 00:19:51,792
Not that, not that.

00:19:51,792 --> 00:19:54,560
(laughter)

00:19:54,560 --> 00:19:58,250
- Thinking on this, the safe thing to do in this way

00:19:58,250 --> 00:20:01,290
in this case would be disabling the

00:20:01,290 --> 00:20:04,300
or reducing the 95% for only

00:20:04,300 --> 00:20:07,180
those CPUs that we actually have online.

00:20:07,180 --> 00:20:09,650
- So currently we have a global admission control.

00:20:09,650 --> 00:20:14,350
So we can double the or quadruple or

00:20:14,350 --> 00:20:16,460
eight times for some of the power chips,

00:20:18,450 --> 00:20:19,720
the requested bandwidth

00:20:20,700 --> 00:20:21,750
and leave it at that.

00:20:23,190 --> 00:20:24,750
I was thinking that should be enough.

00:20:25,840 --> 00:20:27,250
Because we've basically consumed

00:20:27,250 --> 00:20:28,190
the resources of,

00:20:29,660 --> 00:20:31,730
if we were to run this task

00:20:31,730 --> 00:20:34,350
for however many SMT threads

00:20:34,350 --> 00:20:35,620
there are concurrently.

00:20:39,430 --> 00:20:41,920
- When running the admission control just multiply it

00:20:41,920 --> 00:20:43,990
by how many threads there are.

00:20:50,030 --> 00:20:53,620
- Just consider the task, and they will take the whole core.

00:20:53,620 --> 00:20:57,310
- So in this case you are expanding the computational time

00:20:57,310 --> 00:21:02,070
that the task can use, right, did I get it?

00:21:03,362 --> 00:21:05,280
Okay but now think on this way.

00:21:05,280 --> 00:21:07,480
The idea of core scheduling

00:21:07,480 --> 00:21:11,030
is trying to make more use of CPU available

00:21:11,030 --> 00:21:14,280
when it's safe to use those HD, right?

00:21:14,280 --> 00:21:16,630
But in the admission control, I'd say that the current

00:21:16,630 --> 00:21:17,780
that we have now,

00:21:17,780 --> 00:21:22,100
if you have disabling for hyper-threading,

00:21:22,100 --> 00:21:24,170
we're not on a system with eight CPUs.

00:21:25,270 --> 00:21:27,740
Four cores and eight threads.

00:21:27,740 --> 00:21:31,160
The safest thing to do now, it would be to use only the

00:21:32,110 --> 00:21:35,570
95% of the four CPUs not the eight, right?

00:21:35,570 --> 00:21:38,089
- But that is only if you do this for every scheduling

00:21:38,089 --> 00:21:40,680
tasks, but it's still configurable.

00:21:42,161 --> 00:21:43,630
- I like your idea because then you can

00:21:43,630 --> 00:21:47,030
do the inflate for only the task you

00:21:47,030 --> 00:21:48,290
want to run on,

00:21:48,290 --> 00:21:50,960
I mean to force the other siblings idle.

00:21:50,960 --> 00:21:54,260
But maybe don't do that for the software.

00:21:54,260 --> 00:21:56,130
- But I'm kind of lost, can you repeat, like,

00:21:56,130 --> 00:21:57,330
what was the idea that you said

00:21:57,330 --> 00:21:58,163
you liked the idea?

00:21:58,163 --> 00:21:59,100
I'm kind of--

00:22:00,780 --> 00:22:02,660
- So this will give interaction between the two,

00:22:02,660 --> 00:22:04,040
but basically for admission control,

00:22:04,040 --> 00:22:05,480
we currently only consider

00:22:05,480 --> 00:22:07,930
the utilization of the one request.

00:22:07,930 --> 00:22:09,640
We add it to what it's already given out,

00:22:09,640 --> 00:22:11,180
see if it goes over the threshold,

00:22:11,180 --> 00:22:14,470
if it goes over we reject, if it fits we accept,

00:22:16,540 --> 00:22:17,880
but because with core scheduling

00:22:17,880 --> 00:22:19,430
it would consume the entire core,

00:22:19,430 --> 00:22:21,010
however many threads there are

00:22:21,010 --> 00:22:22,270
instead of just the one,

00:22:23,110 --> 00:22:25,110
we simply multiply the utilization

00:22:25,110 --> 00:22:28,070
by however many threads we will now consume

00:22:28,070 --> 00:22:29,050
and use that value

00:22:30,500 --> 00:22:33,240
instead of,

00:22:33,240 --> 00:22:34,073
of the single value.

00:22:34,073 --> 00:22:36,340
- So basically if there's if it's two threads

00:22:36,340 --> 00:22:37,560
then it would be--

00:22:37,560 --> 00:22:39,460
- Then it would be times two.

00:22:39,460 --> 00:22:41,310
- So it looks like you could use the,

00:22:43,110 --> 00:22:45,080
you could pass that to set data.

00:22:46,670 --> 00:22:47,860
- This is one of the things Yuri,

00:22:47,860 --> 00:22:50,030
but also it becomes interesting,

00:22:54,680 --> 00:22:56,100
if we do the PR CTL

00:22:57,730 --> 00:23:00,500
after we've already gained deadlines,

00:23:01,740 --> 00:23:03,790
so we would probably want

00:23:03,790 --> 00:23:07,840
to deny the PR CTL to deadlines tasks in this.

00:23:14,340 --> 00:23:17,000
Maybe for deadline,

00:23:17,000 --> 00:23:19,550
but then there's two interfaces to set it on tasks.

00:23:25,014 --> 00:23:26,230
- I thought it was already extended.

00:23:26,230 --> 00:23:28,230
- It is extensible.

00:23:28,230 --> 00:23:31,210
- [Man] So let's use it for others as well.

00:23:31,210 --> 00:23:32,500
It's not-- - For everything?

00:23:32,500 --> 00:23:33,333
- Yes.

00:23:35,910 --> 00:23:37,930
To make one interface,

00:23:37,930 --> 00:23:40,160
if you configure deadline,

00:23:40,160 --> 00:23:44,340
then you configure all the other nonsense with it,

00:23:44,340 --> 00:23:46,520
but you say, hey I also need

00:23:47,500 --> 00:23:48,850
one core,

00:23:48,850 --> 00:23:50,880
and then you get it naturally

00:23:50,880 --> 00:23:52,230
for everything else

00:23:53,140 --> 00:23:55,030
which then just says,

00:23:55,030 --> 00:23:55,950
"I need one core."

00:23:58,600 --> 00:23:59,930
- So yeah, we need to--

00:23:59,930 --> 00:24:02,660
- [Man] Go away with PR CTLs now.

00:24:03,870 --> 00:24:07,980
- But yeah we need to bike shed on what specifics 'cause

00:24:07,980 --> 00:24:09,940
you might for example want to say

00:24:11,810 --> 00:24:14,030
core schedule this process,

00:24:14,030 --> 00:24:16,030
and core schedule this task

00:24:16,030 --> 00:24:17,870
so the request for

00:24:18,830 --> 00:24:22,277
core scheduling might be like some of the,

00:24:24,660 --> 00:24:26,630
the nice system core has something weird,

00:24:26,630 --> 00:24:28,550
there's a number of controls that

00:24:29,656 --> 00:24:31,160
iterate the task list and do weird stuff

00:24:31,160 --> 00:24:33,110
and are in inherited on fork,

00:24:33,110 --> 00:24:33,943
some are not.

00:24:35,360 --> 00:24:38,860
So we need to find a interface

00:24:38,860 --> 00:24:42,882
that works for all the glorious use cases.

00:24:42,882 --> 00:24:45,790
- [Man] So the other 3P?

00:24:45,790 --> 00:24:48,630
- Davao wants a cube or John.

00:24:48,630 --> 00:24:52,300
- I think when you just do the multiply the request

00:24:52,300 --> 00:24:53,530
time with the number of cores,

00:24:53,530 --> 00:24:54,590
you can connect and run

00:24:54,590 --> 00:24:56,620
into fragmentation problems.

00:24:56,620 --> 00:24:59,640
Like one process requesting a

00:24:59,640 --> 00:25:00,970
full core for 50%

00:25:00,970 --> 00:25:03,140
and another process requesting

00:25:03,140 --> 00:25:04,870
a single CPU for 50%.

00:25:08,900 --> 00:25:11,630
- So currently we do global admission control,

00:25:13,630 --> 00:25:14,950
and we do global EDF,

00:25:15,810 --> 00:25:18,610
and then it will magically work.

00:25:19,788 --> 00:25:22,038
(laughter)

00:25:23,230 --> 00:25:26,090
In as far as that global EDF works.

00:25:28,850 --> 00:25:31,720
Yeah so it provides a weak guarantee.

00:25:31,720 --> 00:25:33,940
It does it provides bounded tardiness.

00:25:38,835 --> 00:25:41,903
So we do want to support affinities first get deadlines

00:25:42,900 --> 00:25:44,890
and then it becomes really interesting

00:25:44,890 --> 00:25:47,110
and then your point is absolutely valid.

00:25:48,730 --> 00:25:50,840
- But can't we consider

00:25:50,840 --> 00:25:54,390
the usage of the sibling core

00:25:54,390 --> 00:25:56,290
as some optimistic utilization

00:25:56,290 --> 00:25:57,700
of that core-like group?

00:25:58,590 --> 00:26:01,060
And not counting maybe we can

00:26:01,060 --> 00:26:02,860
divide by the number of the cores,

00:26:02,860 --> 00:26:04,380
the admission control,

00:26:04,380 --> 00:26:07,170
and then let the other sibling deadline tasks

00:26:07,170 --> 00:26:08,890
to run not accounting the runtime

00:26:09,750 --> 00:26:11,440
or using to trying to,

00:26:13,370 --> 00:26:14,530
we could travel to it,

00:26:14,530 --> 00:26:19,430
but we could use like a greedy approach for it.

00:26:19,430 --> 00:26:22,170
- So for admission control we do not account runtime.

00:26:23,120 --> 00:26:26,550
We only used the worst case.

00:26:26,550 --> 00:26:28,490
- Yeah but while running,

00:26:28,490 --> 00:26:31,390
as we are using a research that wasn't

00:26:31,390 --> 00:26:32,820
actually accounted

00:26:32,820 --> 00:26:35,270
in that admission control

00:26:35,270 --> 00:26:37,160
we don't necessarily need to reduce

00:26:37,160 --> 00:26:38,710
the amount of execution time of

00:26:38,710 --> 00:26:40,160
the task in runner.

00:26:40,160 --> 00:26:44,170
- [Man] You mean let the tasks run for say more run time

00:26:44,170 --> 00:26:46,960
just because it was kind of consuming the--

00:26:46,960 --> 00:26:49,840
- Disparate run time, yeah. - Runtime on the other CPUs?

00:26:53,230 --> 00:26:55,120
- That's another way to try to see the problem.

00:26:55,120 --> 00:26:56,550
- I think that the other tricky

00:26:56,550 --> 00:26:58,570
bit would be actually load balancing

00:26:58,570 --> 00:27:01,490
because if you have a mix of tasks that

00:27:01,490 --> 00:27:04,970
can take full cores and others that can

00:27:04,970 --> 00:27:06,400
run basically everywhere else

00:27:06,400 --> 00:27:08,500
possibly we'll actually,

00:27:08,500 --> 00:27:09,380
so currently we don't

00:27:09,380 --> 00:27:11,910
distinguish and actually currently we

00:27:11,910 --> 00:27:13,900
don't consider the let's say

00:27:13,900 --> 00:27:16,890
spare bandwidth in the CPUs while deciding

00:27:16,890 --> 00:27:19,320
where to put a task, we only consider deadlines,

00:27:19,320 --> 00:27:23,045
so that's the other thing that we'll have to fix right?

00:27:23,045 --> 00:27:25,212
(mumbles)

00:27:26,990 --> 00:27:30,130
I think in this respect look us past the

00:27:30,130 --> 00:27:33,700
capacity awareness patches since they start considering the

00:27:34,760 --> 00:27:38,430
remaining capacity or bandwidth on the CPUs,

00:27:38,430 --> 00:27:39,750
maybe that might help

00:27:39,750 --> 00:27:43,530
because then you'll have a notion of

00:27:43,530 --> 00:27:46,100
where the bandwidth is actually allocated.

00:27:49,196 --> 00:27:51,360
And then you can say okay in the core there is the task

00:27:51,360 --> 00:27:54,100
that wants bandwidth for all the cores

00:27:54,100 --> 00:27:56,560
so I won't schedule anything there because I already know

00:27:56,560 --> 00:27:59,150
it's full but then I can use the other

00:27:59,150 --> 00:28:01,150
cores that are basically free, but yeah.

00:28:02,160 --> 00:28:03,260
- Yeah and then we do.

00:28:04,900 --> 00:28:06,790
- We learned it last time, but just to recall it,

00:28:06,790 --> 00:28:07,860
it's not only deadline,

00:28:07,860 --> 00:28:08,800
the problem,

00:28:08,800 --> 00:28:10,250
we also have the RT Real-Time

00:28:10,250 --> 00:28:13,510
sharing stuff in the FIFO scheduler.

00:28:15,327 --> 00:28:17,170
- I mean for we already killed that for real time,

00:28:17,170 --> 00:28:18,780
and I thought I killed it from mainline,

00:28:18,780 --> 00:28:20,090
but apparently I didn't,

00:28:20,090 --> 00:28:21,440
so let's just disable that.

00:28:22,440 --> 00:28:23,273
- Okay.

00:28:24,680 --> 00:28:28,870
The RT real time share option that you--

00:28:28,870 --> 00:28:33,870
- That was a gross hack when I did it, and it still is.

00:28:33,883 --> 00:28:35,739
(stammers)

00:28:35,739 --> 00:28:37,110
- No, that's for trouble, so--

00:28:37,110 --> 00:28:38,740
- Yeah, yeah, we'll also kill that

00:28:38,740 --> 00:28:40,773
eventually when we do the server thing.

00:28:45,280 --> 00:28:47,430
Yeah you gather back in a different flavor.

00:28:51,860 --> 00:28:53,930
- Okay unfortunately we're done.

00:29:02,280 --> 00:29:05,860
- Well I really don't want to have

00:29:05,860 --> 00:29:07,640
to go outside of cores, I mean

00:29:09,520 --> 00:29:11,110
it is expensive,

00:29:11,110 --> 00:29:14,150
and doing it within a core is relatively cheap

00:29:14,150 --> 00:29:16,170
because it shares the L1

00:29:16,170 --> 00:29:19,080
and it shares the instruction pipelines and all that.

00:29:20,690 --> 00:29:22,120
But if you cross that

00:29:22,120 --> 00:29:24,230
it just gets horribly more expensive,

00:29:26,100 --> 00:29:28,730
so it's fundamentally not that much harder

00:29:31,360 --> 00:29:32,220
but oh my god!

00:29:33,402 --> 00:29:35,652
(laughter)

00:30:06,917 --> 00:30:08,934
- This is kind of embarrassing,

00:30:08,934 --> 00:30:10,555
because I'm one of the organizers.

00:30:10,555 --> 00:30:12,036
You can see my green lanyard,

00:30:12,036 --> 00:30:13,284
and I'm at a microconference,

00:30:13,284 --> 00:30:16,170
so I've got slides.

00:30:17,430 --> 00:30:19,680
On the other hand, there was an alternative,

00:30:19,680 --> 00:30:22,130
and I chose not to take the alternative.

00:30:22,130 --> 00:30:23,280
I'll run the alternative by you,

00:30:23,280 --> 00:30:25,300
and you can let me know if I made a mistake.

00:30:25,300 --> 00:30:26,133
The alternative was

00:30:26,133 --> 00:30:27,890
all of you study Linux kernel RCU.

00:30:28,892 --> 00:30:30,140
You get up to speed on it.

00:30:30,140 --> 00:30:31,200
So that I didn't have to kind of

00:30:31,200 --> 00:30:33,260
provide a little background.

00:30:33,260 --> 00:30:34,760
So for as advice for next time,

00:30:34,760 --> 00:30:35,640
how many people would like me

00:30:35,640 --> 00:30:36,590
to not have slides?

00:30:37,831 --> 00:30:39,565
(laughter)

00:30:39,565 --> 00:30:40,398
All right, yeah!

00:30:51,980 --> 00:30:52,980
But it was more fun this way,

00:30:52,980 --> 00:30:54,060
but sure how many people would

00:30:54,060 --> 00:30:56,120
rather me have slides next time?

00:30:56,120 --> 00:30:57,460
Oh, okay.

00:30:57,460 --> 00:30:59,601
Sorry Thomas you're outvoted.

00:30:59,601 --> 00:31:01,330
(laughs)

00:31:01,330 --> 00:31:02,530
Okay let's see here.

00:31:02,530 --> 00:31:03,550
Let's try that.

00:31:03,550 --> 00:31:04,900
Oh look something's working,

00:31:04,900 --> 00:31:06,460
must be some mistake.

00:31:06,460 --> 00:31:08,130
Okay so I'm gonna go,

00:31:08,130 --> 00:31:09,350
these are the topics I have,

00:31:09,350 --> 00:31:10,960
we'll go through what we go through.

00:31:10,960 --> 00:31:12,210
As usual yell something out

00:31:12,210 --> 00:31:13,110
if you see something.

00:31:13,110 --> 00:31:14,830
I'm gonna go through some background

00:31:14,830 --> 00:31:15,680
and ask advice.

00:31:15,680 --> 00:31:17,170
That's kind of the way this works,

00:31:17,170 --> 00:31:18,840
that's what I'm trying to do here.

00:31:18,840 --> 00:31:19,673
So I'm

00:31:20,600 --> 00:31:21,960
being, I'm

00:31:23,670 --> 00:31:25,050
denying my citizenship

00:31:25,050 --> 00:31:26,900
by trying to make an informed choice.

00:31:28,700 --> 00:31:30,600
(laughter)

00:31:30,600 --> 00:31:31,590
Okay anyway,

00:31:33,088 --> 00:31:34,290
what we have is we have

00:31:35,473 --> 00:31:37,330
the default setup for callbacks

00:31:37,330 --> 00:31:39,520
is set up to be kind of self-throttling,

00:31:39,520 --> 00:31:42,090
and there's a caveat here

00:31:42,090 --> 00:31:44,500
which is the fixes going into five four

00:31:44,500 --> 00:31:46,780
but generally the idea is

00:31:46,780 --> 00:31:49,870
if you have some CPU here that decides it wants to do a loop

00:31:49,870 --> 00:31:51,240
in current mainline doing

00:31:51,240 --> 00:31:55,810
access paron paron on a file with an ACL,

00:31:55,810 --> 00:31:57,130
which means that every pass through the loop,

00:31:57,130 --> 00:31:59,730
there's a RCU callback generated,

00:31:59,730 --> 00:32:01,170
and it can do this really quickly.

00:32:01,170 --> 00:32:02,400
Well over a million callbacks

00:32:02,400 --> 00:32:04,031
per second per CPU,

00:32:04,031 --> 00:32:05,631
and you do that on all the CPUs.

00:32:08,980 --> 00:32:13,190
Well just hold on it here a minute Thomas,

00:32:13,190 --> 00:32:14,600
and we'll see who gets to admit what.

00:32:14,600 --> 00:32:17,290
But anyway so what happens

00:32:17,290 --> 00:32:18,800
in mainline right now

00:32:18,800 --> 00:32:20,900
is if this CPU's doing it

00:32:20,900 --> 00:32:21,890
and the other ones aren't

00:32:21,890 --> 00:32:22,930
let's say CPU Zero

00:32:22,930 --> 00:32:24,130
they got some guy that wants to

00:32:24,130 --> 00:32:26,900
just hammer RCU so he does, right?

00:32:26,900 --> 00:32:29,740
What will happen is is that the RCU

00:32:29,740 --> 00:32:31,300
infrastructure with scheduled clock tick

00:32:31,300 --> 00:32:32,960
if we're not using over its full width

00:32:32,960 --> 00:32:34,300
soft IRQ with other things

00:32:34,300 --> 00:32:37,360
will make grace periods happen and eventually

00:32:37,360 --> 00:32:39,100
it'll do a software key and say hey we

00:32:39,100 --> 00:32:41,150
got to call bunch of callbacks to invoke,

00:32:42,040 --> 00:32:43,940
and that invocation by default

00:32:43,940 --> 00:32:45,590
with normal configuration if you aren't doing

00:32:45,590 --> 00:32:46,880
hot plug and blah blah blah

00:32:46,880 --> 00:32:50,190
whole bunch of caveats most of which hold in the

00:32:50,190 --> 00:32:52,690
common case the same cpu is going to

00:32:52,690 --> 00:32:54,440
invoke the callbacks that posted it

00:32:56,460 --> 00:32:58,910
While it's invoking callbacks it can't post more,

00:33:00,290 --> 00:33:02,020
and so the admission control,

00:33:02,020 --> 00:33:03,560
if I want to say you're right,

00:33:03,560 --> 00:33:04,853
which I wouldn't.

00:33:04,853 --> 00:33:06,480
(laughs)

00:33:06,480 --> 00:33:09,870
Sorry, the admission control happens during the invocation.

00:33:09,870 --> 00:33:12,470
While it's invoking, it can't post more callbacks.

00:33:12,470 --> 00:33:14,480
Peter throw him a box.

00:33:14,480 --> 00:33:15,480
Throw the man a box!

00:33:17,240 --> 00:33:19,040
Or a bike or something, yeah.

00:33:19,040 --> 00:33:22,890
- [Man] So your callback can actually do co-RCU again.

00:33:22,890 --> 00:33:23,954
- It could!

00:33:23,954 --> 00:33:24,787
- I've been there, done that.

00:33:24,787 --> 00:33:26,340
- Yeah, it's fun, you can do that.

00:33:26,340 --> 00:33:27,480
So if somebody,

00:33:27,480 --> 00:33:28,830
and that's that's an important thing for

00:33:28,830 --> 00:33:30,270
people to understand,

00:33:30,270 --> 00:33:32,240
and that's one of the caveats.

00:33:32,240 --> 00:33:34,630
If somebody makes a system call

00:33:34,630 --> 00:33:36,580
that under user control

00:33:36,580 --> 00:33:38,140
can create a callback

00:33:38,140 --> 00:33:40,060
and the callback creates another callback

00:33:40,060 --> 00:33:41,280
each time it invokes

00:33:41,280 --> 00:33:42,550
and they can invoke this over and over again

00:33:42,550 --> 00:33:44,270
and keep creating callbacks,

00:33:44,270 --> 00:33:45,370
please enact the patch form

00:33:45,370 --> 00:33:48,190
or at least send it to me or something, okay?

00:33:48,190 --> 00:33:50,660
So yeah the one of the caveats is

00:33:50,660 --> 00:33:52,370
that when you use the space as a

00:33:52,370 --> 00:33:53,620
callback it does a finite

00:33:53,620 --> 00:33:54,453
number of callbacks,

00:33:54,453 --> 00:33:55,990
preferably one,

00:33:55,990 --> 00:33:57,610
and then gets on with life.

00:33:57,610 --> 00:33:58,790
So yeah it's a good point.

00:33:58,790 --> 00:34:00,600
Please don't do that.

00:34:00,600 --> 00:34:02,310
And you can also make one they did

00:34:02,310 --> 00:34:04,570
two callbacks do a memory allocation do

00:34:04,570 --> 00:34:06,400
callbacks each of those two callbacks

00:34:06,400 --> 00:34:08,250
that would be a callback bomb I guess

00:34:09,590 --> 00:34:10,650
please don't do that either that's

00:34:10,650 --> 00:34:12,430
another one of the caveats anyway enough

00:34:12,430 --> 00:34:15,240
caveat there is another caveat which is

00:34:15,240 --> 00:34:19,313
being the, is the fix is on its way in.

00:34:21,880 --> 00:34:23,230
Well anyway this is just an explanation

00:34:23,230 --> 00:34:25,940
of what I did graphically he madly posts,

00:34:25,940 --> 00:34:28,870
posts callbacks but while he's invoking

00:34:28,870 --> 00:34:30,950
them he can't post them only when he's

00:34:30,950 --> 00:34:32,670
done invoking them can he start posting

00:34:32,670 --> 00:34:34,730
them again, so we have kind of an

00:34:34,730 --> 00:34:36,480
implied Mission Control this is mainline

00:34:36,480 --> 00:34:37,313
non RT

00:34:37,313 --> 00:34:38,146
but--

00:34:39,430 --> 00:34:40,263
- [Man] Steve.

00:34:43,758 --> 00:34:45,030
- My question was wait so he said you

00:34:45,030 --> 00:34:46,128
can't whether they tried to do RCU call back

00:34:46,128 --> 00:34:50,130
or something like that, what happens?

00:34:50,130 --> 00:34:51,480
- [Man] If the call back does a call back?

00:34:51,480 --> 00:34:52,313
- Yeah. - Oh it just

00:34:52,313 --> 00:34:54,510
does another call back and that's, go ahead.

00:34:54,510 --> 00:34:56,080
- No I'm saying what's the question it doesn't invoke we

00:34:56,080 --> 00:34:59,320
mean by the definition of it doesn't invoke anymore.

00:34:59,320 --> 00:35:00,960
- Oh okay so yeah let me I probably didn't

00:35:00,960 --> 00:35:02,780
say that very well so we got the CP

00:35:02,780 --> 00:35:04,840
madly posting callbacks doing call arson

00:35:04,840 --> 00:35:07,100
call our co car sitting tight loop at

00:35:07,100 --> 00:35:08,970
this point after a grace periods

00:35:08,970 --> 00:35:10,140
happened while it's doing this kind of

00:35:10,140 --> 00:35:12,130
behind the scenes at this point it says

00:35:12,130 --> 00:35:14,310
hey we got this five billion callbacks

00:35:14,310 --> 00:35:16,510
RCU invoke them for me and so

00:35:16,510 --> 00:35:18,720
it's in a loop if it wants it it'll kind

00:35:18,720 --> 00:35:20,570
of meter them out for a little bit and

00:35:20,570 --> 00:35:22,520
at some point they'll say okay fine I'm

00:35:22,520 --> 00:35:24,410
just gonna vote callbacks and forget

00:35:24,410 --> 00:35:26,140
everybody else right so I got five

00:35:26,140 --> 00:35:28,510
million of them and at that point it's

00:35:28,510 --> 00:35:30,700
invoking callbacks as long as those

00:35:30,700 --> 00:35:32,670
callbacks to Peter's point don't contain

00:35:32,670 --> 00:35:33,800
caller RC themselves

00:35:35,010 --> 00:35:36,820
and please do that

00:35:36,820 --> 00:35:39,110
yeah okay please keep that true for user

00:35:39,110 --> 00:35:42,770
space hosted callbacks please then the

00:35:42,770 --> 00:35:44,320
user spaces and running.

00:35:44,320 --> 00:35:46,040
- Okay so basically you're saying it just goes

00:35:46,040 --> 00:35:46,940
through and just--

00:35:46,940 --> 00:35:48,400
- Yeah eventually I mean

00:35:48,400 --> 00:35:49,847
it tries to be nice for a while says no

00:35:49,847 --> 00:35:52,440
more mr. nice guy I'm getting this done, right?

00:35:53,913 --> 00:35:56,780
Of course that does lead into the

00:35:56,780 --> 00:35:59,400
five the five four issue this of course

00:35:59,400 --> 00:36:01,770
has just terrible real-time properties

00:36:01,770 --> 00:36:03,220
because you you're grabbing a CPU by the

00:36:03,220 --> 00:36:06,260
throat in soft air queue in real time of

00:36:06,260 --> 00:36:07,590
course you could set up for pride a

00:36:07,590 --> 00:36:09,190
priority for soft air can make your

00:36:09,190 --> 00:36:10,250
critical stuff happen at a higher

00:36:10,250 --> 00:36:13,040
priority you could do that.

00:36:13,040 --> 00:36:15,620
- Could we try to prevent somebody from stupidly

00:36:15,620 --> 00:36:18,810
calling call RCU inside

00:36:18,810 --> 00:36:21,290
the what why we're invoking?

00:36:23,370 --> 00:36:27,210
State say sorry you can't do that.

00:36:27,210 --> 00:36:29,480
So how do I so

00:36:29,480 --> 00:36:31,190
it's something that's necessary for some

00:36:31,190 --> 00:36:32,940
it's a valid use case in some cases

00:36:34,280 --> 00:36:36,030
so an interesting question is can we

00:36:36,030 --> 00:36:39,440
somehow figure out or mark or do something that's a

00:36:39,440 --> 00:36:41,900
great question I don't I don't know an answer to make it

00:36:41,900 --> 00:36:43,960
happen but it would be valuable.

00:36:43,960 --> 00:36:46,320
If we had a if we had some way of saying

00:36:46,320 --> 00:36:48,070
knowing this callback was posted in the

00:36:48,070 --> 00:36:50,090
system call that can be done in

00:36:50,090 --> 00:36:52,350
high-rated be cool to be able to say no

00:36:52,350 --> 00:36:54,320
you don't get to do call RCU and

00:36:54,320 --> 00:36:55,810
I'm gonna error or something I don't

00:36:55,810 --> 00:36:56,650
know somebody drop a floor.

00:36:56,650 --> 00:36:58,400
- There are valid you said there's valid.

00:36:58,400 --> 00:37:00,530
- Yes there are valid. - You seem, you looked at at

00:37:00,530 --> 00:37:02,180
and said okay that's valid instead of saying can

00:37:02,180 --> 00:37:03,690
you do this something differently.

00:37:04,550 --> 00:37:09,260
- So it's kind of a, so one of the things that

00:37:09,260 --> 00:37:13,880
one of the use cases involves reference counting where you

00:37:13,880 --> 00:37:15,660
have somebody doing the last reference

00:37:15,660 --> 00:37:17,450
and there's some other stuff going on

00:37:17,450 --> 00:37:19,550
and you could use tie knot timers I

00:37:19,550 --> 00:37:22,740
suppose but if you do a call RCU

00:37:22,740 --> 00:37:23,720
you just do the call RCU,

00:37:23,720 --> 00:37:25,520
the callback and it checks some condition and says no

00:37:25,520 --> 00:37:27,210
I can't do this right now so do another

00:37:27,210 --> 00:37:28,043
call RCU.

00:37:28,043 --> 00:37:28,876
Just like timers repost

00:37:28,876 --> 00:37:30,307
themselves okay same class of use case.

00:37:30,307 --> 00:37:32,400
- If it's a soft RQ then what happens if inner

00:37:32,400 --> 00:37:34,080
comes in into the call RCU?

00:37:34,080 --> 00:37:36,190
- It gets posted and then sometime later a grace period

00:37:36,190 --> 00:37:38,800
happens and in the although if you've got five million

00:37:38,800 --> 00:37:41,470
of them it might actually get the grace period done and

00:37:41,470 --> 00:37:42,960
queue it before you get done with them.

00:37:42,960 --> 00:37:43,793
But yeah.

00:37:44,680 --> 00:37:46,410
- So are these cases

00:37:46,410 --> 00:37:48,790
somewhat countably limited?

00:37:49,850 --> 00:37:50,683
- Say again?

00:37:50,683 --> 00:37:51,850
- Are they accountably limited?

00:37:51,850 --> 00:37:53,100
As in you can count them.

00:37:56,060 --> 00:37:59,264
- Yeah I heard what you said I was just recovering.

00:37:59,264 --> 00:38:01,514
(laughter)

00:38:03,986 --> 00:38:04,819
I don't know I think it's a small percentage

00:38:06,980 --> 00:38:08,450
but there's a fair number of call RCU's

00:38:08,450 --> 00:38:10,790
in the kernel and I haven't tried

00:38:10,790 --> 00:38:11,623
counting them.

00:38:11,623 --> 00:38:12,456
- What I'm thinking about.

00:38:12,456 --> 00:38:13,370
- Please free to.

00:38:13,370 --> 00:38:14,750
- What I'm thinking

00:38:14,750 --> 00:38:16,112
about is you know just just slap a one

00:38:16,112 --> 00:38:19,920
on there if you call RCU

00:38:19,920 --> 00:38:24,590
and at that point in time if you have a case where hey this

00:38:24,590 --> 00:38:26,510
is actually valid you annotate that and

00:38:26,510 --> 00:38:28,098
don't trigger the born on.

00:38:28,098 --> 00:38:31,070
- Okay but yeah that's a good way to do it

00:38:31,070 --> 00:38:32,960
what I what I need to do is come up with

00:38:32,960 --> 00:38:34,950
a good way of somehow annotating it.

00:38:34,950 --> 00:38:37,030
So one thing is that anyway there's some

00:38:37,030 --> 00:38:39,750
ways of doing that I'm Clark's idea is a

00:38:39,750 --> 00:38:41,960
good one you you've got some good points

00:38:41,960 --> 00:38:43,650
let me take that offline.

00:38:43,650 --> 00:38:45,020
Because I've got some other questions I

00:38:45,020 --> 00:38:46,700
need to ask you guys.

00:38:46,700 --> 00:38:51,160
Okay anyway so the problem that had is that

00:38:51,160 --> 00:38:52,790
and I said this before if it had five

00:38:52,790 --> 00:38:54,240
million callbacks eventually say

00:38:54,240 --> 00:38:55,730
okay guys out of the pool I'm doing all

00:38:55,730 --> 00:38:57,400
five million at once and it's kind of

00:38:57,400 --> 00:38:58,630
overkill because you do a hundred

00:38:58,630 --> 00:39:02,030
thousand at once that's with an epsilon

00:39:02,030 --> 00:39:04,340
as efficient as just doing it continuously

00:39:04,340 --> 00:39:06,170
and that lets go to the cpu every

00:39:06,170 --> 00:39:08,660
few milliseconds unless k free is

00:39:08,660 --> 00:39:10,300
causing you trouble like it was with the

00:39:10,300 --> 00:39:13,430
ACL access thing I was seeing two

00:39:13,430 --> 00:39:14,770
millisecond average K frees.

00:39:14,770 --> 00:39:15,620
I don't know why.

00:39:16,550 --> 00:39:20,880
But anyway so what Erik's patch does

00:39:20,880 --> 00:39:22,240
is it takes a more graduated thing

00:39:22,240 --> 00:39:23,400
instead of just doing them in small

00:39:23,400 --> 00:39:24,440
chunks and then saying and then

00:39:24,440 --> 00:39:26,620
panicking all at once it kind of slowly

00:39:26,620 --> 00:39:30,070
increases the number it does and then

00:39:30,070 --> 00:39:32,530
eventually it gets up to limit says I'm

00:39:32,530 --> 00:39:34,330
going to look at this many at once and

00:39:34,330 --> 00:39:37,200
the limit is fairly large so anyway with

00:39:37,200 --> 00:39:39,650
that with main line with non real time

00:39:39,650 --> 00:39:41,600
this works nicely okay

00:39:43,520 --> 00:39:45,820
and but with offloading if you're doing real time

00:39:45,820 --> 00:39:48,000
you're offloading the callbacks the

00:39:48,000 --> 00:39:49,610
assumption when I wrote this up when was

00:39:49,610 --> 00:39:52,450
that 2012, 2010, I can't remember.

00:39:52,450 --> 00:39:54,880
Anyway the idea was is this

00:39:54,880 --> 00:39:56,540
a real time things are embedded and we

00:39:56,540 --> 00:39:59,140
have a tightly controlled software stack

00:39:59,140 --> 00:40:00,160
so people are

00:40:01,920 --> 00:40:04,310
you know limiting themselves and being disciplined about

00:40:04,310 --> 00:40:06,220
how they use the software and how they

00:40:06,220 --> 00:40:07,710
make how these system two calls and life

00:40:07,710 --> 00:40:08,543
should be good

00:40:10,060 --> 00:40:11,440
and that means that RCU

00:40:11,440 --> 00:40:12,990
can safely assume the saintly low

00:40:12,990 --> 00:40:15,060
rate of callback queuing in that

00:40:15,060 --> 00:40:20,060
configuration so RCU does rely on this

00:40:20,120 --> 00:40:22,860
assumption currently in mainline and

00:40:22,860 --> 00:40:24,430
what happens and this is a kind of a

00:40:24,430 --> 00:40:26,660
cartoony diagram we are CPU's

00:40:26,660 --> 00:40:28,870
again this think of these is the user

00:40:28,870 --> 00:40:31,050
space thing is running along and we have

00:40:31,050 --> 00:40:32,200
a set of kernel threads

00:40:33,730 --> 00:40:36,730
and these are grouped for four CPUs you'd actually it

00:40:36,730 --> 00:40:38,280
be more complicated but let's keep it

00:40:38,280 --> 00:40:41,820
simple you have one of the K threads so

00:40:41,820 --> 00:40:43,900
these the RCO and in current main

00:40:43,900 --> 00:40:45,950
lighted bp4 preemptable and normal

00:40:45,950 --> 00:40:48,840
real-time usage and cpu zero has one

00:40:48,840 --> 00:40:50,350
I've put it in two spaces it has two

00:40:50,350 --> 00:40:53,040
rules it takes on and CPU one and two

00:40:53,040 --> 00:40:54,750
and three all would be if they're all

00:40:54,750 --> 00:40:56,040
offloaded they would all have this

00:40:56,040 --> 00:40:57,040
kernel thread

00:40:57,040 --> 00:40:58,740
this kernel threads job is to invoke

00:40:58,740 --> 00:41:00,800
callbacks the roll down here is just

00:41:00,800 --> 00:41:04,020
invoking callbacks the role here and CPU

00:41:04,020 --> 00:41:06,540
zeros is gonna play that dual role is to

00:41:06,540 --> 00:41:08,360
wait for grace periods to get these guys

00:41:08,360 --> 00:41:10,860
set up you know collect the callbacks up

00:41:10,860 --> 00:41:12,070
wait for grace period when the grace

00:41:12,070 --> 00:41:14,350
period lapses hand the callbacks down to

00:41:14,350 --> 00:41:17,190
the kernel threads including itself and

00:41:17,190 --> 00:41:18,990
then wake them up and they go go at

00:41:18,990 --> 00:41:20,430
getting callbacks for as long it takes

00:41:20,430 --> 00:41:22,530
their use they're just a k thread so

00:41:22,530 --> 00:41:24,560
all this stuff about holding out of the

00:41:24,560 --> 00:41:26,270
CPU too long doesn't apply Peter will

00:41:26,270 --> 00:41:28,570
preempt me if he wants to and that's fine okay

00:41:30,970 --> 00:41:34,810
but and then the administrators job is to figure out

00:41:34,810 --> 00:41:37,830
where these things run okay and again this is tightly

00:41:37,830 --> 00:41:39,680
controlled the administrator if the administrator and messes

00:41:39,680 --> 00:41:41,910
up they're the ones that have to fix it

00:41:41,910 --> 00:41:44,120
and I've given them some rope and they

00:41:44,120 --> 00:41:45,970
can you know use it however they want

00:41:46,810 --> 00:41:48,540
I would I would advise they choose

00:41:48,540 --> 00:41:51,850
wisely but that's their choice at the

00:41:51,850 --> 00:41:55,360
end of the day okay and is with this

00:41:55,360 --> 00:41:57,520
assumption that is a control software

00:41:57,520 --> 00:42:00,720
stack and all this works nicely but

00:42:02,200 --> 00:42:04,860
with that assumption violated what can happen

00:42:04,860 --> 00:42:06,480
is that CPU 0 might just dump a whole

00:42:06,480 --> 00:42:08,050
pile of callbacks because my assumption

00:42:08,050 --> 00:42:09,350
is violated and the guy is just being an

00:42:09,350 --> 00:42:11,420
idiot or or has a really bizarre

00:42:11,420 --> 00:42:12,420
workload I haven't thought of or

00:42:12,420 --> 00:42:14,020
however you want to put it okay.

00:42:15,530 --> 00:42:17,830
And then so this guy says great grace period and

00:42:17,830 --> 00:42:19,070
then he hands the call backs off to

00:42:19,070 --> 00:42:21,250
himself and there's millions of them by

00:42:21,250 --> 00:42:23,750
this time and so he's stuck in a loop

00:42:23,750 --> 00:42:24,670
invoking callbacks

00:42:25,930 --> 00:42:28,790
meanwhile CPU one and two three decide hey it's my turn

00:42:28,790 --> 00:42:32,120
to stuff callbacks in there and they're being

00:42:32,120 --> 00:42:34,600
studiously ignored by cpu 0 who is stuck

00:42:34,600 --> 00:42:36,210
invoking callbacks and they just keep

00:42:36,210 --> 00:42:38,410
piling up and piling up and piling up

00:42:38,410 --> 00:42:41,230
eventually cpu zero gets done doing the

00:42:41,230 --> 00:42:42,650
current set of this callbacks this is

00:42:42,650 --> 00:42:44,820
okay it's time to go up and buy that but

00:42:44,820 --> 00:42:47,120
by that time it's game over you know

00:42:47,120 --> 00:42:49,670
before you run out of memory and life is hard okay.

00:42:52,610 --> 00:42:55,050
My observation over the past level second years is that

00:42:55,050 --> 00:42:58,146
my assumption might not be valid anymore

00:42:58,146 --> 00:43:02,130
and even if it is valid right now it won't be very long

00:43:02,130 --> 00:43:05,130
because people are people are using this nowhere is full

00:43:05,130 --> 00:43:08,700
uses HPC applications usually they've run just in user space

00:43:08,700 --> 00:43:13,510
but you know people are making less discipline use of this

00:43:13,510 --> 00:43:18,440
and it's gotten to the point where in my own self-defense

00:43:18,440 --> 00:43:21,740
I need RCU to defend itself or it can alright

00:43:23,350 --> 00:43:26,930
and so what that means is forget that assumption

00:43:27,980 --> 00:43:30,950
and that's one recent reason why I think I need to forget

00:43:30,950 --> 00:43:35,070
the assumption and what's not quite yet in

00:43:35,070 --> 00:43:37,900
mainline be getting there because I

00:43:37,900 --> 00:43:39,750
consolidated the RCUs I only have

00:43:39,750 --> 00:43:41,770
one of these things per CPU period I

00:43:41,770 --> 00:43:44,650
used to have three of them in an RQ kernel

00:43:44,650 --> 00:43:48,700
three per CPU so I've cut them down by a factor of three so

00:43:48,700 --> 00:43:51,040
you guys should be plenty happy with me

00:43:51,040 --> 00:43:53,250
adding a square root of N worth of them

00:43:53,250 --> 00:43:55,490
which I done okay you don't like it come

00:43:55,490 --> 00:43:58,000
talk to me and we'll have a discussion

00:43:58,000 --> 00:43:59,400
all right?

00:43:59,400 --> 00:44:02,140
So what happens is that CPU zero has two

00:44:02,140 --> 00:44:04,690
of these guys now okay and one of them

00:44:04,690 --> 00:44:07,150
just does grace periods that all he does

00:44:07,150 --> 00:44:08,610
and the other one just to devote callback

00:44:08,610 --> 00:44:09,910
so that's all he does.

00:44:13,160 --> 00:44:14,450
- [Man] And the GP one has a

00:44:14,450 --> 00:44:17,384
slightly higher priority than the

00:44:17,384 --> 00:44:19,300
other one.

00:44:19,300 --> 00:44:22,520
- That may be necessary it hasn't been yet in my testing

00:44:22,520 --> 00:44:26,040
so far I've it's worked fine with these guys doing

00:44:26,040 --> 00:44:26,873
whatever.

00:44:28,650 --> 00:44:30,150
- Yeah I would give it slightly

00:44:30,150 --> 00:44:32,320
higher priority so that it can still

00:44:32,320 --> 00:44:34,210
detect grace periods and still hand that

00:44:34,210 --> 00:44:36,060
work to the other threads even though

00:44:36,920 --> 00:44:39,250
your callback thread is busy processing

00:44:39,250 --> 00:44:41,150
to millions and millions and millions.

00:44:42,220 --> 00:44:44,780
- Okay so um that's an interesting point

00:44:44,780 --> 00:44:46,530
my model of the world was that this guy

00:44:46,530 --> 00:44:48,160
wouldn't be affinity as tightly as these

00:44:48,160 --> 00:44:49,480
guys were and so it would go wherever

00:44:49,480 --> 00:44:50,840
that was but you're right somebody might

00:44:50,840 --> 00:44:52,440
just slam them all on a CPU zero

00:44:53,300 --> 00:44:56,200
but that's we'll get to that in a later slide.

00:44:56,200 --> 00:44:57,033
Yeah.

00:44:58,580 --> 00:45:02,080
- I mean but you're saying by changing the the global

00:45:02,080 --> 00:45:04,110
the man basically I call it like the manager or

00:45:04,110 --> 00:45:05,680
whatever you want to call it or what you

00:45:05,680 --> 00:45:07,940
call the grace period Handler threatened

00:45:07,940 --> 00:45:09,360
you're saying that you could that's you

00:45:09,360 --> 00:45:10,700
could change the affinity of that guy as

00:45:10,700 --> 00:45:11,610
well or?

00:45:11,610 --> 00:45:13,340
- Well what I was I was assuming

00:45:13,340 --> 00:45:14,680
something I think Peter gave me some

00:45:14,680 --> 00:45:16,960
good input that I need to think about

00:45:16,960 --> 00:45:18,620
and and it's quite possible he's right.

00:45:18,620 --> 00:45:20,510
Okay which is which I hate to admit hey

00:45:20,510 --> 00:45:23,330
you know people it was so the input was

00:45:23,330 --> 00:45:24,163
that I need to take the

00:45:24,163 --> 00:45:26,040
prior to this guy slightly higher

00:45:26,040 --> 00:45:27,660
then these guys in case they're sharing

00:45:27,660 --> 00:45:29,320
a CPU so that I keep up with the grace

00:45:29,320 --> 00:45:30,930
periods even if one of these guys was

00:45:30,930 --> 00:45:32,750
tearing away at the CPU.

00:45:32,750 --> 00:45:34,750
Because what Peters telling me is he has enough

00:45:34,750 --> 00:45:37,100
information to know which one's more important.

00:45:38,602 --> 00:45:39,800
- But I would also say we might

00:45:39,800 --> 00:45:42,250
assume that the grace period the GP zero guy

00:45:42,250 --> 00:45:44,030
or they would be pinned to the CPU is no

00:45:44,030 --> 00:45:45,310
reason that the man

00:45:45,310 --> 00:45:47,250
- [Man] That's up to the administrator.

00:45:49,470 --> 00:45:52,110
- Why would you want to because it's like if you have

00:45:52,110 --> 00:45:55,100
CP zero do it handling that you just pass it off to

00:45:55,100 --> 00:45:57,920
that thread may not worry about it so it's--

00:45:57,920 --> 00:46:01,440
- That was my mental model you've got my mental model

00:46:01,440 --> 00:46:03,630
which is that there's so--

00:46:03,630 --> 00:46:06,230
- The CPU zero I'm saying should be per CPU threads they're

00:46:06,230 --> 00:46:08,740
just binded to the CPU the other ones could be moved around

00:46:08,740 --> 00:46:11,090
it because that's where you that's the offloading but the

00:46:11,090 --> 00:46:12,180
managing should just because you're

00:46:12,180 --> 00:46:14,560
going to say okay this CPU zeros my mate

00:46:14,560 --> 00:46:16,020
is what I'm going manage is what manage

00:46:16,020 --> 00:46:19,640
my callbacks I call the GPU zero thread

00:46:19,640 --> 00:46:22,240
knowing that it will be on CPU zero.

00:46:22,240 --> 00:46:23,990
- Except that some people might want to

00:46:23,990 --> 00:46:26,110
put might want to have a set of

00:46:26,110 --> 00:46:29,150
housekeeping CPUs and put all of these

00:46:29,150 --> 00:46:31,180
threads on those housekeeping CPUs

00:46:31,180 --> 00:46:33,630
because they don't want any reference or--

00:46:33,630 --> 00:46:37,030
- The GPU the GP the GP ones I can see not

00:46:37,030 --> 00:46:39,190
just would be I will just be a thread

00:46:39,190 --> 00:46:41,470
that's to sidle you know I mean it's the

00:46:41,470 --> 00:46:42,910
manager it's going to be doing managing

00:46:42,910 --> 00:46:45,654
don't need to of that two of those on one CPU.

00:46:45,654 --> 00:46:49,503
You just need one of them on one CPU.

00:46:49,503 --> 00:46:52,645
Oh you only have one in the system?

00:46:52,645 --> 00:46:53,640
(laughter)

00:46:53,640 --> 00:46:55,710
- All right, he's got aim.

00:46:57,552 --> 00:46:58,618
(laughter)

00:46:58,618 --> 00:46:59,451
- [Man] Who was that?

00:46:59,451 --> 00:47:00,401
(laughter)

00:47:00,401 --> 00:47:02,567
- Who do you think?

00:47:02,567 --> 00:47:04,486
I couldn't hear you.

00:47:04,486 --> 00:47:07,010
(laughter)

00:47:07,010 --> 00:47:09,220
- [Man] So what there is is there's square N of these

00:47:09,220 --> 00:47:12,320
where N is the number of CPUs and the reason they're square

00:47:12,320 --> 00:47:16,030
at n is because if I if I only have one of

00:47:16,030 --> 00:47:19,110
them then the wake up delays start

00:47:19,110 --> 00:47:21,680
killing me if I have if I have hundreds

00:47:21,680 --> 00:47:23,690
of CPUs which is not an uncommon case

00:47:23,690 --> 00:47:26,800
these days then this guy ends up having

00:47:26,800 --> 00:47:28,370
to wake the whole the whole pile of

00:47:28,370 --> 00:47:29,630
people up and then while he's doing that

00:47:29,630 --> 00:47:32,120
he's not checking for the rest of stuff

00:47:32,120 --> 00:47:34,410
now that may be a wrong optimization and

00:47:34,410 --> 00:47:35,660
that that's a good point I need to look

00:47:35,660 --> 00:47:37,220
at that hopefully you're getting these

00:47:37,220 --> 00:47:38,053
in notes

00:47:38,053 --> 00:47:40,340
because I'm not gonna remember them all.

00:47:40,340 --> 00:47:41,870
- [Man] I wasn't talking, I'm hoping someone else

00:47:41,870 --> 00:47:42,703
does the writing.

00:47:42,703 --> 00:47:44,350
- Okay well that's a good point so we also do

00:47:44,350 --> 00:47:46,130
the writing or whatever but so that's

00:47:46,130 --> 00:47:49,110
the but that's that's a good point right

00:47:49,110 --> 00:47:52,020
now my assumption is that I need I can't

00:47:52,020 --> 00:47:53,230
just have one of them on a really big

00:47:53,230 --> 00:47:57,100
system just because I'm the fan out on

00:47:57,100 --> 00:47:59,130
the wake ups would would start killing me.

00:47:59,130 --> 00:48:01,370
- My question was why not just have

00:48:01,370 --> 00:48:04,080
one per CPU and just having pinned and

00:48:04,080 --> 00:48:05,600
only have a mute like they'd just be

00:48:05,600 --> 00:48:07,350
idle or they do nothing basically

00:48:08,740 --> 00:48:09,780
if they're not being used.

00:48:09,780 --> 00:48:11,640
They just that was my question.

00:48:11,640 --> 00:48:12,473
- The thing is

00:48:13,490 --> 00:48:16,520
what do you want to--

00:48:19,890 --> 00:48:22,330
should be able to move or see you call

00:48:22,330 --> 00:48:24,440
back processing completely away from--

00:48:24,440 --> 00:48:26,790
- Right but like here if you have this

00:48:26,790 --> 00:48:28,440
basically my point what I'm trying to

00:48:28,440 --> 00:48:30,240
say is okay if GP zero they're that they're

00:48:30,240 --> 00:48:32,000
going CPU one's going to talk directly

00:48:32,000 --> 00:48:35,230
to GP zero knowing that it's on CPU zero and

00:48:35,230 --> 00:48:36,980
but the thing is you could have a thread

00:48:36,980 --> 00:48:39,360
where you have one of those for each but

00:48:39,360 --> 00:48:42,400
only if you're saying that this is going

00:48:42,400 --> 00:48:43,910
to be the housekeeping one so they're

00:48:43,910 --> 00:48:45,590
just otherwise the ones that are not

00:48:45,590 --> 00:48:46,770
they're being offloaded they're just

00:48:46,770 --> 00:48:48,720
gonna be I mean unless you do a kernel.

00:48:52,150 --> 00:48:53,900
- Let me let me let me clarify something

00:48:53,900 --> 00:48:55,450
let's say that I've got a system that

00:48:55,450 --> 00:48:57,100
where I'm where I've got a big workload

00:48:57,100 --> 00:48:59,460
in is half off load in half not and it's

00:48:59,460 --> 00:49:02,610
like 100 CPUs so 50/50 right what's gonna

00:49:02,610 --> 00:49:04,480
happen is that for the non offloaded ones

00:49:04,480 --> 00:49:05,860
the ones that are running soft irq there

00:49:05,860 --> 00:49:07,900
aren't going to be no GP k threads it

00:49:07,900 --> 00:49:10,457
only makes them if at least one of the

00:49:10,457 --> 00:49:12,830
CPUs in its domain and it's square root

00:49:13,788 --> 00:49:15,910
of n number of CPUs is offloaded.

00:49:19,100 --> 00:49:20,670
- GP zero is only made when--

00:49:21,710 --> 00:49:24,300
- [Man] The well forget the zero, the GP.

00:49:24,300 --> 00:49:29,300
- When there's actually some CPU which is that optimal like

00:49:31,480 --> 00:49:32,680
- [Man] Within its domain.

00:49:32,680 --> 00:49:34,660
- Well then you could just create I mean

00:49:34,660 --> 00:49:36,180
but my point when saying is you just

00:49:36,180 --> 00:49:38,850
create that guy for it to CPU that's

00:49:38,850 --> 00:49:40,517
going that's gonna be that's going to

00:49:40,517 --> 00:49:43,020
clean it up.

00:49:43,020 --> 00:49:45,420
- [Man] Then people leave to things people yell at me for

00:49:45,420 --> 00:49:47,210
having lots of K for its again.

00:49:49,640 --> 00:49:51,840
- Well so you're basically saying--

00:49:51,840 --> 00:49:55,250
- [Man] And the other thing is that if they all are active

00:49:55,250 --> 00:49:58,010
then I start then I have that big wake up delay on

00:49:58,010 --> 00:50:00,870
large systems in the grace period K thread

00:50:00,870 --> 00:50:02,610
'cause the grace period ends I got to wake them all up and

00:50:02,610 --> 00:50:05,050
that's what got me in trouble back in 2010.

00:50:05,050 --> 00:50:07,100
- So let me just go back so basically what you're saying

00:50:07,100 --> 00:50:09,770
let's do a little more complex example because it's modeling

00:50:09,770 --> 00:50:11,624
why I'm getting confused because it's kind of too much of a

00:50:11,624 --> 00:50:12,457
simple.

00:50:12,457 --> 00:50:13,670
(laughs)

00:50:13,670 --> 00:50:17,780
is like so let's say if we have 100 CPUs and if

00:50:17,780 --> 00:50:22,080
50 of them are offloaded in 50 of them are going

00:50:22,080 --> 00:50:25,140
to do the work for it so how many

00:50:26,390 --> 00:50:28,500
of these GP threads would you create then?

00:50:28,500 --> 00:50:30,940
- [Man] 50 or five excuse me five but it

00:50:30,940 --> 00:50:34,010
would be it would be 10 if they were all offloaded but only

00:50:34,010 --> 00:50:36,280
half of them assuming that the ones that are

00:50:36,280 --> 00:50:38,200
offloaded are dense in the cpu number space.

00:50:38,200 --> 00:50:40,500
- And five and these five would then just be--

00:50:44,913 --> 00:50:47,330
- [Man] The square root of 100 is 10

00:50:47,330 --> 00:50:51,040
and 50 that so there's 100 CPUs the squared

00:50:51,040 --> 00:50:54,910
of 100 is 10 but only 50 of them have are

00:50:54,910 --> 00:50:56,880
being offloaded and they're dense and

00:50:56,880 --> 00:50:59,400
therefore five of those ten are created.

00:51:00,470 --> 00:51:02,740
That would be a valid choice it's just that I didn't make

00:51:02,740 --> 00:51:03,573
that choice.

00:51:03,573 --> 00:51:04,890
- Oh I see so you just look at how many

00:51:04,890 --> 00:51:06,400
available CPUs there are and then you

00:51:06,400 --> 00:51:08,800
say my max is oh total CPUs and square

00:51:08,800 --> 00:51:11,500
root of total CPUs that's the max limit.

00:51:11,500 --> 00:51:12,333
- [Man] Yes.

00:51:13,872 --> 00:51:16,090
- Someone probably should add that in the notes.

00:51:16,090 --> 00:51:19,600
Anyway so basically you make 10 and then you only use

00:51:19,600 --> 00:51:21,790
half because there's only half and then you do a percentage

00:51:21,790 --> 00:51:23,860
I guess we're doing a percentage of how many are doing it

00:51:23,860 --> 00:51:25,930
so you have five I guess the affinities are these--

00:51:25,930 --> 00:51:29,320
- [Man] Well it depends how you did it if you I'm assuming

00:51:29,320 --> 00:51:32,430
that say zero through 49 are not offloaded

00:51:32,430 --> 00:51:34,880
and 50 through 99 are in which case

00:51:34,880 --> 00:51:36,210
that's what it would happen if you

00:51:36,210 --> 00:51:39,280
offloaded every other one then you'd get

00:51:39,280 --> 00:51:41,710
the full set of 10 because each of the chunks

00:51:41,710 --> 00:51:45,020
would have a have at least one offloaded CPU.

00:51:56,135 --> 00:51:59,080
- A compass example of a simple topology where it's a single

00:51:59,080 --> 00:52:01,943
flat there's no numa 100 CPUs.

00:52:01,943 --> 00:52:04,193
(laughter)

00:52:07,880 --> 00:52:12,790
Okay my point is so they basically these five, seven or

00:52:12,790 --> 00:52:16,150
whatever are now the affinity of them is

00:52:16,150 --> 00:52:17,800
for all the 50 that--

00:52:17,800 --> 00:52:19,530
- [Man] That's the administrator's choice that's not my

00:52:19,530 --> 00:52:20,363
choice.

00:52:20,363 --> 00:52:21,200
- So what do you put what's know

00:52:21,200 --> 00:52:22,610
what but if you just turned it on and

00:52:22,610 --> 00:52:24,670
they didn't do anything what's a default?

00:52:24,670 --> 00:52:26,870
- [Man] Not affinity at all they just they're just--

00:52:26,870 --> 00:52:29,550
- So they can actually run on the CPUs that actually want to

00:52:29,550 --> 00:52:30,960
call or want the offloading.

00:52:30,960 --> 00:52:33,100
- [Man] They might or they might run wherever that's Peter's

00:52:33,100 --> 00:52:34,733
job not mine.

00:52:34,733 --> 00:52:36,816
(laughs)

00:52:38,880 --> 00:52:41,200
I'm assuming that if people are using this

00:52:41,200 --> 00:52:43,150
they would control what we got the box.

00:52:46,332 --> 00:52:47,700
Give him the box, give the man the box.

00:52:47,700 --> 00:52:49,060
- I was just trying to get back to the

00:52:49,060 --> 00:52:52,200
housekeeping question so we're so if

00:52:52,200 --> 00:52:53,960
I limit like if I have a four core system

00:52:53,960 --> 00:52:55,300
and I designate one core for

00:52:55,300 --> 00:52:58,900
housekeeping I only want to--

00:52:58,900 --> 00:53:01,530
- [Man] Hold that thought we're gonna have a slide with that

00:53:01,530 --> 00:53:04,350
in a little bit thank you though thank you for getting a

00:53:04,350 --> 00:53:05,470
leading question because we need to move

00:53:05,470 --> 00:53:06,506
ahead 'cause we're almost out of time.

00:53:06,506 --> 00:53:11,480
Okay I'm not gonna go through this in detail but

00:53:11,480 --> 00:53:14,150
this is some extra stuff and after doing that I got a two or

00:53:14,150 --> 00:53:16,910
three X reduction in the RCU test case and the number of

00:53:16,910 --> 00:53:19,760
callbacks it was outstanding so this did help is all that

00:53:19,760 --> 00:53:22,830
really means of course nothing is ever perfect this is

00:53:22,830 --> 00:53:25,390
something you might do and in fact it's your example, right?

00:53:25,390 --> 00:53:28,710
All right good I managed to anticipate one question.

00:53:28,710 --> 00:53:30,300
(laughs)

00:53:30,300 --> 00:53:32,200
Okay so this is something you really want to do or some

00:53:32,200 --> 00:53:35,220
people really want to do except that if

00:53:35,220 --> 00:53:37,250
we have this this thing where people are

00:53:37,250 --> 00:53:39,830
doing ugly things CPUs one two three can

00:53:39,830 --> 00:53:42,370
just easily bury CPU zero I mean CPU

00:53:42,370 --> 00:53:44,880
zero just does not have a chance they're

00:53:44,880 --> 00:53:46,270
fairly evenly matched when it comes to

00:53:46,270 --> 00:53:50,920
posting callbacks and doing a K free so you know

00:53:50,920 --> 00:53:55,760
this is a flaming disaster all right?

00:53:55,760 --> 00:53:57,010
- [Man] Why is there four

00:53:58,376 --> 00:54:01,350
RCUOPX threads on

00:54:01,350 --> 00:54:02,740
why wouldn't there just be one?

00:54:02,740 --> 00:54:07,150
- [Man] Because that I have to V then I'd have to

00:54:07,150 --> 00:54:08,950
respond to somebody doing a sketch that

00:54:08,950 --> 00:54:11,980
affinity and rewiring my internals

00:54:11,980 --> 00:54:14,190
to make only one K thread get it and

00:54:14,190 --> 00:54:15,440
then they do another skill affinity to

00:54:15,440 --> 00:54:16,920
have to rewire I so again I'm not doing

00:54:16,920 --> 00:54:17,753
that I'm sorry.

00:54:17,753 --> 00:54:21,160
- And also what would be the point of having the the GP in

00:54:21,160 --> 00:54:25,980
that case anyway because there's only one place to send it

00:54:25,980 --> 00:54:28,770
right it doesn't matter right?

00:54:28,770 --> 00:54:31,610
- Look you have to tell me why it hurts to have this.

00:54:31,610 --> 00:54:33,610
Is there a significant loss no there isn't.

00:54:33,610 --> 00:54:35,230
- Yeah, okay. - Okay, you're right

00:54:35,230 --> 00:54:38,480
it is kind of pointless but I have to if I don't if

00:54:38,480 --> 00:54:41,480
I do what you're doing, Peter and I have to have a lot of

00:54:41,480 --> 00:54:44,290
back and forth every time this somebody does a sketch set

00:54:44,290 --> 00:54:47,160
affinity and that's gonna be complicated.

00:54:48,060 --> 00:54:51,863
- If you march them, there is no point to get 'em--

00:54:56,140 --> 00:54:59,300
- [Man] Taking apart would be really hard.

00:54:59,300 --> 00:55:01,300
- Because then there is only the one PID

00:55:02,330 --> 00:55:04,740
so who do you tell to move somewhere else?

00:55:06,690 --> 00:55:09,670
- Yeah thank you, that's a better answer.

00:55:09,670 --> 00:55:11,170
- [Man] This scenario is useful for the

00:55:11,170 --> 00:55:13,320
case that this is not always where

00:55:13,320 --> 00:55:14,660
you're going to carve it you may move them

00:55:14,660 --> 00:55:16,390
around elsewhere is what you're saying.

00:55:16,390 --> 00:55:17,570
- Yeah.

00:55:17,570 --> 00:55:20,943
Okay and of course

00:55:20,943 --> 00:55:23,010
what do we do about this and I'm gonna not,

00:55:23,010 --> 00:55:24,730
I was going to pull the audience but we're,

00:55:24,730 --> 00:55:26,830
we're just doing this one thing and that's it.

00:55:26,830 --> 00:55:28,840
Currently we do is number one.

00:55:28,840 --> 00:55:30,210
Let it be, let it OM.

00:55:32,210 --> 00:55:33,130
Okay which is,

00:55:34,900 --> 00:55:37,700
how many people think think that's the optimal approach?

00:55:37,700 --> 00:55:39,013
All right, yeah.

00:55:39,013 --> 00:55:41,096
(laughs)

00:55:42,400 --> 00:55:45,220
And Linus Turtles agrees with you so

00:55:45,220 --> 00:55:48,440
there's some indications the two might be favored.

00:55:48,440 --> 00:55:52,290
Yeah I think I know a way to do that but it's

00:55:52,290 --> 00:55:54,310
hard to make it splat when you want

00:55:54,310 --> 00:55:56,140
it to when it's the problem and not

00:55:56,140 --> 00:55:58,990
splat when this just life is just hard, right?

00:56:00,870 --> 00:56:03,380
To Thomas's point the admission control I could detect an

00:56:03,380 --> 00:56:06,750
overload and tell call RCU, you know do a

00:56:06,750 --> 00:56:08,450
I can't make it sleep and I could check

00:56:08,450 --> 00:56:09,930
to see whether there's legal asleep and

00:56:09,930 --> 00:56:12,030
and just sleep you know

00:56:13,170 --> 00:56:17,750
or I could just do a spin delay right and you delay, right?

00:56:17,750 --> 00:56:19,450
And I could check one way or the

00:56:19,450 --> 00:56:21,120
other I mean that's something I could do.

00:56:22,170 --> 00:56:24,080
Go ahead Thomas, give him a box,

00:56:24,080 --> 00:56:26,509
he has a loud voice but it's not that loud.

00:56:26,509 --> 00:56:29,940
- The problem is with delaying it

00:56:29,940 --> 00:56:32,960
I mean moving the problem to a different

00:56:32,960 --> 00:56:34,630
place you go anyway.

00:56:35,930 --> 00:56:40,200
- Well what yeah the the hope is that the

00:56:40,200 --> 00:56:41,830
guy that does the call RCU is also the

00:56:41,830 --> 00:56:43,200
guys to the key Malik but you're right

00:56:43,200 --> 00:56:46,700
that might not be the case and you yeah.

00:56:48,554 --> 00:56:50,160
- [Man] I think having a go home and something like that

00:56:50,160 --> 00:56:52,780
it's really useful for just tuning right I mean you just

00:56:52,780 --> 00:56:54,370
have an idea if I'll maybe one

00:56:54,370 --> 00:56:57,040
housekeeping core's not the right thing, you know.

00:56:57,040 --> 00:56:58,780
- Although if we can do this we

00:56:58,780 --> 00:57:01,050
can we can give you a little better do

00:57:01,050 --> 00:57:03,050
that the other the other thing is the

00:57:03,050 --> 00:57:05,570
thing that I actually is my favor from a

00:57:05,570 --> 00:57:08,780
theoretical standpoint I think I might

00:57:08,780 --> 00:57:13,670
be able to do it but I don't know yet is

00:57:13,670 --> 00:57:15,750
if there's a CPU that's doing massive

00:57:15,750 --> 00:57:17,190
piles of call RCU and it's causing

00:57:17,190 --> 00:57:19,260
this problem I say you know buddy you're

00:57:19,260 --> 00:57:21,160
not offloaded anymore you're doing your

00:57:21,160 --> 00:57:23,370
own stuff with soft IRQ get over it.

00:57:23,370 --> 00:57:26,680
- I disagree I like number two as well

00:57:26,680 --> 00:57:30,480
administration oh and my machine by just

00:57:30,480 --> 00:57:33,030
doing stupid crap and it's that's the

00:57:33,030 --> 00:57:34,330
administration thing I don't think this

00:57:34,330 --> 00:57:35,410
is something bad.

00:57:35,410 --> 00:57:36,830
- Yeah I mean if you do stupid--

00:57:36,830 --> 00:57:38,790
- Sebastian wants to talk back there

00:57:38,790 --> 00:57:39,990
let's give him a chance.

00:57:42,006 --> 00:57:44,820
- I remember a while ago there was something documentation

00:57:44,820 --> 00:57:47,320
saying that you're not supposed to allot memory allowed,

00:57:47,320 --> 00:57:49,370
you have to limit yourself at some point.

00:57:49,370 --> 00:57:50,456
- [Man] Yeah.

00:57:50,456 --> 00:57:51,610
- So why are we doing this on that?

00:57:51,610 --> 00:57:55,810
- Because, okay so the mental model a lot of people have

00:57:55,810 --> 00:57:57,390
and it's a nice mental model to have and

00:57:57,390 --> 00:57:59,410
I'd like to preserve it if we can

00:57:59,410 --> 00:58:01,870
is that as soon as you do K3 RCU

00:58:01,870 --> 00:58:04,970
you freed it okay so the mental model

00:58:04,970 --> 00:58:08,280
would be okay I came out with it, okay I K3RCU it so

00:58:08,280 --> 00:58:12,920
life is good and that if I have to make them account

00:58:12,920 --> 00:58:14,150
for the fact that they can't see the

00:58:14,150 --> 00:58:16,390
grace period and they can't see when

00:58:16,390 --> 00:58:17,640
it's the callbacks being invoked they

00:58:17,640 --> 00:58:18,970
can't see what the K free happens so

00:58:18,970 --> 00:58:22,380
it's kind of ugly. - But they can have some

00:58:22,380 --> 00:58:24,600
kind of a county put himself and at some

00:58:24,600 --> 00:58:27,180
point it was synchronized with this view

00:58:27,180 --> 00:58:28,710
because they're getting out of hand.

00:58:28,710 --> 00:58:30,480
- [Man] Well synchronize,

00:58:30,480 --> 00:58:32,340
right now they can do RCU barrier

00:58:32,340 --> 00:58:33,770
synchronize RCU would just wait for

00:58:33,770 --> 00:58:35,180
another grace period there might

00:58:35,180 --> 00:58:36,570
millions and millions of callbacks still--

00:58:36,570 --> 00:58:39,080
- [Man] Exactly but they are dosed at filling up the

00:58:39,080 --> 00:58:42,160
pile so they that's your limitation do

00:58:42,160 --> 00:58:43,920
it enough to correct them that they have

00:58:43,920 --> 00:58:46,670
to wait and then life is good again.

00:58:46,670 --> 00:58:50,610
- [Man] Okay all right so certainly in the short

00:58:50,610 --> 00:58:53,450
term that's the choice because I'm not

00:58:53,450 --> 00:58:55,050
sure I'm not sure I can make this work

00:58:55,050 --> 00:58:56,640
right or at least not without causing

00:58:56,640 --> 00:58:57,990
some other horrible problem

00:58:59,540 --> 00:59:01,410
but okay but

00:59:01,410 --> 00:59:02,950
yeah that's the that is the current

00:59:02,950 --> 00:59:04,600
you're right that is the current stuff

00:59:04,600 --> 00:59:06,870
you can look at it in documentation RCU

00:59:06,870 --> 00:59:08,812
and it says by the way.

00:59:08,812 --> 00:59:12,000
- Yeah. - Yeah.

00:59:12,000 --> 00:59:14,610
Anyway okay I think I've got a lot

00:59:14,610 --> 00:59:16,700
of good advice I thank you very much I

00:59:16,700 --> 00:59:17,950
think it's also 11 o'clock and

00:59:17,950 --> 00:59:20,050
somebody else's turn okay.

00:59:25,937 --> 00:59:28,187
(laughter)

00:59:29,820 --> 00:59:33,370
Okay so I guess I'll, you're gonna have to so

00:59:33,370 --> 00:59:35,660
how much time do I have because you know,

00:59:35,660 --> 00:59:37,110
okay alright good.

00:59:37,110 --> 00:59:38,690
- Paul. - Yeah?

00:59:38,690 --> 00:59:41,120
- [Man] Can I get back to you on number four option there?

00:59:41,120 --> 00:59:43,090
- Number four, door number four.

00:59:44,490 --> 00:59:47,090
- [Man] I'm stepping back and are you not punting on

00:59:47,090 --> 00:59:48,340
the original problem that caused you to

00:59:48,340 --> 00:59:49,610
do this in the first place?

00:59:49,610 --> 00:59:52,300
The original problem was oh a CPU is doing too much I have

00:59:52,300 --> 00:59:54,090
to offload for it and then you say oh when it's doing too

00:59:54,090 --> 00:59:56,570
much, I'll stop floating.

00:59:56,570 --> 00:59:58,183
Why do we do all this?

00:59:58,183 --> 00:59:59,100
- [Man] So though the reason for offloading is because

00:59:59,100 --> 01:00:01,160
somebody wants really clean execution environment on

01:00:01,160 --> 01:00:01,993
that CPU.

01:00:01,993 --> 01:00:02,826
- [Man] And when they screw up

01:00:02,826 --> 01:00:04,550
you give it back to them anyway.

01:00:04,550 --> 01:00:06,680
- If they screw up then I say sorry you're out of the pool

01:00:06,680 --> 01:00:09,200
you screwed up and so rather than oh I'm the machine

01:00:09,200 --> 01:00:10,600
I'm gonna shoot your real-time response

01:00:10,600 --> 01:00:14,580
in the foot because and it may be that

01:00:14,580 --> 01:00:15,740
you're in something were you

01:00:15,740 --> 01:00:18,230
where you'd rather just explode so it's

01:00:18,230 --> 01:00:19,600
probably if I do that I'm probably have

01:00:19,600 --> 01:00:22,590
to boot parameter where it says

01:00:22,590 --> 01:00:24,080
you know if you detect that just blow

01:00:24,080 --> 01:00:26,110
the machine up so that we can have the

01:00:26,110 --> 01:00:28,890
secondary takeover and reboot and fix it

01:00:28,890 --> 01:00:30,690
or something I don't know if that's,

01:00:31,850 --> 01:00:33,350
I don't know what the best form for that is

01:00:33,350 --> 01:00:35,430
but I'm sure that if I've managed to

01:00:35,430 --> 01:00:36,830
get this working and I send patches out

01:00:36,830 --> 01:00:38,970
I'll get plenty of advice.

01:00:38,970 --> 01:00:41,490
- [Man] Yeah I definitely like number two because the

01:00:41,490 --> 01:00:43,790
splat like hey this is going on

01:00:43,790 --> 01:00:47,020
and you know my bad let's clean it up.

01:00:47,020 --> 01:00:49,100
- Okay all, right cool

01:00:49,100 --> 01:00:51,380
so Linus will be happy.

01:00:53,500 --> 01:00:56,800
Okay I'm gonna skip this because it's kind of

01:00:56,800 --> 01:00:58,390
there and just it's just I don't have

01:00:58,390 --> 01:00:59,990
any real question at this point.

01:01:02,060 --> 01:01:04,780
This one I do have a question on.

01:01:04,780 --> 01:01:06,900
Somebody had an interesting method of doing a bug

01:01:06,900 --> 01:01:09,940
report they posted a blog and I happen

01:01:09,940 --> 01:01:11,740
to come across it a few years later.

01:01:13,565 --> 01:01:15,815
(laughter)

01:01:17,050 --> 01:01:20,630
Which I don't have any way of contacting

01:01:20,630 --> 01:01:22,480
them so I can't suggest that he improve

01:01:22,480 --> 01:01:24,030
their bug reporting but you know if you

01:01:24,030 --> 01:01:25,690
know who they are that's it'd be good

01:01:25,690 --> 01:01:27,880
advice for them anyway what the thing

01:01:27,880 --> 01:01:29,500
was is that it used to be that there was

01:01:29,500 --> 01:01:32,180
a k' config option that said which cpus

01:01:32,180 --> 01:01:35,150
we're gonna be offloaded okay and you

01:01:35,150 --> 01:01:36,780
could say offload all of them with just

01:01:36,780 --> 01:01:39,700
a single configuration and I got a lot

01:01:39,700 --> 01:01:41,130
of heat for having too many k-kat big

01:01:41,130 --> 01:01:43,000
options a few years ago so I said fine

01:01:43,000 --> 01:01:44,790
I'll turn this into a boot parameter

01:01:46,200 --> 01:01:47,970
and what that means is the boot parameter

01:01:47,970 --> 01:01:51,470
you just used to give it a CPU list

01:01:51,470 --> 01:01:53,430
and what happens is if the number of

01:01:53,430 --> 01:01:55,560
CPUs if you say I want you know CPU's

01:01:55,560 --> 01:01:57,490
one through seven

01:01:57,490 --> 01:01:59,890
offloaded for an a CPU system and then

01:01:59,890 --> 01:02:02,070
you plop in a 16 CPU system you have to

01:02:02,070 --> 01:02:04,570
change your boot arguments okay

01:02:05,590 --> 01:02:07,034
well yeah but people were complaining people

01:02:07,034 --> 01:02:10,784
are playing about this you know people

01:02:10,784 --> 01:02:11,617
are complaining about this because they

01:02:11,617 --> 01:02:13,040
used to be able to just say offload

01:02:13,040 --> 01:02:15,270
everything with a K config option and

01:02:15,270 --> 01:02:17,860
they have no way they had no way at that

01:02:17,860 --> 01:02:19,730
points they upload anything anymore.

01:02:19,730 --> 01:02:21,190
They had to you know before they didn't have

01:02:21,190 --> 01:02:23,810
to change the boot arguments now they do.

01:02:23,810 --> 01:02:24,967
Much of the might sympathize with your

01:02:24,967 --> 01:02:28,260
viewpoint on the matter anyway so what I

01:02:28,260 --> 01:02:30,780
did is I made it so that it it just

01:02:30,780 --> 01:02:33,017
checks if there's an if there's a

01:02:33,017 --> 01:02:35,749
non-numeric and if it is it sees is it

01:02:35,749 --> 01:02:37,484
all and if it's all it does it but that

01:02:37,484 --> 01:02:39,774
kind of raises the question there's a

01:02:39,774 --> 01:02:42,190
generic thing I call that says parcel of

01:02:42,190 --> 01:02:46,320
CPU mask okay where you CPU list okay I

01:02:46,320 --> 01:02:49,510
never can the you know 1 - 5 comma 3

01:02:49,510 --> 01:02:51,070
whatever it is yeah and I become a

01:02:51,070 --> 01:02:54,440
stupid CB list but whatever anyway

01:02:54,440 --> 01:02:56,460
should we allow a trailing dash with

01:02:56,460 --> 01:02:57,293
nothing after it

01:02:58,450 --> 01:02:59,860
to say the rest of the CPUs.

01:03:02,980 --> 01:03:07,980
I don't know because I was lazy okay all right okay

01:03:11,580 --> 01:03:13,640
all right cool so that's and then

01:03:13,640 --> 01:03:16,820
there's I have a I have a thing if you

01:03:16,820 --> 01:03:18,670
do an RC CPU stall warning as a chroma

01:03:18,670 --> 01:03:20,130
RAM reading set so it'll automatically

01:03:20,130 --> 01:03:21,790
do an F trace dump and pop it out the

01:03:21,790 --> 01:03:23,070
console has been really useful to me

01:03:23,070 --> 01:03:24,360
maybe it's useful you guys too I don't

01:03:24,360 --> 01:03:25,330
know okay.

01:03:30,150 --> 01:03:32,850
Give the man a cube he's got two hell.

01:03:35,077 --> 01:03:35,910
(laughter)

01:03:35,910 --> 01:03:37,600
- Too late no the number of times

01:03:37,600 --> 01:03:39,530
I've actually had to go in and modify my

01:03:39,530 --> 01:03:42,540
kernel and put into the stall an

01:03:42,540 --> 01:03:45,300
F-trace dump that would be so much useful.

01:03:45,300 --> 01:03:47,806
- Okay well it's there now. - So yes please thank you.

01:03:47,806 --> 01:03:51,930
- All right there's also a kick K threads thing what

01:03:51,930 --> 01:03:54,430
happens is that what can happen is that

01:03:54,430 --> 01:03:56,260
if you configure your system in funny

01:03:56,260 --> 01:03:58,050
ways you can prevent the gray streak a

01:03:58,050 --> 01:04:00,510
person running at all and eventually oh

01:04:00,510 --> 01:04:04,580
I am there is a this guy here RC tree

01:04:04,580 --> 01:04:06,260
our tsuki K threads if you set that on

01:04:06,260 --> 01:04:08,200
boot what will happen is when it detects

01:04:08,200 --> 01:04:09,720
that the grace period K thread right isn't

01:04:09,720 --> 01:04:14,471
getting any CPU it'll splat and then kick it

01:04:14,471 --> 01:04:16,990
okay and it's a--

01:04:16,990 --> 01:04:18,930
- What do you mean by kick?

01:04:18,930 --> 01:04:20,380
- I do an unsolicited wake up

01:04:22,140 --> 01:04:25,850
which helps in some weird cases it isn't quite I didn't say

01:04:25,850 --> 01:04:28,640
it quite right just now but it it means that if

01:04:28,640 --> 01:04:30,650
you've done something funny and ran out

01:04:30,650 --> 01:04:33,600
for waking up then you can give another chance.

01:04:33,600 --> 01:04:37,410
Yeah and then let's see this thing here

01:04:37,410 --> 01:04:40,330
is was a request assist RQY already has

01:04:40,330 --> 01:04:41,920
a definition but it seemed to me to be

01:04:41,920 --> 01:04:43,990
the most specific one so I have a kernel

01:04:43,990 --> 01:04:45,960
parameter this one that says well since

01:04:45,960 --> 01:04:47,900
our cube Y doesn't do what it used to do

01:04:47,900 --> 01:04:49,170
for those people that used it for that I

01:04:49,170 --> 01:04:50,670
can't matter what it was sorry

01:04:51,580 --> 01:04:53,700
and instead what it does is it dumps the

01:04:53,700 --> 01:04:56,040
hierarchy of the RC you know tree which

01:04:56,040 --> 01:04:58,830
can be useful in some cases my thought

01:04:58,830 --> 01:05:00,190
is to expand that to include the

01:05:00,190 --> 01:05:01,930
topology the offloading as well if I

01:05:01,930 --> 01:05:03,150
haven't already I can or whether I did

01:05:03,150 --> 01:05:06,470
or not but I'll check assuming somebody

01:05:06,470 --> 01:05:09,150
takes notes and then this is complement

01:05:09,150 --> 01:05:11,460
so Sebastian if you say RC you

01:05:11,460 --> 01:05:15,660
tree used off soft irq equals zero then

01:05:15,660 --> 01:05:17,670
it'll use K threads instead of soft iron

01:05:17,670 --> 01:05:19,540
Q at that point RC you only softer RQ at

01:05:19,540 --> 01:05:21,720
all and I think that's hit mainline

01:05:21,720 --> 01:05:23,160
already if it's not it's coming up in

01:05:23,160 --> 01:05:25,810
the next emerges window anyway at this

01:05:25,810 --> 01:05:29,235
point I've used my five and a little bit

01:05:29,235 --> 01:05:30,068
thank you all very much for your time

01:05:30,068 --> 01:05:31,023
and attention and maybe next time I'll

01:05:31,023 --> 01:05:33,739
take a few people up and not use slides.

01:05:33,739 --> 01:05:34,714
(laughter)

01:05:34,714 --> 01:05:36,964
(applause)

01:05:39,730 --> 01:05:42,750
- Oh just one question when you say that you have

01:05:42,750 --> 01:05:47,374
in your mind the model of RCU do you see it as

01:05:47,374 --> 01:05:49,474
state machines?

01:05:49,474 --> 01:05:51,840
(laughter)

01:05:51,840 --> 01:05:53,765
- That depends what state I'm in.

01:05:53,765 --> 01:05:56,015
(laughter)

01:07:14,870 --> 01:07:17,581
- He's my manager I will not interrupt him.

01:07:17,581 --> 01:07:19,831
(laughter)

01:07:22,290 --> 01:07:26,140
So that's me Daniel and

01:07:27,240 --> 01:07:29,440
the idea here is to talk a

01:07:29,440 --> 01:07:31,650
little bit more on the latency which is

01:07:31,650 --> 01:07:34,550
is this to erm a metric even though we

01:07:34,550 --> 01:07:36,750
would like to have more deadlines one

01:07:36,750 --> 01:07:40,880
but we're still in love with latency and

01:07:40,880 --> 01:07:43,190
when we run the cyclic test we usually

01:07:43,190 --> 01:07:48,190
get this kind of distribution we have

01:07:49,505 --> 01:07:51,770
almost all the latencies here in the low

01:07:51,770 --> 01:07:55,110
and average and then we have like a tail

01:07:55,110 --> 01:07:58,680
that goes very long and we last two

01:08:00,940 --> 01:08:03,350
years ago Julia I started talking about

01:08:03,350 --> 01:08:05,880
using probabilistic methods to try to

01:08:05,880 --> 01:08:08,270
figure out what would be the worst case

01:08:08,270 --> 01:08:10,260
latency for example using extreme value

01:08:10,260 --> 01:08:14,830
analysis and well the latency is good

01:08:14,830 --> 01:08:18,970
it helped us it's a very good metric for

01:08:18,970 --> 01:08:23,970
us but in the end it's an opaque value

01:08:24,470 --> 01:08:27,770
because it's composed of many things

01:08:27,770 --> 01:08:30,580
that okay I know that Thomas knows I

01:08:30,580 --> 01:08:31,850
know that Peters know

01:08:31,850 --> 01:08:34,870
I myself know more less how it worked

01:08:34,870 --> 01:08:39,290
but still it's not clear to everybody

01:08:39,290 --> 01:08:44,290
which are the the what composes the

01:08:44,540 --> 01:08:46,830
latency and what could be the worst-case

01:08:46,830 --> 01:08:49,460
scenarios to give us a worst case

01:08:49,460 --> 01:08:53,010
latency and this turns hard if not

01:08:53,010 --> 01:08:55,040
impossible to use and probably worst

01:08:55,040 --> 01:08:59,100
case execution time analysis right but

01:08:59,100 --> 01:09:02,670
as we know but inside our minds we know

01:09:02,670 --> 01:09:05,530
it's composed by many code paths there

01:09:05,530 --> 01:09:10,330
are somehow independent right how can we

01:09:10,330 --> 01:09:14,010
improve this we could break the latency

01:09:14,010 --> 01:09:18,330
into small pieces that are independent

01:09:18,330 --> 01:09:21,990
right I know that these this piece of

01:09:21,990 --> 01:09:24,115
code is independent of the scheduler and

01:09:24,115 --> 01:09:27,240
I are accused are independent of the

01:09:27,240 --> 01:09:29,550
previews task that was running and

01:09:29,550 --> 01:09:32,650
disable interrupts so one good thing

01:09:32,650 --> 01:09:34,640
would be to break the latency into

01:09:34,640 --> 01:09:37,350
independent variables then it would be

01:09:37,350 --> 01:09:38,816
easier for us to apply those

01:09:38,816 --> 01:09:41,200
probabilistic methods to figure out the

01:09:41,200 --> 01:09:45,190
worst case of these small pieces because

01:09:45,190 --> 01:09:47,080
they would give us distribution curves

01:09:47,080 --> 01:09:51,480
that are more that are how can I say

01:09:52,680 --> 01:09:55,530
that makes more sense right then rather

01:09:55,530 --> 01:09:57,290
than having a composition of oh and we

01:09:57,290 --> 01:10:00,110
could not take any correlation between

01:10:00,110 --> 01:10:02,850
it so we break measure these values try

01:10:02,850 --> 01:10:05,260
to observe the worst case values of them

01:10:05,260 --> 01:10:07,560
try to use a probabilistic method and

01:10:07,560 --> 01:10:10,560
then we sell them back again trying to

01:10:10,560 --> 01:10:13,760
find a possible worst case scenario that

01:10:13,760 --> 01:10:16,250
we somehow observe it but not

01:10:16,250 --> 01:10:19,270
necessarily in one after the other when

01:10:19,270 --> 01:10:22,470
we sum all these independent variables

01:10:22,470 --> 01:10:25,550
that could happen terrifically we can

01:10:25,550 --> 01:10:28,370
have a possible worst case latest that

01:10:28,370 --> 01:10:30,680
we might not have seen while you're

01:10:30,680 --> 01:10:32,510
using cyclic tests because they took

01:10:32,510 --> 01:10:37,080
place in different times so but I to

01:10:37,080 --> 01:10:39,290
clarify it a little bit I wrote

01:10:43,860 --> 01:10:47,660
things get better when we draw it.

01:10:51,430 --> 01:10:54,220
So let's try to absorb the latest you think

01:10:54,220 --> 01:10:58,240
on it the latest is its the delay that

01:10:58,240 --> 01:11:01,000
the highest priority Fred my suffer

01:11:02,230 --> 01:11:05,844
indeed activation so we can say that in

01:11:05,844 --> 01:11:08,350
the end we wanted to see when this

01:11:08,350 --> 01:11:11,120
happened when the context switch from

01:11:11,120 --> 01:11:13,270
the task that is running to the task

01:11:13,270 --> 01:11:15,400
that actually has the highest priority

01:11:15,400 --> 01:11:18,790
now so this would be the the end of the

01:11:18,790 --> 01:11:19,623
story.

01:11:20,710 --> 01:11:22,670
The context which always take place

01:11:22,670 --> 01:11:26,470
inside the scheduler call and it always

01:11:26,470 --> 01:11:29,530
take place with IRQ is disabled right

01:11:30,850 --> 01:11:33,540
and preemption disable this scheduler is

01:11:33,540 --> 01:11:36,230
always called with preemption disabled

01:11:36,230 --> 01:11:37,470
but IRQ enable

01:11:39,680 --> 01:11:41,630
and then in the,

01:11:45,880 --> 01:11:49,050
the thing that note fires that we have a new

01:11:49,050 --> 01:11:51,250
highest priority thread independent of

01:11:51,250 --> 01:11:54,430
any scheduler is set need risk at right

01:11:54,430 --> 01:11:57,489
and certainly the risk ad can happen one

01:11:57,489 --> 01:11:58,560
of the restrictions in on Unicorn it can

01:11:58,560 --> 01:12:01,410
happen it always happens with interrupts

01:12:01,410 --> 01:12:03,980
in preemption disable necessarily so we

01:12:03,980 --> 01:12:06,950
can have in the best case it happen here

01:12:06,950 --> 01:12:08,900
when another trade already called the

01:12:08,900 --> 01:12:11,500
scheduler and we where in the way to

01:12:11,500 --> 01:12:13,190
call the scheduler so it's the best case

01:12:13,190 --> 01:12:15,760
everything was ready when it arrived we

01:12:15,760 --> 01:12:19,110
can have it here before the final

01:12:19,110 --> 01:12:21,310
decision of the scheduling but in a

01:12:21,310 --> 01:12:23,060
preparation for a scheduling like we

01:12:23,060 --> 01:12:25,410
have a codes in a read write semaphore

01:12:25,410 --> 01:12:27,800
or in the coast that flushes data to the

01:12:27,800 --> 01:12:29,820
disk I think there are some code that

01:12:29,820 --> 01:12:30,870
actually around here.

01:12:34,390 --> 01:12:37,280
Or okay and in this

01:12:37,280 --> 01:12:41,320
context we can also have IR harder

01:12:41,320 --> 01:12:44,270
accuse and we can also have NMI's,

01:12:45,140 --> 01:12:45,973
right.

01:12:51,730 --> 01:12:53,100
Oh no no no but I'm not

01:12:53,100 --> 01:12:55,820
these are need riskettes and these are the

01:12:56,730 --> 01:12:58,480
it's not touching a riskette right.

01:13:00,870 --> 01:13:02,960
Editing up a latency yeah.

01:13:07,400 --> 01:13:10,160
- You're just enumerating the components that make up

01:13:10,160 --> 01:13:12,500
this big latency where we're dealing with okay.

01:13:12,500 --> 01:13:13,900
- Yeah that's the final,

01:13:16,670 --> 01:13:18,220
ha ha, but we were right there.

01:13:22,570 --> 01:13:23,660
So step by step

01:13:26,360 --> 01:13:30,290
okay these were the optimistic case that

01:13:30,290 --> 01:13:31,760
another task have already called the

01:13:31,760 --> 01:13:34,210
scheduler for its own reason but in the

01:13:34,210 --> 01:13:35,750
irregular case we will have another

01:13:35,750 --> 01:13:38,130
thread running and then we have neat

01:13:38,130 --> 01:13:40,580
risk and have any on its context right

01:13:41,790 --> 01:13:44,550
because a low priority test but

01:13:46,480 --> 01:13:49,600
the good thing about frame 30 and the property

01:13:49,600 --> 01:13:51,820
that it provides that gives us the,

01:13:53,420 --> 01:13:56,180
the determinism that we see

01:13:57,260 --> 01:14:01,730
is that if we have a need risk at and if we always

01:14:01,730 --> 01:14:04,630
take place with frames on our code zebra

01:14:04,630 --> 01:14:07,070
also have both IRQ and preemption

01:14:07,070 --> 01:14:10,080
enabled we will not have any other kind

01:14:10,080 --> 01:14:13,000
of code running here we will directly

01:14:13,000 --> 01:14:15,370
call the scheduler right and that's the

01:14:15,370 --> 01:14:18,420
pram 30 if we have a code running here

01:14:18,420 --> 01:14:21,280
we have a bug and and I know a way to

01:14:21,280 --> 01:14:23,040
catch it with state machines but I would

01:14:23,040 --> 01:14:25,620
not talk about it now.

01:14:25,620 --> 01:14:27,456
Not today.

01:14:27,456 --> 01:14:29,950
Oh yeah.

01:14:31,740 --> 01:14:33,060
Okay so

01:14:34,720 --> 01:14:36,890
we can have a and also in this

01:14:36,890 --> 01:14:40,880
part of the code we can have interrupts

01:14:40,880 --> 01:14:44,160
NMI's trying to push

01:14:44,160 --> 01:14:44,993
further the

01:14:46,130 --> 01:14:48,997
they think that we want to the context switch.

01:14:56,100 --> 01:15:00,810
The IRQ disabled they might push up push to

01:15:00,810 --> 01:15:03,790
later execution of IRQs

01:15:03,790 --> 01:15:07,390
right but as we know that this scheduler

01:15:07,390 --> 01:15:09,300
is always called with IRQs

01:15:11,270 --> 01:15:14,990
enabled even though we can push them

01:15:14,990 --> 01:15:18,120
they will always execute like the

01:15:18,120 --> 01:15:19,850
interrupter took place in this time

01:15:19,850 --> 01:15:22,280
window they will always execute before

01:15:22,280 --> 01:15:24,900
the context switch so they will end up

01:15:24,900 --> 01:15:28,160
editing the overhead here right until

01:15:28,160 --> 01:15:31,410
this point where we disable interrupts

01:15:31,410 --> 01:15:32,960
and we will have the scheduler.

01:15:38,750 --> 01:15:39,583
Okay.

01:15:41,310 --> 01:15:43,690
- You have the same problem after the context

01:15:43,690 --> 01:15:45,990
switch because if there is interrupts piled

01:15:45,990 --> 01:15:47,770
up they will fire away.

01:15:47,770 --> 01:15:51,020
- Yeah but then that's one question I have.

01:15:52,350 --> 01:15:54,790
He's raising the point that we can have

01:15:54,790 --> 01:15:58,190
interrupts after the context switch that

01:15:58,190 --> 01:16:00,620
my added a value to the latest that we

01:16:00,620 --> 01:16:02,930
observe on cyclic test right?

01:16:02,930 --> 01:16:04,320
- Right. - Yeah

01:16:04,320 --> 01:16:05,153
but

01:16:05,990 --> 01:16:08,370
what should I or should we

01:16:11,440 --> 01:16:14,080
model the latency,

01:16:14,080 --> 01:16:17,520
what is the latency until the context switch on

01:16:17,520 --> 01:16:21,170
to you one task starts to run the code

01:16:21,170 --> 01:16:22,500
and return to user space.

01:16:23,829 --> 01:16:27,030
- Yeah actually what I think cyclic test is doing the

01:16:27,030 --> 01:16:28,960
right thing that's but because that's

01:16:28,960 --> 01:16:31,010
what the application cares about.

01:16:31,010 --> 01:16:34,890
- Okay, so I should observe until I really turn--

01:16:34,890 --> 01:16:37,280
- It doesn't help you if your context switch is on

01:16:37,280 --> 01:16:42,280
time and then you get delayed by 500 interrupts

01:16:42,330 --> 01:16:44,490
and use your--

01:16:44,490 --> 01:16:48,310
- Perfect that's something we need to clearly define.

01:16:48,310 --> 01:16:51,060
What do we consider as latency and to--

01:16:51,060 --> 01:16:53,240
- I actually agree with Thomas with what we

01:16:53,240 --> 01:16:55,510
declare is latency exactly that but what I

01:16:55,510 --> 01:16:56,800
like about what you're doing it sounds

01:16:56,800 --> 01:17:00,100
like is when you have like an anomaly

01:17:00,100 --> 01:17:03,140
you're like it may help seeing where it happened.

01:17:03,140 --> 01:17:08,140
- Of course, I mean decomposing the elements which can

01:17:09,000 --> 01:17:11,744
contribute to like latency in order to

01:17:11,744 --> 01:17:15,870
do some better estimation what it could be

01:17:15,870 --> 01:17:19,870
in the first case that's okay but

01:17:19,870 --> 01:17:21,220
for the application

01:17:23,180 --> 01:17:25,630
of course you can just say this is my

01:17:25,630 --> 01:17:28,010
scheduling latency but full from the

01:17:28,010 --> 01:17:31,140
application view the scheduling latency is

01:17:32,680 --> 01:17:33,890
what do I care about?

01:17:33,890 --> 01:17:35,242
- No actually I

01:17:35,242 --> 01:17:37,075
(mumbling)

01:17:37,075 --> 01:17:39,210
real time tasks that's worried about, you know,

01:17:39,210 --> 01:17:42,860
more of a like how often, okay I could handle a few

01:17:42,860 --> 01:17:44,880
worst-case scenarios so if you know what

01:17:44,880 --> 01:17:47,120
it is that causes us so you say okay

01:17:47,120 --> 01:17:48,890
this happens periodically I it's

01:17:48,890 --> 01:17:50,720
deterministic that I might have a

01:17:50,720 --> 01:17:52,270
outlier so this might help with

01:17:52,270 --> 01:17:54,160
deterministic latency that--

01:17:54,160 --> 01:17:55,850
- Wait, no, yeah but we can continue.

01:17:55,850 --> 01:17:58,680
- I don't think your final answer will actually change

01:17:59,950 --> 01:18:02,430
depending on where we put the points.

01:18:02,430 --> 01:18:03,600
I think it's moot.

01:18:06,030 --> 01:18:07,470
- [Man] I'm sorry I didn't get that.

01:18:07,470 --> 01:18:10,450
- I think it's irrelevant where exactly you placed a

01:18:10,450 --> 01:18:12,380
boundary I think the math will in the end be

01:18:12,380 --> 01:18:13,420
the exact same anyway.

01:18:13,420 --> 01:18:15,350
- Yeah, yeah that's the point I just need to

01:18:15,350 --> 01:18:17,970
know to clearly define until where I

01:18:17,970 --> 01:18:20,100
need to try to measure things because I

01:18:20,100 --> 01:18:23,280
can pile up things here right?

01:18:23,280 --> 01:18:27,000
I can say that after the context switch I can

01:18:27,000 --> 01:18:29,200
still have this time here which is with

01:18:29,200 --> 01:18:31,430
interrupts disabled then I will necessarily

01:18:31,430 --> 01:18:34,430
enable the interrupt before enabling the

01:18:34,430 --> 01:18:36,780
before return from the scheduler before

01:18:36,780 --> 01:18:39,900
enabling interrupt preemption back again

01:18:40,740 --> 01:18:44,880
so yeah it I will just pile something in after it

01:18:48,960 --> 01:18:50,890
- Just watching so the one thing you seem

01:18:50,890 --> 01:18:53,370
to be missing there is the time between

01:18:53,370 --> 01:18:56,320
well for return to user mode, if you add that--

01:18:56,320 --> 01:18:59,350
- Yeah that's the

01:19:00,610 --> 01:19:02,290
that's the agreement

01:19:02,290 --> 01:19:03,780
yeah

01:19:03,780 --> 01:19:05,680
and but still these parties is still

01:19:05,680 --> 01:19:08,970
valid right it will only pile in the end

01:19:08,970 --> 01:19:09,803
but good

01:19:10,740 --> 01:19:15,200
so trying to decompose the things that are somehow

01:19:15,200 --> 01:19:16,790
independent right?

01:19:23,200 --> 01:19:25,180
Are you India distractions our sewer

01:19:25,180 --> 01:19:28,260
just a task a thread right the

01:19:28,260 --> 01:19:29,540
interrupts our tread so they are

01:19:29,540 --> 01:19:31,740
included here in the priority because we

01:19:31,740 --> 01:19:33,960
don't have this software EQ context.

01:19:36,890 --> 01:19:40,310
So dealing now with this case

01:19:40,310 --> 01:19:43,410
right we I will edit the pile the other

01:19:43,410 --> 01:19:46,350
context later but dealing with this case

01:19:46,350 --> 01:19:48,950
here so we will have

01:19:50,560 --> 01:19:54,480
this part here which would be the worst case interrupts

01:19:54,480 --> 01:19:57,100
or preemption disabled that we could

01:19:57,100 --> 01:20:01,760
observe right then we would have this

01:20:01,760 --> 01:20:04,230
part of the code here that is the

01:20:04,230 --> 01:20:07,480
scheduler code that's called before we

01:20:07,480 --> 01:20:09,990
actually disable interrupts to finally

01:20:09,990 --> 01:20:12,290
do the context switch and here inside we

01:20:12,290 --> 01:20:14,000
can have we still can have some

01:20:15,050 --> 01:20:16,760
interrupt enable and disable and other

01:20:16,760 --> 01:20:20,740
stuff right we still can have here but

01:20:20,740 --> 01:20:24,750
as we know that until here, until this last I record disable

01:20:24,750 --> 01:20:26,310
we can have IRG enabled.

01:20:27,920 --> 01:20:32,920
We were already here but that's just the president so

01:20:33,130 --> 01:20:38,000
at this point any IRQ that happened here I will delay

01:20:38,000 --> 01:20:40,190
for later and then for the case you

01:20:40,190 --> 01:20:42,790
mentioned it would count but assuming

01:20:42,790 --> 01:20:46,880
this previous step it would not count

01:20:46,880 --> 01:20:49,950
right so this part is somehow

01:20:49,950 --> 01:20:53,060
independent this part is somehow

01:20:53,060 --> 01:20:56,080
independent and it varies if we are

01:20:56,080 --> 01:20:59,250
prompting or not because the flush of

01:20:59,250 --> 01:21:01,450
block device I think it happens here, right?

01:21:03,860 --> 01:21:07,040
And so these parts are are easy to

01:21:07,040 --> 01:21:11,380
decompose and then the problem is when

01:21:11,380 --> 01:21:13,470
we arrive in these two guys

01:21:16,270 --> 01:21:17,630
so I know that

01:21:19,140 --> 01:21:21,490
I will have to make a function a

01:21:21,490 --> 01:21:24,420
mathematical function that gives me the

01:21:24,420 --> 01:21:28,130
amount of time that IRQ's could

01:21:28,130 --> 01:21:31,370
consume in this time window in the PD

01:21:31,370 --> 01:21:32,203
time window

01:21:33,950 --> 01:21:35,840
because it's the time I win in which the

01:21:35,840 --> 01:21:37,390
interrupts could postpone us

01:21:39,760 --> 01:21:42,340
so I need to derive a function that T's that

01:21:42,340 --> 01:21:46,110
explains this and for NMIs

01:21:46,970 --> 01:21:49,460
it will takes all the windows because we cannot

01:21:49,460 --> 01:21:50,300
postpone an NMI.

01:21:53,760 --> 01:21:55,540
The problem is there

01:21:56,600 --> 01:21:58,690
when we are in the,

01:22:01,420 --> 01:22:05,050
when we are in the real-time world and we try to

01:22:06,490 --> 01:22:07,323
make these

01:22:10,600 --> 01:22:13,390
we need to characterize how

01:22:13,390 --> 01:22:15,760
IRQ's take place in the system

01:22:17,190 --> 01:22:21,240
right in the theory we can just say ok

01:22:21,240 --> 01:22:24,120
each IRQ has a period and they takes

01:22:24,120 --> 01:22:27,860
place periodically all right and then.

01:22:31,950 --> 01:22:32,783
Sorry?

01:22:34,860 --> 01:22:38,751
Yeah and I agree with you so let's say--

01:22:38,751 --> 01:22:41,700
- And the crypto people would also disagree.

01:22:41,700 --> 01:22:45,700
- Yeah yeah so what is the point?

01:22:45,700 --> 01:22:48,410
if we try to measure the minimal

01:22:48,410 --> 01:22:50,820
inter-arrival time of an IRQ

01:22:52,011 --> 01:22:53,380
we will have a peers mouth.

01:22:56,830 --> 01:22:57,663
Right.

01:22:58,700 --> 01:23:00,280
So this method

01:23:01,290 --> 01:23:04,010
it would ok it's safe in the

01:23:04,010 --> 01:23:06,410
real-time theory to added a pessimism

01:23:06,410 --> 01:23:08,890
but it's bad because the result gets

01:23:08,890 --> 01:23:11,560
less realistic so

01:23:12,600 --> 01:23:14,490
but one other approach

01:23:14,490 --> 01:23:17,470
that is knowing the economy is that ok

01:23:19,460 --> 01:23:24,000
I can still using the periodic approach

01:23:24,000 --> 01:23:26,590
but it will be bounded in our window

01:23:26,590 --> 01:23:28,120
generally right

01:23:29,320 --> 01:23:34,000
so I could say okay in my real-time system

01:23:34,000 --> 01:23:37,260
I observed one burst of IRQ's

01:23:39,470 --> 01:23:43,200
but they don't take place always

01:23:43,200 --> 01:23:45,020
in a time window let's say that this

01:23:45,020 --> 01:23:48,220
time a window here would be the max

01:23:48,220 --> 01:23:49,993
100 microseconds right.

01:23:55,948 --> 01:23:57,290
No just finishing this

01:23:57,290 --> 01:23:58,310
and then

01:23:58,310 --> 01:24:00,100
we could try to assume

01:24:00,100 --> 01:24:02,300
that okay I can have this burst but in

01:24:02,300 --> 01:24:05,040
this time window I have at most five.

01:24:09,370 --> 01:24:12,750
- Have you been talking with Wolfram and

01:24:12,750 --> 01:24:15,110
Daniels talk because it seems like some

01:24:15,110 --> 01:24:17,470
of the stuff that they're doing with the analysis.

01:24:18,360 --> 01:24:20,840
- In the arrival of the IRQ, right?

01:24:20,840 --> 01:24:25,160
- What not, no they're doing the jitter analysis for like a

01:24:25,160 --> 01:24:28,180
long time for statistical analysis to find out the person,

01:24:28,180 --> 01:24:30,000
the jitter debugger doing the

01:24:30,000 --> 01:24:32,770
statistical analysis of a long time to

01:24:32,770 --> 01:24:34,770
be able to figure out through statistic,

01:24:35,640 --> 01:24:37,850
what the maximum is, it sounds very, very similar.

01:24:37,850 --> 01:24:40,530
- Yeah it's similar, it can be similar to work that many

01:24:40,530 --> 01:24:43,057
people are doing but I'm trying to put

01:24:43,057 --> 01:24:46,660
in the real time academic work because

01:24:46,660 --> 01:24:48,560
they complain about the latest the box

01:24:49,620 --> 01:24:50,690
do you first.

01:24:50,690 --> 01:24:53,270
- [Man] Do you model your interrupts per interrupt line

01:24:53,270 --> 01:24:55,390
or it's like everything is an IRQ?

01:24:55,390 --> 01:25:00,260
- I think it will be easier to have each per each

01:25:00,260 --> 01:25:02,270
interrupt line it's a--

01:25:02,270 --> 01:25:05,990
- [Man] Because then you could measure your minimum period

01:25:05,990 --> 01:25:08,520
for each interrupt line and consider that your worst case.

01:25:08,520 --> 01:25:12,243
- Yeah yeah and that was the original idea to use per IRQ

01:25:13,620 --> 01:25:16,590
line because you can also do the

01:25:17,920 --> 01:25:20,440
schedule ability analysis for your cue

01:25:20,440 --> 01:25:22,590
because for example on Intel there are

01:25:22,590 --> 01:25:23,740
fixed priorities.

01:25:29,057 --> 01:25:31,790
- On Intel there's also shared interrupts.

01:25:31,790 --> 01:25:34,320
- Yeah but wait we do interrupt.

01:25:34,320 --> 01:25:38,800
- [Man] Interrupt statistics for idle prediction isn't that

01:25:38,800 --> 01:25:40,720
the same thing actually?

01:25:40,720 --> 01:25:41,760
- Yeah but

01:25:43,070 --> 01:25:46,350
it then then we get the pointer between

01:25:46,350 --> 01:25:49,250
this idea and that idea I as far as I

01:25:49,250 --> 01:25:51,610
know the interrupt prediction you

01:25:51,610 --> 01:25:53,800
consider all the

01:25:54,980 --> 01:25:59,470
old interrupts as the as interrupts not each one separated,

01:25:59,470 --> 01:26:00,700
am I wrong?

01:26:00,700 --> 01:26:02,060
So it's good.

01:26:02,060 --> 01:26:03,970
- [Man] Actually it looks like this is the same thing

01:26:03,970 --> 01:26:07,950
except that we done like we three timers in a special way

01:26:07,950 --> 01:26:10,480
you know in that code but--

01:26:10,480 --> 01:26:12,580
- Yeah that's the kind of information--

01:26:18,014 --> 01:26:20,720
The idea here is not to implement it, the idea is to

01:26:20,720 --> 01:26:23,000
describe it. - Just do one thing for that

01:26:23,000 --> 01:26:27,772
and for the idle prediction that looks like

01:26:27,772 --> 01:26:29,300
the same problem.

01:26:29,300 --> 01:26:32,630
- And how do do you guys measure the okay but you guys

01:26:32,630 --> 01:26:35,580
measure the next occurrence occurrence

01:26:35,580 --> 01:26:38,570
of the the course of the next interrupt, right?

01:26:38,570 --> 01:26:41,930
- [Man] No, we keep track of when they happen.

01:26:41,930 --> 01:26:45,800
- Okay. - And then we try to

01:26:45,800 --> 01:26:48,090
when next it's going to happen.

01:26:48,090 --> 01:26:51,860
- So basically it is a like

01:26:51,860 --> 01:26:55,740
cute like you know you

01:26:55,740 --> 01:26:59,400
micro very interrupts and then when idle when you need to

01:26:59,400 --> 01:27:00,410
predict you know

01:27:00,410 --> 01:27:03,220
at the idle duration you just apply

01:27:03,220 --> 01:27:07,180
statistics to that we have the data you can use it.

01:27:07,180 --> 01:27:10,710
- And that's good to me just to clarify that's good because

01:27:10,710 --> 01:27:13,320
the more thing we get ready the easier I will

01:27:13,320 --> 01:27:15,630
turn these into a paper and get rid of

01:27:15,630 --> 01:27:17,960
the idea that the latency is something

01:27:17,960 --> 01:27:19,940
that the Linux guys never cared about in

01:27:19,940 --> 01:27:20,773
the real time field.

01:27:20,773 --> 01:27:22,840
- [Man] Were you at the tracing?

01:27:22,840 --> 01:27:24,790
- No I was finishing the slides of the--

01:27:24,790 --> 01:27:26,950
- [Man] Of couse, but like I said the histogram synthetic

01:27:26,950 --> 01:27:30,590
events give you like you can actually say the trigger events

01:27:30,590 --> 01:27:33,130
only when you're in the where you want it to be triggered.

01:27:33,130 --> 01:27:36,450
- Yeah yeah then it's how we will measure, right

01:27:36,450 --> 01:27:38,970
and then these are tooling for doing the measurement.

01:27:38,970 --> 01:27:39,890
- It's already in the main line.

01:27:39,890 --> 01:27:41,190
- But that's not relevant.

01:27:43,220 --> 01:27:46,540
Actual description, you're talking about actually doing

01:27:46,540 --> 01:27:49,213
stuff that's completely different.

01:27:49,213 --> 01:27:51,463
(laughter)

01:27:52,390 --> 01:27:53,740
- I was just talking about the implementation of like,

01:27:53,740 --> 01:27:56,750
you're only caring about information in a specific window

01:27:56,750 --> 01:27:59,050
and you can do that today, I think I've only watched this

01:27:59,050 --> 01:28:00,370
trigger while I'm in within this window.

01:28:00,370 --> 01:28:02,280
- So he's talking real versus theoretical.

01:28:02,280 --> 01:28:05,100
- [Man] No, yeah yeah I know we have all these tools what I

01:28:05,100 --> 01:28:09,040
want is to find an agreement between us to what should I use

01:28:09,040 --> 01:28:11,770
to put okay we think that this would be the

01:28:11,770 --> 01:28:13,630
most realistic thing that we can do.

01:28:13,630 --> 01:28:14,630
- [Man] Well so the,

01:28:15,940 --> 01:28:19,380
IRQ, you know statistics for idle is exactly about the same

01:28:19,380 --> 01:28:23,670
thing about you know what you want is about figuring

01:28:23,670 --> 01:28:27,180
out how the next possibly interrupt you know.

01:28:29,510 --> 01:28:32,530
From the you know from the start to the idle period.

01:28:32,530 --> 01:28:35,520
- [Man] But are you guys trying to be as much

01:28:35,520 --> 01:28:38,260
pessimistic as possible or trying to

01:28:38,260 --> 01:28:40,710
find an average value?

01:28:40,710 --> 01:28:42,560
- [Man] Now being the theoretical--

01:28:44,450 --> 01:28:45,750
- It's a weighted average.

01:28:47,150 --> 01:28:49,820
Yeah in the real time period I know I would add a

01:28:49,820 --> 01:28:51,890
pessimism but that's the way that they

01:28:51,890 --> 01:28:53,780
think and the way that they like.

01:28:53,780 --> 01:28:57,290
- [Man] So we are pessimistic because we want the worst-case

01:28:57,290 --> 01:28:58,480
basically.

01:28:58,480 --> 01:29:00,040
- Perfect even better.

01:29:00,040 --> 01:29:01,700
- But the other thing I wanna say is you know this

01:29:01,700 --> 01:29:04,500
a mathematical theory the whole idea is what your job is to

01:29:04,500 --> 01:29:06,630
do is go do the papers do the research and come back

01:29:06,630 --> 01:29:08,050
and tell us oh this is what I found and

01:29:08,050 --> 01:29:10,420
you guys are all wrong anyway so this theoretically

01:29:10,420 --> 01:29:11,740
is what we want.

01:29:11,740 --> 01:29:16,270
- No I believe, I believe and I'm sure that Linux works

01:29:16,270 --> 01:29:18,530
and we know how it works but we don't

01:29:18,530 --> 01:29:21,650
have the clear description how things works.

01:29:21,650 --> 01:29:24,000
- Why it works. - And why it works.

01:29:25,090 --> 01:29:27,040
- We know it works but not why.

01:29:27,040 --> 01:29:28,760
- Yeah that's the--

01:29:28,760 --> 01:29:32,630
- Part of the job is to get the theorists to a more refined

01:29:32,630 --> 01:29:34,320
level of confusion about what the Linux terminal

01:29:34,320 --> 01:29:35,153
actually does.

01:29:35,153 --> 01:29:38,350
- Yes but they do not be an opaque confusion it will be a

01:29:38,350 --> 01:29:41,603
clear confusion or a clearer confusion.

01:29:41,603 --> 01:29:43,336
(laughter)

01:29:43,336 --> 01:29:45,400
- I'm not willing to accept that correction it'll be more

01:29:45,400 --> 01:29:48,550
refined in some way whether it's clear or not, maybe.

01:29:48,550 --> 01:29:52,490
I would hope so but-- - Refined confusion?

01:29:52,490 --> 01:29:53,740
- Yeah refined confusion.

01:29:55,435 --> 01:29:58,140
- The last problems I need to edit it for this the better

01:29:58,140 --> 01:30:02,510
because the more we show that we are actually have some

01:30:02,510 --> 01:30:04,830
reasons for Linux to work very well as

01:30:04,830 --> 01:30:06,550
real-time systems and we know it works

01:30:06,550 --> 01:30:09,210
empirically it resolves you see many

01:30:09,210 --> 01:30:11,890
people here talking about Ryota so we

01:30:11,890 --> 01:30:14,390
would like to to try to clarify this and

01:30:14,390 --> 01:30:15,223
so we could--

01:30:19,230 --> 01:30:20,063
Throw box.

01:30:21,476 --> 01:30:23,820
- Who needs it?

01:30:25,192 --> 01:30:28,840
- [Man] I wanted to say this one use case for having a model

01:30:28,840 --> 01:30:30,200
that describes some

01:30:31,660 --> 01:30:34,260
operating system only such as latency

01:30:34,260 --> 01:30:37,840
and so on that I find myself needing is

01:30:37,840 --> 01:30:40,150
as a performance analyst is when I have

01:30:41,950 --> 01:30:46,260
labs results, I do a lot of experiments and I have to decide

01:30:46,260 --> 01:30:50,910
if my result is statistically significant so I have to

01:30:50,910 --> 01:30:54,980
use formulas to compute the P value for example and then

01:30:54,980 --> 01:30:59,233
you need to know the variance of your random variable and

01:31:00,330 --> 01:31:03,650
what I do is that I assume it's a Gauss Bell

01:31:03,650 --> 01:31:05,760
it's, I assume it's a normal distribution

01:31:05,760 --> 01:31:08,380
but obviously it's not and an accurate

01:31:08,380 --> 01:31:11,800
description of this stuff can give you

01:31:11,800 --> 01:31:13,180
the formula that you plug in in your

01:31:13,180 --> 01:31:16,980
T test to decide yes this is a

01:31:16,980 --> 01:31:20,990
from then only part I mean if if there is a change you know,

01:31:20,990 --> 01:31:24,520
so models helps doing statistics when

01:31:24,520 --> 01:31:27,320
you measure stuff to know if you have

01:31:27,320 --> 01:31:29,890
hopes are observing a difference or not

01:31:29,890 --> 01:31:32,850
so it's not completely I mean it's

01:31:32,850 --> 01:31:35,870
having a model is helpful it needs to

01:31:36,870 --> 01:31:38,400
I think something that you need to ask

01:31:38,400 --> 01:31:41,930
yourself before you go down and model

01:31:41,930 --> 01:31:44,720
something is what do I need this model for?

01:31:44,720 --> 01:31:47,210
Like what is the question and trying to answer it

01:31:47,210 --> 01:31:48,043
'cause obviously--

01:31:48,043 --> 01:31:50,950
- [Man] What is the question you're trying to answer here is

01:31:54,100 --> 01:31:57,280
The paper will have this part explain this thing and

01:31:57,280 --> 01:32:00,010
then we'll go to experimental part doing

01:32:00,010 --> 01:32:02,070
the measurements and trying to figure out

01:32:02,070 --> 01:32:05,550
a higher or a latency that could

01:32:05,550 --> 01:32:07,660
actually happen but not necessarily

01:32:07,660 --> 01:32:10,950
happen while running cyclic test so it's

01:32:10,950 --> 01:32:14,953
good for us to define what would be the most, okay--

01:32:18,300 --> 01:32:19,220
Okay so

01:32:21,690 --> 01:32:26,300
we need it to clarify what is our metrics because on the

01:32:26,300 --> 01:32:29,590
scheduling theory they assume that the

01:32:29,590 --> 01:32:31,840
event of waking up the activation of a

01:32:31,840 --> 01:32:35,380
task is an atomic thing and it has no delays and they

01:32:35,380 --> 01:32:37,030
don't consider these on the scheduling

01:32:37,030 --> 01:32:40,420
development and that's why when we try

01:32:40,420 --> 01:32:42,550
to feed any scheduler on Linux it

01:32:42,550 --> 01:32:45,800
doesn't work perfectly, does this answer your question?

01:32:45,800 --> 01:32:48,690
- [Man] Yeah, sure, sure.

01:32:48,690 --> 01:32:51,490
- So you could do one of two things you could come up with

01:32:51,490 --> 01:32:54,390
the closed form function for what you have there

01:32:55,650 --> 01:32:57,870
and then show that the measure numbers

01:32:57,870 --> 01:33:01,820
that people have fit that equation that you have.

01:33:01,820 --> 01:33:04,620
- Yeah. - Or you could use the

01:33:04,620 --> 01:33:06,970
empirical data that we have and come up

01:33:06,970 --> 01:33:11,820
with curve fitting strategy to come up

01:33:11,820 --> 01:33:14,220
with a function that actually reflects

01:33:15,410 --> 01:33:17,230
the measure so what's the approach you're going to take?

01:33:17,230 --> 01:33:19,310
You're going to come up with an equation first and then

01:33:19,310 --> 01:33:21,090
show that that actually satisfies?

01:33:22,540 --> 01:33:25,340
- And that's incremental work yeah you're reaching the next

01:33:25,340 --> 01:33:26,240
step so--

01:33:27,360 --> 01:33:29,490
- You could do first you come up where you expect it to

01:33:29,490 --> 01:33:31,040
be do the analysis and you have to go

01:33:31,040 --> 01:33:33,100
back anyway and say wait why was I wrong?

01:33:33,980 --> 01:33:36,660
- Yeah no there are things that are things

01:33:36,660 --> 01:33:38,630
that here that are more or less the

01:33:38,630 --> 01:33:41,860
terminus in the events state right you

01:33:41,860 --> 01:33:44,260
have the deterministic part here which

01:33:44,260 --> 01:33:48,630
is the easy part now we have to model

01:33:48,630 --> 01:33:53,630
these things and but in the current latency we have that

01:33:53,880 --> 01:33:56,580
number that we cannot fit on anything with any level of

01:33:56,580 --> 01:33:59,580
insurance but by breaking down breaking

01:33:59,580 --> 01:34:04,450
the pieces we can probably and I hope

01:34:04,450 --> 01:34:06,090
try to find better ways to use

01:34:06,090 --> 01:34:08,230
statistical methods to define what would

01:34:08,230 --> 01:34:09,140
be the worst case.

01:34:09,140 --> 01:34:11,380
- Right but the problem is this is so much different than

01:34:11,380 --> 01:34:12,760
the workloads that you're going to be running.

01:34:12,760 --> 01:34:16,290
- No sure this is obviously dependent of the workload.

01:34:19,410 --> 01:34:23,090
Sure, but in the theory that's why we have a variables here

01:34:23,090 --> 01:34:26,070
we don't know the numbers, the numbers will be dependent on

01:34:26,070 --> 01:34:28,790
the workload but in the real time

01:34:28,790 --> 01:34:31,680
theory we try to come up with the model,

01:34:31,680 --> 01:34:33,760
give the model and the variables and

01:34:33,760 --> 01:34:36,960
then each system will feed the variables

01:34:36,960 --> 01:34:39,860
to try to say okay in my system I

01:34:39,860 --> 01:34:42,320
observed these things and it depends on

01:34:42,320 --> 01:34:44,980
ba-ba-ba-ba-ba and then using

01:34:44,980 --> 01:34:47,200
probabilistic methods trying to go,

01:34:48,280 --> 01:34:50,030
Yeah, the model will be the same.

01:34:50,030 --> 01:34:51,740
The numbers will be the variables will

01:34:51,740 --> 01:34:54,327
be independent is that a good answer?

01:34:56,716 --> 01:34:59,620
- One thing you could show with this as well I mean one of

01:34:59,620 --> 01:35:02,920
the key thing you can do there is to reduce the amount

01:35:02,920 --> 01:35:05,600
of CPU time it takes to reproduce a

01:35:05,600 --> 01:35:07,890
worse case so things that could take

01:35:07,890 --> 01:35:09,750
years to reproduce you could actually

01:35:09,750 --> 01:35:12,670
perhaps produce that in seconds or minutes so--

01:35:14,098 --> 01:35:17,720
Yeah that's another point because we not necessarily--

01:35:17,720 --> 01:35:19,930
- Yeah 'cause I'm going up that I guess if you actually

01:35:19,930 --> 01:35:22,100
this brings up with looking at different

01:35:22,100 --> 01:35:23,540
types of interrupts and if you see a

01:35:23,540 --> 01:35:25,060
period you might be able say wait a

01:35:25,060 --> 01:35:28,130
minute if all the what's called the wit

01:35:28,130 --> 01:35:29,760
you say is a wave or say if there's like

01:35:29,760 --> 01:35:31,510
certain things in blue and then you

01:35:32,421 --> 01:35:33,450
could say maybe in 10 years is a

01:35:33,450 --> 01:35:35,240
possibility that these will all line up

01:35:35,240 --> 01:35:36,665
and then you have this huge latency.

01:35:36,665 --> 01:35:39,490
- Yeah that that's one of the missions in that

01:35:39,490 --> 01:35:41,150
one of the game for the performance

01:35:41,150 --> 01:35:43,820
measurements because with the cyclic

01:35:43,820 --> 01:35:47,940
test we observe the worst case of thing

01:35:47,940 --> 01:35:50,850
that happening during my measurement.

01:35:50,850 --> 01:35:53,760
Mike but could be the case that these

01:35:53,760 --> 01:35:57,110
latency here was caused by these things

01:35:57,110 --> 01:35:59,650
very long while having very short

01:35:59,650 --> 01:36:02,410
interrupts interference and these one

01:36:02,410 --> 01:36:05,570
here could be that these happening very

01:36:05,570 --> 01:36:09,380
short and these happening very long so

01:36:09,380 --> 01:36:11,600
we might as well have the case of

01:36:11,600 --> 01:36:14,020
removing the IRQ's from the worst case

01:36:14,020 --> 01:36:16,550
IRQs and summing with the

01:36:16,550 --> 01:36:18,950
preemption that doesn't consider the IRQ's

01:36:19,805 --> 01:36:22,257
right it doesn't consider the IRQ.

01:36:22,257 --> 01:36:26,540
We could have it could happen

01:36:26,540 --> 01:36:29,520
that these worst case preemption

01:36:29,520 --> 01:36:32,120
disabled would accept the occurrence it

01:36:32,120 --> 01:36:33,930
would take place at the same a moment of

01:36:33,930 --> 01:36:37,080
these worst case IRQ and they sum

01:36:37,080 --> 01:36:38,700
up and it's correct to assume this

01:36:38,700 --> 01:36:41,030
because these are independent variables

01:36:42,000 --> 01:36:43,600
and that's the kind of the thing that

01:36:43,600 --> 01:36:47,840
the model tries to clarify you know

01:36:47,840 --> 01:36:50,570
to decompose but I agree that these

01:36:50,570 --> 01:36:53,250
things we have very different ways to

01:36:53,250 --> 01:36:55,950
moderate we have different ways to apply

01:36:55,950 --> 01:36:59,910
later extreme value theory to find these

01:36:59,910 --> 01:37:03,910
values right but we need first to decompose and make things

01:37:03,910 --> 01:37:06,630
clear for people to be able to apply these things because in

01:37:06,630 --> 01:37:09,110
the current metric the value they would

01:37:09,110 --> 01:37:10,820
find a value that doesn't make sense and

01:37:10,820 --> 01:37:12,760
doesn't adhere for further a theory.

01:37:13,750 --> 01:37:15,960
- I have a question about validating some of

01:37:15,960 --> 01:37:17,980
this not really about your work but is

01:37:17,980 --> 01:37:20,270
there a way to find out when an IRQ is

01:37:20,270 --> 01:37:22,330
actually post disabled is this our

01:37:22,330 --> 01:37:24,790
hardware mechanism just does the

01:37:24,790 --> 01:37:26,370
hardware keep track of when the IRQ

01:37:26,370 --> 01:37:29,090
actually is posted in a modern system?

01:37:29,090 --> 01:37:30,030
- And that was a question.

01:37:30,030 --> 01:37:32,630
- We can't hook up scopes because it's all messages across

01:37:32,630 --> 01:37:33,463
buses.

01:37:36,672 --> 01:37:40,380
- The device fire off the message and it's gone so there's

01:37:40,380 --> 01:37:41,820
no time stamp anyway.

01:37:41,820 --> 01:37:42,653
- Yeah.

01:37:42,653 --> 01:37:46,990
- There's some some stuff which actually

01:37:46,990 --> 01:37:51,990
has the where can be further information

01:37:52,260 --> 01:37:55,290
when it fired if you have if we have

01:37:55,290 --> 01:37:59,240
hard times them that practice

01:37:59,240 --> 01:38:03,770
we can infer the time when the interrupt actually was

01:38:03,770 --> 01:38:06,300
fired from the time stamp on the packet.

01:38:08,170 --> 01:38:11,240
But other than that no.

01:38:11,240 --> 01:38:12,073
- Yeah but that's

01:38:12,073 --> 01:38:13,320
the good thing about they compose

01:38:13,320 --> 01:38:17,130
anything because this the prediction the

01:38:17,130 --> 01:38:20,527
hardest part right because we cannot we

01:38:20,527 --> 01:38:23,410
don't have a clear description but

01:38:23,410 --> 01:38:26,960
we can deal with this pessimism here while

01:38:26,960 --> 01:38:29,220
having this clearly more defined.

01:38:29,220 --> 01:38:30,053
- Right.

01:38:30,053 --> 01:38:32,470
- And actually we as kernel developers we

01:38:32,470 --> 01:38:34,740
care about this we will try to reduce

01:38:34,740 --> 01:38:35,990
this as much as possible.

01:38:36,990 --> 01:38:38,870
Because that is out of our control.

01:38:38,870 --> 01:38:39,703
- Right.

01:38:39,703 --> 01:38:42,769
- It's out it's in is in the society mean

01:38:42,769 --> 01:38:44,470
control for example he could move some

01:38:44,470 --> 01:38:46,850
IRQ's to other core to try to

01:38:46,850 --> 01:38:48,270
reduce the latency here.

01:38:52,300 --> 01:38:56,510
- So you need to remember IRQ's are basically

01:38:56,510 --> 01:38:59,870
can so I feel latency can vary depending

01:38:59,870 --> 01:39:03,700
on the source on energy efficiency

01:39:03,700 --> 01:39:06,080
features which can be enabled like a SPM

01:39:06,080 --> 01:39:10,110
in PCI which if you enable it it can you

01:39:10,110 --> 01:39:14,560
can you know delay yeah it can extend

01:39:14,560 --> 01:39:17,260
the worst case by another if I need to.

01:39:17,260 --> 01:39:20,140
Essentially so yeah you

01:39:20,140 --> 01:39:22,970
are right the whatever the admin does

01:39:22,970 --> 01:39:25,700
will influence the interrupt, interrupt latency.

01:39:25,700 --> 01:39:28,400
- [Man] Yeah yeah and that's good because in the end

01:39:28,400 --> 01:39:32,430
we could find it we could end up helping Susana means to

01:39:32,430 --> 01:39:34,700
reduce the latency based on a more

01:39:34,700 --> 01:39:36,990
precise information or what is

01:39:36,990 --> 01:39:38,610
contributing to the latest a not having

01:39:38,610 --> 01:39:40,050
to add a lot of extra mentation to

01:39:40,050 --> 01:39:41,860
observe something that you not observe

01:39:41,860 --> 01:39:42,693
it again.

01:39:43,740 --> 01:39:45,000
- Be careful here because there

01:39:45,000 --> 01:39:46,930
are some of the worst cases is not the

01:39:46,930 --> 01:39:48,080
worst case of the some.

01:39:50,160 --> 01:39:54,990
No, no I mean if you really want to be hard and you so

01:39:54,990 --> 01:39:56,150
what you get we--

01:39:57,810 --> 01:39:59,590
- [Man] I'm putting my shepherd hat on, we're 10 minutes

01:39:59,590 --> 01:40:02,750
into the break if we want food and coffee we better leave

01:40:02,750 --> 01:40:03,583
right now.

01:40:04,646 --> 01:40:06,896
(laughter)

01:40:08,283 --> 01:40:11,940
- The talk I think was supposed to be soft IRQs

01:40:11,940 --> 01:40:15,390
May 9 in for RT but it's actually an entirely different

01:40:15,390 --> 01:40:16,508
it's actually,

01:40:16,508 --> 01:40:17,650
(laughter)

01:40:17,650 --> 01:40:20,910
it's actually is some kind of pet project so,

01:40:22,200 --> 01:40:25,577
was what? - A bait and switch?

01:40:25,577 --> 01:40:29,610
- No, no.

01:40:29,610 --> 01:40:32,860
Okay so it was about it's about the patch set I posted like

01:40:32,860 --> 01:40:36,250
several months ago but before I enter to

01:40:36,250 --> 01:40:39,240
into the details I'm going to first

01:40:39,240 --> 01:40:43,170
introduce some current state about the

01:40:43,170 --> 01:40:44,980
soft IRQ code so

01:40:46,030 --> 01:40:50,440
I actually only have guesses because I believe that

01:40:50,440 --> 01:40:54,110
the design is the same for decades.

01:40:55,000 --> 01:40:58,490
Yes, because it has that taste of ancient

01:40:58,490 --> 01:41:03,100
code which is actually it tastes nice.

01:41:03,100 --> 01:41:03,933
I like it.

01:41:06,370 --> 01:41:11,160
So yeah it's a very straightforward code which so it's

01:41:11,160 --> 01:41:13,230
essentially an all-in-one switch when

01:41:13,230 --> 01:41:15,290
you disable the soft IRQ's for

01:41:15,290 --> 01:41:18,230
example with the local BH disable

01:41:18,230 --> 01:41:20,710
function it's an all-in-one switch so

01:41:20,710 --> 01:41:24,420
you disable every vectors so

01:41:24,420 --> 01:41:26,520
imagine that you want your code to be

01:41:27,910 --> 01:41:29,580
safe against

01:41:29,580 --> 01:41:34,360
networking our X vector soft IRQ vector is going to also

01:41:34,360 --> 01:41:38,570
disable every other vectors so high resolution timers

01:41:38,570 --> 01:41:39,403
vectors

01:41:40,800 --> 01:41:41,970
block

01:41:41,970 --> 01:41:44,070
timers RCU so everything

01:41:45,170 --> 01:41:47,160
and it's the same for a

01:41:47,160 --> 01:41:49,460
vector execution so when

01:41:50,520 --> 01:41:53,380
the networking when one networking vector is

01:41:53,380 --> 01:41:55,990
executing the other vectors can not

01:41:55,990 --> 01:41:58,340
execute at the same time on a single CPU

01:41:58,340 --> 01:42:01,440
at least because of core supplier cues

01:42:01,440 --> 01:42:04,620
can execute concurrently across CPUs but

01:42:04,620 --> 01:42:06,640
not in a single CPU.

01:42:08,240 --> 01:42:13,240
So what I think RT wants I'm not going to take much

01:42:13,740 --> 01:42:17,990
risk about guessing but I think the,

01:42:19,080 --> 01:42:21,060
so soft IRQ's are annoying just

01:42:21,060 --> 01:42:23,890
like any soft just like any interrupt

01:42:23,890 --> 01:42:26,510
for latency sensitive tasks

01:42:28,590 --> 01:42:29,950
because they are on the way

01:42:30,900 --> 01:42:33,980
when the task wakes up and has a

01:42:33,980 --> 01:42:37,920
critical code to execute with

01:42:37,920 --> 01:42:41,370
latency deterministic expectations

01:42:41,370 --> 01:42:45,540
interrupts are on the way and soft IRQs behave just like

01:42:45,540 --> 01:42:50,530
hard interrupts in this regard and it's also the same

01:42:50,530 --> 01:42:52,670
with soft IRQ disabled sections.

01:42:55,460 --> 01:42:58,220
They are also annoying in the same way.

01:42:58,220 --> 01:43:01,020
So RT wants,

01:43:01,020 --> 01:43:04,760
I believe to preempt soft IRQs,

01:43:04,760 --> 01:43:06,130
you do

01:43:06,130 --> 01:43:08,320
but more to that after.

01:43:08,320 --> 01:43:10,480
They want to print or interrupts soft IRQs

01:43:10,480 --> 01:43:14,680
in order to execute more important more higher priority code

01:43:14,680 --> 01:43:16,820
and they want to also make use of

01:43:16,820 --> 01:43:19,120
priority inheritance such that when a

01:43:19,120 --> 01:43:22,440
task depends on the lock from

01:43:22,440 --> 01:43:24,680
held by a soft IRQs they want that soft IRQs

01:43:25,668 --> 01:43:27,570
to complete fast so that the

01:43:27,570 --> 01:43:30,210
high priority tasks can go to the CPU.

01:43:32,950 --> 01:43:33,910
Also we want

01:43:34,960 --> 01:43:37,570
soft IRQs to

01:43:37,570 --> 01:43:39,630
interrupt other soft IRQs

01:43:40,740 --> 01:43:43,710
for the same reason of a priority inheritance.

01:43:46,760 --> 01:43:48,260
that's also for mainline yeah.

01:43:49,200 --> 01:43:51,200
But you don't have priority inheritance.

01:43:52,180 --> 01:43:56,830
No, but the thing that we only have this

01:43:56,830 --> 01:43:59,750
all in one off on mechanism

01:44:01,220 --> 01:44:05,410
the thing what people were complaining about when

01:44:05,410 --> 01:44:09,460
net the network guys forced made sure

01:44:09,460 --> 01:44:12,450
that once they switched into soft IRQ

01:44:12,450 --> 01:44:16,730
threat mode that the next interrupt

01:44:16,730 --> 01:44:19,870
wouldn't start over in in the return

01:44:19,870 --> 01:44:23,940
from inter a path again but that also

01:44:23,940 --> 01:44:26,950
affected every other soft interrupt

01:44:26,950 --> 01:44:30,030
vector which means tasks let's got

01:44:30,030 --> 01:44:31,700
delayed as well and whatever the

01:44:31,700 --> 01:44:36,700
hell got delayed so they are nasty hacks in there to make

01:44:37,790 --> 01:44:39,580
this work which is

01:44:41,160 --> 01:44:43,830
yeah the soft IRQ now mask

01:44:43,830 --> 01:44:46,880
it's a horrible hacking it needs to die.

01:44:52,270 --> 01:44:53,860
He has a slide on that.

01:44:53,860 --> 01:44:55,390
- I'm going to.

01:44:55,390 --> 01:44:59,480
It's just a teaser.

01:44:59,480 --> 01:45:01,870
Okay so now what I believe

01:45:01,870 --> 01:45:03,930
mainline wants so yeah that's roughly

01:45:03,930 --> 01:45:07,190
what Thomas just explained some soft IRQ

01:45:07,190 --> 01:45:10,820
vectors can really eat a lot of

01:45:10,820 --> 01:45:14,620
CPUs and it's mostly about networking

01:45:14,620 --> 01:45:16,820
soft IRQs but it could be also the

01:45:16,820 --> 01:45:21,590
case with tasks let's or yeah and block

01:45:21,590 --> 01:45:24,900
also when you have large stream of block

01:45:24,900 --> 01:45:25,840
packets arriving

01:45:28,610 --> 01:45:31,620
but there is a balance to find here because

01:45:31,620 --> 01:45:34,580
you don't want to starve the soft IRQs

01:45:34,580 --> 01:45:39,390
so you want the soft IRQ to handle all the packets arriving

01:45:39,390 --> 01:45:42,440
but at the same time you also want the user tasks

01:45:42,440 --> 01:45:46,230
that depend on these packets to also

01:45:46,230 --> 01:45:48,310
first process those packets so you have

01:45:48,310 --> 01:45:51,250
to find something in the middle and

01:45:52,160 --> 01:45:54,510
it's actually very hard to achieve

01:45:58,703 --> 01:46:02,290
the mainline uses some sort of

01:46:02,290 --> 01:46:05,720
balance between interrupt processing so

01:46:05,720 --> 01:46:08,600
soft IRQs are usually executed at the

01:46:08,600 --> 01:46:10,860
end of hard IRQs

01:46:10,860 --> 01:46:15,860
and they we try to switch to a threaded processing

01:46:15,910 --> 01:46:19,780
when the load becomes too heavy but

01:46:22,020 --> 01:46:24,100
of course it has the drawback because if

01:46:24,100 --> 01:46:28,260
you uffload to threading processing

01:46:28,260 --> 01:46:31,260
you might also suffer from some delays

01:46:31,260 --> 01:46:33,840
you might lose some packets networking

01:46:33,840 --> 01:46:35,630
packets so--

01:46:35,630 --> 01:46:36,890
- [Man] The networking case is not

01:46:36,890 --> 01:46:39,440
the problematic case the network in case

01:46:39,440 --> 01:46:42,250
forces it into the threat and

01:46:42,250 --> 01:46:44,120
then it stores everybody else.

01:46:45,480 --> 01:46:48,380
So that's what people were complaining

01:46:48,380 --> 01:46:50,770
about and that's why we have that

01:46:51,690 --> 01:46:52,660
nasty thing there.

01:46:53,980 --> 01:46:56,110
- Yeah so because when you

01:46:57,450 --> 01:47:01,090
defer the software you keep processing into a threaded mode

01:47:01,090 --> 01:47:03,660
every soft IRQs are going to be

01:47:03,660 --> 01:47:06,400
differed there so for example if you

01:47:06,400 --> 01:47:10,060
have tons of networking packets arriving

01:47:10,060 --> 01:47:13,490
we offload the computation to case of

01:47:13,490 --> 01:47:16,310
IRQD and then every subsequent

01:47:16,310 --> 01:47:19,240
vector raised are going to execute on

01:47:19,240 --> 01:47:22,450
that shredded mode and yeah that's a

01:47:22,450 --> 01:47:24,410
problem because case after IRQD is

01:47:24,410 --> 01:47:27,180
going to run well it's the scheduler

01:47:27,180 --> 01:47:28,380
that decides so

01:47:30,790 --> 01:47:33,400
and since we still need quick hunting for many of these

01:47:33,400 --> 01:47:36,640
soft IRQs it's a big issue

01:47:36,640 --> 01:47:40,450
so this is the hack that tries to leverage that

01:47:42,700 --> 01:47:47,700
yeah so tasks let's soft IRQs often need very quick

01:47:48,310 --> 01:47:52,580
processing so when you when every vectors are delayed

01:47:52,580 --> 01:47:57,020
to case soft IRQD but still an interrupt fires

01:47:57,020 --> 01:47:59,630
and enqueues a new soft IRQ

01:48:00,700 --> 01:48:05,150
and here would be tasks read for example

01:48:05,150 --> 01:48:08,070
if we want to execute them right now and

01:48:08,070 --> 01:48:11,410
not wait for the case soft IRQD we have that hacked that

01:48:11,410 --> 01:48:16,410
ensures that that is done right, right on by a

01:48:19,890 --> 01:48:21,890
and it's not very pretty yeah

01:48:24,690 --> 01:48:28,150
so the RT solution to cope with

01:48:29,180 --> 01:48:32,650
most I guess RT needs so this I guess

01:48:32,650 --> 01:48:34,770
most of you know this is the

01:48:34,770 --> 01:48:36,690
threaded softirq implementation

01:48:36,690 --> 01:48:40,900
so most of the what was executed on hard

01:48:40,900 --> 01:48:44,140
interrupts tale is no executed in

01:48:44,140 --> 01:48:47,150
shredded mode we also have per-vector

01:48:47,150 --> 01:48:50,400
granularity so we have I believe one case

01:48:50,400 --> 01:48:52,240
of IRQD per vector right?

01:48:53,480 --> 01:48:54,390
No, no?

01:48:55,290 --> 01:48:56,450
Oh you had, okay.

01:48:56,450 --> 01:48:59,910
- [Man] We had and that had its own set of problems exactly

01:48:59,910 --> 01:49:01,510
because we cannot separate them.

01:49:02,764 --> 01:49:03,597
- So how do you,

01:49:04,850 --> 01:49:06,800
so you have only one-- yeah.

01:49:06,800 --> 01:49:08,400
- Oh okay so--

01:49:08,400 --> 01:49:12,610
- We try to split them apart but because we have no real

01:49:12,610 --> 01:49:17,290
rules one can run concurrently because

01:49:17,290 --> 01:49:19,730
we do not have what you wanted want to

01:49:19,730 --> 01:49:22,720
do we ran into trouble

01:49:22,720 --> 01:49:25,990
- [Man] Yah so that wasn't in the next slide, yeah okay.

01:49:27,552 --> 01:49:30,520
- Do we still have the way of like when the trigger whoever

01:49:32,080 --> 01:49:36,830
raised it when we to save or re-enable, perhaps we execute

01:49:36,830 --> 01:49:38,277
at that moment?

01:49:38,277 --> 01:49:39,160
- It's basically the same what

01:49:39,160 --> 01:49:43,690
we do in mainline when if you look the part

01:49:43,690 --> 01:49:48,690
in half enable and no you're the one which is enabling it

01:49:49,220 --> 01:49:53,980
then we still handle it but on activity it's slightly

01:49:53,980 --> 01:49:58,010
differently we only handle those we raced ourselves

01:49:58,010 --> 01:49:58,843
in that section.

01:49:58,843 --> 01:50:01,910
- Right and we do it as that threat, whoever raised it does

01:50:01,910 --> 01:50:04,670
executes it, it's not done in any different context.

01:50:04,670 --> 01:50:06,550
- If the razor basically

01:50:08,620 --> 01:50:11,400
let's say do you have a friend submitting a network package

01:50:11,400 --> 01:50:16,400
and it raises net T axe then it executes it

01:50:16,730 --> 01:50:18,709
immediately when it drops the

01:50:18,709 --> 01:50:21,150
this re-enable spoken Huff's.

01:50:21,150 --> 01:50:22,430
- It's a nine execution.

01:50:22,430 --> 01:50:24,620
- Yeah that's what main line is

01:50:24,620 --> 01:50:27,290
doing as well but the difference is that

01:50:27,290 --> 01:50:29,660
on main line if--

01:50:29,660 --> 01:50:30,550
- They switch contacts--

01:50:30,550 --> 01:50:34,120
- A lot of shit is added during that time

01:50:34,120 --> 01:50:35,980
while you have partners disabled you

01:50:37,790 --> 01:50:39,660
do all of it

01:50:39,660 --> 01:50:42,780
which is so you do

01:50:42,780 --> 01:50:46,210
also the unrelated ones not only those which you

01:50:47,850 --> 01:50:51,090
kicked so the thing is,

01:50:51,090 --> 01:50:53,470
yes. - How I mean we do or

01:50:53,470 --> 01:50:55,070
so that's right we're thinking about getting him

01:50:55,070 --> 01:50:57,380
'cause I thought this was an idea of putting I mean this

01:50:57,380 --> 01:50:59,180
is even RT related it sounds like this

01:50:59,180 --> 01:51:01,020
actually to me it seems like a better

01:51:01,020 --> 01:51:02,730
solution than what's currently in mainline.

01:51:02,730 --> 01:51:06,110
- Yeah but he comes to that on his next slide.

01:51:08,160 --> 01:51:09,150
- So yeah that was maybe--

01:51:09,150 --> 01:51:12,397
- We would love to go back to that model but we can't right

01:51:12,397 --> 01:51:14,820
now until you finally--

01:51:15,920 --> 01:51:18,350
- I guess I'm here to try.

01:51:18,350 --> 01:51:19,331
- Do your job.

01:51:19,331 --> 01:51:20,164
(laughter)

01:51:20,164 --> 01:51:20,997
- Do my job.

01:51:20,997 --> 01:51:21,830
- Get your act together.

01:51:21,830 --> 01:51:23,100
(laughter)

01:51:23,100 --> 01:51:25,940
- So yeah that was actually my worry

01:51:25,940 --> 01:51:27,980
I was sitting

01:51:28,910 --> 01:51:33,130
yesterday evening in the dark and I was thinking about

01:51:33,130 --> 01:51:34,490
(laughter)

01:51:34,490 --> 01:51:39,210
what happens if what happens if the soft IRQ access

01:51:39,210 --> 01:51:40,340
per CPU values

01:51:42,180 --> 01:51:46,910
that's really only accessed locally and assumes that

01:51:48,040 --> 01:51:51,750
it, I mean there is no concurrency if

01:51:52,936 --> 01:51:54,780
the first CPU value is only accessed

01:51:54,780 --> 01:51:58,920
on by by a vector or whatever soft IRQ

01:51:58,920 --> 01:52:00,950
there is no concurrency we don't need

01:52:00,950 --> 01:52:01,783
any locking

01:52:03,990 --> 01:52:06,040
at least in mainline but if

01:52:06,040 --> 01:52:09,490
we were to have concurrent vectors that

01:52:09,490 --> 01:52:12,093
would be a problem I don't know if--

01:52:12,093 --> 01:52:13,870
- That's why we gave up on it.

01:52:13,870 --> 01:52:15,530
- Yeah exactly so that was my guess.

01:52:15,530 --> 01:52:20,000
- But with the fine granular control we can

01:52:20,000 --> 01:52:24,340
say hey I do only care about that

01:52:24,340 --> 01:52:26,770
particular one and I know nobody else

01:52:26,770 --> 01:52:29,160
touches data which is protected by this

01:52:31,150 --> 01:52:31,983
say that

01:52:33,300 --> 01:52:35,180
let's talk about it once you

01:52:35,180 --> 01:52:36,470
showed what you want to do.

01:52:36,470 --> 01:52:37,303
- Okay, okay.

01:52:38,400 --> 01:52:40,194
- He doesn't want to go to that next slide.

01:52:40,194 --> 01:52:41,030
(laughter)

01:52:41,030 --> 01:52:43,223
- Everything is on the next slide.

01:52:43,223 --> 01:52:44,750
(laughs)

01:52:44,750 --> 01:52:49,090
So it's yeah proposed solution so it's not to

01:52:49,090 --> 01:52:52,080
solve but to help RT and mainline.

01:52:53,090 --> 01:52:57,080
The idea is so this is yeah I think in case

01:52:57,080 --> 01:52:59,500
you missed it the soft IRQ perfect

01:52:59,500 --> 01:53:04,390
or masking you can even find an article on LWN about that

01:53:06,540 --> 01:53:11,540
so the goal is to allow soft IRQ disabled sections

01:53:11,670 --> 01:53:16,110
to be soft interruptible which means when you,

01:53:17,330 --> 01:53:20,860
when you disable a soft IRQs right now you disable all of

01:53:20,860 --> 01:53:23,590
them so now the point is to be able to

01:53:23,590 --> 01:53:26,290
disable just one vector or just one set

01:53:26,290 --> 01:53:29,220
of vectors and you want the other

01:53:29,220 --> 01:53:32,260
vectors to be able to

01:53:32,260 --> 01:53:36,500
interrupt the this soft IRQ disabled sections

01:53:36,500 --> 01:53:38,950
so of course this comes with a new set

01:53:38,950 --> 01:53:40,420
of APIs

01:53:42,770 --> 01:53:44,820
it's essentially declensions

01:53:44,820 --> 01:53:48,080
on top of the existing local BH disable

01:53:48,080 --> 01:53:52,280
and spin lock BH right lock BH read

01:53:52,280 --> 01:53:54,620
lock BH and all these APIs

01:53:56,170 --> 01:53:57,003
with

01:53:58,280 --> 01:54:02,210
underscore mask suffix and you can pass the

01:54:02,210 --> 01:54:04,140
vectors you want to disable

01:54:04,140 --> 01:54:06,700
so it returns to you the,

01:54:08,320 --> 01:54:11,800
yeah, previews mask exactly which will restore upon

01:54:11,800 --> 01:54:16,530
re-enablement so this disablement can stack

01:54:16,530 --> 01:54:20,130
they can nest and it's not pretty but

01:54:20,130 --> 01:54:22,790
it's more granular, right.

01:54:22,790 --> 01:54:26,500
- Yeah it makes a lot of sense even outside of RT because

01:54:26,500 --> 01:54:31,240
why do I care about some random task that if I'm networking

01:54:31,240 --> 01:54:33,460
and the other way around.

01:54:33,460 --> 01:54:34,400
I mean this--

01:54:36,340 --> 01:54:37,600
- It's a big kernel.

01:54:37,600 --> 01:54:40,920
- Yeah you care if there's sheer data but you should know

01:54:40,920 --> 01:54:42,010
that they do.

01:54:42,010 --> 01:54:44,490
- It's equivalent to the big kernel lock.

01:54:44,490 --> 01:54:47,730
- Should we know that they do, I mean there are so many

01:54:47,730 --> 01:54:48,563
vectors--

01:54:48,563 --> 01:54:52,820
- I mean right now you can't just tell but people should go

01:54:52,820 --> 01:54:57,820
and it's soft IRQ disable like preamp disable is--

01:55:00,030 --> 01:55:02,010
- A big hammer? - Big kernel lock

01:55:02,010 --> 01:55:03,740
on a CPU level.

01:55:04,960 --> 01:55:07,610
So and we all know how well

01:55:09,340 --> 01:55:11,890
semantically defines big kernel lock was.

01:55:13,380 --> 01:55:14,213
Not at all.

01:55:15,950 --> 01:55:19,300
Nobody knew what it was protecting but if you ripped it out

01:55:19,300 --> 01:55:20,490
things fell apart.

01:55:20,490 --> 01:55:21,323
- Yeah, yeah.

01:55:22,510 --> 01:55:24,660
Yeah and we had to cover it side by side.

01:55:24,660 --> 01:55:26,900
- It's own version of BKL.

01:55:29,470 --> 01:55:31,010
- [Man] And getting rid of the BKL, that took what,

01:55:31,010 --> 01:55:32,163
10 years? - Nobody knows what it

01:55:32,163 --> 01:55:32,996
protects.

01:55:32,996 --> 01:55:35,710
(laughter)

01:55:35,710 --> 01:55:36,860
- Like that's his luck.

01:55:38,174 --> 01:55:41,303
Sorry, no that was bad joke.

01:55:41,303 --> 01:55:46,303
Yeah. (laughs)

01:55:49,860 --> 01:55:53,630
But the problem is it might be a bit different than the

01:55:53,630 --> 01:55:55,250
big analog because

01:55:57,060 --> 01:56:01,280
maybe mainline doesn't suffer that much from these issues

01:56:01,280 --> 01:56:04,700
I mean we, do we have no symptoms--

01:56:04,700 --> 01:56:06,320
- Talk to the networking people.

01:56:06,320 --> 01:56:07,270
- Yeah, oh yeah.

01:56:08,210 --> 01:56:09,970
They actually like that patch.

01:56:09,970 --> 01:56:11,470
- Well, I mean right now 'cause networking,

01:56:11,470 --> 01:56:14,380
you're getting networking packets that are faster than a CPU

01:56:14,380 --> 01:56:17,160
that's coming in, that's processing it so that's exactly so

01:56:17,160 --> 01:56:18,580
that's where they're going to hit all the issues, that's

01:56:18,580 --> 01:56:20,490
exactly when the trigger is when the networking's come in so

01:56:20,490 --> 01:56:22,970
fast that it's just going to install the whole CPU and the

01:56:22,970 --> 01:56:25,460
whole thing's just basically live locks.

01:56:25,460 --> 01:56:28,400
- Yeah or it's coming so fast that the current

01:56:28,400 --> 01:56:29,580
implementation of subsonic

01:56:29,580 --> 01:56:31,180
use cannot keep up.

01:56:31,180 --> 01:56:32,420
- Well, no, no--

01:56:33,781 --> 01:56:37,900
- The problem is that once they, I mean if they do it

01:56:37,900 --> 01:56:40,560
on return for interrupt you get

01:56:40,560 --> 01:56:43,070
never anything else done because

01:56:43,070 --> 01:56:45,210
you're on return for interrupt.

01:56:45,210 --> 01:56:49,470
If they push it out to the thread it's perfectly fine

01:56:49,470 --> 01:56:52,480
for networking but then it breaks the other piece.

01:56:52,480 --> 01:56:54,830
- Yeah. - That's why you have this

01:56:55,990 --> 01:56:57,790
make my eyes bleed hack there.

01:57:00,130 --> 01:57:03,730
- But yeah so for mainline there would be a

01:57:03,730 --> 01:57:05,610
solution actually a straightforward

01:57:05,610 --> 01:57:08,390
solution for that it would be to have a

01:57:08,390 --> 01:57:12,410
case of IRQD pending mask which

01:57:12,410 --> 01:57:16,340
only takes all the vectors that need to be differed and the

01:57:16,340 --> 01:57:19,940
other one can execute before you reach the case of IRQD.

01:57:19,940 --> 01:57:21,920
- Yes but then

01:57:22,950 --> 01:57:27,950
what people wouldn't like to have is actually a way to

01:57:29,720 --> 01:57:34,610
go back to that model which we had earlier in RT that we had

01:57:34,610 --> 01:57:36,140
threads per vector.

01:57:36,140 --> 01:57:37,230
- Yeah.

01:57:37,230 --> 01:57:39,940
- Because that would help other use cases in mainline as

01:57:39,940 --> 01:57:44,940
well if you have block and net on the same CPU

01:57:45,160 --> 01:57:47,290
they get in each other way.

01:57:47,290 --> 01:57:48,880
- Yeah. - No matter what you do.

01:57:48,880 --> 01:57:51,190
- Yeah because I guess most of the time

01:57:51,190 --> 01:57:54,490
the timers and maybe RCU better--

01:57:54,490 --> 01:57:58,860
- Yeah RCU should go out of soft IRQ anyway.

01:57:58,860 --> 01:58:02,220
- But anyway most timers soft IRQs don't need to be

01:58:02,220 --> 01:58:07,220
offloaded I guess, for example, among other vectors so,

01:58:07,390 --> 01:58:12,390
but yeah that only partially solved the thing for RT because

01:58:12,800 --> 01:58:17,210
vectors with this model of

01:58:17,210 --> 01:58:22,210
fine granularity masking vectors are interrupted

01:58:22,370 --> 01:58:25,520
but they are not preempted, I mean a task cannot preempt

01:58:26,880 --> 01:58:28,260
soft IRQ vector, right?

01:58:29,100 --> 01:58:30,160
- On RT, yes.

01:58:30,160 --> 01:58:31,020
- On RT, yes.

01:58:32,400 --> 01:58:35,670
Yeah we would still need the hybrid solution with your

01:58:37,620 --> 01:58:38,860
soft IRQ threads.

01:58:38,860 --> 01:58:41,880
- Yeah but that's, I mean

01:58:41,880 --> 01:58:46,460
we just offloaded, full offloaded into threads and take the

01:58:46,460 --> 01:58:49,920
penalty for it but that's the price we pay for having

01:58:49,920 --> 01:58:51,850
deterministic behavior.

01:58:51,850 --> 01:58:54,910
We won't change that and it doesn't matter but

01:58:56,090 --> 01:58:58,710
if we break up things into more granular

01:58:59,800 --> 01:59:01,660
entities to protect and

01:59:02,930 --> 01:59:06,820
then it's generally good not only for RT,

01:59:06,820 --> 01:59:10,130
it's a general improvement and that's why I like that thing.

01:59:11,060 --> 01:59:13,920
- But I need a good selling argument for a mainline

01:59:13,920 --> 01:59:18,440
for that really because Linux doesn't let him convinced

01:59:18,440 --> 01:59:19,640
about that.

01:59:19,640 --> 01:59:21,970
- I think the interface we need to make a cleaner

01:59:21,970 --> 01:59:23,420
interface somehow 'cause I think that might

01:59:23,420 --> 01:59:24,253
be part of it.

01:59:24,253 --> 01:59:25,500
- Yeah, and we need to--

01:59:25,500 --> 01:59:27,160
- He actually suggested that interface.

01:59:27,160 --> 01:59:30,510
- Yeah this interface is not the problem, we need to find,

01:59:30,510 --> 01:59:32,800
demonstrate that it actually solves a

01:59:32,800 --> 01:59:34,730
real world problem. - Yeah exactly.

01:59:34,730 --> 01:59:36,050
- Can we talk to networking folks about it?

01:59:36,050 --> 01:59:38,720
- Yeah, we talk to the networking folks.

01:59:38,720 --> 01:59:40,910
- Also they seem to like the patch sets, so yeah.

01:59:40,910 --> 01:59:43,250
- Because they have used cases where they interfere with

01:59:43,250 --> 01:59:47,520
block and they can probably come up with a

01:59:47,520 --> 01:59:51,260
demonstration that it actually solves something and then it

01:59:51,260 --> 01:59:52,990
should be a no brainer.

01:59:55,000 --> 01:59:58,140
- Thomas, do you know who to talk to Eric or David?

01:59:59,629 --> 02:00:01,670
So talk to Eric, he's here so,

02:00:01,670 --> 02:00:04,720
make sure, see if we come up with a use case.

02:00:04,720 --> 02:00:05,553
- Okay.

02:00:09,180 --> 02:00:12,370
But yeah we also need to notice that it's a lot of long-term

02:00:12,370 --> 02:00:16,010
work but why not, indeed, if we have good

02:00:16,010 --> 02:00:19,540
compelling argument to integrate that on the main line

02:00:19,540 --> 02:00:23,620
so we have lots of API is to convert side by side just like

02:00:23,620 --> 02:00:25,570
we did for a big kernel lock.

02:00:29,219 --> 02:00:31,541
- At some point you have to bite the bullet.

02:00:31,541 --> 02:00:36,541
- Sure.

02:00:38,300 --> 02:00:41,160
- It's like we're not used to long term work I mean how old

02:00:41,160 --> 02:00:42,854
is the real-time patch?

02:00:42,854 --> 02:00:43,687
- Yeah.

02:00:43,687 --> 02:00:45,010
(laughs)

02:00:45,010 --> 02:00:48,300
But fortunately like that provides all the informations

02:00:48,300 --> 02:00:53,300
about which lock is taken or disables which vectors, so

02:00:53,880 --> 02:00:55,550
and the lock that support is

02:00:56,470 --> 02:00:59,910
quite a significant chunk on this patch set

02:00:59,910 --> 02:01:03,450
but really this only provides the runtime information.

02:01:03,450 --> 02:01:07,080
We don't have static informations about where our lock--

02:01:07,080 --> 02:01:09,150
- Yeah because you can't have--

02:01:10,880 --> 02:01:12,950
- You can't really follow the whole path.

02:01:12,950 --> 02:01:16,580
- Follow and figure out from static analysis whether

02:01:18,060 --> 02:01:20,930
some data is shared between two vectors or not.

02:01:20,930 --> 02:01:21,810
- Exactly.

02:01:21,810 --> 02:01:23,040
- But

02:01:23,040 --> 02:01:25,170
I mean we have had,

02:01:25,170 --> 02:01:27,800
basically had the same problem with the BKL.

02:01:27,800 --> 02:01:28,734
- Sure, yeah.

02:01:28,734 --> 02:01:32,100
- And we went there and looked at it from, on a case-by-case

02:01:32,100 --> 02:01:35,180
basis and it had the,

02:01:35,180 --> 02:01:39,220
had their main experts involved and had them clean their

02:01:39,220 --> 02:01:43,220
mind if you, if the network people find something which

02:01:43,220 --> 02:01:48,040
makes your, their life easier with that patches,

02:01:48,040 --> 02:01:50,970
they are going to clean up most of the ship because

02:01:50,970 --> 02:01:53,170
they are using it most.

02:01:54,070 --> 02:01:55,130
- I guess many--

02:01:56,730 --> 02:01:59,730
- If you find people who have a vetted interest in that then

02:02:00,780 --> 02:02:02,230
it's just going to happen.

02:02:02,230 --> 02:02:03,660
- Yeah right.

02:02:03,660 --> 02:02:07,380
I guess there's still some drivers that will never really be

02:02:07,380 --> 02:02:10,040
converted but it's not really important I guess.

02:02:10,040 --> 02:02:10,946
- No.

02:02:10,946 --> 02:02:11,820
- Yeah.

02:02:11,820 --> 02:02:14,920
- And those are probably pretty easy to understand what

02:02:14,920 --> 02:02:15,980
they're trying to do.

02:02:20,650 --> 02:02:22,200
- Yeah,

02:02:22,200 --> 02:02:24,720
one big drawback was that patch set is that it

02:02:25,650 --> 02:02:29,780
only makes soft IRQ disabled sections interruptible,

02:02:30,630 --> 02:02:33,950
soft interruptible but it doesn't make the vector execution

02:02:33,950 --> 02:02:38,120
soft interruptible, for that we need some more work because

02:02:40,740 --> 02:02:44,380
I guess we don't use spin lot BH, for example, in a vector

02:02:44,380 --> 02:02:45,213
handler.

02:02:47,300 --> 02:02:48,350
We use just pin lock,

02:02:49,230 --> 02:02:50,490
right? - Right.

02:02:50,490 --> 02:02:53,940
- And we would need like spin lock BH just to know that we

02:02:53,940 --> 02:02:55,400
only need to--

02:02:55,400 --> 02:02:57,230
- In the vector handler you already,

02:02:59,560 --> 02:03:02,650
no, you already have that vector protected.

02:03:05,130 --> 02:03:05,963
- Well.

02:03:06,830 --> 02:03:08,760
- Because you're executing the vector so it's masked.

02:03:08,760 --> 02:03:10,540
- You're executing the vector,

02:03:10,540 --> 02:03:12,750
yeah but very often you

02:03:12,750 --> 02:03:16,570
cannot enable every other vectors because many, many

02:03:16,570 --> 02:03:18,260
handlers are,

02:03:18,260 --> 02:03:20,350
many, many locks are shared

02:03:20,350 --> 02:03:22,180
among many other vectors.

02:03:23,250 --> 02:03:26,110
I've seen some cases in networking where some locks--

02:03:26,110 --> 02:03:28,140
- Yeah let the network people fix that.

02:03:29,870 --> 02:03:31,970
- Yeah but there are many cases to handle.

02:03:38,868 --> 02:03:41,430
- You have the thing that you run and you take the lock

02:03:41,430 --> 02:03:44,510
on in net RX and at some point you run into time out

02:03:44,510 --> 02:03:46,970
at which point you run the time out soft IRQ and then

02:03:46,970 --> 02:03:49,530
you grab the log but not very often.

02:03:51,860 --> 02:03:55,010
- Yeah but those are only a few cases so I

02:03:55,010 --> 02:03:58,600
talked to Eric about that earlier and he said that

02:03:58,600 --> 02:03:59,960
that should be fixable.

02:04:06,370 --> 02:04:08,780
So right now it's a tangled mess but it's,

02:04:09,660 --> 02:04:14,070
the points where it's tangled it's, they are well defined so

02:04:14,070 --> 02:04:16,830
you can actually rip that apart

02:04:17,930 --> 02:04:20,600
and figure out how to solve that.

02:04:21,970 --> 02:04:24,860
So it's not that that there are too many cases where the

02:04:24,860 --> 02:04:26,840
timer actually interferes with

02:04:28,120 --> 02:04:29,140
networking data.

02:04:30,710 --> 02:04:34,310
They don't have so many places where they have the timers.

02:04:34,310 --> 02:04:35,770
- On the circuit code a lot.

02:04:36,830 --> 02:04:37,663
- Pardon?

02:04:37,663 --> 02:04:38,550
- On the circuit code.

02:04:38,550 --> 02:04:39,800
- Yeah but they have--

02:04:40,720 --> 02:04:42,060
- But it's probably very localized.

02:04:42,060 --> 02:04:45,060
- It's very localized and very well structured so they can't

02:04:45,920 --> 02:04:47,580
probably fix it at one spot.

02:04:48,680 --> 02:04:50,570
- I mean we can check that with log that

02:04:50,570 --> 02:04:53,690
check all the logs that are shared among

02:04:53,690 --> 02:04:56,010
many vectors, I need to check that maybe

02:04:56,010 --> 02:04:57,750
that would be interesting.

02:04:57,750 --> 02:04:59,520
Maybe we only find a

02:04:59,520 --> 02:05:01,670
handful of logs after all, yeah.

02:05:03,450 --> 02:05:06,040
Okay so think we

02:05:07,050 --> 02:05:08,969
answered some questions here.

02:05:08,969 --> 02:05:09,990
(laughs)

02:05:09,990 --> 02:05:10,960
So yeah that's all.

02:05:12,210 --> 02:05:13,680
Unless anyone has a question?

02:05:16,060 --> 02:05:18,050
- When do you think you'll have this done?

02:05:18,050 --> 02:05:18,883
- What?

02:05:18,883 --> 02:05:20,890
- when do you think you'll have this finished?

02:05:23,040 --> 02:05:25,730
- I mean it's mostly actually

02:05:25,730 --> 02:05:26,790
pretty much finished.

02:05:28,060 --> 02:05:30,990
I mean just the bulk core code of it

02:05:30,990 --> 02:05:33,360
but if we want to

02:05:33,360 --> 02:05:36,520
convert every side for the API,

02:05:37,854 --> 02:05:39,730
that's going to take years. - As I said before talk to

02:05:39,730 --> 02:05:42,920
Eric about it and find a use case which actually has

02:05:42,920 --> 02:05:43,820
benefits and then.

02:05:45,790 --> 02:05:47,670
- That's for setting the core part, yeah.

02:05:47,670 --> 02:05:48,503
- Yeah and then

02:05:52,070 --> 02:05:52,903
work from there.

02:05:52,903 --> 02:05:53,990
- Yeah. - Yeah if you could show an

02:05:53,990 --> 02:05:56,200
example with and without it and you could see a clear

02:05:56,200 --> 02:05:58,500
advantage with it, Linux would take it.

02:05:58,500 --> 02:05:59,690
- Yeah, yeah I guess so.

02:05:59,690 --> 02:06:02,340
- If networking people love it then he'll take it.

02:06:02,340 --> 02:06:03,190
- Yeah. - Twice.

02:06:04,420 --> 02:06:06,710
- Well David Miller already acted so.

02:06:06,710 --> 02:06:07,980
- Yeah, yeah sure but,

02:06:07,980 --> 02:06:11,880
sure but now the only thing is and you need dear help

02:06:13,010 --> 02:06:15,420
to come up with a use case where it actually shows a

02:06:15,420 --> 02:06:16,270
benefit. - Sure.

02:06:18,330 --> 02:06:20,630
Because that's quite a piece of

02:06:20,630 --> 02:06:22,220
core code modifications.

02:06:22,220 --> 02:06:24,340
Yeah, yeah, yeah. - Yeah sure.

02:06:24,340 --> 02:06:25,173
All right.

02:06:26,809 --> 02:06:29,059
(applause)

02:06:40,374 --> 02:06:41,364
(laughter)

02:06:41,364 --> 02:06:43,281
It's going to be short.

02:07:35,110 --> 02:07:37,430
But this one is going to be very short, just like two

02:07:37,430 --> 02:07:40,407
slides so, actually three with this one.

02:07:43,370 --> 02:07:44,720
Yeah about full dyntiks

02:07:46,050 --> 02:07:47,900
isolation just a

02:07:47,900 --> 02:07:49,130
very small roadmap

02:07:50,340 --> 02:07:52,490
about the things I need to do

02:07:52,490 --> 02:07:54,680
there is a

02:07:54,680 --> 02:07:56,290
CPU stat freeze

02:07:56,290 --> 02:07:57,880
so that when you,

02:07:57,880 --> 02:08:01,080
when you isolate a CPU and disable the tick on it

02:08:02,420 --> 02:08:04,960
the CPU stat is not going to move forward.

02:08:04,960 --> 02:08:07,490
I mean it's going to move forward for the

02:08:07,490 --> 02:08:09,340
task statistics

02:08:09,340 --> 02:08:11,790
but not for a proc stat for

02:08:12,820 --> 02:08:16,350
every CPUs so the user and system

02:08:16,350 --> 02:08:20,150
and guest fields are not evolving so I need to,

02:08:20,150 --> 02:08:23,430
just need to fix that I had a patch set, I just need to

02:08:23,430 --> 02:08:24,830
rethink it a little bit more

02:08:25,730 --> 02:08:30,730
and especially now that the tasks can have an RCU,

02:08:31,000 --> 02:08:35,590
appropriate RCU life cycles thanks to some recent patch

02:08:35,590 --> 02:08:38,140
I can resurrect that patch that.

02:08:39,400 --> 02:08:42,650
I also need to clean up the code in tick sched a bit more

02:08:42,650 --> 02:08:45,370
because I think it's not that great.

02:08:45,370 --> 02:08:46,203
I mean,

02:08:50,320 --> 02:08:52,840
I mean we essentially patched the whole

02:08:54,500 --> 02:08:58,630
full dynticks code on top of idle dynticks code and it's not

02:08:58,630 --> 02:09:01,410
that pretty right now I guess I just need to

02:09:01,410 --> 02:09:03,140
revisit a bit that

02:09:03,140 --> 02:09:05,900
and rethink on text tracking because it's

02:09:05,900 --> 02:09:10,570
based on that TIF no Hertz flag which is

02:09:10,570 --> 02:09:15,570
kind of weird I guess we need something like per CPU switch

02:09:16,360 --> 02:09:20,650
maybe reuse some slow path Cisco slow pass thing.

02:09:20,650 --> 02:09:22,850
Anyway that's lots of technical

02:09:22,850 --> 02:09:24,900
thing, boring

02:09:24,900 --> 02:09:28,660
and of course make no Hertz full mutable through CPU sets

02:09:28,660 --> 02:09:31,310
which I say that every year for like

02:09:32,481 --> 02:09:35,220
at least six years and I still haven't do it

02:09:35,220 --> 02:09:36,053
but

02:09:37,120 --> 02:09:40,460
yeah I keep being sidetracked but it's going to happen

02:09:40,460 --> 02:09:41,620
one day eventually

02:09:43,360 --> 02:09:46,100
but what I wanted to know is

02:09:47,520 --> 02:09:51,920
what do you need for full dynticks and isolation on RT

02:09:51,920 --> 02:09:54,900
because I actually don't know anything about what you're

02:09:54,900 --> 02:09:59,640
doing there I know you have some specific code for that

02:09:59,640 --> 02:10:02,250
I don't know if you have needs specific.

02:10:03,200 --> 02:10:04,510
No?

02:10:04,510 --> 02:10:08,430
- I mean I know that there are people out there using

02:10:08,430 --> 02:10:11,650
full dynticks isolation in order to stay in a

02:10:12,500 --> 02:10:15,040
polling loop on their PCI device

02:10:15,040 --> 02:10:16,610
in user space forever.

02:10:16,610 --> 02:10:18,190
- That's real isolation yeah.

02:10:19,350 --> 02:10:22,510
- So they just waste CPU cycles because they claim

02:10:22,510 --> 02:10:25,040
that they can't afford taking the interrupt.

02:10:25,040 --> 02:10:28,674
- [Man] Yeah and there are people using virtual machines.

02:10:28,674 --> 02:10:30,380
- Virtual machines, oh yeah.

02:10:30,380 --> 02:10:33,420
- [Man] They have the real-time kernel isolated CPU.

02:10:33,420 --> 02:10:34,690
- Watch the speaker.

02:10:34,690 --> 02:10:37,370
- Yeah, they have the real-time IE company

02:10:38,590 --> 02:10:40,170
has the real-time kernel

02:10:40,170 --> 02:10:42,290
and then they have a virtual machine

02:10:42,290 --> 02:10:44,710
and they pin one CPU to the VCPU

02:10:45,640 --> 02:10:48,060
and try to run a pooling thing inside

02:10:48,060 --> 02:10:50,390
and they want to get as less in

02:10:50,390 --> 02:10:53,280
interference as possible and that's one

02:10:53,280 --> 02:10:54,850
case for the full dynamic.

02:10:54,850 --> 02:10:57,350
- [Man] They want the hosts not to tick essentially.

02:10:57,350 --> 02:10:58,810
- The host and the virtual machine.

02:10:58,810 --> 02:11:01,170
- [Man] And the virtual machine, yeah, both of them.

02:11:02,772 --> 02:11:05,650
- Is there any special thing to do for getting,

02:11:05,650 --> 02:11:08,360
I thought, like, you still have that four second tick now

02:11:08,360 --> 02:11:09,820
or is it, did you get rid of all of it?

02:11:09,820 --> 02:11:11,310
- It's actually offloaded to

02:11:11,310 --> 02:11:13,850
housekeeping set of CPUs,

02:11:13,850 --> 02:11:15,320
mostly CPU zero but--

02:11:15,320 --> 02:11:18,010
- I've been running this

02:11:18,010 --> 02:11:21,700
to show it and I still use it as my example in kernel shark

02:11:21,700 --> 02:11:25,190
to run tracing on it, I put in the user spin, have all the

02:11:25,190 --> 02:11:26,980
isolation maybe I'm doing something, I'm doing everything

02:11:26,980 --> 02:11:29,350
isolation, every, and you see a little tick

02:11:29,350 --> 02:11:30,330
every four seconds.

02:11:32,480 --> 02:11:35,450
- Watch dog, I think it's the timer watch dog.

02:11:35,450 --> 02:11:37,340
- That might be the timer watch dog.

02:11:37,340 --> 02:11:40,120
- Oh, okay so I have to turn off the watch dog then.

02:11:40,120 --> 02:11:41,810
- The TSC watch dog.

02:11:45,341 --> 02:11:47,600
- [Man] There's internal common line that disables it.

02:11:47,600 --> 02:11:50,240
- TSC equals reliable, you're lying but.

02:11:51,910 --> 02:11:53,060
- TSC equals reliable.

02:11:54,210 --> 02:11:56,000
- I think it's a black magic

02:11:56,000 --> 02:11:59,930
but if you write TSC equal reliable on the--

02:11:59,930 --> 02:12:02,140
- Yeah we also added the disable,

02:12:02,140 --> 02:12:05,700
I mean TSC no--

02:12:05,700 --> 02:12:06,640
- [Man] Yeah there is something else,

02:12:06,640 --> 02:12:08,040
it's just the TSC reliable.

02:12:08,040 --> 02:12:09,580
- You can just disabled the--

02:12:09,580 --> 02:12:10,690
- [Man] Stable, just disable?

02:12:10,690 --> 02:12:12,380
- Yes stable something, yeah.

02:12:12,380 --> 02:12:14,660
- There's some option where you can disable that,

02:12:14,660 --> 02:12:17,250
you lie still but.

02:12:17,250 --> 02:12:19,270
- Of course it's unsafe because

02:12:19,270 --> 02:12:21,460
you don't have any more TSC guarantee.

02:12:21,460 --> 02:12:24,290
- No, actually to be honest,

02:12:25,180 --> 02:12:27,590
much better with the TSC,

02:12:27,590 --> 02:12:30,100
so it only took 20 years of pitching

02:12:32,175 --> 02:12:34,620
but there are still cases where

02:12:34,620 --> 02:12:38,320
we actually can't trust it and that's

02:12:39,659 --> 02:12:40,492
if your CPU is,

02:12:42,309 --> 02:12:44,500
if you have a single socket system

02:12:44,500 --> 02:12:48,230
and your CPU has the TSC at rest register

02:12:48,230 --> 02:12:49,450
you're pretty much good.

02:12:50,510 --> 02:12:52,830
If you have two circuits it

02:12:52,830 --> 02:12:53,840
kind of works

02:12:54,920 --> 02:12:57,360
most of the time if the,

02:12:58,270 --> 02:13:00,390
only if the

02:13:00,390 --> 02:13:03,170
main book manufacturer and the buyer's writers didn't screw

02:13:03,170 --> 02:13:04,040
up completely

02:13:05,258 --> 02:13:06,091
and

02:13:07,750 --> 02:13:09,950
about two sockets,

02:13:09,950 --> 02:13:13,000
all bets are gone so that's the state

02:13:13,890 --> 02:13:15,540
so on your machine you can do it.

02:13:16,480 --> 02:13:17,313
- Oh okay.

02:13:18,290 --> 02:13:21,580
- Basically if you put your machine without these options

02:13:21,580 --> 02:13:24,810
and run your workload and you don't get TSC warnings,

02:13:24,810 --> 02:13:27,880
it's a fair bet to say that you can use this option

02:13:27,880 --> 02:13:29,470
without too much headaches.

02:13:30,350 --> 02:13:31,760
- Even on virtual machines?

02:13:35,255 --> 02:13:37,450
(laughter)

02:13:37,450 --> 02:13:40,380
- The best option is to just never use a virtual machine.

02:13:43,410 --> 02:13:47,100
- I mean if the host is reliable then the guest is

02:13:47,100 --> 02:13:48,590
reliable as well.

02:13:48,590 --> 02:13:50,643
- [Man] You see, there is a way.

02:13:50,643 --> 02:13:51,476
(laughter)

02:13:51,476 --> 02:13:54,400
- If the hypervisor doesn't screw up with the

02:13:55,810 --> 02:13:56,990
guest TSC.

02:13:56,990 --> 02:13:58,970
- [Man] So relying the host is enough to

02:13:58,970 --> 02:14:02,650
rely on the virtual machine.

02:14:02,650 --> 02:14:04,130
- If you trust.

02:14:04,130 --> 02:14:06,160
- [Man] Oh good, no that's already good.

02:14:06,160 --> 02:14:09,920
- But it could feed that information in from the guest,

02:14:09,920 --> 02:14:13,780
through a CPU ID.

02:14:13,780 --> 02:14:16,780
You could actually tell the guests that you're

02:14:16,780 --> 02:14:17,860
doing great.

02:14:17,860 --> 02:14:22,460
- Okay, no, perfect, no that works for us.

02:14:22,460 --> 02:14:24,530
Thanks.

02:14:26,740 --> 02:14:28,960
- This is actually one of the user spins that are using

02:14:28,960 --> 02:14:31,023
our user spin with the full hertz.

02:14:37,827 --> 02:14:40,440
CPU two and three are isolated,

02:14:40,440 --> 02:14:43,080
CPU twos run the user spin and this is all the interrupts

02:14:43,080 --> 02:14:44,460
that I have,

02:14:44,460 --> 02:14:46,970
so, but this one I think I had IRQs running on this one.

02:14:46,970 --> 02:14:50,290
I forgot to isolate the IRQs, there's one, I think they run

02:14:50,290 --> 02:14:51,590
but there was another one.

02:14:53,250 --> 02:14:55,550
- You see the context tracking exit on every--

02:14:59,757 --> 02:15:00,590
- Oh here it is.

02:15:08,360 --> 02:15:10,680
- Are we secure, oh yeah we still have that.

02:15:12,120 --> 02:15:15,730
Yeah we had that project from some guy who wanted to kill

02:15:15,730 --> 02:15:18,590
when we have any single disturbance,

02:15:18,590 --> 02:15:20,730
still have no news about that.

02:15:20,730 --> 02:15:23,010
- It looks quite pretty now it's,

02:15:23,010 --> 02:15:25,920
this is with a, I moved IRQs off so I have to probably take

02:15:25,920 --> 02:15:27,280
a look at

02:15:27,280 --> 02:15:29,130
what was going on, it like, has a little tick and then

02:15:29,130 --> 02:15:32,430
boom, tick, that CPU two is the one with the user spin

02:15:32,430 --> 02:15:34,200
running and that's--

02:15:34,200 --> 02:15:35,670
- Yeah and what's the tick doing?

02:15:35,670 --> 02:15:36,503
- Yeah.

02:15:37,790 --> 02:15:39,660
- That's the more interesting question.

02:15:39,660 --> 02:15:43,820
- If you have like timers, evens.

02:15:49,220 --> 02:15:50,670
- V time user exit.

02:15:50,670 --> 02:15:52,460
- Yeah but it happens on every...

02:16:02,550 --> 02:16:05,550
Later, it's a high resolution timer.

02:16:08,700 --> 02:16:09,533
Go below.

02:16:10,381 --> 02:16:12,264
- Which timer does it expire

02:16:12,264 --> 02:16:15,287
and which function does it call?

02:16:15,287 --> 02:16:17,641
- Below, below, below, below.

02:16:17,641 --> 02:16:18,600
- Further down.

02:16:18,600 --> 02:16:20,100
- [Man] We need a pointy hair boss thing.

02:16:20,100 --> 02:16:22,330
- Click it, click it. - Below, below, below.

02:16:22,330 --> 02:16:23,810
- Yeah. - Wait, that's zero.

02:16:23,810 --> 02:16:25,317
I'm looking for two, let me filter.

02:16:25,317 --> 02:16:27,554
- Oh it's--

02:16:27,554 --> 02:16:30,100
- Yeah but it's to run and--

02:16:30,100 --> 02:16:33,020
- Yeah that probably then

02:16:33,020 --> 02:16:35,980
raises the

02:16:35,980 --> 02:16:38,630
timer soft IRQ which then does the other thing, yeah.

02:16:40,105 --> 02:16:42,710
- And if you go later to the soft IRQ processing maybe you

02:16:42,710 --> 02:16:43,543
will see the--

02:16:43,543 --> 02:16:44,590
- Yeah, you should see it.

02:16:44,590 --> 02:16:47,330
- Soft IRQ rise here, action timer.

02:16:47,330 --> 02:16:48,380
- Yeah but-- - Yeah but

02:16:48,380 --> 02:16:51,780
which handler and soft IRQ processing later.

02:16:51,780 --> 02:16:56,360
- So we're blaming soft IRQs is what you're saying.

02:16:56,360 --> 02:16:58,610
It's his fault. - Yeah, it's my fault again.

02:16:59,550 --> 02:17:01,350
- Let's see, I'm trying to find the,

02:17:02,479 --> 02:17:04,579
I should probably just filter off CPU two.

02:17:05,530 --> 02:17:06,363
Refilter.

02:17:06,363 --> 02:17:07,980
- Yeah, it's right after IRQ exit.

02:17:11,430 --> 02:17:13,710
- So now case soft IRQD runs.

02:17:15,280 --> 02:17:17,010
- Yeah okay.

02:17:17,010 --> 02:17:18,700
Actually it's going to be delayed.

02:17:19,670 --> 02:17:22,060
- No, no, no, no, no but you should see it inside of

02:17:22,060 --> 02:17:23,390
case soft IRQD. - Yeah.

02:17:37,660 --> 02:17:39,410
- No, it actually was a stray tick.

02:17:48,095 --> 02:17:49,990
- You need to go to the

02:17:49,990 --> 02:17:51,650
case soft IRQD right after.

02:17:53,230 --> 02:17:55,700
- Just try again.

02:17:55,700 --> 02:17:58,530
(laughter)

02:17:58,530 --> 02:17:59,530
It's all fixed now.

02:18:01,380 --> 02:18:03,130
- Case veteran stuff, you're the...

02:18:06,620 --> 02:18:07,570
Run case soft IRQD.

02:18:08,677 --> 02:18:10,010
- There's a little tick here, it's always like a

02:18:10,010 --> 02:18:11,080
little tick here.

02:18:11,080 --> 02:18:13,980
- Yeah, yeah but it's because there is a timer in queue.

02:18:15,565 --> 02:18:18,110
And we need to know which one and it's on

02:18:18,110 --> 02:18:19,660
case soft IRQD processing.

02:18:19,660 --> 02:18:21,710
- You need to have the callback function.

02:18:28,291 --> 02:18:29,670
- There's a lot of things going on here.

02:18:29,670 --> 02:18:32,460
- There is a lot of thing going on.

02:18:32,460 --> 02:18:35,350
- I think there's nothing special about RT in that report.

02:18:35,350 --> 02:18:37,150
- No, no, I think it's--

02:18:37,150 --> 02:18:38,630
- I mean-- - I'm pretty sure--

02:18:38,630 --> 02:18:40,900
- It's still the same thing you have to find the stupid

02:18:40,900 --> 02:18:43,940
timer which fires and figure out why.

02:18:43,940 --> 02:18:47,000
- If it's every five seconds, I'm pretty sure this is the

02:18:47,000 --> 02:18:49,020
watch dog, it could be the watch dog

02:18:51,590 --> 02:18:54,730
hard low cap watch dog or it could be that you see

02:18:54,730 --> 02:18:58,400
thing it's yeah but four seconds

02:18:58,400 --> 02:19:00,610
it's always the same thing, I remember that.

02:19:04,300 --> 02:19:05,133
Anyway.

02:19:09,180 --> 02:19:10,510
- Yeah, four seconds exactly.

02:19:10,510 --> 02:19:11,343
- Yeah.

02:19:11,343 --> 02:19:14,280
- Yeah then it's one of the watch dogs.

02:19:14,280 --> 02:19:15,480
- One of the watch dogs.

02:19:18,620 --> 02:19:20,044
- You can disable that.

02:19:20,044 --> 02:19:20,877
- Yeah.

02:19:22,179 --> 02:19:24,011
That's it.

02:19:24,011 --> 02:19:24,990
Yeah?

02:19:24,990 --> 02:19:26,590
- On your, the previous slide,

02:19:26,590 --> 02:19:29,840
the four thing where you want to,

02:19:29,840 --> 02:19:32,220
yeah, make the isolation CPU

02:19:32,220 --> 02:19:33,260
the name through CPU set.

02:19:33,260 --> 02:19:35,900
I remember there is also an RCU

02:19:35,900 --> 02:19:38,760
relation with the callbacks, is that true?

02:19:39,670 --> 02:19:40,730
- The RCU,

02:19:41,950 --> 02:19:43,020
the callback offloading?

02:19:43,020 --> 02:19:43,940
- Yeah.

02:19:43,940 --> 02:19:47,050
- I think it's a pretty well handled right now, yeah.

02:19:47,050 --> 02:19:50,570
- So there is can be dynamic already, or?

02:19:50,570 --> 02:19:51,610
- It's dynamic, yeah, yeah.

02:19:51,610 --> 02:19:52,690
I think it's,

02:19:52,690 --> 02:19:54,380
it follows the no Hertz full

02:19:55,585 --> 02:19:57,210
set of CPUs.

02:19:57,210 --> 02:19:58,960
So it's completely transparent.

02:19:58,960 --> 02:19:59,793
- Okay.

02:19:59,793 --> 02:20:00,626
- Yeah, yeah.

02:20:04,060 --> 02:20:07,160
Yeah Paul solves things much faster than me, yeah.

02:20:11,950 --> 02:20:16,529
- [Man] No more questions?

02:20:16,529 --> 02:20:18,779
(applause)

02:20:23,472 --> 02:20:25,889
- So we have 15 minutes more.

02:20:28,285 --> 02:20:31,413
Well 15 minutes between here and the next talk.

02:20:31,413 --> 02:20:33,840
But might be the case that next talk might take more

02:20:33,840 --> 02:20:35,592
than 30 minutes.

02:20:35,592 --> 02:20:36,644
- I don't think so.

02:20:36,644 --> 02:20:38,948
- No, so what do you guys think,

02:20:38,948 --> 02:20:41,913
should we wait for these 15 minutes to--

02:20:41,913 --> 02:20:43,456
- No, we just throw it

02:20:43,456 --> 02:20:45,373
and then throw it into

02:20:45,373 --> 02:20:47,800
random discussion session at the end.

02:20:47,800 --> 02:20:49,990
- Yeah and then anyone that's expected to see this on time,

02:20:49,990 --> 02:20:52,366
to come in, too bad they should have been for Frederick's.

02:20:52,366 --> 02:20:53,199
- Okay.

02:20:53,199 --> 02:20:55,282
(laughs)

02:20:56,630 --> 02:20:59,040
- It's recorded, they go watch it later.

02:20:59,040 --> 02:20:59,873
- Yeah, yeah.

02:21:35,510 --> 02:21:39,200
- Just a few words about where we are.

02:21:39,200 --> 02:21:41,170
Most of you might have noticed that

02:21:43,040 --> 02:21:46,000
there was finally a decision made by

02:21:47,460 --> 02:21:48,870
emperor penguin.

02:21:51,240 --> 02:21:52,660
So he pulled the

02:21:55,430 --> 02:21:58,670
bits and pieces which actually bring in the convict preempt

02:21:58,670 --> 02:22:02,140
RTs which, into the main line, which is not functional yet

02:22:03,410 --> 02:22:04,243
but

02:22:05,220 --> 02:22:09,670
it allows us to add all the dependent code with which

02:22:09,670 --> 02:22:13,460
makes use of that convict switch so he basically declared

02:22:15,190 --> 02:22:18,750
finally that RT should be an

02:22:18,750 --> 02:22:21,300
first clas mainline citizen.

02:22:21,300 --> 02:22:23,598
I'm pretty happy about that state.

02:22:23,598 --> 02:22:25,848
(applause)

02:22:30,490 --> 02:22:31,910
At only 15 years now.

02:22:33,360 --> 02:22:34,360
Almost exactly.

02:22:35,520 --> 02:22:40,520
15 years ago in September 2004, the big debate started on

02:22:41,590 --> 02:22:44,280
alchemy on one of the greatest flame wars ever

02:22:46,830 --> 02:22:49,700
and I personally was looking into that for 20 years so,

02:22:49,700 --> 02:22:51,260
1999 I started

02:22:52,960 --> 02:22:56,050
looking at the options and I hated most of them.

02:22:58,740 --> 02:23:00,700
Yeah well what's still

02:23:01,770 --> 02:23:05,160
missing, what we need to do is we

02:23:05,160 --> 02:23:09,960
made big progress on the lost outstanding large cleanup

02:23:12,390 --> 02:23:14,980
thing we had to do which is print K.

02:23:16,810 --> 02:23:20,490
So it's one of these code thing which

02:23:21,910 --> 02:23:26,850
are held together by duct tape and once you throw RT at it,

02:23:26,850 --> 02:23:28,160
the duct tape comes apart.

02:23:31,150 --> 02:23:33,410
So we had a really productive

02:23:36,050 --> 02:23:39,860
ad hoc buff yesterday with a couple of people in the room

02:23:39,860 --> 02:23:42,040
including Linus and we agreed on

02:23:42,920 --> 02:23:44,650
how this should be,

02:23:44,650 --> 02:23:47,410
how this should look like and

02:23:47,410 --> 02:23:48,390
we're actually,

02:23:51,490 --> 02:23:56,130
basically those who have seen John's talk, it's roughly the

02:23:56,130 --> 02:23:57,730
idea will be what

02:23:58,780 --> 02:24:00,770
print K will be in the future.

02:24:01,870 --> 02:24:05,420
It should be usable from any context and it should be less

02:24:05,420 --> 02:24:08,230
annoying for other reasons.

02:24:08,230 --> 02:24:12,310
There are still a few details to be hashed out on the

02:24:12,310 --> 02:24:15,320
implementation level but the conceptual level is agreed on

02:24:15,320 --> 02:24:16,860
which is progress.

02:24:18,160 --> 02:24:19,410
So other than that

02:24:20,930 --> 02:24:24,130
we have a

02:24:24,130 --> 02:24:27,090
few bits and pieces here, a few bits and pieces there

02:24:27,090 --> 02:24:29,630
we have some discussions to resolve where

02:24:29,630 --> 02:24:33,220
people don't like us to change their previous code because

02:24:33,220 --> 02:24:35,750
it's optimized for

02:24:36,610 --> 02:24:39,680
performance which doesn't even matter

02:24:39,680 --> 02:24:43,040
because that code is only cold in the slow pass

02:24:43,040 --> 02:24:44,600
once in a week, so,

02:24:45,470 --> 02:24:48,150
but I mean you know people care about their

02:24:49,710 --> 02:24:50,543
sand pits.

02:24:51,810 --> 02:24:54,100
We will eventually get that solved,

02:24:54,100 --> 02:24:57,130
I don't think it's any fundamental issue anymore.

02:24:58,150 --> 02:25:02,570
So but definitely having the convict switch in

02:25:02,570 --> 02:25:04,710
Linus three is helpful because there was

02:25:06,010 --> 02:25:08,780
a row of arguments starting where people said,

02:25:09,640 --> 02:25:12,010
I don't want to change this

02:25:12,010 --> 02:25:15,770
because I'm not sure whether RT actually goes mainline or

02:25:15,770 --> 02:25:19,590
not and if it doesn't then I have changed it for nothing and

02:25:21,320 --> 02:25:22,920
okay we can settle that

02:25:24,810 --> 02:25:25,860
discussion right now.

02:25:27,820 --> 02:25:29,610
So what else,

02:25:29,610 --> 02:25:31,250
yeah we're going to

02:25:31,250 --> 02:25:34,030
bring in the bits and pieces as

02:25:34,030 --> 02:25:36,100
it goes as we might progress

02:25:36,100 --> 02:25:40,380
but I expect a big chunk as early as,

02:25:40,380 --> 02:25:43,260
quite some stuff queued for

02:25:44,970 --> 02:25:46,280
five four already.

02:25:48,540 --> 02:25:52,640
Which takes out a significant amount of stuff from the

02:25:52,640 --> 02:25:53,540
RT patch set.

02:25:57,050 --> 02:26:00,200
I expect a real bigger chunk to land

02:26:01,450 --> 02:26:03,690
with the print case stuff which we hopefully

02:26:03,690 --> 02:26:05,070
resolve for five five.

02:26:12,280 --> 02:26:13,900
I'd rather throw this one.

02:26:13,900 --> 02:26:17,400
- I'm not catching that one, I'm duckin'.

02:26:17,400 --> 02:26:20,310
Especially if you throw it.

02:26:21,690 --> 02:26:23,050
So a miniature shark Mike.

02:26:24,710 --> 02:26:28,160
When would you expect us to be able to build a

02:26:29,640 --> 02:26:32,990
usable RT from a mainline clone?

02:26:34,860 --> 02:26:36,910
- If everything goes good, five five.

02:26:36,910 --> 02:26:38,290
- Five five, okay.

02:26:38,290 --> 02:26:39,930
- But you know. - Yeah.

02:26:39,930 --> 02:26:40,763
- It's not--

02:26:43,348 --> 02:26:45,044
(laughter)

02:26:45,044 --> 02:26:47,440
- I hate to say it but I think they were gated on us.

02:26:51,140 --> 02:26:53,030
- A discussion brought up

02:26:53,030 --> 02:26:57,280
something interesting yesterday which will actually make the

02:26:59,490 --> 02:27:02,660
year of the Linux desktop happen because,

02:27:02,660 --> 02:27:06,330
so Daniel Vetter came up with brilliant idea how to get a

02:27:06,330 --> 02:27:07,720
blue screen of death.

02:27:07,720 --> 02:27:08,620
- All right.

02:27:08,620 --> 02:27:10,950
- And then we are finally up to the task to be

02:27:10,950 --> 02:27:11,783
on the desktop.

02:27:14,050 --> 02:27:15,670
- Yeah we weren't useful

02:27:15,670 --> 02:27:17,120
like that other operating system.

02:27:17,120 --> 02:27:17,953
- Right. - 'Cause we didn't have

02:27:17,953 --> 02:27:18,786
a blue screen. - No.

02:27:18,786 --> 02:27:20,440
- That other operating system now wants to use

02:27:20,440 --> 02:27:23,190
us and now we can because they, we've hit the one

02:27:23,190 --> 02:27:24,769
requirement that they have. - You can use us because

02:27:24,769 --> 02:27:26,113
we now have a BSOD.

02:27:26,113 --> 02:27:26,946
- Yeah.

02:27:28,560 --> 02:27:30,970
So we just have to

02:27:30,970 --> 02:27:34,340
have that two years long discussion about the colors.

02:27:35,656 --> 02:27:37,138
(laughter)

02:27:37,138 --> 02:27:38,460
- Is it gonna be red or blue?

02:27:40,149 --> 02:27:40,982
- Blue on blue.

02:27:43,590 --> 02:27:45,550
- I have a weird question,

02:27:45,550 --> 02:27:47,590
what do you expect the

02:27:48,900 --> 02:27:52,780
new mainline kernel with the RT bits on it be

02:27:52,780 --> 02:27:55,410
when compiled without the RT bits

02:27:55,410 --> 02:27:59,210
and should it be exactly like upstream right now or

02:27:59,210 --> 02:28:00,043
should it--

02:28:00,043 --> 02:28:01,170
- It won't be any different.

02:28:02,380 --> 02:28:05,880
I mean it has to work in the same way as it worked before.

02:28:07,120 --> 02:28:11,490
I mean except for the stuff we changed over time anyway but

02:28:11,490 --> 02:28:14,720
everybody is happy with that.

02:28:14,720 --> 02:28:17,050
- We've been doing this for years

02:28:17,050 --> 02:28:19,350
and the kernel, actually I would say the kernel

02:28:19,350 --> 02:28:20,970
would be better.

02:28:20,970 --> 02:28:23,070
- Yes, I have this feeling but

02:28:24,500 --> 02:28:26,230
my question is a little bit broader

02:28:26,230 --> 02:28:27,390
maybe weirder but

02:28:29,200 --> 02:28:31,310
because right now

02:28:31,310 --> 02:28:32,540
if you disable,

02:28:32,540 --> 02:28:35,330
if you add the preempt RT patch

02:28:35,330 --> 02:28:37,120
on top of the kernel

02:28:37,120 --> 02:28:39,960
and you build it without preempt RT

02:28:39,960 --> 02:28:41,980
you have some things changing,

02:28:41,980 --> 02:28:43,590
small things or a

02:28:43,590 --> 02:28:45,710
slightly different behavior so--

02:28:45,710 --> 02:28:47,810
- No it's not slightly different behavior.

02:28:48,797 --> 02:28:53,210
What you have is that the code we had to restructure in

02:28:53,210 --> 02:28:55,760
order to accommodate RT

02:28:55,760 --> 02:28:59,630
stays restructured but that's going to be the same way.

02:28:59,630 --> 02:29:01,070
- [Man] Okay it's going to be the official way.

02:29:01,070 --> 02:29:04,710
- The official way so the restructuring of the code is going

02:29:04,710 --> 02:29:07,350
to happen, I mean in a lot of places it

02:29:07,350 --> 02:29:08,440
already happened.

02:29:10,810 --> 02:29:14,320
We just sold it for different reasons.

02:29:15,790 --> 02:29:17,720
- But Thomas did we,

02:29:17,720 --> 02:29:19,930
every time we've done this, we, like, lost,

02:29:19,930 --> 02:29:21,250
the changes have, like,

02:29:21,250 --> 02:29:23,170
went through, like, four modifications before it

02:29:23,170 --> 02:29:24,003
ever went upstream.

02:29:24,003 --> 02:29:24,836
- Right.

02:29:24,836 --> 02:29:27,120
- 'Cause we get the input from the people that we touch.

02:29:27,120 --> 02:29:29,477
- I mean we had cruel hacks to get

02:29:29,477 --> 02:29:31,500
CPU or clockwork in RT.

02:29:32,640 --> 02:29:36,790
Those were really even worse at that.

02:29:36,790 --> 02:29:41,250
I mean there's this, the soft IRQ hack is just golden

02:29:41,250 --> 02:29:43,570
compared to what we had to do to

02:29:43,570 --> 02:29:45,470
hot block and it never worked reliably

02:29:46,430 --> 02:29:49,930
up to the point where we actually ripped out or

02:29:49,930 --> 02:29:53,160
refactored hot block in the mainline kernel to,

02:29:53,160 --> 02:29:56,460
and broke, unbroke everything what was broken there

02:29:56,460 --> 02:29:57,410
in the first place.

02:29:59,210 --> 02:30:01,120
- I have a question which is sort of following off

02:30:01,120 --> 02:30:04,710
from Lewis's question and that is how

02:30:04,710 --> 02:30:06,920
many people do you expect to actually be

02:30:06,920 --> 02:30:09,790
building a preempt RT kernel and as a

02:30:09,790 --> 02:30:12,350
result of that you know how often do you

02:30:12,350 --> 02:30:15,110
expect preempt RT stuff to break in mainline?

02:30:16,310 --> 02:30:19,513
- Not at all because we're going to make sure that we run

02:30:23,030 --> 02:30:25,160
preempt RT tests even on next

02:30:26,380 --> 02:30:27,450
once we are in.

02:30:31,540 --> 02:30:33,520
- And once it's a configurable option

02:30:33,520 --> 02:30:35,060
to zero-day, we'll also hit it.

02:30:35,060 --> 02:30:37,960
So as soon as you compile break

02:30:37,960 --> 02:30:39,790
RT config options,

02:30:39,790 --> 02:30:41,090
zero-day will yell at you.

02:30:42,340 --> 02:30:44,280
- Yeah what about behavior though?

02:30:44,280 --> 02:30:47,590
- No, that's what we are going to do so we have to

02:30:47,590 --> 02:30:51,340
test infrastructure already and just point it at next

02:30:51,340 --> 02:30:52,500
at some point.

02:30:52,500 --> 02:30:54,730
- Locked ups could be modified to be able to catch things

02:30:54,730 --> 02:30:56,290
like spin locks.

02:30:56,290 --> 02:30:59,680
- We'll be adding, you know, once it's in main line and

02:30:59,680 --> 02:31:01,410
Thomas, you know, blesses us to

02:31:01,410 --> 02:31:04,330
turn it on so to speak we'll be running tests on it

02:31:04,330 --> 02:31:07,670
on zero day, right, so it'll be a part of it just like,

02:31:07,670 --> 02:31:10,330
and my goal with that, with zero day

02:31:10,330 --> 02:31:13,060
is when you submit your patches I'm also looking at other

02:31:13,060 --> 02:31:15,790
ways to kind of maybe through cut your nail on other things

02:31:15,790 --> 02:31:18,040
to look at those patches as they're coming in

02:31:18,040 --> 02:31:21,900
and catch those gotchas like you know local disable IRQs

02:31:21,900 --> 02:31:24,160
or things like that to send a soft warning.

02:31:24,160 --> 02:31:25,700
- Right. - There's some patches

02:31:25,700 --> 02:31:28,710
that are coming in so that we can be somewhat aggressive

02:31:28,710 --> 02:31:31,470
to preempt so to speak the potential breakages.

02:31:31,470 --> 02:31:32,790
- Yes, yeah

02:31:34,110 --> 02:31:36,610
that's definitely part of the plan.

02:31:38,020 --> 02:31:40,410
So it's going to be the year end,

02:31:40,410 --> 02:31:41,940
it's going to be used, I mean,

02:31:42,780 --> 02:31:44,200
so I expect that

02:31:45,800 --> 02:31:48,510
the actual users which put them,

02:31:48,510 --> 02:31:50,710
put our team products,

02:31:50,710 --> 02:31:53,080
they're either using totally

02:31:55,150 --> 02:31:57,050
broken franken kernels anyway.

02:31:59,710 --> 02:32:00,656
I don't know.

02:32:00,656 --> 02:32:02,312
(laughter)

02:32:02,312 --> 02:32:05,310
Is there anybody in the room who is related to those things?

02:32:05,310 --> 02:32:07,010
No, I don't care.

02:32:07,010 --> 02:32:10,030
No, but I mean normal and

02:32:10,030 --> 02:32:12,770
reasonable people just use LTS kernels.

02:32:17,550 --> 02:32:21,020
I didn't even try to say that you're close to reasonable.

02:32:25,890 --> 02:32:26,990
So throw a mic around.

02:32:29,080 --> 02:32:32,200
Just throw it into the crowd,

02:32:32,200 --> 02:32:35,346
the guy who is hit has to ask a question.

02:32:35,346 --> 02:32:37,596
(laughter)

02:32:42,730 --> 02:32:45,253
And if you're not throwing I'm going to throw.

02:32:45,253 --> 02:32:47,503
(laughter)

02:32:52,419 --> 02:32:55,336
See, everybody's happy already, no.

02:32:57,800 --> 02:32:59,000
- [Man] That's the beer.

02:33:01,040 --> 02:33:02,220
- [Man] I'm not reasonable.

02:33:03,860 --> 02:33:05,180
- So,

02:33:05,180 --> 02:33:08,170
after we get to the point where we've got

02:33:08,170 --> 02:33:10,660
a mainline curl that will build

02:33:10,660 --> 02:33:13,290
a functional, one we like

02:33:13,290 --> 02:33:15,100
preemptive T kernel,

02:33:15,100 --> 02:33:17,720
what do you see the effort as

02:33:17,720 --> 02:33:21,320
beyond that, do you have areas where you say,

02:33:21,320 --> 02:33:23,230
this is not the way we want it

02:33:24,120 --> 02:33:26,370
and so what are we gonna be lookin' at later?

02:33:27,380 --> 02:33:29,090
- There's a couple of things.

02:33:29,940 --> 02:33:31,010
One we have a

02:33:33,890 --> 02:33:38,030
not very well specified but we're on a long list of

02:33:38,030 --> 02:33:41,790
functionality we disabled with RT where people actually

02:33:41,790 --> 02:33:42,910
want to have it.

02:33:45,470 --> 02:33:46,350
One of them.

02:33:48,120 --> 02:33:49,130
Oh yes.

02:33:49,130 --> 02:33:51,120
- EBPF will fix it all, right?

02:33:51,120 --> 02:33:52,360
- Yeah, yeah we--

02:33:55,520 --> 02:33:59,900
If EBPF is disabled because EBPF wants to run with

02:33:59,900 --> 02:34:01,530
preemption disabled forever.

02:34:05,020 --> 02:34:05,870
Usually not.

02:34:06,880 --> 02:34:08,680
Most of the time it's not a problem.

02:34:10,660 --> 02:34:15,012
I mean Daniel will put it in his formula and it just works.

02:34:15,012 --> 02:34:17,262
(laughter)

02:34:19,950 --> 02:34:23,370
Yeah, no there's other things which are,

02:34:23,370 --> 02:34:26,020
can or currently disabled on RT and--

02:34:31,060 --> 02:34:31,893
No,

02:34:33,155 --> 02:34:37,010
that's more in the more functional areas like

02:34:37,010 --> 02:34:38,550
transparent huge pages.

02:34:41,580 --> 02:34:43,500
He was asking about admission control

02:34:43,500 --> 02:34:44,810
but that should just work.

02:34:47,800 --> 02:34:50,200
At least nobody complained about it not working.

02:34:53,790 --> 02:34:55,850
Group skid RT should go away.

02:34:57,700 --> 02:35:01,290
So we should just rip it out out of mainline completely.

02:35:02,874 --> 02:35:07,830
It's been broken forever not only on RT but on RT it just

02:35:07,830 --> 02:35:09,050
falls completely apart.

02:35:10,300 --> 02:35:11,133
Mark.

02:35:11,133 --> 02:35:12,650
- And so I think it was just mentioned in passing

02:35:12,650 --> 02:35:15,600
about we're now gonna have yet another kernel configuration

02:35:15,600 --> 02:35:17,940
that fundamentally changes

02:35:17,940 --> 02:35:19,110
the behavior of certain things like

02:35:19,110 --> 02:35:21,110
locks whatever there's been lots work

02:35:21,110 --> 02:35:22,430
that's gone on historically in the RT

02:35:22,430 --> 02:35:23,990
projects whose joins the mainline like

02:35:23,990 --> 02:35:25,690
lock dep and that kind of thing to make it easier

02:35:25,690 --> 02:35:27,430
to analyze and identify--

02:35:27,430 --> 02:35:30,300
- We have unlocked a patch for that which is coming up.

02:35:30,300 --> 02:35:32,590
- Sure, I was gonna ask is there anything more coming up

02:35:32,590 --> 02:35:35,740
beyond that to help with actually identifying

02:35:35,740 --> 02:35:37,460
issues, is there anything planned?

02:35:38,580 --> 02:35:40,750
- So a lot of the,

02:35:40,750 --> 02:35:43,340
except for the lock dep part,

02:35:43,340 --> 02:35:45,120
a lot of the missing bits,

02:35:45,120 --> 02:35:48,300
a lot of the infrastructure for us to see

02:35:49,310 --> 02:35:51,530
abuse of

02:35:51,530 --> 02:35:54,050
interfaces is already in place so

02:35:54,050 --> 02:35:56,180
I've reused the existing stuff.

02:35:57,130 --> 02:36:02,130
We might add some extra bits to scan for new

02:36:02,340 --> 02:36:05,330
freestanding local IRQ disabled

02:36:05,330 --> 02:36:07,890
lock, preemption disabled and things like that

02:36:08,790 --> 02:36:10,720
because that's where

02:36:10,720 --> 02:36:12,270
a lot of the trouble comes from

02:36:13,160 --> 02:36:13,993
because

02:36:15,450 --> 02:36:16,470
as I said before,

02:36:18,020 --> 02:36:20,620
all of these mechanisms like

02:36:20,620 --> 02:36:24,300
local IRQ disabled preempt disable, partner of disabled

02:36:24,300 --> 02:36:26,050
and whatever disabled.

02:36:26,050 --> 02:36:27,000
They are

02:36:27,950 --> 02:36:28,783
scopeless.

02:36:30,960 --> 02:36:32,860
They do not tell you what they protect

02:36:35,040 --> 02:36:37,120
so you just

02:36:37,120 --> 02:36:39,660
turn it on and it protects the world.

02:36:39,660 --> 02:36:41,120
Great

02:36:41,120 --> 02:36:44,200
but you can't tell what it actually does

02:36:44,200 --> 02:36:47,857
so we have one mechanism in RT which I

02:36:50,340 --> 02:36:52,710
wanted to avoid it but I probably

02:36:52,710 --> 02:36:55,840
going not to avoid it completely and it actually

02:36:55,840 --> 02:36:58,530
it might help with this particular part

02:36:58,530 --> 02:37:01,930
of problem pretty well is something like

02:37:04,242 --> 02:37:06,720
a mechanism it's called slow clock

02:37:06,720 --> 02:37:10,120
so it's trick per CPU if you define a

02:37:10,120 --> 02:37:14,050
local lock on a non RT kernel it just goes,

02:37:14,910 --> 02:37:16,740
allocates zero space for it.

02:37:17,650 --> 02:37:19,610
On RT it allocates actually

02:37:21,249 --> 02:37:22,082
a lock

02:37:23,260 --> 02:37:25,550
and that behaves semantically like

02:37:25,550 --> 02:37:27,310
then preempt disable but

02:37:28,580 --> 02:37:30,620
on RT, or

02:37:30,620 --> 02:37:33,120
on a non RT kernel it goes,

02:37:33,120 --> 02:37:34,850
compiles into a preempt disable

02:37:36,470 --> 02:37:39,690
and on a RT kernel it becomes a lock

02:37:39,690 --> 02:37:42,900
but then you have scope and you know what you're protecting

02:37:42,900 --> 02:37:45,280
so that's one of the big problems

02:37:45,280 --> 02:37:48,610
we always had with scopeless protection.

02:37:51,370 --> 02:37:53,340
And it's probably,

02:37:53,340 --> 02:37:54,173
it hasn't,

02:37:55,140 --> 02:37:57,580
it has no advantage for

02:37:57,580 --> 02:37:59,590
mainline but it,

02:37:59,590 --> 02:38:01,190
I think it has one as well.

02:38:02,080 --> 02:38:03,580
No obvious one

02:38:03,580 --> 02:38:05,260
but there's one as well

02:38:05,260 --> 02:38:08,240
because at the moment where we have scope,

02:38:10,020 --> 02:38:11,960
also lock dep will be able to

02:38:13,290 --> 02:38:14,970
whack you on the head

02:38:14,970 --> 02:38:18,000
if you do and we found actually problems like that

02:38:18,880 --> 02:38:20,900
so people did a preempt disable

02:38:21,870 --> 02:38:26,870
and actually attack to protect per CPU variable

02:38:27,080 --> 02:38:29,630
access and then actually they took an

02:38:29,630 --> 02:38:33,350
interrupt and accessed exactly the same CPU wearable

02:38:34,710 --> 02:38:38,780
so we have no debugging in mainline which actually can catch

02:38:38,780 --> 02:38:43,340
that case because preempt disable is scopeless.

02:38:44,320 --> 02:38:49,100
So but if we can actually put a scope on those sections

02:38:49,100 --> 02:38:52,500
then locked up can see the lock

02:38:52,500 --> 02:38:57,500
and say, hey you took it with spin lock here

02:38:57,840 --> 02:38:59,580
and then you got it

02:38:59,580 --> 02:39:01,770
you touched it in the interrupt

02:39:01,770 --> 02:39:03,830
and that gives you scope again

02:39:04,720 --> 02:39:07,100
so that works.

02:39:16,510 --> 02:39:17,343
- Okay,

02:39:17,343 --> 02:39:19,290
yeah I think it could also be useful

02:39:19,290 --> 02:39:21,380
and main line like with the BPF exit for

02:39:21,380 --> 02:39:24,280
example like a lot of people have been

02:39:24,280 --> 02:39:26,130
asking why do we disable preemption is

02:39:26,130 --> 02:39:28,970
it because of our CU or is it for some

02:39:28,970 --> 02:39:30,190
other reason and so--

02:39:30,190 --> 02:39:32,257
- No, it's just because it's BPF.

02:39:33,170 --> 02:39:35,420
(laughter)

02:39:36,548 --> 02:39:39,490
- BPF heart relies on preemption disabled because of the

02:39:39,490 --> 02:39:40,323
spin locks.

02:39:42,190 --> 02:39:43,560
- Okay,

02:39:43,560 --> 02:39:46,560
so why couldn't it just use the spin lock API instead?

02:39:47,840 --> 02:39:52,070
- No, no, the spin lock is encoded in the

02:39:52,070 --> 02:39:54,820
byte language.

02:39:54,820 --> 02:39:55,920
- [Man] Oh I see okay.

02:39:58,180 --> 02:39:59,872
- So it's magic.

02:39:59,872 --> 02:40:02,122
(laughter)

02:40:03,140 --> 02:40:05,660
No that chip can't actually.

02:40:06,780 --> 02:40:08,630
The chip just does the,

02:40:10,170 --> 02:40:12,470
translates the instructions but it doesn't

02:40:13,450 --> 02:40:15,440
see that it is a spin lock and

02:40:15,440 --> 02:40:18,400
because they do spin locks on that stuff.

02:40:18,400 --> 02:40:20,550
We're protecting their own data.

02:40:22,000 --> 02:40:24,950
They have this requirement, I don't know how to solve that.

02:40:25,790 --> 02:40:28,800
- I guess you could still have recursion where you have an

02:40:28,800 --> 02:40:31,020
interrupt come in even in the middle of

02:40:31,020 --> 02:40:32,820
the preempt disabled section

02:40:32,820 --> 02:40:33,830
in BPF because

02:40:34,810 --> 02:40:36,710
they don't disable IRQs, right?

02:40:36,710 --> 02:40:40,430
- [Man] No.

02:40:40,430 --> 02:40:44,330
It's so they can't,

02:40:44,330 --> 02:40:49,110
that BPF thing can't be preempted by another BPF thing take

02:40:49,110 --> 02:40:50,700
a whacking at the same lock.

02:40:50,700 --> 02:40:54,180
- [Man] BPF is a giant pile of nasty.

02:40:55,587 --> 02:40:56,420
- [Man] Where I was going was,

02:40:56,420 --> 02:40:59,190
you can have BPF programs run in the context of interrupts.

02:41:00,990 --> 02:41:03,597
- You can, you can even have BPFNMI but

02:41:03,597 --> 02:41:06,010
it's a giant pile of nasty.

02:41:06,010 --> 02:41:08,090
It's truly disgusting but

02:41:08,090 --> 02:41:10,970
they fixed this particular issue by having different

02:41:10,970 --> 02:41:13,080
BPF program types

02:41:13,080 --> 02:41:15,030
and only the

02:41:15,030 --> 02:41:17,240
BPF program types that run

02:41:18,870 --> 02:41:21,093
or at least a spin lock is limited to

02:41:21,093 --> 02:41:22,293
a specific program type.

02:41:23,140 --> 02:41:25,820
- [Man] Which are only run in thread context.

02:41:25,820 --> 02:41:27,730
- Yeah or soft IRQ, I think.

02:41:27,730 --> 02:41:28,920
- [Man] Yeah, whatever.

02:41:28,920 --> 02:41:31,570
- Yeah so they're limited to a single program type.

02:41:42,310 --> 02:41:46,640
- [Man] Now if the issue is specifically the BPF program

02:41:46,640 --> 02:41:48,660
protecting its own data structures,

02:41:50,230 --> 02:41:55,090
could we solve that by simply making an exclusion on

02:41:58,070 --> 02:42:00,670
each individual BPF program?

02:42:01,540 --> 02:42:03,520
- [Man] No, no, so this is a lock that is shared

02:42:03,520 --> 02:42:04,353
with user space.

02:42:06,320 --> 02:42:07,153
- Oh okay.

02:42:08,810 --> 02:42:12,220
- [Man] They have a U32 in the user map

02:42:13,220 --> 02:42:14,820
and they use spin locks on that.

02:42:17,390 --> 02:42:18,223
- It's magic.

02:42:20,710 --> 02:42:22,110
Don't ask why it works.

02:42:24,350 --> 02:42:27,310
That's one of the things is which just work and

02:42:27,310 --> 02:42:28,370
nobody understands why.

02:42:28,370 --> 02:42:29,203
- [Man] Yeah.

02:42:31,850 --> 02:42:35,140
- No, the user map spin lock is,

02:42:35,140 --> 02:42:35,973
I mean--

02:42:41,939 --> 02:42:44,330
If the user space gets scheduled out on the wrong place then

02:42:44,330 --> 02:42:45,450
you spin forever in

02:42:47,030 --> 02:42:48,450
that arrow thing which is.

02:42:50,510 --> 02:42:51,910
No, it becomes your problem.

02:42:57,407 --> 02:42:59,490
(laughs)

02:43:01,710 --> 02:43:02,543
- [Man] Hi,

02:43:03,736 --> 02:43:05,660
I have to deal with a lot of other real-time operating

02:43:05,660 --> 02:43:08,570
systems and everyone I work with, we

02:43:08,570 --> 02:43:10,820
what we really want is to use Linux

02:43:12,080 --> 02:43:14,990
and it's quite nice to hear that there will be a release in

02:43:14,990 --> 02:43:15,823
five five.

02:43:16,810 --> 02:43:20,050
Well, sorry, that's the goal, right, the goal?

02:43:20,050 --> 02:43:21,670
- There might. - There might be.

02:43:22,560 --> 02:43:24,230
What other-- - Five X.

02:43:26,760 --> 02:43:28,780
- Five X. - Five X.

02:43:28,780 --> 02:43:30,630
(laughter)

02:43:30,630 --> 02:43:32,360
- So I guess,

02:43:32,360 --> 02:43:34,960
so we've got automotive, probably military

02:43:34,960 --> 02:43:36,410
avionics, that sort of thing.

02:43:37,470 --> 02:43:41,050
What are the major other blocks you see for

02:43:41,050 --> 02:43:42,840
industry adopting a Linux?

02:43:42,840 --> 02:43:45,680
Because they're so used to proprietary closed software.

02:43:46,810 --> 02:43:50,650
- Linux is widely used in the industry and the preempt RT

02:43:50,650 --> 02:43:53,340
patch as it is, as an out of three

02:43:54,850 --> 02:43:57,980
thing is used in, widely used in products.

02:43:57,980 --> 02:43:59,930
It's all over the place, it's in

02:43:59,930 --> 02:44:00,763
automation.

02:44:03,870 --> 02:44:05,340
Pardon?

02:44:05,340 --> 02:44:07,090
Is there a RT kernel inside, no.

02:44:12,869 --> 02:44:15,930
I mean there's a lot of--

02:44:20,300 --> 02:44:23,210
It flies in rocket as rockets--

02:44:23,210 --> 02:44:26,400
- We did use RT but never in

02:44:26,400 --> 02:44:28,630
aviation or anything like, yeah.

02:44:30,090 --> 02:44:32,290
Right one of our automotive products.

02:44:32,290 --> 02:44:33,123
Portable, yeah.

02:44:34,480 --> 02:44:36,080
- I mean the whole thing getting

02:44:38,944 --> 02:44:40,910
the idea of having Linux

02:44:41,880 --> 02:44:45,270
preempt RT in the control box of your

02:44:46,650 --> 02:44:47,990
Boeing.

02:44:47,990 --> 02:44:50,400
- I guess so I have to deal with things like

02:44:50,400 --> 02:44:53,110
DO178 which is the

02:44:53,110 --> 02:44:55,690
aircraft software standards and

02:44:55,690 --> 02:44:56,940
then of course you have MSRA,

02:44:56,940 --> 02:44:59,960
so I mean one time-- - No, no.

02:44:59,960 --> 02:45:02,930
- So I mean if somebody were to certify one machine with

02:45:02,930 --> 02:45:05,700
Linux on it that kind of opens the door.

02:45:05,700 --> 02:45:08,960
- Yeah there's effort underway at least in the automotive

02:45:08,960 --> 02:45:11,260
space for certified things.

02:45:11,260 --> 02:45:14,040
- Yeah you should have attended Lucas's talk on safety

02:45:14,040 --> 02:45:17,610
critical Linux if you're interested in the

02:45:17,610 --> 02:45:19,831
messiness of that, so.

02:45:19,831 --> 02:45:22,260
- There's a project

02:45:23,400 --> 02:45:25,280
at the Linux Foundation, Eliza

02:45:26,480 --> 02:45:28,650
which actually deals with that.

02:45:28,650 --> 02:45:30,510
So people are looking into that.

02:45:34,480 --> 02:45:35,860
- That's the user case for the Baltic.

02:45:35,860 --> 02:45:38,420
Remotely stuff is clarifying the dynamics to

02:45:38,420 --> 02:45:40,510
one day try to

02:45:40,510 --> 02:45:43,270
certify Linux but I think this will take

02:45:43,270 --> 02:45:44,103
some time.

02:45:45,920 --> 02:45:47,190
No, no, no, no.

02:45:47,190 --> 02:45:49,100
We are far from something.

02:45:49,100 --> 02:45:52,010
Look at Michael Furman but we still--

02:45:55,440 --> 02:46:00,300
Yeah it would take a long time but.

02:46:01,570 --> 02:46:03,660
- You know it only took me 15 years.

02:46:05,050 --> 02:46:07,110
But you're way younger than me.

02:46:07,110 --> 02:46:09,360
(laughter)

02:46:13,750 --> 02:46:16,010
So you might get it done before you retire.

02:46:17,720 --> 02:46:18,770
- [Man] Job security.

02:46:25,480 --> 02:46:27,370
- I think you had the idea about

02:46:27,370 --> 02:46:29,230
completely removing soft IRQ--

02:46:29,230 --> 02:46:30,200
- [Man] Pardon?

02:46:30,200 --> 02:46:33,400
- Completely removing soft IRQ and everything in stride--

02:46:33,400 --> 02:46:35,950
- Well we were discussing that

02:46:35,950 --> 02:46:37,190
at some point but

02:46:39,610 --> 02:46:41,610
I didn't come up with a better solution.

02:46:43,410 --> 02:46:44,760
Soft IRQs completely.

02:46:46,890 --> 02:46:50,570
What I would love to get rid of is tasklets

02:46:50,570 --> 02:46:52,930
because they are ill-defined

02:46:53,840 --> 02:46:55,720
or not defined at all.

02:46:58,340 --> 02:46:59,640
It's a random pain

02:47:01,070 --> 02:47:03,090
so if they should really die

02:47:03,090 --> 02:47:05,090
and there are not that many uses anymore

02:47:06,020 --> 02:47:08,133
but we still grow new ones, so.

02:47:11,090 --> 02:47:15,880
A lot of the tasks, less usage is gone because

02:47:17,640 --> 02:47:18,930
it was very, very

02:47:20,270 --> 02:47:24,210
widely used in things like ice clear sea and SPI

02:47:24,210 --> 02:47:25,043
and whatever

02:47:25,890 --> 02:47:26,790
but those people

02:47:28,760 --> 02:47:32,570
took the opportunity and switched over to

02:47:32,570 --> 02:47:36,010
threaded interrupt handlers which solved the problem proper.

02:47:37,150 --> 02:47:41,470
So that port mostly the task let's use it, just go on and

02:47:41,470 --> 02:47:44,980
then ask quite some in old thrivers which nobody cares about

02:47:47,410 --> 02:47:52,410
so we need to find some of them I think and still whack them

02:47:52,710 --> 02:47:55,610
and then maybe kill them all.

02:47:56,740 --> 02:47:59,000
Input is using tasklets for no reason.

02:48:01,690 --> 02:48:03,860
- So just back to the user map spin locks,

02:48:03,860 --> 02:48:06,610
I'm just curious, do they deal with page faults at all?

02:48:07,546 --> 02:48:09,846
I mean with preemption disabled, what happens?

02:48:11,910 --> 02:48:12,770
- I don't know.

02:48:12,770 --> 02:48:14,070
- [Man] Is it just broken?

02:48:17,400 --> 02:48:21,420
- [Man] And for the spinlock thing actually,

02:48:21,420 --> 02:48:25,390
user cannot spin lock at the same time with the kernel.

02:48:25,390 --> 02:48:28,060
The reason is we don't share the memory.

02:48:28,060 --> 02:48:29,800
In kernel, it's the kernel memory

02:48:29,800 --> 02:48:32,240
and the user will get a copy of data

02:48:32,240 --> 02:48:34,370
and a spin lock will be zeroed

02:48:34,370 --> 02:48:35,910
in a central user space

02:48:35,910 --> 02:48:37,720
so there will be never a case,

02:48:37,720 --> 02:48:41,080
user space has been locked and the kernel has the same spin

02:48:41,080 --> 02:48:43,080
lock, that's not the case.

02:48:43,080 --> 02:48:43,913
- [Man] Okay.

02:48:43,913 --> 02:48:46,470
- Yeah, just kernel do kernel thing and user space,

02:48:46,470 --> 02:48:47,930
they just get zeroed.

02:48:47,930 --> 02:48:50,310
- Okay so what you're saying is

02:48:50,310 --> 02:48:53,600
the BPF spin lock is only

02:48:53,600 --> 02:48:55,480
protecting-- - For kernel only.

02:48:55,480 --> 02:48:56,810
For BPF different--

02:48:56,810 --> 02:49:00,170
- BPF against BPF. - Yes, that true.

02:49:04,230 --> 02:49:07,610
- Why is that user and can the user space modify it?

02:49:07,610 --> 02:49:11,360
- Why is it in the user map, then?

02:49:11,360 --> 02:49:14,640
- You use a map because it's inside the BPF program

02:49:14,640 --> 02:49:18,220
and there some maps they need a special flag and

02:49:18,220 --> 02:49:22,430
to indicate a spin lock there so they can use the spin lock.

02:49:22,430 --> 02:49:24,400
- Okay. - Otherwise they cannot use

02:49:24,400 --> 02:49:26,260
if they do not have this flag--

02:49:26,260 --> 02:49:29,260
- [Man] Okay and that's how they share the

02:49:29,260 --> 02:49:31,590
data between the two BPF programs?

02:49:31,590 --> 02:49:33,640
- Yes, you have a same map, you have a different--

02:49:33,640 --> 02:49:35,725
- Okay.

02:49:35,725 --> 02:49:37,980
But that makes the problem

02:49:39,420 --> 02:49:42,670
much better because then we don't have to

02:49:43,580 --> 02:49:45,600
disable preemption at all.

02:49:45,600 --> 02:49:49,170
We just have to make sure that

02:49:50,470 --> 02:49:52,540
the BPFs can't preempt each other.

02:49:53,670 --> 02:49:55,020
- [Man] Something like that.

02:49:55,020 --> 02:49:57,234
- Yeah. - But it's different the

02:49:57,234 --> 02:50:00,230
CPUs yeah well. - Yeah but then the CPU--

02:50:00,230 --> 02:50:01,650
- That's okay. - No, I mean

02:50:01,650 --> 02:50:06,050
we deal a lot of that with that on RT already that we say

02:50:06,050 --> 02:50:07,330
okay you can't,

02:50:08,330 --> 02:50:12,020
we have mechanisms which keep you on the same CPU

02:50:12,020 --> 02:50:15,150
otherwise the whole per CPU mess wouldn't work.

02:50:17,500 --> 02:50:18,410
Yeah

02:50:18,410 --> 02:50:21,000
no but if I keep it on the CPU and

02:50:21,000 --> 02:50:23,710
make sure that no other BPF thing can

02:50:23,710 --> 02:50:25,620
preempt that BPF thing

02:50:27,300 --> 02:50:29,490
until it's run out

02:50:29,490 --> 02:50:31,470
then I still don't have to be fully

02:50:31,470 --> 02:50:33,732
preemption there disabled preempt I've

02:50:33,732 --> 02:50:36,220
just have to protect

02:50:37,080 --> 02:50:39,070
BPF against BPF on that thing.

02:50:43,574 --> 02:50:46,024
- But if you did a local lock for BPF local lock,

02:50:47,170 --> 02:50:48,750
what about BPF local lock so it just basically,

02:50:48,750 --> 02:50:50,490
if they only care about BPF for BPF,

02:50:50,490 --> 02:50:52,130
I mean if something else you just, boom.

02:50:54,310 --> 02:50:56,930
- I mean then you get local preemption so

02:50:56,930 --> 02:51:00,470
the one CPU that holds the lock will be preempted by some

02:51:00,470 --> 02:51:03,050
other random crap and then the other CPU

02:51:03,050 --> 02:51:05,100
because it is a spin lock will just sit

02:51:05,100 --> 02:51:06,810
there spinning, it is a spin lock.

02:51:06,810 --> 02:51:10,290
- Yeah but it spins with preemption enabled, I don't care.

02:51:16,670 --> 02:51:17,503
Yeah that's,

02:51:18,430 --> 02:51:19,780
and it's a virtual machine.

02:51:21,870 --> 02:51:23,820
We just have to look at it differently.

02:51:26,240 --> 02:51:27,073
Yeah I know.

02:51:28,080 --> 02:51:31,530
You can put it into the same bucket you have it anyway.

02:51:32,700 --> 02:51:35,030
In the buckets you love, Bert.

02:51:38,680 --> 02:51:39,513
NMI.

02:51:42,590 --> 02:51:43,790
Felix's are great.

02:51:48,520 --> 02:51:50,484
Everybody loves system D.

02:51:50,484 --> 02:51:52,480
(laughter)

02:51:52,480 --> 02:51:54,709
We tried hating it, it doesn't work.

02:51:54,709 --> 02:51:55,910
(laughter)

02:51:55,910 --> 02:51:57,110
Doesn't made it go away.

02:51:59,690 --> 02:52:01,320
Okay, any other questions?

02:52:08,580 --> 02:52:10,220
No?

02:52:10,220 --> 02:52:11,053
Yeah sure.

02:52:14,220 --> 02:52:15,480
- Okay, so yeah

02:52:15,480 --> 02:52:17,670
I was just curious how much of

02:52:17,670 --> 02:52:20,970
RCU or torture testing has preempt RT got?

02:52:20,970 --> 02:52:23,950
I know Sebastian runs them quite a bit but--

02:52:23,950 --> 02:52:26,490
- [Man] Yeah we run it on a regular base.

02:52:27,370 --> 02:52:29,480
- Okay, so you don't expect much

02:52:29,480 --> 02:52:31,690
breakage or any at all with--

02:52:31,690 --> 02:52:33,250
- [Man] No, I mean depends

02:52:33,250 --> 02:52:35,910
what Paul is up to at the moment.

02:52:35,910 --> 02:52:38,440
(laughter)

02:52:38,440 --> 02:52:40,230
He might break it again,

02:52:40,230 --> 02:52:41,063
no, no.

02:52:42,030 --> 02:52:43,580
Hasn't been broken for a while.

02:52:44,510 --> 02:52:48,140
There are a few things we break occasionally but once it

02:52:48,140 --> 02:52:49,290
stabilizes, it shouldn't.

02:52:49,290 --> 02:52:52,640
- [Man] I mean the magic moment was 2006 or seven or

02:52:52,640 --> 02:52:56,230
thereabouts which is when preemptable RCU came about

02:52:56,230 --> 02:52:58,130
but ever since, it's been okay for RT.

02:52:59,560 --> 02:53:02,380
I mean it, like everything, occasionally it breaks by

02:53:02,380 --> 02:53:04,660
accident but then it gets fixed.

02:53:04,660 --> 02:53:06,070
It's really not an issue.

02:53:06,070 --> 02:53:06,903
- Okay.

02:53:07,940 --> 02:53:10,490
- No, we have a pretty good test coverage right now

02:53:11,680 --> 02:53:13,050
for the interesting ports.

02:53:14,260 --> 02:53:16,540
- [Man] Are we keeping the config breakdown between

02:53:16,540 --> 02:53:17,890
preempt RT base and--

02:53:17,890 --> 02:53:19,120
- No. - Okay so it's

02:53:19,120 --> 02:53:20,330
just goin' straight to full. - Now it's gone.

02:53:20,330 --> 02:53:21,780
- Okay.

02:53:21,780 --> 02:53:23,641
'Cause I never really understood what the--

02:53:23,641 --> 02:53:25,510
- [Man] Oh that was a

02:53:25,510 --> 02:53:27,231
debugging and development

02:53:27,231 --> 02:53:30,030
thing which I used when I

02:53:30,030 --> 02:53:31,630
remodeled the whole tree

02:53:32,470 --> 02:53:34,850
back in the three O timeframe.

02:53:34,850 --> 02:53:38,020
- Okay. - Because I could test

02:53:38,020 --> 02:53:43,020
some of the nasty thing is full RT kernel

02:53:44,617 --> 02:53:47,580
because I had to make sure that those

02:53:47,580 --> 02:53:51,830
mechanisms work in order to get a working RT kernel

02:53:51,830 --> 02:53:54,380
which made it into a circled bugging problem.

02:53:56,280 --> 02:53:57,700
- [Man] I'm pretty sure

02:53:57,700 --> 02:53:58,870
I think I've

02:53:58,870 --> 02:54:01,170
changed everything that I, if death fell on

02:54:01,170 --> 02:54:02,330
your franken kernel

02:54:03,500 --> 02:54:05,710
from base to full but I guess I'd better

02:54:05,710 --> 02:54:07,040
go make sure of that, huh?

02:54:07,040 --> 02:54:09,410
- Yeah you might

02:54:09,410 --> 02:54:10,840
make this,

02:54:10,840 --> 02:54:13,370
I think full includes space

02:54:14,240 --> 02:54:16,820
fully except for

02:54:16,820 --> 02:54:18,410
an older kernel version,

02:54:18,410 --> 02:54:21,030
one of the really old ones where

02:54:21,030 --> 02:54:25,070
base had some other side effects and which

02:54:25,070 --> 02:54:26,260
full them turned off.

02:54:27,540 --> 02:54:32,540
So you might have done something wrong here but

02:54:32,740 --> 02:54:35,490
you know now it was the franken kernel.

02:54:37,610 --> 02:54:38,700
It made you do that.

02:54:40,280 --> 02:54:42,240
- [Man] Everybody loves the franken kernel.

02:54:43,840 --> 02:54:45,140
- Yeah, well I don't care.

02:54:46,730 --> 02:54:48,730
Yeah, next year's t-shirt is,

02:54:48,730 --> 02:54:52,247
I'm not member of the kernel necrophiliac cult.

02:54:52,247 --> 02:54:54,497
(laughter)

02:54:57,858 --> 02:55:00,625
I see quite some members of that cult here.

02:55:00,625 --> 02:55:02,875
(laughter)

02:55:04,940 --> 02:55:06,260
So,

02:55:06,260 --> 02:55:07,093
anything else?

02:55:10,520 --> 02:55:11,353
No?

02:55:12,640 --> 02:55:13,910
Sounds good.

02:55:13,910 --> 02:55:14,875
Lunch!

02:55:14,875 --> 02:55:17,125

YouTube URL: https://www.youtube.com/watch?v=bpyFQJV5gCI


