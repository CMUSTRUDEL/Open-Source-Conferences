Title: LPC2019 - Toolchains - MC
Publication date: 2019-11-18
Playlist: LPC2019 - MicroConferences
Description: 
	Toolchains - MC
Captions: 
	00:00:00,480 --> 00:00:02,618
- [Speaker] So, as I was saying,

00:00:02,618 --> 00:00:03,576
hello, everybody.

00:00:03,576 --> 00:00:05,145
- Sorry I have to introduce you.

00:00:05,145 --> 00:00:06,169
This is ,

00:00:06,169 --> 00:00:07,919
and this is his talk.

00:00:08,874 --> 00:00:11,874
(audience laughing)

00:00:13,115 --> 00:00:17,365
- Yeah, so I work in the platform to 20 at Red Hat,

00:00:19,348 --> 00:00:20,181
and...

00:00:21,813 --> 00:00:23,813
So this talk is gonna be

00:00:24,940 --> 00:00:27,440
about discussing with you guys

00:00:30,094 --> 00:00:33,511
about the new kinds of debug info formats

00:00:34,691 --> 00:00:36,191
that are coming in

00:00:37,523 --> 00:00:41,273
that we're seeing coming in the kernel space,

00:00:43,871 --> 00:00:46,647
and tell you guys about how we're using

00:00:46,647 --> 00:00:48,656
the existing debug info,

00:00:48,656 --> 00:00:50,888
infrastructure that is there already

00:00:50,888 --> 00:00:53,388
to perform some analysis of...

00:00:56,358 --> 00:01:00,984
Well, I was told not to talk about kernel abi,

00:01:00,984 --> 00:01:05,400
so I will talk about kernel module interface.

00:01:05,400 --> 00:01:08,231
So the idea is to show quickly

00:01:08,231 --> 00:01:11,221
what we do with the debugging info today,

00:01:11,221 --> 00:01:13,388
and so that we can we know

00:01:15,191 --> 00:01:16,691
what would be nice

00:01:17,640 --> 00:01:19,473
to expect from the new

00:01:20,900 --> 00:01:22,351
debugging info formats that are coming

00:01:22,351 --> 00:01:26,434
so that we can keep doing what we're doing today,

00:01:27,306 --> 00:01:30,223
and even getting better experience.

00:01:31,573 --> 00:01:35,906
So, first of all, why are we interested in analysis,

00:01:36,824 --> 00:01:40,676
in looking at the kernel module interface,

00:01:40,676 --> 00:01:42,407
from a binary standpoint.

00:01:42,407 --> 00:01:44,954
So this is mainly due to the fact that

00:01:44,954 --> 00:01:48,137
we're having a different perspective here.

00:01:48,137 --> 00:01:51,636
We're having the perspective of kernel maintainer

00:01:51,636 --> 00:01:56,636
who is usually dealing with long term support versions,

00:01:56,979 --> 00:01:58,646
and in that context,

00:02:01,096 --> 00:02:05,013
that kernel maintainer doesn't want the the abi

00:02:06,539 --> 00:02:09,206
to change in an incompatible way

00:02:10,486 --> 00:02:12,986
across updates of a given LTS,

00:02:15,648 --> 00:02:17,815
I would say, main version.

00:02:20,125 --> 00:02:25,125
So the idea is that we that maintainer or those maintainers

00:02:25,453 --> 00:02:27,307
want to see the changes

00:02:27,307 --> 00:02:30,835
that impact the kernel module interface,

00:02:30,835 --> 00:02:35,157
well the interface exposed by the kernel to its modules.

00:02:35,157 --> 00:02:37,895
Want to see those changes

00:02:37,895 --> 00:02:41,562
in order to review them to be sure he agrees

00:02:42,902 --> 00:02:46,407
I mean, those changes are what he intended,

00:02:46,407 --> 00:02:49,990
and also to probably alert us automatically

00:02:51,455 --> 00:02:54,095
or semi-automatically about some changes

00:02:54,095 --> 00:02:56,512
that might be not acceptable.

00:02:57,984 --> 00:03:00,651
So we look the binaries directly

00:03:01,929 --> 00:03:04,061
as opposed to looking at source code,

00:03:04,061 --> 00:03:07,561
because by doing that we capture not only,

00:03:12,021 --> 00:03:14,365
what's carried by the source code,

00:03:14,365 --> 00:03:19,019
but also all this stuff that happens to the source code.

00:03:19,019 --> 00:03:20,133
After you've written it,

00:03:20,133 --> 00:03:23,716
like if you change, I don't know the tool chain

00:03:23,716 --> 00:03:25,678
that might impact the source code.

00:03:25,678 --> 00:03:27,283
So if you just look at the source code,

00:03:27,283 --> 00:03:29,950
you might miss all those things.

00:03:31,564 --> 00:03:35,152
So, that's the perspective we're taking here.

00:03:35,152 --> 00:03:38,473
So without, talking too much I'll,

00:03:38,473 --> 00:03:39,526
for those who don't know

00:03:39,526 --> 00:03:41,690
I wanted to just show you

00:03:41,690 --> 00:03:46,690
how you can be useful to maintainers in very simple ways.

00:03:47,081 --> 00:03:50,748
So, I'm gonna drive you through a real world

00:03:52,254 --> 00:03:55,906
small example of what we're showing today.

00:03:55,906 --> 00:03:57,656
So can you read this?

00:04:01,791 --> 00:04:03,771
If you can't, I don't know what to do.

00:04:03,771 --> 00:04:06,815
(audience laughing)

00:04:06,815 --> 00:04:08,232
- [Audience] Is the size big enough

00:04:08,232 --> 00:04:10,958
for you guys at the bottom?

00:04:10,958 --> 00:04:14,208
- If it's not big enough, you can come.

00:04:16,615 --> 00:04:18,547
Yeah, but there is room

00:04:18,547 --> 00:04:22,839
in the front where we are not eating people yet.

00:04:22,839 --> 00:04:25,902
So let's take a real example here

00:04:25,902 --> 00:04:30,505
of a tool that we have that uses the infrastructure

00:04:30,505 --> 00:04:32,843
we have today to compare two binaries.

00:04:32,843 --> 00:04:34,413
Okay, these can be, I don't know

00:04:34,413 --> 00:04:36,387
some kernel module or whatever.

00:04:36,387 --> 00:04:38,387
These are small binaries

00:04:39,402 --> 00:04:43,171
and let's see what the changes to the interface

00:04:43,171 --> 00:04:47,924
exposed by the binary interface of this thing is.

00:04:47,924 --> 00:04:51,349
So basically, this is what the tool is gonna show you

00:04:51,349 --> 00:04:52,642
and I've just highlighted this stuff

00:04:52,642 --> 00:04:55,328
so that we can follow it easily.

00:04:55,328 --> 00:05:00,096
So the first part is just an abstract of the changes

00:05:00,096 --> 00:05:01,856
that were detected.

00:05:01,856 --> 00:05:03,193
So basically, we were seeing that

00:05:03,193 --> 00:05:06,576
there was one function that changed,

00:05:06,576 --> 00:05:08,365
and so what does that mean?

00:05:08,365 --> 00:05:13,365
So then it goes on saying that the function that changed

00:05:13,568 --> 00:05:16,874
the name of the function that change is function zero.

00:05:16,874 --> 00:05:18,707
It tells you it's type

00:05:21,580 --> 00:05:22,823
and so on and so forth,

00:05:22,823 --> 00:05:26,490
and it says that the return type has changed

00:05:27,501 --> 00:05:29,752
from an integer to char.

00:05:29,752 --> 00:05:34,381
The type size has changed from 32 bit to 8 bit.

00:05:34,381 --> 00:05:37,125
The first parameter has changed as well,

00:05:37,125 --> 00:05:40,953
it was the parameter has a type, it's appointed type,

00:05:40,953 --> 00:05:44,453
and what's changed is the pointed to type.

00:05:45,508 --> 00:05:50,091
Okay, it got a data member inserted at a certain offset

00:05:51,051 --> 00:05:53,801
and it gives you the source line,

00:05:56,738 --> 00:05:59,443
and it says that the second parameter

00:05:59,443 --> 00:06:01,546
was removed from the function.

00:06:01,546 --> 00:06:04,676
So this is the level of detail

00:06:04,676 --> 00:06:09,676
that we are having today from the current infrastructure

00:06:09,779 --> 00:06:12,838
even though we're looking just at the binary

00:06:12,838 --> 00:06:16,534
we're referring to the source code in the reports.

00:06:16,534 --> 00:06:20,534
So that we can be useful to, well normal people.

00:06:21,596 --> 00:06:26,109
Okay, so basically, what I'm trying to say is that

00:06:26,109 --> 00:06:30,026
we're looking at more than just ELF symbols.

00:06:30,026 --> 00:06:33,642
So obviously, we're reading the debug information.

00:06:33,642 --> 00:06:35,422
We're building on

00:06:35,422 --> 00:06:38,556
we're doing compiler stuff, basically.

00:06:38,556 --> 00:06:42,735
We're building on in memory internal representation

00:06:42,735 --> 00:06:45,251
of what I would call ABI artifact.

00:06:45,251 --> 00:06:48,619
So basically, rebuilding a graph of the functions,

00:06:48,619 --> 00:06:50,452
variables there types.

00:06:52,591 --> 00:06:56,091
That IR can be serialized to disk to save,

00:06:58,011 --> 00:07:00,182
a snapshot of what the ABI is,

00:07:00,182 --> 00:07:02,625
but that is just if needed.

00:07:02,625 --> 00:07:05,339
We can also compare the IRs,

00:07:05,339 --> 00:07:08,401
because obviously we want to compare stuff, right?

00:07:08,401 --> 00:07:12,347
And the result of the comparison is not text.

00:07:12,347 --> 00:07:13,680
It's also an IR,

00:07:16,759 --> 00:07:20,676
an internal representation that can be analyzed

00:07:21,592 --> 00:07:26,135
to decide whether the changes are worthwhile.

00:07:26,135 --> 00:07:30,968
Or just walking that IR to emit change reports, basically.

00:07:32,570 --> 00:07:33,403
So

00:07:36,683 --> 00:07:39,131
for the new debug info formats that are coming,

00:07:39,131 --> 00:07:42,964
I'm talking about, CTF, BTF, or anything more.

00:07:44,467 --> 00:07:47,147
I don't know if there's anything more coming.

00:07:47,147 --> 00:07:50,676
People are talking about some compact DWARF thing,

00:07:50,676 --> 00:07:53,493
but anyway, it will be very...

00:07:53,493 --> 00:07:55,201
So this is where the discussion,

00:07:55,201 --> 00:07:57,618
I would say would start or...

00:08:00,706 --> 00:08:02,987
It will be very interesting

00:08:02,987 --> 00:08:06,743
that we could still do what we're doing,

00:08:06,743 --> 00:08:10,410
what I've showed you in the previous slides.

00:08:11,780 --> 00:08:14,849
So what do we need for that?

00:08:14,849 --> 00:08:18,682
Basically, we would need full type description

00:08:19,873 --> 00:08:22,540
for programmers levels artifact.

00:08:25,073 --> 00:08:26,813
By that I mean function,

00:08:26,813 --> 00:08:28,710
things that are meaningful to programmers.

00:08:28,710 --> 00:08:31,043
So, not ELF section, details

00:08:33,037 --> 00:08:33,870
and stuff like that.

00:08:33,870 --> 00:08:35,407
Nobody cares about those things.

00:08:35,407 --> 00:08:40,177
I'm talking about, functions, variables, their types.

00:08:40,177 --> 00:08:42,859
Whether the type is a structure, a pointer,

00:08:42,859 --> 00:08:45,776
qualified type, things with consts,

00:08:47,682 --> 00:08:48,890
things like that.

00:08:48,890 --> 00:08:50,330
Yeah, please.

00:08:50,330 --> 00:08:51,717
- If I could jump in here and...

00:08:51,717 --> 00:08:52,550
- Of course.

00:08:52,550 --> 00:08:54,131
- It's just a query whether you mean

00:08:54,131 --> 00:08:56,278
only those that are visible in the ELF symbol table

00:08:56,278 --> 00:08:57,939
or absolutely all of them,

00:08:57,939 --> 00:09:00,301
and whether you mean only top level types

00:09:00,301 --> 00:09:03,976
or even types that are only defined inside functions.

00:09:03,976 --> 00:09:05,606
I can't imagine you care about the latter,

00:09:05,606 --> 00:09:06,476
but you might.

00:09:06,476 --> 00:09:09,744
- So yeah, that's an interesting question.

00:09:09,744 --> 00:09:10,577
Yeah.

00:09:12,160 --> 00:09:14,459
- So, back when I was at Red Hat,

00:09:14,459 --> 00:09:17,849
I always took the most delight in

00:09:17,849 --> 00:09:21,682
changing the ABI was the sort of the so sudden

00:09:23,121 --> 00:09:24,659
So there's a whole bunch of things

00:09:24,659 --> 00:09:26,896
you can do with the stroll of people.

00:09:26,896 --> 00:09:29,063
They just store them up...

00:09:30,596 --> 00:09:31,596
- Of course.

00:09:35,348 --> 00:09:38,181
But that's absolutely true, right?

00:09:39,052 --> 00:09:42,135
It's kind of a mouse and cat kind of.

00:09:42,983 --> 00:09:47,678
- No it's a whole class of changes if you can do that

00:09:47,678 --> 00:09:51,595
Are function of the impulse of a working proof.

00:09:52,721 --> 00:09:54,330
- I was talking about (mumbles) kind of stuff.

00:09:54,330 --> 00:09:55,223
- Not necessarily the ABI.

00:09:55,223 --> 00:09:57,036
So for example you have an object

00:09:57,036 --> 00:10:00,466
and it has an initialization function

00:10:00,466 --> 00:10:02,259
and instruction function

00:10:02,259 --> 00:10:04,634
and some other functions to use it during life

00:10:04,634 --> 00:10:06,799
and I'm gonna change the rows.

00:10:06,799 --> 00:10:09,288
For example some functions might be optional

00:10:09,288 --> 00:10:12,459
and that then make it mandatory in the ABI.

00:10:12,459 --> 00:10:15,492
This will never ever catch that.

00:10:15,492 --> 00:10:19,394
If you can reverse the order that two functions must recall.

00:10:19,394 --> 00:10:20,227
- [Speaker] Yes.

00:10:20,227 --> 00:10:22,108
- I've never ever find anything like that.

00:10:22,108 --> 00:10:25,922
- Sure, but this is not a structural.

00:10:25,922 --> 00:10:27,406
This is a matter of behavior.

00:10:27,406 --> 00:10:28,239
- [Audience] I know.

00:10:28,239 --> 00:10:29,989
- So it's not, yeah.

00:10:31,548 --> 00:10:32,381
To me--

00:10:32,381 --> 00:10:33,672
(audience laughing)

00:10:33,672 --> 00:10:35,108
- [Audience] Please do tell your customers.

00:10:35,108 --> 00:10:35,941
- No I mean

00:10:35,941 --> 00:10:38,742
it's gonna be caught by other types of checking

00:10:38,742 --> 00:10:43,742
like anything that has to do with the behavior of a program

00:10:44,471 --> 00:10:49,367
can be caught by dynamic testing, I mean runtime testing.

00:10:49,367 --> 00:10:50,617
So this is not,

00:10:52,398 --> 00:10:56,481
I mean, this is not exclusive to runtime testing.

00:10:58,675 --> 00:11:01,671
I'm not saying that we should not do a runtime testing.

00:11:01,671 --> 00:11:02,648
We should do it,

00:11:02,648 --> 00:11:06,340
but the earlier you catch things, the better.

00:11:06,340 --> 00:11:08,630
I mean, the easier it is to fix them.

00:11:08,630 --> 00:11:11,435
So these ABI thing we're doing

00:11:11,435 --> 00:11:14,543
is really to be able to catch things earlier

00:11:14,543 --> 00:11:18,407
even before those expensive runtime stuff.

00:11:18,407 --> 00:11:21,234
So the thing you were talking about,

00:11:21,234 --> 00:11:23,018
I think, maybe I'm wrong,

00:11:23,018 --> 00:11:25,337
but I think these are not the about the structure

00:11:25,337 --> 00:11:30,337
of the entry points that are exposed by the binary.

00:11:30,344 --> 00:11:34,725
It's about the behavior, like the order of initialization

00:11:34,725 --> 00:11:36,149
and stuff like that,

00:11:36,149 --> 00:11:39,150
that has to be caught by runtime testing.

00:11:39,150 --> 00:11:41,900
So, to get back to your question,

00:11:43,031 --> 00:11:46,448
the philosophy that we are using today is

00:11:48,362 --> 00:11:50,400
the more I can get

00:11:50,400 --> 00:11:53,806
the more information I can get the better

00:11:53,806 --> 00:11:58,139
and then afterwards I will filter what I don't need.

00:11:59,290 --> 00:12:02,540
So, you were talking about for instance

00:12:04,330 --> 00:12:06,997
types that are or even functions

00:12:08,437 --> 00:12:11,015
that are not necessarily exposed.

00:12:11,015 --> 00:12:13,365
Okay, the thing is that.

00:12:13,365 --> 00:12:16,532
So, let us it's nice to have examples.

00:12:19,361 --> 00:12:24,203
When yeah you have a pattern that is used by everyone

00:12:24,203 --> 00:12:27,203
in coding in C when you want to hide

00:12:29,372 --> 00:12:32,366
the private data members of a structure.

00:12:32,366 --> 00:12:36,339
So, the structure will have just one data member

00:12:36,339 --> 00:12:41,339
which is gonna be a pointer to the private structure itself,

00:12:41,634 --> 00:12:43,356
and that private structure itself

00:12:43,356 --> 00:12:47,106
is gonna be like defined in a file dot C file

00:12:49,359 --> 00:12:50,334
without header file.

00:12:50,334 --> 00:12:53,073
So, it is supposedly private.

00:12:53,073 --> 00:12:55,573
Okay, and then the public type

00:12:56,870 --> 00:12:58,603
the one with just one data member

00:12:58,603 --> 00:13:02,859
that is a pointer is going to be exposed in the header file.

00:13:02,859 --> 00:13:05,846
So I guess your question will be

00:13:05,846 --> 00:13:10,846
do we care if there is a change in the private part,

00:13:10,898 --> 00:13:13,947
for instance of the type the one that is not

00:13:13,947 --> 00:13:15,654
that is supposed to be private?

00:13:15,654 --> 00:13:18,821
And initially, I was thinking that no.

00:13:20,342 --> 00:13:24,429
Okay, and we had like real life examples

00:13:24,429 --> 00:13:28,712
of people who were, who came to me and saying,

00:13:28,712 --> 00:13:30,622
yeah, this is not an ABI change

00:13:30,622 --> 00:13:32,286
but I still want to see the change

00:13:32,286 --> 00:13:35,196
because it was a real world case

00:13:35,196 --> 00:13:37,413
where just changing a define

00:13:37,413 --> 00:13:39,873
the value of a defined macro

00:13:39,873 --> 00:13:43,790
was changing some stuff in the private section,

00:13:44,641 --> 00:13:47,311
and the defined macro stuff couldn't be caught,

00:13:47,311 --> 00:13:50,292
because of course after the pre-processing stage,

00:13:50,292 --> 00:13:52,018
boom, it's, gone

00:13:52,018 --> 00:13:53,993
and it's not captured into off, right?

00:13:53,993 --> 00:13:57,014
And so what we did, and obviously

00:13:57,014 --> 00:13:59,510
we follow pointers during the analysis, right?

00:13:59,510 --> 00:14:02,340
So we were saying those things

00:14:02,340 --> 00:14:04,389
but we were discarding them very early.

00:14:04,389 --> 00:14:08,139
So what we did is that we just give ourselves

00:14:09,091 --> 00:14:12,646
the possibility to see all those things,

00:14:12,646 --> 00:14:15,979
but then discard them at the users will.

00:14:17,044 --> 00:14:17,877
Yeah.

00:14:17,877 --> 00:14:18,710
- [Audience] You have fifteen minutes more,

00:14:18,710 --> 00:14:19,963
so if you want to discuss about--

00:14:19,963 --> 00:14:21,463
- Yeah, so did I--

00:14:23,097 --> 00:14:24,167
- Later.

00:14:24,167 --> 00:14:28,071
- Yeah, so full type description of our function.

00:14:28,071 --> 00:14:29,129
So what do I mean by that?

00:14:29,129 --> 00:14:31,222
For instance, I mean that I would like to have

00:14:31,222 --> 00:14:34,889
the return types of the functions described.

00:14:36,536 --> 00:14:38,172
For instance, that's something that you don't have

00:14:38,172 --> 00:14:39,589
in the plain ELF.

00:14:41,113 --> 00:14:41,946
So

00:14:43,416 --> 00:14:45,689
it would like to have like

00:14:45,689 --> 00:14:48,657
all the types of the parameter types,

00:14:48,657 --> 00:14:50,126
but for instance, if the parameter type

00:14:50,126 --> 00:14:52,543
is a pointer to another type,

00:14:53,916 --> 00:14:57,316
I would like to be able to walk through that pointer

00:14:57,316 --> 00:14:59,649
and discover that other type

00:15:00,513 --> 00:15:02,238
So not pack it and say,

00:15:02,238 --> 00:15:04,552
oh pointer to type fu is a new type.

00:15:04,552 --> 00:15:05,385
Pointer to type...

00:15:05,385 --> 00:15:07,822
No I would like to have the ability to say it's a pointer

00:15:07,822 --> 00:15:09,427
to type food that exists

00:15:09,427 --> 00:15:11,503
and walk through that graph,

00:15:11,503 --> 00:15:13,753
and so, this kind of thing.

00:15:16,897 --> 00:15:18,147
Very important.

00:15:19,554 --> 00:15:22,361
It (laughs)

00:15:22,361 --> 00:15:26,403
I see that we some folks are in the know.

00:15:26,403 --> 00:15:30,282
So, de-duplication of type descriptions.

00:15:30,282 --> 00:15:33,032
Compiler people like using lingo.

00:15:34,483 --> 00:15:37,816
So, I'll try to explain what that means.

00:15:40,280 --> 00:15:43,265
So, basically, the way DWARF

00:15:43,265 --> 00:15:44,098
is

00:15:45,959 --> 00:15:49,272
the DWARF pipeline processing is organized today

00:15:49,272 --> 00:15:51,355
is that the compiler sees

00:15:54,102 --> 00:15:54,935
one

00:15:56,923 --> 00:15:59,447
compilation unit at a time.

00:15:59,447 --> 00:16:01,952
Basically I'm not talking about LTU kind of stuff,

00:16:01,952 --> 00:16:04,252
but linked-time optimization.

00:16:04,252 --> 00:16:05,151
At compile time,

00:16:05,151 --> 00:16:10,151
the compiler supposedly sees one compilation unit at a time.

00:16:10,362 --> 00:16:12,262
And so in that compilation unit

00:16:12,262 --> 00:16:16,093
what it does is that it will emit debug information

00:16:16,093 --> 00:16:17,515
for what it sees.

00:16:17,515 --> 00:16:20,254
Okay, including all the header files

00:16:20,254 --> 00:16:23,677
that are included and so on and so forth.

00:16:23,677 --> 00:16:26,260
That is emitted in a locatable,

00:16:28,121 --> 00:16:30,565
okay, with a dot O file,

00:16:30,565 --> 00:16:33,666
and then it moves to the next file, it compiles,

00:16:33,666 --> 00:16:35,106
and it does the same thing.

00:16:35,106 --> 00:16:35,939
So suppose for instance...

00:16:35,939 --> 00:16:37,685
Yeah, please go ahead.

00:16:37,685 --> 00:16:40,398
- [Audience] Does it also emit structure information

00:16:40,398 --> 00:16:42,972
for structures that aren't actually used in the translation?

00:16:42,972 --> 00:16:44,146
- Yes. - [Audience] Okay.

00:16:44,146 --> 00:16:45,729
- If it is declared

00:16:46,782 --> 00:16:51,782
not necessarily defined, it's supposed to be admitted.

00:16:52,085 --> 00:16:56,527
So and it does the same thing for the next compilation unit.

00:16:56,527 --> 00:16:59,188
So suppose that in the first one

00:16:59,188 --> 00:17:02,021
we had an integer type it defined,

00:17:03,508 --> 00:17:05,165
we'll have an integer type defined

00:17:05,165 --> 00:17:07,461
at the second compilation unit as well,

00:17:07,461 --> 00:17:10,220
and in the third into the fourth, etc.

00:17:10,220 --> 00:17:12,186
So there is the duplication

00:17:12,186 --> 00:17:14,603
of types definition in DWARF,

00:17:16,581 --> 00:17:18,194
and then what the linker does

00:17:18,194 --> 00:17:22,397
is that it will take all these dot O files,

00:17:22,397 --> 00:17:26,362
concatenate them, I mean concatenate their debug info

00:17:26,362 --> 00:17:27,596
their DWARF stuff,

00:17:27,596 --> 00:17:28,703
because the linker doesn't go

00:17:28,703 --> 00:17:31,788
and analyze what's inside the DWARF.

00:17:31,788 --> 00:17:35,243
Just takes it and concatenate everything

00:17:35,243 --> 00:17:38,243
and sticks that in the final binary,

00:17:39,592 --> 00:17:41,592
that it is constructing.

00:17:42,479 --> 00:17:44,854
So in the end, in that final binary

00:17:44,854 --> 00:17:48,021
you have int defined zillions of time.

00:17:50,354 --> 00:17:51,762
So, it is duplicated.

00:17:51,762 --> 00:17:55,897
Then you can imagine what you have for structures

00:17:55,897 --> 00:17:58,730
with pointers that points to types

00:18:00,272 --> 00:18:03,605
and you have like, a lot of duplication,

00:18:05,324 --> 00:18:09,289
and so what we spent a lot of time at runtime

00:18:09,289 --> 00:18:13,236
in the bobby Gail, for instance, de-duplicating those types.

00:18:13,236 --> 00:18:16,905
Making sure that if you have two integers,

00:18:16,905 --> 00:18:18,674
I mean, you just keep one,

00:18:18,674 --> 00:18:23,424
and if you have two types of the same name in the binary,

00:18:24,534 --> 00:18:26,717
and if they're the same,

00:18:26,717 --> 00:18:28,679
so there, are two conditions there,

00:18:28,679 --> 00:18:31,561
if you have two types that have the same name,

00:18:31,561 --> 00:18:33,745
and if they're of the same type,

00:18:33,745 --> 00:18:35,517
so structurally, you have to compare

00:18:35,517 --> 00:18:37,924
their structure member wise,

00:18:37,924 --> 00:18:40,141
then it's the same type.

00:18:40,141 --> 00:18:42,391
So you drop the second one.

00:18:43,315 --> 00:18:47,648
Okay, and we do that across all the millions of type

00:18:49,079 --> 00:18:50,983
occurrences that you have in the binary.

00:18:50,983 --> 00:18:54,150
So, we spend a lot of time doing that,

00:18:55,205 --> 00:19:00,205
and so it will be extremely nice, like extremely useful

00:19:00,436 --> 00:19:03,269
that those new debug info formats,

00:19:04,660 --> 00:19:07,206
do that at emitting time,

00:19:07,206 --> 00:19:08,611
when they emit this stuff.

00:19:08,611 --> 00:19:10,446
But this is quite challenging.

00:19:10,446 --> 00:19:15,196
So imagine for instance let's take a hypothetical example

00:19:17,090 --> 00:19:20,696
something that will never happen in real life probably,

00:19:20,696 --> 00:19:21,850
a kernel with modules.

00:19:21,850 --> 00:19:24,885
(audience laughing)

00:19:24,885 --> 00:19:26,321
So, you will have the kernel of for instance

00:19:26,321 --> 00:19:28,654
with 3000 something modules,

00:19:30,084 --> 00:19:33,501
each one defining its debug info like so.

00:19:34,634 --> 00:19:38,240
If you want to build the representation

00:19:38,240 --> 00:19:40,798
in memory representation of,

00:19:40,798 --> 00:19:43,789
that representation must be the union,

00:19:43,789 --> 00:19:46,145
the union of the representation of VM Linux,

00:19:46,145 --> 00:19:48,888
the binary, hypothetical example

00:19:48,888 --> 00:19:52,805
and of all the 3000 something modules in memory

00:19:54,300 --> 00:19:56,883
and then you de-duplicate that.

00:19:58,052 --> 00:20:02,635
So, I think that there is probably some pre-processing,

00:20:04,194 --> 00:20:08,301
I'm sorry some post-processing that should happen there,

00:20:08,301 --> 00:20:09,535
because I think the compiler

00:20:09,535 --> 00:20:14,199
is gonna still see one compile unit at the time

00:20:14,199 --> 00:20:18,065
and probably emit one module at the time, etc.

00:20:18,065 --> 00:20:20,208
But still it will be extremely useful

00:20:20,208 --> 00:20:22,208
to have that thing done.

00:20:23,457 --> 00:20:27,810
I think that the BTF guys are talking about that

00:20:27,810 --> 00:20:30,692
in one of the blog posts I've seen

00:20:30,692 --> 00:20:33,066
from the Facebook guys talking about that.

00:20:33,066 --> 00:20:36,781
But I don't know what the state of things with CTF.

00:20:36,781 --> 00:20:39,027
- I can specifically say that for

00:20:39,027 --> 00:20:40,686
We have a new de-duplicated being written

00:20:40,686 --> 00:20:45,186
for the de-duplicator with a kernel with 3000 modules.

00:20:47,523 --> 00:20:49,875
At the moment it takes about well

00:20:49,875 --> 00:20:51,227
before three weeks ago, it took a minute,

00:20:51,227 --> 00:20:53,799
sorry before three weeks ago it took a minute and a half

00:20:53,799 --> 00:20:57,534
to emit about six meg of compressed CTF

00:20:57,534 --> 00:20:59,114
describing all of them.

00:20:59,114 --> 00:21:00,648
Now it takes about 40 seconds

00:21:00,648 --> 00:21:03,813
to emit 5.5 meg describing all of them.

00:21:03,813 --> 00:21:05,332
Without that without the duplication,

00:21:05,332 --> 00:21:10,102
you get 55 million types and hundreds of mega repeated junk.

00:21:10,102 --> 00:21:11,831
So you really need-- - [Speaker] That's so crazy.

00:21:11,831 --> 00:21:13,168
Yeah. - And we've got it.

00:21:13,168 --> 00:21:14,387
- So, yeah exactly

00:21:14,387 --> 00:21:17,817
and for instance today so Mathias is here.

00:21:17,817 --> 00:21:21,734
I don't know if you were to his talk yesterday,

00:21:23,267 --> 00:21:25,684
where he was presenting their

00:21:26,778 --> 00:21:30,028
process about ABI and stuff in Android.

00:21:31,896 --> 00:21:34,879
Yeah, we've been working on this just to give you

00:21:34,879 --> 00:21:36,712
a kind of time, scale.

00:21:38,318 --> 00:21:40,683
I think now on a regular laptop,

00:21:40,683 --> 00:21:41,763
we're down to,

00:21:41,763 --> 00:21:43,829
so to meet the entire ABI.

00:21:43,829 --> 00:21:45,722
So it's not just the duplication.

00:21:45,722 --> 00:21:49,972
So you read the binaries, oomph thousands binaries,

00:21:51,400 --> 00:21:55,076
you do everything and you save it to in on disk.

00:21:55,076 --> 00:21:58,079
Did duplication included because we have to do it.

00:21:58,079 --> 00:22:02,662
So we're around 100 and 20 seconds or something, right?

00:22:04,236 --> 00:22:06,365
I mean, for the full blown kernel.

00:22:06,365 --> 00:22:07,934
The Android guys are like faster

00:22:07,934 --> 00:22:10,793
because they do like, yeah

00:22:10,793 --> 00:22:14,831
they take corners with a very high velocity or something.

00:22:14,831 --> 00:22:19,248
- So it takes longer than to actually build a kernel.

00:22:21,111 --> 00:22:23,359
- I don't know how long it takes on those machines.

00:22:23,359 --> 00:22:24,211
- [Audience] The codes,

00:22:24,211 --> 00:22:28,628
I guess we're talking about the full blown I think...

00:22:30,081 --> 00:22:31,586
- 120 seconds.

00:22:31,586 --> 00:22:33,668
I think it takes more than that to build a kernel.

00:22:33,668 --> 00:22:34,962
- [Audience] Kernel roughly takes

00:22:34,962 --> 00:22:39,365
I guess it's a roughly measurement instrument to build--

00:22:39,365 --> 00:22:42,839
(audience chattering)

00:22:42,839 --> 00:22:44,962
- That's redundancy.

00:22:44,962 --> 00:22:46,416
- The Android kernel builds

00:22:46,416 --> 00:22:49,278
and that configuration and them testing roughly two minutes

00:22:49,278 --> 00:22:52,688
and extraction of ABI is roughly 20 seconds

00:22:52,688 --> 00:22:54,598
15 seconds depends.

00:22:54,598 --> 00:22:56,646
- Yeah, so yeah.

00:22:56,646 --> 00:22:59,377
And so we're using a lot of heuristics

00:22:59,377 --> 00:23:00,258
and so on and so to forth

00:23:00,258 --> 00:23:04,848
to speed up that thing and a lot of mental power

00:23:04,848 --> 00:23:08,396
and it will be very, very useful to have that.

00:23:08,396 --> 00:23:09,229
So yeah, if--

00:23:09,229 --> 00:23:13,552
- Well I should point out that unlike DWARF with CTF,

00:23:13,552 --> 00:23:17,646
we are duplicating at linking time at link time

00:23:17,646 --> 00:23:19,597
and we are in the process of putting that logic

00:23:19,597 --> 00:23:21,145
in be binutils itself in the link time.

00:23:21,145 --> 00:23:24,580
- So at link time but what about all those modules?

00:23:24,580 --> 00:23:26,913
Because you don't see, yeah.

00:23:28,857 --> 00:23:31,554
So I mean that's super nice already for VM Linux

00:23:31,554 --> 00:23:35,772
- It's a specialized the most of the type merging

00:23:35,772 --> 00:23:36,986
and the de-duplication stuff

00:23:36,986 --> 00:23:40,392
is in the library which binitils produces

00:23:40,392 --> 00:23:43,438
and there is a specialized kernel side

00:23:43,438 --> 00:23:47,378
de-duplicated which does a similar job on a kernel scale

00:23:47,378 --> 00:23:50,847
and knows what modules are and that sort of thing.

00:23:50,847 --> 00:23:51,680
- [Speaker] Okay, so--

00:23:51,680 --> 00:23:53,143
- We will see that later in the--

00:23:53,143 --> 00:23:55,726
- Okay, yeah so I guess this is

00:23:57,408 --> 00:23:58,658
my request for

00:24:00,434 --> 00:24:01,851
you fine fellows.

00:24:03,679 --> 00:24:07,015
And if you don't have any more question,

00:24:07,015 --> 00:24:08,682
thank you very much.

00:24:10,681 --> 00:24:13,462
- We have like five minutes for questions, complaints.

00:24:13,462 --> 00:24:15,131
(audience laughing)

00:24:15,131 --> 00:24:15,964
Not yet.

00:24:17,927 --> 00:24:20,217
- Can I just say (mumbles) is awesome (laughs)

00:24:20,217 --> 00:24:21,718
- Thank you very much.

00:24:21,718 --> 00:24:25,245
Okay, so let's process to the next one.

00:24:25,245 --> 00:24:28,245
(audience clapping)

00:24:48,745 --> 00:24:51,912
(audience chattering)

00:25:52,236 --> 00:25:53,069
- Okay.

00:25:55,124 --> 00:25:55,957
It's all right?

00:25:55,957 --> 00:25:57,457
- [Audience] Yeah.

00:26:06,212 --> 00:26:07,045
- Okay.

00:26:13,610 --> 00:26:14,443
So,

00:26:15,369 --> 00:26:17,452
Can I be heard correctly?

00:26:30,281 --> 00:26:32,114
Okay, can you hear me?

00:26:33,004 --> 00:26:35,246
- [Audience] I can hear you but is not due to the mic.

00:26:35,246 --> 00:26:36,079
- Yeah.

00:26:44,086 --> 00:26:46,586
- Okay, do you hear me? - Yeah.

00:27:27,748 --> 00:27:30,665
Okay, so my name is Maciej Rozycki.

00:27:31,821 --> 00:27:34,238
Welcome to this presentation.

00:27:35,374 --> 00:27:38,684
(audience laughing)

00:27:38,684 --> 00:27:41,434
- It's on, it's just to far away.

00:27:44,098 --> 00:27:47,098
(audience laughing)

00:28:28,294 --> 00:28:30,622
- So this one does work apparently.

00:28:30,622 --> 00:28:31,455
Okay great.

00:28:31,455 --> 00:28:33,634
So my name is Maciej Rozycki

00:28:33,634 --> 00:28:34,467
and

00:28:36,461 --> 00:28:39,426
this is my first presentation which I've invested today

00:28:39,426 --> 00:28:43,482
which was, it was some time last century.

00:28:43,482 --> 00:28:44,315
So this might be a bit harsh--

00:28:44,315 --> 00:28:48,135
(background noise drowns out speaker)

00:28:48,135 --> 00:28:51,135
and I came here I myself and Dmitry.

00:28:54,663 --> 00:28:58,174
We were both coming to this conference

00:28:58,174 --> 00:28:59,898
and GNU Tools Cauldron

00:28:59,898 --> 00:29:03,565
which is happening this week later this week

00:29:05,405 --> 00:29:09,488
and we were asked by one of the glibc maintainers

00:29:11,047 --> 00:29:12,214
Florian Weimer

00:29:17,028 --> 00:29:21,445
to talk about the issue of syscall wrappers in glibc.

00:29:26,361 --> 00:29:27,528
So, excuse me.

00:29:29,179 --> 00:29:32,226
I haven't been involved with in that myself,

00:29:32,226 --> 00:29:34,746
although I've been contributing to glibc

00:29:34,746 --> 00:29:39,141
and working with the community for several years now

00:29:39,141 --> 00:29:39,974
and

00:29:45,103 --> 00:29:47,187
this would be essentially most of their message

00:29:47,187 --> 00:29:51,854
from Florian with a request for feedback from all of you

00:29:53,736 --> 00:29:54,653
if that's--

00:29:56,111 --> 00:29:57,444
Done better or--

00:29:58,920 --> 00:30:02,764
Suggestions then this will be taken into account

00:30:02,764 --> 00:30:07,431
and we'll carry the message to the cauldron in Montreal,

00:30:08,732 --> 00:30:12,065
which is happening this coming Thursday.

00:30:13,220 --> 00:30:14,053
So,

00:30:15,834 --> 00:30:20,667
the motivation for having the syscalls wrapped in glibc is

00:30:23,757 --> 00:30:27,556
there are several advantages to that

00:30:27,556 --> 00:30:30,056
rather than doing raw syscalls

00:30:31,172 --> 00:30:35,192
from various applications which happened to

00:30:35,192 --> 00:30:37,109
and the need for them--

00:30:41,954 --> 00:30:43,341
corresponding,

00:30:43,341 --> 00:30:47,091
there's no corresponding C Library interface.

00:30:48,145 --> 00:30:50,011
So one of them is type checking,

00:30:50,011 --> 00:30:52,094
which is I think obvious.

00:30:53,385 --> 00:30:57,025
The other one is portability across Linux ports,

00:30:57,025 --> 00:31:01,692
which means essentially you have a C interface where you

00:31:03,244 --> 00:31:05,851
can invoke the syscall

00:31:05,851 --> 00:31:07,851
as if a usual C function

00:31:09,679 --> 00:31:11,846
and we don't need to do...

00:31:23,423 --> 00:31:26,291
(audience laughing)

00:31:26,291 --> 00:31:27,689
So essentially Yeah.

00:31:27,689 --> 00:31:28,522
So,

00:31:31,196 --> 00:31:33,721
otherwise obviously, each of the applications

00:31:33,721 --> 00:31:36,473
which wants to use the interface

00:31:36,473 --> 00:31:38,542
would have to know all the gory details

00:31:38,542 --> 00:31:39,375
of the

00:31:42,055 --> 00:31:44,772
unique calling convention for syscall

00:31:44,772 --> 00:31:47,378
meaning generally writing assembly code

00:31:47,378 --> 00:31:48,686
and such staff.

00:31:48,686 --> 00:31:52,186
Another thing is POSIX thread cancellation

00:31:53,454 --> 00:31:55,037
which will be done.

00:32:00,476 --> 00:32:02,452
- [Audience] Yeah, it's working.

00:32:02,452 --> 00:32:05,452
(audience laughing)

00:32:06,994 --> 00:32:08,652
I just got interference in the mic.

00:32:08,652 --> 00:32:09,747
So sorry.

00:32:09,747 --> 00:32:10,580
- Okay,

00:32:13,590 --> 00:32:16,757
and debugging the thing is essentially

00:32:17,944 --> 00:32:20,111
you can place a breakpoint

00:32:22,877 --> 00:32:27,320
at the single entry point to the syscall wrapper

00:32:27,320 --> 00:32:30,487
rather than to having to chase all the

00:32:31,731 --> 00:32:34,398
syscall invocations in assembly.

00:32:35,556 --> 00:32:36,389
So

00:32:39,661 --> 00:32:41,643
traditionally, all the syscalls

00:32:41,643 --> 00:32:44,174
used to be wrapped by C libraries,

00:32:44,174 --> 00:32:47,479
and glibc used to do that as well.

00:32:47,479 --> 00:32:51,535
but if historical mistake was made at one point

00:32:51,535 --> 00:32:53,786
that we stopped doing that

00:32:53,786 --> 00:32:55,954
and lesson has been learned,

00:32:55,954 --> 00:32:57,537
and till we decided

00:32:58,944 --> 00:33:01,361
to do this again essentially.

00:33:03,593 --> 00:33:08,314
So but this is only going to be for the syscall

00:33:08,314 --> 00:33:10,699
that are actually useful for applications.

00:33:10,699 --> 00:33:12,235
We're not going to expose stuff

00:33:12,235 --> 00:33:14,818
like some architectures require

00:33:17,468 --> 00:33:19,802
syscall to set the thread port for example,

00:33:19,802 --> 00:33:22,729
like X86 in the (mumbles)

00:33:22,729 --> 00:33:26,330
entry this is used internally by glibc.

00:33:26,330 --> 00:33:29,498
So if it was to be exposed to an application

00:33:29,498 --> 00:33:31,315
then not all things could break,

00:33:31,315 --> 00:33:33,982
so we're not going to have that.

00:33:34,816 --> 00:33:39,080
But otherwise there's no problem to have the syscalls

00:33:39,080 --> 00:33:42,497
we have some guidelines prepared already.

00:33:46,012 --> 00:33:50,596
what's the syscall wrappers are supposed to look like,

00:33:50,596 --> 00:33:54,013
and why the intent is there to have them.

00:33:55,215 --> 00:33:56,048
We are not

00:33:57,790 --> 00:34:01,572
regrettably going to add them all at once.

00:34:01,572 --> 00:34:03,655
The thing is essentially

00:34:07,352 --> 00:34:10,032
there is significant effort to doing that

00:34:10,032 --> 00:34:11,282
and each of the

00:34:15,731 --> 00:34:18,314
functions have to be documented

00:34:19,247 --> 00:34:20,914
in the glibc manual,

00:34:22,575 --> 00:34:24,692
and that has to be reviewed.

00:34:24,692 --> 00:34:25,525
You have a question.

00:34:25,525 --> 00:34:28,195
- [Audience] Is that copyright only for the documentation

00:34:28,195 --> 00:34:30,179
or also for the wrappers?

00:34:30,179 --> 00:34:34,509
- Yes, it's both for documentation and for code.

00:34:34,509 --> 00:34:36,293
- So does the FSF now acknowledge

00:34:36,293 --> 00:34:39,740
that there's copyrights and APIs?

00:34:39,740 --> 00:34:42,028
- It's not about the API.

00:34:42,028 --> 00:34:45,042
It's about the actual piece of code.

00:34:45,042 --> 00:34:46,002
I mean-- - [Audience] There is no code,

00:34:46,002 --> 00:34:47,252
it's a wrapper.

00:34:50,502 --> 00:34:52,725
- That's actually a piece of code.

00:34:52,725 --> 00:34:54,404
- Well, but it depends.

00:34:54,404 --> 00:34:56,853
As you say if a little piece of code

00:34:56,853 --> 00:34:58,693
it's implement in an interface,

00:34:58,693 --> 00:35:01,800
and there is no creativity required for writing it

00:35:01,800 --> 00:35:04,083
meaning that you cannot do it in a different way

00:35:04,083 --> 00:35:05,661
lexically as speaking.

00:35:05,661 --> 00:35:07,711
- Which-- - Yes.

00:35:07,711 --> 00:35:12,641
Then and in another packages on programs we have files,

00:35:12,641 --> 00:35:15,562
like describing font maps for example,

00:35:15,562 --> 00:35:17,428
which will be something similar

00:35:17,428 --> 00:35:22,062
where we consider those files to not be copyright table,

00:35:22,062 --> 00:35:25,741
but we will need to look at each case separately

00:35:25,741 --> 00:35:27,883
involving lawyers probably and so on.

00:35:27,883 --> 00:35:31,587
But yeah, not everything can be copyrighted.

00:35:31,587 --> 00:35:35,473
- And of course, if the contribution is very small

00:35:35,473 --> 00:35:37,407
there's the rule that like if you contribute

00:35:37,407 --> 00:35:39,692
up to like 15 lines of code

00:35:39,692 --> 00:35:41,265
it can just go in,

00:35:41,265 --> 00:35:42,432
and if you say

00:35:44,067 --> 00:35:46,963
your proposed wrapper is going to fit into that

00:35:46,963 --> 00:35:49,630
that's not going to be an issue.

00:35:50,603 --> 00:35:53,307
And these days doing a copyright assignment

00:35:53,307 --> 00:35:56,661
with FSF is not that it's usually not a big deal

00:35:56,661 --> 00:35:59,655
because this can be done electronically for many people.

00:35:59,655 --> 00:36:00,701
So.

00:36:00,701 --> 00:36:04,751
- It is also not legal in a number of territories

00:36:04,751 --> 00:36:06,413
- Well, I'm not a lawyer, so--

00:36:06,413 --> 00:36:08,266
(mumbles)

00:36:08,266 --> 00:36:09,849
- Yeah, but I mean,

00:36:14,061 --> 00:36:15,834
if it's a void in your country

00:36:15,834 --> 00:36:17,279
for example that you can do this

00:36:17,279 --> 00:36:19,529
and ignore from then on so,

00:36:20,526 --> 00:36:22,822
because it's not valid anyway.

00:36:22,822 --> 00:36:23,678
Yeah I mean--

00:36:23,678 --> 00:36:27,261
- [Audience] But he didn't say that, right?

00:36:30,142 --> 00:36:31,044
- That's nothing illegal.

00:36:31,044 --> 00:36:34,171
Yeah, I mean, if FSF requested that you can do that,

00:36:34,171 --> 00:36:35,921
but it's not going to

00:36:37,308 --> 00:36:40,237
sort of take your copyright away from you.

00:36:40,237 --> 00:36:44,237
That's essentially ineffective for your country.

00:36:45,485 --> 00:36:46,318
So

00:36:48,010 --> 00:36:49,927
but there's nothing on.

00:36:51,610 --> 00:36:53,223
- You can actually do it electronically now.

00:36:53,223 --> 00:36:54,056
- Yes.

00:36:54,056 --> 00:36:57,740
I don't know the exact details where it applies,

00:36:57,740 --> 00:36:59,240
but I believe it's

00:37:01,131 --> 00:37:04,647
for no private persons in the US,

00:37:04,647 --> 00:37:06,131
and I believe in Germany

00:37:06,131 --> 00:37:07,739
and a couple of other countries

00:37:07,739 --> 00:37:11,006
- I think is like two years ago

00:37:11,006 --> 00:37:13,684
or something because I needed to get some stuff into glibc

00:37:13,684 --> 00:37:17,017
and I think I still had to mail a letter

00:37:18,559 --> 00:37:19,392
to the US or something.

00:37:19,392 --> 00:37:21,925
- What country - Germany

00:37:21,925 --> 00:37:24,904
- Well, I have done copyright assignment to in Germany

00:37:24,904 --> 00:37:26,202
from Germany where I lived

00:37:26,202 --> 00:37:28,785
and you can do it with the BTF.

00:37:31,733 --> 00:37:32,566
Yeah, so.

00:37:39,486 --> 00:37:41,454
- Okay, and the final problem

00:37:41,454 --> 00:37:45,037
with adding more wrappers is essential way.

00:37:54,436 --> 00:37:56,872
We were short of reviewers.

00:37:56,872 --> 00:37:59,977
That's the usual problem with the glibc

00:37:59,977 --> 00:38:03,851
community is not very large that at this time,

00:38:03,851 --> 00:38:06,479
everyone is welcome to join us of course,

00:38:06,479 --> 00:38:11,119
but with the task force of people that we currently have,

00:38:11,119 --> 00:38:13,202
and so many things to do,

00:38:14,336 --> 00:38:17,086
it may be quite a stretch for you

00:38:20,329 --> 00:38:23,601
to do this as well especially all at the time.

00:38:23,601 --> 00:38:27,018
So, if all the contributions are welcome.

00:38:30,071 --> 00:38:33,829
- Just in case people are put off by its past reputation

00:38:33,829 --> 00:38:36,319
the glibc community is really inviting these days.

00:38:36,319 --> 00:38:37,462
It's one of the most prolific communities--

00:38:37,462 --> 00:38:40,229
- [Maciej] Yes. - I've contributed to.

00:38:40,229 --> 00:38:41,466
- Yeah, indeed.

00:38:41,466 --> 00:38:43,593
We're consciousness driven these days.

00:38:43,593 --> 00:38:44,843
So essentially,

00:38:47,767 --> 00:38:51,714
for a change they've accepted there has to be

00:38:51,714 --> 00:38:55,531
now serious objections for people from the community,

00:38:55,531 --> 00:38:58,711
and usually just a single acknowledgement

00:38:58,711 --> 00:38:59,961
from one of the maintainers

00:38:59,961 --> 00:39:02,544
is enough to get the change in.

00:39:04,759 --> 00:39:08,342
Okay, so here are some specific notes about

00:39:11,350 --> 00:39:13,454
our glibc products requirements

00:39:13,454 --> 00:39:15,537
for the syscall wrappers.

00:39:16,714 --> 00:39:20,334
So we're not going to emulate syscalls

00:39:20,334 --> 00:39:22,479
that have been removed deprecated

00:39:22,479 --> 00:39:26,179
are not present for whatever reason

00:39:26,179 --> 00:39:29,127
we're just going to return

00:39:29,127 --> 00:39:33,390
past ENOSYS return status from the kernel.

00:39:33,390 --> 00:39:38,043
The reason for that is it's except for retrieval cases

00:39:38,043 --> 00:39:39,543
it has proved very

00:39:41,520 --> 00:39:42,770
error prone and

00:39:44,616 --> 00:39:45,616
problematic.

00:39:47,347 --> 00:39:50,224
Some trivial cases is where for example,

00:39:50,224 --> 00:39:52,474
there's a new flag added to

00:39:54,204 --> 00:39:56,734
syscall which in the absence

00:39:56,734 --> 00:40:00,412
of which an older syscall can be used directly

00:40:00,412 --> 00:40:03,079
but we would like to avoid that.

00:40:05,799 --> 00:40:08,382
Another case is we want to have

00:40:10,772 --> 00:40:14,677
architecture independent names of the wrappers

00:40:14,677 --> 00:40:15,997
if at all possible.

00:40:15,997 --> 00:40:18,216
So essentially if there's a syscall

00:40:18,216 --> 00:40:20,842
that's right across all the architectures

00:40:20,842 --> 00:40:24,607
we want to have it name the same across them all.

00:40:24,607 --> 00:40:29,607
Because otherwise it's going to be a maintenance nightmare.

00:40:30,029 --> 00:40:33,779
A problem is are also multi-flexing syscalls.

00:40:35,511 --> 00:40:36,746
As I listed here

00:40:36,746 --> 00:40:41,109
well it's not possible to take the argument types

00:40:41,109 --> 00:40:45,405
when they are different for each of the sub syscalls

00:40:45,405 --> 00:40:48,892
and pass through the multiplexer

00:40:48,892 --> 00:40:51,809
if there's a variable number of arguments

00:40:51,809 --> 00:40:54,960
depending on the argument, types of flacks

00:40:54,960 --> 00:40:55,928
or something like that

00:40:55,928 --> 00:40:58,095
then that's also a problem

00:40:59,408 --> 00:41:01,975
and one specific example Florian

00:41:01,975 --> 00:41:05,308
has given is the open or openat syscall,

00:41:08,710 --> 00:41:13,345
which has gained the O_TMPFILE flag at one point

00:41:13,345 --> 00:41:17,947
and obviously, if a wrapper didn't know this flag,

00:41:17,947 --> 00:41:20,974
it wouldn't have passed them mode arguments

00:41:20,974 --> 00:41:23,940
because it wouldn't know it's required

00:41:23,940 --> 00:41:26,857
therefore for this new flag as well

00:41:27,965 --> 00:41:30,509
and some architectures have limitations

00:41:30,509 --> 00:41:32,342
in that you can't call

00:41:34,798 --> 00:41:36,715
variadic function which

00:41:39,213 --> 00:41:43,213
has been declared with a non-variadic prototype.

00:41:46,410 --> 00:41:50,776
So we're not going to handle multiplexing syscalls,

00:41:50,776 --> 00:41:53,496
and we can make examples

00:41:53,496 --> 00:41:56,526
sorry we can make exceptions for the existing examples

00:41:56,526 --> 00:41:57,945
like the futex,

00:41:57,945 --> 00:42:00,703
but in this case this would be

00:42:00,703 --> 00:42:05,453
by using individual wrappers for the individual requests.

00:42:07,761 --> 00:42:10,761
And another point is it's preferable

00:42:12,677 --> 00:42:16,596
if a new syscall is added across all the architectures

00:42:16,596 --> 00:42:19,190
in a single kernel release,

00:42:19,190 --> 00:42:21,755
because otherwise were going to have issues

00:42:21,755 --> 00:42:26,173
by keeping track of which syscall has been added

00:42:26,173 --> 00:42:30,256
to a which release for each of the architectures.

00:42:34,670 --> 00:42:36,365
The matter of interfaces,

00:42:36,365 --> 00:42:38,962
there are some specific types

00:42:38,962 --> 00:42:41,045
that we would like to see

00:42:42,543 --> 00:42:46,043
like a ssize_t or size_t for buffer sizes.

00:42:47,725 --> 00:42:50,298
This is mainly for documentation purposes,

00:42:50,298 --> 00:42:51,965
so that we know what

00:42:54,381 --> 00:42:58,033
the interpretation of the type is even if the kernel uses

00:42:58,033 --> 00:42:59,741
int unsigned int.

00:42:59,741 --> 00:43:03,294
Typically well the unsigness of the type

00:43:03,294 --> 00:43:07,294
will reflect the type of the kernel for example,

00:43:11,105 --> 00:43:12,855
when the buffer sizes

00:43:15,388 --> 00:43:18,787
is an incoming type it will be unsigned,

00:43:18,787 --> 00:43:22,870
but in syscall return value which can be negative

00:43:24,665 --> 00:43:26,212
in the case of an error,

00:43:26,212 --> 00:43:28,295
it will be assigned type.

00:43:34,738 --> 00:43:38,054
- And about multiplex syscalls,

00:43:38,054 --> 00:43:39,945
that includes something like BPF, right?

00:43:39,945 --> 00:43:42,047
For example as if nothing comes to my mind right now.

00:43:42,047 --> 00:43:44,018
And the idea will be to expose them

00:43:44,018 --> 00:43:45,982
to expose the individual sub-commands

00:43:45,982 --> 00:43:48,899
or what ever as individual wrappers

00:43:52,987 --> 00:43:55,754
- Okay, so I just repeat that if for recording

00:43:55,754 --> 00:43:59,171
so the question was about the BPF syscall

00:44:04,808 --> 00:44:07,219
which has a multiplex syscall,

00:44:07,219 --> 00:44:08,444
and it does exist already.

00:44:08,444 --> 00:44:10,529
So yeah, so that will be handled

00:44:10,529 --> 00:44:12,937
by having individual wrappers

00:44:12,937 --> 00:44:15,604
for all the individual requests.

00:44:18,235 --> 00:44:19,559
So, back to the type.

00:44:19,559 --> 00:44:24,142
So we want to have the long type avoided for four flags

00:44:25,187 --> 00:44:28,604
because it's not possible to data mine it

00:44:29,815 --> 00:44:31,815
whether the extra 32 bit

00:44:33,355 --> 00:44:36,768
the extra high 32 bits of the flags will ever be used

00:44:36,768 --> 00:44:40,101
or not on architectures which have them.

00:44:41,453 --> 00:44:44,330
For file offsets the pointer

00:44:44,330 --> 00:44:45,913
to off64_t is fine.

00:44:47,679 --> 00:44:51,839
However, using the type directly is problematic

00:44:51,839 --> 00:44:53,540
because of the differences

00:44:53,540 --> 00:44:55,040
in how it's passed

00:44:57,806 --> 00:44:59,770
across various architectures.

00:44:59,770 --> 00:45:01,758
Obviously it can be in a single register

00:45:01,758 --> 00:45:03,432
or a pair of registers

00:45:03,432 --> 00:45:04,639
and it's even more complex

00:45:04,639 --> 00:45:07,556
for it's return value from syscall.

00:45:09,707 --> 00:45:12,649
So the errno have to be passed via an errnos,

00:45:12,649 --> 00:45:15,314
and a special return value,

00:45:15,314 --> 00:45:19,231
and we make an exception for the pthread calls,

00:45:20,765 --> 00:45:22,848
and it would be very good

00:45:25,345 --> 00:45:28,711
if for each newly added syscall

00:45:28,711 --> 00:45:32,531
all the associated types and constants

00:45:32,531 --> 00:45:36,448
were wrapped into a separate Linux uAPI header.

00:45:39,173 --> 00:45:42,916
Because this way we can have support in glibc

00:45:42,916 --> 00:45:44,416
for all the types,

00:45:45,523 --> 00:45:48,356
and constants define there by just

00:45:50,631 --> 00:45:52,791
using the headers

00:45:52,791 --> 00:45:55,116
from a kernel that's new enough to include that.

00:45:55,116 --> 00:45:58,570
We don't have to make any changes

00:45:58,570 --> 00:46:01,982
to the headers that we already have.

00:46:01,982 --> 00:46:04,160
- Just checking presumably the important thing there

00:46:04,160 --> 00:46:05,820
is that it doesn't contain unrelated stuff,

00:46:05,820 --> 00:46:08,222
and it doesn't contain function prototypes,

00:46:08,222 --> 00:46:09,411
because they clash.

00:46:09,411 --> 00:46:11,306
Yeah, just checking.

00:46:11,306 --> 00:46:12,389
- Okay, yeah.

00:46:14,638 --> 00:46:18,654
Okay, so that's the message essentially.

00:46:18,654 --> 00:46:19,487
Any questions?

00:46:19,487 --> 00:46:20,320
So.

00:46:31,597 --> 00:46:32,597
Okay. - Okay.

00:46:34,583 --> 00:46:36,254
- I guess that's a no.

00:46:36,254 --> 00:46:38,466
- So then the syscall wrapping is clear,

00:46:38,466 --> 00:46:40,736
and there is no problem with him.

00:46:40,736 --> 00:46:41,569
- [Audience] Yeah.

00:46:41,569 --> 00:46:43,693
- Well so then it can change.

00:46:43,693 --> 00:46:47,939
If you totally change from the last (mumbles)

00:46:47,939 --> 00:46:50,232
in Vancouver in November because I was there,

00:46:50,232 --> 00:46:54,592
and I remember that there was a huge problem with dlibc,

00:46:54,592 --> 00:46:56,759
and you guys were going to

00:46:57,599 --> 00:46:59,410
I don't know something very drastic

00:46:59,410 --> 00:47:01,889
because it would not be with it any longer.

00:47:01,889 --> 00:47:03,588
So I am very glad to see that--

00:47:03,588 --> 00:47:05,905
- I mean when it already came up on the mailing list

00:47:05,905 --> 00:47:09,141
everybody pretty quickly agreed that yes, please.

00:47:09,141 --> 00:47:10,218
- Okay, so then,

00:47:10,218 --> 00:47:11,468
who has the....

00:47:13,390 --> 00:47:16,014
Well I don't know at least on translation of Spanish say.

00:47:16,014 --> 00:47:19,437
(audience laughing)

00:47:19,437 --> 00:47:21,943
I mean, who should do what now?

00:47:21,943 --> 00:47:25,193
So because if we are if in the glibc side they are waiting,

00:47:25,193 --> 00:47:28,276
and in the kernel side we're waiting.

00:47:29,144 --> 00:47:30,425
- [Audience] I think new syscalls are trickling

00:47:30,425 --> 00:47:31,415
in on the glibc side

00:47:31,415 --> 00:47:33,640
not fast but it's happening.

00:47:33,640 --> 00:47:34,473
- Okay, fine.

00:47:34,473 --> 00:47:36,412
So, my question is,

00:47:36,412 --> 00:47:37,590
is the current situation

00:47:37,590 --> 00:47:41,090
actually moving to some resolution or not?

00:47:42,196 --> 00:47:46,273
- I'm happy to hear that wrappers are accepted

00:47:46,273 --> 00:47:47,600
or acceptable again

00:47:47,600 --> 00:47:50,850
plus like this used to not be the case.

00:47:52,000 --> 00:47:52,833
- Okay.

00:47:54,839 --> 00:47:58,536
- It might help if somebody would invest in

00:47:58,536 --> 00:48:02,119
enumerating which system calls are missing.

00:48:04,811 --> 00:48:06,336
- [Maciej] Florian has done some of the glibc.

00:48:06,336 --> 00:48:07,169
- Okay.

00:48:07,169 --> 00:48:08,253
- He seems to be on top of--

00:48:08,253 --> 00:48:11,111
- I suspect the perf(1) is missing.

00:48:11,111 --> 00:48:12,649
- That's a classical example

00:48:12,649 --> 00:48:16,127
of a horrifying multiplex system in--

00:48:16,127 --> 00:48:18,397
(audience laughing)

00:48:18,397 --> 00:48:19,564
- It would be.

00:48:21,747 --> 00:48:22,580
So yeah.

00:48:23,418 --> 00:48:25,297
- I have a separate question.

00:48:25,297 --> 00:48:27,884
Can you envision how the kernel

00:48:27,884 --> 00:48:30,604
in the glibc communities might better cooperate

00:48:30,604 --> 00:48:33,212
in the design of syscall APIs?

00:48:33,212 --> 00:48:34,045
So--

00:48:34,045 --> 00:48:35,739
- [Maciej] There's a mailing list for that.

00:48:35,739 --> 00:48:39,656
- Well ad there's a kernel in that mailing list

00:48:41,596 --> 00:48:44,456
but that's where co-operation doesn't seem to be there.

00:48:44,456 --> 00:48:47,137
We hear why it for like this

00:48:47,137 --> 00:48:52,137
that we would prefer syscall to define this way or that way

00:48:52,176 --> 00:48:56,426
and attempts not to get through to the kernel side.

00:48:58,621 --> 00:49:00,626
- Yeah, so let's try this one.

00:49:00,626 --> 00:49:03,487
Okay, so I think what work really nicely

00:49:03,487 --> 00:49:07,070
is for some of this syscall that were added

00:49:08,661 --> 00:49:10,949
over the last two kernel releases.

00:49:10,949 --> 00:49:12,444
Just CC for example,

00:49:12,444 --> 00:49:14,473
either glibc alpha directly

00:49:14,473 --> 00:49:17,873
or what I did is usually Florian

00:49:17,873 --> 00:49:20,655
and so if something goes really wrong,

00:49:20,655 --> 00:49:23,415
he will provide input like this is proof pretty valuable

00:49:23,415 --> 00:49:26,017
for clone for example,

00:49:26,017 --> 00:49:26,918
the one we read.

00:49:26,918 --> 00:49:27,751
So--

00:49:27,751 --> 00:49:31,478
- Can we subscribe Florian to Linux API?

00:49:31,478 --> 00:49:33,145
- I think he. - Okay.

00:49:35,222 --> 00:49:38,222
- It doesn't hurt to get multiple...

00:49:39,060 --> 00:49:42,763
- Linux API is still has a lot of unrelated traffic,

00:49:42,763 --> 00:49:44,842
unrelated to this syscall stuff.

00:49:44,842 --> 00:49:47,259
I mean, so it's quite easy to

00:49:48,894 --> 00:49:53,561
miss the key emails among very interesting inter-kernel.

00:49:57,096 --> 00:50:01,849
So, I think one of the things that I Kind of observed

00:50:01,849 --> 00:50:06,062
is for example what types do you choose for

00:50:06,062 --> 00:50:07,952
from the kernel side

00:50:07,952 --> 00:50:10,618
might not be the same as what glibc is choosing

00:50:10,618 --> 00:50:11,451
in terms of types.

00:50:11,451 --> 00:50:12,699
You had something like this

00:50:12,699 --> 00:50:14,717
but it also goes for example

00:50:14,717 --> 00:50:17,674
which I found out the hard way.

00:50:17,674 --> 00:50:19,680
For structures for example,

00:50:19,680 --> 00:50:20,627
the way it is passed into kernel

00:50:20,627 --> 00:50:24,092
such as we can do it in the same way for all architectures

00:50:24,092 --> 00:50:28,259
it doesn't matter if it's 64 bit, 32 bit or alpha,

00:50:29,690 --> 00:50:32,879
and yeah, exactly then talking to the glibc guys,

00:50:32,879 --> 00:50:35,038
and like these types are acceptable for us

00:50:35,038 --> 00:50:35,974
but we need to provide wrappers

00:50:35,974 --> 00:50:36,807
and so on.

00:50:36,807 --> 00:50:37,772
If you have sizes,

00:50:37,772 --> 00:50:39,772
and syscalls use size t.

00:50:40,623 --> 00:50:42,622
Like for example, there's still sometimes the debate

00:50:42,622 --> 00:50:44,981
when new syscall are added between

00:50:44,981 --> 00:50:47,142
I using an integer for a flag argument

00:50:47,142 --> 00:50:49,023
or an unsigned int or along

00:50:49,023 --> 00:50:51,591
or that probably is stuff

00:50:51,591 --> 00:50:54,811
that could be sort of more standardized

00:50:54,811 --> 00:50:58,085
from the kernel's perspective, I guess.

00:50:58,085 --> 00:50:59,285
- [Audience] Unfortunate the context on syscall

00:50:59,285 --> 00:51:00,118
is not the issue.

00:51:00,118 --> 00:51:04,535
- No, I'm sure but going forward for new ones I mean.

00:51:05,929 --> 00:51:06,762
Yeah.

00:51:08,061 --> 00:51:08,894
Sorry.

00:51:10,546 --> 00:51:11,530
- I have a question about

00:51:11,530 --> 00:51:13,447
so is glibc a place for

00:51:14,872 --> 00:51:16,436
like higher level wrappers around syscall

00:51:16,436 --> 00:51:17,978
rather than just syscall wrappers?

00:51:17,978 --> 00:51:20,665
An example would be there's openat I'm looking on

00:51:20,665 --> 00:51:23,778
where the correct usage actually well

00:51:23,778 --> 00:51:25,114
the most idiomatic usage of it

00:51:25,114 --> 00:51:26,973
would not be to just use openat directly,

00:51:26,973 --> 00:51:30,804
but instead would be to handle pods differently effectively.

00:51:30,804 --> 00:51:32,219
So as you would effectively have like a wrapper

00:51:32,219 --> 00:51:33,451
around a file descriptor

00:51:33,451 --> 00:51:36,042
that you would then use as a handle to a file.

00:51:36,042 --> 00:51:37,398
The point I'm making

00:51:37,398 --> 00:51:38,517
is glibc the right place for that

00:51:38,517 --> 00:51:39,850
or should that be somewhere else.

00:51:39,850 --> 00:51:41,510
Which is the things that I've been battling with.

00:51:41,510 --> 00:51:43,557
- Or both? - Or both, yeah.

00:51:43,557 --> 00:51:45,349
- Well, my understanding is it's

00:51:45,349 --> 00:51:48,938
we only expect the better wrappers

00:51:48,938 --> 00:51:50,674
without a higher level interface.

00:51:50,674 --> 00:51:52,619
I mean, the high level interfaces

00:51:52,619 --> 00:51:55,786
is at the sort of the C library level,

00:51:58,021 --> 00:52:02,180
and that's mainly defined by the ISO C committee

00:52:02,180 --> 00:52:03,013
and such--

00:52:06,694 --> 00:52:09,024
- Except of course, this is not always true

00:52:09,024 --> 00:52:11,661
when open ministry met out where I got glibc first,

00:52:11,661 --> 00:52:14,420
and that's very much a wrapper around the file descriptor.

00:52:14,420 --> 00:52:17,224
Implementing file starter and so on.

00:52:17,224 --> 00:52:19,914
I think the real question is probably that needs

00:52:19,914 --> 00:52:22,964
a lot more design if it's going to get careful design

00:52:22,964 --> 00:52:25,244
if it's going to go into a high level wrapper

00:52:25,244 --> 00:52:26,175
because other architectures,

00:52:26,175 --> 00:52:28,142
and other operating systems might want to use it.

00:52:28,142 --> 00:52:29,350
- That's true.

00:52:29,350 --> 00:52:31,759
- May well end up going straight into POSIX eventually.

00:52:31,759 --> 00:52:33,353
So it's more carry is needed

00:52:33,353 --> 00:52:37,103
the more complicated the interfaces will get.

00:52:44,844 --> 00:52:46,552
- I would just like to add to

00:52:46,552 --> 00:52:51,552
sometimes it's documentation that's stops a adding wrappers

00:52:51,736 --> 00:52:54,052
or rather than a thin piece of code

00:52:54,052 --> 00:52:56,741
because well it's been said already

00:52:56,741 --> 00:52:58,842
that it requires cubertr assignment

00:52:58,842 --> 00:53:01,842
and sometimes it's not easy to write

00:53:02,774 --> 00:53:05,207
a new documentation when a piece of documentation

00:53:05,207 --> 00:53:07,317
on that syscall already exists,

00:53:07,317 --> 00:53:10,096
and the author is not interested.

00:53:10,096 --> 00:53:15,096
He just contributed this documentation along with the commit

00:53:15,227 --> 00:53:18,407
inside of the commit message for example for this syscall,

00:53:18,407 --> 00:53:19,554
and he's not interested,

00:53:19,554 --> 00:53:23,785
and to write a new documentation for the same thing

00:53:23,785 --> 00:53:25,618
it will require either

00:53:27,701 --> 00:53:30,379
a new piece of documentation which is not easy,

00:53:30,379 --> 00:53:34,270
and you can't reuse the already existing documentation

00:53:34,270 --> 00:53:36,086
because it will require a cubertr assignment

00:53:36,086 --> 00:53:37,411
from that person,

00:53:37,411 --> 00:53:38,808
and he is not probably interested

00:53:38,808 --> 00:53:40,911
or is not aware of the thing.

00:53:40,911 --> 00:53:44,695
So it's like it will get co-operation between people

00:53:44,695 --> 00:53:46,778
and it's always not easy.

00:53:47,868 --> 00:53:52,451
- But I think to it boils down to the lack of resources

00:53:54,073 --> 00:53:56,136
because obviously the glibc community

00:53:56,136 --> 00:53:58,972
can help with writing a piece of documentation,

00:53:58,972 --> 00:54:01,096
but someone has actually to do that,

00:54:01,096 --> 00:54:05,072
and people may not necessarily have the time to--

00:54:05,072 --> 00:54:07,205
- I mean, it's not easy to write from scratch

00:54:07,205 --> 00:54:09,701
a documentation for the same little thing.

00:54:09,701 --> 00:54:12,525
And not to do a direct work.

00:54:12,525 --> 00:54:14,919
Yeah but at least when you have a contributor

00:54:14,919 --> 00:54:16,590
you can you can talk to them,

00:54:16,590 --> 00:54:20,286
and sort of ask about the details in an informal way

00:54:20,286 --> 00:54:24,203
and get this the formalize the in this process.

00:54:25,691 --> 00:54:27,598
It's been happening before.

00:54:27,598 --> 00:54:29,189
So it's doable certainly.

00:54:29,189 --> 00:54:33,536
But I mean, the issue is the lack of resources.

00:54:33,536 --> 00:54:35,203
- Right, and I think

00:54:36,392 --> 00:54:38,420
glibc over the last two years at least

00:54:38,420 --> 00:54:40,342
just from my observation has changed a lot

00:54:40,342 --> 00:54:43,301
like in terms also how it operates,

00:54:43,301 --> 00:54:44,954
I think, two or three years ago,

00:54:44,954 --> 00:54:46,049
we tried to get a patch

00:54:46,049 --> 00:54:48,382
and went for this PTI stuff,

00:54:50,504 --> 00:54:53,472
and it like it took us over a year

00:54:53,472 --> 00:54:54,710
or something to get something.

00:54:54,710 --> 00:54:57,843
It was really frustrating to the point where I well

00:54:57,843 --> 00:54:59,288
Florian then wrote me a mail,

00:54:59,288 --> 00:55:01,921
and said like you should get a copyright assignment for FSF,

00:55:01,921 --> 00:55:03,140
and then you can have comment rights

00:55:03,140 --> 00:55:04,865
and then you can push it yourself.

00:55:04,865 --> 00:55:07,007
(audience laughing)

00:55:07,007 --> 00:55:10,647
And I think like that fortunately has changed

00:55:10,647 --> 00:55:12,546
but the word needs to get out.

00:55:12,546 --> 00:55:14,324
I think there's really a community

00:55:14,324 --> 00:55:16,574
that you can now work with.

00:55:17,912 --> 00:55:18,745
Yeah.

00:55:19,853 --> 00:55:21,953
I mean, we just got

00:55:21,953 --> 00:55:25,073
people are really surprised when we got the MFD

00:55:25,073 --> 00:55:26,457
creates syscall wrapper

00:55:26,457 --> 00:55:28,815
and this says get the ideal syscall wrapper.

00:55:28,815 --> 00:55:31,441
I don't know how many years after the syscall--

00:55:31,441 --> 00:55:33,723
- Get the idea then (mumbles)

00:55:33,723 --> 00:55:34,556
- Right.

00:55:34,556 --> 00:55:38,056
- Yeah, nobody ever expected that perhaps.

00:55:39,883 --> 00:55:40,943
I mean it's a little too late now

00:55:40,943 --> 00:55:43,113
because everybody has--

00:55:43,113 --> 00:55:46,113
(audience laughing)

00:55:47,383 --> 00:55:48,589
- So I think

00:55:48,589 --> 00:55:51,843
if that word gets out more people know about this,

00:55:51,843 --> 00:55:54,687
and there's even more interaction right now,

00:55:54,687 --> 00:55:56,308
and I think between the kernel community

00:55:56,308 --> 00:55:58,336
in between the glibc community,

00:55:58,336 --> 00:56:00,183
and I think if we sort of increased that,

00:56:00,183 --> 00:56:02,971
and kind of everyone who's working on

00:56:02,971 --> 00:56:03,849
the kernel side of things

00:56:03,849 --> 00:56:06,689
and then keeps in contact with the glibc guys,

00:56:06,689 --> 00:56:09,253
I think this will improve, hopefully.

00:56:09,253 --> 00:56:13,670
So that we don't have to ship glibc library with LVM.

00:56:21,219 --> 00:56:22,469
- Okay, anyone?

00:56:25,015 --> 00:56:26,236
Okay,

00:56:26,236 --> 00:56:29,116
thank you for coming then

00:56:29,116 --> 00:56:32,229
and we'll pass the message on

00:56:32,229 --> 00:56:36,146
to the junior control Squadron later this week,

00:56:37,485 --> 00:56:40,402
and we'll do our best to cooperate.

00:56:49,139 --> 00:56:50,976
- So just as a small comment

00:56:50,976 --> 00:56:54,267
to question that was asked earlier

00:56:54,267 --> 00:56:57,600
about how can we do to better cooperate.

00:56:59,943 --> 00:57:02,806
Well, let's do this more often.

00:57:02,806 --> 00:57:03,639
Like--

00:57:04,913 --> 00:57:07,075
(audience laughing)

00:57:07,075 --> 00:57:11,491
Yeah like talking here, well like before Cauldron,

00:57:11,491 --> 00:57:12,658
and so this is

00:57:13,817 --> 00:57:15,650
to me this is awesome.

00:57:16,793 --> 00:57:17,626
Oh, yeah

00:57:18,822 --> 00:57:21,674
a lot of times for example it's

00:57:21,674 --> 00:57:23,437
asked to ask ourselves,

00:57:23,437 --> 00:57:26,152
or at least helped me as who has sort of a stake

00:57:26,152 --> 00:57:31,097
in this specific work or specific system call, for example,

00:57:31,097 --> 00:57:32,917
and a lot of times,

00:57:32,917 --> 00:57:36,750
it's glibc for not necessarily obvious reasons

00:57:37,942 --> 00:57:40,207
but asking them for input especially from,

00:57:40,207 --> 00:57:41,040
and you have to give it to him.

00:57:41,040 --> 00:57:44,113
It's like, especially from Florian is really helpful,

00:57:44,113 --> 00:57:46,904
and he's pretty willing to,

00:57:46,904 --> 00:57:49,821
to ask really interesting questions

00:57:50,681 --> 00:57:52,300
that we as kernel developers

00:57:52,300 --> 00:57:54,871
do not necessarily have on our radar,

00:57:54,871 --> 00:57:58,218
because we might have a different perspective on things.

00:57:58,218 --> 00:57:59,246
So that helps a lot.

00:57:59,246 --> 00:58:00,571
Just being,

00:58:00,571 --> 00:58:02,264
also for the glibc community

00:58:02,264 --> 00:58:06,301
more active especially on Linux API would probably help.

00:58:06,301 --> 00:58:07,134
A lot.

00:58:13,958 --> 00:58:14,791
Okay.

00:58:17,464 --> 00:58:18,437
- So thank you.

00:58:18,437 --> 00:58:21,437
(audience clapping)

00:58:24,911 --> 00:58:26,214
So we are a few minutes before 11.

00:58:26,214 --> 00:58:30,014
Can we have a little break of three minutes bathroom break?

00:58:30,014 --> 00:58:31,185
Yep.

00:58:31,185 --> 00:58:34,185
(audience laughing)

01:00:29,645 --> 01:00:31,402
- Apparently even being one chair over.

01:00:31,402 --> 01:00:32,577
- [Audience] So can you talk to me please.

01:00:32,577 --> 01:00:34,827
(laughing)

01:00:36,237 --> 01:00:41,237
- Just amazing to watch you like (laughs).

01:00:41,884 --> 01:00:43,134
Seemed to work.

01:01:31,849 --> 01:01:34,050
You tell me when to go.

01:01:34,050 --> 01:01:35,873
- [Audience] Go, it's all right.

01:01:35,873 --> 01:01:36,860
- Do say yes or no?

01:01:36,860 --> 01:01:37,693
Yes.

01:01:37,693 --> 01:01:38,526
Okay.

01:01:38,526 --> 01:01:40,922
All right, I'll go.

01:01:40,922 --> 01:01:41,755
Okay.

01:01:52,542 --> 01:01:53,872
Ready?

01:01:53,872 --> 01:01:54,705
Okay.

01:01:58,208 --> 01:01:59,751
Hi, I'm Case.

01:01:59,751 --> 01:02:02,274
This was just an idea about I'm

01:02:02,274 --> 01:02:07,115
trying to call attention to some of the security features,

01:02:07,115 --> 01:02:09,518
and like security flaw mitigation work

01:02:09,518 --> 01:02:13,185
that's in various compiler, tool chains now.

01:02:14,834 --> 01:02:16,595
There's a lot of work happening,

01:02:16,595 --> 01:02:18,090
especially on that Clang side

01:02:18,090 --> 01:02:21,189
to get things up to speed for building Linux kernel,

01:02:21,189 --> 01:02:23,415
and there's tons of work happening there

01:02:23,415 --> 01:02:26,155
and it's good but I wanted to try to call attention

01:02:26,155 --> 01:02:29,866
and raise the priority of some general security features.

01:02:29,866 --> 01:02:32,083
So what I mean looking back at like

01:02:32,083 --> 01:02:34,240
old school security feature examples,

01:02:34,240 --> 01:02:36,710
stack canaries and uninitialized variables

01:02:36,710 --> 01:02:38,547
and format strings like these

01:02:38,547 --> 01:02:41,728
are should be pretty familiar at this point.

01:02:41,728 --> 01:02:44,191
These are well supported,

01:02:44,191 --> 01:02:46,084
although we do occasionally see bugs

01:02:46,084 --> 01:02:47,777
and various pieces of it

01:02:47,777 --> 01:02:51,035
but these are sort of the things that we're

01:02:51,035 --> 01:02:55,136
I would call we're done with on the tool chain side

01:02:55,136 --> 01:03:00,045
and this this presentation is mainly these pieces

01:03:00,045 --> 01:03:03,184
of what I'm gonna go through in the following slides

01:03:03,184 --> 01:03:04,715
and get into what's missing

01:03:04,715 --> 01:03:08,089
and what I'd really like to see.

01:03:08,089 --> 01:03:11,906
There's a lot of like patches or plugins

01:03:11,906 --> 01:03:13,739
or half working things

01:03:14,674 --> 01:03:17,287
But I'm just gonna jump in,

01:03:17,287 --> 01:03:22,043
and you can download the slides to from the first page.

01:03:22,043 --> 01:03:23,757
So I'm gonna start with the easy stuff,

01:03:23,757 --> 01:03:25,946
which was a per-function sections.

01:03:25,946 --> 01:03:27,101
This works.

01:03:27,101 --> 01:03:27,934
It's good.

01:03:28,876 --> 01:03:30,203
I just wanted to call it out as...

01:03:30,203 --> 01:03:31,036
This is an easy one,

01:03:31,036 --> 01:03:32,863
it's done (laughs).

01:03:32,863 --> 01:03:34,308
But this is mainly for

01:03:34,308 --> 01:03:36,629
the reason I've been interested in it is

01:03:36,629 --> 01:03:39,379
that it supports fine-grain ASLR.

01:03:40,299 --> 01:03:43,364
So if you have a separate section for every function,

01:03:43,364 --> 01:03:44,829
at kernel boot time,

01:03:44,829 --> 01:03:48,949
you can actually randomize all of the functions.

01:03:48,949 --> 01:03:52,522
So suddenly you get extremely fine-grain,

01:03:52,522 --> 01:03:54,355
ASLR the entire kernel

01:03:55,396 --> 01:04:00,082
because you can just randomize the section locations.

01:04:00,082 --> 01:04:02,665
Which is bizarre and wonderful.

01:04:04,448 --> 01:04:07,216
One that we've been working on a whole bunch lately

01:04:07,216 --> 01:04:09,773
is the switch case fall through.

01:04:09,773 --> 01:04:12,322
So in the C switch case,

01:04:12,322 --> 01:04:13,700
you can specify break,

01:04:13,700 --> 01:04:17,535
but you don't specify fall through you just leave out break.

01:04:17,535 --> 01:04:19,238
But that doesn't indicate if you meant to fall through

01:04:19,238 --> 01:04:20,651
or not.

01:04:20,651 --> 01:04:25,401
So implicit fall through was already in both tool chains.

01:04:26,786 --> 01:04:29,777
But Clang did not support the fall through attribute

01:04:29,777 --> 01:04:31,270
until very recently,

01:04:31,270 --> 01:04:33,822
and GCC actually parses the comments,

01:04:33,822 --> 01:04:36,239
looking for markings as well.

01:04:37,446 --> 01:04:39,010
(audience laughing)

01:04:39,010 --> 01:04:40,410
- [Audience] It was linked? - Yeah.

01:04:40,410 --> 01:04:43,514
So it was to have GCC's parsing of that

01:04:43,514 --> 01:04:46,134
was to have parody with the IDEs

01:04:46,134 --> 01:04:47,562
and all sorts of other things

01:04:47,562 --> 01:04:50,341
prior to this being standardized,

01:04:50,341 --> 01:04:53,051
and Clang has said quite loudly

01:04:53,051 --> 01:04:57,502
that they will not be parsing comments (laughing)

01:04:57,502 --> 01:04:59,585
and the kernel is free of

01:05:00,521 --> 01:05:02,568
implicit fall through at this point,

01:05:02,568 --> 01:05:05,235
mostly thanks to Gustavo's work.

01:05:07,588 --> 01:05:10,934
And like in the roughly 500 patches,

01:05:10,934 --> 01:05:12,543
just in the last year alone,

01:05:12,543 --> 01:05:16,305
about 10% of those warnings were real bugs.

01:05:16,305 --> 01:05:20,388
So it was actually a pretty high number of those,

01:05:21,282 --> 01:05:24,181
like actual missing breaks in the kernel.

01:05:24,181 --> 01:05:27,777
So this has proven a good thing to turn on

01:05:27,777 --> 01:05:31,110
and a nice change to make in the kernels

01:05:32,736 --> 01:05:34,236
sort of C dialect,

01:05:36,649 --> 01:05:38,700
and that we don't want to have

01:05:38,700 --> 01:05:42,726
implicit fall through anywhere anymore.

01:05:42,726 --> 01:05:43,681
Link time optimization.

01:05:43,681 --> 01:05:48,182
This is another one that works in both tool chains.

01:05:48,182 --> 01:05:50,471
It's required for control flow integrity,

01:05:50,471 --> 01:05:51,514
because you need to have visibility

01:05:51,514 --> 01:05:54,141
across all of the functions simultaneously.

01:05:54,141 --> 01:05:55,972
At one point

01:05:55,972 --> 01:05:56,990
there's kind of a lot of pain

01:05:56,990 --> 01:06:01,219
in updating the build systems to support LTO

01:06:01,219 --> 01:06:03,858
because you don't have

01:06:03,858 --> 01:06:05,187
you have intermediate states,

01:06:05,187 --> 01:06:09,294
you don't have actual object files as you build,

01:06:09,294 --> 01:06:10,835
and there are still questions about

01:06:10,835 --> 01:06:13,582
the differences between Cs memory model

01:06:13,582 --> 01:06:14,882
and the kernel's memory model.

01:06:14,882 --> 01:06:19,147
And there's some worries that those don't match.

01:06:19,147 --> 01:06:22,427
Although no one has been able to provide a specific example.

01:06:22,427 --> 01:06:23,946
- I don't know if there are.

01:06:23,946 --> 01:06:25,863
Is the consumer, right?

01:06:29,761 --> 01:06:32,377
- [Audience] There's an entire C standards document

01:06:32,377 --> 01:06:34,192
written by Paul McKenney on this issue.

01:06:34,192 --> 01:06:35,625
They do not match.

01:06:35,625 --> 01:06:36,458
- Right?

01:06:36,458 --> 01:06:37,957
Oh, no I agree they don't match.

01:06:37,957 --> 01:06:41,106
But no one has proven that using LTO

01:06:41,106 --> 01:06:42,567
suddenly produces the bugs

01:06:42,567 --> 01:06:46,061
and no one can come up with an example of it.

01:06:46,061 --> 01:06:48,857
I don't disagree that theoretically there's a problem.

01:06:48,857 --> 01:06:49,690
- [Audience] Okay.

01:06:49,690 --> 01:06:52,603
- But the practicality is sort what matters here,

01:06:52,603 --> 01:06:56,936
and being able to declare a way to keep people happy

01:06:58,146 --> 01:07:02,396
about using LTO in The face of the different memory models.

01:07:02,396 --> 01:07:03,229
- Yeah so I would still love--

01:07:03,229 --> 01:07:04,062
- There's still something to be solved.

01:07:04,062 --> 01:07:05,816
- I would love to sit around

01:07:05,816 --> 01:07:08,270
with some of the actual compiler people

01:07:08,270 --> 01:07:10,063
and I'm preferably both GCC

01:07:10,063 --> 01:07:12,146
and Lium at the same time

01:07:13,605 --> 01:07:15,163
and get this sorted out.

01:07:15,163 --> 01:07:15,996
- [Case] Great.

01:07:15,996 --> 01:07:18,852
- Because it's waiting for to C standard committee

01:07:18,852 --> 01:07:20,045
to get their hair untangled.

01:07:20,045 --> 01:07:22,516
It's just not gonna happen.

01:07:22,516 --> 01:07:24,122
- Right?

01:07:24,122 --> 01:07:25,162
I would like that too.

01:07:25,162 --> 01:07:26,458
It's coming up quickly.

01:07:26,458 --> 01:07:29,541
We're gonna need to have this solved.

01:07:46,507 --> 01:07:49,590
- The C standard job is not to create

01:07:51,351 --> 01:07:53,584
the thing that we should be using.

01:07:53,584 --> 01:07:58,584
- It is to ratify what people already want to be happening.

01:07:58,807 --> 01:08:00,886
So - [Audience] You hope.

01:08:00,886 --> 01:08:02,548
- I hope, yes.

01:08:02,548 --> 01:08:03,506
(audience laughing)

01:08:03,506 --> 01:08:06,380
I know some of the people involved too,

01:08:06,380 --> 01:08:07,213
and

01:08:08,963 --> 01:08:10,722
they have told me

01:08:10,722 --> 01:08:14,805
that they have learned that lesson several times.

01:08:19,543 --> 01:08:20,376
- [Audience] This is about the pointer end

01:08:20,376 --> 01:08:22,553
of live semantics right there.

01:08:22,553 --> 01:08:24,207
- Old, so there is that.

01:08:24,207 --> 01:08:25,040
There's the end of life.

01:08:25,040 --> 01:08:25,873
There is,

01:08:26,729 --> 01:08:28,088
what's the other one?

01:08:28,088 --> 01:08:29,338
Drawing point of provenance

01:08:29,338 --> 01:08:32,200
which is an absolutely disgusting thing.

01:08:32,200 --> 01:08:35,283
There's the whole memory model thing.

01:08:37,012 --> 01:08:38,686
Dependency ordering,

01:08:38,686 --> 01:08:42,853
there is control dependencies which C just not do.

01:08:45,854 --> 01:08:47,391
There's a number of other things,

01:08:47,391 --> 01:08:48,558
but basically,

01:08:49,793 --> 01:08:51,269
I'm scared of compilers.

01:08:51,269 --> 01:08:54,436
(audience laughing)

01:08:54,436 --> 01:08:55,769
- [Case] Me too.

01:08:58,663 --> 01:09:01,927
Yeah, so anyway there's work to be done

01:09:01,927 --> 01:09:04,452
not in necessarily LTO itself,

01:09:04,452 --> 01:09:07,814
but in resolving the visibility

01:09:07,814 --> 01:09:10,147
and the memory model issues.

01:09:11,726 --> 01:09:14,907
So, stack probing was added to GCC.

01:09:14,907 --> 01:09:17,228
Clang is still lacks this,

01:09:17,228 --> 01:09:19,760
this was as you use a VLA or alloca

01:09:19,760 --> 01:09:24,521
will actually read the stack in small bite offsets

01:09:24,521 --> 01:09:28,854
to verify that you actually can get to that mapping.

01:09:30,360 --> 01:09:32,179
From my perspective, this is now only interesting

01:09:32,179 --> 01:09:34,425
for user space because the kernel is completely eliminated

01:09:34,425 --> 01:09:37,105
to the use of VLAs and alloca.

01:09:37,105 --> 01:09:40,307
And in the year that we took to do it,

01:09:40,307 --> 01:09:41,815
systemd had two

01:09:41,815 --> 01:09:44,641
exploitable alloca vulnerabilities.

01:09:44,641 --> 01:09:46,885
So it's has been my strong recommendation

01:09:46,885 --> 01:09:48,635
that nobody use VLAs.

01:09:49,649 --> 01:09:50,482
What?

01:09:52,192 --> 01:09:54,025
(audience laughing)

01:09:54,025 --> 01:09:56,058
- I'm not gonna stand here and say that,

01:09:56,058 --> 01:09:57,975
but you can have a mic.

01:09:59,552 --> 01:10:02,007
So again, this is another case of effectively

01:10:02,007 --> 01:10:04,840
changing the dialect of the kernel

01:10:05,680 --> 01:10:08,796
using the options that we've got.

01:10:08,796 --> 01:10:12,157
But if you must use VLAs for some reason,

01:10:12,157 --> 01:10:15,990
having stack clash protection turn on is nice.

01:10:17,523 --> 01:10:20,792
And there's Spectre-V1 mitigation.

01:10:20,792 --> 01:10:25,500
In Clang this exists as the speculative load hardening.

01:10:25,500 --> 01:10:28,685
The performance impact is pretty high,

01:10:28,685 --> 01:10:30,908
but it's better than using offense everywhere.

01:10:30,908 --> 01:10:32,996
And I think it's aided GCC,

01:10:32,996 --> 01:10:33,829
but maybe I'm gonna get corrected.

01:10:33,829 --> 01:10:38,664
- Is it the eucharistic that mostly works or is it solid?

01:10:38,664 --> 01:10:40,156
- My understanding is that it's solid,

01:10:40,156 --> 01:10:43,718
but that's why there's kind of a large performance hit.

01:10:43,718 --> 01:10:46,038
- If I could just note, fstack clash protection

01:10:46,038 --> 01:10:47,479
isn't just needed for VLAs

01:10:47,479 --> 01:10:49,717
although VLAs are an extreme case.

01:10:49,717 --> 01:10:51,060
It's needed for any function

01:10:51,060 --> 01:10:53,054
called with very large local variables.

01:10:53,054 --> 01:10:55,013
So you can't avoid it just by not calling out.

01:10:55,013 --> 01:10:56,779
Okay, you have to avoid it

01:10:56,779 --> 01:10:59,255
by bounding the size of your local variables

01:10:59,255 --> 01:11:00,266
to be less than a page.

01:11:00,266 --> 01:11:03,440
Which seems a little inconvenient for the general case.

01:11:03,440 --> 01:11:06,513
Fstack clash protection is easier.

01:11:06,513 --> 01:11:10,319
- Yes, so having large recursion for example,

01:11:10,319 --> 01:11:12,004
you have an issue with that.

01:11:12,004 --> 01:11:12,837
- [Audience] Using the same--

01:11:12,837 --> 01:11:14,238
- This is less of an issue in the kernel.

01:11:14,238 --> 01:11:19,238
- [Audience] Yeah, using a page worth of on stack data

01:11:19,332 --> 01:11:21,730
is an absolute no go in the kernel.

01:11:21,730 --> 01:11:24,188
- Yeah you can see this is a user space programmer's--

01:11:24,188 --> 01:11:25,984
- In user space, it's still quite valid

01:11:25,984 --> 01:11:30,984
which is why it's good to have it in all the tool chains,

01:11:31,339 --> 01:11:34,172
so we don't recur this flaw again.

01:11:40,916 --> 01:11:41,749
Anyway, yeah.

01:11:41,749 --> 01:11:45,332
So another note about the V1 mitigation is,

01:11:46,397 --> 01:11:47,555
I believe in looking through this,

01:11:47,555 --> 01:11:50,758
there's a function attribute you can set

01:11:50,758 --> 01:11:53,075
so you don't have to globally enable it.

01:11:53,075 --> 01:11:54,596
You can globally enable it,

01:11:54,596 --> 01:11:58,513
but you can also do it on a per function basis.

01:11:59,687 --> 01:12:03,520
I still wanna spend more time looking at this.

01:12:05,718 --> 01:12:07,979
This is an interesting one

01:12:07,979 --> 01:12:10,908
that's in the clear Linux patches to GCC.

01:12:10,908 --> 01:12:11,992
So this is a patch only,

01:12:11,992 --> 01:12:13,659
but to an older GCC.

01:12:14,753 --> 01:12:17,570
This doesn't appear to be landing upstream,

01:12:17,570 --> 01:12:19,548
it would be nice.

01:12:19,548 --> 01:12:21,560
There's nothing like it and Clang at all

01:12:21,560 --> 01:12:23,827
but that is to wipe all of the colleagues

01:12:23,827 --> 01:12:25,564
saved registers on return,

01:12:25,564 --> 01:12:29,780
which has a surprisingly small performance impact.

01:12:29,780 --> 01:12:34,775
Because x of the register itself gets pipelined away

01:12:34,775 --> 01:12:36,192
very efficiently.

01:12:37,301 --> 01:12:41,161
The idea here was this was designed to keep registers

01:12:41,161 --> 01:12:42,377
as clear as possible,

01:12:42,377 --> 01:12:45,173
so they can't be used for leaking data in and out

01:12:45,173 --> 01:12:47,786
of all kinds of things for side channels

01:12:47,786 --> 01:12:48,629
and other stuff.

01:12:48,629 --> 01:12:50,046
So to me this was

01:12:51,712 --> 01:12:54,226
a low performance hit easy thing to do

01:12:54,226 --> 01:12:55,974
but requires some internals

01:12:55,974 --> 01:12:58,832
at the architecture level to enable.

01:12:58,832 --> 01:13:01,623
- So I know we do register clearing

01:13:01,623 --> 01:13:03,408
on system call boundaries

01:13:03,408 --> 01:13:07,033
But what exactly does this mitigate in-kernel

01:13:07,033 --> 01:13:09,783
across every other function call.

01:13:11,942 --> 01:13:13,947
- I think we should ask (mumbles)

01:13:13,947 --> 01:13:17,852
more specifically he was the one driving this change

01:13:17,852 --> 01:13:19,352
but it seemed like

01:13:20,742 --> 01:13:23,423
to me it seemed like a low cost way to just say

01:13:23,423 --> 01:13:26,257
now we don't have to worry about those registers anywhere.

01:13:26,257 --> 01:13:29,065
- Yeah so I'd love for solid security features

01:13:29,065 --> 01:13:31,262
to actually have a proper description

01:13:31,262 --> 01:13:33,290
of what we're mitigating for.

01:13:33,290 --> 01:13:34,159
I mean it's low cost,

01:13:34,159 --> 01:13:35,520
but it's still a cost.

01:13:35,520 --> 01:13:37,766
I mean, it's a death by 1000 cuts

01:13:37,766 --> 01:13:40,656
and if it doesn't actually help anything--

01:13:40,656 --> 01:13:41,489
- [Case] Yeah.

01:13:41,489 --> 01:13:42,636
- We really shouldn't be doing it.

01:13:42,636 --> 01:13:45,114
- Well, the issue the argument was

01:13:45,114 --> 01:13:50,047
we end up with a lot of side channels through side effects,

01:13:50,047 --> 01:13:52,918
and trying to control as many side effects

01:13:52,918 --> 01:13:56,251
and to bring as much of the architecture

01:13:57,129 --> 01:14:00,074
into a known state at a regular basis.

01:14:00,074 --> 01:14:03,599
Reduces how much or where the leakage can happen

01:14:03,599 --> 01:14:07,801
even when we don't know where it's gonna show up next.

01:14:07,801 --> 01:14:10,009
Which is sort of a weird,

01:14:10,009 --> 01:14:12,227
scattered approach to trying to solve it

01:14:12,227 --> 01:14:14,697
because we don't know what's coming next

01:14:14,697 --> 01:14:17,775
as we are beaten over the head with side channel

01:14:17,775 --> 01:14:20,025
after side channel problem.

01:14:21,519 --> 01:14:23,954
But perhaps the poor justification

01:14:23,954 --> 01:14:26,287
is why it's not in upstream.

01:14:27,368 --> 01:14:28,783
- But this would be many are concern

01:14:28,783 --> 01:14:32,155
for hand written functions, right?

01:14:32,155 --> 01:14:32,988
Because otherwise,

01:14:32,988 --> 01:14:37,290
it would be like a compiler bug basically.

01:14:37,290 --> 01:14:39,941
I mean, (mumbles) certainly should be saved,

01:14:39,941 --> 01:14:42,145
and the code generated by the compiler

01:14:42,145 --> 01:14:43,788
should be assuring you that.

01:14:43,788 --> 01:14:45,392
- Well know this is

01:14:45,392 --> 01:14:46,721
so if it's Kali saved,

01:14:46,721 --> 01:14:48,319
you don't have to do anything with it.

01:14:48,319 --> 01:14:49,152
You can just return

01:14:49,152 --> 01:14:51,299
and you can leave whatever state was in your registers.

01:14:51,299 --> 01:14:52,718
The idea is just wipe everything

01:14:52,718 --> 01:14:54,657
that got touched in that function.

01:14:54,657 --> 01:14:55,490
- Okay--

01:14:55,490 --> 01:14:56,613
- Just wipe out the registers completely.

01:14:56,613 --> 01:14:58,143
So there's nothing left over

01:14:58,143 --> 01:15:01,202
- And what's the status of that patch?

01:15:01,202 --> 01:15:03,452
(mumbling)

01:15:05,297 --> 01:15:07,103
- Sorry, yes I should rephrase that--

01:15:07,103 --> 01:15:08,002
- I was a bit confused.

01:15:08,002 --> 01:15:08,835
- Sorry.

01:15:10,033 --> 01:15:12,249
- And what's the status of the patch.

01:15:12,249 --> 01:15:14,106
Has been submitted to GCC patch?

01:15:14,106 --> 01:15:17,314
- I couldn't find it submitted anywhere,

01:15:17,314 --> 01:15:20,042
and it's against an older GCC.

01:15:20,042 --> 01:15:23,411
So I'm not sure why it hasn't gone anywhere.

01:15:23,411 --> 01:15:25,069
- Okay, so we should do something about it

01:15:25,069 --> 01:15:26,187
if you want that in.

01:15:26,187 --> 01:15:27,565
- [Case] Okay. - Yeah.

01:15:27,565 --> 01:15:29,982
I'll go poke Aryan some more.

01:15:35,304 --> 01:15:39,584
So this is another C dialect desire in the kernel

01:15:39,584 --> 01:15:43,917
is to have stack variables auto-initialized to zero.

01:15:45,140 --> 01:15:49,557
Where most of the way technically in Clang with this.

01:15:51,706 --> 01:15:54,052
There was a lot of debate over

01:15:54,052 --> 01:15:58,404
not wanting to support zeroing of stack variables

01:15:58,404 --> 01:16:00,235
because it was viewed as a

01:16:00,235 --> 01:16:01,698
Language fork,

01:16:01,698 --> 01:16:05,417
because now you can depend on your stack variables

01:16:05,417 --> 01:16:07,895
if you don't initialize them as being zero.

01:16:07,895 --> 01:16:10,967
- And this very much includes padding and holes.

01:16:10,967 --> 01:16:12,384
- [Case] Correct,

01:16:13,293 --> 01:16:16,293
and that works and in Clang.

01:16:16,293 --> 01:16:20,748
Linus has been pretty explicit about wanting it to be zeroed

01:16:20,748 --> 01:16:23,069
not uninitialized.

01:16:23,069 --> 01:16:26,330
So Clang's implementation right now adds a bit pattern

01:16:26,330 --> 01:16:29,129
instead of zeroing which is fine

01:16:29,129 --> 01:16:31,009
for avoiding on initialized variables,

01:16:31,009 --> 01:16:33,176
but it's not great for how

01:16:34,102 --> 01:16:38,723
Linus sort of views the future of that kind of thing.

01:16:38,723 --> 01:16:40,610
There was a patch a couple of years ago

01:16:40,610 --> 01:16:44,085
from Florian that didn't go anywhere.

01:16:44,085 --> 01:16:46,926
There were some conflicts over well,

01:16:46,926 --> 01:16:50,168
do we no longer get an initialize variable warnings now,

01:16:50,168 --> 01:16:54,319
so there was an idea of wanting to split auto-initialization

01:16:54,319 --> 01:16:55,986
from unused variable

01:16:56,847 --> 01:16:58,781
or uninitialized variable detection

01:16:58,781 --> 01:17:00,852
and still being able to warn about it

01:17:00,852 --> 01:17:01,735
even though it got zeroed

01:17:01,735 --> 01:17:04,876
and there were complexities about that.

01:17:04,876 --> 01:17:07,095
There's a plugin in the kernel

01:17:07,095 --> 01:17:09,435
that does the initialization

01:17:09,435 --> 01:17:14,265
but it's pretty late in the compilation process.

01:17:14,265 --> 01:17:17,517
So it ends up doing some bizarre tricks

01:17:17,517 --> 01:17:19,638
that confuse other things like case,

01:17:19,638 --> 01:17:23,312
and stuff like that would be nicer to have this natively

01:17:23,312 --> 01:17:25,184
in the compiler having an earlier stage

01:17:25,184 --> 01:17:29,934
and it can be correctly optimized throughout the process.

01:17:33,584 --> 01:17:35,086
So yeah,

01:17:35,086 --> 01:17:35,919
starting on this

01:17:35,919 --> 01:17:38,404
and finishing the getting the zero

01:17:38,404 --> 01:17:41,726
as an official thing in Clang is pretty high on the list,

01:17:41,726 --> 01:17:44,501
but at the very least we can do it in the kernel

01:17:44,501 --> 01:17:47,426
and get stack nationalization.

01:17:47,426 --> 01:17:49,542
- [Audience] Sorry, does Clang have it or Clang doesn't?

01:17:49,542 --> 01:17:51,938
- So Clang has the pattern option.

01:17:51,938 --> 01:17:52,771
So,

01:17:54,606 --> 01:17:56,750
I can say, hey if you're building with Clang,

01:17:56,750 --> 01:17:58,122
and you turn this on

01:17:58,122 --> 01:18:02,133
now you don't have any uninitiated variables on the stack.

01:18:02,133 --> 01:18:03,560
They are initialized.

01:18:03,560 --> 01:18:04,409
They are not zeroed.

01:18:04,409 --> 01:18:05,881
So they have a,

01:18:05,881 --> 01:18:10,478
like an the HEX-AA pattern in most of the bytes

01:18:10,478 --> 01:18:12,789
depending on your architecture,

01:18:12,789 --> 01:18:14,411
the type that's there.

01:18:14,411 --> 01:18:18,165
Like it's an incredibly complex set of things

01:18:18,165 --> 01:18:18,998
that they want to do.

01:18:18,998 --> 01:18:20,212
- [Audience] And yet it's all trivial?

01:18:20,212 --> 01:18:21,944
- Yes, exactly.

01:18:21,944 --> 01:18:23,527
I don't understand.

01:18:24,431 --> 01:18:27,812
And in the kernel has a pretty large set of tests

01:18:27,812 --> 01:18:30,763
for this looking for padding and other things.

01:18:30,763 --> 01:18:33,513
And so all that gets initialized.

01:18:34,347 --> 01:18:36,128
Anyway, so getting this I talked about this last year

01:18:36,128 --> 01:18:38,878
trying to get a foothold on this.

01:18:40,175 --> 01:18:41,508
Anyway, so yeah,

01:18:42,705 --> 01:18:43,954
I think the main argument

01:18:43,954 --> 01:18:47,092
to just make sure it's up in front is like,

01:18:47,092 --> 01:18:49,199
this does fork C,

01:18:49,199 --> 01:18:52,402
like suddenly you do have like stack variables are zero

01:18:52,402 --> 01:18:54,454
if you don't do anything to them,

01:18:54,454 --> 01:18:56,657
which is a pretty radical change.

01:18:56,657 --> 01:18:58,792
- I suspect trivial and it specifically means

01:18:58,792 --> 01:19:01,250
doesn't then expect this to work for C++ classes,

01:19:01,250 --> 01:19:03,981
which are plain old beta

01:19:03,981 --> 01:19:06,589
or something like that.

01:19:06,589 --> 01:19:07,422
I don't know.

01:19:07,422 --> 01:19:10,404
But I am pretty sure it does cover the C++

01:19:10,404 --> 01:19:13,841
knowing the people who are involved in it.

01:19:13,841 --> 01:19:14,799
But I won't,

01:19:14,799 --> 01:19:18,600
I can't say for sure I haven't looked at that.

01:19:18,600 --> 01:19:20,589
A delightfully insane features

01:19:20,589 --> 01:19:23,846
the structure layout randomization.

01:19:23,846 --> 01:19:24,679
- [Audience] I hate it.

01:19:24,679 --> 01:19:26,604
(audience laughing)

01:19:26,604 --> 01:19:29,417
- It's for really paranoid builds.

01:19:29,417 --> 01:19:32,989
There's a GCC plugin that does this,

01:19:32,989 --> 01:19:35,638
and Clang has a stalled version of this

01:19:35,638 --> 01:19:40,453
that was done as sort of a port of the GCC plugin.

01:19:40,453 --> 01:19:42,894
- [Audience] Well it's good for that.

01:19:42,894 --> 01:19:45,273
- But ultimately it's just an attribute

01:19:45,273 --> 01:19:49,770
on structure definitions and you get a randomized based on

01:19:49,770 --> 01:19:52,641
you can have a seed in your in your build tree.

01:19:52,641 --> 01:19:54,835
So if you build multiple times,

01:19:54,835 --> 01:19:56,790
you can have a static seed,

01:19:56,790 --> 01:19:57,623
but if you blow that away,

01:19:57,623 --> 01:19:58,608
you'll get a different layout of the structures

01:19:58,608 --> 01:20:00,191
that you've marked.

01:20:01,410 --> 01:20:04,075
The plugin also has a mode where

01:20:04,075 --> 01:20:06,631
if your structure contains only function pointers,

01:20:06,631 --> 01:20:09,596
it will randomize those automatically,

01:20:09,596 --> 01:20:13,929
which I think in the Clang port was a separate flag.

01:20:14,777 --> 01:20:18,409
Anyway, this isn't in my view needed,

01:20:18,409 --> 01:20:20,249
but it is really fun for paranoid builds

01:20:20,249 --> 01:20:23,243
because it changes the target layout

01:20:23,243 --> 01:20:25,673
from the attackers perspective.

01:20:25,673 --> 01:20:29,098
Why have kernel ASLR when you can have like,

01:20:29,098 --> 01:20:29,931
code ASLR.

01:20:33,343 --> 01:20:34,948
- It does slow things down.

01:20:34,948 --> 01:20:37,749
I did some checking on a really a piece of hardware

01:20:37,749 --> 01:20:39,618
and it's really by about five to 7%,

01:20:39,618 --> 01:20:41,490
presumably it's all the cache optimization

01:20:41,490 --> 01:20:42,792
and so on has been blown away.

01:20:42,792 --> 01:20:45,084
- Yeah, so the plugin the way it was written,

01:20:45,084 --> 01:20:46,595
you can have a performance mode

01:20:46,595 --> 01:20:49,822
that doesn't randomize outside of the cache line.

01:20:49,822 --> 01:20:50,655
Which is interesting,

01:20:50,655 --> 01:20:53,130
but it's still completely insane.

01:20:53,130 --> 01:20:55,174
It's a lovely feature.

01:20:55,174 --> 01:20:59,101
I could spin it as it's good for debugging.

01:20:59,101 --> 01:21:02,600
(audience laughing)

01:21:02,600 --> 01:21:06,183
We found some interesting problems with it.

01:21:08,141 --> 01:21:13,141
So signed overflow is technically an undefined behavior,

01:21:13,296 --> 01:21:15,995
but you can specify it being defined.

01:21:15,995 --> 01:21:18,800
- We all specified as being defined.

01:21:18,800 --> 01:21:22,161
It still compliments-- - [Case] Yeah.

01:21:22,161 --> 01:21:24,828
Yeah, so in the kernel C dialect

01:21:25,688 --> 01:21:28,855
we have defined this as just wrapping.

01:21:30,481 --> 01:21:34,057
But it tends to be unexpected behavior.

01:21:34,057 --> 01:21:36,740
There are places where we wrap.

01:21:36,740 --> 01:21:40,063
I haven't found any intentional signed overflow

01:21:40,063 --> 01:21:43,164
outside of like the reference counter stuff,

01:21:43,164 --> 01:21:43,997
but

01:21:45,987 --> 01:21:48,500
almost always you don't want the result

01:21:48,500 --> 01:21:50,833
from your assigned overflow.

01:21:53,389 --> 01:21:56,248
You can actually add the test for this.

01:21:56,248 --> 01:21:58,074
This works in both tool chains,

01:21:58,074 --> 01:22:00,851
if you just sort of fail

01:22:00,851 --> 01:22:02,047
it's awesome.

01:22:02,047 --> 01:22:04,401
Like there's very little code size change,

01:22:04,401 --> 01:22:05,908
there's very little performance change

01:22:05,908 --> 01:22:07,991
because it's a flag test.

01:22:09,136 --> 01:22:10,878
And that just disappears into the cycle counts.

01:22:10,878 --> 01:22:14,031
So it's runtime wise, it's fine.

01:22:14,031 --> 01:22:16,303
However, when you turn on actual warnings,

01:22:16,303 --> 01:22:18,008
you can get meaningful output.

01:22:18,008 --> 01:22:20,364
Your object size increases like by 6%,

01:22:20,364 --> 01:22:24,108
just from all of the strings that got added,

01:22:24,108 --> 01:22:27,062
describing to all the places where

01:22:27,062 --> 01:22:30,113
your potential math has overflowed.

01:22:30,113 --> 01:22:32,992
I'd really like to have this be a user-defined handler

01:22:32,992 --> 01:22:35,891
where we could have an explicit exception,

01:22:35,891 --> 01:22:38,093
like sort of like bug and warn you already

01:22:38,093 --> 01:22:39,368
and then we can just say,

01:22:39,368 --> 01:22:40,621
oh, what happened over there

01:22:40,621 --> 01:22:45,425
and we don't have to have them massive text size change.

01:22:45,425 --> 01:22:49,355
Another piece is right now there's the die mode

01:22:49,355 --> 01:22:50,924
where oh no,

01:22:50,924 --> 01:22:55,013
I've overflowed till everything which is not helpful or warn

01:22:55,013 --> 01:22:57,188
and continue with whatever the bed value was,

01:22:57,188 --> 01:22:58,382
which has wrapped around.

01:22:58,382 --> 01:23:00,701
I'd really like to have a warning

01:23:00,701 --> 01:23:02,655
but continue with the saturated value,

01:23:02,655 --> 01:23:04,966
like don't actually wrap stop

01:23:04,966 --> 01:23:07,799
at a large at int max or whatever.

01:23:09,817 --> 01:23:10,650
Because most of the time,

01:23:10,650 --> 01:23:11,706
if you're passing into an allocator,

01:23:11,706 --> 01:23:13,831
the allocator will scream at you

01:23:13,831 --> 01:23:15,062
and you'll actually get an error path

01:23:15,062 --> 01:23:18,812
as opposed to getting really strange results.

01:23:20,726 --> 01:23:23,139
Very similarly, there's unsigned overflow.

01:23:23,139 --> 01:23:27,865
The kernel does a lot of legitimate unsigned overflow.

01:23:27,865 --> 01:23:30,239
So finding and marking those

01:23:30,239 --> 01:23:32,699
is something that needs work in the kernel.

01:23:32,699 --> 01:23:34,698
On the tool chain side.

01:23:34,698 --> 01:23:36,252
Clang has the ability to do this

01:23:36,252 --> 01:23:39,955
the same instrumentation is assigned but GCC does not.

01:23:39,955 --> 01:23:41,743
I haven't looked into why.

01:23:41,743 --> 01:23:44,493
I assume it's relatively similar.

01:23:45,508 --> 01:23:48,774
This one is not technically undefined behavior,

01:23:48,774 --> 01:23:52,146
but it frequently leads to exploitable conditions

01:23:52,146 --> 01:23:54,646
and things that no one wanted.

01:23:55,839 --> 01:24:00,464
So, again getting this saturated behavior would be nice.

01:24:00,464 --> 01:24:03,017
Because then we'll actually be able to catch the errors

01:24:03,017 --> 01:24:06,607
and continue as opposed to getting small allocations

01:24:06,607 --> 01:24:08,774
that get overwritten, etc.

01:24:14,055 --> 01:24:15,278
I'm gonna start with hopefully

01:24:15,278 --> 01:24:17,279
the easier of the to CFI type.

01:24:17,279 --> 01:24:18,946
So backward edge CFI

01:24:19,791 --> 01:24:22,740
which is testing when you return

01:24:22,740 --> 01:24:26,809
that you are going somewhere you intended to go.

01:24:26,809 --> 01:24:29,317
The hardware for support for this

01:24:29,317 --> 01:24:33,220
is where most of the work on this exists in the tool chains.

01:24:33,220 --> 01:24:36,720
So on x86, there's the CET feature bit

01:24:36,720 --> 01:24:38,781
and this basically just when a CPU

01:24:38,781 --> 01:24:40,364
becomes an implicit

01:24:41,739 --> 01:24:43,888
it happens implicitly on call and return.

01:24:43,888 --> 01:24:45,736
So there's actually no compiler support.

01:24:45,736 --> 01:24:48,319
It just need kernel support,

01:24:48,319 --> 01:24:52,780
and an OS support for it to set up the second stack.

01:24:52,780 --> 01:24:56,208
Like you end up with two stacks.

01:24:56,208 --> 01:25:00,041
On ARM 64 this works by doing pointer signing.

01:25:02,486 --> 01:25:05,768
But right now in Clang there isn't an attribute

01:25:05,768 --> 01:25:08,620
to turn this off on a per function basis,

01:25:08,620 --> 01:25:11,452
you can only turn it off on a compilation unit basis,

01:25:11,452 --> 01:25:13,401
which is rather awkward,

01:25:13,401 --> 01:25:14,667
and there are special places

01:25:14,667 --> 01:25:17,002
where you want to turn this off,

01:25:17,002 --> 01:25:20,138
like say all the code that initialize is pointer signing.

01:25:20,138 --> 01:25:21,873
You don't want to have signed it

01:25:21,873 --> 01:25:23,873
because things go crazy.

01:25:25,008 --> 01:25:28,478
There is a software implementation of the shadow stack.

01:25:28,478 --> 01:25:31,677
It's on ARM 64 only in Clang.

01:25:31,677 --> 01:25:34,927
It did exist on x86 but had performance

01:25:35,819 --> 01:25:36,656
and other problems.

01:25:36,656 --> 01:25:38,749
So it was actually removed.

01:25:38,749 --> 01:25:40,604
So I think the thought is just waiting

01:25:40,604 --> 01:25:42,415
for hardware support there.

01:25:42,415 --> 01:25:44,983
But it'd be nice to have a software shadow stack

01:25:44,983 --> 01:25:46,233
in GCC as well.

01:25:47,247 --> 01:25:49,575
Since it'd be nice to use in the kernel,

01:25:49,575 --> 01:25:54,035
but I know this would be useful in user space as well.

01:25:54,035 --> 01:25:55,589
Forward edge CFI.

01:25:55,589 --> 01:25:57,420
So protecting indirect calls.

01:25:57,420 --> 01:25:59,785
You've saved a function pointer in the heap

01:25:59,785 --> 01:26:02,647
and you read it back and jump to it.

01:26:02,647 --> 01:26:05,710
Actually validating the destination of those

01:26:05,710 --> 01:26:06,543
is another good one.

01:26:06,543 --> 01:26:10,846
So in hardware, there's really only support

01:26:10,846 --> 01:26:15,607
for coarse grain validating that you're entering a function.

01:26:15,607 --> 01:26:17,891
So as an attacker, the attack surface has been reduced

01:26:17,891 --> 01:26:20,048
from all of the bytes that are executable

01:26:20,048 --> 01:26:22,605
in to all of the entry,

01:26:22,605 --> 01:26:25,086
all the functions that you can reach,

01:26:25,086 --> 01:26:27,249
which is a huge attack surface reduction,

01:26:27,249 --> 01:26:31,965
but tends not to actually be practically much protection

01:26:31,965 --> 01:26:34,116
because you can just chain functions.

01:26:34,116 --> 01:26:38,020
That's already what a lot of attacks we're doing anyway,

01:26:38,020 --> 01:26:39,794
and with Rob.

01:26:39,794 --> 01:26:42,041
Anyway, there's support for this,

01:26:42,041 --> 01:26:45,067
the x86 and AMD 64 versions of this already

01:26:45,067 --> 01:26:47,067
in both the tool chains.

01:26:48,151 --> 01:26:51,555
In software to do this for fine-grain

01:26:51,555 --> 01:26:55,495
in other words allowing an indirect function call

01:26:55,495 --> 01:26:59,322
to only call other functions of the same function prototype.

01:26:59,322 --> 01:27:02,782
That sort of the bucketizing that was done for fine-grain.

01:27:02,782 --> 01:27:05,507
CFI this works in Clang.

01:27:05,507 --> 01:27:09,196
It would be really nice to get this for GCC

01:27:09,196 --> 01:27:11,065
as fine-grained CFI

01:27:11,065 --> 01:27:15,898
really is important for getting protections going forward.

01:27:18,377 --> 01:27:20,350
The paper I linked here is

01:27:20,350 --> 01:27:23,453
sort of a one click exploit generator

01:27:23,453 --> 01:27:25,908
because you can just automatically chained together

01:27:25,908 --> 01:27:30,483
all the gadgets you need to perform the attacks,

01:27:30,483 --> 01:27:33,267
and CFI completely stops this,

01:27:33,267 --> 01:27:34,895
or rather,

01:27:34,895 --> 01:27:37,312
makes the possibility so much smaller

01:27:37,312 --> 01:27:41,383
that they at least can't be automated right now.

01:27:41,383 --> 01:27:44,205
So anyway, since we have LTO in GCC

01:27:44,205 --> 01:27:47,423
it would be nice to also gain the CFI features

01:27:47,423 --> 01:27:51,423
since we have the visibility available to do it.

01:27:53,574 --> 01:27:55,574
And that's my whole list

01:27:58,201 --> 01:28:00,904
which I'll just go back up to as a reminder.

01:28:00,904 --> 01:28:02,235
Anyway,

01:28:02,235 --> 01:28:03,068
That's it.

01:28:03,068 --> 01:28:04,348
Those are the things I've been staring at

01:28:04,348 --> 01:28:06,426
and hoping you can get help with.

01:28:06,426 --> 01:28:07,593
Any questions?

01:28:11,422 --> 01:28:12,255
Peter.

01:28:20,039 --> 01:28:21,956
- I'm lousy with balls.

01:28:23,582 --> 01:28:28,011
One of the things that kind of occurred to me was,

01:28:28,011 --> 01:28:29,594
and I know already,

01:28:31,786 --> 01:28:34,187
I know everyone is going to absolutely hate me

01:28:34,187 --> 01:28:35,544
for saying this.

01:28:35,544 --> 01:28:40,127
But once you're talking about like introducing integers

01:28:41,574 --> 01:28:43,965
with different semantics,

01:28:43,965 --> 01:28:47,163
because that's what you're asking for.

01:28:47,163 --> 01:28:48,005
You're starting

01:28:48,005 --> 01:28:51,088
and then having customizable behavior

01:28:53,843 --> 01:28:57,869
for different kinds overflow conditions.

01:28:57,869 --> 01:29:00,425
That's starting to sound an awful lot like

01:29:00,425 --> 01:29:05,425
Something that would be hell a lot better done in C++.

01:29:07,286 --> 01:29:10,619
Because that is what C++ does.

01:29:14,081 --> 01:29:16,314
- [Audience] That's so not true--

01:29:16,314 --> 01:29:19,280
(audience laughing)

01:29:19,280 --> 01:29:21,947
- [Audience] That's the-- - Yeah,

01:29:23,829 --> 01:29:26,574
I'm not sure it's much better in C++,

01:29:26,574 --> 01:29:29,499
I think is what I would say.

01:29:29,499 --> 01:29:33,186
If you're talking about catching exceptions,

01:29:33,186 --> 01:29:35,054
I still can't, even with C++,

01:29:35,054 --> 01:29:36,493
I can turn these on for C++

01:29:36,493 --> 01:29:39,930
and I still can't saturate the value and carry on.

01:29:39,930 --> 01:29:40,975
Right? - [Audience] Yes, you can.

01:29:40,975 --> 01:29:43,591
You can define a class that does that.

01:29:43,591 --> 01:29:44,949
And that's the whole point.

01:29:44,949 --> 01:29:47,782
- [Audience] Operator overloading.

01:29:48,698 --> 01:29:49,531
- That ends up having

01:29:49,531 --> 01:29:52,710
a significantly larger performance impact.

01:29:52,710 --> 01:29:54,735
This right now is a flag test.

01:29:54,735 --> 01:29:56,740
It's a single instruction.

01:29:56,740 --> 01:29:57,930
It jumps to a call section like--

01:29:57,930 --> 01:30:00,663
- [Audience] You can do that.

01:30:00,663 --> 01:30:01,977
- Okay.

01:30:01,977 --> 01:30:04,977
(audience laughing)

01:30:08,453 --> 01:30:11,767
- I think it will be easier to fix these call sites up

01:30:11,767 --> 01:30:16,767
in the kernel than to switch to C++ (laughs).

01:30:17,983 --> 01:30:20,110
In the meantime (laughs).

01:30:20,110 --> 01:30:22,727
I have rust modules voting (laughs).

01:30:22,727 --> 01:30:23,636
- [Audience] Yeah, rust has this.

01:30:23,636 --> 01:30:24,886
You could do...

01:30:26,232 --> 01:30:29,423
- Except in the first chapter of the rust book,

01:30:29,423 --> 01:30:31,665
it describes overflow behaviors

01:30:31,665 --> 01:30:35,142
and if you're building in production

01:30:35,142 --> 01:30:37,641
and on debug it wraps.

01:30:37,641 --> 01:30:40,519
- [Audience] But never memory model so it's useless.

01:30:40,519 --> 01:30:41,998
- Oh, I'm not even going there.

01:30:41,998 --> 01:30:44,237
(audience laughing)

01:30:44,237 --> 01:30:45,366
- [Audience] There's no such thing as add method.

01:30:45,366 --> 01:30:48,013
Like if you can plus it will wrap on it's own

01:30:48,013 --> 01:30:50,563
but if you wanted to be done--

01:30:50,563 --> 01:30:54,267
- But that's optimistic issues the condition bit,

01:30:54,267 --> 01:30:56,633
and taking the exception.

01:30:56,633 --> 01:30:58,530
So really what we need is different

01:30:58,530 --> 01:31:01,269
integer types and hardware (laughs)

01:31:01,269 --> 01:31:02,169
- Okay.

01:31:02,169 --> 01:31:03,765
(audience laughing)

01:31:03,765 --> 01:31:05,842
I mean, because it has saturated guidance

01:31:05,842 --> 01:31:07,300
added instructions and that sort of thing,

01:31:07,300 --> 01:31:08,523
doesn't it?

01:31:08,523 --> 01:31:10,273
- I didn't find them.

01:31:11,237 --> 01:31:12,264
I don't think so if it does,

01:31:12,264 --> 01:31:14,764
that would make things easier.

01:31:16,739 --> 01:31:17,642
You know what

01:31:17,642 --> 01:31:20,203
I'd love it if we could just get rid of

01:31:20,203 --> 01:31:22,558
integer overflow class of bugs.

01:31:22,558 --> 01:31:24,861
That would be nice if I had a hardware integer type

01:31:24,861 --> 01:31:26,778
that would not do that.

01:31:30,060 --> 01:31:30,893
Anyway,

01:31:31,912 --> 01:31:33,768
I'm keeping you from lunch,

01:31:33,768 --> 01:31:35,601
or break or something.

01:31:37,601 --> 01:31:38,770
Cool, thank you.

01:31:38,770 --> 01:31:41,843
(audience clapping)

01:31:41,843 --> 01:31:42,894
- Alright,

01:31:42,894 --> 01:31:47,304
this talk is going to be on Clang built Linux,

01:31:47,304 --> 01:31:49,229
and it's essentially gonna be an update

01:31:49,229 --> 01:31:52,062
of the Linux kernel port to Clang.

01:31:53,136 --> 01:31:55,455
Now this is a project.

01:31:55,455 --> 01:31:57,041
I was a part of more in the past

01:31:57,041 --> 01:31:59,476
it's not something I'm directly working on anymore

01:31:59,476 --> 01:32:03,066
however Nick Desaulniers from Google,

01:32:03,066 --> 01:32:05,156
though the major contributor now

01:32:05,156 --> 01:32:08,120
and the fellow that basically is driving

01:32:08,120 --> 01:32:11,301
much of the rest of the work across the industry,

01:32:11,301 --> 01:32:13,627
he had more important things to do this week

01:32:13,627 --> 01:32:15,510
and couldn't actually make Plumbers.

01:32:15,510 --> 01:32:18,048
He's at Iron Maiden concert.

01:32:18,048 --> 01:32:20,290
(audience laughing)

01:32:20,290 --> 01:32:22,523
So anyway, it's not that he doesn't love you all

01:32:22,523 --> 01:32:23,532
doesn't want to be here.

01:32:23,532 --> 01:32:25,480
It's just that there's more important things going on.

01:32:25,480 --> 01:32:27,902
(audience laughing)

01:32:27,902 --> 01:32:28,735
Maybe.

01:32:28,735 --> 01:32:31,007
(audience laughing)

01:32:31,007 --> 01:32:31,840
In any case,

01:32:31,840 --> 01:32:35,426
so what happened essentially was is that

01:32:35,426 --> 01:32:37,341
in order to do this this talk,

01:32:37,341 --> 01:32:39,705
I basically got ahold of Nick,

01:32:39,705 --> 01:32:43,509
and we got onto a meet Google meet conversation,

01:32:43,509 --> 01:32:45,413
and he basically did a brain dump.

01:32:45,413 --> 01:32:48,581
And this is the result of that particular brain dump.

01:32:48,581 --> 01:32:49,994
Now, the first thing first,

01:32:49,994 --> 01:32:52,754
and that this prop perhaps isn't entirely useful

01:32:52,754 --> 01:32:53,587
for everybody here,

01:32:53,587 --> 01:32:55,983
we just to make the slide deck come out

01:32:55,983 --> 01:32:58,390
as the first question we almost always get is,

01:32:58,390 --> 01:32:59,223
why use Clang,

01:32:59,223 --> 01:33:00,056
or why bother?

01:33:00,056 --> 01:33:02,214
We've got a perfectly good compiler with GCC

01:33:02,214 --> 01:33:03,728
that we've always used.

01:33:03,728 --> 01:33:04,875
The kernels brought up on it,

01:33:04,875 --> 01:33:06,855
it works perfectly well with that.

01:33:06,855 --> 01:33:11,283
Why would we possibly spend the time getting Clang working?

01:33:11,283 --> 01:33:13,049
And the major issue these days

01:33:13,049 --> 01:33:15,140
isn't what we used to say in the past.

01:33:15,140 --> 01:33:16,771
It was because Clang had certain features

01:33:16,771 --> 01:33:18,851
that GCC didn't and so on.

01:33:18,851 --> 01:33:21,339
There's largely feature parity in many respects,

01:33:21,339 --> 01:33:24,538
these days, to those complaints.

01:33:24,538 --> 01:33:27,635
These days, the number one reason is generally

01:33:27,635 --> 01:33:30,483
because some companies want to use a single compiler

01:33:30,483 --> 01:33:33,150
across their entire project set.

01:33:34,160 --> 01:33:35,911
And to a certain extent, certain companies

01:33:35,911 --> 01:33:37,703
who decided they would prefer to go with Clang

01:33:37,703 --> 01:33:41,234
for various other reasons over GCC,

01:33:41,234 --> 01:33:44,451
and so when it comes to actually extending

01:33:44,451 --> 01:33:46,862
and fixing problems they've gone to do it with

01:33:46,862 --> 01:33:51,714
on a single compiler as opposed to two of them instead.

01:33:51,714 --> 01:33:52,547
The other thing of course,

01:33:52,547 --> 01:33:54,369
it's very good is that to a large degree

01:33:54,369 --> 01:33:56,615
when it comes to things like the C standard,

01:33:56,615 --> 01:33:59,802
most people don't ever read the C standard, right?

01:33:59,802 --> 01:34:00,981
Just a show of hands

01:34:00,981 --> 01:34:03,250
who here is actually read the C standard?

01:34:03,250 --> 01:34:04,756
Okay, that's actually a lot better

01:34:04,756 --> 01:34:06,183
than the last time I did this.

01:34:06,183 --> 01:34:08,494
Now the next question is which version of the C standard?

01:34:08,494 --> 01:34:10,934
(audience laughing)

01:34:10,934 --> 01:34:11,985
Okay, who's read all of them?

01:34:11,985 --> 01:34:13,380
- [Audience] Well not all of them.

01:34:13,380 --> 01:34:15,743
- Okay, so a lot fewer hands, right?

01:34:15,743 --> 01:34:18,586
The reality is the vast majority of people

01:34:18,586 --> 01:34:19,419
think they know C.

01:34:19,419 --> 01:34:21,448
What they really know is right code.

01:34:21,448 --> 01:34:22,883
Does the compiler say it's okay?

01:34:22,883 --> 01:34:24,386
Yes, okay continue.

01:34:24,386 --> 01:34:25,219
Okay.

01:34:25,219 --> 01:34:26,468
And even for those who have read the standard,

01:34:26,468 --> 01:34:27,674
have you read it all the way through,

01:34:27,674 --> 01:34:30,404
or if you merely read parts that you need to read?

01:34:30,404 --> 01:34:31,365
And unfortunately,

01:34:31,365 --> 01:34:34,105
I'm in I only read the parts that I need to read, right?

01:34:34,105 --> 01:34:36,355
So the reality is that the vast majority of us

01:34:36,355 --> 01:34:37,419
don't know C,

01:34:37,419 --> 01:34:41,863
and then beyond that we don't actually use C in the kernel.

01:34:41,863 --> 01:34:43,696
We use a version of C.

01:34:44,955 --> 01:34:48,436
We use the C variants, sorry the kernel variant of C,

01:34:48,436 --> 01:34:50,821
and so one of the nice things about using two compilers

01:34:50,821 --> 01:34:51,654
is because

01:34:54,131 --> 01:34:55,708
standards are interpreted

01:34:55,708 --> 01:34:57,681
by the people who write the compilers.

01:34:57,681 --> 01:35:00,182
It's a good idea to have multiple versions--

01:35:00,182 --> 01:35:02,374
- [Audience] I think we just lost audio.

01:35:02,374 --> 01:35:05,052
- Yeah, I was pretty sure to.

01:35:05,052 --> 01:35:08,967
It's a good idea to have two different interpretations of

01:35:08,967 --> 01:35:10,175
that specification.

01:35:10,175 --> 01:35:12,458
So that we can actually make sure that they match.

01:35:12,458 --> 01:35:14,263
So by having two compilers do the same work.

01:35:14,263 --> 01:35:16,268
In fact, we actually find those places

01:35:16,268 --> 01:35:19,992
that are otherwise considered to be undefined behavior.

01:35:19,992 --> 01:35:21,351
Because in the past at least

01:35:21,351 --> 01:35:24,933
from what I found, when I did a lot of work with Clang,

01:35:24,933 --> 01:35:28,060
in fact was that the kernel in certain situations

01:35:28,060 --> 01:35:30,986
was actually depending on undefined behavior

01:35:30,986 --> 01:35:32,464
on different architectures.

01:35:32,464 --> 01:35:33,468
And so by having to compilers,

01:35:33,468 --> 01:35:38,031
we can actually find those things a lot more easily.

01:35:38,031 --> 01:35:40,338
Certainly a number of the areas where that's been a problem

01:35:40,338 --> 01:35:42,028
from a security perspective cases

01:35:42,028 --> 01:35:44,486
actually managed to find it and get rid of.

01:35:44,486 --> 01:35:45,794
One of the big ones of course,

01:35:45,794 --> 01:35:49,294
being VLAs and (mumbles).

01:35:51,937 --> 01:35:54,580
The other thing is in fact

01:35:54,580 --> 01:35:57,816
the work on getting Clang to work with the kernel

01:35:57,816 --> 01:35:58,649
has had another effect

01:35:58,649 --> 01:36:02,246
and that is in fact to improved C support in Clang.

01:36:02,246 --> 01:36:05,407
It turns out that Clang is extremely heavily used

01:36:05,407 --> 01:36:07,187
in both C++ and in Objective C

01:36:07,187 --> 01:36:09,041
and in those particular areas

01:36:09,041 --> 01:36:12,486
it's very well supported and well tested.

01:36:12,486 --> 01:36:14,632
On the C side it's in fact less used

01:36:14,632 --> 01:36:16,594
than for those two languages.

01:36:16,594 --> 01:36:18,763
So in fact getting it to work with the kernel

01:36:18,763 --> 01:36:21,901
being one of the largest software projects in the world

01:36:21,901 --> 01:36:24,679
is in fact made it better overall.

01:36:24,679 --> 01:36:27,419
So in fact, it's been a net benefit

01:36:27,419 --> 01:36:29,158
of the Clang project as well

01:36:29,158 --> 01:36:30,575
which are useful.

01:36:33,008 --> 01:36:36,427
So this is probably gotta be biggest problem

01:36:36,427 --> 01:36:40,059
that people brought up certainly towards the end of the time

01:36:40,059 --> 01:36:44,289
that I was doing on using Clang with the kernel

01:36:44,289 --> 01:36:46,297
and that is the support for ASM Goto

01:36:46,297 --> 01:36:48,464
wasn't available in Clang.

01:36:49,298 --> 01:36:50,131
And

01:36:51,268 --> 01:36:55,832
ASM Goto is very important for being able to enable things

01:36:55,832 --> 01:36:57,215
like CONFIG_JUMP_LABEL,

01:36:57,215 --> 01:36:58,798
which allows you to

01:37:00,275 --> 01:37:02,942
optimize the use of predictions,

01:37:04,661 --> 01:37:08,019
fix predictions of whether you are gonna go

01:37:08,019 --> 01:37:09,722
have a particular

01:37:09,722 --> 01:37:10,555
have you.

01:37:11,405 --> 01:37:13,052
As added to Clang

01:37:13,052 --> 01:37:14,706
and in fact has been tested

01:37:14,706 --> 01:37:17,180
very heavily with the Linux kernel,

01:37:17,180 --> 01:37:19,015
which is very helpful because for instance,

01:37:19,015 --> 01:37:21,971
amongst other things CONFIG_JUMP_LABEL

01:37:21,971 --> 01:37:23,961
and JUMP_LABEL has now been made mandatory

01:37:23,961 --> 01:37:25,823
in the x86 kernel.

01:37:25,823 --> 01:37:30,073
So it's something that was actually absolutely required.

01:37:30,073 --> 01:37:31,569
Interesting thing of--

01:37:31,569 --> 01:37:35,053
ASM Goto though well tested with kernel

01:37:35,053 --> 01:37:37,604
because of the companies

01:37:37,604 --> 01:37:39,984
that are now using ASM Goto with their kernels,

01:37:39,984 --> 01:37:42,420
less well tested and user space.

01:37:42,420 --> 01:37:44,596
So for non-kernel target in fact

01:37:44,596 --> 01:37:47,205
ASM Goto and in fact still a work in progress

01:37:47,205 --> 01:37:49,038
in certain situations.

01:37:53,504 --> 01:37:55,004
So many questions.

01:37:59,510 --> 01:38:01,760
I'm not sure the mic is on.

01:38:08,794 --> 01:38:12,794
- We found a number of interesting compiler bugs

01:38:13,990 --> 01:38:17,845
while ASM Goto was-- - [Speaker] Oh no doubt.

01:38:17,845 --> 01:38:19,595
- Yeah, that was fun.

01:38:20,757 --> 01:38:23,382
Compiler bugs are always fun.

01:38:23,382 --> 01:38:24,215
But yeah,

01:38:24,215 --> 01:38:26,499
there's one of those areas where it was a long time coming

01:38:26,499 --> 01:38:30,832
and it was a long complaint that it was not supplied

01:38:31,930 --> 01:38:33,767
and in fact, I was asked for this one for several years

01:38:33,767 --> 01:38:34,656
as to when it would be added.

01:38:34,656 --> 01:38:37,073
So that does not surprise me.

01:38:39,610 --> 01:38:41,612
The next one is in line assembly

01:38:41,612 --> 01:38:44,777
and there's two levels inline assembly with Clang

01:38:44,777 --> 01:38:46,527
and those two levels,

01:38:47,630 --> 01:38:51,484
are first Clang needs to be able to parse inline assembly

01:38:51,484 --> 01:38:54,964
whereas GCC largely is past the inline assembly verbatim

01:38:54,964 --> 01:38:57,184
sort of half structured standard

01:38:57,184 --> 01:38:59,628
because Clang has what's called integrated assembly

01:38:59,628 --> 01:39:02,308
it actually has to understand

01:39:02,308 --> 01:39:03,925
the any inline assembly

01:39:03,925 --> 01:39:07,999
before it passes it off to the the assembler,

01:39:07,999 --> 01:39:10,571
whether it is an external one or an internal one

01:39:10,571 --> 01:39:12,627
and some of the formatting

01:39:12,627 --> 01:39:16,335
or that was used was specific to the Gnu Assembler

01:39:16,335 --> 01:39:17,994
and the problem is that

01:39:17,994 --> 01:39:20,604
a lot of those things were extensions

01:39:20,604 --> 01:39:23,940
and extensions that were not a part of any kind of standard

01:39:23,940 --> 01:39:24,773
and in fact,

01:39:24,773 --> 01:39:26,127
they were often extensions

01:39:26,127 --> 01:39:28,960
that even the Gnu Assembler people

01:39:30,202 --> 01:39:32,348
basically didn't think that Clang should in fact,

01:39:32,348 --> 01:39:34,326
implement because they were just too out there

01:39:34,326 --> 01:39:36,961
and basically unsupportable

01:39:36,961 --> 01:39:39,029
things that people are already using.

01:39:39,029 --> 01:39:40,498
They couldn't remove themselves,

01:39:40,498 --> 01:39:41,331
but they sort of wished

01:39:41,331 --> 01:39:44,122
they hadn't done some of those things.

01:39:44,122 --> 01:39:44,982
As a result,

01:39:44,982 --> 01:39:47,912
supporting Clang has been very different areas.

01:39:47,912 --> 01:39:50,581
The nice thing is that the herculean task

01:39:50,581 --> 01:39:53,187
of changing the assembly in the Linux kernel

01:39:53,187 --> 01:39:55,018
to be more standardized,

01:39:55,018 --> 01:39:56,430
a lot of that has been done now.

01:39:56,430 --> 01:39:59,259
So it depends on the architecture exactly.

01:39:59,259 --> 01:40:03,316
For instance, Stephane Agner has spent a long time

01:40:03,316 --> 01:40:07,149
fixing up the assembly in the ARM architecture

01:40:08,616 --> 01:40:10,120
to bring it back to the unified syntax,

01:40:10,120 --> 01:40:11,703
which is very good.

01:40:13,511 --> 01:40:14,902
And indeed, a lot of the extensions

01:40:14,902 --> 01:40:16,866
that were part of GAS have slowly been removed

01:40:16,866 --> 01:40:20,219
from the Linux kernel to make things a lot more supportable.

01:40:20,219 --> 01:40:21,515
So that's really good.

01:40:21,515 --> 01:40:23,499
Unfortunately, the integrator somewhere still can't be used.

01:40:23,499 --> 01:40:26,826
So the speed ups and the debug ability

01:40:26,826 --> 01:40:29,070
that the integrated assembler brings to table

01:40:29,070 --> 01:40:31,297
unfortunately still aren't possible.

01:40:31,297 --> 01:40:34,279
However, that still is a something that people wanna do

01:40:34,279 --> 01:40:36,998
going forward to be able to make that work

01:40:36,998 --> 01:40:39,248
and a nother question here.

01:40:41,945 --> 01:40:43,028
I think the--

01:40:46,725 --> 01:40:48,118
That should be on now. - Okay.

01:40:48,118 --> 01:40:51,977
So the integrated assembler does that

01:40:51,977 --> 01:40:55,894
mean that Clang can change our inline assembly?

01:40:57,867 --> 01:41:02,074
Or does it guarantee that those exact instructions

01:41:02,074 --> 01:41:03,407
will be emitted?

01:41:05,005 --> 01:41:07,110
- Integrated assembler essentially is

01:41:07,110 --> 01:41:09,152
just another path within the compiler,

01:41:09,152 --> 01:41:11,400
it basically means that instead of forking out

01:41:11,400 --> 01:41:13,261
to an external assembler it actually has an assembler

01:41:13,261 --> 01:41:15,332
built into the compiler itself.

01:41:15,332 --> 01:41:17,177
So that the whole point is that it can,

01:41:17,177 --> 01:41:20,276
for instance in the event of in line assembly,

01:41:20,276 --> 01:41:21,846
just having a single instruction,

01:41:21,846 --> 01:41:24,169
it will just admit that single instruction continued.

01:41:24,169 --> 01:41:26,765
- Okay, but it will not then

01:41:26,765 --> 01:41:28,555
interpret the instruction,

01:41:28,555 --> 01:41:31,250
put it in the intermediate representation,

01:41:31,250 --> 01:41:33,300
do optimization passes over it

01:41:33,300 --> 01:41:34,647
and admit something else altogether,

01:41:34,647 --> 01:41:37,020
which has seemingly the same effect.

01:41:37,020 --> 01:41:39,552
- I understand you're saying as far as I understand it,

01:41:39,552 --> 01:41:41,668
it basically goes

01:41:41,668 --> 01:41:44,564
my understanding is it goes straight to an instruction,

01:41:44,564 --> 01:41:46,563
I don't believe it goes through that path.

01:41:46,563 --> 01:41:50,514
- Okay, so because we very much rely on

01:41:50,514 --> 01:41:52,277
specific instructions to be emitted.

01:41:52,277 --> 01:41:53,308
- [Speaker] Right.

01:41:53,308 --> 01:41:54,141
- In a number of places.

01:41:54,141 --> 01:41:55,502
- As far as I know it,

01:41:55,502 --> 01:41:57,011
I'd have to double check but as far as I know,

01:41:57,011 --> 01:41:59,847
it emits and instruction.

01:41:59,847 --> 01:42:00,680
- I can confirm

01:42:00,680 --> 01:42:01,895
yes, that's a case.

01:42:01,895 --> 01:42:05,488
Separate the path. - [Speaker] There we go.

01:42:05,488 --> 01:42:06,792
- Instruction will be preserved.

01:42:06,792 --> 01:42:07,954
- Okay, excellent.

01:42:07,954 --> 01:42:11,037
- But it does pass so it emits the...

01:42:12,360 --> 01:42:14,830
- The comment was that it does parse the outputs

01:42:14,830 --> 01:42:17,980
understands the control flow that it brings to the table.

01:42:17,980 --> 01:42:19,897
And yes, that's agreed.

01:42:20,782 --> 01:42:24,526
The reality is that Clang is supposed to understand,

01:42:24,526 --> 01:42:25,359
certainly the encoding

01:42:25,359 --> 01:42:27,140
and certainly what it's trying to do and so on,

01:42:27,140 --> 01:42:29,774
but it will emit the instruction.

01:42:29,774 --> 01:42:30,607
However, at the moment,

01:42:30,607 --> 01:42:33,552
it's not possible to use it for various other reasons.

01:42:33,552 --> 01:42:34,921
It's just that we're getting closer

01:42:34,921 --> 01:42:36,410
to being able to do that now,

01:42:36,410 --> 01:42:38,660
which is the ultimate goal.

01:42:39,655 --> 01:42:40,822
And basically,

01:42:42,651 --> 01:42:45,437
the support for understanding assemblies

01:42:45,437 --> 01:42:48,153
is something that is an ongoing affair,

01:42:48,153 --> 01:42:50,598
and certainly different encoding now output parameters

01:42:50,598 --> 01:42:53,754
and so on have been added to Clang support

01:42:53,754 --> 01:42:55,194
of inline assembly over the years.

01:42:55,194 --> 01:42:57,995
And so that's taking us closer and closer to the point

01:42:57,995 --> 01:43:02,078
of being able to enable the integrated assembler.

01:43:04,610 --> 01:43:09,610
The next one that we should maybe talk about is LLD.

01:43:09,641 --> 01:43:11,906
Now, the compiler itself,

01:43:11,906 --> 01:43:15,544
of course is one thing when it comes to actually the support

01:43:15,544 --> 01:43:16,685
surrounding the compiler

01:43:16,685 --> 01:43:20,155
the rest of the tool chain things like

01:43:20,155 --> 01:43:23,651
the link or the debugger, the assembler.

01:43:23,651 --> 01:43:26,163
These things all come from binutils traditionally,

01:43:26,163 --> 01:43:28,000
and indeed binutils

01:43:28,000 --> 01:43:32,083
has been a big part of having to use Clang still.

01:43:33,262 --> 01:43:36,789
Of course, binutils as a separate project from GCC.

01:43:36,789 --> 01:43:38,614
When it comes to Clang and LLVM

01:43:38,614 --> 01:43:39,735
they have their own equivalent

01:43:39,735 --> 01:43:41,946
of all the binutils utilities.

01:43:41,946 --> 01:43:44,879
The big one that people have really wanted to see

01:43:44,879 --> 01:43:46,765
for a while something called LLD,

01:43:46,765 --> 01:43:49,619
which is the linker that came out of the LLVM project.

01:43:49,619 --> 01:43:51,443
Now, this is actually kind of interesting

01:43:51,443 --> 01:43:55,415
because one of the major things that LDD is very good at

01:43:55,415 --> 01:43:57,786
is things like LTO, for instance,

01:43:57,786 --> 01:44:00,143
and it does this in a very heavily threaded matter.

01:44:00,143 --> 01:44:03,532
So, whereas LD and gold are quite linear

01:44:03,532 --> 01:44:05,412
because they're not threaded,

01:44:05,412 --> 01:44:06,595
LLD is heavily threaded

01:44:06,595 --> 01:44:10,671
and therefore tends to actually get to an LTO output

01:44:10,671 --> 01:44:13,656
that much faster at least it tends to link faster,

01:44:13,656 --> 01:44:17,489
especially in a incremental linkage situation.

01:44:18,324 --> 01:44:20,161
Now, LLD has been something that's been very slow

01:44:20,161 --> 01:44:21,548
to be worked on over the years,

01:44:21,548 --> 01:44:26,548
in part because gold did most of what it needed to be done.

01:44:26,942 --> 01:44:28,802
However again, there are certain companies

01:44:28,802 --> 01:44:31,602
that desperately want to move to something

01:44:31,602 --> 01:44:33,975
that is all LLVM related

01:44:33,975 --> 01:44:37,392
and as a result work has been put into LLD

01:44:37,392 --> 01:44:38,841
to the point now where in fact,

01:44:38,841 --> 01:44:42,754
there are products that are getting ready to ship

01:44:42,754 --> 01:44:46,566
later this year that are 100% LLD linked

01:44:46,566 --> 01:44:49,494
and one of those is the next version,

01:44:49,494 --> 01:44:52,197
or very likely one of the next versions of the pixel

01:44:52,197 --> 01:44:54,364
like I don't know which one but apparently,

01:44:54,364 --> 01:44:56,086
one of the pixels later this year

01:44:56,086 --> 01:45:00,541
will be shipped 100% with LLD linked kernel.

01:45:00,541 --> 01:45:01,997
Otherwise, sorry?

01:45:01,997 --> 01:45:03,714
- [Audience] Is it LDD or LLD?

01:45:03,714 --> 01:45:04,881
- It's LLD.

01:45:04,881 --> 01:45:06,529
- [Audience] Yeah, okay.

01:45:06,529 --> 01:45:07,615
- It's also LLDB,

01:45:07,615 --> 01:45:09,960
which is the debugger.

01:45:09,960 --> 01:45:12,028
Unfortunately, names are hard to say

01:45:12,028 --> 01:45:14,622
and it's like LLVM and LLDVM

01:45:14,622 --> 01:45:16,607
people get those two mixed up as well.

01:45:16,607 --> 01:45:18,607
The name spaces collide.

01:45:19,787 --> 01:45:20,620
Sorry.

01:45:24,148 --> 01:45:27,148
But yeah, otherwise, LLD basically does,

01:45:27,148 --> 01:45:28,289
essentially what gold can do.

01:45:28,289 --> 01:45:32,129
It's just an entirely different code base,

01:45:32,129 --> 01:45:34,962
and of course a different license.

01:45:37,165 --> 01:45:38,407
I'm sorry, what?

01:45:38,407 --> 01:45:39,240
- [Audience] Yeah,

01:45:39,240 --> 01:45:41,008
so we've removed gold support from the kernel.

01:45:41,008 --> 01:45:41,841
- That's true.

01:45:41,841 --> 01:45:42,674
I saw that recently, that's true.

01:45:42,674 --> 01:45:43,507
And why was that?

01:45:43,507 --> 01:45:44,679
I don't know if I looked into that.

01:45:44,679 --> 01:45:47,967
- Because we run into various bugs

01:45:47,967 --> 01:45:50,448
and being YouTube's people basically said,

01:45:50,448 --> 01:45:52,552
linking the kernel is not a priority for us.

01:45:52,552 --> 01:45:56,253
So we say well then you're not for us either.

01:45:56,253 --> 01:45:57,218
- I don't have that.

01:45:57,218 --> 01:45:58,051
I hadn't heard that part,

01:45:58,051 --> 01:45:59,574
but I didn't see that true

01:45:59,574 --> 01:46:00,945
or had may have been removed recently.

01:46:00,945 --> 01:46:01,778
So,

01:46:02,939 --> 01:46:07,892
okay well hopefully the continue some more things then.

01:46:07,892 --> 01:46:10,368
And now LLD in fact just being a generic linker.

01:46:10,368 --> 01:46:12,737
In fact, it does not have to only be used with Clang.

01:46:12,737 --> 01:46:15,369
In fact, it works with GCC as well.

01:46:15,369 --> 01:46:17,181
But of course, in this instance,

01:46:17,181 --> 01:46:20,991
the idea of Linux is eventually to have it,

01:46:20,991 --> 01:46:22,329
of course, compiled, assembled

01:46:22,329 --> 01:46:25,496
and linked all within this tool chain.

01:46:29,071 --> 01:46:30,258
The next thing is the adoption of Clang,

01:46:30,258 --> 01:46:32,815
and this is something that changes over time.

01:46:32,815 --> 01:46:34,527
Now, that the really interesting part

01:46:34,527 --> 01:46:38,110
was back when I was doing this more heavily

01:46:39,106 --> 01:46:41,504
and I was trying to work at Google

01:46:41,504 --> 01:46:43,913
in order to get them on board

01:46:43,913 --> 01:46:46,993
to help port the kernel to Clang.

01:46:46,993 --> 01:46:48,965
Clang was being relatively heavily used

01:46:48,965 --> 01:46:51,007
at the time for things like Android,

01:46:51,007 --> 01:46:52,384
and they were starting to look at it

01:46:52,384 --> 01:46:53,749
for things like Chrome OS,

01:46:53,749 --> 01:46:56,164
but on the kernel side in fact,

01:46:56,164 --> 01:46:58,549
it was less interesting for many people

01:46:58,549 --> 01:47:02,466
and overall their move forward has always been,

01:47:04,053 --> 01:47:05,253
in fact towards Clang.

01:47:05,253 --> 01:47:07,016
And so in the last couple years,

01:47:07,016 --> 01:47:08,696
one of the reasons why Nick got so involved

01:47:08,696 --> 01:47:09,972
in it was because essentially,

01:47:09,972 --> 01:47:11,386
they wanted to move Android Chrome OS

01:47:11,386 --> 01:47:15,184
and other things 100% to Clang.

01:47:15,184 --> 01:47:16,613
And so generally speaking these days,

01:47:16,613 --> 01:47:20,390
Google has moved largely away from GCC and binutils.

01:47:20,390 --> 01:47:22,499
And to a large degree.

01:47:22,499 --> 01:47:24,991
What they're finding is that there's a long tail of features

01:47:24,991 --> 01:47:29,099
that need to be fixed in things like Clang

01:47:29,099 --> 01:47:31,894
in the IA and other things

01:47:31,894 --> 01:47:33,926
in order to get feature parity,

01:47:33,926 --> 01:47:34,904
or for that matter,

01:47:34,904 --> 01:47:38,118
but compare it with binutils and gnu-as,

01:47:38,118 --> 01:47:42,920
and so the first thing, of course is talking about Android,

01:47:42,920 --> 01:47:45,333
Android, in fact, had largely moved away from GCC

01:47:45,333 --> 01:47:48,277
to Clang several years ago.

01:47:48,277 --> 01:47:50,260
Getting it to work for on the kernel

01:47:50,260 --> 01:47:52,894
was one of the major last thing they needed to do

01:47:52,894 --> 01:47:55,253
and these days they've basically moved away

01:47:55,253 --> 01:47:57,401
from Clang almost 100%.

01:47:57,401 --> 01:47:59,401
The kernel was the last.

01:48:01,708 --> 01:48:04,060
They do have a couple of things that still use GCC,

01:48:04,060 --> 01:48:06,153
but they use a very, very old version of GCC

01:48:06,153 --> 01:48:09,593
that they have instrumented to make work appropriately.

01:48:09,593 --> 01:48:12,418
They're not planning to upgrade that.

01:48:12,418 --> 01:48:15,374
They wanna move over to using Clang instead.

01:48:15,374 --> 01:48:18,384
Android Q these days the one that just came out,

01:48:18,384 --> 01:48:21,033
it mandates that they're OEM use Clang

01:48:21,033 --> 01:48:22,299
to build their kernels.

01:48:22,299 --> 01:48:25,725
So basically, if you've got an Android Q device,

01:48:25,725 --> 01:48:29,492
in theory, it's kernel is now compiled using Clang.

01:48:29,492 --> 01:48:30,930
The major reason for this is that

01:48:30,930 --> 01:48:33,928
they wanna make sure that there's a 100% guarantee

01:48:33,928 --> 01:48:36,280
that the ABI between user's base,

01:48:36,280 --> 01:48:39,604
Android and the kernel is 100% the same.

01:48:39,604 --> 01:48:42,940
And so for debug ability and other reasons,

01:48:42,940 --> 01:48:44,795
they're mandating that Clang must be used

01:48:44,795 --> 01:48:49,127
for all Android kernels now beyond Android Q.

01:48:49,127 --> 01:48:53,603
What this basically means is that all companies now

01:48:53,603 --> 01:48:55,790
trying to support Android into the future of course

01:48:55,790 --> 01:49:00,544
will be mandated to use Clang for their kernels.

01:49:00,544 --> 01:49:02,176
To the end of being

01:49:02,176 --> 01:49:04,308
making sure that the ABI is in fact stable,

01:49:04,308 --> 01:49:08,626
and in fact, basically works across all platforms

01:49:08,626 --> 01:49:11,869
that there are no people using something called libabigail,

01:49:11,869 --> 01:49:14,828
that allows the testing of binary ABIs

01:49:14,828 --> 01:49:17,952
to make sure that the appropriate thing happens.

01:49:17,952 --> 01:49:19,139
They're basically tryna make sure that

01:49:19,139 --> 01:49:20,540
the ABI doesn't change over time

01:49:20,540 --> 01:49:22,555
or between versions of the kernel,

01:49:22,555 --> 01:49:25,972
or indeed, ideally between GCC and Clang,

01:49:27,425 --> 01:49:28,270
but to the large degree,

01:49:28,270 --> 01:49:30,232
they're tryna make sure that the Clang ABI

01:49:30,232 --> 01:49:34,268
for their platform basically stays the same.

01:49:34,268 --> 01:49:35,148
To make this easier,

01:49:35,148 --> 01:49:36,507
one of the things they've now done as well

01:49:36,507 --> 01:49:39,471
is they've shipped a new dev platform,

01:49:39,471 --> 01:49:40,369
it's called cuttlefish.

01:49:40,369 --> 01:49:42,759
It works for x86_64

01:49:42,759 --> 01:49:46,869
and it allows you to essentially do debugging on

01:49:46,869 --> 01:49:49,363
your development device.

01:49:49,363 --> 01:49:50,925
Without having to go to a real hardware.

01:49:50,925 --> 01:49:54,050
It's all 100% Clang built as well,

01:49:54,050 --> 01:49:56,633
including the kernel obviously.

01:49:57,543 --> 01:49:58,387
Chrome OS same deal,

01:49:58,387 --> 01:50:01,271
they moved 100% to Clang.

01:50:01,271 --> 01:50:05,021
They now have all targets x86_64 and aarch64,

01:50:06,113 --> 01:50:11,113
or now Clang built from the kernel on to user space.

01:50:11,238 --> 01:50:13,262
ARM 32 still has a couple of issues

01:50:13,262 --> 01:50:14,206
that are trynna work through

01:50:14,206 --> 01:50:16,871
that they're not entirely there yet,

01:50:16,871 --> 01:50:21,394
but ARM 32 being less of a platform for them these days,

01:50:21,394 --> 01:50:24,579
it's been de-prioritized that's my understanding.

01:50:24,579 --> 01:50:26,703
But pretty much if you've got Chrome OS device,

01:50:26,703 --> 01:50:29,786
it's running a Clang base kernel now.

01:50:30,995 --> 01:50:31,991
This one surprised me

01:50:31,991 --> 01:50:33,860
and that is that Google cloud servers

01:50:33,860 --> 01:50:36,745
are in fact moving over to Clang as well.

01:50:36,745 --> 01:50:40,024
There had been a problem in the past supporting kexec

01:50:40,024 --> 01:50:41,774
and that actually had

01:50:43,666 --> 01:50:47,416
stopped the moving of services over to Clang.

01:50:48,430 --> 01:50:50,144
However, that's now been resolved,

01:50:50,144 --> 01:50:51,240
and they're now in the process

01:50:51,240 --> 01:50:52,760
of doing some pretty heavy testing

01:50:52,760 --> 01:50:56,310
to move the rest of the Google Google Cloud services

01:50:56,310 --> 01:50:58,967
over to using Clang built kernels.

01:50:58,967 --> 01:51:00,179
Just in general, my understand

01:51:00,179 --> 01:51:03,490
is that Google has actually managed to debug

01:51:03,490 --> 01:51:06,197
and find a number of fairly major errors

01:51:06,197 --> 01:51:07,669
by compiling with Clang in the past,

01:51:07,669 --> 01:51:10,322
which has led them to actually want to move everything

01:51:10,322 --> 01:51:11,930
over to that otherwise,

01:51:11,930 --> 01:51:13,073
and I think we've got a question here.

01:51:13,073 --> 01:51:14,622
- [Audience] No it was just a statement.

01:51:14,622 --> 01:51:16,611
Yeah, this isn't just cloud service.

01:51:16,611 --> 01:51:18,673
We're moving trying to move all corners.

01:51:18,673 --> 01:51:19,506
Sure.

01:51:19,506 --> 01:51:21,004
No, I can't say that.

01:51:21,004 --> 01:51:22,901
I'm just passing on what was told to me

01:51:22,901 --> 01:51:23,873
that my understanding is--

01:51:23,873 --> 01:51:25,744
- I'm adding to your slide.

01:51:25,744 --> 01:51:26,577
- There you go.

01:51:26,577 --> 01:51:27,410
So there you have it.

01:51:27,410 --> 01:51:32,399
So Google's trying to move everything over to Clang.

01:51:32,399 --> 01:51:33,778
That's more or less what I had understood.

01:51:33,778 --> 01:51:36,445
So but thank you for clarifying.

01:51:38,768 --> 01:51:40,193
The next thing is LTO.

01:51:40,193 --> 01:51:42,671
Now LTO is something that a number of people

01:51:42,671 --> 01:51:43,863
probably even in the room

01:51:43,863 --> 01:51:46,251
have been working very heavily on for years.

01:51:46,251 --> 01:51:49,352
LTO is now something that certainly

01:51:49,352 --> 01:51:52,606
is being very heavily within Google.

01:51:52,606 --> 01:51:57,227
The Pixel 3 apparently and newer will mandate the use of LTO

01:51:57,227 --> 01:52:00,950
using Clang and LLD as far as I know.

01:52:00,950 --> 01:52:05,388
Android R will be shipped also with LTO Clang kernel,

01:52:05,388 --> 01:52:06,817
which is very interesting.

01:52:06,817 --> 01:52:08,974
So it didn't come out in queue,

01:52:08,974 --> 01:52:12,604
but will be coming out in the next version.

01:52:12,604 --> 01:52:14,902
And the idea effectively is once they have that working

01:52:14,902 --> 01:52:16,526
that it will also be upstreamed

01:52:16,526 --> 01:52:20,787
to make sure that in fact LTO support is pushed upstream.

01:52:20,787 --> 01:52:25,072
Internally, they now have x86_64, ARM 32, aarch64,

01:52:25,072 --> 01:52:26,489
powerpc32 and 64,

01:52:27,444 --> 01:52:31,188
and last time I talked to Nick they just got MIPS32 working

01:52:31,188 --> 01:52:34,438
so that's pretty interesting to be able to have an LTO

01:52:34,438 --> 01:52:37,464
kernel cross all those architectures.

01:52:37,464 --> 01:52:39,798
And my understanding is other work is being done

01:52:39,798 --> 01:52:44,127
in other areas aren't for instance apparently

01:52:44,127 --> 01:52:46,141
also messed around a bit with getting it working on spark

01:52:46,141 --> 01:52:49,173
and system that not really sure how far he got on that

01:52:49,173 --> 01:52:52,904
but apparently that some work has been done there as well.

01:52:52,904 --> 01:52:55,165
As far as LTO supports

01:52:55,165 --> 01:53:00,165
apparently they are going to support version 4 4, 4.9, 4.19,

01:53:00,503 --> 01:53:05,503
Linux-next and mainline (murmurs) standardized kernels

01:53:05,917 --> 01:53:08,584
that Android currently mandates.

01:53:13,743 --> 01:53:16,434
As far as testing this is probably one of the things

01:53:16,434 --> 01:53:18,976
that I was happiest about when it happened.

01:53:18,976 --> 01:53:19,988
Because it was something

01:53:19,988 --> 01:53:22,354
that I hadn't quite managed to do myself,

01:53:22,354 --> 01:53:25,160
and that is there's now full CI built tester

01:53:25,160 --> 01:53:28,113
on both Travis but also within kernel CI,

01:53:28,113 --> 01:53:29,136
which is quite nice,

01:53:29,136 --> 01:53:31,140
and now using Clang, which is great.

01:53:31,140 --> 01:53:34,212
The only one that's kind of awesome is the 0-day bot

01:53:34,212 --> 01:53:36,881
from Intel is now actually also supporting

01:53:36,881 --> 01:53:38,505
a Clang built kernel.

01:53:38,505 --> 01:53:41,726
However, at the moment, it's private only for Google,

01:53:41,726 --> 01:53:44,241
in part because it's still very noisy.

01:53:44,241 --> 01:53:45,621
It still has a lot of warnings

01:53:45,621 --> 01:53:48,479
and other things in it that they're slowly working through.

01:53:48,479 --> 01:53:49,823
But they're really hoping that they can

01:53:49,823 --> 01:53:52,389
make that more globally available.

01:53:52,389 --> 01:53:55,461
Once they reduce the noise on it.

01:53:55,461 --> 01:53:56,734
The last thing everybody here wants to see

01:53:56,734 --> 01:53:58,755
is a million errors

01:53:58,755 --> 01:54:00,489
and more warnings coming out from a compiler,

01:54:00,489 --> 01:54:05,489
they're not strictly using themselves at that point in time.

01:54:05,543 --> 01:54:08,180
So right now there's support for ARM and aarch64.

01:54:08,180 --> 01:54:09,013
That's in testing

01:54:09,013 --> 01:54:12,922
and x86 _64 is actually still a work in progress.

01:54:12,922 --> 01:54:14,281
So there's still some work to be done there

01:54:14,281 --> 01:54:18,562
but the nice thing is that there is more automated testing

01:54:18,562 --> 01:54:21,195
even more so than what we were running back

01:54:21,195 --> 01:54:24,011
when I was doing the project.

01:54:24,011 --> 01:54:25,941
Of course, the other thing that which is both good and bad

01:54:25,941 --> 01:54:27,826
is there are different warnings between the two compilers

01:54:27,826 --> 01:54:29,969
as one would expect.

01:54:29,969 --> 01:54:33,507
This essentially can show where potential problems

01:54:33,507 --> 01:54:36,219
in understandings or the possibilities on behavior

01:54:36,219 --> 01:54:38,337
and other thing like that.

01:54:38,337 --> 01:54:40,090
This is one of those situations

01:54:40,090 --> 01:54:42,708
where different people have found errors

01:54:42,708 --> 01:54:44,617
basically by trying different compilers

01:54:44,617 --> 01:54:48,193
to see what the output happens to be.

01:54:48,193 --> 01:54:51,072
The testing and in the case of Travis CI,

01:54:51,072 --> 01:54:52,757
and kernel CI,

01:54:52,757 --> 01:54:54,625
is both building and booting up the kernel,

01:54:54,625 --> 01:54:58,203
so it's not just to build test like the zero day bot.

01:54:58,203 --> 01:54:59,939
They're actually doing full boot testing as well

01:54:59,939 --> 01:55:02,298
to make sure that the resulting kernels

01:55:02,298 --> 01:55:04,715
actually do something useful.

01:55:08,108 --> 01:55:11,712
This is actually notice the other day

01:55:11,712 --> 01:55:13,955
on the kernel mailing list

01:55:13,955 --> 01:55:16,390
they actually also added the ClangBuiltLinux mailing lists

01:55:16,390 --> 01:55:18,390
to the maintainers file.

01:55:19,941 --> 01:55:20,899
If you look carefully in fact

01:55:20,899 --> 01:55:24,503
it's a instead of specifying a file,

01:55:24,503 --> 01:55:27,170
in fact, there's a pattern in there that basically says

01:55:27,170 --> 01:55:29,999
if the file contains the word Clang,

01:55:29,999 --> 01:55:32,324
the message should just head over the mailing list.

01:55:32,324 --> 01:55:36,157
So basically the Clang group has more or less,

01:55:37,147 --> 01:55:38,855
added themselves as maintainers

01:55:38,855 --> 01:55:41,418
for any file that claims

01:55:41,418 --> 01:55:43,966
that there's some sort of Clang aspect which is interesting.

01:55:43,966 --> 01:55:45,412
So the good thing effectively

01:55:45,412 --> 01:55:47,306
is if there's a Clang related problem

01:55:47,306 --> 01:55:49,977
or a Clang adjacent issue,

01:55:49,977 --> 01:55:52,082
the appropriate people will be emailed,

01:55:52,082 --> 01:55:53,915
which is quite useful.

01:55:54,920 --> 01:55:57,164
So at the moment, at least,

01:55:57,164 --> 01:55:59,731
the right people should be told if something doesn't work

01:55:59,731 --> 01:56:00,731
or if indeed

01:56:02,918 --> 01:56:07,225
an update to a particular problematic file essentially,

01:56:07,225 --> 01:56:08,438
that's being made for GCC

01:56:08,438 --> 01:56:09,271
which they can basically see

01:56:09,271 --> 01:56:12,438
whether it's gonna break Clang or not.

01:56:14,314 --> 01:56:16,564
So this list is by no means

01:56:20,520 --> 01:56:22,531
this is not a list of every company that's using,

01:56:22,531 --> 01:56:26,064
these are some of the major ones that Nick is currently

01:56:26,064 --> 01:56:27,810
aware of people using Clang

01:56:27,810 --> 01:56:29,105
heavily certainly on the kernel side

01:56:29,105 --> 01:56:31,640
and this is companies like Arm,

01:56:31,640 --> 01:56:34,997
obviously Google, Intel, Linaro, Qualcomm and Samsung.

01:56:34,997 --> 01:56:37,537
That's not that all the work that these companies are doing

01:56:37,537 --> 01:56:38,370
are on Clang.

01:56:38,370 --> 01:56:39,801
It's merely that each one of these companies

01:56:39,801 --> 01:56:42,895
is doing some work on Clang with the kernel.

01:56:42,895 --> 01:56:45,453
Certainly there are people around

01:56:45,453 --> 01:56:47,623
that have been very heavily involved with it.

01:56:47,623 --> 01:56:49,333
People like Ant and Will Deacon

01:56:49,333 --> 01:56:50,166
and other people like that

01:56:50,166 --> 01:56:53,078
have been also helping Case of course,

01:56:53,078 --> 01:56:57,828
other people have been working towards this work as well.

01:57:02,170 --> 01:57:04,754
The next thing is it's worth noting that

01:57:04,754 --> 01:57:07,692
there's a public meeting every two weeks.

01:57:07,692 --> 01:57:09,297
Essentially, there's a Google meet

01:57:09,297 --> 01:57:11,726
that happens on a regular basis.

01:57:11,726 --> 01:57:13,027
There's a Google calendar

01:57:13,027 --> 01:57:16,444
on the ClangBuiltLinux Github.io web site

01:57:17,294 --> 01:57:18,900
that will tell you what those are

01:57:18,900 --> 01:57:21,825
and indeed, this is the Google meet

01:57:21,825 --> 01:57:23,668
video chat that happens every two weeks.

01:57:23,668 --> 01:57:24,854
At that time essentially,

01:57:24,854 --> 01:57:28,233
all the appropriate people get on and talk

01:57:28,233 --> 01:57:31,011
and certainly everybody is welcome to be a part of that

01:57:31,011 --> 01:57:33,952
and you get the latest and greatest what's going on.

01:57:33,952 --> 01:57:35,740
To a large degree it's Nick telling

01:57:35,740 --> 01:57:37,931
what's happened for the last week.

01:57:37,931 --> 01:57:39,600
Anyone who's been to the meeting,

01:57:39,600 --> 01:57:42,461
it's basically rapid fire machine gun

01:57:42,461 --> 01:57:44,811
talking from Nick to everybody else,

01:57:44,811 --> 01:57:47,970
but there's an awful lot of great information

01:57:47,970 --> 01:57:52,166
and it's a really good place to find out what's going on

01:57:52,166 --> 01:57:57,083
and what's important to the group of people that are there.

01:57:58,635 --> 01:58:01,475
There's also a list on the wiki of past talks.

01:58:01,475 --> 01:58:04,975
Now, these are primarily past talks that Nick has given

01:58:04,975 --> 01:58:07,379
over the years on this on this topic,

01:58:07,379 --> 01:58:09,304
I actually need to go in and add some of my talks

01:58:09,304 --> 01:58:11,616
and some of the other ones that people have done on here

01:58:11,616 --> 01:58:14,418
so we can have a complete history of everything.

01:58:14,418 --> 01:58:18,085
But there's all sorts of talks like this one

01:58:19,140 --> 01:58:20,783
that are up there that can show you what's going on

01:58:20,783 --> 01:58:24,224
and what's happened in the past.

01:58:24,224 --> 01:58:25,880
And otherwise, these are this is how

01:58:25,880 --> 01:58:27,544
you can get more involved if you're interested

01:58:27,544 --> 01:58:28,676
in what's what's going on.

01:58:28,676 --> 01:58:30,945
There's the major website.

01:58:30,945 --> 01:58:34,921
There's the, yeah I know lots of URLs.

01:58:34,921 --> 01:58:36,775
There's the GitHub where the ClangBuiltLinux code

01:58:36,775 --> 01:58:38,615
is actually stored.

01:58:38,615 --> 01:58:40,032
There's the wiki.

01:58:40,867 --> 01:58:43,583
There's an issue listed there that on GitHub

01:58:43,583 --> 01:58:45,007
that people maintain,

01:58:45,007 --> 01:58:46,856
as well as the mailing list

01:58:46,856 --> 01:58:50,328
and of course the IRC channel on free node.

01:58:50,328 --> 01:58:52,589
Now all this information is available on the first link.

01:58:52,589 --> 01:58:57,182
So don't think you need to copy all these things to...

01:58:57,182 --> 01:58:58,819
This talk will be uploaded appropriately

01:58:58,819 --> 01:59:01,736
to the following website as well as

01:59:03,833 --> 01:59:08,009
the wiki list of talks here that I just showed you.

01:59:08,009 --> 01:59:11,426
Other than that, are there any questions?

01:59:18,391 --> 01:59:19,329
Okay. - [Audience] Great, thank you.

01:59:19,329 --> 01:59:20,162
- Thank you very much.

01:59:20,162 --> 01:59:23,162
(audience clapping)

02:00:02,840 --> 02:00:06,007
(audience chattering)

02:02:10,199 --> 02:02:12,532
- Does this microphone work?

02:02:14,607 --> 02:02:16,024
It's outstanding.

02:02:21,073 --> 02:02:21,906
Okay.

02:02:23,424 --> 02:02:24,257
For

02:02:26,371 --> 02:02:27,204
as Maciej said,

02:02:27,204 --> 02:02:28,870
I think it was earlier in the day.

02:02:28,870 --> 02:02:31,733
This is in fact the first talk I have a presentation

02:02:31,733 --> 02:02:34,801
I had given the since I was about 21,

02:02:34,801 --> 02:02:35,634
and I'm already doing better

02:02:35,634 --> 02:02:37,090
because I hadn't had a panic attack yet.

02:02:37,090 --> 02:02:39,742
So (laughs)

02:02:39,742 --> 02:02:40,884
this is all I'm sorry,

02:02:40,884 --> 02:02:41,808
I've got to look up there

02:02:41,808 --> 02:02:44,781
because this my screen isn't working.

02:02:44,781 --> 02:02:46,614
This is all about CTF.

02:02:47,459 --> 02:02:50,524
And I suppose I should first see what CTF isn't.

02:02:50,524 --> 02:02:52,404
This is not the common trace format

02:02:52,404 --> 02:02:54,920
which has been described in other talks.

02:02:54,920 --> 02:02:56,003
- [Audience] Capture the flag.

02:02:56,003 --> 02:02:57,512
- It's not capture the flag.

02:02:57,512 --> 02:03:00,220
It's not Microsoft Security whole field

02:03:00,220 --> 02:03:01,854
common text framework,

02:03:01,854 --> 02:03:04,937
and it's not continuous tube feeding.

02:03:05,832 --> 02:03:08,087
We really need we really need a different acronym

02:03:08,087 --> 02:03:09,437
but no one can think of any,

02:03:09,437 --> 02:03:11,806
which doesn't also expand the CTF.

02:03:11,806 --> 02:03:14,057
This is the common type format,

02:03:14,057 --> 02:03:15,775
or perhaps compact type format,

02:03:15,775 --> 02:03:18,201
or common NCC type format.

02:03:18,201 --> 02:03:19,696
It came from Solaris,

02:03:19,696 --> 02:03:21,121
and they use all three different acronyms

02:03:21,121 --> 02:03:22,400
in different places.

02:03:22,400 --> 02:03:24,368
I normally call it the compact C type format

02:03:24,368 --> 02:03:28,951
because at least it says what language it's related to.

02:03:30,516 --> 02:03:32,294
I'm sorry, these texts is much smaller

02:03:32,294 --> 02:03:35,698
than I thought it would be on this screen

02:03:35,698 --> 02:03:36,947
but I'll run over it anyway,

02:03:36,947 --> 02:03:38,247
on the basis that no one could read something

02:03:38,247 --> 02:03:40,116
that's that size.

02:03:40,116 --> 02:03:42,587
Its purpose is to be a full complete model

02:03:42,587 --> 02:03:45,837
at the C type system much like say BTF.

02:03:47,157 --> 02:03:50,425
Every type you see in a C program should be represented as

02:03:50,425 --> 02:03:54,849
and all the links between them should be correctly modeled.

02:03:54,849 --> 02:03:57,849
We also have try to map ELF function

02:03:59,528 --> 02:04:02,695
and data symbols into this dictionary,

02:04:04,061 --> 02:04:06,151
so that you can tell that,

02:04:06,151 --> 02:04:09,003
for example, what the types of the given data symbol is,

02:04:09,003 --> 02:04:10,174
what the term values

02:04:10,174 --> 02:04:13,206
and arguments of every function are

02:04:13,206 --> 02:04:17,088
and you can chase down the structures

02:04:17,088 --> 02:04:17,921
and pointers to structures

02:04:17,921 --> 02:04:20,921
and so on and so forth indefinitely.

02:04:21,871 --> 02:04:25,560
This has been around for a very long time

02:04:25,560 --> 02:04:28,007
we were finally sort of cleaning it up

02:04:28,007 --> 02:04:29,863
and up streaming it.

02:04:29,863 --> 02:04:31,854
There are patches under review for GCC

02:04:31,854 --> 02:04:35,354
to generate CTF sections and object files.

02:04:36,304 --> 02:04:38,209
There are patches it's already

02:04:38,209 --> 02:04:41,296
there is already a library in binutils

02:04:41,296 --> 02:04:42,193
which can read this thing

02:04:42,193 --> 02:04:44,110
and generate this thing

02:04:46,092 --> 02:04:47,245
and merge it together

02:04:47,245 --> 02:04:48,331
and so on and so forth.

02:04:48,331 --> 02:04:50,146
There are linker patches under review.

02:04:50,146 --> 02:04:51,286
But when I say under review I mean,

02:04:51,286 --> 02:04:53,953
I was replying to review comments

02:04:53,953 --> 02:04:55,786
just before this talk.

02:04:56,938 --> 02:04:58,602
And there are patches under review

02:04:58,602 --> 02:05:01,391
for GDB to use this when DWARF isn't available.

02:05:01,391 --> 02:05:03,714
I hope it's more usable, for more things than that

02:05:03,714 --> 02:05:07,157
and there's more about that later.

02:05:07,157 --> 02:05:10,175
The CTF section does not get stripped out of binaries

02:05:10,175 --> 02:05:12,363
unlike DWARF it stays in there.

02:05:12,363 --> 02:05:13,418
It's not a loaded section,

02:05:13,418 --> 02:05:16,677
but the idea really can always be relied upon

02:05:16,677 --> 02:05:18,052
to be present.

02:05:18,052 --> 02:05:19,999
So compactness is very important.

02:05:19,999 --> 02:05:23,470
At the moment it's about 2% the size of the debug info

02:05:23,470 --> 02:05:25,402
so the DWARF debug info.

02:05:25,402 --> 02:05:28,155
This is before we have a work

02:05:28,155 --> 02:05:29,632
before we have a working deduplicator,

02:05:29,632 --> 02:05:31,015
you're expected to be significantly smaller

02:05:31,015 --> 02:05:32,543
once there's working deduplicated,

02:05:32,543 --> 02:05:34,144
and there are improvements

02:05:34,144 --> 02:05:37,561
we can make to shrink it further as well.

02:05:38,407 --> 02:05:40,823
We have deduplicated the kernel with a previous

02:05:40,823 --> 02:05:45,559
deduplicator which reads DWARF and turns it into CTF.

02:05:45,559 --> 02:05:47,715
The amount varies depending on the kernel configuration

02:05:47,715 --> 02:05:50,322
but for our enterprise kernel with 3000 modules,

02:05:50,322 --> 02:05:54,265
and there abouts it comes to about 5.5 to six meg.

02:05:54,265 --> 02:05:56,122
It was originally about 6.5 meg

02:05:56,122 --> 02:05:59,071
with format improvements I dropped back to five meg

02:05:59,071 --> 02:06:01,024
in just the last two weeks

02:06:01,024 --> 02:06:03,212
and I expected it to fall further.

02:06:03,212 --> 02:06:05,604
This is compressed so uncompressed it would be bigger

02:06:05,604 --> 02:06:07,787
but not enormously bigger.

02:06:07,787 --> 02:06:10,371
It's much smaller than the DWARF would be.

02:06:10,371 --> 02:06:15,009
I estimate about 100 meg there abouts down to okay.

02:06:15,009 --> 02:06:17,176
(mumbles)

02:06:20,658 --> 02:06:22,742
There is no support for anything

02:06:22,742 --> 02:06:26,276
but the top level types of file scope

02:06:26,276 --> 02:06:27,690
and file scope types and variables.

02:06:27,690 --> 02:06:29,515
Things inside functions aren't supported.

02:06:29,515 --> 02:06:32,420
- [Audience] Exported symbols.

02:06:32,420 --> 02:06:35,202
Also not exported to everything.

02:06:35,202 --> 02:06:37,952
Yes, every type which is declared

02:06:39,299 --> 02:06:42,687
at the top level including things which are static,

02:06:42,687 --> 02:06:43,520
gets pulled in.

02:06:43,520 --> 02:06:45,006
Otherwise it's not used to debugging

02:06:45,006 --> 02:06:46,372
because this public stuff is going to refer

02:06:46,372 --> 02:06:50,205
to the parts of stuff which isn't public.

02:06:50,205 --> 02:06:53,647
In general, I talked with the Libabigail people

02:06:53,647 --> 02:06:55,194
were saying we want everything.

02:06:55,194 --> 02:06:56,043
It's the same attitude for me

02:06:56,043 --> 02:06:57,704
if I could do things inside functions,

02:06:57,704 --> 02:06:59,501
I would but at the moment I can't.

02:06:59,501 --> 02:07:01,334
More about that later.

02:07:02,399 --> 02:07:04,917
Most of this is done is provided in the library.

02:07:04,917 --> 02:07:09,644
It is implemented in the library and binutils libctf.

02:07:09,644 --> 02:07:12,381
There is some code in the linker in LD itself and in BFD

02:07:12,381 --> 02:07:14,042
but that's only about 1000 lines.

02:07:14,042 --> 02:07:15,932
So adding to gold and so on is perfectly possible.

02:07:15,932 --> 02:07:17,797
I don't know about adding to Clang

02:07:17,797 --> 02:07:19,382
because that leads into license health.

02:07:19,382 --> 02:07:21,505
So it's kind of above my pay grade.

02:07:21,505 --> 02:07:22,991
I don't want libcfd re-implemented.

02:07:22,991 --> 02:07:24,711
If I'd much rather have it be reused,

02:07:24,711 --> 02:07:26,838
but that requires let people thinking about licenses.

02:07:26,838 --> 02:07:27,921
I don't know.

02:07:28,949 --> 02:07:29,951
There is a spec at the moment,

02:07:29,951 --> 02:07:32,061
it's only for the latest version of CTF,

02:07:32,061 --> 02:07:36,000
but I plan to add everything else including library APIs

02:07:36,000 --> 02:07:37,421
and turn them into man pages.

02:07:37,421 --> 02:07:38,911
It will land in binutils,

02:07:38,911 --> 02:07:40,975
it's in tech info.

02:07:40,975 --> 02:07:45,366
And there's a link to the library itself as well.

02:07:45,366 --> 02:07:46,199
I thought we should compare it

02:07:46,199 --> 02:07:48,232
to things people might know about.

02:07:48,232 --> 02:07:50,212
Solaris CTF is notable for having been around

02:07:50,212 --> 02:07:51,464
for a very long time.

02:07:51,464 --> 02:07:55,214
It was the parent of all these other formats.

02:07:56,969 --> 02:07:57,973
It's a direct descendant,

02:07:57,973 --> 02:07:59,038
I they changed the magic number,

02:07:59,038 --> 02:08:00,102
I changed the section name

02:08:00,102 --> 02:08:02,533
because I changed the format.

02:08:02,533 --> 02:08:05,700
We have more sections than Solaris CTF

02:08:07,246 --> 02:08:09,589
in particular we have a section which maps strings,

02:08:09,589 --> 02:08:12,414
arbitrary names to types

02:08:12,414 --> 02:08:14,644
which can be used for things like the kernel,

02:08:14,644 --> 02:08:15,489
which has,

02:08:15,489 --> 02:08:19,488
where you don't get the data symbols from a symbol table,

02:08:19,488 --> 02:08:21,488
but from somewhere else.

02:08:22,664 --> 02:08:24,041
We dig them out of CHAOS,

02:08:24,041 --> 02:08:24,966
CHAOS seems

02:08:24,966 --> 02:08:27,646
and then you can use CTF to look at the name of that symbol

02:08:27,646 --> 02:08:29,940
and that sort of thing.

02:08:29,940 --> 02:08:33,232
We have much higher limits than Solaris CTF

02:08:33,232 --> 02:08:34,899
two to the 32 types.

02:08:35,845 --> 02:08:38,454
The strtab can be that can be that size as well,

02:08:38,454 --> 02:08:40,523
two to the 25 struct union enum members

02:08:40,523 --> 02:08:43,937
provided which is way higher than the C standard allows

02:08:43,937 --> 02:08:46,241
but it's also much of the problem is that

02:08:46,241 --> 02:08:47,585
existing things like the kernel

02:08:47,585 --> 02:08:48,636
can have very large structures

02:08:48,636 --> 02:08:50,063
and very large enums in them.

02:08:50,063 --> 02:08:51,021
We've seen enums with

02:08:51,021 --> 02:08:52,549
tenths of thousands of members in there,

02:08:52,549 --> 02:08:53,874
and we'd like to be able to represent them.

02:08:53,874 --> 02:08:55,205
So as long as I'm just raising the limits

02:08:55,205 --> 02:08:57,431
let's raise them all the way.

02:08:57,431 --> 02:08:58,379
There are a lot more type kinds.

02:08:58,379 --> 02:08:59,212
I'm actually wrong there.

02:08:59,212 --> 02:09:02,495
There are 64 of which for 14 are in use.

02:09:02,495 --> 02:09:05,982
So we can add new types of type fairly easily.

02:09:05,982 --> 02:09:08,806
There's plenty of space for expansion.

02:09:08,806 --> 02:09:11,162
We have bit fields into our CTF

02:09:11,162 --> 02:09:12,506
we never quite properly designed it.

02:09:12,506 --> 02:09:14,240
It supports (mumbles) bit fields.

02:09:14,240 --> 02:09:15,073
If you've never heard of it,

02:09:15,073 --> 02:09:16,471
that's because they don't exist.

02:09:16,471 --> 02:09:19,321
But it doesn't support enum bit fields which do exist.

02:09:19,321 --> 02:09:23,373
We fixed those with a new contraption called a slice

02:09:23,373 --> 02:09:26,897
which sits on top of existing integral types

02:09:26,897 --> 02:09:30,064
and changes their width and an offset.

02:09:33,733 --> 02:09:34,810
- Does it normalize those in eighth

02:09:34,810 --> 02:09:36,958
because like do you have the ABI problem

02:09:36,958 --> 02:09:38,416
or doesn't it get rid of the--

02:09:38,416 --> 02:09:41,584
- These are going to be aggressively deduplicated.

02:09:41,584 --> 02:09:42,790
If you go two-- - No, no, no, no

02:09:42,790 --> 02:09:44,462
the normalizing bit field order

02:09:44,462 --> 02:09:45,295
and things like that.

02:09:45,295 --> 02:09:46,935
Because right now, the C standard is wildly,

02:09:46,935 --> 02:09:50,380
well it's all implementation defined.

02:09:50,380 --> 02:09:52,963
- We are representing whatever,

02:09:54,018 --> 02:09:55,713
because nothing is using bit fields at the moment.

02:09:55,713 --> 02:09:58,566
No consumers are using bit fields because they didn't work.

02:09:58,566 --> 02:10:02,141
We can more or less pick that arbitrarily

02:10:02,141 --> 02:10:03,169
at the moment because they didn't work.

02:10:03,169 --> 02:10:05,225
We have more or less doing whatever DWARF does

02:10:05,225 --> 02:10:06,755
but I'd agreed this is incredibly annoying,

02:10:06,755 --> 02:10:09,168
so it will be nice to do something else.

02:10:09,168 --> 02:10:10,001
I mean,

02:10:11,448 --> 02:10:15,301
from DWARF this thing actually had to walk backwards

02:10:15,301 --> 02:10:16,660
in order to get the bit fields in the right order.

02:10:16,660 --> 02:10:18,077
It was ridiculous

02:10:20,278 --> 02:10:23,517
and we a as a minor thing, we have an archive format,

02:10:23,517 --> 02:10:26,148
which you can use to take multiple CTF dictionaries

02:10:26,148 --> 02:10:27,670
and slam them together

02:10:27,670 --> 02:10:31,363
and we use these to handle multiple translation units.

02:10:31,363 --> 02:10:32,816
If you've got multiple conflict types

02:10:32,816 --> 02:10:33,784
of the conflicting definitions,

02:10:33,784 --> 02:10:34,617
and so on.

02:10:34,617 --> 02:10:36,045
Most of them land in one giant dictionary

02:10:36,045 --> 02:10:37,720
but the ones with conflicting definitions

02:10:37,720 --> 02:10:40,637
land in tiny dictionaries descended

02:10:41,547 --> 02:10:45,451
from a giant one per translation unit,

02:10:45,451 --> 02:10:46,942
the parent-child relationship thing again,

02:10:46,942 --> 02:10:48,775
which is quite useful.

02:10:50,693 --> 02:10:52,526
A BTF I thought people

02:10:53,569 --> 02:10:56,911
might have paid some attention to that as well.

02:10:56,911 --> 02:10:59,140
There are a few more differences between BTF and CTF

02:10:59,140 --> 02:11:02,437
because BTF derived from Solaris CTF as well clearly

02:11:02,437 --> 02:11:05,695
but or is a cousin of it or something,

02:11:05,695 --> 02:11:06,701
but has simplified it

02:11:06,701 --> 02:11:09,140
and thrown out some of the things that we kept.

02:11:09,140 --> 02:11:10,928
CTF has parent-child relationship.

02:11:10,928 --> 02:11:12,960
So you can have a container which a dictionary

02:11:12,960 --> 02:11:14,678
which depends on another dictionary,

02:11:14,678 --> 02:11:18,622
and inherits all types from it and adds more.

02:11:18,622 --> 02:11:20,276
And BTF doesn't have that.

02:11:20,276 --> 02:11:21,769
CTF has kept floats,

02:11:21,769 --> 02:11:23,136
BTF has obviously thrown them out

02:11:23,136 --> 02:11:25,720
because there aren't any in the kernel.

02:11:25,720 --> 02:11:28,894
CTF doesn't have functioning prototype type,

02:11:28,894 --> 02:11:30,636
we have function pointer types,

02:11:30,636 --> 02:11:33,210
but BTF has a functioning prototype type

02:11:33,210 --> 02:11:34,646
in the header file,

02:11:34,646 --> 02:11:36,374
which includes a name for every parameter

02:11:36,374 --> 02:11:37,647
that seems really useful.

02:11:37,647 --> 02:11:41,629
So I think I'm going to add that to CTF.

02:11:41,629 --> 02:11:45,105
CTF can share string tables with the containing ELF object

02:11:45,105 --> 02:11:46,692
to shrink its internal string title.

02:11:46,692 --> 02:11:49,018
This can sometimes be quite a dramatic shrinkage.

02:11:49,018 --> 02:11:50,144
Obviously BTF can't do that

02:11:50,144 --> 02:11:52,209
because the kernel doesn't have a string tables to do that.

02:11:52,209 --> 02:11:55,494
So there was no point keeping it.

02:11:55,494 --> 02:11:57,033
And CTF is older than BTF,

02:11:57,033 --> 02:11:59,186
but I think they're both changing pretty fast at this point.

02:11:59,186 --> 02:12:02,943
I started making major revisions to CTF about a year ago

02:12:02,943 --> 02:12:05,483
and I didn't plan to stop.

02:12:05,483 --> 02:12:08,913
I do have a backward compatibility from it's

02:12:08,913 --> 02:12:12,844
old CTF file formats will always be readable by libctf.

02:12:12,844 --> 02:12:15,216
I also hope I'm talking about this in the later slides

02:12:15,216 --> 02:12:19,047
to be able to read original Solaris CTF and BTF

02:12:19,047 --> 02:12:22,400
and write them all as well from libctf.

02:12:22,400 --> 02:12:23,762
So I'm not competing here

02:12:23,762 --> 02:12:25,639
is more that I can possibly pick up the CTF,

02:12:25,639 --> 02:12:27,249
the compiler is generating and spit something out

02:12:27,249 --> 02:12:29,197
which is suitable BTF

02:12:29,197 --> 02:12:30,564
which fits within the range limits,

02:12:30,564 --> 02:12:31,891
and so on and so forth.

02:12:31,891 --> 02:12:33,720
So I'm hoping I'm just strictly adding

02:12:33,720 --> 02:12:35,031
to the utility of the system here

02:12:35,031 --> 02:12:37,786
rather than trying to compete with people.

02:12:37,786 --> 02:12:40,609
So why not just ignore all this completely

02:12:40,609 --> 02:12:42,368
and just use BTF?

02:12:42,368 --> 02:12:44,201
CTF has a wider scope.

02:12:45,297 --> 02:12:47,991
I didn't think BTF is ever plan to be useful for user space,

02:12:47,991 --> 02:12:50,812
but I've got all sorts of ideas for CTF being used

02:12:50,812 --> 02:12:52,748
for C programs to introspect their own types,

02:12:52,748 --> 02:12:54,797
even if they're not in the kernel.

02:12:54,797 --> 02:12:56,470
It's got much wider range limits.

02:12:56,470 --> 02:12:58,785
I'm wondering and looking at the BTF range limits

02:12:58,785 --> 02:13:00,929
which are the same as the Solaris ones.

02:13:00,929 --> 02:13:03,404
If no one's ever tried to build a C BGF

02:13:03,404 --> 02:13:05,920
converting all the types in a full enterprise kernel,

02:13:05,920 --> 02:13:07,411
including all the modules,

02:13:07,411 --> 02:13:09,741
because I tried it with CTF with Solaris CTF,

02:13:09,741 --> 02:13:10,847
and there just isn't room.

02:13:10,847 --> 02:13:12,992
You run out, even if you deduplicate things,

02:13:12,992 --> 02:13:15,716
there's more than 65,000 types in there.

02:13:15,716 --> 02:13:16,734
So at some point,

02:13:16,734 --> 02:13:18,230
BTF will need to expand its range.

02:13:18,230 --> 02:13:19,517
CTF of already has,

02:13:19,517 --> 02:13:22,966
so I can probably give advice on how to do that.

02:13:22,966 --> 02:13:24,326
We will be able to emit BTF.

02:13:24,326 --> 02:13:27,374
I'm hoping we'll be able to translate in both directions

02:13:27,374 --> 02:13:29,284
so you could pick

02:13:29,284 --> 02:13:30,829
if I hadn't been designed the API for this yet,

02:13:30,829 --> 02:13:31,795
but the idea is that

02:13:31,795 --> 02:13:34,142
we can sort of act as a universal translator

02:13:34,142 --> 02:13:36,315
in all directions for all of these types,

02:13:36,315 --> 02:13:38,431
with CTF always being able to handle a superset

02:13:38,431 --> 02:13:39,396
of all of them.

02:13:39,396 --> 02:13:44,396
This isn't really implemented yet but it's a future goal.

02:13:44,439 --> 02:13:47,356
GCC has recently gained BTF support

02:13:48,828 --> 02:13:49,796
in the next talk

02:13:49,796 --> 02:13:51,761
and with CTF support as well,

02:13:51,761 --> 02:13:53,969
we'll be able to generate CTF for BPF programs

02:13:53,969 --> 02:13:56,814
and hopefully converted into BTF

02:13:56,814 --> 02:13:58,871
using the machinery I just mentioned.

02:13:58,871 --> 02:14:02,280
So again, this is still all being written,

02:14:02,280 --> 02:14:05,210
though at least the conversion part.

02:14:05,210 --> 02:14:06,043
So,

02:14:07,568 --> 02:14:09,521
What am I plan to do with all of this?

02:14:09,521 --> 02:14:11,145
Well, first up,

02:14:11,145 --> 02:14:15,114
it would be nice to be able to use CTF in the kernel.

02:14:15,114 --> 02:14:17,355
But in order to do that we need a version of glibc here

02:14:17,355 --> 02:14:18,443
that would work in the kernel,

02:14:18,443 --> 02:14:19,447
or we might need one

02:14:19,447 --> 02:14:22,864
and at the moment it's purely user space.

02:14:23,791 --> 02:14:25,769
If it's gonna be used in the kernel,

02:14:25,769 --> 02:14:27,596
it seems likely will often be useful

02:14:27,596 --> 02:14:29,679
in atomic context panics,

02:14:31,362 --> 02:14:33,053
anything running in interactive context,

02:14:33,053 --> 02:14:34,692
anything running from a trap.

02:14:34,692 --> 02:14:36,199
So we'd like a version of libctf

02:14:36,199 --> 02:14:38,762
which did no memory allocation at all,

02:14:38,762 --> 02:14:41,963
or not libctf as a whole but at the read side.

02:14:41,963 --> 02:14:43,451
I didn't think we were ever gonna want to create

02:14:43,451 --> 02:14:45,443
CTF dictionaries from inside the kernel

02:14:45,443 --> 02:14:47,647
and libctf can do both.

02:14:47,647 --> 02:14:49,080
Creating a dictionary is much more complicated

02:14:49,080 --> 02:14:53,034
than reading one that's already present.

02:14:53,034 --> 02:14:54,964
One other caveat I should have put on the slide

02:14:54,964 --> 02:14:56,697
on the Solaris front if anyone's ever tried

02:14:56,697 --> 02:14:59,530
creating dictionaries from Solaris libctf,

02:14:59,530 --> 02:15:01,135
it's terrifyingly slow.

02:15:01,135 --> 02:15:03,058
It gets exponentially slower the more you add to it,

02:15:03,058 --> 02:15:04,815
I fix that a few months ago.

02:15:04,815 --> 02:15:07,477
It's not true libctf you can create containers

02:15:07,477 --> 02:15:08,364
and there's dictionaries

02:15:08,364 --> 02:15:12,286
and there's really you can't see it in the profile.

02:15:12,286 --> 02:15:15,757
I want to be able to support big enum values.

02:15:15,757 --> 02:15:19,340
BTF and CTF currently say enumerated values

02:15:20,199 --> 02:15:22,201
must fit within two to 32.

02:15:22,201 --> 02:15:23,174
C doesn't say that

02:15:23,174 --> 02:15:26,409
and here you can have there any integral types.

02:15:26,409 --> 02:15:29,081
So it could easily have a two to the 64 minus one value

02:15:29,081 --> 02:15:30,861
and the kernel has some.

02:15:30,861 --> 02:15:33,061
So I'm going to have to revamp

02:15:33,061 --> 02:15:35,361
to do a bit of a format change for that libcfd.

02:15:35,361 --> 02:15:37,653
Of course keep its backward compatibility from us

02:15:37,653 --> 02:15:40,396
so that we will be able to read the old ones.

02:15:40,396 --> 02:15:44,502
- I think on that specific point C and C++ differ.

02:15:44,502 --> 02:15:46,051
- C certainly says any integral

02:15:46,051 --> 02:15:47,420
and the kernel relies on it.

02:15:47,420 --> 02:15:49,390
So I bet CTF can better handle it.

02:15:49,390 --> 02:15:51,041
- I remember because you ran into it...

02:15:51,041 --> 02:15:52,374
- You are right.

02:15:56,339 --> 02:16:01,256
- But you can certainly say the two to the 32 plus five ULL

02:16:02,784 --> 02:16:03,617
in GCC in a CE normal initializer

02:16:03,617 --> 02:16:05,755
and it will work fine.

02:16:05,755 --> 02:16:07,886
So I think it would be nice if I could represent that

02:16:07,886 --> 02:16:08,815
rather than just saying

02:16:08,815 --> 02:16:11,290
I'm gonna ignore that anyway to type.

02:16:11,290 --> 02:16:13,707
No one's gonna use it, right?

02:16:14,777 --> 02:16:17,081
We're going to and I'm considering

02:16:17,081 --> 02:16:19,369
adding a section for kernel functions symbols

02:16:19,369 --> 02:16:21,531
much like the one for kernel data symbols.

02:16:21,531 --> 02:16:23,902
So that you can go from a name

02:16:23,902 --> 02:16:25,899
to a full prototype,

02:16:25,899 --> 02:16:30,201
instead of just from an ELF symbol to a full prototype.

02:16:30,201 --> 02:16:31,287
Again, I only just thought of it.

02:16:31,287 --> 02:16:33,979
So that's hasn't been designed at all.

02:16:33,979 --> 02:16:35,448
Why I'd like to support all of GNU C

02:16:35,448 --> 02:16:36,995
or at least more of GNU C.

02:16:36,995 --> 02:16:38,573
The kernel uses vector extensions,

02:16:38,573 --> 02:16:40,190
which is something only discovered recently

02:16:40,190 --> 02:16:43,677
and there's no support for that in CTF yet.

02:16:43,677 --> 02:16:46,468
I can't remember where it's somewhere in the raid code.

02:16:46,468 --> 02:16:48,679
It uses vector types at the global

02:16:48,679 --> 02:16:51,063
and the static files scope.

02:16:51,063 --> 02:16:52,554
I wanna be able to translate in all directions.

02:16:52,554 --> 02:16:53,405
I want a battery,

02:16:53,405 --> 02:16:55,738
we want the battery section,

02:16:56,588 --> 02:16:59,072
but which is not really designed,

02:16:59,072 --> 02:17:00,686
so that someone can

02:17:00,686 --> 02:17:02,653
we'd like to take from everything DWARF,

02:17:02,653 --> 02:17:04,594
a DWARF and ORC

02:17:04,594 --> 02:17:07,177
I think ORC has the opposite of

02:17:09,212 --> 02:17:11,022
I'd like it to be simpler than DWARF.

02:17:11,022 --> 02:17:12,909
No interpreters, thank you.

02:17:12,909 --> 02:17:14,252
I hope we can describe most things

02:17:14,252 --> 02:17:18,085
without needing the complexity of extra locks.

02:17:19,119 --> 02:17:21,537
I'd like to be able to be oriented to online debugging

02:17:21,537 --> 02:17:23,715
and I think I say in a couple of pages later,

02:17:23,715 --> 02:17:27,101
yes, that we would like to be able to

02:17:27,101 --> 02:17:29,541
we almost have the opposite view of all ork.

02:17:29,541 --> 02:17:32,458
As I understand it is interested in

02:17:33,374 --> 02:17:36,298
reducing the complexity even if it means increasing size

02:17:36,298 --> 02:17:38,993
just to reduce the complexity of the reader.

02:17:38,993 --> 02:17:41,512
- It's speed it needs.

02:17:41,512 --> 02:17:44,212
- I'm interested in that as well.

02:17:44,212 --> 02:17:47,803
Because I don't mind if the code is more complicated

02:17:47,803 --> 02:17:49,038
as long as this formatting isn't complicated.

02:17:49,038 --> 02:17:52,347
- Well there is just finished character

02:17:52,347 --> 02:17:55,660
that has very specific views on complexity

02:17:55,660 --> 02:17:56,840
and the unwinder.

02:17:56,840 --> 02:17:58,989
- Well, I'm interested in reducing size here as well.

02:17:58,989 --> 02:18:00,053
Presumably interested the kernel is interested

02:18:00,053 --> 02:18:03,724
in reducing size because it's all an unstoppable memory.

02:18:03,724 --> 02:18:05,201
- It's not been a problem.

02:18:05,201 --> 02:18:09,409
ORC has been designed for speed and for simplicity,

02:18:09,409 --> 02:18:13,909
because when you unwind specifically in bug and panics

02:18:14,751 --> 02:18:16,198
everything's gone to shit.

02:18:16,198 --> 02:18:17,156
- Yes, you did.

02:18:17,156 --> 02:18:18,447
I certainly don't want the unwinder

02:18:18,447 --> 02:18:20,099
to require memory allocation for example.

02:18:20,099 --> 02:18:22,172
That will be a disaster in more cases.

02:18:22,172 --> 02:18:25,173
- Yeah, so ORC has worked really well for us.

02:18:25,173 --> 02:18:29,923
- But I didn't mind a tangle of conditionals for example.

02:18:31,423 --> 02:18:32,914
But I would like to be able to take ideas

02:18:32,914 --> 02:18:33,882
from everybody on that

02:18:33,882 --> 02:18:35,007
because it hasn't really been designed

02:18:35,007 --> 02:18:38,674
who would have made everything else instead.

02:18:40,425 --> 02:18:41,258
On the format side,

02:18:41,258 --> 02:18:42,820
I'm like to increase compactness,

02:18:42,820 --> 02:18:44,379
boosting range boosting all the ranges

02:18:44,379 --> 02:18:47,655
did reduce the components of the format a bit.

02:18:47,655 --> 02:18:51,322
I know how to get all of that back and more.

02:18:52,528 --> 02:18:55,028
For example, having a variant

02:18:57,038 --> 02:18:59,522
which only supports really specific types

02:18:59,522 --> 02:19:01,427
which only support small type IDs,

02:19:01,427 --> 02:19:02,510
which is okay

02:19:04,119 --> 02:19:05,703
because that means you've put heavily referenced types

02:19:05,703 --> 02:19:06,536
at low IDs

02:19:06,536 --> 02:19:08,092
and then it means you can use a smaller representation

02:19:08,092 --> 02:19:10,842
for any type of reference system.

02:19:12,066 --> 02:19:13,214
- That's effectively the same concept

02:19:13,214 --> 02:19:15,277
is like JavaScript modify, right?

02:19:15,277 --> 02:19:16,521
- Well except you could be down by the linker

02:19:16,521 --> 02:19:17,358
so you could pay attention.

02:19:17,358 --> 02:19:18,191
Yeah,

02:19:18,191 --> 02:19:19,154
We've already got overlapping representations.

02:19:19,154 --> 02:19:21,686
But the overlapping representations are for normal types,

02:19:21,686 --> 02:19:23,430
and unbelievably gigantic types.

02:19:23,430 --> 02:19:26,643
And we should probably add ones to small types as well.

02:19:26,643 --> 02:19:28,519
I'd like to be able to put,

02:19:28,519 --> 02:19:30,009
I've tried optimizing the string table,

02:19:30,009 --> 02:19:31,042
which is gigantic,

02:19:31,042 --> 02:19:32,261
it's often the biggest part of CTF

02:19:32,261 --> 02:19:34,022
and it's really hard to have CTF dictionaries,

02:19:34,022 --> 02:19:35,670
it's all it's quite hard to compress.

02:19:35,670 --> 02:19:38,201
I tried to compress it by splitting up

02:19:38,201 --> 02:19:40,298
at underscores in case changes,

02:19:40,298 --> 02:19:43,125
and turning identifiers into links to lots of

02:19:43,125 --> 02:19:44,990
and it was a great idea until you compress it

02:19:44,990 --> 02:19:46,714
and then the compression dictionary was destroyed

02:19:46,714 --> 02:19:49,541
by all these variations and the size went up.

02:19:49,541 --> 02:19:52,075
But what I can do without adding

02:19:52,075 --> 02:19:53,937
any complex extra links anywhere,

02:19:53,937 --> 02:19:57,097
is to say that if the structure has a constant prefix

02:19:57,097 --> 02:20:00,521
on all its members that we stole that prefix once.

02:20:00,521 --> 02:20:02,809
Because there's no need to store a pointer to it

02:20:02,809 --> 02:20:05,570
because if there's a prefix there we just use it.

02:20:05,570 --> 02:20:08,503
It seems to be that will be turning the symbols into zero

02:20:08,503 --> 02:20:11,573
into nothing and we'll be almost certainly reduce size

02:20:11,573 --> 02:20:12,918
but at least the things that have the standard

02:20:12,918 --> 02:20:15,628
of the old standard of lot of consonant prefix

02:20:15,628 --> 02:20:18,045
on every member of structure.

02:20:20,477 --> 02:20:21,518
It's fairly common.

02:20:21,518 --> 02:20:23,889
You see-- - [Audience] Yeah.

02:20:23,889 --> 02:20:25,828
- Yeah, like C does it,

02:20:25,828 --> 02:20:27,806
the historical reason is ridiculous,

02:20:27,806 --> 02:20:31,249
but certainly some people like it to make it (mumbles)

02:20:31,249 --> 02:20:32,484
I'd like to try to Burrows-Wheeler

02:20:32,484 --> 02:20:33,317
compress as much as possible

02:20:33,317 --> 02:20:34,532
first to see if its perform

02:20:34,532 --> 02:20:37,211
handled in a sensible fashion.

02:20:37,211 --> 02:20:40,538
I'd like to try compressing with LZMA instead of just Gzip.

02:20:40,538 --> 02:20:42,550
It seems like there's a cheap ways to get piles

02:20:42,550 --> 02:20:45,955
of extra compactness with almost no effort.

02:20:45,955 --> 02:20:47,544
It wouldn't improve memory usage,

02:20:47,544 --> 02:20:51,023
but it would at least the compression format slower.

02:20:51,023 --> 02:20:52,195
I wanna get rid of our archives.

02:20:52,195 --> 02:20:54,300
It was an ad hoc format.

02:20:54,300 --> 02:20:57,312
It's okay for gigantic use cases like the kernel,

02:20:57,312 --> 02:21:00,001
but for almost every other use case

02:21:00,001 --> 02:21:01,792
it'd be much more simple to just teach CTF

02:21:01,792 --> 02:21:04,042
or the translation unit is,

02:21:05,164 --> 02:21:06,271
so that you can have one dictionary

02:21:06,271 --> 02:21:08,802
with multiple types of different translation units in.

02:21:08,802 --> 02:21:10,119
Which would mean they would magically share

02:21:10,119 --> 02:21:11,691
their string tables and so on and so forth,

02:21:11,691 --> 02:21:14,125
which should improve compilers more.

02:21:14,125 --> 02:21:16,103
- So the parent-child relationship archives

02:21:16,103 --> 02:21:18,104
seem to make sense modules.

02:21:18,104 --> 02:21:20,868
Oh, yes, that's what we're currently doing.

02:21:20,868 --> 02:21:22,664
That we have a container,

02:21:22,664 --> 02:21:24,452
a major a dictionary with everything

02:21:24,452 --> 02:21:26,388
which is used by more than one module,

02:21:26,388 --> 02:21:28,280
and one dictionary per module.

02:21:28,280 --> 02:21:30,479
In fact, we shuffle things differently for the kernel

02:21:30,479 --> 02:21:31,312
and for everything else.

02:21:31,312 --> 02:21:34,074
For the kernel things go in the per module,

02:21:34,074 --> 02:21:34,907
if the dictionary

02:21:34,907 --> 02:21:37,286
if they're only used by one module.

02:21:37,286 --> 02:21:38,725
For almost everything else,

02:21:38,725 --> 02:21:43,171
we are saying that all types unless they're conflicting

02:21:43,171 --> 02:21:44,247
go in the global dictionary

02:21:44,247 --> 02:21:46,203
with only conflicting one's go in

02:21:46,203 --> 02:21:47,767
per translation needed dictionaries,

02:21:47,767 --> 02:21:50,245
simply because it's smaller

02:21:50,245 --> 02:21:51,704
and it's more likely the case

02:21:51,704 --> 02:21:54,689
that people will need most of the types.

02:21:54,689 --> 02:21:56,698
For the kernel often you only need the types

02:21:56,698 --> 02:21:58,149
and the core kernel of a couple of modules

02:21:58,149 --> 02:22:00,733
and it doesn't loop when even loading the rest.

02:22:00,733 --> 02:22:03,053
But this is all customizable.

02:22:03,053 --> 02:22:07,346
It's all implemented in this shared libctf linking machinery

02:22:07,346 --> 02:22:09,630
so you can write your own link like thing

02:22:09,630 --> 02:22:11,804
and use whatever strategy you see fit

02:22:11,804 --> 02:22:14,624
and deduplicate across that.

02:22:14,624 --> 02:22:17,051
Interesting when you're deduplicating,

02:22:17,051 --> 02:22:19,275
squashing things into one module per child

02:22:19,275 --> 02:22:20,570
has an interesting consequence.

02:22:20,570 --> 02:22:23,717
What happens if two translation unit to the single module

02:22:23,717 --> 02:22:26,884
defined types in conflicting fashions?

02:22:27,937 --> 02:22:29,524
What happens if you have two translation

02:22:29,524 --> 02:22:31,647
you get to define the straight same structure

02:22:31,647 --> 02:22:32,480
in different ways

02:22:32,480 --> 02:22:33,835
and a bunch of other translation units

02:22:33,835 --> 02:22:37,002
that just have opaque forwards to them.

02:22:37,002 --> 02:22:41,150
And that's where a case the kernel does actually use

02:22:41,150 --> 02:22:42,870
and I know how to solve within the deduplicated,

02:22:42,870 --> 02:22:46,154
but I haven't actually implemented it yet.

02:22:46,154 --> 02:22:49,257
We would chase if there's only one

02:22:49,257 --> 02:22:50,937
and if it's a non-conflicting use,

02:22:50,937 --> 02:22:51,908
we would link the more laps

02:22:51,908 --> 02:22:54,066
all the forwards would turn into links

02:22:54,066 --> 02:22:55,081
to the real structure.

02:22:55,081 --> 02:22:56,901
If there are two conflicting definitions,

02:22:56,901 --> 02:22:59,430
one of them would be considered canonical

02:22:59,430 --> 02:23:00,268
and will be loockable up

02:23:00,268 --> 02:23:01,617
when you looked at that structure by name,

02:23:01,617 --> 02:23:02,805
the other one would be hidden

02:23:02,805 --> 02:23:04,137
and it would be only be visible

02:23:04,137 --> 02:23:06,276
where if you followed pointers specifically

02:23:06,276 --> 02:23:07,456
to that structure

02:23:07,456 --> 02:23:08,641
and we pick it to says that the one

02:23:08,641 --> 02:23:11,745
that had most pointers to it got made visible.

02:23:11,745 --> 02:23:15,751
I can't see another way to solve this problem it's very rare

02:23:15,751 --> 02:23:17,862
and all the forwards in that case would just stay forwards

02:23:17,862 --> 02:23:22,862
because we don't know which one they're referring to.

02:23:22,887 --> 02:23:27,054
- It might actually make sense to issue a warning.

02:23:28,842 --> 02:23:30,471
- Oh, what we get is actually valid C.

02:23:30,471 --> 02:23:31,304
So--

02:23:31,304 --> 02:23:33,971
- What I mean it is but I mean--

02:23:35,273 --> 02:23:36,106
- It's gruesome

02:23:36,106 --> 02:23:37,349
but it's valid C so I want to be able to encode it

02:23:37,349 --> 02:23:38,182
without falling over.

02:23:38,182 --> 02:23:41,520
- But at least issue a warning so we can fix it.

02:23:41,520 --> 02:23:43,273
It is pretty shit too--

02:23:43,273 --> 02:23:44,906
- I might make it a warning you can turn off and on

02:23:44,906 --> 02:23:46,756
so that it could be turned on with the debugging options

02:23:46,756 --> 02:23:47,589
or something.

02:23:47,589 --> 02:23:49,768
So I don't like it when normal kernel build

02:23:49,768 --> 02:23:52,165
spray warnings that no users care about.

02:23:52,165 --> 02:23:53,276
But yes, I agree

02:23:53,276 --> 02:23:56,990
It would be nice to we should probably warned about this.

02:23:56,990 --> 02:23:58,311
Yeah.

02:23:58,311 --> 02:24:00,193
Well and not if you're actually

02:24:00,193 --> 02:24:02,497
if you've got other things that have forwards to it,

02:24:02,497 --> 02:24:04,509
which might be passed to either of them.

02:24:04,509 --> 02:24:06,666
It might require a major re-architecture,

02:24:06,666 --> 02:24:08,166
I don't claim to--

02:24:11,185 --> 02:24:16,047
- Don't we have (mumbles) for things like this?

02:24:16,047 --> 02:24:20,380
- I have seen uses mostly in the old ISA sound code.

02:24:21,521 --> 02:24:23,078
Who care about the--

02:24:23,078 --> 02:24:27,163
- [Audience] I'm happily unfamiliar with that code.

02:24:27,163 --> 02:24:30,680
- And last bit I noticed the text size on this slide

02:24:30,680 --> 02:24:31,586
is slightly still different

02:24:31,586 --> 02:24:35,370
despite my attempt to try to fix it.

02:24:35,370 --> 02:24:36,952
I was wondering what I could do

02:24:36,952 --> 02:24:39,247
which the kernel would find useful.

02:24:39,247 --> 02:24:41,463
In can kernel associated stuff DWARF

02:24:41,463 --> 02:24:44,878
has code to read the old Solaris and Free BSD CTF already.

02:24:44,878 --> 02:24:48,057
I'll be quite happy to once I've got libctf

02:24:48,057 --> 02:24:51,078
reading everything to read to submit a patch that

02:24:51,078 --> 02:24:52,642
has it using libctf instead,

02:24:52,642 --> 02:24:53,532
so we could read everything,

02:24:53,532 --> 02:24:58,108
and it wouldn't be quite so much code to maintain.

02:24:58,108 --> 02:24:59,819
I've been thinking about acting as a source of data

02:24:59,819 --> 02:25:01,756
for the Kernel backtracers.

02:25:01,756 --> 02:25:03,447
But this is a bit tricky

02:25:03,447 --> 02:25:05,280
because either we need

02:25:07,077 --> 02:25:08,883
the in-kernel variant of dlibctf

02:25:08,883 --> 02:25:11,869
and all the CTF on linked in to the kernel and loaded,

02:25:11,869 --> 02:25:12,956
which uses more memory

02:25:12,956 --> 02:25:14,277
and people might say no to

02:25:14,277 --> 02:25:16,902
or we could either use a space helper that use libctf,

02:25:16,902 --> 02:25:18,299
and you call down to it,

02:25:18,299 --> 02:25:20,322
which would obviously you couldn't do in the case of panics

02:25:20,322 --> 02:25:21,155
because there's no time.

02:25:21,155 --> 02:25:22,294
They can't if everything's dead.

02:25:22,294 --> 02:25:27,294
We do very frequent backtracers from (mumbles) context,

02:25:27,413 --> 02:25:28,307
- In that case that pretty much destroys

02:25:28,307 --> 02:25:30,608
all of those options and in-kernel (laughs)

02:25:30,608 --> 02:25:33,941
- We do many backtracers from locked up.

02:25:35,457 --> 02:25:37,624
Backtracers are important.

02:25:38,875 --> 02:25:40,049
- In-kernel non-malloc

02:25:40,049 --> 02:25:42,565
(mumbling)

02:25:42,565 --> 02:25:44,415
We would certainly be able to improve

02:25:44,415 --> 02:25:46,306
even without the battery section,

02:25:46,306 --> 02:25:47,798
we would certainly be able to improve

02:25:47,798 --> 02:25:49,474
the quality of backtracers.

02:25:49,474 --> 02:25:51,932
Because with the battery section,

02:25:51,932 --> 02:25:54,989
we could probably turn it from just function names

02:25:54,989 --> 02:25:57,199
into names and all the argument types

02:25:57,199 --> 02:25:58,253
and you can add something

02:25:58,253 --> 02:26:00,398
but let me drill down through them as well.

02:26:00,398 --> 02:26:02,108
Which is something that I don't think people

02:26:02,108 --> 02:26:03,278
had considered before now

02:26:03,278 --> 02:26:04,489
because it seemed completely ridiculous

02:26:04,489 --> 02:26:07,406
but it would certainly become easy.

02:26:08,642 --> 02:26:12,892
- There is actually people working on some of that.

02:26:15,675 --> 02:26:18,758
Most specific for the function tracer

02:26:19,992 --> 02:26:22,193
we already have the fentry hook

02:26:22,193 --> 02:26:24,422
and the if you use a function graph ratio,

02:26:24,422 --> 02:26:28,089
we also do unspeakable things to the return.

02:26:28,968 --> 02:26:30,323
- [Speaker] That's the function tracer.

02:26:30,323 --> 02:26:31,573
- Yeah, I know.

02:26:32,908 --> 02:26:36,329
People were looking at having that print function arguments

02:26:36,329 --> 02:26:37,162
and all that

02:26:37,162 --> 02:26:40,385
and we've talked about doing it on backtracers as well,

02:26:40,385 --> 02:26:41,777
but nobody ever...

02:26:41,777 --> 02:26:43,763
Yeah, so if we have the information,

02:26:43,763 --> 02:26:45,513
we could maybe do it.

02:26:46,439 --> 02:26:49,272
It's not something I've personally

02:26:52,528 --> 02:26:53,603
have had a need for.

02:26:53,603 --> 02:26:54,951
- The option is there now

02:26:54,951 --> 02:26:56,999
and it's probably wouldn't be terribly difficult--

02:26:56,999 --> 02:26:59,671
- [Audience] As long as you have the type info for function.

02:26:59,671 --> 02:27:00,680
- Yep.

02:27:00,680 --> 02:27:01,513
- [Audience] Basically all you need--

02:27:01,513 --> 02:27:02,346
- We've already got that

02:27:02,346 --> 02:27:03,944
all I want to add is the parameter names.

02:27:03,944 --> 02:27:06,367
- Yeah, so strictly speaking,

02:27:06,367 --> 02:27:09,679
all we need for a specific function

02:27:09,679 --> 02:27:12,396
is how many arguments it has

02:27:12,396 --> 02:27:13,813
and maybe a size.

02:27:15,839 --> 02:27:16,888
- It depends on the argument

02:27:16,888 --> 02:27:18,159
and I'm sure there are some functions

02:27:18,159 --> 02:27:20,188
to get past Chars and things.

02:27:20,188 --> 02:27:22,942
- And you don't need to know

02:27:22,942 --> 02:27:24,683
what is the kind of it's argument

02:27:24,683 --> 02:27:28,831
so you can't find it you know according to the ABI

02:27:28,831 --> 02:27:29,748
Like, okay.

02:27:33,125 --> 02:27:36,156
- I mean, if you know how many arguments that has,

02:27:36,156 --> 02:27:38,310
we already know what registers to look at,

02:27:38,310 --> 02:27:41,319
because we have a purely register based convention,

02:27:41,319 --> 02:27:42,902
at least in x86_64.

02:27:44,170 --> 02:27:46,413
I mean, we do build the stack,

02:27:46,413 --> 02:27:47,246
but--

02:27:47,246 --> 02:27:49,571
- [Audience] I'm aware they are on the stack.

02:27:49,571 --> 02:27:51,569
- But we have a kernel function for that,

02:27:51,569 --> 02:27:55,569
we just give it the number of arguments and then

02:27:57,190 --> 02:27:58,416
it goes fine.

02:27:58,416 --> 02:27:59,660
Doesn't find it.

02:27:59,660 --> 02:28:00,837
- [Audience] Depending where you are in the function

02:28:00,837 --> 02:28:02,044
that already might be overwritten

02:28:02,044 --> 02:28:04,016
like it maybe saved--

02:28:04,016 --> 02:28:05,707
(mumbling)

02:28:05,707 --> 02:28:06,828
- But it potentially it's still there.

02:28:06,828 --> 02:28:08,229
- Potentially yeah.

02:28:08,229 --> 02:28:09,963
Okay I thought--

02:28:09,963 --> 02:28:11,556
- [Audience] It gets difficult.

02:28:11,556 --> 02:28:13,909
- Yes I'm just thinking of full backtraces

02:28:13,909 --> 02:28:17,074
here where you clearly need more than just

02:28:17,074 --> 02:28:17,964
look at the current function

02:28:17,964 --> 02:28:18,797
current...

02:28:20,336 --> 02:28:24,769
- But actually our motivation to work on this process

02:28:24,769 --> 02:28:25,604
there're some people

02:28:25,604 --> 02:28:27,271
this is in users now

02:28:30,620 --> 02:28:35,040
who are interested in basically in a fast way

02:28:35,040 --> 02:28:38,585
to recover the original values past a given function

02:28:38,585 --> 02:28:40,085
whenever possible.

02:28:41,109 --> 02:28:43,197
- Without leading all the doors of debuginfo--

02:28:43,197 --> 02:28:46,914
- Exactly without having to implement a little stuck machine

02:28:46,914 --> 02:28:48,247
so you can well.

02:28:49,152 --> 02:28:52,254
- I prefer I prefer 2% or less than

02:28:52,254 --> 02:28:56,754
of the size of the executable to 10 gig sort of thing.

02:29:00,606 --> 02:29:02,672
So one of the things that we're interested in is

02:29:02,672 --> 02:29:05,873
we would like to be able to like do post-mortem debugging

02:29:05,873 --> 02:29:07,706
without needing DWARF.

02:29:08,767 --> 02:29:10,140
- You can certainly do that.

02:29:10,140 --> 02:29:12,104
- Exactly, so like for backtracers

02:29:12,104 --> 02:29:16,042
and being able to get arguments that would be key for us.

02:29:16,042 --> 02:29:18,620
- Yes, we obviously can't do info locals,

02:29:18,620 --> 02:29:20,331
because we're not tracking that sort of thing

02:29:20,331 --> 02:29:22,057
but I think the goal of the backtrace section

02:29:22,057 --> 02:29:24,298
all of this is to let BT work,

02:29:24,298 --> 02:29:25,592
which honestly, as far as I can tell,

02:29:25,592 --> 02:29:28,350
there is 90% of what people do with GDB anyway.

02:29:28,350 --> 02:29:30,243
If most of the rest is runtime

02:29:30,243 --> 02:29:31,266
and if you're messing about with breakpoints,

02:29:31,266 --> 02:29:35,457
and this is then you've presumably got all the debug info.

02:29:35,457 --> 02:29:36,654
- Is there any way to get any of like

02:29:36,654 --> 02:29:39,844
the argument attributes in there like function attributes

02:29:39,844 --> 02:29:42,791
as well like no return or non--

02:29:42,791 --> 02:29:43,624
- [Speaker] Thank you.

02:29:43,624 --> 02:29:44,774
I hadn't thought of that

02:29:44,774 --> 02:29:48,202
and that's a good thing to do in the next version (laughs).

02:29:48,202 --> 02:29:49,215
- You can maybe make a backtrace that says

02:29:49,215 --> 02:29:50,048
this argument is known

02:29:50,048 --> 02:29:51,114
and it's not supposed to be.

02:29:51,114 --> 02:29:53,060
- Yeah, we should definitely be adding

02:29:53,060 --> 02:29:55,703
as many attributes as possible.

02:29:55,703 --> 02:29:56,536
In most cases,

02:29:56,536 --> 02:30:01,352
I think it'll basically be a bit flag of some kind.

02:30:01,352 --> 02:30:02,329
We've got the advantage

02:30:02,329 --> 02:30:03,862
that most functions don't have accurate

02:30:03,862 --> 02:30:05,322
and most arguments don't have attributes.

02:30:05,322 --> 02:30:07,898
So it's not gonna make things much larger

02:30:07,898 --> 02:30:10,928
and most of them are single bit flags anyway.

02:30:10,928 --> 02:30:11,761
I was wondering if we could use it

02:30:11,761 --> 02:30:14,146
to help other people wondering if we could use it to help

02:30:14,146 --> 02:30:15,576
the kABI checker in some way.

02:30:15,576 --> 02:30:16,830
I mean, one of my biggest problem here is

02:30:16,830 --> 02:30:19,094
I tried to understand what the kABI checker was doing

02:30:19,094 --> 02:30:21,133
and it just drove me mad.

02:30:21,133 --> 02:30:23,150
Clearly adding in most cases,

02:30:23,150 --> 02:30:25,221
adding things doesn't break the ABI.

02:30:25,221 --> 02:30:26,893
Except that I think it would change structure sizes

02:30:26,893 --> 02:30:29,437
and wouldn't break the ABI.

02:30:29,437 --> 02:30:31,132
So if I understood what it was doing,

02:30:31,132 --> 02:30:32,222
maybe I could--

02:30:32,222 --> 02:30:33,467
- So on a personal note,

02:30:33,467 --> 02:30:36,537
I'd like to abolish kABI and not make.

02:30:36,537 --> 02:30:37,370
- [Speaker] Oh, yeah.

02:30:37,370 --> 02:30:39,245
- Anything they're easier.

02:30:39,245 --> 02:30:41,953
I prefer to make it harder--

02:30:41,953 --> 02:30:43,828
- [Speaker] Oh yeah, but - To preserve kABI.

02:30:43,828 --> 02:30:45,404
- Those of us who had to deal with enterprise kernels

02:30:45,404 --> 02:30:46,678
have to deal with this monster

02:30:46,678 --> 02:30:47,511
and will have to deal with it--

02:30:47,511 --> 02:30:49,571
- While they're doing it wrong

02:30:49,571 --> 02:30:52,292
and when I was in the position I kept telling people that.

02:30:52,292 --> 02:30:53,125
- [Speaker] Oh, yeah.

02:30:53,125 --> 02:30:54,697
- Is wrong on all levels.

02:30:54,697 --> 02:30:56,549
- Oh yeah, but I'm just trying to live in the world as it is

02:30:56,549 --> 02:30:58,000
in which people want the kABI checker

02:30:58,000 --> 02:30:59,864
and I'd like not to have to slow the build down

02:30:59,864 --> 02:31:02,669
by masses to rebuilding all the DWARF and then scanning it,

02:31:02,669 --> 02:31:05,300
it should be something can be done like that with this tiny,

02:31:05,300 --> 02:31:07,246
tiny CGF thing is possible.

02:31:07,246 --> 02:31:08,728
- [Audience] And without kABI

02:31:08,728 --> 02:31:10,515
some of us might not have paychecks.

02:31:10,515 --> 02:31:14,182
- Because we do have very all the variables.

02:31:15,430 --> 02:31:17,178
- So when I was in Red Hat in the (mumbles)

02:31:17,178 --> 02:31:21,483
what I suggested is for all the magic modules

02:31:21,483 --> 02:31:23,667
that we apparently support,

02:31:23,667 --> 02:31:26,122
get us a source code,

02:31:26,122 --> 02:31:27,987
stick it in the REL tree

02:31:27,987 --> 02:31:28,820
and we'll just update it

02:31:28,820 --> 02:31:32,223
right along with all the other things.

02:31:32,223 --> 02:31:34,078
- [Speaker] The problem there is--

02:31:34,078 --> 02:31:36,385
- You could have...

02:31:36,385 --> 02:31:38,863
- Every time ABI changes incompatibly

02:31:38,863 --> 02:31:40,979
which it does every few releases

02:31:40,979 --> 02:31:42,871
you have to go screaming back to the people

02:31:42,871 --> 02:31:44,799
who would give me the patches

02:31:44,799 --> 02:31:46,754
and I didn't know how long you'd have to wait for them

02:31:46,754 --> 02:31:48,633
for them to come up with fixes.

02:31:48,633 --> 02:31:50,010
- I mean, if it's all in the RHEL tree

02:31:50,010 --> 02:31:52,740
all the magic modules the Nvidia crap,

02:31:52,740 --> 02:31:55,823
the file system monkeys from Forever.

02:31:57,404 --> 02:32:01,514
There isn't okay ABI you just build new version of them.

02:32:01,514 --> 02:32:02,822
Life will be so much easier.

02:32:02,822 --> 02:32:04,235
- Oh, I know.

02:32:04,235 --> 02:32:05,494
But as long as we have a kABI checker,

02:32:05,494 --> 02:32:08,215
I'd like to make it faster use.

02:32:08,215 --> 02:32:09,583
And not so horrifying.

02:32:09,583 --> 02:32:10,416
Because I mean,

02:32:10,416 --> 02:32:12,025
one advantage of this is not just a format,

02:32:12,025 --> 02:32:12,858
it's a library.

02:32:12,858 --> 02:32:14,891
So you can just, walk around these things

02:32:14,891 --> 02:32:16,617
with a couple of function calls.

02:32:16,617 --> 02:32:17,450
And again,

02:32:17,450 --> 02:32:18,972
I'll certainly if we do get a kernel version,

02:32:18,972 --> 02:32:20,889
I'll keep the same API.

02:32:22,554 --> 02:32:24,843
It's definitely and ideally,

02:32:24,843 --> 02:32:25,938
of course, anyone with binutils

02:32:25,938 --> 02:32:27,789
would have access to this library

02:32:27,789 --> 02:32:29,229
once this all gets into

02:32:29,229 --> 02:32:31,174
once this all landed is released.

02:32:31,174 --> 02:32:33,571
The next released binutils will have the library

02:32:33,571 --> 02:32:34,817
but not the linker side

02:32:34,817 --> 02:32:37,817
because that's still being reviewed.

02:32:38,716 --> 02:32:41,896
So I've got some more idea a linked in LWN article

02:32:41,896 --> 02:32:43,789
in which I completely monopolize the comment thread

02:32:43,789 --> 02:32:46,122
with my API ideas and so on.

02:32:47,553 --> 02:32:48,643
Anyone who hasn't already read it,

02:32:48,643 --> 02:32:52,182
and probably everyone in this room reads LWN in any way.

02:32:52,182 --> 02:32:54,265
There's more stuff there.

02:32:55,833 --> 02:32:58,583
And I think we know at questions.

02:33:00,196 --> 02:33:04,127
I wish I knew how to stop it doing this.

02:33:04,127 --> 02:33:05,886
Let's go back to the end.

02:33:05,886 --> 02:33:08,250
Does anyone have any more things I could use this for

02:33:08,250 --> 02:33:10,288
any more improvements?

02:33:10,288 --> 02:33:11,341
- So I'm gonna want to use this because

02:33:11,341 --> 02:33:12,948
I've looking for something like this the whole time.

02:33:12,948 --> 02:33:15,135
- Yes users, excellent.

02:33:15,135 --> 02:33:17,485
- So I'm gonna use this to generate Python bindings

02:33:17,485 --> 02:33:19,273
so that we don't have to write Python bindings

02:33:19,273 --> 02:33:20,827
in C ever again, right?

02:33:20,827 --> 02:33:22,953
So write a pure Python,

02:33:22,953 --> 02:33:26,055
or write a Python module that then loads these

02:33:26,055 --> 02:33:28,281
and generates bindings dynamically

02:33:28,281 --> 02:33:29,882
as you try to use something

02:33:29,882 --> 02:33:33,096
and then write Python bindings for doing things Pythonic

02:33:33,096 --> 02:33:34,358
in pure Python.

02:33:34,358 --> 02:33:36,643
So you never have (mumbles) problems at all,

02:33:36,643 --> 02:33:39,841
because these are just Python objects.

02:33:39,841 --> 02:33:41,242
So that's really, really gonna help.

02:33:41,242 --> 02:33:43,060
So I don't have a question,

02:33:43,060 --> 02:33:44,231
just saying I think

02:33:44,231 --> 02:33:47,066
we probably find some things we're not expecting.

02:33:47,066 --> 02:33:49,038
- One of the first questions I got when this hit binutils

02:33:49,038 --> 02:33:50,706
is will it support C++,

02:33:50,706 --> 02:33:54,206
and I have no theoretic there is no format be related reason

02:33:54,206 --> 02:33:56,572
why we can't have a CTF variant which looks the same.

02:33:56,572 --> 02:34:00,658
So all users with extra API obviously which supports C++,

02:34:00,658 --> 02:34:04,146
it's just it will make my mind melt.

02:34:04,146 --> 02:34:05,252
That I saw some of the revisions

02:34:05,252 --> 02:34:08,222
to allow it to do sort of large scale

02:34:08,222 --> 02:34:11,211
reading inviting of different formats will also help with

02:34:11,211 --> 02:34:13,852
completely different languages like this.

02:34:13,852 --> 02:34:15,711
I've had people say,

02:34:15,711 --> 02:34:16,544
where's the spec?

02:34:16,544 --> 02:34:17,896
I wrote it on Friday.

02:34:17,896 --> 02:34:19,159
Where's the spec?

02:34:19,159 --> 02:34:20,793
I wanted to write a Rust version of this,

02:34:20,793 --> 02:34:21,982
that sort of thing.

02:34:21,982 --> 02:34:25,063
So the more the merrier as far as I'm concerned.

02:34:25,063 --> 02:34:26,752
The advantage is one of the reasons why

02:34:26,752 --> 02:34:29,578
I've got this format re-write all the old versions thing

02:34:29,578 --> 02:34:32,199
is simply that this means that other users

02:34:32,199 --> 02:34:34,971
including other format interpreters aren't required

02:34:34,971 --> 02:34:36,714
who can't keep up with everything I'm doing.

02:34:36,714 --> 02:34:37,876
They can just feed it to me

02:34:37,876 --> 02:34:40,478
and say can back the latest version or vice versa?

02:34:40,478 --> 02:34:41,688
I haven't yet figured out what happens

02:34:41,688 --> 02:34:44,420
if someone someone takes

02:34:44,420 --> 02:34:46,201
some CTF with 10 million types

02:34:46,201 --> 02:34:47,868
and says give me BTF

02:34:48,773 --> 02:34:52,338
or if someone takes some CTF with an eneum, bit fields

02:34:52,338 --> 02:34:53,704
and says give me BTF.

02:34:53,704 --> 02:34:55,221
I think in the eneum, bit field case,

02:34:55,221 --> 02:34:56,269
we just dropped that one type

02:34:56,269 --> 02:34:57,861
but if there were just too many types

02:34:57,861 --> 02:34:59,826
we'd have to say we can't convert this.

02:34:59,826 --> 02:35:01,492
- [Audience] Then issue a warning.

02:35:01,492 --> 02:35:02,706
- Well it would be an error code

02:35:02,706 --> 02:35:04,343
from the it's not a...

02:35:04,343 --> 02:35:05,646
These are all library API.

02:35:05,646 --> 02:35:06,930
So you really when you get an error code back

02:35:06,930 --> 02:35:09,974
it's just this is just too big.

02:35:09,974 --> 02:35:11,092
A possible future enhancement

02:35:11,092 --> 02:35:12,975
might be ways to split these things up in that case,

02:35:12,975 --> 02:35:15,599
but I'm not gonna write this (laughs)

02:35:15,599 --> 02:35:18,045
because splitting type containers up is very hard

02:35:18,045 --> 02:35:20,564
because all the type can link to each other.

02:35:20,564 --> 02:35:22,137
You can easily end up with 10 times as many types

02:35:22,137 --> 02:35:23,965
and you still haven't shrunk the size of each

02:35:23,965 --> 02:35:25,965
any by any great degree.

02:35:28,944 --> 02:35:30,917
Oh, and so speed wise by the way,

02:35:30,917 --> 02:35:31,807
I thought people might want to know

02:35:31,807 --> 02:35:33,710
how fast deduplicators is can be.

02:35:33,710 --> 02:35:36,381
The old DWARF to CTF deduplicator I wrote

02:35:36,381 --> 02:35:39,372
it started out taking about one and a half minutes

02:35:39,372 --> 02:35:41,380
after the recent speed up to libctf

02:35:41,380 --> 02:35:42,881
it now takes about 40 seconds

02:35:42,881 --> 02:35:45,220
and most of that is the overhead of reading

02:35:45,220 --> 02:35:46,971
all that too often.

02:35:46,971 --> 02:35:48,221
So I would hope

02:35:49,942 --> 02:35:51,460
I've got a kernel,

02:35:51,460 --> 02:35:55,585
I tried CTF generation with a non deduplicating linker,

02:35:55,585 --> 02:35:59,015
and it spits out 55 million type horrifying CTF file

02:35:59,015 --> 02:36:01,515
which is about 70 meg in size.

02:36:02,534 --> 02:36:04,564
The fact that it only takes a few minutes

02:36:04,564 --> 02:36:07,458
just to do something on that scale

02:36:07,458 --> 02:36:09,909
suggests that there's no fundamental speed problems

02:36:09,909 --> 02:36:11,491
in this library anymore.

02:36:11,491 --> 02:36:13,275
I don't know how fast the deduplicator is

02:36:13,275 --> 02:36:15,293
but as of last month,

02:36:15,293 --> 02:36:17,671
LD and GDB and all the rest of the stuff in the binutils

02:36:17,671 --> 02:36:19,816
could in theory use threads.

02:36:19,816 --> 02:36:21,899
So I'm probably going to make it multi-threaded,

02:36:21,899 --> 02:36:25,952
if need be to pull in CTF from multiple translation units

02:36:25,952 --> 02:36:29,051
at the same time or something like that.

02:36:29,051 --> 02:36:30,941
In the future.

02:36:30,941 --> 02:36:33,128
- And to actually related to that,

02:36:33,128 --> 02:36:35,961
in GNU we very recently introduced

02:36:36,873 --> 02:36:39,040
RP treads module in Gnulib

02:36:39,978 --> 02:36:44,178
written by Bruno Haible who is a monster.

02:36:44,178 --> 02:36:46,892
(audience laughing)

02:36:46,892 --> 02:36:49,555
And we are starting in GNU in general

02:36:49,555 --> 02:36:51,818
because this basically is giving us the ability

02:36:51,818 --> 02:36:56,723
to parallelize our programs in a way that in a portable way.

02:36:56,723 --> 02:36:59,521
And as everything that Bruno does,

02:36:59,521 --> 02:37:01,025
it's extremely portable.

02:37:01,025 --> 02:37:03,844
So that means windows being DB whatever.

02:37:03,844 --> 02:37:06,863
I'm probably gold and even LD may be,

02:37:06,863 --> 02:37:08,831
but there is BFD there to deal with

02:37:08,831 --> 02:37:12,664
but we are going to start to parallelize more.

02:37:13,730 --> 02:37:14,708
- Suffice to say that

02:37:14,708 --> 02:37:16,895
I noted to when I started working for database companies,

02:37:16,895 --> 02:37:18,519
they stopped working on databases.

02:37:18,519 --> 02:37:20,173
When I started contributing to GNU,

02:37:20,173 --> 02:37:21,345
I started having to use Windows

02:37:21,345 --> 02:37:23,586
because I was having to put compile stuff on MinGW

02:37:23,586 --> 02:37:26,408
to make sure it worked there (laughs).

02:37:26,408 --> 02:37:31,043
Bruno is a monster of portability (laughs).

02:37:31,043 --> 02:37:33,731
So, yes if people have more ideas,

02:37:33,731 --> 02:37:34,947
they are just the binutils list

02:37:34,947 --> 02:37:37,088
is where all this stuff is getting done.

02:37:37,088 --> 02:37:38,670
So if people have more ideas,

02:37:38,670 --> 02:37:40,897
do please come into the binutils list and offer suggestions,

02:37:40,897 --> 02:37:45,147
I will be generally happy to implement any of them.

02:37:46,475 --> 02:37:48,892
I hope this is of general use

02:37:49,988 --> 02:37:51,104
hell in the future in the distant future.

02:37:51,104 --> 02:37:52,933
I hope Clang learns to do this as well.

02:37:52,933 --> 02:37:54,363
It's just their licensing problems

02:37:54,363 --> 02:37:56,180
so I'm not even thinking about it at the moment.

02:37:56,180 --> 02:37:59,583
- What licensing problems are there?

02:37:59,583 --> 02:38:03,194
- The licensing history of libctf is interesting.

02:38:03,194 --> 02:38:04,809
It started out weird proprietary,

02:38:04,809 --> 02:38:06,879
it turned to CDDL,

02:38:06,879 --> 02:38:10,962
from that it turned into a union of UPL and GPLv2

02:38:12,136 --> 02:38:15,759
because we're using it to the kernel side as well

02:38:15,759 --> 02:38:17,235
in the build tools.

02:38:17,235 --> 02:38:18,707
It once it moved into binutils

02:38:18,707 --> 02:38:20,214
it became GPLv3 class

02:38:20,214 --> 02:38:21,922
along with everything else in binutils.

02:38:21,922 --> 02:38:23,578
But I can say that I'm almost certain

02:38:23,578 --> 02:38:24,918
that we could turn it we could turn it

02:38:24,918 --> 02:38:29,085
probably into LGPLv2 plus super kernel could use it

02:38:29,085 --> 02:38:30,239
and so on and so forth.

02:38:30,239 --> 02:38:33,421
I'm fully sure that team is turning it into BSD license

02:38:33,421 --> 02:38:34,486
some could use it in Clang

02:38:34,486 --> 02:38:36,634
will cause something that will cause people to scream.

02:38:36,634 --> 02:38:37,909
I don't know.

02:38:37,909 --> 02:38:39,209
I'm not saying one way or the other

02:38:39,209 --> 02:38:40,302
and I'm not going near this

02:38:40,302 --> 02:38:41,251
because people will bite their head off

02:38:41,251 --> 02:38:43,834
almost no matter what they say.

02:38:44,776 --> 02:38:46,151
I have the gestures.

02:38:46,151 --> 02:38:48,741
So I do not know that all I know is the licenses

02:38:48,741 --> 02:38:50,867
is changed in the past it may change in the future.

02:38:50,867 --> 02:38:52,639
I would like everyone to be able to use it

02:38:52,639 --> 02:38:57,639
but copyright law tries to stop that from happening.

02:38:57,732 --> 02:39:00,332
I don't like a duplication but at least we now have a spec.

02:39:00,332 --> 02:39:04,165
So if people do need to duplicate it they can.

02:39:05,665 --> 02:39:09,225
I will add to the spec in future to provide differences

02:39:09,225 --> 02:39:12,344
between the current CTF and all the older versions,

02:39:12,344 --> 02:39:13,686
so that you can easily tell,

02:39:13,686 --> 02:39:17,996
sort of what on earth is difference between CTFv2 and CTFv3.

02:39:17,996 --> 02:39:19,269
A CTFv4 will be coming.

02:39:19,269 --> 02:39:20,379
And then I'll change the v3

02:39:20,379 --> 02:39:22,630
to say what's different from that.

02:39:22,630 --> 02:39:24,378
I'm probably also going to add something that says

02:39:24,378 --> 02:39:26,933
what's different between BTF and CTF V whatever.

02:39:26,933 --> 02:39:30,578
Just, as they're all documented in one place.

02:39:30,578 --> 02:39:35,578
I'm sick of researching this in dozens of source trees.

02:39:35,757 --> 02:39:37,271
But that's all going to come in the next few weeks,

02:39:37,271 --> 02:39:41,587
probably finishing the documentation is very important.

02:39:41,587 --> 02:39:42,837
And the linker.

02:39:43,802 --> 02:39:45,972
Anyway that's it I think.

02:39:45,972 --> 02:39:49,560
(audience clapping)

02:39:49,560 --> 02:39:53,070
Oh my God I blew my time by miles, I'm sorry (laughs).

02:39:53,070 --> 02:39:56,570
- No because this is important this stuff.

02:39:57,653 --> 02:40:00,570
(speaker laughing)

02:40:04,280 --> 02:40:08,652
I'm gonna need the cable the VGA to HDMI convertor.

02:40:08,652 --> 02:40:10,569
- And I have my screen.

02:41:17,434 --> 02:41:18,634
- This works?

02:41:18,634 --> 02:41:19,918
No.

02:41:19,918 --> 02:41:20,977
Here we go.

02:41:20,977 --> 02:41:22,144
Is it working?

02:41:23,840 --> 02:41:26,090
Well he said that they did.

02:41:28,378 --> 02:41:29,211
Now?

02:41:32,816 --> 02:41:36,983
Okay, we have 20 minutes so this is gonna be fast.

02:41:38,746 --> 02:41:42,013
So this is about the eBPF support in the GNU tool chain.

02:41:42,013 --> 02:41:43,072
Basically you can use,

02:41:43,072 --> 02:41:47,655
GCC binutils and whatnot to generate your BPF programs.

02:41:48,514 --> 02:41:51,347
So first I am not a tracing person

02:41:53,464 --> 02:41:54,375
All right.

02:41:54,375 --> 02:41:58,652
I think that I should mention this because

02:41:58,652 --> 02:42:00,480
I am just the compiler guy

02:42:00,480 --> 02:42:02,842
Basically, you give me some C source code

02:42:02,842 --> 02:42:07,085
and then I give you some, hopefully very well compiled,

02:42:07,085 --> 02:42:08,085
BPF program.

02:42:10,169 --> 02:42:12,669
So BPF trays tracing this that

02:42:13,823 --> 02:42:15,344
I actually don't care about it that much.

02:42:15,344 --> 02:42:18,164
I mean, I care about it because it's the main,

02:42:18,164 --> 02:42:20,205
maybe the main consumers of this,

02:42:20,205 --> 02:42:23,639
but I actually don't know that much about it.

02:42:23,639 --> 02:42:28,222
So the project itself that we started a few months ago,

02:42:29,289 --> 02:42:32,411
basically the first phase which is done,

02:42:32,411 --> 02:42:35,931
it was to add the eBPF support to the tool chain itself.

02:42:35,931 --> 02:42:38,866
So we introduced a new GNU triplet,

02:42:38,866 --> 02:42:41,533
which is this eBPF unknown none.

02:42:43,527 --> 02:42:47,614
In BFD (mumbles) in binutils and whatnot.

02:42:47,614 --> 02:42:50,369
Then we made the first part of binutils,

02:42:50,369 --> 02:42:52,664
meaning support in the assembler of codes,

02:42:52,664 --> 02:42:53,831
this assembler

02:42:55,734 --> 02:42:58,433
and this was upstream already in May 2019.

02:42:58,433 --> 02:43:00,985
Of course back in those first versions,

02:43:00,985 --> 02:43:02,764
they contain a lot of errors.

02:43:02,764 --> 02:43:04,944
So, we had to do some amendments there,

02:43:04,944 --> 02:43:07,104
we haven't done yet with that.

02:43:07,104 --> 02:43:09,937
And then yesterday the GCC support

02:43:11,074 --> 02:43:12,271
got accepted a stream

02:43:12,271 --> 02:43:15,272
and I did a commit yesterday just in time,

02:43:15,272 --> 02:43:16,105
but...

02:43:17,466 --> 02:43:19,799
So, the first phase is done.

02:43:20,746 --> 02:43:25,238
The second phase is to make the eBPF programs

02:43:25,238 --> 02:43:29,321
that GCC compiles suitable to be basically loaded

02:43:30,669 --> 02:43:33,169
and executed in by the kernel.

02:43:34,050 --> 02:43:36,522
Because one thing is to generate the eBPF programs

02:43:36,522 --> 02:43:37,994
in another file something completely different

02:43:37,994 --> 02:43:40,818
is for those programs to be palatable,

02:43:40,818 --> 02:43:42,370
to the kernel itself.

02:43:42,370 --> 02:43:45,172
We shall see now that there are two aspects of this.

02:43:45,172 --> 02:43:47,881
First you have a sort of ABI,

02:43:47,881 --> 02:43:50,080
a sort of application binary interface

02:43:50,080 --> 02:43:54,059
which is actually enforced by the kernel loaders,

02:43:54,059 --> 02:43:56,593
which are the kernel components that basically get

02:43:56,593 --> 02:43:58,600
the L file that you provide with a program

02:43:58,600 --> 02:44:01,504
and load it into the kernel doing

02:44:01,504 --> 02:44:04,243
translating them into some syscalls or whatever.

02:44:04,243 --> 02:44:06,597
And then there is the kernel verifier,

02:44:06,597 --> 02:44:09,114
which basically determines what eBPF program

02:44:09,114 --> 02:44:11,570
can be running the kernel in a safe way or not.

02:44:11,570 --> 02:44:13,005
If it is not,

02:44:13,005 --> 02:44:14,922
then it will not run it

02:44:16,661 --> 02:44:18,538
that face is starting now,

02:44:18,538 --> 02:44:23,093
and it is a continuous obviously a continuous activity.

02:44:23,093 --> 02:44:25,938
Alright, because the kernel verifier changes,

02:44:25,938 --> 02:44:28,956
it becomes more sophisticated with time,

02:44:28,956 --> 02:44:30,717
which basically translates into lifting

02:44:30,717 --> 02:44:33,812
some of the restrictions in BPF programs

02:44:33,812 --> 02:44:38,812
and then of course, we need to keep the compiler up to date.

02:44:40,454 --> 02:44:41,991
Then the phase number three,

02:44:41,991 --> 02:44:44,885
which is actually in parallel with the face number two

02:44:44,885 --> 02:44:47,837
is to also add additional components

02:44:47,837 --> 02:44:49,821
for the eBPF developers,

02:44:49,821 --> 02:44:51,097
because having an assembler

02:44:51,097 --> 02:44:54,468
and a compiler obviously this is very useful,

02:44:54,468 --> 02:44:56,937
but especially in targets like this,

02:44:56,937 --> 02:44:58,605
which is not that much different

02:44:58,605 --> 02:45:01,778
to an embedded target for example

02:45:01,778 --> 02:45:06,778
the developers for that platform they will benefit very much

02:45:08,528 --> 02:45:10,344
from things like a simulator,

02:45:10,344 --> 02:45:12,798
I will talk more about the simulator we are working on

02:45:12,798 --> 02:45:15,485
which includes emulating some of the kernel contexts.

02:45:15,485 --> 02:45:18,235
You know that the eBPF program C.

02:45:20,730 --> 02:45:22,397
So, the port itself.

02:45:23,479 --> 02:45:26,776
Okay eBPF is very peculiar, alright

02:45:26,776 --> 02:45:29,264
especially for someone like me who comes you know from

02:45:29,264 --> 02:45:32,349
working on this backend for example of the compiler

02:45:32,349 --> 02:45:35,435
eBPF is something completely different.

02:45:35,435 --> 02:45:37,465
At first sight it looks like

02:45:37,465 --> 02:45:41,415
a pretty much harmless little cute architecture

02:45:41,415 --> 02:45:42,781
with I don't know,

02:45:42,781 --> 02:45:45,931
11 64 bit registers, better uniform

02:45:45,931 --> 02:45:48,623
and coding for instructions.

02:45:48,623 --> 02:45:51,527
Arithmetic instruction flow your curl branches.

02:45:51,527 --> 02:45:53,921
It looks pretty harmless and nice,

02:45:53,921 --> 02:45:55,496
but trust me it's not

02:45:55,496 --> 02:46:00,084
because there are some characteristics of the instruction

02:46:00,084 --> 02:46:03,035
sets that, there are some omissions there which come from,

02:46:03,035 --> 02:46:05,520
I don't know, probably security concerns

02:46:05,520 --> 02:46:07,320
or the way the instructions

02:46:07,320 --> 02:46:08,598
that has been disseminated

02:46:08,598 --> 02:46:09,598
and evolved.

02:46:10,644 --> 02:46:13,811
That makes compiling eBPF challenging.

02:46:17,148 --> 02:46:18,070
Other than that,

02:46:18,070 --> 02:46:19,710
I'm not gonna get into detail here.

02:46:19,710 --> 02:46:24,034
I'm gonna do a big talk in the cauldron later in this week

02:46:24,034 --> 02:46:27,163
and I have a lot of slides for that about the fun

02:46:27,163 --> 02:46:30,265
and you now the fun and interesting how compelling eBPF

02:46:30,265 --> 02:46:33,173
can make your life much more interesting and fun.

02:46:33,173 --> 02:46:35,497
But, so if you are curious about it,

02:46:35,497 --> 02:46:37,088
I forward you to the slides

02:46:37,088 --> 02:46:39,733
that will be published or the video or whatever.

02:46:39,733 --> 02:46:41,366
Anyway, other than that,

02:46:41,366 --> 02:46:44,866
well, some of the characteristics are that

02:46:45,865 --> 02:46:48,405
first kernel helpers.

02:46:48,405 --> 02:46:52,105
I decided to implement them as compiler built-ins.

02:46:52,105 --> 02:46:55,492
This is a slightly different that to what LLVM does

02:46:55,492 --> 02:46:59,992
LLVM provides you with a header file bpf header dot h,

02:47:00,856 --> 02:47:05,669
and basically it relies on some specific behavior

02:47:05,669 --> 02:47:08,591
of LLVM when you build with (mumbles),

02:47:08,591 --> 02:47:10,060
in a way that you at the end,

02:47:10,060 --> 02:47:11,471
you get the instruction that you need

02:47:11,471 --> 02:47:13,183
to call up the kernel helper.

02:47:13,183 --> 02:47:15,120
Okay, I think that is very fragile.

02:47:15,120 --> 02:47:19,120
So I prefer to other explicit compiler built-ins

02:47:22,097 --> 02:47:23,262
that will generate always.

02:47:23,262 --> 02:47:25,992
It doesn't matter what optimization level you use,

02:47:25,992 --> 02:47:28,243
it will generate the right instruction for you.

02:47:28,243 --> 02:47:30,306
This is much more robust in my opinion.

02:47:30,306 --> 02:47:32,278
Of course, it comes as the cost,

02:47:32,278 --> 02:47:36,583
that you have to do to maintain an explicit list of helpers.

02:47:36,583 --> 02:47:37,663
But then again,

02:47:37,663 --> 02:47:40,482
if you look at this option here,

02:47:40,482 --> 02:47:43,552
we also took the pains of adding to the compiler.

02:47:43,552 --> 02:47:45,492
I might know some kernel option,

02:47:45,492 --> 02:47:47,706
which is similar to the main awesome CPU option

02:47:47,706 --> 02:47:51,270
that you find in more conventional targets.

02:47:51,270 --> 02:47:56,270
And basically, you can specify the version of the kernel

02:47:56,289 --> 02:47:59,628
where you intend to run your bpf program.

02:47:59,628 --> 02:48:02,357
And then for then for example GCC will tell you

02:48:02,357 --> 02:48:04,972
if you are trying to use a helper function

02:48:04,972 --> 02:48:08,555
that does not exist in that kernel version.

02:48:12,725 --> 02:48:14,704
- So this mkernel version thing

02:48:14,704 --> 02:48:16,837
will that then also grow to include

02:48:16,837 --> 02:48:18,562
all the enterprise kernel versions

02:48:18,562 --> 02:48:20,613
that have run them back ports

02:48:20,613 --> 02:48:22,239
and God knows what?

02:48:22,239 --> 02:48:23,697
- I have no idea.

02:48:23,697 --> 02:48:25,004
Maybe, yeah.

02:48:25,004 --> 02:48:27,064
- [Audience] Awesome. - Is that necessary?

02:48:27,064 --> 02:48:30,897
- Yeah how this works in the world you have...

02:48:35,009 --> 02:48:37,999
How it actually work because in enterprises

02:48:37,999 --> 02:48:39,097
kernel (mumbles).

02:48:39,097 --> 02:48:41,125
We have a lot of things back ported

02:48:41,125 --> 02:48:42,598
from newer kernel versions.

02:48:42,598 --> 02:48:43,848
So we have 4.18

02:48:45,197 --> 02:48:47,947
with the BPF at five dot O level.

02:48:50,205 --> 02:48:51,038
So how does this work?

02:48:51,038 --> 02:48:53,418
- Okay, well for this first implementation

02:48:53,418 --> 02:48:57,015
I basically I'm using mainline release numbers.

02:48:57,015 --> 02:48:59,077
Now you are telling me that (mumbles) enroll for example,

02:48:59,077 --> 02:49:00,503
you have back ports

02:49:00,503 --> 02:49:01,943
So this is not enough.

02:49:01,943 --> 02:49:04,534
So then we should come with a solution for that.

02:49:04,534 --> 02:49:05,367
- Yeah,

02:49:05,367 --> 02:49:08,515
it's basically the old problem not relying on versions,

02:49:08,515 --> 02:49:10,503
but on features present.

02:49:10,503 --> 02:49:13,194
- We could support both.

02:49:13,194 --> 02:49:16,124
I mean or if lane features makes these obsolete

02:49:16,124 --> 02:49:19,514
or not that useful we can remove this no problem.

02:49:19,514 --> 02:49:20,559
What would you do?

02:49:20,559 --> 02:49:24,628
Would you group the helpers for example in functionality?

02:49:24,628 --> 02:49:25,461
Or

02:49:27,466 --> 02:49:28,757
I mean, there is another option.

02:49:28,757 --> 02:49:29,590
- [Audience] I don't know.

02:49:29,590 --> 02:49:31,733
- If you always use kernel latest

02:49:31,733 --> 02:49:32,993
it will get any helper.

02:49:32,993 --> 02:49:37,626
- Honestly, I think that hard coding bp wrappers into GCC

02:49:37,626 --> 02:49:39,987
is not not a good solution.

02:49:39,987 --> 02:49:41,854
- [Audience] Because the back port issues

02:49:41,854 --> 02:49:42,903
is not really practical.

02:49:42,903 --> 02:49:46,483
- Okay so you think that supporting this option is not--

02:49:46,483 --> 02:49:48,533
- [Audience] Not practical. - Is not practical.

02:49:48,533 --> 02:49:51,873
- Because 4.0 people could use the latest features.

02:49:51,873 --> 02:49:53,093
So sometime you have a later

02:49:53,093 --> 02:49:56,327
whether you may do not have old helpers.

02:49:56,327 --> 02:49:58,232
So all this could mix up.

02:49:58,232 --> 02:50:02,565
- My suggestion would be that is to move that header

02:50:03,714 --> 02:50:07,711
into the you UAPI headers in the kernel

02:50:07,711 --> 02:50:09,538
and pick it up from there

02:50:09,538 --> 02:50:10,788
and specify the

02:50:13,542 --> 02:50:17,162
and that way, if you need additional information

02:50:17,162 --> 02:50:19,336
about what's available in the kernel,

02:50:19,336 --> 02:50:20,336
you can also

02:50:23,938 --> 02:50:27,938
we could also add pragmas to that header file or

02:50:30,248 --> 02:50:31,904
whatever you would prefer.

02:50:31,904 --> 02:50:35,613
This is orthogonal to the header file.

02:50:35,613 --> 02:50:37,464
I mean, this is about

02:50:37,464 --> 02:50:40,495
because I know that in the LLVM port

02:50:40,495 --> 02:50:42,451
it is the BPF helpers header file

02:50:42,451 --> 02:50:45,283
that they basically determine which kernel helpers

02:50:45,283 --> 02:50:46,826
are available or not.

02:50:46,826 --> 02:50:51,281
But in GCC, it is the existing compiler built-ins.

02:50:51,281 --> 02:50:52,844
- [Audience] Right. - Are available or not.

02:50:52,844 --> 02:50:55,594
- But what I'm saying is you can,

02:50:56,726 --> 02:51:00,893
you could get that information instead of mkernel,

02:51:02,324 --> 02:51:06,324
you could do that from a pragma ina header file.

02:51:07,891 --> 02:51:08,831
- Okay, yeah.

02:51:08,831 --> 02:51:10,338
- And that way it will

02:51:10,338 --> 02:51:14,338
in that way that pragma can be adjusted to match

02:51:15,359 --> 02:51:17,859
whatever district kernel does.

02:51:19,151 --> 02:51:23,668
It would be not really the version of the kernel,

02:51:23,668 --> 02:51:26,085
it will be the version of BPF

02:51:27,355 --> 02:51:28,902
that kernel supports.

02:51:28,902 --> 02:51:31,952
- Well, that I was trying to

02:51:31,952 --> 02:51:34,939
I mean, it's not always possible to do it

02:51:34,939 --> 02:51:37,866
but as from the perspective of the compiler,

02:51:37,866 --> 02:51:39,768
I always try to abstract the fact that

02:51:39,768 --> 02:51:41,809
the bpf program is going to be running a kernel,

02:51:41,809 --> 02:51:43,450
for example.

02:51:43,450 --> 02:51:45,158
- [Audience] Right, but-- - So yeah.

02:51:45,158 --> 02:51:47,075
- But whatever options,

02:51:50,746 --> 02:51:55,316
we can encode that information in a kernel header file,

02:51:55,316 --> 02:51:58,746
and give it to you in whatever format you want,

02:51:58,746 --> 02:52:01,163
which I'm assuming is pragmas

02:52:02,466 --> 02:52:05,096
and that is a much better solution

02:52:05,096 --> 02:52:08,328
than really putting it on the command line.

02:52:08,328 --> 02:52:09,161
- Okay.

02:52:11,590 --> 02:52:12,743
- There's really one here.

02:52:12,743 --> 02:52:14,743
And another alternative,

02:52:15,756 --> 02:52:18,090
given that the set,

02:52:18,090 --> 02:52:20,140
it seems like the set of back ports could be variable

02:52:20,140 --> 02:52:21,370
on a per district basis

02:52:21,370 --> 02:52:25,155
and you can't turn that into a linear BPF version,

02:52:25,155 --> 02:52:27,488
ascending BTF version number

02:52:28,462 --> 02:52:31,817
is to say that all of these versions correspond

02:52:31,817 --> 02:52:35,106
to a file which is a mapping somewhere under user libgcc,

02:52:35,106 --> 02:52:37,277
BPF or something.

02:52:37,277 --> 02:52:39,818
And the district kernels can simply ship one of these files

02:52:39,818 --> 02:52:41,876
and then all of a sudden four point naught dash rail

02:52:41,876 --> 02:52:43,497
would work and it would pick up

02:52:43,497 --> 02:52:45,801
the appropriate mappings from there.

02:52:45,801 --> 02:52:47,158
And then you don't need to ship anything

02:52:47,158 --> 02:52:49,676
and it also means that new kernels could be easily supported

02:52:49,676 --> 02:52:50,991
by shipping one extra file

02:52:50,991 --> 02:52:54,241
without having to ship a whole new GCC.

02:52:55,161 --> 02:52:57,879
- Okay well we should discuss about it.

02:52:57,879 --> 02:52:58,712
Yes.

02:52:58,712 --> 02:53:02,652
- [Audience] Basically what I said I believe it should be

02:53:02,652 --> 02:53:03,485
in the kernel API header in it's directory.

02:53:03,485 --> 02:53:07,318
- Which basically brings me to the next point,

02:53:10,286 --> 02:53:13,247
which is the BPF helpers header file.

02:53:13,247 --> 02:53:14,974
Now, at the moment,

02:53:14,974 --> 02:53:18,359
currently the kernel is provided in a BPF underscore

02:53:18,359 --> 02:53:22,108
helpers dot h file which is in the kernel tree,

02:53:22,108 --> 02:53:26,033
which for several reasons is LVM specific.

02:53:26,033 --> 02:53:28,393
Which makes full sense because up to now,

02:53:28,393 --> 02:53:31,280
I mean LLVM was sort of a requirement to do this.

02:53:31,280 --> 02:53:32,113
Yes.

02:53:32,113 --> 02:53:35,149
- I disagree with that. - [Jose] With what?

02:53:35,149 --> 02:53:37,374
- I mean LLVM specific.

02:53:37,374 --> 02:53:41,411
Basically the existing code has to be compiled with GCC.

02:53:41,411 --> 02:53:43,935
So you cannot force users to abandon--

02:53:43,935 --> 02:53:47,954
- A bpf underscore helpers is LVMS specific.

02:53:47,954 --> 02:53:49,363
- You can have another one

02:53:49,363 --> 02:53:52,327
but I think the kernel community will not like it.

02:53:52,327 --> 02:53:54,265
- No well what they think it will happen

02:53:54,265 --> 02:53:58,441
is to change it, so it also works with GCC,

02:53:58,441 --> 02:54:01,281
I mean, the first thing that it has that it's LLVM specific

02:54:01,281 --> 02:54:05,897
is that it includes architectural dependent kernel headers.

02:54:05,897 --> 02:54:08,564
And that will not work with GCC.

02:54:10,685 --> 02:54:13,820
- Another thing I think and you should just completely

02:54:13,820 --> 02:54:15,802
get rid off the kernels at all

02:54:15,802 --> 02:54:18,704
and the whatever compiler generated the code

02:54:18,704 --> 02:54:21,846
it should generally run all kernels

02:54:21,846 --> 02:54:23,931
and it shouldn't really compare.

02:54:23,931 --> 02:54:26,879
And whether a particular helper available or not

02:54:26,879 --> 02:54:29,257
that's application developers job

02:54:29,257 --> 02:54:31,282
is not really compilers job.

02:54:31,282 --> 02:54:36,282
And maybe some options and we can have like a CPU generation

02:54:36,454 --> 02:54:37,912
version one, version two

02:54:37,912 --> 02:54:42,133
or some architecture and features it could be added,

02:54:42,133 --> 02:54:45,532
but we shouldn't really care about kernel at all.

02:54:45,532 --> 02:54:47,282
- I disagree with that. - [Audience] Yeah.

02:54:47,282 --> 02:54:49,723
- I mean, because I try to apply exactly the same concepts

02:54:49,723 --> 02:54:52,690
and approach but we use in other architectures.

02:54:52,690 --> 02:54:55,503
- Another thing about your compiler built-in,

02:54:55,503 --> 02:54:57,684
I think is also a bad idea.

02:54:57,684 --> 02:55:02,358
The reason is, is that basically means you compiler,

02:55:02,358 --> 02:55:04,964
the GCC is tied to a kernel version.

02:55:04,964 --> 02:55:06,081
That's bad.

02:55:06,081 --> 02:55:10,908
That means new kernel versus old GCC won't work.

02:55:10,908 --> 02:55:12,641
- How is that different to the compiler

02:55:12,641 --> 02:55:16,199
being tied to some specific backdoor extension

02:55:16,199 --> 02:55:18,388
on an instruction existing in architecture?

02:55:18,388 --> 02:55:21,405
- Yeah, some people just have older GCC--

02:55:21,405 --> 02:55:24,210
- [Jose] Yeah, but what is the difference?

02:55:24,210 --> 02:55:26,702
Can you please explain to me the difference?

02:55:26,702 --> 02:55:31,353
The difference is the GCC if you have this building,

02:55:31,353 --> 02:55:33,271
and it is an older building,

02:55:33,271 --> 02:55:36,261
and there suddenly you get a new kernel,

02:55:36,261 --> 02:55:40,754
and it won't be able to issue helpers for the new one.

02:55:40,754 --> 02:55:43,903
Because the new kernel always has new helpers, right?

02:55:43,903 --> 02:55:46,745
- Well, actually, you can.

02:55:46,745 --> 02:55:49,027
- You can generate a call constant

02:55:49,027 --> 02:55:52,396
with each what you do with in BPF underscore helpers.

02:55:52,396 --> 02:55:54,387
- No I mean helpers, new helpers.

02:55:54,387 --> 02:55:55,220
For example,

02:55:55,220 --> 02:55:58,363
you have a packet processing or chasing something you said,

02:55:58,363 --> 02:56:00,128
Okay, I know I have a

02:56:00,128 --> 02:56:04,306
BPF or Chase SKB for some networking stuff,

02:56:04,306 --> 02:56:07,719
only available in new kernel, not older kernel.

02:56:07,719 --> 02:56:08,552
- [Jose] Yes.

02:56:08,552 --> 02:56:10,612
- And there tie it to another kernel for BCC,

02:56:10,612 --> 02:56:12,282
or this is a helper support,

02:56:12,282 --> 02:56:16,034
then you cannot compile for the new kernel.

02:56:16,034 --> 02:56:19,284
- Well, we cannot make an inch to that.

02:56:20,262 --> 02:56:21,095
The compiler built-in,

02:56:21,095 --> 02:56:23,939
I like the approach because for example it does,

02:56:23,939 --> 02:56:26,878
I don't know like arguments checking, for example.

02:56:26,878 --> 02:56:29,198
So if you pass the wrong arguments to a compiler helper,

02:56:29,198 --> 02:56:32,101
it actually tells you at compile time,

02:56:32,101 --> 02:56:33,788
you don't have to wait for the kernel to complain.

02:56:33,788 --> 02:56:36,933
- We had discussed offline about the best way to do that

02:56:36,933 --> 02:56:38,540
but

02:56:38,540 --> 02:56:43,123
to fix the built-in either upon compiler implementation

02:56:44,502 --> 02:56:47,738
at a particular version is basically one work.

02:56:47,738 --> 02:56:48,819
- Okay,

02:56:48,819 --> 02:56:51,595
I'm absolutely interested and your opinions on that.

02:56:51,595 --> 02:56:53,510
And actually, I think that it's about time

02:56:53,510 --> 02:56:56,759
that we have this kind of discussions online.

02:56:56,759 --> 02:56:57,592
Yeah.

02:56:58,720 --> 02:57:01,309
Well, the BPF helpers,

02:57:01,309 --> 02:57:03,533
dash helpers not underscore helpers dot h

02:57:03,533 --> 02:57:07,372
that at the moment GCC is distributing,

02:57:07,372 --> 02:57:09,387
I want to get rid of it,

02:57:09,387 --> 02:57:10,555
because I think that we can all use

02:57:10,555 --> 02:57:12,442
the same header in the kernel tree,

02:57:12,442 --> 02:57:15,396
or, I mean, it makes full sense.

02:57:15,396 --> 02:57:16,840
But for the moment,

02:57:16,840 --> 02:57:20,257
GCC has this BPF dash helpers instead of underscore helpers

02:57:20,257 --> 02:57:22,943
probably we will be able to work out,

02:57:22,943 --> 02:57:25,001
some common grounds here.

02:57:25,001 --> 02:57:26,045
Well, also,

02:57:26,045 --> 02:57:28,453
well, you have an option to specify in the endian

02:57:28,453 --> 02:57:30,703
exactly like the LLVM dash.

02:57:32,703 --> 02:57:35,137
And also, I had to introduce a new option here,

02:57:35,137 --> 02:57:39,724
which is to increase the limit on the frame size,

02:57:39,724 --> 02:57:41,089
which is limited by BPF.

02:57:41,089 --> 02:57:42,922
More about this later.

02:57:45,273 --> 02:57:46,952
Okay, one of the things I did

02:57:46,952 --> 02:57:49,900
was to try to support as much C as possible,

02:57:49,900 --> 02:57:53,319
but the BPM platform architecture is so restrictive

02:57:53,319 --> 02:57:56,234
that that's not always possible.

02:57:56,234 --> 02:57:57,762
I try to do for example, this is something

02:57:57,762 --> 02:58:00,787
that they would like to discuss with you as well.

02:58:00,787 --> 02:58:05,787
I mean how can we come with some general common mechanisms

02:58:05,891 --> 02:58:09,805
to support the unlock alloca for example things like that.

02:58:09,805 --> 02:58:11,138
So does it work?

02:58:12,673 --> 02:58:14,240
Yes.

02:58:14,240 --> 02:58:16,111
Those tests are all compiling test.

02:58:16,111 --> 02:58:18,077
They are not run tests, all right.

02:58:18,077 --> 02:58:20,292
That will have to wait for the simulator.

02:58:20,292 --> 02:58:23,495
But yeah, it solves I think that the backend

02:58:23,495 --> 02:58:26,935
and the GCC maintainers global maintenance agrees with that

02:58:26,935 --> 02:58:29,721
it looks like it's in a good shape.

02:58:29,721 --> 02:58:32,011
So, first question I have for you,

02:58:32,011 --> 02:58:33,465
how shall they call this thing?

02:58:33,465 --> 02:58:37,303
Because I mean cBPF okay eBPF are now

02:58:37,303 --> 02:58:39,211
what is the was too late to.

02:58:39,211 --> 02:58:40,274
Should I call it a eBPF

02:58:40,274 --> 02:58:43,357
or should I change everything to BPF.

02:58:44,857 --> 02:58:46,890
- [Audience] Typically we suggest the BPF.

02:58:46,890 --> 02:58:48,292
- BPF, Okay fine.

02:58:48,292 --> 02:58:51,019
So I think I did the right thing maybe instinctively

02:58:51,019 --> 02:58:52,261
since the beginning.

02:58:52,261 --> 02:58:55,363
Because I'm using BPF in symbols three to the GCC

02:58:55,363 --> 02:58:57,275
and eBPF in documentation.

02:58:57,275 --> 02:58:58,270
Okay, we'll change it in GCC.

02:58:58,270 --> 02:59:01,017
- I think we should call it CTF--

02:59:01,017 --> 02:59:04,089
(audience laughing)

02:59:04,089 --> 02:59:04,922
Okay, then

02:59:06,423 --> 02:59:08,314
I want to propose, I mean,

02:59:08,314 --> 02:59:11,703
this is something I'm actually currently working on it,

02:59:11,703 --> 02:59:13,409
the name is not important,

02:59:13,409 --> 02:59:15,798
I don't care about the name.

02:59:15,798 --> 02:59:19,548
I need a less restrictive version of the BPF.

02:59:20,408 --> 02:59:24,089
So, I can test my compiler properly.

02:59:24,089 --> 02:59:24,922
And so,

02:59:26,992 --> 02:59:30,719
I thought about calling it xBPF for experimental BPF.

02:59:30,719 --> 02:59:33,078
But again the name is not important, all right.

02:59:33,078 --> 02:59:35,279
I am open to any name.

02:59:35,279 --> 02:59:37,303
Basically, the fact is,

02:59:37,303 --> 02:59:39,910
this is an appeal to other architecture, right?

02:59:39,910 --> 02:59:41,993
So, I need to be able to,

02:59:43,678 --> 02:59:45,739
to change the stack frame size,

02:59:45,739 --> 02:59:47,539
so, I can compile C functions,

02:59:47,539 --> 02:59:51,634
like for example, a lot of local variables.

02:59:51,634 --> 02:59:53,498
I need an indirect call instruction,

02:59:53,498 --> 02:59:58,081
I noticed that in LLVM, you are actually generating one

02:59:59,486 --> 03:00:01,671
and I will use the same encoding

03:00:01,671 --> 03:00:03,998
that you are using because why not.

03:00:03,998 --> 03:00:08,915
Also in a BPF program when a function caller calls another,

03:00:09,772 --> 03:00:11,686
it is possible for the callee

03:00:11,686 --> 03:00:14,172
to access the stack frame of the caller

03:00:14,172 --> 03:00:16,633
but only using absolute addressing.

03:00:16,633 --> 03:00:19,853
I mean you cannot use the frame pointer of the callee

03:00:19,853 --> 03:00:23,936
to access you know the stuck frame of the caller.

03:00:25,416 --> 03:00:28,968
In this xBPF I plan to actually allow

03:00:28,968 --> 03:00:33,314
to access the color stuck frame using the frame pointer

03:00:33,314 --> 03:00:34,488
in the callee.

03:00:34,488 --> 03:00:35,321
Why?

03:00:35,321 --> 03:00:36,902
So, I can support passing arguments on the stack

03:00:36,902 --> 03:00:41,201
so we can get rid of the limit of five words

03:00:41,201 --> 03:00:43,173
passing as arguments to the functions

03:00:43,173 --> 03:00:47,607
and also that will give me also the possibility

03:00:47,607 --> 03:00:49,524
of stack traces, right?

03:00:51,225 --> 03:00:52,417
Like a back tracer.

03:00:52,417 --> 03:00:54,398
Which could be I think very useful for debugging

03:00:54,398 --> 03:00:55,815
your BPF program.

03:00:57,544 --> 03:01:01,118
Also, I want to assign division instruction.

03:01:01,118 --> 03:01:02,120
I wanted.

03:01:02,120 --> 03:01:03,766
I mean,

03:01:03,766 --> 03:01:05,977
also to avoid because at the moment

03:01:05,977 --> 03:01:09,332
GCC generates a phone call if it sees that.

03:01:09,332 --> 03:01:14,329
So basically, the idea is that you compile your BPF program

03:01:14,329 --> 03:01:16,735
as an xBPF program,

03:01:16,735 --> 03:01:18,068
and then you can

03:01:19,167 --> 03:01:21,848
go for what those all those avoid those restrictions.

03:01:21,848 --> 03:01:23,227
What is the purpose of it?

03:01:23,227 --> 03:01:25,020
First, so I can compile,

03:01:25,020 --> 03:01:27,687
I can test my compiler properly.

03:01:28,955 --> 03:01:33,158
Because at the moment, I have to disable hundreds

03:01:33,158 --> 03:01:36,247
and hundreds and hundreds of tests in GCC

03:01:36,247 --> 03:01:39,287
because they use more than five arguments in functions

03:01:39,287 --> 03:01:42,191
because they have the stack limitation

03:01:42,191 --> 03:01:45,952
which is limited to 512 bytes by default

03:01:45,952 --> 03:01:47,588
and so on.

03:01:47,588 --> 03:01:49,893
And that is bad for my testing.

03:01:49,893 --> 03:01:51,832
Because I understand that you cannot run those programs

03:01:51,832 --> 03:01:52,665
in the kernel,

03:01:52,665 --> 03:01:54,175
but I need to test my compiler.

03:01:54,175 --> 03:01:58,599
So we are basically negating the possibility to ourselves to

03:01:58,599 --> 03:01:59,811
to use our test weight

03:01:59,811 --> 03:02:03,102
only because of those limitations.

03:02:03,102 --> 03:02:05,766
And so forth I say that really to debug your BPF program

03:02:05,766 --> 03:02:10,766
so you can use while debugging it in the back tracers.

03:02:10,959 --> 03:02:13,317
And so we think it will be interesting to have

03:02:13,317 --> 03:02:17,400
as a sandbox so you could experiment with lifting

03:02:19,980 --> 03:02:21,880
some of the restrictions in the future

03:02:21,880 --> 03:02:25,094
maybe along with working the kernel verifier.

03:02:25,094 --> 03:02:29,700
And also and I am very interested on this last point.

03:02:29,700 --> 03:02:33,959
To explore a bit more to leverage ELF more, right?

03:02:33,959 --> 03:02:37,203
Because for example, in the GNU tool chain now,

03:02:37,203 --> 03:02:39,120
LT knows about the BPF.

03:02:40,268 --> 03:02:41,851
It's sort of links,

03:02:42,746 --> 03:02:46,756
but the BPF programs are very, very strange

03:02:46,756 --> 03:02:49,326
in the sense that didn't really correspond

03:02:49,326 --> 03:02:51,669
to the ELF concepts like executable

03:02:51,669 --> 03:02:56,086
with a single entry point, initializers or finalizers

03:02:57,179 --> 03:02:59,320
because it uses a completely different model

03:02:59,320 --> 03:03:03,187
where you have seven entry points and so on.

03:03:03,187 --> 03:03:06,760
I think that having the xBPF thing it cool also allows us

03:03:06,760 --> 03:03:11,370
to play a bit, explore possibilities of leveraging ELF

03:03:11,370 --> 03:03:14,370
a bit more than it's used right now.

03:03:15,749 --> 03:03:18,588
And then it will be awesome if in a LLVM

03:03:18,588 --> 03:03:20,927
you want to implement the same thing or something similar

03:03:20,927 --> 03:03:25,646
so we can get we can agree something like this.

03:03:25,646 --> 03:03:28,826
So you can probably I'm sure it will be useful for you also

03:03:28,826 --> 03:03:31,326
for running the LLVM this way.

03:03:35,652 --> 03:03:36,485
Also

03:03:39,351 --> 03:03:42,717
in my opinion, one of the recent ways of using a compiler

03:03:42,717 --> 03:03:44,406
is that you want the compiler

03:03:44,406 --> 03:03:46,265
I mean you want the errors not to

03:03:46,265 --> 03:03:50,534
as soon as possible in the development process, right?

03:03:50,534 --> 03:03:52,540
And generally speaking you don't want to have to wait

03:03:52,540 --> 03:03:54,760
until you do a syscall in the kernel

03:03:54,760 --> 03:03:58,510
to get the verifier for getting your problem.

03:03:59,685 --> 03:04:03,458
I know that the verifier is extremely sophisticated.

03:04:03,458 --> 03:04:06,769
And it is getting more and more sophisticated.

03:04:06,769 --> 03:04:10,915
But I really want the compiler and also the simulator

03:04:10,915 --> 03:04:14,832
to do a similar job that the verifier is doing.

03:04:15,830 --> 03:04:17,793
But I definitely I don't want to replicate

03:04:17,793 --> 03:04:20,446
the logic of the kernel verifier order.

03:04:20,446 --> 03:04:22,093
So my question for you is,

03:04:22,093 --> 03:04:24,176
is there a way to somehow

03:04:26,802 --> 03:04:29,770
access or use or reuse the kernel verifier

03:04:29,770 --> 03:04:32,403
from use of land from user space?

03:04:32,403 --> 03:04:35,767
Maybe a program, maybe a library?

03:04:35,767 --> 03:04:36,850
I don't know.

03:04:41,672 --> 03:04:44,795
- Currently, there are some BPF of other work.

03:04:44,795 --> 03:04:48,304
Actually it take the verifier to the user space

03:04:48,304 --> 03:04:51,352
and but is really a pain to maintain that.

03:04:51,352 --> 03:04:52,185
- [Jose] Yeah.

03:04:52,185 --> 03:04:54,987
- I know whenever the verifier changes

03:04:54,987 --> 03:04:58,454
and find there are some kinds of interface changes

03:04:58,454 --> 03:05:01,590
they need to add or remove some kind of like,

03:05:01,590 --> 03:05:05,590
because they need to signal like to all these...

03:05:06,592 --> 03:05:08,275
stuff some other stuff.

03:05:08,275 --> 03:05:12,252
So it is really so they typically people do once a while,

03:05:12,252 --> 03:05:14,521
like every three or four, six months,

03:05:14,521 --> 03:05:16,939
you do well while some people enter the ruin it

03:05:16,939 --> 03:05:20,215
and make change you test the verifier.

03:05:20,215 --> 03:05:21,728
We don't do it,

03:05:21,728 --> 03:05:23,300
we're over.

03:05:23,300 --> 03:05:24,133
- But is this something

03:05:24,133 --> 03:05:27,102
you would like to have in VM as well?

03:05:27,102 --> 03:05:29,613
- I think that is not scalable,

03:05:29,613 --> 03:05:30,857
this approach.

03:05:30,857 --> 03:05:35,551
So wherever you taken a verifier changes are so often

03:05:35,551 --> 03:05:38,875
and it's not a scalable approach.

03:05:38,875 --> 03:05:40,887
- And do you can you think on some other alternative

03:05:40,887 --> 03:05:44,187
approach that will allow us to do this.

03:05:44,187 --> 03:05:45,643
- I do--

03:05:45,643 --> 03:05:48,143
- Okay, we can think about it.

03:05:49,056 --> 03:05:52,306
- I just thought of something gruesome.

03:05:55,499 --> 03:06:00,249
- It's not the same problem the ice three are having is--

03:06:01,295 --> 03:06:03,074
- I have no idea about that.

03:06:03,074 --> 03:06:04,201
- Is exactly the same.

03:06:04,201 --> 03:06:05,591
There's something called FTD

03:06:05,591 --> 03:06:09,119
which is how to handle on the ice tree.

03:06:09,119 --> 03:06:12,332
And it's inside the kernel and it's also a library.

03:06:12,332 --> 03:06:15,582
So no, I think I'm not completely sure,

03:06:18,074 --> 03:06:19,407
but is the same.

03:06:20,483 --> 03:06:23,381
So it's also used by the current tree.

03:06:23,381 --> 03:06:25,955
So maybe you can take a look of what they are doing.

03:06:25,955 --> 03:06:28,289
They are all the same.

03:06:28,289 --> 03:06:29,122
- FDT?

03:06:30,184 --> 03:06:31,767
- File Device Tree.

03:06:32,893 --> 03:06:34,487
- I will thank thanks for this.

03:06:34,487 --> 03:06:36,983
- I just had a completely gruesome idea,

03:06:36,983 --> 03:06:39,816
which is leverage user mode Linux.

03:06:41,151 --> 03:06:43,234
If you could add some way

03:06:44,123 --> 03:06:46,809
to call into the verified direction

03:06:46,809 --> 03:06:49,392
which is only available to UML.

03:06:50,665 --> 03:06:52,415
You can compile UML--

03:06:54,321 --> 03:06:56,186
- Before doing that I will just do the syscall

03:06:56,186 --> 03:06:59,269
and I'll check for the error message.

03:07:00,349 --> 03:07:01,403
Yeah, the problem with that

03:07:01,403 --> 03:07:03,792
it doesn't tell me what happened.

03:07:03,792 --> 03:07:07,625
It does tell me that the program is not valid.

03:07:09,675 --> 03:07:11,001
Okay, the ABI.

03:07:11,001 --> 03:07:13,452
Okay, so the kernel verifier is about

03:07:13,452 --> 03:07:16,389
if a program is secure enough or safe enough to be executed

03:07:16,389 --> 03:07:17,854
in the kernel context,

03:07:17,854 --> 03:07:20,112
but then on the other side in compiled BPF,

03:07:20,112 --> 03:07:23,939
basically is what constitutes a valid ELF BPF program,

03:07:23,939 --> 03:07:24,772
right?

03:07:24,772 --> 03:07:26,907
At the moment, this is defined

03:07:26,907 --> 03:07:29,657
but what the LLV backend produces

03:07:30,959 --> 03:07:33,380
and what the kernel loaders should know this bpflib.

03:07:33,380 --> 03:07:34,766
Is it bpflib it up for libbpf?

03:07:34,766 --> 03:07:36,555
I always get so confused about that.

03:07:36,555 --> 03:07:37,888
And bpf_load.c ,

03:07:38,878 --> 03:07:43,045
which is a sample that is around internal sources.

03:07:44,766 --> 03:07:45,672
Okay, I mean,

03:07:45,672 --> 03:07:48,610
I'm not criticizing it, because I think is normal, right?

03:07:48,610 --> 03:07:51,158
Because that's the only implementation right now.

03:07:51,158 --> 03:07:53,638
But I really think an A would really appreciate

03:07:53,638 --> 03:07:57,667
if we could have some sort of common place

03:07:57,667 --> 03:08:02,084
where we could document that the stuff in the future.

03:08:04,622 --> 03:08:09,289
So, it will be nice and we have to get in touch I think.

03:08:10,487 --> 03:08:12,487
And then let us do that.

03:08:14,085 --> 03:08:17,249
Well, now there is a little VM now there is also GCC,

03:08:17,249 --> 03:08:19,596
the kernel is that consuming for now,

03:08:19,596 --> 03:08:22,622
but there will be all sorts of simulators and whatnot.

03:08:22,622 --> 03:08:25,637
And also, I think the traces been changed to

03:08:25,637 --> 03:08:29,621
it has a compiler as well because it compiles from language,

03:08:29,621 --> 03:08:30,592
the language.

03:08:30,592 --> 03:08:34,662
And I heard in yesterday in the bpftrace session

03:08:34,662 --> 03:08:37,302
that they also want to start generating BPF

03:08:37,302 --> 03:08:39,885
compile BPF as well themselves.

03:08:41,700 --> 03:08:44,655
So I think we need to co-ordinate somehow,

03:08:44,655 --> 03:08:46,141
for two reasons.

03:08:46,141 --> 03:08:48,875
One, because we meet particularly

03:08:48,875 --> 03:08:51,937
as the maintainer of the BPF support in GCC and binutils,

03:08:51,937 --> 03:08:53,051
I need to be in the loop.

03:08:53,051 --> 03:08:55,176
I mean, because I can run after you

03:08:55,176 --> 03:08:58,509
but it does not going to work very well.

03:09:00,094 --> 03:09:02,398
Also, we will lack

03:09:02,398 --> 03:09:05,815
we want also to contribute to it, right?

03:09:05,815 --> 03:09:08,315
So, for example, I don't know,

03:09:09,700 --> 03:09:12,200
this new addition of the CORE,

03:09:13,476 --> 03:09:14,710
I don't know how you pronounce it,

03:09:14,710 --> 03:09:16,391
this compile once run everywhere,

03:09:16,391 --> 03:09:18,752
which is very interesting, by the way.

03:09:18,752 --> 03:09:21,862
Okay, that inputs have new location, for example.

03:09:21,862 --> 03:09:25,102
So it will be nice if we could have mailing list

03:09:25,102 --> 03:09:27,359
from whatever where we could,

03:09:27,359 --> 03:09:28,554
what about that in this location,

03:09:28,554 --> 03:09:29,774
of this type this number,

03:09:29,774 --> 03:09:32,274
and handle it this way, right?

03:09:33,194 --> 03:09:34,766
And then we can talk about it

03:09:34,766 --> 03:09:37,000
and maybe publish it somewhere.

03:09:37,000 --> 03:09:38,442
I don't care where that could be.

03:09:38,442 --> 03:09:40,425
It could be in the BPF mailing list

03:09:40,425 --> 03:09:43,819
or in the kernel or I don't know,

03:09:43,819 --> 03:09:45,215
I don't care.

03:09:45,215 --> 03:09:47,298
But it will be very nice.

03:09:48,221 --> 03:09:49,650
And that was it.

03:09:49,650 --> 03:09:52,259
We are already ten minutes late.

03:09:52,259 --> 03:09:53,092
Questions?

03:09:54,802 --> 03:09:55,635
No.

03:09:55,635 --> 03:09:56,670
Yes.

03:09:56,670 --> 03:09:59,997
- [Audience] So apparently there is so--

03:09:59,997 --> 03:10:01,580
- Get one of those.

03:10:03,576 --> 03:10:05,154
- Thank you.

03:10:05,154 --> 03:10:06,571
So how about BTF?

03:10:09,830 --> 03:10:11,280
Because we were talking about,

03:10:11,280 --> 03:10:13,080
debugging and so on and so forth.

03:10:13,080 --> 03:10:14,402
- [Jose] Yes. - Yeah.

03:10:14,402 --> 03:10:17,634
- Well BTF is more important for GCC than you may think

03:10:17,634 --> 03:10:21,842
because again GCC this doesn't have an integrated assembler

03:10:21,842 --> 03:10:23,134
like LLVM does.

03:10:23,134 --> 03:10:24,599
Even though the LLVM integrates

03:10:24,599 --> 03:10:27,718
the assembly doesn't work for every case.

03:10:27,718 --> 03:10:29,885
I have to say that though.

03:10:31,084 --> 03:10:33,284
So for us is a neither

03:10:33,284 --> 03:10:35,820
you know it's compiled once run everywhere.

03:10:35,820 --> 03:10:37,245
For us it's a fundamental need.

03:10:37,245 --> 03:10:40,463
Is not only you know that are necessity.

03:10:40,463 --> 03:10:41,628
So, of course,

03:10:41,628 --> 03:10:46,498
we need to generate the BTF or something equivalent.

03:10:46,498 --> 03:10:49,969
Now my understanding is that the idea is to generate BTF

03:10:49,969 --> 03:10:50,802
for the kernel

03:10:50,802 --> 03:10:53,759
and then generate header files from the BTF, right?

03:10:53,759 --> 03:10:55,676
As far as I understood.

03:10:57,118 --> 03:10:59,164
So yes, now one of the next steps in GCC,

03:10:59,164 --> 03:11:01,442
which is something they want to discuss in the cauldron

03:11:01,442 --> 03:11:04,045
with the other GCC maintainer is that

03:11:04,045 --> 03:11:06,665
how can we generate BTF?

03:11:06,665 --> 03:11:07,528
Because now we're in the process

03:11:07,528 --> 03:11:11,323
of adding CTF generation in the kernel.

03:11:11,323 --> 03:11:13,517
So in the kernel in GCC.

03:11:13,517 --> 03:11:15,030
So I don't know,

03:11:15,030 --> 03:11:16,917
I don't know if,

03:11:16,917 --> 03:11:21,917
if we will generate CTF and then translate from CTF to BTF.

03:11:22,171 --> 03:11:25,467
And so we can use the kernel to creates whatever it is

03:11:25,467 --> 03:11:28,457
that will translate from BTF to header files

03:11:28,457 --> 03:11:30,718
or generate BTF directly,

03:11:30,718 --> 03:11:34,523
which also has some complications because in the compiler,

03:11:34,523 --> 03:11:35,356
well you know about that,

03:11:35,356 --> 03:11:37,273
they try to use DWARF internally

03:11:37,273 --> 03:11:39,610
as they can only curl the bug in format

03:11:39,610 --> 03:11:41,634
and generate everything else from it..

03:11:41,634 --> 03:11:42,618
It has to be discussed.

03:11:42,618 --> 03:11:44,510
But of course we need to generate BTF

03:11:44,510 --> 03:11:47,313
or CTF or something equivalent for sure.

03:11:47,313 --> 03:11:48,767
- Yeah, so we need to generate it

03:11:48,767 --> 03:11:52,307
and we also need to be able to read it and manipulate it.

03:11:52,307 --> 03:11:55,224
So this is a kind of a shout out to

03:11:57,232 --> 03:12:00,128
whoever is involved with that.

03:12:00,128 --> 03:12:01,228
Because, okay,

03:12:01,228 --> 03:12:02,508
it seems to me that

03:12:02,508 --> 03:12:05,707
so BTF is getting in to the kernel, right?

03:12:05,707 --> 03:12:07,707
So that's a fact, right?

03:12:09,618 --> 03:12:12,028
And so people need to read it.

03:12:12,028 --> 03:12:14,820
I guess when I say people, the kernel first, right?

03:12:14,820 --> 03:12:18,658
Needs to be able to read it and do stuff with it.

03:12:18,658 --> 03:12:19,575
Would it be

03:12:21,098 --> 03:12:26,098
reasonable to ask that the facilities to really be design

03:12:26,321 --> 03:12:30,000
or I don't know as a library reusable sometimes.

03:12:30,000 --> 03:12:32,212
- As noted libctf will gain the ability

03:12:32,212 --> 03:12:34,128
to both read and write.

03:12:34,128 --> 03:12:34,961
Sorry.

03:12:36,630 --> 03:12:40,952
- Is the library or as-- - As noted, libbpf.

03:12:40,952 --> 03:12:44,763
- As noted although actually reading the BTF

03:12:44,763 --> 03:12:46,469
will require allocations,

03:12:46,469 --> 03:12:49,201
I see no reason why the version of libctf

03:12:49,201 --> 03:12:52,810
I was talking about wouldn't be able to

03:12:52,810 --> 03:12:55,560
feed you BTF from CTF on the fly.

03:12:57,227 --> 03:12:58,575
As long as we're not you're not in an atomic configs

03:12:58,575 --> 03:12:59,408
when you open it.

03:12:59,408 --> 03:13:03,446
Why would you be in atomic configs when you open the BTF?

03:13:03,446 --> 03:13:04,279
So yes,

03:13:04,279 --> 03:13:07,498
I certainly hope we can help with that.

03:13:07,498 --> 03:13:11,334
- Yeah, well what I mentioned is today the library

03:13:11,334 --> 03:13:14,084
called the libbpf already available

03:13:14,084 --> 03:13:18,367
that the API try to read the BTF from basically

03:13:18,367 --> 03:13:19,601
to load the BPF

03:13:19,601 --> 03:13:20,434
and to the kernel

03:13:20,434 --> 03:13:22,267
and to read the BTF...

03:13:25,617 --> 03:13:26,950
- And can it be?

03:13:27,996 --> 03:13:29,819
- Either C library.

03:13:29,819 --> 03:13:33,402
- Okay, so it can read I mean BTF from KEL?

03:13:36,685 --> 03:13:39,539
- Yeah, you can read the BTF from a file

03:13:39,539 --> 03:13:41,488
and display that and load to kernel

03:13:41,488 --> 03:13:45,032
or you can read the BTF from the kernel.

03:13:45,032 --> 03:13:46,386
- And if you want to be able to put it out,

03:13:46,386 --> 03:13:47,699
of the the old section,

03:13:47,699 --> 03:13:49,822
I'm sure I can find a way to leverage

03:13:49,822 --> 03:13:52,107
libctf ability to do that with CTF

03:13:52,107 --> 03:13:53,706
and connecting with libctf

03:13:53,706 --> 03:13:57,785
think in some way you'll find some way to work together.

03:13:57,785 --> 03:13:58,922
- Thank you.

03:13:58,922 --> 03:14:00,374
- Okay, so we are super late

03:14:00,374 --> 03:14:03,934
and I am also closing the two chain maker conference.

03:14:03,934 --> 03:14:05,596
And thank you everyone for coming.

03:14:05,596 --> 03:14:06,738
Thank you for the presenters

03:14:06,738 --> 03:14:10,238
and because it was nice to have you in the

03:14:11,334 --> 03:14:12,869
and I hope it has be useful

03:14:12,869 --> 03:14:15,917
and I hope we have you know from the notes and everything

03:14:15,917 --> 03:14:19,762
that we've moved forward in several areas today.

03:14:19,762 --> 03:14:20,616
So thank you.

03:14:20,616 --> 03:14:23,101

YouTube URL: https://www.youtube.com/watch?v=WFZvx08mdjQ


