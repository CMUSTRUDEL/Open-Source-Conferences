Title: LPC2019 - Containers & Checkpoint Restore - MC
Publication date: 2019-11-18
Playlist: LPC2019 - MicroConferences
Description: 
	Containers & Checkpoint/Restore - MC
Captions: 
	00:00:00,428 --> 00:00:02,784
- All right, good afternoon everyone.

00:00:02,784 --> 00:00:06,188
Thank you for coming to the Containers and Checkpoint

00:00:06,188 --> 00:00:08,612
Restore Micro Conference On Premise.

00:00:08,612 --> 00:00:10,973
I've honestly lost track of how many ones of those

00:00:10,973 --> 00:00:12,390
we've had by now.

00:00:14,360 --> 00:00:17,171
So you might have noticed unlike last year

00:00:17,171 --> 00:00:19,941
we didn't get the full day so we've got the afternoon

00:00:19,941 --> 00:00:22,678
and then a bit of the evening instead.

00:00:22,678 --> 00:00:25,937
And we've tried to do the usual kind of mix and match

00:00:25,937 --> 00:00:29,348
of both containers topics and checkpoint restore

00:00:29,348 --> 00:00:32,126
so that hopefully we keep everyone in the room.

00:00:32,126 --> 00:00:33,543
Maybe, we'll see.

00:00:34,663 --> 00:00:37,067
The Etherpad address is right there.

00:00:37,067 --> 00:00:38,892
We're gonna have a laptop that always tries

00:00:38,892 --> 00:00:40,169
and show it there.

00:00:40,169 --> 00:00:41,904
If it's not showing the right thing,

00:00:41,904 --> 00:00:45,268
tell me and I'll make sure we scroll.

00:00:45,268 --> 00:00:47,185
Schedule is this thing.

00:00:48,225 --> 00:00:52,579
We did some switches yesterday of two talks, I think,

00:00:52,579 --> 00:00:55,162
otherwise we've not modified it

00:00:56,133 --> 00:00:58,718
and that's on the website so as long as you looked at it

00:00:58,718 --> 00:01:00,885
this morning, you're fine.

00:01:02,203 --> 00:01:05,924
And, I believe that's it for what I've got.

00:01:05,924 --> 00:01:07,382
Maybe just for the speakers again

00:01:07,382 --> 00:01:10,446
like we do want it to be mostly a discussion

00:01:10,446 --> 00:01:13,792
so do try to engage with people

00:01:13,792 --> 00:01:15,545
and for the audience, like,

00:01:15,545 --> 00:01:17,826
don't wait until the end to talk.

00:01:17,826 --> 00:01:21,007
Like, yeah, just interrupt and chat.

00:01:21,007 --> 00:01:24,340
We've got a strobe ball thing somewhere.

00:01:25,257 --> 00:01:26,620
There, okay.

00:01:26,620 --> 00:01:29,717
So yeah, those will fly your way if you've got a question.

00:01:29,717 --> 00:01:31,157
Please wait for the microphone.

00:01:31,157 --> 00:01:33,209
We would like the recording to include

00:01:33,209 --> 00:01:35,113
people's questions on them.

00:01:35,113 --> 00:01:36,474
So, we've got two microphones.

00:01:36,474 --> 00:01:41,033
They'll come your way if you raise your hand.

00:01:41,033 --> 00:01:43,658
And, I think that's what I've got

00:01:43,658 --> 00:01:46,324
so Adrian can get set up.

00:01:46,324 --> 00:01:48,002
I don't know if he wants to wait

00:01:48,002 --> 00:01:51,024
to be exactly on time so if someone shows up,

00:01:51,024 --> 00:01:52,129
for that exactly on time?

00:01:52,129 --> 00:01:52,962
I dunno.

00:01:52,962 --> 00:01:55,241
- We probably should also point out we have an Etherpad--

00:01:55,241 --> 00:01:56,074
- Right.

00:01:56,074 --> 00:01:59,084
- For people to take notes and I don't know if we put it up

00:01:59,084 --> 00:02:01,147
on the screen right here but I think there's like,

00:02:01,147 --> 00:02:06,002
we have a ridiculously long name for this Etherpad but

00:02:06,002 --> 00:02:07,201
you can see it here.

00:02:07,201 --> 00:02:12,201
Etherpad.net/p/lpc2019_containers_and_checkpoint_restore.

00:02:17,128 --> 00:02:17,961
Sorry.

00:02:17,961 --> 00:02:21,557
(people laughing)

00:02:21,557 --> 00:02:24,325
- Are you volunteering to be Etherpad namer next year?

00:02:24,325 --> 00:02:25,158
(people laughing)

00:02:25,158 --> 00:02:26,797
- Yeah, exactly.

00:02:26,797 --> 00:02:29,927
(man speaking softly)

00:02:29,927 --> 00:02:34,927
- You can put them (mumbles) and just give the short name

00:02:36,847 --> 00:02:38,160
or list them on the website.

00:02:38,160 --> 00:02:41,910
I'm not sure if there are any on the website.

00:02:44,521 --> 00:02:46,021
I'm tempted to say we can probably just go.

00:02:46,021 --> 00:02:46,854
- Okay.

00:02:46,854 --> 00:02:47,687
- Yeah.

00:02:50,540 --> 00:02:52,593
- So thanks for having me here.

00:02:52,593 --> 00:02:54,561
My name is Adrian Reber.

00:02:54,561 --> 00:02:57,262
I am working on process migration,

00:02:57,262 --> 00:02:58,734
at least for the last 10 years.

00:02:58,734 --> 00:03:02,817
I'm involved in CRIU, which this is about partly,

00:03:04,087 --> 00:03:08,004
at least since 2012, I'm doing things with CRIU

00:03:09,022 --> 00:03:10,022
and this is,

00:03:12,492 --> 00:03:15,160
the talk is actually about how to avoid

00:03:15,160 --> 00:03:17,327
what we call the PID dance

00:03:18,838 --> 00:03:21,604
but I like this shorter title better

00:03:21,604 --> 00:03:23,737
so then I just stop.

00:03:23,737 --> 00:03:28,570
So this is about checkpoint restore in userspace and CRIU.

00:03:29,839 --> 00:03:33,919
And CRIU was actually discussed at Atlanta Linux Plumbers

00:03:33,919 --> 00:03:35,169
in 2011 so it's

00:03:36,570 --> 00:03:40,813
always been kind of here at Linux Plumbers.

00:03:40,813 --> 00:03:42,413
And from the beginning one of the goals

00:03:42,413 --> 00:03:46,128
of CRIU was to be as transparent as possible

00:03:46,128 --> 00:03:50,254
and transparent as possible means that CRIU

00:03:50,254 --> 00:03:53,571
should be able to checkpoint and restore

00:03:53,571 --> 00:03:57,320
any process without CRIU requirements.

00:03:57,320 --> 00:04:00,974
This goal comes from other checkpoint restore implementation

00:04:00,974 --> 00:04:02,842
which existed at the time.

00:04:02,842 --> 00:04:05,558
So it was ever external chrome modules

00:04:05,558 --> 00:04:10,152
or you had to preload libraries to intercept system calls.

00:04:10,152 --> 00:04:12,940
So there were different kind

00:04:12,940 --> 00:04:16,499
of checkpoint restore implementation and CRIU

00:04:16,499 --> 00:04:21,332
had a goal to not be like these in some way to be able to,

00:04:22,405 --> 00:04:25,969
to be able to restore and checkpoint any process

00:04:25,969 --> 00:04:27,467
you have in the system.

00:04:27,467 --> 00:04:30,667
One of the results from being as transparent as possible

00:04:30,667 --> 00:04:35,084
is the PID stays the same it had during checkpointing

00:04:36,017 --> 00:04:39,052
and it will be the same during restore

00:04:39,052 --> 00:04:42,135
and for, if you have a single process

00:04:43,265 --> 00:04:45,609
it wouldn't really be important.

00:04:45,609 --> 00:04:47,820
The process could change its PID

00:04:47,820 --> 00:04:50,136
but if CRIU, what CRIU usually does,

00:04:50,136 --> 00:04:53,881
you point it to a PID and it will restore this process

00:04:53,881 --> 00:04:55,826
and all trial processes.

00:04:55,826 --> 00:04:59,365
It will checkpoint the process and all trial processes.

00:04:59,365 --> 00:05:00,747
And if you want to restore it,

00:05:00,747 --> 00:05:03,476
you want to keep the parent child relation in tact

00:05:03,476 --> 00:05:07,209
and that's why it will always restore a process

00:05:07,209 --> 00:05:10,930
with the same PID or the complete process tree.

00:05:10,930 --> 00:05:11,763
And,

00:05:17,599 --> 00:05:20,660
it will restore the process with the same process ID.

00:05:20,660 --> 00:05:22,243
And, this opens up,

00:05:24,569 --> 00:05:26,903
one of the problems with this is that this opens up

00:05:26,903 --> 00:05:30,323
CRIU to, the restore to PID collisions.

00:05:30,323 --> 00:05:32,890
So if the PID already exists on the system,

00:05:32,890 --> 00:05:35,890
the restore will just fail and stop.

00:05:36,772 --> 00:05:40,524
One solution around this is PID namespaces.

00:05:40,524 --> 00:05:43,441
So, CRIU often works on containers.

00:05:45,025 --> 00:05:48,265
Containers often use PID namespaces

00:05:48,265 --> 00:05:51,164
so if you restore something in a PID namespace,

00:05:51,164 --> 00:05:53,224
you usually don't have the problem

00:05:53,224 --> 00:05:56,807
that you get a PID collision but I'm saying

00:05:58,898 --> 00:06:02,014
that CRIU is independent of PID namespaces

00:06:02,014 --> 00:06:07,014
and I mean that you can restore it with a PID namespace.

00:06:07,265 --> 00:06:11,558
You can restore it in the currently running PID namespace

00:06:11,558 --> 00:06:14,725
but it's, it should work in every case

00:06:15,991 --> 00:06:18,112
and I'm mentioning this here because

00:06:18,112 --> 00:06:20,340
when we started to talk about clone3,

00:06:20,340 --> 00:06:22,730
I got a lot of questions but you're always using

00:06:22,730 --> 00:06:25,497
PID namespaces and this is not a case.

00:06:25,497 --> 00:06:29,793
So a restore should also work outside of a new PID namespace

00:06:29,793 --> 00:06:33,632
and in the currently running PID namespace

00:06:33,632 --> 00:06:37,827
and then you have the possibility of PID collision

00:06:37,827 --> 00:06:42,827
but CRIU would like still to work in such an environment.

00:06:43,023 --> 00:06:46,356
To restore a process, CRIU morphs itself

00:06:48,541 --> 00:06:52,124
into the restore process and one good point

00:06:54,295 --> 00:06:59,128
to describe this is, I like, was the file descriptor case.

00:07:00,807 --> 00:07:03,243
When you checkpoint a process, CRIU remembers

00:07:03,243 --> 00:07:06,646
the file descriptor ID, where the file descriptor

00:07:06,646 --> 00:07:09,056
is pointing to, to which file and the position

00:07:09,056 --> 00:07:13,006
and during restore, CRIU just tries to recreate it

00:07:13,006 --> 00:07:15,889
as it was during checkpointing and when the process

00:07:15,889 --> 00:07:19,329
continues to run, the file descriptor will be the same,

00:07:19,329 --> 00:07:21,850
will point to same file and to the same position

00:07:21,850 --> 00:07:23,413
of the file.

00:07:23,413 --> 00:07:28,133
And, the same happens for basically for the process tree

00:07:28,133 --> 00:07:32,700
and what CRIU does it, it does a clone for each PID, TIP.

00:07:32,700 --> 00:07:35,454
The process had during checkpointing

00:07:35,454 --> 00:07:38,533
and so the process tree is recreated

00:07:38,533 --> 00:07:41,278
as it used to be during checkpointing

00:07:41,278 --> 00:07:44,732
and this clone for each PID to make this possible,

00:07:44,732 --> 00:07:48,803
currently the PID dance, what we call it is necessary.

00:07:48,803 --> 00:07:51,012
And the PID dance consists of those steps.

00:07:51,012 --> 00:07:55,845
You open, proc and the last PID you write the PID you want

00:07:57,067 --> 00:07:59,002
minus one to ns_last_pid.

00:07:59,002 --> 00:08:00,636
You close ns_last_pid.

00:08:00,636 --> 00:08:02,897
You do the actual clone

00:08:02,897 --> 00:08:04,964
and then you do a getpid to verify

00:08:04,964 --> 00:08:08,797
that the PID you hoped to get you actually got

00:08:09,657 --> 00:08:10,657
and this is,

00:08:13,971 --> 00:08:17,656
this is open to race conditions as you can probably see

00:08:17,656 --> 00:08:20,320
because during writing to to ns_last_pid

00:08:20,320 --> 00:08:22,827
and doing the actual clone, some other process

00:08:22,827 --> 00:08:26,357
could have been created and then your getpid

00:08:26,357 --> 00:08:28,340
will return something else and in this case

00:08:28,340 --> 00:08:31,432
also CRIU will abort the restore.

00:08:31,432 --> 00:08:34,932
And, as it requires multiple system calls,

00:08:35,938 --> 00:08:39,021
it's also a bit slower as it could be

00:08:40,404 --> 00:08:43,144
and one point I want to mention,

00:08:43,144 --> 00:08:45,583
at the end it also requires CAP_SYS_ADMIN.

00:08:45,583 --> 00:08:49,245
This is not really important to the PID dance

00:08:49,245 --> 00:08:51,601
or clone3 but this is something

00:08:51,601 --> 00:08:55,648
I want to mention at the end of my talk.

00:08:55,648 --> 00:08:58,898
So, interestingly there was an approach

00:09:00,121 --> 00:09:03,257
for checkpoint restore in 2010.

00:09:03,257 --> 00:09:08,257
They also tried to create processes with certain PIDs.

00:09:08,491 --> 00:09:12,284
At that time, and this last PID didn't exist

00:09:12,284 --> 00:09:15,286
so what they tried to do in 2010

00:09:15,286 --> 00:09:18,828
is create a new system called eclone

00:09:18,828 --> 00:09:20,393
where you could specify the PID

00:09:20,393 --> 00:09:25,393
and you would get a new process with the PID you requested.

00:09:25,399 --> 00:09:29,776
This was an in kernel approach to checkpoint restore

00:09:29,776 --> 00:09:32,572
with over 100 patches and this was never merged

00:09:32,572 --> 00:09:35,057
and CRIU can actually be seen as a result

00:09:35,057 --> 00:09:38,359
of that failure to get it merged

00:09:38,359 --> 00:09:40,661
because it moved a lot of the things,

00:09:40,661 --> 00:09:43,115
like is mentioned in its name to userspace

00:09:43,115 --> 00:09:45,852
and not to do it in kernel.

00:09:45,852 --> 00:09:49,132
So, avoiding the PID dance in 2019

00:09:49,132 --> 00:09:52,465
is based, or at least we want to base it

00:09:53,387 --> 00:09:55,554
on the newly added clone3.

00:09:57,060 --> 00:10:01,060
Clone3 was introduced because the flex for clone

00:10:04,600 --> 00:10:07,933
ran out when clone pidfd was introduced.

00:10:08,939 --> 00:10:12,757
So for new clone flags, there was no space left

00:10:12,757 --> 00:10:16,878
if you don't remove the old unused flags

00:10:16,878 --> 00:10:20,386
and if we're looking, for example,

00:10:20,386 --> 00:10:24,236
at a time namespace, there would have been no free flag

00:10:24,236 --> 00:10:26,999
to create, to do a clone with a time namespace.

00:10:26,999 --> 00:10:31,727
So clone3 was introduced thanks to Christian and Jan

00:10:31,727 --> 00:10:35,367
and when I first heard about clone3

00:10:35,367 --> 00:10:38,643
I immediately thought about this would be great

00:10:38,643 --> 00:10:41,726
to have it extended and to use clone3

00:10:43,020 --> 00:10:46,005
and to be possible to specify a PID,

00:10:46,005 --> 00:10:51,005
you actually want for your process you want to create.

00:10:51,234 --> 00:10:55,565
And, I wrote a first patch a few months ago

00:10:55,565 --> 00:10:58,819
maybe when I heard about it and there was some

00:10:58,819 --> 00:11:03,402
private discussion about it and when I first graded it,

00:11:04,940 --> 00:11:07,857
I didn't limit it to CAP_SYS_ADMIN.

00:11:09,030 --> 00:11:11,800
I just basically let anyone create a process

00:11:11,800 --> 00:11:15,296
with whatever PID the user wanted

00:11:15,296 --> 00:11:18,963
and this approach was not seen very positive

00:11:19,986 --> 00:11:24,161
and so I talked again with the CRIU developers.

00:11:24,161 --> 00:11:27,598
They said they think it's important to continue

00:11:27,598 --> 00:11:30,190
and we continued to work on it

00:11:30,190 --> 00:11:34,857
and we have now a patch which could be merged soon maybe

00:11:36,399 --> 00:11:40,828
that has the same restrictions as the last PID.

00:11:40,828 --> 00:11:44,900
So you have CAP_SYS_ADMIN and you can create

00:11:44,900 --> 00:11:48,460
with one single system, call a new process with a PID

00:11:48,460 --> 00:11:50,951
you would like to have.

00:11:50,951 --> 00:11:55,175
So, using clone3 with set_tid would look like this.

00:11:55,175 --> 00:11:57,227
You just do your clone.

00:11:57,227 --> 00:12:01,588
You specify the PID you want, to the one you want

00:12:01,588 --> 00:12:06,421
and the process created should have the PID you specified.

00:12:08,402 --> 00:12:11,997
As already mentioned, this still requires CAP_SYS_ADMIN

00:12:11,997 --> 00:12:15,658
and it has the same limitations as ns_last_pid

00:12:15,658 --> 00:12:19,424
so this fails if the PID already exists.

00:12:19,424 --> 00:12:24,293
Each PID namespace has to have PID one or this will fail

00:12:24,293 --> 00:12:28,210
and if we can, and if this actually gets merged

00:12:29,261 --> 00:12:32,259
we can start to change CRIU to move away

00:12:32,259 --> 00:12:36,342
from its current PID dance to use clone3 instead.

00:12:38,836 --> 00:12:42,963
And, one more thing, which we would discuss

00:12:42,963 --> 00:12:47,546
as part of this clone3 change is to relax CAP_SYS_ADMIN

00:12:48,438 --> 00:12:50,864
on ns_last_pid and clone3.

00:12:50,864 --> 00:12:52,602
The reasons we would like to see this

00:12:52,602 --> 00:12:54,513
from maybe the previous side

00:12:54,513 --> 00:12:57,489
is rootless container migration.

00:12:57,489 --> 00:13:01,132
I'm also working partly a bit on the integration

00:13:01,132 --> 00:13:02,374
of CRIU into podman

00:13:02,374 --> 00:13:06,041
and running podman containers with non-root.

00:13:07,163 --> 00:13:09,959
With CRIU not requiring CAP_SYS_ADMIN

00:13:09,959 --> 00:13:13,757
would make it possible somehow to have container migration

00:13:13,757 --> 00:13:15,695
for non-root containers,

00:13:15,695 --> 00:13:19,778
for running containers as non-root on your system

00:13:20,837 --> 00:13:23,785
and if it's not CAP_SYS_ADMIN, maybe it would be possible

00:13:23,785 --> 00:13:28,200
to have that capability on the file doing the migration.

00:13:28,200 --> 00:13:31,805
Another use case were relaxation of CAP_SYS_ADMIN

00:13:31,805 --> 00:13:35,345
would be nice is the MPI use case.

00:13:35,345 --> 00:13:38,947
In HPC environments checkpoint restore used to be

00:13:38,947 --> 00:13:40,779
an important topic.

00:13:40,779 --> 00:13:44,068
Right now it's not so important any more

00:13:44,068 --> 00:13:46,206
because it requires a lot of time

00:13:46,206 --> 00:13:47,882
writing all those checkpoints to disk

00:13:47,882 --> 00:13:50,913
but still if we could have a way to do rootless

00:13:50,913 --> 00:13:53,951
and to offer checkpoint restore to rootless

00:13:53,951 --> 00:13:57,981
and MPI implementations, it could lead to

00:13:57,981 --> 00:14:00,898
more use of CRIU in those use cases

00:14:04,940 --> 00:14:08,219
and there's actually a talk from someone at Google,

00:14:08,219 --> 00:14:10,782
later an update on task migration at Google

00:14:10,782 --> 00:14:12,282
and I saw they are

00:14:15,340 --> 00:14:17,844
mentioning to also relax CAP_SYS_ADMIN

00:14:17,844 --> 00:14:19,793
to something like CAP_RESTORE.

00:14:19,793 --> 00:14:22,278
And this is something I would also like to see

00:14:22,278 --> 00:14:24,908
so if this is something,

00:14:24,908 --> 00:14:28,273
this is, which will be worked on,

00:14:28,273 --> 00:14:30,805
I'm really open to work with you on this

00:14:30,805 --> 00:14:32,305
to get this going.

00:14:35,176 --> 00:14:38,908
And, with this I'm already at the end of my presentation.

00:14:38,908 --> 00:14:41,018
These are the links I just mentioned there

00:14:41,018 --> 00:14:43,329
and there I'm at the end.

00:14:43,329 --> 00:14:45,329
Are there any questions?

00:14:47,211 --> 00:14:48,588
(people laughing)

00:14:48,588 --> 00:14:49,421
From Eric.

00:14:53,356 --> 00:14:56,581
- I want to address the permission relaxation thing

00:14:56,581 --> 00:14:58,609
really quickly.

00:14:58,609 --> 00:15:01,140
If you make it NS capable CAP_SYS_ADMIN

00:15:01,140 --> 00:15:04,260
of the PID namespace, that will mean

00:15:04,260 --> 00:15:06,673
as long as you create PID namespace

00:15:06,673 --> 00:15:10,293
without being root, you can do a restore without being root.

00:15:10,293 --> 00:15:11,955
- Okay.

00:15:11,955 --> 00:15:13,735
(man speaking softly)

00:15:13,735 --> 00:15:14,568
Okay.

00:15:14,568 --> 00:15:17,735
(man speaking softly)

00:15:18,729 --> 00:15:19,646
Microphone.

00:15:21,461 --> 00:15:22,968
(people laughing)

00:15:22,968 --> 00:15:26,594
(laughing drowns out speaker)

00:15:26,594 --> 00:15:29,063
- So yeah, that's sort of that's what we did.

00:15:29,063 --> 00:15:33,057
So you need to be ns_capable in the owning user namespace

00:15:33,057 --> 00:15:35,782
of the target PID namespace.

00:15:35,782 --> 00:15:39,355
- In which case rootless isn't a problem

00:15:39,355 --> 00:15:41,378
because rootless you would have created a PID name.

00:15:41,378 --> 00:15:43,905
Unless you want to do unprivilege restore,

00:15:43,905 --> 00:15:45,362
not for rootless container

00:15:45,362 --> 00:15:46,760
but for just like a random process.

00:15:46,760 --> 00:15:47,963
In that case, it wouldn't work

00:15:47,963 --> 00:15:49,345
but for rootless containers it would work.

00:15:49,345 --> 00:15:50,719
- [Adrian] Oh, really, okay.

00:15:50,719 --> 00:15:51,552
- Yeah.

00:15:51,552 --> 00:15:52,385
- [Adrian] I haven't thought about that.

00:15:52,385 --> 00:15:53,218
Okay.

00:15:53,218 --> 00:15:55,946
- And then the other part I keep picking on,

00:15:55,946 --> 00:15:59,863
multiple levels of PID namespace being restored

00:16:02,124 --> 00:16:03,589
at the same time.

00:16:03,589 --> 00:16:05,613
I was talking earlier to someone who was saying

00:16:05,613 --> 00:16:07,648
that had gotten dropped because they couldn't figure out

00:16:07,648 --> 00:16:10,162
how the permissions should work

00:16:10,162 --> 00:16:15,162
and it occurs to me that if during restore what you do

00:16:15,306 --> 00:16:19,631
is you take, whoever you start out as permissions,

00:16:19,631 --> 00:16:24,274
you know, root or an unprivileged user who does stuff

00:16:24,274 --> 00:16:27,646
and you never set new ID and you work all your processes

00:16:27,646 --> 00:16:29,479
before that, you know,

00:16:31,497 --> 00:16:34,071
and you should be able to use,

00:16:34,071 --> 00:16:36,496
have all your original permissions go through

00:16:36,496 --> 00:16:40,351
while you're creating your processes with their PIDs.

00:16:40,351 --> 00:16:43,377
So it shouldn't be a problem to be able to restore

00:16:43,377 --> 00:16:46,294
multiple PIDs, levels of PID names,

00:16:47,926 --> 00:16:50,451
PIDs and PID namespaces at the same time.

00:16:50,451 --> 00:16:54,338
- What if you have an intermediate user namespace?

00:16:54,338 --> 00:16:57,203
- You would go through and like create that on the side

00:16:57,203 --> 00:17:00,120
and call set_ns to get things built

00:17:02,526 --> 00:17:05,799
but you don't, you do that outside

00:17:05,799 --> 00:17:08,352
of building your process tree.

00:17:08,352 --> 00:17:10,058
- Right so basically you have another process

00:17:10,058 --> 00:17:11,859
which is like privileged with context to it

00:17:11,859 --> 00:17:14,047
which is in the top level user namespace.

00:17:14,047 --> 00:17:16,674
- Well, the thing with intermediate user namespace

00:17:16,674 --> 00:17:18,233
is you have to drop privileges.

00:17:18,233 --> 00:17:19,066
- [Man] Exactly, yes.

00:17:19,066 --> 00:17:20,289
- To start doing stuff with that

00:17:20,289 --> 00:17:23,028
so if the intermediate process that drops privileges,

00:17:23,028 --> 00:17:24,753
you keep all your privileges while you set

00:17:24,753 --> 00:17:28,170
all your process tree and you call setuid

00:17:29,298 --> 00:17:30,913
and set_, yeah.

00:17:30,913 --> 00:17:33,515
Oh wait, I think that works.

00:17:33,515 --> 00:17:34,348
Um, yeah.

00:17:35,785 --> 00:17:40,029
Yeah because you can, yeah you can drop the user namespace.

00:17:40,029 --> 00:17:42,775
- Actually, when we restore a process tree,

00:17:42,775 --> 00:17:45,608
we need to, so we have one process

00:17:46,716 --> 00:17:50,436
which is in this space already then we need to restore

00:17:50,436 --> 00:17:54,371
a child so we need to work from this process

00:17:54,371 --> 00:17:57,288
and restore all piece on all level,

00:17:58,580 --> 00:18:00,743
I mean, in parent PID namespace,

00:18:00,743 --> 00:18:03,838
parent of parent PID namespace.

00:18:03,838 --> 00:18:08,580
How can we change permission for the parent PID namespace?

00:18:08,580 --> 00:18:10,381
- Okay so your cred,

00:18:10,381 --> 00:18:15,381
so your starting process that forks and forks and forks

00:18:15,778 --> 00:18:18,104
and creates all your children,

00:18:18,104 --> 00:18:20,793
its cred starts out being, you know,

00:18:20,793 --> 00:18:23,120
having all the appropriate permissions to create

00:18:23,120 --> 00:18:25,575
all your PID namespaces and do everything.

00:18:25,575 --> 00:18:29,408
And so, as long as you don't change that cred,

00:18:30,285 --> 00:18:32,178
you still have it.

00:18:32,178 --> 00:18:35,135
You might have to call setns to get into the PID namespaces

00:18:35,135 --> 00:18:38,231
and stuff for your children but as long

00:18:38,231 --> 00:18:40,374
as you don't mess with your creds until after

00:18:40,374 --> 00:18:43,252
you've created the process tree, you'll have all

00:18:43,252 --> 00:18:47,589
of your permissions while the tree of processes

00:18:47,589 --> 00:18:52,339
is being built so it will pass all the permission checks.

00:18:53,711 --> 00:18:54,544
- [Man] I will see, okay.

00:18:54,544 --> 00:18:58,332
(man speaking softly)

00:18:58,332 --> 00:18:59,636
- User namespace it will be,

00:18:59,636 --> 00:19:00,805
if the owner would be different.

00:19:00,805 --> 00:19:02,894
So I guess your point is is that if you have

00:19:02,894 --> 00:19:05,424
this process tree creation thing,

00:19:05,424 --> 00:19:09,441
you then can have something else which is CAP_SYS_ADMIN

00:19:09,441 --> 00:19:13,474
in the top level, PID namespace owning user namespace

00:19:13,474 --> 00:19:15,755
and that will have privileges of the lower ones

00:19:15,755 --> 00:19:17,271
even though to set up you will still need

00:19:17,271 --> 00:19:18,486
to create a user namespace.

00:19:18,486 --> 00:19:19,319
Is that what you're saying?

00:19:19,319 --> 00:19:22,952
- So, your initial process has privileges over everything

00:19:22,952 --> 00:19:26,576
because it's your user and you keep those credentials

00:19:26,576 --> 00:19:28,309
while you're creating the process tree.

00:19:28,309 --> 00:19:32,431
To create the subordinate PID namespaces,

00:19:32,431 --> 00:19:35,513
you go off on the side and you create a user namespace,

00:19:35,513 --> 00:19:38,245
go into the user namespace and create the PID namespace

00:19:38,245 --> 00:19:41,707
and then the process tree you call setns.

00:19:41,707 --> 00:19:45,538
So, the children show up in that in PID namespace.

00:19:45,538 --> 00:19:48,493
So the PID namespace has user namespace limitation

00:19:48,493 --> 00:19:50,442
but your process still doesn't.

00:19:50,442 --> 00:19:54,041
So it has permissions over the parent PID namespace.

00:19:54,041 --> 00:19:55,517
- I think I'll have to think about it for one second.

00:19:55,517 --> 00:19:56,350
(people laughing)

00:19:56,350 --> 00:19:57,183
- Okay.

00:19:57,183 --> 00:20:00,886
- So this seems very elaborate and very complicated

00:20:00,886 --> 00:20:02,442
and I think one of the other reasons

00:20:02,442 --> 00:20:04,738
that I brought up why this didn't come to fruition

00:20:04,738 --> 00:20:08,326
was that you didn't really need it, right?

00:20:08,326 --> 00:20:09,909
I mean, Pablo said.

00:20:13,337 --> 00:20:14,420
Go on, sorry.

00:20:17,291 --> 00:20:20,774
- Actually we want to support checkpoint restore

00:20:20,774 --> 00:20:22,963
for nested PID namespaces

00:20:22,963 --> 00:20:25,450
but when we tried to implement this,

00:20:25,450 --> 00:20:27,450
we just found that it's,

00:20:28,860 --> 00:20:32,029
right now it's very complicated so now we just leave

00:20:32,029 --> 00:20:33,707
and separate (mumbles).

00:20:33,707 --> 00:20:35,636
We don't want to merge this complicated code

00:20:35,636 --> 00:20:38,554
into the CRIU right now but in the future

00:20:38,554 --> 00:20:42,503
we want to have support for nested PID namespaces.

00:20:42,503 --> 00:20:47,472
So, it's like, checkpoint restore for nested containers

00:20:47,472 --> 00:20:52,055
when you run a few containers inside another container.

00:20:59,595 --> 00:21:02,540
- So I guess that's enough for now

00:21:02,540 --> 00:21:07,118
and we'll continue this conversation with the code.

00:21:07,118 --> 00:21:08,201
- [Man] Yeah.

00:21:10,586 --> 00:21:12,419
- Any other questions?

00:21:16,932 --> 00:21:19,022
All right, I guess that's it.

00:21:19,022 --> 00:21:20,427
- Okay, thanks.

00:21:20,427 --> 00:21:23,427
(audience clapping)

00:21:28,392 --> 00:21:31,725
(men chattering softly)

00:22:27,636 --> 00:22:32,266
- Should we wait till 30 or run and visit as it goes?

00:22:32,266 --> 00:22:34,427
Shall we wait till the exact time or?

00:22:34,427 --> 00:22:37,764
(man speaking softly)

00:22:37,764 --> 00:22:39,279
(laughing)

00:22:39,279 --> 00:22:40,112
- Okay.

00:22:40,112 --> 00:22:41,062
- Yeah, probably someone is trying

00:22:41,062 --> 00:22:43,335
to like jump between tracks but I don't (mumbles).

00:22:43,335 --> 00:22:44,833
- You've already shifted several things around

00:22:44,833 --> 00:22:45,875
so they're already screwed up.

00:22:45,875 --> 00:22:49,121
- Well, that was yesterday, yeah but (mumbles).

00:22:49,121 --> 00:22:51,469
- Yeah but also the other tracks don't line up anyway

00:22:51,469 --> 00:22:52,673
so people don't (background noise drowns out speaker).

00:22:52,673 --> 00:22:53,506
- Well, that's true, yeah.

00:22:53,506 --> 00:22:55,814
You can't actually do that much, yeah.

00:22:55,814 --> 00:22:57,504
Yeah I guess we can just go.

00:22:57,504 --> 00:23:01,671
- Okay so we are researching an interesting topic.

00:23:04,012 --> 00:23:06,865
It became traditional, like news from academia.

00:23:06,865 --> 00:23:09,032
Anyway, we are working on,

00:23:10,335 --> 00:23:11,262
I'm here.

00:23:11,262 --> 00:23:12,929
- [Man] Yeah, we can hear you.

00:23:12,929 --> 00:23:14,264
- No, I hear too much.

00:23:14,264 --> 00:23:15,097
I echo.

00:23:15,097 --> 00:23:17,264
Anyway, we are looking to,

00:23:18,808 --> 00:23:21,493
we're investigating different ways to make containers

00:23:21,493 --> 00:23:23,222
more secure.

00:23:23,222 --> 00:23:28,016
One of the known production mechanisms for years

00:23:28,016 --> 00:23:30,785
has been MMU and virtual memory.

00:23:30,785 --> 00:23:34,505
It's how kernel protects itself from user processes

00:23:34,505 --> 00:23:38,932
and how user processes are protected from each other.

00:23:38,932 --> 00:23:41,249
And so, what we've been thinking

00:23:41,249 --> 00:23:45,416
is that we can, we can use multiple address spaces

00:23:48,606 --> 00:23:52,001
inside the Linux kernel so different parts

00:23:52,001 --> 00:23:55,606
of Linux kernel will see different mappings

00:23:55,606 --> 00:24:00,159
on the physical memory because vulnerabilities

00:24:00,159 --> 00:24:03,652
are inevitable and there is nothing that will change this.

00:24:03,652 --> 00:24:07,336
I don't think that we're ever able to produce

00:24:07,336 --> 00:24:10,418
any sort of result in vulnerability.

00:24:10,418 --> 00:24:14,397
So, restricting access from some parts of kernel

00:24:14,397 --> 00:24:16,941
to other parts of the kernel will make

00:24:16,941 --> 00:24:20,441
the attacker life harder and will protect,

00:24:21,355 --> 00:24:23,688
will give better protection.

00:24:27,136 --> 00:24:30,719
There is also been some work in the M area,

00:24:33,521 --> 00:24:36,263
which is work in progress about KVM address space isolation

00:24:36,263 --> 00:24:38,325
and the process local memory.

00:24:38,325 --> 00:24:42,408
Some people are proposing for storing VM secrets.

00:24:43,937 --> 00:24:46,405
Actual restricted address spaces implemented

00:24:46,405 --> 00:24:50,940
because everybody know the kernel page table isolation.

00:24:50,940 --> 00:24:52,690
What happens is user,

00:24:55,072 --> 00:24:59,881
the kernel mode part of user process page table,

00:24:59,881 --> 00:25:03,042
it has a restricted mapping for only essential visits

00:25:03,042 --> 00:25:06,398
required to enter the syscall and continues execution

00:25:06,398 --> 00:25:09,540
and there it happens to switch

00:25:09,540 --> 00:25:12,457
to the complete kernel page tables.

00:25:13,705 --> 00:25:16,458
Our first attempt at using address spaces

00:25:16,458 --> 00:25:20,375
for improving the isolation inside Linux kernel

00:25:21,443 --> 00:25:24,614
was we named it system call isolation

00:25:24,614 --> 00:25:28,531
and the idea was to use a restricted page table

00:25:30,931 --> 00:25:32,548
for execution of system call.

00:25:32,548 --> 00:25:35,071
So whenever an application executes system call,

00:25:35,071 --> 00:25:38,356
it gets some minimal set of mappings

00:25:38,356 --> 00:25:41,696
that are enough to start running the system call

00:25:41,696 --> 00:25:44,706
and whenever the system call processing

00:25:44,706 --> 00:25:49,104
requires additional, to access additional code or data

00:25:49,104 --> 00:25:51,290
we get a page fault and then in that page fault

00:25:51,290 --> 00:25:54,946
we can decide whether the access can be granted or not.

00:25:54,946 --> 00:25:58,498
So when we were thinking about what filters

00:25:58,498 --> 00:26:02,614
and how to make decision whether to grant access or not,

00:26:02,614 --> 00:26:04,894
the only thing that came to mind that we could try

00:26:04,894 --> 00:26:08,477
doing the ROP gadget prevention by checking

00:26:09,351 --> 00:26:12,540
that any calls that is going to be taken

00:26:12,540 --> 00:26:15,079
will be to a known symbol

00:26:15,079 --> 00:26:18,079
and not to the middle of a function.

00:26:19,078 --> 00:26:21,161
So, it didn't really fly.

00:26:22,115 --> 00:26:25,198
First, to have proper ROP prevention,

00:26:28,087 --> 00:26:32,754
you have to check on the return rather than on the call.

00:26:35,188 --> 00:26:37,757
It has a problem with granularity.

00:26:37,757 --> 00:26:41,497
So, whenever we already allowed access to certain pages,

00:26:41,497 --> 00:26:44,278
the entire page is mapped so an attacker can jump

00:26:44,278 --> 00:26:46,530
into the middle of that page because it's already

00:26:46,530 --> 00:26:48,152
in the page table.

00:26:48,152 --> 00:26:51,268
And the worst thing, I've been able to measure performance

00:26:51,268 --> 00:26:54,851
at some point so we don't want to go there.

00:26:57,603 --> 00:26:58,436
The next,

00:27:01,638 --> 00:27:03,307
okay, it was here.

00:27:03,307 --> 00:27:07,770
The next idea we had and we didn't start to work on it yet,

00:27:07,770 --> 00:27:10,603
is to create some special mappings

00:27:11,570 --> 00:27:16,570
in process virtual address space with mmap(MAP_SECRET)

00:27:17,222 --> 00:27:21,388
or so that the user can say, okay, I want this region to be

00:27:21,388 --> 00:27:24,602
private for me and this region won't be visible

00:27:24,602 --> 00:27:27,809
to other, not only to other processors

00:27:27,809 --> 00:27:29,492
but also to the kernel itself.

00:27:29,492 --> 00:27:31,794
It will be essentially every page that now

00:27:31,794 --> 00:27:36,316
that's populated in memory region will be dropped

00:27:36,316 --> 00:27:40,219
from the direct map and then this will allow

00:27:40,219 --> 00:27:43,243
something like opening a secret file,

00:27:43,243 --> 00:27:46,993
decrypting its contents and using and storing

00:27:47,898 --> 00:27:52,235
the secrets from a file inside protected memory areas

00:27:52,235 --> 00:27:54,231
that is not mapped by anybody

00:27:54,231 --> 00:27:57,392
except the process that uses it.

00:27:57,392 --> 00:28:00,293
And then assumption that for block IO,

00:28:00,293 --> 00:28:04,543
you don't usually go to copying bits from my device

00:28:06,769 --> 00:28:10,291
to memory but it's possible to download directly

00:28:10,291 --> 00:28:14,517
into the page that will be already mapped

00:28:14,517 --> 00:28:16,684
into the process services.

00:28:19,136 --> 00:28:24,136
And, another thing we are actively trying to work to

00:28:24,229 --> 00:28:27,023
with different level of success

00:28:27,023 --> 00:28:31,094
is marrying address spaces and namespaces.

00:28:31,094 --> 00:28:33,427
So, currently we are working

00:28:36,205 --> 00:28:40,355
on assigning private page tables for every instance

00:28:40,355 --> 00:28:42,909
of network namespace.

00:28:42,909 --> 00:28:46,992
Network namespace is allocating its objects from,

00:28:49,982 --> 00:28:53,352
it recreates a copy of networking (mumbles),

00:28:53,352 --> 00:28:56,113
the entire networking stack that is mostly independent

00:28:56,113 --> 00:28:59,399
of the rest of the system except some places

00:28:59,399 --> 00:29:02,484
where you need to cross namespace boundaries.

00:29:02,484 --> 00:29:05,555
For instance, when the skb travels from one namespace

00:29:05,555 --> 00:29:08,898
to an independent space or to the other namespace

00:29:08,898 --> 00:29:12,305
and most of the network namespace objects

00:29:12,305 --> 00:29:16,148
are private to that namespace so probably we can be able,

00:29:16,148 --> 00:29:19,587
we may be able to make them invisible in the page tables

00:29:19,587 --> 00:29:21,920
of other network namespaces.

00:29:22,786 --> 00:29:27,392
So, it's something like getting the PGD to struct net

00:29:27,392 --> 00:29:31,928
and then whenever process joins a network namespace

00:29:31,928 --> 00:29:34,351
with one of the existing system calls,

00:29:34,351 --> 00:29:39,351
its PGD is replaced with that one of the network namespaces.

00:29:40,385 --> 00:29:43,802
This allows us to save contacts which hid

00:29:44,909 --> 00:29:49,909
because the change of page table from full kernel page table

00:29:50,639 --> 00:29:53,814
to restricted page table becomes replaced with switched.

00:29:53,814 --> 00:29:57,147
And, again, the objects that are visible

00:29:58,699 --> 00:30:01,499
inside network namespace are dropped from direct map

00:30:01,499 --> 00:30:05,166
and they're not visible in other namespaces.

00:30:06,691 --> 00:30:09,328
I won't go now into the memory management details

00:30:09,328 --> 00:30:12,694
I tried to tell you about earlier.

00:30:12,694 --> 00:30:16,777
And then, supposing we can actually make it work,

00:30:20,351 --> 00:30:23,923
what does the model that is most appropriate

00:30:23,923 --> 00:30:28,690
for usage by container engines, for users and so on

00:30:28,690 --> 00:30:32,157
and we've got several difficult questions

00:30:32,157 --> 00:30:34,446
that we've been asking ourself

00:30:34,446 --> 00:30:37,663
and probably you come up with more.

00:30:37,663 --> 00:30:42,580
So, what other namespaces might gain some security benefits

00:30:47,173 --> 00:30:51,398
of being able to have their own page table?

00:30:51,398 --> 00:30:54,402
It seems to make sense for netns.

00:30:54,402 --> 00:30:56,819
It might be useful for mount.

00:30:58,324 --> 00:31:00,111
Probably UTS.

00:31:00,111 --> 00:31:01,754
I knew, I knew it.

00:31:01,754 --> 00:31:02,605
He says it.

00:31:02,605 --> 00:31:04,672
(man speaking softly)

00:31:04,672 --> 00:31:05,505
- Eric, yeah.

00:31:05,505 --> 00:31:09,501
- Oh, if just, not propgation totally destroys

00:31:09,501 --> 00:31:14,501
any ability to isolate one mount namespace from another.

00:31:14,797 --> 00:31:15,672
- Maybe.

00:31:15,672 --> 00:31:17,050
- Okay.

00:31:17,050 --> 00:31:19,057
- You can build namespaces that disconnect it

00:31:19,057 --> 00:31:20,556
that won't propagate.

00:31:20,556 --> 00:31:21,389
Right?

00:31:21,389 --> 00:31:23,648
So there is a use case where you could possibly

00:31:23,648 --> 00:31:25,207
disconnect a mount namespace

00:31:25,207 --> 00:31:28,373
and then use a mechanism like this.

00:31:28,373 --> 00:31:29,206
- [Matt] Right but MS--

00:31:29,206 --> 00:31:33,163
- After completely rewriting all the locking for that case.

00:31:33,163 --> 00:31:34,037
- I don't think you have to

00:31:34,037 --> 00:31:36,090
- Locks are all global.

00:31:36,090 --> 00:31:39,564
- It's sort of like the pivot root use case, right?

00:31:39,564 --> 00:31:42,003
So with pivot root you can probably do this.

00:31:42,003 --> 00:31:44,526
Whether it becomes useful only in that use case

00:31:44,526 --> 00:31:46,572
is a question but to blanket say

00:31:46,572 --> 00:31:48,247
you can't do it is not correct.

00:31:48,247 --> 00:31:50,095
- Yeah, I was gonna ask even if it was,

00:31:50,095 --> 00:31:52,364
let's say we can do it for the peer review case,

00:31:52,364 --> 00:31:54,570
what would be the protection?

00:31:54,570 --> 00:31:56,251
Because the networking I understand

00:31:56,251 --> 00:31:58,682
which is you don't want, for instance,

00:31:58,682 --> 00:32:01,478
packets in one namespace to be attacked with another

00:32:01,478 --> 00:32:05,074
but mounts are not secret, at least not in principle.

00:32:05,074 --> 00:32:07,345
- But in principle, once you've done pivot_root,

00:32:07,345 --> 00:32:10,081
they can be disconnected by the kernel's root namespace.

00:32:10,081 --> 00:32:13,038
If you can actually disconnect the pages as well,

00:32:13,038 --> 00:32:15,413
you can theoretically, and I don't promise you

00:32:15,413 --> 00:32:17,594
this is possible but it's an area of research,

00:32:17,594 --> 00:32:20,951
you could theoretically attach encrypted file systems

00:32:20,951 --> 00:32:23,655
to this mount namespace that may not be accessible

00:32:23,655 --> 00:32:27,059
to the main kernel itself, which would be a useful thing

00:32:27,059 --> 00:32:27,892
for system storage,

00:32:27,892 --> 00:32:30,374
secret persistent storage for container, say.

00:32:30,374 --> 00:32:31,207
- Though it might--

00:32:31,207 --> 00:32:33,655
- But big enough because you can totally access

00:32:33,655 --> 00:32:38,328
any processes root file systems through pog pid/root.

00:32:38,328 --> 00:32:39,430
- Assuming you can get,

00:32:39,430 --> 00:32:42,446
there are lots of disconnection problems that we have.

00:32:42,446 --> 00:32:44,872
We're just asking the question if we were to do

00:32:44,872 --> 00:32:46,412
all these disconnections correctly,

00:32:46,412 --> 00:32:48,186
can we get a security benefit?

00:32:48,186 --> 00:32:50,418
I'm not convinced that you would run

00:32:50,418 --> 00:32:51,920
an encrypted file system this way.

00:32:51,920 --> 00:32:53,610
I think you're much more likely to run it

00:32:53,610 --> 00:32:55,857
in some sort of microkernel where the microkernel

00:32:55,857 --> 00:32:58,014
can (coughing drowns out speaker) encryption on the pages

00:32:58,014 --> 00:33:00,628
and they we just use a standard separated address space

00:33:00,628 --> 00:33:02,256
for the result, something like that.

00:33:02,256 --> 00:33:03,760
So perhaps we would never do this

00:33:03,760 --> 00:33:05,533
but I was just pushing back on the idea

00:33:05,533 --> 00:33:07,458
that it's a prior impossible.

00:33:07,458 --> 00:33:08,291
It's not.

00:33:08,291 --> 00:33:09,472
So it's useful to research.

00:33:09,472 --> 00:33:10,879
- Yeah, I was gonna say for that use case

00:33:10,879 --> 00:33:12,300
with an encrypted file system, I imagine if

00:33:12,300 --> 00:33:15,007
a theoretical keyring namespace,

00:33:15,007 --> 00:33:18,069
and that would be more useful for that use case, I guess.

00:33:18,069 --> 00:33:19,080
- Right but we haven't.

00:33:19,080 --> 00:33:19,913
- We don't have that, right?

00:33:19,913 --> 00:33:22,190
- We have none yet so but there are namespaces

00:33:22,190 --> 00:33:23,831
that we haven't actually got in the kernel

00:33:23,831 --> 00:33:25,116
this might be useful for as well.

00:33:25,116 --> 00:33:25,949
- Yeah, okay.

00:33:25,949 --> 00:33:28,116
- Okay, we'll accept that.

00:33:30,752 --> 00:33:33,502
- Now (mumbles).

00:33:34,994 --> 00:33:37,259
The one thing I was,

00:33:37,259 --> 00:33:38,984
it seems like the overhead of this and everything

00:33:38,984 --> 00:33:41,836
and the complexity, it's almost like why aren't you

00:33:41,836 --> 00:33:43,702
just kind of like, if you maybe microkernel,

00:33:43,702 --> 00:33:46,535
make a small VM and just use that?

00:33:48,469 --> 00:33:50,344
- Eh, what's that?

00:33:50,344 --> 00:33:52,377
A VM is a LAN security model.

00:33:52,377 --> 00:33:55,139
A microkernel is on the side security model.

00:33:55,139 --> 00:33:56,729
The question we're asking with this

00:33:56,729 --> 00:34:00,229
is can we separate the execution streams of the kernel

00:34:00,229 --> 00:34:02,904
in such a way that it gains the density benefit

00:34:02,904 --> 00:34:05,607
of containers and yet has a security property.

00:34:05,607 --> 00:34:07,388
I mean, the whole premise of what are actual

00:34:07,388 --> 00:34:09,095
security benefits are right at the moment,

00:34:09,095 --> 00:34:11,589
containers get a bad rep with security

00:34:11,589 --> 00:34:13,845
because once you get into the kernel part of the container

00:34:13,845 --> 00:34:15,723
through a system call, you have access

00:34:15,723 --> 00:34:17,700
to the entirety of the system.

00:34:17,700 --> 00:34:19,724
The horizontal attack profile is wide.

00:34:19,724 --> 00:34:22,350
If we can put it into a segregated address space

00:34:22,350 --> 00:34:23,929
we might be able to reduce

00:34:23,929 --> 00:34:26,428
the horizontal attack profile theoretically.

00:34:26,428 --> 00:34:28,372
That's the security benefit we're chasing.

00:34:28,372 --> 00:34:29,955
It's all theoretical at this point.

00:34:29,955 --> 00:34:31,320
- [Man] It doesn't feel easy to do it.

00:34:31,320 --> 00:34:33,908
Another question and then, is there a performance hit

00:34:33,908 --> 00:34:35,148
when you do something like this?

00:34:35,148 --> 00:34:38,037
- We'll know in a couple of months.

00:34:38,037 --> 00:34:40,581
- But, there is because you have to change page tables

00:34:40,581 --> 00:34:43,576
as you do it but if the page table is always present

00:34:43,576 --> 00:34:46,467
and you just call it through it on the syscall,

00:34:46,467 --> 00:34:48,058
we can possibly eliminate the overhead.

00:34:48,058 --> 00:34:50,969
So there are ways of getting the page table overhead

00:34:50,969 --> 00:34:53,125
to shift and the page table overhead

00:34:53,125 --> 00:34:55,325
is a bit less than the overhead you get

00:34:55,325 --> 00:34:57,209
going through a hypercall anyway.

00:34:57,209 --> 00:34:58,042
Right?

00:34:58,042 --> 00:34:59,297
- [Man] Okay if you're able to just find a way

00:34:59,297 --> 00:35:01,957
to crash this, it still crashes the kernel, right?

00:35:01,957 --> 00:35:03,091
Or is it?

00:35:03,091 --> 00:35:06,494
- Well, if you actually bring down the CPU in something.

00:35:06,494 --> 00:35:08,023
It depends, default isolation can actually

00:35:08,023 --> 00:35:10,465
be enforced by this so it can be the same way

00:35:10,465 --> 00:35:12,541
as you get an oops in the kernel but the kernel

00:35:12,541 --> 00:35:15,378
will continue because the fault was isolated to,

00:35:15,378 --> 00:35:17,581
once you've killed all the processes in this container,

00:35:17,581 --> 00:35:19,234
the rest of the kernel can continue.

00:35:19,234 --> 00:35:21,873
So it's not impossible to get fault isolation in this way

00:35:21,873 --> 00:35:23,864
but before we get on to fault isolation,

00:35:23,864 --> 00:35:26,124
we have to have security benefits first.

00:35:26,124 --> 00:35:26,957
- [Man] Yeah.

00:35:26,957 --> 00:35:28,365
- The point of this research is to get containers

00:35:28,365 --> 00:35:30,689
that are more secure than hypervisors.

00:35:30,689 --> 00:35:33,480
So we already have that with sort of specialized containers

00:35:33,480 --> 00:35:34,849
like nabla containers.

00:35:34,849 --> 00:35:36,114
The question we're looking at here

00:35:36,114 --> 00:35:38,675
is can we apply the principles more generally.

00:35:38,675 --> 00:35:40,224
And we're not coming with answers.

00:35:40,224 --> 00:35:42,622
We're coming with mostly questions to this group.

00:35:42,622 --> 00:35:43,705
- [Man] Yeah.

00:35:44,827 --> 00:35:47,682
- So what should we, we would be also interested

00:35:47,682 --> 00:35:50,139
in the mount namespaces where the mount propagation

00:35:50,139 --> 00:35:53,060
is cut off at kind of the definition level

00:35:53,060 --> 00:35:56,277
of the mount namespace simply because, for example,

00:35:56,277 --> 00:36:00,125
we allow some customization of the environment

00:36:00,125 --> 00:36:03,134
and we do a lot of mounts in the environment of the user

00:36:03,134 --> 00:36:05,724
and we don't want for this to accidentally propagate,

00:36:05,724 --> 00:36:06,577
for example.

00:36:06,577 --> 00:36:09,908
Like, it's doable correctly without any set features

00:36:09,908 --> 00:36:11,965
on the kernel side but it makes it easier

00:36:11,965 --> 00:36:14,985
to reason and to think if you just by definition

00:36:14,985 --> 00:36:18,188
cannot get a mount out or get a mount in.

00:36:18,188 --> 00:36:21,542
- Yeah, overall what I've heard is most people

00:36:21,542 --> 00:36:24,653
prefer mount namespaces without non-propagation.

00:36:24,653 --> 00:36:27,439
And as much as we can do about that,

00:36:27,439 --> 00:36:30,435
I would say for purposes of research,

00:36:30,435 --> 00:36:33,606
mount namespace is probably not some place to look at

00:36:33,606 --> 00:36:36,543
until you've seen benefits elsewhere.

00:36:36,543 --> 00:36:39,897
- We are definitely starting with network namespace

00:36:39,897 --> 00:36:44,014
and when we get some results from our work

00:36:44,014 --> 00:36:46,959
with network namespace, we'll see where we're going to

00:36:46,959 --> 00:36:49,862
continue or we just abandon the whole thing maybe.

00:36:49,862 --> 00:36:51,305
If it will become too complex

00:36:51,305 --> 00:36:54,569
or too inefficient, so yes, we are going to drop it

00:36:54,569 --> 00:36:56,344
but if we get some good results,

00:36:56,344 --> 00:36:59,640
and I hope we will do, we'll see what next namespace

00:36:59,640 --> 00:37:02,137
is going to be and most probably it will be actually

00:37:02,137 --> 00:37:04,534
user namespace and then you have like per 10

00:37:04,534 --> 00:37:08,724
and the separation of resources and user namespace

00:37:08,724 --> 00:37:11,588
gets its own page tables and however it encourages it

00:37:11,588 --> 00:37:15,098
to get its view of the kernel memory

00:37:15,098 --> 00:37:19,169
from the owning, from the top process in the user namespace.

00:37:19,169 --> 00:37:20,929
- Yeah, to ground this where it's coming from

00:37:20,929 --> 00:37:22,918
with the nabla containers we were trying to reduce

00:37:22,918 --> 00:37:25,192
the surface area of penetration into the kernel

00:37:25,192 --> 00:37:27,634
which means reduce the horizontal attack profile.

00:37:27,634 --> 00:37:30,051
But if you look at, sort of, container sandboxes

00:37:30,051 --> 00:37:33,323
like nabla, gVisor, and all of them,

00:37:33,323 --> 00:37:35,499
they all have trouble with networking.

00:37:35,499 --> 00:37:37,116
Networking is one of the nasty things

00:37:37,116 --> 00:37:39,502
that you usually have to haul a LT tap up

00:37:39,502 --> 00:37:41,672
and then replicate the entirety of the networking

00:37:41,672 --> 00:37:44,293
in the kernel which causes you an admin problem

00:37:44,293 --> 00:37:46,309
because you've just disconnected the administration

00:37:46,309 --> 00:37:50,720
of your, sort of, sandbox network from your real network

00:37:50,720 --> 00:37:52,480
and it becomes really difficult.

00:37:52,480 --> 00:37:54,528
So the question you were asking initially is

00:37:54,528 --> 00:37:57,249
if we could isolate the kernel's networking layer

00:37:57,249 --> 00:38:00,382
in such a way that we could actually make use of it

00:38:00,382 --> 00:38:02,501
at the sort of layer seven TAP,

00:38:02,501 --> 00:38:04,026
which is where you're supposed to

00:38:04,026 --> 00:38:06,224
and therefore use all the kernel's admin structure,

00:38:06,224 --> 00:38:08,348
it would greatly simplify these sandboxes

00:38:08,348 --> 00:38:09,562
and at the same time provide

00:38:09,562 --> 00:38:11,205
an equivalent amount of protection.

00:38:11,205 --> 00:38:13,461
So part of the reason we're looking at this is

00:38:13,461 --> 00:38:16,518
if we could strengthen system calls in such a way

00:38:16,518 --> 00:38:18,665
that some are safe and some are still unsafe

00:38:18,665 --> 00:38:20,509
and then just emulate the unsafe ones

00:38:20,509 --> 00:38:23,021
in the sandbox and allow the safe ones to pass through,

00:38:23,021 --> 00:38:24,993
we're actually doing a better job of building

00:38:24,993 --> 00:38:28,206
a safer sandbox for future container technologies.

00:38:28,206 --> 00:38:30,241
So there's a lot of, sort of, thought around,

00:38:30,241 --> 00:38:32,280
it's not just about running docket containers.

00:38:32,280 --> 00:38:34,521
This is about thinking about would there be

00:38:34,521 --> 00:38:36,035
a different description of containers

00:38:36,035 --> 00:38:37,843
that we could actually make more secure.

00:38:37,843 --> 00:38:39,417
When you've already proven that we can build

00:38:39,417 --> 00:38:41,078
specialized containers like nabla

00:38:41,078 --> 00:38:44,063
that have security properties that are about twice

00:38:44,063 --> 00:38:45,680
as good as that of a hypervisor.

00:38:45,680 --> 00:38:47,748
So we've cracked the goal of making a container

00:38:47,748 --> 00:38:49,350
that's more secure than a hypervisor.

00:38:49,350 --> 00:38:51,231
The question is can we bring the benefits

00:38:51,231 --> 00:38:53,149
of the technology globally which is,

00:38:53,149 --> 00:38:58,149
that's the background rationale for looking at all of this.

00:38:58,413 --> 00:38:59,911
- I guess big question,

00:38:59,911 --> 00:39:04,569
what are the attacks you're looking to guard against

00:39:04,569 --> 00:39:07,089
with these address spaces?

00:39:07,089 --> 00:39:09,383
Is it primarily speculative execution

00:39:09,383 --> 00:39:11,253
or are you looking primarily at something else?

00:39:11,253 --> 00:39:12,753
- No, it's actually not related

00:39:12,753 --> 00:39:14,877
to speculative execution because--

00:39:14,877 --> 00:39:16,365
- Well, it's basically,

00:39:16,365 --> 00:39:18,747
so the glib answer is everything.

00:39:18,747 --> 00:39:23,137
But the point is that if we can do default domain isolation

00:39:23,137 --> 00:39:26,521
where the consequences of exploiting

00:39:26,521 --> 00:39:28,703
only reflect back on the user because

00:39:28,703 --> 00:39:32,128
of the address space separation, that exploit effectively

00:39:32,128 --> 00:39:35,580
becomes unusable because you can't use it to break out

00:39:35,580 --> 00:39:37,131
into the rest of the kernel.

00:39:37,131 --> 00:39:40,017
So if we can do that with significant classes of bugs,

00:39:40,017 --> 00:39:42,070
we've got a guarding interface that renders

00:39:42,070 --> 00:39:45,367
a container much safer than it was previously.

00:39:45,367 --> 00:39:48,461
And so, it's all about class elimination of faults.

00:39:48,461 --> 00:39:50,137
The big problem we have in research

00:39:50,137 --> 00:39:52,870
is that we can measure horizontal attack profile

00:39:52,870 --> 00:39:55,187
in terms of sort of traversal through the kernel

00:39:55,187 --> 00:39:56,897
and we can easily measure that

00:39:56,897 --> 00:39:58,508
with ftrace or something else.

00:39:58,508 --> 00:40:02,548
We have no means of measuring class of bug elimination

00:40:02,548 --> 00:40:04,943
by techniques like Lysio.

00:40:04,943 --> 00:40:06,526
We don't know how much it contributes

00:40:06,526 --> 00:40:08,798
to the security of the container.

00:40:08,798 --> 00:40:10,922
So that's actually another ongoing area of research

00:40:10,922 --> 00:40:15,922
to see if we can actually get a decent measurement for this.

00:40:17,920 --> 00:40:20,283
- More questions about this bullet?

00:40:20,283 --> 00:40:22,236
Okay, so I'll give (mumbles) second one

00:40:22,236 --> 00:40:24,583
it seems like pretty much obvious

00:40:24,583 --> 00:40:29,523
and how to handle namespaces with different page tables.

00:40:29,523 --> 00:40:31,530
As long as you're nesting with namespaces,

00:40:31,530 --> 00:40:33,142
you restrict macros more and more

00:40:33,142 --> 00:40:35,446
and probably the most obvious way to go

00:40:35,446 --> 00:40:37,832
unless we see from something else.

00:40:37,832 --> 00:40:40,154
So if you have user namespace,

00:40:40,154 --> 00:40:43,015
it has a restricted page table and the network namespace

00:40:43,015 --> 00:40:46,827
has even more restricted page table and so on and so on.

00:40:46,827 --> 00:40:50,000
The idea, at least for now, we'll plan it out again

00:40:50,000 --> 00:40:55,000
in a couple of months how it may be used and enabled.

00:40:55,221 --> 00:40:58,971
So next question is more, suppose we can have

00:41:00,094 --> 00:41:02,655
this marriage between address spaces and namespaces,

00:41:02,655 --> 00:41:05,602
do we need any special ABI for this?

00:41:05,602 --> 00:41:08,390
Is on off on kernel command line is enough

00:41:08,390 --> 00:41:11,533
or we need a sysfs, proc or something?

00:41:11,533 --> 00:41:15,783
Or address space, namespace or something like that?

00:41:17,986 --> 00:41:20,810
- As far as the user interface and how you turned

00:41:20,810 --> 00:41:23,326
off and on, that's all going to depend

00:41:23,326 --> 00:41:25,243
on what the overhead is

00:41:26,977 --> 00:41:31,006
and what the benefits, what the cost are

00:41:31,006 --> 00:41:32,741
and we don't know those so we don't--

00:41:32,741 --> 00:41:33,574
- [Man] Yeah.

00:41:33,574 --> 00:41:35,732
- So, at this point, do whatever's easy

00:41:35,732 --> 00:41:37,243
for your development.

00:41:37,243 --> 00:41:39,187
- At this point, always on.

00:41:39,187 --> 00:41:40,079
It's not a question.

00:41:40,079 --> 00:41:40,912
(laughing)

00:41:40,912 --> 00:41:42,482
- Yeah.

00:41:42,482 --> 00:41:46,072
- But anyway, we need to keep in mind that even

00:41:46,072 --> 00:41:49,106
for the development that it should be at least

00:41:49,106 --> 00:41:51,757
one global off for the entire thing

00:41:51,757 --> 00:41:54,848
that brings the system performance back to normal

00:41:54,848 --> 00:41:56,961
and even if we have some overhead,

00:41:56,961 --> 00:41:58,211
even if we have

00:42:00,835 --> 00:42:05,835
a significant overhead if we do good security improvement

00:42:06,404 --> 00:42:08,880
probably it's worth it.

00:42:08,880 --> 00:42:11,335
So, this moral should be the case

00:42:11,335 --> 00:42:15,162
when you can completely turn it off and get back to normal

00:42:15,162 --> 00:42:17,974
and then call overhead will be like a payment

00:42:17,974 --> 00:42:19,807
for improved security.

00:42:22,903 --> 00:42:25,189
- Your suggestion, I think sort of like

00:42:25,189 --> 00:42:28,513
your namespace suggestion, it might be worth looking

00:42:28,513 --> 00:42:31,846
at this per user of the machine as well.

00:42:33,437 --> 00:42:35,783
- [Man] So user namespace is just per user.

00:42:35,783 --> 00:42:37,483
- Per user.

00:42:37,483 --> 00:42:38,316
You know?

00:42:39,413 --> 00:42:40,937
- As a specialized kernel, sorry.

00:42:40,937 --> 00:42:42,935
A specialized kernel address space per user.

00:42:42,935 --> 00:42:44,606
We have actually thought about doing that

00:42:44,606 --> 00:42:46,933
but we have no mechanism to hang it off yet.

00:42:46,933 --> 00:42:48,521
- [Man] Okay.

00:42:48,521 --> 00:42:49,354
Yeah.

00:42:54,088 --> 00:42:56,952
- Yeah, I was gonna suggest, I mean,

00:42:56,952 --> 00:42:59,296
to me at least a user namespace seems like

00:42:59,296 --> 00:43:01,993
it would be the obvious though probably not

00:43:01,993 --> 00:43:04,490
the best solution because user namespaces are used

00:43:04,490 --> 00:43:06,880
for privilege separation, not just for UIDs

00:43:06,880 --> 00:43:08,991
but also for a variety of other things.

00:43:08,991 --> 00:43:11,126
And so, it might make sense to pitch into this

00:43:11,126 --> 00:43:12,900
though I have heard people complain about the fact

00:43:12,900 --> 00:43:14,992
that there are too many things pinned to user namespaces

00:43:14,992 --> 00:43:16,868
that might also be a counter argument as well.

00:43:16,868 --> 00:43:18,292
- Well that's docket people because they still

00:43:18,292 --> 00:43:19,295
don't damn well use it.

00:43:19,295 --> 00:43:20,871
Can you just fix that please?

00:43:20,871 --> 00:43:21,704
- Yes.

00:43:21,704 --> 00:43:22,537
(laughing)

00:43:22,537 --> 00:43:26,082
I'm no representative for a certain whaling company.

00:43:26,082 --> 00:43:27,694
- So since we are running out of time,

00:43:27,694 --> 00:43:30,470
the last thing to conclude is the major question here

00:43:30,470 --> 00:43:32,458
is what is the actual security benefit

00:43:32,458 --> 00:43:34,198
and how do we measure it?

00:43:34,198 --> 00:43:36,330
And, until we know the answer to that question

00:43:36,330 --> 00:43:39,274
we probably won't know the answers to the other ones

00:43:39,274 --> 00:43:43,435
and we probably won't be able to correctly estimate

00:43:43,435 --> 00:43:46,039
what should be done in this area.

00:43:46,039 --> 00:43:48,512
So, thank you everybody.

00:43:48,512 --> 00:43:51,512
(audience clapping)

00:44:01,159 --> 00:44:04,742
(people chattering softly)

00:44:49,608 --> 00:44:54,191
(background noise drowns out speakers)

00:45:01,122 --> 00:45:04,705
(people chattering softly)

00:45:29,130 --> 00:45:30,130
- Of course.

00:45:37,841 --> 00:45:39,357
One second.

00:45:39,357 --> 00:45:41,072
No, no, no it's,

00:45:41,072 --> 00:45:44,078
this was probably my mistake.

00:45:44,078 --> 00:45:47,661
(people chattering softly)

00:45:55,249 --> 00:45:58,166
(man sighs loudly)

00:46:01,058 --> 00:46:01,891
Sway and.

00:46:04,818 --> 00:46:05,685
- There you go.

00:46:05,685 --> 00:46:08,115
- Sorry, I was just,

00:46:08,115 --> 00:46:09,365
me being silly.

00:46:11,170 --> 00:46:12,003
Right.

00:46:14,853 --> 00:46:15,686
Okay.

00:46:18,717 --> 00:46:22,820
Sorry, it took a while longer but, okay,

00:46:22,820 --> 00:46:25,216
so this is an update on what we did

00:46:25,216 --> 00:46:27,685
with the seccomp notifier fd,

00:46:27,685 --> 00:46:30,352
which we presented on last year.

00:46:31,628 --> 00:46:34,116
So, for everyone who's not in the picture,

00:46:34,116 --> 00:46:36,790
what you can basically do if you're at task

00:46:36,790 --> 00:46:39,159
and you're loading a seccomp filter

00:46:39,159 --> 00:46:42,006
you can get an fd for the seccomp filter

00:46:42,006 --> 00:46:45,794
which you can then hand off to a different process.

00:46:45,794 --> 00:46:47,893
And, for usually a more privileged process

00:46:47,893 --> 00:46:50,275
such as a container manager and the container manager

00:46:50,275 --> 00:46:54,184
can then receive events based on the filter

00:46:54,184 --> 00:46:57,588
that you registered for the task,

00:46:57,588 --> 00:47:00,553
on what syscall the task makes.

00:47:00,553 --> 00:47:05,200
And the idea being that we would be able to perform

00:47:05,200 --> 00:47:08,277
certain operations that containers, unprivileged containers

00:47:08,277 --> 00:47:11,389
and user namespaces would normally not be able to do

00:47:11,389 --> 00:47:15,141
for them, the container manager would be able

00:47:15,141 --> 00:47:16,441
to do them for them.

00:47:16,441 --> 00:47:19,801
Classic example is mknod in containers,

00:47:19,801 --> 00:47:23,177
in user namespaces, sorry, doesn't work

00:47:23,177 --> 00:47:25,451
for character devices and blocked devices.

00:47:25,451 --> 00:47:29,089
It obviously works for sockets and FIFOs.

00:47:29,089 --> 00:47:31,731
So, but there's a bunch of devices

00:47:31,731 --> 00:47:33,883
that every container uses.

00:47:33,883 --> 00:47:37,099
Usually that we already bind mount in from the host,

00:47:37,099 --> 00:47:42,099
/dev/urandom, /dev/random, /dev/null, /dev/zero and so on.

00:47:42,372 --> 00:47:45,273
And such devices would be safe to create.

00:47:45,273 --> 00:47:48,224
So if you do anything inside of the container

00:47:48,224 --> 00:47:50,211
does a mknod call and you would be able

00:47:50,211 --> 00:47:54,294
to somehow detect that this is a valid mknod call

00:47:55,133 --> 00:47:58,699
for a device that you'll find that the container creates

00:47:58,699 --> 00:48:01,796
then you, the container manager in this scenario,

00:48:01,796 --> 00:48:05,463
could perform the syscall for the container.

00:48:06,298 --> 00:48:11,298
So you basically have a whitelist of valid devices.

00:48:11,366 --> 00:48:13,840
So, how exactly does this work?

00:48:13,840 --> 00:48:16,950
Well, you get a second notification.

00:48:16,950 --> 00:48:18,117
You can stuff dfd.

00:48:18,117 --> 00:48:20,214
You got into an epoll loop.

00:48:20,214 --> 00:48:21,920
You get notified when the container

00:48:21,920 --> 00:48:25,381
makes a relevant syscall, in this scenario a mknod syscall

00:48:25,381 --> 00:48:27,809
for a specific type of device.

00:48:27,809 --> 00:48:30,210
Then you can do an ioctl on, sorry,

00:48:30,210 --> 00:48:35,210
you can do an ioctl on this fd and read the seccomp data

00:48:35,237 --> 00:48:38,465
from it that you usually get with seccomp.

00:48:38,465 --> 00:48:41,298
You also get a pid for the process

00:48:43,082 --> 00:48:46,493
which make the syscall and you get a cookie NID,

00:48:46,493 --> 00:48:51,243
which allows you to verify that if a task is still valid.

00:48:52,465 --> 00:48:55,032
So, for example, you could then use the pid

00:48:55,032 --> 00:48:58,214
to open /proc/pid/mem,

00:48:58,214 --> 00:49:00,345
to like read the memory of the syscall

00:49:00,345 --> 00:49:05,051
that was made to inspect pointer arguments and so on.

00:49:05,051 --> 00:49:07,435
And if you open, there is obviously a race here.

00:49:07,435 --> 00:49:10,076
So the process could go away in the meantime

00:49:10,076 --> 00:49:12,625
and could be recycled and then you would open

00:49:12,625 --> 00:49:14,162
the wrong prop pid mem.

00:49:14,162 --> 00:49:16,472
This is where you can use the cookie.

00:49:16,472 --> 00:49:17,812
You basically open the fd.

00:49:17,812 --> 00:49:19,615
You then send the cookie back into the kernel

00:49:19,615 --> 00:49:21,400
which is also an ioctl and ask the kernel,

00:49:21,400 --> 00:49:23,187
is this task still valid?

00:49:23,187 --> 00:49:24,320
Is this still a valid cookie?

00:49:24,320 --> 00:49:25,999
And the kernel then tells you, yes, it's still valid

00:49:25,999 --> 00:49:27,983
or it tells you it's not valid anymore

00:49:27,983 --> 00:49:30,761
and then you can look at the syscall arguments

00:49:30,761 --> 00:49:35,761
in way more detail than currently seccomp allows you to do.

00:49:36,115 --> 00:49:39,586
So, I can give you a quick illustration hopefully

00:49:39,586 --> 00:49:41,086
on how this works.

00:49:45,665 --> 00:49:46,498
A, yeah.

00:49:48,798 --> 00:49:50,597
Oh yeah, yeah, I know.

00:49:50,597 --> 00:49:51,430
Sorry.

00:49:56,558 --> 00:49:58,296
(man mumbling)

00:49:58,296 --> 00:50:00,129
Yeah, in a little bit.

00:50:04,203 --> 00:50:05,097
Is this better?

00:50:05,097 --> 00:50:06,778
Can you read it in the back or should I go on?

00:50:06,778 --> 00:50:08,364
- [Man] More.

00:50:08,364 --> 00:50:09,947
- [Presenter] Okay.

00:50:11,373 --> 00:50:12,385
- [Man] Yup, yup.

00:50:12,385 --> 00:50:13,885
- [Presenter] Yes?

00:50:16,775 --> 00:50:21,275
This is just a container which is in a user namespace.

00:50:26,203 --> 00:50:27,977
And so, if you, for example,

00:50:27,977 --> 00:50:29,479
let me see right here.

00:50:29,479 --> 00:50:33,312
If you do mknod, random name, character device

00:50:34,173 --> 00:50:36,312
five, one, which is def counsel,

00:50:36,312 --> 00:50:38,963
you get operation not permitted.

00:50:38,963 --> 00:50:39,819
Right?

00:50:39,819 --> 00:50:42,773
And so, we can turn on the options

00:50:42,773 --> 00:50:45,407
for the seccomp listener.

00:50:45,407 --> 00:50:47,285
Stefan, do you have them in mind?

00:50:47,285 --> 00:50:48,118
(laughing)

00:50:48,118 --> 00:50:52,057
- [Stefan] Yes, config set, name of container.

00:50:52,057 --> 00:50:54,446
- [Presenter] Uh, B two.

00:50:54,446 --> 00:50:59,446
- [Stefan] And security dot syscall dot interceptor mknod.

00:50:59,767 --> 00:51:01,097
No, intercept.

00:51:01,097 --> 00:51:03,097
- [Presenter] Ah, right.

00:51:04,353 --> 00:51:06,936
(man mumbling)

00:51:08,765 --> 00:51:12,870
- [Stefan] In syscalls, I think there's an S.

00:51:12,870 --> 00:51:13,884
- [Presenter] Right.

00:51:13,884 --> 00:51:15,212
- [Stefan] Okay and then you need to accept.

00:51:15,212 --> 00:51:16,686
- [Man] That means tab completion.

00:51:16,686 --> 00:51:19,584
- [Stefan] It does have tab completion.

00:51:19,584 --> 00:51:21,917
- [Presenter] So is this a--

00:51:23,742 --> 00:51:25,412
- [Man] What did you do?

00:51:25,412 --> 00:51:27,955
(people laughing)

00:51:27,955 --> 00:51:29,854
- [Presenter] That's odd.

00:51:29,854 --> 00:51:31,802
Yeah well in any case.

00:51:31,802 --> 00:51:33,073
I would like to give a demo

00:51:33,073 --> 00:51:36,990
but apparently my kernel doesn't like me today.

00:51:38,066 --> 00:51:40,884
- [Man] Yeah you can do an LXC info

00:51:40,884 --> 00:51:43,217
and it's gonna tell you why.

00:51:44,738 --> 00:51:46,289
Oh, yeah, okay.

00:51:46,289 --> 00:51:48,456
(mumbles)

00:51:51,937 --> 00:51:55,104
(man speaking softly)

00:51:59,085 --> 00:52:01,401
- [Presenter] Oh so it's probably the LXC.

00:52:01,401 --> 00:52:02,306
It doesn't matter.

00:52:02,306 --> 00:52:03,908
I can recompile if you still--

00:52:03,908 --> 00:52:04,741
- [Man] I'll give you (mumbles).

00:52:04,741 --> 00:52:06,367
- Yeah, if we still have enough time.

00:52:06,367 --> 00:52:08,776
In any case, sorry for that.

00:52:08,776 --> 00:52:10,596
It works fine, you can trust me.

00:52:10,596 --> 00:52:13,429
(people laughing)

00:52:15,222 --> 00:52:17,809
- Yeah to get it to actually work you need,

00:52:17,809 --> 00:52:18,696
you've got the right kernel

00:52:18,696 --> 00:52:21,719
but you also need a yet to be released pid seccomp,

00:52:21,719 --> 00:52:23,472
which is probably the issue here.

00:52:23,472 --> 00:52:25,310
You're probably running stock seccomp

00:52:25,310 --> 00:52:27,619
and things are not happy then.

00:52:27,619 --> 00:52:31,252
- Yeah, exactly, there's no released seccomp version

00:52:31,252 --> 00:52:32,197
with this right now.

00:52:32,197 --> 00:52:34,084
It's probably the issue.

00:52:34,084 --> 00:52:36,193
In any case, so the problem right now

00:52:36,193 --> 00:52:38,787
is for mknod, this works really well, right?

00:52:38,787 --> 00:52:41,649
Because as I said, for all mknod devices,

00:52:41,649 --> 00:52:44,265
you cannot create them at all

00:52:44,265 --> 00:52:47,432
and also the syscall is really easy to allow you

00:52:47,432 --> 00:52:50,394
for, to lend itself to filtering, right?

00:52:50,394 --> 00:52:53,282
You can filter on the device number of the mknod syscalls.

00:52:53,282 --> 00:52:54,782
If we look at the,

00:53:02,975 --> 00:53:04,892
so right here you have,

00:53:06,185 --> 00:53:09,422
you have the mode argument and you have the device argument

00:53:09,422 --> 00:53:11,530
and you can register seccomp filter already

00:53:11,530 --> 00:53:14,344
that is pretty elaborate that would filter only,

00:53:14,344 --> 00:53:16,209
for example, for character devices

00:53:16,209 --> 00:53:18,758
and for specific device numbers and you would not

00:53:18,758 --> 00:53:21,376
get any notifications for any other mknod syscalls.

00:53:21,376 --> 00:53:23,916
The kernel would let all of the syscalls

00:53:23,916 --> 00:53:25,732
that you're interesting in through

00:53:25,732 --> 00:53:27,650
but it will only get you notification, for example,

00:53:27,650 --> 00:53:32,583
character devices which match a certain device number.

00:53:32,583 --> 00:53:34,762
And then you can also, if you're interested in this

00:53:34,762 --> 00:53:37,866
you can parcel out the path name and so on

00:53:37,866 --> 00:53:39,811
to know where you are actually supposed to create

00:53:39,811 --> 00:53:42,107
the device and then create the mknod device

00:53:42,107 --> 00:53:43,607
for the container.

00:53:44,491 --> 00:53:46,378
The problem is this is obviously not doable

00:53:46,378 --> 00:53:48,536
for a bunch more syscalls.

00:53:48,536 --> 00:53:51,869
So, for example, let's look at setxattr.

00:53:53,571 --> 00:53:56,985
Setxattr has a path argument, a name argument,

00:53:56,985 --> 00:54:00,011
and a value argument, and a size argument and flags

00:54:00,011 --> 00:54:02,814
and for a lot of interesting setxattr calls,

00:54:02,814 --> 00:54:06,733
so, for example, currently overlay, I think,

00:54:06,733 --> 00:54:09,294
on some systems if it creates whiteouts,

00:54:09,294 --> 00:54:12,043
it creates a file that is called overlay

00:54:12,043 --> 00:54:15,539
dot blah, blah, blah dot whiteout and we would like

00:54:15,539 --> 00:54:18,790
to succeed that, have that succeed inside of containers

00:54:18,790 --> 00:54:20,603
so that you, for example, can run Docker

00:54:20,603 --> 00:54:21,592
and there and so on.

00:54:21,592 --> 00:54:23,594
So this is want you want to intercept.

00:54:23,594 --> 00:54:25,451
The problem is filtering becomes really tricky

00:54:25,451 --> 00:54:28,302
because you need to filter the name of the argument

00:54:28,302 --> 00:54:32,468
and the value of the argument ideally in some circumstances.

00:54:32,468 --> 00:54:34,460
So, you kind of end up with a filter

00:54:34,460 --> 00:54:36,377
that sort of catches everything.

00:54:36,377 --> 00:54:38,863
You get all of the notifications for,

00:54:38,863 --> 00:54:42,239
or a lot of notifications for the setxattr system call

00:54:42,239 --> 00:54:43,543
but yes?

00:54:43,543 --> 00:54:44,376
- [Man] 10 minutes.

00:54:44,376 --> 00:54:45,209
- Oh, okay.

00:54:45,209 --> 00:54:47,442
For the setxattr system call.

00:54:47,442 --> 00:54:48,400
And the problem with this

00:54:48,400 --> 00:54:49,990
is a bunch of those already succeed.

00:54:49,990 --> 00:54:53,411
So for example, every setxattr for the user namespace,

00:54:53,411 --> 00:54:55,129
user dot something, something,

00:54:55,129 --> 00:54:58,400
would totally succeed and the problem is now

00:54:58,400 --> 00:55:00,365
you've put the burden on the container manager

00:55:00,365 --> 00:55:03,468
or the listnet to create all of, to do all of those syscalls

00:55:03,468 --> 00:55:06,242
in lieu of the container because there is no way

00:55:06,242 --> 00:55:08,995
to either do deep pointer inspection,

00:55:08,995 --> 00:55:10,183
deep argument inspection.

00:55:10,183 --> 00:55:11,616
Yes?

00:55:11,616 --> 00:55:14,349
- [Man] So this is supposed to be like,

00:55:14,349 --> 00:55:16,777
you were trying to do some sort of access control

00:55:16,777 --> 00:55:20,282
and you're proxying, you're letting the privileged process

00:55:20,282 --> 00:55:22,832
do the stuff that the container not do, right?

00:55:22,832 --> 00:55:23,665
- Right.

00:55:23,665 --> 00:55:24,624
- What do you think about,

00:55:24,624 --> 00:55:27,175
and I know we've talked about the LSM that I'm working on

00:55:27,175 --> 00:55:31,699
where you can attach EBPF programs to a lesson hooks.

00:55:31,699 --> 00:55:32,864
Could this be something we could do

00:55:32,864 --> 00:55:35,333
as a part of that and do a deep argument inspection

00:55:35,333 --> 00:55:36,250
there and--

00:55:37,513 --> 00:55:39,550
- There was a session about this yesterday

00:55:39,550 --> 00:55:41,395
where we talked about deep argument inspection

00:55:41,395 --> 00:55:44,645
for seccomp where this came up as well.

00:55:45,636 --> 00:55:48,198
It's controversial in the sense that

00:55:48,198 --> 00:55:50,141
because you need an unprivileged LSM

00:55:50,141 --> 00:55:52,932
and whether we unprivilege EBFP LSM

00:55:52,932 --> 00:55:55,799
in this specific scenario and it's unclear

00:55:55,799 --> 00:55:58,854
whether this is ever going to happen because of reservations

00:55:58,854 --> 00:56:03,771
from the EBPF maintainers and also from the LSM maintainers

00:56:05,825 --> 00:56:08,224
who don't want to expose too much internals

00:56:08,224 --> 00:56:09,151
for the LSM hooks.

00:56:09,151 --> 00:56:12,350
So there's a bunch of issues.

00:56:12,350 --> 00:56:14,509
- Also the issue of like we want some

00:56:14,509 --> 00:56:17,323
of that filtering to be at the seccomp layer

00:56:17,323 --> 00:56:19,430
which is before the LSM hooks.

00:56:19,430 --> 00:56:21,464
You might, we actually have cases where,

00:56:21,464 --> 00:56:23,639
because we've played with that feature quite a bit.

00:56:23,639 --> 00:56:25,748
We totally implement syscall as a not exist

00:56:25,748 --> 00:56:26,581
in Linux kernel.

00:56:26,581 --> 00:56:28,706
And it's perfectly fine 'cause we can do it.

00:56:28,706 --> 00:56:31,211
Seccomp doesn't know yet if the syscall exist or not.

00:56:31,211 --> 00:56:32,985
We can just update and go to userspace

00:56:32,985 --> 00:56:34,953
and pretend it does.

00:56:34,953 --> 00:56:37,324
- So I can ask the reverse question?

00:56:37,324 --> 00:56:39,993
What about looking at mknod itself?

00:56:39,993 --> 00:56:41,434
Right at the moment the reason it doesn't work

00:56:41,434 --> 00:56:43,145
is because once you enter a user namespace,

00:56:43,145 --> 00:56:44,180
it's not ns capable.

00:56:44,180 --> 00:56:47,080
It's capable so you're incapable of making any node.

00:56:47,080 --> 00:56:49,721
If we relax that and allowed the making

00:56:49,721 --> 00:56:51,945
of specific nodes that could be set by root

00:56:51,945 --> 00:56:53,760
for which we had a whitelist in the kernel,

00:56:53,760 --> 00:56:54,993
wouldn't it obviate all of this?

00:56:54,993 --> 00:56:57,176
Unless you have a real need for--

00:56:57,176 --> 00:56:58,413
- [Presenter] First of all--

00:56:58,413 --> 00:57:00,607
- For mknod, it's true, it works.

00:57:00,607 --> 00:57:01,445
- There is a bunch more.

00:57:01,445 --> 00:57:04,076
There is a bunch more syscalls where we can do this.

00:57:04,076 --> 00:57:08,193
Also, having the whitelist in kernel was frowned upon.

00:57:08,193 --> 00:57:09,646
Just whitelisting a bunch of devices,

00:57:09,646 --> 00:57:11,897
I've never heard that being acceptable but, huh?

00:57:11,897 --> 00:57:13,198
(man speaking softly)

00:57:13,198 --> 00:57:15,047
In ID module there is a, sorry.

00:57:15,047 --> 00:57:16,127
- [Man] Well, you can just say it but--

00:57:16,127 --> 00:57:17,438
(background noise drowns out speaker)

00:57:17,438 --> 00:57:18,766
- There's a bunch of other syscalls.

00:57:18,766 --> 00:57:20,640
There's a bunch of other syscalls.

00:57:20,640 --> 00:57:21,473
Yeah, exactly.

00:57:21,473 --> 00:57:25,352
One of part of the solution that it could probably

00:57:25,352 --> 00:57:27,531
be done relatively cheaply that,

00:57:27,531 --> 00:57:31,246
at least seccomp maintainers haven't been opposed to,

00:57:31,246 --> 00:57:35,764
is to be able to tell the kernel to resume a syscall.

00:57:35,764 --> 00:57:38,874
So, you inspect the, whatever syscall you intercepted

00:57:38,874 --> 00:57:41,965
that you're interested in and if you know

00:57:41,965 --> 00:57:43,878
that it would succeed anyway, the kernel

00:57:43,878 --> 00:57:48,878
would let you do it and you just would let it pass through.

00:57:49,224 --> 00:57:50,057
Yes?

00:57:50,057 --> 00:57:52,437
- But I was a bit confused by why

00:57:52,437 --> 00:57:54,073
this needs unprivileged PBF though

00:57:54,073 --> 00:57:56,966
because if you have a central LSM that does take care

00:57:56,966 --> 00:57:59,186
of the MAC policy for your mknod syscalls,

00:57:59,186 --> 00:58:01,289
you could have a whitelist as a part of the EPBF program

00:58:01,289 --> 00:58:05,426
that is checked in the mknod hook in the kernel

00:58:05,426 --> 00:58:08,031
and you can check whether this container is allowed

00:58:08,031 --> 00:58:10,096
to make mknod for this particular device, right?

00:58:10,096 --> 00:58:12,320
- [Man] We nest containers.

00:58:12,320 --> 00:58:14,495
- [Presenter] Yes.

00:58:14,495 --> 00:58:16,728
- We run Docker inside LXD, for example.

00:58:16,728 --> 00:58:17,561
- [Man] Okay.

00:58:17,561 --> 00:58:20,066
- At which point the host of the Docker container

00:58:20,066 --> 00:58:21,301
is an unprivileged container itself

00:58:21,301 --> 00:58:23,459
so it can't do anything privileged.

00:58:23,459 --> 00:58:24,752
- [Man] Okay, okay.

00:58:24,752 --> 00:58:25,585
- Exactly.

00:58:25,585 --> 00:58:28,716
There is also no, one should also note that

00:58:28,716 --> 00:58:30,607
at the beginning we worked under the assumption

00:58:30,607 --> 00:58:33,720
that we need deep argument inspection

00:58:33,720 --> 00:58:35,155
in a very generic way.

00:58:35,155 --> 00:58:38,881
Ideally, for example, for seccomp or not necessarily seccomp

00:58:38,881 --> 00:58:41,464
or an EPBF LSM for all syscalls

00:58:42,691 --> 00:58:46,255
and I think we slowly have come to the agreement,

00:58:46,255 --> 00:58:48,874
especially in the case summit session yesterday

00:58:48,874 --> 00:58:51,842
that this is actually not what we want or what we need.

00:58:51,842 --> 00:58:54,909
We don't need, like, we don't need path-based filtering,

00:58:54,909 --> 00:58:56,936
for example for syscalls from,

00:58:56,936 --> 00:58:58,786
that's LSM territory and you want to filter

00:58:58,786 --> 00:59:00,007
on kernel objects anyway.

00:59:00,007 --> 00:59:01,565
You don't wanna filter on string set

00:59:01,565 --> 00:59:03,332
and get turned into other objects

00:59:03,332 --> 00:59:05,570
and in the meantime, the meeting of the path

00:59:05,570 --> 00:59:07,701
and the relation to the kernel object might change

00:59:07,701 --> 00:59:09,007
and so on.

00:59:09,007 --> 00:59:10,799
But, for example, where it would make sense

00:59:10,799 --> 00:59:13,432
is the obvious candidates and I'm partially to blame

00:59:13,432 --> 00:59:15,907
for this, this is why I also had the K summit discussion

00:59:15,907 --> 00:59:18,460
is clone3, for example, where you have the flag argument

00:59:18,460 --> 00:59:21,549
and the struct or openat2 where you have the flag argument

00:59:21,549 --> 00:59:22,947
and the struct.

00:59:22,947 --> 00:59:26,020
Two, or yeah, for those kinds of things where you also,

00:59:26,020 --> 00:59:27,673
where you have a struct where it makes

00:59:27,673 --> 00:59:30,249
totally sense to filter on it, we could, for example,

00:59:30,249 --> 00:59:32,285
come up with the framework where you mark a syscall

00:59:32,285 --> 00:59:33,603
as filterable.

00:59:33,603 --> 00:59:35,606
Then you copy the arguments and then you have to do

00:59:35,606 --> 00:59:38,768
the seccomp deep syscall filtering

00:59:38,768 --> 00:59:43,425
and these are, I think, relatively low hanging fruit.

00:59:43,425 --> 00:59:44,486
- Okay.

00:59:44,486 --> 00:59:46,041
That's gonna be it for this one.

00:59:46,041 --> 00:59:47,835
We've got to switch to the next topic.

00:59:47,835 --> 00:59:50,089
But, I'm sure we'll be talking a lot more

00:59:50,089 --> 00:59:54,140
about seccomp later (mumbles).

00:59:54,140 --> 00:59:54,973
- Thank you.

00:59:54,973 --> 00:59:57,973
(audience clapping)

01:00:07,398 --> 01:00:10,981
(people chattering softly)

01:00:39,709 --> 01:00:41,663
- Okay, I can give you the handheld one.

01:00:41,663 --> 01:00:43,080
It's right there.

01:00:43,943 --> 01:00:47,526
(people chattering softly)

01:01:49,901 --> 01:01:52,394
Yeah, this one's working fine.

01:01:52,394 --> 01:01:54,323
(people chattering softly)

01:01:54,323 --> 01:01:56,462
Oh yeah, you can probably just use this one for now

01:01:56,462 --> 01:01:57,665
until he fixes you.

01:01:57,665 --> 01:01:59,029
Oh, try again.

01:01:59,029 --> 01:01:59,960
- Can you hear me now?

01:01:59,960 --> 01:02:02,129
Oh, I guess it's good.

01:02:02,129 --> 01:02:02,962
Okay.

01:02:07,634 --> 01:02:09,186
So, hello everybody.

01:02:09,186 --> 01:02:10,019
Oh.

01:02:11,911 --> 01:02:13,659
Hello everybody.

01:02:13,659 --> 01:02:17,068
My name is Kamil Yurtsever and I will talk about

01:02:17,068 --> 01:02:18,635
task migration at Google

01:02:18,635 --> 01:02:21,635
together with Michal Clapinski here.

01:02:24,370 --> 01:02:28,953
So, Google started using CRIU for migration around 2018

01:02:30,706 --> 01:02:35,706
and we actually have presented to Linux Plumbers last year.

01:02:35,761 --> 01:02:40,429
This presentation will go over the improvements,

01:02:40,429 --> 01:02:43,659
our contributions and issues and concerns

01:02:43,659 --> 01:02:47,159
as we have encountered over the last year.

01:02:50,169 --> 01:02:51,720
So, one of the important,

01:02:51,720 --> 01:02:56,106
we have a few assumptions when running CRIU.

01:02:56,106 --> 01:02:59,356
One, we don't want to run CRIU as root.

01:03:01,113 --> 01:03:05,113
CRIU has a very big attack surface for the user.

01:03:07,235 --> 01:03:11,060
It, like, touches very exotic system calls,

01:03:11,060 --> 01:03:14,310
inspects all of the user process state,

01:03:15,253 --> 01:03:16,086
and it's,

01:03:18,364 --> 01:03:20,672
because of this it's prone for exploits.

01:03:20,672 --> 01:03:23,074
The easiest way to get to root of the problem

01:03:23,074 --> 01:03:28,074
is to simply run CRIU with the same privileges as user,

01:03:28,275 --> 01:03:30,163
which way you don't have to worry about

01:03:30,163 --> 01:03:32,413
any exploit affecting CRIU.

01:03:34,011 --> 01:03:35,655
Another assumption is that--

01:03:35,655 --> 01:03:37,105
- Just so I'm,

01:03:37,105 --> 01:03:40,017
can I have the microphone?

01:03:40,017 --> 01:03:43,396
Just so I'm clear, your worry is that the process

01:03:43,396 --> 01:03:46,310
being migrated could leak back into CRIU

01:03:46,310 --> 01:03:47,801
and then cause a security breach?

01:03:47,801 --> 01:03:48,651
- Exactly.

01:03:48,651 --> 01:03:50,151
- Okay, thank you.

01:03:52,767 --> 01:03:56,215
- So, the second assumption which partly comes

01:03:56,215 --> 01:03:59,743
from the fact that we don't want CRIU running as root

01:03:59,743 --> 01:04:02,066
is that we don't want to migrate the namespaces.

01:04:02,066 --> 01:04:03,649
The namespaces are,

01:04:05,426 --> 01:04:08,051
essentially we are migrating just the process tree

01:04:08,051 --> 01:04:09,936
within the namespaces.

01:04:09,936 --> 01:04:13,927
So, one reason is that setting up the namespace

01:04:13,927 --> 01:04:16,037
requires doing a lot of stuff

01:04:16,037 --> 01:04:17,865
which requires root privileges.

01:04:17,865 --> 01:04:21,749
And second thing is that we already manage the

01:04:21,749 --> 01:04:26,300
namespace set up, the namespaces through the known agent

01:04:26,300 --> 01:04:30,133
of the cluster management system that we have.

01:04:31,411 --> 01:04:34,009
And the last assumption is that we are aiming

01:04:34,009 --> 01:04:35,822
for migration finishing within minutes.

01:04:35,822 --> 01:04:38,788
So we are not aiming for a millisecond

01:04:38,788 --> 01:04:41,772
or further migration because right now

01:04:41,772 --> 01:04:44,414
we don't see a very good way to achieve

01:04:44,414 --> 01:04:49,414
that kind of performance, even for just the blackout period

01:04:49,458 --> 01:04:52,625
and we found that if we cannot deliver

01:04:53,782 --> 01:04:56,024
then generally our customers are fine

01:04:56,024 --> 01:04:57,923
with a minute long delays.

01:04:57,923 --> 01:04:59,959
We don't want to, for it to take even longer

01:04:59,959 --> 01:05:01,914
because we don't want to hold up resources

01:05:01,914 --> 01:05:03,497
within the cluster.

01:05:05,962 --> 01:05:07,970
So, what's new?

01:05:07,970 --> 01:05:10,946
If you have seen our presentation from the last year

01:05:10,946 --> 01:05:15,420
you may know that our migration was going through storage.

01:05:15,420 --> 01:05:17,304
So we would first checkpoint to storage

01:05:17,304 --> 01:05:18,963
and then restore from it.

01:05:18,963 --> 01:05:22,441
And now, this has been mostly replaced by a streaming

01:05:22,441 --> 01:05:26,905
direct migration from the source to the destination host.

01:05:26,905 --> 01:05:31,020
We rely on the CRIU pageserver for doing this

01:05:31,020 --> 01:05:35,350
during migration with some added encapsulation layer.

01:05:35,350 --> 01:05:39,294
So essentially this is the way it looked before

01:05:39,294 --> 01:05:41,598
with the CRIU pageserver will talk

01:05:41,598 --> 01:05:45,825
with our internal migrator agent, which would put

01:05:45,825 --> 01:05:48,480
all the process then tie into the storage

01:05:48,480 --> 01:05:52,242
and then at later time, migrator on a different host

01:05:52,242 --> 01:05:55,296
would pull the data from the checkpoint and again talk

01:05:55,296 --> 01:05:57,379
with the CRIU pageserver.

01:05:58,901 --> 01:06:03,072
Oh, and the direct streaming at the host level

01:06:03,072 --> 01:06:04,405
is even simpler.

01:06:05,322 --> 01:06:07,637
There is some complexity at the cluster level

01:06:07,637 --> 01:06:09,435
where we need to make sure that the resources

01:06:09,435 --> 01:06:13,180
and the migrator agent is on the destination host

01:06:13,180 --> 01:06:16,051
before the migration starts

01:06:16,051 --> 01:06:20,606
but otherwise it's relatively straightforward.

01:06:20,606 --> 01:06:23,605
So, right now, actually our implementation

01:06:23,605 --> 01:06:27,489
allows us to be flexible, whether we want to migrate

01:06:27,489 --> 01:06:31,404
through storage or as a direct streaming solution

01:06:31,404 --> 01:06:34,922
but actually this has a slight complexity

01:06:34,922 --> 01:06:39,158
because with a direct streaming connection

01:06:39,158 --> 01:06:42,554
we could just encapsulate the page server protocol

01:06:42,554 --> 01:06:44,322
but if we want to put it on storage,

01:06:44,322 --> 01:06:47,172
for which we don't have a file system-like access

01:06:47,172 --> 01:06:49,645
and we don't want to have temporary files

01:06:49,645 --> 01:06:54,645
on some local file system, we had to a bit reverse engineer

01:06:55,333 --> 01:06:59,367
the CRIU pageserver protocol to acknowledge the receiving

01:06:59,367 --> 01:07:02,356
of the messages and then replay that communication

01:07:02,356 --> 01:07:03,725
to the destination host.

01:07:03,725 --> 01:07:04,575
Yes?

01:07:04,575 --> 01:07:08,519
- Do you use the encryption when doing the migration?

01:07:08,519 --> 01:07:09,466
- Yes.

01:07:09,466 --> 01:07:10,316
- Okay.

01:07:10,316 --> 01:07:11,166
- Yes.

01:07:11,166 --> 01:07:16,166
So, the migration agent, like, one of the responsibilities

01:07:16,568 --> 01:07:21,318
is making sure that the connection is encrypted and safe.

01:07:24,956 --> 01:07:28,206
So one thing that would be nice if CRIU

01:07:29,743 --> 01:07:33,537
would give a way to have the data received

01:07:33,537 --> 01:07:36,893
in the streaming manner without us having to

01:07:36,893 --> 01:07:39,940
acknowledge the receiving of the data

01:07:39,940 --> 01:07:44,523
or if the protocol was an officially supported protocol

01:07:46,291 --> 01:07:48,743
that we could feel safe to implement

01:07:48,743 --> 01:07:52,910
without being afraid of it breaking in the future.

01:07:55,299 --> 01:07:58,973
So, now we will talk more about our contributions

01:07:58,973 --> 01:08:03,181
to CRIU and our general experience with CRIU

01:08:03,181 --> 01:08:06,861
and we'll start with the subreaper support

01:08:06,861 --> 01:08:09,528
and Michal will talk about that.

01:08:10,960 --> 01:08:11,793
- Hi, hi.

01:08:14,137 --> 01:08:15,727
Okay.

01:08:15,727 --> 01:08:20,144
And so, this is property, it's called CHILD_SUBREAPER

01:08:21,675 --> 01:08:25,262
and you can set it via up your CTL.

01:08:25,262 --> 01:08:27,077
And, migration of this property

01:08:27,077 --> 01:08:29,827
was not supported in CRIU before.

01:08:34,146 --> 01:08:37,729
So I'm gonna talk about what exactly it is.

01:08:41,144 --> 01:08:45,415
So, normally if you don't have tried subreaper,

01:08:45,415 --> 01:08:50,354
if the green process dies, then the other process,

01:08:50,354 --> 01:08:53,645
it's child, is gonna get appointed to init.

01:08:53,645 --> 01:08:55,862
It's the regular behavior.

01:08:55,862 --> 01:09:00,112
And, if you have a subreaper then if something dies

01:09:01,211 --> 01:09:04,416
below it, it's not gonna get reaper end up doing it

01:09:04,416 --> 01:09:06,647
but to that subreaper.

01:09:06,647 --> 01:09:09,230
And why is it important for us?

01:09:11,952 --> 01:09:15,291
So, if we don't have a subreaper

01:09:15,291 --> 01:09:19,492
then the orphaned processes get appointed to init

01:09:19,492 --> 01:09:24,054
and then since, as Kamil said, we don't migrate

01:09:24,054 --> 01:09:27,971
the whole namespace, just the three starting at

01:09:31,826 --> 01:09:33,326
this root process.

01:09:35,187 --> 01:09:37,776
Then the orphaned process are not gonna get migrated.

01:09:37,776 --> 01:09:42,021
They're gonna get lost during the migration.

01:09:42,021 --> 01:09:44,665
But, if you have the subreaper then everything

01:09:44,665 --> 01:09:47,853
is gonna get properly migrated since that process

01:09:47,853 --> 01:09:50,936
is below the subreaper in the theory.

01:09:55,218 --> 01:09:56,051
Okay, so,

01:09:58,718 --> 01:10:02,520
I mean, generally it's pretty simple.

01:10:02,520 --> 01:10:04,187
You round the PACTL.

01:10:05,179 --> 01:10:07,846
You issue PR get child subreaper

01:10:09,344 --> 01:10:12,079
and then you use set child subreaper

01:10:12,079 --> 01:10:13,628
on the restoring site.

01:10:13,628 --> 01:10:16,545
So it should be easy but it wasn't.

01:10:17,708 --> 01:10:20,579
Basically I had to decide if I want to restore it

01:10:20,579 --> 01:10:24,912
before working, before creating the theory or after.

01:10:25,792 --> 01:10:28,375
And, I can do it before forking

01:10:29,551 --> 01:10:31,881
since sometimes I want to get,

01:10:31,881 --> 01:10:34,737
we want to create processes that get orphaned

01:10:34,737 --> 01:10:36,720
and the parent is doing it.

01:10:36,720 --> 01:10:40,142
And, restoring it before forking would break that.

01:10:40,142 --> 01:10:43,799
Processes wouldn't then get orphaned properly.

01:10:43,799 --> 01:10:45,765
So maybe after forking.

01:10:45,765 --> 01:10:48,348
Well, also not exactly because,

01:10:49,944 --> 01:10:53,171
because there is a bug in old kernels

01:10:53,171 --> 01:10:55,838
and the bug causes this property

01:10:58,099 --> 01:10:59,766
not to get properly,

01:11:02,440 --> 01:11:03,773
properly, sorry?

01:11:05,737 --> 01:11:07,213
- [Man] I think the word you're looking for

01:11:07,213 --> 01:11:10,071
is the property isn't properly propagated.

01:11:10,071 --> 01:11:11,133
- Yeah, theoretically.

01:11:11,133 --> 01:11:12,550
I mean, it's not,

01:11:14,819 --> 01:11:16,461
it's not set in the children then

01:11:16,461 --> 01:11:19,095
because the children are not subreapers but yeah.

01:11:19,095 --> 01:11:23,762
They're not gonna get that has tried subreaper variable.

01:11:28,090 --> 01:11:31,257
So, I had to decide between those two.

01:11:32,578 --> 01:11:34,550
I chose the second one.

01:11:34,550 --> 01:11:37,391
The bug was fixed in 2017.

01:11:37,391 --> 01:11:41,146
So, anyway, kernel has had that fixed

01:11:41,146 --> 01:11:43,824
but if you're running the older kernel,

01:11:43,824 --> 01:11:45,818
unfortunately you're gonna have to update

01:11:45,818 --> 01:11:47,568
if you want to use this feature

01:11:47,568 --> 01:11:50,485
and say thanks to Pavel Tikhomirov.

01:11:51,630 --> 01:11:53,737
I hope I'm saying this right.

01:11:53,737 --> 01:11:55,820
Because he fixed the bug.

01:11:57,706 --> 01:11:59,706
Okay, now about cgroups.

01:12:01,456 --> 01:12:05,539
Basically CRIU handles cgroup migration just fine

01:12:07,881 --> 01:12:10,964
but it uses CAP_SYS_RESTORE to mount,

01:12:14,762 --> 01:12:16,512
to mount the cgroups.

01:12:18,237 --> 01:12:22,580
It has to do that because in other directories,

01:12:22,580 --> 01:12:25,739
not every cgroup might be mounted.

01:12:25,739 --> 01:12:27,222
There might be some missing.

01:12:27,222 --> 01:12:30,472
So basically, CRIU needs a clean mount.

01:12:33,650 --> 01:12:38,510
And, since we don't want to give CAP_SYS_RESTORE to CRIU,

01:12:38,510 --> 01:12:42,677
we found a way to create the directory with mounts

01:12:45,867 --> 01:12:47,603
before starting CRIU.

01:12:47,603 --> 01:12:52,603
Then paused the directory as a common line option to CRIU.

01:12:53,250 --> 01:12:56,917
Then after CRIU is done, we mount everything

01:12:57,901 --> 01:13:01,151
and then we do in a privileged process.

01:13:08,148 --> 01:13:12,981
- Another thing that we liked in our interaction with CRIU

01:13:14,118 --> 01:13:17,896
is that we generally, during the migration,

01:13:17,896 --> 01:13:21,876
the task on the destination host gets a different IP

01:13:21,876 --> 01:13:24,394
than the one on the source host.

01:13:24,394 --> 01:13:26,856
Generally our users handled that well

01:13:26,856 --> 01:13:28,931
by just retrying the connections appropriately

01:13:28,931 --> 01:13:30,598
in the library code.

01:13:31,834 --> 01:13:35,600
And, we are happy that CRIU generally works well

01:13:35,600 --> 01:13:39,177
with this scenario, with appropriate configuration

01:13:39,177 --> 01:13:43,010
and we would like to stress that we would like

01:13:44,007 --> 01:13:46,180
for this to keep being supported

01:13:46,180 --> 01:13:49,263
and this being an important use case.

01:13:51,141 --> 01:13:54,706
One part where we think that perhaps CRIU

01:13:54,706 --> 01:13:58,706
could be a bit better is with the error messages

01:13:59,653 --> 01:14:00,956
that we are getting.

01:14:00,956 --> 01:14:04,505
Right now we need to parse the whole log

01:14:04,505 --> 01:14:07,177
from the migration and try to deduce

01:14:07,177 --> 01:14:09,539
what was actually the kind of failure.

01:14:09,539 --> 01:14:11,590
We often would like to, for example,

01:14:11,590 --> 01:14:15,021
have some categorization, idea of some structure in,

01:14:15,021 --> 01:14:17,096
okay, where we should look for the error,

01:14:17,096 --> 01:14:19,429
what kind of an error it is.

01:14:20,264 --> 01:14:23,668
And, this is also perhaps a good occasion

01:14:23,668 --> 01:14:28,668
to stress that we generally care about (laughing).

01:14:29,148 --> 01:14:32,315
(man speaking softly)

01:14:33,555 --> 01:14:36,819
We care about every failure and we want to get

01:14:36,819 --> 01:14:39,379
as much debugging info as possible.

01:14:39,379 --> 01:14:43,741
So, induct, if it is possible to get more debugging info

01:14:43,741 --> 01:14:47,491
from CRIU, we very much would like to see it.

01:14:50,992 --> 01:14:53,492
One other feature that wasn't,

01:14:54,719 --> 01:14:56,946
and I think is still not supported by CRIU

01:14:56,946 --> 01:15:01,013
is support for file descriptors with O_PATH,

01:15:01,013 --> 01:15:03,623
which is quite funny because CRIU itself

01:15:03,623 --> 01:15:06,373
uses O_PATH file descriptors but,

01:15:08,797 --> 01:15:11,399
so maybe I should tell something

01:15:11,399 --> 01:15:13,476
about what are these file descriptors.

01:15:13,476 --> 01:15:17,026
So, if you open a file with an O_PATH flag

01:15:17,026 --> 01:15:20,757
you get a bit of the general file descriptor

01:15:20,757 --> 01:15:25,385
which holds all the information about the resolved path

01:15:25,385 --> 01:15:27,712
but actually you can't do much with it

01:15:27,712 --> 01:15:31,629
and in particular, CRIU tries to learn too much

01:15:32,504 --> 01:15:35,421
using FCNPLs about it and it fails.

01:15:38,946 --> 01:15:41,282
So we will be posting a patch soon

01:15:41,282 --> 01:15:45,782
which fixes this just by taking the O_PATH flag first.

01:15:47,853 --> 01:15:52,103
And now I will talk about our request or experience

01:15:53,747 --> 01:15:57,638
with the checkpoint restore support in the kernel.

01:15:57,638 --> 01:16:02,095
So, I have talked about the O_PATH file descriptors

01:16:02,095 --> 01:16:06,563
and actually another issue that we haven't really seen

01:16:06,563 --> 01:16:11,352
too much in production in the wild but it's something

01:16:11,352 --> 01:16:15,815
that keeps us worried is that for many virtual file systems

01:16:15,815 --> 01:16:19,127
kernel will keep some internal snapshot

01:16:19,127 --> 01:16:21,912
when the file is first opened and the roots

01:16:21,912 --> 01:16:24,644
would then go from this buffer.

01:16:24,644 --> 01:16:27,003
This is obviously nice because it gives a nice,

01:16:27,003 --> 01:16:29,678
consistent view of the file even if you do it

01:16:29,678 --> 01:16:33,286
in multiple reads but the problem for the checkpoint restore

01:16:33,286 --> 01:16:37,122
is that one, it's hard to get this information.

01:16:37,122 --> 01:16:39,701
You could theoretically read through the file descriptor

01:16:39,701 --> 01:16:43,468
that is already opened, even though the files

01:16:43,468 --> 01:16:46,603
on the virtual file systems don't always

01:16:46,603 --> 01:16:49,897
necessarily work like that but more importantly

01:16:49,897 --> 01:16:54,103
you don't have at all any way to restore that state.

01:16:54,103 --> 01:16:58,353
We don't have a very good proposal how to fix this.

01:17:00,253 --> 01:17:03,620
Perhaps either a direct API to put this data

01:17:03,620 --> 01:17:07,996
or maybe the virtual file systems could have some way

01:17:07,996 --> 01:17:10,163
to migrate them wholesale.

01:17:19,415 --> 01:17:22,784
- Is this something that happens frequently with some files?

01:17:22,784 --> 01:17:27,434
- So we haven't really seen that much in practice.

01:17:27,434 --> 01:17:30,941
I assume this is probably that because majority

01:17:30,941 --> 01:17:33,504
of the proc files can be read with a single read syscall

01:17:33,504 --> 01:17:37,139
so many direct users don't see the issue

01:17:37,139 --> 01:17:38,872
but at the same time we are afraid

01:17:38,872 --> 01:17:41,967
that we may be missing some problems

01:17:41,967 --> 01:17:46,584
because statistically users don't see that happen

01:17:46,584 --> 01:17:50,167
but in the reality they may get wrong data.

01:17:51,440 --> 01:17:52,523
- [Man] Okay.

01:17:55,736 --> 01:17:57,986
- One thing here about proc

01:17:58,953 --> 01:18:02,036
is that while there are parts of proc

01:18:03,254 --> 01:18:06,576
which are generally used and important to users,

01:18:06,576 --> 01:18:09,711
there are other parts which on one hand potentially

01:18:09,711 --> 01:18:13,921
break the hermeticity by giving a lot of information

01:18:13,921 --> 01:18:17,383
about the host and it potentially would be nice

01:18:17,383 --> 01:18:22,198
to have a way to not show all the files in the proc.

01:18:22,198 --> 01:18:25,421
So kind of a limited view which is more suited

01:18:25,421 --> 01:18:26,921
towards migration.

01:18:31,052 --> 01:18:33,479
So, one thing that we also encountered

01:18:33,479 --> 01:18:36,614
is that some interfaces are heavily restricted.

01:18:36,614 --> 01:18:40,214
So, for example, I think map files requires

01:18:40,214 --> 01:18:42,597
the global CAP_SYS_ADMIN.

01:18:42,597 --> 01:18:46,847
The ns_last_pid, it needs a namespace CAP_SYS_ADMIN

01:18:48,698 --> 01:18:52,341
which is definitely much better but still something

01:18:52,341 --> 01:18:55,163
that we would like ideally get rid of.

01:18:55,163 --> 01:18:58,163
So, we think that for our use cases,

01:18:59,743 --> 01:19:04,743
this interfaces don't really affect security significantly

01:19:04,904 --> 01:19:08,309
and we would be happy if we had separate capability

01:19:08,309 --> 01:19:11,556
that we could just give to users and to CRIU

01:19:11,556 --> 01:19:15,306
without having to give CAP_SYS_ADMIN to them.

01:19:19,787 --> 01:19:23,278
So, we have talked about time namespaces last year.

01:19:23,278 --> 01:19:26,116
Really not that much has changed.

01:19:26,116 --> 01:19:29,011
I just wanted to reiterate that it's still something

01:19:29,011 --> 01:19:32,150
that we consider useful and we would like to see.

01:19:32,150 --> 01:19:36,067
Right now we are working it around in libraries

01:19:37,100 --> 01:19:40,309
and one thing that's also important for us,

01:19:40,309 --> 01:19:42,560
if the time namespaces could isolate

01:19:42,560 --> 01:19:45,514
the time stamp counter register too,

01:19:45,514 --> 01:19:47,514
it would be very useful.

01:19:52,893 --> 01:19:56,001
Another issue is that there is a set,

01:19:56,001 --> 01:19:58,505
there are some kernel interfaces

01:19:58,505 --> 01:20:01,120
which are effectively write only.

01:20:01,120 --> 01:20:03,753
For example, resortable sequences,

01:20:03,753 --> 01:20:06,439
I won't go into too much detail how they work

01:20:06,439 --> 01:20:09,108
but essentially you can request some behavior

01:20:09,108 --> 01:20:12,365
from kernel but then you cannot inspect in any way

01:20:12,365 --> 01:20:14,493
what was actually requested.

01:20:14,493 --> 01:20:17,326
Similarly for cgroup v1 event API,

01:20:18,355 --> 01:20:20,713
you can register that to get some events

01:20:20,713 --> 01:20:22,807
but there is no way to discover what events

01:20:22,807 --> 01:20:24,801
have you registered for.

01:20:24,801 --> 01:20:28,475
This means that for users who want to use these libraries,

01:20:28,475 --> 01:20:31,762
we need to add support in the libraries,

01:20:31,762 --> 01:20:35,213
which is unfortunate because ideally,

01:20:35,213 --> 01:20:38,170
as mentioned in the previous presentations,

01:20:38,170 --> 01:20:40,914
we would have CRIU be transparent

01:20:40,914 --> 01:20:44,030
and not require users to access these APIs

01:20:44,030 --> 01:20:47,113
only through some approved libraries.

01:20:49,547 --> 01:20:52,630
And, this ties into a bigger question

01:20:53,579 --> 01:20:57,622
of how do we make sure that the new interfaces

01:20:57,622 --> 01:21:00,052
that are being counted to the kernel

01:21:00,052 --> 01:21:02,747
are suited for migration?

01:21:02,747 --> 01:21:05,919
Generally, the features that make migration possible

01:21:05,919 --> 01:21:10,919
being able to inspect what is the kernel state I think are,

01:21:11,096 --> 01:21:14,864
there wasn't a problem to marriage them

01:21:14,864 --> 01:21:17,781
from what I know but it's been said

01:21:19,744 --> 01:21:22,624
that we kind of have to play whack-a-mole, right?

01:21:22,624 --> 01:21:25,263
Okay, there is somebody who needs this feature.

01:21:25,263 --> 01:21:28,206
Actually it's not migration compatible

01:21:28,206 --> 01:21:30,985
and we need to improve the kernel.

01:21:30,985 --> 01:21:33,495
Ideally we would either, for every new feature,

01:21:33,495 --> 01:21:36,721
have it done with migration in mind

01:21:36,721 --> 01:21:38,966
but I'm not sure if this is feasible

01:21:38,966 --> 01:21:41,034
and how we would achieve this.

01:21:41,034 --> 01:21:43,341
Or alternatively, maybe we need some API

01:21:43,341 --> 01:21:46,299
to kind of instead of having every separate feature,

01:21:46,299 --> 01:21:48,811
have a separate API to read the data,

01:21:48,811 --> 01:21:52,344
some way to dump opaque kernel data

01:21:52,344 --> 01:21:55,249
and then restore it on the other site.

01:21:55,249 --> 01:21:57,166
Actually, this is like,

01:22:00,065 --> 01:22:03,691
I didn't know what the kernel other space isolation

01:22:03,691 --> 01:22:06,846
were before but I think that potentially this could

01:22:06,846 --> 01:22:10,386
feed into such an API if we have a clear separation.

01:22:10,386 --> 01:22:13,825
Okay, these kernel objects belong to some namespace,

01:22:13,825 --> 01:22:14,825
for example.

01:22:17,529 --> 01:22:19,696
And that's pretty much it.

01:22:20,932 --> 01:22:22,099
Any questions?

01:22:24,035 --> 01:22:27,937
- So, you said your container manager

01:22:27,937 --> 01:22:31,494
creates the namespaces on the destination machine.

01:22:31,494 --> 01:22:32,396
- [Kamil] Yes.

01:22:32,396 --> 01:22:34,408
- Is one of those namespaces a PID namespace?

01:22:34,408 --> 01:22:35,614
- [Kamil] Yes.

01:22:35,614 --> 01:22:37,807
- Does your container manager have any problem

01:22:37,807 --> 01:22:41,496
with giving your restore process root

01:22:41,496 --> 01:22:43,496
over that PID namespace?

01:22:45,569 --> 01:22:46,408
Oh, I guess what I mean--

01:22:46,408 --> 01:22:47,449
- [Kamil] During CAP_SYS_ADMIN.

01:22:47,449 --> 01:22:48,702
- Say again.

01:22:48,702 --> 01:22:51,858
- [Kamil] CAP_SYS_ADMIN for the, over the PID namespace.

01:22:51,858 --> 01:22:54,574
- Yeah so if you create a user namespace

01:22:54,574 --> 01:22:57,117
and then create a PID namespace,

01:22:57,117 --> 01:22:58,685
you're not root on the whole machine.

01:22:58,685 --> 01:22:59,725
- [Kamil] Yes, yes, yes.

01:22:59,725 --> 01:23:00,927
- Just over your namespaces.

01:23:00,927 --> 01:23:01,829
- Yes.

01:23:01,829 --> 01:23:04,133
So we actually do that right now.

01:23:04,133 --> 01:23:07,431
We would prefer to have it reduced

01:23:07,431 --> 01:23:10,931
but this is a not bad situation right now,

01:23:12,256 --> 01:23:13,428
(laughing)

01:23:13,428 --> 01:23:14,329
the way we look at it.

01:23:14,329 --> 01:23:15,915
But, for example, I think

01:23:15,915 --> 01:23:19,415
the map files interface, as far as I know,

01:23:21,071 --> 01:23:23,691
requires actually a global CAP_SYS_ADMIN

01:23:23,691 --> 01:23:25,918
and if it required a namespace CAP_SYS_ADMIN

01:23:25,918 --> 01:23:27,546
instead of the global one,

01:23:27,546 --> 01:23:31,214
that would be a huge improvement for us.

01:23:31,214 --> 01:23:33,914
- I don't remember what map files does

01:23:33,914 --> 01:23:35,354
so I can't comment right now.

01:23:35,354 --> 01:23:36,724
- I can describe maybe.

01:23:36,724 --> 01:23:40,039
Essentially it allows to access files

01:23:40,039 --> 01:23:42,456
which are mapped into memory.

01:23:43,934 --> 01:23:46,353
The main secret concern there is that

01:23:46,353 --> 01:23:48,588
only a small region is mapped and for map files

01:23:48,588 --> 01:23:51,164
you can see the whole file if you have permissions.

01:23:51,164 --> 01:23:53,056
- More or less being made to file.

01:23:53,056 --> 01:23:53,889
- Yeah.

01:23:55,427 --> 01:23:57,594
- Is it maybe PFM to file?

01:23:58,547 --> 01:23:59,447
- PMA.

01:23:59,447 --> 01:24:00,362
- Okay.

01:24:00,362 --> 01:24:03,279
I'm remembering a discussion, yeah,

01:24:04,711 --> 01:24:07,312
well if it's VMA to file it's probably okay.

01:24:07,312 --> 01:24:09,069
I know there's another similar interface

01:24:09,069 --> 01:24:12,732
that was showing page frame numbers and stuff

01:24:12,732 --> 01:24:15,982
and it was useful to exploit rowhammer.

01:24:19,960 --> 01:24:22,003
So you could see what other processes,

01:24:22,003 --> 01:24:24,301
where other processes were and say, oh, if I pound

01:24:24,301 --> 01:24:26,936
on this page of mine, it'll blow you up.

01:24:26,936 --> 01:24:28,242
And gets security--

01:24:28,242 --> 01:24:29,390
- It's different.

01:24:29,390 --> 01:24:31,850
- [Kamil] So yeah, as far as I know it's VMAs.

01:24:31,850 --> 01:24:34,978
- Yeah, so if it's just VMAs it should be fine.

01:24:34,978 --> 01:24:37,208
- [Kamil] For the ns_capable?

01:24:37,208 --> 01:24:39,335
- I think so, I think so.

01:24:39,335 --> 01:24:41,783
- [Kamil] And what about the CAP_RESTORE

01:24:41,783 --> 01:24:46,120
for to further reduce the capabilities given?

01:24:46,120 --> 01:24:48,287
- Well, if you could do it

01:24:49,167 --> 01:24:51,770
as a user and a user namespace you have fewer capabilities

01:24:51,770 --> 01:24:53,824
than what you would with a CAP_RESTORE.

01:24:53,824 --> 01:24:54,725
- No, no.

01:24:54,725 --> 01:24:58,026
I guess we could have CAP_RESTORE within the namespace too.

01:24:58,026 --> 01:24:58,859
- Okay, yeah.

01:24:58,859 --> 01:25:00,109
And that could,

01:25:01,374 --> 01:25:03,573
if the only thing that's really using

01:25:03,573 --> 01:25:07,551
that kind of functionality is checkpoint restore

01:25:07,551 --> 01:25:10,051
that wouldn't be unreasonable.

01:25:11,423 --> 01:25:13,883
It might take work but (laughing).

01:25:13,883 --> 01:25:14,716
- Yeah.

01:25:20,548 --> 01:25:22,215
Any other questions?

01:25:27,953 --> 01:25:29,851
- One over there and one over there.

01:25:29,851 --> 01:25:32,584
- But where are the mics?

01:25:32,584 --> 01:25:34,094
(laughing)

01:25:34,094 --> 01:25:37,070
(laughing drowns out speaker)

01:25:37,070 --> 01:25:40,021
- There was one back there somewhere.

01:25:40,021 --> 01:25:41,622
Oh, it's not working?

01:25:41,622 --> 01:25:43,384
You can try this one.

01:25:43,384 --> 01:25:45,469
(man speaking softly)

01:25:45,469 --> 01:25:48,471
- I just want to say a few words about the namespace.

01:25:48,471 --> 01:25:51,971
We were working on the namespace last year

01:25:53,083 --> 01:25:55,768
and now we want to think it will be

01:25:55,768 --> 01:26:00,268
in the near future, maybe next or next kernel release.

01:26:01,887 --> 01:26:05,554
So, it's, we're near the issues of this work

01:26:06,881 --> 01:26:11,381
but we don't know how much time we will need to nurse.

01:26:16,576 --> 01:26:18,592
- [Man] Yeah so my question, I may be showing

01:26:18,592 --> 01:26:22,591
my ignorance here, does CRIU try to checkpoint

01:26:22,591 --> 01:26:25,960
and restore processes at random times

01:26:25,960 --> 01:26:29,042
or do they have to reach a safe point

01:26:29,042 --> 01:26:32,810
where you can save and restore them?

01:26:32,810 --> 01:26:35,174
- Does it require coordination from the user

01:26:35,174 --> 01:26:36,873
in those safe regions?

01:26:36,873 --> 01:26:37,881
Is that the question?

01:26:37,881 --> 01:26:38,873
- [Man] Yeah, something like that.

01:26:38,873 --> 01:26:42,290
- So no, however, we, for users we expose

01:26:44,161 --> 01:26:47,772
a migration to identification API where they can register

01:26:47,772 --> 01:26:50,482
for an event before the migration

01:26:50,482 --> 01:26:53,224
and we wait for them to kind of acknowledge

01:26:53,224 --> 01:26:54,639
that they are ready.

01:26:54,639 --> 01:26:57,571
So, for example, in some cases,

01:26:57,571 --> 01:27:00,738
like if they want to do some lame duck

01:27:01,883 --> 01:27:05,367
or do something to make themselves more migratable,

01:27:05,367 --> 01:27:07,815
this can be done within this hooks.

01:27:07,815 --> 01:27:10,601
So essentially, most of the workarounds

01:27:10,601 --> 01:27:13,106
in the libraries that we have mentioned

01:27:13,106 --> 01:27:15,315
are done using such an API.

01:27:15,315 --> 01:27:18,431
Okay, before migration let's either write down

01:27:18,431 --> 01:27:22,764
or change some stuff and then I'll restore for some,

01:27:23,904 --> 01:27:26,202
fetch the information about the new host

01:27:26,202 --> 01:27:29,063
and only then actually continue execution.

01:27:29,063 --> 01:27:30,248
- [Man] Right.

01:27:30,248 --> 01:27:32,124
One thing I was wondering about specifically

01:27:32,124 --> 01:27:36,310
is what happens if a process is executing

01:27:36,310 --> 01:27:40,220
in the VDSO, for example, when you try and migrate it?

01:27:40,220 --> 01:27:44,108
Do you only allow migration to an identical kernel or?

01:27:44,108 --> 01:27:48,791
- Yeah, so, we haven't really solved that problem

01:27:48,791 --> 01:27:51,017
but I think there's a presentation later

01:27:51,017 --> 01:27:52,886
about this problem and--

01:27:52,886 --> 01:27:56,754
- Yeah, I'm going to present this problem (mumbles).

01:27:56,754 --> 01:27:58,116
- [Kamil] Okay.

01:27:58,116 --> 01:27:59,574
(people laughing)

01:27:59,574 --> 01:28:02,324
- [Man] That will be interesting.

01:28:05,417 --> 01:28:07,250
- Any other questions?

01:28:10,307 --> 01:28:11,397
- Doesn't look like it.

01:28:11,397 --> 01:28:12,230
- Cool.

01:28:12,230 --> 01:28:13,063
- Thank you.

01:28:13,063 --> 01:28:13,896
- Thank you.

01:28:13,896 --> 01:28:16,866
(audience clapping)

01:28:16,866 --> 01:28:20,225
- Okay, we're gonna be starting back up in a minute.

01:28:20,225 --> 01:28:22,075
(people talking loudly)

01:28:22,075 --> 01:28:24,053
We also have like a pile of stickers on the table

01:28:24,053 --> 01:28:26,917
in front here for both Linux sticker and CRIU stickers

01:28:26,917 --> 01:28:29,463
if anyone wants or if anyone's got other stickers

01:28:29,463 --> 01:28:32,167
they would like to share, you can put them over here.

01:28:32,167 --> 01:28:35,500
(people talking loudly)

01:29:20,404 --> 01:29:21,237
- Okay.

01:29:23,545 --> 01:29:24,795
Hello everyone.

01:29:26,118 --> 01:29:28,152
Today I will be speaking

01:29:28,152 --> 01:29:32,108
about secure image-less container migration.

01:29:32,108 --> 01:29:34,918
I, just to introduce myself,

01:29:34,918 --> 01:29:37,371
my name is Radostin.

01:29:37,371 --> 01:29:40,212
I just graduated from the University of Aberdeen

01:29:40,212 --> 01:29:44,282
and I'm about to start my masters degree.

01:29:44,282 --> 01:29:46,865
So one thing we were working on

01:29:48,782 --> 01:29:53,532
was basically to automate the way we transfer image files

01:29:55,980 --> 01:29:58,563
and to do that in a secure way.

01:30:00,879 --> 01:30:03,296
So, the first step is to look

01:30:04,911 --> 01:30:09,241
at how the lazy-pages daemon actually works.

01:30:09,241 --> 01:30:12,491
So, when CRIU does post-copy migration,

01:30:16,035 --> 01:30:19,035
we have to start a lazy-pages daemon

01:30:20,341 --> 01:30:23,591
which then is used to handle user fault

01:30:28,034 --> 01:30:29,784
at the interceptions.

01:30:34,364 --> 01:30:37,281
When the dump site is being called,

01:30:38,670 --> 01:30:41,177
it creates a set of image files

01:30:41,177 --> 01:30:43,549
and these image files have to be transferred

01:30:43,549 --> 01:30:45,721
over to this destination site

01:30:45,721 --> 01:30:48,541
and they don't contain the memory pages

01:30:48,541 --> 01:30:51,780
which is probably the largest,

01:30:51,780 --> 01:30:55,863
in most cases the largest part of the checkpoint.

01:30:57,382 --> 01:30:59,632
But it still, it takes time

01:31:01,008 --> 01:31:03,697
to first start the lazy-pages daemon

01:31:03,697 --> 01:31:06,780
and also to send all the image files.

01:31:10,081 --> 01:31:14,056
And, if we want to introduce encryption,

01:31:14,056 --> 01:31:16,081
how do we do that?

01:31:16,081 --> 01:31:19,414
So one way is to pass a file descriptor.

01:31:20,408 --> 01:31:24,547
So, we create server, we pass the file descriptor to CRIU

01:31:24,547 --> 01:31:27,848
and then CRIU writes to this file descriptor

01:31:27,848 --> 01:31:30,631
but then we have to read from the file descriptor

01:31:30,631 --> 01:31:34,214
and encrypt the data that will be sent over

01:31:35,646 --> 01:31:39,945
to the network and then we have to basically

01:31:39,945 --> 01:31:41,619
decrypt the data on destination site

01:31:41,619 --> 01:31:43,820
and then write it back to the file descriptor

01:31:43,820 --> 01:31:46,021
that CRIU is using.

01:31:46,021 --> 01:31:50,228
So, one way to optimize that is basically to ask CRIU

01:31:50,228 --> 01:31:53,477
to do the encryption and decryption

01:31:53,477 --> 01:31:57,452
and this is basically the idea that we wanted to introduce.

01:31:57,452 --> 01:32:00,869
So, basically CRIU is using a certificate

01:32:04,276 --> 01:32:06,120
installed on the host itself

01:32:06,120 --> 01:32:10,953
and then performs key exchange and once the authentication

01:32:12,221 --> 01:32:13,888
is complete, it just

01:32:17,846 --> 01:32:20,346
encrypts the data and encrypts

01:32:23,175 --> 01:32:25,342
when sending memory pages.

01:32:28,693 --> 01:32:30,943
So, in order to enable TLS,

01:32:32,756 --> 01:32:35,405
the first step is to basically install the,

01:32:35,405 --> 01:32:38,216
to generate certificates and install them

01:32:38,216 --> 01:32:42,852
and then you just have to add the TLS command line option

01:32:42,852 --> 01:32:47,102
and everything else should just work as it used to.

01:32:48,616 --> 01:32:50,918
The next step is basically how to automate

01:32:50,918 --> 01:32:53,025
the transfer of image files.

01:32:53,025 --> 01:32:57,060
So, there was a previous work from Rodrigo Bruno

01:32:57,060 --> 01:33:00,727
who implemented image cache and image proxy,

01:33:03,435 --> 01:33:08,060
which is a way to basically create a proxy server

01:33:08,060 --> 01:33:11,078
on the source site and a cache server

01:33:11,078 --> 01:33:12,831
on the destination site.

01:33:12,831 --> 01:33:16,887
Both create a Unix socket and then the dump

01:33:16,887 --> 01:33:20,689
writes to, CRIU dump writes to this Unix socket.

01:33:20,689 --> 01:33:24,353
Image proxy will basically read from the socket

01:33:24,353 --> 01:33:28,510
and it will send the data over the image cache.

01:33:28,510 --> 01:33:32,278
Image cache will keep the data in memory buffer

01:33:32,278 --> 01:33:36,130
and then when the restore site connects

01:33:36,130 --> 01:33:40,270
through the Unix socket, it will read the data back.

01:33:40,270 --> 01:33:43,696
The problem here is that we have a performance overhead.

01:33:43,696 --> 01:33:46,703
We basically write the same data once

01:33:46,703 --> 01:33:49,370
to the image proxy cache buffer.

01:33:50,215 --> 01:33:54,045
Then this will be sent to over the network

01:33:54,045 --> 01:33:57,393
to image cache and this will be break down again

01:33:57,393 --> 01:34:01,560
and then CRIU restore will basically read the data

01:34:03,122 --> 01:34:04,165
one more time.

01:34:04,165 --> 01:34:07,974
So, it's not a very efficient way of doing that.

01:34:07,974 --> 01:34:10,724
And, this is how you can actually

01:34:12,316 --> 01:34:14,520
use image cache, image proxy.

01:34:14,520 --> 01:34:17,670
You basically have to start the cache daemon

01:34:17,670 --> 01:34:21,668
and the proxy daemon and then you basically pass

01:34:21,668 --> 01:34:25,029
the remote option to dump and restore

01:34:25,029 --> 01:34:27,813
and then instead of writing to files,

01:34:27,813 --> 01:34:31,965
it will basically always write to this Unix socket

01:34:31,965 --> 01:34:34,382
or read from the Unix socket.

01:34:35,267 --> 01:34:37,206
And the way we want to optimize that

01:34:37,206 --> 01:34:40,206
is by using a single TCP connection.

01:34:41,477 --> 01:34:44,144
So, when you start CRIU restore,

01:34:45,249 --> 01:34:47,499
it will create a TCP server

01:34:48,557 --> 01:34:52,640
and then with CRIU dump you can basically connect

01:34:53,990 --> 01:34:58,157
to this TCP server and send all the data that you,

01:34:59,548 --> 01:35:02,941
basically send the images rather than saving them to files.

01:35:02,941 --> 01:35:05,809
You can basically send them over the network.

01:35:05,809 --> 01:35:08,505
And, we already have the TLS encryption

01:35:08,505 --> 01:35:12,450
so we can basically instead of using sent,

01:35:12,450 --> 01:35:15,367
we can use TLS to encrypt the data.

01:35:20,037 --> 01:35:23,781
And the way you can use that is basically

01:35:23,781 --> 01:35:27,198
by adding the port option to CRIU restore

01:35:30,487 --> 01:35:32,634
and this will create the actual server

01:35:32,634 --> 01:35:37,551
and then with dump you can use port and address to connect.

01:35:39,252 --> 01:35:43,740
And, the way we implement, we could implement

01:35:43,740 --> 01:35:47,073
record integration is by using pre-dump.

01:35:48,028 --> 01:35:51,279
So, one this is that pre-dump, what it does,

01:35:51,279 --> 01:35:53,774
it's actually creating an inventory image.

01:35:53,774 --> 01:35:57,977
It's creating a checkpoint of the memory pages

01:35:57,977 --> 01:36:00,644
and so all other images are not,

01:36:03,262 --> 01:36:05,971
they are not being tracked currently.

01:36:05,971 --> 01:36:08,888
So, what we have to do is basically

01:36:09,873 --> 01:36:12,257
we have to transfer the memory pages

01:36:12,257 --> 01:36:16,912
to destination site and then if we have another pre-dump

01:36:16,912 --> 01:36:21,808
then we receive another instance of the memory pages.

01:36:21,808 --> 01:36:24,152
If some memory pages have been changed,

01:36:24,152 --> 01:36:28,279
then we can basically override the existing ones

01:36:28,279 --> 01:36:29,954
on the destination site.

01:36:29,954 --> 01:36:32,643
So we don't need to keep the parent relationship

01:36:32,643 --> 01:36:34,560
between previous dumps.

01:36:35,950 --> 01:36:38,947
And, when the final dump is performed

01:36:38,947 --> 01:36:42,114
then the restore process can continue.

01:36:44,433 --> 01:36:48,115
And, the same could be done with ps socket.

01:36:48,115 --> 01:36:51,913
So, we can just pass a file descriptor

01:36:51,913 --> 01:36:56,067
and then the remote site, instead of creating

01:36:56,067 --> 01:36:57,484
a socket and then

01:37:02,300 --> 01:37:04,172
performing everything for that,

01:37:04,172 --> 01:37:09,172
it would just use the file descriptor that has passed.

01:37:09,296 --> 01:37:12,208
And so, the challenge here is how do we handle

01:37:12,208 --> 01:37:14,136
the special image files?

01:37:14,136 --> 01:37:16,368
For example, the temporary file system,

01:37:16,368 --> 01:37:18,535
it's currently like a CRIU

01:37:20,258 --> 01:37:22,841
in how it creates the zip file.

01:37:23,864 --> 01:37:25,917
Well, not terrible.

01:37:25,917 --> 01:37:28,701
And then this is the actual image.

01:37:28,701 --> 01:37:30,989
So this image has to be transferred

01:37:30,989 --> 01:37:33,791
to destination site and the problem here is that

01:37:33,791 --> 01:37:36,185
we don't know how much space we need

01:37:36,185 --> 01:37:38,418
in order to allocate it.

01:37:38,418 --> 01:37:41,204
So, the way this is currently implemented

01:37:41,204 --> 01:37:45,121
is by writing to image proxy instead of buffers

01:37:47,330 --> 01:37:49,737
and then after the write is complete

01:37:49,737 --> 01:37:53,841
we know how much space we have used and then we can

01:37:53,841 --> 01:37:56,333
send that to the image cache.

01:37:56,333 --> 01:37:59,787
So probably this would be the way to solve it.

01:37:59,787 --> 01:38:02,864
Like, writing in certain buffers

01:38:02,864 --> 01:38:05,264
and then when we start creating it,

01:38:05,264 --> 01:38:07,847
we know how much space we need.

01:38:10,304 --> 01:38:14,054
And, the other challenge was basically how to

01:38:16,455 --> 01:38:20,288
replace or rather merge dumps of memory pages.

01:38:24,711 --> 01:38:28,044
So, we have to identify the memory pages

01:38:29,621 --> 01:38:32,954
that have been modified and replace them

01:38:34,567 --> 01:38:37,997
with the new version and then keep the single instance

01:38:37,997 --> 01:38:39,747
of every memory page.

01:38:42,029 --> 01:38:45,980
And the last step would be to implement,

01:38:45,980 --> 01:38:48,496
basically to integrate it with lazy-pages daemon

01:38:48,496 --> 01:38:51,663
and this would be, the idea here is to

01:38:52,656 --> 01:38:55,786
have something called hybrid copy integration

01:38:55,786 --> 01:38:59,337
which is you perform several iterations of pre-dump

01:38:59,337 --> 01:39:02,724
and then at the end you do post-copy migration

01:39:02,724 --> 01:39:06,057
and all memory pages that have not been,

01:39:08,815 --> 01:39:11,636
have been modified and have not been sent

01:39:11,636 --> 01:39:15,136
in the master will be requested on demand.

01:39:16,463 --> 01:39:19,218
So, the idea is that lazy-pages daemon

01:39:19,218 --> 01:39:22,718
is currently running as a separate process

01:39:23,847 --> 01:39:27,014
and it's creating it's own TCP socket.

01:39:28,183 --> 01:39:31,933
So the way we can integrate the remote option

01:39:32,809 --> 01:39:35,142
with lazy-pages daemon is by

01:39:37,011 --> 01:39:40,400
basically reusing the same socket

01:39:40,400 --> 01:39:42,452
that was already established.

01:39:42,452 --> 01:39:45,834
So, we fork and create the daemon again

01:39:45,834 --> 01:39:49,160
but this time it's just using the socket

01:39:49,160 --> 01:39:51,077
from the remote option.

01:39:53,839 --> 01:39:56,589
And, this is probably, thank you.

01:39:58,383 --> 01:40:02,716
And, these are some of the links to my current work.

01:40:04,721 --> 01:40:06,888
Do you have any questions?

01:40:09,135 --> 01:40:12,302
(man speaking softly)

01:40:14,785 --> 01:40:17,549
- So for the integration with lazy-pages,

01:40:17,549 --> 01:40:21,738
I started to look at it once some time ago

01:40:21,738 --> 01:40:24,349
but then I hadn't more time.

01:40:24,349 --> 01:40:28,485
You can fork the lazy-pages from site CRIU

01:40:28,485 --> 01:40:30,200
and use socket pair to communicate

01:40:30,200 --> 01:40:33,277
between main CRIU and the lazy-pages

01:40:33,277 --> 01:40:36,353
and then if you fork it later enough

01:40:36,353 --> 01:40:38,536
that you can inherit the TCP socket

01:40:38,536 --> 01:40:43,286
from the regional CRIU that you were creating for images.

01:40:44,656 --> 01:40:46,248
- Yes.

01:40:46,248 --> 01:40:47,081
Thanks.

01:40:50,444 --> 01:40:52,106
- So, besides the future work,

01:40:52,106 --> 01:40:54,377
is this already, oh I see it there.

01:40:54,377 --> 01:40:56,129
There's a pole request for all this, right?

01:40:56,129 --> 01:40:58,322
- Well, the pole request is actually for TLS,

01:40:58,322 --> 01:41:01,143
for TLS and fork, like the link is for TLS.

01:41:01,143 --> 01:41:03,232
- And the image-less migration,

01:41:03,232 --> 01:41:05,465
a combination of image proxy and image--

01:41:05,465 --> 01:41:08,190
- It's currently on this branch.

01:41:08,190 --> 01:41:09,259
I'm still working on it.

01:41:09,259 --> 01:41:10,211
- So it's still research?

01:41:10,211 --> 01:41:11,044
- [Radostin] Yeah.

01:41:11,044 --> 01:41:11,877
- Okay.

01:41:15,039 --> 01:41:16,310
Any more questions?

01:41:16,310 --> 01:41:19,988
- I guess (mumbles) so in terms of container times

01:41:19,988 --> 01:41:21,571
to use it and so on and so on,

01:41:21,571 --> 01:41:24,713
the long term is going to be that we would switch to this

01:41:24,713 --> 01:41:26,417
and then we would just have one socket

01:41:26,417 --> 01:41:28,205
for all communication between the two hosts

01:41:28,205 --> 01:41:29,468
when doing a migration, right?

01:41:29,468 --> 01:41:30,421
- Well yeah.

01:41:30,421 --> 01:41:34,025
You have a single TCP socket that you can just use.

01:41:34,025 --> 01:41:34,975
- [Man] Okay, neat.

01:41:34,975 --> 01:41:35,975
Sounds good.

01:41:39,799 --> 01:41:41,466
- [Man] Anyone else?

01:41:43,917 --> 01:41:47,391
- Andre, do you have any comments about this?

01:41:47,391 --> 01:41:49,308
Do you think we should?

01:41:52,158 --> 01:41:56,965
- So, I won't say that we have actually only one problem

01:41:56,965 --> 01:41:59,798
with the tmpfs, how we dump tmpfs.

01:42:01,244 --> 01:42:04,683
The problem with IP addresses and roads,

01:42:04,683 --> 01:42:08,016
it can be easier solved if we will dump,

01:42:10,093 --> 01:42:11,192
if we will dump roads

01:42:11,192 --> 01:42:15,696
and others in CRIU instead of running on IP too.

01:42:15,696 --> 01:42:16,529
- [Radostin] Yes.

01:42:16,529 --> 01:42:17,362
- Yeah, so.

01:42:17,362 --> 01:42:18,195
- Okay.

01:42:18,195 --> 01:42:20,657
So the only challenge is TMP interface

01:42:20,657 --> 01:42:21,527
and how do we solve it.

01:42:21,527 --> 01:42:24,777
- Yeah and how we can think how we can,

01:42:25,927 --> 01:42:28,760
right now we use tar to dump tmpfs

01:42:30,697 --> 01:42:33,359
to files and content of tmpfs mount

01:42:33,359 --> 01:42:36,455
but actually we can implement something in CRIU to

01:42:36,455 --> 01:42:38,916
to dump tmpfs and just,

01:42:38,916 --> 01:42:43,279
we don't need to start tar and we can use our own protocol

01:42:43,279 --> 01:42:46,650
for this and we will remove this dependence too.

01:42:46,650 --> 01:42:48,150
- [Radostin] Okay.

01:42:49,708 --> 01:42:50,824
- I understand that the problem with tar

01:42:50,824 --> 01:42:53,458
is that on the receive side you don't know

01:42:53,458 --> 01:42:55,488
how big the tmpfs mount needs to be?

01:42:55,488 --> 01:42:56,439
Is that what it is?

01:42:56,439 --> 01:42:57,721
- Well, it's kind of like that.

01:42:57,721 --> 01:43:00,465
Like, you basically don't know how much space

01:43:00,465 --> 01:43:05,239
you need to allocate so you can create like a small buffer.

01:43:05,239 --> 01:43:06,535
The way we currently solve that

01:43:06,535 --> 01:43:10,615
is by creating small chunks and then keep receiving

01:43:10,615 --> 01:43:14,198
until tar finish and then basically we just

01:43:18,800 --> 01:43:21,732
read from the buffer when we restore.

01:43:21,732 --> 01:43:22,743
- Oh, 'cause you stream tar.

01:43:22,743 --> 01:43:23,576
You don't--

01:43:23,576 --> 01:43:24,409
- [Radostin] Yeah.

01:43:24,409 --> 01:43:25,242
- Okay, all right.

01:43:25,242 --> 01:43:26,075
All right.

01:43:26,075 --> 01:43:26,931
Because I was gonna say why not send the size

01:43:26,931 --> 01:43:28,034
ahead of time but it's 'cause you stream it

01:43:28,034 --> 01:43:28,867
so you don't know what the size will be.

01:43:28,867 --> 01:43:29,700
- [Radostin] Yeah.

01:43:29,700 --> 01:43:30,533
- Okay.

01:43:32,419 --> 01:43:34,419
- Is that everything or?

01:43:37,175 --> 01:43:38,008
Okay, thank you.

01:43:38,008 --> 01:43:41,008
(audience clapping)

01:43:49,433 --> 01:43:52,016
(man laughing)

01:44:00,703 --> 01:44:04,286
(people chattering softly)

01:44:29,880 --> 01:44:30,864
- Hey.

01:44:30,864 --> 01:44:31,697
Hey, hey.

01:44:31,697 --> 01:44:32,530
Yeah, good.

01:44:32,530 --> 01:44:34,256
- [Man] So somebody else can throw it.

01:44:34,256 --> 01:44:36,839
(men laughing)

01:44:37,769 --> 01:44:39,993
- You have it right here.

01:44:39,993 --> 01:44:41,218
- [Man] Thank you.

01:44:41,218 --> 01:44:44,801
(people chattering softly)

01:44:53,583 --> 01:44:57,509
Well I hope there was an increase in my salary.

01:44:57,509 --> 01:45:01,092
(people chattering softly)

01:45:48,955 --> 01:45:52,653
- So I'm David Howells, I work for Redhat,

01:45:52,653 --> 01:45:54,820
in case you haven't guessed.

01:45:54,820 --> 01:45:58,829
I'm here to mostly to ask about how to use,

01:45:58,829 --> 01:46:02,079
how mount API can help with containers.

01:46:06,515 --> 01:46:10,740
So, here's a rough example of how the new mount API works.

01:46:10,740 --> 01:46:12,573
You open a file system

01:46:13,505 --> 01:46:16,622
and then you set configuration parameters

01:46:16,622 --> 01:46:18,823
using some new system calls.

01:46:18,823 --> 01:46:23,037
You create a mount point and then you move it into place.

01:46:23,037 --> 01:46:25,886
I've missed out some parameters here

01:46:25,886 --> 01:46:28,308
but this is just a rough illustration to make it easier

01:46:28,308 --> 01:46:32,058
to understand what I'm gonna talk about next.

01:46:33,747 --> 01:46:35,497
So the first thing is

01:46:37,727 --> 01:46:40,533
with the new fsconfig system call,

01:46:40,533 --> 01:46:42,419
it gives us the opportunity to do things

01:46:42,419 --> 01:46:45,803
like add UID and group ID, user ID

01:46:45,803 --> 01:46:50,026
and group ID translation tables to a mount point,

01:46:50,026 --> 01:46:52,563
to add to a new superblock or to a mount point

01:46:52,563 --> 01:46:54,483
as we create it.

01:46:54,483 --> 01:46:57,516
Before anyone else gets to see it.

01:46:57,516 --> 01:47:00,183
So when other people can see the

01:47:01,756 --> 01:47:04,931
published mount it is already set up

01:47:04,931 --> 01:47:08,431
where our translation table's been placed.

01:47:09,316 --> 01:47:12,245
What I'm trying to do is make the translation be done

01:47:12,245 --> 01:47:15,932
by the VFS so you don't need something like shiftfs

01:47:15,932 --> 01:47:18,757
to mount on it, to do the translation for you

01:47:18,757 --> 01:47:22,590
because mounting and its immediate file system

01:47:25,583 --> 01:47:28,083
has sort of efficiency issues,

01:47:29,412 --> 01:47:30,935
such as an image is about to skewed.

01:47:30,935 --> 01:47:32,426
- No, I'm not disagreeing, I'm just asking

01:47:32,426 --> 01:47:34,180
where are you doing the translation?

01:47:34,180 --> 01:47:35,581
'Cause we have to do the translation

01:47:35,581 --> 01:47:37,497
underneath the file system but on top

01:47:37,497 --> 01:47:39,592
because the user namespace does it on top.

01:47:39,592 --> 01:47:42,386
- I've been discussing that with Eric.

01:47:42,386 --> 01:47:46,497
There are two points of translation that we can deal with.

01:47:46,497 --> 01:47:47,993
One is actually in the file system

01:47:47,993 --> 01:47:50,699
so we can install a translation table

01:47:50,699 --> 01:47:54,560
on the superblock that translates device IDs

01:47:54,560 --> 01:47:56,749
to KUIDs and back again.

01:47:56,749 --> 01:47:58,719
That's one possibility.

01:47:58,719 --> 01:48:03,521
And the other is to add an extra translation table

01:48:03,521 --> 01:48:07,316
into the user namespace where you can

01:48:07,316 --> 01:48:10,816
put translations from particular use KUIDs

01:48:12,108 --> 01:48:15,858
for the KUIDs and then we would look this up.

01:48:17,224 --> 01:48:18,566
- And then when you cache it into the tray.

01:48:18,566 --> 01:48:22,420
- We can cache these in certain places like the credentials.

01:48:22,420 --> 01:48:24,957
(man speaking softly)

01:48:24,957 --> 01:48:28,195
We got a mic, give him a microphone.

01:48:28,195 --> 01:48:32,278
- Yeah so the credential since it only represents

01:48:33,407 --> 01:48:37,397
one point of translation, you can cache the translation

01:48:37,397 --> 01:48:42,397
if you only have, you have it in the user namespace.

01:48:42,439 --> 01:48:43,835
- [David] If it helps, I have a picture.

01:48:43,835 --> 01:48:44,818
- Yeah.

01:48:44,818 --> 01:48:45,784
(laughing)

01:48:45,784 --> 01:48:46,636
Yeah.

01:48:46,636 --> 01:48:48,007
- This is what I was thinking of

01:48:48,007 --> 01:48:50,997
before I talked to Eric about it at lunchtime (mumbles).

01:48:50,997 --> 01:48:52,080
- Yeah, yeah.

01:48:53,731 --> 01:48:54,627
Um, yeah.

01:48:54,627 --> 01:48:58,123
And the challenge is, you know, if these represent,

01:48:58,123 --> 01:49:01,853
these would be like struct cred for those guys.

01:49:01,853 --> 01:49:03,947
You do the translation in here

01:49:03,947 --> 01:49:07,537
between the KUIDs and the file system.

01:49:07,537 --> 01:49:09,952
- So but we might want to put an asymmetric,

01:49:09,952 --> 01:49:12,751
an asymmetric translation over here

01:49:12,751 --> 01:49:16,334
so you do a vector it uses that translation

01:49:18,741 --> 01:49:20,753
but if you're reading this file with that

01:49:20,753 --> 01:49:24,818
or a file with that, it's translates it to that.

01:49:24,818 --> 01:49:29,149
So that you can have files with different UIDs,

01:49:29,149 --> 01:49:32,255
appearing as the same UID in the container

01:49:32,255 --> 01:49:34,347
but if you create something,

01:49:34,347 --> 01:49:38,097
you know exactly what it's gonna be later on.

01:49:39,427 --> 01:49:42,094
So we leave pairs on the medium.

01:49:44,979 --> 01:49:49,333
So what Eric was, that's the superblock translation there

01:49:49,333 --> 01:49:52,616
where Eric was suggesting that we need another

01:49:52,616 --> 01:49:55,592
translation here because these may actually

01:49:55,592 --> 01:49:57,362
be represented by different KUIDs

01:49:57,362 --> 01:50:01,343
and I didn't realize this when I made the diagram.

01:50:01,343 --> 01:50:03,545
- So, anyway, this is a possibility.

01:50:03,545 --> 01:50:05,708
Looking at it, it looks like it has potential.

01:50:05,708 --> 01:50:08,136
I don't think we have any code for any of this yet.

01:50:08,136 --> 01:50:08,989
Right?

01:50:08,989 --> 01:50:10,380
- Just probably the stuff that's already

01:50:10,380 --> 01:50:11,634
in the user namespace.

01:50:11,634 --> 01:50:12,486
- Okay.

01:50:12,486 --> 01:50:14,760
- That we could hopefully make use of.

01:50:14,760 --> 01:50:16,132
- Yeah.

01:50:16,132 --> 01:50:17,043
- For this.

01:50:17,043 --> 01:50:20,271
- So, but that's the potential of the mount API.

01:50:20,271 --> 01:50:22,583
Did you have more you wanna talk about

01:50:22,583 --> 01:50:25,333
than the translation possibility?

01:50:26,814 --> 01:50:30,501
- Yeah, 'cause, well, another thing that occurs to us

01:50:30,501 --> 01:50:34,700
if you got a translation table on the superblock,

01:50:34,700 --> 01:50:37,117
these do not have to be U32s.

01:50:39,103 --> 01:50:43,096
These could be name strings or like you get from NFS

01:50:43,096 --> 01:50:47,230
or they could be, say, UIDs, like you get from sys

01:50:47,230 --> 01:50:49,457
so this could be a block rather than a number

01:50:49,457 --> 01:50:52,903
and that would make it easier to translate,

01:50:52,903 --> 01:50:55,150
potentially make it easier to translate

01:50:55,150 --> 01:50:59,233
very foreign user IDs from a network file system.

01:51:02,661 --> 01:51:04,205
- So your plan is to replace

01:51:04,205 --> 01:51:07,591
the NFS UID translation daemon as well?

01:51:07,591 --> 01:51:09,829
- Not necessarily.

01:51:09,829 --> 01:51:14,167
That could add translations to the table eventually.

01:51:14,167 --> 01:51:16,120
- Okay, well I get it's theoretically possible.

01:51:16,120 --> 01:51:20,114
We still have to see it work in practice.

01:51:20,114 --> 01:51:21,989
- Any further comments on this bit

01:51:21,989 --> 01:51:23,529
before I move onto the next?

01:51:23,529 --> 01:51:25,691
- So this would mean, just to clarify,

01:51:25,691 --> 01:51:27,385
I think we already established this

01:51:27,385 --> 01:51:30,089
but this would mean it's not actually tied

01:51:30,089 --> 01:51:31,323
to a user namespace.

01:51:31,323 --> 01:51:33,807
You could also make use of this translation mechanism

01:51:33,807 --> 01:51:36,314
independent of user namespaces because there are a lot of--

01:51:36,314 --> 01:51:38,810
- Well, so there's two translation mechanisms

01:51:38,810 --> 01:51:40,178
and you can use one or both of them.

01:51:40,178 --> 01:51:41,454
- [Man] Cool, yes.

01:51:41,454 --> 01:51:42,364
- Yeah.

01:51:42,364 --> 01:51:43,506
And one is trying to use an pid space,

01:51:43,506 --> 01:51:44,742
the other isn't.

01:51:44,742 --> 01:51:46,129
- [Man] Yeah, the classic example, I think, is,

01:51:46,129 --> 01:51:47,888
for this one is for instance where you have a USB stick

01:51:47,888 --> 01:51:50,050
where you want it to be, sorry.

01:51:50,050 --> 01:51:52,231
Yeah so this is a use case,

01:51:52,231 --> 01:51:55,861
a specific use cases so, you can chime

01:51:55,861 --> 01:51:57,701
in there as well if you want.

01:51:57,701 --> 01:52:00,514
So this comes, for example, from System D

01:52:00,514 --> 01:52:03,779
where they want to basically have a home directory

01:52:03,779 --> 01:52:06,531
on a USB stick that you can portably carry around

01:52:06,531 --> 01:52:09,843
to different computers and the UID and GID mappings

01:52:09,843 --> 01:52:12,000
that are actually on the USB stick, for example,

01:52:12,000 --> 01:52:13,095
don't really matter.

01:52:13,095 --> 01:52:16,197
You just plug it in and then, in this case,

01:52:16,197 --> 01:52:18,363
System D would gain logic to automatically

01:52:18,363 --> 01:52:21,863
translate wherever the transit UID or GID,

01:52:23,854 --> 01:52:26,563
the system gives you on that.

01:52:26,563 --> 01:52:27,751
- [David] Yeah, you could do that too.

01:52:27,751 --> 01:52:28,602
- Exactly.

01:52:28,602 --> 01:52:31,789
- I was thinking more if your computer,

01:52:31,789 --> 01:52:34,893
sorry, your computer and there's a server over there

01:52:34,893 --> 01:52:37,770
are you've been allocated user ID on it

01:52:37,770 --> 01:52:40,237
and you translate that to your own user ID.

01:52:40,237 --> 01:52:41,251
- So this is hopefully,

01:52:41,251 --> 01:52:43,010
it's probably fine to talk about this

01:52:43,010 --> 01:52:45,995
but this is actively being worked on in System D

01:52:45,995 --> 01:52:48,942
and so the way they're doing right now

01:52:48,942 --> 01:52:51,009
is think that the solution they have for this,

01:52:51,009 --> 01:52:52,285
if you want to do something like this

01:52:52,285 --> 01:52:54,679
is just brutally recursively tone

01:52:54,679 --> 01:52:57,058
and so this would let you get

01:52:57,058 --> 01:53:00,113
around all of these limitations.

01:53:00,113 --> 01:53:02,467
- So, yeah, that would be the mapping.

01:53:02,467 --> 01:53:05,573
I think, if I understand, on the superblock

01:53:05,573 --> 01:53:07,731
and what we're talking about is something

01:53:07,731 --> 01:53:12,398
roughly equivalent to generalizing NFS's user ID mapping

01:53:13,381 --> 01:53:16,731
so it can be used with more file systems.

01:53:16,731 --> 01:53:17,582
- [David] Yeah.

01:53:17,582 --> 01:53:18,883
- [Man] Or facts one as well, yeah.

01:53:18,883 --> 01:53:21,529
- I'm not sure fat houses user IDs but--

01:53:21,529 --> 01:53:23,383
- [Man] Is it fat or no?

01:53:23,383 --> 01:53:24,796
No, NTFS, sorry.

01:53:24,796 --> 01:53:27,494
- NTFS, yeah, they have (mumbles).

01:53:27,494 --> 01:53:28,352
- UID, GID thing.

01:53:28,352 --> 01:53:29,505
(David mumbling)

01:53:29,505 --> 01:53:31,472
Yeah, yeah, so same thing but generalized, yeah.

01:53:31,472 --> 01:53:33,973
- So yeah, it make sense to have a generalized layer

01:53:33,973 --> 01:53:36,473
that goes to the file systems.

01:53:37,896 --> 01:53:41,504
Now, that doesn't solve the mini to one problem

01:53:41,504 --> 01:53:43,266
we need for a shared root.

01:53:43,266 --> 01:53:44,118
- [Man] Yeah.

01:53:44,118 --> 01:53:44,968
- [David] Sure, yeah.

01:53:44,968 --> 01:53:46,506
- But it's all the rest of them.

01:53:46,506 --> 01:53:47,540
So it.

01:53:47,540 --> 01:53:50,162
- That was the other translation table,

01:53:50,162 --> 01:53:51,896
the one over this side

01:53:51,896 --> 01:53:56,202
that I haven't actually got on the diagram.

01:53:56,202 --> 01:54:00,119
So any other comments on this before I move on?

01:54:01,890 --> 01:54:02,723
Nope.

01:54:03,847 --> 01:54:06,847
So, how to make use of the mount API

01:54:09,721 --> 01:54:13,471
to do unprivileged mounts inside a container.

01:54:14,368 --> 01:54:16,619
We have a file descript, fsmount,

01:54:16,619 --> 01:54:19,952
sorry, fsopen gives us a file descriptor

01:54:21,209 --> 01:54:23,564
and objects inside the kernel cache

01:54:23,564 --> 01:54:25,965
that when you do fsconfig, fsconfig, fsconfig

01:54:25,965 --> 01:54:30,278
it detaches the parameters to the object in the kernel.

01:54:30,278 --> 01:54:34,574
You then call fsmount to actually create your mount point.

01:54:34,574 --> 01:54:36,693
At that point, the possibility exists

01:54:36,693 --> 01:54:40,593
that we could talk, suspend the process

01:54:40,593 --> 01:54:44,412
that's doing the mount and talk to the container supervisor,

01:54:44,412 --> 01:54:47,183
whatever that happens to mean

01:54:47,183 --> 01:54:52,183
and say, here's the file descript point in fs_context,

01:54:52,346 --> 01:54:54,574
the object in the kernel.

01:54:54,574 --> 01:54:58,923
Tell me whether I can allow this or I should reject it.

01:54:58,923 --> 01:55:02,256
And also, you can make alterations to it

01:55:03,631 --> 01:55:06,158
so that you can set certain parameters.

01:55:06,158 --> 01:55:08,840
You say you must have that parameter.

01:55:08,840 --> 01:55:11,648
So fsinfo is something you haven't seen yet.

01:55:11,648 --> 01:55:13,754
It's been pushed a few times

01:55:13,754 --> 01:55:15,786
but it's not upstream yet.

01:55:15,786 --> 01:55:18,145
That allows you to look inside the context

01:55:18,145 --> 01:55:21,391
and read the parameters from it.

01:55:21,391 --> 01:55:23,118
Fsconfig is the same as before.

01:55:23,118 --> 01:55:26,240
So you can set parameters, delete parameters.

01:55:26,240 --> 01:55:28,657
- This is basically the mount equivalent

01:55:28,657 --> 01:55:31,259
of the seccomp notifier of the (laughing).

01:55:31,259 --> 01:55:32,201
(David mumbling)

01:55:32,201 --> 01:55:33,152
To some extent, yes.

01:55:33,152 --> 01:55:34,203
Sorry, you went around.

01:55:34,203 --> 01:55:37,301
Yeah so this would be an upcall, right?

01:55:37,301 --> 01:55:39,235
- I'm sorry, yeah.

01:55:39,235 --> 01:55:42,529
Basically, the kernel says to the manager,

01:55:42,529 --> 01:55:44,980
attention needed at the kernel

01:55:44,980 --> 01:55:47,464
and somehow we get the file descriptor

01:55:47,464 --> 01:55:48,963
to the manager when he asks for it

01:55:48,963 --> 01:55:50,906
and the manager says, yay or nay

01:55:50,906 --> 01:55:55,882
and possibly amends a thing and it can read the parameters.

01:55:55,882 --> 01:55:57,763
- I guess the question, I have a question which is

01:55:57,763 --> 01:55:58,952
would there be a plan to make it

01:55:58,952 --> 01:56:01,446
since you can filter down because the downside is that,

01:56:01,446 --> 01:56:04,255
sorry, with seccomp user notify you couldn't filter this

01:56:04,255 --> 01:56:05,852
even if we had deep syscall inspection

01:56:05,852 --> 01:56:09,379
because you have an FD, not a struct that you can inspect.

01:56:09,379 --> 01:56:10,230
I guess the question is--

01:56:10,230 --> 01:56:11,817
- [David] So filtering what?

01:56:11,817 --> 01:56:13,358
What do you mean by filter it?

01:56:13,358 --> 01:56:16,338
- As in you could say that I only want to be able

01:56:16,338 --> 01:56:19,343
to do special operations on some file systems.

01:56:19,343 --> 01:56:22,148
- [David] Are you talking about with this seccomp?

01:56:22,148 --> 01:56:24,652
- Yeah but what I'm trying to say is that

01:56:24,652 --> 01:56:26,483
because this is not using seccomp, this is gonna use

01:56:26,483 --> 01:56:27,713
and upcall or something like that,

01:56:27,713 --> 01:56:29,504
like a different mechanism, my point is that

01:56:29,504 --> 01:56:31,636
is there a plan to make it, so for instance,

01:56:31,636 --> 01:56:33,919
you could make it so that you filter so you say

01:56:33,919 --> 01:56:36,560
I only want to get an upcall for these particular mounts

01:56:36,560 --> 01:56:38,040
or something like that because--

01:56:38,040 --> 01:56:38,918
- Hadn't considered that.

01:56:38,918 --> 01:56:40,675
That would be a distinct possibility, yes.

01:56:40,675 --> 01:56:43,288
- You couldn't do, the point is you couldn't emulate

01:56:43,288 --> 01:56:45,848
this with seccomp if you could filter a file system

01:56:45,848 --> 01:56:48,751
because there isn't a way to do it with seccomp.

01:56:48,751 --> 01:56:51,244
- But there is, isn't there?

01:56:51,244 --> 01:56:53,823
Because we can get access, as long as we know

01:56:53,823 --> 01:56:57,080
the PID that instigated this, we can get proxies PID

01:56:57,080 --> 01:56:59,165
and if you're privileged enough, proxies PIDFD.

01:56:59,165 --> 01:57:01,566
So you can get a hold of the FD

01:57:01,566 --> 01:57:02,946
as long as you know its number.

01:57:02,946 --> 01:57:03,798
- Oh right, no sorry.

01:57:03,798 --> 01:57:04,875
What I mean is that, no sorry,

01:57:04,875 --> 01:57:07,569
you could do it but you couldn't emulate in kernel filtering

01:57:07,569 --> 01:57:10,236
because even with the--

01:57:10,236 --> 01:57:13,234
- I could provide in kernel filtering.

01:57:13,234 --> 01:57:15,286
- Yeah, I was just asking is there an idea

01:57:15,286 --> 01:57:16,936
to have something like that, yes.

01:57:16,936 --> 01:57:21,087
- But it require support from the file systems probably

01:57:21,087 --> 01:57:25,246
because, to do anything other than file system type

01:57:25,246 --> 01:57:28,597
and probably file system source because the parameters

01:57:28,597 --> 01:57:31,466
are, had to be compiled only to.

01:57:31,466 --> 01:57:32,318
- [Man] Okay.

01:57:32,318 --> 01:57:35,036
- In general, I like the idea

01:57:35,036 --> 01:57:38,428
but it points to me, maybe I'm just thinking wrong,

01:57:38,428 --> 01:57:41,759
but it points to a more pressing problem that we have

01:57:41,759 --> 01:57:43,567
and I'm not sure if you're going to address it

01:57:43,567 --> 01:57:45,860
on the next slide which is before we have supervised

01:57:45,860 --> 01:57:48,024
unprivileged mount, which is very advanced,

01:57:48,024 --> 01:57:51,653
we should probably have a way to mount across namespaces,

01:57:51,653 --> 01:57:52,731
mount namespaces.

01:57:52,731 --> 01:57:54,050
- [David] I have no problem with that.

01:57:54,050 --> 01:57:55,580
- Mount loop should do that.

01:57:55,580 --> 01:57:56,431
(David laughs)

01:57:56,431 --> 01:57:57,283
- [David] No.

01:57:57,283 --> 01:57:58,116
- So this is really a problem right now.

01:57:58,116 --> 01:57:58,949
I mean, we--

01:57:58,949 --> 01:58:02,698
- The problem is not technical, it's Al.

01:58:02,698 --> 01:58:04,924
He doesn't like the idea of doing this.

01:58:04,924 --> 01:58:06,438
- No.

01:58:06,438 --> 01:58:08,609
The mount loop did it, it used to.

01:58:08,609 --> 01:58:11,605
- No, mount loop will not move across namespaces.

01:58:11,605 --> 01:58:13,532
- No, but can't you do,

01:58:13,532 --> 01:58:17,615
so, last time I looked at this API it supported this,

01:58:17,615 --> 01:58:21,445
you do the thing that creates the anonymous namespace

01:58:21,445 --> 01:58:23,527
and then you mount loop into another namespace.

01:58:23,527 --> 01:58:26,130
You clone it and then you attach it.

01:58:26,130 --> 01:58:27,701
- Yeah, when I first did this I had it

01:58:27,701 --> 01:58:29,717
so you could mount into another namespace.

01:58:29,717 --> 01:58:30,877
Al's taken that away.

01:58:30,877 --> 01:58:33,262
He thinks that's a security hole or something.

01:58:33,262 --> 01:58:34,192
I'm not quite sure.

01:58:34,192 --> 01:58:37,098
- And the thing is from a containers perspective,

01:58:37,098 --> 01:58:39,105
that's something we really need

01:58:39,105 --> 01:58:42,604
because right now we have like hacky workarounds.

01:58:42,604 --> 01:58:46,585
So it's possible to do this using mount propagation.

01:58:46,585 --> 01:58:51,585
Also, it's unclear why this would be a security issue

01:58:51,645 --> 01:58:54,420
if you can do it through mount propagation.

01:58:54,420 --> 01:58:57,706
Actually this was regressed because of the new mount API

01:58:57,706 --> 01:59:01,520
which you and Al fixed after I reported it.

01:59:01,520 --> 01:59:06,236
So, he seems apparently fine that this is possible.

01:59:06,236 --> 01:59:07,204
- [Man] Okay.

01:59:07,204 --> 01:59:08,037
- Right?

01:59:08,037 --> 01:59:10,551
So mount propagation, you basically have a shared mount path

01:59:10,551 --> 01:59:13,654
that you set up before you start the container.

01:59:13,654 --> 01:59:15,628
Then you mount on the host side,

01:59:15,628 --> 01:59:17,195
onto that shared mount point

01:59:17,195 --> 01:59:20,315
and then inside of the container you do a mount move.

01:59:20,315 --> 01:59:22,257
At which point, you have to mount in a container,

01:59:22,257 --> 01:59:24,655
you can unmount from the host and you have injected

01:59:24,655 --> 01:59:25,755
a mount into a container.

01:59:25,755 --> 01:59:28,064
But that's really, I mean, that's really hacky, right?

01:59:28,064 --> 01:59:28,914
- [Man] Yeah.

01:59:28,914 --> 01:59:30,614
- It would be way nicer if the container manager

01:59:30,614 --> 01:59:32,509
without the container having had a shared,

01:59:32,509 --> 01:59:34,950
basically a tunnel into the host could just say,

01:59:34,950 --> 01:59:36,250
give me a mount in there.

01:59:36,250 --> 01:59:38,938
- 'Cause when I first did this,

01:59:38,938 --> 01:59:42,330
you (mumbles) kernel container object

01:59:42,330 --> 01:59:43,804
which various people objected to

01:59:43,804 --> 01:59:46,096
but you got the file descriptor from that

01:59:46,096 --> 01:59:50,513
and you could mount using that in place of AT FD CWD.

01:59:52,985 --> 01:59:56,467
So that using a move mount, you use a path

01:59:56,467 --> 02:00:00,756
of the file descriptor plus the direct file,

02:00:00,756 --> 02:00:03,197
best direct file descriptor in the path.

02:00:03,197 --> 02:00:05,226
And so, you could use that to mount loads of things

02:00:05,226 --> 02:00:09,944
into the mount tree referred to by the container object.

02:00:09,944 --> 02:00:14,378
So if I've got a file descriptor representing a mount,

02:00:14,378 --> 02:00:19,378
a mount namespace, I don't personally see any reason why

02:00:19,747 --> 02:00:21,334
you shouldn't be able to use move mount,

02:00:21,334 --> 02:00:23,577
move new mounts into that.

02:00:23,577 --> 02:00:25,133
Just Al doesn't like it.

02:00:25,133 --> 02:00:27,298
- So, here's my question

02:00:27,298 --> 02:00:30,060
and maybe I'm completely confused

02:00:30,060 --> 02:00:32,072
because I know the code looked like

02:00:32,072 --> 02:00:34,289
it supported this earlier,

02:00:34,289 --> 02:00:38,017
is if you do, whatever the copy tree thing is

02:00:38,017 --> 02:00:40,997
that creates you a floating set of mounts

02:00:40,997 --> 02:00:43,799
and it's anonymous mount namespace.

02:00:43,799 --> 02:00:45,221
- [David] I think that's right still.

02:00:45,221 --> 02:00:46,074
- Yeah.

02:00:46,074 --> 02:00:48,549
- I don't exactly follow the anonymous namespace thing but.

02:00:48,549 --> 02:00:51,987
- Well, that's what it does so it doesn't have other bugs.

02:00:51,987 --> 02:00:54,639
But yeah, it's this floating set of mounts

02:00:54,639 --> 02:00:56,809
that are attached to your file descriptor

02:00:56,809 --> 02:00:58,992
that aren't attached to anything real.

02:00:58,992 --> 02:01:03,109
And then, you take that file and then you like setns

02:01:03,109 --> 02:01:06,243
into your mount namespace and then you move mount

02:01:06,243 --> 02:01:08,881
onto your current mount namespace.

02:01:08,881 --> 02:01:12,012
That should, I think that works.

02:01:12,012 --> 02:01:13,996
- Yeah, I suppose that would work.

02:01:13,996 --> 02:01:15,719
'Cause what I was thinking you shouldn't need

02:01:15,719 --> 02:01:17,255
to do the setns necessarily.

02:01:17,255 --> 02:01:19,218
- Yeah but the thing is the setns is the part

02:01:19,218 --> 02:01:21,258
which is effective like the MS move thing.

02:01:21,258 --> 02:01:22,349
It's the same idea which is that

02:01:22,349 --> 02:01:25,596
you're joining the namespace.

02:01:25,596 --> 02:01:27,237
As in, is there a way to inject it

02:01:27,237 --> 02:01:29,326
without doing the namespace?

02:01:29,326 --> 02:01:31,409
- Basically, your original idea was right.

02:01:31,409 --> 02:01:34,869
For example, you specify a mount namespace

02:01:34,869 --> 02:01:37,070
by passing NFD or something.

02:01:37,070 --> 02:01:39,361
- [David] There's a reference to it.

02:01:39,361 --> 02:01:41,758
- If you just pass the fd that represents the mounts

02:01:41,758 --> 02:01:44,489
between processes, to the process.

02:01:44,489 --> 02:01:45,343
- Sure.

02:01:45,343 --> 02:01:47,987
Though with what I'm talking about here,

02:01:47,987 --> 02:01:51,216
the mount is actually done inside the container.

02:01:51,216 --> 02:01:55,466
And then the fd is passed back the manager

02:01:55,466 --> 02:01:58,472
who can then read the parameters and say yes or no,

02:01:58,472 --> 02:01:59,324
sort of thing.

02:01:59,324 --> 02:02:00,777
- Yeah.

02:02:00,777 --> 02:02:03,333
- Just so I'm clear, this can all be used on binds, right?

02:02:03,333 --> 02:02:05,299
So we can use arbitrary parts of the sub tree.

02:02:05,299 --> 02:02:06,785
- Yes, it could work on binds too.

02:02:06,785 --> 02:02:10,245
- So where is the fs, so the fsconfig information

02:02:10,245 --> 02:02:12,213
has to be persistent.

02:02:12,213 --> 02:02:14,423
Where do we persist it?

02:02:14,423 --> 02:02:16,007
- It's in the context.

02:02:16,007 --> 02:02:20,924
Well, fsinfo will read from a context or a live superblock.

02:02:22,400 --> 02:02:25,001
- Right but once it passes the config to the mount,

02:02:25,001 --> 02:02:27,179
right, the file descriptor is gone.

02:02:27,179 --> 02:02:29,368
How does the mount gain access to tables

02:02:29,368 --> 02:02:30,444
and everything else?

02:02:30,444 --> 02:02:32,385
Where is the information actually stored?

02:02:32,385 --> 02:02:34,566
Because for a bind mount, you have no superblocks

02:02:34,566 --> 02:02:35,438
to store it in.

02:02:35,438 --> 02:02:36,845
- Actually, yeah, I'm not sure.

02:02:36,845 --> 02:02:38,393
You can make it handled by mount.

02:02:38,393 --> 02:02:40,454
Currently we don't 'cause I can create the fs--

02:02:40,454 --> 02:02:41,711
- Well that was the whole problem with shiftfs

02:02:41,711 --> 02:02:42,561
was created for.

02:02:42,561 --> 02:02:44,775
If we have a superblock, we can easily fix this

02:02:44,775 --> 02:02:47,019
but for doing most bind mounts

02:02:47,019 --> 02:02:49,422
we don't have a superblock so we can't fix it.

02:02:49,422 --> 02:02:50,827
That's why we needed shiftfs.

02:02:50,827 --> 02:02:52,692
- 'Cause with bind mounts what you do,

02:02:52,692 --> 02:02:56,525
you do call fspick which gets you a configured

02:02:59,254 --> 02:03:03,921
file system and then you do fsmount move mount off that.

02:03:05,213 --> 02:03:06,654
- So if you can solve the problem,

02:03:06,654 --> 02:03:09,277
so the reason we did shiftfs is because

02:03:09,277 --> 02:03:11,670
it is basically a bind mount in a superblock

02:03:11,670 --> 02:03:13,720
and we then hang information off the superblock

02:03:13,720 --> 02:03:14,999
which includes the tables.

02:03:14,999 --> 02:03:17,234
If you can find a way of hanging the information--

02:03:17,234 --> 02:03:21,734
- There's another sys, you saw fsopen, on the example.

02:03:23,644 --> 02:03:27,457
Instead, you do fspick and say this directory.

02:03:27,457 --> 02:03:30,898
Then you call fsmount which creates you a new mount

02:03:30,898 --> 02:03:34,898
to the same place and you specify where in that,

02:03:37,257 --> 02:03:40,257
the thing you're looking at you want

02:03:41,206 --> 02:03:43,926
'cause a bind mount can get you a part

02:03:43,926 --> 02:03:46,009
or a submount of a mount.

02:03:47,181 --> 02:03:49,848
So fspick can get you a submount

02:03:51,349 --> 02:03:54,190
and then you get this fd.

02:03:54,190 --> 02:03:57,505
You can do that and then, this sort of thing,

02:03:57,505 --> 02:03:59,754
and then you can use that to reconfigure it

02:03:59,754 --> 02:04:02,665
or you can call fsmount so you can skip,

02:04:02,665 --> 02:04:06,214
ignore these two lines, fsmount move_mount.

02:04:06,214 --> 02:04:08,825
- But when you call this fsmount,

02:04:08,825 --> 02:04:11,166
effectively you've lost the information

02:04:11,166 --> 02:04:13,119
in the file descriptor because it's been transferred

02:04:13,119 --> 02:04:14,466
to the mount itself.

02:04:14,466 --> 02:04:17,043
- But fsinfo will read it from the superblock

02:04:17,043 --> 02:04:18,419
if you have a superblock.

02:04:18,419 --> 02:04:20,185
If the superblock isn't there it will read it

02:04:20,185 --> 02:04:23,573
from the parameters stored in the object,

02:04:23,573 --> 02:04:25,323
the fscontext object.

02:04:26,664 --> 02:04:28,875
- So you have to keep the fscontext object alive?

02:04:28,875 --> 02:04:31,061
- Right so the fd is still alive

02:04:31,061 --> 02:04:32,176
all the way through.

02:04:32,176 --> 02:04:33,449
It's still alive here.

02:04:33,449 --> 02:04:35,193
That's gonna go through to I mount.

02:04:35,193 --> 02:04:36,097
(mumbles)

02:04:36,097 --> 02:04:39,341
- Okay so if the fd is the carrier

02:04:39,341 --> 02:04:41,214
of information that should work.

02:04:41,214 --> 02:04:42,882
- So that, yeah.

02:04:42,882 --> 02:04:44,363
- But that's the complexity.

02:04:44,363 --> 02:04:46,112
That's the reason we needed shiftfs.

02:04:46,112 --> 02:04:47,502
That was the complexity.

02:04:47,502 --> 02:04:50,669
- And what David and I were sketching,

02:04:53,030 --> 02:04:56,101
we were talking privately, was it looks like

02:04:56,101 --> 02:04:58,371
we can get this down to just needing one bit

02:04:58,371 --> 02:05:00,871
in the VFS mount that says use

02:05:01,841 --> 02:05:04,899
this alternative translation table.

02:05:04,899 --> 02:05:06,829
- [David] Oh, for the UID thing?

02:05:06,829 --> 02:05:09,560
- Yeah, for the UID mapping thing.

02:05:09,560 --> 02:05:11,622
And so, that, you know,

02:05:11,622 --> 02:05:14,872
so it might be very reasonable to do it

02:05:16,370 --> 02:05:19,350
with very little state and we got down to that

02:05:19,350 --> 02:05:22,807
because we need to be able to cache things

02:05:22,807 --> 02:05:25,092
if we were gonna use override cred

02:05:25,092 --> 02:05:29,259
because if you don't cache it, known RCU problems.

02:05:30,959 --> 02:05:32,531
- If everyone's happy with that,

02:05:32,531 --> 02:05:34,531
I've got one more slide.

02:05:35,367 --> 02:05:36,367
- I'm sorry.

02:05:37,716 --> 02:05:42,133
- So the thing is default parameters for superblocks.

02:05:44,161 --> 02:05:46,794
So one of the problems we've got with automounts

02:05:46,794 --> 02:05:50,088
is you don't get a chance to parameterise in automount.

02:05:50,088 --> 02:05:51,575
When you make an automount you give mount

02:05:51,575 --> 02:05:53,607
a lot of parameters like things with NFS,

02:05:53,607 --> 02:05:56,313
you've got timeouts, window sizes.

02:05:56,313 --> 02:05:58,771
You can't do that with automount.

02:05:58,771 --> 02:06:00,861
Or at least you can if you use autofs

02:06:00,861 --> 02:06:03,069
but not if it's not when you step on inside

02:06:03,069 --> 02:06:05,319
it's another, inside an NFS

02:06:06,821 --> 02:06:08,990
because you may cross the domain

02:06:08,990 --> 02:06:10,735
and then the new domain,

02:06:10,735 --> 02:06:12,944
you may want to give it completely different parameters

02:06:12,944 --> 02:06:14,111
but you can't.

02:06:15,022 --> 02:06:18,648
So what I'm proposing is that we provide a way

02:06:18,648 --> 02:06:23,565
to either preload or upcall for parameters for superblocks.

02:06:26,382 --> 02:06:28,367
So you can say if you see this mount

02:06:28,367 --> 02:06:33,367
for this superblock, (mumbles) this type of file,

02:06:34,968 --> 02:06:38,428
this source, use these parameters,

02:06:38,428 --> 02:06:41,428
set these parameters as the default.

02:06:42,379 --> 02:06:44,052
Question is if I'm doing that,

02:06:44,052 --> 02:06:46,211
should I load them, you load them in advance,

02:06:46,211 --> 02:06:49,192
say at boot, into the kernel or does the kernel

02:06:49,192 --> 02:06:50,497
load them on demand?

02:06:50,497 --> 02:06:53,306
So either upcall or go and actually read a file

02:06:53,306 --> 02:06:54,288
if you use a bit there.

02:06:54,288 --> 02:06:57,030
(man speaking softly)

02:06:57,030 --> 02:06:57,880
No, no.

02:06:57,880 --> 02:06:59,578
If you're doing it to boot,

02:06:59,578 --> 02:07:02,174
the boot would say here's a real, here's a real,

02:07:02,174 --> 02:07:06,651
here's a real, here's a real (mumbles).

02:07:06,651 --> 02:07:09,095
- Probably if you wanted to do something on demand,

02:07:09,095 --> 02:07:12,546
the thing that makes sense is to like create the mount

02:07:12,546 --> 02:07:16,562
someplace where you can get at it with fsconfig.

02:07:16,562 --> 02:07:19,407
Send a notification to userspace

02:07:19,407 --> 02:07:21,350
and userspace use the existing calls.

02:07:21,350 --> 02:07:22,183
- Yeah, that's one possibility.

02:07:22,183 --> 02:07:23,016
Yeah.

02:07:23,016 --> 02:07:25,743
Same as the previous thing.

02:07:25,743 --> 02:07:26,999
That the reals are on the inside.

02:07:26,999 --> 02:07:28,712
Here you are, please give me default parameters.

02:07:28,712 --> 02:07:31,129
That's one possibility, yeah.

02:07:32,196 --> 02:07:34,805
So would this be useful in containers too,

02:07:34,805 --> 02:07:36,164
this sort of thing?

02:07:36,164 --> 02:07:38,634
Particularly for unprivileged mounts,

02:07:38,634 --> 02:07:40,061
you preset the defaults

02:07:40,061 --> 02:07:42,155
and then you can rule on it again later.

02:07:42,155 --> 02:07:45,177
- I don't know for containers but this again

02:07:45,177 --> 02:07:47,747
seems like something that might interest

02:07:47,747 --> 02:07:50,884
something that is an init system

02:07:50,884 --> 02:07:53,536
because they have much more use for this

02:07:53,536 --> 02:07:56,203
than I guess the container case.

02:07:58,211 --> 02:08:02,478
- And mount notifications, I keep hearing,

02:08:02,478 --> 02:08:06,608
now some part of me thinks that I've been hearing people

02:08:06,608 --> 02:08:08,867
wanting better mount notifications

02:08:08,867 --> 02:08:11,065
to when a mount happens so that people can do something.

02:08:11,065 --> 02:08:12,471
- We have something that do that.

02:08:12,471 --> 02:08:13,603
(laughing)

02:08:13,603 --> 02:08:15,015
I don't have a slide on it.

02:08:15,015 --> 02:08:16,932
- Absolutely, for sure.

02:08:18,785 --> 02:08:22,326
Mount notification would be really helpful.

02:08:22,326 --> 02:08:26,243
And also, especially also doing it recursively.

02:08:27,994 --> 02:08:30,096
That would be really helpful

02:08:30,096 --> 02:08:32,088
because currently we have no easy mechanism.

02:08:32,088 --> 02:08:36,402
You could probably try to do it with a fan notify, right?

02:08:36,402 --> 02:08:39,561
- [David] That is through the recursive case, I think.

02:08:39,561 --> 02:08:42,982
- I think they recently enabled something like this

02:08:42,982 --> 02:08:45,787
but the problem is it requires you to be capable

02:08:45,787 --> 02:08:47,657
with CAP_SYS_ADMIN.

02:08:47,657 --> 02:08:49,095
Like, there are three checks

02:08:49,095 --> 02:08:50,921
that ask for a capable CAP_SYS_ADMIN

02:08:50,921 --> 02:08:53,284
and last I talked to people, they're like, eh,

02:08:53,284 --> 02:08:55,273
we're not sure we wanna remove this check.

02:08:55,273 --> 02:08:58,148
So, yeah, if this could be done with the mount API.

02:08:58,148 --> 02:09:02,148
- Because (mumbles) the reason,

02:09:03,590 --> 02:09:06,975
with the mount notifications stuff and the mount API

02:09:06,975 --> 02:09:10,901
you can set a notification on the thing you've got

02:09:10,901 --> 02:09:14,234
from fsmount before you call move mount.

02:09:15,142 --> 02:09:19,071
That means if anything happens once it's attached,

02:09:19,071 --> 02:09:21,974
the mount tree, you start seeing notifications immediately.

02:09:21,974 --> 02:09:25,086
There's no gap where you miss notifications

02:09:25,086 --> 02:09:28,836
because you've got a watch in placed already.

02:09:30,490 --> 02:09:34,096
With the recursive thing, the mount notifications

02:09:34,096 --> 02:09:37,829
as I've got, you place a watch on a directory

02:09:37,829 --> 02:09:41,248
and everything in the sub tree from that directory

02:09:41,248 --> 02:09:44,006
out to the tip will generate notifications

02:09:44,006 --> 02:09:45,425
that you can collect.

02:09:45,425 --> 02:09:46,925
- Excellent, yeah.

02:09:48,776 --> 02:09:50,690
But that would definitely be something

02:09:50,690 --> 02:09:52,857
that we could make use of.

02:09:56,276 --> 02:09:57,703
And, this is general again.

02:09:57,703 --> 02:09:59,675
This is generally useful to anything

02:09:59,675 --> 02:10:03,842
that watches other processes or manages processes.

02:10:06,897 --> 02:10:09,918
- Well, that's the end of my slides.

02:10:09,918 --> 02:10:13,055
Any other comments, questions, desires?

02:10:13,055 --> 02:10:15,678
- Specifically about shiftfs.

02:10:15,678 --> 02:10:20,678
So, another reason why we picked up James's initial work

02:10:21,042 --> 02:10:23,792
on shiftfs and made it work, huh?

02:10:25,897 --> 02:10:26,821
- One more minute.

02:10:26,821 --> 02:10:27,725
- Okay.

02:10:27,725 --> 02:10:31,606
Well, the next session is exactly about this.

02:10:31,606 --> 02:10:35,206
So, was obviously also the timeframe.

02:10:35,206 --> 02:10:38,376
We've been wanting shiftfs for a long, long time

02:10:38,376 --> 02:10:41,238
and of course the approach that you suggest right now

02:10:41,238 --> 02:10:44,078
wouldn't have been possible before the new mount API landed

02:10:44,078 --> 02:10:46,355
so it's more of sort of an,

02:10:46,355 --> 02:10:50,426
what sort of timeframe can we talk about?

02:10:50,426 --> 02:10:52,015
- That's a good question.

02:10:52,015 --> 02:10:54,473
Probably minimum of two cycles, I suspect.

02:10:54,473 --> 02:10:56,163
So about six months.

02:10:56,163 --> 02:10:58,383
- I mean, that's fine as long as it's not--

02:10:58,383 --> 02:11:00,608
- [David] Because we have to implement it

02:11:00,608 --> 02:11:04,481
and then it probably has to sit in the next cycle.

02:11:04,481 --> 02:11:06,056
At minimum.

02:11:06,056 --> 02:11:08,348
- I mean, as long as it's not a minimum two years because--

02:11:08,348 --> 02:11:10,864
- Sure and needs reviews but it would probably,

02:11:10,864 --> 02:11:15,043
in terms of speed, it would probably be good

02:11:15,043 --> 02:11:17,992
if you were the one to do it

02:11:17,992 --> 02:11:21,211
because you're sitting at the source.

02:11:21,211 --> 02:11:23,093
- I'll add it to my list of other things.

02:11:23,093 --> 02:11:24,321
(man laughing)

02:11:24,321 --> 02:11:26,326
Yeah, it's on my list to do.

02:11:26,326 --> 02:11:29,505
I might need to lean on Eric to do that side of it

02:11:29,505 --> 02:11:31,779
while I do that side of it.

02:11:31,779 --> 02:11:34,779
Then I can do the configuration bit.

02:11:39,259 --> 02:11:42,307
- So which kernel version did this actually go into?

02:11:42,307 --> 02:11:43,188
- [David] Mount API.

02:11:43,188 --> 02:11:44,316
- Yeah, 5.2?

02:11:44,316 --> 02:11:46,119
- Two versions ago I think.

02:11:46,119 --> 02:11:47,832
- [Man] 5.1 or 5.2.

02:11:47,832 --> 02:11:48,683
- Yeah.

02:11:48,683 --> 02:11:50,037
5.1, yeah.

02:11:50,037 --> 02:11:51,799
- That's fine, I'm just checking.

02:11:51,799 --> 02:11:55,740
- [Man] Yeah, seven new syscalls I think, right?

02:11:55,740 --> 02:11:57,676
- But I think only five of them have got in so far.

02:11:57,676 --> 02:11:59,093
- [Man] Oh right.

02:12:00,843 --> 02:12:02,123
- Anything else?

02:12:02,123 --> 02:12:03,344
I think I'm probably out of time.

02:12:03,344 --> 02:12:04,951
- I mean, I have a mount API question.

02:12:04,951 --> 02:12:08,345
Is it possible to fspick a file descriptor?

02:12:08,345 --> 02:12:10,913
As in, do you have to have a path?

02:12:10,913 --> 02:12:12,243
Is there a way to do it without a path?

02:12:12,243 --> 02:12:14,660
- It has a path and file name

02:12:15,613 --> 02:12:16,946
and the AT flex.

02:12:20,549 --> 02:12:21,411
- [Man] Oh okay, right.

02:12:21,411 --> 02:12:22,261
- Yeah.

02:12:22,261 --> 02:12:23,344
- [Man] Okay.

02:12:26,728 --> 02:12:28,110
- I think I'm out of time here.

02:12:28,110 --> 02:12:28,960
- [Man] Okay, yup.

02:12:28,960 --> 02:12:29,793
All right, thanks.

02:12:29,793 --> 02:12:30,646
- Thank you.

02:12:30,646 --> 02:12:33,646
(audience clapping)

02:12:36,196 --> 02:12:39,863
And thanks, the mount API was really needed.

02:12:51,414 --> 02:12:54,247
So, I guess James is just sort of,

02:12:55,690 --> 02:12:57,598
do you wanna present something or is it just more

02:12:57,598 --> 02:12:58,431
of an open discussion?

02:12:58,431 --> 02:12:59,264
- I have nothing to present.

02:12:59,264 --> 02:13:00,097
- Okay.

02:13:00,097 --> 02:13:00,930
- I have nothing to present.

02:13:00,930 --> 02:13:02,307
I was just actually going to discuss

02:13:02,307 --> 02:13:04,472
what we needed to do and now I'm not sure

02:13:04,472 --> 02:13:06,515
what we need to do so we can,

02:13:06,515 --> 02:13:08,950
do we want to have a discussion or can we?

02:13:08,950 --> 02:13:10,829
- I think it's more or less, it's--

02:13:10,829 --> 02:13:13,704
- I think the only thing we need to ask the question of

02:13:13,704 --> 02:13:18,287
is do we still need shiftfs for anything or is it done?

02:13:19,496 --> 02:13:20,633
- [Man] It's not done yet but--

02:13:20,633 --> 02:13:22,700
- Well, it's not done in a sense.

02:13:22,700 --> 02:13:23,552
(laughing)

02:13:23,552 --> 02:13:28,185
Once we have that and this I think is the way to go,

02:13:28,185 --> 02:13:32,099
it should be fine and we don't need shiftfs anymore.

02:13:32,099 --> 02:13:35,770
So the problem why I think shiftfs is problematic

02:13:35,770 --> 02:13:37,609
and where's Seth?

02:13:37,609 --> 02:13:38,787
Seth is here.

02:13:38,787 --> 02:13:40,836
You can come up because he's been doing

02:13:40,836 --> 02:13:42,409
that work together with me.

02:13:42,409 --> 02:13:45,326
And, we ran into a bunch of issues.

02:13:47,146 --> 02:13:51,896
So, for example, this is obviously an overlay file system

02:13:53,459 --> 02:13:57,014
and now I think, I guess the most prominent case

02:13:57,014 --> 02:13:58,617
that comes to mind is btrfs.

02:13:58,617 --> 02:14:01,703
We run containers in btrfs and btrfs allows you

02:14:01,703 --> 02:14:04,257
as an unprivileged user inside of the user namespace

02:14:04,257 --> 02:14:07,375
to create subvolumes and delete subvolumes

02:14:07,375 --> 02:14:09,768
if mounted with the correct mount options

02:14:09,768 --> 02:14:11,800
and do snapshots and so on.

02:14:11,800 --> 02:14:14,533
Now, if you have shiftfs on top of this,

02:14:14,533 --> 02:14:16,127
on top of this, this all breaks

02:14:16,127 --> 02:14:17,553
because if you do an ioctl,

02:14:17,553 --> 02:14:20,381
which bypasses all of the VFS permission checks,

02:14:20,381 --> 02:14:23,642
then btrfs gets confused and it's like, no,

02:14:23,642 --> 02:14:26,291
you're not capable in the initial user namespace.

02:14:26,291 --> 02:14:29,636
You don't get to create btrfs subvolume,

02:14:29,636 --> 02:14:31,190
regressing a bunch of use cases.

02:14:31,190 --> 02:14:32,327
For example, Docker that runs

02:14:32,327 --> 02:14:35,084
in user namespaces using btrfs.

02:14:35,084 --> 02:14:36,502
So what we had to do is,

02:14:36,502 --> 02:14:37,974
and I'm ashamed to admit this,

02:14:37,974 --> 02:14:39,703
but what we had to do is, for example,

02:14:39,703 --> 02:14:44,703
at the time of the ioctl, you basically switch out the DFD

02:14:44,802 --> 02:14:47,762
for DFD of the underlying btrfs file system

02:14:47,762 --> 02:14:51,081
so that the ioctl goes through and all of that stuff

02:14:51,081 --> 02:14:52,682
would not be necessary, in my opinion,

02:14:52,682 --> 02:14:55,385
if we had shiftfs properly in the VFS

02:14:55,385 --> 02:14:59,190
because that should just work out of the box.

02:14:59,190 --> 02:15:02,477
Also, if you wanted to use OverlayFS on top of shiftfs

02:15:02,477 --> 02:15:05,308
which, again, if you run Docker inside of a user namespace

02:15:05,308 --> 02:15:08,011
then OverlayFS is basically telling you,

02:15:08,011 --> 02:15:11,137
get away because you're a remote file system

02:15:11,137 --> 02:15:13,045
because you have a revalidate method.

02:15:13,045 --> 02:15:16,419
So we had to hack into OverlayFS, again, I'm sorry

02:15:16,419 --> 02:15:18,336
to special case shiftfs

02:15:19,313 --> 02:15:22,896
and then also, remote file systems such as,

02:15:27,710 --> 02:15:30,041
well OverlayFS itself uses DFS data

02:15:30,041 --> 02:15:32,384
to stash information inside of a dentry.

02:15:32,384 --> 02:15:35,384
So, if OverlayFS creates a fake path

02:15:38,479 --> 02:15:42,611
that then gets passed down into shiftfs,

02:15:42,611 --> 02:15:45,510
now shiftfs is looking at the dentry information

02:15:45,510 --> 02:15:46,655
and is really confused.

02:15:46,655 --> 02:15:47,874
What the hell is in this dentry?

02:15:47,874 --> 02:15:50,388
This is OverlayFS information, not shiftfs information,

02:15:50,388 --> 02:15:54,647
crashing which means we needed to change OverlayFS

02:15:54,647 --> 02:15:58,250
to pass down the correct dentry into shiftfs.

02:15:58,250 --> 02:16:01,056
So, we need to change, it came to the point

02:16:01,056 --> 02:16:02,948
where we needed to change a bunch of file systems,

02:16:02,948 --> 02:16:04,257
the ones people cared about.

02:16:04,257 --> 02:16:07,360
OverlayFS, we needed to do this btrfs hackery

02:16:07,360 --> 02:16:08,860
and sort of, yeah.

02:16:09,739 --> 02:16:13,156
It's very nasty and with the VFS approach

02:16:14,920 --> 02:16:17,077
if this would all be gone.

02:16:17,077 --> 02:16:18,824
In the end what I'm trying to say is

02:16:18,824 --> 02:16:20,430
if you don't wanna regress use cases

02:16:20,430 --> 02:16:22,324
and want to have shiftfs really usable,

02:16:22,324 --> 02:16:24,741
I think we can't upstream it.

02:16:26,049 --> 02:16:29,262
Like, this is not upstreamable.

02:16:29,262 --> 02:16:32,199
The way, at least what we had to do.

02:16:32,199 --> 02:16:35,576
Unless we did it in such a wrong way

02:16:35,576 --> 02:16:37,252
and there is an obvious other solution

02:16:37,252 --> 02:16:40,766
to all of these problems but yeah.

02:16:40,766 --> 02:16:42,240
- I think you said it all.

02:16:42,240 --> 02:16:46,157
Some of the, I mean, the basic shiftfs is fine.

02:16:49,637 --> 02:16:50,490
- Right.

02:16:50,490 --> 02:16:52,082
- It's those dirty hacks to get some

02:16:52,082 --> 02:16:55,332
of those other use cases working that just,

02:16:55,332 --> 02:16:58,748
you know, they'd never fly upstream I don't think.

02:16:58,748 --> 02:17:03,398
- So the plan going forward is to see if we can redo it

02:17:03,398 --> 02:17:06,065
around the mount, new mount API.

02:17:07,010 --> 02:17:07,862
- Yes.

02:17:07,862 --> 02:17:08,695
- Okay.

02:17:12,249 --> 02:17:15,182
- At that point then, I better bring up

02:17:15,182 --> 02:17:17,863
what we were talking about

02:17:17,863 --> 02:17:21,359
between David and I and see how many holes

02:17:21,359 --> 02:17:22,494
you can poke in it.

02:17:22,494 --> 02:17:23,510
(laughing)

02:17:23,510 --> 02:17:27,140
- I think he's just told us we have no path forwards

02:17:27,140 --> 02:17:29,956
if we poke holes in this so be careful what you wish for.

02:17:29,956 --> 02:17:33,115
- Well, I figure if we poke the holes early,

02:17:33,115 --> 02:17:37,198
we might get out of them before we sink the boat.

02:17:38,844 --> 02:17:41,844
I'm not going to, if I can scribble.

02:17:43,565 --> 02:17:47,315
- This URL, by the way, is in the description

02:17:49,085 --> 02:17:51,479
of the session so everybody can just go to

02:17:51,479 --> 02:17:53,210
the session description where the timetable

02:17:53,210 --> 02:17:55,749
for the session is and click on it.

02:17:55,749 --> 02:17:58,031
- [Man] Uh yeah, you wanna move it,

02:17:58,031 --> 02:17:59,057
oh, you can see it okay.

02:17:59,057 --> 02:18:01,098
(woman speaking softly)

02:18:01,098 --> 02:18:02,098
Okay, right.

02:18:09,041 --> 02:18:12,458
- So I'm trying to replicate the diagram.

02:18:13,635 --> 02:18:18,635
I was using, as I thought about this while talking to David.

02:18:22,247 --> 02:18:25,206
So I'll start with two containers.

02:18:25,206 --> 02:18:30,190
UID inside the first container translates to KUID 5,000.

02:18:30,190 --> 02:18:32,273
The other one KUID 6,000.

02:18:36,729 --> 02:18:37,562
All right.

02:18:40,320 --> 02:18:42,487
And, okay, let's see.

02:18:42,487 --> 02:18:45,654
(man speaking softly)

02:18:51,746 --> 02:18:53,371
(people laughing)

02:18:53,371 --> 02:18:55,255
- [Man] Move over there.

02:18:55,255 --> 02:18:56,922
- So, um, let's see.

02:19:09,438 --> 02:19:13,198
Yeah, you want parts of it that you want all,

02:19:13,198 --> 02:19:15,891
you want the shared part of stuff

02:19:15,891 --> 02:19:20,712
that I'm thinking, I always think of it as read only

02:19:20,712 --> 02:19:22,379
that you want to be,

02:19:24,594 --> 02:19:26,480
you know, have multiple mappings to

02:19:26,480 --> 02:19:28,023
and then you have the other places where you want

02:19:28,023 --> 02:19:31,773
to write to and you don't want special magic.

02:19:35,002 --> 02:19:37,531
What I was thinking is you have your,

02:19:37,531 --> 02:19:41,698
in your user namespace, you have your ordinary map

02:19:42,761 --> 02:19:47,419
and you have your, for lack of possibly a better term,

02:19:47,419 --> 02:19:48,502
a shared map.

02:19:52,113 --> 02:19:54,196
And these would be inodes

02:19:57,141 --> 02:19:59,224
and these would be creds.

02:20:01,818 --> 02:20:05,485
And so, what you could do is have an additional,

02:20:05,485 --> 02:20:09,111
add a shared map to the user namespace.

02:20:09,111 --> 02:20:12,680
- So would this be the user namespace

02:20:12,680 --> 02:20:17,483
you used at the top or the user namespace of the superblock?

02:20:17,483 --> 02:20:20,078
- User namespace for the containers.

02:20:20,078 --> 02:20:22,013
- [Man] So what do we do if we have a superblock namespace

02:20:22,013 --> 02:20:23,916
as well as a user namespace?

02:20:23,916 --> 02:20:28,083
- That just goes to how these KUIDs get generated.

02:20:32,249 --> 02:20:33,706
- [Man] So this is going to be a private translation

02:20:33,706 --> 02:20:34,556
in here?

02:20:34,556 --> 02:20:35,406
- Yeah.

02:20:35,406 --> 02:20:36,257
- [Man] Okay.

02:20:36,257 --> 02:20:37,274
- Yeah, this is the file system's specific translation

02:20:37,274 --> 02:20:40,251
from the files on disk to KUIDs.

02:20:40,251 --> 02:20:43,921
So, you know, and when you mount your USB stick,

02:20:43,921 --> 02:20:46,087
you really care about that translation

02:20:46,087 --> 02:20:49,121
and how it's going to work and we probably want

02:20:49,121 --> 02:20:53,371
to make a general layer but for the container case,

02:20:55,244 --> 02:20:58,244
we want the one to mini so this file

02:21:01,877 --> 02:21:06,264
goes to both of those and looks like owned by UID zero.

02:21:06,264 --> 02:21:07,347
- [Man] Yeah.

02:21:09,297 --> 02:21:12,485
- So, we got as far as that now.

02:21:12,485 --> 02:21:14,268
Now, what the shared mount let's us do is if we have

02:21:14,268 --> 02:21:15,768
a bind mount here.

02:21:17,954 --> 02:21:19,825
You know, we just have a bit that says

02:21:19,825 --> 02:21:23,408
use your darn shared map on the bind mount.

02:21:25,887 --> 02:21:29,764
And then we can cache a second cred here

02:21:29,764 --> 02:21:33,681
that if your shared cred and your existing cred

02:21:35,789 --> 02:21:39,051
that goes to KUID 20, you do override cred

02:21:39,051 --> 02:21:42,912
and use that one when accessing through the bind mount.

02:21:42,912 --> 02:21:44,618
- So, can we not be more simple?

02:21:44,618 --> 02:21:47,493
Is there any need for a shared map because the statement

02:21:47,493 --> 02:21:51,316
is we have fictitious root to real UID.

02:21:51,316 --> 02:21:54,925
Why not just read back from fictitious root again?

02:21:54,925 --> 02:21:58,229
We always reverse, the only use case I could ever

02:21:58,229 --> 02:22:00,476
find with shiftfs was when we reverse mapped.

02:22:00,476 --> 02:22:01,976
- Oh, I, yeah, so,

02:22:04,300 --> 02:22:06,717
my expectation is UIDs, well,

02:22:09,544 --> 02:22:10,377
okay.

02:22:11,334 --> 02:22:14,772
So, there might be a way to optimize this, yes.

02:22:14,772 --> 02:22:17,858
You know, because everybody wants to go

02:22:17,858 --> 02:22:20,416
to the same UIDs in their container.

02:22:20,416 --> 02:22:23,583
There might be a way to optimize that.

02:22:25,441 --> 02:22:28,524
But this caching here is fundamental.

02:22:30,803 --> 02:22:32,386
And so, yeah, yeah.

02:22:34,677 --> 02:22:36,111
So, yeah.

02:22:36,111 --> 02:22:41,111
I'm all open to this simplification you are suggesting.

02:22:41,224 --> 02:22:44,307
I actually was, had a similar thought

02:22:45,316 --> 02:22:47,316
on my way in here today.

02:22:50,473 --> 02:22:52,895
- [Man] Okay but this is just an implementation detail.

02:22:52,895 --> 02:22:53,749
It doesn't matter.

02:22:53,749 --> 02:22:55,370
- Yeah, yeah, yeah, yeah, yeah, yeah, yeah.

02:22:55,370 --> 02:22:56,871
- [Man] The point is we have to convince Al

02:22:56,871 --> 02:22:58,779
to give us an additional flag in the VFS mount.

02:22:58,779 --> 02:22:59,839
That's the problem.

02:22:59,839 --> 02:23:04,656
- Well, a flag versus a data structure, much easier.

02:23:04,656 --> 02:23:06,627
I've added several.

02:23:06,627 --> 02:23:08,063
(laughing)

02:23:08,063 --> 02:23:10,226
(man speaking softly)

02:23:10,226 --> 02:23:11,076
Yeah.

02:23:11,076 --> 02:23:11,925
Yeah, yeah, yeah.

02:23:11,925 --> 02:23:13,303
Yeah, it needs one bit in a VFS mount

02:23:13,303 --> 02:23:15,470
that says go use that map.

02:23:19,333 --> 02:23:24,258
The hard part to convince Al and everybody of is the,

02:23:24,258 --> 02:23:28,841
in every syscall, especially open adding overwrite cred

02:23:30,259 --> 02:23:33,118
to that one instead of that one

02:23:33,118 --> 02:23:38,118
when, at the syscall layer we're going in and doing that.

02:23:38,333 --> 02:23:39,735
(man speaking softly)

02:23:39,735 --> 02:23:40,741
- Sorry, I was gonna ask.

02:23:40,741 --> 02:23:42,651
We can struct the override cred on the fly

02:23:42,651 --> 02:23:43,484
or we have it available?

02:23:43,484 --> 02:23:45,734
- We cache 'em in the cred.

02:23:47,027 --> 02:23:48,824
- Okay so from the cred we can go to.

02:23:48,824 --> 02:23:49,657
- Yeah. - Okay.

02:23:49,657 --> 02:23:50,490
- Yeah and that can--

02:23:50,490 --> 02:23:51,668
- [Man] Okay they're keyed on the same flag.

02:23:51,668 --> 02:23:52,894
- Yeah and, you know, that's the advantage

02:23:52,894 --> 02:23:56,167
of putting in our user namespace because we only have one

02:23:56,167 --> 02:23:58,633
so if you have two or three file systems

02:23:58,633 --> 02:24:01,227
that you want this mapping to apply to,

02:24:01,227 --> 02:24:03,644
you know, the shared mapping in your namespace,

02:24:03,644 --> 02:24:07,169
they all have to have the same UID mapping

02:24:07,169 --> 02:24:09,890
but I don't think that's a real limitation.

02:24:09,890 --> 02:24:11,491
- This isn't very expensive though, right?

02:24:11,491 --> 02:24:14,666
I mean, at open time if we have to override cred.

02:24:14,666 --> 02:24:15,915
So what is your?

02:24:15,915 --> 02:24:17,585
- Override cred is cheap.

02:24:17,585 --> 02:24:19,948
Generating a cred is expensive

02:24:19,948 --> 02:24:22,249
and so this is, we cache the cred.

02:24:22,249 --> 02:24:25,834
And, this is a, we follow a pointer

02:24:25,834 --> 02:24:28,508
and we put it in the task struct.

02:24:28,508 --> 02:24:29,749
(man mumbling)

02:24:29,749 --> 02:24:34,051
- In many ways it's actually destroying the cred.

02:24:34,051 --> 02:24:36,914
(people laughing)

02:24:36,914 --> 02:24:40,633
(people chattering)

02:24:40,633 --> 02:24:43,448
In many ways, destroying the cred is actually

02:24:43,448 --> 02:24:46,117
the worst bit because it gets deferred

02:24:46,117 --> 02:24:50,385
and so you can wangle your system by doing

02:24:50,385 --> 02:24:52,599
something to create lots of creds.

02:24:52,599 --> 02:24:53,432
Bang, bang, bang.

02:24:53,432 --> 02:24:54,382
And then try and destroy them.

02:24:54,382 --> 02:24:55,215
Bang, bang.

02:24:55,215 --> 02:24:56,362
And then they just eat memory and eat memory

02:24:56,362 --> 02:25:00,779
and eat memory until eventually the RCU cleanup runs.

02:25:02,035 --> 02:25:03,342
And if you're not careful, you can actually

02:25:03,342 --> 02:25:04,562
run out of memory.

02:25:04,562 --> 02:25:07,057
We had this problem with access recently.

02:25:07,057 --> 02:25:08,856
(man speaking softly)

02:25:08,856 --> 02:25:10,164
- And I have a question about,

02:25:10,164 --> 02:25:12,247
this might be obvious but

02:25:13,445 --> 02:25:14,278
I presume this can cache multiple

02:25:14,278 --> 02:25:15,722
because I obviously if you have something from here

02:25:15,722 --> 02:25:18,268
mounted here as well, how do you know which cred to use?

02:25:18,268 --> 02:25:19,266
- Well, that's what I was gonna ask.

02:25:19,266 --> 02:25:20,909
So where is the cache?

02:25:20,909 --> 02:25:23,896
- So this is, in your cred, you have a cache.

02:25:23,896 --> 02:25:25,362
Okay.

02:25:25,362 --> 02:25:28,914
The thing that makes this fast and simple and cheap

02:25:28,914 --> 02:25:31,863
is in your cred you have a pointer to another cred.

02:25:31,863 --> 02:25:36,297
That is, your shared cred for all this shared stuff

02:25:36,297 --> 02:25:37,880
you're bringing in.

02:25:39,117 --> 02:25:41,454
And, you have, and that's it.

02:25:41,454 --> 02:25:44,164
You know, so you only have KUID

02:25:44,164 --> 02:25:46,247
that your UID can map to.

02:25:47,435 --> 02:25:50,444
You know, but one shared one.

02:25:50,444 --> 02:25:52,647
- But what if you have two directories one of like,

02:25:52,647 --> 02:25:54,490
again, in this case imagine you wanted to mount

02:25:54,490 --> 02:25:55,504
into this in here.

02:25:55,504 --> 02:25:56,337
- Yeah, so--

02:25:56,337 --> 02:25:57,170
- Then how would you--

02:25:57,170 --> 02:25:58,376
- So if you mount this one in here,

02:25:58,376 --> 02:26:01,846
if it's read, write, you just use this cred.

02:26:01,846 --> 02:26:05,072
That's the normal case using this cred.

02:26:05,072 --> 02:26:07,442
But it's either this cred or this cred.

02:26:07,442 --> 02:26:08,275
It's either you shared--

02:26:08,275 --> 02:26:12,281
- [Man] But what if we want to shift that one as well?

02:26:12,281 --> 02:26:15,349
- His point is this is K20, this is not really root.

02:26:15,349 --> 02:26:16,182
This is K50.

02:26:16,182 --> 02:26:17,727
We need a K50 cred somewhere.

02:26:17,727 --> 02:26:18,560
- Yeah.

02:26:18,560 --> 02:26:19,393
Oh, yeah.

02:26:19,393 --> 02:26:20,265
Oh yeah that's--

02:26:20,265 --> 02:26:21,482
- [Man] So presuming it's, sorry--

02:26:21,482 --> 02:26:22,944
- Yeah, good point.

02:26:22,944 --> 02:26:25,527
Yeah, you know, if you mount K.

02:26:28,372 --> 02:26:32,319
(man speaking softly)

02:26:32,319 --> 02:26:37,031
K 5000 which is, anyway, normal read write case is that.

02:26:37,031 --> 02:26:39,198
You know, having multiple,

02:26:40,652 --> 02:26:43,761
having more than one or two--

02:26:43,761 --> 02:26:44,594
- Sorry.

02:26:44,594 --> 02:26:45,427
This point of this diagram is wrong.

02:26:45,427 --> 02:26:46,347
This should be K20, right?

02:26:46,347 --> 02:26:47,180
- Oh.

02:26:47,180 --> 02:26:48,013
Well, no, no, no.

02:26:48,013 --> 02:26:48,846
Oh.

02:26:48,846 --> 02:26:51,856
This is just some arbitrary other file.

02:26:51,856 --> 02:26:52,981
- I guess my point is that if you wanted

02:26:52,981 --> 02:26:54,923
to have multiple shifts, sorry, with the system

02:26:54,923 --> 02:26:57,009
you wouldn't, sorry, with the system you wouldn't be able

02:26:57,009 --> 02:26:58,698
to have multiple shifts of things

02:26:58,698 --> 02:27:00,271
in one user namespace basically.

02:27:00,271 --> 02:27:01,104
- Right.

02:27:01,104 --> 02:27:03,226
- The point is multiple shifts are really just not used.

02:27:03,226 --> 02:27:04,808
Usually the shift is just a reverse shift

02:27:04,808 --> 02:27:06,685
of what this mapping is.

02:27:06,685 --> 02:27:07,564
- Right.

02:27:07,564 --> 02:27:09,527
- It's either you flip it to reverse

02:27:09,527 --> 02:27:10,989
or you do nothing with it.

02:27:10,989 --> 02:27:13,359
And those cases would be covered by one cred

02:27:13,359 --> 02:27:15,026
plus its cache cred.

02:27:16,018 --> 02:27:18,732
(laughing drowns out speaker)

02:27:18,732 --> 02:27:20,952
- So currently for the current cases we do

02:27:20,952 --> 02:27:23,738
that is true because if we needed to share data

02:27:23,738 --> 02:27:25,470
between two containers we would store it

02:27:25,470 --> 02:27:27,447
and shift it to the host, and shift it to both of them

02:27:27,447 --> 02:27:29,404
even if they've got different mounts

02:27:29,404 --> 02:27:31,971
but there is, in theory, nothing preventing us

02:27:31,971 --> 02:27:34,636
from actually wanting to share a file from one container

02:27:34,636 --> 02:27:36,423
straight into the other,

02:27:36,423 --> 02:27:40,032
both being unprivileged and both with different mounts.

02:27:40,032 --> 02:27:43,742
- And that's where things get, you know.

02:27:43,742 --> 02:27:47,854
There's theory and there's accelerating the common case

02:27:47,854 --> 02:27:51,088
and this is about accelerating the common case

02:27:51,088 --> 02:27:53,607
and making it fast and cheap so you.

02:27:53,607 --> 02:27:56,690
Now, the one part this thought design

02:27:57,527 --> 02:27:59,273
does not cover right now

02:27:59,273 --> 02:28:03,164
is where do we put in here OverlayFS?

02:28:03,164 --> 02:28:05,201
And does this interact,

02:28:05,201 --> 02:28:06,931
I haven't thought through if this interacts properly

02:28:06,931 --> 02:28:09,121
with OverlayFS which would have to sit on top

02:28:09,121 --> 02:28:13,871
of the bind mount which has the use the shared mount did.

02:28:18,558 --> 02:28:19,420
- [Man] It wouldn't at all.

02:28:19,420 --> 02:28:21,017
This is part of the VFS so OverlayFS

02:28:21,017 --> 02:28:23,069
would take the place of the bind mount.

02:28:23,069 --> 02:28:23,902
Right?

02:28:23,902 --> 02:28:25,190
It's a mount pointing system.

02:28:25,190 --> 02:28:26,422
- [Man] Overlay has to be down there because it's,

02:28:26,422 --> 02:28:28,795
Overlay doesn't (mumbles) on the bind mounts

02:28:28,795 --> 02:28:30,745
because they aren't up here.

02:28:30,745 --> 02:28:32,903
- Yeah but Overlay is first on top of something

02:28:32,903 --> 02:28:34,580
that has a mount underneath it.

02:28:34,580 --> 02:28:36,162
Like, a low ID that has mounts,

02:28:36,162 --> 02:28:38,657
only the directory is pointed.

02:28:38,657 --> 02:28:40,629
- The point is you can mount OverlayFS

02:28:40,629 --> 02:28:43,219
and set your flag and then all of the shifting is done

02:28:43,219 --> 02:28:44,916
as part of OverlayFS, right?

02:28:44,916 --> 02:28:48,611
Because OverlayFS provides the VFS mount structure.

02:28:48,611 --> 02:28:51,778
- Well, so, last I looked at OverlayFS

02:28:54,584 --> 02:28:58,917
it needs to know what the underlying file system is.

02:28:59,803 --> 02:29:01,320
- No.

02:29:01,320 --> 02:29:04,385
OverlayFS just, like, for example it looks

02:29:04,385 --> 02:29:08,091
does the underlying file system have a deopery validate

02:29:08,091 --> 02:29:11,297
and if that's the case then refuse what's going on

02:29:11,297 --> 02:29:12,533
but it doesn't really poke

02:29:12,533 --> 02:29:14,507
into what the underlying file system is.

02:29:14,507 --> 02:29:16,488
- But it needs to know where it is.

02:29:16,488 --> 02:29:18,655
It needs to be configured.

02:29:19,718 --> 02:29:23,333
- So, OverlayFS has this concept of upper

02:29:23,333 --> 02:29:24,496
and lower dentries, right?

02:29:24,496 --> 02:29:25,696
That's all it needs to know

02:29:25,696 --> 02:29:28,037
and where we shift the VFS does not,

02:29:28,037 --> 02:29:31,289
the VFS creds doesn't matter to OverlayFS at all.

02:29:31,289 --> 02:29:35,447
So, we can do it in the, when you mount OverlayFS

02:29:35,447 --> 02:29:38,927
it creates its own VFS mount which has a struct mount.

02:29:38,927 --> 02:29:40,338
We can set the flag in that.

02:29:40,338 --> 02:29:42,000
Everything should just work.

02:29:42,000 --> 02:29:43,155
I mean, that's my theory anyway.

02:29:43,155 --> 02:29:45,310
- Yeah (mumbles).

02:29:45,310 --> 02:29:46,529
- I mean, there will be a problem

02:29:46,529 --> 02:29:48,463
if you try to do overlay on top of shift

02:29:48,463 --> 02:29:49,587
but that's, yeah.

02:29:49,587 --> 02:29:51,632
But I think that you shouldn't do that.

02:29:51,632 --> 02:29:54,505
- Well, we need to have some sensible limitations I think.

02:29:54,505 --> 02:29:58,242
- [Man] I mean, somebody said earlier about supporting

02:29:58,242 --> 02:29:59,790
Docker inside of a container.

02:29:59,790 --> 02:30:01,692
Isn't that what Docker is going to want to do?

02:30:01,692 --> 02:30:03,205
It's gonna want to mount OverlayFS

02:30:03,205 --> 02:30:07,630
within your container that has a shifted bind mount?

02:30:07,630 --> 02:30:09,238
- Read only layer, yeah.

02:30:09,238 --> 02:30:10,550
- Right but it's,

02:30:10,550 --> 02:30:13,602
Docker in a container, in an unprivileged container

02:30:13,602 --> 02:30:16,935
is a nested user namespace thing anyway.

02:30:18,569 --> 02:30:21,015
This flag, doesn't just say go back

02:30:21,015 --> 02:30:23,055
to the first user namespace you can find.

02:30:23,055 --> 02:30:24,378
In which case that would be--

02:30:24,378 --> 02:30:25,533
- [Man] No, it has to be in that space.

02:30:25,533 --> 02:30:27,681
- Well, it could be.

02:30:27,681 --> 02:30:30,063
- Well, what it would mean is you look at your cred,

02:30:30,063 --> 02:30:31,248
your cred has a user namespace.

02:30:31,248 --> 02:30:33,727
(background noise drowns out speaker)

02:30:33,727 --> 02:30:35,253
Yeah, your cred has a user namespace.

02:30:35,253 --> 02:30:37,077
You find the mapping from your user namespace

02:30:37,077 --> 02:30:39,651
and you do the translation if you're on the slow path.

02:30:39,651 --> 02:30:40,484
(laughing)

02:30:40,484 --> 02:30:41,594
- Right but then the point I'm making

02:30:41,594 --> 02:30:42,966
is if the user namespace is nested

02:30:42,966 --> 02:30:44,656
and the flag is set, it just goes back

02:30:44,656 --> 02:30:46,404
to the first user namespace it can find.

02:30:46,404 --> 02:30:48,493
And so, we can do it like that.

02:30:48,493 --> 02:30:50,343
I mean, the whole object of doing this

02:30:50,343 --> 02:30:52,111
is to actually get Docker to bloody well use

02:30:52,111 --> 02:30:54,865
the user namespace because it doesn't today.

02:30:54,865 --> 02:30:57,050
- [Man] Well, among other things, right?

02:30:57,050 --> 02:30:57,883
- Yeah.

02:30:57,883 --> 02:30:59,109
- [Man] Also to fix other problems as well.

02:30:59,109 --> 02:31:01,805
- Yeah Docker or the systems it has inspired.

02:31:01,805 --> 02:31:06,466
(background noise drowns out speaker)

02:31:06,466 --> 02:31:08,799
Yeah but, you know, I think,

02:31:10,087 --> 02:31:11,502
this is where I get,

02:31:11,502 --> 02:31:15,236
so, how does Docker decide which creds it uses

02:31:15,236 --> 02:31:17,471
when it's writing to the lower file system?

02:31:17,471 --> 02:31:18,304
- Docker doesn't.

02:31:18,304 --> 02:31:19,907
- I'm sorry, OverlayFS.

02:31:19,907 --> 02:31:20,740
Sorry.

02:31:20,740 --> 02:31:22,907
(mumbles)

02:31:24,573 --> 02:31:26,894
- [Man] Isn't OverlayFS doing the same thing we did

02:31:26,894 --> 02:31:30,013
for shiftfs where it uses the creds of the mounter

02:31:30,013 --> 02:31:31,295
of the superblock?

02:31:31,295 --> 02:31:35,045
- I had it using override creds at one point.

02:31:37,451 --> 02:31:41,443
I had it using override creds at one point.

02:31:41,443 --> 02:31:45,120
So, it used, I think the mount creds to talk to

02:31:45,120 --> 02:31:49,203
or to look at this and I think it still does that

02:31:50,495 --> 02:31:53,852
but I didn't pass the (background noise drowns out speaker).

02:31:53,852 --> 02:31:57,863
- [Man] Oh, let me put the underlying FS copy up, right?

02:31:57,863 --> 02:32:01,063
- Well, you've got more than one underlying FS.

02:32:01,063 --> 02:32:04,861
You've got a number of static ones and a workspace.

02:32:04,861 --> 02:32:05,694
- Yeah, yeah, yeah, yeah.

02:32:05,694 --> 02:32:08,615
Static, static, static, right.

02:32:08,615 --> 02:32:09,878
So, yeah.

02:32:09,878 --> 02:32:12,114
So, but it only does copy up from everything

02:32:12,114 --> 02:32:13,357
except for the writable, right?

02:32:13,357 --> 02:32:14,699
- [David] But I think it uses the mounts creds

02:32:14,699 --> 02:32:15,949
for everything.

02:32:17,216 --> 02:32:18,049
- Okay.

02:32:19,698 --> 02:32:20,531
- Yes.

02:32:20,531 --> 02:32:22,784
OverlayFS, we use, we use the same approach.

02:32:22,784 --> 02:32:25,120
When the mounter of the superblock,

02:32:25,120 --> 02:32:27,358
the creds of the mounter of the superblock

02:32:27,358 --> 02:32:30,273
becomes the one that get called every time

02:32:30,273 --> 02:32:32,286
over if OverlayFS is a making a decision

02:32:32,286 --> 02:32:33,609
to access the file system.

02:32:33,609 --> 02:32:35,340
- But it will still work because OverlayFS

02:32:35,340 --> 02:32:36,247
will have two creds.

02:32:36,247 --> 02:32:37,768
It will have the users real creds

02:32:37,768 --> 02:32:39,594
and it will have the mounter's creds,

02:32:39,594 --> 02:32:41,169
both of which can have a cached map.

02:32:41,169 --> 02:32:43,035
Both of which done by the shared map.

02:32:43,035 --> 02:32:45,144
Everything should function normally.

02:32:45,144 --> 02:32:45,977
- Yeah so I--

02:32:45,977 --> 02:32:46,814
- You would assume so.

02:32:46,814 --> 02:32:48,877
- My intuition says on the writable layer

02:32:48,877 --> 02:32:52,680
we want the ordinary cred and for copying these up

02:32:52,680 --> 02:32:54,745
we want the shared cred.

02:32:54,745 --> 02:32:55,578
- Yeah.

02:32:55,578 --> 02:32:57,704
And we want mappings on both done through the shared map

02:32:57,704 --> 02:32:59,775
and in that case everything should just work

02:32:59,775 --> 02:33:03,055
because we can do the caching just as still one layer.

02:33:03,055 --> 02:33:04,055
- Oh, sorry.

02:33:05,201 --> 02:33:07,522
- I think the way to think of OverlayFS

02:33:07,522 --> 02:33:11,355
is you go to OverlayFS through the translation

02:33:12,619 --> 02:33:14,709
and then you start again.

02:33:14,709 --> 02:33:17,721
So, it's a completely new translation.

02:33:17,721 --> 02:33:19,631
So, it's just, you go to a less

02:33:19,631 --> 02:33:23,788
and then you start again when it goes to the lower reaches.

02:33:23,788 --> 02:33:25,326
- Okay.

02:33:25,326 --> 02:33:26,505
Yeah.

02:33:26,505 --> 02:33:30,505
Yeah so if those mounts have the bit set on them

02:33:31,748 --> 02:33:33,888
to force you to the shared and you come in here

02:33:33,888 --> 02:33:37,555
with your ordinary cred, I think that works.

02:33:40,675 --> 02:33:42,887
- [David] It does whatever the mounts will do.

02:33:42,887 --> 02:33:43,974
- Yeah. - Yeah.

02:33:43,974 --> 02:33:46,712
- I think we can make it work with a single flag.

02:33:46,712 --> 02:33:50,657
- Anyway, that's the current brainstorm.

02:33:50,657 --> 02:33:52,628
- Yeah, I want to remind everyone that this session

02:33:52,628 --> 02:33:54,439
is recorded so you can watch it later

02:33:54,439 --> 02:33:56,404
if you're confused about what actually has happened.

02:33:56,404 --> 02:33:57,789
(people laughing)

02:33:57,789 --> 02:33:59,349
- [Man] Uh, Seth wants this.

02:33:59,349 --> 02:34:01,816
- I just had one question about setting a flag in the mount.

02:34:01,816 --> 02:34:04,799
As I recall, there's a lot of places in the VFS

02:34:04,799 --> 02:34:08,495
that can't actually get back to the mount

02:34:08,495 --> 02:34:11,376
through which something was accessed.

02:34:11,376 --> 02:34:13,239
Is that going to be an issue for identifying whether these--

02:34:13,239 --> 02:34:16,091
- [Man] This is path versus dentry for the APIs, right?

02:34:16,091 --> 02:34:17,940
- So, yeah, okay.

02:34:17,940 --> 02:34:21,523
- The file systems don't, apart from things

02:34:23,572 --> 02:34:28,274
that take file stars, most of the file system operations

02:34:28,274 --> 02:34:32,130
don't get a path but we're talking about doing the override

02:34:32,130 --> 02:34:34,510
above the file system there in the VFS

02:34:34,510 --> 02:34:36,343
where there is a path.

02:34:37,806 --> 02:34:42,192
- So, you know, just a small matter of adding a path.

02:34:42,192 --> 02:34:45,049
- His point is that not every VFS API takes a path.

02:34:45,049 --> 02:34:47,174
Some of them take a dentry instead of the path

02:34:47,174 --> 02:34:50,336
and we have a problem because they are blind to the mount,

02:34:50,336 --> 02:34:51,753
the struct mount.

02:34:53,608 --> 02:34:54,441
- Ready?

02:34:55,696 --> 02:34:57,701
- But what we were talking about

02:34:57,701 --> 02:35:00,860
is actually doing the override in the VFS

02:35:00,860 --> 02:35:03,024
before it calls the file system.

02:35:03,024 --> 02:35:07,618
So the file systems still use the translated stuff.

02:35:07,618 --> 02:35:11,131
- So when the file system goes to look at current cred,

02:35:11,131 --> 02:35:15,133
it sees that guy and the VFS just has already

02:35:15,133 --> 02:35:20,133
swapped that out if it's appropriate by looking at the path.

02:35:22,378 --> 02:35:24,863
- As long as we always have a way of getting through

02:35:24,863 --> 02:35:27,409
the path, that should work but I seem to remember

02:35:27,409 --> 02:35:31,200
there was some, so Ted Cho always wants

02:35:31,200 --> 02:35:34,487
this single flag approach for a particular use case

02:35:34,487 --> 02:35:36,800
which is mount with cases sensitive.

02:35:36,800 --> 02:35:39,724
But he's trying to use the XT4 for DOS type file systems

02:35:39,724 --> 02:35:41,963
and his problem in doing that,

02:35:41,963 --> 02:35:44,768
which he got a scheme very like this,

02:35:44,768 --> 02:35:47,836
was there was certain VFS APIs where it was blind

02:35:47,836 --> 02:35:50,143
to the actual, it didn't have the path.

02:35:50,143 --> 02:35:51,723
So it didn't have struct mount.

02:35:51,723 --> 02:35:52,920
It only had the dentry

02:35:52,920 --> 02:35:55,206
'cause the path is the mount plus the dentry.

02:35:55,206 --> 02:35:57,305
And, you can't reconstruct the flag state

02:35:57,305 --> 02:35:58,891
unless you have the mount.

02:35:58,891 --> 02:36:01,938
So you can't reconstruct it with only the dentry.

02:36:01,938 --> 02:36:04,077
And so, there are a VFS APIs where he thought

02:36:04,077 --> 02:36:06,453
it needed to be rethreaded to get this to work

02:36:06,453 --> 02:36:09,101
and I think you have the same problem.

02:36:09,101 --> 02:36:10,664
- Quite possibly.

02:36:10,664 --> 02:36:12,426
But we need to find that.

02:36:12,426 --> 02:36:14,901
That's one of the holes we were looking for.

02:36:14,901 --> 02:36:16,984
On the flip side, I think

02:36:18,469 --> 02:36:22,327
if the common case is going to be below OverlayFS,

02:36:22,327 --> 02:36:25,515
it might make sense to teach OverlayFS,

02:36:25,515 --> 02:36:29,036
you make certain OverlayFS doing the right thing on copy up

02:36:29,036 --> 02:36:32,787
and I think that's one path we have to get

02:36:32,787 --> 02:36:34,410
and then we're--

02:36:34,410 --> 02:36:36,936
- Well, just take a note to see if we still have

02:36:36,936 --> 02:36:39,312
this VFS dentry problem without the struct mount.

02:36:39,312 --> 02:36:40,145
- Yeah.

02:36:40,145 --> 02:36:43,942
- I also wonder if we still need some changes

02:36:43,942 --> 02:36:45,479
in other file systems.

02:36:45,479 --> 02:36:48,357
Like, as far as I member, the ioctl case I brought up

02:36:48,357 --> 02:36:52,074
for btrfs, just maybe you can help me walk through this,

02:36:52,074 --> 02:36:56,657
it checks do we have permissions over the inode, right?

02:36:57,639 --> 02:37:00,222
Or am I capable in the initial,

02:37:02,092 --> 02:37:05,703
or am I ns capable in the user namespace?

02:37:05,703 --> 02:37:07,846
Either it needs both or one of the two

02:37:07,846 --> 02:37:09,818
but like, for example, how do you deal with the case

02:37:09,818 --> 02:37:11,916
where it checks am I privileged with respect

02:37:11,916 --> 02:37:13,916
to the underlying inode?

02:37:15,270 --> 02:37:19,639
- Well, but if we swap the cred before the permission check

02:37:19,639 --> 02:37:22,298
and inode permission doesn't take a path so we have to,

02:37:22,298 --> 02:37:23,131
yeah.

02:37:25,262 --> 02:37:28,604
And, yeah, and so you just do that swap

02:37:28,604 --> 02:37:32,521
in ioctl if the path you're dealing with needs,

02:37:34,559 --> 02:37:35,866
has the bit set.

02:37:35,866 --> 02:37:37,949
- Well, we have the path.

02:37:39,816 --> 02:37:42,033
We have the path because we have a file star

02:37:42,033 --> 02:37:44,959
and the file star has a path in it.

02:37:44,959 --> 02:37:48,626
So even the ioctl call has a path available.

02:37:50,116 --> 02:37:54,410
- Right but is the case that you need to, like,

02:37:54,410 --> 02:37:57,074
I guess other ioctls that actually pass like a roll UID.

02:37:57,074 --> 02:37:58,433
It's not just a capability check but like an actual--

02:37:58,433 --> 02:37:59,839
- [David] Well they should be

02:37:59,839 --> 02:38:02,230
using the translation thing already.

02:38:02,230 --> 02:38:03,412
- Well, no, no, but this would be the,

02:38:03,412 --> 02:38:04,954
yes for the devices translators.

02:38:04,954 --> 02:38:07,936
(people chattering softly)

02:38:07,936 --> 02:38:09,256
(man laughing)

02:38:09,256 --> 02:38:11,267
(laughing drowns out speaker)

02:38:11,267 --> 02:38:13,350
- No, no, you first.

02:38:13,350 --> 02:38:14,557
Yes for the device translation

02:38:14,557 --> 02:38:15,799
but not for the other one, right?

02:38:15,799 --> 02:38:18,632
You wouldn't be able to translate on the--

02:38:18,632 --> 02:38:20,694
- Well, if you're passing to roll UID,

02:38:20,694 --> 02:38:23,031
it depends on what it's gonna do with that roll UID.

02:38:23,031 --> 02:38:25,356
If it's actually just gonna write it straight to disk--

02:38:25,356 --> 02:38:26,593
- [Man] Yes, this is the problem is--

02:38:26,593 --> 02:38:31,593
- That would require either the ioctl handler vetting

02:38:31,657 --> 02:38:34,192
or it would require some sort of override.

02:38:34,192 --> 02:38:36,974
(man speaking softly)

02:38:36,974 --> 02:38:40,263
- But if you translate the cred before you get there,

02:38:40,263 --> 02:38:41,263
you're fine.

02:38:42,224 --> 02:38:43,057
- Yeah.

02:38:43,057 --> 02:38:44,168
I'm just careful.

02:38:44,168 --> 02:38:47,632
I would just be careful to be so cheery about the ioctl case

02:38:47,632 --> 02:38:50,359
because ioctls have proven to be really, really horrible

02:38:50,359 --> 02:38:52,785
because they bypass all kinds of permissions

02:38:52,785 --> 02:38:55,165
and file systems do not crazy stuff.

02:38:55,165 --> 02:38:58,544
Well, they do crazy stuff to be honest.

02:38:58,544 --> 02:39:01,897
Behind the, VFS has no control over whatsoever.

02:39:01,897 --> 02:39:05,062
That's why I'm just kind of careful.

02:39:05,062 --> 02:39:08,207
- We can put a translation around it

02:39:08,207 --> 02:39:10,062
but if it's doing something crazy

02:39:10,062 --> 02:39:12,221
like just taking and writing straight to disk,

02:39:12,221 --> 02:39:14,236
short of changing the driver,

02:39:14,236 --> 02:39:15,633
there's nothing we can do about it.

02:39:15,633 --> 02:39:17,407
Even using shiftfs, there's nothing you can do about it.

02:39:17,407 --> 02:39:18,240
- Right, yeah.

02:39:18,240 --> 02:39:19,073
I think, yeah.

02:39:19,073 --> 02:39:21,235
I think there will also be file system changes needed

02:39:21,235 --> 02:39:23,071
but that's a different topic that's independent

02:39:23,071 --> 02:39:24,488
of shiftfs stuff.

02:39:25,371 --> 02:39:28,358
- I was gonna say, like for shiftfs,

02:39:28,358 --> 02:39:30,723
we don't just like, for in the btrfs case,

02:39:30,723 --> 02:39:32,048
we don't just like fold everything.

02:39:32,048 --> 02:39:34,212
Obviously we do validation for exactly

02:39:34,212 --> 02:39:36,665
what ioctls we know are supposed to be safe

02:39:36,665 --> 02:39:38,619
and provision what case.

02:39:38,619 --> 02:39:42,347
And for this, we could solely have a particular VFS be,

02:39:42,347 --> 02:39:44,014
oh, that bit is set.

02:39:44,922 --> 02:39:47,351
Good check with the file system.

02:39:47,351 --> 02:39:50,474
Advertise itself as being able to do those things simply.

02:39:50,474 --> 02:39:53,744
If not, then you just reject that entirely.

02:39:53,744 --> 02:39:56,124
So to try and make it safe so that you can land that stuff

02:39:56,124 --> 02:39:57,948
without causing security issues.

02:39:57,948 --> 02:40:01,236
- The ioctl, so the driver can see that the

02:40:01,236 --> 02:40:03,236
translation is in place.

02:40:05,707 --> 02:40:10,340
So, we could make the drivers do the auditing.

02:40:10,340 --> 02:40:13,172
- Yeah, I mean, obviously we're gonna need to

02:40:13,172 --> 02:40:15,944
'cause in the actual file systems.

02:40:15,944 --> 02:40:17,278
Ah, (mumbles) yeah.

02:40:17,278 --> 02:40:18,111
- Just looking.

02:40:18,111 --> 02:40:19,795
So we're gonna have trouble with extended attributes.

02:40:19,795 --> 02:40:21,718
They still only take dentries, not files.

02:40:21,718 --> 02:40:23,597
So they're going to have to be re-threaded.

02:40:23,597 --> 02:40:24,430
Right?

02:40:24,430 --> 02:40:25,303
All of the ex attributes.

02:40:25,303 --> 02:40:27,677
- Oh, well, that needs to get fixed anyway.

02:40:27,677 --> 02:40:28,510
It's buggy.

02:40:28,510 --> 02:40:30,247
- Oh, so everybody agrees that it needs to be fixed.

02:40:30,247 --> 02:40:32,754
It's just that nobody has tried to fix it yet

02:40:32,754 --> 02:40:34,808
because they're all waiting for somebody else to fix it

02:40:34,808 --> 02:40:36,324
so you just stepped in the tar pit.

02:40:36,324 --> 02:40:38,121
(people laughing)

02:40:38,121 --> 02:40:39,560
- Yay!

02:40:39,560 --> 02:40:41,395
- No, no, I actually don't,

02:40:41,395 --> 02:40:43,200
you know, it's just one of those that--

02:40:43,200 --> 02:40:45,911
- This is what (background noise drowns out speaker) is for.

02:40:45,911 --> 02:40:47,319
Get Link is gonna be another problem.

02:40:47,319 --> 02:40:48,548
So these are your problem APIs.

02:40:48,548 --> 02:40:51,881
It's the extended attribute on Get Link.

02:40:52,954 --> 02:40:54,961
Link API is another crappy one.

02:40:54,961 --> 02:40:55,974
Look at that.

02:40:55,974 --> 02:40:59,400
So these, all these VFS APIs are gonna have to altered.

02:40:59,400 --> 02:41:00,963
- Oh, no.

02:41:00,963 --> 02:41:04,303
Those are the, that's what the file system implements.

02:41:04,303 --> 02:41:07,636
You know, we're looking at the VFS read,

02:41:09,324 --> 02:41:12,843
or above that in the system calls.

02:41:12,843 --> 02:41:17,200
So, we don't necessarily have to change these

02:41:17,200 --> 02:41:20,725
because we're changing current cred before we call those.

02:41:20,725 --> 02:41:22,058
That's the idea.

02:41:23,162 --> 02:41:25,011
- And that's something that shiftfs couldn't do.

02:41:25,011 --> 02:41:25,986
Okay.

02:41:25,986 --> 02:41:27,010
- Yeah, you know.

02:41:27,010 --> 02:41:28,332
We could prototype it with just shiftfs

02:41:28,332 --> 02:41:30,499
changing current cred but,

02:41:32,680 --> 02:41:36,692
but that's the idea and if we can change current cred

02:41:36,692 --> 02:41:40,118
in the right location, it'll be real cheap and fast.

02:41:40,118 --> 02:41:40,951
That's--

02:41:40,951 --> 02:41:43,284
- So the upshot is we still have to prototype it.

02:41:43,284 --> 02:41:44,617
- Yes, yes, yes.

02:41:46,345 --> 02:41:47,262
Absolutely.

02:41:48,654 --> 02:41:49,487
- Oh, it's okay.

02:41:49,487 --> 02:41:50,320
We always ignore you.

02:41:50,320 --> 02:41:52,424
(people laughing)

02:41:52,424 --> 02:41:54,492
- [Man] Thank you.

02:41:54,492 --> 02:41:55,597
- [Man] Okay, well.

02:41:55,597 --> 02:41:59,896
- [Man] It's a good time for our next talk.

02:41:59,896 --> 02:42:02,729
- Someone needs to mircophone him.

02:42:04,585 --> 02:42:05,983
Oh, he's coming.

02:42:05,983 --> 02:42:10,285
(background noise drowns out speaker)

02:42:10,285 --> 02:42:12,021
Oh, it's because Eric was walking right by the (mumbles).

02:42:12,021 --> 02:42:14,604
(man laughing)

02:42:18,801 --> 02:42:22,384
(people chattering softly)

02:43:08,369 --> 02:43:09,205
- Hello, hello, hello.

02:43:09,205 --> 02:43:11,208
All right, awesome.

02:43:11,208 --> 02:43:13,008
Okay, all right.

02:43:13,008 --> 02:43:16,036
Yeah, so this is about securing path resolution

02:43:16,036 --> 02:43:18,286
with openat2 and libpathrs.

02:43:19,217 --> 02:43:21,433
So hi, I'm Aleksa and I'll be talking about some work

02:43:21,433 --> 02:43:23,170
that I've been doing for the past couple of months

02:43:23,170 --> 02:43:25,603
and hopefully open some discussion about,

02:43:25,603 --> 02:43:28,270
to get an idea of what I missed.

02:43:28,270 --> 02:43:30,188
So I'm gonna give a quick whirlwind tour

02:43:30,188 --> 02:43:32,041
for those of you who don't know what this work is

02:43:32,041 --> 02:43:33,716
along with some of the problems that it solves.

02:43:33,716 --> 02:43:36,968
Then we can get into a discussion.

02:43:36,968 --> 02:43:40,240
So, first of all, where can you find all this stuff?

02:43:40,240 --> 02:43:41,194
I should probably start with this.

02:43:41,194 --> 02:43:44,264
So, the patch set, the Linux patch set is here

02:43:44,264 --> 02:43:46,490
on GitHub at that branch.

02:43:46,490 --> 02:43:49,327
I posted V12 last week and it has some fixes already

02:43:49,327 --> 02:43:52,353
so I'll post V13 maybe next week.

02:43:52,353 --> 02:43:54,386
There's another article about it

02:43:54,386 --> 02:43:57,165
which gives a pretty good overview of openat2

02:43:57,165 --> 02:43:59,911
and what each flag does and what their features are

02:43:59,911 --> 02:44:02,494
and then libpathrs lives there.

02:44:03,371 --> 02:44:05,249
So, first let's talk about what is an example

02:44:05,249 --> 02:44:07,420
of an unsafe resolution of a path

02:44:07,420 --> 02:44:10,357
and this sort of, once you look into it,

02:44:10,357 --> 02:44:12,273
it starts getting pretty scary pretty quickly.

02:44:12,273 --> 02:44:16,827
So, effectively, if you have a privileged program

02:44:16,827 --> 02:44:21,475
that is opening /foo/bar/shadow

02:44:21,475 --> 02:44:24,571
and bar is controlled by an attacker,

02:44:24,571 --> 02:44:28,239
there are a variety of scenarios where the attacker

02:44:28,239 --> 02:44:30,948
can start tricking the program into opening files

02:44:30,948 --> 02:44:31,781
it shouldn't mean to.

02:44:31,781 --> 02:44:34,024
So for instance, if shadow's a symlink,

02:44:34,024 --> 02:44:36,294
you can make it open, I dunno,

02:44:36,294 --> 02:44:39,800
exe shadow or some other bad file.

02:44:39,800 --> 02:44:41,541
However, you can fix that with O_NOFOLLOW

02:44:41,541 --> 02:44:44,950
which blocks trailing symlinks from being followed.

02:44:44,950 --> 02:44:46,981
However, what if bar is a symlink?

02:44:46,981 --> 02:44:50,211
So in other words, what is bar is a symlink to /exe,

02:44:50,211 --> 02:44:51,445
how do you detect this?

02:44:51,445 --> 02:44:54,298
And there isn't actually a native way of detecting this

02:44:54,298 --> 02:44:57,869
within open and so, effectively the solution here,

02:44:57,869 --> 02:45:00,188
so what will happen is you'll open exe shadow on the host

02:45:00,188 --> 02:45:01,993
and then possibly it pipe it to output

02:45:01,993 --> 02:45:03,833
and bad things happen.

02:45:03,833 --> 02:45:04,754
So it's like, okay, well the solution

02:45:04,754 --> 02:45:06,723
is to sanitize the path in userspace

02:45:06,723 --> 02:45:08,298
and this is actually as an aside,

02:45:08,298 --> 02:45:10,050
you see the CVE list down here.

02:45:10,050 --> 02:45:11,748
These are a list of programs that have tried this.

02:45:11,748 --> 02:45:14,723
Effectively Docker did this for a long time.

02:45:14,723 --> 02:45:16,059
Docker still does this.

02:45:16,059 --> 02:45:19,311
There are a bunch of other programs that do this

02:45:19,311 --> 02:45:21,560
where they try to sanitize the path in userspace

02:45:21,560 --> 02:45:23,572
where effectively you walk down the path components

02:45:23,572 --> 02:45:25,949
and you say, okay, is foo a symlink, yes or no?

02:45:25,949 --> 02:45:26,854
Foo isn't a symlink.

02:45:26,854 --> 02:45:28,015
Okay, keep foo.

02:45:28,015 --> 02:45:28,848
Is bar a symlink?

02:45:28,848 --> 02:45:29,681
Oh, bar is a symlink.

02:45:29,681 --> 02:45:32,951
So then I'll read what bar is and then I'll resolve it

02:45:32,951 --> 02:45:34,336
and then if I wanna stay inside foo,

02:45:34,336 --> 02:45:37,137
I'll do all the path resolution and so and so on.

02:45:37,137 --> 02:45:38,901
And then you end up with a new string which is,

02:45:38,901 --> 02:45:40,575
ah, this is the safe path.

02:45:40,575 --> 02:45:42,157
But what if one of the components gets changed

02:45:42,157 --> 02:45:43,523
after you've done the sanitization?

02:45:43,523 --> 02:45:45,652
It's a classic time and check time of use attack

02:45:45,652 --> 02:45:47,688
and there's not really much you can do in this case.

02:45:47,688 --> 02:45:49,527
Now, as I'll mention later, there is a way

02:45:49,527 --> 02:45:51,460
you can do this safely today

02:45:51,460 --> 02:45:53,426
but it's very, very complicated to do correctly.

02:45:53,426 --> 02:45:56,143
It requires a lot of fiddling with O_PATH file descriptors

02:45:56,143 --> 02:45:57,886
and double checking through procfs.

02:45:57,886 --> 02:46:00,233
Effectively, I would argue that there are very few

02:46:00,233 --> 02:46:02,669
programs that do this correctly today

02:46:02,669 --> 02:46:05,250
and yet it's such a common operation.

02:46:05,250 --> 02:46:07,179
I mean, open a file is the first thing you learn

02:46:07,179 --> 02:46:08,159
in Unix programming.

02:46:08,159 --> 02:46:10,155
So it's a little bit scary that this sort of basics

02:46:10,155 --> 02:46:12,194
are quite worrying.

02:46:12,194 --> 02:46:14,830
And so, yeah, these are all examples of CVEs

02:46:14,830 --> 02:46:18,603
that are at least related either directly or tangentially.

02:46:18,603 --> 02:46:20,345
And, there are probably many, many more countless

02:46:20,345 --> 02:46:23,144
undiscovered bugs that are related to this.

02:46:23,144 --> 02:46:25,603
And so, the solution for this is to add a set of flags

02:46:25,603 --> 02:46:28,758
to open that allows you to restrict the resolution process,

02:46:28,758 --> 02:46:32,004
which is what openat2 is, which I'll go through in a second.

02:46:32,004 --> 02:46:34,977
But this is one problem that needs to get solved.

02:46:34,977 --> 02:46:35,991
While I was working through this,

02:46:35,991 --> 02:46:37,591
I discovered a couple more problems.

02:46:37,591 --> 02:46:40,227
One of them is file descriptor trickery.

02:46:40,227 --> 02:46:42,224
So this is something that is actually not very well known,

02:46:42,224 --> 02:46:44,183
at least from what I've seen,

02:46:44,183 --> 02:46:46,496
is that you can reopen a file descriptor,

02:46:46,496 --> 02:46:48,548
so let's say you open a file descriptor,

02:46:48,548 --> 02:46:53,006
I dunno, foo, and you open it with read capabilities.

02:46:53,006 --> 02:46:55,371
You can then reopen it through /proc/self/fd/

02:46:55,371 --> 02:46:58,081
with write capabilities, even though you originally

02:46:58,081 --> 02:46:59,258
opened it with read capabilities.

02:46:59,258 --> 02:47:01,002
Now, it should be noted obviously

02:47:01,002 --> 02:47:03,072
that there are still inode permission checks going on

02:47:03,072 --> 02:47:04,797
so it's not like you can open anything

02:47:04,797 --> 02:47:07,147
but the primary problem is is that there are examples

02:47:07,147 --> 02:47:10,886
where you get a file descriptor and you shouldn't,

02:47:10,886 --> 02:47:12,943
it doesn't make sense for you to be able

02:47:12,943 --> 02:47:13,862
to open up for writing.

02:47:13,862 --> 02:47:17,661
For instance, this security bug over here, (mumbles),

02:47:17,661 --> 02:47:21,990
the way this was exploited is that you open /proc/self/exe,

02:47:21,990 --> 02:47:24,027
right, which is a pointer to the executable

02:47:24,027 --> 02:47:26,741
of an existing process, and you open it for reading,

02:47:26,741 --> 02:47:28,706
you obviously can't open it for writing

02:47:28,706 --> 02:47:31,469
because it's the live memory of an executable.

02:47:31,469 --> 02:47:32,361
You get etext busy.

02:47:32,361 --> 02:47:34,269
So you open it for reading.

02:47:34,269 --> 02:47:35,881
Then you wait for the process to die

02:47:35,881 --> 02:47:37,557
and then you reopen it for writing

02:47:37,557 --> 02:47:39,205
and this is in the context of a container.

02:47:39,205 --> 02:47:41,266
So the container has no way of accessing this host,

02:47:41,266 --> 02:47:44,593
this host file, and yet it can open it for writing.

02:47:44,593 --> 02:47:47,203
It should be noted, however, and also this works

02:47:47,203 --> 02:47:49,134
with O_PATH so you don't have to open it for reading.

02:47:49,134 --> 02:47:52,156
You can open with O_PATH and so on and so on.

02:47:52,156 --> 02:47:53,951
The point being that,

02:47:53,951 --> 02:47:55,638
the point is this is actually useful.

02:47:55,638 --> 02:47:57,364
So both LXC and runc actually use this

02:47:57,364 --> 02:47:59,416
to improve the security of containers

02:47:59,416 --> 02:48:01,960
through a variety of quite hairy tricks

02:48:01,960 --> 02:48:04,610
but effectively this is actually quite a useful feature.

02:48:04,610 --> 02:48:06,646
The problem is this fact that you can open something

02:48:06,646 --> 02:48:10,276
for reading and then later open it for writing.

02:48:10,276 --> 02:48:12,362
So the solution for this problem is,

02:48:12,362 --> 02:48:15,795
which is what the patch does is that it makes magic-links,

02:48:15,795 --> 02:48:19,165
these procfs FD symlinks are actually more magical

02:48:19,165 --> 02:48:21,415
and so we obey their modes.

02:48:23,465 --> 02:48:28,197
The F mode is exposed in procfs is you look at,

02:48:28,197 --> 02:48:29,030
whoops.

02:48:32,366 --> 02:48:35,328
So this, I'm running the version where I patched

02:48:35,328 --> 02:48:36,942
so the mode looks different to what it'll look like

02:48:36,942 --> 02:48:41,505
in your system but the point is is that this is F mode.

02:48:41,505 --> 02:48:44,657
So this file is opened with read and write

02:48:44,657 --> 02:48:46,366
so you get read and write here.

02:48:46,366 --> 02:48:48,678
So what you do is that when I try to open

02:48:48,678 --> 02:48:50,633
this file descriptor,

02:48:50,633 --> 02:48:52,926
a permission check is actually done on this.

02:48:52,926 --> 02:48:56,238
In old kernels, this wasn't done and so on and so on.

02:48:56,238 --> 02:48:59,655
So, that's the solution and then, whoops.

02:49:01,353 --> 02:49:02,770
Let's go forward.

02:49:04,556 --> 02:49:05,973
Money, oh, right.

02:49:06,820 --> 02:49:07,653
Okay.

02:49:07,653 --> 02:49:08,835
And then you just have to fix that

02:49:08,835 --> 02:49:12,788
and then also for other reasons you need to also deal

02:49:12,788 --> 02:49:15,320
with O_PATH and O_PATH inherits the mode

02:49:15,320 --> 02:49:19,076
of a magic-link effectively, which solves both problems.

02:49:19,076 --> 02:49:20,908
And then one more thing is that one thing

02:49:20,908 --> 02:49:23,856
that's coming up quite often is that there are examples

02:49:23,856 --> 02:49:27,583
of use cases where you need to do things without procfs

02:49:27,583 --> 02:49:31,166
and now that we have this hardening to stop

02:49:32,474 --> 02:49:35,236
these types of attacks, we can now expose

02:49:35,236 --> 02:49:38,571
the ability to open a file descriptor without procfs

02:49:38,571 --> 02:49:41,585
so this openat is identical to open /proc/self/fd/

02:49:41,585 --> 02:49:43,141
but without needing procfs.

02:49:43,141 --> 02:49:45,009
And then obviously because of backwards

02:49:45,009 --> 02:49:48,467
compatibility problems, O_EMPTYPATH actually

02:49:48,467 --> 02:49:52,759
doesn't cause the whole thing where basically open

02:49:52,759 --> 02:49:55,567
has never actually checked for invalid flags before.

02:49:55,567 --> 02:49:59,091
So, but because this O_EMPTYPATH only acts

02:49:59,091 --> 02:50:02,088
for empty strings, there's no backwards

02:50:02,088 --> 02:50:05,025
compatibility problem because empty string pods

02:50:05,025 --> 02:50:07,318
have always been invalid.

02:50:07,318 --> 02:50:08,544
Okay and then there's openat2,

02:50:08,544 --> 02:50:10,125
which is the actual syscall.

02:50:10,125 --> 02:50:12,574
So effectively this allows us to,

02:50:12,574 --> 02:50:16,147
and as we mentioned a couple of times today,

02:50:16,147 --> 02:50:17,841
we're now moving towards extensive syscalls

02:50:17,841 --> 02:50:21,366
so effectively rather than adding new flag arguments,

02:50:21,366 --> 02:50:24,274
instead we paths of struct.

02:50:24,274 --> 02:50:27,107
The struct has flags in mode just as all open,

02:50:27,107 --> 02:50:30,676
however, it should be noted that unlike open,

02:50:30,676 --> 02:50:34,027
we give you E inval if the flag is unknown

02:50:34,027 --> 02:50:36,529
or if the mode is set when it shouldn't be set.

02:50:36,529 --> 02:50:39,255
So, effectively you actually get return value

02:50:39,255 --> 02:50:40,853
telling you, no, actually this kernel

02:50:40,853 --> 02:50:43,439
doesn't support this feature.

02:50:43,439 --> 02:50:46,028
This upgrade mask is related to reopening.

02:50:46,028 --> 02:50:47,342
I can get into it if anyone's interested

02:50:47,342 --> 02:50:49,715
but effectively it allows you to, as I said,

02:50:49,715 --> 02:50:52,485
O_PATH inherits the mode but this lets you restrict it.

02:50:52,485 --> 02:50:55,026
So you can say, you can open an O_PATH of a file

02:50:55,026 --> 02:50:57,456
but you can say you cannot open this for reading,

02:50:57,456 --> 02:50:59,695
even if you normally could.

02:50:59,695 --> 02:51:03,038
And then resolve flags is the resolution problem

02:51:03,038 --> 02:51:06,119
that I was mentioning with foo bar baz.

02:51:06,119 --> 02:51:09,036
Effectively, this is where the new flags go

02:51:09,036 --> 02:51:12,033
and you can extend this struct by increasing the size

02:51:12,033 --> 02:51:13,393
and adding new feature fields.

02:51:13,393 --> 02:51:14,518
So, people have already mentioned to me

02:51:14,518 --> 02:51:17,556
some ideas for new extensions we could do to open

02:51:17,556 --> 02:51:21,764
and because this is extensible, you can do this.

02:51:21,764 --> 02:51:23,468
This work was discussed last year

02:51:23,468 --> 02:51:24,888
so I'm not gonna go through any of this.

02:51:24,888 --> 02:51:26,998
Effectively, these are the new flags.

02:51:26,998 --> 02:51:29,245
They let you block through resolution certain things

02:51:29,245 --> 02:51:31,320
so you can block mount point crossings.

02:51:31,320 --> 02:51:33,828
You can block magic links, symlinks.

02:51:33,828 --> 02:51:37,392
You can block jumps to root and dot dot escaping root

02:51:37,392 --> 02:51:40,520
and RESOLVE_IN_ROOT effectively is like a CH root

02:51:40,520 --> 02:51:43,770
during resolution but we deal with some

02:51:45,385 --> 02:51:47,441
of the CH problems so it doesn't actually,

02:51:47,441 --> 02:51:48,527
it doesn't escape though.

02:51:48,527 --> 02:51:50,695
You can't escape it.

02:51:50,695 --> 02:51:53,750
And so, the last thing is libpathrs.

02:51:53,750 --> 02:51:55,215
So all of this work is very useful

02:51:55,215 --> 02:51:58,246
but the thing is is that using the RESOLVE_IN_ROOT stuff

02:51:58,246 --> 02:52:00,144
is actually quite complicated

02:52:00,144 --> 02:52:03,478
because not all syscalls support it.

02:52:03,478 --> 02:52:05,065
Obviously only one syscall supports it

02:52:05,065 --> 02:52:07,222
but in order to write a program that deals

02:52:07,222 --> 02:52:08,055
with a file system,

02:52:08,055 --> 02:52:09,703
you need to do more than just open things.

02:52:09,703 --> 02:52:12,210
You need to, for instance, hard link things,

02:52:12,210 --> 02:52:13,988
unlink things, and so on and so on.

02:52:13,988 --> 02:52:18,155
So effectively, you need to use a different, yeah,

02:52:19,861 --> 02:52:23,464
you need to have different semantics and effectively

02:52:23,464 --> 02:52:25,667
to use it correctly, you would in fact need to

02:52:25,667 --> 02:52:28,358
take a path, resolve it as a file descriptor

02:52:28,358 --> 02:52:29,680
and then pass it on the file descriptor.

02:52:29,680 --> 02:52:31,524
A lot of programs instead deal with strings

02:52:31,524 --> 02:52:34,054
as paths which is not actually the right model

02:52:34,054 --> 02:52:37,188
if you're trying to defend against attackers.

02:52:37,188 --> 02:52:38,248
Yes?

02:52:38,248 --> 02:52:42,233
- No, I think, yes, probably we would need

02:52:42,233 --> 02:52:45,070
to change userspace over time but openat2

02:52:45,070 --> 02:52:49,070
is extremely useful for programs that want to be

02:52:50,259 --> 02:52:51,695
secure proactively.

02:52:51,695 --> 02:52:54,996
I mean, container managers are, in this case,

02:52:54,996 --> 02:52:57,464
something that, it's just the obvious example.

02:52:57,464 --> 02:53:01,111
It's like, I'm managing mounting for,

02:53:01,111 --> 02:53:02,534
or whatever path resolution

02:53:02,534 --> 02:53:05,367
for a process I don't fully trust.

02:53:06,784 --> 02:53:09,223
Or configured by a user that I don't fully trust.

02:53:09,223 --> 02:53:12,468
That's really it's useful right away.

02:53:12,468 --> 02:53:13,301
I mean.

02:53:13,301 --> 02:53:14,666
- Yeah and also, I mean, for instance

02:53:14,666 --> 02:53:16,476
if you wanna extract with inside a root

02:53:16,476 --> 02:53:19,642
that you don't trust, this also protects you against that.

02:53:19,642 --> 02:53:21,165
And so on and so on.

02:53:21,165 --> 02:53:23,725
But another key thing, and this is sort of the real reason

02:53:23,725 --> 02:53:26,043
why I wrote this is how on earth would you deal

02:53:26,043 --> 02:53:28,875
with old kernels because obviously openat2 today is great

02:53:28,875 --> 02:53:31,257
but you still need programs running old kernels.

02:53:31,257 --> 02:53:33,745
What this library does is that it actually emulates

02:53:33,745 --> 02:53:35,242
RESOLVE_IN_ROOT on old kernels.

02:53:35,242 --> 02:53:36,953
Now, I mention that this is difficult to do

02:53:36,953 --> 02:53:39,409
but it's not impossible.

02:53:39,409 --> 02:53:42,826
Effectively, you can safely resolve paths

02:53:44,698 --> 02:53:48,560
using O_PATH descriptors where by you emulate the opening.

02:53:48,560 --> 02:53:50,012
So you have foo bar baz.

02:53:50,012 --> 02:53:51,503
You open foo as O_PATH.

02:53:51,503 --> 02:53:53,317
Then you check it and then you underneath it

02:53:53,317 --> 02:53:55,566
open the next the component.

02:53:55,566 --> 02:53:57,663
If you have the write combination of owner follow

02:53:57,663 --> 02:54:00,377
and so on and so on, it ends up being safe

02:54:00,377 --> 02:54:03,624
and actually I have examples where you can actually

02:54:03,624 --> 02:54:05,849
do the read in attack for the CVEs I mentioned,

02:54:05,849 --> 02:54:09,011
it doesn't work if you use the emulated version.

02:54:09,011 --> 02:54:12,091
So the same attack fails on both the kernel version

02:54:12,091 --> 02:54:13,966
and the emulated version.

02:54:13,966 --> 02:54:14,799
Yup?

02:54:14,799 --> 02:54:17,081
- The difference for RESOLVE_IN_ROOT being

02:54:17,081 --> 02:54:18,223
that you don't get an error.

02:54:18,223 --> 02:54:20,433
It's just always when you try to escape

02:54:20,433 --> 02:54:22,385
from your current root

02:54:22,385 --> 02:54:26,638
is you just get resolved to the current root.

02:54:26,638 --> 02:54:27,471
Right?

02:54:27,471 --> 02:54:28,979
- [Aleksa] No, no, you get the (mumbles).

02:54:28,979 --> 02:54:29,812
This was changed, yes.

02:54:29,812 --> 02:54:30,645
- Oh, okay.

02:54:30,645 --> 02:54:33,579
So then it's basically exactly what we did,

02:54:33,579 --> 02:54:35,801
what we do in LXE when we mount a path.

02:54:35,801 --> 02:54:36,634
- Right, yeah.

02:54:36,634 --> 02:54:39,434
This is basically the same thing that LXE and XE do.

02:54:39,434 --> 02:54:40,740
It's just that it's separate libraries

02:54:40,740 --> 02:54:44,158
so people can use it because it also has an idiomatic.

02:54:44,158 --> 02:54:47,024
Effectively, it's made such that it's more idiomatic to use

02:54:47,024 --> 02:54:48,950
because rather than it being like you write the program

02:54:48,950 --> 02:54:51,739
logic to use O_PATH everywhere, instead, yeah, exactly.

02:54:51,739 --> 02:54:52,632
I've seen the code too.

02:54:52,632 --> 02:54:55,352
Effectively, you have a handle which is actually an FD

02:54:55,352 --> 02:54:58,227
and then you, that wasn't meant to be a dig.

02:54:58,227 --> 02:55:01,592
It's always gonna be ugly unless you separate it out.

02:55:01,592 --> 02:55:02,913
And so, the idea would be to use this.

02:55:02,913 --> 02:55:04,854
The only downside, and I'm sure people will have opinions

02:55:04,854 --> 02:55:07,336
about this is that it's currently a Rust library.

02:55:07,336 --> 02:55:10,735
I know that this is gonna cause many problems.

02:55:10,735 --> 02:55:12,640
Yeah, I mean, if people really want it to be written,

02:55:12,640 --> 02:55:15,252
it can be done but from what I've heard

02:55:15,252 --> 02:55:16,984
Rust libraries and distributions is no longer

02:55:16,984 --> 02:55:19,456
as much of a nightmare as it was two years ago.

02:55:19,456 --> 02:55:21,052
But, feel free to prove me wrong on that one.

02:55:21,052 --> 02:55:22,179
- [Man] Keep telling that to yourself.

02:55:22,179 --> 02:55:23,012
- Yeah.

02:55:23,012 --> 02:55:23,845
(laughing)

02:55:23,845 --> 02:55:25,504
Oh shit.

02:55:25,504 --> 02:55:27,403
- [Man] Does it have C bindings?

02:55:27,403 --> 02:55:28,236
- Sorry?

02:55:28,236 --> 02:55:29,537
- [Man] Does your Rust library have C bindings?

02:55:29,537 --> 02:55:30,370
- Yeah, yeah.

02:55:30,370 --> 02:55:31,203
The main interface is C bindings.

02:55:31,203 --> 02:55:33,745
And in fact, I have a Python wrapper.

02:55:33,745 --> 02:55:35,507
I don't know if I have it on this laptop

02:55:35,507 --> 02:55:36,967
but I have a Python, whatever.

02:55:36,967 --> 02:55:38,138
The point is I have a Python wrapper

02:55:38,138 --> 02:55:41,647
which I use for testing which uses the C etherfi libraries,

02:55:41,647 --> 02:55:46,064
uses Python's etherfi and then the etherfi into Rust.

02:55:47,576 --> 02:55:50,375
- So, having written programs in Rust as well

02:55:50,375 --> 02:55:54,452
and working on like a sort of exemplary kernel module,

02:55:54,452 --> 02:55:57,441
the really nice thing is that it has bind gam,

02:55:57,441 --> 02:55:59,241
which generates C bindings automatically.

02:55:59,241 --> 02:56:01,136
Then you still have to do some wrapper writing work

02:56:01,136 --> 02:56:03,877
but it's like well thought out and it's done.

02:56:03,877 --> 02:56:07,250
You don't have to do it yourself.

02:56:07,250 --> 02:56:09,588
- Yeah and so the idea is to effectively,

02:56:09,588 --> 02:56:11,623
actually I can actually just show you what it looks like.

02:56:11,623 --> 02:56:12,873
So, if I go to,

02:56:20,135 --> 02:56:22,802
so the API looks something like,

02:56:23,908 --> 02:56:25,741
so this is like, oops.

02:56:28,405 --> 02:56:32,449
So you open a root and the path and then you then

02:56:32,449 --> 02:56:35,865
underneath it can do mkdar underneath the path.

02:56:35,865 --> 02:56:37,716
You can do mknod and all of this is backed

02:56:37,716 --> 02:56:38,549
by RESOLVE_IN_ROOT.

02:56:38,549 --> 02:56:40,896
The idea is basically looks like normal syscalls

02:56:40,896 --> 02:56:44,812
but instead it's using the RESOLVE_IN_ROOT handling,

02:56:44,812 --> 02:56:46,652
all of the weird cases where, for instance,

02:56:46,652 --> 02:56:48,451
you need to unlink a file.

02:56:48,451 --> 02:56:50,880
You need to resolve IN_ROOT of the director, the parent,

02:56:50,880 --> 02:56:53,237
and then you need to unlike the child and for rename,

02:56:53,237 --> 02:56:55,105
rename exchange and you need to, and so on and so on.

02:56:55,105 --> 02:56:58,040
So dealing with all that lovely semantics.

02:56:58,040 --> 02:57:01,562
As an aside, I discovered that there's no way in Linux

02:57:01,562 --> 02:57:05,118
to just unlink something without caring what it is

02:57:05,118 --> 02:57:07,894
because if you tried to unlink something as a directory,

02:57:07,894 --> 02:57:09,244
unlink at has at removed.

02:57:09,244 --> 02:57:12,288
You cannot just say unlink.

02:57:12,288 --> 02:57:14,523
I don't care what it is.

02:57:14,523 --> 02:57:17,610
I mean, I don't care I can just retry.

02:57:17,610 --> 02:57:20,882
It's just funny that this doesn't exist.

02:57:20,882 --> 02:57:23,263
And yeah, once you have one of these handles,

02:57:23,263 --> 02:57:26,602
so then you resolve a handle within the root,

02:57:26,602 --> 02:57:28,885
you get this handle descriptor which is an O_PATH

02:57:28,885 --> 02:57:33,009
of the thing you just resolved and then you can reopen it

02:57:33,009 --> 02:57:34,676
to get an actual FD.

02:57:35,997 --> 02:57:37,249
Is the ID use case.

02:57:37,249 --> 02:57:39,259
The reason why you have this intermediate resolve

02:57:39,259 --> 02:57:42,197
is for the LXC use case or rather the container use case

02:57:42,197 --> 02:57:47,193
whereby you want to be able to reopen /dev/pts/ptmx

02:57:47,193 --> 02:57:49,740
inside a container because you can't, yeah.

02:57:49,740 --> 02:57:52,574
- It's not even that pressing of an issue

02:57:52,574 --> 02:57:57,407
because we haven't really made much use of this for these.

02:57:58,401 --> 02:58:01,942
So basically we're still in using the devpts mount

02:58:01,942 --> 02:58:05,631
from the host, not inside of the container.

02:58:05,631 --> 02:58:08,074
So it's not really that important.

02:58:08,074 --> 02:58:10,479
So it shouldn't block your, okay.

02:58:10,479 --> 02:58:11,365
- [Aleksa] I mean you just patch that.

02:58:11,365 --> 02:58:12,378
It's already done so--

02:58:12,378 --> 02:58:14,270
- His point being if you're doing an open

02:58:14,270 --> 02:58:16,559
on the devptms device, you automatically

02:58:16,559 --> 02:58:19,309
get a slay 50 for the slay sight.

02:58:20,184 --> 02:58:23,283
So you automatically allocate a new PTS device

02:58:23,283 --> 02:58:25,784
whereas if you do an O_PATH, you don't trigger

02:58:25,784 --> 02:58:27,600
an actual open.

02:58:27,600 --> 02:58:30,670
So you can send that FD around and then reopen

02:58:30,670 --> 02:58:32,221
to (background noise drowns out speaker) FD

02:58:32,221 --> 02:58:35,916
and then upgrade it and at that time you get a PTS device.

02:58:35,916 --> 02:58:37,490
- [Aleksa] Which is this is manuscript for.

02:58:37,490 --> 02:58:38,548
- This is the trick he's been talking about.

02:58:38,548 --> 02:58:39,381
- Right.

02:58:39,381 --> 02:58:41,546
The other point is that with the path rs handle,

02:58:41,546 --> 02:58:43,657
is that ideally what you would have is the programs

02:58:43,657 --> 02:58:46,040
that currently pass around string paths,

02:58:46,040 --> 02:58:47,567
they would resolve the path and then pass

02:58:47,567 --> 02:58:49,758
this around instead and then when they would normally

02:58:49,758 --> 02:58:51,655
do the open on the string, they would use this.

02:58:51,655 --> 02:58:54,092
Obviously it depends very much on what the program is doing

02:58:54,092 --> 02:58:56,939
but that would be the ideal case.

02:58:56,939 --> 02:58:58,867
And then I have Python wraparound

02:58:58,867 --> 02:59:02,026
that still does the same stuff and because I need this

02:59:02,026 --> 02:59:05,664
for my umoci, which is the OCI image tool I have,

02:59:05,664 --> 02:59:07,474
I'm also writing a Go wrapper for it.

02:59:07,474 --> 02:59:11,208
So you definitely, you can use it for different languages.

02:59:11,208 --> 02:59:12,914
Even if I end up rewriting it in C,

02:59:12,914 --> 02:59:15,027
the wrappers would still work.

02:59:15,027 --> 02:59:16,769
But yeah, and the important point is the reason

02:59:16,769 --> 02:59:18,407
why I have a library and not using syscall

02:59:18,407 --> 02:59:20,516
is that to correctly use the syscall you would need

02:59:20,516 --> 02:59:23,462
to rewrite or rather port programs to use it anyway.

02:59:23,462 --> 02:59:25,405
So the idea was that if we have a more idiomatic wrapper

02:59:25,405 --> 02:59:27,934
it might be more easy to convince people to use it

02:59:27,934 --> 02:59:30,136
because I've had some emails from people telling me

02:59:30,136 --> 02:59:32,096
that, oh, I saw you found a CVE inductor.

02:59:32,096 --> 02:59:33,458
Actually, it turns out these other 10 programs

02:59:33,458 --> 02:59:35,162
have the exact same problem.

02:59:35,162 --> 02:59:37,404
And so ideally we can fix those programs

02:59:37,404 --> 02:59:39,849
much more quickly than having to teach everyone

02:59:39,849 --> 02:59:41,835
what is the correct way to do an open,

02:59:41,835 --> 02:59:45,760
which is more complicated than it maybe should be.

02:59:45,760 --> 02:59:47,399
And then, what's next effectively.

02:59:47,399 --> 02:59:48,368
Openat2 merged.

02:59:48,368 --> 02:59:49,490
There are some open questions.

02:59:49,490 --> 02:59:50,898
I've put some flame bait on there

02:59:50,898 --> 02:59:52,158
in case we want to go into that

02:59:52,158 --> 02:59:54,859
and the other thing is to deport programs libpathrs.

02:59:54,859 --> 02:59:56,370
And the neat thing is that we don't actually

02:59:56,370 --> 02:59:58,888
need the kernel work to stop doing the porting effort

02:59:58,888 --> 03:00:03,389
because, again, the emulation will work on all the kernels.

03:00:03,389 --> 03:00:05,505
But yeah, so any comments?

03:00:05,505 --> 03:00:07,441
Oh sorry, as an example of the open questions

03:00:07,441 --> 03:00:10,825
is that Andy Wojiminski had an idea for flags

03:00:10,825 --> 03:00:14,868
which is to try to fix up flags now but I think

03:00:14,868 --> 03:00:16,134
that's pretty much been knacked

03:00:16,134 --> 03:00:17,824
by everyone in the room, right?

03:00:17,824 --> 03:00:19,325
- Linus and Ingo, I think.

03:00:19,325 --> 03:00:21,236
- Yeah, I think that's dead in the water.

03:00:21,236 --> 03:00:23,217
Basically the problem is that,

03:00:23,217 --> 03:00:26,512
it's been a longstanding thing where O_READ only

03:00:26,512 --> 03:00:28,582
is equal to zero and it would be nice

03:00:28,582 --> 03:00:31,765
to not have this problem because it causes issues elsewhere

03:00:31,765 --> 03:00:33,496
but I think that's pretty much

03:00:33,496 --> 03:00:37,252
not gonna change effectively, I think.

03:00:37,252 --> 03:00:38,749
Yes?

03:00:38,749 --> 03:00:41,438
- The problem being, as far as I understand,

03:00:41,438 --> 03:00:44,891
the concern being that if you change,

03:00:44,891 --> 03:00:48,013
if you require too much change from userspace,

03:00:48,013 --> 03:00:50,139
like getting used to new flags and whatever,

03:00:50,139 --> 03:00:52,763
then the switch is never going to happen

03:00:52,763 --> 03:00:54,013
or in 20 years.

03:00:55,769 --> 03:00:56,918
- Yeah, yeah.

03:00:56,918 --> 03:00:58,470
So if we just keep this in flags

03:00:58,470 --> 03:00:59,931
then we don't have to worry about people

03:00:59,931 --> 03:01:01,195
not wanting to switch because it's just--

03:01:01,195 --> 03:01:02,246
- You need a set of new architectures

03:01:02,246 --> 03:01:05,717
that don't implement open but only implement openat2.

03:01:05,717 --> 03:01:07,107
- Yeah.

03:01:07,107 --> 03:01:08,486
And sorry, one other thing is--

03:01:08,486 --> 03:01:09,319
- Case in point.

03:01:09,319 --> 03:01:12,545
I think this takes the same as IPV4, just longer.

03:01:12,545 --> 03:01:15,163
(man laughing)

03:01:15,163 --> 03:01:16,533
- I'm not commenting on that.

03:01:16,533 --> 03:01:19,434
So, and then the other thing is sort of future work,

03:01:19,434 --> 03:01:20,814
which I talked to Eric about,

03:01:20,814 --> 03:01:24,786
which is right now there is no way to limit

03:01:24,786 --> 03:01:26,856
what file descriptors can be executed.

03:01:26,856 --> 03:01:29,001
So essentially if you have a file descriptor

03:01:29,001 --> 03:01:31,681
which the underlying file happens to be executable,

03:01:31,681 --> 03:01:34,053
if you open it for reading, for instance,

03:01:34,053 --> 03:01:38,704
you cannot limit it from being executed (mumbles)

03:01:38,704 --> 03:01:40,217
sorry, this is not the syscall.

03:01:40,217 --> 03:01:41,265
This is the wrapper.

03:01:41,265 --> 03:01:45,079
Exit VEF, you can exit it through /proc/self/fd/

03:01:45,079 --> 03:01:46,873
or through add a new path.

03:01:46,873 --> 03:01:49,259
The point being that for instance,

03:01:49,259 --> 03:01:50,771
I mean, I'm trying to think of a good example

03:01:50,771 --> 03:01:52,824
where this could be useful but for instance,

03:01:52,824 --> 03:01:54,511
imagine you're passing an FD to a process

03:01:54,511 --> 03:01:57,310
you don't trust and it's a set UID file.

03:01:57,310 --> 03:01:59,082
Let's say, like, I don't know,

03:01:59,082 --> 03:02:01,215
dumping all strings in a binary or something silly,

03:02:01,215 --> 03:02:03,491
right, and you give it a set UID program

03:02:03,491 --> 03:02:06,634
as readable, you don't want them to later be able

03:02:06,634 --> 03:02:07,927
to execute it.

03:02:07,927 --> 03:02:09,904
Maybe it's a buggy set UID binary.

03:02:09,904 --> 03:02:11,632
You can't do this limitation.

03:02:11,632 --> 03:02:15,493
I mean, you can unset, you can set minus exit

03:02:15,493 --> 03:02:17,547
but yeah, I think that it would be neat

03:02:17,547 --> 03:02:18,696
to be able to do this limiting

03:02:18,696 --> 03:02:20,601
but the problem is is that right now,

03:02:20,601 --> 03:02:23,470
as far as I can tell, there isn't an equivalent way

03:02:23,470 --> 03:02:24,764
to read and write because read and write

03:02:24,764 --> 03:02:27,005
have F mode write and so on and so on.

03:02:27,005 --> 03:02:28,347
But yeah, that's.

03:02:28,347 --> 03:02:33,014
- I think, at some point, proc had problems in this area

03:02:35,603 --> 03:02:38,686
where you could like exact, you know,

03:02:40,168 --> 03:02:43,965
proc pid environ, or something like that.

03:02:43,965 --> 03:02:45,531
(laughing)

03:02:45,531 --> 03:02:47,866
And there was also something where it wasn't

03:02:47,866 --> 03:02:50,927
checked in the permissions when you owned it.

03:02:50,927 --> 03:02:51,760
- [Aleksa] Oh God.

03:02:51,760 --> 03:02:52,637
- Picture modded it.

03:02:52,637 --> 03:02:53,906
Something like that.

03:02:53,906 --> 03:02:56,002
You could probably look in the Git history and find it.

03:02:56,002 --> 03:02:58,252
But, I have this vague memory

03:02:58,252 --> 03:03:00,736
that it's actually been a problem in the past

03:03:00,736 --> 03:03:04,378
and that might be worth looking up.

03:03:04,378 --> 03:03:07,410
- [Aleksa] Right 'cause in the case of (mumbles)

03:03:07,410 --> 03:03:11,099
actually no, environ isn't a magic link though, isn't it?

03:03:11,099 --> 03:03:12,173
- No, that's the thing.

03:03:12,173 --> 03:03:13,706
It's not a magic link.

03:03:13,706 --> 03:03:15,584
It's a magic file.

03:03:15,584 --> 03:03:16,657
- [Aleksa] Oh God.

03:03:16,657 --> 03:03:19,456
- That reads the processes memories

03:03:19,456 --> 03:03:22,101
so you can make it say whatever you want it to say.

03:03:22,101 --> 03:03:23,190
- [Aleksa] Oh, right.

03:03:23,190 --> 03:03:25,273
- Right, you can override

03:03:26,204 --> 03:03:27,852
- [Aleksa] Yeah, that'll be different.

03:03:27,852 --> 03:03:29,998
- Yeah, you get into all of these problems

03:03:29,998 --> 03:03:31,943
where you can override the environ

03:03:31,943 --> 03:03:35,055
and proc self something something and in G Lipsy,

03:03:35,055 --> 03:03:37,419
the environ global variable for your process

03:03:37,419 --> 03:03:38,910
will not get updated at all.

03:03:38,910 --> 03:03:40,743
It's really beautiful.

03:03:41,627 --> 03:03:44,184
(laughing)

03:03:44,184 --> 03:03:45,923
- So as I was saying, environ isn't mapped.

03:03:45,923 --> 03:03:49,181
I always assumed it was like an M mapped.

03:03:49,181 --> 03:03:50,014
Right?

03:03:50,014 --> 03:03:51,633
Or is it like read and then stored somewhere?

03:03:51,633 --> 03:03:52,893
- I think it's read and stored somewhere.

03:03:52,893 --> 03:03:53,987
- Okay.

03:03:53,987 --> 03:03:55,633
That's interesting.

03:03:55,633 --> 03:03:57,090
Yeah, so.

03:03:57,090 --> 03:03:57,923
Sorry?

03:03:58,823 --> 03:04:00,931
- One comment about the fexecve,

03:04:00,931 --> 03:04:03,059
that's probably something you envision for the future

03:04:03,059 --> 03:04:04,700
in the sense after the initial version

03:04:04,700 --> 03:04:06,374
of openat2 has been merged.

03:04:06,374 --> 03:04:09,287
- Yeah, we discussed this last week

03:04:09,287 --> 03:04:11,157
and yesterday and effectively it boils down to, yeah,

03:04:11,157 --> 03:04:13,034
first of all it would block it for too long

03:04:13,034 --> 03:04:14,319
because I'm not (background noise drowns out speaker).

03:04:14,319 --> 03:04:15,267
- Okay, yes.

03:04:15,267 --> 03:04:17,884
I just wanted to say I know you liked to get

03:04:17,884 --> 03:04:19,699
and you have a lot of good ideas for good features

03:04:19,699 --> 03:04:21,180
but don't stop there.

03:04:21,180 --> 03:04:23,424
- Yeah, yeah, we should get it first, yeah (mumbles).

03:04:23,424 --> 03:04:24,290
- Exactly.

03:04:24,290 --> 03:04:29,025
- And question, because I think there's a good answer

03:04:29,025 --> 03:04:32,701
to this, but what is the advantage of the native syscalls

03:04:32,701 --> 03:04:34,510
over the emulation?

03:04:34,510 --> 03:04:38,557
- So there are a couple, so, RESOLVE_IN_ROOT, okay,

03:04:38,557 --> 03:04:40,540
there are a couple.

03:04:40,540 --> 03:04:42,978
So the first thing is that these ones

03:04:42,978 --> 03:04:47,027
are not, well, actually the one that's most obviously

03:04:47,027 --> 03:04:50,586
not possible today is resolve in magic links

03:04:50,586 --> 03:04:52,646
because the kernel does not expose whether

03:04:52,646 --> 03:04:56,610
or not something is a magic link and so, in libpathrs,

03:04:56,610 --> 03:04:58,952
what I do is that I actually block all symlink resolution

03:04:58,952 --> 03:05:01,394
on proc because I can't tell whether it's gonna be

03:05:01,394 --> 03:05:03,635
a magic link or not until I go through it

03:05:03,635 --> 03:05:07,211
and I don't even wanna play with going through it.

03:05:07,211 --> 03:05:09,577
- I think you can do this.

03:05:09,577 --> 03:05:12,323
You can, something like L start open

03:05:12,323 --> 03:05:14,656
and F start if you can open.

03:05:15,845 --> 03:05:16,678
- Ah, no, no.

03:05:16,678 --> 03:05:18,202
The thing is that you can do L stat, sorry,

03:05:18,202 --> 03:05:19,035
if you get--

03:05:19,035 --> 03:05:21,130
- So check open and (mumbles) check

03:05:21,130 --> 03:05:24,769
whether you open the same, you check.

03:05:24,769 --> 03:05:26,648
I think this works.

03:05:26,648 --> 03:05:28,499
- Ah, yes, you--

03:05:28,499 --> 03:05:31,861
- So you would open and find out it's magic.

03:05:31,861 --> 03:05:32,716
- Ah, right.

03:05:32,716 --> 03:05:36,286
The problem is is that it depends,

03:05:36,286 --> 03:05:39,583
during when in resolution you are but there are

03:05:39,583 --> 03:05:43,217
some files that are unsafe to even open.

03:05:43,217 --> 03:05:45,702
For instance, consoles, if you're an attached process

03:05:45,702 --> 03:05:49,527
and you open a file, this can be fixed with ONCTY,

03:05:49,527 --> 03:05:50,897
this is another thing.

03:05:50,897 --> 03:05:52,774
But yeah, there are some file descriptors

03:05:52,774 --> 03:05:54,898
ideally you wouldn't even wanna try to open.

03:05:54,898 --> 03:05:56,897
But you're right, if you want to do this effectively,

03:05:56,897 --> 03:05:59,548
like, the point is that on proc, you have proc self

03:05:59,548 --> 03:06:01,798
which is an actual symlink.

03:06:02,686 --> 03:06:06,731
It's not a magic link but everything in /proc/self/pid

03:06:06,731 --> 03:06:08,192
is a magic link, for instance.

03:06:08,192 --> 03:06:11,063
My point is that effectively you end up blocking

03:06:11,063 --> 03:06:12,846
actual symlinks rather than (mumbles).

03:06:12,846 --> 03:06:16,174
But yeah, effectively the main argument is that

03:06:16,174 --> 03:06:18,512
it's more efficient, it's more efficient

03:06:18,512 --> 03:06:21,068
than doing the opening because imagine, again,

03:06:21,068 --> 03:06:22,480
if you wanna use libpathrs you would do this

03:06:22,480 --> 03:06:26,139
for every single operation on the file system.

03:06:26,139 --> 03:06:28,026
If you're constantly doing this resolving

03:06:28,026 --> 03:06:30,249
and reopening and so on and so on, it does drag.

03:06:30,249 --> 03:06:34,094
Like it goes from being one syscall to 50, effectively,

03:06:34,094 --> 03:06:36,983
and then 'cause you have to do the O_PATH.

03:06:36,983 --> 03:06:38,102
Then you have to do a check.

03:06:38,102 --> 03:06:40,960
Then you also have to read link /proc/self/fd/

03:06:40,960 --> 03:06:43,102
to see whether or not it is the path you expected

03:06:43,102 --> 03:06:44,128
and so on and so on.

03:06:44,128 --> 03:06:47,794
So it requires, like the blob is massive.

03:06:47,794 --> 03:06:49,544
- Can you make it so,

03:06:50,710 --> 03:06:51,543
two questions.

03:06:51,543 --> 03:06:54,846
I think the performance argument is enough already

03:06:54,846 --> 03:06:56,825
in this sense and it's way too complicated

03:06:56,825 --> 03:07:01,825
what you have to do to actually get this right in userspace.

03:07:02,942 --> 03:07:04,839
So yeah, and now I forget what I wanted to say.

03:07:04,839 --> 03:07:08,006
I've been at this conference too long.

03:07:08,938 --> 03:07:09,771
Go on.

03:07:09,771 --> 03:07:10,604
- Okay, right.

03:07:10,604 --> 03:07:14,677
And yeah, you could emulate these though I think

03:07:14,677 --> 03:07:17,419
that they're more, sorry, of course, yes.

03:07:17,419 --> 03:07:19,326
(laughing)

03:07:19,326 --> 03:07:20,159
Now you can wait.

03:07:20,159 --> 03:07:21,545
(man laughing)

03:07:21,545 --> 03:07:24,787
It's much, much more straightforward

03:07:24,787 --> 03:07:27,472
and obviously correct to do them in the kernel effectively.

03:07:27,472 --> 03:07:29,702
Like, for instance, NO_XDEV is very obvious

03:07:29,702 --> 03:07:30,535
to do in the kernel.

03:07:30,535 --> 03:07:33,342
You just do on pick mount or whatever the function is,

03:07:33,342 --> 03:07:35,962
you just check as opposed to in userspace

03:07:35,962 --> 03:07:38,180
you would need to do F startup and then you would need

03:07:38,180 --> 03:07:40,633
to do, then you would need to care about,

03:07:40,633 --> 03:07:42,136
then you would need to care about OverlayFS

03:07:42,136 --> 03:07:45,439
where it's the underlay files.

03:07:45,439 --> 03:07:47,399
It's a different file system even though

03:07:47,399 --> 03:07:48,972
it's the same mount and so on and so on.

03:07:48,972 --> 03:07:50,675
So effectively, this becomes complicated.

03:07:50,675 --> 03:07:51,508
Yes?

03:07:51,508 --> 03:07:54,841
- Is the emulation userspace toctl free?

03:07:55,929 --> 03:07:56,882
- [Aleksa] Sorry?

03:07:56,882 --> 03:07:59,708
- Does it have like time of check, time of use problems?

03:07:59,708 --> 03:08:01,724
Is it race free, the emulation you do

03:08:01,724 --> 03:08:03,002
without (background noise drowns out speaker)?

03:08:03,002 --> 03:08:03,838
- [Aleksa] As far as I know, it is.

03:08:03,838 --> 03:08:05,710
So basically we do similar to what you do

03:08:05,710 --> 03:08:06,624
which is that--

03:08:06,624 --> 03:08:07,549
- Shh, just said no.

03:08:07,549 --> 03:08:08,969
- Okay, no.

03:08:08,969 --> 03:08:09,802
Yeah, okay.

03:08:09,802 --> 03:08:10,718
Yeah, yeah, yeah.

03:08:10,718 --> 03:08:13,284
Effectively what it does is that it does the open chain

03:08:13,284 --> 03:08:14,912
and then at the very, very end it does a recheck

03:08:14,912 --> 03:08:16,300
with /proc/self/fd/ to see whether

03:08:16,300 --> 03:08:18,643
it is the path we expected,

03:08:18,643 --> 03:08:21,875
which should be good enough effectively.

03:08:21,875 --> 03:08:23,590
Basically meaning that at some point,

03:08:23,590 --> 03:08:26,834
this path actually did resolve to this thing

03:08:26,834 --> 03:08:31,595
without intermediate symlink screwery, effectively.

03:08:31,595 --> 03:08:32,428
- Okay.

03:08:32,428 --> 03:08:33,991
- But yeah.

03:08:33,991 --> 03:08:34,908
Okay, yeah?

03:08:36,067 --> 03:08:37,896
(man speaking softly)

03:08:37,896 --> 03:08:40,071
Can you throw him a box?

03:08:40,071 --> 03:08:40,904
Yeah, okay.

03:08:40,904 --> 03:08:45,444
- But the retracting cannot retract the magic links, right?

03:08:45,444 --> 03:08:46,366
Do we think?

03:08:46,366 --> 03:08:47,464
- [Aleksa] Sorry?

03:08:47,464 --> 03:08:51,047
- If you do the track in the end will it

03:08:51,047 --> 03:08:53,388
solve the, like it will symlinks

03:08:53,388 --> 03:08:56,181
but will it solve the other issues?

03:08:56,181 --> 03:08:57,524
- Ah, so if you do,

03:08:57,524 --> 03:09:00,156
so in the userspace emulations or in libpathrs

03:09:00,156 --> 03:09:02,406
what we do is that we take,

03:09:03,880 --> 03:09:06,158
so effectively what you do is you do the work

03:09:06,158 --> 03:09:09,006
of each component and then once you're done,

03:09:09,006 --> 03:09:11,576
you then look at the final file descriptor you have

03:09:11,576 --> 03:09:13,485
at the very end and then you say,

03:09:13,485 --> 03:09:17,370
this file descriptor, what does it point to?

03:09:17,370 --> 03:09:18,996
And then you do that check by doing relink

03:09:18,996 --> 03:09:22,253
/proc/self/fd/, the number, and then you compare that to

03:09:22,253 --> 03:09:25,071
internally what you thought the path should be.

03:09:25,071 --> 03:09:27,068
Effectively is what you do.

03:09:27,068 --> 03:09:28,306
Um, yeah.

03:09:28,306 --> 03:09:30,655
Which means that if there is a race, you catch it.

03:09:30,655 --> 03:09:31,550
This is the important point

03:09:31,550 --> 03:09:32,971
is that you can catch when a race happens.

03:09:32,971 --> 03:09:35,934
And obviously, sorry, another thing is that there cases

03:09:35,934 --> 03:09:39,522
where /proc/self/fd/ blah will give you slash

03:09:39,522 --> 03:09:42,314
because it detects an escape effectively

03:09:42,314 --> 03:09:45,071
and this is resolved if you use RESOLVE_IN_ROOT.

03:09:45,071 --> 03:09:47,613
The restriction isn't the same.

03:09:47,613 --> 03:09:48,446
But yeah.

03:09:50,254 --> 03:09:51,837
Any more questions?

03:09:52,908 --> 03:09:53,741
Yup?

03:09:55,477 --> 03:09:57,985
- One additional thing we can do,

03:09:57,985 --> 03:10:00,645
as I mentioned to you already,

03:10:00,645 --> 03:10:03,876
is that we could add two new mount flags potentially.

03:10:03,876 --> 03:10:04,833
- [Aleksa] Yes.

03:10:04,833 --> 03:10:08,166
- One to say if there are any automounts

03:10:09,035 --> 03:10:12,922
in this mount, just don't ever trigger them.

03:10:12,922 --> 03:10:15,175
Just return your remote IO.

03:10:15,175 --> 03:10:19,258
And the other one is if you see a symlink in here

03:10:20,176 --> 03:10:22,674
and you follow it and it wants to cross

03:10:22,674 --> 03:10:25,924
into another mount point, say the XDEV,

03:10:27,133 --> 03:10:30,350
I think those should be relatively straightforward to do.

03:10:30,350 --> 03:10:32,297
- [Man] Yeah and that's also gonna be something

03:10:32,297 --> 03:10:33,866
different than what you want.

03:10:33,866 --> 03:10:35,285
We discussed this yesterday and I think

03:10:35,285 --> 03:10:36,553
this is a really great idea.

03:10:36,553 --> 03:10:37,826
But I think both are useful.

03:10:37,826 --> 03:10:39,741
Like, the openat2 path resolution stuff

03:10:39,741 --> 03:10:42,752
is useful and that is certainly very useful for containers.

03:10:42,752 --> 03:10:44,011
- And actually, you just reminded me of something

03:10:44,011 --> 03:10:45,121
which is that it might even be helpful

03:10:45,121 --> 03:10:47,709
to have resolve know automount.

03:10:47,709 --> 03:10:48,969
That might be something useful

03:10:48,969 --> 03:10:50,643
'cause obviously there is a, I don't know what it's called

03:10:50,643 --> 03:10:52,061
look up no automount or whatever,

03:10:52,061 --> 03:10:53,700
where it won't trigger an automount on look up.

03:10:53,700 --> 03:10:56,067
- [David] 18 no automount.

03:10:56,067 --> 03:10:56,900
- [Aleksa] Sorry?

03:10:56,900 --> 03:10:59,352
- I think you're thinking 18 no automount?

03:10:59,352 --> 03:11:00,980
- Ah, yes.

03:11:00,980 --> 03:11:03,973
I don't remember what the internal flag is called in,

03:11:03,973 --> 03:11:05,968
yes, there is also that.

03:11:05,968 --> 03:11:07,914
But there's also an internal flag

03:11:07,914 --> 03:11:10,118
which is the look up flag that it maps to it

03:11:10,118 --> 03:11:10,951
and I'm saying--

03:11:10,951 --> 03:11:11,784
- [David] Look up automount.

03:11:11,784 --> 03:11:13,138
I think it's inverted.

03:11:13,138 --> 03:11:14,375
- Yeah, yeah.

03:11:14,375 --> 03:11:15,208
Sure.

03:11:15,208 --> 03:11:16,335
And the idea is that we could have a resolve

03:11:16,335 --> 03:11:18,444
and an automount as well, which does a similar thing.

03:11:18,444 --> 03:11:19,858
But yeah, that would be useful because it would allow

03:11:19,858 --> 03:11:23,015
you to have programs which don't use openat2

03:11:23,015 --> 03:11:28,015
to also be safe against jumping out of the mount point.

03:11:28,161 --> 03:11:30,359
It would be neat and I'm sure that are use cases

03:11:30,359 --> 03:11:33,122
aside from openat2 but I think that alone

03:11:33,122 --> 03:11:34,706
is a good enough use case.

03:11:34,706 --> 03:11:35,539
- Right.

03:11:35,539 --> 03:11:36,724
It would basically become,

03:11:36,724 --> 03:11:38,779
for every intelligent container run time,

03:11:38,779 --> 03:11:42,301
it would become the default mount option.

03:11:42,301 --> 03:11:43,134
- Yeah.

03:11:43,134 --> 03:11:44,520
Actually one thing I wanna mention is an aside.

03:11:44,520 --> 03:11:46,700
Someone mentioned that, yeah,

03:11:46,700 --> 03:11:49,249
one downside of having a resolve no XDF flag

03:11:49,249 --> 03:11:51,163
is that people bind mount all sorts of stuff

03:11:51,163 --> 03:11:53,056
and so the one thing that probably should be mentioned

03:11:53,056 --> 03:11:55,021
to people who are using this is like,

03:11:55,021 --> 03:11:57,296
please don't set this without giving the user

03:11:57,296 --> 03:11:59,295
an ability to disable it because otherwise

03:11:59,295 --> 03:12:00,796
you might end up with not being able to open

03:12:00,796 --> 03:12:03,094
like someone's home directory because they bind mounted

03:12:03,094 --> 03:12:05,670
something or whatever 'cause this is something,

03:12:05,670 --> 03:12:07,920
but this is a user concern.

03:12:09,382 --> 03:12:10,329
But yeah, are we out of time?

03:12:10,329 --> 03:12:11,236
- Yep, we are. - Okay, all right.

03:12:11,236 --> 03:12:14,669
- So we've got a 15 minute or 10 minutes break.

03:12:14,669 --> 03:12:17,384
10 minutes break and we're back at 6:40.

03:12:17,384 --> 03:12:18,623
- Okay, thank you very much.

03:12:18,623 --> 03:12:21,706

YouTube URL: https://www.youtube.com/watch?v=LN2CUgp8deo


