Title: LPC2019 - Tracing MC
Publication date: 2019-11-18
Playlist: LPC2019 - MicroConferences
Description: 
	Tracing MC
Captions: 
	00:00:00,277 --> 00:00:03,824
- Okay, thanks everyone for coming to

00:00:03,824 --> 00:00:05,491
Linux Plumbers 2019.

00:00:06,328 --> 00:00:10,377
Before we go, we have a few things we want to cover.

00:00:10,377 --> 00:00:13,758
First of all, we have to thank our sponsors.

00:00:13,758 --> 00:00:17,602
Big thank you for Facebook as our diamond sponsor.

00:00:17,602 --> 00:00:21,242
Without our sponsors, this would not happen.

00:00:21,242 --> 00:00:23,825
Linux Plumbers is an extremely,

00:00:26,151 --> 00:00:27,297
how do you say?

00:00:27,297 --> 00:00:30,050
Very important conference to get things done.

00:00:30,050 --> 00:00:32,650
And a lot of corporations realize this.

00:00:32,650 --> 00:00:34,843
So thanks, Facebook.

00:00:34,843 --> 00:00:38,663
Our platinum sponsors: Intel, Google, NetApp.

00:00:38,663 --> 00:00:43,036
Gold, arm, Dell EMC, Microsoft Azul, Azure sorry,

00:00:43,036 --> 00:00:44,069
Western Digital.

00:00:44,069 --> 00:00:46,819
Silver is Digital Ocean, Netflix,

00:00:47,680 --> 00:00:49,769
Netronome, ORACLE,

00:00:49,769 --> 00:00:52,733
the Catchboxes, these guys,

00:00:52,733 --> 00:00:54,983
Collabora, Collabora sorry.

00:00:56,450 --> 00:00:58,238
I'm horrible with pronunciations.

00:00:58,238 --> 00:01:01,996
The lunch sponsors by IBM, T-shirts, VM Ware,

00:01:01,996 --> 00:01:04,560
and evening events will be Google.

00:01:04,560 --> 00:01:06,556
So please just give a round of applause.

00:01:06,556 --> 00:01:09,723
(audience applauding)

00:01:14,416 --> 00:01:16,890
Everyone if you haven't known, we have the wifi,

00:01:16,890 --> 00:01:19,890
SSID lf events, password linux 1991.

00:01:21,768 --> 00:01:24,314
We do have a code of conduct.

00:01:24,314 --> 00:01:26,711
We are very strict, we will be abiding by it.

00:01:26,711 --> 00:01:28,963
Please read it, if you have any issues,

00:01:28,963 --> 00:01:32,357
look for someone with one of these green lanyards.

00:01:32,357 --> 00:01:34,553
We are the planning committee,

00:01:34,553 --> 00:01:36,951
come up to us, talk to us,

00:01:36,951 --> 00:01:40,284
we will make sure it's handled properly.

00:01:41,926 --> 00:01:46,111
Schedule overview, Linux conf's event timetable.

00:01:46,111 --> 00:01:47,493
You go through, look for,

00:01:47,493 --> 00:01:49,647
just go to Linux conf's you'll find a link for the schedule.

00:01:49,647 --> 00:01:52,504
As you know, morning session started at 10:00.

00:01:52,504 --> 00:01:56,044
Lunch, if you'll notice there's no breakfast,

00:01:56,044 --> 00:01:57,872
that's because the conference hotel

00:01:57,872 --> 00:01:59,498
provides a really nice breakfast,

00:01:59,498 --> 00:02:01,448
so we try to encourage lunch.

00:02:01,448 --> 00:02:03,317
So it's either, our choice was,

00:02:03,317 --> 00:02:04,780
we either have a breakfast and no lunch

00:02:04,780 --> 00:02:07,363
but having the conference hotel had breakfast,

00:02:07,363 --> 00:02:09,395
we figured let's have lunch.

00:02:09,395 --> 00:02:12,298
So lunch is provided down at the restaurant downstairs

00:02:12,298 --> 00:02:14,145
from 1:30 to 3:00.

00:02:14,145 --> 00:02:17,030
Evening events, we have something tonight,

00:02:17,030 --> 00:02:20,628
it's a reception, it'll be same place that lunch is.

00:02:20,628 --> 00:02:21,731
From 7:00 to 9:00.

00:02:21,731 --> 00:02:23,698
Tuesday night, you're on your own.

00:02:23,698 --> 00:02:26,421
The second half of the micro conferences

00:02:26,421 --> 00:02:30,345
will be on Tuesday night, will be extended conferences

00:02:30,345 --> 00:02:31,704
because there's no evening events.

00:02:31,704 --> 00:02:34,345
Wednesday night event after Plenary,

00:02:34,345 --> 00:02:35,498
buses will start at 7:30,

00:02:35,498 --> 00:02:40,331
we'll talk more about that at the closing Plenary session.

00:02:41,352 --> 00:02:44,626
Okay, make sure everyone uploads their slides

00:02:44,626 --> 00:02:46,698
to the LPC site, hopefully,

00:02:46,698 --> 00:02:49,235
if you have problems find one of us

00:02:49,235 --> 00:02:50,332
we'll help you do that.

00:02:50,332 --> 00:02:52,323
Etherpads are really important,

00:02:52,323 --> 00:02:55,307
okay so, there's a link, I don't know if I put that,

00:02:55,307 --> 00:02:57,542
the link is in there, if you can see it.

00:02:57,542 --> 00:02:59,593
I will try to, if not I will write

00:02:59,593 --> 00:03:01,194
the link up there and paste it.

00:03:01,194 --> 00:03:03,515
So anyone can help update the Etherpad.

00:03:03,515 --> 00:03:05,686
Right now, the micro conferences

00:03:05,686 --> 00:03:08,856
we need notes, it's gonna be three hours of straight talk.

00:03:08,856 --> 00:03:10,725
At the end of the day we're all gonna be exhausted,

00:03:10,725 --> 00:03:12,252
we won't remember what happened during,

00:03:12,252 --> 00:03:14,608
the more notes that we have on the Etherpad

00:03:14,608 --> 00:03:16,799
the better we're gonna have information

00:03:16,799 --> 00:03:18,710
'cause this is all gonna be summarized

00:03:18,710 --> 00:03:21,394
and posted up on our blogs.

00:03:21,394 --> 00:03:23,813
Micro conference leads, we have to write out summaries,

00:03:23,813 --> 00:03:26,584
and also, there should be two video cameras.

00:03:26,584 --> 00:03:29,748
Right, there's, or is this one?

00:03:29,748 --> 00:03:31,472
Yep, okay we have two video cameras.

00:03:31,472 --> 00:03:32,546
One for whoever's talking up here,

00:03:32,546 --> 00:03:34,479
one for the audience,

00:03:34,479 --> 00:03:36,429
so the conversations are all being recorded.

00:03:36,429 --> 00:03:38,885
Which brings up, see these,

00:03:38,885 --> 00:03:39,718
boxes.

00:03:41,667 --> 00:03:43,431
Throw-able microphones.

00:03:43,431 --> 00:03:44,553
Please be careful.

00:03:44,553 --> 00:03:47,256
This keeps people from being too concentrated on your email

00:03:47,256 --> 00:03:49,531
and not paying attention to the talks

00:03:49,531 --> 00:03:51,319
because it's always that person

00:03:51,319 --> 00:03:53,392
that's sitting there like this, that gets hit in the head.

00:03:53,392 --> 00:03:55,528
(audience laughing)

00:03:55,528 --> 00:04:00,528
So, you gotta pay attention to what's going on in the room.

00:04:01,023 --> 00:04:03,452
We also have the ability to schedule BOF's

00:04:03,452 --> 00:04:05,240
so if you have something that comes up,

00:04:05,240 --> 00:04:06,720
you want to discuss something

00:04:06,720 --> 00:04:08,345
go to the registration desk,

00:04:08,345 --> 00:04:10,174
and schedule a room, hopefully,

00:04:10,174 --> 00:04:12,831
it's first come first serve for doing that.

00:04:12,831 --> 00:04:14,862
And finally, if you have any questions,

00:04:14,862 --> 00:04:17,000
look for us with the green lanyards.

00:04:17,000 --> 00:04:19,800
And let's see, it's six minutes on there,

00:04:19,800 --> 00:04:22,254
so I'm gonna kill that.

00:04:22,254 --> 00:04:24,274
And have you come up.

00:04:24,274 --> 00:04:27,264
And we'll start, and I'll give you six minutes extra.

00:04:27,264 --> 00:04:28,889
- All right, is this on?

00:04:28,889 --> 00:04:29,722
Oh I have.

00:04:29,722 --> 00:04:30,921
- Yep. - A mic, yes.

00:04:30,921 --> 00:04:31,921
Okay, great.

00:04:35,367 --> 00:04:36,543
- All right, morning everyone.

00:04:36,543 --> 00:04:37,684
My name's Omar Sandoval,

00:04:37,684 --> 00:04:39,753
I'm a software engineer on the kernel team at Facebook.

00:04:39,753 --> 00:04:41,788
I primarily work on btrfs,

00:04:41,788 --> 00:04:43,941
but I also do a lot of investigating

00:04:43,941 --> 00:04:46,118
of bugs that come up in our production kernels.

00:04:46,118 --> 00:04:49,061
So, drgn is a tool that I built to help

00:04:49,061 --> 00:04:51,378
with these sorts of investigations.

00:04:51,378 --> 00:04:53,473
Lately, the kinds of bugs we've been hitting

00:04:53,473 --> 00:04:56,480
have been really subtle bugs

00:04:56,480 --> 00:04:59,359
where you have different sub systems

00:04:59,359 --> 00:05:00,457
all with their complicated state

00:05:00,457 --> 00:05:03,690
all interacting in ways and they have to line up just right

00:05:03,690 --> 00:05:05,861
to get, for things to go wrong.

00:05:05,861 --> 00:05:10,028
And drgn was built exactly for that sort of thing.

00:05:11,122 --> 00:05:14,798
So I call drgn a programmable debugger

00:05:14,798 --> 00:05:16,662
or debugger as a library.

00:05:16,662 --> 00:05:19,222
When I say that, I mean as opposed to

00:05:19,222 --> 00:05:21,660
like your typical debugger work flow

00:05:21,660 --> 00:05:23,999
drgn's built around the idea

00:05:23,999 --> 00:05:26,762
of taking all the kernel variable

00:05:26,762 --> 00:05:28,486
and types that you get from debug information,

00:05:28,486 --> 00:05:31,736
exposing them as a magic Python objects

00:05:33,792 --> 00:05:35,377
that you can than write scripts

00:05:35,377 --> 00:05:36,451
almost as if you're writing C.

00:05:36,451 --> 00:05:39,255
And then you can test your theories,

00:05:39,255 --> 00:05:42,584
iterate on whatever bug you're trying to drill into.

00:05:42,584 --> 00:05:46,917
So it's easier to demonstrate then it is to explain,

00:05:48,926 --> 00:05:53,093
so this is just my VM running some kernel version.

00:05:54,719 --> 00:05:56,060
5-3 I guess.

00:05:56,060 --> 00:05:56,893
5-3-R-T-8.

00:05:56,893 --> 00:05:57,726
- [Audience Member] Can you make your font bigger?

00:05:57,726 --> 00:05:58,814
- Yes, absolutely.

00:05:58,814 --> 00:06:00,580
- [Audience Member] A lot bigger, thanks.

00:06:00,580 --> 00:06:01,538
(audience laughing)

00:06:01,538 --> 00:06:03,673
- [Omar] Is that better? Legible?

00:06:03,673 --> 00:06:05,177
Okay, cool.

00:06:05,177 --> 00:06:07,427
So I'll just start up drgn,

00:06:08,383 --> 00:06:11,529
it's by default it attaches to the running kernel,

00:06:11,529 --> 00:06:14,538
it grabs all the debug information from the kernel,

00:06:14,538 --> 00:06:16,955
imports the basic drgn API's,

00:06:17,791 --> 00:06:20,699
and gives you this prog object.

00:06:20,699 --> 00:06:22,812
So this object is like the entryway

00:06:22,812 --> 00:06:24,275
into all the drgn functionality,

00:06:24,275 --> 00:06:26,144
it represents the program you're debugging.

00:06:26,144 --> 00:06:27,381
So you can do stuff like

00:06:27,381 --> 00:06:29,923
lookup type definitions or

00:06:29,923 --> 00:06:31,729
look up variables.

00:06:31,729 --> 00:06:34,812
You can do operations with variables.

00:06:39,190 --> 00:06:41,706
You can look at structure of variables as well.

00:06:41,706 --> 00:06:43,722
This is a big one so there's a lot there.

00:06:43,722 --> 00:06:46,222
And it acts very similar to C,

00:06:48,372 --> 00:06:50,485
so if you wanted to look at a structure member,

00:06:50,485 --> 00:06:53,288
you can just do that see whatever you need to see.

00:06:53,288 --> 00:06:56,705
So we can also do more interesting things

00:06:58,937 --> 00:07:00,603
than just poke around at

00:07:00,603 --> 00:07:02,103
individual fields.

00:07:03,755 --> 00:07:05,498
So for example, a prog,

00:07:05,498 --> 00:07:07,936
or the init task is a task struct,

00:07:07,936 --> 00:07:11,066
for the first task that the kernel brings up.

00:07:11,066 --> 00:07:13,200
It has this, and every task struct

00:07:13,200 --> 00:07:14,904
has a list of children tasks,

00:07:14,904 --> 00:07:19,821
so we could look at every task that's a child of this task.

00:07:21,875 --> 00:07:23,988
If I can remember which order

00:07:23,988 --> 00:07:26,905
this for each entry takes stuff in.

00:07:31,143 --> 00:07:34,733
So, list for each entry is a helper in dragon

00:07:34,733 --> 00:07:36,602
which is really just Python code

00:07:36,602 --> 00:07:40,435
written on top of the core drgn functionality.

00:07:46,076 --> 00:07:49,269
And we can look at all the children of the task struct.

00:07:49,269 --> 00:07:51,225
In this case init task,

00:07:51,225 --> 00:07:54,198
and see that we get the actual init and k thread d.

00:07:54,198 --> 00:07:56,891
So those are kind of the basic concepts

00:07:56,891 --> 00:08:00,472
but rather than like just giving a lecture

00:08:00,472 --> 00:08:03,880
of how drgn works, I think it's more interesting

00:08:03,880 --> 00:08:08,332
to look at an actual bug that I investigated using drgn.

00:08:08,332 --> 00:08:11,949
I'm gonna make the font a little smaller.

00:08:11,949 --> 00:08:12,965
- [Audience Member] I missed,

00:08:12,965 --> 00:08:14,404
because I was setting up the stuff,

00:08:14,404 --> 00:08:15,884
I missed the beginning.

00:08:15,884 --> 00:08:16,717
How did you start this off,

00:08:16,717 --> 00:08:17,550
I just wanted to take notes on it.

00:08:17,550 --> 00:08:18,603
- Oh.

00:08:18,603 --> 00:08:23,421
- [Audience Member] I missed the first entering of it

00:08:23,421 --> 00:08:24,540
so I just--

00:08:24,540 --> 00:08:25,373
- [Man] Use your mic.

00:08:25,373 --> 00:08:27,669
- [Audience Member] Oh well, it doesn't really care if,

00:08:27,669 --> 00:08:28,766
I just wanna see him,

00:08:28,766 --> 00:08:30,432
what did you just do so I can take notes.

00:08:30,432 --> 00:08:33,439
- Okay, I went into the drgn CLI,

00:08:33,439 --> 00:08:36,439
poked around at the basic interface.

00:08:39,588 --> 00:08:41,421
Cool, okay we're good.

00:08:42,306 --> 00:08:44,139
So, the background is,

00:08:47,955 --> 00:08:50,453
I sent some patches up to the btrfs mailing list,

00:08:50,453 --> 00:08:51,919
the maintainer applied them

00:08:51,919 --> 00:08:54,011
and he came back to me and said that

00:08:54,011 --> 00:08:56,777
it caused a deadlock in the next best test.

00:08:56,777 --> 00:08:59,273
So I managed to reproduce the deadlock,

00:08:59,273 --> 00:09:03,940
it's been running since last night and it's still stuck.

00:09:05,387 --> 00:09:07,134
So clearly it's stuck stuck.

00:09:07,134 --> 00:09:10,217
(audience chuckling)

00:09:11,155 --> 00:09:14,251
The first thing you usually do

00:09:14,251 --> 00:09:15,285
when you're gonna debug a deadlock

00:09:15,285 --> 00:09:17,438
is look at what tasks are actually stuck,

00:09:17,438 --> 00:09:19,385
you can do that, usually you do that,

00:09:19,385 --> 00:09:22,134
you just go look at var log messages

00:09:22,134 --> 00:09:24,346
or whatever, and see the hung task warnings.

00:09:24,346 --> 00:09:26,320
But we can do it in drgn as well.

00:09:26,320 --> 00:09:28,143
So, might as well do it, just to demonstrate.

00:09:28,143 --> 00:09:31,173
(keyboard clicking)

00:09:31,173 --> 00:09:34,197
So, there's another help bar for each task

00:09:34,197 --> 00:09:36,630
that just iterates over every task in the kernel

00:09:36,630 --> 00:09:39,380
and we can look at just the tasks

00:09:40,559 --> 00:09:42,226
that are in v state.

00:09:44,704 --> 00:09:48,460
We can print their pid, command line.

00:09:48,460 --> 00:09:52,043
And we can even get a stack trace for them.

00:09:54,573 --> 00:09:56,990
All right, so let's run that.

00:10:03,617 --> 00:10:04,450
Hold up.

00:10:06,154 --> 00:10:09,154
(keyboard clicking)

00:10:10,014 --> 00:10:11,297
There we go.

00:10:11,297 --> 00:10:13,694
Okay, so we have a few tasks

00:10:13,694 --> 00:10:16,611
two of them are work queue workers.

00:10:18,815 --> 00:10:20,341
Doing some btrfs work.

00:10:20,341 --> 00:10:23,325
The last one is a user space program

00:10:23,325 --> 00:10:25,705
which is probably waiting on those workers

00:10:25,705 --> 00:10:27,957
to finish whatever they're doing.

00:10:27,957 --> 00:10:30,030
So this one's task,

00:10:30,030 --> 00:10:32,447
or this one's pid 222.

00:10:32,447 --> 00:10:36,632
So, oops, let's take a closer look at that one.

00:10:36,632 --> 00:10:38,882
We can just find it by pid.

00:10:41,024 --> 00:10:42,853
We have that task.

00:10:42,853 --> 00:10:46,186
So, worker threads have their own state,

00:10:51,361 --> 00:10:53,354
is this legible enough?

00:10:53,354 --> 00:10:54,881
Okay, cool.

00:10:54,881 --> 00:10:58,149
So each worker thread has it's,

00:10:58,149 --> 00:11:00,912
it's a struct worker that's associated with it.

00:11:00,912 --> 00:11:03,793
So to get to it, we need to chase a bunch of pointers,

00:11:03,793 --> 00:11:05,364
since I don't have a helper for it,

00:11:05,364 --> 00:11:10,031
so we can just basically copy over the C code as Python.

00:11:11,175 --> 00:11:13,834
So we can see that whoever wrote this

00:11:13,834 --> 00:11:16,124
abused this set child tid thing.

00:11:16,124 --> 00:11:19,131
To shove the k thread into the task struct.

00:11:19,131 --> 00:11:22,048
So we can just grab it out of here.

00:11:26,144 --> 00:11:30,549
So we have a worker task, that's set child tid.

00:11:30,549 --> 00:11:32,382
And then the worker is

00:11:35,263 --> 00:11:37,930
the data field of that k thread.

00:11:39,286 --> 00:11:40,869
As a struct worker.

00:11:45,770 --> 00:11:46,603
So, data.

00:11:47,960 --> 00:11:48,957
Okay.

00:11:48,957 --> 00:11:49,849
So let's print that out.

00:11:49,849 --> 00:11:53,409
So this is basically just as if you were writing C

00:11:53,409 --> 00:11:55,215
and you just didn't have

00:11:55,215 --> 00:11:57,270
the functionality available already.

00:11:57,270 --> 00:11:58,786
Okay, so this is the struct worker

00:11:58,786 --> 00:11:59,952
for that k thread we're looking at.

00:11:59,952 --> 00:12:01,919
We have some interesting information here,

00:12:01,919 --> 00:12:04,178
we have this current work,

00:12:04,178 --> 00:12:06,308
which is the work struct we're supposed

00:12:06,308 --> 00:12:07,324
to be working on right now.

00:12:07,324 --> 00:12:08,719
We have the function we're supposed to be

00:12:08,719 --> 00:12:10,778
executing from the worker right now.

00:12:10,778 --> 00:12:14,151
And we have this list of work that we need to get to soon.

00:12:14,151 --> 00:12:18,754
So, just to get an idea of what things look like,

00:12:18,754 --> 00:12:23,090
we can find out how many things are scheduled,

00:12:23,090 --> 00:12:26,260
(keyboard clicking)

00:12:26,260 --> 00:12:29,343
so we have the worker scheduled list.

00:12:33,815 --> 00:12:34,648
And...

00:12:38,532 --> 00:12:40,949
Hold on counting parentheses.

00:12:42,247 --> 00:12:44,522
And let's also look at the

00:12:44,522 --> 00:12:47,105
the name of the symbol for that

00:12:48,808 --> 00:12:51,779
current func that we're executing.

00:12:51,779 --> 00:12:54,779
(keyboard clicking)

00:12:57,682 --> 00:13:00,015
Yeah, I knew I messed it up.

00:13:04,416 --> 00:13:06,099
Okay, so we have one thing scheduled.

00:13:06,099 --> 00:13:09,682
And we're executing this btrfs work helper.

00:13:11,771 --> 00:13:14,453
So we can go back to the btrfs code

00:13:14,453 --> 00:13:16,370
to look at what that is

00:13:17,500 --> 00:13:19,528
because it's not super informative

00:13:19,528 --> 00:13:21,682
because that's kind of our generic dispatch function

00:13:21,682 --> 00:13:23,839
btrfs that we use for all the async work that we have.

00:13:23,839 --> 00:13:26,506
But we can see that we have this

00:13:28,831 --> 00:13:32,631
actual work struc that has the btrfs specific information.

00:13:32,631 --> 00:13:37,298
So we can again, kind of copy over the definition there.

00:13:38,590 --> 00:13:42,044
So in this case the btrfs work is just the container

00:13:42,044 --> 00:13:43,627
of the current work

00:13:46,148 --> 00:13:48,231
and the struct btrfs work

00:13:51,204 --> 00:13:53,706
with the name normal work.

00:13:53,706 --> 00:13:54,539
And that

00:13:57,340 --> 00:13:59,529
has a function as well,

00:13:59,529 --> 00:14:02,114
so let's look at that, hopefully it's more informative.

00:14:02,114 --> 00:14:05,114
(keyboard clicking)

00:14:10,585 --> 00:14:11,418
Okay, so,

00:14:12,520 --> 00:14:15,220
this is what the btrfs worker's actually executing

00:14:15,220 --> 00:14:18,064
this end work queue function somewhere in btrfs.

00:14:18,064 --> 00:14:21,981
But, if you were paying close enough attention,

00:14:24,096 --> 00:14:26,596
we can look at the stack trace

00:14:29,221 --> 00:14:31,392
that we're looking at just now.

00:14:31,392 --> 00:14:35,398
So this stack trace says from btrfs work helper,

00:14:35,398 --> 00:14:39,078
we're executing this btrfs and dio bio

00:14:39,078 --> 00:14:41,554
which is not the end work queue function.

00:14:41,554 --> 00:14:44,337
So that's a little funky.

00:14:44,337 --> 00:14:47,004
So, usually when there's like a,

00:14:48,343 --> 00:14:49,440
sorry, do you have a question?

00:14:49,440 --> 00:14:50,273
- [Audience Member] Uh yep.

00:14:50,273 --> 00:14:51,228
Is there a--

00:14:51,228 --> 00:14:52,853
- [Man] Oh yep, who has a question?

00:14:52,853 --> 00:14:54,173
- [Audience Member] Nobody.

00:14:54,173 --> 00:14:57,323
(audience laughing)

00:14:57,323 --> 00:14:58,217
- [Audience Member] So first of all,

00:14:58,217 --> 00:14:59,639
so this is a live running kernel right?

00:14:59,639 --> 00:15:00,472
- [Omar] Yes.

00:15:00,472 --> 00:15:02,768
- So how do you handle the fact

00:15:02,768 --> 00:15:04,578
that the structures you're accessing

00:15:04,578 --> 00:15:06,123
can change underneath your feet

00:15:06,123 --> 00:15:09,148
and do you expect them to stay stable?

00:15:09,148 --> 00:15:11,907
- Each helper kind of handles it ad hoc,

00:15:11,907 --> 00:15:15,713
for the most part I just assume it doesn't change

00:15:15,713 --> 00:15:18,128
and if it does like it'll

00:15:18,128 --> 00:15:20,402
crash in Python gracefully, whatever.

00:15:20,402 --> 00:15:24,183
- [Audience Member] Presumably, it gets into serious trouble

00:15:24,183 --> 00:15:26,441
if you try to trace something in drgn itself

00:15:26,441 --> 00:15:29,076
using it to print the output,

00:15:29,076 --> 00:15:30,905
or is it doing all of it?

00:15:30,905 --> 00:15:32,106
- It's all in user space,

00:15:32,106 --> 00:15:33,836
so you're not gonna crash the kernel.

00:15:33,836 --> 00:15:35,317
- [Audience Member] Yes, but you might deadlock

00:15:35,317 --> 00:15:37,186
if you're inspecting something that is itself using

00:15:37,186 --> 00:15:40,559
or does it uninstall it's own probe points around?

00:15:40,559 --> 00:15:42,201
- It doesn't probe anything,

00:15:42,201 --> 00:15:45,289
it's entirely in user space, just reading from proc kcore

00:15:45,289 --> 00:15:47,263
which doesn't block or do anything.

00:15:47,263 --> 00:15:48,889
- [Audience Member] Ah, right, yeah.

00:15:48,889 --> 00:15:52,627
- So my, so my, is this one on too?

00:15:52,627 --> 00:15:55,460
So all you do is this just ad map,

00:15:56,424 --> 00:15:59,408
just basically ad mapping the memory, or what's?

00:15:59,408 --> 00:16:01,909
- It reads from proc kcore,

00:16:01,909 --> 00:16:02,742
I would ad map it if it let me.

00:16:02,742 --> 00:16:03,575
- Well that's what I meant, but so,

00:16:03,575 --> 00:16:06,582
so you just basically, kinda like you said,

00:16:06,582 --> 00:16:08,614
it's a debugger that's just live running.

00:16:08,614 --> 00:16:09,626
- Yep.

00:16:09,626 --> 00:16:10,459
- Bugger,

00:16:10,459 --> 00:16:12,109
so if core memory is not available,

00:16:12,109 --> 00:16:13,328
then this isn't.

00:16:13,328 --> 00:16:15,847
You can only get this if you have that memory available.

00:16:15,847 --> 00:16:17,018
- Yeah, so you need proc kcore,

00:16:17,018 --> 00:16:18,059
you need debugging symbols.

00:16:18,059 --> 00:16:19,156
- Yes, so that's not always on

00:16:19,156 --> 00:16:21,187
more production systems don't,

00:16:21,187 --> 00:16:22,691
that's usually disabled.

00:16:22,691 --> 00:16:24,235
- Right, which is a pain.

00:16:24,235 --> 00:16:25,898
At Facebook, we have 'em on,

00:16:25,898 --> 00:16:28,932
even our prod kernels leave 'em in.

00:16:28,932 --> 00:16:31,265
And that makes life a lot easier for me.

00:16:31,265 --> 00:16:33,580
At least Distro's you can at least install

00:16:33,580 --> 00:16:35,125
the debug info package,

00:16:35,125 --> 00:16:37,442
and it'll find 'em properly.

00:16:37,442 --> 00:16:39,359
But yeah, you need 'em.

00:16:40,991 --> 00:16:41,824
Cool.

00:16:43,334 --> 00:16:44,584
All right well.

00:16:46,376 --> 00:16:47,793
To keep it short,

00:16:53,960 --> 00:16:56,035
the root cause of the bug is

00:16:56,035 --> 00:17:00,162
so we can tell that something's weird is going on

00:17:00,162 --> 00:17:01,231
because we're,

00:17:01,231 --> 00:17:02,902
we think we're executing a different function

00:17:02,902 --> 00:17:04,121
than we actually are.

00:17:04,121 --> 00:17:06,600
And the reason that happened is because

00:17:06,600 --> 00:17:08,736
while we were executing our

00:17:08,736 --> 00:17:10,686
or while the worker thread is still running

00:17:10,686 --> 00:17:13,001
we freed the work item,

00:17:13,001 --> 00:17:16,515
the work item was then reallocated as a new work item

00:17:16,515 --> 00:17:20,432
and then the work queue code has some mechanism

00:17:21,350 --> 00:17:23,562
that prevents it from running the same work item twice.

00:17:23,562 --> 00:17:25,553
And because of the way btrfs

00:17:25,553 --> 00:17:28,311
uses the same dispatch function

00:17:28,311 --> 00:17:30,470
for multiple things,

00:17:30,470 --> 00:17:33,500
the work queue code gets tricked into thinking

00:17:33,500 --> 00:17:35,365
that it's the same work item all over again.

00:17:35,365 --> 00:17:37,140
It waits for the other one to finish,

00:17:37,140 --> 00:17:38,902
and if you have a dependency on the one

00:17:38,902 --> 00:17:41,018
that is waiting for the other one to finish,

00:17:41,018 --> 00:17:42,115
you end up with a deadlock.

00:17:42,115 --> 00:17:44,390
So fun stuff, I don't know how I would have found it

00:17:44,390 --> 00:17:47,537
without having this introspection.

00:17:47,537 --> 00:17:49,243
- Okay first of all.

00:17:49,243 --> 00:17:50,160
First just wanna say, yes,

00:17:50,160 --> 00:17:53,401
this is actually nice to see, it's a cute little string

00:17:53,401 --> 00:17:56,540
but since this is Plumbers and we're more talking about

00:17:56,540 --> 00:17:58,165
is there, I'm just curious if you're coming up here

00:17:58,165 --> 00:17:59,953
now like more of a,

00:17:59,953 --> 00:18:01,493
instead of just demoing what you've done,

00:18:01,493 --> 00:18:04,772
do you have issues, questions, things you would like to done

00:18:04,772 --> 00:18:06,369
yes, 'cause I just wanna let you know

00:18:06,369 --> 00:18:08,812
that you're just into the halfway point.

00:18:08,812 --> 00:18:10,150
- Yep, absolutely.

00:18:10,150 --> 00:18:13,119
Okay, so the part that I was

00:18:13,119 --> 00:18:15,674
looking for feedback or ideas on,

00:18:15,674 --> 00:18:18,239
the big thing that's been gnawing at me,

00:18:18,239 --> 00:18:20,294
is combining this with BPF tracing.

00:18:20,294 --> 00:18:22,587
'Cause this obviously has a lot of overlap

00:18:22,587 --> 00:18:25,350
in the terms of use cases that you'd want to use.

00:18:25,350 --> 00:18:28,422
Drgn has the upside that you can run

00:18:28,422 --> 00:18:30,798
whatever arbitrary looping or,

00:18:30,798 --> 00:18:33,545
you know, gathering state in

00:18:33,545 --> 00:18:36,453
whatever Python data structures you want to use.

00:18:36,453 --> 00:18:38,224
BPF you can catch things live.

00:18:38,224 --> 00:18:42,585
But kind of, it'd be nice to have someway to unify that.

00:18:42,585 --> 00:18:45,515
Like, my crazy idea has been

00:18:45,515 --> 00:18:48,015
throwing safety out the window

00:18:48,870 --> 00:18:51,060
and just having a BPF breakpoint,

00:18:51,060 --> 00:18:53,236
like you insert a BPF program

00:18:53,236 --> 00:18:54,902
in certain cases it hits a breakpoint

00:18:54,902 --> 00:18:58,066
that stops, like, who cares.

00:18:58,066 --> 00:19:00,875
Then drgn, or whatever, runs

00:19:00,875 --> 00:19:03,375
and gets the pointers from BPF

00:19:04,491 --> 00:19:07,152
that says here, start doing stuff here,

00:19:07,152 --> 00:19:09,043
and then drgn can go do it's thing

00:19:09,043 --> 00:19:12,073
and then tell the kernel, okay you can continue now.

00:19:12,073 --> 00:19:15,116
- I don't think we have that.

00:19:15,116 --> 00:19:17,413
I think we'd prevent that from EPP happening.

00:19:17,413 --> 00:19:22,413
- Yes, that's why it's my crazy idea for how to integrate it

00:19:23,861 --> 00:19:25,255
I talked to Lexi about it,

00:19:25,255 --> 00:19:27,653
and 'cause I think he's also been

00:19:27,653 --> 00:19:31,861
trying to think of ways to improve debuggability

00:19:31,861 --> 00:19:34,335
of BPF programs themselves.

00:19:34,335 --> 00:19:36,128
So there's some overlap there,

00:19:36,128 --> 00:19:37,045
but I mean,

00:19:38,013 --> 00:19:40,998
if you're inserting this breakpoint

00:19:40,998 --> 00:19:43,053
you're kind of agreeing that like

00:19:43,053 --> 00:19:46,016
I might deadlock, I might do whatever,

00:19:46,016 --> 00:19:50,083
so probably wouldn't be a prod system thing.

00:19:50,083 --> 00:19:53,817
- This seems a little similar to like KGDB.

00:19:53,817 --> 00:19:54,814
- Right.

00:19:54,814 --> 00:19:58,146
Except KGDB isn't the nicest interface.

00:19:58,146 --> 00:20:00,215
- Right so basically it's a nicer interface

00:20:00,215 --> 00:20:02,152
for if you had something like KGDB.

00:20:02,152 --> 00:20:02,985
- Right.

00:20:05,849 --> 00:20:07,819
- [Audience Member] My point--

00:20:07,819 --> 00:20:10,402
- Should be a microphone there.

00:20:11,683 --> 00:20:14,162
- [Audience Member] KGDB have a Python interface, or not?

00:20:14,162 --> 00:20:16,443
Am I misremembering?

00:20:16,443 --> 00:20:17,663
- I forget how it works,

00:20:17,663 --> 00:20:19,590
if you can hook up GDB to KGDB,

00:20:19,590 --> 00:20:22,132
and GDB does have its Python interface,

00:20:22,132 --> 00:20:24,750
but it's a little clunkier.

00:20:24,750 --> 00:20:26,945
- [Audience Member] Yeah.

00:20:26,945 --> 00:20:29,122
One of the issues I see with the breakpoint approach,

00:20:29,122 --> 00:20:31,560
if the breakpoint is at the wrong latication

00:20:31,560 --> 00:20:34,161
just trying to spawn your user space process

00:20:34,161 --> 00:20:36,738
might actually hit that breakpoint again,

00:20:36,738 --> 00:20:40,186
and your kind of luck on yourself.

00:20:40,186 --> 00:20:42,670
- [Omar] (laughs) Yeah.

00:20:42,670 --> 00:20:43,503
Yeah.

00:20:45,774 --> 00:20:47,628
So, moving on from that,

00:20:47,628 --> 00:20:50,797
another thing that I've run into

00:20:50,797 --> 00:20:52,880
is there's a lack of some

00:20:54,495 --> 00:20:56,080
debugging information in the kernel

00:20:56,080 --> 00:20:57,908
particularly macros.

00:20:57,908 --> 00:21:01,972
GCC doesn't generate macro debug information by default.

00:21:01,972 --> 00:21:04,306
So the kernel doesn't

00:21:04,306 --> 00:21:08,654
even when you have like a config debug info equals yes,

00:21:08,654 --> 00:21:10,198
you don't get macro debug information

00:21:10,198 --> 00:21:11,051
and a lot of stuff in the kernel

00:21:11,051 --> 00:21:12,334
that you really wanted to know,

00:21:12,334 --> 00:21:13,733
stuff like page size,

00:21:13,733 --> 00:21:17,733
or like page table layouts, stuff like that,

00:21:17,733 --> 00:21:21,030
is in debug information, or is in macros.

00:21:21,030 --> 00:21:23,780
I'm sure that'd be an easy patch,

00:21:25,001 --> 00:21:26,352
but I'm just curious if anyone else

00:21:26,352 --> 00:21:28,425
has run into that or if they've found

00:21:28,425 --> 00:21:31,449
different ways to work around it.

00:21:31,449 --> 00:21:33,238
- Repeat the question, sorry I was typing.

00:21:33,238 --> 00:21:35,252
- Has anyone that's worked on debugging tools

00:21:35,252 --> 00:21:38,835
worked around a lack of macros in some way?

00:21:39,758 --> 00:21:44,174
(background noise drowns out speaker)

00:21:44,174 --> 00:21:45,513
Okay.

00:21:45,513 --> 00:21:48,424
- [Audience Member] It's not terribly useful, I know,

00:21:48,424 --> 00:21:51,570
but Ditros has a mechanism in user space

00:21:51,570 --> 00:21:54,208
which is meant to abstract other differences

00:21:54,208 --> 00:21:55,349
between kernel versions.

00:21:55,349 --> 00:21:59,674
Translators, which can in effect, mimic macros in C.

00:21:59,674 --> 00:22:01,686
But you have to rewrite them in the process

00:22:01,686 --> 00:22:03,981
which for some of the more horrendous kernel macros

00:22:03,981 --> 00:22:05,403
is not terribly practical.

00:22:05,403 --> 00:22:06,743
(laughing)

00:22:06,743 --> 00:22:07,576
- Okay.

00:22:11,719 --> 00:22:12,552
Cool.

00:22:13,954 --> 00:22:14,952
- [Audience Member] Just one thing,

00:22:14,952 --> 00:22:17,106
so one thing is the size of the debug info

00:22:17,106 --> 00:22:18,707
that you need to take into account.

00:22:18,707 --> 00:22:21,657
So if you enable this macro information as well

00:22:21,657 --> 00:22:23,501
I mean they are already huge,

00:22:23,501 --> 00:22:25,494
so they're going to be even larger.

00:22:25,494 --> 00:22:28,257
So I'm not sure how the distributions will sit with that.

00:22:28,257 --> 00:22:31,694
- I actually measured it, for a large--

00:22:31,694 --> 00:22:34,416
- [Man] Please talk into the--

00:22:34,416 --> 00:22:35,630
- I measured it for a large Distro kernel,

00:22:35,630 --> 00:22:38,271
and you've got about nine gig of dwarf debug info

00:22:38,271 --> 00:22:40,988
and if you turn on macros it goes up to about 40.

00:22:40,988 --> 00:22:42,857
This is not terribly practical

00:22:42,857 --> 00:22:45,417
and it makes compilation take absolutely forever.

00:22:45,417 --> 00:22:47,245
(laughing)

00:22:47,245 --> 00:22:50,090
- So, one thing I've noticed about the bug information

00:22:50,090 --> 00:22:51,715
is that we don't minimize it at all.

00:22:51,715 --> 00:22:53,300
At least, Distros don't seem to.

00:22:53,300 --> 00:22:55,383
So, for example, the BTF,

00:22:57,404 --> 00:23:00,321
the dwarf to BTF stuff does all the

00:23:02,402 --> 00:23:04,271
Andre Hedges algorithim that

00:23:04,271 --> 00:23:06,385
what's the word?

00:23:06,385 --> 00:23:07,399
- Dedup.

00:23:07,399 --> 00:23:08,232
- Dedup, there we go.

00:23:08,232 --> 00:23:10,210
It dedup's everything.

00:23:10,210 --> 00:23:12,120
It's possible to do the same thing for dwarf,

00:23:12,120 --> 00:23:14,697
I think just no one's ever put the effort in to do it.

00:23:14,697 --> 00:23:16,058
- [Audience Member] Yes we have.

00:23:16,058 --> 00:23:17,358
- Oh you did?

00:23:17,358 --> 00:23:18,558
- [Audience Member] It's painful.

00:23:18,558 --> 00:23:20,264
It's much easier to get it to go from something like...

00:23:20,264 --> 00:23:23,457
There is a reason why most of the dwarf dedup stuff

00:23:23,457 --> 00:23:26,011
got ripped out of GCC and GCC it kept on crashing.

00:23:26,011 --> 00:23:27,800
And no one could fix it.

00:23:27,800 --> 00:23:29,813
It's much easier to soup up BTF

00:23:29,813 --> 00:23:33,047
or as we're now hoping to as of this meeting CGF.

00:23:33,047 --> 00:23:35,891
So that it can record this sort of thing for you.

00:23:35,891 --> 00:23:38,893
Of course, macros and compactness

00:23:38,893 --> 00:23:40,175
are not terribly compatible

00:23:40,175 --> 00:23:42,515
so it might be an interesting challenge.

00:23:42,515 --> 00:23:44,765
(laughing)

00:23:49,176 --> 00:23:50,009
- Yeah.

00:23:51,187 --> 00:23:53,057
Well, I'd imagine that it'd be possible

00:23:53,057 --> 00:23:54,787
to make macro information smaller

00:23:54,787 --> 00:23:58,420
'cause the header files in the kernel aren't 40 gigs.

00:23:58,420 --> 00:24:02,321
And that's kind of the upper bound on what you need to store

00:24:02,321 --> 00:24:04,071
or lower bound sorry.

00:24:05,326 --> 00:24:06,159
All right.

00:24:08,864 --> 00:24:09,743
Okay, looks like I'm out of time.

00:24:09,743 --> 00:24:10,576
- No, you have two minutes left.

00:24:10,576 --> 00:24:11,409
- Oh okay.

00:24:11,409 --> 00:24:12,242
- I gave you six minutes extra.

00:24:12,242 --> 00:24:13,675
- Oh, okay, cool.

00:24:13,675 --> 00:24:17,663
So the last thing I've run into is VM cores

00:24:17,663 --> 00:24:20,413
don't include the vm alloc areas,

00:24:22,325 --> 00:24:24,408
as well as per-CPU areas,

00:24:25,756 --> 00:24:27,323
other like specially mapped areas

00:24:27,323 --> 00:24:29,616
aren't in VM cores, so if you wanna read from a VM core,

00:24:29,616 --> 00:24:31,630
you need to actually walk the page tables

00:24:31,630 --> 00:24:33,476
and that's been a pain.

00:24:33,476 --> 00:24:35,630
So that's another thing I was wondering

00:24:35,630 --> 00:24:37,540
if anyone has worked around in any other way,

00:24:37,540 --> 00:24:40,082
other than just writing like

00:24:40,082 --> 00:24:42,254
there's this lip k dump file

00:24:42,254 --> 00:24:43,960
that knows how to walk the page tables

00:24:43,960 --> 00:24:46,457
but it's because we don't have macro information

00:24:46,457 --> 00:24:48,494
it's very kernel version sensitive.

00:24:48,494 --> 00:24:49,876
- Have you looked at the crash code?

00:24:49,876 --> 00:24:52,677
- It's the same thing, it walks the page tables.

00:24:52,677 --> 00:24:53,817
- Yeah.

00:24:53,817 --> 00:24:55,317
- Which is a pain.

00:24:56,307 --> 00:24:58,415
Yeah, it's fragile, so.

00:24:58,415 --> 00:25:00,383
- Now if we had like a library that maybe

00:25:00,383 --> 00:25:02,641
that somehow to, maybe that could help.

00:25:02,641 --> 00:25:03,738
- Yeah, well

00:25:03,738 --> 00:25:06,054
LIP k dump file is that,

00:25:06,054 --> 00:25:07,819
it knows how to parse k dump file,

00:25:07,819 --> 00:25:09,766
like make dump files format,

00:25:09,766 --> 00:25:11,638
but it also knows the page tables.

00:25:11,638 --> 00:25:13,751
But again, like if you upgrade kernels

00:25:13,751 --> 00:25:15,255
without upgrading the dump file

00:25:15,255 --> 00:25:16,294
then good luck.

00:25:16,294 --> 00:25:18,953
(laughs)

00:25:18,953 --> 00:25:21,983
Okay, well these are all things

00:25:21,983 --> 00:25:23,446
that are kinda on my to do list,

00:25:23,446 --> 00:25:26,005
to come up with better ways to do it.

00:25:26,005 --> 00:25:28,786
But, you know, splitting time between this and btrfs.

00:25:28,786 --> 00:25:29,619
Cool.

00:25:32,403 --> 00:25:33,680
All right.

00:25:33,680 --> 00:25:34,858
Thanks.

00:25:34,858 --> 00:25:38,025
(audience applauding)

00:25:43,450 --> 00:25:46,450
- Okay, next up is Masami Hiramatsu.

00:25:50,193 --> 00:25:52,026
Oh for the presenters.

00:25:55,677 --> 00:25:58,235
- Do you want me to put on mine, or do you want--

00:25:58,235 --> 00:26:00,656
- Oh sorry, one more thing,

00:26:00,656 --> 00:26:03,703
there's a kernel debugging tool BOF later today.

00:26:03,703 --> 00:26:05,311
- There's a kernel debugging tool BOF later today.

00:26:05,311 --> 00:26:08,001
- At 3:00 pm. - 3:00 pm.

00:26:08,001 --> 00:26:09,488
Do you wanna just plug in yours?

00:26:09,488 --> 00:26:10,821
See if it works?

00:26:11,821 --> 00:26:13,632
If there's a problem, then we'll probably

00:26:13,632 --> 00:26:15,598
plug it right back into yours, or mine.

00:26:15,598 --> 00:26:17,916
Well I can't, mine's the Etherpad right now.

00:26:17,916 --> 00:26:20,418
(audience chatting quietly)

00:26:20,418 --> 00:26:24,751
(conversation drowning out speaker)

00:27:15,354 --> 00:27:16,634
One more quick update.

00:27:16,634 --> 00:27:18,384
When you guys do use,

00:27:19,600 --> 00:27:22,363
I love that everyone uses these microphone

00:27:22,363 --> 00:27:24,273
when you talk, that way recording.

00:27:24,273 --> 00:27:26,218
But could you also stand up,

00:27:26,218 --> 00:27:28,357
because we're trying to get a discussion

00:27:28,357 --> 00:27:30,552
and people can see who's actually speaking.

00:27:30,552 --> 00:27:33,497
Right now, you're kind of hidden among the crowd,

00:27:33,497 --> 00:27:36,260
so when you're talking kinda just stand up to talk

00:27:36,260 --> 00:27:39,593
at least to show who you are, thank you.

00:27:41,665 --> 00:27:43,796
Oops, if not I could, mine,

00:27:43,796 --> 00:27:45,318
well, yours isn't working?

00:27:45,318 --> 00:27:49,995
Uh, where did Omar go, we might need his laptop.

00:27:49,995 --> 00:27:52,050
Ope, there he is.

00:27:52,050 --> 00:27:53,513
If it's not.

00:27:53,513 --> 00:27:54,749
If it takes more than two minutes,

00:27:54,749 --> 00:27:57,777
then we need to try something because we only have,

00:27:57,777 --> 00:28:00,860
I dedicated two minutes for transfer.

00:28:05,541 --> 00:28:07,126
- No, not working.

00:28:07,126 --> 00:28:10,793
- Can he use yours, he has it right on this.

00:28:15,607 --> 00:28:16,440
- Uh, zero, two.

00:28:16,440 --> 00:28:19,402
- And who's next on the list,

00:28:19,402 --> 00:28:21,113
just so I know who's.

00:28:21,113 --> 00:28:22,454
- [Audience Member] I'm next.

00:28:22,454 --> 00:28:24,642
- Oh you, and you've already been on this.

00:28:24,642 --> 00:28:25,608
Yeah, so we might be using your,

00:28:25,608 --> 00:28:26,882
are you okay with your laptop

00:28:26,882 --> 00:28:27,715
being used for the next two talks here?

00:28:27,715 --> 00:28:29,215
- Yeah, it's fine.

00:28:37,234 --> 00:28:38,067
- Yeah.

00:28:39,616 --> 00:28:40,449
Okay.

00:28:43,475 --> 00:28:44,308
Oh, sorry.

00:28:45,770 --> 00:28:48,899
So for rater, so that there,

00:28:48,899 --> 00:28:51,279
I will direct or show some of our

00:28:51,279 --> 00:28:54,731
the latent work for kernel boot-time tracing.

00:28:54,731 --> 00:28:58,398
So we're Masami Hiramatsu working for Linaro

00:29:00,863 --> 00:29:04,280
and maintainer of Kprobes related things.

00:29:05,149 --> 00:29:05,982
Okay.

00:29:08,362 --> 00:29:12,345
So, why we need our kernel boot-time tracing?

00:29:12,345 --> 00:29:16,057
The kernel boot-time tracing is for debugging

00:29:16,057 --> 00:29:19,148
and another thing that the boot time errors

00:29:19,148 --> 00:29:21,343
or performance issues,

00:29:21,343 --> 00:29:25,160
so that we need to measure performance statistics

00:29:25,160 --> 00:29:27,014
of the kernel boot

00:29:27,014 --> 00:29:31,118
or analyze our kernel driver issues when they boot

00:29:31,118 --> 00:29:35,535
or debug the boot up process, or something like that.

00:29:36,718 --> 00:29:40,885
And actually, we already have some f trace options

00:29:43,748 --> 00:29:45,416
for the kernel command line,

00:29:45,416 --> 00:29:48,040
so yeah there are some of our options.

00:29:48,040 --> 00:29:50,681
And you can see that those options,

00:29:50,681 --> 00:29:54,598
under the documentation, the kernel parameters.

00:29:55,534 --> 00:30:00,270
And here is like an example of the kernel command line

00:30:00,270 --> 00:30:02,437
options for the f tracing.

00:30:03,603 --> 00:30:08,520
So you can see that the long kernel command line parameters

00:30:11,178 --> 00:30:15,140
for the tracing, yeah, you can do that.

00:30:15,140 --> 00:30:19,062
But what issues under current implementation

00:30:19,062 --> 00:30:22,229
is it's a, there are major two issues.

00:30:24,097 --> 00:30:25,749
One is a size limitation.

00:30:25,749 --> 00:30:28,878
Because of the kernel command line size

00:30:28,878 --> 00:30:31,045
is limited under 256 byte,

00:30:33,673 --> 00:30:37,690
and the half of them is used by the normal command line.

00:30:37,690 --> 00:30:40,598
So that the command line, parameter also uses

00:30:40,598 --> 00:30:44,563
like for specifying booter device or something like that.

00:30:44,563 --> 00:30:48,139
So that the size is very limited.

00:30:48,139 --> 00:30:53,139
And the other issues are only partial features was supported

00:30:54,884 --> 00:30:56,717
not the full features.

00:30:57,746 --> 00:31:01,604
Like an f trace really has too complex features

00:31:01,604 --> 00:31:05,182
like histograms or something like that,

00:31:05,182 --> 00:31:08,099
which is not sweet for single line,

00:31:09,551 --> 00:31:12,134
or sorry, command line options.

00:31:15,073 --> 00:31:20,073
So, I'd like to make it like a per-event filters and actions

00:31:22,411 --> 00:31:24,994
instance making, or histograms.

00:31:26,986 --> 00:31:28,819
So what are solutions?

00:31:29,848 --> 00:31:32,015
One is to use init ram fs.

00:31:33,830 --> 00:31:36,466
I mean that the init process.

00:31:36,466 --> 00:31:39,600
But it's too late to initiate tracing

00:31:39,600 --> 00:31:42,933
when after landing with an init process.

00:31:44,123 --> 00:31:48,956
And the second one is maybe expand the kernel command line

00:31:49,881 --> 00:31:54,381
but this one is also, just things make more confusing.

00:31:56,338 --> 00:31:59,714
You know, because it's not easy to

00:31:59,714 --> 00:32:02,356
write down a complex tracing options

00:32:02,356 --> 00:32:06,297
on the boot loader or something like that.

00:32:06,297 --> 00:32:10,214
And another one is reuse the current, oh sorry,

00:32:11,841 --> 00:32:15,232
structured boot time data like a Devicetree.

00:32:15,232 --> 00:32:17,936
This is actually what I tried

00:32:17,936 --> 00:32:21,686
at first and the second series of my version.

00:32:25,964 --> 00:32:30,547
So our boot-time trace, V1, version one and version two

00:32:32,321 --> 00:32:34,457
is based on actually Devicetree.

00:32:34,457 --> 00:32:37,457
Devicetree is actually, is very well

00:32:45,161 --> 00:32:49,911
well, let's see, destruct, described and structured data.

00:32:52,902 --> 00:32:56,516
And it already passed when the kernel is boot,

00:32:56,516 --> 00:32:59,433
so that there are many good points,

00:33:00,522 --> 00:33:05,355
stable and good for the user space tools, well documented.

00:33:08,012 --> 00:33:11,249
And most of the boot loader already supported.

00:33:11,249 --> 00:33:15,344
It actually SKC graph doesn't support that.

00:33:15,344 --> 00:33:19,594
I just I need to make a patch, but yeah, it's easy.

00:33:21,280 --> 00:33:25,280
And we talked with some of our veteran engineers

00:33:28,209 --> 00:33:32,459
about this idea, but they actually rejected my idea

00:33:34,421 --> 00:33:37,571
because Devicetree's are standardized and documented

00:33:37,571 --> 00:33:40,147
as hardware description,

00:33:40,147 --> 00:33:44,113
not a software configuration or something like that.

00:33:44,113 --> 00:33:47,937
So that I need to check applying it another way.

00:33:47,937 --> 00:33:52,854
And V3, I introduce a new supplemental kernel command line.

00:33:57,040 --> 00:34:00,957
This is actually, let's see, another Devicetree

00:34:07,542 --> 00:34:12,042
so I introduced a new kernel command line extension.

00:34:12,042 --> 00:34:15,605
It is actually, a plain ascii text,

00:34:15,605 --> 00:34:19,688
so not binary data, just a plain data, text data,

00:34:20,673 --> 00:34:25,173
which are written as a tree structured key value list,

00:34:27,619 --> 00:34:31,169
so that you can write the key value

00:34:31,169 --> 00:34:34,095
as a key word equal value,

00:34:34,095 --> 00:34:37,141
and also you can write them as the trees.

00:34:37,141 --> 00:34:40,724
Those are words, connected with our period.

00:34:46,745 --> 00:34:50,245
So this is written as a file, a text file,

00:34:53,258 --> 00:34:57,425
and boot loader, can load it when the kernel boot,

00:34:58,525 --> 00:35:03,525
and so that our kernel will pass this file at a early stage.

00:35:12,271 --> 00:35:14,164
So I tried to make a demo,

00:35:14,164 --> 00:35:17,414
but with the trouble, I cannot do that.

00:35:18,837 --> 00:35:23,087
But yeah, I have a back ups right for what happens,

00:35:26,269 --> 00:35:30,602
so SKC supplemental command line, boot-time tracing,

00:35:34,356 --> 00:35:36,229
which is based on like that.

00:35:36,229 --> 00:35:39,114
Yeah, you can write the f trace.

00:35:39,114 --> 00:35:40,947
And trace and options,

00:35:41,976 --> 00:35:45,047
these options actually we already have

00:35:45,047 --> 00:35:47,543
under kernel command line.

00:35:47,543 --> 00:35:49,354
It's the same mechanism.

00:35:49,354 --> 00:35:52,187
And also, you can expand the tree,

00:35:55,206 --> 00:35:58,123
which are event k probes, vfs, read

00:36:00,349 --> 00:36:02,462
or something like that, yeah,

00:36:02,462 --> 00:36:07,045
you can write down, define that the new k probes event.

00:36:09,474 --> 00:36:13,817
Actually this one needs a very humanly double parameters

00:36:13,817 --> 00:36:16,817
with filters or something like that.

00:36:17,839 --> 00:36:20,922
And also for their, sorry, histograms

00:36:26,509 --> 00:36:30,152
we need to make a new sensitive event

00:36:30,152 --> 00:36:32,345
for consolidating the histograms

00:36:32,345 --> 00:36:36,678
so that our this, you can see that the f trace event

00:36:37,565 --> 00:36:42,065
and actually it's a synthetic init call latency event.

00:36:45,204 --> 00:36:48,787
And with these field, and also our actions,

00:36:50,429 --> 00:36:54,672
you can link the histograms sitting on that.

00:36:54,672 --> 00:36:57,755
And other init call start and finish,

00:36:59,711 --> 00:37:03,211
you can see that they're histogram events.

00:37:04,331 --> 00:37:07,615
No histogram actions, three actions,

00:37:07,615 --> 00:37:11,115
which send the latency data to this event.

00:37:15,339 --> 00:37:16,172
So, oh.

00:37:17,899 --> 00:37:18,732
Like that.

00:37:19,849 --> 00:37:22,849
And, when, how to use this SKC file.

00:37:26,593 --> 00:37:29,927
You can write down the file, and put the,

00:37:29,927 --> 00:37:33,241
for example, to use it by a graph,

00:37:33,241 --> 00:37:35,534
you can write down the SKC file

00:37:35,534 --> 00:37:39,451
and put it under boot and use the "skc" command

00:37:40,736 --> 00:37:43,156
right after the Linux command,

00:37:43,156 --> 00:37:47,573
and posture the file to skc on the grub command line.

00:37:50,894 --> 00:37:54,561
Or, you can use under SKC with Qemu testing.

00:37:57,620 --> 00:38:01,287
With our pass the SKC option, and like that,

00:38:06,132 --> 00:38:09,414
so that the kernel is sitting that the kernel,

00:38:09,414 --> 00:38:12,750
passing the kernel with SKC file.

00:38:12,750 --> 00:38:17,586
So that's the Qemu load, that the Qemu and the grub

00:38:17,586 --> 00:38:19,477
load their SKC file on their memory

00:38:19,477 --> 00:38:22,644
and then shares it to pass the kernel.

00:38:28,946 --> 00:38:30,954
- [Audience Member] Can you go back really quick,

00:38:30,954 --> 00:38:32,197
I just wanted to see the Qemu,

00:38:32,197 --> 00:38:34,530
go back to the Qemu, I just wanted to see that.

00:38:34,530 --> 00:38:35,947
- Yep, it's fine.

00:38:36,951 --> 00:38:41,380
- [Audience Member] And is that already in Qemu,

00:38:41,380 --> 00:38:42,616
or is that?

00:38:42,616 --> 00:38:46,387
- Not in, yeah, I just implemented that this summer

00:38:46,387 --> 00:38:49,764
for Qemu, and grub, for exit disks,

00:38:49,764 --> 00:38:53,764
but it's easy to support for other architecture.

00:38:54,779 --> 00:38:58,152
Just put these files on the memory

00:38:58,152 --> 00:39:01,902
and actually posture physically all the risks

00:39:03,377 --> 00:39:04,880
via the kernel command line.

00:39:04,880 --> 00:39:06,630
So it's very generic.

00:39:12,823 --> 00:39:14,156
So, that is the,

00:39:15,358 --> 00:39:18,775
so here is the current status of my work.

00:39:21,450 --> 00:39:24,950
What's done is make a RFC patches with SKC

00:39:26,370 --> 00:39:30,294
and also Qemu and grub implementation made

00:39:30,294 --> 00:39:35,044
my reports are these, so you can download it and test it.

00:39:39,109 --> 00:39:42,692
However, I just get the response from time,

00:39:45,794 --> 00:39:49,794
for this series so I need your response or reply

00:39:53,131 --> 00:39:55,813
or any comments on that.

00:39:55,813 --> 00:39:59,813
And I think that we need to make somewhere more,

00:40:04,103 --> 00:40:06,936
let's see, more things to be done.

00:40:12,386 --> 00:40:16,903
One of these are actions syntax expansion for the histogram

00:40:16,903 --> 00:40:21,129
because it's a current histogram options to load

00:40:21,129 --> 00:40:24,112
and have a different syntax,

00:40:24,112 --> 00:40:26,695
so it's not easy to write down.

00:40:27,604 --> 00:40:30,687
And also, initialize tracing earlier.

00:40:32,768 --> 00:40:34,515
The boot-time tracing is currently

00:40:34,515 --> 00:40:37,932
ensured in boot, let's see, fs init call,

00:40:40,186 --> 00:40:43,112
and also, we need a user space tools

00:40:43,112 --> 00:40:45,195
for writing the SKC file,

00:40:46,183 --> 00:40:49,100
and operating if it's right or not.

00:40:52,888 --> 00:40:55,055
And, of course, we need to

00:40:57,154 --> 00:41:00,544
discuss with our other personnel,

00:41:00,544 --> 00:41:03,246
I am not sure who is the correct person to talk

00:41:03,246 --> 00:41:06,163
about SKC and how we can, you know.

00:41:07,818 --> 00:41:08,651
Yeah?

00:41:09,670 --> 00:41:12,894
- I'm curious, have you considered integrating this

00:41:12,894 --> 00:41:14,929
with the kernel build, so optionally,

00:41:14,929 --> 00:41:17,711
you could point the kernel build

00:41:17,711 --> 00:41:21,512
to a set of SKC file, they get pulled into the kernel image,

00:41:21,512 --> 00:41:23,201
and then on the command line,

00:41:23,201 --> 00:41:27,465
you refer to the SKC profiles you want actually loaded

00:41:27,465 --> 00:41:29,215
for this specific boot.

00:41:29,215 --> 00:41:32,687
It might, easy, make the integration much easier,

00:41:32,687 --> 00:41:35,163
since you just have to integrate within the Linux kernel,

00:41:35,163 --> 00:41:38,211
without having to modify Qemu or grub.

00:41:38,211 --> 00:41:40,441
- Yeah, that is another option I think.

00:41:40,441 --> 00:41:43,774
Yeah, I think that is, we can, expand it

00:41:46,402 --> 00:41:48,319
the SKC file, you know,

00:41:49,746 --> 00:41:53,829
boot, load when the boot, or load when compelled.

00:41:55,423 --> 00:41:57,959
- I mean you could also, yeah,

00:41:57,959 --> 00:41:58,975
kind of like similar to that,

00:41:58,975 --> 00:42:01,409
you could also do that, kind of like k dump

00:42:01,409 --> 00:42:03,689
okay so that k dump loads a kernel in there.

00:42:03,689 --> 00:42:05,314
So you could just say, here's a path,

00:42:05,314 --> 00:42:06,816
so it knows the boot directory,

00:42:06,816 --> 00:42:08,221
like where it would load in at RAM disk.

00:42:08,221 --> 00:42:10,013
You could just put in say,

00:42:10,013 --> 00:42:10,846
is that basically what you're saying,

00:42:10,846 --> 00:42:12,144
just say hey slash, boot slash SKC,

00:42:12,144 --> 00:42:15,354
or is SKC maybe have a kernel command line

00:42:15,354 --> 00:42:17,856
called SKC equals, and then you put a path name,

00:42:17,856 --> 00:42:20,456
where it will boot up just like it,

00:42:20,456 --> 00:42:22,871
we could put in init RAM disks or something.

00:42:22,871 --> 00:42:24,659
And well, not really even at RAM,

00:42:24,659 --> 00:42:25,855
RAM that's passed up by grub.

00:42:25,855 --> 00:42:28,331
- That will need to, you know,

00:42:28,331 --> 00:42:31,081
put the file in the init call FS,

00:42:31,951 --> 00:42:35,753
we cannot access, unless we expand it,

00:42:35,753 --> 00:42:36,658
you need to have a grub base.

00:42:36,658 --> 00:42:37,716
- I see what you're saying so grub

00:42:37,716 --> 00:42:38,709
has to actually still load it still someplace.

00:42:38,709 --> 00:42:39,542
- Yeah.

00:42:39,542 --> 00:42:40,375
- I was thinking about it as a way,

00:42:40,375 --> 00:42:42,792
and I'm trying to think about how a kdump,

00:42:42,792 --> 00:42:44,737
kexec kinda does an image there.

00:42:44,737 --> 00:42:48,725
- Yeah, k dump also are initiated at a later stage.

00:42:48,725 --> 00:42:52,138
- Yeah so it's too late, yeah it's too late then,

00:42:52,138 --> 00:42:52,971
that's true.

00:42:52,971 --> 00:42:55,006
- Sorry, I'm not really familiar

00:42:55,006 --> 00:42:57,133
with how kexec really works.

00:42:57,133 --> 00:43:00,184
But kexec does stuff in user space, right,

00:43:00,184 --> 00:43:03,133
so doesn't kexec have the ability

00:43:03,133 --> 00:43:06,587
to actually access a file in the running system

00:43:06,587 --> 00:43:11,300
and incorporate it then into the new boot with kexec,

00:43:11,300 --> 00:43:12,520
is that plausible or not?

00:43:12,520 --> 00:43:15,056
- [Masami] Yeah, I think it's--

00:43:15,056 --> 00:43:16,397
- I hadn't even thought about that

00:43:16,397 --> 00:43:17,863
before when we were talking.

00:43:17,863 --> 00:43:21,054
- Yeah, but in that case, we need to, you know,

00:43:21,054 --> 00:43:23,311
do you have state boot?

00:43:23,311 --> 00:43:24,144
Yeah.

00:43:25,322 --> 00:43:26,521
- [Audience Member] Yeah, that'd be a

00:43:26,521 --> 00:43:27,595
two stage boot to do that.

00:43:27,595 --> 00:43:29,301
- So basically you're saying like boot up in one kernel

00:43:29,301 --> 00:43:31,537
then trigger another, and loads everything for you,

00:43:31,537 --> 00:43:32,855
then trigger another kernel,

00:43:32,855 --> 00:43:33,737
and you know where the memory is.

00:43:33,737 --> 00:43:34,748
- [Audience Member] Exactly.

00:43:34,748 --> 00:43:38,662
- Okay, yeah, I don't know if people would want that though.

00:43:38,662 --> 00:43:41,495
- So technically, you could extend

00:43:42,920 --> 00:43:44,871
an internal mechanism for that.

00:43:44,871 --> 00:43:48,303
Like, just making it an init area to work thing.

00:43:48,303 --> 00:43:50,720
With your SKC like appendage.

00:43:52,411 --> 00:43:54,784
To the original, right?

00:43:54,784 --> 00:43:57,467
- [Masami] Original, oh sorry, command line

00:43:57,467 --> 00:43:58,800
- No internally.

00:44:00,010 --> 00:44:02,998
Or in Qemu FS because this is an image,

00:44:02,998 --> 00:44:06,550
don't you allow it anyway into memory, right?

00:44:06,550 --> 00:44:09,210
- Yeah, so you mean that the, after,

00:44:09,210 --> 00:44:12,361
the file under yeah, like a tails

00:44:12,361 --> 00:44:13,694
or init FS file?

00:44:15,838 --> 00:44:19,618
- Yes, so upon your SKC part to the rest of the init FS file

00:44:19,618 --> 00:44:21,483
and then you have a singly matched

00:44:21,483 --> 00:44:24,389
and then you only need an off setting to that.

00:44:24,389 --> 00:44:26,009
Bypass your SKC's.

00:44:26,009 --> 00:44:28,012
- Yeah, you also can, yeah it's possible.

00:44:28,012 --> 00:44:30,345
But I think that will, yeah,

00:44:32,359 --> 00:44:34,192
we need to, if we can,

00:44:35,122 --> 00:44:40,122
we'd like to change our trace command, our tracing script.

00:44:40,527 --> 00:44:44,631
We need to prepare that the several different kernels

00:44:44,631 --> 00:44:48,776
in each or interim FS image, that will consume too many--

00:44:48,776 --> 00:44:50,012
- [Audience Member] Well you only need one,

00:44:50,012 --> 00:44:52,352
and then have multiple sections at the end.

00:44:52,352 --> 00:44:55,479
- Yeah, like basically you have it

00:44:55,479 --> 00:44:57,705
and just you can candate the two,

00:44:57,705 --> 00:44:59,887
actually you could even keep it two separate files

00:44:59,887 --> 00:45:02,673
but you just can concatenate it to a third file

00:45:02,673 --> 00:45:07,006
that this is what's gonna get loaded into boot time.

00:45:08,060 --> 00:45:10,311
- [Audience Member] The kernels bill system, isn't so good,

00:45:10,311 --> 00:45:11,587
oh sorry.

00:45:11,587 --> 00:45:13,921
The kernels bill system isn't so good

00:45:13,921 --> 00:45:15,929
at automatically building those though.

00:45:15,929 --> 00:45:17,026
- No this wouldn't be,

00:45:17,026 --> 00:45:18,716
it would actually be a user space tool.

00:45:18,716 --> 00:45:20,219
- It would be desirable anyway,

00:45:20,219 --> 00:45:22,982
because that way people who are building or anything--

00:45:22,982 --> 00:45:25,298
- Could you stand up, just so we can get you--

00:45:25,298 --> 00:45:26,884
- Sorry, that way people who are building

00:45:26,884 --> 00:45:27,717
your init and your RAM FS could easily build,

00:45:27,717 --> 00:45:30,476
could easily add early micro code

00:45:30,476 --> 00:45:32,406
and that sort of thing which is

00:45:32,406 --> 00:45:34,055
also not implemented at the moment.

00:45:34,055 --> 00:45:35,520
Because that uses the same technique

00:45:35,520 --> 00:45:38,122
of concatenating stuff onto the front of the init RAM FS.

00:45:38,122 --> 00:45:40,763
- So are you suggesting like a generic solution for this?

00:45:40,763 --> 00:45:42,206
- Yeah, because there's already one in the kernel

00:45:42,206 --> 00:45:44,054
for building or actually when you compile the kernel,

00:45:44,054 --> 00:45:46,365
so I think it just needs enhancement.

00:45:46,365 --> 00:45:47,948
It is sorta useful.

00:45:50,632 --> 00:45:51,972
- Well I think, yeah.

00:45:51,972 --> 00:45:53,127
- Hang on, hang on,

00:45:53,127 --> 00:45:55,178
this is boot-time tracing.

00:45:55,178 --> 00:45:58,307
So you said init RAM FS, it's already too late.

00:45:58,307 --> 00:46:00,257
Like we've already booted.

00:46:00,257 --> 00:46:03,734
- [Host] No, no, but the init RAM FS is loaded onto memory.

00:46:03,734 --> 00:46:05,438
- No, that's late.

00:46:05,438 --> 00:46:07,368
- [Host] Was it, that's still too late?

00:46:07,368 --> 00:46:08,706
- It's way too late.

00:46:08,706 --> 00:46:10,027
- No boot time actually load,

00:46:10,027 --> 00:46:13,777
but we need to have our somewhere, let's see.

00:46:16,365 --> 00:46:17,730
- Oh knowing where it is.

00:46:17,730 --> 00:46:20,128
- Yeah, no, we need to...

00:46:20,128 --> 00:46:22,728
Have our password, to pass it through the images.

00:46:22,728 --> 00:46:24,296
- Yeah, yeah.

00:46:24,296 --> 00:46:25,957
- [Audience Member] I'm just saying,

00:46:25,957 --> 00:46:27,848
it's loaded during boot, but it's late in boot.

00:46:27,848 --> 00:46:29,537
- No, no, no, no.

00:46:29,537 --> 00:46:30,838
- [Audience Member] Yeah, yeah, yeah, yeah.

00:46:30,838 --> 00:46:32,521
- No, no, no, no, no.

00:46:32,521 --> 00:46:34,959
The grub loads in it like when you on kexecs.

00:46:34,959 --> 00:46:35,792
- No, no.

00:46:35,792 --> 00:46:38,268
The kernel doesn't unpack the RAM FS until later.

00:46:38,268 --> 00:46:40,218
- Yes, but we only have to know where it is

00:46:40,218 --> 00:46:42,413
and they say if it's concatenated.

00:46:42,413 --> 00:46:44,770
So we're not, we're not putting into the init RAM,

00:46:44,770 --> 00:46:47,063
we're not expanding it, we're just saying

00:46:47,063 --> 00:46:48,485
here is a blob of memory,

00:46:48,485 --> 00:46:50,536
and on the end we put the SKC files

00:46:50,536 --> 00:46:52,572
so we know where the init RAM disk is.

00:46:52,572 --> 00:46:54,153
- [Audience Member] That's not a terrible,

00:46:54,153 --> 00:46:55,132
okay maybe that could work.

00:46:55,132 --> 00:46:57,740
So the other option is the Devicetree maintainers are wrong

00:46:57,740 --> 00:47:00,212
(audience laughing)

00:47:00,212 --> 00:47:02,045
and it should just be.

00:47:03,932 --> 00:47:05,638
Because, the Devicetree does

00:47:05,638 --> 00:47:07,467
already have a configuration in it,

00:47:07,467 --> 00:47:09,417
it has the kernel command line in it.

00:47:09,417 --> 00:47:12,049
- [Audience Member] It's missing

00:47:12,049 --> 00:47:13,364
communication between those two.

00:47:13,364 --> 00:47:14,646
- Oh I think right here, throw the mic that way,

00:47:14,646 --> 00:47:16,330
or do you want me to throw this mic.

00:47:16,330 --> 00:47:18,014
- It's mostly above air, - Heads up.

00:47:18,014 --> 00:47:18,847
- But not all of it.

00:47:18,847 --> 00:47:19,680
- Incoming.

00:47:19,680 --> 00:47:22,680
(audience laughing)

00:47:24,837 --> 00:47:27,379
- Yeah, one of the big problems with putting

00:47:27,379 --> 00:47:29,862
an extra configuration stuff into the DT

00:47:29,862 --> 00:47:32,300
is stuff like kexec, especially the kexec followed

00:47:32,300 --> 00:47:34,111
we have to go and sanitize a chosen node.

00:47:34,111 --> 00:47:36,241
And we really wanna keep most of that idempotent

00:47:36,241 --> 00:47:38,622
other than the command line

00:47:38,622 --> 00:47:41,321
which is called boot-og's that we change all the time,

00:47:41,321 --> 00:47:43,252
we want to keep some other stuff

00:47:43,252 --> 00:47:45,082
like the stood out path.

00:47:45,082 --> 00:47:46,866
But we don't wanna mess around,

00:47:46,866 --> 00:47:49,105
I mean we wanna clean, we have to clean

00:47:49,105 --> 00:47:50,054
some other things like the init ID properties.

00:47:50,054 --> 00:47:52,356
We have this mismatch of things that we gotta keep

00:47:52,356 --> 00:47:54,336
and things we gotta remove,

00:47:54,336 --> 00:47:55,932
and I really don't wanna have to change that code

00:47:55,932 --> 00:47:57,837
in the kexec follow path,

00:47:57,837 --> 00:48:00,135
every kernel release when we add a new thing

00:48:00,135 --> 00:48:01,580
that we might wanna keep, or we might wanna remove.

00:48:01,580 --> 00:48:03,896
So having this in the command line is nice,

00:48:03,896 --> 00:48:05,967
'cause that's something that is transient

00:48:05,967 --> 00:48:07,187
from boot to boot already.

00:48:07,187 --> 00:48:10,177
So that is a really nice feature of--

00:48:10,177 --> 00:48:14,131
- [Man] Except kexec already copies it or, you know.

00:48:14,131 --> 00:48:15,677
- Kexec Follow does not copy the command line,

00:48:15,677 --> 00:48:17,852
it uses the command line as it's handed from user space.

00:48:17,852 --> 00:48:21,224
Kexec in user space also can use whatever it's handed

00:48:21,224 --> 00:48:23,703
or it can copy the existing thing,

00:48:23,703 --> 00:48:25,717
but when you're using kexec from user space

00:48:25,717 --> 00:48:27,157
without kexec Follow,

00:48:27,157 --> 00:48:28,889
you can do absolutely anything to the k's.

00:48:28,889 --> 00:48:33,222
- Yeah, but the constadator, if we cannot use kexec,

00:48:34,058 --> 00:48:36,771
like a new architecture or something like that,

00:48:36,771 --> 00:48:39,289
but tracing can do that.

00:48:39,289 --> 00:48:41,503
- Okay, this time is up.

00:48:41,503 --> 00:48:42,735
- Oh, okay.

00:48:42,735 --> 00:48:44,897
- So actually, if you wanna have a wrap up real quick,

00:48:44,897 --> 00:48:45,967
or something?

00:48:45,967 --> 00:48:47,948
- Yeah, yeah, sorry I don't know how to,

00:48:47,948 --> 00:48:49,629
no, no, it's just,

00:48:49,629 --> 00:48:50,659
this one needs a less,

00:48:50,659 --> 00:48:54,159
another one is just explains what happens,

00:48:55,215 --> 00:48:56,798
yeah, like that.

00:48:56,798 --> 00:48:57,715
- Okay, so.

00:48:59,432 --> 00:49:02,109
With this should we take a BOF later on?

00:49:02,109 --> 00:49:03,495
To discuss this further?

00:49:03,495 --> 00:49:04,328
- Okay.

00:49:04,328 --> 00:49:06,094
- Any of you wanna be in a BOF later?

00:49:06,094 --> 00:49:09,122
Let's continue the conversation.

00:49:09,122 --> 00:49:11,243
We kinda have an idea, so let's small,

00:49:11,243 --> 00:49:14,069
we'll set up registration for this.

00:49:14,069 --> 00:49:16,191
But next we have to go to the next person up.

00:49:16,191 --> 00:49:19,524
I think there's you information for you.

00:49:20,471 --> 00:49:21,537
Thank you.

00:49:21,537 --> 00:49:24,704
(audience applauding)

00:49:28,020 --> 00:49:31,020
(audience chatting)

00:49:37,766 --> 00:49:38,752
- [Woman] Frank is the owner.

00:49:38,752 --> 00:49:39,923
- [Man] Oh I thought you were the center

00:49:39,923 --> 00:49:40,756
of the passing universe.

00:49:40,756 --> 00:49:43,962
The cord has got it's center of gravity's

00:49:43,962 --> 00:49:46,522
gotta be somewhere right here, between us.

00:49:46,522 --> 00:49:51,189
(cross talk drowns out any one speaker)

00:50:33,545 --> 00:50:34,626
- [Audience Member] 'Cause if they do

00:50:34,626 --> 00:50:38,043
like a block of memory, that's two week,

00:50:38,043 --> 00:50:40,190
one or two week properties that have been chosen.

00:50:40,190 --> 00:50:45,169
- [Man] Yeah, well once they get the command line.

00:50:45,169 --> 00:50:47,051
I mean we can already do that, with an SLD,

00:50:47,051 --> 00:50:52,051
you can have an SLD stunt, (cross-talk drowns out speaker)

00:50:52,598 --> 00:50:54,728
- [Audience Member] So like the same file format

00:50:54,728 --> 00:50:57,145
or user space, and boot-time,

00:50:59,241 --> 00:51:03,111
and they could build it into the kernel.

00:51:03,111 --> 00:51:06,944
- I'll leave it to you, to say your full name.

00:51:11,646 --> 00:51:12,769
Yes.

00:51:12,769 --> 00:51:13,852
And also his.

00:51:20,453 --> 00:51:23,658
So good morning everyone, great this works.

00:51:23,658 --> 00:51:26,431
So my name is Song Liu, and...

00:51:26,431 --> 00:51:27,589
- David.

00:51:27,589 --> 00:51:28,756
David Carillo.

00:51:31,104 --> 00:51:33,344
- And David Carillo.

00:51:33,344 --> 00:51:34,375
- I apologize, it just got turned off,

00:51:34,375 --> 00:51:36,636
let me turn it on.

00:51:36,636 --> 00:51:37,636
- So today--

00:51:38,890 --> 00:51:41,307
- Gotta be careful coming in.

00:51:43,335 --> 00:51:47,054
- So today we wanna talk about share PMU counters

00:51:47,054 --> 00:51:49,307
across compatible perf events.

00:51:49,307 --> 00:51:52,543
So lets look at the problem we're looking at,

00:51:52,543 --> 00:51:54,571
it's like we have more perf events

00:51:54,571 --> 00:51:58,182
than PMU counters provided by the hardware.

00:51:58,182 --> 00:52:01,015
So basically, in some environment,

00:52:02,106 --> 00:52:05,575
like our company Facebook we have different tools,

00:52:05,575 --> 00:52:07,478
and they are all counting the same thing

00:52:07,478 --> 00:52:09,062
like the cycles, the instructions.

00:52:09,062 --> 00:52:10,607
But they have different scope,

00:52:10,607 --> 00:52:13,522
sometimes different tools counting at the same scope.

00:52:13,522 --> 00:52:15,855
We cannot really limit them.

00:52:16,722 --> 00:52:19,587
And it do per CPU events,

00:52:19,587 --> 00:52:21,435
there would be a per task event,

00:52:21,435 --> 00:52:24,245
and there would be a cgroup or cgroup events

00:52:24,245 --> 00:52:26,271
and sometimes we have nested cgroup,

00:52:26,271 --> 00:52:29,807
you can have every layer you have different counters.

00:52:29,807 --> 00:52:31,866
So they all count the same thing,

00:52:31,866 --> 00:52:34,449
but they are separate perf event.

00:52:34,449 --> 00:52:36,312
So when we have like more perf events,

00:52:36,312 --> 00:52:38,143
then we have the counters,

00:52:38,143 --> 00:52:40,295
we're gonna do the time multiplexing

00:52:40,295 --> 00:52:44,486
which is through this perf rotate context function.

00:52:44,486 --> 00:52:47,761
So here's a very easy example,

00:52:47,761 --> 00:52:51,261
I always play with, we use the it's at 66,

00:52:52,420 --> 00:52:54,678
we use the ref cycles events,

00:52:54,678 --> 00:52:57,113
which there's only one counter at the rate

00:52:57,113 --> 00:52:58,749
so if you do that twice,

00:52:58,749 --> 00:53:01,862
easily you'll get like multiplexing.

00:53:01,862 --> 00:53:06,445
So, one event get a schedule three fourths of the time,

00:53:07,511 --> 00:53:09,578
the other get it one fourth of the time.

00:53:09,578 --> 00:53:11,691
That's not a bug, it's by design,

00:53:11,691 --> 00:53:14,271
there's no guarantee you'll get an equal amount of time.

00:53:14,271 --> 00:53:16,702
But you, basically the rotation

00:53:16,702 --> 00:53:18,695
makes sure you get some time to run.

00:53:18,695 --> 00:53:21,195
This is a problem, like first,

00:53:22,698 --> 00:53:25,589
time multiplexing is very expensive.

00:53:25,589 --> 00:53:28,926
It can force reschedule of the perf event.

00:53:28,926 --> 00:53:31,231
Every millisecond by default.

00:53:31,231 --> 00:53:36,231
And also it's not an accurate way of doing this multiplexing

00:53:36,509 --> 00:53:38,165
and when you do like a context

00:53:38,165 --> 00:53:39,942
which if that happens too much,

00:53:39,942 --> 00:53:42,162
you probably didn't get much time to run.

00:53:42,162 --> 00:53:44,412
You're already off the CPU.

00:53:46,022 --> 00:53:47,765
- [Audience Member] So that is something

00:53:47,765 --> 00:53:49,471
I will fight you on.

00:53:49,471 --> 00:53:52,542
Something tells me you'll be having this a lot.

00:53:52,542 --> 00:53:54,571
(audience laughing)

00:53:54,571 --> 00:53:55,460
- Is that thing on?

00:53:55,460 --> 00:53:57,877
Yeah so the unfairness there,

00:53:58,714 --> 00:54:00,367
that's something I do want to fix.

00:54:00,367 --> 00:54:03,950
(microphone reverberating)

00:54:04,998 --> 00:54:07,229
Scary little thing.

00:54:07,229 --> 00:54:09,729
It's just, it's a lot of work.

00:54:11,069 --> 00:54:12,883
We need to rewrite most of

00:54:12,883 --> 00:54:14,702
how all that course core scheduling works.

00:54:14,702 --> 00:54:16,952
A year or two ago I posted,

00:54:18,135 --> 00:54:20,731
no what was it, a year and a half, I don't know.

00:54:20,731 --> 00:54:23,326
I posted some of that rewrite.

00:54:23,326 --> 00:54:25,049
I just haven't had time afterwords

00:54:25,049 --> 00:54:27,593
to look at it every again.

00:54:27,593 --> 00:54:28,926
But it's doable.

00:54:31,753 --> 00:54:34,278
Fixing that fairness.

00:54:34,278 --> 00:54:35,167
- [Song] But in this case,

00:54:35,167 --> 00:54:38,667
we reduced that need to reduce unfairness.

00:54:39,503 --> 00:54:40,942
- I mean...

00:54:40,942 --> 00:54:43,022
- [Song] It's like, different problems I think.

00:54:43,022 --> 00:54:44,482
- Yeah but you, you brought it up,

00:54:44,482 --> 00:54:46,986
so I'm saying this is fixable.

00:54:46,986 --> 00:54:48,569
- [Song] Mhmm, yep.

00:54:49,566 --> 00:54:50,566
So let's do.

00:54:51,841 --> 00:54:55,174
So what we're doing with the share PMU's

00:54:56,215 --> 00:54:59,131
so if we think multiple perf events

00:54:59,131 --> 00:55:02,580
that compatible, so technically they can share

00:55:02,580 --> 00:55:04,053
one hardware counter.

00:55:04,053 --> 00:55:05,937
And for here, I have

00:55:05,937 --> 00:55:08,162
a very conservative definition of compatible,

00:55:08,162 --> 00:55:10,791
I mean they count exactly the same thing.

00:55:10,791 --> 00:55:14,435
And I think in the future, we can extend that

00:55:14,435 --> 00:55:18,458
to have a sample event and a counting event

00:55:18,458 --> 00:55:22,749
share the hardware counter, it's totally possible.

00:55:22,749 --> 00:55:25,731
But for now I think just the share

00:55:25,731 --> 00:55:27,122
for only the counting ones,

00:55:27,122 --> 00:55:29,519
will be a big win already.

00:55:29,519 --> 00:55:31,352
So what's the benefit?

00:55:32,420 --> 00:55:35,525
The first is gonna be like we're gonna avoid

00:55:35,525 --> 00:55:38,855
or at least reduce, the time multiplexing.

00:55:38,855 --> 00:55:42,245
So instead, so if we go back to this example,

00:55:42,245 --> 00:55:44,275
these two are gonna share the same counter

00:55:44,275 --> 00:55:47,404
there won't be any time multiplexing at all.

00:55:47,404 --> 00:55:50,154
And again, like if we share them,

00:55:52,915 --> 00:55:54,831
and say we have two cycles.

00:55:54,831 --> 00:55:57,853
We're gonna do like time multiplexing

00:55:57,853 --> 00:56:00,773
but we need to program the hardware counters twice

00:56:00,773 --> 00:56:02,784
that also spends time.

00:56:02,784 --> 00:56:04,646
In this case, if we have the sharing,

00:56:04,646 --> 00:56:06,162
they're gonna share the same counter

00:56:06,162 --> 00:56:08,045
we leave the other counter idle,

00:56:08,045 --> 00:56:12,378
which also saves us cycles in programming the PMU's.

00:56:17,599 --> 00:56:18,432
- Mic?

00:56:18,432 --> 00:56:20,168
- Microphone there.

00:56:20,168 --> 00:56:21,713
- I got one right here, ready?

00:56:21,713 --> 00:56:22,546
- Okay.

00:56:23,828 --> 00:56:27,692
Could you please give us some examples of these?

00:56:27,692 --> 00:56:29,909
- [Host] Watch the speaker, it's right there.

00:56:29,909 --> 00:56:31,721
- Hi speaker.

00:56:31,721 --> 00:56:32,857
- Just back a bit, yep.

00:56:32,857 --> 00:56:34,955
- Could you please give us some examples

00:56:34,955 --> 00:56:37,288
of compatible perf counters,

00:56:38,166 --> 00:56:42,667
I mean, you can have like cache misses, cache coherency,

00:56:42,667 --> 00:56:43,845
whatever, whatever,

00:56:43,845 --> 00:56:47,607
so it helps if you give a little more context here.

00:56:47,607 --> 00:56:51,293
- So it's pretty much compatible right now,

00:56:51,293 --> 00:56:53,538
I have it being identical.

00:56:53,538 --> 00:56:55,731
Your counting exactly the same thing.

00:56:55,731 --> 00:56:59,128
The two perf events, say if you have,

00:56:59,128 --> 00:57:04,045
one for CPU event, and one attached to your per task event,

00:57:05,507 --> 00:57:06,424
and this...

00:57:08,245 --> 00:57:09,759
Oh, this might not be good example.

00:57:09,759 --> 00:57:11,196
But like they're all counting

00:57:11,196 --> 00:57:12,743
the same exactly the same thing.

00:57:12,743 --> 00:57:14,716
They're gonna share the same counters.

00:57:14,716 --> 00:57:17,299
So it's compatible meaning like

00:57:18,343 --> 00:57:20,161
they're counting the same matches

00:57:20,161 --> 00:57:23,803
from hardware point of view, that's identical.

00:57:23,803 --> 00:57:27,608
- So what is different in the two events then?

00:57:27,608 --> 00:57:28,872
Is it the process?

00:57:28,872 --> 00:57:31,219
- [David] It's the scope, so in this example,

00:57:31,219 --> 00:57:34,703
you open one per CPU, one per task, and one per cgroup.

00:57:34,703 --> 00:57:35,590
- Okay.

00:57:35,590 --> 00:57:36,481
- [David] You will use

00:57:36,481 --> 00:57:37,868
three different counters in the hardware.

00:57:37,868 --> 00:57:38,736
- Okay.

00:57:38,736 --> 00:57:39,996
- [David] One for each one of these scopes.

00:57:39,996 --> 00:57:41,132
- Okay got it.

00:57:41,132 --> 00:57:44,614
- And also sometimes if you have multiple application

00:57:44,614 --> 00:57:47,178
trying to monitor the same thing.

00:57:47,178 --> 00:57:49,687
You could have two per CPU events

00:57:49,687 --> 00:57:51,125
doing exactly the same thing.

00:57:51,125 --> 00:57:54,168
And the perf code, will treat it

00:57:54,168 --> 00:57:57,312
as totally separate perf events.

00:57:57,312 --> 00:57:58,929
- [Woman] Thank you.

00:57:58,929 --> 00:58:01,045
Okay, I'll hold the mic for the back of the room.

00:58:01,045 --> 00:58:02,396
(laughing)

00:58:02,396 --> 00:58:03,229
- Thanks.

00:58:06,414 --> 00:58:08,997
So, we have two proposals here.

00:58:10,799 --> 00:58:14,466
One is we implement in the perf core code.

00:58:14,466 --> 00:58:17,078
So basically, I think we should show this one first.

00:58:17,078 --> 00:58:22,076
So basically, we have this concept of perf event context

00:58:22,076 --> 00:58:24,920
which we hold a bunch of, like,

00:58:24,920 --> 00:58:26,911
a bunch of perf events.

00:58:26,911 --> 00:58:31,661
And well basically each CPU has two contexts at any time.

00:58:33,038 --> 00:58:35,766
It's the CPU context and then one comes with your task.

00:58:35,766 --> 00:58:37,355
It's the task context.

00:58:37,355 --> 00:58:40,100
So we want to introduce this thing,

00:58:40,100 --> 00:58:42,517
is the perf event deduplicate

00:58:43,879 --> 00:58:47,008
which you have different, multiple perf events

00:58:47,008 --> 00:58:49,499
pointing to this deduplicate.

00:58:49,499 --> 00:58:51,577
And this one goes to a master event,

00:58:51,577 --> 00:58:55,518
which is the real event we're going to schedule.

00:58:55,518 --> 00:58:57,469
So if you want to enable both of them,

00:58:57,469 --> 00:58:59,948
it's actually enable that master event

00:58:59,948 --> 00:59:01,692
and you adjust the countings

00:59:01,692 --> 00:59:04,319
into both events at the same time.

00:59:04,319 --> 00:59:08,152
So what's the benefit is it's in the core code

00:59:09,112 --> 00:59:11,877
so we pretty much do it once

00:59:11,877 --> 00:59:14,617
and all the perf events get the same benefit.

00:59:14,617 --> 00:59:17,367
And we also optimizes things too,

00:59:19,005 --> 00:59:22,338
we will be able to detect the perf event

00:59:23,417 --> 00:59:24,979
when you open or close,

00:59:24,979 --> 00:59:27,896
it will detect the compatible event

00:59:29,553 --> 00:59:31,559
when we open the new event.

00:59:31,559 --> 00:59:35,746
So we are not doing any comparison of different events

00:59:35,746 --> 00:59:39,322
at a context switch of the rotation.

00:59:39,322 --> 00:59:43,061
Which means that we try to only put as the overhead

00:59:43,061 --> 00:59:44,646
in the non-critical parts.

00:59:44,646 --> 00:59:48,245
The critical parts is equally expensive or cheaper

00:59:48,245 --> 00:59:51,740
if we consider it a benefit of programming less

00:59:51,740 --> 00:59:53,568
and less rotations.

00:59:53,568 --> 00:59:56,752
And right now, there's a problem with it,

00:59:56,752 --> 01:00:00,002
it's like because we need this context.

01:00:01,776 --> 01:00:05,921
We only do the sharing within this context.

01:00:05,921 --> 01:00:09,375
So if your perf event, and your CPU context,

01:00:09,375 --> 01:00:12,603
and your task context will not be able to share

01:00:12,603 --> 01:00:14,170
the performance counter.

01:00:14,170 --> 01:00:18,681
Which is a, which may or may not be a problem,

01:00:18,681 --> 01:00:20,681
depends on the use case.

01:00:22,396 --> 01:00:24,532
So that's the problem.

01:00:24,532 --> 01:00:26,198
Oh sorry.

01:00:26,198 --> 01:00:28,532
So that's one of the problems.

01:00:28,532 --> 01:00:30,888
The second problem is we have this new

01:00:30,888 --> 01:00:33,594
data structure that's a little more complex.

01:00:33,594 --> 01:00:37,129
But I feel that I have fixed all the bugs.

01:00:37,129 --> 01:00:39,706
I think it works great in my test.

01:00:39,706 --> 01:00:42,429
So hopefully it's not a problem in implementation

01:00:42,429 --> 01:00:46,167
but the complexity going to be a problem

01:00:46,167 --> 01:00:48,665
for future maintenance.

01:00:48,665 --> 01:00:51,636
Which means Peter's problem, not my problem.

01:00:51,636 --> 01:00:54,219
(all laughing)

01:00:57,987 --> 01:01:00,996
So the other proposal is like a while back

01:01:00,996 --> 01:01:05,996
Jiri Olsa proposed and also varied the ICOSE ladder

01:01:06,133 --> 01:01:08,241
proposal is like we just do that

01:01:08,241 --> 01:01:13,038
for each architecture for each PMU in that code.

01:01:13,038 --> 01:01:15,371
And we have this the benefit

01:01:17,164 --> 01:01:19,728
and the pros and cons are just reversed.

01:01:19,728 --> 01:01:22,834
In this case, because there's no context concept,

01:01:22,834 --> 01:01:26,584
so we can share a CPU event and a task event.

01:01:28,227 --> 01:01:30,577
And of course the problem with this

01:01:30,577 --> 01:01:33,544
because there's no context concept,

01:01:33,544 --> 01:01:36,877
so we do the, after the context reached,

01:01:37,787 --> 01:01:39,775
you have to compare again,

01:01:39,775 --> 01:01:41,549
which means you pretty much

01:01:41,549 --> 01:01:45,752
whenever you program your hardware counters,

01:01:45,752 --> 01:01:47,476
you will need to look at

01:01:47,476 --> 01:01:50,018
whether these two events are compatible.

01:01:50,018 --> 01:01:53,739
So it looks like something when you do the PMU add,

01:01:53,739 --> 01:01:56,503
you try oh I'll have this event,

01:01:56,503 --> 01:01:58,412
and whether it's compatible,

01:01:58,412 --> 01:02:01,152
if it's compatible we set up the compatible events,

01:02:01,152 --> 01:02:04,322
otherwise we do the existing code

01:02:04,322 --> 01:02:07,288
to find the new hardware counter for it.

01:02:07,288 --> 01:02:08,121
So.

01:02:11,208 --> 01:02:13,180
- Now hold on, I've got a question here.

01:02:13,180 --> 01:02:14,763
So if you're gonna.

01:02:15,781 --> 01:02:17,751
- [Song] Yeah.

01:02:17,751 --> 01:02:20,584
- So if you're gonna do a PMU add,

01:02:24,982 --> 01:02:27,574
which is the boundary of the interface,

01:02:27,574 --> 01:02:30,360
you might as well then pull it into the core code.

01:02:30,360 --> 01:02:32,325
And I mean, if you're gonna change old PMU adds

01:02:32,325 --> 01:02:34,058
to do this same thing,

01:02:34,058 --> 01:02:37,024
you might as well just pull it across the layer again.

01:02:37,024 --> 01:02:39,987
And I think you've proposed doing something else

01:02:39,987 --> 01:02:42,550
like that as well at some point.

01:02:42,550 --> 01:02:43,972
I forgot.

01:02:43,972 --> 01:02:47,260
So instead of doing it inside the add,

01:02:47,260 --> 01:02:49,540
do it outside in the core code.

01:02:49,540 --> 01:02:54,040
The tricky bit is of course to find compatible events.

01:03:01,863 --> 01:03:06,113
Especially if you do a schedule of a counter group,

01:03:10,060 --> 01:03:13,816
you will not actually do the scheduling

01:03:13,816 --> 01:03:17,007
until the last event when the transaction closes,

01:03:17,007 --> 01:03:19,366
that's when you do scheduleability analysis.

01:03:19,366 --> 01:03:22,783
And then try and assign all these things.

01:03:29,770 --> 01:03:31,880
I don't know, I'd have to think about it,

01:03:31,880 --> 01:03:33,971
but if you do it in PMU add,

01:03:33,971 --> 01:03:36,897
you might as well do it one layer above.

01:03:36,897 --> 01:03:38,603
In the core code, I think.

01:03:38,603 --> 01:03:41,270
- Yeah, I think that also works.

01:03:43,763 --> 01:03:47,464
Actually, the difference is whether we have this context,

01:03:47,464 --> 01:03:50,126
we take the context concept inside.

01:03:50,126 --> 01:03:53,518
So basically, if you look at these pros and the cons

01:03:53,518 --> 01:03:55,186
for the two proposal is just reversed.

01:03:55,186 --> 01:03:59,879
It's like if you want to detect a compatible events,

01:03:59,879 --> 01:04:03,780
if we want, we do not want to do this

01:04:03,780 --> 01:04:06,218
at a context switch and rotation.

01:04:06,218 --> 01:04:09,468
We're limited to within the CPU context

01:04:11,416 --> 01:04:13,083
or the task context.

01:04:14,490 --> 01:04:17,823
Otherwise if we wanted to do the primer,

01:04:20,707 --> 01:04:22,454
we cannot get both.

01:04:22,454 --> 01:04:23,650
- Yeah, but the devil is in the details.

01:04:23,650 --> 01:04:25,682
That find compatible event function,

01:04:25,682 --> 01:04:27,550
that one's gonna be tricky

01:04:27,550 --> 01:04:31,217
- Can those be just identical confirmations?

01:04:32,932 --> 01:04:36,515
- Well sure but, you still have to find it,

01:04:37,400 --> 01:04:39,759
and preferably quickly.

01:04:39,759 --> 01:04:41,936
If you can just do a linear search,

01:04:41,936 --> 01:04:43,269
that might work.

01:04:45,976 --> 01:04:49,494
- Is the architecture found, where's the other mic?

01:04:49,494 --> 01:04:51,462
- The other mic is in the back.

01:04:51,462 --> 01:04:54,962
- No it's just a performance thing mostly.

01:04:58,859 --> 01:05:03,478
I want to not spend too much time on trying to figure out

01:05:03,478 --> 01:05:04,811
who shares what.

01:05:05,794 --> 01:05:08,534
- And that's why Song's proposal number one,

01:05:08,534 --> 01:05:10,340
isn't in context switch time,

01:05:10,340 --> 01:05:12,337
it's at load of end time.

01:05:12,337 --> 01:05:13,572
- Correct.

01:05:13,572 --> 01:05:14,751
- Yep, so that's, so.

01:05:14,751 --> 01:05:16,923
- And the downside is you do not share

01:05:16,923 --> 01:05:20,359
between CPU counters and task counters.

01:05:20,359 --> 01:05:22,391
So there was another proposal,

01:05:22,391 --> 01:05:24,224
a few weeks ago maybe,

01:05:25,822 --> 01:05:29,072
that tagged all events with a cgroup ID

01:05:30,287 --> 01:05:33,258
because a few slides back you had,

01:05:33,258 --> 01:05:36,591
here would indifference, nested cgroups,

01:05:37,887 --> 01:05:40,607
that one would go away, you'd just have the one CPU counter,

01:05:40,607 --> 01:05:44,190
but then each event would have a cgroup ID.

01:05:46,749 --> 01:05:47,999
So you could...

01:05:49,512 --> 01:05:51,393
- Okay, I see that's gonna work,

01:05:51,393 --> 01:05:52,893
that's gonna work.

01:05:53,778 --> 01:05:55,861
So you have cgroup, well,

01:05:57,679 --> 01:05:59,490
so that's still the same problem right?

01:05:59,490 --> 01:06:02,660
If you have a parent cgroup, and the children cgroup,

01:06:02,660 --> 01:06:04,222
you're gonna have to do both,

01:06:04,222 --> 01:06:06,944
you're gonna enable both at the same time.

01:06:06,944 --> 01:06:09,974
- So the samples would have the most specific cgroup

01:06:09,974 --> 01:06:11,902
in them, I think, and then the software,

01:06:11,902 --> 01:06:14,932
one you read them, you can then propagate up the hierarchy.

01:06:14,932 --> 01:06:15,765
- Oh.

01:06:16,859 --> 01:06:18,723
That's nice, I didn't know that.

01:06:18,723 --> 01:06:20,958
So you're gonna, the cgroup code

01:06:20,958 --> 01:06:23,726
is gonna aggregate the values, that's...

01:06:23,726 --> 01:06:25,944
- Well user space will have to do that.

01:06:25,944 --> 01:06:26,777
- Oh.

01:06:28,156 --> 01:06:29,938
- We've had performance problems

01:06:29,938 --> 01:06:31,186
propagating up the hierarchy.

01:06:31,186 --> 01:06:33,154
- I am aware, yes.

01:06:33,154 --> 01:06:34,737
- Yay, for secrets.

01:06:36,973 --> 01:06:38,223
It's a feature.

01:06:42,083 --> 01:06:44,733
- So the proposal will be one event for CPU,

01:06:44,733 --> 01:06:47,819
one for cgroup, and one for task.

01:06:47,819 --> 01:06:52,819
- So it would maybe help with the burnouts to cgroup issue.

01:06:53,539 --> 01:06:56,705
So then the per CPU samples can be tagged

01:06:56,705 --> 01:06:58,429
with a cgroup ID,

01:06:58,429 --> 01:07:01,459
so you know which cgroup originated the sample

01:07:01,459 --> 01:07:05,459
and then you can reconstruct everything in post.

01:07:07,142 --> 01:07:08,512
Sorta, kinda, maybe.

01:07:08,512 --> 01:07:10,929
(whispering)

01:07:13,202 --> 01:07:15,925
- What happens if some cgroups don't have events?

01:07:15,925 --> 01:07:17,842
- Then they will not...

01:07:19,623 --> 01:07:21,553
- Okay, but then the CPU event

01:07:21,553 --> 01:07:24,720
must be measured independently, right?

01:07:27,889 --> 01:07:29,129
- Um, what?

01:07:29,129 --> 01:07:31,204
- Because if you don't have an event

01:07:31,204 --> 01:07:32,829
for all the cgroups that are running?

01:07:32,829 --> 01:07:35,018
- Oh no, no, so you,

01:07:35,018 --> 01:07:38,110
it's just the regular CPU wide event,

01:07:38,110 --> 01:07:39,534
it will count everything,

01:07:39,534 --> 01:07:42,155
it's just that the samples that generate,

01:07:42,155 --> 01:07:44,108
so this is a sampling event,

01:07:44,108 --> 01:07:47,945
every sample will have a cgroup tag on,

01:07:47,945 --> 01:07:52,212
what most specific cgroup does this process run in.

01:07:52,212 --> 01:07:54,975
And then, both can reconstruct

01:07:54,975 --> 01:07:58,740
the hierarchy, the cgroup hierarchy, if it wants to.

01:07:58,740 --> 01:08:01,477
- Okay, but then you have to pay that context switch cost

01:08:01,477 --> 01:08:04,631
even if you don't want one for the cgroup.

01:08:04,631 --> 01:08:06,724
- Oh, no, there is no context switch cost.

01:08:06,724 --> 01:08:10,377
It's just a regular per CPU event.

01:08:10,377 --> 01:08:12,639
It doesn't get scheduled when cgroups change.

01:08:12,639 --> 01:08:16,151
It's just that every time it generates the sample,

01:08:16,151 --> 01:08:20,318
it also outputs the cgroup ID of the current task.

01:08:22,957 --> 01:08:26,624
- Okay, it doesn't have to read the counter?

01:08:27,976 --> 01:08:30,310
- Well, yes, it will have to read the counter.

01:08:30,310 --> 01:08:32,649
But, I mean, it does everything

01:08:32,649 --> 01:08:34,295
that the normal sample already does

01:08:34,295 --> 01:08:38,605
all it does is adds the ability to output the cgroup ID.

01:08:38,605 --> 01:08:43,438
So then at post time, you can reconstruct the cgroup data.

01:08:48,154 --> 01:08:50,061
- I just wondered if there's some deployment

01:08:50,061 --> 01:08:54,575
where the user don't want to handle the cgroup speed monitor

01:08:54,575 --> 01:08:58,330
to reduce the context switch and overhead.

01:08:58,330 --> 01:09:02,330
In that case, you would pay even if you only had

01:09:03,288 --> 01:09:06,335
some of the cgroups with events.

01:09:06,335 --> 01:09:08,918
- So there is also patches that

01:09:11,526 --> 01:09:15,008
make scheduling many of the cgroup counters cheaper.

01:09:15,008 --> 01:09:17,425
But that's a different thing.

01:09:27,801 --> 01:09:29,149
- [Host] You have one more minute

01:09:29,149 --> 01:09:30,973
so it's up to you if you wanna give it up or...

01:09:30,973 --> 01:09:33,863
- I think that that's very good suggestions

01:09:33,863 --> 01:09:37,369
and some we can continue to discussion.

01:09:37,369 --> 01:09:39,836
- Peter, I'm gonna probably pick your brain later

01:09:39,836 --> 01:09:41,340
about to add more notes.

01:09:41,340 --> 01:09:42,861
- [Peter] Sure.

01:09:42,861 --> 01:09:44,712
- Okay, thank you.

01:09:44,712 --> 01:09:47,879
(audience applauding)

01:09:49,691 --> 01:09:52,774
(all sound cuts out)

01:11:49,281 --> 01:11:51,531
- Now I do have it on here.

01:11:55,802 --> 01:11:56,969
- Okay, hello,

01:11:58,010 --> 01:11:59,945
hello my name is Tavetomir Stoyanov

01:11:59,945 --> 01:12:04,112
and I'm part of the Open Source Center of VM ware.

01:12:05,088 --> 01:12:07,120
Today I would like to discuss with you

01:12:07,120 --> 01:12:09,982
the ftrace histograms and in particular

01:12:09,982 --> 01:12:12,257
the way they are configured

01:12:12,257 --> 01:12:15,183
and to think about a solution

01:12:15,183 --> 01:12:18,335
to how to simplify this compilation

01:12:18,335 --> 01:12:21,301
and to make it more useful.

01:12:21,301 --> 01:12:26,301
I guess that most of you are familiar with ftrace histograms

01:12:26,317 --> 01:12:30,322
so I'm going to focus on the histograms itself,

01:12:30,322 --> 01:12:33,248
but only in their configuration.

01:12:33,248 --> 01:12:34,427
- Actually, can I real quick,

01:12:34,427 --> 01:12:37,349
how many people are familiar of the Linux histogram code

01:12:37,349 --> 01:12:38,516
that's inside?

01:12:39,384 --> 01:12:40,581
How many people are not familiar

01:12:40,581 --> 01:12:42,472
with the Linux histogram code within,

01:12:42,472 --> 01:12:44,135
so there's a lot of people that are not familiar

01:12:44,135 --> 01:12:45,556
with the Linux histogram code.

01:12:45,556 --> 01:12:46,669
- [Audience Member] I have not read the actual code,

01:12:46,669 --> 01:12:47,502
does that count?

01:12:47,502 --> 01:12:50,179
- No, no, not reading, just knowing that it at least exists.

01:12:50,179 --> 01:12:54,389
- Oh I'm going to describe shortly histogram idea.

01:12:54,389 --> 01:12:58,228
The histograms were implemented by Tom Zanussi,

01:12:58,228 --> 01:13:01,219
in the first center using the Linux kernel a few years ago.

01:13:01,219 --> 01:13:03,738
It's a very powerful feature,

01:13:03,738 --> 01:13:06,867
but the main throwback is that it is configured,

01:13:06,867 --> 01:13:11,436
it is a very hard, he has very complex configuration.

01:13:11,436 --> 01:13:13,711
Especially in the case when you want

01:13:13,711 --> 01:13:15,987
to do something more interesting.

01:13:15,987 --> 01:13:19,545
I'm going to show you a few examples so far

01:13:19,545 --> 01:13:21,657
of configuration of histograms.

01:13:21,657 --> 01:13:24,719
This is the very basic histogram configuration.

01:13:24,719 --> 01:13:27,690
You get to ride this magic string

01:13:27,690 --> 01:13:32,605
into the dear configuration of these architecture event.

01:13:32,605 --> 01:13:35,207
Here in this example, we are interested

01:13:35,207 --> 01:13:38,359
in the application of page fault application,

01:13:38,359 --> 01:13:41,140
that's why the key in our histogram

01:13:41,140 --> 01:13:43,758
is the application name.

01:13:43,758 --> 01:13:45,546
Under pages that are accumulated,

01:13:45,546 --> 01:13:47,843
and page fault hits.

01:13:47,843 --> 01:13:51,234
This is how our histogram works.

01:13:51,234 --> 01:13:54,240
Like in the list size of the names of the applications

01:13:54,240 --> 01:13:58,694
on the right side of the accumulated page fault hits.

01:13:58,694 --> 01:14:00,762
- I just wanted, real quick,

01:14:00,762 --> 01:14:03,709
just to let you know if in that very first line there

01:14:03,709 --> 01:14:07,036
it's assumed that you're already in the trace FS directory,

01:14:07,036 --> 01:14:09,804
so slash sys, slash kernel, slash tracing,

01:14:09,804 --> 01:14:11,042
or debug slash tracing.

01:14:11,042 --> 01:14:11,875
Yeah.

01:14:11,875 --> 01:14:13,769
- Yeah, I didn't 'cause the kernel is too big.

01:14:13,769 --> 01:14:15,859
(audience chuckling)

01:14:15,859 --> 01:14:17,484
- Yeah.

01:14:17,484 --> 01:14:21,942
- This is the basic example of the more interesting things

01:14:21,942 --> 01:14:24,056
when you want to measure

01:14:24,056 --> 01:14:26,802
the latency between two trace events.

01:14:26,802 --> 01:14:30,801
In this example, the first event is sys enter send message,

01:14:30,801 --> 01:14:33,718
and the second is sys exit send message.

01:14:33,718 --> 01:14:36,094
Okay, in order to do that,

01:14:36,094 --> 01:14:39,778
we need to configure the synthetic event.

01:14:39,778 --> 01:14:42,662
Which is called send latence here.

01:14:42,662 --> 01:14:44,799
And to accumulate the histogram,

01:14:44,799 --> 01:14:46,911
the context of this synthetic event.

01:14:46,911 --> 01:14:50,911
How this configuration looks like, it's complex.

01:14:53,025 --> 01:14:55,440
First we need to define the synthetic event

01:14:55,440 --> 01:14:58,954
by defining each line of send latency

01:14:58,954 --> 01:15:01,371
and these parameters for PID.

01:15:02,231 --> 01:15:06,314
Then we have to define a tier in the first event,

01:15:08,301 --> 01:15:10,235
this enter send message.

01:15:10,235 --> 01:15:15,235
And that, here, we have to save the time stamp of this event

01:15:16,715 --> 01:15:18,215
into what is zero.

01:15:20,619 --> 01:15:23,156
There's a third one, is the most interesting one.

01:15:23,156 --> 01:15:26,325
We have to define the histogram

01:15:26,325 --> 01:15:30,408
into the sys exit send message, the second event.

01:15:31,657 --> 01:15:35,436
And this histogram, we are interested

01:15:35,436 --> 01:15:37,323
in a much, doing both events,

01:15:37,323 --> 01:15:40,779
this center send message, and exit send message,

01:15:40,779 --> 01:15:44,703
which means that the keys of both histograms

01:15:44,703 --> 01:15:46,170
must be equal.

01:15:46,170 --> 01:15:49,014
So the count PID of the first event,

01:15:49,014 --> 01:15:52,305
should be equal to the count PID of the second event

01:15:52,305 --> 01:15:55,532
and in this case we have a match, in case of match,

01:15:55,532 --> 01:15:58,946
we take the send latency synthetic event.

01:15:58,946 --> 01:16:03,358
With that is a parentheses, a latent count PID.

01:16:03,358 --> 01:16:05,531
Here, the liderato

01:16:05,531 --> 01:16:07,054
is calculated by subtracting

01:16:07,054 --> 01:16:09,524
both time stamps from both events.

01:16:09,524 --> 01:16:13,568
And the last one is the configuration of the histogram

01:16:13,568 --> 01:16:17,108
itself that we are interested in.

01:16:17,108 --> 01:16:21,197
It is in the contextual send latency synthetic events

01:16:21,197 --> 01:16:23,763
previously defined synthetic events.

01:16:23,763 --> 01:16:28,517
And this is how our histogram looks like in this case.

01:16:28,517 --> 01:16:30,647
That's sort of in the first one.

01:16:30,647 --> 01:16:34,230
The third example is the even more complex,

01:16:36,644 --> 01:16:40,155
know that we're not limited to measure latency

01:16:40,155 --> 01:16:42,089
between only two events.

01:16:42,089 --> 01:16:44,283
We can measure latency between multiple events.

01:16:44,283 --> 01:16:47,950
The only limitations here is that we have to

01:16:48,950 --> 01:16:52,387
the both events that we are matching

01:16:52,387 --> 01:16:56,591
must have some common things that are matchable.

01:16:56,591 --> 01:17:01,508
But, in example, there is no common feud between two events

01:17:02,813 --> 01:17:06,487
but we still want to measure the latency between them.

01:17:06,487 --> 01:17:11,160
We can do it using this artificial synthetic events.

01:17:11,160 --> 01:17:14,612
In this example, we're going to measure the latency

01:17:14,612 --> 01:17:18,782
between HR time of stopped event and scheduled event.

01:17:18,782 --> 01:17:21,865
There is no common feud between them,

01:17:23,717 --> 01:17:25,284
that we can use for matching,

01:17:25,284 --> 01:17:30,034
that's why we have to define the latency synthetic event,

01:17:31,356 --> 01:17:34,606
to accumulate the histogram data event,

01:17:36,154 --> 01:17:39,188
so between hrtimer and sched_waking,

01:17:39,188 --> 01:17:42,901
and the second synthetic event wake up latency

01:17:42,901 --> 01:17:45,068
that we match that irq_lat

01:17:47,326 --> 01:17:51,706
synthetic event with the result, sched_switch.

01:17:51,706 --> 01:17:53,956
How this graphic looks like

01:17:55,644 --> 01:17:59,864
much more complex, but the idea is the same

01:17:59,864 --> 01:18:02,180
with the previous one,

01:18:02,180 --> 01:18:04,800
but the configuration is bigger.

01:18:04,800 --> 01:18:07,486
We have to define the both synthetic events

01:18:07,486 --> 01:18:11,903
irq lat and wake lat with their following latent PID.

01:18:13,622 --> 01:18:17,906
And after that we will find the histograms

01:18:17,906 --> 01:18:22,156
in the hr timer, schedule waking, calculate latency

01:18:24,831 --> 01:18:27,275
and it always ends up interesting.

01:18:27,275 --> 01:18:30,607
We can chain here as much events as we wish,

01:18:30,607 --> 01:18:32,524
there is no limitation.

01:18:33,817 --> 01:18:36,984
Biggest problem that we are configure,

01:18:38,165 --> 01:18:41,665
circulated in the wake lat synthetic event

01:18:43,646 --> 01:18:45,563
and it looks like that.

01:18:46,536 --> 01:18:50,314
So, what is the goal with this discussion?

01:18:50,314 --> 01:18:53,314
Somehow to design a simple interface

01:18:54,568 --> 01:18:57,873
to describe in more user friendly way

01:18:57,873 --> 01:19:00,290
this histogram configuration.

01:19:01,424 --> 01:19:03,782
And the idea is to use trace implication,

01:19:03,782 --> 01:19:07,828
to configure the actual equal synthetic events

01:19:07,828 --> 01:19:09,796
histograms in the events.

01:19:09,796 --> 01:19:13,982
And to feature the tracing with some simple

01:19:13,982 --> 01:19:16,822
simple thing that describes that.

01:19:16,822 --> 01:19:19,322
And the best case, this syntax

01:19:20,321 --> 01:19:22,799
should cover all histogram operations

01:19:22,799 --> 01:19:26,454
or at least the most commonly used cases.

01:19:26,454 --> 01:19:28,468
It should be as simple as possible.

01:19:28,468 --> 01:19:33,218
We discussed this issue on the audio time tracing seminar

01:19:34,340 --> 01:19:37,757
this year with Steve Arodid, Tom Zanussi,

01:19:39,054 --> 01:19:41,867
and Lucas, Lucas Brewhan, I think.

01:19:41,867 --> 01:19:46,700
And Lucas came up with the solution to use SQL-like syntax

01:19:48,960 --> 01:19:52,722
interface to describe interrelations between those events.

01:19:52,722 --> 01:19:56,338
We can think of events as SQL tables

01:19:56,338 --> 01:19:59,142
and event fields as SQL columns.

01:19:59,142 --> 01:20:01,725
And to use this SQL-like syntax

01:20:03,531 --> 01:20:05,698
to describe our histogram.

01:20:06,771 --> 01:20:08,438
The idea is first to

01:20:11,930 --> 01:20:13,376
to define the histogram,

01:20:13,376 --> 01:20:15,936
then along with it's parameters,

01:20:15,936 --> 01:20:19,001
these are the values and the keys of the histogram.

01:20:19,001 --> 01:20:21,584
Then to define like SQL joints,

01:20:23,128 --> 01:20:26,693
the events that we are interested in.

01:20:26,693 --> 01:20:28,574
Start event, join, end event.

01:20:28,574 --> 01:20:30,822
So you can chain here, as much events as

01:20:30,822 --> 01:20:31,655
you want.

01:20:34,222 --> 01:20:35,661
And then to define what

01:20:35,661 --> 01:20:38,018
of the matching field between this event

01:20:38,018 --> 01:20:40,375
in order to have a match between them

01:20:40,375 --> 01:20:43,057
start event field equal to end event field.

01:20:43,057 --> 01:20:46,941
Unfortunately, we can define the conditions.

01:20:46,941 --> 01:20:49,338
Where are the conditions.

01:20:49,338 --> 01:20:50,255
So how this

01:20:53,848 --> 01:20:56,181
syntax maps to the examples.

01:21:00,598 --> 01:21:04,431
Before, here is the latency between two events

01:21:06,165 --> 01:21:10,053
we defined this selects syntax the send latency

01:21:10,053 --> 01:21:14,386
synthetic events with the two parameters latent PID.

01:21:16,084 --> 01:21:20,265
And here we define how this latency is calculated

01:21:20,265 --> 01:21:24,848
by subtracting the time stamps of the synthetic events.

01:21:26,643 --> 01:21:28,553
And the PID is just secured

01:21:28,553 --> 01:21:31,802
to the count PID of the second event.

01:21:31,802 --> 01:21:36,215
Then we define this from join, it's the statement

01:21:36,215 --> 01:21:40,033
both of sys calls, sys calls send message,

01:21:40,033 --> 01:21:42,490
and sys calls exit send message.

01:21:42,490 --> 01:21:45,490
And we define the matching criteria.

01:21:46,940 --> 01:21:48,623
- Yeah, yeah, I was about to say.

01:21:48,623 --> 01:21:50,902
Okay, you gotta question, I was gonna stop you here.

01:21:50,902 --> 01:21:52,690
Because I think this is a very important slide

01:21:52,690 --> 01:21:54,826
that we want to talk about, but yes.

01:21:54,826 --> 01:21:57,493
- Hello, yes so I was wondering,

01:21:58,443 --> 01:22:01,386
I just played around with BPF trace

01:22:01,386 --> 01:22:05,796
for a day, enough to go through some of the examples

01:22:05,796 --> 01:22:09,617
and I was struck by the fairly simple syntax

01:22:09,617 --> 01:22:11,544
of the language that it has in there

01:22:11,544 --> 01:22:15,242
which reduces this problem down to some very clear code.

01:22:15,242 --> 01:22:19,626
But I'm not clear, and I bet a bunch of other people

01:22:19,626 --> 01:22:22,028
aren't completely clear on what's common

01:22:22,028 --> 01:22:24,101
between BPF trace and this problem,

01:22:24,101 --> 01:22:26,314
and for example, why wouldn't I just

01:22:26,314 --> 01:22:28,813
run a little BPF trace program to solve this?

01:22:28,813 --> 01:22:30,422
- Very good question.

01:22:30,422 --> 01:22:33,999
- One thing is, yes BPF trace is awesome,

01:22:33,999 --> 01:22:35,273
it it's available.

01:22:35,273 --> 01:22:36,721
A lot of cases it's not.

01:22:36,721 --> 01:22:38,038
This is very very simple.

01:22:38,038 --> 01:22:39,741
One thing ftrace has always been doing,

01:22:39,741 --> 01:22:41,841
the only tool you really need is,

01:22:41,841 --> 01:22:43,588
well 'cause you could do everything here

01:22:43,588 --> 01:22:45,376
and also you could get the syntax out of it, if you want.

01:22:45,376 --> 01:22:49,091
The only tool you need to run ftrace is BusyBox.

01:22:49,091 --> 01:22:52,866
I mean, you just have it on embed devices,

01:22:52,866 --> 01:22:55,210
what not, you might wanna be doing this

01:22:55,210 --> 01:22:57,079
in lots of situations BPF is great, yes.

01:22:57,079 --> 01:23:00,208
People always say BPF can do everything

01:23:00,208 --> 01:23:02,117
ftrace can do basically, why do you have ftrace?

01:23:02,117 --> 01:23:03,801
I say, okay why do we have Bash

01:23:03,801 --> 01:23:05,975
when C could do everything that Bash can do?

01:23:05,975 --> 01:23:07,225
So, Bash grips.

01:23:08,962 --> 01:23:13,008
I always, my analogy is BPF is C ftrace is Bash.

01:23:13,008 --> 01:23:15,951
So when you wanna do something that's very simple,

01:23:15,951 --> 01:23:17,937
very common, it's quick,

01:23:17,937 --> 01:23:19,060
if you don't have BPF available

01:23:19,060 --> 01:23:20,527
it's right here, it's available.

01:23:20,527 --> 01:23:22,829
That's the reason why we have the two, make sense?

01:23:22,829 --> 01:23:23,922
- [Audience Member] Yeah.

01:23:23,922 --> 01:23:25,673
- Okay, but I wanna go back just to say,

01:23:25,673 --> 01:23:27,850
one reason why a lot of people haven't used the latency code

01:23:27,850 --> 01:23:29,532
it was actually something that's really been pushed

01:23:29,532 --> 01:23:30,997
by the real time.

01:23:30,997 --> 01:23:33,638
It's because of the complexity of the format.

01:23:33,638 --> 01:23:36,889
And yeah, down, well maybe it's not that,

01:23:36,889 --> 01:23:40,203
or maybe the bottom is still complex,

01:23:40,203 --> 01:23:42,006
but we're trying to make it into something

01:23:42,006 --> 01:23:43,779
that's a little bit more human readable

01:23:43,779 --> 01:23:46,275
even though SQL is not always the best thing.

01:23:46,275 --> 01:23:47,734
But it's something a lot of people know,

01:23:47,734 --> 01:23:49,752
even though like reluctantly know.

01:23:49,752 --> 01:23:54,629
I know SQL because I maintain my own database server

01:23:54,629 --> 01:23:56,538
for my mail server and stuff like that

01:23:56,538 --> 01:23:57,914
so I had to learn SQL,

01:23:57,914 --> 01:23:59,419
when Lucas mentioned it that

01:23:59,419 --> 01:24:02,593
say okay why don't we just, this is like tables in data,

01:24:02,593 --> 01:24:04,218
well you're right, you have a couple tables,

01:24:04,218 --> 01:24:05,902
if you could kinda use SQL format,

01:24:05,902 --> 01:24:08,015
we try to keep it as close to possible

01:24:08,015 --> 01:24:10,146
that things that will work by any SQL book

01:24:10,146 --> 01:24:12,467
we can kinda implement it this way.

01:24:12,467 --> 01:24:13,849
So the only little trick is here,

01:24:13,849 --> 01:24:16,490
down below, like we have a dash dash select,

01:24:16,490 --> 01:24:18,174
kind of like the select command,

01:24:18,174 --> 01:24:19,007
the only thing that's different

01:24:19,007 --> 01:24:20,836
is the very first send latency right there, that colon,

01:24:20,836 --> 01:24:22,725
that creates a synthetic event for you.

01:24:22,725 --> 01:24:24,820
So after you do this command on trace command,

01:24:24,820 --> 01:24:26,707
that actually will be a synthetic event

01:24:26,707 --> 01:24:29,023
that then you can actually enable tracing on.

01:24:29,023 --> 01:24:30,991
So you actually, it's more than just SQL,

01:24:30,991 --> 01:24:32,864
so it does do, we're trying to do

01:24:32,864 --> 01:24:34,631
everything you can do in ftrace,

01:24:34,631 --> 01:24:37,576
so yes we're just trying to say okay

01:24:37,576 --> 01:24:39,670
send latency lat, and then here you'll notice,

01:24:39,670 --> 01:24:42,307
it was the two time stamps here,

01:24:42,307 --> 01:24:44,650
and we could even probably make that into

01:24:44,650 --> 01:24:45,521
something easier to write,

01:24:45,521 --> 01:24:46,861
but we're just saying this minus this,

01:24:46,861 --> 01:24:48,569
I want the latency to be this minus this

01:24:48,569 --> 01:24:51,247
where up above you had to do this unmatch thing,

01:24:51,247 --> 01:24:54,054
and then you know, pass, create a variable

01:24:54,054 --> 01:24:55,906
to pass between the two,

01:24:55,906 --> 01:24:59,116
and the second one removes the access of,

01:24:59,116 --> 01:25:00,904
we don't show the variables,

01:25:00,904 --> 01:25:03,017
so you don't have to worry about variables to,

01:25:03,017 --> 01:25:05,920
the variable up on top you'll see the TSO zero up on top

01:25:05,920 --> 01:25:07,690
equals common time stamp?

01:25:07,690 --> 01:25:11,185
So when the send message triggers,

01:25:11,185 --> 01:25:14,546
that every time, every instance,

01:25:14,546 --> 01:25:18,302
will be the time stamp will be recorded in that TSO variable

01:25:18,302 --> 01:25:21,663
when we do the un-match in the second event,

01:25:21,663 --> 01:25:23,933
which is this exit send message,

01:25:23,933 --> 01:25:26,303
then we have that, when it has a match,

01:25:26,303 --> 01:25:28,565
it has that available for that guy

01:25:28,565 --> 01:25:30,492
and then you do the subtraction of it.

01:25:30,492 --> 01:25:32,443
That's kind of hard to remember, hard to write up,

01:25:32,443 --> 01:25:34,105
and knowing the command sequence.

01:25:34,105 --> 01:25:35,287
We're just trying to say,

01:25:35,287 --> 01:25:36,529
okay I want send latency,

01:25:36,529 --> 01:25:38,844
send message minus, from the,

01:25:38,844 --> 01:25:43,478
it's called send message from the exit to the enter.

01:25:43,478 --> 01:25:46,898
Oh yeah, the exit time stamp, minus the enter time stamp,

01:25:46,898 --> 01:25:48,737
will equal my latency, that's pretty easy.

01:25:48,737 --> 01:25:50,670
And yeah it's long variables, but it's really just,

01:25:50,670 --> 01:25:55,100
okay when it ended subtracted from when it started,

01:25:55,100 --> 01:25:56,092
there's my latency.

01:25:56,092 --> 01:25:58,043
So we're simplifying it,

01:25:58,043 --> 01:26:00,260
trace command will do all the heavy,

01:26:00,260 --> 01:26:02,304
and it will give an option to say

01:26:02,304 --> 01:26:04,417
here's the command you used when you cut and paste

01:26:04,417 --> 01:26:07,290
and put it on your BusyBox line, if you wanna use it there,

01:26:07,290 --> 01:26:08,956
does that make sense?

01:26:08,956 --> 01:26:10,764
Is anyone objectionable about

01:26:10,764 --> 01:26:12,636
using like this type of syntax?

01:26:12,636 --> 01:26:14,682
Oh yeah, Jahari.

01:26:14,682 --> 01:26:16,956
(audience laughing)

01:26:16,956 --> 01:26:19,034
- So kind of going back to what was said earlier,

01:26:19,034 --> 01:26:21,339
why not a syntax, you said BPF trace isn't everywhere,

01:26:21,339 --> 01:26:24,923
but what about a syntax that is like BPF trace,

01:26:24,923 --> 01:26:29,274
so that you have a common type of scripting language?

01:26:29,274 --> 01:26:31,357
- Yeah, so I second that,

01:26:32,606 --> 01:26:35,393
but I would also say, I have run into use cases

01:26:35,393 --> 01:26:37,274
for example OS Query,

01:26:37,274 --> 01:26:39,307
where people think in an SQL like syntax,

01:26:39,307 --> 01:26:42,031
and they would actually like to take BPF tracing

01:26:42,031 --> 01:26:43,424
and turn it into SQL

01:26:43,424 --> 01:26:45,078
which I find going the opposite direction.

01:26:45,078 --> 01:26:46,646
(audience laughing)

01:26:46,646 --> 01:26:47,824
- [Host] Exactly.

01:26:47,824 --> 01:26:51,317
- So I can imagine this, the primary uses of this may be

01:26:51,317 --> 01:26:53,919
turning this into an OS Query module,

01:26:53,919 --> 01:26:56,253
because they wanna use it.

01:26:56,253 --> 01:26:57,495
- What's Query?

01:26:57,495 --> 01:26:59,103
- Oh it's great, it's very popular,

01:26:59,103 --> 01:27:01,582
it's a monitoring agent, SQL-like syntax,

01:27:01,582 --> 01:27:03,550
who uses OS Query?

01:27:03,550 --> 01:27:06,620
Well I hear it's popular, I hear it's popular.

01:27:06,620 --> 01:27:07,916
(audience laughing)

01:27:07,916 --> 01:27:09,604
It may not be popular in this room.

01:27:09,604 --> 01:27:11,026
- Write down OS Query on the notes,

01:27:11,026 --> 01:27:12,588
I wanna look more into that.

01:27:12,588 --> 01:27:13,424
Yes.

01:27:13,424 --> 01:27:14,665
If you want it back.

01:27:14,665 --> 01:27:16,088
The reason why I'd also, like I said,

01:27:16,088 --> 01:27:17,714
BPF, I've looked at what we discussed

01:27:17,714 --> 01:27:19,582
is actually one of our first discussions

01:27:19,582 --> 01:27:20,721
at the real time summit,

01:27:20,721 --> 01:27:22,039
saying using the BPF syntax for this,

01:27:22,039 --> 01:27:24,175
and BPF is much more complex, and then we're like okay

01:27:24,175 --> 01:27:27,565
we have to really rip it down to limiting it.

01:27:27,565 --> 01:27:30,351
And then the more we talked about it,

01:27:30,351 --> 01:27:32,357
we kept coming up with a lot of issues

01:27:32,357 --> 01:27:34,699
like well, that people were gonna expect it

01:27:34,699 --> 01:27:36,121
to do more than it can do.

01:27:36,121 --> 01:27:37,823
And yes, it can do everything,

01:27:37,823 --> 01:27:39,616
and then we're trying to figure out

01:27:39,616 --> 01:27:42,623
and we couldn't come up with a good BPF limited subset

01:27:42,623 --> 01:27:44,428
and that's when someone said,

01:27:44,428 --> 01:27:45,809
you know it sounds like this is just a bunch

01:27:45,809 --> 01:27:47,354
of tables you're manipulating, why not use SQL?

01:27:47,354 --> 01:27:50,219
And 'cause it really is, it's just tables.

01:27:50,219 --> 01:27:52,555
That's where manipulating, we're not doing logic,

01:27:52,555 --> 01:27:54,773
I mean we're not doing the trigger and stuff like that

01:27:54,773 --> 01:27:55,606
that's something else.

01:27:55,606 --> 01:27:57,048
But this is just saying, we just want latencies.

01:27:57,048 --> 01:27:59,321
Or we want ways, we're doing histograms between events.

01:27:59,321 --> 01:28:02,801
That's all, and right now you can put multiple events

01:28:02,801 --> 01:28:04,281
follow the latency,

01:28:04,281 --> 01:28:06,760
'cause that's a very very common thing that people ask for.

01:28:06,760 --> 01:28:08,124
Right?

01:28:08,124 --> 01:28:09,970
- But I think there are two different audiences.

01:28:09,970 --> 01:28:11,634
Some will be happy with this,

01:28:11,634 --> 01:28:13,302
and then there is a different audience

01:28:13,302 --> 01:28:15,026
who wanna take the BPF trace syntax,

01:28:15,026 --> 01:28:17,708
and have it compiled to synthetic events.

01:28:17,708 --> 01:28:20,431
- So I think even within BPF,

01:28:20,431 --> 01:28:22,153
and Brendan knows this much better than I do,

01:28:22,153 --> 01:28:22,986
it's not one thing.

01:28:22,986 --> 01:28:26,295
Right, there's BPF trace, and then there's BPF utils,

01:28:26,295 --> 01:28:28,350
and you know, there's a lot of different ways

01:28:28,350 --> 01:28:29,691
to do the same thing with BPF.

01:28:29,691 --> 01:28:31,944
And I think this is another way to do something similar

01:28:31,944 --> 01:28:33,877
and so my bigger question is,

01:28:33,877 --> 01:28:35,794
like inside the kernel,

01:28:36,739 --> 01:28:38,564
can we be doing some of the same things

01:28:38,564 --> 01:28:40,988
to set up this generic idea of you know

01:28:40,988 --> 01:28:42,857
managing latency between events

01:28:42,857 --> 01:28:45,092
or you know, so I care more about like

01:28:45,092 --> 01:28:46,369
the kernel side consistency,

01:28:46,369 --> 01:28:49,559
instead of like, you know, a handful of utilities

01:28:49,559 --> 01:28:51,367
that end up triggering the same.

01:28:51,367 --> 01:28:53,503
- Actually, this would take place in the user space.

01:28:53,503 --> 01:28:58,176
The existing histogram configuration interface.

01:28:58,176 --> 01:29:00,447
It's only a wrapper.

01:29:00,447 --> 01:29:02,614
- Right, is this thing on?

01:29:03,947 --> 01:29:04,960
- Yep.

01:29:04,960 --> 01:29:07,546
- So our, I have a question,

01:29:07,546 --> 01:29:10,713
I think this one is a very good syntax

01:29:12,462 --> 01:29:16,129
but a bit, or the information is, let's see,

01:29:19,208 --> 01:29:21,041
it's a bit long, yeah.

01:29:22,540 --> 01:29:25,669
- We tried to make this short as possible,

01:29:25,669 --> 01:29:29,245
but we had some help to describe the populations of.

01:29:29,245 --> 01:29:31,965
- Yeah, but we can see the many sys exit send message,

01:29:31,965 --> 01:29:35,048
are many, you know, one of them are--

01:29:38,281 --> 01:29:39,810
- The way that we get information, you mean.

01:29:39,810 --> 01:29:41,476
- Yeah.

01:29:41,476 --> 01:29:43,143
- I need the mic on.

01:29:48,069 --> 01:29:51,025
Okay, yeah, I mean that's actually why

01:29:51,025 --> 01:29:52,487
we haven't implemented this yet.

01:29:52,487 --> 01:29:55,088
This is one of those things that you said.

01:29:55,088 --> 01:29:55,965
This is, we're just working on a syntax,

01:29:55,965 --> 01:29:57,202
we haven't even started the work

01:29:57,202 --> 01:29:58,421
on actually implementing this.

01:29:58,421 --> 01:30:00,412
We're just trying to see, we were basically

01:30:00,412 --> 01:30:01,857
just mapping things right now.

01:30:01,857 --> 01:30:03,750
If you have ways, ideas,

01:30:03,750 --> 01:30:05,511
this is why we're presenting this at Plumbers

01:30:05,511 --> 01:30:08,298
'cause we don't know where we're going yet.

01:30:08,298 --> 01:30:09,590
Yes we could change it to BPF,

01:30:09,590 --> 01:30:10,631
we haven't done anything,

01:30:10,631 --> 01:30:12,910
this is just the planning stages right now.

01:30:12,910 --> 01:30:15,290
So yes, we need help, I could make a BOF.

01:30:15,290 --> 01:30:17,055
Would people be interested in coming to a BOF

01:30:17,055 --> 01:30:18,744
to discuss this maybe?

01:30:18,744 --> 01:30:20,531
Or we could discuss it later?

01:30:20,531 --> 01:30:22,825
Okay, so, we'll set up a BOF, but--

01:30:22,825 --> 01:30:24,340
- [Audience Member] So Steve.

01:30:24,340 --> 01:30:28,173
- [Song] We will make a BOF about our tracing.

01:30:30,723 --> 01:30:31,822
- If there's a room available.

01:30:31,822 --> 01:30:32,716
- [Song] Okay.

01:30:32,716 --> 01:30:33,851
- Yeah, if there's a room available,

01:30:33,851 --> 01:30:35,381
I'll continue with a BOF yes.

01:30:35,381 --> 01:30:36,472
- I just wanna suggest that

01:30:36,472 --> 01:30:37,918
this might not be the right hands

01:30:37,918 --> 01:30:38,852
to help you define where the,

01:30:38,852 --> 01:30:40,247
because people who are familiar with SQL are often admins

01:30:40,247 --> 01:30:42,405
and people dealing with tables all the time anyway.

01:30:42,405 --> 01:30:43,502
I am not such a person,

01:30:43,502 --> 01:30:45,737
when I go look at Brendan Gregg's pages

01:30:45,737 --> 01:30:47,124
when I need to do perf stuff,

01:30:47,124 --> 01:30:48,262
right and stuff like that,

01:30:48,262 --> 01:30:49,603
so I don't memorize all these things

01:30:49,603 --> 01:30:50,917
and I don't memorize SQL syntax,

01:30:50,917 --> 01:30:53,359
and I don't have a preference for it particularly.

01:30:53,359 --> 01:30:54,618
I will use whatever works.

01:30:54,618 --> 01:30:57,405
And I think the admins who do regular SQL work,

01:30:57,405 --> 01:30:59,169
will probably love this.

01:30:59,169 --> 01:31:00,651
Right, it'll be much easier for them to use

01:31:00,651 --> 01:31:02,380
and figure out what's going on in the system.

01:31:02,380 --> 01:31:03,825
- Well and the things that work.

01:31:03,825 --> 01:31:05,793
The things that work have really good examples,

01:31:05,793 --> 01:31:07,374
well documented on the web.

01:31:07,374 --> 01:31:09,488
I'm looking at Brendan here because he's really good at it.

01:31:09,488 --> 01:31:12,643
That's why it works so well.

01:31:12,643 --> 01:31:15,528
We just have a directory distributed on every machine

01:31:15,528 --> 01:31:16,968
with all of the examples,

01:31:16,968 --> 01:31:18,995
and that's what people build on top of

01:31:18,995 --> 01:31:20,625
when they're debugging problems.

01:31:20,625 --> 01:31:21,458
- Yeah Etherpad person, whomever,

01:31:21,458 --> 01:31:23,285
can you just add, add examples.

01:31:23,285 --> 01:31:27,209
- Yeah I, sorry, I wanted to add one thing to that.

01:31:27,209 --> 01:31:29,325
Which is that I'm coming in as a

01:31:29,325 --> 01:31:32,049
like a BPF trace somewhat newbie,

01:31:32,049 --> 01:31:34,020
so I spent you know half a day learning it.

01:31:34,020 --> 01:31:36,826
I was struck by what the learning curve felt like.

01:31:36,826 --> 01:31:38,713
So it was a comfortable learning curve,

01:31:38,713 --> 01:31:40,420
but there is one, you know I had to

01:31:40,420 --> 01:31:41,842
burn that half a day to learn it

01:31:41,842 --> 01:31:44,239
and taking the time to learn a new anything

01:31:44,239 --> 01:31:45,662
is, you know, something

01:31:45,662 --> 01:31:48,709
so where you wanna go is you wanna look at the source

01:31:48,709 --> 01:31:50,234
of all the stuff,

01:31:50,234 --> 01:31:51,861
so you end up looking at the kernel trace events

01:31:51,861 --> 01:31:54,868
both in the kernel tree and under sys,

01:31:54,868 --> 01:31:56,736
you know, whatever debug,

01:31:56,736 --> 01:32:01,139
if you go off into SQL you do lose a little bit of that.

01:32:01,139 --> 01:32:04,296
Both in terms of the subtraction and all that

01:32:04,296 --> 01:32:06,403
is a little bit un-SQL,

01:32:06,403 --> 01:32:08,981
and you can find the events in the kernel

01:32:08,981 --> 01:32:11,163
and those line up really well with the BPF trace.

01:32:11,163 --> 01:32:13,049
So my takeaway from the whole thing

01:32:13,049 --> 01:32:16,481
was that learning BPF trace was not hard

01:32:16,481 --> 01:32:18,779
because the kernel source and the mounted sys

01:32:18,779 --> 01:32:21,498
and proc were there to help me.

01:32:21,498 --> 01:32:23,818
And I could find out what the events were,

01:32:23,818 --> 01:32:25,037
and I could match 'em all up.

01:32:25,037 --> 01:32:27,272
If you go to SQL you'll lose a little bit of that.

01:32:27,272 --> 01:32:28,432
- Yeah, I do understand,

01:32:28,432 --> 01:32:30,319
there is a thing, believe me I hate SQL.

01:32:30,319 --> 01:32:32,090
But I picked it because it was kind of like,

01:32:32,090 --> 01:32:33,649
I mean if you think of it that way,

01:32:33,649 --> 01:32:35,219
it was actually, it made the syntax actually easier

01:32:35,219 --> 01:32:37,007
than a lot of the things I came up with.

01:32:37,007 --> 01:32:39,259
Real quick, do you wanna switch to the next couple slides?

01:32:39,259 --> 01:32:40,478
I think the one you have?

01:32:40,478 --> 01:32:41,448
- I think this end off.

01:32:41,448 --> 01:32:43,328
- You had the more complex version,

01:32:43,328 --> 01:32:46,432
yeah this was the example that does have one complex,

01:32:46,432 --> 01:32:48,181
real complex one,

01:32:48,181 --> 01:32:50,294
this is actually you'd be two select statements

01:32:50,294 --> 01:32:52,118
this would be all on one line, obviously.

01:32:52,118 --> 01:32:54,195
So it was just giving an idea of this.

01:32:54,195 --> 01:32:56,876
Basically we have to go to the break now, so we end this.

01:32:56,876 --> 01:33:00,801
So I wanted to basically, let's have a discussion with this

01:33:00,801 --> 01:33:02,440
and we'll come up with more,

01:33:02,440 --> 01:33:03,907
so this is like more of a design stage

01:33:03,907 --> 01:33:05,776
we could get it, if it works,

01:33:05,776 --> 01:33:07,036
if we could find a better way,

01:33:07,036 --> 01:33:09,674
we're all, right now, very open minded.

01:33:09,674 --> 01:33:12,725
So, thank you very much, I will hopefully post it.

01:33:12,725 --> 01:33:14,368
And it's break time.

01:33:14,368 --> 01:33:17,535
(audience applauding)

01:33:20,649 --> 01:33:22,111
Okay, welcome back everyone.

01:33:22,111 --> 01:33:26,173
Hopefully some more people, only problem with breaks is

01:33:26,173 --> 01:33:29,240
it gives people an excuse not to come back.

01:33:29,240 --> 01:33:32,823
Especially when it's like you're exhausted.

01:33:35,914 --> 01:33:38,197
But anyway we're going to continue off,

01:33:38,197 --> 01:33:40,960
Jeremie is the way it's pronounced?

01:33:40,960 --> 01:33:41,976
- Yep.

01:33:41,976 --> 01:33:43,062
- And, how do you pronounce your last name?

01:33:43,062 --> 01:33:44,095
- Galarneau.

01:33:44,095 --> 01:33:44,984
- Galarneau? - Yep.

01:33:44,984 --> 01:33:47,814
- Okay, so Jeremie Galarneau will be now talking about

01:33:47,814 --> 01:33:50,579
finding tracing processing ecosystems with Babeltrace

01:33:50,579 --> 01:33:51,811
or something like that.

01:33:51,811 --> 01:33:54,155
But I'll be going to work with him afterwords so...

01:33:54,155 --> 01:33:56,508
- Okay, so thank you Steven.

01:33:56,508 --> 01:33:58,462
Actually Steven and I

01:33:58,462 --> 01:34:00,338
are going to speak about the same thing

01:34:00,338 --> 01:34:03,542
which is identifying trace processing ecosystems.

01:34:03,542 --> 01:34:06,466
You may know this that I'm not wearing any body armor,

01:34:06,466 --> 01:34:09,881
so I'm not trying to unify tracers.

01:34:09,881 --> 01:34:12,090
Okay, don't wanna get into that.

01:34:12,090 --> 01:34:12,923
- [Audience Member] No ring buffers.

01:34:12,923 --> 01:34:14,898
- No discussion of unification of ring buffers

01:34:14,898 --> 01:34:18,565
is gonna happen at least while I'm in front.

01:34:19,693 --> 01:34:23,110
So basically what we're trying to achieve

01:34:24,694 --> 01:34:27,336
is there's a situation right now

01:34:27,336 --> 01:34:28,933
where there are a lot of tools

01:34:28,933 --> 01:34:31,214
that are trace processing tools

01:34:31,214 --> 01:34:34,343
that are targeted for specific tracers

01:34:34,343 --> 01:34:36,334
and there's no reason for that.

01:34:36,334 --> 01:34:38,971
I mean typically, it's only because they all output

01:34:38,971 --> 01:34:40,502
their own output formats.

01:34:40,502 --> 01:34:43,504
And I mean, all tracers have their own use cases

01:34:43,504 --> 01:34:45,094
but at the end of the day,

01:34:45,094 --> 01:34:46,597
they all extract pretty much the same information.

01:34:46,597 --> 01:34:48,950
So there's no technical reason

01:34:48,950 --> 01:34:53,888
for tools not to reuse the same trace reading code,

01:34:53,888 --> 01:34:56,448
trace processing code, if you wanna filter,

01:34:56,448 --> 01:34:57,992
all that stuff can be reused.

01:34:57,992 --> 01:35:00,657
And this is what Babeltrace tries to achieve.

01:35:00,657 --> 01:35:02,015
Babeltrace already exists,

01:35:02,015 --> 01:35:03,761
what I'm gonna present is basically

01:35:03,761 --> 01:35:06,119
what we're introducing in Babeltrace two.

01:35:06,119 --> 01:35:08,026
Just to give a bit of context

01:35:08,026 --> 01:35:09,736
before we go into the open discussion.

01:35:09,736 --> 01:35:11,321
So Babeltrace, the goal is to

01:35:11,321 --> 01:35:15,059
consume, manipulate, and convert traces of various formats.

01:35:15,059 --> 01:35:18,249
So it's tracer agnostic, for all intents and purposes.

01:35:18,249 --> 01:35:21,479
The goal, when I say trace manipulation,

01:35:21,479 --> 01:35:24,161
it's basically filtering, removing fields,

01:35:24,161 --> 01:35:26,582
changing field values, adding the bug information,

01:35:26,582 --> 01:35:28,451
those kinds of things in traces.

01:35:28,451 --> 01:35:32,166
And we wanna basically aggregate and correlate

01:35:32,166 --> 01:35:34,953
kernel traces, user space traces, logs,

01:35:34,953 --> 01:35:38,000
could be pcap traces, hardware traces.

01:35:38,000 --> 01:35:41,675
It's already used in the kernel tree

01:35:41,675 --> 01:35:44,354
for the perf to CTF converter,

01:35:44,354 --> 01:35:46,917
so that's already out there.

01:35:46,917 --> 01:35:48,850
And Babeltrace is cross platform,

01:35:48,850 --> 01:35:52,199
so it works on Linux, Mac OS, and Windows.

01:35:52,199 --> 01:35:55,219
So the big idea before the discussion,

01:35:55,219 --> 01:36:00,219
is if you've ever toyed with gStreamer, ffmpeg, DirectShow,

01:36:00,404 --> 01:36:02,765
a number of those video frameworks,

01:36:02,765 --> 01:36:05,284
basically you'll recognize this.

01:36:05,284 --> 01:36:07,925
You have sources, filters, and sinks.

01:36:07,925 --> 01:36:09,668
To give you an idea,

01:36:09,668 --> 01:36:11,565
when you assemble the graph in Babeltrace,

01:36:11,565 --> 01:36:15,808
you have sources, those really handle the ingest of events.

01:36:15,808 --> 01:36:18,470
So reading a CTF trace, reading a perf trace,

01:36:18,470 --> 01:36:22,006
a de-message, output, could be anything.

01:36:22,006 --> 01:36:25,665
Then you insert a number of filters,

01:36:25,665 --> 01:36:27,695
the one that is there is a Moxer,

01:36:27,695 --> 01:36:29,322
so basically it does the correlation between all traces

01:36:29,322 --> 01:36:33,548
to present them as a single time or stream of events.

01:36:33,548 --> 01:36:35,128
So any viewer could use that

01:36:35,128 --> 01:36:37,378
to do any number of things.

01:36:38,970 --> 01:36:42,831
And then you have sinks, so basically sinks can be analysis

01:36:42,831 --> 01:36:45,350
and in that case, that's a pretty printer,

01:36:45,350 --> 01:36:47,892
and that's the typical use when you use

01:36:47,892 --> 01:36:50,309
the actual Babeltrace binary.

01:36:51,923 --> 01:36:53,477
For Babeltrace 2.0,

01:36:53,477 --> 01:36:57,481
I mean all the API's are stable right now,

01:36:57,481 --> 01:36:59,230
and we're just working on the documentation.

01:36:59,230 --> 01:37:00,994
So it's gonna be released within a few weeks.

01:37:00,994 --> 01:37:03,578
At least they release candidate one is gonna be released

01:37:03,578 --> 01:37:04,972
within a few weeks.

01:37:04,972 --> 01:37:07,415
So discussion points, and this is where

01:37:07,415 --> 01:37:09,388
we have a lot of overlap, Steven and I.

01:37:09,388 --> 01:37:12,657
The first point I wanna bring up,

01:37:12,657 --> 01:37:14,973
is trace format stability and interface.

01:37:14,973 --> 01:37:17,890
I work in LTTng's so LTTng uses CTF

01:37:19,058 --> 01:37:20,888
which is an external spec,

01:37:20,888 --> 01:37:23,365
that is not, whoa, am I good?

01:37:23,365 --> 01:37:24,359
Okay.

01:37:24,359 --> 01:37:26,192
It's an external spec,

01:37:27,227 --> 01:37:30,478
so it's not like the format of LTTng,

01:37:30,478 --> 01:37:32,631
so it doesn't change, it's self described.

01:37:32,631 --> 01:37:35,006
And LTTng just produces that format,

01:37:35,006 --> 01:37:36,939
and there are a number of traces that use that.

01:37:36,939 --> 01:37:40,040
But there are tracers that will have

01:37:40,040 --> 01:37:42,668
very flexible trace formats,

01:37:42,668 --> 01:37:44,698
that may change with every release.

01:37:44,698 --> 01:37:47,843
I don't know if that's the case of perf and ftrace.

01:37:47,843 --> 01:37:50,145
I don't know if there's an intent to keep

01:37:50,145 --> 01:37:54,062
binary compatibility in terms of trace formats.

01:37:56,477 --> 01:37:59,143
- So it's trace command trace.dap file

01:37:59,143 --> 01:38:02,028
actually works, trace command 1.0

01:38:02,028 --> 01:38:04,861
can read the 3.0 trace data files.

01:38:06,457 --> 01:38:08,891
It may not have a, if there's a new feature,

01:38:08,891 --> 01:38:10,886
it uses options to extend the file

01:38:10,886 --> 01:38:13,098
but whatever it can read, it can read.

01:38:13,098 --> 01:38:15,275
So we try to keep forward and backward compatibility

01:38:15,275 --> 01:38:17,022
in the trace.dap file.

01:38:17,022 --> 01:38:18,034
- Okay.

01:38:18,034 --> 01:38:18,955
- So did I answer your question on that one.

01:38:18,955 --> 01:38:19,873
- Yep, that's my question.

01:38:19,873 --> 01:38:23,832
And I mean, this is where a big problem that we have

01:38:23,832 --> 01:38:26,148
with double tracing, we have,

01:38:26,148 --> 01:38:28,442
basically all the components that you saw

01:38:28,442 --> 01:38:30,316
could be in the Babletrace tree or out of tree,

01:38:30,316 --> 01:38:31,535
we have a plug in system.

01:38:31,535 --> 01:38:34,298
And for a lot of hardware traces and things like that,

01:38:34,298 --> 01:38:36,545
make sense to carry that out of tree

01:38:36,545 --> 01:38:38,419
because the formats may change,

01:38:38,419 --> 01:38:39,598
they may not be documented,

01:38:39,598 --> 01:38:44,181
and they may not be open source-able, if that's a word.

01:38:45,357 --> 01:38:49,321
And so basically we wanna accommodate that

01:38:49,321 --> 01:38:53,234
and my question to you, which you answered,

01:38:53,234 --> 01:38:55,649
is basically, should we use lib trace event

01:38:55,649 --> 01:38:59,550
to consume ftraces, or like if you were,

01:38:59,550 --> 01:39:02,353
a library that we can already use,

01:39:02,353 --> 01:39:05,353
and sorta write a wrapper around it?

01:39:07,892 --> 01:39:08,915
- Actually, we're still,

01:39:08,915 --> 01:39:12,330
okay the code is there, it's just not a library yet.

01:39:12,330 --> 01:39:14,582
For trace, we're trying to pull out

01:39:14,582 --> 01:39:16,492
all the writing and reading

01:39:16,492 --> 01:39:18,506
of the trace.dap file into it's own library.

01:39:18,506 --> 01:39:20,637
Probably even call it lib ftrace.

01:39:20,637 --> 01:39:22,691
It's specifically focused for ftrace.

01:39:22,691 --> 01:39:25,716
That will allow you to, it's also going to,

01:39:25,716 --> 01:39:28,990
there's, what we want it to be able to do

01:39:28,990 --> 01:39:30,372
is not just rewrite the file,

01:39:30,372 --> 01:39:33,582
but also to enable and disable ftrace as well

01:39:33,582 --> 01:39:36,160
so it will actually interact with the kernel.

01:39:36,160 --> 01:39:38,354
But we do, that's the format,

01:39:38,354 --> 01:39:40,409
but actually, it sounds like you're looking at it,

01:39:40,409 --> 01:39:43,469
from my idea is Babletrace is you have all these tools

01:39:43,469 --> 01:39:45,935
you get out the data,

01:39:45,935 --> 01:39:47,926
and I think this might be where we might

01:39:47,926 --> 01:39:51,380
work on the same goal but different aspects of it.

01:39:51,380 --> 01:39:55,200
Sounds like you're looking at all the tracing format files,

01:39:55,200 --> 01:39:58,126
and I'd be happy to make trace command write CTF,

01:39:58,126 --> 01:40:00,807
I mean I have no problem, it's been on the to do list,

01:40:00,807 --> 01:40:03,530
it's just the time, it's just never got there.

01:40:03,530 --> 01:40:06,634
But what I'm actually focusing on my side

01:40:06,634 --> 01:40:08,487
is enabling or disabling the tracers

01:40:08,487 --> 01:40:10,212
are you working on doing that?

01:40:10,212 --> 01:40:11,796
- [Jeremie] Not as part of Babeltrace.

01:40:11,796 --> 01:40:13,178
- Yeah, so.

01:40:13,178 --> 01:40:14,519
- [Jeremie] Babeltrace is really like,

01:40:14,519 --> 01:40:15,936
once you have your traces.

01:40:15,936 --> 01:40:17,810
- Right, so this actually I think we could work together

01:40:17,810 --> 01:40:19,233
and this is where I think we are not

01:40:19,233 --> 01:40:21,508
there's a small overlap,

01:40:21,508 --> 01:40:23,766
but I think we have two different focuses.

01:40:23,766 --> 01:40:26,059
I'm looking at getting, having something,

01:40:26,059 --> 01:40:28,438
like if you load LTTng having a library perf,

01:40:28,438 --> 01:40:31,521
LTTng ftrace, anything that's in BPF,

01:40:32,664 --> 01:40:35,283
or I mean, have something that could enable, disable a tool

01:40:35,283 --> 01:40:38,331
a library that enables and disables the tracing

01:40:38,331 --> 01:40:39,834
to pull out the data.

01:40:39,834 --> 01:40:42,296
And I haven't really looked at formatting the data.

01:40:42,296 --> 01:40:44,571
So, it looks like Babel, like the two could be combined

01:40:44,571 --> 01:40:47,127
where like, the unified tracing platform

01:40:47,127 --> 01:40:49,447
is supposed to be enabling and disabling tracing

01:40:49,447 --> 01:40:53,385
and then using Babeltrace to, let Babeltrace,

01:40:53,385 --> 01:40:57,023
to be able to unify the data once it's collected.

01:40:57,023 --> 01:40:58,059
- [Jeremie] Yep.

01:40:58,059 --> 01:40:59,989
- So it sounds like we are actually...

01:40:59,989 --> 01:41:01,086
- Complimentary.

01:41:01,086 --> 01:41:01,919
- Complimentary, yes.

01:41:01,919 --> 01:41:03,286
- So I guess my lib trace event

01:41:03,286 --> 01:41:06,188
was more the trace processing aspect.

01:41:06,188 --> 01:41:07,530
- It did both, but yeah,

01:41:07,530 --> 01:41:09,440
that's why I have a lib ftrace that does it

01:41:09,440 --> 01:41:11,372
and actually, maybe I'll break that up,

01:41:11,372 --> 01:41:12,853
into a way of doing that.

01:41:12,853 --> 01:41:14,786
I don't even mind if we change it to uCTF

01:41:14,786 --> 01:41:16,981
and right, I have no problem with that

01:41:16,981 --> 01:41:18,060
I just need man power.

01:41:18,060 --> 01:41:21,520
But yes, I've been very very concerned about

01:41:21,520 --> 01:41:24,937
backward compatibility, I mean they know,

01:41:26,025 --> 01:41:28,544
I'm always yelling at them saying no we gotta do it this way

01:41:28,544 --> 01:41:31,139
because it's always looking for

01:41:31,139 --> 01:41:33,502
like how can this be, how can we extend it,

01:41:33,502 --> 01:41:34,494
without breaking it.

01:41:34,494 --> 01:41:35,591
So I always have options,

01:41:35,591 --> 01:41:37,600
I always have extendability to be able to extend things

01:41:37,600 --> 01:41:39,289
so the trace.daf file,

01:41:39,289 --> 01:41:42,148
we're actually it's at version six.

01:41:42,148 --> 01:41:44,995
Version six was written at trace command 1.0,

01:41:44,995 --> 01:41:49,245
and one, two, three, four, five were all like,

01:41:49,245 --> 01:41:51,196
one, two, three, four, five were all development processes.

01:41:51,196 --> 01:41:52,879
Once it hit six, I haven't changed it since.

01:41:52,879 --> 01:41:54,852
We were thinking of going to seven,

01:41:54,852 --> 01:41:56,982
because there's one thing I don't know is compress,

01:41:56,982 --> 01:41:58,771
we have the file compressed,

01:41:58,771 --> 01:42:00,721
that's one thing that's not,

01:42:00,721 --> 01:42:03,078
once you make it compressed, old trace mail

01:42:03,078 --> 01:42:05,271
will never be able to, won't know how to read it.

01:42:05,271 --> 01:42:06,735
So that's the only difference.

01:42:06,735 --> 01:42:09,847
That's the one step of changing breaking compatibility but.

01:42:09,847 --> 01:42:12,648
- Is that considered part of the kernel API or?

01:42:12,648 --> 01:42:13,869
- No, no, no.

01:42:13,869 --> 01:42:15,553
No, no this is all user space API.

01:42:15,553 --> 01:42:17,607
The kernel API is there, it's actually

01:42:17,607 --> 01:42:18,690
lib k buffer.

01:42:20,789 --> 01:42:23,802
We have a lib k buffer that trace command uses

01:42:23,802 --> 01:42:26,602
and that's actually in the kernel tree that perf uses.

01:42:26,602 --> 01:42:29,769
Or perf, I think, not perf but ftrace,

01:42:32,167 --> 01:42:34,187
the perf ftrace has it.

01:42:34,187 --> 01:42:35,836
So that lib k buffer tells you

01:42:35,836 --> 01:42:37,623
how to read the ftrace ring buffer

01:42:37,623 --> 01:42:39,876
from binary data that gets pulled outta the kernel.

01:42:39,876 --> 01:42:40,888
- Okay.

01:42:40,888 --> 01:42:41,948
- And that's API.

01:42:41,948 --> 01:42:43,620
- Okay, so then you can do whatever you want.

01:42:43,620 --> 01:42:45,570
- Yeah. - Okay.

01:42:45,570 --> 01:42:47,863
Good, so that works for ftrace.

01:42:47,863 --> 01:42:51,848
I'm not so sure how we're gonna end up

01:42:51,848 --> 01:42:53,351
for instance in total PT

01:42:53,351 --> 01:42:55,018
something that I've looked a bit into.

01:42:55,018 --> 01:42:58,251
And I mean there's a lot of tooling

01:42:58,251 --> 01:43:00,016
that's open sourced to deal with that.

01:43:00,016 --> 01:43:03,599
But I'm sorta unsure if those trace formats

01:43:07,028 --> 01:43:09,751
those native trace formats of intel

01:43:09,751 --> 01:43:11,434
are gonna be supportive in the future,

01:43:11,434 --> 01:43:12,448
are they gonna change?

01:43:12,448 --> 01:43:14,116
So if things can change,

01:43:14,116 --> 01:43:15,846
I think it makes sense to ship

01:43:15,846 --> 01:43:19,155
a source as part of that tree.

01:43:19,155 --> 01:43:21,819
There's gonna be painting say by Intel.

01:43:21,819 --> 01:43:23,909
And the same would apply,

01:43:23,909 --> 01:43:25,556
if ftrace was to change it's format

01:43:25,556 --> 01:43:27,909
then it could update its Babeltrace source

01:43:27,909 --> 01:43:30,289
and the rest would continue to work as is.

01:43:30,289 --> 01:43:31,789
The other thing is

01:43:32,767 --> 01:43:35,674
having come on clock sources.

01:43:35,674 --> 01:43:38,938
So LTTng uses, for instance, CLOCK_MONOTONIC.

01:43:38,938 --> 01:43:42,218
It provides a boot ID, and it provides an offset to Epoch.

01:43:42,218 --> 01:43:44,900
So basically you can interpret a cycle count

01:43:44,900 --> 01:43:46,483
as real world time.

01:43:48,024 --> 01:43:51,071
This is not so true with a lot of hardware traces,

01:43:51,071 --> 01:43:54,693
and so, this is like an open question.

01:43:54,693 --> 01:43:57,618
We're not sure how to infer that information

01:43:57,618 --> 01:44:00,573
from existing traces and whether

01:44:00,573 --> 01:44:02,292
we can work with other tracer hardware

01:44:02,292 --> 01:44:05,095
to make sure that clocks are described

01:44:05,095 --> 01:44:09,281
as part of their trace formats or whichever other way.

01:44:09,281 --> 01:44:11,759
This is more an open question.

01:44:11,759 --> 01:44:15,009
I don't know if anything has been done.

01:44:17,597 --> 01:44:18,934
- Yeah, it's funny, 'cause the clock

01:44:18,934 --> 01:44:23,851
in lib ftrace or whatever, trace command is just a counter.

01:44:23,851 --> 01:44:26,533
And we're working on ways, and actually

01:44:26,533 --> 01:44:29,110
it's defined in the lib trace event,

01:44:29,110 --> 01:44:30,962
which is in the kernel, which is,

01:44:30,962 --> 01:44:31,795
and,

01:44:34,434 --> 01:44:35,734
I think we're actually working,

01:44:35,734 --> 01:44:37,400
we're working on changing, 'cause right now

01:44:37,400 --> 01:44:38,335
lib trace event is not,

01:44:38,335 --> 01:44:40,001
we're working on making that into an ABI

01:44:40,001 --> 01:44:42,950
actual hard coding into a true, you know,

01:44:42,950 --> 01:44:45,711
once we send it as a library,

01:44:45,711 --> 01:44:47,437
you know it's called lib trace event,

01:44:47,437 --> 01:44:50,084
but once it goes out as to the distributions

01:44:50,084 --> 01:44:51,831
where it's gotta be stable, we can't,

01:44:51,831 --> 01:44:54,246
and we're still actually working on some of this

01:44:54,246 --> 01:44:56,079
to make it more, just,

01:44:58,513 --> 01:45:00,161
it's a number and you can define,

01:45:00,161 --> 01:45:03,047
we actually created a new, ABI,

01:45:03,047 --> 01:45:04,387
what's it called?

01:45:04,387 --> 01:45:06,866
The prints one, Cecil, the one that you just did.

01:45:06,866 --> 01:45:08,814
The TEP print format?

01:45:08,814 --> 01:45:10,686
Yeah, we have a TEP print format.

01:45:10,686 --> 01:45:13,019
TEP is tracing event parser.

01:45:14,831 --> 01:45:16,886
Yeah trace event parser, so how to

01:45:16,886 --> 01:45:18,331
parse the events sync data.

01:45:18,331 --> 01:45:21,081
So, the TEP, for our print format

01:45:22,209 --> 01:45:24,831
what it does is you pass in

01:45:24,831 --> 01:45:26,914
basically print f format,

01:45:29,017 --> 01:45:31,090
and then you can pass in, you know,

01:45:31,090 --> 01:45:34,787
you could use the start dot, the precision,

01:45:34,787 --> 01:45:36,431
and then say okay this is going the field is,

01:45:36,431 --> 01:45:38,783
I want the time, I want the time stamp,

01:45:38,783 --> 01:45:42,033
this and this, so basically to the interface

01:45:42,033 --> 01:45:43,502
the time stamp is just a number.

01:45:43,502 --> 01:45:45,394
But the tool could pass in a print format

01:45:45,394 --> 01:45:48,848
thing to define, to make that number into a precision

01:45:48,848 --> 01:45:50,756
to truncate it or whatever,

01:45:50,756 --> 01:45:52,627
you could say okay, but do...

01:45:52,627 --> 01:45:54,473
- Can you relate to wall time?

01:45:54,473 --> 01:45:56,162
Or is always the cycle count your in?

01:45:56,162 --> 01:45:59,840
- Okay, here's the thing about trace event, or ftrace,

01:45:59,840 --> 01:46:03,558
and is a fact that the clock is definable.

01:46:03,558 --> 01:46:05,897
You can actually, there's a trace clock

01:46:05,897 --> 01:46:08,028
in the trace FS file system.

01:46:08,028 --> 01:46:10,339
So you can make it give me cycles,

01:46:10,339 --> 01:46:14,309
give me, so it's just a number, so it's not, yes.

01:46:14,309 --> 01:46:17,211
- So that brings a problem, I mean if we can have

01:46:17,211 --> 01:46:19,365
information in the tracement of data

01:46:19,365 --> 01:46:22,372
about what configuration has been used for that clock,

01:46:22,372 --> 01:46:25,036
then Babeltrace would know if it can correlate

01:46:25,036 --> 01:46:27,000
with other tracers or not.

01:46:27,000 --> 01:46:28,083
That would be useful.

01:46:28,083 --> 01:46:30,702
- Okay, I'm trying to remember, do we have an option

01:46:30,702 --> 01:46:32,530
in the trace data that records,

01:46:32,530 --> 01:46:34,179
yeah, we record what clock is used.

01:46:34,179 --> 01:46:36,007
- [Audience Member] Yeah the trace dot dapa file .

01:46:36,007 --> 01:46:39,213
- Um, yeah, the trace dot dapa yeah.

01:46:39,213 --> 01:46:43,403
Yeah, we actually record, we read the trace clock

01:46:43,403 --> 01:46:45,896
with levers, so if it says local,

01:46:45,896 --> 01:46:48,483
we actually say this is what the clock is.

01:46:48,483 --> 01:46:51,408
So at least, that shouldn't change I guess.

01:46:51,408 --> 01:46:52,604
That's kernel ABI.

01:46:52,604 --> 01:46:54,961
So I guess that's something that we could see,

01:46:54,961 --> 01:46:56,406
hey Linux this can't change.

01:46:56,406 --> 01:46:59,007
So yes, you actually could tell you what clock was used

01:46:59,007 --> 01:47:00,998
for what number it was.

01:47:00,998 --> 01:47:02,989
And that's actually one thing we changed,

01:47:02,989 --> 01:47:04,835
before we based off the format

01:47:04,835 --> 01:47:06,646
depending on what clock was used.

01:47:06,646 --> 01:47:09,386
And realized that for a library that's not what we wanted,

01:47:09,386 --> 01:47:12,050
we wanted the user to be able to be more flexible

01:47:12,050 --> 01:47:13,757
that's why we created a trace format

01:47:13,757 --> 01:47:16,927
to do the change but you could ask what clock was this?

01:47:16,927 --> 01:47:18,646
And then make your decision,

01:47:18,646 --> 01:47:20,422
that's actually what trace command does,

01:47:20,422 --> 01:47:22,385
it now does what clock was used,

01:47:22,385 --> 01:47:24,398
and then makes its decision on how to format it

01:47:24,398 --> 01:47:25,736
based off of what clock it was

01:47:25,736 --> 01:47:28,119
and the library doesn't set the policy anymore.

01:47:28,119 --> 01:47:29,379
Before...

01:47:29,379 --> 01:47:30,629
- Before, yeah.

01:47:31,492 --> 01:47:32,995
Do you have any way to preserve that offset

01:47:32,995 --> 01:47:34,495
to wall time or...

01:47:35,555 --> 01:47:37,854
- No, well we could set an option to it.

01:47:37,854 --> 01:47:39,941
'Cause right now actually we're working on that

01:47:39,941 --> 01:47:40,941
on our, for,

01:47:43,705 --> 01:47:48,477
Kernel Shark 2.0, we're doing tracing between the m's.

01:47:48,477 --> 01:47:50,394
And we need a way to do

01:47:51,466 --> 01:47:55,222
synchronization between the two clocks,

01:47:55,222 --> 01:47:57,074
or we're working on synchronization,

01:47:57,074 --> 01:47:58,780
at least synchronizations between

01:47:58,780 --> 01:48:00,613
two basically tracers.

01:48:02,086 --> 01:48:04,551
You know, one's in the VM and one's in the host,

01:48:04,551 --> 01:48:06,803
and I've learned that, you know,

01:48:06,803 --> 01:48:09,400
the Intel architecture allows you to have them be

01:48:09,400 --> 01:48:11,070
two completely different clocks,

01:48:11,070 --> 01:48:13,041
with two different frequencies, and everything.

01:48:13,041 --> 01:48:16,579
So, you can't just assume that...

01:48:16,579 --> 01:48:18,466
- [Jeremie] That they're the same.

01:48:18,466 --> 01:48:19,464
- That they're the same, yeah,

01:48:19,464 --> 01:48:20,297
or even at the same frequency.

01:48:20,297 --> 01:48:22,489
There's a drift (laughs).

01:48:22,489 --> 01:48:25,252
- So do you have any solution for that, or,

01:48:25,252 --> 01:48:28,137
something on the table or...

01:48:28,137 --> 01:48:29,623
- Yeah, that's actually one of our,

01:48:29,623 --> 01:48:31,550
we're discussing that.

01:48:31,550 --> 01:48:32,724
We have a P to P program,

01:48:32,724 --> 01:48:34,151
are any of you familiar with the P to P?

01:48:34,151 --> 01:48:36,083
Not peer to peer protocol, but there's a time.

01:48:36,083 --> 01:48:38,698
- I know it, an our resolution kind of.

01:48:38,698 --> 01:48:39,940
- Yes, yes.

01:48:39,940 --> 01:48:40,876
- [Jeremie] Oh, okay.

01:48:40,876 --> 01:48:41,982
- Yeah we're doing, we're,

01:48:41,982 --> 01:48:43,241
that was one thing, one thing we wanted,

01:48:43,241 --> 01:48:44,095
originally tried to do is use trace points

01:48:44,095 --> 01:48:46,492
or trace events within the host and kernel

01:48:46,492 --> 01:48:47,729
and then tag it, tag it.

01:48:47,729 --> 01:48:49,273
But, right now we're using V sockets,

01:48:49,273 --> 01:48:50,934
or VSOCk as our communication,

01:48:50,934 --> 01:48:52,686
and VSOCK is very bloated.

01:48:52,686 --> 01:48:54,858
So trying to get the two trace points

01:48:54,858 --> 01:48:56,668
where the switch happens, is extremely difficult.

01:48:56,668 --> 01:48:58,331
And you could have, like,

01:48:58,331 --> 01:49:00,430
it's preemption is enabled so you can actually

01:49:00,430 --> 01:49:02,519
take your trace point and then preempt it

01:49:02,519 --> 01:49:04,203
and then come back and then it switches.

01:49:04,203 --> 01:49:05,591
So, it was very inaccurate,

01:49:05,591 --> 01:49:07,297
when we tried this it was extremely inaccurate.

01:49:07,297 --> 01:49:08,840
We couldn't find places where it was done

01:49:08,840 --> 01:49:11,964
with interrupts disabled and, yeah.

01:49:11,964 --> 01:49:14,507
So that's a thing that we're working on.

01:49:14,507 --> 01:49:16,963
- Okay, I think I'm just about out of time.

01:49:16,963 --> 01:49:18,611
The last point was basically,

01:49:18,611 --> 01:49:22,878
making trace analysis tools, tracer-agnostics,

01:49:22,878 --> 01:49:24,458
this is really an open discussion.

01:49:24,458 --> 01:49:27,551
But I mean, I've talked with people from Trace Compass,

01:49:27,551 --> 01:49:31,492
I think Kernel Shark would be open to using Babeltrace.

01:49:31,492 --> 01:49:33,362
Just to read any number of...

01:49:33,362 --> 01:49:34,354
- [Steve] Oh no, yeah.

01:49:34,354 --> 01:49:35,608
That's part of the plan.

01:49:35,608 --> 01:49:40,191
- But the rest, making BPF trace scripts work with that

01:49:41,547 --> 01:49:43,010
is really an open question.

01:49:43,010 --> 01:49:44,269
I think we discussed it yesterday.

01:49:44,269 --> 01:49:45,102
So...

01:49:47,520 --> 01:49:49,874
If people have any ideas to throw out there

01:49:49,874 --> 01:49:52,599
how you could actually run those scripts

01:49:52,599 --> 01:49:54,834
which are meant to run real time.

01:49:54,834 --> 01:49:57,557
Well not, well real time, but on a live system,

01:49:57,557 --> 01:50:00,442
from a post-mortem trace.

01:50:00,442 --> 01:50:03,775
Either through a SandBox BPF interpreter

01:50:05,440 --> 01:50:07,755
that would try to recreate the context

01:50:07,755 --> 01:50:10,458
that was available to the BPF probe

01:50:10,458 --> 01:50:13,323
or you know, whichever other solution.

01:50:13,323 --> 01:50:15,406
(laughs)

01:50:16,557 --> 01:50:19,134
- Okay, now, right now it's been a discussion,

01:50:19,134 --> 01:50:21,445
right now everything that's happened right now,

01:50:21,445 --> 01:50:22,669
could've been done by us two just getting together

01:50:22,669 --> 01:50:24,313
and a few other people.

01:50:24,313 --> 01:50:27,198
Anyone have questions, ideas,

01:50:27,198 --> 01:50:29,281
or discussion, or topics?

01:50:30,427 --> 01:50:31,971
Basically, the idea is this,

01:50:31,971 --> 01:50:34,517
how many people think there's too many tracers in the world.

01:50:34,517 --> 01:50:37,032
(laughing)

01:50:37,032 --> 01:50:37,865
Okay, so.

01:50:38,883 --> 01:50:41,316
Basically the point is this, you know,

01:50:41,316 --> 01:50:43,483
what I've learned is that,

01:50:44,333 --> 01:50:45,651
the reason why there's so many different tracers.

01:50:45,651 --> 01:50:47,724
We tried the unified tracing buffer,

01:50:47,724 --> 01:50:50,545
you know we had the, you know, the ring buffer wars.

01:50:50,545 --> 01:50:52,803
The one ring buffer to rule them all.

01:50:52,803 --> 01:50:55,200
That failed miserably.

01:50:55,200 --> 01:50:58,790
We, there's now, the LTTng ring buffer,

01:50:58,790 --> 01:51:00,465
ftrace ring buffer, perf ring buffer,

01:51:00,465 --> 01:51:02,131
and I think they're even trying to add,

01:51:02,131 --> 01:51:03,820
by the way the print k ring buffer now.

01:51:03,820 --> 01:51:05,243
We're doing a lot of ring buffers.

01:51:05,243 --> 01:51:07,192
And it's almost like, why can't we just do one?

01:51:07,192 --> 01:51:09,192
And when you work, okay,

01:51:10,052 --> 01:51:12,859
who here has written a ring buffer?

01:51:12,859 --> 01:51:14,995
(scattered laughter)

01:51:14,995 --> 01:51:16,092
Okay.

01:51:16,092 --> 01:51:19,401
A long time ago I had the predecessor to the ftrace

01:51:19,401 --> 01:51:23,058
was log def, and I tried to get it into the kernel

01:51:23,058 --> 01:51:25,975
and this is around 2004 time frame.

01:51:27,076 --> 01:51:30,247
And Thomas Gleixner said, you know,

01:51:30,247 --> 01:51:31,551
everyone and their grandmother

01:51:31,551 --> 01:51:33,831
wrote a ring buffer in the kernel.

01:51:33,831 --> 01:51:34,825
We don't need it.

01:51:34,825 --> 01:51:36,392
You know, you write it, you throw it away.

01:51:36,392 --> 01:51:39,092
It's like why is everyone rewriting the world.

01:51:39,092 --> 01:51:42,487
Well, once you start working on this

01:51:42,487 --> 01:51:44,821
and this is something Matieu is very well aware of.

01:51:44,821 --> 01:51:46,893
The thing about tracing is you don't want to be,

01:51:46,893 --> 01:51:50,040
you don't want to effect the system.

01:51:50,040 --> 01:51:53,398
You want the Heisenberg issue low as possible.

01:51:53,398 --> 01:51:57,355
So you gotta have a ring buffer that is lockless.

01:51:57,355 --> 01:51:59,491
You have to have a ring buffer that's extremely fast.

01:51:59,491 --> 01:52:02,195
You have to have something that can record and get out,

01:52:02,195 --> 01:52:03,356
zero copy.

01:52:03,356 --> 01:52:05,812
This means that you gotta do a lot of tricks.

01:52:05,812 --> 01:52:08,639
And ring buffers yes, raise.

01:52:08,639 --> 01:52:09,472
What?

01:52:12,186 --> 01:52:13,769
I'll give you this.

01:52:15,657 --> 01:52:17,677
- Those are all good requirements,

01:52:17,677 --> 01:52:20,237
but you also forgot sequence and correlated time.

01:52:20,237 --> 01:52:24,237
- You hold on to that, keep it, I got a new one.

01:52:27,834 --> 01:52:29,340
Okay is this on?

01:52:29,340 --> 01:52:30,351
Okay.

01:52:30,351 --> 01:52:32,896
- Those are all exactly the right things you need

01:52:32,896 --> 01:52:34,338
in order to lower the noise you get.

01:52:34,338 --> 01:52:36,189
The big problem is, when you try and put in some kind of

01:52:36,189 --> 01:52:37,977
correlated sequence or correlated time.

01:52:37,977 --> 01:52:41,408
And trying to get that, usually throws you at a lock.

01:52:41,408 --> 01:52:43,016
- [Steve] Yeah, by the way, can you stand up

01:52:43,016 --> 01:52:44,578
so they can see who's talking?

01:52:44,578 --> 01:52:46,487
- Yeah, it's..

01:52:46,487 --> 01:52:48,113
- [Steve] Yes, well the thing is,

01:52:48,113 --> 01:52:50,127
what we usually do is a per CPU ring buffers

01:52:50,127 --> 01:52:52,321
and then you don't have to really worry about,

01:52:52,321 --> 01:52:56,118
I mean actually, I have an issue with the ftrace ring buffer

01:52:56,118 --> 01:52:58,742
I know Matieu had, did it differently,

01:52:58,742 --> 01:53:00,303
I didn't really agree with his solution.

01:53:00,303 --> 01:53:02,236
But his actually can handle,

01:53:02,236 --> 01:53:04,082
if I get, an interrupt happens

01:53:04,082 --> 01:53:06,419
when an event is being recorded

01:53:06,419 --> 01:53:08,750
because it's lockless and also I don't disable interrupts,

01:53:08,750 --> 01:53:11,153
I disable preemption, that's the only thing.

01:53:11,153 --> 01:53:12,471
Just, makes things easier.

01:53:12,471 --> 01:53:15,171
So I disable preemption, but if interrupt goes off

01:53:15,171 --> 01:53:17,265
and a trace event happens while the recording happens,

01:53:17,265 --> 01:53:20,553
the time, since my time stamps are done

01:53:20,553 --> 01:53:22,856
to keep it as small as possible, it's a differential.

01:53:22,856 --> 01:53:25,172
And it just puts in zero,

01:53:25,172 --> 01:53:27,748
so it's saying that if you happen here,

01:53:27,748 --> 01:53:30,669
now you have a bunch of events that happened

01:53:30,669 --> 01:53:32,689
that are all at the same time stamp.

01:53:32,689 --> 01:53:34,965
I have solutions that came up, but they all are buggy.

01:53:34,965 --> 01:53:37,579
So I'm trying to find a way to make sure

01:53:37,579 --> 01:53:40,953
because it's really really tricky to get that correct.

01:53:40,953 --> 01:53:42,686
- Zero copy, and lockless,

01:53:42,686 --> 01:53:44,328
and all the rest of it you can do.

01:53:44,328 --> 01:53:45,814
It's when you start trying to figure out

01:53:45,814 --> 01:53:47,109
which came first that it gets harder.

01:53:47,109 --> 01:53:48,107
- Yeah, well.

01:53:48,107 --> 01:53:50,339
And it's fine, it's ordered,

01:53:50,339 --> 01:53:51,904
'cause it comes in, you're right,

01:53:51,904 --> 01:53:55,056
when something happens, at time, that's where an issue is.

01:53:55,056 --> 01:53:57,616
But this is, we're kind of getting off tangent here.

01:53:57,616 --> 01:54:00,907
The thing about the ring buffers are like I said,

01:54:00,907 --> 01:54:02,330
the reason why there's so many,

01:54:02,330 --> 01:54:04,114
is also, we found out,

01:54:04,114 --> 01:54:05,395
there's different perspectives.

01:54:05,395 --> 01:54:07,485
The question came up earlier,

01:54:07,485 --> 01:54:10,939
why are we doing histograms when BPF could do?

01:54:10,939 --> 01:54:13,051
When the histogram code came out,

01:54:13,051 --> 01:54:15,164
it was like, you know, BPF can do this.

01:54:15,164 --> 01:54:17,968
And I always say to people, I'm like,

01:54:17,968 --> 01:54:20,163
when you, I use the example of,

01:54:20,163 --> 01:54:22,885
or the analogy of BASH versus C.

01:54:22,885 --> 01:54:25,522
You know, when you need to do something real quick,

01:54:25,522 --> 01:54:27,314
and you just don't care.

01:54:27,314 --> 01:54:29,407
You just run in, you write your BASH, you start doing BASH.

01:54:29,407 --> 01:54:31,459
And once it gets a little bit more complex,

01:54:31,459 --> 01:54:33,908
you're like oh wow, this actually a useful feature,

01:54:33,908 --> 01:54:35,637
I need to constantly use over and over again

01:54:35,637 --> 01:54:37,181
and extend it, it gets more complicated,

01:54:37,181 --> 01:54:39,398
maintain it in BASH and it becomes a nightmare.

01:54:39,398 --> 01:54:42,283
Writing a true C program is where to go.

01:54:42,283 --> 01:54:45,209
That's basically the difference between ftrace and BPF.

01:54:45,209 --> 01:54:48,112
I tell people, if you just need something quick,

01:54:48,112 --> 01:54:49,453
ftrace is there.

01:54:49,453 --> 01:54:52,013
I just wanna do something once, or a couple things,

01:54:52,013 --> 01:54:54,247
or do some things, and I do I use it all the time.

01:54:54,247 --> 01:54:56,645
I have not needed to use BPF,

01:54:56,645 --> 01:54:58,984
because ftrace has done everything I've needed

01:54:58,984 --> 01:55:00,854
but then again, I'm the author,

01:55:00,854 --> 01:55:02,438
if there's something I think ftrace needs

01:55:02,438 --> 01:55:03,942
I just kind of write the code and change it.

01:55:03,942 --> 01:55:05,625
So I've always told people,

01:55:05,625 --> 01:55:06,828
ftrace was written for me not you.

01:55:06,828 --> 01:55:09,282
(laughing)

01:55:09,282 --> 01:55:10,752
But the point, what I'm saying was,

01:55:10,752 --> 01:55:13,346
we have some different perspectives,

01:55:13,346 --> 01:55:15,482
that's why we have so many different tools.

01:55:15,482 --> 01:55:18,895
What's sad part is, one tool has something

01:55:18,895 --> 01:55:20,115
another tool doesn't.

01:55:20,115 --> 01:55:22,512
And this is not the Unix world

01:55:22,512 --> 01:55:26,210
where we had AIX, Sun, you know and everything else

01:55:26,210 --> 01:55:28,747
the BSD, all proprietary systems

01:55:28,747 --> 01:55:31,628
where, you know, everyone was trying to outdo the other

01:55:31,628 --> 01:55:34,853
and then you came up with a bunch of Unix systems

01:55:34,853 --> 01:55:37,158
that were incompatible and that's why they died,

01:55:37,158 --> 01:55:39,108
it crashed, and everyone says Linux,

01:55:39,108 --> 01:55:40,676
the fork of Linux will kill it.

01:55:40,676 --> 01:55:43,091
No, because the difference between back then and Linux

01:55:43,091 --> 01:55:44,452
is Linux is open source,

01:55:44,452 --> 01:55:46,098
GPL, when you see a feature

01:55:46,098 --> 01:55:47,909
that someone else has that you like

01:55:47,909 --> 01:55:49,372
you can incorporate it in your own stuff.

01:55:49,372 --> 01:55:52,372
Or, better, be able to lock in hook.

01:55:53,472 --> 01:55:56,384
So the idea here, kinda like what I said,

01:55:56,384 --> 01:55:57,702
I think this is where we're working

01:55:57,702 --> 01:55:59,308
there are times, Jeremie's proposal

01:55:59,308 --> 01:56:01,521
is we have a bunch of tracers and we're trying

01:56:01,521 --> 01:56:05,376
to get them, get a tool, just get a tool

01:56:05,376 --> 01:56:07,210
and say hey, I've used this library

01:56:07,210 --> 01:56:09,220
and I can read all the data formats

01:56:09,220 --> 01:56:11,454
and I can put together, I can take

01:56:11,454 --> 01:56:16,270
perf cache countings, LTG's, module loading or something,

01:56:16,270 --> 01:56:18,205
maybe ftrace function tracing.

01:56:18,205 --> 01:56:20,765
'Cause ftrace function, the ftrace ring buffer

01:56:20,765 --> 01:56:22,083
was made for function tracing.

01:56:22,083 --> 01:56:23,488
So it was made to be, you know,

01:56:23,488 --> 01:56:24,910
for that constant pull in.

01:56:24,910 --> 01:56:26,698
Where a perf was made for more for profiling.

01:56:26,698 --> 01:56:29,298
So, if you've done perf function tracing,

01:56:29,298 --> 01:56:31,086
you won't get as much data,

01:56:31,086 --> 01:56:32,509
as much as you will with the ftrace.

01:56:32,509 --> 01:56:34,331
So there's a focus there.

01:56:34,331 --> 01:56:37,036
But if we, you could, say if you got all these data formats

01:56:37,036 --> 01:56:38,882
and you wanna correlate them,

01:56:38,882 --> 01:56:40,856
that's why we come up with the question.

01:56:40,856 --> 01:56:42,621
Time stamps, that's a huge problem,

01:56:42,621 --> 01:56:44,937
and that's something that we have to work together with

01:56:44,937 --> 01:56:46,580
and that's one of the discussions,

01:56:46,580 --> 01:56:48,997
so anyone here a time expert?

01:56:52,084 --> 01:56:53,267
You are?

01:56:53,267 --> 01:56:54,266
Good.

01:56:54,266 --> 01:56:55,376
- [Audience Member] Worked on GPS.

01:56:55,376 --> 01:56:57,290
- Okay, well, maybe you have some ideas

01:56:57,290 --> 01:56:58,565
that you could help us.

01:56:58,565 --> 01:56:59,566
- [Audience Member] It's hard.

01:56:59,566 --> 01:57:00,924
(all laughing)

01:57:00,924 --> 01:57:04,943
In a particular, you summed it up well.

01:57:04,943 --> 01:57:07,124
I mean per CPU works really well

01:57:07,124 --> 01:57:09,440
if it's all happening on that CPU.

01:57:09,440 --> 01:57:13,138
When you have to start worrying about correlating things

01:57:13,138 --> 01:57:15,796
between CPU's and especially when you have to cross

01:57:15,796 --> 01:57:17,197
from one socket to another,

01:57:17,197 --> 01:57:19,413
and there's huge cross transport delays.

01:57:19,413 --> 01:57:21,300
The issue gets fraught.

01:57:21,300 --> 01:57:23,517
The best you can usually do,

01:57:23,517 --> 01:57:26,199
is try and attempt an approximation of what you've got.

01:57:26,199 --> 01:57:29,473
But trying to get everything strictly ordered,

01:57:29,473 --> 01:57:31,382
I don't think it's possible.

01:57:31,382 --> 01:57:33,508
- [Steve] Yeah, and...

01:57:33,508 --> 01:57:35,527
(background noise drowns out speaker)

01:57:35,527 --> 01:57:37,312
Wait please, mic.

01:57:37,312 --> 01:57:38,778
- [Audience Member] Sorry.

01:57:38,778 --> 01:57:41,216
- [Man] And then you've gotta be seeing these things--

01:57:41,216 --> 01:57:42,716
- Yeah, I can't...

01:57:44,670 --> 01:57:45,709
Here, here, here, before you...

01:57:45,709 --> 01:57:47,660
Heads up ready?

01:57:47,660 --> 01:57:49,448
You got your phone, I don't wanna crush your phone.

01:57:49,448 --> 01:57:52,414
- [Man] Fundamentally, relatively says

01:57:52,414 --> 01:57:54,889
there is no single consistent ordering

01:57:54,889 --> 01:57:57,326
given the speed of modern machines

01:57:57,326 --> 01:57:59,502
and the distance between sockets and so on and so forth.

01:57:59,502 --> 01:58:00,988
So it's an impossible problem.

01:58:00,988 --> 01:58:03,687
You're going to come up with candidace orderings.

01:58:03,687 --> 01:58:06,027
All as valid as each other.

01:58:06,027 --> 01:58:07,829
- [Audience Member] And approximations.

01:58:07,829 --> 01:58:10,108
- And like I said, it doesn't even matter if you're in

01:58:10,108 --> 01:58:11,936
on the same CPU, like I've mentioned,

01:58:11,936 --> 01:58:14,030
we're trying to trace between guest and host.

01:58:14,030 --> 01:58:16,933
And I mean, I didn't realize that was a new technology

01:58:16,933 --> 01:58:19,071
I just assumed that they had the same frequency,

01:58:19,071 --> 01:58:20,795
I was wrong.

01:58:20,795 --> 01:58:22,078
You can actually set up,

01:58:22,078 --> 01:58:24,046
and actually it does that by default I think,

01:58:24,046 --> 01:58:25,468
'cause the guest will have

01:58:25,468 --> 01:58:26,890
a different frequency then the host.

01:58:26,890 --> 01:58:29,023
So you can't even, I mean the same CPU,

01:58:29,023 --> 01:58:30,832
you just change contexts, and not only that,

01:58:30,832 --> 01:58:32,846
your time stamps are not gonna correlate.

01:58:32,846 --> 01:58:34,976
That makes things very difficult,

01:58:34,976 --> 01:58:36,625
especially when you want to show

01:58:36,625 --> 01:58:38,531
when things happen between guests and hosts exactly.

01:58:38,531 --> 01:58:40,120
So yes, we need help.

01:58:40,120 --> 01:58:44,549
Linux trace devel, at vger dot kernel dot org,

01:58:44,549 --> 01:58:46,435
and someone, oh I can write that down, hold on.

01:58:46,435 --> 01:58:50,018
(audience member sneezing)

01:58:50,942 --> 01:58:52,351
- [Man] It'll be in the notes.

01:58:52,351 --> 01:58:53,814
- Yeah.

01:58:53,814 --> 01:58:54,981
Whoops, geeze,

01:58:57,268 --> 01:58:58,768
this things not...

01:59:08,053 --> 01:59:10,898
We like to have people to subscribe,

01:59:10,898 --> 01:59:12,546
please, this is okay Linux trace devel,

01:59:12,546 --> 01:59:15,878
please subscribe, go to vger dot kernel dot org.

01:59:15,878 --> 01:59:19,775
And there'll be a mail, you can find it, subscribe to it.

01:59:19,775 --> 01:59:21,585
This is where at least we do

01:59:21,585 --> 01:59:24,615
our all our development for our trace command

01:59:24,615 --> 01:59:26,365
and for Kernel Shark,

01:59:27,500 --> 01:59:31,418
it's open for, it's LTT you have your own mailing list.

01:59:31,418 --> 01:59:34,141
If any, this is supposed to be generic,

01:59:34,141 --> 01:59:37,432
it's not trace command devel, it's not ftrace devel,

01:59:37,432 --> 01:59:39,666
it's supposed to be Linux trace devel.

01:59:39,666 --> 01:59:42,413
We're encouraging anyone to do that.

01:59:42,413 --> 01:59:44,201
I told you to, when you do the,

01:59:44,201 --> 01:59:46,515
what's it called, tracing summit,

01:59:46,515 --> 01:59:48,990
please post to, at least the users, and devel,

01:59:48,990 --> 01:59:51,010
so we know when it happens.

01:59:51,010 --> 01:59:53,408
I'm trying to get more people to subscribe here,

01:59:53,408 --> 01:59:55,050
this is where we do all our talking.

01:59:55,050 --> 01:59:57,610
Please come here, 'cause this is where we post our patches

01:59:57,610 --> 01:59:59,051
for time synchronization,

01:59:59,051 --> 02:00:01,006
this is where we do our discussions on time synchronization.

02:00:01,006 --> 02:00:03,212
If you're, it sounds like you have

02:00:03,212 --> 02:00:04,418
a lot more experience in this then we do.

02:00:04,418 --> 02:00:06,956
We really would appreciate any insight that you see on that.

02:00:06,956 --> 02:00:09,123
Anyone else have anything?

02:00:11,531 --> 02:00:14,149
So basically, I talked about

02:00:14,149 --> 02:00:16,018
what Jeremie was doing a little bit.

02:00:16,018 --> 02:00:18,944
What I'm focusing on now, is I want to have

02:00:18,944 --> 02:00:23,559
a way to not just read the data, but use the data.

02:00:23,559 --> 02:00:25,309
So I want a lib perf.

02:00:26,444 --> 02:00:28,615
I want a lib EPF, or something like that,

02:00:28,615 --> 02:00:30,666
I want a lib LTTng.

02:00:30,666 --> 02:00:32,760
I want anything that can say hey, I'm available,

02:00:32,760 --> 02:00:34,692
I want a library that tells me,

02:00:34,692 --> 02:00:37,189
so a tool, any tool, you can write a tool.

02:00:37,189 --> 02:00:40,014
Or Python script, to say what's available?

02:00:40,014 --> 02:00:42,268
And then from Python or whatever, say okay,

02:00:42,268 --> 02:00:44,219
I want to start this function tracing,

02:00:44,219 --> 02:00:47,330
I want to start, maybe abstracting out what you ask,

02:00:47,330 --> 02:00:49,443
or maybe just say hey, maybe get a single ABI

02:00:49,443 --> 02:00:51,231
that will work with,

02:00:51,231 --> 02:00:53,994
so maybe have a unified tracing platform,

02:00:53,994 --> 02:00:57,488
maybe a lib UTP, that will then figure out,

02:00:57,488 --> 02:00:59,904
oh perf is available, ftrace is available,

02:00:59,904 --> 02:01:01,060
LCT's are available.

02:01:01,060 --> 02:01:02,609
And be able to just get the data you want.

02:01:02,609 --> 02:01:04,861
Figure out the time synchronizations, anything else.

02:01:04,861 --> 02:01:06,608
And this is like I said,

02:01:06,608 --> 02:01:09,289
I'm trying to figure out how to do this,

02:01:09,289 --> 02:01:11,281
how to get this done, it's not easy.

02:01:11,281 --> 02:01:13,377
You got a bunch of different ways,

02:01:13,377 --> 02:01:15,246
different ideas, different mentalities.

02:01:15,246 --> 02:01:16,605
And I'm trying to sum it up together,

02:01:16,605 --> 02:01:18,352
instead of reinventing the wheel.

02:01:18,352 --> 02:01:20,709
I'm like, we have a lot of great functionality,

02:01:20,709 --> 02:01:22,963
a lot of great tools, that should be a platform.

02:01:22,963 --> 02:01:26,456
It shouldn't be a perf, Trace Compass, right.

02:01:26,456 --> 02:01:28,128
These things should be able to use,

02:01:28,128 --> 02:01:30,339
we should separate that, have the user in a base,

02:01:30,339 --> 02:01:33,712
some people like using trace command more than perf,

02:01:33,712 --> 02:01:36,050
or Trace Compass more than Kernel Shark, or whatever.

02:01:36,050 --> 02:01:37,050
That's fine.

02:01:37,897 --> 02:01:40,782
But everything else, the functionality,

02:01:40,782 --> 02:01:43,744
should be a separation, should be abstracted out.

02:01:43,744 --> 02:01:45,130
And that's what I'm working on,

02:01:45,130 --> 02:01:46,779
that's what I'm trying to get people to do.

02:01:46,779 --> 02:01:48,133
So, that's my pitch.

02:01:48,133 --> 02:01:49,989
If anyone wants to help out.

02:01:49,989 --> 02:01:51,239
Have any ideas?

02:01:54,484 --> 02:01:56,270
It's always hard after the break.

02:01:56,270 --> 02:01:58,360
(audience laughing)

02:01:58,360 --> 02:02:00,199
But that's the idea, that sums up what I'm trying to do.

02:02:00,199 --> 02:02:01,200
So at least the main thing,

02:02:01,200 --> 02:02:03,764
I'm focusing on what I'm trying to go.

02:02:03,764 --> 02:02:07,116
So, if you have ideas, there's also a Linux trace users

02:02:07,116 --> 02:02:08,374
as well if you want.

02:02:08,374 --> 02:02:09,933
I try to post things, announcements,

02:02:09,933 --> 02:02:12,158
if you wanna see, feel free to post announcements

02:02:12,158 --> 02:02:15,016
for you know, Babeltrace on the Linux trace users.

02:02:15,016 --> 02:02:17,255
Or, to get more users, it's open.

02:02:17,255 --> 02:02:20,672
I'm trying to see what else we have next.

02:02:21,951 --> 02:02:23,868
We might be early, but.

02:02:32,491 --> 02:02:34,583
Well it's 12:44, so I have like 10 more minutes.

02:02:34,583 --> 02:02:36,083
(laughs)

02:02:36,083 --> 02:02:37,085
Before we go to the next thing,

02:02:37,085 --> 02:02:38,873
unless, I'll probably hold off

02:02:38,873 --> 02:02:40,905
because I know Babeltrace, or I think BPF trace

02:02:40,905 --> 02:02:42,669
is coming up next or something.

02:02:42,669 --> 02:02:45,088
So I know people are gonna come in at that time,

02:02:45,088 --> 02:02:48,451
because I'm sure this room will probably get crowded there.

02:02:48,451 --> 02:02:51,063
Anything else, we wanna discuss, or is there any ideas?

02:02:51,063 --> 02:02:53,885
'Cause that was basically, what I was trying

02:02:53,885 --> 02:02:55,772
to come up with some ideas and speaking of the man.

02:02:55,772 --> 02:02:59,980
Yeah, do you have the mic over there too?

02:02:59,980 --> 02:03:03,091
- How much does architecture effect

02:03:03,091 --> 02:03:04,125
what you're gonna be able to do

02:03:04,125 --> 02:03:06,034
with the universal interface?

02:03:06,034 --> 02:03:08,885
The underlying hardware that you have available?

02:03:08,885 --> 02:03:12,622
- Well that depends on, like I said,

02:03:12,622 --> 02:03:14,469
ideally I want a lib perf that deals with it.

02:03:14,469 --> 02:03:17,029
I want a lib ftrace that deals with it.

02:03:17,029 --> 02:03:19,586
So the idea, it's kind of like,

02:03:19,586 --> 02:03:23,112
what you showed before and also how Linux is architectured

02:03:23,112 --> 02:03:25,188
or even GCC's architectured.

02:03:25,188 --> 02:03:26,628
A lot of times I say let's look at,

02:03:26,628 --> 02:03:28,230
I use GCC, you have how GCC

02:03:28,230 --> 02:03:30,064
can handle all the different architectures.

02:03:30,064 --> 02:03:33,843
There's, and it compiles it into a single interface,

02:03:33,843 --> 02:03:35,424
and then you could read it.

02:03:35,424 --> 02:03:37,500
Kind of similar with Babeltrace,

02:03:37,500 --> 02:03:41,417
so I wanna API that will then talk to different

02:03:42,417 --> 02:03:47,248
other API's, that will deal with underlying infrastructure.

02:03:47,248 --> 02:03:48,976
So that's what I'm kind of working on,

02:03:48,976 --> 02:03:50,643
trying to figure out how to get together.

02:03:50,643 --> 02:03:52,106
I'm trying to find people who would be interested in it.

02:03:52,106 --> 02:03:53,603
Anyone interested in working on this?

02:03:53,603 --> 02:03:54,436
Yeah...

02:03:56,860 --> 02:03:58,079
- [Audience Member] You might find

02:03:58,079 --> 02:03:59,821
venue tools more interesting,

02:03:59,821 --> 02:04:02,816
or LD in particular, more interesting to look at then GCC.

02:04:02,816 --> 02:04:04,726
Because it can compile in multiple targets at the same time.

02:04:04,726 --> 02:04:07,146
Which you can't do with GCC

02:04:07,146 --> 02:04:09,763
front ends or back ends as far as I'm aware.

02:04:09,763 --> 02:04:11,837
- Okay, well I haven't actually looked at the code.

02:04:11,837 --> 02:04:13,665
I just looked at the idea of it.

02:04:13,665 --> 02:04:15,239
- [Audience Member] Yeah, it's even more unusual

02:04:15,239 --> 02:04:17,224
with shell scripts generating code

02:04:17,224 --> 02:04:19,621
and pasting it together and all sorts of things like that.

02:04:19,621 --> 02:04:21,102
- Yeah, I don't wanna follow that.

02:04:21,102 --> 02:04:24,741
(scattered laughter)

02:04:24,741 --> 02:04:26,163
No, it's basically just saying okay,

02:04:26,163 --> 02:04:28,330
we have the idea, we have a way of,

02:04:28,330 --> 02:04:30,935
I figured out though some of the basic things that we need,

02:04:30,935 --> 02:04:33,518
I'm trying to think of more that you might need, from API.

02:04:33,518 --> 02:04:36,363
So say, perf, I would say does it exist?

02:04:36,363 --> 02:04:38,029
Does perf, is perf enabled?

02:04:38,029 --> 02:04:39,328
Ftrace is it enabled?

02:04:39,328 --> 02:04:43,004
Is LTT enabled, is API, if I had a lib LTTng,

02:04:43,004 --> 02:04:45,087
can I say, does it exist?

02:04:47,201 --> 02:04:48,878
- One thing I'm thinking,

02:04:48,878 --> 02:04:51,942
perhaps there would also be value

02:04:51,942 --> 02:04:53,958
in creating something that does

02:04:53,958 --> 02:04:57,222
more orchestration of tracing across various machines.

02:04:57,222 --> 02:05:00,233
So between a host and a guest,

02:05:00,233 --> 02:05:03,626
but also across various machines

02:05:03,626 --> 02:05:05,783
that are interacting on a cluster.

02:05:05,783 --> 02:05:08,581
And perhaps there might be more value added

02:05:08,581 --> 02:05:10,676
in doing this orchestration

02:05:10,676 --> 02:05:14,249
then doing the unified tracing platform

02:05:14,249 --> 02:05:17,499
from the point of you have a single OS.

02:05:20,939 --> 02:05:23,238
- Yes, actually I've been thinking that too.

02:05:23,238 --> 02:05:24,840
Right now, I'm just trying to say a way

02:05:24,840 --> 02:05:27,014
of just trying to get the actual there.

02:05:27,014 --> 02:05:29,107
But we could also say hey are we at a cloud,

02:05:29,107 --> 02:05:30,976
are we, is there service available?

02:05:30,976 --> 02:05:33,275
We could extend this into services.

02:05:33,275 --> 02:05:36,137
And then build up on that.

02:05:36,137 --> 02:05:38,070
Once we get something unified,

02:05:38,070 --> 02:05:41,239
I think it shouldn't be too hard to extend it.

02:05:41,239 --> 02:05:46,239
Adding another way and then, we have to think about this.

02:05:46,359 --> 02:05:47,192
But...

02:05:48,340 --> 02:05:50,707
Is there any other ideas, other then?

02:05:50,707 --> 02:05:53,100
- Are you trying to, oops,

02:05:53,100 --> 02:05:54,176
(microphone echoing)

02:05:54,176 --> 02:05:55,173
yep, got it, okay.

02:05:55,173 --> 02:05:57,165
Are you trying to do something that's capability based?

02:05:57,165 --> 02:05:58,996
Like you wanna trace sketch switch,

02:05:58,996 --> 02:06:00,256
I don't care which tracer does it,

02:06:00,256 --> 02:06:02,328
I just want all the sketch switches in a file somewhere.

02:06:02,328 --> 02:06:03,750
- Yes, yes, any sketch switch.

02:06:03,750 --> 02:06:05,399
It could determine which one, yeah.

02:06:05,399 --> 02:06:06,530
- Or whatever, yeah. - Okay.

02:06:06,530 --> 02:06:08,481
- So it would use whatever is configured on that system?

02:06:08,481 --> 02:06:10,653
- Yeah, and it'll try, maybe a few

02:06:10,653 --> 02:06:12,098
and figure out which one's the best.

02:06:12,098 --> 02:06:13,723
Or it could be, the API could,

02:06:13,723 --> 02:06:15,372
or maybe you could say I wanna do this one.

02:06:15,372 --> 02:06:16,997
Maybe have a way of saying

02:06:16,997 --> 02:06:18,396
I just care about the ftrace version of it.

02:06:18,396 --> 02:06:20,057
Or do perf version of it.

02:06:20,057 --> 02:06:21,788
Or if I don't care it just finds one.

02:06:21,788 --> 02:06:24,126
So, yes, I kinda wanna abstract out

02:06:24,126 --> 02:06:26,299
people caring about what's going on.

02:06:26,299 --> 02:06:28,009
I mean, you care about what's going on,

02:06:28,009 --> 02:06:32,028
but what's, it's a tool, and I've always said about ftrace,

02:06:32,028 --> 02:06:35,811
ftrace is a second class citizen in the Linux kernel.

02:06:35,811 --> 02:06:37,435
I keep telling people that.

02:06:37,435 --> 02:06:39,793
Ftrace is trying not to be there.

02:06:39,793 --> 02:06:42,288
The important thing is whatever, the work getting done.

02:06:42,288 --> 02:06:45,401
Your database acts, you know, when your customer comes in

02:06:45,401 --> 02:06:47,815
onto your system, and you get a response.

02:06:47,815 --> 02:06:49,360
You do a Google search or something,

02:06:49,360 --> 02:06:50,684
it comes up and you get something real quick.

02:06:50,684 --> 02:06:51,816
That is important.

02:06:51,816 --> 02:06:54,968
The tracing of that is a debugging tool.

02:06:54,968 --> 02:06:56,988
So, it's a utilization tool,

02:06:56,988 --> 02:07:00,111
and people don't care what debugger it is.

02:07:00,111 --> 02:07:02,445
They just care about their reaction to happen

02:07:02,445 --> 02:07:04,540
and just give me something,

02:07:04,540 --> 02:07:06,166
it's not working the way I expected.

02:07:06,166 --> 02:07:07,545
Why?

02:07:07,545 --> 02:07:08,684
They want a utility.

02:07:08,684 --> 02:07:10,676
This is why it doesn't really matter.

02:07:10,676 --> 02:07:12,218
So I always say ftrace is a second class citizen,

02:07:12,218 --> 02:07:14,821
and everything works fine,

02:07:14,821 --> 02:07:16,743
and try to give as much info to people,

02:07:16,743 --> 02:07:20,660
and try to stay out of their way when doing it.

02:07:21,609 --> 02:07:24,103
- I think one of the important things to tackle

02:07:24,103 --> 02:07:25,968
with this unified tracing platform

02:07:25,968 --> 02:07:28,108
is to replicate what is being done

02:07:28,108 --> 02:07:29,711
by tracers on other platforms

02:07:29,711 --> 02:07:33,774
which is basically not requiring people to be kernel experts

02:07:33,774 --> 02:07:35,829
in order to know what events they need to trace.

02:07:35,829 --> 02:07:38,673
So kind of having higher level profile,

02:07:38,673 --> 02:07:42,145
saying I'm interested in IO, I'm interested in scheduling,

02:07:42,145 --> 02:07:44,014
and so forth, and so,

02:07:44,014 --> 02:07:47,874
I think those profiles at this unified tracing platform

02:07:47,874 --> 02:07:49,987
might make sense.

02:07:49,987 --> 02:07:52,344
- Yeah, but that's,

02:07:52,344 --> 02:07:54,074
to me that's the second stage.

02:07:54,074 --> 02:07:57,040
Right now we're looking, yeah it's good to look forward,

02:07:57,040 --> 02:07:59,153
but like, we need to get the lib,

02:07:59,153 --> 02:08:01,609
do you have a lib LTTng?

02:08:01,609 --> 02:08:03,517
- Yeah, LTT, a combo one.

02:08:03,517 --> 02:08:05,249
- Yeah, so you have,

02:08:05,249 --> 02:08:06,327
so if I had a tool that just want to interact,

02:08:06,327 --> 02:08:07,362
I could just write a tool?

02:08:07,362 --> 02:08:08,360
Great.

02:08:08,360 --> 02:08:09,742
I'm working right now on ftrace,

02:08:09,742 --> 02:08:12,342
I need one for perf, BPF might get something,

02:08:12,342 --> 02:08:14,169
well BPF's a little more complicated

02:08:14,169 --> 02:08:15,367
because that's writing scripts

02:08:15,367 --> 02:08:16,731
and tools and stuff like that.

02:08:16,731 --> 02:08:19,387
But having something that could implement all this stuff

02:08:19,387 --> 02:08:22,948
and I'm trying to get it so the user doesn't care

02:08:22,948 --> 02:08:24,225
what tracer they're using.

02:08:24,225 --> 02:08:28,572
So if it's there, it's our job to make it easy for them,

02:08:28,572 --> 02:08:30,158
and we should be working together

02:08:30,158 --> 02:08:31,639
to try to make sure that that's,

02:08:31,639 --> 02:08:33,391
the features are there and not be fighting,

02:08:33,391 --> 02:08:35,400
oh I want LTT, oh I want BPF, or oh I want,

02:08:35,400 --> 02:08:37,577
you know, that's just squabbling among us.

02:08:37,577 --> 02:08:40,195
And it makes great LWN articles,

02:08:40,195 --> 02:08:41,862
but other than that.

02:08:43,444 --> 02:08:46,351
Let's see here, I still have six minutes to waste.

02:08:46,351 --> 02:08:48,601
(laughing)

02:08:49,538 --> 02:08:51,573
I would jump ahead, like I said,

02:08:51,573 --> 02:08:53,546
if Brendan Gregg, I think you're next, right Brendan?

02:08:53,546 --> 02:08:56,025
- [Brendan] No, I'm not next.

02:08:56,025 --> 02:08:57,037
- You're not next?

02:08:57,037 --> 02:08:59,293
Who's next? - He's at the end.

02:08:59,293 --> 02:09:00,634
- What was it?

02:09:00,634 --> 02:09:02,097
- He's just before lunch.

02:09:02,097 --> 02:09:03,599
- [Audience Member] Actually you're next.

02:09:03,599 --> 02:09:06,218
- No, actually, I'm in my field right now.

02:09:06,218 --> 02:09:10,718
(background noise drowns out speaker)

02:09:12,056 --> 02:09:13,234
- [Audience Member] I think he just

02:09:13,234 --> 02:09:14,694
stepped out to use the bathroom.

02:09:14,694 --> 02:09:16,305
- Well actually, yeah,

02:09:16,305 --> 02:09:19,573
'cause I'm supposed to be till 12:44,

02:09:19,573 --> 02:09:21,384
although I think I, yeah,

02:09:21,384 --> 02:09:24,432
so it's, I have five more minutes, yes.

02:09:24,432 --> 02:09:26,053
- Oh sorry, stretching.

02:09:26,053 --> 02:09:27,681
- I keep looking over at you,

02:09:27,681 --> 02:09:29,244
because I'm waiting for you to comment on something.

02:09:29,244 --> 02:09:32,658
Anything else, anyone else have any

02:09:32,658 --> 02:09:34,539
questions, concerns, help?

02:09:34,539 --> 02:09:35,929
Yes.

02:09:35,929 --> 02:09:38,544
- [Audience Member] You talked about

02:09:38,544 --> 02:09:40,053
not wanting to create noise at the bottom end.

02:09:40,053 --> 02:09:41,661
One of the things that tends to create noise

02:09:41,661 --> 02:09:42,857
especially in tracing,

02:09:42,857 --> 02:09:46,690
is the cache effects, especially at high rate,

02:09:47,611 --> 02:09:51,217
how do you try and address those in a universal way?

02:09:51,217 --> 02:09:54,421
- Well that's not up to the universal tracing platform

02:09:54,421 --> 02:09:55,738
to address that,

02:09:55,738 --> 02:09:58,054
that's up to the tracers themselves to address that

02:09:58,054 --> 02:09:59,842
and do you have any ideas on how best

02:09:59,842 --> 02:10:01,572
to handle cache, well I mean,

02:10:01,572 --> 02:10:04,028
we tried, that's always been an issue.

02:10:04,028 --> 02:10:05,531
(laughs)

02:10:05,531 --> 02:10:07,502
I've seen the effects, I mean one time,

02:10:07,502 --> 02:10:10,512
weirdly, when I first enabled trace events in the kernel,

02:10:10,512 --> 02:10:14,268
and with the trace points and everything else,

02:10:14,268 --> 02:10:16,909
where it would actually inject code at the bottom.

02:10:16,909 --> 02:10:19,319
You know, it doesn't, an unlikely's,

02:10:19,319 --> 02:10:22,211
we had, the way trace events work,

02:10:22,211 --> 02:10:24,450
is the fact that there's just a no op there,

02:10:24,450 --> 02:10:27,509
and we use jump labels to actually convert the no op

02:10:27,509 --> 02:10:28,937
to jump to the tracing code,

02:10:28,937 --> 02:10:30,680
but the tracing code is, when you create a trace event,

02:10:30,680 --> 02:10:32,408
or a trace point actually,

02:10:32,408 --> 02:10:33,462
when you create a trace point,

02:10:33,462 --> 02:10:36,391
you're actually injecting code into the hot path,

02:10:36,391 --> 02:10:38,463
or into, well it's not the hot path,

02:10:38,463 --> 02:10:40,037
but into those functions at the bottom of those functions.

02:10:40,037 --> 02:10:42,062
So we use the unlikely, so GCC will actually move 'em

02:10:42,062 --> 02:10:44,458
out of the way so they're always,

02:10:44,458 --> 02:10:46,369
you just have a no op at the bottom of the functions.

02:10:46,369 --> 02:10:48,090
But if you have multiple functions,

02:10:48,090 --> 02:10:49,783
it's going to put a gap between 'em.

02:10:49,783 --> 02:10:52,319
And I wanted to see what the cache effect was,

02:10:52,319 --> 02:10:55,123
of trace events, so I compiled.

02:10:55,123 --> 02:10:58,357
I turned off all tracing, so no trace events was there.

02:10:58,357 --> 02:11:01,828
Ran hack bench like a hundred times,

02:11:01,828 --> 02:11:03,678
took a bunch of average number of it.

02:11:03,678 --> 02:11:06,159
Enabled trace events with it off.

02:11:06,159 --> 02:11:08,245
Ran hack bench a bunch of times,

02:11:08,245 --> 02:11:10,745
and it got about 2% speed up.

02:11:10,745 --> 02:11:13,246
(scattered laughter)

02:11:13,246 --> 02:11:17,351
And I did it multiple times and I got the same effect,

02:11:17,351 --> 02:11:19,543
I went what the hell, it just happened

02:11:19,543 --> 02:11:21,884
to move the cache better.

02:11:21,884 --> 02:11:23,644
- The note is the same thing,

02:11:23,644 --> 02:11:25,721
but when you do actual useful tracing,

02:11:25,721 --> 02:11:27,855
you end up writing in ring buffer,

02:11:27,855 --> 02:11:29,727
in our postal sitting approaches.

02:11:29,727 --> 02:11:32,507
And this, I mean, if you are the shared ring buffer

02:11:32,507 --> 02:11:34,940
between CPU's you will destroy your systems performance.

02:11:34,940 --> 02:11:37,651
So per CPU approach is good,

02:11:37,651 --> 02:11:40,333
but then you have to size a ring buffer correctly

02:11:40,333 --> 02:11:42,685
so I mean you might want to hit the cache rather than memory

02:11:42,685 --> 02:11:44,373
and things like that.

02:11:44,373 --> 02:11:47,417
- And as I predicted, the room is filling up,

02:11:47,417 --> 02:11:49,167
waiting for the next.

02:11:52,421 --> 02:11:53,514
So we got two more, well actually we can start,

02:11:53,514 --> 02:11:56,197
who's, where, there he is.

02:11:56,197 --> 02:11:58,433
I guess you could take.

02:11:58,433 --> 02:11:59,936
- Oh, right here?

02:11:59,936 --> 02:12:01,019
- That works.

02:12:03,536 --> 02:12:04,731
- So thank you.

02:12:04,731 --> 02:12:07,898
(audience applauding)

02:12:11,001 --> 02:12:13,334
Just put it there, anywhere.

02:12:14,379 --> 02:12:17,546
(audience chattering)

02:12:22,488 --> 02:12:24,405
Careful with the cable.

02:12:25,455 --> 02:12:26,447
- I'm not sure if you have one?

02:12:26,447 --> 02:12:27,462
- Yes, thank you.

02:12:27,462 --> 02:12:28,965
- [Audience Member] I didn't know we

02:12:28,965 --> 02:12:29,798
did the glasses, in the D and E.

02:12:29,798 --> 02:12:30,877
- [Steve] Oh yeah, watch the glasses,

02:12:30,877 --> 02:12:32,502
whose glass, whose water glass is this?

02:12:32,502 --> 02:12:33,823
Was that yours?

02:12:33,823 --> 02:12:34,749
- [Man] Yeah, that's mine.

02:12:34,749 --> 02:12:35,582
- [Steve] Oh, that's yours, okay.

02:12:35,582 --> 02:12:36,978
- [Man] Yeah, just don't kick it.

02:12:36,978 --> 02:12:37,970
- [Steve] Yes.

02:12:37,970 --> 02:12:41,137
(audience chattering)

02:12:47,218 --> 02:12:48,965
- Do we have any others up next?

02:12:48,965 --> 02:12:51,215
I've got the new Mac, here.

02:12:52,477 --> 02:12:54,654
(background noise drowns out speaker)

02:12:54,654 --> 02:12:55,687
- Yes.

02:12:55,687 --> 02:12:58,942
- Okay, who has USB-C to HDMI?

02:12:58,942 --> 02:13:01,707
USB-C to HDMI, who has one?

02:13:01,707 --> 02:13:02,624
Right here.

02:13:04,327 --> 02:13:07,660
(people chattering)

02:15:04,424 --> 02:15:05,257
- All right ready?

02:15:05,257 --> 02:15:06,090
- [Man] Yep.

02:15:06,090 --> 02:15:06,923
- Okay, good.

02:15:06,923 --> 02:15:09,382
Hello everyone, my name is Alastair Robertson

02:15:09,382 --> 02:15:11,819
and I'm gonna be talking about BPF trace today.

02:15:11,819 --> 02:15:14,914
But before we get started, I made a promise to my boss

02:15:14,914 --> 02:15:16,597
that I would plug my company,

02:15:16,597 --> 02:15:19,506
Yellowbrick Data, because they have very kindly

02:15:19,506 --> 02:15:21,027
paid for me to come here to this conference this whole week

02:15:21,027 --> 02:15:23,790
despite it having nothing to do with my day job.

02:15:23,790 --> 02:15:27,998
And so Yellowbrick is an all-flash SQL database

02:15:27,998 --> 02:15:30,251
designed for very quickly processing

02:15:30,251 --> 02:15:32,155
complex analytical queries

02:15:32,155 --> 02:15:33,905
on petabytes of data.

02:15:36,021 --> 02:15:37,503
So okay, on to bpftrace,

02:15:37,503 --> 02:15:41,078
bpftrace is a project which I started in my spare time

02:15:41,078 --> 02:15:43,643
just under three years ago now.

02:15:43,643 --> 02:15:45,324
(microphone reverberating)

02:15:45,324 --> 02:15:47,407
(laughs)

02:15:50,078 --> 02:15:51,346
And for those who don't know,

02:15:51,346 --> 02:15:53,581
it's a high-level tracing language for Linux.

02:15:53,581 --> 02:15:55,974
Surprisingly enough, powered by BPF.

02:15:55,974 --> 02:15:59,067
More specifically it uses the newer features

02:15:59,067 --> 02:16:01,725
that have gone into BPF over the last several years.

02:16:01,725 --> 02:16:04,973
The stuff that is sometimes known as eBPF,

02:16:04,973 --> 02:16:07,130
or the enhanced Berkeley Packet Filter.

02:16:07,130 --> 02:16:09,243
I'm not going to talk about BPF,

02:16:09,243 --> 02:16:11,420
the internals of BPF today,

02:16:11,420 --> 02:16:13,411
if you're interested in that, I'm sure you already know,

02:16:13,411 --> 02:16:15,686
but there's the BPF micro conference on Wednesday,

02:16:15,686 --> 02:16:17,204
where people probably do that stuff.

02:16:17,204 --> 02:16:19,320
So today, what I am going to go over,

02:16:19,320 --> 02:16:22,124
is first give a brief introduction to bpftrace,

02:16:22,124 --> 02:16:24,138
just to make sure we're all

02:16:24,138 --> 02:16:25,655
on the same page about what it is.

02:16:25,655 --> 02:16:27,407
Later on, we'll talk about

02:16:27,407 --> 02:16:29,010
what I've been working on the past year

02:16:29,010 --> 02:16:32,161
and our plans for the future.

02:16:32,161 --> 02:16:35,272
So, if you install bpftrace,

02:16:35,272 --> 02:16:37,602
you get a command line interface to it,

02:16:37,602 --> 02:16:39,556
a command line tool, bpftrace.

02:16:39,556 --> 02:16:43,115
You can use the dash e option, and then pass a string

02:16:43,115 --> 02:16:45,714
containing your BPF tracing program.

02:16:45,714 --> 02:16:49,779
Same kind of thing as orc dash e script.

02:16:49,779 --> 02:16:52,988
So bpftrace script consists of three main parts,

02:16:52,988 --> 02:16:55,224
first you always have a probe definition

02:16:55,224 --> 02:16:58,191
that just says what events you want to be tracing

02:16:58,191 --> 02:17:00,019
on your computer.

02:17:00,019 --> 02:17:02,393
Secondly, between a pair of forward slashes,

02:17:02,393 --> 02:17:03,878
you have an optional predicate,

02:17:03,878 --> 02:17:06,764
which is just an expression if it evaluates to true,

02:17:06,764 --> 02:17:08,610
we continue and execute our probe,

02:17:08,610 --> 02:17:11,004
if it develops to false we just ignore this event.

02:17:11,004 --> 02:17:13,630
And finally, we've got the action block

02:17:13,630 --> 02:17:16,111
which is a series of statements

02:17:16,111 --> 02:17:18,340
that just define what actions we want to take

02:17:18,340 --> 02:17:20,499
when our event files.

02:17:20,499 --> 02:17:23,113
So in this case, we're attaching to a k probe,

02:17:23,113 --> 02:17:26,403
which means we attach to a function inside the Linux kernel.

02:17:26,403 --> 02:17:29,723
So every time the do fork function is run inside Linux,

02:17:29,723 --> 02:17:32,405
if it comes from a post qresql process,

02:17:32,405 --> 02:17:36,225
then we print hello back to visa, simple.

02:17:36,225 --> 02:17:40,184
Print f in this example, is a bpftrace built in function.

02:17:40,184 --> 02:17:43,353
There's actually a whole load of them,

02:17:43,353 --> 02:17:44,857
for various types of outputs

02:17:44,857 --> 02:17:47,034
or forming internal aggregations

02:17:47,034 --> 02:17:49,123
like histograms or statistics.

02:17:49,123 --> 02:17:51,707
We've got a bunch of built in variables as well

02:17:51,707 --> 02:17:53,937
to get process ID, time stamps,

02:17:53,937 --> 02:17:58,104
anything you might find useful when doing tracing.

02:17:59,201 --> 02:18:01,900
There's a number of different probe types we can attach to.

02:18:01,900 --> 02:18:03,671
I've talked about kprobe's already,

02:18:03,671 --> 02:18:06,271
uprobes are equivalent to attach to any UserLAnd function,

02:18:06,271 --> 02:18:08,280
we can also attach to UserLAnd

02:18:08,280 --> 02:18:10,393
statically defined trace points.

02:18:10,393 --> 02:18:12,461
Kernel trace points and various perf events

02:18:12,461 --> 02:18:14,416
like timers, software events, hardware events,

02:18:14,416 --> 02:18:16,686
and watchpoints are a new one as well.

02:18:16,686 --> 02:18:18,520
Each of these probe types,

02:18:18,520 --> 02:18:20,972
as well as a few other bpftrace features,

02:18:20,972 --> 02:18:23,518
has slightly different kernel version requirements

02:18:23,518 --> 02:18:26,606
just depending on when the ability to attach BPF programs

02:18:26,606 --> 02:18:28,980
to these events was added to Linux.

02:18:28,980 --> 02:18:32,516
So technically you can start using bpftrace

02:18:32,516 --> 02:18:33,880
with a Linux 4.1,

02:18:33,880 --> 02:18:37,578
to trace some kprobes, although you might,

02:18:37,578 --> 02:18:40,056
there would be a lot of missing features there.

02:18:40,056 --> 02:18:41,641
So the more recent kernel version you're using,

02:18:41,641 --> 02:18:43,443
the more features you're gonna get,

02:18:43,443 --> 02:18:44,729
better experiences you'll have.

02:18:44,729 --> 02:18:49,062
This one here is a slightly more complicated example

02:18:50,801 --> 02:18:52,346
of a bpftrace script.

02:18:52,346 --> 02:18:54,604
What it's doing is attaching to a kernel trace point

02:18:54,604 --> 02:18:58,261
and we've got a wild card up there,

02:18:58,261 --> 02:19:00,614
so attaching to every kernel trace point

02:19:00,614 --> 02:19:03,863
that starts in the sys call, sys enter, star.

02:19:03,863 --> 02:19:05,982
So it's attaching to every system call on your computer.

02:19:05,982 --> 02:19:09,649
And we're defining a BPF map, with my count.

02:19:10,544 --> 02:19:14,207
Which is keyed on the exact probe name,

02:19:14,207 --> 02:19:15,856
so sys read or sys write.

02:19:15,856 --> 02:19:18,840
And we count it with producing an individual count

02:19:18,840 --> 02:19:20,610
for every system call.

02:19:20,610 --> 02:19:22,682
So this script here is essentially like ftrace dash C,

02:19:22,682 --> 02:19:25,080
that system wide count of system calls.

02:19:25,080 --> 02:19:27,437
When you control C your bpftrace program

02:19:27,437 --> 02:19:29,933
it dumps out all the information

02:19:29,933 --> 02:19:31,744
it's aggregated inside the kernel

02:19:31,744 --> 02:19:33,265
back to UserLAnd for reading,

02:19:33,265 --> 02:19:34,522
you get something like this.

02:19:34,522 --> 02:19:37,352
So that was my very brief introduction to bpftrace.

02:19:37,352 --> 02:19:39,912
If you are interested in learning more,

02:19:39,912 --> 02:19:43,221
there's documentation on our get up repository.

02:19:43,221 --> 02:19:45,252
We've got a one-liner tutorial,

02:19:45,252 --> 02:19:46,675
a full reference guide

02:19:46,675 --> 02:19:48,381
with descriptions of every feature of the language,

02:19:48,381 --> 02:19:50,517
Brendan has written a lot of blog posts about it.

02:19:50,517 --> 02:19:53,807
And there's a number of bpftrace contributors

02:19:53,807 --> 02:19:55,788
in the room today, so feel free

02:19:55,788 --> 02:19:58,788
to come and talk to any of us later.

02:19:59,623 --> 02:20:01,243
So now, for what we've been doing

02:20:01,243 --> 02:20:02,830
in bpftrace in the past year.

02:20:02,830 --> 02:20:05,308
Actually, what we've been doing in bpftrace

02:20:05,308 --> 02:20:07,050
since the last Linux Plumbers

02:20:07,050 --> 02:20:10,016
which was November 2018, so not quite a year.

02:20:10,016 --> 02:20:13,703
Because that was when Mattias Marchini,

02:20:13,703 --> 02:20:15,467
another bpftrace maintainer gave a talk

02:20:15,467 --> 02:20:17,384
back in Vancouver then.

02:20:18,271 --> 02:20:21,400
So since then, we've had 298 pull requests

02:20:21,400 --> 02:20:23,281
merged in from 48 individuals.

02:20:23,281 --> 02:20:25,487
Changing over 20,000 lines of code.

02:20:25,487 --> 02:20:28,047
All of it being in tests and documentation.

02:20:28,047 --> 02:20:29,711
Bpftrace being packaged

02:20:29,711 --> 02:20:32,737
on a bunch of popular Linux distributions

02:20:32,737 --> 02:20:36,737
and it's also available, and it's being built and packaged

02:20:36,737 --> 02:20:39,523
internally at a number of large companies,

02:20:39,523 --> 02:20:41,878
made available for employees too.

02:20:41,878 --> 02:20:43,082
So all of these packages,

02:20:43,082 --> 02:20:44,661
both open source and internal companies

02:20:44,661 --> 02:20:47,098
mean that it's easier than ever

02:20:47,098 --> 02:20:48,544
for people to start using bpftrace,

02:20:48,544 --> 02:20:51,812
and I imagine it's growth is going to continue to accelerate

02:20:51,812 --> 02:20:53,596
over the next year.

02:20:53,596 --> 02:20:57,276
So now I've just got a list of a few big features

02:20:57,276 --> 02:20:59,655
that went in since November

02:20:59,655 --> 02:21:01,317
last year I wanted to talk about.

02:21:01,317 --> 02:21:05,547
First one is our compiler now has error context.

02:21:05,547 --> 02:21:08,330
We record what line number the error message is on,

02:21:08,330 --> 02:21:09,999
carrot division that line,

02:21:09,999 --> 02:21:11,784
and we print out and underline

02:21:11,784 --> 02:21:13,372
where the offending code is.

02:21:13,372 --> 02:21:15,132
If you're just writing simple one liners

02:21:15,132 --> 02:21:17,168
it's not too big of a problem if there's no context,

02:21:17,168 --> 02:21:18,916
but as people start writing

02:21:18,916 --> 02:21:21,923
more complicated bpftrace scripts and reusable tools,

02:21:21,923 --> 02:21:23,833
then it can become a bit of a nightmare

02:21:23,833 --> 02:21:25,539
if there's no line numbers.

02:21:25,539 --> 02:21:30,039
So that's just a non controversial improvement, there.

02:21:33,817 --> 02:21:36,290
Bpftrace has always had unit tests,

02:21:36,290 --> 02:21:38,479
but there was no end to end testing.

02:21:38,479 --> 02:21:42,830
So we've produced our own Python based test library

02:21:42,830 --> 02:21:46,181
and our own test definition format.

02:21:46,181 --> 02:21:48,155
It makes it very easy to write

02:21:48,155 --> 02:21:50,390
full end to end tests so we can be more sure

02:21:50,390 --> 02:21:52,950
when we're developing bpftrace, that nothing breaks.

02:21:52,950 --> 02:21:56,783
Now onto more user divisible tracing features.

02:21:58,210 --> 02:22:01,127
Bpftrace has now got native support

02:22:02,465 --> 02:22:06,075
for IP addresses, both IPv4 and IPv6.

02:22:06,075 --> 02:22:09,075
Using the new n2p built in function,

02:22:11,172 --> 02:22:14,017
you could specify what type of IP address it is,

02:22:14,017 --> 02:22:16,206
we have data withholding IP address

02:22:16,206 --> 02:22:18,040
and it produces a human readable string.

02:22:18,040 --> 02:22:21,679
So this just makes it a lot easier to write tracing tools

02:22:21,679 --> 02:22:24,605
that trace networking applications,

02:22:24,605 --> 02:22:26,654
and we've got a number of new ones

02:22:26,654 --> 02:22:28,669
that have been added to our repository.

02:22:28,669 --> 02:22:30,782
May take advantage of it already.

02:22:30,782 --> 02:22:35,782
- [Audience Member] Other sorts, about the previous slide?

02:22:35,800 --> 02:22:36,682
- Yeah, the testing. - [Steve] Microphone.

02:22:36,682 --> 02:22:38,799
- Yeah have you considered using

02:22:38,799 --> 02:22:41,132
something standard like TAP?

02:22:44,344 --> 02:22:46,566
- I've not actually been too involved in the testing bits.

02:22:46,566 --> 02:22:50,350
I haven't heard of TAP so I'm sorry.

02:22:50,350 --> 02:22:54,510
You think it would suitable for this kind of testing?

02:22:54,510 --> 02:22:55,501
- [Audience Member[ I think you need

02:22:55,501 --> 02:22:56,870
to structure the app for--

02:22:56,870 --> 02:22:59,825
- [Man] It's perfect, and it can run them for you.

02:22:59,825 --> 02:23:04,042
It's not, it doesn't construe the inverse in a way.

02:23:04,042 --> 02:23:05,349
- TAP?

02:23:05,349 --> 02:23:09,349
- Yeah, you can output, trace out to the output.

02:23:10,422 --> 02:23:12,388
- [Man] (whispering) What are you doing?

02:23:12,388 --> 02:23:15,055
- Yeah, it's worth looking into.

02:23:19,561 --> 02:23:21,165
Okay, this is another one I touched on briefly earlier.

02:23:21,165 --> 02:23:25,748
A new watchpoint probe type is being added to bpftrace,

02:23:26,591 --> 02:23:30,003
that allows you to essentially watch a piece of memory.

02:23:30,003 --> 02:23:31,938
You give it a memory address

02:23:31,938 --> 02:23:33,807
and link this memory block,

02:23:33,807 --> 02:23:35,432
and whether you want to watch

02:23:35,432 --> 02:23:36,733
for read events or write events

02:23:36,733 --> 02:23:38,968
then when that block memory is changed,

02:23:38,968 --> 02:23:40,715
of read files.

02:23:40,715 --> 02:23:44,144
So this one is both work that has been done

02:23:44,144 --> 02:23:46,498
and work that needs to be done in the future.

02:23:46,498 --> 02:23:49,062
As obviously specifying memory addresses like this

02:23:49,062 --> 02:23:50,806
isn't ideal for users.

02:23:50,806 --> 02:23:52,516
You'd want to just put the name of a variable

02:23:52,516 --> 02:23:54,243
or something like that in there

02:23:54,243 --> 02:23:56,417
and bpftrace will automatically look up its address

02:23:56,417 --> 02:23:58,350
and how big the variable

02:23:58,350 --> 02:24:01,191
and so the users don't have to

02:24:01,191 --> 02:24:02,453
mess around with text addresses.

02:24:02,453 --> 02:24:05,200
- Question too, also, is this

02:24:05,200 --> 02:24:07,981
I mean, bpftrace I take it it's user only?

02:24:07,981 --> 02:24:09,137
- [Alastair] Yes.

02:24:09,137 --> 02:24:11,981
- Okay, so then you should have like proc kl sims

02:24:11,981 --> 02:24:14,198
or you would take, I guess from user space?

02:24:14,198 --> 02:24:15,196
- Yeah, yeah

02:24:15,196 --> 02:24:18,708
we do use proc kl sims for k probes and stuff.

02:24:18,708 --> 02:24:22,226
- Yeah, because proc kl sims, I believe it has,

02:24:22,226 --> 02:24:24,258
does variables exist?

02:24:24,258 --> 02:24:26,226
I believe variables are.

02:24:26,226 --> 02:24:27,791
Are they?

02:24:27,791 --> 02:24:28,948
No they're not, no they're not.

02:24:28,948 --> 02:24:30,450
They're just functions are they?

02:24:30,450 --> 02:24:32,060
- They have global variables.

02:24:32,060 --> 02:24:33,440
- Global variables?

02:24:33,440 --> 02:24:34,904
Yeah global variables, I guess if, yeah.

02:24:34,904 --> 02:24:35,737
So.

02:24:37,627 --> 02:24:39,107
But then again, you might have trouble

02:24:39,107 --> 02:24:40,878
with the non-global variables

02:24:40,878 --> 02:24:42,706
if you want a watchpoint or something that's...

02:24:42,706 --> 02:24:44,454
- Local variables might be in there too.

02:24:44,454 --> 02:24:45,537
But they're--

02:24:46,377 --> 02:24:47,867
- Well, well, yeah but then you have a lot of duplicates.

02:24:47,867 --> 02:24:49,644
What I'm saying is local variables might be variable

02:24:49,644 --> 02:24:51,199
what I'm saying is if you have,

02:24:51,199 --> 02:24:52,032
most of the times I tried,

02:24:52,032 --> 02:24:53,312
that's right I tried using KL sims once

02:24:53,312 --> 02:24:56,229
for one of the kprobes things I did

02:24:57,272 --> 02:24:58,595
and I found out that there's actually

02:24:58,595 --> 02:25:00,423
a very limited amount of global variables

02:25:00,423 --> 02:25:02,559
most of the things you care about are not global.

02:25:02,559 --> 02:25:04,709
Like, I wanna see this variable,

02:25:04,709 --> 02:25:06,013
oh it's like allocated and it's,

02:25:06,013 --> 02:25:09,996
allocated at run time and you gotta go out and find it

02:25:09,996 --> 02:25:11,467
and that's not in KL sims.

02:25:11,467 --> 02:25:12,689
I guess that's what.

02:25:12,689 --> 02:25:14,390
- I think it's missing known exportage.

02:25:14,390 --> 02:25:16,873
It's missing not exported photo symbols.

02:25:16,873 --> 02:25:19,899
- Oh it's missing, no I think, I think there's some.

02:25:19,899 --> 02:25:21,362
No, they should, they're there.

02:25:21,362 --> 02:25:23,375
- They're there,

02:25:23,375 --> 02:25:24,717
you can't have like 12 local variables

02:25:24,717 --> 02:25:26,546
you can have it static,

02:25:26,546 --> 02:25:28,322
I think the static variables are there.

02:25:28,322 --> 02:25:29,326
- Okay cool.

02:25:29,326 --> 02:25:31,845
- Right, static variables are there.

02:25:31,845 --> 02:25:32,929
I have to repeat what you just said.

02:25:32,929 --> 02:25:34,464
So yeah, so you have static variables are there,

02:25:34,464 --> 02:25:35,706
but yeah, I think that's--

02:25:35,706 --> 02:25:36,844
- Yeah, yeah,

02:25:36,844 --> 02:25:37,677
so I was actually talking

02:25:37,677 --> 02:25:38,626
to some of the Facebook guys yesterday

02:25:38,626 --> 02:25:40,710
and I heard there might be some problems,

02:25:40,710 --> 02:25:42,534
was that along that line of stuff

02:25:42,534 --> 02:25:43,611
that you were thinking of?

02:25:43,611 --> 02:25:45,278
- [Audience Member] Yeah, so local variables--

02:25:45,278 --> 02:25:46,521
- Oh, um, do you have a mic?

02:25:46,521 --> 02:25:47,712
Mic?

02:25:47,712 --> 02:25:48,935
Does someone else have a?

02:25:48,935 --> 02:25:50,317
Where's the other throwable mic?

02:25:50,317 --> 02:25:52,105
Is that one back there or did it?

02:25:52,105 --> 02:25:54,355
We should have another one.

02:25:57,086 --> 02:25:58,886
- [Audience Member] Hello, okay cool,

02:25:58,886 --> 02:26:00,394
yeah local variables are tricky

02:26:00,394 --> 02:26:02,734
because for BPF tracing you know the--

02:26:02,734 --> 02:26:03,994
- [Steve] Please stand up.

02:26:03,994 --> 02:26:05,025
Stand up so we can see you.

02:26:05,025 --> 02:26:06,757
- Oh sorry.

02:26:06,757 --> 02:26:09,314
So local variables are tricky because for BPF tracing

02:26:09,314 --> 02:26:11,426
you know the virtual address ahead of time

02:26:11,426 --> 02:26:13,316
and you don't really have access to the frame pointer.

02:26:13,316 --> 02:26:15,490
So even if you had the off set from the door stuff,

02:26:15,490 --> 02:26:18,170
it may be really tricky to get the frame pointer on,

02:26:18,170 --> 02:26:21,443
just to get the offset into like a normal function.

02:26:21,443 --> 02:26:24,044
So I'm not really sure what to do about that.

02:26:24,044 --> 02:26:25,896
You could do like some crazy stuff

02:26:25,896 --> 02:26:27,901
with like attach a probe to that entry point of the function

02:26:27,901 --> 02:26:30,342
grab the faring pointer, calculate the offset,

02:26:30,342 --> 02:26:31,705
and install another probe.

02:26:31,705 --> 02:26:33,169
But then you could race with it,

02:26:33,169 --> 02:26:36,275
and you can't really pause execution in a BPF program.

02:26:36,275 --> 02:26:39,607
You can't install another probe in BPF program context.

02:26:39,607 --> 02:26:42,393
- Yeah, but they could easily be multiple through--

02:26:42,393 --> 02:26:45,075
- [Steve] Ah, wait, mic.

02:26:45,075 --> 02:26:45,908
- Here.

02:26:47,049 --> 02:26:48,240
- [Audience Member] They could easily be multiple

02:26:48,240 --> 02:26:49,830
simultaneously live instances

02:26:49,830 --> 02:26:51,639
at a given local variable, so even then,

02:26:51,639 --> 02:26:54,195
you have problems if what it was recurser,

02:26:54,195 --> 02:26:55,925
you're gonna be repeatedly installing a probe

02:26:55,925 --> 02:26:57,629
at the same address.

02:26:57,629 --> 02:26:59,338
It's a flaming nightmare.

02:26:59,338 --> 02:27:01,428
- [Steve] We don't do recursors in the kernel.

02:27:01,428 --> 02:27:02,485
We try not to.

02:27:02,485 --> 02:27:04,052
- Oh, I'm sure it happens.

02:27:04,052 --> 02:27:05,352
It happens in every software system.

02:27:05,352 --> 02:27:06,851
(laughing)

02:27:06,851 --> 02:27:07,847
- It's always limited.

02:27:07,847 --> 02:27:11,347
- Oh yes, it's still it's non zero though.

02:27:14,252 --> 02:27:15,894
- Yeah, for local variables it looks

02:27:15,894 --> 02:27:17,415
like it's gonna be really hairy.

02:27:17,415 --> 02:27:19,186
So I'm gonna probably do the global stuff first

02:27:19,186 --> 02:27:20,847
and then see if I get any inspiration.

02:27:20,847 --> 02:27:22,847
I don't know, maybe not.

02:27:26,883 --> 02:27:28,143
- [Audience Member] I noticed

02:27:28,143 --> 02:27:29,710
that you are not including a C file.

02:27:29,710 --> 02:27:30,627
I see here.

02:27:31,882 --> 02:27:33,042
- [Was that on a previous slide?

02:27:33,042 --> 02:27:34,302
- [Audience Member] Yes.

02:27:34,302 --> 02:27:35,135
- [Alistair] Oh yes there.

02:27:35,135 --> 02:27:35,968
- So how does this work,

02:27:35,968 --> 02:27:38,487
are you compiling the probe definition into C code

02:27:38,487 --> 02:27:42,754
and then building it with, comparing it to BPF?

02:27:42,754 --> 02:27:46,410
- No, no, so what happens is we use lib climb internally

02:27:46,410 --> 02:27:49,823
and lib climb pauses the includes and structs,

02:27:49,823 --> 02:27:52,361
and converts it into a format that bpftrace understands.

02:27:52,361 --> 02:27:53,888
And then---

02:27:53,888 --> 02:27:54,880
- [Audience Member] And what format is that?

02:27:54,880 --> 02:27:56,814
- Just an entire bpftrace thing.

02:27:56,814 --> 02:27:58,050
- [Audience Member] Okay.

02:27:58,050 --> 02:28:02,294
- So wait, is that a, is that then that socket that,

02:28:02,294 --> 02:28:04,859
so that's coming from the kernel itself?

02:28:04,859 --> 02:28:07,094
- Yeah, yeah, that's just standard kernel headers.

02:28:07,094 --> 02:28:08,650
Yeah.

02:28:08,650 --> 02:28:12,147
- Until BTF, because Jiri's still on the--

02:28:12,147 --> 02:28:15,397
- We have BTF support, did we merge it?

02:28:17,000 --> 02:28:18,057
- [Alistair] As a pull request, it hasn't been merged yet.

02:28:18,057 --> 02:28:20,251
- So we have a pull request for BTF support

02:28:20,251 --> 02:28:24,584
so we can just use BTF for that information instead.

02:28:27,680 --> 02:28:29,133
In fact, Jiri might be here somewhere,

02:28:29,133 --> 02:28:30,410
so we can talk to him about it.

02:28:30,410 --> 02:28:31,243
- Yes.

02:28:32,447 --> 02:28:33,341
- [Jiri] Yeah hi.

02:28:33,341 --> 02:28:34,601
- Oh (laughs)

02:28:34,601 --> 02:28:35,884
- Thanks Jiri.

02:28:35,884 --> 02:28:37,022
- So one question there Brendan,

02:28:37,022 --> 02:28:40,412
so with PTF support, does that mean that aug zero

02:28:40,412 --> 02:28:43,036
will automatically know that is a struct SOCK?

02:28:43,036 --> 02:28:45,270
- So we haven't merged it yet,

02:28:45,270 --> 02:28:49,131
but I would like there to be another type,

02:28:49,131 --> 02:28:50,850
'cause aug zero is also a UN 64 type,

02:28:50,850 --> 02:28:53,883
so I'd like there to be a different type of aug zero.

02:28:53,883 --> 02:28:56,120
So like, aug zero underscore t,

02:28:56,120 --> 02:28:57,925
to say a typed aug zero,

02:28:57,925 --> 02:29:00,305
using BTF so that it knows the type.

02:29:00,305 --> 02:29:03,612
And so you could then choose to write programs

02:29:03,612 --> 02:29:06,319
that so you didn't have to cast things like we're doing here

02:29:06,319 --> 02:29:08,902
because it would know the type.

02:29:09,855 --> 02:29:13,549
- So that our BTF can, BT or CTF which one?

02:29:13,549 --> 02:29:14,828
- BTF.

02:29:14,828 --> 02:29:15,950
BPF type format.

02:29:15,950 --> 02:29:17,247
(laughing)

02:29:17,247 --> 02:29:21,247
- Okay, is that include somewhere, uh let's see,

02:29:23,670 --> 02:29:25,920
augment names or just type?

02:29:27,937 --> 02:29:30,577
- It's a lot of information.

02:29:30,577 --> 02:29:32,546
Young Jun Son is here, who coded it,

02:29:32,546 --> 02:29:34,967
it's built into the kernel, so, yeah.

02:29:34,967 --> 02:29:37,967
If I had a laptop I could show some,

02:29:39,292 --> 02:29:40,940
yeah it's a lot of information,

02:29:40,940 --> 02:29:42,746
a lot of information about type format.

02:29:42,746 --> 02:29:44,841
Who can summarize it better than I can?

02:29:44,841 --> 02:29:45,674
- Not me.

02:29:47,049 --> 02:29:48,127
- [Alistair] Is Young Jun here?

02:29:48,127 --> 02:29:50,159
- [Audience Member] Endre's here.

02:29:50,159 --> 02:29:52,992
- [Alistair] Endre, Endre can say.

02:29:55,314 --> 02:29:56,981
- Here we go, ready.

02:30:03,446 --> 02:30:06,535
- Okay, so BTF is a collection of type information

02:30:06,535 --> 02:30:08,665
plus some additional information

02:30:08,665 --> 02:30:10,814
and like in this context we kind of talked about

02:30:10,814 --> 02:30:12,403
two different uses of it here.

02:30:12,403 --> 02:30:14,946
The first one, like this essentially replacing the need

02:30:14,946 --> 02:30:18,333
for system kernels, or system kernel heads right?

02:30:18,333 --> 02:30:22,121
So like you won't need to do include MAT swap and whatever,

02:30:22,121 --> 02:30:23,761
you can just dump essentially,

02:30:23,761 --> 02:30:26,522
the BTF information contained was in the kernel,

02:30:26,522 --> 02:30:28,710
generate like one big header file

02:30:28,710 --> 02:30:30,794
with like all the structs included and the internal ones

02:30:30,794 --> 02:30:32,175
that are not exposed normally.

02:30:32,175 --> 02:30:34,451
And that's, I think, what we are talking about

02:30:34,451 --> 02:30:36,216
that like is landing soon, right?

02:30:36,216 --> 02:30:38,758
So we don't need walk out headers,

02:30:38,758 --> 02:30:40,894
we just need BTF and then we can convert it to C.

02:30:40,894 --> 02:30:43,089
As for the function arguments,

02:30:43,089 --> 02:30:45,161
BTF also contains the type information.

02:30:45,161 --> 02:30:47,762
We probably can add the argument names,

02:30:47,762 --> 02:30:50,078
but they are not there right now.

02:30:50,078 --> 02:30:53,345
And with that, probably on some more magic

02:30:53,345 --> 02:30:55,780
you can drive it like argument one,

02:30:55,780 --> 02:30:58,489
for some specific kernel probe is of type sk buff

02:30:58,489 --> 02:31:01,310
and then just use it for self casting, yeah.

02:31:01,310 --> 02:31:05,880
- [Song] So it's a, let see, subset of the dwarf.

02:31:05,880 --> 02:31:06,797
It can be--

02:31:07,934 --> 02:31:09,540
- You can say so yes, we can convert dwarf into BTF.

02:31:09,540 --> 02:31:10,373
- Okay.

02:31:11,527 --> 02:31:14,250
- And also, clank knows how to emit BTF directly

02:31:14,250 --> 02:31:15,507
for BPF programs,

02:31:15,507 --> 02:31:17,199
so like there are two ways to get BTF

02:31:17,199 --> 02:31:19,287
either through dwarf to BTF conversion

02:31:19,287 --> 02:31:21,587
or directly generated by clank.

02:31:21,587 --> 02:31:22,983
- Okay, thank you.

02:31:22,983 --> 02:31:23,816
- Mhmm.

02:31:26,092 --> 02:31:27,925
- That's yours, right?

02:31:29,515 --> 02:31:31,235
- So I think we're done with watchpoints.

02:31:31,235 --> 02:31:33,142
Another one is, oh, sorry you've got a question.

02:31:33,142 --> 02:31:34,381
A question about this.

02:31:34,381 --> 02:31:35,798
- [Man] Heads up!

02:31:39,785 --> 02:31:41,719
- My question, is this going to be

02:31:41,719 --> 02:31:43,646
like a SystemTap replacement?

02:31:43,646 --> 02:31:44,479
Or how it is?

02:31:44,479 --> 02:31:47,180
- [Alistair] Oh, that's a tough question.

02:31:47,180 --> 02:31:48,788
(all laughing)

02:31:48,788 --> 02:31:49,816
- You're right it's true.

02:31:49,816 --> 02:31:54,631
- [Alistair] Does anyone else want to answer that one?

02:31:54,631 --> 02:31:57,461
- [Steve] Here, here, throw it to me.

02:31:57,461 --> 02:31:58,819
- [Audience Member] Heads up.

02:31:58,819 --> 02:31:59,986
Can you catch?

02:32:01,385 --> 02:32:02,781
- Well SystemTap is in the kernel.

02:32:02,781 --> 02:32:06,604
That's a RedHat, basically only thing supported.

02:32:06,604 --> 02:32:08,374
So this is actually in the official kernel,

02:32:08,374 --> 02:32:10,040
so it's not a SystemTap replacement,

02:32:10,040 --> 02:32:12,049
but I believe functionality wise

02:32:12,049 --> 02:32:13,954
I think you probably can do most everything.

02:32:13,954 --> 02:32:16,701
I don't know, well the problem with SystemTap also

02:32:16,701 --> 02:32:19,810
is you put a, you're loading a kernel module

02:32:19,810 --> 02:32:21,679
into the kernel to do work.

02:32:21,679 --> 02:32:24,669
This is more of like just in time compiling, right?

02:32:24,669 --> 02:32:26,797
So it's basically BTF has it's own byte code,

02:32:26,797 --> 02:32:29,640
that goes to the kernel and then can also be optimized

02:32:29,640 --> 02:32:31,716
by just in time compiling.

02:32:31,716 --> 02:32:35,633
And it has strict, how do you, what do you say?

02:32:36,569 --> 02:32:38,380
Analysis, verification.

02:32:38,380 --> 02:32:40,923
Yeah it verifies the code, it doesn't allow,

02:32:40,923 --> 02:32:42,426
currently doesn't allow loops,

02:32:42,426 --> 02:32:44,232
but has that been fixed yet, have they doing the?

02:32:44,232 --> 02:32:45,997
- [Alistair] I think it has been fixed.

02:32:45,997 --> 02:32:46,919
- Has that been fixed?

02:32:46,919 --> 02:32:50,008
Yeah so, I think now, it verifies that it's an ending loop

02:32:50,008 --> 02:32:52,405
so it doesn't allow any infinite loops,

02:32:52,405 --> 02:32:55,128
or various other things that you know the halting problem.

02:32:55,128 --> 02:32:58,216
So it checks, it's a limited functionality,

02:32:58,216 --> 02:33:00,330
where SystemTap is full blown

02:33:00,330 --> 02:33:02,889
and you could easily crash the kernel with SystemTap

02:33:02,889 --> 02:33:07,889
if you could crash the kernel with BPF, that's a bug.

02:33:08,029 --> 02:33:10,163
Is that correct?

02:33:10,163 --> 02:33:10,996
- Yep!

02:33:13,309 --> 02:33:14,142
Nope.

02:33:15,446 --> 02:33:19,239
- Just one note, SystemTap now has BPF backing

02:33:19,239 --> 02:33:21,175
so you can generate actually

02:33:21,175 --> 02:33:24,425
if you have problems that run in kernel

02:33:25,682 --> 02:33:27,973
but well using System,

02:33:27,973 --> 02:33:31,957
well you can still use your like sort of SystemTap programs

02:33:31,957 --> 02:33:35,540
to run a BPF programs and not like kernels.

02:33:38,903 --> 02:33:39,904
- Hello?

02:33:39,904 --> 02:33:40,897
Uh, mic.

02:33:40,897 --> 02:33:41,994
Okay.

02:33:41,994 --> 02:33:43,538
Actually, you might wanna keep that.

02:33:43,538 --> 02:33:45,366
So, do you maintain SystemTap at all?

02:33:45,366 --> 02:33:46,377
- No.

02:33:46,377 --> 02:33:47,863
- Okay, I wasn't sure if you did or not.

02:33:47,863 --> 02:33:49,430
No, one thing that would be interesting though is

02:33:49,430 --> 02:33:51,438
because a lot of people do use SystemTap,

02:33:51,438 --> 02:33:52,681
okay, here's a question.

02:33:52,681 --> 02:33:53,755
How many people here actually use SystemTap?

02:33:53,755 --> 02:33:55,177
Got a few hands.

02:33:55,177 --> 02:33:57,191
And how many people here have

02:33:57,191 --> 02:33:59,589
like scripts that you don't wanna modify that you use?

02:33:59,589 --> 02:34:02,758
Maybe a couple, yes, so what would be really really nice

02:34:02,758 --> 02:34:05,603
is the fact that SystemTap does make an interface

02:34:05,603 --> 02:34:07,607
where the UserLAnd scripts turn into BTF code

02:34:07,607 --> 02:34:11,917
then you could actually use your old SystemTap scripts,

02:34:11,917 --> 02:34:14,885
for BPF and this kinda goes back to my own talk

02:34:14,885 --> 02:34:16,754
about the unified tracing platform

02:34:16,754 --> 02:34:19,048
they should be, once the implementation

02:34:19,048 --> 02:34:21,044
and user space should be two different things

02:34:21,044 --> 02:34:25,211
and that's something I would like to see actually.

02:34:26,141 --> 02:34:27,847
- Okay, the next thing I wanted to talk about

02:34:27,847 --> 02:34:30,854
is that back in spring someone came along in get up

02:34:30,854 --> 02:34:33,821
and asked for a way of using bpftrace pragmatically.

02:34:33,821 --> 02:34:37,375
So initial suggestions were to produce

02:34:37,375 --> 02:34:40,020
a kind of limp bpftrace or C library

02:34:40,020 --> 02:34:45,020
that exposed some interfaces for calling bpftrace functions.

02:34:46,702 --> 02:34:48,429
We decided not to go with that in the end,

02:34:48,429 --> 02:34:52,431
because the internal architecture of bpftrace

02:34:52,431 --> 02:34:54,811
is changing a lot, we've got a lot of changes planned

02:34:54,811 --> 02:34:57,958
and we didn't want to have to restrict ourselves

02:34:57,958 --> 02:34:59,444
to maintaining a stable API

02:34:59,444 --> 02:35:01,410
when we don't know what we want

02:35:01,410 --> 02:35:03,403
it to look like in the future.

02:35:03,403 --> 02:35:05,433
So what we went with instead,

02:35:05,433 --> 02:35:09,100
is allowing people to specify dash f jason,

02:35:10,555 --> 02:35:14,682
and all format will be output as Jason on command line.

02:35:14,682 --> 02:35:17,788
Since the pretty printing histograms

02:35:17,788 --> 02:35:22,038
and MAT values, everything is just a jason message.

02:35:26,082 --> 02:35:29,402
Okay, and just a few more quick things I wanted to go over.

02:35:29,402 --> 02:35:32,155
We've added a way of running sub processes

02:35:32,155 --> 02:35:33,629
out of bpftrace,

02:35:33,629 --> 02:35:35,922
running command and automatically start tracing it

02:35:35,922 --> 02:35:36,999
from the very beginning,

02:35:36,999 --> 02:35:39,492
just makes stuff, life a bit easier,

02:35:39,492 --> 02:35:41,489
then having to start a command

02:35:41,489 --> 02:35:43,056
then bpftrace at the same time

02:35:43,056 --> 02:35:45,349
get process ID's and all that sort of stuff.

02:35:45,349 --> 02:35:49,797
We've added a way of listing bpftrace probes,

02:35:49,797 --> 02:35:51,833
if you're not sure exactly what you want to be tracing

02:35:51,833 --> 02:35:54,393
you can do bpftrace dot l,

02:35:54,393 --> 02:35:55,585
stick some wildcards in their,

02:35:55,585 --> 02:35:57,092
see what is available in your system.

02:35:57,092 --> 02:36:00,709
We've added better support for tracing Go programs,

02:36:00,709 --> 02:36:03,025
'cause Go's calling convection, (laughs)

02:36:03,025 --> 02:36:07,108
convention, is for passing arguments on the stack

02:36:08,145 --> 02:36:11,988
rather than it registers as we currently expect.

02:36:11,988 --> 02:36:15,198
So we've added a few new built ins

02:36:15,198 --> 02:36:18,449
for accessing stack arguments.

02:36:18,449 --> 02:36:20,153
- [Steve] Your times coming up,

02:36:20,153 --> 02:36:21,903
so is there anything that you'd like to discuss

02:36:21,903 --> 02:36:24,320
for questions from the floor.

02:36:26,495 --> 02:36:28,412
- Yes future stuff, we,

02:36:29,420 --> 02:36:32,102
so actually let's not talk about that,

02:36:32,102 --> 02:36:34,418
'cause I think we know what we're doing on those two things.

02:36:34,418 --> 02:36:35,855
Stuff we're not sure about,

02:36:35,855 --> 02:36:38,743
is potentially adding support

02:36:38,743 --> 02:36:41,222
for new CPU architectures in the future.

02:36:41,222 --> 02:36:44,496
In the past year we added arm 64 support,

02:36:44,496 --> 02:36:47,886
which is fairly easy, just needed a few register re-mappings

02:36:47,886 --> 02:36:49,331
compared to MD 64.

02:36:49,331 --> 02:36:52,514
32 bit architectures will be a bit tougher,

02:36:52,514 --> 02:36:55,996
because bpftrace was just written expecting 64 bit support.

02:36:55,996 --> 02:36:59,413
We do have a proof of concept, on 32 bit,

02:37:01,783 --> 02:37:04,893
build, kind of working we think,

02:37:04,893 --> 02:37:06,926
but it would need a bit of work to produtionize it,

02:37:06,926 --> 02:37:09,926
if people actually find that useful.

02:37:13,522 --> 02:37:15,946
So we try to keep up to date with LLVM versions,

02:37:15,946 --> 02:37:19,157
which is a bit annoying, but we may not have to do that

02:37:19,157 --> 02:37:21,939
if we go for the fourth option on this list,

02:37:21,939 --> 02:37:23,244
which is to swap out,

02:37:23,244 --> 02:37:25,658
instead of compiling to LLVM byte code

02:37:25,658 --> 02:37:28,324
and then getting LLVM to produce BPF byte code for us,

02:37:28,324 --> 02:37:31,330
we just directly admit BPF byte code

02:37:31,330 --> 02:37:34,233
and remove the LLVM dependence all together.

02:37:34,233 --> 02:37:36,590
That's something people have been requesting a lot.

02:37:36,590 --> 02:37:41,423
Especially to be able to use bpftrace on embedded systems.

02:37:45,386 --> 02:37:48,314
Yep, and then I guess just any other features

02:37:48,314 --> 02:37:51,481
or suggestions that people would have.

02:37:55,990 --> 02:37:57,123
- Anyone else have?

02:37:57,123 --> 02:37:58,692
Other than that, I think time's up, so.

02:37:58,692 --> 02:38:01,859
(audience applauding)

02:39:46,900 --> 02:39:47,733
- Where'd it go?

02:39:47,733 --> 02:39:48,566
By the way real quick,

02:39:48,566 --> 02:39:49,399
if anyone else wants to help out,

02:39:49,399 --> 02:39:51,073
there is an Etherpad,

02:39:51,073 --> 02:39:53,634
Etherpad tracing up there, if you,

02:39:53,634 --> 02:39:56,397
I'm doing it right now, but if someone else wants to jump in

02:39:56,397 --> 02:39:58,144
and help out especially when I'm talking

02:39:58,144 --> 02:39:59,259
or listening to someone,

02:39:59,259 --> 02:40:01,761
I leave out things, so this is important

02:40:01,761 --> 02:40:03,143
for the notes for the summary,

02:40:03,143 --> 02:40:05,703
so feel free anyone can go to that link and edit.

02:40:05,703 --> 02:40:07,895
- [Audience Member] Is there any link or?

02:40:07,895 --> 02:40:10,701
- It's right there, I don't know if you can read it.

02:40:10,701 --> 02:40:12,368
I'll make it bigger.

02:40:13,847 --> 02:40:17,353
- Okay testing microphone, sounds good.

02:40:17,353 --> 02:40:19,836
Thank you, this discussion is on BPF tracing tools.

02:40:19,836 --> 02:40:23,169
And Alistair just talked about bpftrace,

02:40:24,958 --> 02:40:27,460
I've been maintaining this diagram

02:40:27,460 --> 02:40:29,953
to keep my head around what's been going on

02:40:29,953 --> 02:40:31,604
with the different traces.

02:40:31,604 --> 02:40:36,167
As Steven mentioned earlier, there are too many traces.

02:40:36,167 --> 02:40:38,572
And I've spent a lot of time on all of them.

02:40:38,572 --> 02:40:40,753
(microphone reverberating)

02:40:40,753 --> 02:40:43,205
Bpftrace, I've got bpftrace at the top.

02:40:43,205 --> 02:40:46,171
Ftrace, I keep moving down towards the right

02:40:46,171 --> 02:40:49,774
because it keeps adding capabilities

02:40:49,774 --> 02:40:52,880
and we saw earlier with synthetic events

02:40:52,880 --> 02:40:55,617
how you can record variables and refer to them

02:40:55,617 --> 02:40:57,982
and then come up with custom latency distributions.

02:40:57,982 --> 02:40:59,689
That's great.

02:40:59,689 --> 02:41:01,454
I think it's actually making

02:41:01,454 --> 02:41:03,323
the ftrace interface harder to use.

02:41:03,323 --> 02:41:06,370
Which is why, ftrace really needs

02:41:06,370 --> 02:41:08,913
a higher level interface.

02:41:08,913 --> 02:41:12,448
That's the SQL style interface is one of them.

02:41:12,448 --> 02:41:14,904
And so, as ftrace, if we get

02:41:14,904 --> 02:41:16,936
a higher level interface that works,

02:41:16,936 --> 02:41:20,331
ftrace can make a detour and turn left

02:41:20,331 --> 02:41:24,831
and start moving up to the easier end of this diagram.

02:41:27,239 --> 02:41:29,370
Bpftrace, at the moment it's looking great,

02:41:29,370 --> 02:41:31,602
0.9.2, we just launched.

02:41:31,602 --> 02:41:32,435
And...

02:41:36,887 --> 02:41:40,260
I began with bpf back with raw BPF and C BPF

02:41:40,260 --> 02:41:42,206
which are really really hard to use.

02:41:42,206 --> 02:41:47,206
And so overtime we've been adding the easier front ends.

02:41:47,461 --> 02:41:51,097
I've spent a lot of this year writing a book

02:41:51,097 --> 02:41:52,965
on BPF performance tools.

02:41:52,965 --> 02:41:55,096
And that shows what we can do with tracing capabilities.

02:41:55,096 --> 02:42:00,096
I discussed this in the IO Weizen meeting at the end of 2017

02:42:01,842 --> 02:42:04,466
that we needed a book,

02:42:04,466 --> 02:42:07,188
it's a great way to share everything things can do.

02:42:07,188 --> 02:42:10,155
Internally at Netflix, this is a way

02:42:10,155 --> 02:42:12,918
for me to scale my skills.

02:42:12,918 --> 02:42:15,354
Because I've given copies to all the other developers,

02:42:15,354 --> 02:42:18,457
so they can self study, and this is also becoming

02:42:18,457 --> 02:42:20,435
the basis of an internal Netflix course

02:42:20,435 --> 02:42:23,077
that I can teach instructor led.

02:42:23,077 --> 02:42:25,470
But there's another reason as well

02:42:25,470 --> 02:42:26,995
and that was at that point,

02:42:26,995 --> 02:42:28,661
we'd published a lot of documentation,

02:42:28,661 --> 02:42:30,774
especially myself and Sasha Goldstein,

02:42:30,774 --> 02:42:34,756
on how to use BPF and failures of BPF tracing,

02:42:34,756 --> 02:42:37,560
and sooner or later, someone's going to throw together

02:42:37,560 --> 02:42:39,737
and put together a book.

02:42:39,737 --> 02:42:41,866
And on one hand, that would have been okay,

02:42:41,866 --> 02:42:44,532
because if they threw together what was already published,

02:42:44,532 --> 02:42:46,865
I wrote a lot of it, I guess it's okay.

02:42:46,865 --> 02:42:50,279
But on the other hand, it would be bad,

02:42:50,279 --> 02:42:52,345
because I knew what was missing.

02:42:52,345 --> 02:42:54,894
So there was a lot of tracing tools I just hadn't done yet

02:42:54,894 --> 02:42:57,007
and documentation I just hadn't written yet.

02:42:57,007 --> 02:42:58,975
So if at the end of 2017

02:42:58,975 --> 02:43:01,720
you took together what was published on BPF tracing

02:43:01,720 --> 02:43:04,704
and put it together and stuck it on Amazon,

02:43:04,704 --> 02:43:06,919
it would be incomplete.

02:43:06,919 --> 02:43:09,499
And so, creating this book project,

02:43:09,499 --> 02:43:11,409
was an opportunity to fill in the gaps.

02:43:11,409 --> 02:43:15,716
This diagram of the BPF performance tools,

02:43:15,716 --> 02:43:19,251
in red are the new tools that I developed for the book.

02:43:19,251 --> 02:43:23,090
And especially, I had a blind spot for socket tracing

02:43:23,090 --> 02:43:25,736
and so I've gone around and added a lot new,

02:43:25,736 --> 02:43:27,907
created many new tools for socket stuff.

02:43:27,907 --> 02:43:29,934
But there were gaps all over the place.

02:43:29,934 --> 02:43:33,103
So it's really great to have this finished,

02:43:33,103 --> 02:43:35,122
it'll be, the electronic version is on Safari right now,

02:43:35,122 --> 02:43:38,983
all the tools are open source on GitHub,

02:43:38,983 --> 02:43:40,770
I published the repo this morning.

02:43:40,770 --> 02:43:42,938
Actually while I was sitting here in Plumbers.

02:43:42,938 --> 02:43:46,094
And the physical paper book should be out,

02:43:46,094 --> 02:43:48,004
definitely by the end of the year.

02:43:48,004 --> 02:43:50,091
It's a big book, it's 750 pages.

02:43:50,091 --> 02:43:54,157
So it takes them a while to copy, edit, and layout.

02:43:54,157 --> 02:43:55,887
So I'd expect a couple months.

02:43:55,887 --> 02:43:58,749
Just as a quick example of

02:43:58,749 --> 02:44:00,844
what sort of things the tools can do.

02:44:00,844 --> 02:44:03,892
So I wrote a tool for readahead,

02:44:03,892 --> 02:44:06,815
just was on my to do list for many years.

02:44:06,815 --> 02:44:10,066
So that I can find out is the readahead algorithm

02:44:10,066 --> 02:44:12,263
actually performing well or not?

02:44:12,263 --> 02:44:14,515
And then, print it out,

02:44:14,515 --> 02:44:18,602
after I've read it, read in pages of file system read a head

02:44:18,602 --> 02:44:22,258
or pre fetch, what's the age of the page when I use it?

02:44:22,258 --> 02:44:23,739
Because if they use quickly,

02:44:23,739 --> 02:44:26,182
it means the readahead algorithm is working well.

02:44:26,182 --> 02:44:28,618
If they're very old by the time they're used,

02:44:28,618 --> 02:44:30,947
maybe readahead was too aggressive.

02:44:30,947 --> 02:44:33,194
And also, to do a count of unused pages.

02:44:33,194 --> 02:44:34,629
So you can have an idea of like,

02:44:34,629 --> 02:44:37,555
I would like, this algorithm in the kernel,

02:44:37,555 --> 02:44:39,239
this algorithm in the application.

02:44:39,239 --> 02:44:41,253
Is it working well or not, what's the ideal tool

02:44:41,253 --> 02:44:43,348
that would give me that information?

02:44:43,348 --> 02:44:45,556
And then you can code it

02:44:45,556 --> 02:44:48,648
in so few lines of code that it fits on a slide.

02:44:48,648 --> 02:44:50,581
There's the bpftrace program for that.

02:44:50,581 --> 02:44:52,660
We're just tracing some k probes, to do my accounting.

02:44:52,660 --> 02:44:54,910
So lots of tools like that,

02:44:55,999 --> 02:44:58,180
really lots of great use cases

02:44:58,180 --> 02:45:03,180
for performance analysis, filling in observability gaps.

02:45:03,261 --> 02:45:04,178
Discussion.

02:45:05,344 --> 02:45:06,446
As part of writing the book,

02:45:06,446 --> 02:45:10,696
I hit many brick walls where bpftrace in particular

02:45:12,659 --> 02:45:14,289
couldn't do something,

02:45:14,289 --> 02:45:17,075
and so with help from the community and Alistair

02:45:17,075 --> 02:45:18,712
and people in this room,

02:45:18,712 --> 02:45:20,303
we went and added those capabilities

02:45:20,303 --> 02:45:22,353
just so that I could get the tools written.

02:45:22,353 --> 02:45:24,993
And so, getting to the end of the book

02:45:24,993 --> 02:45:27,315
is a huge milestone, not just for the book

02:45:27,315 --> 02:45:29,347
but for bpftrace and it's own capabilities

02:45:29,347 --> 02:45:31,803
because we're able to get all the tools to work.

02:45:31,803 --> 02:45:34,363
But in getting those tools to work,

02:45:34,363 --> 02:45:35,765
I often had to use k probes,

02:45:35,765 --> 02:45:37,532
when I kind of should have used trace points,

02:45:37,532 --> 02:45:39,546
because trace points would be much more stable.

02:45:39,546 --> 02:45:42,919
At the top of the list of desired trace points would be VFS.

02:45:42,919 --> 02:45:46,187
Would really like VFS trace points.

02:45:46,187 --> 02:45:47,430
VFS read and write,

02:45:47,430 --> 02:45:50,315
it would be fantastic, can expose arguments.

02:45:50,315 --> 02:45:52,751
Yes someone else would like them as well?

02:45:52,751 --> 02:45:55,246
You didn't even need to say anything,

02:45:55,246 --> 02:45:57,077
I put the words in your mouth.

02:45:57,077 --> 02:45:58,134
Go ahead.

02:45:58,134 --> 02:45:59,757
- Uh, hello.

02:45:59,757 --> 02:46:02,441
(microphone tapping)

02:46:02,441 --> 02:46:03,274
Talk.

02:46:03,274 --> 02:46:04,310
Talk to Al, Bureau.

02:46:04,310 --> 02:46:05,421
He's the one that's against it.

02:46:05,421 --> 02:46:07,416
One thing is, we may not be able to,

02:46:07,416 --> 02:46:09,079
well trace events we may not

02:46:09,079 --> 02:46:10,748
be able to get trace points possibly,

02:46:10,748 --> 02:46:12,902
if that's okay, there's a difference,

02:46:12,902 --> 02:46:14,808
you're very familiar with that difference.

02:46:14,808 --> 02:46:16,071
Trace events--

02:46:16,071 --> 02:46:17,697
- [Brendan] You've told me before yes.

02:46:17,697 --> 02:46:20,537
Say it again for the room and my memory.

02:46:20,537 --> 02:46:22,735
- Okay, trace events are what you see

02:46:22,735 --> 02:46:26,677
in a trace FS file system, where you create a trace event

02:46:26,677 --> 02:46:27,796
you get the whole,

02:46:27,796 --> 02:46:29,626
here's the format, here's the fields, this.

02:46:29,626 --> 02:46:32,796
A trace point is actually the hook in the kernel,

02:46:32,796 --> 02:46:35,437
it's the, trace events are built on top of a trace point.

02:46:35,437 --> 02:46:37,080
So when you create a trace event,

02:46:37,080 --> 02:46:38,891
you create a trace point, but if you,

02:46:38,891 --> 02:46:40,204
hold on a second,

02:46:40,204 --> 02:46:41,242
but if you make a trace point

02:46:41,242 --> 02:46:43,808
it will not create a trace event,

02:46:43,808 --> 02:46:45,896
the reason why Al Bureau's afraid of trace events

02:46:45,896 --> 02:46:47,442
is because it exposes the inter,

02:46:47,442 --> 02:46:51,525
that data goes to user space and he's afraid that

02:46:53,130 --> 02:46:55,772
Linus is going to be very, you know,

02:46:55,772 --> 02:46:57,862
when someone builds a tool on top of something from BFS,

02:46:57,862 --> 02:46:59,899
and then they want to change something

02:46:59,899 --> 02:47:01,745
and they remove that trace point and that tool breaks,

02:47:01,745 --> 02:47:03,353
next thing you know,

02:47:03,353 --> 02:47:05,832
Linus rejects that change,

02:47:05,832 --> 02:47:08,040
so Al Bureau was very very much against

02:47:08,040 --> 02:47:11,968
adding any trace events into the BFS layer

02:47:11,968 --> 02:47:14,745
but if we could get him, if we could get trace points,

02:47:14,745 --> 02:47:16,519
which means that they're not stable,

02:47:16,519 --> 02:47:18,913
so it's the whole thing like yes,

02:47:18,913 --> 02:47:20,356
they're more stable, they are,

02:47:20,356 --> 02:47:22,329
but they're not guaranteed to be there in the future.

02:47:22,329 --> 02:47:23,508
- But that ship has sailed,

02:47:23,508 --> 02:47:26,045
like we already had a TCP set stay trace point,

02:47:26,045 --> 02:47:27,815
and I wrote tools that used it,

02:47:27,815 --> 02:47:30,253
it was then deleted, it was added in four six

02:47:30,253 --> 02:47:31,937
and was deleted in four seven,

02:47:31,937 --> 02:47:34,131
so I'm okay with trace point's being best effort

02:47:34,131 --> 02:47:36,041
and I said this at LSFMN as well,

02:47:36,041 --> 02:47:37,336
I'm okay with trace points being--

02:47:37,336 --> 02:47:38,169
- [Steve] No that was a trace event,

02:47:38,169 --> 02:47:39,048
not even a trace point was it?

02:47:39,048 --> 02:47:40,267
That was a trace event.

02:47:40,267 --> 02:47:42,112
- That was a trace point that was added and removed.

02:47:42,112 --> 02:47:43,779
- [Steve] No what I'm saying was it exposed by the trace FS?

02:47:43,779 --> 02:47:45,996
- It was exposed, yeah.

02:47:45,996 --> 02:47:46,829
- [Steve] That was a trace event,

02:47:46,829 --> 02:47:47,866
there's a difference, that's what I'm saying.

02:47:47,866 --> 02:47:49,387
Trace event is what's exposed,

02:47:49,387 --> 02:47:51,058
trace points are just the hook.

02:47:51,058 --> 02:47:52,679
But yeah, but (mumbles).

02:47:52,679 --> 02:47:53,943
(cross talk drowns out speaker)

02:47:53,943 --> 02:47:56,480
- [Audience Member] But Linus has flat out said,

02:47:56,480 --> 02:47:58,129
it's okay if they change.

02:47:58,129 --> 02:48:01,078
- [Steve] Wait, yes, Linus has said,

02:48:01,078 --> 02:48:04,590
yeah, you said, Linus has said it's okay if they change.

02:48:04,590 --> 02:48:07,678
No, he's basically said, yeah they're changed

02:48:07,678 --> 02:48:09,669
as long as they don't break anything like PowerTOP

02:48:09,669 --> 02:48:11,115
that's really useful.

02:48:11,115 --> 02:48:11,948
- [Audience Member] Not true.

02:48:11,948 --> 02:48:12,818
(audience laughing)

02:48:12,818 --> 02:48:14,261
No, no Steve, like.

02:48:14,261 --> 02:48:15,094
- [Steve] Where is he?

02:48:15,094 --> 02:48:16,293
Raise your hand?

02:48:16,293 --> 02:48:17,494
- [Audience Member] So like...

02:48:17,494 --> 02:48:18,528
- [Steve] There he is,

02:48:18,528 --> 02:48:20,054
yeah if you wanna have this argument, yeah.

02:48:20,054 --> 02:48:22,083
- You asked this question already many times

02:48:22,083 --> 02:48:23,508
and Linux many times clarified,

02:48:23,508 --> 02:48:25,296
it is okay to change it.

02:48:25,296 --> 02:48:26,312
- [Steve] Well Linus will be here tomorrow.

02:48:26,312 --> 02:48:27,145
- Yes, so--

02:48:27,145 --> 02:48:28,425
- [Steve] So let's sit down and ask 'em.

02:48:28,425 --> 02:48:30,236
- Sure, okay, let's do it again.

02:48:30,236 --> 02:48:32,918
But it's already been mentioned many times,

02:48:32,918 --> 02:48:34,950
there have been articles written about it.

02:48:34,950 --> 02:48:36,860
Like this is done.

02:48:36,860 --> 02:48:39,460
Like you can change them, we had trace point,

02:48:39,460 --> 02:48:41,588
they were exposed, we had trace point,

02:48:41,588 --> 02:48:43,379
everything really moved them.

02:48:43,379 --> 02:48:45,231
We changed them.

02:48:45,231 --> 02:48:46,531
- [Steve] Yeah, but like Linus has said,

02:48:46,531 --> 02:48:48,295
user space, does user space,

02:48:48,295 --> 02:48:49,985
we break user space all the time

02:48:49,985 --> 02:48:51,668
but it's the whole thing, if no one notices

02:48:51,668 --> 02:48:52,951
did it really break?

02:48:52,951 --> 02:48:54,071
- No, we did break.

02:48:54,071 --> 02:48:56,361
And Brendan fixed his tool

02:48:56,361 --> 02:48:58,234
because we changed the trace points.

02:48:58,234 --> 02:48:59,067
- [Steve] Yeah, you're lucky that you

02:48:59,067 --> 02:49:00,045
have someone that doesn't complain to Linus.

02:49:00,045 --> 02:49:00,881
- No, no, you're not getting the point.

02:49:00,881 --> 02:49:04,642
It is okay, like anyone can complain

02:49:04,642 --> 02:49:07,933
as much as they can, but it is okay to change them.

02:49:07,933 --> 02:49:10,023
The trace point can change and we will change them.

02:49:10,023 --> 02:49:11,875
- [Steve] Those that got screwed by PowerTOP

02:49:11,875 --> 02:49:13,925
are afraid to change, that's why.

02:49:13,925 --> 02:49:15,713
- [Audience Member] Can we let Brendan continue?

02:49:15,713 --> 02:49:17,297
- [Steve] Well actually, I want this guy to talk

02:49:17,297 --> 02:49:19,214
he's been very patient.

02:49:20,362 --> 02:49:25,233
- I wanted to add to this issue trace event, trace points.

02:49:25,233 --> 02:49:29,381
One, data point which is the PAL trace point,

02:49:29,381 --> 02:49:31,737
that are going to appear inside that tree

02:49:31,737 --> 02:49:33,444
are going to be of this new kind,

02:49:33,444 --> 02:49:35,273
they don't expose a trace event,

02:49:35,273 --> 02:49:38,077
they only have a trace point,

02:49:38,077 --> 02:49:41,002
and Petras Alsta feels this is a condition

02:49:41,002 --> 02:49:45,633
to get this very useful trace point in the schedule.

02:49:45,633 --> 02:49:47,074
- [Steve] Yes, I'm familiar with that.

02:49:47,074 --> 02:49:48,760
- Yeah, so, I think,

02:49:48,760 --> 02:49:50,934
I don't know if it's the first case of trace point

02:49:50,934 --> 02:49:53,373
without exposed trace event,

02:49:53,373 --> 02:49:54,940
I don't remember any other example,

02:49:54,940 --> 02:49:59,263
but this thing is taken some momentum I guess.

02:49:59,263 --> 02:50:00,832
- [Steve] Yeah, we'll talk about that more later.

02:50:00,832 --> 02:50:02,301
- Okay, thanks.

02:50:02,301 --> 02:50:06,252
BFS wasn't expecting it to be that controversial,

02:50:06,252 --> 02:50:07,821
but yes we need to get BFS in.

02:50:07,821 --> 02:50:11,861
Sockets send receive, I use socket tracing a lot,

02:50:11,861 --> 02:50:14,503
and these are things that were born out

02:50:14,503 --> 02:50:16,394
of writing the 750 page book.

02:50:16,394 --> 02:50:18,468
Socket send receive, it's nice

02:50:18,468 --> 02:50:20,557
to trace network IO at the socket level

02:50:20,557 --> 02:50:22,427
because you're still in process context

02:50:22,427 --> 02:50:23,951
so I can rely on the process ID.

02:50:23,951 --> 02:50:26,852
I'm using tcp send message, receive message,

02:50:26,852 --> 02:50:29,398
there's a socket operations type

02:50:29,398 --> 02:50:32,545
with other things you might need to trace as well.

02:50:32,545 --> 02:50:36,486
Skb alloc, would be nice to have a trace point

02:50:36,486 --> 02:50:38,762
because we actually already have skb consume skb

02:50:38,762 --> 02:50:40,265
and k free skb.

02:50:40,265 --> 02:50:42,907
So the use case there is during

02:50:42,907 --> 02:50:45,832
the lifespan of skbs inside the kernel.

02:50:45,832 --> 02:50:48,349
Which gets complicated for a number of reasons,

02:50:48,349 --> 02:50:50,732
like splitting skb's and collecting skb's.

02:50:50,732 --> 02:50:53,025
But at least I wanna try, I wanna try to do this.

02:50:53,025 --> 02:50:54,894
Tcp send receive.

02:50:54,894 --> 02:50:57,576
Of course as soon as we end tcp send receive,

02:50:57,576 --> 02:51:00,200
as soon as we have tcp trace point heaven

02:51:00,200 --> 02:51:02,655
all work loads will move over to udp.

02:51:02,655 --> 02:51:05,661
I've experienced this many times as a performance engineer,

02:51:05,661 --> 02:51:09,422
as soon as you fix find pointers and symbols for one target

02:51:09,422 --> 02:51:11,270
everyone's using something else.

02:51:11,270 --> 02:51:13,830
So we will need to get udp done as well.

02:51:13,830 --> 02:51:16,535
There's some trace points we can add,

02:51:16,535 --> 02:51:18,440
that should be uncontroversial.

02:51:18,440 --> 02:51:22,102
Like IP ECN, explicit congestion notification.

02:51:22,102 --> 02:51:24,273
Would be nice to have trace points for that.

02:51:24,273 --> 02:51:25,690
Genl, bql limits.

02:51:27,036 --> 02:51:30,409
Some trace points it would be nice

02:51:30,409 --> 02:51:33,294
to add information to them.

02:51:33,294 --> 02:51:36,689
The block trace points don't have a unique ID,

02:51:36,689 --> 02:51:39,632
and I'd like a unique ID so I can trace latency

02:51:39,632 --> 02:51:42,338
from the start of a block IO to the end of a block IO,

02:51:42,338 --> 02:51:44,898
instead of having to add the sector ID and the device ID

02:51:44,898 --> 02:51:46,518
and other stuff.

02:51:46,518 --> 02:51:47,963
And locks.

02:51:47,963 --> 02:51:49,666
- [Audience Member] Wait a minute.

02:51:49,666 --> 02:51:51,173
- Yes.

02:51:51,173 --> 02:51:53,832
- Hello, just what are your views on

02:51:53,832 --> 02:51:57,306
I think we badly need something like a synthetic provider

02:51:57,306 --> 02:52:01,139
for our framework, like IO Stars, SKED on CPU,

02:52:02,952 --> 02:52:05,941
that kind of thing like we used, have in another world.

02:52:05,941 --> 02:52:08,135
Yeah, what's your view on that?

02:52:08,135 --> 02:52:09,581
Because a lot of this is point stuff,

02:52:09,581 --> 02:52:11,346
you're saying BFS providers, I'd like to see,

02:52:11,346 --> 02:52:14,538
you know, like IO Star for example,

02:52:14,538 --> 02:52:16,298
and you export to me an argument

02:52:16,298 --> 02:52:18,277
which is fully populated with type information

02:52:18,277 --> 02:52:20,935
that kind of thing like it used to have in dTrace.

02:52:20,935 --> 02:52:23,188
- So there seem to be two parts of it,

02:52:23,188 --> 02:52:27,231
there's the group of trace points which is already done

02:52:27,231 --> 02:52:29,997
so Linux has that, they're called categories or systems

02:52:29,997 --> 02:52:32,110
depends on the documentation you read.

02:52:32,110 --> 02:52:34,119
So like the skb group, and then

02:52:34,119 --> 02:52:35,605
you've got the skb trace points.

02:52:35,605 --> 02:52:38,530
And then there is having a standard struct

02:52:38,530 --> 02:52:40,313
that the trace point exposes.

02:52:40,313 --> 02:52:43,000
And it's possible we could do that,

02:52:43,000 --> 02:52:47,226
at the moment, if you have a look in sys FS tracing,

02:52:47,226 --> 02:52:50,233
you do get the members, you're familiar with this,

02:52:50,233 --> 02:52:52,346
you get the members for each of the trace points.

02:52:52,346 --> 02:52:53,949
- Yeah, just from a usability perspective,

02:52:53,949 --> 02:52:56,247
it's just really nice not having to decipher

02:52:56,247 --> 02:52:58,360
all that information, just have a common format,

02:52:58,360 --> 02:53:00,410
it's a really nice thing.

02:53:00,410 --> 02:53:02,162
You need some translation framework.

02:53:02,162 --> 02:53:04,070
- Yeah, it's an idea I haven't thought about.

02:53:04,070 --> 02:53:08,745
I mean the way Linux does it, is we can just add,

02:53:08,745 --> 02:53:10,330
what's the difference between that

02:53:10,330 --> 02:53:12,948
and adding a list of members to a trace point.

02:53:12,948 --> 02:53:14,231
Each of them have their own names?

02:53:14,231 --> 02:53:15,467
- I don't care how it's done,

02:53:15,467 --> 02:53:18,474
it's just it'd be nice to have a unified higher level,

02:53:18,474 --> 02:53:20,557
you know, probe for this.

02:53:21,423 --> 02:53:22,967
- Yeah because at the moment we sort of are there

02:53:22,967 --> 02:53:25,731
because you can take a set of trace points

02:53:25,731 --> 02:53:28,534
and you can develop them to say,

02:53:28,534 --> 02:53:31,012
make sure they always have these five common members.

02:53:31,012 --> 02:53:33,934
Basically what you're saying is that should be a struct.

02:53:33,934 --> 02:53:35,808
And then make sure they all have a struct.

02:53:35,808 --> 02:53:36,783
- [Audience Member] Indeed.

02:53:36,783 --> 02:53:38,409
- We can sort of do the same thing right now,

02:53:38,409 --> 02:53:40,423
to make sure that those trace points

02:53:40,423 --> 02:53:41,520
have the same five members,

02:53:41,520 --> 02:53:43,526
and have the same name, so it's almost the same thing.

02:53:43,526 --> 02:53:44,870
- [Audience Member] I mean it seems that way.

02:53:44,870 --> 02:53:45,949
- I get what you're suggesting, yeah.

02:53:45,949 --> 02:53:49,380
- [Audience Member] It's an ease of use thing,

02:53:49,380 --> 02:53:50,843
but that's really important, like you say,

02:53:50,843 --> 02:53:52,366
the easier it is to use,

02:53:52,366 --> 02:53:54,320
then people will learn to use it.

02:53:54,320 --> 02:53:55,153
- Yeah, it's just a different model

02:53:55,153 --> 02:53:56,352
from what we've got right now,

02:53:56,352 --> 02:54:01,352
which is you look at the named arguments and you use them.

02:54:01,880 --> 02:54:05,495
BPF helpers, so some that would be desired.

02:54:05,495 --> 02:54:08,600
If you see some of these and you'd like to work on them

02:54:08,600 --> 02:54:09,655
go ahead.

02:54:09,655 --> 02:54:11,793
Struct file to path name, like path look up at.

02:54:11,793 --> 02:54:15,974
This came up a lot because I can easily give you

02:54:15,974 --> 02:54:20,974
the file name itself or work to its' parent directory,

02:54:20,994 --> 02:54:22,696
but I want the full path name.

02:54:22,696 --> 02:54:24,187
Just for absolute path.

02:54:24,187 --> 02:54:26,015
We should just have a helper for that.

02:54:26,015 --> 02:54:29,812
A lot of times I'm tracing at the sys call level

02:54:29,812 --> 02:54:31,519
or close to the sys call level,

02:54:31,519 --> 02:54:32,981
and I have filed a script to integers.

02:54:32,981 --> 02:54:35,765
And I'd like some helpers to turn them into the struct file

02:54:35,765 --> 02:54:38,219
or the path name, or the file type

02:54:38,219 --> 02:54:41,866
like whether it's a SOCK or different file types themselves.

02:54:41,866 --> 02:54:45,436
There's a big problem emerging with

02:54:45,436 --> 02:54:49,269
bpf get current comm, exposes the thread name.

02:54:50,617 --> 02:54:54,723
And applications are starting to set their thread names

02:54:54,723 --> 02:54:56,410
more than they used to.

02:54:56,410 --> 02:54:58,872
When I first started using BPF at Netflix,

02:54:58,872 --> 02:55:02,082
a lot of my tools print out the comm,

02:55:02,082 --> 02:55:03,725
the name of the process.

02:55:03,725 --> 02:55:06,349
And they would say java, sounds good,

02:55:06,349 --> 02:55:07,948
in the middle of writing the book

02:55:07,948 --> 02:55:12,339
there've been updates to java and updates to applications

02:55:12,339 --> 02:55:16,037
and so now the production workloads we have

02:55:16,037 --> 02:55:18,458
each of the thread names are different.

02:55:18,458 --> 02:55:20,530
So you have the seater compiler threads,

02:55:20,530 --> 02:55:22,457
the application threads, and they all have separate names.

02:55:22,457 --> 02:55:25,162
And so, my examples changed,

02:55:25,162 --> 02:55:28,454
and it's to the point where it's like

02:55:28,454 --> 02:55:30,526
well now I need the actual parent name,

02:55:30,526 --> 02:55:33,818
I need to see java, as well as the thread names,

02:55:33,818 --> 02:55:35,849
so we just need to add a helper for that,

02:55:35,849 --> 02:55:37,452
should be straight forward,

02:55:37,452 --> 02:55:39,871
so that we get the parent or process name,

02:55:39,871 --> 02:55:42,026
not just the thread name or task name.

02:55:42,026 --> 02:55:45,980
There's more than just the single get in sets

02:55:45,980 --> 02:55:47,959
that we have in the kernel,

02:55:47,959 --> 02:55:49,561
there's lots of other time stamps as well.

02:55:49,561 --> 02:55:51,331
Of like all the time stamps the kernel tracks

02:55:51,331 --> 02:55:53,949
give them to me because I'll find a use for them.

02:55:53,949 --> 02:55:57,891
So the CPU time, we need to add a helper for fetching that.

02:55:57,891 --> 02:55:59,987
There's time stamps for

02:55:59,987 --> 02:56:02,135
scheduler accounting, delay accounting,

02:56:02,135 --> 02:56:04,218
all sorts of time stamps.

02:56:05,874 --> 02:56:07,423
So why do I want all the time stamps

02:56:07,423 --> 02:56:09,698
and mention you can U probe application request?

02:56:09,698 --> 02:56:11,767
So when it begins and ends.

02:56:11,767 --> 02:56:14,023
And then I can break it down into

02:56:14,023 --> 02:56:15,457
time spend waiting on the run queue,

02:56:15,457 --> 02:56:16,989
time spent waiting on disk error,

02:56:16,989 --> 02:56:19,166
time spent waiting on all these things.

02:56:19,166 --> 02:56:20,159
That's the marriage of

02:56:20,159 --> 02:56:22,963
application context and kernel context

02:56:22,963 --> 02:56:25,880
that makes this tracing worthwhile.

02:56:27,131 --> 02:56:29,749
Because if I try and sell tracing

02:56:29,749 --> 02:56:31,560
to application developers,

02:56:31,560 --> 02:56:34,526
they already have custom tracing tools

02:56:34,526 --> 02:56:36,517
often for the application which are pretty good.

02:56:36,517 --> 02:56:38,241
They have all these custom things.

02:56:38,241 --> 02:56:41,289
So why would they want to go and use a kernel tracer?

02:56:41,289 --> 02:56:44,563
You wanna use it because the kernel has extra information

02:56:44,563 --> 02:56:47,692
and you wanna marry it with the application context.

02:56:47,692 --> 02:56:50,148
And so, all those time stamps,

02:56:50,148 --> 02:56:52,568
they're an example of extra information,

02:56:52,568 --> 02:56:55,206
so easy to fetch the time stamp when you enter

02:56:55,206 --> 02:56:58,176
an application request, when you finish, what happens,

02:56:58,176 --> 02:57:00,834
well provided you're on the same task, thread ID.

02:57:00,834 --> 02:57:01,667
So...

02:57:03,093 --> 02:57:04,085
It would be great.

02:57:04,085 --> 02:57:05,447
More string functions we might need,

02:57:05,447 --> 02:57:07,615
I just wanted to add that to the slide.

02:57:07,615 --> 02:57:11,532
Bigger capabilities, BTF, thanks Yonghong Song,

02:57:13,495 --> 02:57:14,616
we've already got BTF there.

02:57:14,616 --> 02:57:17,540
Unprivileged BPF, we've been discussing,

02:57:17,540 --> 02:57:20,873
so that's something that we need for some environments.

02:57:20,873 --> 02:57:24,100
Probe multi-attach, at the moment,

02:57:24,100 --> 02:57:26,850
if I try to BPF trace 100 probes,

02:57:29,488 --> 02:57:32,170
you can notice how slow it is to start and stop.

02:57:32,170 --> 02:57:35,170
Ftrace is really fast in comparison,

02:57:37,267 --> 02:57:40,988
so I use ftrace for a lot of function accounting tasks.

02:57:40,988 --> 02:57:42,569
Ftrace of course is cheating,

02:57:42,569 --> 02:57:44,860
because f entry is built into the function,

02:57:44,860 --> 02:57:46,880
compiled into all the functions,

02:57:46,880 --> 02:57:48,871
so it doesn't need to go and modify things.

02:57:48,871 --> 02:57:52,360
But we, it would be nice to have multi-attach.

02:57:52,360 --> 02:57:53,724
We've mentioned this before,

02:57:53,724 --> 02:57:55,007
someone just needs to do the work.

02:57:55,007 --> 02:57:57,892
Faster uprobes was mentioned before,

02:57:57,892 --> 02:58:00,997
LTTng has its method which is super fast

02:58:00,997 --> 02:58:03,414
compared to what we're doing.

02:58:04,718 --> 02:58:06,588
So some integration of that.

02:58:06,588 --> 02:58:08,736
And we need to get ready

02:58:08,736 --> 02:58:12,091
for the BPF probe read user and kernel split

02:58:12,091 --> 02:58:14,651
that will eventually happen.

02:58:14,651 --> 02:58:16,096
So BPF probe read will,

02:58:16,096 --> 02:58:20,543
in order to support other architectures like SPOCK

02:58:20,543 --> 02:58:24,357
that have a different address space for user and kernel

02:58:24,357 --> 02:58:26,092
which can overlap,

02:58:26,092 --> 02:58:28,592
we need to have that split up.

02:58:29,686 --> 02:58:31,603
Yes, box, speaking box.

02:58:33,262 --> 02:58:36,390
- For the LTTng style fast uprobes,

02:58:36,390 --> 02:58:37,551
are you talking about the

02:58:37,551 --> 02:58:40,477
LTTng kernel tracer uprobe integration

02:58:40,477 --> 02:58:44,030
or the native LTTng user space only tracer?

02:58:44,030 --> 02:58:47,484
- I believe I'm talking about the user space only tracer.

02:58:47,484 --> 02:58:48,660
- Okay, that's the fastest, yeah.

02:58:48,660 --> 02:58:49,864
- Yeah so it's, I mean,

02:58:49,864 --> 02:58:53,254
it's someway of leveraging that from,

02:58:53,254 --> 02:58:55,123
I know it's going to be very strange

02:58:55,123 --> 02:58:56,528
because it runs on its own world.

02:58:56,528 --> 02:58:59,697
But some way of marrying the information that it can get

02:58:59,697 --> 02:59:01,706
with the information we get from the kernel.

02:59:01,706 --> 02:59:05,539
- [Steve] That's what we're trying to work on.

02:59:07,799 --> 02:59:09,612
- And the final thing I had here,

02:59:09,612 --> 02:59:13,862
is one of the biggest challenges we have right now.

02:59:16,594 --> 02:59:21,356
Off CPU analysis is, something I wanna do a lot more of.

02:59:21,356 --> 02:59:23,022
Off CPU analysis is where,

02:59:23,022 --> 02:59:25,582
I generally consider CPU analysis a solved problem.

02:59:25,582 --> 02:59:29,262
I can do timer based stack sampling.

02:59:29,262 --> 02:59:32,146
I can look at PMC's and look at instructions per cycle

02:59:32,146 --> 02:59:34,559
and I can decompose it into it's dull cycles.

02:59:34,559 --> 02:59:37,024
So give me a CPU bound work load

02:59:37,024 --> 02:59:38,991
and I can answer it very well.

02:59:38,991 --> 02:59:41,551
What are work loads in off CPU bound,

02:59:41,551 --> 02:59:43,525
we're blocked on locks, we're blocked on IO,

02:59:43,525 --> 02:59:45,151
how do I decompose that?

02:59:45,151 --> 02:59:47,628
Well I can trace schedule events

02:59:47,628 --> 02:59:49,353
we've got trace points for it.

02:59:49,353 --> 02:59:50,921
I can look at when we block,

02:59:50,921 --> 02:59:53,539
I can look at who woke up the blocking thread

02:59:53,539 --> 02:59:56,203
and their stack trace, I can look at who woke up the waker,

02:59:56,203 --> 02:59:59,106
and so on, and I can do all these great things

02:59:59,106 --> 03:00:02,420
but I need the stack tracers for the context.

03:00:02,420 --> 03:00:04,980
And unfortunately a lot of blocking events

03:00:04,980 --> 03:00:08,730
go through select our pull or f read or write

03:00:10,425 --> 03:00:12,150
and that's all in lib C,

03:00:12,150 --> 03:00:14,936
and lib C is universally shipped

03:00:14,936 --> 03:00:16,818
without the frame pointer.

03:00:16,818 --> 03:00:19,586
And so it breaks, I've got a flame graph here

03:00:19,586 --> 03:00:21,803
where we've got p thread comm time wait

03:00:21,803 --> 03:00:23,324
and there's nothing underneath

03:00:23,324 --> 03:00:24,177
and I see this all the time at Netflix.

03:00:24,177 --> 03:00:25,757
We've all been automating flame graphs,

03:00:25,757 --> 03:00:27,591
automating BPF based flame graph collections.

03:00:27,591 --> 03:00:29,721
So you click a button, you get an off CPU flame graph,

03:00:29,721 --> 03:00:32,832
great it's broken, but it's showing it to you.

03:00:32,832 --> 03:00:35,393
And it's broken because we have no user level stack trace

03:00:35,393 --> 03:00:37,628
'cause we all die on lib C.

03:00:37,628 --> 03:00:40,066
So at Netflix do we build our own lib C

03:00:40,066 --> 03:00:42,015
and then ship that, this is a challenge

03:00:42,015 --> 03:00:43,456
we're dealing with right now.

03:00:43,456 --> 03:00:45,998
There's another Netflix engineer here in the Distros track

03:00:45,998 --> 03:00:47,782
trying to figure that out.

03:00:47,782 --> 03:00:51,115
Do we talk to the maintainers of G lib C

03:00:52,274 --> 03:00:54,568
and say you need to compile this differently

03:00:54,568 --> 03:00:57,231
or the Distro maintainers?

03:00:57,231 --> 03:00:58,746
One solution is to use LBR,

03:00:58,746 --> 03:01:00,848
use last branch record because you can then walk past

03:01:00,848 --> 03:01:03,588
the places where you don't have frame pointers.

03:01:03,588 --> 03:01:05,820
Where to point on the cloud,

03:01:05,820 --> 03:01:08,865
and the cloud usually disables a lot of process or features.

03:01:08,865 --> 03:01:11,146
And so LBR is something I don't have access to on the cloud.

03:01:11,146 --> 03:01:13,313
- [Steve] You do, I think,

03:01:14,234 --> 03:01:15,431
(microphone tapping)

03:01:15,431 --> 03:01:17,891
this is, I think the reason why they don't do flame pointers

03:01:17,891 --> 03:01:19,801
is because there is edit overhead

03:01:19,801 --> 03:01:22,058
when you have frame pointers compiled in.

03:01:22,058 --> 03:01:23,742
- Yeah, I'd like to bench mark that though.

03:01:23,742 --> 03:01:25,797
It really depends and the

03:01:25,797 --> 03:01:28,537
production applications we've bench marked,

03:01:28,537 --> 03:01:31,039
the frame pointer overhead is

03:01:31,039 --> 03:01:33,789
almost always close to 0.1%.

03:01:35,306 --> 03:01:37,419
- Okay, 'cause in the kernel,

03:01:37,419 --> 03:01:39,144
when we did it for kernels we saw about

03:01:39,144 --> 03:01:41,784
closer to 4%.

03:01:41,784 --> 03:01:43,206
- [Brendan] Yeah, I'd love to see

03:01:43,206 --> 03:01:45,786
a cycle breakdown with 4%.

03:01:45,786 --> 03:01:48,106
- But that was 2007, things might have changed, never know.

03:01:48,106 --> 03:01:49,813
- 2007, things might have changed.

03:01:49,813 --> 03:01:52,477
The worst I saw, we have one production worker at Netflix

03:01:52,477 --> 03:01:56,883
with a frame pointer, Java frame pointers, was 10% overhead.

03:01:56,883 --> 03:01:57,716
10%?

03:01:59,321 --> 03:02:01,742
I'd love to see a cycle breakdown to find out why.

03:02:01,742 --> 03:02:04,441
But we don't have PEB's on the cloud,

03:02:04,441 --> 03:02:05,887
precisive NP sampling,

03:02:05,887 --> 03:02:08,464
so I can't actually reliably do cycle based analysis.

03:02:08,464 --> 03:02:11,877
So I'd love to know what that 10% was,

03:02:11,877 --> 03:02:14,722
I do know one thing, it involved

03:02:14,722 --> 03:02:16,957
stack traces 1,000 frames deep.

03:02:16,957 --> 03:02:18,620
- [Audience Member] Is there a reason

03:02:18,620 --> 03:02:20,126
you can't use the dwarf key?

03:02:20,126 --> 03:02:22,384
- So the question was, I'll repeat the question,

03:02:22,384 --> 03:02:25,838
can I not use dwarf for going past lib C?

03:02:25,838 --> 03:02:28,538
At the moment we don't have dwarf access from BPF

03:02:28,538 --> 03:02:31,038
plus I don't, I believe dwarf,

03:02:32,555 --> 03:02:34,755
the dwarf stack trace working,

03:02:34,755 --> 03:02:38,455
we've got debug info installed on both instances

03:02:38,455 --> 03:02:41,300
but I believe that was designed for

03:02:41,300 --> 03:02:42,133
a break point based debugger

03:02:42,133 --> 03:02:45,639
and not a real time debugger like BPF.

03:02:45,639 --> 03:02:47,732
And so the overhead, like what if

03:02:47,732 --> 03:02:50,108
you have to page fob in some of the dwarf information

03:02:50,108 --> 03:02:53,230
while you're in a probe context that sounds like--

03:02:53,230 --> 03:02:54,762
- Do we have ORC for user space?

03:02:54,762 --> 03:02:57,055
Are you familiar with ORC?

03:02:57,055 --> 03:02:58,498
- ORC?

03:02:58,498 --> 03:02:59,371
- ORC.

03:02:59,371 --> 03:03:00,522
- Yeah, that's what I said.

03:03:00,522 --> 03:03:02,053
ORC yes, so did I put it on the slide?

03:03:02,053 --> 03:03:03,191
I should have put it on the slide.

03:03:03,191 --> 03:03:04,631
So we should have ORC for user space,

03:03:04,631 --> 03:03:06,645
we should, there's some GCC people here,

03:03:06,645 --> 03:03:09,585
we should get ORC by default putting into GCC.

03:03:09,585 --> 03:03:11,480
- [Steve] And you know, by the way,

03:03:11,480 --> 03:03:13,065
that's the ORC maintainer.

03:03:13,065 --> 03:03:14,203
- Thank you sir.

03:03:14,203 --> 03:03:15,765
(audience laughing)

03:03:15,765 --> 03:03:18,510
Your task is to talk to the, if the GCC person's here,

03:03:18,510 --> 03:03:21,900
that would be great and then ORC everywhere

03:03:21,900 --> 03:03:24,240
all applications have ORC and then,

03:03:24,240 --> 03:03:26,962
because we already, BPF already accesses ORC

03:03:26,962 --> 03:03:28,750
because it goes through,

03:03:28,750 --> 03:03:31,026
Steven showed me, it goes through

03:03:31,026 --> 03:03:33,116
the same perf stack trace walker,

03:03:33,116 --> 03:03:35,171
so it's got ORC support already.

03:03:35,171 --> 03:03:37,057
- If we can generate the ORC information out of dwarf,

03:03:37,057 --> 03:03:39,414
one thing that could perhaps be done,

03:03:39,414 --> 03:03:41,425
if we want to move distribution

03:03:41,425 --> 03:03:43,907
to have added ORC information

03:03:43,907 --> 03:03:46,078
would be to go over all the debug info,

03:03:46,078 --> 03:03:48,658
and generate that ORC in full

03:03:48,658 --> 03:03:50,751
as a post processing step.

03:03:50,751 --> 03:03:52,481
- Yeah, you could convert dwarf.

03:03:52,481 --> 03:03:55,281
Yeah, you could convert dwarf to ORC,

03:03:55,281 --> 03:03:56,806
we don't have tools to do that now,

03:03:56,806 --> 03:03:58,838
but it should be pretty easy to do.

03:03:58,838 --> 03:04:00,776
- And you guys, if you come to

03:04:00,776 --> 03:04:01,762
the chaining thing tomorrow morning,

03:04:01,762 --> 03:04:04,807
we are doing some of that stuff.

03:04:04,807 --> 03:04:06,948
It's already on it's way.

03:04:06,948 --> 03:04:09,728
- [Steve] We're out, we're way over.

03:04:09,728 --> 03:04:10,744
- That's it.

03:04:10,744 --> 03:04:13,078
- [Steve] Okay so, thank you.

03:04:13,078 --> 03:04:16,328

YouTube URL: https://www.youtube.com/watch?v=f7kIzeDyjLo


