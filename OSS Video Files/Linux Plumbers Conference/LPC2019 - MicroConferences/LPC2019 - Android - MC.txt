Title: LPC2019 - Android - MC
Publication date: 2019-11-18
Playlist: LPC2019 - MicroConferences
Description: 
	Android - MC
Captions: 
	00:00:00,490 --> 00:00:01,430
- Started slowly here.

00:00:01,430 --> 00:00:06,040
Just introducing the MC before we hit the clock,

00:00:06,040 --> 00:00:08,870
so that we hit the clock with the first presentation.

00:00:08,870 --> 00:00:10,440
So, my name is Karim Yaghmour.

00:00:10,440 --> 00:00:12,530
Welcome to the Android Micro-Conference.

00:00:12,530 --> 00:00:14,980
This is about the seventh or eighth year it runs.

00:00:15,880 --> 00:00:17,900
First time we ran it we had two people from Google.

00:00:17,900 --> 00:00:20,830
This year, you know, every year it keeps increasing,

00:00:20,830 --> 00:00:22,900
so we're very happy with that.

00:00:22,900 --> 00:00:25,900
It has become a primary rendezvous point

00:00:25,900 --> 00:00:27,720
between the Android team

00:00:27,720 --> 00:00:30,250
and the general Linux community at large.

00:00:30,250 --> 00:00:32,360
Not that there aren't conversations ongoing over the year,

00:00:32,360 --> 00:00:33,390
but this one has become kinda

00:00:33,390 --> 00:00:36,360
like a nice way to sync everybody together.

00:00:36,360 --> 00:00:38,210
So, on behalf of the organization committee,

00:00:38,210 --> 00:00:41,560
that's Todd Amits, who is not here, and myself,

00:00:41,560 --> 00:00:44,260
I'd like to welcome you to this afternoon,

00:00:44,260 --> 00:00:47,300
which will probably overflow to sometime

00:00:47,300 --> 00:00:50,850
around sevenish depending on how things go.

00:00:50,850 --> 00:00:54,370
Every presenter has 15 minutes, and this is a hard limit.

00:00:54,370 --> 00:00:56,790
If you were there last year, you saw how it went.

00:00:56,790 --> 00:00:58,860
Effectively, by 15, I'll just cut you off,

00:00:58,860 --> 00:01:02,050
and you'll have to pursue it outside or whatever.

00:01:02,050 --> 00:01:04,820
Preferably, you're doing five minutes of presentation

00:01:04,820 --> 00:01:06,180
and 10 minutes of talking.

00:01:07,550 --> 00:01:08,890
I'll leave you the liberty to continue

00:01:08,890 --> 00:01:10,460
between the five and 10 minute mark,

00:01:10,460 --> 00:01:11,640
but about the 10 minute mark

00:01:11,640 --> 00:01:13,990
if you haven't actually started the discussion,

00:01:13,990 --> 00:01:15,426
I'm gonna force it upon you.

00:01:15,426 --> 00:01:16,259
(laughing)

00:01:16,259 --> 00:01:17,900
Alright?

00:01:17,900 --> 00:01:19,080
Depending on the situation,

00:01:19,080 --> 00:01:20,290
I might be a bit flexible on this,

00:01:20,290 --> 00:01:22,360
but seriously, if you're getting close to 10 minutes,

00:01:22,360 --> 00:01:24,790
you really want to get started on the conversation,

00:01:24,790 --> 00:01:28,280
'cause that's the point of these micro-conferences,

00:01:28,280 --> 00:01:31,370
to actually engage with the audience.

00:01:31,370 --> 00:01:33,320
There is going to be an etherpad.

00:01:33,320 --> 00:01:35,120
Alicia was gonna start doing that.

00:01:35,120 --> 00:01:37,040
If anybody else wants to chime in

00:01:37,040 --> 00:01:39,720
and add stuff along the way, that's perfectly fine.

00:01:41,290 --> 00:01:42,890
What else do I want to say here?

00:01:44,210 --> 00:01:46,950
Right, there is some homework

00:01:46,950 --> 00:01:48,690
for you to do if you're presenting.

00:01:48,690 --> 00:01:50,580
So you get your 15 minutes of fame.

00:01:51,640 --> 00:01:54,260
Afterwards, however, depending on the discussion,

00:01:54,260 --> 00:01:55,360
you do you wanna take the time

00:01:55,360 --> 00:01:57,880
to actually fill in the progress report.

00:01:59,141 --> 00:02:02,430
And effectively, it's not a very difficult format.

00:02:02,430 --> 00:02:05,930
There's wins, work, losses.

00:02:05,930 --> 00:02:07,630
The idea there is just to summarize

00:02:07,630 --> 00:02:09,960
what progress has been made, what people have agreed upon,

00:02:09,960 --> 00:02:11,130
what they disagreed about,

00:02:11,130 --> 00:02:13,600
and what things people agree on disagreeing,

00:02:13,600 --> 00:02:16,340
unless there's some future work to be done about it.

00:02:16,340 --> 00:02:17,450
Alright?

00:02:17,450 --> 00:02:19,460
There are rules for the mics.

00:02:19,460 --> 00:02:20,970
There's two cubes.

00:02:20,970 --> 00:02:23,540
I was told you that wannna hold them around this,

00:02:23,540 --> 00:02:25,570
not to close your mouth, not too far away.

00:02:25,570 --> 00:02:26,500
You don't wanna bring them together.

00:02:26,500 --> 00:02:28,640
It's like the Ghostbuster rules, okay?

00:02:28,640 --> 00:02:30,410
Don't mix the streams.

00:02:30,410 --> 00:02:33,060
Don't cross the streams, I think the actual quote is.

00:02:34,470 --> 00:02:35,303
What else do I wanna say?

00:02:35,303 --> 00:02:37,090
Okay, yeah, the video is cut off at 6:30,

00:02:37,090 --> 00:02:39,240
so we are going to lose one or two sessions

00:02:39,240 --> 00:02:40,750
or whatever discussion goes afterwards.

00:02:40,750 --> 00:02:43,450
I don't think it's that big of a deal.

00:02:43,450 --> 00:02:46,640
And we are going to probably close around sevenish

00:02:46,640 --> 00:02:48,090
depending on where things go.

00:02:49,190 --> 00:02:50,023
Anything else?

00:02:50,023 --> 00:02:50,856
Any questions?

00:02:50,856 --> 00:02:51,966
Todd, did I forget anything?

00:02:51,966 --> 00:02:53,549
We're good?

00:02:53,549 --> 00:02:54,382
Okay.

00:02:54,382 --> 00:02:55,640
- [Todd] Please stand when speaking through the mic.

00:02:55,640 --> 00:02:57,040
- Sorry, yes.

00:02:57,040 --> 00:02:57,873
- [Todd] Please stand.

00:02:57,873 --> 00:02:58,706
- Yeah, please stand.

00:02:58,706 --> 00:02:59,539
Yes, thank you for reminding me about that.

00:02:59,539 --> 00:03:01,470
If you are holding the cube and need to talk,

00:03:01,470 --> 00:03:04,380
please stand so the person filming can actually film you

00:03:04,380 --> 00:03:06,450
and know who is talking.

00:03:06,450 --> 00:03:08,140
As well, if you're talking to,

00:03:08,140 --> 00:03:09,850
if you're explaining something on the screen,

00:03:09,850 --> 00:03:12,010
you want to position yourself this way,

00:03:12,010 --> 00:03:14,870
so the camera can also catch that as well.

00:03:14,870 --> 00:03:15,703
Alright.

00:03:15,703 --> 00:03:17,970
And with that, Sandeep, it's all yours.

00:03:19,945 --> 00:03:20,778
- So, give me.

00:03:20,778 --> 00:03:22,850
- Yeah, so if you just want to switch his presentation in,

00:03:22,850 --> 00:03:23,720
or is it just--

00:03:23,720 --> 00:03:24,553
- [Woman] Okay, I'll launch it if you want.

00:03:24,553 --> 00:03:29,553
- Yep, thanks.

00:03:31,427 --> 00:03:34,080
(crowd laughing)

00:03:34,080 --> 00:03:35,161
- How does it work?

00:03:35,161 --> 00:03:35,994
(microphone humming)

00:03:42,788 --> 00:03:44,169
- [Man] It wasn't you?

00:03:44,169 --> 00:03:45,002
- Oh, definitely.

00:03:45,002 --> 00:03:46,590
I checked again just to make sure.

00:03:46,590 --> 00:03:48,240
- Oh, yeah, one last thing, sorry.

00:03:48,240 --> 00:03:50,470
Yeah, one last thing before we get started.

00:03:50,470 --> 00:03:53,180
The schedule is such that there are 15 minute slots,

00:03:53,180 --> 00:03:56,880
so even if you finish before we'll wait for the next 15 mark

00:03:56,880 --> 00:03:58,430
to start the next presentation.

00:04:00,870 --> 00:04:03,050
- Okay, my name is Sandeep Patil.

00:04:03,050 --> 00:04:06,125
I lead the Android Kernel Team in Google.

00:04:06,125 --> 00:04:06,958
(microphone humming)

00:04:06,958 --> 00:04:09,930
We talked about what we are trying to do with

00:04:09,930 --> 00:04:11,940
Android kernels in last year's Plumbers,

00:04:11,940 --> 00:04:14,200
around generate kernel images.

00:04:14,200 --> 00:04:16,210
We maintain an Android Common Kernel,

00:04:16,210 --> 00:04:19,140
which, basically, is essentially an upstream for

00:04:20,079 --> 00:04:21,620
all the new android devices.

00:04:22,650 --> 00:04:25,190
But none of this kernel actually runs

00:04:25,190 --> 00:04:26,420
on any given android device,

00:04:26,420 --> 00:04:28,820
because of how downstream gets heavily modified.

00:04:28,820 --> 00:04:32,640
So, our goal is to refactor our kernel enough

00:04:32,640 --> 00:04:35,683
and give APIs for modules enough,

00:04:35,683 --> 00:04:38,540
and tested enough in order to make sure it actually runs

00:04:38,540 --> 00:04:42,910
on the devices and boots, and then we can run test for them.

00:04:42,910 --> 00:04:44,880
There are a lot more details about it

00:04:44,880 --> 00:04:46,920
in the LWN article that I linked.

00:04:48,340 --> 00:04:50,760
The tl;dr from last year's thing was basically

00:04:50,760 --> 00:04:52,790
all of this helps us

00:04:52,790 --> 00:04:57,060
A, be as close to the mainline as possible.

00:04:57,060 --> 00:05:00,290
Today we don't know what it takes in order to run an

00:05:00,290 --> 00:05:03,530
Android device, what it takes to be added in the kernel

00:05:03,530 --> 00:05:05,210
in order to run on Android device.

00:05:05,210 --> 00:05:07,660
We know what it takes to run Android,

00:05:07,660 --> 00:05:09,880
but not necessarily on any given hardware.

00:05:09,880 --> 00:05:12,970
So, our goal is to basically find all of that out,

00:05:12,970 --> 00:05:14,450
and then upstream it,

00:05:14,450 --> 00:05:16,859
and try to be as close to mainline as possible.

00:05:16,859 --> 00:05:21,859
So, we started off about right after last year's Plumbers.

00:05:22,970 --> 00:05:25,600
So, target, for example, that are the kernels

00:05:25,600 --> 00:05:26,980
that we are targeting this time is,

00:05:26,980 --> 00:05:30,400
we have an AOSP Android mainline branch,

00:05:30,400 --> 00:05:33,740
which is basically tracking upstream Linux,

00:05:33,740 --> 00:05:36,510
and we also have a 4.19 LTS branch.

00:05:36,510 --> 00:05:39,090
The mainline branch will, essentially, probably,

00:05:39,090 --> 00:05:41,520
fork into when there is a next long term stable.

00:05:41,520 --> 00:05:45,020
We also have decided on the first hardware target.

00:05:45,020 --> 00:05:47,970
One being Cuttlefish, which we talked about

00:05:47,970 --> 00:05:48,803
last year as well.

00:05:48,803 --> 00:05:51,890
This is basically, the Android virtual device

00:05:51,890 --> 00:05:54,360
has both x86 and arm64.

00:05:54,360 --> 00:05:56,470
The x86 one is obviously a lot easier,

00:05:56,470 --> 00:06:00,830
so that will get enabled first sometime this month, I think.

00:06:00,830 --> 00:06:03,190
Alistair, correct me if I'm wrong.

00:06:03,190 --> 00:06:05,010
And by that, what I mean by that is,

00:06:05,010 --> 00:06:08,070
it'll actually have a generate kernel defconfig,

00:06:08,070 --> 00:06:09,590
just like what we were talking about

00:06:09,590 --> 00:06:11,310
in the distribution micro-conference yesterday.

00:06:11,310 --> 00:06:12,570
It will have its own defconfig.

00:06:12,570 --> 00:06:14,930
It'll have all the drivers that it needs

00:06:14,930 --> 00:06:17,050
in order to run Cuttlefish, and that'll be

00:06:17,050 --> 00:06:19,540
our first litmus test.

00:06:19,540 --> 00:06:22,570
Then we'll move on to the arm64 Cuttlefish.

00:06:22,570 --> 00:06:24,990
Again, it'll be easier because there's no,

00:06:24,990 --> 00:06:27,592
all the drivers in the Cuttlefish world

00:06:27,592 --> 00:06:29,610
are everything that is known to us.

00:06:29,610 --> 00:06:30,880
So, that's our next.

00:06:30,880 --> 00:06:33,170
And then we have a bunch of AOSP development board,

00:06:33,170 --> 00:06:35,570
so that its DB845 and Hikey.

00:06:35,570 --> 00:06:37,540
That work is already ongoing,

00:06:37,540 --> 00:06:39,720
and so we expect that to happen next,

00:06:39,720 --> 00:06:42,070
followed by actual phones and devices.

00:06:45,040 --> 00:06:48,500
Right so, where are we working on all of this.

00:06:48,500 --> 00:06:53,040
Basically, the branches of Android 4.19 to 5.4,

00:06:54,070 --> 00:06:56,290
we are using a single configuration.

00:06:56,290 --> 00:07:00,770
We named it gki_defconfig, and it's basically for arm64.

00:07:00,770 --> 00:07:03,070
There's one x86 as well.

00:07:03,070 --> 00:07:06,160
We are using a single toolchain, Clang.

00:07:07,010 --> 00:07:08,340
And we are almost,

00:07:10,840 --> 00:07:12,980
I had an asterisk at Hermetic build,

00:07:12,980 --> 00:07:14,850
but we are basically trying to make sure

00:07:14,850 --> 00:07:17,070
all our common builds are reproducible as well.

00:07:17,070 --> 00:07:19,360
But, as far as the tooling is concerned,

00:07:19,360 --> 00:07:21,850
mostly within the repo package.

00:07:23,050 --> 00:07:24,030
And the scope is obviously,

00:07:24,030 --> 00:07:26,890
we want to make sure this kernel runs on arm64 and x86.

00:07:26,890 --> 00:07:29,510
I'm gonna move to the important parts.

00:07:29,510 --> 00:07:31,800
This is basically how we divided all the work.

00:07:31,800 --> 00:07:34,190
We have ABI monitoring, we need this obviously

00:07:34,190 --> 00:07:37,440
in order to make sure that device drivers

00:07:37,440 --> 00:07:38,870
and modules continue to work

00:07:38,870 --> 00:07:40,570
as we keep making kernel changes,

00:07:40,570 --> 00:07:42,312
and we want to make sure how we are changing it

00:07:42,312 --> 00:07:45,020
or LTS or our own changes.

00:07:45,020 --> 00:07:46,550
How do we choose kernel configurations

00:07:46,550 --> 00:07:47,600
that need to be enabled?

00:07:47,600 --> 00:07:49,340
We are basically working with everybody,

00:07:49,340 --> 00:07:53,190
so we are actually enabling a lot of things

00:07:53,190 --> 00:07:54,790
pretty much every single day into this,

00:07:54,790 --> 00:07:57,570
based on the needs and what gets enabled on devices.

00:07:59,520 --> 00:08:01,930
We also have to solve interdependencies

00:08:01,930 --> 00:08:03,940
between devices and device drivers,

00:08:03,940 --> 00:08:06,460
because this is something that we saw was,

00:08:06,460 --> 00:08:08,920
didn't quite actually work like what we expected

00:08:08,920 --> 00:08:09,753
in upstream as well.

00:08:09,753 --> 00:08:11,690
So, there are discussions going on in the mailing list,

00:08:11,690 --> 00:08:13,750
and I'll talk more about it later.

00:08:13,750 --> 00:08:15,110
We also have to make sure,

00:08:15,110 --> 00:08:18,360
we have been in the bad habit of breaking user space

00:08:18,360 --> 00:08:20,920
every year pretty much with Android common kernel.

00:08:20,920 --> 00:08:22,938
We decided we're not going to do that anymore,

00:08:22,938 --> 00:08:25,101
from when we do GKI.

00:08:25,101 --> 00:08:27,900
Before we sign up to do that,

00:08:27,900 --> 00:08:29,840
we want to make sure all the user space facing

00:08:29,840 --> 00:08:32,520
things are finalized and the way we want to.

00:08:32,520 --> 00:08:35,010
One of the biggest thing, in that,

00:08:35,010 --> 00:08:36,000
is basically SDCardFS and Ion,

00:08:36,000 --> 00:08:37,530
and so we want to make sure we're comfortable

00:08:37,530 --> 00:08:39,800
with whatever is there.

00:08:39,800 --> 00:08:42,400
I think there are talks about SDCardFS later

00:08:42,400 --> 00:08:44,850
that'll tell you about exactly which direction

00:08:44,850 --> 00:08:47,000
we are going to go.

00:08:48,370 --> 00:08:50,600
There are Android site changes needed

00:08:50,600 --> 00:08:51,610
for this to happen as well,

00:08:51,610 --> 00:08:54,710
and I think most of these are already done in AOSP,

00:08:54,710 --> 00:08:57,440
which included adding module support

00:08:57,440 --> 00:08:59,740
and basically splitting the initramfs in two,

00:08:59,740 --> 00:09:02,410
in order to make sure modules can be loaded

00:09:02,410 --> 00:09:06,160
from ramfs and there can be a hardware specific

00:09:06,160 --> 00:09:07,940
module that is needed for booting a device

00:09:07,940 --> 00:09:11,650
or mounting storage, for example, that is available.

00:09:11,650 --> 00:09:14,160
So, basically, how desktop distros have been working

00:09:14,160 --> 00:09:15,310
for years, pretty much.

00:09:18,020 --> 00:09:19,230
This is pretty much,

00:09:19,230 --> 00:09:21,690
this is Matthias' slide from yesterday.

00:09:21,690 --> 00:09:24,010
Basically, we already have enabled

00:09:24,897 --> 00:09:26,897
the ABI monitoring and enforcement AOSP.

00:09:27,870 --> 00:09:31,100
This, the way, tl;dr for this is the way this work is,

00:09:31,100 --> 00:09:35,650
if you end up changing an AI in kernel API or ABI,

00:09:35,650 --> 00:09:38,340
our tree hugger, or pre-submit, basically fails

00:09:38,340 --> 00:09:40,670
and doesn't let us check in that code,

00:09:40,670 --> 00:09:43,165
and so until we actually update the ABI

00:09:43,165 --> 00:09:44,990
with our next change,

00:09:44,990 --> 00:09:46,560
and we basically merge them both together.

00:09:46,560 --> 00:09:49,306
That basically tells us what do we continue to keep

00:09:49,306 --> 00:09:51,720
changing and what is being changed,

00:09:51,720 --> 00:09:55,840
even in RCs as we merge from inline as well.

00:09:55,840 --> 00:09:58,420
It has been working with a couple of quirks,

00:09:58,420 --> 00:10:01,640
but we are going through those.

00:10:01,640 --> 00:10:02,473
Defconfig.

00:10:02,473 --> 00:10:05,180
So, this is basically what I want to talk about here.

00:10:05,180 --> 00:10:08,682
We are noticing a bunch of problems for what we want to do.

00:10:08,682 --> 00:10:11,860
Now, the idea is we want to an arm64 kernels

00:10:11,860 --> 00:10:16,370
where you can have that kernel run on any given device,

00:10:16,370 --> 00:10:18,870
and it basically makes everything functional

00:10:18,870 --> 00:10:22,400
as the device specific drivers load into that kernel.

00:10:22,400 --> 00:10:25,810
Turns out that's actually difficult to do with arm64,

00:10:25,810 --> 00:10:27,860
because of a bunch of things.

00:10:27,860 --> 00:10:31,640
One is there are a lot of drivers that actually

00:10:31,640 --> 00:10:36,640
have config arch dependencies and these dependencies,

00:10:37,270 --> 00:10:40,750
as we found out, are not necessarily build dependencies,

00:10:40,750 --> 00:10:42,960
then neither are there any symbol dependencies.

00:10:42,960 --> 00:10:44,730
They're just dependencies because we know

00:10:44,730 --> 00:10:47,710
that piece, that particular hardware only exists

00:10:47,710 --> 00:10:49,540
on a particular architecture

00:10:49,540 --> 00:10:53,060
and that particular config arch.

00:10:53,060 --> 00:10:54,880
For example, it can be config arch qcom

00:10:54,880 --> 00:10:58,220
or config arch mediatek or whatever it can be, that is.

00:10:58,220 --> 00:11:00,230
And that's actually problematic because now you can't

00:11:00,230 --> 00:11:02,380
create a kernel that basically is generic

00:11:02,380 --> 00:11:04,960
and these drivers actually plug into them.

00:11:04,960 --> 00:11:06,440
So, that's problem number one.

00:11:06,440 --> 00:11:09,040
Second problem, and you'll see I actually have

00:11:09,040 --> 00:11:10,530
links to a lot of AOSP configs,

00:11:10,530 --> 00:11:13,480
which is a hack that we are working on right now

00:11:13,480 --> 00:11:17,350
and I think we're adding dummy Kconfig fragments right now

00:11:17,350 --> 00:11:18,780
in order to basically get a bunch

00:11:18,780 --> 00:11:20,730
of subsystems to building.

00:11:20,730 --> 00:11:23,230
Because these subsystems, as far as I remember,

00:11:23,230 --> 00:11:25,600
only are selected in Kconfig.

00:11:25,600 --> 00:11:28,950
They can't be just switched on and you have the framework

00:11:28,950 --> 00:11:30,440
code built as part of the kernel

00:11:30,440 --> 00:11:31,340
because the drivers need it.

00:11:31,340 --> 00:11:34,251
So most of the drivers just select them and there are,

00:11:34,251 --> 00:11:36,300
I'm pretty sure there are more examples of this.

00:11:36,300 --> 00:11:39,120
So, what we're doing for now, and we'll be sending

00:11:39,120 --> 00:11:40,590
e-mails again, but I'd like to know

00:11:40,590 --> 00:11:42,090
how do we solve this problem.

00:11:42,090 --> 00:11:45,360
Is basically we're adding a dummy config with

00:11:45,360 --> 00:11:48,240
solely for the purpose of selecting these configs.

00:11:48,240 --> 00:11:51,050
Just so we have a kernel which basically has all the

00:11:51,050 --> 00:11:53,470
subsystems built in and then the drivers can probe,

00:11:53,470 --> 00:11:58,240
but that's actually definitely wrong if I'm not visible.

00:11:58,240 --> 00:11:59,460
Some of these are probably easy.

00:11:59,460 --> 00:12:03,530
Just, oh you just make them (mumbles)

00:12:03,530 --> 00:12:05,580
and give an option to select them.

00:12:05,580 --> 00:12:07,210
But as of now, at least that's not true.

00:12:07,210 --> 00:12:12,210
So we are finding a lot of those.

00:12:12,340 --> 00:12:14,190
Device dependencies.

00:12:14,190 --> 00:12:17,420
Oh, deferred probe is another fun thing.

00:12:17,420 --> 00:12:18,253
It works.

00:12:19,650 --> 00:12:21,820
But now, for example, if you have a phone,

00:12:21,820 --> 00:12:24,240
and you're deferring probe because you're discovering

00:12:24,240 --> 00:12:26,200
device is out of order,

00:12:26,200 --> 00:12:28,120
then you're actually going to finish booting

00:12:28,120 --> 00:12:30,970
about 10 times slower than a normal phone.

00:12:30,970 --> 00:12:34,330
And that's a problem because we don't necessarily

00:12:34,330 --> 00:12:37,750
want to say, Oh, you do this generic Kernel,

00:12:37,750 --> 00:12:41,130
and now, you adjust boot time so it's never gonna happen.

00:12:41,130 --> 00:12:44,910
This is a solvable problem if you know the probe order.

00:12:44,910 --> 00:12:48,500
But how do we know that is an open question?

00:12:48,500 --> 00:12:50,210
I think there have been discussions around this

00:12:50,210 --> 00:12:52,450
has been meaningless.

00:12:52,450 --> 00:12:54,350
Cycling dependencies between devices.

00:12:54,350 --> 00:12:56,420
Same thing, basically,

00:12:56,420 --> 00:12:58,780
and even the post-boot device state clean up.

00:12:58,780 --> 00:13:00,740
Basically, the last one actually talks about

00:13:00,740 --> 00:13:03,090
there are some frameworks,

00:13:03,090 --> 00:13:04,630
and I don't remember which one exactly,

00:13:04,630 --> 00:13:07,230
but there are some frameworks where what ends up happening

00:13:07,230 --> 00:13:11,020
is your boot-up device and,

00:13:11,020 --> 00:13:13,270
at that time, there'll be some measures,

00:13:13,270 --> 00:13:14,780
policy and measures applied.

00:13:14,780 --> 00:13:16,300
Oh, I think it regulator, right?.

00:13:16,300 --> 00:13:17,790
Correct if I'm wrong.

00:13:17,790 --> 00:13:19,533
Maxial, hank you.

00:13:22,372 --> 00:13:24,524
(speaking faintly off mic)

00:13:24,524 --> 00:13:26,390
(laughing)

00:13:26,390 --> 00:13:30,894
- Yeah, so I actually, yesterday,

00:13:30,894 --> 00:13:32,340
(background noise draws off the sound)

00:13:32,340 --> 00:13:36,650
which will work around the regulator thing.

00:13:36,650 --> 00:13:39,210
It will now wait 30 seconds after boot

00:13:41,510 --> 00:13:43,320
to power off the regulators.

00:13:43,320 --> 00:13:45,540
So if you haven't, and if you haven't managed

00:13:45,540 --> 00:13:48,250
to lose your modules on your phone in 30 seconds,

00:13:48,250 --> 00:13:49,610
you've got a problem anyway.

00:13:49,610 --> 00:13:51,540
So it'll probably solve your problems for the regulators.

00:13:51,540 --> 00:13:53,650
- [Sandeep] Not necessarily true.

00:13:53,650 --> 00:13:54,590
No, no, no.

00:13:54,590 --> 00:13:56,010
I wanna make sure everybody know that.

00:13:56,010 --> 00:13:56,860
Not necessarily true.

00:13:56,860 --> 00:13:58,720
Because, for example, having these modules

00:13:58,720 --> 00:14:00,950
also enables something unique for us.

00:14:00,950 --> 00:14:02,200
For example, with trouble,

00:14:02,200 --> 00:14:04,070
we separate HAL down, right?

00:14:04,070 --> 00:14:07,830
So we don't necessarily add or start all of the HAL,

00:14:07,830 --> 00:14:09,990
because of whatever, memory or whatever reason.

00:14:09,990 --> 00:14:11,428
I'll give you a normal example.

00:14:11,428 --> 00:14:12,261
(speaking faintly off mic)

00:14:12,261 --> 00:14:13,094
Sure.

00:14:13,094 --> 00:14:15,900
You can defer starting camera HAL,

00:14:15,900 --> 00:14:18,040
because you don't need camera for boot.

00:14:18,040 --> 00:14:19,880
But if I'm deferring starting camera HAL,

00:14:19,880 --> 00:14:21,540
then I wanna make sure all the camera drivers

00:14:21,540 --> 00:14:23,280
are loaded when the HAL Is started.

00:14:23,280 --> 00:14:27,499
So there goes your 30 second time right there.

00:14:27,499 --> 00:14:28,460
- Yeah.

00:14:28,460 --> 00:14:31,500
It's really only critical for the display.

00:14:31,500 --> 00:14:33,300
I think, everything else,

00:14:33,300 --> 00:14:35,150
you can just power up again later on.

00:14:37,930 --> 00:14:39,210
- There was a use case, for example,

00:14:39,210 --> 00:14:41,660
on the under , they wanna turn on the camera

00:14:41,660 --> 00:14:43,570
in the bootloader, so that when they're reserving the HAL

00:14:43,570 --> 00:14:45,550
they can see it, before the kernel boots up.

00:14:45,550 --> 00:14:47,873
So it's not as simple as that, I think.

00:14:50,982 --> 00:14:53,149
(mumbles)

00:14:55,740 --> 00:14:58,010
- Another note talk, if possible,

00:14:58,010 --> 00:15:01,010
(audience laughing)

00:15:03,000 --> 00:15:06,570
was I know there is a solution around,

00:15:06,570 --> 00:15:09,010
to actually over around DMA-BUF heaps,

00:15:09,010 --> 00:15:13,280
and we all like it and we should do that upstream.

00:15:13,280 --> 00:15:16,450
We do, however, have to do something about Ion

00:15:16,450 --> 00:15:18,320
for the purposes of GKI,

00:15:18,320 --> 00:15:21,740
which means we're gonna change the UAPI again for ION.

00:15:21,740 --> 00:15:23,070
But it will be only Android.

00:15:23,070 --> 00:15:25,320
I didn't even bother sending these patches upstream.

00:15:25,320 --> 00:15:26,370
If anybody wants to see them,

00:15:26,370 --> 00:15:27,430
just tell me, I'll send them.

00:15:27,430 --> 00:15:30,140
But I figured nobody will be interested.

00:15:30,140 --> 00:15:31,076
What?

00:15:31,076 --> 00:15:31,909
(audience member speaking faintly)

00:15:31,909 --> 00:15:32,742
Yeah, exactly.

00:15:32,742 --> 00:15:36,180
But the reason why we need to is because Android

00:15:36,180 --> 00:15:38,880
has started using Ion now,

00:15:38,880 --> 00:15:42,060
which means, previously, Ion was only used by us HALs.

00:15:42,060 --> 00:15:43,600
But now that there's Android dependency,

00:15:43,600 --> 00:15:45,450
that means we can't necessarily have,

00:15:47,400 --> 00:15:50,260
we need to have some sort of consistency

00:15:50,260 --> 00:15:52,930
across devices for Android to be able to use it.

00:15:52,930 --> 00:15:56,660
A simple as a system heap may have any given ID

00:15:56,660 --> 00:15:58,910
as of today, so we're trying to fix all of that

00:15:58,910 --> 00:16:00,920
in order to at least standardize those heap ideas,

00:16:00,920 --> 00:16:01,753
and that's the whole reason

00:16:01,753 --> 00:16:03,330
why we're changing Ion right now.

00:16:03,330 --> 00:16:06,830
You will not see those patches, don't worry about it.

00:16:06,830 --> 00:16:08,930
We have a plan for SDCardFS, as well,

00:16:08,930 --> 00:16:13,120
which is to, I think, I'm gonna steal Daniel's stand

00:16:13,120 --> 00:16:14,790
and say, "Not to use it."

00:16:14,790 --> 00:16:16,920
But we're figuring out.

00:16:16,920 --> 00:16:20,130
We have a couple of things in mind

00:16:20,130 --> 00:16:21,560
for how do we do that,

00:16:21,560 --> 00:16:25,030
and Daniel's gonna talk about it more.

00:16:25,030 --> 00:16:27,140
Case folding support, I think Daniel didn't boot

00:16:27,140 --> 00:16:30,350
the file systems, that mostly end up getting used

00:16:30,350 --> 00:16:32,430
in Android for on user data.

00:16:32,430 --> 00:16:35,500
Ext4 and FTS and that definitely helps with the SDCardFS,

00:16:35,500 --> 00:16:37,242
and you'll hear more about it.

00:16:37,242 --> 00:16:38,075
LMKD.

00:16:38,075 --> 00:16:40,650
Again, I think the Low Memory Killer Daemon

00:16:40,650 --> 00:16:42,850
went away since 4.12.

00:16:42,850 --> 00:16:44,980
All Android minimum kernel version

00:16:44,980 --> 00:16:46,700
will be 4.14 and onwards.

00:16:46,700 --> 00:16:48,670
So we want to make sure LMKD works for everybody.

00:16:48,670 --> 00:16:50,722
So we are working with everyone to make sure

00:16:50,722 --> 00:16:52,570
the use space low memory killer works,

00:16:52,570 --> 00:16:54,620
so we never see the in-kernel one.

00:16:54,620 --> 00:16:55,930
And now, that way, basically,

00:16:55,930 --> 00:16:57,161
we get rid of all of our,

00:16:57,161 --> 00:16:58,710
at least try and remove

00:16:58,710 --> 00:17:03,710
all of our user space longstanding problems if you will.

00:17:04,860 --> 00:17:06,790
And SDCardFS has a nice side effect

00:17:06,790 --> 00:17:09,510
of all the bad stack that we've been carrying

00:17:09,510 --> 00:17:10,450
goes away with it.

00:17:13,650 --> 00:17:14,483
Android.

00:17:14,483 --> 00:17:16,230
Anybody interested in, so this is,

00:17:16,230 --> 00:17:18,070
actually simple as modprobe.

00:17:18,070 --> 00:17:19,400
We didn't have modprobe in Android,

00:17:19,400 --> 00:17:21,000
so now, we added modprobe.

00:17:21,000 --> 00:17:24,700
It also allows us to have configuration

00:17:24,700 --> 00:17:26,140
and dependencies between modules.

00:17:26,140 --> 00:17:28,950
We can have built-on dependencies, et cetera, et cetera.

00:17:28,950 --> 00:17:31,390
Everybody who's familiar with Linux and Distros

00:17:31,390 --> 00:17:32,223
already know this.

00:17:32,223 --> 00:17:33,630
Android didn't, now, it does.

00:17:34,580 --> 00:17:36,600
But split ramfs is another interesting thing

00:17:36,600 --> 00:17:38,311
because it allows us to, say,

00:17:38,311 --> 00:17:41,780
give it a, give it a choice if there's a specific

00:17:41,780 --> 00:17:44,380
higher module that we have in GKI

00:17:44,380 --> 00:17:47,290
that we know because every hardware is different

00:17:47,290 --> 00:17:48,820
and there are custom permissions right now

00:17:48,820 --> 00:17:51,280
that allows the second ramfs to override

00:17:51,280 --> 00:17:52,150
the first ramfs.

00:17:53,541 --> 00:17:55,130
And that's the whole purpose of split ramfs.

00:17:55,130 --> 00:17:57,830
And it also keeps the ownership separate because, then,

00:17:57,830 --> 00:18:00,930
on any given device, we can have our ramfs,

00:18:00,930 --> 00:18:03,190
and our kernel, you can just literally put it,

00:18:03,190 --> 00:18:05,090
flash it on the device and eveything should just work.

00:18:05,090 --> 00:18:07,130
That's the whole idea of splitting

00:18:07,130 --> 00:18:11,890
where the modules are sourced from.

00:18:11,890 --> 00:18:14,670
Linaro, obviously, is helping us with making

00:18:14,670 --> 00:18:16,976
all the AOSP dev boards work with the GKI.

00:18:16,976 --> 00:18:20,940
We have miles to go, and we know that,

00:18:20,940 --> 00:18:23,590
but we've come along from where we started.

00:18:23,590 --> 00:18:25,940
Last year, I talked it into existence.

00:18:25,940 --> 00:18:29,500
This time, we actually have problems to discuss.

00:18:29,500 --> 00:18:30,630
Real ones.

00:18:30,630 --> 00:18:34,480
There is another, all of our changes

00:18:34,480 --> 00:18:35,970
and everything is in AOSP.

00:18:35,970 --> 00:18:37,610
Whether you have problems, questions,

00:18:37,610 --> 00:18:39,250
what we are up to, by all means,

00:18:39,250 --> 00:18:40,930
that's the email address that you reach out to.

00:18:40,930 --> 00:18:42,880
Just email us and we'll be,

00:18:42,880 --> 00:18:44,510
we are fairly responsive.

00:18:46,130 --> 00:18:46,963
And that's it.

00:18:46,963 --> 00:18:47,796
That's all I have.

00:18:47,796 --> 00:18:49,600
Any comments?

00:18:49,600 --> 00:18:50,433
I'm I right on time?

00:18:50,433 --> 00:18:51,266
(audience member speaking faintly)

00:18:51,266 --> 00:18:52,099
There you go.

00:18:52,099 --> 00:18:52,932
- This is special.

00:18:52,932 --> 00:18:55,073
So Matthias, cause we're out of time.

00:19:00,030 --> 00:19:02,947
(speaking faintly)

00:19:12,330 --> 00:19:13,740
- Yeah, I am Matthias.

00:19:15,005 --> 00:19:19,130
Whoever was on yesterday's version of the talks,

00:19:19,130 --> 00:19:19,963
pretty much, the same,

00:19:19,963 --> 00:19:22,550
but feel free to just interrupt me

00:19:22,550 --> 00:19:25,640
whenever you feel there is a question because,

00:19:25,640 --> 00:19:28,408
I promise, it gets more and more boring towards the end.

00:19:28,408 --> 00:19:30,890
(audience laughing)

00:19:30,890 --> 00:19:33,110
Because of the material,

00:19:33,110 --> 00:19:35,920
just examples and stuff.

00:19:35,920 --> 00:19:38,750
I'm talking about how we can monitor and stabilize

00:19:38,750 --> 00:19:39,960
the in-kernel ABI.

00:19:39,960 --> 00:19:41,260
As Sandeep just mentioned,

00:19:42,160 --> 00:19:46,170
we want to create a generic kernel image.

00:19:46,170 --> 00:19:49,940
And so, we want to reduce the many, many kernels

00:19:49,940 --> 00:19:51,830
we have run for different devices.

00:19:51,830 --> 00:19:54,730
And so, we want to consolidate on a single ABI/API

00:19:57,723 --> 00:19:58,790
to actually achieve that,

00:19:58,790 --> 00:20:01,370
to agree things and also keep things stable.

00:20:03,737 --> 00:20:05,070
So why do we do that?

00:20:05,070 --> 00:20:06,610
Yes, I know there are stable APIs known

00:20:06,610 --> 00:20:07,850
and we should not do that.

00:20:07,850 --> 00:20:09,600
And I'm not talking about mainline.

00:20:09,600 --> 00:20:12,190
I'm not talking about latest mainline.

00:20:12,190 --> 00:20:14,250
I'm talking about that particular case

00:20:14,250 --> 00:20:18,300
that we are having, LTS kernels, yeah.

00:20:19,760 --> 00:20:22,030
We want to do a couple development

00:20:22,030 --> 00:20:23,530
of the kernel and its modules.

00:20:26,780 --> 00:20:28,260
We want to decouple the development

00:20:28,260 --> 00:20:29,810
of the kernel and it's modules,

00:20:31,360 --> 00:20:34,480
not because we don't like the modules to be in three

00:20:34,480 --> 00:20:38,800
but the reality is just like modules are developed outside

00:20:38,800 --> 00:20:41,260
and so we have to accommodate to that.

00:20:41,260 --> 00:20:44,618
As I said we want to provide a single kernel ABI/API

00:20:44,618 --> 00:20:46,420
for that ecosystem of vendor modules

00:20:46,420 --> 00:20:50,810
that they just have to eventually reduce fragmentation.

00:20:50,810 --> 00:20:53,100
Fragmentation that we have several kernels

00:20:53,100 --> 00:20:58,100
per Android version almost a kernel per device

00:20:58,510 --> 00:20:59,510
like heavily forked.

00:21:01,380 --> 00:21:04,580
Versus coming from, as Sandeep said, yeah basically,

00:21:04,580 --> 00:21:07,650
the story of decoupling vendor parts

00:21:07,650 --> 00:21:10,630
from generic parts continues into the kernel,

00:21:12,150 --> 00:21:16,440
to have a generic kernel image, generic kernel modules

00:21:16,440 --> 00:21:21,200
that expose an API/ABI towards something

00:21:21,200 --> 00:21:22,400
that is vendor specific

00:21:23,980 --> 00:21:26,330
and exactly this blue border

00:21:26,330 --> 00:21:27,830
we want to control or monitor.

00:21:30,810 --> 00:21:32,880
That light should be familiar.

00:21:32,880 --> 00:21:35,080
Someone used it already.

00:21:35,080 --> 00:21:36,960
Yeah(laughs hysterically)

00:21:36,960 --> 00:21:38,827
So I can skip it.

00:21:38,827 --> 00:21:43,160
It contains the asterisks at Hermetic Toolchain.

00:21:43,160 --> 00:21:45,840
You're not yet really there but almost.

00:21:46,790 --> 00:21:50,300
So we cannot just say we have an internal ABI

00:21:50,300 --> 00:21:51,370
and we keep that stable.

00:21:51,370 --> 00:21:54,030
So we have to make some constraints under which we do that.

00:21:54,030 --> 00:21:57,130
First of all, we limit ourselves to LTS branches.

00:21:57,130 --> 00:22:01,350
So in that case Android 4.19, Android 5x,

00:22:01,350 --> 00:22:02,450
whatever that will be.

00:22:04,090 --> 00:22:06,931
We also only support that single configuration

00:22:06,931 --> 00:22:09,840
that is relevant for us or for Android

00:22:09,840 --> 00:22:13,800
the generic kernel image configuration, we can call it,

00:22:13,800 --> 00:22:17,180
where we agree that with partners and vendors

00:22:17,180 --> 00:22:21,600
and users of Android on a common configuration.

00:22:23,720 --> 00:22:27,230
Obviously the two chain has a significant influence

00:22:27,230 --> 00:22:29,920
on how binaries are build and what effects

00:22:29,920 --> 00:22:34,920
it can have on the twitch, under ABI that you expose.

00:22:35,210 --> 00:22:39,180
So in in that particular version of Android kernel

00:22:39,180 --> 00:22:42,850
we only build that clang and we restrict ourselves

00:22:42,850 --> 00:22:44,610
to that hermetic toolchain

00:22:44,610 --> 00:22:46,730
where we contain every tool

00:22:46,730 --> 00:22:49,100
that that we use during the built.

00:22:49,100 --> 00:22:53,730
Not only compilers linkers but down to you name and prods

00:22:53,730 --> 00:22:58,270
whatever is used indirectly by make files and so on.

00:22:59,840 --> 00:23:03,350
We also try to restrict the scope of

00:23:03,350 --> 00:23:04,790
what we want to keep stable.

00:23:04,790 --> 00:23:07,380
So we just, at the moment we are saying

00:23:07,380 --> 00:23:12,380
whatever is observable but binary exposes is kept stable.

00:23:13,290 --> 00:23:16,420
In the long run that that will not be our only scope.

00:23:16,420 --> 00:23:20,340
We will most likely throw that down to whitelists,

00:23:20,340 --> 00:23:23,300
maybe use symbol namespaces

00:23:23,300 --> 00:23:26,830
to say we keep this kind of symbol stable.

00:23:33,080 --> 00:23:33,913
How do we do that?

00:23:33,913 --> 00:23:37,440
In the kernel Build, so basically we still use make

00:23:37,440 --> 00:23:39,880
and whatever upstream is used as a make tools,

00:23:39,880 --> 00:23:43,050
we don't replace that, but we wrapped that

00:23:43,050 --> 00:23:46,140
to actually come to the point that

00:23:46,140 --> 00:23:49,470
we have a hermetic tool chain cross-compiler set up.

00:23:51,005 --> 00:23:53,470
The directory, distribution directory

00:23:53,470 --> 00:23:55,560
in a way that we can later integrate

00:23:55,560 --> 00:23:59,480
it into the platform built very very easily.

00:24:00,370 --> 00:24:02,809
And obviously we also integrate ABI tooling.

00:24:02,809 --> 00:24:07,809
Like extracting ABI and comparing ABI against the reference.

00:24:09,450 --> 00:24:12,430
And to show that it's actually easy to use

00:24:13,393 --> 00:24:18,270
and that's actually easy to integrate in an automation,

00:24:18,270 --> 00:24:19,950
it's literally three commands.

00:24:20,920 --> 00:24:22,220
If you have installed a repo

00:24:22,220 --> 00:24:27,220
which maybe is okay to assume in android context.

00:24:27,710 --> 00:24:31,640
So literally getting the sources repo sync gets everything

00:24:31,640 --> 00:24:34,040
including the sources, but also the tool chain

00:24:34,040 --> 00:24:38,290
and every necessary tool and build ABI

00:24:38,290 --> 00:24:40,020
is just building the kernel,

00:24:40,020 --> 00:24:42,280
but that will change hermetic

00:24:42,280 --> 00:24:46,497
and creates an ABI representation and compares it

00:24:46,497 --> 00:24:49,850
if necessary against the reference.

00:24:51,570 --> 00:24:55,674
Also that's like we saw already earlier. (laughs)

00:24:55,674 --> 00:24:57,340
That's literally what happens.

00:24:57,340 --> 00:25:02,340
So if you're on a branch where a baseline is defined

00:25:02,410 --> 00:25:04,690
that is currently the case for Android 4.19

00:25:04,690 --> 00:25:07,930
and Android mainline where do that exercise even though

00:25:07,930 --> 00:25:09,810
it breaks continuously from upstream,

00:25:11,990 --> 00:25:15,260
we keep that reference there, we want to keep it stable

00:25:15,260 --> 00:25:17,360
as much as we can.

00:25:17,360 --> 00:25:19,590
And every time someone breaks it even

00:25:19,590 --> 00:25:23,000
if the upstream arch comes in and breaks it we see

00:25:23,000 --> 00:25:25,740
these kind of differences reported every time

00:25:25,740 --> 00:25:28,940
as part of our continuous integration process.

00:25:28,940 --> 00:25:32,570
So even though, yeah if its great the upstream currently

00:25:32,570 --> 00:25:36,620
and yeah we see the breakage and we update the reference

00:25:36,620 --> 00:25:39,920
but we still see what all is regularly breaking

00:25:39,920 --> 00:25:41,220
if the tooling is working.

00:25:44,190 --> 00:25:47,130
Under the hood, we use Libabigail.

00:25:47,130 --> 00:25:51,960
Libabigail is a set of libraries and tools

00:25:51,960 --> 00:25:54,080
to analyze binaries.

00:25:54,080 --> 00:25:57,740
Historically, t was used for userspace binaries,

00:25:58,820 --> 00:26:02,510
but got kernel support fairly recently,

00:26:02,510 --> 00:26:03,610
a couple of years ago.

00:26:05,850 --> 00:26:09,160
It can work with elf binaries in general

00:26:09,160 --> 00:26:12,700
but it understands the way kernel symbols are exported

00:26:12,700 --> 00:26:15,240
in the case on top, and makes use of that .

00:26:16,530 --> 00:26:18,900
In addition, it uses to off information

00:26:18,900 --> 00:26:23,740
to get line information, type, names and all this

00:26:23,740 --> 00:26:27,690
that we need to actually compare since ELF

00:26:27,690 --> 00:26:30,240
is not for example encoding return types

00:26:30,240 --> 00:26:32,060
or anything else other than the name.

00:26:33,180 --> 00:26:35,760
We need additional information from the ELF

00:26:35,760 --> 00:26:39,340
to actually extract ABI relevant stuff.

00:26:41,900 --> 00:26:44,490
4.19 kernels are almost supported.

00:26:44,490 --> 00:26:47,580
The patches under on the list and for review.

00:26:48,630 --> 00:26:52,680
So latest master Abigail given that patches emerged soon,

00:26:52,680 --> 00:26:54,590
we should be able to work

00:26:54,590 --> 00:26:58,020
with 4.19 kernel modules and kernels.

00:27:00,768 --> 00:27:04,150
And yeah, how does it look like our representation?

00:27:05,540 --> 00:27:08,440
On the left side it's not really kernel code

00:27:08,440 --> 00:27:10,930
but it should give me an impression,

00:27:10,930 --> 00:27:12,340
we have a struct there,

00:27:12,340 --> 00:27:17,130
we have like kind of a nested data type.

00:27:18,170 --> 00:27:21,650
We have functions that refer to that struct by pointer

00:27:21,650 --> 00:27:23,480
or by the struct itself.

00:27:23,480 --> 00:27:26,500
You have an enum and on the right side

00:27:26,500 --> 00:27:27,900
you can see how that is captured.

00:27:27,900 --> 00:27:30,200
So first of all we we look at the ELF.

00:27:31,550 --> 00:27:33,370
The ELF are symbols that are along

00:27:33,370 --> 00:27:36,570
with the binary defined in the case on top,

00:27:36,570 --> 00:27:39,720
in the kernel case, but in in any other case

00:27:39,720 --> 00:27:41,260
just as an elf symbol.

00:27:45,040 --> 00:27:47,700
In addition, so A C B, all these data structures

00:27:47,700 --> 00:27:48,790
from the left.

00:27:48,790 --> 00:27:52,860
In addition, that comes from the drawer of information

00:27:52,860 --> 00:27:55,670
where we see the decoration of that enum,

00:27:55,670 --> 00:27:57,780
even though it's not in an ELF symbol.

00:27:57,780 --> 00:28:02,780
We see, I left out some parts of that

00:28:03,195 --> 00:28:04,028
but the essential parts you can see

00:28:04,028 --> 00:28:08,800
the function declaration with the types

00:28:08,800 --> 00:28:11,150
the parameter type parameter types for example,

00:28:12,083 --> 00:28:14,660
this type ID 3 which refers to that enum here.

00:28:14,660 --> 00:28:18,640
So you see func_enum, first parameter is that enum

00:28:20,694 --> 00:28:22,770
and it's referred to here as that type.

00:28:22,770 --> 00:28:25,780
So whenever there is a change in that particular enum,

00:28:25,780 --> 00:28:26,730
it will be tracked.

00:28:29,230 --> 00:28:34,230
Similar for structs, and it's also you can use(mumbles)

00:28:37,206 --> 00:28:38,245
Time?

00:28:38,245 --> 00:28:39,779
I can--

00:28:39,779 --> 00:28:40,612
- [Karim] We've got 30 seconds before

00:28:40,612 --> 00:28:42,653
we start the discussion.

00:28:42,653 --> 00:28:45,920
- Okay as I said, it gets a bit...

00:28:47,080 --> 00:28:50,060
How does a breakage actually look like.

00:28:50,060 --> 00:28:53,830
One of the one of the very easy cases is removing a function

00:28:53,830 --> 00:28:56,460
So the two are reported as removed function.

00:28:59,050 --> 00:29:01,110
Another case is obviously adding a function

00:29:01,110 --> 00:29:03,750
which is technically not a breakage in that case,

00:29:05,010 --> 00:29:08,030
but still if you want to keep your ABI a stable

00:29:08,030 --> 00:29:10,450
from that moment on you have to consider it

00:29:10,450 --> 00:29:13,580
as part of your ABI since an additional change might break

00:29:13,580 --> 00:29:15,630
that particular part that you just added.

00:29:17,580 --> 00:29:20,120
So that's a thing that you have to consider.

00:29:21,780 --> 00:29:23,980
I have a couple of questions at the end.

00:29:24,870 --> 00:29:27,822
It might be of interest if no one has any questions.

00:29:27,822 --> 00:29:31,145
(all giggling)

00:29:31,145 --> 00:29:33,395
- [Karim] You have the mic?

00:29:34,588 --> 00:29:38,087
(audience speaks faintly)

00:29:38,087 --> 00:29:39,070
- All right, here's question.

00:29:39,070 --> 00:29:40,300
So I've been at your prior talk

00:29:40,300 --> 00:29:41,720
where you were talking regarding

00:29:41,720 --> 00:29:43,770
to some of the corner cases that you couldn't cover.

00:29:43,770 --> 00:29:44,603
- Yes!

00:29:44,603 --> 00:29:46,570
- Have you thought about you might be able

00:29:46,570 --> 00:29:48,740
to cover those problems if you had access

00:29:48,740 --> 00:29:49,860
to the source code.

00:29:49,860 --> 00:29:50,693
'Cause like for instance

00:29:50,693 --> 00:29:54,220
when you're looking at ABI changes like in an LTS context,

00:29:54,220 --> 00:29:55,550
you've got all the source code of it,

00:29:55,550 --> 00:29:58,120
there that you could be analyze it.

00:29:58,120 --> 00:29:58,953
- You mean?

00:30:00,300 --> 00:30:02,840
- So the tool right now works with binaries,

00:30:02,840 --> 00:30:04,160
but if you back that up a little bit,

00:30:04,160 --> 00:30:05,810
you take a look at the source code

00:30:05,810 --> 00:30:07,390
that's changed as well,

00:30:07,390 --> 00:30:09,020
so just think about it in the context,

00:30:09,020 --> 00:30:11,000
you've got access to all the source to.

00:30:11,000 --> 00:30:12,970
Could you make the tool better by going back

00:30:12,970 --> 00:30:14,480
and taking a look at the source

00:30:14,480 --> 00:30:15,680
besides just the binary.

00:30:16,580 --> 00:30:19,170
- Well, we are currently capturing like

00:30:19,170 --> 00:30:20,760
what is observable from the binary.

00:30:20,760 --> 00:30:22,680
Because that is kind of the truth

00:30:22,680 --> 00:30:25,330
of what we're actually exporting to everyone else

00:30:25,330 --> 00:30:29,930
and considering not only ELF but also DWARF information.

00:30:29,930 --> 00:30:31,653
It's something that is extending

00:30:31,653 --> 00:30:34,500
beyond that usual scope.

00:30:34,500 --> 00:30:36,259
So we're actually getting

00:30:36,259 --> 00:30:37,920
source code information into that.

00:30:37,920 --> 00:30:40,560
Like line information, type information

00:30:40,560 --> 00:30:41,660
that it's usually not part

00:30:41,660 --> 00:30:45,720
of like part of the ELF exposure there.

00:30:45,720 --> 00:30:48,140
So we are kind of getting that,

00:30:48,140 --> 00:30:50,640
but I think what you're more talking about

00:30:50,640 --> 00:30:54,560
whether we do actual like analysis of changes

00:30:54,560 --> 00:30:57,920
has come in to that or a really taking into source code,

00:30:57,920 --> 00:30:59,270
that's not the tool for it.

00:31:00,710 --> 00:31:02,690
That's not what we are doing with that tool.

00:31:02,690 --> 00:31:05,860
Maybe another tool is more useful because yeah.

00:31:07,150 --> 00:31:08,390
We're not doing patch analysis,

00:31:08,390 --> 00:31:10,430
we're doing like literally

00:31:10,430 --> 00:31:11,830
comparing the results of it.

00:31:13,620 --> 00:31:16,300
Results also, there's not only the source code

00:31:16,300 --> 00:31:18,560
that could change, it's also there the tool chain.

00:31:18,560 --> 00:31:23,560
If you're upgrading the compiler that might be possible

00:31:24,340 --> 00:31:25,760
in a compatible way.

00:31:25,760 --> 00:31:29,580
So we might upgrade to a clang whatever 10 11

00:31:29,580 --> 00:31:31,680
and do that in a way that it's compatible.

00:31:36,880 --> 00:31:38,390
Any further questions?

00:31:43,730 --> 00:31:46,900
Yeah, one other question I had in mind is,

00:31:46,900 --> 00:31:49,380
how do people think about runtime checks?

00:31:49,380 --> 00:31:52,510
Like using not necessarily libabigail

00:31:52,510 --> 00:31:56,970
but mechanisms like libabigail at runtime,

00:31:56,970 --> 00:31:59,550
like let's say at module load time,

00:32:01,250 --> 00:32:03,220
not the ones that are already there,

00:32:03,220 --> 00:32:05,790
but like literally looking at the binaries only.

00:32:07,650 --> 00:32:09,510
- I think what Matthias is asking is,

00:32:09,510 --> 00:32:12,129
does anybody know if mod versions work?

00:32:12,129 --> 00:32:15,388
(all laughing)

00:32:15,388 --> 00:32:17,471
- [Karim] Mic over there.

00:32:20,630 --> 00:32:23,020
- So I was in Doji's talk about libabigail

00:32:23,020 --> 00:32:25,310
the Toolchains Micro Conference this morning

00:32:25,310 --> 00:32:28,790
and Peter Zee had some pretty strong opinions

00:32:28,790 --> 00:32:30,550
about runtime stuff.

00:32:30,550 --> 00:32:33,170
So I'd suggest following up with him to see

00:32:33,170 --> 00:32:35,860
if he actually has some suggestions

00:32:35,860 --> 00:32:38,500
or if it's he's just saying no you can't do this at runtime

00:32:38,500 --> 00:32:39,800
or other things like that.

00:32:44,997 --> 00:32:47,640
- So I did not hear the runtime part from him.

00:32:47,640 --> 00:32:51,663
- I think Peter just, he didn't want to do this, right?

00:32:53,040 --> 00:32:55,380
But I think we need something like mod versions

00:32:55,380 --> 00:32:56,670
at runtime, yes.

00:32:56,670 --> 00:32:58,610
If we can make my versions work,

00:32:58,610 --> 00:33:02,460
there are real use cases independent command.

00:33:05,680 --> 00:33:10,160
- I think the question is more also are we able

00:33:10,160 --> 00:33:14,090
to trust that kind of tooling to omit these runtime checks.

00:33:18,354 --> 00:33:20,646
- [Karim] You got one minutes.

00:33:20,646 --> 00:33:22,227
Please stand when you are talking.

00:33:22,227 --> 00:33:25,517
- [Man] Yes, I mean we are(microphone humming)

00:33:25,517 --> 00:33:26,713
- [Man] Don't stand up please.

00:33:26,713 --> 00:33:29,003
(all laugh)

00:33:29,003 --> 00:33:30,380
- I mean we just want something like mod versions

00:33:30,380 --> 00:33:31,340
to work at runtime.

00:33:32,266 --> 00:33:33,500
I mean that's that was the goal, right?

00:33:33,500 --> 00:33:34,333
So yeah.

00:33:35,220 --> 00:33:36,053
Sorry, okay.

00:33:39,975 --> 00:33:41,758
- 30 seconds

00:33:41,758 --> 00:33:46,758
- Anyone?

00:33:47,010 --> 00:33:50,000
- Have we got like some sort of plan to like

00:33:50,000 --> 00:33:52,250
if you got a rebase a kernel to try

00:33:52,250 --> 00:33:55,420
and get back to the old ABI somehow or--

00:33:55,420 --> 00:33:57,590
- You mean something in between compatibility

00:33:57,590 --> 00:33:59,591
between five dots like android 4.19?

00:33:59,591 --> 00:34:02,600
- Yes, like try to actually reinforce an ABI

00:34:02,600 --> 00:34:06,800
as opposed to you know just noticing that it's broken.

00:34:06,800 --> 00:34:08,330
- I think that it's in the same category

00:34:08,330 --> 00:34:11,290
like keeping mainline ups compatible.

00:34:11,290 --> 00:34:15,240
I think that's not something that we should do at that time.

00:34:18,248 --> 00:34:19,280
- If I can grab that just for a second.

00:34:19,280 --> 00:34:21,840
So what I'll do for the future presentations is

00:34:21,840 --> 00:34:23,830
if you're close to the five-minute mark for discussion

00:34:23,830 --> 00:34:25,170
I'll tell you you have one minute left

00:34:25,170 --> 00:34:26,520
for presentation all right?

00:34:27,860 --> 00:34:30,810
- Hey, I'm Saravan from the Android kernel team too.

00:34:31,930 --> 00:34:33,970
And I'm here to talk about some of the issues

00:34:33,970 --> 00:34:37,130
we face with respect to modules and device dependencies

00:34:37,130 --> 00:34:38,980
and how we think we could solve them.

00:34:41,980 --> 00:34:44,430
So some base terms before we proceed.

00:34:44,430 --> 00:34:46,330
I call driver as a piece of software

00:34:46,330 --> 00:34:48,980
that knows how to operate a hardware IP.

00:34:48,980 --> 00:34:52,320
I define device as an instance of a hardware IP

00:34:52,320 --> 00:34:54,450
and it can have more than one of them.

00:34:54,450 --> 00:34:57,190
and the device is probed by a driver

00:34:57,190 --> 00:34:59,500
and if the driver knows how to operate the device

00:34:59,500 --> 00:35:01,980
and it can get all the resources it needs,

00:35:01,980 --> 00:35:03,180
then the probe succeeds.

00:35:04,620 --> 00:35:05,680
To give some context here is

00:35:05,680 --> 00:35:08,310
like a simplified view of boot flow.

00:35:08,310 --> 00:35:10,080
So when you do hardware reset

00:35:10,080 --> 00:35:12,170
or the bootload starts running,

00:35:12,170 --> 00:35:14,650
either one of them could turn on different resources

00:35:14,650 --> 00:35:15,760
in the chip.

00:35:15,760 --> 00:35:18,050
So hardware reset might turn on a bunch of power supplies

00:35:18,050 --> 00:35:19,750
so that it can actually boot.

00:35:19,750 --> 00:35:20,583
The bootload might go ahead

00:35:20,583 --> 00:35:22,180
and turn on the display and UART.

00:35:23,270 --> 00:35:24,400
Say around arch initcall

00:35:24,400 --> 00:35:27,680
the kernel probes the supplier drivers,

00:35:27,680 --> 00:35:28,890
so the clocks and regulators

00:35:28,890 --> 00:35:31,220
could be probed around that time.

00:35:31,220 --> 00:35:32,930
The device initcall level

00:35:32,930 --> 00:35:36,230
say the display driver and UART driver probes

00:35:36,230 --> 00:35:37,640
and then late initcall sync.

00:35:38,650 --> 00:35:41,470
The kernel will go on clean up the hardware state.

00:35:41,470 --> 00:35:43,630
So for example, since all the consumers

00:35:43,630 --> 00:35:45,350
have probed for the regulator's,

00:35:45,350 --> 00:35:47,720
you could go and turn off all the regulators

00:35:47,720 --> 00:35:49,220
and it would be safe to do so.

00:35:50,110 --> 00:35:53,070
Except it's not really true, there's no guarantee

00:35:53,070 --> 00:35:56,320
that the consumers are probed by late initcall sync.

00:35:56,320 --> 00:35:59,510
And if you turn off the resources that are used

00:35:59,510 --> 00:36:02,380
by devices that have not been probed yet

00:36:02,380 --> 00:36:05,340
but are still on, we'd have the system crash or misbehave.

00:36:07,640 --> 00:36:09,470
So today the kernel boot sequence

00:36:09,470 --> 00:36:12,190
is kinda like a delicate at the dependencies people using

00:36:12,190 --> 00:36:15,510
initcall link order to manually order our device probing,

00:36:15,510 --> 00:36:17,690
except it's not really ordering device probing,

00:36:17,690 --> 00:36:19,740
is really ordering driver registration.

00:36:20,740 --> 00:36:23,520
So if you have more than one device that is probed

00:36:23,520 --> 00:36:25,600
by the same driver, you can't really order them

00:36:25,600 --> 00:36:28,230
if they have different ordering requirements

00:36:28,230 --> 00:36:29,160
because you can only control

00:36:29,160 --> 00:36:31,589
the first time a register driver

00:36:31,589 --> 00:36:33,810
and not when the device gets probed.

00:36:33,810 --> 00:36:35,690
And finally the deferred probe throws

00:36:35,690 --> 00:36:37,090
all of this out the window.

00:36:37,090 --> 00:36:39,830
Like initcall call order doesn't mean anything

00:36:39,830 --> 00:36:42,560
once default probe kicks in

00:36:42,560 --> 00:36:44,390
and then once you have modules again,

00:36:44,390 --> 00:36:46,270
modules are loaded after late initcall sync.

00:36:46,270 --> 00:36:49,120
So you can't really do the cleanup at late initcall sync.

00:36:49,980 --> 00:36:53,240
You can do the 32nd one but we'll talk about that.

00:36:53,240 --> 00:36:54,940
So why are we interested in this?

00:36:54,940 --> 00:36:56,960
Like something we talked about,

00:36:56,960 --> 00:36:58,180
that we won't have one kernel

00:36:58,180 --> 00:37:00,960
that can boot all the different products

00:37:00,960 --> 00:37:02,590
and we won't have the drivers

00:37:02,590 --> 00:37:04,910
for each hardware specific stuff as a module.

00:37:05,800 --> 00:37:07,800
So that's where our interest comes from.

00:37:08,890 --> 00:37:11,770
So would you have any solution to actually have the device

00:37:11,770 --> 00:37:13,580
links which I think is gonna help us?

00:37:14,770 --> 00:37:17,350
Except it's almost there, not fully there.

00:37:17,350 --> 00:37:18,730
So it's a device links is

00:37:18,730 --> 00:37:21,240
an upstream API functionality framework

00:37:21,240 --> 00:37:23,440
whatever you want to call it in driver core.

00:37:24,500 --> 00:37:26,710
It allows you to track consumer supplier dependency.

00:37:26,710 --> 00:37:30,170
So I can say this device is a consumer for another device

00:37:30,170 --> 00:37:33,510
and then it allows you to or more it enforces ordering

00:37:33,510 --> 00:37:36,080
so it won't try to even probe the consumer before

00:37:36,080 --> 00:37:37,080
the suppliers probe.

00:37:38,040 --> 00:37:40,690
And then after supplier's probed

00:37:40,690 --> 00:37:42,350
and if the consumer's probed it keeps track

00:37:42,350 --> 00:37:43,680
of the state of each of these devices

00:37:43,680 --> 00:37:46,420
saying as a supplier that's the consumer probe,

00:37:46,420 --> 00:37:48,830
based on that it'll update the status of the link.

00:37:50,640 --> 00:37:53,820
And then the other missing pieces are that device links

00:37:53,820 --> 00:37:56,550
it has no mechanism to let the supplier know

00:37:56,550 --> 00:37:57,970
that all the consumers have probes

00:37:57,970 --> 00:38:02,730
so it can go and do say state cleanup in a safe way.

00:38:02,730 --> 00:38:04,240
And it also needs some other entity

00:38:04,240 --> 00:38:05,370
to go create the device links.

00:38:05,370 --> 00:38:07,480
It's not going to populate the device links on its own.

00:38:07,480 --> 00:38:09,380
That's not the point of the framework.

00:38:10,320 --> 00:38:12,810
And there's no way for all the consumers,

00:38:15,110 --> 00:38:16,650
there's no way to know when all the consumers

00:38:16,650 --> 00:38:18,950
have successfully linked to a supplier.

00:38:18,950 --> 00:38:21,860
So if you go check, are all my consumers probed,

00:38:21,860 --> 00:38:23,750
before all your consumers can link to you,

00:38:23,750 --> 00:38:26,150
the meaning of the question isn't really useful.

00:38:29,000 --> 00:38:30,750
So how do we solve this puzzle.

00:38:30,750 --> 00:38:33,260
I think we just need two pieces to solve this thing.

00:38:33,260 --> 00:38:36,180
First is update the device links

00:38:36,180 --> 00:38:38,880
in the driver core of driver core

00:38:38,880 --> 00:38:41,900
so that we can have a call back at the bus or driver level

00:38:41,900 --> 00:38:43,930
to let the device supplier know

00:38:43,930 --> 00:38:45,990
that all its consumers have probed.

00:38:45,990 --> 00:38:50,990
So I've added like a sync state call back to driver ops

00:38:51,060 --> 00:38:52,720
and for the bus ops.

00:38:52,720 --> 00:38:54,660
And the second part is having the format go ahead

00:38:54,660 --> 00:38:56,200
and create the links.

00:38:56,200 --> 00:38:58,230
So that you have all the dependents information

00:38:58,230 --> 00:39:00,060
in the format, so you can go create the links

00:39:00,060 --> 00:39:03,420
and once you create the links it can solve itself

00:39:04,630 --> 00:39:08,560
or device link solves all the issues for us.

00:39:08,560 --> 00:39:10,070
One question that often comes up

00:39:10,070 --> 00:39:12,250
and I've talked about this other people is

00:39:12,250 --> 00:39:14,800
why don't you have the driver create the links?

00:39:14,800 --> 00:39:17,120
The problem is that there's no way to differentiate

00:39:17,120 --> 00:39:19,830
between have all the consumers been added

00:39:19,830 --> 00:39:21,470
and linked to the particular supplier

00:39:21,470 --> 00:39:25,900
versus the model not being loaded at all.

00:39:25,900 --> 00:39:27,380
So there's like no way to differentiate

00:39:27,380 --> 00:39:29,560
when that transition happens.

00:39:29,560 --> 00:39:31,662
And then also there's no good way to ensure

00:39:31,662 --> 00:39:34,270
that the consumer gets a chance to link itself

00:39:34,270 --> 00:39:36,670
to the supplier, before the supplier goes ahead

00:39:36,670 --> 00:39:39,160
and ask for, hey are all my consumers probed?

00:39:40,430 --> 00:39:43,670
And then if you let the firmware create the device link

00:39:43,670 --> 00:39:45,190
so you have these benefits.

00:39:45,190 --> 00:39:47,860
So whether you're going to use the driver as a module

00:39:47,860 --> 00:39:50,150
or statically compiled in becomes irrelevant

00:39:50,150 --> 00:39:51,870
to the problem you're trying to solve.

00:39:51,870 --> 00:39:53,940
Because the firmware knows the details of the links,

00:39:53,940 --> 00:39:55,450
you don't need to wait for the driver.

00:39:56,300 --> 00:40:00,740
And then the other benefit is that we can know when

00:40:00,740 --> 00:40:02,480
all the consumers have been added

00:40:02,480 --> 00:40:05,244
because firmware is going to populate all the devices.

00:40:05,244 --> 00:40:07,550
You kinda know what's going on there.

00:40:07,550 --> 00:40:09,710
And you're not waiting for a driver

00:40:09,710 --> 00:40:11,160
to be loaded to achieve that.

00:40:12,190 --> 00:40:13,670
And then it also makes it pretty easy

00:40:13,670 --> 00:40:15,400
to give a chance to the consumer,

00:40:15,400 --> 00:40:17,710
to link itself to the supplier devices

00:40:17,710 --> 00:40:20,210
because the firmware is gonna do it for the device

00:40:22,610 --> 00:40:25,450
And so for that I can add it like a callback

00:40:25,450 --> 00:40:27,820
to the firmware node which is like a framework

00:40:27,820 --> 00:40:29,270
that can go create the links.

00:40:30,110 --> 00:40:32,210
And if it's respect to patches,

00:40:32,210 --> 00:40:34,600
that's the latest version of the patch set.

00:40:34,600 --> 00:40:36,110
There are more subtle details of about this

00:40:36,110 --> 00:40:37,360
that are captured in the comment text

00:40:37,360 --> 00:40:39,280
and documentation we try to put in there.

00:40:40,200 --> 00:40:41,200
And that's about it.

00:40:42,339 --> 00:40:43,172
(man laughs)

00:40:43,172 --> 00:40:44,372
How fast was that?

00:40:44,372 --> 00:40:45,312
- [Karim] That's awesome.

00:40:45,312 --> 00:40:47,034
You have a few minutes to go.

00:40:47,034 --> 00:40:49,920
- Okay, maybe I should have taken longer.

00:40:49,920 --> 00:40:51,400
So one more.

00:40:51,400 --> 00:40:56,400
- So one issue with the waiting until all the consumers

00:40:58,410 --> 00:41:00,580
have loaded is you're assuming that the system

00:41:00,580 --> 00:41:04,050
has any intention of loading a driver for every consumer.

00:41:06,200 --> 00:41:09,220
So you if you've got a device on the system

00:41:09,220 --> 00:41:12,120
that's described in your device tree or act tree whatever,

00:41:13,410 --> 00:41:16,460
but for the support just isn't in the kernel

00:41:16,460 --> 00:41:20,590
you're using than all the resources that users get wedged in

00:41:20,590 --> 00:41:24,960
their boots state, which may not be desirable.

00:41:24,960 --> 00:41:26,490
- [Saravana] But the opposite might also not

00:41:26,490 --> 00:41:28,090
be desirable so for example--

00:41:28,090 --> 00:41:29,590
- Okay, I'm not saying that it's good to boot,

00:41:29,590 --> 00:41:30,423
I'm just saying that you are--

00:41:30,423 --> 00:41:33,400
- So I think it was able to boot in that wedge state,

00:41:33,400 --> 00:41:34,930
I think it's better to leave it in a state

00:41:34,930 --> 00:41:37,400
that we know will work then trying to change it

00:41:37,400 --> 00:41:39,630
to a state that might not work.

00:41:39,630 --> 00:41:43,140
So for example you can have a backlight device

00:41:43,140 --> 00:41:44,780
and you don't have a driver for it--

00:41:44,780 --> 00:41:47,970
- The reason regulator API and the clock API do this

00:41:47,970 --> 00:41:52,970
is because there are particularly on older P mix you had,

00:41:52,977 --> 00:41:57,977
boards powering up with things weren't things enabled

00:41:58,200 --> 00:41:59,950
that were never ever gonna be used,

00:42:00,790 --> 00:42:02,440
because they were never ever gonna be used,

00:42:02,440 --> 00:42:04,610
there was no software to clean up after them,

00:42:04,610 --> 00:42:06,560
therefore we need something to run along

00:42:06,560 --> 00:42:09,810
and clean up the default hardware state.

00:42:11,219 --> 00:42:13,700
The default hardware state is not necessarily

00:42:13,700 --> 00:42:15,840
the non good state although it might be good.

00:42:15,840 --> 00:42:18,200
- It's definitely non-functional state.

00:42:18,200 --> 00:42:19,860
It might not be good in terms of power

00:42:19,860 --> 00:42:21,370
but definitely functional.

00:42:21,370 --> 00:42:22,810
So if you have a backlight and you don't have

00:42:22,810 --> 00:42:24,770
a driver for it, I would rather have the backlight on

00:42:24,770 --> 00:42:27,860
then you go turn it off and I can't see anything.

00:42:27,860 --> 00:42:30,620
And also at the worst case you can always come up

00:42:30,620 --> 00:42:33,310
with the dummy driver and it can override the driver

00:42:33,310 --> 00:42:36,350
just for but if you need to; if you really need to.

00:42:36,350 --> 00:42:37,980
It's still better than having a timer

00:42:37,980 --> 00:42:39,880
or just turning it off out of nowhere.

00:42:41,710 --> 00:42:43,140
Aim for the head please.

00:42:43,140 --> 00:42:47,190
- I know, I actually have a question.

00:42:48,288 --> 00:42:52,850
The problem with the device tree having devices described

00:42:52,850 --> 00:42:56,320
that may not have drivers, wouldn't this actually force us

00:42:56,320 --> 00:42:57,690
to make sure there are drivers

00:42:57,690 --> 00:43:00,439
and there are no additional nodes device described

00:43:00,439 --> 00:43:01,380
in device tree that nobody uses?

00:43:03,030 --> 00:43:04,370
- [Saravana] Aim for the head.

00:43:04,370 --> 00:43:09,370
- So you're gonna get my upstream kernel to full power

00:43:10,940 --> 00:43:12,230
of your drivers, are you?

00:43:12,230 --> 00:43:13,870
Great, thank you for solving the problem.

00:43:13,870 --> 00:43:17,610
- No, no, no, that's not what I'm saying.

00:43:17,610 --> 00:43:19,950
I'm saying if the node is defined in the device tree,

00:43:19,950 --> 00:43:23,570
if it does not have the driver, then you're asking for it,

00:43:23,570 --> 00:43:25,450
not necessarily, it's not the framework problem,

00:43:25,450 --> 00:43:27,140
it's just because you don't have the driver

00:43:27,140 --> 00:43:28,520
and you define an extra node

00:43:28,520 --> 00:43:31,260
that's not even needed in your hardware.

00:43:32,460 --> 00:43:34,200
- My hardware shapes are intended to be run

00:43:34,200 --> 00:43:37,180
with your proprietary kernel and I'm running upstream on it.

00:43:37,180 --> 00:43:38,460
They are in the frame.

00:43:38,460 --> 00:43:41,060
- But the device stays the same either go.

00:43:41,060 --> 00:43:42,110
- That's the problem.

00:43:43,950 --> 00:43:45,980
- But I guess my main point is that it's at least

00:43:45,980 --> 00:43:48,680
a non-functional state might not be powered efficient.

00:43:48,680 --> 00:43:50,240
It's better than going and turning them off

00:43:50,240 --> 00:43:52,980
without being sure.

00:43:52,980 --> 00:43:54,960
You can either leave at the bad power state

00:43:54,960 --> 00:43:56,150
or traction device.

00:43:56,150 --> 00:43:57,930
I'd go for the former.

00:43:57,930 --> 00:44:00,290
- There were some other model P mix

00:44:00,290 --> 00:44:02,220
where they didn't really run that stably

00:44:02,220 --> 00:44:04,322
if you left all the regulator's on.

00:44:04,322 --> 00:44:08,120
It was like the the P mix was non reprogrammable,

00:44:08,120 --> 00:44:09,310
so they had to do it.

00:44:09,310 --> 00:44:11,940
And they were just like boot up quickly turn this off

00:44:11,940 --> 00:44:14,350
and it probably won't blow anything up

00:44:14,350 --> 00:44:15,183
but it's not good.

00:44:15,183 --> 00:44:16,320
- But I think on a more serious note,

00:44:16,320 --> 00:44:17,820
if you really need something like that,

00:44:17,820 --> 00:44:20,530
I think you can always have like a dummy driver

00:44:20,530 --> 00:44:21,540
that you override in.

00:44:21,540 --> 00:44:23,520
If you really need to fix it that one.

00:44:23,520 --> 00:44:25,760
It's like a weird hardware do weird things.

00:44:25,760 --> 00:44:29,150
- I have a question, we have started to, oh sorry sorry,

00:44:29,150 --> 00:44:31,650
well we have started to the device links

00:44:31,650 --> 00:44:35,120
between ping control consumer handles

00:44:35,120 --> 00:44:37,010
and ping control providers.

00:44:37,010 --> 00:44:40,150
And there is a patch set for doing the same for GPIO,

00:44:40,150 --> 00:44:44,620
so that consumers of GPIO lines create

00:44:44,620 --> 00:44:47,060
a link back to the to the GPIO controller.

00:44:47,060 --> 00:44:51,460
So we are doing that in the core subsystem code.

00:44:51,460 --> 00:44:53,870
Is that how you perceive we should be doing it

00:44:53,870 --> 00:44:56,180
or should these links be created elsewhere?

00:44:56,180 --> 00:44:58,018
Are we doing the right thing?

00:44:58,018 --> 00:44:59,390
- So the way I see it, I mean you could do it that way

00:44:59,390 --> 00:45:01,940
but adding its support to my patch it is super easy.

00:45:01,940 --> 00:45:04,040
You just have to have like three to four lines of it.

00:45:04,040 --> 00:45:06,330
Just to know how to patch the P handle.

00:45:06,330 --> 00:45:07,800
So you don't have to do it in every framework,

00:45:07,800 --> 00:45:09,840
I'll just add like a one look few liners

00:45:09,840 --> 00:45:11,360
to the patch in descending order.

00:45:11,360 --> 00:45:15,170
- We also support board files and you know ACPIM.

00:45:15,170 --> 00:45:16,810
- But then another nice thing about diverse links

00:45:16,810 --> 00:45:17,643
is that you already have a link

00:45:17,643 --> 00:45:18,720
and you try to create another one,

00:45:18,720 --> 00:45:19,930
nothing goes wrong with it.

00:45:19,930 --> 00:45:20,763
- Ah, okay.

00:45:20,763 --> 00:45:21,916
- That's nice.

00:45:21,916 --> 00:45:23,010
- All right, fair enough.

00:45:26,290 --> 00:45:28,300
- Oh Frank, sorry I've been looking for you.

00:45:31,757 --> 00:45:34,171
- Off the record the patch is looking nice and cleaner.

00:45:34,171 --> 00:45:35,620
- You can say it on the mic too, it's okay.

00:45:36,597 --> 00:45:38,745
- [Karim I see you holding the mic.

00:45:38,745 --> 00:45:39,843
- [Saravan] He is doing it oof the record.

00:45:39,843 --> 00:45:41,522
- Off the record.

00:45:41,522 --> 00:45:45,590
One thing that I had proposed

00:45:45,590 --> 00:45:47,220
while going through this this patch set

00:45:47,220 --> 00:45:48,850
was an alternate approach which

00:45:50,330 --> 00:45:52,290
is have the bootloader passed the information

00:45:52,290 --> 00:45:55,960
to the kernel about what devices it had powered up.

00:45:55,960 --> 00:45:59,550
And then the framework could claim,

00:45:59,550 --> 00:46:01,800
do it get on any resource.

00:46:01,800 --> 00:46:04,150
Therefore, it wouldn't get shut off until a driver

00:46:04,150 --> 00:46:06,100
it appropriately done a put.

00:46:06,100 --> 00:46:07,470
That's been pushed.

00:46:07,470 --> 00:46:10,580
I got a lot of pushback against that because of a desire

00:46:10,580 --> 00:46:13,240
to not update all the bootloaders.

00:46:14,330 --> 00:46:17,710
But that's a much more direct approach I think.

00:46:17,710 --> 00:46:20,030
It avoids a lot of these problems

00:46:20,030 --> 00:46:23,210
although it's encountering other problems with boot loaders.

00:46:23,210 --> 00:46:25,740
- And also I think if the kernel has all the information

00:46:25,740 --> 00:46:26,850
to do the right thing,

00:46:26,850 --> 00:46:28,690
you don't have to depend on the bootloader.

00:46:28,690 --> 00:46:29,950
I'm not sure we need to talk

00:46:29,950 --> 00:46:31,580
a little bit more after this. - Yeah, of course.

00:46:31,580 --> 00:46:33,422
- There's one more corner case

00:46:33,422 --> 00:46:35,350
that you may have explained to me before and I've forgotten

00:46:35,350 --> 00:46:36,183
- It sounds good.

00:46:36,183 --> 00:46:37,070
- Let's talk after.

00:46:40,590 --> 00:46:42,420
- Rob, I thought I saw Rob in here.

00:46:42,420 --> 00:46:44,460
Or there is no question or comments Rob?

00:46:45,631 --> 00:46:49,657
- We got a few minutes which is good.

00:46:49,657 --> 00:46:51,044
(speaks faintly)

00:46:51,044 --> 00:46:56,044
- One other thing, I did hear that SDM ended up using

00:46:57,780 --> 00:46:59,650
my patch series because it helps them,

00:46:59,650 --> 00:47:01,440
I don't know how or why.

00:47:01,440 --> 00:47:03,100
But they seem to be using it.

00:47:03,100 --> 00:47:04,840
I'll try to get more information on that.

00:47:04,840 --> 00:47:06,770
- So how do you create your device links?

00:47:06,770 --> 00:47:07,780
You said you pass the firmware?

00:47:07,780 --> 00:47:09,390
- That's really a good question, sorry.

00:47:09,390 --> 00:47:14,390
So former node is like so ACPI and device tree

00:47:14,750 --> 00:47:16,530
they are all former and they can have

00:47:16,530 --> 00:47:18,370
a generic format node concept.

00:47:18,370 --> 00:47:20,400
So every device as a former node.

00:47:20,400 --> 00:47:23,210
So it has a bunch of ops, you can like every firmware needs

00:47:23,210 --> 00:47:25,120
to support a bunch of ops.

00:47:25,120 --> 00:47:27,960
I added to that saying add device links kernel.

00:47:27,960 --> 00:47:30,370
Listen to call back to the devices former nodes saying

00:47:30,370 --> 00:47:32,650
hey, can you please create the device links for me.

00:47:32,650 --> 00:47:35,260
In the case of device tree, I go parse the common bindings

00:47:35,260 --> 00:47:38,240
like say clocks, regulators, interconnect too

00:47:38,240 --> 00:47:39,320
is another example.

00:47:39,320 --> 00:47:42,160
- And how about the dependencies that expressed

00:47:42,160 --> 00:47:44,490
through device specific properties in the device tree.

00:47:44,490 --> 00:47:47,350
So not clogs or GPIO?

00:47:47,350 --> 00:47:49,250
- So I did have a solution for that

00:47:49,250 --> 00:47:51,250
but it's a hidden device--

00:47:51,250 --> 00:47:52,350
- Cause they're only known to the driver

00:47:52,350 --> 00:47:53,580
and that's a problem.

00:47:53,580 --> 00:47:55,760
- Exactly, so I propose having something called depends on

00:47:55,760 --> 00:47:57,290
where you can have a common description

00:47:57,290 --> 00:47:59,360
of what other devices you depend on.

00:47:59,360 --> 00:48:02,850
If it's not captured by a common generic binding

00:48:02,850 --> 00:48:05,449
but they're pushed back for that for some valid reasons,

00:48:05,449 --> 00:48:07,070
some debatable reasons.

00:48:09,180 --> 00:48:10,930
- And have you thought about what's gonna happen

00:48:10,930 --> 00:48:12,330
when you unload the modules.

00:48:14,450 --> 00:48:19,380
- Device links allows you to delete the device link

00:48:19,380 --> 00:48:21,300
as the device gets on long.

00:48:21,300 --> 00:48:23,460
So if you set the flags right it shouldn't matter.

00:48:23,460 --> 00:48:25,500
- But you know they're addressing the problem of having

00:48:25,500 --> 00:48:29,930
a supplier and provider where the provider module

00:48:29,930 --> 00:48:32,010
isn't loaded in the supplier then traction.

00:48:32,010 --> 00:48:33,443
- [Saravan] Totally makes sense.

00:48:33,443 --> 00:48:35,140
- So you have a you have a consumer and

00:48:35,140 --> 00:48:36,870
- A supplier. - A supplier.

00:48:36,870 --> 00:48:39,000
And the supply module gets unloaded

00:48:39,000 --> 00:48:40,680
and all of a sudden the consumer doesn't

00:48:40,680 --> 00:48:42,780
have the resource anymore.

00:48:42,780 --> 00:48:43,700
- I wasn't trying to solve that

00:48:43,700 --> 00:48:45,060
but that's already solved sir.

00:48:45,060 --> 00:48:47,900
So I can force the if you can force the unbinding

00:48:47,900 --> 00:48:50,170
of the consumers before you unbind.

00:48:50,170 --> 00:48:51,270
The lot of flags you can see it makes

00:48:51,270 --> 00:48:52,240
a lot of things nicer too.

00:48:52,240 --> 00:48:55,300
It also makes sure for example you set the flags right,

00:48:55,300 --> 00:48:57,580
you can make sure that even in runtime suspend,

00:48:57,580 --> 00:48:59,530
those devices have spent first

00:48:59,530 --> 00:49:01,439
before your regulator or pin control

00:49:01,439 --> 00:49:03,320
whatever needs to suspend.

00:49:03,320 --> 00:49:04,920
It's actually pretty nice.

00:49:04,920 --> 00:49:06,550
I'm intentionally not trying to solve them

00:49:06,550 --> 00:49:08,560
because I'm trying to keep my patch set focused,

00:49:08,560 --> 00:49:10,900
but adding those things just adding another flag.

00:49:16,520 --> 00:49:18,520
- Just quickly go back to this ST case,

00:49:18,520 --> 00:49:22,050
I think it was to show dependencies between

00:49:22,050 --> 00:49:23,720
the display and the backlight,

00:49:25,020 --> 00:49:27,510
which they were trying to solve generically

00:49:27,510 --> 00:49:31,290
which in my opinion should this be a specific ID.

00:49:31,290 --> 00:49:34,340
- The one I heard is specifically in order is not display.

00:49:34,340 --> 00:49:37,000
It's not a display, something with power.

00:49:37,000 --> 00:49:37,833
- Alistair.

00:49:39,350 --> 00:49:40,183
- Thank you.

00:49:42,990 --> 00:49:44,720
My name is Alistair Delva.

00:49:44,720 --> 00:49:46,910
I'm the manager of the Cloud Android Team.

00:49:51,371 --> 00:49:52,340
I wanna talk to you today about

00:49:52,340 --> 00:49:54,390
how we're using virtualization on Android

00:49:55,340 --> 00:49:58,460
and where it's being used, where we see it going?

00:50:01,585 --> 00:50:05,490
So Android has a number of virtual devices AVDs we call them

00:50:05,490 --> 00:50:06,790
The Android Emulator is probably the one

00:50:06,790 --> 00:50:08,640
that most people know.

00:50:08,640 --> 00:50:10,420
It's part of the Android Studio as distributors,

00:50:10,420 --> 00:50:11,620
part the Android Studio.

00:50:12,880 --> 00:50:16,941
My team works on Cuttlefish which is the validation platform

00:50:16,941 --> 00:50:21,941
for framework engineers rather than application developers

00:50:23,100 --> 00:50:26,150
and they're also other virtual devices out there,

00:50:26,150 --> 00:50:29,531
proprietary virtual devices, open source virtual devices,

00:50:29,531 --> 00:50:34,160
acorn, course various implementations

00:50:34,160 --> 00:50:35,360
for automotive and IOT.

00:50:38,050 --> 00:50:39,980
Almost all of them use virtio

00:50:39,980 --> 00:50:42,550
and the virtio drivers blk, console, net,

00:50:42,550 --> 00:50:44,300
rng everybody uses these.

00:50:45,720 --> 00:50:46,553
They just work.

00:50:49,380 --> 00:50:51,430
So kind of deep diving into Cuttlefish.

00:50:51,430 --> 00:50:53,970
Cuttlefish is based on crosvm

00:50:53,970 --> 00:50:58,330
which is a hypervisor written by the Chrome team.

00:51:00,570 --> 00:51:03,620
It runs either on your local machine or on Google Cloud.

00:51:06,086 --> 00:51:07,580
- Sorry, rewind back on why you dropped QEMU.

00:51:09,550 --> 00:51:13,170
- We dropped QEMU because we have more internal support

00:51:13,170 --> 00:51:14,810
for crossvm than we did for QEMU.

00:51:14,810 --> 00:51:17,485
There are teams at Google that use QEMU and work on QEMU

00:51:17,485 --> 00:51:21,250
but not the kind of synergy that we have at crosvm.

00:51:21,250 --> 00:51:22,470
Another reason is that

00:51:22,470 --> 00:51:24,590
we can run Cuttlefish directly on Chrome OS

00:51:24,590 --> 00:51:27,790
without requiring the installation of another hypervisor.

00:51:27,790 --> 00:51:30,120
So the other reason is that in

00:51:30,120 --> 00:51:31,870
as part of adding things to virtio,

00:51:33,358 --> 00:51:35,320
we do wanna add it everywhere

00:51:35,320 --> 00:51:36,900
and I'll go into that later,

00:51:36,900 --> 00:51:39,440
but we're kind of focusing on that against crosvm first.

00:51:44,265 --> 00:51:45,320
So Cuttlefish is developed upstream.

00:51:45,320 --> 00:51:48,390
It's developed in AOSP, we don't do it behind the scenes

00:51:48,390 --> 00:51:49,300
and then release it every year,

00:51:49,300 --> 00:51:51,680
it's actually developed in AOSP, everybody can try out.

00:51:51,680 --> 00:51:52,770
I encourage everybody to do so.

00:51:52,770 --> 00:51:55,180
I did it taught last plumbers about that.

00:51:55,180 --> 00:51:58,270
How to get the code and how to build and set it up.

00:51:58,270 --> 00:52:00,330
And you can test mainline upstream Linux on it.

00:52:00,330 --> 00:52:01,830
You don't need an Android kernel.

00:52:01,830 --> 00:52:04,530
You can use just upstream Linux.

00:52:04,530 --> 00:52:05,630
It boots on Cuttlefish.

00:52:05,630 --> 00:52:07,030
It will boot to Android.

00:52:07,030 --> 00:52:08,390
Some functionality is impaired

00:52:08,390 --> 00:52:11,240
without using the Android patches but mainline does work.

00:52:12,193 --> 00:52:14,600
And we originally used

00:52:14,600 --> 00:52:17,160
a kind of hand roll virtual SoC architecture

00:52:17,160 --> 00:52:18,040
which was based on a drive

00:52:18,040 --> 00:52:22,200
with AI upstream last year called VSoC, virtual SoC,

00:52:23,340 --> 00:52:25,190
but we're now more aligned to Virtio.

00:52:26,950 --> 00:52:30,220
So c#Cuttlefish in P used vSoC, didn't use virtio.

00:52:30,220 --> 00:52:31,900
They used the shared memory architecture

00:52:31,900 --> 00:52:34,280
based on QEMU code ivshmen.

00:52:35,810 --> 00:52:40,810
And this was always considered by me anyway as a stopgap.

00:52:41,410 --> 00:52:44,510
So we did upstream the driver because we wanted people

00:52:44,510 --> 00:52:46,550
to be able to use Cuttlefish upstream,

00:52:46,550 --> 00:52:48,720
but the long-term plan was to move to Virtio.

00:52:49,560 --> 00:52:51,890
And that helped us set up our kernel testing

00:52:51,890 --> 00:52:56,760
and a common kernel validation allows us to test upstream

00:52:57,720 --> 00:53:00,260
in our virtual platform without relying on patches

00:53:00,260 --> 00:53:03,710
without relying on having done virtio conversion.

00:53:03,710 --> 00:53:05,560
And I'll explain why that was difficult.

00:53:07,610 --> 00:53:08,760
As you can see in the diagram,

00:53:08,760 --> 00:53:10,650
we have various regions exposed

00:53:10,650 --> 00:53:13,140
by this visa driver audio, gralloc, hwcomposer,

00:53:13,140 --> 00:53:14,450
input, rild and wifi.

00:53:15,530 --> 00:53:20,530
All of those regions were basically shared memory

00:53:21,430 --> 00:53:22,540
and there was a custom protocol

00:53:22,540 --> 00:53:24,970
that round between the guest and the host

00:53:24,970 --> 00:53:27,140
and kind of all the clever stuff

00:53:27,140 --> 00:53:28,890
was done through this vSoC driver.

00:53:28,890 --> 00:53:31,470
So basically we're duplicating what virtio does

00:53:31,470 --> 00:53:32,750
but not as well.

00:53:34,720 --> 00:53:37,810
We also for our Wi-Fi implementation used mac80211 hardware.

00:53:37,810 --> 00:53:39,820
So much again, I'll go into in a moment,

00:53:39,820 --> 00:53:42,960
why that was hard and causes problems.

00:53:42,960 --> 00:53:45,490
So Cuttlefish in Q which is something

00:53:45,490 --> 00:53:46,600
that we kind of wrapped up because

00:53:46,600 --> 00:53:47,760
of the way our branching model works.

00:53:47,760 --> 00:53:49,860
We kind of wrap this up in in March

00:53:49,860 --> 00:53:54,430
and this is supporting crosvm now instead of QEMU,

00:53:54,430 --> 00:53:57,438
but more drivers have been aligned to virtio.

00:53:57,438 --> 00:54:01,408
Some drivers we like the Audio Driver AC 97 driver,

00:54:01,408 --> 00:54:04,900
we switched to using emulated hardware instead

00:54:04,900 --> 00:54:07,850
of a the VSoC driver just as a stopgap

00:54:07,850 --> 00:54:11,620
to adapt to loose dependency on that driver,

00:54:11,620 --> 00:54:13,940
but we know it's not kind of an ideal solution.

00:54:15,250 --> 00:54:16,620
But for most of the other ones we were able

00:54:16,620 --> 00:54:18,110
to convert them to use vsoc.

00:54:19,076 --> 00:54:19,909
So to use virtio.

00:54:19,909 --> 00:54:23,790
So input users virtio input, wifi is now using a driver

00:54:23,790 --> 00:54:25,190
that we came up with covert WiFi

00:54:25,190 --> 00:54:26,290
which was up streamed.

00:54:27,280 --> 00:54:30,170
I also uses these sockets which is kind of

00:54:30,170 --> 00:54:32,280
a replace almost a direct replacement for vsoc.

00:54:32,280 --> 00:54:35,180
It's essentially a byte stream from the guest of the host.

00:54:36,210 --> 00:54:39,162
Now in AOSP master which is the situation today,

00:54:39,162 --> 00:54:42,580
we have got rid of the vsoc driver entirely

00:54:42,580 --> 00:54:45,140
and we are now using virtio for everything.

00:54:45,140 --> 00:54:47,190
The biggest job obviously was virtio_gpu

00:54:47,190 --> 00:54:49,690
which required a lot of changes to many components

00:54:50,930 --> 00:54:52,330
and we know that there were other,

00:54:52,330 --> 00:54:54,920
lots of people are interested in using virtio_gpu now

00:54:54,920 --> 00:54:58,140
and there are lots of people using Android virtio_gpu

00:54:58,140 --> 00:55:01,950
and obviously chrome OS was using virtio_gpu on crosvm

00:55:01,950 --> 00:55:05,620
for Linux compatibility; Linux application compatibility.

00:55:05,620 --> 00:55:07,640
So all of those efforts have ever been involved

00:55:07,640 --> 00:55:09,080
in that process you know has made

00:55:09,080 --> 00:55:12,450
this very straightforward for us to use on Android.

00:55:13,660 --> 00:55:14,900
So anybody who's interested in running

00:55:14,900 --> 00:55:17,110
with the virtio stack, the virtio-gpu stack

00:55:17,110 --> 00:55:18,840
can use the launch_cvd command

00:55:18,840 --> 00:55:20,690
which is a couple of official device

00:55:20,690 --> 00:55:24,330
with mode-drm virgl and it will switch into using that mode.

00:55:24,330 --> 00:55:26,120
And then obviously the last step for us is just

00:55:26,120 --> 00:55:29,130
to drop the visa driver entirely from upstream.

00:55:31,760 --> 00:55:33,100
Learnings from virtio_gpu.

00:55:36,633 --> 00:55:38,300
So things work, like I said things

00:55:38,300 --> 00:55:40,070
were very smooth due to all these other projects,

00:55:40,070 --> 00:55:42,780
using it and the code base being very active in life.

00:55:42,780 --> 00:55:44,740
But the code base was also very active in live

00:55:44,740 --> 00:55:47,310
which meant as we were implementing features,

00:55:47,310 --> 00:55:48,440
things broke a lot.

00:55:48,440 --> 00:55:50,180
You know, we would have to update

00:55:50,180 --> 00:55:52,300
our gralloch our MS implementation, we have

00:55:52,300 --> 00:55:55,130
to update our kernel changes, crosvm changes

00:55:55,130 --> 00:55:56,610
to keep everything in line.

00:55:56,610 --> 00:55:58,680
Fortunately the Chrome OS team are doing that

00:55:58,680 --> 00:55:59,513
for other reasons.

00:55:59,513 --> 00:56:01,730
So that made the crosvm changes a lot easier,

00:56:02,700 --> 00:56:05,140
but one of the things we did do, end up having to do

00:56:05,140 --> 00:56:08,030
is because of the Android kernel release model

00:56:08,030 --> 00:56:10,900
of releasing three kernels per Android release,

00:56:11,770 --> 00:56:15,220
we did have to backport virtio_gpu to 4.14 and 4.19

00:56:15,220 --> 00:56:18,530
because the versions in 4.14 and 4.19 have problems

00:56:18,530 --> 00:56:21,350
that blocked us from using it on Android.

00:56:21,350 --> 00:56:24,249
Specifically it's kind of a minor issue

00:56:24,249 --> 00:56:27,710
but virsio_gpu had hard-coded the...

00:56:27,710 --> 00:56:30,350
It has a hard-coded assumption about how large the screen is

00:56:30,350 --> 00:56:31,580
Now you can go and set the mode

00:56:31,580 --> 00:56:33,680
to something else afterwards if you want.

00:56:33,680 --> 00:56:36,210
But it uses generated EDIDs which don't work

00:56:36,210 --> 00:56:37,970
for the kind of devices to Android chips on

00:56:37,970 --> 00:56:41,340
because they're all you know HDMI modes rather HCEA modes

00:56:41,340 --> 00:56:44,520
rather than normal kind of legacy modes.

00:56:44,520 --> 00:56:46,560
And so, with backport, that has been solved upstream.

00:56:46,560 --> 00:56:48,150
There's the ability to inject EDID now.

00:56:48,150 --> 00:56:49,490
And you can customize the modes.

00:56:49,490 --> 00:56:51,200
And so we've done that.

00:56:51,200 --> 00:56:53,170
We also needed fixes for an our friend support.

00:56:53,170 --> 00:56:56,160
Obviously Android is using that for a harbor composer

00:56:56,160 --> 00:56:58,590
and there were various other small things we needed as well.

00:57:00,748 --> 00:57:01,720
Kind of issues that we encountered

00:57:01,720 --> 00:57:04,460
that haven't been resolved fully yet are virtio_gpu

00:57:04,460 --> 00:57:06,030
cause it does support multiple displays,

00:57:06,030 --> 00:57:08,330
but it doesn't really support multiple planes.

00:57:09,400 --> 00:57:11,630
We need better pixel support,

00:57:11,630 --> 00:57:14,570
pixel format support in virtio_gpu_2d.

00:57:14,570 --> 00:57:16,980
Couple of examples are video overlay with support

00:57:16,980 --> 00:57:17,990
would be nice for Android

00:57:17,990 --> 00:57:20,680
because the full screen video use cases we need that,

00:57:22,030 --> 00:57:24,590
and then the we also bumped into

00:57:24,590 --> 00:57:27,320
which is the last point on here the stride, format modifier.

00:57:27,320 --> 00:57:28,660
We also bumped in some cases

00:57:28,660 --> 00:57:30,800
where the assumed framebuffer format

00:57:32,020 --> 00:57:34,480
that the kernel will use for the kind of its framebuffer

00:57:34,480 --> 00:57:37,140
is a byte order that's not supported by SwiftShader.

00:57:38,210 --> 00:57:40,230
So we end up getting to this problem

00:57:40,230 --> 00:57:42,460
where SwiftSahder is running in like RGBA

00:57:42,460 --> 00:57:45,210
and we want BGRA or something like that.

00:57:45,210 --> 00:57:46,730
And it kind of used to work upstream

00:57:46,730 --> 00:57:48,460
but it was because it wasn't properly checking it

00:57:48,460 --> 00:57:50,550
and then the crosvm was doing the wrong thing,

00:57:50,550 --> 00:57:51,950
but then that was fixed.

00:57:51,950 --> 00:57:52,783
It doesn't work anymore.

00:57:52,783 --> 00:57:53,640
These are kind of minor issues

00:57:53,640 --> 00:57:55,430
but the things that we need to fix.

00:57:56,510 --> 00:57:58,930
And then other things that other teams

00:57:58,930 --> 00:58:00,677
at Google have mentioned to me,

00:58:00,677 --> 00:58:02,390
haven't got a solution right now

00:58:02,390 --> 00:58:06,640
is the need for being able to...

00:58:06,640 --> 00:58:08,420
Although the guest has to allocate the memory

00:58:08,420 --> 00:58:12,190
for virtio_gpu, it would be helpful if it could do that

00:58:12,190 --> 00:58:13,790
in a way that was hinted by the host,

00:58:13,790 --> 00:58:15,890
so that it can allocate DMA-BUF stack

00:58:15,890 --> 00:58:18,590
that are compatible with the host without copying them.

00:58:18,590 --> 00:58:21,080
So there are some examples where you know

00:58:21,080 --> 00:58:22,700
a hardware implementation needs to buffer

00:58:22,700 --> 00:58:24,360
to be sized correctly for FBC.

00:58:24,360 --> 00:58:26,570
Now, virtio doesn't need to know what the format is

00:58:26,570 --> 00:58:28,460
because it's doing the the FBC before

00:58:28,460 --> 00:58:30,370
will only be touched by the host.

00:58:30,370 --> 00:58:33,560
But the guest has to still allocate the buffer appropriately

00:58:33,560 --> 00:58:35,610
So there are some, may be some future changes

00:58:35,610 --> 00:58:39,770
to make requests for modifiers of the original assumptions

00:58:39,770 --> 00:58:41,270
at the buffer allocation size.

00:58:42,686 --> 00:58:43,519
- Go into the discussion.

00:58:43,519 --> 00:58:44,352
- Okay.

00:58:44,352 --> 00:58:45,185
One more thing I just wanted to touch on

00:58:45,185 --> 00:58:46,370
was camera virtualization.

00:58:48,570 --> 00:58:50,390
Something that we're looking at doing.

00:58:50,390 --> 00:58:52,300
We haven't really started yet.

00:58:52,300 --> 00:58:54,700
As you can see here there's a lot of questions

00:58:54,700 --> 00:58:56,400
about how we would do that,

00:58:56,400 --> 00:58:58,620
but one thing will be good would be kind of figuring out

00:58:58,620 --> 00:59:00,630
how to do vertical for camera

00:59:00,630 --> 00:59:02,120
and what that should look like.

00:59:02,120 --> 00:59:06,710
One driver or many, kind of how would we test it,

00:59:06,710 --> 00:59:08,070
what would be exposed etc.

00:59:09,550 --> 00:59:11,800
I had a couple of those slides kind of,

00:59:11,800 --> 00:59:13,500
just these are the other virtio drivers

00:59:13,500 --> 00:59:15,440
that other virtual machines are using.

00:59:16,440 --> 00:59:17,937
Any questions?

00:59:17,937 --> 00:59:18,770
Yeah.

00:59:21,133 --> 00:59:26,133
- Just under wanting planes in the virtio_gpu

00:59:27,480 --> 00:59:28,820
what would you see the host doing there

00:59:28,820 --> 00:59:30,730
without using OpenGL to do the blending

00:59:30,730 --> 00:59:31,563
So that's the problem.

00:59:31,563 --> 00:59:33,697
The reason I never added planes when I designed it was

00:59:33,697 --> 00:59:36,340
I didn't have an idea of what I should do on

00:59:36,340 --> 00:59:38,090
the whole side of the host graphics of that.

00:59:38,090 --> 00:59:40,180
- So that's absolutely right

00:59:40,180 --> 00:59:42,150
And we kind of learned,

00:59:42,150 --> 00:59:43,630
I could understand from acceleration

00:59:43,630 --> 00:59:45,720
just kind of desktop acceleration point of view,

00:59:45,720 --> 00:59:46,870
it doesn't really make sense.

00:59:46,870 --> 00:59:49,110
But for us what we wanna do is, we want to create

00:59:49,110 --> 00:59:51,120
kind of a better device fidelity.

00:59:51,120 --> 00:59:52,730
So we want this we want our virtual device

00:59:52,730 --> 00:59:54,140
to look like a real device.

00:59:54,140 --> 00:59:56,160
So we therefore want our DRM device to look like

00:59:56,160 --> 00:59:58,690
a real DRM device as far as possible.

00:59:58,690 --> 01:00:00,830
And that will allow us to cache user space

01:00:00,830 --> 01:00:03,600
in assumptions being made by a harbor composer

01:00:03,600 --> 01:00:06,330
or by a surface flinger or whatever.

01:00:06,330 --> 01:00:07,810
Now the current mode will require

01:00:07,810 --> 01:00:10,660
that surface flinger essentially blends down the layers

01:00:10,660 --> 01:00:11,493
inside the guest.

01:00:11,493 --> 01:00:13,170
So although that works being done by the host

01:00:13,170 --> 01:00:15,700
as you said it's being done in OpenGL.

01:00:15,700 --> 01:00:17,540
Now we'll probably still be using it in OpenGL,

01:00:17,540 --> 01:00:19,120
but we've done on the host instead.

01:00:20,110 --> 01:00:21,520
So that's kind of a use case for interesting.

01:00:21,520 --> 01:00:23,180
The other the other example is,

01:00:23,180 --> 01:00:24,290
obviously if you do that

01:00:24,290 --> 01:00:25,940
then you need video texture support as well

01:00:25,940 --> 01:00:27,550
cause you can't rely on the guest to do it.

01:00:27,550 --> 01:00:29,360
- You need to be able to call all the video stuff

01:00:29,360 --> 01:00:31,504
and blend in the right color space.

01:00:31,504 --> 01:00:34,480
- So I'm hoping to get started on that soon

01:00:34,480 --> 01:00:36,080
and hopefully you'll get some patches from us

01:00:36,080 --> 01:00:37,080
to add that feature.

01:00:40,880 --> 01:00:41,713
Anything else?

01:00:44,630 --> 01:00:48,240
- I saw some, you had some virtio GPIO there,

01:00:48,240 --> 01:00:51,260
I haven't seen that yet as GPIO maintainer.

01:00:51,260 --> 01:00:54,040
So I'm eagerly anticipating this thing.

01:00:54,040 --> 01:00:57,800
There is some patches flying to like take a few DPI

01:00:57,800 --> 01:01:01,020
use of the running host and export them

01:01:01,020 --> 01:01:05,101
into the virtual machinist whatever GPIO ship.

01:01:05,101 --> 01:01:08,350
You could provide very good input to that discussion.

01:01:08,350 --> 01:01:11,030
So can you just contact me and--

01:01:11,030 --> 01:01:13,243
- Yes, actually so we'd like to...

01:01:13,243 --> 01:01:15,290
One of the things I want to be careful about

01:01:15,290 --> 01:01:16,820
is that there are actually as he points out,

01:01:16,820 --> 01:01:18,552
patches flying around.

01:01:18,552 --> 01:01:19,385
And as you can see from the list here,

01:01:19,385 --> 01:01:21,440
there's probably maybe 10 vertio drivers out there

01:01:21,440 --> 01:01:22,940
that are being used by projects

01:01:22,940 --> 01:01:25,620
that I've come up with their own virtio specification.

01:01:25,620 --> 01:01:26,900
That hasn't been standardized yet

01:01:26,900 --> 01:01:29,300
and written a driver for and the user in production.

01:01:29,300 --> 01:01:30,340
So obviously for Android,

01:01:30,340 --> 01:01:31,680
we'd rather not go down that path.

01:01:31,680 --> 01:01:33,560
We want to work with everybody upstream

01:01:33,560 --> 01:01:35,860
and make sure that people agree on the necessity

01:01:35,860 --> 01:01:38,550
for a particular virtio implementation and work on that one

01:01:38,550 --> 01:01:40,490
and only add support for that one.

01:01:40,490 --> 01:01:41,400
We don't want to add support

01:01:41,400 --> 01:01:43,230
for non-standard implementations.

01:01:43,230 --> 01:01:45,930
- It would be nice to be able to like loop you guys somehow.

01:01:45,930 --> 01:01:48,640
- Yes, I think almost everything on this list

01:01:48,640 --> 01:01:52,260
that was added to ACRN or A-C-R-N however you pronounce it,

01:01:52,260 --> 01:01:53,810
that project probably would be something

01:01:53,810 --> 01:01:55,510
that Android devices would ultimately need.

01:01:55,510 --> 01:01:58,260
Audio GPIO is ICHTCP.

01:01:58,260 --> 01:01:59,550
They're all things we need.

01:01:59,550 --> 01:02:03,600
Crossvm also has a video decoder virtio implementation.

01:02:03,600 --> 01:02:05,260
I don't think anybody's attempted.

01:02:05,260 --> 01:02:06,710
Well, I think people have attempted camera

01:02:06,710 --> 01:02:10,400
but they do it in a simple way like exporting a DMA-BUF.

01:02:10,400 --> 01:02:11,430
There's nobody who has kind of like

01:02:11,430 --> 01:02:14,800
a managed camera interface virtio yet I'm aware of.

01:02:14,800 --> 01:02:17,740
- Sorry for my ignorance but what is this ACRN thing?

01:02:17,740 --> 01:02:20,570
- It is a type one hypervisor.

01:02:20,570 --> 01:02:22,160
It's originally was written by Intel

01:02:22,160 --> 01:02:24,740
and I believe it's now a sort of open source project.

01:02:24,740 --> 01:02:25,930
It's project ACRN.

01:02:25,930 --> 01:02:27,580
If you're interested you can go and check it out.

01:02:27,580 --> 01:02:28,413
- Okay, awesome.

01:02:28,413 --> 01:02:31,190
- And they've got us on ship patches against Linux as well.

01:02:36,710 --> 01:02:40,090
- Has virtio been replaced by virtio vsoc?

01:02:41,221 --> 01:02:42,921
- Yes, we did not virtio(mumbles).

01:02:45,056 --> 01:02:47,556
- Oh yeah, that's makes sense.

01:02:58,892 --> 01:02:59,790
- You're free to present more if you got some stuff--

01:02:59,790 --> 01:03:00,820
- Yeah, I've got a little bit.

01:03:00,820 --> 01:03:02,960
So another kind of interesting thing

01:03:02,960 --> 01:03:04,380
was Wi-Fi that's come up recently.

01:03:04,380 --> 01:03:07,150
So for virtio_wifi implementations

01:03:07,150 --> 01:03:08,950
we used to use Mac 80211 hardware sim

01:03:08,950 --> 01:03:12,697
and we basically turn all the the mac 80 211 hardware sim

01:03:12,697 --> 01:03:16,460
that kind of fake frames through to the host

01:03:16,460 --> 01:03:19,160
and then replay them using an instance of mac 80211 hardware

01:03:19,160 --> 01:03:21,320
someone on the other side that was how we created

01:03:21,320 --> 01:03:23,280
a network bridging using Wi-Fi.

01:03:23,280 --> 01:03:24,840
But there were lots of problems with that.

01:03:24,840 --> 01:03:26,840
Like you had to have root permissions,

01:03:26,840 --> 01:03:28,340
there was no Ethernet connection running

01:03:28,340 --> 01:03:30,890
between guest and host and the host bridge setup

01:03:30,890 --> 01:03:31,723
was more complicated.

01:03:31,723 --> 01:03:33,507
So we came up with a driver that we upstreamed

01:03:33,507 --> 01:03:36,050
just over a year ago virt_wifi

01:03:36,050 --> 01:03:38,324
which is an NRT net link driver

01:03:38,324 --> 01:03:39,360
that wraps another ethernet device,

01:03:39,360 --> 01:03:40,850
which is kind of a standard way of doing things

01:03:40,850 --> 01:03:42,000
in the networking core.

01:03:45,090 --> 01:03:47,540
But one of kind of the open questions would be,

01:03:47,540 --> 01:03:49,070
the problem with virt_wifi is

01:03:49,070 --> 01:03:52,100
you can't actually connect to hope to Cuttlefishes

01:03:52,100 --> 01:03:52,933
if you like together.

01:03:52,933 --> 01:03:54,720
You can't bridge them using Wi-Fi,

01:03:54,720 --> 01:03:56,300
you can only bridge them using Ethernet.

01:03:56,300 --> 01:03:58,250
So kind of do we need virtio or Wi-Fi as well.

01:03:58,250 --> 01:03:59,750
It's kind of an open question.

01:04:00,870 --> 01:04:02,270
I don't there's any networking people here

01:04:02,270 --> 01:04:04,940
who would have interests or care about that.

01:04:07,758 --> 01:04:09,252
No?

01:04:09,252 --> 01:04:13,085
(men speaking off microphone)

01:04:21,450 --> 01:04:22,283
Thank you.

01:04:25,824 --> 01:04:28,991
(audience applauding)

01:04:55,630 --> 01:04:57,150
- Okay, I'll do my best.

01:05:00,660 --> 01:05:02,350
I will start up briefly

01:05:02,350 --> 01:05:03,930
and very briefly introducing the project

01:05:03,930 --> 01:05:06,610
we've been working on for nearly an year called libcamera

01:05:06,610 --> 01:05:08,840
and how unifying camera support

01:05:08,840 --> 01:05:10,500
on different Linux systems including Android

01:05:10,500 --> 01:05:11,900
and that's why I'm here today.

01:05:13,060 --> 01:05:17,110
Very very brief context why we did that.

01:05:17,110 --> 01:05:20,380
We starting a long time ago with extremely simple cameras

01:05:20,380 --> 01:05:23,090
where you had a sensor usually row sensor

01:05:23,090 --> 01:05:27,110
or sensor to provide process images.

01:05:28,380 --> 01:05:33,380
And on the SOC side, you had sensor interface possibly

01:05:34,320 --> 01:05:35,650
a scalar and that's it.

01:05:35,650 --> 01:05:37,390
And I was easy to control from user space.

01:05:37,390 --> 01:05:40,070
We had a V file API that was working totally fine

01:05:40,070 --> 01:05:43,260
with that and it was there was absolutely no problem.

01:05:43,260 --> 01:05:46,119
So from a user based front of view, a single video node,

01:05:46,119 --> 01:05:48,940
single API and that was it.

01:05:51,290 --> 01:05:53,020
Then appeared more complex SOCs

01:05:53,020 --> 01:05:55,440
with more processing inside the SOC

01:05:55,440 --> 01:05:57,650
and that's that's more than 10 years old

01:05:57,650 --> 01:06:00,370
so it's a simple diagram compared to what we have today.

01:06:00,370 --> 01:06:01,870
But you have more processing blocks

01:06:01,870 --> 01:06:04,120
and we figured out it was impossible

01:06:04,120 --> 01:06:06,710
to control that's using the POV file to API.

01:06:06,710 --> 01:06:09,330
So we made API extension situated mere control API,

01:06:09,330 --> 01:06:14,330
we exposed the internals of the pipeline to user space

01:06:14,780 --> 01:06:17,060
and of us all of a sudden used based application

01:06:17,060 --> 01:06:20,540
was supposed to interact with tens of devices

01:06:20,540 --> 01:06:21,800
on the kernel side.

01:06:21,800 --> 01:06:25,560
And to have deep knowledge of what the hardware I was doing

01:06:25,560 --> 01:06:28,250
That was suddenly possible when were making a product

01:06:28,250 --> 01:06:32,130
and had applications and frameworks that's aware of

01:06:32,130 --> 01:06:33,110
what was inside a device,

01:06:33,110 --> 01:06:36,701
but that's not something usable for generic applications.

01:06:36,701 --> 01:06:38,370
It was a problem that was well known.

01:06:38,370 --> 01:06:40,770
We had solutions were proposed.

01:06:42,370 --> 01:06:44,658
I'm talking about 10 years ago and when working with Nokia

01:06:44,658 --> 01:06:46,440
and then you all know what happened with Nokia,

01:06:46,440 --> 01:06:48,530
so nothing gets implemented.

01:06:48,530 --> 01:06:50,160
So the Vfrontal Community knew that

01:06:50,160 --> 01:06:53,880
there was a missing component and last November

01:06:53,880 --> 01:06:55,530
we started working on it finally.

01:06:56,500 --> 01:06:58,700
So that's how the libcamera project started.

01:06:59,740 --> 01:07:02,550
We were really bad at marketing.

01:07:02,550 --> 01:07:04,570
So until the name that his tribe elaborate

01:07:04,570 --> 01:07:07,220
that's handles cameras and we came up with libcamera.

01:07:08,230 --> 01:07:11,370
The idea there is that we wanted to create

01:07:11,370 --> 01:07:14,660
a whole camera stack and if you compare it to graphics world

01:07:14,660 --> 01:07:16,160
we want to be the measure of the graphic quality.

01:07:16,160 --> 01:07:18,219
So it's a use base stack that's gonna go

01:07:18,219 --> 01:07:21,640
a single API towards applications.

01:07:21,640 --> 01:07:23,560
And we in the handle any cameras regardless

01:07:23,560 --> 01:07:24,990
of what's underneath.

01:07:24,990 --> 01:07:27,230
So we have a whole stack defined

01:07:27,230 --> 01:07:30,630
with applications frameworks, option language bindings,

01:07:30,630 --> 01:07:33,280
route cameras written in C++ or the mini PS in C++

01:07:33,280 --> 01:07:35,500
between to offer support for the languages too.

01:07:35,500 --> 01:07:37,730
And we have libcamera in the middle and then the bottom

01:07:37,730 --> 01:07:40,030
we have older camera stack.

01:07:40,030 --> 01:07:41,830
So that's more or less how it looks.

01:07:43,550 --> 01:07:45,130
What it provides if you're familiar

01:07:45,130 --> 01:07:47,630
with how androids handles cameras

01:07:47,630 --> 01:07:50,540
with the Android Camera HAL, we have camera devices,

01:07:50,540 --> 01:07:52,200
we have enumeration of cameras.

01:07:52,200 --> 01:07:53,600
We see both multiple streams

01:07:53,600 --> 01:07:55,520
so you can capture multiple streams at the same time

01:07:55,520 --> 01:07:58,530
from the same sensor and different resolutions.

01:07:58,530 --> 01:08:01,130
We support or want to support pre-frame control

01:08:02,580 --> 01:08:04,720
and more importantly, we need

01:08:04,720 --> 01:08:07,230
to support image processing algorithms.

01:08:07,230 --> 01:08:08,490
So I won't go in depth on

01:08:08,490 --> 01:08:10,100
how it's done at the hardware level,

01:08:10,100 --> 01:08:11,220
but that's something that's

01:08:11,220 --> 01:08:13,540
all hardware vendor consider highly valuable

01:08:13,540 --> 01:08:16,440
and highly proprietary, so they want to ship binary blobs.

01:08:17,970 --> 01:08:22,970
And on top of that, we want to have a compatibility

01:08:23,370 --> 01:08:25,900
with the V4L2 API for existing applications

01:08:25,900 --> 01:08:29,190
but more importantly today also compatibility with Android.

01:08:30,532 --> 01:08:32,010
So the real goal of libcamera is just

01:08:32,010 --> 01:08:33,360
to pound a whole ecosystem.

01:08:36,670 --> 01:08:39,250
Just a quick word of how we do that internally

01:08:39,250 --> 01:08:41,830
that's more or less the architecture of what we have today.

01:08:41,830 --> 01:08:43,270
So we have a camera device manager.

01:08:43,270 --> 01:08:45,780
You can invert the cameras and a camera itself

01:08:45,780 --> 01:08:49,570
has a hopefully as much as possible piece

01:08:49,570 --> 01:08:52,670
of device agnostic code that we can reuse across all cameras

01:08:52,670 --> 01:08:55,500
but there's in red over there PCs

01:08:55,500 --> 01:08:57,040
that are specific to your hardware.

01:08:57,040 --> 01:08:59,389
So we have what we call a pipeline handler

01:08:59,389 --> 01:09:04,389
that handles the camera receiver inside the SOC or AISP

01:09:04,630 --> 01:09:06,060
all the processing blocks are over there.

01:09:06,060 --> 01:09:08,490
And another component that isolates

01:09:08,490 --> 01:09:10,690
the image processing algorithms.

01:09:10,690 --> 01:09:12,950
And that can be provided by vendors as a binary blob

01:09:12,950 --> 01:09:14,710
because what they do,

01:09:14,710 --> 01:09:17,980
but you want to also provide open source solutions for that.

01:09:17,980 --> 01:09:19,910
Open source implementation.

01:09:19,910 --> 01:09:22,970
So the goals of licking around two folds,

01:09:22,970 --> 01:09:25,320
we want to provide camera support for all Linux systems

01:09:25,320 --> 01:09:26,600
and when I say camera support,

01:09:26,600 --> 01:09:30,010
it means all camera we see them today in laptops,

01:09:30,010 --> 01:09:31,220
in tablets, in phones.

01:09:32,270 --> 01:09:34,560
So that's all the Linux distributions

01:09:34,560 --> 01:09:36,220
what is definitely missing in there

01:09:36,220 --> 01:09:39,530
because we have we have laptops today

01:09:39,530 --> 01:09:43,370
that are based on raw sensors and the Intel SOC

01:09:43,370 --> 01:09:45,090
and that just doesn't work in Linux.

01:09:45,090 --> 01:09:49,040
We have absolutely no solution to work with that.

01:09:49,040 --> 01:09:50,220
And we want that solution also

01:09:50,220 --> 01:09:53,050
to be usable on Android and on Chrome OS.

01:09:53,050 --> 01:09:55,750
And the reason why I want to cover all that

01:09:55,750 --> 01:09:58,490
is that I mentioned that vendors will provide algorithms

01:09:58,490 --> 01:10:01,130
as a binary blob and there's no way we're gonna get

01:10:01,130 --> 01:10:03,180
those vendors to provide implementations

01:10:03,180 --> 01:10:05,410
for different Linux based systems.

01:10:05,410 --> 01:10:08,460
So Android has a big leverage, Chrome OS does as well

01:10:08,460 --> 01:10:10,120
and it can work with vendors

01:10:10,120 --> 01:10:12,280
and make them support Linux,

01:10:12,280 --> 01:10:14,970
but the Linux distributions can't really do the same.

01:10:14,970 --> 01:10:17,420
So we want to provide a single unifying implementation

01:10:17,420 --> 01:10:20,570
that we'll be able to reuse the same implementation

01:10:20,570 --> 01:10:22,470
for the vendors and all those systems.

01:10:23,821 --> 01:10:26,610
And the second point is that I want to create,

01:10:26,610 --> 01:10:27,800
we wanted to create an environment

01:10:27,800 --> 01:10:29,950
that will first innovation on camera site.

01:10:29,950 --> 01:10:32,950
And that means that the camera, to use a camera

01:10:32,950 --> 01:10:34,880
you need a big framework.

01:10:34,880 --> 01:10:37,210
So far if you look at an Android system,

01:10:37,210 --> 01:10:39,280
that standardized is the camera API

01:10:39,280 --> 01:10:40,990
at the users based level.

01:10:40,990 --> 01:10:42,840
Everything that's underneath the camera HAL

01:10:42,840 --> 01:10:45,420
the kind of drivers, they all provided by the vendors

01:10:45,420 --> 01:10:47,220
and the vendors will keep that quite low.

01:10:47,220 --> 01:10:48,880
Some implementations are open-source

01:10:48,880 --> 01:10:51,520
but they don't really upstream kernel drivers.

01:10:51,520 --> 01:10:53,150
They don't document the interfaces.

01:10:53,150 --> 01:10:56,060
They don't explain what statistics you can get off

01:10:56,060 --> 01:10:56,893
their hardware and all that.

01:10:56,893 --> 01:10:59,230
So it's close to impossible to come up

01:10:59,230 --> 01:11:01,220
with a fully open source implementation

01:11:01,220 --> 01:11:02,610
because there's lots of work

01:11:02,610 --> 01:11:04,690
and information is missing.

01:11:04,690 --> 01:11:06,870
So by providing a framework that's fully open source

01:11:06,870 --> 01:11:09,100
and having just one component in there

01:11:09,100 --> 01:11:11,220
that will be proprietary,

01:11:11,220 --> 01:11:13,300
we want to force the vendors to document

01:11:13,300 --> 01:11:15,140
the interfaces there so we can compete with them

01:11:15,140 --> 01:11:17,060
and we can create open-source implementation.

01:11:17,060 --> 01:11:19,150
Of course they will claim it's completely impossible

01:11:19,150 --> 01:11:21,490
like a GPU people did 10 years ago.

01:11:21,490 --> 01:11:25,590
It was impossible to create GPU stack in an open source one,

01:11:26,510 --> 01:11:27,550
but we all know what happened.

01:11:27,550 --> 01:11:29,380
So hopefully at some point

01:11:29,380 --> 01:11:31,500
we'll reach the same with the cameras.

01:11:31,500 --> 01:11:33,590
So now discussions.

01:11:33,590 --> 01:11:35,126
How much time do we have left?

01:11:35,126 --> 01:11:37,197
- [Karim] We still got about eight minutes.

01:11:37,197 --> 01:11:38,970
- Oh good.

01:11:38,970 --> 01:11:40,920
So a bunch of points I would like to discuss today.

01:11:40,920 --> 01:11:44,890
So we have as I mentioned, we started development

01:11:44,890 --> 01:11:46,890
in the November last year.

01:11:46,890 --> 01:11:48,140
We have demos that we can make.

01:11:48,140 --> 01:11:49,750
We have a camera HAL implementation

01:11:49,750 --> 01:11:52,030
that has been tested in some ways,

01:11:52,030 --> 01:11:54,558
not an Android mostly because we didn't really

01:11:54,558 --> 01:11:57,058
have testing platforms that what is it used first.

01:11:58,490 --> 01:12:01,060
And I would like to get none easily today,

01:12:01,060 --> 01:12:03,530
but at least to see how we could get feedback

01:12:03,530 --> 01:12:08,530
from the both the Android Community but Google as well

01:12:08,700 --> 01:12:11,700
on the design and how we could get that

01:12:11,700 --> 01:12:13,010
to work correctly with Android

01:12:13,010 --> 01:12:14,510
and hopefully shipped in AOSP.

01:12:15,350 --> 01:12:16,260
So that's one thing.

01:12:16,260 --> 01:12:18,550
I also want to get feedback from SOC vendors

01:12:18,550 --> 01:12:19,960
that's not really question for today,

01:12:19,960 --> 01:12:24,930
because mostly about about Android in the community side,

01:12:24,930 --> 01:12:27,130
but that's something that you I would like

01:12:27,130 --> 01:12:28,530
to work on as well.

01:12:29,530 --> 01:12:33,334
Integration in AOSP and in the context of traffic travel

01:12:33,334 --> 01:12:36,470
as well we have discussed that previously.

01:12:39,450 --> 01:12:42,660
I would like and we won't have enough time five minutes,

01:12:42,660 --> 01:12:46,490
but to provide we've worked a lot,

01:12:46,490 --> 01:12:49,910
we can plan in Android Camera HAL and there are pain points.

01:12:51,660 --> 01:12:55,200
In the Camera HAL API, I think that are not well-suited

01:12:55,200 --> 01:12:57,410
for what we did.

01:12:57,410 --> 01:13:00,150
Issues that's have been there for quite some time

01:13:00,150 --> 01:13:01,450
to just historical issues.

01:13:02,600 --> 01:13:04,290
And we would like to see how it could evolve

01:13:04,290 --> 01:13:06,460
in a direction that maybe could take more feedback

01:13:06,460 --> 01:13:08,140
for the community.

01:13:08,140 --> 01:13:10,520
And last but not least possibly discussions

01:13:10,520 --> 01:13:13,780
on Linux kernel camera API because

01:13:13,780 --> 01:13:16,300
we're using V fall to today and that's also quite painful

01:13:16,300 --> 01:13:19,251
for right(speaks faintly)

01:13:19,251 --> 01:13:20,084
Where do I start?

01:13:24,830 --> 01:13:27,050
Oh and another point possibly how we could use that

01:13:27,050 --> 01:13:29,030
for virtualization of cameras on edge right.

01:13:30,420 --> 01:13:35,130
- Yeah, I was gonna ask in your view,

01:13:36,030 --> 01:13:37,490
when you're running like Android on Chrome

01:13:37,490 --> 01:13:38,850
or something like that

01:13:38,850 --> 01:13:39,980
or let's say there is a glorious future

01:13:39,980 --> 01:13:41,960
where android runs that are contained in a virtual machines

01:13:41,960 --> 01:13:43,490
that have any container

01:13:43,490 --> 01:13:44,323
How do you view,

01:13:44,323 --> 01:13:47,020
how do you think that say an Android camera app

01:13:47,020 --> 01:13:48,880
would be able to access camera features

01:13:48,880 --> 01:13:50,800
using something like libcamera.

01:13:50,800 --> 01:13:53,190
I've seen libcamera will be running on Chrome OS for example

01:13:53,190 --> 01:13:56,730
- Yes, I think that the virtualization should happen

01:13:56,730 --> 01:13:58,380
at quite high level.

01:13:58,380 --> 01:13:59,930
I don't think it make sense to virtualize

01:13:59,930 --> 01:14:02,700
the visual to API, whatever kernel API we would have

01:14:02,700 --> 01:14:03,930
because we have as I mentioned,

01:14:03,930 --> 01:14:06,211
we have lots of components at the kernel level.

01:14:06,211 --> 01:14:08,320
And having to interact with all of them,

01:14:08,320 --> 01:14:11,440
first of all, you're gonna need hardware knowledge

01:14:12,350 --> 01:14:13,550
in the guest side.

01:14:13,550 --> 01:14:15,760
If you want to revitalize that in being able

01:14:15,760 --> 01:14:17,570
to run a variety of hosts,

01:14:17,570 --> 01:14:20,680
you want to emulate a complex processing system

01:14:20,680 --> 01:14:23,520
that's gonna be recursively to terminate in software

01:14:23,520 --> 01:14:24,820
as well on the house side.

01:14:26,440 --> 01:14:28,350
And so for that reason I think an API

01:14:28,350 --> 01:14:29,720
at this higher level,

01:14:29,720 --> 01:14:31,550
roughly at the level of the Android Camera HAL

01:14:31,550 --> 01:14:33,800
or libcamera, they're kind of the same level

01:14:33,800 --> 01:14:35,140
in the camera stack.

01:14:35,140 --> 01:14:36,340
I think would make much more sense.

01:14:36,340 --> 01:14:37,173
- Okay, awesome.

01:14:39,910 --> 01:14:41,510
- And that's something we would like to help

01:14:41,510 --> 01:14:44,610
with in the future, if we can work together.

01:14:44,610 --> 01:14:45,980
I think it would be nice.

01:14:56,721 --> 01:14:58,017
Can you throw that for him.

01:15:02,180 --> 01:15:04,090
- So we're supporting the vendor blobs.

01:15:04,090 --> 01:15:06,400
If the vendor stops supporting the blob,

01:15:06,400 --> 01:15:09,430
say after two years, how do you make sure

01:15:09,430 --> 01:15:13,860
that doesn't hamper your future development and libcamera?

01:15:13,860 --> 01:15:17,810
- Okay, so we have two API's that we want to keep stable

01:15:17,810 --> 01:15:20,720
or two ABIs that we want to keep stable in libcamera.

01:15:20,720 --> 01:15:22,700
It's the the one facing applications

01:15:22,700 --> 01:15:24,550
or facing the Android Camera HAL,

01:15:24,550 --> 01:15:26,922
but also the ABI and it's facing

01:15:26,922 --> 01:15:29,050
the image processing algorithms.

01:15:30,650 --> 01:15:32,930
Of course, one will raise major versions

01:15:32,930 --> 01:15:35,480
that's something is we could break from time to time.

01:15:35,480 --> 01:15:37,060
We can't guarantee that we're gonna keep

01:15:37,060 --> 01:15:38,360
the same API for 20 years,

01:15:39,950 --> 01:15:41,810
but one interesting I believe thing about

01:15:41,810 --> 01:15:46,430
this project is that, we the binary blob from the vendor

01:15:46,430 --> 01:15:50,560
will not be allowed to interact with kernel devices.

01:15:50,560 --> 01:15:54,020
So we create an ABI idea where we know what information

01:15:54,020 --> 01:15:55,390
we gotta pass to them

01:15:55,390 --> 01:15:56,927
and we know what information we get back.

01:15:56,927 --> 01:16:00,460
And it means that it's forcing them to provide

01:16:00,460 --> 01:16:02,600
some level of documentation.

01:16:02,600 --> 01:16:06,700
So it means two things, one with the information

01:16:06,700 --> 01:16:09,318
that provide we can work on open source implementations.

01:16:09,318 --> 01:16:11,930
Two, if we need to create preparations

01:16:11,930 --> 01:16:14,240
between different ABIs is because we need

01:16:14,240 --> 01:16:15,630
to level on our side.

01:16:15,630 --> 01:16:17,330
That's something it is doable as well

01:16:17,330 --> 01:16:19,080
because they don't control the ABI.

01:16:21,670 --> 01:16:23,450
- My question was around the binary blob.

01:16:23,450 --> 01:16:25,310
What does the current interface

01:16:25,310 --> 01:16:27,200
or design look like for those?

01:16:27,200 --> 01:16:28,490
Are they separate processes?

01:16:28,490 --> 01:16:29,680
Are they like libraries that you expect

01:16:29,680 --> 01:16:30,800
to be loaded as plugins.

01:16:30,800 --> 01:16:35,030
- Okay, so the way it works today is that

01:16:35,030 --> 01:16:37,180
we have one should elaborate libcamera.

01:16:38,180 --> 01:16:40,960
The pipeline handlers the part here that's hardware specific

01:16:40,960 --> 01:16:44,160
but is open source is manual inside libcamera.

01:16:44,160 --> 01:16:46,630
So we have all the ones we support,

01:16:46,630 --> 01:16:48,090
could be external plugins in the future

01:16:48,090 --> 01:16:49,520
if we have dozens of them and we're going

01:16:49,520 --> 01:16:50,870
to reduce the battery size.

01:16:52,190 --> 01:16:53,650
The image processing algorithms.

01:16:53,650 --> 01:16:56,450
They loaded a separate plugins to the solution libraries.

01:16:56,450 --> 01:16:59,200
We load them and we isolate them in a separate process.

01:17:00,150 --> 01:17:01,950
And as part of that isolation,

01:17:01,950 --> 01:17:03,820
they not allowed to access the kind of devices

01:17:03,820 --> 01:17:06,290
we control the resources, they can use.

01:17:06,290 --> 01:17:08,140
If we have open source implementation,

01:17:08,140 --> 01:17:10,350
it will be the option of running name directly

01:17:10,350 --> 01:17:11,183
in the libcam process.

01:17:11,183 --> 01:17:12,670
Still shed external shadow object

01:17:12,670 --> 01:17:13,990
that will others plugins,

01:17:13,990 --> 01:17:16,730
but run directly, because if it's open source

01:17:16,730 --> 01:17:19,390
as libcamera then we consider that we can trust the code,

01:17:19,390 --> 01:17:23,080
but otherwise we don't want a binary and trusted code

01:17:23,080 --> 01:17:24,630
to be able to crash the system.

01:17:26,740 --> 01:17:28,470
- Same question on the other side of the API.

01:17:28,470 --> 01:17:30,950
The camera how is facing APIs?

01:17:30,950 --> 01:17:33,640
Does the libcamera itself run in a separate process

01:17:33,640 --> 01:17:36,603
or is basically going to run as part of camera HAL?

01:17:36,603 --> 01:17:40,430
- So the current camera HAL implementation we have right now

01:17:40,430 --> 01:17:42,900
it's part of the libcamera binary.

01:17:42,900 --> 01:17:45,200
The shared object, which could be

01:17:45,200 --> 01:17:46,120
it could be a separate one.

01:17:46,120 --> 01:17:48,320
That doesn't matter to much.

01:17:48,320 --> 01:17:50,260
It create threads internally,

01:17:50,260 --> 01:17:51,680
but the main entry point of the camera HAL

01:17:51,680 --> 01:17:54,180
is in init function and then we create all the threads

01:17:54,180 --> 01:17:55,013
that we need internally,

01:17:55,013 --> 01:17:58,370
but it runs in the process of the camera service.

01:18:00,340 --> 01:18:02,730
So it's like any camera HAL on android today.

01:18:02,730 --> 01:18:04,810
We don't create a separate process internally.

01:18:07,930 --> 01:18:09,330
- Sorry if you mentioned this earlier.

01:18:09,330 --> 01:18:12,370
Can you talk about the license and you say we,

01:18:12,370 --> 01:18:14,810
so can you just give us an idea of the size of the project,

01:18:14,810 --> 01:18:16,070
who's involved and such.

01:18:16,070 --> 01:18:21,070
- So the project is licensed under the LGPL2 Plus,

01:18:21,465 --> 01:18:25,550
except for the, I think to test suite that we have

01:18:25,550 --> 01:18:28,706
is GPL but that just test applications inside a test units.

01:18:28,706 --> 01:18:33,706
When I say we, we have five people working on that.

01:18:33,760 --> 01:18:36,570
Spot time so roughly equivalent to two full time.

01:18:38,750 --> 01:18:41,190
And we working in close cooperation with the chrome OS team.

01:18:59,750 --> 01:19:02,790
- Is there any provision to do license under Apache as well?

01:19:04,920 --> 01:19:06,620
- That's something we can discuss.

01:19:08,190 --> 01:19:11,990
We clearly wanted to avoid vendor folks there.

01:19:11,990 --> 01:19:15,700
So that's what it was decision to go for the LGPL2.

01:19:17,840 --> 01:19:19,770
Not to go into too much details,

01:19:19,770 --> 01:19:22,450
but most of the crowd right now is owned by Google.

01:19:22,450 --> 01:19:24,780
So Google has some leverage,

01:19:24,780 --> 01:19:27,270
but when we'll have external contributions

01:19:27,270 --> 01:19:28,840
that's gonna be a bit different.

01:19:30,997 --> 01:19:34,417
- So we are out of time, thank you.

01:19:34,417 --> 01:19:37,584
(audience applauding)

01:19:48,570 --> 01:19:50,596
- So I'm going to give a bit

01:19:50,596 --> 01:19:52,700
of an update on Android emulated storage

01:19:52,700 --> 01:19:55,710
and what we're doing with SDcardFS.

01:19:55,710 --> 01:19:57,944
Sandeep may have given some

01:19:57,944 --> 01:19:59,212
(alarm beeping)

01:19:59,212 --> 01:20:03,657
- Sorry, ignore that, sorry.

01:20:03,657 --> 01:20:04,890
- That will be very short time.

01:20:04,890 --> 01:20:06,369
- [Karim] You'll get some extra time.

01:20:06,369 --> 01:20:09,470
(all laugh)

01:20:09,470 --> 01:20:11,950
- So first off a brief overview of

01:20:11,950 --> 01:20:16,000
what we currently do with SDcardFS.

01:20:16,000 --> 01:20:18,710
It provides a layer of case insensitivity

01:20:18,710 --> 01:20:22,510
for whatever the file system we're running on

01:20:22,510 --> 01:20:26,300
is similar to what you might see in VFAT,

01:20:26,300 --> 01:20:28,730
for like app compatibility reasons.

01:20:29,710 --> 01:20:34,710
And we used to have shared OBB files

01:20:35,030 --> 01:20:37,920
where some things would be shared in between users,

01:20:37,920 --> 01:20:40,050
but we're no longer doing that.

01:20:40,050 --> 01:20:43,580
So we don't have to worry about that part of it anymore.

01:20:43,580 --> 01:20:46,540
There's some and also controls

01:20:46,540 --> 01:20:50,350
how we do some of our app permission handling

01:20:51,580 --> 01:20:56,580
and currently we in an SDcardFS we control this

01:20:56,970 --> 01:20:59,630
via some out of three patches

01:20:59,630 --> 01:21:02,730
which we are very much looking to not use anymore.

01:21:04,520 --> 01:21:07,060
So that's a motivation for some things that

01:21:07,060 --> 01:21:09,010
we are wanting to move away from.

01:21:09,010 --> 01:21:12,820
And we're currently using it to kind of control

01:21:12,820 --> 01:21:17,820
some quota tracking, which could be moved into user space.

01:21:19,690 --> 01:21:24,090
So for whether or not it's still needed,

01:21:24,090 --> 01:21:27,130
we don't do the share there would be folders anymore.

01:21:28,120 --> 01:21:32,120
The quota tracking can be moved into user space

01:21:32,120 --> 01:21:36,510
and possibly switch over to project ID quotas.

01:21:37,810 --> 01:21:41,610
The permission changes can also be done

01:21:41,610 --> 01:21:45,180
through other means possibly with read-only bind mounts

01:21:45,180 --> 01:21:46,013
or part of it.

01:21:46,013 --> 01:21:50,453
And like attempt FS for the parts that you know

01:21:50,453 --> 01:21:55,050
if you don't have permission to read or write or anything.

01:21:56,929 --> 01:21:57,970
And then yeah, the last bit remaining

01:21:57,970 --> 01:22:00,280
is a case insensitivity.

01:22:00,280 --> 01:22:02,890
So some of you may have seen the talk last year

01:22:02,890 --> 01:22:07,070
that Gabriel did on adding case insensitivity

01:22:07,070 --> 01:22:11,220
of case insensitivity to Ext4.

01:22:11,220 --> 01:22:15,190
So I've added that over into F2FS as well.

01:22:16,240 --> 01:22:19,920
Though it still does not yet support encryption.

01:22:19,920 --> 01:22:22,630
So that's something I've been working on adding

01:22:22,630 --> 01:22:24,430
and naturally we need to have that.

01:22:28,170 --> 01:22:33,170
So this is a kind of an overview of what we have.

01:22:33,920 --> 01:22:38,290
The red lines require the like encryption keys.

01:22:39,350 --> 01:22:43,730
So we have our name, we preserve the case,

01:22:43,730 --> 01:22:47,970
so we have, it's a case preserving system

01:22:47,970 --> 01:22:49,460
which unfortunately means that

01:22:49,460 --> 01:22:53,020
there is no direct relationship in between

01:22:53,020 --> 01:22:58,020
the directory entry and the name as we care about it

01:22:58,480 --> 01:23:00,710
without access to the key.

01:23:00,710 --> 01:23:03,040
So one of the big differences that we have here

01:23:03,040 --> 01:23:07,320
is that we can't really go from what's stored on disk

01:23:07,320 --> 01:23:10,240
to a hash to be able to look up the entry

01:23:10,240 --> 01:23:12,110
without having stored that there

01:23:12,110 --> 01:23:13,640
or having access the key.

01:23:16,450 --> 01:23:20,600
So I mean some changes in FS script to generate

01:23:22,620 --> 01:23:24,760
a hash that we can use.

01:23:25,892 --> 01:23:27,590
I'm sorry, for the no key token.

01:23:27,590 --> 01:23:29,340
The name that we present,

01:23:29,340 --> 01:23:31,990
when we have not yet decrypted the device.

01:23:33,160 --> 01:23:36,510
Currently that sometimes includes the hash.

01:23:36,510 --> 01:23:38,610
In the case of long names,

01:23:40,220 --> 01:23:44,450
where the base64 encoding that we do there prevents

01:23:44,450 --> 01:23:46,830
you from being able to use a full name.

01:23:48,200 --> 01:23:50,540
But it need to be some adjustments there.

01:23:50,540 --> 01:23:54,960
And along with like passing the hash down.

01:23:54,960 --> 01:23:59,580
So as this is, we currently have a plan

01:23:59,580 --> 01:24:03,110
for how to go forward with enabling encryption here.

01:24:04,880 --> 01:24:05,980
A bit of a typo there.

01:24:07,740 --> 01:24:12,460
And so, one of the minor inconveniences

01:24:12,460 --> 01:24:16,630
is that currently for the case holding support

01:24:16,630 --> 01:24:21,630
and F2FS and Ext4 we have some custom dentry operations

01:24:21,900 --> 01:24:24,870
and they're basically doing exactly the same thing

01:24:24,870 --> 01:24:26,730
and anyone else using this is going

01:24:26,730 --> 01:24:29,440
and having the same sort of operations.

01:24:29,440 --> 01:24:32,440
So one of the things that I'm looking at

01:24:32,440 --> 01:24:36,680
is moving that into the default ops.

01:24:38,500 --> 01:24:41,200
So additionally for the hash,

01:24:42,340 --> 01:24:44,780
the hash is based on the case folder name

01:24:44,780 --> 01:24:48,130
and naturally we can't just store the unencrypted hash there

01:24:48,990 --> 01:24:53,990
So I'm using fscrypt2 to drive a SipHash 2-4

01:24:55,470 --> 01:24:59,260
to generate the hash there.

01:25:01,420 --> 01:25:06,420
And we also looking to change the format of the no key token

01:25:07,620 --> 01:25:09,320
And so, currently we have a scheme

01:25:10,350 --> 01:25:14,590
which is a bit longer than what the default currently is.

01:25:14,590 --> 01:25:16,280
And I'm not super attached to it.

01:25:16,280 --> 01:25:21,020
So if anyone has objections to it being a lot longer

01:25:21,020 --> 01:25:23,380
and it currently is let me know.

01:25:24,920 --> 01:25:29,130
And on the Ext4 side, currently I don't believe

01:25:29,130 --> 01:25:31,280
it's store the hash on disk.

01:25:32,250 --> 01:25:34,870
So probably going to need to take a little bit

01:25:34,870 --> 01:25:37,320
of more space in that and that entry

01:25:37,320 --> 01:25:38,790
to make room for that.

01:25:42,580 --> 01:25:47,580
And yes, on another hand we have some interest

01:25:48,430 --> 01:25:52,063
and going back to a few solution we and...

01:25:54,567 --> 01:25:58,650
Yeah, so we have like some features

01:25:58,650 --> 01:26:02,540
that are other APIs explore at and...

01:26:02,540 --> 01:26:06,410
There's some desire to move these so that you have

01:26:06,410 --> 01:26:08,820
the same sort of things when you're going through

01:26:08,820 --> 01:26:12,490
our Java API or going through direct file access.

01:26:13,380 --> 01:26:17,350
And you know, when the I guess talk after the break.

01:26:18,260 --> 01:26:21,010
We'll be looking at Ext FUSE

01:26:21,010 --> 01:26:25,070
and the possibility for improving performance through that.

01:26:28,340 --> 01:26:32,630
So you know, anyone has any any comments?

01:26:37,660 --> 01:26:38,493
Questions?

01:26:57,650 --> 01:27:00,817
- Any takers, going once, going twice.

01:27:03,113 --> 01:27:08,113
So okay, then we'll go for a break right away.

01:27:08,593 --> 01:27:11,030
We are coming back at five sharp.

01:27:11,030 --> 01:27:13,317
Make sure you are properly caffeinated

01:27:13,317 --> 01:27:16,151
(speaks off microphone)

01:27:16,151 --> 01:27:19,318
(audience applauding)

02:03:05,010 --> 02:03:07,360
- All right, so we'll be starting very shortly.

02:03:08,230 --> 02:03:10,230
Eden can I ask you for the door, thanks.

02:03:34,380 --> 02:03:35,960
So same rules as before.

02:03:35,960 --> 02:03:37,293
Ashish you get the floor.

02:03:38,473 --> 02:03:43,473
- Thank you.

02:03:48,810 --> 02:03:50,510
All right, hello everyone?

02:03:50,510 --> 02:03:51,840
My name is Ashish.

02:03:51,840 --> 02:03:53,830
I'm a PhD student at Georgia Tech.

02:03:53,830 --> 02:03:57,670
And I'm presenting my work, part of my PhD research.

02:03:59,550 --> 02:04:00,990
Okay, is that good?

02:04:02,140 --> 02:04:04,370
So I'm presenting part of my PhD research

02:04:04,370 --> 02:04:06,380
that says how do you improve our performance

02:04:06,380 --> 02:04:09,000
of FUSE file system using EVPF

02:04:09,000 --> 02:04:12,070
and how can that be applied in in context of Android.

02:04:13,770 --> 02:04:16,520
So some background.

02:04:16,520 --> 02:04:20,190
So early Android devices shipped with microSD card slot.

02:04:22,138 --> 02:04:26,040
So users could pop in an SD card and expand the storage

02:04:26,040 --> 02:04:28,670
and there was an external partition called SD card

02:04:28,670 --> 02:04:32,720
it was FAT enabled and host OBB files

02:04:32,720 --> 02:04:36,190
and you know user data, pictures and videos.

02:04:38,490 --> 02:04:42,700
Later on this was replaced with virtual SD card.

02:04:42,700 --> 02:04:47,700
So a part of data partition was exposed as virtual SD card

02:04:47,760 --> 02:04:49,070
and was FUSE managed.

02:04:50,140 --> 02:04:53,840
By FUSE manager, I mean that the FUSE file system

02:04:53,840 --> 02:04:55,680
was doing the FAT emulation

02:04:55,680 --> 02:04:57,990
and enforcing custom permission checks.

02:04:57,990 --> 02:05:00,180
So FUSE is a state-of-the-art framework

02:05:00,180 --> 02:05:01,780
for developing user file system.

02:05:03,536 --> 02:05:05,140
So because it's in user space,

02:05:05,140 --> 02:05:06,480
there are a couple of advantages.

02:05:06,480 --> 02:05:09,150
So you can use existing third-party libraries.

02:05:09,150 --> 02:05:10,750
It's easy to maintain and debug.

02:05:11,630 --> 02:05:13,970
However, it comes with performance overhead.

02:05:15,420 --> 02:05:17,220
So let's see why.

02:05:17,220 --> 02:05:19,390
The main reason of performance overhead

02:05:19,390 --> 02:05:21,630
is the context switching that happens

02:05:21,630 --> 02:05:24,840
while serving file system requests in user space.

02:05:26,135 --> 02:05:30,000
So A FUSE allows the user space daemon

02:05:30,000 --> 02:05:32,380
to register file system handless with the kernel

02:05:32,380 --> 02:05:35,020
and every time there's a request from VFS

02:05:35,020 --> 02:05:37,050
to serve a file system requests,

02:05:37,050 --> 02:05:38,730
the requests are simply redirected

02:05:38,730 --> 02:05:42,190
to user space whether requests are served.

02:05:42,190 --> 02:05:44,120
So there's lot of context switching

02:05:44,120 --> 02:05:46,160
and that's why there performance overhead.

02:05:47,130 --> 02:05:49,640
And due to the performance overhead,

02:05:49,640 --> 02:05:52,240
fuse implementation was later on replaced

02:05:52,240 --> 02:05:56,280
with a new file system called SDcardFS.

02:05:56,280 --> 02:05:58,190
It's in kernel file system.

02:05:58,190 --> 02:05:59,670
It's so simple.

02:05:59,670 --> 02:06:01,170
So based on wrapper file system,

02:06:01,170 --> 02:06:04,970
so simple functionality stacked on lower file system

02:06:04,970 --> 02:06:06,950
using WrapFS and the functionality

02:06:06,950 --> 02:06:08,630
was same FAT emulation

02:06:08,630 --> 02:06:10,680
and enforcing custom permission checks.

02:06:12,160 --> 02:06:14,160
Now this is in kernel space entirely.

02:06:14,160 --> 02:06:16,070
So no context switching.

02:06:16,070 --> 02:06:18,450
However because it's in kernel space

02:06:18,450 --> 02:06:21,110
you need to debug it carefully,

02:06:21,110 --> 02:06:23,980
difficult to maintain, out of tree maintenance

02:06:23,980 --> 02:06:28,170
and you cannot use complex existing third-party libraries.

02:06:28,170 --> 02:06:31,260
Also results in bloated RCB and has security implications.

02:06:32,500 --> 02:06:33,400
So what can we do.

02:06:36,060 --> 02:06:40,200
So I'm proposing to use ExtFUSE for managing

02:06:40,200 --> 02:06:42,710
this emulated virtual a Sdcard.

02:06:42,710 --> 02:06:47,710
So what this does is you can have two parts now.

02:06:48,060 --> 02:06:52,490
A regular path in user space which is the default fuel spot.

02:06:52,490 --> 02:06:55,640
However you can also have in kernel handlers,

02:06:55,640 --> 02:06:59,220
thin handlers based on eBPF code.

02:06:59,220 --> 02:07:01,110
So what does it

02:07:01,961 --> 02:07:04,210
So you can have neo native performance

02:07:04,210 --> 02:07:06,180
because you'll be handling some of the requests

02:07:06,180 --> 02:07:07,100
right in the kernel,

02:07:07,100 --> 02:07:09,260
without switching to user space.

02:07:09,260 --> 02:07:11,240
And it results in better system reliability,

02:07:11,240 --> 02:07:14,500
you're not the bloating the kernel,

02:07:14,500 --> 02:07:19,350
you're not adding much complex functionality in the kernel

02:07:19,350 --> 02:07:22,500
and because it has the default use component,

02:07:22,500 --> 02:07:25,500
it's easy to port and debug and maintain.

02:07:26,810 --> 02:07:29,530
So let's see how ExtFUSE works.

02:07:29,530 --> 02:07:32,180
So like I said, now there are two parts,

02:07:32,180 --> 02:07:34,590
one slow path which is in user space fast path

02:07:34,590 --> 02:07:35,850
in the kernel space.

02:07:35,850 --> 02:07:37,460
What happens at mount time is,

02:07:37,460 --> 02:07:39,710
when you mount the file system,

02:07:39,710 --> 02:07:43,830
the BPF code or BPF handlers file system handles

02:07:43,830 --> 02:07:46,360
are inserted into the kernel verified

02:07:46,360 --> 02:07:49,000
and they are executed.

02:07:49,000 --> 02:07:52,900
You know as a part of BPF are a virtual machine runtime.

02:07:52,900 --> 02:07:55,890
So those handlers are very restricted

02:07:55,890 --> 02:07:57,860
and they live in a sandbox environment.

02:07:59,020 --> 02:08:01,560
So when application makes a system call

02:08:01,560 --> 02:08:03,130
or file system when it call,

02:08:03,130 --> 02:08:05,210
so step one there goes to VFS,

02:08:05,210 --> 02:08:08,060
step two just delivered to FUSE driver.

02:08:08,060 --> 02:08:10,520
Now simply, so FUSE driver

02:08:10,520 --> 02:08:12,510
will not simply redirect to users space.

02:08:12,510 --> 02:08:16,520
It will first check with the handlers with eBPF VM

02:08:16,520 --> 02:08:19,640
and if the handler can serve the request in the kernel,

02:08:19,640 --> 02:08:20,930
it'll directly serve the request

02:08:20,930 --> 02:08:22,960
with no context switching to user space.

02:08:22,960 --> 02:08:25,770
But if it has to fall back to the default path,

02:08:25,770 --> 02:08:28,210
it will forward the request to user space.

02:08:28,210 --> 02:08:30,320
So you have both fast and slow path.

02:08:30,320 --> 02:08:33,270
And eBPF maps are used to share metadata

02:08:33,270 --> 02:08:36,000
between the FUSE daemon and user space

02:08:36,000 --> 02:08:37,350
and the handlers in kernel.

02:08:39,290 --> 02:08:43,440
So this is an example of what can be enabled with ExtFUSE.

02:08:43,440 --> 02:08:46,850
So this handle_open is a part of the few statement.

02:08:46,850 --> 02:08:48,470
It's in user space.

02:08:48,470 --> 02:08:50,580
So I've added three lines here.

02:08:50,580 --> 02:08:53,360
So imap_key and imap_values,

02:08:53,360 --> 02:08:56,870
what I'm doing here is I'm creating an eBPF map

02:08:56,870 --> 02:08:59,670
that holds the file descriptor of

02:08:59,670 --> 02:09:02,780
the lower file in the kernel.

02:09:02,780 --> 02:09:05,630
And it's instructing the FUSE driver,

02:09:05,630 --> 02:09:09,290
that if the handler, if the extension in the kernel

02:09:09,290 --> 02:09:12,110
if the eBPF code in the colonel says that

02:09:13,370 --> 02:09:15,190
if the code says pass through

02:09:15,190 --> 02:09:18,430
then do not send the requester too FUSE Daemon,

02:09:18,430 --> 02:09:21,020
but use this file descriptor as the mapping

02:09:21,020 --> 02:09:22,760
between upper file and lower file

02:09:22,760 --> 02:09:25,950
and directly send IO request to lower file.

02:09:25,950 --> 02:09:27,580
And this is inserted in a map.

02:09:27,580 --> 02:09:29,190
A special map called inot_map.

02:09:30,160 --> 02:09:31,660
So the read_extension.

02:09:31,660 --> 02:09:32,940
This is part of the kernel.

02:09:32,940 --> 02:09:34,640
This is eBPF code.

02:09:34,640 --> 02:09:38,330
So that it gets all the parameters

02:09:38,330 --> 02:09:40,440
that a FUSE Daemon gets.

02:09:40,440 --> 02:09:43,070
So it will look up the file descriptor

02:09:44,105 --> 02:09:45,780
based on the upper...

02:09:45,780 --> 02:09:47,720
It will use the upper file descriptor as the key

02:09:47,720 --> 02:09:51,150
and look up the lower file descriptor value

02:09:51,150 --> 02:09:53,510
and then it will instruct the FUSE driver

02:09:53,510 --> 02:09:54,460
to do pass through.

02:09:54,460 --> 02:09:57,210
So as opposed to delivering the read request,

02:09:57,210 --> 02:09:59,630
to user space the read request is directly delivered

02:09:59,630 --> 02:10:00,960
to the lower file system,

02:10:00,960 --> 02:10:03,600
hence it bypasses the user space context switching.

02:10:04,660 --> 02:10:08,040
And you get a very good performance improvement.

02:10:08,040 --> 02:10:10,070
so I tested with two games

02:10:10,070 --> 02:10:12,820
and why games because like I mentioned,

02:10:12,820 --> 02:10:16,090
OBB files are placed on your SD card

02:10:16,090 --> 02:10:19,070
and they are kind of small files.

02:10:19,070 --> 02:10:21,370
So if you handle everything in user space

02:10:21,370 --> 02:10:23,320
there's a lot of performance overhead

02:10:23,320 --> 02:10:25,090
with ExtFuse.

02:10:25,090 --> 02:10:28,010
You get to bypass that and handle all the requests

02:10:28,010 --> 02:10:30,380
in kernel directly to the door file system

02:10:30,380 --> 02:10:32,180
and you get performance improvement.

02:10:34,660 --> 02:10:37,780
I think that's it(mumbles)

02:10:46,500 --> 02:10:48,010
- I wanted to ask, how does the how do

02:10:48,010 --> 02:10:50,410
those numbers compare to SDcardFS.

02:10:50,410 --> 02:10:51,243
Did you try them?

02:10:51,243 --> 02:10:52,090
- No, I did not.

02:10:52,090 --> 02:10:53,650
So it's very close to native.

02:10:53,650 --> 02:10:57,280
So I'm assuming that SDcardFS gives you native performance.

02:10:57,280 --> 02:10:59,970
I bet it did not get a chance to do that.

02:10:59,970 --> 02:11:03,390
- And the second question was about the maps.

02:11:03,390 --> 02:11:04,690
Why are there custom maps?

02:11:05,766 --> 02:11:10,610
- So let me go to backup slides.

02:11:10,610 --> 02:11:12,820
This is a metadata cache example.

02:11:12,820 --> 02:11:14,806
So I'm trying to cover more.

02:11:14,806 --> 02:11:16,010
You know, as I answer the questions.

02:11:16,010 --> 02:11:18,620
So here I'm doing you know caching of attributes

02:11:18,620 --> 02:11:21,320
and because I'm creating custom cache in the kernel,

02:11:21,320 --> 02:11:25,010
the the request will serve directly in the kernel.

02:11:25,010 --> 02:11:26,920
So answering the map question.

02:11:26,920 --> 02:11:31,630
There are special maps because unlike regular eBPF maps

02:11:31,630 --> 02:11:34,710
that are accessible to either all processes

02:11:34,710 --> 02:11:39,710
or the super user process with with caps assignment,

02:11:39,990 --> 02:11:43,480
we want FUSE teaming which is potentially untrusted

02:11:43,480 --> 02:11:46,140
and you know user space unprivileged application

02:11:46,140 --> 02:11:50,970
to be able to insert code in the kernel,

02:11:50,970 --> 02:11:54,080
access the maps and not leak anything.

02:11:54,080 --> 02:11:56,880
So I've created special maps so that the maps

02:11:56,880 --> 02:12:01,220
can only be accessed by the FUSE Daemon and no other process

02:12:08,490 --> 02:12:11,390
- I thought this was already possible

02:12:11,390 --> 02:12:14,930
with the maps being mapped into the file system

02:12:14,930 --> 02:12:18,730
with UID and get standard permission limits on those.

02:12:20,241 --> 02:12:21,726
- [Ashish] So you saying it's already possible

02:12:21,726 --> 02:12:25,180
to have special maps which are only accessed

02:12:25,180 --> 02:12:26,690
by a particular process?

02:12:26,690 --> 02:12:28,290
- As far as I know that's the case.

02:12:28,290 --> 02:12:30,010
- [Ashish] Okay, so I think--

02:12:30,010 --> 02:12:32,170
- We actually even have maps that are readable

02:12:32,170 --> 02:12:36,646
from Java but writable from Daemons.

02:12:36,646 --> 02:12:39,140
- I think when I started working on this

02:12:39,140 --> 02:12:41,120
there wasn't no support of that.

02:12:41,120 --> 02:12:43,701
But you know if the support is there we can use it.

02:12:43,701 --> 02:12:46,850
- I'm not 100% certain but I'm almost certain.

02:12:46,850 --> 02:12:47,770
- Okay, good.

02:12:50,727 --> 02:12:51,560
- Do you have examples of things

02:12:51,560 --> 02:12:53,580
that have to be handled in user space

02:12:53,580 --> 02:12:57,700
and can't be handled by BPF.

02:12:57,700 --> 02:12:59,930
- For example, let me see.

02:13:01,620 --> 02:13:03,500
I give you an example of open right.

02:13:03,500 --> 02:13:06,130
So Open has to be handled in user space.

02:13:06,130 --> 02:13:08,970
Because open will instruct the driver based on

02:13:08,970 --> 02:13:12,460
some parameters that would be inserted in the map right.

02:13:12,460 --> 02:13:15,770
So open cannot be handled in kernel.

02:13:16,710 --> 02:13:19,740
And then some in this example

02:13:19,740 --> 02:13:22,770
where I show how metadata caching works,

02:13:22,770 --> 02:13:24,710
so the first one get attribute.

02:13:24,710 --> 02:13:28,240
It's looking the cache, it's consuming the cache.

02:13:28,240 --> 02:13:30,740
The other one is actually doing the invalidation

02:13:30,740 --> 02:13:32,130
because you're caching.

02:13:32,130 --> 02:13:34,280
You just want to make sure there is no stale data.

02:13:34,280 --> 02:13:36,180
So you need to invalidate it as well.

02:13:36,180 --> 02:13:37,740
So if there is a set attribute,

02:13:37,740 --> 02:13:41,260
you need to invalidate and then go back to user space.

02:13:41,260 --> 02:13:42,350
So this is another example

02:13:42,350 --> 02:13:44,814
where you would go back to user space.

02:13:44,814 --> 02:13:49,814
- [Karim] We got five minutes.

02:13:55,200 --> 02:13:57,450
- Last question, when do we see the code?

02:13:58,502 --> 02:14:00,450
(all laughing)

02:14:00,450 --> 02:14:01,283
- Good question.

02:14:01,283 --> 02:14:03,230
With little help from Google, pretty soon.

02:14:16,616 --> 02:14:19,783
- Did you look at what's changed in Q?

02:14:21,300 --> 02:14:22,393
- Sorry?

02:14:22,393 --> 02:14:23,570
- Did you look at what's changed in Q yet?

02:14:23,570 --> 02:14:25,020
The Q AOSP release.

02:14:25,020 --> 02:14:26,450
Cause may be that--

02:14:26,450 --> 02:14:27,730
- Android Q. - Android Q.

02:14:27,730 --> 02:14:28,590
- Oh, no I haven't.

02:14:28,590 --> 02:14:30,780
- Cause maybe that would link in what you were saying

02:14:30,780 --> 02:14:33,522
that maybe some of these things aren't exposed before then.

02:14:33,522 --> 02:14:36,711
I don't know.

02:14:36,711 --> 02:14:41,610
Oh sorry, I'm not toeing the line on the version name change

02:14:43,000 --> 02:14:44,880
- Yes, if something it already exists are

02:14:44,880 --> 02:14:46,190
we can reuse that.

02:14:46,190 --> 02:14:47,240
No need for new code.

02:14:57,260 --> 02:15:00,030
- I think those parts were developed in AOSP all along.

02:15:00,030 --> 02:15:03,310
So I think it's been available for many months now.

02:15:08,760 --> 02:15:10,830
- So I think still have some time.

02:15:10,830 --> 02:15:12,150
- Yes, you have three minutes.

02:15:12,150 --> 02:15:13,480
- If you don't have any questions

02:15:13,480 --> 02:15:16,220
I would like to point out another example.

02:15:16,220 --> 02:15:19,870
So this is an example where, so I give you all three cases,

02:15:19,870 --> 02:15:21,590
actually took instance this is the third one.

02:15:21,590 --> 02:15:25,540
So use cases with Ext4 that you can do.

02:15:25,540 --> 02:15:28,780
So you can have direct IO pass-through to lower file system.

02:15:28,780 --> 02:15:32,160
You can have custom metadata caching in the kernel

02:15:32,160 --> 02:15:35,170
and you can enforce permission checks in the kernel.

02:15:36,233 --> 02:15:37,260
So this is again eBPF code.

02:15:37,260 --> 02:15:40,900
So you can you can insert this code in the kernel

02:15:40,900 --> 02:15:45,260
and execute that as part of let's say lookup operation

02:15:45,260 --> 02:15:48,490
or get attributed operation if needed.

02:15:51,870 --> 02:15:53,030
- There are two questions.

02:15:53,030 --> 02:15:54,980
Have you tried up streaming the BPF parts

02:15:54,980 --> 02:15:57,800
into the FUSE kernel?

02:15:59,000 --> 02:16:00,010
- No, I haven't tried.

02:16:00,010 --> 02:16:02,149
I've released the kernel code.

02:16:02,149 --> 02:16:06,670
So I did not get a chance to test with meltdown patches.

02:16:06,670 --> 02:16:08,570
So that's something that I need to do.

02:16:09,450 --> 02:16:11,150
And then not high up streaming it.

02:16:13,800 --> 02:16:15,900
Because meltdown will change the equation.

02:16:17,260 --> 02:16:21,320
- One of the things we're considering is also read use cases

02:16:24,040 --> 02:16:26,920
does it work where it's either always passed through

02:16:26,920 --> 02:16:28,570
or always an upcall?

02:16:28,570 --> 02:16:33,160
Is there a way today or do you have any ideas around

02:16:33,160 --> 02:16:36,700
if you can see something about that.

02:16:36,700 --> 02:16:39,450
- For example, if you insert your custom read extension

02:16:39,450 --> 02:16:41,770
in the kernel, for example this one,

02:16:41,770 --> 02:16:43,390
if you want always pass through,

02:16:43,390 --> 02:16:45,220
you can just say upcall always.

02:16:45,220 --> 02:16:48,730
Replace it with upcall or you could have some custom check.

02:16:48,730 --> 02:16:52,670
You know based on UID, GID, PID you know something else

02:16:52,670 --> 02:16:54,210
that will either,

02:16:54,210 --> 02:16:56,660
so conditionally generate upcall or pass through.

02:16:59,050 --> 02:16:59,890
- Okay, thanks.

02:17:07,570 --> 02:17:08,952
- Any other question?

02:17:08,952 --> 02:17:13,952
- [Man] Free time.

02:17:19,050 --> 02:17:21,073
All right then, thank you so much.

02:17:21,073 --> 02:17:22,387
- [Audience] Thank you.

02:17:22,387 --> 02:17:25,554
(audience applauding)

02:18:22,270 --> 02:18:24,450
- It works(laughs)

02:18:43,070 --> 02:18:45,360
What news like template?

02:18:46,940 --> 02:18:47,773
(all laughs)

02:18:47,773 --> 02:18:50,900
(man speaks off microphone)

02:18:50,900 --> 02:18:52,620
Okay, so I wanted to cover,

02:18:52,620 --> 02:18:54,200
what we've been doing with the eBPF

02:18:54,200 --> 02:18:55,500
for networking in Android.

02:18:56,810 --> 02:18:59,520
And I joined the team only about a year ago.

02:18:59,520 --> 02:19:01,700
I was working on networking on servers before that.

02:19:01,700 --> 02:19:03,520
So a lot of this work was actually done

02:19:03,520 --> 02:19:06,290
by my current manager Lorenzo and Chenbo.

02:19:07,660 --> 02:19:11,300
And they did all the work for P

02:19:11,300 --> 02:19:13,010
with most of the implementation by Chenbo

02:19:13,010 --> 02:19:14,640
and the runs are doing the reviews.

02:19:14,640 --> 02:19:16,410
And for Q it was half-and-half.

02:19:16,410 --> 02:19:18,670
And going forward it's gonna be probably mostly me.

02:19:21,844 --> 02:19:22,677
So why eBPF?

02:19:23,770 --> 02:19:25,120
There's a bunch of reasons.

02:19:26,280 --> 02:19:28,860
Getting rid of custom Android kernel patches

02:19:28,860 --> 02:19:30,410
is probably the largest one.

02:19:30,410 --> 02:19:33,790
So anything we can move into eBPF is great

02:19:33,790 --> 02:19:35,600
for long-term maintainability.

02:19:36,690 --> 02:19:37,820
There's also just stuff

02:19:37,820 --> 02:19:40,210
where we can actually get performance improvements

02:19:40,210 --> 02:19:43,390
by moving out of user space and into eBPF.

02:19:44,690 --> 02:19:47,390
There's also actually a lot more configurability

02:19:47,390 --> 02:19:49,140
that can be accomplished with eBPF.

02:19:50,010 --> 02:19:52,240
Capabilities for example, are pretty limited

02:19:52,240 --> 02:19:53,430
in what you can accomplish with them.

02:19:53,430 --> 02:19:54,580
There's a small number of them.

02:19:54,580 --> 02:19:56,560
You can't dynamically grant them to processes

02:19:56,560 --> 02:19:59,790
only when you start the process that sort of stuff.

02:20:01,470 --> 02:20:04,560
Kernel upgrades are a huge problem.

02:20:05,630 --> 02:20:08,570
You can't really upgrade devices in the field.

02:20:12,160 --> 02:20:14,270
You can upgrade eBPF programs basically

02:20:14,270 --> 02:20:16,200
but you can't upgrade kernels, right?

02:20:16,200 --> 02:20:18,160
So if we can move stuff into the eBPF,

02:20:18,160 --> 02:20:20,080
then we can rev it with the platform.

02:20:21,610 --> 02:20:24,740
And well, the reason I moved to the team

02:20:24,740 --> 02:20:25,750
was because I like eBPF

02:20:25,750 --> 02:20:29,890
and I wanted to work on this so(laughs)

02:20:29,890 --> 02:20:33,800
So this is a quick rundown of what we did in Android P.

02:20:33,800 --> 02:20:36,560
This was actually presented at LPC two years ago.

02:20:36,560 --> 02:20:38,910
So I only have one slide on this.

02:20:38,910 --> 02:20:40,530
And the primary thing we did was

02:20:40,530 --> 02:20:44,580
we got rid of the xt_qtaguid extension,

02:20:44,580 --> 02:20:48,210
which was a custom ip tables, piece of code

02:20:48,210 --> 02:20:51,310
and it was actually constant source of problems

02:20:51,310 --> 02:20:53,830
because every time the upstream kernel changed something,

02:20:53,830 --> 02:20:55,520
we would end up with all sorts of deadlocks

02:20:55,520 --> 02:20:57,010
and bugs and stuff not working.

02:20:57,010 --> 02:21:00,060
And then, we'd have to spend time debugging it.

02:21:01,454 --> 02:21:04,960
So Chenbo moved all of that into eBPF code

02:21:05,840 --> 02:21:08,690
and in Q on supported devices

02:21:08,690 --> 02:21:11,980
we no longer use the qtaguid extension

02:21:11,980 --> 02:21:14,620
and we even reverted the code out of the kernel.

02:21:14,620 --> 02:21:18,370
So it's faster, it's cleaner and we hopefully

02:21:18,370 --> 02:21:19,680
won't have to touch it ever again,

02:21:19,680 --> 02:21:21,410
because it will just keep on working.

02:21:24,520 --> 02:21:27,320
So those are the links to the slides from two years ago.

02:21:28,880 --> 02:21:30,690
So what we did in Q.

02:21:30,690 --> 02:21:33,620
We did basically two things: one was, there

02:21:33,620 --> 02:21:36,780
was another custom kernel patch called Paranoid Android

02:21:36,780 --> 02:21:41,780
which did, basically is a way to prevent apps

02:21:42,700 --> 02:21:44,280
from having access to sockets.

02:21:45,210 --> 02:21:49,300
And this was switched for the 414+ kernel

02:21:49,300 --> 02:21:51,890
to use eBPF hooks at socket creation time

02:21:51,890 --> 02:21:54,390
to do permission checks

02:21:54,390 --> 02:21:57,590
at that point in time based on the UID.

02:21:59,910 --> 02:22:04,910
And the other thing, we did was we had a user space Daemon

02:22:05,730 --> 02:22:09,840
that enables the phone to support v4 applications

02:22:09,840 --> 02:22:12,510
on a v6 only cellular connection.

02:22:12,510 --> 02:22:15,110
And in order to do this, it has to do,

02:22:15,110 --> 02:22:19,220
basically translate IPv6 packets into IPv4 packets

02:22:19,220 --> 02:22:22,020
and translate IPv4 packets into IPv6 packets.

02:22:23,070 --> 02:22:25,730
Applications that actually support ipv6,

02:22:25,730 --> 02:22:30,140
will get tricked by DNS into using IPv6 even

02:22:30,140 --> 02:22:32,400
to talk to ipv4 destinations.

02:22:32,400 --> 02:22:35,190
But applications that don't support IPv6

02:22:35,190 --> 02:22:37,500
will keep on using IPv4.

02:22:37,500 --> 02:22:41,340
Applications that use v4 literals will keep on using IPv4

02:22:41,340 --> 02:22:44,360
and if you tether a phone anything that is being tethered

02:22:44,360 --> 02:22:49,360
over v4, over a v6 uplink will also go through this code.

02:22:49,890 --> 02:22:53,800
So there was this Daemon and it was slow, really slow

02:22:55,916 --> 02:22:58,580
and we replaced it in one direction only

02:22:58,580 --> 02:23:02,550
and only for the most simple of cases with eBPF code.

02:23:02,550 --> 02:23:04,440
So we actually still run the Daemon,

02:23:04,440 --> 02:23:05,890
but all the simple cases.

02:23:05,890 --> 02:23:09,310
So TCP and UDP that isn't fragmented

02:23:09,310 --> 02:23:11,310
and it's coming from the cellular uplink

02:23:12,320 --> 02:23:15,480
is handled by eBPF and no longer hits the Daemon.

02:23:17,006 --> 02:23:18,683
And that was a huge win.

02:23:18,683 --> 02:23:23,210
Depending on how you run the benchmark numbers,

02:23:23,210 --> 02:23:25,510
potentially the improvement is 400x

02:23:26,990 --> 02:23:31,990
but that's my personal belief is that there's bugs

02:23:32,600 --> 02:23:35,650
in the user space daemon that we have to fix.

02:23:35,650 --> 02:23:37,927
So I don't think it's quite that good,

02:23:37,927 --> 02:23:40,710
but well still 400x is improvement, is pretty good.

02:23:44,540 --> 02:23:47,990
And there's all sorts of interesting problems

02:23:47,990 --> 02:23:50,650
working with eBPF and Android.

02:23:50,650 --> 02:23:52,830
We don't have the benefit of being

02:23:52,830 --> 02:23:55,080
on the newest kernel all the time.

02:23:55,080 --> 02:23:56,490
So there's all sorts of crazy things

02:23:56,490 --> 02:23:58,740
like you make a change to eBPF map

02:23:59,590 --> 02:24:02,340
that doesn't immediately take effect

02:24:02,340 --> 02:24:04,320
because of multi-threaded systems

02:24:04,320 --> 02:24:07,120
and all sorts of schedule or problems.

02:24:07,120 --> 02:24:10,210
So if you if you want to make sure that

02:24:10,210 --> 02:24:12,410
the new eBPF code is using the new eBPF map,

02:24:13,500 --> 02:24:14,850
then you actually need to make sure

02:24:14,850 --> 02:24:19,850
that a kernel RCU grace period has expired.

02:24:20,370 --> 02:24:22,720
And there's actually no way to do that from user space.

02:24:22,720 --> 02:24:25,100
So we were scratching our heads for a long time,

02:24:25,100 --> 02:24:27,090
how to do this on the 4.9 kernel

02:24:27,090 --> 02:24:29,050
and we discovered that if you create,

02:24:30,640 --> 02:24:33,720
an AF key socket and then close it,

02:24:33,720 --> 02:24:35,530
then closing the socket forces

02:24:35,530 --> 02:24:37,710
an RCU synchronization event to take place.

02:24:39,390 --> 02:24:41,010
That's part of the cleanup code path.

02:24:41,010 --> 02:24:43,170
So that's just terrible hack, but it works.

02:24:46,830 --> 02:24:49,650
Well, on newer upstream kernels there actually

02:24:49,650 --> 02:24:51,200
is a way to force the synchronisation

02:24:51,200 --> 02:24:52,720
with an explicit API.

02:24:52,720 --> 02:24:54,370
Yeah, it's just not there in 4.9.

02:24:56,260 --> 02:24:57,660
And what we would like to do,

02:24:57,660 --> 02:24:59,350
so everything I've been talking up till now

02:24:59,350 --> 02:25:01,850
is available in Q it's all published in AOSP

02:25:01,850 --> 02:25:04,410
and there will be links to the code later on.

02:25:04,410 --> 02:25:07,850
Now this is kind of like what we would like to do in R.

02:25:07,850 --> 02:25:11,160
So the IPv6 translation it was done only

02:25:11,160 --> 02:25:14,020
for the simplest cases and only on receive.

02:25:14,020 --> 02:25:15,690
We would like to handle all

02:25:15,690 --> 02:25:19,940
the more complex cases, fragmented packets, ICMP datagrams

02:25:19,940 --> 02:25:23,040
and we would like to handle the transmit side as well.

02:25:23,040 --> 02:25:25,590
There just wasn't enough time to do that.

02:25:25,590 --> 02:25:28,170
Unfortunately, there's a bunch of problems here.

02:25:28,170 --> 02:25:31,270
Stuff like for example the standard BPF translator

02:25:31,270 --> 02:25:36,270
for v6 to v4 assumes that v6 is 40 bytes and v4 is 20 bytes

02:25:36,750 --> 02:25:41,280
of headers, but it turns out that a v4 fragment is 20 bytes

02:25:41,280 --> 02:25:43,160
but a v6 fragment is 48 bytes.

02:25:43,160 --> 02:25:46,130
So there's this 8 bytes that you kind of have

02:25:46,130 --> 02:25:49,080
to handle correctly and there's no support for that in 4.9.

02:25:51,066 --> 02:25:52,470
So we'll see what happens.

02:25:56,810 --> 02:26:00,110
We are hoping to do something to improve tethering

02:26:00,950 --> 02:26:05,950
as well, there's it's hard to say

02:26:06,380 --> 02:26:09,410
what what exactly the current problems are with tethering.

02:26:10,540 --> 02:26:14,280
Some people think that it's a very complex network setup

02:26:14,280 --> 02:26:17,940
because of the fact that we support multiple up links

02:26:17,940 --> 02:26:21,860
and we have a very complex routing setup

02:26:21,860 --> 02:26:25,170
and a very complex IP tables set up as a result of this.

02:26:25,170 --> 02:26:28,110
And other people think that it's mostly just problems

02:26:28,110 --> 02:26:29,010
in the network drivers,

02:26:29,010 --> 02:26:30,330
where they're not terribly optimized

02:26:30,330 --> 02:26:33,220
and that a lot of fixes could be done there.

02:26:34,540 --> 02:26:35,373
We shall see.

02:26:36,290 --> 02:26:38,700
My personal belief is that a lot of the problems

02:26:38,700 --> 02:26:40,840
are coming from the complex setup

02:26:40,840 --> 02:26:44,210
and that by moving to packet forwarding in eBPF,

02:26:44,210 --> 02:26:47,680
we can hopefully at least eliminate those bottlenecks.

02:26:47,680 --> 02:26:48,513
But we'll see.

02:26:49,510 --> 02:26:51,780
I was hoping that we would try to use XDP,

02:26:51,780 --> 02:26:55,090
but based on some discussions earlier today

02:26:55,090 --> 02:26:56,110
in the networking track,

02:26:56,110 --> 02:27:00,999
it sounds like not this year.(laughs)

02:27:00,999 --> 02:27:02,949
It sounds like it's super super complex

02:27:04,300 --> 02:27:06,050
and we still need to enable the JIT

02:27:07,140 --> 02:27:09,093
because we're not using it.

02:27:12,320 --> 02:27:13,620
So challenges.

02:27:14,520 --> 02:27:15,720
Security is a challenge,

02:27:16,560 --> 02:27:20,430
because well do you want to load untrusted eBPF?

02:27:20,430 --> 02:27:22,430
Do you want to dynamically generate eBPF?

02:27:22,430 --> 02:27:26,350
Do you only want to load eBPF from a read-only partition,

02:27:26,350 --> 02:27:28,660
from DM-verity etc etc.

02:27:28,660 --> 02:27:31,400
So a lot of thought has been going into that

02:27:31,400 --> 02:27:33,340
and sometimes you need crazy workarounds

02:27:33,340 --> 02:27:35,020
like put Booleans and maps

02:27:35,020 --> 02:27:37,120
so that you can dynamically choose the code path

02:27:37,120 --> 02:27:39,863
instead of just load a different program

02:27:39,863 --> 02:27:40,930
or dynamically compile the program.

02:27:42,320 --> 02:27:45,620
Another thing that keeps on showing up is stuff relating

02:27:45,620 --> 02:27:47,850
to filtering netlink messages.

02:27:49,190 --> 02:27:51,570
The kernel generates and that link responds,

02:27:51,570 --> 02:27:54,420
upstream considers the entire content of that message

02:27:54,420 --> 02:27:59,420
to be open like freely available to everybody on the machine

02:28:01,570 --> 02:28:03,560
and that might include stuff that we would consider

02:28:03,560 --> 02:28:06,360
to be privacy conscious like a MAC address or something.

02:28:07,480 --> 02:28:10,210
So you may want to parse that out

02:28:10,210 --> 02:28:12,010
and maybe we can use eBPF

02:28:12,010 --> 02:28:14,500
to somehow filter out Network messages.

02:28:14,500 --> 02:28:15,750
It sounds very difficult to do.

02:28:15,750 --> 02:28:16,900
We'll see what happens.

02:28:18,370 --> 02:28:20,180
A constant source of trouble is trying

02:28:20,180 --> 02:28:23,370
to make all this stuff work on old kernels

02:28:23,370 --> 02:28:25,190
because there's all this cool stuff

02:28:25,190 --> 02:28:27,909
and you know kernels that are three years newer

02:28:27,909 --> 02:28:32,450
and another problem is there's

02:28:32,450 --> 02:28:34,290
a lot of different hardware out there.

02:28:34,290 --> 02:28:36,090
There's a lot of different kernels on this,

02:28:36,090 --> 02:28:37,910
they have a lot of different configuration options

02:28:37,910 --> 02:28:40,760
that are have a lot of different backboards and patches.

02:28:40,760 --> 02:28:42,850
And making sure everything works and testing

02:28:42,850 --> 02:28:44,350
is really really really hard.

02:28:45,440 --> 02:28:49,827
Development is actually easiest in a VM which is sad.

02:28:51,810 --> 02:28:54,270
And this is pretty much my final slide.

02:28:55,710 --> 02:28:57,030
As a result of all this,

02:28:58,410 --> 02:29:02,250
the Delta between the android common kernel

02:29:02,250 --> 02:29:05,190
as regards to networking and upstream Linux kernel

02:29:06,500 --> 02:29:09,690
is down to five patches.

02:29:11,280 --> 02:29:13,850
One of them is one line, one of them is two lines

02:29:15,100 --> 02:29:17,380
and three of them are more complex.

02:29:17,380 --> 02:29:20,290
And I think we have a plan for how to eliminate another one

02:29:20,290 --> 02:29:21,890
or maybe one and a half of them.

02:29:23,170 --> 02:29:25,270
So it's nice.

02:29:25,270 --> 02:29:28,190
Unfortunately, this is only the Android common kernel.

02:29:28,190 --> 02:29:30,010
There is still a lot of networking patches

02:29:30,010 --> 02:29:32,710
that are in device specific kernels.

02:29:32,710 --> 02:29:34,210
So we still have to figure out

02:29:34,210 --> 02:29:36,120
what to do with all that stuff

02:29:36,120 --> 02:29:38,890
and how much of it we can we can upstream.

02:29:38,890 --> 02:29:41,950
And upstream keeps on changing stuff.

02:29:43,748 --> 02:29:44,970
And we have networking tests

02:29:44,970 --> 02:29:47,910
and they like every time something new fails.

02:29:48,880 --> 02:29:51,300
So chasing upstream sometimes it's our tests that are broken

02:29:51,300 --> 02:29:52,906
sometimes it's something that upstream broke,

02:29:52,906 --> 02:29:55,100
sometimes it's bad assumptions somewhere else.

02:29:55,100 --> 02:29:57,750
It's painful it takes a lot of time, a lot of effort.

02:29:59,410 --> 02:30:01,900
And questions?

02:30:12,710 --> 02:30:14,270
- Caught it!

02:30:14,270 --> 02:30:16,620
So you mentioned testing and testing is quite complex.

02:30:16,620 --> 02:30:18,100
How do we help you with that?

02:30:21,630 --> 02:30:24,100
- When you say you're from Linaro.

02:30:27,830 --> 02:30:30,280
I don't entirely know how to answer that question.

02:30:30,280 --> 02:30:33,070
I know that we've been trying to make sure

02:30:33,070 --> 02:30:35,600
that we run the networking test suite

02:30:35,600 --> 02:30:39,160
against all the versions of the common kernel out there

02:30:39,160 --> 02:30:43,310
and that we run Android OS

02:30:43,310 --> 02:30:45,200
against every version of that kernel,

02:30:45,200 --> 02:30:48,430
so that we run the Q user space against the 4.9 P kernel

02:30:48,430 --> 02:30:51,270
that we run the Q user space against the 4.9 kernel etc,

02:30:52,520 --> 02:30:54,400
that we run the networking test on all those kernels,

02:30:54,400 --> 02:30:57,160
that we run it on arm, that we run it on x86,

02:30:57,160 --> 02:30:59,580
that we run 64-bit user space, on 64-bit kernel

02:30:59,580 --> 02:31:01,540
is 32-bit user space on 64-bit kernel,

02:31:01,540 --> 02:31:03,390
32-bit users space on 32-bit kernels.

02:31:04,310 --> 02:31:06,360
One of the patches that we actually have,

02:31:06,360 --> 02:31:09,050
the two line patch is actually deleting text from the kernel

02:31:09,050 --> 02:31:11,702
in order to allow 32 and 64 to work.

02:31:11,702 --> 02:31:14,310
So there's a lot of that.

02:31:14,310 --> 02:31:18,130
I'm not entirely sure where the continuous integration tests

02:31:18,130 --> 02:31:20,310
that Linaro runs could fit into this.

02:31:20,310 --> 02:31:23,641
But I'm sure something could be done.

02:31:23,641 --> 02:31:27,190
I'm really hoping that the Cuttlefish

02:31:27,190 --> 02:31:30,480
and GKI initiatives will reduce the the complexity.

02:31:32,510 --> 02:31:34,100
I don't know what that answers your question.

02:31:34,100 --> 02:31:34,933
- Well, it helps.

02:31:34,933 --> 02:31:37,110
At least your test cases are they at least open?

02:31:39,090 --> 02:31:42,270
- They're in there VTS.

02:31:42,270 --> 02:31:45,490
- Right, so the tests are all there in VTS.

02:31:45,490 --> 02:31:49,700
Unfortunately, right now all the virtualization environments

02:31:49,700 --> 02:31:53,880
don't actually really have networking supporting them.

02:31:53,880 --> 02:31:56,530
We don't have v6 in the virtualization environment.

02:31:57,940 --> 02:32:01,210
We don't have like basically there are no real tests,

02:32:01,210 --> 02:32:03,020
like at the end of the day,

02:32:03,020 --> 02:32:04,950
you run the tests by flashing a device

02:32:04,950 --> 02:32:06,440
and taking it out into the field

02:32:06,440 --> 02:32:08,780
and walking around and finding access points

02:32:08,780 --> 02:32:11,290
and cellular networks and stuff like that.

02:32:11,290 --> 02:32:14,063
Captive portals and all sorts of stuff like that.

02:32:14,063 --> 02:32:19,063
A lot of work to be done there.

02:32:19,890 --> 02:32:22,150
- I had a question about the net link routing.

02:32:22,150 --> 02:32:24,370
Do you have any thoughts on how do we solve that problem.

02:32:24,370 --> 02:32:26,100
I know you know the problem.

02:32:26,100 --> 02:32:29,080
The problem is basically just for everybody.

02:32:29,080 --> 02:32:30,560
The net link broadcast has they come

02:32:30,560 --> 02:32:33,590
to user space Android has two native humans

02:32:33,590 --> 02:32:35,410
that listen to them one is Uevent

02:32:35,410 --> 02:32:37,080
and the other is Healthy.

02:32:37,080 --> 02:32:39,660
Healthy is the thing that monitors battery,

02:32:39,660 --> 02:32:42,830
but but it basically evolves with an equal wake up

02:32:42,830 --> 02:32:46,880
because it has to, because your device battery can die

02:32:46,880 --> 02:32:48,810
while the device is suspended.

02:32:48,810 --> 02:32:50,500
So when the battery state changes

02:32:50,500 --> 02:32:52,220
whether it's temperature or battery state

02:32:52,220 --> 02:32:54,010
we want to make sure Healthy knows about it,

02:32:54,010 --> 02:32:56,530
so it can take action in case the battery is critical

02:32:56,530 --> 02:32:58,480
or the temperature is dangerous.

02:32:59,440 --> 02:33:02,970
So but the problem because of that equal wakeup

02:33:02,970 --> 02:33:06,000
happens is when the device is being suspended,

02:33:06,000 --> 02:33:08,570
there are CPU hot plug events that gets created

02:33:08,570 --> 02:33:10,590
and sent over broadcast over uevent.

02:33:11,680 --> 02:33:12,530
Net link broadcast.

02:33:12,530 --> 02:33:15,000
And those are seen by Healthy,

02:33:15,000 --> 02:33:17,520
because it's and then new wake up user space,

02:33:17,520 --> 02:33:19,200
it tries to go down into suspend again

02:33:19,200 --> 02:33:20,260
and again the CPU shut down

02:33:20,260 --> 02:33:22,180
and the cycle continues.

02:33:22,180 --> 02:33:25,090
So basically that breaks suspense pretty much for us.

02:33:25,090 --> 02:33:27,620
It only happened on x86 and it happens

02:33:27,620 --> 02:33:29,070
as the code changes upstream,

02:33:29,070 --> 02:33:30,716
because this was new.

02:33:30,716 --> 02:33:32,620
We didn't this event or this year even

02:33:32,620 --> 02:33:34,070
it wasn't there before.

02:33:34,070 --> 02:33:36,110
So we were looking for a solution where

02:33:36,110 --> 02:33:39,000
the user space can tell the kernel to filter uvents

02:33:39,000 --> 02:33:41,080
and that's probably what you meant there.

02:33:41,080 --> 02:33:42,980
- Yeah, that was on one of the slides.

02:33:45,688 --> 02:33:47,420
I don't have a good answer for this.

02:33:47,420 --> 02:33:52,300
I'm really actually scared of filtering net link in eBPF.

02:33:53,160 --> 02:33:57,270
Netlink is not you know a statically formatted protocol.

02:33:57,270 --> 02:34:01,060
So it's it basically requires loops and that's not nice.

02:34:15,530 --> 02:34:17,887
- Okay, so next up we're going to talk about LKFT

02:34:17,887 --> 02:34:21,620
and LKFT short for Linux Kernel Functional Test.

02:34:22,860 --> 02:34:25,180
Emphasis on Linux.

02:34:25,180 --> 02:34:26,820
So there's sort of two aspects of this.

02:34:26,820 --> 02:34:30,100
So let's talk about LKFT as a system first.

02:34:31,374 --> 02:34:34,910
So what it is is a lab.

02:34:34,910 --> 02:34:36,480
You've got a number of test targets

02:34:36,480 --> 02:34:40,430
and a matter of fact, it can be a federated system.

02:34:40,430 --> 02:34:43,340
So it's one of those things where not all of the lab

02:34:43,340 --> 02:34:45,550
and hardware has to be on site in Linaro.

02:34:45,550 --> 02:34:47,630
It can be distributed all across companies

02:34:47,630 --> 02:34:49,670
just like kernel CI or anything like that.

02:34:51,306 --> 02:34:52,670
And it is coordinated such that

02:34:52,670 --> 02:34:54,550
you've got a build system with Jenkin,

02:34:54,550 --> 02:34:56,780
you have a dispatch system with LAVA,

02:34:56,780 --> 02:34:59,630
and so ultimately it's LAVA is working with the devices

02:34:59,630 --> 02:35:02,090
that are under test, so you get a new kernel that pops in

02:35:02,090 --> 02:35:03,850
through a branch, you have to build that,

02:35:03,850 --> 02:35:05,600
you have to push that out to the devices.

02:35:05,600 --> 02:35:08,530
You have to make sure that in the case of Android devices

02:35:08,530 --> 02:35:09,990
that you have user space,

02:35:09,990 --> 02:35:12,650
that then is paired with the device

02:35:12,650 --> 02:35:14,260
and then you have to push out

02:35:14,260 --> 02:35:15,810
what it is your charge ultimately going

02:35:15,810 --> 02:35:17,460
to be running on the device.

02:35:17,460 --> 02:35:19,560
So in the case of course Android,

02:35:19,560 --> 02:35:21,270
depending on what your user space is

02:35:21,270 --> 02:35:23,750
you might be running a different version of CTS and BTS

02:35:23,750 --> 02:35:26,360
and so you have to make sure you get all that right

02:35:26,360 --> 02:35:28,490
and then you end up with a whole bunch of data

02:35:28,490 --> 02:35:30,020
at the end that you've got to go

02:35:30,020 --> 02:35:33,940
and ultimately analyze or hopefully it's as simple

02:35:33,940 --> 02:35:35,310
as everything just passed.

02:35:35,310 --> 02:35:37,130
So no regressions, we move on.

02:35:37,130 --> 02:35:40,930
So in the case of Linux Kernel Functional Test,

02:35:40,930 --> 02:35:44,120
our main goal is as we're looking for regressions

02:35:44,120 --> 02:35:44,953
in the kernel.

02:35:46,281 --> 02:35:48,680
So as an LTS moves forward or as mainline goes forward,

02:35:48,680 --> 02:35:49,880
if we have something at breaks,

02:35:49,880 --> 02:35:52,190
we wanna catch it as early as possible,

02:35:52,190 --> 02:35:54,940
get the people involved that own that code

02:35:54,940 --> 02:35:58,030
and ultimately present them with either the problem

02:35:58,030 --> 02:35:59,900
or as much as a debug problem as possible

02:35:59,900 --> 02:36:01,890
or even better sometimes in case we can hand them

02:36:01,890 --> 02:36:04,350
a patch and say look, by the way here's

02:36:04,350 --> 02:36:07,390
how we've get you know managed to get bisected

02:36:07,390 --> 02:36:11,367
and this was what needs to happen.

02:36:14,500 --> 02:36:15,670
Now that we've been kind of doing this

02:36:15,670 --> 02:36:16,870
for about two years now,

02:36:18,730 --> 02:36:21,740
in the case of that just the Android tests only,

02:36:21,740 --> 02:36:26,740
we've run about 90 million test all total.

02:36:28,090 --> 02:36:30,930
However, this chart actually exposes

02:36:30,930 --> 02:36:33,630
an interesting piece of the dynamic of LKFT

02:36:33,630 --> 02:36:36,490
and that's there's two universes here.

02:36:36,490 --> 02:36:38,370
And that's why I was stressing

02:36:38,370 --> 02:36:40,860
Linux Kernel Functional Testing.

02:36:40,860 --> 02:36:45,860
Because when like Greg KH releases a new stable RC,

02:36:47,180 --> 02:36:48,610
what happens is is that kicks off

02:36:48,610 --> 02:36:51,620
a whole bunch of testing that occurs with Linux

02:36:51,620 --> 02:36:55,570
as the OS that's under test.

02:36:55,570 --> 02:36:58,930
And then ultimately what happens because Android common

02:36:58,930 --> 02:37:01,370
is a little bit behind LTS.

02:37:01,370 --> 02:37:04,130
is as then when those patches get landed

02:37:04,130 --> 02:37:06,120
and everything gets accepted in the released LTS,

02:37:06,120 --> 02:37:07,890
it makes it into Android common.

02:37:07,890 --> 02:37:10,090
And that's when the Android testing happens.

02:37:12,023 --> 02:37:15,050
So if you pull in the testing that Dan's team does

02:37:15,050 --> 02:37:17,540
for the Linux hosted stuff,

02:37:17,540 --> 02:37:20,060
that's another 60 million tests that have been run.

02:37:22,470 --> 02:37:24,270
So what I really want to stress here

02:37:24,270 --> 02:37:27,230
is that we kind of have these what this waterfall model

02:37:27,230 --> 02:37:30,620
where as things flow in through Linux nests

02:37:30,620 --> 02:37:32,810
they get merged, you ended up in mainline

02:37:32,810 --> 02:37:34,640
and then ultimately you have an LTS

02:37:34,640 --> 02:37:36,910
that gets released, then LTS goes through

02:37:36,910 --> 02:37:39,390
its own lifetime cycle and of course

02:37:39,390 --> 02:37:42,940
that's being followed very closely in android common.

02:37:42,940 --> 02:37:44,290
Then you end up within a soc tree,

02:37:44,290 --> 02:37:45,270
which ends up at a vendor,

02:37:45,270 --> 02:37:47,130
which then ultimately ends up in a phone.

02:37:47,130 --> 02:37:49,160
You know, this is a pretty long cycle.

02:37:50,170 --> 02:37:52,980
And something that we really really want to compress down

02:37:52,980 --> 02:37:53,840
as much as possible.

02:37:53,840 --> 02:37:56,920
Cause ultimately what I would love to be able to do

02:37:56,920 --> 02:37:59,680
is that when mainline releases something new

02:37:59,680 --> 02:38:02,110
or an LTS releases something new,

02:38:02,110 --> 02:38:06,320
that I can run Android on that kernel

02:38:06,320 --> 02:38:09,640
and report status to Greg or to Linus or anything like that

02:38:09,640 --> 02:38:11,220
when something regresses.

02:38:11,220 --> 02:38:14,880
And so Sumeet here is gonna have a something

02:38:14,880 --> 02:38:17,450
that he can at least hold up in the air

02:38:17,450 --> 02:38:19,020
and that is we've got a Poco F1

02:38:19,020 --> 02:38:21,060
that's booting Android with mainline.

02:38:21,060 --> 02:38:24,170
And so you know conceptually we want to do it

02:38:24,170 --> 02:38:25,490
with more devices.

02:38:25,490 --> 02:38:27,460
Because the thing is this is not just the Poco F1,

02:38:27,460 --> 02:38:29,189
it's also the Pixel X3 as well

02:38:29,189 --> 02:38:30,980
and then you can run CTS on that,

02:38:30,980 --> 02:38:32,290
you can run VTS on it.

02:38:32,290 --> 02:38:35,050
So now that 90 million amount of tests

02:38:35,050 --> 02:38:39,310
that we run can suddenly be you know something of value

02:38:39,310 --> 02:38:41,990
to the you know main Linux kernel community

02:38:41,990 --> 02:38:43,580
as opposed to well, you know

02:38:43,580 --> 02:38:45,320
you couldn't give us the feedback

02:38:45,320 --> 02:38:47,760
that something broke because we've already done our release.

02:38:47,760 --> 02:38:49,370
So that's really something

02:38:49,370 --> 02:38:51,950
that we're really trying to push

02:38:51,950 --> 02:38:54,080
and I think also something where

02:38:54,080 --> 02:38:55,850
there's major major props to be given

02:38:55,850 --> 02:38:57,860
to the Google kernel team in particular

02:38:57,860 --> 02:38:59,690
for getting their code upstream,

02:38:59,690 --> 02:39:03,237
so that we can boot devices with a mainline kernel.

02:39:05,410 --> 02:39:08,070
So don't read too much into the title of the slide

02:39:08,070 --> 02:39:09,970
cause I don't want to take something like anything away

02:39:09,970 --> 02:39:11,170
from boot testing in general.

02:39:11,170 --> 02:39:13,970
Boot testing is good, but that's not the only kind

02:39:13,970 --> 02:39:15,330
of testing that's important.

02:39:15,330 --> 02:39:17,020
This is where functional testing comes in

02:39:17,020 --> 02:39:18,890
and this is you know like for instance,

02:39:18,890 --> 02:39:21,199
we were just talking about eBPF.

02:39:21,199 --> 02:39:22,032
You know, as an example of

02:39:22,032 --> 02:39:23,800
it's a very complex thing to test.

02:39:23,800 --> 02:39:25,040
Well, ultimately if you want to test

02:39:25,040 --> 02:39:25,920
a very complex thing,

02:39:25,920 --> 02:39:28,380
you have a very complex test suite to run against it

02:39:28,380 --> 02:39:30,270
so that you can look for regressions.

02:39:30,270 --> 02:39:33,170
You know, in my wonderful world I would love to be able

02:39:33,170 --> 02:39:35,124
to find those kinds problems which is kinda why,

02:39:35,124 --> 02:39:37,381
I asked the question that I did.

02:39:37,381 --> 02:39:38,690
You know how do we make that kind of thing better

02:39:38,690 --> 02:39:41,490
so that we can have quicker feedback loops.

02:39:41,490 --> 02:39:43,674
So for us when we're testing Android.

02:39:43,674 --> 02:39:48,293
what we do is we do cross run VTS which has K self tests

02:39:48,293 --> 02:39:49,790
and LTP in it.

02:39:49,790 --> 02:39:52,620
On our case though what we'll do is we'll update LTP

02:39:53,480 --> 02:39:57,340
so that it's not what was really in the release version DTS

02:39:57,340 --> 02:40:00,350
We try to have the latest grades LTP on that

02:40:00,350 --> 02:40:02,650
which case I'm sending appear in the front row

02:40:04,047 --> 02:40:05,130
of getting you have major thanks for actually making

02:40:05,130 --> 02:40:06,840
that kind of thing possible.

02:40:06,840 --> 02:40:10,060
And then we also run CTS, but we just run a cut-down version

02:40:10,060 --> 02:40:12,700
of that which you know kind of pokes and prods

02:40:12,700 --> 02:40:14,220
and tickles various parts of the kernel

02:40:14,220 --> 02:40:16,320
so that it does interesting things like networking

02:40:16,320 --> 02:40:17,820
and you know a Bluetooth and camera

02:40:17,820 --> 02:40:19,320
and all those kinds of things.

02:40:19,320 --> 02:40:22,940
But moving beyond that, you know those are all tests

02:40:22,940 --> 02:40:24,630
where the they're all pass/fail.

02:40:24,630 --> 02:40:26,648
But there's other kinds of testing which is interesting too

02:40:26,648 --> 02:40:30,430
So we have boards in our lab that have energy probes on.

02:40:30,430 --> 02:40:32,264
So we're measuring watts and joules.

02:40:32,264 --> 02:40:35,790
And so, what we can do with the energyaware scheduler

02:40:35,790 --> 02:40:38,600
over time is as we can watch for trends

02:40:38,600 --> 02:40:40,820
and that is as patches are coming into LTS

02:40:41,720 --> 02:40:46,720
is your energy going up or is your energy usage going down.

02:40:47,150 --> 02:40:49,570
Obviously we all like to be using less energy especially

02:40:49,570 --> 02:40:50,880
any consumer device.

02:40:50,880 --> 02:40:54,860
So this gives us another way to detect a regression

02:40:54,860 --> 02:40:56,360
in the kernel, which isn't something

02:40:56,360 --> 02:40:57,540
that's necessarily functional.

02:40:57,540 --> 02:40:58,840
It's just a use of more energy,

02:40:58,840 --> 02:41:01,420
so we can go back to the EAS maintainer

02:41:01,420 --> 02:41:05,090
and say oh by the way, here's the patch that came in

02:41:05,090 --> 02:41:07,590
something happened you know you take it from here.

02:41:08,460 --> 02:41:10,810
But it isn't just, you know that's not the only thing

02:41:10,810 --> 02:41:12,291
that you can do.

02:41:12,291 --> 02:41:13,490
You could also take advantage of the chamelium board.

02:41:13,490 --> 02:41:15,680
And so this is something we've started to pull into our lab

02:41:15,680 --> 02:41:17,350
And so, what the chamelium board can do is

02:41:17,350 --> 02:41:19,130
it can capture video and sound.

02:41:19,130 --> 02:41:22,680
You know literally is able to act like an LCD panel.

02:41:22,680 --> 02:41:24,900
I guess it's kind of a good way of explaining to it

02:41:24,900 --> 02:41:26,180
so you can go in and you can probe

02:41:26,180 --> 02:41:28,770
and say okay it picks a lot of particular XY coordinate

02:41:28,770 --> 02:41:31,210
what value is it what you would expect.

02:41:31,210 --> 02:41:33,300
So if you're playing back video or a camera

02:41:33,300 --> 02:41:37,340
or anything like that you can very quickly start

02:41:37,340 --> 02:41:41,410
to validate v4l2 in ways that it hasn't been done before.

02:41:41,410 --> 02:41:44,700
You can do playback and with you know other test suites

02:41:44,700 --> 02:41:46,700
that you use professional video that kind of stuff

02:41:46,700 --> 02:41:48,950
and that's particularly exciting.

02:41:48,950 --> 02:41:50,620
Another test suite, I think is really interesting

02:41:50,620 --> 02:41:53,070
as synthmark which is something that Phil Burke

02:41:53,070 --> 02:41:54,850
is doing at Google.

02:41:54,850 --> 02:41:57,880
So this is all about, it's an audio,

02:41:57,880 --> 02:41:59,270
it's a virtualized environment.

02:41:59,270 --> 02:42:01,020
so it doesn't actually need the chamelium board,

02:42:01,020 --> 02:42:03,130
but it is testing workloads and seeing

02:42:03,130 --> 02:42:05,040
how efficient is sound and it's also looking

02:42:05,040 --> 02:42:06,430
for latency and things like that.

02:42:06,430 --> 02:42:08,060
So good stuff.

02:42:08,060 --> 02:42:10,240
So you know my impassioned plea here

02:42:10,240 --> 02:42:12,794
is that you know we shouldn't be just thinking

02:42:12,794 --> 02:42:14,230
of functional testing as pass/fail type stuff.

02:42:14,230 --> 02:42:17,960
It can and it should evolve into more complicated tests

02:42:17,960 --> 02:42:20,480
for one thing and it can be, we should be also be thinking

02:42:20,480 --> 02:42:22,220
and things like EAS as well,

02:42:22,220 --> 02:42:24,280
where you're not just looking at something

02:42:24,280 --> 02:42:26,174
that again it's a pass/fail,

02:42:26,174 --> 02:42:27,924
but it's you know watts and joules.

02:42:29,780 --> 02:42:30,860
How we doing for time?

02:42:31,922 --> 02:42:33,350
- So you have six minutes forty five.

02:42:33,350 --> 02:42:34,320
- Six minutes forty fives.

02:42:34,320 --> 02:42:35,770
Well, this is where I like to get into the questions

02:42:35,770 --> 02:42:38,340
because as I recall this should be my last slide.

02:42:39,360 --> 02:42:40,920
So I think one of the general questions

02:42:40,920 --> 02:42:43,200
I've got for the audience is is where else should

02:42:43,200 --> 02:42:46,640
we be putting time and effort into validating kernels

02:42:46,640 --> 02:42:49,370
as they're evolving through either LTS or with mainline.

02:42:49,370 --> 02:42:51,330
And back there.

02:42:56,530 --> 02:43:00,150
- Yeah, I'm wondering about the GPU.

02:43:00,150 --> 02:43:01,220
Why are you testing that?

02:43:01,220 --> 02:43:02,550
If you are.

02:43:02,550 --> 02:43:03,383
- With igt?

02:43:05,225 --> 02:43:06,870
- [Karim] Please stand up.

02:43:06,870 --> 02:43:08,620
- Yeah, with budgeted you could assume

02:43:08,620 --> 02:43:12,840
but I guess you want to run the ETP so the GLS2.

02:43:14,880 --> 02:43:16,420
- So at this point, we're not doing a lot

02:43:16,420 --> 02:43:18,270
with the graphics stack.

02:43:18,270 --> 02:43:21,130
Save what you know for what's in CTS.

02:43:21,130 --> 02:43:24,080
We've started to you know poke and prod on the an igt

02:43:24,080 --> 02:43:26,050
of course you know we're in the army universe primarily

02:43:26,050 --> 02:43:27,910
for all our advices and there's a lot of igt

02:43:27,910 --> 02:43:29,110
which is Intel specific.

02:43:30,820 --> 02:43:32,050
But you know this is an area,

02:43:32,050 --> 02:43:34,960
where we see that there could be a lot of improvement.

02:43:34,960 --> 02:43:38,140
We do see some you know,

02:43:38,140 --> 02:43:39,140
some things that we could do

02:43:39,140 --> 02:43:40,900
with the MS and DRM communities,

02:43:43,170 --> 02:43:45,660
that's just stuff that we've thought about,

02:43:45,660 --> 02:43:48,210
we haven't really taken any action on it as of yet.

02:44:07,650 --> 02:44:12,650
- Would you find useful tool that given to bug reports

02:44:12,880 --> 02:44:17,880
or message dumps or whatever that are bad in some way.

02:44:24,550 --> 02:44:28,970
I can identify the badness relative to the tube,

02:44:28,970 --> 02:44:32,780
to each other and point it out relative

02:44:32,780 --> 02:44:34,840
to a known good trace?

02:44:34,840 --> 02:44:35,673
- Yes.

02:44:36,691 --> 02:44:38,330
- Okay, it's a loaded, it's a point of question,

02:44:38,330 --> 02:44:41,980
because we have such a tool in-house at Google.

02:44:41,980 --> 02:44:44,490
We use it for bug reports, broad bug reports

02:44:44,490 --> 02:44:46,170
for all of Android.

02:44:46,170 --> 02:44:50,860
And we have this very painful need to answer

02:44:50,860 --> 02:44:52,310
the question, do you do the fragmentation

02:44:52,310 --> 02:44:53,710
that we're all dealing with?

02:44:54,760 --> 02:44:59,760
Hey there's a bug in this BSP by an SOC provider,

02:45:00,740 --> 02:45:02,440
does it also exists in AOSP?

02:45:02,440 --> 02:45:04,690
That is was it introduced by AOSP which acts

02:45:04,690 --> 02:45:08,730
as the upstream for all of android or downstream of it

02:45:08,730 --> 02:45:10,480
and so that might be useful for the kernel.

02:45:10,480 --> 02:45:11,313
We could talk.

02:45:11,313 --> 02:45:12,270
- That would be spectacular.

02:45:12,270 --> 02:45:13,930
Cause we save all of the logs,

02:45:13,930 --> 02:45:16,170
but we're not doing any sort of post-processing them

02:45:16,170 --> 02:45:17,003
after the fact,

02:45:17,003 --> 02:45:18,790
so yeah that would be something

02:45:18,790 --> 02:45:21,317
I think we could take advantage of.

02:45:26,642 --> 02:45:31,642
- So if you don't use all of the debugging tools,

02:45:31,880 --> 02:45:35,990
then that may be another's in a way for evolution

02:45:35,990 --> 02:45:37,830
because lots of testing efforts,

02:45:37,830 --> 02:45:41,970
do they run tests but the tests actually corrupt memory,

02:45:41,970 --> 02:45:44,483
leak memory, dead lock and that's all considered

02:45:44,483 --> 02:45:46,340
as good and passing.

02:45:48,190 --> 02:45:50,410
- Yeah and there there are those kinds of tests

02:45:50,410 --> 02:45:51,960
where they'll crash the kernel.

02:45:53,072 --> 02:45:54,760
And our environment can recover from that

02:45:54,760 --> 02:45:56,870
and you know go on to the next test and things like that.

02:45:56,870 --> 02:45:59,130
So that's you know, if there are more

02:45:59,130 --> 02:46:02,753
of those kinds of tests, we would you know

02:46:02,753 --> 02:46:05,620
and they're not integrated with like LTP,

02:46:05,620 --> 02:46:07,710
that's a great place to put them.

02:46:07,710 --> 02:46:08,870
Impossible or--

02:46:08,870 --> 02:46:10,797
- I mean that can we have the bugging tools like --

02:46:10,797 --> 02:46:12,339
(overlapping discussion)

02:46:12,339 --> 02:46:15,710
- MMleak, fold injection and you know--

02:46:15,710 --> 02:46:17,710
- That's a really good class of stuff.

02:46:17,710 --> 02:46:20,260
And so like right now we're not taking advantage of that.

02:46:20,260 --> 02:46:23,344
So like you know, go ahead.

02:46:23,344 --> 02:46:26,510
- Then you're missing lots and lots of bugs

02:46:26,510 --> 02:46:30,150
and in particular security bugs and stability bugs.

02:46:32,800 --> 02:46:34,990
- I'm going to ask Dimitri's follow-up questions.

02:46:34,990 --> 02:46:36,690
So how does he get you to do that?

02:46:39,765 --> 02:46:42,080
- So in many ways, I think if we were to start

02:46:42,080 --> 02:46:43,850
to do that what we have to do is

02:46:43,850 --> 02:46:47,010
we have to change our approach of how we config the system

02:46:47,870 --> 02:46:49,670
and how we build the system as well.

02:46:51,528 --> 02:46:53,060
And you know clearly we need to think about

02:46:53,060 --> 02:46:55,260
how to do that in an effective way.

02:46:56,150 --> 02:46:57,680
Cause that will explode the number of builds

02:46:57,680 --> 02:46:59,790
that we would have and that would also explode

02:46:59,790 --> 02:47:02,440
the number of tests that we would have to be running.

02:47:03,350 --> 02:47:05,910
But you know, this is all supposed

02:47:05,910 --> 02:47:07,070
to be testing at scale anyway.

02:47:07,070 --> 02:47:09,460
So adding more capacity to be able to do it.

02:47:09,460 --> 02:47:10,760
I think is something that's good.

02:47:10,760 --> 02:47:12,850
So very good suggestion.

02:47:12,850 --> 02:47:13,990
- I had one more question.

02:47:13,990 --> 02:47:17,920
If somebody had a test or test framework solution for you

02:47:17,920 --> 02:47:19,010
how do they contact?

02:47:21,680 --> 02:47:24,810
- So I think probably the simplest thing to do is email me.

02:47:24,810 --> 02:47:26,973
So that's tom.goal@linaro.org

02:47:26,973 --> 02:47:29,520
or get ahold of me after the session

02:47:29,520 --> 02:47:31,170
or actually Dan's another great person

02:47:31,170 --> 02:47:33,050
to get a hold of as well.

02:47:33,050 --> 02:47:35,640
You know, so in you know the case where you know

02:47:35,640 --> 02:47:37,270
I care more about Android,

02:47:37,270 --> 02:47:39,200
Dan cares more about Linux,

02:47:39,200 --> 02:47:40,760
but you know we wanted to make sure that

02:47:40,760 --> 02:47:43,070
we cover all the possibilities.

02:47:43,070 --> 02:47:45,840
- Are your email emails in the slide deck

02:47:45,840 --> 02:47:47,240
so that I can discover them.

02:47:48,253 --> 02:47:49,720
- I did not add them.

02:47:49,720 --> 02:47:50,931
I will do that.

02:47:50,931 --> 02:47:52,362
- When it's posted they'll be there.

02:47:52,362 --> 02:47:55,260
- I'm gonna ensure that we do that.

02:47:55,260 --> 02:47:58,544
- And I think the debug tools is in your backlog, right?

02:47:58,544 --> 02:48:00,570
- It is, yeah.

02:48:00,570 --> 02:48:02,810
- so it's not like they've been ignoring that case,

02:48:02,810 --> 02:48:04,560
it's in the backlog and it's in plan

02:48:04,560 --> 02:48:05,960
it just hasn't happened yet.

02:48:06,850 --> 02:48:11,020
- It's wrong in the notes.

02:48:11,907 --> 02:48:14,193
- G-A-L-L. - G-A-L-L.

02:48:14,193 --> 02:48:15,799
- Yeah sorry.

02:48:15,799 --> 02:48:17,340
- [Dan] Good eyes.

02:48:17,340 --> 02:48:18,901
- Not, obvious spelling.

02:48:18,901 --> 02:48:20,348
(laughs)

02:48:20,348 --> 02:48:22,398
- [Rob] I was hoping I could see frankly.

02:48:23,700 --> 02:48:24,533
- Way to go Rob.

02:48:27,961 --> 02:48:28,870
All right, anything else?

02:48:32,820 --> 02:48:34,170
All right, thanks everyone.

02:48:35,117 --> 02:48:38,284
(audience applauding)

02:48:48,430 --> 02:48:50,780
- Hi everyone, my name is Saran Bagdasarian.

02:48:50,780 --> 02:48:53,070
I work in Android systems team.

02:48:53,070 --> 02:48:55,010
I'll present some of the ideas

02:48:55,010 --> 02:48:59,060
we are working on to better handle memory pressure

02:48:59,060 --> 02:49:00,350
on Android systems.

02:49:05,528 --> 02:49:06,710
So what's wrong with this picture

02:49:06,710 --> 02:49:09,109
is this orange part basically

02:49:09,109 --> 02:49:13,320
which represents the RSS of the cached applications.

02:49:14,200 --> 02:49:15,990
And as you can see a lot of memory

02:49:15,990 --> 02:49:18,040
is used by cached applications

02:49:18,040 --> 02:49:20,620
which is basically mostly idle.

02:49:22,170 --> 02:49:25,220
And so we want to find ways to use

02:49:25,220 --> 02:49:28,130
that memory more useful.

02:49:31,663 --> 02:49:35,820
So to use that for foreground or more important applications

02:49:35,820 --> 02:49:37,980
while not killing the background ones

02:49:37,980 --> 02:49:39,600
which are using and basically

02:49:40,539 --> 02:49:43,710
which owns that memory but however it's being idle.

02:49:45,170 --> 02:49:49,290
So the solution is practically reclaim that memory

02:49:49,290 --> 02:49:52,840
which is not being used and we know is

02:49:52,840 --> 02:49:55,850
that it's not going to be used for in the near future.

02:49:55,850 --> 02:49:57,360
And that's can be done by,

02:49:58,620 --> 02:50:03,390
what we do is basically we implement process.madvsed syscall

02:50:04,540 --> 02:50:06,100
It's working progress.

02:50:08,380 --> 02:50:12,510
We also add to advice options which are already

02:50:12,510 --> 02:50:17,310
in the MM3 they are Madvised_COLD and Madvised_PAGEOUT.

02:50:19,000 --> 02:50:22,150
And I'll explain more in details what they are doing.

02:50:23,330 --> 02:50:27,920
As a result we are getting 15% less kills

02:50:27,920 --> 02:50:29,640
on dogfood population.

02:50:29,640 --> 02:50:33,790
Basically running this with real with internal users

02:50:33,790 --> 02:50:38,040
and 30% less kills on stress tests.

02:50:38,040 --> 02:50:43,040
And we don't get big penalty on basically restarting

02:50:43,100 --> 02:50:45,600
or unpacking the compacted applications

02:50:45,600 --> 02:50:47,360
because we are using CRM

02:50:47,360 --> 02:50:50,110
and it's much faster than restarting the application

02:50:51,470 --> 02:50:52,320
from the scratch.

02:50:54,641 --> 02:50:57,080
So more details on process_madvise.

02:50:57,080 --> 02:50:59,370
It's a syscall basically which allows us

02:50:59,370 --> 02:51:03,964
to give a memory advice to about the vmas

02:51:03,964 --> 02:51:07,880
of different process.

02:51:07,880 --> 02:51:11,400
And the idea is system management's software

02:51:11,400 --> 02:51:15,600
can gives us which knows that a particular process

02:51:15,600 --> 02:51:16,690
went in the background,

02:51:16,690 --> 02:51:18,120
it has been there for a while

02:51:18,120 --> 02:51:19,870
and we have a pretty good idea

02:51:19,870 --> 02:51:23,410
that it's not going to be reused any time soon.

02:51:23,410 --> 02:51:26,870
We can tell kernel, we can hint kernel,

02:51:26,870 --> 02:51:31,430
that pages for this process can be reclaimed

02:51:31,430 --> 02:51:34,690
and we use madvise code to deactivate pages

02:51:34,690 --> 02:51:37,780
and in our case we use that for file back pages

02:51:37,780 --> 02:51:40,240
because as a result of the experimenting

02:51:40,240 --> 02:51:43,380
we found out that if we reclaim file back pages

02:51:43,380 --> 02:51:46,530
and if we made a mistake and we have to bring them back,

02:51:46,530 --> 02:51:48,580
it's the cost is too steep.

02:51:48,580 --> 02:51:49,830
So instead of reclaiming them,

02:51:49,830 --> 02:51:51,470
we are deactivating them so that

02:51:51,470 --> 02:51:54,580
they can be reclaimed faster in case memory pressure happens

02:51:54,580 --> 02:51:59,580
And Madvise_pageout is another advice

02:52:00,170 --> 02:52:02,390
which reclaims the pages.

02:52:02,390 --> 02:52:06,007
And we use that for anonymous pages to swap them out.

02:52:10,120 --> 02:52:13,530
So that's about the first idea of compacting applications.

02:52:13,530 --> 02:52:16,970
The second idea I want to present this improvements

02:52:16,970 --> 02:52:18,550
through lmkd kill strategy.

02:52:19,670 --> 02:52:24,390
The previous one was looking only at free memory levels

02:52:24,390 --> 02:52:29,390
and also at file back page cache size.

02:52:30,010 --> 02:52:32,470
And I'm working on the new strategy

02:52:32,470 --> 02:52:34,590
which also looks at zone watermark,

02:52:34,590 --> 02:52:39,180
breeches swap utilization, working search results

02:52:39,180 --> 02:52:43,320
to identify fall back page cast thrashing.

02:52:44,490 --> 02:52:47,330
And advantage is the new kill strategy works well

02:52:47,330 --> 02:52:48,750
for both kind of devices.

02:52:48,750 --> 02:52:50,720
High performance and low memory devices

02:52:50,720 --> 02:52:53,130
which was not the case with the old strategy.

02:52:53,130 --> 02:52:56,790
We had two different strategies to kill on those devices.

02:52:58,080 --> 02:53:00,260
We also get decreased number of tunables.

02:53:01,361 --> 02:53:06,361
So it's easier to tune and we also get favorable results.

02:53:06,810 --> 02:53:10,520
So on high-end devices we get 25% less kills

02:53:10,520 --> 02:53:13,310
with 15% up launch time improvements,

02:53:13,310 --> 02:53:17,910
because we get less cold starts as a result of less kills.

02:53:17,910 --> 02:53:21,380
And on low-end on low memory devices

02:53:21,380 --> 02:53:24,840
we get the only case when we get regression of five

02:53:24,840 --> 02:53:28,990
to 6% is on very large working set sizes

02:53:28,990 --> 02:53:32,180
where basically previous strategy

02:53:32,180 --> 02:53:34,680
which was basically killed, whenever you see

02:53:34,680 --> 02:53:38,100
a hint of memory pressure works better

02:53:38,100 --> 02:53:41,470
because working set size is so big,

02:53:41,470 --> 02:53:42,780
that you have to kill anyway.

02:53:42,780 --> 02:53:46,620
So basically a dumb decision to kill as soon as possible

02:53:46,620 --> 02:53:48,480
is winning in that case.

02:53:49,600 --> 02:53:51,630
And we're looking at additional heuristics

02:53:51,630 --> 02:53:53,450
to identify those cases where

02:53:53,450 --> 02:53:56,110
we can make that decision faster.

02:53:56,110 --> 02:53:58,630
So basically we're working said is too too big

02:53:58,630 --> 02:53:59,830
as their limited working set

02:53:59,830 --> 02:54:04,830
by killing preemptively or killing faster basically

02:54:05,530 --> 02:54:06,910
or deciding to kill faster.

02:54:08,930 --> 02:54:11,000
As also the new tunables.

02:54:11,000 --> 02:54:15,980
It's basically the thresholds for psi stall for partial

02:54:15,980 --> 02:54:18,040
and complete psi stalls.

02:54:18,040 --> 02:54:20,380
Thresholds for every swap levels

02:54:20,380 --> 02:54:25,380
and thresholds for thrashing and thrashing decay.

02:54:29,230 --> 02:54:31,120
Alright and the last idea,

02:54:31,120 --> 02:54:35,910
I want to present is tracking processes using pidfds.

02:54:35,910 --> 02:54:38,450
Pidfds are the new features that was introduced

02:54:38,450 --> 02:54:39,800
in latest kernels.

02:54:39,800 --> 02:54:44,800
And the problem we are tackling here is the PID reuse.

02:54:45,220 --> 02:54:50,220
So occasionally, pretty rare we observe on Android systems

02:54:51,500 --> 02:54:54,720
that pids gets gets reused.

02:54:54,720 --> 02:54:59,720
So the scenario is process gets registered with lmkd

02:55:01,320 --> 02:55:03,739
using its PID, then it crashes for some reason

02:55:03,739 --> 02:55:08,362
and lmkd it doesn't have any clue about the fact

02:55:08,362 --> 02:55:10,300
that this process crashed.

02:55:10,300 --> 02:55:13,830
Then after a while, system can reuse that PID

02:55:13,830 --> 02:55:16,240
if there's an overflow of key pids basically.

02:55:16,240 --> 02:55:18,580
It reduces the PID for a different process

02:55:18,580 --> 02:55:21,500
and then memory pressure happens,

02:55:21,500 --> 02:55:24,830
LMKD tries to kill that PID and it kills the wrong process;

02:55:24,830 --> 02:55:27,720
the new one thinking that its original one.

02:55:27,720 --> 02:55:31,320
And that new one new process might be a very important one.

02:55:31,320 --> 02:55:34,710
So even though it's a very rare occasion,

02:55:34,710 --> 02:55:38,360
it can be devastating for the user experience.

02:55:38,360 --> 02:55:40,920
Something very important might crash.

02:55:40,920 --> 02:55:44,850
So the solution to this problem is using the pidfds.

02:55:44,850 --> 02:55:48,120
And the trick is basically pidfds don't get reused

02:55:48,120 --> 02:55:51,640
until all the users close that file descriptor.

02:55:51,640 --> 02:55:56,110
So if lmkd opens file descriptor to a process,

02:55:56,110 --> 02:55:58,331
then it's not going to be reused until

02:55:58,331 --> 02:56:00,980
basically lmkd closes it.

02:56:04,300 --> 02:56:08,160
That was the three main ideas I wanted to present.

02:56:09,150 --> 02:56:11,150
All of them are work in progress.

02:56:12,561 --> 02:56:14,360
The application compaction partially

02:56:14,360 --> 02:56:17,980
is already in the MM tree, partially we are still,

02:56:19,420 --> 02:56:22,310
we didn't upstream the process-madvised syscall yet.

02:56:24,230 --> 02:56:27,610
The other two are purely user space changes.

02:56:27,610 --> 02:56:30,630
All the kernel space changes are already upstream.

02:56:31,817 --> 02:56:33,367
So those are also under review.

02:56:35,130 --> 02:56:35,963
Questions?

02:56:42,630 --> 02:56:47,220
- Bit of the, isn't it easier to connect debugger d2lmkd

02:56:48,908 --> 02:56:51,490
because the have already knows when that process dies

02:56:51,490 --> 02:56:54,040
and it can tell LMKD that this happened?

02:56:55,680 --> 02:56:59,380
You can address that issue on legacy devices this way too

02:56:59,380 --> 02:57:02,470
because that's been the case for many years.

02:57:02,470 --> 02:57:04,310
And pidfd probably a better way to fix it,

02:57:04,310 --> 02:57:07,990
but you have a backstop way to do that too.

02:57:07,990 --> 02:57:11,740
- Yeah, it's a medication for kind of devices

02:57:11,740 --> 02:57:14,310
which which don't have Pidfd support.

02:57:16,770 --> 02:57:18,500
It can be done.

02:57:18,500 --> 02:57:19,530
It's a patch basically,

02:57:19,530 --> 02:57:22,550
but going forward we want a real solution

02:57:22,550 --> 02:57:23,980
where with the kernel support

02:57:23,980 --> 02:57:26,870
and that's by our basic work on on that.

02:57:26,870 --> 02:57:31,700
But yeah, we can look into also additional support

02:57:31,700 --> 02:57:32,820
for legacy devices.

02:57:35,140 --> 02:57:36,320
- Do you know how many times

02:57:36,320 --> 02:57:38,790
the pid reuse actually was observed?

02:57:41,214 --> 02:57:44,670
- Well, I can tell about my experience.

02:57:44,670 --> 02:57:48,450
I've got like one bug in two or three months

02:57:49,480 --> 02:57:54,010
which after and it's very painful to debug that problem

02:57:54,010 --> 02:57:57,210
because process gets killed,

02:57:57,210 --> 02:58:01,030
that process had a score which should have never been killed

02:58:03,332 --> 02:58:04,320
and yet it still gets killed.

02:58:04,320 --> 02:58:07,000
And it's very difficult to prove that this is actually

02:58:07,000 --> 02:58:11,710
is a reason because PID reuse happens after a very long time

02:58:11,710 --> 02:58:14,150
so you don't get those traces or logs.

02:58:15,349 --> 02:58:18,432
(man speaks off mic)

02:58:21,980 --> 02:58:22,813
- Sorry?

02:58:27,990 --> 02:58:29,930
- That's why the backstop is useful for you

02:58:29,930 --> 02:58:32,330
because it can validate your hypothesis.

02:58:32,330 --> 02:58:35,080
and you'll stop getting these annoying bug reports

02:58:35,080 --> 02:58:36,370
or bugs assigned to you.

02:58:36,370 --> 02:58:39,100
- Yeah, well we validated that by adding

02:58:39,100 --> 02:58:42,890
some of the additional checks for this case basically

02:58:42,890 --> 02:58:44,660
but they are not the real solutions.

02:58:44,660 --> 02:58:48,260
The real solution is actually being able to track that.

02:58:53,352 --> 02:58:55,450
- [Karim] Please just stand up.

02:58:55,450 --> 02:58:56,940
- Slightly unrelated question have you

02:58:56,940 --> 02:58:58,890
ever considered using low-memory killer

02:59:00,848 --> 02:59:02,440
to basically reclaim graphic buffers

02:59:02,440 --> 02:59:04,480
like ion, Ashman, DMA-BUF.

02:59:04,480 --> 02:59:07,610
- Yeah, we are, actually Sandeep is working

02:59:07,610 --> 02:59:12,610
on standardizing the Ion, as soon as we have

02:59:13,580 --> 02:59:17,410
a standard way to look at the Ion usage,

02:59:17,410 --> 02:59:22,140
we definitely are going to use that knowledge in lmkd

02:59:22,140 --> 02:59:26,080
because a lot of memory and it's a big share of memory

02:59:26,080 --> 02:59:28,390
being used by applications in ion

02:59:28,390 --> 02:59:31,190
and we we don't have a clear way right now

02:59:31,190 --> 02:59:34,770
to specific to point out which application is using it.

02:59:36,450 --> 02:59:37,690
- I think you could also partially

02:59:37,690 --> 02:59:40,040
do that through gralloc, we're gonna start tracking

02:59:40,040 --> 02:59:41,750
who allocated the buffer

02:59:41,750 --> 02:59:43,870
and who has references on the buffer,

02:59:43,870 --> 02:59:46,950
CTL identify the foreground process, has it?

02:59:46,950 --> 02:59:50,330
Yeah, but it'd be really nice to have this because right now

02:59:50,330 --> 02:59:53,830
a napkin crash Android any app just by allocating buffers

02:59:53,830 --> 02:59:54,930
to the device crashes.

02:59:57,150 --> 02:59:59,670
- That's definitely something we are going to look into.

03:00:01,227 --> 03:00:03,900
- That becomes relevant for ion

03:00:03,900 --> 03:00:06,370
and also I guess what so myths can talk

03:00:06,370 --> 03:00:07,760
in the DNA above description as well.

03:00:07,760 --> 03:00:09,860
Cause we need that tracking all the memory

03:00:09,860 --> 03:00:12,750
and all the(mumbles)

03:00:17,400 --> 03:00:18,450
- Any more questions?

03:00:32,410 --> 03:00:34,320
- [Man] When are we gonna fix the ion issue?

03:00:37,570 --> 03:00:38,403
- Never.

03:00:44,060 --> 03:00:46,678
- All right, thank you very much.

03:00:46,678 --> 03:00:49,845
(audience applauding)

03:00:52,860 --> 03:00:53,850
- Okay, next we have Sameat,

03:00:53,850 --> 03:00:55,860
we're just gonna wait till 6:00 to start

03:00:55,860 --> 03:00:57,703
just in case some people come in.

03:02:43,724 --> 03:02:44,780
So Arnold there, he was very explicit

03:02:44,780 --> 03:02:45,613
about the instructions.

03:02:45,613 --> 03:02:47,010
You need to hold up like that.

03:02:47,880 --> 03:02:52,190
Not like that, like that, not too close, this way.

03:02:52,190 --> 03:02:56,260
One, two, one, two, one like this.

03:02:57,450 --> 03:02:59,490
One two, we're good?

03:02:59,490 --> 03:03:00,880
All right.

03:03:00,880 --> 03:03:02,050
If you have to?

03:03:20,408 --> 03:03:22,003
- Are you counting seconds?

03:03:22,003 --> 03:03:23,770
(speaks off microphone)

03:03:23,770 --> 03:03:24,603
Okay, thank you.

03:03:26,080 --> 03:03:29,800
So I'm just filling in for John who couldn't be here.

03:03:29,800 --> 03:03:33,100
This talk is basically going to be about our recent efforts

03:03:33,100 --> 03:03:36,990
around ion upstreaming that Linaro

03:03:36,990 --> 03:03:41,990
has been doing with Alistair Davis I think from TI.

03:03:44,680 --> 03:03:46,730
And a few others.

03:03:46,730 --> 03:03:50,990
First off, I think I just like to thank Laura

03:03:50,990 --> 03:03:53,338
because she's been coming up here,

03:03:53,338 --> 03:03:56,010
I think for past six years or so.

03:03:56,010 --> 03:03:58,013
And we've been talking about

03:03:58,013 --> 03:03:58,970
how can we do the Ion destaging.

03:03:58,970 --> 03:04:00,810
She's done a lot of good work and maintenance,

03:04:00,810 --> 03:04:01,760
so thank you Laura.

03:04:06,146 --> 03:04:07,710
So there are a few issues with ION.

03:04:07,710 --> 03:04:11,510
I guess the probably the kind of issues

03:04:11,510 --> 03:04:13,710
yeah, Sandeep you can just kill me later on.

03:04:14,905 --> 03:04:17,830
So the kind of issues that have been there were around.

03:04:17,830 --> 03:04:19,640
Its it's been trying to do too many things

03:04:19,640 --> 03:04:22,710
in one interface or constraint solving,

03:04:22,710 --> 03:04:27,710
trying to do cash handling that was also tried

03:04:28,710 --> 03:04:31,560
to be enforced on vendors, so they couldn't get it wrong.

03:04:32,410 --> 03:04:37,230
It had a few it tried to provide a flexible interface

03:04:37,230 --> 03:04:42,230
for vendors, but it was like really poorly defined interface

03:04:43,820 --> 03:04:44,720
for custome flags.

03:04:45,837 --> 03:04:48,030
It also tried to, so because of that vendors

03:04:48,030 --> 03:04:52,430
actually hacked shared caching logic in common code

03:04:52,430 --> 03:04:57,320
and that made it very hard to have single source

03:04:57,320 --> 03:05:02,320
with multiple different heaps in them, vendor heaps.

03:05:02,680 --> 03:05:07,380
So as part of ion of streaming efforts,

03:05:07,380 --> 03:05:09,820
DM API correctness was done,

03:05:09,820 --> 03:05:11,900
but it's sort of hard performance

03:05:11,900 --> 03:05:15,870
and that just meant that lot of vendors

03:05:15,870 --> 03:05:18,810
actually diverted the changes that were made by Laura

03:05:18,810 --> 03:05:23,810
and we have many users we're 4.9 ion

03:05:23,860 --> 03:05:25,530
is used with 414+ kernels.

03:05:26,520 --> 03:05:30,390
So to try and so, what we try to do

03:05:30,390 --> 03:05:33,190
was to just focus on one feature from ion

03:05:33,190 --> 03:05:35,576
which is basically standardizing

03:05:35,576 --> 03:05:36,910
the user land allocation interface

03:05:36,910 --> 03:05:38,510
for different types of memories.

03:05:39,730 --> 03:05:42,650
The good thing is that each heap driver

03:05:42,650 --> 03:05:45,110
has its own chardev.

03:05:45,110 --> 03:05:47,880
And so, there is one allocation

03:05:47,880 --> 03:05:51,840
and then enumeration is based on heap names.

03:05:53,690 --> 03:05:56,960
Because each driver is its own DMF exporter,

03:05:56,960 --> 03:06:00,690
there's no need to modify the code part of the custom heaps.

03:06:00,690 --> 03:06:02,500
Cache maintenance and everything else is left

03:06:02,500 --> 03:06:06,370
to the heap driver which is its own DMA-BUF exporter.

03:06:07,850 --> 03:06:09,810
We have tried to provide some helper functions

03:06:09,810 --> 03:06:13,150
that allow avoiding duplication

03:06:13,150 --> 03:06:16,390
while providing some flexibility for the users.

03:06:17,890 --> 03:06:19,460
We're definitely not planning to solve

03:06:19,460 --> 03:06:23,146
every crazy use case that can come in for example,

03:06:23,146 --> 03:06:25,280
we know that there are

03:06:25,280 --> 03:06:27,470
some dynamic security pimp fermentations

03:06:27,470 --> 03:06:30,950
that need userland to pass magic cookies

03:06:30,950 --> 03:06:33,600
to specify which dynamic security domain

03:06:33,600 --> 03:06:36,070
that you're trying to allocate from and so on.

03:06:36,070 --> 03:06:39,260
So we definitely not going to try to attempt that.

03:06:40,240 --> 03:06:43,650
You can still write your own DMA-BUF exporter driver

03:06:43,650 --> 03:06:48,650
or a custom heap and vendors the request is that once

03:06:49,774 --> 03:06:52,890
this is upstream, I mean you should just move

03:06:52,890 --> 03:06:54,530
to run code to this.

03:06:57,820 --> 03:06:59,130
So this is all John.

03:07:01,460 --> 03:07:04,250
As part of DMA-BUF upstream,

03:07:04,250 --> 03:07:06,760
heap upstream effort, we have also provided

03:07:06,760 --> 03:07:09,670
two example heaps that are the system and the CMA.

03:07:09,670 --> 03:07:13,430
So while while posting those for review

03:07:13,430 --> 03:07:16,260
actually Christoph Helph gave a good amount

03:07:16,260 --> 03:07:18,590
of feedback around these.

03:07:18,590 --> 03:07:21,950
It's basically, he had concerns around allowing CPU mapping

03:07:21,950 --> 03:07:26,420
that came up a map to exist in parallel with device mappings

03:07:26,420 --> 03:07:29,200
and his concern was that they were easy to misuse

03:07:29,200 --> 03:07:31,470
and could provide inconsistent data.

03:07:31,470 --> 03:07:34,190
But actually the feedback doesn't seem

03:07:34,190 --> 03:07:36,250
to be around the heaps interface themselves,

03:07:36,250 --> 03:07:39,730
but around the system in system heap exporters.

03:07:39,730 --> 03:07:41,970
Basically, trying to establish what are the rules

03:07:41,970 --> 03:07:46,780
of the DMA-BUF APIs using these allocated DMA-BUF.

03:07:46,780 --> 03:07:48,610
So it looks like a reasonable concern.

03:07:48,610 --> 03:07:51,510
I mean this, can be dangerous,

03:07:51,510 --> 03:07:55,070
should be allow people to have these foodguns.

03:07:56,290 --> 03:07:57,990
But on the graphics side

03:07:58,930 --> 03:08:01,190
and I had to write down the name of the movie

03:08:01,190 --> 03:08:03,150
it's from a movie called Planet Terror.

03:08:05,683 --> 03:08:07,720
And people just get probably they saw the movie

03:08:07,720 --> 03:08:11,120
and they got pretty excited about what they can do.

03:08:11,120 --> 03:08:15,450
And so graphics needs flexible solutions of course

03:08:15,450 --> 03:08:19,340
and then there is an absolute need for performance solutions

03:08:20,962 --> 03:08:24,510
So what happens it's more like let me have my performance

03:08:24,510 --> 03:08:26,710
and I'll take care of the side effects

03:08:26,710 --> 03:08:28,890
or what I mean things don't go wrong,

03:08:28,890 --> 03:08:31,610
whereas the for the other users of API,

03:08:31,610 --> 03:08:36,170
the answer is probably, if they do bad things

03:08:36,170 --> 03:08:37,220
they get bad results.

03:08:39,866 --> 03:08:42,590
So it's a valid concern of trying

03:08:44,660 --> 03:08:48,320
I mean how do we enforce things around these.

03:08:51,722 --> 03:08:55,340
So I think we need to raise the concern

03:08:55,340 --> 03:08:58,480
for something that we at least need to document better.

03:09:00,510 --> 03:09:02,554
So I think Daniel is here, yes.

03:09:02,554 --> 03:09:07,280
When we when we designed the initial DMA-BUF API

03:09:07,280 --> 03:09:09,820
and the documentation that we did it,

03:09:09,820 --> 03:09:11,900
had a really cool possibility

03:09:11,900 --> 03:09:16,822
that you could have the delayed allocation possible.

03:09:16,822 --> 03:09:20,780
So potentially you could do constraint solving

03:09:20,780 --> 03:09:22,620
after allowing different devices to attach

03:09:22,620 --> 03:09:24,980
and then do a location based on the first map,

03:09:26,010 --> 03:09:30,570
but it's remained like an elusive implementation.

03:09:30,570 --> 03:09:35,540
We don't have any upstream drivers that implement that.

03:09:35,540 --> 03:09:37,390
On the other hand because the feature is available,

03:09:37,390 --> 03:09:38,960
there are a lot of people that think

03:09:38,960 --> 03:09:42,170
it's an actual feature and it's available for people to use.

03:09:42,170 --> 03:09:45,410
So that's something we probably need to get sorted.

03:09:49,090 --> 03:09:51,730
Then, the there is some confusion

03:09:51,730 --> 03:09:53,370
also around the usage barrier.

03:09:53,370 --> 03:09:56,870
So the CPU begin an end access device map

03:09:56,870 --> 03:09:59,813
and map are thought of as exclusive usage barriers,

03:09:59,813 --> 03:10:04,813
but the core framework doesn't actually do it.

03:10:07,180 --> 03:10:09,810
It's left for the exporters to handle.

03:10:09,810 --> 03:10:13,870
So probably the question is how should we either document

03:10:13,870 --> 03:10:18,070
or enforce the usage barriers around.

03:10:18,070 --> 03:10:22,270
With the advent of the implicit fences,

03:10:22,270 --> 03:10:25,770
the rules seem to have been loosened a little bit.

03:10:25,770 --> 03:10:29,320
So now it's probably the bracketing is around CPU begin,

03:10:29,320 --> 03:10:31,170
end access and fence wait and signal.

03:10:32,730 --> 03:10:34,690
Then also we do need to talk about.

03:10:36,130 --> 03:10:38,760
Explicit signaling makes it feel

03:10:38,760 --> 03:10:41,460
like implicit ownership signal rules

03:10:41,460 --> 03:10:43,010
might have lost their meaning.

03:10:43,010 --> 03:10:46,350
So nothing seems to enforce the correctness

03:10:46,350 --> 03:10:50,740
with implicit methods when it comes to cache management.

03:10:52,910 --> 03:10:55,310
So probably the question here is,

03:10:56,840 --> 03:10:59,760
do we I mean, there are use cases that exist

03:10:59,760 --> 03:11:02,160
where multiple device maps are used in parallel

03:11:02,160 --> 03:11:04,180
and then there's manual cache cleaning

03:11:04,180 --> 03:11:06,710
and signaling that happens with fences.

03:11:06,710 --> 03:11:09,140
So probably one question is do we want

03:11:09,140 --> 03:11:12,290
to enforce exclusion between vmap,mmap, Kmap

03:11:12,290 --> 03:11:16,970
and map_for_device or if yes, then there is a concern

03:11:16,970 --> 03:11:19,110
that GL has some use cases where one buffer

03:11:19,110 --> 03:11:22,440
can be accessed at the same time by device and CPU carefully

03:11:24,810 --> 03:11:26,390
So that's another.

03:11:26,390 --> 03:11:28,680
So I think one topic for discussion

03:11:28,680 --> 03:11:31,560
is how do we really sanely address Christoph's feedback.

03:11:31,560 --> 03:11:34,230
I mean without limiting some of these usage models

03:11:34,230 --> 03:11:39,230
how do you enforce these usage barriers.

03:11:39,460 --> 03:11:42,110
I guess some rules would help.

03:11:42,110 --> 03:11:44,250
So I'll probably go to the next slide

03:11:44,250 --> 03:11:45,400
because without those rules

03:11:45,400 --> 03:11:48,000
I think the optimizations will become limited due

03:11:48,000 --> 03:11:50,890
to lack of ability to assert correctness.

03:11:55,220 --> 03:11:59,550
Around the CMO, so the idea is trying to reduce overhead

03:11:59,550 --> 03:12:02,790
of DMA map and map_SG on every device map and map.

03:12:03,660 --> 03:12:06,220
So cache flushing overhead of the DMA_map_sg

03:12:06,220 --> 03:12:08,560
is significant I mean if you do map_and_map,

03:12:08,560 --> 03:12:12,850
every device, every frame, it's just not going to hold up.

03:12:14,220 --> 03:12:17,080
This issue actually was visible more after

03:12:17,080 --> 03:12:20,380
for the 12 ion DMA APIs fixes

03:12:20,380 --> 03:12:22,690
that we did for for correctness.

03:12:22,690 --> 03:12:25,320
But then because it was not performant,

03:12:25,320 --> 03:12:27,290
I'm gonna try to be first.

03:12:28,380 --> 03:12:33,150
So basically vendors wanted to do their own hacks

03:12:33,150 --> 03:12:35,340
and they just reverted ION to 4.9

03:12:35,340 --> 03:12:37,780
had uncashed buffers whatever.

03:12:37,780 --> 03:12:40,580
Then some internal DMA-BUF export is also cheat

03:12:40,580 --> 03:12:44,100
by doing DMA_map_sg on attach

03:12:44,100 --> 03:12:45,920
and only when direction changes.

03:12:45,920 --> 03:12:49,960
So Christian Konig actually he had submitter patch

03:12:49,960 --> 03:12:52,880
which made the cash as UT mapping flag,

03:12:53,950 --> 03:12:56,480
so it allowed to be made generic,

03:12:56,480 --> 03:12:58,930
but that truly doesn't sort of solve the problem.

03:13:00,560 --> 03:13:02,540
Very often buffer is never touched by the CPU.

03:13:02,540 --> 03:13:04,610
So can we try to lazy flushing only

03:13:04,610 --> 03:13:06,630
when your ownership or usage changes?

03:13:06,630 --> 03:13:08,280
That's another question.

03:13:08,280 --> 03:13:09,510
But probably to do that,

03:13:09,510 --> 03:13:13,190
we need to have some sort of explosive device CPU mapping.

03:13:13,190 --> 03:13:14,920
So it goes back to it.

03:13:14,920 --> 03:13:16,230
There are just two topics,

03:13:16,230 --> 03:13:18,100
I want to very quickly touch upon

03:13:18,100 --> 03:13:20,500
which is partial cache invalidation

03:13:20,500 --> 03:13:23,600
and universe that Alistair discussed with John.

03:13:23,600 --> 03:13:27,270
So they had an idea around proposing range flushes

03:13:27,270 --> 03:13:30,660
which is basically DMA clean range or DMA flush range,

03:13:30,660 --> 03:13:32,670
but I think we need a clear articulation

03:13:33,670 --> 03:13:37,090
of the community as to what is required

03:13:37,090 --> 03:13:39,570
and then definitely an upstream user of the code.

03:13:43,282 --> 03:13:44,140
And very quick shout out to,

03:13:44,140 --> 03:13:46,620
this is just FYI but kernel graphics buffers

03:13:46,620 --> 03:13:49,870
is also something that John had discussed

03:13:49,870 --> 03:13:52,460
with Marisa and Alistair the ideas

03:13:52,460 --> 03:13:53,910
to add buffers with metadata.

03:13:55,435 --> 03:13:56,500
And my question around here is some

03:13:56,500 --> 03:13:58,380
in our chamber first right answers.

03:13:58,380 --> 03:14:00,520
Probably it depends on the definition of metadata,

03:14:00,520 --> 03:14:03,070
but okay open.

03:14:03,070 --> 03:14:05,130
- Oh, I just had a comment.

03:14:05,130 --> 03:14:07,900
The partial cache flashing invariegated is real thing

03:14:07,900 --> 03:14:10,340
and apparently the performance optimization.

03:14:10,340 --> 03:14:12,170
I just wanted to put out that.

03:14:12,170 --> 03:14:14,920
- So it's already in kernel, I didn't know that.

03:14:14,920 --> 03:14:17,280
- It's probably not upstream kernel but we've seen it.

03:14:17,280 --> 03:14:19,330
You will see it in ION for example today.

03:14:20,730 --> 03:14:24,300
- Yes, something that the vendors need.

03:14:24,300 --> 03:14:26,110
There are use cases for it.

03:14:26,110 --> 03:14:27,920
- So that's why probably, that's the forum

03:14:27,920 --> 03:14:30,610
that we really need to discuss it right here

03:14:30,610 --> 03:14:32,290
and see if there are any real objections

03:14:32,290 --> 03:14:33,123
to trying to.

03:14:33,123 --> 03:14:35,620
- Yeah, because it also opens a whole can of worms

03:14:35,620 --> 03:14:37,730
because the API is that you need in order

03:14:37,730 --> 03:14:39,750
to actually do partial cache flush

03:14:39,750 --> 03:14:42,060
are also not even exported to any of the drivers.

03:14:42,060 --> 03:14:45,340
So then that's going to open up more.

03:14:47,840 --> 03:14:51,360
- Okay, that was I think the last slide.

03:14:51,360 --> 03:14:52,460
- I also had one more.

03:14:53,412 --> 03:14:57,090
- Oh the user space API for the DMA-BUF heaps,

03:14:57,090 --> 03:14:59,108
is that pretty much finalized?

03:14:59,108 --> 03:14:59,941
So do we have--

03:14:59,941 --> 03:15:01,447
- It's just a single

03:15:01,447 --> 03:15:06,447
- So how do we do heap discovery in from just heap names,

03:15:07,840 --> 03:15:08,840
do we standardize names.

03:15:08,840 --> 03:15:11,530
- Just heap names, that's something we can discuss about.

03:15:11,530 --> 03:15:16,100
We can try and standardize that as part of merging it in.

03:15:16,100 --> 03:15:20,613
- So because I went through 'standardizing' recently,

03:15:21,730 --> 03:15:24,180
I found out a bunch of places where for example,

03:15:24,180 --> 03:15:25,780
if for Android to depend on ION,

03:15:26,740 --> 03:15:29,432
it needs to know exactly what heap is which.

03:15:29,432 --> 03:15:32,360
Today the way it happens is because

03:15:32,360 --> 03:15:34,220
whoever is writing the kernel side ION code

03:15:34,220 --> 03:15:36,160
and the user space side, they just know

03:15:36,160 --> 03:15:38,980
which heap ID to use and they just use that.

03:15:38,980 --> 03:15:41,610
So if unless there is some standardization for example,

03:15:41,610 --> 03:15:44,500
the CMA heaps, how do I know which seem a range

03:15:44,500 --> 03:15:46,610
to use etc etc.

03:15:46,610 --> 03:15:48,220
- I mean the problem is is that

03:15:48,220 --> 03:15:50,070
this is the way ION is fundamentally,

03:15:51,290 --> 03:15:53,450
this is the way ION is fundamentally designed to work.

03:15:53,450 --> 03:15:54,940
Is that ION is fundamentally designs

03:15:54,940 --> 03:15:57,200
that user space is making the decision

03:15:57,200 --> 03:15:58,380
to be do the heap allocation,

03:15:58,380 --> 03:16:00,110
so that user space has to have some sort

03:16:00,110 --> 03:16:02,720
of apriori knowledge about how it works,

03:16:02,720 --> 03:16:03,770
like things are going to.

03:16:03,770 --> 03:16:05,840
So I mean, I don't think we can get away

03:16:05,840 --> 03:16:09,660
from having some user space have some knowledge of that.

03:16:09,660 --> 03:16:11,000
I'm not sure if that's what.

03:16:11,900 --> 03:16:13,570
- Yeah, in ION for sure.

03:16:13,570 --> 03:16:14,620
We can do that,

03:16:14,620 --> 03:16:17,800
But I'm just hoping we do it for the DMA-BUF heaps.

03:16:17,800 --> 03:16:20,290
There is that the discoverability covers the case

03:16:20,290 --> 03:16:21,720
where we don't have to.

03:16:23,017 --> 03:16:24,790
There will be custom heap implementation

03:16:24,790 --> 03:16:26,820
but we we can literally say

03:16:26,820 --> 03:16:29,310
this is the only way user space discovers heaps

03:16:29,310 --> 03:16:30,620
and this is how you get their information,

03:16:30,620 --> 03:16:33,670
you can't just pre-negotiate what a heap looks like.

03:16:33,670 --> 03:16:35,960
Like for example, if the heap nodes are being named

03:16:35,960 --> 03:16:38,304
I can call them like DMA-BUF heap foo

03:16:38,304 --> 03:16:42,270
and only somehow somewhere just you open DMA-BUF heap foo

03:16:42,270 --> 03:16:43,650
and that's bad.

03:16:43,650 --> 03:16:45,590
We wanted to see if we can somehow--

03:16:45,590 --> 03:16:50,590
- So as current offering of solution,

03:16:50,810 --> 03:16:54,090
it's only the enumeration is done only by names

03:16:54,090 --> 03:16:55,920
because each heap its own chardev.

03:16:57,580 --> 03:17:00,040
But we can I think trying to figure out

03:17:00,040 --> 03:17:02,290
a discovery mechanism based on some properties

03:17:02,290 --> 03:17:04,390
that might be something we can talk about.

03:17:10,940 --> 03:17:12,390
- You said that you're hoping the vendors

03:17:12,390 --> 03:17:13,900
would all switch over to DMA-BUF,

03:17:13,900 --> 03:17:15,460
is there any plans to ever?

03:17:15,460 --> 03:17:16,293
- DMA-BUF heaps?

03:17:16,293 --> 03:17:18,980
- Yes, is there any plans to ever deprecated ION.

03:17:21,274 --> 03:17:22,508
- Oh good question.

03:17:22,508 --> 03:17:25,190
- When DMF-BUF heap goes upstream, yes.

03:17:26,360 --> 03:17:29,260
We still have to, when it becomes an upstream thing

03:17:29,260 --> 03:17:33,170
we still have to carry ion for at least another year

03:17:33,170 --> 03:17:34,970
by the time everything catches up.

03:17:34,970 --> 03:17:37,310
so yeah that's basically the plan.

03:17:37,310 --> 03:17:38,650
- Yeah, that is the idea.

03:17:38,650 --> 03:17:41,497
So that's the whole idea around doing using destaging

03:17:41,497 --> 03:17:45,350
of ION using DMA-BUFs and ION.

03:17:45,350 --> 03:17:47,320
- The biggest obstacle I see for the DMA,

03:17:47,320 --> 03:17:49,260
we can figure out the use PCP and whatnot,

03:17:49,260 --> 03:17:50,910
the big thing is the cache management.

03:17:50,910 --> 03:17:53,610
So if that's the biggest thing that I know of

03:17:53,610 --> 03:17:56,710
where people don't want to switch to DMF-BUF,

03:17:56,710 --> 03:18:01,470
they want of cache(mumbles)

03:18:12,024 --> 03:18:13,941
- Okay, that's not bad.

03:18:15,470 --> 03:18:17,860
I was not sure I will be able to finish.

03:18:17,860 --> 03:18:21,027
(audience applauding)

03:18:27,410 --> 03:18:29,342
- Hi I'm back.

03:18:29,342 --> 03:18:32,850
(audience laugh)

03:18:32,850 --> 03:18:34,980
okay, I want to just give a quick talk

03:18:34,980 --> 03:18:38,780
to update folks on DRM/KMS in in AOSP

03:18:38,780 --> 03:18:43,680
and kind of how we're trying to push the platform forward

03:18:43,680 --> 03:18:45,470
and push testing forward with DRM.

03:18:49,605 --> 03:18:53,305
So Pixel 3a XL came out this year same drivers pixel 3.

03:18:53,305 --> 03:18:58,190
That an AOSP using during atomic same driver.

03:18:59,240 --> 03:19:01,570
DragonBoard 845c is currently under review.

03:19:01,570 --> 03:19:03,720
It's going to be added to AOSP shortly.

03:19:03,720 --> 03:19:06,160
It's the same SOC as Pixel 3 laps the the demo

03:19:06,160 --> 03:19:10,600
that Tom Sameach showed it running on Pixel 3,

03:19:10,600 --> 03:19:12,770
but is unfortunately it's not the same driver,

03:19:13,689 --> 03:19:16,389
it's the the upstream MSM DRM driver,

03:19:16,389 --> 03:19:17,430
not the Snapdragon display engine driver

03:19:17,430 --> 03:19:18,900
which is used on pixel 3.

03:19:18,900 --> 03:19:21,027
but it does prove that Android can run on a DRM,

03:19:21,027 --> 03:19:23,870
atomic mode setting DRM/KMS driver

03:19:23,870 --> 03:19:27,170
which is no we knew that, but it's a good demonstrator

03:19:27,170 --> 03:19:30,490
for an AOSP for another plot other SOC manufacturers.

03:19:31,890 --> 03:19:33,000
Also another thing as I mentioned

03:19:33,000 --> 03:19:34,050
in my previous presentation,

03:19:34,050 --> 03:19:35,850
Cuttlefish is now using vertical GPU

03:19:35,850 --> 03:19:37,530
which is aligning our virtual platform

03:19:37,530 --> 03:19:39,730
to use DRM atomic mode setting driver.

03:19:41,500 --> 03:19:45,340
We had to back port the 53RC4 version of virtio.gpu

03:19:45,340 --> 03:19:49,550
to 4.14 and 4.19 for in and out fence support EDID

03:19:49,550 --> 03:19:52,170
and we still have some issues with the default FB

03:19:52,170 --> 03:19:54,751
from the frame of four format as I mentioned

03:19:54,751 --> 03:19:56,379
in my previous presentation.

03:19:56,379 --> 03:19:58,670
But for the most part it works.

03:19:58,670 --> 03:20:00,560
And we're fully going to pile on

03:20:00,560 --> 03:20:02,660
that rather than our old GPU architecture.

03:20:05,210 --> 03:20:08,370
So just to kind of give a status update on upstreaming.

03:20:09,450 --> 03:20:12,780
The only boards I can show are externally available boards,

03:20:12,780 --> 03:20:16,260
visible in AOSP, but it does show that

03:20:16,260 --> 03:20:19,480
there's been no change on pixel, because pixel 3

03:20:19,480 --> 03:20:21,900
was the same as, pixel 3a was the same as pixel 3

03:20:21,900 --> 03:20:25,740
but you know that might change with future products.

03:20:27,270 --> 03:20:31,350
Hikey kind of demonstrates that it's possible

03:20:31,350 --> 03:20:34,980
to do an out of tree Android compatible DRM multiplayer,

03:20:34,980 --> 03:20:39,980
DRM driver outside of upstream

03:20:40,540 --> 03:20:42,570
without making upstream changes.

03:20:42,570 --> 03:20:44,040
So in their full 4.19 kernel

03:20:44,040 --> 03:20:46,480
you can see there's no changes in DRM code,

03:20:46,480 --> 03:20:48,780
but there are only a small number of changes even back

03:20:48,780 --> 03:20:51,140
to 4.14 which are mostly just back ports.

03:20:52,530 --> 03:20:54,080
But these drivers are still,

03:20:54,080 --> 03:20:57,530
you know in the case of Hikey about 10000 lines long.

03:20:58,950 --> 03:21:01,390
When we look at X15 which is an old map platform,

03:21:01,390 --> 03:21:04,110
that's also about 10 to 20000 lines.

03:21:05,700 --> 03:21:06,850
But again it doesn't require many changes

03:21:06,850 --> 03:21:08,367
to DRM core.

03:21:08,367 --> 03:21:10,450
So I think we can we can demonstrate that,

03:21:10,450 --> 03:21:13,550
you know the upstream DRM it is able

03:21:13,550 --> 03:21:16,140
to suit the needs of Android.

03:21:16,140 --> 03:21:18,399
It has got to the point where

03:21:18,399 --> 03:21:21,099
there aren't features that we need to add to it per se

03:21:22,330 --> 03:21:25,330
that are required by conformance,

03:21:25,330 --> 03:21:28,610
but for Android bare minimum, it's enough.

03:21:30,435 --> 03:21:31,440
And then looking at Dragonboard obviously

03:21:31,440 --> 03:21:33,240
because that's being developed essentially

03:21:33,240 --> 03:21:36,880
in upstream, again that's a very minor Delta

03:21:36,880 --> 03:21:38,730
from the upstream drivers.

03:21:38,730 --> 03:21:39,830
Again, it's probably just

03:21:39,830 --> 03:21:42,190
well in this case, it's actually not cherry-picks

03:21:42,190 --> 03:21:45,670
These exchanges that have not yet been accepted upstream.

03:21:45,670 --> 03:21:47,610
but just a small number of changes.

03:21:47,610 --> 03:21:49,940
So you know honestly everybody involved in these projects

03:21:49,940 --> 03:21:52,920
has done an amazing job of aligning to upstream

03:21:52,920 --> 03:21:54,820
and making sure that those upstream changes come back

03:21:54,820 --> 03:21:57,640
to the Android common kernel trees and derivatives of those

03:21:57,640 --> 03:22:00,030
And it's actually looking good.

03:22:03,838 --> 03:22:06,438
So again as I mentioned in my previous presentation,

03:22:07,700 --> 03:22:09,240
Cuttlefish is now a platform that

03:22:09,240 --> 03:22:11,140
for the Android common kernel and GKI,

03:22:12,240 --> 03:22:15,000
we are kind of DRM,

03:22:15,000 --> 03:22:17,910
using it as a demonstration vehicle for DRM.

03:22:17,910 --> 03:22:21,010
So it's possible to launch Cuttlefish with the DRM back-end

03:22:22,720 --> 03:22:25,500
It works with crosvm on both Chrome OS and Linux

03:22:25,500 --> 03:22:27,480
and the crosvm built into Chrome OS.

03:22:27,480 --> 03:22:29,020
The one the ships with the current update channel

03:22:29,020 --> 03:22:30,170
is enough to run Cuttlefish.

03:22:30,170 --> 03:22:31,970
You don't need a custom build a bit.

03:22:33,190 --> 03:22:36,020
And we are going to your question Kareem from before,

03:22:36,020 --> 03:22:37,650
we are adding QEMU support back,

03:22:37,650 --> 03:22:39,500
'cause we know that the community

03:22:39,500 --> 03:22:40,810
also needs access to QEMU support.

03:22:40,810 --> 03:22:43,730
It is just was temporarily deprioritized,

03:22:43,730 --> 03:22:46,650
but we do intend to support our DRM virtual stock

03:22:46,650 --> 03:22:47,940
on QEMU as well.

03:22:50,060 --> 03:22:53,127
So kind of, just kind of discussing

03:22:53,127 --> 03:22:56,360
the need for this, in the Android common kernel.

03:22:56,360 --> 03:22:59,380
So obviously partners merge from the Android common kernel.

03:22:59,380 --> 03:23:00,550
And so, we need to be careful with

03:23:00,550 --> 03:23:02,040
what we put in the Android common kernel.

03:23:02,040 --> 03:23:04,072
Now, this is more important than ever with GKI,

03:23:04,072 --> 03:23:07,370
because if we choose to put DRM,

03:23:07,370 --> 03:23:09,950
the DRM core in the GKI and I think the current plan

03:23:09,950 --> 03:23:13,293
is that we will do that, then we do depend on

03:23:13,293 --> 03:23:15,770
that core being the same for everybody.

03:23:16,820 --> 03:23:20,160
So somebody releasing a device with a GKI based on 419

03:23:20,160 --> 03:23:24,080
or 5.4, will have a specific version of DRM core.

03:23:24,080 --> 03:23:25,740
Now this doesn't seem like a big deal.

03:23:25,740 --> 03:23:27,200
Most kernel subsystems is not,

03:23:27,200 --> 03:23:29,650
but with DRM specifically, our kind of experience

03:23:30,767 --> 03:23:33,000
with the partner ecosystem with GPU

03:23:33,000 --> 03:23:36,180
and display drivers from different manufacturers

03:23:36,180 --> 03:23:38,610
is that everybody is cherry picking and back porting

03:23:38,610 --> 03:23:40,020
and forward porting different versions

03:23:40,020 --> 03:23:42,370
of DRM to different kernel versions to support the customer

03:23:42,370 --> 03:23:43,370
but their customers...

03:23:43,370 --> 03:23:45,480
So the actual, if you look at the,

03:23:45,480 --> 03:23:46,620
if you look at shipping devices

03:23:46,620 --> 03:23:49,046
that aren't those AOSP devices I highlighted earlier,

03:23:49,046 --> 03:23:50,750
it is a bit of a mess.

03:23:51,910 --> 03:23:56,470
So we really need to know which version of DRM/KMS

03:23:56,470 --> 03:23:59,075
do people want to see in the Android common kernel.

03:23:59,075 --> 03:24:00,790
And I think our current view on this is that

03:24:00,790 --> 03:24:03,120
it should be the latest that we can deliver,

03:24:03,120 --> 03:24:05,890
which will be kind of in the case

03:24:05,890 --> 03:24:09,610
of Android are potentially 5.4 LTS.

03:24:11,650 --> 03:24:13,000
So Cuttlefish is the only reference

03:24:13,000 --> 03:24:15,330
that we have building out of the Android common kernel,

03:24:15,330 --> 03:24:18,210
but I hope that we will be able to add more boards over time

03:24:18,210 --> 03:24:20,210
especially as more things get mainlined.

03:24:21,909 --> 03:24:23,720
And obviously the reason for all doing all this

03:24:23,720 --> 03:24:27,260
is greater alignment of the GPU and display stack up string.

03:24:29,590 --> 03:24:31,690
So just a brief update on testing as well,

03:24:32,580 --> 03:24:34,230
so I talked about this last year.

03:24:35,490 --> 03:24:38,490
We now have successfully enabled DRM Harbor Composer

03:24:38,490 --> 03:24:42,000
on basically all AOSP platforms and moving forwards

03:24:42,000 --> 03:24:44,320
that's what we will continue to do.

03:24:44,320 --> 03:24:45,790
So we have alignment of a harbor composer

03:24:45,790 --> 03:24:47,020
which kind of gives us an opportunity

03:24:47,020 --> 03:24:51,150
to do interesting things on the harbor composer side.

03:24:51,150 --> 03:24:53,300
Igt_gpu_tools was added to AOSP

03:24:53,300 --> 03:24:55,900
and I have started work on the build system changes.

03:24:56,770 --> 03:24:58,100
There's more we need to do there

03:24:58,100 --> 03:25:00,936
to actually get more of the modules building,

03:25:00,936 --> 03:25:03,210
they're kind of basic support.

03:25:04,790 --> 03:25:07,697
Once that's in place we'll set a baseline as Tom mentioned

03:25:07,697 --> 03:25:10,992
that the tool itself is not terribly aligned

03:25:10,992 --> 03:25:13,110
to the needs of SOC platforms.

03:25:13,110 --> 03:25:16,480
It's not a particularly wide-ranging test,

03:25:16,480 --> 03:25:17,820
case of tests at the moment,

03:25:17,820 --> 03:25:19,810
but once we've enabled as a baseline,

03:25:19,810 --> 03:25:21,270
I think it'll give us a center of point

03:25:21,270 --> 03:25:23,220
to actually base other test efforts on.

03:25:24,764 --> 03:25:27,120
And my idea is obviously that if a DRM driver is detected,

03:25:27,120 --> 03:25:28,780
it will automatically run this baseline

03:25:28,780 --> 03:25:33,390
of tests using igt_gpu_tools, probably in VTS.

03:25:33,390 --> 03:25:35,810
And then, we'll incrementally increase the test coverage

03:25:35,810 --> 03:25:36,910
over Android releases.

03:25:39,040 --> 03:25:39,873
Any questions?

03:25:49,520 --> 03:25:51,940
We did have a long discussion about this already.

03:25:57,020 --> 03:25:59,750
- I'm from the Android display team

03:25:59,750 --> 03:26:01,170
and we own harbor composer

03:26:01,170 --> 03:26:03,710
and we've been talking about completely blowing it up

03:26:03,710 --> 03:26:04,550
in the future and turning it

03:26:04,550 --> 03:26:07,650
into a couple of small idle interfaces.

03:26:07,650 --> 03:26:09,420
And we've managed the core of it.

03:26:09,420 --> 03:26:12,020
We were hoping someday to be able to talk to DRM/KMS

03:26:13,040 --> 03:26:16,240
or through libDRM without needing

03:26:16,240 --> 03:26:18,630
to know any vendor specific information.

03:26:18,630 --> 03:26:20,330
Do you see that as being possible?

03:26:21,310 --> 03:26:24,520
- Well, I learned recently that the,

03:26:24,520 --> 03:26:27,780
even the DRM_ictl function can be overridden upstream

03:26:27,780 --> 03:26:29,610
So that does present some problems.

03:26:31,230 --> 03:26:32,840
But I think one of the things

03:26:32,840 --> 03:26:35,030
that actually Daniel suggested to me was,

03:26:35,030 --> 03:26:38,340
that Android could take steps that maybe were beyond

03:26:38,340 --> 03:26:39,480
what upstream does;

03:26:39,480 --> 03:26:40,800
which is we could actually you know,

03:26:40,800 --> 03:26:43,388
hack the kernel basically to disallow overriding,

03:26:43,388 --> 03:26:44,670
say DRM_Ictl.

03:26:45,684 --> 03:26:50,260
And then make sure that a set of upstream approved behavior

03:26:50,260 --> 03:26:52,370
and upstream approved dialog tools exist.

03:26:52,370 --> 03:26:54,020
Namely the ictl_tools will be required

03:26:54,020 --> 03:26:56,230
for a kind of a baseline Harbor composer.

03:26:56,230 --> 03:26:59,230
But we also obviously need to provide an extension mechanism

03:27:00,147 --> 03:27:01,115
because not everybody implements

03:27:01,115 --> 03:27:02,280
display hardware the same way.

03:27:02,280 --> 03:27:05,970
And so, there needs to be a way of doing value add,

03:27:05,970 --> 03:27:08,720
but I think in general if we do this kind of alignment,

03:27:09,768 --> 03:27:14,090
we can eliminate something like the harbor composer howl

03:27:15,092 --> 03:27:16,730
and actually have our services talking to DRM directly.

03:27:16,730 --> 03:27:18,930
That would be the goal in my opinion.

03:27:18,930 --> 03:27:20,990
- I think that's pretty lofty.

03:27:20,990 --> 03:27:22,440
I think we could probably get mostly there

03:27:22,440 --> 03:27:25,330
but you do need some knowledge about

03:27:26,220 --> 03:27:29,520
what's underneath the kernel interface.

03:27:31,210 --> 03:27:33,970
For example, some of the restrictions like,

03:27:33,970 --> 03:27:36,110
the one that's particularly nasty is

03:27:36,110 --> 03:27:41,110
that Rockchip only supports FBC on one plane,

03:27:41,360 --> 03:27:44,480
but it can be any of its planes.

03:27:44,480 --> 03:27:47,200
And it's something that you really just have to know

03:27:48,390 --> 03:27:50,970
because it's kind of hard to codify that.

03:27:52,390 --> 03:27:54,040
- To give a bit more context for our plan,

03:27:54,040 --> 03:27:57,920
we had been discussing having a solver idle interface

03:27:57,920 --> 03:27:59,780
that's basically the intelligence of hardware composer.

03:27:59,780 --> 03:28:02,180
It's the thing that people care to write

03:28:02,180 --> 03:28:04,290
and they don't care about the rest of the code.

03:28:04,290 --> 03:28:07,480
A solver would say I want to send these layers

03:28:07,480 --> 03:28:10,220
to the GPU and these layers my mem to mem you know,

03:28:10,220 --> 03:28:12,160
I guess a separate title interface

03:28:12,160 --> 03:28:14,860
and then I want to send these ones to DRM/KMS

03:28:14,860 --> 03:28:16,780
and you'd specify what plain.

03:28:16,780 --> 03:28:18,800
And some of the information to program it.

03:28:18,800 --> 03:28:20,888
- Yeah, that's basically what you need.

03:28:20,888 --> 03:28:23,120
- And I think that's something's achievable,

03:28:23,120 --> 03:28:24,860
but what we would do.

03:28:24,860 --> 03:28:27,230
I mean once we have the planner as well in places

03:28:27,230 --> 03:28:29,200
all the solar sorry, you would be able to test

03:28:29,200 --> 03:28:31,440
that as well, I would quite like

03:28:31,440 --> 03:28:32,840
to have both kinds of tests,

03:28:32,840 --> 03:28:36,050
low level tests via something igt_gpu_tools

03:28:36,050 --> 03:28:37,650
and the may be kind of Android tests

03:28:37,650 --> 03:28:39,931
that will be testing things above that layer

03:28:39,931 --> 03:28:41,340
but I'd like both to work.

03:28:41,340 --> 03:28:44,790
- You guys could play with this already by contributing

03:28:44,790 --> 03:28:46,750
to DRM hardware composer.

03:28:46,750 --> 03:28:47,860
- Yes. - Yes.

03:28:47,860 --> 03:28:49,370
When we've talked about prototyping it,

03:28:49,370 --> 03:28:51,260
we always discuss starting with DRM harbor composer

03:28:51,260 --> 03:28:52,480
and then breaking it up.

03:28:52,480 --> 03:28:54,304
We do it an open sourcing.

03:28:54,304 --> 03:28:57,820
- So Sean, this news is kinda like hot off the press for us.

03:28:57,820 --> 03:29:01,030
We have only just enabled DRM harbor composer in Cuttlefish.

03:29:01,030 --> 03:29:03,930
So is my intention to contribute to that project

03:29:03,930 --> 03:29:05,070
and as a stream to DRM.

03:29:05,070 --> 03:29:08,440
- So you're using DRM harbor composer and Cuttlefish

03:29:08,440 --> 03:29:09,867
on Linux or--

03:29:11,110 --> 03:29:12,630
- On Android.

03:29:12,630 --> 03:29:15,483
- No, but on crosvm on Linux or?

03:29:17,840 --> 03:29:20,590
Oh sorry you're using it--

03:29:20,590 --> 03:29:21,830
- We're using it in our guests.

03:29:21,830 --> 03:29:22,820
- Okay, you're not using it.

03:29:22,820 --> 03:29:25,710
Sorry, I thought you're using the Weiland thing on--

03:29:25,710 --> 03:29:27,900
- We don't only start we don't use the Weiland.

03:29:27,900 --> 03:29:29,830
We don't use the legacy.

03:29:29,830 --> 03:29:32,910
We don't use the legacy Weiland interface.

03:29:32,910 --> 03:29:35,540
We're using, we're tracking the upstream mechanism on,

03:29:35,540 --> 03:29:38,640
was it the DMA-BUF mechanism whatever they had

03:29:38,640 --> 03:29:41,870
to crossvm we're not using virtio(mumbles)

03:29:42,710 --> 03:29:47,120
That's why we needed the functionality to discuss

03:29:47,120 --> 03:29:50,380
them in my last talk about multiplanar virtio_gpu

03:29:51,460 --> 03:29:53,660
because we actually want to run

03:29:53,660 --> 03:29:55,710
this stuff in the guest, not on the host.

03:30:05,850 --> 03:30:07,310
- I just wanted you understand so,

03:30:07,310 --> 03:30:09,390
how did we decide we're gonna standardize things again

03:30:09,390 --> 03:30:11,720
for the solver or we decided

03:30:11,720 --> 03:30:16,660
we're not gonna standardize things for solver?

03:30:16,660 --> 03:30:18,530
- Well, I think the the point John

03:30:18,530 --> 03:30:22,590
was making was the constraint management essentially,

03:30:22,590 --> 03:30:24,480
is not something you can handle like a,

03:30:24,480 --> 03:30:25,950
it's not something you would efficiently handle

03:30:25,950 --> 03:30:27,000
with an ictl interface.

03:30:27,000 --> 03:30:28,600
It would be too custom.

03:30:28,600 --> 03:30:30,770
So the idea is the way it works in DRM

03:30:30,770 --> 03:30:32,310
and more with atomic mode setting,

03:30:32,310 --> 03:30:33,570
as you set a configuration than

03:30:33,570 --> 03:30:36,090
if it's allowed, if it's not allowed to set it,

03:30:36,090 --> 03:30:37,870
you'll bounce you.

03:30:37,870 --> 03:30:40,613
And so, you wanna make sure when you do those calls

03:30:40,613 --> 03:30:42,830
that the configuration is valid

03:30:42,830 --> 03:30:45,180
for all the planes connectors and everything else

03:30:45,180 --> 03:30:47,250
is configured on that device.

03:30:47,250 --> 03:30:49,910
So the vendor specific horribleness goes

03:30:49,910 --> 03:30:52,070
in both the display driver and then user space

03:30:52,070 --> 03:30:54,070
but not in the interface between those components.

03:30:54,070 --> 03:30:56,090
But we still need to standardize--

03:30:56,090 --> 03:30:57,150
- [Man] The user space.

03:30:57,150 --> 03:30:58,600
- The ictl space for example.

03:30:59,850 --> 03:31:03,040
- [Man] And some minimum things that we expect

03:31:03,040 --> 03:31:06,041
to exist at some point.

03:31:06,041 --> 03:31:10,640
- I think that, so the problem is that the KMS interface

03:31:10,640 --> 03:31:15,230
to set up a scene for example, to put your buffers on planes

03:31:17,230 --> 03:31:20,380
you need to have some knowledge of the hardware

03:31:20,380 --> 03:31:23,200
to make an intelligent choice about what to try

03:31:23,200 --> 03:31:25,110
and then you can try that and the kernel

03:31:25,110 --> 03:31:27,540
will tell yes that will work

03:31:27,540 --> 03:31:29,340
or no it won't work.

03:31:29,340 --> 03:31:32,570
But you need some smarts to know where to start

03:31:32,570 --> 03:31:33,910
and also how to fall back.

03:31:35,668 --> 03:31:39,640
Right, because otherwise you'll just try the best thing,

03:31:39,640 --> 03:31:42,240
the kernel will say no for some reason you don't know

03:31:42,240 --> 03:31:44,140
and then you'll fall back to GPU compositing.

03:31:44,140 --> 03:31:46,898
- But does any drill down like for example,

03:31:46,898 --> 03:31:48,393
if majority of the hardware that we deal

03:31:48,393 --> 03:31:51,300
with always supports like say two overlays and two planes.

03:31:51,300 --> 03:31:53,580
Can't we just say oh, we need,

03:31:53,580 --> 03:31:55,680
we have a test which basically expects

03:31:55,680 --> 03:31:57,840
this particular thing setting to succeed.

03:32:00,290 --> 03:32:02,950
There's no whole Android hardware does

03:32:02,950 --> 03:32:04,536
have such a complicated(mumbles).

03:32:04,536 --> 03:32:06,010
- Well, obviously that's was the first question.

03:32:06,010 --> 03:32:07,369
If it doesn't then--

03:32:07,369 --> 03:32:10,820
- You just can't rely on that ever being true,

03:32:10,820 --> 03:32:12,930
because of a myriad of things.

03:32:12,930 --> 03:32:14,360
- Yes, an example, another example,

03:32:14,360 --> 03:32:15,410
this is bandwidth management.

03:32:15,410 --> 03:32:18,210
So for example displays in GPU is a lot of memory bandwidth

03:32:18,210 --> 03:32:20,580
If the device is operating in a low-power mode,

03:32:20,580 --> 03:32:22,070
it may not be able to do as many things as

03:32:22,070 --> 03:32:25,440
it was able to do when it had lots of bandwidth available.

03:32:25,440 --> 03:32:27,190
So a configuration that might

03:32:27,190 --> 03:32:29,060
have been successfully settable previously

03:32:29,060 --> 03:32:30,160
is no longer settable.

03:32:31,286 --> 03:32:32,828
And whether DRM should have

03:32:32,828 --> 03:32:34,370
or whether we should standardized DRM

03:32:34,370 --> 03:32:35,970
in such a way that you could require it all of

03:32:35,970 --> 03:32:38,063
that kind of kind of stuff,

03:32:38,063 --> 03:32:40,263
it's it seems out of the scope for DRM core.

03:32:44,010 --> 03:32:45,520
- Another complication that we probably

03:32:45,520 --> 03:32:47,200
will never be able to understand

03:32:47,200 --> 03:32:49,690
is some Android vendors will take over

03:32:49,690 --> 03:32:50,910
their display controller and use it

03:32:50,910 --> 03:32:52,948
for other subsystems temporarily that's like mem to mem unit

03:32:52,948 --> 03:32:56,130
2D format conversions, color correction and stuff like that

03:32:58,419 --> 03:33:00,850
and that just doesn't belong a DRM core.

03:33:01,850 --> 03:33:03,640
- What do y'all think?

03:33:03,640 --> 03:33:05,890
Blitzes, colorspace converters should

03:33:05,890 --> 03:33:08,080
they be exposed as video devices in DRM.

03:33:09,210 --> 03:33:12,190
- So we have right-back devices right now

03:33:12,190 --> 03:33:16,560
which is kind of in that range of things,

03:33:16,560 --> 03:33:17,790
but no probably not.

03:33:17,790 --> 03:33:20,460
I think those sound like v4l devices.

03:33:23,080 --> 03:33:24,450
- Daniel has got nothing to say.

03:33:27,079 --> 03:33:28,938
- You have 20 seconds to go.

03:33:28,938 --> 03:33:31,021
(laughs)

03:33:36,370 --> 03:33:38,210
- There has been some suggestions made

03:33:38,210 --> 03:33:42,210
that maybe v4l should be merged into DRM at some point

03:33:43,240 --> 03:33:46,497
and that's, it's not a power grab, it's my nightmare but.

03:34:02,890 --> 03:34:07,760
- Hello again, so this presentation is about UtilClamp.

03:34:09,590 --> 03:34:12,330
This is a new facility in the kernel

03:34:12,330 --> 03:34:14,080
which was developed by ARM,

03:34:14,080 --> 03:34:18,190
actually Patrick Galache is here as our main developer.

03:34:18,190 --> 03:34:21,410
And I'll be talking about our plans to use it

03:34:21,410 --> 03:34:24,710
in the Android and replace schedtune

03:34:26,100 --> 03:34:29,120
proprietary C group basically.

03:34:29,120 --> 03:34:33,510
So the basic idea of boosting and clamping tasks

03:34:33,510 --> 03:34:36,892
is you basically change the utilization of the task

03:34:36,892 --> 03:34:41,400
for it to look bigger or smaller to the scheduler

03:34:42,800 --> 03:34:45,770
and that will affect the frequency selection

03:34:45,770 --> 03:34:47,190
and also the task placement,

03:34:48,100 --> 03:34:53,100
when schedutils and EAS

03:34:53,240 --> 03:34:57,010
are being used in the system just like in Android.

03:34:59,850 --> 03:35:03,100
So here's the comparison between Schedtune and Utilclamp,

03:35:03,100 --> 03:35:06,680
obvious Schedtune is out of three custom cgroup controller.

03:35:06,680 --> 03:35:09,480
It supports only v1, cgroups v1

03:35:09,480 --> 03:35:12,610
and on the limited number of task groups.

03:35:13,880 --> 03:35:16,070
Its boosting is nonlinear,

03:35:16,070 --> 03:35:17,320
so it's difficult to tune

03:35:19,940 --> 03:35:24,060
and it has some additional features

03:35:24,060 --> 03:35:27,060
which are kind of hard coded, so they are not very flexible.

03:35:29,102 --> 03:35:31,111
And you Utilclamp on the other hand

03:35:31,111 --> 03:35:34,550
is upstream as of 5.3 Cgroup support

03:35:34,550 --> 03:35:38,070
will most likely go into 5.4.

03:35:38,070 --> 03:35:41,620
And it supports both cgroup v1 and v2.

03:35:43,320 --> 03:35:46,260
In addition, it supports pre task syscalls

03:35:46,260 --> 03:35:48,460
and also system-wide defaults

03:35:48,460 --> 03:35:50,090
which are missing in Schedtune.

03:35:51,980 --> 03:35:55,724
Its threshold gets simple, its linear

03:35:55,724 --> 03:35:59,970
and actually the features which are missing

03:35:59,970 --> 03:36:04,970
are boost holding and prefer idle features,

03:36:05,850 --> 03:36:07,370
but they are being worked on.

03:36:10,040 --> 03:36:15,040
So here are some results running the Android JankBench tests

03:36:16,090 --> 03:36:19,100
and the power performance numbers look pretty good.

03:36:19,100 --> 03:36:20,440
They're very comparable.

03:36:20,440 --> 03:36:23,320
There is one case which is shown in red

03:36:23,320 --> 03:36:28,250
where we see regression and we are going to be looking at it

03:36:28,250 --> 03:36:30,320
but overall it looks pretty comparable,

03:36:30,320 --> 03:36:33,290
so we don't expect any regressions

03:36:33,290 --> 03:36:34,670
by switching to Utilclamp.

03:36:38,470 --> 03:36:41,890
So our rollout plan is basically next version of Android.

03:36:43,510 --> 03:36:47,460
It will be upstream in kernel 5.4

03:36:47,460 --> 03:36:51,540
and we are planning to backport most likely up to 4.19.

03:36:53,400 --> 03:36:55,320
There are several considerations

03:36:55,320 --> 03:36:56,980
which we still need to clarify

03:36:56,980 --> 03:37:00,280
whether we're gonna use cgroup v1 or v2,

03:37:00,280 --> 03:37:04,300
unified hierarchy or with that will be driven

03:37:04,300 --> 03:37:06,190
by that cgroup v1 or v2.

03:37:06,190 --> 03:37:10,350
This consideration and also per-role

03:37:10,350 --> 03:37:12,270
or per application test grouping.

03:37:14,580 --> 03:37:15,770
And there is a number of things

03:37:15,770 --> 03:37:17,420
which still need to work through.

03:37:19,210 --> 03:37:22,780
As I said there is a number of features which are missing.

03:37:22,780 --> 03:37:24,880
One of them is boost hold feature

03:37:27,790 --> 03:37:31,900
which basically keeps the boosting for some specific time.

03:37:36,040 --> 03:37:39,250
That's missing in Utilclamp and prefer idle

03:37:39,250 --> 03:37:41,110
which we would like to discuss today

03:37:43,124 --> 03:37:45,420
and there are couple of options to implement it.

03:37:45,420 --> 03:37:48,370
And there are a number of things which we need to validate.

03:37:49,570 --> 03:37:54,440
One of them is are the requirement for RT tasks

03:37:54,440 --> 03:37:58,250
to be in root cgroup, where we don't know

03:37:58,250 --> 03:38:01,890
if there are any negative effects of that yet.

03:38:01,890 --> 03:38:05,570
And also the fact that we are using CPU controller

03:38:05,570 --> 03:38:08,720
means as a bandwidth, CPU bandwidth will be divided

03:38:08,720 --> 03:38:09,900
between the Cgroups.

03:38:11,220 --> 03:38:14,460
And we also need to evaluate

03:38:14,460 --> 03:38:16,160
possible negative effects of that.

03:38:20,130 --> 03:38:22,550
Before I go to discussion points,

03:38:22,550 --> 03:38:25,190
I'll talk about migration process for us.

03:38:25,190 --> 03:38:27,990
So we have prototype working and migration

03:38:27,990 --> 03:38:29,370
was pretty straightforward.

03:38:29,370 --> 03:38:32,440
Basically we needed to change the task profiles

03:38:32,440 --> 03:38:35,900
to use UtilClamp instead of schedtune controller.

03:38:37,120 --> 03:38:39,530
There are small changes in the power how

03:38:39,530 --> 03:38:43,470
to use something, instead of prefer idle,

03:38:43,470 --> 03:38:47,260
some new mechanisms which we will be discussing today

03:38:47,260 --> 03:38:50,980
and there are a number of changes in the init scripts.

03:38:50,980 --> 03:38:53,220
So basically not mount Schedtune control

03:38:53,220 --> 03:38:55,300
and instead use CPU controller

03:38:55,300 --> 03:38:57,780
and create appropriate hierarchy under it.

03:39:01,700 --> 03:39:04,770
So and discussion points that we would like to discuss today

03:39:04,770 --> 03:39:06,960
is prefer_idle replacement.

03:39:06,960 --> 03:39:09,510
And two options that we see right now

03:39:09,510 --> 03:39:14,510
is one is to use a couple of conditions

03:39:15,420 --> 03:39:18,220
to replace prefer-idle hint,

03:39:18,220 --> 03:39:20,200
so instead of, and the second option

03:39:20,200 --> 03:39:23,090
is basically introducing a new property.

03:39:24,310 --> 03:39:28,690
The first option would be if task is boosted

03:39:28,690 --> 03:39:33,230
and if it has shares higher than default once,

03:39:33,230 --> 03:39:38,230
considers that a hint that prefer_idle should be enabled.

03:39:38,250 --> 03:39:41,790
And prefer-idle means we want to place

03:39:41,790 --> 03:39:45,470
that task on a CPU which is idle right now.

03:39:46,340 --> 03:39:49,610
That helps with reducing the latency.

03:39:49,610 --> 03:39:53,400
So you know, right now it's used for touch boost

03:39:53,400 --> 03:39:58,400
which is basically when user, there is a touch event.

03:39:58,610 --> 03:40:01,790
We want the latencies to be minimized for such a task

03:40:01,790 --> 03:40:05,220
so that say the response time is very short.

03:40:06,120 --> 03:40:07,770
- It's also used for all top app.

03:40:10,085 --> 03:40:12,570
So the apps that are part of the user experience right now

03:40:12,570 --> 03:40:14,200
we're optimizing for latency,

03:40:14,200 --> 03:40:17,570
so they don't miss their their vsync windows.

03:40:17,570 --> 03:40:18,403
- I see okay.

03:40:19,570 --> 03:40:21,520
So basically we are we are trying

03:40:21,520 --> 03:40:23,070
to optimize it for the latency.

03:40:24,010 --> 03:40:27,100
And so, if we go with this option,

03:40:27,100 --> 03:40:30,960
we don't need to add any addition of proper properties

03:40:30,960 --> 03:40:32,660
in the CPU controller.

03:40:32,660 --> 03:40:34,010
The second option is to add

03:40:35,020 --> 03:40:37,970
just additional CPU controller property

03:40:37,970 --> 03:40:42,970
which would say whether the task is latency tolerant or not

03:40:43,260 --> 03:40:48,260
and by default all tasks are basically latency tolerant

03:40:48,860 --> 03:40:52,090
unless we set it to false in which case,

03:40:53,010 --> 03:40:56,220
it will be similar to setting prefer idle to true.

03:40:56,220 --> 03:41:00,470
So the scheduler will try to find an idle CPU

03:41:00,470 --> 03:41:01,340
for that task.

03:41:02,720 --> 03:41:06,090
So those are two options that we are considering

03:41:06,090 --> 03:41:10,210
and if anybody has any concerns about those

03:41:10,210 --> 03:41:13,810
or any preferences we would like to know about it

03:41:13,810 --> 03:41:15,740
rather earlier in the process.

03:41:20,907 --> 03:41:24,173
- So we have about seven minutes and a half to go.

03:41:24,173 --> 03:41:25,355
- Oh, this is the last presentation

03:41:25,355 --> 03:41:27,908
so if we end earlier(laughs)

03:41:27,908 --> 03:41:31,241
(speech off microphone)

03:41:32,348 --> 03:41:34,000
- Oh okay, all right.

03:41:34,000 --> 03:41:35,800
So if anybody has any suggestions

03:41:35,800 --> 03:41:37,730
or any concerns about this approaches

03:41:42,619 --> 03:41:43,760
or is there are any questions?

03:41:52,120 --> 03:41:53,411
I guess not.

03:41:53,411 --> 03:41:54,744
All right, thank you very much.

03:41:54,744 --> 03:41:56,198
- Thank you sir!

03:41:56,198 --> 03:41:57,824

YouTube URL: https://www.youtube.com/watch?v=f2C-gA8jEyY


