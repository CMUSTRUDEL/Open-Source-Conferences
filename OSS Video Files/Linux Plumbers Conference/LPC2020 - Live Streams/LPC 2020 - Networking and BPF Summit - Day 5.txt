Title: LPC 2020 - Networking and BPF Summit - Day 5
Publication date: 2020-08-28
Playlist: LPC2020 - Live Streams
Description: 
	Linux Plumbers Conference 2020
Captions: 
	00:01:42,079 --> 00:01:44,880
okay luke you should have presenter

00:01:43,680 --> 00:01:48,640
status now

00:01:44,880 --> 00:01:50,399
and uh maybe wait another minute or two

00:01:48,640 --> 00:01:52,399
to make sure the youtube live stream is

00:01:50,399 --> 00:01:54,320
going and everything

00:01:52,399 --> 00:01:56,640
uh by the way it's good to see some uw

00:01:54,320 --> 00:01:58,000
folks uh participating in the uh

00:01:56,640 --> 00:01:59,040
conference uh you're right down the

00:01:58,000 --> 00:02:00,799
street some local

00:01:59,040 --> 00:02:03,360
local local folks it's always good to

00:02:00,799 --> 00:02:05,280
see um

00:02:03,360 --> 00:02:07,200
yeah let's just wait or two oh daniel

00:02:05,280 --> 00:02:11,759
says that youtube live is ready so

00:02:07,200 --> 00:02:11,759
um luke uh you can go please begin

00:02:15,440 --> 00:02:23,840
luke we can't hear your audio

00:02:35,280 --> 00:02:38,800
uh testing can you hear me now yes we

00:02:37,760 --> 00:02:41,360
can hear you

00:02:38,800 --> 00:02:41,360
you're perfect

00:02:42,319 --> 00:02:49,280
um let me get back to the all right

00:02:45,840 --> 00:02:53,200
okay i think we should be back

00:02:49,280 --> 00:02:54,480
um there we go

00:02:53,200 --> 00:02:58,239
my webcam doesn't seem to be coming

00:02:54,480 --> 00:03:02,560
through but uh it says it's a permission

00:02:58,239 --> 00:03:04,720
error on let me try stop and share

00:03:02,560 --> 00:03:05,760
webcam sharing locked i'm not sure what

00:03:04,720 --> 00:03:08,959
that

00:03:05,760 --> 00:03:10,480
oh there we go okay perfect so hi my

00:03:08,959 --> 00:03:12,560
name is luke nelson um today i'm going

00:03:10,480 --> 00:03:13,840
to tell you about uh how we use formal

00:03:12,560 --> 00:03:16,000
verification techniques

00:03:13,840 --> 00:03:17,680
to help eliminate bugs and the vpf jets

00:03:16,000 --> 00:03:19,440
that are in the linux kernel

00:03:17,680 --> 00:03:23,280
and this is work that i did together

00:03:19,440 --> 00:03:23,280
with several other people at uw

00:03:24,879 --> 00:03:29,200
so as we've seen throughout this week

00:03:26,799 --> 00:03:31,360
there's bpf is used for many important

00:03:29,200 --> 00:03:33,280
parts of the kernel so it's been used

00:03:31,360 --> 00:03:35,200
for tracing and networking and security

00:03:33,280 --> 00:03:36,480
and other important purposes

00:03:35,200 --> 00:03:39,120
and the basic way that this works on

00:03:36,480 --> 00:03:41,200
linux is that user space downloads the

00:03:39,120 --> 00:03:42,319
bpf program and bpf by code into the

00:03:41,200 --> 00:03:43,680
linux kernel

00:03:42,319 --> 00:03:45,599
the linux kernel has a component called

00:03:43,680 --> 00:03:46,000
the verifier that checks that the bpf

00:03:45,599 --> 00:03:48,159
program

00:03:46,000 --> 00:03:50,080
is safe and then if it is safe it sends

00:03:48,159 --> 00:03:53,599
it to a vpfj compiler which compiles it

00:03:50,080 --> 00:03:56,080
to native code for better performance

00:03:53,599 --> 00:03:57,439
so one problem that exists with these

00:03:56,080 --> 00:03:58,720
bpfc compilers

00:03:57,439 --> 00:04:00,879
is that they can be very difficult to

00:03:58,720 --> 00:04:01,120
get right and the main reason behind

00:04:00,879 --> 00:04:02,720
this

00:04:01,120 --> 00:04:04,080
is because when you're writing a bpf jet

00:04:02,720 --> 00:04:05,680
compiler you have to think about code

00:04:04,080 --> 00:04:06,560
that's executing at multiple different

00:04:05,680 --> 00:04:07,840
levels

00:04:06,560 --> 00:04:10,000
and what i mean by that is that you have

00:04:07,840 --> 00:04:10,560
to think about the code that's executing

00:04:10,000 --> 00:04:12,400
in the jit

00:04:10,560 --> 00:04:15,040
itself as well as the machine code

00:04:12,400 --> 00:04:16,880
that's being produced by the jit

00:04:15,040 --> 00:04:18,320
so the kernel has existing self-tests

00:04:16,880 --> 00:04:19,600
and fuzzing techniques and these can be

00:04:18,320 --> 00:04:21,440
effective at preventing many of the

00:04:19,600 --> 00:04:22,320
types of bugs that can happen in vpf

00:04:21,440 --> 00:04:24,160
jets

00:04:22,320 --> 00:04:25,919
but the search base is just too big to

00:04:24,160 --> 00:04:27,919
exhaust all the possibilities

00:04:25,919 --> 00:04:29,840
so there could be many corner cases

00:04:27,919 --> 00:04:31,520
lurking both in the input to the jit

00:04:29,840 --> 00:04:32,960
and to the input to the bpf program

00:04:31,520 --> 00:04:34,560
itself

00:04:32,960 --> 00:04:36,160
and because the compiled code runs

00:04:34,560 --> 00:04:38,160
directly in the kernel

00:04:36,160 --> 00:04:39,600
any bugs in the jit might be able to be

00:04:38,160 --> 00:04:41,280
exploited by

00:04:39,600 --> 00:04:44,479
some malicious bpf program to become a

00:04:41,280 --> 00:04:44,479
kernel security vulnerability

00:04:44,880 --> 00:04:48,479
to make it a little bit more concrete

00:04:46,160 --> 00:04:50,400
why these bpf jets are hard

00:04:48,479 --> 00:04:51,759
here's a little snippet of the 32-bit

00:04:50,400 --> 00:04:54,320
x86 jet

00:04:51,759 --> 00:04:56,240
for the bpf instruction that loads a 4

00:04:54,320 --> 00:04:58,639
byte value from memory

00:04:56,240 --> 00:04:59,840
and the thing to note here first is that

00:04:58,639 --> 00:05:02,000
there can be control flow

00:04:59,840 --> 00:05:03,440
in the bpf jit itself so the mapping

00:05:02,000 --> 00:05:05,120
from bpf instructions to native

00:05:03,440 --> 00:05:07,280
instructions is not just one-to-one

00:05:05,120 --> 00:05:08,960
often the jit is doing some complicated

00:05:07,280 --> 00:05:10,479
logic to determine what instructions to

00:05:08,960 --> 00:05:13,280
produce

00:05:10,479 --> 00:05:15,280
and then secondly in some examples the

00:05:13,280 --> 00:05:17,680
generated code itself also has branches

00:05:15,280 --> 00:05:19,840
that you have to think about

00:05:17,680 --> 00:05:22,000
so the second thing is that in some of

00:05:19,840 --> 00:05:24,400
these jets like at least the x86 chips

00:05:22,000 --> 00:05:25,520
they're emitting uh native instructions

00:05:24,400 --> 00:05:27,440
as these raw

00:05:25,520 --> 00:05:29,600
raw bytes with these these emit

00:05:27,440 --> 00:05:30,639
functions so that means is to understand

00:05:29,600 --> 00:05:32,160
what this code is doing

00:05:30,639 --> 00:05:34,000
if you're reading or writing it you have

00:05:32,160 --> 00:05:35,039
to sort of keep an x86 decoder in your

00:05:34,000 --> 00:05:38,240
head which is

00:05:35,039 --> 00:05:40,160
uh quite a feat

00:05:38,240 --> 00:05:42,000
so there's actually at least one bug in

00:05:40,160 --> 00:05:43,440
this code um

00:05:42,000 --> 00:05:45,840
and it's quite difficult to be able to

00:05:43,440 --> 00:05:46,080
spot what the bug is and so what we need

00:05:45,840 --> 00:05:48,400
is

00:05:46,080 --> 00:05:49,520
some way of systematically testing this

00:05:48,400 --> 00:05:52,240
code that

00:05:49,520 --> 00:05:53,840
would be able to catch uh i'll catch all

00:05:52,240 --> 00:05:56,400
of the bugs and verify that we've

00:05:53,840 --> 00:05:58,080
correctly fixed them so one promising

00:05:56,400 --> 00:05:59,199
approach is called formal verification

00:05:58,080 --> 00:06:01,199
for doing this

00:05:59,199 --> 00:06:02,479
and the idea behind formal verification

00:06:01,199 --> 00:06:03,600
is that you're going to formally prove

00:06:02,479 --> 00:06:04,160
that the piece of software that you

00:06:03,600 --> 00:06:07,280
write

00:06:04,160 --> 00:06:08,960
is uh is free of bugs and the basic way

00:06:07,280 --> 00:06:10,240
that you do that

00:06:08,960 --> 00:06:12,240
is first you come up with a

00:06:10,240 --> 00:06:14,000
specification so specification

00:06:12,240 --> 00:06:15,759
is an abstract description of what the

00:06:14,000 --> 00:06:17,680
intended behavior of the code is

00:06:15,759 --> 00:06:19,280
and ideally your specification is

00:06:17,680 --> 00:06:21,280
smaller and therefore easier to audit

00:06:19,280 --> 00:06:22,800
than your implementation

00:06:21,280 --> 00:06:24,560
and then you'll prove that your

00:06:22,800 --> 00:06:25,680
implementation satisfies your abstract

00:06:24,560 --> 00:06:27,199
specification

00:06:25,680 --> 00:06:29,440
and so what this would show is that your

00:06:27,199 --> 00:06:31,039
implementation at least doesn't have any

00:06:29,440 --> 00:06:33,280
more bugs than what the specification

00:06:31,039 --> 00:06:33,280
has

00:06:33,600 --> 00:06:38,639
so but not everything comes for free and

00:06:37,120 --> 00:06:40,479
formal verification especially comes

00:06:38,639 --> 00:06:42,240
with that cost and this cost is uh

00:06:40,479 --> 00:06:44,639
largely the developer burden

00:06:42,240 --> 00:06:45,759
so to do formal verification requires a

00:06:44,639 --> 00:06:47,120
lot more effort on the part of the

00:06:45,759 --> 00:06:48,319
developer compared to other techniques

00:06:47,120 --> 00:06:49,919
such as testing

00:06:48,319 --> 00:06:52,720
this effort comes largely from two

00:06:49,919 --> 00:06:54,479
different places so first is

00:06:52,720 --> 00:06:56,080
when you're if you want to apply for

00:06:54,479 --> 00:06:57,680
verification you have to actually sit

00:06:56,080 --> 00:06:59,120
down and think of what the specification

00:06:57,680 --> 00:07:00,800
for your code should be

00:06:59,120 --> 00:07:02,960
and this is difficult for a number of

00:07:00,800 --> 00:07:04,560
reasons so your specification has to be

00:07:02,960 --> 00:07:05,840
restrictive enough to prevent the bugs

00:07:04,560 --> 00:07:07,280
that can occur in your code

00:07:05,840 --> 00:07:09,039
but it also has to be general enough to

00:07:07,280 --> 00:07:10,080
cover the existing implementations that

00:07:09,039 --> 00:07:13,520
you're trying to verify

00:07:10,080 --> 00:07:15,360
such as the bpf jets that are in linux

00:07:13,520 --> 00:07:17,680
secondly once you've decided what your

00:07:15,360 --> 00:07:18,560
specification for your system should be

00:07:17,680 --> 00:07:19,840
you have to prove that your

00:07:18,560 --> 00:07:21,120
implementation satisfies that

00:07:19,840 --> 00:07:22,960
specification

00:07:21,120 --> 00:07:24,160
uh manually writing these proofs can be

00:07:22,960 --> 00:07:26,319
very time consuming so

00:07:24,160 --> 00:07:27,759
often times for manual proofs uh there

00:07:26,319 --> 00:07:29,039
can be more than ten times the number of

00:07:27,759 --> 00:07:31,120
lines of code approved compared to

00:07:29,039 --> 00:07:32,960
implementation

00:07:31,120 --> 00:07:34,479
now there is also this idea of automated

00:07:32,960 --> 00:07:35,840
formal verification

00:07:34,479 --> 00:07:37,599
that doesn't require you to write any

00:07:35,840 --> 00:07:38,960
manual proofs but it's not clear that

00:07:37,599 --> 00:07:40,479
these techniques will trivially scale

00:07:38,960 --> 00:07:43,120
well to the problem of vpf jet

00:07:40,479 --> 00:07:43,120
verification

00:07:43,759 --> 00:07:47,199
so today what i'm going to tell you

00:07:45,120 --> 00:07:48,080
about is a tool that we built called

00:07:47,199 --> 00:07:49,440
jitterbug

00:07:48,080 --> 00:07:50,879
and judibug is a tool that does

00:07:49,440 --> 00:07:52,639
automated formal verification for the

00:07:50,879 --> 00:07:54,479
bpf jits and linux

00:07:52,639 --> 00:07:56,720
and there's two main new things in

00:07:54,479 --> 00:07:58,000
jitterbug so the first is that judybug

00:07:56,720 --> 00:08:00,639
comes with a specification

00:07:58,000 --> 00:08:02,879
of bpfj correctness that rules out the

00:08:00,639 --> 00:08:05,360
types of bugs that we see in bpf chips

00:08:02,879 --> 00:08:07,599
and is also amenable to the existing

00:08:05,360 --> 00:08:09,360
implementations in the kernel

00:08:07,599 --> 00:08:10,800
and second jitterbug comes with an

00:08:09,360 --> 00:08:12,960
automated proof strategy

00:08:10,800 --> 00:08:14,720
that liberates the developer from having

00:08:12,960 --> 00:08:16,319
to write any manual proofs

00:08:14,720 --> 00:08:17,840
and again works for the implementations

00:08:16,319 --> 00:08:19,520
that are in linux

00:08:17,840 --> 00:08:21,039
and the implementations for these bits

00:08:19,520 --> 00:08:22,800
are actually we write them in a

00:08:21,039 --> 00:08:23,599
domain-specific language that jitterbug

00:08:22,800 --> 00:08:25,360
introduces

00:08:23,599 --> 00:08:27,919
specifically designed for verifying and

00:08:25,360 --> 00:08:29,680
implementing bpf dids

00:08:27,919 --> 00:08:31,840
our main results are that using

00:08:29,680 --> 00:08:32,880
jitterbug we found and fixed more than

00:08:31,840 --> 00:08:35,279
30 new bugs in

00:08:32,880 --> 00:08:37,279
existing bpf jits in linux across 11

00:08:35,279 --> 00:08:39,519
patches

00:08:37,279 --> 00:08:41,519
and to do this we manually translated

00:08:39,519 --> 00:08:42,320
the c code of these jits to our dsl for

00:08:41,519 --> 00:08:44,320
verification

00:08:42,320 --> 00:08:46,399
this process took roughly several weeks

00:08:44,320 --> 00:08:48,959
per jet

00:08:46,399 --> 00:08:52,160
secondly using jitterbug we developed a

00:08:48,959 --> 00:08:53,279
new bpf jet for risk 532 or 32-bit risk

00:08:52,160 --> 00:08:55,600
00:08:53,279 --> 00:08:57,279
which previously wasn't a vpf jit for

00:08:55,600 --> 00:08:59,839
and to do this we first wrote our

00:08:57,279 --> 00:09:00,480
implementation in the dsl that jitterbug

00:08:59,839 --> 00:09:02,160
has

00:09:00,480 --> 00:09:03,680
and then we wrote a tool to do automated

00:09:02,160 --> 00:09:05,360
extraction to c code and this

00:09:03,680 --> 00:09:07,920
automatedly extracted c code

00:09:05,360 --> 00:09:09,760
is what's in the linux kernel today and

00:09:07,920 --> 00:09:10,640
then lastly we use jitterbug to develop

00:09:09,760 --> 00:09:12,480
and verify

00:09:10,640 --> 00:09:15,120
uh 12 new optimization patches for

00:09:12,480 --> 00:09:17,600
existing jets

00:09:15,120 --> 00:09:18,160
so now i'll give you a brief outline of

00:09:17,600 --> 00:09:19,120
the

00:09:18,160 --> 00:09:20,800
the rest of the things that i'm going to

00:09:19,120 --> 00:09:22,160
talk about in this talk so first i'll

00:09:20,800 --> 00:09:23,680
give an overview of

00:09:22,160 --> 00:09:25,200
how you should think about how the bpf

00:09:23,680 --> 00:09:27,600
jets and linux work

00:09:25,200 --> 00:09:29,360
uh then i'll talk about a case study of

00:09:27,600 --> 00:09:29,920
bugs that we've seen in bpf jits in the

00:09:29,360 --> 00:09:31,360
past

00:09:29,920 --> 00:09:33,519
and an example of some bugs that

00:09:31,360 --> 00:09:34,880
jitterbug has found

00:09:33,519 --> 00:09:36,800
then i'll talk about jitterbug's jit

00:09:34,880 --> 00:09:37,920
specification and how it rules out the

00:09:36,800 --> 00:09:40,800
types of bugs that

00:09:37,920 --> 00:09:42,560
we've studied in the case study then

00:09:40,800 --> 00:09:44,080
i'll talk about how to use jitterbug so

00:09:42,560 --> 00:09:45,519
it's the basics of how jitterbug works

00:09:44,080 --> 00:09:47,360
and what developers have to provide in

00:09:45,519 --> 00:09:50,080
order to use it

00:09:47,360 --> 00:09:51,760
then verification effort so how hard it

00:09:50,080 --> 00:09:53,040
is to actually prove these bpf jets

00:09:51,760 --> 00:09:55,760
correct

00:09:53,040 --> 00:09:56,240
and lastly a short demonstration uh and

00:09:55,760 --> 00:09:57,760
then

00:09:56,240 --> 00:10:01,839
we'll talk about some future directions

00:09:57,760 --> 00:10:01,839
for uh jet verification in linux

00:10:02,240 --> 00:10:05,360
okay so starting off we'll talk and give

00:10:04,000 --> 00:10:07,519
an overview of how the bpf jets and

00:10:05,360 --> 00:10:09,600
linux work

00:10:07,519 --> 00:10:10,880
so sort of reiterating reiterating what

00:10:09,600 --> 00:10:13,120
we saw earlier uh

00:10:10,880 --> 00:10:14,480
the vpf jet works by passing a dpf

00:10:13,120 --> 00:10:15,839
program to a verifier

00:10:14,480 --> 00:10:17,680
which passes it to the compiler which

00:10:15,839 --> 00:10:19,440
compiles its native code

00:10:17,680 --> 00:10:20,800
the key thing about this for jitterbug

00:10:19,440 --> 00:10:22,240
is that we're just focused on the

00:10:20,800 --> 00:10:23,519
correctness of the bpf jit

00:10:22,240 --> 00:10:25,600
and so for now we're assuming that the

00:10:23,519 --> 00:10:27,120
bpf verifier is correct so the jet

00:10:25,600 --> 00:10:28,480
compiler is allowed to

00:10:27,120 --> 00:10:30,839
trust that the program that it's

00:10:28,480 --> 00:10:32,640
compiling has already passed the vpf

00:10:30,839 --> 00:10:34,160
verifier

00:10:32,640 --> 00:10:36,079
so what exactly do these bpf jet

00:10:34,160 --> 00:10:37,279
compilers look like well you can think

00:10:36,079 --> 00:10:40,560
of the jet compiler

00:10:37,279 --> 00:10:42,880
as consisting of roughly three parts um

00:10:40,560 --> 00:10:44,480
so that i've shown here on the right so

00:10:42,880 --> 00:10:46,560
first digit has

00:10:44,480 --> 00:10:47,839
this emit prologue so that produces a

00:10:46,560 --> 00:10:50,000
native function prologue

00:10:47,839 --> 00:10:51,600
that can save the colony save registers

00:10:50,000 --> 00:10:54,000
and set up the bpf stack and

00:10:51,600 --> 00:10:55,600
do other initialization things like that

00:10:54,000 --> 00:10:57,600
the second thing the jit does

00:10:55,600 --> 00:10:59,519
is for each instruct each bpf

00:10:57,600 --> 00:11:01,440
instruction it compiles it to

00:10:59,519 --> 00:11:02,720
some sequence of native instructions and

00:11:01,440 --> 00:11:04,959
it does this separately for each

00:11:02,720 --> 00:11:06,959
individual bpf instruction so one bpf

00:11:04,959 --> 00:11:09,360
instruction at a time

00:11:06,959 --> 00:11:10,079
then at the end it emits some epilogue

00:11:09,360 --> 00:11:11,839
that does

00:11:10,079 --> 00:11:14,640
clean up of the bpf stack and setting of

00:11:11,839 --> 00:11:15,920
the return values etc so some other

00:11:14,640 --> 00:11:17,839
other things to note about these ppf

00:11:15,920 --> 00:11:19,680
chits first is that they do static

00:11:17,839 --> 00:11:21,760
register allocation

00:11:19,680 --> 00:11:22,800
so they map each bpf registers to some

00:11:21,760 --> 00:11:24,800
fixed piece of

00:11:22,800 --> 00:11:26,720
hardware state such as a hardware

00:11:24,800 --> 00:11:28,240
register

00:11:26,720 --> 00:11:29,920
they compile one vpf in stretch at a

00:11:28,240 --> 00:11:31,760
time and uh

00:11:29,920 --> 00:11:33,519
another uh feature of them is that

00:11:31,760 --> 00:11:34,959
because they have to compile bpf jump

00:11:33,519 --> 00:11:36,320
offsets into the corresponding native

00:11:34,959 --> 00:11:38,240
offsets it actually has to repeat the

00:11:36,320 --> 00:11:41,600
jit process until the generated

00:11:38,240 --> 00:11:42,079
image has converged okay so now we've

00:11:41,600 --> 00:11:44,880
seen

00:11:42,079 --> 00:11:46,160
what these bpf jets look like so what

00:11:44,880 --> 00:11:47,519
sort of things can go wrong

00:11:46,160 --> 00:11:50,720
when people are developing these bpf

00:11:47,519 --> 00:11:52,320
bits so first some background on the bpf

00:11:50,720 --> 00:11:53,040
jets and sort of the history and linux

00:11:52,320 --> 00:11:55,279
so what i've been

00:11:53,040 --> 00:11:56,720
calling bpf is actually evpn for

00:11:55,279 --> 00:11:58,399
extended bpf

00:11:56,720 --> 00:12:00,399
and jit support for various

00:11:58,399 --> 00:12:02,399
architectures for ebpf has been added

00:12:00,399 --> 00:12:04,959
roughly over the previous seven years

00:12:02,399 --> 00:12:05,920
so here's a timeline of uh the past

00:12:04,959 --> 00:12:08,320
seven years and

00:12:05,920 --> 00:12:11,600
what year the architecture uh legit for

00:12:08,320 --> 00:12:14,480
each architecture was first introduced

00:12:11,600 --> 00:12:15,519
so for for our uh case study we just

00:12:14,480 --> 00:12:18,320
looked at the uh

00:12:15,519 --> 00:12:19,920
jits for x86 arm and risk five the 32

00:12:18,320 --> 00:12:24,240
and 64 bit variants of each

00:12:19,920 --> 00:12:26,240
for six architectures so

00:12:24,240 --> 00:12:27,760
for these six architectures we manually

00:12:26,240 --> 00:12:28,399
went through all of the bug fixing

00:12:27,760 --> 00:12:31,200
commits

00:12:28,399 --> 00:12:32,480
uh for these existing bpf jets what we

00:12:31,200 --> 00:12:34,480
found is that there are 82

00:12:32,480 --> 00:12:36,560
a total of 82 jet correctness bugs

00:12:34,480 --> 00:12:37,680
across 41 commits during that

00:12:36,560 --> 00:12:39,839
time period that they were being

00:12:37,680 --> 00:12:42,160
developed and here we counted a

00:12:39,839 --> 00:12:44,240
correctness bug is legit produces wrong

00:12:42,160 --> 00:12:46,399
native code for a single bpf instruction

00:12:44,240 --> 00:12:48,399
so a single commit might fix multiple

00:12:46,399 --> 00:12:50,240
bugs

00:12:48,399 --> 00:12:52,000
what we did then is categorize these

00:12:50,240 --> 00:12:54,079
bugs by the type of bpf

00:12:52,000 --> 00:12:56,480
instruction that the bug affects so we

00:12:54,079 --> 00:12:59,600
were curious what types of instructions

00:12:56,480 --> 00:13:01,360
tend to be affected by bugs the most

00:12:59,600 --> 00:13:02,639
and what we found is that these bugs

00:13:01,360 --> 00:13:05,040
have occurred across all different types

00:13:02,639 --> 00:13:08,240
of bpf instructions so

00:13:05,040 --> 00:13:09,680
33 or just over a third or so of them

00:13:08,240 --> 00:13:11,680
or have been involved in alu or

00:13:09,680 --> 00:13:13,040
arithmetic instructions but we also see

00:13:11,680 --> 00:13:13,920
them across other types of instructions

00:13:13,040 --> 00:13:18,480
like memory

00:13:13,920 --> 00:13:18,480
jumps calls and prologue and epilogue

00:13:18,959 --> 00:13:22,399
of these 41 bug fixing commits that we

00:13:21,519 --> 00:13:24,959
looked at

00:13:22,399 --> 00:13:26,000
11 of them were bugs that we found that

00:13:24,959 --> 00:13:27,760
we fixed uh

00:13:26,000 --> 00:13:29,920
because we found them using by applying

00:13:27,760 --> 00:13:31,279
verification using theater bug

00:13:29,920 --> 00:13:33,120
and these are across a variety of

00:13:31,279 --> 00:13:34,560
different architectures um in the

00:13:33,120 --> 00:13:36,639
interest of time to give you an example

00:13:34,560 --> 00:13:39,279
of what bugs and bpf just can look like

00:13:36,639 --> 00:13:42,000
uh i will show you the details of just

00:13:39,279 --> 00:13:42,000
these first two

00:13:42,720 --> 00:13:46,399
so the first bug i'll talk about is a

00:13:44,079 --> 00:13:47,519
bug that was present in the 64-bit risk

00:13:46,399 --> 00:13:49,839
5j

00:13:47,519 --> 00:13:50,639
and the basic idea of what what happened

00:13:49,839 --> 00:13:53,839
with this bug

00:13:50,639 --> 00:13:55,920
is that bpf 32-bit has 32-bit alu

00:13:53,839 --> 00:13:57,839
instructions and the semantics of the

00:13:55,920 --> 00:14:00,839
bpf 32-bit instructions are that they

00:13:57,839 --> 00:14:04,320
zero extend the result to the 64-bit bpf

00:14:00,839 --> 00:14:05,680
register risk 5 64-bit also has 32-bit

00:14:04,320 --> 00:14:06,959
arithmetic instructions

00:14:05,680 --> 00:14:09,519
but on the other hand this one sign

00:14:06,959 --> 00:14:10,079
extends to 64-bit and so the bug was

00:14:09,519 --> 00:14:11,680
that

00:14:10,079 --> 00:14:14,800
this mismatch between the semantics of

00:14:11,680 --> 00:14:16,720
the bpf and risk-five instructions

00:14:14,800 --> 00:14:18,959
meant that the the jet would compute the

00:14:16,720 --> 00:14:21,279
wrong result when the results of the uh

00:14:18,959 --> 00:14:23,199
uh arithmetic construction was negative

00:14:21,279 --> 00:14:25,199
so here's an example uh

00:14:23,199 --> 00:14:27,360
of the jit code below that that shows

00:14:25,199 --> 00:14:30,560
the bug and what the introduces the fix

00:14:27,360 --> 00:14:31,760
so this is the bpf jit for 64 and 32-bit

00:14:30,560 --> 00:14:34,639
subtraction

00:14:31,760 --> 00:14:36,720
it either emits a risk 5 subtract

00:14:34,639 --> 00:14:38,880
instruction or a 32-bit subtraction

00:14:36,720 --> 00:14:40,560
instruction the sub w

00:14:38,880 --> 00:14:42,880
and then the fix for the bug is to add

00:14:40,560 --> 00:14:43,760
an additional check if it's not a 64-bit

00:14:42,880 --> 00:14:46,480
instruction

00:14:43,760 --> 00:14:48,320
then emit two extra instructions that

00:14:46,480 --> 00:14:50,000
zero extend the upper bits

00:14:48,320 --> 00:14:51,920
so this is an example of a bug where

00:14:50,000 --> 00:14:53,920
there's a semantic mismatch between the

00:14:51,920 --> 00:14:58,240
intended behavior of the bpf instruction

00:14:53,920 --> 00:15:00,160
and the actual compiled code so the

00:14:58,240 --> 00:15:02,399
second bug that i'll talk about

00:15:00,160 --> 00:15:03,839
is uh uh actually the bug that was

00:15:02,399 --> 00:15:05,120
present in that example that i showed at

00:15:03,839 --> 00:15:08,079
the beginning of the talk

00:15:05,120 --> 00:15:09,839
so this is from the 32-bit x86 j uh it's

00:15:08,079 --> 00:15:11,600
for the bpf instruction that loads the

00:15:09,839 --> 00:15:13,680
four byte value from memory

00:15:11,600 --> 00:15:15,519
and similar to the 32-bit arithmetic

00:15:13,680 --> 00:15:17,199
instructions the semantics of this

00:15:15,519 --> 00:15:18,800
instruction are to zero extend the upper

00:15:17,199 --> 00:15:20,160
32-bits

00:15:18,800 --> 00:15:22,079
so to understand a little bit more what

00:15:20,160 --> 00:15:23,839
the bug is you have to know that on

00:15:22,079 --> 00:15:26,880
32-bit x86

00:15:23,839 --> 00:15:28,480
it maps each bpf register to two x86

00:15:26,880 --> 00:15:30,079
registers and this is because bpf

00:15:28,480 --> 00:15:32,880
registers are 64-bit

00:15:30,079 --> 00:15:34,800
so it maps a 64-bit bpf register to two

00:15:32,880 --> 00:15:36,560
x86 registers one of which holds the

00:15:34,800 --> 00:15:38,240
high bits of the bpf register and one of

00:15:36,560 --> 00:15:41,360
which holds the low bits

00:15:38,240 --> 00:15:42,880
so does zero extend a bpf register uh on

00:15:41,360 --> 00:15:43,920
32 bit x86

00:15:42,880 --> 00:15:47,199
that means we have to set the

00:15:43,920 --> 00:15:48,639
corresponding x86 register to zero

00:15:47,199 --> 00:15:51,519
and the instruction that the jit tries

00:15:48,639 --> 00:15:52,399
to do uh to set these bits to zero in

00:15:51,519 --> 00:15:54,959
this example

00:15:52,399 --> 00:15:56,720
is this move l of a zero immediate into

00:15:54,959 --> 00:15:58,320
the whatever the high bits of whatever

00:15:56,720 --> 00:15:59,600
register corresponds to the high bits of

00:15:58,320 --> 00:16:01,519
the destination

00:15:59,600 --> 00:16:02,959
and the bug is that the jit doesn't

00:16:01,519 --> 00:16:06,320
correctly encode uh

00:16:02,959 --> 00:16:08,959
this move immediate instruction

00:16:06,320 --> 00:16:10,800
so to see exactly why uh let's i'll dig

00:16:08,959 --> 00:16:13,680
into the details of this line of code

00:16:10,800 --> 00:16:14,320
so emit three that's just a macro that

00:16:13,680 --> 00:16:17,519
emits

00:16:14,320 --> 00:16:19,279
three bytes of raw x86 instruction um so

00:16:17,519 --> 00:16:21,519
the first byte is a c7

00:16:19,279 --> 00:16:23,839
that's just the op code for moving a

00:16:21,519 --> 00:16:26,800
32-bit media into a destination register

00:16:23,839 --> 00:16:28,480
that's fine the second is this add

00:16:26,800 --> 00:16:30,079
underscore one reg

00:16:28,480 --> 00:16:31,839
this is a byte that encodes the

00:16:30,079 --> 00:16:34,480
destination register if you're familiar

00:16:31,839 --> 00:16:38,399
with x86 encoding this is the mod r

00:16:34,480 --> 00:16:40,079
m byte and the last uh byte this zero is

00:16:38,399 --> 00:16:42,560
one byte of the immediate

00:16:40,079 --> 00:16:43,839
so the bug is that this x86 instruction

00:16:42,560 --> 00:16:45,680
expects there to be four bytes of

00:16:43,839 --> 00:16:48,160
immediate at the end of the instruction

00:16:45,680 --> 00:16:50,240
um but the jit only encodes one binder

00:16:48,160 --> 00:16:52,320
media this first zero so what will

00:16:50,240 --> 00:16:53,519
happen if you try and execute this code

00:16:52,320 --> 00:16:55,040
is that the first three bytes of

00:16:53,519 --> 00:16:55,680
whatever instruction follows this in

00:16:55,040 --> 00:16:57,440
memory

00:16:55,680 --> 00:16:58,880
will be swallowed as the immediate and

00:16:57,440 --> 00:17:00,320
then that will break the entire stream

00:16:58,880 --> 00:17:03,440
of x86 instruction

00:17:00,320 --> 00:17:05,360
which isn't great so the fix that we did

00:17:03,440 --> 00:17:06,799
was uh to use an xor of the register

00:17:05,360 --> 00:17:09,199
with itself instead

00:17:06,799 --> 00:17:10,959
this is uh uses the correct encoding it

00:17:09,199 --> 00:17:12,880
uses only two bytes instead of six

00:17:10,959 --> 00:17:14,799
that are required for the correct uh

00:17:12,880 --> 00:17:16,880
move immediate and it's actually the

00:17:14,799 --> 00:17:20,160
uh like canonical way of clearing a

00:17:16,880 --> 00:17:20,160
register on x86

00:17:21,439 --> 00:17:25,199
okay so we've seen some examples of bugs

00:17:23,520 --> 00:17:26,959
that can happen in bpf jets

00:17:25,199 --> 00:17:28,480
so now let's see how we can write a

00:17:26,959 --> 00:17:30,960
specification that can rule out these

00:17:28,480 --> 00:17:32,720
types of bugs

00:17:30,960 --> 00:17:34,400
the main question is how do we write

00:17:32,720 --> 00:17:35,039
down a spec that systematically rules

00:17:34,400 --> 00:17:36,480
out

00:17:35,039 --> 00:17:38,400
various different types of bugs that can

00:17:36,480 --> 00:17:39,840
occur in bpfjs so we want to rule out

00:17:38,400 --> 00:17:40,960
encoding bugs like the one that we saw

00:17:39,840 --> 00:17:42,640
in x86

00:17:40,960 --> 00:17:44,799
as well as semantics bugs like the one

00:17:42,640 --> 00:17:48,160
like the one we saw in risk five

00:17:44,799 --> 00:17:49,600
as well as others um and we want to rule

00:17:48,160 --> 00:17:51,200
them out for a variety of bpf

00:17:49,600 --> 00:17:53,200
instruction types

00:17:51,200 --> 00:17:54,640
and the main questions here first what

00:17:53,200 --> 00:17:56,000
does git correctness even mean in this

00:17:54,640 --> 00:17:57,520
context

00:17:56,000 --> 00:17:59,280
and second is how do we prove that the

00:17:57,520 --> 00:18:01,840
implementation meets the specification

00:17:59,280 --> 00:18:01,840
that we've written down

00:18:02,240 --> 00:18:05,280
so the high-level picture of the

00:18:03,440 --> 00:18:06,880
specification that jitterbug uses

00:18:05,280 --> 00:18:09,280
is this property that we call end-to-end

00:18:06,880 --> 00:18:12,000
correctness and what this says is that

00:18:09,280 --> 00:18:13,679
for any possible valid bpf program if

00:18:12,000 --> 00:18:15,840
you compile that vpf program

00:18:13,679 --> 00:18:17,039
down to some native instructions so a

00:18:15,840 --> 00:18:18,640
compiled program

00:18:17,039 --> 00:18:20,400
and then you provide the same input to

00:18:18,640 --> 00:18:21,200
the bpf program and to the compiled

00:18:20,400 --> 00:18:23,039
program

00:18:21,200 --> 00:18:24,400
then they should produce the same output

00:18:23,039 --> 00:18:25,280
that is they should produce the same

00:18:24,400 --> 00:18:26,320
return value

00:18:25,280 --> 00:18:27,919
and then they should also produce the

00:18:26,320 --> 00:18:30,160
same trace of events so that's the

00:18:27,919 --> 00:18:31,520
sequence of memory loads and stores or

00:18:30,160 --> 00:18:32,480
function calls to the kernel that the

00:18:31,520 --> 00:18:34,000
program performed

00:18:32,480 --> 00:18:35,840
so basically anything that's externally

00:18:34,000 --> 00:18:37,600
visible

00:18:35,840 --> 00:18:39,200
and the nice thing about this spec is

00:18:37,600 --> 00:18:40,960
that it's very abstract it doesn't talk

00:18:39,200 --> 00:18:42,799
about the details of individual bpf

00:18:40,960 --> 00:18:44,400
instructions or anything like that

00:18:42,799 --> 00:18:45,840
you can convince yourself that a jit

00:18:44,400 --> 00:18:47,280
that satisfies this property is

00:18:45,840 --> 00:18:50,400
correctly compiling ppf

00:18:47,280 --> 00:18:51,120
programs but the thing that's difficult

00:18:50,400 --> 00:18:53,280
about this

00:18:51,120 --> 00:18:54,640
is that it's quite hard to prove this

00:18:53,280 --> 00:18:56,160
directly at least

00:18:54,640 --> 00:18:58,080
because we can't enumerate all bpf

00:18:56,160 --> 00:18:59,280
programs or even if we could it would

00:18:58,080 --> 00:19:02,240
probably take an extremely

00:18:59,280 --> 00:19:02,240
extremely long time

00:19:02,799 --> 00:19:06,559
so what jitterbug does instead is breaks

00:19:05,200 --> 00:19:07,120
down this end to end correctness

00:19:06,559 --> 00:19:08,799
property

00:19:07,120 --> 00:19:10,960
into three different parts that together

00:19:08,799 --> 00:19:12,559
imply the end to end correctness

00:19:10,960 --> 00:19:14,559
so the first part is this thing called

00:19:12,559 --> 00:19:15,520
prolog correctness and all this says is

00:19:14,559 --> 00:19:17,840
that the

00:19:15,520 --> 00:19:20,000
prologue correctly sets up the bpf state

00:19:17,840 --> 00:19:21,679
so it correctly sets up the vpf stack

00:19:20,000 --> 00:19:23,360
and it correctly saves any collision

00:19:21,679 --> 00:19:25,440
registers

00:19:23,360 --> 00:19:26,720
the second part is what we call per

00:19:25,440 --> 00:19:28,799
instruction correctness

00:19:26,720 --> 00:19:29,840
and that means for any individual single

00:19:28,799 --> 00:19:31,360
bpf instruction

00:19:29,840 --> 00:19:34,000
the jit will produce the correct machine

00:19:31,360 --> 00:19:35,200
code and then lastly we have epilogue

00:19:34,000 --> 00:19:36,880
practice so that's that the j

00:19:35,200 --> 00:19:39,120
epilogue tears down the bpf state

00:19:36,880 --> 00:19:41,440
correctly and sets the return value

00:19:39,120 --> 00:19:42,960
so this is still very abstract so let me

00:19:41,440 --> 00:19:46,880
tell you exactly what i mean

00:19:42,960 --> 00:19:46,880
by the per instruction correctness

00:19:47,360 --> 00:19:51,039
so per instruction correctness what you

00:19:49,440 --> 00:19:52,559
can think of it is doing is exploiting

00:19:51,039 --> 00:19:54,080
the per-instruction nature of the jet

00:19:52,559 --> 00:19:56,080
compilers so recall that the jig

00:19:54,080 --> 00:19:57,440
compilers compile bpf programs one

00:19:56,080 --> 00:19:58,799
instruction at a time

00:19:57,440 --> 00:20:00,480
so it follows that we would want to

00:19:58,799 --> 00:20:02,400
reason about these bpf jet compilers one

00:20:00,480 --> 00:20:04,559
bpf instruction at the time

00:20:02,400 --> 00:20:06,240
so what print structure correctness says

00:20:04,559 --> 00:20:07,280
is that if you have some arbitrary bpf

00:20:06,240 --> 00:20:09,440
program state

00:20:07,280 --> 00:20:11,360
and some arbitrary native machine code

00:20:09,440 --> 00:20:11,919
state and those states are related in

00:20:11,360 --> 00:20:13,760
some way

00:20:11,919 --> 00:20:15,520
and i'll describe what i mean if by

00:20:13,760 --> 00:20:17,600
related uh later on

00:20:15,520 --> 00:20:19,520
but if they're related in some way and

00:20:17,600 --> 00:20:21,520
you execute the bpf instruction

00:20:19,520 --> 00:20:22,880
and you execute the result of the jit on

00:20:21,520 --> 00:20:23,840
that instruction so the compiled

00:20:22,880 --> 00:20:25,200
instructions

00:20:23,840 --> 00:20:27,360
you should produce two states which are

00:20:25,200 --> 00:20:29,600
again related so this side this

00:20:27,360 --> 00:20:31,120
uh this idea is nicer than the end to

00:20:29,600 --> 00:20:32,480
end correctness one because

00:20:31,120 --> 00:20:34,159
we only have to reason about a single

00:20:32,480 --> 00:20:37,200
bpf instruction at the time

00:20:34,159 --> 00:20:39,840
which we definitely can uh is

00:20:37,200 --> 00:20:41,440
simpler to reason about but even this

00:20:39,840 --> 00:20:43,039
hides a lot of the complexity

00:20:41,440 --> 00:20:46,559
that is actually involved with trying to

00:20:43,039 --> 00:20:47,760
prove uh vpfj correctness

00:20:46,559 --> 00:20:49,440
so there are several things that make

00:20:47,760 --> 00:20:49,840
jet correctness hard in the context of

00:20:49,440 --> 00:20:52,320
the

00:20:49,840 --> 00:20:54,720
jets in the linux journal so first is

00:20:52,320 --> 00:20:56,880
that the jit itself can contain branches

00:20:54,720 --> 00:20:59,360
so uh here on the right is another

00:20:56,880 --> 00:21:02,320
snippet from the 32-bit x86 jet

00:20:59,360 --> 00:21:03,679
for storing a value to memory and just

00:21:02,320 --> 00:21:04,320
in this one example for this one

00:21:03,679 --> 00:21:05,679
instruction

00:21:04,320 --> 00:21:07,840
there's at least seven different

00:21:05,679 --> 00:21:09,120
branches in the jet code in the jit

00:21:07,840 --> 00:21:10,720
itself

00:21:09,120 --> 00:21:12,720
and so that means there's many possible

00:21:10,720 --> 00:21:14,559
paths through this code to consider

00:21:12,720 --> 00:21:16,080
and the jit should be correct for all

00:21:14,559 --> 00:21:18,159
possible paths

00:21:16,080 --> 00:21:19,919
that through this code that get taken

00:21:18,159 --> 00:21:21,600
and the number of paths can

00:21:19,919 --> 00:21:22,880
can grow quite quickly since the number

00:21:21,600 --> 00:21:25,120
of paths in general is going to be

00:21:22,880 --> 00:21:27,760
exponential in the number of branches

00:21:25,120 --> 00:21:29,679
so this makes it complex to verify the

00:21:27,760 --> 00:21:30,880
bpf

00:21:29,679 --> 00:21:32,720
the second thing that makes jet

00:21:30,880 --> 00:21:35,200
correctness hard is that

00:21:32,720 --> 00:21:37,200
the jit can produce code that the native

00:21:35,200 --> 00:21:39,200
code itself contains branches

00:21:37,200 --> 00:21:41,039
so this is an example on the right for

00:21:39,200 --> 00:21:44,320
the 32-bit risk 5j

00:21:41,039 --> 00:21:46,559
for a 64-bit left shift by register

00:21:44,320 --> 00:21:47,919
so things to note here are that this

00:21:46,559 --> 00:21:49,360
code that it generates actually has

00:21:47,919 --> 00:21:50,480
branches

00:21:49,360 --> 00:21:52,000
you don't have to understand exactly

00:21:50,480 --> 00:21:53,360
what the branches are doing but the high

00:21:52,000 --> 00:21:54,960
level idea is that uh

00:21:53,360 --> 00:21:56,559
it's branching on the amount of that it

00:21:54,960 --> 00:21:59,600
has to shift by so that it can emulate

00:21:56,559 --> 00:22:02,159
64-bit shifts using 32-bit hardware

00:21:59,600 --> 00:22:03,919
and similarly to the branches in the jit

00:22:02,159 --> 00:22:06,400
the this code should be correct

00:22:03,919 --> 00:22:07,919
for all possible paths uh through this

00:22:06,400 --> 00:22:10,080
uh through the generated code

00:22:07,919 --> 00:22:11,440
so for all possible uh sequence of jumps

00:22:10,080 --> 00:22:13,120
that you take

00:22:11,440 --> 00:22:15,600
and this complexity sort of stacks on

00:22:13,120 --> 00:22:18,880
top of the complexity introduced by the

00:22:15,600 --> 00:22:18,880
branches in the jit itself

00:22:19,840 --> 00:22:23,760
so lastly as we actually have to see

00:22:21,600 --> 00:22:25,360
what we mean uh by this

00:22:23,760 --> 00:22:27,039
when we say that the bpf and the heart

00:22:25,360 --> 00:22:28,880
and the native states are related

00:22:27,039 --> 00:22:30,159
so we need some way of mapping the bpf

00:22:28,880 --> 00:22:32,559
state onto the

00:22:30,159 --> 00:22:34,320
machine state and in jitterbug we break

00:22:32,559 --> 00:22:35,440
this down into roughly three into three

00:22:34,320 --> 00:22:37,919
components

00:22:35,440 --> 00:22:39,600
so the first is how to map bpf registers

00:22:37,919 --> 00:22:41,919
onto hardware

00:22:39,600 --> 00:22:43,679
for some architectures this mapping is

00:22:41,919 --> 00:22:45,360
simple it's just a one-to-one bpf

00:22:43,679 --> 00:22:47,520
registers to hardware registers

00:22:45,360 --> 00:22:49,440
but in some architectures like 32-bit

00:22:47,520 --> 00:22:52,000
architectures each bpf register might

00:22:49,440 --> 00:22:53,679
have to map to multiple target registers

00:22:52,000 --> 00:22:55,200
or if there aren't even enough of those

00:22:53,679 --> 00:22:56,559
it might have to map to locations on the

00:22:55,200 --> 00:22:57,840
stack that are loaded and saved to

00:22:56,559 --> 00:22:59,520
temporaries as needed

00:22:57,840 --> 00:23:01,840
so that makes it difficult to specify

00:22:59,520 --> 00:23:03,679
the register mapping

00:23:01,840 --> 00:23:05,919
second in order to know that we've

00:23:03,679 --> 00:23:07,280
compiled bpf jump instructions correctly

00:23:05,919 --> 00:23:09,600
we have to have some way of mapping the

00:23:07,280 --> 00:23:10,559
bpf program counter onto the program

00:23:09,600 --> 00:23:13,039
counter of the

00:23:10,559 --> 00:23:15,039
dative machine and this is difficult

00:23:13,039 --> 00:23:16,799
because each bpf instruction

00:23:15,039 --> 00:23:18,159
can be compiled to a variable number of

00:23:16,799 --> 00:23:20,240
target instructions

00:23:18,159 --> 00:23:22,320
so this mapping from bpf program counter

00:23:20,240 --> 00:23:24,720
to machine program counter

00:23:22,320 --> 00:23:26,320
isn't uh just some scale and offset it's

00:23:24,720 --> 00:23:28,559
it's non-linear and so we have to have

00:23:26,320 --> 00:23:30,799
some way of specifying that too

00:23:28,559 --> 00:23:32,559
and lastly we have to specify uh how the

00:23:30,799 --> 00:23:35,600
bpf memory maps onto

00:23:32,559 --> 00:23:37,280
actual uh memory for the native code

00:23:35,600 --> 00:23:39,440
and this is difficult because ppf

00:23:37,280 --> 00:23:41,039
programs can have variable stack sizes

00:23:39,440 --> 00:23:42,880
and legit should be correct regardless

00:23:41,039 --> 00:23:46,320
of what the stack size is

00:23:42,880 --> 00:23:48,000
and the bpf jet stack

00:23:46,320 --> 00:23:49,520
should not overlap with any stack

00:23:48,000 --> 00:23:51,919
locations used by the jet

00:23:49,520 --> 00:23:53,200
so the bpf has a stack itself and the

00:23:51,919 --> 00:23:57,039
jit has a stack and

00:23:53,200 --> 00:23:57,039
those regions have to be disjoined

00:23:58,080 --> 00:24:01,200
okay so now we've seen an overview of

00:24:00,320 --> 00:24:03,520
jitterbug's

00:24:01,200 --> 00:24:04,240
jit specification and why it's hard so

00:24:03,520 --> 00:24:06,000
now i'll show

00:24:04,240 --> 00:24:07,440
how developers actually use data bug and

00:24:06,000 --> 00:24:09,840
what developers have to provide in order

00:24:07,440 --> 00:24:09,840
to use it

00:24:09,919 --> 00:24:13,520
so this is the high level overview of

00:24:12,480 --> 00:24:15,039
how uh

00:24:13,520 --> 00:24:17,120
how jitterbug proves straight

00:24:15,039 --> 00:24:19,520
correctness so it starts

00:24:17,120 --> 00:24:21,039
at this uh this top left bpf instruction

00:24:19,520 --> 00:24:22,720
it starts with a symbolic bpf

00:24:21,039 --> 00:24:25,120
instruction which you can think about as

00:24:22,720 --> 00:24:26,799
representing any possible arbitrary bpf

00:24:25,120 --> 00:24:28,799
instruction

00:24:26,799 --> 00:24:30,000
the next thing that jitterbug does is it

00:24:28,799 --> 00:24:30,799
does a process called symbolic

00:24:30,000 --> 00:24:32,799
evaluation

00:24:30,799 --> 00:24:34,400
on the implementation of the jit to

00:24:32,799 --> 00:24:35,200
produce a set of symbolic machine

00:24:34,400 --> 00:24:36,880
instructions

00:24:35,200 --> 00:24:38,799
so you can think of what this is doing

00:24:36,880 --> 00:24:39,919
as exploring all paths of the jit

00:24:38,799 --> 00:24:41,440
implementation

00:24:39,919 --> 00:24:42,960
and coming up with a set of all the

00:24:41,440 --> 00:24:45,520
possible machine instructions that the

00:24:42,960 --> 00:24:47,440
ppf jet could generate

00:24:45,520 --> 00:24:49,760
now we have a bpf symbolic bpf

00:24:47,440 --> 00:24:51,279
instruction and a corresponding set of

00:24:49,760 --> 00:24:53,520
possible machine instructions that are

00:24:51,279 --> 00:24:55,440
compiled for that instruction

00:24:53,520 --> 00:24:57,760
the next thing we do is run symbolic

00:24:55,440 --> 00:24:59,440
evaluation of a bpf interpreter on the

00:24:57,760 --> 00:25:01,600
bpf instruction

00:24:59,440 --> 00:25:03,120
and what this does is reduces the vpf

00:25:01,600 --> 00:25:05,039
instruction to a set of logical

00:25:03,120 --> 00:25:06,960
constraints that represent the semantics

00:25:05,039 --> 00:25:09,279
of the bpf instruction

00:25:06,960 --> 00:25:10,880
similarly we symbolically evaluate a

00:25:09,279 --> 00:25:13,520
machine interpreter on a set of machine

00:25:10,880 --> 00:25:16,400
instructions that we obtain from the jet

00:25:13,520 --> 00:25:19,520
so what we end up with now is to

00:25:16,400 --> 00:25:20,880
formulate two formulations so we have a

00:25:19,520 --> 00:25:22,880
logical formula representing the

00:25:20,880 --> 00:25:24,400
semantics of the ppf instruction

00:25:22,880 --> 00:25:26,400
and we have a formula representing the

00:25:24,400 --> 00:25:28,320
semantics of the machine instructions

00:25:26,400 --> 00:25:29,919
so we feed them into our uh our

00:25:28,320 --> 00:25:31,520
functional incorrectness or per

00:25:29,919 --> 00:25:33,200
instruction correctness definition

00:25:31,520 --> 00:25:35,360
and ask an smt solver to prove that

00:25:33,200 --> 00:25:38,400
they're equivalent

00:25:35,360 --> 00:25:39,840
so in order to use uh this whole process

00:25:38,400 --> 00:25:41,440
what does a jet developer actually have

00:25:39,840 --> 00:25:42,559
to provide so

00:25:41,440 --> 00:25:44,080
they have to provide these things that

00:25:42,559 --> 00:25:45,039
are in these shaded boxes it's four

00:25:44,080 --> 00:25:46,880
different things

00:25:45,039 --> 00:25:48,799
um so the first is that they have to

00:25:46,880 --> 00:25:50,799
provide an implementation of the jit in

00:25:48,799 --> 00:25:52,480
jitterbug's dsl

00:25:50,799 --> 00:25:54,320
second they have to provide a symbolic

00:25:52,480 --> 00:25:55,840
interpreter for the machine instructions

00:25:54,320 --> 00:25:58,320
for the architecture that the jit is

00:25:55,840 --> 00:26:00,320
targeting third they have to provide

00:25:58,320 --> 00:26:02,400
bits that architecture specific state

00:26:00,320 --> 00:26:04,159
mapping that i described earlier

00:26:02,400 --> 00:26:05,679
and then lastly they can provide any

00:26:04,159 --> 00:26:07,120
additional architecture specific

00:26:05,679 --> 00:26:08,559
invariants that they might have

00:26:07,120 --> 00:26:10,720
so things that don't have to do

00:26:08,559 --> 00:26:14,640
specifically with bpf but need to be

00:26:10,720 --> 00:26:14,640
maintained anyways like stack alignment

00:26:14,799 --> 00:26:20,080
i'll show you the details of what these

00:26:16,799 --> 00:26:23,200
first three actually look like

00:26:20,080 --> 00:26:25,039
so first is digital implementation so as

00:26:23,200 --> 00:26:26,320
i said earlier jitterbug introduces a

00:26:25,039 --> 00:26:28,559
domain-specific language for

00:26:26,320 --> 00:26:29,919
implementing and verifying vpf jets

00:26:28,559 --> 00:26:31,679
so it's a subset of the rosette

00:26:29,919 --> 00:26:32,400
programming language with a one-to-one

00:26:31,679 --> 00:26:34,720
mapping to c

00:26:32,400 --> 00:26:36,240
code and roset is a programming language

00:26:34,720 --> 00:26:38,000
that makes it easy to write symbolic

00:26:36,240 --> 00:26:39,520
reasoning tools

00:26:38,000 --> 00:26:41,200
and the reason we choose this is because

00:26:39,520 --> 00:26:43,039
it allows us to have finer grain control

00:26:41,200 --> 00:26:44,880
over the symbolic evaluation process

00:26:43,039 --> 00:26:47,679
which helps us scale the verification to

00:26:44,880 --> 00:26:50,080
that uh to actually work

00:26:47,679 --> 00:26:51,200
for the new risk for 32-bit chip we do

00:26:50,080 --> 00:26:53,039
automated extraction

00:26:51,200 --> 00:26:54,640
from the dsl to the c code that's in

00:26:53,039 --> 00:26:56,000
linux

00:26:54,640 --> 00:26:57,840
and for existing jits we have to

00:26:56,000 --> 00:26:59,760
manually translate from the c code to

00:26:57,840 --> 00:27:01,440
the dsl for verification

00:26:59,760 --> 00:27:02,880
and as future work we'd like to be able

00:27:01,440 --> 00:27:04,080
to reason about the c code directly

00:27:02,880 --> 00:27:06,159
without having to do this manual

00:27:04,080 --> 00:27:09,360
translation work but for now uh we

00:27:06,159 --> 00:27:09,360
still manually translate them

00:27:09,840 --> 00:27:13,360
so here's an example of uh what the code

00:27:11,840 --> 00:27:15,600
actually looks like so here's a snippet

00:27:13,360 --> 00:27:18,480
from the risk 532 widget

00:27:15,600 --> 00:27:20,080
on the left is the dsl code so rosette

00:27:18,480 --> 00:27:21,600
is built in fracking and bracket is a

00:27:20,080 --> 00:27:23,200
dialect of lisp and so that's where all

00:27:21,600 --> 00:27:24,159
of these parentheses and brackets come

00:27:23,200 --> 00:27:25,760
from

00:27:24,159 --> 00:27:27,679
but the thing to note is that this

00:27:25,760 --> 00:27:29,840
mapping is largely one-to-one with the c

00:27:27,679 --> 00:27:32,080
code so you can see this is the code for

00:27:29,840 --> 00:27:34,240
uh 64-bit shift on risk five

00:27:32,080 --> 00:27:36,000
and the code looks very looks slightly

00:27:34,240 --> 00:27:38,559
different but the mapping from c code to

00:27:36,000 --> 00:27:40,720
dsl is actually fairly straightforward

00:27:38,559 --> 00:27:42,640
so for this example for the 32-bit risk

00:27:40,720 --> 00:27:44,320
five kit we wrote the code on the right

00:27:42,640 --> 00:27:45,840
and verified that it was correct and

00:27:44,320 --> 00:27:49,679
then used our tool to automatically

00:27:45,840 --> 00:27:51,600
extract it into the code on the right

00:27:49,679 --> 00:27:53,279
for existing jits we have to sort of

00:27:51,600 --> 00:27:54,080
manually do the reverse process of

00:27:53,279 --> 00:27:56,320
starting with the c

00:27:54,080 --> 00:27:59,120
code and then porting it ourselves back

00:27:56,320 --> 00:27:59,120
into the dsl

00:27:59,840 --> 00:28:03,440
the second thing the bpf jet developer

00:28:02,399 --> 00:28:05,520
has to provide

00:28:03,440 --> 00:28:07,360
is an inter a machine interpreter for

00:28:05,520 --> 00:28:09,279
the instructions that the jet targets

00:28:07,360 --> 00:28:10,799
and this is so that jitterbug knows the

00:28:09,279 --> 00:28:12,399
semantics of the machine instructions

00:28:10,799 --> 00:28:13,840
that are produced by the jit

00:28:12,399 --> 00:28:15,360
to do that you have to write an

00:28:13,840 --> 00:28:16,399
interpreter for the machine instructions

00:28:15,360 --> 00:28:17,919
in rosette

00:28:16,399 --> 00:28:20,080
and then rosette automatically lifts it

00:28:17,919 --> 00:28:22,159
to work on symbolic instructions

00:28:20,080 --> 00:28:23,120
so as an example of what that looks like

00:28:22,159 --> 00:28:25,120
here's the

00:28:23,120 --> 00:28:27,279
a snippet of the machine interpreter for

00:28:25,120 --> 00:28:28,559
the risc-5 architecture for the add

00:28:27,279 --> 00:28:31,039
instruction

00:28:28,559 --> 00:28:32,640
so we start by defining a struct cpu

00:28:31,039 --> 00:28:34,880
that holds all the relevant risk five

00:28:32,640 --> 00:28:36,960
cpu state such as a program counter and

00:28:34,880 --> 00:28:38,799
some general purpose registers

00:28:36,960 --> 00:28:40,000
um we define this function for

00:28:38,799 --> 00:28:42,080
interpreting an ad

00:28:40,000 --> 00:28:43,840
instruction that takes a cpu a

00:28:42,080 --> 00:28:44,880
destination register and two source

00:28:43,840 --> 00:28:46,880
registers

00:28:44,880 --> 00:28:48,480
and it sets the destination general

00:28:46,880 --> 00:28:50,880
purpose register to the result of the

00:28:48,480 --> 00:28:53,760
sum of the two source registers

00:28:50,880 --> 00:28:55,279
and then skips to the next instruction

00:28:53,760 --> 00:28:57,440
to interpret and hold pro

00:28:55,279 --> 00:28:58,960
to interpret the whole program we obtain

00:28:57,440 --> 00:29:00,720
the current program counter

00:28:58,960 --> 00:29:02,080
fetch the instruction at the program

00:29:00,720 --> 00:29:03,520
counter from the program

00:29:02,080 --> 00:29:05,039
and then condition off of what type of

00:29:03,520 --> 00:29:06,480
instruction it is so if it's an ad

00:29:05,039 --> 00:29:08,799
instruction we can call the interpret

00:29:06,480 --> 00:29:10,480
add function we defined above

00:29:08,799 --> 00:29:12,320
and to scale this to work for an entire

00:29:10,480 --> 00:29:15,360
isa you simply repeat this process for

00:29:12,320 --> 00:29:16,799
every possible instruction

00:29:15,360 --> 00:29:19,200
so that's what machine interpreters look

00:29:16,799 --> 00:29:20,720
like in jitterbug

00:29:19,200 --> 00:29:22,399
lastly the developer has to provide a

00:29:20,720 --> 00:29:25,840
state mapping from the bpf state

00:29:22,399 --> 00:29:28,640
to the target state so

00:29:25,840 --> 00:29:30,080
this comprises registers uh program

00:29:28,640 --> 00:29:32,480
counter and memory

00:29:30,080 --> 00:29:33,279
so as an example uh for the risk 532

00:29:32,480 --> 00:29:36,000
registers

00:29:33,279 --> 00:29:36,960
each bpf register has to map to two risk

00:29:36,000 --> 00:29:39,200
five registers

00:29:36,960 --> 00:29:40,320
uh or to a spilled region register

00:29:39,200 --> 00:29:42,399
region on the stack

00:29:40,320 --> 00:29:43,840
so here's a little visual uh diagram

00:29:42,399 --> 00:29:46,000
which represents uh

00:29:43,840 --> 00:29:47,440
the state mapping that's used uh by the

00:29:46,000 --> 00:29:49,600
risk 532j

00:29:47,440 --> 00:29:50,720
so on the top here is the set of bpf

00:29:49,600 --> 00:29:52,399
registers

00:29:50,720 --> 00:29:53,840
and then the bottom is the set of risk 5

00:29:52,399 --> 00:29:55,600
registers used by the jit

00:29:53,840 --> 00:29:58,159
as well as a little diagram representing

00:29:55,600 --> 00:30:00,960
the stack layout during j execution

00:29:58,159 --> 00:30:01,279
so commonly used bpf registers like r0

00:30:00,960 --> 00:30:04,880
through

00:30:01,279 --> 00:30:05,919
r5 each are mapped to two 32-bit risk

00:30:04,880 --> 00:30:07,440
five registers

00:30:05,919 --> 00:30:09,039
one of which holds the high bits of the

00:30:07,440 --> 00:30:10,880
bpf register and one of which holds the

00:30:09,039 --> 00:30:13,360
low bits

00:30:10,880 --> 00:30:15,279
other bpf registers are mapped to a

00:30:13,360 --> 00:30:16,640
special designated region on the stack

00:30:15,279 --> 00:30:18,240
that holds their values

00:30:16,640 --> 00:30:20,480
and then those are loaded and saved to

00:30:18,240 --> 00:30:22,320
temporaries as needed

00:30:20,480 --> 00:30:24,240
so in order to use kinderbug uh the

00:30:22,320 --> 00:30:25,520
developer has to specify what exactly

00:30:24,240 --> 00:30:28,320
what this mapping is in order for the

00:30:25,520 --> 00:30:28,320
code to be verified

00:30:30,720 --> 00:30:34,399
um so i've talked a little bit about

00:30:32,720 --> 00:30:36,000
using jderbug to find bugs

00:30:34,399 --> 00:30:37,760
but we've also used jitterbug for other

00:30:36,000 --> 00:30:39,600
purposes in finding bugs so for example

00:30:37,760 --> 00:30:41,679
we've developed and verified the new jit

00:30:39,600 --> 00:30:43,279
for risk of 32 that i described

00:30:41,679 --> 00:30:44,960
um we've also developed and verified

00:30:43,279 --> 00:30:47,200
optimizations for existing jets

00:30:44,960 --> 00:30:48,640
um so here's a list of some of the

00:30:47,200 --> 00:30:50,799
optimizations that we've developed

00:30:48,640 --> 00:30:52,960
but in the interest of time i'll leave

00:30:50,799 --> 00:30:54,080
it to to you to see the links or ask

00:30:52,960 --> 00:30:55,120
questions afterwards to

00:30:54,080 --> 00:30:57,840
hear the details about these

00:30:55,120 --> 00:30:57,840
optimizations

00:30:58,720 --> 00:31:01,360
okay so next we'll talk about the

00:30:59,919 --> 00:31:03,039
verification effort of developing

00:31:01,360 --> 00:31:05,120
jitterbug and importing and verifying

00:31:03,039 --> 00:31:07,919
the jits

00:31:05,120 --> 00:31:09,440
so jitterbug itself is roughly 2 200

00:31:07,919 --> 00:31:10,720
lines of rosette code

00:31:09,440 --> 00:31:11,760
this is excluding the machine

00:31:10,720 --> 00:31:13,039
interpreters and any

00:31:11,760 --> 00:31:15,519
architecture-specific

00:31:13,039 --> 00:31:17,440
specifications so this is just the core

00:31:15,519 --> 00:31:21,760
libraries and core specifications

00:31:17,440 --> 00:31:23,679
that jitterbug defines the risk 52j

00:31:21,760 --> 00:31:25,279
we co-developed it with jitterbug over

00:31:23,679 --> 00:31:27,039
the course of about 10 months of

00:31:25,279 --> 00:31:28,240
development and the risk of 32-bit has

00:31:27,039 --> 00:31:31,840
since been shipped with

00:31:28,240 --> 00:31:33,519
linux 5.7 we developed the jit

00:31:31,840 --> 00:31:35,840
specification and the proof technique

00:31:33,519 --> 00:31:37,039
together with the risk 532j

00:31:35,840 --> 00:31:39,360
and then once we were sure that it was

00:31:37,039 --> 00:31:41,200
reasonably stable um porting the other

00:31:39,360 --> 00:31:42,159
architectures to use the same spec and

00:31:41,200 --> 00:31:44,559
proof technique took

00:31:42,159 --> 00:31:46,159
roughly several weeks each and the jit

00:31:44,559 --> 00:31:47,039
optimizations took roughly several weeks

00:31:46,159 --> 00:31:49,679
each as well

00:31:47,039 --> 00:31:53,440
um between writing the optimization and

00:31:49,679 --> 00:31:53,440
interacting with kernel maintainers etc

00:31:54,240 --> 00:31:58,559
so here i've shown uh some lines of code

00:31:57,039 --> 00:31:59,200
that represent the jet verification

00:31:58,559 --> 00:32:01,840
effort

00:31:59,200 --> 00:32:03,440
so for each architecture i show the the

00:32:01,840 --> 00:32:03,919
lines of code of the implementation for

00:32:03,440 --> 00:32:06,240
the c

00:32:03,919 --> 00:32:08,399
and the dsl as well as the lines of code

00:32:06,240 --> 00:32:10,000
of the specification so the

00:32:08,399 --> 00:32:11,519
specific specification as well as the

00:32:10,000 --> 00:32:13,600
machine interpreter

00:32:11,519 --> 00:32:15,279
so the main effort in verifying these

00:32:13,600 --> 00:32:17,120
jits is actually in writing the machine

00:32:15,279 --> 00:32:20,000
interpreter

00:32:17,120 --> 00:32:21,200
which is uh makes sense because there's

00:32:20,000 --> 00:32:22,320
lots of different types of instructions

00:32:21,200 --> 00:32:23,440
that you have to handle in the machine

00:32:22,320 --> 00:32:26,240
interpreter

00:32:23,440 --> 00:32:27,440
the effort to port the dsl from port to

00:32:26,240 --> 00:32:29,840
the dsl from the c

00:32:27,440 --> 00:32:30,880
code um and to write the jit specific

00:32:29,840 --> 00:32:32,480
specification is

00:32:30,880 --> 00:32:34,880
relatively small this is roughly three

00:32:32,480 --> 00:32:36,640
weeks each but there's added effort to

00:32:34,880 --> 00:32:37,279
keep the dsl code in sync with the c

00:32:36,640 --> 00:32:38,799
code

00:32:37,279 --> 00:32:40,399
so it's still sort of annoying to have

00:32:38,799 --> 00:32:42,159
to keep this uh to

00:32:40,399 --> 00:32:43,519
have to keep the dsl code around but for

00:32:42,159 --> 00:32:46,080
now it's necessary in order to do the

00:32:43,519 --> 00:32:46,080
verification

00:32:47,279 --> 00:32:51,840
um so secondly is about the verification

00:32:50,240 --> 00:32:53,279
performance so here what i've shown is

00:32:51,840 --> 00:32:55,600
for each architecture

00:32:53,279 --> 00:32:57,760
the verification time that it takes to

00:32:55,600 --> 00:32:58,320
verify a single bpf instructor a single

00:32:57,760 --> 00:33:00,960
uh

00:32:58,320 --> 00:33:02,640
opcode class of a bpf instruction and

00:33:00,960 --> 00:33:04,399
the verification time is usually less

00:33:02,640 --> 00:33:06,080
than one minute for one instruction

00:33:04,399 --> 00:33:07,760
which means you can get rapid feedback

00:33:06,080 --> 00:33:10,480
if you're developing a new optimization

00:33:07,760 --> 00:33:13,039
or fixing a bug or developing a new jet

00:33:10,480 --> 00:33:16,320
so that's uh that's that makes it easy

00:33:13,039 --> 00:33:16,320
to actually use verification

00:33:16,399 --> 00:33:22,480
okay so next i'll show a quick demo if i

00:33:19,200 --> 00:33:27,200
can figure out how to share my screen

00:33:22,480 --> 00:33:27,200
let's see actions

00:33:29,760 --> 00:33:33,440
um does anybody know where the share oh

00:33:32,720 --> 00:33:39,840
here we go

00:33:33,440 --> 00:33:39,840
sorry entire screen

00:33:43,440 --> 00:33:47,200
okay i believe my screen should be up

00:33:45,279 --> 00:33:50,399
now um

00:33:47,200 --> 00:33:53,760
someone should tell me if it's not

00:33:50,399 --> 00:33:56,000
it's visible perfect all right um

00:33:53,760 --> 00:33:57,279
okay so let me show you this uh this uh

00:33:56,000 --> 00:33:58,880
example so what and what i'm gonna

00:33:57,279 --> 00:33:59,519
demonstrate in this in this uh in this

00:33:58,880 --> 00:34:02,880
demo

00:33:59,519 --> 00:34:04,399
is uh how jitterbug finds the uh jit bug

00:34:02,880 --> 00:34:07,120
that i described earlier and that was

00:34:04,399 --> 00:34:08,879
found in the 64-bit risk five jet

00:34:07,120 --> 00:34:10,720
so the one that was with subtraction in

00:34:08,879 --> 00:34:13,200
the zero extension

00:34:10,720 --> 00:34:14,800
so here on the left i'm showing is the c

00:34:13,200 --> 00:34:15,599
code that corresponds to that

00:34:14,800 --> 00:34:17,280
instruction

00:34:15,599 --> 00:34:18,639
it's very similar to what i showed

00:34:17,280 --> 00:34:20,879
earlier in the slides

00:34:18,639 --> 00:34:21,679
so it emits either a risk five subtract

00:34:20,879 --> 00:34:24,480
or

00:34:21,679 --> 00:34:24,960
sub subtract uh 32-bit instruction and

00:34:24,480 --> 00:34:27,200
then

00:34:24,960 --> 00:34:29,440
this is actually the fixed code it also

00:34:27,200 --> 00:34:31,040
admits a zero extension if it's a 32-bit

00:34:29,440 --> 00:34:32,960
instruction

00:34:31,040 --> 00:34:34,639
on the right here is a corresponding dsl

00:34:32,960 --> 00:34:36,720
code that we manually ported

00:34:34,639 --> 00:34:38,240
um and it's you know a one to one

00:34:36,720 --> 00:34:38,879
translation between the c code and the

00:34:38,240 --> 00:34:40,399
dsl

00:34:38,879 --> 00:34:43,200
so it's the same set of instructions it

00:34:40,399 --> 00:34:46,320
does the same things um so to test

00:34:43,200 --> 00:34:47,679
uh the the verification for jitterbug

00:34:46,320 --> 00:34:49,359
i'll actually go ahead and comment out

00:34:47,679 --> 00:34:51,359
the bug fix um

00:34:49,359 --> 00:34:53,760
in order to artificially inject the bug

00:34:51,359 --> 00:34:56,159
and see if jeter bug is able to catch it

00:34:53,760 --> 00:34:58,879
uh so i've commented out the the bug

00:34:56,159 --> 00:34:58,879
let's go over here

00:34:58,960 --> 00:35:02,720
uh so what i'm gonna do is verify is ask

00:35:02,000 --> 00:35:05,440
jitterbug

00:35:02,720 --> 00:35:06,240
to verify the bpfj for this particular

00:35:05,440 --> 00:35:07,599
op code

00:35:06,240 --> 00:35:09,119
and what that means is it's going to try

00:35:07,599 --> 00:35:10,720
and prove that for all possible

00:35:09,119 --> 00:35:12,000
destination registers and for all

00:35:10,720 --> 00:35:13,440
possible source registers

00:35:12,000 --> 00:35:16,160
and for all possible values of those

00:35:13,440 --> 00:35:17,440
registers that the jit is correct

00:35:16,160 --> 00:35:19,200
it actually comes back and says that

00:35:17,440 --> 00:35:20,800
there has been a test failure which is

00:35:19,200 --> 00:35:22,400
good because we injected the bug

00:35:20,800 --> 00:35:24,880
so i'm glad it didn't accept it as

00:35:22,400 --> 00:35:26,240
correct um

00:35:24,880 --> 00:35:28,400
and what jitterbug tells us is a bunch

00:35:26,240 --> 00:35:30,240
of information that might help us debug

00:35:28,400 --> 00:35:31,440
what exactly went wrong so when

00:35:30,240 --> 00:35:33,200
verification fails

00:35:31,440 --> 00:35:35,599
jitterbug comes back with a concrete

00:35:33,200 --> 00:35:38,400
test case that you can use to figure out

00:35:35,599 --> 00:35:39,359
uh why the uh what the exactly the bug

00:35:38,400 --> 00:35:41,200
is

00:35:39,359 --> 00:35:42,960
so what databook tells us here it says

00:35:41,200 --> 00:35:44,320
first the bpf gets specification the

00:35:42,960 --> 00:35:46,480
final registers must match

00:35:44,320 --> 00:35:48,000
that means that the jitted code and the

00:35:46,480 --> 00:35:49,680
bpf instruction disagree

00:35:48,000 --> 00:35:51,359
on the value of some register for this

00:35:49,680 --> 00:35:53,520
instruction

00:35:51,359 --> 00:35:54,480
so the bpf instruction that's involved

00:35:53,520 --> 00:35:57,119
that it comes up with

00:35:54,480 --> 00:35:58,560
is an alu is a 32-bit arithmetic

00:35:57,119 --> 00:36:00,720
subtraction subtraction

00:35:58,560 --> 00:36:02,480
bp of x so subtract a register uh

00:36:00,720 --> 00:36:03,520
between r9 and r10 so it wants to

00:36:02,480 --> 00:36:06,400
subtract the value

00:36:03,520 --> 00:36:07,440
in our nine and uh r9 or in our 10 from

00:36:06,400 --> 00:36:09,040
r9

00:36:07,440 --> 00:36:10,400
and these are the bpf offset and

00:36:09,040 --> 00:36:13,119
immediate fields which aren't used for

00:36:10,400 --> 00:36:14,000
this instruction so they're just zero

00:36:13,119 --> 00:36:15,760
it'll also tell us what the

00:36:14,000 --> 00:36:17,599
corresponding risk five instruction is

00:36:15,760 --> 00:36:19,839
so it says it's using a sub w

00:36:17,599 --> 00:36:21,760
and then it has some uh encoded risk

00:36:19,839 --> 00:36:23,520
five registers corresponding to the bpf

00:36:21,760 --> 00:36:25,280
registers

00:36:23,520 --> 00:36:27,680
so what's actually really useful that

00:36:25,280 --> 00:36:30,000
when helping diagnose what this bug is

00:36:27,680 --> 00:36:31,680
is uh uh these next following things so

00:36:30,000 --> 00:36:33,839
first it'll tell us what the initial

00:36:31,680 --> 00:36:35,359
value of the bpf destination and source

00:36:33,839 --> 00:36:36,320
should be in order to demonstrate what

00:36:35,359 --> 00:36:38,480
the bug is

00:36:36,320 --> 00:36:41,119
so jitterbug is saying is suppose that

00:36:38,480 --> 00:36:44,640
initially r9 holds this value

00:36:41,119 --> 00:36:46,400
right here this fff7ffe

00:36:44,640 --> 00:36:49,920
and then suppose that r10 holds this

00:36:46,400 --> 00:36:51,599
value ffff7fff

00:36:49,920 --> 00:36:54,000
if we interpret the correct bpf

00:36:51,599 --> 00:36:55,680
semantics the result in r9 uh should

00:36:54,000 --> 00:36:57,119
be this so if you subtract these two

00:36:55,680 --> 00:36:59,440
using 32-bit arithmetic

00:36:57,119 --> 00:37:01,280
you get minus one and then if you zero

00:36:59,440 --> 00:37:03,680
extend that to 64 bits you get

00:37:01,280 --> 00:37:04,960
minus one in the first 32 bits and then

00:37:03,680 --> 00:37:07,839
all zeros in the upper

00:37:04,960 --> 00:37:09,760
in the upper 32 bits so this is the

00:37:07,839 --> 00:37:11,839
correct value that should be computed

00:37:09,760 --> 00:37:12,800
what jitterbug tells us is that uh for

00:37:11,839 --> 00:37:14,160
the jitted code

00:37:12,800 --> 00:37:16,560
this is the value that it finds in that

00:37:14,160 --> 00:37:18,400
register that actually finds all ones

00:37:16,560 --> 00:37:20,240
so this is actually uh can tell us that

00:37:18,400 --> 00:37:21,599
what's an idea of what's happening is

00:37:20,240 --> 00:37:23,119
that we're sign extending this value

00:37:21,599 --> 00:37:24,800
instead of zero extending it like we

00:37:23,119 --> 00:37:27,359
should

00:37:24,800 --> 00:37:29,119
so this is an example of how uh and if

00:37:27,359 --> 00:37:31,119
this was a real bug you could go

00:37:29,119 --> 00:37:32,720
and write a new linux kernel like

00:37:31,119 --> 00:37:34,160
self-test uh

00:37:32,720 --> 00:37:36,000
that sets up the registers in these

00:37:34,160 --> 00:37:37,440
values to

00:37:36,000 --> 00:37:39,119
to catch and demonstrate that it is

00:37:37,440 --> 00:37:41,599
actually a real bug and prevent it from

00:37:39,119 --> 00:37:44,640
regressing in the future

00:37:41,599 --> 00:37:47,520
so next i'll uncomment the bug

00:37:44,640 --> 00:37:48,960
or uncomment the bug fix and then go

00:37:47,520 --> 00:37:51,760
back and ask your book to verify it

00:37:48,960 --> 00:37:53,280
again

00:37:51,760 --> 00:37:56,160
let's see what it says hopefully it

00:37:53,280 --> 00:37:56,160
accepts it this time

00:37:56,800 --> 00:38:04,480
usually it takes about six seconds or so

00:37:59,920 --> 00:38:06,400
to finish solving

00:38:04,480 --> 00:38:08,000
great so it tells us that it actually

00:38:06,400 --> 00:38:09,040
successfully verified it and what that

00:38:08,000 --> 00:38:11,119
means is that

00:38:09,040 --> 00:38:13,200
this particular part of the jit code is

00:38:11,119 --> 00:38:15,040
correct for all possible destination

00:38:13,200 --> 00:38:18,079
source registers and initial values

00:38:15,040 --> 00:38:19,680
so we can move on to verifying the

00:38:18,079 --> 00:38:21,119
jit for other different types of bpf

00:38:19,680 --> 00:38:23,440
instruction off codes until we've done

00:38:21,119 --> 00:38:23,440
them all

00:38:25,680 --> 00:38:31,760
okay so that's the end of my my

00:38:28,720 --> 00:38:32,800
short demo next

00:38:31,760 --> 00:38:34,560
last thing i'll talk about is some

00:38:32,800 --> 00:38:37,599
future possible directions for jet

00:38:34,560 --> 00:38:37,599
verification of linux

00:38:38,320 --> 00:38:42,400
um so currently we have to manually

00:38:40,320 --> 00:38:43,760
translate uh the c code that's in linux

00:38:42,400 --> 00:38:45,040
into the jitterbug's dsl for

00:38:43,760 --> 00:38:46,640
verification

00:38:45,040 --> 00:38:48,000
and this is quite hard to maintain

00:38:46,640 --> 00:38:49,680
especially because the c code can be

00:38:48,000 --> 00:38:51,520
changing and so we have to

00:38:49,680 --> 00:38:53,599
maintain this mapping from the c code

00:38:51,520 --> 00:38:56,079
back into the dsl code

00:38:53,599 --> 00:38:57,680
and ideally we want jit developers to be

00:38:56,079 --> 00:38:59,599
able to verify the c code directly

00:38:57,680 --> 00:39:00,880
without knowing

00:38:59,599 --> 00:39:03,280
without needing to know how to write

00:39:00,880 --> 00:39:04,720
rosette code there's two main barriers

00:39:03,280 --> 00:39:06,480
to achieving this

00:39:04,720 --> 00:39:07,920
first is we need additional research on

00:39:06,480 --> 00:39:09,680
scaling automated verification or

00:39:07,920 --> 00:39:11,359
symbolic evaluation of c code

00:39:09,680 --> 00:39:13,359
and that's something that i'm still

00:39:11,359 --> 00:39:15,839
working on

00:39:13,359 --> 00:39:17,520
secondly is we need a common jit

00:39:15,839 --> 00:39:18,000
interface in the kernel that's amenable

00:39:17,520 --> 00:39:19,599
to

00:39:18,000 --> 00:39:22,000
the specification that we can actually

00:39:19,599 --> 00:39:23,839
plug the verification into

00:39:22,000 --> 00:39:25,200
um so to tell you exactly what i mean by

00:39:23,839 --> 00:39:26,240
that i'll describe an experience that we

00:39:25,200 --> 00:39:28,400
have when we're developing there's

00:39:26,240 --> 00:39:29,520
532-bit jet so

00:39:28,400 --> 00:39:31,520
when we were when we first started

00:39:29,520 --> 00:39:33,040
developing the risk 52j uh

00:39:31,520 --> 00:39:34,640
the sort of top-level interface to the

00:39:33,040 --> 00:39:36,800
bpf jit looks like this

00:39:34,640 --> 00:39:38,720
bpf in jit compile function that takes a

00:39:36,800 --> 00:39:39,359
whole bpf program and compiles it to a

00:39:38,720 --> 00:39:40,839
whole

00:39:39,359 --> 00:39:42,800
native function so it does the whole

00:39:40,839 --> 00:39:44,640
thing and

00:39:42,800 --> 00:39:46,160
uh this is kind of hard to use for

00:39:44,640 --> 00:39:46,720
verification for the same reason that

00:39:46,160 --> 00:39:48,079
the end

00:39:46,720 --> 00:39:49,760
and correctness that i described earlier

00:39:48,079 --> 00:39:51,839
is hard to directly prove

00:39:49,760 --> 00:39:53,040
so during the process of development we

00:39:51,839 --> 00:39:56,480
actually factored

00:39:53,040 --> 00:39:58,560
this function uh with the uh

00:39:56,480 --> 00:40:00,079
from the 64 and 32 bit risk five jets to

00:39:58,560 --> 00:40:01,920
actually be shared between them

00:40:00,079 --> 00:40:03,599
so now the top level interface that each

00:40:01,920 --> 00:40:05,520
each architecture has to provide

00:40:03,599 --> 00:40:07,520
is uh these three functions so build

00:40:05,520 --> 00:40:09,440
prolog emit one instruction and then

00:40:07,520 --> 00:40:11,440
build the epilogue

00:40:09,440 --> 00:40:12,800
and what's nice about this is a couple

00:40:11,440 --> 00:40:15,200
things is

00:40:12,800 --> 00:40:17,040
first this actually mirrors the

00:40:15,200 --> 00:40:19,200
breakdown of the specification that your

00:40:17,040 --> 00:40:20,880
debug uses into the prolog correctness

00:40:19,200 --> 00:40:22,160
the per instruction correctness and the

00:40:20,880 --> 00:40:23,680
epilogue practice

00:40:22,160 --> 00:40:25,359
and then also it means there's less code

00:40:23,680 --> 00:40:27,839
to maintain in linux because there's no

00:40:25,359 --> 00:40:29,040
uh duplication between the 64 and 32

00:40:27,839 --> 00:40:30,160
risk five bits

00:40:29,040 --> 00:40:32,000
and one thing that we think might be

00:40:30,160 --> 00:40:33,520
useful in the future is thinking if it's

00:40:32,000 --> 00:40:35,040
possible to factor this code uh

00:40:33,520 --> 00:40:37,359
across even other architectures at some

00:40:35,040 --> 00:40:38,000
point um so that not every jit has to

00:40:37,359 --> 00:40:39,920
re-implement

00:40:38,000 --> 00:40:41,440
uh roughly the same logic for building

00:40:39,920 --> 00:40:44,079
the body of the jit function

00:40:41,440 --> 00:40:45,359
etc and so that might make life easier

00:40:44,079 --> 00:40:46,640
for it's possible that might

00:40:45,359 --> 00:40:48,319
make life easier for maintainers and

00:40:46,640 --> 00:40:51,040
also easier to do the verification in a

00:40:48,319 --> 00:40:51,040
more automated way

00:40:51,280 --> 00:40:55,359
um so the last thing that i'll talk

00:40:53,200 --> 00:40:56,880
about is sort of what's next what what

00:40:55,359 --> 00:40:57,680
things might we want to look at uh in

00:40:56,880 --> 00:41:00,000
the future

00:40:57,680 --> 00:41:01,359
and one thing is the uh the bpf verifier

00:41:00,000 --> 00:41:02,880
that uh that we

00:41:01,359 --> 00:41:04,400
that i showed earlier so so far we've

00:41:02,880 --> 00:41:04,960
been trusting the bpf verifier to be

00:41:04,400 --> 00:41:06,640
correct

00:41:04,960 --> 00:41:09,280
which sort of simplifies the life of the

00:41:06,640 --> 00:41:10,640
bpf jet but the bpf verifier itself is

00:41:09,280 --> 00:41:13,040
also hard to get right

00:41:10,640 --> 00:41:13,920
and it's hard for uh there's a couple

00:41:13,040 --> 00:41:15,200
sort of

00:41:13,920 --> 00:41:16,960
symptoms of this the first is that

00:41:15,200 --> 00:41:18,079
sometimes the verifier accepts code that

00:41:16,960 --> 00:41:19,920
it should actually reject

00:41:18,079 --> 00:41:21,040
and the an example of this is that

00:41:19,920 --> 00:41:22,720
safety bugs have been found in the

00:41:21,040 --> 00:41:24,480
verifier in the past

00:41:22,720 --> 00:41:26,240
the second thing is that some a lot of

00:41:24,480 --> 00:41:28,000
the time verifier rejects code that is

00:41:26,240 --> 00:41:30,000
actually safe that it should accept

00:41:28,000 --> 00:41:32,319
and uh it can be very hard to actually

00:41:30,000 --> 00:41:34,000
get the verifier to accept a bpf program

00:41:32,319 --> 00:41:35,839
especially when you have complex

00:41:34,000 --> 00:41:37,680
interactions with llvm so it's

00:41:35,839 --> 00:41:39,359
possible you write some c code compile

00:41:37,680 --> 00:41:41,359
it to vpf uh

00:41:39,359 --> 00:41:42,720
it can be hard to make sure that it's in

00:41:41,359 --> 00:41:44,079
the right shape that'll be accepted by

00:41:42,720 --> 00:41:46,400
the bpa verifier

00:41:44,079 --> 00:41:47,599
so we haven't done anything on this yet

00:41:46,400 --> 00:41:49,119
but it could be interesting in the

00:41:47,599 --> 00:41:50,640
future to do more research on how to

00:41:49,119 --> 00:41:52,560
develop bpf verifiers that

00:41:50,640 --> 00:41:54,000
accept additional safe programs to make

00:41:52,560 --> 00:41:56,400
uh uh

00:41:54,000 --> 00:41:58,319
developer of bps programs lives easier

00:41:56,400 --> 00:42:00,880
but still rejecting the unsafe ones

00:41:58,319 --> 00:42:03,839
um so that could be an interesting line

00:42:00,880 --> 00:42:03,839
of future research

00:42:04,800 --> 00:42:09,040
so lastly i'll conclude by saying that

00:42:06,640 --> 00:42:10,640
jitterbug is a tool that we built um

00:42:09,040 --> 00:42:12,160
that allows developers to do automated

00:42:10,640 --> 00:42:14,000
verification to bpf kits

00:42:12,160 --> 00:42:16,240
and our experience has been effective at

00:42:14,000 --> 00:42:16,560
finding bugs in existing jets as well

00:42:16,240 --> 00:42:18,079
but

00:42:16,560 --> 00:42:20,720
as well as developing new jits and new

00:42:18,079 --> 00:42:23,040
optimizations and ideally uh

00:42:20,720 --> 00:42:24,960
uh after we've sort of sometime in the

00:42:23,040 --> 00:42:26,960
future it'll be integrated into the bpf

00:42:24,960 --> 00:42:29,119
development process um so all of our

00:42:26,960 --> 00:42:30,480
code is publicly available on github

00:42:29,119 --> 00:42:32,319
and i'd like to acknowledge all of these

00:42:30,480 --> 00:42:33,680
people for being uh for being kind

00:42:32,319 --> 00:42:36,079
enough to review all of our patches to

00:42:33,680 --> 00:42:38,000
linux so thank you

00:42:36,079 --> 00:42:40,400
and i will take any questions that

00:42:38,000 --> 00:42:40,400
people have

00:42:40,960 --> 00:42:44,560
so i've been saw you have some questions

00:42:42,880 --> 00:42:47,200
for luke and that's a good time to ask

00:42:44,560 --> 00:42:48,640
i actually have a quick question um one

00:42:47,200 --> 00:42:49,680
interesting class of bugs that i've

00:42:48,640 --> 00:42:53,280
actually had to fix

00:42:49,680 --> 00:42:56,079
uh involve uh

00:42:53,280 --> 00:42:58,560
branch offsets being not encoded

00:42:56,079 --> 00:43:02,000
correctly and contextually

00:42:58,560 --> 00:43:03,440
this would in order this is

00:43:02,000 --> 00:43:05,280
whether the bug triggers or not is

00:43:03,440 --> 00:43:08,079
depends upon the context of the

00:43:05,280 --> 00:43:10,079
totality of the bpf program such as this

00:43:08,079 --> 00:43:11,599
the total size of the bpf program can

00:43:10,079 --> 00:43:12,880
cause the branches to be encoded

00:43:11,599 --> 00:43:15,520
incorrectly or whatever

00:43:12,880 --> 00:43:16,319
uh is jitterbug able to evaluate and

00:43:15,520 --> 00:43:19,200
validate

00:43:16,319 --> 00:43:20,720
these kind of bugs yes i believe so so

00:43:19,200 --> 00:43:22,240
jitterbug when it's verifying the per

00:43:20,720 --> 00:43:23,520
instruction correctness it doesn't make

00:43:22,240 --> 00:43:25,200
any assumptions on the

00:43:23,520 --> 00:43:26,720
actual total size of the bpf program it

00:43:25,200 --> 00:43:28,960
assumes it could be anything

00:43:26,720 --> 00:43:31,040
and it assumes that the context offset

00:43:28,960 --> 00:43:31,520
mapping the mapping from bpf instruction

00:43:31,040 --> 00:43:33,440
to

00:43:31,520 --> 00:43:35,119
like native offset it assumes that

00:43:33,440 --> 00:43:36,640
mapping could be anything as well

00:43:35,119 --> 00:43:38,400
so in order to show that a bpf jump

00:43:36,640 --> 00:43:39,440
instruction is correct it actually has

00:43:38,400 --> 00:43:42,079
to be correct

00:43:39,440 --> 00:43:42,720
for any valid mapping from bpf to target

00:43:42,079 --> 00:43:44,319
instructions

00:43:42,720 --> 00:43:46,000
and so we've used this to actually find

00:43:44,319 --> 00:43:48,480
uh some existing ppf

00:43:46,000 --> 00:43:49,520
uh bug jit bugs in jump instructions so

00:43:48,480 --> 00:43:50,079
similar bugs to the ones that you

00:43:49,520 --> 00:43:52,640
described

00:43:50,079 --> 00:43:54,560
yeah i see that's great so logically

00:43:52,640 --> 00:43:55,040
it's testing the branch for all possible

00:43:54,560 --> 00:43:58,079
pc

00:43:55,040 --> 00:44:00,880
initial pc values yes yep yep

00:43:58,079 --> 00:44:02,400
cool uh paul shangnong says thanks great

00:44:00,880 --> 00:44:04,000
presentation you mentioned a couple

00:44:02,400 --> 00:44:05,760
times that jitterbug assumes the bpa

00:44:04,000 --> 00:44:07,280
verifier is correct

00:44:05,760 --> 00:44:09,520
what does that mean in practice what

00:44:07,280 --> 00:44:10,560
could be the impact if the verifier has

00:44:09,520 --> 00:44:12,079
a book

00:44:10,560 --> 00:44:14,640
yeah so so far we haven't done any

00:44:12,079 --> 00:44:16,560
verification of the bpf verifier itself

00:44:14,640 --> 00:44:18,880
so if the bpm verifier has a bug it

00:44:16,560 --> 00:44:20,640
might let an unsafe bpf program through

00:44:18,880 --> 00:44:22,079
and then sort of all bets are off for

00:44:20,640 --> 00:44:23,760
what the jit is going to be able to

00:44:22,079 --> 00:44:25,359
uh is going to be able to do so the bpf

00:44:23,760 --> 00:44:26,720
jet jitterbug is sort of

00:44:25,359 --> 00:44:28,800
really focused in the correctness of the

00:44:26,720 --> 00:44:30,160
bpf jets and not looking at the bpf

00:44:28,800 --> 00:44:31,440
verifier itself but it could be

00:44:30,160 --> 00:44:32,560
interesting to also look at that in the

00:44:31,440 --> 00:44:34,480
future since i know that

00:44:32,560 --> 00:44:35,920
sort of historically that's that's been

00:44:34,480 --> 00:44:38,000
somewhere where our bugs have also shown

00:44:35,920 --> 00:44:38,000
up

00:44:38,480 --> 00:44:43,359
cool uh some people are typing slits

00:44:40,400 --> 00:44:43,359
away from the finch

00:44:48,240 --> 00:44:52,160
uh will deacon says uh that was

00:44:50,160 --> 00:44:54,480
fascinating thank you for the risk

00:44:52,160 --> 00:44:55,440
the 32-bit jit which is generated from

00:44:54,480 --> 00:44:57,200
rosette is the c

00:44:55,440 --> 00:44:58,640
source code still patched upstream or is

00:44:57,200 --> 00:44:59,920
the rosette patched and the jet

00:44:58,640 --> 00:45:01,680
regenerated instead

00:44:59,920 --> 00:45:03,040
if the form or what steps are taken to

00:45:01,680 --> 00:45:05,280
avoid regressions

00:45:03,040 --> 00:45:07,040
yeah so so the the thing about the risk

00:45:05,280 --> 00:45:09,760
52 jet that lets us do this

00:45:07,040 --> 00:45:11,920
is uh for now that we're actually

00:45:09,760 --> 00:45:13,440
maintaining the risk of 32 jit so any

00:45:11,920 --> 00:45:16,400
changes that we make we can make to the

00:45:13,440 --> 00:45:17,920
dsl and then regenerate the c code

00:45:16,400 --> 00:45:19,520
it's actually unclear because we have to

00:45:17,920 --> 00:45:21,200
do this porting process for the existing

00:45:19,520 --> 00:45:22,800
gist that's why we're trying to get the

00:45:21,200 --> 00:45:25,520
tool to work directly on the c code so

00:45:22,800 --> 00:45:26,880
we can sort of skip this porting process

00:45:25,520 --> 00:45:28,800
it would be nice in the future to be

00:45:26,880 --> 00:45:30,560
able to let other people use this

00:45:28,800 --> 00:45:32,000
and so that we don't have to maintain

00:45:30,560 --> 00:45:34,480
all of these rosette copies

00:45:32,000 --> 00:45:36,240
of the bpf chips for now that's as good

00:45:34,480 --> 00:45:39,359
that's the best we can do but

00:45:36,240 --> 00:45:41,440
it's we're working on it great

00:45:39,359 --> 00:45:42,880
um daniel borkman says awesome work luke

00:45:41,440 --> 00:45:44,240
when do you plan to upstream this work

00:45:42,880 --> 00:45:45,839
into the kernel

00:45:44,240 --> 00:45:47,200
uh it would be useful to have the specs

00:45:45,839 --> 00:45:48,800
maintain the links on the jits and the

00:45:47,200 --> 00:45:50,160
trees so that when people extend jits

00:45:48,800 --> 00:45:51,359
with new instructions they can also

00:45:50,160 --> 00:45:53,599
extend the rkt

00:45:51,359 --> 00:45:54,400
code alongside with it and verify the

00:45:53,599 --> 00:45:55,599
instruction

00:45:54,400 --> 00:45:57,200
actually that's a very good question

00:45:55,599 --> 00:45:58,160
whether this makes sense to do something

00:45:57,200 --> 00:46:01,280
like that

00:45:58,160 --> 00:46:03,119
yeah so i currently my sort of litmus

00:46:01,280 --> 00:46:04,480
test for when i think it's reasonable to

00:46:03,119 --> 00:46:06,880
to actually upstream this

00:46:04,480 --> 00:46:07,599
will be once it's possible for people to

00:46:06,880 --> 00:46:09,440
run and

00:46:07,599 --> 00:46:11,760
maintain at least parts of the bpf kits

00:46:09,440 --> 00:46:14,079
without having to understand the rosette

00:46:11,760 --> 00:46:15,680
because it's sort of a uh i feel like

00:46:14,079 --> 00:46:17,280
it's a big burden to have to

00:46:15,680 --> 00:46:18,880
have people in addition to changing the

00:46:17,280 --> 00:46:20,000
c code understand the rosette code and

00:46:18,880 --> 00:46:21,280
understand the tools of

00:46:20,000 --> 00:46:23,520
of how to write how to do this

00:46:21,280 --> 00:46:25,280
verification but once we're able to

00:46:23,520 --> 00:46:27,200
verify at least parts of the c code

00:46:25,280 --> 00:46:28,240
directly um without requiring this

00:46:27,200 --> 00:46:30,640
manual porting process

00:46:28,240 --> 00:46:31,599
then in my mind it would be useful

00:46:30,640 --> 00:46:33,440
enough for

00:46:31,599 --> 00:46:34,800
other developers that who aren't us to

00:46:33,440 --> 00:46:36,480
use it without having to

00:46:34,800 --> 00:46:38,560
understand the details of the racking

00:46:36,480 --> 00:46:41,040
code

00:46:38,560 --> 00:46:42,000
but also if uh if if it seems reasonable

00:46:41,040 --> 00:46:44,560
to upload

00:46:42,000 --> 00:46:45,760
the uh or to upstream the the rapid

00:46:44,560 --> 00:46:48,160
specs earlier than that

00:46:45,760 --> 00:46:48,880
then i we we don't have any opposition

00:46:48,160 --> 00:46:51,359
to it we just

00:46:48,880 --> 00:46:53,200
want to make sure that it's the most uh

00:46:51,359 --> 00:46:54,880
uh it's as useful as it can be

00:46:53,200 --> 00:46:58,640
uh without introducing any additional

00:46:54,880 --> 00:46:58,640
overhead onto developers workflows

00:47:00,720 --> 00:47:04,800
yeah if that ever occurred it would be

00:47:02,400 --> 00:47:05,440
the question of what requirements would

00:47:04,800 --> 00:47:08,319
exist for

00:47:05,440 --> 00:47:09,440
making sure that the dsl and the c code

00:47:08,319 --> 00:47:11,760
are in

00:47:09,440 --> 00:47:12,800
yeah exactly that's the main it's

00:47:11,760 --> 00:47:15,520
already hard enough

00:47:12,800 --> 00:47:16,240
uh uh to make changes to the jits it's

00:47:15,520 --> 00:47:18,079
it's

00:47:16,240 --> 00:47:19,520
probably also hard to ask people to

00:47:18,079 --> 00:47:20,400
maintain two different copies of the

00:47:19,520 --> 00:47:23,839
thing

00:47:20,400 --> 00:47:24,559
right um there's some people typing uh

00:47:23,839 --> 00:47:26,160
daniel

00:47:24,559 --> 00:47:27,760
says makes sense thanks a lot do you

00:47:26,160 --> 00:47:28,720
also plan to check out some of the other

00:47:27,760 --> 00:47:31,680
architectures that haven't been

00:47:28,720 --> 00:47:33,200
mentioned here for example s398 smart

00:47:31,680 --> 00:47:35,040
um we don't have any plans to do that

00:47:33,200 --> 00:47:36,400
yet uh but we

00:47:35,040 --> 00:47:37,760
we definitely could in the future if

00:47:36,400 --> 00:47:41,760
people think that that would be a useful

00:47:37,760 --> 00:47:41,760
uh useful place to look for bugs

00:47:42,319 --> 00:47:45,680
okay uh a couple people are typing and

00:47:44,559 --> 00:47:47,760
see what they have to say

00:47:45,680 --> 00:47:49,200
we're about up on the hour so i think

00:47:47,760 --> 00:47:49,920
these will be the last questions for

00:47:49,200 --> 00:47:53,839
sure

00:47:49,920 --> 00:47:53,839
all right um

00:47:56,800 --> 00:48:02,400
uh daniel atkins says axton says i work

00:48:00,079 --> 00:48:03,680
on powerpc64 we're going to have a look

00:48:02,400 --> 00:48:07,200
at your code and get in touch

00:48:03,680 --> 00:48:10,880
that's great cool thanks and john fast

00:48:07,200 --> 00:48:10,880
event seems to be the last person typing

00:48:12,160 --> 00:48:16,800
come on folks oh john says the future

00:48:15,119 --> 00:48:18,079
directions would jitterbug be useful for

00:48:16,800 --> 00:48:19,920
the verifier

00:48:18,079 --> 00:48:22,000
as well or would you imagine that to be

00:48:19,920 --> 00:48:24,880
some other tools

00:48:22,000 --> 00:48:26,559
uh yeah so for now a lot of the

00:48:24,880 --> 00:48:28,160
techniques that jitterbug uses

00:48:26,559 --> 00:48:30,160
it's not clear how they would scale to

00:48:28,160 --> 00:48:30,720
be able to work for uh the bpm verifier

00:48:30,160 --> 00:48:33,040
itself

00:48:30,720 --> 00:48:34,559
vpf verifier is a much more complex

00:48:33,040 --> 00:48:36,000
property because it sort of depends on

00:48:34,559 --> 00:48:38,640
the entire bpf program

00:48:36,000 --> 00:48:39,440
uh like you have to uh it has to keep

00:48:38,640 --> 00:48:41,599
track of

00:48:39,440 --> 00:48:43,200
state of the entire bpf program to know

00:48:41,599 --> 00:48:44,640
that if it's safe it's a lot harder to

00:48:43,200 --> 00:48:47,280
break it down into this

00:48:44,640 --> 00:48:49,280
per instruction correctness and so we're

00:48:47,280 --> 00:48:51,839
not we have some ideas of uh

00:48:49,280 --> 00:48:53,200
of ways of developing a verifier that

00:48:51,839 --> 00:48:54,319
might be might be effective

00:48:53,200 --> 00:48:55,920
but it's not clear at least that

00:48:54,319 --> 00:48:57,520
jitterbug will be applied applicable to

00:48:55,920 --> 00:48:59,040
it or even the verification might not

00:48:57,520 --> 00:49:00,960
even be the right approach to uh the

00:48:59,040 --> 00:49:03,520
right trade-off for mitigating bugs

00:49:00,960 --> 00:49:05,280
so we're still uh actively thinking

00:49:03,520 --> 00:49:08,400
about that

00:49:05,280 --> 00:49:10,240
oh and as for as far as s390 uh yeah

00:49:08,400 --> 00:49:11,680
that could be interesting to take a a

00:49:10,240 --> 00:49:14,480
look in the future

00:49:11,680 --> 00:49:16,000
yeah sir high macro says the s390x is a

00:49:14,480 --> 00:49:17,599
sweet spot where the demand for it

00:49:16,000 --> 00:49:18,800
outstrips the engineering time and

00:49:17,599 --> 00:49:21,680
that's a good point about

00:49:18,800 --> 00:49:23,440
whether this uh could uh make it easier

00:49:21,680 --> 00:49:24,800
to maintain it and verify a jit if

00:49:23,440 --> 00:49:26,240
there's not a lot of engineering

00:49:24,800 --> 00:49:28,720
resources available so that's great

00:49:26,240 --> 00:49:30,000
right hey luke thank you very much for

00:49:28,720 --> 00:49:31,760
your presentation thank you

00:49:30,000 --> 00:49:35,200
awesome work and i wish you luck in the

00:49:31,760 --> 00:49:35,200
future thanks

00:49:35,520 --> 00:49:42,880
okay so moving on i'll take the

00:49:38,559 --> 00:49:42,880
presenter back and

00:49:43,760 --> 00:49:46,800
set up the next talk

00:49:56,000 --> 00:49:59,599
okay martin i've given you presenter

00:49:57,839 --> 00:50:13,839
status you should be able to manage the

00:49:59,599 --> 00:50:13,839
slides and bring in your presentation

00:50:14,800 --> 00:50:20,480
um yes let me try to start my webcam

00:50:24,960 --> 00:50:30,720
okay um

00:50:28,240 --> 00:50:33,040
hi everybody uh thanks for joining in uh

00:50:30,720 --> 00:50:34,960
my name is martin i work in the

00:50:33,040 --> 00:50:38,480
kernel team in facebook uh today i want

00:50:34,960 --> 00:50:41,839
to talk about the bpf work we have done

00:50:38,480 --> 00:50:41,839
in the leveling step

00:50:47,680 --> 00:50:54,800
so uh in 2015 i attended a

00:50:50,800 --> 00:50:56,000
i attended lpc so one of the topic that

00:50:54,800 --> 00:50:58,960
got brought up was the

00:50:56,000 --> 00:50:59,760
protocol ossification so in our team we

00:50:58,960 --> 00:51:03,440
always got

00:50:59,760 --> 00:51:05,520
question asked like uh how easy is it to

00:51:03,440 --> 00:51:08,640
test a departmental tcp

00:51:05,520 --> 00:51:11,040
congestion control idea um

00:51:08,640 --> 00:51:12,880
the the answer is uh is usually

00:51:11,040 --> 00:51:16,000
discouraging because

00:51:12,880 --> 00:51:18,640
it turns out to be a

00:51:16,000 --> 00:51:20,240
how easy is it to make kernel changes um

00:51:18,640 --> 00:51:23,440
without the kernel panic

00:51:20,240 --> 00:51:25,280
and sometimes uh it's also it's very

00:51:23,440 --> 00:51:28,319
difficult to deploy

00:51:25,280 --> 00:51:30,000
those changes uh it would be like how

00:51:28,319 --> 00:51:31,599
quick is it to upgrade a kernel

00:51:30,000 --> 00:51:33,440
or at least to upgrade the kind of

00:51:31,599 --> 00:51:36,079
module um

00:51:33,440 --> 00:51:37,520
it sometimes it's not easy because some

00:51:36,079 --> 00:51:40,559
of the environment has a

00:51:37,520 --> 00:51:41,040
very long tail of kernel versions so all

00:51:40,559 --> 00:51:44,319
of this

00:51:41,040 --> 00:51:47,680
is uh pretty discouraging for the

00:51:44,319 --> 00:51:50,640
uh networking expert or political expert

00:51:47,680 --> 00:51:52,240
who want to try to experiment new

00:51:50,640 --> 00:51:53,440
congestion control idea or other

00:51:52,240 --> 00:51:56,720
protocol

00:51:53,440 --> 00:51:57,280
improvement idea so at that time one

00:51:56,720 --> 00:52:01,760
question

00:51:57,280 --> 00:52:05,359
was asked is can tcp congestion control

00:52:01,760 --> 00:52:08,480
be written in bpf at that time

00:52:05,359 --> 00:52:10,640
it was something that unheard of and

00:52:08,480 --> 00:52:12,800
it was pretty hard to imagine how that

00:52:10,640 --> 00:52:15,839
could be done in bpf

00:52:12,800 --> 00:52:16,960
um but now actually we could do that we

00:52:15,839 --> 00:52:19,359
can write tcp

00:52:16,960 --> 00:52:20,000
conjunction control and ppf and actually

00:52:19,359 --> 00:52:22,720
we

00:52:20,000 --> 00:52:23,760
we can do more than that so today i want

00:52:22,720 --> 00:52:25,920
to talk about

00:52:23,760 --> 00:52:27,440
of course the construction control and

00:52:25,920 --> 00:52:28,880
also about the

00:52:27,440 --> 00:52:31,119
another thing i want to talk about is

00:52:28,880 --> 00:52:34,720
the uh

00:52:31,119 --> 00:52:37,599
writing tcp head option in bpf

00:52:34,720 --> 00:52:38,319
and the last thing i want to touch base

00:52:37,599 --> 00:52:47,040
also is

00:52:38,319 --> 00:52:50,559
about the socket local storage

00:52:47,040 --> 00:52:54,400
so first uh construction control um so

00:52:50,559 --> 00:52:58,880
in this slide i put two pieces of code

00:52:54,400 --> 00:52:59,599
one uh one is a a b-pap cubic so both of

00:52:58,880 --> 00:53:01,680
them is

00:52:59,599 --> 00:53:03,359
cubic implementation one of them is

00:53:01,680 --> 00:53:06,480
written in bpf

00:53:03,359 --> 00:53:06,960
and another one is uh is the kernel

00:53:06,480 --> 00:53:09,680
cubic

00:53:06,960 --> 00:53:11,839
so which one do you guess is the bpf

00:53:09,680 --> 00:53:11,839
cube

00:53:12,839 --> 00:53:15,839
here

00:53:16,960 --> 00:53:24,079
um so this one is maybe easier the left

00:53:20,559 --> 00:53:27,599
the left hand side one is the bpf qubit

00:53:24,079 --> 00:53:29,680
i think the avoid pointer custom may be

00:53:27,599 --> 00:53:33,280
giving this one away

00:53:29,680 --> 00:53:34,240
so um let's dive into one of the ponder

00:53:33,280 --> 00:53:38,240
implementation

00:53:34,240 --> 00:53:40,640
um the one that i picked is the ss trash

00:53:38,240 --> 00:53:42,319
uh because it's small enough to put it

00:53:40,640 --> 00:53:45,280
in a slide

00:53:42,319 --> 00:53:48,079
so let's dive into the ss trash and

00:53:45,280 --> 00:53:48,079
implementation

00:53:48,880 --> 00:53:56,319
so again here is uh two pieces of code

00:53:52,640 --> 00:53:58,640
one is the bpf cubic implementation

00:53:56,319 --> 00:54:00,000
of the assets trash another one is the

00:53:58,640 --> 00:54:03,920
kernel qubit

00:54:00,000 --> 00:54:07,680
uh from this can we tell which one

00:54:03,920 --> 00:54:07,680
is the bpf coupe here

00:54:09,359 --> 00:54:15,119
i think this one is harder i think uh

00:54:12,640 --> 00:54:16,720
except the very first like i cover up

00:54:15,119 --> 00:54:20,160
every single light should be

00:54:16,720 --> 00:54:20,160
the same uh

00:54:20,400 --> 00:54:24,960
again the left hand side one is the uh

00:54:23,119 --> 00:54:26,160
vpf cubic

00:54:24,960 --> 00:54:28,880
only the first line the function

00:54:26,160 --> 00:54:31,920
selector is different the bpf one

00:54:28,880 --> 00:54:39,839
requires a macro border play

00:54:31,920 --> 00:54:39,839
to to define the function

00:54:40,400 --> 00:54:46,319
so we cover how uh it could be written

00:54:44,240 --> 00:54:47,839
uh how the bpf construction control

00:54:46,319 --> 00:54:51,680
could be written let's

00:54:47,839 --> 00:54:55,440
take a look at how it is used in

00:54:51,680 --> 00:54:58,240
in the production so um

00:54:55,440 --> 00:54:59,200
first we need to load the uh bpf cubic

00:54:58,240 --> 00:55:02,240
um

00:54:59,200 --> 00:55:05,440
so it can be done by the bff two

00:55:02,240 --> 00:55:06,559
struts ops sub command which is the very

00:55:05,440 --> 00:55:09,920
first

00:55:06,559 --> 00:55:12,720
command i place here so bpf shot ops

00:55:09,920 --> 00:55:16,559
register bpf cubic and you will get

00:55:12,720 --> 00:55:18,240
loaded to the kernel but after that uh

00:55:16,559 --> 00:55:20,430
everything will work the same as the

00:55:18,240 --> 00:55:21,599
kernel conjunction control we can

00:55:20,430 --> 00:55:24,160
[Music]

00:55:21,599 --> 00:55:25,119
look at it in the syscudo in the second

00:55:24,160 --> 00:55:28,160
command

00:55:25,119 --> 00:55:30,720
we can see the bpf cuber is

00:55:28,160 --> 00:55:33,359
already one of the available conjection

00:55:30,720 --> 00:55:37,359
control in the system

00:55:33,359 --> 00:55:39,599
and we can also use it as a default use

00:55:37,359 --> 00:55:43,119
the bpf cuber as the default

00:55:39,599 --> 00:55:44,079
conjection control by setting the system

00:55:43,119 --> 00:55:47,760
also

00:55:44,079 --> 00:55:50,799
so that is the third command the last

00:55:47,760 --> 00:55:50,799
command i place here

00:55:51,839 --> 00:55:55,760
and yes it can be used in accessor

00:55:54,000 --> 00:55:58,799
option

00:55:55,760 --> 00:56:01,440
so you can we can

00:55:58,799 --> 00:56:04,720
select a field specific connection to

00:56:01,440 --> 00:56:04,720
use bpef kubrick

00:56:08,079 --> 00:56:14,880
so here's uh some um so we run

00:56:11,680 --> 00:56:17,920
cubic and bpf cubic uh under the

00:56:14,880 --> 00:56:22,000
testo test that uh larry uh

00:56:17,920 --> 00:56:25,200
has created um so here's the one of the

00:56:22,000 --> 00:56:26,640
performance comparison uh the one i put

00:56:25,200 --> 00:56:31,040
here is the uh

00:56:26,640 --> 00:56:34,160
good put uh comparison so we can see the

00:56:31,040 --> 00:56:36,480
performance uh property is us

00:56:34,160 --> 00:56:37,520
pretty much the same with the kernel one

00:56:36,480 --> 00:56:39,760
um

00:56:37,520 --> 00:56:41,359
and it has to be because uh if you look

00:56:39,760 --> 00:56:42,960
at the bpf cube it is

00:56:41,359 --> 00:56:44,400
mostly live by like the same as the

00:56:42,960 --> 00:56:47,680
panel one

00:56:44,400 --> 00:56:50,240
um so i we have a lot of autograph to

00:56:47,680 --> 00:56:52,400
show the uh we transmit latency

00:56:50,240 --> 00:56:53,440
and um they're pretty much pretty much

00:56:52,400 --> 00:56:59,839
all the same so i

00:56:53,440 --> 00:56:59,839
didn't place all of them here

00:57:01,359 --> 00:57:08,799
so um before i switch topic to the

00:57:05,599 --> 00:57:10,319
um tcp head option i want to talk about

00:57:08,799 --> 00:57:13,359
uh

00:57:10,319 --> 00:57:14,400
struck ops because um i think a few days

00:57:13,359 --> 00:57:16,000
ago

00:57:14,400 --> 00:57:18,400
people has been talking about if struck

00:57:16,000 --> 00:57:21,440
ops can be reused in

00:57:18,400 --> 00:57:24,640
in qd's or some other things

00:57:21,440 --> 00:57:27,839
so um so q uh strut ops is what

00:57:24,640 --> 00:57:31,200
uh tcp contraction control

00:57:27,839 --> 00:57:33,520
build up on so when i

00:57:31,200 --> 00:57:35,359
uh when i try to work on bpf

00:57:33,520 --> 00:57:38,559
construction control

00:57:35,359 --> 00:57:40,319
uh patches um when i look at the tcp

00:57:38,559 --> 00:57:43,520
congestion ops

00:57:40,319 --> 00:57:44,079
it is a struck and has a few pointers in

00:57:43,520 --> 00:57:46,079
it

00:57:44,079 --> 00:57:47,440
and each point is doing different things

00:57:46,079 --> 00:57:51,520
and different

00:57:47,440 --> 00:57:54,559
conjunction control just uh need to we

00:57:51,520 --> 00:57:56,880
implement those uh pointer so if you

00:57:54,559 --> 00:57:59,280
look at this pattern uh struck

00:57:56,880 --> 00:58:00,240
with a kernel struct with a field

00:57:59,280 --> 00:58:01,760
function pointer

00:58:00,240 --> 00:58:03,359
if we look at this pattern uh this

00:58:01,760 --> 00:58:05,440
pattern is pretty common in in the

00:58:03,359 --> 00:58:07,760
kernel

00:58:05,440 --> 00:58:09,119
the tcp conjunction control ops is one

00:58:07,760 --> 00:58:12,480
of them for sure

00:58:09,119 --> 00:58:13,920
are the q disks of tcp protocol udp

00:58:12,480 --> 00:58:16,079
protocol and

00:58:13,920 --> 00:58:17,920
pretty much all the kernel module is is

00:58:16,079 --> 00:58:21,119
using this pattern

00:58:17,920 --> 00:58:24,000
so uh what i

00:58:21,119 --> 00:58:25,440
was thinking is to um if we instead of

00:58:24,000 --> 00:58:28,160
creating a specific

00:58:25,440 --> 00:58:28,960
api that only work with tcp conjunction

00:58:28,160 --> 00:58:32,160
ops

00:58:28,960 --> 00:58:33,920
so uh it may it is a it would be a

00:58:32,160 --> 00:58:37,040
better idea to create a

00:58:33,920 --> 00:58:39,599
an api that will uh work

00:58:37,040 --> 00:58:41,119
pretty much work uh for all these

00:58:39,599 --> 00:58:44,160
kernels drop-offs

00:58:41,119 --> 00:58:47,680
um data structure so that's what um

00:58:44,160 --> 00:58:47,680
bps dropoffs us

00:58:47,920 --> 00:58:54,880
comes in so it's an api to implement

00:58:51,280 --> 00:58:58,319
function pointers uh in bpf

00:58:54,880 --> 00:59:01,839
um so each function pointer is actually

00:58:58,319 --> 00:59:03,520
a uh bfair program uh which is in the

00:59:01,839 --> 00:59:07,520
type uh

00:59:03,520 --> 00:59:09,839
bpa pop type struct ops

00:59:07,520 --> 00:59:11,040
um so one thing about this drop-off

00:59:09,839 --> 00:59:13,839
speedpair program is

00:59:11,040 --> 00:59:15,280
it doesn't have a static um branding

00:59:13,839 --> 00:59:18,720
contents

00:59:15,280 --> 00:59:19,440
so but it learned the function signature

00:59:18,720 --> 00:59:22,240
from

00:59:19,440 --> 00:59:22,799
from the from the btf of the kernel so

00:59:22,240 --> 00:59:25,280
what

00:59:22,799 --> 00:59:26,240
you can what the btf can tell us is the

00:59:25,280 --> 00:59:29,119
uh

00:59:26,240 --> 00:59:30,000
is harmony for example how many argument

00:59:29,119 --> 00:59:32,960
is in

00:59:30,000 --> 00:59:35,680
is uh in this function pointer and the

00:59:32,960 --> 00:59:39,040
runtime we only need to pass the

00:59:35,680 --> 00:59:41,280
pass those arguments to the stack so

00:59:39,040 --> 00:59:43,760
all of this uh could be happening

00:59:41,280 --> 00:59:46,319
because all of this recent work uh

00:59:43,760 --> 00:59:48,799
has been done in in the bpf for example

00:59:46,319 --> 00:59:51,920
the btf aware verifier

00:59:48,799 --> 00:59:54,000
trampoline and the core so

00:59:51,920 --> 00:59:54,960
thanks to all the guys that are well on

00:59:54,000 --> 01:00:00,799
this area

00:59:54,960 --> 01:00:02,480
that make straight ups happening

01:00:00,799 --> 01:00:04,240
so that will be the last slide for the

01:00:02,480 --> 01:00:07,599
uh conjunction control

01:00:04,240 --> 01:00:11,040
so if we look at the delete bpf how

01:00:07,599 --> 01:00:12,079
how the ppf low uh the ppf curveback is

01:00:11,040 --> 01:00:14,960
uh

01:00:12,079 --> 01:00:16,640
it will so as i said before uh each of

01:00:14,960 --> 01:00:20,240
this function pointer is

01:00:16,640 --> 01:00:23,839
actually implemented by a bpa program so

01:00:20,240 --> 01:00:27,280
what the people have uh do is

01:00:23,839 --> 01:00:29,200
load each of this uh bpap program

01:00:27,280 --> 01:00:31,680
and then get a function get a file

01:00:29,200 --> 01:00:34,559
descriptor for each of them

01:00:31,680 --> 01:00:35,359
and then it will create the tcp

01:00:34,559 --> 01:00:38,559
conjunction

01:00:35,359 --> 01:00:42,640
ops object and then initialize

01:00:38,559 --> 01:00:43,520
each function pointer to the bpa program

01:00:42,640 --> 01:00:46,960
fd

01:00:43,520 --> 01:00:50,319
and then though this whole object did

01:00:46,960 --> 01:00:52,480
look hold this whole uh dcp conjunction

01:00:50,319 --> 01:00:54,640
object to the kernel and then it will

01:00:52,480 --> 01:00:57,200
get registered to the

01:00:54,640 --> 01:00:58,640
to the networking staff as one of the

01:00:57,200 --> 01:01:02,079
congestion control

01:00:58,640 --> 01:01:05,119
available but uh good news is that you

01:01:02,079 --> 01:01:08,240
you don't have to use the ppf uh you

01:01:05,119 --> 01:01:11,040
i imagine you should just use the b52

01:01:08,240 --> 01:01:14,400
strip of sub subcommand directly

01:01:11,040 --> 01:01:14,400
maybe in the future um

01:01:14,640 --> 01:01:18,880
we develop qd's ops on top of shop ops

01:01:18,400 --> 01:01:21,280
then

01:01:18,880 --> 01:01:25,839
we we should be able to reuse this drop

01:01:21,280 --> 01:01:25,839
off sub command essence

01:01:34,400 --> 01:01:42,400
okay next we'll switch

01:01:37,599 --> 01:01:47,119
our switch topic to talk about the

01:01:42,400 --> 01:01:51,200
writing tcp header options in bpf

01:01:47,119 --> 01:01:54,880
so i think uh we don't lack of use case

01:01:51,200 --> 01:01:57,920
uh to uh to

01:01:54,880 --> 01:02:00,640
of to allow bpa program to write the tcp

01:01:57,920 --> 01:02:02,480
had options for example um

01:02:00,640 --> 01:02:04,559
one use case could be we want to

01:02:02,480 --> 01:02:06,000
communicate the maximum delay act in the

01:02:04,559 --> 01:02:08,799
head options

01:02:06,000 --> 01:02:09,839
so that the receiver side can can say

01:02:08,799 --> 01:02:12,079
low rto

01:02:09,839 --> 01:02:14,559
and so this will be the example i will

01:02:12,079 --> 01:02:16,799
use in the following slides too

01:02:14,559 --> 01:02:18,000
to show how it could be done in the bpf

01:02:16,799 --> 01:02:19,760
program

01:02:18,000 --> 01:02:21,839
and actually this use case has been

01:02:19,760 --> 01:02:25,039
co-posted in

01:02:21,839 --> 01:02:28,480
in uh some of the ios rfc by

01:02:25,039 --> 01:02:29,359
by google also and the other use case uh

01:02:28,480 --> 01:02:32,960
that may be

01:02:29,359 --> 01:02:36,559
uh uh quite specific to the data center

01:02:32,960 --> 01:02:36,559
or internal traffic for example

01:02:37,039 --> 01:02:40,640
we may want to communicate the legs the

01:02:39,039 --> 01:02:43,680
leg speed to the other side

01:02:40,640 --> 01:02:46,400
or we may want to communicate what um

01:02:43,680 --> 01:02:47,200
conjunction control we want we prefer to

01:02:46,400 --> 01:02:50,880
use uh

01:02:47,200 --> 01:02:51,599
to the other side and and many other

01:02:50,880 --> 01:02:55,680
cases

01:02:51,599 --> 01:02:57,359
like that so uh

01:02:55,680 --> 01:02:59,359
right now what the b player program can

01:02:57,359 --> 01:03:03,280
do is it can you can write

01:02:59,359 --> 01:03:06,319
any other option that means uh

01:03:03,280 --> 01:03:09,599
uh they we don't restrict what

01:03:06,319 --> 01:03:11,920
what you can write uh but the

01:03:09,599 --> 01:03:14,079
uh kernel kernel will definitely check

01:03:11,920 --> 01:03:17,200
for duplicated options and

01:03:14,079 --> 01:03:17,839
check for whether that um option format

01:03:17,200 --> 01:03:20,960
is uh

01:03:17,839 --> 01:03:24,160
correct or not um so

01:03:20,960 --> 01:03:26,079
by by allowing the bpa program to to

01:03:24,160 --> 01:03:29,599
write any option contact give

01:03:26,079 --> 01:03:30,000
a lot of flexibility for for the data

01:03:29,599 --> 01:03:33,119
center

01:03:30,000 --> 01:03:33,520
internal traffic because uh that traffic

01:03:33,119 --> 01:03:36,079
will

01:03:33,520 --> 01:03:36,720
only go to the proper internet so they

01:03:36,079 --> 01:03:38,960
they can have

01:03:36,720 --> 01:03:40,400
better control on what they want to send

01:03:38,960 --> 01:03:43,599
um

01:03:40,400 --> 01:03:46,799
and uh potentially you can support newer

01:03:43,599 --> 01:03:51,119
standard option in an older kernel

01:03:46,799 --> 01:03:54,480
so i expect this will be mostly used

01:03:51,119 --> 01:03:57,599
during the freeway handshake but

01:03:54,480 --> 01:03:58,000
it will also work in passing or writing

01:03:57,599 --> 01:04:00,720
option

01:03:58,000 --> 01:04:01,119
in data header or pure add header or

01:04:00,720 --> 01:04:04,799
even

01:04:01,119 --> 01:04:04,799
fin packet header

01:04:08,720 --> 01:04:12,240
so in the next two slides i'm going to

01:04:10,839 --> 01:04:14,799
um

01:04:12,240 --> 01:04:17,200
set an example on how it could be used

01:04:14,799 --> 01:04:20,640
at the server side

01:04:17,200 --> 01:04:24,079
doing the three-way handshake

01:04:20,640 --> 01:04:28,240
so on the top right hand corner is a

01:04:24,079 --> 01:04:30,480
quick recap on how a tcp had options

01:04:28,240 --> 01:04:31,760
looks like so the first sprite is the

01:04:30,480 --> 01:04:34,160
con

01:04:31,760 --> 01:04:35,119
uh so what kind of the option it is it's

01:04:34,160 --> 01:04:38,000
one byte

01:04:35,119 --> 01:04:39,200
and the second byte is the length of the

01:04:38,000 --> 01:04:41,520
options

01:04:39,200 --> 01:04:44,079
and after that is whatever data this

01:04:41,520 --> 01:04:47,680
option want to carry

01:04:44,079 --> 01:04:50,160
um so the example i'm going to use is

01:04:47,680 --> 01:04:51,440
to uh is to communicate the maximum

01:04:50,160 --> 01:04:54,880
delay act

01:04:51,440 --> 01:04:57,680
in the head options um so i use the

01:04:54,880 --> 01:05:02,480
hexadecimal da

01:04:57,680 --> 01:05:02,480
for the count by da stand for delay ac

01:05:02,720 --> 01:05:07,119
so the first thing the server want to do

01:05:05,520 --> 01:05:08,720
is to write the same

01:05:07,119 --> 01:05:10,160
right which if it's sync then you want

01:05:08,720 --> 01:05:13,440
to write the sync act

01:05:10,160 --> 01:05:16,559
back so the bpi program will get called

01:05:13,440 --> 01:05:19,200
to write the same act

01:05:16,559 --> 01:05:21,200
so first what the server would like to

01:05:19,200 --> 01:05:24,400
do is to

01:05:21,200 --> 01:05:25,440
look at the same header to see whether

01:05:24,400 --> 01:05:29,599
the

01:05:25,440 --> 01:05:32,640
client has has communicated its delay ad

01:05:29,599 --> 01:05:35,680
options so it called bpflow had

01:05:32,640 --> 01:05:39,520
options to look at the

01:05:35,680 --> 01:05:43,599
same header um so that's the first step

01:05:39,520 --> 01:05:46,240
um in the second step is if the

01:05:43,599 --> 01:05:47,440
sync packet doesn't carry the delay

01:05:46,240 --> 01:05:49,680
option then that's fine

01:05:47,440 --> 01:05:50,559
it means the client does not support

01:05:49,680 --> 01:05:52,400
this option

01:05:50,559 --> 01:05:55,599
then the server can just return here

01:05:52,400 --> 01:05:59,200
without writing anything back

01:05:55,599 --> 01:06:01,760
um so in the first step here you can

01:05:59,200 --> 01:06:03,440
uh the prepaid program can also learn if

01:06:01,760 --> 01:06:07,359
the server is currently in

01:06:03,440 --> 01:06:10,319
sen kokimo if it is in senko kimo it can

01:06:07,359 --> 01:06:11,920
it can tell the you can write a bit in

01:06:10,319 --> 01:06:14,400
the option to tell the

01:06:11,920 --> 01:06:16,240
client to resend the delay add option

01:06:14,400 --> 01:06:18,079
later

01:06:16,240 --> 01:06:19,599
so assume everything is fine then it

01:06:18,079 --> 01:06:22,799
will go to step four

01:06:19,599 --> 01:06:25,440
and then it will really write the

01:06:22,799 --> 01:06:26,559
uh its maximum delay act in the option

01:06:25,440 --> 01:06:29,039
header now

01:06:26,559 --> 01:06:30,559
uh so in this example i set it to 10

01:06:29,039 --> 01:06:33,119
milliseconds

01:06:30,559 --> 01:06:35,119
and then you can call the bpf store

01:06:33,119 --> 01:06:38,880
header option helper

01:06:35,119 --> 01:06:47,839
to write it into the same app header

01:06:38,880 --> 01:06:51,119
that um that is going to send out

01:06:47,839 --> 01:06:52,559
so now um in the in the in the previous

01:06:51,119 --> 01:06:56,240
slide it write the same act

01:06:52,559 --> 01:06:57,359
so now the add come back um the free

01:06:56,240 --> 01:06:59,760
handshake has

01:06:57,359 --> 01:07:01,039
completed so a new connection has

01:06:59,760 --> 01:07:02,880
established it

01:07:01,039 --> 01:07:05,839
and the bpa program will be get call

01:07:02,880 --> 01:07:08,640
again uh

01:07:05,839 --> 01:07:10,160
in at this time the bpa program can look

01:07:08,640 --> 01:07:13,520
at the same header again

01:07:10,160 --> 01:07:16,000
which it has saved earlier and then to

01:07:13,520 --> 01:07:16,960
get the delay add option back from the

01:07:16,000 --> 01:07:20,160
same header

01:07:16,960 --> 01:07:23,039
in the first step and then

01:07:20,160 --> 01:07:24,400
if it is there then in the last step the

01:07:23,039 --> 01:07:27,760
first step here

01:07:24,400 --> 01:07:31,359
you can call a helper ppf set

01:07:27,760 --> 01:07:34,000
up to lower its rto

01:07:31,359 --> 01:07:34,880
based on whatever the maximum delay at

01:07:34,000 --> 01:07:38,799
the

01:07:34,880 --> 01:07:38,799
decline has told the server

01:07:39,359 --> 01:07:46,240
so um the whole uh concept is uh

01:07:44,079 --> 01:07:48,480
pretty much built around two helpers the

01:07:46,240 --> 01:07:51,599
low header options and uh

01:07:48,480 --> 01:07:52,799
right header option and you may want to

01:07:51,599 --> 01:07:55,440
call that saw up to

01:07:52,799 --> 01:07:56,960
to change the behavior of the connection

01:07:55,440 --> 01:08:01,119
depends on the

01:07:56,960 --> 01:08:01,119
options you have received from the other

01:08:08,839 --> 01:08:14,559
side

01:08:11,039 --> 01:08:16,719
okay so we will go to the last topic of

01:08:14,559 --> 01:08:17,839
of this talk is about socket local

01:08:16,719 --> 01:08:22,080
storage

01:08:17,839 --> 01:08:24,880
um so um as we can

01:08:22,080 --> 01:08:27,199
write more and more uh networking uh

01:08:24,880 --> 01:08:29,679
function or features in bpf

01:08:27,199 --> 01:08:31,199
it is very common that the bpa program

01:08:29,679 --> 01:08:34,560
wants to

01:08:31,199 --> 01:08:38,239
associate some data to a specific uh

01:08:34,560 --> 01:08:41,359
socket for example um tomorrow i may

01:08:38,239 --> 01:08:42,239
create a new tcp conjunction control

01:08:41,359 --> 01:08:45,199
algorithm and

01:08:42,239 --> 01:08:47,600
write in bpf uh but i want to store a

01:08:45,199 --> 01:08:50,159
few more data points

01:08:47,600 --> 01:08:50,880
to a connection it could be a few more

01:08:50,159 --> 01:08:54,080
round trip

01:08:50,880 --> 01:08:56,080
time samples to a socket

01:08:54,080 --> 01:08:57,199
uh so how could we do it so one way to

01:08:56,080 --> 01:09:00,400
do it is

01:08:57,199 --> 01:09:03,839
to use the hash table to a uh

01:09:00,400 --> 01:09:05,120
a regular epf hash table and then use

01:09:03,839 --> 01:09:08,799
the four tuple

01:09:05,120 --> 01:09:10,319
as the key and then the value of this

01:09:08,799 --> 01:09:12,719
table could be whatever the

01:09:10,319 --> 01:09:14,080
whatever data you want to store for this

01:09:12,719 --> 01:09:16,560
connection

01:09:14,080 --> 01:09:18,640
so the four tuple as the key is the

01:09:16,560 --> 01:09:21,920
destination and source ip

01:09:18,640 --> 01:09:25,199
and port um so that that worked

01:09:21,920 --> 01:09:28,319
and and we do we do have a

01:09:25,199 --> 01:09:31,600
program do something like that uh also

01:09:28,319 --> 01:09:33,759
but the downside is um the

01:09:31,600 --> 01:09:35,279
cpu lock up time could be expensive if

01:09:33,759 --> 01:09:37,440
you do it

01:09:35,279 --> 01:09:39,040
uh for example if you do this lookup for

01:09:37,440 --> 01:09:42,159
every packet

01:09:39,040 --> 01:09:45,199
you receive or you send out and it

01:09:42,159 --> 01:09:47,199
could become a maintenance light mail

01:09:45,199 --> 01:09:49,839
because you have to remember to remove

01:09:47,199 --> 01:09:53,120
this key when the socket is closed

01:09:49,839 --> 01:09:56,719
if that's not handled correctly um

01:09:53,120 --> 01:09:59,840
the map could get exploded very quickly

01:09:56,719 --> 01:10:01,040
um but that's that's another way a new

01:09:59,840 --> 01:10:04,320
way to do it is

01:10:01,040 --> 01:10:06,640
called bpf socket storage

01:10:04,320 --> 01:10:07,840
so what it does is it stores data

01:10:06,640 --> 01:10:10,800
directly at the s

01:10:07,840 --> 01:10:12,320
at the socket itself and the data will

01:10:10,800 --> 01:10:16,320
go away with the socket

01:10:12,320 --> 01:10:19,600
um when the socket closed it

01:10:16,320 --> 01:10:21,679
the main helper to to use this uh to

01:10:19,600 --> 01:10:23,199
to store data or to get data from the

01:10:21,679 --> 01:10:26,880
socket is

01:10:23,199 --> 01:10:29,920
is called bpf socket storage gap

01:10:26,880 --> 01:10:31,600
um so you still have to pass a map in it

01:10:29,920 --> 01:10:32,800
i'll talk about that later why do we

01:10:31,600 --> 01:10:36,320
need a map

01:10:32,800 --> 01:10:38,159
and and for sure you need to pass the

01:10:36,320 --> 01:10:40,239
socket pointer in it to tell

01:10:38,159 --> 01:10:42,840
the kernel which socket you want to

01:10:40,239 --> 01:10:46,000
store the data to

01:10:42,840 --> 01:10:46,320
um the lookup benchmark shows uh more

01:10:46,000 --> 01:10:49,360
than

01:10:46,320 --> 01:10:51,199
fifty percent of time so uh uh

01:10:49,360 --> 01:10:53,199
that's probably something you want to

01:10:51,199 --> 01:10:56,560
use if you want to start it

01:10:53,199 --> 01:10:59,600
in the socket um

01:10:56,560 --> 01:11:01,600
and the concept has recently been

01:10:59,600 --> 01:11:04,239
repurposed uh

01:11:01,600 --> 01:11:05,600
and then to allow store data at other

01:11:04,239 --> 01:11:09,920
kernel objects also

01:11:05,600 --> 01:11:13,040
um uh for example it has been

01:11:09,920 --> 01:11:13,520
repurposed to store data to you to the i

01:11:13,040 --> 01:11:16,640
know

01:11:13,520 --> 01:11:17,520
and that has all this work has been done

01:11:16,640 --> 01:11:21,920
by

01:11:17,520 --> 01:11:21,920
kp from google so thanks for the work on

01:11:24,840 --> 01:11:29,600
that

01:11:26,480 --> 01:11:30,960
so um in the next few slides i'm going

01:11:29,600 --> 01:11:34,080
to talk about uh

01:11:30,960 --> 01:11:38,000
an example on how to how to store

01:11:34,080 --> 01:11:38,719
data in sk and how you can use the bpf

01:11:38,000 --> 01:11:43,520
socket get

01:11:38,719 --> 01:11:47,280
storage helper so uh for example um

01:11:43,520 --> 01:11:50,320
so uh so to to to start data in s-cave

01:11:47,280 --> 01:11:52,480
uh first you need to um

01:11:50,320 --> 01:11:53,679
define a map the type of the map is

01:11:52,480 --> 01:11:56,960
called bpf bpfmap

01:11:53,679 --> 01:11:59,600
socket storage so the key will be the

01:11:56,960 --> 01:12:01,440
socket file descriptor and the value is

01:11:59,600 --> 01:12:05,600
whatever you want to store in the

01:12:01,440 --> 01:12:08,080
in the socket so for example i want to

01:12:05,600 --> 01:12:09,199
store two things in the socket one is i

01:12:08,080 --> 01:12:12,880
want to store

01:12:09,199 --> 01:12:13,920
the round trip time some more round trip

01:12:12,880 --> 01:12:15,920
time in the socket

01:12:13,920 --> 01:12:17,040
and another thing i want to store is the

01:12:15,920 --> 01:12:19,360
location

01:12:17,040 --> 01:12:20,719
of the remote sign like for example east

01:12:19,360 --> 01:12:23,679
coast west coast

01:12:20,719 --> 01:12:25,199
or apac or europe things like that so

01:12:23,679 --> 01:12:28,640
because i i want to store two

01:12:25,199 --> 01:12:29,120
different things so um i have to define

01:12:28,640 --> 01:12:32,480
two

01:12:29,120 --> 01:12:35,360
um socket storage map one

01:12:32,480 --> 01:12:36,000
i got one i call them ltd another one i

01:12:35,360 --> 01:12:38,560
call map

01:12:36,000 --> 01:12:38,560
location

01:12:40,400 --> 01:12:45,920
so here is um is a picture

01:12:43,679 --> 01:12:47,040
a very very simplified picture on how

01:12:45,920 --> 01:12:50,159
things organized

01:12:47,040 --> 01:12:53,840
in under another socket

01:12:50,159 --> 01:12:54,480
um is a little more complicated than

01:12:53,840 --> 01:12:57,760
this in

01:12:54,480 --> 01:13:00,640
in the real code but um

01:12:57,760 --> 01:13:02,480
that is the simplified version for the

01:13:00,640 --> 01:13:05,679
discussion purpose um

01:13:02,480 --> 01:13:07,600
so um so there's a socket for sure um

01:13:05,679 --> 01:13:11,199
and then it will point an array

01:13:07,600 --> 01:13:14,719
of storage and here is why the map

01:13:11,199 --> 01:13:17,679
uh comes in the map has an index

01:13:14,719 --> 01:13:18,080
stored in this so this index tells us

01:13:17,679 --> 01:13:21,040
where

01:13:18,080 --> 01:13:23,280
this data is uh going to be started for

01:13:21,040 --> 01:13:26,960
example um

01:13:23,280 --> 01:13:28,719
the location data map the map location

01:13:26,960 --> 01:13:30,800
index is pointing to the first element

01:13:28,719 --> 01:13:32,560
of this array so so the location will be

01:13:30,800 --> 01:13:36,239
started in the first

01:13:32,560 --> 01:13:38,800
element of this array

01:13:36,239 --> 01:13:40,480
and the map rtt index is pointing to the

01:13:38,800 --> 01:13:42,880
second element of this array

01:13:40,480 --> 01:13:44,159
so the ltd data will be stored in the

01:13:42,880 --> 01:13:47,840
second

01:13:44,159 --> 01:13:51,679
element here um so when i

01:13:47,840 --> 01:13:53,040
call uh bpf soccer storage gap for the

01:13:51,679 --> 01:13:56,239
very first time

01:13:53,040 --> 01:13:59,360
um i want to create that

01:13:56,239 --> 01:14:01,840
um i want to store this data as

01:13:59,360 --> 01:14:02,960
stored this little data to the socket so

01:14:01,840 --> 01:14:06,400
i want to create this

01:14:02,960 --> 01:14:09,679
data um that's why i pass the

01:14:06,400 --> 01:14:13,040
get create thread

01:14:09,679 --> 01:14:16,400
as the last argument in this helper

01:14:13,040 --> 01:14:20,159
um and the first argument is

01:14:16,400 --> 01:14:22,960
the map rtt that can tell us where

01:14:20,159 --> 01:14:23,360
where this ld t data should be started

01:14:22,960 --> 01:14:26,640
to

01:14:23,360 --> 01:14:28,400
in this array and the second argument

01:14:26,640 --> 01:14:30,400
for sure is the socket to tell us which

01:14:28,400 --> 01:14:33,520
socket we want to start with

01:14:30,400 --> 01:14:37,120
and then the third argument is the

01:14:33,520 --> 01:14:40,480
um in in eso data

01:14:37,120 --> 01:14:43,840
we want to start this out t

01:14:40,480 --> 01:14:47,040
value if if this data

01:14:43,840 --> 01:14:48,320
does not exist so it is the very first

01:14:47,040 --> 01:14:51,120
time i call this so

01:14:48,320 --> 01:14:53,920
it does not exist so ltd 10 millisecond

01:14:51,120 --> 01:14:53,920
will be started

01:14:54,840 --> 01:15:00,080
here

01:14:56,960 --> 01:15:03,520
so and then to store the location data

01:15:00,080 --> 01:15:04,960
um we will call the helper again but

01:15:03,520 --> 01:15:07,440
this time we will

01:15:04,960 --> 01:15:09,360
pass in the map location instead instead

01:15:07,440 --> 01:15:11,360
of the map ltd because the map location

01:15:09,360 --> 01:15:13,199
will tell us where to store

01:15:11,360 --> 01:15:15,440
this location data too so it will be the

01:15:13,199 --> 01:15:19,840
first

01:15:15,440 --> 01:15:19,840
element here in this array

01:15:22,560 --> 01:15:30,400
so you may ask how big is this array um

01:15:26,960 --> 01:15:33,840
what if we have uh more data to store

01:15:30,400 --> 01:15:34,960
um than the size of this array uh as i

01:15:33,840 --> 01:15:37,920
said before um

01:15:34,960 --> 01:15:39,199
that's a very simplified version of what

01:15:37,920 --> 01:15:42,000
is happening

01:15:39,199 --> 01:15:42,880
um actually this array is is is a fixed

01:15:42,000 --> 01:15:46,080
size um

01:15:42,880 --> 01:15:49,440
is 60 16 element

01:15:46,080 --> 01:15:52,480
uh but it is only added as a cache so

01:15:49,440 --> 01:15:55,040
and which is backed by a long list as i

01:15:52,480 --> 01:15:55,040
show here

01:15:57,199 --> 01:16:07,840
so the cache is for fast look up time

01:16:00,640 --> 01:16:07,840
for oh which is office um

01:16:07,920 --> 01:16:11,920
okay so we talked about the uh how to

01:16:10,400 --> 01:16:14,640
use the

01:16:11,920 --> 01:16:16,000
um socket local storage from the bpf

01:16:14,640 --> 01:16:18,000
program site

01:16:16,000 --> 01:16:20,159
so how could it be used from the usage

01:16:18,000 --> 01:16:23,199
space program site

01:16:20,159 --> 01:16:26,800
because we have the map um so we

01:16:23,199 --> 01:16:30,080
we will use the map api as usual

01:16:26,800 --> 01:16:31,280
for example we want to update the

01:16:30,080 --> 01:16:34,800
location

01:16:31,280 --> 01:16:37,040
uh we'll pass in the location map fd

01:16:34,800 --> 01:16:38,640
but here now we don't pass in the socket

01:16:37,040 --> 01:16:40,640
pointer we pass in the socket

01:16:38,640 --> 01:16:42,080
file descriptor because in the user

01:16:40,640 --> 01:16:44,159
space there's no

01:16:42,080 --> 01:16:45,679
socket pointer so we're passing a socket

01:16:44,159 --> 01:16:47,360
file descriptor

01:16:45,679 --> 01:16:48,880
and then for example we want to store

01:16:47,360 --> 01:16:52,560
another location then we

01:16:48,880 --> 01:16:57,440
install the passing location yeast um

01:16:52,560 --> 01:17:01,199
here so the point i want to

01:16:57,440 --> 01:17:03,040
uh pronounce you need to elite

01:17:01,199 --> 01:17:05,280
the user space program need to hold a

01:17:03,040 --> 01:17:08,400
socket file descriptor

01:17:05,280 --> 01:17:10,800
um but for some share map uh

01:17:08,400 --> 01:17:11,440
for map that's shared other process may

01:17:10,800 --> 01:17:14,640
not

01:17:11,440 --> 01:17:17,920
have a hold to the file descriptor

01:17:14,640 --> 01:17:20,800
uh so that could be a problem um

01:17:17,920 --> 01:17:24,480
and this part other map has also have

01:17:20,800 --> 01:17:27,120
similar situation for example the um

01:17:24,480 --> 01:17:28,840
socket map or we use for array and and

01:17:27,120 --> 01:17:31,920
field on the map

01:17:28,840 --> 01:17:34,960
also um

01:17:31,920 --> 01:17:39,199
so how to solve it um the

01:17:34,960 --> 01:17:42,960
ideas are being brought up in a few

01:17:39,199 --> 01:17:46,159
locations in um that's an id

01:17:42,960 --> 01:17:49,600
for each uh socket and that id

01:17:46,159 --> 01:17:51,280
is the socket cookie um maybe we can

01:17:49,600 --> 01:17:54,560
have a generic way to

01:17:51,280 --> 01:17:58,000
uh get the file descriptor

01:17:54,560 --> 01:18:01,920
back from from the soccer cookie

01:17:58,000 --> 01:18:05,199
but how to do that um it's still tpd

01:18:01,920 --> 01:18:06,320
um i would love to hear idea of what we

01:18:05,199 --> 01:18:08,560
need to uh

01:18:06,320 --> 01:18:08,890
think about to do that to make that

01:18:08,560 --> 01:18:10,840
happen

01:18:08,890 --> 01:18:13,840
[Music]

01:18:10,840 --> 01:18:13,840
um

01:18:14,000 --> 01:18:23,040
okay uh that that will be all uh

01:18:18,159 --> 01:18:23,040
uh i have for today um

01:18:23,280 --> 01:18:29,679
any questions or things that i can

01:18:27,280 --> 01:18:29,679
answer

01:18:30,640 --> 01:18:34,320
okay great let's see if anyone has any

01:18:32,400 --> 01:18:36,880
questions in the uh chat room

01:18:34,320 --> 01:18:38,800
uh lorenz bower says can we use sd

01:18:36,880 --> 01:18:39,440
storage for internal implementation as

01:18:38,800 --> 01:18:44,480
well

01:18:39,440 --> 01:18:44,480
ieee store socket map state

01:18:48,560 --> 01:18:53,360
what do you mean by internal

01:18:51,280 --> 01:18:56,080
implementation

01:18:53,360 --> 01:18:57,679
uh maybe he's asking if it can be

01:18:56,080 --> 01:18:59,199
accessed from the criminal side as well

01:18:57,679 --> 01:19:04,400
for making state decisions

01:18:59,199 --> 01:19:04,400
internal to the kernel oh um

01:19:05,600 --> 01:19:11,360
yeah why not you see

01:19:08,640 --> 01:19:12,080
it is some data hanging in the socket

01:19:11,360 --> 01:19:15,280
right if

01:19:12,080 --> 01:19:15,920
if you know what the data is why not you

01:19:15,280 --> 01:19:18,080
know

01:19:15,920 --> 01:19:19,199
i don't see why the question would be

01:19:18,080 --> 01:19:21,440
how to represent that

01:19:19,199 --> 01:19:22,480
in the kernel internal api so you could

01:19:21,440 --> 01:19:24,000
interpret the data

01:19:22,480 --> 01:19:26,400
and find out where the indexes are and

01:19:24,000 --> 01:19:26,400
everything

01:19:26,960 --> 01:19:31,840
well it's an it's an array right so um

01:19:30,159 --> 01:19:33,679
if you know what is stored in this

01:19:31,840 --> 01:19:35,840
particular element of

01:19:33,679 --> 01:19:37,040
of this array yeah you can assess it but

01:19:35,840 --> 01:19:40,560
what is in this

01:19:37,040 --> 01:19:44,640
data is it's described by the pdf

01:19:40,560 --> 01:19:46,719
so um i mean i mean

01:19:44,640 --> 01:19:48,800
you can you can make sense of it one

01:19:46,719 --> 01:19:50,640
what what

01:19:48,800 --> 01:19:52,320
what this data is starting with for

01:19:50,640 --> 01:19:54,239
example uh the first

01:19:52,320 --> 01:19:56,800
four byte is the ltd the second followed

01:19:54,239 --> 01:20:00,080
by is the

01:19:56,800 --> 01:20:00,560
is something else but you you still need

01:20:00,080 --> 01:20:03,600
to

01:20:00,560 --> 01:20:04,400
know what semantic is this raw data

01:20:03,600 --> 01:20:06,560
story

01:20:04,400 --> 01:20:07,600
so that is something you have to you

01:20:06,560 --> 01:20:10,159
have to

01:20:07,600 --> 01:20:10,639
you have to go you have to manage with

01:20:10,159 --> 01:20:13,120
the

01:20:10,639 --> 01:20:15,600
bpa program you have you have written

01:20:13,120 --> 01:20:18,880
which store this data in the first place

01:20:15,600 --> 01:20:19,760
right um yeah it's interesting conflict

01:20:18,880 --> 01:20:21,760
because

01:20:19,760 --> 01:20:23,760
bpf allows you to dynamically define

01:20:21,760 --> 01:20:25,679
what this data means whereas the kernel

01:20:23,760 --> 01:20:27,760
is kind of in a static situation

01:20:25,679 --> 01:20:29,520
and you can't dynamically figure out

01:20:27,760 --> 01:20:30,639
what every bpf program is doing with

01:20:29,520 --> 01:20:33,280
this area

01:20:30,639 --> 01:20:35,280
um joe stringer said i was wondering

01:20:33,280 --> 01:20:36,880
about allocation time of the sk local

01:20:35,280 --> 01:20:38,960
storage if i follow

01:20:36,880 --> 01:20:40,960
in your slides it's allocated on first

01:20:38,960 --> 01:20:42,639
use which could delay first packet and

01:20:40,960 --> 01:20:43,600
effect connection establishment latency

01:20:42,639 --> 01:20:45,199
is that right

01:20:43,600 --> 01:20:49,120
could there be a way to tell the kernel

01:20:45,199 --> 01:20:51,520
to pre-allocate a second creation time

01:20:49,120 --> 01:20:54,080
no uh yeah you're correct um sure you're

01:20:51,520 --> 01:20:57,520
correct use um is allocated in the first

01:20:54,080 --> 01:20:58,719
the very first time um that data is

01:20:57,520 --> 01:21:02,159
created um

01:20:58,719 --> 01:21:04,000
but the use case the the target use case

01:21:02,159 --> 01:21:06,800
is that it is created

01:21:04,000 --> 01:21:08,719
um once and then get looked up many

01:21:06,800 --> 01:21:11,199
times

01:21:08,719 --> 01:21:12,719
so that was the top uh the case that we

01:21:11,199 --> 01:21:14,960
are targeting

01:21:12,719 --> 01:21:16,719
so that's why we then pre-allocate it

01:21:14,960 --> 01:21:19,679
and we we do want to

01:21:16,719 --> 01:21:20,639
get away from the plk uh paradigm right

01:21:19,679 --> 01:21:23,920
because we

01:21:20,639 --> 01:21:25,840
we don't want to we don't want to fix

01:21:23,920 --> 01:21:29,280
the size and then get

01:21:25,840 --> 01:21:30,960
uh and then exit this procedure side and

01:21:29,280 --> 01:21:32,159
then we will get into the same problem

01:21:30,960 --> 01:21:34,239
that john

01:21:32,159 --> 01:21:36,400
has described we want and then we want

01:21:34,239 --> 01:21:38,719
to dynamically allocate it

01:21:36,400 --> 01:21:39,520
again so we want to get away from it

01:21:38,719 --> 01:21:42,560
that that

01:21:39,520 --> 01:21:44,880
that was the idea um

01:21:42,560 --> 01:21:46,400
daniel borkman says with respect to tcp

01:21:44,880 --> 01:21:48,719
header option i was wondering about the

01:21:46,400 --> 01:21:50,400
interaction with the gro gso

01:21:48,719 --> 01:21:52,560
but it's only used for the three-way

01:21:50,400 --> 01:21:55,440
handshake and thus not applicable with

01:21:52,560 --> 01:21:58,800
respect to aggregation there correct

01:21:55,440 --> 01:21:59,760
um is uh grogso or tsa student student

01:21:58,800 --> 01:22:04,159
um

01:21:59,760 --> 01:22:08,480
didn't have anything to do

01:22:04,159 --> 01:22:12,320
it's an rft gso or tso gel because

01:22:08,480 --> 01:22:15,760
it is done in the tcp uh stat rate

01:22:12,320 --> 01:22:16,239
so everything else will everything gso

01:22:15,760 --> 01:22:18,320
and ts

01:22:16,239 --> 01:22:19,760
and general will will work with work

01:22:18,320 --> 01:22:24,080
assets i mean

01:22:19,760 --> 01:22:27,120
imagine we want to add a new uh

01:22:24,080 --> 01:22:28,800
header option and maybe a new rfc

01:22:27,120 --> 01:22:30,800
becomes standard tomorrow we want to add

01:22:28,800 --> 01:22:31,840
support this option in the tcp that way

01:22:30,800 --> 01:22:34,800
differently in the kernel

01:22:31,840 --> 01:22:35,520
it will also add this option in the tcp

01:22:34,800 --> 01:22:38,400
stack and

01:22:35,520 --> 01:22:39,199
we don't have to change the gso or glo

01:22:38,400 --> 01:22:41,760
also

01:22:39,199 --> 01:22:44,639
so the same thing will be true for the

01:22:41,760 --> 01:22:47,280
for the uh bpftcp header options

01:22:44,639 --> 01:22:49,360
because it seems that the options are

01:22:47,280 --> 01:22:50,400
only edited by the bpf helpers you've

01:22:49,360 --> 01:22:51,760
defined for the

01:22:50,400 --> 01:22:54,080
for example congestion control

01:22:51,760 --> 01:22:56,880
operations and the tcp header

01:22:54,080 --> 01:22:58,480
modification so that's inside the kernel

01:22:56,880 --> 01:23:02,320
and therefore the kernel helper should

01:22:58,480 --> 01:23:02,320
handle gso properly in gro

01:23:04,840 --> 01:23:09,600
um

01:23:06,639 --> 01:23:11,440
the the helper does help to write it to

01:23:09,600 --> 01:23:15,040
the skb itself

01:23:11,440 --> 01:23:17,920
but the uh but it is done exactly

01:23:15,040 --> 01:23:19,520
as the set at the same place at as the

01:23:17,920 --> 01:23:23,040
kernel will write a

01:23:19,520 --> 01:23:25,199
head option so so it

01:23:23,040 --> 01:23:26,080
won't it won't change it won't affect

01:23:25,199 --> 01:23:30,239
the gso

01:23:26,080 --> 01:23:30,239
at all right yeah

01:23:30,639 --> 01:23:34,639
hey do we have any other questions

01:23:32,960 --> 01:23:36,960
anyone else have anything to ask

01:23:34,639 --> 01:23:36,960
martin

01:23:41,120 --> 01:23:49,840
mason is typing let's give him a moment

01:24:00,080 --> 01:24:04,159
and now while i'm waiting for this um

01:24:02,800 --> 01:24:05,840
there are some people in the

01:24:04,159 --> 01:24:07,920
tooling micro conference who had some

01:24:05,840 --> 01:24:10,560
bpf questions and elena

01:24:07,920 --> 01:24:12,080
asked me to let people know so you could

01:24:10,560 --> 01:24:14,000
head over there later if you have the

01:24:12,080 --> 01:24:15,679
time and want to help out answer some

01:24:14,000 --> 01:24:17,199
ppf questions over there the tooling

01:24:15,679 --> 01:24:18,800
people would appreciate it

01:24:17,199 --> 01:24:20,639
uh kevin mason says very cool

01:24:18,800 --> 01:24:21,760
presentation i can see it inspiring a

01:24:20,639 --> 01:24:25,120
lot of new ideas

01:24:21,760 --> 01:24:28,840
that's great uh vladimir koroskov

01:24:25,120 --> 01:24:30,080
says do you use it already in production

01:24:28,840 --> 01:24:32,560
environment

01:24:30,080 --> 01:24:34,080
yeah for the circus local storage we we

01:24:32,560 --> 01:24:36,639
are using it

01:24:34,080 --> 01:24:38,239
we're using it in the environment for

01:24:36,639 --> 01:24:40,320
the tcp

01:24:38,239 --> 01:24:42,320
congestion control we had we are

01:24:40,320 --> 01:24:45,760
definitely testing um

01:24:42,320 --> 01:24:49,040
uh some uh construction control

01:24:45,760 --> 01:24:50,800
in in in the production also but not in

01:24:49,040 --> 01:24:52,480
in the full bone scale but we are

01:24:50,800 --> 01:24:54,400
we're testing it but that but that's

01:24:52,480 --> 01:24:56,000
what it's supposed to be right we want

01:24:54,400 --> 01:24:57,600
to make it easier to test it

01:24:56,000 --> 01:24:59,120
in the production so we're testing we're

01:24:57,600 --> 01:25:02,000
definitely testing some

01:24:59,120 --> 01:25:04,000
new construction control in in that

01:25:02,000 --> 01:25:06,560
space also yeah

01:25:04,000 --> 01:25:08,400
uh jonathan lemon asks how does the vpn

01:25:06,560 --> 01:25:13,360
sk storage compared to the sk

01:25:08,400 --> 01:25:16,800
extension storage

01:25:13,360 --> 01:25:19,760
how does that compare to the

01:25:16,800 --> 01:25:20,480
yes you mean the skb extension storage

01:25:19,760 --> 01:25:22,320
or sk

01:25:20,480 --> 01:25:24,840
i think that may be what he is referring

01:25:22,320 --> 01:25:28,000
to right

01:25:24,840 --> 01:25:31,520
um skb extension storage

01:25:28,000 --> 01:25:33,600
uh i don't know i haven't take a quick

01:25:31,520 --> 01:25:35,040
i haven't take a deep look into it but

01:25:33,600 --> 01:25:38,719
uh

01:25:35,040 --> 01:25:43,360
you mean can we can we extend skb

01:25:38,719 --> 01:25:46,719
also uh maybe that will be

01:25:43,360 --> 01:25:49,520
a more controversial discussion on

01:25:46,719 --> 01:25:52,239
extended skb i think that's an

01:25:49,520 --> 01:25:52,239
understatement

01:25:53,120 --> 01:25:58,000
um uh john fasstermann asks i want to

01:25:55,520 --> 01:26:01,679
enable sk storage get from k-pop tracing

01:25:58,000 --> 01:26:01,679
side are there any objections to that

01:26:02,560 --> 01:26:09,360
oh yeah um actually that's one of the

01:26:06,000 --> 01:26:12,239
to-do lists if uh yeah if

01:26:09,360 --> 01:26:14,880
i will be happy if you want it uh take

01:26:12,239 --> 01:26:14,880
it on yeah

01:26:15,520 --> 01:26:20,080
but one thing one thing definitely we

01:26:17,199 --> 01:26:23,120
have to keep in mind is the uh

01:26:20,080 --> 01:26:25,679
because um we cannot call we cannot

01:26:23,120 --> 01:26:28,480
access the

01:26:25,679 --> 01:26:29,920
we because k-pop tracing is like we

01:26:28,480 --> 01:26:32,400
don't know where it will be

01:26:29,920 --> 01:26:34,719
called away we don't know where this sk

01:26:32,400 --> 01:26:37,040
storage gap will be called the way

01:26:34,719 --> 01:26:39,440
and that okay imagine in some of the

01:26:37,040 --> 01:26:41,679
tracing in some of the function

01:26:39,440 --> 01:26:43,199
uh if we trace that and then we call sk

01:26:41,679 --> 01:26:46,000
storage gap it will

01:26:43,199 --> 01:26:46,320
it may not be safe for example if the if

01:26:46,000 --> 01:26:49,760
this

01:26:46,320 --> 01:26:52,239
um if the socket is under this under

01:26:49,760 --> 01:26:54,000
destruction if we trace it there it

01:26:52,239 --> 01:26:56,480
probably won't be safe

01:26:54,000 --> 01:26:58,080
yeah john mentions that uh i guess we

01:26:56,480 --> 01:27:00,239
need the sock lock at least

01:26:58,080 --> 01:27:01,520
uh as a minimal requirement for calling

01:27:00,239 --> 01:27:05,760
the get

01:27:01,520 --> 01:27:08,000
operation um probably no because

01:27:05,760 --> 01:27:10,080
when i write this uh socket local

01:27:08,000 --> 01:27:13,440
storage i have

01:27:10,080 --> 01:27:16,080
i have uh i have tried

01:27:13,440 --> 01:27:16,960
to avoid the cases that in this thought

01:27:16,080 --> 01:27:19,199
log

01:27:16,960 --> 01:27:21,280
so i tried very hard law to use the salt

01:27:19,199 --> 01:27:22,239
law and it's it's not using salt law at

01:27:21,280 --> 01:27:24,080
all

01:27:22,239 --> 01:27:25,280
so i don't think that will be the

01:27:24,080 --> 01:27:28,110
concern

01:27:25,280 --> 01:27:29,760
um yeah but the thing is um

01:27:28,110 --> 01:27:32,080
[Music]

01:27:29,760 --> 01:27:32,960
but more i'm more concerned whether it

01:27:32,080 --> 01:27:36,719
is safe to

01:27:32,960 --> 01:27:39,280
like create or delete a

01:27:36,719 --> 01:27:40,960
local storage on all the tracing pawn

01:27:39,280 --> 01:27:44,560
that we can we can hook on

01:27:40,960 --> 01:27:48,080
so that we definitely need to audit it

01:27:44,560 --> 01:27:51,360
um so the idea is to release

01:27:48,080 --> 01:27:56,320
some of the function uh

01:27:51,360 --> 01:27:58,960
we can call uh socket storage gap

01:27:56,320 --> 01:28:00,800
that um we can we use some of the word

01:27:58,960 --> 01:28:04,239
that jury has

01:28:00,800 --> 01:28:07,280
landed to write list the d-path

01:28:04,239 --> 01:28:09,840
the d-path helper we can definitely

01:28:07,280 --> 01:28:12,080
try to write on that to write this a few

01:28:09,840 --> 01:28:13,760
uh function we want to trace

01:28:12,080 --> 01:28:15,360
um presumably you would need some

01:28:13,760 --> 01:28:16,159
synchronization though for the first

01:28:15,360 --> 01:28:18,239
time a storage

01:28:16,159 --> 01:28:19,520
object is accessed for a socket because

01:28:18,239 --> 01:28:21,280
you're creating

01:28:19,520 --> 01:28:24,960
this the slot you're allocating and

01:28:21,280 --> 01:28:24,960
setting up the slot that first time

01:28:25,199 --> 01:28:31,199
yeah um yes uh

01:28:28,800 --> 01:28:32,000
there's a but that you that's that

01:28:31,199 --> 01:28:35,520
you're correct

01:28:32,000 --> 01:28:38,000
they've um that we uh we

01:28:35,520 --> 01:28:39,600
use a spin knot but that there's a

01:28:38,000 --> 01:28:40,000
different spin there's a different knot

01:28:39,600 --> 01:28:42,719
that

01:28:40,000 --> 01:28:43,199
we don't use the this uh the salt law is

01:28:42,719 --> 01:28:45,600
not used

01:28:43,199 --> 01:28:47,040
it's a totally different lock okay that

01:28:45,600 --> 01:28:49,280
that should solve the allocation case

01:28:47,040 --> 01:28:49,280
then

01:28:54,400 --> 01:29:00,480
hey john says thank you uh that's great

01:28:56,639 --> 01:29:00,480
i do have any more questions for martin

01:29:02,719 --> 01:29:06,080
looks like john lennon is typing uh he

01:29:05,120 --> 01:29:08,320
also says thank you

01:29:06,080 --> 01:29:09,760
great um thanks martin for your

01:29:08,320 --> 01:29:10,239
presentation this is really interesting

01:29:09,760 --> 01:29:11,440
work

01:29:10,239 --> 01:29:14,639
thanks for showing us what you've been

01:29:11,440 --> 01:29:18,080
up to thanks

01:29:14,639 --> 01:29:21,840
all right everyone we are in the uh

01:29:18,080 --> 01:29:25,120
break until nine o'clock

01:29:21,840 --> 01:29:27,040
um a reminder again if anyone here who

01:29:25,120 --> 01:29:28,719
is a bpf expert wants to go help

01:29:27,040 --> 01:29:30,719
out the tooling micro conference they

01:29:28,719 --> 01:29:31,920
apparently have some uh bpf related

01:29:30,719 --> 01:29:34,400
questions there and nikki to

01:29:31,920 --> 01:29:35,280
help you out i've also notified them of

01:29:34,400 --> 01:29:37,840
the weekly

01:29:35,280 --> 01:29:39,600
bpf office hours and elena will let

01:29:37,840 --> 01:29:40,080
everyone there know about that so that

01:29:39,600 --> 01:29:41,520
if

01:29:40,080 --> 01:29:43,679
they can't get their questions answered

01:29:41,520 --> 01:29:44,800
they could attend uh but once again if

01:29:43,679 --> 01:29:45,440
you could give them a hand that would

01:29:44,800 --> 01:29:47,520
really help

01:29:45,440 --> 01:29:49,040
just head on over there as you when you

01:29:47,520 --> 01:29:51,120
get a chance and uh

01:29:49,040 --> 01:30:07,840
try to give them a hand okay all right

01:29:51,120 --> 01:30:07,840
thank you we'll see you in half an hour

01:30:13,770 --> 01:30:17,569
[Music]

01:57:34,400 --> 01:57:38,080
hey everyone we're about five minutes

01:57:36,880 --> 01:57:41,119
left on the break

01:57:38,080 --> 01:57:42,320
and um once that's done i'm at the top

01:57:41,119 --> 01:57:44,960
of the hour

01:57:42,320 --> 01:57:47,199
we'll hand things over to william too so

01:57:44,960 --> 01:57:49,119
you can talk to us about using space obs

01:57:47,199 --> 01:57:50,639
with hardware offloading af xd page

01:57:49,119 --> 01:57:52,719
which would be very interesting

01:57:50,639 --> 01:57:54,800
kind of a follow-up to his presentation

01:57:52,719 --> 01:57:57,599
in vancouver

01:57:54,800 --> 01:57:59,040
um good to see how that's going um if

01:57:57,599 --> 01:58:01,520
you could click the

01:57:59,040 --> 01:58:03,040
ready button in the poll that would be

01:58:01,520 --> 01:58:05,599
great i can kind of get an idea of how

01:58:03,040 --> 01:58:06,960
many people in the room are

01:58:05,599 --> 01:58:08,800
sitting in front of their seats and are

01:58:06,960 --> 01:58:12,400
ready to go

01:58:08,800 --> 01:58:15,599
um yeah so let's get ready for

01:58:12,400 --> 01:58:21,840
the last and final presentation of the

01:58:15,599 --> 01:58:21,840
networking and vp of summit of lpc2020

02:01:26,400 --> 02:01:30,080
okay william your slides are loaded you

02:01:28,480 --> 02:01:33,360
should be able to control them now

02:01:30,080 --> 02:01:37,040
and in a minute or two uh you can begin

02:01:33,360 --> 02:01:51,840
your presentation

02:01:37,040 --> 02:01:51,840
okay thank you yes i can control it

02:02:16,840 --> 02:02:19,840
so

02:03:10,159 --> 02:03:13,440
okay william you can begin whenever

02:03:11,599 --> 02:03:16,880
you're ready

02:03:13,440 --> 02:03:16,880
um okay thank you

02:03:20,159 --> 02:03:26,719
okay uh um thank you so um

02:03:23,920 --> 02:03:29,599
hello everyone i am william two today

02:03:26,719 --> 02:03:32,800
i'm going to talk about user space

02:03:29,599 --> 02:03:36,960
ovs with power of flow and

02:03:32,800 --> 02:03:40,320
afxdp so

02:03:36,960 --> 02:03:43,920
first i'll give some introduction about

02:03:40,320 --> 02:03:45,119
the ovs kernel module and obvious user

02:03:43,920 --> 02:03:48,159
space that have passed

02:03:45,119 --> 02:03:48,960
so majorly we have two or three data

02:03:48,159 --> 02:03:52,320
paths

02:03:48,960 --> 02:03:55,280
of obs today and then um

02:03:52,320 --> 02:03:57,280
they have a task has to couple with the

02:03:55,280 --> 02:03:58,560
packet i o library like to send and

02:03:57,280 --> 02:04:01,760
receive packing

02:03:58,560 --> 02:04:05,119
so i'll talk about dpdk and afx

02:04:01,760 --> 02:04:07,840
af xtp these are the two ways to

02:04:05,119 --> 02:04:09,040
send and receive packet to the database

02:04:07,840 --> 02:04:10,560
pass

02:04:09,040 --> 02:04:13,040
and then we are thinking about using

02:04:10,560 --> 02:04:16,560
some power flow mechanism today

02:04:13,040 --> 02:04:19,760
um obvious has a tc flower support

02:04:16,560 --> 02:04:23,360
and also rte flow support

02:04:19,760 --> 02:04:23,679
one for the dpdk use case the other for

02:04:23,360 --> 02:04:26,719
the

02:04:23,679 --> 02:04:29,440
kernel use case

02:04:26,719 --> 02:04:30,719
uh then we'll talk about the design of

02:04:29,440 --> 02:04:32,639
this uh

02:04:30,719 --> 02:04:35,040
so these are things we are trying to do

02:04:32,639 --> 02:04:35,840
is to use the user space they have

02:04:35,040 --> 02:04:39,199
passed

02:04:35,840 --> 02:04:44,800
with tc flower or flow and

02:04:39,199 --> 02:04:44,800
afxdp and share some performance number

02:04:47,360 --> 02:04:54,480
so obs cell majorly has two components

02:04:51,360 --> 02:04:57,280
one is in slow pass the other is at

02:04:54,480 --> 02:04:58,079
fastpass so the slow pass part is

02:04:57,280 --> 02:05:02,239
majorly

02:04:58,079 --> 02:05:05,360
uh user space daemon called obs v6d

02:05:02,239 --> 02:05:06,079
so usually the sdn controller or network

02:05:05,360 --> 02:05:08,800
controller

02:05:06,079 --> 02:05:11,520
will have higher level network policies

02:05:08,800 --> 02:05:13,520
like dropping the packet or

02:05:11,520 --> 02:05:14,960
for a particular tenant and apply

02:05:13,520 --> 02:05:17,520
certain network

02:05:14,960 --> 02:05:20,560
firewall rules and then they'll convert

02:05:17,520 --> 02:05:24,159
this policy into a open flow rules

02:05:20,560 --> 02:05:27,520
and program into the open v switch

02:05:24,159 --> 02:05:28,560
the obvious v3d implement the open flow

02:05:27,520 --> 02:05:30,960
protocol

02:05:28,560 --> 02:05:31,760
so it has support like multiple table

02:05:30,960 --> 02:05:34,960
lookup

02:05:31,760 --> 02:05:36,560
and each table will do a protocol

02:05:34,960 --> 02:05:39,920
support passing the

02:05:36,560 --> 02:05:41,760
product headers applying actions to

02:05:39,920 --> 02:05:44,079
different

02:05:41,760 --> 02:05:45,520
match and action rules and jump to

02:05:44,079 --> 02:05:49,679
another table

02:05:45,520 --> 02:05:51,440
for example and so for every packet

02:05:49,679 --> 02:05:54,159
coming into the ovs

02:05:51,440 --> 02:05:54,960
so the first package always go to the

02:05:54,159 --> 02:05:58,079
slow pass

02:05:54,960 --> 02:06:01,040
so the data pass part is a cache so

02:05:58,079 --> 02:06:01,520
in the beginning the cache is empty so

02:06:01,040 --> 02:06:04,239
um

02:06:01,520 --> 02:06:05,440
it goes to the user space obs the slows

02:06:04,239 --> 02:06:08,000
pass part

02:06:05,440 --> 02:06:09,040
and then once it resolve how to handle

02:06:08,000 --> 02:06:12,320
this packet

02:06:09,040 --> 02:06:15,280
it insert a cache into its data path

02:06:12,320 --> 02:06:17,840
so that the subsequent packet will just

02:06:15,280 --> 02:06:20,639
stay in the fastpass

02:06:17,840 --> 02:06:23,840
so this is basically how obs achieve

02:06:20,639 --> 02:06:23,840
good performance today

02:06:26,159 --> 02:06:31,920
so one data path is

02:06:29,599 --> 02:06:33,840
inside the linux kernel it's actually

02:06:31,920 --> 02:06:36,880
called openly switched

02:06:33,840 --> 02:06:39,520
ko um so the idea

02:06:36,880 --> 02:06:40,480
how it works is that the kernel module

02:06:39,520 --> 02:06:43,360
register

02:06:40,480 --> 02:06:44,159
an rx hook and receive all the packets

02:06:43,360 --> 02:06:47,440
from the

02:06:44,159 --> 02:06:51,199
particular net dev and then we apply

02:06:47,440 --> 02:06:54,159
um like pass the packet

02:06:51,199 --> 02:06:56,639
and then we do table look up and then we

02:06:54,159 --> 02:06:58,960
apply actions to the packet

02:06:56,639 --> 02:06:59,920
so this is how the obvious kernel module

02:06:58,960 --> 02:07:03,520
work

02:06:59,920 --> 02:07:06,719
um so far it works on a variety of

02:07:03,520 --> 02:07:08,560
different linux distributions and it's

02:07:06,719 --> 02:07:09,760
well it's been well tested and

02:07:08,560 --> 02:07:13,599
integrated and

02:07:09,760 --> 02:07:15,840
used other linux kernel component

02:07:13,599 --> 02:07:16,639
for example today obvious kernel module

02:07:15,840 --> 02:07:19,119
use uh

02:07:16,639 --> 02:07:20,159
nefilter subsystems for cognition

02:07:19,119 --> 02:07:22,639
tracking

02:07:20,159 --> 02:07:24,880
and it also share and use the linux

02:07:22,639 --> 02:07:28,239
kernel's

02:07:24,880 --> 02:07:32,719
tunnel uh implementation for example

02:07:28,239 --> 02:07:36,719
like genevieve tunnel vxlan tunnel so

02:07:32,719 --> 02:07:38,079
however this uh kernel module is well

02:07:36,719 --> 02:07:41,119
tested but it has

02:07:38,079 --> 02:07:44,239
kernel overhead

02:07:41,119 --> 02:07:47,040
so another obvious data path

02:07:44,239 --> 02:07:48,159
is uh not in kernel but in the user

02:07:47,040 --> 02:07:52,000
space

02:07:48,159 --> 02:07:55,679
so this is usually used by

02:07:52,000 --> 02:07:58,639
a community called obs dpdk

02:07:55,679 --> 02:08:01,199
so the idea is that we want to do the

02:07:58,639 --> 02:08:04,719
packet processing in user space

02:08:01,199 --> 02:08:08,159
but first we need to have a fast

02:08:04,719 --> 02:08:11,440
io packet io channel so here we are

02:08:08,159 --> 02:08:13,520
using the dpdk library to

02:08:11,440 --> 02:08:15,599
send and receive to receive the package

02:08:13,520 --> 02:08:18,239
from the network device

02:08:15,599 --> 02:08:19,440
and do the rest rest of the processing

02:08:18,239 --> 02:08:22,880
in user space

02:08:19,440 --> 02:08:24,560
and then send it out again using the btk

02:08:22,880 --> 02:08:27,760
library

02:08:24,560 --> 02:08:31,599
so it's very fast because uh first

02:08:27,760 --> 02:08:34,560
we have a we have a fast channel

02:08:31,599 --> 02:08:36,239
to get to send and receive packet and

02:08:34,560 --> 02:08:39,040
then we also have uh

02:08:36,239 --> 02:08:40,960
lots of optimization in this user space

02:08:39,040 --> 02:08:43,599
that are passed

02:08:40,960 --> 02:08:45,520
however it's not very widely used

02:08:43,599 --> 02:08:48,719
because uh

02:08:45,520 --> 02:08:50,079
first deploying and debugging dpdk is a

02:08:48,719 --> 02:08:52,239
little bit hard

02:08:50,079 --> 02:08:53,520
it usually involves a lot of low level

02:08:52,239 --> 02:08:55,199
details

02:08:53,520 --> 02:08:57,760
it's not like lingerie's kernel which

02:08:55,199 --> 02:08:58,800
has a very good abstraction uh like

02:08:57,760 --> 02:09:00,639
people

02:08:58,800 --> 02:09:02,560
don't need to know much about the low

02:09:00,639 --> 02:09:06,000
level details

02:09:02,560 --> 02:09:08,880
and another case is that usually this

02:09:06,000 --> 02:09:09,280
obvious dpdk deployment deployment is

02:09:08,880 --> 02:09:12,320
for

02:09:09,280 --> 02:09:15,119
the um appliance use case

02:09:12,320 --> 02:09:17,440
so people has dedicated server who want

02:09:15,119 --> 02:09:18,079
to outbands the performance a lot so

02:09:17,440 --> 02:09:21,679
they

02:09:18,079 --> 02:09:21,679
deploy ovsdpdk

02:09:22,480 --> 02:09:26,880
so uh the motivation of the problem we

02:09:25,599 --> 02:09:30,000
are thinking about here

02:09:26,880 --> 02:09:33,040
is that so customer today

02:09:30,000 --> 02:09:35,119
they deploy one of the two so

02:09:33,040 --> 02:09:37,280
today you can run obvious kernel there

02:09:35,119 --> 02:09:40,400
pass which is stable

02:09:37,280 --> 02:09:42,320
has a lot of feature well tested it

02:09:40,400 --> 02:09:44,719
shipped with all the linux

02:09:42,320 --> 02:09:47,199
distribution so it's good for the

02:09:44,719 --> 02:09:50,560
hypervisor or the enterprise

02:09:47,199 --> 02:09:51,280
use case so another model another case

02:09:50,560 --> 02:09:53,280
is for

02:09:51,280 --> 02:09:54,560
the high performance customer who want

02:09:53,280 --> 02:09:58,560
to use

02:09:54,560 --> 02:10:01,599
dpdk user space they have passed

02:09:58,560 --> 02:10:03,360
so uh so they they deploy obvious dpdk

02:10:01,599 --> 02:10:06,239
with dedicated hardware

02:10:03,360 --> 02:10:06,800
and they have to have some dpdk

02:10:06,239 --> 02:10:08,880
knowledge

02:10:06,800 --> 02:10:10,880
to how to tune the performance to get

02:10:08,880 --> 02:10:14,320
the best numbers

02:10:10,880 --> 02:10:17,360
um so the problem is that maintaining

02:10:14,320 --> 02:10:19,119
uh and running to the high pass is is

02:10:17,360 --> 02:10:24,480
difficult

02:10:19,119 --> 02:10:27,599
for example uh today for if we implement

02:10:24,480 --> 02:10:30,320
some features in the obs for example

02:10:27,599 --> 02:10:31,679
gtp recently we have implemented gtpu

02:10:30,320 --> 02:10:33,679
tunnel features

02:10:31,679 --> 02:10:34,880
so this feature we implement in user

02:10:33,679 --> 02:10:36,639
space data pass

02:10:34,880 --> 02:10:39,199
but we didn't implement we didn't

02:10:36,639 --> 02:10:41,520
integrate into the kernel that i passed

02:10:39,199 --> 02:10:42,639
so we then we have to maintain a list

02:10:41,520 --> 02:10:44,719
saying that

02:10:42,639 --> 02:10:46,480
okay this is a list and this is the

02:10:44,719 --> 02:10:49,599
features some features

02:10:46,480 --> 02:10:52,719
we have done in user space there past

02:10:49,599 --> 02:10:53,360
some feature we have done in kernel they

02:10:52,719 --> 02:10:56,560
are past

02:10:53,360 --> 02:10:59,360
since whatever version or sometimes

02:10:56,560 --> 02:11:00,800
both features are there but uh

02:10:59,360 --> 02:11:04,800
implementation are

02:11:00,800 --> 02:11:08,800
different so sometimes uh the bug

02:11:04,800 --> 02:11:08,800
happens and it's pretty confusing

02:11:08,960 --> 02:11:12,800
so um so what we are thinking is that

02:11:11,920 --> 02:11:15,679
can we

02:11:12,800 --> 02:11:17,040
have just one data path uh

02:11:15,679 --> 02:11:20,800
implementation just use

02:11:17,040 --> 02:11:22,960
one for the both for both use case for

02:11:20,800 --> 02:11:25,440
the

02:11:22,960 --> 02:11:26,400
enterprise use customer use case and for

02:11:25,440 --> 02:11:29,920
the

02:11:26,400 --> 02:11:29,920
high performance customers

02:11:30,800 --> 02:11:37,599
so we think afx dp or xtp might be

02:11:34,960 --> 02:11:38,400
a solution we are still trying to

02:11:37,599 --> 02:11:41,840
experiment

02:11:38,400 --> 02:11:42,239
and building a prototype so xdp stands

02:11:41,840 --> 02:11:45,920
for

02:11:42,239 --> 02:11:47,599
express they have pass basically you

02:11:45,920 --> 02:11:50,480
have an ebpa program

02:11:47,599 --> 02:11:52,880
and this program runs at the very

02:11:50,480 --> 02:11:56,960
beginning of the package received pass

02:11:52,880 --> 02:12:00,480
at the driver level so af xdp

02:11:56,960 --> 02:12:03,040
is a new circuit type um so we should

02:12:00,480 --> 02:12:06,560
allow you to send and receive packet

02:12:03,040 --> 02:12:06,960
with a very high speed so you can write

02:12:06,560 --> 02:12:10,960
an

02:12:06,960 --> 02:12:13,360
xdp program and then have your selective

02:12:10,960 --> 02:12:14,560
logic and then send the packet to this

02:12:13,360 --> 02:12:18,480
circuit

02:12:14,560 --> 02:12:21,119
so that the kernel is bypassed and then

02:12:18,480 --> 02:12:22,239
with if with the driver a vendor's

02:12:21,119 --> 02:12:25,040
driver support

02:12:22,239 --> 02:12:26,400
like zero copy support um you can get a

02:12:25,040 --> 02:12:29,760
very good performance

02:12:26,400 --> 02:12:32,880
like close to the line rate of

02:12:29,760 --> 02:12:36,159
10 or 25 gig

02:12:32,880 --> 02:12:40,400
so uh since obs 212 we

02:12:36,159 --> 02:12:44,880
have uh implement the idea of afx dp

02:12:40,400 --> 02:12:48,560
into the obvious so the idea is that we

02:12:44,880 --> 02:12:49,920
use fxdp socket as a way to send and

02:12:48,560 --> 02:12:53,280
receive package

02:12:49,920 --> 02:12:54,639
so we inject a xdp program in the driver

02:12:53,280 --> 02:12:57,679
level

02:12:54,639 --> 02:12:59,520
so far we didn't do much we

02:12:57,679 --> 02:13:02,480
we pretty much send all the package to

02:12:59,520 --> 02:13:05,520
the user space they have passed and once

02:13:02,480 --> 02:13:09,360
obvious receive this packet it just

02:13:05,520 --> 02:13:12,480
follows the obvious pipeline

02:13:09,360 --> 02:13:12,880
implementation so it was to mention that

02:13:12,480 --> 02:13:16,079
this

02:13:12,880 --> 02:13:18,880
user space there has is the same code

02:13:16,079 --> 02:13:20,480
as the there are paths used by the

02:13:18,880 --> 02:13:22,960
obvious dpdk

02:13:20,480 --> 02:13:24,880
so basically all the implementation can

02:13:22,960 --> 02:13:27,760
be shared here with

02:13:24,880 --> 02:13:28,239
obvious dpdk so the only difference is

02:13:27,760 --> 02:13:31,440
that

02:13:28,239 --> 02:13:33,040
the way we receive packet is through

02:13:31,440 --> 02:13:37,840
fxdp circuit

02:13:33,040 --> 02:13:45,119
instead of using the obs

02:13:37,840 --> 02:13:47,119
instead of using a dpdk library

02:13:45,119 --> 02:13:48,239
so this is a quick performance

02:13:47,119 --> 02:13:51,599
comparison

02:13:48,239 --> 02:13:54,639
um so on the y axis

02:13:51,599 --> 02:13:57,040
we are measuring the packet rate

02:13:54,639 --> 02:13:58,000
million packet per second so this is two

02:13:57,040 --> 02:14:01,199
machines

02:13:58,000 --> 02:14:04,400
uh one runs traffic generator

02:14:01,199 --> 02:14:07,440
sending 64 by udp packet

02:14:04,400 --> 02:14:08,320
the other machine runs ovs and then just

02:14:07,440 --> 02:14:10,480
do

02:14:08,320 --> 02:14:12,159
nothing but forwarding from one port to

02:14:10,480 --> 02:14:15,360
another port

02:14:12,159 --> 02:14:16,480
so for if we install one flow um for the

02:14:15,360 --> 02:14:18,719
kernel data pass

02:14:16,480 --> 02:14:20,400
it's showing like a little bit above 1

02:14:18,719 --> 02:14:24,159
million

02:14:20,400 --> 02:14:28,239
for the user space they have has the ud

02:14:24,159 --> 02:14:30,639
plus obvious dp obvious af xdp

02:14:28,239 --> 02:14:31,520
so it shows much better like close to

02:14:30,639 --> 02:14:34,960
four million

02:14:31,520 --> 02:14:38,320
packet per second and here's the

02:14:34,960 --> 02:14:41,920
obvious dpdk like running

02:14:38,320 --> 02:14:44,639
dpdk with ix3b pnd driver

02:14:41,920 --> 02:14:46,719
shows very good like more than 9 million

02:14:44,639 --> 02:14:49,920
packets per second

02:14:46,719 --> 02:14:50,320
so it's obvious fxdb is still slower

02:14:49,920 --> 02:14:53,599
than

02:14:50,320 --> 02:14:55,920
the dpdk and uh

02:14:53,599 --> 02:14:58,159
here for the kernel that they have has

02:14:55,920 --> 02:15:01,280
if we install 1k flow

02:14:58,159 --> 02:15:04,400
the packet rate improves a lot to

02:15:01,280 --> 02:15:06,560
8 million packets per second but that's

02:15:04,400 --> 02:15:09,360
because um

02:15:06,560 --> 02:15:12,480
because there are more flows and this

02:15:09,360 --> 02:15:14,480
flow are spread into different cpu coils

02:15:12,480 --> 02:15:16,400
so there are more soft irq demon

02:15:14,480 --> 02:15:19,760
processing the package so

02:15:16,400 --> 02:15:24,880
um basically it use more cpu to

02:15:19,760 --> 02:15:28,480
get that they can get better packet rate

02:15:24,880 --> 02:15:31,840
also in the case of uh fxdp

02:15:28,480 --> 02:15:35,520
we also see that it's using less cpu but

02:15:31,840 --> 02:15:38,960
usually because fxdp still

02:15:35,520 --> 02:15:39,599
runs the device driver so the usually we

02:15:38,960 --> 02:15:42,800
see that

02:15:39,599 --> 02:15:46,880
another soft irq daemon is also running

02:15:42,800 --> 02:15:49,920
so it compared to obvious dpdk

02:15:46,880 --> 02:15:53,360
it also use more cpu

02:15:49,920 --> 02:15:56,639
cpu times so

02:15:53,360 --> 02:15:59,599
the the take away from this

02:15:56,639 --> 02:16:00,159
quick experiment is that today for the

02:15:59,599 --> 02:16:03,199
ovs

02:16:00,159 --> 02:16:04,079
side the user space that happens with

02:16:03,199 --> 02:16:07,440
afx dp

02:16:04,079 --> 02:16:09,199
is the performance is much better than

02:16:07,440 --> 02:16:13,280
kernel they have passed

02:16:09,199 --> 02:16:16,320
by still slower than the dpdk

02:16:13,280 --> 02:16:18,960
obviously bdk case

02:16:16,320 --> 02:16:19,679
so what we are thinking is that uh for

02:16:18,960 --> 02:16:22,960
the future

02:16:19,679 --> 02:16:25,599
we are we we are planning to improve

02:16:22,960 --> 02:16:27,040
uh the and more improvement to the obs

02:16:25,599 --> 02:16:29,679
xdp

02:16:27,040 --> 02:16:30,320
but to get better for performance we are

02:16:29,679 --> 02:16:34,399
also

02:16:30,320 --> 02:16:37,760
thinking about a hardware flow so

02:16:34,399 --> 02:16:41,040
today there are two ways to do it so

02:16:37,760 --> 02:16:44,479
if you run obviously pdk which

02:16:41,040 --> 02:16:45,439
runs obs and compile it with dpdk

02:16:44,479 --> 02:16:48,240
library

02:16:45,439 --> 02:16:49,359
then you can use the rte flow api

02:16:48,240 --> 02:16:52,559
provided by

02:16:49,359 --> 02:16:55,120
the dbek

02:16:52,559 --> 02:16:57,439
that's one way and the other way is you

02:16:55,120 --> 02:17:00,559
use obvious kernel they have pass

02:16:57,439 --> 02:17:04,000
and allowing the driver running

02:17:00,559 --> 02:17:06,479
because the driver is still running so

02:17:04,000 --> 02:17:07,120
the tc floor you can use the tc flower

02:17:06,479 --> 02:17:10,160
way to

02:17:07,120 --> 02:17:12,960
offload so

02:17:10,160 --> 02:17:14,399
here we found that we want to use user

02:17:12,960 --> 02:17:18,160
space they have s because it's

02:17:14,399 --> 02:17:21,280
fast but if you use dpdk then dpdk

02:17:18,160 --> 02:17:24,639
will unload the driver so tc flower

02:17:21,280 --> 02:17:26,639
cannot be used here but with afx dp

02:17:24,639 --> 02:17:29,840
because the driver is still there

02:17:26,639 --> 02:17:31,519
so we can use obvious we can use obvious

02:17:29,840 --> 02:17:35,599
user space they have pass

02:17:31,519 --> 02:17:39,280
coupled with fxdp and also

02:17:35,599 --> 02:17:41,359
use the tc flower api to offload

02:17:39,280 --> 02:17:42,479
so that's something we want to try and

02:17:41,359 --> 02:17:46,000
and

02:17:42,479 --> 02:17:48,000
the topic of this talk so compare uh

02:17:46,000 --> 02:17:50,319
so we want to come first we want to

02:17:48,000 --> 02:17:54,160
compare these two of low mechanism

02:17:50,319 --> 02:17:56,319
rt flow and tc flower so from the obs

02:17:54,160 --> 02:17:58,880
side and

02:17:56,319 --> 02:18:00,319
obvious visibility actually just uh

02:17:58,880 --> 02:18:02,479
doing the

02:18:00,319 --> 02:18:03,359
policy conversion from the open flow

02:18:02,479 --> 02:18:06,639
rule

02:18:03,359 --> 02:18:07,599
to the obs data path flow so it will

02:18:06,639 --> 02:18:10,960
translate into

02:18:07,599 --> 02:18:11,840
its obvious flow format and then depend

02:18:10,960 --> 02:18:14,399
on

02:18:11,840 --> 02:18:15,200
what api you want to use so for example

02:18:14,399 --> 02:18:19,040
if you want to use

02:18:15,200 --> 02:18:21,679
rt flow then obs will translate

02:18:19,040 --> 02:18:22,719
transform translate this obs there high

02:18:21,679 --> 02:18:25,599
pass flow

02:18:22,719 --> 02:18:26,240
into the four main that rt flow uh

02:18:25,599 --> 02:18:29,280
required

02:18:26,240 --> 02:18:30,399
for example rt flow need to uh set up

02:18:29,280 --> 02:18:33,120
the

02:18:30,399 --> 02:18:34,080
the first pro how to pass the protocol

02:18:33,120 --> 02:18:36,800
and how to

02:18:34,080 --> 02:18:37,519
do the actions and and of course in the

02:18:36,800 --> 02:18:39,760
beginning

02:18:37,519 --> 02:18:42,160
we as well do probably to see whether a

02:18:39,760 --> 02:18:46,160
flow can be or flow into the power

02:18:42,160 --> 02:18:50,559
into the rte flow or not so if not then

02:18:46,160 --> 02:18:52,559
it will fall back into the software case

02:18:50,559 --> 02:18:54,559
same thing for the tc flower so

02:18:52,559 --> 02:18:57,120
obviously we'll do the conversion

02:18:54,559 --> 02:18:58,399
so convert this obvious they have pass

02:18:57,120 --> 02:19:01,840
flow into the full

02:18:58,399 --> 02:19:02,399
main that tc flower require and then

02:19:01,840 --> 02:19:07,840
program

02:19:02,399 --> 02:19:07,840
into the the tc flower api

02:19:09,439 --> 02:19:12,960
and the target used so today they

02:19:11,200 --> 02:19:15,840
already support sound uh

02:19:12,960 --> 02:19:17,359
both api already supports some sahara

02:19:15,840 --> 02:19:20,960
flow and ovs

02:19:17,359 --> 02:19:23,840
some feature support to program it but

02:19:20,960 --> 02:19:25,519
the target use case we are uh thinking

02:19:23,840 --> 02:19:28,719
about is uh

02:19:25,519 --> 02:19:31,760
tunnel and the combination tracking

02:19:28,719 --> 02:19:32,479
so um simply doing five type of match

02:19:31,760 --> 02:19:36,559
and action

02:19:32,479 --> 02:19:39,280
um no longer meets today's firework rule

02:19:36,559 --> 02:19:40,479
so most of our use case has to go

02:19:39,280 --> 02:19:44,960
through

02:19:40,479 --> 02:19:48,000
three obvious data pass flows so

02:19:44,960 --> 02:19:51,200
for example here an incoming

02:19:48,000 --> 02:19:54,319
pack he usually goes through first

02:19:51,200 --> 02:19:57,439
it try to match the outer header

02:19:54,319 --> 02:20:00,000
and then doing the tunnel decay for

02:19:57,439 --> 02:20:01,200
example we are using geneve tunnel and

02:20:00,000 --> 02:20:03,600
there are other people using the

02:20:01,200 --> 02:20:07,040
excellent timeline so when we

02:20:03,600 --> 02:20:09,439
do tunnel decay we extract the metadata

02:20:07,040 --> 02:20:10,080
and put the menu on somewhere and then

02:20:09,439 --> 02:20:13,680
we do

02:20:10,080 --> 02:20:14,800
recirculation and then we hit second

02:20:13,680 --> 02:20:17,520
flow

02:20:14,800 --> 02:20:20,080
second floor will try to match on the

02:20:17,520 --> 02:20:23,680
manhattan app

02:20:20,080 --> 02:20:27,920
for example using vni uh vxlan id

02:20:23,680 --> 02:20:30,880
as the tenant's id and then

02:20:27,920 --> 02:20:32,319
we send it to connection checking and

02:20:30,880 --> 02:20:35,680
convention tracking

02:20:32,319 --> 02:20:36,800
um also require recirculation so it

02:20:35,680 --> 02:20:40,240
research

02:20:36,800 --> 02:20:42,560
and then we hit the third floor um

02:20:40,240 --> 02:20:44,479
so at the third flow we already know

02:20:42,560 --> 02:20:46,800
that okay this is the england packet and

02:20:44,479 --> 02:20:49,840
this is for particular attendance

02:20:46,800 --> 02:20:52,080
uh then we try to match the um

02:20:49,840 --> 02:20:54,000
connection checking states for example

02:20:52,080 --> 02:20:57,040
whether this is a and a new

02:20:54,000 --> 02:20:59,920
tcp connection or it's uh

02:20:57,040 --> 02:21:00,399
it's already established and based on

02:20:59,920 --> 02:21:03,280
the

02:21:00,399 --> 02:21:03,760
condition states uh convention checking

02:21:03,280 --> 02:21:06,319
states

02:21:03,760 --> 02:21:07,520
we decided to follow to forward or to

02:21:06,319 --> 02:21:10,560
drop

02:21:07,520 --> 02:21:13,920
uh apply different actions

02:21:10,560 --> 02:21:17,040
so based on this use case we want to

02:21:13,920 --> 02:21:19,680
uh we have a two requirements so either

02:21:17,040 --> 02:21:20,080
in an environment we have a hardware

02:21:19,680 --> 02:21:23,600
that

02:21:20,080 --> 02:21:24,640
can do of low and and for the

02:21:23,600 --> 02:21:28,160
requirement a

02:21:24,640 --> 02:21:31,120
we want to make sure that all the three

02:21:28,160 --> 02:21:33,520
flows can be offloading hardware so if

02:21:31,120 --> 02:21:36,399
we are doing partial of low like

02:21:33,520 --> 02:21:36,720
overflow flow number one flow number two

02:21:36,399 --> 02:21:39,840
but

02:21:36,720 --> 02:21:41,600
not uh connection tracking or flow then

02:21:39,840 --> 02:21:43,760
the performance is

02:21:41,600 --> 02:21:45,840
the same as the doing everything in

02:21:43,760 --> 02:21:49,439
software

02:21:45,840 --> 02:21:52,560
so if we cannot meet requirement a then

02:21:49,439 --> 02:21:52,880
we want to have requirement b which is

02:21:52,560 --> 02:21:56,000
do

02:21:52,880 --> 02:21:57,520
everything in software but um but it

02:21:56,000 --> 02:21:59,840
should be uh

02:21:57,520 --> 02:21:59,840
fast

02:22:02,880 --> 02:22:08,319
so one proposed so solution one is to

02:22:06,399 --> 02:22:11,040
use kernel data pass

02:22:08,319 --> 02:22:11,760
with tc flower so this uh people have

02:22:11,040 --> 02:22:15,120
been using

02:22:11,760 --> 02:22:19,040
this uh for a while so the

02:22:15,120 --> 02:22:23,280
pros is that pc flower today has

02:22:19,040 --> 02:22:25,920
more features there so it support both

02:22:23,280 --> 02:22:26,720
tunnel and connection tracking of log

02:22:25,920 --> 02:22:30,080
into the

02:22:26,720 --> 02:22:32,160
hardware and using tc has

02:22:30,080 --> 02:22:33,280
much better integration with linux

02:22:32,160 --> 02:22:35,439
kernel

02:22:33,280 --> 02:22:36,880
because like all the linux distribution

02:22:35,439 --> 02:22:40,160
has tc support

02:22:36,880 --> 02:22:40,800
so even if a highway doesn't is not

02:22:40,160 --> 02:22:43,680
there

02:22:40,800 --> 02:22:45,920
we can always fall back into the tc or

02:22:43,680 --> 02:22:49,040
obvious kernel

02:22:45,920 --> 02:22:51,200
however one problem is that if the

02:22:49,040 --> 02:22:54,000
requirement a cannot be met

02:22:51,200 --> 02:22:56,319
so for example if connection tracking

02:22:54,000 --> 02:22:59,520
doesn't supporting a particular hardware

02:22:56,319 --> 02:23:01,760
or so or

02:22:59,520 --> 02:23:04,000
some flow cannot be of flow for example

02:23:01,760 --> 02:23:05,120
we are thinking about doing layer seven

02:23:04,000 --> 02:23:08,399
processing so

02:23:05,120 --> 02:23:11,200
hardware probably couldn't be overflow

02:23:08,399 --> 02:23:12,319
so the fullback performance will be a

02:23:11,200 --> 02:23:14,560
little bit lower

02:23:12,319 --> 02:23:16,840
so about less than two million packet

02:23:14,560 --> 02:23:19,920
per second

02:23:16,840 --> 02:23:22,319
if because we are doing it in kernel or

02:23:19,920 --> 02:23:22,319
obs

02:23:23,520 --> 02:23:30,560
the the solution b

02:23:27,120 --> 02:23:35,200
is to use obvious dpdk

02:23:30,560 --> 02:23:38,479
with rt flow of low api

02:23:35,200 --> 02:23:41,920
so today rt flow support tunnel in cat

02:23:38,479 --> 02:23:45,359
and tunnel dk is also in a progress

02:23:41,920 --> 02:23:48,160
however the problem is that

02:23:45,359 --> 02:23:49,920
rt flow doesn't support combination

02:23:48,160 --> 02:23:53,520
tracking yet

02:23:49,920 --> 02:23:56,160
and but one benefit of using

02:23:53,520 --> 02:23:57,760
this is that it has better software for

02:23:56,160 --> 02:24:00,880
back performance

02:23:57,760 --> 02:24:02,720
so if a particular flow cannot be

02:24:00,880 --> 02:24:05,439
overflowing to the hardware

02:24:02,720 --> 02:24:05,920
we can process it in the user space that

02:24:05,439 --> 02:24:09,280
happens

02:24:05,920 --> 02:24:11,600
in the obvious dpdk which

02:24:09,280 --> 02:24:14,160
still shows around 9 or 10 million

02:24:11,600 --> 02:24:16,640
packets per second

02:24:14,160 --> 02:24:19,120
and today we see more uh people are

02:24:16,640 --> 02:24:22,240
testing this obvious dpdk with uh

02:24:19,120 --> 02:24:25,439
highway of low however

02:24:22,240 --> 02:24:28,560
deploying obvious dpdk

02:24:25,439 --> 02:24:29,280
require has a lot of system requirement

02:24:28,560 --> 02:24:32,000
and it

02:24:29,280 --> 02:24:32,960
may may not be a pretty applicable for

02:24:32,000 --> 02:24:36,720
all the uh

02:24:32,960 --> 02:24:36,720
customers or all the environment

02:24:38,000 --> 02:24:46,160
so what we are thinking about is to

02:24:41,359 --> 02:24:49,840
use this uh sir solution the solution c

02:24:46,160 --> 02:24:52,720
so the idea is that

02:24:49,840 --> 02:24:53,680
if a flow can be processed processing

02:24:52,720 --> 02:24:57,280
hardware

02:24:53,680 --> 02:24:57,920
so so so we want to use user space data

02:24:57,280 --> 02:25:00,720
paths

02:24:57,920 --> 02:25:02,399
but instead of using uh dpdk want to use

02:25:00,720 --> 02:25:05,520
afx dp

02:25:02,399 --> 02:25:09,200
and since we use fxdp so we want to use

02:25:05,520 --> 02:25:12,640
tc flower to do uh to be the flow api

02:25:09,200 --> 02:25:15,840
because dc flower has more features

02:25:12,640 --> 02:25:19,200
and better integrated into the kernel

02:25:15,840 --> 02:25:22,720
and because we are using af xdp we

02:25:19,200 --> 02:25:23,359
also have a chance to do xtp processing

02:25:22,720 --> 02:25:27,920
in the

02:25:23,359 --> 02:25:31,359
kernel so this makes up this uh

02:25:27,920 --> 02:25:34,800
three layer of processing so

02:25:31,359 --> 02:25:37,359
first so we want imagine we have a flow

02:25:34,800 --> 02:25:38,000
so if a flow can be handled in hardware

02:25:37,359 --> 02:25:41,120
with tc

02:25:38,000 --> 02:25:44,240
flower then we're doing hardware so

02:25:41,120 --> 02:25:47,520
if not then second one is we can

02:25:44,240 --> 02:25:51,200
process in xdp which is safe

02:25:47,520 --> 02:25:53,760
and which has pretty good performance

02:25:51,200 --> 02:25:54,560
however it also has its limitations for

02:25:53,760 --> 02:25:58,800
example

02:25:54,560 --> 02:26:00,880
um obvious first thing to do is to do

02:25:58,800 --> 02:26:04,080
broadcasting or multicast

02:26:00,880 --> 02:26:06,960
for to flood packing into many ports so

02:26:04,080 --> 02:26:11,120
that's cannot be done in xdp

02:26:06,960 --> 02:26:14,960
if that's the case then we fall back to

02:26:11,120 --> 02:26:19,359
obvious users based down past with fxdp

02:26:14,960 --> 02:26:22,160
which is still pretty good performance

02:26:19,359 --> 02:26:23,120
and uh has less limitations and more

02:26:22,160 --> 02:26:27,280
flexible in

02:26:23,120 --> 02:26:29,840
adding new feature or debugging

02:26:27,280 --> 02:26:31,439
so with this design i i we think that

02:26:29,840 --> 02:26:33,680
it's uh

02:26:31,439 --> 02:26:34,800
better it's better integrated into linux

02:26:33,680 --> 02:26:38,240
kernel

02:26:34,800 --> 02:26:41,200
it has better fallback performance

02:26:38,240 --> 02:26:42,240
if power cannot be supported when

02:26:41,200 --> 02:26:46,080
extruding

02:26:42,240 --> 02:26:48,640
xtp or in user space so although each

02:26:46,080 --> 02:26:53,520
stage will has its limitation

02:26:48,640 --> 02:26:57,200
so bro so then we have to have a way to

02:26:53,520 --> 02:26:59,760
prop like for a particular flow which uh

02:26:57,200 --> 02:27:03,840
which stage we should should be the flow

02:26:59,760 --> 02:27:03,840
should be done

02:27:04,399 --> 02:27:10,240
so we did a pretty uh

02:27:07,520 --> 02:27:12,160
early stage of preliminary and

02:27:10,240 --> 02:27:16,319
performance measurement

02:27:12,160 --> 02:27:17,439
of this design so first one is so this

02:27:16,319 --> 02:27:20,720
is again using

02:27:17,439 --> 02:27:24,720
like two machine and sending a udp

02:27:20,720 --> 02:27:26,960
one flow 64 by ebp packet

02:27:24,720 --> 02:27:27,920
so with the hardware of low like port

02:27:26,960 --> 02:27:31,120
forwarding between

02:27:27,920 --> 02:27:32,800
two ports we can get about 31 million

02:27:31,120 --> 02:27:36,319
packing per second

02:27:32,800 --> 02:27:40,080
so this is uh this is 25k

02:27:36,319 --> 02:27:42,160
on the car and then if we program the

02:27:40,080 --> 02:27:45,840
hardware to do a little more things

02:27:42,160 --> 02:27:48,880
like if we do uh highway of law we if we

02:27:45,840 --> 02:27:52,080
say receive the package and then uh

02:27:48,880 --> 02:27:53,439
in cabin and we extend headers and then

02:27:52,080 --> 02:27:56,880
send it out

02:27:53,439 --> 02:27:59,840
so then it shows around 21 million

02:27:56,880 --> 02:28:02,000
packet per second by doing it in

02:27:59,840 --> 02:28:04,880
hardware

02:28:02,000 --> 02:28:07,120
so if let's say we hit something that

02:28:04,880 --> 02:28:10,479
cannot be processed in the hardware

02:28:07,120 --> 02:28:13,920
then we fall back to the kc

02:28:10,479 --> 02:28:17,120
which is xdp so this is uh

02:28:13,920 --> 02:28:19,520
the work done by the toshiaki presented

02:28:17,120 --> 02:28:22,800
in the netdev conference

02:28:19,520 --> 02:28:26,880
so if we do processing in xdp it shows

02:28:22,800 --> 02:28:29,359
around 3.5 million packets per second

02:28:26,880 --> 02:28:31,439
so here the number is much lower than uh

02:28:29,359 --> 02:28:34,399
other xdp benchmark

02:28:31,439 --> 02:28:34,800
because uh actually the code is doing a

02:28:34,399 --> 02:28:37,840
lot

02:28:34,800 --> 02:28:42,000
like it tries to do the obvious way of

02:28:37,840 --> 02:28:45,120
parsing packet and it tries to create a

02:28:42,000 --> 02:28:46,560
compressed version compressed data

02:28:45,120 --> 02:28:50,240
structure of the flow

02:28:46,560 --> 02:28:55,840
i call mini flow in the xdp program

02:28:50,240 --> 02:28:55,840
so it takes much more cycles to do that

02:28:56,000 --> 02:29:02,560
then if c could not be done in c

02:28:59,280 --> 02:29:04,720
then we fall back into the case d

02:29:02,560 --> 02:29:05,600
which uh do the user space they have

02:29:04,720 --> 02:29:09,240
passed

02:29:05,600 --> 02:29:14,160
with afx dp it shows about

02:29:09,240 --> 02:29:16,240
2.4.5 million packets per second

02:29:14,160 --> 02:29:17,680
also one thing to mention is about the

02:29:16,240 --> 02:29:21,359
cpu

02:29:17,680 --> 02:29:24,080
cycles so for the case of a and b

02:29:21,359 --> 02:29:24,880
actually there is no whole cpu cycle

02:29:24,080 --> 02:29:29,280
being used

02:29:24,880 --> 02:29:32,160
because it's all done in the hardware

02:29:29,280 --> 02:29:33,760
for the case c it's using one cpu

02:29:32,160 --> 02:29:37,040
hundred percent

02:29:33,760 --> 02:29:37,760
but for the ksd uh we are using two

02:29:37,040 --> 02:29:40,960
coins

02:29:37,760 --> 02:29:42,160
because like uh afx dp will use another

02:29:40,960 --> 02:29:45,840
coin

02:29:42,160 --> 02:29:45,840
one extra coin cpu

02:29:47,359 --> 02:29:53,200
so summary of the

02:29:50,399 --> 02:29:54,479
case the solution c is that we are

02:29:53,200 --> 02:29:57,600
hoping for the

02:29:54,479 --> 02:30:00,720
enterprise customer which they

02:29:57,600 --> 02:30:03,920
probably don't need a lot of high

02:30:00,720 --> 02:30:05,280
throughput or packet rate uh they can

02:30:03,920 --> 02:30:09,359
use this obvious

02:30:05,280 --> 02:30:11,840
user space standard pass with afx dp

02:30:09,359 --> 02:30:13,359
but instead of pulling more they can use

02:30:11,840 --> 02:30:16,560
interrupt more

02:30:13,359 --> 02:30:19,680
so which will save more cpu but

02:30:16,560 --> 02:30:21,600
with lower performance if they want more

02:30:19,680 --> 02:30:22,640
performance then they can enable the

02:30:21,600 --> 02:30:26,479
pulling more

02:30:22,640 --> 02:30:27,439
which will get them better performance

02:30:26,479 --> 02:30:31,040
than kernel

02:30:27,439 --> 02:30:34,640
but use more cpu cycles

02:30:31,040 --> 02:30:38,399
but for the high performance like uh

02:30:34,640 --> 02:30:40,880
nfv use cases so with this

02:30:38,399 --> 02:30:41,439
solution see we are hoping that they can

02:30:40,880 --> 02:30:43,920
first

02:30:41,439 --> 02:30:44,960
try to do highway or flow through the tc

02:30:43,920 --> 02:30:48,640
flower

02:30:44,960 --> 02:30:51,520
which is fastest because it's all done

02:30:48,640 --> 02:30:54,640
in hardware and less cpu consume

02:30:51,520 --> 02:30:56,640
and today cc blower has much more

02:30:54,640 --> 02:30:58,560
features

02:30:56,640 --> 02:31:01,200
and then it cannot be done then fall

02:30:58,560 --> 02:31:03,840
back to xdp or

02:31:01,200 --> 02:31:04,720
again fall back to the user space that i

02:31:03,840 --> 02:31:10,080
passed with

02:31:04,720 --> 02:31:10,080
the fxdp voting mode netdef

02:31:11,920 --> 02:31:16,720
so for the future work um today we are

02:31:15,520 --> 02:31:19,200
still trying to

02:31:16,720 --> 02:31:19,760
uh do a couple of experiments to vary

02:31:19,200 --> 02:31:22,560
the how

02:31:19,760 --> 02:31:24,000
tc flower or flow work with the the

02:31:22,560 --> 02:31:26,800
basis

02:31:24,000 --> 02:31:28,640
we try pretty basic thing first like

02:31:26,800 --> 02:31:30,880
passing the protocol headers

02:31:28,640 --> 02:31:31,760
uh send the packet to the vm and come

02:31:30,880 --> 02:31:34,960
back

02:31:31,760 --> 02:31:38,240
and we tried vxn tunnel in

02:31:34,960 --> 02:31:42,560
cap so we are or we try to

02:31:38,240 --> 02:31:45,040
do like basic connection tracking state

02:31:42,560 --> 02:31:46,000
uh match on the convention training

02:31:45,040 --> 02:31:48,000
stake

02:31:46,000 --> 02:31:49,520
but there are still a lot of work to do

02:31:48,000 --> 02:31:53,520
like tunnel decaf and

02:31:49,520 --> 02:31:56,000
more uh connection tracking experiment

02:31:53,520 --> 02:31:58,160
that's the highway of low side for the

02:31:56,000 --> 02:32:01,520
obvious xtp processing

02:31:58,160 --> 02:32:02,560
site we are looking at the patch sent

02:32:01,520 --> 02:32:06,160
from the

02:32:02,560 --> 02:32:08,880
society to see how much

02:32:06,160 --> 02:32:09,280
how many features can be implemented in

02:32:08,880 --> 02:32:13,200
the

02:32:09,280 --> 02:32:15,359
xdp how many ovs flow uh

02:32:13,200 --> 02:32:17,600
requirement for format can be

02:32:15,359 --> 02:32:20,880
implementing the xdp

02:32:17,600 --> 02:32:22,319
program and how many limitations are

02:32:20,880 --> 02:32:24,479
there

02:32:22,319 --> 02:32:26,640
and also definitely we are looking for

02:32:24,479 --> 02:32:30,240
more optimization for the

02:32:26,640 --> 02:32:34,240
fx dp part um

02:32:30,240 --> 02:32:34,240
that's my talk thank you

02:32:35,359 --> 02:32:39,600
okay thank you william let's see if we

02:32:37,600 --> 02:32:41,359
have any questions for you kevin mason

02:32:39,600 --> 02:32:43,120
says how does the performance change

02:32:41,359 --> 02:32:45,200
when a mix of packet sizes are used for

02:32:43,120 --> 02:32:50,000
the various configurations

02:32:45,200 --> 02:32:53,600
oh probably we didn't have a lot of

02:32:50,000 --> 02:32:56,640
data there so today we mostly use

02:32:53,600 --> 02:33:00,720
like pretty small so we run two cases

02:32:56,640 --> 02:33:02,479
so one is to use uh traffic jam to send

02:33:00,720 --> 02:33:05,200
64 by packet

02:33:02,479 --> 02:33:06,479
and another case is we try to run an

02:33:05,200 --> 02:33:09,760
iperf

02:33:06,479 --> 02:33:14,080
hyper of tcp then i'm from tcp

02:33:09,760 --> 02:33:17,520
triggers more issue so one issue is that

02:33:14,080 --> 02:33:18,960
when we are using fxtp and the checksum

02:33:17,520 --> 02:33:21,760
of low support

02:33:18,960 --> 02:33:22,880
is not there so so we are sending bigger

02:33:21,760 --> 02:33:25,920
package but then

02:33:22,880 --> 02:33:29,120
consume more cpu because we are doing

02:33:25,920 --> 02:33:31,760
uh software so so for a

02:33:29,120 --> 02:33:33,040
calculation of the checksum so but but

02:33:31,760 --> 02:33:36,240
that's definitely a

02:33:33,040 --> 02:33:40,080
good question and we we will

02:33:36,240 --> 02:33:40,080
do that in future work yes

02:33:41,680 --> 02:33:46,000
has any idea what the performance

02:33:43,520 --> 02:33:49,439
difference from af xdp to dpdk

02:33:46,000 --> 02:33:51,680
exists oh yes so so

02:33:49,439 --> 02:33:53,920
one thing to mention is that actually

02:33:51,680 --> 02:33:54,240
the low performance we are reporting

02:33:53,920 --> 02:33:57,760
from

02:33:54,240 --> 02:34:00,319
fxdp is because we

02:33:57,760 --> 02:34:01,680
we divided the number by two because we

02:34:00,319 --> 02:34:05,120
are counting the

02:34:01,680 --> 02:34:06,560
performance per cpu coin so every time

02:34:05,120 --> 02:34:09,840
we are doing fxdp

02:34:06,560 --> 02:34:11,920
we use two uh cpu coins one

02:34:09,840 --> 02:34:12,960
runs the software two daemon and the

02:34:11,920 --> 02:34:16,160
other runs the

02:34:12,960 --> 02:34:17,760
fxdp user space circuit and when we run

02:34:16,160 --> 02:34:19,840
obvious dpdk

02:34:17,760 --> 02:34:21,120
it only use one coil because it doesn't

02:34:19,840 --> 02:34:25,120
have driver right

02:34:21,120 --> 02:34:30,399
so that's why the performance looks so

02:34:25,120 --> 02:34:33,520
gaps so so huge yeah

02:34:30,399 --> 02:34:34,800
so are you saying that uh the actual

02:34:33,520 --> 02:34:37,840
performance

02:34:34,800 --> 02:34:40,960
is closer to dpdk yeah

02:34:37,840 --> 02:34:44,000
close to but still we are seeing about

02:34:40,960 --> 02:34:46,080
at least 20 10 to 20 so

02:34:44,000 --> 02:34:48,399
they are performance overhead they are

02:34:46,080 --> 02:34:51,600
also performance overhead of the obs

02:34:48,399 --> 02:34:55,040
part like obvious has to um

02:34:51,600 --> 02:34:55,760
pre locate the human and then fill in

02:34:55,040 --> 02:34:58,960
the

02:34:55,760 --> 02:35:01,600
cues so they are still uh

02:34:58,960 --> 02:35:02,479
overhead theirs they're in the obvious

02:35:01,600 --> 02:35:04,000
driver

02:35:02,479 --> 02:35:06,000
john is asking something i'm curious

02:35:04,000 --> 02:35:07,359
about too is is it fair to do that

02:35:06,000 --> 02:35:10,560
division by two

02:35:07,359 --> 02:35:12,319
um maybe a packet per cycle would be a

02:35:10,560 --> 02:35:15,359
more accurate measurement

02:35:12,319 --> 02:35:18,399
to make conspiracy cases okay

02:35:15,359 --> 02:35:21,680
uh yes yes but yes i i

02:35:18,399 --> 02:35:25,280
i understand so

02:35:21,680 --> 02:35:27,359
but then the problem is that

02:35:25,280 --> 02:35:28,399
some of the customers they care about

02:35:27,359 --> 02:35:31,920
the

02:35:28,399 --> 02:35:33,359
the how many cpu used by the obs for the

02:35:31,920 --> 02:35:37,520
entire system right

02:35:33,359 --> 02:35:41,359
so yeah so so that's why we are doing

02:35:37,520 --> 02:35:44,240
this again we should probably

02:35:41,359 --> 02:35:46,000
measure this using multiple several sets

02:35:44,240 --> 02:35:48,319
of metrics and not just focus

02:35:46,000 --> 02:35:50,160
purely on any of these specific domains

02:35:48,319 --> 02:35:52,720
like how many cpus or

02:35:50,160 --> 02:35:54,240
how many cycles we consume because uh

02:35:52,720 --> 02:35:56,399
from what you say it sounds like it's a

02:35:54,240 --> 02:35:58,479
multi-dimensional

02:35:56,399 --> 02:36:00,240
concern that customers have they want to

02:35:58,479 --> 02:36:02,319
know how much cpu usage

02:36:00,240 --> 02:36:04,560
how fast their packets can be processed

02:36:02,319 --> 02:36:05,600
with an obs given obs configuration and

02:36:04,560 --> 02:36:07,439
how many cores

02:36:05,600 --> 02:36:09,680
get used by a given configuration as

02:36:07,439 --> 02:36:11,520
well so there's many dimensions to this

02:36:09,680 --> 02:36:12,160
concern level and i kind of agree with

02:36:11,520 --> 02:36:15,040
john

02:36:12,160 --> 02:36:16,560
it didn't seem fair to um divide the

02:36:15,040 --> 02:36:18,399
performance by half

02:36:16,560 --> 02:36:20,479
it looked a little bit skewed in the

02:36:18,399 --> 02:36:21,680
graph and it would lead to questions

02:36:20,479 --> 02:36:24,880
like john had like why is the

02:36:21,680 --> 02:36:28,160
performance so much lower working at xdp

02:36:24,880 --> 02:36:29,840
yes yes um

02:36:28,160 --> 02:36:32,240
do we have any other questions now would

02:36:29,840 --> 02:36:34,160
be a good time to ask them

02:36:32,240 --> 02:36:36,319
i'll give people a minute a couple

02:36:34,160 --> 02:36:37,520
seconds to start typing see if we get

02:36:36,319 --> 02:36:41,120
any of that

02:36:37,520 --> 02:36:42,000
um no i don't see anything uh william

02:36:41,120 --> 02:36:42,960
thank you very much for your

02:36:42,000 --> 02:36:45,760
presentation i

02:36:42,960 --> 02:36:47,680
very much do all your work to try to

02:36:45,760 --> 02:36:49,920
integrate obs with various

02:36:47,680 --> 02:36:50,720
bpf based networking technologies that

02:36:49,920 --> 02:36:52,960
we have now

02:36:50,720 --> 02:36:54,560
i really appreciate your work thank you

02:36:52,960 --> 02:36:56,960
very much

02:36:54,560 --> 02:36:56,960
thank you

02:36:57,680 --> 02:37:04,880
okay uh that is the completion of the

02:37:01,280 --> 02:37:05,520
networking and bpf summit for 2020 at

02:37:04,880 --> 02:37:08,960
lpc

02:37:05,520 --> 02:37:12,240
i'd like to thank everyone for coming um

02:37:08,960 --> 02:37:15,200
in particular i would like to thank the

02:37:12,240 --> 02:37:16,840
lpc committee uh and i'd like to give

02:37:15,200 --> 02:37:20,080
specific thanks to

02:37:16,840 --> 02:37:22,399
um gee who came in here every day

02:37:20,080 --> 02:37:24,240
to make sure the channel is working

02:37:22,399 --> 02:37:25,359
properly the youtube stream is

02:37:24,240 --> 02:37:27,040
operational

02:37:25,359 --> 02:37:28,640
i like to thank elena because she did a

02:37:27,040 --> 02:37:30,720
lot of the busy work in the background

02:37:28,640 --> 02:37:31,520
to make this a reality and honestly

02:37:30,720 --> 02:37:34,800
speaking

02:37:31,520 --> 02:37:36,160
uh considering the fact that uh lpc

02:37:34,800 --> 02:37:38,479
decided to go virtual

02:37:36,160 --> 02:37:39,200
about three or maybe four months ago and

02:37:38,479 --> 02:37:40,800
we have

02:37:39,200 --> 02:37:42,399
everything that we saw this week

02:37:40,800 --> 02:37:44,640
operational and functioning

02:37:42,399 --> 02:37:46,160
for the most part properly i think

02:37:44,640 --> 02:37:49,280
that's quite an accomplishment

02:37:46,160 --> 02:37:51,280
and if you see or have a chance to speak

02:37:49,280 --> 02:37:52,640
with one of the lpc committee members

02:37:51,280 --> 02:37:54,640
uh you should thank them because it's

02:37:52,640 --> 02:37:56,880
quite an accomplishment i'd like to

02:37:54,640 --> 02:37:58,640
also thank the technical committee that

02:37:56,880 --> 02:37:59,280
we have for networking and bpf summit

02:37:58,640 --> 02:38:01,439
this year

02:37:59,280 --> 02:38:03,120
that's comprised of myself alexis style

02:38:01,439 --> 02:38:06,720
whitetail daniel portman

02:38:03,120 --> 02:38:09,680
jacob sitnitsky paolo benite jakobs

02:38:06,720 --> 02:38:10,960
kaczynski mahal kubisek and sabrina

02:38:09,680 --> 02:38:12,560
duproza

02:38:10,960 --> 02:38:14,960
all of them worked very hard to review

02:38:12,560 --> 02:38:16,800
the proposals that that led to the

02:38:14,960 --> 02:38:18,960
presentations you saw this week so thank

02:38:16,800 --> 02:38:21,280
you very much i'd like to thank

02:38:18,960 --> 02:38:22,240
in particular daniel uh he was in the

02:38:21,280 --> 02:38:24,640
room every

02:38:22,240 --> 02:38:26,080
day this week and he did the moderation

02:38:24,640 --> 02:38:27,120
on wednesday and thursday that helped me

02:38:26,080 --> 02:38:29,439
a lot

02:38:27,120 --> 02:38:31,359
as you know the conference starts at 7

02:38:29,439 --> 02:38:33,520
a.m in my time zone

02:38:31,359 --> 02:38:35,040
and i had to get up around 5 a.m or so

02:38:33,520 --> 02:38:37,040
when i would be moderating and

02:38:35,040 --> 02:38:38,720
daniel's helping out let me sleep in

02:38:37,040 --> 02:38:40,240
another 30 minutes so that was so nice

02:38:38,720 --> 02:38:43,520
of him i appreciate that

02:38:40,240 --> 02:38:45,040
um i think things run very well i think

02:38:43,520 --> 02:38:47,600
that the cadence of four

02:38:45,040 --> 02:38:48,399
talks per day was pretty good and didn't

02:38:47,600 --> 02:38:50,640
overly

02:38:48,399 --> 02:38:51,520
wear people out i think anymore would

02:38:50,640 --> 02:38:54,560
have been too much

02:38:51,520 --> 02:38:56,479
uh but if you have any specific feedback

02:38:54,560 --> 02:38:58,720
about either the networking of bpf

02:38:56,479 --> 02:38:59,439
summit or the lpc in general please feel

02:38:58,720 --> 02:39:02,560
free to con

02:38:59,439 --> 02:39:03,359
contact with the lpc committee or myself

02:39:02,560 --> 02:39:05,120
or daniel

02:39:03,359 --> 02:39:06,880
and let us know what you think and we'll

02:39:05,120 --> 02:39:08,640
make sure we take a look into

02:39:06,880 --> 02:39:10,880
what your concerns are and try to make

02:39:08,640 --> 02:39:12,960
this an even better event next year

02:39:10,880 --> 02:39:14,240
uh once once again thank you everyone

02:39:12,960 --> 02:39:16,240
for attending thanks to all the

02:39:14,240 --> 02:39:18,880
presenters for their awesome material

02:39:16,240 --> 02:39:20,800
and lively discussion i look forward to

02:39:18,880 --> 02:39:25,840
seeing everyone next year

02:39:20,800 --> 02:39:25,840
and thank you very much once again

03:02:03,840 --> 03:02:05,920

YouTube URL: https://www.youtube.com/watch?v=dZ_1HgUbni0


