Title: LPC 2020 - GNU Tools Track - Day 3
Publication date: 2020-08-28
Playlist: LPC2020 - Live Streams
Description: 
	Linux Plumbers Conference 2020
Captions: 
	00:06:23,120 --> 00:06:25,199
conference

00:06:23,840 --> 00:06:26,880
i think elaine has been it's been

00:06:25,199 --> 00:06:28,880
fabulous working related it's been very

00:06:26,880 --> 00:06:30,880
helpful for setting things up but it is

00:06:28,880 --> 00:06:34,319
a different scale of conference

00:06:30,880 --> 00:06:36,000
okay the physical lpc is 500 people

00:06:34,319 --> 00:06:37,759
are small for compared some confidence

00:06:36,000 --> 00:06:41,919
is a lot bigger than cauldron

00:06:37,759 --> 00:06:44,960
i remember cauldron has run usually

00:06:41,919 --> 00:06:46,160
by support from the host when we go to

00:06:44,960 --> 00:06:47,759
prague

00:06:46,160 --> 00:06:49,360
we run it in the university because

00:06:47,759 --> 00:06:51,520
that's where honza works

00:06:49,360 --> 00:06:53,280
when we go to the uk we're small enough

00:06:51,520 --> 00:06:54,080
conference we can fit into unusual

00:06:53,280 --> 00:06:57,199
places like

00:06:54,080 --> 00:06:58,720
you know head and bridge town hall um

00:06:57,199 --> 00:06:59,759
and quite often the venues you know when

00:06:58,720 --> 00:07:01,199
we were at cambridge cambridge

00:06:59,759 --> 00:07:02,000
university gave us all those venues for

00:07:01,199 --> 00:07:04,240
free

00:07:02,000 --> 00:07:05,120
so there is an element that our cost

00:07:04,240 --> 00:07:07,199
base is kept

00:07:05,120 --> 00:07:08,720
very very tight i think something like

00:07:07,199 --> 00:07:10,319
eighty percent of the cost of a cauldron

00:07:08,720 --> 00:07:12,560
is the food and drink

00:07:10,319 --> 00:07:13,919
that's about it and a sniff another

00:07:12,560 --> 00:07:16,560
chunk is the t-shirts

00:07:13,919 --> 00:07:17,919
um so it is i don't think we'd see any

00:07:16,560 --> 00:07:20,080
cost savings

00:07:17,919 --> 00:07:21,440
and i think we would switch as we've

00:07:20,080 --> 00:07:22,960
talked anyway

00:07:21,440 --> 00:07:24,880
tomorrow particularly the other

00:07:22,960 --> 00:07:26,080
difference is that cauldron's held over

00:07:24,880 --> 00:07:28,560
a weekend

00:07:26,080 --> 00:07:30,240
and for participants for whom compilers

00:07:28,560 --> 00:07:32,000
is not their day job

00:07:30,240 --> 00:07:34,319
that's actually an advantage that they

00:07:32,000 --> 00:07:35,840
don't take out time during the week

00:07:34,319 --> 00:07:37,680
i'm actually finding it harder this year

00:07:35,840 --> 00:07:38,800
just because i'm used to i can sort of

00:07:37,680 --> 00:07:41,039
bolt on cauldron

00:07:38,800 --> 00:07:42,080
at a weekend and it doesn't get under my

00:07:41,039 --> 00:07:44,960
feet as

00:07:42,080 --> 00:07:46,960
during the the ordinary working day um

00:07:44,960 --> 00:07:48,879
and i do appreciate the comment from

00:07:46,960 --> 00:07:50,240
having to come in early carlos's comment

00:07:48,879 --> 00:07:51,440
about having to come in early

00:07:50,240 --> 00:07:53,840
so i don't i don't think there's a cost

00:07:51,440 --> 00:07:56,720
saving there at all

00:07:53,840 --> 00:07:57,280
yeah okay thanks jeremy but there is

00:07:56,720 --> 00:08:00,960
also

00:07:57,280 --> 00:08:04,000
another oh sorry there is also the

00:08:00,960 --> 00:08:06,160
of the price because this year lpc is

00:08:04,000 --> 00:08:07,120
quite affordable because it's remote but

00:08:06,160 --> 00:08:10,479
usually

00:08:07,120 --> 00:08:10,879
in order to attend uh you have to pay

00:08:10,479 --> 00:08:14,560
like

00:08:10,879 --> 00:08:16,080
a few hundred of euros and up to now as

00:08:14,560 --> 00:08:17,120
far as i know the cauldron has been

00:08:16,080 --> 00:08:20,080
always free

00:08:17,120 --> 00:08:20,639
for attendance that was my question i

00:08:20,080 --> 00:08:22,000
remember

00:08:20,639 --> 00:08:24,400
i think last year or maybe the year

00:08:22,000 --> 00:08:25,360
before there was considerable push back

00:08:24,400 --> 00:08:28,479
on even

00:08:25,360 --> 00:08:29,440
considering a you know maybe like a 20

00:08:28,479 --> 00:08:32,080
00:08:29,440 --> 00:08:32,800
fee for the cauldron and now we've had

00:08:32,080 --> 00:08:35,360
this 50

00:08:32,800 --> 00:08:36,080
fifa for this and i'm wondering if

00:08:35,360 --> 00:08:39,039
that's

00:08:36,080 --> 00:08:40,000
um made a difference in the in the

00:08:39,039 --> 00:08:44,159
people in

00:08:40,000 --> 00:08:44,159
the um attendees

00:08:46,320 --> 00:08:50,000
well i'll see i mean two things one is

00:08:47,760 --> 00:08:52,160
that people have i mean

00:08:50,000 --> 00:08:54,000
the tool chain fund has sponsored these

00:08:52,160 --> 00:08:55,839
students in the past i'm not sure for

00:08:54,000 --> 00:08:58,000
sponsoring this year there's been some

00:08:55,839 --> 00:09:01,120
there's least some requests early on

00:08:58,000 --> 00:09:05,040
um i mean i agree about the fee i mean i

00:09:01,120 --> 00:09:07,200
won't go and get into all of the the

00:09:05,040 --> 00:09:08,640
the underlying issues about that but i

00:09:07,200 --> 00:09:11,360
mean there was some concern

00:09:08,640 --> 00:09:13,200
about um i mean just the way that some

00:09:11,360 --> 00:09:14,959
corporations are set up to fund this and

00:09:13,200 --> 00:09:16,320
to sponsor it where

00:09:14,959 --> 00:09:18,399
um and and the number of people

00:09:16,320 --> 00:09:19,360
attending so part of it was a balance

00:09:18,399 --> 00:09:22,720
between

00:09:19,360 --> 00:09:25,600
um sponsorship versus people

00:09:22,720 --> 00:09:26,480
paying some sort of a fee if they're a

00:09:25,600 --> 00:09:29,200
lot of

00:09:26,480 --> 00:09:30,800
uh attendees from a particular

00:09:29,200 --> 00:09:33,279
organization that doesn't have

00:09:30,800 --> 00:09:34,160
a lot of sponsorship so it needs to be a

00:09:33,279 --> 00:09:37,839
balance but i

00:09:34,160 --> 00:09:38,560
i agree about the how to make this cost

00:09:37,839 --> 00:09:40,800
effective

00:09:38,560 --> 00:09:43,200
and and affordable and accessible for

00:09:40,800 --> 00:09:43,200
everybody

00:09:48,160 --> 00:09:55,600
that was a just uh i'm not i don't think

00:09:51,760 --> 00:09:57,680
uh matt is here but the the there is

00:09:55,600 --> 00:09:59,360
a general comment about the way we found

00:09:57,680 --> 00:10:02,240
at the moment we've been funded for

00:09:59,360 --> 00:10:04,800
years by very very generous support from

00:10:02,240 --> 00:10:06,640
our sponsors and those sponsors actually

00:10:04,800 --> 00:10:09,120
stepped in this year

00:10:06,640 --> 00:10:10,720
to bail out after we spent a lot of

00:10:09,120 --> 00:10:13,040
money setting up

00:10:10,720 --> 00:10:14,240
um and making commitments because even

00:10:13,040 --> 00:10:15,519
though we only pay for the food we do

00:10:14,240 --> 00:10:16,399
have to commit we're going to buy that

00:10:15,519 --> 00:10:18,160
food to the

00:10:16,399 --> 00:10:19,519
venue quite a long time in advance and

00:10:18,160 --> 00:10:22,000
fair deposit and

00:10:19,519 --> 00:10:23,600
four of our sponsors stepped in to bail

00:10:22,000 --> 00:10:25,360
us out because we would have wiped out

00:10:23,600 --> 00:10:28,079
our very small reserves

00:10:25,360 --> 00:10:30,880
on the cost of this year so one of the

00:10:28,079 --> 00:10:34,079
feedback from the big sponsors is

00:10:30,880 --> 00:10:38,320
it is a lot easier to justify

00:10:34,079 --> 00:10:40,240
a 300 ticket to attend a conference

00:10:38,320 --> 00:10:41,360
than it is to extract thousands of

00:10:40,240 --> 00:10:43,279
dollars

00:10:41,360 --> 00:10:44,800
to pay for your staff to go to those

00:10:43,279 --> 00:10:46,399
it's a sponsorship

00:10:44,800 --> 00:10:48,000
even though it would actually be cheaper

00:10:46,399 --> 00:10:51,519
to pay the sponsorship

00:10:48,000 --> 00:10:53,200
um so there is a suggestion that we

00:10:51,519 --> 00:10:55,600
that it will make our sponsors life a

00:10:53,200 --> 00:10:57,600
lot easier if we charge the ticket price

00:10:55,600 --> 00:10:59,279
and just use the sponsorship to support

00:10:57,600 --> 00:11:00,000
those who are not paid for by their

00:10:59,279 --> 00:11:01,440
companies

00:11:00,000 --> 00:11:03,040
because if your company's going to pay

00:11:01,440 --> 00:11:05,839
for your airfare in a hotel

00:11:03,040 --> 00:11:06,560
then the cost of a cauldron ticket is

00:11:05,839 --> 00:11:09,040
not that

00:11:06,560 --> 00:11:09,839
is relatively not that high and i think

00:11:09,040 --> 00:11:11,360
the idea would be

00:11:09,839 --> 00:11:13,519
if your company pays they can pay for a

00:11:11,360 --> 00:11:14,800
ticket if they don't pay then it would

00:11:13,519 --> 00:11:16,240
be free

00:11:14,800 --> 00:11:18,240
and the sponsorship would be much

00:11:16,240 --> 00:11:24,240
smaller but cover those free people

00:11:18,240 --> 00:11:26,000
[Music]

00:11:24,240 --> 00:11:28,320
one one of the issues that people have

00:11:26,000 --> 00:11:29,519
raised in the past is about locations

00:11:28,320 --> 00:11:31,760
about

00:11:29,519 --> 00:11:32,640
having the cauldron in the u.s and and

00:11:31,760 --> 00:11:34,079
difficulty

00:11:32,640 --> 00:11:35,920
for some people getting here would that

00:11:34,079 --> 00:11:39,200
be an issue if we were to

00:11:35,920 --> 00:11:40,959
co-locate with lpc because

00:11:39,200 --> 00:11:43,279
aren't most of those are a lot of those

00:11:40,959 --> 00:11:47,440
held in the u.s

00:11:43,279 --> 00:11:51,279
try to can you hear me now better

00:11:47,440 --> 00:11:52,560
yes thanks we try to alternate we do

00:11:51,279 --> 00:11:57,839
europe one year

00:11:52,560 --> 00:11:57,839
and the u.s another

00:12:03,519 --> 00:12:07,279
it's great to talk about this this

00:12:05,440 --> 00:12:07,760
coordination and we hope that there is

00:12:07,279 --> 00:12:09,279
you know

00:12:07,760 --> 00:12:11,760
additional coordination going forward

00:12:09,279 --> 00:12:14,800
between uh the

00:12:11,760 --> 00:12:18,160
um foundation this plumber's conference

00:12:14,800 --> 00:12:19,360
and the gnu tool chain are there any

00:12:18,160 --> 00:12:22,320
and i want to make sure that given that

00:12:19,360 --> 00:12:24,240
we have a this abridged version of the

00:12:22,320 --> 00:12:25,920
the q a if there are any other questions

00:12:24,240 --> 00:12:27,839
we're happy to continue this discussion

00:12:25,920 --> 00:12:31,040
just want to make sure that everybody's

00:12:27,839 --> 00:12:33,040
voices everybody's you know thoughts are

00:12:31,040 --> 00:12:34,079
are included in this session i mean

00:12:33,040 --> 00:12:38,160
obviously

00:12:34,079 --> 00:12:39,920
the the the leadership here is

00:12:38,160 --> 00:12:41,760
and steward's steering committee is

00:12:39,920 --> 00:12:43,360
available you know all throughout the

00:12:41,760 --> 00:12:44,399
year for any other questions just if

00:12:43,360 --> 00:12:47,440
anybody wants to

00:12:44,399 --> 00:12:50,000
have sort of a broader um

00:12:47,440 --> 00:12:50,480
group conversation about a topic i i

00:12:50,000 --> 00:12:54,160
have a

00:12:50,480 --> 00:12:58,160
i have a question so the gnu tool chain

00:12:54,160 --> 00:12:59,760
fund um is that new i i'm not familiar

00:12:58,160 --> 00:13:02,560
with that when did that come about

00:12:59,760 --> 00:13:06,880
and what is it and how do you decide

00:13:02,560 --> 00:13:09,600
what to fund

00:13:06,880 --> 00:13:12,480
yeah so the the tool chain fund is was

00:13:09,600 --> 00:13:15,120
created relatively recently that the

00:13:12,480 --> 00:13:15,839
free software foundation a few years ago

00:13:15,120 --> 00:13:19,200
created

00:13:15,839 --> 00:13:21,680
a um an opportunity for

00:13:19,200 --> 00:13:24,000
individual organizations and groups to

00:13:21,680 --> 00:13:24,000
have

00:13:25,040 --> 00:13:29,120
directed funds and selected funds

00:13:27,680 --> 00:13:32,320
underneath the umbrella

00:13:29,120 --> 00:13:34,480
of the free software foundation

00:13:32,320 --> 00:13:36,399
general account so instead of having

00:13:34,480 --> 00:13:38,959
just a general pot of funds and going

00:13:36,399 --> 00:13:40,160
to the uh the free software foundation

00:13:38,959 --> 00:13:43,279
for funding everything that

00:13:40,160 --> 00:13:46,839
that both the organizations and

00:13:43,279 --> 00:13:49,839
donors could direct funds to specific

00:13:46,839 --> 00:13:53,120
groups and so uh i

00:13:49,839 --> 00:13:56,720
with with the help of joel from the

00:13:53,120 --> 00:14:00,240
ged and carlos from glib c created

00:13:56,720 --> 00:14:03,680
the new tool chain fund under the

00:14:00,240 --> 00:14:06,480
auspices of the fsf and so we

00:14:03,680 --> 00:14:06,880
the three of us are the the trustees and

00:14:06,480 --> 00:14:09,519
uh

00:14:06,880 --> 00:14:10,800
you know have consensus for the the use

00:14:09,519 --> 00:14:13,120
of the funds

00:14:10,800 --> 00:14:14,959
also as we uh announced i think it was i

00:14:13,120 --> 00:14:18,320
guess a year or two ago

00:14:14,959 --> 00:14:21,440
that a large donor came

00:14:18,320 --> 00:14:24,639
forward to the fsf to fund

00:14:21,440 --> 00:14:24,639
the fsf and

00:14:24,800 --> 00:14:27,920
10 different projects within the fsf so

00:14:27,199 --> 00:14:30,800
the fsf

00:14:27,920 --> 00:14:31,920
received over a million dollars and that

00:14:30,800 --> 00:14:35,199
was distributed

00:14:31,920 --> 00:14:38,399
to the different funds so the

00:14:35,199 --> 00:14:40,560
new tool chain fund has some donations

00:14:38,399 --> 00:14:41,440
received a modest amount of donations

00:14:40,560 --> 00:14:43,519
from

00:14:41,440 --> 00:14:45,519
uh individual donors and one can donate

00:14:43,519 --> 00:14:48,639
through the the fsf

00:14:45,519 --> 00:14:50,079
uh and then there was this larger a

00:14:48,639 --> 00:14:51,600
hundred thousand dollars

00:14:50,079 --> 00:14:53,440
that was well i guess it's ninety

00:14:51,600 --> 00:14:57,519
thousand because the fsf will take ten

00:14:53,440 --> 00:15:00,079
percent up the top but um for the

00:14:57,519 --> 00:15:00,800
the new tool chain fund and nine other

00:15:00,079 --> 00:15:04,160
uh

00:15:00,800 --> 00:15:07,519
organizations other projects under

00:15:04,160 --> 00:15:10,720
the canoe tool chain and so we're

00:15:07,519 --> 00:15:11,440
again using that we've funded some of

00:15:10,720 --> 00:15:14,800
the

00:15:11,440 --> 00:15:16,959
students last year for travel um i mean

00:15:14,800 --> 00:15:18,079
as you understand it's it you know it's

00:15:16,959 --> 00:15:19,760
it's a matter of not

00:15:18,079 --> 00:15:21,360
not just you're saving this for forever

00:15:19,760 --> 00:15:24,079
and ever but also trying to

00:15:21,360 --> 00:15:26,959
use this prudently for example you know

00:15:24,079 --> 00:15:28,959
it's it's not enough money to

00:15:26,959 --> 00:15:31,040
continually pay for you know a

00:15:28,959 --> 00:15:33,519
scholarship or a sponsorship or a

00:15:31,040 --> 00:15:35,040
uh of a student in the university i mean

00:15:33,519 --> 00:15:37,920
it's not

00:15:35,040 --> 00:15:38,399
that level with a with a one shot but uh

00:15:37,920 --> 00:15:40,079
um

00:15:38,399 --> 00:15:42,320
you know to be able to utilize it for

00:15:40,079 --> 00:15:42,880
some you know key areas as as i

00:15:42,320 --> 00:15:44,880
mentioned

00:15:42,880 --> 00:15:46,320
with you know autocomp couple other

00:15:44,880 --> 00:15:49,360
projects with this

00:15:46,320 --> 00:15:49,680
rust bounty um it's not something where

00:15:49,360 --> 00:15:51,920
we're

00:15:49,680 --> 00:15:54,480
looking to again and we don't want to

00:15:51,920 --> 00:15:57,120
get in and it's you know it's it's it's

00:15:54,480 --> 00:15:57,839
ill-advised to get into the process of

00:15:57,120 --> 00:15:59,759
um

00:15:57,839 --> 00:16:01,440
you know paying developers and paying

00:15:59,759 --> 00:16:03,839
maintainers out of this it's not

00:16:01,440 --> 00:16:06,320
you know how open source projects

00:16:03,839 --> 00:16:09,440
generally work but but to look at key

00:16:06,320 --> 00:16:12,880
key focus areas

00:16:09,440 --> 00:16:15,279
okay that's interesting thank you

00:16:12,880 --> 00:16:16,880
the the fund has been in operation for

00:16:15,279 --> 00:16:18,639
for four years now i think

00:16:16,880 --> 00:16:20,720
if i look back at the at the records

00:16:18,639 --> 00:16:23,040
we've been four years

00:16:20,720 --> 00:16:24,639
kind of supporting students to come to

00:16:23,040 --> 00:16:27,680
caldra if they needed help

00:16:24,639 --> 00:16:29,360
um and trying to support initiatives

00:16:27,680 --> 00:16:30,880
where we could

00:16:29,360 --> 00:16:32,000
so i think the new auto conf is an

00:16:30,880 --> 00:16:33,920
interesting one because it's a very

00:16:32,000 --> 00:16:36,320
specific focused initiative to

00:16:33,920 --> 00:16:37,519
to do a revitalization effort but the

00:16:36,320 --> 00:16:40,720
subsequent

00:16:37,519 --> 00:16:42,240
um you know uh recurring engineering is

00:16:40,720 --> 00:16:43,519
really for the community to do but they

00:16:42,240 --> 00:16:45,920
need help getting to the point where

00:16:43,519 --> 00:16:45,920
they're ready

00:16:46,000 --> 00:16:49,360
can i just clarify one thing for

00:16:47,279 --> 00:16:51,759
catherine the funding of the

00:16:49,360 --> 00:16:53,360
new tools cauldron is completely

00:16:51,759 --> 00:16:56,000
separate it's nothing to do with this

00:16:53,360 --> 00:16:56,480
that's what i thought that's what i got

00:16:56,000 --> 00:16:58,399
okay

00:16:56,480 --> 00:16:59,759
that will when i can finally get the

00:16:58,399 --> 00:17:02,320
lawyers sorted out is

00:16:59,759 --> 00:17:04,240
will be actually a separate uk based

00:17:02,320 --> 00:17:05,839
community interest company

00:17:04,240 --> 00:17:07,520
yeah when are you going to get that done

00:17:05,839 --> 00:17:10,720
jeremy uh i've

00:17:07,520 --> 00:17:13,760
i've been reading impenetrably dense law

00:17:10,720 --> 00:17:15,199
things about charity law and so forth in

00:17:13,760 --> 00:17:17,039
principle it's very simple

00:17:15,199 --> 00:17:18,720
simple i think we've got it sorted now i

00:17:17,039 --> 00:17:20,880
now just need to find the time

00:17:18,720 --> 00:17:22,880
to build a company's house to make it

00:17:20,880 --> 00:17:24,480
happen we know who the directors will be

00:17:22,880 --> 00:17:26,480
we know how to do this stuff

00:17:24,480 --> 00:17:28,000
it's just getting over that first hurdle

00:17:26,480 --> 00:17:29,840
there's all sorts of rules about what

00:17:28,000 --> 00:17:30,640
you can call yourself if you're a cic

00:17:29,840 --> 00:17:32,080
etc

00:17:30,640 --> 00:17:33,840
and we're trying not to fall into those

00:17:32,080 --> 00:17:35,919
particular pitfalls um

00:17:33,840 --> 00:17:37,600
but yeah i had had i always hoped to

00:17:35,919 --> 00:17:40,799
have it done before cauldron

00:17:37,600 --> 00:17:42,240
um and uh i'm it's just

00:17:40,799 --> 00:17:43,919
it's one of those things once i get it

00:17:42,240 --> 00:17:47,840
done it'll run smoothly it's just

00:17:43,919 --> 00:17:47,840
getting over that first hurdle

00:17:51,039 --> 00:17:55,600
uh so i have a question for all their

00:17:53,440 --> 00:17:58,160
committees and the stewards

00:17:55,600 --> 00:17:59,039
should we all change our version numbers

00:17:58,160 --> 00:18:03,679
to match

00:17:59,039 --> 00:18:03,679
each other no

00:18:07,360 --> 00:18:10,400
i was going to say catherine i know you

00:18:09,120 --> 00:18:11,520
well enough that i know when you're

00:18:10,400 --> 00:18:14,799
being sarcastic

00:18:11,520 --> 00:18:17,200
but go on no i don't have a strong

00:18:14,799 --> 00:18:17,200
opinion

00:18:17,840 --> 00:18:20,960
i think if we change the version numbers

00:18:19,440 --> 00:18:28,080
we'd also have to make sure we all

00:18:20,960 --> 00:18:30,400
upgrade in sync we'll release in sync

00:18:28,080 --> 00:18:32,160
so who's present from the battled cygnus

00:18:30,400 --> 00:18:33,919
days when we actually used to do

00:18:32,160 --> 00:18:35,600
synchronized releases where people could

00:18:33,919 --> 00:18:37,919
say all these components worked well

00:18:35,600 --> 00:18:42,559
together and we had the unified tree

00:18:37,919 --> 00:18:44,559
how much work was that probably a lot

00:18:42,559 --> 00:18:46,320
well back in the day i used to do merges

00:18:44,559 --> 00:18:50,160
every month keeping everything in sync

00:18:46,320 --> 00:18:50,160
so we could then do a single release

00:18:50,799 --> 00:18:53,919
well i mean there was the you know at

00:18:53,280 --> 00:18:57,120
the time i mean

00:18:53,919 --> 00:19:00,320
the cygnus i mean and then

00:18:57,120 --> 00:19:03,919
um with code sorcery they also had a

00:19:00,320 --> 00:19:11,840
specific release of a of a unified

00:19:03,919 --> 00:19:11,840
tool chain yep we still do

00:19:16,480 --> 00:19:20,559
did i hear correctly that gdb is gonna

00:19:18,640 --> 00:19:24,400
change the number to match gcc

00:19:20,559 --> 00:19:27,360
did i miss that

00:19:24,400 --> 00:19:28,720
that is uh well not the number but the

00:19:27,360 --> 00:19:32,400
numbering scheme

00:19:28,720 --> 00:19:33,600
yeah okay okay i've misunderstood that

00:19:32,400 --> 00:19:36,559
so not the number you're not going to

00:19:33,600 --> 00:19:38,640
release gdp 11 all of a sudden

00:19:36,559 --> 00:19:40,240
no the next one is gdb10 and then the

00:19:38,640 --> 00:19:43,760
next one after that will be

00:19:40,240 --> 00:19:46,720
11. yeah okay we dropped the

00:19:43,760 --> 00:19:47,760
you know the minor release numbers it's

00:19:46,720 --> 00:19:51,280
going to be gdp

00:19:47,760 --> 00:19:53,440
10.1 then 10 10.2 10.3

00:19:51,280 --> 00:19:55,280
and those will be bug fix releases the

00:19:53,440 --> 00:20:00,240
next major release

00:19:55,280 --> 00:20:00,240
would be 11 just like jesus

00:20:00,640 --> 00:20:05,919
but the numbers are the coincidence it's

00:20:02,320 --> 00:20:06,640
the format that is called the following

00:20:05,919 --> 00:20:08,799
yeah

00:20:06,640 --> 00:20:11,120
yeah dj does raise a point that like

00:20:08,799 --> 00:20:12,799
glib c is one number off from the fedora

00:20:11,120 --> 00:20:15,039
number in terms of minor so people

00:20:12,799 --> 00:20:16,799
always really confused by that

00:20:15,039 --> 00:20:18,720
but it doesn't matter to me but i think

00:20:16,799 --> 00:20:20,240
to someone's point you know we could

00:20:18,720 --> 00:20:22,480
probably get to publishing

00:20:20,240 --> 00:20:23,840
data on what tool sets are used together

00:20:22,480 --> 00:20:25,200
and when we build g liberty and we do a

00:20:23,840 --> 00:20:26,080
glibc release we actually try pretty

00:20:25,200 --> 00:20:27,919
hard to

00:20:26,080 --> 00:20:29,360
say these are the things we use to build

00:20:27,919 --> 00:20:30,000
it or these are the most recent versions

00:20:29,360 --> 00:20:34,080
that work with

00:20:30,000 --> 00:20:36,880
glibc so that at least from the glibc uh

00:20:34,080 --> 00:20:38,320
installed data that we have it goes and

00:20:36,880 --> 00:20:39,600
shows you what what can be used with

00:20:38,320 --> 00:20:41,360
what so

00:20:39,600 --> 00:20:43,200
okay so nobody wants to change all our

00:20:41,360 --> 00:20:44,240
version numbers around to make matching

00:20:43,200 --> 00:20:47,360
version of this

00:20:44,240 --> 00:20:48,960
well let me just add that like gdb

00:20:47,360 --> 00:20:51,120
is going to be 10. it's a coincidence

00:20:48,960 --> 00:20:54,400
that gcc is at 10 as well

00:20:51,120 --> 00:20:57,280
but ddb has a six month statement so

00:20:54,400 --> 00:20:58,320
we'll have to really well if we have one

00:20:57,280 --> 00:21:01,039
per year

00:20:58,320 --> 00:21:01,760
so in a couple of years we'll be like in

00:21:01,039 --> 00:21:05,280
gdp

00:21:01,760 --> 00:21:08,320
13 while tcc will still be in

00:21:05,280 --> 00:21:09,840
11 12 right so that's the release

00:21:08,320 --> 00:21:11,360
guidance aspect as well

00:21:09,840 --> 00:21:14,080
yeah david malcolm raises the question

00:21:11,360 --> 00:21:16,400
about calendar year based numbering

00:21:14,080 --> 00:21:17,280
and david so i'm an ex-sorcerer so i

00:21:16,400 --> 00:21:18,799
used to work for

00:21:17,280 --> 00:21:20,400
for code sorcery and mentor graphics but

00:21:18,799 --> 00:21:22,000
that's how we did it that's how it's

00:21:20,400 --> 00:21:25,760
still done i imagine right

00:21:22,000 --> 00:21:29,120
catherine at mentor which is uh like a

00:21:25,760 --> 00:21:30,000
2020 q1 tool chain 2020 q2 tool chain

00:21:29,120 --> 00:21:31,600
right

00:21:30,000 --> 00:21:33,520
or have you changed that yeah that's

00:21:31,600 --> 00:21:35,440
right yeah

00:21:33,520 --> 00:21:37,520
they still do that yeah because

00:21:35,440 --> 00:21:39,760
customers they just wanted to know

00:21:37,520 --> 00:21:42,080
users just want to know okay is this the

00:21:39,760 --> 00:21:43,280
2020 q1 tool chain with all the pieces

00:21:42,080 --> 00:21:46,080
that work together yeah

00:21:43,280 --> 00:21:46,640
okay well then we'll use that um and

00:21:46,080 --> 00:21:48,799
there is

00:21:46,640 --> 00:21:50,720
um i mean there's precedent here i mean

00:21:48,799 --> 00:21:52,000
eclipse does a unified release despite

00:21:50,720 --> 00:21:53,200
the fact that they have hundreds of

00:21:52,000 --> 00:21:55,840
separate projects

00:21:53,200 --> 00:21:59,280
so eclipse has um they release a project

00:21:55,840 --> 00:22:01,440
platform so

00:21:59,280 --> 00:22:03,440
all right i see mark mark you want to

00:22:01,440 --> 00:22:08,000
say something go

00:22:03,440 --> 00:22:08,720
sorry but apart from the first endeavors

00:22:08,000 --> 00:22:12,640
i

00:22:08,720 --> 00:22:13,679
i think having things more in sync would

00:22:12,640 --> 00:22:17,760
be

00:22:13,679 --> 00:22:21,679
nice i did some patches for pfd

00:22:17,760 --> 00:22:25,679
and lip liberty lip little lip bit

00:22:21,679 --> 00:22:28,880
i don't know how to pronounce that uh

00:22:25,679 --> 00:22:32,000
anyway nick was nice enough to

00:22:28,880 --> 00:22:35,600
then backboard the bfd changes

00:22:32,000 --> 00:22:39,120
to the util so i know there

00:22:35,600 --> 00:22:42,720
they will get in the next release of

00:22:39,120 --> 00:22:45,440
pin utils but i don't know when gdp

00:22:42,720 --> 00:22:47,520
picks them up so i have to being there

00:22:45,440 --> 00:22:50,720
and

00:22:47,520 --> 00:22:55,840
it it would be nice to have

00:22:50,720 --> 00:22:55,840
more integration

00:23:06,880 --> 00:23:08,960
we

00:23:14,159 --> 00:23:17,280
so anyways thanks everybody for

00:23:16,000 --> 00:23:19,679
participating in this

00:23:17,280 --> 00:23:20,880
abridged version of the gcc steering

00:23:19,679 --> 00:23:24,000
committee and steward's

00:23:20,880 --> 00:23:26,159
q a session and uh thanks for the great

00:23:24,000 --> 00:23:26,880
comments in the chat and we'll continue

00:23:26,159 --> 00:23:29,919
to

00:23:26,880 --> 00:23:30,480
uh have this discussion uh later and i

00:23:29,919 --> 00:23:32,320
mean

00:23:30,480 --> 00:23:33,600
everybody's welcome to you know continue

00:23:32,320 --> 00:23:34,400
the conversation i guess we can go to

00:23:33,600 --> 00:23:36,080
one of the

00:23:34,400 --> 00:23:38,320
breakout rooms i want to take away from

00:23:36,080 --> 00:23:39,679
the rest of the sessions here or we can

00:23:38,320 --> 00:23:41,279
i said throughout the rest of the year

00:23:39,679 --> 00:23:42,240
continue to discuss these interesting

00:23:41,279 --> 00:23:44,799
topics and

00:23:42,240 --> 00:23:45,520
come to uh to a consensus so thanks

00:23:44,799 --> 00:23:46,799
everybody

00:23:45,520 --> 00:23:49,120
carlos all the stewards for

00:23:46,799 --> 00:23:50,000
participating and enjoy the rest of the

00:23:49,120 --> 00:23:52,640
conference and then again

00:23:50,000 --> 00:23:54,559
thanks to lpc for for sponsoring this

00:23:52,640 --> 00:23:56,080
and allowing us to to hold this

00:23:54,559 --> 00:23:58,159
this virtual conference this year it's

00:23:56,080 --> 00:24:02,080
been great and with the great support of

00:23:58,159 --> 00:24:02,080
elena and the rest of the staff

00:24:02,840 --> 00:24:05,840
and

00:24:24,320 --> 00:24:30,000
okay thank you david and

00:24:27,600 --> 00:24:32,000
everyone else participating so now we

00:24:30,000 --> 00:24:33,760
have five minutes

00:24:32,000 --> 00:24:36,159
until the next session which will be the

00:24:33,760 --> 00:24:39,039
lvm and

00:24:36,159 --> 00:24:39,039
gcc both

00:24:42,559 --> 00:24:49,440
can you guys hear me better now or same

00:24:45,600 --> 00:24:53,840
disaster you're better now

00:24:49,440 --> 00:24:53,840
you'll definitely have more volume okay

00:24:54,000 --> 00:25:01,840
good good good

00:25:11,360 --> 00:25:16,480
uh in anticipation of this session um

00:25:14,320 --> 00:25:18,400
could i have a volunteer to

00:25:16,480 --> 00:25:19,919
take the shared notes we've been taking

00:25:18,400 --> 00:25:23,360
notes on each buff

00:25:19,919 --> 00:25:25,679
and they get pushed up onto the lpc

00:25:23,360 --> 00:25:27,600
platform at the end of the day

00:25:25,679 --> 00:25:29,440
since i'm leading the lvm gcc buff i

00:25:27,600 --> 00:25:31,039
can't take notes at the same time

00:25:29,440 --> 00:25:43,840
so if anyone would care to volunteer

00:25:31,039 --> 00:25:43,840
that would be appreciated

00:27:14,320 --> 00:27:21,840
okay two minutes to start

00:28:34,960 --> 00:28:42,720
okay so let's start

00:28:39,360 --> 00:28:46,480
okay thank you jose the um so

00:28:42,720 --> 00:28:49,039
welcome to the llvm gcc buff um

00:28:46,480 --> 00:28:49,919
we've run these sessions in one or two

00:28:49,039 --> 00:28:52,559
places

00:28:49,919 --> 00:28:54,559
um over the last year or so conscious

00:28:52,559 --> 00:28:56,320
that people seem to be working on both

00:28:54,559 --> 00:28:58,559
projects and wouldn't it be nice

00:28:56,320 --> 00:28:59,520
if we could actually try and share some

00:28:58,559 --> 00:29:02,880
of the effort

00:28:59,520 --> 00:29:04,000
so we ran uh a session at last year's

00:29:02,880 --> 00:29:06,880
canoe cauldron

00:29:04,000 --> 00:29:07,919
we ran a session in the nlvm dev room at

00:29:06,880 --> 00:29:10,840
fosdem

00:29:07,919 --> 00:29:12,480
uh this spring and this is an

00:29:10,840 --> 00:29:16,399
opportunity um

00:29:12,480 --> 00:29:18,960
to run this discussion uh at lpc

00:29:16,399 --> 00:29:19,600
where we might have a bigger spread of

00:29:18,960 --> 00:29:23,120
uh

00:29:19,600 --> 00:29:25,120
llvm people than we usually expect

00:29:23,120 --> 00:29:26,240
um i'm going to try and just remain as a

00:29:25,120 --> 00:29:28,159
facilitator

00:29:26,240 --> 00:29:29,520
but i couldn't resist the chance of

00:29:28,159 --> 00:29:32,960
playing with the

00:29:29,520 --> 00:29:36,080
poll feature so um

00:29:32,960 --> 00:29:39,120
i'm going to ask a few questions and you

00:29:36,080 --> 00:29:39,120
should see in a moment

00:29:39,520 --> 00:29:43,840
your options to respond to the poll so

00:29:42,240 --> 00:29:45,440
if you'd like to answer the poll and

00:29:43,840 --> 00:29:48,880
we'll just give it a few moments

00:29:45,440 --> 00:29:51,600
so hopefully people are generally

00:29:48,880 --> 00:29:53,120
using gcc and llvm i hope we're going to

00:29:51,600 --> 00:29:55,120
get some llvm users

00:29:53,120 --> 00:29:57,039
in this particular poll um

00:29:55,120 --> 00:29:58,799
[Music]

00:29:57,039 --> 00:30:00,080
i'll just give it a moment or two for

00:29:58,799 --> 00:30:02,480
you to answer

00:30:00,080 --> 00:30:02,480
and

00:30:07,520 --> 00:30:11,039
okay people who are going to speak have

00:30:09,039 --> 00:30:15,200
spoken let's have a look at the poll

00:30:11,039 --> 00:30:16,000
so um a mixture of people here use gcc

00:30:15,200 --> 00:30:18,559
or both

00:30:16,000 --> 00:30:20,159
um a couple of people who just use llpm

00:30:18,559 --> 00:30:22,399
and one person who doesn't use

00:30:20,159 --> 00:30:24,080
either gcc or llvm which has an

00:30:22,399 --> 00:30:28,080
interesting result

00:30:24,080 --> 00:30:32,240
um so next question related to that

00:30:28,080 --> 00:30:35,279
um do you develop gcc

00:30:32,240 --> 00:30:36,080
and or llvm and i'd interpret this quite

00:30:35,279 --> 00:30:37,760
broadly

00:30:36,080 --> 00:30:39,039
you can count as a developer if you have

00:30:37,760 --> 00:30:40,240
patches committed to improve the

00:30:39,039 --> 00:30:42,399
documentation

00:30:40,240 --> 00:30:43,919
um as well as taking a special bonus

00:30:42,399 --> 00:30:47,200
point for that obviously

00:30:43,919 --> 00:30:51,840
um so uh yeah do you develop either of

00:30:47,200 --> 00:30:51,840
these tools

00:31:00,159 --> 00:31:03,360
fascinating we're getting more

00:31:01,679 --> 00:31:04,080
developers than we actually have users

00:31:03,360 --> 00:31:06,320
i'm not sure

00:31:04,080 --> 00:31:07,360
what to make of that particular response

00:31:06,320 --> 00:31:09,279
um

00:31:07,360 --> 00:31:10,880
here's the polling results um i go

00:31:09,279 --> 00:31:12,720
through this quite quickly so of course

00:31:10,880 --> 00:31:14,000
not surprisingly a lot of gcc developers

00:31:12,720 --> 00:31:15,760
here quite a few lld

00:31:14,000 --> 00:31:17,679
developers and a small number who've

00:31:15,760 --> 00:31:20,880
done both and

00:31:17,679 --> 00:31:21,519
not to be um some people of course who

00:31:20,880 --> 00:31:23,919
don't

00:31:21,519 --> 00:31:25,840
develop who are here for other tools um

00:31:23,919 --> 00:31:27,679
which leads me on to another question

00:31:25,840 --> 00:31:30,159
if they're not the only tools in the

00:31:27,679 --> 00:31:30,960
stable now this may break the polling

00:31:30,159 --> 00:31:32,799
system

00:31:30,960 --> 00:31:34,340
and so i'm just going to put together a

00:31:32,799 --> 00:31:37,730
custom poll

00:31:34,340 --> 00:31:37,730
[Music]

00:31:45,360 --> 00:31:50,000
all right okay so

00:31:48,480 --> 00:31:52,159
okay this is going to be interesting

00:31:50,000 --> 00:31:54,240
because i can't i can't have a six-way

00:31:52,159 --> 00:31:56,880
pole i didn't realize that

00:31:54,240 --> 00:31:59,120
so i'm afraid if you do llvm bin utils

00:31:56,880 --> 00:32:15,840
you cannot answer this poll

00:31:59,120 --> 00:32:15,840
um so there we go

00:32:26,720 --> 00:32:32,720
yeah we could only select one option

00:32:30,559 --> 00:32:34,240
yes i realized that and i didn't really

00:32:32,720 --> 00:32:37,039
i'm afraid the only

00:32:34,240 --> 00:32:38,559
i the training session and i did try to

00:32:37,039 --> 00:32:39,440
do a little bit before and then broke

00:32:38,559 --> 00:32:42,159
the system

00:32:39,440 --> 00:32:43,039
um i wasn't aware that it is an either

00:32:42,159 --> 00:32:45,600
or a poll

00:32:43,039 --> 00:32:47,440
so perhaps the answer has to be pick the

00:32:45,600 --> 00:32:48,159
one you think is most exciting to talk

00:32:47,440 --> 00:32:51,360
about

00:32:48,159 --> 00:32:53,279
so i could run that poll again and

00:32:51,360 --> 00:32:54,880
say if you answer one of those and want

00:32:53,279 --> 00:32:56,240
to answer another does anyone want to

00:32:54,880 --> 00:32:58,880
answer a second

00:32:56,240 --> 00:33:00,000
and we can we can do that again so we'll

00:32:58,880 --> 00:33:02,320
start this poll

00:33:00,000 --> 00:33:04,159
and i'll start it again i'm sorry you

00:33:02,320 --> 00:33:04,960
can't do llvm being utils i have no way

00:33:04,159 --> 00:33:06,640
of fixing that

00:33:04,960 --> 00:33:11,840
tell me what your second choice is of

00:33:06,640 --> 00:33:11,840
other tools you use

00:33:27,360 --> 00:33:31,279
okay so last time we got bin utils and

00:33:29,919 --> 00:33:32,720
and gdb

00:33:31,279 --> 00:33:34,880
and this time around yeah we can get

00:33:32,720 --> 00:33:35,840
more people using llc interesting no

00:33:34,880 --> 00:33:37,440
gold no one has

00:33:35,840 --> 00:33:40,399
their first priority or second priority

00:33:37,440 --> 00:33:40,399
using nldb

00:33:40,720 --> 00:33:45,279
jeremy you were missing the f f option

00:33:43,679 --> 00:33:47,679
from your poll

00:33:45,279 --> 00:33:48,720
yes and i know and if you tell me how to

00:33:47,679 --> 00:33:50,480
wrap f

00:33:48,720 --> 00:33:53,679
because i try to do a custom poll but it

00:33:50,480 --> 00:33:58,080
only lets me have five slots

00:33:53,679 --> 00:34:01,120
oh that's beyond my skills here yeah

00:33:58,080 --> 00:34:04,159
i can't i'll plan another window

00:34:01,120 --> 00:34:04,720
but you continue i'll carry on we can

00:34:04,159 --> 00:34:08,560
come back

00:34:04,720 --> 00:34:11,119
and so the um and then the question is

00:34:08,560 --> 00:34:12,639
how many people develop on this i'll ask

00:34:11,119 --> 00:34:13,200
this question so first of all first

00:34:12,639 --> 00:34:14,800
choice

00:34:13,200 --> 00:34:17,200
which is the main tool you mainly

00:34:14,800 --> 00:34:20,639
develop if you develop any of them

00:34:17,200 --> 00:34:22,320
um start a poll okay and again i'm sorry

00:34:20,639 --> 00:34:35,839
llvm bin newton's is going to be left

00:34:22,320 --> 00:34:35,839
out of this

00:34:41,839 --> 00:34:47,520
okay so of developers a lot have been

00:34:45,679 --> 00:34:49,520
a lot of bin util developers here a few

00:34:47,520 --> 00:34:51,200
ll developers interestingly we've got an

00:34:49,520 --> 00:34:54,960
lldb developer

00:34:51,200 --> 00:34:57,280
though ldb user and gdb

00:34:54,960 --> 00:34:58,640
so i'll ask that poll again and this is

00:34:57,280 --> 00:35:00,160
if you answer to

00:34:58,640 --> 00:35:02,000
one of this and you have a second tool

00:35:00,160 --> 00:35:17,839
you work on you can declare your

00:35:02,000 --> 00:35:17,839
second tool now okay

00:35:27,520 --> 00:35:30,560
okay that's slowing down let's publish

00:35:29,280 --> 00:35:33,040
the polling results

00:35:30,560 --> 00:35:34,160
so we actually have people so people do

00:35:33,040 --> 00:35:38,160
work on lld

00:35:34,160 --> 00:35:40,000
lldb and uh there's a bit of work on ld

00:35:38,160 --> 00:35:42,000
we see coming on and a little bit of

00:35:40,000 --> 00:35:44,079
work on lld but in general canoe bin

00:35:42,000 --> 00:35:47,680
utils is the big one and gdp

00:35:44,079 --> 00:35:50,079
so that's a useful uh set of questions

00:35:47,680 --> 00:35:52,960
not quite going quite how i planned

00:35:50,079 --> 00:35:54,400
so i want to try and not just repeat

00:35:52,960 --> 00:35:57,440
what we've said before but

00:35:54,400 --> 00:35:58,480
give us starting focus for the ongoing

00:35:57,440 --> 00:36:02,400
discussion

00:35:58,480 --> 00:36:05,440
okay so how ideas that we've had for

00:36:02,400 --> 00:36:07,440
joint work on language standardization

00:36:05,440 --> 00:36:08,880
uh are joint work on language

00:36:07,440 --> 00:36:10,560
standardization

00:36:08,880 --> 00:36:12,720
joint work on maintaining abi

00:36:10,560 --> 00:36:14,160
compatibility work on instability

00:36:12,720 --> 00:36:15,599
between tools and libraries i think

00:36:14,160 --> 00:36:16,400
we've picked up from one or two talks

00:36:15,599 --> 00:36:18,160
this week

00:36:16,400 --> 00:36:19,839
the idea of building with gcc and in

00:36:18,160 --> 00:36:22,880
linking with lld

00:36:19,839 --> 00:36:25,440
um and communication channels

00:36:22,880 --> 00:36:26,079
shared bugzilla joint mailing lists so

00:36:25,440 --> 00:36:28,079
those four

00:36:26,079 --> 00:36:30,079
areas have come up consistently they

00:36:28,079 --> 00:36:33,599
came up last year at canoe cauldron

00:36:30,079 --> 00:36:36,560
they came up at fosdem and in order to

00:36:33,599 --> 00:36:38,160
prioritize our talks i've got

00:36:36,560 --> 00:36:40,240
only two more polls and this is the

00:36:38,160 --> 00:36:43,200
first of them and

00:36:40,240 --> 00:36:44,400
i'm afraid there isn't an option to say

00:36:43,200 --> 00:36:47,440
none of the above

00:36:44,400 --> 00:36:49,280
because a starter pole

00:36:47,440 --> 00:36:51,520
so you can't say none of the above

00:36:49,280 --> 00:36:53,680
you've got to make a decision

00:36:51,520 --> 00:36:56,480
so yeah and what we'll do is we'll focus

00:36:53,680 --> 00:37:09,839
the conversation around these priorities

00:36:56,480 --> 00:37:09,839
um okay

00:37:23,760 --> 00:37:28,560
okay so oh those few more coming in

00:37:31,839 --> 00:37:35,760
that seems to stabilize that's

00:37:34,560 --> 00:37:38,800
interesting there

00:37:35,760 --> 00:37:39,280
there's a clear feeling here two-thirds

00:37:38,800 --> 00:37:41,680
of

00:37:39,280 --> 00:37:44,000
the answers around abi comparative

00:37:41,680 --> 00:37:47,119
compatibility and interoperability

00:37:44,000 --> 00:37:49,680
so i'll now open the floor for comments

00:37:47,119 --> 00:37:51,359
quite a few of you 17 of you thought

00:37:49,680 --> 00:37:54,880
interoperability

00:37:51,359 --> 00:37:57,599
is top priority

00:37:54,880 --> 00:37:58,800
what i'd ask is for the floor to comment

00:37:57,599 --> 00:38:02,720
on

00:37:58,800 --> 00:38:05,520
what are what what can we do

00:38:02,720 --> 00:38:07,359
to improve interoperability what are the

00:38:05,520 --> 00:38:08,240
mechanisms we should do what concrete

00:38:07,359 --> 00:38:11,680
efforts

00:38:08,240 --> 00:38:14,400
um that we can we can do what what where

00:38:11,680 --> 00:38:16,839
what should we do suggestions um the

00:38:14,400 --> 00:38:19,839
floor is now

00:38:16,839 --> 00:38:19,839
open

00:38:36,240 --> 00:38:41,280
uh so um uh there is a question rather

00:38:39,839 --> 00:38:46,240
than comment can you use

00:38:41,280 --> 00:38:49,359
lld when linking gcc using lto um

00:38:46,240 --> 00:38:52,079
and i don't know the answer nick what

00:38:49,359 --> 00:38:54,400
how would you like to comment

00:38:52,079 --> 00:38:55,280
yeah just a curious idea i've been

00:38:54,400 --> 00:38:57,599
playing with is

00:38:55,280 --> 00:38:59,040
you know i i see how unit tests are

00:38:57,599 --> 00:39:02,160
written in in llvm

00:38:59,040 --> 00:39:05,599
i'm kind of curious to see um maybe in

00:39:02,160 --> 00:39:07,200
in bin utils for instance like

00:39:05,599 --> 00:39:09,200
what the kind of testing framework is

00:39:07,200 --> 00:39:09,839
like because i'd be curious to play

00:39:09,200 --> 00:39:13,440
around with

00:39:09,839 --> 00:39:16,320
can we try to collaborate on a shared

00:39:13,440 --> 00:39:18,160
test suite particularly i i find

00:39:16,320 --> 00:39:21,119
compatibility with gas

00:39:18,160 --> 00:39:22,560
kind of lacking in llvm and i would like

00:39:21,119 --> 00:39:24,880
to be more proactive

00:39:22,560 --> 00:39:26,400
about making sure that klein's

00:39:24,880 --> 00:39:29,760
integrated assembler

00:39:26,400 --> 00:39:33,119
is is uh supportive of

00:39:29,760 --> 00:39:35,119
of uh or interoperable um

00:39:33,119 --> 00:39:36,640
kind of thing and and there's a couple

00:39:35,119 --> 00:39:39,119
places where i see even

00:39:36,640 --> 00:39:41,119
like for specific ices like some of the

00:39:39,119 --> 00:39:41,680
architecture extensions are diverging a

00:39:41,119 --> 00:39:44,320
little bit

00:39:41,680 --> 00:39:45,920
or you know have different names in

00:39:44,320 --> 00:39:47,280
between the two different tool chains

00:39:45,920 --> 00:39:50,160
and i think that makes it

00:39:47,280 --> 00:39:51,920
very frustrating to try to write um kind

00:39:50,160 --> 00:39:56,000
of tool chain portable

00:39:51,920 --> 00:39:59,280
assembler code right now

00:39:56,000 --> 00:40:01,359
so to address that um

00:39:59,280 --> 00:40:02,800
the miniatures don't have any unit tests

00:40:01,359 --> 00:40:04,560
at the moment but they do have test

00:40:02,800 --> 00:40:06,880
suites that you can run

00:40:04,560 --> 00:40:07,760
um i am now running the linker test

00:40:06,880 --> 00:40:09,760
suite using

00:40:07,760 --> 00:40:11,920
clang as it as the c compiler for the

00:40:09,760 --> 00:40:13,040
tests but it still tests the bin utils

00:40:11,920 --> 00:40:15,599
linker

00:40:13,040 --> 00:40:16,400
at the moment um but that is possible

00:40:15,599 --> 00:40:18,240
and it is

00:40:16,400 --> 00:40:19,440
it's certainly theoretically possible to

00:40:18,240 --> 00:40:22,640
for example run the

00:40:19,440 --> 00:40:25,280
gas test suite using um llvms

00:40:22,640 --> 00:40:26,880
assembler instead i haven't actually

00:40:25,280 --> 00:40:29,440
done it yet but that certainly can be

00:40:26,880 --> 00:40:29,440
arranged

00:40:29,920 --> 00:40:34,000
i i think it's been long established

00:40:32,000 --> 00:40:36,319
starting apple about a decade ago

00:40:34,000 --> 00:40:37,200
that you can use the gcc regression test

00:40:36,319 --> 00:40:40,480
set suite

00:40:37,200 --> 00:40:42,720
to test um kang llvm

00:40:40,480 --> 00:40:43,520
and that's been widely done and indeed

00:40:42,720 --> 00:40:45,680
within

00:40:43,520 --> 00:40:47,520
my company empiricalism that's part of

00:40:45,680 --> 00:40:50,079
the routine testing

00:40:47,520 --> 00:40:52,880
and one of the challenges is how do you

00:40:50,079 --> 00:40:55,200
make it so that the gcc test suite

00:40:52,880 --> 00:40:57,200
you know smoothly works with llvm

00:40:55,200 --> 00:40:59,680
there's no point in the tests

00:40:57,200 --> 00:41:00,880
internal structure of rtl uh being run

00:40:59,680 --> 00:41:02,880
on llvm

00:41:00,880 --> 00:41:04,400
um but i think pretty much out of the

00:41:02,880 --> 00:41:08,240
box you can run the

00:41:04,400 --> 00:41:10,640
the gcc torture tests on llvm

00:41:08,240 --> 00:41:13,839
and that's a fairly painless exercise

00:41:10,640 --> 00:41:13,839
and that's a big chunk of the tests

00:41:15,280 --> 00:41:22,640
i i ran into him

00:41:19,760 --> 00:41:24,720
i ran into different problems with rvm

00:41:22,640 --> 00:41:27,440
actually not myself some

00:41:24,720 --> 00:41:28,640
people i'm working with they are trying

00:41:27,440 --> 00:41:31,280
to use the

00:41:28,640 --> 00:41:33,440
clan to compel gdpc one particular

00:41:31,280 --> 00:41:37,920
problem is

00:41:33,440 --> 00:41:41,839
in gdpc there are certain

00:41:37,920 --> 00:41:45,520
uh scripts let's just put that away

00:41:41,839 --> 00:41:48,000
they are not a bad c code

00:41:45,520 --> 00:41:49,359
not they are also they are not embedded

00:41:48,000 --> 00:41:52,240
assembly code

00:41:49,359 --> 00:41:54,400
we are using that to generate some

00:41:52,240 --> 00:41:57,839
constant or something

00:41:54,400 --> 00:41:58,960
and however style problem for gcc gtc

00:41:57,839 --> 00:42:01,040
because just

00:41:58,960 --> 00:42:02,480
compile and pass everything to the

00:42:01,040 --> 00:42:05,440
server and

00:42:02,480 --> 00:42:05,920
because we only generate a summary code

00:42:05,440 --> 00:42:09,359
and

00:42:05,920 --> 00:42:13,280
use that with assembly output as

00:42:09,359 --> 00:42:16,480
some kind of company however

00:42:13,280 --> 00:42:20,319
even for hand even if it

00:42:16,480 --> 00:42:23,200
is one assembly code it insists

00:42:20,319 --> 00:42:23,200
to assemble

00:42:23,520 --> 00:42:29,839
the output of course

00:42:26,560 --> 00:42:34,400
if the award is not assembly we just

00:42:29,839 --> 00:42:37,760
use that as a way to compare something

00:42:34,400 --> 00:42:42,079
so i think that the bug report

00:42:37,760 --> 00:42:45,200
opened against that but i was told

00:42:42,079 --> 00:42:45,680
that is done by design if so for the

00:42:45,200 --> 00:42:48,560
clan

00:42:45,680 --> 00:42:49,520
even if you only want assembly code you

00:42:48,560 --> 00:42:52,400
will insist

00:42:49,520 --> 00:42:53,119
trying to assemble that so that one

00:42:52,400 --> 00:42:56,480
particular

00:42:53,119 --> 00:42:57,599
issue makes that difficult to compile

00:42:56,480 --> 00:43:00,079
gdpc

00:42:57,599 --> 00:43:00,079
with clan

00:43:00,720 --> 00:43:05,280
any of glibc people like to comment on

00:43:02,720 --> 00:43:08,000
that specific point

00:43:05,280 --> 00:43:09,440
i think it's just the first problem you

00:43:08,000 --> 00:43:11,920
will hit because it

00:43:09,440 --> 00:43:13,920
happens early during build there's

00:43:11,920 --> 00:43:16,000
actually a patch

00:43:13,920 --> 00:43:17,920
on some branch in the repository that

00:43:16,000 --> 00:43:22,800
fixes that

00:43:17,920 --> 00:43:25,280
and the trick is to put

00:43:22,800 --> 00:43:27,200
the extracted constant into an ascii

00:43:25,280 --> 00:43:28,400
literal in the assembler code so it

00:43:27,200 --> 00:43:31,359
doesn't matter

00:43:28,400 --> 00:43:33,280
what kind of syntax we use to mark the

00:43:31,359 --> 00:43:35,200
extraction point for the constant

00:43:33,280 --> 00:43:38,000
extraction from the tlc

00:43:35,200 --> 00:43:40,319
build system so that that i can point

00:43:38,000 --> 00:43:43,680
you to the patch

00:43:40,319 --> 00:43:46,960
but then we will hint you will

00:43:43,680 --> 00:43:48,720
hit a bunch of other problems like our

00:43:46,960 --> 00:43:52,560
use of

00:43:48,720 --> 00:43:55,839
nested functions still a few are left

00:43:52,560 --> 00:43:59,920
which are not supported by clang and

00:43:55,839 --> 00:44:02,079
you also won't get a correct api because

00:43:59,920 --> 00:44:04,000
clank doesn't do simple right direct

00:44:02,079 --> 00:44:05,119
through some simple redirects for

00:44:04,000 --> 00:44:08,800
built-ins

00:44:05,119 --> 00:44:11,599
like gcc does

00:44:08,800 --> 00:44:13,920
thank you florian all right you wish to

00:44:11,599 --> 00:44:13,920
speak

00:44:14,640 --> 00:44:18,480
yeah uh thanks jeremy so uh just a

00:44:17,280 --> 00:44:20,560
comment from

00:44:18,480 --> 00:44:22,640
i guess it's one of the four people here

00:44:20,560 --> 00:44:23,280
that develops both in gcc and the client

00:44:22,640 --> 00:44:26,720
side

00:44:23,280 --> 00:44:30,160
so um on our platform on ibm cs390

00:44:26,720 --> 00:44:32,240
um it's certainly the goal that clang

00:44:30,160 --> 00:44:33,680
inline assembly is as compatible as

00:44:32,240 --> 00:44:37,040
possible with

00:44:33,680 --> 00:44:39,760
the gcc version and i mean it will never

00:44:37,040 --> 00:44:40,560
be a hundred percent identical because

00:44:39,760 --> 00:44:42,560
the way that

00:44:40,560 --> 00:44:43,839
the gcc uh just passes through

00:44:42,560 --> 00:44:46,720
everything to gas

00:44:43,839 --> 00:44:47,839
uh enables you to use any feature that

00:44:46,720 --> 00:44:49,920
gas explo

00:44:47,839 --> 00:44:51,040
the gas exposes including all the macro

00:44:49,920 --> 00:44:54,160
facilities and whatnot

00:44:51,040 --> 00:44:54,960
this will never work in in clang inline

00:44:54,160 --> 00:44:56,800
assembly

00:44:54,960 --> 00:44:58,160
but sort of most people aren't using

00:44:56,800 --> 00:45:01,200
that in that assembly

00:44:58,160 --> 00:45:03,200
so for for that subset that is that is

00:45:01,200 --> 00:45:04,160
used by the major protein in an assembly

00:45:03,200 --> 00:45:07,760
we certainly want

00:45:04,160 --> 00:45:09,839
to be compatible uh we are not 100

00:45:07,760 --> 00:45:11,359
there yet but i can only encourage

00:45:09,839 --> 00:45:13,040
everybody who runs in the program just

00:45:11,359 --> 00:45:15,280
reported as a bug and

00:45:13,040 --> 00:45:17,440
we have fixed many of those in the past

00:45:15,280 --> 00:45:19,040
and if

00:45:17,440 --> 00:45:20,800
there are more that are being reported

00:45:19,040 --> 00:45:24,000
i'll be happy to fix fix more

00:45:20,800 --> 00:45:25,520
of those spikes in fact thank you

00:45:24,000 --> 00:45:27,200
i think that's you so i i would say that

00:45:25,520 --> 00:45:29,520
i can see from the chat column

00:45:27,200 --> 00:45:30,720
and remember the chat is recorded and

00:45:29,520 --> 00:45:32,400
will appear on the website

00:45:30,720 --> 00:45:33,760
we are building up a fantastic

00:45:32,400 --> 00:45:35,920
repository of incompatible

00:45:33,760 --> 00:45:38,800
incompatibilities that need fixing

00:45:35,920 --> 00:45:39,839
um so um there's a to-do list for

00:45:38,800 --> 00:45:43,119
someone

00:45:39,839 --> 00:45:47,040
okay um okay any more

00:45:43,119 --> 00:45:49,040
thoughts on interoperability

00:45:47,040 --> 00:45:50,240
okay let's then move on to the second

00:45:49,040 --> 00:45:53,520
priority which was

00:45:50,240 --> 00:45:55,119
abi compatibility anyone who

00:45:53,520 --> 00:45:57,359
saw that as a top priority like to

00:45:55,119 --> 00:46:00,800
compete comment on the issues of

00:45:57,359 --> 00:46:03,920
abi compatibility on you

00:46:00,800 --> 00:46:07,760
uh my impression

00:46:03,920 --> 00:46:09,040
yes okay personally uh i open a couple

00:46:07,760 --> 00:46:12,000
api box

00:46:09,040 --> 00:46:13,520
uh in polka cans rbm and also other

00:46:12,000 --> 00:46:16,800
people also open the

00:46:13,520 --> 00:46:19,119
rbm again yeah rdi issues

00:46:16,800 --> 00:46:20,400
my my question is are there they don't

00:46:19,119 --> 00:46:29,839
care about ibm

00:46:20,400 --> 00:46:29,839
to certain extent

00:46:30,319 --> 00:46:33,920
uh ben woodward makes an interesting

00:46:32,079 --> 00:46:36,319
comment in the chat it's not just about

00:46:33,920 --> 00:46:38,079
api compatibility it's also verifiable

00:46:36,319 --> 00:46:40,880
abi and that's an important point

00:46:38,079 --> 00:46:41,839
nathan yeah i was going to say that we

00:46:40,880 --> 00:46:43,280
facebook

00:46:41,839 --> 00:46:45,119
cares very much about the avi

00:46:43,280 --> 00:46:48,160
compatibility because

00:46:45,119 --> 00:46:52,400
we build with both compilers we

00:46:48,160 --> 00:46:54,960
use lipstick c plus plus this gcc

00:46:52,400 --> 00:46:56,319
standard library c plus by standard

00:46:54,960 --> 00:46:58,160
library uh

00:46:56,319 --> 00:46:59,839
and not the clang one and we expect it

00:46:58,160 --> 00:47:03,119
all to work together

00:46:59,839 --> 00:47:06,880
um and i know we file find issues that

00:47:03,119 --> 00:47:08,720
uh jason and or i could poke at

00:47:06,880 --> 00:47:10,000
or talk to the clang people about and

00:47:08,720 --> 00:47:11,760
say and then discuss what

00:47:10,000 --> 00:47:13,119
to happen and that happened recently

00:47:11,760 --> 00:47:17,400
with one that jason just

00:47:13,119 --> 00:47:20,559
fixed because uh the api is worded

00:47:17,400 --> 00:47:24,480
ambiguously for a time when c

00:47:20,559 --> 00:47:27,040
plus c plus 98 was the thing

00:47:24,480 --> 00:47:29,760
um and clang developers made some

00:47:27,040 --> 00:47:29,760
assumptions that

00:47:32,240 --> 00:47:35,520
anyway there were there there was some

00:47:34,000 --> 00:47:37,920
breakage that we had to reverse

00:47:35,520 --> 00:47:40,160
check to revert something to maintain

00:47:37,920 --> 00:47:42,640
compatibility

00:47:40,160 --> 00:47:43,200
but but some of the issues are already

00:47:42,640 --> 00:47:46,559
fighting

00:47:43,200 --> 00:47:50,160
uh filed in llvm baczilla for for

00:47:46,559 --> 00:47:52,240
many years and and the comments just

00:47:50,160 --> 00:47:54,400
him that they are not willing to change

00:47:52,240 --> 00:47:54,400
it

00:47:54,480 --> 00:47:58,920
i think the most important api

00:47:56,800 --> 00:48:01,760
incompatibility issue on

00:47:58,920 --> 00:48:06,160
x3664 is the

00:48:01,760 --> 00:48:09,280
uh the question whether whether

00:48:06,160 --> 00:48:12,559
8 or 16 bit

00:48:09,280 --> 00:48:15,200
arguments are sign or zero extended or

00:48:12,559 --> 00:48:15,200
not at all

00:48:15,359 --> 00:48:22,240
and that breaks in real world many

00:48:18,640 --> 00:48:28,000
many projects which for instance use

00:48:22,240 --> 00:48:28,000
c plus plus 11 typed enums

00:48:28,720 --> 00:48:35,680
i think there are a couple for this

00:48:31,839 --> 00:48:35,680
particular issue there a couple of

00:48:36,160 --> 00:48:42,480
discussions on the api

00:48:39,200 --> 00:48:46,839
forum i

00:48:42,480 --> 00:48:50,160
do not remember the conclusion as the

00:48:46,839 --> 00:48:51,119
uh i think what happened i think what

00:48:50,160 --> 00:48:55,200
should be if the

00:48:51,119 --> 00:48:58,480
uh okay let me see what happens

00:48:55,200 --> 00:49:01,680
if it is um if unspecified

00:48:58,480 --> 00:49:05,680
by the api in the

00:49:01,680 --> 00:49:09,440
assume anything something like this

00:49:05,680 --> 00:49:09,440
i recall hitting with

00:49:09,920 --> 00:49:13,040
uh foreign you've been up for a bit and

00:49:11,680 --> 00:49:15,119
then i'll bring i'll come back to you

00:49:13,040 --> 00:49:18,400
nathan florian

00:49:15,119 --> 00:49:20,559
i i would like to point out that

00:49:18,400 --> 00:49:21,599
this goes both ways so we have a

00:49:20,559 --> 00:49:25,400
long-standing

00:49:21,599 --> 00:49:28,880
abi back for gcc on 32-bit

00:49:25,400 --> 00:49:31,760
i386 and possibly other targets

00:49:28,880 --> 00:49:33,839
about atomic alignments for 64-bit

00:49:31,760 --> 00:49:36,079
integers

00:49:33,839 --> 00:49:37,280
where the the alignment is not correct

00:49:36,079 --> 00:49:39,440
and clang

00:49:37,280 --> 00:49:40,559
does it differently and arguably more

00:49:39,440 --> 00:49:43,680
correctly and

00:49:40,559 --> 00:49:46,880
yet we don't change gcc so sort of

00:49:43,680 --> 00:49:46,880
sort of goes both ways

00:49:47,280 --> 00:49:51,200
nathan you wanted to comment um yes

00:49:49,680 --> 00:49:53,359
specifically about the sign extension

00:49:51,200 --> 00:49:57,280
one because i remember hitting this

00:49:53,359 --> 00:50:00,079
uh paris gcc ports and it was gcct

00:49:57,280 --> 00:50:01,680
seemed to have historically done the

00:50:00,079 --> 00:50:04,960
extension in both places

00:50:01,680 --> 00:50:08,000
and then on certainly some ports and

00:50:04,960 --> 00:50:10,240
it was hard to make it not do that

00:50:08,000 --> 00:50:11,440
and then we left with the pragmatic

00:50:10,240 --> 00:50:13,680
state of

00:50:11,440 --> 00:50:15,599
having to work with old code that didn't

00:50:13,680 --> 00:50:17,599
do it in the right places

00:50:15,599 --> 00:50:19,839
whereas i think from what hj is saying

00:50:17,599 --> 00:50:20,400
that uh clang's attitude as well the

00:50:19,839 --> 00:50:23,760
rest of the

00:50:20,400 --> 00:50:27,760
the broken world should fix itself um

00:50:23,760 --> 00:50:30,480
and the gcc approach appears to be

00:50:27,760 --> 00:50:31,040
we have to work with the broken world um

00:50:30,480 --> 00:50:32,720
you know

00:50:31,040 --> 00:50:35,359
characterize them in course ways which

00:50:32,720 --> 00:50:37,440
is unfortunate

00:50:35,359 --> 00:50:38,400
uh yeah and hopefully this sort of

00:50:37,440 --> 00:50:40,960
vehicle can be

00:50:38,400 --> 00:50:41,520
us talking so we stop characterizing

00:50:40,960 --> 00:50:44,559
each other

00:50:41,520 --> 00:50:45,119
um i think my experience of working in

00:50:44,559 --> 00:50:46,640
both

00:50:45,119 --> 00:50:48,000
communities is they each have their

00:50:46,640 --> 00:50:48,960
great strengths and they have their

00:50:48,000 --> 00:50:52,400
weaknesses

00:50:48,960 --> 00:50:54,319
and neither of us is perfect sarah yes

00:50:52,400 --> 00:50:55,520
did you want to comment oh no you're

00:50:54,319 --> 00:50:57,599
holding up a three minute warning

00:50:55,520 --> 00:50:58,720
okay thank you um so we've got three

00:50:57,599 --> 00:51:01,119
minutes left

00:50:58,720 --> 00:51:03,119
very quickly um the other two topics

00:51:01,119 --> 00:51:06,319
that people raised were communication

00:51:03,119 --> 00:51:08,720
channels and language standards um

00:51:06,319 --> 00:51:10,079
i'm gonna pick communication channels if

00:51:08,720 --> 00:51:11,280
anyone wants to talk about that first

00:51:10,079 --> 00:51:12,800
just because language standards could

00:51:11,280 --> 00:51:14,960
take us another three hours

00:51:12,800 --> 00:51:17,839
um anyone wish to comment on

00:51:14,960 --> 00:51:19,760
communication channels

00:51:17,839 --> 00:51:21,680
at least for the the kernel standpoint

00:51:19,760 --> 00:51:24,559
um you know implementing

00:51:21,680 --> 00:51:26,000
new features in the language uh i think

00:51:24,559 --> 00:51:28,800
yesterday i sent out

00:51:26,000 --> 00:51:29,680
a mail trying to get a kernel specific

00:51:28,800 --> 00:51:32,160
mailing list

00:51:29,680 --> 00:51:33,440
a that's tool chain agnostic set up um

00:51:32,160 --> 00:51:34,319
one of the things i'd like to see is

00:51:33,440 --> 00:51:35,599
whenever

00:51:34,319 --> 00:51:37,760
someone needs a new extension of the

00:51:35,599 --> 00:51:39,440
language maybe kernel from a kernel

00:51:37,760 --> 00:51:41,200
developer standpoint that they

00:51:39,440 --> 00:51:43,200
post you know what are we trying to do

00:51:41,200 --> 00:51:45,440
here and then kind of let the tool chain

00:51:43,200 --> 00:51:46,720
folks sort out you know what's the best

00:51:45,440 --> 00:51:48,559
way to implement something like this

00:51:46,720 --> 00:51:50,559
that works for everyone

00:51:48,559 --> 00:51:51,599
and maybe try to collaborate on the

00:51:50,559 --> 00:51:53,599
design and

00:51:51,599 --> 00:51:56,240
testing of of the features i think would

00:51:53,599 --> 00:51:56,240
be really nice

00:51:58,880 --> 00:52:04,559
uh nick how do you see that as as

00:52:02,079 --> 00:52:06,400
different or how does the scope change

00:52:04,559 --> 00:52:08,160
with respect to the linux api list

00:52:06,400 --> 00:52:10,000
that we're already telling all the c

00:52:08,160 --> 00:52:13,680
library maintainers and kind of runtime

00:52:10,000 --> 00:52:13,680
maintainers to sit on and watch

00:52:14,800 --> 00:52:19,440
i guess it's i'm not aware of any other

00:52:17,520 --> 00:52:20,640
pre-existing mailing lists

00:52:19,440 --> 00:52:23,440
if there's another one that i should be

00:52:20,640 --> 00:52:26,480
using instead then i'm fine with that

00:52:23,440 --> 00:52:28,240
so i thought that the api one was was

00:52:26,480 --> 00:52:30,319
mostly for

00:52:28,240 --> 00:52:33,599
stuff to user space whereas this

00:52:30,319 --> 00:52:36,800
toolchain one that was proposed

00:52:33,599 --> 00:52:38,880
is for us talking to tool chain guys and

00:52:36,800 --> 00:52:41,599
can we please get the compiler to do so

00:52:38,880 --> 00:52:41,599
and so for us

00:52:42,000 --> 00:52:49,200
okay did you want to comment

00:52:47,440 --> 00:52:52,079
yeah i just wanted to briefly say that

00:52:49,200 --> 00:52:54,079
the uh llvm seems to be using a discord

00:52:52,079 --> 00:52:56,160
server as opposed to irc for a lot of

00:52:54,079 --> 00:52:59,680
things and i i've set up at least

00:52:56,160 --> 00:53:00,240
a um a prototype canoe tools uh discord

00:52:59,680 --> 00:53:01,839
server

00:53:00,240 --> 00:53:03,839
i mean it's separate from the llvm one

00:53:01,839 --> 00:53:05,200
but just in terms of discussing

00:53:03,839 --> 00:53:05,920
communication channels i don't know if

00:53:05,200 --> 00:53:07,520
we

00:53:05,920 --> 00:53:09,599
uh and not not to open a big can of

00:53:07,520 --> 00:53:10,400
worms during this meeting but if we want

00:53:09,599 --> 00:53:13,440
to

00:53:10,400 --> 00:53:15,200
use that if that's a a better form or

00:53:13,440 --> 00:53:17,839
another form that people prefer we can

00:53:15,200 --> 00:53:20,079
discuss that again in the future

00:53:17,839 --> 00:53:22,160
okay that's as well thank you very much

00:53:20,079 --> 00:53:24,240
i'm conscious we have one minute left

00:53:22,160 --> 00:53:25,680
i'm going to move to my last slide which

00:53:24,240 --> 00:53:27,520
is a poll

00:53:25,680 --> 00:53:28,880
which is we've got lots of ideas here

00:53:27,520 --> 00:53:32,240
and nick actually

00:53:28,880 --> 00:53:34,160
has answered a to one question

00:53:32,240 --> 00:53:36,000
um there's lots of initiatives here but

00:53:34,160 --> 00:53:38,079
it does need people to drive them

00:53:36,000 --> 00:53:39,839
nick's stood up and carlos has pointed

00:53:38,079 --> 00:53:40,319
out another initiative that's going on

00:53:39,839 --> 00:53:43,280
there

00:53:40,319 --> 00:53:44,559
i'm going to start the poll and see if

00:53:43,280 --> 00:53:47,040
we have people

00:53:44,559 --> 00:53:48,160
that are willing to say yes i think

00:53:47,040 --> 00:53:50,400
these are good

00:53:48,160 --> 00:53:53,760
um please vote to say yes you personally

00:53:50,400 --> 00:53:53,760
or your company will support these

00:53:54,839 --> 00:53:57,839
things

00:54:10,240 --> 00:54:14,800
okay and the polling seems to have

00:54:12,079 --> 00:54:16,160
stabilized no one more person voting

00:54:14,800 --> 00:54:17,839
i think we'll call it today there

00:54:16,160 --> 00:54:21,280
publish polling results

00:54:17,839 --> 00:54:22,800
so um i think there are some people put

00:54:21,280 --> 00:54:25,680
there and i have had a quick look at

00:54:22,800 --> 00:54:27,040
the the a's there are nick and carlos

00:54:25,680 --> 00:54:28,400
who already doing stuff in this space

00:54:27,040 --> 00:54:30,240
but i'm glad that people have got

00:54:28,400 --> 00:54:33,839
companies that will support

00:54:30,240 --> 00:54:35,119
and um i'm glad to see other people

00:54:33,839 --> 00:54:36,640
are willing to support it so there is

00:54:35,119 --> 00:54:37,760
some driver there but it does need

00:54:36,640 --> 00:54:39,839
people to lead

00:54:37,760 --> 00:54:41,280
and we have four leaders there so i

00:54:39,839 --> 00:54:41,760
encourage you to go forward and make

00:54:41,280 --> 00:54:45,200
these

00:54:41,760 --> 00:54:48,640
things happen uh thank you very much for

00:54:45,200 --> 00:54:50,720
um participating we have as part of this

00:54:48,640 --> 00:54:53,839
got an excellent record

00:54:50,720 --> 00:54:57,200
of um uh

00:54:53,839 --> 00:54:58,160
of uh some inconsistencies between llvm

00:54:57,200 --> 00:54:59,680
and gcc

00:54:58,160 --> 00:55:01,440
which will if nothing else is a good

00:54:59,680 --> 00:55:02,720
outcome from this uh

00:55:01,440 --> 00:55:04,720
so thank you all very much this

00:55:02,720 --> 00:55:08,640
discussion i'm sure will continue

00:55:04,720 --> 00:55:09,359
um in a uh one of the hack rooms in due

00:55:08,640 --> 00:55:12,240
course

00:55:09,359 --> 00:55:13,040
um we'll make a note of where that is on

00:55:12,240 --> 00:55:15,359
the

00:55:13,040 --> 00:55:21,839
rocket chat if it's working thank you

00:55:15,359 --> 00:55:24,640
very much

00:55:21,839 --> 00:55:24,640
thank you jeremy

00:55:27,119 --> 00:55:32,720
so we have now

00:55:30,559 --> 00:55:36,559
like three minutes until the next

00:55:32,720 --> 00:55:36,559
session which is a landing talk

00:55:39,359 --> 00:55:43,280
about accelerating machine learning

00:55:41,200 --> 00:55:49,839
workloads using

00:55:43,280 --> 00:55:49,839
gcc built-ins

00:55:52,799 --> 00:56:00,799
hello hi can you hear me

00:55:56,799 --> 00:56:05,760
yes do you do you get any echo

00:56:00,799 --> 00:56:07,680
a little bit yes okay um

00:56:05,760 --> 00:56:09,359
how words is it otherwise i have to

00:56:07,680 --> 00:56:12,319
sketch

00:56:09,359 --> 00:56:12,319
the headphones

00:56:12,640 --> 00:56:18,400
okay well i think it's not it's not i

00:56:15,200 --> 00:56:21,760
mean i can understand you perfectly well

00:56:18,400 --> 00:56:23,839
yeah thank you um

00:56:21,760 --> 00:56:25,760
okay you got everything you need you got

00:56:23,839 --> 00:56:31,839
the slides there

00:56:25,760 --> 00:56:31,839
the video works okay the audio as well

00:56:33,359 --> 00:56:45,440
yes but i'm just trying to slide

00:56:36,400 --> 00:56:48,880
go to the next page

00:56:45,440 --> 00:56:50,400
yes it works it works okay sometimes it

00:56:48,880 --> 00:56:52,880
takes a little

00:56:50,400 --> 00:56:53,920
while you know once after you push next

00:56:52,880 --> 00:56:55,760
or back

00:56:53,920 --> 00:56:59,839
sometimes it takes her one or two

00:56:55,760 --> 00:56:59,839
seconds to show up in your screen

00:57:01,040 --> 00:57:13,839
okay so two minutes

00:58:05,040 --> 00:58:12,640
okay it's time please go ahead thank you

00:58:08,799 --> 00:58:13,760
thanks hi everyone i'm rajalakshmi i'm

00:58:12,640 --> 00:58:15,760
working in ibm

00:58:13,760 --> 00:58:17,040
library optimization team for the power

00:58:15,760 --> 00:58:18,640
processor

00:58:17,040 --> 00:58:21,040
today i'm going to talk about some of

00:58:18,640 --> 00:58:24,240
the recent optimizations that i added in

00:58:21,040 --> 00:58:25,280
class library these are related to a new

00:58:24,240 --> 00:58:28,480
power tank feature

00:58:25,280 --> 00:58:30,240
called mma there are new compiler

00:58:28,480 --> 00:58:33,760
built-ins added for this

00:58:30,240 --> 00:58:35,920
feature to uh to help in matrix multiply

00:58:33,760 --> 00:58:37,280
multiplication and using all these

00:58:35,920 --> 00:58:39,359
buildings there is a

00:58:37,280 --> 00:58:40,400
good improvement in the performance so

00:58:39,359 --> 00:58:44,400
i'm going to

00:58:40,400 --> 00:58:44,400
talk about all these four topics today

00:58:45,280 --> 00:58:49,119
uh before we get into open blast just to

00:58:47,680 --> 00:58:51,440
give a brief about what

00:58:49,119 --> 00:58:54,160
glasses the expansion for blas is

00:58:51,440 --> 00:58:55,599
basically near algebra sub programs

00:58:54,160 --> 00:58:57,599
these are the routines that help in

00:58:55,599 --> 00:58:58,640
performing various vector and matrix

00:58:57,599 --> 00:59:01,599
operations

00:58:58,640 --> 00:59:03,920
and this is categorized into three types

00:59:01,599 --> 00:59:05,359
as level one level two and level three

00:59:03,920 --> 00:59:07,839
functions

00:59:05,359 --> 00:59:09,839
level one of blast functions perform

00:59:07,839 --> 00:59:12,799
scalar vector operations

00:59:09,839 --> 00:59:13,359
and level two of glass functions uh

00:59:12,799 --> 00:59:15,839
contains

00:59:13,359 --> 00:59:17,680
matrix and vector operations and in

00:59:15,839 --> 00:59:19,520
level three glass

00:59:17,680 --> 00:59:21,200
we have matrix and matrix operations

00:59:19,520 --> 00:59:24,400
today the focus is

00:59:21,200 --> 00:59:26,240
only on level 3 where i have optimized

00:59:24,400 --> 00:59:33,040
single and double precision matrix

00:59:26,240 --> 00:59:34,480
multiplication for the power processor

00:59:33,040 --> 00:59:36,240
there are different types of glass

00:59:34,480 --> 00:59:37,520
libraries distributed by different

00:59:36,240 --> 00:59:40,559
vendors but today

00:59:37,520 --> 00:59:42,240
um the focus is only on open glass open

00:59:40,559 --> 00:59:44,400
glass is an open source optimized

00:59:42,240 --> 00:59:46,079
glass library so the good thing about

00:59:44,400 --> 00:59:48,160
this open glass is uh

00:59:46,079 --> 00:59:50,559
this has optimized implementation of

00:59:48,160 --> 00:59:53,520
different types of kernel for different

00:59:50,559 --> 00:59:55,359
processes and today it is a default

00:59:53,520 --> 00:59:56,720
underlying library for many of the

00:59:55,359 --> 00:59:58,640
machine learning and deep learning

00:59:56,720 --> 01:00:01,599
frameworks

00:59:58,640 --> 01:00:02,960
this library has test and bench source

01:00:01,599 --> 01:00:05,040
in it so that

01:00:02,960 --> 01:00:07,040
for anyone who's going to develop a new

01:00:05,040 --> 01:00:09,280
feature in open blast

01:00:07,040 --> 01:00:11,599
it's very easy to use the prince test

01:00:09,280 --> 01:00:13,760
and show the performance improvement and

01:00:11,599 --> 01:00:16,319
get it accepted with community i

01:00:13,760 --> 01:00:19,520
recently added power 10 support

01:00:16,319 --> 01:00:20,400
in this library and there are some

01:00:19,520 --> 01:00:22,799
optimizations

01:00:20,400 --> 01:00:25,040
in the german kernel so gem stands for

01:00:22,799 --> 01:00:26,960
general matrix matrix operation

01:00:25,040 --> 01:00:30,400
and my optimizations were in the single

01:00:26,960 --> 01:00:30,400
and the big precision categories

01:00:31,359 --> 01:00:35,119
okay so there is a new exciting feature

01:00:33,760 --> 01:00:38,000
in power 10 this is called

01:00:35,119 --> 01:00:39,119
um mma mmv stands for matrix multiplier

01:00:38,000 --> 01:00:40,799
assist

01:00:39,119 --> 01:00:42,799
today most of the operations in the

01:00:40,799 --> 01:00:44,480
neural network require some form of

01:00:42,799 --> 01:00:46,240
matrix multiplication and this

01:00:44,480 --> 01:00:46,799
particular feature is definitely going

01:00:46,240 --> 01:00:49,920
to help

01:00:46,799 --> 01:00:51,920
in that space this feature introduces

01:00:49,920 --> 01:00:53,839
three different things the first one is

01:00:51,920 --> 01:00:55,760
uh it it introduces eight

01:00:53,839 --> 01:00:56,960
five twelve bit accumulators so

01:00:55,760 --> 01:01:00,400
accumulators are like

01:00:56,960 --> 01:01:03,119
um software managed shadow of

01:01:00,400 --> 01:01:04,559
four vsls for vector scalar registers so

01:01:03,119 --> 01:01:07,599
each accumulator is

01:01:04,559 --> 01:01:09,680
going to contain four 1.8 bit rooms so

01:01:07,599 --> 01:01:10,319
totally 5 12-bit and there are four rows

01:01:09,680 --> 01:01:12,880
in it

01:01:10,319 --> 01:01:13,839
if the input matrices of or of type

01:01:12,880 --> 01:01:15,839
float

01:01:13,839 --> 01:01:18,480
then this accumulators of scored by four

01:01:15,839 --> 01:01:19,520
array in case of the input matrix is of

01:01:18,480 --> 01:01:21,520
double times and

01:01:19,520 --> 01:01:23,119
accumulation can be like it's like a

01:01:21,520 --> 01:01:24,559
four by two array of floating points

01:01:23,119 --> 01:01:26,400
which you forget

01:01:24,559 --> 01:01:28,079
the second thing that this feature has

01:01:26,400 --> 01:01:31,280
is a set of instructions

01:01:28,079 --> 01:01:33,440
to transfer the content from vsrs to

01:01:31,280 --> 01:01:34,960
accumulators and from accumulators back

01:01:33,440 --> 01:01:37,280
to vsrs

01:01:34,960 --> 01:01:38,000
the third important thing is the set of

01:01:37,280 --> 01:01:40,079
outer product

01:01:38,000 --> 01:01:42,319
instructions that are going to help in

01:01:40,079 --> 01:01:45,440
our matrix multiplication

01:01:42,319 --> 01:01:45,920
so the next slide talks about this outer

01:01:45,440 --> 01:01:49,440
product

01:01:45,920 --> 01:01:52,960
instruction so this is the structure of

01:01:49,440 --> 01:01:56,160
the new instructions that are now added

01:01:52,960 --> 01:01:59,200
this instruction starts with um

01:01:56,160 --> 01:02:02,960
characters xv followed by the

01:01:59,200 --> 01:02:06,079
type uh the supporter types today are

01:02:02,960 --> 01:02:08,960
float32 double binary

01:02:06,079 --> 01:02:09,280
float 16 item from 16 inch four inch

01:02:08,960 --> 01:02:12,000
eight

01:02:09,280 --> 01:02:13,119
and in sixty so for the type uh for

01:02:12,000 --> 01:02:16,640
float it it says

01:02:13,119 --> 01:02:20,160
f32 followed by characters d

01:02:16,640 --> 01:02:21,920
r and then the rank so rank is the

01:02:20,160 --> 01:02:23,839
number of rows that this particular

01:02:21,920 --> 01:02:25,920
instruction is going to update at that

01:02:23,839 --> 01:02:27,599
time so for example for single position

01:02:25,920 --> 01:02:29,760
this particular instruction is going to

01:02:27,599 --> 01:02:32,880
update one row of the matrix so

01:02:29,760 --> 01:02:32,880
it's a rank one update

01:02:33,520 --> 01:02:37,760
this this picture explains the input and

01:02:36,799 --> 01:02:40,079
output of this

01:02:37,760 --> 01:02:41,760
instructions so there are three inputs

01:02:40,079 --> 01:02:42,720
for this new instruction it's going to

01:02:41,760 --> 01:02:45,119
take elements

01:02:42,720 --> 01:02:46,640
i mean inputs from of matrix a inputs

01:02:45,119 --> 01:02:49,760
from matrix b

01:02:46,640 --> 01:02:52,079
and accumulator so what happens is

01:02:49,760 --> 01:02:53,440
element ca gets multiplied with elements

01:02:52,079 --> 01:02:56,000
b and then

01:02:53,440 --> 01:02:57,680
the result is added to whatever result

01:02:56,000 --> 01:03:00,079
that was there in accumulator

01:02:57,680 --> 01:03:03,359
and stored back in emulator so the input

01:03:00,079 --> 01:03:06,000
and output accumulators are the same

01:03:03,359 --> 01:03:08,319
in the right hand side picture this this

01:03:06,000 --> 01:03:09,599
explains a single precision four by four

01:03:08,319 --> 01:03:12,640
computer

01:03:09,599 --> 01:03:14,880
so four elements of matrix saying gets

01:03:12,640 --> 01:03:15,119
multiplied with four elements of matrix

01:03:14,880 --> 01:03:17,359
v

01:03:15,119 --> 01:03:19,119
here that means each element from a

01:03:17,359 --> 01:03:21,440
you're going to get multiplied with all

01:03:19,119 --> 01:03:22,240
the four elements of b so there are 16

01:03:21,440 --> 01:03:25,359
floating

01:03:22,240 --> 01:03:27,280
13.32 elements here that's going to get

01:03:25,359 --> 01:03:29,039
saved in that generator so accumulator

01:03:27,280 --> 01:03:31,440
is like 4x4 it's a

01:03:29,039 --> 01:03:34,160
12 bit so it can contain all these 16

01:03:31,440 --> 01:03:34,160
results here

01:03:37,920 --> 01:03:42,480
so this is this is how uh the inner loop

01:03:41,200 --> 01:03:44,640
generally looks like

01:03:42,480 --> 01:03:46,079
assuming that the data is processed and

01:03:44,640 --> 01:03:48,319
transposed

01:03:46,079 --> 01:03:49,280
and it is ready uh for the matrix

01:03:48,319 --> 01:03:52,160
multiplication

01:03:49,280 --> 01:03:52,559
the inner loop looks like this uh let's

01:03:52,160 --> 01:03:55,440
assume

01:03:52,559 --> 01:03:57,920
m and n are number 4 and k is 16 that

01:03:55,440 --> 01:04:00,960
means there are 16 columns in matrix 8

01:03:57,920 --> 01:04:02,640
and this is the matrix b where uh 16

01:04:00,960 --> 01:04:05,119
rows and 4 columns

01:04:02,640 --> 01:04:05,920
so the loop is going to look like this

01:04:05,119 --> 01:04:08,160
row

01:04:05,920 --> 01:04:09,119
load one column from matrix a that's the

01:04:08,160 --> 01:04:12,880
blue column

01:04:09,119 --> 01:04:16,240
and then load blue row from matrix b

01:04:12,880 --> 01:04:16,240
and this m and n

01:04:16,319 --> 01:04:21,440
gets multiplied using this instruction

01:04:19,119 --> 01:04:22,079
uh using the xdf instruction that i just

01:04:21,440 --> 01:04:24,960
explained

01:04:22,079 --> 01:04:26,000
so if there are 16 columns in matrix a

01:04:24,960 --> 01:04:29,119
this is going to take

01:04:26,000 --> 01:04:30,799
16 xdf instructions and the result

01:04:29,119 --> 01:04:32,480
will be in the accumulator which is a

01:04:30,799 --> 01:04:35,520
4x4 array

01:04:32,480 --> 01:04:38,559
in case of power 9 uh what happens is

01:04:35,520 --> 01:04:40,559
we use vector multiply with

01:04:38,559 --> 01:04:42,880
that's going to take 16 into 4 so there

01:04:40,559 --> 01:04:43,520
are 64 instructions in case of power 9

01:04:42,880 --> 01:04:45,920
but

01:04:43,520 --> 01:04:49,039
with this feature in power 10 it's like

01:04:45,920 --> 01:04:51,039
reduced to 16 instructions now

01:04:49,039 --> 01:04:53,200
so the same will be repeated for 16

01:04:51,039 --> 01:04:56,720
that's how the inner loop looks like

01:04:53,200 --> 01:04:56,720
for any market specification

01:05:00,400 --> 01:05:04,480
okay so now let me talk about what this

01:05:02,559 --> 01:05:07,599
feature is uh

01:05:04,480 --> 01:05:09,839
so isa 3.1 upon pc has added all these

01:05:07,599 --> 01:05:13,520
mma instructions and

01:05:09,839 --> 01:05:14,559
recently in gcc 10.2 support for these

01:05:13,520 --> 01:05:17,599
instructions

01:05:14,559 --> 01:05:21,680
are like added and there are new

01:05:17,599 --> 01:05:24,000
built-in mma functions added in gcc 10.2

01:05:21,680 --> 01:05:26,559
so some of the buildings that i used in

01:05:24,000 --> 01:05:30,559
openglass now are listed here

01:05:26,559 --> 01:05:30,880
uh xvf32ger is what i just explained

01:05:30,559 --> 01:05:33,200
it's

01:05:30,880 --> 01:05:34,079
take it's going to take uh inputs from

01:05:33,200 --> 01:05:35,920
matrix

01:05:34,079 --> 01:05:37,680
once inputs from matrix two and the

01:05:35,920 --> 01:05:40,000
vector quad is the

01:05:37,680 --> 01:05:41,200
uh is the result accumulated where the

01:05:40,000 --> 01:05:43,839
switch is going to get

01:05:41,200 --> 01:05:45,200
stored so the difference between gr and

01:05:43,839 --> 01:05:48,480
grpp is

01:05:45,200 --> 01:05:50,559
in in case of g or pp the the result is

01:05:48,480 --> 01:05:51,520
going to get added with the accumulator

01:05:50,559 --> 01:05:54,559
but in case of

01:05:51,520 --> 01:05:56,799
ger it's just going to store it

01:05:54,559 --> 01:06:00,640
the result will not get added to the

01:05:56,799 --> 01:06:00,640
previously stored resistance

01:06:01,280 --> 01:06:05,039
so now that there is a feature and there

01:06:03,359 --> 01:06:07,599
are built-ins for that

01:06:05,039 --> 01:06:09,839
in power nine today uh the doesn't i

01:06:07,599 --> 01:06:12,559
mean for for these kernels it it

01:06:09,839 --> 01:06:14,400
uses hand written assembly version so

01:06:12,559 --> 01:06:14,960
for the s gem and region kernels there

01:06:14,400 --> 01:06:17,039
are like

01:06:14,960 --> 01:06:18,640
six thousand lines of assembly code in

01:06:17,039 --> 01:06:21,920
power 9 and when i

01:06:18,640 --> 01:06:24,480
started to optimize this

01:06:21,920 --> 01:06:26,000
matrix multiplication kernel for power

01:06:24,480 --> 01:06:27,520
10 there were no buildings and they

01:06:26,000 --> 01:06:30,839
started to write everything in

01:06:27,520 --> 01:06:32,400
assembly later when these built-ins are

01:06:30,839 --> 01:06:35,039
available i

01:06:32,400 --> 01:06:36,400
converted my code from assembly to c

01:06:35,039 --> 01:06:39,359
code

01:06:36,400 --> 01:06:41,520
since i already had a assembly version

01:06:39,359 --> 01:06:43,680
implemented i could easily benchmark

01:06:41,520 --> 01:06:46,400
between these two versions so i had a

01:06:43,680 --> 01:06:47,760
power 10 assembly version of sjm kernel

01:06:46,400 --> 01:06:50,079
and i also have a

01:06:47,760 --> 01:06:51,599
a c code using these new built-ins for

01:06:50,079 --> 01:06:53,359
the swim runner

01:06:51,599 --> 01:06:55,680
i could easily benchmark between these

01:06:53,359 --> 01:06:57,680
two and the performance was really

01:06:55,680 --> 01:06:59,280
closer so i decided to go with the

01:06:57,680 --> 01:07:00,480
buildings

01:06:59,280 --> 01:07:02,319
this is going to help in future

01:07:00,480 --> 01:07:04,400
maintenance and it is it is definitely

01:07:02,319 --> 01:07:07,440
easy to debug in future

01:07:04,400 --> 01:07:08,160
so the lines of code reduced from 6k to

01:07:07,440 --> 01:07:11,359
1k

01:07:08,160 --> 01:07:12,240
just for the srim and and similarly for

01:07:11,359 --> 01:07:14,799
the other

01:07:12,240 --> 01:07:16,720
double precision corners aspect these

01:07:14,799 --> 01:07:19,520
built-ins are also now used

01:07:16,720 --> 01:07:21,920
in other libraries like ireland today we

01:07:19,520 --> 01:07:24,720
also have plans to introduce

01:07:21,920 --> 01:07:25,680
in another one more library called bliss

01:07:24,720 --> 01:07:28,799
where we are going to

01:07:25,680 --> 01:07:31,599
introduce the low multiplication columns

01:07:28,799 --> 01:07:33,599
so the result of this conclusion is up

01:07:31,599 --> 01:07:34,079
to four x improvements noted in the

01:07:33,599 --> 01:07:35,920
poverty

01:07:34,079 --> 01:07:38,079
simulator depending on various state

01:07:35,920 --> 01:07:39,440
factors compared to power nine

01:07:38,079 --> 01:07:42,400
so that's a good improvement that we

01:07:39,440 --> 01:07:43,839
have noted

01:07:42,400 --> 01:07:46,000
these are the references that i talked

01:07:43,839 --> 01:07:48,880
about the first one um

01:07:46,000 --> 01:07:49,920
is the link that explains these built-in

01:07:48,880 --> 01:07:52,319
functions

01:07:49,920 --> 01:07:54,960
and the second link has all the

01:07:52,319 --> 01:07:57,839
optimizations that i just talked about

01:07:54,960 --> 01:07:57,839
thank you

01:08:05,920 --> 01:08:11,839
thank you do we have any question

01:08:26,000 --> 01:08:29,440
okay so

01:08:30,159 --> 01:08:39,839
we have five minutes until the next

01:08:32,319 --> 01:08:39,839
lighting talk

01:08:50,839 --> 01:08:53,839
uh

01:10:36,560 --> 01:10:46,719
um where are you getting that

01:10:44,239 --> 01:10:46,719
andrew

01:10:54,800 --> 01:10:59,840
there you are

01:11:10,640 --> 01:11:27,840
can you please say something so we can

01:11:12,880 --> 01:11:27,840
make sure your audio is working properly

01:11:37,750 --> 01:11:42,640
[Music]

01:11:39,920 --> 01:11:42,640
okay so

01:11:45,040 --> 01:11:55,840
so the audio is not working

01:12:39,280 --> 01:12:51,840
okay let's see if that works

01:13:15,950 --> 01:13:19,149
[Music]

01:14:40,840 --> 01:14:43,840
hmm

01:14:57,040 --> 01:15:01,600
okay andrew now i see that you are mute

01:15:08,000 --> 01:15:12,320
yeah so now it looks like you are

01:15:10,000 --> 01:15:15,199
connected using computer audio

01:15:12,320 --> 01:15:16,000
which looks like an improvement and you

01:15:15,199 --> 01:15:18,800
try to emute

01:15:16,000 --> 01:15:18,800
and say something

01:15:22,960 --> 01:15:39,840
you are mute you are still mute

01:15:48,640 --> 01:15:50,880
so

01:15:51,679 --> 01:16:07,840
can you trade please to a mute

01:16:47,760 --> 01:16:52,480
um i will not worry that much about the

01:16:50,400 --> 01:16:53,600
video because what we absolutely need is

01:16:52,480 --> 01:16:58,719
the audio for the

01:16:53,600 --> 01:16:58,719
for the talk so i still see that you are

01:17:00,840 --> 01:17:03,840
mute

01:17:07,520 --> 01:17:17,840
ah now you are not smooth any longer

01:17:10,880 --> 01:17:17,840
but i can't hear you

01:17:23,360 --> 01:17:31,840
okay now you are mute again

01:17:26,640 --> 01:17:31,840
can can anybody actually hear me

01:17:33,840 --> 01:17:37,280
i can hear you i can hear you just fine

01:17:35,920 --> 01:17:39,520
okay

01:17:37,280 --> 01:17:40,640
i was wondering if it was the the audio

01:17:39,520 --> 01:17:44,800
in the in the

01:17:40,640 --> 01:17:44,800
in the whole no it's

01:17:45,920 --> 01:17:52,560
just having trouble i don't know

01:17:49,360 --> 01:17:56,239
okay well andrew we can't hear you

01:17:52,560 --> 01:17:59,840
um you look a mute but uh still

01:17:56,239 --> 01:17:59,840
tell you is not coming through

01:18:13,760 --> 01:18:27,840
maybe you have i don't know maybe a kill

01:18:15,760 --> 01:18:27,840
switch in your micro or something

01:18:42,430 --> 01:18:45,549
[Applause]

01:18:47,920 --> 01:18:55,199
let's connect to the echo server

01:18:51,199 --> 01:18:55,199
it failed yeah let's let's look

01:19:06,239 --> 01:19:11,600
right okay so now thank you we've just

01:19:09,600 --> 01:19:14,400
been hearing about how to accelerate

01:19:11,600 --> 01:19:15,040
um uh machine learning now we can learn

01:19:14,400 --> 01:19:19,040
about how to

01:19:15,040 --> 01:19:22,320
accelerate things properly uh using gpus

01:19:19,040 --> 01:19:25,760
so this is a update on the status of the

01:19:22,320 --> 01:19:27,040
uh amd gcn project which we are here at

01:19:25,760 --> 01:19:28,080
mentor have been working on for a few

01:19:27,040 --> 01:19:32,320
years

01:19:28,080 --> 01:19:32,320
uh next slide so

01:19:32,640 --> 01:19:37,120
first of all for those who are

01:19:33,760 --> 01:19:38,800
unfamiliar gcn is amd's graphics core

01:19:37,120 --> 01:19:41,920
next architecture which is for

01:19:38,800 --> 01:19:42,640
gpus and as far as i'm aware all their

01:19:41,920 --> 01:19:46,400
recent

01:19:42,640 --> 01:19:50,080
radion branded gpus have been

01:19:46,400 --> 01:19:52,239
gcn under the covers um it's not a uh

01:19:50,080 --> 01:19:53,600
public-facing brand name such but it's

01:19:52,239 --> 01:19:57,040
something that um

01:19:53,600 --> 01:19:58,480
but it is what they use recently and uh

01:19:57,040 --> 01:20:01,600
this is the architecture that

01:19:58,480 --> 01:20:04,159
ornl the bridge national laboratory

01:20:01,600 --> 01:20:05,840
are planning to use in their upcoming

01:20:04,159 --> 01:20:07,199
exascale suitable computer named

01:20:05,840 --> 01:20:11,120
frontier

01:20:07,199 --> 01:20:12,639
uh their um previous um

01:20:11,120 --> 01:20:14,800
or the current one that they use at the

01:20:12,639 --> 01:20:16,320
moment is called summit and that runs on

01:20:14,800 --> 01:20:17,440
nvidia so i guess they're sharing it

01:20:16,320 --> 01:20:20,400
about

01:20:17,440 --> 01:20:22,560
um so uh this is largely what this

01:20:20,400 --> 01:20:25,040
project is about i think

01:20:22,560 --> 01:20:26,000
um the interest the hardware is

01:20:25,040 --> 01:20:29,040
interesting um

01:20:26,000 --> 01:20:31,360
the gpu consists of

01:20:29,040 --> 01:20:35,440
a 64 compute units which you can kind of

01:20:31,360 --> 01:20:39,440
think of as a cpu in their own right

01:20:35,440 --> 01:20:39,440
and each one each compute unit

01:20:39,600 --> 01:20:47,760
has 3200 scalar registers

01:20:43,760 --> 01:20:49,679
and 1024

01:20:47,760 --> 01:20:52,400
vector registers each of which consists

01:20:49,679 --> 01:20:56,320
of 64 32-bit lanes

01:20:52,400 --> 01:20:59,520
so this is a quite a large register file

01:20:56,320 --> 01:21:02,000
but it gets divided by

01:20:59,520 --> 01:21:03,920
40 when you run the maximum number of

01:21:02,000 --> 01:21:07,520
threads per compute unit

01:21:03,920 --> 01:21:09,199
um so if you want to run two threads on

01:21:07,520 --> 01:21:11,679
it then you can get half of it but if

01:21:09,199 --> 01:21:14,800
you want to run 40 then you end up with

01:21:11,679 --> 01:21:16,880
80 scalar registers in 24 vectors

01:21:14,800 --> 01:21:18,480
but after you take into account

01:21:16,880 --> 01:21:20,880
registers reserved for trap handlers it

01:21:18,480 --> 01:21:23,360
ends up being 64 scalars and

01:21:20,880 --> 01:21:24,639
24 vectors which is still not um

01:21:23,360 --> 01:21:29,840
terribly limited by

01:21:24,639 --> 01:21:29,840
many cpu standards um

01:21:30,560 --> 01:21:37,120
so we started this project around about

01:21:34,000 --> 01:21:41,760
the gcc7 timescale but it got first

01:21:37,120 --> 01:21:44,080
arrived upstream uh in gcc-9

01:21:41,760 --> 01:21:46,080
and that was only the basic um

01:21:44,080 --> 01:21:50,719
instruction set support

01:21:46,080 --> 01:21:54,000
you could run the gcc test suite

01:21:50,719 --> 01:21:57,120
using for c and fortran

01:21:54,000 --> 01:22:00,000
using a single threaded

01:21:57,120 --> 01:22:00,400
um runner rather like using a a target

01:22:00,000 --> 01:22:02,400
board

01:22:00,400 --> 01:22:03,840
it might do in it for any any embedded

01:22:02,400 --> 01:22:08,080
developer

01:22:03,840 --> 01:22:09,199
um when it comes to when it got to gc10

01:22:08,080 --> 01:22:11,199
though we've managed to get the

01:22:09,199 --> 01:22:12,320
offloading support upstream so you can

01:22:11,199 --> 01:22:16,719
now

01:22:12,320 --> 01:22:20,320
um build gcc 10 for

01:22:16,719 --> 01:22:23,719
for offload support so that is using

01:22:20,320 --> 01:22:26,880
openmp or openacc to run an

01:22:23,719 --> 01:22:28,800
x8664 program which in which the

01:22:26,880 --> 01:22:30,880
the the core kernels are offloaded to

01:22:28,800 --> 01:22:35,600
the gpu

01:22:30,880 --> 01:22:39,679
um the uh

01:22:35,600 --> 01:22:42,400
we support c and fortran on the for the

01:22:39,679 --> 01:22:43,520
for the gcn back end but you can also do

01:22:42,400 --> 01:22:45,679
offloading in c

01:22:43,520 --> 01:22:47,120
plus as long as the offload kernel

01:22:45,679 --> 01:22:50,159
doesn't use the

01:22:47,120 --> 01:22:51,679
c plus standard library at all um you

01:22:50,159 --> 01:22:54,880
can cope with the um

01:22:51,679 --> 01:22:56,639
nested functions and the um

01:22:54,880 --> 01:22:58,000
uh and all the other c plus plus weird

01:22:56,639 --> 01:22:59,679
things that you get in the in

01:22:58,000 --> 01:23:02,159
immediate intermediate representation

01:22:59,679 --> 01:23:05,360
just not the library calls

01:23:02,159 --> 01:23:10,400
um we currently support

01:23:05,360 --> 01:23:14,080
three gcn devices uh the gfx 803 fiji

01:23:10,400 --> 01:23:15,679
the gfx 900 vega and the gfx 906 vega

01:23:14,080 --> 01:23:17,679
i realize these are not the cards that

01:23:15,679 --> 01:23:21,600
tv will typically have at home

01:23:17,679 --> 01:23:25,120
often perhaps if you're a high-end gamer

01:23:21,600 --> 01:23:28,480
um so um

01:23:25,120 --> 01:23:30,480
if you have another amd gcn3 plus device

01:23:28,480 --> 01:23:31,520
um that you want to work then patches

01:23:30,480 --> 01:23:34,639
are welcome

01:23:31,520 --> 01:23:35,840
um if it's a discrete gpu with its own

01:23:34,639 --> 01:23:38,320
memory

01:23:35,840 --> 01:23:39,280
then it will not be even that hard it's

01:23:38,320 --> 01:23:41,280
just a question of

01:23:39,280 --> 01:23:43,040
adding the magic numbers and testing it

01:23:41,280 --> 01:23:46,800
really

01:23:43,040 --> 01:23:48,000
um apu's um such as the karizon stuff

01:23:46,800 --> 01:23:49,600
will require extra work

01:23:48,000 --> 01:23:51,600
because of the shared memory and the

01:23:49,600 --> 01:23:54,639
x-mac feature

01:23:51,600 --> 01:23:55,440
um requiring support that we don't have

01:23:54,639 --> 01:23:58,560
yet

01:23:55,440 --> 01:24:01,600
um these are just the devices that

01:23:58,560 --> 01:24:02,960
we have that amd are interested in for

01:24:01,600 --> 01:24:05,360
this project

01:24:02,960 --> 01:24:07,120
um there's no reason couldn't work on

01:24:05,360 --> 01:24:11,600
others we just haven't done it

01:24:07,120 --> 01:24:13,360
we don't have them to test um

01:24:11,600 --> 01:24:15,199
this is a picture that i got from the

01:24:13,360 --> 01:24:18,080
amd website of

01:24:15,199 --> 01:24:19,440
one of their beast um graphics cards i

01:24:18,080 --> 01:24:20,480
couldn't tell you exactly which one it

01:24:19,440 --> 01:24:22,400
says um

01:24:20,480 --> 01:24:23,679
it says it's a rally on pro vega

01:24:22,400 --> 01:24:25,520
frontier edition

01:24:23,679 --> 01:24:26,800
i don't think that means frontier

01:24:25,520 --> 01:24:31,840
exactly the same as the

01:24:26,800 --> 01:24:31,840
super computer but you never know

01:24:32,639 --> 01:24:36,719
uh so where are we at this is supposed

01:24:35,360 --> 01:24:40,080
to be the project status update

01:24:36,719 --> 01:24:40,800
this is where we get into that um in gcc

01:24:40,080 --> 01:24:42,480
01:24:40,800 --> 01:24:44,480
which is the current obviously public

01:24:42,480 --> 01:24:46,560
release and you can run this

01:24:44,480 --> 01:24:48,880
from ubuntu and there's various other

01:24:46,560 --> 01:24:52,800
distributions that are building it

01:24:48,880 --> 01:24:55,199
um the gcn offloading support

01:24:52,800 --> 01:24:56,159
fully supports all of gcc's openmp

01:24:55,199 --> 01:24:57,600
features that is

01:24:56,159 --> 01:24:59,760
the openmp features that have been

01:24:57,600 --> 01:25:02,960
implemented in gcc not

01:24:59,760 --> 01:25:07,120
all of openmp and it

01:25:02,960 --> 01:25:11,040
mostly supports gcc's open htc

01:25:07,120 --> 01:25:14,480
features the missing

01:25:11,040 --> 01:25:17,600
um support is the multi-workers um

01:25:14,480 --> 01:25:20,000
because of the way that um we do

01:25:17,600 --> 01:25:21,120
um the sharing on the computers there's

01:25:20,000 --> 01:25:22,480
broadcasting and stuff that needs to

01:25:21,120 --> 01:25:24,080
happen and that that support has not

01:25:22,480 --> 01:25:27,920
made it into the gtc

01:25:24,080 --> 01:25:30,800
10 branch as yet and probably never will

01:25:27,920 --> 01:25:31,920
um if you really want the freshest stuff

01:25:30,800 --> 01:25:34,639
you should go to the

01:25:31,920 --> 01:25:35,760
development branch however devel omp

01:25:34,639 --> 01:25:38,719
gcc10

01:25:35,760 --> 01:25:40,800
or og10 for short and that has full

01:25:38,719 --> 01:25:44,320
multi worker support we support

01:25:40,800 --> 01:25:48,000
16 workers per gang or

01:25:44,320 --> 01:25:51,120
threads per team if you're using openmp

01:25:48,000 --> 01:25:54,000
terminology that's the hardware maximum

01:25:51,120 --> 01:25:55,040
and you can have up to 40 gangs per

01:25:54,000 --> 01:25:57,840
compute unit

01:25:55,040 --> 01:25:59,040
again that's the hardware maximum and so

01:25:57,840 --> 01:26:03,120
and it has not to

01:25:59,040 --> 01:26:07,760
exceed 40 workers total so

01:26:03,120 --> 01:26:10,480
that is um so you can have 41

01:26:07,760 --> 01:26:11,360
worker or you can have two of 16 workers

01:26:10,480 --> 01:26:13,600
or you can have

01:26:11,360 --> 01:26:16,080
five or eight workers and then of course

01:26:13,600 --> 01:26:17,600
that multiplies up by 60 or 64 depending

01:26:16,080 --> 01:26:20,880
on what car you have

01:26:17,600 --> 01:26:21,600
to um rather a lot of threads um if you

01:26:20,880 --> 01:26:24,800
count it

01:26:21,600 --> 01:26:28,880
in terms of the work items um

01:26:24,800 --> 01:26:31,840
the number of um uh

01:26:28,880 --> 01:26:33,120
vector lanes that's um as thousands you

01:26:31,840 --> 01:26:34,000
know it's about two hundred and two and

01:26:33,120 --> 01:26:37,120
a half thousand um

01:26:34,000 --> 01:26:39,199
running simultaneously i think um

01:26:37,120 --> 01:26:40,960
that branch also has various openings

01:26:39,199 --> 01:26:42,960
you see improvements bug fixes the

01:26:40,960 --> 01:26:44,960
support been on to continuous arrays

01:26:42,960 --> 01:26:46,880
various profiling and pro and

01:26:44,960 --> 01:26:47,280
performance improvements all sorts of

01:26:46,880 --> 01:26:48,960
things

01:26:47,280 --> 01:26:50,400
all sorts of new stuff that we haven't

01:26:48,960 --> 01:26:53,600
yet managed to get

01:26:50,400 --> 01:26:54,159
into gcc 11 which is the next thing of

01:26:53,600 --> 01:26:58,159
course

01:26:54,159 --> 01:26:58,639
and we are gradually moving the patches

01:26:58,159 --> 01:27:01,679
from

01:26:58,639 --> 01:27:05,280
the og 10 into gcc 11 as the

01:27:01,679 --> 01:27:06,800
patch review system allows um it takes

01:27:05,280 --> 01:27:09,920
time

01:27:06,800 --> 01:27:12,320
there's only one reviewer and

01:27:09,920 --> 01:27:12,960
these patches tend to be complicated um

01:27:12,320 --> 01:27:14,880
but

01:27:12,960 --> 01:27:16,840
gradually working through so gcc11

01:27:14,880 --> 01:27:19,840
support is improving

01:27:16,840 --> 01:27:19,840
um

01:27:23,120 --> 01:27:28,320
yes the og-10 branch is based on gcc 10

01:27:26,080 --> 01:27:30,000
it is the stable development branch

01:27:28,320 --> 01:27:32,239
but it has the features that are

01:27:30,000 --> 01:27:35,760
destined for gc 11.

01:27:32,239 --> 01:27:39,199
so in some ways it's ahead of gc um

01:27:35,760 --> 01:27:40,960
mainline in some ways behind the current

01:27:39,199 --> 01:27:43,280
development that is in progress is

01:27:40,960 --> 01:27:46,320
largely around the debug

01:27:43,280 --> 01:27:48,320
uh amd um have

01:27:46,320 --> 01:27:50,320
a bunch of in-house developers working

01:27:48,320 --> 01:27:51,679
on gdb that's so that's not us but we're

01:27:50,320 --> 01:27:55,360
using it

01:27:51,679 --> 01:27:56,159
uh they have they are they are mostly

01:27:55,360 --> 01:28:00,000
working

01:27:56,159 --> 01:28:03,040
to have gdb work for their hip compiler

01:28:00,000 --> 01:28:05,040
which is llvm based

01:28:03,040 --> 01:28:06,639
um sorry i started late so i'm going to

01:28:05,040 --> 01:28:10,239
overrun a bit i feel

01:28:06,639 --> 01:28:12,000
um the um they've done a whole lot of

01:28:10,239 --> 01:28:15,199
work to make gdb work

01:28:12,000 --> 01:28:16,320
heterogeneous mode so it's context aware

01:28:15,199 --> 01:28:19,600
if you um

01:28:16,320 --> 01:28:22,639
you can load both x8664 and

01:28:19,600 --> 01:28:24,560
gcn binaries into the same project and

01:28:22,639 --> 01:28:26,159
it will automatically disassemble

01:28:24,560 --> 01:28:28,159
the right mode it will show you the

01:28:26,159 --> 01:28:29,199
right registers in the right mode it

01:28:28,159 --> 01:28:33,199
will

01:28:29,199 --> 01:28:34,639
um uh upset for eight points in the

01:28:33,199 --> 01:28:37,920
right mode for the right architecture

01:28:34,639 --> 01:28:39,760
and it shows the gpu threads on the info

01:28:37,920 --> 01:28:41,040
threads list alongside your cpu threads

01:28:39,760 --> 01:28:43,120
it's really rather clever what they've

01:28:41,040 --> 01:28:44,400
done none of that is upstream yet i

01:28:43,120 --> 01:28:47,199
don't know what their plans are

01:28:44,400 --> 01:28:48,560
but you can get it from github um and

01:28:47,199 --> 01:28:49,840
you can get it

01:28:48,560 --> 01:28:53,120
and the binary release comes with the

01:28:49,840 --> 01:28:54,880
rest of their drivers um

01:28:53,120 --> 01:28:57,440
the current one that you can that you

01:28:54,880 --> 01:29:00,880
get it supports basic debug

01:28:57,440 --> 01:29:01,840
the isa level um but and their future

01:29:00,880 --> 01:29:04,239
releases plan to

01:29:01,840 --> 01:29:05,199
support cfi and that's where we are with

01:29:04,239 --> 01:29:09,520
gcc2

01:29:05,199 --> 01:29:10,239
if you build um gcc main line today you

01:29:09,520 --> 01:29:12,480
will get

01:29:10,239 --> 01:29:13,920
basic the basic debug support for the

01:29:12,480 --> 01:29:16,639
current frame only

01:29:13,920 --> 01:29:17,520
and where we i have patches for the cfi

01:29:16,639 --> 01:29:20,480
stuff

01:29:17,520 --> 01:29:21,760
ready to go um almost just working out a

01:29:20,480 --> 01:29:24,159
few kinks

01:29:21,760 --> 01:29:25,360
um for when they release the gdb that

01:29:24,159 --> 01:29:27,679
works

01:29:25,360 --> 01:29:27,679
um

01:29:28,639 --> 01:29:33,840
okay yeah they've also had to make some

01:29:32,239 --> 01:29:34,719
cheap dwarf extensions because it wasn't

01:29:33,840 --> 01:29:38,000
really made for

01:29:34,719 --> 01:29:40,400
gpus um in particular this

01:29:38,000 --> 01:29:42,639
architecture is interesting because it's

01:29:40,400 --> 01:29:45,760
a 64-bit architecture in terms of memory

01:29:42,639 --> 01:29:48,639
but it only has 32-bit registers

01:29:45,760 --> 01:29:50,400
so it's one of the only architectures

01:29:48,639 --> 01:29:52,560
where

01:29:50,400 --> 01:29:54,560
addresses can span multiple registers

01:29:52,560 --> 01:29:55,360
and gcc is not good with this gdp is not

01:29:54,560 --> 01:29:57,520
good with this

01:29:55,360 --> 01:29:59,040
uh and dwarf isn't good with this so

01:29:57,520 --> 01:30:01,520
that's interesting

01:29:59,040 --> 01:30:02,239
uh final slide if you want to try this

01:30:01,520 --> 01:30:04,639
yourself

01:30:02,239 --> 01:30:06,000
you need to have i don't know i'm

01:30:04,639 --> 01:30:09,600
fishing the wrong slides

01:30:06,000 --> 01:30:13,360
okay you need to have an x86 64

01:30:09,600 --> 01:30:17,600
machine um that is to say amd 64.

01:30:13,360 --> 01:30:20,560
um with a supported gpu um

01:30:17,600 --> 01:30:21,600
uh it needs to be running ubuntu or sls

01:30:20,560 --> 01:30:25,040
or centos or

01:30:21,600 --> 01:30:27,920
red hat enterprise uh using

01:30:25,040 --> 01:30:29,360
64-bit and then if you have those you

01:30:27,920 --> 01:30:33,440
can install

01:30:29,360 --> 01:30:37,360
the rockum drivers from their website

01:30:33,440 --> 01:30:39,760
link is given um

01:30:37,360 --> 01:30:41,440
and that includes the gdb includes that

01:30:39,760 --> 01:30:45,360
llvm-based compiler

01:30:41,440 --> 01:30:47,440
um and uh and and their tools they don't

01:30:45,360 --> 01:30:51,679
there's no openmp or openhcc

01:30:47,440 --> 01:30:54,800
it's more like cooler but not um

01:30:51,679 --> 01:30:56,880
and then from the uh

01:30:54,800 --> 01:30:58,800
from the mentor website you can download

01:30:56,880 --> 01:31:01,520
the binary tools

01:30:58,800 --> 01:31:02,080
for um our tool chain that we've worked

01:31:01,520 --> 01:31:04,000
on so

01:31:02,080 --> 01:31:05,440
the main release was gc9 based but it

01:31:04,000 --> 01:31:08,000
had a big pile of patches on so it's

01:31:05,440 --> 01:31:09,120
closer to gcc 10 in terms of open htc

01:31:08,000 --> 01:31:12,719
support

01:31:09,120 --> 01:31:15,840
uh um indeed it has all the multi-worker

01:31:12,719 --> 01:31:17,440
support as well and the next release

01:31:15,840 --> 01:31:18,719
will be coming out in november which

01:31:17,440 --> 01:31:20,080
will be based on gc10

01:31:18,719 --> 01:31:22,080
and have all the debug support and

01:31:20,080 --> 01:31:23,840
everything and it'll be um you know

01:31:22,080 --> 01:31:25,920
properly tested by us

01:31:23,840 --> 01:31:27,120
or you can go and build it yourself and

01:31:25,920 --> 01:31:29,920
the gcc wiki

01:31:27,120 --> 01:31:31,280
has the instructions how to go build it

01:31:29,920 --> 01:31:35,120
it's also included

01:31:31,280 --> 01:31:37,920
it that in in ubuntu repo and

01:31:35,120 --> 01:31:39,360
probably some others uh that's the end

01:31:37,920 --> 01:31:42,560
of my

01:31:39,360 --> 01:31:44,800
um presentation so um

01:31:42,560 --> 01:31:47,440
do we have any questions well

01:31:44,800 --> 01:31:47,440
unfortunately

01:31:48,320 --> 01:31:55,199
we don't have time for testing okay

01:31:51,600 --> 01:31:58,960
i blame the microphone button

01:31:55,199 --> 01:32:00,560
okay thank you

01:31:58,960 --> 01:32:03,440
okay so now i'm handing over the

01:32:00,560 --> 01:32:03,440
moderation to

01:32:10,840 --> 01:32:16,639
davidson

01:32:12,960 --> 01:32:17,040
it works yeah yes hello jose thanks very

01:32:16,639 --> 01:32:21,199
much

01:32:17,040 --> 01:32:23,199
and great that we have serge

01:32:21,199 --> 01:32:24,960
so even though we're running a little

01:32:23,199 --> 01:32:28,400
bit late yeah so

01:32:24,960 --> 01:32:32,159
thanks jose great job and serge you're

01:32:28,400 --> 01:32:36,719
all ready to go so okay no transition

01:32:32,159 --> 01:32:40,159
so we can take five second break

01:32:36,719 --> 01:32:42,239
that's okay that's okay um that's just

01:32:40,159 --> 01:32:45,440
in time presenting

01:32:42,239 --> 01:32:47,120
even so uh this talk is about uh

01:32:45,440 --> 01:32:50,080
security flags

01:32:47,120 --> 01:32:51,520
for both gcc and clang and as you

01:32:50,080 --> 01:32:54,560
probably know

01:32:51,520 --> 01:32:57,920
when there is a security issue

01:32:54,560 --> 01:32:58,719
somewhere it can be fixed by the

01:32:57,920 --> 01:33:02,000
hardware

01:32:58,719 --> 01:33:05,199
or by your channel through

01:33:02,000 --> 01:33:07,520
update of the microcode or

01:33:05,199 --> 01:33:09,199
through your compiler where you may

01:33:07,520 --> 01:33:12,320
activate some

01:33:09,199 --> 01:33:15,600
security related flags that make

01:33:12,320 --> 01:33:18,080
attempts to detect or to prevent some

01:33:15,600 --> 01:33:18,719
attacks or you can change your your code

01:33:18,080 --> 01:33:22,239
base

01:33:18,719 --> 01:33:24,880
obviously the lower you are

01:33:22,239 --> 01:33:26,000
in this list the more costly it is and

01:33:24,880 --> 01:33:28,880
the higher

01:33:26,000 --> 01:33:29,920
uh the less intrusive it is for the end

01:33:28,880 --> 01:33:32,239
users

01:33:29,920 --> 01:33:33,360
so compiler is relatively okay on that

01:33:32,239 --> 01:33:35,520
side i mean just

01:33:33,360 --> 01:33:36,560
changing a few flags but you need to

01:33:35,520 --> 01:33:38,880
know the flags

01:33:36,560 --> 01:33:40,159
and what are their impacts what they

01:33:38,880 --> 01:33:42,719
actually do which

01:33:40,159 --> 01:33:43,679
requires some culture security related

01:33:42,719 --> 01:33:46,800
culture

01:33:43,679 --> 01:33:51,840
which is not always

01:33:46,800 --> 01:33:51,840
present in the end user brain

01:33:52,639 --> 01:33:59,600
so i'm going to speak to about

01:33:56,080 --> 01:34:04,080
gcc and llvm with a focus on

01:33:59,600 --> 01:34:04,880
cnc plus we can we could arguably speak

01:34:04,080 --> 01:34:08,239
about

01:34:04,880 --> 01:34:09,040
rust or go when they share some common

01:34:08,239 --> 01:34:11,040
infrastructure

01:34:09,040 --> 01:34:13,520
for instance some of the avm related

01:34:11,040 --> 01:34:17,040
security security flags

01:34:13,520 --> 01:34:19,760
are appliable for rust but it makes

01:34:17,040 --> 01:34:22,239
it easier for me to compare only for cc

01:34:19,760 --> 01:34:22,239
plus plus

01:34:24,560 --> 01:34:29,520
and yeah i'm a compiler engineer at red

01:34:27,280 --> 01:34:29,520
dots

01:34:30,800 --> 01:34:36,400
so uh just uh to begin with

01:34:34,400 --> 01:34:37,760
i'd like to point out that these are the

01:34:36,400 --> 01:34:40,800
defaults

01:34:37,760 --> 01:34:44,719
compiler flags for fedora on

01:34:40,800 --> 01:34:45,440
intel 64. and the interesting thing here

01:34:44,719 --> 01:34:48,400
is that

01:34:45,440 --> 01:34:50,639
almost all of these flags expect except

01:34:48,400 --> 01:34:53,440
from the debug and optimization ones

01:34:50,639 --> 01:34:54,320
are security related there is a strong

01:34:53,440 --> 01:34:57,760
focus

01:34:54,320 --> 01:35:00,639
on most distribution on security flags

01:34:57,760 --> 01:35:02,960
and so getting a good comment of them is

01:35:00,639 --> 01:35:05,920
meaningful

01:35:02,960 --> 01:35:07,119
it's not only about fedora on debian

01:35:05,920 --> 01:35:09,760
it's the same so

01:35:07,119 --> 01:35:10,880
it's a bit more difficult to access the

01:35:09,760 --> 01:35:13,440
actual list because

01:35:10,880 --> 01:35:14,080
it's split in two places so the first

01:35:13,440 --> 01:35:16,320
list is

01:35:14,080 --> 01:35:17,840
not is only a subset of what is actually

01:35:16,320 --> 01:35:21,119
applied

01:35:17,840 --> 01:35:22,000
but basically we've got a bit more flags

01:35:21,119 --> 01:35:25,119
on fedora

01:35:22,000 --> 01:35:25,760
but most of them are are common to

01:35:25,119 --> 01:35:29,840
fedora

01:35:25,760 --> 01:35:29,840
and debian they use the same

01:35:30,560 --> 01:35:34,080
interestingly debian is patching gcc to

01:35:33,199 --> 01:35:36,480
activate some

01:35:34,080 --> 01:35:38,000
security flags by default even for the

01:35:36,480 --> 01:35:41,119
end user

01:35:38,000 --> 01:35:43,840
so first i'll start with some kind of

01:35:41,119 --> 01:35:46,719
bibliography about

01:35:43,840 --> 01:35:47,520
common security flags so if you want to

01:35:46,719 --> 01:35:50,800
protect

01:35:47,520 --> 01:35:52,000
uh some libraries like the standard c

01:35:50,800 --> 01:35:54,400
libraries gillebc

01:35:52,000 --> 01:35:55,360
or the standard libre standard c plus

01:35:54,400 --> 01:35:58,719
plus library

01:35:55,360 --> 01:35:59,600
you could activate some macro so fortify

01:35:58,719 --> 01:36:03,280
source or

01:35:59,600 --> 01:36:03,280
glibc xx asserts

01:36:03,520 --> 01:36:08,239
fortify source is not very costly for

01:36:05,360 --> 01:36:11,760
the end user it basically

01:36:08,239 --> 01:36:14,080
adds some extra bond checking to

01:36:11,760 --> 01:36:14,960
some interesting the interesting part

01:36:14,080 --> 01:36:17,679
here is that

01:36:14,960 --> 01:36:18,480
also this looks like only processor

01:36:17,679 --> 01:36:20,159
flags

01:36:18,480 --> 01:36:23,840
which means it should be independent

01:36:20,159 --> 01:36:26,320
from the compiler

01:36:23,840 --> 01:36:27,600
these flags actually ignored some

01:36:26,320 --> 01:36:29,920
built-in calls

01:36:27,600 --> 01:36:30,719
where there might be some difference so

01:36:29,920 --> 01:36:32,400
at some point

01:36:30,719 --> 01:36:34,560
clang was not implementing some of this

01:36:32,400 --> 01:36:36,320
building now

01:36:34,560 --> 01:36:38,239
the required built in are implemented

01:36:36,320 --> 01:36:41,440
both in gcc and clang

01:36:38,239 --> 01:36:44,719
but maybe not with the same

01:36:41,440 --> 01:36:47,360
accuracy especially to compute

01:36:44,719 --> 01:36:48,560
dynamic object size or object size which

01:36:47,360 --> 01:36:52,480
are needed for

01:36:48,560 --> 01:36:55,840
fortify source

01:36:52,480 --> 01:36:56,239
and on the opposite the glibc xx asserts

01:36:55,840 --> 01:36:58,080
are

01:36:56,239 --> 01:37:00,000
relatively more costly because they

01:36:58,080 --> 01:37:04,239
check some

01:37:00,000 --> 01:37:06,239
boundary access and such so i would

01:37:04,239 --> 01:37:08,719
it has to be known that the cost is

01:37:06,239 --> 01:37:08,719
heavier

01:37:09,760 --> 01:37:12,080
next

01:37:13,679 --> 01:37:17,520
some checks can be done statically so

01:37:16,320 --> 01:37:20,000
for instance

01:37:17,520 --> 01:37:21,520
the well-known printf attacks where you

01:37:20,000 --> 01:37:24,080
pass the first argument

01:37:21,520 --> 01:37:27,040
controlled by the user can be detected

01:37:24,080 --> 01:37:30,320
at compile time and be warned or error

01:37:27,040 --> 01:37:34,719
on the good thing with that is that

01:37:30,320 --> 01:37:37,440
there is no extra runtime costs

01:37:34,719 --> 01:37:38,239
and in a similar manner some buffer

01:37:37,440 --> 01:37:41,920
overflows

01:37:38,239 --> 01:37:43,760
can be detected when

01:37:41,920 --> 01:37:47,119
the array bonds are not too complex and

01:37:43,760 --> 01:37:49,280
can be computed through a range analysis

01:37:47,119 --> 01:37:51,119
this is implemented for both gcc and

01:37:49,280 --> 01:37:51,760
clang but there has been much more

01:37:51,119 --> 01:37:55,119
efforts

01:37:51,760 --> 01:37:59,280
on the gc side on that aspect while

01:37:55,119 --> 01:38:01,360
um on the client side so in the lvm

01:37:59,280 --> 01:38:02,560
code base there used to be a quite

01:38:01,360 --> 01:38:05,440
accurate

01:38:02,560 --> 01:38:06,560
ranch analysis but it was deemed too

01:38:05,440 --> 01:38:09,199
expensive

01:38:06,560 --> 01:38:11,600
in terms of uh compilation time for the

01:38:09,199 --> 01:38:15,040
benefit so it got removed at some point

01:38:11,600 --> 01:38:16,400
and the actual one is a bit lagging

01:38:15,040 --> 01:38:19,440
behind

01:38:16,400 --> 01:38:22,880
the gcc one but

01:38:19,440 --> 01:38:23,760
that's for llvm and it's all implemented

01:38:22,880 --> 01:38:28,480
in the front end

01:38:23,760 --> 01:38:31,600
for the warning in clang so um

01:38:28,480 --> 01:38:34,320
it's not exactly the same but anyway

01:38:31,600 --> 01:38:36,800
the range value analysis is much better

01:38:34,320 --> 01:38:40,560
in gcc than in clang

01:38:36,800 --> 01:38:40,560
but it's good to have it in both

01:38:43,040 --> 01:38:50,239
this flag is debatable

01:38:47,280 --> 01:38:52,960
i would say what it does is whenever

01:38:50,239 --> 01:38:55,119
there is a stack allocated variable

01:38:52,960 --> 01:38:56,560
it's initialized while the standard

01:38:55,119 --> 01:38:59,760
doesn't mandate that

01:38:56,560 --> 01:39:02,800
neither scene or c plus plus and

01:38:59,760 --> 01:39:04,320
uh so the goal of that is to change an

01:39:02,800 --> 01:39:08,480
undefined behavior

01:39:04,320 --> 01:39:11,040
into a defined behavior

01:39:08,480 --> 01:39:13,280
which is compiler specific obviously so

01:39:11,040 --> 01:39:16,719
it used to be proposed

01:39:13,280 --> 01:39:17,360
for gcc or at least the idea was raised

01:39:16,719 --> 01:39:22,159
but

01:39:17,360 --> 01:39:24,840
it wasn't implemented apparently for

01:39:22,159 --> 01:39:26,880
optimization reason or execution time

01:39:24,840 --> 01:39:29,679
reason

01:39:26,880 --> 01:39:30,239
the protection it provides is that if

01:39:29,679 --> 01:39:33,600
some

01:39:30,239 --> 01:39:35,119
initialized stack variable ended up

01:39:33,600 --> 01:39:37,520
being printed this could leak some

01:39:35,119 --> 01:39:40,800
information that were in the stack

01:39:37,520 --> 01:39:44,400
for the previous stack frames and

01:39:40,800 --> 01:39:44,400
thanks to that at least it doesn't leak

01:39:48,800 --> 01:39:55,360
these two ones are for the linkers so

01:39:52,000 --> 01:39:58,639
ld gold or bfd and lld

01:39:55,360 --> 01:40:02,480
there are relatively old ones 15

01:39:58,639 --> 01:40:06,000
they were implemented 15 years ago

01:40:02,480 --> 01:40:10,800
i think so basically it deals with

01:40:06,000 --> 01:40:14,239
dynamic lazy loading of symbols

01:40:10,800 --> 01:40:17,360
by the loader and when you do that

01:40:14,239 --> 01:40:21,199
it's make it possible to

01:40:17,360 --> 01:40:23,360
to run undesired codes

01:40:21,199 --> 01:40:24,560
but the fix is relatively easy you load

01:40:23,360 --> 01:40:26,880
all your symbols

01:40:24,560 --> 01:40:28,800
uh when you load the actual program and

01:40:26,880 --> 01:40:32,239
then you mark the

01:40:28,800 --> 01:40:32,239
appropriate page as

01:40:32,280 --> 01:40:37,840
non-writable i

01:40:35,440 --> 01:40:38,639
if i recall correctly uh one of these

01:40:37,840 --> 01:40:41,440
two flags

01:40:38,639 --> 01:40:42,000
i i would say railroad is the default

01:40:41,440 --> 01:40:45,440
now

01:40:42,000 --> 01:40:48,560
and uh none lazy baiting

01:40:45,440 --> 01:40:50,400
binding has to be forced

01:40:48,560 --> 01:40:51,920
it's slightly increase the startup time

01:40:50,400 --> 01:40:54,880
but

01:40:51,920 --> 01:40:54,880
it also decreases

01:40:57,360 --> 01:41:01,440
the attack surface of your code

01:41:02,400 --> 01:41:09,280
and obviously nobody ever makes

01:41:05,600 --> 01:41:14,080
its stack executable uh by default

01:41:09,280 --> 01:41:16,560
but you could ensure that maybe on some

01:41:14,080 --> 01:41:17,520
hardware it's it's needed to provide

01:41:16,560 --> 01:41:19,840
this flag but

01:41:17,520 --> 01:41:20,880
the default is to have it's been not

01:41:19,840 --> 01:41:23,360
non-executable

01:41:20,880 --> 01:41:23,360
obviously

01:41:24,719 --> 01:41:29,440
quick comment on here by now the startup

01:41:28,159 --> 01:41:32,560
time

01:41:29,440 --> 01:41:36,239
performance impact was long since

01:41:32,560 --> 01:41:38,480
mitigated by having the uh the hashed uh

01:41:36,239 --> 01:41:40,239
symbol table lookups so there's no

01:41:38,480 --> 01:41:44,000
measurable startup time for that anymore

01:41:40,239 --> 01:41:44,000
okay good to know thanks

01:41:44,719 --> 01:41:48,560
and then with canal support you can

01:41:47,679 --> 01:41:51,920
enable

01:41:48,560 --> 01:41:54,880
asl layer which basically makes it's

01:41:51,920 --> 01:41:55,760
more difficult to write reproducible

01:41:54,880 --> 01:41:57,790
shell codes

01:41:55,760 --> 01:41:59,119
or attacks because you need to

01:41:57,790 --> 01:42:02,080
[Music]

01:41:59,119 --> 01:42:03,440
you can't rely on hard-coded address in

01:42:02,080 --> 01:42:05,840
your attacks

01:42:03,440 --> 01:42:06,480
you need to have a leak of the actual

01:42:05,840 --> 01:42:09,520
layout

01:42:06,480 --> 01:42:11,760
to to use the address

01:42:09,520 --> 01:42:13,360
or to brute force it which is also a

01:42:11,760 --> 01:42:15,199
valuable approach

01:42:13,360 --> 01:42:16,880
and to do that you need to compile

01:42:15,199 --> 01:42:20,719
depending on if it's a shared

01:42:16,880 --> 01:42:24,080
object or a binary

01:42:20,719 --> 01:42:26,480
with spy or opic and you also need to

01:42:24,080 --> 01:42:29,840
activate the according option

01:42:26,480 --> 01:42:30,719
on your channel otherwise well you are

01:42:29,840 --> 01:42:33,840
binary ended

01:42:30,719 --> 01:42:37,520
and it ends up being a relocatable but

01:42:33,840 --> 01:42:42,239
nobody cares well it's not used

01:42:37,520 --> 01:42:45,600
at least

01:42:42,239 --> 01:42:48,400
um so star clash is an attack

01:42:45,600 --> 01:42:49,280
where you make the stack and the hip

01:42:48,400 --> 01:42:52,320
grow so that

01:42:49,280 --> 01:42:54,000
in the end they end up overlapping which

01:42:52,320 --> 01:42:55,600
is normally detected by the kernel

01:42:54,000 --> 01:42:58,800
thanks to a gold page

01:42:55,600 --> 01:43:00,719
in between the two memory areas but

01:42:58,800 --> 01:43:01,840
if you happen to jump over that memory

01:43:00,719 --> 01:43:04,560
areas then

01:43:01,840 --> 01:43:06,880
you can have you can write the stack

01:43:04,560 --> 01:43:10,080
with the hip or the other way around

01:43:06,880 --> 01:43:13,040
and the typical way to prevent

01:43:10,080 --> 01:43:14,480
that attack is to probe each page when

01:43:13,040 --> 01:43:17,760
you allocate it

01:43:14,480 --> 01:43:21,119
through the stack and so the star

01:43:17,760 --> 01:43:23,760
this flag used to be gcc only but

01:43:21,119 --> 01:43:24,400
it's now also supported for by clang but

01:43:23,760 --> 01:43:26,159
not for

01:43:24,400 --> 01:43:28,880
all architecture it's not supported for

01:43:26,159 --> 01:43:28,880
arm yet

01:43:34,000 --> 01:43:39,520
and stack smashing so whenever you you

01:43:37,040 --> 01:43:42,639
use a buffer overflow or something to

01:43:39,520 --> 01:43:46,000
to write uh at the end of the stack

01:43:42,639 --> 01:43:49,280
generally to take control over

01:43:46,000 --> 01:43:49,760
the return pointer there are two

01:43:49,280 --> 01:43:52,560
different

01:43:49,760 --> 01:43:54,560
ways to protect from that the first one

01:43:52,560 --> 01:43:57,280
is the stacked canary

01:43:54,560 --> 01:43:58,560
which with the idea that if you end up

01:43:57,280 --> 01:44:00,719
smashing the stack you

01:43:58,560 --> 01:44:01,760
end up smashing the stack canary in the

01:44:00,719 --> 01:44:06,880
end

01:44:01,760 --> 01:44:08,639
and there is a test for that canary

01:44:06,880 --> 01:44:10,560
and the split stack is just to have two

01:44:08,639 --> 01:44:13,920
different memory areas

01:44:10,560 --> 01:44:17,280
to store different parts of the stack

01:44:13,920 --> 01:44:18,000
and so for the secondary stack protester

01:44:17,280 --> 01:44:20,719
strong

01:44:18,000 --> 01:44:22,080
is activated for both fedora and debian

01:44:20,719 --> 01:44:25,760
it's very

01:44:22,080 --> 01:44:27,840
common protection it's not super costly

01:44:25,760 --> 01:44:31,760
and i haven't found any reference of

01:44:27,840 --> 01:44:34,080
that of the split stack or safe stack

01:44:31,760 --> 01:44:36,960
implementation on gcc but i would love

01:44:34,080 --> 01:44:36,960
to be proved wrong

01:44:37,280 --> 01:44:40,960
it's available on clang

01:44:41,199 --> 01:44:45,600
the good thing with stack protector is

01:44:42,800 --> 01:44:48,239
that you can control the granularity of

01:44:45,600 --> 01:44:50,000
which functions are protected or not you

01:44:48,239 --> 01:44:52,560
can protect all of them even

01:44:50,000 --> 01:44:53,920
if the compiler think it's not useful or

01:44:52,560 --> 01:44:56,480
you you can

01:44:53,920 --> 01:44:57,280
let him make the choice for you which is

01:44:56,480 --> 01:44:59,920
usually

01:44:57,280 --> 01:44:59,920
the way to go

01:45:01,280 --> 01:45:05,440
so all this epithelia now all the

01:45:04,480 --> 01:45:07,920
options were

01:45:05,440 --> 01:45:09,199
equally supported at least from a

01:45:07,920 --> 01:45:12,400
command line api

01:45:09,199 --> 01:45:14,080
point of view by both compilers which is

01:45:12,400 --> 01:45:17,520
a relatively

01:45:14,080 --> 01:45:20,880
good status according to me

01:45:17,520 --> 01:45:22,880
even so the act supported architecture

01:45:20,880 --> 01:45:25,199
may differ or the actual implementation

01:45:22,880 --> 01:45:29,280
may differ providing different

01:45:25,199 --> 01:45:33,440
guarantees from a packager point of view

01:45:29,280 --> 01:45:33,440
it's nice to have the flags on both

01:45:33,760 --> 01:45:38,880
compiler two chains uh and now i have a

01:45:37,440 --> 01:45:41,920
few flags that are not

01:45:38,880 --> 01:45:41,920
equally supported

01:45:42,320 --> 01:45:48,719
by the total chain so first one is about

01:45:46,000 --> 01:45:49,360
spectr spectre i don't know who to spell

01:45:48,719 --> 01:45:51,920
that

01:45:49,360 --> 01:45:52,880
spectr in french so there are two

01:45:51,920 --> 01:45:56,320
versions of that

01:45:52,880 --> 01:45:58,960
um attacks

01:45:56,320 --> 01:46:00,080
but both rely on training the branch

01:45:58,960 --> 01:46:03,679
prediction

01:46:00,080 --> 01:46:05,840
and have that uh

01:46:03,679 --> 01:46:07,199
code and have that predictor execute

01:46:05,840 --> 01:46:10,800
code path

01:46:07,199 --> 01:46:14,880
that would should not be executed

01:46:10,800 --> 01:46:15,520
but and thanks to that we populate the

01:46:14,880 --> 01:46:19,119
cash

01:46:15,520 --> 01:46:19,760
and then you can use a cash time attack

01:46:19,119 --> 01:46:23,280
to guess

01:46:19,760 --> 01:46:26,639
what's is in the cash so that's

01:46:23,280 --> 01:46:28,560
the rough idea and the counter measure

01:46:26,639 --> 01:46:32,639
is basically to create to create

01:46:28,560 --> 01:46:35,440
a data dependency between the

01:46:32,639 --> 01:46:36,080
the branch ward and the actual data

01:46:35,440 --> 01:46:39,280
access

01:46:36,080 --> 01:46:42,400
through a mask which makes

01:46:39,280 --> 01:46:45,520
the cache the memory access fail if

01:46:42,400 --> 01:46:47,440
that are if the branch condition is

01:46:45,520 --> 01:46:48,880
false basically that's the whole idea so

01:46:47,440 --> 01:46:51,440
it's relatively costly

01:46:48,880 --> 01:46:52,639
it's better to rely on the intel

01:46:51,440 --> 01:46:57,040
microcode update

01:46:52,639 --> 01:47:00,159
to patch that but clank does have a flag

01:46:57,040 --> 01:47:02,239
to instrument your code

01:47:00,159 --> 01:47:06,480
to prevent that attack and i haven't

01:47:02,239 --> 01:47:09,360
found any reference in gcc but again

01:47:06,480 --> 01:47:12,159
if it's not the case it's on me and my

01:47:09,360 --> 01:47:12,159
bibliography

01:47:12,480 --> 01:47:20,000
the second variant of spectre is

01:47:15,920 --> 01:47:21,199
based on the same idea but instead of

01:47:20,000 --> 01:47:22,800
going through different branch and

01:47:21,199 --> 01:47:23,440
executing different and loading

01:47:22,800 --> 01:47:27,440
different

01:47:23,440 --> 01:47:30,159
data in memory you are using a

01:47:27,440 --> 01:47:31,840
virtual table to execute different

01:47:30,159 --> 01:47:34,239
function implementation which

01:47:31,840 --> 01:47:35,199
uh if you have control of what in of one

01:47:34,239 --> 01:47:38,560
of them may

01:47:35,199 --> 01:47:40,960
may be useful for you and

01:47:38,560 --> 01:47:41,840
both clang and gcc have protection

01:47:40,960 --> 01:47:45,760
against that

01:47:41,840 --> 01:47:48,960
using basically return instead of jump

01:47:45,760 --> 01:47:52,239
to doing direct branching

01:47:48,960 --> 01:47:54,239
which is very i find that idea very

01:47:52,239 --> 01:47:57,280
clever

01:47:54,239 --> 01:47:59,040
and um so

01:47:57,280 --> 01:48:02,080
the bad thing is that the flags are

01:47:59,040 --> 01:48:05,199
different in the two different

01:48:02,080 --> 01:48:08,000
uh two chains which is not uh

01:48:05,199 --> 01:48:09,280
super nice from a user point of view and

01:48:08,000 --> 01:48:11,440
basically

01:48:09,280 --> 01:48:13,440
it's because the flag is related to

01:48:11,440 --> 01:48:16,719
actual instrumentation techniques

01:48:13,440 --> 01:48:20,239
and not to counter measure it's not

01:48:16,719 --> 01:48:22,000
named minus m specter v2

01:48:20,239 --> 01:48:23,679
its name according to the contour

01:48:22,000 --> 01:48:26,560
measure so as they may

01:48:23,679 --> 01:48:27,920
slightly differ and the name differs but

01:48:26,560 --> 01:48:31,119
it makes it

01:48:27,920 --> 01:48:35,840
more blurry for the end user

01:48:31,119 --> 01:48:35,840
and they both have a performance impact

01:48:39,440 --> 01:48:43,119
and then to protect again return

01:48:42,080 --> 01:48:46,960
oriented programming

01:48:43,119 --> 01:48:51,760
where you once you get the control over

01:48:46,960 --> 01:48:54,159
the function pointer then you can

01:48:51,760 --> 01:48:55,440
use that to jump over several area in

01:48:54,159 --> 01:48:59,360
your codes

01:48:55,440 --> 01:49:01,199
and then jump back to the color which

01:48:59,360 --> 01:49:02,560
if you have enough gadgets in your code

01:49:01,199 --> 01:49:05,920
make it possible to run

01:49:02,560 --> 01:49:09,040
any code and the countermeasure is

01:49:05,920 --> 01:49:10,159
generally to to check if the control

01:49:09,040 --> 01:49:13,280
flow looks legit

01:49:10,159 --> 01:49:16,880
so that's cfi control for integrity

01:49:13,280 --> 01:49:20,000
it can be done in pure software

01:49:16,880 --> 01:49:23,840
through the cfi saying laser in clang

01:49:20,000 --> 01:49:26,960
i haven't found that in gct and

01:49:23,840 --> 01:49:28,159
there is also hardware support to do

01:49:26,960 --> 01:49:32,239
these checks

01:49:28,159 --> 01:49:32,880
um in both intel and armor architecture

01:49:32,239 --> 01:49:35,920
through

01:49:32,880 --> 01:49:39,040
c e c e t and bti and

01:49:35,920 --> 01:49:39,599
that's activated through minus control

01:49:39,040 --> 01:49:42,480
flow

01:49:39,599 --> 01:49:43,920
protection and that's supported by both

01:49:42,480 --> 01:49:47,440
clang and gct which

01:49:43,920 --> 01:49:48,239
is good news i don't have any estimate

01:49:47,440 --> 01:49:52,239
or

01:49:48,239 --> 01:49:54,480
i haven't read the papers about

01:49:52,239 --> 01:49:57,840
the actual overhead but if anyone has

01:49:54,480 --> 01:49:57,840
information please jump in

01:50:01,679 --> 01:50:05,760
one so it's not actually a counter

01:50:04,239 --> 01:50:08,320
measure but sometimes you want to know

01:50:05,760 --> 01:50:11,679
if your binary is protected

01:50:08,320 --> 01:50:13,360
in some way so a possible approach to

01:50:11,679 --> 01:50:15,760
that is just to check the flags that

01:50:13,360 --> 01:50:19,119
were used to compile your binary

01:50:15,760 --> 01:50:21,280
so gcc and clang actually so i

01:50:19,119 --> 01:50:23,199
i wrote gcc but i double checked and

01:50:21,280 --> 01:50:26,239
it's gcc and clang

01:50:23,199 --> 01:50:26,719
supports the record gcc switches so you

01:50:26,239 --> 01:50:29,760
can

01:50:26,719 --> 01:50:32,960
get this command line information in a

01:50:29,760 --> 01:50:34,320
note somewhere in your elf binary or you

01:50:32,960 --> 01:50:37,280
can use the

01:50:34,320 --> 01:50:38,080
adobe plugin which is more focused on

01:50:37,280 --> 01:50:40,800
security

01:50:38,080 --> 01:50:41,119
if i recall correctly and now as support

01:50:40,800 --> 01:50:44,880
for

01:50:41,119 --> 01:50:48,880
um both gcc and claim i'm not sure

01:50:44,880 --> 01:50:52,000
if clank support is as advanced

01:50:48,880 --> 01:50:55,040
as gc1 but at least

01:50:52,000 --> 01:50:57,520
it's ongoing work nick knows more than

01:50:55,040 --> 01:50:59,360
me about that

01:50:57,520 --> 01:51:01,280
yeah just to say i mean it's not as

01:50:59,360 --> 01:51:07,599
advanced as gcc but it is yeah

01:51:01,280 --> 01:51:11,119
as you say it's ongoing

01:51:07,599 --> 01:51:12,800
and um another approach instead of being

01:51:11,119 --> 01:51:15,280
declarative about the

01:51:12,800 --> 01:51:16,000
protection status of your binary would

01:51:15,280 --> 01:51:18,639
be to

01:51:16,000 --> 01:51:22,320
to actually inspect the assembly and

01:51:18,639 --> 01:51:22,320
looks for hardening artifacts

01:51:22,560 --> 01:51:26,639
in the same way that this small

01:51:24,719 --> 01:51:28,000
hardening czech script that is available

01:51:26,639 --> 01:51:31,040
on debian

01:51:28,000 --> 01:51:34,719
so i i wrote a small repo

01:51:31,040 --> 01:51:36,880
with a very simple and i would say dumb

01:51:34,719 --> 01:51:40,000
checks for each of the flags i've

01:51:36,880 --> 01:51:41,440
mentioned in this talk just to check

01:51:40,000 --> 01:51:43,119
if the flag is supported by both

01:51:41,440 --> 01:51:46,880
compiler and if there is

01:51:43,119 --> 01:51:46,880
an easy to check hardening

01:51:47,119 --> 01:51:54,239
um artifacts present in the assembly

01:51:51,520 --> 01:51:54,960
at some point or in the health headers

01:51:54,239 --> 01:51:57,199
so

01:51:54,960 --> 01:51:59,920
elaborating on that would be super

01:51:57,199 --> 01:52:03,199
useful both for

01:51:59,920 --> 01:52:04,960
white hats in security teams and also as

01:52:03,199 --> 01:52:08,320
a post check

01:52:04,960 --> 01:52:11,760
in a similar manner to bin and

01:52:08,320 --> 01:52:13,520
it would also be useful to check if gccm

01:52:11,760 --> 01:52:15,199
can generate the same kind of code or

01:52:13,520 --> 01:52:16,800
the same kind of artifact or the same

01:52:15,199 --> 01:52:18,800
kind of

01:52:16,800 --> 01:52:20,400
protection so instead of being

01:52:18,800 --> 01:52:23,440
declarative being

01:52:20,400 --> 01:52:25,440
looking at the actual codes looks

01:52:23,440 --> 01:52:26,719
very interesting but it's also more

01:52:25,440 --> 01:52:29,199
difficult because you need to understand

01:52:26,719 --> 01:52:32,159
the assembly

01:52:29,199 --> 01:52:33,040
but most of the time it's it's feasible

01:52:32,159 --> 01:52:35,599
i mean the

01:52:33,040 --> 01:52:36,639
the hardenings are not too complex and

01:52:35,599 --> 01:52:40,560
very local

01:52:36,639 --> 01:52:44,000
so it sounds like a possible approach

01:52:40,560 --> 01:52:46,320
so uh now small words

01:52:44,000 --> 01:52:48,080
about my personal experience when

01:52:46,320 --> 01:52:49,360
implementing stack clash protection for

01:52:48,080 --> 01:52:52,480
lvm

01:52:49,360 --> 01:52:54,159
so it's nice to have it already

01:52:52,480 --> 01:52:56,000
implemented in gcc

01:52:54,159 --> 01:52:57,520
and documented in the mailing list

01:52:56,000 --> 01:52:59,280
because the only thing i had to do was

01:52:57,520 --> 01:53:02,400
to read the posts

01:52:59,280 --> 01:53:03,040
and i mean implement the ideas that were

01:53:02,400 --> 01:53:06,880
already

01:53:03,040 --> 01:53:11,599
available i could also use

01:53:06,880 --> 01:53:13,920
the output of gcc as a starter for what

01:53:11,599 --> 01:53:15,760
i wanted to to generate or to check that

01:53:13,920 --> 01:53:18,960
we were generating the same

01:53:15,760 --> 01:53:20,159
things which is uh there were some

01:53:18,960 --> 01:53:21,840
design choice

01:53:20,159 --> 01:53:23,520
which made the output slightly different

01:53:21,840 --> 01:53:25,199
but

01:53:23,520 --> 01:53:26,880
that's also a good way to collaborate i

01:53:25,199 --> 01:53:29,040
mean one

01:53:26,880 --> 01:53:31,599
compiler to change does the job and then

01:53:29,040 --> 01:53:33,520
the other one just adjusts

01:53:31,599 --> 01:53:34,800
it's to chain to the actual state of the

01:53:33,520 --> 01:53:36,880
art

01:53:34,800 --> 01:53:38,000
and there is less friction because there

01:53:36,880 --> 01:53:41,360
is a clear leader

01:53:38,000 --> 01:53:43,440
when we do so um one

01:53:41,360 --> 01:53:45,040
uh thing i was disappointing about

01:53:43,440 --> 01:53:48,080
disappointed about was

01:53:45,040 --> 01:53:51,280
that i could not reuse the gcc test bed

01:53:48,080 --> 01:53:52,080
because uh the tests the gcc test for

01:53:51,280 --> 01:53:56,239
stacklash

01:53:52,080 --> 01:53:57,199
actually relies on verbose output of gcc

01:53:56,239 --> 01:53:59,840
and checking

01:53:57,199 --> 01:54:01,440
some reports while i wanted to check the

01:53:59,840 --> 01:54:04,880
actual assembly

01:54:01,440 --> 01:54:07,599
for some test-driven like

01:54:04,880 --> 01:54:08,159
development so there is room for

01:54:07,599 --> 01:54:11,360
improvement

01:54:08,159 --> 01:54:14,560
improvement there uh maybe

01:54:11,360 --> 01:54:14,880
if we if we write our tests in a way

01:54:14,560 --> 01:54:16,800
that

01:54:14,880 --> 01:54:19,440
only checks the generated assembly and

01:54:16,800 --> 01:54:22,960
not the elder internal representation

01:54:19,440 --> 01:54:23,920
or the gcc gimper or rtl or i don't know

01:54:22,960 --> 01:54:27,199
the same the

01:54:23,920 --> 01:54:29,040
actual name for the cc this

01:54:27,199 --> 01:54:30,639
would help a lot because sharing is a

01:54:29,040 --> 01:54:33,199
test suit uh

01:54:30,639 --> 01:54:33,760
it's super cool nobody likes to write it

01:54:33,199 --> 01:54:37,199
and

01:54:33,760 --> 01:54:40,400
everybody wants to use it or i do hope

01:54:37,199 --> 01:54:41,840
and so that could be a hint for future

01:54:40,400 --> 01:54:44,400
development when we write

01:54:41,840 --> 01:54:45,440
a new protection write some generic

01:54:44,400 --> 01:54:50,000
tests maybe

01:54:45,440 --> 01:54:52,719
in a separate repo and and that's

01:54:50,000 --> 01:54:52,719
much easier

01:54:53,679 --> 01:54:58,000
yeah i have one minute and only one

01:54:55,280 --> 01:55:01,440
slide left so i can elaborate on that

01:54:58,000 --> 01:55:02,639
if we wrote some valgrind like

01:55:01,440 --> 01:55:05,760
[Music]

01:55:02,639 --> 01:55:07,280
plugins that would check that whenever

01:55:05,760 --> 01:55:10,800
the program is run

01:55:07,280 --> 01:55:13,199
the the probe are done correctly

01:55:10,800 --> 01:55:13,920
by just through execution of the

01:55:13,199 --> 01:55:16,080
assembly

01:55:13,920 --> 01:55:18,639
this would also give us some insurance

01:55:16,080 --> 01:55:22,639
about the quality of the verification

01:55:18,639 --> 01:55:25,199
and we could test

01:55:22,639 --> 01:55:26,560
if gcc and claim provide the same kind

01:55:25,199 --> 01:55:28,560
of protection

01:55:26,560 --> 01:55:29,840
and that's something that we it's not

01:55:28,560 --> 01:55:32,000
done actually

01:55:29,840 --> 01:55:33,760
for i've done the test more accurately

01:55:32,000 --> 01:55:37,679
for fortify and the diff

01:55:33,760 --> 01:55:40,480
there are difference in the results so

01:55:37,679 --> 01:55:40,960
having the same flag is a good first

01:55:40,480 --> 01:55:45,760
step

01:55:40,960 --> 01:55:48,880
but the actual comparable implementation

01:55:45,760 --> 01:55:52,320
requires much more thoughts but it's

01:55:48,880 --> 01:55:55,840
really valuable and the

01:55:52,320 --> 01:55:55,840
last slide yeah

01:55:55,920 --> 01:55:59,679
we all agree that having the same

01:55:57,760 --> 01:56:03,440
compiler flags is

01:55:59,679 --> 01:56:05,599
a good thing for users for packages and

01:56:03,440 --> 01:56:07,199
and such yeah time is up that's the last

01:56:05,599 --> 01:56:09,599
slide

01:56:07,199 --> 01:56:10,719
but the implementation may differ we

01:56:09,599 --> 01:56:14,000
need to discuss

01:56:10,719 --> 01:56:16,400
them before or if someone implements

01:56:14,000 --> 01:56:18,159
on the particular two chain use that

01:56:16,400 --> 01:56:19,920
implementation as a reference

01:56:18,159 --> 01:56:21,520
and uh there are a bunch of people who

01:56:19,920 --> 01:56:23,679
helped me

01:56:21,520 --> 01:56:24,719
not saying too much dumb things and i'd

01:56:23,679 --> 01:56:27,040
like to thank them

01:56:24,719 --> 01:56:29,440
here are the names and that's all i may

01:56:27,040 --> 01:56:32,400
have time for a question

01:56:29,440 --> 01:56:33,280
if you have any okay great thank you

01:56:32,400 --> 01:56:36,159
serge

01:56:33,280 --> 01:56:36,159
so oh yeah

01:56:37,119 --> 01:56:41,520
we're sort of out of time i mean we need

01:56:39,440 --> 01:56:43,040
to prepare for the next person any any

01:56:41,520 --> 01:56:44,239
quick questions there is some good

01:56:43,040 --> 01:56:48,159
discussion

01:56:44,239 --> 01:56:48,159
in the uh the chat that we can follow up

01:56:51,199 --> 01:56:54,560
so excellent as ser says it's very

01:56:53,440 --> 01:56:56,159
important

01:56:54,560 --> 01:56:57,920
for security going forward they've been

01:56:56,159 --> 01:56:59,199
you know many more discussions about

01:56:57,920 --> 01:57:01,440
this with the uh

01:56:59,199 --> 01:57:03,360
the whole uh security of applications

01:57:01,440 --> 01:57:04,800
and the software supply chain so

01:57:03,360 --> 01:57:07,040
thanks for this this great work and the

01:57:04,800 --> 01:57:10,000
great work of both communities to

01:57:07,040 --> 01:57:13,119
create the infrastructures to ensure the

01:57:10,000 --> 01:57:15,679
safety and security of all the software

01:57:13,119 --> 01:57:25,840
excellent work good great comparison so

01:57:15,679 --> 01:57:25,840
thanks very much

01:57:35,679 --> 01:57:39,840
sorry so ian are you

01:57:44,800 --> 01:57:53,840
ah here comes

01:58:04,840 --> 01:58:07,840
ian

01:58:15,599 --> 01:58:20,880
ian can you try again i saw your lips

01:58:18,840 --> 01:58:24,400
moving

01:58:20,880 --> 01:58:24,400
i don't think everybody's a good lip

01:58:32,840 --> 01:58:35,840
reader

01:58:39,119 --> 01:58:49,840
and it is not muted

01:58:57,520 --> 01:59:04,560
remember just hold on a second we'll

01:59:00,639 --> 01:59:17,840
have e ian reconnect this is a

01:59:04,560 --> 01:59:17,840
very interesting presentation

02:03:52,960 --> 02:03:57,599
hey sorry everyone we're waiting to see

02:03:55,119 --> 02:03:58,960
if ian could get past some

02:03:57,599 --> 02:04:00,639
technical issues with the

02:03:58,960 --> 02:04:02,480
[Music]

02:04:00,639 --> 02:04:11,840
the big blue button infrastructure at

02:04:02,480 --> 02:04:11,840
the moment

02:05:06,159 --> 02:05:11,360
sorry that we don't have weight music

02:05:07,599 --> 02:05:11,360
but we can't afford the licensing fees

02:05:16,159 --> 02:05:21,840
you can still sing something

02:06:30,000 --> 02:06:45,840
can anybody hear me yay

02:06:52,880 --> 02:06:58,800
and yay welcome thanks for everybody's

02:06:56,840 --> 02:07:02,159
patience

02:06:58,800 --> 02:07:05,199
and thanks for uh the diligence of ian

02:07:02,159 --> 02:07:09,280
and the great effort that

02:07:05,199 --> 02:07:09,280
microsoft's participation in this entire

02:07:10,840 --> 02:07:13,760
community

02:07:12,400 --> 02:07:27,840
are you there ian we heard you for a

02:07:13,760 --> 02:07:27,840
second but then you've disappeared again

02:07:28,800 --> 02:07:31,920
we lose ian again

02:07:34,400 --> 02:07:55,840
see i'm moving the cursor but

02:07:41,840 --> 02:07:55,840
from anybody else here

02:08:03,199 --> 02:08:09,840
okay so what would people like to do we

02:08:06,719 --> 02:08:11,760
actually had this entire track ending

02:08:09,840 --> 02:08:15,119
half an hour earlier we can wait for

02:08:11,760 --> 02:08:15,760
see if ian can work or we can also see

02:08:15,119 --> 02:08:18,880
if

02:08:15,760 --> 02:08:22,320
jose is available and wants to

02:08:18,880 --> 02:08:23,520
give his talk earlier i know that's

02:08:22,320 --> 02:08:25,679
going to confuse people who were

02:08:23,520 --> 02:08:26,320
planning to attend his talk and expect

02:08:25,679 --> 02:08:29,520
it

02:08:26,320 --> 02:08:29,520
in about 20 minutes

02:08:34,800 --> 02:08:37,040
that's

02:08:42,880 --> 02:08:49,520
i mean i'm good with that

02:08:46,079 --> 02:08:53,920
okay you can hear jose

02:08:49,520 --> 02:08:56,079
all right um can folks hear me now

02:08:53,920 --> 02:08:58,000
i think the server seems to be

02:08:56,079 --> 02:09:01,760
recognizing me

02:08:58,000 --> 02:09:01,760
okay yes we can hear you again

02:09:03,599 --> 02:09:08,719
are you still there you

02:09:06,719 --> 02:09:12,159
hello yummy you talked for a little bit

02:09:08,719 --> 02:09:15,920
and then okay it just died again so ian

02:09:12,159 --> 02:09:18,880
so um i guess

02:09:15,920 --> 02:09:21,440
if people are interested we can have

02:09:18,880 --> 02:09:25,199
jose give his presentation now

02:09:21,440 --> 02:09:25,520
and hope that ian that the server issue

02:09:25,199 --> 02:09:30,800
is

02:09:25,520 --> 02:09:30,800
rectified in the next 20 minutes or so

02:09:30,840 --> 02:09:34,159
david um yes what you might like what

02:09:33,199 --> 02:09:37,840
you might like to do

02:09:34,159 --> 02:09:39,119
is actually hold um jose to his time

02:09:37,840 --> 02:09:39,840
slot for anyone who's specifically

02:09:39,119 --> 02:09:41,840
attending

02:09:39,840 --> 02:09:43,199
we actually have an hour spare within

02:09:41,840 --> 02:09:45,679
the actual official program

02:09:43,199 --> 02:09:46,800
at the end here so if ian can't get

02:09:45,679 --> 02:09:49,840
things going now

02:09:46,800 --> 02:09:51,360
he could perhaps give his talk after uh

02:09:49,840 --> 02:09:52,960
yes i mean we can do this either we can

02:09:51,360 --> 02:09:54,800
either have jose start now or we can

02:09:52,960 --> 02:09:57,920
have jose start at the

02:09:54,800 --> 02:09:59,760
half hour and then ian take the as you

02:09:57,920 --> 02:10:02,079
said the the half hour that was

02:09:59,760 --> 02:10:02,079
later

02:10:05,760 --> 02:10:13,040
so people want to take a break for

02:10:10,000 --> 02:10:17,840
20 minutes and we'll start at

02:10:13,040 --> 02:10:17,840
12 at half past the hour

02:10:18,400 --> 02:10:23,040
let's take the break okay that's one

02:10:21,199 --> 02:10:26,400
vote for a break

02:10:23,040 --> 02:10:26,400
i guess we can create instant poll

02:10:27,520 --> 02:10:43,840
that's here that polling technology

02:10:29,119 --> 02:10:43,840
there david

02:11:06,430 --> 02:11:10,229
[Music]

02:11:12,079 --> 02:11:20,239
which is a and which is b yes and

02:11:16,960 --> 02:11:25,840
break now or let's see a is

02:11:20,239 --> 02:11:25,840
take a break now b is to start jose

02:11:31,119 --> 02:11:33,440
okay

02:11:35,199 --> 02:11:38,560
hey it's very very clear that everybody

02:11:36,960 --> 02:11:41,599
wants to take a break now

02:11:38,560 --> 02:11:42,560
so let's take a break and we'll start at

02:11:41,599 --> 02:11:45,760
half past the hour

02:11:42,560 --> 02:11:49,520
for jose's talk and then

02:11:45,760 --> 02:11:53,360
ian will give his presentation at the

02:11:49,520 --> 02:11:56,000
the top of the hour when we have the

02:11:53,360 --> 02:11:56,000
extra time

02:11:58,400 --> 02:12:02,239
thanks david looks like uh the audio is

02:12:00,719 --> 02:12:04,800
staying connected now though

02:12:02,239 --> 02:12:05,360
but i will i'm happy to hold off till 10

02:12:04,800 --> 02:12:07,599
o'clock

02:12:05,360 --> 02:12:08,880
give folks a chance to break and after

02:12:07,599 --> 02:12:20,800
sitting through back-to-back

02:12:08,880 --> 02:12:22,960
presentations earlier

02:12:20,800 --> 02:12:24,480
david do you have the slide deck that

02:12:22,960 --> 02:12:27,360
says we are on a break now

02:12:24,480 --> 02:12:28,880
mostly concerned for the people watching

02:12:27,360 --> 02:12:32,079
on youtube

02:12:28,880 --> 02:12:32,840
no let's see i don't know the default

02:12:32,079 --> 02:12:49,840
deck

02:12:32,840 --> 02:12:49,840
yeah fault okay

02:17:26,840 --> 02:17:29,840
um

02:18:50,840 --> 02:18:53,840
uh

02:19:04,840 --> 02:19:07,840
okay

02:20:14,840 --> 02:20:17,840
uh

02:25:36,840 --> 02:25:39,840
um

02:27:14,000 --> 02:27:18,160
okay so say you're there

02:27:28,840 --> 02:27:31,840
yes

02:27:42,840 --> 02:27:45,840
pspbs

02:27:47,920 --> 02:27:55,200
you know having a file name bpf.pdf

02:27:51,600 --> 02:27:55,200
makes your life much more interesting

02:27:57,600 --> 02:28:01,280
and we always need excitement in these

02:27:59,200 --> 02:28:04,319
boring times yeah

02:28:01,280 --> 02:28:07,359
bpf dot pbf or pdf bpf or

02:28:04,319 --> 02:28:07,359
yeah okay

02:28:07,920 --> 02:28:11,600
okay so let's just wait another couple

02:28:10,000 --> 02:28:13,359
of seconds to

02:28:11,600 --> 02:28:15,040
get to top the hour and welcome

02:28:13,359 --> 02:28:27,840
everybody back from that

02:28:15,040 --> 02:28:27,840
refreshing break

02:28:28,800 --> 02:28:35,600
i want to uh thank jose for his

02:28:32,240 --> 02:28:37,120
great efforts with this i mean gnu tools

02:28:35,600 --> 02:28:38,319
track this year thanks for being a

02:28:37,120 --> 02:28:41,439
moderator thanks for

02:28:38,319 --> 02:28:42,880
helping also leading with the uh tool

02:28:41,439 --> 02:28:46,000
chain mini conference

02:28:42,880 --> 02:28:49,439
which is coming up on friday and uh

02:28:46,000 --> 02:28:50,720
so and then uh also getting helping with

02:28:49,439 --> 02:28:54,000
the moderation so with that

02:28:50,720 --> 02:28:57,040
i'll uh somebody needs no introduction

02:28:54,000 --> 02:28:57,760
so jose martinez is going to talk about

02:28:57,040 --> 02:29:00,319
the

02:28:57,760 --> 02:29:01,280
current support for bpf in the gnu tool

02:29:00,319 --> 02:29:04,800
chain when he

02:29:01,280 --> 02:29:04,800
when his his head is straightened out

02:29:05,280 --> 02:29:12,399
okay thanks very much jose well

02:29:08,720 --> 02:29:14,319
thanks thanks um okay

02:29:12,399 --> 02:29:16,640
i will do my best to not navigate too

02:29:14,319 --> 02:29:19,920
much in this talk because

02:29:16,640 --> 02:29:19,920
this is work stuff so

02:29:20,319 --> 02:29:24,720
okay so first i'm gonna basically go

02:29:23,200 --> 02:29:26,880
very quickly over

02:29:24,720 --> 02:29:29,439
the latest developments that we have

02:29:26,880 --> 02:29:32,640
done on the support for the bpf

02:29:29,439 --> 02:29:33,600
target in the know tool center then i

02:29:32,640 --> 02:29:37,439
will

02:29:33,600 --> 02:29:40,800
build very quickly a case about why

02:29:37,439 --> 02:29:44,080
we absolutely need to generate btf

02:29:40,800 --> 02:29:48,080
from gcc then i will

02:29:44,080 --> 02:29:49,520
propose a change in the gcc internals to

02:29:48,080 --> 02:29:53,280
make this

02:29:49,520 --> 02:29:57,120
visible and acceptable hopefully by the

02:29:53,280 --> 02:30:00,960
gcc maintainers and then if we have time

02:29:57,120 --> 02:30:03,680
i have a last slide that

02:30:00,960 --> 02:30:05,040
well it's about you know using bpf for

02:30:03,680 --> 02:30:05,920
something else and not just in the

02:30:05,040 --> 02:30:09,520
kernel

02:30:05,920 --> 02:30:10,319
all right so ppf bpf i guess everybody

02:30:09,520 --> 02:30:13,920
knows

02:30:10,319 --> 02:30:17,280
it by now but well it is basically an

02:30:13,920 --> 02:30:17,280
internal virtual machine

02:30:17,439 --> 02:30:24,240
it was originally intended for uh

02:30:21,600 --> 02:30:27,439
aiding and specifying uh packet

02:30:24,240 --> 02:30:30,560
filtering schemas in a very flexible way

02:30:27,439 --> 02:30:34,319
and then with the time it's evolved

02:30:30,560 --> 02:30:36,000
into a sort of kitchen sink

02:30:34,319 --> 02:30:37,359
thing in the kernel because it's been

02:30:36,000 --> 02:30:40,880
adopted by

02:30:37,359 --> 02:30:43,200
many kernel subsystems to do

02:30:40,880 --> 02:30:45,200
a lot of different things most of which

02:30:43,200 --> 02:30:48,399
i don't even understand

02:30:45,200 --> 02:30:49,920
but basically what we started this

02:30:48,399 --> 02:30:52,080
project in oracle

02:30:49,920 --> 02:30:54,000
we wanted to add support for this

02:30:52,080 --> 02:30:57,120
spiritual architecture

02:30:54,000 --> 02:30:57,439
in the neutral chain so what you see in

02:30:57,120 --> 02:31:00,160
this

02:30:57,439 --> 02:31:02,160
slide was the plan as it was the last

02:31:00,160 --> 02:31:04,640
year and it is still

02:31:02,160 --> 02:31:05,280
this year basically the first step was

02:31:04,640 --> 02:31:08,640
to add

02:31:05,280 --> 02:31:10,640
um well support for bpf to the tools

02:31:08,640 --> 02:31:13,439
into the different components

02:31:10,640 --> 02:31:16,160
the second phase was to basically to

02:31:13,439 --> 02:31:19,200
make the programs that we generate

02:31:16,160 --> 02:31:22,000
um from gcc and we assembly

02:31:19,200 --> 02:31:25,200
with the assembler um basically

02:31:22,000 --> 02:31:28,319
acceptable by the kernel verifier

02:31:25,200 --> 02:31:29,520
this still needs a bit of work and to

02:31:28,319 --> 02:31:32,399
keep it that way

02:31:29,520 --> 02:31:34,880
because the bpf world is is moving very

02:31:32,399 --> 02:31:37,520
very very fast

02:31:34,880 --> 02:31:38,000
and then the third phase or the third

02:31:37,520 --> 02:31:41,040
point

02:31:38,000 --> 02:31:45,280
was to provide

02:31:41,040 --> 02:31:47,600
development facilities to bpf developers

02:31:45,280 --> 02:31:48,800
um other than just you know like a c

02:31:47,600 --> 02:31:51,280
compiler

02:31:48,800 --> 02:31:53,120
and an assembler because we believe that

02:31:51,280 --> 02:31:56,960
tooling is important for

02:31:53,120 --> 02:31:59,200
you know for quality of life basically

02:31:56,960 --> 02:32:00,560
so what is the current status of all

02:31:59,200 --> 02:32:04,000
this

02:32:00,560 --> 02:32:04,000
uh the port exists

02:32:05,280 --> 02:32:09,600
basically we have a benutil sport which

02:32:08,399 --> 02:32:12,479
has been upstream

02:32:09,600 --> 02:32:15,359
since several months now since august

02:32:12,479 --> 02:32:15,359
02:32:15,680 --> 02:32:19,840
we have a gcc backend in place upstream

02:32:18,800 --> 02:32:23,520
as well

02:32:19,840 --> 02:32:26,560
which is in gcc 10. it was released as

02:32:23,520 --> 02:32:26,560
part of tcc10

02:32:27,359 --> 02:32:35,600
then since a couple of weeks ago

02:32:30,640 --> 02:32:37,840
we also have a gdp port a simulator port

02:32:35,600 --> 02:32:38,880
and also well we have also you know uh

02:32:37,840 --> 02:32:42,399
the jack newport

02:32:38,880 --> 02:32:45,280
description that we

02:32:42,399 --> 02:32:46,240
hope to use in order to run the gcc test

02:32:45,280 --> 02:32:49,600
suite

02:32:46,240 --> 02:32:52,479
on the simulator now uh the binodal

02:32:49,600 --> 02:32:55,200
support is pretty complete

02:32:52,479 --> 02:32:56,080
like we are basically covering the full

02:32:55,200 --> 02:32:59,920
bpf

02:32:56,080 --> 02:33:03,200
instruction set um the gcc support

02:32:59,920 --> 02:33:06,640
is is well i would say it's good as well

02:33:03,200 --> 02:33:09,600
right um

02:33:06,640 --> 02:33:11,040
the gdp port the gdp support is very

02:33:09,600 --> 02:33:14,000
very simple at the moment

02:33:11,040 --> 02:33:14,479
it's very basic what is working right

02:33:14,000 --> 02:33:18,080
now

02:33:14,479 --> 02:33:21,600
is you can load a ppf object

02:33:18,080 --> 02:33:24,080
you can single step on it you can uh

02:33:21,600 --> 02:33:26,560
set breakpoints you can look at the

02:33:24,080 --> 02:33:29,600
value of the registers and change them

02:33:26,560 --> 02:33:32,960
and so on well and get this listing

02:33:29,600 --> 02:33:34,880
of this assembler right

02:33:32,960 --> 02:33:36,880
the simulator which is part of the new

02:33:34,880 --> 02:33:38,640
simulator so that means that it is

02:33:36,880 --> 02:33:41,760
integrated automatically

02:33:38,640 --> 02:33:44,319
with gdb the support is also quite basic

02:33:41,760 --> 02:33:44,319
at the moment

02:33:44,479 --> 02:33:49,840
most of the instructions are supported

02:33:46,960 --> 02:33:53,040
you can use the simulator along with gdp

02:33:49,840 --> 02:33:56,240
in order to actually execute

02:33:53,040 --> 02:33:59,280
the programs and

02:33:56,240 --> 02:34:01,040
the idea is that we will be

02:33:59,280 --> 02:34:03,200
progressively adding

02:34:01,040 --> 02:34:04,399
support for emulating certain kernel

02:34:03,200 --> 02:34:06,800
contexts

02:34:04,399 --> 02:34:08,640
in the simulator like for example

02:34:06,800 --> 02:34:11,439
recognizing different bpf

02:34:08,640 --> 02:34:13,439
programs kind of bpf programs which are

02:34:11,439 --> 02:34:16,560
identified depending on the name of the

02:34:13,439 --> 02:34:19,680
section in the l file where they reside

02:34:16,560 --> 02:34:21,439
and well we want to start progressively

02:34:19,680 --> 02:34:23,840
implementing support for that context so

02:34:21,439 --> 02:34:27,600
for example if you have a bpf firm

02:34:23,840 --> 02:34:30,479
which is hooked into a proof

02:34:27,600 --> 02:34:31,359
probe product for example we will try to

02:34:30,479 --> 02:34:33,359
provide

02:34:31,359 --> 02:34:35,359
your program in the simulator with a

02:34:33,359 --> 02:34:36,560
context that looks like what the bps

02:34:35,359 --> 02:34:40,319
program would

02:34:36,560 --> 02:34:42,000
uh actually expect when running in the

02:34:40,319 --> 02:34:45,600
kernel

02:34:42,000 --> 02:34:49,840
obviously the goal with this is uh

02:34:45,600 --> 02:34:52,960
yes yes different dps program types yes

02:34:49,840 --> 02:34:54,720
and also the kernel helpers right now we

02:34:52,960 --> 02:34:57,439
only support one kernel helper in the

02:34:54,720 --> 02:35:00,000
simulator which is print k

02:34:57,439 --> 02:35:02,399
which we needed first because um the

02:35:00,000 --> 02:35:04,560
test suite in the simulator which exists

02:35:02,399 --> 02:35:05,600
is based on print k just you know to

02:35:04,560 --> 02:35:09,520
verify the

02:35:05,600 --> 02:35:11,840
execution results so that's the idea

02:35:09,520 --> 02:35:12,800
the basic stuff is there so now it's a

02:35:11,840 --> 02:35:16,160
matter of

02:35:12,800 --> 02:35:18,160
adding to it for this we will be well

02:35:16,160 --> 02:35:19,680
this we will talk more about this in

02:35:18,160 --> 02:35:21,840
friday in the

02:35:19,680 --> 02:35:22,720
in the kernel ppf and the micro

02:35:21,840 --> 02:35:26,800
conference

02:35:22,720 --> 02:35:31,520
so i will skip this fast

02:35:26,800 --> 02:35:31,520
um so this is the status of the port now

02:35:31,920 --> 02:35:37,120
um as long as uh

02:35:34,960 --> 02:35:38,720
along with the support for the kernel

02:35:37,120 --> 02:35:41,040
bpf so what

02:35:38,720 --> 02:35:43,200
used to be known as ebps but now is

02:35:41,040 --> 02:35:46,319
known as bpf

02:35:43,200 --> 02:35:48,960
and that's it um we are

02:35:46,319 --> 02:35:52,399
also adding progressively in all the

02:35:48,960 --> 02:35:54,319
tools and components in binution in dcc

02:35:52,399 --> 02:35:55,760
and in the simulator support for

02:35:54,319 --> 02:35:58,560
something that we call

02:35:55,760 --> 02:36:00,160
xppf now the name is not important we

02:35:58,560 --> 02:36:02,399
can change it if you don't like it i

02:36:00,160 --> 02:36:04,160
actually don't care we can call it xpf

02:36:02,399 --> 02:36:06,160
gppf or whatever

02:36:04,160 --> 02:36:09,280
the thing is that this is a sort of an

02:36:06,160 --> 02:36:13,200
experimental bpf which basically

02:36:09,280 --> 02:36:14,720
is like bpf but extended with certain

02:36:13,200 --> 02:36:17,840
constructions

02:36:14,720 --> 02:36:19,439
and which are oriented to remove the

02:36:17,840 --> 02:36:23,520
many many

02:36:19,439 --> 02:36:26,240
limitations that ppf as in architecture

02:36:23,520 --> 02:36:28,319
has so bpf is not just a virtual

02:36:26,240 --> 02:36:31,840
architecture it's an architecture that

02:36:28,319 --> 02:36:34,319
is has been designed to uh to

02:36:31,840 --> 02:36:36,560
to to run programs which which run in

02:36:34,319 --> 02:36:39,439
the kernel in the kernel context

02:36:36,560 --> 02:36:40,479
which imposes a security concern so

02:36:39,439 --> 02:36:44,880
that's the reason why

02:36:40,479 --> 02:36:49,120
the bpf architecture is extremely

02:36:44,880 --> 02:36:51,200
restricted so with xpf we are lifting

02:36:49,120 --> 02:36:55,280
some of those restrictions

02:36:51,200 --> 02:36:56,640
currently um we have two extensions in

02:36:55,280 --> 02:36:59,840
place in both compilers

02:36:56,640 --> 02:37:00,880
compiler and binutils which is well the

02:36:59,840 --> 02:37:03,359
safe restore

02:37:00,880 --> 02:37:05,120
called safe users used registers which

02:37:03,359 --> 02:37:07,120
actually came to a surprise to me

02:37:05,120 --> 02:37:09,200
to learn that the kernel actually the

02:37:07,120 --> 02:37:11,680
verifier rejects programs because

02:37:09,200 --> 02:37:12,560
well for several reasons if you actually

02:37:11,680 --> 02:37:16,080
do the safe

02:37:12,560 --> 02:37:18,479
and restore of those registers and also

02:37:16,080 --> 02:37:21,520
we support indirect calls

02:37:18,479 --> 02:37:23,920
well the main purpose of having xppf

02:37:21,520 --> 02:37:26,560
is that it's the only way that we can

02:37:23,920 --> 02:37:29,760
actually use the gcc test suite

02:37:26,560 --> 02:37:32,640
in order to to test

02:37:29,760 --> 02:37:33,040
the port because right now there are

02:37:32,640 --> 02:37:35,760
like

02:37:33,040 --> 02:37:37,040
literally thousands of tests that will

02:37:35,760 --> 02:37:39,600
not even compile

02:37:37,040 --> 02:37:40,560
in gcc because they require indirect

02:37:39,600 --> 02:37:42,720
calls or

02:37:40,560 --> 02:37:44,479
they require bigger stack frames or

02:37:42,720 --> 02:37:46,399
whatever okay here

02:37:44,479 --> 02:37:47,920
you can see a little list of you know of

02:37:46,399 --> 02:37:50,720
common extensions

02:37:47,920 --> 02:37:51,040
that we will be adding progressively in

02:37:50,720 --> 02:37:54,399
this

02:37:51,040 --> 02:37:55,040
xpf thing so the purpose is compiler

02:37:54,399 --> 02:37:58,560
testing

02:37:55,040 --> 02:38:00,479
first and foremost also bpf debugging

02:37:58,560 --> 02:38:01,920
because we will see well we will see no

02:38:00,479 --> 02:38:06,160
there is no time for that but

02:38:01,920 --> 02:38:09,680
um with xvpf we also plan to support

02:38:06,160 --> 02:38:10,560
things like dwarf and so you can use

02:38:09,680 --> 02:38:14,399
actually

02:38:10,560 --> 02:38:16,479
gdb to to get back traces

02:38:14,399 --> 02:38:17,920
to go up and down you know in the bpf to

02:38:16,479 --> 02:38:20,160
bpf calls uh

02:38:17,920 --> 02:38:24,240
stack and for that you will get your

02:38:20,160 --> 02:38:25,920
ebpf program you will compile it as xppf

02:38:24,240 --> 02:38:27,280
and then you will run it in the

02:38:25,920 --> 02:38:29,200
simulator and you

02:38:27,280 --> 02:38:31,040
hopefully you will be able to debug it

02:38:29,200 --> 02:38:33,120
you know more easily

02:38:31,040 --> 02:38:34,160
right and also the last point here is

02:38:33,120 --> 02:38:36,160
the user land that

02:38:34,160 --> 02:38:38,319
if we have time this will be in the last

02:38:36,160 --> 02:38:42,479
slide

02:38:38,319 --> 02:38:43,520
so um after we got all those pieces in

02:38:42,479 --> 02:38:46,319
place

02:38:43,520 --> 02:38:48,880
now what we are working on currently is

02:38:46,319 --> 02:38:51,439
to support btf what is btf btf

02:38:48,880 --> 02:38:52,960
is the debugging format which is used by

02:38:51,439 --> 02:38:55,120
ebps

02:38:52,960 --> 02:38:57,520
okay it's similar to cdf actually they

02:38:55,120 --> 02:39:01,600
have a common ancestor

02:38:57,520 --> 02:39:04,800
and this is the point here

02:39:01,600 --> 02:39:08,080
when you use the gcc to generate

02:39:04,800 --> 02:39:12,479
to compile a bpf program

02:39:08,080 --> 02:39:15,280
minus g should generate ptf not turf

02:39:12,479 --> 02:39:15,920
why because btf is instrumental to the

02:39:15,280 --> 02:39:18,720
mechanism

02:39:15,920 --> 02:39:19,600
for the mechanism that the kernel people

02:39:18,720 --> 02:39:22,800
are using

02:39:19,600 --> 02:39:26,240
in order to achieve portable

02:39:22,800 --> 02:39:29,200
bpf programs this thing is called

02:39:26,240 --> 02:39:30,000
core for compile ones run everywhere and

02:39:29,200 --> 02:39:32,880
i tried in this

02:39:30,000 --> 02:39:33,920
slide to provide you know like a simple

02:39:32,880 --> 02:39:36,080
view of

02:39:33,920 --> 02:39:37,200
what it does well basically the program

02:39:36,080 --> 02:39:39,920
the problem

02:39:37,200 --> 02:39:41,280
this is very simplistic you know because

02:39:39,920 --> 02:39:41,840
i don't even know all the details of

02:39:41,280 --> 02:39:44,319
this so

02:39:41,840 --> 02:39:45,280
my apologies if something is not correct

02:39:44,319 --> 02:39:48,560
but this is

02:39:45,280 --> 02:39:52,080
at least how i understand it basically

02:39:48,560 --> 02:39:54,479
um the problem with with portable bpf

02:39:52,080 --> 02:39:56,960
is that if you have a c program that you

02:39:54,479 --> 02:39:59,680
want to build into a bpf

02:39:56,960 --> 02:40:00,880
wpf object and run it in running in some

02:39:59,680 --> 02:40:03,920
kernel

02:40:00,880 --> 02:40:04,960
um this bpf program usually uses kernel

02:40:03,920 --> 02:40:07,120
headers

02:40:04,960 --> 02:40:08,080
in order to access to some data

02:40:07,120 --> 02:40:10,880
structures

02:40:08,080 --> 02:40:11,680
in the kernel now the thing is that of

02:40:10,880 --> 02:40:14,800
course

02:40:11,680 --> 02:40:16,960
what he does to use right because if you

02:40:14,800 --> 02:40:17,680
build your bpf program in an environment

02:40:16,960 --> 02:40:19,760
having

02:40:17,680 --> 02:40:22,160
the headers for some specific kernel

02:40:19,760 --> 02:40:24,800
version then

02:40:22,160 --> 02:40:25,680
obviously if you run it in a different

02:40:24,800 --> 02:40:27,600
kernel

02:40:25,680 --> 02:40:30,479
where those data structures may be

02:40:27,600 --> 02:40:33,279
different then you have a problem

02:40:30,479 --> 02:40:34,960
now as far as i understand it currently

02:40:33,279 --> 02:40:38,319
or until very recently

02:40:34,960 --> 02:40:39,920
the different bpf based infrastructures

02:40:38,319 --> 02:40:41,520
like bcc and others

02:40:39,920 --> 02:40:43,600
they fix that problem by basically

02:40:41,520 --> 02:40:46,800
distributing um

02:40:43,600 --> 02:40:46,800
i think the dlvm

02:40:47,040 --> 02:40:51,359
bpf port so you basically will

02:40:50,319 --> 02:40:54,160
distribute the c

02:40:51,359 --> 02:40:55,920
code right and then you will recompile

02:40:54,160 --> 02:40:58,560
it on the fly every time

02:40:55,920 --> 02:41:00,240
you wanted to run it in some specific

02:40:58,560 --> 02:41:02,160
system

02:41:00,240 --> 02:41:03,600
but the kernel hackers they came with a

02:41:02,160 --> 02:41:06,080
solution for this

02:41:03,600 --> 02:41:06,800
which is shown in this schema so

02:41:06,080 --> 02:41:08,720
basically

02:41:06,800 --> 02:41:11,120
you generate your bpf program with the c

02:41:08,720 --> 02:41:12,800
compiler and then you generate bpf you

02:41:11,120 --> 02:41:14,000
generate btf

02:41:12,800 --> 02:41:16,000
and then you'll generate some

02:41:14,000 --> 02:41:18,000
relocations which use

02:41:16,000 --> 02:41:19,920
that built into surface index that

02:41:18,000 --> 02:41:23,359
basically in those relocations

02:41:19,920 --> 02:41:26,000
they they they say when you access

02:41:23,359 --> 02:41:26,479
some specific field at some specific

02:41:26,000 --> 02:41:29,359
offset

02:41:26,479 --> 02:41:30,000
in some specific extract from a kernel

02:41:29,359 --> 02:41:32,960
heater

02:41:30,000 --> 02:41:33,760
or that is in the kernel then basically

02:41:32,960 --> 02:41:37,279
you generate

02:41:33,760 --> 02:41:39,520
that information in relocations so

02:41:37,279 --> 02:41:41,120
the bpf loader which is part in the of

02:41:39,520 --> 02:41:42,319
the kernel even though it doesn't run in

02:41:41,120 --> 02:41:45,600
kernel mode

02:41:42,319 --> 02:41:46,399
the bpf loader basically combines that

02:41:45,600 --> 02:41:49,359
information

02:41:46,399 --> 02:41:50,720
so the btf those relocations and also

02:41:49,359 --> 02:41:53,200
the pdf

02:41:50,720 --> 02:41:54,800
of the kernel itself right corresponding

02:41:53,200 --> 02:41:57,200
to the data structures in the kernel

02:41:54,800 --> 02:41:59,439
itself in the system you are running

02:41:57,200 --> 02:42:00,640
then it combines everything and then it

02:41:59,439 --> 02:42:04,399
rewrites

02:42:00,640 --> 02:42:06,880
your bpf program to do the right thing

02:42:04,399 --> 02:42:07,520
to access for example to use the right

02:42:06,880 --> 02:42:10,479
offsets

02:42:07,520 --> 02:42:11,439
right to access those fields this seems

02:42:10,479 --> 02:42:12,960
to work well

02:42:11,439 --> 02:42:14,640
actually it covers cases that are not

02:42:12,960 --> 02:42:16,160
trivial at all like fields which are

02:42:14,640 --> 02:42:19,439
renamed

02:42:16,160 --> 02:42:21,200
also see bitmaps which i

02:42:19,439 --> 02:42:22,720
think personally that it's amazing that

02:42:21,200 --> 02:42:26,160
it works but

02:42:22,720 --> 02:42:27,439
apparently it worked anyway for this to

02:42:26,160 --> 02:42:30,720
actually

02:42:27,439 --> 02:42:34,560
work we need to generate btf and now

02:42:30,720 --> 02:42:38,000
we go we come to what controls gcc

02:42:34,560 --> 02:42:39,920
in particular in llvm

02:42:38,000 --> 02:42:41,920
i learned about this by looking at the

02:42:39,920 --> 02:42:45,120
bpf backend in llvm

02:42:41,920 --> 02:42:46,560
basically part of the ir is the backing

02:42:45,120 --> 02:42:49,840
information

02:42:46,560 --> 02:42:52,560
so then um in the target

02:42:49,840 --> 02:42:54,479
in the vm you can actually extend a

02:42:52,560 --> 02:42:55,760
class which is called the back handle

02:42:54,479 --> 02:42:57,520
base

02:42:55,760 --> 02:42:59,520
to add support for some additional

02:42:57,520 --> 02:43:01,680
format the backing format

02:42:59,520 --> 02:43:02,960
at the moment the vm supports dwarf code

02:43:01,680 --> 02:43:07,040
view and

02:43:02,960 --> 02:43:09,600
btf precisely in gcc the situation is

02:43:07,040 --> 02:43:11,279
completely different in gcc there is

02:43:09,600 --> 02:43:13,120
something which is called the backhoeks

02:43:11,279 --> 02:43:16,960
which is a very old thing

02:43:13,120 --> 02:43:19,920
which are called from many different

02:43:16,960 --> 02:43:20,399
pieces of the compiler all around from

02:43:19,920 --> 02:43:23,359
code

02:43:20,399 --> 02:43:24,319
concerning the tree in the front end yes

02:43:23,359 --> 02:43:26,160
also from

02:43:24,319 --> 02:43:28,160
the back ends when you start a new

02:43:26,160 --> 02:43:31,200
function when you finish a function

02:43:28,160 --> 02:43:34,960
also there are some lto calls to it

02:43:31,200 --> 02:43:36,880
and then um as you can see in this

02:43:34,960 --> 02:43:38,080
slide there are like that they could

02:43:36,880 --> 02:43:40,080
find and count

02:43:38,080 --> 02:43:42,000
like five different implementations of

02:43:40,080 --> 02:43:44,560
those debug hooks

02:43:42,000 --> 02:43:45,279
now last year some months ago we

02:43:44,560 --> 02:43:47,920
submitted

02:43:45,279 --> 02:43:50,080
to gcc upstream support for the ctf

02:43:47,920 --> 02:43:53,120
debugging format

02:43:50,080 --> 02:43:54,319
our first intention was to use the back

02:43:53,120 --> 02:43:56,880
hooks

02:43:54,319 --> 02:43:57,520
because well that's what they are for

02:43:56,880 --> 02:43:59,279
but

02:43:57,520 --> 02:44:01,040
the feedback we got from the gcc

02:43:59,279 --> 02:44:03,040
maintainers was

02:44:01,040 --> 02:44:05,840
that they want to obsolete the back

02:44:03,040 --> 02:44:08,160
hooks

02:44:05,840 --> 02:44:09,920
and then they suggested basically to to

02:44:08,160 --> 02:44:13,680
rely on the dwarf

02:44:09,920 --> 02:44:13,680
information so

02:44:14,000 --> 02:44:21,120
what we understood by that is that uh

02:44:18,080 --> 02:44:23,920
and please correct me if i am wrong

02:44:21,120 --> 02:44:25,600
this goes for the gcc maintainers here

02:44:23,920 --> 02:44:28,960
um

02:44:25,600 --> 02:44:30,160
basically we understood that as a desire

02:44:28,960 --> 02:44:33,120
basically to

02:44:30,160 --> 02:44:34,880
use dwarf in gcc in the compiler as some

02:44:33,120 --> 02:44:37,439
sort of canonical

02:44:34,880 --> 02:44:38,800
form for internal debugging information

02:44:37,439 --> 02:44:42,800
right

02:44:38,800 --> 02:44:46,160
and then um what they would like to see

02:44:42,800 --> 02:44:49,680
is new debugging formats to actually

02:44:46,160 --> 02:44:50,640
hook on the generated dwarf internal

02:44:49,680 --> 02:44:53,760
dwarf

02:44:50,640 --> 02:44:54,240
um instead of all the back hooks which

02:44:53,760 --> 02:44:58,240
all that

02:44:54,240 --> 02:45:01,120
there are genius sources right so

02:44:58,240 --> 02:45:02,000
after thinking about it for a while this

02:45:01,120 --> 02:45:04,319
is what i

02:45:02,000 --> 02:45:06,160
propose this is what we are proposing

02:45:04,319 --> 02:45:06,640
and we are not just proposing it but we

02:45:06,160 --> 02:45:09,120
are

02:45:06,640 --> 02:45:10,399
actually volunteering to actually

02:45:09,120 --> 02:45:13,520
implement it

02:45:10,399 --> 02:45:14,000
if it is okay and you know if it can be

02:45:13,520 --> 02:45:16,399
agreed

02:45:14,000 --> 02:45:17,840
beforehand that this approach is sane or

02:45:16,399 --> 02:45:21,279
it makes any sense

02:45:17,840 --> 02:45:24,399
so it will be two steps

02:45:21,279 --> 02:45:27,840
in the first step basically we will keep

02:45:24,399 --> 02:45:30,960
the all the back hooks obviously because

02:45:27,840 --> 02:45:34,319
there are back ends and using

02:45:30,960 --> 02:45:38,640
uh well the x-cov you know

02:45:34,319 --> 02:45:41,920
the the vms debug out and so on

02:45:38,640 --> 02:45:43,680
and then basically we will be creating

02:45:41,920 --> 02:45:47,200
in dorf2 out

02:45:43,680 --> 02:45:50,000
we will be creating a new

02:45:47,200 --> 02:45:50,720
set of of the back hooks which will be

02:45:50,000 --> 02:45:53,680
basically

02:45:50,720 --> 02:45:54,840
invoked from the walk on the internal

02:45:53,680 --> 02:45:57,920
debugging

02:45:54,840 --> 02:46:02,080
representation that is actually

02:45:57,920 --> 02:46:02,080
already performed to generic turf

02:46:03,920 --> 02:46:11,520
and then we will be adding support for

02:46:07,120 --> 02:46:14,479
both btf and ctf to this new set using

02:46:11,520 --> 02:46:16,640
this new set of the back hooks

02:46:14,479 --> 02:46:18,080
assuming that this works properly and

02:46:16,640 --> 02:46:19,680
assuming that in the future

02:46:18,080 --> 02:46:22,840
progressively we can actually

02:46:19,680 --> 02:46:25,279
obsolete or rewrite or transform the

02:46:22,840 --> 02:46:28,399
other

02:46:25,279 --> 02:46:30,960
the clients for the all the back hooks

02:46:28,399 --> 02:46:32,319
then we will this is what we will

02:46:30,960 --> 02:46:35,600
basically propose

02:46:32,319 --> 02:46:36,720
uh at this point which is that at that

02:46:35,600 --> 02:46:38,880
point

02:46:36,720 --> 02:46:41,359
the all the back hooks will be replaced

02:46:38,880 --> 02:46:41,920
by what is today the door to out

02:46:41,359 --> 02:46:44,880
probably

02:46:41,920 --> 02:46:47,200
renaming the dwarf to out blah blah to

02:46:44,880 --> 02:46:50,479
the back underscore blah blah

02:46:47,200 --> 02:46:50,960
and to turn the new the back hooks into

02:46:50,479 --> 02:46:53,920
the

02:46:50,960 --> 02:46:55,279
let's say official the back hooks right

02:46:53,920 --> 02:46:59,520
and then

02:46:55,279 --> 02:47:01,600
to port what is not obsolete

02:46:59,520 --> 02:47:02,880
to use the new set of the back hooks i

02:47:01,600 --> 02:47:05,600
use this gold amp

02:47:02,880 --> 02:47:06,479
here as an example because i don't know

02:47:05,600 --> 02:47:08,560
exactly

02:47:06,479 --> 02:47:10,160
all the the details of what the gold amp

02:47:08,560 --> 02:47:12,160
actually dumps

02:47:10,160 --> 02:47:13,760
but probably it's still needed so it's

02:47:12,160 --> 02:47:16,000
not something that we can obsolete so we

02:47:13,760 --> 02:47:18,640
will need basically to rewrite it

02:47:16,000 --> 02:47:19,680
to use uh to use this new set of the

02:47:18,640 --> 02:47:22,080
back hooks

02:47:19,680 --> 02:47:23,120
now well the last step is that hopefully

02:47:22,080 --> 02:47:26,479
this will make

02:47:23,120 --> 02:47:29,520
everybody happy right

02:47:26,479 --> 02:47:36,080
okay yeah dbx out dropped

02:47:29,520 --> 02:47:39,200
i like that let's drop it okay um

02:47:36,080 --> 02:47:42,240
oops now

02:47:39,200 --> 02:47:44,319
there is one concern that we have

02:47:42,240 --> 02:47:46,160
and with we you know i mean you know

02:47:44,319 --> 02:47:46,960
this little oracle world that we have

02:47:46,160 --> 02:47:48,640
here

02:47:46,960 --> 02:47:50,640
and as you have observed in the last

02:47:48,640 --> 02:47:52,160
months we are very concerned about ctf

02:47:50,640 --> 02:47:56,800
and btf

02:47:52,160 --> 02:48:00,560
is this this this coming back here right

02:47:56,800 --> 02:48:03,359
the thing is dwarf

02:48:00,560 --> 02:48:04,080
it's good for almost uh well for a lot

02:48:03,359 --> 02:48:07,840
of things

02:48:04,080 --> 02:48:12,160
right so we can expect that

02:48:07,840 --> 02:48:14,720
any application um

02:48:12,160 --> 02:48:15,600
which would need uh debugging

02:48:14,720 --> 02:48:17,840
information

02:48:15,600 --> 02:48:20,479
the same amount and kind of the backing

02:48:17,840 --> 02:48:23,760
information that dorf provides

02:48:20,479 --> 02:48:27,600
we can assume that it will use dwarf

02:48:23,760 --> 02:48:31,120
right um however

02:48:27,600 --> 02:48:32,960
well it follows that the new debugging

02:48:31,120 --> 02:48:37,439
formats

02:48:32,960 --> 02:48:40,080
that are arising which are not dwarf

02:48:37,439 --> 02:48:42,160
it follows that it looks like those new

02:48:40,080 --> 02:48:45,680
debugging formats

02:48:42,160 --> 02:48:47,040
they will be compact because if they

02:48:45,680 --> 02:48:48,640
were not compact

02:48:47,040 --> 02:48:50,800
they would be dwarf i don't know if you

02:48:48,640 --> 02:48:52,399
follow me right i mean

02:48:50,800 --> 02:48:54,160
we can assume that the new debugging

02:48:52,399 --> 02:48:56,840
formats popping around for

02:48:54,160 --> 02:48:58,399
purposes for which dwarf is not

02:48:56,840 --> 02:49:01,439
appropriate

02:48:58,399 --> 02:49:03,279
they will be compact and these races

02:49:01,439 --> 02:49:04,960
oh well that is certainly the case for

02:49:03,279 --> 02:49:07,279
ptf and for ctf

02:49:04,960 --> 02:49:08,160
so this is our concern there should be a

02:49:07,279 --> 02:49:11,200
way

02:49:08,160 --> 02:49:11,200
for those

02:49:11,600 --> 02:49:16,000
back ends here the backing back ends to

02:49:14,560 --> 02:49:18,880
specify

02:49:16,000 --> 02:49:19,520
what uh the backing information to

02:49:18,880 --> 02:49:22,080
generate

02:49:19,520 --> 02:49:23,359
in the internal canonical representation

02:49:22,080 --> 02:49:26,000
so for example

02:49:23,359 --> 02:49:27,200
btf doesn't does not support it doesn't

02:49:26,000 --> 02:49:30,479
does not support

02:49:27,200 --> 02:49:31,840
uh frame information so at the end of

02:49:30,479 --> 02:49:33,279
the day there is no need to generate

02:49:31,840 --> 02:49:35,359
that frame information

02:49:33,279 --> 02:49:36,479
if this is the only application for it

02:49:35,359 --> 02:49:38,720
right

02:49:36,479 --> 02:49:40,479
and so on we are concerned about this

02:49:38,720 --> 02:49:41,279
because one of the advantages of ctf and

02:49:40,479 --> 02:49:43,840
btf

02:49:41,279 --> 02:49:45,439
is that they achieve a lot of of

02:49:43,840 --> 02:49:47,200
compactness compared to dwarf

02:49:45,439 --> 02:49:51,040
so this is something that will have to

02:49:47,200 --> 02:49:51,040
be taken into account

02:49:53,600 --> 02:50:00,399
so this is the plan and

02:49:56,800 --> 02:50:02,319
any comment from any gcc people

02:50:00,399 --> 02:50:04,720
do you think this makes sense it doesn't

02:50:02,319 --> 02:50:06,160
make sense

02:50:04,720 --> 02:50:09,840
i'm not talking about the details but

02:50:06,160 --> 02:50:09,840
the general approach

02:50:12,319 --> 02:50:16,000
okay well um

02:50:17,040 --> 02:50:20,399
this is something that we will be

02:50:18,720 --> 02:50:21,439
discussing probably in the main list

02:50:20,399 --> 02:50:25,760
anyway

02:50:21,439 --> 02:50:29,600
so i have like four four minutes more

02:50:25,760 --> 02:50:29,600
let's go to something that is more fun

02:50:30,560 --> 02:50:35,439
i say that xvpf is basically mainly

02:50:33,840 --> 02:50:40,160
intended to be used for

02:50:35,439 --> 02:50:40,160
testing the port properly however

02:50:40,720 --> 02:50:45,040
by lifting some of the restrictions of

02:50:42,399 --> 02:50:47,040
vpf what we basically achieve

02:50:45,040 --> 02:50:49,359
is that we have a virtualized

02:50:47,040 --> 02:50:53,279
architecture

02:50:49,359 --> 02:50:56,640
um in gcc supported in the tool center

02:50:53,279 --> 02:50:59,680
that is designed to be cheated uh

02:50:56,640 --> 02:51:00,800
very efficiently and that is something

02:50:59,680 --> 02:51:04,800
that i think that

02:51:00,800 --> 02:51:06,479
we could be able to um

02:51:04,800 --> 02:51:09,200
we could be able to use for other

02:51:06,479 --> 02:51:11,520
purposes in the usa land

02:51:09,200 --> 02:51:13,439
and this is one example the infinity

02:51:11,520 --> 02:51:14,560
notes project which is an amazing

02:51:13,439 --> 02:51:18,240
project

02:51:14,560 --> 02:51:20,880
well uh you know it's about

02:51:18,240 --> 02:51:22,240
having programs embedded in sections in

02:51:20,880 --> 02:51:24,160
the elf file

02:51:22,240 --> 02:51:25,600
to provide introspection that's one of

02:51:24,160 --> 02:51:28,720
the applications on it

02:51:25,600 --> 02:51:32,880
like replacing the lib db relief 3db

02:51:28,720 --> 02:51:35,920
for example and it seems to me

02:51:32,880 --> 02:51:39,760
that uh if we will

02:51:35,920 --> 02:51:41,920
mix bpf and infinity

02:51:39,760 --> 02:51:42,960
because those are the three components

02:51:41,920 --> 02:51:45,040
of infinity

02:51:42,960 --> 02:51:46,240
you have the node compiler you have the

02:51:45,040 --> 02:51:47,760
no testing framework

02:51:46,240 --> 02:51:49,840
and you have a client library that

02:51:47,760 --> 02:51:51,680
basically provides an interpreter a very

02:51:49,840 --> 02:51:54,240
fast and a small interpreter that you

02:51:51,680 --> 02:51:56,560
can embed in other programs like gdp

02:51:54,240 --> 02:51:58,560
so it seems to me that if we will want

02:51:56,560 --> 02:52:01,359
to use bpf for this

02:51:58,560 --> 02:52:02,160
now we have all the most of the of the

02:52:01,359 --> 02:52:04,640
pieces

02:52:02,160 --> 02:52:07,359
already for the node compiler you don't

02:52:04,640 --> 02:52:08,399
need a compiler for in case of infinity

02:52:07,359 --> 02:52:10,880
it uses some

02:52:08,399 --> 02:52:12,880
a super set of dwarf expressions you

02:52:10,880 --> 02:52:15,760
just use dcc

02:52:12,880 --> 02:52:18,399
and you can compile from c for the

02:52:15,760 --> 02:52:20,319
testing framework we have the simulator

02:52:18,399 --> 02:52:21,439
and for the client library we don't have

02:52:20,319 --> 02:52:23,680
this because

02:52:21,439 --> 02:52:24,560
the simulator will be too heavy for this

02:52:23,680 --> 02:52:26,319
and also

02:52:24,560 --> 02:52:28,080
i don't think it will work to build it

02:52:26,319 --> 02:52:29,840
as a library but we

02:52:28,080 --> 02:52:32,399
will definitely at some point write a

02:52:29,840 --> 02:52:37,520
little libex ptf

02:52:32,399 --> 02:52:40,240
providing a very fast interpreter um

02:52:37,520 --> 02:52:42,800
combining this well this is just food

02:52:40,240 --> 02:52:46,479
for thought right um

02:52:42,800 --> 02:52:49,680
we could basically um

02:52:46,479 --> 02:52:51,600
do with bpfs what infinity was basically

02:52:49,680 --> 02:52:53,840
trying to do with turf expressions

02:52:51,600 --> 02:52:56,399
consider tillip c for example in

02:52:53,840 --> 02:52:59,200
gillipsy

02:52:56,399 --> 02:53:00,880
we what will end in the infinity notes

02:52:59,200 --> 02:53:02,960
could be written in c

02:53:00,880 --> 02:53:04,479
and you could use you could include

02:53:02,960 --> 02:53:07,520
directly the ellipse

02:53:04,479 --> 02:53:08,160
headers right so you will not need any

02:53:07,520 --> 02:53:10,800
more

02:53:08,160 --> 02:53:13,359
any kind of pre-processing you know of

02:53:10,800 --> 02:53:15,920
the ellipse here so it will generate

02:53:13,359 --> 02:53:17,760
constants that in turn you include well

02:53:15,920 --> 02:53:18,319
in case of infinite it was in the in

02:53:17,760 --> 02:53:21,600
this

02:53:18,319 --> 02:53:24,960
infinity language for

02:53:21,600 --> 02:53:27,520
and um yeah well it's just an idea

02:53:24,960 --> 02:53:29,680
i think it would be fun and maybe it

02:53:27,520 --> 02:53:31,439
would be even extended to do some other

02:53:29,680 --> 02:53:33,760
stuff for example

02:53:31,439 --> 02:53:35,359
in the lo in the dynamic loader talk

02:53:33,760 --> 02:53:38,560
from yesterday

02:53:35,359 --> 02:53:39,040
i was thinking about well maybe we could

02:53:38,560 --> 02:53:42,319
have

02:53:39,040 --> 02:53:45,359
a bpf program that could actually

02:53:42,319 --> 02:53:48,080
compute the search paths right

02:53:45,359 --> 02:53:48,960
or we could have a bpf program which

02:53:48,080 --> 02:53:52,000
would

02:53:48,960 --> 02:53:53,600
calculate one of those

02:53:52,000 --> 02:53:57,279
examples that some people were talking

02:53:53,600 --> 02:54:00,319
about defining describing the um

02:53:57,279 --> 02:54:02,960
the interface the api

02:54:00,319 --> 02:54:03,920
i don't know but i think that it will be

02:54:02,960 --> 02:54:06,399
interesting to

02:54:03,920 --> 02:54:08,640
to think about things like that we can

02:54:06,399 --> 02:54:09,920
rot user land with bpf in the same way

02:54:08,640 --> 02:54:10,800
that the kernel people are doing with

02:54:09,920 --> 02:54:14,000
the kernel

02:54:10,800 --> 02:54:17,359
you know while roads not fraud let's say

02:54:14,000 --> 02:54:21,840
and reach and um

02:54:17,359 --> 02:54:21,840
and uh and yeah this was it

02:54:26,080 --> 02:54:29,439
great thanks very much jose

02:54:30,000 --> 02:54:33,120
our time is up for this really good

02:54:32,000 --> 02:54:35,359
discussion

02:54:33,120 --> 02:54:36,319
in the chat and people interested in

02:54:35,359 --> 02:54:38,160
this as

02:54:36,319 --> 02:54:39,359
i said we'll continue the discussion

02:54:38,160 --> 02:54:42,479
about the

02:54:39,359 --> 02:54:44,640
transition in the debug generation uh

02:54:42,479 --> 02:54:44,640
yeah

02:54:44,880 --> 02:54:50,080
exciting opportunities exciting

02:54:48,240 --> 02:54:51,600
improving the infrastructure and the

02:54:50,080 --> 02:54:54,160
modernization of the infrastructure in

02:54:51,600 --> 02:54:54,160
gcc

02:54:54,479 --> 02:55:02,399
okay any final questions or

02:54:58,720 --> 02:55:05,040
comments or let's give people back uh

02:55:02,399 --> 02:55:06,960
another four minutes or so and

02:55:05,040 --> 02:55:09,279
transition to ian hopefully we have the

02:55:06,960 --> 02:55:11,520
the audio issues all all solved this

02:55:09,279 --> 02:55:11,520
time

02:55:14,880 --> 02:55:21,439
great ian you there testing my audio

02:55:18,240 --> 02:55:21,840
okay we can i can hear you okay that's

02:55:21,439 --> 02:55:26,240
probably

02:55:21,840 --> 02:55:26,240
start yeah exactly it's very good

02:55:28,000 --> 02:55:32,399
hopefully it stays up this time i

02:55:30,399 --> 02:55:35,200
haven't seen it crash since uh

02:55:32,399 --> 02:55:37,359
before but you never know let's see do i

02:55:35,200 --> 02:55:39,680
have

02:55:37,359 --> 02:55:44,479
i have a laser pointer good folks can

02:55:39,680 --> 02:55:46,080
see my laser pointer it's a virtual

02:55:44,479 --> 02:55:49,200
conference virtual laser pointer

02:55:46,080 --> 02:55:50,990
all good um let's see how i take down

02:55:49,200 --> 02:55:53,760
the pole

02:55:50,990 --> 02:55:55,760
[Music]

02:55:53,760 --> 02:55:59,520
maybe that you're presented you have to

02:55:55,760 --> 02:56:02,800
take the pole

02:55:59,520 --> 02:56:05,359
oh there's a pole here that's a clear

02:56:02,800 --> 02:56:08,160
nope that's not what i wanted clear

02:56:05,359 --> 02:56:08,160
annotations

02:56:09,359 --> 02:56:13,840
the poll results are stuck on my slide

02:56:11,040 --> 02:56:13,840
are they going to stay there

02:56:14,319 --> 02:56:22,160
no that's fine sorry it was the

02:56:19,920 --> 02:56:23,600
vote vote to take a break so anyway

02:56:22,160 --> 02:56:27,840
we've got another three minutes

02:56:23,600 --> 02:56:27,840
to to go so

02:56:29,120 --> 02:56:41,840
i'm going to stay unmuted though because

02:56:30,479 --> 02:56:41,840
i don't want anything to go

02:56:52,960 --> 02:56:56,479
now thank you everybody for uh staying

02:56:54,960 --> 02:56:57,920
late today i don't know

02:56:56,479 --> 02:56:59,920
i know we're all over the world so i'm

02:56:57,920 --> 02:57:01,279
sure for some people this is a bit of a

02:56:59,920 --> 02:57:04,000
stretch

02:57:01,279 --> 02:57:06,840
and i'm here in seattle i'm just getting

02:57:04,000 --> 02:57:09,840
my day started so it's no big deal for

02:57:06,840 --> 02:57:09,840
me

02:57:17,279 --> 02:57:20,840
hopefully the talk will live up to the

02:57:18,800 --> 02:57:23,840
suspense of everybody having to stay

02:57:20,840 --> 02:57:23,840
longer

02:58:31,600 --> 02:58:35,680
okay so we're at the top of the hour now

02:58:35,279 --> 02:58:37,760
and

02:58:35,680 --> 02:58:39,359
uh thanks everybody again as ian said

02:58:37,760 --> 02:58:42,720
for everyone's patience and

02:58:39,359 --> 02:58:43,920
uh thanks even microsoft for their uh

02:58:42,720 --> 02:58:46,000
now you know engagement and

02:58:43,920 --> 02:58:48,960
participation in the gcc community

02:58:46,000 --> 02:58:50,479
you're very welcome to to microsoft with

02:58:48,960 --> 02:58:52,399
everyone it's great that microsoft is

02:58:50,479 --> 02:58:54,640
becoming so much more active in

02:58:52,399 --> 02:58:55,920
open source in general and with a great

02:58:54,640 --> 02:58:59,040
positive attitude

02:58:55,920 --> 02:59:01,040
so uh thanks to ian who's the principal

02:58:59,040 --> 02:59:01,439
software engineer manager at microsoft

02:59:01,040 --> 02:59:04,000
and

02:59:01,439 --> 02:59:05,840
let's hear about the the great work that

02:59:04,000 --> 02:59:07,040
he wants to describe on the

02:59:05,840 --> 02:59:08,880
exploring the profile guided

02:59:07,040 --> 02:59:12,640
optimization linus kernel so

02:59:08,880 --> 02:59:15,600
take it away ian thank you david um

02:59:12,640 --> 02:59:17,200
and uh william i will get a pdf posted i

02:59:15,600 --> 02:59:19,600
apologize for the

02:59:17,200 --> 02:59:20,880
the bad formatting of the powerpoint i

02:59:19,600 --> 02:59:22,479
try to minimize

02:59:20,880 --> 02:59:24,479
the bells and whistles i use to get it

02:59:22,479 --> 02:59:26,960
to display correctly but um

02:59:24,479 --> 02:59:27,520
i'll i'll get a printing printout of it

02:59:26,960 --> 02:59:30,960
so

02:59:27,520 --> 02:59:33,439
everybody uh i'm ian behrman um

02:59:30,960 --> 02:59:34,160
i'm uh the former team lead for the gnu

02:59:33,439 --> 02:59:37,520
linux

02:59:34,160 --> 02:59:40,399
tools team at microsoft and um

02:59:37,520 --> 02:59:41,600
uh i was at tools cauldron last year i

02:59:40,399 --> 02:59:43,600
met a lot of you there

02:59:41,600 --> 02:59:44,640
and i really want to thank you again for

02:59:43,600 --> 02:59:47,200
the warm welcome

02:59:44,640 --> 02:59:48,800
myself and my team had and i'm excited

02:59:47,200 --> 02:59:50,399
to be back this year as a presenter

02:59:48,800 --> 02:59:52,880
talking about profile guided

02:59:50,399 --> 02:59:57,279
optimization of the linux kernel

02:59:52,880 --> 02:59:59,760
um so today i'm just going to go through

02:59:57,279 --> 03:00:00,720
um a little bit about my team uh the

02:59:59,760 --> 03:00:04,000
work that we did

03:00:00,720 --> 03:00:07,040
um how we went about uh generating

03:00:04,000 --> 03:00:09,920
some data on pgo of the kernel and then

03:00:07,040 --> 03:00:12,000
show the results that we got so let's

03:00:09,920 --> 03:00:14,399
get started

03:00:12,000 --> 03:00:15,279
so um as i mentioned i'm the former lead

03:00:14,399 --> 03:00:17,600
for the the

03:00:15,279 --> 03:00:18,720
new linux tools team so this is a small

03:00:17,600 --> 03:00:21,040
team within

03:00:18,720 --> 03:00:22,640
visual studio it's microsoft developer

03:00:21,040 --> 03:00:25,520
tools platform

03:00:22,640 --> 03:00:27,040
and we act as sort of a front-line

03:00:25,520 --> 03:00:29,279
support for folks

03:00:27,040 --> 03:00:31,200
uh developing software for linux or

03:00:29,279 --> 03:00:33,600
developing linux itself

03:00:31,200 --> 03:00:35,279
uh the team is staffed with mostly

03:00:33,600 --> 03:00:38,479
compiler engineers

03:00:35,279 --> 03:00:39,920
but um we

03:00:38,479 --> 03:00:42,080
cover a broad range of tools so

03:00:39,920 --> 03:00:45,600
libraries compilers

03:00:42,080 --> 03:00:47,359
utilities um we work on correctness

03:00:45,600 --> 03:00:49,279
performance security features

03:00:47,359 --> 03:00:52,080
anything that teams within microsoft

03:00:49,279 --> 03:00:53,359
need to get the job done

03:00:52,080 --> 03:00:55,279
we work on a variety of different

03:00:53,359 --> 03:00:56,319
platforms everything from servers to

03:00:55,279 --> 03:00:58,880
clients

03:00:56,319 --> 03:01:00,479
our biggest customer within microsoft is

03:00:58,880 --> 03:01:03,520
the azure cloud group

03:01:00,479 --> 03:01:04,560
and those of you may or may not know at

03:01:03,520 --> 03:01:06,720
any given time

03:01:04,560 --> 03:01:08,160
nowadays about half the instances in

03:01:06,720 --> 03:01:10,080
azure the microsoft cloud

03:01:08,160 --> 03:01:11,600
are actually running linux so linux has

03:01:10,080 --> 03:01:14,399
become very important

03:01:11,600 --> 03:01:14,399
for microsoft

03:01:15,359 --> 03:01:21,600
went too fast um so uh

03:01:18,720 --> 03:01:23,200
as uh folks at microsoft do we had a

03:01:21,600 --> 03:01:24,319
group come to us and say that they were

03:01:23,200 --> 03:01:25,840
developing

03:01:24,319 --> 03:01:27,840
a service it was gonna be running on

03:01:25,840 --> 03:01:29,120
linux and they wanted to know if the

03:01:27,840 --> 03:01:30,720
tools team could help them with

03:01:29,120 --> 03:01:33,840
performance

03:01:30,720 --> 03:01:35,200
um usually when teams come to ask for

03:01:33,840 --> 03:01:36,319
advice on this it's about

03:01:35,200 --> 03:01:39,120
making sure they're setting the right

03:01:36,319 --> 03:01:42,800
compiler flags making sure that they

03:01:39,120 --> 03:01:43,600
are using the right tools that they have

03:01:42,800 --> 03:01:44,880
the right

03:01:43,600 --> 03:01:45,840
profilers in place that they're

03:01:44,880 --> 03:01:47,279
understanding how to measure their

03:01:45,840 --> 03:01:49,680
performance

03:01:47,279 --> 03:01:50,800
um we we brainstormed about how to help

03:01:49,680 --> 03:01:53,439
this particular team

03:01:50,800 --> 03:01:54,319
um we came up with some interesting

03:01:53,439 --> 03:01:55,520
ideas

03:01:54,319 --> 03:01:57,359
around using profile guided

03:01:55,520 --> 03:01:59,520
optimizations

03:01:57,359 --> 03:02:00,479
for this particular customer when their

03:01:59,520 --> 03:02:01,680
service was running they were

03:02:00,479 --> 03:02:02,080
effectively going to be owning the

03:02:01,680 --> 03:02:04,640
entire

03:02:02,080 --> 03:02:06,080
machine or the entire instance and they

03:02:04,640 --> 03:02:07,040
were willing to build their own kernel

03:02:06,080 --> 03:02:10,399
so we thought

03:02:07,040 --> 03:02:12,319
why not just might not recommend not

03:02:10,399 --> 03:02:13,760
only using profile guided optimizations

03:02:12,319 --> 03:02:16,080
for their service

03:02:13,760 --> 03:02:18,479
but also for the underlying operating

03:02:16,080 --> 03:02:18,479
system

03:02:19,200 --> 03:02:24,479
um one of the complications

03:02:22,960 --> 03:02:26,399
though was the customer hadn't written

03:02:24,479 --> 03:02:28,720
the service yet so we had no code

03:02:26,399 --> 03:02:29,520
for them to for us to test with no

03:02:28,720 --> 03:02:32,800
benchmarks

03:02:29,520 --> 03:02:34,240
um that they provided uh to stand in for

03:02:32,800 --> 03:02:35,600
their service so

03:02:34,240 --> 03:02:37,200
we kind of went off on our own and just

03:02:35,600 --> 03:02:39,040
said well let's just look at whether

03:02:37,200 --> 03:02:40,800
pogoizing the linux kernel

03:02:39,040 --> 03:02:42,840
uh can help improve performance of cloud

03:02:40,800 --> 03:02:44,319
applications and that's how we got into

03:02:42,840 --> 03:02:46,800
this

03:02:44,319 --> 03:02:47,680
now before i get uh too far into this i

03:02:46,800 --> 03:02:49,600
want to

03:02:47,680 --> 03:02:51,520
give a little bit of background about

03:02:49,600 --> 03:02:53,600
the work going on here

03:02:51,520 --> 03:02:55,520
so first of all i want to set a baseline

03:02:53,600 --> 03:02:57,680
when i refer to pogo or pgo

03:02:55,520 --> 03:02:59,200
and also link time optimization these

03:02:57,680 --> 03:03:00,000
are two really important technologies

03:02:59,200 --> 03:03:02,240
that i'm sure

03:03:00,000 --> 03:03:03,279
most of the folks here um are very

03:03:02,240 --> 03:03:06,720
familiar with as

03:03:03,279 --> 03:03:09,520
uh contributors and users of gcc but

03:03:06,720 --> 03:03:10,800
i'm sure that uh there are a few folks

03:03:09,520 --> 03:03:12,080
in the audience who aren't as familiar

03:03:10,800 --> 03:03:13,439
with these and so i just want to

03:03:12,080 --> 03:03:15,680
get everybody up to the same level of

03:03:13,439 --> 03:03:17,200
understanding so profile guided

03:03:15,680 --> 03:03:19,760
optimization

03:03:17,200 --> 03:03:21,200
is a way to tell the compiler how to

03:03:19,760 --> 03:03:24,160
optimize your program

03:03:21,200 --> 03:03:25,359
based on its runtime performance this

03:03:24,160 --> 03:03:26,960
could be really important

03:03:25,359 --> 03:03:28,800
because a lot of the code in your

03:03:26,960 --> 03:03:32,000
program isn't what we would call

03:03:28,800 --> 03:03:33,600
hot in fact a lot some of the code may

03:03:32,000 --> 03:03:35,520
never be executed at all in normal

03:03:33,600 --> 03:03:38,960
running of your program for example your

03:03:35,520 --> 03:03:40,000
error handling code profile data can

03:03:38,960 --> 03:03:42,960
help the compiler make

03:03:40,000 --> 03:03:44,080
decisions about different optimizations

03:03:42,960 --> 03:03:46,800
so that code that

03:03:44,080 --> 03:03:47,920
isn't executed often can be made smaller

03:03:46,800 --> 03:03:50,240
and more compact

03:03:47,920 --> 03:03:51,920
and code that is often executed can be

03:03:50,240 --> 03:03:53,359
fully optimized and take up as much

03:03:51,920 --> 03:03:56,560
space as we need

03:03:53,359 --> 03:03:58,560
the compiler can also lay out

03:03:56,560 --> 03:04:00,240
code and data next to each other so if a

03:03:58,560 --> 03:04:01,760
function calls another function or

03:04:00,240 --> 03:04:03,279
data is used at the same time as other

03:04:01,760 --> 03:04:05,760
data

03:04:03,279 --> 03:04:07,600
to help with locality and together these

03:04:05,760 --> 03:04:08,080
optimizations can have a really good

03:04:07,600 --> 03:04:10,640
positive

03:04:08,080 --> 03:04:12,399
effect across the memory hierarchy so

03:04:10,640 --> 03:04:15,680
we're talking less disk i o

03:04:12,399 --> 03:04:17,040
better tlb usage better cash usage

03:04:15,680 --> 03:04:19,359
at the end of the day this is all a

03:04:17,040 --> 03:04:22,800
boost on top of the maximum optimization

03:04:19,359 --> 03:04:24,800
that the compiler traditionally does

03:04:22,800 --> 03:04:26,560
the other optimization that's really

03:04:24,800 --> 03:04:28,080
important here is lto or link time

03:04:26,560 --> 03:04:30,080
optimization

03:04:28,080 --> 03:04:31,359
so those of you familiar with the c plus

03:04:30,080 --> 03:04:33,600
plus compile model

03:04:31,359 --> 03:04:35,040
the compiler is only getting one cpp

03:04:33,600 --> 03:04:36,720
file at a time

03:04:35,040 --> 03:04:38,399
it then compiles that down into an

03:04:36,720 --> 03:04:39,120
object file which then hands off the

03:04:38,399 --> 03:04:41,920
linker

03:04:39,120 --> 03:04:43,200
and the linker then generates code for

03:04:41,920 --> 03:04:47,200
the entire program

03:04:43,200 --> 03:04:50,160
by just stitching together object files

03:04:47,200 --> 03:04:51,279
so to fully unlock the potential of the

03:04:50,160 --> 03:04:53,200
of

03:04:51,279 --> 03:04:54,880
optimization what we really want is to

03:04:53,200 --> 03:04:55,600
allow the compiler to see your entire

03:04:54,880 --> 03:04:57,200
program

03:04:55,600 --> 03:04:59,520
and that's where link time optimization

03:04:57,200 --> 03:05:00,960
comes in if we delay the optimization

03:04:59,520 --> 03:05:03,680
and code generation steps

03:05:00,960 --> 03:05:05,600
until the linker has created or found

03:05:03,680 --> 03:05:08,080
all the contributions to your program

03:05:05,600 --> 03:05:09,520
the compiler can do a much better job of

03:05:08,080 --> 03:05:11,920
getting that whole picture the whole

03:05:09,520 --> 03:05:15,040
program analysis

03:05:11,920 --> 03:05:17,760
and lto and pgo can then work together

03:05:15,040 --> 03:05:19,359
to get really maximum performance for

03:05:17,760 --> 03:05:22,720
your binary

03:05:19,359 --> 03:05:25,040
and to show how this can work in the

03:05:22,720 --> 03:05:27,040
um at least in a benchmark scenario i

03:05:25,040 --> 03:05:27,520
have some numbers here generated by my

03:05:27,040 --> 03:05:30,560
team

03:05:27,520 --> 03:05:34,800
um for spec 2017

03:05:30,560 --> 03:05:36,960
running on arm64 um

03:05:34,800 --> 03:05:38,399
this is respectant and the key that i'd

03:05:36,960 --> 03:05:39,439
like to draw your attention to is the

03:05:38,399 --> 03:05:41,200
geome numbers

03:05:39,439 --> 03:05:43,840
so this is for the rate and this is for

03:05:41,200 --> 03:05:47,920
speed versus or the benchmarks

03:05:43,840 --> 03:05:51,040
and you can see here so we have o2 o3

03:05:47,920 --> 03:05:52,399
lto and lto it's marked fdo here but

03:05:51,040 --> 03:05:53,760
that's the same thing profile guided

03:05:52,399 --> 03:05:54,880
optimizations

03:05:53,760 --> 03:05:56,880
you can see we've got about a five

03:05:54,880 --> 03:05:58,000
percent boost turning on link time

03:05:56,880 --> 03:06:00,160
optimizations

03:05:58,000 --> 03:06:01,680
and nearly another five percent boost

03:06:00,160 --> 03:06:02,720
from turning on profile guided

03:06:01,680 --> 03:06:04,800
optimizations

03:06:02,720 --> 03:06:06,640
and the same thing is repeated over here

03:06:04,800 --> 03:06:09,040
uh when we do speed

03:06:06,640 --> 03:06:11,040
so these uh optimization modes link time

03:06:09,040 --> 03:06:12,640
optimization profile guide optimization

03:06:11,040 --> 03:06:14,479
can just boost the performance of your

03:06:12,640 --> 03:06:16,080
program by just setting a few compiler

03:06:14,479 --> 03:06:18,319
flags

03:06:16,080 --> 03:06:20,560
but we weren't interested in turning

03:06:18,319 --> 03:06:21,760
these features on for an application

03:06:20,560 --> 03:06:24,960
we were interested in turning these

03:06:21,760 --> 03:06:26,560
features on for the linux kernel

03:06:24,960 --> 03:06:29,120
when we looked for some prior art in

03:06:26,560 --> 03:06:30,240
this area we found a couple of papers by

03:06:29,120 --> 03:06:33,680
yuan

03:06:30,240 --> 03:06:36,160
that described sort of an attempt to do

03:06:33,680 --> 03:06:36,160
this work

03:06:36,479 --> 03:06:41,200
the top graph here you can see some data

03:06:38,399 --> 03:06:43,040
published in the first paper from 2014

03:06:41,200 --> 03:06:44,880
um and these are some common cloud

03:06:43,040 --> 03:06:46,000
scenarios running on top of a pogo

03:06:44,880 --> 03:06:47,040
optimized kernel

03:06:46,000 --> 03:06:49,439
and you can see there's some pretty

03:06:47,040 --> 03:06:51,680
decent wins here apache had about a 10

03:06:49,439 --> 03:06:53,200
win some of these other benchmarks are

03:06:51,680 --> 03:06:53,760
kind of in the three to five percent

03:06:53,200 --> 03:06:57,120
range

03:06:53,760 --> 03:06:59,279
that's pretty good down here you can see

03:06:57,120 --> 03:07:00,479
results published in the later 2015

03:06:59,279 --> 03:07:02,240
paper

03:07:00,479 --> 03:07:03,920
and here they claim an average speed up

03:07:02,240 --> 03:07:05,760
of nearly eight percent

03:07:03,920 --> 03:07:07,520
so when we found this data we were

03:07:05,760 --> 03:07:08,720
pretty happy and excited that there was

03:07:07,520 --> 03:07:10,399
something here

03:07:08,720 --> 03:07:12,080
so we use this as inspiration and then

03:07:10,399 --> 03:07:13,680
try to reproduce the results of this

03:07:12,080 --> 03:07:17,120
paper

03:07:13,680 --> 03:07:17,120
let's look into how we did that

03:07:18,240 --> 03:07:23,359
um so this is a basic description of our

03:07:20,640 --> 03:07:26,399
setup uh we used dublin21910

03:07:23,359 --> 03:07:29,279
we used the gcc and libraries and

03:07:26,399 --> 03:07:30,640
kernel that were attached to that build

03:07:29,279 --> 03:07:33,200
of ubuntu

03:07:30,640 --> 03:07:36,479
a hardware was a marble thunder x2 which

03:07:33,200 --> 03:07:36,479
is an arm64 part

03:07:37,680 --> 03:07:41,600
for enabling lto on the kernel we did

03:07:39,680 --> 03:07:42,960
run into some issues remember lto and

03:07:41,600 --> 03:07:44,399
pgo are not

03:07:42,960 --> 03:07:46,640
part of the normal build of the kernel

03:07:44,399 --> 03:07:48,800
they're not being tested and so

03:07:46,640 --> 03:07:50,560
we weren't um expecting everything to

03:07:48,800 --> 03:07:52,640
just go smoothly

03:07:50,560 --> 03:07:54,399
and sure enough when we did lto we ran

03:07:52,640 --> 03:07:56,240
into uh some breakages

03:07:54,399 --> 03:07:57,680
and i want to give a shout out to andy

03:07:56,240 --> 03:07:59,920
clean from intel

03:07:57,680 --> 03:08:01,600
who helped us understand what the issue

03:07:59,920 --> 03:08:03,680
was with lto

03:08:01,600 --> 03:08:04,840
and uh we he was able to find us a patch

03:08:03,680 --> 03:08:08,720
to get lto

03:08:04,840 --> 03:08:10,720
working for pgo we didn't run into any

03:08:08,720 --> 03:08:12,240
particular issues here it was just a

03:08:10,720 --> 03:08:13,279
matter of understanding what was in the

03:08:12,240 --> 03:08:16,560
documentation and

03:08:13,279 --> 03:08:19,680
some trial and error so

03:08:16,560 --> 03:08:22,560
um let's uh take a look then

03:08:19,680 --> 03:08:24,240
at the profile step so we chose to use

03:08:22,560 --> 03:08:26,399
an instrumentation based profiling

03:08:24,240 --> 03:08:28,800
approach to gather our profiles

03:08:26,399 --> 03:08:30,880
for the kernel so this is the step where

03:08:28,800 --> 03:08:33,680
you're going to put instrumentation into

03:08:30,880 --> 03:08:35,279
the kernel you're going to run it or run

03:08:33,680 --> 03:08:37,520
your scenarios i should say

03:08:35,279 --> 03:08:39,279
and then measure the profile of the

03:08:37,520 --> 03:08:42,399
kernel

03:08:39,279 --> 03:08:44,319
as it's running so for the kernel

03:08:42,399 --> 03:08:46,000
we found that it already supports the

03:08:44,319 --> 03:08:47,920
type of profiling we needed to do

03:08:46,000 --> 03:08:49,760
so we just found the profiling flags we

03:08:47,920 --> 03:08:52,800
needed we turned them on

03:08:49,760 --> 03:08:53,840
we built the kernel installed it ran our

03:08:52,800 --> 03:08:56,800
scenarios

03:08:53,840 --> 03:08:58,720
and then collected our um trace files

03:08:56,800 --> 03:09:00,840
out of the kernel debug directory

03:08:58,720 --> 03:09:02,640
not rocket science this part was pretty

03:09:00,840 --> 03:09:04,399
straightforward

03:09:02,640 --> 03:09:06,479
once we had the profiles we're ready to

03:09:04,399 --> 03:09:09,279
feed them back into gcc and build a full

03:09:06,479 --> 03:09:11,200
optimized build of the compiler

03:09:09,279 --> 03:09:12,399
our experience here took a little bit

03:09:11,200 --> 03:09:15,200
more trial and error

03:09:12,399 --> 03:09:16,240
and i just want to call out a step here

03:09:15,200 --> 03:09:17,840
for those of you who might try and

03:09:16,240 --> 03:09:20,000
reproduce this

03:09:17,840 --> 03:09:22,080
so you don't make the same mistake we

03:09:20,000 --> 03:09:23,680
might have done on one particular run

03:09:22,080 --> 03:09:26,080
which is make sure you turn off the

03:09:23,680 --> 03:09:27,279
profiling options before you build your

03:09:26,080 --> 03:09:29,040
optimized kernel

03:09:27,279 --> 03:09:30,800
otherwise your optimize kernel is not

03:09:29,040 --> 03:09:31,359
going to be as optimized as you think it

03:09:30,800 --> 03:09:34,160
is

03:09:31,359 --> 03:09:36,640
so remember turn these off before you

03:09:34,160 --> 03:09:36,640
optimize

03:09:36,720 --> 03:09:40,800
next we need to get the profiles back

03:09:39,600 --> 03:09:43,439
into gcc

03:09:40,800 --> 03:09:44,479
and this part i wouldn't say it was

03:09:43,439 --> 03:09:46,479
tricky but it was a little bit

03:09:44,479 --> 03:09:49,760
cumbersome so gcc expects

03:09:46,479 --> 03:09:52,720
profiles to be in a very specific path

03:09:49,760 --> 03:09:54,640
and um one feature we found really

03:09:52,720 --> 03:09:56,319
helpful was the fact that gcc can

03:09:54,640 --> 03:09:58,080
take profiles in what is called a

03:09:56,319 --> 03:09:58,800
flattened path i don't recall if that

03:09:58,080 --> 03:10:00,080
was

03:09:58,800 --> 03:10:02,239
our term or a term from the

03:10:00,080 --> 03:10:04,239
documentation but what we did is we

03:10:02,239 --> 03:10:05,680
replaced all the slashes in the path

03:10:04,239 --> 03:10:08,000
with these pound signs

03:10:05,680 --> 03:10:09,600
and gcc was able to find the profile

03:10:08,000 --> 03:10:11,600
information without having to

03:10:09,600 --> 03:10:13,920
spread it out across all the kernel

03:10:11,600 --> 03:10:16,319
build directories

03:10:13,920 --> 03:10:16,960
um the next step's pretty easy you just

03:10:16,319 --> 03:10:19,920
turn on

03:10:16,960 --> 03:10:21,359
profile information so f profile uses

03:10:19,920 --> 03:10:22,000
the flag you want to use and you point

03:10:21,359 --> 03:10:24,239
it at

03:10:22,000 --> 03:10:26,960
where it's going to look for the profile

03:10:24,239 --> 03:10:29,279
information kind of its root path

03:10:26,960 --> 03:10:31,040
then you build the kernel and you're

03:10:29,279 --> 03:10:32,080
going to probably run into a few issues

03:10:31,040 --> 03:10:34,880
because again

03:10:32,080 --> 03:10:35,920
lto pgo these are not default options

03:10:34,880 --> 03:10:36,319
they're not what people are building

03:10:35,920 --> 03:10:39,279
with

03:10:36,319 --> 03:10:41,120
and sure enough uh when we built arm 64

03:10:39,279 --> 03:10:42,880
kernel we did find one place where

03:10:41,120 --> 03:10:44,160
consuming profile information caused the

03:10:42,880 --> 03:10:46,160
compiler to crash

03:10:44,160 --> 03:10:48,880
but that wasn't going to stop us we

03:10:46,160 --> 03:10:50,880
disabled optimization on that one file

03:10:48,880 --> 03:10:52,319
and we were able to get our build going

03:10:50,880 --> 03:10:55,439
the good news is on

03:10:52,319 --> 03:10:57,840
other targets including x8664

03:10:55,439 --> 03:10:59,279
we didn't hit any issues gcc uh was able

03:10:57,840 --> 03:11:00,960
to consume the profile information and

03:10:59,279 --> 03:11:02,399
build us an optimized build

03:11:00,960 --> 03:11:04,800
so that was that was pretty good we're

03:11:02,399 --> 03:11:08,319
very happy about that

03:11:04,800 --> 03:11:09,680
all right so now we have our optimized

03:11:08,319 --> 03:11:12,720
kernel and we're ready to actually

03:11:09,680 --> 03:11:15,520
do some measuring so the scenario

03:11:12,720 --> 03:11:17,200
uh we focused on um that i'm going to

03:11:15,520 --> 03:11:19,040
present here is redis

03:11:17,200 --> 03:11:21,040
so those of you who aren't familiar with

03:11:19,040 --> 03:11:23,760
redis it's a popular

03:11:21,040 --> 03:11:25,600
database or key storage program that's

03:11:23,760 --> 03:11:27,200
used in cloud applications

03:11:25,600 --> 03:11:28,640
and the fact that it's popular is

03:11:27,200 --> 03:11:30,319
actually one of the reasons

03:11:28,640 --> 03:11:32,800
i had my team go and measure this

03:11:30,319 --> 03:11:33,439
because our usage data in azure says

03:11:32,800 --> 03:11:35,680
that it's

03:11:33,439 --> 03:11:37,439
it's used quite a bit it backs a lot of

03:11:35,680 --> 03:11:38,880
technologies that people rely on

03:11:37,439 --> 03:11:40,720
and we felt that if we could demonstrate

03:11:38,880 --> 03:11:43,760
a win for redis

03:11:40,720 --> 03:11:45,520
it could uh show usage in this uh sort

03:11:43,760 --> 03:11:47,520
of

03:11:45,520 --> 03:11:49,200
potentializing the kernel beyond just

03:11:47,520 --> 03:11:50,720
the customer that had asked us to

03:11:49,200 --> 03:11:52,720
take a look at this or inspired us to

03:11:50,720 --> 03:11:54,319
take a look at this

03:11:52,720 --> 03:11:56,479
um the other nice thing about redis is

03:11:54,319 --> 03:11:59,520
it has a built-in benchmarking system

03:11:56,479 --> 03:12:00,720
so one can run redis benchmark and uh

03:11:59,520 --> 03:12:01,760
you don't need to worry about

03:12:00,720 --> 03:12:03,200
understanding

03:12:01,760 --> 03:12:04,800
uh details about how you're going to

03:12:03,200 --> 03:12:06,080
actually measure the program it already

03:12:04,800 --> 03:12:08,640
has some built-in

03:12:06,080 --> 03:12:10,000
built-in so we can just jump in and go

03:12:08,640 --> 03:12:13,680
learning a lot

03:12:10,000 --> 03:12:14,319
um so what did we get when we ran redis

03:12:13,680 --> 03:12:16,319
so let me

03:12:14,319 --> 03:12:17,600
show the data this is what everybody's

03:12:16,319 --> 03:12:19,680
here to see

03:12:17,600 --> 03:12:21,359
so um here's a graph of the sub

03:12:19,680 --> 03:12:22,800
benchmarks within redis

03:12:21,359 --> 03:12:24,880
each one of these represents a

03:12:22,800 --> 03:12:26,319
particular operation sort of how many

03:12:24,880 --> 03:12:27,760
times per second it can

03:12:26,319 --> 03:12:30,880
put something in the database take it

03:12:27,760 --> 03:12:34,160
out or do another operation

03:12:30,880 --> 03:12:36,640
we ran uh the stock kernel five three

03:12:34,160 --> 03:12:37,520
we ran the kernel built with o3 and we

03:12:36,640 --> 03:12:41,040
ran the kernel

03:12:37,520 --> 03:12:42,800
uh with pogo and lto

03:12:41,040 --> 03:12:44,479
the all the numbers are normalized

03:12:42,800 --> 03:12:46,239
against the baseline kernel and you can

03:12:44,479 --> 03:12:49,520
see this black line here represents

03:12:46,239 --> 03:12:51,359
our uh baseline first thing i'll point

03:12:49,520 --> 03:12:53,920
out is that when we built with o3

03:12:51,359 --> 03:12:55,439
we saw degradation and performance so

03:12:53,920 --> 03:12:57,840
that's the kernel built with o3 not

03:12:55,439 --> 03:12:57,840
redis

03:12:59,040 --> 03:13:02,800
one can speculate why that might be um i

03:13:01,439 --> 03:13:04,720
think one easy place to

03:13:02,800 --> 03:13:06,720
a conclusion to jump to without any you

03:13:04,720 --> 03:13:07,840
know supporting evidence is that o3 is

03:13:06,720 --> 03:13:09,760
going to generally make things

03:13:07,840 --> 03:13:11,600
bigger and when you're dealing with an

03:13:09,760 --> 03:13:14,640
operating system with lots of

03:13:11,600 --> 03:13:16,239
um data lots of code that isn't

03:13:14,640 --> 03:13:17,920
necessarily being loaded

03:13:16,239 --> 03:13:19,279
building everything with o3 is not going

03:13:17,920 --> 03:13:20,720
to give you a performance boost

03:13:19,279 --> 03:13:22,800
necessarily

03:13:20,720 --> 03:13:24,640
the third bar in each group the red bar

03:13:22,800 --> 03:13:26,080
that represents the pogo data and you

03:13:24,640 --> 03:13:27,760
can see we got a clear win when we

03:13:26,080 --> 03:13:30,160
enabled profile information across the

03:13:27,760 --> 03:13:31,920
board in all these sub benchmarks

03:13:30,160 --> 03:13:33,439
um so this is pretty good you know we

03:13:31,920 --> 03:13:34,399
got an average probably about two to

03:13:33,439 --> 03:13:36,880
three percent win

03:13:34,399 --> 03:13:40,319
and that's just from uh pogoizing the

03:13:36,880 --> 03:13:41,600
kernel not pogolizing redis itself

03:13:40,319 --> 03:13:43,250
another thing to keep in mind is the

03:13:41,600 --> 03:13:44,640
redis benchmark um

03:13:43,250 --> 03:13:47,120
[Music]

03:13:44,640 --> 03:13:47,680
doesn't have um a lot of time spent in

03:13:47,120 --> 03:13:49,760
the kernel

03:13:47,680 --> 03:13:51,439
so the fact that optimizing the kernel

03:13:49,760 --> 03:13:52,160
gave us a performance boost was uh

03:13:51,439 --> 03:13:55,279
really happy

03:13:52,160 --> 03:13:56,160
we're really happy to see that um let's

03:13:55,279 --> 03:13:57,920
see oh okay

03:13:56,160 --> 03:13:59,680
so one last thing before i drop off this

03:13:57,920 --> 03:14:01,520
slide is that this is the data from the

03:13:59,680 --> 03:14:04,399
2014 paper

03:14:01,520 --> 03:14:06,000
this is the data from the 2015 paper um

03:14:04,399 --> 03:14:09,760
you can see our numbers kind of lined up

03:14:06,000 --> 03:14:13,359
pretty nicely with the 2014 paper

03:14:09,760 --> 03:14:15,760
2015 paper claimed a 12 win

03:14:13,359 --> 03:14:17,840
and i have a theory as to why it's so

03:14:15,760 --> 03:14:18,640
much larger i believe there was a key in

03:14:17,840 --> 03:14:21,120
line

03:14:18,640 --> 03:14:22,080
that they were getting under pogo um

03:14:21,120 --> 03:14:23,680
that uh

03:14:22,080 --> 03:14:24,800
probably was fixed somebody probably

03:14:23,680 --> 03:14:26,239
forced in line or the code and the

03:14:24,800 --> 03:14:27,840
kernel changed a little bit

03:14:26,239 --> 03:14:30,479
remember our numbers that we gathered

03:14:27,840 --> 03:14:33,439
here uh didn't match the gcc

03:14:30,479 --> 03:14:34,239
and um kernel versions used uh in the

03:14:33,439 --> 03:14:36,840
papers

03:14:34,239 --> 03:14:38,560
so i wouldn't expect exactly the same

03:14:36,840 --> 03:14:41,760
numbers all right great i

03:14:38,560 --> 03:14:43,439
see some questions coming in on um the

03:14:41,760 --> 03:14:46,000
chat i'm going to get to them at the end

03:14:43,439 --> 03:14:47,200
um i should have plenty of time i think

03:14:46,000 --> 03:14:50,800
if i till 10 30

03:14:47,200 --> 03:14:54,479
at 10 25 um because we're just about to

03:14:50,800 --> 03:14:56,560
wrap things up here so conclusion

03:14:54,479 --> 03:14:57,840
we've got some gotta win in redis that

03:14:56,560 --> 03:14:59,359
was enough to

03:14:57,840 --> 03:15:01,279
keep the team positive we're going to

03:14:59,359 --> 03:15:02,640
continue to look more into pogolizing

03:15:01,279 --> 03:15:04,960
the kernel

03:15:02,640 --> 03:15:05,760
one area that we didn't get into yet is

03:15:04,960 --> 03:15:07,279
that

03:15:05,760 --> 03:15:09,279
we'd really like to get a measurement of

03:15:07,279 --> 03:15:10,640
core kernel performance

03:15:09,279 --> 03:15:12,640
and i'm going to take an aside here for

03:15:10,640 --> 03:15:13,439
a minute to talk about uh microsoft

03:15:12,640 --> 03:15:15,439
windows

03:15:13,439 --> 03:15:16,880
now i know uh there may be a bit of a

03:15:15,439 --> 03:15:19,520
yawn here a bit of like

03:15:16,880 --> 03:15:20,000
that's not related but i have a lot of

03:15:19,520 --> 03:15:21,439
experience

03:15:20,000 --> 03:15:23,600
with this and i just want to bring a

03:15:21,439 --> 03:15:26,640
little bit of my experience to the

03:15:23,600 --> 03:15:29,760
gnu linux world so one of the uh

03:15:26,640 --> 03:15:31,120
areas that um windows microsoft windows

03:15:29,760 --> 03:15:34,000
relies on

03:15:31,120 --> 03:15:36,080
is profile guided optimization its

03:15:34,000 --> 03:15:39,840
profile guided optimization in the

03:15:36,080 --> 03:15:40,800
microsoft compiler uh sort of grew up

03:15:39,840 --> 03:15:42,560
with

03:15:40,800 --> 03:15:44,160
pro usage of profile guide optimization

03:15:42,560 --> 03:15:45,920
microsoft windows

03:15:44,160 --> 03:15:48,000
so microsoft windows has what they call

03:15:45,920 --> 03:15:50,319
these performance gates so as code moves

03:15:48,000 --> 03:15:51,840
between branches of performance is

03:15:50,319 --> 03:15:52,720
monitored in these gates and these gates

03:15:51,840 --> 03:15:53,920
measure

03:15:52,720 --> 03:15:55,920
tons of different things but they

03:15:53,920 --> 03:15:58,800
measure things like file i o

03:15:55,920 --> 03:15:59,439
network i o scheduler performance and

03:15:58,800 --> 03:16:00,880
basically

03:15:59,439 --> 03:16:02,720
the performance of many different

03:16:00,880 --> 03:16:05,040
operating system primitives

03:16:02,720 --> 03:16:07,200
and when um they measure with and

03:16:05,040 --> 03:16:09,200
without profile guided optimizations

03:16:07,200 --> 03:16:10,399
profile guided optimizations give them a

03:16:09,200 --> 03:16:12,880
boost on these

03:16:10,399 --> 03:16:14,560
basic operations by about five to twenty

03:16:12,880 --> 03:16:16,239
percent

03:16:14,560 --> 03:16:18,479
now i know that we're talking about

03:16:16,239 --> 03:16:21,600
apples to oranges comparisons here

03:16:18,479 --> 03:16:22,640
but i do think that uh or i would say i

03:16:21,600 --> 03:16:24,399
would like that

03:16:22,640 --> 03:16:25,760
my team or some other folks out there to

03:16:24,399 --> 03:16:28,239
start to gather some data

03:16:25,760 --> 03:16:30,000
on whether or not the same operating

03:16:28,239 --> 03:16:31,920
system sort of

03:16:30,000 --> 03:16:35,520
core functionality can be improved using

03:16:31,920 --> 03:16:37,279
profile guide optimization

03:16:35,520 --> 03:16:38,640
um that takes me to the last point on

03:16:37,279 --> 03:16:40,239
the slide which is that i think a lot of

03:16:38,640 --> 03:16:41,520
compiler devs here will recognize the

03:16:40,239 --> 03:16:43,439
cyclic dependency

03:16:41,520 --> 03:16:44,960
between usage and quality of compiler

03:16:43,439 --> 03:16:46,160
features

03:16:44,960 --> 03:16:48,160
what we found when we looked in the

03:16:46,160 --> 03:16:49,279
compute community is that neither lto

03:16:48,160 --> 03:16:51,120
nor pgo

03:16:49,279 --> 03:16:52,800
are heavily used or i should say as

03:16:51,120 --> 03:16:54,640
heavily used on the linux side as they

03:16:52,800 --> 03:16:56,800
are on the windows side

03:16:54,640 --> 03:16:58,399
so i think that there is a chicken and

03:16:56,800 --> 03:17:00,720
egg problem here of

03:16:58,399 --> 03:17:02,080
folks not necessarily relying on these

03:17:00,720 --> 03:17:03,439
features because they don't feel that

03:17:02,080 --> 03:17:06,239
the value is there

03:17:03,439 --> 03:17:07,920
and then compiler contributors not

03:17:06,239 --> 03:17:09,120
necessarily

03:17:07,920 --> 03:17:10,080
improving those features because they

03:17:09,120 --> 03:17:11,200
don't see a lot of usage in the

03:17:10,080 --> 03:17:13,200
community

03:17:11,200 --> 03:17:14,960
so i would encourage folks on both sides

03:17:13,200 --> 03:17:18,080
both users of gcc

03:17:14,960 --> 03:17:19,279
and the new tools and

03:17:18,080 --> 03:17:21,600
application developers that are

03:17:19,279 --> 03:17:23,279
consuming those tools to work together

03:17:21,600 --> 03:17:24,640
or somebody going first to kind of put a

03:17:23,279 --> 03:17:26,479
little bit of pressure to

03:17:24,640 --> 03:17:28,560
add these things because as i showed

03:17:26,479 --> 03:17:30,239
earlier just enabling them

03:17:28,560 --> 03:17:32,000
can give really good performance wins on

03:17:30,239 --> 03:17:34,479
top of everything else the compiler is

03:17:32,000 --> 03:17:36,239
already doing in common cases

03:17:34,479 --> 03:17:37,680
so if we can improve the quality of the

03:17:36,239 --> 03:17:39,040
optimizations if we can improve the

03:17:37,680 --> 03:17:41,200
debug

03:17:39,040 --> 03:17:42,560
debugability of the output the quality

03:17:41,200 --> 03:17:43,040
of the compiler in those scenarios i

03:17:42,560 --> 03:17:45,279
think

03:17:43,040 --> 03:17:47,279
everything um you know all of our users

03:17:45,279 --> 03:17:48,880
would benefit from that

03:17:47,279 --> 03:17:50,800
all right so that's off my little

03:17:48,880 --> 03:17:54,560
soapbox there about these things

03:17:50,800 --> 03:17:55,920
so let's uh um i'll

03:17:54,560 --> 03:17:58,000
answer a couple questions and kind of

03:17:55,920 --> 03:17:58,880
wrap things up um just before i do i

03:17:58,000 --> 03:18:01,520
just want to give a

03:17:58,880 --> 03:18:02,239
big thank you to my two team members

03:18:01,520 --> 03:18:05,120
roman and

03:18:02,239 --> 03:18:06,560
modi who uh did almost all of the work

03:18:05,120 --> 03:18:08,239
i'm presenting here they're the ones who

03:18:06,560 --> 03:18:09,200
gathered all the data found the

03:18:08,239 --> 03:18:11,439
benchmarks

03:18:09,200 --> 03:18:12,720
um timed everything and did you know

03:18:11,439 --> 03:18:14,239
worked through all the documentation and

03:18:12,720 --> 03:18:15,920
get everything working they did a really

03:18:14,239 --> 03:18:18,399
great job i'm really just

03:18:15,920 --> 03:18:19,920
presenting their work here and then once

03:18:18,399 --> 03:18:22,960
again uh thank you to andy for getting

03:18:19,920 --> 03:18:26,160
us on block on lto

03:18:22,960 --> 03:18:29,200
okay um let's do it

03:18:26,160 --> 03:18:30,640
um so i got some questions in the chat

03:18:29,200 --> 03:18:32,800
nick i guess you probably have a

03:18:30,640 --> 03:18:33,359
question um let's start in the chat

03:18:32,800 --> 03:18:35,120
first

03:18:33,359 --> 03:18:37,040
uh that's that came in first so one

03:18:35,120 --> 03:18:38,160
thing about pogo and spec

03:18:37,040 --> 03:18:40,800
it's one of the benchmarks is

03:18:38,160 --> 03:18:43,840
non-represented trial runs uses

03:18:40,800 --> 03:18:45,359
um yeah that's that's a good point about

03:18:43,840 --> 03:18:48,720
training data michael so michael

03:18:45,359 --> 03:18:50,880
uh points out that um if your training

03:18:48,720 --> 03:18:53,120
data doesn't represent the actual usage

03:18:50,880 --> 03:18:54,640
of profile guided optimizations may not

03:18:53,120 --> 03:18:57,040
give you what you want and

03:18:54,640 --> 03:18:58,239
i have a couple comments there so first

03:18:57,040 --> 03:19:01,120
i would like to emphasize

03:18:58,239 --> 03:19:02,640
that it's really important to have a

03:19:01,120 --> 03:19:03,920
good training data

03:19:02,640 --> 03:19:05,520
whether you're testing a user

03:19:03,920 --> 03:19:06,560
application or a spec benchmark or

03:19:05,520 --> 03:19:08,160
whatever it is that you're you know

03:19:06,560 --> 03:19:10,800
using pogo for

03:19:08,160 --> 03:19:12,239
um one of the ways one can do that so

03:19:10,800 --> 03:19:14,319
when you're using

03:19:12,239 --> 03:19:15,520
instrumentation based profiling as we

03:19:14,319 --> 03:19:17,120
did here for our

03:19:15,520 --> 03:19:18,880
example you have to come up with

03:19:17,120 --> 03:19:21,040
artificial scenarios you need to come up

03:19:18,880 --> 03:19:22,399
like what would a user probably do

03:19:21,040 --> 03:19:24,080
let me run through that and measure

03:19:22,399 --> 03:19:26,000
what's going to happen

03:19:24,080 --> 03:19:27,680
an alternative which is sort of gaining

03:19:26,000 --> 03:19:29,920
steam in the community is sample based

03:19:27,680 --> 03:19:31,600
profiling

03:19:29,920 --> 03:19:33,120
at microsoft we found on the windows

03:19:31,600 --> 03:19:35,040
side we found a lot of customers really

03:19:33,120 --> 03:19:37,600
like sample-based programming because

03:19:35,040 --> 03:19:39,600
they can sample what's going on like in

03:19:37,600 --> 03:19:42,479
their server in real time

03:19:39,600 --> 03:19:43,040
and use that profile information to

03:19:42,479 --> 03:19:46,000
either

03:19:43,040 --> 03:19:47,920
directly give that to the compiler or

03:19:46,000 --> 03:19:50,960
even just to analyze to make sure that

03:19:47,920 --> 03:19:54,080
their home grown

03:19:50,960 --> 03:19:57,439
would call like profile

03:19:54,080 --> 03:19:59,600
sorry their homegrown profiling

03:19:57,439 --> 03:20:02,000
scenarios match what customers are

03:19:59,600 --> 03:20:04,319
actually doing

03:20:02,000 --> 03:20:05,840
um okay is it possible to get pogo

03:20:04,319 --> 03:20:08,000
profile data without the kernel

03:20:05,840 --> 03:20:10,160
configuration using perf

03:20:08,000 --> 03:20:11,279
uh yeah william uh thank you for that

03:20:10,160 --> 03:20:14,720
question i don't

03:20:11,279 --> 03:20:16,880
know the answer to that um i think

03:20:14,720 --> 03:20:19,359
is perfect sample based profile if it is

03:20:16,880 --> 03:20:22,560
um that would be another way to do this

03:20:19,359 --> 03:20:23,200
we um we were just in interested in kind

03:20:22,560 --> 03:20:24,880
of just

03:20:23,200 --> 03:20:26,319
demonstrating that this was possible

03:20:24,880 --> 03:20:27,760
that there was some wins here

03:20:26,319 --> 03:20:29,439
so we didn't want to like figure out

03:20:27,760 --> 03:20:31,680
like in the real world yeah we'd want to

03:20:29,439 --> 03:20:34,560
probably sample the application running

03:20:31,680 --> 03:20:35,920
in real time or maybe in a test uh

03:20:34,560 --> 03:20:37,439
production test environment

03:20:35,920 --> 03:20:39,040
or maybe even a production environment

03:20:37,439 --> 03:20:42,319
and get that data out

03:20:39,040 --> 03:20:44,239
um so yeah so which optimization level

03:20:42,319 --> 03:20:45,840
is pogo 53 used

03:20:44,239 --> 03:20:47,600
i don't have an answer to that you'd

03:20:45,840 --> 03:20:49,200
have to go look in the kernel con

03:20:47,600 --> 03:20:51,359
kernel config files my guess is it's

03:20:49,200 --> 03:20:54,560
probably either o2

03:20:51,359 --> 03:20:57,760
um but um yeah

03:20:54,560 --> 03:20:59,520
i'm not sure uh did you report that icy

03:20:57,760 --> 03:21:02,080
ran into pogo with r64

03:20:59,520 --> 03:21:03,359
alex that's a great question and no it

03:21:02,080 --> 03:21:08,560
did not get reported

03:21:03,359 --> 03:21:08,560
unfortunately yes i know i know i know i

03:21:08,840 --> 03:21:12,960
know

03:21:10,479 --> 03:21:13,520
okay let's see michael says in the spec

03:21:12,960 --> 03:21:15,279
case

03:21:13,520 --> 03:21:17,040
uh is there specific training data to

03:21:15,279 --> 03:21:19,439
use uh yes

03:21:17,040 --> 03:21:21,279
so the spec benchmarks provide uh three

03:21:19,439 --> 03:21:23,840
sets of data for your runs

03:21:21,279 --> 03:21:25,120
uh a test set for kind of validating the

03:21:23,840 --> 03:21:26,000
correctness of the benchmark with your

03:21:25,120 --> 03:21:28,160
compiler

03:21:26,000 --> 03:21:29,359
a train set specifically for doing

03:21:28,160 --> 03:21:31,920
profiling

03:21:29,359 --> 03:21:33,760
of the benchmark and a reference set

03:21:31,920 --> 03:21:36,160
which is meant for running the benchmark

03:21:33,760 --> 03:21:38,319
so when benchmarking with pogo you

03:21:36,160 --> 03:21:40,720
really don't want to

03:21:38,319 --> 03:21:42,960
measure the exact same data set that you

03:21:40,720 --> 03:21:45,840
use to train the compiler

03:21:42,960 --> 03:21:47,520
otherwise you're not getting um you're

03:21:45,840 --> 03:21:49,359
not getting real results like

03:21:47,520 --> 03:21:51,520
if i tell the compiler this branch is

03:21:49,359 --> 03:21:53,200
always taken 100 of the time it will

03:21:51,520 --> 03:21:54,880
optimize it if it's taking 100

03:21:53,200 --> 03:21:57,279
of the time but in the real world if

03:21:54,880 --> 03:21:58,800
it's only taken 80 percent of the time

03:21:57,279 --> 03:22:00,399
you might not get the wins that you

03:21:58,800 --> 03:22:01,439
thought you were gonna get so when

03:22:00,399 --> 03:22:03,359
you're doing the spec

03:22:01,439 --> 03:22:05,120
you train with the train set and then

03:22:03,359 --> 03:22:07,439
you run with the reference set

03:22:05,120 --> 03:22:08,880
and i would and that's what we did in

03:22:07,439 --> 03:22:11,279
that example and you've got about a five

03:22:08,880 --> 03:22:13,120
percent win from doing that

03:22:11,279 --> 03:22:14,560
so ian we should probably let nick ask

03:22:13,120 --> 03:22:16,160
his question not just because by the way

03:22:14,560 --> 03:22:17,279
my michael wasn't asking a question mike

03:22:16,160 --> 03:22:18,960
was saying that there is actually a

03:22:17,279 --> 03:22:22,319
known problem with the spec

03:22:18,960 --> 03:22:26,080
training data for one of the the sets

03:22:22,319 --> 03:22:27,680
nick thank you david yeah go ahead nick

03:22:26,080 --> 03:22:29,359
uh super cool to see other people

03:22:27,680 --> 03:22:32,160
playing with this in the kernel uh

03:22:29,359 --> 03:22:32,479
we've been using lto for a couple years

03:22:32,160 --> 03:22:35,600
now

03:22:32,479 --> 03:22:38,000
in our kernels at google and pgo data

03:22:35,600 --> 03:22:39,200
as well though some of the sample based

03:22:38,000 --> 03:22:42,479
stuff is a little bit newer

03:22:39,200 --> 03:22:43,600
um so we have a talk tomorrow um we'd

03:22:42,479 --> 03:22:45,040
love for you to

03:22:43,600 --> 03:22:48,080
to check it out and ask questions you

03:22:45,040 --> 03:22:49,439
know based on on our presentation

03:22:48,080 --> 03:22:51,200
and we're trying to find anyone else

03:22:49,439 --> 03:22:52,640
who's interested in and finds us work

03:22:51,200 --> 03:22:53,439
valuable and wants to help us try to

03:22:52,640 --> 03:22:56,720
upstream that

03:22:53,439 --> 03:22:58,640
kind of thing yeah the focus of my art

03:22:56,720 --> 03:23:00,080
like kind of the the tail end of our

03:22:58,640 --> 03:23:01,040
talk tomorrow will be like how do we

03:23:00,080 --> 03:23:02,720
upstream

03:23:01,040 --> 03:23:05,359
pieces of these and what makes sense and

03:23:02,720 --> 03:23:06,960
stuff like that that's great nick yeah

03:23:05,359 --> 03:23:08,880
microsoft we're really excited about

03:23:06,960 --> 03:23:10,880
this stuff um

03:23:08,880 --> 03:23:13,120
internally you know our windows users

03:23:10,880 --> 03:23:14,800
are really accustomed to using

03:23:13,120 --> 03:23:16,080
uh link time optimization and profile

03:23:14,800 --> 03:23:17,359
guide documentation so like the first

03:23:16,080 --> 03:23:18,640
thing i ask us is hey

03:23:17,359 --> 03:23:20,080
should we turn this on or we notice

03:23:18,640 --> 03:23:20,880
we're using this package and it's not

03:23:20,080 --> 03:23:23,680
built that way

03:23:20,880 --> 03:23:24,640
should we be adding those features um so

03:23:23,680 --> 03:23:26,720
between those

03:23:24,640 --> 03:23:28,479
requests and security related requests

03:23:26,720 --> 03:23:30,880
those are probably the two biggest

03:23:28,479 --> 03:23:32,399
uh questions we get asked but yeah we're

03:23:30,880 --> 03:23:33,840
definitely interested in and see if we

03:23:32,399 --> 03:23:35,359
can lend a hand there that's great other

03:23:33,840 --> 03:23:39,520
folks are working on this

03:23:35,359 --> 03:23:39,520
cool great talk thanks thank you

03:23:40,080 --> 03:23:44,479
um all right uh so is it pronounced pogo

03:23:43,520 --> 03:23:46,960
or pgo

03:23:44,479 --> 03:23:47,760
i guess it depends on who you ask um i

03:23:46,960 --> 03:23:51,439
use both

03:23:47,760 --> 03:23:55,120
um but uh you know it's also pronounced

03:23:51,439 --> 03:23:56,239
fdo depend uh for some people so

03:23:55,120 --> 03:23:58,399
uh thank you everybody for the

03:23:56,239 --> 03:24:00,239
opportunity to talk here uh yeah

03:23:58,399 --> 03:24:01,600
so the occupied question i mean or

03:24:00,239 --> 03:24:03,840
pointing out that with

03:24:01,600 --> 03:24:05,200
pgo there there are architecture

03:24:03,840 --> 03:24:08,160
specific

03:24:05,200 --> 03:24:10,640
paths now with ifunks other things that

03:24:08,160 --> 03:24:11,840
can make the the profiling inaccurate

03:24:10,640 --> 03:24:15,040
that's one of the things to make sure

03:24:11,840 --> 03:24:18,000
that as one transitions to different

03:24:15,040 --> 03:24:20,080
cpu levels or other things yeah that's

03:24:18,000 --> 03:24:20,720
that's something we saw in firefox for

03:24:20,080 --> 03:24:25,200
instance

03:24:20,720 --> 03:24:27,359
and it's not that that bad but

03:24:25,200 --> 03:24:29,520
maybe there should be some way how to

03:24:27,359 --> 03:24:33,439
work around this and

03:24:29,520 --> 03:24:36,399
pretend during the training build that

03:24:33,439 --> 03:24:36,640
architecture has multiple possibilities

03:24:36,399 --> 03:24:40,000
or

03:24:36,640 --> 03:24:43,439
or something else

03:24:40,000 --> 03:24:45,359
erica um i answer i said joe mario's a

03:24:43,439 --> 03:24:46,800
uh a question about the windows side and

03:24:45,359 --> 03:24:48,160
i'll answer that because i'm probably

03:24:46,800 --> 03:24:51,200
the only person here that can

03:24:48,160 --> 03:24:51,840
um so the way the i don't know how gcc

03:24:51,200 --> 03:24:54,560
implements

03:24:51,840 --> 03:24:55,680
uh pogo and changes in profile accounts

03:24:54,560 --> 03:24:59,040
but on the windows

03:24:55,680 --> 03:25:01,439
compiler side the compiler um

03:24:59,040 --> 03:25:03,200
can uh try and correlate the counts and

03:25:01,439 --> 03:25:06,399
so there's a fuzzy match and if it's

03:25:03,200 --> 03:25:08,880
close enough it will consume the profile

03:25:06,399 --> 03:25:11,200
counts on a function by function basis

03:25:08,880 --> 03:25:12,720
so if function a has good counts it'll

03:25:11,200 --> 03:25:14,319
use those if function b

03:25:12,720 --> 03:25:16,239
thinks these counts don't quite match up

03:25:14,319 --> 03:25:18,319
to what's in that function it will

03:25:16,239 --> 03:25:20,479
compile it as if profile guided

03:25:18,319 --> 03:25:23,040
optimization wasn't provided at all

03:25:20,479 --> 03:25:24,239
so that uh allows developers to continue

03:25:23,040 --> 03:25:25,920
to develop using

03:25:24,239 --> 03:25:27,520
stay at what we call stale profile

03:25:25,920 --> 03:25:30,399
accounts from previous runs

03:25:27,520 --> 03:25:31,200
um and then before you merge your branch

03:25:30,399 --> 03:25:32,960
you need to re

03:25:31,200 --> 03:25:34,319
you know rerun your profile accounts and

03:25:32,960 --> 03:25:35,840
and make sure everything's

03:25:34,319 --> 03:25:37,600
uh up just snuff so that all the

03:25:35,840 --> 03:25:39,040
functions are being built profile guided

03:25:37,600 --> 03:25:43,200
optimizations

03:25:39,040 --> 03:25:44,720
so okay okay great so thanks very much

03:25:43,200 --> 03:25:46,880
ian it's great great work

03:25:44,720 --> 03:25:48,560
really interesting information glad to

03:25:46,880 --> 03:25:51,279
see gcc this

03:25:48,560 --> 03:25:52,800
applied to more parts and used widely

03:25:51,279 --> 03:25:54,560
and as you said

03:25:52,800 --> 03:25:56,239
you can see how to create a more

03:25:54,560 --> 03:25:58,319
virtuous cycle for

03:25:56,239 --> 03:25:59,840
the applications in the linux space and

03:25:58,319 --> 03:26:01,359
the the compiler to work

03:25:59,840 --> 03:26:03,840
better together to improve all of this

03:26:01,359 --> 03:26:05,120
so that the pgo or pogo or however

03:26:03,840 --> 03:26:08,800
people want to pronounce it

03:26:05,120 --> 03:26:12,319
as more more beneficial so again thanks

03:26:08,800 --> 03:26:15,439
ian for that and thanks to jeremy

03:26:12,319 --> 03:26:16,319
and to sarah for helping to run this

03:26:15,439 --> 03:26:19,359
session

03:26:16,319 --> 03:26:20,399
and with that i'll uh thank everybody

03:26:19,359 --> 03:26:23,120
for this uh

03:26:20,399 --> 03:26:23,600
great third day uh you can catch up on

03:26:23,120 --> 03:26:25,200
uh

03:26:23,600 --> 03:26:26,960
youtube for anything that you've missed

03:26:25,200 --> 03:26:29,760
and i look forward to seeing you

03:26:26,960 --> 03:26:30,479
tomorrow for the fourth day of the gnu2

03:26:29,760 --> 03:26:33,279
tools track

03:26:30,479 --> 03:26:34,800
at linux plumbers conference 2020 so

03:26:33,279 --> 03:26:36,239
thanks very much everybody have a good

03:26:34,800 --> 03:26:40,960
afternoon evening

03:26:36,239 --> 03:26:40,960
rest of your morning bedtime whatever

03:26:43,920 --> 03:26:47,840
thank you david

03:37:18,080 --> 03:37:20,160

YouTube URL: https://www.youtube.com/watch?v=EgUTa3vpCuc


