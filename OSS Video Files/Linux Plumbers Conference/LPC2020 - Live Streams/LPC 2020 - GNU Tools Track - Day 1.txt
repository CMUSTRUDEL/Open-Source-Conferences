Title: LPC 2020 - GNU Tools Track - Day 1
Publication date: 2020-08-28
Playlist: LPC2020 - Live Streams
Description: 
	Linux Plumbers Conference 2020
Captions: 
	00:00:04,080 --> 00:00:08,080
hi

00:00:05,440 --> 00:00:09,040
uh yeah welcome everybody thanks for

00:00:08,080 --> 00:00:12,160
joining this

00:00:09,040 --> 00:00:14,799
gbb buff session uh i

00:00:12,160 --> 00:00:15,280
so can i just get a confirmation that

00:00:14,799 --> 00:00:18,160
the

00:00:15,280 --> 00:00:21,199
sound is fine everybody hears me maybe

00:00:18,160 --> 00:00:21,199
in the chat or something like that

00:00:21,680 --> 00:00:24,720
i see people typing so i guess that's

00:00:23,519 --> 00:00:28,640
good

00:00:24,720 --> 00:00:30,640
uh so and maybe one mention

00:00:28,640 --> 00:00:32,239
is and that i think that's valid for

00:00:30,640 --> 00:00:35,520
throughout the conference

00:00:32,239 --> 00:00:38,320
um so it's a bit different to have

00:00:35,520 --> 00:00:39,200
uh yeah my hello it's a bit different to

00:00:38,320 --> 00:00:42,840
have this

00:00:39,200 --> 00:00:45,680
online versus uh in person so

00:00:42,840 --> 00:00:47,440
and especially for buffs we want to have

00:00:45,680 --> 00:00:48,079
as many people participating but it can

00:00:47,440 --> 00:00:50,559
be hard

00:00:48,079 --> 00:00:52,320
when we do this online to you know to

00:00:50,559 --> 00:00:54,719
avoid speaking

00:00:52,320 --> 00:00:56,239
everybody at the same time so how it's

00:00:54,719 --> 00:00:59,760
how we expect it to work is that

00:00:56,239 --> 00:01:02,800
if you want to kind of raise your hand

00:00:59,760 --> 00:01:04,400
i think you can do that through the uh

00:01:02,800 --> 00:01:06,799
the system you can click on your name

00:01:04,400 --> 00:01:08,240
set status and raise hand but that's not

00:01:06,799 --> 00:01:10,080
very visible so what

00:01:08,240 --> 00:01:11,520
we want to do instead is that if you

00:01:10,080 --> 00:01:14,400
want to take a

00:01:11,520 --> 00:01:14,960
turn of speaking you turn your camera on

00:01:14,400 --> 00:01:17,200
and

00:01:14,960 --> 00:01:18,240
whoever's speaking should see you appear

00:01:17,200 --> 00:01:21,360
and they know that

00:01:18,240 --> 00:01:23,920
that's like raising your hand so

00:01:21,360 --> 00:01:25,520
if you want to take something just turn

00:01:23,920 --> 00:01:27,840
your camera on it takes a few seconds

00:01:25,520 --> 00:01:27,840
but

00:01:28,799 --> 00:01:36,799
and yeah since this is a buff

00:01:31,920 --> 00:01:36,799
i don't expect to speak more than

00:01:37,759 --> 00:01:44,399
everybody else so i'll just turn on

00:01:40,880 --> 00:01:44,399
the list of topics

00:01:45,759 --> 00:01:49,920
so you should now see the list of topics

00:01:47,520 --> 00:01:54,399
that i've gathered from

00:01:49,920 --> 00:01:57,200
that people sent me um

00:01:54,399 --> 00:01:58,240
i'll give you a few seconds to to read

00:01:57,200 --> 00:02:00,960
them but

00:01:58,240 --> 00:02:01,680
the goal is that we talk about what you

00:02:00,960 --> 00:02:05,439
want to

00:02:01,680 --> 00:02:07,680
talk about so uh

00:02:05,439 --> 00:02:09,920
if you have anything else to add even if

00:02:07,680 --> 00:02:14,239
if it's not on this list then just

00:02:09,920 --> 00:02:16,480
bring it up we have about 25 minutes and

00:02:14,239 --> 00:02:18,640
the plan is that we can keep talking

00:02:16,480 --> 00:02:20,400
after that

00:02:18,640 --> 00:02:22,560
i know that the presentation right after

00:02:20,400 --> 00:02:25,760
is also dwarf related so anyway

00:02:22,560 --> 00:02:27,360
i'm personally interested but we

00:02:25,760 --> 00:02:29,120
a bit later in the day we can take some

00:02:27,360 --> 00:02:32,239
time and join the hack room

00:02:29,120 --> 00:02:37,440
uh to to to continue

00:02:32,239 --> 00:02:40,400
any discussions

00:02:37,440 --> 00:02:42,959
uh so yeah the list of topics the first

00:02:40,400 --> 00:02:45,440
one moving up gb support and db server

00:02:42,959 --> 00:02:47,120
uh so that's the move that's been done

00:02:45,440 --> 00:02:48,319
maybe in the last year to move it to the

00:02:47,120 --> 00:02:49,760
top level of a repo

00:02:48,319 --> 00:02:51,440
that's something that was led by tom

00:02:49,760 --> 00:02:53,519
chumi uh

00:02:51,440 --> 00:02:57,200
i thought we could have a little update

00:02:53,519 --> 00:03:00,400
but i don't see tom in here so i guess

00:02:57,200 --> 00:03:02,159
it maybe won't be possible but uh yeah

00:03:00,400 --> 00:03:04,159
i'd like to know if there's anything

00:03:02,159 --> 00:03:05,760
left is there any problems

00:03:04,159 --> 00:03:07,519
left to address or is is there anything

00:03:05,760 --> 00:03:09,599
more we want to move for example from

00:03:07,519 --> 00:03:11,360
gdb to gb support so it can

00:03:09,599 --> 00:03:13,120
properly be shared because i know that

00:03:11,360 --> 00:03:17,040
gb server uses

00:03:13,120 --> 00:03:19,280
files from gb to build a topic that

00:03:17,040 --> 00:03:20,159
um jeremy would like to say a few words

00:03:19,280 --> 00:03:22,319
about the

00:03:20,159 --> 00:03:24,400
free or any bsd version of gb server

00:03:22,319 --> 00:03:27,040
they are working on

00:03:24,400 --> 00:03:27,760
uh the next two ones are some small

00:03:27,040 --> 00:03:30,799
cleanups

00:03:27,760 --> 00:03:31,519
that sometimes large clubs i've been

00:03:30,799 --> 00:03:34,879
working on

00:03:31,519 --> 00:03:36,560
i'd like to before i continue if there's

00:03:34,879 --> 00:03:40,879
any

00:03:36,560 --> 00:03:44,560
uh comments on that that'll be the time

00:03:40,879 --> 00:03:47,200
uh joel so we had joel uh brubacher who

00:03:44,560 --> 00:03:48,799
is our release manager he's not there to

00:03:47,200 --> 00:03:49,680
uh currently he'll be there later in the

00:03:48,799 --> 00:03:52,400
day so

00:03:49,680 --> 00:03:53,599
if we have things to talk with him uh we

00:03:52,400 --> 00:03:55,040
can do something in the acronym but

00:03:53,599 --> 00:03:56,560
he wanted to have any feedback on the

00:03:55,040 --> 00:03:57,680
new version number and scheme so we

00:03:56,560 --> 00:04:01,200
aligned our

00:03:57,680 --> 00:04:04,799
since the latest release on rgc does

00:04:01,200 --> 00:04:07,519
learn feedback on that and

00:04:04,799 --> 00:04:08,720
i see that so i see a lot of people i

00:04:07,519 --> 00:04:11,280
know in the room

00:04:08,720 --> 00:04:12,959
contributors and maybe there are in the

00:04:11,280 --> 00:04:15,200
room there's also people who

00:04:12,959 --> 00:04:16,160
plan to start contributing to gdp in the

00:04:15,200 --> 00:04:20,160
future

00:04:16,160 --> 00:04:20,799
so if anybody else is working on some

00:04:20,160 --> 00:04:23,120
big

00:04:20,799 --> 00:04:24,000
feature and you know we like to ask

00:04:23,120 --> 00:04:25,840
questions or

00:04:24,000 --> 00:04:28,160
just say i'm working on this so that we

00:04:25,840 --> 00:04:30,320
can know we know what to expect i think

00:04:28,160 --> 00:04:32,479
it would be interesting to to share and

00:04:30,320 --> 00:04:33,520
you can discuss that and if you have a

00:04:32,479 --> 00:04:34,800
something you'd like to contribute

00:04:33,520 --> 00:04:35,520
either an architecture feature or

00:04:34,800 --> 00:04:38,080
whatever

00:04:35,520 --> 00:04:39,680
if you'd like to if you're not sure

00:04:38,080 --> 00:04:40,960
about how to proceed how to split things

00:04:39,680 --> 00:04:44,720
up what's the right process

00:04:40,960 --> 00:04:46,639
then feel free to ask questions and

00:04:44,720 --> 00:04:47,759
you have a few gb maintainers in the

00:04:46,639 --> 00:04:52,479
room so

00:04:47,759 --> 00:04:52,479
that would be the right time so

00:04:52,800 --> 00:04:56,479
uh i'd like to start by giving jeremy a

00:04:55,440 --> 00:04:58,240
few

00:04:56,479 --> 00:04:59,680
a bit of time to talk about because he

00:04:58,240 --> 00:05:01,680
wanted to talk about this

00:04:59,680 --> 00:05:04,080
freebsd version of tv server they're

00:05:01,680 --> 00:05:07,440
working on so

00:05:04,080 --> 00:05:07,440
i'm curious to hear about that

00:05:08,080 --> 00:05:11,520
thank you um i'm still here so i'm i'm

00:05:10,720 --> 00:05:14,800
here all day

00:05:11,520 --> 00:05:17,120
the um so it was just a flag up

00:05:14,800 --> 00:05:18,880
that because of a project we're working

00:05:17,120 --> 00:05:21,919
on we need to use

00:05:18,880 --> 00:05:24,160
a gdb server under freebsd it's an

00:05:21,919 --> 00:05:25,600
embedded freebsd system

00:05:24,160 --> 00:05:28,800
which is when we discovered that

00:05:25,600 --> 00:05:30,960
somewhere post 2005 gdb server on

00:05:28,800 --> 00:05:34,000
freebsd got broken

00:05:30,960 --> 00:05:34,479
um we have started some work it's a bit

00:05:34,000 --> 00:05:37,600
slow

00:05:34,479 --> 00:05:38,639
on doing a freebsd version of gdb server

00:05:37,600 --> 00:05:40,400
and it's just to say

00:05:38,639 --> 00:05:41,919
i'd be really interested if anyone else

00:05:40,400 --> 00:05:44,320
has got the same problem we can share

00:05:41,919 --> 00:05:44,320
the effort

00:05:49,039 --> 00:05:55,199
and so do you know or

00:05:52,080 --> 00:05:58,479
i've never seen gb server bits for

00:05:55,199 --> 00:06:02,080
previously do you know it was added in

00:05:58,479 --> 00:06:02,080
2005 or removed in 2005

00:06:02,800 --> 00:06:07,440
when when was the last time that it that

00:06:05,919 --> 00:06:10,639
or when were they removed from the tree

00:06:07,440 --> 00:06:12,319
jeff and yeah uh so i i

00:06:10,639 --> 00:06:14,000
i've not been it's mostly andrew burgess

00:06:12,319 --> 00:06:17,919
who's been uh working on this

00:06:14,000 --> 00:06:20,960
um but uh he uh

00:06:17,919 --> 00:06:22,800
he can't be with us today so um i don't

00:06:20,960 --> 00:06:27,039
know he just mentioned to me that

00:06:22,800 --> 00:06:28,960
it was there once uh back in 2005.

00:06:27,039 --> 00:06:30,400
where how it got lost i don't know i

00:06:28,960 --> 00:06:32,000
don't know the history of it

00:06:30,400 --> 00:06:33,680
it's just that we discovered that where

00:06:32,000 --> 00:06:35,840
we wanted it so there certainly isn't

00:06:33,680 --> 00:06:39,520
anything recent that we can build on

00:06:35,840 --> 00:06:41,280
um so we've started the work or i say we

00:06:39,520 --> 00:06:42,800
andrew has started the work of putting

00:06:41,280 --> 00:06:45,280
together a freebsd

00:06:42,800 --> 00:06:45,919
version of gdb server i'm just curious

00:06:45,280 --> 00:06:47,600
to know

00:06:45,919 --> 00:06:49,039
if anyone's interested most people use

00:06:47,600 --> 00:06:50,560
freebsd native

00:06:49,039 --> 00:06:51,919
so it's not an issue it's just that we

00:06:50,560 --> 00:06:53,280
happen to be working with an embedded

00:06:51,919 --> 00:06:56,720
freebsd system

00:06:53,280 --> 00:06:59,680
so we really need a gdp server on it

00:06:56,720 --> 00:07:02,479
um do you happen to be in contact with

00:06:59,680 --> 00:07:05,440
john baldwin

00:07:02,479 --> 00:07:05,440
who's working on

00:07:05,759 --> 00:07:10,160
freebsd at least he contributes a lot to

00:07:08,560 --> 00:07:13,280
gdp

00:07:10,160 --> 00:07:17,280
for freebsd i

00:07:13,280 --> 00:07:19,599
so i say i'm not directly working on it

00:07:17,280 --> 00:07:20,319
that's a good point i will have a chat

00:07:19,599 --> 00:07:23,120
with john

00:07:20,319 --> 00:07:24,880
baldwin yeah uh i'm sure that andrew

00:07:23,120 --> 00:07:26,800
knows about the image since he's

00:07:24,880 --> 00:07:28,479
they're both active on a mailing list so

00:07:26,800 --> 00:07:30,000
but uh

00:07:28,479 --> 00:07:31,520
you know john would be the right person

00:07:30,000 --> 00:07:35,280
to answer any

00:07:31,520 --> 00:07:35,280
previous reality questions

00:07:39,199 --> 00:07:43,039
uh elena is asking helena is asking

00:07:41,280 --> 00:07:44,800
anybody taking notes so

00:07:43,039 --> 00:07:46,639
is there any volunteer i don't think i

00:07:44,800 --> 00:07:49,120
can do that myself while

00:07:46,639 --> 00:07:49,120
trying to

00:07:51,280 --> 00:07:54,800
while i speak so there any volunteer who

00:07:53,680 --> 00:07:59,840
could just

00:07:54,800 --> 00:07:59,840
make a log of what

00:08:09,039 --> 00:08:14,160
so if there isn't any other topic coming

00:08:12,720 --> 00:08:17,120
up

00:08:14,160 --> 00:08:17,120
let's go through the list

00:08:19,039 --> 00:08:22,720
even though tom tommy is not here do we

00:08:21,520 --> 00:08:25,440
have any

00:08:22,720 --> 00:08:26,080
unless you just don't know do you have

00:08:25,440 --> 00:08:29,120
any

00:08:26,080 --> 00:08:32,080
feedback on the move of gb support and

00:08:29,120 --> 00:08:33,039
research the top level uh personally i

00:08:32,080 --> 00:08:35,599
you know i

00:08:33,039 --> 00:08:36,800
i wasn't sure in the beginning but it

00:08:35,599 --> 00:08:39,919
turned out i think to be

00:08:36,800 --> 00:08:42,080
great uh it really showed that the way

00:08:39,919 --> 00:08:44,159
gb server was built before was

00:08:42,080 --> 00:08:45,279
really kind of a hack now it's just one

00:08:44,159 --> 00:08:48,560
program

00:08:45,279 --> 00:08:50,160
like any other in the bin utils gdb3 uh

00:08:48,560 --> 00:08:53,120
there was a bit of

00:08:50,160 --> 00:08:54,000
you know it it shook things so there's a

00:08:53,120 --> 00:08:56,240
few things that

00:08:54,000 --> 00:08:59,360
broke in the beginning but i think for

00:08:56,240 --> 00:09:01,839
the most part it's quite stable

00:08:59,360 --> 00:09:02,800
but is there any else anything else that

00:09:01,839 --> 00:09:05,920
needs to be done

00:09:02,800 --> 00:09:10,000
that anybody knows about

00:09:05,920 --> 00:09:14,720
in this area so historically

00:09:10,000 --> 00:09:18,000
uh gdp server um is very much for

00:09:14,720 --> 00:09:20,560
full operating systems so linux

00:09:18,000 --> 00:09:22,720
hopefully freebsd soon and one or two of

00:09:20,560 --> 00:09:24,720
the larger r tosses

00:09:22,720 --> 00:09:26,640
but there's a whole other class of gdb

00:09:24,720 --> 00:09:29,040
servers which are the bare metal

00:09:26,640 --> 00:09:31,200
rtos so typically people use something

00:09:29,040 --> 00:09:34,399
like openocd for that

00:09:31,200 --> 00:09:36,720
um which is actually gpl licensed

00:09:34,399 --> 00:09:38,959
it's always struck me as a question of

00:09:36,720 --> 00:09:42,560
should we actually have a framework

00:09:38,959 --> 00:09:45,120
for bare metal gdb servers and not just

00:09:42,560 --> 00:09:46,000
full operating system gdb servers and i

00:09:45,120 --> 00:09:48,480
can see the case

00:09:46,000 --> 00:09:49,920
both ways but since we're discussing

00:09:48,480 --> 00:09:52,959
what we should have in the tree i'll

00:09:49,920 --> 00:09:52,959
flag that one up here

00:09:53,760 --> 00:09:57,680
i think that's a good question uh yeah

00:09:56,480 --> 00:10:00,320
you

00:09:57,680 --> 00:10:01,920
probably wouldn't want to run or to

00:10:00,320 --> 00:10:05,120
maybe not use the same program

00:10:01,920 --> 00:10:07,600
for fallout operating systems versus

00:10:05,120 --> 00:10:09,360
uh embedded systems well if we could to

00:10:07,600 --> 00:10:09,839
be great but i don't know how practical

00:10:09,360 --> 00:10:13,040
to be

00:10:09,839 --> 00:10:16,399
uh so yeah the question would be do

00:10:13,040 --> 00:10:16,880
do we want to have a kind of second gb

00:10:16,399 --> 00:10:19,360
server

00:10:16,880 --> 00:10:20,399
that's more like for embedded in the

00:10:19,360 --> 00:10:22,000
tree

00:10:20,399 --> 00:10:23,920
and my question would be so personally

00:10:22,000 --> 00:10:25,519
i've i think it'd be nice i don't have a

00:10:23,920 --> 00:10:29,200
personal need for it

00:10:25,519 --> 00:10:33,040
is is there anything we could start from

00:10:29,200 --> 00:10:34,160
that already exists that people use and

00:10:33,040 --> 00:10:37,200
they would just like to have it

00:10:34,160 --> 00:10:47,360
maintained upstream instead of

00:10:37,200 --> 00:10:48,959
a bit everywhere

00:10:47,360 --> 00:10:51,279
so you mentioned openocd but i think

00:10:48,959 --> 00:10:54,800
openocd is also with

00:10:51,279 --> 00:10:56,800
more for accessing oh that's right it's

00:10:54,800 --> 00:10:59,839
working real targets

00:10:56,800 --> 00:11:01,519
yeah yes so it focuses on real targets

00:10:59,839 --> 00:11:06,160
but it has a gdp server in it

00:11:01,519 --> 00:11:08,000
um okay we have a gdp server we use

00:11:06,160 --> 00:11:09,519
which started out as a teaching exercise

00:11:08,000 --> 00:11:11,760
to explain how to write gdb

00:11:09,519 --> 00:11:14,079
servers so that might be a possible

00:11:11,760 --> 00:11:17,360
basis for an upstream uh

00:11:14,079 --> 00:11:19,600
bare metal gdp server

00:11:17,360 --> 00:11:20,480
there is a slight challenge with bare

00:11:19,600 --> 00:11:24,800
metal

00:11:20,480 --> 00:11:29,440
gdb servers in that

00:11:24,800 --> 00:11:32,160
they the gpl license

00:11:29,440 --> 00:11:33,279
once you start engaging at a low level

00:11:32,160 --> 00:11:34,320
particularly you start engaging with

00:11:33,279 --> 00:11:36,320
simulations

00:11:34,320 --> 00:11:38,320
you start applying the gpl to

00:11:36,320 --> 00:11:41,120
simulations

00:11:38,320 --> 00:11:42,959
and that might mean exposing the actual

00:11:41,120 --> 00:11:46,480
hardware chip design

00:11:42,959 --> 00:11:49,360
and given the way chips are designed

00:11:46,480 --> 00:11:51,440
most people don't have actually

00:11:49,360 --> 00:11:53,760
ownership of the entire ip of their chip

00:11:51,440 --> 00:11:55,920
to be able to do that

00:11:53,760 --> 00:11:57,279
so it may prove that actually it turns

00:11:55,920 --> 00:11:58,639
out to be something that's quite hard to

00:11:57,279 --> 00:12:02,800
do in a meaningful way

00:11:58,639 --> 00:12:02,800
for a gpl licensed tool

00:12:03,279 --> 00:12:09,360
right um although that applies

00:12:06,720 --> 00:12:10,079
to when they actually want to distribute

00:12:09,360 --> 00:12:15,600
it if they

00:12:10,079 --> 00:12:17,600
want to if you just want to use

00:12:15,600 --> 00:12:19,360
use it locally for your own simulator

00:12:17,600 --> 00:12:20,399
and for example because i was thinking

00:12:19,360 --> 00:12:22,240
um

00:12:20,399 --> 00:12:24,000
so kevin mentioned this old project

00:12:22,240 --> 00:12:27,519
called rda which is the remote

00:12:24,000 --> 00:12:30,880
debugger agent

00:12:27,519 --> 00:12:32,240
uh i don't know kevin

00:12:30,880 --> 00:12:35,040
i don't know much about it do you want

00:12:32,240 --> 00:12:39,839
to explain it

00:12:35,040 --> 00:12:39,839
what that was is relevant to

00:12:41,200 --> 00:12:46,240
what we would like to or what we're

00:12:43,440 --> 00:12:46,240
discussing now

00:12:48,240 --> 00:12:54,480
yeah i'm here um

00:12:51,440 --> 00:12:56,320
yeah so red hat used to use it uh for

00:12:54,480 --> 00:12:58,639
some of our embedded projects a long

00:12:56,320 --> 00:13:01,920
time ago it's uh

00:12:58,639 --> 00:13:04,079
up on source where i haven't built it in

00:13:01,920 --> 00:13:05,519
many years i don't know it's probably a

00:13:04,079 --> 00:13:08,160
bit rotted

00:13:05,519 --> 00:13:08,959
but it would be something for something

00:13:08,160 --> 00:13:13,120
to look at

00:13:08,959 --> 00:13:16,560
if you're thinking about uh

00:13:13,120 --> 00:13:21,600
an embedded type of framework

00:13:16,560 --> 00:13:23,279
um yeah i

00:13:21,600 --> 00:13:25,279
can't remember too much more about it

00:13:23,279 --> 00:13:28,079
than that but uh

00:13:25,279 --> 00:13:29,200
given time i might remember more do you

00:13:28,079 --> 00:13:30,639
remember what was the concept for

00:13:29,200 --> 00:13:34,000
example

00:13:30,639 --> 00:13:36,000
was it like in some kind of a

00:13:34,000 --> 00:13:37,519
base of code and data from interface and

00:13:36,000 --> 00:13:40,800
then we just implement

00:13:37,519 --> 00:13:43,440
some callbacks but that common code

00:13:40,800 --> 00:13:45,519
manages all the serial communication the

00:13:43,440 --> 00:13:49,839
protocol aspects of it

00:13:45,519 --> 00:13:52,800
yeah pretty much uh actually uh

00:13:49,839 --> 00:13:53,440
yeah i'm remembering andrew cagney i

00:13:52,800 --> 00:13:57,040
think

00:13:53,440 --> 00:13:59,360
designed a lot of it uh and i

00:13:57,040 --> 00:14:02,639
as i recall jim blandy and michael

00:13:59,360 --> 00:14:05,920
schneider had a hand in some of it

00:14:02,639 --> 00:14:06,639
eventually i got to maintaining it for a

00:14:05,920 --> 00:14:11,120
while

00:14:06,639 --> 00:14:11,120
um but

00:14:11,680 --> 00:14:18,320
yeah you could kind of drop in uh

00:14:15,040 --> 00:14:19,839
you know if you needed a a new embedded

00:14:18,320 --> 00:14:21,519
board or something like that with a

00:14:19,839 --> 00:14:22,160
particular interface it wasn't too hard

00:14:21,519 --> 00:14:24,880
to

00:14:22,160 --> 00:14:24,880
hook things up

00:14:26,560 --> 00:14:30,000
i think we uh i think we were connecting

00:14:29,199 --> 00:14:32,880
to isis and

00:14:30,000 --> 00:14:32,880
things like that so

00:14:36,720 --> 00:14:39,279
that pedro

00:14:40,240 --> 00:14:46,800
yeah hi um so

00:14:43,519 --> 00:14:49,839
i i've looked at the rda code base

00:14:46,800 --> 00:14:51,040
uh before and it was actually surprising

00:14:49,839 --> 00:14:54,639
to me

00:14:51,040 --> 00:14:56,800
that it was pretty much complete like uh

00:14:54,639 --> 00:14:58,160
i noticed that it also had like a

00:14:56,800 --> 00:15:01,279
windows port

00:14:58,160 --> 00:15:02,880
uh even before gdp server was ported to

00:15:01,279 --> 00:15:05,920
windows

00:15:02,880 --> 00:15:08,959
um yeah it didn't look very much

00:15:05,920 --> 00:15:10,880
different from what gdp server is

00:15:08,959 --> 00:15:14,079
i don't think there's any technical

00:15:10,880 --> 00:15:17,279
reason that gdp server couldn't be

00:15:14,079 --> 00:15:20,000
used for non-os targets

00:15:17,279 --> 00:15:22,160
it's uh much more reasonably abstracted

00:15:20,000 --> 00:15:24,639
nowadays than it was

00:15:22,160 --> 00:15:26,000
maybe a decade ago when i started

00:15:24,639 --> 00:15:29,199
looking at gdp server back

00:15:26,000 --> 00:15:31,360
then um it's

00:15:29,199 --> 00:15:32,880
mainly nowadays an issue of license as

00:15:31,360 --> 00:15:36,240
jeremy was

00:15:32,880 --> 00:15:38,320
saying i think that rda if i recall

00:15:36,240 --> 00:15:39,040
correctly and this was before my time i

00:15:38,320 --> 00:15:42,079
think

00:15:39,040 --> 00:15:44,079
red hat tried to contribute rda to to

00:15:42,079 --> 00:15:45,839
the fsf and it was rejected something

00:15:44,079 --> 00:15:49,440
like that

00:15:45,839 --> 00:15:52,240
and it never got much use

00:15:49,440 --> 00:15:55,040
in the community because it was seen as

00:15:52,240 --> 00:15:58,320
kind of a side thing from red hat

00:15:55,040 --> 00:15:59,920
not an upstream community project

00:15:58,320 --> 00:16:01,360
that's my understanding and i wasn't

00:15:59,920 --> 00:16:02,959
involved in it at the time it's my

00:16:01,360 --> 00:16:06,320
understanding from

00:16:02,959 --> 00:16:09,199
talking with other people about it

00:16:06,320 --> 00:16:10,480
but by looking at the code i had the

00:16:09,199 --> 00:16:12,240
thought that you know we could do the

00:16:10,480 --> 00:16:14,320
same thing with the gb service method of

00:16:12,240 --> 00:16:15,920
license so the question then becomes

00:16:14,320 --> 00:16:17,839
would we want to import a different

00:16:15,920 --> 00:16:20,399
thing inside our code base

00:16:17,839 --> 00:16:22,000
if it's going to be very similar just

00:16:20,399 --> 00:16:24,079
because it has a different license

00:16:22,000 --> 00:16:25,440
or if we really want to follow that path

00:16:24,079 --> 00:16:27,759
maybe we should

00:16:25,440 --> 00:16:29,440
split it a little bit more technically

00:16:27,759 --> 00:16:32,880
so that we have like the core

00:16:29,440 --> 00:16:35,279
parts neatly separated from the um

00:16:32,880 --> 00:16:36,320
operating system implementations and

00:16:35,279 --> 00:16:40,000
then we could

00:16:36,320 --> 00:16:42,000
rebrand that as a leave gdp server thing

00:16:40,000 --> 00:16:43,839
and maybe we could talk to the fsf we

00:16:42,000 --> 00:16:46,240
license that

00:16:43,839 --> 00:16:48,720
so that we would technically still have

00:16:46,240 --> 00:16:51,920
only one implementation

00:16:48,720 --> 00:16:54,240
that's an open question i have

00:16:51,920 --> 00:16:56,480
uh i used to think that c plus plus

00:16:54,240 --> 00:16:58,320
would was was a blocker

00:16:56,480 --> 00:17:00,560
but uh it's my understanding that even

00:16:58,320 --> 00:17:02,880
jeremy's um

00:17:00,560 --> 00:17:03,759
project is c plus based and they use it

00:17:02,880 --> 00:17:06,480
a lot and

00:17:03,759 --> 00:17:06,799
invested stuff uh jeremy please correct

00:17:06,480 --> 00:17:09,120
me

00:17:06,799 --> 00:17:10,720
if i'm wrong there yeah you're correct

00:17:09,120 --> 00:17:18,240
it's it's c plus plus

00:17:10,720 --> 00:17:20,880
14 i think yeah

00:17:18,240 --> 00:17:22,160
right okay yeah i i think i like pedro's

00:17:20,880 --> 00:17:25,600
idea of uh

00:17:22,160 --> 00:17:28,319
splitting out a live gdp server

00:17:25,600 --> 00:17:28,960
that would have the core components and

00:17:28,319 --> 00:17:31,360
and

00:17:28,960 --> 00:17:32,080
i know that uh that was actually one of

00:17:31,360 --> 00:17:35,840
the reasons

00:17:32,080 --> 00:17:37,120
that red hat uh used rda for these

00:17:35,840 --> 00:17:42,000
things was that

00:17:37,120 --> 00:17:42,000
we controlled the license so there was a

00:17:42,160 --> 00:17:46,960
you know kind of a free version that

00:17:44,320 --> 00:17:48,640
other folks could use but we also

00:17:46,960 --> 00:17:50,559
if we needed to connect it to something

00:17:48,640 --> 00:17:53,440
that had uh

00:17:50,559 --> 00:17:55,200
you know proprietary ip we could do so

00:17:53,440 --> 00:17:58,640
because

00:17:55,200 --> 00:18:01,679
uh we you know

00:17:58,640 --> 00:18:05,039
kept part of the license that you know

00:18:01,679 --> 00:18:06,640
that we could do that uh so yeah kind of

00:18:05,039 --> 00:18:09,679
a re-licensing of the

00:18:06,640 --> 00:18:12,840
the core part so it could be put into

00:18:09,679 --> 00:18:16,000
something proprietary might be uh

00:18:12,840 --> 00:18:17,360
well i i think

00:18:16,000 --> 00:18:19,679
as a practical matter right it's a good

00:18:17,360 --> 00:18:19,679
idea

00:18:21,280 --> 00:18:25,360
yeah i'm also not very good with

00:18:24,080 --> 00:18:28,480
licensed stuff so

00:18:25,360 --> 00:18:31,440
but i'm not sure how that could work but

00:18:28,480 --> 00:18:31,440
just understand pedro

00:18:31,840 --> 00:18:35,360
because i i don't think it would be a

00:18:32,960 --> 00:18:36,720
good idea either to have two different

00:18:35,360 --> 00:18:38,160
implementations in the trees we've got

00:18:36,720 --> 00:18:40,240
gb server and other thing on the side

00:18:38,160 --> 00:18:43,840
because this thing on the side would

00:18:40,240 --> 00:18:46,480
be doomed to be trot and maintained and

00:18:43,840 --> 00:18:48,240
it would be very hard to test uh

00:18:46,480 --> 00:18:51,039
upstream at least

00:18:48,240 --> 00:18:53,600
so i but i could very well see having

00:18:51,039 --> 00:18:55,760
this legit server that

00:18:53,600 --> 00:18:57,200
and have the gb server program

00:18:55,760 --> 00:18:59,440
implemented that's

00:18:57,200 --> 00:19:02,240
using that so that at least the the lib

00:18:59,440 --> 00:19:05,280
would always be

00:19:02,240 --> 00:19:08,480
tested and exercised not all

00:19:05,280 --> 00:19:10,080
ports or all implementations behind that

00:19:08,480 --> 00:19:12,160
would could be tested upstream but at

00:19:10,080 --> 00:19:15,520
least the lid itself

00:19:12,160 --> 00:19:17,600
and yeah it would avoid duplication of

00:19:15,520 --> 00:19:19,120
functionality as well so is that what

00:19:17,600 --> 00:19:19,679
you were thinking of implementing gb

00:19:19,120 --> 00:19:21,120
server

00:19:19,679 --> 00:19:22,960
using that library and then the library

00:19:21,120 --> 00:19:26,480
kit can be used by other people

00:19:22,960 --> 00:19:30,480
like i don't know a valid grind or qmu

00:19:26,480 --> 00:19:33,600
that has gb

00:19:30,480 --> 00:19:37,440
rsp interfaces right i was saying

00:19:33,600 --> 00:19:40,640
yeah that that's a potential path i i

00:19:37,440 --> 00:19:43,039
if we did separate the core aspects of

00:19:40,640 --> 00:19:45,120
jdb server from the

00:19:43,039 --> 00:19:46,480
you know the linux back and the windows

00:19:45,120 --> 00:19:48,480
backend then

00:19:46,480 --> 00:19:52,160
of course gdb server the pro the program

00:19:48,480 --> 00:19:55,280
would consume that library as well and

00:19:52,160 --> 00:19:56,000
to me it's a matter of who wants to do

00:19:55,280 --> 00:19:59,360
this

00:19:56,000 --> 00:20:02,480
who wants to spend time you know

00:19:59,360 --> 00:20:03,360
actually working on on this is it worth

00:20:02,480 --> 00:20:07,200
it

00:20:03,360 --> 00:20:08,000
um i'm also happy with a world where we

00:20:07,200 --> 00:20:10,960
have different

00:20:08,000 --> 00:20:12,080
gdp server implementations it's not like

00:20:10,960 --> 00:20:15,440
the

00:20:12,080 --> 00:20:18,720
remote protocol parts

00:20:15,440 --> 00:20:18,720
are very complicated

00:20:19,039 --> 00:20:25,280
it's it's not where the core of

00:20:22,240 --> 00:20:26,960
of a typical server is

00:20:25,280 --> 00:20:29,360
like the that's not the hard parts the

00:20:26,960 --> 00:20:32,400
hard parts tend to be the back end

00:20:29,360 --> 00:20:36,080
and and

00:20:32,400 --> 00:20:38,799
also offering a library interface

00:20:36,080 --> 00:20:40,320
ask the question like what guarantees do

00:20:38,799 --> 00:20:40,640
we have with stability and everything

00:20:40,320 --> 00:20:42,080
like

00:20:40,640 --> 00:20:44,000
we do a lot of efforts to keep the

00:20:42,080 --> 00:20:44,640
remote protocol itself backwards

00:20:44,000 --> 00:20:47,280
compatible

00:20:44,640 --> 00:20:49,280
and everything uh so that's the

00:20:47,280 --> 00:20:51,360
interface people currently

00:20:49,280 --> 00:20:53,120
use and like you say pedro it's not the

00:20:51,360 --> 00:20:53,760
hardest protocol to just parse and use

00:20:53,120 --> 00:20:56,559
that's the

00:20:53,760 --> 00:20:58,000
hard part now if you're doing a c

00:20:56,559 --> 00:21:00,080
interface

00:20:58,000 --> 00:21:01,360
we have to make sure it's at least

00:21:00,080 --> 00:21:03,120
somewhat backwards compatible through

00:21:01,360 --> 00:21:06,640
otherwise

00:21:03,120 --> 00:21:09,120
other programs that consume yeah

00:21:06,640 --> 00:21:10,320
i i'd support pedro's view actually i'd

00:21:09,120 --> 00:21:11,919
suggest starting with

00:21:10,320 --> 00:21:14,240
multiple architectures and then look at

00:21:11,919 --> 00:21:16,960
unifying them the reason is that

00:21:14,240 --> 00:21:18,000
you might find that bare metal actually

00:21:16,960 --> 00:21:20,159
requires

00:21:18,000 --> 00:21:21,360
additional features that you don't get

00:21:20,159 --> 00:21:22,799
in linux

00:21:21,360 --> 00:21:24,880
uh for example it's perfectly normal to

00:21:22,799 --> 00:21:27,679
have multi-core bet or

00:21:24,880 --> 00:21:28,640
simple hard deeply embedded systems

00:21:27,679 --> 00:21:31,760
where

00:21:28,640 --> 00:21:35,120
the mapping between address spaces and

00:21:31,760 --> 00:21:37,840
execution threads is non-trivial

00:21:35,120 --> 00:21:38,799
um certainly compared to linux so you

00:21:37,840 --> 00:21:42,480
may find

00:21:38,799 --> 00:21:43,679
that's um that's a factor so starting

00:21:42,480 --> 00:21:45,520
with two and then working what the

00:21:43,679 --> 00:21:46,720
common themes are to put them into a gdp

00:21:45,520 --> 00:21:48,880
server

00:21:46,720 --> 00:21:51,120
lib gdp server is a good idea and it

00:21:48,880 --> 00:21:53,840
really needs one of those

00:21:51,120 --> 00:21:55,520
companies that are paying for you know

00:21:53,840 --> 00:21:57,120
bare metal gdp support

00:21:55,520 --> 00:21:58,880
to decide actually having it upstream

00:21:57,120 --> 00:22:00,640
would be a good thing so i think that's

00:21:58,880 --> 00:22:04,080
those obviously work commercially can

00:22:00,640 --> 00:22:04,080
see who's willing to pay for the work

00:22:07,520 --> 00:22:11,280
yeah i think as a community it would

00:22:09,200 --> 00:22:14,400
definitely be worth it but yeah the

00:22:11,280 --> 00:22:16,960
problem is that somebody has to

00:22:14,400 --> 00:22:18,720
um mark in the chat mentions that yeah

00:22:16,960 --> 00:22:20,640
the valgrind gb server implementation

00:22:18,720 --> 00:22:22,799
is a hacked up copy lifted from gb a

00:22:20,640 --> 00:22:24,400
long time ago so

00:22:22,799 --> 00:22:26,240
and that's the kind i think the kind of

00:22:24,400 --> 00:22:28,320
things that i

00:22:26,240 --> 00:22:30,159
don't find i mean i understand why it

00:22:28,320 --> 00:22:31,520
wasn't this way but it's not ideal in

00:22:30,159 --> 00:22:34,799
that

00:22:31,520 --> 00:22:37,919
while gdp's version evolves

00:22:34,799 --> 00:22:37,919
the one that was copied

00:22:39,600 --> 00:22:42,799
yeah i'm under the impression that it's

00:22:41,760 --> 00:22:46,320
stuck because of

00:22:42,799 --> 00:22:48,640
gpl v2 maybe i'm incorrect

00:22:46,320 --> 00:22:50,720
and this is still information but i

00:22:48,640 --> 00:22:55,840
think that was the original

00:22:50,720 --> 00:22:55,840
thing okay maybe

00:22:56,799 --> 00:22:59,840
okay so i think we all agree that's all

00:22:58,880 --> 00:23:03,200
technically

00:22:59,840 --> 00:23:03,520
good something good but there's licenses

00:23:03,200 --> 00:23:07,120
and

00:23:03,520 --> 00:23:07,840
also who would like to work on that but

00:23:07,120 --> 00:23:10,880
at least

00:23:07,840 --> 00:23:10,880
as an upstream

00:23:10,960 --> 00:23:14,320
maintainer that's something i would very

00:23:12,960 --> 00:23:23,840
very happy to look at and

00:23:14,320 --> 00:23:23,840
help anybody would like to work on that

00:23:25,200 --> 00:23:30,080
so did we cover this topic journey

00:23:32,000 --> 00:23:36,159
yes yes um and i noticed we've got no

00:23:34,640 --> 00:23:37,200
minutes left to cover all the other

00:23:36,159 --> 00:23:40,240
times really

00:23:37,200 --> 00:23:43,679
well yeah it's 20 it's really fast

00:23:40,240 --> 00:23:46,400
okay yep uh yeah the

00:23:43,679 --> 00:23:48,000
25 minutes goes real quick but this is

00:23:46,400 --> 00:23:49,679
one interesting topic we talked about

00:23:48,000 --> 00:23:52,320
but

00:23:49,679 --> 00:23:53,600
i'd like to know if like i said that the

00:23:52,320 --> 00:23:54,240
talk that's just after the brother

00:23:53,600 --> 00:23:57,440
suffer

00:23:54,240 --> 00:24:00,320
is about dwarf and you know i've been

00:23:57,440 --> 00:24:02,080
quite involved in last year and learning

00:24:00,320 --> 00:24:05,039
about dwarf fire things like that to

00:24:02,080 --> 00:24:06,720
review patches and otherwise uh so i'd

00:24:05,039 --> 00:24:10,320
like to

00:24:06,720 --> 00:24:12,000
and i'd like to to to to listen but

00:24:10,320 --> 00:24:13,760
if people if people would like to

00:24:12,000 --> 00:24:17,520
continue in the ad room right away i'll

00:24:13,760 --> 00:24:18,480
also join but you could also mind if we

00:24:17,520 --> 00:24:20,159
wait

00:24:18,480 --> 00:24:22,640
after this talk or i'd like to just i'd

00:24:20,159 --> 00:24:26,240
just like to know what people like to do

00:24:22,640 --> 00:24:30,080
uh stay for the next one or

00:24:26,240 --> 00:24:30,080
leave for to the akron

00:24:31,120 --> 00:24:34,559
a quick question i think there are five

00:24:33,440 --> 00:24:36,240
rooms

00:24:34,559 --> 00:24:39,360
is that correct that we cannot create

00:24:36,240 --> 00:24:40,880
extra so power

00:24:39,360 --> 00:24:42,159
there's a message on chat hack room

00:24:40,880 --> 00:24:44,400
two's available if you'd like to

00:24:42,159 --> 00:24:46,720
continue the discussion

00:24:44,400 --> 00:24:49,120
yeah first comes so i think you'd be

00:24:46,720 --> 00:24:53,440
people we can coordinate on gdpr's

00:24:49,120 --> 00:24:55,440
irc also

00:24:53,440 --> 00:24:56,880
all right thank you very much then simon

00:24:55,440 --> 00:24:58,880
um first session

00:24:56,880 --> 00:25:00,559
successfully completed within the time

00:24:58,880 --> 00:25:03,120
interval um

00:25:00,559 --> 00:25:04,960
we'll let people get their cells sorted

00:25:03,120 --> 00:25:15,840
out and their new slides

00:25:04,960 --> 00:25:15,840
up and i will just

00:25:40,320 --> 00:25:45,440
so mark um uh i was

00:25:43,440 --> 00:25:47,039
i will we'll start you at exactly half

00:25:45,440 --> 00:25:48,159
past for the benefit of anyone who's

00:25:47,039 --> 00:25:52,240
live

00:25:48,159 --> 00:25:54,159
uh live uh watching the live stream so

00:25:52,240 --> 00:25:56,559
we've got a couple of minutes

00:25:54,159 --> 00:25:57,200
um oh there we are you've got your

00:25:56,559 --> 00:26:00,400
slides

00:25:57,200 --> 00:26:02,240
okay uh mark oh there they are

00:26:00,400 --> 00:26:03,679
if uh we'll just give it a couple of

00:26:02,240 --> 00:26:05,520
minutes for anyone who's transferring

00:26:03,679 --> 00:26:08,840
over

00:26:05,520 --> 00:26:10,400
and simon marchi are you still here

00:26:08,840 --> 00:26:13,679
simon

00:26:10,400 --> 00:26:16,240
yep yeah okay simon's take

00:26:13,679 --> 00:26:17,840
okay simon you're taking over as me from

00:26:16,240 --> 00:26:21,039
me as moderator

00:26:17,840 --> 00:26:21,679
i oh right so i i have to stay anyway

00:26:21,039 --> 00:26:24,880
that's true

00:26:21,679 --> 00:26:27,039
until he's until all right okay

00:26:24,880 --> 00:26:28,640
but i i'm currently joined in the two

00:26:27,039 --> 00:26:32,400
rooms so i'll be able to listen

00:26:28,640 --> 00:26:34,960
to each what one year each

00:26:32,400 --> 00:26:36,559
okay and sarah will put up the time

00:26:34,960 --> 00:26:38,960
sarah will put up the time

00:26:36,559 --> 00:26:41,200
warnings you'll get a notification five

00:26:38,960 --> 00:26:46,640
three in one minute mark

00:26:41,200 --> 00:26:53,840
okay thank you oh great and i can

00:26:46,640 --> 00:26:53,840
okay this works

00:27:09,039 --> 00:27:11,520
you can

00:27:15,120 --> 00:27:24,000
i can

00:27:21,360 --> 00:27:24,799
uh sarah did sarah did say that her

00:27:24,000 --> 00:27:27,360
laptop was

00:27:24,799 --> 00:27:28,480
getting a bit overloaded um while she's

00:27:27,360 --> 00:27:34,720
tracking sorted

00:27:28,480 --> 00:27:36,880
things at once so um we'll just give it

00:27:34,720 --> 00:27:38,640
you've got about a minute and then it

00:27:36,880 --> 00:27:39,840
will stick exactly to time for anyone

00:27:38,640 --> 00:27:42,640
who's setting alarm to see this

00:27:39,840 --> 00:27:42,640
particular session

00:28:18,960 --> 00:28:25,760
um jeremy yeah

00:28:22,799 --> 00:28:27,679
so okay uh so if you want to cut you'd

00:28:25,760 --> 00:28:30,559
like to copy the notes you you took

00:28:27,679 --> 00:28:31,679
and do you know if there's a place to

00:28:30,559 --> 00:28:34,880
put it so there's

00:28:31,679 --> 00:28:38,159
it can be available in for

00:28:34,880 --> 00:28:39,360
i'll i'll blow up well yeah i'll i'll

00:28:38,159 --> 00:28:40,720
sort that out and work out where we're

00:28:39,360 --> 00:28:41,840
gonna put them yeah we'll probably put

00:28:40,720 --> 00:28:45,120
them up on the um

00:28:41,840 --> 00:28:49,840
the wiki or something i'll take a copy

00:28:45,120 --> 00:28:53,279
okay okay i think you're there mark

00:28:49,840 --> 00:28:58,000
okay let's start this so

00:28:53,279 --> 00:29:02,159
um when i proposed this talk

00:28:58,000 --> 00:29:06,399
or buff i was a bit

00:29:02,159 --> 00:29:09,520
ambitious so i thought let's discuss

00:29:06,399 --> 00:29:13,279
making var5 the default

00:29:09,520 --> 00:29:16,480
and see if we can support rf64

00:29:13,279 --> 00:29:18,640
and single file split barf and have a

00:29:16,480 --> 00:29:22,320
discussion about debug types

00:29:18,640 --> 00:29:25,520
and that was a bit much

00:29:22,320 --> 00:29:28,640
so i

00:29:25,520 --> 00:29:30,320
actually looked at making 25 the default

00:29:28,640 --> 00:29:33,520
for gc

00:29:30,320 --> 00:29:33,520
uh uh

00:29:33,600 --> 00:29:38,480
but that took up all my time so i've

00:29:36,880 --> 00:29:41,919
been just prepared for that

00:29:38,480 --> 00:29:45,760
uh but the others are just

00:29:41,919 --> 00:29:45,760
ideas um

00:29:46,399 --> 00:29:54,799
so why would we want

00:29:50,159 --> 00:29:56,960
to finally move to the r5 i believe the

00:29:54,799 --> 00:30:01,600
standard has been out for

00:29:56,960 --> 00:30:04,960
four years already uh and dc

00:30:01,600 --> 00:30:08,240
really already supports uh

00:30:04,960 --> 00:30:12,000
most of it and it supports

00:30:08,240 --> 00:30:16,000
in a nice way

00:30:12,000 --> 00:30:19,760
in that if if you don't use any of the

00:30:16,000 --> 00:30:23,039
extended features it doesn't use

00:30:19,760 --> 00:30:27,200
extended forms or

00:30:23,039 --> 00:30:27,200
alternative tables uh

00:30:28,240 --> 00:30:34,880
so it's it's what do you see

00:30:32,320 --> 00:30:36,720
output says 2r5 is actually not that

00:30:34,880 --> 00:30:41,679
hard to

00:30:36,720 --> 00:30:41,679
support it makes

00:30:41,919 --> 00:30:48,880
the dwarf a bit smaller

00:30:45,440 --> 00:30:51,760
it has less relocations

00:30:48,880 --> 00:30:52,799
mainly because a lot of the rangers

00:30:51,760 --> 00:30:56,320
lists

00:30:52,799 --> 00:30:59,440
used to be just tables of two addresses

00:30:56,320 --> 00:31:03,279
and now they can be offsets uh

00:30:59,440 --> 00:31:04,080
uh from a base address or from each

00:31:03,279 --> 00:31:07,360
other

00:31:04,080 --> 00:31:09,919
which makes things uh a bit more

00:31:07,360 --> 00:31:09,919
efficient

00:31:10,320 --> 00:31:19,039
and it's really easier to reason about

00:31:15,679 --> 00:31:20,720
than the new extensions that we used in

00:31:19,039 --> 00:31:23,519
the past because

00:31:20,720 --> 00:31:25,279
well now things are actually documented

00:31:23,519 --> 00:31:28,960
standardized

00:31:25,279 --> 00:31:32,080
so other tools can also help with it

00:31:28,960 --> 00:31:35,200
um so basically what i

00:31:32,080 --> 00:31:38,399
did was make it the default

00:31:35,200 --> 00:31:42,000
uh look what breaks uh

00:31:38,399 --> 00:31:44,720
uh and

00:31:42,000 --> 00:31:46,559
well look what breaks is i looked at c c

00:31:44,720 --> 00:31:49,200
plus plus

00:31:46,559 --> 00:31:51,679
and i mainly looked at the tc alpha

00:31:49,200 --> 00:31:56,559
tailspin utils and gdp

00:31:51,679 --> 00:31:56,559
test suits um

00:31:57,120 --> 00:32:04,080
uh the uh

00:32:00,240 --> 00:32:07,120
i did send some patches to uh to see

00:32:04,080 --> 00:32:12,799
uh uh petra's

00:32:07,120 --> 00:32:12,799
main list uh one of them is kind of

00:32:12,840 --> 00:32:19,519
uh

00:32:15,519 --> 00:32:22,720
well uh i don't know um alex isn't

00:32:19,519 --> 00:32:25,120
here no too bad um

00:32:22,720 --> 00:32:26,080
the idea with location views is that

00:32:25,120 --> 00:32:29,840
they

00:32:26,080 --> 00:32:33,679
are in the lock list but

00:32:29,840 --> 00:32:33,679
they are not

00:32:33,840 --> 00:32:40,960
for for older dwarf

00:32:37,760 --> 00:32:43,440
the lock list was

00:32:40,960 --> 00:32:44,240
uh really you had to read it together

00:32:43,440 --> 00:32:48,480
with the

00:32:44,240 --> 00:32:51,039
cu um in it were five almost

00:32:48,480 --> 00:32:52,480
all the tables are kind of standalone

00:32:51,039 --> 00:32:55,519
have their own header

00:32:52,480 --> 00:32:58,559
uh their own base addresses uh

00:32:55,519 --> 00:33:01,760
so you could read them

00:32:58,559 --> 00:33:06,480
standalone and the lock location views

00:33:01,760 --> 00:33:08,159
make that kind of hard because they are

00:33:06,480 --> 00:33:10,159
they are still at no extension not

00:33:08,159 --> 00:33:13,440
standardized there are actually

00:33:10,159 --> 00:33:16,960
two forms that you can do this in

00:33:13,440 --> 00:33:20,480
uh but both aren't

00:33:16,960 --> 00:33:22,000
standard to r5 so one of the suggestions

00:33:20,480 --> 00:33:24,320
i made was

00:33:22,000 --> 00:33:25,039
don't enable location fields by default

00:33:24,320 --> 00:33:27,679
for

00:33:25,039 --> 00:33:27,679
to r5

00:33:28,080 --> 00:33:33,440
let's see what people say yay or

00:33:31,279 --> 00:33:33,440
boo

00:33:36,000 --> 00:33:39,679
uh out there is yeah i i think it's it's

00:33:39,039 --> 00:33:42,000
kind of

00:33:39,679 --> 00:33:44,000
problematic we should discuss with with

00:33:42,000 --> 00:33:47,200
alex what exactly he wants

00:33:44,000 --> 00:33:49,360
then uh what was the way forward

00:33:47,200 --> 00:33:50,880
because it's not standardized we can

00:33:49,360 --> 00:33:54,000
come up with a different

00:33:50,880 --> 00:33:57,360
extension perhaps or

00:33:54,000 --> 00:34:01,120
yeah this was

00:33:57,360 --> 00:34:05,279
mainly oh this is something that

00:34:01,120 --> 00:34:08,399
uh both ben neutos and elf utils

00:34:05,279 --> 00:34:12,000
can read the location lists

00:34:08,399 --> 00:34:12,000
for five location lists

00:34:12,480 --> 00:34:19,119
stand alone but not if

00:34:16,000 --> 00:34:21,440
location views are enabled

00:34:19,119 --> 00:34:22,159
because there are two ways of enabling

00:34:21,440 --> 00:34:24,240
them

00:34:22,159 --> 00:34:26,720
we probably have to discuss and make

00:34:24,240 --> 00:34:30,480
sure else you just

00:34:26,720 --> 00:34:33,359
support that um

00:34:30,480 --> 00:34:34,000
so the the good old in the in the chat

00:34:33,359 --> 00:34:37,119
then

00:34:34,000 --> 00:34:42,480
asked about fortran no i didn't look at

00:34:37,119 --> 00:34:42,480
all at fortune sorry um

00:34:42,800 --> 00:34:48,399
and yes there is a proposal to add

00:34:45,919 --> 00:34:52,480
location views uh

00:34:48,399 --> 00:34:54,800
to our six but i'm not sure if

00:34:52,480 --> 00:34:56,079
anybody is actually working yet onto our

00:34:54,800 --> 00:35:00,839
six so

00:34:56,079 --> 00:35:04,560
yeah yeah it hasn't started yet so

00:35:00,839 --> 00:35:07,119
yeah um

00:35:04,560 --> 00:35:08,240
yeah so i didn't really look at fortune

00:35:07,119 --> 00:35:11,359
or ada i

00:35:08,240 --> 00:35:14,880
could have but well ran out of fine

00:35:11,359 --> 00:35:18,320
um i think they're fine

00:35:14,880 --> 00:35:19,119
well at least in it you see the test

00:35:18,320 --> 00:35:22,640
suit

00:35:19,119 --> 00:35:25,440
uh if you enable two or five uh

00:35:22,640 --> 00:35:27,680
there aren't that many things that need

00:35:25,440 --> 00:35:31,599
fixing up and they all

00:35:27,680 --> 00:35:33,920
uh are just a

00:35:31,599 --> 00:35:34,640
test that scan the assembly generated

00:35:33,920 --> 00:35:37,920
and then

00:35:34,640 --> 00:35:42,240
some forms change so i just uh

00:35:37,920 --> 00:35:44,720
made a

00:35:42,240 --> 00:35:45,599
made a test to work the new forms and

00:35:44,720 --> 00:35:49,040
that was it

00:35:45,599 --> 00:35:52,560
so gcc itself seems

00:35:49,040 --> 00:35:56,240
okay uh except for

00:35:52,560 --> 00:35:59,440
a couple of tests that need a

00:35:56,240 --> 00:36:02,960
fix in being you to those ld uh we'll

00:35:59,440 --> 00:36:06,480
get to that um gdb

00:36:02,960 --> 00:36:08,800
uh the tesla looks really good

00:36:06,480 --> 00:36:10,240
uh again i looked only at the c and the

00:36:08,800 --> 00:36:12,880
c plus one

00:36:10,240 --> 00:36:14,240
uh the the only thing that gdp has an

00:36:12,880 --> 00:36:18,880
issue with

00:36:14,240 --> 00:36:22,400
is that uh in r5 static data members

00:36:18,880 --> 00:36:25,520
are no longer members of a class

00:36:22,400 --> 00:36:28,720
but are actual variables

00:36:25,520 --> 00:36:31,839
uh that breaks a couple of test cases

00:36:28,720 --> 00:36:35,599
i don't think it really breaks

00:36:31,839 --> 00:36:35,599
uh debugging itself

00:36:37,280 --> 00:36:44,320
the only kind of odd thing about

00:36:40,400 --> 00:36:47,280
the static

00:36:44,320 --> 00:36:48,800
data members is that the variables can

00:36:47,280 --> 00:36:52,480
sometimes disappear

00:36:48,800 --> 00:36:55,280
if you don't reference them and

00:36:52,480 --> 00:36:56,240
i think we kind of want to keep them in

00:36:55,280 --> 00:36:58,880
the

00:36:56,240 --> 00:37:00,480
debugged outputs even if they are not

00:36:58,880 --> 00:37:04,320
used because

00:37:00,480 --> 00:37:04,320
that's what people expect to see

00:37:04,640 --> 00:37:11,680
um so being utils was

00:37:08,640 --> 00:37:15,839
kind of i was kind of surprised

00:37:11,680 --> 00:37:19,280
because it needed very small fixes

00:37:15,839 --> 00:37:22,800
uh probably nobody ever

00:37:19,280 --> 00:37:25,520
really used uh uh

00:37:22,800 --> 00:37:27,200
built big utils itself with four or five

00:37:25,520 --> 00:37:30,720
enabled so

00:37:27,200 --> 00:37:34,560
um the uh

00:37:30,720 --> 00:37:35,359
there's one fix for ld which sometimes

00:37:34,560 --> 00:37:38,400
tries to

00:37:35,359 --> 00:37:40,720
read the debug ranges and of course now

00:37:38,400 --> 00:37:45,200
there's debug brains lists

00:37:40,720 --> 00:37:48,839
uh i think that's only an issue if

00:37:45,200 --> 00:37:52,079
ld wants to provide warnings and

00:37:48,839 --> 00:37:55,359
uh reads the dwarf to give

00:37:52,079 --> 00:37:56,560
better error messages uh the only

00:37:55,359 --> 00:37:59,839
problem is that if it

00:37:56,560 --> 00:38:03,280
can't read the debug message it gives an

00:37:59,839 --> 00:38:06,560
error about not being able to reach the

00:38:03,280 --> 00:38:09,280
the the debug info instead of

00:38:06,560 --> 00:38:09,920
the the original error which is kind of

00:38:09,280 --> 00:38:14,000
odd

00:38:09,920 --> 00:38:18,560
i i have a fix for that uh

00:38:14,000 --> 00:38:23,440
which kind of should go in um

00:38:18,560 --> 00:38:26,480
the the problematic thing so

00:38:23,440 --> 00:38:31,200
this is actually all good uh

00:38:26,480 --> 00:38:34,480
the uh i think if it was just

00:38:31,200 --> 00:38:37,599
uh alfie those being util cc itself

00:38:34,480 --> 00:38:39,920
uh uh gdb uh

00:38:37,599 --> 00:38:41,440
we could just switch on to uh

00:38:39,920 --> 00:38:45,359
switzerland fifo

00:38:41,440 --> 00:38:48,480
uh felgrand uh rpm debug and

00:38:45,359 --> 00:38:51,760
edit and dwc uh

00:38:48,480 --> 00:38:56,320
needs batches i don't think it's too

00:38:51,760 --> 00:39:00,320
much work uh i know young already has

00:38:56,320 --> 00:39:03,359
most of the patches for debug edits

00:39:00,320 --> 00:39:06,400
i looked a bit at fail grant

00:39:03,359 --> 00:39:09,440
should not be that much work dwz

00:39:06,400 --> 00:39:10,480
is a bit more work but i think we can

00:39:09,440 --> 00:39:13,520
manage and

00:39:10,480 --> 00:39:17,599
of course that doesn't need to be

00:39:13,520 --> 00:39:22,800
ready till tc11 is

00:39:17,599 --> 00:39:22,800
out and distros want to package it

00:39:27,359 --> 00:39:29,839
yeah yeah

00:39:31,040 --> 00:39:35,119
yeah on the dw z side it's it's actually

00:39:34,640 --> 00:39:37,520
three

00:39:35,119 --> 00:39:40,000
three different things one one is to to

00:39:37,520 --> 00:39:41,119
be able to parse the dwarf five headers

00:39:40,000 --> 00:39:45,280
and

00:39:41,119 --> 00:39:49,119
new forms and so on the second part is

00:39:45,280 --> 00:39:52,880
to switch to using the now standard

00:39:49,119 --> 00:39:56,880
way of of marking

00:39:52,880 --> 00:40:00,320
the multiple files uh

00:39:56,880 --> 00:40:01,520
located somewhere else way which which

00:40:00,320 --> 00:40:03,920
is now standard in var

00:40:01,520 --> 00:40:06,400
five and the last part is is

00:40:03,920 --> 00:40:09,359
optimizations which which we can

00:40:06,400 --> 00:40:11,440
do afterwards it doesn't have to be

00:40:09,359 --> 00:40:14,560
before gcc 11.

00:40:11,440 --> 00:40:17,359
by optimizations i i mean mainly

00:40:14,560 --> 00:40:18,560
being able to use the better more

00:40:17,359 --> 00:40:21,839
compact forms

00:40:18,560 --> 00:40:23,359
based on how how many how many dice are

00:40:21,839 --> 00:40:26,240
there in

00:40:23,359 --> 00:40:26,640
what kind of attributes they have but

00:40:26,240 --> 00:40:29,040
the

00:40:26,640 --> 00:40:29,760
first two parts probably need to be done

00:40:29,040 --> 00:40:32,400
and after

00:40:29,760 --> 00:40:33,440
after the second part is done we need to

00:40:32,400 --> 00:40:37,520
also

00:40:33,440 --> 00:40:40,560
change all the consumers again

00:40:37,520 --> 00:40:44,400
so that they they handled that five

00:40:40,560 --> 00:40:47,920
way of looking for the multiple files

00:40:44,400 --> 00:40:51,440
yeah that that that might be

00:40:47,920 --> 00:40:54,880
a bit more work but i think

00:40:51,440 --> 00:40:58,000
if they handle uh dwarf

00:40:54,880 --> 00:41:02,400
in a normal fall they

00:40:58,000 --> 00:41:04,400
also will be able to easily handle it

00:41:02,400 --> 00:41:06,880
yeah it should be that hard it's just

00:41:04,400 --> 00:41:08,240
different way of how to express the same

00:41:06,880 --> 00:41:11,839
thing

00:41:08,240 --> 00:41:15,200
yeah um

00:41:11,839 --> 00:41:16,800
so one thing that that yes better

00:41:15,200 --> 00:41:19,040
i was just going to say that for gdp

00:41:16,800 --> 00:41:22,319
there's one extra issue and it's kind of

00:41:19,040 --> 00:41:24,480
it's it's more five related it's the

00:41:22,319 --> 00:41:25,920
the debug names section the

00:41:24,480 --> 00:41:27,839
implementation gdp is

00:41:25,920 --> 00:41:29,839
supposedly complete but it's not it's

00:41:27,839 --> 00:41:33,119
not really complete because

00:41:29,839 --> 00:41:34,079
uh what we do is we dump into the debug

00:41:33,119 --> 00:41:36,160
name section

00:41:34,079 --> 00:41:37,760
the same thing that we would dump into

00:41:36,160 --> 00:41:42,079
the gdb index

00:41:37,760 --> 00:41:45,280
file which is not war five compliant

00:41:42,079 --> 00:41:47,359
so we like we encapsulate things

00:41:45,280 --> 00:41:49,440
nicely in the bar five way but the

00:41:47,359 --> 00:41:51,359
contents are not compliant so

00:41:49,440 --> 00:41:52,800
uh if we ever want to switch the dwarf

00:41:51,359 --> 00:41:54,800
five index files

00:41:52,800 --> 00:41:58,319
we would need to fix that otherwise we

00:41:54,800 --> 00:42:03,520
would be stuck in a gtb only then

00:41:58,319 --> 00:42:07,520
yeah yeah so um uh

00:42:03,520 --> 00:42:10,880
yeah do you know if other tools

00:42:07,520 --> 00:42:13,760
use the gdb index file

00:42:10,880 --> 00:42:13,760
directly or

00:42:14,800 --> 00:42:23,680
ask consumers um yes i don't i don't

00:42:19,440 --> 00:42:26,880
okay lldb uses dwarf five things

00:42:23,680 --> 00:42:30,240
okay and clang admits it i think

00:42:26,880 --> 00:42:33,760
in a compliant way

00:42:30,240 --> 00:42:36,960
uh okay and does do they do it

00:42:33,760 --> 00:42:40,400
in the compiler or if they

00:42:36,960 --> 00:42:41,040
because they i they i think do it in the

00:42:40,400 --> 00:42:44,800
compiler

00:42:41,040 --> 00:42:47,200
somehow okay

00:42:44,800 --> 00:42:48,160
that's interesting i don't know how you

00:42:47,200 --> 00:42:52,000
would do that

00:42:48,160 --> 00:42:56,079
so because you you you have to

00:42:52,000 --> 00:43:00,720
uh so that they parsed all the cus

00:42:56,079 --> 00:43:05,760
during the compilates i don't know

00:43:00,720 --> 00:43:09,280
okay let's put a shared notes

00:43:05,760 --> 00:43:12,640
uh uh look

00:43:09,280 --> 00:43:15,280
into the piano well

00:43:12,640 --> 00:43:16,319
i think you can emit something from the

00:43:15,280 --> 00:43:18,560
compiler

00:43:16,319 --> 00:43:20,800
if you compile just a single composition

00:43:18,560 --> 00:43:23,440
you need then you emit

00:43:20,800 --> 00:43:23,839
standard compliant debug names for that

00:43:23,440 --> 00:43:26,800
but

00:43:23,839 --> 00:43:27,920
that generally is not really useful so i

00:43:26,800 --> 00:43:30,720
would think that they

00:43:27,920 --> 00:43:32,720
throw it away during link time and and

00:43:30,720 --> 00:43:34,480
build it again during linking or

00:43:32,720 --> 00:43:38,079
something

00:43:34,480 --> 00:43:38,960
yeah okay but that doesn't need

00:43:38,079 --> 00:43:44,480
something to

00:43:38,960 --> 00:43:44,480
look at that i didn't add to this list

00:43:45,599 --> 00:43:52,560
so the one thing

00:43:48,720 --> 00:43:56,800
that tc doesn't do

00:43:52,560 --> 00:43:56,800
is or actually does

00:43:57,440 --> 00:43:59,599
it

00:44:00,800 --> 00:44:05,359
outputting of debug lights it

00:44:05,440 --> 00:44:09,839
it passes that on to the assembler

00:44:08,800 --> 00:44:13,040
because the assembler

00:44:09,839 --> 00:44:16,319
knows more about

00:44:13,040 --> 00:44:16,319
where all their sections go

00:44:17,520 --> 00:44:23,599
but that means that currently

00:44:21,200 --> 00:44:25,040
to see even into our five modes

00:44:23,599 --> 00:44:28,800
generates a

00:44:25,040 --> 00:44:31,920
2r4 debug line section

00:44:28,800 --> 00:44:32,720
that actually works great so maybe we

00:44:31,920 --> 00:44:36,240
don't want to

00:44:32,720 --> 00:44:40,480
change that because everything

00:44:36,240 --> 00:44:44,079
handles version 4 debug lines

00:44:40,480 --> 00:44:48,400
but pin utils does support

00:44:44,079 --> 00:44:48,400
gdrf 5. now

00:44:48,640 --> 00:44:51,839
the only problem is that it is a bit

00:44:50,800 --> 00:44:54,960
buggy

00:44:51,839 --> 00:44:58,400
uh so i have some

00:44:54,960 --> 00:45:01,760
patches uh for it to uh

00:44:58,400 --> 00:45:04,079
generate uh better version five

00:45:01,760 --> 00:45:04,880
uh double clients those are those are

00:45:04,079 --> 00:45:08,160
already in

00:45:04,880 --> 00:45:12,400
master but uh

00:45:08,160 --> 00:45:12,400
maybe we can get them exported

00:45:13,359 --> 00:45:18,720
is nick here yes i am and yes you can

00:45:16,319 --> 00:45:22,160
get them back ported

00:45:18,720 --> 00:45:22,160
okay great

00:45:25,680 --> 00:45:30,000
basically what we we need some configure

00:45:28,800 --> 00:45:33,119
tests to

00:45:30,000 --> 00:45:36,160
make sure bin utils

00:45:33,119 --> 00:45:38,240
is doing the right thing and maybe also

00:45:36,160 --> 00:45:41,680
a converter test for

00:45:38,240 --> 00:45:46,800
ld uh that it reads

00:45:41,680 --> 00:45:49,920
the the debug range this correctly uh

00:45:46,800 --> 00:45:52,960
but then i think what we want is

00:45:49,920 --> 00:45:57,359
uh uh from the the

00:45:52,960 --> 00:46:00,800
the sm spec pass on the dwarf version to

00:45:57,359 --> 00:46:03,920
the assembler i looked at it but

00:46:00,800 --> 00:46:06,079
i have spec files if somebody can help

00:46:03,920 --> 00:46:09,920
me there that would be

00:46:06,079 --> 00:46:12,480
appreciated i guess uh well uh if you

00:46:09,920 --> 00:46:15,359
can come up with with a test

00:46:12,480 --> 00:46:16,079
which can be used during configure for

00:46:15,359 --> 00:46:18,319
well

00:46:16,079 --> 00:46:19,520
it depends either either we just turn on

00:46:18,319 --> 00:46:22,800
the switch whenever

00:46:19,520 --> 00:46:25,200
uh assembler supports the switch that's

00:46:22,800 --> 00:46:26,000
very easy and that can be done and i can

00:46:25,200 --> 00:46:29,599
do it

00:46:26,000 --> 00:46:31,680
or or we do some correctness test

00:46:29,599 --> 00:46:35,040
whether whether assembler

00:46:31,680 --> 00:46:36,319
emits something correct and in that case

00:46:35,040 --> 00:46:39,119
we need to find out

00:46:36,319 --> 00:46:40,839
what the box where and how to how to

00:46:39,119 --> 00:46:43,839
detect buggy

00:46:40,839 --> 00:46:43,839
assembly

00:46:46,800 --> 00:46:49,440
for you okay

00:46:54,000 --> 00:47:03,119
um so this is basically what i had for

00:46:59,119 --> 00:47:07,119
uh to r5 i would really like

00:47:03,119 --> 00:47:08,839
to see if we can enable to our five by

00:47:07,119 --> 00:47:11,920
default

00:47:08,839 --> 00:47:14,560
now uh because

00:47:11,920 --> 00:47:16,400
if we don't enable it we don't find the

00:47:14,560 --> 00:47:20,400
bugs in the consumers

00:47:16,400 --> 00:47:23,599
uh and

00:47:20,400 --> 00:47:27,440
if the consumers don't

00:47:23,599 --> 00:47:28,000
aren't ready by the time we get to stage

00:47:27,440 --> 00:47:30,480
one

00:47:28,000 --> 00:47:31,920
then maybe we can switch it back that

00:47:30,480 --> 00:47:34,559
would be my

00:47:31,920 --> 00:47:34,559
suggestion

00:47:36,839 --> 00:47:43,520
okay uh

00:47:40,000 --> 00:47:46,559
some bonus discussions for

00:47:43,520 --> 00:47:48,240
the last 10 minutes uh i don't have

00:47:46,559 --> 00:47:53,040
betters for this

00:47:48,240 --> 00:47:56,800
um although i think the patches aren't

00:47:53,040 --> 00:48:00,000
too uh too hard

00:47:56,800 --> 00:48:02,400
uh so first is

00:48:00,000 --> 00:48:03,040
i think it would be an interesting idea

00:48:02,400 --> 00:48:07,440
to have an

00:48:03,040 --> 00:48:10,559
f12 64 f432

00:48:07,440 --> 00:48:14,559
uh switch which simply says

00:48:10,559 --> 00:48:18,960
offsets are 32-bit or 64-bit

00:48:14,559 --> 00:48:23,280
uh because there are currently uh

00:48:18,960 --> 00:48:27,040
programs that run out of uh 32-bit

00:48:23,280 --> 00:48:29,599
uh debug info or debug string sections

00:48:27,040 --> 00:48:32,079
and i can't reference them anymore

00:48:29,599 --> 00:48:32,079
um

00:48:32,800 --> 00:48:38,160
i think it's an interesting idea but

00:48:34,800 --> 00:48:38,160
maybe it's stupid

00:48:41,599 --> 00:48:46,559
did you measure the overhead of mark 64

00:48:44,800 --> 00:48:48,559
because i think in such cases it's

00:48:46,559 --> 00:48:52,400
already better to use split dwarf which

00:48:48,559 --> 00:48:55,920
has overhang just about eight percent

00:48:52,400 --> 00:48:58,720
yeah yeah yeah it it is but

00:48:55,920 --> 00:49:00,000
on the other hand the debugger is

00:48:58,720 --> 00:49:03,520
already

00:49:00,000 --> 00:49:06,880
ginormous solved and

00:49:03,520 --> 00:49:09,599
it would be a quick solution the only

00:49:06,880 --> 00:49:11,040
problem is everything needs to be

00:49:09,599 --> 00:49:15,040
compiled with

00:49:11,040 --> 00:49:19,040
uh either uh

00:49:15,040 --> 00:49:22,400
or because otherwise cus can't reference

00:49:19,040 --> 00:49:24,960
all others to use the problem is that

00:49:22,400 --> 00:49:27,359
for example db has completely dropped

00:49:24,960 --> 00:49:31,839
all the code for dark 64 because there

00:49:27,359 --> 00:49:31,839
is no use for it because

00:49:36,000 --> 00:49:43,200
oh okay that's interesting because

00:49:39,680 --> 00:49:45,760
most other things

00:49:43,200 --> 00:49:47,599
seem to it's it's not that hard to add

00:49:45,760 --> 00:49:51,359
of course because

00:49:47,599 --> 00:49:53,359
you could just read the header uh

00:49:51,359 --> 00:49:55,359
i i think it would be still nice to

00:49:53,359 --> 00:49:57,200
enable it so that

00:49:55,359 --> 00:49:59,119
something can be actually tested this

00:49:57,200 --> 00:50:00,640
because right now there are no producers

00:49:59,119 --> 00:50:03,200
so nobody does it

00:50:00,640 --> 00:50:04,079
except that gtcc supports it on some

00:50:03,200 --> 00:50:07,359
dead iris

00:50:04,079 --> 00:50:11,440
starjet or something yeah and

00:50:07,359 --> 00:50:14,559
i believe spark for some reason uses it

00:50:11,440 --> 00:50:17,359
but anyway yeah um

00:50:14,559 --> 00:50:19,359
then the question is what what switch

00:50:17,359 --> 00:50:22,240
because there is the

00:50:19,359 --> 00:50:23,839
big debate whether it should be f minus

00:50:22,240 --> 00:50:27,359
f something or minus g

00:50:23,839 --> 00:50:31,040
something and whether it should take

00:50:27,359 --> 00:50:34,559
equals 32 or 64 or

00:50:31,040 --> 00:50:37,520
minus 32 or 64

00:50:34,559 --> 00:50:38,640
and so on so we need to decide how to

00:50:37,520 --> 00:50:41,119
name it

00:50:38,640 --> 00:50:42,640
but otherwise the support really is

00:50:41,119 --> 00:50:45,920
there just

00:50:42,640 --> 00:50:49,119
right now is is compile time rather oh

00:50:45,920 --> 00:50:52,640
well it's behind a macro rather than

00:50:49,119 --> 00:50:56,160
behind an option yeah okay

00:50:52,640 --> 00:50:57,359
only three minutes let's this is the

00:50:56,160 --> 00:51:00,559
other idea

00:50:57,359 --> 00:51:03,839
um uh

00:51:00,559 --> 00:51:08,160
currently split dwarf is kind of

00:51:03,839 --> 00:51:11,359
harder um

00:51:08,160 --> 00:51:12,559
because it generates a separate file

00:51:11,359 --> 00:51:17,440
which makes things

00:51:12,559 --> 00:51:17,440
hard with build systems

00:51:18,960 --> 00:51:26,079
clang actually has a cute hack that i

00:51:22,000 --> 00:51:29,119
believe lto also uses use shf

00:51:26,079 --> 00:51:32,880
excludes for the pwo

00:51:29,119 --> 00:51:36,800
sections keep them in the same file

00:51:32,880 --> 00:51:39,839
and uh

00:51:36,800 --> 00:51:42,160
uh then the linker ignores them

00:51:39,839 --> 00:51:43,760
they are still disk of course but they

00:51:42,160 --> 00:51:48,839
want to be in

00:51:43,760 --> 00:51:52,319
uh the links object

00:51:48,839 --> 00:51:56,079
um uh

00:51:52,319 --> 00:51:56,960
this is actually uh supported by gdb

00:51:56,079 --> 00:51:59,040
alfie

00:51:56,960 --> 00:52:00,160
those doesn't but i have some patches

00:51:59,040 --> 00:52:04,640
that

00:52:00,160 --> 00:52:06,880
uh work with this format i think it's

00:52:04,640 --> 00:52:08,079
interesting on the other hand i'm not

00:52:06,880 --> 00:52:11,520
completely sure

00:52:08,079 --> 00:52:16,000
people really like split twerf that much

00:52:11,520 --> 00:52:16,000
so um

00:52:16,839 --> 00:52:24,720
yeah i guess we have one minute left

00:52:21,520 --> 00:52:28,240
to do the big debug types

00:52:24,720 --> 00:52:33,040
uh discussion um

00:52:28,240 --> 00:52:37,119
uh young did some uh measurements

00:52:33,040 --> 00:52:40,319
uh i think

00:52:37,119 --> 00:52:42,400
doing it after the link is still more

00:52:40,319 --> 00:52:45,760
beneficial but of course

00:52:42,400 --> 00:52:46,960
if you can do the application before the

00:52:45,760 --> 00:52:51,119
link phase

00:52:46,960 --> 00:52:51,119
or during the link phase i think that's

00:52:51,200 --> 00:52:57,760
nice i think

00:52:54,640 --> 00:53:01,839
it is a bit of a natural fit for the

00:52:57,760 --> 00:53:01,839
early debug scheme

00:53:02,480 --> 00:53:09,440
on the other hand it

00:53:05,760 --> 00:53:14,160
makes it harder to reference

00:53:09,440 --> 00:53:17,440
anything except the big types uh

00:53:14,160 --> 00:53:20,319
and uh referencing has a large overhead

00:53:17,440 --> 00:53:22,800
i don't know if people want to look at

00:53:20,319 --> 00:53:22,800
into this

00:53:25,040 --> 00:53:29,440
i think that's the time let's see when

00:53:27,200 --> 00:53:32,079
we are getting

00:53:29,440 --> 00:53:32,079
moved away

00:53:33,760 --> 00:53:40,079
you know maybe i asked if there is

00:53:36,880 --> 00:53:41,119
therefore a plan to pour the dw02 r5

00:53:40,079 --> 00:53:43,359
that was discussed

00:53:41,119 --> 00:53:45,520
before i haven't seen such fun so far

00:53:43,359 --> 00:53:45,520
but

00:53:50,079 --> 00:53:57,440
yeah so yeah so

00:53:53,520 --> 00:54:00,960
one thing could be to

00:53:57,440 --> 00:54:03,680
emit them and then have dwc

00:54:00,960 --> 00:54:06,160
actually remove them again make them

00:54:03,680 --> 00:54:06,160
normal

00:54:08,839 --> 00:54:13,599
references

00:54:10,640 --> 00:54:14,800
now i didn't know the debug types

00:54:13,599 --> 00:54:17,040
specifically but

00:54:14,800 --> 00:54:18,400
more about bar five because these wizard

00:54:17,040 --> 00:54:24,319
currently does not support

00:54:18,400 --> 00:54:24,319
var5 so if there is the plan to port it

00:54:36,960 --> 00:54:43,040
um so it's not currently on my list is

00:54:40,000 --> 00:54:43,040
what i can say about it

00:54:43,760 --> 00:54:49,119
yeah but well then i put it on my list

00:54:51,119 --> 00:54:57,440
uh so i uh yeah we we we have to

00:54:54,160 --> 00:55:00,720
wrap up but um i think

00:54:57,440 --> 00:55:03,599
the plane dwc uh

00:55:00,720 --> 00:55:06,160
support for to r5 at least to r5s

00:55:03,599 --> 00:55:08,960
emitted by gc isn't that hard and

00:55:06,160 --> 00:55:11,359
i i can do that and now jeremy is going

00:55:08,960 --> 00:55:14,079
to save you yeah

00:55:11,359 --> 00:55:15,839
okay sorry running out of time it's okay

00:55:14,079 --> 00:55:17,680
we did allow five minute gap just to

00:55:15,839 --> 00:55:19,599
allow you know that rounding off

00:55:17,680 --> 00:55:21,760
hack room two is still going strong full

00:55:19,599 --> 00:55:23,680
of gdb types so i suggest

00:55:21,760 --> 00:55:24,880
let's transfer this conversation over to

00:55:23,680 --> 00:55:28,720
hackroom too for

00:55:24,880 --> 00:55:30,960
all the uh for going into more dwarf

00:55:28,720 --> 00:55:32,319
it's a it's a great topic and if i

00:55:30,960 --> 00:55:34,240
weren't supposed to be here moderating

00:55:32,319 --> 00:55:37,520
i'd be over there piling in as well

00:55:34,240 --> 00:55:39,200
so thank you very much mark um and um

00:55:37,520 --> 00:55:41,440
in a couple of minutes we'll move on to

00:55:39,200 --> 00:55:43,920
lightning talks

00:55:41,440 --> 00:55:43,920
thank you

00:55:45,359 --> 00:55:48,400
i should know i've taken some notes

00:55:46,960 --> 00:55:50,319
they're in the shared notes

00:55:48,400 --> 00:55:52,400
area we will get those captured them and

00:55:50,319 --> 00:56:03,839
pushed up to the

00:55:52,400 --> 00:56:03,839
wiki if nowhere else

00:56:20,319 --> 00:56:23,839
that's great frank thank you

00:56:23,920 --> 00:56:28,960
i will let you

00:56:27,440 --> 00:56:30,640
if you haven't done so already please

00:56:28,960 --> 00:56:33,920
take the presenter

00:56:30,640 --> 00:56:35,839
over you have done it great

00:56:33,920 --> 00:56:36,960
um we'll just wait to the top of the

00:56:35,839 --> 00:56:38,720
hour before

00:56:36,960 --> 00:56:45,839
carrying on just to give anyone such

00:56:38,720 --> 00:56:45,839
another chance to carry on

00:57:23,520 --> 00:57:29,599
are you you're good invisible frank

00:57:27,359 --> 00:57:31,520
we can hear you eliminate any signs of

00:57:29,599 --> 00:57:33,440
personality from the backdrop so uh

00:57:31,520 --> 00:57:35,839
i should be as as mellow and mild as

00:57:33,440 --> 00:57:41,839
possible today

00:57:35,839 --> 00:57:41,839
the benefits of my bedroom there you go

00:57:42,960 --> 00:57:49,200
right um okay so uh frank

00:57:46,559 --> 00:57:51,040
it's um we've got two of these to fit in

00:57:49,200 --> 00:57:52,240
the half hour so we'll flag up

00:57:51,040 --> 00:57:54,640
five minutes three minutes and one

00:57:52,240 --> 00:57:57,839
minute for a 10 minute slot and then

00:57:54,640 --> 00:58:01,119
that should give you a good lightning

00:57:57,839 --> 00:58:01,119
time sounds good

00:58:02,319 --> 00:58:09,839
half a minute to go exciting

00:58:13,040 --> 00:58:18,400
aaron if you're in a cold you should uh

00:58:15,200 --> 00:58:18,400
let's see let's get you into the

00:58:20,000 --> 00:58:24,160
uh he's showing in the list of he's the

00:58:22,160 --> 00:58:27,839
sharing in the list of attendees

00:58:24,160 --> 00:58:29,200
um can i designate him a presenter also

00:58:27,839 --> 00:58:31,119
uh because he'll be sharing his screen

00:58:29,200 --> 00:58:34,240
to do good all right yeah

00:58:31,119 --> 00:58:35,599
if you can't i can and if you think

00:58:34,240 --> 00:58:37,280
that's it yeah you've made him a

00:58:35,599 --> 00:58:38,640
presenter for ray

00:58:37,280 --> 00:58:40,559
so yeah he'll be showing his screen to

00:58:38,640 --> 00:58:42,079
show a little demo um at the appropriate

00:58:40,559 --> 00:58:44,880
moment

00:58:42,079 --> 00:58:46,160
okay that's good okay you're good to go

00:58:44,880 --> 00:58:48,640
it's the top of the hour

00:58:46,160 --> 00:58:50,240
let us away thank you all for coming i'm

00:58:48,640 --> 00:58:51,680
surprised so many folks showed up i'm

00:58:50,240 --> 00:58:53,440
very happy to see you guys

00:58:51,680 --> 00:58:54,960
hello i'm frank agler i'm a redhead

00:58:53,440 --> 00:58:56,720
developer aaron

00:58:54,960 --> 00:58:58,240
my close personal friend is another red

00:58:56,720 --> 00:59:00,720
hat developer and we're here to talk to

00:58:58,240 --> 00:59:05,280
you about debugging for d

00:59:00,720 --> 00:59:05,839
ah let's see do i advance these pages oh

00:59:05,280 --> 00:59:08,079
no

00:59:05,839 --> 00:59:08,079
god

00:59:10,799 --> 00:59:13,920
frank you need to be presented while

00:59:12,240 --> 00:59:17,040
you're presenting so take over

00:59:13,920 --> 00:59:18,000
there's only one presenter well that

00:59:17,040 --> 00:59:20,160
explains everything

00:59:18,000 --> 00:59:21,520
all right very good let us move on to

00:59:20,160 --> 00:59:24,640
slide two and let's get it over with

00:59:21,520 --> 00:59:26,400
very good debugging for d is a

00:59:24,640 --> 00:59:27,920
program dealing with debug info what is

00:59:26,400 --> 00:59:30,400
debug info it is uh

00:59:27,920 --> 00:59:31,599
dwarf debugging data that uh those of

00:59:30,400 --> 00:59:33,680
you who heard

00:59:31,599 --> 00:59:37,200
mark's talk in our last few last half

00:59:33,680 --> 00:59:38,799
hour will be totally familiar with

00:59:37,200 --> 00:59:40,559
we are talking more about the logistics

00:59:38,799 --> 00:59:42,480
as opposed to details of the format here

00:59:40,559 --> 00:59:43,599
so logistics are interesting to us

00:59:42,480 --> 00:59:46,400
because debug info

00:59:43,599 --> 00:59:47,920
as he says as we all know is large and

00:59:46,400 --> 00:59:50,880
is not routinely distributed

00:59:47,920 --> 00:59:51,520
on every place where uh where it should

00:59:50,880 --> 00:59:54,160
be

00:59:51,520 --> 00:59:54,720
uh so we just stripped and it's large so

00:59:54,160 --> 00:59:57,359
uh and

00:59:54,720 --> 00:59:59,280
that makes debugging uh very difficult

00:59:57,359 --> 01:00:02,160
to impossible at times so

00:59:59,280 --> 01:00:02,640
debugging for d is an effort as a tool

01:00:02,160 --> 01:00:04,640
to

01:00:02,640 --> 01:00:06,720
make the distribution of that debug info

01:00:04,640 --> 01:00:10,079
as easy as possible

01:00:06,720 --> 01:00:10,400
after the fact and it's been this it's

01:00:10,079 --> 01:00:12,559
been

01:00:10,400 --> 01:00:13,680
public for about nine months now it's

01:00:12,559 --> 01:00:16,400
part of alpha utils

01:00:13,680 --> 01:00:17,359
0.178 and a bunch of distros shipped it

01:00:16,400 --> 01:00:20,559
already

01:00:17,359 --> 01:00:24,480
and we hope many more of them do

01:00:20,559 --> 01:00:25,760
slide three all right

01:00:24,480 --> 01:00:28,160
so two like this is nothing without

01:00:25,760 --> 01:00:31,119
client support we want

01:00:28,160 --> 01:00:31,839
all debugging type tools to be able to

01:00:31,119 --> 01:00:33,760
pull down

01:00:31,839 --> 01:00:36,079
the debug and flowing and source code

01:00:33,760 --> 01:00:38,960
from this type of service

01:00:36,079 --> 01:00:40,960
so we spent mostly aaron has spent a lot

01:00:38,960 --> 01:00:43,599
of effort in making sure that

01:00:40,960 --> 01:00:44,799
standard debugger like tools can handle

01:00:43,599 --> 01:00:46,079
this thing

01:00:44,799 --> 01:00:48,160
so there have been patches that have

01:00:46,079 --> 01:00:50,240
been merged into gb and released all

01:00:48,160 --> 01:00:51,040
over the place and uh system tab perf i

01:00:50,240 --> 01:00:55,200
think those

01:00:51,040 --> 01:00:58,000
dynams etc etc etc so we have a suite of

01:00:55,200 --> 01:00:58,960
debugging for consuming tools out there

01:00:58,000 --> 01:01:00,400
um

01:00:58,960 --> 01:01:02,160
we haven't gotten to all of zero all of

01:01:00,400 --> 01:01:04,079
them and we have a status page

01:01:02,160 --> 01:01:06,000
that i'll show at the end which

01:01:04,079 --> 01:01:07,440
indicates which

01:01:06,000 --> 01:01:09,359
would still appreciate a lot of help

01:01:07,440 --> 01:01:10,720
with

01:01:09,359 --> 01:01:12,720
the nice thing is that there's a little

01:01:10,720 --> 01:01:13,440
library that a c library and a shell

01:01:12,720 --> 01:01:14,799
script

01:01:13,440 --> 01:01:18,000
or a shell command interface that's

01:01:14,799 --> 01:01:20,079
available the c library is so small that

01:01:18,000 --> 01:01:21,119
and so kind of easy to use that it takes

01:01:20,079 --> 01:01:24,000
only about a dozen

01:01:21,119 --> 01:01:25,520
two dozen lines to add client-side

01:01:24,000 --> 01:01:27,040
support code

01:01:25,520 --> 01:01:29,119
and all this works because of the magic

01:01:27,040 --> 01:01:32,400
of build ids which is a

01:01:29,119 --> 01:01:34,000
unique hexadecimal unique binary hash

01:01:32,400 --> 01:01:35,520
that's built into every binary that's

01:01:34,000 --> 01:01:38,000
built by

01:01:35,520 --> 01:01:39,839
modern compiler or tool chain since well

01:01:38,000 --> 01:01:41,760
gosh a decade now

01:01:39,839 --> 01:01:43,200
at least on linux but equivalent things

01:01:41,760 --> 01:01:44,319
are available elsewhere too to some

01:01:43,200 --> 01:01:47,760
extent

01:01:44,319 --> 01:01:50,559
anyway so that client gets the debug

01:01:47,760 --> 01:01:51,839
gets the build id out of the target

01:01:50,559 --> 01:01:53,760
binder that's trying to debug whether

01:01:51,839 --> 01:01:57,200
it's a process or a dead file

01:01:53,760 --> 01:02:00,559
sends it to the server and gets back the

01:01:57,200 --> 01:02:01,440
binary code or debug info or source code

01:02:00,559 --> 01:02:04,559
source file

01:02:01,440 --> 01:02:04,559
that is necessary

01:02:04,720 --> 01:02:09,359
i yeah i book shelves ben i will draw

01:02:08,160 --> 01:02:10,880
bookshelves for next time i give this

01:02:09,359 --> 01:02:14,400
talk how about that there you go

01:02:10,880 --> 01:02:16,160
so anyway uh the easiest way to use uh

01:02:14,400 --> 01:02:17,599
there's a single uniform a configuration

01:02:16,160 --> 01:02:18,880
for all these clients to talk to these

01:02:17,599 --> 01:02:21,440
servers it's an environment variable

01:02:18,880 --> 01:02:24,880
called debugging for the underscore urls

01:02:21,440 --> 01:02:26,640
and that's it you set it to a server and

01:02:24,880 --> 01:02:28,559
it that's all everything else is just

01:02:26,640 --> 01:02:29,440
automatic the source code everything

01:02:28,559 --> 01:02:34,960
just downloads

01:02:29,440 --> 01:02:38,640
on the fly and it's as fast as possible

01:02:34,960 --> 01:02:39,839
servers well so uh part of the uh

01:02:38,640 --> 01:02:41,119
debugging for the

01:02:39,839 --> 01:02:43,200
work is of course not just the client

01:02:41,119 --> 01:02:43,680
library but the server itself this is a

01:02:43,200 --> 01:02:47,039
small

01:02:43,680 --> 01:02:48,799
uh very fairly small c plus plus program

01:02:47,039 --> 01:02:50,720
it's self-contained it's very well

01:02:48,799 --> 01:02:53,119
behaved so it runs well as a container

01:02:50,720 --> 01:02:54,240
runs well as a systemd service runs well

01:02:53,119 --> 01:02:56,480
as a hand-started

01:02:54,240 --> 01:02:58,720
uh little gadget it's a small

01:02:56,480 --> 01:03:01,440
purposefully small program

01:02:58,720 --> 01:03:03,280
you aim it at some directories whether

01:03:01,440 --> 01:03:06,400
it's a build trick full of

01:03:03,280 --> 01:03:07,680
binaries that you made or rpms or wm

01:03:06,400 --> 01:03:10,240
files or whatever

01:03:07,680 --> 01:03:12,000
kind of standard archiving formats are

01:03:10,240 --> 01:03:13,839
distro formats uh you just

01:03:12,000 --> 01:03:15,599
download a bunch tell the server what

01:03:13,839 --> 01:03:17,520
directory they're in it will

01:03:15,599 --> 01:03:19,839
sort of transparently decompress them

01:03:17,520 --> 01:03:21,680
index the contents by build id

01:03:19,839 --> 01:03:24,160
and then be immediately ready to serve

01:03:21,680 --> 01:03:26,559
those contents via http

01:03:24,160 --> 01:03:28,640
so it does not need to you know unpack

01:03:26,559 --> 01:03:32,319
everything it does not need a weird

01:03:28,640 --> 01:03:34,160
custom file system hierarchy it just

01:03:32,319 --> 01:03:36,079
gives you the content on the fly without

01:03:34,160 --> 01:03:38,160
any sort of temporary

01:03:36,079 --> 01:03:41,520
you know extra storage it's monitorable

01:03:38,160 --> 01:03:41,520
via prometheus as it should be

01:03:42,319 --> 01:03:47,680
it so just question about abort uh it

01:03:46,160 --> 01:03:49,119
it kind of supplements the retrace

01:03:47,680 --> 01:03:50,720
server we actually would like to have

01:03:49,119 --> 01:03:53,280
those guys use us as a

01:03:50,720 --> 01:03:54,960
debug ufo uh source as opposed to having

01:03:53,280 --> 01:03:56,839
to upload a core file somewhere else for

01:03:54,960 --> 01:03:59,599
analysis

01:03:56,839 --> 01:04:00,640
um uh we're getting peter's idea making

01:03:59,599 --> 01:04:02,960
user lovely bug

01:04:00,640 --> 01:04:04,720
uh fuse mount uh that's a possibility

01:04:02,960 --> 01:04:07,119
there there's another project um

01:04:04,720 --> 01:04:08,559
gosh i forget who built it that that

01:04:07,119 --> 01:04:11,119
worked kind of like that

01:04:08,559 --> 01:04:12,400
this is a much lower uh complexity kind

01:04:11,119 --> 01:04:14,480
of solution than that but

01:04:12,400 --> 01:04:15,520
it we we have considered that but it's

01:04:14,480 --> 01:04:19,280
not yeah

01:04:15,520 --> 01:04:21,440
exactly anywho

01:04:19,280 --> 01:04:23,839
let us move on to the next slide keeping

01:04:21,440 --> 01:04:25,920
things going

01:04:23,839 --> 01:04:27,599
uh we have at least one or two we have a

01:04:25,920 --> 01:04:29,280
couple of public servers already i don't

01:04:27,599 --> 01:04:31,920
do wide open internet

01:04:29,280 --> 01:04:33,680
uh this debug info detailfutions.org is

01:04:31,920 --> 01:04:35,119
already open has been serviced for six

01:04:33,680 --> 01:04:37,359
months or so now

01:04:35,119 --> 01:04:38,400
it carries packages from uh fedora

01:04:37,359 --> 01:04:41,200
santos debian

01:04:38,400 --> 01:04:43,440
ubuntu uh the opensuse friends of ours

01:04:41,200 --> 01:04:45,839
have run their own server for tumbleweed

01:04:43,440 --> 01:04:46,559
which is always kept up to date and we

01:04:45,839 --> 01:04:48,799
are

01:04:46,559 --> 01:04:50,000
you know anticipating over time would

01:04:48,799 --> 01:04:51,920
like uh

01:04:50,000 --> 01:04:53,359
more distros to run them isvs can run

01:04:51,920 --> 01:04:54,000
them like you know mozilla foundation

01:04:53,359 --> 01:04:55,839
can run for

01:04:54,000 --> 01:04:57,520
any binaries they distribute and then

01:04:55,839 --> 01:04:59,520
that will make that stuff

01:04:57,520 --> 01:05:00,880
uh downloadable i know mozilla has their

01:04:59,520 --> 01:05:03,520
own system but again

01:05:00,880 --> 01:05:04,640
this is uh this can function as a more

01:05:03,520 --> 01:05:08,319
cross isv

01:05:04,640 --> 01:05:13,039
standard kind of thing um

01:05:08,319 --> 01:05:15,119
all right and that's it

01:05:13,039 --> 01:05:16,400
double time over to aaron so let me see

01:05:15,119 --> 01:05:20,480
if i can designate him

01:05:16,400 --> 01:05:20,480
presenter and he can show us this thing

01:05:20,839 --> 01:05:23,839
working

01:05:25,200 --> 01:05:28,480
can everyone hear me okay

01:05:34,400 --> 01:05:38,240
yeah loud and clear anything too too

01:05:36,880 --> 01:05:40,400
loud and too clear

01:05:38,240 --> 01:05:44,000
okay i'll try to back up a bit i'm

01:05:40,400 --> 01:05:46,880
trying to share my screen

01:05:44,000 --> 01:05:46,880
one second

01:05:50,079 --> 01:05:55,920
it's always that that is screen sharing

01:05:53,520 --> 01:05:55,920
hello

01:05:56,880 --> 01:06:00,640
okay i see something happening am i am i

01:05:59,440 --> 01:06:04,480
uh too loud now

01:06:00,640 --> 01:06:06,640
is this all right just carry on

01:06:04,480 --> 01:06:08,160
okay um all right hi everyone going to

01:06:06,640 --> 01:06:10,559
give a brief demonstration of how to use

01:06:08,160 --> 01:06:12,799
debugging foodie with system tap and gdb

01:06:10,559 --> 01:06:14,000
i'm going to start with system tap uh

01:06:12,799 --> 01:06:16,000
our goal here

01:06:14,000 --> 01:06:18,000
is to instrument a process with a system

01:06:16,000 --> 01:06:19,760
tap probe that prints a timed call graph

01:06:18,000 --> 01:06:22,000
with function parameters and return

01:06:19,760 --> 01:06:23,280
values uh in order to do so we're going

01:06:22,000 --> 01:06:24,720
to need debug information for the

01:06:23,280 --> 01:06:26,319
process we wish to instrument

01:06:24,720 --> 01:06:27,920
if we don't have this then system tap's

01:06:26,319 --> 01:06:28,720
not going to be able to compile the

01:06:27,920 --> 01:06:30,880
probe

01:06:28,720 --> 01:06:33,359
so the command the command we want to

01:06:30,880 --> 01:06:33,680
run uh is this here we're instrumenting

01:06:33,359 --> 01:06:36,799
the

01:06:33,680 --> 01:06:37,520
tree executable um and since we don't

01:06:36,799 --> 01:06:40,000
have

01:06:37,520 --> 01:06:41,039
oh that noises should be disabled but oh

01:06:40,000 --> 01:06:42,319
well um

01:06:41,039 --> 01:06:44,160
since we don't have a debug info

01:06:42,319 --> 01:06:46,319
installed uh

01:06:44,160 --> 01:06:48,559
the the compilation fails we could

01:06:46,319 --> 01:06:50,160
manually use dnf to install

01:06:48,559 --> 01:06:51,760
the debug info but this isn't always

01:06:50,160 --> 01:06:53,839
convenient or possible

01:06:51,760 --> 01:06:55,920
so let's start up a debug m4d server

01:06:53,839 --> 01:06:57,359
that has index the debug info we're

01:06:55,920 --> 01:07:00,880
looking for

01:06:57,359 --> 01:07:04,319
so that's stored in this build directory

01:07:00,880 --> 01:07:07,440
and i'll start up the server

01:07:04,319 --> 01:07:07,440
using this command

01:07:08,720 --> 01:07:12,880
so the server has indexed those files

01:07:11,920 --> 01:07:15,760
that the

01:07:12,880 --> 01:07:18,000
tree building profiles and when i try

01:07:15,760 --> 01:07:21,760
running the system tap script again

01:07:18,000 --> 01:07:21,760
things should work properly this time

01:07:22,000 --> 01:07:26,079
which you can see here since the

01:07:24,799 --> 01:07:28,079
executables

01:07:26,079 --> 01:07:29,920
share build ids with their debug info

01:07:28,079 --> 01:07:31,280
system top is able to query the server

01:07:29,920 --> 01:07:33,039
for the missing debug info

01:07:31,280 --> 01:07:35,760
using the build id of finds in the tree

01:07:33,039 --> 01:07:36,880
executable so on the left here you can

01:07:35,760 --> 01:07:38,880
see

01:07:36,880 --> 01:07:40,480
the server received a request for trees

01:07:38,880 --> 01:07:42,960
debug info and on the right

01:07:40,480 --> 01:07:44,880
the instrumented tree process was ran

01:07:42,960 --> 01:07:46,319
and system top was able to successfully

01:07:44,880 --> 01:07:49,200
produce the call graph

01:07:46,319 --> 01:07:51,039
using debug info got from the server

01:07:49,200 --> 01:07:53,440
another feature of system top

01:07:51,039 --> 01:07:54,079
that uses debugging 4d is the ability to

01:07:53,440 --> 01:07:56,400
specify

01:07:54,079 --> 01:07:58,160
probe targets according to build id then

01:07:56,400 --> 01:07:58,880
we want to instrument an executable we

01:07:58,160 --> 01:08:00,559
generally

01:07:58,880 --> 01:08:02,319
with system type we specify either the

01:08:00,559 --> 01:08:05,039
path of the executable or a

01:08:02,319 --> 01:08:06,160
process id but debug mpd now gives us an

01:08:05,039 --> 01:08:08,480
easy way to target

01:08:06,160 --> 01:08:10,160
a specific build of an executable with

01:08:08,480 --> 01:08:13,119
its build id

01:08:10,160 --> 01:08:14,240
so here's another snap command that's

01:08:13,119 --> 01:08:16,400
the same as the last one except i've

01:08:14,240 --> 01:08:18,640
replaced the path of the tree executable

01:08:16,400 --> 01:08:23,440
with the the build id of that specific

01:08:18,640 --> 01:08:27,120
uh tree executable um

01:08:23,440 --> 01:08:30,239
and now i will run the server i will uh

01:08:27,120 --> 01:08:33,040
run that command and in this case

01:08:30,239 --> 01:08:34,799
uh system tab queries the server for the

01:08:33,040 --> 01:08:36,400
tree executable in addition to the debug

01:08:34,799 --> 01:08:38,239
info so that it is able to

01:08:36,400 --> 01:08:39,839
compile and run the probe which you can

01:08:38,239 --> 01:08:40,960
see on the right

01:08:39,839 --> 01:08:43,120
this feature is useful when you want to

01:08:40,960 --> 01:08:44,719
target a specific build of an executable

01:08:43,120 --> 01:08:46,960
or shared library or when you want to

01:08:44,719 --> 01:08:48,319
cross compile a system top module for a

01:08:46,960 --> 01:08:52,319
different platform

01:08:48,319 --> 01:08:55,040
so now i will show debug kodi working

01:08:52,319 --> 01:08:56,159
with gdb as it runs inside a fedora

01:08:55,040 --> 01:09:00,400
container

01:08:56,159 --> 01:09:00,400
i'll start up the container

01:09:01,199 --> 01:09:04,319
so for this example i'm simply going to

01:09:02,799 --> 01:09:06,319
run python 3

01:09:04,319 --> 01:09:07,839
under gdp and since this container

01:09:06,319 --> 01:09:10,719
doesn't have any debugging for source

01:09:07,839 --> 01:09:12,480
files installed for python 3 or globe c

01:09:10,719 --> 01:09:15,120
we're not going to get all too much

01:09:12,480 --> 01:09:17,440
information from gdb at this point

01:09:15,120 --> 01:09:19,520
which you can see here no debugging

01:09:17,440 --> 01:09:23,920
symbols found

01:09:19,520 --> 01:09:25,120
so we will uh index python the python3

01:09:23,920 --> 01:09:27,120
and glypc

01:09:25,120 --> 01:09:28,319
debugging for one source files which i

01:09:27,120 --> 01:09:31,199
have stored

01:09:28,319 --> 01:09:32,159
over here in this rpms directory and

01:09:31,199 --> 01:09:34,640
i'll

01:09:32,159 --> 01:09:36,400
index them with the debugging 4d server

01:09:34,640 --> 01:09:38,159
using this command

01:09:36,400 --> 01:09:39,440
sorry to interrupt can you make the font

01:09:38,159 --> 01:09:41,279
a little bigger because

01:09:39,440 --> 01:09:42,480
here you can blow up the screen but in

01:09:41,279 --> 01:09:45,040
the live stream they

01:09:42,480 --> 01:09:46,880
they can't see very well sure thanks for

01:09:45,040 --> 01:09:50,000
that

01:09:46,880 --> 01:09:50,480
hopefully that's better um where was i

01:09:50,000 --> 01:09:53,359
yes

01:09:50,480 --> 01:09:53,359
rpms

01:09:53,759 --> 01:09:57,199
okay so it's going to take a moment to

01:09:56,000 --> 01:10:00,400
index all those

01:09:57,199 --> 01:10:04,080
python and globe crpms and

01:10:00,400 --> 01:10:08,159
i will um i will now

01:10:04,080 --> 01:10:10,560
point um gdb to the debug info ds

01:10:08,159 --> 01:10:13,040
server by setting this environment

01:10:10,560 --> 01:10:13,040
variable

01:10:13,280 --> 01:10:16,480
and whenever in gdb again we should see

01:10:15,199 --> 01:10:18,880
the extra output

01:10:16,480 --> 01:10:19,920
from the so you see extra output

01:10:18,880 --> 01:10:22,560
regarding files

01:10:19,920 --> 01:10:23,360
that gdb queries the debug info d server

01:10:22,560 --> 01:10:26,640
for

01:10:23,360 --> 01:10:28,320
so let's run gdp again

01:10:26,640 --> 01:10:31,120
in this case we can see downloading

01:10:28,320 --> 01:10:34,320
separate debug info for python 3

01:10:31,120 --> 01:10:36,239
and some other debug info files

01:10:34,320 --> 01:10:38,080
so now gdb has access to the debug info

01:10:36,239 --> 01:10:40,880
and when i run python 3

01:10:38,080 --> 01:10:42,640
gb is going to query debug info d for

01:10:40,880 --> 01:10:44,080
debug info of any shared libraries that

01:10:42,640 --> 01:10:47,440
are dynamically linked

01:10:44,080 --> 01:10:49,440
which we can see here and

01:10:47,440 --> 01:10:50,560
as i attempt to print source files

01:10:49,440 --> 01:10:52,800
associated with

01:10:50,560 --> 01:10:54,320
uh each stack frame gdb is going to

01:10:52,800 --> 01:10:57,040
query debugging for the for

01:10:54,320 --> 01:10:58,320
each source file one at a time as a

01:10:57,040 --> 01:11:00,000
attempts to

01:10:58,320 --> 01:11:01,360
as a realize that it doesn't happen

01:11:00,000 --> 01:11:01,920
locally it will attempt to query the

01:11:01,360 --> 01:11:03,600
server

01:11:01,920 --> 01:11:05,520
so here you can see downloading source

01:11:03,600 --> 01:11:07,679
file select dot c

01:11:05,520 --> 01:11:09,360
and as i go up the call stack it will

01:11:07,679 --> 01:11:10,640
download whatever source files that it's

01:11:09,360 --> 01:11:14,320
locking

01:11:10,640 --> 01:11:17,040
and that's it all right aaron uh

01:11:14,320 --> 01:11:19,360
thanks for the demo uh the time is up so

01:11:17,040 --> 01:11:22,800
we'll have to switch to the other

01:11:19,360 --> 01:11:23,120
part but that's good and that's all we

01:11:22,800 --> 01:11:26,719
have

01:11:23,120 --> 01:11:29,760
um let's see just the very final state

01:11:26,719 --> 01:11:31,280
slide uh a url there has the current

01:11:29,760 --> 01:11:32,480
status including all the uh various

01:11:31,280 --> 01:11:34,000
servers that are available and the

01:11:32,480 --> 01:11:35,280
clients that are there and including

01:11:34,000 --> 01:11:37,120
patches and stuff

01:11:35,280 --> 01:11:38,880
and we welcome irc discussions and of

01:11:37,120 --> 01:11:40,320
course mailing lists

01:11:38,880 --> 01:11:42,159
we'll head over to one of the hack rooms

01:11:40,320 --> 01:11:43,120
to to continue further chatting that

01:11:42,159 --> 01:11:44,800
people are interested in

01:11:43,120 --> 01:11:47,199
and thank you thank you thank you for

01:11:44,800 --> 01:11:47,199
your time

01:11:48,159 --> 01:11:55,840
thank you thank you erin frank

01:12:03,440 --> 01:12:07,440
so we're going to prepare for the next

01:12:06,719 --> 01:12:11,040
petition

01:12:07,440 --> 01:12:14,080
uh teaching growl vmware fish debugging

01:12:11,040 --> 01:12:17,199
native java using gdb

01:12:14,080 --> 01:12:17,199
with android and

01:12:17,440 --> 01:12:24,960
so uh the talk is scheduled for

01:12:21,600 --> 01:12:26,800
11 15 i guess so but i

01:12:24,960 --> 01:12:28,640
nobody minds if we start one minute

01:12:26,800 --> 01:12:30,800
earlier

01:12:28,640 --> 01:12:34,560
i'm happy to wait until on the dot just

01:12:30,800 --> 01:12:34,560
in case anybody's coming along so yes

01:12:34,880 --> 01:12:38,880
can you wait for one minute if maybe

01:12:36,239 --> 01:12:40,960
people need to grab something or

01:12:38,880 --> 01:12:43,920
go to the restroom or whatever we'll

01:12:40,960 --> 01:12:43,920
start at precisely

01:12:44,719 --> 01:12:51,840
8 15 pacific time

01:13:02,840 --> 01:13:05,840
uh

01:13:28,880 --> 01:13:32,640
right i think that's actually on the dot

01:13:31,440 --> 01:13:35,120
so um

01:13:32,640 --> 01:13:36,800
i'll start i'm andrew dean i'm from red

01:13:35,120 --> 01:13:38,080
hat's java team and i'm going to talk to

01:13:36,800 --> 01:13:40,080
you today about work i'll be doing with

01:13:38,080 --> 01:13:40,960
the growl vm native image generator for

01:13:40,080 --> 01:13:42,880
java

01:13:40,960 --> 01:13:45,840
i've been teaching it to talk dwarfish

01:13:42,880 --> 01:13:47,199
or if you're a tolkien fan dwarvish

01:13:45,840 --> 01:13:49,760
that's basically allowing it to

01:13:47,199 --> 01:13:52,640
communicate with gdb

01:13:49,760 --> 01:13:53,760
so um let's start by saying what gravity

01:13:52,640 --> 01:13:56,080
of native edge

01:13:53,760 --> 01:13:57,760
native is the image generator is a way

01:13:56,080 --> 01:14:00,000
of taking a java application that's

01:13:57,760 --> 01:14:02,159
presented as either a suite of class

01:14:00,000 --> 01:14:04,800
files or library jars containing class

01:14:02,159 --> 01:14:06,239
files and turning it into a standalone

01:14:04,800 --> 01:14:07,840
self-contained binary

01:14:06,239 --> 01:14:09,520
you don't need to ship a jvm you don't

01:14:07,840 --> 01:14:11,440
need to ship all the class files

01:14:09,520 --> 01:14:13,360
you just choose a single image that you

01:14:11,440 --> 01:14:14,000
can executable you can put on your

01:14:13,360 --> 01:14:16,880
target machine

01:14:14,000 --> 01:14:18,719
and run it doesn't have all the

01:14:16,880 --> 01:14:19,679
capability of a normal dynamic java

01:14:18,719 --> 01:14:21,520
runtime

01:14:19,679 --> 01:14:23,120
it doesn't allow you to load classes at

01:14:21,520 --> 01:14:24,480
runtime and dive into them and start

01:14:23,120 --> 01:14:26,320
executing because it doesn't include an

01:14:24,480 --> 01:14:27,520
interpreter or a jet compiler it has a

01:14:26,320 --> 01:14:29,520
closed world model

01:14:27,520 --> 01:14:31,360
all the code has to be there in advance

01:14:29,520 --> 01:14:33,760
is that really java well

01:14:31,360 --> 01:14:35,520
um the open jdk project is actually

01:14:33,760 --> 01:14:38,159
working on building a very clear

01:14:35,520 --> 01:14:39,760
precise definition of what static java

01:14:38,159 --> 01:14:41,280
is as opposed to damage java

01:14:39,760 --> 01:14:44,000
but it's already out there in the field

01:14:41,280 --> 01:14:46,159
as part of oracle's growl vm suite of

01:14:44,000 --> 01:14:47,679
tools it's one of the components and we

01:14:46,159 --> 01:14:49,280
also released it at red hat and our

01:14:47,679 --> 01:14:50,320
mandrel releases derived from the same

01:14:49,280 --> 01:14:53,360
project which were a

01:14:50,320 --> 01:14:56,159
member of uh just the gravim native part

01:14:53,360 --> 01:14:58,000
so it de facto it is java how does it

01:14:56,159 --> 01:15:00,239
work well you start with

01:14:58,000 --> 01:15:02,159
your application it comprises a set of

01:15:00,239 --> 01:15:03,600
bytecode files java byte code compared

01:15:02,159 --> 01:15:05,360
from sources

01:15:03,600 --> 01:15:07,120
and the native image generator starts

01:15:05,360 --> 01:15:08,880
with the main class and it does what's

01:15:07,120 --> 01:15:10,320
called a points to analysis

01:15:08,880 --> 01:15:12,560
starting for that main class the main

01:15:10,320 --> 01:15:14,320
method it derives the type closure

01:15:12,560 --> 01:15:16,800
and the invocation closure of all

01:15:14,320 --> 01:15:18,560
methods accessible for the main method

01:15:16,800 --> 01:15:20,480
and that gives it a suite of classes it

01:15:18,560 --> 01:15:21,520
needs to build into a program a target

01:15:20,480 --> 01:15:22,960
program

01:15:21,520 --> 01:15:25,120
and there's an optimizing compiler that

01:15:22,960 --> 01:15:26,400
optimizes about -03 level

01:15:25,120 --> 01:15:28,560
fairly sophisticated optimizing the

01:15:26,400 --> 01:15:29,679
pilot it gives you a binary along the

01:15:28,560 --> 01:15:32,880
way you may need to

01:15:29,679 --> 01:15:34,800
link in open jdk classes from an open

01:15:32,880 --> 01:15:37,199
jdk release that are part of the jdk

01:15:34,800 --> 01:15:39,120
runtime standard libraries you may also

01:15:37,199 --> 01:15:40,000
need to link in static libraries and

01:15:39,120 --> 01:15:42,400
some native call

01:15:40,000 --> 01:15:43,199
outs to compile c code and some of the

01:15:42,400 --> 01:15:45,760
methods

01:15:43,199 --> 01:15:46,560
so there's a bundling of that stuff into

01:15:45,760 --> 01:15:48,719
the suite

01:15:46,560 --> 01:15:50,640
in the analysis but you can't bundle all

01:15:48,719 --> 01:15:52,640
of the jdk code in because

01:15:50,640 --> 01:15:54,640
we don't want to keep the code that's

01:15:52,640 --> 01:15:57,600
closely tied to lib jvm

01:15:54,640 --> 01:15:59,360
the dynamic jvm we really want to have

01:15:57,600 --> 01:16:00,880
an alternative to that that doesn't

01:15:59,360 --> 01:16:02,719
have all the cost of maintaining all the

01:16:00,880 --> 01:16:04,239
dynamic state so there's a lightweight

01:16:02,719 --> 01:16:05,280
virtual machine called substrate and the

01:16:04,239 --> 01:16:08,080
svm code

01:16:05,280 --> 01:16:09,760
is implemented as java classes and

01:16:08,080 --> 01:16:11,520
certain points in the jdk runtime

01:16:09,760 --> 01:16:13,440
either at the wholesale class level or

01:16:11,520 --> 01:16:15,120
within individual methods and fields

01:16:13,440 --> 01:16:16,960
substitutions are made for code from the

01:16:15,120 --> 01:16:18,320
svm implementation

01:16:16,960 --> 01:16:20,159
and that gives you a final speed of

01:16:18,320 --> 01:16:22,320
classes you've got a choice of

01:16:20,159 --> 01:16:23,360
initializing some of the static data for

01:16:22,320 --> 01:16:25,760
the

01:16:23,360 --> 01:16:27,280
target program at build time or having

01:16:25,760 --> 01:16:29,120
runtime initialization

01:16:27,280 --> 01:16:30,719
but you can define a heap layout for all

01:16:29,120 --> 01:16:33,760
the static values that will be

01:16:30,719 --> 01:16:34,080
linked in there there's also a new

01:16:33,760 --> 01:16:35,920
object

01:16:34,080 --> 01:16:37,840
heap thread support garbage collect

01:16:35,920 --> 01:16:39,360
support linkedin and you basically build

01:16:37,840 --> 01:16:41,840
yourself an executable

01:16:39,360 --> 01:16:43,120
so that's how that works what's the

01:16:41,840 --> 01:16:44,560
problem with debugging that well all

01:16:43,120 --> 01:16:46,320
that executable code

01:16:44,560 --> 01:16:47,760
has bit layouts and code layouts that

01:16:46,320 --> 01:16:48,960
are derived from class files and gdp

01:16:47,760 --> 01:16:51,280
doesn't know anything about them

01:16:48,960 --> 01:16:53,040
and those classes exist uh compiled by a

01:16:51,280 --> 01:16:53,840
bytecode compiler from source code

01:16:53,040 --> 01:16:55,760
that's in

01:16:53,840 --> 01:16:57,120
jars and in a source dot zip in the case

01:16:55,760 --> 01:16:58,480
of the open jdk code

01:16:57,120 --> 01:17:00,239
and gdb doesn't know where they come

01:16:58,480 --> 01:17:03,199
from or how to find them

01:17:00,239 --> 01:17:04,320
so we've had two stages to the uh the

01:17:03,199 --> 01:17:06,159
pipeline here

01:17:04,320 --> 01:17:07,920
we assemble all the type information all

01:17:06,159 --> 01:17:09,520
the modifications that are made by the

01:17:07,920 --> 01:17:11,920
substitutions or the

01:17:09,520 --> 01:17:12,719
static data layouts or the code

01:17:11,920 --> 01:17:14,239
information

01:17:12,719 --> 01:17:16,000
from those other previous phases and

01:17:14,239 --> 01:17:18,239
build a generic model and from that

01:17:16,000 --> 01:17:19,280
we can clone dwarf information that we

01:17:18,239 --> 01:17:21,360
can put in

01:17:19,280 --> 01:17:23,040
that will describe to gdb how the

01:17:21,360 --> 01:17:24,239
program operates and how the data is

01:17:23,040 --> 01:17:26,719
laid out

01:17:24,239 --> 01:17:27,920
um we also at build time assemble

01:17:26,719 --> 01:17:29,120
sources because they're usually

01:17:27,920 --> 01:17:30,800
available in the build time the

01:17:29,120 --> 01:17:32,640
source.zip for openjdk

01:17:30,800 --> 01:17:34,800
we can find all the jdk runtime class

01:17:32,640 --> 01:17:36,560
sources and the application sources are

01:17:34,800 --> 01:17:38,320
usually in source jars

01:17:36,560 --> 01:17:40,000
it would no good trying to point to gdb

01:17:38,320 --> 01:17:41,920
at them but we can build a source cache

01:17:40,000 --> 01:17:43,440
that we you can upload next to your

01:17:41,920 --> 01:17:45,840
binary when you want to debug it

01:17:43,440 --> 01:17:47,520
and we put information the dwarf info

01:17:45,840 --> 01:17:49,760
that references those source files

01:17:47,520 --> 01:17:50,960
relative to that cache now i say that

01:17:49,760 --> 01:17:52,719
that's very simple we just create

01:17:50,960 --> 01:17:55,760
warfare for there's a problem though

01:17:52,719 --> 01:17:57,920
we don't actually have dwarf info for a

01:17:55,760 --> 01:17:59,840
java program that gdb can understand it

01:17:57,920 --> 01:18:01,199
doesn't know about java anymore

01:17:59,840 --> 01:18:02,960
so what we've done is we've at the

01:18:01,199 --> 01:18:04,960
moment we're faking it we're providing

01:18:02,960 --> 01:18:07,840
dwarf info what would be an equivalent

01:18:04,960 --> 01:18:10,159
c plus plus program and at the moment

01:18:07,840 --> 01:18:12,480
we've implemented all the dwarf info

01:18:10,159 --> 01:18:13,360
layouts and other dwarfs they have their

01:18:12,480 --> 01:18:16,159
records

01:18:13,360 --> 01:18:16,800
for the method part the code part of the

01:18:16,159 --> 01:18:18,239
binary

01:18:16,800 --> 01:18:20,880
and we're working on the type stuff as a

01:18:18,239 --> 01:18:22,400
latest work so for every class we have a

01:18:20,880 --> 01:18:24,400
compile unit in the info

01:18:22,400 --> 01:18:27,040
model within that there are subrecords

01:18:24,400 --> 01:18:28,560
for subprograms we know the class

01:18:27,040 --> 01:18:30,560
we know the name so we can identify

01:18:28,560 --> 01:18:32,159
methods by name we know its address

01:18:30,560 --> 01:18:34,320
range in the text segment

01:18:32,159 --> 01:18:35,679
whether it's visible public or private

01:18:34,320 --> 01:18:37,920
we can actually

01:18:35,679 --> 01:18:39,520
uh from the compiler we can associate

01:18:37,920 --> 01:18:41,760
particular addresses

01:18:39,520 --> 01:18:42,719
back to the originating but compiled by

01:18:41,760 --> 01:18:44,800
code that they were

01:18:42,719 --> 01:18:46,239
compiled from and we could use line

01:18:44,800 --> 01:18:47,920
information that was available in the

01:18:46,239 --> 01:18:50,560
class files at build time

01:18:47,920 --> 01:18:52,080
to map that back to source lines so we

01:18:50,560 --> 01:18:52,719
can actually get source file and line

01:18:52,080 --> 01:18:54,800
maps

01:18:52,719 --> 01:18:56,480
for for methods the compiler

01:18:54,800 --> 01:18:58,800
conveniently tells us when

01:18:56,480 --> 01:19:00,640
stack pushes and snap stack pops occur

01:18:58,800 --> 01:19:02,880
at certain offsets in the machine code

01:19:00,640 --> 01:19:05,040
so we can also build frame information

01:19:02,880 --> 01:19:06,719
and the compiler also tracks where

01:19:05,040 --> 01:19:08,239
it does inlining so there's a range

01:19:06,719 --> 01:19:09,920
which is in line code

01:19:08,239 --> 01:19:12,400
we can relate the addresses in that

01:19:09,920 --> 01:19:13,520
range some of them back to source files

01:19:12,400 --> 01:19:16,000
and source lines

01:19:13,520 --> 01:19:17,040
using the same model so we can build an

01:19:16,000 --> 01:19:19,760
info model uh

01:19:17,040 --> 01:19:21,040
and a brief section a ranges frame line

01:19:19,760 --> 01:19:22,400
and string sections

01:19:21,040 --> 01:19:24,400
much the same as you'd see for the

01:19:22,400 --> 01:19:26,239
method description part of a c plus plus

01:19:24,400 --> 01:19:28,320
program and it's pretty it's enough to

01:19:26,239 --> 01:19:30,000
fool gdb into thinking yes i've got a c

01:19:28,320 --> 01:19:32,000
plus plus program and it debugs the java

01:19:30,000 --> 01:19:33,440
code with what we've got already and

01:19:32,000 --> 01:19:35,679
this is already in the product

01:19:33,440 --> 01:19:38,320
that means we can break methods by name

01:19:35,679 --> 01:19:40,960
or by method name or by file and line

01:19:38,320 --> 01:19:42,719
and then gdb will find file source files

01:19:40,960 --> 01:19:43,280
relative to the sources cache that we've

01:19:42,719 --> 01:19:45,760
built

01:19:43,280 --> 01:19:46,320
and made available it can step line by

01:19:45,760 --> 01:19:48,560
line

01:19:46,320 --> 01:19:50,000
into calls and over calls and it will

01:19:48,560 --> 01:19:51,520
follow the relevant files and the

01:19:50,000 --> 01:19:54,320
relevant lines in the file

01:19:51,520 --> 01:19:56,320
as you're debugging and stepping um it

01:19:54,320 --> 01:19:57,679
can also do stack back traces because it

01:19:56,320 --> 01:19:59,199
knows about the frame layouts

01:19:57,679 --> 01:20:00,880
and that will include you can see in the

01:19:59,199 --> 01:20:03,440
stack frame the transition from the c

01:20:00,880 --> 01:20:04,960
entry point into the java main method

01:20:03,440 --> 01:20:06,480
and if you break a native

01:20:04,960 --> 01:20:08,320
method the symptom is c you can see

01:20:06,480 --> 01:20:09,679
where it's called from java it all just

01:20:08,320 --> 01:20:11,440
works and of course it all works

01:20:09,679 --> 01:20:14,080
transparently inside emacs which is the

01:20:11,440 --> 01:20:16,000
most important thing

01:20:14,080 --> 01:20:18,159
what i'm working on now is the next

01:20:16,000 --> 01:20:19,120
phase is working on putting information

01:20:18,159 --> 01:20:22,159
about types and

01:20:19,120 --> 01:20:22,560
heap layouts into the dwarf model now

01:20:22,159 --> 01:20:24,159
that

01:20:22,560 --> 01:20:26,719
in order to get the type information in

01:20:24,159 --> 01:20:28,880
we have to do a bit more work to fool

01:20:26,719 --> 01:20:30,239
gdb into thinking it's got a c plus

01:20:28,880 --> 01:20:31,760
program that will look

01:20:30,239 --> 01:20:33,600
equivalent to the java program will

01:20:31,760 --> 01:20:35,120
debug properly and we can get certain

01:20:33,600 --> 01:20:36,320
capabilities out of that with a fairly

01:20:35,120 --> 01:20:39,760
basic bit of

01:20:36,320 --> 01:20:40,239
of of trickery so java objects are going

01:20:39,760 --> 01:20:42,480
to be

01:20:40,239 --> 01:20:44,400
pointer types to an underlying structure

01:20:42,480 --> 01:20:45,280
type the object reference is really just

01:20:44,400 --> 01:20:46,719
a pointer

01:20:45,280 --> 01:20:48,639
the underlying structure will have a

01:20:46,719 --> 01:20:50,480
header and it will have

01:20:48,639 --> 01:20:52,880
field entries for each of the java data

01:20:50,480 --> 01:20:53,520
values like a java integer 32-bit signed

01:20:52,880 --> 01:20:54,960
integer

01:20:53,520 --> 01:20:57,040
or an object reference to some other

01:20:54,960 --> 01:20:58,800
class so we can describe the class

01:20:57,040 --> 01:21:01,040
layout for a java class

01:20:58,800 --> 01:21:02,560
when we have subclassing we can model

01:21:01,040 --> 01:21:04,800
the underlying structure types of the

01:21:02,560 --> 01:21:06,400
two the two classes as though they've

01:21:04,800 --> 01:21:08,159
represented using more public

01:21:06,400 --> 01:21:11,520
inheritance so again we can just

01:21:08,159 --> 01:21:14,239
use the standard c plus model for that

01:21:11,520 --> 01:21:14,880
a java interface is basically a type

01:21:14,239 --> 01:21:16,880
that can

01:21:14,880 --> 01:21:18,560
be implemented by disparate types that

01:21:16,880 --> 01:21:20,400
don't have a common parent class

01:21:18,560 --> 01:21:21,920
we can actually model that using a union

01:21:20,400 --> 01:21:22,719
of the pointer types for each of the

01:21:21,920 --> 01:21:24,880
implementers

01:21:22,719 --> 01:21:25,840
so we can get interfaces to sort of work

01:21:24,880 --> 01:21:28,239
and we can cast

01:21:25,840 --> 01:21:29,280
to the relevant type and invoke via a

01:21:28,239 --> 01:21:31,840
suitable subtype

01:21:29,280 --> 01:21:33,360
and so on uh we can also model arrays

01:21:31,840 --> 01:21:34,719
using another under a reference a

01:21:33,360 --> 01:21:35,199
reference to other underlying structure

01:21:34,719 --> 01:21:36,480
type

01:21:35,199 --> 01:21:38,239
it's got a slightly different header

01:21:36,480 --> 01:21:38,880
structure because the array has a length

01:21:38,239 --> 01:21:40,159
in it

01:21:38,880 --> 01:21:42,080
and it'll have an empty array of

01:21:40,159 --> 01:21:44,239
elements of either a reference type

01:21:42,080 --> 01:21:45,440
which we in rare pointers or of a java

01:21:44,239 --> 01:21:48,159
primitive

01:21:45,440 --> 01:21:50,239
type like boolean integer float and so

01:21:48,159 --> 01:21:52,159
on so we can model arrays as well

01:21:50,239 --> 01:21:53,280
using whatever the equivalent model for

01:21:52,159 --> 01:21:55,120
that c plus that c

01:21:53,280 --> 01:21:57,040
plus plus type would be and then we can

01:21:55,120 --> 01:21:58,480
use that to type locations in the heap

01:21:57,040 --> 01:22:01,040
to type constant values that are in the

01:21:58,480 --> 01:22:02,400
heap and also to type local variables

01:22:01,040 --> 01:22:04,159
and parameter variables

01:22:02,400 --> 01:22:06,239
once we put information about liveness

01:22:04,159 --> 01:22:07,440
in so with with that work that i'm

01:22:06,239 --> 01:22:09,199
currently working on we should be able

01:22:07,440 --> 01:22:10,000
to print objects field by field with a

01:22:09,199 --> 01:22:12,880
header

01:22:10,000 --> 01:22:14,000
tag information we should be able to

01:22:12,880 --> 01:22:16,239
identify

01:22:14,000 --> 01:22:18,080
data values using names for parameter

01:22:16,239 --> 01:22:19,520
vars names for local vars names for

01:22:18,080 --> 01:22:21,199
static locations

01:22:19,520 --> 01:22:22,960
and know when they're live and map into

01:22:21,199 --> 01:22:25,199
a register or a stack address

01:22:22,960 --> 01:22:27,040
or heap address we should be able to use

01:22:25,199 --> 01:22:27,679
cast so that we can access elements of a

01:22:27,040 --> 01:22:30,000
subtype

01:22:27,679 --> 01:22:31,760
or of an interface type and we should be

01:22:30,000 --> 01:22:33,040
able to use path expressions to diverse

01:22:31,760 --> 01:22:34,639
the object network

01:22:33,040 --> 01:22:36,480
so we'll have enough for us to be able

01:22:34,639 --> 01:22:37,199
to do basic debugging and it's at this

01:22:36,480 --> 01:22:39,120
point then

01:22:37,199 --> 01:22:41,280
we really need to start thinking about

01:22:39,120 --> 01:22:42,639
how do we get gdb to do this properly

01:22:41,280 --> 01:22:45,520
and we start faking it and do it for

01:22:42,639 --> 01:22:47,840
real so gdp can understand java again

01:22:45,520 --> 01:22:49,920
so um coming to the end of that i'll

01:22:47,840 --> 01:22:50,560
just say that the code that's working

01:22:49,920 --> 01:22:53,120
now

01:22:50,560 --> 01:22:53,760
the the debugging is in the growl repo

01:22:53,120 --> 01:22:56,320
upstream

01:22:53,760 --> 01:22:58,000
it's also in our mandrel repo my work in

01:22:56,320 --> 01:22:59,840
progress on putting type information is

01:22:58,000 --> 01:23:00,960
in is in my debug types branch and my

01:22:59,840 --> 01:23:02,960
github repo

01:23:00,960 --> 01:23:04,239
there's a lovely youtube gem demo on our

01:23:02,960 --> 01:23:05,520
caucus channel caucasus

01:23:04,239 --> 01:23:08,000
middleware that relies on the native

01:23:05,520 --> 01:23:09,600
image generator showing me debugging a

01:23:08,000 --> 01:23:10,480
java program it's slightly out of date

01:23:09,600 --> 01:23:12,080
but

01:23:10,480 --> 01:23:13,199
it shows actual debugging and moving

01:23:12,080 --> 01:23:14,400
around the source file so have a look at

01:23:13,199 --> 01:23:15,679
that never play with it

01:23:14,400 --> 01:23:21,840
and i hope you enjoy that and i'll be

01:23:15,679 --> 01:23:21,840
very interested if your feedback

01:23:22,880 --> 01:23:25,840
so any feedback

01:23:30,560 --> 01:23:35,280
thank you thank you andrew any questions

01:23:33,199 --> 01:23:37,280
frank

01:23:35,280 --> 01:23:38,800
yeah andrew i think i'll be in touch uh

01:23:37,280 --> 01:23:39,440
offline once we're talking it looks like

01:23:38,800 --> 01:23:41,520
we have some

01:23:39,440 --> 01:23:43,440
at least two fertile opportunities to

01:23:41,520 --> 01:23:45,679
interface our code so all good

01:23:43,440 --> 01:23:49,840
excellent yeah yeah no that's great

01:23:45,679 --> 01:23:49,840
frank good

01:23:51,040 --> 01:23:54,320
right stun silence i know the word the

01:23:52,639 --> 01:23:55,840
mention of java just

01:23:54,320 --> 01:23:57,520
puts it with these like most people but

01:23:55,840 --> 01:24:00,800
it it's really it's really c plus plus

01:23:57,520 --> 01:24:00,800
just pretend that it's fine

01:24:00,880 --> 01:24:07,679
so andrew hi hi did you look at the

01:24:05,440 --> 01:24:09,120
gdp support just before it was removed

01:24:07,679 --> 01:24:11,280
the java support for

01:24:09,120 --> 01:24:12,159
gcj no i haven't i haven't looked at it

01:24:11,280 --> 01:24:15,920
all i found

01:24:12,159 --> 01:24:18,320
was that the the java language is still

01:24:15,920 --> 01:24:20,080
defined and immediately says oh you mean

01:24:18,320 --> 01:24:21,199
c plus plus and that's all that's there

01:24:20,080 --> 01:24:23,280
right now

01:24:21,199 --> 01:24:25,040
um i didn't know what was there before

01:24:23,280 --> 01:24:26,960
i'm not sure how much it'll translate

01:24:25,040 --> 01:24:28,639
because it was gcj support

01:24:26,960 --> 01:24:30,400
so maybe things will work maybe they

01:24:28,639 --> 01:24:32,080
won't i mean the difficult bit is

01:24:30,400 --> 01:24:33,679
the layouts and i'm not sure they're

01:24:32,080 --> 01:24:36,080
necessarily going to be

01:24:33,679 --> 01:24:37,360
comparable or i suppose in the abstract

01:24:36,080 --> 01:24:38,000
they are but in the detail they probably

01:24:37,360 --> 01:24:39,280
won't be

01:24:38,000 --> 01:24:41,280
but it might be it might be useful to

01:24:39,280 --> 01:24:42,800
look at that i've just been wanting to

01:24:41,280 --> 01:24:44,000
get something to work so we can actually

01:24:42,800 --> 01:24:47,040
have the product

01:24:44,000 --> 01:24:48,719
be debuggable as soon as possible um and

01:24:47,040 --> 01:24:50,639
then we'll think about the longer term

01:24:48,719 --> 01:24:51,920
retrofitting this and getting gdb there

01:24:50,639 --> 01:24:53,280
but it's at the stage where it'll be

01:24:51,920 --> 01:24:54,320
good to talk to someone from the gdp

01:24:53,280 --> 01:24:56,320
team about that

01:24:54,320 --> 01:24:57,920
so anybody who's working on gdp has got

01:24:56,320 --> 01:25:00,080
an interest in this i'd be really keen

01:24:57,920 --> 01:25:02,159
to follow this up

01:25:00,080 --> 01:25:03,679
one thing that may be useful is the

01:25:02,159 --> 01:25:07,120
parser that we've had

01:25:03,679 --> 01:25:08,719
at the java parser yeah i mean

01:25:07,120 --> 01:25:10,159
i'm hoping i'll get by you know path

01:25:08,719 --> 01:25:12,560
expressions will work

01:25:10,159 --> 01:25:13,280
very much the same apart from you're

01:25:12,560 --> 01:25:15,520
going to have to put

01:25:13,280 --> 01:25:16,800
put casts in to de-reference a an

01:25:15,520 --> 01:25:20,400
interface union

01:25:16,800 --> 01:25:22,800
or you know but it a lot of it should be

01:25:20,400 --> 01:25:24,960
sort of transparently work i think but

01:25:22,800 --> 01:25:26,480
that's still yet to be proven so

01:25:24,960 --> 01:25:27,760
when i get there i'll let you know but

01:25:26,480 --> 01:25:29,120
yes i mean there's a lot of cleanup that

01:25:27,760 --> 01:25:29,679
could be done and i'm looking forward to

01:25:29,120 --> 01:25:31,520
getting it

01:25:29,679 --> 01:25:33,120
actually done for real rather than just

01:25:31,520 --> 01:25:34,880
just um hacking this in but

01:25:33,120 --> 01:25:36,639
this should be very valuable experience

01:25:34,880 --> 01:25:39,360
once this is working to work out what we

01:25:36,639 --> 01:25:39,360
really do need

01:25:39,520 --> 01:25:43,360
okay i think we have to call it a day

01:25:41,600 --> 01:25:45,440
there thank you very much indeed

01:25:43,360 --> 01:25:47,600
uh andrew i appreciate you very good

01:25:45,440 --> 01:25:50,639
time keeping that extent plus us all

01:25:47,600 --> 01:25:53,920
um practice thanks a lot

01:25:50,639 --> 01:25:55,360
thank you your um moderator moderator

01:25:53,920 --> 01:25:57,920
for the afternoon session

01:25:55,360 --> 01:25:58,960
will be joel brobecker um who many of

01:25:57,920 --> 01:26:01,840
you will know

01:25:58,960 --> 01:26:02,639
um so i shall hand over him to introduce

01:26:01,840 --> 01:26:05,679
talks and

01:26:02,639 --> 01:26:06,880
um uh keep people to time and for those

01:26:05,679 --> 01:26:08,000
who are interested the notes from the

01:26:06,880 --> 01:26:11,120
boss are now up on

01:26:08,000 --> 01:26:23,840
the uh wiki the links in the uh

01:26:11,120 --> 01:26:23,840
chat okay okay joe

01:26:24,960 --> 01:26:31,679
all right vladimir the floor is yours

01:26:28,000 --> 01:26:33,920
okay thank you thank you yeah

01:26:31,679 --> 01:26:36,080
hello everyone i am vlad makarov and

01:26:33,920 --> 01:26:38,960
this presentation will be about

01:26:36,080 --> 01:26:40,800
my experience to use gcc as a jit

01:26:38,960 --> 01:26:43,040
compiler for ruby

01:26:40,800 --> 01:26:44,400
and how this experience resulted in

01:26:43,040 --> 01:26:47,360
starting with the lightweight jit

01:26:44,400 --> 01:26:47,360
compiler project

01:26:48,239 --> 01:26:52,320
about five years ago the creator of ruby

01:26:50,880 --> 01:26:55,120
programming language

01:26:52,320 --> 01:26:55,760
uh yukihiro matsumota set up three goals

01:26:55,120 --> 01:26:58,639
for

01:26:55,760 --> 01:26:59,600
zero b version three these goals are

01:26:58,639 --> 01:27:02,159
type chipping

01:26:59,600 --> 01:27:04,159
checking parallelism support and

01:27:02,159 --> 01:27:05,040
improving xerob performance in three

01:27:04,159 --> 01:27:08,639
times

01:27:05,040 --> 01:27:10,880
in comparison with version 2.

01:27:08,639 --> 01:27:13,280
my personal opinion successful

01:27:10,880 --> 01:27:16,400
fulfilling these goals

01:27:13,280 --> 01:27:17,840
would prevent go actively eating ruby

01:27:16,400 --> 01:27:20,960
market share because go

01:27:17,840 --> 01:27:23,280
already has this feature

01:27:20,960 --> 01:27:24,719
the ruby virtual machine has a very

01:27:23,280 --> 01:27:26,880
optimized code

01:27:24,719 --> 01:27:28,000
a radical three times performance

01:27:26,880 --> 01:27:30,960
improvement of

01:27:28,000 --> 01:27:32,080
a fine-tuned virtual machine could be

01:27:30,960 --> 01:27:37,280
achieved only by

01:27:32,080 --> 01:27:37,280
a radical change uh as aden gidget

01:27:38,719 --> 01:27:42,639
there are a lot of ruby implementations

01:27:41,280 --> 01:27:46,000
and some of them beat

01:27:42,639 --> 01:27:49,360
jets some jets were actually proposed

01:27:46,000 --> 01:27:52,480
to become part of c ruby i decided to

01:27:49,360 --> 01:27:55,040
participate in zero budget work too

01:27:52,480 --> 01:27:56,719
because i am from gcc community i

01:27:55,040 --> 01:28:00,560
decided to try to build

01:27:56,719 --> 01:28:04,960
gcc based jet which i called amg

01:28:00,560 --> 01:28:04,960
amg it simply means a meta jet

01:28:05,600 --> 01:28:09,760
when i started this work david malcolm

01:28:07,920 --> 01:28:14,320
already implemented libgi

01:28:09,760 --> 01:28:17,679
jit a jit compiler library based on gcc

01:28:14,320 --> 01:28:19,040
this diagram shows how serum jet based

01:28:17,679 --> 01:28:22,800
on deep jccc

01:28:19,040 --> 01:28:25,440
would look like but after

01:28:22,800 --> 01:28:28,239
consultation with david i decided to use

01:28:25,440 --> 01:28:31,440
a bit different approach what

01:28:28,239 --> 01:28:32,480
executing the ruby byte code calls a big

01:28:31,440 --> 01:28:35,600
set of

01:28:32,480 --> 01:28:39,120
in-line functions i call this set an

01:28:35,600 --> 01:28:41,840
environment generating

01:28:39,120 --> 01:28:42,560
the environment through libgcc jet api

01:28:41,840 --> 01:28:45,760
is huge

01:28:42,560 --> 01:28:47,199
error prone drop and it's a nightmare

01:28:45,760 --> 01:28:49,520
for maintenance

01:28:47,199 --> 01:28:51,760
as this set actively changed by other

01:28:49,520 --> 01:28:55,040
crub developers

01:28:51,760 --> 01:28:58,080
also rip gcc cannot inline functions

01:28:55,040 --> 01:29:01,440
because of its start point in gcc

01:28:58,080 --> 01:29:01,440
optimization pipeline

01:29:02,000 --> 01:29:09,199
instead of rib gcc jet i decided to use

01:29:05,040 --> 01:29:13,440
gcc itself instead of libgcc jet api

01:29:09,199 --> 01:29:15,760
i use cs interface language

01:29:13,440 --> 01:29:18,239
using such approach makes implementation

01:29:15,760 --> 01:29:20,480
simple and easy for debugging

01:29:18,239 --> 01:29:21,360
it also permits to use alternative c

01:29:20,480 --> 01:29:24,800
compilers

01:29:21,360 --> 01:29:27,920
for example clank the environment

01:29:24,800 --> 01:29:28,719
is added as a header to speed up its

01:29:27,920 --> 01:29:32,880
processing

01:29:28,719 --> 01:29:32,880
i actually use a pre-compiled header

01:29:33,199 --> 01:29:39,760
case data flow of approaches uses

01:29:36,440 --> 01:29:42,320
represent and gcc itself

01:29:39,760 --> 01:29:44,800
the red parts are different they are

01:29:42,320 --> 01:29:47,679
basically creating gcc internal

01:29:44,800 --> 01:29:49,600
representation of the environment and gt

01:29:47,679 --> 01:29:52,960
code from c

01:29:49,600 --> 01:29:56,080
if we can make runtime of three of these

01:29:52,960 --> 01:29:58,080
parts small

01:29:56,080 --> 01:30:01,679
there will be no performance advantages

01:29:58,080 --> 01:30:01,679
in using the gccg

01:30:02,800 --> 01:30:08,080
a key to achieve the same compile time

01:30:05,840 --> 01:30:09,840
as pre-compiled headers

01:30:08,080 --> 01:30:11,760
here is the time graph for the

01:30:09,840 --> 01:30:15,199
compilation data flow

01:30:11,760 --> 01:30:17,760
for typical ruby method as you can see

01:30:15,199 --> 01:30:19,520
optimizations and generation take

01:30:17,760 --> 01:30:21,920
biggest time

01:30:19,520 --> 01:30:24,239
parsing ac function which implements the

01:30:21,920 --> 01:30:25,679
bytecode instruction sequence is very

01:30:24,239 --> 01:30:28,480
small

01:30:25,679 --> 01:30:29,440
parsing the environment is pretty big

01:30:28,480 --> 01:30:32,840
even if we

01:30:29,440 --> 01:30:34,560
throw away unnecessary environment

01:30:32,840 --> 01:30:36,960
declarations

01:30:34,560 --> 01:30:39,120
but when we use pre-compiled environment

01:30:36,960 --> 01:30:41,600
processing the environment drops to

01:30:39,120 --> 01:30:43,920
three and a half percent so using

01:30:41,600 --> 01:30:46,880
pre-compiled header basically speeds

01:30:43,920 --> 01:30:48,320
up jet compilation in about two times

01:30:46,880 --> 01:30:51,040
for a typical small

01:30:48,320 --> 01:30:51,040
ruby method

01:30:51,840 --> 01:30:55,280
so about three years ago i implemented

01:30:54,080 --> 01:30:58,159
zero budget

01:30:55,280 --> 01:30:59,840
and here are the performance results

01:30:58,159 --> 01:31:02,880
historically most widely

01:30:59,840 --> 01:31:03,199
used c ruby programs like ruby on rails

01:31:02,880 --> 01:31:06,400
are

01:31:03,199 --> 01:31:08,719
input output bound benchmarks jit is

01:31:06,400 --> 01:31:11,840
mostly useless for them

01:31:08,719 --> 01:31:14,159
ruby community uses opt caret benchmark

01:31:11,840 --> 01:31:17,120
for performance measuring

01:31:14,159 --> 01:31:18,159
op carrot is about 30 second cpu bound

01:31:17,120 --> 01:31:20,400
benchmark

01:31:18,159 --> 01:31:21,280
a new dental entertainment system

01:31:20,400 --> 01:31:24,560
simulator

01:31:21,280 --> 01:31:27,760
written on ruby the speed for this

01:31:24,560 --> 01:31:31,520
program is measured in frames per second

01:31:27,760 --> 01:31:33,760
i used gcc and clank

01:31:31,520 --> 01:31:35,520
jruby with and without support of

01:31:33,760 --> 01:31:38,800
dynamic languages

01:31:35,520 --> 01:31:41,440
oracle ground ruby and ibm omr

01:31:38,800 --> 01:31:41,440
jit ruby

01:31:42,840 --> 01:31:49,199
gccldmgt is the second best and improves

01:31:46,159 --> 01:31:53,199
this ruby version to performance

01:31:49,199 --> 01:31:55,440
in three times ground results are the

01:31:53,199 --> 01:31:58,080
best because of aggressive jitting

01:31:55,440 --> 01:32:00,239
and speculation and in line with kuruki

01:31:58,080 --> 01:32:02,560
standard methods

01:32:00,239 --> 01:32:05,840
to do this successfully you need a very

01:32:02,560 --> 01:32:05,840
fast jit compiler

01:32:06,719 --> 01:32:11,600
here's cpu time people will frequently

01:32:09,199 --> 01:32:12,080
omit this injured comparison but it's

01:32:11,600 --> 01:32:15,120
important

01:32:12,080 --> 01:32:16,639
how many resources you spend to execute

01:32:15,120 --> 01:32:19,840
a program

01:32:16,639 --> 01:32:24,000
this is important for mobile devices

01:32:19,840 --> 01:32:28,080
using battery and for cloud applications

01:32:24,000 --> 01:32:31,199
because usage of more cpus is costly

01:32:28,080 --> 01:32:34,800
as you can see crb mg and omr

01:32:31,199 --> 01:32:35,199
ruby on this european jitter and oem

01:32:34,800 --> 01:32:38,560
where

01:32:35,199 --> 01:32:41,040
ruby spent less risk cpu resources

01:32:38,560 --> 01:32:43,840
to execute the benchmark than its

01:32:41,040 --> 01:32:43,840
interpretation

01:32:45,760 --> 01:32:52,320
peak memory consumption for mg this

01:32:48,560 --> 01:32:54,239
includes memory used by gcc llvm

01:32:52,320 --> 01:32:55,360
we need to spend additional memory to

01:32:54,239 --> 01:32:58,960
generate and keep

01:32:55,360 --> 01:33:01,360
cheat code jruby spent too much memory

01:32:58,960 --> 01:33:03,440
no surprise here people always

01:33:01,360 --> 01:33:04,639
complained that jvm needs too much

01:33:03,440 --> 01:33:09,679
memory

01:33:04,639 --> 01:33:12,960
but growl ruby is even worse

01:33:09,679 --> 01:33:15,679
uh my mg code was adopted by

01:33:12,960 --> 01:33:18,000
takashi kokobon and the adopted code

01:33:15,679 --> 01:33:21,520
became official ceo bmg

01:33:18,000 --> 01:33:22,000
since version 2.6 the difference with my

01:33:21,520 --> 01:33:25,679
original

01:33:22,000 --> 01:33:27,920
version is and use existing uh

01:33:25,679 --> 01:33:29,920
virtual machine stack instructions

01:33:27,920 --> 01:33:33,360
instead of register instructions

01:33:29,920 --> 01:33:36,400
i introduced for the grid also official

01:33:33,360 --> 01:33:39,360
lmg it has no speculation instructions

01:33:36,400 --> 01:33:42,000
and speculative code generation and has

01:33:39,360 --> 01:33:45,040
less aggressive getting heuristics

01:33:42,000 --> 01:33:46,719
but it can combine gtt methods in one

01:33:45,040 --> 01:33:48,880
shared object

01:33:46,719 --> 01:33:53,600
in overall performance of officer

01:33:48,880 --> 01:33:53,600
official ceo budget is a bit worse

01:33:54,639 --> 01:34:01,120
but enough about advantages of

01:33:57,840 --> 01:34:01,840
gccl of the employee states let us speak

01:34:01,120 --> 01:34:05,840
about the

01:34:01,840 --> 01:34:07,520
disadvantages first of all gccllvm-based

01:34:05,840 --> 01:34:10,639
jits are big

01:34:07,520 --> 01:34:13,360
their compilation speed can be also slow

01:34:10,639 --> 01:34:15,440
and it's hard to implement optimizations

01:34:13,360 --> 01:34:16,880
of code written on different programming

01:34:15,440 --> 01:34:21,440
languages

01:34:16,880 --> 01:34:24,239
in case of c ruby they ruby nc

01:34:21,440 --> 01:34:24,719
people are also uncomfortable to have

01:34:24,239 --> 01:34:27,840
gas

01:34:24,719 --> 01:34:32,000
or gcc in production environment

01:34:27,840 --> 01:34:34,320
needed for lip gcc jet or mg

01:34:32,000 --> 01:34:36,560
dynamical order allocates 4 kilobyte

01:34:34,320 --> 01:34:39,840
pages for each object generated

01:34:36,560 --> 01:34:41,679
with gcc jit or mg

01:34:39,840 --> 01:34:43,440
when there are a lot of objects about

01:34:41,679 --> 01:34:46,800
100 bytes each

01:34:43,440 --> 01:34:50,000
it results in a lot of tlb misses

01:34:46,800 --> 01:34:50,880
and big performance hit so let us

01:34:50,000 --> 01:34:54,080
consider

01:34:50,880 --> 01:34:57,760
some these disadvantages in more detail

01:34:54,080 --> 01:35:02,880
first of all gcc and lvm

01:34:57,760 --> 01:35:02,880
are big comparing to sirubi how big

01:35:04,000 --> 01:35:10,800
0b binary is big but gcc

01:35:07,360 --> 01:35:12,960
and lvm binaries are much bigger from 7

01:35:10,800 --> 01:35:16,080
to 18 times bigger

01:35:12,960 --> 01:35:18,239
using gcc llvm based jit

01:35:16,080 --> 01:35:21,760
for a simple language could easily

01:35:18,239 --> 01:35:24,560
increase binary code in hundred times

01:35:21,760 --> 01:35:25,040
the big code size can be serious problem

01:35:24,560 --> 01:35:27,920
for

01:35:25,040 --> 01:35:28,480
cloud environment internet of things or

01:35:27,920 --> 01:35:31,920
mob

01:35:28,480 --> 01:35:31,920
mobile market environments

01:35:32,719 --> 01:35:35,760
second gccl then compilation speed is

01:35:35,199 --> 01:35:38,080
slow

01:35:35,760 --> 01:35:40,960
it seems that 20 milliseconds in small

01:35:38,080 --> 01:35:44,480
form method compilation with gcc llvm

01:35:40,960 --> 01:35:47,360
on modern cpus but for less powerful

01:35:44,480 --> 01:35:49,520
but widely used cpus it can be a half a

01:35:47,360 --> 01:35:51,840
half second

01:35:49,520 --> 01:35:52,560
also faster speed can help achieving

01:35:51,840 --> 01:35:54,719
desirable

01:35:52,560 --> 01:35:58,000
jit performance by aggressive

01:35:54,719 --> 01:36:01,760
speculation and in line

01:35:58,000 --> 01:36:04,880
how a faster jit compilation could look

01:36:01,760 --> 01:36:06,960
for java falcon compiler it's about 100

01:36:04,880 --> 01:36:10,080
milliseconds for one method

01:36:06,960 --> 01:36:13,280
for llvm based jit compiler and

01:36:10,080 --> 01:36:16,960
one millisecond for faster tire one

01:36:13,280 --> 01:36:20,960
jvm compiler so why gccl

01:36:16,960 --> 01:36:22,880
vm compilation is slow gcc has more 300

01:36:20,960 --> 01:36:26,719
optimization passes

01:36:22,880 --> 01:36:29,520
you can just disable most passes

01:36:26,719 --> 01:36:32,880
but will be speed up proportional to the

01:36:29,520 --> 01:36:32,880
number of disabled passes

01:36:33,520 --> 01:36:36,560
the biggest problem for gcc and lvm to

01:36:36,239 --> 01:36:38,560
be

01:36:36,560 --> 01:36:40,080
a lightweight jet compiler is a big

01:36:38,560 --> 01:36:42,639
startup time

01:36:40,080 --> 01:36:45,440
for small code the initialization can

01:36:42,639 --> 01:36:47,840
take majority of all compilation

01:36:45,440 --> 01:36:50,400
and small method code is typical for

01:36:47,840 --> 01:36:52,960
dynamic high-level languages

01:36:50,400 --> 01:36:54,480
so you cannot switch off optimizations

01:36:52,960 --> 01:36:57,760
and proportionally speed up

01:36:54,480 --> 01:36:57,760
gcc and clank

01:36:58,719 --> 01:37:01,840
to get a better performance we need to

01:37:01,040 --> 01:37:04,159
inline c

01:37:01,840 --> 01:37:04,960
code implement implementing standard

01:37:04,159 --> 01:37:08,080
ruby methods

01:37:04,960 --> 01:37:11,199
besides function from the environment

01:37:08,080 --> 01:37:12,080
here's a small example ruby code calls

01:37:11,199 --> 01:37:15,440
method

01:37:12,080 --> 01:37:18,560
times which is implemented on c this c

01:37:15,440 --> 01:37:22,159
code call calls several times another

01:37:18,560 --> 01:37:24,400
ruby code implement in multiplication

01:37:22,159 --> 01:37:28,000
how can we integrate all three code

01:37:24,400 --> 01:37:29,920
parts in one generated function code

01:37:28,000 --> 01:37:31,199
let us consider again the current engine

01:37:29,920 --> 01:37:33,360
structure

01:37:31,199 --> 01:37:36,000
c function which can be enlightened

01:37:33,360 --> 01:37:38,560
should be in the pre-compiled header

01:37:36,000 --> 01:37:41,040
the more code we insert into the header

01:37:38,560 --> 01:37:44,800
the slow jit code generation because of

01:37:41,040 --> 01:37:44,800
much bigger pre-compiled header

01:37:45,679 --> 01:37:49,679
in brief my experience with amg shows

01:37:48,159 --> 01:37:52,480
that gcc client

01:37:49,679 --> 01:37:53,360
can be excellent tired to compilers but

01:37:52,480 --> 01:37:56,639
they cannot be

01:37:53,360 --> 01:37:57,520
attained one compile their own compiler

01:37:56,639 --> 01:38:00,080
should be much

01:37:57,520 --> 01:38:01,119
faster and smaller its performance is

01:38:00,080 --> 01:38:04,000
less important

01:38:01,119 --> 01:38:04,719
especially for dynamic languages by

01:38:04,000 --> 01:38:07,440
implementing

01:38:04,719 --> 01:38:08,320
inlining and aggressive speculation is

01:38:07,440 --> 01:38:10,400
more important

01:38:08,320 --> 01:38:12,719
for performance than classical compiler

01:38:10,400 --> 01:38:15,600
optimizations

01:38:12,719 --> 01:38:17,280
jet compiler should generate code

01:38:15,600 --> 01:38:20,719
directly in memory

01:38:17,280 --> 01:38:22,560
llvm and cgit can do this unfortunately

01:38:20,719 --> 01:38:26,719
it's not true for libgcc

01:38:22,560 --> 01:38:28,320
jet and gcc gcc needs embedded assembler

01:38:26,719 --> 01:38:32,239
and load

01:38:28,320 --> 01:38:33,840
rip gcc needs needs a streamable input

01:38:32,239 --> 01:38:38,000
language

01:38:33,840 --> 01:38:40,320
not only api the language should be

01:38:38,000 --> 01:38:41,679
very quickly compiled readable and

01:38:40,320 --> 01:38:45,199
desirably

01:38:41,679 --> 01:38:47,520
of high level ideally of c language

01:38:45,199 --> 01:38:47,520
level

01:38:48,400 --> 01:38:53,760
so after mg implementation i believe

01:38:50,800 --> 01:38:56,080
crub needs a lightweight compiler

01:38:53,760 --> 01:38:57,760
the lightweight compiler should be an

01:38:56,080 --> 01:39:00,480
addition to existing mg

01:38:57,760 --> 01:39:02,800
generating c code or the on rigid

01:39:00,480 --> 01:39:05,040
compiler where the current one does not

01:39:02,800 --> 01:39:05,040
work

01:39:05,679 --> 01:39:09,119
so about two years ago i started to work

01:39:08,719 --> 01:39:11,760
on

01:39:09,119 --> 01:39:12,719
a lightweight jet compiler initially in

01:39:11,760 --> 01:39:14,880
my spare time

01:39:12,719 --> 01:39:17,679
and later i started to spend half of my

01:39:14,880 --> 01:39:19,840
work time on this project

01:39:17,679 --> 01:39:21,040
because i'd like to use jit compiler not

01:39:19,840 --> 01:39:23,840
only for ruby

01:39:21,040 --> 01:39:24,880
i decided to make it an universal jet

01:39:23,840 --> 01:39:28,159
compiler

01:39:24,880 --> 01:39:29,600
and a standalone project the central

01:39:28,159 --> 01:39:32,000
notion of the project

01:39:29,600 --> 01:39:34,400
is well-defined intermediate language

01:39:32,000 --> 01:39:36,560
called mir

01:39:34,400 --> 01:39:37,679
mir is strongly a type and flexible

01:39:36,560 --> 01:39:40,080
enough

01:39:37,679 --> 01:39:41,280
mere in different forms can represent

01:39:40,080 --> 01:39:44,880
machine code for

01:39:41,280 --> 01:39:44,880
risk and risk processors

01:39:45,760 --> 01:39:50,080
to get a better understanding what is

01:39:47,760 --> 01:39:50,880
beer let us consider the ereta's fan

01:39:50,080 --> 01:39:56,080
shift code

01:39:50,880 --> 01:39:56,080
as an example here is the c code for c

01:39:57,600 --> 01:40:02,239
and here is mere textual representation

01:40:00,560 --> 01:40:04,320
for the same code

01:40:02,239 --> 01:40:06,880
there are no hard registers in there

01:40:04,320 --> 01:40:10,159
only typed variables

01:40:06,880 --> 01:40:12,000
call api is also hidden

01:40:10,159 --> 01:40:14,080
first operand in the function of the

01:40:12,000 --> 01:40:17,440
instruction is function return type

01:40:14,080 --> 01:40:20,560
and then all arguments are declared

01:40:17,440 --> 01:40:21,520
local variables are declared as 64-bit

01:40:20,560 --> 01:40:25,280
integers

01:40:21,520 --> 01:40:25,280
through local pfd instruction

01:40:26,639 --> 01:40:32,960
i set up sub performance goals for

01:40:29,679 --> 01:40:33,760
digit compiler comparing to gcc it

01:40:32,960 --> 01:40:37,360
should have

01:40:33,760 --> 01:40:38,800
100 times faster compilation 100 times

01:40:37,360 --> 01:40:42,239
faster startup

01:40:38,800 --> 01:40:44,400
and 100 times smaller code size

01:40:42,239 --> 01:40:46,480
as for the the generated code

01:40:44,400 --> 01:40:50,480
performance i decided

01:40:46,480 --> 01:40:50,480
it should be at least 70 percent

01:40:53,280 --> 01:40:56,400
it should be simple to less than 10 000

01:40:56,159 --> 01:40:59,040
c

01:40:56,400 --> 01:41:00,560
lines because i want a wider adoption of

01:40:59,040 --> 01:41:02,880
it

01:41:00,560 --> 01:41:04,000
i'd like to avoid avoid any external

01:41:02,880 --> 01:41:07,040
dependency for this

01:41:04,000 --> 01:41:11,119
project too i will talk later about

01:41:07,040 --> 01:41:11,119
what's the actual results i have now

01:41:12,000 --> 01:41:16,400
how to achieve the performance goals

01:41:14,159 --> 01:41:18,400
optimizing compilers like gcc

01:41:16,400 --> 01:41:19,520
are big and complex because they are

01:41:18,400 --> 01:41:22,800
trying to improve

01:41:19,520 --> 01:41:25,600
any code including array edge cases

01:41:22,800 --> 01:41:27,520
they practically they use practically

01:41:25,600 --> 01:41:29,360
any known optimization

01:41:27,520 --> 01:41:31,840
a lot of complicated code data

01:41:29,360 --> 01:41:35,520
structures to effectively compile

01:41:31,840 --> 01:41:36,800
functions of any size so to achieve our

01:41:35,520 --> 01:41:40,159
goals we need to use

01:41:36,800 --> 01:41:42,000
few most valuable optimizations optimize

01:41:40,159 --> 01:41:44,159
only frequent cases

01:41:42,000 --> 01:41:46,080
and use algorithms with the best

01:41:44,159 --> 01:41:48,239
combination of simplicity and

01:41:46,080 --> 01:41:50,239
performance

01:41:48,239 --> 01:41:53,040
so what are the most available

01:41:50,239 --> 01:41:53,040
optimizations

01:41:53,840 --> 01:41:59,440
the most important optimizations are

01:41:56,000 --> 01:42:02,080
only effectively exploiting

01:41:59,440 --> 01:42:02,800
uh once effectively exploiting most

01:42:02,080 --> 01:42:06,000
common

01:42:02,800 --> 01:42:08,800
cpu resources instruction set and

01:42:06,000 --> 01:42:09,840
registers so the most valuable

01:42:08,800 --> 01:42:12,840
optimizations

01:42:09,840 --> 01:42:14,560
are a good register allocation and code

01:42:12,840 --> 01:42:16,639
selection

01:42:14,560 --> 01:42:18,480
some time ago i did an experiment

01:42:16,639 --> 01:42:20,880
switching on only

01:42:18,480 --> 01:42:23,040
a fast and simple register allocator and

01:42:20,880 --> 01:42:25,360
combiner in gcc

01:42:23,040 --> 01:42:27,600
comparing to hundreds of optimizations

01:42:25,360 --> 01:42:30,159
in gcc with minus o2

01:42:27,600 --> 01:42:32,239
these two optimizations achieve almost

01:42:30,159 --> 01:42:34,960
80 percent performance on spec

01:42:32,239 --> 01:42:34,960
in 2000

01:42:35,440 --> 01:42:38,639
here's the diagram showing the current

01:42:37,199 --> 01:42:41,600
state of

01:42:38,639 --> 01:42:42,000
the life widget project currently i can

01:42:41,600 --> 01:42:45,840
create

01:42:42,000 --> 01:42:49,440
mirrors through api or from mere textual

01:42:45,840 --> 01:42:50,480
or binary representation mere binary

01:42:49,440 --> 01:42:52,960
representation

01:42:50,480 --> 01:42:54,159
is three times more compact and four

01:42:52,960 --> 01:42:57,760
times faster

01:42:54,159 --> 01:43:00,080
to read than the textual one

01:42:57,760 --> 01:43:01,840
i can interpret pure code and generate

01:43:00,080 --> 01:43:05,040
machine code in memory from

01:43:01,840 --> 01:43:08,159
for from here for two

01:43:05,040 --> 01:43:09,679
different targets there are no any

01:43:08,159 --> 01:43:12,320
external dependencies

01:43:09,679 --> 01:43:14,400
besides standard c library i can

01:43:12,320 --> 01:43:17,520
generate c code from here

01:43:14,400 --> 01:43:18,719
and i am also working on c to mere

01:43:17,520 --> 01:43:21,840
compilers

01:43:18,719 --> 01:43:25,360
by implementing llvm to mirror and my

01:43:21,840 --> 01:43:27,600
own c compiler

01:43:25,360 --> 01:43:30,320
here is the diagram showing the possible

01:43:27,600 --> 01:43:32,719
development directions of the project

01:43:30,320 --> 01:43:34,000
generating beer from llvm internal

01:43:32,719 --> 01:43:37,760
representation

01:43:34,000 --> 01:43:40,400
opens use of code on different languages

01:43:37,760 --> 01:43:43,520
implemented with llvm

01:43:40,400 --> 01:43:46,080
generated mir from java byte code would

01:43:43,520 --> 01:43:47,920
do the same for languages implemented

01:43:46,080 --> 01:43:50,400
with jvm

01:43:47,920 --> 01:43:53,840
generated web assembly from here could

01:43:50,400 --> 01:43:55,600
help to use mirror code and web browsers

01:43:53,840 --> 01:43:56,960
there will be a lot of interesting

01:43:55,600 --> 01:43:59,679
possibilities if

01:43:56,960 --> 01:44:02,320
even a part of these directions are

01:43:59,679 --> 01:44:02,320
implemented

01:44:02,639 --> 01:44:07,199
the most interesting component at least

01:44:04,639 --> 01:44:09,600
for me is smear generator

01:44:07,199 --> 01:44:10,800
it can work on different optimization

01:44:09,600 --> 01:44:14,159
levels

01:44:10,800 --> 01:44:14,560
there is very a very fast generation

01:44:14,159 --> 01:44:17,920
part

01:44:14,560 --> 01:44:21,040
without building control flow graph and

01:44:17,920 --> 01:44:23,199
any data flow analysis

01:44:21,040 --> 01:44:24,960
the generator also implements linear

01:44:23,199 --> 01:44:27,920
scan register allocator

01:44:24,960 --> 01:44:30,239
and code selector as the most valuable

01:44:27,920 --> 01:44:32,639
optimizations

01:44:30,239 --> 01:44:34,719
sparse conditional constant propagation

01:44:32,639 --> 01:44:35,199
and common sub-expression elimination

01:44:34,719 --> 01:44:38,320
will be

01:44:35,199 --> 01:44:40,400
important for in-line functions in c

01:44:38,320 --> 01:44:42,800
ruby environment

01:44:40,400 --> 01:44:45,360
register renaming is for improving

01:44:42,800 --> 01:44:47,520
register allocation

01:44:45,360 --> 01:44:49,679
i also implemented register pressure

01:44:47,520 --> 01:44:52,719
sensitive loop and variant

01:44:49,679 --> 01:44:55,679
motion but probably i remove it

01:44:52,719 --> 01:44:58,480
in the future as it has small value for

01:44:55,679 --> 01:44:58,480
my purposes

01:44:59,520 --> 01:45:02,800
i started with only register allocator

01:45:01,920 --> 01:45:06,239
and combiner

01:45:02,800 --> 01:45:09,040
therefore i did not use ssa

01:45:06,239 --> 01:45:09,520
then i added few optimization later not

01:45:09,040 --> 01:45:13,520
using

01:45:09,520 --> 01:45:15,440
ssa i think it was a mistake

01:45:13,520 --> 01:45:17,679
now i am planning to use conventional

01:45:15,440 --> 01:45:19,920
ssa in the future

01:45:17,679 --> 01:45:21,760
also i don't generate position

01:45:19,920 --> 01:45:24,159
independent code

01:45:21,760 --> 01:45:27,600
generating such code is more complicated

01:45:24,159 --> 01:45:27,600
and decreases performance

01:45:29,360 --> 01:45:34,880
to start usage of building a ruby i need

01:45:32,719 --> 01:45:38,239
see to mere compile

01:45:34,880 --> 01:45:41,520
there are several ways to implement it

01:45:38,239 --> 01:45:44,639
it could implement i could implement

01:45:41,520 --> 01:45:47,760
llcm ir to mir compiler

01:45:44,639 --> 01:45:49,920
or right gcc port to mirror but

01:45:47,760 --> 01:45:51,920
it would create a big dependence to a

01:45:49,920 --> 01:45:56,000
particular external project for

01:45:51,920 --> 01:45:59,360
ruby on the other hand some people

01:45:56,000 --> 01:46:01,760
wrote small c compiles pretty quickly

01:45:59,360 --> 01:46:03,280
so i decided to write on c compile

01:46:01,760 --> 01:46:06,080
automate first

01:46:03,280 --> 01:46:06,719
it should implement standard c11 without

01:46:06,080 --> 01:46:12,159
optional

01:46:06,719 --> 01:46:13,040
variable arrays complex and atomics my

01:46:12,159 --> 01:46:15,199
approach to

01:46:13,040 --> 01:46:16,719
dc compiler implementation is classic

01:46:15,199 --> 01:46:19,679
division on four

01:46:16,719 --> 01:46:21,119
on four passes of approximately the same

01:46:19,679 --> 01:46:23,600
size

01:46:21,119 --> 01:46:26,000
mute to c compiler is mostly done it

01:46:23,600 --> 01:46:29,280
passes about thousand small tests

01:46:26,000 --> 01:46:31,520
and successfully bootstrap itself

01:46:29,280 --> 01:46:33,360
it can be used as a library and there is

01:46:31,520 --> 01:46:36,000
a driver to use it from

01:46:33,360 --> 01:46:36,000
command line

01:46:36,560 --> 01:46:41,520
and finally the current performance

01:46:39,280 --> 01:46:45,520
results for a mere generator and

01:46:41,520 --> 01:46:48,320
interpreter comparing to gcc

01:46:45,520 --> 01:46:48,719
i used received benchmark which consists

01:46:48,320 --> 01:46:51,840
of

01:46:48,719 --> 01:46:54,960
only 30 preprocessed lines

01:46:51,840 --> 01:46:58,480
compilation speed of mere generator

01:46:54,960 --> 01:47:00,320
is about 300 times faster than gcc with

01:46:58,480 --> 01:47:03,040
-2

01:47:00,320 --> 01:47:05,520
it takes only 50 microseconds to

01:47:03,040 --> 01:47:08,960
generate code for shift

01:47:05,520 --> 01:47:11,920
and circle shift code generated by

01:47:08,960 --> 01:47:14,159
merge generator is only five percent

01:47:11,920 --> 01:47:16,880
slow

01:47:14,159 --> 01:47:19,040
merge generator object size is much much

01:47:16,880 --> 01:47:22,080
smaller than gcc

01:47:19,040 --> 01:47:22,480
merge generator has a very fast startup

01:47:22,080 --> 01:47:26,320
time

01:47:22,480 --> 01:47:29,119
and suitable for tire widget tire one

01:47:26,320 --> 01:47:29,119
jit compiler

01:47:29,679 --> 01:47:34,800
ks source line distribution for the

01:47:32,239 --> 01:47:38,320
current state of mir project

01:47:34,800 --> 01:47:42,880
the mirko and mir2c compiler

01:47:38,320 --> 01:47:46,880
are about 10 12 000 lines each

01:47:42,880 --> 01:47:50,320
generator is a bit more than 6000 lines

01:47:46,880 --> 01:47:52,560
motion dependent code used by generator

01:47:50,320 --> 01:47:55,040
is about two three thousand lines for

01:47:52,560 --> 01:47:58,639
each target

01:47:55,040 --> 01:48:05,280
porting khmer to a new targets takes

01:47:58,639 --> 01:48:08,000
about one two months for me

01:48:05,280 --> 01:48:10,159
uh sorry i have no time for this slide

01:48:08,000 --> 01:48:13,199
so i am skipping it

01:48:10,159 --> 01:48:16,239
but uh this slide may be

01:48:13,199 --> 01:48:19,360
uh will will be useful for

01:48:16,239 --> 01:48:22,480
people later if they won't compare

01:48:19,360 --> 01:48:25,760
my beer project with other

01:48:22,480 --> 01:48:25,760
jet compiler projects

01:48:25,840 --> 01:48:31,199
about the future plans beer is

01:48:29,040 --> 01:48:32,719
already used in several language

01:48:31,199 --> 01:48:35,520
implementations

01:48:32,719 --> 01:48:37,280
and people are asking me to make a first

01:48:35,520 --> 01:48:40,080
release of it

01:48:37,280 --> 01:48:42,080
so i am planning to do this at the end

01:48:40,080 --> 01:48:45,760
of this year

01:48:42,080 --> 01:48:46,800
i'd like to have a prototype m ruby jet

01:48:45,760 --> 01:48:50,159
compiler

01:48:46,800 --> 01:48:52,159
based on mere in one ear i'm sure

01:48:50,159 --> 01:48:55,199
working on it will affect

01:48:52,159 --> 01:48:57,199
the future mir

01:48:55,199 --> 01:48:58,480
if you are interested you can find the

01:48:57,199 --> 01:49:02,159
source on github

01:48:58,480 --> 01:49:05,920
here's the link and that's it for today

01:49:02,159 --> 01:49:09,280
thank you for for your attention and

01:49:05,920 --> 01:49:11,520
i'm ready to answer a question if you

01:49:09,280 --> 01:49:11,520
have

01:49:12,840 --> 01:49:15,840
some

01:49:16,639 --> 01:49:29,840
thank you vladimir we have a few more

01:49:18,880 --> 01:49:29,840
minutes for questions

01:49:31,199 --> 01:49:33,599
david

01:49:34,880 --> 01:49:40,719
um is there a liber in existence that i

01:49:39,040 --> 01:49:43,040
i guess my obvious

01:49:40,719 --> 01:49:43,040
thing to

01:49:47,440 --> 01:49:51,840
context which might be a way of getting

01:49:50,080 --> 01:49:55,040
a kind of a tier two

01:49:51,840 --> 01:49:58,639
uh chip compiler um for free

01:49:55,040 --> 01:50:00,800
air quotes from there that might be a

01:49:58,639 --> 01:50:02,560
thing i might try to like to try hacking

01:50:00,800 --> 01:50:05,760
on

01:50:02,560 --> 01:50:09,199
yeah you are right actually

01:50:05,760 --> 01:50:09,199
i am considering um

01:50:09,599 --> 01:50:16,480
so in the future to make

01:50:12,719 --> 01:50:20,719
gcc uh port two mirror and uh

01:50:16,480 --> 01:50:24,320
uh make amber as input to gcc probably

01:50:20,719 --> 01:50:27,760
two libraries jet so

01:50:24,320 --> 01:50:31,040
people using pre-produced you could uh

01:50:27,760 --> 01:50:31,440
also use beer for this but my experience

01:50:31,040 --> 01:50:34,800
actually

01:50:31,440 --> 01:50:36,719
beer is a pretty low level too

01:50:34,800 --> 01:50:39,360
although it's called medium internal

01:50:36,719 --> 01:50:42,639
representation but people prefer

01:50:39,360 --> 01:50:45,840
to use something even

01:50:42,639 --> 01:50:49,280
more high level language

01:50:45,840 --> 01:50:53,199
for example people are asking me

01:50:49,280 --> 01:50:58,000
to use even might see to mere compiler

01:50:53,199 --> 01:50:58,000
as input language for their jits

01:50:59,040 --> 01:51:03,119
there i should say there are several

01:51:01,679 --> 01:51:07,040
implementations

01:51:03,119 --> 01:51:09,679
of uh languages

01:51:07,040 --> 01:51:10,800
with mural radio although there are no

01:51:09,679 --> 01:51:13,920
there is no

01:51:10,800 --> 01:51:15,040
first release and one interesting

01:51:13,920 --> 01:51:19,040
project is

01:51:15,040 --> 01:51:22,400
called arabi they trying to use

01:51:19,040 --> 01:51:25,119
every possible jit to implement

01:51:22,400 --> 01:51:27,599
this language it's it's kind of uh lower

01:51:25,119 --> 01:51:29,360
dialect with static typing

01:51:27,599 --> 01:51:30,800
so it's interesting to compare

01:51:29,360 --> 01:51:34,239
performance

01:51:30,800 --> 01:51:38,239
uh a mere with other

01:51:34,239 --> 01:51:40,639
uh jit compilers and

01:51:38,239 --> 01:51:42,639
i got the feedback for example that om

01:51:40,639 --> 01:51:46,159
ibm omg

01:51:42,639 --> 01:51:48,800
and uh my mere

01:51:46,159 --> 01:52:02,320
jet compiler is practically the same

01:51:48,800 --> 01:52:04,080
with performance point of view

01:52:02,320 --> 01:52:05,920
so i guess that's so i don't know if

01:52:04,080 --> 01:52:11,119
there's anybody else out there that is

01:52:05,920 --> 01:52:12,480
uh pondering using gcc as a jet but um

01:52:11,119 --> 01:52:15,520
i know you were dragged into the

01:52:12,480 --> 01:52:16,480
conversation with ruby and the gcc jet

01:52:15,520 --> 01:52:19,760
uh about

01:52:16,480 --> 01:52:23,199
uh six months to a year ago vlad where

01:52:19,760 --> 01:52:24,159
uh the ruby project was using gc as a

01:52:23,199 --> 01:52:27,199
jet

01:52:24,159 --> 01:52:30,239
and it was using uh pre-compiled headers

01:52:27,199 --> 01:52:32,159
that sound familiar and yeah anything

01:52:30,239 --> 01:52:36,080
using pch

01:52:32,159 --> 01:52:39,040
in a world where uh we have

01:52:36,080 --> 01:52:40,480
high executables and address space

01:52:39,040 --> 01:52:44,800
layout randomization

01:52:40,480 --> 01:52:47,920
is doomed to failure and i think the

01:52:44,800 --> 01:52:50,760
the the take away from that is

01:52:47,920 --> 01:52:52,000
the startup time for gcc makes it

01:52:50,760 --> 01:52:55,599
infeasible

01:52:52,000 --> 01:52:58,960
as a jet and so i i would be very

01:52:55,599 --> 01:53:02,000
hesitant anybody go off and use gcc

01:52:58,960 --> 01:53:05,199
as a jet engine because of that

01:53:02,000 --> 01:53:09,280
yeah yeah i agree with you but

01:53:05,199 --> 01:53:12,080
uh my understanding we should fix

01:53:09,280 --> 01:53:12,960
pre-compiled headers and make it working

01:53:12,080 --> 01:53:16,560
for

01:53:12,960 --> 01:53:19,840
uh page randomizations because uh

01:53:16,560 --> 01:53:23,520
yeah how do you rewrite it yeah yeah

01:53:19,840 --> 01:53:26,480
they they used uh not only uh

01:53:23,520 --> 01:53:28,080
by me but for example i know virtual box

01:53:26,480 --> 01:53:30,560
uses uh

01:53:28,080 --> 01:53:31,760
pre-compiled headers very actively and

01:53:30,560 --> 01:53:34,880
if it's broken

01:53:31,760 --> 01:53:38,159
it's not good because for clank

01:53:34,880 --> 01:53:40,800
pre-compiled headers works very well

01:53:38,159 --> 01:53:42,880
with randomization with pressure

01:53:40,800 --> 01:53:46,639
optimizations

01:53:42,880 --> 01:53:49,599
yep well they do it right yeah

01:53:46,639 --> 01:53:52,159
yeah they they have a real streamable

01:53:49,599 --> 01:53:55,040
language it's very compact in comparison

01:53:52,159 --> 01:53:58,560
pre-compiled headers with gcc

01:53:55,040 --> 01:54:00,000
of gcc gcc is simply a hack they just

01:53:58,560 --> 01:54:09,679
dump memory

01:54:00,000 --> 01:54:11,679
and that's it

01:54:09,679 --> 01:54:14,080
jeff would you like to ask uh some

01:54:11,679 --> 01:54:16,159
questions

01:54:14,080 --> 01:54:17,119
oh that was me talking with glad just a

01:54:16,159 --> 01:54:23,840
moment ago

01:54:17,119 --> 01:54:23,840
okay sorry no worries joel

01:54:25,040 --> 01:54:28,960
hey vlad this is david really really

01:54:27,520 --> 01:54:30,159
interesting work really great work on

01:54:28,960 --> 01:54:32,000
this

01:54:30,159 --> 01:54:34,840
i was curious if you thought about this

01:54:32,000 --> 01:54:37,840
in terms of like a cython

01:54:34,840 --> 01:54:40,880
interface as opposed to a jit

01:54:37,840 --> 01:54:44,960
in other words using gcc for

01:54:40,880 --> 01:54:44,960
to compile in a

01:54:45,599 --> 01:54:48,639
less immediate way where the startup

01:54:47,280 --> 01:54:51,760
time again with cython

01:54:48,639 --> 01:54:55,119
for compiling a cython code isn't uh

01:54:51,760 --> 01:54:57,280
isn't critical yeah

01:54:55,119 --> 01:55:00,000
it would be interesting to use it for

01:54:57,280 --> 01:55:04,880
other dynamic languages since

01:55:00,000 --> 01:55:07,520
uh cyto or python could be uh

01:55:04,880 --> 01:55:08,480
interesting uh for this but i i didn't

01:55:07,520 --> 01:55:12,000
mean using it for

01:55:08,480 --> 01:55:15,520
cython i meant you instead of having

01:55:12,000 --> 01:55:18,320
this c ruby as a jit

01:55:15,520 --> 01:55:19,599
where it's immediate have see ruby

01:55:18,320 --> 01:55:22,719
behave like

01:55:19,599 --> 01:55:22,719
c cython

01:55:23,440 --> 01:55:30,159
yeah there were a lot of different

01:55:27,280 --> 01:55:30,719
attempts to implement zero budgets and

01:55:30,159 --> 01:55:33,679
i'm sure

01:55:30,719 --> 01:55:35,119
somebody already tried this for example

01:55:33,679 --> 01:55:40,880
uh

01:55:35,119 --> 01:55:40,880
c ruby some people tried to use

01:55:41,280 --> 01:55:49,119
javascript and all this stuff but

01:55:44,400 --> 01:55:53,280
it didn't work so i i don't know

01:55:49,119 --> 01:55:56,320
i don't know how my approach is to use

01:55:53,280 --> 01:56:01,840
mir project for implementing

01:55:56,320 --> 01:56:01,840
c ruby and ambro budget

01:56:02,400 --> 01:56:06,239
thank you vladimir thank you everyone

01:56:04,159 --> 01:56:06,800
for your questions as well and your

01:56:06,239 --> 01:56:08,320
interest

01:56:06,800 --> 01:56:10,960
i'm sorry we're running out of time so

01:56:08,320 --> 01:56:12,880
we need to set up for the next one

01:56:10,960 --> 01:56:14,080
and the next presentation is an update

01:56:12,880 --> 01:56:16,639
on project ranger

01:56:14,080 --> 01:56:19,760
from andrew and aldi andrew if you want

01:56:16,639 --> 01:56:19,760
to stop video

01:56:24,159 --> 01:56:30,320
andrew i'm trying it was working a

01:56:27,840 --> 01:56:30,320
minute ago

01:56:34,800 --> 01:56:43,840
and it doesn't seem to want to let me at

01:56:36,960 --> 01:56:43,840
the moment this all worked not long ago

01:56:45,840 --> 01:56:48,800
oh there we go okay

01:56:52,239 --> 01:56:56,239
all right there am i showing up uh

01:56:55,360 --> 01:56:58,800
almost

01:56:56,239 --> 01:57:00,480
andrew andrew and i'm just gonna make

01:56:58,800 --> 01:57:04,560
you presenter

01:57:00,480 --> 01:57:08,400
andrew all right it's not true

01:57:04,560 --> 01:57:10,159
sorry here we go so andrew you should

01:57:08,400 --> 01:57:12,080
have uh presenting

01:57:10,159 --> 01:57:14,159
right so the floor is yours have a good

01:57:12,080 --> 01:57:14,480
presentation uh you for some reason i

01:57:14,159 --> 01:57:16,560
can't

01:57:14,480 --> 01:57:19,199
do my own video so hopefully i'm sort of

01:57:16,560 --> 01:57:20,960
centered here

01:57:19,199 --> 01:57:22,239
um all right so i'm just going to give

01:57:20,960 --> 01:57:25,199
you a quick a quick

01:57:22,239 --> 01:57:26,800
update on ranger project which we

01:57:25,199 --> 01:57:30,239
introduced last year at the

01:57:26,800 --> 01:57:31,520
tools cauldron um so

01:57:30,239 --> 01:57:33,199
today what i'm planning to do is i'm

01:57:31,520 --> 01:57:33,920
just going to give her no i'm not sure

01:57:33,199 --> 01:57:35,360
everybody

01:57:33,920 --> 01:57:37,440
had attended that so i'll give you a

01:57:35,360 --> 01:57:40,000
very quick update maybe five minutes on

01:57:37,440 --> 01:57:41,679
what the ranger project is then i'll

01:57:40,000 --> 01:57:43,760
give a brief rundown on what's

01:57:41,679 --> 01:57:44,880
changed since then what we're planning

01:57:43,760 --> 01:57:48,000
to do in stage one

01:57:44,880 --> 01:57:51,760
and and beyond after that

01:57:48,000 --> 01:57:53,280
um all right and by the way if anyone

01:57:51,760 --> 01:57:55,760
has any questions feel free to interrupt

01:57:53,280 --> 01:57:58,880
me at any point through this

01:57:55,760 --> 01:58:03,360
um so the ranger project itself is

01:57:58,880 --> 01:58:05,679
uh was created in order to generate

01:58:03,360 --> 01:58:07,040
much more accurate ranges with a very

01:58:05,679 --> 01:58:09,840
lightweight infrastructure

01:58:07,040 --> 01:58:10,239
in order to do that we needed to provide

01:58:09,840 --> 01:58:12,159
we

01:58:10,239 --> 01:58:13,599
provide basically three things uh one is

01:58:12,159 --> 01:58:16,800
the range ops which

01:58:13,599 --> 01:58:17,199
teaches teaches the compiler how to

01:58:16,800 --> 01:58:18,560
perform

01:58:17,199 --> 01:58:19,920
operations on ranges for all the

01:58:18,560 --> 01:58:21,679
different tree codes so how did how to

01:58:19,920 --> 01:58:25,599
add ranges how to subtract ranges

01:58:21,679 --> 01:58:28,800
stuff like that um then we support

01:58:25,599 --> 01:58:30,880
the original ranged classes

01:58:28,800 --> 01:58:32,080
supported just like a pair of a pair of

01:58:30,880 --> 01:58:35,520
values for ranges

01:58:32,080 --> 01:58:35,920
and we're providing much more accuracy

01:58:35,520 --> 01:58:39,119
so

01:58:35,920 --> 01:58:40,560
multiple sub-ranges and then the ranger

01:58:39,119 --> 01:58:43,360
infrastructure itself

01:58:40,560 --> 01:58:45,280
um does queries for ranges watch the cfg

01:58:43,360 --> 01:58:47,199
puts all the information together

01:58:45,280 --> 01:58:48,320
and does it in an on-demand way so you

01:58:47,199 --> 01:58:50,320
don't need to

01:58:48,320 --> 01:58:51,840
walk through the entire program in order

01:58:50,320 --> 01:58:55,280
to ask at some point you just ask the

01:58:51,840 --> 01:58:55,280
question and it'll go figure it all out

01:58:55,520 --> 01:58:59,520
so the raindrops part like i had

01:58:58,400 --> 01:59:02,000
mentioned

01:58:59,520 --> 01:59:02,639
solves problems for each individual op

01:59:02,000 --> 01:59:04,480
code

01:59:02,639 --> 01:59:06,960
but it it's actually an equation solver

01:59:04,480 --> 01:59:09,040
it's not just a folder like

01:59:06,960 --> 01:59:11,520
the way we currently do things you could

01:59:09,040 --> 01:59:13,679
fold a plus and get a result

01:59:11,520 --> 01:59:15,119
now if we know what the left hand side

01:59:13,679 --> 01:59:18,400
is and we know one of the other

01:59:15,119 --> 01:59:20,000
operands it'll solve for the other

01:59:18,400 --> 01:59:21,520
and that allows us to do a lot of

01:59:20,000 --> 01:59:24,800
interesting things

01:59:21,520 --> 01:59:27,599
in particular we we can work backwards

01:59:24,800 --> 01:59:29,520
so when you get an if at the bottom of a

01:59:27,599 --> 01:59:32,159
at the bottom of an expression

01:59:29,520 --> 01:59:33,599
the left if you take in the true side

01:59:32,159 --> 01:59:34,560
the left-hand side of that if is

01:59:33,599 --> 01:59:38,480
actually

01:59:34,560 --> 01:59:42,159
a one a true and so you can solve for

01:59:38,480 --> 01:59:43,920
um you can solve for the

01:59:42,159 --> 01:59:45,440
in the example that's there you can

01:59:43,920 --> 01:59:47,360
solve for x

01:59:45,440 --> 01:59:48,719
and then you can keep feeding that back

01:59:47,360 --> 01:59:50,480
and so you can step back through the

01:59:48,719 --> 01:59:51,760
program and that that's how that's why

01:59:50,480 --> 01:59:52,960
we don't have to walk all the way

01:59:51,760 --> 01:59:53,520
through the program from the top to the

01:59:52,960 --> 01:59:55,119
bottom

01:59:53,520 --> 01:59:57,199
we can just walk back as far as we need

01:59:55,119 --> 01:59:58,880
to and frequently you don't have to walk

01:59:57,199 --> 02:00:01,040
back very far to the answers to the

01:59:58,880 --> 02:00:02,800
questions you're looking for

02:00:01,040 --> 02:00:04,639
this aspect we manage we managed to get

02:00:02,800 --> 02:00:06,000
into trunk last year before stage one

02:00:04,639 --> 02:00:08,639
cut off

02:00:06,000 --> 02:00:10,080
so evrp and vrp and all the current

02:00:08,639 --> 02:00:12,639
range

02:00:10,080 --> 02:00:13,679
infrastructure uses raindrops under the

02:00:12,639 --> 02:00:15,920
covers to to

02:00:13,679 --> 02:00:16,800
to do the folding we don't utilize any

02:00:15,920 --> 02:00:18,719
of the

02:00:16,800 --> 02:00:22,000
equation solving parts yet that's

02:00:18,719 --> 02:00:26,239
that'll come out online with the ranger

02:00:22,000 --> 02:00:27,599
um the implementation of multiple

02:00:26,239 --> 02:00:30,880
sub-ranges

02:00:27,599 --> 02:00:32,000
it's basically non-overlapping integral

02:00:30,880 --> 02:00:34,000
sub-ranges

02:00:32,000 --> 02:00:36,880
with an arbitrary number of them to

02:00:34,000 --> 02:00:36,880
represent the range

02:00:38,880 --> 02:00:41,520
i don't know if i need to say much else

02:00:40,159 --> 02:00:43,040
about that right now it's just it's just

02:00:41,520 --> 02:00:46,000
an alternate representation

02:00:43,040 --> 02:00:46,800
um when i get to what's in going into

02:00:46,000 --> 02:00:48,159
trunk right now

02:00:46,800 --> 02:00:50,639
i'll give you a little bit more

02:00:48,159 --> 02:00:53,119
information about that

02:00:50,639 --> 02:00:54,320
um and then there's the ranger itself uh

02:00:53,119 --> 02:00:56,639
we basically

02:00:54,320 --> 02:00:58,480
boil everything down to one of one of

02:00:56,639 --> 02:01:00,239
five questions and for most

02:00:58,480 --> 02:01:01,440
optimizations the first three are all

02:01:00,239 --> 02:01:03,119
they really need to do

02:01:01,440 --> 02:01:04,880
you can ask at any given point in the

02:01:03,119 --> 02:01:06,400
program you can point to an operand and

02:01:04,880 --> 02:01:07,760
say what's the range right here at this

02:01:06,400 --> 02:01:09,920
point

02:01:07,760 --> 02:01:11,199
you can ask what the result of this

02:01:09,920 --> 02:01:12,960
statement is so you can ask what the

02:01:11,199 --> 02:01:16,159
left-hand side is of any given

02:01:12,960 --> 02:01:18,000
statement and you can also ask on an

02:01:16,159 --> 02:01:19,599
incoming edge what's the range on this

02:01:18,000 --> 02:01:21,199
edge

02:01:19,599 --> 02:01:24,239
and that seems to actually cover still

02:01:21,199 --> 02:01:27,679
everything we ever really need

02:01:24,239 --> 02:01:31,199
okay so that's it for the quick summary

02:01:27,679 --> 02:01:32,239
um for the statement for the expression

02:01:31,199 --> 02:01:34,800
the first one uh

02:01:32,239 --> 02:01:36,480
is it before the statement or after it's

02:01:34,800 --> 02:01:38,000
it's before the statement is executed so

02:01:36,480 --> 02:01:38,639
it's the incoming values to the

02:01:38,000 --> 02:01:40,159
statement

02:01:38,639 --> 02:01:43,040
and range of statement is the outgoing

02:01:40,159 --> 02:01:43,040
values basically

02:01:43,199 --> 02:01:47,360
so those are your three situations

02:01:48,239 --> 02:01:55,679
so the ranger is uh what's my next slide

02:01:52,639 --> 02:01:57,199
okay so and the ranger i mean

02:01:55,679 --> 02:01:58,560
it's been operating on the branch for a

02:01:57,199 --> 02:01:59,199
long time we've done a lot of tweaks and

02:01:58,560 --> 02:02:01,920
stuff

02:01:59,199 --> 02:02:03,040
and we're i had i said i hope that we

02:02:01,920 --> 02:02:04,719
were going to have it in the trunk by

02:02:03,040 --> 02:02:05,840
the time this conference started but it

02:02:04,719 --> 02:02:07,040
looks like we're probably going to be a

02:02:05,840 --> 02:02:08,960
week or two

02:02:07,040 --> 02:02:10,080
we're working on some performance issues

02:02:08,960 --> 02:02:12,639
right now that

02:02:10,080 --> 02:02:13,599
have cropped up since last year but for

02:02:12,639 --> 02:02:15,119
the most part

02:02:13,599 --> 02:02:18,080
i'm expecting we'll be ready to submit

02:02:15,119 --> 02:02:22,480
it in the next couple of weeks

02:02:18,080 --> 02:02:23,840
so significant changes since last year

02:02:22,480 --> 02:02:26,320
we've done a lot we did a lot of work

02:02:23,840 --> 02:02:30,080
during the off season

02:02:26,320 --> 02:02:32,159
our multiple sub-range code

02:02:30,080 --> 02:02:34,000
used to be completely separate from the

02:02:32,159 --> 02:02:36,480
existing code we

02:02:34,000 --> 02:02:38,000
and we've managed to integrate those

02:02:36,480 --> 02:02:40,239
together so that they're now

02:02:38,000 --> 02:02:41,040
one thing i'll go over that in a minute

02:02:40,239 --> 02:02:43,119
um

02:02:41,040 --> 02:02:45,520
since it's actually of more relevant

02:02:43,119 --> 02:02:49,520
detail importance i mean

02:02:45,520 --> 02:02:50,080
um we've had an a number of refinements

02:02:49,520 --> 02:02:52,000
to

02:02:50,080 --> 02:02:53,199
the range ops code itself the code base

02:02:52,000 --> 02:02:56,560
in order to

02:02:53,199 --> 02:02:58,480
integrate well with vrp and stuff we've

02:02:56,560 --> 02:03:00,320
done a lot of work to make sure that we

02:02:58,480 --> 02:03:01,760
do we produce the exact same results

02:03:00,320 --> 02:03:03,840
that the code used to

02:03:01,760 --> 02:03:04,960
um it's all been shuffled off into the

02:03:03,840 --> 02:03:07,440
raindrops

02:03:04,960 --> 02:03:09,840
infrastructure now so we've made a lot

02:03:07,440 --> 02:03:12,880
of refinements to that and as we

02:03:09,840 --> 02:03:16,159
as we find various issues mo the

02:03:12,880 --> 02:03:18,239
the goal is especially going forward is

02:03:16,159 --> 02:03:19,840
when we have a missed optimization or

02:03:18,239 --> 02:03:21,840
something um

02:03:19,840 --> 02:03:24,480
we should only have to teach raindrops

02:03:21,840 --> 02:03:26,719
what what's missing like if

02:03:24,480 --> 02:03:27,760
um we can teach the right shift

02:03:26,719 --> 02:03:30,800
optimization

02:03:27,760 --> 02:03:31,760
or the code for folding right shift for

02:03:30,800 --> 02:03:34,800
certain

02:03:31,760 --> 02:03:37,119
cases um anyway i'm getting

02:03:34,800 --> 02:03:38,719
i'm i'm i'm going down at the path i

02:03:37,119 --> 02:03:40,639
don't really want to go down so

02:03:38,719 --> 02:03:42,560
basically the idea is we're going to be

02:03:40,639 --> 02:03:45,360
able to fix an awful lot of

02:03:42,560 --> 02:03:46,639
prs by just tweaking the raindrops code

02:03:45,360 --> 02:03:49,040
and we've been doing a lot of that

02:03:46,639 --> 02:03:50,400
and we've got a lot more of that to do

02:03:49,040 --> 02:03:52,159
there's been a lot of internal

02:03:50,400 --> 02:03:54,960
restructuring to the ranger code

02:03:52,159 --> 02:03:57,840
um it's now a lot flatter a lot cleaner

02:03:54,960 --> 02:03:59,520
than it used to be

02:03:57,840 --> 02:04:02,880
that's not really relevant most people

02:03:59,520 --> 02:04:02,880
but we've done a lot of work on that

02:04:02,960 --> 02:04:07,440
we're we're producing we used to have

02:04:05,760 --> 02:04:09,360
our own past so

02:04:07,440 --> 02:04:10,719
short-term goal is we want to replace

02:04:09,360 --> 02:04:12,000
the early vrp pass

02:04:10,719 --> 02:04:13,440
and then the long term goal is we're

02:04:12,000 --> 02:04:15,920
going to replace all of the vrp pass

02:04:13,440 --> 02:04:18,239
with the ranger

02:04:15,920 --> 02:04:20,159
as of last year we had our own pass for

02:04:18,239 --> 02:04:23,199
doing range

02:04:20,159 --> 02:04:24,639
for doing a vrp pass we've since

02:04:23,199 --> 02:04:26,320
integrated with the substitute and fold

02:04:24,639 --> 02:04:29,679
engines and everything so we're using

02:04:26,320 --> 02:04:30,880
exact same mechanism as evrp is at the

02:04:29,679 --> 02:04:32,719
moment this is mostly for a

02:04:30,880 --> 02:04:36,239
compatibility thing during this

02:04:32,719 --> 02:04:37,520
transition stage but so we've done a lot

02:04:36,239 --> 02:04:39,599
of consolidating between

02:04:37,520 --> 02:04:42,560
the ranger and both of the vrps so we've

02:04:39,599 --> 02:04:44,320
got as much common code as possible

02:04:42,560 --> 02:04:47,280
and the other significant change is we

02:04:44,320 --> 02:04:49,599
now have a or i have a prototype for

02:04:47,280 --> 02:04:51,520
handling relational queries that's

02:04:49,599 --> 02:04:54,639
another thing that vrp currently does

02:04:51,520 --> 02:04:56,239
that isn't really range

02:04:54,639 --> 02:04:58,400
specific like you can have a set of

02:04:56,239 --> 02:04:59,280
ranges but if you say you know if a is

02:04:58,400 --> 02:05:02,400
equal to y

02:04:59,280 --> 02:05:04,320
and then later on you say if a equals

02:05:02,400 --> 02:05:06,719
not equal to y in order to fold that

02:05:04,320 --> 02:05:09,520
condition you can't use ranges for that

02:05:06,719 --> 02:05:12,000
but it's a relational thing

02:05:09,520 --> 02:05:12,960
so we've got a i've got a prototype done

02:05:12,000 --> 02:05:14,880
for uh

02:05:12,960 --> 02:05:16,560
tracking relationals at the same time so

02:05:14,880 --> 02:05:18,000
that we can do

02:05:16,560 --> 02:05:19,599
solve a lot of it that was one of the

02:05:18,000 --> 02:05:21,360
big missing pieces

02:05:19,599 --> 02:05:22,960
it's not quite ready for prime time it's

02:05:21,360 --> 02:05:24,320
been prototyped and

02:05:22,960 --> 02:05:28,239
over the next couple months i'm hoping

02:05:24,320 --> 02:05:28,239
to have that actually in and done too

02:05:28,560 --> 02:05:31,679
um let's see so the change the main

02:05:30,719 --> 02:05:34,960
change to iran

02:05:31,679 --> 02:05:37,360
is we we used to represent it as a

02:05:34,960 --> 02:05:38,560
as a list of pairs of wide ants we've

02:05:37,360 --> 02:05:41,199
switched move

02:05:38,560 --> 02:05:42,800
we've since switched to using trees

02:05:41,199 --> 02:05:44,880
internally instead

02:05:42,800 --> 02:05:46,159
and that has allowed us to actually

02:05:44,880 --> 02:05:49,119
merge with value

02:05:46,159 --> 02:05:50,960
with value range um our api hasn't

02:05:49,119 --> 02:05:53,599
really changed we still

02:05:50,960 --> 02:05:55,040
we still query and get widens back

02:05:53,599 --> 02:05:56,480
because we don't want to deal with only

02:05:55,040 --> 02:05:58,719
integers

02:05:56,480 --> 02:06:00,000
um but it's give but what we know is a

02:05:58,719 --> 02:06:03,599
compatibility layer

02:06:00,000 --> 02:06:05,760
in that if you ask for a

02:06:03,599 --> 02:06:06,639
an i range that only has a single pair

02:06:05,760 --> 02:06:08,800
it goes into

02:06:06,639 --> 02:06:11,040
legacy mode which allows it to work

02:06:08,800 --> 02:06:13,280
exactly the same way as value range

02:06:11,040 --> 02:06:14,800
um so now the two coexist you can copy a

02:06:13,280 --> 02:06:16,400
multi-range into a value range and a

02:06:14,800 --> 02:06:18,320
value range back to a multi-range

02:06:16,400 --> 02:06:20,800
you lose precision but it all works

02:06:18,320 --> 02:06:24,079
everything everything kind of

02:06:20,800 --> 02:06:25,520
works together so now um we really we

02:06:24,079 --> 02:06:28,239
really have much more

02:06:25,520 --> 02:06:30,719
common code now that we can do that um

02:06:28,239 --> 02:06:33,599
aldi has created a reporting

02:06:30,719 --> 02:06:35,040
document as he went through and sort of

02:06:33,599 --> 02:06:37,679
ported everything

02:06:35,040 --> 02:06:38,480
um i don't think he's published it yet

02:06:37,679 --> 02:06:40,079
but it should be

02:06:38,480 --> 02:06:42,000
in the next week or two certainly by the

02:06:40,079 --> 02:06:45,840
time ranger comes out we'll have the

02:06:42,000 --> 02:06:45,840
reporting guidelines document available

02:06:46,400 --> 02:06:52,239
um so i'll give a quick rundown on

02:06:49,440 --> 02:06:54,239
relations and how they're going to work

02:06:52,239 --> 02:06:57,440
there's a class that tracks

02:06:54,239 --> 02:07:00,400
individual relations so when you see

02:06:57,440 --> 02:07:01,760
um any any uh the the the six different

02:07:00,400 --> 02:07:03,360
kinds of relations

02:07:01,760 --> 02:07:05,679
or actually seven when you include no

02:07:03,360 --> 02:07:09,599
relation so that when we um

02:07:05,679 --> 02:07:12,079
anytime as we we can represent them

02:07:09,599 --> 02:07:14,400
as an abstract thing and then we can

02:07:12,079 --> 02:07:16,960
start combining them so if you've got

02:07:14,400 --> 02:07:18,000
you know x2 is less than b6 and one

02:07:16,960 --> 02:07:20,079
branch and

02:07:18,000 --> 02:07:21,679
a2 is equal to six here and you combine

02:07:20,079 --> 02:07:25,440
those two things together

02:07:21,679 --> 02:07:26,000
um you can you can determine the results

02:07:25,440 --> 02:07:28,800
um

02:07:26,000 --> 02:07:30,079
it helped that it's by combining these

02:07:28,800 --> 02:07:32,239
in a general way

02:07:30,079 --> 02:07:34,400
that we'll be able to answer questions

02:07:32,239 --> 02:07:35,440
um that will allow us to fold conditions

02:07:34,400 --> 02:07:37,760
that allow us to

02:07:35,440 --> 02:07:39,199
uh map equivalencies so that if we ask

02:07:37,760 --> 02:07:40,639
for the range of one thing is

02:07:39,199 --> 02:07:42,480
something else we can give you the range

02:07:40,639 --> 02:07:46,000
of both combined

02:07:42,480 --> 02:07:49,040
um and so it's it's basically a

02:07:46,000 --> 02:07:51,520
um a simple object that we

02:07:49,040 --> 02:07:54,719
can then use and combine in whatever

02:07:51,520 --> 02:07:56,800
ways we see fit um

02:07:54,719 --> 02:07:58,480
there's the next slide and the

02:07:56,800 --> 02:07:59,920
relational stuff follows the same model

02:07:58,480 --> 02:08:01,199
we use for raindrops

02:07:59,920 --> 02:08:04,079
it's not currently integrated with

02:08:01,199 --> 02:08:06,079
raindrops because as as it's evolving

02:08:04,079 --> 02:08:07,599
i was trying not to mess up the

02:08:06,079 --> 02:08:09,520
raindrops interface until we

02:08:07,599 --> 02:08:11,440
actually have whatever the final version

02:08:09,520 --> 02:08:13,119
is going to be but basically it allows

02:08:11,440 --> 02:08:14,320
you to query for the relation between

02:08:13,119 --> 02:08:16,239
the left-hand side

02:08:14,320 --> 02:08:19,040
and any operand or between the two

02:08:16,239 --> 02:08:20,400
operands and so this this allows us to

02:08:19,040 --> 02:08:22,560
generically treat

02:08:20,400 --> 02:08:23,520
all of the different tree codes um the

02:08:22,560 --> 02:08:26,560
same

02:08:23,520 --> 02:08:28,239
and the same idea will apply once once

02:08:26,560 --> 02:08:30,880
the infrastructure is all in working

02:08:28,239 --> 02:08:32,639
if we're missing a case somewhere we'll

02:08:30,880 --> 02:08:36,079
probably able to get it by

02:08:32,639 --> 02:08:39,119
um teaching the op code the the

02:08:36,079 --> 02:08:42,800
the range ops but what the relation is

02:08:39,119 --> 02:08:44,239
um so for example if x1 is less than b2

02:08:42,800 --> 02:08:48,079
that's a pretty simple thing to

02:08:44,239 --> 02:08:49,840
track the relation for but um

02:08:48,079 --> 02:08:51,920
in the example here for for an

02:08:49,840 --> 02:08:53,760
assignment there are relations between

02:08:51,920 --> 02:08:55,040
the left-hand side and the operand and

02:08:53,760 --> 02:08:58,639
it depends on the type

02:08:55,040 --> 02:09:02,480
and if you happen to have ranges for it

02:08:58,639 --> 02:09:03,360
you can then um get much more specific

02:09:02,480 --> 02:09:05,280
information

02:09:03,360 --> 02:09:07,040
so for instance in that addition if it's

02:09:05,280 --> 02:09:09,840
if it's an unsigned

02:09:07,040 --> 02:09:11,199
integer there is no relation between x2

02:09:09,840 --> 02:09:12,400
and b3 because you don't know it's going

02:09:11,199 --> 02:09:14,400
to be less than or greater than but if

02:09:12,400 --> 02:09:17,599
you happen to know the range of x2

02:09:14,400 --> 02:09:19,760
or x3 or sorry x2 or b3

02:09:17,599 --> 02:09:21,440
then you can actually determine you know

02:09:19,760 --> 02:09:22,719
that there is a relation between the two

02:09:21,440 --> 02:09:25,440
and then that can help you fold stuff

02:09:22,719 --> 02:09:25,440
away later on

02:09:27,440 --> 02:09:30,800
i'm going over this very quickly it's

02:09:28,639 --> 02:09:32,159
not much time but

02:09:30,800 --> 02:09:33,040
it'll be much more interesting when it

02:09:32,159 --> 02:09:34,239
actually comes out because then i'll

02:09:33,040 --> 02:09:35,760
publish the whole document on how it

02:09:34,239 --> 02:09:37,760
works and all that kind of stuff

02:09:35,760 --> 02:09:38,800
um and this is just an example of how

02:09:37,760 --> 02:09:42,800
you can

02:09:38,800 --> 02:09:44,239
if you happen to know so when we see x2

02:09:42,800 --> 02:09:46,159
less than or equal to five the range of

02:09:44,239 --> 02:09:48,480
configured arrange for x2 when you

02:09:46,159 --> 02:09:50,320
when you go take back step you can

02:09:48,480 --> 02:09:51,679
calculate a range for b3 using range

02:09:50,320 --> 02:09:52,400
outs but you can also calculate a

02:09:51,679 --> 02:09:54,639
relation

02:09:52,400 --> 02:09:56,719
and if you then wanted to apply that

02:09:54,639 --> 02:09:58,239
relation later on we would know that x2

02:09:56,719 --> 02:10:00,480
is less than b3 or

02:09:58,239 --> 02:10:01,280
or whatever the cases are in those those

02:10:00,480 --> 02:10:07,119
three

02:10:01,280 --> 02:10:07,119
places um what am i doing here

02:10:09,280 --> 02:10:13,040
and the queries in the relational engine

02:10:11,760 --> 02:10:15,360
um it basically ops

02:10:13,040 --> 02:10:16,560
operates as an oracle uh we track

02:10:15,360 --> 02:10:18,400
equivalency c

02:10:16,560 --> 02:10:19,599
separately from all the other relations

02:10:18,400 --> 02:10:22,400
because

02:10:19,599 --> 02:10:22,800
you you satisfy the equivalencies first

02:10:22,400 --> 02:10:24,480
which

02:10:22,800 --> 02:10:26,079
may give you a set of things and then

02:10:24,480 --> 02:10:28,639
you apply the relations from all of

02:10:26,079 --> 02:10:28,639
those things

02:10:30,000 --> 02:10:34,480
as at the way it currently works we

02:10:33,040 --> 02:10:37,280
require the dominators

02:10:34,480 --> 02:10:40,480
so since we're integrated with the evrp

02:10:37,280 --> 02:10:42,400
and the dominator walk stuff

02:10:40,480 --> 02:10:44,079
i'm just piggybacking on that right now

02:10:42,400 --> 02:10:47,280
um so as you walk through

02:10:44,079 --> 02:10:50,320
the block statements are registered um

02:10:47,280 --> 02:10:51,920
and we register the relations and and

02:10:50,320 --> 02:10:52,719
track those and then we can query them

02:10:51,920 --> 02:10:54,480
later

02:10:52,719 --> 02:10:56,079
uh the long-term plan is to integrate

02:10:54,480 --> 02:10:58,639
this much more tightly with the

02:10:56,079 --> 02:11:00,239
on-demand model of the ranger so we will

02:10:58,639 --> 02:11:01,920
still register statements as we see them

02:11:00,239 --> 02:11:03,119
but only as the ranger sees them as it

02:11:01,920 --> 02:11:06,239
walks back and does

02:11:03,119 --> 02:11:06,239
just what it needs to do

02:11:06,400 --> 02:11:11,280
that's the long-term plan for that the

02:11:09,040 --> 02:11:12,159
api for it's still pretty simple you can

02:11:11,280 --> 02:11:14,560
ask for a

02:11:12,159 --> 02:11:16,239
you can ask really all you can do right

02:11:14,560 --> 02:11:19,119
all it can do right now is uh

02:11:16,239 --> 02:11:20,719
you can ask for the equivalency set for

02:11:19,119 --> 02:11:22,159
something or you can actually try

02:11:20,719 --> 02:11:23,679
applying relations to a statement that's

02:11:22,159 --> 02:11:27,760
how it currently goes and

02:11:23,679 --> 02:11:29,119
and folds i expect to actually open up a

02:11:27,760 --> 02:11:30,800
bit more of that so because there are

02:11:29,119 --> 02:11:31,920
other more useful things i suspect that

02:11:30,800 --> 02:11:34,079
this will actually be

02:11:31,920 --> 02:11:36,000
of use in places other than the ranger

02:11:34,079 --> 02:11:39,840
um which is why i'm trying to keep it

02:11:36,000 --> 02:11:41,440
sort of separate uh i think the oracle

02:11:39,840 --> 02:11:44,880
would have much more use would have

02:11:41,440 --> 02:11:44,880
other uses in other places as well

02:11:46,560 --> 02:11:50,960
so that's all of the the new stuff we

02:11:48,560 --> 02:11:52,960
got um

02:11:50,960 --> 02:11:54,079
currently in stage one uh as i had

02:11:52,960 --> 02:11:56,320
mentioned earlier raindrops was

02:11:54,079 --> 02:11:59,119
integrated in the last release of gcc

02:11:56,320 --> 02:12:00,239
the multi-range support for iran um i

02:11:59,119 --> 02:12:01,520
think you already checked that in in

02:12:00,239 --> 02:12:02,719
july

02:12:01,520 --> 02:12:04,400
it's in there running we did a lot of

02:12:02,719 --> 02:12:06,239
performance work on it and we've

02:12:04,400 --> 02:12:08,320
actually got to the point where

02:12:06,239 --> 02:12:09,440
in a lot of cases the multi-range code

02:12:08,320 --> 02:12:11,520
runs

02:12:09,440 --> 02:12:13,840
um it's actually a little bit faster

02:12:11,520 --> 02:12:15,760
than the legacy code in some cases

02:12:13,840 --> 02:12:17,040
but in general it was pretty much a wash

02:12:15,760 --> 02:12:18,960
all the way through

02:12:17,040 --> 02:12:20,400
so we've got multi-range support and the

02:12:18,960 --> 02:12:21,599
legacy stuff

02:12:20,400 --> 02:12:24,079
if we ever get to the point where we

02:12:21,599 --> 02:12:25,280
manage to get rid of all of the legacy

02:12:24,079 --> 02:12:27,280
code and value range that

02:12:25,280 --> 02:12:28,400
doesn't need it anymore then we can drop

02:12:27,280 --> 02:12:30,400
all the legacy support

02:12:28,400 --> 02:12:31,760
pretty straight forward and everything

02:12:30,400 --> 02:12:32,320
will speed up a little bit because of a

02:12:31,760 --> 02:12:35,040
lot less

02:12:32,320 --> 02:12:37,119
checks for stuff as i mentioned we're

02:12:35,040 --> 02:12:40,800
going through the final performance

02:12:37,119 --> 02:12:42,719
runs of the ranger the conversion to

02:12:40,800 --> 02:12:43,599
trees cost us a little bit the move over

02:12:42,719 --> 02:12:47,199
to the

02:12:43,599 --> 02:12:50,239
folder and substitute engine

02:12:47,199 --> 02:12:51,920
that's cost us some bit too because it

02:12:50,239 --> 02:12:53,760
doesn't understand the concept of asking

02:12:51,920 --> 02:12:54,560
for ranges on edges or anything so we

02:12:53,760 --> 02:12:56,000
have to

02:12:54,560 --> 02:12:57,199
we have some adjustments to make but i

02:12:56,000 --> 02:12:58,239
think we've got it under control at the

02:12:57,199 --> 02:13:00,400
moment i'm hoping

02:12:58,239 --> 02:13:02,719
that in the next couple of weeks we'll

02:13:00,400 --> 02:13:04,960
be able to submit it to trunk

02:13:02,719 --> 02:13:05,840
along with the passes we had talked

02:13:04,960 --> 02:13:08,960
about last year

02:13:05,840 --> 02:13:11,840
that are sped up by using it and i've

02:13:08,960 --> 02:13:15,440
also implemented a new version of er brp

02:13:11,840 --> 02:13:17,119
where um it can run in multiple modes

02:13:15,440 --> 02:13:19,199
but the general idea is

02:13:17,119 --> 02:13:21,119
it runs exactly the way it does today

02:13:19,199 --> 02:13:22,400
and it runs evrp and ranger both so

02:13:21,119 --> 02:13:25,440
it'll query one

02:13:22,400 --> 02:13:27,840
and if it can fold it it will fold it if

02:13:25,440 --> 02:13:29,920
um if it fails to fold with evrp then

02:13:27,840 --> 02:13:32,400
it'll call the ranger and say can you

02:13:29,920 --> 02:13:34,800
fold this or do something with it with

02:13:32,400 --> 02:13:35,679
and we can run it in different ways we

02:13:34,800 --> 02:13:37,840
run our

02:13:35,679 --> 02:13:40,320
ranger first and even your parallel even

02:13:37,840 --> 02:13:43,360
second which will then show us which

02:13:40,320 --> 02:13:47,119
things evp evrp is getting that we don't

02:13:43,360 --> 02:13:47,599
if we do it the other way you run evrp

02:13:47,119 --> 02:13:49,840
first

02:13:47,599 --> 02:13:51,280
and then ranger then it shows you the

02:13:49,840 --> 02:13:52,079
things the ranger gets that evrp

02:13:51,280 --> 02:13:53,599
wouldn't

02:13:52,079 --> 02:13:54,800
and then they can also run in solo modes

02:13:53,599 --> 02:13:57,840
and there's a tracing mode which shows

02:13:54,800 --> 02:13:58,960
you lots of interesting stuff

02:13:57,840 --> 02:14:00,480
so that would all be part of the

02:13:58,960 --> 02:14:01,760
submission when we come forward in a

02:14:00,480 --> 02:14:03,760
couple of weeks

02:14:01,760 --> 02:14:05,040
and then the relational oracle i hope to

02:14:03,760 --> 02:14:06,719
have that kind of up and running by

02:14:05,040 --> 02:14:07,440
early october so hopefully we can get

02:14:06,719 --> 02:14:09,679
that in too

02:14:07,440 --> 02:14:12,960
and all the performance and that of

02:14:09,679 --> 02:14:14,800
course will be great i hope

02:14:12,960 --> 02:14:18,000
all right um so that's what we're

02:14:14,800 --> 02:14:18,000
planning to do for the stage one

02:14:18,480 --> 02:14:24,880
then there we go

02:14:22,400 --> 02:14:26,480
once once we're in and operating um the

02:14:24,880 --> 02:14:28,239
plan is

02:14:26,480 --> 02:14:29,840
we will start identifying we'll run it

02:14:28,239 --> 02:14:32,159
in the mode where the ranger goes first

02:14:29,840 --> 02:14:34,320
and evrp goes second and it flay it will

02:14:32,159 --> 02:14:35,280
flag everything that evrp gets that we

02:14:34,320 --> 02:14:38,079
don't and we will work

02:14:35,280 --> 02:14:40,159
on determining why it's getting

02:14:38,079 --> 02:14:43,040
something we're not and fixing that

02:14:40,159 --> 02:14:44,320
once it reaches the point where evrp

02:14:43,040 --> 02:14:46,079
isn't getting anything

02:14:44,320 --> 02:14:47,360
or is only getting things that are got

02:14:46,079 --> 02:14:48,719
by other passes

02:14:47,360 --> 02:14:51,040
later on because of something that was

02:14:48,719 --> 02:14:54,400
exposed then we can

02:14:51,040 --> 02:14:56,320
replace evrp with just the ranger

02:14:54,400 --> 02:14:57,440
um and then the goal the next goal after

02:14:56,320 --> 02:15:00,560
that will be then

02:14:57,440 --> 02:15:03,040
to look at the iterative vrp pass

02:15:00,560 --> 02:15:04,960
and see what it's getting that we're not

02:15:03,040 --> 02:15:08,000
because the ranger includes

02:15:04,960 --> 02:15:11,280
um iterative updating which is the main

02:15:08,000 --> 02:15:14,400
thing that the the vrp pass

02:15:11,280 --> 02:15:16,880
provides and

02:15:14,400 --> 02:15:18,560
in theory there isn't i can't think of

02:15:16,880 --> 02:15:19,679
anything that vrp gets that we shouldn't

02:15:18,560 --> 02:15:20,800
but i'm sure there's a little bit of

02:15:19,679 --> 02:15:22,560
footwork to do

02:15:20,800 --> 02:15:24,079
and then we'll just have a single vrp

02:15:22,560 --> 02:15:27,440
for everywhere

02:15:24,079 --> 02:15:28,400
that should be significantly faster too

02:15:27,440 --> 02:15:32,079
i hope

02:15:28,400 --> 02:15:34,320
um vrp tends to be

02:15:32,079 --> 02:15:35,599
a bunch of a bunch of optimizations that

02:15:34,320 --> 02:15:37,599
are lumped together

02:15:35,599 --> 02:15:38,960
to make use of range information if we

02:15:37,599 --> 02:15:40,560
can make range information cheap enough

02:15:38,960 --> 02:15:42,000
we can push these things back out to the

02:15:40,560 --> 02:15:44,639
passes where they belong instead of

02:15:42,000 --> 02:15:47,040
trying to lump them into vrp

02:15:44,639 --> 02:15:48,960
the range ops code still has some

02:15:47,040 --> 02:15:50,000
enhancements for multi-range because we

02:15:48,960 --> 02:15:52,079
just base

02:15:50,000 --> 02:15:54,079
some of some things like multiply and

02:15:52,079 --> 02:15:58,560
add they're all very multi-range

02:15:54,079 --> 02:15:58,560
um enabled now but a lot of the other

02:15:58,639 --> 02:16:01,840
things like shift the shifts and a lot

02:16:01,040 --> 02:16:03,840
of the other things

02:16:01,840 --> 02:16:04,960
we basically just absorb the old code

02:16:03,840 --> 02:16:08,960
which is

02:16:04,960 --> 02:16:12,400
um single range

02:16:08,960 --> 02:16:14,239
based and there's we've identified at

02:16:12,400 --> 02:16:17,360
least a half a dozen

02:16:14,239 --> 02:16:19,199
prs we can fix by simply teaching

02:16:17,360 --> 02:16:20,159
raindrops how to be multi-range to

02:16:19,199 --> 02:16:21,360
handle

02:16:20,159 --> 02:16:22,719
the cases that are in there because

02:16:21,360 --> 02:16:23,599
typically it's a small sub-range of

02:16:22,719 --> 02:16:25,119
stuff that

02:16:23,599 --> 02:16:26,880
currently those operations just don't

02:16:25,119 --> 02:16:30,400
work on multi-range

02:16:26,880 --> 02:16:32,080
um block outgoing range refinements

02:16:30,400 --> 02:16:33,760
oh so there's a there's a speed up for

02:16:32,080 --> 02:16:35,439
the ranger uh

02:16:33,760 --> 02:16:36,960
currently when you're when you when it

02:16:35,439 --> 02:16:37,920
does this little backward queries to

02:16:36,960 --> 02:16:40,000
answer questions

02:16:37,920 --> 02:16:41,760
it does a lot more work than it has to

02:16:40,000 --> 02:16:43,599
um i have some

02:16:41,760 --> 02:16:45,280
optimizations for that that will be

02:16:43,599 --> 02:16:46,240
combined with the release so we can i'll

02:16:45,280 --> 02:16:49,519
be able to do the

02:16:46,240 --> 02:16:51,280
relational and and and range related

02:16:49,519 --> 02:16:51,760
stuff sort of simultaneously and cache

02:16:51,280 --> 02:16:53,679
it and

02:16:51,760 --> 02:16:55,359
it'll just speed things up even more

02:16:53,679 --> 02:16:57,760
than they already are

02:16:55,359 --> 02:16:58,399
which is part of the tighter integration

02:16:57,760 --> 02:17:00,479
um

02:16:58,399 --> 02:17:02,080
long-term plans also involve allowing

02:17:00,479 --> 02:17:04,240
more than just integral

02:17:02,080 --> 02:17:06,479
ranges um i've had some queries about

02:17:04,240 --> 02:17:09,519
floating point ranges which we can

02:17:06,479 --> 02:17:11,840
we can take care of as well eventually

02:17:09,519 --> 02:17:12,880
that includes tracking you know not in

02:17:11,840 --> 02:17:15,679
numbers and

02:17:12,880 --> 02:17:18,000
a lot of different conditions we've had

02:17:15,679 --> 02:17:19,439
some input on what that would look like

02:17:18,000 --> 02:17:22,960
it requires some adjustments to the

02:17:19,439 --> 02:17:24,399
range base we need to may have a

02:17:22,960 --> 02:17:26,479
we need to we need to do a few

02:17:24,399 --> 02:17:27,280
adjustments but the ranger itself is not

02:17:26,479 --> 02:17:30,160
integral

02:17:27,280 --> 02:17:32,319
based it's just we just need to do some

02:17:30,160 --> 02:17:34,000
uh tweaking to allow for a class other

02:17:32,319 --> 02:17:36,240
than high range

02:17:34,000 --> 02:17:37,679
and we don't do any bit mass tracking

02:17:36,240 --> 02:17:38,800
that would fit in with raindrops and

02:17:37,679 --> 02:17:40,000
there's some pretty

02:17:38,800 --> 02:17:43,359
pretty interesting things we could do

02:17:40,000 --> 02:17:43,359
with that too i think um

02:17:44,800 --> 02:17:48,960
and uh that's that's the end of my

02:17:46,559 --> 02:17:48,960
slides

02:17:49,120 --> 02:17:56,240
so i'm open to whatever questions or

02:17:51,040 --> 02:17:59,200
comments you have

02:17:56,240 --> 02:18:00,880
deandra this is jeff um just one note

02:17:59,200 --> 02:18:02,479
you mentioned that uh you have an

02:18:00,880 --> 02:18:06,080
innovative step

02:18:02,479 --> 02:18:07,120
in ranger that is different than the vrp

02:18:06,080 --> 02:18:10,000
iteration

02:18:07,120 --> 02:18:10,880
that we're trying to get rid of yes

02:18:10,000 --> 02:18:12,960
right

02:18:10,880 --> 02:18:13,920
yes so what the iterative part of the

02:18:12,960 --> 02:18:15,840
ranger is

02:18:13,920 --> 02:18:17,760
is when you ask for when you ask for the

02:18:15,840 --> 02:18:19,519
range of an ssa name

02:18:17,760 --> 02:18:22,000
um it doesn't walk back to the cfg

02:18:19,519 --> 02:18:25,359
looking for the definition

02:18:22,000 --> 02:18:26,240
and it it doesn't need dominators or

02:18:25,359 --> 02:18:28,240
anything it just does

02:18:26,240 --> 02:18:29,920
it just it does a walk and sometimes

02:18:28,240 --> 02:18:31,120
when it finds a back edge it'll keep

02:18:29,920 --> 02:18:32,800
looking through the back edge till it

02:18:31,120 --> 02:18:35,439
gets back to where it started

02:18:32,800 --> 02:18:37,519
um so it doesn't go anything it's it's

02:18:35,439 --> 02:18:41,280
it's purely linear like there's no

02:18:37,519 --> 02:18:42,880
it doesn't yes you don't it'll it will

02:18:41,280 --> 02:18:45,760
never visit a block more than once

02:18:42,880 --> 02:18:47,200
and it will solve some of those a lot of

02:18:45,760 --> 02:18:49,040
those back edge problems

02:18:47,200 --> 02:18:50,559
um but it doesn't try to fully solve it

02:18:49,040 --> 02:18:52,559
it ends up in a situation that would be

02:18:50,559 --> 02:18:54,160
a cycle it stops

02:18:52,559 --> 02:18:56,080
and then that would be an enhancement

02:18:54,160 --> 02:18:58,080
later on to actually

02:18:56,080 --> 02:19:00,000
say hey we've got a new the the

02:18:58,080 --> 02:19:01,280
infrastructure is there to say hey i've

02:19:00,000 --> 02:19:03,840
got a new value from something you

02:19:01,280 --> 02:19:06,559
calculated earlier go find me a new one

02:19:03,840 --> 02:19:07,040
but yes it is not even it's not there's

02:19:06,559 --> 02:19:10,639
there's

02:19:07,040 --> 02:19:12,080
it's a very short cycle um

02:19:10,639 --> 02:19:14,319
and yes it's so it's not the same as the

02:19:12,080 --> 02:19:15,519
uterus just it allows us to find values

02:19:14,319 --> 02:19:17,920
on back edges

02:19:15,519 --> 02:19:21,040
with uh with a minimal amount of effort

02:19:17,920 --> 02:19:21,040
in fact it can find a lot

02:19:24,800 --> 02:19:28,080
yeah it's not like that it's it's part

02:19:26,639 --> 02:19:31,359
of the cash filling

02:19:28,080 --> 02:19:33,920
uh for the so the ranger has an on entry

02:19:31,359 --> 02:19:34,479
cash for each basic block and it will

02:19:33,920 --> 02:19:36,319
only do

02:19:34,479 --> 02:19:38,559
it only deals with one ssa name at a

02:19:36,319 --> 02:19:41,599
time so it only has to

02:19:38,559 --> 02:19:44,080
yeah it's it's it's not a very

02:19:41,599 --> 02:19:45,760
heavyweight thing but it allows us to

02:19:44,080 --> 02:19:47,439
like it can find half this

02:19:45,760 --> 02:19:49,280
anything with constant bounds in a loop

02:19:47,439 --> 02:19:51,520
it can find loop bounce

02:19:49,280 --> 02:19:52,960
like with a just a quick check of the

02:19:51,520 --> 02:19:55,680
the exit condition if it's

02:19:52,960 --> 02:19:55,680
properly written

02:19:57,600 --> 02:20:03,840
which is why i think we'll be able to rp

02:20:09,200 --> 02:20:14,160
and so this should be available for

02:20:11,439 --> 02:20:16,000
anybody that uses ranges in the compiler

02:20:14,160 --> 02:20:17,680
that's just something we should be able

02:20:16,000 --> 02:20:20,960
to easily query

02:20:17,680 --> 02:20:22,399
in starting in a couple weeks the more

02:20:20,960 --> 02:20:30,560
people query it

02:20:22,399 --> 02:20:33,280
the better we'll get

02:20:30,560 --> 02:20:34,720
are there any parameters or something

02:20:33,280 --> 02:20:37,920
similar to limit how

02:20:34,720 --> 02:20:41,200
how far does it look uh

02:20:37,920 --> 02:20:44,560
in perhaps for for uses in other passes

02:20:41,200 --> 02:20:46,479
not not in the evrp so

02:20:44,560 --> 02:20:48,000
no it doesn't it doesn't really have

02:20:46,479 --> 02:20:50,399
limits but the limits are sort of

02:20:48,000 --> 02:20:51,680
self-imposed so if you ask for the range

02:20:50,399 --> 02:20:54,080
of something

02:20:51,680 --> 02:20:55,280
um it will compute everything it needs

02:20:54,080 --> 02:20:58,160
to get to that

02:20:55,280 --> 02:20:59,600
but so when we did the original the

02:20:58,160 --> 02:21:02,399
original pass

02:20:59,600 --> 02:21:03,439
we set it up so that we could run it do

02:21:02,399 --> 02:21:06,560
the queries

02:21:03,439 --> 02:21:08,000
we do if you do a dominator walk

02:21:06,560 --> 02:21:10,479
and ask for the query at every given

02:21:08,000 --> 02:21:11,920
statement um

02:21:10,479 --> 02:21:12,880
it doesn't have very much work to do

02:21:11,920 --> 02:21:14,160
because you've already visited the

02:21:12,880 --> 02:21:15,520
statement so when you're asking for the

02:21:14,160 --> 02:21:18,240
range or something it knows it

02:21:15,520 --> 02:21:19,439
we tried doing that in reverse uh we

02:21:18,240 --> 02:21:22,240
tried doing it for

02:21:19,439 --> 02:21:23,520
from basic block two to to the end and

02:21:22,240 --> 02:21:25,520
then we did it from the end

02:21:23,520 --> 02:21:27,280
back and the times are all very similar

02:21:25,520 --> 02:21:29,200
in all of them uh so it doesn't really

02:21:27,280 --> 02:21:32,080
matter what order you do it in it

02:21:29,200 --> 02:21:33,359
and it only looks the nice part about if

02:21:32,080 --> 02:21:34,399
you're asking for it in the middle of a

02:21:33,359 --> 02:21:36,319
program

02:21:34,399 --> 02:21:38,000
um if it can look back five statements

02:21:36,319 --> 02:21:39,760
and find the answer that's all it does

02:21:38,000 --> 02:21:41,359
it doesn't have to go any further or not

02:21:39,760 --> 02:21:42,080
and it will only go as far as it needs

02:21:41,359 --> 02:21:46,640
to

02:21:42,080 --> 02:21:49,680
um it's it's it seems quite good

02:21:46,640 --> 02:21:52,800
well i was wondering about pathological

02:21:49,680 --> 02:21:56,160
cases like asking somewhere

02:21:52,800 --> 02:21:58,880
at the end of a block with a hundred of

02:21:56,160 --> 02:22:00,160
thousands state of statement which each

02:21:58,880 --> 02:22:02,640
depend on

02:22:00,160 --> 02:22:06,240
on the previous one um it only visits

02:22:02,640 --> 02:22:06,240
each statement once so it doesn't become

02:22:06,840 --> 02:22:10,319
pathological

02:22:08,560 --> 02:22:13,600
like when it walks back it walks back

02:22:10,319 --> 02:22:15,680
and then comes and it's got its answer

02:22:13,600 --> 02:22:18,240
so we haven't found a pathological case

02:22:15,680 --> 02:22:19,520
uh i know llvm originally had a pass it

02:22:18,240 --> 02:22:21,760
did something like this and they had a

02:22:19,520 --> 02:22:23,920
lot of pathological case issues

02:22:21,760 --> 02:22:25,680
i got a couple of them none of them were

02:22:23,920 --> 02:22:27,200
an issue we haven't found anything

02:22:25,680 --> 02:22:31,040
that's pathological yet

02:22:27,200 --> 02:22:33,439
so i'm hoping the design has actually

02:22:31,040 --> 02:22:35,280
eliminated that because it is limited

02:22:33,439 --> 02:22:36,640
the iterative part is very limited in

02:22:35,280 --> 02:22:40,319
what it does

02:22:36,640 --> 02:22:41,760
and the rest of it it only ever visits a

02:22:40,319 --> 02:22:43,280
statement once

02:22:41,760 --> 02:22:51,840
so there's a limit to the

02:22:43,280 --> 02:22:51,840
pathologicalness there can be

02:23:01,600 --> 02:23:04,880
we have a couple more minutes for

02:23:03,280 --> 02:23:07,120
questions if anyone would like to ask

02:23:04,880 --> 02:23:10,479
questions

02:23:07,120 --> 02:23:10,479
or i can do a little tap dance

02:23:16,960 --> 02:23:20,000
the only thing i'll add is from the

02:23:18,479 --> 02:23:21,840
original oops sorry

02:23:20,000 --> 02:23:23,680
no go ahead please i'd say from the

02:23:21,840 --> 02:23:25,680
original presentation we had

02:23:23,680 --> 02:23:28,000
some of our performance numbers uh in

02:23:25,680 --> 02:23:29,359
particular passes that

02:23:28,000 --> 02:23:31,120
so in order to get ranges before you

02:23:29,359 --> 02:23:33,760
head in and you had to do a whole

02:23:31,120 --> 02:23:34,479
dominator walk which hauled in a bunch

02:23:33,760 --> 02:23:37,600
of uh

02:23:34,479 --> 02:23:40,000
a bunch of access um infrastructure

02:23:37,600 --> 02:23:41,520
uh some of those the passes that had to

02:23:40,000 --> 02:23:42,399
do that when we converted them to the

02:23:41,520 --> 02:23:44,399
ranger like

02:23:42,399 --> 02:23:46,080
i think was it was a print f pass or or

02:23:44,399 --> 02:23:49,359
maybe it was a allocate it was one

02:23:46,080 --> 02:23:52,479
they they really only needed

02:23:49,359 --> 02:23:54,160
a couple of ranges and those ranges are

02:23:52,479 --> 02:23:55,439
usually located pretty close

02:23:54,160 --> 02:23:57,359
though in those passes we were getting

02:23:55,439 --> 02:23:59,600
like a 95 speed up in the past

02:23:57,359 --> 02:24:01,840
because we were doing very little work

02:23:59,600 --> 02:24:03,600
now and you weren't doing a lot of

02:24:01,840 --> 02:24:06,080
things you didn't need to do

02:24:03,600 --> 02:24:09,520
so i think there's a lot of potential

02:24:06,080 --> 02:24:09,520
speed ups can happen with this

02:24:11,120 --> 02:24:14,479
yeah that's one of the design principles

02:24:14,000 --> 02:24:17,120
that looks

02:24:14,479 --> 02:24:18,319
really really promising in that we have

02:24:17,120 --> 02:24:21,120
passes that want to make

02:24:18,319 --> 02:24:22,399
queries but they only need a very small

02:24:21,120 --> 02:24:24,399
subset

02:24:22,399 --> 02:24:26,399
of objects they want to make queries on

02:24:24,399 --> 02:24:27,680
the way evrp is structured we

02:24:26,399 --> 02:24:30,399
essentially have to look at

02:24:27,680 --> 02:24:31,840
everything whereas in the ranger vrp

02:24:30,399 --> 02:24:33,760
it's an on-demand

02:24:31,840 --> 02:24:35,840
uh minimal set it's only the set that

02:24:33,760 --> 02:24:39,439
actually feed into the

02:24:35,840 --> 02:24:40,399
uh definition of the ssa name that we

02:24:39,439 --> 02:24:42,160
care about

02:24:40,399 --> 02:24:44,000
and so passes like the printf pass the

02:24:42,160 --> 02:24:46,880
algae pass or the

02:24:44,000 --> 02:24:48,640
uh out of bounds uh array indexing pass

02:24:46,880 --> 02:24:51,439
i think we'll be able to do

02:24:48,640 --> 02:24:52,319
very fast analysis uh on those which

02:24:51,439 --> 02:24:55,280
would be

02:24:52,319 --> 02:24:56,880
awesome i mean as you know andrew the it

02:24:55,280 --> 02:24:58,800
was you know the thing that started all

02:24:56,880 --> 02:25:01,920
this was getting good ranges for the

02:24:58,800 --> 02:25:02,960
rebounds checking yeah and uh using that

02:25:01,920 --> 02:25:05,439
is where it's gonna be really really

02:25:02,960 --> 02:25:06,720
useful yeah yeah i mean i just poking

02:25:05,439 --> 02:25:07,840
around i mean aldi just finished

02:25:06,720 --> 02:25:09,920
converting

02:25:07,840 --> 02:25:11,600
uh we tried to generalize all of the

02:25:09,920 --> 02:25:14,880
substitution and folding

02:25:11,600 --> 02:25:16,640
stuff in the last week or so and uh

02:25:14,880 --> 02:25:18,720
i was noticing like even loop versioning

02:25:16,640 --> 02:25:20,399
i mean it seems to do

02:25:18,720 --> 02:25:22,240
it seems to have to do an entire walk

02:25:20,399 --> 02:25:23,840
and calculate ranges for every statement

02:25:22,240 --> 02:25:24,720
in order to do something it doesn't

02:25:23,840 --> 02:25:27,520
anyway

02:25:24,720 --> 02:25:29,120
there's a there was a whole bunch of um

02:25:27,520 --> 02:25:31,280
places where i think we can speed stuff

02:25:29,120 --> 02:25:31,280
up

02:25:32,240 --> 02:25:36,319
and most of the germany airport may be

02:25:33,760 --> 02:25:38,000
able to go away

02:25:36,319 --> 02:25:39,680
thank you andrew thank you very much for

02:25:38,000 --> 02:25:41,359
all these presentations

02:25:39,680 --> 02:25:42,880
thank you also to aldi who wasn't here

02:25:41,359 --> 02:25:46,000
today um

02:25:42,880 --> 02:25:47,600
thank you for not being here aldi yeah

02:25:46,000 --> 02:25:49,920
and then we'll switch to the next uh

02:25:47,600 --> 02:25:52,319
presentation so jose if you want to

02:25:49,920 --> 02:25:54,240
come online the next presentation will

02:25:52,319 --> 02:25:57,120
be about gnu poke it's an update

02:25:54,240 --> 02:25:58,000
a 2020 update about all the exciting

02:25:57,120 --> 02:26:00,319
work that

02:25:58,000 --> 02:26:06,399
jose and maybe others have been doing on

02:26:00,319 --> 02:26:08,720
the new book

02:26:06,399 --> 02:26:09,840
and while jose comes online uh i think

02:26:08,720 --> 02:26:11,920
uh there's been some

02:26:09,840 --> 02:26:13,600
requests for the tag done so andrew you

02:26:11,920 --> 02:26:15,520
can take one of the uh

02:26:13,600 --> 02:26:17,200
hacker rooms for your demonstration of

02:26:15,520 --> 02:26:20,479
course

02:26:17,200 --> 02:26:22,560
yeah jose hi

02:26:20,479 --> 02:26:24,160
so is the sound in the sound okay it's

02:26:22,560 --> 02:26:27,359
not too strong

02:26:24,160 --> 02:26:30,560
no it sounds perfect to me okay so

02:26:27,359 --> 02:26:32,240
the slides okay they look good i found

02:26:30,560 --> 02:26:34,560
out this morning that

02:26:32,240 --> 02:26:35,520
this bbb platform has some problems with

02:26:34,560 --> 02:26:38,640
some slides

02:26:35,520 --> 02:26:41,600
generated from uh with later

02:26:38,640 --> 02:26:42,000
but seems to work okay i would like to

02:26:41,600 --> 02:26:45,200
use

02:26:42,000 --> 02:26:49,439
those first few minutes

02:26:45,200 --> 02:26:52,640
to make sure that the screen sharing

02:26:49,439 --> 02:26:52,640
is working properly

02:27:00,160 --> 02:27:03,840
is that working

02:27:07,520 --> 02:27:15,120
okay um i just tried to use a very

02:27:12,080 --> 02:27:18,720
quite fat font in the terminal

02:27:15,120 --> 02:27:21,120
so it should be okay

02:27:18,720 --> 02:27:21,120
perfect

02:27:32,960 --> 02:27:37,680
jose can you make the font a bit bigger

02:27:35,359 --> 02:27:40,960
a bit right i guess so yeah okay

02:27:37,680 --> 02:27:43,680
let's see the strip

02:27:40,960 --> 02:27:44,160
yeah the streaming doesn't um doesn't

02:27:43,680 --> 02:27:46,880
necessarily

02:27:44,160 --> 02:27:48,160
do small fonts terribly well ah well

02:27:46,880 --> 02:27:51,040
what the shame

02:27:48,160 --> 02:27:51,040
is this will enough

02:27:54,240 --> 02:27:58,160
it's good enough for if you've got a

02:27:55,760 --> 02:27:59,439
decent broadband and screen it might be

02:27:58,160 --> 02:28:01,840
a bit difficult for people watching on

02:27:59,439 --> 02:28:01,840
youtube

02:28:02,080 --> 02:28:06,319
okay well i mean now it's quite big you

02:28:05,600 --> 02:28:09,359
know

02:28:06,319 --> 02:28:10,080
if i continue zooming in i won't be able

02:28:09,359 --> 02:28:13,359
to

02:28:10,080 --> 02:28:26,960
to have enough screen room here

02:28:13,359 --> 02:28:29,280
well maybe yes let's see

02:28:26,960 --> 02:28:31,680
okay well i guess we will have to work

02:28:29,280 --> 02:28:31,680
with this

02:28:38,840 --> 02:28:43,200
okay so now how to

02:28:57,359 --> 02:29:03,760
okay jose you're good to go

02:29:00,479 --> 02:29:07,040
okay so um

02:29:03,760 --> 02:29:10,080
thank you euro as you all said um

02:29:07,040 --> 02:29:12,479
this year i wanted to um

02:29:10,080 --> 02:29:13,600
to go through some of the the latest

02:29:12,479 --> 02:29:16,880
developments that

02:29:13,600 --> 02:29:19,600
we have done in the poke project

02:29:16,880 --> 02:29:20,080
um it's been more than half a year now

02:29:19,600 --> 02:29:23,200
since

02:29:20,080 --> 02:29:26,240
last year last september when

02:29:23,200 --> 02:29:28,399
i basically

02:29:26,240 --> 02:29:29,760
published the first version of poke

02:29:28,399 --> 02:29:32,880
which was

02:29:29,760 --> 02:29:36,399
under development and well

02:29:32,880 --> 02:29:39,840
we have been very very very busy

02:29:36,399 --> 02:29:43,359
during those months and

02:29:39,840 --> 02:29:46,399
we have been adding a lot of new support

02:29:43,359 --> 02:29:47,760
and you know like capabilities to poke

02:29:46,399 --> 02:29:52,080
and also we have

02:29:47,760 --> 02:29:56,319
advanced in the design of the language

02:29:52,080 --> 02:29:59,040
and there are still some words there

02:29:56,319 --> 02:30:01,040
you know i'm talking about the design um

02:29:59,040 --> 02:30:03,280
like the language capabilities

02:30:01,040 --> 02:30:04,720
and you know like putting everything

02:30:03,280 --> 02:30:06,720
together

02:30:04,720 --> 02:30:08,080
and well i will be mentioning that in

02:30:06,720 --> 02:30:10,479
some detail later

02:30:08,080 --> 02:30:12,000
so basically um this is in the schedule

02:30:10,479 --> 02:30:13,840
listed as a tutorial

02:30:12,000 --> 02:30:15,840
i have to confess that the only reason

02:30:13,840 --> 02:30:16,160
why i selected that option was because

02:30:15,840 --> 02:30:17,840
it

02:30:16,160 --> 02:30:19,200
was the only one giving me more than 20

02:30:17,840 --> 02:30:22,240
minutes

02:30:19,200 --> 02:30:23,439
but um in my defense i have to say that

02:30:22,240 --> 02:30:25,920
there is going to be a lot of

02:30:23,439 --> 02:30:29,120
interactive well not interactive like

02:30:25,920 --> 02:30:32,880
live action here right but we don't have

02:30:29,120 --> 02:30:36,160
much uh much time so we better get

02:30:32,880 --> 02:30:38,560
started okay

02:30:36,160 --> 02:30:38,560
next

02:30:39,200 --> 02:30:43,200
well this is a very similar disclaimer

02:30:41,600 --> 02:30:45,040
that they used last year

02:30:43,200 --> 02:30:46,560
in the different conferences where i

02:30:45,040 --> 02:30:49,840
introduced talk to

02:30:46,560 --> 02:30:51,520
to the people um this is a still working

02:30:49,840 --> 02:30:52,319
progress it was working progress last

02:30:51,520 --> 02:30:55,840
year

02:30:52,319 --> 02:31:00,240
it is work in progress now um as i said

02:30:55,840 --> 02:31:02,560
we are still working a lot only a lot

02:31:00,240 --> 02:31:03,920
on it we have not released our first

02:31:02,560 --> 02:31:07,280
version yet

02:31:03,920 --> 02:31:09,920
but we plan to do so like at the okay

02:31:07,280 --> 02:31:10,640
you know like late summer let's see if

02:31:09,920 --> 02:31:15,840
that's

02:31:10,640 --> 02:31:15,840
that works hopefully

02:31:18,000 --> 02:31:24,640
okay now i cannot see my slides

02:31:21,120 --> 02:31:28,960
can you see them oh it's just slow

02:31:24,640 --> 02:31:29,760
okay well so basically today we are

02:31:28,960 --> 02:31:33,040
going to

02:31:29,760 --> 02:31:35,600
first i'm gonna do a very

02:31:33,040 --> 02:31:36,640
fast and furious introduction to the

02:31:35,600 --> 02:31:38,960
program

02:31:36,640 --> 02:31:40,080
um mainly for the benefit of the people

02:31:38,960 --> 02:31:42,720
who

02:31:40,080 --> 02:31:43,920
well they may not not uh not know what

02:31:42,720 --> 02:31:45,280
poke is

02:31:43,920 --> 02:31:47,520
and they plan to do it like in 10

02:31:45,280 --> 02:31:49,760
minutes gonna be fast i will show

02:31:47,520 --> 02:31:50,640
you know what is that for and how to use

02:31:49,760 --> 02:31:53,600
it

02:31:50,640 --> 02:31:54,840
and so on and then we will go through a

02:31:53,600 --> 02:31:57,920
list of different

02:31:54,840 --> 02:32:00,399
new stuff and new capabilities

02:31:57,920 --> 02:32:01,600
that have been have been implemented in

02:32:00,399 --> 02:32:04,479
delay in the last months

02:32:01,600 --> 02:32:06,160
in the program and then finally well we

02:32:04,479 --> 02:32:09,680
will take a look to the

02:32:06,160 --> 02:32:11,359
status of the project and the the plans

02:32:09,680 --> 02:32:15,120
for the near future

02:32:11,359 --> 02:32:15,120
and for the far future as well

02:32:21,439 --> 02:32:27,600
okay so um yes i'm reducing some of the

02:32:25,600 --> 02:32:29,040
same slides from last year but only for

02:32:27,600 --> 02:32:32,399
this first part

02:32:29,040 --> 02:32:36,240
um basically what is spock pog is

02:32:32,399 --> 02:32:38,720
a command line editor

02:32:36,240 --> 02:32:39,920
which by the way we will see later that

02:32:38,720 --> 02:32:41,840
um

02:32:39,920 --> 02:32:43,680
well we are already working on adding

02:32:41,840 --> 02:32:45,600
some other kind of interfaces to it like

02:32:43,680 --> 02:32:48,720
graphical user interfaces

02:32:45,600 --> 02:32:53,280
but it's mainly a command line editor

02:32:48,720 --> 02:32:55,760
for editing structure binary data

02:32:53,280 --> 02:32:58,319
what do that means well basically um

02:32:55,760 --> 02:33:01,600
it's like well your guardian variety

02:32:58,319 --> 02:33:04,240
um binary editor right like you can have

02:33:01,600 --> 02:33:06,160
it like bytes bits

02:33:04,240 --> 02:33:07,680
you know like data structures simple

02:33:06,160 --> 02:33:11,920
ones strings

02:33:07,680 --> 02:33:15,840
and so on but also um well basically pog

02:33:11,920 --> 02:33:19,520
allows you to define the structure

02:33:15,840 --> 02:33:20,000
of the data that you um that you want to

02:33:19,520 --> 02:33:22,640
edit

02:33:20,000 --> 02:33:24,000
that you want to manipulate in abstract

02:33:22,640 --> 02:33:27,439
terms

02:33:24,000 --> 02:33:29,439
basically to put it simple um

02:33:27,439 --> 02:33:31,040
well imagine that you have some data a

02:33:29,439 --> 02:33:34,479
structure in some

02:33:31,040 --> 02:33:37,280
binary stream or a binary file well

02:33:34,479 --> 02:33:38,720
with pog you can basically define the

02:33:37,280 --> 02:33:41,200
structure of that data

02:33:38,720 --> 02:33:43,359
and then operate on the data using in

02:33:41,200 --> 02:33:47,280
terms of the same abstractions

02:33:43,359 --> 02:33:50,560
that you define and this is achievable

02:33:47,280 --> 02:33:52,479
this is possible without basically

02:33:50,560 --> 02:33:55,760
without the specializing the tool

02:33:52,479 --> 02:33:58,160
i mean poc is a general purpose tool and

02:33:55,760 --> 02:33:59,600
once you teach spoke about the structure

02:33:58,160 --> 02:34:02,160
of your data

02:33:59,600 --> 02:34:04,240
you can use it in a quite general way we

02:34:02,160 --> 02:34:06,399
will so we will see that

02:34:04,240 --> 02:34:09,120
um well basically the motivation for the

02:34:06,399 --> 02:34:12,319
project was that

02:34:09,120 --> 02:34:15,280
my job in my daily job well i

02:34:12,319 --> 02:34:17,120
have to deal with binary objects very

02:34:15,280 --> 02:34:20,160
often another kind of

02:34:17,120 --> 02:34:21,840
data which is encoded in not that

02:34:20,160 --> 02:34:25,120
convenient ways

02:34:21,840 --> 02:34:28,319
and well

02:34:25,120 --> 02:34:30,640
you know i mean i collected

02:34:28,319 --> 02:34:31,840
through time i collected like a good

02:34:30,640 --> 02:34:35,280
good

02:34:31,840 --> 02:34:37,600
big collection of scripts you know to do

02:34:35,280 --> 02:34:39,280
all kind of things to those files

02:34:37,600 --> 02:34:41,920
and then at some point i decided that it

02:34:39,280 --> 02:34:43,280
was enough and that

02:34:41,920 --> 02:34:44,880
instead of investing my time on

02:34:43,280 --> 02:34:46,080
maintaining those scripts i will invest

02:34:44,880 --> 02:34:47,040
my time on writing something more

02:34:46,080 --> 02:34:49,200
general

02:34:47,040 --> 02:34:49,200
so

02:34:53,120 --> 02:34:58,880
okay basically well i took a while to

02:34:56,560 --> 02:35:00,560
develop the idea initially i thought it

02:34:58,880 --> 02:35:02,160
was it was gonna be something very

02:35:00,560 --> 02:35:05,120
simple like okay uh some

02:35:02,160 --> 02:35:06,640
sick kind some kind of you know like cs

02:35:05,120 --> 02:35:09,840
tracts with a little

02:35:06,640 --> 02:35:12,960
bit extra you know to eliminate the

02:35:09,840 --> 02:35:15,120
the undefined aspects of the c

02:35:12,960 --> 02:35:16,800
definitions of extracts

02:35:15,120 --> 02:35:18,720
but then of course it's very fast you

02:35:16,800 --> 02:35:21,920
know it exploded into

02:35:18,720 --> 02:35:24,319
into into craziness and

02:35:21,920 --> 02:35:26,720
there were some existing work from which

02:35:24,319 --> 02:35:29,280
i took a lot of inspiration from

02:35:26,720 --> 02:35:31,040
i can i want to mention one of it which

02:35:29,280 --> 02:35:34,080
is a data script

02:35:31,040 --> 02:35:35,920
developed by a professor in some

02:35:34,080 --> 02:35:38,560
american university the beginning of the

02:35:35,920 --> 02:35:41,680
2000s

02:35:38,560 --> 02:35:43,120
which was quite nice um i learned a lot

02:35:41,680 --> 02:35:46,319
from it

02:35:43,120 --> 02:35:49,280
um but well it was a bit limited for

02:35:46,319 --> 02:35:49,280
what they wanted to do

02:35:52,720 --> 02:35:56,720
so uh first before seeing the

02:35:55,680 --> 02:35:59,840
architecture

02:35:56,720 --> 02:36:03,359
let me show you very very fast

02:35:59,840 --> 02:36:09,840
a little talk session for the people who

02:36:03,359 --> 02:36:09,840
are not familiar with the program

02:36:10,080 --> 02:36:18,560
yeah okay so um i have a build box here

02:36:15,600 --> 02:36:18,880
um i'm not cheating i mean this is you

02:36:18,560 --> 02:36:21,520
see

02:36:18,880 --> 02:36:22,160
this is master only bootstrap.com is

02:36:21,520 --> 02:36:23,920
modified

02:36:22,160 --> 02:36:25,600
because i have i had to use a machine

02:36:23,920 --> 02:36:29,439
that is not my main machine

02:36:25,600 --> 02:36:29,840
but uh you know what we are going to see

02:36:29,439 --> 02:36:34,000
here

02:36:29,840 --> 02:36:36,080
is the current master

02:36:34,000 --> 02:36:38,319
the current heat master so let's see how

02:36:36,080 --> 02:36:40,960
many segmentation scope faults we're

02:36:38,319 --> 02:36:43,280
going we're going to collect today so

02:36:40,960 --> 02:36:43,280
pog

02:36:47,600 --> 02:36:51,520
this is how you well how you invoke it

02:36:50,000 --> 02:36:53,359
when it's not installed

02:36:51,520 --> 02:36:55,040
you know this run script it basically

02:36:53,359 --> 02:36:57,760
sets up the environment

02:36:55,040 --> 02:36:59,600
and this is it you basically you run it

02:36:57,760 --> 02:37:02,560
you get a prompt

02:36:59,600 --> 02:37:03,280
um it says hello and then you are on

02:37:02,560 --> 02:37:07,439
your own

02:37:03,280 --> 02:37:07,439
right so um

02:37:07,760 --> 02:37:12,960
one of the most basic capabilities is uh

02:37:10,960 --> 02:37:14,160
well opening what opening files right we

02:37:12,960 --> 02:37:17,120
will see later what

02:37:14,160 --> 02:37:18,000
we call io spaces so for example let's

02:37:17,120 --> 02:37:22,080
open another

02:37:18,000 --> 02:37:24,479
file that they have compiled before here

02:37:22,080 --> 02:37:25,439
so basically you please ignore the elf

02:37:24,479 --> 02:37:28,560
part

02:37:25,439 --> 02:37:31,520
before the prompt for the moment

02:37:28,560 --> 02:37:32,080
so basically now the current file in the

02:37:31,520 --> 02:37:35,840
editor

02:37:32,080 --> 02:37:37,439
is is 4.0 so then what is the most basic

02:37:35,840 --> 02:37:39,439
thing we can do with it well we can take

02:37:37,439 --> 02:37:41,439
a look

02:37:39,439 --> 02:37:42,800
the different uh bytes you know

02:37:41,439 --> 02:37:45,680
composing the file

02:37:42,800 --> 02:37:46,560
so we can see here that the dump command

02:37:45,680 --> 02:37:48,240
basically

02:37:46,560 --> 02:37:51,200
if we execute it to the prompt then we

02:37:48,240 --> 02:37:51,200
get like

02:37:51,520 --> 02:37:55,040
bytes right so the contents of the file

02:37:53,439 --> 02:37:55,920
is starting since the beginning of the

02:37:55,040 --> 02:37:58,560
file

02:37:55,920 --> 02:38:00,479
now i say that pokey is a binary editor

02:37:58,560 --> 02:38:03,600
so you can expect that you can actually

02:38:00,479 --> 02:38:06,640
um well edit the stuff

02:38:03,600 --> 02:38:09,120
stuff with it right and the most basic

02:38:06,640 --> 02:38:13,359
entities that you can edit with poker

02:38:09,120 --> 02:38:16,479
bytes right so for example we can

02:38:13,359 --> 02:38:19,520
say okay which one is the bite at

02:38:16,479 --> 02:38:22,640
the uh starting at the first byte

02:38:19,520 --> 02:38:24,960
since the beginning of the file

02:38:22,640 --> 02:38:26,080
and then well we'll get it like that

02:38:24,960 --> 02:38:29,680
right

02:38:26,080 --> 02:38:32,399
um but then we could also modify it

02:38:29,680 --> 02:38:34,000
right because imagine that we want to i

02:38:32,399 --> 02:38:35,520
don't know to vandalize this cell file

02:38:34,000 --> 02:38:36,000
so it's not recognized as in the file

02:38:35,520 --> 02:38:37,600
anymore

02:38:36,000 --> 02:38:39,280
so we could do something like this it

02:38:37,600 --> 02:38:40,479
will break the magic number in this case

02:38:39,280 --> 02:38:44,000
so we could say okay

02:38:40,479 --> 02:38:47,120
change the first byte you know to

02:38:44,000 --> 02:38:47,600
um uh well the ascii code corresponding

02:38:47,120 --> 02:38:51,040
to the

02:38:47,600 --> 02:38:55,280
little x uh lowercase x

02:38:51,040 --> 02:38:58,960
character so then if we jump again

02:38:55,280 --> 02:38:59,920
well you can see well i don't know can

02:38:58,960 --> 02:39:02,080
you see my

02:38:59,920 --> 02:39:03,120
my the cursor image in the screen yeah i

02:39:02,080 --> 02:39:06,160
think so

02:39:03,120 --> 02:39:10,080
you can see that it actually changed it

02:39:06,160 --> 02:39:12,720
right in the file that we are editing

02:39:10,080 --> 02:39:13,840
so this is how you manipulate single

02:39:12,720 --> 02:39:18,240
bytes here

02:39:13,840 --> 02:39:22,080
okay let's restore the file

02:39:18,240 --> 02:39:25,680
so this was the big

02:39:22,080 --> 02:39:30,319
e now this is back

02:39:25,680 --> 02:39:32,319
you know like a normal uh l5 okay but

02:39:30,319 --> 02:39:33,600
in the same way that you can manipulate

02:39:32,319 --> 02:39:35,760
bytes this way

02:39:33,600 --> 02:39:37,280
you can manipulate or manipulate other

02:39:35,760 --> 02:39:40,479
kind of simple data

02:39:37,280 --> 02:39:44,640
right so for example you could

02:39:40,479 --> 02:39:47,520
say okay uh i want to write

02:39:44,640 --> 02:39:48,479
or give me i want to read or i want to

02:39:47,520 --> 02:39:51,600
take a look

02:39:48,479 --> 02:39:52,080
to be a string right starting at the

02:39:51,600 --> 02:39:55,520
beginning

02:39:52,080 --> 02:39:57,920
of the file and then we get a string

02:39:55,520 --> 02:39:58,880
which is uh basically well in this case

02:39:57,920 --> 02:40:00,960
it contains the

02:39:58,880 --> 02:40:02,160
elf right which is the magic number

02:40:00,960 --> 02:40:06,479
which happens to be

02:40:02,160 --> 02:40:08,880
you know really polanski um

02:40:06,479 --> 02:40:10,080
in the same way we can do something like

02:40:08,880 --> 02:40:11,920
this so just string

02:40:10,080 --> 02:40:13,520
something at the first byte i want to

02:40:11,920 --> 02:40:16,640
change it to

02:40:13,520 --> 02:40:21,359
instead of f to f l e for example you

02:40:16,640 --> 02:40:24,319
know to reverse it

02:40:21,359 --> 02:40:24,319
and it also works

02:40:28,399 --> 02:40:32,399
um in the same way that we can do that

02:40:30,720 --> 02:40:32,880
with bikes and with the strings we have

02:40:32,399 --> 02:40:36,880
seen

02:40:32,880 --> 02:40:39,840
we can do it with integers um

02:40:36,880 --> 02:40:41,920
but you know normally in programming

02:40:39,840 --> 02:40:44,319
languages you have integers

02:40:41,920 --> 02:40:45,680
you have types covering in certain

02:40:44,319 --> 02:40:48,800
widths of integers right

02:40:45,680 --> 02:40:50,800
both sides or inside like 32 bits in two

02:40:48,800 --> 02:40:51,600
years like 64 bits in the years and so

02:40:50,800 --> 02:40:54,880
on

02:40:51,600 --> 02:40:57,040
but poke is different in the sense that

02:40:54,880 --> 02:40:58,080
in poke 32 bit integers for example they

02:40:57,040 --> 02:41:01,120
are nothing

02:40:58,080 --> 02:41:02,880
special you can have integers of any

02:41:01,120 --> 02:41:05,600
number of bits from one bit

02:41:02,880 --> 02:41:07,520
to 64 bits and the 64 bits limit is

02:41:05,600 --> 02:41:09,279
something that we are gonna remove soon

02:41:07,520 --> 02:41:10,560
when we integrate and support for big

02:41:09,279 --> 02:41:12,399
numbers so

02:41:10,560 --> 02:41:14,479
what i mean with this we will see a bit

02:41:12,399 --> 02:41:15,359
more about this later when we see weird

02:41:14,479 --> 02:41:18,560
numbers

02:41:15,359 --> 02:41:22,000
is that in pog in reality um

02:41:18,560 --> 02:41:25,600
an integer can be an integer of 11 bits

02:41:22,000 --> 02:41:29,439
so for example give me the integer

02:41:25,600 --> 02:41:32,319
uh the 11 bits unsigned integer starting

02:41:29,439 --> 02:41:32,880
and offset one byte for example here you

02:41:32,319 --> 02:41:34,960
go

02:41:32,880 --> 02:41:37,600
well it is that value in extra decimal

02:41:34,960 --> 02:41:40,240
right um

02:41:37,600 --> 02:41:40,800
we will see later too a bit more in tip

02:41:40,240 --> 02:41:42,399
that

02:41:40,800 --> 02:41:44,319
those integers they don't even have to

02:41:42,399 --> 02:41:46,800
be aligned right i mean

02:41:44,319 --> 02:41:49,200
you could actually or ask for the

02:41:46,800 --> 02:41:52,880
unsigned integer of 11 bits

02:41:49,200 --> 02:41:55,760
starting at offset 13 bits

02:41:52,880 --> 02:41:59,680
because team bytes and you get that

02:41:55,760 --> 02:42:02,319
value as well and

02:41:59,680 --> 02:42:03,680
well this is basically pretty generic

02:42:02,319 --> 02:42:05,920
again there is nothing

02:42:03,680 --> 02:42:08,160
special about the conventionally sized

02:42:05,920 --> 02:42:10,160
integers anymore we will see later

02:42:08,160 --> 02:42:12,080
but for for this to work and to be

02:42:10,160 --> 02:42:12,800
predictable of course we need some kind

02:42:12,080 --> 02:42:15,200
of um

02:42:12,800 --> 02:42:16,080
of abstraction right because as we will

02:42:15,200 --> 02:42:17,359
see later

02:42:16,080 --> 02:42:19,120
well underneath what we have is a

02:42:17,359 --> 02:42:20,399
sequence of dice so when we start

02:42:19,120 --> 02:42:23,279
talking about

02:42:20,399 --> 02:42:23,520
all the numbers like of 11 bits and all

02:42:23,279 --> 02:42:25,359
the

02:42:23,520 --> 02:42:27,040
alignments then we have we need to have

02:42:25,359 --> 02:42:29,120
some kind of

02:42:27,040 --> 02:42:31,120
conventions right we will see that later

02:42:29,120 --> 02:42:33,600
anyway um

02:42:31,120 --> 02:42:34,880
in the same way that we can work with

02:42:33,600 --> 02:42:37,040
integers with the strings

02:42:34,880 --> 02:42:38,960
you know we can also work with arrays of

02:42:37,040 --> 02:42:42,000
things like for example

02:42:38,960 --> 02:42:45,200
um give me the array of three

02:42:42,000 --> 02:42:48,640
11 bit integers starting at

02:42:45,200 --> 02:42:50,080
offset 13 bits in the five well those

02:42:48,640 --> 02:42:52,240
are the ones

02:42:50,080 --> 02:42:55,840
um those are the ones actually i mean

02:42:52,240 --> 02:42:55,840
this works

02:42:56,880 --> 02:43:03,439
as we can also do as we will see

02:43:00,560 --> 02:43:05,279
also later more sophisticated stuff but

02:43:03,439 --> 02:43:07,600
to finish with introduction

02:43:05,279 --> 02:43:08,319
so this was an array fine you can also

02:43:07,600 --> 02:43:10,960
define

02:43:08,319 --> 02:43:12,240
extracts so you can also define your own

02:43:10,960 --> 02:43:14,160
data structures

02:43:12,240 --> 02:43:15,680
so for example let's see this is the

02:43:14,160 --> 02:43:18,479
example i always use

02:43:15,680 --> 02:43:20,319
let's say that we say that the packet is

02:43:18,479 --> 02:43:24,479
an integer

02:43:20,319 --> 02:43:27,600
i followed by a long tail

02:43:24,479 --> 02:43:31,439
um in pog things like

02:43:27,600 --> 02:43:35,359
ink is a synonymous of

02:43:31,439 --> 02:43:37,920
an interpreter along his analysis for

02:43:35,359 --> 02:43:39,920
i think well for in 64. you can use

02:43:37,920 --> 02:43:41,359
cedar you know it is in a in a standard

02:43:39,920 --> 02:43:44,720
in the standard library

02:43:41,359 --> 02:43:46,960
that book loads had started

02:43:44,720 --> 02:43:48,720
well anyway so once we have a packet

02:43:46,960 --> 02:43:50,880
defined this type packet in this

02:43:48,720 --> 02:43:52,240
in this case well you can do the same

02:43:50,880 --> 02:43:54,080
that with the simple types

02:43:52,240 --> 02:43:55,840
so you can say okay i want to see the

02:43:54,080 --> 02:43:58,399
packet starting at

02:43:55,840 --> 02:43:59,040
13 bytes in this case from the beginning

02:43:58,399 --> 02:44:03,279
of the file

02:43:59,040 --> 02:44:06,640
so that is it um

02:44:03,279 --> 02:44:08,880
and then of course you can also say okay

02:44:06,640 --> 02:44:10,160
um let's see this bar this is how you

02:44:08,880 --> 02:44:13,279
define a variable

02:44:10,160 --> 02:44:16,479
input okay let's put this packet in

02:44:13,279 --> 02:44:18,800
a variable p and then well

02:44:16,479 --> 02:44:20,720
that's what we have so imagine that we

02:44:18,800 --> 02:44:23,600
want to change one of the fields so well

02:44:20,720 --> 02:44:27,200
we just do it using dot notation

02:44:23,600 --> 02:44:30,880
so let's say that for example we want to

02:44:27,200 --> 02:44:35,439
um increase you know the the field l

02:44:30,880 --> 02:44:37,439
in one and then now if we take a look

02:44:35,439 --> 02:44:39,359
to the contents of the file we will see

02:44:37,439 --> 02:44:41,439
that these the contents in the file

02:44:39,359 --> 02:44:42,880
they changed accordingly so we can do it

02:44:41,439 --> 02:44:46,160
for example to dump

02:44:42,880 --> 02:44:46,800
them command we can pass arguments so we

02:44:46,160 --> 02:44:49,760
can say

02:44:46,800 --> 02:44:50,880
how can we see the bytes corresponding

02:44:49,760 --> 02:44:54,000
specifically

02:44:50,880 --> 02:44:55,760
to this uh to this packet this packet

02:44:54,000 --> 02:44:57,680
at 13 bytes since the beginning of the

02:44:55,760 --> 02:45:01,439
file what we will do is something like

02:44:57,680 --> 02:45:05,120
okay done from from what from the offset

02:45:01,439 --> 02:45:07,920
of p this is how you specify an offset

02:45:05,120 --> 02:45:09,439
in uh of a poke value in this case the

02:45:07,920 --> 02:45:12,880
value is extract value

02:45:09,439 --> 02:45:18,560
so and it is mapped so it has an offset

02:45:12,880 --> 02:45:22,800
size precise so then this should give us

02:45:18,560 --> 02:45:26,640
the bytes starting

02:45:22,800 --> 02:45:29,439
at offset d

02:45:26,640 --> 02:45:30,800
which was the offset where we mapped 13

02:45:29,439 --> 02:45:32,800
yeah 13 bytes

02:45:30,800 --> 02:45:34,319
and those are the bytes and then if we

02:45:32,800 --> 02:45:37,600
look

02:45:34,319 --> 02:45:41,680
uh one f7

02:45:37,600 --> 02:45:44,800
or one f7 yeah

02:45:41,680 --> 02:45:48,560
so the contents changed in the file

02:45:44,800 --> 02:45:50,240
so let's restore the file again minus

02:45:48,560 --> 02:45:53,840
one

02:45:50,240 --> 02:45:57,279
and uh and well and that is how you

02:45:53,840 --> 02:45:58,960
actually change modify things in terms

02:45:57,279 --> 02:46:02,000
of your abstractions

02:45:58,960 --> 02:46:05,760
now this is a very

02:46:02,000 --> 02:46:09,120
small stupid example but we can do

02:46:05,760 --> 02:46:12,880
a bit better so for example we say that

02:46:09,120 --> 02:46:15,200
4.0 it is an l file right ramp oh

02:46:12,880 --> 02:46:16,160
from zero bytes the time command

02:46:15,200 --> 02:46:18,800
remembers the last

02:46:16,160 --> 02:46:20,479
offset that we used right so so yeah

02:46:18,800 --> 02:46:22,840
this looks like an elephant right we see

02:46:20,479 --> 02:46:25,760
the magic number there and everything

02:46:22,840 --> 02:46:29,040
um so

02:46:25,760 --> 02:46:32,000
we can say okay we are editing

02:46:29,040 --> 02:46:34,319
an l file so it happens and let me

02:46:32,000 --> 02:46:34,319
change

02:46:34,800 --> 02:46:40,800
to an image here that we talk we

02:46:38,160 --> 02:46:44,240
distribute a set of what we call pickles

02:46:40,800 --> 02:46:47,359
which are basically a collection of uh

02:46:44,240 --> 02:46:48,080
pre-written definitions for some certain

02:46:47,359 --> 02:46:51,439
formats

02:46:48,080 --> 02:46:54,160
or domains or whatever

02:46:51,439 --> 02:46:56,479
in this case there is an elf pickle

02:46:54,160 --> 02:47:00,479
which is this one here

02:46:56,479 --> 02:47:03,200
and it contains definitions for

02:47:00,479 --> 02:47:05,760
well many different things i already

02:47:03,200 --> 02:47:07,439
showed this last year but now obviously

02:47:05,760 --> 02:47:09,760
now we support methods now we support

02:47:07,439 --> 02:47:10,160
much more things so the pkl accordingly

02:47:09,760 --> 02:47:12,319
is

02:47:10,160 --> 02:47:13,359
much more sophisticated now and much

02:47:12,319 --> 02:47:16,800
more useful

02:47:13,359 --> 02:47:18,560
so um for example well basically

02:47:16,800 --> 02:47:20,160
something that it's always defined in

02:47:18,560 --> 02:47:23,760
pickles or more often

02:47:20,160 --> 02:47:24,319
is types so for example here we can see

02:47:23,760 --> 02:47:26,560
a type

02:47:24,319 --> 02:47:28,000
which is the type corresponding to an

02:47:26,560 --> 02:47:31,200
l64

02:47:28,000 --> 02:47:34,240
elf file so this

02:47:31,200 --> 02:47:37,359
extract definition basically it covers

02:47:34,240 --> 02:47:37,359
everything that

02:47:37,760 --> 02:47:43,279
corresponds to the elf file

02:47:41,359 --> 02:47:44,720
we will see that by having you know this

02:47:43,279 --> 02:47:47,279
step called a file and

02:47:44,720 --> 02:47:48,560
well imagine that you had differential

02:47:47,279 --> 02:47:51,040
files

02:47:48,560 --> 02:47:52,640
packed consecutively in a stream for

02:47:51,040 --> 02:47:55,840
example or in another file

02:47:52,640 --> 02:47:58,080
or in a tar file or you know um

02:47:55,840 --> 02:48:00,720
you could still with poc you could still

02:47:58,080 --> 02:48:03,680
map an f64 file

02:48:00,720 --> 02:48:05,120
in this case type from any offset in the

02:48:03,680 --> 02:48:06,800
ios space so it doesn't have to

02:48:05,120 --> 02:48:10,479
correspond to a physical file

02:48:06,800 --> 02:48:14,479
so anyway um

02:48:10,479 --> 02:48:14,479
in this case photo

02:48:14,880 --> 02:48:18,240
well it is an l file actually pog knows

02:48:17,040 --> 02:48:21,279
that and

02:48:18,240 --> 02:48:23,359
it recognized that uh this is

02:48:21,279 --> 02:48:24,800
an l file that's why you can see this

02:48:23,359 --> 02:48:27,920
elf little elf thing at the

02:48:24,800 --> 02:48:31,520
at the left of the of the prompt

02:48:27,920 --> 02:48:35,439
so why did it recognize it because

02:48:31,520 --> 02:48:35,439
in my focus rc file

02:48:39,840 --> 02:48:45,840
no it's not in the propriety file sorry

02:48:56,840 --> 02:48:59,840
um

02:49:01,840 --> 02:49:04,960
well i can't find it now but anyway

02:49:04,160 --> 02:49:07,040
there is a part

02:49:04,960 --> 02:49:09,040
in the poke runtime that basically

02:49:07,040 --> 02:49:09,920
associates it has an association list in

02:49:09,040 --> 02:49:12,960
an array

02:49:09,920 --> 02:49:14,880
with uh file names to to

02:49:12,960 --> 02:49:16,240
specifying what it is it's similar to

02:49:14,880 --> 02:49:18,720
the mx saturation list

02:49:16,240 --> 02:49:21,040
restrict extensions to formats anyway

02:49:18,720 --> 02:49:22,720
whatever

02:49:21,040 --> 02:49:24,560
notification here because we don't have

02:49:22,720 --> 02:49:28,240
time anyway so

02:49:24,560 --> 02:49:30,479
um basically this means that

02:49:28,240 --> 02:49:32,800
i have access to all that stuff that is

02:49:30,479 --> 02:49:36,960
defined in the elf picker

02:49:32,800 --> 02:49:38,319
so for example the types

02:49:36,960 --> 02:49:41,040
as you can see that we have auto

02:49:38,319 --> 02:49:42,880
completion now um

02:49:41,040 --> 02:49:45,200
so for example i will i would want to

02:49:42,880 --> 02:49:47,680
see well what is the l file the contents

02:49:45,200 --> 02:49:49,520
of the l5 so i map an l file

02:49:47,680 --> 02:49:51,200
at the beginning of the file in this

02:49:49,520 --> 02:49:54,640
case object zero since the beginning

02:49:51,200 --> 02:49:56,880
right oh and this is what i get

02:49:54,640 --> 02:49:56,880
um

02:49:58,560 --> 02:50:04,080
as you can see there is an elf header

02:50:01,920 --> 02:50:05,520
um and then there is all the rest of the

02:50:04,080 --> 02:50:09,840
fields

02:50:05,520 --> 02:50:13,600
under it okay so um it happens

02:50:09,840 --> 02:50:16,479
that well i can do that bar as

02:50:13,600 --> 02:50:17,600
that so now the variable elf contains

02:50:16,479 --> 02:50:19,279
this map extract

02:50:17,600 --> 02:50:22,080
so for example if i wanted to get the

02:50:19,279 --> 02:50:26,800
header i would i could refer to it

02:50:22,080 --> 02:50:29,840
as elf um htr

02:50:26,800 --> 02:50:30,479
and then i get the header with all his

02:50:29,840 --> 02:50:34,880
content

02:50:30,479 --> 02:50:38,240
all the contents um right now we can do

02:50:34,880 --> 02:50:41,359
better things than this so for example

02:50:38,240 --> 02:50:44,720
i can low i can do okay very fast

02:50:41,359 --> 02:50:48,160
for example i can do a load

02:50:44,720 --> 02:50:50,720
well for example if i want the text

02:50:48,160 --> 02:50:52,560
section of the l file i can call to a

02:50:50,720 --> 02:50:55,200
method that is defined also in the pixel

02:50:52,560 --> 02:50:57,760
which is forget section

02:50:55,200 --> 02:50:57,760
by name

02:50:58,240 --> 02:51:01,120
and then this is the

02:51:02,000 --> 02:51:07,520
this is the contents of the the the

02:51:05,279 --> 02:51:09,920
the text section of the ldf file which

02:51:07,520 --> 02:51:12,080
in this case this is a bpf file

02:51:09,920 --> 02:51:13,120
used be compiled using the bpf backend

02:51:12,080 --> 02:51:17,120
of gcc so

02:51:13,120 --> 02:51:20,640
i can load the bps pickle and then

02:51:17,120 --> 02:51:26,960
now i have access to all those types

02:51:20,640 --> 02:51:26,960
pdf so for example i can say okay

02:51:27,920 --> 02:51:33,840
give me all the ppf

02:51:30,960 --> 02:51:33,840
instructions

02:51:35,760 --> 02:51:44,560
shh size that occupy exercise bytes

02:51:40,479 --> 02:51:44,560
add text as its offset

02:51:45,359 --> 02:51:49,200
there you go and then you can see the

02:51:47,200 --> 02:51:51,120
different definitions

02:51:49,200 --> 02:51:52,479
of the bpf instructions here we will see

02:51:51,120 --> 02:51:55,279
a little bit more of this later

02:51:52,479 --> 02:51:57,040
anyway this is pog so when you have a

02:51:55,279 --> 02:51:59,279
value

02:51:57,040 --> 02:52:00,080
that is mapped that is mapped you can

02:51:59,279 --> 02:52:03,359
actually edit

02:52:00,080 --> 02:52:06,880
it and when you modify the structures

02:52:03,359 --> 02:52:12,160
it gets updated in in the file

02:52:06,880 --> 02:52:12,160
in this in this case so let's go back

02:52:12,479 --> 02:52:16,479
to the presentation okay the

02:52:14,240 --> 02:52:20,240
architecture of poke this is very fast

02:52:16,479 --> 02:52:21,439
um poke is not as simple as it should it

02:52:20,240 --> 02:52:25,359
could seem

02:52:21,439 --> 02:52:28,000
um actually it has a compiler it has a

02:52:25,359 --> 02:52:29,840
virtual machine uh it has an io

02:52:28,000 --> 02:52:30,399
subsystem which is the one that is in

02:52:29,840 --> 02:52:33,439
charge of

02:52:30,399 --> 02:52:35,760
implementing you know all the

02:52:33,439 --> 02:52:37,359
well on the input output in this case

02:52:35,760 --> 02:52:41,200
two files but we will see that

02:52:37,359 --> 02:52:44,240
it will support other id spaces and then

02:52:41,200 --> 02:52:46,560
all of that is in a leap poke

02:52:44,240 --> 02:52:49,120
so dodgy as you can see i listen

02:52:46,560 --> 02:52:51,760
sometimes not often but sometimes i do

02:52:49,120 --> 02:52:53,680
and now there is a leap box that

02:52:51,760 --> 02:52:54,880
provides services we will see this later

02:52:53,680 --> 02:52:57,200
too very fast

02:52:54,880 --> 02:52:59,439
and the poke application the command

02:52:57,200 --> 02:52:59,439
part

02:53:03,439 --> 02:53:07,920
okay this is uh this was to not confuse

02:53:05,920 --> 02:53:11,040
the poke is the program but with big p

02:53:07,920 --> 02:53:12,000
is the domain specific language that pog

02:53:11,040 --> 02:53:14,399
implements

02:53:12,000 --> 02:53:15,359
and then article as we just said is a

02:53:14,399 --> 02:53:24,560
collection of

02:53:15,359 --> 02:53:26,960
related facilities right

02:53:24,560 --> 02:53:29,040
okay those are slides i got them here

02:53:26,960 --> 02:53:31,279
just in case

02:53:29,040 --> 02:53:33,600
for you know but this is what we have

02:53:31,279 --> 02:53:36,000
seen now you know it's okay it has

02:53:33,600 --> 02:53:38,720
it supports interiors it supports arrays

02:53:36,000 --> 02:53:40,960
extracts and so on i don't know why it's

02:53:38,720 --> 02:53:44,399
taking so long for

02:53:40,960 --> 02:53:44,399
the slides to load actually

02:53:45,040 --> 02:53:50,000
type structs it supports variables as

02:53:49,200 --> 02:53:53,840
well

02:53:50,000 --> 02:53:53,840
and functions

02:54:10,080 --> 02:54:17,200
okay let's go to the interesting part

02:54:13,439 --> 02:54:21,120
what is new um let's just start with the

02:54:17,200 --> 02:54:22,720
fun stuff um using bruno hubble's

02:54:21,120 --> 02:54:24,319
lip text style which is something that

02:54:22,720 --> 02:54:27,359
he wrote recently

02:54:24,319 --> 02:54:30,399
um now we as you can as you have seen

02:54:27,359 --> 02:54:31,040
in in the demo now we support uh like a

02:54:30,399 --> 02:54:33,200
styling

02:54:31,040 --> 02:54:35,200
in the terminal so that means colors

02:54:33,200 --> 02:54:37,840
nice that means

02:54:35,200 --> 02:54:39,520
well bold and things like that like

02:54:37,840 --> 02:54:43,040
attributes visual attributes

02:54:39,520 --> 02:54:45,680
for the output this

02:54:43,040 --> 02:54:48,160
is implemented as basically everything

02:54:45,680 --> 02:54:49,200
that bruno writes in a very convenient

02:54:48,160 --> 02:54:52,880
way

02:54:49,200 --> 02:54:57,760
in a way that basically

02:54:52,880 --> 02:55:01,760
you define the style using a css file

02:54:57,760 --> 02:55:02,960
like this this is the file that gets

02:55:01,760 --> 02:55:07,359
installed by default

02:55:02,960 --> 02:55:09,680
in package in the package tier um

02:55:07,359 --> 02:55:11,040
where you can define classes like a

02:55:09,680 --> 02:55:14,080
styling classes

02:55:11,040 --> 02:55:15,840
and then um well pog will

02:55:14,080 --> 02:55:17,279
basically do the right thing in the

02:55:15,840 --> 02:55:20,399
styling

02:55:17,279 --> 02:55:20,960
this is also so for example if you if we

02:55:20,399 --> 02:55:24,240
print

02:55:20,960 --> 02:55:27,279
the number 13 you can see there you see

02:55:24,240 --> 02:55:29,520
it's green and it is green because

02:55:27,279 --> 02:55:31,760
there is an integer class here they find

02:55:29,520 --> 02:55:33,840
here where the color is green

02:55:31,760 --> 02:55:36,240
but you can also define your own your

02:55:33,840 --> 02:55:38,399
own classes

02:55:36,240 --> 02:55:40,479
and the classes that you can how you

02:55:38,399 --> 02:55:44,399
define your own class as well

02:55:40,479 --> 02:55:47,200
let's define here a full class

02:55:44,399 --> 02:55:47,200
color pink

02:55:48,080 --> 02:55:52,560
and then from pog you can you have a

02:55:50,960 --> 02:55:55,520
primitive which is printf

02:55:52,560 --> 02:55:56,160
which surprise you does formatted output

02:55:55,520 --> 02:55:58,240
and

02:55:56,160 --> 02:55:59,680
there is uh this is the syntax that you

02:55:58,240 --> 02:56:00,560
use for example i want to print

02:55:59,680 --> 02:56:03,680
something

02:56:00,560 --> 02:56:05,920
with the class uh

02:56:03,680 --> 02:56:06,720
with a class full so in this case for

02:56:05,920 --> 02:56:12,880
example

02:56:06,720 --> 02:56:17,600
let's print an integer in decimal

02:56:12,880 --> 02:56:21,200
using this styling class 13

02:56:17,600 --> 02:56:21,200
oops here we go

02:56:21,680 --> 02:56:24,880
oh yeah okay i i don't know how to use

02:56:24,000 --> 02:56:26,800
my own program

02:56:24,880 --> 02:56:28,560
that's always happens to me okay this is

02:56:26,800 --> 02:56:30,960
the format right

02:56:28,560 --> 02:56:32,080
so this basically prints whatever is in

02:56:30,960 --> 02:56:35,760
the middle

02:56:32,080 --> 02:56:35,760
with using that styling class

02:56:36,080 --> 02:56:41,840
i forgot the new line

02:56:45,120 --> 02:56:50,160
no problem there you go pink

02:56:51,120 --> 02:56:57,760
so this that is nice you know to have

02:56:54,319 --> 02:57:00,720
like uh like nice colors

02:56:57,760 --> 02:57:03,279
and you know and to see stuff it has

02:57:00,720 --> 02:57:06,840
another advantage

02:57:03,279 --> 02:57:09,840
which is the support for terminal

02:57:06,840 --> 02:57:09,840
hyperlinks

02:57:12,319 --> 02:57:16,640
which i will show you now how how they

02:57:14,640 --> 02:57:18,399
feel i took great pains to

02:57:16,640 --> 02:57:20,240
to compile like no terminal which is

02:57:18,399 --> 02:57:21,120
modern enough to you know to support

02:57:20,240 --> 02:57:22,880
this but

02:57:21,120 --> 02:57:24,479
i think it's worth enough because it's

02:57:22,880 --> 02:57:26,000
very interesting well

02:57:24,479 --> 02:57:28,399
what are the hyperlinks you know that

02:57:26,000 --> 02:57:29,439
the terminal emulators for long time now

02:57:28,399 --> 02:57:30,960
they

02:57:29,439 --> 02:57:34,080
sort of support you know they try to

02:57:30,960 --> 02:57:36,640
recognize http links and ftp links

02:57:34,080 --> 02:57:37,920
you know like urls in the output of the

02:57:36,640 --> 02:57:38,880
programs and then they do the right

02:57:37,920 --> 02:57:40,479
thing somehow

02:57:38,880 --> 02:57:43,040
you click on them and then it opens a

02:57:40,479 --> 02:57:46,160
web browser or whatever it is

02:57:43,040 --> 02:57:48,880
but um some smart people they thought

02:57:46,160 --> 02:57:50,720
that this could be improved and they

02:57:48,880 --> 02:57:52,080
basically created those terminal

02:57:50,720 --> 02:57:55,279
hyperlinks which

02:57:52,080 --> 02:57:59,840
basically is uh escape sequence

02:57:55,279 --> 02:58:01,520
um um it's a terminal escape sequence

02:57:59,840 --> 02:58:03,200
that you escape first and then you

02:58:01,520 --> 02:58:06,560
specify the url

02:58:03,200 --> 02:58:07,600
you specify the description and and so

02:58:06,560 --> 02:58:09,840
on and then it's up

02:58:07,600 --> 02:58:12,080
to the terminal implementations to do

02:58:09,840 --> 02:58:15,520
the right thing to recognize them

02:58:12,080 --> 02:58:16,319
and to um well to open a web browser or

02:58:15,520 --> 02:58:19,040
whatever

02:58:16,319 --> 02:58:21,600
now based on this in one of the rabbit

02:58:19,040 --> 02:58:26,080
heart meetings that we have sometimes

02:58:21,600 --> 02:58:29,359
um we basically um added support to pog

02:58:26,080 --> 02:58:31,920
to use the hyperlink support to uh

02:58:29,359 --> 02:58:32,800
establish a communication with the user

02:58:31,920 --> 02:58:36,800
through links

02:58:32,800 --> 02:58:39,040
on the terminal how does this work

02:58:36,800 --> 02:58:39,040
so

02:58:40,399 --> 02:58:47,840
now we have poke running here let me

02:58:43,439 --> 02:58:47,840
quickly quick share again

02:58:53,120 --> 02:58:56,880
there are we support for now two

02:58:54,720 --> 02:58:59,520
different kind of terminal hyperlinks

02:58:56,880 --> 02:59:00,399
in pog two kind of command the insert

02:58:59,520 --> 02:59:04,160
command

02:59:00,399 --> 02:59:05,760
and an edit command um

02:59:04,160 --> 02:59:07,840
you know input you can have different

02:59:05,760 --> 02:59:11,760
files like for example you can open

02:59:07,840 --> 02:59:11,760
the file full and let's open

02:59:12,240 --> 02:59:16,399
my apc password file because why not

02:59:17,200 --> 02:59:21,520
oh and at this point

02:59:22,080 --> 02:59:27,520
as you can see here at this point we

02:59:25,200 --> 02:59:30,240
have i have three different idea

02:59:27,520 --> 02:59:32,800
open in poke the atc password file the

02:59:30,240 --> 02:59:35,920
4.0 file and then a memory iospace

02:59:32,800 --> 02:59:37,120
called full and look that those are

02:59:35,920 --> 02:59:41,200
links

02:59:37,120 --> 02:59:43,200
right so in book in order to switch to a

02:59:41,200 --> 02:59:46,160
different uh your space you use the

02:59:43,200 --> 02:59:47,680
ios command and then in this case if i

02:59:46,160 --> 02:59:49,279
wanted to switch to the file full

02:59:47,680 --> 02:59:50,800
though i would write something like this

02:59:49,279 --> 02:59:53,359
not ios

02:59:50,800 --> 02:59:54,960
one one is the id of the space and then

02:59:53,359 --> 02:59:57,520
it tells me that the new

02:59:54,960 --> 02:59:59,120
the car entire space is this new one but

02:59:57,520 --> 03:00:02,880
using the hyperlinks

02:59:59,120 --> 03:00:05,920
you can just click on those

03:00:02,880 --> 03:00:08,479
names in this case so for example now

03:00:05,920 --> 03:00:11,760
the current file is ctc password

03:00:08,479 --> 03:00:12,720
now it is full of and now it is the

03:00:11,760 --> 03:00:15,840
buffer

03:00:12,720 --> 03:00:16,720
it is the memory i use for so this is an

03:00:15,840 --> 03:00:19,600
example

03:00:16,720 --> 03:00:19,600
of an edit

03:00:19,760 --> 03:00:23,600
an execute command if you look at the

03:00:22,800 --> 03:00:25,760
url

03:00:23,600 --> 03:00:27,600
well that's that's too small for us to

03:00:25,760 --> 03:00:29,279
see but i think it's in this slide

03:00:27,600 --> 03:00:32,479
you will see that basically it is

03:00:29,279 --> 03:00:35,359
communicating with poc using

03:00:32,479 --> 03:00:37,040
a socket a tcpap socket using a protocol

03:00:35,359 --> 03:00:38,560
that we designed in this meeting that we

03:00:37,040 --> 03:00:40,560
refer before

03:00:38,560 --> 03:00:42,240
but you also have other kind of

03:00:40,560 --> 03:00:43,200
hyperlinks in pub which is that they

03:00:42,240 --> 03:00:45,439
insert ones

03:00:43,200 --> 03:00:46,960
so for example you can see you can say

03:00:45,439 --> 03:00:50,240
two plus

03:00:46,960 --> 03:00:52,720
and then you select uh in this case this

03:00:50,240 --> 03:00:56,560
size this offset here

03:00:52,720 --> 03:00:58,080
and then you see it inserts it in the

03:00:56,560 --> 03:01:00,160
in the prompt and it's done the right

03:00:58,080 --> 03:01:01,520
way so for example if in between when

03:01:00,160 --> 03:01:02,560
you have something in the prompt in the

03:01:01,520 --> 03:01:05,760
right lane buffer

03:01:02,560 --> 03:01:07,520
you select you execute any of the other

03:01:05,760 --> 03:01:10,720
commands you don't lose your input

03:01:07,520 --> 03:01:15,040
in the prompt so

03:01:10,720 --> 03:01:18,080
now well yeah of course

03:01:15,040 --> 03:01:20,560
i should add two different offices so

03:01:18,080 --> 03:01:22,479
those are the hyperlinks um

03:01:20,560 --> 03:01:23,760
we are sort of excited about them

03:01:22,479 --> 03:01:25,439
because

03:01:23,760 --> 03:01:26,960
we really think that this this they

03:01:25,439 --> 03:01:29,279
could be used you know to

03:01:26,960 --> 03:01:30,880
actually bring the the command line to

03:01:29,279 --> 03:01:31,359
okay i know this sounds like [ __ ]

03:01:30,880 --> 03:01:33,279
but

03:01:31,359 --> 03:01:34,880
to a different level to a new level

03:01:33,279 --> 03:01:37,920
because you don't need

03:01:34,880 --> 03:01:40,800
courses in this case to um

03:01:37,920 --> 03:01:42,160
to achieve interaction right you know

03:01:40,800 --> 03:01:44,000
that kind of interaction so

03:01:42,160 --> 03:01:45,600
you print you can print your buttons you

03:01:44,000 --> 03:01:46,640
can print your menus and you can print

03:01:45,600 --> 03:01:48,800
your stuff actually

03:01:46,640 --> 03:01:49,840
you look at the slide i am considering

03:01:48,800 --> 03:01:52,240
adding here

03:01:49,840 --> 03:01:53,439
a sort of a toolbar that will be

03:01:52,240 --> 03:01:56,160
displayed

03:01:53,439 --> 03:01:56,880
on top of the prompt and also the user

03:01:56,160 --> 03:01:58,640
can

03:01:56,880 --> 03:02:00,720
will be able to customize it and to

03:01:58,640 --> 03:02:02,640
associate book functions and commands

03:02:00,720 --> 03:02:05,920
written in poke

03:02:02,640 --> 03:02:06,560
to those patterns basically i think this

03:02:05,920 --> 03:02:10,000
is

03:02:06,560 --> 03:02:11,920
worth the looking forward

03:02:10,000 --> 03:02:13,840
also for the other new tools i'm

03:02:11,920 --> 03:02:17,120
thinking maybe particularly in edb

03:02:13,840 --> 03:02:19,040
i think that would be a good context um

03:02:17,120 --> 03:02:21,359
so those are the hyperlinks exciting

03:02:19,040 --> 03:02:21,359
things

03:02:22,000 --> 03:02:25,680
what else is neo union types union types

03:02:24,720 --> 03:02:27,600
now work

03:02:25,680 --> 03:02:30,800
last seven months ago they were not

03:02:27,600 --> 03:02:33,120
working yet now they work um

03:02:30,800 --> 03:02:34,880
well you know in pog unions are the way

03:02:33,120 --> 03:02:35,760
i'm gonna get into that because we have

03:02:34,880 --> 03:02:39,040
no time

03:02:35,760 --> 03:02:42,560
um are the way to basically um

03:02:39,040 --> 03:02:43,840
um conditionally the code is stuff right

03:02:42,560 --> 03:02:46,240
they could look like a bit

03:02:43,840 --> 03:02:47,840
counter-intuitive at first but

03:02:46,240 --> 03:02:49,840
when you get to use to them they are

03:02:47,840 --> 03:02:51,840
nice right yeah

03:02:49,840 --> 03:02:53,200
they are based on constraints of fields

03:02:51,840 --> 03:02:55,439
i refer you to the

03:02:53,200 --> 03:02:56,640
talk from last year you know to formal

03:02:55,439 --> 03:03:00,000
information about how

03:02:56,640 --> 03:03:02,800
units work what else is new

03:03:00,000 --> 03:03:04,240
and exciting oh initial values first for

03:03:02,800 --> 03:03:07,359
extract fields

03:03:04,240 --> 03:03:11,520
um basically when you define extract

03:03:07,359 --> 03:03:15,600
type you can use constraints

03:03:11,520 --> 03:03:15,600
right so for example

03:03:18,160 --> 03:03:20,880
sharing again

03:03:21,279 --> 03:03:24,720
for example you could say okay

03:03:25,680 --> 03:03:29,120
in my pocket the stupid silly usual

03:03:28,399 --> 03:03:32,560
example

03:03:29,120 --> 03:03:34,479
that is one integer and then long

03:03:32,560 --> 03:03:36,640
um basically there is a restriction

03:03:34,479 --> 03:03:37,359
which is that the integer it should be

03:03:36,640 --> 03:03:39,920
bigger

03:03:37,359 --> 03:03:41,120
than the long well this doesn't make any

03:03:39,920 --> 03:03:43,920
sense okay let's

03:03:41,120 --> 03:03:45,600
let's make it that it's uh no it's not

03:03:43,920 --> 03:03:47,120
you cannot do that because long island

03:03:45,600 --> 03:03:47,520
okay let's do the other way that the

03:03:47,120 --> 03:03:50,720
long

03:03:47,520 --> 03:03:51,120
it should be bigger than um the previous

03:03:50,720 --> 03:03:54,800
field

03:03:51,120 --> 03:03:57,279
that the integer right okay um

03:03:54,800 --> 03:03:58,240
you specify constraints like this like

03:03:57,279 --> 03:04:01,279
with a colon

03:03:58,240 --> 03:04:05,040
and then an expression so

03:04:01,279 --> 03:04:09,120
um um but but sometimes well

03:04:05,040 --> 03:04:12,240
how is this used well if you try

03:04:09,120 --> 03:04:15,200
hey let's i don't know

03:04:12,240 --> 03:04:16,800
are we going to be lucky no well yeah of

03:04:15,200 --> 03:04:18,720
course this is a very silly

03:04:16,800 --> 03:04:21,359
well imagine that this would this will

03:04:18,720 --> 03:04:23,840
not be the case let's do it

03:04:21,359 --> 03:04:23,840
for example

03:04:29,920 --> 03:04:38,800
no i use two

03:04:36,399 --> 03:04:40,479
yeah this is all zeros so if we try to

03:04:38,800 --> 03:04:42,399
pack this packet here

03:04:40,479 --> 03:04:44,319
yeah now that we do then we get the

03:04:42,399 --> 03:04:47,840
constant violation exception

03:04:44,319 --> 03:04:50,000
but sometimes the default value

03:04:47,840 --> 03:04:51,200
sorry sometimes the constraint can be

03:04:50,000 --> 03:04:52,800
used also to specify

03:04:51,200 --> 03:04:54,640
what will be the default value for that

03:04:52,800 --> 03:04:56,560
field because we will see later that we

03:04:54,640 --> 03:04:59,359
support test constructors now

03:04:56,560 --> 03:05:00,800
so when you want to do that in order to

03:04:59,359 --> 03:05:05,840
do that

03:05:00,800 --> 03:05:05,840
basically you can use this syntax

03:05:06,640 --> 03:05:12,160
along l equal to i in this case for

03:05:09,760 --> 03:05:12,160
example

03:05:13,040 --> 03:05:16,800
it's not exactly equivalent to the one

03:05:14,640 --> 03:05:20,880
before but

03:05:16,800 --> 03:05:20,880
okay let's define packet number two

03:05:21,200 --> 03:05:23,520
um

03:05:25,920 --> 03:05:31,040
the constraint is the same but i mean

03:05:29,520 --> 03:05:32,240
this is the equivalence of having the

03:05:31,040 --> 03:05:35,600
constraint and also

03:05:32,240 --> 03:05:37,840
when you construct a packet it basically

03:05:35,600 --> 03:05:39,520
will use it will use it to build you

03:05:37,840 --> 03:05:40,560
know default value of the field this is

03:05:39,520 --> 03:05:43,439
it

03:05:40,560 --> 03:05:45,680
i'm sorry if it's not very clear but we

03:05:43,439 --> 03:05:48,960
have no time

03:05:45,680 --> 03:05:50,080
this is useful for example uh to define

03:05:48,960 --> 03:05:53,120
magic numbers

03:05:50,080 --> 03:05:56,399
and creating new new new data

03:05:53,120 --> 03:05:58,479
now we support optional fields

03:05:56,399 --> 03:06:00,880
as you can see here this is an excerpt

03:05:58,479 --> 03:06:03,120
of the l64 file if you are familiar with

03:06:00,880 --> 03:06:04,160
l files i guess that most of you are you

03:06:03,120 --> 03:06:08,880
you know that

03:06:04,160 --> 03:06:11,279
another file can contain sections or and

03:06:08,880 --> 03:06:13,279
program here segments right sections and

03:06:11,279 --> 03:06:15,760
segments

03:06:13,279 --> 03:06:17,279
how many sections and how many segments

03:06:15,760 --> 03:06:19,040
you have in the file

03:06:17,279 --> 03:06:20,800
this comes from information which is

03:06:19,040 --> 03:06:23,439
stored in the header

03:06:20,800 --> 03:06:23,920
right in this case this is its name and

03:06:23,439 --> 03:06:25,760
a

03:06:23,920 --> 03:06:26,960
ph number for sections and segments

03:06:25,760 --> 03:06:30,080
respectively

03:06:26,960 --> 03:06:31,760
also if there are no segments for

03:06:30,080 --> 03:06:35,120
example

03:06:31,760 --> 03:06:35,920
there is no param header table so this

03:06:35,120 --> 03:06:38,560
is how you express

03:06:35,920 --> 03:06:40,000
this in poke you right at the end of the

03:06:38,560 --> 03:06:43,760
field definition if

03:06:40,000 --> 03:06:45,680
whatever um whatever expression

03:06:43,760 --> 03:06:46,880
i will show it but to you in the demo

03:06:45,680 --> 03:06:49,359
but

03:06:46,880 --> 03:06:50,560
we have no time so basically this means

03:06:49,359 --> 03:06:52,720
that some of the fields

03:06:50,560 --> 03:06:56,399
in the australian may be absent and pog

03:06:52,720 --> 03:07:02,319
does the right thing basically

03:06:56,399 --> 03:07:02,319
what else is new well extra constructors

03:07:07,840 --> 03:07:11,279
up to now we have been working with

03:07:09,200 --> 03:07:13,359
extract values that we have mapped

03:07:11,279 --> 03:07:15,200
you know in a file or whatever are your

03:07:13,359 --> 03:07:18,399
space right

03:07:15,200 --> 03:07:19,279
but okay let me go back to the secondary

03:07:18,399 --> 03:07:22,479
example

03:07:19,279 --> 03:07:24,240
let's type packet i'm not the third guy

03:07:22,479 --> 03:07:27,359
that's boring

03:07:24,240 --> 03:07:30,080
elf for example so for example an 64

03:07:27,359 --> 03:07:31,600
heater okay we map it at some offset in

03:07:30,080 --> 03:07:34,640
the audio space

03:07:31,600 --> 03:07:37,040
now poke is able to actually create

03:07:34,640 --> 03:07:38,160
new extract values which are not mapped

03:07:37,040 --> 03:07:41,920
in an iospace

03:07:38,160 --> 03:07:44,479
to construct them so basically

03:07:41,920 --> 03:07:45,200
this is this is how you will construct a

03:07:44,479 --> 03:07:47,359
new

03:07:45,200 --> 03:07:48,800
fresh elf heater that is not mapped in

03:07:47,359 --> 03:07:52,880
the iospace

03:07:48,800 --> 03:07:56,080
with this syntax now when you

03:07:52,880 --> 03:07:56,880
create a new structure then you can

03:07:56,080 --> 03:07:58,720
specify

03:07:56,880 --> 03:08:00,800
initial values for fields right for

03:07:58,720 --> 03:08:04,319
example the e type

03:08:00,800 --> 03:08:04,319
for this is going to be 12.

03:08:05,120 --> 03:08:11,840
and the e type is zero c right

03:08:08,319 --> 03:08:15,760
so it works when you construct

03:08:11,840 --> 03:08:18,399
extract uh using a constructor basically

03:08:15,760 --> 03:08:20,080
the same i mean the process is very very

03:08:18,399 --> 03:08:22,560
similar to what happens when you

03:08:20,080 --> 03:08:24,479
map a struct and in particular that is

03:08:22,560 --> 03:08:24,960
the data integrity that you define in

03:08:24,479 --> 03:08:28,000
your

03:08:24,960 --> 03:08:31,439
in your in your prototype it applies

03:08:28,000 --> 03:08:35,920
to so for example if we try

03:08:31,439 --> 03:08:39,279
to create an l64

03:08:35,920 --> 03:08:40,720
okay let's use because otherwise it's

03:08:39,279 --> 03:08:44,319
gonna be

03:08:40,720 --> 03:08:49,840
complex for example we define our packet

03:08:44,319 --> 03:08:49,840
and i should be bigger than 10.

03:08:50,399 --> 03:08:56,479
so if we create a new packet using

03:08:54,319 --> 03:08:58,240
the simple constructor it fails why

03:08:56,479 --> 03:09:00,319
because when you use a constructor and

03:08:58,240 --> 03:09:02,800
you don't specify an initial value

03:09:00,319 --> 03:09:04,399
then it uses zero in a smart way you

03:09:02,800 --> 03:09:05,600
know depending if it's an array this is

03:09:04,399 --> 03:09:08,399
an array of zeros

03:09:05,600 --> 03:09:09,520
and so on and in this case 0 is not

03:09:08,399 --> 03:09:12,560
bigger than 10

03:09:09,520 --> 03:09:14,800
so the constructor sorry the the

03:09:12,560 --> 03:09:17,359
the constraint expression is failing so

03:09:14,800 --> 03:09:20,399
we get the constant violation exception

03:09:17,359 --> 03:09:23,920
what can we do well we can provide

03:09:20,399 --> 03:09:26,080
an initial value for uh that field

03:09:23,920 --> 03:09:28,000
so now we are creating a packet in which

03:09:26,080 --> 03:09:30,080
i is bigger than 10

03:09:28,000 --> 03:09:32,080
so the constant by the constraint is not

03:09:30,080 --> 03:09:34,479
failing now

03:09:32,080 --> 03:09:36,080
so those are construction constructors

03:09:34,479 --> 03:09:37,439
it happens that for example exceptions

03:09:36,080 --> 03:09:41,120
are now implemented in poke

03:09:37,439 --> 03:09:43,120
as as as extracts

03:09:41,120 --> 03:09:45,840
and when you want to rise in poke an

03:09:43,120 --> 03:09:45,840
exception

03:09:47,359 --> 03:09:52,399
well you basically do it with something

03:09:49,600 --> 03:09:52,399
similar to this

03:09:53,040 --> 03:09:59,840
those that is for extract constructors

03:10:00,239 --> 03:10:05,200
what else is new now it is possible to

03:10:03,120 --> 03:10:08,399
define

03:10:05,200 --> 03:10:11,359
types variables and functions

03:10:08,399 --> 03:10:12,640
so to have definitions inside extract

03:10:11,359 --> 03:10:14,479
types

03:10:12,640 --> 03:10:16,800
and they live in their own lexical scope

03:10:14,479 --> 03:10:19,200
of course

03:10:16,800 --> 03:10:20,319
so for example consider this example

03:10:19,200 --> 03:10:23,359
this is a packet

03:10:20,319 --> 03:10:24,640
that has a magic number which is the

03:10:23,359 --> 03:10:26,560
first byte which

03:10:24,640 --> 03:10:27,680
here you see one of the initial values

03:10:26,560 --> 03:10:29,200
we were talking before

03:10:27,680 --> 03:10:31,680
then it has another byte which is the

03:10:29,200 --> 03:10:33,439
size of the packet

03:10:31,680 --> 03:10:35,680
but it's not really the size of the

03:10:33,439 --> 03:10:38,000
packet you see i mean it's not sorry

03:10:35,680 --> 03:10:39,840
it's not really the size of the data it

03:10:38,000 --> 03:10:41,760
is some encoding of the size of the data

03:10:39,840 --> 03:10:42,319
and in this case it happens that if the

03:10:41,760 --> 03:10:45,760
size

03:10:42,319 --> 03:10:48,000
is ff then it is

03:10:45,760 --> 03:10:48,880
to be considered as zero so there are

03:10:48,000 --> 03:10:50,399
two ways of

03:10:48,880 --> 03:10:52,560
basically expressing zero in this

03:10:50,399 --> 03:10:55,200
encoding for the size

03:10:52,560 --> 03:10:56,800
so then we have an array of the payload

03:10:55,200 --> 03:10:59,600
which is a data and then an array of

03:10:56,800 --> 03:11:02,720
control which are crc's or whatever

03:10:59,600 --> 03:11:05,680
but how big are those arrays

03:11:02,720 --> 03:11:07,279
well we cannot use size directly because

03:11:05,680 --> 03:11:08,479
we have to do this conversion of the

03:11:07,279 --> 03:11:10,880
encoding here

03:11:08,479 --> 03:11:12,960
so in order to avoid writing this

03:11:10,880 --> 03:11:15,040
expression twice in this case

03:11:12,960 --> 03:11:16,880
well we can define a variable here with

03:11:15,040 --> 03:11:19,920
the real size and use it

03:11:16,880 --> 03:11:19,920
which is convenient

03:11:21,359 --> 03:11:27,040
you also can embed things like functions

03:11:24,880 --> 03:11:28,479
inside the inside tags like for example

03:11:27,040 --> 03:11:30,560
in this case

03:11:28,479 --> 03:11:31,600
there is a library function in this

03:11:30,560 --> 03:11:35,040
let's imagine

03:11:31,600 --> 03:11:36,880
called calculate c or c um but this

03:11:35,040 --> 03:11:37,600
function is implemented in a way in some

03:11:36,880 --> 03:11:41,040
pickle

03:11:37,600 --> 03:11:44,319
in a way that it can result

03:11:41,040 --> 03:11:47,279
in a division by zero but

03:11:44,319 --> 03:11:49,359
for the initial value of this of this

03:11:47,279 --> 03:11:51,200
field in this in this struct type

03:11:49,359 --> 03:11:52,960
we don't want that what we want is that

03:11:51,200 --> 03:11:55,680
if there is a division by zero in

03:11:52,960 --> 03:11:56,479
the internal calculate crc function we

03:11:55,680 --> 03:11:58,640
want the value

03:11:56,479 --> 03:12:00,160
this to contain zero and this is how we

03:11:58,640 --> 03:12:02,800
can do it

03:12:00,160 --> 03:12:03,840
as well we could have used the f bar

03:12:02,800 --> 03:12:05,040
here as well but

03:12:03,840 --> 03:12:06,800
because the function doesn't get any

03:12:05,040 --> 03:12:08,160
argument but this was just for purpose

03:12:06,800 --> 03:12:11,279
of showing it

03:12:08,160 --> 03:12:14,960
so this is useful

03:12:11,279 --> 03:12:15,600
um but you we cannot it's not only that

03:12:14,960 --> 03:12:18,000
we can

03:12:15,600 --> 03:12:18,880
embed like that like variable

03:12:18,000 --> 03:12:20,720
definitions

03:12:18,880 --> 03:12:23,200
and function definitions we can also

03:12:20,720 --> 03:12:26,319
embed another type definitions

03:12:23,200 --> 03:12:28,640
so this is a classical well classical

03:12:26,319 --> 03:12:29,520
yeah this is new but it's classical

03:12:28,640 --> 03:12:31,600
already

03:12:29,520 --> 03:12:34,399
this is the classical example here so

03:12:31,600 --> 03:12:36,720
this is a btf type

03:12:34,399 --> 03:12:38,319
which you have a name here you have some

03:12:36,720 --> 03:12:41,120
information here

03:12:38,319 --> 03:12:43,040
and then you have the data which is a

03:12:41,120 --> 03:12:44,399
specific tool depending on the type of

03:12:43,040 --> 03:12:45,760
the kind of the type that it is

03:12:44,399 --> 03:12:49,279
describing

03:12:45,760 --> 03:12:51,279
so then you have a btf integer array

03:12:49,279 --> 03:12:52,000
enumeration function prototype variable

03:12:51,279 --> 03:12:56,640
member

03:12:52,000 --> 03:13:00,399
and so on in this case

03:12:56,640 --> 03:13:02,239
the btf function protocol you know

03:13:00,399 --> 03:13:04,399
which is one of the options here in this

03:13:02,239 --> 03:13:07,200
union uh the definitions

03:13:04,399 --> 03:13:08,399
the definition of the parameters is

03:13:07,200 --> 03:13:09,840
obtained

03:13:08,399 --> 03:13:12,239
the number of parameters for this

03:13:09,840 --> 03:13:15,279
function prototype you get it from

03:13:12,239 --> 03:13:18,640
info which is a field that comes before

03:13:15,279 --> 03:13:20,080
in the extract type so we are generating

03:13:18,640 --> 03:13:22,640
we are defining this type

03:13:20,080 --> 03:13:23,680
here embedded here so we can use it

03:13:22,640 --> 03:13:25,760
below

03:13:23,680 --> 03:13:27,840
and this is this has access to the

03:13:25,760 --> 03:13:29,920
lexical environment

03:13:27,840 --> 03:13:33,520
of the previous field when you map or

03:13:29,920 --> 03:13:37,120
construct an extract of this type

03:13:33,520 --> 03:13:38,800
this is gonna be not that useful in

03:13:37,120 --> 03:13:40,720
because we are going to implement

03:13:38,800 --> 03:13:43,359
passing arguments to the

03:13:40,720 --> 03:13:45,120
to the types very soon but it's still

03:13:43,359 --> 03:13:47,840
handy

03:13:45,120 --> 03:13:49,680
so yeah you can embed tapes in other

03:13:47,840 --> 03:13:53,359
types

03:13:49,680 --> 03:13:56,640
what is new methods now we have proper

03:13:53,359 --> 03:13:57,359
working methods in instructs the methods

03:13:56,640 --> 03:13:59,359
are

03:13:57,359 --> 03:14:00,960
well i mean we need it we totally need

03:13:59,359 --> 03:14:02,560
them basically

03:14:00,960 --> 03:14:04,080
they are not functions they are like

03:14:02,560 --> 03:14:05,120
functions they totally look like

03:14:04,080 --> 03:14:07,840
functions actually

03:14:05,120 --> 03:14:08,880
but they are methods um the methods are

03:14:07,840 --> 03:14:11,680
defined in two

03:14:08,880 --> 03:14:12,720
in the types and for example those are

03:14:11,680 --> 03:14:15,040
two functions which are

03:14:12,720 --> 03:14:16,640
from the elf picker right and you can

03:14:15,040 --> 03:14:19,520
see how they are used

03:14:16,640 --> 03:14:20,800
to uh to do different things in this

03:14:19,520 --> 03:14:23,120
case this get a string

03:14:20,800 --> 03:14:24,560
it uses it locates the string table in

03:14:23,120 --> 03:14:26,080
the elf file

03:14:24,560 --> 03:14:27,600
and then it uses the offset that you

03:14:26,080 --> 03:14:29,279
pass along with

03:14:27,600 --> 03:14:30,640
the information from the section header

03:14:29,279 --> 03:14:33,439
table to give you

03:14:30,640 --> 03:14:34,479
an ascii a new terminated rescue string

03:14:33,439 --> 03:14:38,080
given its offset

03:14:34,479 --> 03:14:40,319
in the string table of the file um

03:14:38,080 --> 03:14:41,680
the methods they get an implicit first

03:14:40,319 --> 03:14:44,239
argument which obviously

03:14:41,680 --> 03:14:45,279
is the extract the value the struct

03:14:44,239 --> 03:14:47,760
value

03:14:45,279 --> 03:14:48,479
on which it is operating note that

03:14:47,760 --> 03:14:51,200
inside

03:14:48,479 --> 03:14:52,319
you can actually refer to the fields

03:14:51,200 --> 03:14:54,720
which are defined above

03:14:52,319 --> 03:14:55,920
without having to write a self dot or

03:14:54,720 --> 03:14:57,520
anything like that

03:14:55,920 --> 03:14:59,920
the compiler is smart enough to do the

03:14:57,520 --> 03:14:59,920
right thing

03:15:04,479 --> 03:15:08,960
and now that we have methods now we have

03:15:07,359 --> 03:15:13,040
pretty printers

03:15:08,960 --> 03:15:14,640
which are super nice um basically

03:15:13,040 --> 03:15:16,720
when it comes to binary data like this

03:15:14,640 --> 03:15:19,120
with this kind of stuff

03:15:16,720 --> 03:15:20,960
more often than not the stored

03:15:19,120 --> 03:15:22,239
representation of the data is not the

03:15:20,960 --> 03:15:25,200
most

03:15:22,239 --> 03:15:26,880
interesting one or the readable one so

03:15:25,200 --> 03:15:29,120
it often happens that we are interested

03:15:26,880 --> 03:15:32,960
in something very particular

03:15:29,120 --> 03:15:33,439
and but and for that we are interested

03:15:32,960 --> 03:15:35,840
in

03:15:33,439 --> 03:15:36,720
we want as much detail as possible like

03:15:35,840 --> 03:15:39,840
if we want to

03:15:36,720 --> 03:15:40,720
to to mess with um i don't know with the

03:15:39,840 --> 03:15:43,760
dwarf

03:15:40,720 --> 03:15:46,800
expressions in some the back

03:15:43,760 --> 03:15:48,319
section in a nail file and we want

03:15:46,800 --> 03:15:50,560
we want to be able to manipulate the

03:15:48,319 --> 03:15:52,800
dwarf stuff in a very detailed way

03:15:50,560 --> 03:15:54,880
but everything else is something that we

03:15:52,800 --> 03:15:58,720
want to have like in a readable way

03:15:54,880 --> 03:16:02,880
right more than the little bits of it

03:15:58,720 --> 03:16:07,520
so the pretty printers they provide

03:16:02,880 --> 03:16:07,520
a way to do this so let's see an example

03:16:10,560 --> 03:16:20,640
yeah so

03:16:17,200 --> 03:16:24,560
oh we are in our alpha

03:16:20,640 --> 03:16:24,560
elf file again

03:16:24,800 --> 03:16:27,120
and

03:16:28,800 --> 03:16:32,239
let's get the text section again

03:16:33,520 --> 03:16:41,359
get section by name next

03:16:37,520 --> 03:16:44,160
let's get the bpf okay load ppf

03:16:41,359 --> 03:16:44,960
let's get the pdf instructions array

03:16:44,160 --> 03:16:48,080
again

03:16:44,960 --> 03:16:52,000
text the search size

03:16:48,080 --> 03:16:55,439
add text message offset

03:16:52,000 --> 03:16:58,640
say instructions so

03:16:55,439 --> 03:17:02,239
we have okay let me

03:16:58,640 --> 03:17:03,920
put the output base to decimal

03:17:02,239 --> 03:17:05,600
we have nine instructions on the bpf

03:17:03,920 --> 03:17:08,000
instructions let's take a look to the

03:17:05,600 --> 03:17:08,000
first one

03:17:08,319 --> 03:17:13,920
there you go so um

03:17:11,760 --> 03:17:16,000
well basically there you can be the pre

03:17:13,920 --> 03:17:18,479
you can see the pretty pretty printers

03:17:16,000 --> 03:17:19,279
if you see everything that is printed

03:17:18,479 --> 03:17:22,319
between

03:17:19,279 --> 03:17:26,720
um dash less than

03:17:22,319 --> 03:17:29,439
and bigger than is pretty printed

03:17:26,720 --> 03:17:31,200
it's by convention this this notation is

03:17:29,439 --> 03:17:32,880
by convention and i am abusing the the

03:17:31,200 --> 03:17:34,319
least traditional way of

03:17:32,880 --> 03:17:35,760
notating things that don't have a

03:17:34,319 --> 03:17:37,200
textual representation right like

03:17:35,760 --> 03:17:39,439
closures and everything

03:17:37,200 --> 03:17:41,040
and they like um so in this case for

03:17:39,439 --> 03:17:43,200
example there is something here which is

03:17:41,040 --> 03:17:45,120
a bpf instruction of code

03:17:43,200 --> 03:17:46,800
that it happens to be an lddw

03:17:45,120 --> 03:17:49,520
instruction

03:17:46,800 --> 03:17:52,080
uh but obviously this is not what it is

03:17:49,520 --> 03:17:55,200
stored right like in the binary file

03:17:52,080 --> 03:17:56,640
but it is pretty printed so let's see

03:17:55,200 --> 03:17:59,520
let's take a look to the pretty printer

03:17:56,640 --> 03:17:59,520
responsible of this

03:17:59,840 --> 03:18:04,000
if we go to the pickles collection we go

03:18:03,120 --> 03:18:07,359
to the ppf

03:18:04,000 --> 03:18:12,880
file and when we look for

03:18:07,359 --> 03:18:12,880
this was a hop quotes right

03:18:13,520 --> 03:18:17,680
yeah there you go

03:18:18,399 --> 03:18:23,760
so basically if you look at this

03:18:20,880 --> 03:18:25,680
definition here

03:18:23,760 --> 03:18:27,200
it's an anonymous struct which is part

03:18:25,680 --> 03:18:30,720
of the bpf instruction

03:18:27,200 --> 03:18:32,800
and basically what is this is a union of

03:18:30,720 --> 03:18:34,479
uh the with the opcodes because there

03:18:32,800 --> 03:18:35,840
are two kind of ppf instructions

03:18:34,479 --> 03:18:38,319
basically

03:18:35,840 --> 03:18:39,120
some of them oh no i'm looking at the

03:18:38,319 --> 03:18:43,760
wrong place

03:18:39,120 --> 03:18:43,760
this is for the immediate the up calls

03:18:45,359 --> 03:18:51,840
this is the definition for the of course

03:18:49,120 --> 03:18:54,399
okay well anyway it is a union anyway

03:18:51,840 --> 03:18:57,040
because they'll put they'll it can be an

03:18:54,399 --> 03:18:57,920
arithmetical logical unit jump

03:18:57,040 --> 03:19:00,800
instruction

03:18:57,920 --> 03:19:01,279
in which it uses those three outputs

03:19:00,800 --> 03:19:04,479
here

03:19:01,279 --> 03:19:06,239
or three fields or it can be

03:19:04,479 --> 03:19:08,000
a load store instruction which is a

03:19:06,239 --> 03:19:09,840
different class of instructions

03:19:08,000 --> 03:19:13,040
in which case it has a model size and a

03:19:09,840 --> 03:19:14,399
class the other one has a code a source

03:19:13,040 --> 03:19:15,840
and a class and also there is a

03:19:14,399 --> 03:19:17,520
constraint here to make sure the

03:19:15,840 --> 03:19:20,880
instruction is correct and everything

03:19:17,520 --> 03:19:23,439
and look at the pretty printer basically

03:19:20,880 --> 03:19:24,960
the pretty printer is if first it prints

03:19:23,439 --> 03:19:26,239
is a method with a special name

03:19:24,960 --> 03:19:28,720
underscore print

03:19:26,239 --> 03:19:30,080
and then first it prints well the

03:19:28,720 --> 03:19:32,000
convention that we have been talking

03:19:30,080 --> 03:19:34,560
about and then it does the right thing

03:19:32,000 --> 03:19:36,399
note by the way how it is using a

03:19:34,560 --> 03:19:38,720
styling class which is called in

03:19:36,399 --> 03:19:40,080
instruction mnemonic that we have in our

03:19:38,720 --> 03:19:43,040
css file

03:19:40,080 --> 03:19:44,720
so if other pixels or import wants to

03:19:43,040 --> 03:19:46,399
print instruction mnemonics

03:19:44,720 --> 03:19:48,319
like if we make a disassembler

03:19:46,399 --> 03:19:50,160
infrastructure then

03:19:48,319 --> 03:19:51,439
every all the metemonics will be printed

03:19:50,160 --> 03:19:56,560
and styled in

03:19:51,439 --> 03:19:56,560
in the same way so those are pretty

03:19:58,840 --> 03:20:03,279
printers

03:20:00,399 --> 03:20:03,279
what else is new

03:20:04,080 --> 03:20:08,399
okay this is more about more on pretty

03:20:05,920 --> 03:20:10,640
printers oh here you can see

03:20:08,399 --> 03:20:12,000
how there is an option in book which is

03:20:10,640 --> 03:20:14,560
the pretty print option

03:20:12,000 --> 03:20:16,560
but if you set it to yes you get

03:20:14,560 --> 03:20:18,880
everything pretty printed

03:20:16,560 --> 03:20:20,479
if you set it to no then you don't get

03:20:18,880 --> 03:20:22,800
it's pretty printed so you see

03:20:20,479 --> 03:20:25,680
here you can see that the op code now

03:20:22,800 --> 03:20:30,560
you can see all the gory details of it

03:20:25,680 --> 03:20:32,720
right okay first fast

03:20:30,560 --> 03:20:34,640
okay well now we support memory ios

03:20:32,720 --> 03:20:37,920
spaces that basically you can create

03:20:34,640 --> 03:20:41,840
on the flight ship fast um

03:20:37,920 --> 03:20:43,439
um hydrospaces you know for like

03:20:41,840 --> 03:20:47,279
temporal stuff i will

03:20:43,439 --> 03:20:50,399
maybe later show something about that um

03:20:47,279 --> 03:20:51,439
eric blake contributed um an io space

03:20:50,399 --> 03:20:55,200
handler

03:20:51,439 --> 03:20:57,439
uh back end for this network block

03:20:55,200 --> 03:20:58,399
device well i don't know is this this

03:20:57,439 --> 03:21:01,520
way of

03:20:58,399 --> 03:21:02,560
of of basically exporting a disk over

03:21:01,520 --> 03:21:05,600
the internet

03:21:02,560 --> 03:21:09,359
and in book now you can basically use uh

03:21:05,600 --> 03:21:10,640
things like this to edit directly to

03:21:09,359 --> 03:21:13,600
poke directly

03:21:10,640 --> 03:21:13,600
mbd devices

03:21:15,840 --> 03:21:19,120
okay um very fast i'm sorry that this

03:21:18,640 --> 03:21:21,279
this

03:21:19,120 --> 03:21:22,479
because this part is a bit tricky we saw

03:21:21,279 --> 03:21:25,520
before that

03:21:22,479 --> 03:21:27,439
we that box supports not only 32 bits

03:21:25,520 --> 03:21:29,920
into years or 64 or eight

03:21:27,439 --> 03:21:31,359
or eight bits or whatever but you you

03:21:29,920 --> 03:21:35,439
have like all sort of

03:21:31,359 --> 03:21:37,279
weird crazy stuff here right like 11

03:21:35,439 --> 03:21:41,439
bits integers and whatnot

03:21:37,279 --> 03:21:44,720
um so basically um

03:21:41,439 --> 03:21:46,960
so basically how is that done

03:21:44,720 --> 03:21:48,640
well underneath you have an io device

03:21:46,960 --> 03:21:49,600
which would be a file could be a memory

03:21:48,640 --> 03:21:51,680
buffer whatever

03:21:49,600 --> 03:21:52,960
but in the io device what you are doing

03:21:51,680 --> 03:21:55,200
is a sequence of bytes

03:21:52,960 --> 03:21:56,319
because we all know here that basically

03:21:55,200 --> 03:21:59,520
all this beats thing

03:21:56,319 --> 03:22:01,439
is is isn't i mean

03:21:59,520 --> 03:22:02,640
it's it's not real right i mean it may

03:22:01,439 --> 03:22:04,479
be real maybe not

03:22:02,640 --> 03:22:06,160
it's an abstraction it's a construction

03:22:04,479 --> 03:22:08,239
right because

03:22:06,160 --> 03:22:09,600
at this level in the operating system a

03:22:08,239 --> 03:22:10,319
byte is a byte it's a number it's a

03:22:09,600 --> 03:22:13,359
little number

03:22:10,319 --> 03:22:14,800
so what book does is that in top of the

03:22:13,359 --> 03:22:17,600
stream of bytes

03:22:14,800 --> 03:22:18,239
it basically abstracts up and provides a

03:22:17,600 --> 03:22:20,800
stream of

03:22:18,239 --> 03:22:21,760
bits and in top of that the stream of

03:22:20,800 --> 03:22:23,520
beats

03:22:21,760 --> 03:22:25,040
it basically provides you with the book

03:22:23,520 --> 03:22:26,560
values like in this case this assign

03:22:25,040 --> 03:22:29,520
integer of 16 bits

03:22:26,560 --> 03:22:30,640
starting at two bits now input we take

03:22:29,520 --> 03:22:32,800
it very seriously

03:22:30,640 --> 03:22:35,120
the whippy weak philosophy which is what

03:22:32,800 --> 03:22:36,560
you poke is what you get it's not like c

03:22:35,120 --> 03:22:38,399
it's not like you know well it depends

03:22:36,560 --> 03:22:40,479
what you're compiling for the physical

03:22:38,399 --> 03:22:42,640
layout will be different no in pockets

03:22:40,479 --> 03:22:43,520
it is that it's always the same given an

03:22:42,640 --> 03:22:48,239
endianness

03:22:43,520 --> 03:22:51,760
and a negative encoding basically so

03:22:48,239 --> 03:22:53,040
um so we have support for weird

03:22:51,760 --> 03:22:54,080
interiors there are two main types of

03:22:53,040 --> 03:22:56,640
wear interiors

03:22:54,080 --> 03:22:57,279
the integers that span for more than one

03:22:56,640 --> 03:23:00,479
byte

03:22:57,279 --> 03:23:03,120
but they don't fully use

03:23:00,479 --> 03:23:04,399
a part of the second byte by convention

03:23:03,120 --> 03:23:06,960
in this case

03:23:04,399 --> 03:23:07,520
um and this is how it works i'm sorry i

03:23:06,960 --> 03:23:10,960
have to

03:23:07,520 --> 03:23:13,279
run now there is no time um

03:23:10,960 --> 03:23:15,600
the other kind of weird integers is what

03:23:13,279 --> 03:23:15,840
i call quantum bitemix which is when you

03:23:15,600 --> 03:23:19,600
are

03:23:15,840 --> 03:23:22,479
using like sub byte uh integers

03:23:19,600 --> 03:23:22,800
right so for example an unsigned integer

03:23:22,479 --> 03:23:25,439
of

03:23:22,800 --> 03:23:26,080
five of five bits so this is how it

03:23:25,439 --> 03:23:28,800
works

03:23:26,080 --> 03:23:30,160
in this case obviously the ndns is not

03:23:28,800 --> 03:23:32,000
well not obviously

03:23:30,160 --> 03:23:33,840
yeah by convention the ndns is not

03:23:32,000 --> 03:23:37,520
impacting this not affecting this

03:23:33,840 --> 03:23:39,920
so um when you have an aligned

03:23:37,520 --> 03:23:42,399
integers this is what it how it happens

03:23:39,920 --> 03:23:44,239
you have the bytes you have the bits

03:23:42,399 --> 03:23:45,760
and then you construct on top of the

03:23:44,239 --> 03:23:47,840
bits mentally

03:23:45,760 --> 03:23:49,120
you construct those virtual bytes which

03:23:47,840 --> 03:23:50,560
are the ones

03:23:49,120 --> 03:23:53,760
on top of which you have the poke

03:23:50,560 --> 03:23:56,800
failures so

03:23:53,760 --> 03:23:59,120
it may look like tricky but really

03:23:56,800 --> 03:24:01,439
even i can do that i mean once you

03:23:59,120 --> 03:24:03,760
understand how the indians impacts

03:24:01,439 --> 03:24:04,640
and the two kind of weird integers

03:24:03,760 --> 03:24:06,800
basically

03:24:04,640 --> 03:24:08,720
using this model you can actually

03:24:06,800 --> 03:24:10,880
predict uh

03:24:08,720 --> 03:24:12,960
in your brain basically what would be

03:24:10,880 --> 03:24:16,960
the effect of mapping a 16 bits

03:24:12,960 --> 03:24:16,960
in the year displayed by two bits

03:24:20,080 --> 03:24:24,000
okay it's a pretty we don't have time

03:24:22,239 --> 03:24:26,000
internal extracts okay

03:24:24,000 --> 03:24:27,120
for the base case you have like a cs

03:24:26,000 --> 03:24:29,520
track like this

03:24:27,120 --> 03:24:31,120
that translates directly into a

03:24:29,520 --> 03:24:34,800
pokestart with three fields

03:24:31,120 --> 03:24:38,239
okay fine this is trivial but

03:24:34,800 --> 03:24:41,680
um sometimes composite data is encoded

03:24:38,239 --> 03:24:44,560
into data that it is self-stored as

03:24:41,680 --> 03:24:45,040
integral values like for example there

03:24:44,560 --> 03:24:48,880
was

03:24:45,040 --> 03:24:51,200
well the typical health um stuff that

03:24:48,880 --> 03:24:52,000
you all should be familiar with right in

03:24:51,200 --> 03:24:54,000
this case this

03:24:52,000 --> 03:24:55,600
this field is the system the 32 bits

03:24:54,000 --> 03:24:57,680
more significant bits

03:24:55,600 --> 03:24:58,960
and this is the least less significant

03:24:57,680 --> 03:25:01,359
field in c

03:24:58,960 --> 03:25:02,239
this is always handled like using

03:25:01,359 --> 03:25:04,000
bitmasks

03:25:02,239 --> 03:25:05,600
and using macros like this we could do

03:25:04,000 --> 03:25:07,760
the same in poke

03:25:05,600 --> 03:25:09,439
like using functions to mimic the c

03:25:07,760 --> 03:25:12,319
style but that would be

03:25:09,439 --> 03:25:13,680
ideotic to do so because then we will be

03:25:12,319 --> 03:25:16,399
using c basically

03:25:13,680 --> 03:25:18,399
so instead of that in pog you can

03:25:16,399 --> 03:25:20,399
declare you can tell poke that a given

03:25:18,399 --> 03:25:22,479
extract is an integral extract

03:25:20,399 --> 03:25:24,399
meaning that yes it has fields it has it

03:25:22,479 --> 03:25:25,920
has constraints it can have

03:25:24,399 --> 03:25:27,680
you know everything that you can have in

03:25:25,920 --> 03:25:30,080
a normal struct but

03:25:27,680 --> 03:25:31,920
when it comes to store that in disk or

03:25:30,080 --> 03:25:34,080
to pick or to poke it

03:25:31,920 --> 03:25:35,680
poke knows that this is an integral so

03:25:34,080 --> 03:25:37,439
it knows it does the right thing

03:25:35,680 --> 03:25:38,880
according to the current endings and so

03:25:37,439 --> 03:25:40,560
on also

03:25:38,880 --> 03:25:42,960
you can basically manipulate the

03:25:40,560 --> 03:25:44,560
structures internal extract values like

03:25:42,960 --> 03:25:47,040
if they were integers

03:25:44,560 --> 03:25:47,920
like using an explicit cast or

03:25:47,040 --> 03:25:51,120
automatically

03:25:47,920 --> 03:25:53,120
you know which is quite hand it's very

03:25:51,120 --> 03:25:56,160
handy

03:25:53,120 --> 03:25:58,080
okay one

03:25:56,160 --> 03:25:59,200
yeah the loading pickers is also

03:25:58,080 --> 03:26:02,960
relatively new

03:25:59,200 --> 03:26:03,359
you have seen me when i say load bpa for

03:26:02,960 --> 03:26:05,760
load

03:26:03,359 --> 03:26:07,920
elf basically it's a language level

03:26:05,760 --> 03:26:09,279
construction that loads whatever pickle

03:26:07,920 --> 03:26:12,080
is named after that there are two

03:26:09,279 --> 03:26:12,080
different variants

03:26:12,960 --> 03:26:18,479
in case it has a strange square and then

03:26:16,399 --> 03:26:20,880
what else is new pocket scripts now we

03:26:18,479 --> 03:26:21,600
can write binary utilities in poke

03:26:20,880 --> 03:26:25,359
instead of c

03:26:21,600 --> 03:26:27,840
for example so um we are using this

03:26:25,359 --> 03:26:28,880
this shivan trick is the same trick that

03:26:27,840 --> 03:26:32,000
guile uses i

03:26:28,880 --> 03:26:34,720
i basically use the same strategy there

03:26:32,000 --> 03:26:35,359
and basically you can write pokescripts

03:26:34,720 --> 03:26:38,560
that

03:26:35,359 --> 03:26:40,880
um um well they can access the

03:26:38,560 --> 03:26:42,640
the environment and everything and you

03:26:40,880 --> 03:26:46,319
can write binary utilities

03:26:42,640 --> 03:26:49,120
i want to show you one utility

03:26:46,319 --> 03:26:49,760
that they have written which is very

03:26:49,120 --> 03:26:52,000
stupid

03:26:49,760 --> 03:26:52,000
but

03:26:52,880 --> 03:26:56,000
it's an elf extractor

03:26:58,800 --> 03:27:03,920
this is it oh if you can see

03:27:02,239 --> 03:27:05,600
you can see here the alpha structure is

03:27:03,920 --> 03:27:09,040
the chi bank then the comment

03:27:05,600 --> 03:27:11,200
the license whatever then first it loads

03:27:09,040 --> 03:27:13,120
a pickle which is the health speaker

03:27:11,200 --> 03:27:15,040
right so it has access to all the

03:27:13,120 --> 03:27:16,720
definitions and everything then it

03:27:15,040 --> 03:27:19,920
checks for arguments that you pass the

03:27:16,720 --> 03:27:23,680
right number of arguments

03:27:19,920 --> 03:27:25,840
and this is it this is the code of it

03:27:23,680 --> 03:27:27,040
and it opens the file that you specify

03:27:25,840 --> 03:27:31,439
the name of it it

03:27:27,040 --> 03:27:34,960
maps an elf 64 file

03:27:31,439 --> 03:27:38,000
in in the file that you specify and then

03:27:34,960 --> 03:27:40,399
it iterates in

03:27:38,000 --> 03:27:41,040
through all the section headers then it

03:27:40,399 --> 03:27:42,800
gets

03:27:41,040 --> 03:27:44,319
look this is using the method for

03:27:42,800 --> 03:27:46,080
getting the for getting this

03:27:44,319 --> 03:27:48,319
a string from the l file that we saw

03:27:46,080 --> 03:27:49,600
before and then it compares

03:27:48,319 --> 03:27:51,760
and then it does the right thing it

03:27:49,600 --> 03:27:54,239
extracts the section matching

03:27:51,760 --> 03:27:55,760
uh the argument that you pass to the

03:27:54,239 --> 03:27:58,399
script let's see it in action

03:27:55,760 --> 03:27:58,399
very briefly

03:27:59,439 --> 03:28:06,880
here we have a food then we call here

03:28:03,600 --> 03:28:08,560
f extractor full of dough

03:28:06,880 --> 03:28:10,800
and if we don't pass a second argument

03:28:08,560 --> 03:28:13,279
it will extract all the sections

03:28:10,800 --> 03:28:13,279
in the file

03:28:15,040 --> 03:28:20,479
there you go bss extra

03:28:18,399 --> 03:28:21,840
blah blah blah but the point here is

03:28:20,479 --> 03:28:24,720
that this is possible

03:28:21,840 --> 03:28:24,720
basically in

03:28:25,040 --> 03:28:28,720
in 60 lines of poke

03:28:28,880 --> 03:28:32,560
obviously this is assuming that there is

03:28:30,640 --> 03:28:34,560
a elf pickle

03:28:32,560 --> 03:28:36,239
implementing the l files and those

03:28:34,560 --> 03:28:38,560
methods and everything but

03:28:36,239 --> 03:28:39,439
it is there right because other people

03:28:38,560 --> 03:28:42,880
use it for

03:28:39,439 --> 03:28:46,000
other stuff so scripts

03:28:42,880 --> 03:28:46,000
binary utilities

03:28:49,120 --> 03:28:54,560
now as i mentioned before pog now is uh

03:28:51,920 --> 03:28:54,560
is um

03:28:54,960 --> 03:29:00,880
is a library um basically um

03:28:58,080 --> 03:29:02,479
which was really it was so painful um

03:29:00,880 --> 03:29:04,720
basically pocket gives you

03:29:02,479 --> 03:29:06,080
all the facilities that you should need

03:29:04,720 --> 03:29:09,760
if you want to integrate pog

03:29:06,080 --> 03:29:12,080
in your program your utility

03:29:09,760 --> 03:29:14,160
and basically it provides you the

03:29:12,080 --> 03:29:17,359
complete compilation services

03:29:14,160 --> 03:29:18,880
uh disassembler management of ios spaces

03:29:17,359 --> 03:29:20,319
including that your application can

03:29:18,880 --> 03:29:22,080
provide its own narrow space

03:29:20,319 --> 03:29:24,880
implementation

03:29:22,080 --> 03:29:26,560
it gives you autocompletion services in

03:29:24,880 --> 03:29:28,399
case your program has an interactive

03:29:26,560 --> 03:29:30,720
prompt or whatever

03:29:28,399 --> 03:29:32,239
you can load modules like

03:29:30,720 --> 03:29:35,359
programmatically as well

03:29:32,239 --> 03:29:37,920
and you can manipulate uh

03:29:35,359 --> 03:29:38,720
book values also programmatically you

03:29:37,920 --> 03:29:41,520
can build the

03:29:38,720 --> 03:29:44,000
integers strings arrays extracts and

03:29:41,520 --> 03:29:44,000
whatnot

03:29:46,840 --> 03:29:52,640
offsets

03:29:49,359 --> 03:29:54,640
but also we are adding now

03:29:52,640 --> 03:29:56,080
a machine interface this machine

03:29:54,640 --> 03:29:59,680
interface basically

03:29:56,080 --> 03:30:02,880
is uh is uh is based on on json

03:29:59,680 --> 03:30:03,439
why on json well because those kids of

03:30:02,880 --> 03:30:05,439
today

03:30:03,439 --> 03:30:06,640
you know i mean what can i say if it's

03:30:05,439 --> 03:30:09,840
not json they don't

03:30:06,640 --> 03:30:11,680
they don't eat it so as jason it is

03:30:09,840 --> 03:30:13,840
i'm not a big fan of json but well there

03:30:11,680 --> 03:30:16,399
are worse things um

03:30:13,840 --> 03:30:18,160
basically it is inspired a bit loosely

03:30:16,399 --> 03:30:20,000
in the the back adapter protocol from

03:30:18,160 --> 03:30:22,960
microsoft

03:30:20,000 --> 03:30:23,680
um when i say inspired is that we use

03:30:22,960 --> 03:30:26,319
the same

03:30:23,680 --> 03:30:27,439
primitive you know like requests answers

03:30:26,319 --> 03:30:29,120
and whatever but

03:30:27,439 --> 03:30:30,800
other than that focus is not a debugger

03:30:29,120 --> 03:30:32,080
so gdp would be nice to have an

03:30:30,800 --> 03:30:34,319
interface like this

03:30:32,080 --> 03:30:35,279
um this is part of the summer of code

03:30:34,319 --> 03:30:37,520
03:30:35,279 --> 03:30:38,640
and my good friend costas who is a

03:30:37,520 --> 03:30:41,439
champion

03:30:38,640 --> 03:30:44,960
he's he's writing it as part of his

03:30:41,439 --> 03:30:44,960
student a student he's writing it

03:30:45,359 --> 03:30:49,359
this mi machine interface uh well

03:30:48,160 --> 03:30:52,160
basically it's based on request

03:30:49,359 --> 03:30:56,239
responses to the requests and events

03:30:52,160 --> 03:30:58,479
and well mr typical thing

03:30:56,239 --> 03:31:00,160
here you see an example of a dialogue i

03:30:58,479 --> 03:31:02,560
would like

03:31:00,160 --> 03:31:03,359
to be able to show you the the prototype

03:31:02,560 --> 03:31:06,000
user

03:31:03,359 --> 03:31:07,040
gear we that we have now that is working

03:31:06,000 --> 03:31:09,439
progress too

03:31:07,040 --> 03:31:10,399
but this is a typical dialogue exchange

03:31:09,439 --> 03:31:13,760
right

03:31:10,399 --> 03:31:16,800
right now poke uses uh a pipe to

03:31:13,760 --> 03:31:20,319
um to

03:31:16,800 --> 03:31:22,239
implement this this protocol and this

03:31:20,319 --> 03:31:24,479
this graphical user interface prototype

03:31:22,239 --> 03:31:26,880
is using the pipe interface

03:31:24,479 --> 03:31:28,880
but it uses select so i mean we can

03:31:26,880 --> 03:31:31,600
implement support for sockets anytime

03:31:28,880 --> 03:31:34,080
you know i mean so and we can basically

03:31:31,600 --> 03:31:37,200
communicate this with uh

03:31:34,080 --> 03:31:39,840
via tcp okay

03:31:37,200 --> 03:31:41,279
there are some new commands i'm sorry i

03:31:39,840 --> 03:31:42,640
don't have time to show you the new

03:31:41,279 --> 03:31:45,200
commands

03:31:42,640 --> 03:31:46,399
of course of course and this i want to

03:31:45,200 --> 03:31:48,880
stress it

03:31:46,399 --> 03:31:48,880
of course

03:31:49,600 --> 03:31:55,680
in poke the commands

03:31:52,960 --> 03:31:56,960
we can import themselves not all of them

03:31:55,680 --> 03:32:00,160
but most of them

03:31:56,960 --> 03:32:02,239
and for example i don't know um

03:32:00,160 --> 03:32:04,560
now we have a copy command which is a

03:32:02,239 --> 03:32:06,960
pity can't show it to you but

03:32:04,560 --> 03:32:08,399
the copy command is written in pog and

03:32:06,960 --> 03:32:10,160
this is it

03:32:08,399 --> 03:32:11,920
so basically this basically means that

03:32:10,160 --> 03:32:15,840
you can implement your own commands

03:32:11,920 --> 03:32:19,040
and use them um you know i mean

03:32:15,840 --> 03:32:20,840
with no problem um

03:32:19,040 --> 03:32:22,960
the damn command is with an import as

03:32:20,840 --> 03:32:26,479
well so there are a few

03:32:22,960 --> 03:32:26,479
of new commands which are handy

03:32:26,800 --> 03:32:29,520
and what else

03:32:33,680 --> 03:32:38,960
i don't know what it takes so much time

03:32:35,760 --> 03:32:38,960
to load these slides

03:32:40,000 --> 03:32:45,760
okay we had a pop conference at monsol

03:32:43,920 --> 03:32:47,439
in january this year we were lucky

03:32:45,760 --> 03:32:49,920
because this was corona

03:32:47,439 --> 03:32:52,080
at least around here and we managed to

03:32:49,920 --> 03:32:54,560
meet we did a lot of good work there

03:32:52,080 --> 03:32:55,439
and we are looking forward to to to me

03:32:54,560 --> 03:32:57,520
the game

03:32:55,439 --> 03:33:00,000
if that gets possible at some point

03:32:57,520 --> 03:33:00,000
sometime

03:33:00,319 --> 03:33:03,359
so currently status fast fast and then

03:33:02,239 --> 03:33:07,239
finish and i'm done

03:33:03,359 --> 03:33:09,600
okay this is of today um we have like

03:33:07,239 --> 03:33:12,960
35988 comments

03:33:09,600 --> 03:33:14,800
and now it's not only me i mean

03:33:12,960 --> 03:33:16,319
there are several people having poke

03:33:14,800 --> 03:33:19,600
this is in order of appearance

03:33:16,319 --> 03:33:20,160
many thanks to all of you and we have a

03:33:19,600 --> 03:33:21,920
decent

03:33:20,160 --> 03:33:23,920
test suite here you know at the moment

03:33:21,920 --> 03:33:26,560
we have like more than 4 000 tests

03:33:23,920 --> 03:33:27,840
distributed in like 10 different suites

03:33:26,560 --> 03:33:30,319
it's not enough though

03:33:27,840 --> 03:33:31,920
because there are still bugs there is

03:33:30,319 --> 03:33:35,040
still work to do after the first release

03:33:31,920 --> 03:33:38,160
that hopefully will come at the end of

03:33:35,040 --> 03:33:39,359
the summer but they can't comment on

03:33:38,160 --> 03:33:41,120
them because they don't have time

03:33:39,359 --> 03:33:43,040
and those are the project resources so

03:33:41,120 --> 03:33:44,399
basically we have a homepage we have a

03:33:43,040 --> 03:33:45,600
savannah project where the git

03:33:44,399 --> 03:33:47,760
repositories

03:33:45,600 --> 03:33:49,279
we have a mailing list obviously we have

03:33:47,760 --> 03:33:52,880
a baxilla

03:33:49,279 --> 03:33:55,520
thanks frank for setting that for us um

03:33:52,880 --> 03:33:57,040
in software then we have also an irc

03:33:55,520 --> 03:33:59,359
channel in freenode

03:33:57,040 --> 03:34:00,399
and i maintain a blog called applied

03:33:59,359 --> 03:34:03,200
photology

03:34:00,399 --> 03:34:06,399
here that you may want to follow if you

03:34:03,200 --> 03:34:06,399
are interested in using pog

03:34:07,200 --> 03:34:12,880
and well if you like the program and you

03:34:10,880 --> 03:34:16,000
think it may be useful for you

03:34:12,880 --> 03:34:16,960
and you have some cycles to spare well

03:34:16,000 --> 03:34:21,120
you will be welcome

03:34:16,960 --> 03:34:24,399
to hack with us and

03:34:21,120 --> 03:34:24,399
that was it thank you

03:34:27,040 --> 03:34:31,040
thank you jose that was uh that was a

03:34:29,359 --> 03:34:33,279
very good presentation

03:34:31,040 --> 03:34:34,720
uh lots of information and it generated

03:34:33,279 --> 03:34:37,760
a lot of comments i don't know if you

03:34:34,720 --> 03:34:37,760
had time to uh

03:34:38,080 --> 03:34:42,720
yeah so um we got permission to stay a

03:34:41,600 --> 03:34:45,120
bit longer if

03:34:42,720 --> 03:34:46,960
you are available and other people want

03:34:45,120 --> 03:34:57,760
to stay and ask questions

03:34:46,960 --> 03:35:00,960
they can take a few minutes to do that

03:34:57,760 --> 03:35:04,560
you have andrea who's uh hi

03:35:00,960 --> 03:35:07,439
yeah can you hear me yes

03:35:04,560 --> 03:35:09,600
okay hi i just have a couple of quick

03:35:07,439 --> 03:35:11,920
questions so first i wanted to

03:35:09,600 --> 03:35:12,960
ask if you have considered using an

03:35:11,920 --> 03:35:15,359
existing

03:35:12,960 --> 03:35:16,560
programming language instead of

03:35:15,359 --> 03:35:19,600
developing

03:35:16,560 --> 03:35:20,399
a dsl from scratch implementing it and

03:35:19,600 --> 03:35:23,600
the second one

03:35:20,399 --> 03:35:25,279
is if you plan to bring all this stuff

03:35:23,600 --> 03:35:27,279
within imax with some kind of

03:35:25,279 --> 03:35:30,800
integration

03:35:27,279 --> 03:35:34,000
uh iterated where in imax

03:35:30,800 --> 03:35:35,359
as they say that you are not remax users

03:35:34,000 --> 03:35:39,840
of course that's the most important

03:35:35,359 --> 03:35:39,840
thing yes

03:35:43,760 --> 03:35:47,279
i guess you are you have luau or python

03:35:45,920 --> 03:35:48,880
in mind right something that is designed

03:35:47,279 --> 03:35:52,960
to embed in applications right

03:35:48,880 --> 03:35:56,239
yeah yeah um what you like

03:35:52,960 --> 03:35:58,479
well i did consider that possibility yes

03:35:56,239 --> 03:36:00,880
but it was very fast abandoned because

03:35:58,479 --> 03:36:02,399
um if you get into into poke the

03:36:00,880 --> 03:36:03,920
language you will see very fast that

03:36:02,399 --> 03:36:05,840
it's very unusual

03:36:03,920 --> 03:36:07,200
it's not useful i mean it's weird it's a

03:36:05,840 --> 03:36:08,720
weird language uh

03:36:07,200 --> 03:36:11,279
not only because it has you know those

03:36:08,720 --> 03:36:13,279
types of uh like 11 bits or

03:36:11,279 --> 03:36:14,479
you know stuff like that also because

03:36:13,279 --> 03:36:17,120
for example

03:36:14,479 --> 03:36:18,560
um one of the of the of the most

03:36:17,120 --> 03:36:20,800
important aspects of the language is

03:36:18,560 --> 03:36:24,160
that we have united types

03:36:20,800 --> 03:36:29,040
for not united types

03:36:24,160 --> 03:36:32,640
we have united values for the offsets

03:36:29,040 --> 03:36:36,640
so in poke 23 bits is not 23

03:36:32,640 --> 03:36:38,479
73 bits um i have i didn't have time to

03:36:36,640 --> 03:36:39,680
show you know in detail that is in the

03:36:38,479 --> 03:36:41,200
talk from the last year if you're

03:36:39,680 --> 03:36:41,840
interested there should be some videos

03:36:41,200 --> 03:36:45,439
there

03:36:41,840 --> 03:36:46,640
um 23 bits are not the same thing that

03:36:45,439 --> 03:36:48,720
23 bytes

03:36:46,640 --> 03:36:50,319
and 23 alpha locations are not the same

03:36:48,720 --> 03:36:53,279
thing the 23

03:36:50,319 --> 03:36:54,640
health hitters for example right and i

03:36:53,279 --> 03:36:58,399
really wanted

03:36:54,640 --> 03:37:02,000
to be able to to work with those

03:36:58,399 --> 03:37:03,200
concepts as a first-class citizens in

03:37:02,000 --> 03:37:08,080
the language

03:37:03,200 --> 03:37:11,200
right and for that i needed for esl

03:37:08,080 --> 03:37:13,040
i mean um there is no way around it

03:37:11,200 --> 03:37:14,479
i know if you ask the skin people they

03:37:13,040 --> 03:37:17,840
will tell you yeah you can

03:37:14,479 --> 03:37:17,840
you can

03:37:23,040 --> 03:37:30,560
now emacs um there is a

03:37:26,399 --> 03:37:31,920
pog mode to edit box source files

03:37:30,560 --> 03:37:34,960
there is a start of it someone

03:37:31,920 --> 03:37:38,479
contributed it i use the c mode for now

03:37:34,960 --> 03:37:41,680
yeah i saw it yeah there is a

03:37:38,479 --> 03:37:42,720
ras mode which is for developers too i

03:37:41,680 --> 03:37:45,680
have not shown it

03:37:42,720 --> 03:37:46,800
but part of box is written in it has its

03:37:45,680 --> 03:37:50,319
own macro assembler

03:37:46,800 --> 03:37:54,479
and we have an assembly written in in in

03:37:50,319 --> 03:37:54,479
inadequate uk called rush

03:37:54,560 --> 03:37:58,479
and we also have a mod for that and of

03:37:57,040 --> 03:38:02,000
course

03:37:58,479 --> 03:38:04,640
um i am going to write an imax

03:38:02,000 --> 03:38:05,520
apoc dot el that will use the machine

03:38:04,640 --> 03:38:08,080
interface

03:38:05,520 --> 03:38:08,800
uh well to actually use spoke from imax

03:38:08,080 --> 03:38:11,600
yeah

03:38:08,800 --> 03:38:13,439
so the people who likes graphical user

03:38:11,600 --> 03:38:15,439
interfaces they can use a graphical user

03:38:13,439 --> 03:38:19,279
interface and i will use the amx mode

03:38:15,439 --> 03:38:19,279
right for for editing

03:38:20,160 --> 03:38:26,560
files okay but i guess

03:38:23,760 --> 03:38:27,279
if you use excel mode and down to revert

03:38:26,560 --> 03:38:28,720
mode

03:38:27,279 --> 03:38:32,399
probably you can still see what you are

03:38:28,720 --> 03:38:32,399
doing on the file directly in imax

03:38:33,359 --> 03:38:40,960
will not be like that ah because you

03:38:35,600 --> 03:38:43,439
don't like every time okay i see yeah

03:38:40,960 --> 03:38:44,720
the machine interface provides like it

03:38:43,439 --> 03:38:47,199
provides also

03:38:44,720 --> 03:38:48,640
functions to ask for the status for the

03:38:47,199 --> 03:38:50,560
different ios spaces

03:38:48,640 --> 03:38:52,080
to get the bytes that has been updated

03:38:50,560 --> 03:38:56,720
or not on yeah

03:38:52,080 --> 03:38:56,720
would be fun i see thanks

03:39:01,120 --> 03:39:09,840
other questions

03:39:11,840 --> 03:39:15,279
during uh during your presentation uh

03:39:13,840 --> 03:39:17,680
some people started talking about

03:39:15,279 --> 03:39:18,640
uh the dwarf pickle file which is in

03:39:17,680 --> 03:39:22,080
future

03:39:18,640 --> 03:39:23,359
it's in future yes yeah yes so uh

03:39:22,080 --> 03:39:26,160
can you tell us a little bit more about

03:39:23,359 --> 03:39:28,399
it well yeah sure i mean

03:39:26,160 --> 03:39:29,520
um everything that is in future i just

03:39:28,399 --> 03:39:33,359
started writing all that

03:39:29,520 --> 03:39:36,960
stuff even before pog

03:39:33,359 --> 03:39:37,359
existed because since i had to define my

03:39:36,960 --> 03:39:39,920
own

03:39:37,359 --> 03:39:41,840
domain specific language i wanted to be

03:39:39,920 --> 03:39:42,720
very sure that i was not doing something

03:39:41,840 --> 03:39:45,840
very stupid

03:39:42,720 --> 03:39:48,000
right so first i wanted to get

03:39:45,840 --> 03:39:48,960
the taste right and the you know the

03:39:48,000 --> 03:39:51,600
taste of

03:39:48,960 --> 03:39:53,920
how will be the language i need to do

03:39:51,600 --> 03:39:56,000
what they want to do

03:39:53,920 --> 03:39:57,840
what we do is that as spock gets more

03:39:56,000 --> 03:40:01,439
mature and more

03:39:57,840 --> 03:40:03,760
features gets in the language we move

03:40:01,439 --> 03:40:04,800
things from future we rewrite them to

03:40:03,760 --> 03:40:06,960
modern poke

03:40:04,800 --> 03:40:09,520
to actually existing pog and we move

03:40:06,960 --> 03:40:12,560
them from future to pickles

03:40:09,520 --> 03:40:14,479
so mark i guess if i have to guess

03:40:12,560 --> 03:40:16,479
probably it was mark who made that

03:40:14,479 --> 03:40:19,279
comment um

03:40:16,479 --> 03:40:21,680
he has two options i mean he he can just

03:40:19,279 --> 03:40:24,800
sit and wait for time to fix the problem

03:40:21,680 --> 03:40:26,080
so eventually they will dwarf.pk will go

03:40:24,800 --> 03:40:28,960
from future to pickles

03:40:26,080 --> 03:40:33,359
or he can do it himself which i think is

03:40:28,960 --> 03:40:36,160
the preferred option yeah

03:40:33,359 --> 03:40:38,960
very interesting um something else also

03:40:36,160 --> 03:40:42,479
that uh people were talking about was uh

03:40:38,960 --> 03:40:46,479
using poke as a validation uh tool

03:40:42,479 --> 03:40:48,560
um yeah so you don't really modify

03:40:46,479 --> 03:40:49,760
the object file but you still read into

03:40:48,560 --> 03:40:51,760
it and then you use uh

03:40:49,760 --> 03:40:54,720
the proc language to validate whether or

03:40:51,760 --> 03:40:57,600
not it matches any constraints and uh

03:40:54,720 --> 03:40:58,880
it's good for that i mean the problems

03:40:57,600 --> 03:41:00,399
we are having these are in the other

03:40:58,880 --> 03:41:02,399
front actually but

03:41:00,399 --> 03:41:04,239
in order because now we have to start

03:41:02,399 --> 03:41:07,439
thinking about how to work with invalid

03:41:04,239 --> 03:41:09,199
data which is quite challenging

03:41:07,439 --> 03:41:11,760
because right now if the constraint

03:41:09,199 --> 03:41:13,520
fails you don't get a mapped value

03:41:11,760 --> 03:41:15,040
but we want to to make that more

03:41:13,520 --> 03:41:17,199
flexible so you

03:41:15,040 --> 03:41:19,359
you should get a warning but you should

03:41:17,199 --> 03:41:22,880
be able to tag every value

03:41:19,359 --> 03:41:24,720
every math value as um

03:41:22,880 --> 03:41:26,239
strict or not strict in terms of that

03:41:24,720 --> 03:41:28,399
integrity right

03:41:26,239 --> 03:41:29,680
so you can work with broken data which

03:41:28,399 --> 03:41:33,920
is good for

03:41:29,680 --> 03:41:33,920
reverse engineering and other stuff

03:41:36,640 --> 03:41:43,840
does anyone else want to ask questions

03:41:45,840 --> 03:41:51,279
all right well thank you jose

03:41:49,520 --> 03:41:52,800
again for your presentation for your

03:41:51,279 --> 03:41:55,920
demo

03:41:52,800 --> 03:41:58,880
uh that concludes today so you know see

03:41:55,920 --> 03:41:58,880
you guys all tomorrow

03:42:03,439 --> 03:42:07,359
bye thank you joe bye

03:42:08,840 --> 03:42:11,840
bye

03:42:29,600 --> 03:42:31,680

YouTube URL: https://www.youtube.com/watch?v=mMwC0QenvcA


