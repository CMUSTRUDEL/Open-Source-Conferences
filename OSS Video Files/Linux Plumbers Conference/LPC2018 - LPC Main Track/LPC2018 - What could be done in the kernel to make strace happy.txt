Title: LPC2018 - What could be done in the kernel to make strace happy
Publication date: 2018-12-04
Playlist: LPC2018 - LPC Main Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/78/
speaker:  Dmitry Levin (BaseALT),  Elvira Khabirova (BaseALT),  Eugene Syromyatnikov (RedHat)


What could be done in the kernel to make strace happy.
Being a traditional tool with a long history, strace has been making every effort to overcome various deficiencies in the kernel API. Unfortunately, some of these workarounds are fragile, and in some cases no workaround is possible. In this talk maintainers of strace will describe these deficiencies and propose extensions to the kernel API so that tools like strace could work in a more reliable way.

1
Problem: there is no kernel API to find out whether the tracee is entering or exiting syscall.

Current workarounds: strace does its best to sort out and track ptrace events, this works in most cases, but in case of strace attaching to a tracee being inside exec when its first syscall stop is syscall-exit-stop instead of syscall-enter-stop, the workaround is fragile, and in infamous case of int 0x80 on x86_64 there is no reliable workaround.

Proposed solution: extend the ptrace API with PTRACE_GET_SYSCALL_INFO request.

2
Problem: there is no kernel API to invoke wait4 syscall with changed signal mask.

Current workarounds: strace does its best to implement a race-free workaround, but it is way too complex and hard to maintain.

Proposed solution: add wait6 syscall which is wait4 with additional signal mask arguments, like pselect vs select and ppoll vs poll.

3
Problem: time precision provided by struct rusage is too low for strace -c nowadays.

Current workarounds: none.

Proposed solution: when adding wait6 syscall, change struct rusage argument to a different structure with fields of type struct timespec instead of struct timeval.

4
Problem: PID namespaces have been introduced without a proper kernel API to translate between tracer and tracee views of pids. This causes confusion among strace users, e.g. https://bugzilla.redhat.com/1035433

Current workarounds: none.

Proposed solution: add translate_pid syscall, e.g. https://lkml.org/lkml/2018/7/3/589

5
Problem: there are no consistent declarative syscall descriptions, this forces every user to reinvent its own wheel and catch up with the kernel.

Current workarounds: a lot of manual work has been done in strace to implement parsers of all syscalls. Some of these parsers are quite complex and hard to test. Other projects, e.g. syzkaller, implement their own representation of syscall ABI.

Proposed solution: provide declarative descriptions for all syscalls consistently.
Captions: 
	00:00:06,380 --> 00:00:12,780
I'll be talking about things who find

00:00:09,750 --> 00:00:13,590
out for these nine years so what could

00:00:12,780 --> 00:00:16,680
be done in the

00:00:13,590 --> 00:00:22,430
to make a stress happy but why would you

00:00:16,680 --> 00:00:25,320
bother like why making a stress help you

00:00:22,430 --> 00:00:28,680
if you think of a stress as a project

00:00:25,320 --> 00:00:32,910
which is like a few months older than

00:00:28,680 --> 00:00:38,550
the Linux kernel it might be nice to

00:00:32,910 --> 00:00:40,710
make elders happy and when you make a

00:00:38,550 --> 00:00:43,940
stressful you make not just a stress

00:00:40,710 --> 00:00:48,120
users happy you're also making happy

00:00:43,940 --> 00:00:50,370
other projects like debuggers that use

00:00:48,120 --> 00:00:56,579
petraeus interface and other projects

00:00:50,370 --> 00:00:58,590
that call system calls directly so it

00:00:56,579 --> 00:01:03,360
actually might be useful not just for

00:00:58,590 --> 00:01:07,500
its trace so at least here eight

00:01:03,360 --> 00:01:12,770
problems for some of them I have more or

00:01:07,500 --> 00:01:18,209
less specific proposals some of them are

00:01:12,770 --> 00:01:21,619
like more VOC ideas so I would actually

00:01:18,209 --> 00:01:25,560
like to share some ideas for those

00:01:21,619 --> 00:01:28,800
problems that are not as as clear but

00:01:25,560 --> 00:01:31,970
I'll start with those problems for which

00:01:28,800 --> 00:01:34,740
we think we have a good ideas how to

00:01:31,970 --> 00:01:39,090
what to do in the kernel to to make a

00:01:34,740 --> 00:01:44,069
stress happy so the first problem is

00:01:39,090 --> 00:01:48,090
like it was always fair when you use the

00:01:44,069 --> 00:01:50,550
trace interface so for every system

00:01:48,090 --> 00:01:53,250
color is a so-called cisco enter stop

00:01:50,550 --> 00:01:56,910
and she's called a green stop but for

00:01:53,250 --> 00:01:59,759
the tracer they look absolutely the same

00:01:56,910 --> 00:02:04,610
there is no way in the kernel API to

00:01:59,759 --> 00:02:07,440
distinguish him no way at all so what

00:02:04,610 --> 00:02:12,180
the buggers do well like motor stress

00:02:07,440 --> 00:02:15,660
does they just try to keep track of the

00:02:12,180 --> 00:02:18,150
sequence of events and so they assume

00:02:15,660 --> 00:02:20,940
that when they attach also the first

00:02:18,150 --> 00:02:26,890
syscall stop is an enter stop and then

00:02:20,940 --> 00:02:29,260
they like always I keep this sequence

00:02:26,890 --> 00:02:31,120
enter stop exit stop there are other

00:02:29,260 --> 00:02:34,569
kinds of stops that are not Cisco stoves

00:02:31,120 --> 00:02:37,239
but - there is no way to distinguish

00:02:34,569 --> 00:02:41,469
them and when something odd happens for

00:02:37,239 --> 00:02:45,129
example when you attach to Traci which

00:02:41,469 --> 00:02:48,519
is inside exact the first syscall stop

00:02:45,129 --> 00:02:51,730
is actually is not an ancestor but an

00:02:48,519 --> 00:02:56,049
exit stop and everything is gets

00:02:51,730 --> 00:03:00,730
completely confused so we implemented a

00:02:56,049 --> 00:03:03,180
workaround for this but it's really

00:03:00,730 --> 00:03:07,930
fragile because there is no guarantee

00:03:03,180 --> 00:03:12,299
that the first Cisco stop is going to be

00:03:07,930 --> 00:03:16,840
an exit stop when you are attaching to a

00:03:12,299 --> 00:03:19,900
process that is inside exact another

00:03:16,840 --> 00:03:25,799
problem similar to the first one is that

00:03:19,900 --> 00:03:30,040
on this the most like popular platform

00:03:25,799 --> 00:03:32,560
x86 64 there is a compat mod and there

00:03:30,040 --> 00:03:34,659
is no reliable way to distinguish this

00:03:32,560 --> 00:03:37,479
course like native syscalls from

00:03:34,659 --> 00:03:41,979
compiled syscalls in most cases it works

00:03:37,479 --> 00:03:45,519
so what the backers usually do they use

00:03:41,979 --> 00:03:50,519
the trace Dietrich set with a union of

00:03:45,519 --> 00:03:53,739
two register sets and the kernel usually

00:03:50,519 --> 00:03:56,799
responds not just with a field structure

00:03:53,739 --> 00:03:58,709
but it also returns the size and by the

00:03:56,799 --> 00:04:02,979
size you can tell whether it was a

00:03:58,709 --> 00:04:05,680
native or a compact register set so yeah

00:04:02,979 --> 00:04:10,120
it works but it doesn't work in all

00:04:05,680 --> 00:04:15,459
cases for example in this in famous case

00:04:10,120 --> 00:04:19,449
of a interrupt number hexadecimal number

00:04:15,459 --> 00:04:21,720
88 this approach doesn't work as you can

00:04:19,449 --> 00:04:25,180
see in this example it was especially

00:04:21,720 --> 00:04:29,650
chosen - so you will see the difference

00:04:25,180 --> 00:04:34,139
you just easier it's just cool that days

00:04:29,650 --> 00:04:39,570
are like a very harmless just call

00:04:34,139 --> 00:04:44,870
called a get beat but now

00:04:39,570 --> 00:04:49,050
it's it's get beat on x86 button it is

00:04:44,870 --> 00:04:51,540
664 it's not a get beat it's a like more

00:04:49,050 --> 00:04:55,620
gracious call it's tequila it can kill

00:04:51,540 --> 00:04:58,560
something but there's no way to tell the

00:04:55,620 --> 00:05:00,930
difference and well it's a very real

00:04:58,560 --> 00:05:03,630
story if you trace this simple program

00:05:00,930 --> 00:05:08,640
it will report that it's a to kill that

00:05:03,630 --> 00:05:11,880
cheat owns number 500 which looks really

00:05:08,640 --> 00:05:17,420
odd have you ever seen a tequila turn in

00:05:11,880 --> 00:05:20,880
500 in real life I hope not

00:05:17,420 --> 00:05:23,670
so what do they suggest we suggest to

00:05:20,880 --> 00:05:26,130
like to extend the preachers API with a

00:05:23,670 --> 00:05:29,970
with a comment that can tell the

00:05:26,130 --> 00:05:31,680
difference but if we were eating if

00:05:29,970 --> 00:05:33,560
they're adding something to this

00:05:31,680 --> 00:05:37,290
interface we can do better than just

00:05:33,560 --> 00:05:40,080
return the the the the architecture and

00:05:37,290 --> 00:05:43,110
whether it's entering or exiting we can

00:05:40,080 --> 00:05:47,130
at the same time or return the the whole

00:05:43,110 --> 00:05:51,510
information the traces usually try to

00:05:47,130 --> 00:05:53,640
obtain in this case so we it would

00:05:51,510 --> 00:05:56,730
introduce a comment that it owns all

00:05:53,640 --> 00:05:59,250
this information we usually need and we

00:05:56,730 --> 00:06:00,060
usually obtained by issuing peach trees

00:05:59,250 --> 00:06:05,550
gets it

00:06:00,060 --> 00:06:08,580
then you won't have to issue to be

00:06:05,550 --> 00:06:12,150
traced commands instead of one so we

00:06:08,580 --> 00:06:15,330
will keep the same number of sis :

00:06:12,150 --> 00:06:17,960
vacations and we will get a reliable

00:06:15,330 --> 00:06:23,070
information right from the kernel

00:06:17,960 --> 00:06:25,740
actually proposed patch which turned

00:06:23,070 --> 00:06:32,180
into a patch set which is being

00:06:25,740 --> 00:06:34,800
discussed at this moment and I am I'm

00:06:32,180 --> 00:06:37,400
like not really optimistic but I'm

00:06:34,800 --> 00:06:43,290
cautiously optimistic about this because

00:06:37,400 --> 00:06:46,170
like it was some people are like like

00:06:43,290 --> 00:06:51,750
Angie are interested about this to make

00:06:46,170 --> 00:06:52,870
this but the bug that you can tell the

00:06:51,750 --> 00:06:58,870
difference too

00:06:52,870 --> 00:07:03,370
like this bug actually fixed another

00:06:58,870 --> 00:07:07,960
problem we have is that there is no way

00:07:03,370 --> 00:07:09,490
to invoke any any sis call from the

00:07:07,960 --> 00:07:13,510
weight family with a different signal

00:07:09,490 --> 00:07:16,900
mask it first race it became a problem

00:07:13,510 --> 00:07:19,990
last year because well before that we

00:07:16,900 --> 00:07:24,820
just put what actually stress used to do

00:07:19,990 --> 00:07:29,440
just a big loop with a weight for Cisco

00:07:24,820 --> 00:07:32,880
and a big Condor for for whatever it

00:07:29,440 --> 00:07:35,770
returned but last year we introduced

00:07:32,880 --> 00:07:39,220
along with other kinds of injections we

00:07:35,770 --> 00:07:43,240
introduced to delay injection and to

00:07:39,220 --> 00:07:49,210
implement this we had to add a timer and

00:07:43,240 --> 00:07:51,540
one time expires we have to handle this

00:07:49,210 --> 00:07:54,100
expiration we can't invoke weight

00:07:51,540 --> 00:07:57,750
otherwise would book in differently in

00:07:54,100 --> 00:08:02,220
some cases but there is no way to like

00:07:57,750 --> 00:08:05,830
to ensure that the signal doesn't arrive

00:08:02,220 --> 00:08:08,830
in immediately before the invocation of

00:08:05,830 --> 00:08:12,520
weight family she's calm so we now have

00:08:08,830 --> 00:08:16,180
a problem at least we had a problem of

00:08:12,520 --> 00:08:20,530
that kind but there's no she's call that

00:08:16,180 --> 00:08:22,870
would be useful in this case so what we

00:08:20,530 --> 00:08:25,750
did we had a very ugly workaround

00:08:22,870 --> 00:08:29,590
because we actually do a lot of work

00:08:25,750 --> 00:08:33,840
inside the signal Condor and this is not

00:08:29,590 --> 00:08:38,230
the thing you you really like to do your

00:08:33,840 --> 00:08:40,720
void so you do a as less as possible in

00:08:38,230 --> 00:08:43,090
the signal handler and we have to do a

00:08:40,720 --> 00:08:46,510
lot of non-trivial work so I'm very

00:08:43,090 --> 00:08:48,610
uncomfortable about this it's it's

00:08:46,510 --> 00:08:52,150
really not just complex it's fragile

00:08:48,610 --> 00:08:53,200
because the code that is running inside

00:08:52,150 --> 00:08:59,050
signal hunger

00:08:53,200 --> 00:09:01,030
it might change like because a side

00:08:59,050 --> 00:09:04,510
effect of some other code that we don't

00:09:01,030 --> 00:09:06,110
see this is out of scope of the signal

00:09:04,510 --> 00:09:09,980
handler itself so

00:09:06,110 --> 00:09:13,579
Ceri fragile so what we suggest is to

00:09:09,980 --> 00:09:17,420
like some years ago

00:09:13,579 --> 00:09:20,420
P select six Cisco was introduced as an

00:09:17,420 --> 00:09:25,610
extension to select and people I suggest

00:09:20,420 --> 00:09:28,190
to extend for example wait for the same

00:09:25,610 --> 00:09:31,940
way like these two extended adjusted

00:09:28,190 --> 00:09:35,390
their signal mask arguments the current

00:09:31,940 --> 00:09:39,370
tradition is to add two arguments which

00:09:35,390 --> 00:09:42,170
is looks somewhat strange because the

00:09:39,370 --> 00:09:44,810
signal set size is more or less the same

00:09:42,170 --> 00:09:47,649
but this is the tradition a in the

00:09:44,810 --> 00:09:51,980
kernel they do it this way

00:09:47,649 --> 00:09:55,519
we can also extend not wait for but for

00:09:51,980 --> 00:09:58,220
example wait IG but it would be a bit

00:09:55,519 --> 00:10:01,190
more complicated because weight idea

00:09:58,220 --> 00:10:04,459
already has five arguments and we can't

00:10:01,190 --> 00:10:07,459
add two because there is a limitation of

00:10:04,459 --> 00:10:10,730
6:30 means you have to introduce her

00:10:07,459 --> 00:10:13,820
indirection like in P select six just

00:10:10,730 --> 00:10:16,279
call that it has the last argument is an

00:10:13,820 --> 00:10:18,709
address where the pair of this two

00:10:16,279 --> 00:10:21,829
arguments start say ultra they extend

00:10:18,709 --> 00:10:25,040
wait for but for the purposes of first

00:10:21,829 --> 00:10:32,350
race other way would work ever wait for

00:10:25,040 --> 00:10:37,029
or wait ad this is about well new Cisco

00:10:32,350 --> 00:10:41,060
and another problem that could be

00:10:37,029 --> 00:10:47,290
addressed by introducing the same period

00:10:41,060 --> 00:10:49,699
success call is that the time precision

00:10:47,290 --> 00:10:55,100
returned by this weight force is called

00:10:49,699 --> 00:10:57,140
he is no longer sufficient for for for

00:10:55,100 --> 00:10:59,029
current purposes of collection

00:10:57,140 --> 00:11:03,709
statistics you know a stress has a

00:10:59,029 --> 00:11:05,959
option to collect statistics and it kind

00:11:03,709 --> 00:11:09,769
of works but as you can see in this

00:11:05,959 --> 00:11:12,800
example the same comment executed like

00:11:09,769 --> 00:11:16,510
twice in a row it shows so different

00:11:12,800 --> 00:11:19,460
results you can it's like the first time

00:11:16,510 --> 00:11:23,120
the get CV dish is called

00:11:19,460 --> 00:11:31,940
zero time and the second it was like

00:11:23,120 --> 00:11:34,130
nine nine points dot five zeros nine and

00:11:31,940 --> 00:11:36,350
with other Cisco's you see it's like

00:11:34,130 --> 00:11:38,959
it's because of the precision of

00:11:36,350 --> 00:11:43,459
structure years which is time Val which

00:11:38,959 --> 00:11:49,130
is as you can imagine it was like it's

00:11:43,459 --> 00:11:52,430
very old tradition it doesn't work so

00:11:49,130 --> 00:11:55,430
what do we suggest if were introduced in

00:11:52,430 --> 00:11:58,540
and uses call anyway so why not do it

00:11:55,430 --> 00:12:03,380
the right way so instead of adding

00:11:58,540 --> 00:12:07,450
startled usage like in P wait for why

00:12:03,380 --> 00:12:08,870
not a proper structure with the proper

00:12:07,450 --> 00:12:11,959
time

00:12:08,870 --> 00:12:16,100
timings like time spec and so to avoid

00:12:11,959 --> 00:12:20,180
this potential 32-bit time T of a flow

00:12:16,100 --> 00:12:24,310
problem why not to to use time spec 64

00:12:20,180 --> 00:12:31,390
right away so we won't have to like

00:12:24,310 --> 00:12:37,150
handle this when we creating tour to

00:12:31,390 --> 00:12:40,520
kennel time T and all this stuff so I

00:12:37,150 --> 00:12:44,360
think this is like a easy thing to do

00:12:40,520 --> 00:12:47,060
because the kernel already has all this

00:12:44,360 --> 00:12:49,700
information it just every time it feels

00:12:47,060 --> 00:12:52,970
out they start a usage it just

00:12:49,700 --> 00:12:56,120
explicitly loses this information and we

00:12:52,970 --> 00:12:59,450
we need it so it it would be even maybe

00:12:56,120 --> 00:13:04,870
faster in the kernel not to transform

00:12:59,450 --> 00:13:07,640
this nanoseconds in to microseconds so

00:13:04,870 --> 00:13:10,070
I'm cautious optimistic about this

00:13:07,640 --> 00:13:13,100
interface it looks straight forward but

00:13:10,070 --> 00:13:16,040
it hasn't been discussed yet you

00:13:13,100 --> 00:13:22,190
probably the first one to to hear about

00:13:16,040 --> 00:13:23,870
it so maybe you have some ideas if you

00:13:22,190 --> 00:13:26,149
have any questions about these two

00:13:23,870 --> 00:13:27,800
things I was talking about you're

00:13:26,149 --> 00:13:31,240
welcome

00:13:27,800 --> 00:13:31,240
this is a mic

00:13:31,490 --> 00:13:39,899
so that hey talk the 32-bit overflow

00:13:35,370 --> 00:13:50,180
when does it the car sorry the 32-bit

00:13:39,899 --> 00:13:53,970
overflow today so Toki is today that

00:13:50,180 --> 00:13:59,250
about this yeah the end of UNIX support

00:13:53,970 --> 00:14:02,000
problem and this is not an absolute time

00:13:59,250 --> 00:14:06,300
but this is our usage imagine you have

00:14:02,000 --> 00:14:08,730
like a lot of a lot of course like

00:14:06,300 --> 00:14:18,180
really a lot of course and they're all

00:14:08,730 --> 00:14:21,149
running and and they they spend time so

00:14:18,180 --> 00:14:22,800
in like in a few hours or it depends on

00:14:21,149 --> 00:14:29,779
the number of course and the speed of

00:14:22,800 --> 00:14:34,199
course so this looks like slightly less

00:14:29,779 --> 00:14:38,100
easy to reproduce then just move the

00:14:34,199 --> 00:14:40,620
time in the future but it's real it's no

00:14:38,100 --> 00:14:45,199
type so did you ever hit the case that

00:14:40,620 --> 00:14:52,259
you did or you time or or or s time

00:14:45,199 --> 00:14:55,079
exceeded 68 years yeah if you have a lot

00:14:52,259 --> 00:14:58,889
of course all this time on all course is

00:14:55,079 --> 00:15:01,740
added you can easily get this 60 60

00:14:58,889 --> 00:15:09,269
something years just just imagine that

00:15:01,740 --> 00:15:13,380
just imagine so if you want to like to

00:15:09,269 --> 00:15:20,790
exceed it in 60 something hours you need

00:15:13,380 --> 00:15:24,449
the number of course which is I think

00:15:20,790 --> 00:15:26,339
this is this is quite real and if if we

00:15:24,449 --> 00:15:29,759
are adding a new interface it should

00:15:26,339 --> 00:15:35,759
survive for quite some time we we can

00:15:29,759 --> 00:15:39,649
just make it the right way we can leave

00:15:35,759 --> 00:15:46,100
it if you if you assume that you have

00:15:39,649 --> 00:15:46,100
thousand 24 course you need actually 500

00:15:48,410 --> 00:15:53,730
ours too

00:15:49,910 --> 00:15:57,720
to get into the overflow situation and

00:15:53,730 --> 00:15:58,470
what if you have more course yeah it's

00:15:57,720 --> 00:16:01,050
good

00:15:58,470 --> 00:16:03,060
so yes if if it's actually a real

00:16:01,050 --> 00:16:06,390
problem why not

00:16:03,060 --> 00:16:09,720
my point is not to replace time well

00:16:06,390 --> 00:16:12,600
with time spec 64 but with time spoke

00:16:09,720 --> 00:16:15,779
there was a we need time spec but if you

00:16:12,600 --> 00:16:19,410
are replacing so why not do it the right

00:16:15,779 --> 00:16:22,980
way from the from the beginning I mean

00:16:19,410 --> 00:16:28,279
what would we achieve if we limit this

00:16:22,980 --> 00:16:32,870
to times-pic and then some time yeah

00:16:28,279 --> 00:16:36,750
it's not you don't often see a

00:16:32,870 --> 00:16:40,290
multi-core system running 32-bit like

00:16:36,750 --> 00:16:41,910
user space really multi-core but why

00:16:40,290 --> 00:16:46,950
don't you use potential problems if we

00:16:41,910 --> 00:16:52,589
can avoid this okay so the next problem

00:16:46,950 --> 00:16:54,660
we have is that in namespaces they were

00:16:52,589 --> 00:16:57,180
introduced without a proper kernel

00:16:54,660 --> 00:17:00,060
appear to translate between tracer and

00:16:57,180 --> 00:17:02,399
tracer views of bits and stretch the

00:17:00,060 --> 00:17:07,350
users are actually confused about this

00:17:02,399 --> 00:17:10,230
there's a bug report that this example

00:17:07,350 --> 00:17:15,630
is a just a cut down from that bug

00:17:10,230 --> 00:17:18,600
report if you trace something that works

00:17:15,630 --> 00:17:23,699
in a in a different namespace so at some

00:17:18,600 --> 00:17:27,360
point the at some point the the peat

00:17:23,699 --> 00:17:31,559
that is seen is the leaflets reported to

00:17:27,360 --> 00:17:32,070
the Tracy not to stress and people are

00:17:31,559 --> 00:17:35,010
confused

00:17:32,070 --> 00:17:39,179
for example they see the process ID

00:17:35,010 --> 00:17:42,780
number two while in reality it's a

00:17:39,179 --> 00:17:46,520
different process ID and the stress

00:17:42,780 --> 00:17:50,790
users they want to see both like the The

00:17:46,520 --> 00:17:55,110
Prodigy that is seen by the Tracy and

00:17:50,790 --> 00:17:58,290
also the the real prodigy they can use

00:17:55,110 --> 00:18:02,390
for example to to analyze the log

00:17:58,290 --> 00:18:06,110
which has this number the the prodigy

00:18:02,390 --> 00:18:10,940
but there is no sane way to to do this I

00:18:06,110 --> 00:18:15,360
mean you can do like forking and passing

00:18:10,940 --> 00:18:19,230
passing descriptors with circuit

00:18:15,360 --> 00:18:22,680
credentials but it's so slow that even

00:18:19,230 --> 00:18:26,220
for a stress which is not the fastest

00:18:22,680 --> 00:18:28,950
racer in the world it's going to slow it

00:18:26,220 --> 00:18:37,440
down significantly and it's really

00:18:28,950 --> 00:18:39,600
complicated thing so the idea is to to

00:18:37,440 --> 00:18:42,660
introduce into the kiln or something

00:18:39,600 --> 00:18:44,060
that would make her translation a proper

00:18:42,660 --> 00:18:46,950
way

00:18:44,060 --> 00:18:54,390
actually there is a proposal of a system

00:18:46,950 --> 00:18:58,350
call which dates to 2015 it's byte

00:18:54,390 --> 00:19:02,580
konstantin strelnikov it survived its

00:18:58,350 --> 00:19:05,340
sixth iteration so on this slide you see

00:19:02,580 --> 00:19:08,250
his description of this is coal which

00:19:05,340 --> 00:19:11,100
allows to translate Perce ad from a

00:19:08,250 --> 00:19:13,770
source namespace to add a target

00:19:11,100 --> 00:19:17,760
namespace the interface looks like

00:19:13,770 --> 00:19:20,460
stitch forward it was discussed here are

00:19:17,760 --> 00:19:24,030
some examples how it could be used the

00:19:20,460 --> 00:19:27,480
examples are also by Constantine but the

00:19:24,030 --> 00:19:33,600
discussion is told so like more or less

00:19:27,480 --> 00:19:39,840
everybody agrees but they it doesn't

00:19:33,600 --> 00:19:43,260
move anywhere so I would like to attract

00:19:39,840 --> 00:19:45,810
more attention to this system call a I

00:19:43,260 --> 00:19:49,320
think Constantine had different plans to

00:19:45,810 --> 00:19:52,910
use it but he didn't mean a stress but

00:19:49,320 --> 00:19:52,910
first race it will be really useful

00:19:55,010 --> 00:20:04,440
so from problems for which we have some

00:19:59,690 --> 00:20:09,720
ideas and I'll switch to problems for

00:20:04,440 --> 00:20:12,420
which we have just a common generic

00:20:09,720 --> 00:20:15,870
ideas without any specific proposal

00:20:12,420 --> 00:20:18,300
but their real problems anyway so

00:20:15,870 --> 00:20:21,510
besides difference in building spaces

00:20:18,300 --> 00:20:24,180
there are limitations that are

00:20:21,510 --> 00:20:27,270
noticeable in stress that are related to

00:20:24,180 --> 00:20:29,910
network namespaces for example there was

00:20:27,270 --> 00:20:33,330
a bug report recently that when you are

00:20:29,910 --> 00:20:36,360
tracing a chromium browser stage doesn't

00:20:33,330 --> 00:20:38,240
show network protocol details like it

00:20:36,360 --> 00:20:42,060
does for a regular purchases because

00:20:38,240 --> 00:20:44,070
chromium browser creates purchases with

00:20:42,060 --> 00:20:49,260
China in different network namespaces

00:20:44,070 --> 00:20:52,200
and as a result strays I can't see this

00:20:49,260 --> 00:20:55,620
information because the interface would

00:20:52,200 --> 00:20:58,050
use its knitting sub jack it doesn't

00:20:55,620 --> 00:21:01,080
report circuits of traces that ran in

00:20:58,050 --> 00:21:03,510
different network namespaces so you can

00:21:01,080 --> 00:21:07,320
see in this example it's actually an

00:21:03,510 --> 00:21:11,490
example from that back report the first

00:21:07,320 --> 00:21:14,310
circuit parent location is is invocation

00:21:11,490 --> 00:21:17,310
that was made in the same network

00:21:14,310 --> 00:21:19,560
namespace you see that the the circuits

00:21:17,310 --> 00:21:25,080
are created they are created connected

00:21:19,560 --> 00:21:27,420
and when so when the process and there's

00:21:25,080 --> 00:21:30,300
a different network namespace what

00:21:27,420 --> 00:21:32,280
happens is that the descriptions are

00:21:30,300 --> 00:21:35,520
created in a different name space and

00:21:32,280 --> 00:21:39,330
they are not reported to a strace so

00:21:35,520 --> 00:21:42,570
they look like unconnected which is not

00:21:39,330 --> 00:21:45,030
really the case and I don't think we can

00:21:42,570 --> 00:21:50,490
do anything with it just a problem just

00:21:45,030 --> 00:21:54,090
a limitation probably if some network

00:21:50,490 --> 00:21:56,300
people can suggesting something about

00:21:54,090 --> 00:21:56,300
this

00:21:58,110 --> 00:22:08,430
I don't have any ideas how how to how to

00:22:02,730 --> 00:22:11,600
work around this program okay so what

00:22:08,430 --> 00:22:15,660
about decoding syscalls

00:22:11,600 --> 00:22:18,720
like every every every piece of software

00:22:15,660 --> 00:22:22,590
what invokes is calls directly or that

00:22:18,720 --> 00:22:26,190
decode sis calls every piece of software

00:22:22,590 --> 00:22:30,510
has to invent its own way how to do this

00:22:26,190 --> 00:22:31,290
because there's no like no real support

00:22:30,510 --> 00:22:34,680
in the kennel

00:22:31,290 --> 00:22:38,720
there is no detail machine readable

00:22:34,680 --> 00:22:42,240
circle descriptions that are consistent

00:22:38,720 --> 00:22:45,690
as you will see in the following slide

00:22:42,240 --> 00:22:48,960
so what projects do they do whatever

00:22:45,690 --> 00:22:54,570
they can and in case of a stress we have

00:22:48,960 --> 00:22:58,050
a lot of a lot of decoders written and

00:22:54,570 --> 00:23:01,410
see so a lot of manual work has been

00:22:58,050 --> 00:23:04,200
done to implement this sometimes these

00:23:01,410 --> 00:23:09,600
purses are quite complex but fortunately

00:23:04,200 --> 00:23:12,120
we have attitude so I'm very proud that

00:23:09,600 --> 00:23:17,370
this destitute appeared during my tenure

00:23:12,120 --> 00:23:24,690
so it covers about 85% so we are more or

00:23:17,370 --> 00:23:27,030
less sure that these decoders do the

00:23:24,690 --> 00:23:29,520
right thing but every time something is

00:23:27,030 --> 00:23:36,840
added to the kernel we have to catch up

00:23:29,520 --> 00:23:40,280
and if you have a look at any Lipson

00:23:36,840 --> 00:23:44,000
implementation it has its own wrappers

00:23:40,280 --> 00:23:47,190
some of them like some of them are

00:23:44,000 --> 00:23:50,340
generated because they're

00:23:47,190 --> 00:23:53,010
straightforward some of them are more

00:23:50,340 --> 00:23:57,260
complex because they have to convert

00:23:53,010 --> 00:23:59,880
data structures from Lipsy

00:23:57,260 --> 00:24:02,550
representation which is maintained by

00:23:59,880 --> 00:24:06,120
standards to a kernel representation so

00:24:02,550 --> 00:24:09,060
there are more complex and second find

00:24:06,120 --> 00:24:11,250
all kind of wrappers there other

00:24:09,060 --> 00:24:14,760
projects they also

00:24:11,250 --> 00:24:19,640
renlund a wills like if you have a look

00:24:14,760 --> 00:24:21,300
at this color it has a very detailed

00:24:19,640 --> 00:24:23,820
declarative machine readable

00:24:21,300 --> 00:24:26,820
descriptions

00:24:23,820 --> 00:24:31,610
I think sanitizers do something about

00:24:26,820 --> 00:24:35,820
this but there's no help from the kernel

00:24:31,610 --> 00:24:38,760
and it would be really great if this

00:24:35,820 --> 00:24:42,780
information would be available from the

00:24:38,760 --> 00:24:44,820
kernel itself so I'll just show you an

00:24:42,780 --> 00:24:49,170
example this is there was some

00:24:44,820 --> 00:24:51,660
discussion about that lost current

00:24:49,170 --> 00:24:56,210
summit I think sorry there was some

00:24:51,660 --> 00:24:58,770
discussion about having possible

00:24:56,210 --> 00:25:01,290
descriptions of Siskel's in the kernel

00:24:58,770 --> 00:25:03,480
say I don't know what we're that when

00:25:01,290 --> 00:25:05,490
services color people wanted to have

00:25:03,480 --> 00:25:11,910
that anyway so we agreed that it should

00:25:05,490 --> 00:25:17,330
be in the kernel itself but anything

00:25:11,910 --> 00:25:17,330
more than discussions too much work so

00:25:18,770 --> 00:25:41,190
sorry say you have to do to say the

00:25:24,240 --> 00:25:43,860
first set is obviously manual okay yeah

00:25:41,190 --> 00:25:46,230
but anyway we agreed that it would be a

00:25:43,860 --> 00:25:50,660
good thing if somebody has an idea how

00:25:46,230 --> 00:25:55,100
to do it I have some ideas just let me

00:25:50,660 --> 00:25:58,410
let me go on so this is a short example

00:25:55,100 --> 00:26:00,720
what stress can do and how complicated

00:25:58,410 --> 00:26:03,630
the output could be and you can imagine

00:26:00,720 --> 00:26:06,780
how complicated the parser could be so

00:26:03,630 --> 00:26:09,810
it's on the top level a partial for this

00:26:06,780 --> 00:26:12,150
it's a sin to and receive messages cause

00:26:09,810 --> 00:26:15,630
so on the top part this is just to see

00:26:12,150 --> 00:26:20,250
that cause other functions and if you

00:26:15,630 --> 00:26:24,740
compare this to this color it has like

00:26:20,250 --> 00:26:29,340
more machine readable like

00:26:24,740 --> 00:26:31,769
9si code is not machine readable if you

00:26:29,340 --> 00:26:34,440
compare sis colors description for this

00:26:31,769 --> 00:26:37,890
message and the description you can

00:26:34,440 --> 00:26:40,200
obtain from the kernel source it will

00:26:37,890 --> 00:26:44,850
find out that she's color is much more

00:26:40,200 --> 00:26:48,210
structured the Consulate's the where

00:26:44,850 --> 00:26:52,529
where the argument the first argument of

00:26:48,210 --> 00:26:57,000
this is call is just integer in Cisco

00:26:52,529 --> 00:27:01,440
it's it's a file description and also in

00:26:57,000 --> 00:27:04,080
this trace decoder is printed as a see

00:27:01,440 --> 00:27:11,850
print of G it's a special way to print

00:27:04,080 --> 00:27:15,419
file descriptors okay so what do we what

00:27:11,850 --> 00:27:18,659
could we do for for the beginning we can

00:27:15,419 --> 00:27:22,830
extend these syscall definitions and the

00:27:18,659 --> 00:27:25,730
kernel by using more specific structures

00:27:22,830 --> 00:27:29,880
and types for example if we type def

00:27:25,730 --> 00:27:33,120
into something like Colonel F DT or

00:27:29,880 --> 00:27:35,429
whatever which is not an int but more

00:27:33,120 --> 00:27:38,220
specific description which is a file

00:27:35,429 --> 00:27:43,019
descriptor we can compile it into dwarf

00:27:38,220 --> 00:27:45,860
and then well we would be able to obtain

00:27:43,019 --> 00:27:49,409
more information this is like

00:27:45,860 --> 00:27:54,090
low-hanging fruit but it's really easy

00:27:49,409 --> 00:27:59,210
to do but to implement something as

00:27:54,090 --> 00:28:05,149
detailed as in this color or in a stress

00:27:59,210 --> 00:28:07,769
it cries I think more thinking then just

00:28:05,149 --> 00:28:10,440
just exchanging this is called

00:28:07,769 --> 00:28:14,779
definitions so if you have some ideas

00:28:10,440 --> 00:28:18,559
how to go how to proceed with this this

00:28:14,779 --> 00:28:23,210
behind this simple extension of these

00:28:18,559 --> 00:28:28,380
basic types for example a there are

00:28:23,210 --> 00:28:32,880
multiplexer syscalls like i io cattle

00:28:28,380 --> 00:28:35,309
that have the funny thing that the same

00:28:32,880 --> 00:28:37,530
cisco argument may have different

00:28:35,309 --> 00:28:40,530
meaning depending on the

00:28:37,530 --> 00:28:42,570
disk on the device associated with

00:28:40,530 --> 00:28:52,470
descriptor how do you describe this in

00:28:42,570 --> 00:28:56,330
the kernel I don't know okay so the last

00:28:52,470 --> 00:28:59,840
problem I would like to touch is that

00:28:56,330 --> 00:29:03,780
everybody knows that stress is slow

00:28:59,840 --> 00:29:08,280
because on every she's : vacation it

00:29:03,780 --> 00:29:11,250
traces it gets to she's called stops and

00:29:08,280 --> 00:29:14,160
on every she's called stop there is a to

00:29:11,250 --> 00:29:17,700
cut six switches from the Tracy to

00:29:14,160 --> 00:29:22,680
tracer and then back so it's like for

00:29:17,700 --> 00:29:24,900
context switches purchases : vacation in

00:29:22,680 --> 00:29:28,590
the Tracy and a stress also has to

00:29:24,900 --> 00:29:33,720
invoke which is calls on itself at least

00:29:28,590 --> 00:29:36,020
it has to wait if it races if it's

00:29:33,720 --> 00:29:40,200
interested in this is call it also like

00:29:36,020 --> 00:29:44,700
grabs registers and it has to put the

00:29:40,200 --> 00:29:47,220
traces call it the the Tracy so it's

00:29:44,700 --> 00:29:50,910
really slow everybody knows this but

00:29:47,220 --> 00:29:54,900
from another side all kernel traces they

00:29:50,910 --> 00:29:56,870
write into a ring buffer and if they

00:29:54,900 --> 00:30:00,660
write faster than the reader reads it

00:29:56,870 --> 00:30:01,650
they the data could be lost so what

00:30:00,660 --> 00:30:09,420
could be done about it

00:30:01,650 --> 00:30:15,270
how can we like make maybe like extended

00:30:09,420 --> 00:30:19,380
curve interface to make some some events

00:30:15,270 --> 00:30:23,060
like motion furnace in this meaning that

00:30:19,380 --> 00:30:27,180
they would like blah click the process

00:30:23,060 --> 00:30:31,170
if if there is no enough space in the

00:30:27,180 --> 00:30:37,920
buffer instead of just averaging the

00:30:31,170 --> 00:30:41,160
ring buffer so so what it has to do with

00:30:37,920 --> 00:30:45,500
the stress stress has a lot of purses

00:30:41,160 --> 00:30:48,150
and if we can if you can for example

00:30:45,500 --> 00:30:51,820
convert them or just automatically

00:30:48,150 --> 00:30:57,910
compile them into into BBF

00:30:51,820 --> 00:31:01,450
and then if turf has this way to block

00:30:57,910 --> 00:31:04,030
purchases so we can use actually we can

00:31:01,450 --> 00:31:08,280
implement a kind of curve back and forth

00:31:04,030 --> 00:31:19,770
Trace that would use be paired parses

00:31:08,280 --> 00:31:24,210
generated from its own C code okay no

00:31:19,770 --> 00:31:28,060
actually I think that's probably trivial

00:31:24,210 --> 00:31:30,030
thing is we wouldn't build a block way

00:31:28,060 --> 00:31:32,650
to have to check to see if we're in a

00:31:30,030 --> 00:31:34,480
preemptable context so there's some

00:31:32,650 --> 00:31:37,870
events but if you're doing from the

00:31:34,480 --> 00:31:41,470
system call yeah well from a success

00:31:37,870 --> 00:31:44,160
that you're always going to be in a we

00:31:41,470 --> 00:31:48,100
have the trace point yeah a preemptable

00:31:44,160 --> 00:31:49,840
spot I think we could just say okay

00:31:48,100 --> 00:31:51,340
block and put it to sleep and when the

00:31:49,840 --> 00:31:56,140
ring buffering to wake it up I don't

00:31:51,340 --> 00:32:02,350
think that would be a difficult patch to

00:31:56,140 --> 00:32:03,910
do here yeah oh you oh you don't usually

00:32:02,350 --> 00:32:05,410
work on the I know Peters else was

00:32:03,910 --> 00:32:14,440
usually on the kernel side don't you see

00:32:05,410 --> 00:32:15,790
but what do you think what well yeah he

00:32:14,440 --> 00:32:18,310
might hate it but I'm saying is if you

00:32:15,790 --> 00:32:20,440
if it has to be all the features if you

00:32:18,310 --> 00:32:22,960
could P trace a process why can't you

00:32:20,440 --> 00:32:25,240
block it at its system call I mean we we

00:32:22,960 --> 00:32:34,690
need the security on it do you have any

00:32:25,240 --> 00:32:39,580
issues with it it's something not that

00:32:34,690 --> 00:32:44,670
difficult to implement why do to stop it

00:32:39,580 --> 00:32:44,670
I mean we can stop it

00:32:46,559 --> 00:32:50,260
so we just have to come up with an

00:32:48,490 --> 00:32:52,419
interface I mean I'm sure probably a

00:32:50,260 --> 00:32:54,669
perf attribute or something that says

00:32:52,419 --> 00:32:56,890
block on this event yeah for the raw

00:32:54,669 --> 00:33:00,309
syscalls haven't you're gonna see that

00:32:56,890 --> 00:33:04,510
the pause when they be everything

00:33:00,309 --> 00:33:06,160
wake up the user space component that

00:33:04,510 --> 00:33:09,850
you're gonna read it and when it reads

00:33:06,160 --> 00:33:11,559
and sign yeah I don't think we could

00:33:09,850 --> 00:33:13,150
make it a watermark so you would read so

00:33:11,559 --> 00:33:16,870
much and then I hate it's a watermark

00:33:13,150 --> 00:33:19,120
say okay read saw this then continue and

00:33:16,870 --> 00:33:21,549
I don't think that would be difficult to

00:33:19,120 --> 00:33:23,559
do and we just keep I would base it off

00:33:21,549 --> 00:33:25,570
the peach race you know if you if you

00:33:23,559 --> 00:33:27,010
could pee trace it and you have all the

00:33:25,570 --> 00:33:28,330
controls for everything you do in P

00:33:27,010 --> 00:33:30,700
trace which would basically do the same

00:33:28,330 --> 00:33:32,620
thing you'd have to have all the right

00:33:30,700 --> 00:33:34,929
has I'm assuming it has all the security

00:33:32,620 --> 00:33:36,820
in the petrous interface so maybe even

00:33:34,929 --> 00:33:41,309
attach it to PJ saying hey I'm gonna use

00:33:36,820 --> 00:33:41,309
perf and just let it run and block

00:33:41,370 --> 00:33:48,640
actually don't know whether it worth

00:33:44,799 --> 00:33:52,030
like abusing the trace thing I mean if

00:33:48,640 --> 00:33:56,610
you trace a process maybe you want this

00:33:52,030 --> 00:34:00,340
behavior by default just I know it's

00:33:56,610 --> 00:34:03,520
it's highly wanted this money this which

00:34:00,340 --> 00:34:05,710
amend ously speed-up s trace yeah it's a

00:34:03,520 --> 00:34:06,160
mystery I know a lot of people that SS

00:34:05,710 --> 00:34:08,850
trace

00:34:06,160 --> 00:34:12,639
so actually Inga Inga Mona and I

00:34:08,850 --> 00:34:17,560
implemented s trace once with with the

00:34:12,639 --> 00:34:20,080
perfume and say it works yes and you

00:34:17,560 --> 00:34:21,790
can't do it so so you just need to

00:34:20,080 --> 00:34:24,330
interface I mean the only thing what you

00:34:21,790 --> 00:34:26,740
need and I don't think it's a problem to

00:34:24,330 --> 00:34:30,040
block the thing when we overrun the

00:34:26,740 --> 00:34:31,720
buffer only thing is we have to make

00:34:30,040 --> 00:34:35,139
sure I mean I don't know how you're

00:34:31,720 --> 00:34:37,330
naraku's I mean obviously it's a no-no

00:34:35,139 --> 00:34:39,460
you can restrict that to a certain set

00:34:37,330 --> 00:34:40,750
of events yeah and I mean you can do it

00:34:39,460 --> 00:34:45,639
as long as you're in a preemptable

00:34:40,750 --> 00:34:49,570
context don't do it No

00:34:45,639 --> 00:34:51,780
why not you might hold the reader locks

00:34:49,570 --> 00:34:55,970
or whatever

00:34:51,780 --> 00:34:59,359
no it's user space that block yeah

00:34:55,970 --> 00:35:01,750
don't go there so we can really say okay

00:34:59,359 --> 00:35:04,310
here is a white list of events which

00:35:01,750 --> 00:35:06,400
were allowed to do that and that's

00:35:04,310 --> 00:35:09,800
basically the Rosses Cole tracer

00:35:06,400 --> 00:35:14,540
actually I might say only sister system

00:35:09,800 --> 00:35:17,060
call yes only yes yes so if it's just a

00:35:14,540 --> 00:35:19,130
flag in the in the trace points and it's

00:35:17,060 --> 00:35:20,930
actually a single trace point it's not

00:35:19,130 --> 00:35:23,780
even all that all the system calls are

00:35:20,930 --> 00:35:25,250
done by a single trace point it has junk

00:35:23,780 --> 00:35:27,200
on top to make it look like multiple

00:35:25,250 --> 00:35:29,359
trace points so it's really a bit and

00:35:27,200 --> 00:35:31,670
that makes it really easy yes so it's

00:35:29,359 --> 00:35:34,220
actually code changed in one spot and it

00:35:31,670 --> 00:35:42,050
happens to be in the P trace code that

00:35:34,220 --> 00:35:44,300
it's implemented oh great the only

00:35:42,050 --> 00:35:47,930
question I have is how do we move

00:35:44,300 --> 00:35:51,319
forward I mean I'm not can purchase who

00:35:47,930 --> 00:35:54,530
is going to patch the the kernel

00:35:51,319 --> 00:36:00,430
I might get I don't know I could see if

00:35:54,530 --> 00:36:00,430
it's Matt here one of my workers

00:36:00,579 --> 00:36:05,060
no actually it's something we want I

00:36:03,170 --> 00:36:12,920
might be able to get someone to work on

00:36:05,060 --> 00:36:15,130
it so yeah I think I was somewhere Red

00:36:12,920 --> 00:36:15,130
Hat

00:36:21,280 --> 00:36:26,840
okay I take let's take that offline and

00:36:24,620 --> 00:36:31,280
talk about it so it's not rocket science

00:36:26,840 --> 00:36:33,200
to do it if you must chest grab Peter

00:36:31,280 --> 00:36:34,970
sister assembly on the conference and

00:36:33,200 --> 00:36:36,380
tell him body wardens

00:36:34,970 --> 00:36:42,290
he may have it done by the end of the

00:36:36,380 --> 00:36:46,810
day or not yeah okay

00:36:42,290 --> 00:36:46,810
any more questions ideas

00:36:51,130 --> 00:37:01,500
a wish can we kill Pete race I don't

00:36:56,670 --> 00:37:08,830
think you want to kill to kill Pete race

00:37:01,500 --> 00:37:11,740
because how do you modify that Tracy yes

00:37:08,830 --> 00:37:17,200
yeah I know but still Petrus is a pain

00:37:11,740 --> 00:37:21,880
and yes it is the whole non semantics of

00:37:17,200 --> 00:37:24,100
Pete race are horrible you know yes you

00:37:21,880 --> 00:37:26,320
feeling with that and there's so many

00:37:24,100 --> 00:37:26,650
race conditions in Pete races we can

00:37:26,320 --> 00:37:32,230
money

00:37:26,650 --> 00:37:35,430
yeah we can kill it piece by piece give

00:37:32,230 --> 00:37:35,430
it a slow death yeah

00:37:41,730 --> 00:37:48,189
[Applause]

00:37:52,740 --> 00:37:54,800

YouTube URL: https://www.youtube.com/watch?v=hQmt4bTL4Uk


