Title: LPC2018 - Enhancing perf to export processor hazard information
Publication date: 2018-12-04
Playlist: LPC2018 - LPC Main Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/76/
speaker:  Madhavan Srinivasan (IBM)


Most modern microprocessors employ complex instruction execution pipelines such that many instructions can be 'in flight' at any given point in time. The efficiency of this pipelining is typically measured in how many instructions get completed per CPU cycle and the metric gets variously called as Instructions Per Cycle (IPC) or the inverse metric Cycles Per Instruction (CPI). Various factors affect this metric and hazards are the primary among them. Different types of hazards exist - Data hazards, Structural hazards and Control hazards. Data hazard is the case where data dependencies exist between instructions in different stages in the pipeline. Structural hazard is when the same processor hardware is needed by more than one instruction in flight at the same time. Control hazards are more the branch misprediction kinds. Information about these hazards are critical towards analyzing performance issues and also to tune software to overcome such issues. Modern processors export such hazard data in Performance Monitoring Unit (PMU) registers. In this talk, we propose an arch neutral extension to perf to export the hazard data presented in different ways by different architectures. We also present how this extension has been applied to the IBM Power processor, the APIs and example output.
Captions: 
	00:00:05,650 --> 00:00:11,240
I said I'm modern Schneerson I work for

00:00:08,990 --> 00:00:13,309
IBM at the next Technology Center so

00:00:11,240 --> 00:00:15,889
today's presentation is about how to

00:00:13,309 --> 00:00:19,040
expose some of the crosser hazard data

00:00:15,889 --> 00:00:20,930
by a puff to user space so what are the

00:00:19,040 --> 00:00:24,829
plumbing is that we could name we may

00:00:20,930 --> 00:00:27,470
need and we can get it done and things

00:00:24,829 --> 00:00:35,000
and with a sample implementation in

00:00:27,470 --> 00:00:36,710
power so yeah so to start with I give up

00:00:35,000 --> 00:00:39,560
wanted to give a brief instruction about

00:00:36,710 --> 00:00:42,170
what is what its processor pipeline is

00:00:39,560 --> 00:00:44,630
what are the issues that you were going

00:00:42,170 --> 00:00:47,540
to what issues we are seeing how that

00:00:44,630 --> 00:00:51,770
could impact the stall cycles which

00:00:47,540 --> 00:00:54,110
impacts the road and then how we narrow

00:00:51,770 --> 00:00:56,329
it down or how do we get those data from

00:00:54,110 --> 00:00:58,520
the hardware pmu that a different

00:00:56,329 --> 00:01:01,670
platform provides and it's supposed that

00:00:58,520 --> 00:01:03,380
by up of a pas and finally I want to

00:01:01,670 --> 00:01:04,850
close it a sample screenshots of

00:01:03,380 --> 00:01:09,920
different tools optimizations that we

00:01:04,850 --> 00:01:13,120
did things in there so instruction

00:01:09,920 --> 00:01:17,600
cycles so the basic instruction pipeline

00:01:13,120 --> 00:01:20,810
says that we have a fetch unit which

00:01:17,600 --> 00:01:22,430
fetches the opcode it's then it decodes

00:01:20,810 --> 00:01:24,470
to know what kind of what class of

00:01:22,430 --> 00:01:26,479
instruction it is it's a root store

00:01:24,470 --> 00:01:29,270
branch or whatever and so it's a load

00:01:26,479 --> 00:01:32,210
store or ALU or things in there and then

00:01:29,270 --> 00:01:34,250
it then goes and fetches the operands or

00:01:32,210 --> 00:01:37,520
options could be the registers or memory

00:01:34,250 --> 00:01:41,000
and then it start executing it in the

00:01:37,520 --> 00:01:42,920
execute in the logic and finally it goes

00:01:41,000 --> 00:01:44,979
back and writes the results either

00:01:42,920 --> 00:01:48,890
intermembrane or into the register store

00:01:44,979 --> 00:01:52,939
so this is the set of basic instruction

00:01:48,890 --> 00:01:56,030
pipeline that we have read about and in

00:01:52,939 --> 00:01:57,770
today's process I goes our process are

00:01:56,030 --> 00:02:03,409
much more advanced and sophisticated

00:01:57,770 --> 00:02:06,310
where they have more more advanced

00:02:03,409 --> 00:02:09,289
sophisticated pipeline or super squares

00:02:06,310 --> 00:02:12,129
data so one thing is that they have

00:02:09,289 --> 00:02:15,049
multiple parallel executions they also

00:02:12,129 --> 00:02:18,200
have multiple stages within two

00:02:15,049 --> 00:02:19,629
executions and with speculation and out

00:02:18,200 --> 00:02:22,420
of order execution

00:02:19,629 --> 00:02:24,819
in there so this is all try to see

00:02:22,420 --> 00:02:27,370
whether we can improve our instructions

00:02:24,819 --> 00:02:30,040
per cycle in the process thereby we can

00:02:27,370 --> 00:02:32,170
achieve more of a throughput with the

00:02:30,040 --> 00:02:37,420
common process with dope loading things

00:02:32,170 --> 00:02:39,550
in there so but this there's an simple

00:02:37,420 --> 00:02:42,730
example of how the current opponent

00:02:39,550 --> 00:02:45,040
generation works and how so this you can

00:02:42,730 --> 00:02:47,620
see there is a pretty code we have

00:02:45,040 --> 00:02:49,180
branch slides which talks about whether

00:02:47,620 --> 00:02:52,630
the speculation in what direction we

00:02:49,180 --> 00:02:54,700
have to take it as multiple L use and it

00:02:52,630 --> 00:02:57,790
goes back and writes the data to

00:02:54,700 --> 00:03:00,760
different nu and then it does store

00:02:57,790 --> 00:03:03,400
forwarding things so real all this

00:03:00,760 --> 00:03:06,510
sophistication gets you to the point

00:03:03,400 --> 00:03:09,810
where we can improve our instructions

00:03:06,510 --> 00:03:12,400
throughput by saying that we reduce the

00:03:09,810 --> 00:03:13,989
stall cycles so that the application

00:03:12,400 --> 00:03:18,310
directly impacts and improves the

00:03:13,989 --> 00:03:19,360
performance in there right but it's not

00:03:18,310 --> 00:03:24,690
in reality

00:03:19,360 --> 00:03:27,370
we don't get the idea of me having a

00:03:24,690 --> 00:03:30,130
nominal rate of instruction per cycle of

00:03:27,370 --> 00:03:32,530
one so that's kind of the ideal goal

00:03:30,130 --> 00:03:34,660
where everything will look like so what

00:03:32,530 --> 00:03:38,650
we want to do in there but because of

00:03:34,660 --> 00:03:40,450
different pipeline issues like if the

00:03:38,650 --> 00:03:42,280
pipeline is not balanced I mean if the

00:03:40,450 --> 00:03:43,840
different units have different stages in

00:03:42,280 --> 00:03:45,310
there and pipeline in different

00:03:43,840 --> 00:03:49,030
combinations then you are going to have

00:03:45,310 --> 00:03:50,769
different cycles duration and you have

00:03:49,030 --> 00:03:53,019
to balance it out and you have to do

00:03:50,769 --> 00:03:57,160
that and there are cases where you have

00:03:53,019 --> 00:03:59,319
two instructions which cannot go forward

00:03:57,160 --> 00:04:01,630
because it was waiting for either for

00:03:59,319 --> 00:04:03,880
the data or it's waiting for the

00:04:01,630 --> 00:04:06,250
previous exclusion instruction to give

00:04:03,880 --> 00:04:08,470
it the data out so all this going to

00:04:06,250 --> 00:04:10,569
increase the weight cycle in the

00:04:08,470 --> 00:04:12,910
processor to execute the instruction so

00:04:10,569 --> 00:04:15,700
whenever there is a weight cycle it

00:04:12,910 --> 00:04:18,609
actually reduces your instructions per

00:04:15,700 --> 00:04:20,919
cycle ratio and which incurs which in

00:04:18,609 --> 00:04:24,610
turn reduces the ocular performance in

00:04:20,919 --> 00:04:26,470
there so primarily some of these areas

00:04:24,610 --> 00:04:30,460
where this could potentially be happen

00:04:26,470 --> 00:04:32,510
is the hazards is what we call and that

00:04:30,460 --> 00:04:35,870
is primarily the reason for reducing

00:04:32,510 --> 00:04:37,270
the instructions per cycle so what are

00:04:35,870 --> 00:04:40,310
hazards others are nothing but

00:04:37,270 --> 00:04:42,020
instruction which stops the next

00:04:40,310 --> 00:04:45,580
instruction to execute you know dis

00:04:42,020 --> 00:04:48,020
again cycle so it has we basically

00:04:45,580 --> 00:04:50,930
categorized that as three major

00:04:48,020 --> 00:04:53,390
categories one is execution

00:04:50,930 --> 00:04:55,490
I mean structuralism which is nothing

00:04:53,390 --> 00:04:57,590
but where the two or more instructions

00:04:55,490 --> 00:04:59,720
trying to get the same hardware at the

00:04:57,590 --> 00:05:02,060
same time so at this point it has to

00:04:59,720 --> 00:05:04,610
stall or it just to wait the further on

00:05:02,060 --> 00:05:06,470
to complete and write back and so that

00:05:04,610 --> 00:05:08,300
interest can start exuding in there and

00:05:06,470 --> 00:05:10,010
then comes the next which is the

00:05:08,300 --> 00:05:11,900
controllers it where this is more of a

00:05:10,010 --> 00:05:13,070
condition to predicting and saying that

00:05:11,900 --> 00:05:14,780
okay this is the direction we are going

00:05:13,070 --> 00:05:17,000
to take and start reaching from there

00:05:14,780 --> 00:05:19,010
and if the branch misses then it's a

00:05:17,000 --> 00:05:20,810
penalty where we have to go and fetch

00:05:19,010 --> 00:05:23,210
totally a different direction and get it

00:05:20,810 --> 00:05:26,000
back in there so we could hide some of

00:05:23,210 --> 00:05:27,470
these because we have a lot of our

00:05:26,000 --> 00:05:29,960
executions and we have a lot of

00:05:27,470 --> 00:05:32,420
in-flight instructions where we can

00:05:29,960 --> 00:05:34,580
actually hide some of these Latin Z's in

00:05:32,420 --> 00:05:37,190
there but still some of in some cases if

00:05:34,580 --> 00:05:39,610
the data is coming from a way from

00:05:37,190 --> 00:05:41,990
memory then it will show up in your

00:05:39,610 --> 00:05:43,970
profiling things in there and finally

00:05:41,990 --> 00:05:45,560
the data hazards are the ones which has

00:05:43,970 --> 00:05:50,300
a lot of dependencies from the

00:05:45,560 --> 00:05:54,290
instruction so instrument going poor so

00:05:50,300 --> 00:05:59,000
yeah so what we can use and how the

00:05:54,290 --> 00:06:01,790
hardware can help here so IBM has even

00:05:59,000 --> 00:06:05,510
power has a sampling mechanism where it

00:06:01,790 --> 00:06:07,670
can mark an instruction and collect data

00:06:05,510 --> 00:06:08,780
out of it and when you see mark an

00:06:07,670 --> 00:06:11,060
instruction you can actually look

00:06:08,780 --> 00:06:13,430
through the instruction code with

00:06:11,060 --> 00:06:15,080
lifestyle next time in the pipeline so

00:06:13,430 --> 00:06:17,030
this gives you a lot of information of

00:06:15,080 --> 00:06:19,640
what are the kind of hazards it maintain

00:06:17,030 --> 00:06:22,190
whether it had stars whether it had

00:06:19,640 --> 00:06:24,590
hazards in case of issuing or it has

00:06:22,190 --> 00:06:26,900
hazards in case of executing it where it

00:06:24,590 --> 00:06:29,180
was waiting for so many things so all

00:06:26,900 --> 00:06:32,060
this information is possible to and its

00:06:29,180 --> 00:06:35,630
provides these information entry set of

00:06:32,060 --> 00:06:37,220
registers the instruction event register

00:06:35,630 --> 00:06:40,850
is the one which gives you a lot of

00:06:37,220 --> 00:06:43,720
mapping in case of data from say whether

00:06:40,850 --> 00:06:43,720
it is from

00:06:44,480 --> 00:06:49,180
the register which provides the

00:06:46,310 --> 00:06:53,150
information for these hazard

00:06:49,180 --> 00:06:55,040
conditions and MD also has something

00:06:53,150 --> 00:06:58,400
called IBS instruction based sampling

00:06:55,040 --> 00:07:00,560
which primarily gives you two kinds of

00:06:58,400 --> 00:07:03,710
you can categorize that in two kinds of

00:07:00,560 --> 00:07:05,690
ways one is the fetch data there it

00:07:03,710 --> 00:07:07,460
actually gives you what other fetch

00:07:05,690 --> 00:07:09,920
whether the Fate went in fine whether

00:07:07,460 --> 00:07:11,540
there was a cancellation in that case

00:07:09,920 --> 00:07:14,420
what is the cycles from which to

00:07:11,540 --> 00:07:16,790
complete and the next set of next

00:07:14,420 --> 00:07:18,830
category of IBS information is that it

00:07:16,790 --> 00:07:19,190
actually gives you out information about

00:07:18,830 --> 00:07:22,250
how the

00:07:19,190 --> 00:07:24,860
exude so hop execution gives you

00:07:22,250 --> 00:07:28,490
information about whether it was it had

00:07:24,860 --> 00:07:30,110
any D kashmiris whether it had any Tilby

00:07:28,490 --> 00:07:32,620
measures whether it had information

00:07:30,110 --> 00:07:36,650
whether it has any stalls in there so

00:07:32,620 --> 00:07:39,620
the information IBS provides has some

00:07:36,650 --> 00:07:41,480
similarities in there so which can be

00:07:39,620 --> 00:07:48,050
connected to get the data in case of

00:07:41,480 --> 00:07:50,810
hazards so now wipe off right so puffs

00:07:48,050 --> 00:07:53,150
is the community tool and it is most the

00:07:50,810 --> 00:07:55,610
eco system users and it also provides

00:07:53,150 --> 00:07:57,350
you plumbing for hardware monitor

00:07:55,610 --> 00:07:58,580
performance monitoring unit so that

00:07:57,350 --> 00:08:01,910
gives you information about how we

00:07:58,580 --> 00:08:03,230
hardware is be giving so that with but

00:08:01,910 --> 00:08:06,950
from that it also gives you information

00:08:03,230 --> 00:08:08,630
on how I mean it gives you generate

00:08:06,950 --> 00:08:10,430
reports and we can look at it for

00:08:08,630 --> 00:08:12,230
annotating the instruction sequence and

00:08:10,430 --> 00:08:16,780
things in the day so it's like wait and

00:08:12,230 --> 00:08:19,610
pass and it's a lot more convenient so

00:08:16,780 --> 00:08:21,919
why add other information in puffs right

00:08:19,610 --> 00:08:24,260
so posted a give you or gives you

00:08:21,919 --> 00:08:28,419
information about exporting memory

00:08:24,260 --> 00:08:32,180
sampling so both today can get you how

00:08:28,419 --> 00:08:33,589
memory instruction went in memory

00:08:32,180 --> 00:08:36,349
instruction meaning it can be a load of

00:08:33,589 --> 00:08:40,539
store saying whether load store data

00:08:36,349 --> 00:08:43,460
fetch had any translation miss whether

00:08:40,539 --> 00:08:46,370
whether it the memory came from whether

00:08:43,460 --> 00:08:48,800
the local cache in an l2 l3 or local

00:08:46,370 --> 00:08:51,580
memory this has some moment of

00:08:48,800 --> 00:08:55,040
information to tell you what kind of

00:08:51,580 --> 00:08:56,060
stalls we had and how many cycles it had

00:08:55,040 --> 00:08:59,870
because

00:08:56,060 --> 00:09:01,850
it also gives you the latency of miss to

00:08:59,870 --> 00:09:06,710
reload so that gives you a lot of

00:09:01,850 --> 00:09:09,410
information on where the data came

00:09:06,710 --> 00:09:13,310
coming from and how long it took to get

00:09:09,410 --> 00:09:16,850
the data and put it in there so this has

00:09:13,310 --> 00:09:19,820
some moment of plumbing to get some of

00:09:16,850 --> 00:09:25,810
the information for load and store

00:09:19,820 --> 00:09:29,750
instructions right so now can we extend

00:09:25,810 --> 00:09:32,360
them of memory data source to include

00:09:29,750 --> 00:09:35,330
more of the holiday des so one of the

00:09:32,360 --> 00:09:37,880
key things is that mem data source is

00:09:35,330 --> 00:09:43,880
primarily intended for load stores and

00:09:37,880 --> 00:09:48,440
it also has it also is to say it also

00:09:43,880 --> 00:09:51,860
has or committed with Sony information

00:09:48,440 --> 00:09:54,980
in case of the levels of memory the

00:09:51,860 --> 00:09:59,120
mechanism of logs expose exporting the

00:09:54,980 --> 00:10:01,339
lock information even for the data

00:09:59,120 --> 00:10:04,550
that's coming from different ops whether

00:10:01,339 --> 00:10:08,120
it can be load or store things in there

00:10:04,550 --> 00:10:10,250
so when if you want to add more or or

00:10:08,120 --> 00:10:13,160
load that to further to include a

00:10:10,250 --> 00:10:15,500
pipeline stage or reason we had we don't

00:10:13,160 --> 00:10:18,339
have enough bits in there and that could

00:10:15,500 --> 00:10:20,390
complicate some more handling in case of

00:10:18,339 --> 00:10:23,230
flexibility to give you what are the

00:10:20,390 --> 00:10:26,780
stages that if you want to predict so

00:10:23,230 --> 00:10:28,640
one of the so the proposal here is to

00:10:26,780 --> 00:10:31,910
see whether we can actually look at a

00:10:28,640 --> 00:10:34,910
different way of doing things like so

00:10:31,910 --> 00:10:36,920
can we have a different structure with

00:10:34,910 --> 00:10:40,130
which we can collect more information

00:10:36,920 --> 00:10:44,000
from the hardware source and get the

00:10:40,130 --> 00:10:47,180
same with a specific format like what we

00:10:44,000 --> 00:10:49,670
had in data source we have a format and

00:10:47,180 --> 00:10:52,010
that gives you a option to collect all

00:10:49,670 --> 00:10:56,839
the hazard based information along with

00:10:52,010 --> 00:11:00,650
other options from buffer Cod so a data

00:10:56,839 --> 00:11:04,400
sample implementation in power to get

00:11:00,650 --> 00:11:05,800
the same data in case of hazard so this

00:11:04,400 --> 00:11:09,459
is a

00:11:05,800 --> 00:11:12,250
of rapport with information of getting a

00:11:09,459 --> 00:11:14,620
small upload where we where I made sure

00:11:12,250 --> 00:11:16,509
that we don't have some instruction

00:11:14,620 --> 00:11:18,790
having multiple hazards our same

00:11:16,509 --> 00:11:20,980
instruction does not appear to Rhymes in

00:11:18,790 --> 00:11:25,540
the same record file right so this day

00:11:20,980 --> 00:11:29,439
by I also have different sort sequence I

00:11:25,540 --> 00:11:32,319
included couple of news slot sequence to

00:11:29,439 --> 00:11:34,240
say okay I want to read it in based of

00:11:32,319 --> 00:11:37,029
the instruction class or what are the

00:11:34,240 --> 00:11:39,430
hazard stages it went in or what what

00:11:37,029 --> 00:11:41,709
kind of a reason or it is and whether

00:11:39,430 --> 00:11:43,029
the instruction had any stalls and if it

00:11:41,709 --> 00:11:47,769
is stalls what is the reason for the

00:11:43,029 --> 00:11:49,230
stall is so this this primont this will

00:11:47,769 --> 00:11:52,269
get you information on how the

00:11:49,230 --> 00:11:55,839
application or how the current workload

00:11:52,269 --> 00:12:00,160
is looking at but this can be enhanced

00:11:55,839 --> 00:12:03,850
with annotate where we where we

00:12:00,160 --> 00:12:06,399
currently give you information on the

00:12:03,850 --> 00:12:08,980
cycles along with the instruction and

00:12:06,399 --> 00:12:11,560
mnemonics so in case of ABR we also

00:12:08,980 --> 00:12:14,439
provide an option another column where

00:12:11,560 --> 00:12:17,350
we give the cycles that took for the

00:12:14,439 --> 00:12:19,230
from the previous branch to this in case

00:12:17,350 --> 00:12:21,880
of hazard we can actually include

00:12:19,230 --> 00:12:25,329
whether the instruction had any hazards

00:12:21,880 --> 00:12:30,579
in the pipeline which it cost and which

00:12:25,329 --> 00:12:33,220
it came out from so this is the core

00:12:30,579 --> 00:12:36,459
data structure that I'm proposing to see

00:12:33,220 --> 00:12:38,560
whether we can include the hazard

00:12:36,459 --> 00:12:40,949
information in there so primarily it has

00:12:38,560 --> 00:12:43,449
a class information where it gives you

00:12:40,949 --> 00:12:45,670
whether the instruction is a load store

00:12:43,449 --> 00:12:50,769
instruction or it's a branch or it's a

00:12:45,670 --> 00:12:52,540
vector it can also have type whether

00:12:50,769 --> 00:12:54,939
it's a single cycle point multi cycle

00:12:52,540 --> 00:12:56,860
instruction then what is the hierarchy

00:12:54,939 --> 00:12:58,809
in case of I cache where the data came

00:12:56,860 --> 00:13:02,279
from I mean where the instruction came

00:12:58,809 --> 00:13:05,199
from apart from that I I want to include

00:13:02,279 --> 00:13:09,040
the hazard stages that's basically the

00:13:05,199 --> 00:13:12,370
pipeline stage where it is or how it can

00:13:09,040 --> 00:13:17,390
be categorized for different pipeline

00:13:12,370 --> 00:13:22,100
units and the reasons for it now

00:13:17,390 --> 00:13:24,490
not all of these can be are neutral but

00:13:22,100 --> 00:13:28,370
some of these can be are neutral so

00:13:24,490 --> 00:13:29,960
reason for is that each arc as they own

00:13:28,370 --> 00:13:32,990
and each processor has their own

00:13:29,960 --> 00:13:35,630
pipeline stages and we cannot combine we

00:13:32,990 --> 00:13:38,570
cannot have a neutral way of explaining

00:13:35,630 --> 00:13:41,570
saying that ok this is the set of units

00:13:38,570 --> 00:13:43,190
we can going to get it under plug it in

00:13:41,570 --> 00:13:45,740
plugging in there which is going to

00:13:43,190 --> 00:13:49,460
cause some breakage or flexibility for

00:13:45,740 --> 00:13:51,830
the other ops but the reasons like the

00:13:49,460 --> 00:13:54,950
eye cache or the class of instruction

00:13:51,830 --> 00:13:58,820
can be a common way so the method I'm

00:13:54,950 --> 00:14:01,460
proposing is to have a mixed version of

00:13:58,820 --> 00:14:05,330
having some of them to be arc neutral

00:14:01,460 --> 00:14:08,150
but some of them to be arc specific so

00:14:05,330 --> 00:14:10,570
this way we can collect we each arc will

00:14:08,150 --> 00:14:13,730
have the capability to have their own

00:14:10,570 --> 00:14:15,890
independent mechanism to say what are

00:14:13,730 --> 00:14:17,870
the things they want to include but they

00:14:15,890 --> 00:14:26,710
can also fuse the other data along in

00:14:17,870 --> 00:14:26,710
the arc neutrally so this

00:14:48,010 --> 00:14:56,000
instruction mocking okay so I mean we

00:14:54,230 --> 00:14:59,389
can from user space we can have specific

00:14:56,000 --> 00:15:02,750
up codes event codes for the PMU the

00:14:59,389 --> 00:15:05,389
Pima unit then has a specific law the

00:15:02,750 --> 00:15:07,579
logic in there where it takes that and

00:15:05,389 --> 00:15:09,260
specifically randomizers which

00:15:07,579 --> 00:15:10,850
instruction to look for you can either

00:15:09,260 --> 00:15:13,220
randomize it or you can specifically say

00:15:10,850 --> 00:15:15,290
this is the instruction type or class I

00:15:13,220 --> 00:15:17,649
want to look for and then the process

00:15:15,290 --> 00:15:20,329
and then the logic goes and looks to for

00:15:17,649 --> 00:15:22,579
for the entire pipeline stage and gets

00:15:20,329 --> 00:15:24,980
you the data out and that's it's

00:15:22,579 --> 00:15:27,050
provided using the SAR information so

00:15:24,980 --> 00:15:30,500
the ratio given Treister gives you the

00:15:27,050 --> 00:15:32,329
data of what are the different stages it

00:15:30,500 --> 00:15:34,880
went in and whether it had any stalls

00:15:32,329 --> 00:15:38,449
whether it has it had any hazards in

00:15:34,880 --> 00:15:39,769
there and IBS also does that AMD IBS

00:15:38,449 --> 00:15:42,490
also has some of these capabilities

00:15:39,769 --> 00:15:42,490
buildin

00:15:48,310 --> 00:15:54,560
so yeah so this so this slide is to

00:15:52,010 --> 00:15:56,960
primarily to say to region to the

00:15:54,560 --> 00:16:00,650
community to say that whether if we have

00:15:56,960 --> 00:16:03,290
an approach of doing not neutral and on

00:16:00,650 --> 00:16:05,360
specific information gathering for

00:16:03,290 --> 00:16:09,950
hazards in case of doing it because we

00:16:05,360 --> 00:16:12,350
in case of perf mem we could able to

00:16:09,950 --> 00:16:13,790
generalize and have an arc neutral way

00:16:12,350 --> 00:16:16,070
of getting all the data in the memory

00:16:13,790 --> 00:16:18,410
hierarchy which give you which gives you

00:16:16,070 --> 00:16:20,920
the data from say if it is an l2 or l3

00:16:18,410 --> 00:16:23,630
and or most of the arc actually has that

00:16:20,920 --> 00:16:26,180
cache hierarchy in there so that becomes

00:16:23,630 --> 00:16:30,230
easy to plug those information into it

00:16:26,180 --> 00:16:32,470
but say in case of interrupt Riggs which

00:16:30,230 --> 00:16:34,940
is specific to architecture and

00:16:32,470 --> 00:16:37,880
interrupt bricks basically captures the

00:16:34,940 --> 00:16:39,560
PD regs at the time of its interrupt and

00:16:37,880 --> 00:16:41,750
gives that information to the user space

00:16:39,560 --> 00:16:44,960
and in this case it's very specific to

00:16:41,750 --> 00:16:48,290
arc and they have arc specific data for

00:16:44,960 --> 00:16:50,090
each of them in there so by having a

00:16:48,290 --> 00:16:53,330
mixed method of doing it where we have

00:16:50,090 --> 00:16:55,790
both arc neutral and art specific we

00:16:53,330 --> 00:17:02,540
could try to get both of these to be

00:16:55,790 --> 00:17:05,030
enabled and added for the hazard so what

00:17:02,540 --> 00:17:07,430
are the enhancements so one of the key

00:17:05,030 --> 00:17:10,400
things is that we need to have a new

00:17:07,430 --> 00:17:12,680
format so that we can have mechanism to

00:17:10,400 --> 00:17:16,490
capture the data which is specific to

00:17:12,680 --> 00:17:19,190
hazard and we also need to have a way in

00:17:16,490 --> 00:17:20,980
a command line to explain to the user to

00:17:19,190 --> 00:17:23,780
provide that to say that okay we need

00:17:20,980 --> 00:17:26,209
hazard data to be captured where in this

00:17:23,780 --> 00:17:29,180
case I used Python H which was not used

00:17:26,209 --> 00:17:32,620
previously so there was matching in

00:17:29,180 --> 00:17:36,220
there so I used it and I also added a

00:17:32,620 --> 00:17:38,750
sample type to provide the data to the

00:17:36,220 --> 00:17:42,470
kernel to capture the information in

00:17:38,750 --> 00:17:45,140
there and in this case I used complete

00:17:42,470 --> 00:17:48,320
instruction which is nothing but red ops

00:17:45,140 --> 00:17:51,170
in case of Intel and AMD so this gives

00:17:48,320 --> 00:17:53,900
you this actually marks the instruction

00:17:51,170 --> 00:17:56,360
ran in a random way and start looking at

00:17:53,900 --> 00:17:58,730
the data coming out of that for each

00:17:56,360 --> 00:18:00,890
sample it gets so this gives you an

00:17:58,730 --> 00:18:03,110
option to provide the capture that

00:18:00,890 --> 00:18:08,780
for each and every instruction it looks

00:18:03,110 --> 00:18:12,530
for the pipeline in there so I also

00:18:08,780 --> 00:18:15,380
added a support to dump the data from

00:18:12,530 --> 00:18:18,110
the counters so that I can look for it

00:18:15,380 --> 00:18:20,510
if it needs it as as as we do it for

00:18:18,110 --> 00:18:23,780
other of the options in DES so currently

00:18:20,510 --> 00:18:25,640
I mean with puff D we have capability to

00:18:23,780 --> 00:18:27,470
dump all of the hazard information and

00:18:25,640 --> 00:18:35,660
then we can post process it using puff

00:18:27,470 --> 00:18:38,420
scripts or things in there so finally we

00:18:35,660 --> 00:18:41,240
have added a new mode where it talks

00:18:38,420 --> 00:18:43,880
about hazard information something

00:18:41,240 --> 00:18:46,970
similar to puff mem mem for which

00:18:43,880 --> 00:18:51,680
categorizes the data to be in a specific

00:18:46,970 --> 00:18:53,750
format to present it out in the user for

00:18:51,680 --> 00:18:57,560
user to get it out and present it in a

00:18:53,750 --> 00:19:00,290
nice way and it also has different sort

00:18:57,560 --> 00:19:02,260
types to help out to say that okay I

00:19:00,290 --> 00:19:07,130
wanted to be in the direction of other

00:19:02,260 --> 00:19:08,870
reasons or reasons and other cases for

00:19:07,130 --> 00:19:11,300
that so this gives you a focused

00:19:08,870 --> 00:19:15,790
presentation on other data alone and

00:19:11,300 --> 00:19:15,790
gives the information to the user so

00:19:16,180 --> 00:19:22,690
that's something the buying legal team

00:19:19,070 --> 00:19:25,690
wanted to put me out there so yeah so

00:19:22,690 --> 00:19:25,690
questions

00:19:31,370 --> 00:19:35,760
you're proposing putting these pipeline

00:19:33,360 --> 00:19:37,770
stages in an art specific cutter it

00:19:35,760 --> 00:19:39,660
seems to be assuming that every single

00:19:37,770 --> 00:19:41,760
processor within an architecture is

00:19:39,660 --> 00:19:48,600
going to have the same definitions for

00:19:41,760 --> 00:19:50,250
this thing what makes the pipeline

00:19:48,600 --> 00:19:56,430
stages architecture specific rather than

00:19:50,250 --> 00:19:59,760
processor specific so in case of so

00:19:56,430 --> 00:20:02,550
since these are more of a superscalar

00:19:59,760 --> 00:20:05,130
some of them doesn't support say vector

00:20:02,550 --> 00:20:07,560
for in case of intel intel has a VX and

00:20:05,130 --> 00:20:09,570
the wider pipeline information in there

00:20:07,560 --> 00:20:11,940
but power doesn't support them arm

00:20:09,570 --> 00:20:12,600
doesn't support them so these logic in

00:20:11,940 --> 00:20:17,310
pipelines

00:20:12,600 --> 00:20:19,710
either is is the if the intent is to get

00:20:17,310 --> 00:20:22,050
the raw data and just have that match

00:20:19,710 --> 00:20:24,120
your enumerations then you're gonna have

00:20:22,050 --> 00:20:26,370
problems of incompatibility of encoding

00:20:24,120 --> 00:20:28,500
from one processor to another whereas if

00:20:26,370 --> 00:20:32,640
you're gonna translate it into you know

00:20:28,500 --> 00:20:34,560
an established enumeration then why do

00:20:32,640 --> 00:20:37,560
you need to separate it out into arches

00:20:34,560 --> 00:20:39,990
and so what if the Nanako teacher

00:20:37,560 --> 00:20:43,110
specific file has the maneuvers that are

00:20:39,990 --> 00:20:45,540
used yeah so I'm open for it so we could

00:20:43,110 --> 00:20:47,880
have some abstraction on or on the

00:20:45,540 --> 00:20:49,710
stages that we want to do and then we

00:20:47,880 --> 00:20:51,390
can then we can abstract it to say that

00:20:49,710 --> 00:20:52,590
these specific stages could be plugged

00:20:51,390 --> 00:20:56,540
in for the architecture in there yeah

00:20:52,590 --> 00:20:56,540
that's another way of doing yeah

00:21:00,420 --> 00:21:04,980
so I see you're kind of like providing

00:21:02,700 --> 00:21:06,990
more simple information as compared with

00:21:04,980 --> 00:21:09,570
the existing one which probably provide

00:21:06,990 --> 00:21:12,330
the average data I want understanding

00:21:09,570 --> 00:21:14,370
how using this template wizard to

00:21:12,330 --> 00:21:17,190
actually improve the performance of your

00:21:14,370 --> 00:21:18,809
software one thing is that you can

00:21:17,190 --> 00:21:21,960
actually that gives you information on

00:21:18,809 --> 00:21:23,730
the current so own anything examples

00:21:21,960 --> 00:21:25,860
that that can be missed that may not

00:21:23,730 --> 00:21:28,140
happen frequently or in turn excitation

00:21:25,860 --> 00:21:29,400
so one way of looking at is that some of

00:21:28,140 --> 00:21:30,960
the information that gives you

00:21:29,400 --> 00:21:34,080
information on what is the current load

00:21:30,960 --> 00:21:36,870
in the processor and but in case of when

00:21:34,080 --> 00:21:39,929
you look at data for say and cache miss

00:21:36,870 --> 00:21:44,250
or dcashman sauron cache - that gives

00:21:39,929 --> 00:21:45,750
you where the location for the your

00:21:44,250 --> 00:21:47,790
variables things in there that can be

00:21:45,750 --> 00:21:49,559
optimized and pull it in in there so

00:21:47,790 --> 00:21:51,710
that gives some of them it doesn't all

00:21:49,559 --> 00:21:54,450
of this doesn't map through all the

00:21:51,710 --> 00:21:56,280
application performance but some of them

00:21:54,450 --> 00:21:59,030
do map and some gives you what is the

00:21:56,280 --> 00:21:59,030
current load in the pipeline

00:22:03,380 --> 00:22:08,100
yeah that's a good way so I'm currently

00:22:06,000 --> 00:22:10,320
working on getting these data and

00:22:08,100 --> 00:22:18,090
processing it to see whether how much I

00:22:10,320 --> 00:22:20,250
can get in there but yeah so these could

00:22:18,090 --> 00:22:22,380
potentially feed back to the compiler or

00:22:20,250 --> 00:22:23,549
at runtime to say that of what what are

00:22:22,380 --> 00:22:28,440
the things that we can actually plug in

00:22:23,549 --> 00:22:30,149
as a parameter to get it out in there so

00:22:28,440 --> 00:22:42,510
my question is actually very similar to

00:22:30,149 --> 00:22:44,820
what so and so it doesn't map all each

00:22:42,510 --> 00:22:47,309
each of them on on one mapping it may

00:22:44,820 --> 00:22:49,440
not be there but some of them too can

00:22:47,309 --> 00:22:57,000
can be used to understand how the data

00:22:49,440 --> 00:22:58,350
structure that happens in there and also

00:22:57,000 --> 00:23:00,179
at run time you can understand how the

00:22:58,350 --> 00:23:01,830
process is loaded and how it is in there

00:23:00,179 --> 00:23:07,830
and why it is cache misses happening or

00:23:01,830 --> 00:23:13,860
why the TLB is missing in there this

00:23:07,830 --> 00:23:16,049
work applicable to x86 it's so one of

00:23:13,860 --> 00:23:20,010
the key information that we will need is

00:23:16,049 --> 00:23:22,409
the the hardware has to give you some

00:23:20,010 --> 00:23:24,870
amount of data to plumb it out so in

00:23:22,409 --> 00:23:27,600
case of x86 they look at top-down model

00:23:24,870 --> 00:23:30,600
of having performance analysis where

00:23:27,600 --> 00:23:33,510
they do the same calculation but they

00:23:30,600 --> 00:23:35,070
get it doesn't have to I don't know

00:23:33,510 --> 00:23:36,960
exactly whether I can speak for Intel

00:23:35,070 --> 00:23:39,539
but as far as my understanding they

00:23:36,960 --> 00:23:42,360
don't have sampling mechanism to export

00:23:39,539 --> 00:23:45,029
this data to each sample but with the

00:23:42,360 --> 00:23:47,880
recent process out they do have matrix

00:23:45,029 --> 00:23:49,860
where for specifically for top-down

00:23:47,880 --> 00:23:52,200
matrix where they give you percentage of

00:23:49,860 --> 00:23:54,419
how much the bad speculation happened or

00:23:52,200 --> 00:23:57,299
how much different install was how much

00:23:54,419 --> 00:23:59,279
the back install and what is your

00:23:57,299 --> 00:24:01,139
control loop in this so that's is that

00:23:59,279 --> 00:24:03,450
is something that also captures the

00:24:01,139 --> 00:24:05,429
hazard but that's more of a freaking

00:24:03,450 --> 00:24:07,810
Friedan encounters it is it's not for

00:24:05,429 --> 00:24:12,880
each sample

00:24:07,810 --> 00:24:18,070
you cannot distribute it through the

00:24:12,880 --> 00:24:20,320
court which is running we can associated

00:24:18,070 --> 00:24:23,110
with it but you cannot look at it for

00:24:20,320 --> 00:24:24,870
say a different time zone I mean a

00:24:23,110 --> 00:24:27,430
different time in the pipe in the

00:24:24,870 --> 00:24:29,050
application running so when you are

00:24:27,430 --> 00:24:30,910
running it when you're running when

00:24:29,050 --> 00:24:32,920
you're doing suffering you politically

00:24:30,910 --> 00:24:34,840
interrupt to see how much you what is

00:24:32,920 --> 00:24:36,250
the state of it and gets in there but in

00:24:34,840 --> 00:24:38,980
case of free running counters you

00:24:36,250 --> 00:24:40,810
actually look at it on every context

00:24:38,980 --> 00:24:44,850
switch or primarily in a context switch

00:24:40,810 --> 00:24:44,850
or at the end of it and things in there

00:24:48,210 --> 00:24:58,140
continue in your question the top-down

00:24:52,090 --> 00:25:00,910
but is talking about is a

00:24:58,140 --> 00:25:03,010
characterization methodology it tells

00:25:00,910 --> 00:25:13,360
you you have 20% from 10 bound or

00:25:03,010 --> 00:25:15,520
something like this where happened to

00:25:13,360 --> 00:25:17,710
collect a metric like from 10 bound you

00:25:15,520 --> 00:25:20,380
may have to combine multiple events to

00:25:17,710 --> 00:25:22,960
get that metric and you cannot sample on

00:25:20,380 --> 00:25:26,230
a difference of events or an addition of

00:25:22,960 --> 00:25:28,150
advance ok so the top down there trying

00:25:26,230 --> 00:25:30,340
to improve this and if you look at the

00:25:28,150 --> 00:25:32,830
top down spreadsheet you will see that

00:25:30,340 --> 00:25:34,030
there is a way they try to map you say

00:25:32,830 --> 00:25:36,070
if you want to figure out where you are

00:25:34,030 --> 00:25:37,600
front end bound then you try to sample

00:25:36,070 --> 00:25:39,160
on this event they give you an event

00:25:37,600 --> 00:25:42,760
that you can sample a single event where

00:25:39,160 --> 00:25:46,540
you can sample now to get back to this

00:25:42,760 --> 00:25:49,570
presentation I think you need to to

00:25:46,540 --> 00:25:53,170
validate it by trying to support the MD

00:25:49,570 --> 00:25:57,390
IBS that would validate the approach can

00:25:53,170 --> 00:26:00,460
we use it in more than one architecture

00:25:57,390 --> 00:26:03,280
that would be a useful thing to do

00:26:00,460 --> 00:26:06,060
because right now the IBS is exported

00:26:03,280 --> 00:26:09,390
grow we don't have that level of

00:26:06,060 --> 00:26:11,860
information it's it's wrong

00:26:09,390 --> 00:26:13,690
yeah that could be one thing which I

00:26:11,860 --> 00:26:14,680
will look at when I post a lot of space

00:26:13,690 --> 00:26:15,890
for all these things so that I can

00:26:14,680 --> 00:26:19,130
capture it

00:26:15,890 --> 00:26:21,530
this kind of output to say hey is the

00:26:19,130 --> 00:26:23,480
instruction at the top the one I need to

00:26:21,530 --> 00:26:26,420
focus my attention on is it the one that

00:26:23,480 --> 00:26:27,830
is causing me the most trouble and I

00:26:26,420 --> 00:26:30,860
don't think you can conclude from this

00:26:27,830 --> 00:26:39,559
that this is the one that is causing the

00:26:30,860 --> 00:26:42,740
most trouble but but yeah income some

00:26:39,559 --> 00:26:50,090
cases we need to have even the day mmm

00:26:42,740 --> 00:26:52,100
dead also yeah so this doesn't include

00:26:50,090 --> 00:26:54,830
the cycles along with at the penalty

00:26:52,100 --> 00:27:07,280
what we're talking about here because of

00:26:54,830 --> 00:27:11,390
this yeah yes yeah but that is something

00:27:07,280 --> 00:27:13,669
obvious but I just

00:27:11,390 --> 00:27:23,230
I think MD IBS does gives you

00:27:13,669 --> 00:27:23,230
information on more questions

00:27:24,320 --> 00:27:27,500
if not let's think so speaker and don't

00:27:26,540 --> 00:27:29,740
eat up too much of the lunch the other

00:27:27,500 --> 00:27:29,740

YouTube URL: https://www.youtube.com/watch?v=6hIFkjYiTmE


