Title: LPC2019   printk  Why is it so complicated
Publication date: 2019-11-18
Playlist: LPC2018 - LPC Main Track
Description: 
	The printk() function has a long history of issues and has undergone many iterations to improve performance and reliability. Yet it is still not an acceptable solution to reliably allow the kernel to send detailed information to the user. And these problems are even magnified when using a real-time system. So why is printk() so complicated and why are we having such a hard time finding a good solution?

This talk will briefly cover the history of printk() and why the recent major rework was necessary. It will go through the details of the rework and why we believe it solves many of the issues. And it will present the issues still not solved (such as fully synchronous console writing), why these issues are particularly complex and controversial, and review some of the proposed solutions for moving forward.

This talk may be of particular interest to developers with experience or interest in lockless ring buffers, memory barriers, and NMI-safe synchronization.


John Ogness (Linutronix GmbH)
Captions: 
	00:00:00,030 --> 00:00:05,510
hi so think we're ready to begin

00:00:06,799 --> 00:00:11,090
officially there's no emcee right now so

00:00:09,269 --> 00:00:15,049
I'm just going to introduce myself

00:00:11,090 --> 00:00:15,049
do we need to shut the door in the back

00:00:17,449 --> 00:00:26,640
someone's got it great okay

00:00:24,359 --> 00:00:28,920
my name is John Agnes I'm one of the

00:00:26,640 --> 00:00:32,250
happy hackers at Linn atronics in

00:00:28,920 --> 00:00:38,010
Germany and I'm here to talk about print

00:00:32,250 --> 00:00:40,980
Kane a slight disclaimer when I begin

00:00:38,010 --> 00:00:43,379
here we're doing actually we're working

00:00:40,980 --> 00:00:45,600
on re-engineering a lot of print K to

00:00:43,379 --> 00:00:47,850
address a lot of long-standing problems

00:00:45,600 --> 00:00:50,760
but none of the work that I am

00:00:47,850 --> 00:00:52,289
presenting here is mainline yet yeah so

00:00:50,760 --> 00:00:54,449
we've been working on this for a year

00:00:52,289 --> 00:00:56,789
and a half already but there is actually

00:00:54,449 --> 00:00:58,289
none of this in mainline yet lots and

00:00:56,789 --> 00:01:01,590
lots of patches and discussions on the

00:00:58,289 --> 00:01:04,880
mailing list so it could actually end up

00:01:01,590 --> 00:01:08,189
being different than we see here as well

00:01:04,880 --> 00:01:09,750
so the main thing about wise print K so

00:01:08,189 --> 00:01:11,909
complicated is and it's just a function

00:01:09,750 --> 00:01:13,740
that just prints something let's just

00:01:11,909 --> 00:01:15,330
maybe really quick take a look at what

00:01:13,740 --> 00:01:18,210
are the requirements actually of print K

00:01:15,330 --> 00:01:20,130
so you have the basic requirements that

00:01:18,210 --> 00:01:22,080
print K can be called from any context

00:01:20,130 --> 00:01:24,110
and scheduling context and in my context

00:01:22,080 --> 00:01:26,460
interrupts heart interrupt context

00:01:24,110 --> 00:01:28,950
that's a requirement these are simple

00:01:26,460 --> 00:01:31,049
requirements actually it stores messages

00:01:28,950 --> 00:01:32,970
into a rake buffer this ring buffer is

00:01:31,049 --> 00:01:35,610
then made available to user space for

00:01:32,970 --> 00:01:37,439
example syslog dev K message there's the

00:01:35,610 --> 00:01:39,329
key message dump facility so that if the

00:01:37,439 --> 00:01:42,630
machine crashes it can actually grab

00:01:39,329 --> 00:01:44,280
those logs and print k is also

00:01:42,630 --> 00:01:46,439
responsible responsible for pushing

00:01:44,280 --> 00:01:49,290
messages out on to the console which

00:01:46,439 --> 00:01:52,229
might be a graphic screen or a serial or

00:01:49,290 --> 00:01:55,560
network for example so those are the

00:01:52,229 --> 00:01:57,000
simple requirements actually here's

00:01:55,560 --> 00:02:00,899
where it starts to get complicated

00:01:57,000 --> 00:02:03,479
so we also would like our print k to not

00:02:00,899 --> 00:02:06,750
be missing any messages if we crash or

00:02:03,479 --> 00:02:09,840
hang or any reason right so if we're

00:02:06,750 --> 00:02:12,510
crashing in bizarre contexts when we're

00:02:09,840 --> 00:02:14,160
holding certain spin locks or some other

00:02:12,510 --> 00:02:17,250
exotic locks

00:02:14,160 --> 00:02:19,920
it might be really hard to actually get

00:02:17,250 --> 00:02:21,360
those messages stored so we might

00:02:19,920 --> 00:02:22,920
actually missing some messages when the

00:02:21,360 --> 00:02:26,040
Machine crashes they might actually not

00:02:22,920 --> 00:02:28,740
be in the ring buffer even we would also

00:02:26,040 --> 00:02:30,840
like that the console doesn't miss any

00:02:28,740 --> 00:02:33,270
messages right so if my machine crashes

00:02:30,840 --> 00:02:34,620
I would like to see what happened yeah I

00:02:33,270 --> 00:02:36,300
don't want to be I don't want to see

00:02:34,620 --> 00:02:38,340
nothingness or I don't want there to be

00:02:36,300 --> 00:02:40,770
missing messages right so this is also

00:02:38,340 --> 00:02:42,930
really important and the reason why this

00:02:40,770 --> 00:02:45,810
is so difficult is because the different

00:02:42,930 --> 00:02:47,910
console drivers they do a lot of

00:02:45,810 --> 00:02:51,360
interesting stuff you know where they're

00:02:47,910 --> 00:02:53,370
not thinking about that they might be

00:02:51,360 --> 00:02:55,200
being called from enemy context for

00:02:53,370 --> 00:02:57,240
example they don't think about this when

00:02:55,200 --> 00:02:59,430
they write these drivers things like the

00:02:57,240 --> 00:03:02,160
whole graphic subsystem or even doing

00:02:59,430 --> 00:03:04,110
the network console become really

00:03:02,160 --> 00:03:06,450
complicated if we're crashing into my

00:03:04,110 --> 00:03:09,180
context for example how could we even

00:03:06,450 --> 00:03:12,060
get that stuff out and then of course

00:03:09,180 --> 00:03:14,100
the big requirement which is then the

00:03:12,060 --> 00:03:16,110
the biggest one on the wish list is we

00:03:14,100 --> 00:03:18,120
don't want print hate to interfere the

00:03:16,110 --> 00:03:19,890
system at all right so we want to see

00:03:18,120 --> 00:03:22,370
the messages immediately we want them to

00:03:19,890 --> 00:03:24,510
be restored reliably from any context

00:03:22,370 --> 00:03:25,890
but we also don't want them to disturb

00:03:24,510 --> 00:03:28,050
the system at all while running yeah so

00:03:25,890 --> 00:03:30,720
if I stick in my USB stick I shouldn't

00:03:28,050 --> 00:03:33,720
see latency spikes because it's telling

00:03:30,720 --> 00:03:34,890
me the devices that are that were the

00:03:33,720 --> 00:03:37,170
different partitions that were found on

00:03:34,890 --> 00:03:38,580
my USB stick but I would still want to

00:03:37,170 --> 00:03:39,930
see those messages right when we put in

00:03:38,580 --> 00:03:41,610
our USB stick we want to see those

00:03:39,930 --> 00:03:43,740
messages we just don't want them to

00:03:41,610 --> 00:03:46,350
disturb our real-time applications that

00:03:43,740 --> 00:03:49,620
are running for example and if I'm

00:03:46,350 --> 00:03:53,130
allowed to quote myself I actually wrote

00:03:49,620 --> 00:03:54,720
awhile as a summary if it's in if it's a

00:03:53,130 --> 00:03:57,240
part of print K then it's already

00:03:54,720 --> 00:04:00,150
implicitly on every single line of code

00:03:57,240 --> 00:04:02,400
in the kernel because any line of code

00:04:00,150 --> 00:04:04,290
of kernel and the code in the kernel

00:04:02,400 --> 00:04:06,420
could potentially crash which would

00:04:04,290 --> 00:04:09,360
cause print cage to start doing stack

00:04:06,420 --> 00:04:11,820
traces and these kinds of things so this

00:04:09,360 --> 00:04:13,940
is what makes print K so difficult is

00:04:11,820 --> 00:04:15,780
it's everywhere it's a very simple

00:04:13,940 --> 00:04:18,750
function that a lot of people don't even

00:04:15,780 --> 00:04:20,609
like and try to avoid but it's at the

00:04:18,750 --> 00:04:21,120
same time it goes very deep in the

00:04:20,609 --> 00:04:23,340
system

00:04:21,120 --> 00:04:25,810
yeah and when our system crashes now the

00:04:23,340 --> 00:04:27,280
sudden print K is very important to us

00:04:25,810 --> 00:04:28,720
now obviously we started complaining who

00:04:27,280 --> 00:04:30,610
wrote that and why is print K not

00:04:28,720 --> 00:04:32,320
working like this so at the same time

00:04:30,610 --> 00:04:36,130
it's a very important piece of the

00:04:32,320 --> 00:04:37,810
kernel so I went through to look at the

00:04:36,130 --> 00:04:39,250
history of print K just to see where it

00:04:37,810 --> 00:04:41,050
came from and it turns out the print

00:04:39,250 --> 00:04:44,440
Kate has been around since the dawn of

00:04:41,050 --> 00:04:46,720
time right so Linux 0.01 this is

00:04:44,440 --> 00:04:50,440
actually the contents of kernel slash

00:04:46,720 --> 00:04:51,970
print KC so we see here that there's no

00:04:50,440 --> 00:04:54,910
ring buffer involved or anything like

00:04:51,970 --> 00:04:59,320
this it's just directly SM printf or S

00:04:54,910 --> 00:05:01,600
print f'ing the string into temporary

00:04:59,320 --> 00:05:05,280
buffer one kilobyte and then pushing

00:05:01,600 --> 00:05:09,639
that out to the tty using assembly calls

00:05:05,280 --> 00:05:11,320
so it's a synchronous print K and if we

00:05:09,639 --> 00:05:13,419
go through back the locks now I'm only

00:05:11,320 --> 00:05:14,860
highlighting the ones this is actually

00:05:13,419 --> 00:05:17,020
this list is only the things that I

00:05:14,860 --> 00:05:19,180
consider significant to the print print

00:05:17,020 --> 00:05:20,260
K history and even from this list I'm

00:05:19,180 --> 00:05:22,960
only going to be talking about a couple

00:05:20,260 --> 00:05:24,460
items on this list because it has a very

00:05:22,960 --> 00:05:26,770
long history it's been there from for

00:05:24,460 --> 00:05:29,110
almost 30 years now so when we first

00:05:26,770 --> 00:05:31,030
started off in 91 we had this direct

00:05:29,110 --> 00:05:34,060
synchronous printing to the terminal

00:05:31,030 --> 00:05:37,120
this is obviously something that is very

00:05:34,060 --> 00:05:38,530
reliable but in a modern system where we

00:05:37,120 --> 00:05:40,419
have lots of different CPUs that maybe

00:05:38,530 --> 00:05:42,640
want to print obviously this solution

00:05:40,419 --> 00:05:46,000
would not work today in this form at

00:05:42,640 --> 00:05:47,229
least not long later we introduced the

00:05:46,000 --> 00:05:50,770
ring buffer and this is mainly because

00:05:47,229 --> 00:05:53,080
we needed syslog support syslog needs to

00:05:50,770 --> 00:05:54,610
be able to access the the previous

00:05:53,080 --> 00:05:58,210
messages that we've already given out so

00:05:54,610 --> 00:06:00,669
we need to log them and we also

00:05:58,210 --> 00:06:03,430
introduced kernel dredges up I'm sorry

00:06:00,669 --> 00:06:05,940
console registration which meant that if

00:06:03,430 --> 00:06:09,280
a console registers at some later point

00:06:05,940 --> 00:06:11,800
then we need to spit out the messages

00:06:09,280 --> 00:06:13,120
that it's already missed right so this

00:06:11,800 --> 00:06:14,680
is and this is something we still do

00:06:13,120 --> 00:06:16,660
today yeah so if the net console

00:06:14,680 --> 00:06:18,430
registers you know after a few seconds

00:06:16,660 --> 00:06:20,620
then all the messages that the net

00:06:18,430 --> 00:06:23,710
console actually missed will get spit

00:06:20,620 --> 00:06:25,360
out over the net console.log levels

00:06:23,710 --> 00:06:27,039
became in because once people all these

00:06:25,360 --> 00:06:29,020
developers start working on Linux they

00:06:27,039 --> 00:06:31,539
started adding all kinds of messages and

00:06:29,020 --> 00:06:37,900
so the log levels came in there so we

00:06:31,539 --> 00:06:38,390
could reduce or increase that the at

00:06:37,900 --> 00:06:39,830
some point

00:06:38,390 --> 00:06:41,300
decided we wanted to have more consoles

00:06:39,830 --> 00:06:42,920
right so at the beginning we miss with

00:06:41,300 --> 00:06:45,410
just a TTY and then later we said well

00:06:42,920 --> 00:06:47,900
we could also do serial and later even

00:06:45,410 --> 00:06:49,400
came network so we could use all these

00:06:47,900 --> 00:06:51,440
consoles at the same time so he actually

00:06:49,400 --> 00:06:53,240
has support from multiple consoles that

00:06:51,440 --> 00:06:55,640
can be registered and the way it was

00:06:53,240 --> 00:06:56,990
implement is really when a message came

00:06:55,640 --> 00:06:59,390
in from print cade then we went through

00:06:56,990 --> 00:07:00,770
a four loop and just printed synchrony

00:06:59,390 --> 00:07:03,290
synchronously to every one of these

00:07:00,770 --> 00:07:06,080
consoles and actually that code still

00:07:03,290 --> 00:07:08,720
exists today yeah that for every single

00:07:06,080 --> 00:07:13,910
message we go and we print to every

00:07:08,720 --> 00:07:17,300
registered console we then start having

00:07:13,910 --> 00:07:18,650
problems that okay we needed some sort

00:07:17,300 --> 00:07:20,360
of protection because we added locking

00:07:18,650 --> 00:07:22,220
in there obviously when SMP came onto

00:07:20,360 --> 00:07:23,570
the scene we needed some sort of locking

00:07:22,220 --> 00:07:26,150
and we had the problem what if the lock

00:07:23,570 --> 00:07:27,860
is taken and now we crash right and so

00:07:26,150 --> 00:07:30,560
we introduced a really great function

00:07:27,860 --> 00:07:32,030
called bus spin locks which goes against

00:07:30,560 --> 00:07:35,120
everything that anyone has ever learned

00:07:32,030 --> 00:07:37,550
in computer engineering which basically

00:07:35,120 --> 00:07:38,570
says well for in a panic situation then

00:07:37,550 --> 00:07:39,710
let's just forget the locks

00:07:38,570 --> 00:07:42,530
right they're not important anymore

00:07:39,710 --> 00:07:45,410
right which the locks really do have a

00:07:42,530 --> 00:07:48,710
purpose right but we thought okay well

00:07:45,410 --> 00:07:50,270
it's better than nothing right and then

00:07:48,710 --> 00:07:52,490
actually ten years later about the

00:07:50,270 --> 00:07:54,740
10-year anniversary of print k there was

00:07:52,490 --> 00:07:56,030
a big change that came in from Andrew in

00:07:54,740 --> 00:07:58,730
the to Fort Colonel what really was

00:07:56,030 --> 00:08:00,200
really our key tech the architecture of

00:07:58,730 --> 00:08:02,180
print K was changed quite a bit there

00:08:00,200 --> 00:08:04,400
was this console Sam which was a

00:08:02,180 --> 00:08:05,900
semaphore that was brought in that

00:08:04,400 --> 00:08:08,240
replaced the the lock

00:08:05,900 --> 00:08:10,310
there was a locking introduced for the

00:08:08,240 --> 00:08:12,260
log buffer and several other things

00:08:10,310 --> 00:08:13,760
there was also for example an oops in

00:08:12,260 --> 00:08:15,320
progress global variable that was

00:08:13,760 --> 00:08:17,000
introduced so the whole system could

00:08:15,320 --> 00:08:21,980
could decide what to do in a panic

00:08:17,000 --> 00:08:23,900
situation and actually this is if you

00:08:21,980 --> 00:08:25,400
look at the patch from back then this is

00:08:23,900 --> 00:08:27,380
pretty much what print K looks like now

00:08:25,400 --> 00:08:29,840
this is actually very significant

00:08:27,380 --> 00:08:32,990
overhaul the print K design that still

00:08:29,840 --> 00:08:34,220
exists today more or less but what's

00:08:32,990 --> 00:08:36,530
significant here which I've highlighted

00:08:34,220 --> 00:08:40,010
is that this was the moment where print

00:08:36,530 --> 00:08:42,020
K became non synchronous so rather than

00:08:40,010 --> 00:08:44,750
for every print K we print synchronously

00:08:42,020 --> 00:08:46,760
to every console it was changed so that

00:08:44,750 --> 00:08:48,590
if somebody if a print kit comes in and

00:08:46,760 --> 00:08:50,780
someone else is already printing then

00:08:48,590 --> 00:08:51,690
just let them print my message too right

00:08:50,780 --> 00:08:54,120
so

00:08:51,690 --> 00:08:56,160
basically that meant print kay Michael

00:08:54,120 --> 00:08:58,590
really fast if someone else is already

00:08:56,160 --> 00:09:00,660
doing the printing now if you're the guy

00:08:58,590 --> 00:09:02,160
doing the printing that's not gonna be

00:09:00,660 --> 00:09:04,050
fun if all of a sudden all these people

00:09:02,160 --> 00:09:09,450
start doing print case you have a lot of

00:09:04,050 --> 00:09:11,400
work to do ahead of you so libusb later

00:09:09,450 --> 00:09:13,200
we got dynamic allocating that came in

00:09:11,400 --> 00:09:14,910
because before up to this point it was

00:09:13,200 --> 00:09:16,610
just a static buffer in the kernel so

00:09:14,910 --> 00:09:19,620
now actually when the kernel boots

00:09:16,610 --> 00:09:21,870
fairly early in the boot process it'll

00:09:19,620 --> 00:09:23,490
actually allocate memory dynamically and

00:09:21,870 --> 00:09:25,470
then move those messages over to the

00:09:23,490 --> 00:09:27,150
dynamic version so you can have very

00:09:25,470 --> 00:09:32,010
large print K Buster's if buffers if you

00:09:27,150 --> 00:09:35,570
want and at some point we wanted this

00:09:32,010 --> 00:09:38,460
big curl lock removed the BK L right and

00:09:35,570 --> 00:09:40,560
we weren't disabling interrupts while we

00:09:38,460 --> 00:09:42,660
were printing on the consoles but we

00:09:40,560 --> 00:09:45,060
realized when we removed the BK l all of

00:09:42,660 --> 00:09:46,710
a sudden nothing worked anymore so to

00:09:45,060 --> 00:09:47,730
work around that we said okay well if

00:09:46,710 --> 00:09:48,810
we're gonna be calling the console

00:09:47,730 --> 00:09:51,120
drivers then we need to disable

00:09:48,810 --> 00:09:53,940
interrupts and this is because the

00:09:51,120 --> 00:09:55,500
drivers are doing all kinds of things we

00:09:53,940 --> 00:09:58,290
just need to be safe and disable the

00:09:55,500 --> 00:10:01,350
interrupts their timing information came

00:09:58,290 --> 00:10:03,240
in and here's what's really interesting

00:10:01,350 --> 00:10:04,380
so now we're disabling the interrupts

00:10:03,240 --> 00:10:06,600
during the console printing and we

00:10:04,380 --> 00:10:08,400
noticed we're having these huge latency

00:10:06,600 --> 00:10:10,140
spikes because interrupts are disabled

00:10:08,400 --> 00:10:13,860
for a long time when I'm printing a line

00:10:10,140 --> 00:10:15,420
on cereal maybe 9600 KBS or something it

00:10:13,860 --> 00:10:16,950
takes a long time to print that line and

00:10:15,420 --> 00:10:19,220
the interrupts are disabled for that

00:10:16,950 --> 00:10:23,100
huge thing so what was our solution

00:10:19,220 --> 00:10:26,250
let's ignore the latency time if we're

00:10:23,100 --> 00:10:28,650
printing to the consoles right so rather

00:10:26,250 --> 00:10:30,240
than addressing the issue at that point

00:10:28,650 --> 00:10:33,600
we just decided well let's just ignore

00:10:30,240 --> 00:10:36,120
those Layton sees so that we can so we

00:10:33,600 --> 00:10:37,710
can track other latencies right but this

00:10:36,120 --> 00:10:39,000
doesn't make sense really I mean if I

00:10:37,710 --> 00:10:41,760
have a real-time system and it has a

00:10:39,000 --> 00:10:43,410
huge latency and I'm like well wire the

00:10:41,760 --> 00:10:44,670
serial console isn't even showing up on

00:10:43,410 --> 00:10:48,960
my graphs well it's because we're

00:10:44,670 --> 00:10:50,310
ignoring that latency secretly the kdump

00:10:48,960 --> 00:10:52,110
interface showed up so that you know for

00:10:50,310 --> 00:10:55,590
kernel crashes you could actually get to

00:10:52,110 --> 00:10:57,810
the logs and then here's what I call one

00:10:55,590 --> 00:11:00,830
of the first real big duct-tape started

00:10:57,810 --> 00:11:03,000
to show in keep in mind we have

00:11:00,830 --> 00:11:04,600
registered consoles that are that are

00:11:03,000 --> 00:11:07,029
registering later and we

00:11:04,600 --> 00:11:10,000
to reprint everything but at that point

00:11:07,029 --> 00:11:11,649
and still today there is only one index

00:11:10,000 --> 00:11:14,160
that keep tracks of where we are in this

00:11:11,649 --> 00:11:16,959
ring buffer right so when someone else

00:11:14,160 --> 00:11:19,990
registers and we need to replay the ring

00:11:16,959 --> 00:11:22,540
buffer then what we do is we say okay

00:11:19,990 --> 00:11:25,300
this is now an exclusive console we

00:11:22,540 --> 00:11:26,980
reset the index we and we only print to

00:11:25,300 --> 00:11:29,110
this one console until we get back to

00:11:26,980 --> 00:11:32,019
there and now we let everyone else print

00:11:29,110 --> 00:11:34,000
again this works of course but there are

00:11:32,019 --> 00:11:40,240
more elegant ways to handle multiple

00:11:34,000 --> 00:11:43,120
consoles okay and with 3.4 actually with

00:11:40,240 --> 00:11:44,980
the push of system D there was a lot of

00:11:43,120 --> 00:11:47,050
re-engineering to print K this is I

00:11:44,980 --> 00:11:49,420
would call the second major revision of

00:11:47,050 --> 00:11:51,399
print K this is where we actually went

00:11:49,420 --> 00:11:53,170
from just a list of strings in a ring

00:11:51,399 --> 00:11:55,569
buffer to actual real structures that

00:11:53,170 --> 00:11:58,240
were variable length we added sequence

00:11:55,569 --> 00:12:00,490
numbers and we added the devki message

00:11:58,240 --> 00:12:04,300
interface read and write so that the

00:12:00,490 --> 00:12:10,750
system D daemon could directly access

00:12:04,300 --> 00:12:13,870
the print K stuff okay so this this

00:12:10,750 --> 00:12:15,189
anyway this is a big big change and the

00:12:13,870 --> 00:12:16,779
interesting thing is is once we have

00:12:15,189 --> 00:12:18,819
sequence numbers so we can actually

00:12:16,779 --> 00:12:19,899
number which is a good thing because if

00:12:18,819 --> 00:12:21,279
you have sequence numbers now you can

00:12:19,899 --> 00:12:22,839
detect if you've dropped like if we've

00:12:21,279 --> 00:12:25,120
lost the messages before we didn't know

00:12:22,839 --> 00:12:27,189
that we were dropping anything because

00:12:25,120 --> 00:12:28,899
they weren't numbered so once we have

00:12:27,189 --> 00:12:32,380
sequence numbers now we can detect that

00:12:28,899 --> 00:12:36,310
messages are being dropped and but

00:12:32,380 --> 00:12:37,630
recently 2006 2016 the idea of nmi

00:12:36,310 --> 00:12:40,779
because until that point we still

00:12:37,630 --> 00:12:43,899
couldn't really print from enemy context

00:12:40,779 --> 00:12:45,279
right because printf print K still tries

00:12:43,899 --> 00:12:47,199
to print to the consoles if no one else

00:12:45,279 --> 00:12:49,120
is printing then I need to do it and if

00:12:47,199 --> 00:12:51,310
I'm in an enemy context this isn't going

00:12:49,120 --> 00:12:53,980
to work right so there was actually

00:12:51,310 --> 00:12:55,689
several iterations here you can actually

00:12:53,980 --> 00:12:57,910
see the evolution to the safe buffers

00:12:55,689 --> 00:12:59,290
but actually came into 4.18 where we

00:12:57,910 --> 00:13:02,439
actually have safe buffers these are

00:12:59,290 --> 00:13:04,060
specials buffers set aside and if we

00:13:02,439 --> 00:13:05,980
want to print came from in my context we

00:13:04,060 --> 00:13:07,329
just copied to those buffers and then we

00:13:05,980 --> 00:13:10,089
trigger an IRA cue work and it's

00:13:07,329 --> 00:13:15,160
supposed to then copy it into the real

00:13:10,089 --> 00:13:16,569
ring buffer under the lock now what

00:13:15,160 --> 00:13:17,829
happens when we crash we've got all

00:13:16,569 --> 00:13:18,499
these things sitting in these buffers as

00:13:17,829 --> 00:13:21,709
a min move over

00:13:18,499 --> 00:13:24,109
yet moved over yet we crash then also we

00:13:21,709 --> 00:13:28,009
want to flush those buffers so we can

00:13:24,109 --> 00:13:30,529
see them when the machine panics very

00:13:28,009 --> 00:13:33,889
recently so last year there was a lot of

00:13:30,529 --> 00:13:36,079
work to add a console honoring waiter

00:13:33,889 --> 00:13:38,059
concept so this is you know we're coming

00:13:36,079 --> 00:13:40,189
up on 30 years and finally we're like

00:13:38,059 --> 00:13:41,449
okay this one guy who's printing if

00:13:40,189 --> 00:13:44,089
there's all these other people calling

00:13:41,449 --> 00:13:46,219
print Ches and this one printer is stuck

00:13:44,089 --> 00:13:47,509
printing then this jet this the CPU

00:13:46,219 --> 00:13:49,879
might just be printing the rest of its

00:13:47,509 --> 00:13:52,609
life no one else gets a chance to do

00:13:49,879 --> 00:13:55,369
anything right and so the this new logic

00:13:52,609 --> 00:13:57,439
came in that says if someone's printing

00:13:55,369 --> 00:13:59,179
then I'm actually going to take over the

00:13:57,439 --> 00:14:01,369
printing right so each person that

00:13:59,179 --> 00:14:03,079
prints is actually taking over from

00:14:01,369 --> 00:14:06,559
another another task that might already

00:14:03,079 --> 00:14:09,469
be printing and then finally really new

00:14:06,559 --> 00:14:12,229
is we have a feature called blog Conte

00:14:09,469 --> 00:14:14,089
which means I can just do part I can

00:14:12,229 --> 00:14:16,009
kind of build my message on the fly with

00:14:14,089 --> 00:14:19,429
multiple print cake halls and at some

00:14:16,009 --> 00:14:21,019
point flush that whole thing that in of

00:14:19,429 --> 00:14:21,349
it in and of itself is a kind of a

00:14:21,019 --> 00:14:24,829
nightmare

00:14:21,349 --> 00:14:28,159
but we actually with the 5.0 we actually

00:14:24,829 --> 00:14:29,989
have a pretty good idea of how to at

00:14:28,159 --> 00:14:31,729
least to coordinate whose partial

00:14:29,989 --> 00:14:32,869
messages or messages or hoof we have two

00:14:31,729 --> 00:14:35,449
different CPUs that are doing partial

00:14:32,869 --> 00:14:37,009
messages then it's in we have to be able

00:14:35,449 --> 00:14:38,389
to coordinate is this piece coming from

00:14:37,009 --> 00:14:41,449
him or is this peach come from this guy

00:14:38,389 --> 00:14:44,149
so with with 5.0 we actually have caller

00:14:41,449 --> 00:14:47,449
Ids now that we can tell who's printing

00:14:44,149 --> 00:14:48,919
what so what are the open issues we've

00:14:47,449 --> 00:14:50,779
been all these changes we've added all

00:14:48,919 --> 00:14:53,239
these features what are the current

00:14:50,779 --> 00:14:55,789
issues right now with print kay first of

00:14:53,239 --> 00:14:58,369
all we have this Ross spin lock called

00:14:55,789 --> 00:15:00,619
block buff that's protecting the lock

00:14:58,369 --> 00:15:03,019
buffer now the log buffer the ring

00:15:00,619 --> 00:15:05,029
buffer the problem with that is it

00:15:03,019 --> 00:15:07,609
cannot be taken from and in my context

00:15:05,029 --> 00:15:09,439
at all times right like and we were an

00:15:07,609 --> 00:15:11,149
enemy I will try to take it if it's will

00:15:09,439 --> 00:15:13,069
do a try lock if we get it great we can

00:15:11,149 --> 00:15:14,809
print but if it's already locked we

00:15:13,069 --> 00:15:17,989
still have to use the safe buffers right

00:15:14,809 --> 00:15:21,049
so we can't actually write into these

00:15:17,989 --> 00:15:23,479
into the ring buffer immediately so now

00:15:21,049 --> 00:15:24,799
we get to the safe buffers they have a

00:15:23,479 --> 00:15:27,319
problem that for example they're using

00:15:24,799 --> 00:15:29,179
bogus time stamps so the time stamping

00:15:27,319 --> 00:15:30,859
is not happening when it goes into the

00:15:29,179 --> 00:15:32,060
safe buffers the time stamps are

00:15:30,859 --> 00:15:33,740
happening when it actually makes it

00:15:32,060 --> 00:15:35,960
the real ring buffer right which might

00:15:33,740 --> 00:15:37,490
be considerably laboured later yeah so

00:15:35,960 --> 00:15:39,260
when we look at our D message we see all

00:15:37,490 --> 00:15:40,880
these nice timestamps but if any of

00:15:39,260 --> 00:15:44,150
those messages were coming from the safe

00:15:40,880 --> 00:15:45,590
buffers those numbers are wrong so those

00:15:44,150 --> 00:15:46,850
actually is not the order that the

00:15:45,590 --> 00:15:49,100
things were happening and you can't even

00:15:46,850 --> 00:15:50,260
sort it because the timestamps come much

00:15:49,100 --> 00:15:52,400
later

00:15:50,260 --> 00:15:55,130
it relies on the right queue work

00:15:52,400 --> 00:15:57,350
mechanism which is fairly reliable all

00:15:55,130 --> 00:15:58,910
but there are situations where this

00:15:57,350 --> 00:16:01,520
might be the last thing the CPU ever

00:15:58,910 --> 00:16:04,370
does if we don't print now it's going to

00:16:01,520 --> 00:16:06,530
be lost and then we have a little

00:16:04,370 --> 00:16:08,510
technical issue that you know I said

00:16:06,530 --> 00:16:10,670
that if we have a panic situation we

00:16:08,510 --> 00:16:12,800
flush the safe buffers but that's also

00:16:10,670 --> 00:16:14,210
not so trivial and there are situations

00:16:12,800 --> 00:16:16,790
for example if we can't bring all the

00:16:14,210 --> 00:16:17,810
CPUs offline then we don't flush so

00:16:16,790 --> 00:16:19,670
there's actually quite a bit of

00:16:17,810 --> 00:16:22,880
situations where the safe buffers will

00:16:19,670 --> 00:16:25,340
not get flushed at all the console

00:16:22,880 --> 00:16:29,210
drivers are a problem that they're very

00:16:25,340 --> 00:16:30,680
slow but really the problem is is that

00:16:29,210 --> 00:16:32,390
we're calling them all with interrupts

00:16:30,680 --> 00:16:34,460
disabled and we're calling them all

00:16:32,390 --> 00:16:36,230
together all right so we have five

00:16:34,460 --> 00:16:38,540
consoles and we're gonna do all five of

00:16:36,230 --> 00:16:39,680
them with interrupts disabled even if

00:16:38,540 --> 00:16:41,180
one of them is really fast and when I

00:16:39,680 --> 00:16:42,800
was really slow that we're gonna do all

00:16:41,180 --> 00:16:45,920
five of them and then we're gonna re

00:16:42,800 --> 00:16:47,480
enable interrupts of course the fact

00:16:45,920 --> 00:16:49,340
that we're ignoring interrupt latency is

00:16:47,480 --> 00:16:51,740
with the consoles I don't have to say

00:16:49,340 --> 00:16:53,390
much about that and we have a problem

00:16:51,740 --> 00:16:55,040
that the console drivers are just not

00:16:53,390 --> 00:16:56,750
reliable in the panic situation because

00:16:55,040 --> 00:16:58,880
they're not made for that yeah if we're

00:16:56,750 --> 00:17:03,070
panicking in nmi context the drivers

00:16:58,880 --> 00:17:06,410
just won't help us another issue

00:17:03,070 --> 00:17:08,600
we're treating info messages exactly the

00:17:06,410 --> 00:17:12,200
same as emergency message right so that

00:17:08,600 --> 00:17:14,060
message that just says our dev random is

00:17:12,200 --> 00:17:17,180
finally ready with real random data is

00:17:14,060 --> 00:17:20,630
exactly as important as we just resolved

00:17:17,180 --> 00:17:22,310
a null pointer right which means we're

00:17:20,630 --> 00:17:25,310
keeping these that we're handling them

00:17:22,310 --> 00:17:26,990
exactly the same which means we treat

00:17:25,310 --> 00:17:29,150
them both as an emergency or do we treat

00:17:26,990 --> 00:17:30,980
them both as informational but the whole

00:17:29,150 --> 00:17:32,330
handling of this you know it's obviously

00:17:30,980 --> 00:17:34,670
one is more important than the other

00:17:32,330 --> 00:17:36,950
it's nice that the random is read it's

00:17:34,670 --> 00:17:38,780
ready but it would I would prefer to get

00:17:36,950 --> 00:17:43,310
the information that we just did a null

00:17:38,780 --> 00:17:45,530
pointer I already mentioned

00:17:43,310 --> 00:17:46,970
you know we improve this that you know

00:17:45,530 --> 00:17:50,150
every time that someone does a print que

00:17:46,970 --> 00:17:52,100
this task takes over the printing task

00:17:50,150 --> 00:17:54,290
right so that printing test is finally

00:17:52,100 --> 00:17:56,270
relieved and it's getting someone else

00:17:54,290 --> 00:17:58,760
can come along the problem is is when

00:17:56,270 --> 00:18:01,670
I'm the last guy I get to do the rest

00:17:58,760 --> 00:18:04,310
right so you know if there's like you

00:18:01,670 --> 00:18:05,690
know 50 60 print case that have been you

00:18:04,310 --> 00:18:06,980
know stacking up there and almost and

00:18:05,690 --> 00:18:08,780
I'm the last one I might actually have a

00:18:06,980 --> 00:18:12,020
lot of stuff that I need to print there

00:18:08,780 --> 00:18:13,340
right so that's it's not fun to be the

00:18:12,020 --> 00:18:15,650
last guy in that situation so although

00:18:13,340 --> 00:18:17,450
this did really relieve a lot of real

00:18:15,650 --> 00:18:20,330
situations it severe it was very helpful

00:18:17,450 --> 00:18:22,160
to hand off the print caning but if

00:18:20,330 --> 00:18:24,740
you're the last one

00:18:22,160 --> 00:18:26,840
it's no fun and this actually makes it a

00:18:24,740 --> 00:18:28,610
big wild card for callers of print hey

00:18:26,840 --> 00:18:31,430
you know if I'm in certain contexts I

00:18:28,610 --> 00:18:33,410
might be afraid of using print K because

00:18:31,430 --> 00:18:35,510
Amaya is going to be expensive or is it

00:18:33,410 --> 00:18:37,220
going to be cheap I don't even know it

00:18:35,510 --> 00:18:39,910
depends on the ordering if I was the

00:18:37,220 --> 00:18:43,250
last task to do the printing and the

00:18:39,910 --> 00:18:44,990
last major open issue is the fact that

00:18:43,250 --> 00:18:48,770
we have this oops in progress global

00:18:44,990 --> 00:18:50,660
variable which is kind of politely

00:18:48,770 --> 00:18:53,090
requesting drivers to ignore their locks

00:18:50,660 --> 00:18:56,270
and we also have a bus pin locks

00:18:53,090 --> 00:19:00,320
function that explicitly tells print

00:18:56,270 --> 00:19:02,030
Kate to ignore its locks and it's my

00:19:00,320 --> 00:19:04,130
opinion that we are a lot of brilliant

00:19:02,030 --> 00:19:05,420
people and after 30 years of print K

00:19:04,130 --> 00:19:07,510
there has to be a way to better way to

00:19:05,420 --> 00:19:09,800
do this than to just ignore locks

00:19:07,510 --> 00:19:14,480
because it actually doesn't work in a

00:19:09,800 --> 00:19:15,800
lot of situations so the problem you

00:19:14,480 --> 00:19:17,000
know after looking at this I looked at

00:19:15,800 --> 00:19:19,510
all these issues I looked at the history

00:19:17,000 --> 00:19:21,740
and I said what is the main issue here

00:19:19,510 --> 00:19:23,780
and the main issue that I got out of

00:19:21,740 --> 00:19:26,960
this is we have a tug of war going on

00:19:23,780 --> 00:19:28,610
we want this non-interference you know

00:19:26,960 --> 00:19:30,740
that we can just print K whatever as

00:19:28,610 --> 00:19:32,300
much we can just be in the loop of just

00:19:30,740 --> 00:19:34,790
print King we don't want to disturb the

00:19:32,300 --> 00:19:37,190
system and at the other time at the same

00:19:34,790 --> 00:19:39,740
time if it crashes we want this

00:19:37,190 --> 00:19:41,360
information now right and these are two

00:19:39,740 --> 00:19:43,910
requirements that are actually working

00:19:41,360 --> 00:19:46,730
against each other and so what happens

00:19:43,910 --> 00:19:48,500
is we end up with a solution that's not

00:19:46,730 --> 00:19:50,480
good for both sides right so we're both

00:19:48,500 --> 00:19:52,160
tug-of-war and this sides not happy and

00:19:50,480 --> 00:19:54,440
that sides not happy and we just got

00:19:52,160 --> 00:19:56,470
something kind of in the middle and I

00:19:54,440 --> 00:19:59,530
was kind of inspired by ran

00:19:56,470 --> 00:20:01,809
munroe who wrote an article about tug of

00:19:59,530 --> 00:20:04,299
war and he said in the ultimate game of

00:20:01,809 --> 00:20:08,530
tug of war the only winning move is not

00:20:04,299 --> 00:20:10,690
to pull so we need to remove this that

00:20:08,530 --> 00:20:13,030
we have print Kay fighting with itself

00:20:10,690 --> 00:20:16,059
do I want to be non-interference or I

00:20:13,030 --> 00:20:18,549
want to be reliable and really if the

00:20:16,059 --> 00:20:20,289
only purpose of my talk really is this

00:20:18,549 --> 00:20:23,320
right so we'll go into some solutions

00:20:20,289 --> 00:20:25,990
but really this idea of we need to get

00:20:23,320 --> 00:20:28,480
out of this mindset that print K has to

00:20:25,990 --> 00:20:30,970
do both sides equally right we need to

00:20:28,480 --> 00:20:33,820
we need to have this we need to handle

00:20:30,970 --> 00:20:37,030
these things separately so what does it

00:20:33,820 --> 00:20:38,760
mean to not pull right and it turns out

00:20:37,030 --> 00:20:40,900
if you look at what print K is doing and

00:20:38,760 --> 00:20:42,909
then if you ask yourself the question

00:20:40,900 --> 00:20:45,100
what is it printing and when is it

00:20:42,909 --> 00:20:47,590
printing then you can start to see

00:20:45,100 --> 00:20:50,679
actually we can actually divide these

00:20:47,590 --> 00:20:52,539
two countering requirements right so for

00:20:50,679 --> 00:20:54,789
example when I'm crashing when there's

00:20:52,539 --> 00:20:56,559
war nons happening things like this

00:20:54,789 --> 00:20:58,059
these are these are situations that we

00:20:56,559 --> 00:21:00,100
know about we know that it's happening

00:20:58,059 --> 00:21:01,360
right there they're being triggered and

00:21:00,100 --> 00:21:02,950
we're calling into the bug function

00:21:01,360 --> 00:21:05,080
right so it knows that there's something

00:21:02,950 --> 00:21:08,860
serious going on as opposed to someone

00:21:05,080 --> 00:21:12,100
who's just printing random information

00:21:08,860 --> 00:21:13,659
about the USB or whatever so the fact

00:21:12,100 --> 00:21:15,429
that what we're printing and when we're

00:21:13,659 --> 00:21:16,870
printing it for example have also if I'm

00:21:15,429 --> 00:21:19,120
in a panic situation that's also a win

00:21:16,870 --> 00:21:21,340
then the things in there are extremely

00:21:19,120 --> 00:21:23,260
important so we can kind of start to

00:21:21,340 --> 00:21:24,940
partition this and to see there's

00:21:23,260 --> 00:21:28,720
actually two different types of

00:21:24,940 --> 00:21:31,299
scenarios scenarios there and so really

00:21:28,720 --> 00:21:33,580
my solution is my recommendation what

00:21:31,299 --> 00:21:35,440
I'm trying to push is that we split this

00:21:33,580 --> 00:21:38,770
into two problems with two different

00:21:35,440 --> 00:21:40,750
solutions so the first problem is the

00:21:38,770 --> 00:21:42,880
non-interference one and so what I'm

00:21:40,750 --> 00:21:44,860
really trying to push is to make print K

00:21:42,880 --> 00:21:48,520
fully preemptable right so we do this

00:21:44,860 --> 00:21:49,780
first of all with a call context safe

00:21:48,520 --> 00:21:52,150
ring buffer so we need to get away from

00:21:49,780 --> 00:21:53,640
this ross pin lock that city or sitting

00:21:52,150 --> 00:21:56,530
around there protecting the ring buffer

00:21:53,640 --> 00:21:58,090
this will give us the freedom that we

00:21:56,530 --> 00:21:59,710
can just it doesn't matter what context

00:21:58,090 --> 00:22:01,750
we're in we can just insert those

00:21:59,710 --> 00:22:03,940
messages into the ring buffer right so

00:22:01,750 --> 00:22:05,470
this will help us this non-interference

00:22:03,940 --> 00:22:09,309
that we don't have to do it special

00:22:05,470 --> 00:22:10,000
locks or were you know causing extra irq

00:22:09,309 --> 00:22:11,440
works or anything

00:22:10,000 --> 00:22:13,900
like this we could just throw it in

00:22:11,440 --> 00:22:15,970
there and it's in there the second thing

00:22:13,900 --> 00:22:17,650
is is that we go to per console K

00:22:15,970 --> 00:22:19,270
threads and I'll go into these things in

00:22:17,650 --> 00:22:23,860
a little bit more detail in the upcoming

00:22:19,270 --> 00:22:26,320
slides now Catherine's have been tried

00:22:23,860 --> 00:22:29,350
in the past but in my opinion the

00:22:26,320 --> 00:22:32,430
problem was the past attempts at using K

00:22:29,350 --> 00:22:34,690
threads is they didn't try to separate

00:22:32,430 --> 00:22:36,040
the critical messages for the

00:22:34,690 --> 00:22:37,510
non-critical message they still they

00:22:36,040 --> 00:22:40,150
tried to do everything with the K thread

00:22:37,510 --> 00:22:42,220
so you're not really solving the problem

00:22:40,150 --> 00:22:46,150
you're just moving it into K threads

00:22:42,220 --> 00:22:48,070
which is not necessarily helpful so the

00:22:46,150 --> 00:22:49,330
other problem which we want to solve

00:22:48,070 --> 00:22:52,780
which is a separate problem its

00:22:49,330 --> 00:22:54,970
reliability and the idea was that we

00:22:52,780 --> 00:22:57,250
provide an official synchronous channel

00:22:54,970 --> 00:22:58,840
where we can put important messages for

00:22:57,250 --> 00:23:01,150
example when the machine is crashing

00:22:58,840 --> 00:23:03,820
panic situation bugs and we use this

00:23:01,150 --> 00:23:05,680
other channel this synchronous channel

00:23:03,820 --> 00:23:08,560
when one gets out get this miss give

00:23:05,680 --> 00:23:10,990
this information out so this also will

00:23:08,560 --> 00:23:13,690
make use of the all context a freeing

00:23:10,990 --> 00:23:14,950
buffer that can be used at any time so

00:23:13,690 --> 00:23:15,970
we can get those messages in the ring

00:23:14,950 --> 00:23:17,590
buffer all the time this is really

00:23:15,970 --> 00:23:19,090
important because there's a lot of

00:23:17,590 --> 00:23:21,400
interfaces in the kernel for example the

00:23:19,090 --> 00:23:23,470
key message dump interface where other

00:23:21,400 --> 00:23:24,910
callbacks need to get will just grab

00:23:23,470 --> 00:23:25,900
those messages from the ring buffer so

00:23:24,910 --> 00:23:27,460
it's really important that we at least

00:23:25,900 --> 00:23:29,230
get those in the ring buffer we need the

00:23:27,460 --> 00:23:31,690
all context safe ring buffer for both

00:23:29,230 --> 00:23:33,430
scenarios but for the reliability

00:23:31,690 --> 00:23:34,990
scenario we're also going to have atomic

00:23:33,430 --> 00:23:36,040
consoles which is something that I'm

00:23:34,990 --> 00:23:39,850
going to talk about in a minute and

00:23:36,040 --> 00:23:40,930
something called emergency messages so

00:23:39,850 --> 00:23:42,970
first let's talk about the ring buffer

00:23:40,930 --> 00:23:46,240
which we need for both they both need

00:23:42,970 --> 00:23:48,070
this even though it's not the the

00:23:46,240 --> 00:23:50,680
problems are being solved separately but

00:23:48,070 --> 00:23:52,600
both problems need this thing the first

00:23:50,680 --> 00:23:57,730
iteration was something that was using a

00:23:52,600 --> 00:24:00,220
CPU lock and this ring buffer can be

00:23:57,730 --> 00:24:02,470
called from any context it supports

00:24:00,220 --> 00:24:05,080
multiple readers and a single writing

00:24:02,470 --> 00:24:07,780
CPU all right so when I say writing CPU

00:24:05,080 --> 00:24:10,300
it means if I if the CPU is writing and

00:24:07,780 --> 00:24:12,100
then there's an MI on the CPU see if you

00:24:10,300 --> 00:24:15,130
can also continue to write write but

00:24:12,100 --> 00:24:18,670
another CPU would actually have to wait

00:24:15,130 --> 00:24:21,220
for the CPU to finish it stores all data

00:24:18,670 --> 00:24:22,840
continuously in memory exactly like the

00:24:21,220 --> 00:24:24,790
current print kay

00:24:22,840 --> 00:24:27,190
it's a relatively simple implementation

00:24:24,790 --> 00:24:28,900
and we're not going to go into this but

00:24:27,190 --> 00:24:30,520
actually if you go to the website from

00:24:28,900 --> 00:24:33,340
Linux plumbers and you download my

00:24:30,520 --> 00:24:35,050
slides there's like 10 slides after my

00:24:33,340 --> 00:24:36,940
thank you slide that show a lot of

00:24:35,050 --> 00:24:37,990
pictures and a lot details so if you're

00:24:36,940 --> 00:24:40,060
really interested in how we're

00:24:37,990 --> 00:24:41,590
implementing this it's a lot of detailed

00:24:40,060 --> 00:24:44,860
information but unfortunately I don't

00:24:41,590 --> 00:24:46,810
have enough time here for that now the

00:24:44,860 --> 00:24:49,480
implementation is using the CPU lock

00:24:46,810 --> 00:24:53,320
which is actually a CPU reentrant spin

00:24:49,480 --> 00:24:56,170
lock which means if a CPU grabs the spin

00:24:53,320 --> 00:24:58,360
lock and the owner that spin lock is me

00:24:56,170 --> 00:25:00,880
it's the same CPU then I also get it

00:24:58,360 --> 00:25:03,550
right so it's you're allowed to regrab

00:25:00,880 --> 00:25:06,310
that spin lock if it's on the CPU same

00:25:03,550 --> 00:25:08,830
CPU and we use this to serialize the

00:25:06,310 --> 00:25:11,590
writers and there's also in the appendix

00:25:08,830 --> 00:25:14,770
the code to show you what the CPU lock

00:25:11,590 --> 00:25:16,810
looks like in code what this ring buffer

00:25:14,770 --> 00:25:19,240
also does is it uses logical positions

00:25:16,810 --> 00:25:20,830
to avoid an ABA problem so if you have a

00:25:19,240 --> 00:25:22,830
you know a ring buffer that's only four

00:25:20,830 --> 00:25:25,630
kilobytes large and it wraps around

00:25:22,830 --> 00:25:27,190
we're locked lists now so if reader a

00:25:25,630 --> 00:25:29,830
reader might say ok I want to read this

00:25:27,190 --> 00:25:31,990
message and maybe the reader blocked for

00:25:29,830 --> 00:25:33,490
a couple seconds and then actually came

00:25:31,990 --> 00:25:34,870
time to read it maybe that ring buffers

00:25:33,490 --> 00:25:36,610
wrapped three times since then

00:25:34,870 --> 00:25:38,110
right so it's reading the position but

00:25:36,610 --> 00:25:40,210
it's actually a totally wrong message

00:25:38,110 --> 00:25:43,060
and so rather than just rat using an

00:25:40,210 --> 00:25:44,710
index into a buffer it's actually just a

00:25:43,060 --> 00:25:46,270
logical position that just keeps going

00:25:44,710 --> 00:25:48,280
on so that we have an actual unsigned

00:25:46,270 --> 00:25:48,850
long that has to wrap before that to

00:25:48,280 --> 00:25:53,260
help for that

00:25:48,850 --> 00:25:55,870
EBA problem the only real concerns about

00:25:53,260 --> 00:25:58,870
this version was that the CPU lock has

00:25:55,870 --> 00:26:00,910
kind of a big kernel like feel to it you

00:25:58,870 --> 00:26:02,290
can only have one in the system if you

00:26:00,910 --> 00:26:04,510
have more than one in your system you

00:26:02,290 --> 00:26:06,970
can actually really easily create

00:26:04,510 --> 00:26:08,470
deadlocks so we have this kind of starts

00:26:06,970 --> 00:26:10,810
to feel like bkl already just we only

00:26:08,470 --> 00:26:14,890
have one and if you're gonna be doing

00:26:10,810 --> 00:26:17,020
any nmi locking in at all so for example

00:26:14,890 --> 00:26:18,940
if I if there's a chance that one nmi

00:26:17,020 --> 00:26:21,670
context is going to wait for an Avant

00:26:18,940 --> 00:26:23,920
for another CPU then you're also gonna

00:26:21,670 --> 00:26:27,670
have a problem so the nmi contexts are

00:26:23,920 --> 00:26:29,590
also required to use this global CPU

00:26:27,670 --> 00:26:32,680
lock all right so it kind of has a pka

00:26:29,590 --> 00:26:35,440
feel to it when you're talking about nmi

00:26:32,680 --> 00:26:39,580
context and synchronizing the

00:26:35,440 --> 00:26:41,260
log yeah it should never but it's done

00:26:39,580 --> 00:26:44,530
in the past and the concerns are what if

00:26:41,260 --> 00:26:48,190
it does it again in the future right so

00:26:44,530 --> 00:26:50,050
then to get around this situation I was

00:26:48,190 --> 00:26:52,210
asked by Petter the who's the maintainer

00:26:50,050 --> 00:26:54,070
of print k well can we do this without

00:26:52,210 --> 00:26:56,500
that cpu lock and actually I happen to

00:26:54,070 --> 00:26:58,600
have one in my pocket because I was kind

00:26:56,500 --> 00:27:00,700
of working on a lock list version anyway

00:26:58,600 --> 00:27:03,220
and so I was like okay well let's try

00:27:00,700 --> 00:27:05,980
that and so I actually created a new

00:27:03,220 --> 00:27:07,540
version of the Ring buffer and this one

00:27:05,980 --> 00:27:09,550
was truly lock less so it doesn't grab

00:27:07,540 --> 00:27:11,800
any locks whatsoever it supports

00:27:09,550 --> 00:27:14,680
multiple readers multiple riders all

00:27:11,800 --> 00:27:16,180
contexts and the raw record data is

00:27:14,680 --> 00:27:17,680
stored contiguously so there's some

00:27:16,180 --> 00:27:20,770
information that's not stored

00:27:17,680 --> 00:27:22,540
contiguously but basically all of the

00:27:20,770 --> 00:27:24,040
print k messages themselves are all

00:27:22,540 --> 00:27:27,460
stored continuously just like the

00:27:24,040 --> 00:27:29,410
current implementation the way it works

00:27:27,460 --> 00:27:31,720
is it uses descriptors to store the

00:27:29,410 --> 00:27:33,280
metadata so we actually have we have the

00:27:31,720 --> 00:27:34,690
ring buffer itself which has the raw

00:27:33,280 --> 00:27:36,850
data and there's actually a separate

00:27:34,690 --> 00:27:39,370
structure that uses descriptors to

00:27:36,850 --> 00:27:42,910
describe where the records are located

00:27:39,370 --> 00:27:45,400
in there in order to simplify this I

00:27:42,910 --> 00:27:47,080
actually factor this into three

00:27:45,400 --> 00:27:48,760
different structures so it uses

00:27:47,080 --> 00:27:50,650
something called a number list which is

00:27:48,760 --> 00:27:52,230
just a numbered list and the job of the

00:27:50,650 --> 00:27:55,000
number list is to sequence the records

00:27:52,230 --> 00:27:56,920
it has a data ring buffer which is just

00:27:55,000 --> 00:27:59,890
the basically a primitive ring buffer

00:27:56,920 --> 00:28:02,980
very similar to the version from 1992 to

00:27:59,890 --> 00:28:05,440
just track the raw data as as the

00:28:02,980 --> 00:28:07,060
records individual records and then it

00:28:05,440 --> 00:28:09,670
uses a high-level print k ring buffer

00:28:07,060 --> 00:28:11,350
structure which basically provides the

00:28:09,670 --> 00:28:14,440
interface to the ring buffer so it's

00:28:11,350 --> 00:28:16,090
using the data ring and the num list to

00:28:14,440 --> 00:28:18,280
provide a coherent reader/writer

00:28:16,090 --> 00:28:20,380
interface to support all of the features

00:28:18,280 --> 00:28:24,580
of print K that we are that we now have

00:28:20,380 --> 00:28:26,800
to support to avoid the ABA problem it

00:28:24,580 --> 00:28:28,960
also used logical positions for the data

00:28:26,800 --> 00:28:30,300
ring and the number list and the number

00:28:28,960 --> 00:28:33,100
list which is actually a linked list

00:28:30,300 --> 00:28:34,720
uses node IDs rather than pointers

00:28:33,100 --> 00:28:38,950
because with pointers you can very

00:28:34,720 --> 00:28:41,230
quickly also get into the AV problem so

00:28:38,950 --> 00:28:44,410
what was the problem with this one it

00:28:41,230 --> 00:28:46,480
was complicated doing a pure lock list

00:28:44,410 --> 00:28:48,640
multi reader multi writer was not easy

00:28:46,480 --> 00:28:49,240
and there's still on my opinion ongoing

00:28:48,640 --> 00:28:51,400
research on

00:28:49,240 --> 00:28:53,860
topic I had the three different data

00:28:51,400 --> 00:28:56,140
structures there was multiple writer

00:28:53,860 --> 00:28:58,570
variables that were shared between that

00:28:56,140 --> 00:28:59,260
could be shared between CPUs which means

00:28:58,570 --> 00:29:01,450
oops

00:28:59,260 --> 00:29:03,400
which means you're left with nine memory

00:29:01,450 --> 00:29:06,120
barrier pairs so basically we have 18

00:29:03,400 --> 00:29:08,380
memory barriers in this stuff which is

00:29:06,120 --> 00:29:11,770
becomes first of all difficult to

00:29:08,380 --> 00:29:13,990
document because we don't really have a

00:29:11,770 --> 00:29:15,940
formalized method of documenting our

00:29:13,990 --> 00:29:17,560
memory barriers so we have we've done a

00:29:15,940 --> 00:29:20,500
lot of stuff in the direction of memory

00:29:17,560 --> 00:29:22,180
barriers and proving them but the

00:29:20,500 --> 00:29:25,270
documentation the kernel is still kind

00:29:22,180 --> 00:29:26,980
of do whatever you want I mean you've

00:29:25,270 --> 00:29:30,220
got 18 of them do whatever you want is

00:29:26,980 --> 00:29:32,140
not so easy and obviously it's difficult

00:29:30,220 --> 00:29:34,210
to review so we've got these did we've

00:29:32,140 --> 00:29:36,220
got the data list the data ring the the

00:29:34,210 --> 00:29:38,320
number list we've got the 18 memory

00:29:36,220 --> 00:29:41,230
barriers in there and it's difficult for

00:29:38,320 --> 00:29:43,740
other people to prove or to believe that

00:29:41,230 --> 00:29:46,270
what I've done is actually correct and

00:29:43,740 --> 00:29:48,790
if the situation came up where the

00:29:46,270 --> 00:29:51,190
question came up do we really need multi

00:29:48,790 --> 00:29:53,410
writer support anyway right if can we

00:29:51,190 --> 00:29:55,870
just the the CPU lock version actually

00:29:53,410 --> 00:29:57,310
was quite simple right the difference

00:29:55,870 --> 00:29:59,710
between the CP locked version in this

00:29:57,310 --> 00:30:01,090
version was really that this is multi

00:29:59,710 --> 00:30:03,430
writer and that one's not and if we

00:30:01,090 --> 00:30:07,000
don't really need that then maybe it's

00:30:03,430 --> 00:30:08,890
not worth all of this extra effort okay

00:30:07,000 --> 00:30:10,840
ring buffer so we've got the two ring

00:30:08,890 --> 00:30:11,920
buffers there let's move on to the next

00:30:10,840 --> 00:30:14,290
one it's a little bit a little bit

00:30:11,920 --> 00:30:17,020
easier maybe so if we get to the topic

00:30:14,290 --> 00:30:20,590
of non-interference that we want to

00:30:17,020 --> 00:30:23,470
solve i propose doing per console kernel

00:30:20,590 --> 00:30:25,630
threads and the advantage of this is we

00:30:23,470 --> 00:30:28,150
can totally decoupled the print cake

00:30:25,630 --> 00:30:30,970
callers from the console right so when

00:30:28,150 --> 00:30:32,440
someone calls print K that context is

00:30:30,970 --> 00:30:33,820
not actually printing although it doing

00:30:32,440 --> 00:30:35,800
is throwing it into a ring buffer and

00:30:33,820 --> 00:30:37,150
they're done right and there's actually

00:30:35,800 --> 00:30:40,660
a lot of advantages to that because

00:30:37,150 --> 00:30:42,670
there's a lot of crazy locks for example

00:30:40,660 --> 00:30:44,230
the console walk that's involved in

00:30:42,670 --> 00:30:46,510
print cake colors and print cake collars

00:30:44,230 --> 00:30:47,620
if don't want to deal with that cause

00:30:46,510 --> 00:30:49,420
consoles they don't need to deal with

00:30:47,620 --> 00:30:51,220
them at all why should they have to they

00:30:49,420 --> 00:30:52,390
were talking about non-interference here

00:30:51,220 --> 00:30:54,220
they're just trying to get a message

00:30:52,390 --> 00:30:56,020
into the ring buffer right so let's

00:30:54,220 --> 00:30:59,530
decouple print K from the console

00:30:56,020 --> 00:31:01,990
completely by doing this we can now have

00:30:59,530 --> 00:31:02,620
into individual iterators per console so

00:31:01,990 --> 00:31:04,540
every con

00:31:02,620 --> 00:31:06,580
so thread is just keeping track of where

00:31:04,540 --> 00:31:08,890
it is which means that if I have a

00:31:06,580 --> 00:31:10,030
really fast console it can get the

00:31:08,890 --> 00:31:11,559
messages out quickly and if I have a

00:31:10,030 --> 00:31:13,059
slow and it's going slow but the slow

00:31:11,559 --> 00:31:15,309
console is not affecting the fast

00:31:13,059 --> 00:31:18,280
console right so maybe on the network

00:31:15,309 --> 00:31:19,990
console I'm actually seeing that F trace

00:31:18,280 --> 00:31:21,550
dumped and I'm not missing anything and

00:31:19,990 --> 00:31:23,559
on the serial console I'm missing like

00:31:21,550 --> 00:31:26,440
90% of the messages but does it matter

00:31:23,559 --> 00:31:27,970
the way it is right now they all miss 90

00:31:26,440 --> 00:31:30,160
percent in the messages which is just

00:31:27,970 --> 00:31:31,809
insane right we've got these fast

00:31:30,160 --> 00:31:33,700
consoles and they're they're being tied

00:31:31,809 --> 00:31:36,700
to a stone because they're dragging a

00:31:33,700 --> 00:31:40,210
serial console with them right so we let

00:31:36,700 --> 00:31:41,800
them go fast there was also some patches

00:31:40,210 --> 00:31:44,080
floating around about individual log

00:31:41,800 --> 00:31:45,610
levels per console and this in this

00:31:44,080 --> 00:31:47,440
situation that would also be very good

00:31:45,610 --> 00:31:49,929
because we could say so if I have a fast

00:31:47,440 --> 00:31:51,490
console let it log a lot if I have a

00:31:49,929 --> 00:31:52,840
slow console let's have it log a little

00:31:51,490 --> 00:31:55,390
bit and you know we can we can play with

00:31:52,840 --> 00:31:57,309
these things and then obviously features

00:31:55,390 --> 00:31:59,350
like the exclusive console which is

00:31:57,309 --> 00:32:01,600
really in my opinion a real piece of

00:31:59,350 --> 00:32:03,550
duct tape they just disappear on their

00:32:01,600 --> 00:32:05,050
own every console has their own iterator

00:32:03,550 --> 00:32:06,580
they always start at the beginning and I

00:32:05,050 --> 00:32:10,090
just dump everything that there is right

00:32:06,580 --> 00:32:12,960
there not affected by each other so it

00:32:10,090 --> 00:32:16,270
makes a lot of sense in a lot of levels

00:32:12,960 --> 00:32:18,429
so one of the concerns about this first

00:32:16,270 --> 00:32:19,960
of all obviously what happened with that

00:32:18,429 --> 00:32:21,460
with the console lock we can't just

00:32:19,960 --> 00:32:23,170
ignore it and throw it away the console

00:32:21,460 --> 00:32:25,540
lock does serve a purpose

00:32:23,170 --> 00:32:26,830
one of the ideas from me was that we

00:32:25,540 --> 00:32:28,809
could turn it into something similar to

00:32:26,830 --> 00:32:30,640
a readwrite lock where we have lots of

00:32:28,809 --> 00:32:32,140
readers that are allowed to you to go in

00:32:30,640 --> 00:32:35,080
there in this case it would be the

00:32:32,140 --> 00:32:36,910
console K threads or for the people that

00:32:35,080 --> 00:32:39,100
are not part of print K so for example

00:32:36,910 --> 00:32:40,780
as far as I'm aware of the DRM the whole

00:32:39,100 --> 00:32:43,690
graphic infrastructure they're also

00:32:40,780 --> 00:32:45,130
taking the console lock if they take it

00:32:43,690 --> 00:32:47,440
okay then we'll keep all of our readers

00:32:45,130 --> 00:32:48,760
out of it but as soon as they're done

00:32:47,440 --> 00:32:51,280
with it then we can go ahead and let all

00:32:48,760 --> 00:32:54,309
readers go back in and get in their work

00:32:51,280 --> 00:32:56,679
with the consoles what we can also

00:32:54,309 --> 00:32:59,140
possibly do is use a per console lock

00:32:56,679 --> 00:33:01,780
which in my opinion would be sufficient

00:32:59,140 --> 00:33:03,550
because as far as I know the graphics

00:33:01,780 --> 00:33:05,830
loyd the the graphics people that are

00:33:03,550 --> 00:33:07,600
using this console semaphore they're

00:33:05,830 --> 00:33:09,429
basically just using it as some sort of

00:33:07,600 --> 00:33:11,679
special locking for their TT wise or

00:33:09,429 --> 00:33:13,330
whatever their displays so really if

00:33:11,679 --> 00:33:14,650
they each if each console has its own

00:33:13,330 --> 00:33:16,270
lock in my opinion that would be

00:33:14,650 --> 00:33:18,820
sufficient but we need to look at

00:33:16,270 --> 00:33:20,679
in detail print K itself doesn't need

00:33:18,820 --> 00:33:22,240
this to Const the consoles themselves

00:33:20,679 --> 00:33:25,929
don't need us but there are other people

00:33:22,240 --> 00:33:27,970
using this stuff because really at the

00:33:25,929 --> 00:33:29,860
end the print K should not care about

00:33:27,970 --> 00:33:33,070
the console at all they're just dumping

00:33:29,860 --> 00:33:35,200
messages to the ring buffer right the

00:33:33,070 --> 00:33:37,270
other concern is is can we rely on Keith

00:33:35,200 --> 00:33:39,880
heads for console printing and my answer

00:33:37,270 --> 00:33:42,010
is that's not what we're trying to solve

00:33:39,880 --> 00:33:44,770
here the K threads are not solving the

00:33:42,010 --> 00:33:45,460
reliability problem people need to stop

00:33:44,770 --> 00:33:46,870
thinking that

00:33:45,460 --> 00:33:48,610
yeah it's stop thinking and that's one

00:33:46,870 --> 00:33:51,880
problem and thinking of as two problems

00:33:48,610 --> 00:33:53,800
the K threads are solving the issue of

00:33:51,880 --> 00:33:55,090
non-interference right there's other

00:33:53,800 --> 00:34:00,880
things that we'll see in the slides

00:33:55,090 --> 00:34:02,530
about solving the the reliability so if

00:34:00,880 --> 00:34:03,820
we can learn to stop pulling on each

00:34:02,530 --> 00:34:06,160
other then we can actually start

00:34:03,820 --> 00:34:08,050
focusing how can we make the reliability

00:34:06,160 --> 00:34:09,970
solution more reliable how can we make

00:34:08,050 --> 00:34:13,720
the non interface interference solution

00:34:09,970 --> 00:34:15,820
more more non-interfering right if you

00:34:13,720 --> 00:34:18,220
go to reliability I introduced something

00:34:15,820 --> 00:34:20,350
called atomic consoles that's a new

00:34:18,220 --> 00:34:22,179
special call back in the console

00:34:20,350 --> 00:34:24,550
structure called right atomic it's

00:34:22,179 --> 00:34:26,770
basically like an early print k but it's

00:34:24,550 --> 00:34:29,740
safe yeah so we have early print K

00:34:26,770 --> 00:34:31,450
implementations for drivers but they're

00:34:29,740 --> 00:34:33,580
not they're not safe they just kind of

00:34:31,450 --> 00:34:36,220
just override the registers and don't

00:34:33,580 --> 00:34:38,470
worry about anything that's not gonna

00:34:36,220 --> 00:34:40,869
work if two of two different CPUs are

00:34:38,470 --> 00:34:43,060
doing that at the same time right so

00:34:40,869 --> 00:34:45,460
let's create an atomic callback to

00:34:43,060 --> 00:34:48,790
really allow consoles to actually

00:34:45,460 --> 00:34:50,679
implement on their driver a writing that

00:34:48,790 --> 00:34:56,230
is truly atomic that can be called from

00:34:50,679 --> 00:34:58,600
any context sorry it also goes into

00:34:56,230 --> 00:35:01,150
atomic consoles are also synchronous so

00:34:58,600 --> 00:35:02,680
if I'm gonna do an atomic write then I'm

00:35:01,150 --> 00:35:04,119
actually going to sit there in that

00:35:02,680 --> 00:35:05,500
atomic write until it's done this is

00:35:04,119 --> 00:35:07,300
kind of going back to the roots of print

00:35:05,500 --> 00:35:08,800
k zero zero one where you're actually

00:35:07,300 --> 00:35:11,500
sitting there until it's out there

00:35:08,800 --> 00:35:12,760
alright so we want to be reliable I'm

00:35:11,500 --> 00:35:14,619
not just gonna throw it in there and

00:35:12,760 --> 00:35:16,750
hope someone else printed it no I'm

00:35:14,619 --> 00:35:18,010
gonna sit there and I'm going to print

00:35:16,750 --> 00:35:24,460
it and I'm going to say sitting here

00:35:18,010 --> 00:35:25,890
until it's printed by doing that we can

00:35:24,460 --> 00:35:28,119
actually ignore the console lock

00:35:25,890 --> 00:35:29,619
altogether because we're doing something

00:35:28,119 --> 00:35:31,089
special there

00:35:29,619 --> 00:35:32,769
right so we're doing something atomic

00:35:31,089 --> 00:35:34,059
and the drivers are the ones that are

00:35:32,769 --> 00:35:35,980
gonna have to implement this right so if

00:35:34,059 --> 00:35:37,660
I have a driver and I have the right

00:35:35,980 --> 00:35:39,460
function and I have the right atomic

00:35:37,660 --> 00:35:40,900
function and it's my responsibility as

00:35:39,460 --> 00:35:42,700
the driver author to make sure that

00:35:40,900 --> 00:35:45,190
those two things are synchronized and

00:35:42,700 --> 00:35:47,980
actually you can use the CPU lock to do

00:35:45,190 --> 00:35:49,420
this now we don't want to use this

00:35:47,980 --> 00:35:51,309
reliability atomic consoles for

00:35:49,420 --> 00:35:52,720
everything because obviously if I'm

00:35:51,309 --> 00:35:54,190
gonna sit in there and block until it's

00:35:52,720 --> 00:35:56,640
done this is really going to slow my

00:35:54,190 --> 00:35:59,499
system down this is going to be major

00:35:56,640 --> 00:36:00,640
interference on general level right but

00:35:59,499 --> 00:36:01,839
we're not this is not dealing with

00:36:00,640 --> 00:36:04,480
interference this is dealing with the

00:36:01,839 --> 00:36:06,849
reliability and so really of the only

00:36:04,480 --> 00:36:09,309
things we want to reliably are the

00:36:06,849 --> 00:36:11,470
critical messages not all the messages

00:36:09,309 --> 00:36:13,390
right so the only thing we really want

00:36:11,470 --> 00:36:16,950
to be printing our emergency messages

00:36:13,390 --> 00:36:16,950
which we'll see in the next two slides

00:36:17,759 --> 00:36:22,930
what's also nice about when because

00:36:19,869 --> 00:36:25,720
preempt RT is going remain line which

00:36:22,930 --> 00:36:27,160
means that the spin locks that the

00:36:25,720 --> 00:36:28,480
different console drivers are taking are

00:36:27,160 --> 00:36:32,769
not actually spin locks they can

00:36:28,480 --> 00:36:35,499
actually sleep which means if we've got

00:36:32,769 --> 00:36:37,930
these atomic consoles that are available

00:36:35,499 --> 00:36:39,880
for preempt RT then we can actually

00:36:37,930 --> 00:36:42,609
still do this reliability through the

00:36:39,880 --> 00:36:44,529
atomic writes but the normal rights can

00:36:42,609 --> 00:36:46,539
still be sleeping spin locks and we

00:36:44,529 --> 00:36:49,029
don't have to worry about anything

00:36:46,539 --> 00:37:03,549
we gate regarding latencies of console

00:36:49,029 --> 00:37:07,869
drivers right so this it makes sense for

00:37:03,549 --> 00:37:10,089
everybody right so really there's yeah

00:37:07,869 --> 00:37:11,890
but the difference is may RT they're not

00:37:10,089 --> 00:37:14,980
actually spin locks that are disabling

00:37:11,890 --> 00:37:17,019
interrupts so we can actually if we when

00:37:14,980 --> 00:37:20,589
we get to this ignoring of the latency

00:37:17,019 --> 00:37:22,569
that we can actually do that because the

00:37:20,589 --> 00:37:24,039
drivers are still doing spin lock our

00:37:22,569 --> 00:37:25,900
cue safe right that the code is there

00:37:24,039 --> 00:37:29,259
right so only in the pre M - RT is that

00:37:25,900 --> 00:37:31,210
not actually disabling intro's anyway if

00:37:29,259 --> 00:37:32,710
we when we have these atomic consoles

00:37:31,210 --> 00:37:34,299
then we also don't need these special

00:37:32,710 --> 00:37:36,130
ops in progress that's supposed to be

00:37:34,299 --> 00:37:37,809
evaluated by the different drivers to do

00:37:36,130 --> 00:37:39,279
something special and we don't need to

00:37:37,809 --> 00:37:42,130
ignore our locks because we have a

00:37:39,279 --> 00:37:44,109
function available to just right

00:37:42,130 --> 00:37:46,690
now the concerns with the atomic

00:37:44,109 --> 00:37:49,509
consoles are how many drivers could we

00:37:46,690 --> 00:37:51,279
actually implement to be atomic in my

00:37:49,509 --> 00:37:52,529
first release candidate I implemented

00:37:51,279 --> 00:37:55,869
the 8250 UART

00:37:52,529 --> 00:37:58,210
as an example but it was not trivial it

00:37:55,869 --> 00:37:59,349
you have to be really careful there to

00:37:58,210 --> 00:38:04,089
synchronize that and you have to make

00:37:59,349 --> 00:38:05,859
use of the CPU lock and basically the

00:38:04,089 --> 00:38:08,019
way it worked is for example when

00:38:05,859 --> 00:38:10,359
writing the serial we're using the CPU

00:38:08,019 --> 00:38:12,640
lock to synchronize per character and

00:38:10,359 --> 00:38:14,769
reason the CPU lock per line for the

00:38:12,640 --> 00:38:17,229
emergency for the emergency messages

00:38:14,769 --> 00:38:18,729
right so at the the serial is allowed to

00:38:17,229 --> 00:38:20,079
do one character at a time which is just

00:38:18,729 --> 00:38:22,059
putting on the FIFO that's really fast

00:38:20,079 --> 00:38:24,519
and then but if a whole line comes along

00:38:22,059 --> 00:38:28,410
then we can actually interrupt that at

00:38:24,519 --> 00:38:31,920
the atomic level and do an entire line

00:38:28,410 --> 00:38:33,819
it was also the question of can at

00:38:31,920 --> 00:38:36,400
something be done for systems without

00:38:33,819 --> 00:38:36,789
atomic consoles because you know let's

00:38:36,400 --> 00:38:38,640
face it

00:38:36,789 --> 00:38:41,650
people have to write these atomic write

00:38:38,640 --> 00:38:43,539
function everywhere and maybe they can't

00:38:41,650 --> 00:38:45,249
figure it out or it just doesn't exist

00:38:43,539 --> 00:38:47,380
so there were some different ideas

00:38:45,249 --> 00:38:49,180
floating around about how we can help

00:38:47,380 --> 00:38:51,460
these systems that actually don't have

00:38:49,180 --> 00:38:53,920
atomic consoles for example in US

00:38:51,460 --> 00:38:56,890
recently threw up the idea that we could

00:38:53,920 --> 00:38:59,410
throw things into a separate memory area

00:38:56,890 --> 00:39:01,239
bowl and a reliable address and when the

00:38:59,410 --> 00:39:02,739
system reboots maybe we can still read

00:39:01,239 --> 00:39:04,960
that area and there's actually some

00:39:02,739 --> 00:39:06,519
tests around and amazingly after you to

00:39:04,960 --> 00:39:08,979
reboot your system you can actually in

00:39:06,519 --> 00:39:10,509
many situations read most of that memory

00:39:08,979 --> 00:39:12,849
again so that might be something that

00:39:10,509 --> 00:39:14,349
could be interesting we could try some

00:39:12,849 --> 00:39:17,650
things like trying to print

00:39:14,349 --> 00:39:19,450
synchronously if we're not in an atomic

00:39:17,650 --> 00:39:21,640
context assuming we can even detect that

00:39:19,450 --> 00:39:24,640
or we could fall back to the craziness

00:39:21,640 --> 00:39:27,519
of that we're doing today in my opinion

00:39:24,640 --> 00:39:28,930
we we really need to split this and we

00:39:27,519 --> 00:39:30,549
need to start handling our separate

00:39:28,930 --> 00:39:33,940
solutions and that people start to deal

00:39:30,549 --> 00:39:35,799
with the atomic console problem but you

00:39:33,940 --> 00:39:38,440
know reality is a different situation so

00:39:35,799 --> 00:39:42,009
we stuff to decide on that yeah but the

00:39:38,440 --> 00:39:45,640
thing is right now we have a mindset

00:39:42,009 --> 00:39:47,890
that we think something must work for

00:39:45,640 --> 00:39:50,079
all consoles or it can't work for any

00:39:47,890 --> 00:39:52,299
which is wrong because they are hardware

00:39:50,079 --> 00:39:54,029
from the hardware side totally different

00:39:52,299 --> 00:39:58,979
and

00:39:54,029 --> 00:40:03,509
so a lot of machines still have cereal

00:39:58,979 --> 00:40:08,009
in the data centers in or boxes which

00:40:03,509 --> 00:40:10,979
developers use and so we a lot of people

00:40:08,009 --> 00:40:14,069
including me and Peter and who else has

00:40:10,979 --> 00:40:17,549
a random hacks to make it work even if

00:40:14,069 --> 00:40:20,399
the thing crashes in an MI so but that's

00:40:17,549 --> 00:40:23,309
not a solution so we really should

00:40:20,399 --> 00:40:25,289
understand and should accept that there

00:40:23,309 --> 00:40:28,199
is harder which can provide atomic

00:40:25,289 --> 00:40:31,559
rights and their soda which can't and we

00:40:28,199 --> 00:40:33,929
can solve the problem with with with the

00:40:31,559 --> 00:40:36,479
the graphic stuff at all

00:40:33,929 --> 00:40:41,339
I mean unless there is a switch in the

00:40:36,479 --> 00:40:44,759
graphics device very say I write into

00:40:41,339 --> 00:40:46,949
this and now the hardware itself or the

00:40:44,759 --> 00:40:49,529
firm very inverse which is reliably to

00:40:46,949 --> 00:40:51,119
VGA mode and then they are working on

00:40:49,529 --> 00:40:53,369
the secretary now yeah and I think I'll

00:40:51,119 --> 00:40:56,129
make it to yeah but this is the only way

00:40:53,369 --> 00:40:58,679
how this can be solved

00:40:56,129 --> 00:41:01,469
I was recently cruising about that whole

00:40:58,679 --> 00:41:02,939
thing because I was trying to debug

00:41:01,469 --> 00:41:07,169
something which would mean it a laptop

00:41:02,939 --> 00:41:14,989
to debug so it never made anything to

00:41:07,169 --> 00:41:17,519
any scream so it just doesn't work that

00:41:14,989 --> 00:41:21,029
discussion came up after after I

00:41:17,519 --> 00:41:24,449
actually figure it out what what was

00:41:21,029 --> 00:41:27,899
broken but I mean save it but for a lot

00:41:24,449 --> 00:41:33,599
of my other work I have consoles which

00:41:27,899 --> 00:41:35,969
allow atomic so the the the the the

00:41:33,599 --> 00:41:37,949
world console can that can do the atomic

00:41:35,969 --> 00:41:40,379
I mean there are a lot that don't as

00:41:37,949 --> 00:41:43,919
well so yes I shout out to all the

00:41:40,379 --> 00:41:47,309
hardware people awesome stuff like a USB

00:41:43,919 --> 00:41:52,219
deeper part do not work in yet to my

00:41:47,309 --> 00:41:52,219
context such useless

00:42:08,880 --> 00:42:14,020
and I think that once the colonel

00:42:11,740 --> 00:42:15,760
officially provides an interface right

00:42:14,020 --> 00:42:17,650
we officially say we want to do this

00:42:15,760 --> 00:42:19,420
split then it becomes more interesting

00:42:17,650 --> 00:42:20,770
for drivers we have a lot of brilliant

00:42:19,420 --> 00:42:22,119
people out there that'll actually figure

00:42:20,770 --> 00:42:23,380
out how to make things work atomic or

00:42:22,119 --> 00:42:24,790
there'll be new hardware people doing

00:42:23,380 --> 00:42:27,760
things atomic but right now we're just

00:42:24,790 --> 00:42:29,589
paper taping over everything and no

00:42:27,760 --> 00:42:33,040
one's doing anything about it except for

00:42:29,589 --> 00:42:34,839
screaming when it doesn't work so the

00:42:33,040 --> 00:42:37,599
last thing on the list of things is

00:42:34,839 --> 00:42:39,579
emergency messages which means that at

00:42:37,599 --> 00:42:40,839
any point we can have certain messages

00:42:39,579 --> 00:42:43,119
that were sending into the print came

00:42:40,839 --> 00:42:45,660
from structure that we're tagging for

00:42:43,119 --> 00:42:48,550
immediate and synchronous printing

00:42:45,660 --> 00:42:49,510
obviously the concerns here are what is

00:42:48,550 --> 00:42:52,329
considered important

00:42:49,510 --> 00:42:54,579
so my first version actually used a log

00:42:52,329 --> 00:42:57,640
level but but that's pretty hard to do

00:42:54,579 --> 00:42:59,740
but it works but that log level is kind

00:42:57,640 --> 00:43:01,569
of a gray area what's you know it's

00:42:59,740 --> 00:43:03,880
warning really warning or not or you

00:43:01,569 --> 00:43:05,349
know are people misusing that so you

00:43:03,880 --> 00:43:07,180
know there are other ideas from me that

00:43:05,349 --> 00:43:08,940
maybe log level I'm kind of impression

00:43:07,180 --> 00:43:11,500
that log level is not the way to go

00:43:08,940 --> 00:43:12,339
there's only certain situations you know

00:43:11,500 --> 00:43:14,680
bug warned

00:43:12,339 --> 00:43:16,599
oops panic you know it just helped let's

00:43:14,680 --> 00:43:19,420
just maybe have the developers decide

00:43:16,599 --> 00:43:20,530
what's really important the things we're

00:43:19,420 --> 00:43:22,240
sending mainline for when a thing

00:43:20,530 --> 00:43:25,540
crashes and we can just use the atomic

00:43:22,240 --> 00:43:26,800
writes for that another option is maybe

00:43:25,540 --> 00:43:28,660
that the comes counsel drivers

00:43:26,800 --> 00:43:30,849
themselves somehow decide I'm not sure

00:43:28,660 --> 00:43:33,520
about this but you know for example what

00:43:30,849 --> 00:43:35,470
what Linna spur offered that we could

00:43:33,520 --> 00:43:36,760
have you know a memory area we want

00:43:35,470 --> 00:43:38,410
everything to kind of go in there then

00:43:36,760 --> 00:43:41,109
that's kind of the the console the

00:43:38,410 --> 00:43:42,550
special console that's deciding that or

00:43:41,109 --> 00:43:43,990
maybe the user should decide maybe we

00:43:42,550 --> 00:43:45,430
should be using log level threshold and

00:43:43,990 --> 00:43:47,920
we just need to clean up our log levels

00:43:45,430 --> 00:43:49,810
right because maybe a user says I don't

00:43:47,920 --> 00:43:52,240
care I want everything synchronous right

00:43:49,810 --> 00:43:53,619
or they say no I just want certain types

00:43:52,240 --> 00:43:55,480
of messages to be synchronous I don't

00:43:53,619 --> 00:43:57,400
know this this is like I said I'd done

00:43:55,480 --> 00:43:59,109
an implementation with log level and we

00:43:57,400 --> 00:44:00,609
get it to work but system D likes to

00:43:59,109 --> 00:44:04,979
play with log levels a lot so it's hard

00:44:00,609 --> 00:44:13,749
to to kind of keep that filtered

00:44:04,979 --> 00:44:14,979
yeah ignore love you so I'm kinda ran

00:44:13,749 --> 00:44:16,689
out of time here so I'm just gonna kind

00:44:14,979 --> 00:44:19,029
of finish up really quick so the status

00:44:16,689 --> 00:44:23,199
until now you see this began way back in

00:44:19,029 --> 00:44:27,459
February of 2018 my last post was the

00:44:23,199 --> 00:44:29,919
RFC version for last month and we're

00:44:27,459 --> 00:44:33,429
still discussing on the things there in

00:44:29,919 --> 00:44:35,079
particular it's still some things that

00:44:33,429 --> 00:44:38,679
they think that it's considered too

00:44:35,079 --> 00:44:40,839
complicated that we need to sort out now

00:44:38,679 --> 00:44:43,119
one thing to note is is that the RFC

00:44:40,839 --> 00:44:45,519
version 1 which is using the CPU lock

00:44:43,119 --> 00:44:50,259
ring buffer is actually part of the

00:44:45,519 --> 00:44:51,669
preempt series since 5:03 so the RT

00:44:50,259 --> 00:44:52,719
people are actually already switched

00:44:51,669 --> 00:44:53,979
over

00:44:52,719 --> 00:44:56,589
but that's using a different ring buffer

00:44:53,979 --> 00:44:59,469
that I'm currently posting so I don't

00:44:56,589 --> 00:45:00,669
know looking forward I was gonna kind of

00:44:59,469 --> 00:45:03,119
put down these are the steps that we've

00:45:00,669 --> 00:45:05,859
kind of outlined how we want to continue

00:45:03,119 --> 00:45:07,899
we want to start off by replacing the

00:45:05,859 --> 00:45:11,529
the mainline ring buffer just kind of

00:45:07,899 --> 00:45:13,209
goes slowly then we will need to fix log

00:45:11,529 --> 00:45:15,369
continuous that it actually works and am

00:45:13,209 --> 00:45:18,429
i safe then we can remove that log buff

00:45:15,369 --> 00:45:20,559
lock remove the SAF buffers introduced

00:45:18,429 --> 00:45:22,389
per console threads maybe something

00:45:20,559 --> 00:45:24,039
similar to thread I recuse now to kind

00:45:22,389 --> 00:45:25,599
of let people kind of migrate into it

00:45:24,039 --> 00:45:27,429
they can at the beginning they can

00:45:25,599 --> 00:45:30,429
actually choose if they want to have it

00:45:27,429 --> 00:45:34,629
or not we're gonna have to decide the

00:45:30,429 --> 00:45:35,859
emergency messages thing and yeah the

00:45:34,629 --> 00:45:39,339
right Atomics we're also going to need

00:45:35,859 --> 00:45:41,349
so anyway the point thing here is this

00:45:39,339 --> 00:45:44,589
is not just a huge to-do list actually

00:45:41,349 --> 00:45:46,779
RFC one implemented like 95 percent of

00:45:44,589 --> 00:45:49,239
this right so it's there is actual code

00:45:46,779 --> 00:45:51,669
there maybe it can't be used as it was

00:45:49,239 --> 00:45:53,229
with the RFC version 1 but there isn't

00:45:51,669 --> 00:45:55,779
you can do a lot of testing it is in the

00:45:53,229 --> 00:45:57,369
preempt RT patch set and we can actually

00:45:55,779 --> 00:45:59,229
you know really see how these things

00:45:57,369 --> 00:46:01,239
work if they are really as reliable as

00:45:59,229 --> 00:46:03,009
we think they are and if there is known

00:46:01,239 --> 00:46:06,369
as non-interfering this we think they

00:46:03,009 --> 00:46:07,929
are really quick thanks to a lot of

00:46:06,369 --> 00:46:10,719
people that gave me an enormous amount

00:46:07,929 --> 00:46:12,129
of support working on this there's no

00:46:10,719 --> 00:46:13,989
way I could have done this myself print

00:46:12,129 --> 00:46:17,770
K is way too big it's coming up it's

00:46:13,989 --> 00:46:19,990
approaching 30 years old and that's just

00:46:17,770 --> 00:46:21,340
it's got a lot of history and also to

00:46:19,990 --> 00:46:24,280
the Linux Foundation for helping us

00:46:21,340 --> 00:46:25,930
bring preempt RT mainline we pray don't

00:46:24,280 --> 00:46:27,490
have time for questions but maybe if

00:46:25,930 --> 00:46:28,960
there's one or two good ones otherwise

00:46:27,490 --> 00:46:38,260
I'm happy to talk about this all day

00:46:28,960 --> 00:46:42,670
outside so how about the trace the

00:46:38,260 --> 00:46:44,590
tracing printing the F trace you try yes

00:46:42,670 --> 00:46:47,350
yes actually I tried use F trays in the

00:46:44,590 --> 00:46:49,890
beginning F trace has two problems first

00:46:47,350 --> 00:46:52,180
of all it's designed for per CPU usage

00:46:49,890 --> 00:46:55,050
so which means we're gonna have to

00:46:52,180 --> 00:46:57,580
create large buffers on every single CPU

00:46:55,050 --> 00:46:59,560
even though we may not be using 90% of

00:46:57,580 --> 00:47:01,780
those buffers right so if I have 128

00:46:59,560 --> 00:47:04,090
CPUs and everyone's getting a megabyte

00:47:01,780 --> 00:47:05,620
maybe we don't care maybe that is ok so

00:47:04,090 --> 00:47:07,300
that's the one issue is that we can't a

00:47:05,620 --> 00:47:11,920
fish we can't efficiently use those

00:47:07,300 --> 00:47:14,470
buffers the second issue is that F trace

00:47:11,920 --> 00:47:16,990
is not lock list for reading so the non

00:47:14,470 --> 00:47:18,970
consuming readers and F trace do have to

00:47:16,990 --> 00:47:21,790
take locks right so that's also not

00:47:18,970 --> 00:47:25,840
acceptable so that was another problem

00:47:21,790 --> 00:47:27,640
that I had so with those two issues it

00:47:25,840 --> 00:47:29,680
was decided that I should spend my

00:47:27,640 --> 00:47:31,300
effort just making a print case-specific

00:47:29,680 --> 00:47:33,610
ring buffer rather than using F trace

00:47:31,300 --> 00:47:36,400
and this by the way this buffer is not

00:47:33,610 --> 00:47:37,750
interesting for F trace because of the

00:47:36,400 --> 00:47:40,480
fact that it's a global shared buffer

00:47:37,750 --> 00:47:43,120
right so f trace is optimized to be per

00:47:40,480 --> 00:47:44,410
CPU also that all the cache alignment

00:47:43,120 --> 00:47:46,750
and everything is doing is really great

00:47:44,410 --> 00:47:48,640
so that we're not you know it's the CPUs

00:47:46,750 --> 00:47:50,860
are not killing each other whereas this

00:47:48,640 --> 00:47:53,170
one we have a global thing so I I'm only

00:47:50,860 --> 00:47:55,420
I've done tests and it takes about on a

00:47:53,170 --> 00:47:58,300
modern arm 64 you know one and a half

00:47:55,420 --> 00:48:00,490
microseconds per print K into that ring

00:47:58,300 --> 00:48:02,290
buffer and F trace can go about six

00:48:00,490 --> 00:48:04,720
times that speed right so it's

00:48:02,290 --> 00:48:06,250
considerably slower than f trace but it

00:48:04,720 --> 00:48:09,930
also supports different things in if

00:48:06,250 --> 00:48:12,790
trace so would it make sense to kind of

00:48:09,930 --> 00:48:14,980
make it configurable in some way so that

00:48:12,790 --> 00:48:20,260
for some in some cases we would like to

00:48:14,980 --> 00:48:22,390
have use F tries for all F trace like

00:48:20,260 --> 00:48:24,280
semantics for print K so what we can

00:48:22,390 --> 00:48:27,670
have one framework instead of two for

00:48:24,280 --> 00:48:30,130
printing I mean that we surely can

00:48:27,670 --> 00:48:31,180
at some point experiment with it but I

00:48:30,130 --> 00:48:34,080
at the

00:48:31,180 --> 00:48:35,740
and I would go for keep it simple first

00:48:34,080 --> 00:48:37,870
make it work

00:48:35,740 --> 00:48:40,750
solve the problems we have and then

00:48:37,870 --> 00:48:42,870
introduce new ones not the other way

00:48:40,750 --> 00:48:42,870
around

00:48:43,830 --> 00:48:49,090
any other questions

00:48:46,560 --> 00:48:50,200
so we're just missing lunch we're just

00:48:49,090 --> 00:48:53,920
be missing the beginning of lunch right

00:48:50,200 --> 00:49:01,950
now so no one has to panic about so

00:48:53,920 --> 00:49:07,180
missing the long lines and I'm curious

00:49:01,950 --> 00:49:11,290
who pays you for that and why exactly I

00:49:07,180 --> 00:49:15,160
mean as I said it's good but what why

00:49:11,290 --> 00:49:18,220
why you employ right so so we all know

00:49:15,160 --> 00:49:21,340
why I employed him yeah I don't know why

00:49:18,220 --> 00:49:23,200
I'm happy that he did though so we this

00:49:21,340 --> 00:49:25,630
actually initially this whole effort

00:49:23,200 --> 00:49:28,180
became part of the umbrella from the

00:49:25,630 --> 00:49:30,730
Linux Foundation trying to bring prank

00:49:28,180 --> 00:49:33,460
in real time but we've actually extended

00:49:30,730 --> 00:49:35,050
beyond what that funding could give so

00:49:33,460 --> 00:49:38,260
it was initially I think we thought

00:49:35,050 --> 00:49:40,420
would take a month right and so you know

00:49:38,260 --> 00:49:41,650
there's a lot of my own personal private

00:49:40,420 --> 00:49:43,270
time my own interest

00:49:41,650 --> 00:49:45,250
I mean I'm got my I have my name out

00:49:43,270 --> 00:49:47,200
there I'm working on this I also want to

00:49:45,250 --> 00:49:49,900
see it working I'm a big realtime fan so

00:49:47,200 --> 00:49:52,420
I want it to work and the end maintainer

00:49:49,900 --> 00:49:54,730
you know like Peter who's spending weeks

00:49:52,420 --> 00:49:57,640
and now Peter who's doing all kinds of

00:49:54,730 --> 00:49:59,980
reviews there's no one really paying for

00:49:57,640 --> 00:50:01,120
that but that's I mean we're kind of we

00:49:59,980 --> 00:50:04,180
get to do it during work I guess

00:50:01,120 --> 00:50:05,800
sometimes but yeah there's I'm not

00:50:04,180 --> 00:50:08,800
getting paid full time to work on this

00:50:05,800 --> 00:50:12,060
for sure not because it's it's way too

00:50:08,800 --> 00:50:13,870
expensive it's it's there's so much

00:50:12,060 --> 00:50:15,070
stuff especially with the memory

00:50:13,870 --> 00:50:16,720
barriers I really encourage people to

00:50:15,070 --> 00:50:19,690
download this and look at the following

00:50:16,720 --> 00:50:21,010
slides the in the appendix that really

00:50:19,690 --> 00:50:23,590
go into the memory bearers and the dock

00:50:21,010 --> 00:50:25,300
is just so much stuff there I think when

00:50:23,590 --> 00:50:27,460
we started doing this we didn't realize

00:50:25,300 --> 00:50:29,170
how much baggage that we would have to

00:50:27,460 --> 00:50:30,940
go into there's so much history so many

00:50:29,170 --> 00:50:35,500
requirements and it really is a quite

00:50:30,940 --> 00:50:37,570
complicated topic so yeah but I'm happy

00:50:35,500 --> 00:50:41,990
to to improve the world right so it's

00:50:37,570 --> 00:50:45,900
it's okay I love Linux

00:50:41,990 --> 00:50:52,170
you be in the back did you throw your

00:50:45,900 --> 00:50:54,420
box to the corner so since you you're

00:50:52,170 --> 00:50:56,130
introducing emergency messages doesn't

00:50:54,420 --> 00:50:59,220
that necessarily mean that you could

00:50:56,130 --> 00:51:01,589
that those might be out of sequence as

00:50:59,220 --> 00:51:02,849
they're printed if you have some non

00:51:01,589 --> 00:51:05,520
emergency messages that happen before

00:51:02,849 --> 00:51:06,119
yes okay but the timestamps are all

00:51:05,520 --> 00:51:08,040
accurate

00:51:06,119 --> 00:51:10,710
also the timestamps are when they when

00:51:08,040 --> 00:51:12,210
they're yes so the reason why the

00:51:10,710 --> 00:51:14,250
timestamps right now are not accurate is

00:51:12,210 --> 00:51:16,080
because of the safe buffers but once we

00:51:14,250 --> 00:51:18,119
have a lock less ring buffer then we can

00:51:16,080 --> 00:51:20,240
just we can put those in right now right

00:51:18,119 --> 00:51:22,830
so all the timestamps are accurate so

00:51:20,240 --> 00:51:25,440
going back to your example if like a USB

00:51:22,830 --> 00:51:27,060
Drive is plugged in and then I was

00:51:25,440 --> 00:51:30,000
thinking well what would happen if that

00:51:27,060 --> 00:51:31,530
caused a panic in itself you'd give some

00:51:30,000 --> 00:51:33,480
messages out of sequence but you'd see

00:51:31,530 --> 00:51:35,250
you would eventually see all of them and

00:51:33,480 --> 00:51:36,839
from the times - yeah for example like a

00:51:35,250 --> 00:51:38,310
worn on or something right so and a worn

00:51:36,839 --> 00:51:40,380
on comes right away maybe you see that

00:51:38,310 --> 00:51:42,599
and then you see a bunch of messages

00:51:40,380 --> 00:51:44,640
that actually came before that but it

00:51:42,599 --> 00:51:46,170
can't that was printed synchronously and

00:51:44,640 --> 00:51:47,400
the other things were printed by the Kay

00:51:46,170 --> 00:51:49,349
thread which maybe got scheduled

00:51:47,400 --> 00:51:52,320
afterwards right but the timestamps are

00:51:49,349 --> 00:51:55,349
there also you mentioned there's RAM

00:51:52,320 --> 00:51:56,970
buffer that is I'm not sure if that's

00:51:55,349 --> 00:52:01,650
necessarily a new idea because we've had

00:51:56,970 --> 00:52:04,320
a brand moves for a while yeah that's

00:52:01,650 --> 00:52:05,640
true yeah so let's just talked about

00:52:04,320 --> 00:52:09,270
less the two weeks ago or something I

00:52:05,640 --> 00:52:12,210
would about having it on the machines

00:52:09,270 --> 00:52:15,240
which do not have persistent RAM buffers

00:52:12,210 --> 00:52:17,099
which is show users laptop and that's

00:52:15,240 --> 00:52:19,890
what we care about because that's what

00:52:17,099 --> 00:52:24,570
we can't deep back right now because we

00:52:19,890 --> 00:52:30,060
lose all the information so in there was

00:52:24,570 --> 00:52:33,089
some experiment how much DRAM actually

00:52:30,060 --> 00:52:36,720
retains information over a reset or even

00:52:33,089 --> 00:52:39,420
over a power off which is impressive so

00:52:36,720 --> 00:52:42,089
but of course what we really want and we

00:52:39,420 --> 00:52:45,349
were asking for that for 20 plus years

00:52:42,089 --> 00:52:49,770
now and not getting it from the hardware

00:52:45,349 --> 00:52:54,020
or people is actually persistent storage

00:52:49,770 --> 00:52:57,140
for exactly that purpose maybe we

00:52:54,020 --> 00:52:59,810
if if it's there is if the the

00:52:57,140 --> 00:53:02,390
persistent story exists on the hardware

00:52:59,810 --> 00:53:04,580
it's just a matter of writing a console

00:53:02,390 --> 00:53:08,210
driver which writes out to that saying

00:53:04,580 --> 00:53:11,630
and with that split that console driver

00:53:08,210 --> 00:53:16,130
can write out anything and can even

00:53:11,630 --> 00:53:18,830
write out synchronous all the time so

00:53:16,130 --> 00:53:21,470
that's the that's the interesting change

00:53:18,830 --> 00:53:23,810
to the current mode to the current mode

00:53:21,470 --> 00:53:26,390
we just treat everything the same way

00:53:23,810 --> 00:53:29,600
now when we switch over to something

00:53:26,390 --> 00:53:33,740
which is really useful like persistent

00:53:29,600 --> 00:53:37,640
persistent storage we which is which has

00:53:33,740 --> 00:53:39,680
no limitations in locking or one hour we

00:53:37,640 --> 00:53:42,860
just came right out to it and be done

00:53:39,680 --> 00:53:50,420
with it so that's where where we want to

00:53:42,860 --> 00:53:56,720
go and I mean did now if IP store

00:53:50,420 --> 00:54:01,970
doesn't account if pypy store is be

00:53:56,720 --> 00:54:03,320
stored now this boot but it would be

00:54:01,970 --> 00:54:04,760
nice to have something integrated into

00:54:03,320 --> 00:54:06,140
print kay right so we're using these

00:54:04,760 --> 00:54:07,910
kind of things and the Machine does this

00:54:06,140 --> 00:54:08,990
reboot and then all those messages are

00:54:07,910 --> 00:54:10,970
put right back into the ring buffer

00:54:08,990 --> 00:54:12,920
right so my machine crashes I don't see

00:54:10,970 --> 00:54:14,510
anything but I hit reset and I come back

00:54:12,920 --> 00:54:15,710
up and I can D message and I see them

00:54:14,510 --> 00:54:17,540
all like something like that like an

00:54:15,710 --> 00:54:20,000
integrated solution would be nice and

00:54:17,540 --> 00:54:22,310
and we're back to your initial question

00:54:20,000 --> 00:54:24,230
about ordering I mean if there is an

00:54:22,310 --> 00:54:25,940
emergency where you really want to see

00:54:24,230 --> 00:54:27,500
the emergency and that's the most

00:54:25,940 --> 00:54:30,859
important thing we need to get out

00:54:27,500 --> 00:54:33,170
because in a lot of situations where the

00:54:30,859 --> 00:54:35,240
machine is actually crashing the most

00:54:33,170 --> 00:54:40,820
important thing you need to get is the

00:54:35,240 --> 00:54:45,320
is the back trace and one and the

00:54:40,820 --> 00:54:49,010
register them yeah the less interesting

00:54:45,320 --> 00:54:51,350
part is older oh I loaded five thousand

00:54:49,010 --> 00:54:53,960
gazillion modules and things like that

00:54:51,350 --> 00:54:56,390
but anyway it's there so that the the

00:54:53,960 --> 00:55:00,080
the the thing right now we often do not

00:54:56,390 --> 00:55:03,200
get the back trace out of the out of out

00:55:00,080 --> 00:55:05,420
of the prim KB chests or lost in

00:55:03,200 --> 00:55:07,490
something and that's especially true

00:55:05,420 --> 00:55:11,350
when the when the crash

00:55:07,490 --> 00:55:15,670
mr. right while the driver while loading

00:55:11,350 --> 00:55:18,500
print case and then the interrupts hits

00:55:15,670 --> 00:55:21,410
crashes because the driver wasn't yet

00:55:18,500 --> 00:55:23,060
fully initialized and then you just lock

00:55:21,410 --> 00:55:25,660
up the machine and be done with it

00:55:23,060 --> 00:55:30,230
and that's what we want to get away with

00:55:25,660 --> 00:55:42,820
and everything after that is nice to

00:55:30,230 --> 00:55:46,640
have so I was wondering if there's an

00:55:42,820 --> 00:55:48,950
agreed approach for cases where you

00:55:46,640 --> 00:55:51,140
print out a ton of stuff over print kay

00:55:48,950 --> 00:55:53,810
but too much for PR can't be reasonable

00:55:51,140 --> 00:55:56,330
like if particular nasty things happen

00:55:53,810 --> 00:55:58,250
you can get an oops on multiple CPUs at

00:55:56,330 --> 00:56:02,510
the same time and then it's difficult to

00:55:58,250 --> 00:56:05,120
Dan to leave there one approach might be

00:56:02,510 --> 00:56:07,040
you add a CPU number or some context on

00:56:05,120 --> 00:56:08,450
the print K lines but that might break

00:56:07,040 --> 00:56:11,300
it yeah we actually have that now since

00:56:08,450 --> 00:56:12,650
five-0 it's called the caller ID it's

00:56:11,300 --> 00:56:14,210
beautiful when you print that out you

00:56:12,650 --> 00:56:16,520
see exists if it's if you're in a task

00:56:14,210 --> 00:56:19,220
context you see the the thread ID if

00:56:16,520 --> 00:56:21,200
you're in some sort of scheduling or nmi

00:56:19,220 --> 00:56:22,820
or something you see the CPU ID and you

00:56:21,200 --> 00:56:25,490
can sort although they can all dump at

00:56:22,820 --> 00:56:27,290
the same time just grab that output sort

00:56:25,490 --> 00:56:28,880
it and you have your stack traces it's

00:56:27,290 --> 00:56:31,670
beautiful actually good solve problem

00:56:28,880 --> 00:56:32,870
that's now the caller ID I was really

00:56:31,670 --> 00:56:35,330
excited to see that come in that just

00:56:32,870 --> 00:56:36,680
came into five no five zero and it was a

00:56:35,330 --> 00:56:38,150
big but you have to turn it on it's not

00:56:36,680 --> 00:56:42,620
turned on by default so turn on caller

00:56:38,150 --> 00:56:48,880
ID it's really good that's that's only

00:56:42,620 --> 00:56:53,440
part of pretty I like right now using

00:56:48,880 --> 00:56:53,440
great then thank you for attention and

00:56:53,880 --> 00:56:56,979

YouTube URL: https://www.youtube.com/watch?v=pXe6KiIudDU


