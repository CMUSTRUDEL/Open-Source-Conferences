Title: LPC2018 - Recursive read deadlocks and Where to find them
Publication date: 2018-12-04
Playlist: LPC2018 - LPC Main Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/74/
speaker:  Boqun Feng


Lockdep (the deadlock detector in the Linux kernel) is a powerful tool to detect deadlocks, and has been used for a long time by kernel developers. However, when comes to read/write lock deadlock detections, lockdep only has limited support. Another thing makes this limited support worse is some major architectures (x86 and arm64) has switched or is trying to switch its rwlock implementation to queued rwlock. One example is we found some deadlock cases that happened in kernel but we could not detect it with lockdep.

To improve this situation, a patchset to support read/write deadlock detection in lockdep has been post to lkml and got to its v6. Althrough it got several positive feedbacks, some details about the reasoning of the correctness and other things still need more discussion.

This topic will give a brief introduction on rwlock related deadlocks (recursive read deadlocks) and how we can tweak lockdep to detect them. It will focus on the detection algorithm and its correctness, but also some implementation details.

This topic will provide the opportunity to discuss the reasoning and the overall design with some core lock developers, along with the opportunity to discuss the usage scenarios with potential users. The expected result is we have a cleaner plan on upstreaming this and more developers get educated on how to use this to help their work.
Captions: 
	00:00:05,590 --> 00:00:11,410
so today I'm going to talk something

00:00:08,170 --> 00:00:13,750
about the lock lock that work I have

00:00:11,410 --> 00:00:17,279
been working on which basically helped

00:00:13,750 --> 00:00:20,740
the developers to detect the deadlock

00:00:17,279 --> 00:00:24,369
which caused by the recursive with

00:00:20,740 --> 00:00:28,689
recursive read locks so let's begin

00:00:24,369 --> 00:00:32,490
this is today's agenda so and I'm pretty

00:00:28,689 --> 00:00:35,470
I will begin with some goes through some

00:00:32,490 --> 00:00:38,230
normal knowledge of lock tab and that

00:00:35,470 --> 00:00:41,200
locks and then we jump into the

00:00:38,230 --> 00:00:44,250
different flavors of read and write

00:00:41,200 --> 00:00:47,230
locks and then I will talk more about

00:00:44,250 --> 00:00:50,410
the data our case that's specified to

00:00:47,230 --> 00:00:54,190
really read locks and then I talked

00:00:50,410 --> 00:00:58,720
about how we can detect that in lock

00:00:54,190 --> 00:00:59,530
that okay so the first thing is very

00:00:58,720 --> 00:01:03,370
easy

00:00:59,530 --> 00:01:07,509
I assume oh you already know that there

00:01:03,370 --> 00:01:10,539
are two classic data of cases first line

00:01:07,509 --> 00:01:15,460
is the self deadlock which means you

00:01:10,539 --> 00:01:18,640
once the p0 grab a lock a if he if it

00:01:15,460 --> 00:01:21,520
cry tried to grab the lock again and it

00:01:18,640 --> 00:01:25,149
will self talk

00:01:21,520 --> 00:01:28,329
so excited awk and the other problem

00:01:25,149 --> 00:01:34,659
the next problem is what we called a BB

00:01:28,329 --> 00:01:39,009
a deadlock is that in if the CPU if the

00:01:34,659 --> 00:01:42,130
p0 has acquired lock a and p1 has

00:01:39,009 --> 00:01:45,759
acquired lock B and both of them can out

00:01:42,130 --> 00:01:49,329
any either of them cannot get precise

00:01:45,759 --> 00:01:51,969
because they wait for each other and it

00:01:49,329 --> 00:01:54,459
cannot get through and they can not

00:01:51,969 --> 00:01:57,100
carry the resource so this is just very

00:01:54,459 --> 00:01:59,709
basic deadlock

00:01:57,100 --> 00:02:02,279
another interesting deadlock is we

00:01:59,709 --> 00:02:06,249
called our cue saved and saved analog

00:02:02,279 --> 00:02:12,010
which basically the similar if you think

00:02:06,249 --> 00:02:15,090
in a way so it's like for example the

00:02:12,010 --> 00:02:19,970
left one I thought the last one is that

00:02:15,090 --> 00:02:24,500
if you grab a lock core block a

00:02:19,970 --> 00:02:26,930
which can be can be acquired in actual

00:02:24,500 --> 00:02:29,750
Hinderer without the tradition bill

00:02:26,930 --> 00:02:33,350
disabled you will get a deadlock it's

00:02:29,750 --> 00:02:40,550
basically like the arc you cross the R

00:02:33,350 --> 00:02:43,000
cube the RQ handler put the second SB

00:02:40,550 --> 00:02:44,210
lock into a code it's basically you can

00:02:43,000 --> 00:02:46,400
wait

00:02:44,210 --> 00:02:50,450
so in the lock tab they are the same

00:02:46,400 --> 00:02:52,940
like the other state from the point view

00:02:50,450 --> 00:03:00,100
of lock tab they are the same thing

00:02:52,940 --> 00:03:05,240
I mean and the right one is that slight

00:03:00,100 --> 00:03:07,550
conflict example so yes basically like

00:03:05,240 --> 00:03:11,350
you can you write the code you can see

00:03:07,550 --> 00:03:14,420
that this example is is similar to the

00:03:11,350 --> 00:03:19,580
previous example of a BBA deadlock

00:03:14,420 --> 00:03:25,730
so it basically that you have some you

00:03:19,580 --> 00:03:28,790
grab some lock a and there is another

00:03:25,730 --> 00:03:32,840
log P which can which can be correct in

00:03:28,790 --> 00:03:36,280
the air handler and in another process

00:03:32,840 --> 00:03:39,440
you grab that with aircrew disabled and

00:03:36,280 --> 00:03:43,670
after the PP 0 gridlock a and there is a

00:03:39,440 --> 00:03:47,750
interrupts and you know the p 0 and P

00:03:43,670 --> 00:03:50,630
ones got locked up so yes it's just like

00:03:47,750 --> 00:03:53,959
the RQ brings more like cold

00:03:50,630 --> 00:03:56,780
combinations so that it my point is that

00:03:53,959 --> 00:04:00,320
is similar to the previous example so it

00:03:56,780 --> 00:04:05,030
just happens specifically for the RQ

00:04:00,320 --> 00:04:07,720
scenario so also yeah the blocks

00:04:05,030 --> 00:04:13,180
involved in the lock tab can be extend

00:04:07,720 --> 00:04:18,049
like for thrill 3 logs or for logs

00:04:13,180 --> 00:04:21,799
example so p0 take consider case there

00:04:18,049 --> 00:04:26,050
p0 take lock a p1 take lock P and the P

00:04:21,799 --> 00:04:29,390
to take lock see and and nobody can move

00:04:26,050 --> 00:04:33,050
yeah so okay

00:04:29,390 --> 00:04:36,590
so there are these are data logs and

00:04:33,050 --> 00:04:40,580
we have a kernel runtime that love

00:04:36,590 --> 00:04:45,979
deadlock possibility detector which is

00:04:40,580 --> 00:04:48,199
called lock tab and the lock type one

00:04:45,979 --> 00:04:53,479
seemed to notice that is that the lock

00:04:48,199 --> 00:04:58,460
type treated logs as different classes

00:04:53,479 --> 00:05:02,690
now so what I'm saying is that in the

00:04:58,460 --> 00:05:06,710
lock tab in the detection of lock tab

00:05:02,690 --> 00:05:09,770
there is no thing like single lock

00:05:06,710 --> 00:05:11,960
instance because in that way there are

00:05:09,770 --> 00:05:15,259
maybe many locks many logging business

00:05:11,960 --> 00:05:19,789
in the kernel so in the lock type track

00:05:15,259 --> 00:05:22,940
every lock instance there will be there

00:05:19,789 --> 00:05:29,930
will be many a lot of memory to take so

00:05:22,940 --> 00:05:32,270
locked X only only deal with the law

00:05:29,930 --> 00:05:36,080
class and a lot class you can see if I

00:05:32,270 --> 00:05:44,990
think is like a group of logs which for

00:05:36,080 --> 00:05:47,960
example the task log and the first block

00:05:44,990 --> 00:05:50,840
and thus together together lock the rank

00:05:47,960 --> 00:05:52,820
you preparing to load and most of the

00:05:50,840 --> 00:05:57,110
best log happens when you come on

00:05:52,820 --> 00:06:01,340
combine different sub module together

00:05:57,110 --> 00:06:05,360
also a story subsystem together so only

00:06:01,340 --> 00:06:08,469
deal by the law class would be enough to

00:06:05,360 --> 00:06:11,719
detect most of the law like terror cases

00:06:08,469 --> 00:06:16,130
but they are sure there are some general

00:06:11,719 --> 00:06:19,340
cases involved with to lock instance we

00:06:16,130 --> 00:06:23,360
belong into the same time same lock

00:06:19,340 --> 00:06:26,090
classes in that way Locker has to use

00:06:23,360 --> 00:06:30,259
some other trick to to directed to

00:06:26,090 --> 00:06:33,020
detect that and there is a key count key

00:06:30,259 --> 00:06:36,070
concept in lock tab which we called a

00:06:33,020 --> 00:06:40,680
lock dependency and it's basically

00:06:36,070 --> 00:06:44,790
considered a code p0 and it

00:06:40,680 --> 00:06:46,919
if if p 0 if there is the sorry if p 0

00:06:44,790 --> 00:06:48,990
take a look at first and it take in

00:06:46,919 --> 00:06:52,620
Takaki and there will be a lakh

00:06:48,990 --> 00:06:55,590
dependency called a from b and basically

00:06:52,620 --> 00:07:01,380
the log dependency is trickin tracking

00:06:55,590 --> 00:07:05,539
that whether a program all in the system

00:07:01,380 --> 00:07:11,759
or cpu has a query log you know certain

00:07:05,539 --> 00:07:15,840
sequence so the whole dependency forms

00:07:11,759 --> 00:07:18,419
like from dependency graph and that is

00:07:15,840 --> 00:07:22,740
basically the main data structure at

00:07:18,419 --> 00:07:27,180
lock tab used to detect that block okay

00:07:22,740 --> 00:07:32,310
so the detection of deadlock is it's

00:07:27,180 --> 00:07:36,990
kind of easy it just if we learn about

00:07:32,310 --> 00:07:39,660
the dependency graph and the lot the

00:07:36,990 --> 00:07:43,940
algorithm for deadlock detection in lock

00:07:39,660 --> 00:07:49,320
tab is simply fine outer circle in the

00:07:43,940 --> 00:07:51,690
dependency graph so so why what is it

00:07:49,320 --> 00:07:55,710
well it's enough you can't think this

00:07:51,690 --> 00:07:58,470
this graph and it so we have a

00:07:55,710 --> 00:08:02,159
dependency from A to B which means there

00:07:58,470 --> 00:08:04,380
will be p0 which has acquire a and then

00:08:02,159 --> 00:08:07,370
require B and we have dependency from B

00:08:04,380 --> 00:08:10,409
to C which means there p1 acquired

00:08:07,370 --> 00:08:12,510
beavers and incur C and we have a

00:08:10,409 --> 00:08:16,139
dependency from C to a which means we

00:08:12,510 --> 00:08:22,080
have another stride toward p2 across C

00:08:16,139 --> 00:08:25,229
and a so it's basically like a b b c see

00:08:22,080 --> 00:08:29,520
a problem we covered in the previous

00:08:25,229 --> 00:08:31,860
slide okay so so much for lock tab so

00:08:29,520 --> 00:08:34,409
much for the lock tab and this has been

00:08:31,860 --> 00:08:37,969
working very well until there are some

00:08:34,409 --> 00:08:41,940
until we want to detect more deadlocks

00:08:37,969 --> 00:08:43,979
so I'm going to introduce a little bit

00:08:41,940 --> 00:08:46,020
of the different flavors of Rey

00:08:43,979 --> 00:08:48,860
dreadlocks there are two different

00:08:46,020 --> 00:08:54,079
flavors wines called recursive unfair

00:08:48,860 --> 00:08:54,079
unfair at other blocks

00:08:54,660 --> 00:09:04,480
which basically the readers are more the

00:09:00,630 --> 00:09:07,180
loves prefer to readers so think of this

00:09:04,480 --> 00:09:10,480
example if there is a first reader

00:09:07,180 --> 00:09:12,970
called our car one grab that locks and

00:09:10,480 --> 00:09:16,510
then come at a writer called a blue one

00:09:12,970 --> 00:09:18,910
and at this time the tablet one can out

00:09:16,510 --> 00:09:23,680
get the lock and then there is another

00:09:18,910 --> 00:09:27,250
reader at who comes around and because

00:09:23,680 --> 00:09:31,390
the the logs preferred readers so our

00:09:27,250 --> 00:09:34,780
two hand catalogs so so so that's why

00:09:31,390 --> 00:09:37,540
the app with green and there are another

00:09:34,780 --> 00:09:40,270
with read read lock switch called

00:09:37,540 --> 00:09:44,530
non-recursive read lock off furnace

00:09:40,270 --> 00:09:47,200
because in the previous in the recursive

00:09:44,530 --> 00:09:49,810
with read/write locks the there will be

00:09:47,200 --> 00:09:52,060
a situation that the writers cause

00:09:49,810 --> 00:09:56,080
variation because there may be

00:09:52,060 --> 00:09:58,180
continuous readers comes so that the

00:09:56,080 --> 00:10:02,530
writers may not get a chance to to

00:09:58,180 --> 00:10:06,670
catalog and so we have the sink out fare

00:10:02,530 --> 00:10:10,980
read blog i'll cute relock which has a

00:10:06,670 --> 00:10:16,780
different scenario in for the previous

00:10:10,980 --> 00:10:20,560
for the previous sequence so we can take

00:10:16,780 --> 00:10:22,870
act so if if the I want o'clock and I'll

00:10:20,560 --> 00:10:25,930
tabby one calm double ones do get

00:10:22,870 --> 00:10:29,260
blocked and then are to come and because

00:10:25,930 --> 00:10:34,000
of fairness and wr2 cannot get the lock

00:10:29,260 --> 00:10:36,850
even is even it is reader and there is a

00:10:34,000 --> 00:10:40,270
really the Houghton block so but if

00:10:36,850 --> 00:10:43,090
there is no double one and our two just

00:10:40,270 --> 00:10:45,910
come it will get the lock so this is the

00:10:43,090 --> 00:10:50,230
difference between fairness and fair and

00:10:45,910 --> 00:10:55,510
unfair read read read lock so this is

00:10:50,230 --> 00:10:58,030
the samurai so post of the is rewrite

00:10:55,510 --> 00:11:03,149
log so both of them allowed multiple

00:10:58,030 --> 00:11:06,089
readers and but you know

00:11:03,149 --> 00:11:10,219
it's called recursive really love so it

00:11:06,089 --> 00:11:12,779
allows recursive critical section and

00:11:10,219 --> 00:11:15,149
memory Christy would love doesn't allow

00:11:12,779 --> 00:11:18,659
the recursive critical section because

00:11:15,149 --> 00:11:22,429
that way it will become adult so for

00:11:18,659 --> 00:11:27,599
example like this case there is no way

00:11:22,429 --> 00:11:31,289
there r1 and r2 may be the same precise

00:11:27,599 --> 00:11:35,039
so once the so - so as there are applies

00:11:31,289 --> 00:11:38,399
the process gets the log and r1 and it

00:11:35,039 --> 00:11:41,369
won't - you know in enter a nested of

00:11:38,399 --> 00:11:43,979
recursive reader read the correct

00:11:41,369 --> 00:11:49,379
section it will get locked in look at

00:11:43,979 --> 00:11:51,839
kind of like the self deadlock so

00:11:49,379 --> 00:11:54,359
another way to thinking to think the

00:11:51,839 --> 00:11:58,619
recursive and non recursive behavior is

00:11:54,359 --> 00:12:01,169
that the recursive data retort the

00:11:58,619 --> 00:12:03,689
recursive read lock cannot get blocked

00:12:01,169 --> 00:12:05,969
and not by another reader but highroad

00:12:03,689 --> 00:12:09,899
the never occurs the dog can't get

00:12:05,969 --> 00:12:12,419
blocked by an another reader and a

00:12:09,899 --> 00:12:19,679
colored get blocked we are awaiting

00:12:12,419 --> 00:12:22,409
writer so like the previous case because

00:12:19,679 --> 00:12:24,889
if there is no double one the our r2

00:12:22,409 --> 00:12:29,479
will not get blocked

00:12:24,889 --> 00:12:36,479
okay so anyone have any question here

00:12:29,479 --> 00:12:40,139
cool it goes through so basically there

00:12:36,479 --> 00:12:47,189
is another summer summary for the block

00:12:40,139 --> 00:12:50,099
condition so it's like the recursive

00:12:47,189 --> 00:12:52,199
readers can get block but writers can we

00:12:50,099 --> 00:12:56,159
talk about writers but now Rico's

00:12:52,199 --> 00:12:58,919
readers can get blocked by both non

00:12:56,159 --> 00:13:03,749
recursive readers at American readers we

00:12:58,919 --> 00:13:07,799
are basing writers all very rehearse the

00:13:03,749 --> 00:13:10,589
Builder below is the matrix so we will

00:13:07,799 --> 00:13:13,849
use that block condition for deadlock

00:13:10,589 --> 00:13:13,849
defect detection algorithm

00:13:16,040 --> 00:13:26,759
so um so since we have those redirects

00:13:23,639 --> 00:13:29,759
logs so we have different we have more

00:13:26,759 --> 00:13:34,800
data of cases and for the non-recursive

00:13:29,759 --> 00:13:38,160
really read log is same I mean look

00:13:34,800 --> 00:13:40,259
since that we know that a reader can

00:13:38,160 --> 00:13:42,779
block another reader which basically

00:13:40,259 --> 00:13:45,089
like us below block and others bilac

00:13:42,779 --> 00:13:51,470
so this they saw this case is a deadlock

00:13:45,089 --> 00:13:59,670
is the similar to the ABP a deadlock so

00:13:51,470 --> 00:14:03,779
the p2 maybe a irrelevant task that you

00:13:59,670 --> 00:14:06,779
know because that comes after the p0

00:14:03,779 --> 00:14:09,990
grabbed lock a as a riddle at the reader

00:14:06,779 --> 00:14:16,620
lock and so that the reader lock and p2

00:14:09,990 --> 00:14:19,220
cannot get log ok so I think everybody

00:14:16,620 --> 00:14:24,269
can understand is this example right

00:14:19,220 --> 00:14:25,740
okay cool but photo recursive logs

00:14:24,269 --> 00:14:30,029
things get interesting

00:14:25,740 --> 00:14:38,480
oh this is obvious not data log right we

00:14:30,029 --> 00:14:42,779
called you know even if p p0 and p1 get

00:14:38,480 --> 00:14:44,670
PD look at a and p1 cat B and P band

00:14:42,779 --> 00:14:47,130
still can't get a because it's a non

00:14:44,670 --> 00:14:49,589
recursive read lock and even if there is

00:14:47,130 --> 00:14:54,180
another waiting writer there

00:14:49,589 --> 00:14:57,540
p1 could still get lock okay so but this

00:14:54,180 --> 00:15:00,120
is the lock right be called the right

00:14:57,540 --> 00:15:07,410
lock and p1 will blocked by the really

00:15:00,120 --> 00:15:10,920
lock on p0 so it's the two cases has the

00:15:07,410 --> 00:15:13,439
same kind of similar graph but result in

00:15:10,920 --> 00:15:17,009
different situations so that means we

00:15:13,439 --> 00:15:22,800
have to extend the lock tab to to to be

00:15:17,009 --> 00:15:27,079
able to process this and when and things

00:15:22,800 --> 00:15:30,930
maybe get more complicated when we have

00:15:27,079 --> 00:15:35,069
in because in the kernel our cute read

00:15:30,930 --> 00:15:38,399
read read lock is not pure is neither a

00:15:35,069 --> 00:15:41,759
pure a pure sorry pure non-recursive

00:15:38,399 --> 00:15:44,399
read lock all know the recursive read

00:15:41,759 --> 00:15:46,319
lock it's never consumed read lock in

00:15:44,399 --> 00:15:47,279
the process contact but is a recursive

00:15:46,319 --> 00:15:50,699
read lock in

00:15:47,279 --> 00:15:56,149
Erico context so things got interesting

00:15:50,699 --> 00:16:01,230
and there is the there the case for this

00:15:56,149 --> 00:16:07,999
for hopeful for what I mean so this case

00:16:01,230 --> 00:16:12,899
is this is bedrock and so because the

00:16:07,999 --> 00:16:15,899
pp0 is in a queue handler so that the

00:16:12,899 --> 00:16:22,999
read lock on p0 is a recursive read log

00:16:15,899 --> 00:16:27,290
and the ended and after p1 acquire B and

00:16:22,999 --> 00:16:32,779
P sort of a p0 q RB and the p1 query and

00:16:27,290 --> 00:16:36,389
if there is a another p2 waiting for B

00:16:32,779 --> 00:16:40,439
that will block the read lock on p1

00:16:36,389 --> 00:16:46,679
right because the redraw Compu is a non

00:16:40,439 --> 00:16:49,339
recursive is a fair with dog okay but if

00:16:46,679 --> 00:16:54,059
we change the case

00:16:49,339 --> 00:16:58,829
switch the read lock root redox bilac

00:16:54,059 --> 00:17:03,380
hit 0 and P 1 this is not deadlock the

00:16:58,829 --> 00:17:08,490
thing is that since the the read lock on

00:17:03,380 --> 00:17:13,289
p0 is unfair with log so we can it has

00:17:08,490 --> 00:17:18,380
the first pass to get the P to start ok

00:17:13,289 --> 00:17:18,380
to get B and you know make progress

00:17:20,920 --> 00:17:34,810
so yeah sure so so just in the recursive

00:17:31,990 --> 00:17:39,130
case right I was I was trying trying to

00:17:34,810 --> 00:17:43,660
look at the the right lock on p2 there

00:17:39,130 --> 00:17:46,300
has to be there for this deadlock so

00:17:43,660 --> 00:17:49,690
that's a good question so for I think

00:17:46,300 --> 00:17:52,660
for lock that we so so this is just a

00:17:49,690 --> 00:17:57,430
case where we can have a deadlock and

00:17:52,660 --> 00:18:02,170
for lock that it must assume that and

00:17:57,430 --> 00:18:04,480
it's anything happen so is so the from

00:18:02,170 --> 00:18:07,420
the point of view of lac type is it

00:18:04,480 --> 00:18:11,730
doesn't see the p2 but it must assume

00:18:07,420 --> 00:18:18,130
that pukin happens and at any time after

00:18:11,730 --> 00:18:23,890
someone acquired redock thank you it's

00:18:18,130 --> 00:18:28,270
good question yeah so so we find some

00:18:23,890 --> 00:18:32,940
limitation for lock tab so because that

00:18:28,270 --> 00:18:36,820
in lock tabs in the current lock tab

00:18:32,940 --> 00:18:38,680
circles means that locks but as we can

00:18:36,820 --> 00:18:41,170
see in the foreign and in the in the

00:18:38,680 --> 00:18:46,660
previous examples that not all their

00:18:41,170 --> 00:18:47,380
circles are deadlock so for example like

00:18:46,660 --> 00:18:51,940
this one

00:18:47,380 --> 00:18:53,970
is not not a deadlock and we try to make

00:18:51,940 --> 00:18:56,830
sure we can detect it recursive

00:18:53,970 --> 00:19:00,070
deadlocks there are three goals we want

00:18:56,830 --> 00:19:03,070
to do first we want to make sure that

00:19:00,070 --> 00:19:06,310
they could out lock type detection is

00:19:03,070 --> 00:19:10,020
there working and we want to handle the

00:19:06,310 --> 00:19:13,270
this Mattox of cube read rewrite log and

00:19:10,020 --> 00:19:17,010
the second third is very important we

00:19:13,270 --> 00:19:20,170
don't want any false positives so like

00:19:17,010 --> 00:19:23,350
this one is this one is not a deadlock

00:19:20,170 --> 00:19:25,960
we we can have a very easy way to detect

00:19:23,350 --> 00:19:29,110
this one this one is the deadlock but it

00:19:25,960 --> 00:19:32,260
would be introduced a false positive or

00:19:29,110 --> 00:19:35,970
for this one so we want to why would it

00:19:32,260 --> 00:19:39,760
have that deadlock but we don't want to

00:19:35,970 --> 00:19:43,090
did we don't want to do this as deadlock

00:19:39,760 --> 00:19:47,520
so there's that what I mean like it's

00:19:43,090 --> 00:19:53,100
now we don't want any false positives

00:19:47,520 --> 00:19:58,120
okay so going to give you brief of the

00:19:53,100 --> 00:20:02,290
algorithm so first I'm going to classify

00:19:58,120 --> 00:20:03,730
the dependency so since we know that now

00:20:02,290 --> 00:20:06,700
two out the circle not now the

00:20:03,730 --> 00:20:11,130
dependency circles means that log so

00:20:06,700 --> 00:20:16,360
there must be some classification sorry

00:20:11,130 --> 00:20:21,070
justification for that dependency so

00:20:16,360 --> 00:20:22,990
there depends on what depend on so there

00:20:21,070 --> 00:20:27,700
are two part of a lot lakh dependency

00:20:22,990 --> 00:20:30,430
the tail and the head so depends on the

00:20:27,700 --> 00:20:32,140
middle health is a reader reader a

00:20:30,430 --> 00:20:34,120
recursive reader all right through and

00:20:32,140 --> 00:20:36,550
it hell is a reader because the reader

00:20:34,120 --> 00:20:41,560
all right here there are like there are

00:20:36,550 --> 00:20:45,700
nine combinations and we can group them

00:20:41,560 --> 00:20:49,990
into fall and so this is grouping the

00:20:45,700 --> 00:20:53,350
first one is there are eyes then for

00:20:49,990 --> 00:20:57,580
shared shared means readers but whatever

00:20:53,350 --> 00:21:01,570
it's it's a recursive readers non

00:20:57,580 --> 00:21:03,940
recursive readers and and if sorry II

00:21:01,570 --> 00:21:06,760
stand for exclusive it's a writer of

00:21:03,940 --> 00:21:10,810
spinlock and n stand for non recursive

00:21:06,760 --> 00:21:13,090
it's it's the right earth and the non

00:21:10,810 --> 00:21:18,280
recursive readers and are I stand for

00:21:13,090 --> 00:21:24,250
recursive readers okay so why we can

00:21:18,280 --> 00:21:26,440
group things like this because because

00:21:24,250 --> 00:21:30,820
the the you know love dependency

00:21:26,440 --> 00:21:33,370
so we basically we it's there the we

00:21:30,820 --> 00:21:35,950
treat the tail and the group that he'll

00:21:33,370 --> 00:21:39,940
and the group that had in a different

00:21:35,950 --> 00:21:44,140
way why we why we do this because at you

00:21:39,940 --> 00:21:48,740
know a lot of dependency that the tail

00:21:44,140 --> 00:21:53,450
and the child has different

00:21:48,740 --> 00:21:55,309
different attributes we cared about for

00:21:53,450 --> 00:21:58,519
dependency a to be we cares about

00:21:55,309 --> 00:22:01,510
whether a can block anyone and we cares

00:21:58,519 --> 00:22:07,580
whether B can get block where anyone so

00:22:01,510 --> 00:22:11,389
remember the ball condition so if if log

00:22:07,580 --> 00:22:16,940
is recursive if the lock is our it

00:22:11,389 --> 00:22:20,360
cannot it can only block by you can only

00:22:16,940 --> 00:22:25,820
block by exclusive lock so like our only

00:22:20,360 --> 00:22:28,820
block by E and our weepok by E and if

00:22:25,820 --> 00:22:37,460
it's a non recursive lock it can be

00:22:28,820 --> 00:22:39,490
blocked by it can block any logs so

00:22:37,460 --> 00:22:49,029
that's way we differs in different tree

00:22:39,490 --> 00:22:49,029
so ok so any question for this ok

00:22:54,610 --> 00:23:06,500
readwrite walk to separate spin locks

00:22:59,000 --> 00:23:11,120
one is we are read walking a that means

00:23:06,500 --> 00:23:14,539
it's a read/write walk right threat

00:23:11,120 --> 00:23:26,960
didn't get we're talking about

00:23:14,539 --> 00:23:30,139
read/write walks so in the most cases we

00:23:26,960 --> 00:23:34,070
read walking a read walking or write

00:23:30,139 --> 00:23:38,059
walking a and we're talking about spin

00:23:34,070 --> 00:23:39,889
locking the same thing if you turn back

00:23:38,059 --> 00:23:43,460
into the slides a little bit I think

00:23:39,889 --> 00:23:47,450
that was such an example if we're speed

00:23:43,460 --> 00:23:50,060
lock spin locking read/write walk what

00:23:47,450 --> 00:23:53,170
exactly we're walking

00:23:50,060 --> 00:23:56,810
means been logging I mean if we if we

00:23:53,170 --> 00:24:26,360
implement a trade log dice me that's a

00:23:56,810 --> 00:24:29,870
point schematics okay so one way to look

00:24:26,360 --> 00:24:32,750
at it if you if you write lock Bibi is

00:24:29,870 --> 00:24:35,390
one lakh you can either be read lock and

00:24:32,750 --> 00:24:37,010
write locked so if there's if you write

00:24:35,390 --> 00:24:39,050
lock it that's the only thing you can

00:24:37,010 --> 00:24:41,690
hold it they could have multiple people

00:24:39,050 --> 00:24:46,970
read locking it so so you mean that

00:24:41,690 --> 00:24:49,430
these just be is a lock

00:24:46,970 --> 00:24:50,960
it's a reader/writer lock and the

00:24:49,430 --> 00:24:53,330
semantics are you can have one writer

00:24:50,960 --> 00:24:56,240
holding it so that's right lock is right

00:24:53,330 --> 00:24:58,610
hold it okay and you have a large number

00:24:56,240 --> 00:24:59,780
of readers read holding it but if

00:24:58,610 --> 00:25:02,530
there's a reader either holding it you

00:24:59,780 --> 00:25:02,530
can't have a writer

00:25:03,980 --> 00:25:07,069
[Music]

00:25:18,720 --> 00:25:30,790
okay so okay so we have different type

00:25:27,040 --> 00:25:37,450
of dependency and we a lakh dependency

00:25:30,790 --> 00:25:41,050
and we want to so in in the current

00:25:37,450 --> 00:25:42,700
employees in the current lock tab it

00:25:41,050 --> 00:25:45,550
failed to detect that was deadlock

00:25:42,700 --> 00:25:49,450
because it treat all the dependency past

00:25:45,550 --> 00:25:52,780
as a strong condition for the deadlock

00:25:49,450 --> 00:25:55,920
but actually there are something that

00:25:52,780 --> 00:25:59,740
there are some dependencies which is now

00:25:55,920 --> 00:26:03,580
which will not introduce dead logs so we

00:25:59,740 --> 00:26:05,710
call the the dependency that will

00:26:03,580 --> 00:26:09,400
introduce deadlock strong strong

00:26:05,710 --> 00:26:12,730
dependency and if I think strong

00:26:09,400 --> 00:26:15,880
dependency pass is like chaining block

00:26:12,730 --> 00:26:19,350
dependency we are the training lock

00:26:15,880 --> 00:26:24,220
dependency we are the block conditions

00:26:19,350 --> 00:26:27,220
so it's like basically a block chain so

00:26:24,220 --> 00:26:32,380
for example that for the dependency like

00:26:27,220 --> 00:26:35,740
from A to B and B to C ABC just want

00:26:32,380 --> 00:26:40,450
dependency only if those three keynesian

00:26:35,740 --> 00:26:44,950
happens so I can explain one by one so

00:26:40,450 --> 00:26:48,940
if B is in the dependency a to b and b

00:26:44,950 --> 00:26:53,980
is recursive with log and in a

00:26:48,940 --> 00:26:59,920
dependency B to C test psi exclusive

00:26:53,980 --> 00:27:03,760
lock in that way if someone holding the

00:26:59,920 --> 00:27:09,040
holding B for the second dependency it

00:27:03,760 --> 00:27:11,400
will block the first that the first be

00:27:09,040 --> 00:27:14,890
in that have been the first dependency

00:27:11,400 --> 00:27:21,780
so this is says to this wow this is

00:27:14,890 --> 00:27:21,780
where we are block condition works so

00:27:21,930 --> 00:27:29,590
the the rest exam are similar so if if

00:27:26,890 --> 00:27:30,799
the first if they're being the first

00:27:29,590 --> 00:27:33,210
take

00:27:30,799 --> 00:27:41,940
dependency is a non-recursive lock it

00:27:33,210 --> 00:27:46,320
will catch block by any it will plug by

00:27:41,940 --> 00:27:49,549
any so let me explain that about the

00:27:46,320 --> 00:27:53,460
notation so the star so there is two

00:27:49,549 --> 00:27:56,519
character for the dependency the first

00:27:53,460 --> 00:27:58,619
one is for the hat the second of Mines

00:27:56,519 --> 00:28:01,859
for the tail and the star means we don't

00:27:58,619 --> 00:28:10,139
care about that predation it can be a it

00:28:01,859 --> 00:28:13,409
can be any type so only only the star

00:28:10,139 --> 00:28:17,849
are and I star will broke will break the

00:28:13,409 --> 00:28:20,849
dependency because that means the in the

00:28:17,849 --> 00:28:25,019
first third dependency is that the tell

00:28:20,849 --> 00:28:28,529
is recursively lock and in the second

00:28:25,019 --> 00:28:32,940
dependency to have it Sherlock which

00:28:28,529 --> 00:28:36,239
means read lock and that's in that way

00:28:32,940 --> 00:28:39,029
to the tale of the first dependency can

00:28:36,239 --> 00:28:41,489
always get lock so there is no way the

00:28:39,029 --> 00:28:45,629
second dependency will block the first

00:28:41,489 --> 00:28:50,009
dependency so this is the way I define

00:28:45,629 --> 00:28:52,349
the strong dependency and it also works

00:28:50,009 --> 00:28:58,830
for for lock pieces and so on

00:28:52,349 --> 00:29:00,599
so okay how can you explain what year

00:28:58,830 --> 00:29:08,429
the in demonic ow

00:29:00,599 --> 00:29:18,769
and temple okay so our is fall recursive

00:29:08,429 --> 00:29:26,249
yeah and it's fun and kazoo okay so so

00:29:18,769 --> 00:29:29,909
let's see the the first first two group

00:29:26,249 --> 00:29:33,539
and the tail of the dependency and is

00:29:29,909 --> 00:29:36,659
then for non recursive is like it and so

00:29:33,539 --> 00:29:40,739
that instant for non recursive readers

00:29:36,659 --> 00:29:42,430
and the writers and our stand for

00:29:40,739 --> 00:29:45,710
recursive writers

00:29:42,430 --> 00:29:47,990
okay it's with groups through three

00:29:45,710 --> 00:29:53,360
locks into we groups through a kind of

00:29:47,990 --> 00:29:58,750
lock into two group and you can see the

00:29:53,360 --> 00:30:03,700
second Lannister benasi and as then for

00:29:58,750 --> 00:30:07,390
Sherlock means reader movies any readers

00:30:03,700 --> 00:30:12,320
recursive or not and II stand for

00:30:07,390 --> 00:30:18,550
exclusive means writers oh think all us

00:30:12,320 --> 00:30:18,550
belong okay

00:30:18,730 --> 00:30:27,830
so yeah with this strong dependency we

00:30:23,180 --> 00:30:32,000
can have the condition for paradox that

00:30:27,830 --> 00:30:34,310
the if just if the strong dependency for

00:30:32,000 --> 00:30:40,300
my circle that means we have that lock

00:30:34,310 --> 00:30:43,220
so there is a example on the right which

00:30:40,300 --> 00:30:50,870
cross-burning to the following cost nap

00:30:43,220 --> 00:30:53,870
that okay that's that's a tells that if

00:30:50,870 --> 00:30:58,640
we have the dependence graph like on the

00:30:53,870 --> 00:31:02,750
right hand and we have data log so so we

00:30:58,640 --> 00:31:06,740
can see if the p1 grab a key to grab b p

00:31:02,750 --> 00:31:19,310
sr p1 p0 grab a p1 grab P and the P to

00:31:06,740 --> 00:31:21,380
grab C we lock so for this so so like we

00:31:19,310 --> 00:31:25,490
are like I said with the one strand

00:31:21,380 --> 00:31:27,860
dependency as the way that no really the

00:31:25,490 --> 00:31:32,950
dependency and that could block things

00:31:27,860 --> 00:31:35,740
so that means that give us the similar

00:31:32,950 --> 00:31:42,080
kind deadlock condition for the

00:31:35,740 --> 00:31:45,560
recursive deadlocks so I also have some

00:31:42,080 --> 00:31:49,460
very formal proof we want to prove is

00:31:45,560 --> 00:31:52,370
that a strong dependency circle is a

00:31:49,460 --> 00:31:53,040
crew equivalent to the deadlock

00:31:52,370 --> 00:31:56,700
possibility

00:31:53,040 --> 00:32:00,200
not that that locked up detector only

00:31:56,700 --> 00:32:06,060
detect deadlock possibilities it can out

00:32:00,200 --> 00:32:09,570
its so is it cannot make sure that the

00:32:06,060 --> 00:32:13,710
teller will happen but it can say so so

00:32:09,570 --> 00:32:15,780
it has some assumption that if there is

00:32:13,710 --> 00:32:18,620
a lock dependency then the cold can

00:32:15,780 --> 00:32:24,300
combination in many many ways

00:32:18,620 --> 00:32:27,080
so we want to prove that a strong

00:32:24,300 --> 00:32:31,470
dependency circle is equivalent to

00:32:27,080 --> 00:32:36,750
deadlock possibility so we protein into

00:32:31,470 --> 00:32:41,370
two to two condition first one to for

00:32:36,750 --> 00:32:45,870
the necessary condition is that we if we

00:32:41,370 --> 00:32:50,310
have a strong circle then we may have a

00:32:45,870 --> 00:32:53,940
deadlock and this is easy because like

00:32:50,310 --> 00:32:59,940
like we we did previously if we have a

00:32:53,940 --> 00:33:03,270
circle of the graph and we can so

00:32:59,940 --> 00:33:05,790
basically if we have the circle here we

00:33:03,270 --> 00:33:08,400
can generate the code we can convert it

00:33:05,790 --> 00:33:10,530
to a a cold snap like this and this and

00:33:08,400 --> 00:33:17,670
you can check that that is that that is

00:33:10,530 --> 00:33:22,520
deadlock and this might be and for the

00:33:17,670 --> 00:33:26,490
next one is we want to approve that is

00:33:22,520 --> 00:33:32,130
sufficient so we have to prove true in a

00:33:26,490 --> 00:33:35,790
another direction that means if that if

00:33:32,130 --> 00:33:41,490
we if we have the deadlock possibility

00:33:35,790 --> 00:33:44,820
in our system that we must fund there

00:33:41,490 --> 00:33:50,120
there must exist strong dependent circle

00:33:44,820 --> 00:33:53,850
and this so that means this is actually

00:33:50,120 --> 00:33:58,560
how we prevent the false positives

00:33:53,850 --> 00:34:01,650
because how this sufficient conditions

00:33:58,560 --> 00:34:04,740
so so that if we there will be no case

00:34:01,650 --> 00:34:06,899
that there is the system doesn't have a

00:34:04,740 --> 00:34:09,889
deadlock possibility but we

00:34:06,899 --> 00:34:12,990
find us strong dependent circles and

00:34:09,889 --> 00:34:17,460
this I use a trick true put for that

00:34:12,990 --> 00:34:21,649
because I translated the I convert the

00:34:17,460 --> 00:34:26,940
data possibility into the secure weight

00:34:21,649 --> 00:34:29,010
condition and then I can formed strong

00:34:26,940 --> 00:34:34,919
dependency circle with secure weight

00:34:29,010 --> 00:34:37,440
condition but this is I will have have

00:34:34,919 --> 00:34:39,510
some proof in my documentation so you

00:34:37,440 --> 00:34:42,869
can look that for details but I think

00:34:39,510 --> 00:34:46,859
that maybe one day I will try some

00:34:42,869 --> 00:34:50,480
formal proof to to prove that I didn't

00:34:46,859 --> 00:34:54,179
miss anything in the in the reasoning

00:34:50,480 --> 00:34:59,460
okay the last thing is the

00:34:54,179 --> 00:35:01,470
implementation so there is a BFS in Lock

00:34:59,460 --> 00:35:07,200
tack is not man it's a coral half of the

00:35:01,470 --> 00:35:10,309
lock tab and it used to only walk on it

00:35:07,200 --> 00:35:13,980
it used to may walk any dependency and

00:35:10,309 --> 00:35:14,779
make that a change I had to walk strong

00:35:13,980 --> 00:35:18,900
dependency past

00:35:14,779 --> 00:35:22,470
there are many implementation detail

00:35:18,900 --> 00:35:26,700
there and also there is a there is a

00:35:22,470 --> 00:35:33,829
still called chain keys which basically

00:35:26,700 --> 00:35:37,080
like it's a hash each and that recalled

00:35:33,829 --> 00:35:42,630
recalled the

00:35:37,080 --> 00:35:49,290
the log the logs that precise has taken

00:35:42,630 --> 00:35:52,830
for four for now so it's a optimization

00:35:49,290 --> 00:35:55,200
for lock tab because if you see if you

00:35:52,830 --> 00:35:57,590
see a log sequence is safe in previously

00:35:55,200 --> 00:36:02,880
you need to check that in the in the

00:35:57,590 --> 00:36:07,340
dependency graph but that didn't cake

00:36:02,880 --> 00:36:11,880
taking account of the reader read

00:36:07,340 --> 00:36:16,370
recursively love so we need to fix that

00:36:11,880 --> 00:36:19,860
and also I'll add a few tests police and

00:36:16,370 --> 00:36:23,220
also there is a worry old test our

00:36:19,860 --> 00:36:26,190
career occurs recursion who is I think

00:36:23,220 --> 00:36:29,060
it's come along with the very first

00:36:26,190 --> 00:36:34,230
commit a flock depth and it has been

00:36:29,060 --> 00:36:39,930
comment out so I uncommon that so that

00:36:34,230 --> 00:36:43,260
and I got the expected result and also I

00:36:39,930 --> 00:36:46,170
am Elise for others to you so we now can

00:36:43,260 --> 00:36:50,690
use this to detected data log for SSD

00:36:46,170 --> 00:36:54,450
you and you can send a call here in my

00:36:50,690 --> 00:36:59,070
key to wrap whole and the net branch so

00:36:54,450 --> 00:37:02,010
how then takes version for upstream and

00:36:59,070 --> 00:37:04,350
the baton then I realized I use the

00:37:02,010 --> 00:37:06,240
wrong algorithm so the change of the

00:37:04,350 --> 00:37:09,090
record rhythm is very quick that I need

00:37:06,240 --> 00:37:11,640
to change all my documentation and the

00:37:09,090 --> 00:37:15,060
comb and the comments for that so that

00:37:11,640 --> 00:37:17,730
may take a well so I will try to stand

00:37:15,060 --> 00:37:22,710
another version by the end of this year

00:37:17,730 --> 00:37:25,260
and also if any of you want to use that

00:37:22,710 --> 00:37:29,370
other one to try that you can fetch that

00:37:25,260 --> 00:37:32,400
branch and has that if you find any lock

00:37:29,370 --> 00:37:34,470
tech warnings you can email me it either

00:37:32,400 --> 00:37:37,580
is learned my path or the back in my

00:37:34,470 --> 00:37:40,560
code or it's fun that real were

00:37:37,580 --> 00:37:41,600
recursively read lock because they get

00:37:40,560 --> 00:37:45,830
up

00:37:41,600 --> 00:37:48,560
okay so that's all for my topic so I

00:37:45,830 --> 00:37:50,600
think we still have a minute right here

00:37:48,560 --> 00:38:00,470
we got about six minutes who you take

00:37:50,600 --> 00:38:02,210
questions okay so any questions if not

00:38:00,470 --> 00:38:03,980
let's thank our speaker be good to be

00:38:02,210 --> 00:38:04,430
able to get the locked up to deal with

00:38:03,980 --> 00:38:07,660
these

00:38:04,430 --> 00:38:07,660

YouTube URL: https://www.youtube.com/watch?v=KsASrJKUp-w


