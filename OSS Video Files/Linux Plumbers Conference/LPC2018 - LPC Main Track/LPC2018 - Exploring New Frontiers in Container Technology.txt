Title: LPC2018 - Exploring New Frontiers in Container Technology
Publication date: 2018-12-04
Playlist: LPC2018 - LPC Main Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/56/
speaker:  James Bottomley (IBM)


Containers (or Operating System based Virtualization) are an old
technology; however, the current excitement (and consequent
investment) around containers provides interesting avenues for
research on updating the way we build and manage container technology.
The most active area of research today, thanks to concerns raised by
groups supporting other types of virtualization, is in improving the
security properties of containers.

The first step in improving security is actually being able to measure
it in the first place, so the initial goal of a research programme for
container security involves finding that measure. In this talk I'll
outline one such measure (attack profiles) developed by IBM research,
the useful results that can be derived from it, the problems it has
and the avenues that can be explored to refine future measurements of
containment.

Contrary to popular belief, a "container" doesn't describe one fixed
thing, but instead is a collective noun for a group of isolation and
resource control primitives (in Linux terminology called namespaces
and cgroups) the composition of which can be independently varied. In
the second half of this talk, we'll explore how containment can be
improved by replacing some of the isolation primitives with local
system call emulation sandboxes, a promising technique used by both
the Google gVisor and the IBM Nabla secure container systems. We'll
also explore the question of whether sandboxes are the end point of
container security research or merely point the way to the next
Frontier for container abstraction.
Captions: 
	00:00:06,640 --> 00:00:10,150
thanks for coming everybody it's nine

00:00:08,470 --> 00:00:12,700
o'clock I imagine people still be

00:00:10,150 --> 00:00:13,690
drifting in from breakfast but since

00:00:12,700 --> 00:00:14,980
you've got a reasonable amount of

00:00:13,690 --> 00:00:18,730
material to get through it might as well

00:00:14,980 --> 00:00:21,039
start my name is James Bottomly I am

00:00:18,730 --> 00:00:24,039
currently a sort of container evangelist

00:00:21,039 --> 00:00:25,480
for IBM originally when I worked for

00:00:24,039 --> 00:00:27,160
parallels which is how I got into

00:00:25,480 --> 00:00:28,900
containers I was more an open source

00:00:27,160 --> 00:00:29,919
advocate about converting business to

00:00:28,900 --> 00:00:32,320
open source so it was more a

00:00:29,919 --> 00:00:34,480
businessperson than a technology person

00:00:32,320 --> 00:00:36,190
and for a long time I've actually been a

00:00:34,480 --> 00:00:38,410
kernel developer I'm still scuzzy

00:00:36,190 --> 00:00:40,330
subsystem maintainer pa-risc

00:00:38,410 --> 00:00:42,550
architecture maintainer those two are

00:00:40,330 --> 00:00:44,230
pretty much nominal titles so helga

00:00:42,550 --> 00:00:46,120
della does all the work in pa-risc I

00:00:44,230 --> 00:00:48,070
didn't even do anything and Martin does

00:00:46,120 --> 00:00:49,630
all the work in subsystem but because I

00:00:48,070 --> 00:00:51,550
said the pull request the leanness I

00:00:49,630 --> 00:00:53,200
take all the credit and obviously I've

00:00:51,550 --> 00:00:54,910
done a lot of work in Linux containers

00:00:53,200 --> 00:00:56,830
and one that's missing from the bottom

00:00:54,910 --> 00:00:59,050
as I'm now into security technologies

00:00:56,830 --> 00:01:00,280
like TPM as well so if you've actually

00:00:59,050 --> 00:01:02,140
been following what I've been doing

00:01:00,280 --> 00:01:04,540
recently it's almost all been about TPM

00:01:02,140 --> 00:01:06,939
and I have a slight confession to make

00:01:04,540 --> 00:01:08,500
because this is this talk says it's

00:01:06,939 --> 00:01:09,940
about exploring the frontiers in

00:01:08,500 --> 00:01:12,160
containers this is sort of partially

00:01:09,940 --> 00:01:14,200
true but if you came to see a detailed

00:01:12,160 --> 00:01:16,000
description of IBM's new nabla container

00:01:14,200 --> 00:01:17,740
technology I'm actually not going to be

00:01:16,000 --> 00:01:19,840
giving you that I'm going to be giving

00:01:17,740 --> 00:01:21,760
you the story of how we actually got to

00:01:19,840 --> 00:01:24,550
the point where we knew a technology

00:01:21,760 --> 00:01:26,530
like nabla was necessary because this

00:01:24,550 --> 00:01:29,080
talk is going to be primarily about

00:01:26,530 --> 00:01:32,260
assessing security in virtual

00:01:29,080 --> 00:01:34,060
environments but before that let's just

00:01:32,260 --> 00:01:35,800
start with the container basics I seem I

00:01:34,060 --> 00:01:39,130
can fly through this since most of you

00:01:35,800 --> 00:01:40,780
are familiar but the difference between

00:01:39,130 --> 00:01:42,790
a container and a hypervisor is where

00:01:40,780 --> 00:01:45,340
the fundamental interface is the

00:01:42,790 --> 00:01:46,750
hypervisor fundamental interface is at

00:01:45,340 --> 00:01:48,549
the virtual hardware level so

00:01:46,750 --> 00:01:50,530
hypervisors are all about emulating

00:01:48,549 --> 00:01:52,720
hardware and that means that you can

00:01:50,530 --> 00:01:54,729
bring anything up that can actually talk

00:01:52,720 --> 00:01:56,680
to the hardware so you know a Windows

00:01:54,729 --> 00:01:58,270
kernel in a virtual environment a Linux

00:01:56,680 --> 00:01:59,070
kernel in a virtual environment and so

00:01:58,270 --> 00:02:01,659
on

00:01:59,070 --> 00:02:03,880
containers are all about virtualizing

00:02:01,659 --> 00:02:05,979
the operating system subsystem itself so

00:02:03,880 --> 00:02:07,900
for containers the interface is the

00:02:05,979 --> 00:02:09,429
Cisco interface of whatever operating

00:02:07,900 --> 00:02:11,680
system the container is running on

00:02:09,429 --> 00:02:13,719
everything below that interface belongs

00:02:11,680 --> 00:02:15,300
to the service provider belongs to the

00:02:13,719 --> 00:02:18,510
guy who's hosting the can

00:02:15,300 --> 00:02:20,280
Dayna and the reason why if you if you

00:02:18,510 --> 00:02:22,590
look at the containers revolution today

00:02:20,280 --> 00:02:24,930
it's basically everything is Linux there

00:02:22,590 --> 00:02:27,780
is no really no other type of container

00:02:24,930 --> 00:02:30,270
if you get container history it's a long

00:02:27,780 --> 00:02:31,770
involved critically complicated thing

00:02:30,270 --> 00:02:33,990
and nobody's actually managed to sort

00:02:31,770 --> 00:02:35,910
out in which everybody claims to have a

00:02:33,990 --> 00:02:37,980
piece so I'm not gonna go into that all

00:02:35,910 --> 00:02:39,960
I'm gonna tell you is the reason all

00:02:37,980 --> 00:02:41,580
containers are Linux today is because of

00:02:39,960 --> 00:02:44,130
the hardness guarantees of the Linux

00:02:41,580 --> 00:02:46,500
disk all interface that interface hadn't

00:02:44,130 --> 00:02:48,360
been fantastically hard and fairly

00:02:46,500 --> 00:02:50,430
immutable from Linux kernel to Linux

00:02:48,360 --> 00:02:52,620
kernel containers today would not work

00:02:50,430 --> 00:02:54,630
the reason you don't have a decent

00:02:52,620 --> 00:02:56,730
container operating system on lint on

00:02:54,630 --> 00:02:59,010
Windows is because their interface is

00:02:56,730 --> 00:03:00,720
just not hard enough going from Windows

00:02:59,010 --> 00:03:02,430
released in Windows released the ABI

00:03:00,720 --> 00:03:03,900
change there were bits that use a space

00:03:02,430 --> 00:03:05,910
that required bits in the kernel and

00:03:03,900 --> 00:03:08,220
vice versa and that makes it very

00:03:05,910 --> 00:03:10,200
difficult to bring up containers on

00:03:08,220 --> 00:03:12,000
Windows we can bring up containers on

00:03:10,200 --> 00:03:14,820
Linux because the syscall interface is

00:03:12,000 --> 00:03:17,370
just so hard and basically because we

00:03:14,820 --> 00:03:19,070
didn't control it and obviously this

00:03:17,370 --> 00:03:21,870
means the main difference between

00:03:19,070 --> 00:03:23,820
hypervisors and containers is containers

00:03:21,870 --> 00:03:25,380
are a single kernel hypervisors and

00:03:23,820 --> 00:03:27,630
multiple kernels because for every

00:03:25,380 --> 00:03:30,959
hypervisor system you have a host kernel

00:03:27,630 --> 00:03:33,000
and a guest kernel and obviously the

00:03:30,959 --> 00:03:34,770
immediate benefit to containers which is

00:03:33,000 --> 00:03:36,690
why the technology is so beloved of the

00:03:34,770 --> 00:03:38,880
cloud where everything wants to run lean

00:03:36,690 --> 00:03:41,340
is if you have one kernel you have one

00:03:38,880 --> 00:03:43,650
resource manager so this gives us huge

00:03:41,340 --> 00:03:46,770
advantages containers like elasticity

00:03:43,650 --> 00:03:48,840
and so on so this is what a hypervisor

00:03:46,770 --> 00:03:50,580
looks like here's your hypervisor kernel

00:03:48,840 --> 00:03:53,160
running in the host all this sort of big

00:03:50,580 --> 00:03:54,900
box is the host you emulate one virtual

00:03:53,160 --> 00:03:56,730
hardware set of virtual hardware for

00:03:54,900 --> 00:03:58,590
guest and the guest brings up its own

00:03:56,730 --> 00:04:01,500
kernel and runs an incredibly large

00:03:58,590 --> 00:04:02,970
stack on top this is what containers

00:04:01,500 --> 00:04:04,500
look like so it's similar to the

00:04:02,970 --> 00:04:06,239
hypervisor diagram it's just slightly

00:04:04,500 --> 00:04:08,340
thinner and in fact these are what I

00:04:06,239 --> 00:04:09,720
call system containers so you bring it

00:04:08,340 --> 00:04:11,640
up on the one piece of hardware you have

00:04:09,720 --> 00:04:13,530
a single operating system kernel and

00:04:11,640 --> 00:04:15,420
then for system containers you start at

00:04:13,530 --> 00:04:17,669
the init system and then we have what

00:04:15,420 --> 00:04:20,330
docker allegedly claims to do but

00:04:17,669 --> 00:04:22,530
doesn't quite which is you basically

00:04:20,330 --> 00:04:24,090
inherit the init system the operating

00:04:22,530 --> 00:04:26,580
system and the libraries from the

00:04:24,090 --> 00:04:28,860
outside and all you bring up is a tiny

00:04:26,580 --> 00:04:30,930
boxed application that should be

00:04:28,860 --> 00:04:32,520
theoretical container description and if

00:04:30,930 --> 00:04:35,099
you look at these obviously this is a

00:04:32,520 --> 00:04:36,870
huge fat stack this is a furnace stack

00:04:35,099 --> 00:04:38,699
and this is a really thin stack to the

00:04:36,870 --> 00:04:40,979
tune of this one is usually gigabytes

00:04:38,699 --> 00:04:45,419
and this one if you get it right is

00:04:40,979 --> 00:04:47,969
usually megabytes and but the key point

00:04:45,419 --> 00:04:50,610
about this is the resource sharing that

00:04:47,969 --> 00:04:52,379
having a single kernel actually enables

00:04:50,610 --> 00:04:54,210
is what gives you the agility of

00:04:52,379 --> 00:04:56,729
containers it's what makes containers so

00:04:54,210 --> 00:04:58,409
tiny and solely not in terms of the

00:04:56,729 --> 00:05:00,030
actual image that you bring up because

00:04:58,409 --> 00:05:01,919
if you most people have seen docker

00:05:00,030 --> 00:05:03,539
images they're not actually megabytes

00:05:01,919 --> 00:05:06,120
big they're often sort of hundreds

00:05:03,539 --> 00:05:07,830
megabytes some a gigabytes big but it

00:05:06,120 --> 00:05:09,930
gives you resource sharing inside the

00:05:07,830 --> 00:05:13,080
kernel the great efficiency of memory

00:05:09,930 --> 00:05:14,849
management and obviously it also gives

00:05:13,080 --> 00:05:16,710
you instant up or down scaling because

00:05:14,849 --> 00:05:19,259
you just ask the one kernel to do this

00:05:16,710 --> 00:05:20,789
for whatever container you want to do it

00:05:19,259 --> 00:05:23,340
to you don't have to inflate balloons

00:05:20,789 --> 00:05:24,930
you don't have to do anything else and

00:05:23,340 --> 00:05:27,270
this means the single kernel for

00:05:24,930 --> 00:05:28,770
containers makes resource decisions much

00:05:27,270 --> 00:05:31,169
more efficiently than hypervisors

00:05:28,770 --> 00:05:32,490
because an hypervisors resource

00:05:31,169 --> 00:05:34,110
decisions have to be made across a

00:05:32,490 --> 00:05:36,509
hardware interface but they're actually

00:05:34,110 --> 00:05:38,310
operating system decisions so we invent

00:05:36,509 --> 00:05:40,650
all sorts of weird and wonderful virtual

00:05:38,310 --> 00:05:42,479
pervert Hardware interfaces to try and

00:05:40,650 --> 00:05:44,520
communicate this information but what

00:05:42,479 --> 00:05:46,020
usually ends up is the guest kernel ends

00:05:44,520 --> 00:05:48,210
up fighting with the host kernel for

00:05:46,020 --> 00:05:52,560
resources which is why hypervisors end

00:05:48,210 --> 00:05:53,909
up being rather efficient so presume

00:05:52,560 --> 00:05:55,680
most people in this room have heard of

00:05:53,909 --> 00:05:59,550
docker I believe it's quite popular in

00:05:55,680 --> 00:06:01,199
container world now docker isn't really

00:05:59,550 --> 00:06:03,449
it's sort of the thing that made docker

00:06:01,199 --> 00:06:05,759
famous wasn't really being containers it

00:06:03,449 --> 00:06:08,189
was actually finding a way of boxing up

00:06:05,759 --> 00:06:10,409
applications such that the application

00:06:08,189 --> 00:06:12,569
you box up and test on your laptop it's

00:06:10,409 --> 00:06:15,930
exactly the same application environment

00:06:12,569 --> 00:06:18,120
you box up and deploy on the Internet

00:06:15,930 --> 00:06:20,310
this is what actually made docker really

00:06:18,120 --> 00:06:22,319
useful it's the transport of the

00:06:20,310 --> 00:06:24,330
environment from one place to another

00:06:22,319 --> 00:06:25,680
that allows this DevOps thing that all

00:06:24,330 --> 00:06:28,680
of the frothy container people are

00:06:25,680 --> 00:06:30,120
talking about to actually exist this by

00:06:28,680 --> 00:06:31,529
the way will be the first and last time

00:06:30,120 --> 00:06:32,909
I mentioned DevOps because I'm

00:06:31,529 --> 00:06:35,039
interested in the fundamental technology

00:06:32,909 --> 00:06:36,719
but for you to understand why the

00:06:35,039 --> 00:06:38,370
technology is useful you have to

00:06:36,719 --> 00:06:40,380
understand that we have a connection to

00:06:38,370 --> 00:06:41,540
the frothy orchestration people who will

00:06:40,380 --> 00:06:44,510
talk all the time

00:06:41,540 --> 00:06:46,460
DevOps but the point is that docker is

00:06:44,510 --> 00:06:48,470
really nothing more than an application

00:06:46,460 --> 00:06:50,270
packaging and transport system that was

00:06:48,470 --> 00:06:52,280
actually enabled by certain features in

00:06:50,270 --> 00:06:53,810
container technology the fact that it's

00:06:52,280 --> 00:06:56,360
based on containers is just an added

00:06:53,810 --> 00:06:58,820
bonus Oh

00:06:56,360 --> 00:07:00,470
DevOps again but it's basically all

00:06:58,820 --> 00:07:02,690
about easy deployment of boxed

00:07:00,470 --> 00:07:05,180
applications easy image creation easy

00:07:02,690 --> 00:07:06,680
testing and seamless transport to a

00:07:05,180 --> 00:07:08,720
cloud environment where you're really

00:07:06,680 --> 00:07:11,090
unsure what everything else is running

00:07:08,720 --> 00:07:13,430
in one of the dirty secrets of

00:07:11,090 --> 00:07:14,840
hypervisors is you think that a boxed

00:07:13,430 --> 00:07:17,420
virtual machine could do exactly the

00:07:14,840 --> 00:07:19,280
same thing but it can't because if you

00:07:17,420 --> 00:07:21,920
take your virtual machine that I created

00:07:19,280 --> 00:07:23,840
KVM on my laptop and trying to deploy it

00:07:21,920 --> 00:07:25,430
say in the Amazon Cloud what you're

00:07:23,840 --> 00:07:27,340
actually going to find is as a driver

00:07:25,430 --> 00:07:30,230
mismatch I don't have exactly the right

00:07:27,340 --> 00:07:33,260
drivers to actually run in the Amazon

00:07:30,230 --> 00:07:35,360
Cloud so in theory virtual machines

00:07:33,260 --> 00:07:37,460
could do exactly the same box deployment

00:07:35,360 --> 00:07:39,380
but in practice shifting the interface

00:07:37,460 --> 00:07:41,570
up to where it belongs in the kernel is

00:07:39,380 --> 00:07:44,120
what enabled us to just work seamlessly

00:07:41,570 --> 00:07:45,560
without having to work out did I need to

00:07:44,120 --> 00:07:47,420
build my image with all these pair of

00:07:45,560 --> 00:07:50,030
our drivers and everything else that's

00:07:47,420 --> 00:07:52,160
why docker works in theory docker could

00:07:50,030 --> 00:07:54,080
all work with hypervisor today Katter

00:07:52,160 --> 00:07:56,420
containers is actually a demonstration

00:07:54,080 --> 00:07:57,740
of that but in practice it's much more

00:07:56,420 --> 00:08:01,790
difficult to get it to work in a

00:07:57,740 --> 00:08:04,100
hypervisor technology now here's the key

00:08:01,790 --> 00:08:05,750
crux of the talk the great benefit of

00:08:04,100 --> 00:08:08,180
containers to everybody is this

00:08:05,750 --> 00:08:10,340
increased sharing but the great threat

00:08:08,180 --> 00:08:12,890
that containers bring is increased

00:08:10,340 --> 00:08:14,750
sharing increases the security risk of

00:08:12,890 --> 00:08:16,400
the containment environment the more I

00:08:14,750 --> 00:08:18,140
share the more I'm vulnerable to

00:08:16,400 --> 00:08:21,590
everybody else is sharing the same thing

00:08:18,140 --> 00:08:23,930
and obviously this is a fact that

00:08:21,590 --> 00:08:25,880
hypervisor owners seek to exploit

00:08:23,930 --> 00:08:28,130
because if you see all of the debates

00:08:25,880 --> 00:08:30,050
about hypervisor security versus

00:08:28,130 --> 00:08:30,650
container security it goes something

00:08:30,050 --> 00:08:32,900
like this

00:08:30,650 --> 00:08:35,090
hypervisor security is great because we

00:08:32,900 --> 00:08:36,590
have a tiny hyper call interface we

00:08:35,090 --> 00:08:39,169
don't get much footprint into the kernel

00:08:36,590 --> 00:08:41,000
we have a really really small footprint

00:08:39,169 --> 00:08:42,560
it's very difficult to take something

00:08:41,000 --> 00:08:44,750
running in the guest and get it to

00:08:42,560 --> 00:08:46,550
exploit the host kernel just because of

00:08:44,750 --> 00:08:48,710
the hypervisor interface so hypervisors

00:08:46,550 --> 00:08:50,450
are great and then hypervisor advocates

00:08:48,710 --> 00:08:52,700
will tell you that you know containers

00:08:50,450 --> 00:08:54,050
are right because the syscall

00:08:52,700 --> 00:08:55,700
interface is the most

00:08:54,050 --> 00:08:57,890
beautiful interface in Linux there are

00:08:55,700 --> 00:08:59,930
300 sis calls any one of which is

00:08:57,890 --> 00:09:01,700
exposed to a container you could use to

00:08:59,930 --> 00:09:03,410
exploit that exploit goes straight

00:09:01,700 --> 00:09:05,540
through to the host kernel the entire

00:09:03,410 --> 00:09:07,220
physical system is compromised and you

00:09:05,540 --> 00:09:09,140
can pull any piece of security

00:09:07,220 --> 00:09:12,829
information about any other tenant you

00:09:09,140 --> 00:09:14,690
can get so hypervisors have some sort of

00:09:12,829 --> 00:09:15,620
container envy because containers have

00:09:14,690 --> 00:09:17,630
been ruling the world

00:09:15,620 --> 00:09:19,550
but they're seeking to bring it back but

00:09:17,630 --> 00:09:21,800
effectively trying to make hypervisors

00:09:19,550 --> 00:09:24,050
great again I've had to get that Red Hat

00:09:21,800 --> 00:09:26,180
phrase in there but most of it is

00:09:24,050 --> 00:09:29,510
actually fake news so most of it is

00:09:26,180 --> 00:09:31,820
about this security stuff and what I'm

00:09:29,510 --> 00:09:36,380
going to try and do today is expose some

00:09:31,820 --> 00:09:38,450
of the fakery so the real problem in

00:09:36,380 --> 00:09:40,760
this security debate is a complete lack

00:09:38,450 --> 00:09:43,010
effect so I gave you the crux of that

00:09:40,760 --> 00:09:44,899
debate but I didn't give you one solid

00:09:43,010 --> 00:09:46,700
engineering fact in any of that debate I

00:09:44,899 --> 00:09:48,980
waved my hands around and said things

00:09:46,700 --> 00:09:51,110
like surface penetration hyper core

00:09:48,980 --> 00:09:53,660
syscall interface breadth of interface

00:09:51,110 --> 00:09:55,370
therefore hypervisors good containers

00:09:53,660 --> 00:09:57,769
bad is what it all amounts to there is

00:09:55,370 --> 00:10:00,020
no intellectual rigor in any of these

00:09:57,769 --> 00:10:02,029
debates part of the problem is that will

00:10:00,020 --> 00:10:04,100
actually be doing that see thirty

00:10:02,029 --> 00:10:06,170
minutes we'll go over the containers API

00:10:04,100 --> 00:10:08,300
so this is if you actually orchestrate

00:10:06,170 --> 00:10:10,220
containers and understand it this is how

00:10:08,300 --> 00:10:12,110
containers work in the Linux kernel if

00:10:10,220 --> 00:10:13,399
you are a kubernetes person this is

00:10:12,110 --> 00:10:14,899
where your head explodes because you

00:10:13,399 --> 00:10:16,430
never actually need to understand any of

00:10:14,899 --> 00:10:18,950
this but the great thing about

00:10:16,430 --> 00:10:21,290
containers is that every container

00:10:18,950 --> 00:10:23,690
system on the planet orchestrates using

00:10:21,290 --> 00:10:27,020
this interface so lxc does it docker

00:10:23,690 --> 00:10:28,850
does it the me sauce container

00:10:27,020 --> 00:10:31,160
orchestration system does it all new

00:10:28,850 --> 00:10:33,050
orchestration systems still use this

00:10:31,160 --> 00:10:34,279
interface this is actually quite an

00:10:33,050 --> 00:10:35,750
achievement if you think about the

00:10:34,279 --> 00:10:37,970
difference between us and hypervisors

00:10:35,750 --> 00:10:40,070
because the 2 hypervisors we bring up on

00:10:37,970 --> 00:10:41,630
Linux then and KVM actually is

00:10:40,070 --> 00:10:43,730
completely separate in kernel

00:10:41,630 --> 00:10:46,160
orchestration subsystems and work in

00:10:43,730 --> 00:10:48,020
completely separate ways so getting all

00:10:46,160 --> 00:10:49,579
of the container people to agree to use

00:10:48,020 --> 00:10:51,800
the same interface as one of the great

00:10:49,579 --> 00:10:53,930
achievements of containers way back in

00:10:51,800 --> 00:10:57,199
2011 when we came to this agreement at

00:10:53,930 --> 00:10:58,940
the kernel summit so this API is the

00:10:57,199 --> 00:11:00,890
same it came from the agreement at the

00:10:58,940 --> 00:11:03,140
kernel summit it actually caused

00:11:00,890 --> 00:11:05,720
container interest to converge on a

00:11:03,140 --> 00:11:06,830
unified API and that we could all talk

00:11:05,720 --> 00:11:08,390
about containers and

00:11:06,830 --> 00:11:10,370
theoretically be on the same page book

00:11:08,390 --> 00:11:12,230
even if one one guy was working for

00:11:10,370 --> 00:11:14,120
darker one was working for rocket one

00:11:12,230 --> 00:11:15,980
was working for Alexei and so on

00:11:14,120 --> 00:11:18,670
we were all talking about the same thing

00:11:15,980 --> 00:11:20,900
and obviously we didn't bifurcate our

00:11:18,670 --> 00:11:23,540
development resources into two separate

00:11:20,900 --> 00:11:25,250
sub systems like Xen and KVM did and it

00:11:23,540 --> 00:11:26,960
actually led directly to the ability of

00:11:25,250 --> 00:11:29,480
docker to run upstream and it's also

00:11:26,960 --> 00:11:31,280
fairly rapidly evolving and obviously

00:11:29,480 --> 00:11:32,600
there are lots of sea groups I'm not

00:11:31,280 --> 00:11:34,790
going to go over them a name them all

00:11:32,600 --> 00:11:36,710
these see groups job is to control

00:11:34,790 --> 00:11:38,480
resources within the kernel so it's to

00:11:36,710 --> 00:11:41,180
make resource control decisions for a

00:11:38,480 --> 00:11:42,830
container and obviously these sea groups

00:11:41,180 --> 00:11:44,210
are all granular they can be turned on

00:11:42,830 --> 00:11:46,190
and off at the whim of the container

00:11:44,210 --> 00:11:48,320
system and this is one of the problem in

00:11:46,190 --> 00:11:49,880
containers for virtual machines you have

00:11:48,320 --> 00:11:51,740
a really hard description of what a

00:11:49,880 --> 00:11:53,930
virtual machine is because it's whatever

00:11:51,740 --> 00:11:55,970
the virtual hardware is for a container

00:11:53,930 --> 00:11:58,160
you can actually choose to turn on or

00:11:55,970 --> 00:12:00,590
off any of these si groups or namespaces

00:11:58,160 --> 00:12:02,600
individually namespaces there are about

00:12:00,590 --> 00:12:05,780
seven of them now there's Network IPC

00:12:02,600 --> 00:12:08,450
man PID and so on a namespaces job is to

00:12:05,780 --> 00:12:09,830
do a security separation of some sort of

00:12:08,450 --> 00:12:11,840
system interface with the northern

00:12:09,830 --> 00:12:13,490
external so for instance the network

00:12:11,840 --> 00:12:15,350
namespace allows you to bring up fully

00:12:13,490 --> 00:12:17,780
separated network interfaces within the

00:12:15,350 --> 00:12:19,850
container the mount namespace allows you

00:12:17,780 --> 00:12:22,400
to have a fully separated mount tree for

00:12:19,850 --> 00:12:24,650
each container the PID namespace allows

00:12:22,400 --> 00:12:26,750
each container to have a PID one running

00:12:24,650 --> 00:12:28,640
inside it main reason for this is

00:12:26,750 --> 00:12:30,830
Annette gets very an or system D gets

00:12:28,640 --> 00:12:32,990
very annoyed if it's not PA D one the

00:12:30,830 --> 00:12:34,850
UTS namespace just allows you to bring

00:12:32,990 --> 00:12:37,160
up NFS clients within the container of

00:12:34,850 --> 00:12:39,890
virtualizes the kernels view of the host

00:12:37,160 --> 00:12:41,840
name and the domain name and so on the

00:12:39,890 --> 00:12:43,460
user namespace was recently well not

00:12:41,840 --> 00:12:45,500
recently now it's sort of several years

00:12:43,460 --> 00:12:47,930
old like about five years old was

00:12:45,500 --> 00:12:50,000
introduced to actually get rid of the

00:12:47,930 --> 00:12:52,520
problem where real root runs inside a

00:12:50,000 --> 00:12:54,890
container and he was and the C group

00:12:52,520 --> 00:12:56,540
namespace which was introduced in 4.6

00:12:54,890 --> 00:12:58,250
was to try and actually make sure that

00:12:56,540 --> 00:13:00,050
we could bring up nested containers with

00:12:58,250 --> 00:13:04,070
all of these things it's not actually

00:13:00,050 --> 00:13:05,660
been terribly successful so far the

00:13:04,070 --> 00:13:07,400
problem with this interface that you

00:13:05,660 --> 00:13:09,950
hear lots of docker people tell you is

00:13:07,400 --> 00:13:11,600
it's almost impossible to use as kernel

00:13:09,950 --> 00:13:12,950
people sitting in the room you probably

00:13:11,600 --> 00:13:15,200
understand that actually it's quite easy

00:13:12,950 --> 00:13:16,910
to use and we do it all the time if you

00:13:15,200 --> 00:13:18,650
look at how I orchestrate containers on

00:13:16,910 --> 00:13:20,660
my laptop I basically create a few

00:13:18,650 --> 00:13:22,370
namespaces bind it into

00:13:20,660 --> 00:13:24,470
the temporary file system and away I go

00:13:22,370 --> 00:13:27,079
I don't really use any orchestration

00:13:24,470 --> 00:13:28,699
system but the myth that the

00:13:27,079 --> 00:13:30,769
orchestration people present is that

00:13:28,699 --> 00:13:33,019
orchestration systems are required for

00:13:30,769 --> 00:13:34,819
containers and being sort of good

00:13:33,019 --> 00:13:36,410
operating system people whose time has

00:13:34,819 --> 00:13:38,269
passed because we're essentially

00:13:36,410 --> 00:13:39,740
responsible for the plumbing right

00:13:38,269 --> 00:13:41,420
that's all they care about

00:13:39,740 --> 00:13:43,459
we're the people who manage the drains

00:13:41,420 --> 00:13:45,350
they manage the interesting stuff that

00:13:43,459 --> 00:13:47,180
tips into the drains so we're the

00:13:45,350 --> 00:13:49,129
people in the thigh length waders we

00:13:47,180 --> 00:13:50,689
just don't matter what we think it's all

00:13:49,129 --> 00:13:53,810
about the orchestration system for

00:13:50,689 --> 00:13:55,519
container people but the point I want to

00:13:53,810 --> 00:13:57,170
make about all of versus docker is not

00:13:55,519 --> 00:13:58,310
the end of containers is actually just

00:13:57,170 --> 00:14:01,519
the beginning there's a lot of

00:13:58,310 --> 00:14:03,589
interesting stuff to do in containers

00:14:01,519 --> 00:14:05,180
and one of the big problems here is that

00:14:03,589 --> 00:14:07,610
docker is the source of quite a few of

00:14:05,180 --> 00:14:10,490
our security issues certain issues that

00:14:07,610 --> 00:14:11,870
are hurled at us for containers actually

00:14:10,490 --> 00:14:13,519
don't exist if you build a container

00:14:11,870 --> 00:14:14,899
correctly it's just because docker

00:14:13,519 --> 00:14:17,029
doesn't actually build the container

00:14:14,899 --> 00:14:19,519
correctly the reason is that right at

00:14:17,029 --> 00:14:22,189
the moment most docker instances don't

00:14:19,519 --> 00:14:24,709
use the username space if you go to a

00:14:22,189 --> 00:14:26,930
cloud with a docker image that requires

00:14:24,709 --> 00:14:29,389
root and you just run it on any random

00:14:26,930 --> 00:14:30,980
cloud chances are you have the real

00:14:29,389 --> 00:14:33,050
system root running inside your

00:14:30,980 --> 00:14:35,750
container there's any containment escape

00:14:33,050 --> 00:14:37,759
you don't even need to use a an exploit

00:14:35,750 --> 00:14:40,009
tool to do privileged elevation you

00:14:37,759 --> 00:14:42,290
already have privilege this is a bit of

00:14:40,009 --> 00:14:44,269
a security problem and hypervisor people

00:14:42,290 --> 00:14:48,050
are obviously very keen to remind us of

00:14:44,269 --> 00:14:49,610
this so one of the things I was actually

00:14:48,050 --> 00:14:51,410
talking about in the containers micro

00:14:49,610 --> 00:14:54,259
conference yesterday was actually how we

00:14:51,410 --> 00:14:55,550
get docker to adopt the username space

00:14:54,259 --> 00:14:56,600
and actually get rid of its root

00:14:55,550 --> 00:14:58,310
security problem

00:14:56,600 --> 00:14:59,480
this was the shifter first talk that we

00:14:58,310 --> 00:15:02,060
were doing I'm not sure we'll actually

00:14:59,480 --> 00:15:05,089
do it that way but as the plumbing guys

00:15:02,060 --> 00:15:06,620
we're all on it as the frothy container

00:15:05,089 --> 00:15:08,059
guys I'm sure they even don't know what

00:15:06,620 --> 00:15:09,620
we're doing but we'll spoon feed it to

00:15:08,059 --> 00:15:13,250
them when we finally work out how to do

00:15:09,620 --> 00:15:17,420
it but anyway the point about this talk

00:15:13,250 --> 00:15:20,149
is countering the hype and in order to

00:15:17,420 --> 00:15:22,939
actually make definitive statements

00:15:20,149 --> 00:15:24,980
about security you actually need a way

00:15:22,939 --> 00:15:26,809
of measuring security and this is the

00:15:24,980 --> 00:15:29,300
dirty little secret everybody talks

00:15:26,809 --> 00:15:31,010
about security nobody can give you a

00:15:29,300 --> 00:15:33,260
definitive way of measuring

00:15:31,010 --> 00:15:35,120
security this is why security experts

00:15:33,260 --> 00:15:37,070
just can't agree because even when

00:15:35,120 --> 00:15:38,840
security experts talk about security

00:15:37,070 --> 00:15:40,340
they're usually talking about different

00:15:38,840 --> 00:15:41,900
things and they're different things

00:15:40,340 --> 00:15:44,000
they're talking about is usually their

00:15:41,900 --> 00:15:46,310
own personal opinion of whether this is

00:15:44,000 --> 00:15:49,090
secure or not because by and large there

00:15:46,310 --> 00:15:52,670
is no definitive way of measuring this

00:15:49,090 --> 00:15:55,400
so one of the things I gave my research

00:15:52,670 --> 00:15:58,280
group with an IBM research to do a while

00:15:55,400 --> 00:16:00,920
ago is come up with a definitive way of

00:15:58,280 --> 00:16:03,380
actually getting me a numerical measure

00:16:00,920 --> 00:16:06,620
of security can this actually be done

00:16:03,380 --> 00:16:08,450
and we considered for a long time how we

00:16:06,620 --> 00:16:10,640
would actually do this and we finally

00:16:08,450 --> 00:16:12,890
decided that the best way of actually

00:16:10,640 --> 00:16:14,510
measuring security at least in the first

00:16:12,890 --> 00:16:17,060
approximation was something called an

00:16:14,510 --> 00:16:22,700
attack profile what an attack profile

00:16:17,060 --> 00:16:24,950
means is that if I have a stack that

00:16:22,700 --> 00:16:26,840
exposes itself to the internet and runs

00:16:24,950 --> 00:16:29,000
down and runs down and runs down and

00:16:26,840 --> 00:16:30,860
finally hits physical Hardware every

00:16:29,000 --> 00:16:32,960
path that comes in from the web goes

00:16:30,860 --> 00:16:34,580
through a whole bundle of code hits

00:16:32,960 --> 00:16:35,840
hardware and then comes back through

00:16:34,580 --> 00:16:38,930
that bundle of code and gives you a

00:16:35,840 --> 00:16:41,480
response traversing that entire call

00:16:38,930 --> 00:16:43,280
path up and down potentially leads

00:16:41,480 --> 00:16:45,680
allows you to run across various

00:16:43,280 --> 00:16:46,880
exploits which are problems and the bugs

00:16:45,680 --> 00:16:50,120
in the code that we haven't actually

00:16:46,880 --> 00:16:52,310
found and if the attacker is clever any

00:16:50,120 --> 00:16:54,140
one of these potential exploits that are

00:16:52,310 --> 00:16:56,080
found in the stack can be used to gain

00:16:54,140 --> 00:16:59,420
control of your application to break out

00:16:56,080 --> 00:17:02,060
so we concluded that vertical attack

00:16:59,420 --> 00:17:04,190
profile was something like the number of

00:17:02,060 --> 00:17:06,440
lines of code that he would traverse

00:17:04,190 --> 00:17:08,260
going when the container or whatever it

00:17:06,440 --> 00:17:10,520
is is performing its normal operation

00:17:08,260 --> 00:17:13,640
multiplied by the approximate CVE

00:17:10,520 --> 00:17:15,380
density got from estimates and so for

00:17:13,640 --> 00:17:18,020
the kernel which is that the shared

00:17:15,380 --> 00:17:19,820
component this is roughly constant so we

00:17:18,020 --> 00:17:21,650
just think of it as multiplying by a

00:17:19,820 --> 00:17:24,020
standard constant we just chuck it away

00:17:21,650 --> 00:17:25,780
so the attack profile is roughly the

00:17:24,020 --> 00:17:29,480
number of lines of code traversed

00:17:25,780 --> 00:17:31,730
however and this is where the discussion

00:17:29,480 --> 00:17:34,430
gets interesting some of that attack

00:17:31,730 --> 00:17:36,620
profile belongs to the tenant and some

00:17:34,430 --> 00:17:39,110
belongs to the host so in a hypervisor

00:17:36,620 --> 00:17:42,170
everything almost everything apart from

00:17:39,110 --> 00:17:42,920
the Hardware emulation system belongs to

00:17:42,170 --> 00:17:45,110
the tenant

00:17:42,920 --> 00:17:47,090
so the tenant and a hypervisor system is

00:17:45,110 --> 00:17:49,370
responsible for much more of the

00:17:47,090 --> 00:17:51,170
vertical attack profile than a tenant in

00:17:49,370 --> 00:17:53,300
the container system in a container

00:17:51,170 --> 00:17:55,580
system the tenants responsibility stops

00:17:53,300 --> 00:17:57,500
at the Cisco interface so the hosting

00:17:55,580 --> 00:17:59,630
provider is actually responsible for all

00:17:57,500 --> 00:18:02,660
of the shared kernel interfaces so the

00:17:59,630 --> 00:18:04,430
actual vertical attack profile or tenant

00:18:02,660 --> 00:18:06,200
is responsible for in a container is

00:18:04,430 --> 00:18:08,090
much smaller than a hypervisor which is

00:18:06,200 --> 00:18:10,430
useful but it doesn't mean the overall

00:18:08,090 --> 00:18:11,720
attack profile is smaller because it is

00:18:10,430 --> 00:18:13,610
technically because there's actually

00:18:11,720 --> 00:18:15,920
less code in a container than there is

00:18:13,610 --> 00:18:18,530
in a hypervisor but the big problem is

00:18:15,920 --> 00:18:20,360
that there is a huge horizontal piece in

00:18:18,530 --> 00:18:21,920
the container which is technically the

00:18:20,360 --> 00:18:24,530
responsibility of the hosting provider

00:18:21,920 --> 00:18:26,270
no hosting provider tells you this they

00:18:24,530 --> 00:18:28,070
all scream about you know you have to

00:18:26,270 --> 00:18:30,290
protect yourself on this interface and

00:18:28,070 --> 00:18:32,600
in fact most hosting providers would

00:18:30,290 --> 00:18:35,780
prefer you running a hypervisor not

00:18:32,600 --> 00:18:37,730
because it's easier or for you or it

00:18:35,780 --> 00:18:39,590
gives you more security as they will

00:18:37,730 --> 00:18:41,660
claim but because it makes you

00:18:39,590 --> 00:18:43,880
responsible for the guest kernel so you

00:18:41,660 --> 00:18:46,130
are now responsible for all exploits in

00:18:43,880 --> 00:18:47,750
the guest kernel any hosting provider

00:18:46,130 --> 00:18:50,060
that allows you to run on their bare

00:18:47,750 --> 00:18:52,070
metal containers they are responsible

00:18:50,060 --> 00:18:54,560
for all potential exploits in the kernel

00:18:52,070 --> 00:18:57,050
a lot of the security and that system

00:18:54,560 --> 00:18:58,790
becomes their responsibility and this is

00:18:57,050 --> 00:19:01,970
why as far as I know there is only

00:18:58,790 --> 00:19:04,190
current one current cloud that actually

00:19:01,970 --> 00:19:07,490
sells you bare metal containers and it

00:19:04,190 --> 00:19:09,080
was the IBM bluemix cloud and we did it

00:19:07,490 --> 00:19:11,090
because we wanted to prove to the world

00:19:09,080 --> 00:19:13,310
that it was actually possible to run a

00:19:11,090 --> 00:19:15,320
system where we would be responsible for

00:19:13,310 --> 00:19:18,080
a significant chunk of the security

00:19:15,320 --> 00:19:20,390
profile of the applications however I'm

00:19:18,080 --> 00:19:22,640
not here to blow IBM's horn I'm here to

00:19:20,390 --> 00:19:25,130
talk about this horizontal attack

00:19:22,640 --> 00:19:27,590
profile if you're on native bare metal

00:19:25,130 --> 00:19:29,930
containers is the reason that hypervisor

00:19:27,590 --> 00:19:32,270
people claim it's so dangerous to do

00:19:29,930 --> 00:19:33,410
this so we ran our cloud like this to

00:19:32,270 --> 00:19:35,120
prove that actually it wasn't as

00:19:33,410 --> 00:19:36,920
dangerous as you thought but when we

00:19:35,120 --> 00:19:38,870
brought up the bluemix cloud we actually

00:19:36,920 --> 00:19:40,400
had no idea how big the danger was

00:19:38,870 --> 00:19:42,350
because there are no definitive

00:19:40,400 --> 00:19:44,090
statistics proving this the only way we

00:19:42,350 --> 00:19:46,430
could actually tell if we had a problem

00:19:44,090 --> 00:19:48,860
was to expose the entire cloud to the

00:19:46,430 --> 00:19:50,870
Internet and say see okay who's gonna

00:19:48,860 --> 00:19:52,940
hack us that was that's basically how we

00:19:50,870 --> 00:19:55,010
thought that you know this there's

00:19:52,940 --> 00:19:56,659
something here that means that although

00:19:55,010 --> 00:19:58,159
hypervisor people can

00:19:56,659 --> 00:20:00,169
claim that containers are hundreds of

00:19:58,159 --> 00:20:02,659
times more vulnerable and hypervisors

00:20:00,169 --> 00:20:04,999
when we actually exposed a bare-metal

00:20:02,659 --> 00:20:07,039
container interface to the world we did

00:20:04,999 --> 00:20:09,289
not get hundreds of times more exploits

00:20:07,039 --> 00:20:11,119
than a hosting provider on hypervisors

00:20:09,289 --> 00:20:13,159
got and there must be a reason for this

00:20:11,119 --> 00:20:14,989
trying to find out what the reason for

00:20:13,159 --> 00:20:16,940
this is what led us down this research

00:20:14,989 --> 00:20:19,009
path and what led us to the attack

00:20:16,940 --> 00:20:22,849
profile concept which is basically lines

00:20:19,009 --> 00:20:24,470
of code reversed so the overall a chance

00:20:22,849 --> 00:20:26,629
of attack being attacked in the shared

00:20:24,470 --> 00:20:27,830
kernel the horizontal profile which is

00:20:26,629 --> 00:20:30,259
the thing which is really dangerous

00:20:27,830 --> 00:20:32,779
because any exploit in this code is in

00:20:30,259 --> 00:20:34,639
shared code I can use that exploit to go

00:20:32,779 --> 00:20:37,309
back up into another tenants container

00:20:34,639 --> 00:20:40,220
and I can compromise your entire system

00:20:37,309 --> 00:20:42,619
so any horizontal exploit is potentially

00:20:40,220 --> 00:20:44,690
fatal to a hosting provider and the

00:20:42,619 --> 00:20:46,549
horizontal profile is in theory the

00:20:44,690 --> 00:20:48,470
amount of exposed code in the Linux

00:20:46,549 --> 00:20:51,859
kernel multiplied by the potential bug

00:20:48,470 --> 00:20:55,549
density in that code so here are the

00:20:51,859 --> 00:20:57,979
observations the measured horizontal

00:20:55,549 --> 00:20:59,779
attack profile of docker versus that of

00:20:57,979 --> 00:21:02,690
cata containers and the way we measured

00:20:59,779 --> 00:21:05,059
this is we actually ran F trace profiles

00:21:02,690 --> 00:21:07,369
of what were these the system calls that

00:21:05,059 --> 00:21:09,379
are actually being made through k vm and

00:21:07,369 --> 00:21:11,869
the host cata containers and what was

00:21:09,379 --> 00:21:13,940
actually being done by a standard docker

00:21:11,869 --> 00:21:16,429
application and this is roughly what it

00:21:13,940 --> 00:21:18,229
looks like these are for sorry you

00:21:16,429 --> 00:21:21,409
probably can't read these but this is

00:21:18,229 --> 00:21:23,779
first node test this is was a Redis test

00:21:21,409 --> 00:21:25,940
and this is the Python tornado test and

00:21:23,779 --> 00:21:27,379
this is actually using F trace to

00:21:25,940 --> 00:21:29,869
measure the lines of code traversed

00:21:27,379 --> 00:21:33,619
inside the kernel for those tests first

00:21:29,869 --> 00:21:36,259
observation the red line which is docker

00:21:33,619 --> 00:21:38,929
is docker on bare metal in the kernel

00:21:36,259 --> 00:21:41,090
the blue line which is cat is cat a

00:21:38,929 --> 00:21:41,720
container so it's basically a container

00:21:41,090 --> 00:21:44,929
on docker

00:21:41,720 --> 00:21:46,669
running in KVM on the host and all we're

00:21:44,929 --> 00:21:49,489
measuring is the profile of the host

00:21:46,669 --> 00:21:51,649
kernel and contrary to what hypervisor

00:21:49,489 --> 00:21:53,779
people have long claimed these two lines

00:21:51,649 --> 00:21:55,369
are not a hundred times apart they're

00:21:53,779 --> 00:21:57,649
roughly if you look at I mean so

00:21:55,369 --> 00:21:59,509
obviously docker is worse on every line

00:21:57,649 --> 00:22:01,909
so that there is greater profile

00:21:59,509 --> 00:22:04,549
exposure in bare-metal docker on every

00:22:01,909 --> 00:22:06,200
line but it's not that much greater than

00:22:04,549 --> 00:22:09,230
the profile exposure of Kb

00:22:06,200 --> 00:22:11,900
these differences are at worst here

00:22:09,230 --> 00:22:14,090
you're talking about 30% at best here

00:22:11,900 --> 00:22:16,670
you're talking about 10% right this is

00:22:14,090 --> 00:22:18,290
not a factor of 100 and this is actually

00:22:16,670 --> 00:22:18,620
a security measurement of what's going

00:22:18,290 --> 00:22:20,630
on

00:22:18,620 --> 00:22:22,490
now this security measurement is a bit

00:22:20,630 --> 00:22:24,740
of a lie because that's what's going on

00:22:22,490 --> 00:22:26,900
for a well behaved application obviously

00:22:24,740 --> 00:22:28,400
if I were going to prove the entire to

00:22:26,900 --> 00:22:30,260
school interface I wouldn't be running

00:22:28,400 --> 00:22:33,710
these tests I'd be running a full fuzzer

00:22:30,260 --> 00:22:36,530
interface but the point is that if I

00:22:33,710 --> 00:22:39,410
could constrain my docker container with

00:22:36,530 --> 00:22:41,660
a adequate set comp profile to only use

00:22:39,410 --> 00:22:43,490
these system calls the amount of exposed

00:22:41,660 --> 00:22:45,410
code would pretty much match what my

00:22:43,490 --> 00:22:48,320
application is running so I'm not

00:22:45,410 --> 00:22:50,660
promising you that docker is completely

00:22:48,320 --> 00:22:53,510
secure but I'm promising you that there

00:22:50,660 --> 00:22:56,210
is a way of securing docker such that

00:22:53,510 --> 00:22:59,030
your risk map pretty much what a

00:22:56,210 --> 00:23:00,980
hypervisor gets to within a tens of

00:22:59,030 --> 00:23:02,930
percent not to within orders of

00:23:00,980 --> 00:23:06,650
magnitude like hypervisor people contain

00:23:02,930 --> 00:23:08,540
but putting that security profile in

00:23:06,650 --> 00:23:10,940
place is still a huge problem I'm not

00:23:08,540 --> 00:23:13,010
going to pretend it's easy can crafting

00:23:10,940 --> 00:23:15,470
good set comp profiles from docker is

00:23:13,010 --> 00:23:19,160
horrible it is an exercise that I think

00:23:15,470 --> 00:23:22,790
only Jesse Frisell could love but if you

00:23:19,160 --> 00:23:24,860
do it you can get a horizontal attack

00:23:22,790 --> 00:23:26,840
profile for a container that is pretty

00:23:24,860 --> 00:23:29,960
much equivalent to the horizontal attack

00:23:26,840 --> 00:23:32,330
profile for a hypervisor however where

00:23:29,960 --> 00:23:33,860
IBM research we didn't stop there once

00:23:32,330 --> 00:23:36,590
we'd measured this and now we have a

00:23:33,860 --> 00:23:39,260
reason we understand why our bare metal

00:23:36,590 --> 00:23:41,720
cloud was not attacked hundreds of times

00:23:39,260 --> 00:23:43,340
more than a stand hosting cloud we if we

00:23:41,720 --> 00:23:45,260
measure the amount of people trying to

00:23:43,340 --> 00:23:46,760
attack it the the people who actually

00:23:45,260 --> 00:23:48,830
manage to get exploits earned looks

00:23:46,760 --> 00:23:52,250
about the same as any public cloud that

00:23:48,830 --> 00:23:54,170
ran hypervisors so our attack actual our

00:23:52,250 --> 00:23:56,660
empirical data was that we seem to be

00:23:54,170 --> 00:23:59,240
about as secure as a public cloud and

00:23:56,660 --> 00:24:00,890
this is what this profile is backing up

00:23:59,240 --> 00:24:03,170
there is actually a scientific

00:24:00,890 --> 00:24:05,030
measurable reason why we didn't get

00:24:03,170 --> 00:24:07,250
hundreds of times more exploits than

00:24:05,030 --> 00:24:09,710
hypervisors did and it's because of the

00:24:07,250 --> 00:24:12,460
fact that the exploitable surface area

00:24:09,710 --> 00:24:15,620
can be well contained even in the

00:24:12,460 --> 00:24:18,380
and this means that once we've actually

00:24:15,620 --> 00:24:21,050
made this attack profile we can actually

00:24:18,380 --> 00:24:23,270
start to measure different containment

00:24:21,050 --> 00:24:25,580
principles and we can actually use this

00:24:23,270 --> 00:24:28,130
attack profile to guide ourselves

00:24:25,580 --> 00:24:30,500
towards a container system that actually

00:24:28,130 --> 00:24:32,390
minimizes the horizontal profile this is

00:24:30,500 --> 00:24:34,070
what things like G visor and if you've

00:24:32,390 --> 00:24:36,260
heard of an a blur are doing I won't

00:24:34,070 --> 00:24:38,690
mention a blur too much because how we

00:24:36,260 --> 00:24:40,760
did it is another 45-minute talk that I

00:24:38,690 --> 00:24:43,070
have no time for but now we have a

00:24:40,760 --> 00:24:45,020
measure we can actually experiment with

00:24:43,070 --> 00:24:46,760
different profiles and see you know does

00:24:45,020 --> 00:24:48,410
the containment fact to go up or down

00:24:46,760 --> 00:24:50,330
and when we do this and obviously the

00:24:48,410 --> 00:24:51,830
back of our mind the thing I had that I

00:24:50,330 --> 00:24:53,300
knew would make the headlines which is

00:24:51,830 --> 00:24:56,390
what happened when we didn't announce

00:24:53,300 --> 00:24:58,250
nabla is can I build a container that on

00:24:56,390 --> 00:24:58,940
these tests is more secure than a

00:24:58,250 --> 00:25:00,800
hypervisor

00:24:58,940 --> 00:25:02,210
I knew if I could do that all of the

00:25:00,800 --> 00:25:04,310
news outlets would be phenomenally

00:25:02,210 --> 00:25:05,900
interested in the statement not because

00:25:04,310 --> 00:25:07,820
they understood any of the engineering

00:25:05,900 --> 00:25:09,350
facts going into this statement but

00:25:07,820 --> 00:25:11,690
because it's a hugely controversial

00:25:09,350 --> 00:25:14,120
statement to make and news outlets love

00:25:11,690 --> 00:25:17,450
controversy so I was looking to be able

00:25:14,120 --> 00:25:19,310
to make this statement and also the

00:25:17,450 --> 00:25:21,440
other problem is that this defect

00:25:19,310 --> 00:25:23,570
profile horizontal attack profile I

00:25:21,440 --> 00:25:24,920
don't think this is the air end of the

00:25:23,570 --> 00:25:26,480
state-of-the-art I think this is the

00:25:24,920 --> 00:25:28,580
beginning of a conversation of how we

00:25:26,480 --> 00:25:30,860
measure security the point of giving

00:25:28,580 --> 00:25:32,600
this talk today is this is how we did

00:25:30,860 --> 00:25:34,400
the security measurements but I've got a

00:25:32,600 --> 00:25:36,320
funny feeling there are much better ways

00:25:34,400 --> 00:25:39,080
of measuring security and now we need to

00:25:36,320 --> 00:25:41,150
find out what they are the problem is

00:25:39,080 --> 00:25:43,280
with the horizontal attack profile of as

00:25:41,150 --> 00:25:45,680
a measure is if no one can exploit your

00:25:43,280 --> 00:25:47,630
bug does it actually exist so the kernel

00:25:45,680 --> 00:25:48,530
contains many many bugs but not all of

00:25:47,630 --> 00:25:51,260
them are CVEs

00:25:48,530 --> 00:25:53,420
some of them are not exploitable bugs so

00:25:51,260 --> 00:25:55,730
obviously just taking the entire defect

00:25:53,420 --> 00:25:57,890
profile of the kernel and just saying we

00:25:55,730 --> 00:25:59,900
have X bugs per line of code and

00:25:57,890 --> 00:26:02,090
therefore our attack vulnerability is

00:25:59,900 --> 00:26:04,580
number of lines of code x x bugs is

00:26:02,090 --> 00:26:09,170
untrue because some of those bugs are

00:26:04,580 --> 00:26:11,630
not exploitable and we need therefore to

00:26:09,170 --> 00:26:13,610
incorporate exploit ability as a measure

00:26:11,630 --> 00:26:15,410
in this horizontal attack profile so I'm

00:26:13,610 --> 00:26:17,600
hoping that this will be the next

00:26:15,410 --> 00:26:19,800
refinement of attack profiles try and

00:26:17,600 --> 00:26:23,460
incorporate exploit ability

00:26:19,800 --> 00:26:26,040
I also suspect this means that the

00:26:23,460 --> 00:26:27,900
actual interface description becomes the

00:26:26,040 --> 00:26:29,970
most important factor so the most

00:26:27,900 --> 00:26:32,160
important factor for exploiting a bug in

00:26:29,970 --> 00:26:34,380
the kernel is not actually the number of

00:26:32,160 --> 00:26:36,420
lines of code you traverse I suspect

00:26:34,380 --> 00:26:39,330
it's the breadth of what the system call

00:26:36,420 --> 00:26:41,160
API actually allows you to do now all of

00:26:39,330 --> 00:26:43,680
this is speculation so I'm indulging in

00:26:41,160 --> 00:26:45,810
hypervisor hype here I have no empirical

00:26:43,680 --> 00:26:47,490
proof this is what it is but for those

00:26:45,810 --> 00:26:49,620
of you who are interested in this area

00:26:47,490 --> 00:26:52,980
and want to go off and explore I think

00:26:49,620 --> 00:26:54,780
the next generation of measurements of

00:26:52,980 --> 00:26:57,750
this will actually be somewhere in the

00:26:54,780 --> 00:26:59,880
interface so I will tell you now that at

00:26:57,750 --> 00:27:01,140
IBM we were racing to try and do this

00:26:59,880 --> 00:27:02,940
because this will be the next press

00:27:01,140 --> 00:27:04,650
release but if you want to do it at home

00:27:02,940 --> 00:27:06,930
I think this is what you want to be

00:27:04,650 --> 00:27:08,940
looking at in order to come up with the

00:27:06,930 --> 00:27:11,430
second-generation measure of how secure

00:27:08,940 --> 00:27:13,560
is a container or a hypervisor because

00:27:11,430 --> 00:27:15,480
some interfaces are obviously inherently

00:27:13,560 --> 00:27:17,250
more exploitable than others we have

00:27:15,480 --> 00:27:19,290
system calls in the kernel that with the

00:27:17,250 --> 00:27:20,910
ever getting exploits in and we have

00:27:19,290 --> 00:27:23,340
some system calls that no one has ever

00:27:20,910 --> 00:27:24,960
worked out how to exploit obviously some

00:27:23,340 --> 00:27:27,030
of them are much more secure than others

00:27:24,960 --> 00:27:30,390
and we need to factor in this security

00:27:27,030 --> 00:27:32,310
and also if we could get a guarding

00:27:30,390 --> 00:27:35,070
system that took the insecure system

00:27:32,310 --> 00:27:37,170
calls and just quietly checked with EBP

00:27:35,070 --> 00:27:39,390
F or something and threw out anything

00:27:37,170 --> 00:27:41,220
anybody did that was insecure you might

00:27:39,390 --> 00:27:42,890
actually be able to make the kernel

00:27:41,220 --> 00:27:44,610
interface itself much more secure

00:27:42,890 --> 00:27:46,650
independently of whether we use it for

00:27:44,610 --> 00:27:48,900
containers or not so there's clearly a

00:27:46,650 --> 00:27:53,340
lot of research work to actually be done

00:27:48,900 --> 00:27:55,680
in this field but what we were actually

00:27:53,340 --> 00:27:58,080
interested in is producing an

00:27:55,680 --> 00:28:00,360
alternative container description so you

00:27:58,080 --> 00:28:02,670
probably heard the term sandboxing so in

00:28:00,360 --> 00:28:05,190
a sandbox the idea is that you run a

00:28:02,670 --> 00:28:07,080
container but you run it in a way that

00:28:05,190 --> 00:28:09,120
it's not exposed to the full Linux

00:28:07,080 --> 00:28:11,550
system call interface what you do in a

00:28:09,120 --> 00:28:13,830
sandbox is you take certain Linux system

00:28:11,550 --> 00:28:16,260
calls and you emulate them inside the

00:28:13,830 --> 00:28:18,510
sandbox now this is obviously starting

00:28:16,260 --> 00:28:20,190
to look a bit like a mini hypervisor

00:28:18,510 --> 00:28:23,010
running and calling itself a container

00:28:20,190 --> 00:28:25,320
but sandboxing has been around for a

00:28:23,010 --> 00:28:27,930
while as actually a way of getting

00:28:25,320 --> 00:28:31,660
security containment without actually

00:28:27,930 --> 00:28:34,660
doing full hypervisor set up and for

00:28:31,660 --> 00:28:36,850
hypervisor image building and so it

00:28:34,660 --> 00:28:39,250
means emulating some system calls for

00:28:36,850 --> 00:28:40,900
isolation instead of doing namespace so

00:28:39,250 --> 00:28:43,030
the nabla containers we build actually

00:28:40,900 --> 00:28:45,040
use C groups but in our namespaces

00:28:43,030 --> 00:28:46,690
although technically we cheated you do

00:28:45,040 --> 00:28:49,320
use a network namespace because if you

00:28:46,690 --> 00:28:52,000
don't keep a Nettie's doesn't work an

00:28:49,320 --> 00:28:53,830
emulation means that the code isn't

00:28:52,000 --> 00:28:56,260
shared if I'm emulating a system call

00:28:53,830 --> 00:28:57,940
within the tenon container the tenant

00:28:56,260 --> 00:28:59,890
container is actually responsible for

00:28:57,940 --> 00:29:01,840
the code in that system call so I've

00:28:59,890 --> 00:29:04,570
lowered the horizontal attack profile

00:29:01,840 --> 00:29:06,430
partially by doing the emulation but

00:29:04,570 --> 00:29:08,140
also by actively pushing the

00:29:06,430 --> 00:29:10,180
responsibility back into the tenant

00:29:08,140 --> 00:29:12,370
again so another part of our container

00:29:10,180 --> 00:29:14,170
description was actually working out how

00:29:12,370 --> 00:29:16,000
we could actually give responsibility

00:29:14,170 --> 00:29:18,670
for the emulation system to the hosts as

00:29:16,000 --> 00:29:20,350
I said it's another you know 45 minute

00:29:18,670 --> 00:29:21,640
to an hour talk about nabla containers

00:29:20,350 --> 00:29:23,260
so I'm not gonna be telling you how we

00:29:21,640 --> 00:29:25,600
did this I'm just going to be telling

00:29:23,260 --> 00:29:27,130
you that we we recognized that we

00:29:25,600 --> 00:29:28,990
couldn't just push the problem back on

00:29:27,130 --> 00:29:31,330
to the tenant as everybody is done with

00:29:28,990 --> 00:29:33,070
hypervisor for generations if we pushed

00:29:31,330 --> 00:29:34,930
it back into the emulation environment

00:29:33,070 --> 00:29:36,700
the hosting service provider actually

00:29:34,930 --> 00:29:38,830
has to take responsibility for that

00:29:36,700 --> 00:29:40,870
emulation environment which is what we

00:29:38,830 --> 00:29:44,470
were looking to do in a black containers

00:29:40,870 --> 00:29:46,240
thing and obviously it's very difficult

00:29:44,470 --> 00:29:48,040
to get sandboxing right without

00:29:46,240 --> 00:29:50,020
committing the hypervisor fault which is

00:29:48,040 --> 00:29:51,790
just basically pushing the entire tenant

00:29:50,020 --> 00:29:54,220
entire responsibility off onto the

00:29:51,790 --> 00:29:56,080
tenant if you're a tenant in a virtual

00:29:54,220 --> 00:29:57,670
machine you actually have to understand

00:29:56,080 --> 00:29:59,470
what kernel bugs are because you're

00:29:57,670 --> 00:30:01,240
responsible for patching them in your

00:29:59,470 --> 00:30:03,370
guest environment if you don't want your

00:30:01,240 --> 00:30:06,700
guests to be exploited this is the

00:30:03,370 --> 00:30:08,560
hypervisor fault the true benefits of

00:30:06,700 --> 00:30:10,840
the cloud revolution and containers

00:30:08,560 --> 00:30:14,230
should be shifting that responsibility

00:30:10,840 --> 00:30:16,210
boundary from the tenant to the service

00:30:14,230 --> 00:30:17,860
provider because the service provider is

00:30:16,210 --> 00:30:19,870
the person who has all of these response

00:30:17,860 --> 00:30:22,570
teams they have all of this expertise

00:30:19,870 --> 00:30:24,660
and security if they can take from you

00:30:22,570 --> 00:30:26,710
the responsibility for responding to

00:30:24,660 --> 00:30:29,230
exploits that have discovered or

00:30:26,710 --> 00:30:31,390
problems in your environment for you

00:30:29,230 --> 00:30:33,730
that is a big win because it means it's

00:30:31,390 --> 00:30:35,740
all sorts of stuff you no longer need an

00:30:33,730 --> 00:30:38,620
expert for when you build a container

00:30:35,740 --> 00:30:40,630
itself so shifting that boundary is one

00:30:38,620 --> 00:30:43,090
of the biggest favors that a cloud

00:30:40,630 --> 00:30:44,999
service provider can do for you and most

00:30:43,090 --> 00:30:46,469
cloud services provide us today or if

00:30:44,999 --> 00:30:47,849
using to do that they're mostly trying

00:30:46,469 --> 00:30:50,459
to make it your fault if something goes

00:30:47,849 --> 00:30:52,589
wrong in your container and if a good

00:30:50,459 --> 00:30:54,149
cloud service provider or aiming for us

00:30:52,589 --> 00:30:56,189
to make it our fault is the person

00:30:54,149 --> 00:30:58,349
running your containers if we can take

00:30:56,189 --> 00:31:00,149
from you most of the security burden you

00:30:58,349 --> 00:31:01,799
can concentrate much more on building

00:31:00,149 --> 00:31:04,529
your applications in a safe way

00:31:01,799 --> 00:31:06,269
obviously we can't take all of it if you

00:31:04,529 --> 00:31:08,369
write a crap application that's easily

00:31:06,269 --> 00:31:09,719
exploitable just because we're fixing

00:31:08,369 --> 00:31:11,429
and finding and fixing all of the bugs

00:31:09,719 --> 00:31:13,499
and the kernel doesn't mean your crap

00:31:11,429 --> 00:31:15,389
application is any less crap so you

00:31:13,499 --> 00:31:18,179
still have to take responsibility for

00:31:15,389 --> 00:31:20,579
part of it but the less you have to take

00:31:18,179 --> 00:31:21,929
responsibility fart for the more chance

00:31:20,579 --> 00:31:25,319
there is that you'll actually get that

00:31:21,929 --> 00:31:27,989
part of it right and so at least in IBM

00:31:25,319 --> 00:31:30,299
research we regard our job as enabling

00:31:27,989 --> 00:31:32,309
the cloud service provider to take over

00:31:30,299 --> 00:31:35,129
management of most of these security

00:31:32,309 --> 00:31:37,349
problems in the cloud itself and that

00:31:35,129 --> 00:31:39,899
actually means that the horizontal

00:31:37,349 --> 00:31:42,209
attack profile is really useful unlike

00:31:39,899 --> 00:31:45,419
in the original IBM bluemix container

00:31:42,209 --> 00:31:47,669
not because it's sort of an interesting

00:31:45,419 --> 00:31:50,009
point to explore technology for

00:31:47,669 --> 00:31:52,409
reductions but even if there's no

00:31:50,009 --> 00:31:54,239
reduction at all it's no longer your

00:31:52,409 --> 00:31:55,739
responsibility as the tenant it's our

00:31:54,239 --> 00:31:57,929
responsibility as the cloud service

00:31:55,739 --> 00:31:59,249
provider so we become the ones who are

00:31:57,929 --> 00:32:01,409
interested in all the security

00:31:59,249 --> 00:32:03,829
technology and you the tenant shouldn't

00:32:01,409 --> 00:32:07,289
care because it's all our responsibility

00:32:03,829 --> 00:32:08,519
and the two well-known sandboxes that

00:32:07,289 --> 00:32:11,519
you may have heard of are obviously

00:32:08,519 --> 00:32:14,879
Google G Weiser which is a system that

00:32:11,519 --> 00:32:17,159
builds kernel system calls in go and the

00:32:14,879 --> 00:32:18,419
IBM nabla containers nabla containers is

00:32:17,159 --> 00:32:20,399
actually based on unique onal

00:32:18,419 --> 00:32:21,989
technologies so it's actually trying to

00:32:20,399 --> 00:32:23,759
build a library operating system that

00:32:21,989 --> 00:32:25,499
has a container description

00:32:23,759 --> 00:32:27,149
the reason it's done that way is because

00:32:25,499 --> 00:32:28,979
the team I got to work with an IBM with

00:32:27,149 --> 00:32:30,659
the unit kernel team and so you always

00:32:28,979 --> 00:32:32,039
do something that your team is familiar

00:32:30,659 --> 00:32:33,959
with which is why we built nabla

00:32:32,039 --> 00:32:35,789
containers and the way we did but the

00:32:33,959 --> 00:32:38,039
objective in building nabla containers

00:32:35,789 --> 00:32:40,229
was try and get a sandbox contain a

00:32:38,039 --> 00:32:41,999
description that on the horizontal

00:32:40,229 --> 00:32:44,699
attack profile and the shared kernel

00:32:41,999 --> 00:32:48,209
would turn out to be more secure than a

00:32:44,699 --> 00:32:50,699
hypervisor and the interesting question

00:32:48,209 --> 00:32:51,749
is did we do this G visor so I'm going

00:32:50,699 --> 00:32:55,109
to show you some figures for this

00:32:51,749 --> 00:32:57,269
shortly I have to explain that when I

00:32:55,109 --> 00:32:58,050
show these figures G visor actually

00:32:57,269 --> 00:32:59,610
turns out

00:32:58,050 --> 00:33:01,440
be the worst containment system ever

00:32:59,610 --> 00:33:03,690
it's actually even worse than docker on

00:33:01,440 --> 00:33:05,640
the measure we developed the problem

00:33:03,690 --> 00:33:07,590
here is not that gee visor is doing the

00:33:05,640 --> 00:33:09,300
wrong thing the problem is that gee

00:33:07,590 --> 00:33:11,550
visor decided to rewrite all of the

00:33:09,300 --> 00:33:13,680
system calls and go which is fine but

00:33:11,550 --> 00:33:15,390
what I'm measuring is you know the

00:33:13,680 --> 00:33:17,670
attack profe the amount of code

00:33:15,390 --> 00:33:19,950
traversed in the kernel and it turns out

00:33:17,670 --> 00:33:22,290
that the go runtime is incredibly

00:33:19,950 --> 00:33:25,440
profligate in terms of system calls so

00:33:22,290 --> 00:33:27,480
gee visor itself might be a secure way

00:33:25,440 --> 00:33:30,030
of doing it but the go runtime destroys

00:33:27,480 --> 00:33:31,980
all that security if they invested in

00:33:30,030 --> 00:33:34,260
writing a secure go runtime that had

00:33:31,980 --> 00:33:36,330
less system call profile into the kernel

00:33:34,260 --> 00:33:38,640
their figures would be a lot better so

00:33:36,330 --> 00:33:40,650
on the measure I'm using the Google

00:33:38,640 --> 00:33:42,330
figures are actually sort of somewhat

00:33:40,650 --> 00:33:42,780
inflated but it's because of why they

00:33:42,330 --> 00:33:45,180
did it

00:33:42,780 --> 00:33:46,560
nabla extracting unique kernel

00:33:45,180 --> 00:33:49,020
techniques a library operating system

00:33:46,560 --> 00:33:52,770
fitting them into a single profile gets

00:33:49,020 --> 00:33:54,780
much better response to this because if

00:33:52,770 --> 00:33:56,490
you look at what unique kernels do the

00:33:54,780 --> 00:33:58,470
library operating system is almost an

00:33:56,490 --> 00:34:00,690
entire kernel in itself so we can

00:33:58,470 --> 00:34:03,390
emulate system calls that ever making an

00:34:00,690 --> 00:34:05,520
actual other system called down into the

00:34:03,390 --> 00:34:07,710
Linux kernel so we can emulate whole

00:34:05,520 --> 00:34:09,600
system calls in user space without ever

00:34:07,710 --> 00:34:13,470
troubling the kernel this gives us a

00:34:09,600 --> 00:34:15,270
much lower attack profile but obviously

00:34:13,470 --> 00:34:17,220
we try and keep the standard content so

00:34:15,270 --> 00:34:19,140
we deliberately tried to make this a

00:34:17,220 --> 00:34:21,090
proper container it's supposed to have

00:34:19,140 --> 00:34:22,679
proper resource sharing we're supposed

00:34:21,090 --> 00:34:24,780
to be using proper Linux management

00:34:22,679 --> 00:34:26,700
techniques and as I said how we did this

00:34:24,780 --> 00:34:28,140
is another 45-minute talk that I'm not

00:34:26,700 --> 00:34:30,810
going to go into but these are the

00:34:28,140 --> 00:34:32,250
figures so you see in red this is darker

00:34:30,810 --> 00:34:37,440
so this is a standard line for all

00:34:32,250 --> 00:34:39,929
containers Green is G Weiser KVM bigger

00:34:37,440 --> 00:34:42,150
is worse so larger attack profile means

00:34:39,929 --> 00:34:44,070
more chance of attacks so this is the

00:34:42,150 --> 00:34:46,679
Jiva is a problem because of the go

00:34:44,070 --> 00:34:48,750
runtime this is cat a containers doing

00:34:46,679 --> 00:34:51,510
slightly better and blue again so it's

00:34:48,750 --> 00:34:53,700
always doing better than docker and the

00:34:51,510 --> 00:34:55,650
orange is the nabla containers and as

00:34:53,700 --> 00:34:57,600
you can see the horizontal attack

00:34:55,650 --> 00:35:00,510
profile for the nabla containers is

00:34:57,600 --> 00:35:02,610
getting to be it's not significantly

00:35:00,510 --> 00:35:04,980
better than hypervisors but in every

00:35:02,610 --> 00:35:08,340
test it is better and in some tests is

00:35:04,980 --> 00:35:09,530
better bite by at least 50% so here we

00:35:08,340 --> 00:35:12,650
actually have built

00:35:09,530 --> 00:35:14,450
a container description on an empirical

00:35:12,650 --> 00:35:16,520
test that is more secure than a

00:35:14,450 --> 00:35:17,600
hypervisor so what I'm hoping is that

00:35:16,520 --> 00:35:19,610
once and for all

00:35:17,600 --> 00:35:21,590
this puts to rest the security debates

00:35:19,610 --> 00:35:23,930
about what is more secure a container or

00:35:21,590 --> 00:35:25,910
a hypervisor the answer there is neither

00:35:23,930 --> 00:35:26,870
unless you build correctly but if you

00:35:25,910 --> 00:35:28,820
know what you're doing

00:35:26,870 --> 00:35:31,070
I can build a container that is more

00:35:28,820 --> 00:35:34,010
secure than a hypervisor and actually in

00:35:31,070 --> 00:35:35,870
order to drive home the point khattak

00:35:34,010 --> 00:35:37,550
containers has an interesting interface

00:35:35,870 --> 00:35:39,680
problem in the linux kernel and the way

00:35:37,550 --> 00:35:41,450
it connects the kubernetes using this

00:35:39,680 --> 00:35:43,910
analysis in the eff trace we were able

00:35:41,450 --> 00:35:46,280
to spot what the problem was and I sent

00:35:43,910 --> 00:35:48,500
an intern out and said get me an exploit

00:35:46,280 --> 00:35:50,450
insert so I can run a program inside a

00:35:48,500 --> 00:35:51,830
cat a container and it will loop the

00:35:50,450 --> 00:35:54,560
host kernel prove to me that this

00:35:51,830 --> 00:35:56,600
exploit exists so my intern emailed me

00:35:54,560 --> 00:35:58,490
his 15 megabyte video of doing it today

00:35:56,600 --> 00:36:00,200
I'm not going to show it to you in this

00:35:58,490 --> 00:36:02,930
talk but we'll be releasing it from the

00:36:00,200 --> 00:36:04,520
IBM Research nabla blog to just show how

00:36:02,930 --> 00:36:07,100
this is and it's a simple proof of

00:36:04,520 --> 00:36:09,470
concept where you run this binary and

00:36:07,100 --> 00:36:12,440
the cat container which is inside docker

00:36:09,470 --> 00:36:14,600
inside KVM and the guest kernel actually

00:36:12,440 --> 00:36:16,880
gives an oops so it is perfectly

00:36:14,600 --> 00:36:19,250
possible even in the hypervisor system

00:36:16,880 --> 00:36:20,780
to find an exploit that will actually

00:36:19,250 --> 00:36:22,520
get you through to the guest kernel

00:36:20,780 --> 00:36:24,200
which is the whole point of this and we

00:36:22,520 --> 00:36:27,200
cheated enormous Lee the reason it works

00:36:24,200 --> 00:36:28,880
is because making a hypervisor that runs

00:36:27,200 --> 00:36:30,890
as a container is difficult the problem

00:36:28,880 --> 00:36:32,630
with containers is they they like to

00:36:30,890 --> 00:36:35,480
think in terms of file systems instead

00:36:32,630 --> 00:36:38,240
of block devices so the the exploit that

00:36:35,480 --> 00:36:40,550
he found is that nabla can Cata

00:36:38,240 --> 00:36:42,290
containers has a plan line interface

00:36:40,550 --> 00:36:44,480
that actually is simply an interface

00:36:42,290 --> 00:36:47,750
transport between the guest and the host

00:36:44,480 --> 00:36:50,030
for all filesystem API calls so any

00:36:47,750 --> 00:36:53,330
exploit I can find in the filesystem API

00:36:50,030 --> 00:36:55,280
call the p9 interface and the guest will

00:36:53,330 --> 00:36:57,110
diligently transport that exploit to the

00:36:55,280 --> 00:36:59,390
host which is how we did it so this

00:36:57,110 --> 00:37:01,760
wouldn't happen in an ordinary KVM guest

00:36:59,390 --> 00:37:04,040
because that 9-p interface doesn't exist

00:37:01,760 --> 00:37:06,110
but what it shows you is you have to be

00:37:04,040 --> 00:37:09,200
incredibly careful when you setup

00:37:06,110 --> 00:37:10,700
interface descriptions even if you think

00:37:09,200 --> 00:37:12,470
you're using a virtual machine and

00:37:10,700 --> 00:37:14,600
you've bought into all of the hypervisor

00:37:12,470 --> 00:37:17,320
hype you may not be getting all of the

00:37:14,600 --> 00:37:21,250
benefits from this virtual machine

00:37:17,320 --> 00:37:23,080
so anyway what's next obviously but the

00:37:21,250 --> 00:37:24,670
questions we can start asking is is

00:37:23,080 --> 00:37:26,290
there some useful way of segmenting

00:37:24,670 --> 00:37:28,630
within the Linux kernel all of these

00:37:26,290 --> 00:37:30,460
system calls if I could separate system

00:37:28,630 --> 00:37:32,140
calls into separate address spaces that

00:37:30,460 --> 00:37:34,390
belong to the tenant I would no longer

00:37:32,140 --> 00:37:35,920
be able to do an exploit from one system

00:37:34,390 --> 00:37:37,920
call to another which might actually be

00:37:35,920 --> 00:37:41,410
useful this is one potential Avenue

00:37:37,920 --> 00:37:42,850
exploring address space separation so

00:37:41,410 --> 00:37:44,650
run parts of the kernel with user

00:37:42,850 --> 00:37:46,570
context the Linux is going to scream

00:37:44,650 --> 00:37:48,250
when we try doing this but it I think

00:37:46,570 --> 00:37:50,590
it's an interesting way of researching

00:37:48,250 --> 00:37:52,930
as well because again it's separating

00:37:50,590 --> 00:37:54,820
the kernel system calls into things that

00:37:52,930 --> 00:37:57,640
can't be used to exploit the shared

00:37:54,820 --> 00:37:59,950
surface area and obviously we can use

00:37:57,640 --> 00:38:01,900
supervisors like Linux security modules

00:37:59,950 --> 00:38:03,400
to correct interface defects now we

00:38:01,900 --> 00:38:05,710
actually started to measure where the

00:38:03,400 --> 00:38:07,330
interface defects are I think we could

00:38:05,710 --> 00:38:10,090
actually start to have a scientific

00:38:07,330 --> 00:38:12,310
exploration of can we craft an Alice am

00:38:10,090 --> 00:38:14,380
that carefully protects all the system

00:38:12,310 --> 00:38:16,240
call interfaces much more efficiently

00:38:14,380 --> 00:38:18,670
than all the current Alice amps because

00:38:16,240 --> 00:38:20,770
in fact all current Alice arms are still

00:38:18,670 --> 00:38:22,930
based on the security hand wavy stuff of

00:38:20,770 --> 00:38:25,680
we feel these interfaces are insecure so

00:38:22,930 --> 00:38:28,480
we're going to protect them and

00:38:25,680 --> 00:38:30,160
obviously we also have to look at what

00:38:28,480 --> 00:38:32,740
about the vertical attack profile as I

00:38:30,160 --> 00:38:35,020
said the job of the hosting provider is

00:38:32,740 --> 00:38:37,300
to reduce that va vertical attack

00:38:35,020 --> 00:38:38,890
profile not necessarily by reducing the

00:38:37,300 --> 00:38:40,960
whole attack profile but just by

00:38:38,890 --> 00:38:43,840
reducing the tenants responsibility for

00:38:40,960 --> 00:38:46,420
it so we have to look at ways we can

00:38:43,840 --> 00:38:48,190
actually move up the stack and make more

00:38:46,420 --> 00:38:49,570
of this the responsibility of the hosts

00:38:48,190 --> 00:38:51,400
and be the tenants this is also

00:38:49,570 --> 00:38:53,650
something we're actually looking at but

00:38:51,400 --> 00:38:56,350
anyway I have two minute le five minutes

00:38:53,650 --> 00:38:58,450
of questions so conclusions are there's

00:38:56,350 --> 00:39:00,970
really a lot of exciting process to be

00:38:58,450 --> 00:39:02,920
made simply exploring how we measure

00:39:00,970 --> 00:39:04,990
security once we have a measure of

00:39:02,920 --> 00:39:06,880
security we use that measure to guide us

00:39:04,990 --> 00:39:08,830
as we build container descriptions

00:39:06,880 --> 00:39:10,510
instead of doing all the hand wavy crap

00:39:08,830 --> 00:39:12,940
that everybody's done for decades

00:39:10,510 --> 00:39:15,070
we now have an empirical scientific way

00:39:12,940 --> 00:39:16,840
of guiding the secure building of

00:39:15,070 --> 00:39:19,000
containers the secure building of

00:39:16,840 --> 00:39:21,040
security modules and even the secure

00:39:19,000 --> 00:39:24,580
construction of system call interfaces

00:39:21,040 --> 00:39:26,290
for Linux kernel but this field is at

00:39:24,580 --> 00:39:28,420
its beginning it's not at its end the

00:39:26,290 --> 00:39:30,460
measures I showed you are very very

00:39:28,420 --> 00:39:32,950
crude they produce certain

00:39:30,460 --> 00:39:34,599
things that are perhaps not reflections

00:39:32,950 --> 00:39:36,760
of accurate reality even though now

00:39:34,599 --> 00:39:39,070
finally I have an empirical way of

00:39:36,760 --> 00:39:41,560
comparing them I think we need to see

00:39:39,070 --> 00:39:43,089
second and third-generation refinements

00:39:41,560 --> 00:39:45,490
of this before we're completely happy

00:39:43,089 --> 00:39:47,830
saying this number that I've got as the

00:39:45,490 --> 00:39:49,990
attack profile is really a true

00:39:47,830 --> 00:39:52,089
representative of the true security

00:39:49,990 --> 00:39:54,400
hardness of that system I think we still

00:39:52,089 --> 00:39:55,930
have a bit of a way to go so we found an

00:39:54,400 --> 00:39:59,230
initial measure but there's a long way

00:39:55,930 --> 00:40:01,270
to go in finding the real measures and I

00:39:59,230 --> 00:40:02,980
think there's even more exciting

00:40:01,270 --> 00:40:04,750
advances to be made in terms of how do

00:40:02,980 --> 00:40:06,310
you secure containers because this is my

00:40:04,750 --> 00:40:08,800
field this is what I'm interested in I

00:40:06,310 --> 00:40:12,640
expect to have many more interesting

00:40:08,800 --> 00:40:14,349
blog posts about how I've developed a

00:40:12,640 --> 00:40:16,990
container system that is way way more

00:40:14,349 --> 00:40:19,030
secure than a hypervisor not just 50%

00:40:16,990 --> 00:40:20,230
more secure than a hypervisor and it

00:40:19,030 --> 00:40:22,599
preserves all of the interesting

00:40:20,230 --> 00:40:24,460
container properties and obviously the

00:40:22,599 --> 00:40:26,530
real point is we need a whole lot more

00:40:24,460 --> 00:40:28,750
research into this field this is a new

00:40:26,530 --> 00:40:30,640
field now that everybody should start to

00:40:28,750 --> 00:40:32,530
get interested in if you're interested

00:40:30,640 --> 00:40:34,480
in any security property of your system

00:40:32,530 --> 00:40:35,980
at all because what we're looking at is

00:40:34,480 --> 00:40:38,260
trying to give you an empirical measure

00:40:35,980 --> 00:40:40,420
of how secure the system you built is

00:40:38,260 --> 00:40:42,040
and anybody who's actually interested in

00:40:40,420 --> 00:40:44,440
security should in some sense be

00:40:42,040 --> 00:40:46,750
interested in this measure so with that

00:40:44,440 --> 00:40:49,150
I'll just say this was as Jake Jake

00:40:46,750 --> 00:40:52,540
reminded me my web-based presentation

00:40:49,150 --> 00:40:54,220
using javascript html5 css3 now in

00:40:52,540 --> 00:40:56,200
addition to being a kernel developer I'm

00:40:54,220 --> 00:40:58,000
a web developer and I'll say thank you

00:40:56,200 --> 00:40:59,380
and I believe we have five minutes left

00:40:58,000 --> 00:41:04,330
and in those five minutes I'll ask for

00:40:59,380 --> 00:41:07,950
questions so thank you very much

00:41:04,330 --> 00:41:10,569
[Applause]

00:41:07,950 --> 00:41:14,440
while answering I also setup for the

00:41:10,569 --> 00:41:16,509
next person just just a question James

00:41:14,440 --> 00:41:19,259
in the terms of a new security

00:41:16,509 --> 00:41:22,210
vulnerability occurs in the real world

00:41:19,259 --> 00:41:23,799
outside of your research then have you a

00:41:22,210 --> 00:41:25,569
way to make sure that your model has

00:41:23,799 --> 00:41:28,509
some way of capturing that like are you

00:41:25,569 --> 00:41:30,039
still reiterating how you measure things

00:41:28,509 --> 00:41:32,559
based on what's happening in the real

00:41:30,039 --> 00:41:34,390
world so the question is how does my

00:41:32,559 --> 00:41:36,700
model of security react relate to

00:41:34,390 --> 00:41:38,980
reality and the fact is as I tried to

00:41:36,700 --> 00:41:40,749
explain it doesn't really all it is is a

00:41:38,980 --> 00:41:43,660
measure of how many defects do I

00:41:40,749 --> 00:41:44,859
Traverse as I execute this code and I

00:41:43,660 --> 00:41:46,150
don't know if those defects are

00:41:44,859 --> 00:41:49,779
exploitable or not which is the

00:41:46,150 --> 00:41:51,730
real-world thing so so bad guys hackers

00:41:49,779 --> 00:41:54,039
that they run through the kernel trying

00:41:51,730 --> 00:41:55,930
to find these deep defects but for every

00:41:54,039 --> 00:41:58,509
exploitable defect they find they

00:41:55,930 --> 00:42:00,309
probably thrown away about you know 50

00:41:58,509 --> 00:42:01,749
unexploited ball bugs that are sitting

00:42:00,309 --> 00:42:05,170
in the kernel and I've just counted all

00:42:01,749 --> 00:42:07,720
of them so I have and also if you look

00:42:05,170 --> 00:42:09,670
at correlation of CDEs the system calls

00:42:07,720 --> 00:42:11,499
used to exploit them there are certain

00:42:09,670 --> 00:42:13,539
system calls that are really hot in the

00:42:11,499 --> 00:42:14,799
exploit paths and certain system calls

00:42:13,539 --> 00:42:18,220
that aren't so this is the interface

00:42:14,799 --> 00:42:19,839
problem there is definitely something

00:42:18,220 --> 00:42:22,509
we're missing in this measure that we've

00:42:19,839 --> 00:42:24,519
done that the this this if you call into

00:42:22,509 --> 00:42:26,349
the system call you are inherently much

00:42:24,519 --> 00:42:28,390
more exploitable as an application than

00:42:26,349 --> 00:42:30,849
if you don't and we have totally missed

00:42:28,390 --> 00:42:33,039
our measure is blind to that so that's

00:42:30,849 --> 00:42:34,900
why this measure is it's the first

00:42:33,039 --> 00:42:37,450
attempt at doing a measure but it's by

00:42:34,900 --> 00:42:39,009
no means perfect and how far off from

00:42:37,450 --> 00:42:40,749
perfection it is I won't know until

00:42:39,009 --> 00:42:42,759
somebody does the second refinement and

00:42:40,749 --> 00:42:44,799
I look at it and say my god we were off

00:42:42,759 --> 00:42:46,989
by a factor of 10 I am surprised or

00:42:44,799 --> 00:42:49,359
perhaps we're only off by a factor of

00:42:46,989 --> 00:42:51,489
50% who knows but I have no way of

00:42:49,359 --> 00:42:55,140
giving you an honest answer as to how

00:42:51,489 --> 00:42:55,140
far were off because I just don't know

00:42:55,490 --> 00:43:03,809
is is the what the walks is shown so far

00:43:01,470 --> 00:43:06,299
is this publicly available with that

00:43:03,809 --> 00:43:09,180
someone turn yep so really they're

00:43:06,299 --> 00:43:10,740
available at github slash nabla I think

00:43:09,180 --> 00:43:12,869
it's nabla - containers I should have

00:43:10,740 --> 00:43:14,730
had the URL on my slides if you don't

00:43:12,869 --> 00:43:16,980
find it there just do a search for

00:43:14,730 --> 00:43:18,660
Nadler on github turns out that knobbler

00:43:16,980 --> 00:43:22,650
is a pretty unique search term so you

00:43:18,660 --> 00:43:27,390
will just find it I mean are you the

00:43:22,650 --> 00:43:29,369
proof also you create there so all of

00:43:27,390 --> 00:43:31,980
the stuff most of the stuff about so my

00:43:29,369 --> 00:43:34,440
blog my Hanson partnership blog has a

00:43:31,980 --> 00:43:37,710
lot of the proof points about the attack

00:43:34,440 --> 00:43:39,569
profiles the people who run the nabla

00:43:37,710 --> 00:43:41,369
github account are also the unit kernel

00:43:39,569 --> 00:43:43,410
people they're somewhat proud of all of

00:43:41,369 --> 00:43:45,210
their techniques so a lot of the initial

00:43:43,410 --> 00:43:47,369
techniques that went to proving this and

00:43:45,210 --> 00:43:49,559
the code we use to do the F trace

00:43:47,369 --> 00:43:51,869
measurements in the kernel are also up

00:43:49,559 --> 00:43:53,339
on that github account they're the ones

00:43:51,869 --> 00:43:55,049
with the fewer stars so if you look at

00:43:53,339 --> 00:43:56,819
our account we've got you know hundreds

00:43:55,049 --> 00:43:58,500
of stars on the kubernetes bit but we

00:43:56,819 --> 00:44:00,240
have lots of these weird and wonderful

00:43:58,500 --> 00:44:02,010
little things that have no stars that

00:44:00,240 --> 00:44:03,540
are all the code we used to do the proof

00:44:02,010 --> 00:44:05,910
code we used to do the measurement and

00:44:03,540 --> 00:44:08,670
everything else so it is almost lead on

00:44:05,910 --> 00:44:11,400
an open source up there just curious you

00:44:08,670 --> 00:44:13,619
said that you measured the attack

00:44:11,400 --> 00:44:15,359
profile for IBM bluemix with other

00:44:13,619 --> 00:44:17,430
cloud-based systems actually no you

00:44:15,359 --> 00:44:18,839
didn't so by the time we'd completed

00:44:17,430 --> 00:44:21,240
this measure the bluemix cloud had

00:44:18,839 --> 00:44:23,730
already been discontinued so what we

00:44:21,240 --> 00:44:25,170
measured was an approximation of what

00:44:23,730 --> 00:44:27,030
the bluemix cloud would have looked like

00:44:25,170 --> 00:44:29,220
so I never actually measured this to

00:44:27,030 --> 00:44:33,710
blue these are the other hypervisor

00:44:29,220 --> 00:44:33,710
based clouds including Google and no no

00:44:34,010 --> 00:44:39,540
we would get into incredible with

00:44:36,750 --> 00:44:41,790
SLA if we went around measure publishing

00:44:39,540 --> 00:44:43,829
measurements for other clouds everybody

00:44:41,790 --> 00:44:46,880
has a EULA that says you're not allowed

00:44:43,829 --> 00:44:48,990
to do this so we produced in our lab

00:44:46,880 --> 00:44:51,420
environments that we thought exactly

00:44:48,990 --> 00:44:53,400
replicated what the cloud was so all of

00:44:51,420 --> 00:44:55,440
this is done in lab copies of the cloud

00:44:53,400 --> 00:44:58,319
none of it is done in real clouds for

00:44:55,440 --> 00:45:00,119
our exploits some of them some of the

00:44:58,319 --> 00:45:01,260
stuff that we've actually done has been

00:45:00,119 --> 00:45:03,450
done and that the second-generation

00:45:01,260 --> 00:45:05,609
bluemix cloud which is now called armada

00:45:03,450 --> 00:45:07,260
but the dirty secret to that is we

00:45:05,609 --> 00:45:07,869
actually reintroduced hypervisors into

00:45:07,260 --> 00:45:09,729
our MA

00:45:07,869 --> 00:45:13,450
so we're no longer currently running a

00:45:09,729 --> 00:45:15,460
bare-metal container cloud I think

00:45:13,450 --> 00:45:17,920
containers running on top of Linux can

00:45:15,460 --> 00:45:20,170
be more secure because then hypervisor

00:45:17,920 --> 00:45:21,759
because they have more defense

00:45:20,170 --> 00:45:24,489
mechanisms for example and your common

00:45:21,759 --> 00:45:27,220
corner has CF I and other a bunch of

00:45:24,489 --> 00:45:29,680
contributors are contributing so I

00:45:27,220 --> 00:45:31,390
wonder like how because you mentioned

00:45:29,680 --> 00:45:34,299
you have plant extend your matrix but

00:45:31,390 --> 00:45:36,700
how can we take into account the defense

00:45:34,299 --> 00:45:38,499
mechanism even though there is a exploit

00:45:36,700 --> 00:45:39,940
it doesn't mean it's exploitable if

00:45:38,499 --> 00:45:41,859
there's a defense mechanism is okay so

00:45:39,940 --> 00:45:45,099
the essence of this question is about

00:45:41,859 --> 00:45:46,690
passive versus active defense and the

00:45:45,099 --> 00:45:48,549
point about all of the measures here is

00:45:46,690 --> 00:45:50,079
they're all measuring passive defense

00:45:48,549 --> 00:45:51,460
so it's all something that somebody's

00:45:50,079 --> 00:45:54,249
come along coming along to try and

00:45:51,460 --> 00:45:56,650
exploit I haven't put any measure of any

00:45:54,249 --> 00:45:58,930
active system that goes up goes out and

00:45:56,650 --> 00:46:00,460
tries to find and kill attackers sort of

00:45:58,930 --> 00:46:02,950
like the viral defense system for

00:46:00,460 --> 00:46:04,720
containers so none of that figures in

00:46:02,950 --> 00:46:06,999
any of this research this is all about

00:46:04,720 --> 00:46:09,729
passive defense so I agree that adding

00:46:06,999 --> 00:46:11,619
active defense could in theory make you

00:46:09,729 --> 00:46:13,900
look better and in fact a lot of the

00:46:11,619 --> 00:46:16,150
LSMs the skewed Linux security modules

00:46:13,900 --> 00:46:17,680
are active defense modules the problem

00:46:16,150 --> 00:46:19,869
with them on the measurements that I

00:46:17,680 --> 00:46:21,700
make of how many system calls each

00:46:19,869 --> 00:46:23,650
traversing in the kernel is that every

00:46:21,700 --> 00:46:26,529
time you activate an Alice on your

00:46:23,650 --> 00:46:28,059
system called profile goes up so on my

00:46:26,529 --> 00:46:29,469
measure it makes it look like your

00:46:28,059 --> 00:46:31,779
security just got worse

00:46:29,469 --> 00:46:33,489
so there is obviously something in

00:46:31,779 --> 00:46:35,380
active defense as well that has to

00:46:33,489 --> 00:46:37,420
factor into this so like I said there

00:46:35,380 --> 00:46:39,369
are many avenues for exploration in this

00:46:37,420 --> 00:46:41,440
interface descriptions is the one I

00:46:39,369 --> 00:46:42,880
think I'm most interested in but active

00:46:41,440 --> 00:46:44,650
defense is another one that everybody

00:46:42,880 --> 00:46:46,299
should be going off to explore how do

00:46:44,650 --> 00:46:48,430
you actually incorporate an active

00:46:46,299 --> 00:46:50,349
defense measure into this attack profile

00:46:48,430 --> 00:46:53,319
and I have no answer for that currently

00:46:50,349 --> 00:46:55,509
so if you believe the security module

00:46:53,319 --> 00:46:57,609
guys and some of them big enough to beat

00:46:55,509 --> 00:46:59,200
me up so you should believe them active

00:46:57,609 --> 00:47:00,729
defense is actually a significant

00:46:59,200 --> 00:47:02,710
contributor to the security of your

00:47:00,729 --> 00:47:04,420
container and my measure is just blind

00:47:02,710 --> 00:47:06,400
to that as well like I said this is a

00:47:04,420 --> 00:47:08,109
first generation measure it may be off

00:47:06,400 --> 00:47:10,210
by a factor of ten it may be off by

00:47:08,109 --> 00:47:11,680
fifty percent I have no idea but at

00:47:10,210 --> 00:47:14,819
least I have a measurement nobody else

00:47:11,680 --> 00:47:14,819
has a measurement that's the point

00:47:14,910 --> 00:47:21,430
we you're the you're the MC how many

00:47:18,070 --> 00:47:24,310
okay we I think we're over time so I'll

00:47:21,430 --> 00:47:27,440
be out in the corridor if you want

00:47:24,310 --> 00:47:27,440

YouTube URL: https://www.youtube.com/watch?v=0aqAMGMUOFs


