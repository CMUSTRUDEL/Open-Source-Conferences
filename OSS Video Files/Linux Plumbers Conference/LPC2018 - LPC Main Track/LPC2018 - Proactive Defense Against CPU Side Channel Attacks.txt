Title: LPC2018 - Proactive Defense Against CPU Side Channel Attacks
Publication date: 2018-12-04
Playlist: LPC2018 - LPC Main Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/77/
speaker:  Kristen Accardi


Side channel attacks are here to stay. What can we do inside the operating system to proactively defend against them? This talk will walk through a few of the ideas that Intelâ€™s Open Source Technology Center are developing to improve our resistance to side channel attacks as part of our new side channel defense project. We would also like to gather ideas from the rest of the community on what our top priorities for side channel defense for the Linux kernel should be.
Captions: 
	00:00:06,609 --> 00:00:12,040
my name is Kristen Accardi I know some

00:00:09,639 --> 00:00:13,809
of you but I'll introduce myself to

00:00:12,040 --> 00:00:16,470
those of you who don't know me I work at

00:00:13,809 --> 00:00:19,300
Intel's open source Technology Center

00:00:16,470 --> 00:00:22,630
I've worked on the kernel for many years

00:00:19,300 --> 00:00:26,769
now I think my first patch I sent was in

00:00:22,630 --> 00:00:30,189
like 2000 or so my hats so I popped

00:00:26,769 --> 00:00:33,640
around from subsystem to subsystem I've

00:00:30,189 --> 00:00:36,370
worked on the PCI I stood to maintain

00:00:33,640 --> 00:00:40,060
the PCI hoplite subsystem I've worked on

00:00:36,370 --> 00:00:43,420
a CPI power management and my newest

00:00:40,060 --> 00:00:46,690
incarnation of career is security I'm

00:00:43,420 --> 00:00:48,820
part of the OTC security team so today

00:00:46,690 --> 00:00:50,920
I'm going to talk to you about some

00:00:48,820 --> 00:00:53,050
ideas we have for how to do some

00:00:50,920 --> 00:00:56,350
proactive defense against CPU side

00:00:53,050 --> 00:00:59,200
channel attacks I'm gonna let you read

00:00:56,350 --> 00:01:03,970
this offline at your leisure tell me

00:00:59,200 --> 00:01:05,259
what it says ok so the first thing I

00:01:03,970 --> 00:01:09,850
want to talk to you about is is

00:01:05,259 --> 00:01:12,969
diversity so this is a definition of a

00:01:09,850 --> 00:01:15,759
monoculture that I got off of Wikipedia

00:01:12,969 --> 00:01:18,700
and I think we're all familiar with the

00:01:15,759 --> 00:01:20,140
idea of monocultures in agriculture and

00:01:18,700 --> 00:01:23,140
the kind of problems that they can

00:01:20,140 --> 00:01:26,439
present such as the Irish potato famine

00:01:23,140 --> 00:01:28,569
and we also are probably really familiar

00:01:26,439 --> 00:01:30,969
with the problems that it can present

00:01:28,569 --> 00:01:31,929
for computer infrastructures to the

00:01:30,969 --> 00:01:35,889
point where you know we have a

00:01:31,929 --> 00:01:39,700
definition on Wikipedia for monocultures

00:01:35,889 --> 00:01:41,740
in computing the Morris worm which was

00:01:39,700 --> 00:01:46,109
in 1988 was probably like the most

00:01:41,740 --> 00:01:50,109
famous incident of how monoculture

00:01:46,109 --> 00:01:51,969
software allowed a malicious piece of

00:01:50,109 --> 00:01:54,579
software to travel very efficiently and

00:01:51,969 --> 00:01:58,659
quickly so they've been it's been a

00:01:54,579 --> 00:02:00,459
problem for a long time so at this point

00:01:58,659 --> 00:02:03,639
you're probably wondering what does this

00:02:00,459 --> 00:02:05,350
have to do with side channels so I

00:02:03,639 --> 00:02:08,950
assume at this point that everybody

00:02:05,350 --> 00:02:11,020
knows what a side channel is but I just

00:02:08,950 --> 00:02:12,400
want to like give you a definition so

00:02:11,020 --> 00:02:14,790
that I can highlight the part that I

00:02:12,400 --> 00:02:17,380
think that you should find important and

00:02:14,790 --> 00:02:20,710
that's that a side channel attack

00:02:17,380 --> 00:02:22,660
is any kind of attack that's based on

00:02:20,710 --> 00:02:25,330
information that you can get from a

00:02:22,660 --> 00:02:27,820
computer system that is a result of the

00:02:25,330 --> 00:02:30,220
computer system itself rather than any

00:02:27,820 --> 00:02:32,380
kind of weakness in the algorithm so

00:02:30,220 --> 00:02:34,720
it's a way that information can get

00:02:32,380 --> 00:02:36,760
leaked rather than an exploit in and of

00:02:34,720 --> 00:02:38,980
itself and they've been around for

00:02:36,760 --> 00:02:40,960
decades and we've talked we've had side

00:02:38,980 --> 00:02:44,470
channels against power systems and

00:02:40,960 --> 00:02:46,020
various other things and also when you

00:02:44,470 --> 00:02:48,580
start looking at CPU microarchitectures

00:02:46,020 --> 00:02:50,290
side channels those have actually been

00:02:48,580 --> 00:02:51,910
around for years as well although

00:02:50,290 --> 00:02:53,980
they've gotten a lot of publicity this

00:02:51,910 --> 00:02:56,860
year they have been a thing for a while

00:02:53,980 --> 00:02:58,420
so they're not new academics have been

00:02:56,860 --> 00:03:01,150
writing papers about them for years

00:02:58,420 --> 00:03:02,730
so side channel this is the key takeaway

00:03:01,150 --> 00:03:05,500
those side channels in and of themselves

00:03:02,730 --> 00:03:11,440
aren't an exploit they're often the

00:03:05,500 --> 00:03:14,530
first step in an exploit so back to

00:03:11,440 --> 00:03:16,390
diversity so what does this why are we

00:03:14,530 --> 00:03:18,760
talking about it it's because software

00:03:16,390 --> 00:03:21,400
diversity makes some side channels less

00:03:18,760 --> 00:03:23,710
useful I think that it's a valid

00:03:21,400 --> 00:03:26,980
assumption at this point too to assume

00:03:23,710 --> 00:03:29,050
that we're going to see CPU based side

00:03:26,980 --> 00:03:31,720
channels for the foreseeable future

00:03:29,050 --> 00:03:33,940
they're just going to keep coming and so

00:03:31,720 --> 00:03:35,320
what we have to do is stop stop

00:03:33,940 --> 00:03:37,210
pretending that we are going to be able

00:03:35,320 --> 00:03:39,310
to block all of them and start assuming

00:03:37,210 --> 00:03:43,240
that we need to start making them yet

00:03:39,310 --> 00:03:45,130
less useful or harder to use so we have

00:03:43,240 --> 00:03:46,870
mitigations in place in the kernel today

00:03:45,130 --> 00:03:49,030
that blocks some of them but obviously

00:03:46,870 --> 00:03:51,390
we can't have blocked everything so

00:03:49,030 --> 00:03:53,950
being proactive means that we're not

00:03:51,390 --> 00:03:56,410
looking to address specific side

00:03:53,950 --> 00:03:59,470
channels or specific exploits we're

00:03:56,410 --> 00:04:00,610
doing hardening so this proposal I'm

00:03:59,470 --> 00:04:02,830
going to talk to you today is about

00:04:00,610 --> 00:04:08,220
hardening against future unknown

00:04:02,830 --> 00:04:11,230
exploits so there's been a lot of

00:04:08,220 --> 00:04:13,480
academic research on software diversity

00:04:11,230 --> 00:04:15,459
this is sort of a collection of the Pape

00:04:13,480 --> 00:04:17,650
some of the papers I found I didn't put

00:04:15,459 --> 00:04:20,830
all of them I just put a few until I got

00:04:17,650 --> 00:04:22,540
bored of making this slide the oldest

00:04:20,830 --> 00:04:24,889
paper though on this list is from the

00:04:22,540 --> 00:04:28,189
early 90s and the new is

00:04:24,889 --> 00:04:30,680
is from this year so obviously there's

00:04:28,189 --> 00:04:32,900
been a lot of research and continues to

00:04:30,680 --> 00:04:35,599
be a lot of research in this area

00:04:32,900 --> 00:04:38,389
however most operating systems today

00:04:35,599 --> 00:04:40,460
have really only adopted one method of

00:04:38,389 --> 00:04:44,749
automatic software diversity and we'll

00:04:40,460 --> 00:04:45,949
talk more about that later but before I

00:04:44,749 --> 00:04:47,810
can talk to you about code

00:04:45,949 --> 00:04:50,330
diversification diversification I want

00:04:47,810 --> 00:04:54,199
to give you a quick refresher on the elf

00:04:50,330 --> 00:04:56,930
file format elf is the format that's

00:04:54,199 --> 00:05:00,439
used most on linux and most unix systems

00:04:56,930 --> 00:05:03,259
it has sort of at the at the highest

00:05:00,439 --> 00:05:05,060
level it's got two basic formats one of

00:05:03,259 --> 00:05:07,550
them is an executable and the other one

00:05:05,060 --> 00:05:09,319
is a relocatable object format and this

00:05:07,550 --> 00:05:13,099
is a really simple version so that it

00:05:09,319 --> 00:05:15,139
fits nicely on my slide but this is the

00:05:13,099 --> 00:05:17,330
kernel is an executable format and it's

00:05:15,139 --> 00:05:20,360
got sort of these main sections it has a

00:05:17,330 --> 00:05:22,009
header where you use it to reference the

00:05:20,360 --> 00:05:23,089
other sections and get some information

00:05:22,009 --> 00:05:26,120
out of it

00:05:23,089 --> 00:05:29,330
and the the part that we care about in

00:05:26,120 --> 00:05:31,250
this picture is the text section the

00:05:29,330 --> 00:05:33,860
text section is where your code is

00:05:31,250 --> 00:05:35,509
that's where your executable code is so

00:05:33,860 --> 00:05:38,569
the kernel is obviously a lot more

00:05:35,509 --> 00:05:39,770
complicated than this in addition to the

00:05:38,569 --> 00:05:42,259
fact that I didn't list every single

00:05:39,770 --> 00:05:45,469
possible elf section here the kernel

00:05:42,259 --> 00:05:48,080
also makes special sections because fun

00:05:45,469 --> 00:05:50,779
I guess and I don't even know what they

00:05:48,080 --> 00:05:53,149
all do I expect I will soon but for now

00:05:50,779 --> 00:05:57,589
these are the basics and we're gonna

00:05:53,149 --> 00:05:59,240
focus on the text section so so when we

00:05:57,589 --> 00:06:02,120
start talking about code diversity

00:05:59,240 --> 00:06:05,120
there's really two categories of things

00:06:02,120 --> 00:06:08,120
that you can that you can talk about one

00:06:05,120 --> 00:06:11,300
of them is where is the level of

00:06:08,120 --> 00:06:13,580
randomization that you do and in this in

00:06:11,300 --> 00:06:16,490
this slide I've given you examples of

00:06:13,580 --> 00:06:18,020
where you can do randomization so we can

00:06:16,490 --> 00:06:21,349
do randomization all the way at the

00:06:18,020 --> 00:06:23,569
instruction level we can reorder basic

00:06:21,349 --> 00:06:25,759
blocks we've all we all have known for a

00:06:23,569 --> 00:06:27,319
long time that basic blocks can be

00:06:25,759 --> 00:06:29,270
certain basic blocks can be reordered

00:06:27,319 --> 00:06:31,669
and you retain your functionality so

00:06:29,270 --> 00:06:34,250
this is obviously something that we can

00:06:31,669 --> 00:06:37,070
do we can at the function level do

00:06:34,250 --> 00:06:39,400
randomization in fact OpenBSD has a

00:06:37,070 --> 00:06:43,100
stack layer remnant randomization

00:06:39,400 --> 00:06:45,110
enabled for their kernel you can change

00:06:43,100 --> 00:06:47,690
the function parameters on-the-fly I

00:06:45,110 --> 00:06:50,320
mean obviously that would break certain

00:06:47,690 --> 00:06:53,300
things like CFI but but what the heck

00:06:50,320 --> 00:06:55,960
and there's all kinds of other things

00:06:53,300 --> 00:06:58,280
finally you can do programmable

00:06:55,960 --> 00:07:00,440
randomization so at the program level

00:06:58,280 --> 00:07:02,690
you can do things like function

00:07:00,440 --> 00:07:05,500
reordering you can do base address

00:07:02,690 --> 00:07:08,450
randomization you can do some data

00:07:05,500 --> 00:07:10,040
randomization or you can do system

00:07:08,450 --> 00:07:11,480
called mapping randomization and I'm

00:07:10,040 --> 00:07:16,000
sure there's more but these are sort of

00:07:11,480 --> 00:07:16,000
like the biggies that I identified the

00:07:16,600 --> 00:07:21,620
second place where we can categorize

00:07:18,890 --> 00:07:24,260
randomization approaches is when you

00:07:21,620 --> 00:07:26,919
apply the randomization so this is kind

00:07:24,260 --> 00:07:29,570
of a diagram of the software life cycle

00:07:26,919 --> 00:07:31,850
vendor systems are the sort of the top

00:07:29,570 --> 00:07:33,740
part of the life cycle and user systems

00:07:31,850 --> 00:07:36,800
are at the bottom this shows you where

00:07:33,740 --> 00:07:38,390
these different steps happen so vendor

00:07:36,800 --> 00:07:41,620
systems are obviously controlled by the

00:07:38,390 --> 00:07:44,870
distributor of the software and the

00:07:41,620 --> 00:07:46,940
install load executes update is it takes

00:07:44,870 --> 00:07:51,380
place on the user system and those are

00:07:46,940 --> 00:07:53,840
user controlled so most operating

00:07:51,380 --> 00:07:55,880
systems as I mentioned have implemented

00:07:53,840 --> 00:07:59,419
one type of randomization and this is

00:07:55,880 --> 00:08:02,030
base address randomization for Linux

00:07:59,419 --> 00:08:04,790
it's implemented in both user space and

00:08:02,030 --> 00:08:06,710
the kernel and we also have the

00:08:04,790 --> 00:08:08,810
structure layout randomization if you

00:08:06,710 --> 00:08:11,540
actually use the GCC plug in that case

00:08:08,810 --> 00:08:13,970
put in there but these so these are the

00:08:11,540 --> 00:08:16,010
two things that we have and these are at

00:08:13,970 --> 00:08:20,450
the program level and we'll talk about

00:08:16,010 --> 00:08:24,530
why that's important later so as far as

00:08:20,450 --> 00:08:29,120
when to randomize aslr works at low time

00:08:24,530 --> 00:08:32,030
so every time you load a program and you

00:08:29,120 --> 00:08:34,669
have a SLR implement implemented then

00:08:32,030 --> 00:08:36,610
the ranma's a she takes place so this is

00:08:34,669 --> 00:08:39,560
this is kind of what kernel

00:08:36,610 --> 00:08:42,469
randomization looks like today so you

00:08:39,560 --> 00:08:44,990
can see here we have on the Left the

00:08:42,469 --> 00:08:46,999
address space that the kernels look

00:08:44,990 --> 00:08:50,569
and you have your little text section

00:08:46,999 --> 00:08:53,209
which is probably bigger but but the

00:08:50,569 --> 00:08:55,730
text section can move within this within

00:08:53,209 --> 00:08:57,949
this fixed range so the order within the

00:08:55,730 --> 00:09:00,649
text section is unchanged it's still the

00:08:57,949 --> 00:09:03,199
same as it was when it was built but as

00:09:00,649 --> 00:09:09,949
we load the kernel we can we can adjust

00:09:03,199 --> 00:09:12,619
it within certain parameters so the

00:09:09,949 --> 00:09:15,319
issue with ASL art as it is today is

00:09:12,619 --> 00:09:17,269
that it's pretty weak I mean even if

00:09:15,319 --> 00:09:20,449
you're talking about user space aslr

00:09:17,269 --> 00:09:23,480
it's a pretty weak defense the kernel in

00:09:20,449 --> 00:09:25,879
particular is extra weak because it has

00:09:23,480 --> 00:09:28,129
really low entropy meaning there's only

00:09:25,879 --> 00:09:30,889
so many places where you can fit that

00:09:28,129 --> 00:09:32,689
text slot into that little space that

00:09:30,889 --> 00:09:34,579
we're out with it we're allocated for

00:09:32,689 --> 00:09:36,559
address space so that means it's it's

00:09:34,579 --> 00:09:38,029
possible to do brute force attacks to

00:09:36,559 --> 00:09:41,240
just figure out where the kernel is

00:09:38,029 --> 00:09:44,389
located the other issue is that anytime

00:09:41,240 --> 00:09:47,569
you have any kind of info leak where a

00:09:44,389 --> 00:09:50,660
single address is revealed the location

00:09:47,569 --> 00:09:52,639
of the entire text segment can be found

00:09:50,660 --> 00:09:55,970
so that means that an attacker can

00:09:52,639 --> 00:09:57,980
construct an offline exploit in the

00:09:55,970 --> 00:10:00,199
comfort of their own home against some

00:09:57,980 --> 00:10:02,600
of the major district kernels and just

00:10:00,199 --> 00:10:07,459
calculate where the offset is of their

00:10:02,600 --> 00:10:09,019
attack once they get onto the system so

00:10:07,459 --> 00:10:11,869
at this point you might be wondering

00:10:09,019 --> 00:10:13,790
well if a SLR is so weak why don't we do

00:10:11,869 --> 00:10:17,509
more especially considering there's

00:10:13,790 --> 00:10:21,110
decades of research on this topic so the

00:10:17,509 --> 00:10:24,769
issue is is that monoculture has its

00:10:21,110 --> 00:10:27,670
benefits the software ecosystem as it is

00:10:24,769 --> 00:10:31,720
today is actually built around

00:10:27,670 --> 00:10:33,980
monoculture they this is the way that IT

00:10:31,720 --> 00:10:35,689
organizations work they love monoculture

00:10:33,980 --> 00:10:37,519
because it makes their lives easier if

00:10:35,689 --> 00:10:39,649
everybody's running the exact same

00:10:37,519 --> 00:10:42,139
software everywhere it makes it easy to

00:10:39,649 --> 00:10:44,569
automatically deploy patches it makes it

00:10:42,139 --> 00:10:47,179
easy to do code verification and it

00:10:44,569 --> 00:10:49,100
makes debugging easier and this is why

00:10:47,179 --> 00:10:51,470
actually the aslr has been a

00:10:49,100 --> 00:10:54,049
successfully deployed it's because it

00:10:51,470 --> 00:10:56,079
works within this structure it allows

00:10:54,049 --> 00:10:57,800
you to keep all of the benefits of

00:10:56,079 --> 00:10:59,930
monoculture at

00:10:57,800 --> 00:11:02,360
just a little bit of load latency and it

00:10:59,930 --> 00:11:05,870
takes place almost entirely on the user

00:11:02,360 --> 00:11:08,570
system so there's no overhead put on to

00:11:05,870 --> 00:11:13,100
the vendor to use it so everything is

00:11:08,570 --> 00:11:15,350
kind of business as usual so the

00:11:13,100 --> 00:11:17,300
question is can we do any better given

00:11:15,350 --> 00:11:19,339
these restraints and we're obviously not

00:11:17,300 --> 00:11:22,450
going to rototill the software ecosystem

00:11:19,339 --> 00:11:24,769
in order to add randomization so

00:11:22,450 --> 00:11:27,589
obviously I think the answer is yes

00:11:24,769 --> 00:11:29,930
otherwise I wouldn't be here today but I

00:11:27,589 --> 00:11:32,149
just would like to caution you guys this

00:11:29,930 --> 00:11:35,120
is a work in progress it's going to be a

00:11:32,149 --> 00:11:38,089
really long road to get to the final end

00:11:35,120 --> 00:11:39,740
point and I want to make sure that you

00:11:38,089 --> 00:11:44,390
understand that we're trying to work

00:11:39,740 --> 00:11:46,010
incrementally here so when I started

00:11:44,390 --> 00:11:47,750
looking at how can we do better with

00:11:46,010 --> 00:11:51,560
randomization the first question I have

00:11:47,750 --> 00:11:53,990
to ask myself is when to randomize so if

00:11:51,560 --> 00:11:56,570
we stick just like a SLR does with a

00:11:53,990 --> 00:11:58,670
load time randomization this is really

00:11:56,570 --> 00:12:00,769
still very practical and a good decision

00:11:58,670 --> 00:12:02,209
because it allows the vendors to

00:12:00,769 --> 00:12:04,600
continue to let use its existing

00:12:02,209 --> 00:12:07,910
distribution and code signing methods

00:12:04,600 --> 00:12:09,620
without any kind of modification the

00:12:07,910 --> 00:12:11,570
other thing that we can do which is very

00:12:09,620 --> 00:12:14,690
interesting is we can do kind of a

00:12:11,570 --> 00:12:17,480
hybrid system where we add some metadata

00:12:14,690 --> 00:12:20,209
at build time but defer the actual

00:12:17,480 --> 00:12:21,589
randomization until load time so I'll

00:12:20,209 --> 00:12:26,300
show you what that looks like as we get

00:12:21,589 --> 00:12:28,910
a little further along so the next

00:12:26,300 --> 00:12:31,490
question that asked is what level of

00:12:28,910 --> 00:12:33,740
randomization are we going to do well it

00:12:31,490 --> 00:12:35,329
looks very enticing to try to go for

00:12:33,740 --> 00:12:37,060
some of the lower level randomizations

00:12:35,329 --> 00:12:39,980
because obviously they have better

00:12:37,060 --> 00:12:43,760
entropy the fact is if we sort of stick

00:12:39,980 --> 00:12:47,600
with our plan of how not to ruin

00:12:43,760 --> 00:12:50,060
everything right away it makes a lot of

00:12:47,600 --> 00:12:52,520
sense to stick with program level

00:12:50,060 --> 00:12:54,589
randomization and the nice thing about

00:12:52,520 --> 00:12:57,100
this is that we can layer what we're

00:12:54,589 --> 00:12:59,570
doing on top of existing base address of

00:12:57,100 --> 00:13:01,550
randomization so everything continues to

00:12:59,570 --> 00:13:03,529
work as it is and now we have sort of

00:13:01,550 --> 00:13:07,010
two layers of support instead of just

00:13:03,529 --> 00:13:09,110
one so I chose function reordering

00:13:07,010 --> 00:13:11,360
because conceptually it's very easy to

00:13:09,110 --> 00:13:13,880
understand it doesn't cause though it's

00:13:11,360 --> 00:13:19,340
not very intrusive and it's something

00:13:13,880 --> 00:13:22,370
that we can do as a first step so the

00:13:19,340 --> 00:13:24,980
last decision I made was was really an

00:13:22,370 --> 00:13:26,660
efforts to keep this small so I decided

00:13:24,980 --> 00:13:29,300
to try to implement fine-grain

00:13:26,660 --> 00:13:31,550
randomization four modules as a first

00:13:29,300 --> 00:13:33,680
step and the reason I did that is

00:13:31,550 --> 00:13:36,320
because initially it's going to be a lot

00:13:33,680 --> 00:13:39,050
less work it's also going to allow us to

00:13:36,320 --> 00:13:42,200
constrain the changes that we make to

00:13:39,050 --> 00:13:45,050
individual make files and that way we

00:13:42,200 --> 00:13:47,150
can sort of gradually add modules in as

00:13:45,050 --> 00:13:49,400
we prove that this as people get more

00:13:47,150 --> 00:13:51,770
comfortable with the feature the nice

00:13:49,400 --> 00:13:54,830
thing is that GCC actually already has

00:13:51,770 --> 00:13:57,110
support for a flag that will allow us to

00:13:54,830 --> 00:13:59,330
capture the metadata at compile time

00:13:57,110 --> 00:14:01,730
that we can then use at load time in

00:13:59,330 --> 00:14:04,640
order to do our randomization and this

00:14:01,730 --> 00:14:07,460
is the dash F function sections flag so

00:14:04,640 --> 00:14:10,850
if I go to my module make file all I

00:14:07,460 --> 00:14:12,950
have to do is at this C flag dash F

00:14:10,850 --> 00:14:15,620
function sections and now suddenly all

00:14:12,950 --> 00:14:17,800
of my metadata gets generated for me and

00:14:15,620 --> 00:14:21,980
the reason that that works is because

00:14:17,800 --> 00:14:24,680
modules are already relocatable objects

00:14:21,980 --> 00:14:27,380
they're not executable formats so they

00:14:24,680 --> 00:14:30,040
are going to retain the metadata that is

00:14:27,380 --> 00:14:32,510
generated through this function flag

00:14:30,040 --> 00:14:35,210
they are linked into the they're

00:14:32,510 --> 00:14:40,580
basically linked on the fly whenever you

00:14:35,210 --> 00:14:42,680
load a module into the kernel so what

00:14:40,580 --> 00:14:46,150
does this look like so on the left side

00:14:42,680 --> 00:14:50,450
is our relocation relocatable format

00:14:46,150 --> 00:14:52,880
this is basically a lot like the

00:14:50,450 --> 00:14:54,530
execution the executable format except

00:14:52,880 --> 00:14:57,050
it adds a little extra section in there

00:14:54,530 --> 00:14:59,180
which is called the relocation section

00:14:57,050 --> 00:15:00,950
and you can see on the Left I've

00:14:59,180 --> 00:15:02,300
indicated there's one for the text

00:15:00,950 --> 00:15:05,390
section you get one for your data

00:15:02,300 --> 00:15:08,540
section and what it looks like when you

00:15:05,390 --> 00:15:10,940
apply this flag is basically GCC will

00:15:08,540 --> 00:15:12,680
break your text section up into

00:15:10,940 --> 00:15:14,810
individual functions so now you'll have

00:15:12,680 --> 00:15:16,760
multiple text sections so you can see

00:15:14,810 --> 00:15:18,800
here in my example I've got two

00:15:16,760 --> 00:15:21,529
functions each function is broke

00:15:18,800 --> 00:15:23,480
helped into its own section and one of

00:15:21,529 --> 00:15:26,230
those has its own relocation section

00:15:23,480 --> 00:15:26,230
assigned to it

00:15:26,649 --> 00:15:31,610
so I got a simple module example just to

00:15:30,019 --> 00:15:34,760
walk through this and make it a little

00:15:31,610 --> 00:15:37,279
bit more concrete here I have I have a

00:15:34,760 --> 00:15:39,560
module that's got three functions one of

00:15:37,279 --> 00:15:42,140
them is an init function but there's two

00:15:39,560 --> 00:15:44,079
that are going to exist at runtime the

00:15:42,140 --> 00:15:50,209
first the test module where Q function

00:15:44,079 --> 00:15:53,060
refers to the one up top and so I had to

00:15:50,209 --> 00:15:55,100
make make it because my test module is

00:15:53,060 --> 00:15:56,630
so stupid I had to tell the compiler not

00:15:55,100 --> 00:16:02,600
topped my zit out so that's what that

00:15:56,630 --> 00:16:04,640
messes but anyway so when I've compiled

00:16:02,600 --> 00:16:07,010
what I've done is I've compiled the text

00:16:04,640 --> 00:16:09,019
module I mean the test module and we're

00:16:07,010 --> 00:16:10,970
looking at it with read elf we've told

00:16:09,019 --> 00:16:12,980
read elf just show us the sections and

00:16:10,970 --> 00:16:15,500
I've just cut out the text sections for

00:16:12,980 --> 00:16:17,810
you so what you can see is that there's

00:16:15,500 --> 00:16:21,709
now three text sections and the main

00:16:17,810 --> 00:16:24,560
text section there is got a size of zero

00:16:21,709 --> 00:16:26,300
because there's nothing in it all of the

00:16:24,560 --> 00:16:30,200
all of the code has been broken out into

00:16:26,300 --> 00:16:33,260
individual sections and then again if

00:16:30,200 --> 00:16:35,570
you look into the relocation section for

00:16:33,260 --> 00:16:37,640
the test module work queue function you

00:16:35,570 --> 00:16:40,190
can see that it's referencing a symbol

00:16:37,640 --> 00:16:43,160
in the other text section test module do

00:16:40,190 --> 00:16:46,190
work and that it helpfully like gives

00:16:43,160 --> 00:16:52,730
its own symbol index and in references

00:16:46,190 --> 00:16:54,649
it by the text section name so I just

00:16:52,730 --> 00:16:58,430
want to give you a sort of a quick

00:16:54,649 --> 00:17:00,620
refresher on how relocations work the

00:16:58,430 --> 00:17:02,899
correct address of a symbol needs to be

00:17:00,620 --> 00:17:06,439
updated whenever you actually place the

00:17:02,899 --> 00:17:08,870
code into memory and so the relocation

00:17:06,439 --> 00:17:10,189
section what that is included in the elf

00:17:08,870 --> 00:17:12,589
file is really just going to show you

00:17:10,189 --> 00:17:14,240
the offset of where to make the change

00:17:12,589 --> 00:17:17,120
and the name of the symbol whose address

00:17:14,240 --> 00:17:20,120
you need to update so in modules this

00:17:17,120 --> 00:17:22,250
happens at load time at compile time at

00:17:20,120 --> 00:17:24,679
what happens is that is we wind up with

00:17:22,250 --> 00:17:27,050
this is using obj don't to just look at

00:17:24,679 --> 00:17:28,890
the file you can see that my address of

00:17:27,050 --> 00:17:31,470
this symbol is all zeros

00:17:28,890 --> 00:17:33,809
and and what we're going to do at load

00:17:31,470 --> 00:17:35,820
time in the module code is then replaced

00:17:33,809 --> 00:17:37,890
that with the correct address where we

00:17:35,820 --> 00:17:40,160
placed our new section so you can easily

00:17:37,890 --> 00:17:42,570
see that we can move our functions

00:17:40,160 --> 00:17:44,340
anywhere and as long as we know where

00:17:42,570 --> 00:17:49,080
they are we can then go into our

00:17:44,340 --> 00:17:52,020
relocation so when you're compiling with

00:17:49,080 --> 00:17:53,610
function sections the symbol table which

00:17:52,020 --> 00:17:55,950
is where all of the symbols are kept

00:17:53,610 --> 00:17:58,740
just references the individual section

00:17:55,950 --> 00:18:00,660
so where the functions are located so

00:17:58,740 --> 00:18:02,820
they again this is just to show you that

00:18:00,660 --> 00:18:04,620
they can really be anywhere and we don't

00:18:02,820 --> 00:18:06,330
have to change anything about how we're

00:18:04,620 --> 00:18:10,500
doing me locations in the kernel because

00:18:06,330 --> 00:18:12,540
it all just works so when you load a

00:18:10,500 --> 00:18:15,030
module into memory this is kind of what

00:18:12,540 --> 00:18:16,890
it looks like you have two main sections

00:18:15,030 --> 00:18:19,710
there's a core section and there's an

00:18:16,890 --> 00:18:22,230
init section the init section is thrown

00:18:19,710 --> 00:18:24,419
out after we call module in it and the

00:18:22,230 --> 00:18:27,510
core section is the section that lives

00:18:24,419 --> 00:18:29,940
on in the kernel so your executable code

00:18:27,510 --> 00:18:32,700
that's not marked by an it is located in

00:18:29,940 --> 00:18:35,940
the core section and it's at the top and

00:18:32,700 --> 00:18:37,530
all in one section we collect mostly

00:18:35,940 --> 00:18:39,630
text but there's some miscellaneous

00:18:37,530 --> 00:18:42,330
other sections that are also executable

00:18:39,630 --> 00:18:44,610
that are stuck in there and for for my

00:18:42,330 --> 00:18:47,940
purposes I'm going to treat them exactly

00:18:44,610 --> 00:18:50,340
like the text section so we can apply

00:18:47,940 --> 00:18:54,540
our randomization to the executable

00:18:50,340 --> 00:18:57,330
section so that rather than have a text

00:18:54,540 --> 00:18:59,700
section that is predictable we can add

00:18:57,330 --> 00:19:01,830
some entropy to it so after we apply

00:18:59,700 --> 00:19:03,780
randomization to this it could look

00:19:01,830 --> 00:19:05,370
something like this if you have a whole

00:19:03,780 --> 00:19:08,130
bunch of functions you know they're

00:19:05,370 --> 00:19:13,169
basically randomized within that one

00:19:08,130 --> 00:19:15,710
section okay so you're probably

00:19:13,169 --> 00:19:20,490
wondering how effective is this really

00:19:15,710 --> 00:19:23,610
well it depends obviously if you have a

00:19:20,490 --> 00:19:25,559
two function test module you're not

00:19:23,610 --> 00:19:29,820
going to get a lot of entropy out of

00:19:25,559 --> 00:19:32,160
this however most function most modules

00:19:29,820 --> 00:19:35,620
that don't have that few a number of

00:19:32,160 --> 00:19:39,140
functions and like I mentioned

00:19:35,620 --> 00:19:42,740
modules are really not the end goal this

00:19:39,140 --> 00:19:44,900
is a way of proving the technology in a

00:19:42,740 --> 00:19:48,590
way that's controlled and making tiny

00:19:44,900 --> 00:19:50,810
steps so we can do it on the on modules

00:19:48,590 --> 00:19:53,360
even though modules isn't exactly where

00:19:50,810 --> 00:19:56,000
we want to be but the good news is that

00:19:53,360 --> 00:19:57,860
we can expand this over x Engine in

00:19:56,000 --> 00:20:00,290
general so we may start with function

00:19:57,860 --> 00:20:02,360
reordering and then eventually as time

00:20:00,290 --> 00:20:04,940
goes on we could add something like

00:20:02,360 --> 00:20:06,710
basic block reordering there's no reason

00:20:04,940 --> 00:20:08,980
why they can't layer on top of each

00:20:06,710 --> 00:20:08,980
other

00:20:09,340 --> 00:20:17,450
so let's take a look at our monoculture

00:20:12,650 --> 00:20:21,350
benefits when we're talking about this

00:20:17,450 --> 00:20:23,630
this proposal we continue to have ease

00:20:21,350 --> 00:20:26,750
of distribution the vendor doesn't have

00:20:23,630 --> 00:20:31,370
to have any overhead we can continue to

00:20:26,750 --> 00:20:33,560
use code signing there probably will be

00:20:31,370 --> 00:20:38,090
load in runtime overhead of the

00:20:33,560 --> 00:20:41,390
diversified binaries we're going to have

00:20:38,090 --> 00:20:44,480
probably some changes to make how we do

00:20:41,390 --> 00:20:46,520
debugging and error reporting and I

00:20:44,480 --> 00:20:48,560
think that tracing and live patching

00:20:46,520 --> 00:20:51,290
will still work but it's going to

00:20:48,560 --> 00:20:53,630
require some work I think that what we

00:20:51,290 --> 00:20:55,700
can do is find a way to make our

00:20:53,630 --> 00:20:58,520
randomization repeatable by saving the

00:20:55,700 --> 00:21:00,440
seed or something like that so how will

00:20:58,520 --> 00:21:02,960
this work when we start going where we

00:21:00,440 --> 00:21:06,860
really want to go which is to the kernel

00:21:02,960 --> 00:21:09,590
text I think what we need to do is the

00:21:06,860 --> 00:21:12,200
the issue with the kernel text is kernel

00:21:09,590 --> 00:21:14,060
is not the kernel is not a relocatable

00:21:12,200 --> 00:21:15,530
format the compiler is going to throw

00:21:14,060 --> 00:21:18,530
out all of that nice function

00:21:15,530 --> 00:21:20,300
information and when it generates the

00:21:18,530 --> 00:21:23,270
final image so what we're going to have

00:21:20,300 --> 00:21:25,940
to do is either write a plug-in that

00:21:23,270 --> 00:21:29,720
will capture that metadata and store it

00:21:25,940 --> 00:21:31,490
into yet another special section or we

00:21:29,720 --> 00:21:34,280
can wrap we can also write a linker

00:21:31,490 --> 00:21:36,380
around a link wrapper around the linker

00:21:34,280 --> 00:21:38,420
or something to capture that metadata

00:21:36,380 --> 00:21:41,210
before it gets thrown out the good news

00:21:38,420 --> 00:21:42,950
is is that this method is actually not

00:21:41,210 --> 00:21:44,360
something that I invented

00:21:42,950 --> 00:21:48,470
and it's something that's been deployed

00:21:44,360 --> 00:21:50,720
in the wild in a somewhat complex piece

00:21:48,470 --> 00:21:54,200
of software and that is with the tor

00:21:50,720 --> 00:21:57,020
browser and there's was a project called

00:21:54,200 --> 00:22:00,050
self Rando that one of the academic

00:21:57,020 --> 00:22:02,450
researches made and tor actually

00:22:00,050 --> 00:22:04,670
integrated it into their system in the

00:22:02,450 --> 00:22:07,190
way that it works is they do function

00:22:04,670 --> 00:22:09,290
reordering exactly like this they write

00:22:07,190 --> 00:22:11,240
they have a little runtime binary that

00:22:09,290 --> 00:22:13,250
they use to sort of capture the start

00:22:11,240 --> 00:22:15,740
point of the program and that's when

00:22:13,250 --> 00:22:17,390
they do their their loader modifications

00:22:15,740 --> 00:22:19,580
that they need to do in order to apply

00:22:17,390 --> 00:22:21,140
the randomization we won't of course

00:22:19,580 --> 00:22:23,420
have to do that since we already have a

00:22:21,140 --> 00:22:26,510
loader in the kernel and all we really

00:22:23,420 --> 00:22:29,420
need to do is tack on the extra metadata

00:22:26,510 --> 00:22:31,610
and that that we need in order to make

00:22:29,420 --> 00:22:34,370
sure we understand where the start and

00:22:31,610 --> 00:22:35,990
end of all the functions are so I think

00:22:34,370 --> 00:22:41,960
it's doable it's just something that

00:22:35,990 --> 00:22:44,330
we're I'm deferring until later so at

00:22:41,960 --> 00:22:46,700
this point you might be stark snarky and

00:22:44,330 --> 00:22:48,350
you're thinking to yourself well fine

00:22:46,700 --> 00:22:51,530
grain randomization is completely

00:22:48,350 --> 00:22:56,330
useless because JIT Rob how many people

00:22:51,530 --> 00:22:57,740
know what JIT rotted Rob is if you so

00:22:56,330 --> 00:23:00,500
I'll tell you what it means it means

00:22:57,740 --> 00:23:02,930
that rather than build your attack

00:23:00,500 --> 00:23:05,620
offline in the comfort of your own home

00:23:02,930 --> 00:23:09,230
when you know where the the layout of

00:23:05,620 --> 00:23:11,600
your text section is you can actually go

00:23:09,230 --> 00:23:15,920
out and download a helpful framework to

00:23:11,600 --> 00:23:17,780
generate gadgets on the fly so this is

00:23:15,920 --> 00:23:21,320
something where it really doesn't matter

00:23:17,780 --> 00:23:24,380
how much randomization you get if you

00:23:21,320 --> 00:23:26,840
find an address for a single a single

00:23:24,380 --> 00:23:29,090
address you can then have access to an

00:23:26,840 --> 00:23:32,870
entire page of gadgets that you can use

00:23:29,090 --> 00:23:36,680
to now construct your exploit luckily

00:23:32,870 --> 00:23:39,110
with this we can actually combine what

00:23:36,680 --> 00:23:41,510
we're doing with execute only memory in

00:23:39,110 --> 00:23:44,300
order to make a much stronger defense so

00:23:41,510 --> 00:23:49,130
execute only memory allows us to mark

00:23:44,300 --> 00:23:50,480
the code section as non readable and now

00:23:49,130 --> 00:23:52,640
some of you are thinking but hey you

00:23:50,480 --> 00:23:57,260
can't do that on X 80

00:23:52,640 --> 00:24:00,500
six but haha that's not true you can do

00:23:57,260 --> 00:24:04,220
this on x86 in a certain way you can do

00:24:00,500 --> 00:24:07,220
it in a guest so we have right now the

00:24:04,220 --> 00:24:10,250
issue is is that page tables have bits

00:24:07,220 --> 00:24:13,730
for present right and no execute but you

00:24:10,250 --> 00:24:16,640
can't simultaneously have right a little

00:24:13,730 --> 00:24:20,060
bit unreadable you can have writable yes

00:24:16,640 --> 00:24:22,970
but the extended page tables will allow

00:24:20,060 --> 00:24:25,370
you to have separate bits and so it lets

00:24:22,970 --> 00:24:28,070
you represent what we need to do there's

00:24:25,370 --> 00:24:30,490
a lot of complications now to this not

00:24:28,070 --> 00:24:33,260
the least of which is that there's

00:24:30,490 --> 00:24:35,660
bunching pointers and data there's

00:24:33,260 --> 00:24:39,110
probably going to be data in the text

00:24:35,660 --> 00:24:43,670
section that exists so marking that as

00:24:39,110 --> 00:24:45,680
as is going to be hard and also we might

00:24:43,670 --> 00:24:47,330
have to provide a way to turn it on and

00:24:45,680 --> 00:24:50,210
off in order to enable things like K

00:24:47,330 --> 00:24:51,860
probes to continue to work but we're

00:24:50,210 --> 00:24:54,350
pretty sure this is a solvable problem

00:24:51,860 --> 00:24:56,930
and we're working on this in combination

00:24:54,350 --> 00:24:59,600
with fine grained randomization to have

00:24:56,930 --> 00:25:06,770
a really pretty good story on code reuse

00:24:59,600 --> 00:25:09,680
prevention for guests so here are a few

00:25:06,770 --> 00:25:11,960
resources if you're interested I only

00:25:09,680 --> 00:25:13,640
listed like five papers that I thought

00:25:11,960 --> 00:25:17,140
were really interesting there's like a

00:25:13,640 --> 00:25:20,150
zillion if you go google them all in

00:25:17,140 --> 00:25:22,070
particular if you could look at the self

00:25:20,150 --> 00:25:24,380
randall one that's that's the one and

00:25:22,070 --> 00:25:25,430
unfortunately I think I didn't oh yeah

00:25:24,380 --> 00:25:28,550
there it is so Ferrando

00:25:25,430 --> 00:25:30,410
that's the best one well it best by my

00:25:28,550 --> 00:25:32,090
definition meaning most practical thing

00:25:30,410 --> 00:25:34,460
I could imagine being deployed anywhere

00:25:32,090 --> 00:25:37,520
I also have a POC

00:25:34,460 --> 00:25:40,670
which works by some definition of work

00:25:37,520 --> 00:25:44,540
right now I can load a module it

00:25:40,670 --> 00:25:49,760
randomizes it doesn't it doesn't hang

00:25:44,540 --> 00:25:52,970
with doing nothing it's still under

00:25:49,760 --> 00:25:56,090
development the most the things that are

00:25:52,970 --> 00:25:59,450
missing from it are mainly the ability

00:25:56,090 --> 00:26:00,390
to consistent to sort of predictably

00:25:59,450 --> 00:26:01,980
randomize if

00:26:00,390 --> 00:26:04,650
know what I mean in order for us to

00:26:01,980 --> 00:26:06,690
start this starts making live patching

00:26:04,650 --> 00:26:08,340
work so there's still a lot of work to

00:26:06,690 --> 00:26:10,410
do but if you want to take a look it's

00:26:08,340 --> 00:26:13,140
surprisingly little code to make this

00:26:10,410 --> 00:26:14,880
work and I think that the amount of code

00:26:13,140 --> 00:26:17,370
that I had to write in order to get this

00:26:14,880 --> 00:26:17,880
to work with maybe less than 30 lines of

00:26:17,370 --> 00:26:22,520
code

00:26:17,880 --> 00:26:22,520
so it's very simple and straightforward

00:26:23,690 --> 00:26:36,630
so I have left time for questions if

00:26:28,020 --> 00:26:39,690
anybody has any hi my question is if we

00:26:36,630 --> 00:26:43,710
are going to save the seat in order to

00:26:39,690 --> 00:26:46,080
be able to debug if I get the seed of a

00:26:43,710 --> 00:26:48,530
side channel attack which we know they

00:26:46,080 --> 00:26:48,530
exist

00:26:48,750 --> 00:26:55,980
what will stop me - yeah nothing if you

00:26:54,090 --> 00:26:58,410
get the seed that's the end of that I

00:26:55,980 --> 00:27:00,030
mean it's sort of like the other thing

00:26:58,410 --> 00:27:02,220
that you have to think about is the

00:27:00,030 --> 00:27:04,170
symbol table right I mean if you get the

00:27:02,220 --> 00:27:07,200
symbol table you get everything - now

00:27:04,170 --> 00:27:08,820
you get your new nice layout so there's

00:27:07,200 --> 00:27:10,890
going to be a lot of things we're going

00:27:08,820 --> 00:27:12,690
to have to protect I think that we can

00:27:10,890 --> 00:27:14,760
look at strategies for how to keep the

00:27:12,690 --> 00:27:16,770
seeds safe for example maybe we could

00:27:14,760 --> 00:27:19,560
put it in the TPM or something like that

00:27:16,770 --> 00:27:21,090
so you know obviously the seed is going

00:27:19,560 --> 00:27:23,280
to be a precious thing that we're going

00:27:21,090 --> 00:27:26,370
to have to keep secret okay my other

00:27:23,280 --> 00:27:29,340
question is usually I'm not worried

00:27:26,370 --> 00:27:31,530
about that someone will steal my text

00:27:29,340 --> 00:27:34,520
sections I'm worried about that someone

00:27:31,530 --> 00:27:37,710
will steal my historic secrets in memory

00:27:34,520 --> 00:27:40,440
here what you're mice might start

00:27:37,710 --> 00:27:43,410
secretly for example Oh your data you're

00:27:40,440 --> 00:27:47,370
worried about your data yeah that's a

00:27:43,410 --> 00:27:48,990
different problem to solve for sure so I

00:27:47,370 --> 00:27:50,940
know that Intel's been working on CED

00:27:48,990 --> 00:27:53,480
the spec has been out for some time now

00:27:50,940 --> 00:27:56,100
control execution

00:27:53,480 --> 00:27:57,990
forget the what C D stands for but I

00:27:56,100 --> 00:27:58,530
think the idea is to prevent drop-in

00:27:57,990 --> 00:28:01,560
hardware

00:27:58,530 --> 00:28:04,710
by preventing where you can jump to or

00:28:01,560 --> 00:28:06,300
jump from so is this so the technology

00:28:04,710 --> 00:28:08,160
you're talking about is likely to apply

00:28:06,300 --> 00:28:10,590
only to the current generation of

00:28:08,160 --> 00:28:14,250
process I guess going forward CET would

00:28:10,590 --> 00:28:17,940
be the way to prevent drop so there's I

00:28:14,250 --> 00:28:21,570
think that CET and other control flow

00:28:17,940 --> 00:28:24,470
technologies are in some sense solving a

00:28:21,570 --> 00:28:27,270
different problem and they can be used

00:28:24,470 --> 00:28:29,430
complementary I think it remains to be

00:28:27,270 --> 00:28:31,290
seen whether all aspects of control flow

00:28:29,430 --> 00:28:33,270
technology would work with this I I'm

00:28:31,290 --> 00:28:36,600
not sure enough about whether the shadow

00:28:33,270 --> 00:28:40,080
stock stuff would still work but I think

00:28:36,600 --> 00:28:45,360
it would so I think that they would they

00:28:40,080 --> 00:28:48,240
would they be complementary thanks for

00:28:45,360 --> 00:28:50,640
the talk I can easily see is preventing

00:28:48,240 --> 00:28:53,010
like victim to leap C or return-oriented

00:28:50,640 --> 00:28:54,600
programming kind attacks but since you

00:28:53,010 --> 00:28:56,720
mentioned insider attacks I was

00:28:54,600 --> 00:28:58,800
wondering whether you have some specific

00:28:56,720 --> 00:29:01,080
microarchitecture of architecture about

00:28:58,800 --> 00:29:02,790
Berlin ability thank you a second I can

00:29:01,080 --> 00:29:05,700
prevent suicide channels own of

00:29:02,790 --> 00:29:07,950
themselves aren't attacks they're their

00:29:05,700 --> 00:29:11,070
info leaks so think of them like that

00:29:07,950 --> 00:29:13,080
and if you think of them like that then

00:29:11,070 --> 00:29:17,430
you can see that although of course we

00:29:13,080 --> 00:29:19,230
want to stop info leaks you can also do

00:29:17,430 --> 00:29:21,390
hardening against the exploits that

00:29:19,230 --> 00:29:25,340
people build on top of side channels and

00:29:21,390 --> 00:29:25,340
so that's what this proposal is doing

00:29:25,790 --> 00:29:30,780
the applying this to the kernel has been

00:29:29,460 --> 00:29:32,490
resisted in the past because of

00:29:30,780 --> 00:29:34,050
performance it's pretty highly tuned

00:29:32,490 --> 00:29:36,300
particularly that structure

00:29:34,050 --> 00:29:39,960
randomization stuff which blows cache

00:29:36,300 --> 00:29:43,650
lines and all kinds of things I have

00:29:39,960 --> 00:29:45,420
thought about this and and and this is

00:29:43,650 --> 00:29:47,460
why I really like doing function

00:29:45,420 --> 00:29:50,640
reordering is because you can apply it

00:29:47,460 --> 00:29:52,680
to certain sections of the kernel and

00:29:50,640 --> 00:29:54,840
not to others like there's no reason why

00:29:52,680 --> 00:29:56,640
you can't have a text section that

00:29:54,840 --> 00:29:59,130
continues to exist that isn't a zero

00:29:56,640 --> 00:30:00,840
size like in the example I gave you it

00:29:59,130 --> 00:30:03,570
was completely eliminated but it doesn't

00:30:00,840 --> 00:30:05,340
have to be and so what we can do is we

00:30:03,570 --> 00:30:06,340
can sort of chip away at the code that

00:30:05,340 --> 00:30:07,840
we randomized

00:30:06,340 --> 00:30:09,779
but we don't have to do it all at once

00:30:07,840 --> 00:30:13,510
we can do it a little bit at a time and

00:30:09,779 --> 00:30:15,130
I think that if you find if we find some

00:30:13,510 --> 00:30:18,279
code in there that really relies on

00:30:15,130 --> 00:30:20,679
either you know cache cache line

00:30:18,279 --> 00:30:23,620
alignment or locality then we can

00:30:20,679 --> 00:30:25,510
address it individually but in general

00:30:23,620 --> 00:30:27,309
like when you think about how they lay

00:30:25,510 --> 00:30:29,830
out a text section the only thing that's

00:30:27,309 --> 00:30:32,860
really guaranteed to be a page line is

00:30:29,830 --> 00:30:35,559
is kind of like the function that exists

00:30:32,860 --> 00:30:37,510
at the top of the page so that was

00:30:35,559 --> 00:30:39,070
another question packing I mean yeah

00:30:37,510 --> 00:30:40,570
you're not gonna be quite as tightly

00:30:39,070 --> 00:30:44,559
packed as it might have been in the

00:30:40,570 --> 00:30:47,080
object well in the in the algorithm that

00:30:44,559 --> 00:30:49,480
I'm using today I actually used the

00:30:47,080 --> 00:30:52,809
exact same amount of space as what was

00:30:49,480 --> 00:30:55,419
used before so it doesn't it doesn't

00:30:52,809 --> 00:30:57,909
increase anything in memory it does

00:30:55,419 --> 00:31:00,100
increase the footprint of the file

00:30:57,909 --> 00:31:03,399
because you're now adding metadata to

00:31:00,100 --> 00:31:06,870
the binary but as far as memory

00:31:03,399 --> 00:31:06,870
footprint it doesn't change it

00:31:13,270 --> 00:31:18,380
so yeah it was also the question of your

00:31:16,490 --> 00:31:21,260
performance but about debugging how the

00:31:18,380 --> 00:31:24,500
symbols its you have any plan for fixing

00:31:21,260 --> 00:31:25,940
the disturbance that it's going to

00:31:24,500 --> 00:31:28,520
generate these in terms of debugging

00:31:25,940 --> 00:31:30,679
once we have that so my thought the the

00:31:28,520 --> 00:31:33,410
way that the self Rando project

00:31:30,679 --> 00:31:36,410
addressed this was by writing basically

00:31:33,410 --> 00:31:38,030
a wrapper around the error recording

00:31:36,410 --> 00:31:40,490
tool that they were using for the tor

00:31:38,030 --> 00:31:42,860
browser in order to basically D

00:31:40,490 --> 00:31:45,289
randomize before generating the report

00:31:42,860 --> 00:31:47,809
that's something that we can do inside

00:31:45,289 --> 00:31:49,970
the kernel I'm not I haven't convinced

00:31:47,809 --> 00:31:52,340
myself that I actually need to do this I

00:31:49,970 --> 00:31:54,289
need to take a look at you know how do

00:31:52,340 --> 00:31:56,000
people even look at this because for

00:31:54,289 --> 00:31:58,880
example take a look at a stack dump

00:31:56,000 --> 00:32:02,179
today the part that would be really

00:31:58,880 --> 00:32:04,130
messed up I think is you know you get a

00:32:02,179 --> 00:32:07,190
stacked on that the address isn't in

00:32:04,130 --> 00:32:09,440
your it isn't in your symbol table it

00:32:07,190 --> 00:32:11,270
tries to guess where it thinks that it

00:32:09,440 --> 00:32:12,919
might be I think and you see that

00:32:11,270 --> 00:32:14,510
reference does you know question mark

00:32:12,919 --> 00:32:16,820
question mark question mark you know

00:32:14,510 --> 00:32:20,390
symbol name I think those are going to

00:32:16,820 --> 00:32:22,220
be all bogus and wrong but it's I think

00:32:20,390 --> 00:32:24,620
this is a solvable problem especially if

00:32:22,220 --> 00:32:27,230
the seed is saved somewhere we should be

00:32:24,620 --> 00:32:30,370
able to de randomized before we spit out

00:32:27,230 --> 00:32:30,370
any debug info

00:32:40,409 --> 00:32:49,239
all right thank you very much

00:32:43,440 --> 00:32:49,239

YouTube URL: https://www.youtube.com/watch?v=YhlJuFPMBuI


