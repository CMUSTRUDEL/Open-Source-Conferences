Title: LPC2018 - Untrusted File systems
Publication date: 2018-12-04
Playlist: LPC2018 - LPC Main Track
Description: 
	url:  https://linuxplumbersconf.org/event/2/contributions/67/
speaker:  Eric Biederman


Plugging in USB sticks, building VM images, and unprivileged containers all give rise to a situation where users are mounting and dealing with filesystem images they have not built themselves, and don't necessarily want to trust.

This leads to the problem of how to mount and read/write those filesystems without opening yourself up to more risk than visiting a web page.

I will survey what has been built already, describe what the technical challenges and describe the problems ahead.

With this talk I hope to unite the various groups across the linux ecosystem that care about this problem and get the discussion started on how we can move forward.
Captions: 
	00:00:05,570 --> 00:00:14,480
I I'm here here today to talk to you

00:00:08,660 --> 00:00:16,700
guys about a problem and I don't think

00:00:14,480 --> 00:00:21,500
we've solved it yet although I'm certain

00:00:16,700 --> 00:00:24,470
we can the problem is about file system

00:00:21,500 --> 00:00:26,869
images that we get off the internet from

00:00:24,470 --> 00:00:29,119
or from USB sticks or whatever that we

00:00:26,869 --> 00:00:39,980
don't fully trust that someone may have

00:00:29,119 --> 00:00:43,850
been a little bit malicious and so the

00:00:39,980 --> 00:00:45,620
the big Pro yeah well what makes these

00:00:43,850 --> 00:00:51,140
images a problem is if we go and we

00:00:45,620 --> 00:00:52,609
mount them in the kernel and then they

00:00:51,140 --> 00:00:54,980
might cause problems and when you talk

00:00:52,609 --> 00:00:56,239
to a file system developer about dealing

00:00:54,980 --> 00:00:57,859
with the kind of problem someone

00:00:56,239 --> 00:01:00,379
malicious can create a file system

00:00:57,859 --> 00:01:02,510
format they back slowly away from you

00:01:00,379 --> 00:01:03,769
because this is a scary scary difficult

00:01:02,510 --> 00:01:06,220
problem and they don't want to solve it

00:01:03,769 --> 00:01:11,330
they don't want to be responsible for it

00:01:06,220 --> 00:01:13,520
so what we've been doing in Linux with

00:01:11,330 --> 00:01:19,610
automatic file sense and all this stuff

00:01:13,520 --> 00:01:23,150
is really not in the long term a really

00:01:19,610 --> 00:01:25,790
sustainable option file systems are a

00:01:23,150 --> 00:01:28,700
little too complicated for that at least

00:01:25,790 --> 00:01:31,490
using the kernel drivers and we don't

00:01:28,700 --> 00:01:33,320
know how to build a file system you know

00:01:31,490 --> 00:01:35,030
with all the with all our current

00:01:33,320 --> 00:01:39,229
priorities that job needs real best

00:01:35,030 --> 00:01:43,340
against that doing that what we can do

00:01:39,229 --> 00:01:46,600
is move the files before four you know I

00:01:43,340 --> 00:01:49,009
suppose we download for VM images for

00:01:46,600 --> 00:01:51,049
container images for USB sticks what we

00:01:49,009 --> 00:01:53,360
can do is we can run the file system

00:01:51,049 --> 00:01:56,840
drivers in the user space and connect

00:01:53,360 --> 00:01:58,960
them up into the kernel with use that's

00:01:56,840 --> 00:02:01,430
at least a small enough attack surface

00:01:58,960 --> 00:02:07,009
there's a reasonable chance that there

00:02:01,430 --> 00:02:11,730
won't be a kernel bug in it at least not

00:02:07,009 --> 00:02:14,010
not most days so

00:02:11,730 --> 00:02:18,450
you know I you know I've been looking

00:02:14,010 --> 00:02:21,950
for what ways to actually make this

00:02:18,450 --> 00:02:24,780
happen and various pieces the best

00:02:21,950 --> 00:02:27,450
project I've seen out there is Lib guest

00:02:24,780 --> 00:02:29,069
FS that the VM guys are doing I don't

00:02:27,450 --> 00:02:30,510
know quite how complete it is but it

00:02:29,069 --> 00:02:36,750
does have a bunch of the common file

00:02:30,510 --> 00:02:40,079
systems there's a month and it is kind

00:02:36,750 --> 00:02:42,060
of important to reuse at least as a

00:02:40,079 --> 00:02:43,709
fallback file system drivers that are in

00:02:42,060 --> 00:02:46,620
the kernel instead of rewriting the

00:02:43,709 --> 00:02:48,329
fastest drivers because they're about a

00:02:46,620 --> 00:02:49,920
hundred file system drivers in the front

00:02:48,329 --> 00:02:52,109
there are a hundred different file

00:02:49,920 --> 00:02:53,910
system types and while some of them were

00:02:52,109 --> 00:02:55,530
virtual some of them rather you know

00:02:53,910 --> 00:02:57,180
that's a big enough number I don't think

00:02:55,530 --> 00:03:02,549
we're going to replicate them all in

00:02:57,180 --> 00:03:06,470
userspace anytime soon so being able to

00:03:02,549 --> 00:03:11,129
leverage that I think is important but

00:03:06,470 --> 00:03:13,470
so you know there are a few other

00:03:11,129 --> 00:03:16,889
projects out there like okay Linux

00:03:13,470 --> 00:03:18,569
they'll run for links into a library and

00:03:16,889 --> 00:03:21,209
stuff but that doesn't merged upstream

00:03:18,569 --> 00:03:23,160
how well it works I don't you know I

00:03:21,209 --> 00:03:25,380
don't really know but we've got the

00:03:23,160 --> 00:03:28,349
pieces we've got fused we've got ability

00:03:25,380 --> 00:03:29,340
to run file systems in userspace but we

00:03:28,349 --> 00:03:36,329
don't have any of the user space

00:03:29,340 --> 00:03:39,540
plumbing that's the problem and and yeah

00:03:36,329 --> 00:03:41,700
and so yeah I'm here to solicit input

00:03:39,540 --> 00:03:43,980
and see if there's anyone on the user

00:03:41,700 --> 00:03:45,989
space side who's got some ideas on how

00:03:43,980 --> 00:03:49,739
to finish connecting the dots and make

00:03:45,989 --> 00:03:51,690
this work so when I talk to people it's

00:03:49,739 --> 00:03:53,730
like oh yeah we just didn't do this and

00:03:51,690 --> 00:03:55,650
it's not a problem because file system

00:03:53,730 --> 00:03:58,560
drivers user space it's sandbox you

00:03:55,650 --> 00:04:00,959
don't have to worry about those guys

00:03:58,560 --> 00:04:03,750
from that Security Agency I can't tell

00:04:00,959 --> 00:04:05,519
you who they are or or that malicious

00:04:03,750 --> 00:04:10,079
hacker on TV who just dropped a USB

00:04:05,519 --> 00:04:11,190
stick on your pavement outside with and

00:04:10,079 --> 00:04:12,440
you're really looking to see if those

00:04:11,190 --> 00:04:15,769
one of your coworkers

00:04:12,440 --> 00:04:23,190
and you want to give them back to us

00:04:15,769 --> 00:04:25,440
and yeah so at that I'm going to open

00:04:23,190 --> 00:04:32,280
this up for discussion and questions and

00:04:25,440 --> 00:04:34,040
say does anybody have ideas does he um

00:04:32,280 --> 00:04:44,640
does anybody have any questions for me

00:04:34,040 --> 00:04:47,100
yes do you do you want a runtime or a

00:04:44,640 --> 00:04:49,440
compile a compile time compatibility

00:04:47,100 --> 00:04:55,410
because are you actually looking for

00:04:49,440 --> 00:04:58,800
loading the dot k o x f sk o from the

00:04:55,410 --> 00:05:02,130
kernel as compiled from the kernel or or

00:04:58,800 --> 00:05:05,430
is it good enough to take the x FS

00:05:02,130 --> 00:05:12,360
source code and compile it against some

00:05:05,430 --> 00:05:16,200
header and that will make it feel like

00:05:12,360 --> 00:05:19,979
in the kernel okay so what is your goal

00:05:16,200 --> 00:05:22,490
so my goal fundamentally is that

00:05:19,979 --> 00:05:24,930
wherever we get these file systems from

00:05:22,490 --> 00:05:26,790
that we have the tools that we can use

00:05:24,930 --> 00:05:29,760
them and so we don't need to worry about

00:05:26,790 --> 00:05:32,810
it you know I don't think it's

00:05:29,760 --> 00:05:35,180
reasonable to take a kernel object and

00:05:32,810 --> 00:05:38,340
run it in some some place in user space

00:05:35,180 --> 00:05:41,040
you know but I do think it's reasonable

00:05:38,340 --> 00:05:43,140
to like take the UML or something like

00:05:41,040 --> 00:05:46,140
that and running in user space that way

00:05:43,140 --> 00:05:48,419
and I don't know if that's what we wanna

00:05:46,140 --> 00:05:50,010
do for all the file systems but to get

00:05:48,419 --> 00:05:53,070
get the full coverage of all our file

00:05:50,010 --> 00:05:55,050
systems I think that's important so we

00:05:53,070 --> 00:05:57,000
don't so people don't say I'm not going

00:05:55,050 --> 00:05:59,610
to use that because it doesn't support

00:05:57,000 --> 00:06:04,290
this this file system that I care about

00:05:59,610 --> 00:06:05,850
and it's something that out on the Amiga

00:06:04,290 --> 00:06:06,450
at only five guys have taking the time

00:06:05,850 --> 00:06:08,070
to do it

00:06:06,450 --> 00:06:09,960
and so we don't have any other

00:06:08,070 --> 00:06:12,330
implementations except the kernel or

00:06:09,960 --> 00:06:15,240
something like that the UML actually is

00:06:12,330 --> 00:06:17,490
a very good solution

00:06:15,240 --> 00:06:19,560
yes you know the piece we have the

00:06:17,490 --> 00:06:21,600
pieces no one's wired up to plumbing in

00:06:19,560 --> 00:06:25,690
user space and I don't know who that

00:06:21,600 --> 00:06:28,560
needs to be you know I

00:06:25,690 --> 00:06:31,180
I know that there are possibilities so

00:06:28,560 --> 00:06:33,870
I'm hoping at the plumbers conference I

00:06:31,180 --> 00:06:36,970
can find it find people who want what

00:06:33,870 --> 00:06:48,040
Wow I'll help take in the next month

00:06:36,970 --> 00:06:51,760
yeah oh thanks good throw

00:06:48,040 --> 00:06:53,200
so the net VSD guys did something for

00:06:51,760 --> 00:06:57,580
completely different reason which might

00:06:53,200 --> 00:06:59,620
help which is rump kernel I don't know

00:06:57,580 --> 00:07:01,330
if you've heard of that I may have heard

00:06:59,620 --> 00:07:04,090
of it but I don't know anything about it

00:07:01,330 --> 00:07:05,890
they wanted to test their drivers so

00:07:04,090 --> 00:07:08,710
they figured out a way to pull out all

00:07:05,890 --> 00:07:10,540
of their drivers and separate it from

00:07:08,710 --> 00:07:12,070
the kernel and they built like a little

00:07:10,540 --> 00:07:13,960
test framework around it and they called

00:07:12,070 --> 00:07:16,060
it Rumble and then later on they

00:07:13,960 --> 00:07:18,070
realized hey we can just build a whole

00:07:16,060 --> 00:07:20,320
working system on this so they called it

00:07:18,070 --> 00:07:22,840
rump run and they made it like a little

00:07:20,320 --> 00:07:25,540
containerized system which then became

00:07:22,840 --> 00:07:29,080
like a unique kernel but the point is it

00:07:25,540 --> 00:07:32,380
runs Ned BSD drivers unmodified how

00:07:29,080 --> 00:07:34,630
basically in userspace okay yeah and

00:07:32,380 --> 00:07:35,980
they complain the Linux can't do this

00:07:34,630 --> 00:07:36,910
and you'll never be able to do it

00:07:35,980 --> 00:07:39,340
because the Linux kernels too

00:07:36,910 --> 00:07:42,070
complicated not built right but they

00:07:39,340 --> 00:07:44,020
could do it with net bsd well to a

00:07:42,070 --> 00:07:46,120
certain extent we've got UML and there's

00:07:44,020 --> 00:07:48,370
a similar project on the out there

00:07:46,120 --> 00:07:52,990
called lkl Linux although it hasn't been

00:07:48,370 --> 00:07:55,180
merged upstream so you know I yeah

00:07:52,990 --> 00:07:57,130
hearing that the BSD guys do it you know

00:07:55,180 --> 00:07:58,990
I didn't even mind if we read the BSD

00:07:57,130 --> 00:08:00,940
user space to get most of the file

00:07:58,990 --> 00:08:06,040
systems maybe there's files as the BSD

00:08:00,940 --> 00:08:07,300
he's got that we don't but you know but

00:08:06,040 --> 00:08:10,390
right now I want us to get the file

00:08:07,300 --> 00:08:13,000
system so if I get a random image III

00:08:10,390 --> 00:08:15,460
know what to do to use it and everybody

00:08:13,000 --> 00:08:17,260
else does too so they don't get we don't

00:08:15,460 --> 00:08:20,110
have to worry about these security

00:08:17,260 --> 00:08:22,390
issues but ya know that's awful

00:08:20,110 --> 00:08:22,950
so yeah if you could build something

00:08:22,390 --> 00:08:26,730
like

00:08:22,950 --> 00:08:28,590
rump on fuse then you could take all of

00:08:26,730 --> 00:08:30,570
your hundreds of file systems and run it

00:08:28,590 --> 00:08:34,100
in userspace without modifications yeah

00:08:30,570 --> 00:08:42,360
exactly exactly that's what I'm thinking

00:08:34,100 --> 00:08:44,130
you know and I think that I I have some

00:08:42,360 --> 00:08:49,650
technical difficulties with this

00:08:44,130 --> 00:08:51,990
microphone but yeah I yeah I think what

00:08:49,650 --> 00:08:54,900
I saw with lib guest FS it already has a

00:08:51,990 --> 00:08:58,590
UML adapter so we can do something very

00:08:54,900 --> 00:09:02,190
similar today and they've been solving

00:08:58,590 --> 00:09:04,170
it for the VM case but no one's I don't

00:09:02,190 --> 00:09:06,450
think anyone has wired this up to auto

00:09:04,170 --> 00:09:10,080
mounts you know or mounts in your

00:09:06,450 --> 00:09:11,940
desktop and and it certainly isn't well

00:09:10,080 --> 00:09:18,300
known or else people would tell me just

00:09:11,940 --> 00:09:21,870
just use it so I'm trying to understand

00:09:18,300 --> 00:09:23,280
what your threat model is are you trying

00:09:21,870 --> 00:09:25,890
to address the situation that someone

00:09:23,280 --> 00:09:27,810
might have changed the metadata of a

00:09:25,890 --> 00:09:30,330
file system in a malicious way that

00:09:27,810 --> 00:09:33,600
would cause a kernel crash or a break

00:09:30,330 --> 00:09:36,840
privilege or are you concerned about the

00:09:33,600 --> 00:09:40,410
content in the files can you explain in

00:09:36,840 --> 00:09:45,320
more detail what you're okay the threat

00:09:40,410 --> 00:09:48,690
model that I see and I've heard is that

00:09:45,320 --> 00:09:53,910
if you if you maliciously corrupt the

00:09:48,690 --> 00:09:56,010
metadata of a file system then you can

00:09:53,910 --> 00:10:01,350
cause the file system driver to

00:09:56,010 --> 00:10:04,370
misbehave you know one thing I saw not

00:10:01,350 --> 00:10:07,860
too long ago as an example if someone

00:10:04,370 --> 00:10:11,310
Alvaro was reviewing ISO FS and he found

00:10:07,860 --> 00:10:12,930
a case where if the metadata was set up

00:10:11,310 --> 00:10:15,870
in such a way you could cause infinite

00:10:12,930 --> 00:10:17,730
stack depth in the kernel you know the

00:10:15,870 --> 00:10:22,320
code would well it would just recurse or

00:10:17,730 --> 00:10:25,220
something and so there are lots lots of

00:10:22,320 --> 00:10:25,220
little things like that

00:10:27,480 --> 00:10:32,890
it's metadata that's what worries yeah

00:10:30,100 --> 00:10:35,110
eventually all the slow file systems we

00:10:32,890 --> 00:10:37,150
would just make it so you can't build it

00:10:35,110 --> 00:10:39,340
except on you amount that it works and

00:10:37,150 --> 00:10:46,330
then we could it be a security

00:10:39,340 --> 00:10:49,600
improvement not yeah and it yeah it's to

00:10:46,330 --> 00:10:51,670
thing just a metadata and it's the fact

00:10:49,600 --> 00:10:54,760
that someone else had their hands on it

00:10:51,670 --> 00:10:56,260
they are really not certain if they've

00:10:54,760 --> 00:11:00,250
got your best interests at heart right

00:10:56,260 --> 00:11:03,730
and like if you put a USB stick even if

00:11:00,250 --> 00:11:07,450
it's a XFS you want to mount it in your

00:11:03,730 --> 00:11:15,130
mouth and copy it over the data if you

00:11:07,450 --> 00:11:16,180
care about this yeah oh yeah yeah there

00:11:15,130 --> 00:11:20,920
you know if you're just transferring

00:11:16,180 --> 00:11:23,560
files you care about speed you know and

00:11:20,920 --> 00:11:26,830
if you can say I very trust this USB

00:11:23,560 --> 00:11:30,460
stick because I'm the one who put the

00:11:26,830 --> 00:11:34,450
filesystem bot and stuff but yeah you

00:11:30,460 --> 00:11:38,230
know but but yeah so speeds not

00:11:34,450 --> 00:11:41,140
inconsequential but you know at the same

00:11:38,230 --> 00:11:42,910
time we don't want want dumb trust we

00:11:41,140 --> 00:11:48,640
got to get out of this trust by default

00:11:42,910 --> 00:11:51,130
or full trust by default so if I could

00:11:48,640 --> 00:11:54,520
just follow up briefly yeah so you don't

00:11:51,130 --> 00:11:57,100
trust fsck or metadata check something

00:11:54,520 --> 00:11:59,590
to insulate you from

00:11:57,100 --> 00:12:05,110
kind of attacks metadata checksumming

00:11:59,590 --> 00:12:09,250
will will catch bit flips and so but you

00:12:05,110 --> 00:12:12,730
know if I if I'm if I put on my evil hat

00:12:09,250 --> 00:12:16,150
I can correct I can drop the file system

00:12:12,730 --> 00:12:17,560
and check fix the checksums well it just

00:12:16,150 --> 00:12:21,490
seems to me like you're trying to

00:12:17,560 --> 00:12:23,890
address future file system bugs happen

00:12:21,490 --> 00:12:28,480
to be security issues

00:12:23,890 --> 00:12:32,170
yeah the way yeah yes exactly so why we

00:12:28,480 --> 00:12:34,780
have a way of dealing with bugs we not

00:12:32,170 --> 00:12:48,580
sure okay so what I'm trying to

00:12:34,780 --> 00:12:52,750
accomplish is making it so that pretty

00:12:48,580 --> 00:12:58,060
serious bugs nobody cares and nobody

00:12:52,750 --> 00:13:00,460
fixes it and nobody can test it so if we

00:12:58,060 --> 00:13:06,340
could move it to you amount I'll be a

00:13:00,460 --> 00:13:10,150
win definitely improve security and

00:13:06,340 --> 00:13:12,160
that's a useful thing but it doesn't

00:13:10,150 --> 00:13:14,560
really solve the problem because the

00:13:12,160 --> 00:13:17,440
modern exploits are sufficiently complex

00:13:14,560 --> 00:13:20,740
and people exploit the JavaScript and

00:13:17,440 --> 00:13:24,340
the render process host process some

00:13:20,740 --> 00:13:26,980
server and then the kernel so if the

00:13:24,340 --> 00:13:28,810
image can exploit the few server and

00:13:26,980 --> 00:13:30,940
then exploit the kernel that's not

00:13:28,810 --> 00:13:33,670
really much different it's kind of makes

00:13:30,940 --> 00:13:36,430
it harder so it's good but it doesn't

00:13:33,670 --> 00:13:39,580
address the problem of actually checking

00:13:36,430 --> 00:13:42,340
the image and correctly handing the bad

00:13:39,580 --> 00:13:45,640
images so if we really just reuse the

00:13:42,340 --> 00:13:48,130
same code then it's slightly better but

00:13:45,640 --> 00:13:51,850
yeah doesn't really solve the problem

00:13:48,130 --> 00:13:53,920
well it's fundamentally with security

00:13:51,850 --> 00:13:56,680
you can't solve the problem you can only

00:13:53,920 --> 00:13:59,770
make it more costly for someone to

00:13:56,680 --> 00:14:04,240
attack you and I think the first step on

00:13:59,770 --> 00:14:05,680
this is to not it is to make is to

00:14:04,240 --> 00:14:08,560
figure out how we can use the stuff

00:14:05,680 --> 00:14:12,880
we've got to make it more costly to

00:14:08,560 --> 00:14:15,100
you attack us you know get into either

00:14:12,880 --> 00:14:17,470
space you know once we do that we can

00:14:15,100 --> 00:14:19,660
put in all kinds of sand boxes do all

00:14:17,470 --> 00:14:22,529
kinds of stuff depending on what we see

00:14:19,660 --> 00:14:26,830
is a threat model but right now it's

00:14:22,529 --> 00:14:30,070
nobody would you know this is not you

00:14:26,830 --> 00:14:31,810
know in ext4 which is as far as I know

00:14:30,070 --> 00:14:34,420
the best file system for handling bugs

00:14:31,810 --> 00:14:37,960
like this as their reported they'll fix

00:14:34,420 --> 00:14:39,580
them but there is no confidence that

00:14:37,960 --> 00:14:43,750
there aren't existing bugs in the file

00:14:39,580 --> 00:14:47,680
system that you can can exploit you know

00:14:43,750 --> 00:14:51,580
that you know they they don't want it

00:14:47,680 --> 00:14:54,550
you know they'll fix the bugs they know

00:14:51,580 --> 00:14:57,430
about but if but they don't know how to

00:14:54,550 --> 00:14:58,600
find this class or and make certain

00:14:57,430 --> 00:15:01,270
they're not in the file system

00:14:58,600 --> 00:15:03,700
you know buzzer you know fuzzers report

00:15:01,270 --> 00:15:06,820
these every day the Lynx kernel bailing

00:15:03,700 --> 00:15:12,160
was just about we've got you know more

00:15:06,820 --> 00:15:15,790
and ya fixing that's great but how do we

00:15:12,160 --> 00:15:20,050
get to the point where we're not a you

00:15:15,790 --> 00:15:24,280
know it it takes a really well financed

00:15:20,050 --> 00:15:27,550
adversary should choose who I'm attack

00:15:24,280 --> 00:15:29,680
us this way you only care about this for

00:15:27,550 --> 00:15:31,690
privileged UK robot this for privileged

00:15:29,680 --> 00:15:33,490
and unprivileged users alike so you want

00:15:31,690 --> 00:15:35,740
to make even if your route then you want

00:15:33,490 --> 00:15:42,310
to run the filesystem as for example in

00:15:35,740 --> 00:15:45,700
UML so I you know I think routes should

00:15:42,310 --> 00:15:47,170
be able to say yes I trust this but

00:15:45,700 --> 00:15:49,060
routes shouldn't have you know but we

00:15:47,170 --> 00:15:51,030
shouldn't have to make trust the default

00:15:49,060 --> 00:15:58,990
policy which is all we've got right now

00:15:51,030 --> 00:16:01,720
lot of files isms are automated yeah

00:15:58,990 --> 00:16:07,100
exactly exactly and that's where the

00:16:01,720 --> 00:16:10,730
disconnect I've got it behind

00:16:07,100 --> 00:16:14,000
I've been running with UML for years and

00:16:10,730 --> 00:16:17,870
years in the air so until it's kind of

00:16:14,000 --> 00:16:23,930
broken and and features are missing and

00:16:17,870 --> 00:16:27,800
so I had to move to VM Tom's but this is

00:16:23,930 --> 00:16:30,190
actually a doable because there they

00:16:27,800 --> 00:16:36,019
used to be I think there's still one

00:16:30,190 --> 00:16:42,519
fuse plug-in that will give you a file

00:16:36,019 --> 00:16:47,180
system of a CP okay and and you easily a

00:16:42,519 --> 00:16:51,589
pin in a UML with a file system with a

00:16:47,180 --> 00:16:53,690
mount and you SSH into that UML and you

00:16:51,589 --> 00:16:57,620
and you and you have a fossil fuels file

00:16:53,690 --> 00:17:01,399
system so it's just it's a it's a back

00:16:57,620 --> 00:17:04,160
it's some kind of script crap that you

00:17:01,399 --> 00:17:06,620
need to write but you could do it on any

00:17:04,160 --> 00:17:09,470
image you want to do yeah so I mean I

00:17:06,620 --> 00:17:11,329
mean what I mean is that it's you need

00:17:09,470 --> 00:17:15,890
someone to want it because it's very

00:17:11,329 --> 00:17:18,650
easy to do this thing that you said yeah

00:17:15,890 --> 00:17:21,169
it's very doable and this is my mom I

00:17:18,650 --> 00:17:23,000
talk to get people to want it and to get

00:17:21,169 --> 00:17:24,679
the file system and maybe with a little

00:17:23,000 --> 00:17:28,730
luck get some user space guys to say

00:17:24,679 --> 00:17:32,210
this is what we need to do to make

00:17:28,730 --> 00:17:35,150
something like this the default so that

00:17:32,210 --> 00:17:37,520
I plug in a USB key and by default in

00:17:35,150 --> 00:17:42,370
Auto mounts in user space with fuse

00:17:37,520 --> 00:17:46,700
instead of in the kernel but well where

00:17:42,370 --> 00:17:48,980
the attack surface is so big that they

00:17:46,700 --> 00:17:51,200
just that the file system developers

00:17:48,980 --> 00:17:56,140
throw up their hands that you know

00:17:51,200 --> 00:18:00,080
that's also and I can only you know I

00:17:56,140 --> 00:18:02,179
guess did we talk about LK you talked

00:18:00,080 --> 00:18:04,880
about lkl briefly but did we talk about

00:18:02,179 --> 00:18:06,710
lkf you see it yet for example and how

00:18:04,880 --> 00:18:09,830
much work it would be to split it out

00:18:06,710 --> 00:18:12,500
now of the whole lkl project and then I

00:18:09,830 --> 00:18:14,840
guess did the other question is do you

00:18:12,500 --> 00:18:18,370
expect or do we expect

00:18:14,840 --> 00:18:21,020
that any solution we can come up with is

00:18:18,370 --> 00:18:23,450
performance wise okay so that people are

00:18:21,020 --> 00:18:25,790
like okay I get the security issues but

00:18:23,450 --> 00:18:28,160
the performance impact is going to be so

00:18:25,790 --> 00:18:34,280
high I'm just going to say I'm not doing

00:18:28,160 --> 00:18:36,320
this yeah so I guess my personal goal

00:18:34,280 --> 00:18:38,300
would be that the performance is good

00:18:36,320 --> 00:18:42,230
enough that if you're dealing with a

00:18:38,300 --> 00:18:47,960
with a lousy USB stick you probably

00:18:42,230 --> 00:18:50,750
don't care you know yeah but you know

00:18:47,960 --> 00:18:53,840
because people don't use things that are

00:18:50,750 --> 00:18:55,520
horrible performance wise I don't think

00:18:53,840 --> 00:18:58,820
we have to have to be perfect awesome

00:18:55,520 --> 00:19:06,490
performance wise just just good enough

00:18:58,820 --> 00:19:08,990
so that things work you know and and so

00:19:06,490 --> 00:19:12,080
that we don't have our aren't constantly

00:19:08,990 --> 00:19:13,820
exposing our users to all these security

00:19:12,080 --> 00:19:18,640
holes and throwing up our hands because

00:19:13,820 --> 00:19:18,640
it's too hard to solve it in the kernel

00:19:20,380 --> 00:19:23,380
okay

00:19:25,460 --> 00:19:30,020
is it do you have a feeling about where

00:19:28,340 --> 00:19:32,990
most of these bugs might me and my

00:19:30,020 --> 00:19:35,360
question is is it enough to just parse

00:19:32,990 --> 00:19:38,750
the initial superblock info and whatever

00:19:35,360 --> 00:19:41,000
else or whatever metadata is is in the

00:19:38,750 --> 00:19:43,280
file system see that okay I didn't crash

00:19:41,000 --> 00:19:45,140
then we can mount it in the kernel like

00:19:43,280 --> 00:19:47,330
is this is that halfway measure that

00:19:45,140 --> 00:19:50,560
you'd be comfortable with or do you

00:19:47,330 --> 00:19:55,940
think there's other bugs later and other

00:19:50,560 --> 00:20:02,660
I think file systems especially the big

00:19:55,940 --> 00:20:06,320
ones like XFS and butter FS and mmin

00:20:02,660 --> 00:20:07,940
we've never merged you are some of the

00:20:06,320 --> 00:20:10,220
biggest piece of chunks that ever get

00:20:07,940 --> 00:20:14,870
chunks of code to get into the kernel

00:20:10,220 --> 00:20:17,360
and if you allow corrupt for corrupt

00:20:14,870 --> 00:20:19,400
metadata that that makes all of that

00:20:17,360 --> 00:20:21,410
code and attack surface because

00:20:19,400 --> 00:20:25,010
basically all the file system driver

00:20:21,410 --> 00:20:28,810
does is deal with metadata in in you

00:20:25,010 --> 00:20:30,830
know as far as their logic so

00:20:28,810 --> 00:20:33,740
100,000 lines of code is an attack

00:20:30,830 --> 00:20:36,410
surface on a big file system yeah I

00:20:33,740 --> 00:20:39,980
don't don't don't know nowhere where all

00:20:36,410 --> 00:20:46,600
the bugs could be and that's kind of the

00:20:39,980 --> 00:20:50,930
fundamental problem problem nobody does

00:20:46,600 --> 00:20:54,290
nobody really knows and their priorities

00:20:50,930 --> 00:20:57,590
are for I trust the disk I put the data

00:20:54,290 --> 00:20:59,530
there and and that's where where it

00:20:57,590 --> 00:21:01,580
ought to be for local file systems

00:20:59,530 --> 00:21:08,600
because that's what gets the performance

00:21:01,580 --> 00:21:10,460
and stuff so so there's a large class of

00:21:08,600 --> 00:21:13,040
file systems that already do what you're

00:21:10,460 --> 00:21:15,620
describing Network file systems right

00:21:13,040 --> 00:21:17,420
they don't trust their peer they parse

00:21:15,620 --> 00:21:19,460
every packet they make sure that

00:21:17,420 --> 00:21:23,360
everything's saying before they allow

00:21:19,460 --> 00:21:25,580
the operation to proceed well why why

00:21:23,360 --> 00:21:27,440
hoist the existing code up in userspace

00:21:25,580 --> 00:21:29,030
and decorate it with a whole lot of

00:21:27,440 --> 00:21:37,990
protection why not just riho these

00:21:29,030 --> 00:21:37,990
things defensively good question yeah

00:21:38,110 --> 00:21:55,250
yeah yeah yeah yeah UML NFS you know

00:21:52,070 --> 00:21:59,120
it's one of those so far any mention of

00:21:55,250 --> 00:22:02,810
that to file system developers are not

00:21:59,120 --> 00:22:07,070
keen on the idea file systems are hard

00:22:02,810 --> 00:22:08,860
right but yeah and I don't know you know

00:22:07,070 --> 00:22:13,040
and I'm not a hundred percent certain

00:22:08,860 --> 00:22:15,950
well the issue is fully solved for

00:22:13,040 --> 00:22:17,570
network file systems either I you know

00:22:15,950 --> 00:22:19,580
what I've seen a manifest it looks as

00:22:17,570 --> 00:22:21,320
though we're gonna solve problem right

00:22:19,580 --> 00:22:23,000
you you're never gonna have a hundred

00:22:21,320 --> 00:22:25,760
percent solution with no vulnerabilities

00:22:23,000 --> 00:22:27,410
right true but you need an architecture

00:22:25,760 --> 00:22:30,950
that allows you to have good confidence

00:22:27,410 --> 00:22:33,610
that you're close I don't think you

00:22:30,950 --> 00:22:33,610
necessarily do

00:22:33,880 --> 00:22:36,989
[Music]

00:22:48,159 --> 00:23:04,969
yeah you know as far as all of this goes

00:23:00,789 --> 00:23:07,249
if you can sit if anyone can sell to a

00:23:04,969 --> 00:23:08,779
ordinary file system developer in the

00:23:07,249 --> 00:23:12,229
links kernel if this is the way they

00:23:08,779 --> 00:23:17,210
ought to do it and get them to agree to

00:23:12,229 --> 00:23:19,190
do it and and you know this you know I

00:23:17,210 --> 00:23:26,320
will be happy with that I've been having

00:23:19,190 --> 00:23:34,429
this conversations off and on and a and

00:23:26,320 --> 00:23:39,639
the none of them have any confidence

00:23:34,429 --> 00:23:39,639
that they can do it so

00:23:40,920 --> 00:23:47,530
you know we should we should just we

00:23:44,830 --> 00:23:51,280
should do an unconference and just do it

00:23:47,530 --> 00:23:52,810
like yeah I mean part of it you have to

00:23:51,280 --> 00:23:55,420
configure the network and you have to

00:23:52,810 --> 00:24:12,850
decide which IP address you're gonna use

00:23:55,420 --> 00:24:16,080
for your yeah but I agree to setup thing

00:24:12,850 --> 00:24:19,570
but the Fedora installer can easily

00:24:16,080 --> 00:24:22,000
figure all that so so the networking is

00:24:19,570 --> 00:24:26,890
basically the same as the one used with

00:24:22,000 --> 00:24:30,370
the VMS and so the net network manager

00:24:26,890 --> 00:24:35,890
and everything in the internal the DHCP

00:24:30,370 --> 00:24:40,450
is already solved the UML has very good

00:24:35,890 --> 00:24:43,930
networking and and running something

00:24:40,450 --> 00:24:46,960
running a UML with something like a

00:24:43,930 --> 00:24:56,880
dedicated something is is how a UML

00:24:46,960 --> 00:24:56,880
works so this is this is distribution

00:24:57,180 --> 00:25:06,250
two weeks work to say okay I enable the

00:25:01,330 --> 00:25:08,470
bottom yeah now but somebody you know

00:25:06,250 --> 00:25:12,670
this is much better much more mature

00:25:08,470 --> 00:25:15,190
than fuse first because it's all inside

00:25:12,670 --> 00:25:19,140
the UML there is no interconnection I

00:25:15,190 --> 00:25:22,060
don't need to go from the fuse

00:25:19,140 --> 00:25:24,850
application and connect to the UML

00:25:22,060 --> 00:25:30,220
application somehow yeah you can run and

00:25:24,850 --> 00:25:33,640
they and I have already mature and all

00:25:30,220 --> 00:25:35,920
you do I don't need except as developer

00:25:33,640 --> 00:25:38,410
involvement all I need is that they

00:25:35,920 --> 00:25:42,130
support an offensive export on their

00:25:38,410 --> 00:25:42,940
processor UML compiles compile the decay

00:25:42,130 --> 00:25:46,300
of the you

00:25:42,940 --> 00:25:50,290
okay so it's a mine it's more like a

00:25:46,300 --> 00:25:52,780
packaging thing oh it's not good yeah

00:25:50,290 --> 00:25:54,340
and until we connect those dots the user

00:25:52,780 --> 00:25:56,770
space it's not completely solved but

00:25:54,340 --> 00:25:58,990
yeah we've got young that's kind of my

00:25:56,770 --> 00:26:00,790
point we've got the pieces that one way

00:25:58,990 --> 00:26:10,120
or another we can get the file systems

00:26:00,790 --> 00:26:11,860
running in user space it seems also that

00:26:10,120 --> 00:26:13,840
this would be pretty problematic present

00:26:11,860 --> 00:26:15,580
well I guess for me and may

00:26:13,840 --> 00:26:17,800
misunderstand this but there is sort of

00:26:15,580 --> 00:26:19,210
the implication that actually client

00:26:17,800 --> 00:26:22,750
system drivers should not be part of the

00:26:19,210 --> 00:26:24,640
kernel so or should not run in in kernel

00:26:22,750 --> 00:26:26,050
space and it's probably something that

00:26:24,640 --> 00:26:29,710
you don't want to tell a bunch of

00:26:26,050 --> 00:26:33,310
classes of maintainer x' well if file

00:26:29,710 --> 00:26:35,710
system maintainer x' want to turn around

00:26:33,310 --> 00:26:40,600
and say yeah i can i can solve these

00:26:35,710 --> 00:26:42,820
issues yeah you know and and we can

00:26:40,600 --> 00:26:45,040
allow unprivileged users to mount them

00:26:42,820 --> 00:26:48,970
even when they're malicious

00:26:45,040 --> 00:26:50,380
that's great but you know instead

00:26:48,970 --> 00:26:53,800
they've been telling me the exact

00:26:50,380 --> 00:26:56,050
opposite and they've been looking for

00:26:53,800 --> 00:26:57,580
I've had suggestions from file system

00:26:56,050 --> 00:27:01,390
developers how to run the file systems

00:26:57,580 --> 00:27:05,380
in userspace or you'll run the kernel in

00:27:01,390 --> 00:27:09,850
user space so so the untrusted ones so

00:27:05,380 --> 00:27:13,120
that's yeah so that's the direction I've

00:27:09,850 --> 00:27:15,790
had that so does anyone have any clue

00:27:13,120 --> 00:27:18,010
how to get things so if we had one of

00:27:15,790 --> 00:27:22,060
these setups so the file system would

00:27:18,010 --> 00:27:24,250
auto would mount under gnome or KDE with

00:27:22,060 --> 00:27:31,030
this way instead of using the kernel

00:27:24,250 --> 00:27:34,740
driver well I mean how do we connect all

00:27:31,030 --> 00:27:34,740
the pieces so what happens by default

00:27:42,679 --> 00:27:46,470
thank you

00:27:44,040 --> 00:27:48,420
I believe at least the genome gvfs which

00:27:46,470 --> 00:27:50,610
is the genome file system demon that

00:27:48,420 --> 00:27:52,799
also uses fuse could be persuaded to

00:27:50,610 --> 00:27:56,400
intercept the USB event and just factory

00:27:52,799 --> 00:27:57,780
gvfs then set up your fuse mount instead

00:27:56,400 --> 00:27:59,700
of actually just mounting it in the

00:27:57,780 --> 00:28:02,220
kernel so I think it's possible with

00:27:59,700 --> 00:28:04,320
that but I think we'd want a more Genet

00:28:02,220 --> 00:28:05,850
or operating system generically so I

00:28:04,320 --> 00:28:07,890
think you'd probably want you to have to

00:28:05,850 --> 00:28:12,000
do it all rather than relying on some

00:28:07,890 --> 00:28:14,040
AMD members okay okay is that how the

00:28:12,000 --> 00:28:15,059
other mounts happen now what you did

00:28:14,040 --> 00:28:17,760
okay

00:28:15,059 --> 00:28:20,610
well no no they had to automatic a gnome

00:28:17,760 --> 00:28:22,500
hat with jeeve a gvfs you dev is some

00:28:20,610 --> 00:28:24,840
sort of participant in Maya but it

00:28:22,500 --> 00:28:26,580
doesn't business simulator so I think

00:28:24,840 --> 00:28:28,710
for us we probably want to make you dev

00:28:26,580 --> 00:28:30,840
the supervisor okay

00:28:28,710 --> 00:28:32,580
just a guess because I I don't think you

00:28:30,840 --> 00:28:34,730
want to contain us to rely on whichever

00:28:32,580 --> 00:28:37,500
graphical desktop is running yeah oh

00:28:34,730 --> 00:28:38,760
well yeah and this is you know there but

00:28:37,500 --> 00:28:41,820
there's a problem for containers there's

00:28:38,760 --> 00:28:45,150
a problem for it for other things I mean

00:28:41,820 --> 00:28:48,410
but yeah like USB sticks but yeah if we

00:28:45,150 --> 00:28:48,410
can if we can make it happen

00:28:52,220 --> 00:28:59,789
access part is already done you just go

00:28:56,240 --> 00:29:06,480
slash net slash some naming convention

00:28:59,789 --> 00:29:10,080
how can USB for this the it's you you do

00:29:06,480 --> 00:29:13,260
need someone to set up a YouTube rule

00:29:10,080 --> 00:29:18,120
which says in these conditions under

00:29:13,260 --> 00:29:22,110
these conditions run the UML loader okay

00:29:18,120 --> 00:29:28,080
with this name and then oops you have a

00:29:22,110 --> 00:29:31,020
slash net slash using okay so it's all

00:29:28,080 --> 00:29:35,279
there it's something that someone wants

00:29:31,020 --> 00:29:41,100
to want to want to do it yeah don't need

00:29:35,279 --> 00:29:48,179
to write code so just because I see an

00:29:41,100 --> 00:29:53,120
NFS maintainer back there you know how

00:29:48,179 --> 00:29:57,149
scary to does it does this this idea of

00:29:53,120 --> 00:29:59,130
mounting NFS filesystem unprivileged

00:29:57,149 --> 00:30:04,370
user's mount about to get FS file

00:29:59,130 --> 00:30:04,370
systems I'm sound to you

00:30:19,590 --> 00:30:26,220
so this is all done well there are lots

00:30:23,860 --> 00:30:28,860
of things that already happened you know

00:30:26,220 --> 00:30:31,059
Lizza the challenge is getting this into

00:30:28,860 --> 00:30:33,190
supported and people actually know

00:30:31,059 --> 00:30:36,970
what's happening and can maintain and

00:30:33,190 --> 00:30:39,370
all of that yeah I mean obviously this

00:30:36,970 --> 00:30:41,520
will work it's not not hard this is very

00:30:39,370 --> 00:30:41,520
easy

00:30:54,360 --> 00:30:59,830
yeah because obviously using for it IO

00:30:57,210 --> 00:31:01,450
faster Oh second I was thinking about

00:30:59,830 --> 00:31:02,559
Ganesha versus the kernel server right

00:31:01,450 --> 00:31:05,500
because you're trying to avoid

00:31:02,559 --> 00:31:07,330
introducing a virus right so you know a

00:31:05,500 --> 00:31:09,250
complicated virus where you know the

00:31:07,330 --> 00:31:12,460
file system crash and killing the NFS

00:31:09,250 --> 00:31:14,350
server can be bad Ganesha also may have

00:31:12,460 --> 00:31:16,510
plugins now if you do this with Samba

00:31:14,350 --> 00:31:17,919
Samba has the virus check plugins right

00:31:16,510 --> 00:31:19,210
so you can just you know run the virus

00:31:17,919 --> 00:31:21,400
dark plug in a check the signature on

00:31:19,210 --> 00:31:22,809
the thing and mmm that's kind of cool so

00:31:21,400 --> 00:31:24,820
you know if you did the auto mount with

00:31:22,809 --> 00:31:26,980
with smb3 you know you'd have the virus

00:31:24,820 --> 00:31:28,870
check plug-in could be called out but I

00:31:26,980 --> 00:31:31,240
think NFS Ganesha probably has the same

00:31:28,870 --> 00:31:34,049
thing right I think where it has a call

00:31:31,240 --> 00:31:34,049
out for virus trap

00:31:44,819 --> 00:31:50,919
yeah yeah it's very easy I think I agree

00:31:48,459 --> 00:31:53,409
it's the easy path so a couple other

00:31:50,919 --> 00:31:54,909
quick things I was thinking about was so

00:31:53,409 --> 00:31:56,619
you can make performative a little bit

00:31:54,909 --> 00:32:00,639
better and if s easy Samba is easy this

00:31:56,619 --> 00:32:02,139
would be trivial to do but you know in a

00:32:00,639 --> 00:32:03,339
lot of these cases what are these thing

00:32:02,139 --> 00:32:06,969
what are these drives formatted with

00:32:03,339 --> 00:32:11,859
your memory loop so I would think most

00:32:06,969 --> 00:32:14,559
Commons actually xq4 yeah or or fad and

00:32:11,859 --> 00:32:17,440
these are like super trivial to do like

00:32:14,559 --> 00:32:19,690
okay look at exit pass it's five times

00:32:17,440 --> 00:32:21,309
bigger than either of those NTFS is

00:32:19,690 --> 00:32:24,459
already in the user space so if it's an

00:32:21,309 --> 00:32:26,229
NTFS one that's easy bad and the extra

00:32:24,459 --> 00:32:27,940
four are actually fairly simple problems

00:32:26,229 --> 00:32:29,229
to solve a user space compared with the

00:32:27,940 --> 00:32:31,089
normal file system but I'm just

00:32:29,229 --> 00:32:33,729
wondering if your use case ever hits XFS

00:32:31,089 --> 00:32:36,489
words you don't want to - I'll

00:32:33,729 --> 00:32:37,959
disappoint ya I don't know quite what my

00:32:36,489 --> 00:32:39,519
consume you know yeah I'm just looking

00:32:37,959 --> 00:32:42,519
at the general problem where by default

00:32:39,519 --> 00:32:45,489
that's when you plug in USB stick that

00:32:42,519 --> 00:32:48,309
or weird or we're dealing with container

00:32:45,489 --> 00:32:51,279
images yeah yeah so I'd like you to

00:32:48,309 --> 00:32:54,729
consider widening your use case because

00:32:51,279 --> 00:32:57,759
you're missing a few steps okay so the

00:32:54,729 --> 00:32:59,559
physical slot or the place that you get

00:32:57,759 --> 00:33:02,079
the file from right these are the places

00:32:59,559 --> 00:33:04,779
where untrusted thingies come from yeah

00:33:02,079 --> 00:33:06,940
who manages that the kernel is actually

00:33:04,779 --> 00:33:08,499
listing for this insert event so you

00:33:06,940 --> 00:33:10,629
already have another attack surface you

00:33:08,499 --> 00:33:14,440
haven't talked about supposing it's the

00:33:10,629 --> 00:33:16,599
GPT partition table somebody can create

00:33:14,440 --> 00:33:18,009
some random thing that has a partition

00:33:16,599 --> 00:33:20,669
table which would suddenly cause a

00:33:18,009 --> 00:33:23,480
random creation of device notes of

00:33:20,669 --> 00:33:25,250
uncountable entries

00:33:23,480 --> 00:33:27,020
there's many many things before you get

00:33:25,250 --> 00:33:28,610
to the place where somebody said hey

00:33:27,020 --> 00:33:31,820
let's look and see what happens if you

00:33:28,610 --> 00:33:34,700
cause every single file system ko to get

00:33:31,820 --> 00:33:37,070
loaded all at once so I think the whole

00:33:34,700 --> 00:33:40,280
notion that you're really aiming towards

00:33:37,070 --> 00:33:41,780
is part of machine a trust because it's

00:33:40,280 --> 00:33:44,210
the stuff I'm setting next year right

00:33:41,780 --> 00:33:46,580
it's my keyboard is my mouse and the

00:33:44,210 --> 00:33:48,350
other part let's call it a p.m. yeah all

00:33:46,580 --> 00:33:50,240
right so I'd like to hand away this

00:33:48,350 --> 00:33:52,160
slide so that whenever I plug in

00:33:50,240 --> 00:33:54,560
something into that slot it goes and

00:33:52,160 --> 00:33:56,240
gets handled by at my local cloud right

00:33:54,560 --> 00:33:58,340
that's kind of idea that somebody posed

00:33:56,240 --> 00:34:00,400
here was running using both Linux is

00:33:58,340 --> 00:34:03,200
yeah let's take the part which belong to

00:34:00,400 --> 00:34:05,660
random stuff I picked up off the street

00:34:03,200 --> 00:34:08,320
when I bicycles home and saying let's

00:34:05,660 --> 00:34:10,400
let's call that a separate trust zone

00:34:08,320 --> 00:34:12,770
yeah yeah I think there are plenty of

00:34:10,400 --> 00:34:14,690
good ideas and then my suggestion here

00:34:12,770 --> 00:34:19,340
would be to put together a discussion

00:34:14,690 --> 00:34:22,190
forum you can pick your favorite okay

00:34:19,340 --> 00:34:26,810
likely enough people mailing lists or

00:34:22,190 --> 00:34:29,840
something I mean the biggest push for as

00:34:26,810 --> 00:34:32,330
far as I see it came from the container

00:34:29,840 --> 00:34:33,830
use case I mean right for a long for a

00:34:32,330 --> 00:34:35,210
long time you mean one of the reasons

00:34:33,830 --> 00:34:36,830
why we have all of these infrastructure

00:34:35,210 --> 00:34:40,010
to for example make on privileged mounts

00:34:36,830 --> 00:34:41,780
and so on work is to be able to use meet

00:34:40,010 --> 00:34:45,440
finding file systems meaningful file

00:34:41,780 --> 00:34:46,940
systems apart from fuse in containers

00:34:45,440 --> 00:34:51,530
for unprivileged users which is

00:34:46,940 --> 00:34:53,060
obviously not going to happen so that's

00:34:51,530 --> 00:34:54,710
kind of where I've been working and

00:34:53,060 --> 00:34:57,800
where I picked it up but right it's

00:34:54,710 --> 00:35:01,160
where the motivation but but but for

00:34:57,800 --> 00:35:03,500
even longer that the first way we had a

00:35:01,160 --> 00:35:06,470
malicious code spread well as people

00:35:03,500 --> 00:35:09,740
would plug in a floppy disk and bad

00:35:06,470 --> 00:35:11,840
things would happen so this is you know

00:35:09,740 --> 00:35:14,900
this is the oldest attack vector I know

00:35:11,840 --> 00:35:18,040
of in computers and we have yet to

00:35:14,900 --> 00:35:22,330
figure out how to lock it down very well

00:35:18,040 --> 00:35:22,330
we're not even really trying right now

00:35:29,310 --> 00:35:33,670
it works great for a minute when you

00:35:31,810 --> 00:35:35,470
first mount it and then a block goes bad

00:35:33,670 --> 00:35:38,980
it happens to be a metadata block and

00:35:35,470 --> 00:35:42,040
you know evil things happen wasn't evil

00:35:38,980 --> 00:35:43,570
intent but the system failed so you know

00:35:42,040 --> 00:35:45,130
there there are other scenarios that

00:35:43,570 --> 00:35:48,790
aren't even security related just

00:35:45,130 --> 00:35:50,710
integrity related yeah and I think all

00:35:48,790 --> 00:35:52,990
the integrity related you know everybody

00:35:50,710 --> 00:35:57,070
will be happy to take bug fixes and all

00:35:52,990 --> 00:35:59,800
of that you know that what's unique

00:35:57,070 --> 00:36:03,870
about security issues if someone says oh

00:35:59,800 --> 00:36:06,490
there is this one insane path where you

00:36:03,870 --> 00:36:09,220
walk up the wall climb across the

00:36:06,490 --> 00:36:12,010
ceiling and you drop down it causes an

00:36:09,220 --> 00:36:17,140
issue which has a one in a bazillion

00:36:12,010 --> 00:36:18,940
chance of happening accidentally but has

00:36:17,140 --> 00:36:20,470
about a one in one chance of happening

00:36:18,940 --> 00:36:22,270
if someone's attacking you do what James

00:36:20,470 --> 00:36:25,210
had a really interesting presentation a

00:36:22,270 --> 00:36:27,910
little while ago about a non exploitable

00:36:25,210 --> 00:36:30,280
vulnerability right is it really a

00:36:27,910 --> 00:36:32,650
vulnerability if you can't exploit it

00:36:30,280 --> 00:36:34,630
right I don't think that's so worried

00:36:32,650 --> 00:36:37,060
here right these are real

00:36:34,630 --> 00:36:40,120
vulnerabilities right yeah actual evil

00:36:37,060 --> 00:36:44,320
USB sticks lying on the ground yes or

00:36:40,120 --> 00:36:45,250
yeah or almost it is bad in this

00:36:44,320 --> 00:36:47,050
scenario you're talking about with

00:36:45,250 --> 00:36:48,850
drivers and widening the scope if

00:36:47,050 --> 00:36:50,920
someone takes say an Android phone or

00:36:48,850 --> 00:36:53,560
something but similar functionality and

00:36:50,920 --> 00:36:57,370
programs it so it just looks like a USB

00:36:53,560 --> 00:37:01,030
stick and attacks or drivers some of

00:36:57,370 --> 00:37:03,000
that we've got infrastructure for and a

00:37:01,030 --> 00:37:05,500
lot of those places are small enough

00:37:03,000 --> 00:37:08,380
there's a reasonable chance we can

00:37:05,500 --> 00:37:11,560
harden hardened the hardened the code so

00:37:08,380 --> 00:37:13,660
that you know someone can review it in a

00:37:11,560 --> 00:37:15,730
day and say no I don't think it's it's

00:37:13,660 --> 00:37:19,500
reasonably not it not even on the USB

00:37:15,730 --> 00:37:22,180
stacks okay well is it the old fashioned

00:37:19,500 --> 00:37:25,380
file system two tables that seemed

00:37:22,180 --> 00:37:25,380
simple enough but

00:37:26,780 --> 00:37:32,240
ah but even if you looked at that table

00:37:29,810 --> 00:37:36,410
and then a second later the table

00:37:32,240 --> 00:37:38,990
changed intro I'm sorry yeah did all the

00:37:36,410 --> 00:37:49,130
protection you wanted but your code was

00:37:38,990 --> 00:37:51,820
weak okay so now you've jumped with

00:37:49,130 --> 00:37:55,330
solution you've hoisted it into a

00:37:51,820 --> 00:38:00,080
non-religious space that's fine yeah

00:37:55,330 --> 00:38:02,090
yeah that's all I'm advocating for that

00:38:00,080 --> 00:38:04,670
we find out how to take these problems

00:38:02,090 --> 00:38:06,710
and and push them so that it's more

00:38:04,670 --> 00:38:08,990
likely to use their space crash so it's

00:38:06,710 --> 00:38:13,660
harder to exploit the kernel exactly

00:38:08,990 --> 00:38:17,090
harder to exploit things it gives us

00:38:13,660 --> 00:38:19,400
some confidence that we're not being a

00:38:17,090 --> 00:38:25,450
take advantage of by someone who's very

00:38:19,400 --> 00:38:25,450
clever okay

00:38:25,890 --> 00:38:37,110
ah so I guess the summary is there is

00:38:32,340 --> 00:38:40,470
and you know but with malicious devices

00:38:37,110 --> 00:38:45,360
or malicious file system layouts we

00:38:40,470 --> 00:38:47,490
could the kernel and your application

00:38:45,360 --> 00:38:49,590
can be attacked you know whether it's

00:38:47,490 --> 00:38:52,710
you know from an iPhone you download off

00:38:49,590 --> 00:38:54,930
the net USB stick you plugged in a VM or

00:38:52,710 --> 00:39:02,700
a container image you get from somewhere

00:38:54,930 --> 00:39:05,850
and now you know and doesn't look in the

00:39:02,700 --> 00:39:07,350
code bases are large enough to the

00:39:05,850 --> 00:39:09,120
attack surface is large people don't

00:39:07,350 --> 00:39:13,830
think they think they can nail

00:39:09,120 --> 00:39:15,750
completely solve the issues so it would

00:39:13,830 --> 00:39:19,820
be good if we can figure out how to push

00:39:15,750 --> 00:39:19,820
it out of the kernel into a sandbox to

00:39:21,050 --> 00:39:31,760
to reduce the threat good summary okay

00:39:32,420 --> 00:39:37,700
[Music]

00:39:32,500 --> 00:39:40,500
[Applause]

00:39:37,700 --> 00:39:43,970
and if someone can automate that in

00:39:40,500 --> 00:39:43,970

YouTube URL: https://www.youtube.com/watch?v=BlugUDzCJqI


