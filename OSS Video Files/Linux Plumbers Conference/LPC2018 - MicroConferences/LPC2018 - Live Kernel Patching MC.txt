Title: LPC2018 - Live Kernel Patching MC
Publication date: 2018-12-04
Playlist: LPC2018 - MicroConferences
Description: 
	https://linuxplumbersconf.org/event/2/sessions/30/#20181115

The main purpose of the Linux Plumbers 2018 Live kernel patching miniconference is to involve all stakeholders in open discussion about remaining issues that need to be solved in order to make Live patching of the Linux Kernel (more or less) feature complete.

The main purpose of the proposed miniconference is focusing on the features that have been proposed (some even with a preliminary implementation), but not yet finished, with the ultimate goal of sorting out the remaining issues.
Captions: 
	00:00:05,620 --> 00:00:11,559
I welcome my name is Nikolai Stanga and

00:00:09,040 --> 00:00:14,920
I'm working as a live pitching developer

00:00:11,559 --> 00:00:17,290
at Sousa and this talk will be about a

00:00:14,920 --> 00:00:22,259
little side project I've been doing

00:00:17,290 --> 00:00:25,689
recently so to do we do source based

00:00:22,259 --> 00:00:29,160
life patches which as opposed to for

00:00:25,689 --> 00:00:32,169
example binary dipping based methods and

00:00:29,160 --> 00:00:35,649
the problem is that this is a completely

00:00:32,169 --> 00:00:38,519
manual process at this time so what is

00:00:35,649 --> 00:00:41,109
involved is usually to find out which

00:00:38,519 --> 00:00:43,899
functions have to be patched and then

00:00:41,109 --> 00:00:47,530
just to recursively copy everything

00:00:43,899 --> 00:00:49,660
together from the original kernel

00:00:47,530 --> 00:00:52,989
sources into intuitive life patching

00:00:49,660 --> 00:00:55,480
module sources so and yes it's a tedious

00:00:52,989 --> 00:00:57,519
process and it's a lot of work it

00:00:55,480 --> 00:00:59,350
particularly if you support like for

00:00:57,519 --> 00:01:03,720
example 60 different kernel versions

00:00:59,350 --> 00:01:07,990
also and so yeah I've been working on

00:01:03,720 --> 00:01:15,490
automating that let me show my single

00:01:07,990 --> 00:01:17,830
slide so the our approach is to

00:01:15,490 --> 00:01:24,370
basically implement

00:01:17,830 --> 00:01:25,900
oh it's that's it okay but I think I

00:01:24,370 --> 00:01:30,510
remember what it was

00:01:25,900 --> 00:01:35,530
so the over approach is to basically

00:01:30,510 --> 00:01:37,600
write kind of a C front end and it works

00:01:35,530 --> 00:01:42,040
like this in the first step there's a

00:01:37,600 --> 00:01:43,570
pre-processing phase and the important

00:01:42,040 --> 00:01:45,370
thing is that for each pre-processing

00:01:43,570 --> 00:01:48,820
token which could be something like an

00:01:45,370 --> 00:01:52,990
identifier or white space or anything it

00:01:48,820 --> 00:01:55,690
tracks the expansion history which will

00:01:52,990 --> 00:01:58,480
be important the very last step when it

00:01:55,690 --> 00:02:01,210
will attempt to undo the pre-processing

00:01:58,480 --> 00:02:02,500
to keep the result as close to the

00:02:01,210 --> 00:02:06,940
original current sources as possible

00:02:02,500 --> 00:02:09,039
just for reviewability and everything so

00:02:06,940 --> 00:02:14,230
in the second step by the way the check

00:02:09,039 --> 00:02:16,709
marks are for what's working so in the

00:02:14,230 --> 00:02:19,430
second step you just parse that

00:02:16,709 --> 00:02:21,769
preprocessor toking thing

00:02:19,430 --> 00:02:24,680
and then we are running a full type

00:02:21,769 --> 00:02:27,200
evaluation and this is important to know

00:02:24,680 --> 00:02:30,019
which type definitions are actually

00:02:27,200 --> 00:02:34,549
needed in the creator life patching

00:02:30,019 --> 00:02:36,920
modules so yeah and the four-step we

00:02:34,549 --> 00:02:41,959
build the closure which just means we

00:02:36,920 --> 00:02:46,090
copy everything needed together automate

00:02:41,959 --> 00:02:48,860
it and yeah I have a toy demo for that

00:02:46,090 --> 00:02:52,310
yeah and in the fifth step that's the

00:02:48,860 --> 00:02:55,340
last one which is slightly cut off we'll

00:02:52,310 --> 00:02:59,739
be doing the undoing the pre-processing

00:02:55,340 --> 00:02:59,739
and yeah I haven't implemented that yet

00:03:00,099 --> 00:03:10,120
other questions or ads from the other

00:03:04,790 --> 00:03:10,120
room so let me show you a quick demo

00:03:11,739 --> 00:03:23,620
okay okay so I got is it visible okay

00:03:21,230 --> 00:03:23,620
it's not

00:03:39,310 --> 00:03:47,629
so this is just an example toy input

00:03:43,750 --> 00:03:52,970
featuring several things like Ares and

00:03:47,629 --> 00:03:55,280
functions the xt xt prefix is for just

00:03:52,970 --> 00:03:58,430
just for the toy demo to indicate that

00:03:55,280 --> 00:03:59,950
we'd like to have it externalized or I

00:03:58,430 --> 00:04:03,470
don't know a better word for it but

00:03:59,950 --> 00:04:07,430
basically to prepare that for being

00:04:03,470 --> 00:04:10,700
converted into a KP relocation so and

00:04:07,430 --> 00:04:12,799
for the Ares it's important to when it

00:04:10,700 --> 00:04:16,160
comes externalization before example

00:04:12,799 --> 00:04:19,479
have to remove c initializers because it

00:04:16,160 --> 00:04:23,870
just can't have external symbols with

00:04:19,479 --> 00:04:27,560
initializers yeah so one thing to

00:04:23,870 --> 00:04:29,960
highlight is that for one every the

00:04:27,560 --> 00:04:34,310
first one the size will be needed and I

00:04:29,960 --> 00:04:37,000
think for the others not so on let me

00:04:34,310 --> 00:04:37,000
run the same

00:04:45,279 --> 00:04:57,129
so and please ignore any white space

00:04:48,999 --> 00:04:57,129
issues yeah as you can see I can't see

00:04:57,309 --> 00:05:12,649
ya let me pipe that to less so it's

00:05:07,489 --> 00:05:15,559
actually explicit it emitted the size of

00:05:12,649 --> 00:05:19,219
this first area which was needed left it

00:05:15,559 --> 00:05:21,589
out for the second area which because

00:05:19,219 --> 00:05:25,099
it's just not needed and kept the

00:05:21,589 --> 00:05:27,919
initializer for the non externalized

00:05:25,099 --> 00:05:32,269
third area yeah and when it comes to

00:05:27,919 --> 00:05:35,179
functions its yeah just either resolve

00:05:32,269 --> 00:05:39,259
it through an external or not so one

00:05:35,179 --> 00:05:42,619
more thing is that if see one of the

00:05:39,259 --> 00:05:47,300
patch functions or any functions which

00:05:42,619 --> 00:05:49,189
are in the closure are referenced by

00:05:47,300 --> 00:05:52,639
thumb expression which is not a function

00:05:49,189 --> 00:05:57,050
call it should also get externalized to

00:05:52,639 --> 00:06:00,319
just keep Z to retain the original

00:05:57,050 --> 00:06:04,879
address from the kernel code version

00:06:00,319 --> 00:06:07,219
yeah yeah and I have a second demo which

00:06:04,879 --> 00:06:10,069
is about yeah just structures and types

00:06:07,219 --> 00:06:12,679
but I've skipped that I think other

00:06:10,069 --> 00:06:14,539
questions remarks everything's welcome

00:06:12,679 --> 00:06:26,360
to make that thing usable for other

00:06:14,539 --> 00:06:29,029
people to maybe I would like to ask do

00:06:26,360 --> 00:06:35,599
you have some estimation how far you are

00:06:29,029 --> 00:06:39,139
like if you have done like 40% of yeah

00:06:35,599 --> 00:06:41,749
so I think I mean there can be always be

00:06:39,139 --> 00:06:44,389
problem anyway but I think it's

00:06:41,749 --> 00:06:47,990
something like 80 to 90 percent because

00:06:44,389 --> 00:06:52,159
the most work was to do the type

00:06:47,990 --> 00:06:57,169
evaluation in a way compatible with GCC

00:06:52,159 --> 00:06:59,360
so yeah but yet I'm running the

00:06:57,169 --> 00:07:01,490
this type of evaluation thing on the GCC

00:06:59,360 --> 00:07:08,379
test suite so I'm quite optimistic that

00:07:01,490 --> 00:07:08,379
it will work so it ended parser yeah

00:07:10,300 --> 00:07:25,129
sounds promising

00:07:11,960 --> 00:07:27,439
I hope for any more questions or okay so

00:07:25,129 --> 00:07:32,089
so maybe just a step back because I

00:07:27,439 --> 00:07:35,240
think should we mention that we would

00:07:32,089 --> 00:07:37,509
like to have something like oh maybe not

00:07:35,240 --> 00:07:40,129
exactly like this but to have a

00:07:37,509 --> 00:07:44,389
education to upstream just you have

00:07:40,129 --> 00:07:48,460
something yeah am i right so that we

00:07:44,389 --> 00:07:52,249
want to have some education to upstream

00:07:48,460 --> 00:07:54,319
yeah say because did you ever to do

00:07:52,249 --> 00:07:58,120
everything manually is is is a

00:07:54,319 --> 00:07:59,749
horrendous task say any automation it is

00:07:58,120 --> 00:08:03,560
it's perfect

00:07:59,749 --> 00:08:07,370
so the question is whether this source

00:08:03,560 --> 00:08:11,050
based approach is the way to go that's

00:08:07,370 --> 00:08:15,080
the first question because you have a

00:08:11,050 --> 00:08:20,139
functioning demo to some extent say

00:08:15,080 --> 00:08:23,919
that's first question we need to decide

00:08:20,139 --> 00:08:26,990
if we haven't decided yet I'm not sure

00:08:23,919 --> 00:08:29,810
because then there's cabbage build of

00:08:26,990 --> 00:08:37,269
course we the question is whether to use

00:08:29,810 --> 00:08:37,269
that or just to follow this path yeah

00:08:38,990 --> 00:08:44,030
I don't think we're in a position to

00:08:41,090 --> 00:08:49,070
make that decision yet because of the

00:08:44,030 --> 00:08:52,100
DCCC optimization issue I do think if

00:08:49,070 --> 00:08:58,490
which we'll talk about next but I do

00:08:52,100 --> 00:09:01,550
think if we resolve that problem and you

00:08:58,490 --> 00:09:04,610
know this works in the end then it could

00:09:01,550 --> 00:09:08,150
be a good candidate for replacing

00:09:04,610 --> 00:09:13,430
capability I do like this idea of the

00:09:08,150 --> 00:09:15,260
source base approach how it works in

00:09:13,430 --> 00:09:19,070
practice is still you know it remains to

00:09:15,260 --> 00:09:24,530
be seen but I think it's promising at

00:09:19,070 --> 00:09:27,380
least I have one more question do you

00:09:24,530 --> 00:09:28,640
think that this tool will be able to

00:09:27,380 --> 00:09:32,590
also catch

00:09:28,640 --> 00:09:36,230
for example semantic changes in that

00:09:32,590 --> 00:09:40,190
source code that needs special care like

00:09:36,230 --> 00:09:43,940
using that would definitely be the

00:09:40,190 --> 00:09:46,670
second step to just verify to some

00:09:43,940 --> 00:09:49,580
extent possible that you're not doing

00:09:46,670 --> 00:09:51,770
anything which is like forbidden in life

00:09:49,580 --> 00:09:54,080
patching so I mean the the low-hanging

00:09:51,770 --> 00:09:57,460
fruit would be to check that you're not

00:09:54,080 --> 00:10:00,920
modifying structs or something but

00:09:57,460 --> 00:10:03,470
beyond that I can imagine even more

00:10:00,920 --> 00:10:05,600
complicated things like for example if

00:10:03,470 --> 00:10:09,650
we add something like a control flow

00:10:05,600 --> 00:10:11,960
graph which was not be that hard we

00:10:09,650 --> 00:10:13,460
could for example detect locking

00:10:11,960 --> 00:10:17,750
inversion or something like that but

00:10:13,460 --> 00:10:20,470
yeah it's just basically yeah it's the

00:10:17,750 --> 00:10:20,470
third step

00:10:26,810 --> 00:10:33,440
okay another thing so because I think

00:10:30,460 --> 00:10:36,920
Alice yesterday talked about relocations

00:10:33,440 --> 00:10:38,950
and how to generate them right am i

00:10:36,920 --> 00:10:38,950
right

00:10:40,810 --> 00:10:47,510
okay say and you talked about

00:10:45,080 --> 00:10:51,080
relocations and so I'm going back to

00:10:47,510 --> 00:10:53,810
Kayla P converted so given that GCC

00:10:51,080 --> 00:10:57,350
optimizations problem is solved which is

00:10:53,810 --> 00:11:03,110
about to be so should we should we use

00:10:57,350 --> 00:11:06,140
ALP converse with this approach because

00:11:03,110 --> 00:11:08,000
there may be another another way how to

00:11:06,140 --> 00:11:10,880
do it this is not my idea because it

00:11:08,000 --> 00:11:16,250
comes from Michael Moss from our GCC

00:11:10,880 --> 00:11:19,760
team say because I think I didn't

00:11:16,250 --> 00:11:22,460
refresh it but his idea was that you

00:11:19,760 --> 00:11:27,670
didn't have to have special elf sections

00:11:22,460 --> 00:11:30,320
for for our purpose because we kid since

00:11:27,670 --> 00:11:34,280
since a life but she's tightly banned

00:11:30,320 --> 00:11:40,550
the to its Colonel say we know where all

00:11:34,280 --> 00:11:43,490
the symbols are up to K as a but that

00:11:40,550 --> 00:11:47,210
could be solved as well so we could

00:11:43,490 --> 00:11:49,250
generate all all the relocations just

00:11:47,210 --> 00:11:54,980
just like that because we we know the

00:11:49,250 --> 00:11:57,680
colonel and that K s ASLR could be

00:11:54,980 --> 00:12:02,210
solved by relatively allocation so

00:11:57,680 --> 00:12:05,840
there's good don't have to be absolute

00:12:02,210 --> 00:12:09,560
relative to some well-known symbol in in

00:12:05,840 --> 00:12:12,860
the kernel so in that case k LP convert

00:12:09,560 --> 00:12:17,930
and everything we have right now in

00:12:12,860 --> 00:12:24,100
upstream for the relocations would be

00:12:17,930 --> 00:12:24,100
would be obsolete say that maybe an idea

00:12:25,770 --> 00:12:49,510
yes yes right but it should be much much

00:12:28,900 --> 00:12:53,260
simpler I think the biggest obstacle to

00:12:49,510 --> 00:12:56,470
that is exported symbols are currently

00:12:53,260 --> 00:13:04,390
the only way to link to a symbol from a

00:12:56,470 --> 00:13:06,040
module is if it's exported there was a

00:13:04,390 --> 00:13:08,830
talk they talked about doing individual

00:13:06,040 --> 00:13:10,630
function relocation for security reasons

00:13:08,830 --> 00:13:15,300
so we don't necessarily want to prevent

00:13:10,630 --> 00:13:15,300
that with assumed optimizations

00:13:27,890 --> 00:13:35,070
that was I don't think I can comment on

00:13:33,540 --> 00:13:38,899
that but I don't think like that should

00:13:35,070 --> 00:13:38,899
come in the way of being able to do that

00:13:43,940 --> 00:13:49,500
so if I understand you're speaking about

00:13:46,680 --> 00:13:51,300
the randomization talk right where the

00:13:49,500 --> 00:13:54,089
suggestion was to use a function section

00:13:51,300 --> 00:13:56,070
so I am not really sure if we really

00:13:54,089 --> 00:13:57,450
want to do that for the con I mean the

00:13:56,070 --> 00:14:00,269
basic kernel has such and but--

00:13:57,450 --> 00:14:08,060
something with that kind of I'm not sure

00:14:00,269 --> 00:14:08,060
it's that even feasible to do okay

00:14:09,140 --> 00:14:14,470
oh sorry it's not ever of that

00:14:28,170 --> 00:14:32,470
so what problems remain after this with

00:14:30,790 --> 00:14:33,810
respect to being able to do a source

00:14:32,470 --> 00:14:36,250
based patch

00:14:33,810 --> 00:14:39,220
he's already I think see Mike isn't

00:14:36,250 --> 00:14:41,590
really working

00:14:39,220 --> 00:14:43,900
what problems remain with respect to

00:14:41,590 --> 00:14:47,920
being able to do a source level batch as

00:14:43,900 --> 00:14:52,300
opposed to like a binary diff that Kay

00:14:47,920 --> 00:14:55,900
patch does after your GCC changes so I

00:14:52,300 --> 00:15:00,900
don't understand the question yeah yeah

00:14:55,900 --> 00:15:04,360
basically none so I mean you know I mean

00:15:00,900 --> 00:15:07,750
the problem is you always have to

00:15:04,360 --> 00:15:10,780
inspect the upstream fix manually if

00:15:07,750 --> 00:15:14,110
it's with a real-life patching so you

00:15:10,780 --> 00:15:18,910
always need some human probably also a I

00:15:14,110 --> 00:15:21,790
don't know but yeah that's so I and I

00:15:18,910 --> 00:15:22,450
think when we have that we'll be very

00:15:21,790 --> 00:15:25,630
happy

00:15:22,450 --> 00:15:29,520
or I will be very happy because I won't

00:15:25,630 --> 00:15:29,520
have to do it manually anymore but yeah

00:15:29,820 --> 00:15:32,850
fair point

00:15:34,750 --> 00:15:45,220
any more questions or shall we continue

00:15:38,620 --> 00:15:48,759
with the next session it's not obvious

00:15:45,220 --> 00:15:50,500
thing but how do plenty to generate the

00:15:48,759 --> 00:15:53,949
list of Bechet functions so you're gonna

00:15:50,500 --> 00:15:55,959
pass the the page hi okay so this is why

00:15:53,949 --> 00:15:58,019
this is a toy D mu because it decided

00:15:55,959 --> 00:16:03,730
that based on the name of the input and

00:15:58,019 --> 00:16:06,100
for the production thing I'm thinking

00:16:03,730 --> 00:16:09,399
about having a command like taking like

00:16:06,100 --> 00:16:14,019
user provided shell commands that could

00:16:09,399 --> 00:16:18,220
be decide like is this external external

00:16:14,019 --> 00:16:19,930
elizabe or so which would probably the

00:16:18,220 --> 00:16:22,899
shell command which probably just runs

00:16:19,930 --> 00:16:25,509
on object um was grabbed on the target

00:16:22,899 --> 00:16:33,040
kernel or something like that and yeah

00:16:25,509 --> 00:16:35,410
so when I hope that by yeah Lee I'm

00:16:33,040 --> 00:16:39,189
asking because it should be somehow

00:16:35,410 --> 00:16:44,670
connected in a pipeline with what we get

00:16:39,189 --> 00:16:48,069
or what we will get from GCC dumped by

00:16:44,670 --> 00:16:52,329
Optimus optimus Asians involved and

00:16:48,069 --> 00:16:55,269
inlining yes so yeah right so okay I

00:16:52,329 --> 00:17:02,649
actually have a slide for that although

00:16:55,269 --> 00:17:05,199
I'm forbidden so so this is the

00:17:02,649 --> 00:17:07,360
command-line interface I had in my mind

00:17:05,199 --> 00:17:09,579
so it doesn't exist yet but what I'm

00:17:07,360 --> 00:17:13,110
what what basically is needed is a

00:17:09,579 --> 00:17:16,770
number of policy decisions which is like

00:17:13,110 --> 00:17:20,140
it's some function in the initial set

00:17:16,770 --> 00:17:23,470
for example functions in the closure

00:17:20,140 --> 00:17:26,470
should be remain renamed probably and so

00:17:23,470 --> 00:17:31,480
on and one one of the or two of the

00:17:26,470 --> 00:17:35,020
policy is whether or not functions can

00:17:31,480 --> 00:17:39,120
be externalized and for example this can

00:17:35,020 --> 00:17:44,260
externalize command would inspect the

00:17:39,120 --> 00:17:48,040
the output as the optimization report is

00:17:44,260 --> 00:17:55,540
generated by GCC for example

00:17:48,040 --> 00:17:57,880
so yeah and yeah yeah FD is for a

00:17:55,540 --> 00:18:00,190
function definition so it's different a

00:17:57,880 --> 00:18:02,770
little bit different between function

00:18:00,190 --> 00:18:07,750
definitions and function declaration or

00:18:02,770 --> 00:18:10,570
data declarations are these patches

00:18:07,750 --> 00:18:14,230
anywhere or do you plan to post this

00:18:10,570 --> 00:18:16,420
these patches I mean it's not a patch

00:18:14,230 --> 00:18:22,000
it's like forty-one thousand lines of

00:18:16,420 --> 00:18:26,280
code but I can't maybe not a fad get a

00:18:22,000 --> 00:18:31,030
positive so yeah I can I can probably

00:18:26,280 --> 00:18:32,980
push it somewhere I mean the source

00:18:31,030 --> 00:18:35,200
based approach is very needed me

00:18:32,980 --> 00:18:37,750
personally so I would like like some

00:18:35,200 --> 00:18:40,300
time to look at it yeah sure sure but

00:18:37,750 --> 00:18:46,510
yeah really as a front-end only the toy

00:18:40,300 --> 00:18:51,580
thing exists yet so yeah there's no

00:18:46,510 --> 00:18:56,110
question hey perhaps you just covered

00:18:51,580 --> 00:18:58,680
this but I wasn't sure if the tool helps

00:18:56,110 --> 00:19:01,630
with inlined functions

00:18:58,680 --> 00:19:04,270
I'm also very new to the source based

00:19:01,630 --> 00:19:05,800
approach and I wasn't sure you know you

00:19:04,270 --> 00:19:08,830
had that example or you had a patched

00:19:05,800 --> 00:19:11,680
function what would happen if you want

00:19:08,830 --> 00:19:15,850
it to patch a function that the compiler

00:19:11,680 --> 00:19:18,160
okay yeah I know so this is all I was

00:19:15,850 --> 00:19:20,080
talking all about the recursive I mean

00:19:18,160 --> 00:19:23,290
it assumes that it's known what which

00:19:20,080 --> 00:19:25,510
functions are patched which means it's

00:19:23,290 --> 00:19:28,900
right now or even this is ready as a

00:19:25,510 --> 00:19:31,030
manual process but what I'm planning to

00:19:28,900 --> 00:19:35,620
do is to basically give the tool it diff

00:19:31,030 --> 00:19:37,630
and go see core graph up until it has

00:19:35,620 --> 00:19:40,300
found something that is sweeter before

00:19:37,630 --> 00:19:43,780
being a live patching target and then

00:19:40,300 --> 00:19:46,750
thus this recursive thing but that's

00:19:43,780 --> 00:19:47,830
made pretty trivial to implement to go

00:19:46,750 --> 00:19:51,220
just absolutely called

00:19:47,830 --> 00:19:53,950
core graph while this this recursive

00:19:51,220 --> 00:19:55,930
completion of building of the closure is

00:19:53,950 --> 00:20:00,590
not because you because of the type

00:19:55,930 --> 00:20:06,090
evaluation which is needed but yeah

00:20:00,590 --> 00:20:09,190
good question okay sorry

00:20:06,090 --> 00:20:09,190
[Music]

00:21:03,529 --> 00:21:10,529
hi i'm i'm Miroslav I work at Sousa on

00:21:07,289 --> 00:21:13,350
life pitching and so this is my my just

00:21:10,529 --> 00:21:16,799
one slide and it's not so important

00:21:13,350 --> 00:21:18,960
because first I apologize this is not

00:21:16,799 --> 00:21:21,240
going to be much of a discussion I think

00:21:18,960 --> 00:21:25,230
because many things have happened

00:21:21,240 --> 00:21:30,240
recently say maybe more likes they just

00:21:25,230 --> 00:21:32,669
report so I about GCC optimizations and

00:21:30,240 --> 00:21:37,409
life pitching two years ago in Santa Fe

00:21:32,669 --> 00:21:40,289
and say there are G sees there are GCC

00:21:37,409 --> 00:21:43,320
optimizations which are quite dangerous

00:21:40,289 --> 00:21:49,889
for life pitching because GCC is allowed

00:21:43,320 --> 00:21:53,190
to do some crazy stuff with the code for

00:21:49,889 --> 00:21:55,320
example it can remove parameters on

00:21:53,190 --> 00:21:58,289
function if those parameters are not

00:21:55,320 --> 00:22:01,260
evolved involved which means that there

00:21:58,289 --> 00:22:08,070
are constants during during the runtime

00:22:01,260 --> 00:22:09,799
and and stuff like that so it would be

00:22:08,070 --> 00:22:14,010
great to do something about it because

00:22:09,799 --> 00:22:17,880
for example that source based automation

00:22:14,010 --> 00:22:22,409
creation - you would need to be sure

00:22:17,880 --> 00:22:24,960
that everything which every symbol or

00:22:22,409 --> 00:22:28,409
every function which can be found in the

00:22:24,960 --> 00:22:31,230
kernel and can be called some high from

00:22:28,409 --> 00:22:35,309
from the yfh module is it safe to call

00:22:31,230 --> 00:22:38,130
so it's it's because when you when your

00:22:35,309 --> 00:22:40,380
life patch a function it can say it can

00:22:38,130 --> 00:22:42,510
change somehow GCC would do something

00:22:40,380 --> 00:22:45,480
different with it for example those

00:22:42,510 --> 00:22:47,639
parameters will be used suddenly so if

00:22:45,480 --> 00:22:49,649
you if you call such such an optimized

00:22:47,639 --> 00:22:55,380
function it could it could crush your

00:22:49,649 --> 00:22:58,289
kernel the problem is that sometimes GCC

00:22:55,380 --> 00:23:01,200
lets you know that it did something to

00:22:58,289 --> 00:23:07,139
the function so when it clones a

00:23:01,200 --> 00:23:09,659
function it usually add a suffix that

00:23:07,139 --> 00:23:12,269
symbol name so you can find in your call

00:23:09,659 --> 00:23:15,020
same stable you can find functions like

00:23:12,269 --> 00:23:22,919
food dog constant prop

00:23:15,020 --> 00:23:26,010
dot some number or dot i as sra dot a

00:23:22,919 --> 00:23:27,840
number and stuff like that say at least

00:23:26,010 --> 00:23:29,700
you know from from the function name

00:23:27,840 --> 00:23:31,980
that something was done on that function

00:23:29,700 --> 00:23:35,220
which is good because then you can go

00:23:31,980 --> 00:23:38,070
back in a khole graph and life patch its

00:23:35,220 --> 00:23:41,429
caller which is which is great but

00:23:38,070 --> 00:23:43,290
sometimes GCC doesn't let you know that

00:23:41,429 --> 00:23:48,419
it donuts that it had done something

00:23:43,290 --> 00:23:52,650
about about a function so it's quite

00:23:48,419 --> 00:23:57,450
hard to notice it of course you could

00:23:52,650 --> 00:23:59,850
analyze the object file and then you

00:23:57,450 --> 00:24:02,250
could see that something happens but

00:23:59,850 --> 00:24:07,169
that's that's not not much comfortable

00:24:02,250 --> 00:24:09,450
so it we I think we came to a conclusion

00:24:07,169 --> 00:24:12,570
that it would be great to disable such

00:24:09,450 --> 00:24:15,710
optimizations well it's not always

00:24:12,570 --> 00:24:21,380
possible as we found out recently

00:24:15,710 --> 00:24:24,590
because not all of these optimizations

00:24:21,380 --> 00:24:29,130
not all yeah not all these optimizations

00:24:24,590 --> 00:24:37,290
can be can be disabled say that that's

00:24:29,130 --> 00:24:39,809
one thing and there's no how to say that

00:24:37,290 --> 00:24:41,760
say it would be quite maybe I quite

00:24:39,809 --> 00:24:46,559
uncomfortable from the maintenance point

00:24:41,760 --> 00:24:49,470
of view to get a track of these

00:24:46,559 --> 00:24:52,740
dangerous optimizations so because GCC

00:24:49,470 --> 00:24:55,100
or was quite a lot so with every major

00:24:52,740 --> 00:24:59,130
version there are new optimizations so

00:24:55,100 --> 00:25:03,120
we would have to be in careful body to

00:24:59,130 --> 00:25:04,950
let me know the new G that you know that

00:25:03,120 --> 00:25:08,100
new optimizations are somehow dangerous

00:25:04,950 --> 00:25:09,960
so it would be better to have a one

00:25:08,100 --> 00:25:12,720
option which would disable what's

00:25:09,960 --> 00:25:19,290
necessary and what GCC guys care about

00:25:12,720 --> 00:25:22,770
it and it turns out a month ago that

00:25:19,290 --> 00:25:26,280
Oracle wants to do the same say there

00:25:22,770 --> 00:25:28,230
was a proposal on GCC mailing list to do

00:25:26,280 --> 00:25:31,350
something quite similar

00:25:28,230 --> 00:25:33,210
it's it's not about Karen or like

00:25:31,350 --> 00:25:37,169
bitching because they wanted for

00:25:33,210 --> 00:25:41,880
userspace but then again it's similar

00:25:37,169 --> 00:25:45,389
because they want to disable first

00:25:41,880 --> 00:25:48,299
there's dangerous GCC optimizations then

00:25:45,389 --> 00:25:51,600
they they want to limit the inlining as

00:25:48,299 --> 00:25:53,519
well which we don't want to I think so

00:25:51,600 --> 00:25:55,980
that's one question maybe for a

00:25:53,519 --> 00:26:01,010
discussion because that could impact

00:25:55,980 --> 00:26:07,230
performance quite quite a lot say this

00:26:01,010 --> 00:26:12,200
proposal evolved in a time and we came

00:26:07,230 --> 00:26:16,200
up with quite quite a simple proposal so

00:26:12,200 --> 00:26:19,320
let's implement disabling switches for

00:26:16,200 --> 00:26:22,250
these optimizations which we cannot

00:26:19,320 --> 00:26:25,980
disable right now so that's one thing

00:26:22,250 --> 00:26:28,980
let's let's have a new new option which

00:26:25,980 --> 00:26:33,840
would disable everything was was

00:26:28,980 --> 00:26:40,399
dangerous this is maybe a walk around

00:26:33,840 --> 00:26:44,340
because if we had a complete view of

00:26:40,399 --> 00:26:47,490
impacted functions in the kernel I mean

00:26:44,340 --> 00:26:50,639
which functions were impacted by GCC

00:26:47,490 --> 00:26:53,549
optimizations it would not be necessary

00:26:50,639 --> 00:26:56,669
to disable those optimizations sometime

00:26:53,549 --> 00:27:00,990
so not not always because you would just

00:26:56,669 --> 00:27:04,049
purge that that closure but that one can

00:27:00,990 --> 00:27:05,490
be quite huge do you have a question yes

00:27:04,049 --> 00:27:07,620
so do we actually have a clear

00:27:05,490 --> 00:27:12,750
definition more exactly it is the

00:27:07,620 --> 00:27:15,840
dangerous optimisation yes a everything

00:27:12,750 --> 00:27:22,610
which somehow every optimization which

00:27:15,840 --> 00:27:26,370
somehow modifies C ABI whatever it means

00:27:22,610 --> 00:27:27,929
so there's this optimization which is

00:27:26,370 --> 00:27:32,490
called I PA RA

00:27:27,929 --> 00:27:37,649
register allocation it could modify CA

00:27:32,490 --> 00:27:40,740
bi because GCC knows that if a function

00:27:37,649 --> 00:27:41,490
is a leaf function not not yeah that's

00:27:40,740 --> 00:27:43,200
clear I mean

00:27:41,490 --> 00:27:48,660
there is anything else besides the

00:27:43,200 --> 00:27:49,860
clearly a bi violating occupations so if

00:27:48,660 --> 00:27:53,790
there are other things we would like to

00:27:49,860 --> 00:27:57,360
disable other than every I think all of

00:27:53,790 --> 00:28:02,790
this code removing dead code removing

00:27:57,360 --> 00:28:05,970
optimizations variable removals all of

00:28:02,790 --> 00:28:08,460
this stuff right because or just GCC can

00:28:05,970 --> 00:28:13,080
decide that a global variable is is

00:28:08,460 --> 00:28:15,450
read-only and then just just stuff to

00:28:13,080 --> 00:28:17,850
the code and the GCC people are fine

00:28:15,450 --> 00:28:19,380
with introducing such a switch that

00:28:17,850 --> 00:28:24,179
would disable all this right yes

00:28:19,380 --> 00:28:30,540
interesting okay good Oh to my knowledge

00:28:24,179 --> 00:28:32,760
they are I missed some of the talk but

00:28:30,540 --> 00:28:34,500
is there a specific set of functions

00:28:32,760 --> 00:28:37,429
where these optimizations occur are they

00:28:34,500 --> 00:28:41,250
largely static functions so is GCC doing

00:28:37,429 --> 00:28:44,490
optimization across a bunch of datos is

00:28:41,250 --> 00:28:48,000
it doing optimization across all the

00:28:44,490 --> 00:28:50,990
functions like no no no it's all this

00:28:48,000 --> 00:28:54,600
our IPA which means inter procedure or

00:28:50,990 --> 00:28:58,350
something okay it's only in one one unit

00:28:54,600 --> 00:29:01,380
I think yes okay so just say functions

00:28:58,350 --> 00:29:05,900
right because we don't have LTO in the

00:29:01,380 --> 00:29:05,900
kernel okay enabled still

00:29:09,570 --> 00:29:16,990
yeah so and the second part of the

00:29:14,350 --> 00:29:21,600
proposal was about dumping in info about

00:29:16,990 --> 00:29:28,019
impacted functions so currently there is

00:29:21,600 --> 00:29:32,860
an option in GCC which lets in a what

00:29:28,019 --> 00:29:35,950
GCC did in terms of clothing so if

00:29:32,860 --> 00:29:38,320
action was cloned it will it will dump

00:29:35,950 --> 00:29:40,600
team for we have a two to pass it so we

00:29:38,320 --> 00:29:44,679
know that a function was in line to do

00:29:40,600 --> 00:29:47,230
its caller we know that there's IPA

00:29:44,679 --> 00:29:52,299
optimizations were used so that gives us

00:29:47,230 --> 00:29:55,330
optimum gives us overview about the set

00:29:52,299 --> 00:29:59,799
about that closure about the set of to

00:29:55,330 --> 00:30:02,110
be patched functions Oracle once or that

00:29:59,799 --> 00:30:06,399
guy from Oracle wants some something

00:30:02,110 --> 00:30:11,259
more said there is probably gonna be a

00:30:06,399 --> 00:30:14,019
new new option which would give info

00:30:11,259 --> 00:30:16,840
which would give info about about all

00:30:14,019 --> 00:30:19,629
the impacted functions so somehow I

00:30:16,840 --> 00:30:24,519
don't know it wasn't specified yet so

00:30:19,629 --> 00:30:28,330
that's just an idea and last point yeah

00:30:24,519 --> 00:30:30,669
you may wonder about performance impact

00:30:28,330 --> 00:30:33,820
because when you when you disable GCC

00:30:30,669 --> 00:30:36,730
optimizations you just somehow have a

00:30:33,820 --> 00:30:40,600
feeling that it it's maybe not a good

00:30:36,730 --> 00:30:46,090
idea to do well the kernel is is special

00:30:40,600 --> 00:30:50,470
in this way it's not C++ templates code

00:30:46,090 --> 00:30:53,139
so it's highly optimized so we found out

00:30:50,470 --> 00:30:57,519
thanks to john acardo edge from our

00:30:53,139 --> 00:31:00,850
performance team that the impact is not

00:30:57,519 --> 00:31:05,049
that thing significant I think in

00:31:00,850 --> 00:31:09,639
majority of cases there was no impact at

00:31:05,049 --> 00:31:13,840
all there are some cases we when there

00:31:09,639 --> 00:31:16,330
was an impact bar it was in terms of in

00:31:13,840 --> 00:31:17,519
order percents say nothing nothing

00:31:16,330 --> 00:31:21,600
significant

00:31:17,519 --> 00:31:23,460
we just did it on on a big machine

00:31:21,600 --> 00:31:26,100
small machine and the results were quite

00:31:23,460 --> 00:31:31,340
consistent if you want to say more you

00:31:26,100 --> 00:31:33,690
can of course yeah so the conclusion is

00:31:31,340 --> 00:31:37,610
does this all makes sense

00:31:33,690 --> 00:31:40,799
I think it does so we want to disable

00:31:37,610 --> 00:31:45,590
everything which is dangerous and we can

00:31:40,799 --> 00:31:51,059
not do anything about it and so I

00:31:45,590 --> 00:31:55,080
imagine that once this lands in GCC

00:31:51,059 --> 00:31:59,909
upstream which could be GCC 10 I see

00:31:55,080 --> 00:32:04,080
pace because GCC 9 is supposed to be to

00:31:59,909 --> 00:32:05,490
be stabilized I think our I don't know I

00:32:04,080 --> 00:32:09,360
don't know for sure

00:32:05,490 --> 00:32:13,260
so GCC turn would be our target and then

00:32:09,360 --> 00:32:15,150
we can have a have an option in the

00:32:13,260 --> 00:32:21,390
kernel just to just to just do it

00:32:15,150 --> 00:32:24,840
say questions where is the key

00:32:21,390 --> 00:32:27,120
thank you yeah so first of all GCC 9 is

00:32:24,840 --> 00:32:27,659
now frozen four major features yeah I

00:32:27,120 --> 00:32:29,610
thought so

00:32:27,659 --> 00:32:31,740
so again second is that just to clarify

00:32:29,610 --> 00:32:34,650
that the performance measurement was

00:32:31,740 --> 00:32:38,250
only x86 or was it other is agent

00:32:34,650 --> 00:32:41,100
architecture yes it was x86 right so

00:32:38,250 --> 00:32:43,230
there may be impacts of optimization

00:32:41,100 --> 00:32:49,530
that differ between architectures could

00:32:43,230 --> 00:32:51,270
we could be yes so I presume these

00:32:49,530 --> 00:32:55,770
optimizations will be enabled for config

00:32:51,270 --> 00:32:57,960
like patch yes is it easier to get a new

00:32:55,770 --> 00:33:05,690
optimization level with - Oh L or

00:32:57,960 --> 00:33:10,620
something that says yes it said yes I

00:33:05,690 --> 00:33:12,510
said before I think we need or we would

00:33:10,620 --> 00:33:15,480
like to preserve inlining I think if

00:33:12,510 --> 00:33:18,650
that's crucial in the kernel we didn't

00:33:15,480 --> 00:33:23,820
measure it because it somehow seemed

00:33:18,650 --> 00:33:25,679
ridiculous to even try and in the

00:33:23,820 --> 00:33:29,159
absence of even in the absence of that

00:33:25,679 --> 00:33:30,750
flag is it possible to somehow figure

00:33:29,159 --> 00:33:33,090
out that these functions are dangerous

00:33:30,750 --> 00:33:34,740
so that if they are never like patched

00:33:33,090 --> 00:33:35,990
then we still get all the benefits that

00:33:34,740 --> 00:33:39,120
we need

00:33:35,990 --> 00:33:40,470
or if we try to live patch them and they

00:33:39,120 --> 00:33:42,000
were not necessarily compiled with the

00:33:40,470 --> 00:33:46,830
right optimizations we can feel the live

00:33:42,000 --> 00:33:58,140
patch I probably did not understand the

00:33:46,830 --> 00:34:00,900
question so what what we do is that let

00:33:58,140 --> 00:34:06,120
me be honest I I know it's recorded but

00:34:00,900 --> 00:34:10,140
well ok so what we do is that we deal

00:34:06,120 --> 00:34:11,880
with this IPA optimizations because of

00:34:10,140 --> 00:34:15,840
the suffixes and function names so we

00:34:11,880 --> 00:34:18,570
know what what happened then in such

00:34:15,840 --> 00:34:24,060
cases we patch all the callers

00:34:18,570 --> 00:34:26,700
I bet this other dangerous optimizations

00:34:24,060 --> 00:34:29,790
we just pretend that everything is

00:34:26,700 --> 00:34:33,230
alright there's important remark to it

00:34:29,790 --> 00:34:36,810
because I think all of these

00:34:33,230 --> 00:34:43,260
optimizations would be called during the

00:34:36,810 --> 00:34:47,690
testing which is important by itself so

00:34:43,260 --> 00:34:47,690
yes this is important really

00:34:55,520 --> 00:35:05,000
Oh another question Joe so having the

00:35:02,180 --> 00:35:07,610
ability to disable the set of

00:35:05,000 --> 00:35:11,390
optimization it's probably most useful

00:35:07,610 --> 00:35:13,610
for us this may be a far-fetched idea

00:35:11,390 --> 00:35:16,460
but if you are given a list of

00:35:13,610 --> 00:35:18,730
optimizations that occurred for given

00:35:16,460 --> 00:35:21,560
functions would it be possible to

00:35:18,730 --> 00:35:23,390
instruct GCC to do those same

00:35:21,560 --> 00:35:27,650
optimizations for the patched

00:35:23,390 --> 00:35:30,170
compliation and would that be safe or

00:35:27,650 --> 00:35:32,360
would it require too much sort of you

00:35:30,170 --> 00:35:38,290
know analysis to make sure that you know

00:35:32,360 --> 00:35:42,860
your new code is it even yeah yes but it

00:35:38,290 --> 00:35:45,200
some of these optimizations would be

00:35:42,860 --> 00:35:47,980
useless in that case and it might be

00:35:45,200 --> 00:35:51,530
possible I think if we are talking about

00:35:47,980 --> 00:35:53,210
re rename the renaming registers and the

00:35:51,530 --> 00:35:53,780
new code would really look completely

00:35:53,210 --> 00:35:55,790
different

00:35:53,780 --> 00:35:58,700
there's no way how to match up the map

00:35:55,790 --> 00:36:03,880
the two codes together right if the

00:35:58,700 --> 00:36:03,880
change the function is significant

00:36:06,820 --> 00:36:15,830
probably but maybe that subsidies of

00:36:09,740 --> 00:36:18,560
zeros sighs okay so going back didn't do

00:36:15,830 --> 00:36:26,690
nickel eyestalk say my my vision of all

00:36:18,560 --> 00:36:30,050
the pipeline is that we somehow make GCC

00:36:26,690 --> 00:36:34,820
compilation safe for life or kind of

00:36:30,050 --> 00:36:38,270
config like patch then we get info from

00:36:34,820 --> 00:36:41,690
GCC what's in line where for example

00:36:38,270 --> 00:36:43,190
then there's gonna be your tool then we

00:36:41,690 --> 00:36:44,530
could do something of other relocation

00:36:43,190 --> 00:36:49,600
so that's it

00:36:44,530 --> 00:36:54,250
am i right it sounds reasonable

00:36:49,600 --> 00:36:54,250
okay so now we have to do it

00:36:54,990 --> 00:36:58,470
okay thanks

00:37:00,250 --> 00:37:04,369
[Applause]

00:38:20,829 --> 00:38:31,569
so I'm not talking about something which

00:38:26,660 --> 00:38:35,809
I and lack of a better name coined

00:38:31,569 --> 00:38:37,849
global consistency and it's it's

00:38:35,809 --> 00:38:40,069
referring to the period in time when the

00:38:37,849 --> 00:38:42,980
life patch has been fully applied which

00:38:40,069 --> 00:38:45,319
means the transition to it has finished

00:38:42,980 --> 00:38:49,490
and the transition away hasn't been

00:38:45,319 --> 00:38:51,799
started yet and in that time you

00:38:49,490 --> 00:38:55,339
basically know that the whole kernel is

00:38:51,799 --> 00:39:00,290
patched completely and this allows one

00:38:55,339 --> 00:39:03,290
to do some advanced things from life

00:39:00,290 --> 00:39:11,619
patching perspective like changing

00:39:03,290 --> 00:39:11,619
global semantics yeah still in the works

00:39:20,020 --> 00:39:32,470
oh great yeah I think I can describe it

00:39:26,920 --> 00:39:38,830
as well so usually for example take a

00:39:32,470 --> 00:39:43,060
1/2 F so you have this this PDE and and

00:39:38,830 --> 00:39:47,290
the fix is to invert the higher grades

00:39:43,060 --> 00:39:50,440
basically and on x86 or some unused bits

00:39:47,290 --> 00:39:53,040
which means that for inverted PDE is you

00:39:50,440 --> 00:39:56,710
would always have the high speed set and

00:39:53,040 --> 00:39:59,110
for non inverted PD is it would be unset

00:39:56,710 --> 00:40:01,630
so basically it would enable the live

00:39:59,110 --> 00:40:03,850
patched functions the reader function

00:40:01,630 --> 00:40:08,740
which is something like PDE to swap

00:40:03,850 --> 00:40:11,460
entry I guess would be able to handle

00:40:08,740 --> 00:40:16,750
either case and when it is known that

00:40:11,460 --> 00:40:19,330
there is no unlife patched PDE to swap

00:40:16,750 --> 00:40:23,860
entry then it's actually possible to do

00:40:19,330 --> 00:40:27,520
that so and the idea was to kind of use

00:40:23,860 --> 00:40:31,980
callbacks like for example the post

00:40:27,520 --> 00:40:35,440
patch codec I think it's an upstream

00:40:31,980 --> 00:40:37,690
that would just set some global boolean

00:40:35,440 --> 00:40:41,500
flag a glue global for the live Petri

00:40:37,690 --> 00:40:46,510
module and enable the PDE writers to

00:40:41,500 --> 00:40:50,220
actually start inverting PDEs so that

00:40:46,510 --> 00:40:52,810
worked very well so the problem is or

00:40:50,220 --> 00:40:54,550
not a real problem but what has to be

00:40:52,810 --> 00:40:56,680
solved is when it comes to either

00:40:54,550 --> 00:41:02,350
reverse because basically what has to be

00:40:56,680 --> 00:41:15,690
done is the revert ok that's apparently

00:41:02,350 --> 00:41:15,690
not mine it's right

00:41:22,140 --> 00:41:31,120
so there we go yeah okay so that's the

00:41:27,340 --> 00:41:33,130
idea to to to set a global flag from the

00:41:31,120 --> 00:41:35,850
post patch callback which what n here is

00:41:33,130 --> 00:41:41,530
write us to start for example inverted

00:41:35,850 --> 00:41:42,430
PDEs the problem is when it comes to

00:41:41,530 --> 00:41:47,470
either averts

00:41:42,430 --> 00:41:49,210
or to downgrade to a application of next

00:41:47,470 --> 00:41:51,640
life patch module which is actually a

00:41:49,210 --> 00:41:56,980
downgrade and doesn't have C I want to f

00:41:51,640 --> 00:42:00,640
fix because that means that the PDE to

00:41:56,980 --> 00:42:03,880
swap entries may perhaps be unpatched

00:42:00,640 --> 00:42:07,180
now on and those unable to cope with C

00:42:03,880 --> 00:42:09,910
inverted PDS which would means the

00:42:07,180 --> 00:42:12,040
system will just crash so we have to

00:42:09,910 --> 00:42:15,130
from for example from the pre unpatch

00:42:12,040 --> 00:42:18,790
callback which will be I think

00:42:15,130 --> 00:42:20,530
yeah no forget about it we have to scan

00:42:18,790 --> 00:42:23,860
all page tables and block the

00:42:20,530 --> 00:42:26,860
transitions to start so and it turned

00:42:23,860 --> 00:42:29,950
out to be quite a useful technique if

00:42:26,860 --> 00:42:32,350
you want for example format down and I

00:42:29,950 --> 00:42:35,950
want TF and what I'm wondering about is

00:42:32,350 --> 00:42:41,110
whether it would make sense to introduce

00:42:35,950 --> 00:42:43,600
some API for like informing the life

00:42:41,110 --> 00:42:45,640
patch about that it's in global

00:42:43,600 --> 00:42:50,380
consistency mode or something like that

00:42:45,640 --> 00:42:52,630
and yes is the most difficult thing

00:42:50,380 --> 00:42:55,030
about this so we've been discussing that

00:42:52,630 --> 00:42:57,400
internally a little bit and basically

00:42:55,030 --> 00:43:01,150
what we think if we want to do that we

00:42:57,400 --> 00:43:05,800
would probably have some kind of IDs

00:43:01,150 --> 00:43:07,840
like like IDs for fixes like one we

00:43:05,800 --> 00:43:10,990
would allocate one ID for example for a

00:43:07,840 --> 00:43:15,400
one TF so and then we would have some

00:43:10,990 --> 00:43:18,910
sense of the status maintained or broken

00:43:15,400 --> 00:43:22,930
or whatnot so and yeah that's the topic

00:43:18,910 --> 00:43:26,680
to discuss so first what make sense so

00:43:22,930 --> 00:43:31,470
if it were sit and second if Sarah any

00:43:26,680 --> 00:43:31,470
ideas for a sane API for that

00:43:40,320 --> 00:43:46,450
yeah so my idea was like to create

00:43:44,140 --> 00:43:52,230
something like we have that API for

00:43:46,450 --> 00:43:52,230
shared variables that would be able to

00:43:53,310 --> 00:44:01,180
get allocate some structure where it

00:43:58,060 --> 00:44:05,080
could store for example pointer dot for

00:44:01,180 --> 00:44:07,560
callbacks and maybe I don't know some

00:44:05,080 --> 00:44:11,470
version number of that what was the

00:44:07,560 --> 00:44:16,900
state and I don't know maybe some other

00:44:11,470 --> 00:44:19,630
flags or whatever and we could use

00:44:16,900 --> 00:44:22,450
basically to existing callbacks to keep

00:44:19,630 --> 00:44:26,470
it simple and then we could from there

00:44:22,450 --> 00:44:28,900
call just some good function and if the

00:44:26,470 --> 00:44:32,920
state already exists then we could have

00:44:28,900 --> 00:44:35,530
easy access to decode backs from the

00:44:32,920 --> 00:44:44,160
whole page so if we somehow for example

00:44:35,530 --> 00:44:46,680
need to revert the operation before we

00:44:44,160 --> 00:44:47,860
apply the new page then we could easily

00:44:46,680 --> 00:44:51,640
called

00:44:47,860 --> 00:44:55,630
callback from the old page and so on and

00:44:51,640 --> 00:44:58,870
or we could just do nothing because we

00:44:55,630 --> 00:45:03,510
are able to basically just maybe check

00:44:58,870 --> 00:45:07,210
the version and we knew that new page

00:45:03,510 --> 00:45:09,910
exactly handled the same feature the

00:45:07,210 --> 00:45:12,510
same way so there will be no change and

00:45:09,910 --> 00:45:17,850
we could just do nothing

00:45:12,510 --> 00:45:21,610
and stuff like this and but it somehow

00:45:17,850 --> 00:45:24,370
expects that which is the current

00:45:21,610 --> 00:45:28,900
proposal and they ought to make replace

00:45:24,370 --> 00:45:32,170
it said that we will call just do

00:45:28,900 --> 00:45:34,590
callbacks from the new page the idea is

00:45:32,170 --> 00:45:39,790
that actually only the new page knows

00:45:34,590 --> 00:45:44,820
what what might have been in the older

00:45:39,790 --> 00:45:48,910
batches and how to like take over or

00:45:44,820 --> 00:45:49,519
revert or change the state or disable

00:45:48,910 --> 00:45:54,319
what's not

00:45:49,519 --> 00:46:00,140
granny did and stuff like this and yeah

00:45:54,319 --> 00:46:04,459
the only problem is with down grades of

00:46:00,140 --> 00:46:08,709
pitches because we are currently not

00:46:04,459 --> 00:46:11,449
able like to prevent users for

00:46:08,709 --> 00:46:14,119
installing older version of the page and

00:46:11,449 --> 00:46:18,859
given if we use that atomic replace

00:46:14,119 --> 00:46:21,259
approach then if we install the old page

00:46:18,859 --> 00:46:24,409
on top of the new one then it will

00:46:21,259 --> 00:46:28,640
basically like the old patch replace the

00:46:24,409 --> 00:46:31,929
new one but the old page doesn't know it

00:46:28,640 --> 00:46:38,209
was prepared before and he doesn't know

00:46:31,929 --> 00:46:42,759
so I thought about that I I don't know

00:46:38,209 --> 00:46:45,469
we might either it's um like versioning

00:46:42,759 --> 00:46:49,130
internal life bitching and actually the

00:46:45,469 --> 00:46:54,469
kernel will refuse to load old page or

00:46:49,130 --> 00:46:56,749
maybe we could just check if the the

00:46:54,469 --> 00:47:00,279
patches support the same set of features

00:46:56,749 --> 00:47:02,869
like that we could be aware of all that

00:47:00,279 --> 00:47:04,369
global states and check that the

00:47:02,869 --> 00:47:06,919
versions are the same or something like

00:47:04,369 --> 00:47:08,359
this so that basically the patches are

00:47:06,919 --> 00:47:13,969
compatible but it still might be

00:47:08,359 --> 00:47:16,899
dangerous because actually it's how the

00:47:13,969 --> 00:47:19,849
pages are created if you introduce new

00:47:16,899 --> 00:47:23,630
feature then you could test just the

00:47:19,849 --> 00:47:26,719
transition between the state between the

00:47:23,630 --> 00:47:30,889
old patch they didn't support it and to

00:47:26,719 --> 00:47:33,529
newly support it and when you do the

00:47:30,889 --> 00:47:36,109
next version of the page then you could

00:47:33,529 --> 00:47:38,569
finally test correctly the transition

00:47:36,109 --> 00:47:40,069
and you might actually find that it

00:47:38,569 --> 00:47:47,199
doesn't work well and you have to

00:47:40,069 --> 00:47:47,199
somehow update the code and so on so

00:47:48,030 --> 00:47:53,260
okay first I'm sorry for it for you guys

00:47:51,520 --> 00:47:55,450
because this must be pretty confusing

00:47:53,260 --> 00:47:59,680
but okay

00:47:55,450 --> 00:48:02,500
say I think the important question is to

00:47:59,680 --> 00:48:04,600
ask whether we even want to support that

00:48:02,500 --> 00:48:12,160
scenario when you apply all the budget a

00:48:04,600 --> 00:48:17,770
to the Renewable one because I didn't

00:48:12,160 --> 00:48:21,490
know it sounds somehow wrong yeah I mean

00:48:17,770 --> 00:48:24,280
because that's one case is when you when

00:48:21,490 --> 00:48:25,900
you want to go back so you want a dinner

00:48:24,280 --> 00:48:28,900
for example we have two two batches per

00:48:25,900 --> 00:48:31,930
part and then you want to regard the the

00:48:28,900 --> 00:48:36,030
newer and the other one would stay is it

00:48:31,930 --> 00:48:38,560
still supported I I it would be better

00:48:36,030 --> 00:48:40,780
what this scenario be supporting video

00:48:38,560 --> 00:48:43,810
atomic replies but special Donald so

00:48:40,780 --> 00:48:46,900
that you have to to participate and you

00:48:43,810 --> 00:48:50,890
could remove or regard the new one too

00:48:46,900 --> 00:48:53,170
so only the older one would stay no I

00:48:50,890 --> 00:48:55,210
don't think so I think that's that's

00:48:53,170 --> 00:48:59,050
something something we decided not to do

00:48:55,210 --> 00:49:02,140
right so okay so then then it may it may

00:48:59,050 --> 00:49:04,780
make sense to to support what that

00:49:02,140 --> 00:49:08,860
problematic scenario you described yeah

00:49:04,780 --> 00:49:11,890
yeah well there is some workaround and I

00:49:08,860 --> 00:49:15,310
wonder if it might be acceptable that we

00:49:11,890 --> 00:49:18,220
if we keep the possibility to disable

00:49:15,310 --> 00:49:21,600
the page then the users that would like

00:49:18,220 --> 00:49:25,600
to downgrade could disable the new page

00:49:21,600 --> 00:49:28,120
then for some time the system will be

00:49:25,600 --> 00:49:31,810
non unpatched and they don't they could

00:49:28,120 --> 00:49:34,240
install the older page and like get it's

00:49:31,810 --> 00:49:39,070
like down great way to bit something but

00:49:34,240 --> 00:49:41,320
it's like yeah just I think we we don't

00:49:39,070 --> 00:49:43,270
want to do this because as you say the

00:49:41,320 --> 00:49:45,670
system would be on page even for a short

00:49:43,270 --> 00:49:48,730
short period of time and the whole point

00:49:45,670 --> 00:49:58,570
of atomic replace is not not to have it

00:49:48,730 --> 00:50:01,500
so that that the system is I just wonder

00:49:58,570 --> 00:50:03,870
how many times

00:50:01,500 --> 00:50:07,770
it's needed because it doesn't make

00:50:03,870 --> 00:50:10,620
sense to like I think that it might be

00:50:07,770 --> 00:50:16,560
pretty complicated to support downgrades

00:50:10,620 --> 00:50:21,570
like a Safeway and for example Nikolai

00:50:16,560 --> 00:50:24,600
has had an idea to add a lot of like new

00:50:21,570 --> 00:50:27,720
callbacks that for example that the

00:50:24,600 --> 00:50:31,680
global State have might have some states

00:50:27,720 --> 00:50:34,380
with which could be transferred to a new

00:50:31,680 --> 00:50:38,990
one and around back and a lot of

00:50:34,380 --> 00:50:42,270
callbacks to do all these changes and

00:50:38,990 --> 00:50:45,480
but for me it looked very complicated

00:50:42,270 --> 00:50:49,440
and I had like troubles to make a mental

00:50:45,480 --> 00:50:52,080
picture of how do all the callbacks

00:50:49,440 --> 00:50:57,570
depends on each other and in which order

00:50:52,080 --> 00:50:59,340
they are called and yeah and yeah I I

00:50:57,570 --> 00:51:02,430
still think that it doesn't make sense

00:50:59,340 --> 00:51:08,610
to complicate it that much if it's used

00:51:02,430 --> 00:51:15,330
just I don't know say I think maybe the

00:51:08,610 --> 00:51:20,100
obvious first step is not mmm we can we

00:51:15,330 --> 00:51:23,700
can disallow it so that if if there was

00:51:20,100 --> 00:51:27,120
a case that if you went from the new one

00:51:23,700 --> 00:51:31,520
say oh if you applied the older page to

00:51:27,120 --> 00:51:35,100
to a new one so if there's a way that

00:51:31,520 --> 00:51:37,470
that in in in the framework so if

00:51:35,100 --> 00:51:41,760
there's a way to detect such scenarios

00:51:37,470 --> 00:51:44,460
so I think with those IDs it could be

00:51:41,760 --> 00:51:47,970
done so even the older patch could know

00:51:44,460 --> 00:51:51,300
that there's something in a global state

00:51:47,970 --> 00:51:55,500
machinery that the older page cannot

00:51:51,300 --> 00:51:58,380
deal with so if if this can be those I

00:51:55,500 --> 00:52:02,970
think the simplest way simplest thing is

00:51:58,380 --> 00:52:05,760
to do refuse to refuse such downgrade so

00:52:02,970 --> 00:52:09,300
this is something we can we can start

00:52:05,760 --> 00:52:12,690
from and I would generally have

00:52:09,300 --> 00:52:13,080
something simple at the beginning and

00:52:12,690 --> 00:52:15,330
then

00:52:13,080 --> 00:52:18,080
we can we can add stuff because this is

00:52:15,330 --> 00:52:21,390
really useful not not for all those

00:52:18,080 --> 00:52:26,190
common common CV fixes and stuff but if

00:52:21,390 --> 00:52:27,840
something like meltdown or l1 TF came in

00:52:26,190 --> 00:52:32,100
the future it would be it would be

00:52:27,840 --> 00:52:34,260
perfect yeah so you're saying that each

00:52:32,100 --> 00:52:37,710
KP patch structure what basically

00:52:34,260 --> 00:53:01,530
announced some set of state IDs it

00:52:37,710 --> 00:53:04,500
relies on yes okay yeah but I think you

00:53:01,530 --> 00:53:06,470
could also use shadow variables you

00:53:04,500 --> 00:53:14,390
wouldn't even need an API right just

00:53:06,470 --> 00:53:17,580
create your own scheme whatever it is so

00:53:14,390 --> 00:53:19,710
the ID should be conducted by us or we

00:53:17,580 --> 00:53:21,900
allow the user to know chooses oneida

00:53:19,710 --> 00:53:23,820
kind of thing that would be like if if

00:53:21,900 --> 00:53:25,620
you're going to allow the user as such

00:53:23,820 --> 00:53:27,480
for the downgrade also he can use the

00:53:25,620 --> 00:53:29,580
same thing and I don't know that can be

00:53:27,480 --> 00:53:31,920
like a walk around or cheat around if

00:53:29,580 --> 00:53:33,960
the ID can be like predicted should we

00:53:31,920 --> 00:53:36,600
have liked the idea presented by the

00:53:33,960 --> 00:53:38,960
iPad system itself or the user should

00:53:36,600 --> 00:53:38,960
get

00:53:46,230 --> 00:53:53,770
some upgrades might not update the

00:53:49,750 --> 00:53:56,700
global state right so they would you did

00:53:53,770 --> 00:53:58,869
that the version would be the same or

00:53:56,700 --> 00:54:07,210
the identifiers be the same as before

00:53:58,869 --> 00:54:10,230
and that was also another related idea

00:54:07,210 --> 00:54:14,980
that actually Nicolai commits that

00:54:10,230 --> 00:54:17,800
somehow it's like maybe ugly at all

00:54:14,980 --> 00:54:21,240
these callbacks and maybe this state is

00:54:17,800 --> 00:54:27,819
associated with module orbit object

00:54:21,240 --> 00:54:30,190
because and actually I we talked about

00:54:27,819 --> 00:54:34,000
it that it might be easier from the

00:54:30,190 --> 00:54:37,869
maintenance point like have just like

00:54:34,000 --> 00:54:41,020
another list of array of this like

00:54:37,869 --> 00:54:44,200
states and have like separated callbacks

00:54:41,020 --> 00:54:49,750
for each state or something like this so

00:54:44,200 --> 00:54:53,380
just of course it's possible like to do

00:54:49,750 --> 00:54:55,720
some top-level called bike like prayer

00:54:53,380 --> 00:55:00,640
and pose and coach I'll call all that

00:54:55,720 --> 00:55:05,290
callbacks from there but it's just what

00:55:00,640 --> 00:55:10,900
well I don't know because you not

00:55:05,290 --> 00:55:14,849
usually but I think that callbacks are

00:55:10,900 --> 00:55:18,400
tied to the object in a way because you

00:55:14,849 --> 00:55:20,520
you manipulate with something which is

00:55:18,400 --> 00:55:24,040
in that object

00:55:20,520 --> 00:55:26,410
why are while a callback so if it's

00:55:24,040 --> 00:55:29,099
adding a global variable you'd like to

00:55:26,410 --> 00:55:33,309
change say that lives somewhere it's a

00:55:29,099 --> 00:55:37,299
it's an object file so no not object

00:55:33,309 --> 00:55:41,920
file that parent object but if so say I

00:55:37,299 --> 00:55:45,299
don't know if seems like orthogonal so I

00:55:41,920 --> 00:55:51,069
I don't know whether to go this way I

00:55:45,299 --> 00:55:54,460
mean is just recognized I think this

00:55:51,069 --> 00:55:56,059
morning or some things that sees corvex

00:55:54,460 --> 00:55:58,939
not tied to any particular

00:55:56,059 --> 00:56:03,109
object can actually be emulated by using

00:55:58,939 --> 00:56:06,279
the corvex for VM Linux and so yes yes a

00:56:03,109 --> 00:56:06,279
yeah okay right

00:56:15,220 --> 00:56:21,990
any more questions so thank you very

00:56:19,660 --> 00:56:21,990
much

00:56:22,800 --> 00:56:27,570
[Applause]

00:58:05,690 --> 00:58:12,500
okay so hello everyone I'm Jerome I work

00:58:08,180 --> 00:58:14,420
for so safe as you can see I will excuse

00:58:12,500 --> 00:58:16,369
first because I have more than one slide

00:58:14,420 --> 00:58:19,250
so I'm sorry about that but it's gonna

00:58:16,369 --> 00:58:20,869
be fast I swear it's gonna be fast so

00:58:19,250 --> 00:58:23,000
I'm here to talk about lip bob which is

00:58:20,869 --> 00:58:26,809
our presentation and userspace live

00:58:23,000 --> 00:58:29,359
matching so just like sort of like new

00:58:26,809 --> 00:58:30,890
thing so because of that I actually need

00:58:29,359 --> 00:58:32,630
these extra slides otherwise I would not

00:58:30,890 --> 00:58:35,390
be able to go a little bit in detail

00:58:32,630 --> 00:58:37,460
about what we have to talk about so the

00:58:35,390 --> 00:58:38,960
first thing we have to say is that we

00:58:37,460 --> 00:58:41,450
don't have a reliable stack tracer for

00:58:38,960 --> 00:58:43,069
user space so it's kind of complicated

00:58:41,450 --> 00:58:46,609
to use this approach to have life

00:58:43,069 --> 00:58:48,559
matching in user space also whenever

00:58:46,609 --> 00:58:50,960
you're running your program the threads

00:58:48,559 --> 00:58:52,700
are not only in kernel space so you

00:58:50,960 --> 00:58:55,160
could not use the old approach from key

00:58:52,700 --> 00:58:57,859
graft for also having user space life

00:58:55,160 --> 00:59:01,630
matching so we actually needed to find a

00:58:57,859 --> 00:59:04,730
different idea for dealing with this and

00:59:01,630 --> 00:59:07,309
our idea came from the assumptions that

00:59:04,730 --> 00:59:09,440
actually life patching the binary main

00:59:07,309 --> 00:59:12,829
object is not really to go because

00:59:09,440 --> 00:59:14,839
normally the the vulnerabilities or the

00:59:12,829 --> 00:59:16,880
bugs you have in your code are residing

00:59:14,839 --> 00:59:21,440
inside libraries so for example G deep

00:59:16,880 --> 00:59:22,849
see in Lib SSL so we just relaxed or go

00:59:21,440 --> 00:59:25,819
a little bit and you said okay if we're

00:59:22,849 --> 00:59:28,400
able to patch libraries this might be

00:59:25,819 --> 00:59:30,589
enough so basically we created this

00:59:28,400 --> 00:59:33,140
model that we call a library boundary

00:59:30,589 --> 00:59:35,720
based patching which is more or less

00:59:33,140 --> 00:59:37,730
like the old approach from Kay craft but

00:59:35,720 --> 00:59:40,369
instead of like tracking the context

00:59:37,730 --> 00:59:41,869
from user space to kernel space we're

00:59:40,369 --> 00:59:44,569
actually tracking the contest the

00:59:41,869 --> 00:59:48,200
context from the main object to the

00:59:44,569 --> 00:59:48,680
library - the library binary so how does

00:59:48,200 --> 00:59:51,829
it work

00:59:48,680 --> 00:59:54,799
so first thing we do we do some changes

00:59:51,829 --> 00:59:58,519
to the symbol table so basically we take

00:59:54,799 --> 01:00:00,170
the binary we change the values within

00:59:58,519 --> 01:00:03,740
the symbol table so we can actually

01:00:00,170 --> 01:00:05,839
point to a trampoline table so basically

01:00:03,740 --> 01:00:08,869
we are redirecting the entry points for

01:00:05,839 --> 01:00:10,970
a library and we want to do that because

01:00:08,869 --> 01:00:13,609
we want to make the control flow to go

01:00:10,970 --> 01:00:15,109
through our stubs so we call it like you

01:00:13,609 --> 01:00:18,520
have P stubs and we'll get into detail

01:00:15,109 --> 01:00:19,869
about this assume we also do

01:00:18,520 --> 01:00:22,600
change the linker in the case we

01:00:19,869 --> 01:00:24,820
implemented is in LD and basically we

01:00:22,600 --> 01:00:26,830
generate the trampoline table within the

01:00:24,820 --> 01:00:29,710
linker so we have this table there with

01:00:26,830 --> 01:00:32,770
one entry for each exported symbol and

01:00:29,710 --> 01:00:34,570
we also have compiler changes which are

01:00:32,770 --> 01:00:36,490
pretty much similar to the whatever's is

01:00:34,570 --> 01:00:39,580
being done for kernel kernel life

01:00:36,490 --> 01:00:44,470
patching where we meet padding ops into

01:00:39,580 --> 01:00:48,040
function prologues so in the end we we

01:00:44,470 --> 01:00:50,320
have this schematic so basically if you

01:00:48,040 --> 01:00:52,570
think about the main I'll just we'll go

01:00:50,320 --> 01:00:56,080
through the graph so you can understand

01:00:52,570 --> 01:00:57,400
how it works if you go from a whenever

01:00:56,080 --> 01:00:59,380
you're calling a function called foo

01:00:57,400 --> 01:01:01,450
which is in a library that you actually

01:00:59,380 --> 01:01:03,850
want to live batch what you do is that

01:01:01,450 --> 01:01:06,460
you try to resolve that symbol so you go

01:01:03,850 --> 01:01:09,100
through the PLC you leave this work for

01:01:06,460 --> 01:01:11,380
the dynamic linker and it's it's

01:01:09,100 --> 01:01:12,970
resolved to the trampoline table so

01:01:11,380 --> 01:01:16,890
basically the trampoline table will have

01:01:12,970 --> 01:01:19,090
this trm entry for the function foo and

01:01:16,890 --> 01:01:21,580
inside the trampoline table we were

01:01:19,090 --> 01:01:23,590
actually calling function I stub that we

01:01:21,580 --> 01:01:26,020
call the ULP entry and here's actually

01:01:23,590 --> 01:01:27,700
the trick that we are doing so in the

01:01:26,020 --> 01:01:29,440
ULP entry or what you're going to do is

01:01:27,700 --> 01:01:31,359
that first you're gonna check if there's

01:01:29,440 --> 01:01:34,690
a is there's a variable called shadow

01:01:31,359 --> 01:01:36,580
which is set if that set this means that

01:01:34,690 --> 01:01:37,720
the library was already entered so we

01:01:36,580 --> 01:01:39,369
don't care about it I mean we already

01:01:37,720 --> 01:01:41,260
know that we cannot patch this library

01:01:39,369 --> 01:01:42,970
because it's already running but if it's

01:01:41,260 --> 01:01:45,250
not set this means that the library is

01:01:42,970 --> 01:01:47,200
being entered for the first time so here

01:01:45,250 --> 01:01:49,180
what we do is that we save the return

01:01:47,200 --> 01:01:51,130
address for the function that we want to

01:01:49,180 --> 01:01:53,920
call that that that's actually been

01:01:51,130 --> 01:01:57,490
called we replace the return address or

01:01:53,920 --> 01:02:00,330
in the stack with the address for ULP

01:01:57,490 --> 01:02:02,800
exit which is another stub from us and

01:02:00,330 --> 01:02:04,420
then we check if there's a pending patch

01:02:02,800 --> 01:02:06,369
so if there's a pending patch if you

01:02:04,420 --> 01:02:08,440
actually want to patch something we are

01:02:06,369 --> 01:02:10,480
going to apply the patch right now so

01:02:08,440 --> 01:02:12,280
the function is not was not entered yet

01:02:10,480 --> 01:02:14,980
the library was not entered yet so it's

01:02:12,280 --> 01:02:17,380
actually safe to patch this library

01:02:14,980 --> 01:02:21,430
right now and after that we just return

01:02:17,380 --> 01:02:24,010
when we return the our trampoline table

01:02:21,430 --> 01:02:26,710
will resurrect contraflow towards our

01:02:24,010 --> 01:02:28,480
full function which we execute and when

01:02:26,710 --> 01:02:30,760
average returns it's going to use the

01:02:28,480 --> 01:02:32,350
modified return address which we changed

01:02:30,760 --> 01:02:35,140
in the ULP entry

01:02:32,350 --> 01:02:38,740
and it will go for the Europeans it

01:02:35,140 --> 01:02:40,360
function there we restore the actual

01:02:38,740 --> 01:02:43,570
return address the true return address

01:02:40,360 --> 01:02:47,140
that we saved in the ULP entry we then

01:02:43,570 --> 01:02:49,210
set the shadow variable to new so now we

01:02:47,140 --> 01:02:52,660
know that the library is actually being

01:02:49,210 --> 01:02:54,700
exited and then we just return we just

01:02:52,660 --> 01:02:55,870
jump to whatever value was stored in

01:02:54,700 --> 01:02:58,750
shadow and then we have the regular

01:02:55,870 --> 01:03:00,580
control flow back again and your your

01:02:58,750 --> 01:03:05,350
code is executing without actually

01:03:00,580 --> 01:03:07,390
having a damaged control flow something

01:03:05,350 --> 01:03:08,830
important about this scheme is that that

01:03:07,390 --> 01:03:12,160
shadow variable and dependent variable

01:03:08,830 --> 01:03:15,120
these are TLS so we basically have

01:03:12,160 --> 01:03:17,980
treads being migrated individually and

01:03:15,120 --> 01:03:20,740
this is important because you might have

01:03:17,980 --> 01:03:22,900
like many treads running and you might

01:03:20,740 --> 01:03:24,820
not be able to find a moment where all

01:03:22,900 --> 01:03:26,710
the treads are outside the library

01:03:24,820 --> 01:03:28,120
simultaneously so by doing something

01:03:26,710 --> 01:03:31,330
like that you just go migrating thread

01:03:28,120 --> 01:03:35,620
by thread one by one and of course we

01:03:31,330 --> 01:03:36,880
use pitch race for triggering dispatch

01:03:35,620 --> 01:03:38,470
so basically what we do is that we

01:03:36,880 --> 01:03:41,230
attach to the process that we want to

01:03:38,470 --> 01:03:43,180
patch we write whatever information we

01:03:41,230 --> 01:03:45,160
need in the right data structures and

01:03:43,180 --> 01:03:47,830
then we just leave the process running

01:03:45,160 --> 01:03:51,370
and wait for it to pass itself whenever

01:03:47,830 --> 01:03:52,990
the libraries are being entered there

01:03:51,370 --> 01:03:55,120
are some problems to this approach of

01:03:52,990 --> 01:03:56,800
course first problem our static

01:03:55,120 --> 01:04:01,030
functions which actually have their

01:03:56,800 --> 01:04:03,280
their addresses licked so as you have

01:04:01,030 --> 01:04:07,810
seen I mean we we depend on the dynamic

01:04:03,280 --> 01:04:10,390
symbol table and this basically covers

01:04:07,810 --> 01:04:11,710
all exported functions and sometimes you

01:04:10,390 --> 01:04:13,450
might have static functions which will

01:04:11,710 --> 01:04:15,820
not go into your dynamic symbol table

01:04:13,450 --> 01:04:17,710
and if there's a function which is

01:04:15,820 --> 01:04:20,800
actually exported but that returns the

01:04:17,710 --> 01:04:22,660
address of that function to outside the

01:04:20,800 --> 01:04:26,560
library and you somebody might

01:04:22,660 --> 01:04:27,940
eventually call it from outside and this

01:04:26,560 --> 01:04:30,640
is going to be a problem because you're

01:04:27,940 --> 01:04:33,850
not going to be tracking the contacts

01:04:30,640 --> 01:04:36,610
here so it might be a little problem to

01:04:33,850 --> 01:04:38,440
patch static functions with this

01:04:36,610 --> 01:04:41,250
specific model we're already thinking

01:04:38,440 --> 01:04:43,750
about ways to solve this maybe amid

01:04:41,250 --> 01:04:45,220
stubs in the beginning of static

01:04:43,750 --> 01:04:47,170
functions but we are not quite sure

01:04:45,220 --> 01:04:48,490
we're still thinking and ideas are very

01:04:47,170 --> 01:04:50,740
welcome

01:04:48,490 --> 01:04:52,869
also slacking patches may require some

01:04:50,740 --> 01:04:55,180
further improvements we don't have a

01:04:52,869 --> 01:04:58,810
quite support for that yet mostly

01:04:55,180 --> 01:05:00,550
because that that bending stage is

01:04:58,810 --> 01:05:03,880
something a little bit tricky for you to

01:05:00,550 --> 01:05:06,550
deal with we you actually need to write

01:05:03,880 --> 01:05:09,490
on the on the padding ops of functions

01:05:06,550 --> 01:05:11,680
and whenever you do that you're gonna

01:05:09,490 --> 01:05:16,119
have to disband ops you need to be

01:05:11,680 --> 01:05:18,250
replaced again by knobs when you patch

01:05:16,119 --> 01:05:20,920
that same function again or something

01:05:18,250 --> 01:05:23,380
like that so controlling this multiple

01:05:20,920 --> 01:05:25,210
versions might be an issue what we are

01:05:23,380 --> 01:05:26,710
doing currently is like you just remove

01:05:25,210 --> 01:05:29,099
the old back and then you add a new one

01:05:26,710 --> 01:05:31,900
you cannot like patch over another patch

01:05:29,099 --> 01:05:34,750
which i think is kind of similar to what

01:05:31,900 --> 01:05:37,810
you do in the kernel right and this is

01:05:34,750 --> 01:05:43,020
what I had for slides so I would enjoy

01:05:37,810 --> 01:05:51,460
any kind of feedback and I hope you

01:05:43,020 --> 01:05:53,589
understood questions yeah did you try

01:05:51,460 --> 01:05:56,740
any of the existing mechanisms like our

01:05:53,589 --> 01:05:58,450
tier did you try to reload using any of

01:05:56,740 --> 01:06:00,690
the RTL metrics that we already have

01:05:58,450 --> 01:06:03,069
trying to override you know trying to

01:06:00,690 --> 01:06:05,260
mark the symbols in the library as weak

01:06:03,069 --> 01:06:07,660
and then trying to see if you can come

01:06:05,260 --> 01:06:10,240
up with so so the the patch function can

01:06:07,660 --> 01:06:12,310
provide a stronger definition and by

01:06:10,240 --> 01:06:13,690
default I think the support to override

01:06:12,310 --> 01:06:15,280
functions you don't have to do anything

01:06:13,690 --> 01:06:19,210
special

01:06:15,280 --> 01:06:21,160
did you try like for example coming up

01:06:19,210 --> 01:06:25,319
with with a technique that doesn't need

01:06:21,160 --> 01:06:25,319
you to rewrite the library

01:06:25,990 --> 01:06:30,970
okay we in the first in the first moment

01:06:28,869 --> 01:06:35,349
we implemented it completely differently

01:06:30,970 --> 01:06:38,500
or first approach required to you to

01:06:35,349 --> 01:06:40,359
actually add let's say checkpoints to

01:06:38,500 --> 01:06:42,970
your source code and we actually

01:06:40,359 --> 01:06:44,440
considered this to be non fit to our

01:06:42,970 --> 01:06:47,190
requirements because we didn't want to

01:06:44,440 --> 01:06:50,109
rewrite source code I mean it's actually

01:06:47,190 --> 01:06:52,270
much better for us if we have the tools

01:06:50,109 --> 01:06:53,920
changed like we change the compiler we

01:06:52,270 --> 01:06:55,510
change the linker and then we have like

01:06:53,920 --> 01:06:57,730
an offline editor which who goes in the

01:06:55,510 --> 01:07:00,880
binary the binary and fixes the dynamic

01:06:57,730 --> 01:07:02,589
symbol table but this is completely

01:07:00,880 --> 01:07:04,599
transparent to whoever is writing the

01:07:02,589 --> 01:07:06,160
code that you want to make packable so

01:07:04,599 --> 01:07:08,500
we actually tried a different approach

01:07:06,160 --> 01:07:11,020
but we thought it would be better to

01:07:08,500 --> 01:07:13,630
just have tools that fix this for you

01:07:11,020 --> 01:07:16,869
and not requiring programmers to

01:07:13,630 --> 01:07:21,430
actually have to place something inside

01:07:16,869 --> 01:07:23,470
the source code what about the em count

01:07:21,430 --> 01:07:25,080
approach that the kana uses something

01:07:23,470 --> 01:07:27,520
like a minimalistic have trace layer

01:07:25,080 --> 01:07:29,320
you're already generating generating no

01:07:27,520 --> 01:07:30,609
ops so if you had you know if you could

01:07:29,320 --> 01:07:31,869
patch those points you could do

01:07:30,609 --> 01:07:36,910
something similar to what the kernel

01:07:31,869 --> 01:07:40,270
does that's what we do I mean we want

01:07:36,910 --> 01:07:41,950
you to patch the depending depending

01:07:40,270 --> 01:07:44,410
area because I mean if you have two

01:07:41,950 --> 01:07:47,740
treads one might be migrated and the

01:07:44,410 --> 01:07:49,630
other one might not be migrated so what

01:07:47,740 --> 01:07:52,660
happens is that whenever you rewrite the

01:07:49,630 --> 01:07:54,190
departing ops you have to verify if that

01:07:52,660 --> 01:07:57,220
specific thread is reading the new

01:07:54,190 --> 01:07:58,540
universe or not so we kind of do the

01:07:57,220 --> 01:07:59,710
same thing that the kernel does so

01:07:58,540 --> 01:08:02,619
basically we read write contraflow

01:07:59,710 --> 01:08:04,690
towards a function that we're very far

01:08:02,619 --> 01:08:06,609
if this is in the new state or not and

01:08:04,690 --> 01:08:07,839
then it will decide which function it's

01:08:06,609 --> 01:08:09,339
going to execute if it's going to

01:08:07,839 --> 01:08:11,440
execute the other version or the new

01:08:09,339 --> 01:08:14,790
version so it's it's in this sense it's

01:08:11,440 --> 01:08:14,790
quite similar to two kernel patching

01:08:15,180 --> 01:08:22,270
David so how is this current interact

01:08:21,009 --> 01:08:24,850
with some of the control flow

01:08:22,270 --> 01:08:26,529
enforcement technology that's being

01:08:24,850 --> 01:08:28,180
added because if the process for

01:08:26,529 --> 01:08:30,100
instance has been set and the

01:08:28,180 --> 01:08:31,810
application is control phone forest and

01:08:30,100 --> 01:08:33,460
you're now going to start redirecting it

01:08:31,810 --> 01:08:37,480
in the midst of that it's gonna be at

01:08:33,460 --> 01:08:38,859
least tricky to I'm quite aware about

01:08:37,480 --> 01:08:40,570
control flow

01:08:38,859 --> 01:08:44,980
integrity and this kind of techniques I

01:08:40,570 --> 01:08:46,950
actually did a PhD on that but this is

01:08:44,980 --> 01:08:50,230
actually going to be a little bit tricky

01:08:46,950 --> 01:08:54,820
but we think we might be able to fix

01:08:50,230 --> 01:08:57,490
that because of because we might be able

01:08:54,820 --> 01:09:00,010
to use jumps at some places but there's

01:08:57,490 --> 01:09:01,600
like one rat which is when when the

01:09:00,010 --> 01:09:03,640
function returns to the ULP exit

01:09:01,600 --> 01:09:05,380
function so this is something we're not

01:09:03,640 --> 01:09:09,130
quite clear about how we're going to

01:09:05,380 --> 01:09:10,690
solve we thought about that we were just

01:09:09,130 --> 01:09:13,950
like living this problem for a second

01:09:10,690 --> 01:09:13,950
stage but that's definitely a concern

01:09:14,100 --> 01:09:19,480
and actually an interesting thing here

01:09:17,230 --> 01:09:21,220
is that we already like use we call the

01:09:19,480 --> 01:09:23,020
variable shadow but because it's not

01:09:21,220 --> 01:09:24,910
actually actually a stack we just store

01:09:23,020 --> 01:09:27,460
one return address there and not like

01:09:24,910 --> 01:09:29,490
alt calls but what's interesting is that

01:09:27,460 --> 01:09:31,690
I mean this address is already been

01:09:29,490 --> 01:09:33,880
saved somewhere else so there would not

01:09:31,690 --> 01:09:36,580
be a way for somebody to do ROP on that

01:09:33,880 --> 01:09:37,870
specific address but yeah I mean we

01:09:36,580 --> 01:09:39,930
might need to figure figure something

01:09:37,870 --> 01:09:39,930
out

01:09:44,329 --> 01:09:53,540
any more questions does it work when you

01:09:50,750 --> 01:09:55,840
obtained when basically the application

01:09:53,540 --> 01:09:59,090
uses the open and the awesome to obtain

01:09:55,840 --> 01:10:03,679
the symbol from from the library okay

01:09:59,090 --> 01:10:06,739
yeah so what we do I mean currently lip

01:10:03,679 --> 01:10:08,960
pop itself so the thing is lip pop could

01:10:06,739 --> 01:10:11,059
can be LD preloaded so we don't really

01:10:08,960 --> 01:10:14,179
need to link it into the binary just to

01:10:11,059 --> 01:10:17,510
mention that and but lip pop actually

01:10:14,179 --> 01:10:20,780
uses DL open and Yeltsin to find

01:10:17,510 --> 01:10:23,150
whatever needs to be patched so what we

01:10:20,780 --> 01:10:25,400
do is that when we beat race inside the

01:10:23,150 --> 01:10:27,230
application we kind of stop the

01:10:25,400 --> 01:10:29,300
application from running for a while we

01:10:27,230 --> 01:10:31,130
resurrect control flow of the Triads of

01:10:29,300 --> 01:10:34,309
a single thread so it could go through

01:10:31,130 --> 01:10:35,780
some lip pop routines where it's going

01:10:34,309 --> 01:10:37,460
to patch itself or it's going to find

01:10:35,780 --> 01:10:39,349
whatever it has to find and it's going

01:10:37,460 --> 01:10:41,380
to use GL open and Yeltsin and there's

01:10:39,349 --> 01:10:44,449
actually another tricky part here

01:10:41,380 --> 01:10:46,040
because if you be traced inside the

01:10:44,449 --> 01:10:48,199
application in the moment where it was

01:10:46,040 --> 01:10:49,909
running the Ella perdi scene then

01:10:48,199 --> 01:10:52,010
you're gonna have like a deadlock so

01:10:49,909 --> 01:10:53,599
because they're like locks that needs to

01:10:52,010 --> 01:10:56,150
be acquired for using this function same

01:10:53,599 --> 01:10:58,190
goes with malloc for example but we're

01:10:56,150 --> 01:11:03,050
currently not using malloc within the

01:10:58,190 --> 01:11:06,940
Pope but this would be a problem if you

01:11:03,050 --> 01:11:09,860
considered using you probes not really

01:11:06,940 --> 01:11:11,840
I'm not aware about that sorry you can

01:11:09,860 --> 01:11:15,349
actually set up probes in user space

01:11:11,840 --> 01:11:18,770
from the kernel and that guarantees that

01:11:15,349 --> 01:11:20,329
everything in user space stopped yeah I

01:11:18,770 --> 01:11:20,929
mean that's that might be a nice

01:11:20,329 --> 01:11:22,520
approach

01:11:20,929 --> 01:11:24,920
currently we are trying to avoid

01:11:22,520 --> 01:11:26,809
interacting with the kernel the maximum

01:11:24,920 --> 01:11:28,760
we can but it might be the case where we

01:11:26,809 --> 01:11:31,520
cannot just avoid it but currently we're

01:11:28,760 --> 01:11:37,190
trying to not mess with kernel support

01:11:31,520 --> 01:11:40,579
or anything oh do you have the code

01:11:37,190 --> 01:11:44,270
anywhere yes the code for lip bulb is

01:11:40,579 --> 01:11:47,329
actually available in the Sousa github

01:11:44,270 --> 01:11:50,840
organization so it's github.com likes to

01:11:47,329 --> 01:11:52,940
say it's like sleep pop I apologize the

01:11:50,840 --> 01:11:55,010
git is a little bit messy because this

01:11:52,940 --> 01:11:57,139
thing is very prototypes in a very

01:11:55,010 --> 01:11:58,010
prototype stage but the latest version

01:11:57,139 --> 01:11:59,960
is there

01:11:58,010 --> 01:12:04,400
it's a little bit different from what I

01:11:59,960 --> 01:12:07,130
presented because the individual thread

01:12:04,400 --> 01:12:09,739
migration is not completely done yet

01:12:07,130 --> 01:12:12,170
so it completely depends on having no

01:12:09,739 --> 01:12:14,929
threads outside the library for it to be

01:12:12,170 --> 01:12:18,230
passable but pretty much everything else

01:12:14,929 --> 01:12:21,320
is there so the binary rewriting tools

01:12:18,230 --> 01:12:24,199
the compiler the company the linker

01:12:21,320 --> 01:12:33,650
patches and and allows I mean there

01:12:24,199 --> 01:12:35,780
could someone overwrite what the pulp is

01:12:33,650 --> 01:12:37,579
doing in the sense that does it allow

01:12:35,780 --> 01:12:39,230
multiple batches to exist and a lot of

01:12:37,579 --> 01:12:41,960
security tools tend to patch similar

01:12:39,230 --> 01:12:43,940
functions can they come in and hurt what

01:12:41,960 --> 01:12:52,400
the pulp is trying to do because they're

01:12:43,940 --> 01:12:54,889
trying to patch the same functions yeah

01:12:52,400 --> 01:12:57,829
coexistence of other patches like can

01:12:54,889 --> 01:12:59,150
somebody else patch the same binary for

01:12:57,829 --> 01:13:01,579
security reasons you know a lot of

01:12:59,150 --> 01:13:02,719
security tools will go patch similar

01:13:01,579 --> 01:13:06,079
functions that you want to patch for

01:13:02,719 --> 01:13:07,730
life patching what do they have to do so

01:13:06,079 --> 01:13:13,639
that their patches can nest with live

01:13:07,730 --> 01:13:15,320
bulk okay so I mean if they want to use

01:13:13,639 --> 01:13:17,179
the same structures that live pop uses

01:13:15,320 --> 01:13:19,070
because we keep track of whatever spatch

01:13:17,179 --> 01:13:21,980
in so you can actually refer that if you

01:13:19,070 --> 01:13:24,230
want they would need to follow the the

01:13:21,980 --> 01:13:25,699
API that we have defined there the API

01:13:24,230 --> 01:13:27,139
is actually quite simple the data

01:13:25,699 --> 01:13:29,719
structures electrics were quite simple

01:13:27,139 --> 01:13:31,369
so another library we would just need to

01:13:29,719 --> 01:13:33,739
have these routines

01:13:31,369 --> 01:13:36,019
I guess that reuse this routine from the

01:13:33,739 --> 01:13:37,969
pub that write the data structures

01:13:36,019 --> 01:13:39,199
there's and then just just go through I

01:13:37,969 --> 01:13:42,469
mean and leap pop actually makes it

01:13:39,199 --> 01:13:44,179
quite easy for for me in touchable I

01:13:42,469 --> 01:13:46,909
mean if you are writing like a library

01:13:44,179 --> 01:13:47,989
and you want to make it legible all you

01:13:46,909 --> 01:13:51,050
have to do is to care in the

01:13:47,989 --> 01:13:52,940
distribution process so my question was

01:13:51,050 --> 01:13:56,179
more along the coexistence of patches so

01:13:52,940 --> 01:13:57,530
if you had patched a function for if

01:13:56,179 --> 01:13:59,840
there is already a patch that was

01:13:57,530 --> 01:14:02,179
applied through some other mechanism

01:13:59,840 --> 01:14:03,619
would lip bulk keep that patch and nest

01:14:02,179 --> 01:14:04,210
through it or would it just throw it

01:14:03,619 --> 01:14:07,070
away

01:14:04,210 --> 01:14:09,170
okay so I think it would depend on how

01:14:07,070 --> 01:14:11,490
the other patch was applied but as long

01:14:09,170 --> 01:14:14,850
as the other patch does not

01:14:11,490 --> 01:14:16,110
mess with the with the entry point of

01:14:14,850 --> 01:14:18,540
the function then it would be fine

01:14:16,110 --> 01:14:19,980
because I mean problem is if you patch

01:14:18,540 --> 01:14:22,650
another if you patch a function but you

01:14:19,980 --> 01:14:23,940
were actually changing the the the

01:14:22,650 --> 01:14:25,650
prologue like the pairing knobs or

01:14:23,940 --> 01:14:27,090
something like that then yeah then leap

01:14:25,650 --> 01:14:31,650
hope we were right that at some point

01:14:27,090 --> 01:14:33,030
and this might be a problem okay yeah we

01:14:31,650 --> 01:14:43,680
have one more minute so maybe one more

01:14:33,030 --> 01:14:47,820
question okay easy one please yeah it's

01:14:43,680 --> 01:14:53,010
it's not have you got a demo if I got a

01:14:47,820 --> 01:14:54,390
demo yes yes you asked because I was

01:14:53,010 --> 01:14:57,800
wondering if somebody would be

01:14:54,390 --> 01:14:57,800
interested in seeing this

01:15:25,700 --> 01:15:28,360
that

01:15:38,070 --> 01:15:44,230
okay oh you're gonna hang for me yes I

01:15:41,230 --> 01:15:55,390
feel special now so what we have here

01:15:44,230 --> 01:15:57,340
where's my mouse okay I have this this

01:15:55,390 --> 01:16:02,160
thing built here so I'll just go

01:15:57,340 --> 01:16:02,160
directly to the RPMs oh they're not here

01:16:22,660 --> 01:16:26,960
I'm currently I can't remember or I

01:16:25,370 --> 01:16:30,170
haven't cell installed in though I don't

01:16:26,960 --> 01:16:32,290
have so I just try to reinstall

01:16:30,170 --> 01:16:32,290
everything

01:16:37,989 --> 01:16:47,980
I think this one is already there yeah

01:16:41,980 --> 01:16:49,780
I'll try the dummy app it's also already

01:16:47,980 --> 01:16:52,360
there so I'll just run

01:16:49,780 --> 01:16:55,510
I'm actually here what I have is a dummy

01:16:52,360 --> 01:16:57,370
library with that just to print messages

01:16:55,510 --> 01:17:15,219
and I'll try to replace this function

01:16:57,370 --> 01:17:19,630
which is printing messages I'll try to

01:17:15,219 --> 01:17:23,070
patch this so I'm pretty sure I didn't

01:17:19,630 --> 01:17:23,070
stall the life pack before

01:17:36,850 --> 01:17:41,010
so hopefully I won't embarrass myself

01:17:41,940 --> 01:17:48,790
yes and now we change the function there

01:17:46,320 --> 01:17:52,450
actually we we have this whole thing

01:17:48,790 --> 01:17:54,790
implemented in different rpm we actually

01:17:52,450 --> 01:17:57,010
have like some Lua application running

01:17:54,790 --> 01:17:58,960
behind it behind the RPM that actually

01:17:57,010 --> 01:18:01,000
checks all processes which are which are

01:17:58,960 --> 01:18:03,040
using the library and the process which

01:18:01,000 --> 01:18:05,320
are running the library tries to verify

01:18:03,040 --> 01:18:10,930
if it's already patched or not and then

01:18:05,320 --> 01:18:12,820
it will verify if we poke was loaded or

01:18:10,930 --> 01:18:14,230
not and if that's the case I mean if

01:18:12,820 --> 01:18:16,780
everything is in the right place then it

01:18:14,230 --> 01:18:18,610
will apply to bash my coffee trace it's

01:18:16,780 --> 01:18:21,280
actually it's a code written in C then a

01:18:18,610 --> 01:18:23,800
5 patch so it you just call this C code

01:18:21,280 --> 01:18:26,590
which will be traced into the

01:18:23,800 --> 01:18:28,360
application and do whatever is needed as

01:18:26,590 --> 01:18:30,760
you have seen there's some stuff that

01:18:28,360 --> 01:18:32,410
needs to be done to make it like clean I

01:18:30,760 --> 01:18:47,080
mean the signals are is to show it in

01:18:32,410 --> 01:18:49,210
the shell but before it's quite ok so I

01:18:47,080 --> 01:18:51,280
think we're done with the time right

01:18:49,210 --> 01:18:52,990
Eugene okay thank you everyone if you

01:18:51,280 --> 01:18:56,430
want to discuss this I'll be around

01:18:52,990 --> 01:18:56,430
I'll be in the pub tonight

01:20:23,710 --> 01:20:47,969
oh sorry thank you so you know we've

01:20:41,850 --> 01:20:52,030
found life patch really useful and so

01:20:47,969 --> 01:20:54,250
you know I work at Akamai sorry and we

01:20:52,030 --> 01:20:59,260
have you know hundreds of thousands of

01:20:54,250 --> 01:21:00,700
servers we follow the stable kernel so

01:20:59,260 --> 01:21:05,860
for example right now we're running

01:21:00,700 --> 01:21:08,050
mostly 414 and you know we've we find

01:21:05,860 --> 01:21:11,950
you know live patch really useful for

01:21:08,050 --> 01:21:14,860
security fixes and we'd like to use it

01:21:11,950 --> 01:21:20,160
more but frankly we have a very small

01:21:14,860 --> 01:21:22,900
kernel team and we don't necessarily

01:21:20,160 --> 01:21:26,410
have the time to to go through each

01:21:22,900 --> 01:21:29,739
patch and sort of verify it I've also

01:21:26,410 --> 01:21:33,670
spoken with a number of people in

01:21:29,739 --> 01:21:35,830
various other companies who are very

01:21:33,670 --> 01:21:39,010
interested in live patch follow

01:21:35,830 --> 01:21:42,010
long-term stable and I think would

01:21:39,010 --> 01:21:47,940
potentially be interested in using live

01:21:42,010 --> 01:21:51,640
patch more so I'm hoping that there's

01:21:47,940 --> 01:21:56,590
you know interest in the community in

01:21:51,640 --> 01:21:58,420
this and so I also spoken with people

01:21:56,590 --> 01:22:00,969
you know like for Android I know for

01:21:58,420 --> 01:22:03,700
example there's even interest because

01:22:00,969 --> 01:22:05,260
you know the live patch module is you

01:22:03,700 --> 01:22:06,610
know is a lot smaller than you know

01:22:05,260 --> 01:22:11,320
downloading a whole new kernel and

01:22:06,610 --> 01:22:13,650
rebooting and so forth so I wanted to

01:22:11,320 --> 01:22:16,630
kind of go through some of the issues

01:22:13,650 --> 01:22:20,170
and you know I'm sure you guys have

01:22:16,630 --> 01:22:22,960
really good ideas around you know what

01:22:20,170 --> 01:22:25,800
what they are and you know and so forth

01:22:22,960 --> 01:22:28,690
assuming there's you know interest in it

01:22:25,800 --> 01:22:29,979
so I also talked a little with Greg gage

01:22:28,690 --> 01:22:33,190
about it and

01:22:29,979 --> 01:22:35,619
he seemed like he would potentially be

01:22:33,190 --> 01:22:39,820
interested in running white patch

01:22:35,619 --> 01:22:41,739
modules through his test suite you know

01:22:39,820 --> 01:22:46,989
if that was something we could provide

01:22:41,739 --> 01:22:49,590
him so anyway I have two slides so

01:22:46,989 --> 01:22:54,130
hopefully that's not over the limit

01:22:49,590 --> 01:22:55,989
so all right so this is just you know

01:22:54,130 --> 01:22:58,389
first of all you know how many people

01:22:55,989 --> 01:23:01,329
are really interested in this

01:22:58,389 --> 01:23:05,979
I think there's interest in it I'm not

01:23:01,329 --> 01:23:10,719
aware of too much discussion about it

01:23:05,979 --> 01:23:12,789
I think you know a lot of the people

01:23:10,719 --> 01:23:14,739
have been doing you know people get life

01:23:12,789 --> 01:23:18,820
patch mostly I think through you know

01:23:14,739 --> 01:23:22,090
like Ubuntu or Red Hat and so forth

01:23:18,820 --> 01:23:27,309
so you know how much of this can we

01:23:22,090 --> 01:23:30,280
automate do we you know there's you know

01:23:27,309 --> 01:23:34,900
a bunch of tools obviously for creating

01:23:30,280 --> 01:23:36,820
life patches one idea was like you know

01:23:34,900 --> 01:23:40,030
every time there's like a stable patch

01:23:36,820 --> 01:23:44,289
that comes out you know could we you

01:23:40,030 --> 01:23:46,150
know sort of automatically try it and

01:23:44,289 --> 01:23:50,130
sort of try it out and see you know it

01:23:46,150 --> 01:23:52,719
doesn't need fix ups or or whatnot

01:23:50,130 --> 01:23:55,179
testing is obviously a big one so like I

01:23:52,719 --> 01:23:57,959
said Greg Gage said he was sort of

01:23:55,179 --> 01:24:00,130
interested potentially in testing these

01:23:57,959 --> 01:24:03,639
another question I had was around

01:24:00,130 --> 01:24:06,489
whether we would need you know so the

01:24:03,639 --> 01:24:09,130
stable core you know Greg releases his

01:24:06,489 --> 01:24:11,050
kernel and like a lot of the impetus to

01:24:09,130 --> 01:24:12,760
have life patches to have them be very

01:24:11,050 --> 01:24:15,760
timely cuz therefore important security

01:24:12,760 --> 01:24:17,619
issues so would we need access or if

01:24:15,760 --> 01:24:20,619
somebody was creating a live patch would

01:24:17,619 --> 01:24:24,039
they need access sort of to that

01:24:20,619 --> 01:24:25,869
information earlier such that the live

01:24:24,039 --> 01:24:28,090
patch could come out sort of at the same

01:24:25,869 --> 01:24:31,719
time there may be some issues around

01:24:28,090 --> 01:24:34,389
that and then it's just about sort of

01:24:31,719 --> 01:24:36,309
which trees we could support I think

01:24:34,389 --> 01:24:38,590
also there's certainly patches right now

01:24:36,309 --> 01:24:40,469
we were talking about you know before

01:24:38,590 --> 01:24:42,909
about stopping the kernel there's

01:24:40,469 --> 01:24:43,869
patches right now that we potentially

01:24:42,909 --> 01:24:47,619
don't know how to deal

01:24:43,869 --> 01:24:50,230
or we will eventually but right now we

01:24:47,619 --> 01:24:53,949
can't so do we say at some point in the

01:24:50,230 --> 01:24:57,310
past stream okay right now dispatch we

01:24:53,949 --> 01:25:01,090
can't do your honor you know we're not

01:24:57,310 --> 01:25:02,860
live patching that I don't know those

01:25:01,090 --> 01:25:04,210
were some of the issues I think you know

01:25:02,860 --> 01:25:09,400
there's mostly meant to be a discussion

01:25:04,210 --> 01:25:13,590
around you know or you know if there's

01:25:09,400 --> 01:25:17,230
other people interested in this I think

01:25:13,590 --> 01:25:19,050
you know we if if we could you know work

01:25:17,230 --> 01:25:22,840
together on it you know there would be

01:25:19,050 --> 01:25:24,520
it would certainly benefit us I guess

01:25:22,840 --> 01:25:28,300
you probably don't want to start with

01:25:24,520 --> 01:25:30,340
basically setting the target of to

01:25:28,300 --> 01:25:32,380
generate life match for each and every

01:25:30,340 --> 01:25:35,409
patch that goes through stable that's

01:25:32,380 --> 01:25:38,500
that's a very that's a very high bar for

01:25:35,409 --> 01:25:40,300
start because basically we as a distro

01:25:38,500 --> 01:25:42,040
we dispute life patches we have some

01:25:40,300 --> 01:25:44,020
criteria which patches actually do

01:25:42,040 --> 01:25:45,760
qualify for life patches and that's far

01:25:44,020 --> 01:25:49,000
smaller group that what actually goes to

01:25:45,760 --> 01:25:53,349
stable so we generalized life which is

01:25:49,000 --> 01:25:58,300
only four CVEs core was it's seven plus

01:25:53,349 --> 01:26:01,300
six seven plus or data corruption or

01:25:58,300 --> 01:26:05,170
major stability issue and even for that

01:26:01,300 --> 01:26:08,560
it basically takes two people full-time

01:26:05,170 --> 01:26:10,540
basically so if you would like to

01:26:08,560 --> 01:26:11,520
generate life but because it's it's as

01:26:10,540 --> 01:26:13,599
you've seen from the previous

01:26:11,520 --> 01:26:17,230
presentation it's not fully automatic

01:26:13,599 --> 01:26:18,580
yet it's a lot of manual work so I think

01:26:17,230 --> 01:26:20,710
currently with the current tooling at

01:26:18,580 --> 01:26:22,330
this we have generating live page for

01:26:20,710 --> 01:26:25,420
each and every page contained in stable

01:26:22,330 --> 01:26:28,440
is not realistic unless you have an army

01:26:25,420 --> 01:26:32,780
of monkeys doing it basically

01:26:28,440 --> 01:26:35,940
[Laughter]

01:26:32,780 --> 01:26:37,440
so in the discussion we had I think last

01:26:35,940 --> 01:26:39,900
night or the day before we were talking

01:26:37,440 --> 01:26:41,700
about at least doing some of the things

01:26:39,900 --> 01:26:44,820
you mentioned that you do being able to

01:26:41,700 --> 01:26:46,380
tag something as life patchable and I

01:26:44,820 --> 01:26:48,120
think that largely depends on the stable

01:26:46,380 --> 01:26:49,739
maintainer maybe they could use the same

01:26:48,120 --> 01:26:52,170
filtering criteria that you have and

01:26:49,739 --> 01:26:54,720
Mark something - the life patch mailing

01:26:52,170 --> 01:26:56,250
list or CC the life patch mailing lists

01:26:54,720 --> 01:26:58,860
that would be a good starting point and

01:26:56,250 --> 01:26:59,880
then the life patch mailing list or you

01:26:58,860 --> 01:27:02,280
know another list couldn't decide

01:26:59,880 --> 01:27:05,489
whether this is liable and what life

01:27:02,280 --> 01:27:07,230
matching the second thing is of course

01:27:05,489 --> 01:27:09,600
if the patch is too complex there's

01:27:07,230 --> 01:27:11,010
there's not much to do in which case for

01:27:09,600 --> 01:27:12,780
life path we may want to do a separate

01:27:11,010 --> 01:27:14,760
you know we may want to do additional

01:27:12,780 --> 01:27:19,590
work to see if we can come up with a

01:27:14,760 --> 01:27:21,510
patch in source form that can be posted

01:27:19,590 --> 01:27:25,470
on the list or a github tree that can be

01:27:21,510 --> 01:27:27,540
maintained those might be good starting

01:27:25,470 --> 01:27:28,860
places in my opinion and I think the

01:27:27,540 --> 01:27:30,570
third thing that we're missing here is

01:27:28,860 --> 01:27:32,910
the test infrastructure we do all of

01:27:30,570 --> 01:27:35,120
this and we ship it without testing I

01:27:32,910 --> 01:27:39,360
think it's going to be disastrous I

01:27:35,120 --> 01:27:41,130
think that's a good point that we want

01:27:39,360 --> 01:27:43,380
to have a good impression of life patch

01:27:41,130 --> 01:27:49,830
so we don't want to just throw our

01:27:43,380 --> 01:27:55,380
patches and then have them not work so -

01:27:49,830 --> 01:27:58,739
or regarding testing a small part of

01:27:55,380 --> 01:28:01,950
atomic replaced by cell holds a self

01:27:58,739 --> 01:28:05,330
test thanks to you thanks to Joe from

01:28:01,950 --> 01:28:09,510
from redhead say it should be upstream

01:28:05,330 --> 01:28:15,150
soonish say I think it's a good starting

01:28:09,510 --> 01:28:17,010
point so what I kind of missed part of

01:28:15,150 --> 01:28:19,830
that point what what self tested the

01:28:17,010 --> 01:28:22,320
earth test for myself test for their

01:28:19,830 --> 01:28:26,040
life pitching infrastructure but it's

01:28:22,320 --> 01:28:31,470
not like test for for the real life

01:28:26,040 --> 01:28:34,380
 like right so say say this may

01:28:31,470 --> 01:28:37,290
be a little bit schizophrenic because in

01:28:34,380 --> 01:28:41,040
upstream there is only only a framework

01:28:37,290 --> 01:28:43,530
which is in the kernel and users are

01:28:41,040 --> 01:28:49,650
somewhere else

01:28:43,530 --> 01:28:53,220
yes we at Sousa are both framework

01:28:49,650 --> 01:28:56,910
maintain us and and users so we provide

01:28:53,220 --> 01:29:01,170
this life purchase as well I not sure if

01:28:56,910 --> 01:29:04,890
we as an upstream community when wanted

01:29:01,170 --> 01:29:08,360
to do something about by users in a way

01:29:04,890 --> 01:29:14,280
that we would provide life matches for

01:29:08,360 --> 01:29:17,940
for trees I don't know because as he

01:29:14,280 --> 01:29:18,780
said it's it takes a lot lot of men

01:29:17,940 --> 01:29:21,090
manpower

01:29:18,780 --> 01:29:29,190
did you actually prepare this life by

01:29:21,090 --> 01:29:31,050
she say you'd also have to decide are

01:29:29,190 --> 01:29:32,880
you gonna support when we when we bought

01:29:31,050 --> 01:29:36,150
a life hatch is specific to a certain

01:29:32,880 --> 01:29:39,150
build of the kernel right so you have to

01:29:36,150 --> 01:29:41,640
decide you know which am I going to

01:29:39,150 --> 01:29:43,830
support every stable kernel release like

01:29:41,640 --> 01:29:48,170
if there's a CV that comes out I'm gonna

01:29:43,830 --> 01:29:52,200
fix it fer of 4.16 dot one for the

01:29:48,170 --> 01:29:55,820
starting point well you just you just

01:29:52,200 --> 01:29:59,400
have to you know the more kernels you

01:29:55,820 --> 01:30:00,150
backport the live patch for there's more

01:29:59,400 --> 01:30:02,100
things can go wrong

01:30:00,150 --> 01:30:03,630
more testings needed but I think there's

01:30:02,100 --> 01:30:05,670
a good point something I thought a

01:30:03,630 --> 01:30:08,040
little bit about is like okay yeah you

01:30:05,670 --> 01:30:10,310
have a stable patch that's more type

01:30:08,040 --> 01:30:13,050
priority but yeah which ones are you

01:30:10,310 --> 01:30:19,470
piecing it from it which part of this

01:30:13,050 --> 01:30:21,660
dream yeah how far do you go back one

01:30:19,470 --> 01:30:23,550
idea around that was maybe like we said

01:30:21,660 --> 01:30:26,610
some things were not life patchable and

01:30:23,550 --> 01:30:30,570
maybe those are sort of the points that

01:30:26,610 --> 01:30:33,440
sort of limits it a little bit but yeah

01:30:30,570 --> 01:30:33,440
that's a good point

01:30:35,940 --> 01:30:39,990
one thing would be like for example if

01:30:38,730 --> 01:30:42,000
we're going to have schematic changes

01:30:39,990 --> 01:30:44,400
then who's going to be the person who's

01:30:42,000 --> 01:30:45,510
going to do the changes for they know do

01:30:44,400 --> 01:30:47,630
the additional changes which are

01:30:45,510 --> 01:30:51,030
required as such to generate the light

01:30:47,630 --> 01:30:53,220
so that'll be one complex thing right

01:30:51,030 --> 01:30:54,930
like if there are going to be like data

01:30:53,220 --> 01:30:57,210
structure changes or function schematic

01:30:54,930 --> 01:30:59,370
changes that would mean that just this

01:30:57,210 --> 01:31:01,739
we batch this not suffice you need to

01:30:59,370 --> 01:31:03,870
alter the batch well yeah I think though

01:31:01,739 --> 01:31:05,489
so the Lincoln are right so I think

01:31:03,870 --> 01:31:08,670
that's one of the points is that for a

01:31:05,489 --> 01:31:10,680
lot of the patches you know or I would

01:31:08,670 --> 01:31:13,230
say you guys would know better than me

01:31:10,680 --> 01:31:14,610
but I'd say at least in my experience a

01:31:13,230 --> 01:31:17,489
lot of the patches don't don't actually

01:31:14,610 --> 01:31:19,380
need any changes especially in LTS like

01:31:17,489 --> 01:31:22,080
because they're smaller they tend to be

01:31:19,380 --> 01:31:24,420
smaller target of fixes but yeah that

01:31:22,080 --> 01:31:26,460
that's mostly what the point of this is

01:31:24,420 --> 01:31:30,480
for is the ones that do require extra

01:31:26,460 --> 01:31:33,860
work because otherwise you just sort of

01:31:30,480 --> 01:31:39,090
you know the patch as is sort of works

01:31:33,860 --> 01:31:42,480
so I actually would guess that most of

01:31:39,090 --> 01:31:46,380
them don't actually at least in my

01:31:42,480 --> 01:31:50,400
experience don't actually require too

01:31:46,380 --> 01:31:53,010
much extra or any changes but yeah that

01:31:50,400 --> 01:31:55,320
that's where the I'm trying to get

01:31:53,010 --> 01:32:02,580
people interested in in doing those more

01:31:55,320 --> 01:32:06,450
complex ones so how might you multiple

01:32:02,580 --> 01:32:09,780
patches would we be creating like like a

01:32:06,450 --> 01:32:13,200
stream for a particular you know staple

01:32:09,780 --> 01:32:16,620
kernel and you could post a patch for

01:32:13,200 --> 01:32:18,690
one CVE but then maybe subsequent you

01:32:16,620 --> 01:32:22,110
know Seavey's end up changing the same

01:32:18,690 --> 01:32:33,000
function there for your input patch may

01:32:22,110 --> 01:32:35,980
have to yeah cumulate fixes yeah i mean

01:32:33,000 --> 01:32:37,219
if if your reap a qing the same function

01:32:35,980 --> 01:32:39,840
[Music]

01:32:37,219 --> 01:32:43,350
yeah we'd have to define points like

01:32:39,840 --> 01:32:45,690
like Josh was saying before where you

01:32:43,350 --> 01:32:48,510
know we're we're patching from perhaps

01:32:45,690 --> 01:32:50,969
they serve as kind of a sample or a

01:32:48,510 --> 01:32:53,400
model patch for that CV and then if you

01:32:50,969 --> 01:32:55,530
want to distribute it for you know

01:32:53,400 --> 01:32:58,290
whatever release or whatever it's up to

01:32:55,530 --> 01:33:00,210
you to then combine the C exists and

01:32:58,290 --> 01:33:02,430
that sort of happens with LTS now so a

01:33:00,210 --> 01:33:04,110
lot of people that are on LTS have their

01:33:02,430 --> 01:33:06,909
own patches already so they sort of have

01:33:04,110 --> 01:33:10,469
to do that integration already

01:33:06,909 --> 01:33:10,469
so it's sort of similar in that sense

01:33:11,400 --> 01:33:16,989
so assuming let's say for example used

01:33:14,679 --> 01:33:20,350
kay patch build to build your patches

01:33:16,989 --> 01:33:24,460
just because a patch builds doesn't mean

01:33:20,350 --> 01:33:26,380
it's safe so part of that effort is

01:33:24,460 --> 01:33:29,620
gonna be you know analyzing the patches

01:33:26,380 --> 01:33:31,900
somebody you know if you get you need

01:33:29,620 --> 01:33:32,949
people you know resources basically to

01:33:31,900 --> 01:33:35,650
do that

01:33:32,949 --> 01:33:38,050
for the analysis you know not just in

01:33:35,650 --> 01:33:42,250
and also conversion if if it needs to be

01:33:38,050 --> 01:33:45,130
converted I think part of the issue here

01:33:42,250 --> 01:33:47,590
is you know there is a lot of work that

01:33:45,130 --> 01:33:48,940
goes I think a bunch of people said that

01:33:47,590 --> 01:33:53,260
there is a lot of work that goes into

01:33:48,940 --> 01:33:55,150
each patch so if you know if there's

01:33:53,260 --> 01:33:57,760
enough community interest in it maybe it

01:33:55,150 --> 01:33:59,500
would work but that's the question I

01:33:57,760 --> 01:34:01,270
would have so who's basically I actually

01:33:59,500 --> 01:34:04,659
don't have a good overview who is

01:34:01,270 --> 01:34:06,550
currently running on LTS so it's Android

01:34:04,659 --> 01:34:08,260
probably is one of the users right so

01:34:06,550 --> 01:34:10,510
they might be interested and who else

01:34:08,260 --> 01:34:12,699
who would be actually willing and able

01:34:10,510 --> 01:34:15,400
to contribute manpower to creating the

01:34:12,699 --> 01:34:18,610
patches is actually using LTS right I

01:34:15,400 --> 01:34:21,429
don't know right you know we can discuss

01:34:18,610 --> 01:34:23,620
it more and maybe not a lot of people

01:34:21,429 --> 01:34:25,750
aren't in this area but you know can be

01:34:23,620 --> 01:34:31,570
discussing a lot of stiff okay it sounds

01:34:25,750 --> 01:34:33,429
like there's some interest I think we

01:34:31,570 --> 01:34:35,010
should ask on the list there might be

01:34:33,429 --> 01:34:39,130
interest and maybe Linux Foundation

01:34:35,010 --> 01:34:41,080
could be another source of this input

01:34:39,130 --> 01:34:43,239
because they you know we could go to

01:34:41,080 --> 01:34:45,070
them and ask them for manpower right I

01:34:43,239 --> 01:34:46,510
feel like you know if we did get to this

01:34:45,070 --> 01:34:49,000
point I think it would help you know

01:34:46,510 --> 01:34:51,120
hopefully advanced life patch maybe get

01:34:49,000 --> 01:34:55,750
more interested in advanced it more so

01:34:51,120 --> 01:34:58,810
hopefully it would help everybody yeah

01:34:55,750 --> 01:35:01,150
just that I think that what you are

01:34:58,810 --> 01:35:04,420
going to do is something similar what

01:35:01,150 --> 01:35:06,610
does like Elise for Gen 2 because it

01:35:04,420 --> 01:35:10,050
sounds like you would like to provide

01:35:06,610 --> 01:35:15,219
life pitches for people that basically

01:35:10,050 --> 01:35:18,400
like as a service like that you will not

01:35:15,219 --> 01:35:19,429
provide the binaries but like some way

01:35:18,400 --> 01:35:24,710
how to

01:35:19,429 --> 01:35:28,370
convert sources or patches into binary

01:35:24,710 --> 01:35:33,500
module which is basically like Gentoo

01:35:28,370 --> 01:35:38,050
works that basically you know I guess

01:35:33,500 --> 01:35:38,050
that you are not going to provide like

01:35:38,110 --> 01:35:46,550
because I guess that LTS kernels are not

01:35:43,699 --> 01:35:55,699
provided as like buying binaries but as

01:35:46,550 --> 01:36:00,230
a sources right yeah yeah so you

01:35:55,699 --> 01:36:03,320
basically are going to do something like

01:36:00,230 --> 01:36:08,750
like like gentle with that with there a

01:36:03,320 --> 01:36:19,159
life patch approach that just get some

01:36:08,750 --> 01:36:22,219
like a cheese and then yeah so you might

01:36:19,159 --> 01:36:26,120
be interesting to do next dog okay so

01:36:22,219 --> 01:36:28,909
anyway it will get much easier with all

01:36:26,120 --> 01:36:32,030
the automation we work on currently so

01:36:28,909 --> 01:36:34,100
then me we can do something about it

01:36:32,030 --> 01:36:37,250
maybe yeah I mean one thought is maybe

01:36:34,100 --> 01:36:37,790
we're not really ready for to do that

01:36:37,250 --> 01:36:42,320
it's too much

01:36:37,790 --> 01:36:51,320
yeah I think it's too much no yeah but

01:36:42,320 --> 01:36:58,850
yeah why not we use keep us both okay so

01:36:51,320 --> 01:37:02,199
I've used it okay I think it's time for

01:36:58,850 --> 01:37:03,320
a break so alright

01:37:02,199 --> 01:37:07,240
you

01:37:03,320 --> 01:37:07,240
[Applause]

01:37:07,369 --> 01:37:14,909
hi i'm anna chiatti and i'm working for

01:37:10,560 --> 01:37:20,060
several tries to japan and this project

01:37:14,909 --> 01:37:29,940
is part of a gentle kernel project and

01:37:20,060 --> 01:37:33,179
today I will talk about elect patch day

01:37:29,940 --> 01:37:37,679
patch is a flexible framework for life

01:37:33,179 --> 01:37:40,590
patch and the motivation under alive

01:37:37,679 --> 01:37:46,590
patches with some distribution started

01:37:40,590 --> 01:37:50,340
to have left patch for I usually get

01:37:46,590 --> 01:37:51,780
stressed when I'm at work so some

01:37:50,340 --> 01:37:53,219
distribution started to have a left

01:37:51,780 --> 01:37:57,150
patch for fixing security bugs

01:37:53,219 --> 01:38:00,330
temporarily and where we can use it on

01:37:57,150 --> 01:38:04,350
same kernel binary file configuration

01:38:00,330 --> 01:38:07,350
and GCC version engine - we don't have

01:38:04,350 --> 01:38:10,199
such user case every user - particle you

01:38:07,350 --> 01:38:14,100
want we want we install kernel version

01:38:10,199 --> 01:38:15,869
we put connect configuration and web GCC

01:38:14,100 --> 01:38:21,780
with different versioning some cases

01:38:15,869 --> 01:38:24,449
different optimization so LF patch is

01:38:21,780 --> 01:38:29,520
trying to simplify and reproduce the

01:38:24,449 --> 01:38:33,980
system in such situation so we also

01:38:29,520 --> 01:38:37,350
found that various little support for

01:38:33,980 --> 01:38:42,000
from life bus service for user case when

01:38:37,350 --> 01:38:45,900
the user want to send the patch for be

01:38:42,000 --> 01:38:47,730
converted into a life path object and

01:38:45,900 --> 01:38:51,090
you really just get what the

01:38:47,730 --> 01:38:52,790
distribution is sending to you so you

01:38:51,090 --> 01:38:57,300
need to say to trust your distribution

01:38:52,790 --> 01:38:59,909
and because there is no contribution

01:38:57,300 --> 01:39:02,719
from the user user doesn't collaborating

01:38:59,909 --> 01:39:08,010
in making this passion creation process

01:39:02,719 --> 01:39:13,710
so in some case this processes close

01:39:08,010 --> 01:39:16,230
source so any patch is trying to solve

01:39:13,710 --> 01:39:19,080
this process by creating an open source

01:39:16,230 --> 01:39:20,940
collaborative ecosystem around life

01:39:19,080 --> 01:39:25,020
patch when use

01:39:20,940 --> 01:39:27,570
can collaborate for making into a life

01:39:25,020 --> 01:39:33,900
patch left patch passing creation

01:39:27,570 --> 01:39:38,640
process and they could also create a own

01:39:33,900 --> 01:39:48,210
repository where they came 19 and share

01:39:38,640 --> 01:39:51,180
the patch each other and but this system

01:39:48,210 --> 01:39:54,239
is still experimental we started to make

01:39:51,180 --> 01:40:00,330
such things and now what we are trying

01:39:54,239 --> 01:40:03,120
to get is is in mimic in some cases not

01:40:00,330 --> 01:40:05,910
working and so we want to get feedback

01:40:03,120 --> 01:40:09,300
from the user so that we can make it

01:40:05,910 --> 01:40:14,580
better and so we are trying to get

01:40:09,300 --> 01:40:20,940
feedback so if you want to try and use

01:40:14,580 --> 01:40:23,280
please send feedback and there are still

01:40:20,940 --> 01:40:27,780
many problem and one of the problem is

01:40:23,280 --> 01:40:33,500
that we are trying to make it the life

01:40:27,780 --> 01:40:33,500
patch process more simple and

01:40:36,710 --> 01:40:44,190
here we are using capabilities came in

01:40:40,739 --> 01:40:53,120
help for ultimate izing the life patch

01:40:44,190 --> 01:40:58,400
patching process and we also think that

01:40:53,120 --> 01:41:11,610
user can collaborate each other for

01:40:58,400 --> 01:41:14,010
making this patch and us now we are also

01:41:11,610 --> 01:41:17,219
doing about better system

01:41:14,010 --> 01:41:21,890
reproducibility we are reproducing it

01:41:17,219 --> 01:41:21,890
Ave kernel the kernel configuration and

01:41:23,660 --> 01:41:31,290
invest soul and we think in the future

01:41:25,980 --> 01:41:36,350
to try to as yesterday was disgusted try

01:41:31,290 --> 01:41:40,199
to reproduce also same GCC version and

01:41:36,350 --> 01:41:43,240
to use container for doing making same

01:41:40,199 --> 01:41:46,319
system of the user

01:41:43,240 --> 01:41:46,319
[Music]

01:41:51,440 --> 01:41:54,160
so

01:42:01,889 --> 01:42:08,320
to another things with it can be much is

01:42:05,920 --> 01:42:11,860
for continuous integration and

01:42:08,320 --> 01:42:14,020
continuous deployment to check so you

01:42:11,860 --> 01:42:17,920
can send the patch to a left patch and

01:42:14,020 --> 01:42:26,949
it will check in some system that is

01:42:17,920 --> 01:42:30,280
working and because we are making this

01:42:26,949 --> 01:42:35,290
we are trying to make with a left patch

01:42:30,280 --> 01:42:39,460
repository where user can maintain and

01:42:35,290 --> 01:42:42,369
collaborate making patch we are thinking

01:42:39,460 --> 01:42:49,540
if maybe we can have someone but is

01:42:42,369 --> 01:42:53,800
maintaining such repository and that's

01:42:49,540 --> 01:42:58,020
all like in freeze any question about a

01:42:53,800 --> 01:42:58,020
life path to freeze any question about I

01:43:01,139 --> 01:43:13,409
think today some part was already

01:43:05,920 --> 01:43:13,409
discussed right for LTS and also for

01:43:16,100 --> 01:43:22,670
with Nikolai system it was for making

01:43:19,490 --> 01:43:24,380
more simple the way of ultimate icing

01:43:22,670 --> 01:43:30,550
but I passed process and I think is

01:43:24,380 --> 01:43:36,530
something but we can see to adopt I

01:43:30,550 --> 01:43:38,690
don't know now is completely in

01:43:36,530 --> 01:44:00,290
discussion what we can do in the future

01:43:38,690 --> 01:44:03,260
so if using idea anything all right hi

01:44:00,290 --> 01:44:06,170
so is your patch system then going to be

01:44:03,260 --> 01:44:11,750
specific to Gen 2 or could I use it with

01:44:06,170 --> 01:44:16,250
any destroy yeah as now is unfortunately

01:44:11,750 --> 01:44:19,490
specific design to Karen and so we made

01:44:16,250 --> 01:44:21,500
some kind of monster so we take a Damian

01:44:19,490 --> 01:44:24,290
machine we put adage into kernel and we

01:44:21,500 --> 01:44:28,220
use elect patch and it was working but

01:44:24,290 --> 01:44:31,030
it was not Debian anymore so but we are

01:44:28,220 --> 01:44:33,830
thinking the future to support also such

01:44:31,030 --> 01:44:40,460
different distribution so the support

01:44:33,830 --> 01:44:44,990
also Debian or Ubuntu rIDOT and II us

01:44:40,460 --> 01:44:46,850
now I'm we are a few people doing use

01:44:44,990 --> 01:44:49,639
such things so we don't have so much

01:44:46,850 --> 01:44:56,159
manpower so

01:44:49,639 --> 01:44:59,330
he is not don't yet but but is anyway

01:44:56,159 --> 01:44:59,330
interesting things to do

01:45:08,820 --> 01:45:17,530
is the project and source code available

01:45:12,940 --> 01:45:19,449
online and so so what is the current

01:45:17,530 --> 01:45:22,780
state I guess if you were running gen 2

01:45:19,449 --> 01:45:24,639
okay and then for folks who maybe you're

01:45:22,780 --> 01:45:28,179
interested in porting to other

01:45:24,639 --> 01:45:30,760
distributions is is that something that

01:45:28,179 --> 01:45:33,280
you know you would accept pull requests

01:45:30,760 --> 01:45:34,809
or enhancements on yeah we are

01:45:33,280 --> 01:45:41,369
completely open about us everything we

01:45:34,809 --> 01:45:44,380
request and as now the status is that

01:45:41,369 --> 01:45:48,070
very easy still many case where it's not

01:45:44,380 --> 01:45:50,829
working so what we are trying to get is

01:45:48,070 --> 01:45:53,170
getting feedback for what is so so wet

01:45:50,829 --> 01:45:57,869
weekend as now we are sending some time

01:45:53,170 --> 01:46:00,969
feedback to kibosh bill took a patch for

01:45:57,869 --> 01:46:03,940
collaborating each other and so if we

01:46:00,969 --> 01:46:07,559
get such feedback we can try to find a

01:46:03,940 --> 01:46:07,559
way for helping each other

01:46:12,479 --> 01:46:18,570
hello so what sounds a bit scary to me

01:46:16,409 --> 01:46:22,499
is that you actually when you create a

01:46:18,570 --> 01:46:25,909
life page then you create by by

01:46:22,499 --> 01:46:33,209
narrative between two kernels that are

01:46:25,909 --> 01:46:37,050
built like more or less that you try to

01:46:33,209 --> 01:46:39,929
just like simulate words on the user

01:46:37,050 --> 01:46:42,449
system so you cannot guarantee that it's

01:46:39,929 --> 01:46:45,809
really the same and there is always the

01:46:42,449 --> 01:46:49,019
danger that it might just blow up I just

01:46:45,809 --> 01:46:52,289
think if there are some ways to do some

01:46:49,019 --> 01:46:54,479
at least some basic check heist checks I

01:46:52,289 --> 01:46:57,389
don't know for the list of symbols that

01:46:54,479 --> 01:47:00,420
at least these are the same or some

01:46:57,389 --> 01:47:03,570
check some of I don't know if the size

01:47:00,420 --> 01:47:06,769
is the same or something like this which

01:47:03,570 --> 01:47:12,229
might be basically usable maybe even for

01:47:06,769 --> 01:47:12,229
upstream life patching to be more like

01:47:12,349 --> 01:47:19,409
error-prone so how does it even work

01:47:16,650 --> 01:47:21,440
with more versions I probably lost the

01:47:19,409 --> 01:47:24,809
idea somewhere so how can you build

01:47:21,440 --> 01:47:26,519
module for kernel that is built by

01:47:24,809 --> 01:47:27,809
somebody else somewhere else because you

01:47:26,519 --> 01:47:35,519
wouldn't have the same old versions

01:47:27,809 --> 01:47:38,699
that's right version because the you can

01:47:35,519 --> 01:47:40,650
enable tracking of versions of sim of

01:47:38,699 --> 01:47:42,479
symbols in the kernel and then the extra

01:47:40,650 --> 01:47:44,760
module built against a different current

01:47:42,479 --> 01:47:46,979
wouldn't float right I think the mod

01:47:44,760 --> 01:47:48,449
versions are the same if even if you put

01:47:46,979 --> 01:47:52,229
on two different systems cuz its source

01:47:48,449 --> 01:47:58,499
based its uses a hash of the function

01:47:52,229 --> 01:48:00,269
signature well yeah this config has to

01:47:58,499 --> 01:48:02,449
be the same the source has to be the

01:48:00,269 --> 01:48:02,449
same

01:48:09,400 --> 01:48:15,340
and kph bill it has several checks to

01:48:13,030 --> 01:48:19,990
make sure that you have the same version

01:48:15,340 --> 01:48:22,980
of GCC and same binary the symbols are

01:48:19,990 --> 01:48:22,980
in the same order and

01:48:31,780 --> 01:48:35,820
and last things is

01:48:47,340 --> 01:48:52,830
we are trying to make some kind of

01:48:50,100 --> 01:48:58,200
standard for keeping patch in repository

01:48:52,830 --> 01:49:00,630
so that you can send the same patch to

01:48:58,200 --> 01:49:03,120
the elect patch or I don't know in the

01:49:00,630 --> 01:49:05,220
future you can send same you can have

01:49:03,120 --> 01:49:07,800
same repository for a patch build or you

01:49:05,220 --> 01:49:11,220
can save for when equalized software and

01:49:07,800 --> 01:49:20,220
it it will get like all is getting the

01:49:11,220 --> 01:49:22,860
ID upstream for the current so as now we

01:49:20,220 --> 01:49:24,450
are using am so if there is any other I

01:49:22,860 --> 01:49:30,410
don't know so someone suggested to you

01:49:24,450 --> 01:49:30,410
stone for keeping but whatever is okay

01:50:23,980 --> 01:50:31,930
we can change for making better party so

01:50:28,460 --> 01:50:31,930
what we are trying to do

01:50:33,099 --> 01:50:38,039
take it from the user and try to make

01:50:48,270 --> 01:50:55,830
do you envision the use case to be that

01:50:52,469 --> 01:50:59,310
Gentoo kernel developers would be the

01:50:55,830 --> 01:51:01,890
ones creating curating the live patches

01:50:59,310 --> 01:51:06,210
or do you think that Gentoo users would

01:51:01,890 --> 01:51:13,320
want to submit patches of their own to

01:51:06,210 --> 01:51:15,840
this my patch server sometimes some user

01:51:13,320 --> 01:51:19,440
engine 2 is like oh I want to do life

01:51:15,840 --> 01:51:23,880
patch patch and they started to

01:51:19,440 --> 01:51:26,670
investigate how to do such things and so

01:51:23,880 --> 01:51:30,840
any wet one is one of them that we can

01:51:26,670 --> 01:51:32,880
get and because there is some interest

01:51:30,840 --> 01:51:37,370
engine to a bottom creating life patch

01:51:32,880 --> 01:51:40,290
but is not only about engine - I think

01:51:37,370 --> 01:51:43,260
also at a distribution kind of interest

01:51:40,290 --> 01:51:46,080
on making like partially visitor

01:51:43,260 --> 01:51:51,949
distribution matter using life path so I

01:51:46,080 --> 01:51:55,340
think is not only specific to Jin - no

01:51:51,949 --> 01:51:55,340
it could be

01:52:09,620 --> 01:52:17,610
some paid quite PG question so what

01:52:14,910 --> 01:52:20,580
about the fertility of your system like

01:52:17,610 --> 01:52:24,200
if someone want to exploit your system

01:52:20,580 --> 01:52:26,580
and then push belief militias cold

01:52:24,200 --> 01:52:29,460
toward the server's right around the

01:52:26,580 --> 01:52:34,290
controller is any mechanism to protect

01:52:29,460 --> 01:52:39,930
against every part of the system is open

01:52:34,290 --> 01:52:42,210
source so it can be like if someone want

01:52:39,930 --> 01:52:46,290
to do some checkout it or want to audit

01:52:42,210 --> 01:52:50,510
with systemic an or like an

01:52:46,290 --> 01:52:54,660
authentication yeah yeah authentic now

01:52:50,510 --> 01:53:03,300
we are not doing so like you can use

01:52:54,660 --> 01:53:07,320
like for example you can add ostentation

01:53:03,300 --> 01:53:10,040
but I think is not difficult to adding

01:53:07,320 --> 01:53:10,040
such official

01:53:12,370 --> 01:53:20,330
that was one of the we are not signing

01:53:16,100 --> 01:53:23,930
the module but it came out in the other

01:53:20,330 --> 01:53:26,170
issue and is interesting to do such

01:53:23,930 --> 01:53:26,170
things

01:53:30,640 --> 01:53:39,140
thank you

01:53:32,580 --> 01:53:39,140
[Applause]

01:54:04,900 --> 01:54:12,190
hi my name is Joe from Red Hat and work

01:54:10,120 --> 01:54:16,330
on a live patch project

01:54:12,190 --> 01:54:22,300
I brought zero slides today so I hope

01:54:16,330 --> 01:54:26,220
I'm over the limit and I'm gonna talk

01:54:22,300 --> 01:54:30,550
about life patch and the s/390

01:54:26,220 --> 01:54:35,850
architecture so it's just a disclaimer I

01:54:30,550 --> 01:54:38,620
am by no means an s3 9 the expert but

01:54:35,850 --> 01:54:40,150
when I actually get machines that we

01:54:38,620 --> 01:54:42,400
have in our lab when they're available

01:54:40,150 --> 01:54:45,420
you know I get to tinker with with live

01:54:42,400 --> 01:54:50,790
patch on them so I'm going to talk about

01:54:45,420 --> 01:54:50,790
maybe two or three things real quick

01:54:51,090 --> 01:54:57,730
starting with three locations and then

01:54:54,160 --> 01:55:02,820
talking about the consistency model and

01:54:57,730 --> 01:55:08,290
then the next steps for supporting s/390

01:55:02,820 --> 01:55:11,350
so just a quick summary Jessica you who

01:55:08,290 --> 01:55:15,220
is the module maintainer had started

01:55:11,350 --> 01:55:18,670
some preliminary work looking at us 390

01:55:15,220 --> 01:55:21,310
a while back and I can summarize some of

01:55:18,670 --> 01:55:25,540
the things that she had discovered and

01:55:21,310 --> 01:55:30,040
what I picked up and continued so the

01:55:25,540 --> 01:55:33,940
first thing that Jessica found when

01:55:30,040 --> 01:55:40,260
starting to build s/390 kernel modules

01:55:33,940 --> 01:55:45,070
is that GCC can generate pc-relative

01:55:40,260 --> 01:55:48,010
32-bit relocations and on s/390 this is

01:55:45,070 --> 01:55:51,150
of particular interests because of the

01:55:48,010 --> 01:55:53,680
way the kernel address space is laid out

01:55:51,150 --> 01:55:56,230
what ends up happening is the kernel

01:55:53,680 --> 01:55:58,750
proper is at one end of the kernel

01:55:56,230 --> 01:56:03,130
address space and then the modules are

01:55:58,750 --> 01:56:06,970
loaded on the other side so what ends up

01:56:03,130 --> 01:56:10,060
happening when you generate at least K

01:56:06,970 --> 01:56:14,830
patches and I suspect maybe source base

01:56:10,060 --> 01:56:16,550
life patches is that you can have these

01:56:14,830 --> 01:56:20,989
32-bit

01:56:16,550 --> 01:56:23,270
PC of relativity locations that are put

01:56:20,989 --> 01:56:26,960
into a kernel module that needs to get

01:56:23,270 --> 01:56:34,300
to kernel space and it's too far to

01:56:26,960 --> 01:56:38,390
traverse for 32 bits so so what to do

01:56:34,300 --> 01:56:41,480
well luckily k patch and I think the

01:56:38,390 --> 01:56:43,489
source space tools were already keeping

01:56:41,480 --> 01:56:47,900
lists of relocations that we might need

01:56:43,489 --> 01:56:51,680
to adjust so Jessica had brought the

01:56:47,900 --> 01:56:57,830
problem to the GCC folks and she lobbied

01:56:51,680 --> 01:57:02,630
them to to port compile option called M

01:56:57,830 --> 01:57:04,450
no pic data is text relative rolls off

01:57:02,630 --> 01:57:10,210
the tongue

01:57:04,450 --> 01:57:13,790
this essentially addresses relocations

01:57:10,210 --> 01:57:21,440
concerning the relationship between data

01:57:13,790 --> 01:57:24,190
and texts and basically turns it turns

01:57:21,440 --> 01:57:26,930
off the relative addressing for those

01:57:24,190 --> 01:57:31,730
they ported that from I think the ARM

01:57:26,930 --> 01:57:36,440
architecture to the s/390 architecture

01:57:31,730 --> 01:57:40,850
in GCC and I think that made GCC release

01:57:36,440 --> 01:57:45,080
8 or 8.1 so it's been there for a little

01:57:40,850 --> 01:57:49,670
while now so this solve some of the

01:57:45,080 --> 01:57:52,670
problem there still remained an issue of

01:57:49,670 --> 01:57:54,890
local kernel function references so if

01:57:52,670 --> 01:57:56,750
your kernel function we have a reference

01:57:54,890 --> 01:57:58,520
to a kernel function and then you need

01:57:56,750 --> 01:58:02,930
to carry that relocation into the kernel

01:57:58,520 --> 01:58:07,070
module what do you do so tentative

01:58:02,930 --> 01:58:10,670
solution that Jessica and the GCC folks

01:58:07,070 --> 01:58:14,180
had had floated and I had implemented

01:58:10,670 --> 01:58:16,510
and have been testing a bit is to

01:58:14,180 --> 01:58:22,489
convert those relocations

01:58:16,510 --> 01:58:26,030
to 32-bit redirect it relocations

01:58:22,489 --> 01:58:28,080
so essentially GCC seems to be

01:58:26,030 --> 01:58:32,020
generating the same

01:58:28,080 --> 01:58:35,200
with instructions and the same sort of

01:58:32,020 --> 01:58:39,880
series of instructions when it uses

01:58:35,200 --> 01:58:42,640
either those relative or PLT relocations

01:58:39,880 --> 01:58:45,010
and so what we just simply did is I

01:58:42,640 --> 01:58:47,920
checked for the that pattern and then

01:58:45,010 --> 01:58:52,360
converted three locations to the PLT

01:58:47,920 --> 01:58:54,700
type then when I load it the life patch

01:58:52,360 --> 01:58:57,250
module the module loader sees those

01:58:54,700 --> 01:58:59,710
creates BLTs and now we have a little

01:58:57,250 --> 01:59:03,310
trampoline to get here you know from

01:58:59,710 --> 01:59:06,730
here to there so that worked fairly well

01:59:03,310 --> 01:59:10,740
at least in the the test cases that kate

01:59:06,730 --> 01:59:14,080
patch has you know I it's not

01:59:10,740 --> 01:59:19,210
exhaustively tested but the tentative

01:59:14,080 --> 01:59:22,080
solution seems to be holding so far that

01:59:19,210 --> 01:59:24,610
said there I guess would be maybe some

01:59:22,080 --> 01:59:28,920
performance maybe impacts by having the

01:59:24,610 --> 01:59:33,450
PLT redirection but more interestingly

01:59:28,920 --> 01:59:35,830
there is some to do here and I think

01:59:33,450 --> 01:59:38,320
function pointers might throw a wrench

01:59:35,830 --> 01:59:40,840
into this I have to do some

01:59:38,320 --> 01:59:42,940
investigation and to see what does it

01:59:40,840 --> 01:59:45,100
mean if you have function pointers in

01:59:42,940 --> 01:59:47,830
the similar manner does it generate the

01:59:45,100 --> 01:59:50,560
same code can we convert them can we

01:59:47,830 --> 01:59:54,430
compare them what is a function pointer

01:59:50,560 --> 02:00:01,000
mean if it pointed to patched code verse

01:59:54,430 --> 02:00:02,590
unpatched code etc so that was a kind of

02:00:01,000 --> 02:00:07,270
extent of what Jessica had been doing

02:00:02,590 --> 02:00:11,110
with GCC module loading the next part of

02:00:07,270 --> 02:00:17,100
this was the consistency model and in

02:00:11,110 --> 02:00:21,700
particular do we need obj tool for s/390

02:00:17,100 --> 02:00:23,200
a quick recap I don't have slides and

02:00:21,700 --> 02:00:25,720
I'm not going to go into a long detail

02:00:23,200 --> 02:00:29,590
about the architecture and a stack frame

02:00:25,720 --> 02:00:32,860
is pretty simple the ABI supplement

02:00:29,590 --> 02:00:35,830
describes it functions or passed new

02:00:32,860 --> 02:00:37,600
frames by the calling function and

02:00:35,830 --> 02:00:40,510
they're required if that function is

02:00:37,600 --> 02:00:43,350
going to in turn call another function

02:00:40,510 --> 02:00:49,200
the stack frame consists of the usual

02:00:43,350 --> 02:00:53,620
sort of register save area parameters

02:00:49,200 --> 02:00:57,100
etc and most interestingly an optional

02:00:53,620 --> 02:01:01,770
back chain pointer so the back chain

02:00:57,100 --> 02:01:04,180
pointer facilitates stack unwinding each

02:01:01,770 --> 02:01:07,030
pointer holds a copy of the previous

02:01:04,180 --> 02:01:08,860
stack pointer until you get all the way

02:01:07,030 --> 02:01:12,460
back to the first frame in which case

02:01:08,860 --> 02:01:14,200
you have a null back chain value so it

02:01:12,460 --> 02:01:18,610
allows you to sort of traverse the stack

02:01:14,200 --> 02:01:25,420
and help unwind okay

02:01:18,610 --> 02:01:28,090
in looking at the architecture and kind

02:01:25,420 --> 02:01:30,700
of keyed off by the supplement saying

02:01:28,090 --> 02:01:35,230
that the back chain pointer is optional

02:01:30,700 --> 02:01:37,120
I went about actually testing this and I

02:01:35,230 --> 02:01:39,430
couldn't find anything

02:01:37,120 --> 02:01:42,400
architectural II that forced you to use

02:01:39,430 --> 02:01:44,620
back chain pointers so I said about

02:01:42,400 --> 02:01:49,600
writing some really terrible assembly

02:01:44,620 --> 02:01:51,670
code I use GCC makes them assembly where

02:01:49,600 --> 02:01:54,280
function a calls function because

02:01:51,670 --> 02:01:56,500
function C etc I took the assembly

02:01:54,280 --> 02:01:59,560
generated and completely removed the

02:01:56,500 --> 02:02:02,770
stack frames but left the code intact

02:01:59,560 --> 02:02:04,660
and you know saved some things and

02:02:02,770 --> 02:02:06,520
registers and sure enough and I trace

02:02:04,660 --> 02:02:10,030
the execution I could get all the way

02:02:06,520 --> 02:02:13,180
through my functions and back it confuse

02:02:10,030 --> 02:02:15,850
the heck out of gdb but you know the

02:02:13,180 --> 02:02:19,620
machine didn't explode so it did indeed

02:02:15,850 --> 02:02:23,800
seem optional okay

02:02:19,620 --> 02:02:25,840
so I told Josh this and he said well

02:02:23,800 --> 02:02:27,940
okay well what is the kernel do because

02:02:25,840 --> 02:02:34,660
Joe doesn't write s/390

02:02:27,940 --> 02:02:38,740
kernel code so TCC does indeed use an

02:02:34,660 --> 02:02:41,830
option I think it's - M back chain

02:02:38,740 --> 02:02:46,360
something like that yeah - and back

02:02:41,830 --> 02:02:49,570
chain so so he kind of came to the

02:02:46,360 --> 02:02:52,510
conclusion that that calls from C code

02:02:49,570 --> 02:02:54,760
should work because GCC's will be doing

02:02:52,510 --> 02:02:57,580
the right thing so C code this you

02:02:54,760 --> 02:03:00,940
should be fine calls from inline

02:02:57,580 --> 02:03:02,680
assembly should probably be fine as well

02:03:00,940 --> 02:03:05,890
because if you've got there

02:03:02,680 --> 02:03:08,140
GCC set up a stack frame and I'm like

02:03:05,890 --> 02:03:11,260
the collie needs to get its arguments

02:03:08,140 --> 02:03:13,570
and if GCC is doing that and it's

02:03:11,260 --> 02:03:16,950
probably maintaining this back pointer

02:03:13,570 --> 02:03:20,260
chain so that left us with assembly code

02:03:16,950 --> 02:03:24,489
could it potentially forget to store the

02:03:20,260 --> 02:03:27,160
back chain pointer so that sounds like

02:03:24,489 --> 02:03:31,750
something an awful lot like obj tool or

02:03:27,160 --> 02:03:36,820
a job Jade tool so short of actually

02:03:31,750 --> 02:03:40,170
porting obj tool s/390 josh came up with

02:03:36,820 --> 02:03:44,980
a suggestion of looking at objdump

02:03:40,170 --> 02:03:49,330
assembly output and sort of inspecting

02:03:44,980 --> 02:03:51,520
it and to make matters worse I think he

02:03:49,330 --> 02:03:53,890
suggested writing a NOC script to do it

02:03:51,520 --> 02:03:56,910
and I didn't know if that was a

02:03:53,890 --> 02:03:56,910
challenge or a dare

02:03:58,390 --> 02:04:04,239
surprisingly things are not too bad I

02:04:01,330 --> 02:04:09,070
think it's only like 60 lines it's

02:04:04,239 --> 02:04:12,489
better than my assembly so in the end I

02:04:09,070 --> 02:04:16,440
I ran it against a fully compiled test

02:04:12,489 --> 02:04:18,640
configured kernel if there was like over

02:04:16,440 --> 02:04:22,000
200,000 functions I think it analyzed

02:04:18,640 --> 02:04:24,420
and it came up with about two dozen

02:04:22,000 --> 02:04:27,400
functions that looked quote interesting

02:04:24,420 --> 02:04:30,070
where maybe they didn't set up a stack

02:04:27,400 --> 02:04:33,040
frame and then made a call or didn't say

02:04:30,070 --> 02:04:35,680
the back pointer made a call so the

02:04:33,040 --> 02:04:37,870
summary of that experiment is that when

02:04:35,680 --> 02:04:42,850
we looked at those functions they were

02:04:37,870 --> 02:04:46,150
all in init code or interrupt handlers

02:04:42,850 --> 02:04:48,370
or boot code so essentially it seemed

02:04:46,150 --> 02:04:54,690
like the kernel did a very consistent

02:04:48,370 --> 02:04:57,520
job of maintaining the back pointers so

02:04:54,690 --> 02:05:01,840
that was kind of the the extent of

02:04:57,520 --> 02:05:03,940
what's that I've learned with us 390 we

02:05:01,840 --> 02:05:07,090
presented that or posted upstream I

02:05:03,940 --> 02:05:12,790
think maybe a few weeks ago

02:05:07,090 --> 02:05:16,420
and Martin from IBM I think the the arch

02:05:12,790 --> 02:05:18,730
maintainer he confirmed the fact that

02:05:16,420 --> 02:05:21,310
that back chain pointers were indeed

02:05:18,730 --> 02:05:25,200
optional however they did have a line

02:05:21,310 --> 02:05:29,500
item to implement the organ winder and

02:05:25,200 --> 02:05:32,170
also obj tool support and once they had

02:05:29,500 --> 02:05:35,080
that they would be dropping support or

02:05:32,170 --> 02:05:36,760
dropping the n-back chain build option

02:05:35,080 --> 02:05:41,980
so we get them a little bit of a

02:05:36,760 --> 02:05:45,490
performance boosts so the question in

02:05:41,980 --> 02:05:48,340
that I had is that certainly if anybody

02:05:45,490 --> 02:05:51,220
knows what the timetable is for that

02:05:48,340 --> 02:05:56,350
work that would be very good to know

02:05:51,220 --> 02:05:59,560
and then if if we don't know you know

02:05:56,350 --> 02:06:02,860
how long that would take and we do think

02:05:59,560 --> 02:06:05,380
that back chain use is consistent then

02:06:02,860 --> 02:06:09,400
should we just go about enhancing the

02:06:05,380 --> 02:06:14,200
existing unwinder to handle any cases

02:06:09,400 --> 02:06:16,510
that it currently doesn't which I guess

02:06:14,200 --> 02:06:23,670
we'd have to make sure function graph

02:06:16,510 --> 02:06:23,670
tracing K probes stack corruption etc

02:06:23,820 --> 02:06:31,270
would be needed and I guess an

02:06:28,710 --> 02:06:34,560
additional question might be

02:06:31,270 --> 02:06:37,930
should we just said about thinking about

02:06:34,560 --> 02:06:40,870
how to make obj tool our architecture

02:06:37,930 --> 02:06:43,810
independence that's probably a question

02:06:40,870 --> 02:06:50,770
for a whole nother micro conference Josh

02:06:43,810 --> 02:06:52,290
but so that's all I have for 390 and I

02:06:50,770 --> 02:06:55,120
didn't know if anybody else was

02:06:52,290 --> 02:06:58,240
interested in life patching for that

02:06:55,120 --> 02:07:01,660
architecture or had done any similar

02:06:58,240 --> 02:07:05,470
sort of initial problem yes commander

02:07:01,660 --> 02:07:10,060
bad laces that we are gonna be very much

02:07:05,470 --> 02:07:16,660
interested about it in the future in the

02:07:10,060 --> 02:07:18,589
future yes so the conclusion is that we

02:07:16,660 --> 02:07:21,379
should be safe

02:07:18,589 --> 02:07:23,959
and obviously though is not needed it's

02:07:21,379 --> 02:07:26,449
not necessary right and we have to only

02:07:23,959 --> 02:07:30,139
implement that reliable stack traces

02:07:26,449 --> 02:07:33,319
infrastructure is that correct say

02:07:30,139 --> 02:07:37,760
detection that the stack trace is

02:07:33,319 --> 02:07:39,919
reliable so that new there's we are

02:07:37,760 --> 02:07:42,859
things like function tracing what

02:07:39,919 --> 02:07:54,819
happening right right right correct

02:07:42,859 --> 02:07:57,289
Thanks okay so what about obj2 well we

02:07:54,819 --> 02:08:00,189
we were pretty sure we don't need it we

02:07:57,289 --> 02:08:04,939
go first three ninety so the question is

02:08:00,189 --> 02:08:06,499
if they want it for organ winder you

02:08:04,939 --> 02:08:09,050
should they might want to question why

02:08:06,499 --> 02:08:10,939
they want or cone winder because I think

02:08:09,050 --> 02:08:14,749
we did some performance numbers with

02:08:10,939 --> 02:08:17,030
that chain disabled right and I'm sorry

02:08:14,749 --> 02:08:21,079
I did built a kernel right without the

02:08:17,030 --> 02:08:25,189
back chain and I don't I think I ran

02:08:21,079 --> 02:08:28,010
stress the stressor program and I didn't

02:08:25,189 --> 02:08:30,559
see much of a difference but of course

02:08:28,010 --> 02:08:32,899
I'm not the architecture expert and I'm

02:08:30,559 --> 02:08:34,369
sure you could concoct you know some

02:08:32,899 --> 02:08:38,569
scenarios where maybe it is more

02:08:34,369 --> 02:08:40,639
interesting than I did so there might

02:08:38,569 --> 02:08:46,010
not be as much benefit for the organ

02:08:40,639 --> 02:08:48,699
winder so whether whether OVH will be

02:08:46,010 --> 02:08:48,699
needed for other reasons

02:08:57,340 --> 02:09:09,190
no other questions just another basic

02:09:05,739 --> 02:09:11,349
question so why I BM like I sound like I

02:09:09,190 --> 02:09:14,219
the IBM g3 they're talking about III is

02:09:11,349 --> 02:09:17,920
right the process mother talked about

02:09:14,219 --> 02:09:20,980
rooks rike has more demand for TIF is it

02:09:17,920 --> 02:09:23,920
due to their application domain right

02:09:20,980 --> 02:09:26,980
requiring high availability or do we

02:09:23,920 --> 02:09:27,670
have similar demands in other server

02:09:26,980 --> 02:09:29,320
systems

02:09:27,670 --> 02:09:33,219
what about mobile like do you see any

02:09:29,320 --> 02:09:35,679
areas where this may apply so the

02:09:33,219 --> 02:09:40,510
question is why as 390 and that another

02:09:35,679 --> 02:09:45,389
architecture yeah well I can't speak for

02:09:40,510 --> 02:09:47,980
su se but generally I would think

02:09:45,389 --> 02:09:51,010
distributions would want to kind of have

02:09:47,980 --> 02:09:53,920
parity feature parity if you offer live

02:09:51,010 --> 02:09:56,650
patching for architecture a and then you

02:09:53,920 --> 02:10:00,070
say we you know we support our

02:09:56,650 --> 02:10:01,900
distribution on architecture be one

02:10:00,070 --> 02:10:07,000
might ask well why can't I get a live

02:10:01,900 --> 02:10:10,840
patch for architecture B so there are

02:10:07,000 --> 02:10:12,940
other you know there's work underway on

02:10:10,840 --> 02:10:16,360
other architectures you'll hear from

02:10:12,940 --> 02:10:20,110
coalition in a moment on power for

02:10:16,360 --> 02:10:23,559
example you know I think there's a patch

02:10:20,110 --> 02:10:25,510
set outstanding for arm so you know

02:10:23,559 --> 02:10:29,020
there's a bunch of architectures kind of

02:10:25,510 --> 02:10:36,639
simultaneously being being worked maybe

02:10:29,020 --> 02:10:39,340
a better yeah yeah I would say that life

02:10:36,639 --> 02:10:42,760
matching makes most sense on servers

02:10:39,340 --> 02:10:46,800
that are not cheap to reboot because

02:10:42,760 --> 02:10:52,270
they have to they handle some business

02:10:46,800 --> 02:10:57,309
important stuff and so of course I guess

02:10:52,270 --> 02:10:59,619
that x64 is the most common architecture

02:10:57,309 --> 02:11:01,809
and but s/390

02:10:59,619 --> 02:11:05,230
also runs probably some of this

02:11:01,809 --> 02:11:08,139
sensitive stuff and PowerPC as well so

02:11:05,230 --> 02:11:10,900
this is probably why this gets more

02:11:08,139 --> 02:11:13,240
important on the other hand arm

02:11:10,900 --> 02:11:15,250
well to be honest I'm not sure but at

02:11:13,240 --> 02:11:21,370
least on a mobile phone it doesn't make

02:11:15,250 --> 02:11:24,670
much sense to it I know I know

02:11:21,370 --> 02:11:28,500
yeah yeah so of course it will be

02:11:24,670 --> 02:11:28,500
interesting interesting as well

02:11:34,090 --> 02:11:47,830
so we're out of time so I think we're

02:11:37,450 --> 02:11:56,980
over time thank you yes but we do have

02:11:47,830 --> 02:11:58,060
some more people in the house do you

02:11:56,980 --> 02:12:04,560
want to do you want to talk about this

02:11:58,060 --> 02:12:04,560
now arm / obj tool or

02:12:08,360 --> 02:12:18,320
I know you guys had some questions about

02:12:11,770 --> 02:12:22,990
three-pointers and yeah so I guess the

02:12:18,320 --> 02:12:25,100
big deal is that the arm 64 maintainer

02:12:22,990 --> 02:12:27,320
the object for upstream maintainer is

02:12:25,100 --> 02:12:29,870
basically we don't know what's necessary

02:12:27,320 --> 02:12:31,490
for life patching we don't know what the

02:12:29,870 --> 02:12:33,140
necessary prerequisites are for things

02:12:31,490 --> 02:12:34,910
like house reliable stacktrace

02:12:33,140 --> 02:12:38,690
and after having read the documentation

02:12:34,910 --> 02:12:39,650
I'm still not entirely sure be really

02:12:38,690 --> 02:12:43,720
nice if we could improve the

02:12:39,650 --> 02:12:46,400
documentation on like specifically what

02:12:43,720 --> 02:12:47,570
you know architecture neutral way what's

02:12:46,400 --> 02:12:50,090
required is the way it's written in the

02:12:47,570 --> 02:12:56,270
moment is rather x86 specific at least

02:12:50,090 --> 02:12:57,470
from my point of view as I understand it

02:12:56,270 --> 02:12:59,900
there's an awful lot of stuff that we

02:12:57,470 --> 02:13:02,300
need to do before life patching is ready

02:12:59,900 --> 02:13:04,340
on arm 64 so we need efforts with regs

02:13:02,300 --> 02:13:05,720
we need a reliable stack tracing we need

02:13:04,340 --> 02:13:10,340
to go and audit all our assembly with

02:13:05,720 --> 02:13:12,860
respect to that no one's really done the

02:13:10,340 --> 02:13:15,380
latter two parts of that I think Torsten

02:13:12,860 --> 02:13:17,750
do from Caesars been looking at doing F

02:13:15,380 --> 02:13:19,640
trace with rags but has assumed that

02:13:17,750 --> 02:13:24,560
everything else is fine and I'm not sure

02:13:19,640 --> 02:13:27,770
that's the case right from my limited

02:13:24,560 --> 02:13:32,780
understanding I think we have an issue

02:13:27,770 --> 02:13:34,040
with with frame pointers so some of the

02:13:32,780 --> 02:13:39,050
issues with frame pointers that we saw

02:13:34,040 --> 02:13:42,610
on x86 are if if you have in line a

02:13:39,050 --> 02:13:44,800
assume that calls into another function

02:13:42,610 --> 02:13:48,260
right

02:13:44,800 --> 02:13:50,660
GCC doesn't know what's inside the in

02:13:48,260 --> 02:13:52,550
line I assume has no visibility so

02:13:50,660 --> 02:13:54,350
sometimes there's two things that can

02:13:52,550 --> 02:13:57,860
happen one as if the function was

02:13:54,350 --> 02:14:00,710
otherwise a leaf function then the in

02:13:57,860 --> 02:14:02,450
line I assume that will break for any

02:14:00,710 --> 02:14:04,550
pointers because it don't mean no frame

02:14:02,450 --> 02:14:10,000
pointer prologue before calling out the

02:14:04,550 --> 02:14:12,710
other case is if the in line ASM is

02:14:10,000 --> 02:14:16,190
inserted before the frame pointer

02:14:12,710 --> 02:14:21,110
prologue which we saw happen a lot or

02:14:16,190 --> 02:14:21,980
dozens of times in x86 so GCC can do

02:14:21,110 --> 02:14:23,630
that

02:14:21,980 --> 02:14:26,180
you can reorder things and do the

02:14:23,630 --> 02:14:28,550
prologue later after two inserts the in

02:14:26,180 --> 02:14:32,050
line a assume and so that's a real

02:14:28,550 --> 02:14:36,110
problem so yeah so we definitely have

02:14:32,050 --> 02:14:37,340
four Atomics we have in line a SM that

02:14:36,110 --> 02:14:39,230
doesn't have a line call which would

02:14:37,340 --> 02:14:40,640
definitely break for importers we don't

02:14:39,230 --> 02:14:44,989
serve a stack frame for that we're aware

02:14:40,640 --> 02:14:47,360
of that case in terms of DCC doing crazy

02:14:44,989 --> 02:14:53,030
things take a look at will Deakins

02:14:47,360 --> 02:14:56,000
Twitter yeah it we've not done any of

02:14:53,030 --> 02:15:00,140
the auditing necessary to know what's

02:14:56,000 --> 02:15:02,510
what we need to do that so I mean it

02:15:00,140 --> 02:15:08,570
sounds like that confirms my view that

02:15:02,510 --> 02:15:10,370
we do need a obj tool for forearm can we

02:15:08,570 --> 02:15:12,460
start by marking those functions that's

02:15:10,370 --> 02:15:15,400
not patchable anything using inline SM

02:15:12,460 --> 02:15:18,320
where we know there's no frame pointer

02:15:15,400 --> 02:15:21,800
start marking them is not being led

02:15:18,320 --> 02:15:24,200
badge so in this case this is any

02:15:21,800 --> 02:15:25,489
function using any of the atomic API

02:15:24,200 --> 02:15:28,100
which is going to be the vast majority

02:15:25,489 --> 02:15:31,880
of functions to get in line all over the

02:15:28,100 --> 02:15:33,950
place so to odd had a potential solution

02:15:31,880 --> 02:15:37,130
that re works the way we do that but I'm

02:15:33,950 --> 02:15:38,900
not entirely sure if that helps because

02:15:37,130 --> 02:15:40,670
it moves the call out into a subsection

02:15:38,900 --> 02:15:45,470
it might not get reported as part of

02:15:40,670 --> 02:15:48,310
that function we can fix that in the in

02:15:45,470 --> 02:15:48,310
the back tracing coats

02:15:50,410 --> 02:15:54,830
yeah so big deal is there's work to be

02:15:53,660 --> 02:15:57,970
done there we need to actually

02:15:54,830 --> 02:15:57,970
understand analyze that

02:16:02,669 --> 02:16:08,340
so what other what do you have any other

02:16:06,360 --> 02:16:10,469
specific questions or you only go her

02:16:08,340 --> 02:16:11,849
you pretty much gave overview of the

02:16:10,469 --> 02:16:14,189
requirements that you need to have

02:16:11,849 --> 02:16:17,849
choice with your eggs but from a safety

02:16:14,189 --> 02:16:19,380
perspective we need reliable frame

02:16:17,849 --> 02:16:24,510
pointers and what we just talked about I

02:16:19,380 --> 02:16:26,610
also need a unwinder that can what we

02:16:24,510 --> 02:16:29,489
call it a reliable unwinder frame

02:16:26,610 --> 02:16:30,630
partners aren't always reliable even if

02:16:29,489 --> 02:16:33,479
they're always in the right place

02:16:30,630 --> 02:16:36,809
because when you have exceptions like

02:16:33,479 --> 02:16:41,670
page faults and preemption then things

02:16:36,809 --> 02:16:43,710
can get go weird so the unwinder needs

02:16:41,670 --> 02:16:46,679
to be able to detect those cases when

02:16:43,710 --> 02:16:48,389
you have an exception on the stack then

02:16:46,679 --> 02:16:51,989
it needs to return an error and say this

02:16:48,389 --> 02:16:55,859
is not reliable so I guess in terms that

02:16:51,989 --> 02:16:57,269
when you say it's unreliable yeah you

02:16:55,859 --> 02:16:59,989
preempted in the middle of sank before

02:16:57,269 --> 02:17:02,639
you've it does it matter if we have

02:16:59,989 --> 02:17:04,679
duplicate frames in the on one do you

02:17:02,639 --> 02:17:07,109
actually just care that the full set of

02:17:04,679 --> 02:17:08,550
functions is in the back-trace or does

02:17:07,109 --> 02:17:11,729
it literally need to be absolutely

02:17:08,550 --> 02:17:14,239
correct so that you wouldn't like have

02:17:11,729 --> 02:17:16,679
the same function twice in a back-trace

02:17:14,239 --> 02:17:18,120
duplicates would be fine you just need

02:17:16,679 --> 02:17:20,130
to make sure that the function that

02:17:18,120 --> 02:17:23,880
you're patching is not on the stack

02:17:20,130 --> 02:17:30,139
trees so it's part of our consistency

02:17:23,880 --> 02:17:33,960
model on any stack on any week we

02:17:30,139 --> 02:17:38,189
transition one task at a time so we'd

02:17:33,960 --> 02:17:40,559
look look at the stack of a task and if

02:17:38,189 --> 02:17:42,779
if all the functions that were patching

02:17:40,559 --> 02:17:45,090
at that time there's none of them or on

02:17:42,779 --> 02:17:48,599
the stack then we will transition that

02:17:45,090 --> 02:17:51,599
task so at least in terms of exceptions

02:17:48,599 --> 02:17:53,159
we can handle that in the entry assembly

02:17:51,599 --> 02:17:57,510
because we artificially create a stack

02:17:53,159 --> 02:17:59,779
frame for the preempted forever we took

02:17:57,510 --> 02:18:03,179
the exception from so we can create a

02:17:59,779 --> 02:18:04,139
stack frame that would point to that PC

02:18:03,179 --> 02:18:08,010
value at that point in time which would

02:18:04,139 --> 02:18:09,689
be that function and we probably would

02:18:08,010 --> 02:18:11,069
have to do some munging or if it's in

02:18:09,689 --> 02:18:14,159
the middle of creating a stack frame

02:18:11,069 --> 02:18:15,460
what we do there well you don't always

02:18:14,159 --> 02:18:17,250
have to get 100

02:18:15,460 --> 02:18:20,559
right it's okay to say there's a

02:18:17,250 --> 02:18:22,510
preemption on the stack we just won't

02:18:20,559 --> 02:18:23,830
don't patch this task right now so it's

02:18:22,510 --> 02:18:27,420
not it's not a big deal it's a pretty

02:18:23,830 --> 02:18:27,420
rare case anyway so

02:18:30,430 --> 02:18:42,131
just forgotten so for things like tail

02:18:39,881 --> 02:18:44,501
calls I guess it doesn't matter if the

02:18:42,131 --> 02:18:47,140
return address that the stack trace

02:18:44,501 --> 02:18:48,791
would says does it matter if you have a

02:18:47,140 --> 02:18:53,470
false positive pointing at a function

02:18:48,791 --> 02:18:59,801
that we're being patched no no in false

02:18:53,470 --> 02:19:01,810
positives it's not bad I mean you would

02:18:59,801 --> 02:19:05,950
just skip you don't necessarily skip

02:19:01,810 --> 02:19:07,390
that task but with a tail call it

02:19:05,950 --> 02:19:09,100
wouldn't even show up show up on the

02:19:07,390 --> 02:19:10,841
stack trace which is fine because the

02:19:09,100 --> 02:19:13,570
function is already basically exited

02:19:10,841 --> 02:19:15,640
yeah so the fun thing is the tail call

02:19:13,570 --> 02:19:17,650
leads to a false positive in that you

02:19:15,640 --> 02:19:21,131
point at the next function the entry

02:19:17,650 --> 02:19:24,310
point of the next function is we sorry

02:19:21,131 --> 02:19:26,440
yeah no but with a no return call say

02:19:24,310 --> 02:19:28,331
like branch to panic I mean it's a

02:19:26,440 --> 02:19:31,240
stupid case because it's almost always

02:19:28,331 --> 02:19:32,890
fatal or a task exiting its LR value

02:19:31,240 --> 02:19:34,510
that will get put into the stack frame

02:19:32,890 --> 02:19:35,740
will be pointing at whatever is next

02:19:34,510 --> 02:19:37,900
which could be another function we get a

02:19:35,740 --> 02:19:42,270
false positive out of it and we can

02:19:37,900 --> 02:19:42,270
fiddle with it yeah that's fine

02:19:51,330 --> 02:20:02,750
I think that a telco function always a

02:19:58,279 --> 02:20:13,310
program program have a problem on the

02:20:02,750 --> 02:20:13,310
unwinding check upon or x86 not visible

02:20:14,540 --> 02:20:22,949
no not visible because that are the

02:20:19,830 --> 02:20:25,699
point we usually do the table will jump

02:20:22,949 --> 02:20:29,420
to the next function so that there is no

02:20:25,699 --> 02:20:29,420
yeah no the function

02:20:34,120 --> 02:20:37,120
yes

02:20:54,760 --> 02:20:58,510
if you have changed

02:20:59,310 --> 02:21:03,630
if there is a chain of multiple jumps

02:21:01,470 --> 02:21:05,730
that then end up with a final return to

02:21:03,630 --> 02:21:09,230
the very beginning then it's completely

02:21:05,730 --> 02:21:09,230
invisible to the online the right oh

02:21:13,430 --> 02:21:19,340
you're right okay that's fine right

02:21:30,420 --> 02:21:34,120
[Laughter]

02:21:37,180 --> 02:21:44,690
yeah we're over button so what was the

02:21:42,530 --> 02:21:52,300
conclusion we need we need to obj tool

02:21:44,690 --> 02:21:52,300
right forearm yeah

02:22:02,220 --> 02:22:05,970
there's there's something else on arm

02:22:04,260 --> 02:22:08,450
right there's not - tree but they have

02:22:05,970 --> 02:22:08,450
some other

02:22:38,671 --> 02:22:45,700
all right thank you thank you everybody

02:22:42,721 --> 02:22:47,500
how do you okay

02:22:45,700 --> 02:22:52,530
actually camel ash is gonna say a few

02:22:47,500 --> 02:22:52,530
words you know okay

02:23:38,340 --> 02:23:40,850
yeah

02:23:43,370 --> 02:23:50,820
yes sorry huh I usually find myself

02:23:47,040 --> 02:23:52,730
really loud chef anyway so uh most of

02:23:50,820 --> 02:23:55,230
the discussion we're like it's just uh

02:23:52,730 --> 02:23:58,380
I'm not going to discuss the same thing

02:23:55,230 --> 02:23:59,880
which is 390 and um guys discussed so in

02:23:58,380 --> 02:24:03,600
PowerPC for if you're going to see that

02:23:59,880 --> 02:24:06,240
you know the bat chain is what in the

02:24:03,600 --> 02:24:09,570
PowerPC terminology we call so that you

02:24:06,240 --> 02:24:10,980
can just know unwind or walk through the

02:24:09,570 --> 02:24:13,021
whole stack to figure out you know from

02:24:10,980 --> 02:24:15,660
where are you getting or what the whole

02:24:13,021 --> 02:24:17,311
called China's so that's reason it was

02:24:15,660 --> 02:24:21,030
determined that they know we don't

02:24:17,311 --> 02:24:23,070
really need an object tool for enabling

02:24:21,030 --> 02:24:27,930
the consistency model or the consistency

02:24:23,070 --> 02:24:31,980
check on PowerPC so having said that it

02:24:27,930 --> 02:24:34,590
was concluded that you know by a bi it

02:24:31,980 --> 02:24:39,230
is mandated it is a mandate that we have

02:24:34,590 --> 02:24:41,730
this but for the hand coded Ames

02:24:39,230 --> 02:24:45,330
assembly language or the assembly code

02:24:41,730 --> 02:24:48,450
as such there is no way we could you

02:24:45,330 --> 02:24:51,061
know be sure that you know it's not

02:24:48,450 --> 02:24:52,771
doing it but to guarantee that on

02:24:51,061 --> 02:24:54,930
purpose you can't do that I mean you

02:24:52,771 --> 02:24:56,640
can't do you have to make sure the frame

02:24:54,930 --> 02:24:58,950
pointer is set up in the right way and I

02:24:56,640 --> 02:25:01,410
know all the rules which apply to the C

02:24:58,950 --> 02:25:03,090
code applies to the assembly also so you

02:25:01,410 --> 02:25:04,440
can guarantee that you know if you're

02:25:03,090 --> 02:25:07,250
going to do something things will break

02:25:04,440 --> 02:25:10,860
very badly so now the question is like

02:25:07,250 --> 02:25:12,750
if in case if you're going to have

02:25:10,860 --> 02:25:14,850
object tool which is like very nice to

02:25:12,750 --> 02:25:18,450
have to just ensure that we are doing

02:25:14,850 --> 02:25:20,610
things right to add up to the discussion

02:25:18,450 --> 02:25:22,410
given that we have now s/390 which is

02:25:20,610 --> 02:25:25,561
people are working on and we have um

02:25:22,410 --> 02:25:27,420
which people are working on and if I'm

02:25:25,561 --> 02:25:29,610
going to do and if we are going to

02:25:27,420 --> 02:25:33,330
modify object tool to add PowerPC

02:25:29,610 --> 02:25:34,530
support so that would mean that as I

02:25:33,330 --> 02:25:37,920
said we are going to enforce all the

02:25:34,530 --> 02:25:40,110
rules which we have for C and a couple

02:25:37,920 --> 02:25:42,720
of them which we have for x86 like you

02:25:40,110 --> 02:25:44,430
want to make sure the stack the frame

02:25:42,720 --> 02:25:46,110
pointers all right I mean they set up

02:25:44,430 --> 02:25:49,380
right and if you're going to have a jump

02:25:46,110 --> 02:25:51,510
you make sure the jump is just it's a

02:25:49,380 --> 02:25:53,311
legal one it's like like not the inline

02:25:51,510 --> 02:25:55,681
assembly where you just do it

02:25:53,311 --> 02:25:57,870
you know jump a non-return jump kind of

02:25:55,681 --> 02:26:00,271
thing so enforcing those rules will be

02:25:57,870 --> 02:26:03,061
nice to have on assembly as such through

02:26:00,271 --> 02:26:04,860
objective so that would the major

02:26:03,061 --> 02:26:07,050
question here is like now we are going

02:26:04,860 --> 02:26:09,150
to if we're going to add support for

02:26:07,050 --> 02:26:12,511
PowerPC isn't the right time to relook

02:26:09,150 --> 02:26:14,940
back and start you know separating the

02:26:12,511 --> 02:26:17,280
arc dependent bits and our independent

02:26:14,940 --> 02:26:21,240
bits which would mean that changing the

02:26:17,280 --> 02:26:23,730
check dot C file into like habitus like

02:26:21,240 --> 02:26:27,271
and our directory as such and then we

02:26:23,730 --> 02:26:30,420
just start putting the bits like the

02:26:27,271 --> 02:26:32,340
common core - velocity yeah now would be

02:26:30,420 --> 02:26:34,230
the right way to do rap yeah that was

02:26:32,340 --> 02:26:37,440
kind of the original intention of how

02:26:34,230 --> 02:26:38,700
laid the code out check that C was

02:26:37,440 --> 02:26:41,400
supposed to be a common and arch was

02:26:38,700 --> 02:26:43,710
supposed to be ours but it was just a

02:26:41,400 --> 02:26:46,650
first effort and I'm sure that I got

02:26:43,710 --> 02:26:49,080
missed a lot of things and the reason

02:26:46,650 --> 02:26:50,610
why I'm saying is like if I'm just going

02:26:49,080 --> 02:26:52,620
to be for PowerPC we can just do the if

02:26:50,610 --> 02:26:54,030
this will work but given that the number

02:26:52,620 --> 02:26:55,891
of architectures you are going to add

02:26:54,030 --> 02:26:57,990
now it'll be you know the clean way to

02:26:55,891 --> 02:27:00,150
do is like just having our directory and

02:26:57,990 --> 02:27:02,460
so our directory here would mean like

02:27:00,150 --> 02:27:04,980
from the discussion I feel that we would

02:27:02,460 --> 02:27:09,480
need it for the orc as well as for check

02:27:04,980 --> 02:27:13,650
or how are we going to do that I mean so

02:27:09,480 --> 02:27:16,950
say the organ grinder because a 390 or

02:27:13,650 --> 02:27:18,511
that would need there would be like Ark

02:27:16,950 --> 02:27:20,280
specific bits which will go into that

02:27:18,511 --> 02:27:24,290
also and we'll have check which would

02:27:20,280 --> 02:27:24,290
have be like again Ark specific bits

02:27:28,480 --> 02:27:35,300
so also should we do it let's do the

02:27:32,510 --> 02:27:37,510
check dot see first for you know start

02:27:35,300 --> 02:27:40,280
with check dot see where we have the our

02:27:37,510 --> 02:27:44,750
separation and then gradually keep

02:27:40,280 --> 02:27:46,610
adding things I'm like should it maybe I

02:27:44,750 --> 02:27:52,061
need to look at the code it's been a

02:27:46,610 --> 02:27:54,170
while so one thing which would mean

02:27:52,061 --> 02:27:56,750
adding support for object always like

02:27:54,170 --> 02:27:59,271
identifying the sites where we don't

02:27:56,750 --> 02:28:01,311
need enforcement we exactly know that

02:27:59,271 --> 02:28:05,771
you know what we are doing is right and

02:28:01,311 --> 02:28:08,900
it's okay so that's one exercise which

02:28:05,771 --> 02:28:12,500
RPC would need especially with the async

02:28:08,900 --> 02:28:16,040
code as such and yeah PowerPC comes with

02:28:12,500 --> 02:28:20,780
its own things with my experience with J

02:28:16,040 --> 02:28:22,190
patch build I'm sure there will be

02:28:20,780 --> 02:28:23,540
certain things which would need some

02:28:22,190 --> 02:28:25,670
exceptions or certain way of doing

02:28:23,540 --> 02:28:29,811
things which might change the object

02:28:25,670 --> 02:28:32,030
tool a little I don't have anything on

02:28:29,811 --> 02:28:34,550
top of my head because as if now what I

02:28:32,030 --> 02:28:37,670
have currently working just like just

02:28:34,550 --> 02:28:39,530
making sure the frame resistor status

02:28:37,670 --> 02:28:42,440
like perfect I mean the that's the point

02:28:39,530 --> 02:28:44,780
I've reached now and one thing which I

02:28:42,440 --> 02:28:46,700
would like to do is like update the

02:28:44,780 --> 02:28:49,460
documentation on whatever finding which

02:28:46,700 --> 02:28:50,900
goes on power as such so the major

02:28:49,460 --> 02:28:55,760
question would be the last one the

02:28:50,900 --> 02:28:59,390
compiler independence thing which so are

02:28:55,760 --> 02:29:02,360
we going to go the way of using GCC

02:28:59,390 --> 02:29:04,010
plugin because I stopped my work there

02:29:02,360 --> 02:29:07,070
at the point to because

02:29:04,010 --> 02:29:11,360
should we try DCC plugin also because

02:29:07,070 --> 02:29:16,670
this would be like um yeah I had a plan

02:29:11,360 --> 02:29:19,640
to ease the obj to a port other arches

02:29:16,670 --> 02:29:25,640
in that plan involved using a compiler

02:29:19,640 --> 02:29:27,771
plug-in leanness happened to be on CC

02:29:25,640 --> 02:29:28,190
when I mention this and he said don't do

02:29:27,771 --> 02:29:32,050
that

02:29:28,190 --> 02:29:34,460
at least for another few years because

02:29:32,050 --> 02:29:38,470
they you know there's there's a

02:29:34,460 --> 02:29:40,500
perception that GCC plugins are aren't

02:29:38,470 --> 02:29:44,940
stable yet first circle maybe

02:29:40,500 --> 02:29:47,640
for older versions of DCC so I think

02:29:44,940 --> 02:29:49,830
it's something we should look at and it

02:29:47,640 --> 02:29:53,430
might help this now that all of a sudden

02:29:49,830 --> 02:29:56,870
we need other architecture support maybe

02:29:53,430 --> 02:30:01,650
we could look at it again now it's

02:29:56,870 --> 02:30:03,270
because yeah I think RTL just reading

02:30:01,650 --> 02:30:05,370
the RTL pass and just making sure the

02:30:03,270 --> 02:30:10,020
annotations are there would ease up a

02:30:05,370 --> 02:30:15,410
little yeah I think you could use a

02:30:10,020 --> 02:30:20,970
plug-in to annotate certain certain

02:30:15,410 --> 02:30:23,250
important parts of control flow and and

02:30:20,970 --> 02:30:27,030
so hopefully that would help reduce a

02:30:23,250 --> 02:30:30,630
lot of the architecture specificity and

02:30:27,030 --> 02:30:33,030
uh I remember the solution which came

02:30:30,630 --> 02:30:34,890
out was like four different GCC version

02:30:33,030 --> 02:30:37,860
and every time that is going to be a

02:30:34,890 --> 02:30:39,660
different I mean the GCC version changes

02:30:37,860 --> 02:30:41,880
we have to make certain changes to the

02:30:39,660 --> 02:30:43,710
object pool as such so copying of that

02:30:41,880 --> 02:30:50,790
word is going to be like one big thing

02:30:43,710 --> 02:30:54,690
yeah it is it is a pain for over jato to

02:30:50,790 --> 02:30:56,910
keep up with GCC and some parts of some

02:30:54,690 --> 02:31:02,610
things are especially difficult like the

02:30:56,910 --> 02:31:06,300
switch tables yes um obj tool has a hard

02:31:02,610 --> 02:31:07,830
time finding those and and I I can just

02:31:06,300 --> 02:31:10,230
imagine on par and I'm sure we're gonna

02:31:07,830 --> 02:31:13,290
have like poverty wait does the switch

02:31:10,230 --> 02:31:15,540
label from when we analyzing the object

02:31:13,290 --> 02:31:17,400
code it does it in a very different

02:31:15,540 --> 02:31:18,750
fashion the way the ACM labels get

02:31:17,400 --> 02:31:21,240
generated it's going to be like really

02:31:18,750 --> 02:31:23,190
really tough for certain situations so I

02:31:21,240 --> 02:31:25,410
was just thinking about all those things

02:31:23,190 --> 02:31:27,750
but interesting thing would be like as

02:31:25,410 --> 02:31:30,420
you mentioned if you're going to have no

02:31:27,750 --> 02:31:32,100
optimization or the Jesus you will flag

02:31:30,420 --> 02:31:34,980
someone I don't know who suggested they

02:31:32,100 --> 02:31:39,090
will fly if if that comes and I'm sure

02:31:34,980 --> 02:31:42,600
at least it would ease a little of the

02:31:39,090 --> 02:31:45,450
decoupling of Jesus I'm not sure I'm

02:31:42,600 --> 02:31:48,540
like I'm not sure I'm not sure so far I

02:31:45,450 --> 02:31:51,240
don't think obj tool has had any trouble

02:31:48,540 --> 02:31:53,740
with those interprocedural optimizations

02:31:51,240 --> 02:31:56,561
that said cape hatch build

02:31:53,740 --> 02:31:59,320
had a lot of trouble with this okay I

02:31:56,561 --> 02:32:02,051
know it will help there so uh one

02:31:59,320 --> 02:32:03,820
solution would be like as if now when

02:32:02,051 --> 02:32:06,040
the other architectures just they're

02:32:03,820 --> 02:32:07,091
trying to know do the reliable stack

02:32:06,040 --> 02:32:09,181
trace

02:32:07,091 --> 02:32:13,120
it'll be nice if they can even identify

02:32:09,181 --> 02:32:15,910
decides which they think it's like can

02:32:13,120 --> 02:32:17,771
be no is okay if you know the object

02:32:15,910 --> 02:32:20,620
will you know doesn't analyze this this

02:32:17,771 --> 02:32:24,641
particular site kind of thing so that's

02:32:20,620 --> 02:32:26,681
something which I'm not sure if as part

02:32:24,641 --> 02:32:28,990
of putting the object tool they want to

02:32:26,681 --> 02:32:31,391
do that because if anyways if you're

02:32:28,990 --> 02:32:34,570
going to do the independent thing so

02:32:31,391 --> 02:32:36,040
most of the bits would be there and so

02:32:34,570 --> 02:32:37,990
the dead end has always been a problem

02:32:36,040 --> 02:32:43,330
to identify what would be the tail call

02:32:37,990 --> 02:32:47,580
or the the end of parsing of or

02:32:43,330 --> 02:32:47,580
following the different function calls

02:32:55,141 --> 02:33:07,990
so yeah yeah please so I'm just coming

02:33:03,820 --> 02:33:09,940
over the questions which I had it

02:33:07,990 --> 02:33:11,551
started up last year and numbered this

02:33:09,940 --> 02:33:15,160
number and we figured out that you know

02:33:11,551 --> 02:33:17,440
we can reliably walk through these tacks

02:33:15,160 --> 02:33:19,631
and we really don't need object tool or

02:33:17,440 --> 02:33:21,671
search for PowerPC and given that that

02:33:19,631 --> 02:33:23,501
is an interest now so if you're going to

02:33:21,671 --> 02:33:25,541
restart we better do it in the way which

02:33:23,501 --> 02:33:27,521
would like scale for everyone not just

02:33:25,541 --> 02:33:28,681
do it for power so that's the whole

02:33:27,521 --> 02:33:32,711
point

02:33:28,681 --> 02:33:36,761
is there a way to disable that chain no

02:33:32,711 --> 02:33:38,471
no no so that was a major question right

02:33:36,761 --> 02:33:41,561
for all the questions you asked for the

02:33:38,471 --> 02:33:43,091
discussion just now you had that booth

02:33:41,561 --> 02:33:44,891
that's not possible at all so we can

02:33:43,091 --> 02:33:46,091
label the you know say that you know

02:33:44,891 --> 02:33:49,091
that is going to be a page fault or if

02:33:46,091 --> 02:33:57,511
there is going to be any exceptions the

02:33:49,091 --> 02:33:57,511
exception markers come on the stack so

02:33:57,961 --> 02:34:06,280
what exactly is this plug-in being used

02:34:02,261 --> 02:34:08,740
for an obstacle I mean I work on GCC by

02:34:06,280 --> 02:34:11,681
the way so why and why is this remaining

02:34:08,740 --> 02:34:14,501
a plug-in I mean after you've prototyped

02:34:11,681 --> 02:34:16,961
it why isn't there now already a process

02:34:14,501 --> 02:34:19,360
or is there or when will there be to

02:34:16,961 --> 02:34:22,181
convert this into an actual feature

02:34:19,360 --> 02:34:27,690
directly in GCC and potentially clang

02:34:22,181 --> 02:34:27,690
why is this remaining still a plug-in

02:34:28,631 --> 02:34:36,221
there's no plug-in yet it was it was a

02:34:31,990 --> 02:34:37,690
hypothetical so if once we get to that

02:34:36,221 --> 02:34:40,211
point well actually I guess there is one

02:34:37,690 --> 02:34:41,530
plug-in it's we have it in the queue

02:34:40,211 --> 02:34:44,381
patch right listen

02:34:41,530 --> 02:34:48,131
it's a obj2 itself there's no plug-in

02:34:44,381 --> 02:34:50,801
but it's a valid point that if we if and

02:34:48,131 --> 02:34:53,740
when we do get plugins it's a sign that

02:34:50,801 --> 02:34:58,990
perhaps you know that functionality

02:34:53,740 --> 02:35:00,461
could be moved to GCC so that thing just

02:34:58,990 --> 02:35:03,341
you move it to move it but saying

02:35:00,461 --> 02:35:05,261
plugins are a great way to prototype new

02:35:03,341 --> 02:35:07,391
functionality but this is something that

02:35:05,261 --> 02:35:09,641
really needs to be maintained

02:35:07,391 --> 02:35:11,980
in the longer term that wasn't the

02:35:09,641 --> 02:35:13,511
intention of plugins and plugins I mean

02:35:11,980 --> 02:35:15,370
I'm not sure exactly the conversation

02:35:13,511 --> 02:35:17,200
with Lina's but it's never gonna be a

02:35:15,370 --> 02:35:19,181
stable interface it's always going to be

02:35:17,200 --> 02:35:21,400
changing because you're using internal

02:35:19,181 --> 02:35:25,091
infrastructure internal API is in the

02:35:21,400 --> 02:35:27,400
compiler so it's not intended to be some

02:35:25,091 --> 02:35:28,811
sort of a long-term oh you'll just plug

02:35:27,400 --> 02:35:31,061
in you compile it once and it'll be

02:35:28,811 --> 02:35:34,061
usable later so it's really intended if

02:35:31,061 --> 02:35:36,190
this is something that's necessary for I

02:35:34,061 --> 02:35:37,841
mean which is a great feature I mean

02:35:36,190 --> 02:35:41,080
this is just something that sounds like

02:35:37,841 --> 02:35:43,330
there should at least be a plan for I

02:35:41,080 --> 02:35:46,150
mean some either you know you know your

02:35:43,330 --> 02:35:48,341
team or the GCC team in in in you know

02:35:46,150 --> 02:35:50,070
sushi and red having others but one you

02:35:48,341 --> 02:35:53,051
know planning that this will be

02:35:50,070 --> 02:35:55,511
implemented or proposed as a feature so

02:35:53,051 --> 02:35:56,801
we can stand engaging the canoe

02:35:55,511 --> 02:35:58,181
toolchain community and the Klang

02:35:56,801 --> 02:36:00,280
community as well so that we have a

02:35:58,181 --> 02:36:02,591
well-defined interface that everybody

02:36:00,280 --> 02:36:04,660
can agree upon for how this is going to

02:36:02,591 --> 02:36:06,880
work but you know having a you know a

02:36:04,660 --> 02:36:10,360
really conformance spec for this is

02:36:06,880 --> 02:36:11,320
after this it gets prototype time it's

02:36:10,360 --> 02:36:13,301
not a matter of just that you need to

02:36:11,320 --> 02:36:15,250
have day one but you know just

02:36:13,301 --> 02:36:16,601
understanding that's the process and not

02:36:15,250 --> 02:36:18,551
just sort of showing up and saying well

02:36:16,601 --> 02:36:20,980
this sort of works now and we sort of

02:36:18,551 --> 02:36:22,360
like this and you know you know every

02:36:20,980 --> 02:36:24,011
not that it needs to be this you know

02:36:22,360 --> 02:36:26,530
full language spec but something it's a

02:36:24,011 --> 02:36:29,681
little bit defined so that everybody can

02:36:26,530 --> 02:36:31,811
you know can start you know agreeing on

02:36:29,681 --> 02:36:34,750
a GoSee an understanding whether this is

02:36:31,811 --> 02:36:36,730
really maintainable in the long term how

02:36:34,750 --> 02:36:38,561
this is going to be impacted with as

02:36:36,730 --> 02:36:39,610
we're discussing optimizations to

02:36:38,561 --> 02:36:42,311
compile or anything else just to

02:36:39,610 --> 02:36:44,051
understand whether it's it's doable in

02:36:42,311 --> 02:36:45,851
general for instance on multiple

02:36:44,051 --> 02:36:48,130
architectures I mean some things that

02:36:45,851 --> 02:36:51,250
are just sort of well it works on x86

02:36:48,130 --> 02:36:53,771
well yeah it works I mean but that

02:36:51,250 --> 02:36:56,440
doesn't mean it's actually you know safe

02:36:53,771 --> 02:36:59,320
you know reliable it's robust so you

02:36:56,440 --> 02:37:00,700
know just to under not you know tomorrow

02:36:59,320 --> 02:37:02,410
we need this but it's a matter of just

02:37:00,700 --> 02:37:03,851
you know thinking ahead of how this is

02:37:02,410 --> 02:37:05,980
going to work because this is clearly is

02:37:03,851 --> 02:37:07,480
a functionality that that's going to be

02:37:05,980 --> 02:37:11,830
necessary and how they're to make this

02:37:07,480 --> 02:37:15,610
implement it in a robust manner fair

02:37:11,830 --> 02:37:18,540
enough yeah as as we move forward we'll

02:37:15,610 --> 02:37:22,740
we'll engage and

02:37:18,540 --> 02:37:26,011
go from there yeah but to mention it did

02:37:22,740 --> 02:37:28,860
the Jesus plug in to solve a major

02:37:26,011 --> 02:37:31,620
problem for me in PowerPC as such so

02:37:28,860 --> 02:37:36,841
what happens is like you have a sibling

02:37:31,620 --> 02:37:39,240
call and it doesn't need an OP so the

02:37:36,841 --> 02:37:41,280
reason beings like the LR restore is not

02:37:39,240 --> 02:37:43,561
needed and now when you're building a

02:37:41,280 --> 02:37:45,271
binary comparison I mean binary compared

02:37:43,561 --> 02:37:47,160
way of doing it that would mean that

02:37:45,271 --> 02:37:50,971
that function which was a sibling call

02:37:47,160 --> 02:37:53,730
is now an export so now how do you

02:37:50,971 --> 02:37:56,940
insert a knob I mean you need a knob

02:37:53,730 --> 02:37:59,490
there and the knob is missing so Jesus

02:37:56,940 --> 02:38:01,051
is plugging it I know help us there Josh

02:37:59,490 --> 02:38:02,940
wrote it yeah

02:38:01,051 --> 02:38:07,561
so I'm just saying you want particle

02:38:02,940 --> 02:38:09,780
example but so you're thinking if we can

02:38:07,561 --> 02:38:12,000
just do the same thing with RTL I mean

02:38:09,780 --> 02:38:12,421
passing the same pass and just if you

02:38:12,000 --> 02:38:17,521
can do it

02:38:12,421 --> 02:38:25,051
they could be a couple lot of things

02:38:17,521 --> 02:38:27,030
that was the idea I mean this I think is

02:38:25,051 --> 02:38:31,471
the broader problem they're not exactly

02:38:27,030 --> 02:38:33,511
sure what what forum we want to discuss

02:38:31,471 --> 02:38:36,211
it because I mean said there was this

02:38:33,511 --> 02:38:37,711
que patch there's there's you know this

02:38:36,211 --> 02:38:40,261
I mean they're just a lot of places

02:38:37,711 --> 02:38:44,061
where you know it's a it's a trade-off

02:38:40,261 --> 02:38:47,370
between optimizations and how much the

02:38:44,061 --> 02:38:50,131
you know the code is really you know

02:38:47,370 --> 02:38:52,530
modular and really isolated so that one

02:38:50,131 --> 02:38:55,290
can perform these sorts of replacements

02:38:52,530 --> 02:38:59,761
and I'm not sure and I mean I guess what

02:38:55,290 --> 02:39:00,990
what it seems like we I mean that not to

02:38:59,761 --> 02:39:03,360
like oh community committees and stuff

02:39:00,990 --> 02:39:04,381
but like I mean I'm not sure well what I

02:39:03,360 --> 02:39:06,631
haven't heard from all these different

02:39:04,381 --> 02:39:09,931
conversations throughout this this

02:39:06,631 --> 02:39:12,841
entire week is if there really is a

02:39:09,931 --> 02:39:15,450
single definition that all of these

02:39:12,841 --> 02:39:18,601
different uses can agree upon or if we

02:39:15,450 --> 02:39:20,940
really need I mean again up there

02:39:18,601 --> 02:39:23,730
balancing performance as well but if if

02:39:20,940 --> 02:39:25,410
we really need to have a separate switch

02:39:23,730 --> 02:39:27,511
for every single one of these different

02:39:25,410 --> 02:39:30,120
use cases that there's something that we

02:39:27,511 --> 02:39:31,891
there's a common denominator that we can

02:39:30,120 --> 02:39:32,310
find that that's a balance like okay

02:39:31,891 --> 02:39:33,600
with this need

02:39:32,310 --> 02:39:34,770
IPA this doesn't need to I pay the

02:39:33,600 --> 02:39:36,869
sneeze I'm letting this doesn't need

02:39:34,770 --> 02:39:38,489
inlining this needs no no you know

02:39:36,869 --> 02:39:40,229
sibling calls with assembly I mean it's

02:39:38,489 --> 02:39:42,540
like how many of these difference it's

02:39:40,229 --> 02:39:44,640
gonna be a very complicated matrix I

02:39:42,540 --> 02:39:47,640
mean it's possible but I don't think

02:39:44,640 --> 02:39:52,020
anybody is really it doesn't sound like

02:39:47,640 --> 02:39:55,170
anybody has done that full analysis get

02:39:52,020 --> 02:39:57,270
much or two but but of you know really

02:39:55,170 --> 02:39:59,100
deciding if this this level of

02:39:57,270 --> 02:40:01,380
granularity of differentiation for each

02:39:59,100 --> 02:40:03,840
of these different cases is necessary or

02:40:01,380 --> 02:40:06,060
it's just sort of again well this is

02:40:03,840 --> 02:40:07,560
what we found was a problem for x86 and

02:40:06,060 --> 02:40:10,439
this is a problem we found and then and

02:40:07,560 --> 02:40:13,560
there without any real sort of coming to

02:40:10,439 --> 02:40:17,159
a you know a common denominator and so I

02:40:13,560 --> 02:40:21,359
think that well I think there's been

02:40:17,159 --> 02:40:24,409
some effort towards having a single GCC

02:40:21,359 --> 02:40:29,670
flag for disabling those intra

02:40:24,409 --> 02:40:32,520
object optimizations so this thing we

02:40:29,670 --> 02:40:35,250
have the dishes he plugin for for

02:40:32,520 --> 02:40:40,460
inserting the knobs maybe that could

02:40:35,250 --> 02:40:40,460
also be moved into that same flag

02:40:43,750 --> 02:40:51,250
so yep that's the discussion I want her

02:40:47,780 --> 02:40:51,250
to have and yeah thank you

02:40:51,520 --> 02:40:55,079

YouTube URL: https://www.youtube.com/watch?v=UUUW1wdoVOU


